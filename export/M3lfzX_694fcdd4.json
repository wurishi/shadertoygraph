{"ver":"0.1","info":{"id":"M3lfzX","date":"1728729157","viewed":203,"name":"color noise3","username":"nayk","description":"originals  https://www.shadertoy.com/view/MdXSzS https://www.shadertoy.com/view/lXffD8","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["fractal","noise","color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n#define VIEW_LAYER 3\n\n\n#define PI (3.141)\n#define MAX_ITERATIONS (16)\n#define ITERATIONS 10\n\n\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\n\nfloat circSdf(vec2 uv, float r) {\n    return length(uv) - r;\n}\n\n\nvec2 fold(vec2 uv, float theta) {\n    vec2 normal = vec2(cos(-theta), sin(-theta));\n    float d = dot(uv, normal);\n    return uv - (2. * min(0., d) * normal);\n}\n\n\nvec2 sierpinskiKifs(vec2 uv, int N) {\n    uv -= vec2(-0.5, 0.);\n    for(int i = 0; i < 22; i++) {\n        if (i >= N) { break; }\n        uv *= 1.5;\n        uv.x -=2.5;\n            float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;\n        float animationSpeed = 0.5;\n   \n        uv = fold(uv,1.);\n    \tuv = fold(uv, -PI/6.);\n    }\n    return uv;\n}\n\n\nvec2 mengerKifs(vec2 uv, int N) {\n    for(int i = 0; i < 12; i++) {\n        if (i >= N) { break; }\n            float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 20.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;\n        uv *= 3.;  \n       \n        uv.x -= 1.*sqrt(2.);\n    }\n    return uv;\n}\n\n\n// Menger Kifs\nfloat viewLayerMenger(vec2 uv) {\n    //return vec3(1.);\n\n    vec2 mengerUv = mengerKifs(uv, ITERATIONS);\n    float cSdf = circSdf(mengerUv, 1.);\n    float pixelSize = (2. * pow(3., float(ITERATIONS))) / iResolution.x;\n    float c = smoothstep(2.*pixelSize, 0., cSdf);\n    return c;\n}\n\n\n// Sierpinski Kifs\nfloat viewLayerSierpinski(vec2 uv) {\n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 20.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;\n\n    vec2 sierpinskiUv = sierpinskiKifs(uv, ITERATIONS+2);\n    float cSdf = circSdf(sierpinskiUv, 1.);\n    float pixelSize = (2. * pow(3., float(ITERATIONS))) / iResolution.x;\n    float c = smoothstep(2.*pixelSize, 0., cSdf);\n    return c;\n}\n\n// Menger+Sierpinski\nfloat viewLayerMerge(vec2 uv) {\n\n\n    vec2 hybridUv = sierpinskiKifs(uv, ITERATIONS);\n    hybridUv = mengerKifs(hybridUv, ITERATIONS);\n    float cSdf = circSdf(hybridUv, 1.);\n    float pixelSize = (1. * (pow(3., float(ITERATIONS)) * pow(2., float(ITERATIONS)))) / iResolution.x;\n    float c = smoothstep(2.*pixelSize, 0., cSdf);\n    return c;\n}\n\n\n// Tiled Menger + Sierpinski\nfloat viewLayerTiling(vec2 uv) {\n\n    float globalScale = 2.000;\n    uv *= globalScale;\n    uv *= rotate2d(PI / 2.);\n    vec2 tileIdx = floor(uv);\n    float flipSign = (2.*mod(floor(tileIdx.y), 2.)) - 1.;\n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 20.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;\n    uv = fract(uv);\n\n    vec2 hybridUv = sierpinskiKifs(uv, ITERATIONS);\n    hybridUv = mengerKifs(hybridUv, ITERATIONS);\n    float cSdf = circSdf(hybridUv, 1.);\n    float pixelSize = (2. * globalScale * pow(3., float(ITERATIONS+1))) / iResolution.x;\n    float c = smoothstep(2.*pixelSize, 0., cSdf);\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n      \n    float globalScale = 0.5;\n    uv *= globalScale;\n    \n    float c = 0.;\n    if (VIEW_LAYER == 1) {\n        c = viewLayerMenger(uv);\n    } else if (VIEW_LAYER == 2) {\n        c = viewLayerSierpinski(uv);\n    } else if (VIEW_LAYER == 3) {\n        c = viewLayerMerge(uv);\n    } else if (VIEW_LAYER == 4) {\n        c = viewLayerTiling(uv);\n    } else {\n        c = 0.;\n    }\n    \n    vec3 color = vec3(0.165,0.123,0.130);\n    color = mix(color, vec3(0.750,0.909,0.975), c);\n        float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 5.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;\n    for (float i = 0.0; i < 2.0; i++) {\n        uv = fract(uv*color.xy* 2.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*12. + iTime)/24.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.5);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}