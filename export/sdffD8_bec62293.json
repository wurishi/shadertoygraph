{"ver":"0.1","info":{"id":"sdffD8","date":"1674424869","viewed":14,"name":"VG Raymarching primitives","username":"Sheldier","description":"Primitives","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100.\n#define MAX_DISTANCE 100.\n#define SURF_DIST .01\nfloat SDCapsule(vec3 p, vec3 a, vec3 b, float rad){\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot (ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t*ab;\n    return length(p-c)-rad;\n    \n}\nfloat SDCylinder(vec3 p, vec3 a, vec3 b, float rad){\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot (ab, ab);\n    vec3 c = a + t*ab;\n    float x = length(p-c)-rad;\n    float y = abs((t-.5)-.5) * length(ab);\n    float e = length(max(vec2(x,y), 0.));\n    float i = min(max(x,y), 0.);\n    return e+i;\n    \n}\nfloat SDTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\nfloat DBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s, 0.));\n}\n\nfloat GetDist(vec3 point){\n    vec4 sphere = vec4(0, 1, 6, 1);\n    float sphereDist = length(point - sphere.xyz)-sphere.w;\n    float planeDist = point.y;\n    \n    \n    float cd = SDCapsule(point, vec3(.3, 0.5, 6), vec3(1,2,6), .5);\n    float td = SDTorus(point-vec3(0,.5,6), vec2(1.5, .3));\n    float bd = DBox(point-vec3(-3, .75, 6), vec3(.75));\n    float cyld = SDCylinder(point, vec3(1, 0.5, 1), vec3(3,0.5,6), .5);\n    float totalDistance = min(cd, planeDist);\n    totalDistance = min(totalDistance, td);\n    totalDistance= min(totalDistance, bd);\n    totalDistance = min(totalDistance, cyld);\n    return totalDistance;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir){\n    float originDistance = 0.;\n    \n    for(float i = 0.; i < MAX_STEPS; i++){\n        vec3 currentMarchingLocation = rayOrigin + rayDir*originDistance;\n        float distanceToScene = GetDist(currentMarchingLocation);\n        originDistance += distanceToScene;\n        if(originDistance > MAX_DISTANCE || distanceToScene < SURF_DIST) break;\n    }\n    \n    return originDistance;\n}\nvec3 GetNormal(vec3 point){\n    float dist = GetDist(point);\n    vec2 e = vec2(.01, 0);\n    vec3 n = dist - vec3(\n        GetDist(point - e.xyy),\n        GetDist(point - e.yxy),\n        GetDist(point - e.yyx)\n    );\n    return normalize(n);\n}\nfloat GetLight(vec3 pointToShade){\n    vec3 lightPos = vec3(0., 5., 6.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 l = normalize(lightPos - pointToShade);\n    vec3 n = GetNormal(pointToShade);\n    float diffuse = clamp(dot(l,n),0.,1.);\n    float d = RayMarch(pointToShade + n * SURF_DIST * 2., l);\n    if(d<length(lightPos - pointToShade)) diffuse *= .1;\n    return diffuse;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 camPos = vec3(0, 2., 0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y -.2, 1));\n\n    float dist = RayMarch(camPos, rayDir);\n    \n    vec3 pointToShade = camPos + rayDir * dist;\n    float diffuse = GetLight(pointToShade);\n    //dist /= 6.;\n    col = vec3(diffuse);\n    //col = GetNormal(pointToShade);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}