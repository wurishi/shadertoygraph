{"ver":"0.1","info":{"id":"fsjfRc","date":"1647302950","viewed":181,"name":"Sound Only - Waiting For Death","username":"zurashu","description":"Sound only.\n\nSmall shader practice.\n\nI tried to eliminate  the leak on the sides of the monoliths (more noticeable when zoomed out) but couldn't.\n\nAlso wanted to add glow to the bottom lights without a second pass. Tried some ideas, none worked ðŸ˜…","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["sound","only","eva","seele"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 2d sdf shapes from: https://iquilezles.org/articles/distfunctions2d\n\n#define AA 2\n\n#define PI 3.1415926536\n\n#define TO_LINEAR(X) pow(X,vec3(2.2))\n\nconst float baseHalfWidth = 0.3;\nconst float baseRound = 0.13;\nconst float halfThick = 0.09;\nconst float halfThin = 0.05;\n\nconst int MaxSteps = 100;\nconst float MaxDist = 40.0;\nconst float DistEps = 0.001;\n\nconst vec3 BackgroundColor = TO_LINEAR(vec3(0.05));\nconst vec3 MonolithBlack = TO_LINEAR(vec3(0.125, 0.114, 0.227));\nconst vec3 MonolithLight = TO_LINEAR(vec3(0.365, 0.322, 0.592));\n\n\nmat2 rotation(in float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 rotate(in vec2 v, in float a) \n{\n    a *= PI / 180.0;\n    return rotation(a) * v;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat charZero(in vec2 pos) \n{\n    float sd = sdRoundedBox(pos,vec2(baseHalfWidth,0.5),vec4(baseRound));\n    sd = max(sd, -sdRoundedBox(pos,vec2(baseHalfWidth-halfThick*2.0,0.5-halfThin*2.0),vec4(0.02)));\n    sd = min(sd, sdRoundedBox(rotate(pos,45.0),vec2(halfThin,0.3),vec4(0.0)));\n    return sd;\n}\n\nfloat charOne(in vec2 pos)\n{\n    float sd = sdRoundedBox(pos,vec2(0.1,0.5),vec4(0.01));    \n    sd = min(sd, sdRoundedBox(pos+vec2(0.1,-0.39),vec2(0.18,0.1),vec4(0.01))); \n    float sdd = length(pos+vec2(0.25,-0.6))-0.2;\n    sdd = min(sdd, sdRoundedBox(pos - vec2(-0.35, 0.589),vec2(0.18,0.18),vec4(0.0)));\n    sd = max(sd, -sdd);\n\n    return sd;\n}\n\nfloat charTwo(in vec2 pos) \n{\n    float sd = sdRoundedBox(pos,vec2(baseHalfWidth,0.5),vec4(baseRound));\n    sd = max(sd, -sdRoundedBox(pos,vec2(baseHalfWidth-halfThick*2.0,0.5-halfThick*2.0),vec4(baseRound/2.0)));\n    sd = max(sd, -sdRoundedBox(pos+vec2(0.0,0.35),vec2(0.8,0.5),vec4(0.0)));\n    sd = min(sd, sdRoundedBox(pos+vec2(0.0,0.5-halfThick),vec2(baseHalfWidth,halfThick),vec4(0.0)));\n    float sdd = sdRoundedBox(rotate(pos+vec2(0.0,0.1),41.0),vec2(halfThick,0.4),vec4(0.0));\n    sdd = max(sdd,-sdRoundedBox(pos+vec2(baseHalfWidth+0.5,0.0),vec2(0.5,0.5),vec4(0.0)));\n    sdd = max(sdd,-sdRoundedBox(pos-vec2(baseHalfWidth+0.5,0.0),vec2(0.5,0.5),vec4(0.0)));\n    return min(sd,sdd);\n}\n\nfloat charThree(in vec2 pos) \n{\n    float sd = sdRoundedBox(pos+vec2(0.0,0.25),vec2(baseHalfWidth,0.25),vec4(baseRound));\n    sd = max(sd,-sdRoundedBox(pos+vec2(0.0,0.22),vec2(0.14,0.12),vec4(baseRound/2.0)));\n    \n    sd = min(sd, sdRoundedBox(pos-vec2(0.0,0.25),vec2(baseHalfWidth,0.25),vec4(baseRound)));\n    sd = max(sd,-sdRoundedBox(pos-vec2(0.0,0.22),vec2(0.14,0.12),vec4(baseRound/2.0)));\n    \n    sd = max(sd,-sdRoundedBox(pos+vec2(0.25,0.0),vec2(0.2,0.18),vec4(0.0)));\n    return sd;\n}\n\nfloat charFour(in vec2 pos) \n{\n    float sd = sdRoundedBox(pos+vec2(0.0,0.25),vec2(baseHalfWidth, halfThick),vec4(0.0));\n    sd = min(sd, sdRoundedBox(pos-vec2(0.13,0.0),vec2(halfThick, 0.5),vec4(0.0)));\n    float sdd = sdRoundedBox(rotate(pos+vec2(0.1,-0.1),22.0)-vec2(0.0, 0.06),vec2(halfThick,0.5),vec4(0.0));\n    sdd = max(sdd, sdRoundedBox(pos, vec2(baseHalfWidth, 0.5), vec4(0.0)));\n    return min(sd, sdd);\n}\n\nfloat charFive(in vec2 pos) \n{\n    float sd = sdRoundedBox(pos+vec2(0.0,0.18), vec2(baseHalfWidth,0.32),vec4(baseRound));\n    sd = max(sd, -sdRoundedBox(pos+vec2(0.0,0.19),vec2(0.14,0.17),vec4(baseRound/2.0)));\n    sd = max(sd, -sdRoundedBox(pos+vec2(0.2, 0.18), vec2(0.23, 0.1), vec4(0.0)));\n    sd = min(sd, sdRoundedBox(pos+vec2(0.21, -0.23), vec2(halfThick, 0.25), vec4(0.0)));\n    sd = min(sd, sdRoundedBox(pos+vec2(0.015,-0.39), vec2(baseHalfWidth*0.94, halfThick), vec4(0.0)));\n    return sd;    \n}\n\nfloat charSix(in vec2 pos) \n{\n    float sd = sdRoundedBox(pos+vec2(0.0,0.2), vec2(baseHalfWidth,0.3),vec4(baseRound));\n    sd = max(sd, -sdRoundedBox(pos+vec2(0.0,0.2),vec2(0.14,0.17),vec4(baseRound/2.0)));\n\n    float sdd = sdRoundedBox(pos,vec2(baseHalfWidth,0.5),vec4(baseRound));\n    sdd = max(sdd, -sdRoundedBox(pos, vec2(baseHalfWidth-halfThick*2.0,0.5-halfThick*2.0),vec4(0.02)));\n    sdd = max(sdd, -sdRoundedBox(pos + vec2(0.0, 0.5), vec2(0.5, 0.5), vec4(0.0)));\n    sdd = max(sdd, -sdRoundedBox(pos - vec2(0.5, 0.05), vec2(0.5, 0.2), vec4(0.0)));\n    return min(sd, sdd);    \n}\n\nfloat charSeven(in vec2 pos)\n{\n    float sd = sdRoundedBox(pos+vec2(-0.003, 0.36),vec2(halfThick,0.14),vec4(0.01));    \n    sd = min(sd, sdRoundedBox(rotate(pos-vec2(0.084,-0.04),23.0)-vec2(0.0, 0.06), vec2(halfThick*0.95,0.3), vec4(0.0)));\n    sd = min(sd, sdRoundedBox(pos - vec2(0.0, 0.38), vec2(baseHalfWidth, halfThick), vec4(0.0)));\n    sd = min(sd, sdRoundedBox(pos - vec2(0.21, 0.35), vec2(halfThick, 0.1), vec4(0.0)));\n    return sd;\n}\n\nfloat charEight(in vec2 pos) \n{\n    float sd = sdRoundedBox(pos+vec2(0.0,0.25),vec2(baseHalfWidth,0.25),vec4(baseRound));\n    sd = max(sd,-sdRoundedBox(pos+vec2(0.0,0.25),vec2(0.14,0.12),vec4(baseRound/2.0)));\n\n    sd = min(sd, sdRoundedBox(pos-vec2(0.0,0.24),vec2(baseHalfWidth,0.25),vec4(baseRound)));\n    sd = max(sd,-sdRoundedBox(pos-vec2(0.0,0.22),vec2(0.14,0.12),vec4(baseRound/2.0)));\n\n    return sd;\n}\n\nfloat charNine(in vec2 pos) \n{\n    float sd = sdRoundedBox(pos-vec2(0.0,0.18),vec2(baseHalfWidth,0.3),vec4(baseRound));\n    sd = max(sd,-sdRoundedBox(pos-vec2(0.0,0.18),vec2(0.14,0.18),vec4(baseRound/2.0)));\n\n    sd = min(sd, sdRoundedBox(rotate(pos-vec2(0.084,-0.3),23.0)-vec2(0.0, 0.06), vec2(halfThick*0.95,0.23), vec4(0.0)));\n    \n    sd = min(sd, sdRoundedBox(pos + vec2(0.06, 0.41), vec2(0.15, 0.08), vec4(0.0)));\n\n    return sd;\n}\n\nfloat numberSDF(in vec2 pos, in int n) {\n    float sd = charZero(pos+vec2(0.35,0.0));\n    \n    if( n >= 10) {\n        pos.x += n == 11 ? 0.05 : 0.12;\n        sd = charOne(pos+vec2(0.2,0.0));\n    }\n \n    float nsd = 0.0;\n    \n    n  = n % 10;\n    \n    if(n == 0) {\n        nsd = charZero(pos-vec2(0.4,0.0));\n    } else if(n == 1) {\n        nsd = charOne(pos-vec2(0.38,0.0));\n    } else if(n == 2) {\n        nsd = charTwo(pos-vec2(0.38,0.0));\n    } else if(n == 3) {\n        nsd = charThree(pos-vec2(0.38,0.0));\n    } else if(n == 4) {\n        nsd = charFour(pos-vec2(0.38,0.0));\n    } else if(n == 5) {\n        nsd = charFive(pos-vec2(0.38,0.0));\n    } else if(n == 6) {\n        nsd = charSix(pos-vec2(0.38,0.0));\n    } else if(n == 7) {\n        nsd = charSeven(pos-vec2(0.38,0.0));\n    } else if(n == 8) {\n        nsd = charEight(pos-vec2(0.38,0.0));\n    } else if(n == 9) {\n        nsd = charNine(pos-vec2(0.38,0.0));\n    }\n    \n    return min(sd,nsd);\n}\n\n\nfloat hollowRoundedBox(in vec2 pos, in vec2 b, float r, float r2,float w) \n{\n    float sd = sdRoundedBox(pos, b, vec4(r));\n    sd = max(sd, -sdRoundedBox(pos, b - w, vec4(r2)));\n    return sd;\n}\n\nfloat charS(in vec2 pos) \n{\n    const float meet = 0.04;\n    float sd = hollowRoundedBox(pos - vec2(0, 0.25 - meet), vec2(0.8*0.5,0.25+meet), 0.2, 0.1, 0.15);\n    sd = max(sd, -sdRoundedBox(pos+vec2(-1.195, 0.8), vec2(1), vec4(0)));\n    \n    float sdd = min(sd, hollowRoundedBox(pos + vec2(0, 0.25 - meet), vec2(0.8*0.5,0.25+meet), 0.2, 0.1, 0.15));\n    sdd = max(sdd, -sdRoundedBox(pos + vec2(1.2, -0.78), vec2(1), vec4(0)));\n    \n    return min(sd, sdd);\n}\n\nfloat charE(in vec2 pos) \n{\n    const float th = 0.08;\n    pos.y = abs(pos.y);\n    float sd = sdRoundedBox(pos - vec2(0, 0.5 - th), vec2(0.35, th), vec4(0.01));\n    sd = min(sd, sdRoundedBox(pos, vec2(0.35, th), vec4(0.01)));\n    sd = min(sd, sdRoundedBox(pos + vec2(0.27, 0), vec2(th, 0.5), vec4(0.01)));\n    return sd;\n}\n\nfloat charL(in vec2 pos) \n{\n    const float th = 0.08;\n    float sd = sdRoundedBox(pos + vec2(0, 0.5 - th), vec2(0.25, th), vec4(0.01));\n    sd = min(sd, sdRoundedBox(pos + vec2(0.27, 0), vec2(th, 0.5), vec4(0.01)));\n    return sd;\n}\n\n\nfloat seeleSDF(in vec2 pos) \n{\n    pos *= 5.5;\n    float xoff = 1.75;\n    float sd = 99999.0; \n    sd = min(sd, charS(pos + vec2(xoff, 0)));\n    sd = min(sd, charE(pos + vec2(xoff - 0.96, 0)));\n    sd = min(sd, charE(pos + vec2(xoff - 1.9, 0)));\n    sd = min(sd, charL(pos + vec2(xoff - 2.85, 0)));\n    sd = min(sd, charE(pos + vec2(xoff - 3.65, 0)));\n    \n    return sd / 5.5;\n}\n\nfloat charO(in vec2 pos) \n{\n    float sd = sdRoundedBox(pos,vec2(0.35, 0.5),vec4(0.2));\n    sd = max(sd, -sdRoundedBox(pos,vec2(0.26, 0.36),vec4(0.2)));\n    return sd;\n}\n\nfloat charU(in vec2 pos) \n{\n    vec2 y = vec2(0, 0.2);\n    float sd = sdRoundedBox(pos - y, vec2(0.35, 0.7), vec4(0.2));\n    sd = max(sd, -sdRoundedBox(pos - y, vec2(0.23, 0.57), vec4(0.2)));\n    sd = max(sd, -sdRoundedBox(pos - vec2(0, 0.5 + 0.4), vec2(1,0.4), vec4(0)));\n    return sd;\n}\n\nfloat charN(in vec2 pos) \n{\n    float sd = sdRoundedBox(rotate(pos, -30.0),vec2(0.08,0.5),vec4(0.0));\n    \n    pos.x = abs(pos.x);\n    sd = min(sd, sdRoundedBox(pos - vec2(0.26, 0.0),vec2(0.07, 0.5),vec4(0.01)));\n    sd = max(sd, sdRoundedBox(pos,vec2(0.35, 0.5),vec4(0.001)));\n    return sd;\n}\n\nfloat charD(in vec2 pos) \n{\n    vec2 x = vec2(0.15, 0);\n    float sd = sdRoundedBox(pos + x,vec2(0.5, 0.5),vec4(0.2));\n    sd = max(sd, -sdRoundedBox(pos,vec2(0.26, 0.36),vec4(0.2)));\n    sd = max(sd, sdRoundedBox(pos,vec2(0.35, 0.5),vec4(0.001)));\n    return sd;\n}\n\nfloat soundSDF(in vec2 pos) {\n    pos *= 5.5;\n    float xoff = 1.9;\n    float sd = 99999.0;\n    sd = min(sd, charS(pos + vec2(xoff, 0)));\n    sd = min(sd, charO(pos + vec2(xoff - 1.03, 0)));\n    sd = min(sd, charU(pos + vec2(xoff - 2.02, 0)));\n    sd = min(sd, charN(pos + vec2(xoff - 3.0, 0)));\n    sd = min(sd, charD(pos + vec2(xoff - 3.96, 0)));\n\n    return sd / 5.5;  \n}\n\nfloat charY(in vec2 pos) \n{\n    float sd = 99999.9;\n    //sdRoundedBox(rotate(pos, -30.0),vec2(0.08,0.5),vec4(0.0));\n    sd = min(sd, sdRoundedBox(pos + vec2(0, 0.5), vec2(0.1,0.5), vec4(0)));\n    pos.x = abs(pos.x);\n    sd = min(sd, sdRoundedBox(rotate(pos + vec2(0.0,0.2), 30.0),vec2(0.08, 1.0),vec4(0.0)));\n    sd = max(sd, sdRoundedBox(pos, vec2(0.4, 0.5),vec4(0.001)));\n    return sd;\n}\n\nfloat onlySDF(in vec2 pos) {\n    pos *= 5.5;\n    float xoff = 1.42;\n    float sd = 99999.0;\n    sd = min(sd, charO(pos + vec2(xoff, 0)));\n    sd = min(sd, charN(pos + vec2(xoff - 1.03, 0)));\n    sd = min(sd, charL(pos + vec2(xoff - 2.03, 0)));\n    sd = min(sd, charY(pos + vec2(xoff - 2.8, 0)));\n    \n    return sd / 5.5;      \n}\n\nfloat soundOnlySDF(in vec2 pos, int n) \n{\n    pos *= 2.7;\n    pos.y -= 0.22;\n    float sd = 0.0;\n    \n    sd = numberSDF(pos, n);\n    \n    {\n        float sdd = seeleSDF(pos * 0.75 - vec2(0, 0.65))/0.75;\n        sd = min(sd, sdd);\n    }   \n    \n    {\n        float sdd = soundSDF(pos * 0.75 + vec2(0, 0.66))/0.75;\n        sd = min(sd, sdd);  \n    }\n\n    {\n        float sdd = onlySDF(pos * 0.75 + vec2(0, 0.92))/0.75;\n        sd = min(sd, sdd);  \n    }\n\n    return sd / 2.7;\n}\n\nvec4 soundOnlyTex(in vec2 pos, int n, float glow) \n{\n    float base = smoothstep(0.01, 0.0, soundOnlySDF(pos, n));\n    return vec4(1.0,0.0,0.0,1.0)*smoothstep(0.01,0.0,soundOnlySDF(pos, n));\n}\n\n\nfloat sdRoundBox(in vec3 p, in vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 monolithTransform(in vec3 pos, out float id)\n{\n    const float n = 12.0;\n    pos.xz = rotation(-iTime*0.08) * pos.xz;\n\n    pos.y -= 0.5;\n\n    float sectorSize = 2.0 * PI / n;\n    float sector = round(atan(pos.z, pos.x)/sectorSize);\n\n    id = mod(sector + n, n) + 1.0;\n\n    pos.xz = rotation(-sectorSize * sector) * pos.xz;\n    \n    pos.x -= 10.0;\n\n    pos.xz = rotation(-PI/2.0) * pos.xz;\n    \n    return pos;\n}\n\nconst float MonoThick = 0.15;\n// monolith mat: 1, id, p.z\n// white square mat: 2\nvec4 monoliths(in vec3 pos, out vec2 uv) \n{\n    float id;\n\n    pos = monolithTransform(pos, id);\n\n    uv = 0.6*(pos.xy - vec2(0, 1.5));\n    \n    float monoBox = sdRoundBox(pos, vec3(0.96, 3.0, MonoThick), 0.001);\n    \n    \n    float lightBox = sdRoundBox(pos - vec3(0, -4.5, 0), vec3(0.96, 0.04, 0.2), 0.01);\n\n\n    if(lightBox  < monoBox) {\n        return vec4(lightBox, 2, 0, 0);\n    }\n    \n\n    return vec4(monoBox, 1, id, pos.z);\n}\n\nvec4 scene(in vec3 pos, out vec2 uv) \n{\n    vec4 ret = monoliths(pos, uv);\n    \n    return ret;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd, out vec3 mat, out vec2 uv)\n{\n    float d = DistEps;\n    mat = vec3(-1);\n    \n    for(int i = 0; i < MaxSteps; i++) {\n    \tvec3 p = ro + rd * d;\n        vec4 sc  = scene(p, uv);\n        d += sc.x;\n        if(d > MaxDist || abs(sc.x) < DistEps) {\n            mat = sc.yzw;\n            break;\n        }\n    }\n\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 uv;\n\tfloat d = scene(p, uv).x;\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        scene(p-e.xyy, uv).x,\n        scene(p-e.yxy, uv).x,\n        scene(p-e.yyx, uv).x);\n    \n    return normalize(n);\n}\n\n\n//\t<https://www.shadertoy.com/view/4dS3Wd>\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\nfloat hash21(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n\n    vec3 total = vec3(0.0);\n    #if AA>1\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 off = vec2(float(i),float(j))/float(AA);\n    #else\n        vec2 off = vec2(0.0);\n    #endif  \n    \n    uv = (fragCoord + off - iResolution.xy * 0.5)/iResolution.y;\n\n    float by = 1.0 - uv.y - 0.5;\n    vec3 bgC = by * BackgroundColor + (1.0 - by) * BackgroundColor * 15.0;\n    \n    bgC += 0.005 * (hash21(uv) - 0.5);\n    \n    \n    vec3 col = bgC;\n    vec2 ruv;\n    vec3 mat;\n    \n    const float sharp = 0.45;\n    float camT = smoothstep(sharp, 1.0 - sharp, sin(iTime * PI * 2.0 / (BeatDuration * 32.0)) + 0.5);\n    \n\n    \n    vec3 ro = vec3(0, 0, 12.0 - camT*14.0);\n    vec3 rd = normalize(vec3(uv, -0.75));\n    float d = raymarch(ro, rd, mat, ruv);\n    \n    if(d < MaxDist) {\n        vec3 p = ro + rd * d;\n        if(mat.x < 1.5) {\n            col = MonolithLight;\n            \n            if(mat.z > MonoThick - 0.01) {\n                vec4 tCol = soundOnlyTex(ruv, int(mat.y), 0.01);\n                col = tCol.rgb + (1.0 - tCol.a) * MonolithBlack;  \n            } else if(mat.z < -MonoThick + 0.01) {\n                col = MonolithBlack;\n            }\n\n        } else if(mat.x < 2.5) {\n            col = vec3(1);\n        }\n    }\n\n    total += col;\n\n    #if AA>1\n    }\n\ttotal /= float(AA*AA);\n    #endif    \n\n    total = pow(total, vec3(1.0/2.2)); \n\n    fragColor = vec4(total,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Stuff learned and inspired from @athibaul great series\n// https://www.youtube.com/watch?v=3mteFftC7fE\n\n\n\n\n#define NOTE_TO_FREQ(FROM_C4) (exp2(( FROM_C4 - 9.0) / 12.0) * 440.0)\n#define TRANSP(F,SEMI) (F * exp2(SEMI / 12.0))\n#define NOTE_IN_OCTAVE(N, O) (NOTE_TO_FREQ(float( N + (O-4) * 12 )))\n#define C(O)   (NOTE_IN_OCTAVE(0, O))\n#define Csh(O) (NOTE_IN_OCTAVE(1, O))\n#define D(O)   (NOTE_IN_OCTAVE(2, O))\n#define Dsh(O) (NOTE_IN_OCTAVE(3, O))\n#define E(O)   (NOTE_IN_OCTAVE(4, O))\n#define F(O)   (NOTE_IN_OCTAVE(5, O))\n#define Fsh(O) (NOTE_IN_OCTAVE(6, O))\n#define G(O)   (NOTE_IN_OCTAVE(7, O))\n#define Gsh(O) (NOTE_IN_OCTAVE(8, O))\n#define A(O)   (NOTE_IN_OCTAVE(9, O))\n#define Ash(O) (NOTE_IN_OCTAVE(10, O))\n#define B(O)   (NOTE_IN_OCTAVE(11, O))\n\n#define FM(fc, fm, iom) sin(TWOPI*fract((fc)*t) + (iom)*sin(TWOPI*fract((fm)*t)))\n\n\nvec2 pianoLike(float f, float t)\n{\n    t = max(t, 0.0);\n    vec2 wav = vec2(0);\n    wav += FM(f, f , 4.0) * exp(-3.0 * t) * 0.1;\n    wav += FM(f, f * 0.5 , 4.0) * exp(-3.5 * t) * 0.02;\n    return wav;\n}\n\nvec2 pipupirupu(float t, float fNote, float scaleFix) \n{\n    t = mod(t, 8.0 * BeatDuration);\n    float offsets[5] = float[5](0.0, -1.0 - scaleFix, -3.0, -7.0, -8.0);\n    float dur = BeatDuration / 4.0;\n    int i = min(int(t / dur), 4);\n    return pianoLike(TRANSP(fNote, offsets[i]), t - float(i) * dur);\n}\n\nvec2 mainTune(float t) \n{\n    t = max(0.0, t);\n    float mainT = mod(t, 128.0 * BeatDuration);\n    t = mod(t, 64.0 * BeatDuration);\n    \n    vec2 wav = vec2(0.0);\n    \n    #define NOTE(F, BEATS) wav += (t >= 0.0 && t < BEATS * BeatDuration)?(pianoLike(F.x, t) + pianoLike(F.y, t)*0.8 + pianoLike(F.z, t)*0.75 ):vec2(0.0); t -= (BEATS)*BeatDuration;\n    \n    const int oct = 6;\n    \n    const vec3 chords[4] = vec3[4](\n        vec3(C(oct),    F(oct - 1), E(oct - 1)), \n        vec3(B(oct -1), F(oct - 1), E(oct - 1)),\n        vec3(D(oct),    G(oct - 1), Fsh(oct - 1)), \n        vec3(Csh(oct),  G(oct - 1), Fsh(oct - 1))\n    );\n\n    float patNorm = 2.0 * t / (64.0 * BeatDuration);\n    int subPat = int(fract(patNorm)*4.0) % 2;\n    vec3 chord = chords[int(patNorm) * 2 + subPat];\n\n    for(int i = 0; i < 32; i++) {\n        NOTE(chord, 2.0);\n    }\n\n    #undef NOTE\n    if(mainT >= 64.0 * BeatDuration)\n        wav += subPat == 0 ? pipupirupu(t, int(patNorm) == 0 ? C(oct + 1) : E(oct +1), floor(patNorm)) * 0.45 : vec2(0);\n    \n    \n    return wav;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    return mainTune(time);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926536;\nconst float TWOPI = 2.0 * PI;\n\nconst float BPM = 125.0;\nconst float BeatDuration = 60.0 / BPM;","name":"Common","description":"","type":"common"}]}