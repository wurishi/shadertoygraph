{"ver":"0.1","info":{"id":"slGyDK","date":"1662205774","viewed":192,"name":"Airy spot simulation","username":"stduhpf","description":"Modelisation of the diffraction of a 6500K blackbody radiation passing through a perfectly circular hole, making this pattern called \"Airy Spot\" or \"Airy Disc\". I studied that to make accurate bloom for a spectral pathtracer (I gave up).","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["diffraction","spectralrendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define linear_dithering true\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float prec = float(1<<8-1); //8-bit color range: 0.->255.\n\n    \n    if(linear_dithering)\n    {\n        //linear dithering to avoid banding (linear means less overshoot for dark pixels, so better contrast)\n        vec4 lcol = clamp(texture(iChannel0,uv)/texture(iChannel0,uv).a,0.,1.);\n        vec4 gcol = pow(lcol,vec4(1./2.2));\n\n        vec4 gcol_f = floor(gcol*prec)/prec;\n\n        vec4 lcol_f = pow(     gcol_f         ,vec4(2.2));\n        vec4 lcol_c = pow(ceil(gcol*prec)/prec,vec4(2.2));\n\n        vec4 rem = (lcol-lcol_f)/(lcol_c-lcol_f);\n\n         //8-bit color range: 0.->255.\n        // dithering to avoid banding\n        vec4 col = gcol_f+step(texture(iChannel1,fragCoord/iChannelResolution[1].xy),rem)/prec;\n\n        // Output to screen\n        fragColor = (col);\n    }else{\n\n        vec4 col = pow(clamp(texture(iChannel0,uv)/texture(iChannel0,uv).a,0.,1.),vec4(1./2.2));\n        // dithering to avoid banding\n        col = col*prec;\n        vec4 rem  = fract(col);\n        col = floor(col)+step(texture(iChannel1,fragCoord/iChannelResolution[1].xy),rem);\n\n        // Output to screen\n        fragColor = (col)/prec;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float gaussian(float x,float al, float mu, float s1, float s2){\n    float y = x-mu;\n    y /= y<0. ? s1 : s2;\n    return al*exp(-y*y*.5);\n}\nvec3 lambdatoXYZ(float wl){\n    return vec3( gaussian(wl, 1.056, 599.8, 37.9, 31.0)+gaussian(wl, 0.362, 442.0, 16.0, 26.7)+ gaussian(wl,-0.065, 501.1, 20.4, 26.2)\n                ,gaussian(wl, 0.821, 568.8, 46.9, 40.5)+gaussian(wl, 0.286, 530.9, 16.3, 31.1)\n                ,gaussian(wl, 1.217, 437.0, 11.8, 36.0)+gaussian(wl, 0.681, 459.0, 26.0, 13.8));\n}\nconst mat3 xyz = mat3(\n\t 3.240479, -1.537150, -0.498535,\n    -0.969256,  1.875992,  0.041556,\n     0.055648, -0.204043,  1.057311);\n\nvec3 spectrum_to_rgb(in float wl){\n\n    return lambdatoXYZ(wl)*xyz;\n}\n\n\nfloat blackbody(float wl, float T){\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n   \twl*=1e-9;\n    float wlwl = wl*wl;\n    return  2.*h*(c*c)/(wl*wlwl*wlwl*(exp(h*c/(T*wl*k))-1.));\n}\n\n\n\n// Very good approximation of J1, stolen from https://www.shadertoy.com/view/Wt3czM\nfloat BesselJ1(float x)\n{\n   \n    float xx = x * x;\n\n    return (sqrt(1.0 + 0.12138 * xx) * (46.68634 + 5.82514 * xx) * sin(x) - x * (17.83632 + 2.02948 * xx) * cos(x)) /\n           ((57.70003 + 17.49211 * xx) * pow(1.0 + 0.12138 * xx, 3.0/4.0) );\n}\n\n\n// Fourrier transform of the circular aperture (assuming radius 1)\n// see https://adriftjustoffthecoast.wordpress.com/2013/06/06/2d-fourier-transform-of-the-unit-disk/\nfloat ft(float r){\n     if(r*r<1e-9)return 1.;\n    return 2.*acos(-1.)*BesselJ1(r)/r;//*R*R\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float zoom = .03;\n    const float intensity = 5e-3;\n    const float temperature = 6500.; // in K : temperature of black-body source \n    const float redshift = 1.; // redshifting of blackbody radiation (<1 => blueshift) \n\n    \n    vec2 pixOffset = //jitter for antialiasing\n        fract((iTime*vec2(.01,(1.+sqrt(5.))/200.))+ \n                texture(iChannel1,\n                    (fragCoord+float(iFrame)*vec2(1,1./iChannelResolution[1].x))/iChannelResolution[1].xy\n                    ).xy\n                )-.5;\n    \n    float r = length(fragCoord+pixOffset-iResolution.xy*.5)/zoom;\n    \n    float wl_start = 300.;\n    \n    float wl_range = 600.; // = wl_end-wl_start\n    \n    float wl = mod(\n        (float(iFrame)*(.5+.5*sqrt(5.))+texture(iChannel1,fragCoord/iChannelResolution[1].xy).a)\n    *wl_range,wl_range)+wl_start;\n    \n    float stretch = wl; //longer wavelenth have greater scaling because of dispersion\n    float spread = acos(-1.)*(stretch*stretch); //same as above, but in 2D\n    \n    float fourrier = ft(r/stretch)/spread;\n    float airySpot = fourrier*fourrier;\n    \n    \n    float brightness = intensity*blackbody(wl/redshift,temperature);\n    vec3 lightColor = spectrum_to_rgb(wl)*brightness;\n\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy)+vec4(airySpot*lightColor,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}