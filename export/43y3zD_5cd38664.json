{"ver":"0.1","info":{"id":"43y3zD","date":"1717402456","viewed":64,"name":"CUBES","username":"typidoyun","description":"my shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cubefract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n    vec3 q = abs(p) - b + r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 pal(float t)\n{\n    vec3 a = vec3(.5, .5, .5);\n    vec3 b = vec3(.5, .5, .5);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(.263, .416, 0.557);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nmat2 rot( float rad ) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat dd = 0.;\n\nfloat map( vec3 p ) {\n    p.x += iTime / 2.;\n    vec3 boxPos = vec3(0, 0, 0);\n    vec3 q = p;\n    \n    q.xy = fract(p.xy) - .5;\n    q.z = mod(p.z, (sin(2. * 3.141592 * (iMouse.x / iResolution.x)) + 1.) * 2. + .0005) - ((sin(2. * 3.141592 * (iMouse.x / iResolution.x)) + 1.) * 2. + .0005) / 2.;\n    // q.z = mod(p.z, (sin(2. * 3.141592 * .75) + 1.) * 2. + .0005) - ((sin(2. * 3.141592 * .75) + 1.) * 2. + .0005) / 2.;\n    q.xz *= rot(1.28 * sin(1.76 * iTime + length(p.zy)));\n    q.yz *= rot(.86 * cos(1.23 * iTime + length(p.xy)));\n    \n    float box = sdRoundBox(q - boxPos, vec3(.15 + sin(1.2 * iTime + length(p.z)) / 20.), .1);\n    \n    return box;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    float t = 0.; // total distance travelled\n    \n    vec3 rayOrigin = vec3(0, 0, -3);\n    vec3 rayDirection = normalize(vec3(uv, 0) - rayOrigin);\n    vec3 col = vec3(0);\n    \n    // Raymarching\n    \n    for (int i = 0; i < 256; i++) {\n        vec3 p = rayOrigin + rayDirection * t;\n        \n        p.y += sin(t) * .6;\n        p.x += cos(t) * .6;\n        p.xy *= rot(t * .2);\n        // p.x += sin(noise(p) * 3.141592 * 2.) / 15.;\n        // p.y += cos(4. * noise(p) * 3.141592 * 2.) / 13.;\n       \n        float d = map(p);\n        \n        t += d;\n        \n        col = vec3(i) / 256.;\n        \n        if (d < 0.001) break; // early stop if close enough\n        if (t > 1000.) break; // early stop if too far\n    }\n    \n    col = vec3(pal(.2 + t / 10.));\n    \n    fragColor = vec4(col, 0.);\n}","name":"Image","description":"","type":"image"}]}