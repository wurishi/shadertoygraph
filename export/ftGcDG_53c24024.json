{"ver":"0.1","info":{"id":"ftGcDG","date":"1662066376","viewed":280,"name":"Raymarching Lightbulb Demo","username":"KilledByAPixel","description":"Progress update on my raymarching rendering engine including rotated objects, improved materials, and optimization. Also showing a technique to have visible point light shadow casters.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lights"],"hasliked":0,"parentid":"ftVcRG","parentname":"Raymarching Engine Demo"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rendering Engine Demo\n// Copyright Frank Force 2022\n// https://frankforce.com\n\n// This demo includes 50 objects with a directional, ambient, and point light.\n// Each object also has it's own material properties.\n\n// global settings\nconst int maxRaycastIterations = 100;\nconst int maxReflectionIterations = 50;\nconst int maxShadowIterations = 80;\nconst bool enableShadows = true;\nconst bool enableAmbientOcclusion = true;\nconst bool enableAmbientLights = true;\nconst bool enableDirectionalLights = true;\nconst bool enablePointLights = true;\nconst bool enableReflections = true;\nconst bool enableSpecular = true;\nconst bool enableMaterials = true;\n\n// forward declarations for generated code\nvec3 getColor(vec3 startPosition, vec3 direction);\nvec2 sceneDistance(vec3 position);\n\n// helper functions\nmat3 getRotationMatrix(vec3 direction)\n{\n\tvec3 f = direction;\n\tvec3 r = normalize(cross(vec3(0,1,0), f));\n\tvec3 u = -cross(r,f);\n    return mat3(r, u, f);\n}\nvec2 rotate(vec2 v, float angle)\n{ return angle != 0. ? v*cos(angle) + vec2(-v.y,v)*sin(angle) : v; }\nvec3 rotateXYZ(vec3 v, vec3 angles)\n{\n\tv.yz = rotate(v.yz, angles.x);\n\tv.xz = rotate(v.xz, angles.y);\n\tv.xy = rotate(v.xy, angles.z);\n\treturn v;\n}\n\n// main rendering function\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // input\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // camera\n    float cameraDistance = 90.;\n    vec3 cameraDirection = normalize(vec3(1.0,0,0));\n    cameraDirection.xy = rotate(cameraDirection.xy, mouse.y > 0. ? -1.4*(1.-mouse.y) : .3*cos(.1*iTime)-.5);\n    vec3 lookAtPosition = vec3( 0, mouse.x*15., 0);\n    cameraDirection.xz = rotate(cameraDirection.xz, iMouse.z > 0. ? -8.*mouse.x : .1*iTime);\n    vec3 cameraPosition = lookAtPosition - cameraDistance * cameraDirection;\n    float cameraZoom = 3.;\n\n    // render the pixel\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    mat3 cameraTransform = getRotationMatrix(cameraDirection);\n    vec3 direction = cameraTransform * normalize(vec3(uv, cameraZoom));\n    fragColor = vec4(getColor(cameraPosition, direction), 1);\n}\n\n// noise\nvec3 hash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(p)*3e4);\n}\n\nvec3 noise3(vec3 p)\n{\n    // fast build noise, prevent inlining calls to hash33\n    const vec2 o = vec2(1, 0);\n    vec3 i = floor(p);\n    vec3 f = smoothstep(0., 1., fract(p));\n\n    vec3 hashResult[8]; \n    for(int j=0; j<8; ++j)\n    {\n        vec3 z = vec3(j&1,(j&2)>>1,(j&4)>>2);\n        hashResult[j] = hash3(i+z);\n    }\n    \n    return mix(\n        mix\n        (\n            mix(hashResult[0], hashResult[1], f.x), \n            mix(hashResult[2], hashResult[3], f.x), \n            f.y\n        ),\n        mix\n        (\n            mix(hashResult[4], hashResult[5], f.x), \n            mix(hashResult[6], hashResult[7], f.x),\n            f.y\n        ),\n        f.z\n    );\n}\n\n// distance shapes\nfloat distancePlane(vec3 p, vec3 n) { return dot(p, n); }\nfloat distanceSphere(vec3 p, float r) { return length(p) - r; }\nfloat distanceTorus(vec3 p, vec2 s)\n{ return length(vec2(length(p.xz) - s.x, p.y)) - s.y; }\nfloat distanceBox(vec3 p, vec3 s, float e)\n{\n    vec3 d = abs(p) - s + e;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.)) - e;\n}\nfloat distanceCylinder(vec3 p, vec2 s, float e)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - s + e;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - e;\n}\nfloat distanceCone(vec3 p, float h, float angle)\n{\n    vec2 q = 2. * h * vec2(sin(angle) / cos(angle), -1.);\n    vec2 o = vec2(length(p.xz), p.y - h);\n    vec2 b1 = o - q * clamp(dot(o, q) / dot(q, q), 0., 1.);\n    vec2 b2 = o - q * vec2(clamp(o.x / q.x, 0., 1.), 1.);\n    float d = min(dot(b1, b1), dot(b2, b2));\n    float k = sign(q.y);\n    float s = max(k * (o.x * q.y - o.y * q.x), k * (o.y - q.y));\n    return sqrt(d) * sign(s);\n}\nfloat distanceEllipsoid(vec3 p, vec3 s)\n{\n    float k0 = length(p / s);\n    float k1 = length(p / (s * s));\n    return k0 * (k0 - 1.) / k1;\n}\nfloat distanceBoxFrame(vec3 p, vec3 s, float f)\n{     \n    vec3 a = abs(p) - s;\n    vec3 b = abs(a + f) - f;\n    return min(min(\n        length(max(vec3(a.x,b.y,b.z),0.)) + min(max(a.x,max(b.y,b.z)),0.),\n        length(max(vec3(b.x,a.y,b.z),0.)) + min(max(b.x,max(a.y,b.z)),0.)),\n        length(max(vec3(b.x,b.y,a.z),0.)) + min(max(b.x,max(b.y,a.z)),0.));\n}\n\n// combine operators\nvec2 combineUnion(vec2 d1, vec2 d2)     { return d1.x  < d2.x ? d1 : d2; }\nvec2 combineSubtract(vec2 d1, vec2 d2)  { return -d1.x > d2.x ? d1 : d2; }\nvec2 combineIntersect(vec2 d1, vec2 d2) { return d1.x  > d2.x ? d1 : d2; }\nvec2 combineRound(vec2 d, float r)      { return d - r; }\nvec2 combineUnionSmooth(vec2 d1, vec2 d2, float k)\n{\n    float p = clamp(.5 + .5 * (d2.x - d1.x) / k, 0., 1.);\n    return vec2(mix(d2.x, d1.x, p) - k * p * (1. - p), d1.y);\n}\nvec2 combineSubtractSmooth(vec2 d1, vec2 d2, float k)\n{\n    float p = clamp(.5 - .5 * (d2.x + d1.x) / k, 0., 1.);\n    return vec2(mix(d2.x, -d1.x, p) + k * p * (1. - p), d1.y);\n}\nvec2 combineIntersectSmooth(vec2 d1, vec2 d2, float k)\n{\n    float p = clamp(.5 - .5 * (d2.x - d1.x) / k, 0., 1.);\n    return vec2(mix(d2.x, d1.x, p) + k * p * (1. - p), d1.y);\n}\n\nvec2 raycast(vec3 position, vec3 direction, bool isReflection)\n{\n    // cast the ray\n    const float range = 1e3;\n    const float minRange = .1;\n    const float accuracy = .001;\n    float total = minRange;\n    float nearestDistance = 1e9;\n    vec2 nearestResult = vec2(1e4);\n    for (int i = (isReflection ? maxReflectionIterations : maxRaycastIterations); accuracy < nearestDistance && --i > 0;)\n    {\n        vec2 distanceResult = sceneDistance(position + total * direction);\n        if (distanceResult.x * nearestResult.x * nearestResult.x < nearestDistance* total * total)\n        {\n            // fix flickering pixel around edges\n            nearestDistance = distanceResult.x;\n            nearestResult = vec2(total, distanceResult.y);\n        }\n        total += distanceResult.x;\n        if (total > range)\n            return vec2(range, -1);\n    }\n    \n    return nearestResult;\n}\n\nfloat getShadow(vec3 position, vec3 direction, float softness, float range)\n{\n    if (!enableShadows)\n        return 1.;\n\n    // cast the shadow\n    const float minRange = .1;\n    const float accuracy = .001;\n    float distanceLast = 1e9;\n    softness = max(softness, .001);\n    \n    float shadow = 1.;\n    float total = minRange;\n    for (int i = 0; accuracy < shadow && ++i < maxShadowIterations;)\n    {\n        // get estimated shadow distance\n        float distance = sceneDistance(position + total * direction).x;\n        float x = distance * distance / (2. * distanceLast);\n        float y = distance * distance - x * x;\n        if (y > 0. && total - x > accuracy)\n            shadow = min(shadow, sqrt(y) / (total - x) / softness);\n\n        // update distance\n        distanceLast = distance;\n        total += distance;\n        if (total > range)\n            return smoothstep(0., 1., shadow);\n    }\n    return 0.;\n}\n\nfloat getPointShadow(vec3 lightPosition, float lightRadius, vec3 position, vec3 direction, float softness, float range)\n{\n    if (!enableShadows)\n        return 1.;\n\n    // cast the shadow\n    const float minRange = .1;\n    const float accuracy = .001;\n    float distanceLast = 1e9;\n    softness = max(softness, .001);\n\n    float shadow = 1.;\n    float total = minRange;\n    for (int i = 0; accuracy < shadow && ++i < maxShadowIterations;)\n    {\n        // get nearest distance, stop if closer to the light\n        vec3 castPosition = position + total * direction;\n        float distance = sceneDistance(castPosition).x;\n        vec3 lightDelta = castPosition - lightPosition;\n        float lightDistanceSquared = dot(lightDelta, lightDelta);\n        float checkDistance = distance + lightRadius + accuracy;\n        if (total > range || lightDistanceSquared < checkDistance*checkDistance)\n            return smoothstep(0., 1., shadow);\n        \n        // get estimated shadow distance\n        float x = distance * distance / (2. * distanceLast);\n        float y = distance * distance - x * x;\n        if (y > 0. && total - x > accuracy)\n            shadow = min(shadow, sqrt(y) / (total - x) / softness);\n\n        // update distance\n        distanceLast = distance;\n        total += distance;\n    }\n    return 0.;\n}\n\nvec3 getNormal(vec3 p)\n{\n    // faster to compile normals\n    const float accuracy = .001;\n    vec3 t=vec3(0);\n    for(int j=0;j<4;++j){\n    vec3 e=accuracy*(j==3?vec3(1):vec3(j==0?1:-1,j==1?1:-1,j==2?1:-1));\nt+=e*sceneDistance(p+e).x;}\n    return normalize(t);\n}\n\nfloat getAmbientOcclusion(vec3 position, vec3 normal)\n{\n    if (!enableAmbientOcclusion)\n        return 1.;\n\n    // cast the ambient occusion\n    const float strength = .2;\n    const float scale = .1;\n    const int stepCount = 5;\n\tfloat occlusion = 0.;\n    float d = .1;\n    for (int i = 0; ++i < stepCount;)\n    {\n        float distance = sceneDistance(position + d * normal).x;\n        occlusion += max((d - distance) / d, 0.); \n        d += min(distance, scale);\n    }\n    return max(1. - occlusion * strength, 0.);\n}\n\nvec3 getAmbientLight(vec3 lightColor, vec3 position, vec3 direction, vec3 normal, vec3 diffuseColor, vec3 specularColor, float specularPower)\n{\n    if (!enableAmbientLights)\n        return vec3(0);\n\n    return lightColor * diffuseColor;\n}\n\nvec3 getDirectionalLight(vec3 lightDirection, vec3 lightColor, float lightSoftness, bool castShadow, vec3 position, vec3 direction, vec3 normal, vec3 diffuseColor, vec3 specularColor, float specularPower)\n{\n    // check if no shadow\n    float diffuseDot = dot(lightDirection, normal);\n    if (diffuseDot < 0. || !enableDirectionalLights)\n        return vec3(0);\n\n    // apply shadow and shading\n    float shadowAmount = castShadow ? getShadow(position, lightDirection, lightSoftness, 1e3) : 1.;\n    vec3 diffuse = (diffuseDot * shadowAmount) * lightColor * diffuseColor;\n    if (specularPower == 0. || !enableSpecular)\n        return diffuse;\n\n    // apply specular\n    vec3 reflectDirection = reflect(direction, normal);\n    float specularDot = pow(max(dot(lightDirection, reflectDirection), 0.), 1. + specularPower);\n    vec3 specular = (specularDot * shadowAmount) * lightColor * specularColor;\n    return diffuse + specular;\n}\n\nvec3 getPointLight(vec3 lightPosition, vec3 lightColor, float lightStrength, float lightSoftness, bool castShadow, float lightRadius, vec3 position, vec3 direction, vec3 normal, vec3 diffuseColor, vec3 specularColor, float specularPower)\n{\n    // get direction to light\n    vec3 delta = lightPosition - position;\n    float distance = length(delta);\n    vec3 lightDirection = delta / distance;\n\n    // check if no shadow\n    float diffuseDot = dot(lightDirection, normal);\n    if (diffuseDot < 0. || !enablePointLights)\n        return vec3(0);\n\n    // apply shadow and shading\n    float shadowAmount = castShadow ? \n        lightRadius == 0. ? getShadow(position, lightDirection, lightSoftness, distance) :\n        getPointShadow(lightPosition, lightRadius, position, lightDirection, lightSoftness, distance)\n        : 1.;\n    vec3 diffuse = (diffuseDot * shadowAmount) * lightColor * diffuseColor;\n    float falloff = min(lightStrength * lightStrength / distance / distance, 1.);\n    if (specularPower == 0. || !enableSpecular)\n        return diffuse * falloff;\n\n    // apply specular\n    vec3 reflectDirection = reflect(direction, normal);\n    float specularDot = pow(max(dot(lightDirection, reflectDirection), 0.), 1. + specularPower);\n    vec3 specular = (specularDot * shadowAmount) * lightColor * specularColor;\n    return (diffuse + specular) * falloff;\n}\n\nstruct Material\n{\n    vec3 diffuse;\n    vec3 emissive;\n    vec3 specular;\n    float specularPower;\n    float reflectivity;\n    float roughness;\n    float roughnessScale;\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// SCENE CODE STARTS HERE\n////////////////////////////////////////////////////////////////////////////////\n\nconst Material materials[] = Material[]\n(\n    // diffuse, emissive, specular, specPower, reflect, rough, roughScale\n    Material(vec3(1., 0.370, 0.100), vec3(2.100, 0.840, 0.300), vec3(1), 50., 0., 0., 50.),\n    Material(vec3(0.844, 0.056, 0.347), vec3(0), vec3(1), 0., 0., 0.196, 50.),\n    Material(vec3(0.810, 0.790, 0.796), vec3(0), vec3(1), 5., 0., 0.050, 50.),\n    Material(vec3(0.675, 0.682, 0.725), vec3(0), vec3(1), 0., 0., 0., 50.),\n    Material(vec3(0.375, 0.140, 0.920), vec3(0), vec3(0.902, 0.063, 0.847), 32.074, 0., 0., 50.),\n    Material(vec3(0.434, 0.990, 0.914), vec3(0), vec3(0.542, 0.213, 0.331), 26.776, 0., 0., 50.),\n    Material(vec3(0.020, 0.313, 0.089), vec3(0), vec3(0.658, 0.680, 0.037), 61.281, 0., 0.109, 50.),\n    Material(vec3(0.165, 0., 0.276), vec3(0), vec3(1), 20.249, 0., 0.062, 50.),\n    Material(vec3(0.480, 0.044, 0.343), vec3(0), vec3(1), 23.035, 0., 0., 50.),\n    Material(vec3(0.029, 0.400, 0.666), vec3(0), vec3(0.632, 0.291, 0.003), 30.332, 0., 0.139, 50.),\n    Material(vec3(0.919, 0.002, 0.840), vec3(0), vec3(1), 66.592, 0., 0., 50.),\n    Material(vec3(0.683, 0.972, 0.747), vec3(0), vec3(0.916, 0.684, 0.209), 55.335, 0.746, 0.021, 16.667),\n    Material(vec3(0.053, 0.571, 0.597), vec3(0), vec3(1), 16.560, 0., 0.165, 50.),\n    Material(vec3(0.372, 0.625, 0.058), vec3(0), vec3(0.454, 0.688, 0.325), 71.268, 0., 0., 50.),\n    Material(vec3(0.998, 0.960, 0.997), vec3(0), vec3(1), 67.683, 0., 0., 50.),\n    Material(vec3(0.994, 0.951, 0.770), vec3(0), vec3(0.200, 0.326, 0.268), 14.878, 0.470, 0., 16.667),\n    Material(vec3(0.607, 0.501, 0.020), vec3(0), vec3(0.080, 0.722, 0.922), 0., 0., 0.009, 50.),\n    Material(vec3(0.952, 0.305, 0.753), vec3(0), vec3(0.938, 0.492, 0.535), 30.442, 0.560, 0.020, 16.667),\n    Material(vec3(0.022, 0.122, 0.528), vec3(0), vec3(1), 68.372, 0., 0., 50.),\n    Material(vec3(0.535, 0.877, 0.986), vec3(0), vec3(0.380, 0.568, 0.933), 20.356, 0., 0.047, 50.),\n    Material(vec3(0.507, 0.114, 0.050), vec3(0), vec3(1), 15.839, 0., 0., 50.),\n    Material(vec3(0.047, 0.349, 0.423), vec3(0), vec3(0.935, 0.294, 0.698), 73.971, 0., 0., 50.),\n    Material(vec3(0.225, 0.778, 0.010), vec3(0), vec3(0.085, 0.670, 0.178), 7.714, 0., 0.014, 50.)\n);\n\nvec2 group0Distance(vec3 position)\n{\n    vec2 d = vec2(1e9);\n    d = combineUnion(vec2(distanceSphere(position - vec3(0., 10.500, 0.), 3.), 0), d);\n    d = combineUnionSmooth(vec2(distanceCylinder(position - vec3(0., 6., 0.), vec2(1.500, 3.), 0.), 0), d, 2.);\n    d = combineUnion(vec2(distanceBox(position - vec3(0., 1.500, 0.), vec3(3), 0.200), 1), d);\n    return d;\n}\n\nvec2 sceneDistance(vec3 position)\n{\n    vec2 d = vec2(1e9);\n    d = combineUnion(group0Distance(position - vec3(0)), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(0., -1000., 0.), vec2(50., 1000.), 0.500), 2), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(0., -1000., 0.), vec2(50., 1000.), 0.500), 2), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(0., -40., 0.), vec2(500., 10.), 0.500), 3), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(31.169, 9.340, 23.335), vec3(6.965, 9.340, 6.150), 0.876), 4), d);\n    d = combineUnion(vec2(distanceSphere(position - vec3(34.082, 25.266, 22.549), 6.585), 5), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(23.046, 3.113, 13.158), vec2(3.171, 3.113), 0.539), 6), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(12.721, 2.687, 8.395), vec2(6.242, 2.687), 0.483), 7), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(12.032, 8.028, 7.870), vec2(3.461, 2.653), 0.596), 8), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(30.618, 2.323, 10.866), vec2(2.631, 2.323), 0.499), 9), d);\n    d = combineUnion(vec2(distanceSphere(position - vec3(1.435, 7.196, 33.183), 7.196), 1), d);\n    d = combineUnion(vec2(distanceBox(rotateXYZ(position - vec3(-21.502, 5.023, -24.767), vec3(0., 6.204, 0.)), vec3(6.548, 5.023, 5.130), 0.965), 10), d);\n    d = combineUnion(vec2(distanceSphere(position - vec3(-19.990, 16.422, -23.653), 6.376), 11), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(-7.336, 3.214, -15.565), vec2(6.444, 3.214), 0.725), 11), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(-8.226, 11.095, -17.561), vec3(3.334, 4.667, 3.330), 0.418), 12), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(-8.768, 17.121, -17.825), vec3(1.551, 1.359, 1.389), 0.495), 13), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(-22.500, 14.353, 26.639), vec3(6.886, 14.353, 3.592), 0.591), 7), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(-20.059, 31.615, 24.761), vec2(5.307, 2.909), 0.846), 14), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(-18.888, 37.894, 25.619), vec2(3.102, 3.371), 0.519), 15), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(-32.719, 8.745, 14.746), vec3(4.202, 8.745, 3.748), 0.162), 11), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(-34.717, 22.504, 13.633), vec2(4.723, 5.014), 0.210), 9), d);\n    d = combineUnion(vec2(distanceSphere(position - vec3(-34.960, 30.879, 14.821), 3.360), 4), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(12.392, 6.086, 23.727), vec3(4.358, 6.086, 2.807), 0.757), 7), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(12.636, 13.865, 25.033), vec3(1.875, 1.692, 1.835), 0.587), 16), d);\n    d = combineUnion(vec2(distanceBox(rotateXYZ(position - vec3(21.955, 7.327, -22.223), vec3(0., 3.964, 0.)), vec3(5.243, 7.327, 2.828), 0.170), 11), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(20.075, 17.251, -22.507), vec2(4.785, 2.597), 0.654), 17), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(19.128, 22.437, -23.459), vec2(3.528, 2.590), 0.724), 7), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(35.042, 3.529, -7.681), vec3(6.373, 3.529, 3.613), 0.103), 18), d);\n    d = combineUnion(vec2(distanceSphere(position - vec3(34.152, 10.935, -7.462), 3.878), 1), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(-18.514, 5.035, -11.873), vec2(3.975, 5.035), 0.762), 4), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(-19.708, 13.076, -12.307), vec3(1.915, 3.007, 1.866), 0.487), 10), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(3.218, 2.219, -33.368), vec2(7.450, 2.219), 0.543), 12), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(3.364, 6.338, -32.999), vec2(5.458, 1.900), 0.290), 18), d);\n    d = combineUnion(vec2(distanceSphere(position - vec3(1.969, 11.503, -34.430), 3.265), 11), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(-36.415, 4.136, -10.431), vec2(6.375, 4.136), 0.984), 19), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(-35.897, 10.213, -11.598), vec2(4.394, 1.941), 0.933), 12), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(-30.071, 2.288, -2.365), vec3(2.748, 2.288, 1.727), 0.057), 13), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(10.353, 1.935, 36.315), vec2(2.257, 1.935), 0.362), 6), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(6.254, 2.482, 15.698), vec2(3.514, 2.482), 0.363), 5), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(-9.661, 6.807, 12.018), vec2(6.420, 6.807), 0.819), 20), d);\n    d = combineUnion(vec2(distanceSphere(position - vec3(-9.504, 16.631, 10.914), 3.017), 13), d);\n    d = combineUnion(vec2(distanceBox(rotateXYZ(position - vec3(14.195, 4.198, -0.540), vec3(0., 5.488, 0.)), vec3(1.990, 4.198, 1.656), 0.520), 16), d);\n    d = combineUnion(vec2(distanceBox(rotateXYZ(position - vec3(14.395, 11.314, 0.427), vec3(0., 3.825, 0.)), vec3(1.450, 2.917, 1.370), 0.888), 12), d);\n    d = combineUnion(vec2(distanceBox(rotateXYZ(position - vec3(22.027, 3.296, -32.452), vec3(0., 0.813, 0.)), vec3(1.990, 3.296, 1.197), 0.438), 19), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(-56.172, 0.527, 188.013), vec2(97.073, 30.527), 0.916), 21), d);\n    d = combineUnion(vec2(distanceBox(rotateXYZ(position - vec3(-52.844, 91.900, 173.151), vec3(0., 3.056, 0.)), vec3(30.474, 60.846, 23.917), 0.888), 5), d);\n    d = combineUnion(vec2(distanceBox(rotateXYZ(position - vec3(-187.629, 71.668, -236.161), vec3(0., 4.258, 0.)), vec3(54.879, 101.668, 52.898), 0.246), 14), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(131.036, 14.671, -278.805), vec3(37.169, 44.671, 20.363), 0.960), 6), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(264.345, 0.899, -179.202), vec3(45.304, 30.899, 40.931), 0.052), 22), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(273.979, 60.933, -176.016), vec3(19.924, 29.136, 18.102), 0.945), 17), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(117.232, 9.937, 256.031), vec3(58.019, 39.937, 39.371), 0.685), 22), d);\n    d = combineUnion(vec2(distanceBox(position - vec3(143.241, 98.553, 279.970), vec3(45.614, 48.680, 28.070), 0.760), 1), d);\n    d = combineUnion(vec2(distanceCylinder(position - vec3(209.306, 67.320, -52.695), vec2(73.892, 97.320), 0.884), 19), d);\n    return d;\n}\n\nvec3 ACESFilm(vec3 v) \n{\n  // knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0., 1.);\n}\n\nvec3 getColor(vec3 startPosition, vec3 direction)\n{\n    vec3 passColor = vec3(1);\n    vec3 finalColor = vec3(0);\n    int maxReflects = 3;\n    for (int reflectCount = 0; ++reflectCount <= maxReflects;)\n    {\n        // raycast to find hit info\n        vec2 raycastResult = raycast(startPosition, direction, reflectCount > 1);\n        float hitDistance = raycastResult.x;\n        int hitMaterialIndex = int(raycastResult.y);\n        \n        // get fog color\n        const vec3 fogColor1 = vec3(0.637, 0.708, 0.963);\n        const vec3 fogColor2 = vec3(0.019, 0.123, 0.181);\n        const vec3 fogFadeDirection = vec3(0., 1., 0.);\n        float fogColorBlend = dot(direction, fogFadeDirection);\n        fogColorBlend = (fogColorBlend - -0.300) / 0.900;\n        vec3 fogColor = mix(fogColor2, fogColor1, fogColorBlend);\n        \n        // stop if nothing was hit\n        if (hitMaterialIndex < 0)\n        {\n            finalColor += fogColor * passColor;\n            break;\n        }\n        \n        // material info\n        vec3 position = startPosition + hitDistance * direction;\n        Material material = materials[enableMaterials ? hitMaterialIndex : 0];        vec3 diffuse = material.diffuse;\n        vec3 specular = material.specular;\n        vec3 emissive = material.emissive;\n        float specularPower = material.specularPower;\n        float reflectivity = material.reflectivity;\n        float roughness = material.roughness;\n        float roughnessScale = material.roughnessScale;\n        \n        // hit normal\n        vec3 normal = getNormal(position);\n        if (roughness > 0.)\n            normal = normalize(normal + noise3(position * roughnessScale) * roughness);\n        \n        // lighting\n        vec3 color;\n        color = getAmbientLight(vec3(0.001, 0.005, 0.007), position, direction, normal, diffuse, specular, specularPower);\n        color *= getAmbientOcclusion(position, normal);\n        color += getDirectionalLight(vec3(0.408, 0.816, -0.408), vec3(0.122, 0.076, 0.124), 0.200, true, position, direction, normal, diffuse, specular, specularPower);\n        color += getPointLight(vec3(0., 10.500, 0.), vec3(.9, 0.370, 0.100), 40., 0.100, true, 6., position, direction, normal, diffuse, specular, specularPower);\n        color += emissive;\n        \n        // blend fog\n        const float fogStart = 100.;\n        const float fogDistance = 400.;\n        float fogPercent = clamp((hitDistance - fogStart) / fogDistance, 0., 1.);\n        color *= 1. - reflectivity;\n        finalColor += passColor * mix(color, fogColor, fogPercent);\n        \n        // check if reflecting\n        if (!enableReflections || reflectivity == 0.)\n            break;\n        \n        // apply reflections\n        startPosition = position;\n        direction = reflect(direction, normal);\n        passColor *= diffuse * reflectivity * (1. - fogPercent);\n    }\n    \n    // gamma\n    const float gamma = 0.4545;\n    finalColor = pow(clamp(finalColor, 0., 1.), vec3(gamma));\n    finalColor = ACESFilm(finalColor);\n    return finalColor;\n    \n}","name":"Image","description":"","type":"image"}]}