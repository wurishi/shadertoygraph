{"ver":"0.1","info":{"id":"llKcDR","date":"1535857484","viewed":409,"name":"Fluid Breaking Mirror","username":"Veggiebob","description":"Not sure how to make this more realistic . . . I want to do something with it tho","likes":5,"published":1,"flags":2,"usePreview":0,"tags":["voronoi","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float num_points = 10.;\nconst float point_spread = 4.;\nconst float speed = 0.08;\nvec2 calcPointSpot2D (float i){\n    return vec2(sin(iTime*speed+i*point_spread), cos(iTime*speed*2.+i*speed*1.7));\n}\nvec3 calcNearestPoint2D (vec2 p){\n    float minDist = 1.;\n    float nxtminDist = minDist;\n    float index = -1.;\n    for(float i = 0.; i<num_points; i++){\n        vec2 pp = calcPointSpot2D(i);\n        float d = length(p-pp);\n        if(d<minDist){\n            nxtminDist = minDist;\n            minDist = d;\n            index = i;\n        }\n    }\n    return vec3(minDist, nxtminDist, index);\n}\nvec2 rotate2d (vec2 uv, float angle) {\n    float ang = atan(uv.y, uv.x);\n    float l = length(uv);\n    return vec2(cos(ang+angle)*l, sin(ang+angle)*l);\n}\nvec2 calcOffsetOnI (float i){\n    return vec2(sin(i*point_spread), cos(i*speed*1.7));\n}\nfloat sq (float x){\n    return x*x;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 nuv = (uv-0.5)*2.;\n    vec3 p = calcNearestPoint2D(nuv);\n    vec2 off = calcOffsetOnI(p.z);\n    \n    // get the texture with an offset based on the tile that it's in\n    vec2 finalUV = vec2(1.-uv.x, uv.y)+off*0.05;\n    finalUV = rotate2d(finalUV, float(off*0.2));\n    vec3 col = texture(iChannel0, finalUV).rgb;\n    float g = clamp(pow(0.05/abs(p.y-p.x)+0., 10.), 0., 1.);\n    //col*=1.-g;//borders around cracks\n    //col+=texture(iChannel1, uv*2.).rrr*g;\n    // Output to screen\n    //col = p.rrr;\n    float border = sqrt(abs(sq(p.y)-sq(p.x)));\n    border = abs(border-sqrt(2.));\n    if(border>1.3){\n        //col = vec3(1.);\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}