{"ver":"0.1","info":{"id":"WsSGzh","date":"1548068544","viewed":244,"name":"Marble Fantasies Colored","username":"tholzer","description":"Stereo variant of [url]https://www.shadertoy.com/view/tdXGWM[/url].\nUse mouse to rotate marble.\ntoggle keys: a, f, r, s  see header!","likes":9,"published":1,"flags":16,"usePreview":0,"tags":["3d","transparency","sphere","antialiasing","raytrace","satiny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Originally created by S. Guillitte 2015\n\n//---------------------------------------------------------\n// keys: a  sphere pattern animation\n//       f  show sphere reflections\n//       r  rotation scene\n//       s  cross eye stereo view\n//---------------------------------------------------------\n// shadertoy defines\n#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\n//---------------------------------------------------------\n// get javascript keycode: http://keycode.info/\n//----------------------------------------------------------\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_U = 85;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_X = 88;\nconst int KEY_Y = 89;\nconst int KEY_Z = 90;\n//----------------------------------------------------------\nbool ReadKey(int key, bool toggle)\n{\n  return 0.5 < texture(iChannel3\n    ,vec2((float(key)+0.5) / 256.0, toggle ? 0.75 : 0.25)).x;\n}\n\n//---------------------------------------------------------\n// global settings\n//---------------------------------------------------------\nbool animate_pattern = false;    // a\nbool show_reflections = false;   // f\nbool rotation_scene = true;      // r\nbool cross_eye_view = true;      // v\n//---------------------------------------------------------\nvoid keyInput()\n{\n  if (iFrame > 9)\n  {\n    animate_pattern   = !ReadKey(KEY_A, true);\n    show_reflections  = !ReadKey(KEY_F, true);\n    rotation_scene    = !ReadKey(KEY_R, true);\n    cross_eye_view    = !ReadKey(KEY_S, true);\n  }\n}\n//---------------------------------------------------------\n// here some values to play for you ...\n\n#define MAP_OCTAVE 7\n#define BACK_COLOR vec3(0.4, 0.05, 0.05)\n#define INNER_COLOR vec3(0.2, 0.2, 0.6)\n#define GLAS_COLOR vec3(0.5, 0.5, 0.9)\n\n\n\n\n\n\n\n\n//---------------------------------------------------------\n//Play with the detail level, change it!\n#define DETAIL 5\n\n//also play with this one. Fixed it so that the marble doesn't go dark when this is small.\n#define INNER_DEPTH 64\n\n//play with these too you can try changes in the range of 1s, 10s or 100s\n//but keep a decimal point on it or it won't compile\n#define COLOR_CONTRAST 45.0\n#define MILKY_LIGHT 80.0\n\n//not exactly opacity.. in this model the \"subtractive\" colors are actually adding light, but light can \n//have negative colors... Yeah it's not a realistic model. I did it by mistake, but it looks cool. \n\n//0 is color is additive\n//1 is color is kind of subtractive\n#define OPACITY_OF_COLOR 1.0\n\nfloat zoom=1.;\n\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n//---------------------------------------------------------\nvec3 map(in vec3 p) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n\tfor (int i = 0; i < DETAIL; ++i) {\n        p =.7*abs(p)/dot(p,p) -.7;\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)))+.02;\n        \n\t}\n\treturn res*COLOR_CONTRAST*0.013*(normalize(p)+(1.0-OPACITY_OF_COLOR)*vec3(1.0));\n}\n//---------------------------------------------------------\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    float t = tminmax.x;\n    float dt = .02;\n    if (animate_pattern)\n      dt = 0.02 + 0.01*cos(time*0.5);\n     \n    vec3 col= vec3(0.);\n    vec3 c = vec3( 0.);\n    for( int i=0; i<INNER_DEPTH; i++ )\n\t{\n        t+=dt*exp(-2.*length(c));\n        if(t>tminmax.y)break;\n        //vec3 pos = ro+t*rd;\n        vec3 pos = refract( ro, (ro+t*rd)/.7,-.012);\n        c = map(pos);//map(ro+t*rd);               \n        \n        float gr= MILKY_LIGHT*0.02/float(INNER_DEPTH);//.01*(2.0-float(i)/64.0);\n        \n        col = .99*col+ .08*c+vec3(gr);//vec3(c*c, c, c*c*c);//green\t\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\n    }    \n    return col;\n}\n\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    keyInput();\n\n    vec2 uv = 2.0*(fragCoord.xy / resolution.xy) - 1.0;\n    uv.x *= resolution.x / resolution.y;\n    vec2 m = vec2(-0.5);\n//    if( mouse.z > 0.0 )   // mouse pressed?\n\tm = mouse.xy / resolution.xy * 3.14;\n//    m += mouse.xy * 3.14;    // use on glslsandbox.com\n\n    float eye = 0.1;\n    float radius = 1.4;\n\n    if (cross_eye_view)     // stereo view ?\n    {\n      radius = 1.0;\n      if (uv.x > 0.)\n      {\n        uv.x -= 0.8;\n        eye = -0.1;\n      } else {\n        uv.x += 0.8;\n        eye = +0.1;\n      }\n    }\n\n    // camera\n    vec3 ro = vec3(6,0,0);   // origin\n    ro.y += eye;\n    ro.yz *= rot(m.y);\n    ro.xz *= rot(m.x);\n    if (rotation_scene)\n      ro.xz *= rot(0.07*time);\n\n    vec3 ta = vec3( 0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( uv.x*uu + uv.y*vv + 4.0*ww );\n\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,radius) );\n\n    // sound animation\n//\tfloat fft  = texture( iChannel0, vec2(p.x+22.,0.25) ).x;\n//  float wave = texture( iChannel0, vec2(p.x,0.75) ).x;\n//  tmm += 0.6*wave + fft;\n\n    // raymarch\n    vec3 col = raymarch(ro,rd,tmm);  // get sphere Color\n\n    const float taa = 6.3;     // antialiasing limit\n    float aa = (2.2*(tmm.x - taa));\n    if ((tmm.x < 0.0) || (tmm.x > taa))\n    {\n        vec3 bgCol = BACK_COLOR * map(rd);   // background color\n        if (tmm.x > taa)\n    \t{\n\t        //bgCol = vec3(9.0, 5.0, 0.0);   // for testing antialiasing\n            col = mix( col, bgCol, aa);      // do antialasing\n        }\n        else col = bgCol;        // set pure background color\n    }\n\n    if (tmm.x > 0.0)             // add sphere reflection ?\n    {\n        vec3 nor = reflect(rd, (ro+tmm.x*rd) * 0.5);  // sphere normal\n        float fre = pow(0.3+ clamp(dot(nor,rd), 0.0, 1.0), 3. )*1.3;\n        // add reflecting color\n        col += GLAS_COLOR * fre * 0.1 *(1.0-aa);   // add some solid glas\n        if (show_reflections)\n\t      col += BACK_COLOR * map(nor) * fre * 0.3 *(1.0-aa);\n    }\n\n    // shade\n    col = 0.5 *(log(1.0 + col));\n    col = clamp(col, 0., 1.0);\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}