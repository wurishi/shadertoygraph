{"ver":"0.1","info":{"id":"DlS3RD","date":"1672942297","viewed":121,"name":"Light Normal of 2D Rays","username":"FatalSleep","description":"Using this for 2D GI purposes, calculates the dominant light normal direction of a set of N rays.\n\nSource Solution: https://stackoverflow.com/questions/5343629/averaging-angles","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.2831853071795864769252867665590\nfloat ATAN2(float yy, float xx) { return mod(atan(yy, xx), TAU); }\n\nfloat values[32] = float[](\n    0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, // Top-Right\n    0.9, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, // Top-Left\n    0.1, 0.1, 1.0, 0.1, 0.1, 0.1, 0.1, 0.1, // Bottom-Left\n    0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1  // Bottom-Right\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    float radius = iResolution.y * 0.45; // Spacing from center of screen.\n    float cirRad = iResolution.y * 0.05; // Visual Radius of ray circles.\n    \n    // Set Ray Position Offsets.\n    vec2 offsets[33];\n    float off = TAU/32.0;\n    for(int i = 0; i < 32; i++) {\n        offsets[i] = (iResolution.xy*0.5) + (vec2(cos(float(i) * off), sin(float(i) * off)) * radius);\n    }\n    \n    // Set Pixel color according to closest ray.\n    for(int i = 0; i < 32; i++)\n        if (distance(uv*iResolution.xy, offsets[i]) < cirRad)\n            col = vec3(values[i]);\n    \n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    // Calculate the light normal based on dominant ray brightness.\n    vec2 unit = vec2(0.0);\n    for(int i = 0; i < 32; i++)\n        unit += vec2(cos(float(i) * off) * values[i], sin(float(i) * off) * values[i]);\n    \n    float normal = ATAN2(unit.y, unit.x);\n    \n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    // Direct visual normal direction.\n    offsets[32] = (iResolution.xy*0.5) + (vec2(cos(normal), sin(normal)) * (radius*0.5));\n    if (distance(uv*iResolution.xy, offsets[32]) < cirRad)\n        col = vec3(normal/TAU);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n/*\nSOURCE: https://stackoverflow.com/questions/5343629/averaging-angles\n\nAdd unit vectors of each angle, and convert the resulting vector back into an angle. If the result vector is of zero length, the inputs cancelled each other out and the result is indeterminate.\n\nA unit vector has a length of 1, and its x and y lengths are given by the cosine and sine of the angle. Thus you average your examples as in the following pseudo-code:\n\nx = cos(radians(1)) + cos(radians(359)) + cos(radians(2)) + cos(radians(358));\ny = sin(radians(1)) + sin(radians(359)) + sin(radians(2)) + sin(radians(358));\nangle = degrees(atan2(y, x));\n*/","name":"Image","description":"","type":"image"}]}