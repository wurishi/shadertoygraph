{"ver":"0.1","info":{"id":"3sfSRn","date":"1550373093","viewed":402,"name":"Mapper","username":"Myro","description":"a 2D random map generator\n\n-> if someone has a method to make it 3D it would be much apreciated","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","sea","perlin","water","earth","grass","ocean","map","snow","reef","world","mountain","dirt","fantasy","biome","carthography"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D land map generator with 2 biomes and made using noise\n\n// \"vonronoise\" from https://www.shadertoy.com/view/Xd23Dh\n// More info here: https://iquilezles.org/articles/voronoise\n\n// ell noise    u=0,v=0\n// voronoi      u=1,v=0\n// perlin noise u=0,v1=\n// voronoise    u=1,v=1\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat vonronoi(vec2 x) {\n\treturn iqnoise(x,1.0,0.0);\n}\n\nfloat noise(vec2 x) {\n\treturn iqnoise(x,0.0,1.0);\n}\n\nfloat vonronoise(vec2 x) {\n\treturn iqnoise(x,1.0,1.0);\n}\n\n// vonronoi but with  intensity & contrast control\nfloat vonronoiStep(float i, float a, float b, vec2 x) {\n    float d = 0.2*(b-a);\n\treturn 1.0-i+(smoothstep(a-d, b+d, vonronoi(x))*(i));\n}\n\n// noise but with  intensity & contrast control\nfloat noiseStep(float i, float a, float b, vec2 x) {\n    float d = 0.2*(b-a);\n\treturn 1.0-i+(smoothstep(a-d, b+d, noise(x))*(i));\n}\n\n// vonronoise but with  intensity & contrast control\nfloat vonronoiseStep(float i, float a, float b, vec2 x) {\n    float d = 0.2*(b-a);\n\treturn 1.0-i+(smoothstep(a-d, b+d, vonronoise(x))*(i));\n}\n// iq noise but with  intensity & contrast control\nfloat iqStep(float i, float a, float b, float u, float v, vec2 x) {\n    float d = 0.2*(b-a);\n\treturn 1.0-i+(smoothstep(a-d, b+d, iqnoise(x, u, v))*(i));\n}\n\n\n/*\noperations :\n*\t: more dark\n/\t: more light\nmax : only lighter\nmin : only darker\n*/\n\nfloat getHeight(vec2 uv) {\n\tfloat h = 0.0;\n    // hills & valleys\n    h = noiseStep(1.0,0.2,0.8,uv*0.2);\n    h = max(h,0.8*noise((vec2(1000.0)+uv)*0.2));\n    h = min(h,1.0*noise((vec2(100.0)+uv)*0.5));\n    h = max(h,0.8*noise((vec2(800.0)+uv)*0.3));\n    \n    // seas\n   \th *= 1.0-min(h,vonronoiseStep(0.5,0.6,0.65,0.1*uv));\n\t//continents\n    h /= 1.8*vonronoiseStep(1.0,0.0,0.95,0.1*uv);\n    \n    // big seas\n   \th *= 1.0-min(h,vonronoiseStep(0.5,0.6,0.65,0.03*uv));\n\t// big continents\n    h /= 1.4*vonronoiseStep(1.0,0.0,0.95,0.03*uv);\n    \n    //rocky montain tops\n   \th = min(h,(vonronoiseStep(0.05,-0.6,1.6,uv*0.01)));\n    // random details stuff\n   \th *= vonronoiseStep(0.3,-0.6,1.6,vec2(1500.0)+uv*0.8);\n   \th /= vonronoiseStep(0.3,0.0,0.5,vec2(1500.0)+uv*0.1);\n    h /= iqStep(0.21,-0.6,1.6,1.0,0.5,uv*1.1);\n\t\n\treturn h;\n}\n\n\n//return a color from a to b when h goes from m to n (and divide the color by 255)\nvec3 colormix (vec3 a, vec3 b, float h, float m, float n) {\n    return mix(a/255.0, b/255.0, (h-m)/(n-m));\n}\n               \n//return a color from a to b to c when h goes from m to n (and divide the color by 255)\nvec3 tricolormix (vec3 a, vec3 b, vec3 c,float h, float m, float n) {\n\tfloat t = (h-m)/(n-m);\n    if (t<0.5) {\n    \treturn mix(a/255.0, b/255.0,t*2.0);\n    }\n    else {\n    \treturn mix(b/255.0, c/255.0,(t-0.5)*2.0);\n    }\n}\n\n\nvec3 biomeColor1 (float h) {\n\n    //vec3 fog=vec3(197.0,219.0,211.0);\n    float oceanh = 0.2;\n    vec3 ocean1 =vec3(8.0,42.0,79.0);\n    vec3 ocean2 =vec3(23.0,79.0,114.0);\n    float seah = 0.32;\n    vec3 sea1 =vec3(6.0,104.0,133.0);\n    vec3 sea2 =vec3(56.0,104.0,133.0);\n    float bayh = 0.4;\n    vec3 bay1 =vec3(79.0,176.0,159.0);\n    vec3 bay2 =vec3(93.0,204.0,167.0);\n    float shoreh = 0.45;\n    vec3 shore1 =vec3(131.0,246.0,191);\n    vec3 shore2 =vec3(234.0,246.0,191);\n    float beachh = 0.5;\n    vec3 beach1 =vec3(210.0,173.0,128.0);\n    vec3 beach2 =vec3(255.0,236.0,181.0);\n    float fieldh = 0.74;\n    vec3 field1 =vec3(31.0,122.0,4.0);\n    vec3 field2 =vec3(140.0,191.0,28.0);\n    float dirth = 0.92;\n    vec3 dirt1 =vec3(154.0,148.0,9.0);\n    vec3 dirt2 =vec3(204.0,170.0,31.0);\n    float rockh = 0.97;\n    vec3 rock1 =vec3(133.0,140.0,112.0);\n    vec3 rock2 =vec3(72.0,114.0,104.0);\n    vec3 snow1 =vec3(197.0,219.0,211.0);\n    vec3 snow2 =vec3(224.0,255.0,255.0);\n\n    if (h<oceanh)    \treturn colormix(ocean1, ocean2,h,0.0,oceanh);\n    if (h<seah)     \treturn tricolormix(ocean2,sea1,sea2,h,oceanh,seah);\n    if (h<bayh)         return tricolormix(sea2, bay1, bay2,h,seah,bayh);\n    if (h<shoreh)       return tricolormix(bay2, shore1, shore2,h,bayh,shoreh);\n    if (h<beachh)       return colormix(beach1, beach2,h,shoreh,beachh);\n    if (h<fieldh)       return colormix(field1,field2,h,beachh,fieldh);\n    if (h<dirth)        return tricolormix(field2, dirt1, dirt2,h,fieldh,dirth);\n    if (h<rockh)        return tricolormix(dirt2, rock1, rock2,h,dirth,rockh);\n\telse/*snow*/\t\treturn tricolormix(rock2,snow1, snow2,h,rockh,1.0);\t\n}\n\n\nvec3 biomeColor2(float h) {\n    \n    //vec3 fog=vec3(197.0,219.0,211.0);\n    float oceanh = 0.2;\n    vec3 ocean1 =vec3(8.0,42.0,79.0);\n    vec3 ocean2 =vec3(23.0,79.0,114.0);\n    float seah = 0.32;\n    vec3 sea1 =vec3(6.0,104.0,133.0);\n    vec3 sea2 =vec3(56.0,104.0,133.0);\n    float bayh = 0.4;\n    vec3 bay1 =vec3(79.0,176.0,159.0);\n    vec3 bay2 =vec3(93.0,204.0,167.0);\n    float shoreh = 0.45;\n    vec3 shore1 =vec3(131.0,246.0,191);\n    vec3 shore2 =vec3(234.0,246.0,191);\n    float beachh = 0.5;\n    vec3 beach1 =vec3(251.0,225.0,182.0);\n    vec3 beach2 =vec3(247.0,237.0,222.0);\n    float fieldh = 0.74;\n    vec3 field1 =vec3(118.0,102.0,33.0);\n    vec3 field2 =vec3(204.0,166.0,113.0);\n    float dirth = 0.92;\n    vec3 dirt1 =vec3(103.0,76.0,14.0);\n    vec3 dirt2 =vec3(156.0,79.0,32.0);\n    float rockh = 0.97;\n    vec3 rock1 =vec3(71.0,68.0,62.0);\n    vec3 rock2 =vec3(115.0,136.0,160.0);\n    vec3 snow1 =vec3(89.0,96.0,88.0);\n    vec3 snow2 =vec3(117.0,127.0,116.0);\n\n    if (h<oceanh)    \treturn colormix(ocean1, ocean2,h,0.0,oceanh);\n    if (h<seah)     \treturn tricolormix(ocean2,sea1,sea2,h,oceanh,seah);\n    if (h<bayh)         return tricolormix(sea2, bay1, bay2,h,seah,bayh);\n    if (h<shoreh)       return tricolormix(bay2, shore1, shore2,h,bayh,shoreh);\n    if (h<beachh)       return colormix(beach1, beach2,h,shoreh,beachh);\n    if (h<fieldh)       return colormix(field1,field2,h,beachh,fieldh);\n    if (h<dirth)        return tricolormix(field2, dirt1, dirt2,h,fieldh,dirth);\n    if (h<rockh)        return tricolormix(dirt2, rock1, rock2,h,dirth,rockh);\n\telse/*snow*/\t\treturn tricolormix(rock2,snow1, snow2,h,rockh,1.0);\t\n}\n\n\nfloat getBiome(vec2 uv) {\n    return noiseStep(1.0,0.45,0.55,0.01*uv);\n\t\n}\nvec3 getColor (vec2 uv, float h) {\n    float b = getBiome(uv);\n    return colormix( 255.0*biomeColor1(h),  255.0*biomeColor2(h), b,0.0,1.0);\n}\n\nconst float SCALE = 800.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized screen pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*2.0;\n    \n    vec4 mouse = iMouse / iResolution.x;\n    float scale = SCALE*mouse.y;\n    if (mouse.y <= 0.0) scale = 100.0;\n    float offset = (mouse.x);\n    \n    vec2 mapuv = uv;// coordinate on the map\n    mapuv *= scale;\n    mapuv += vec2(cos(0.01*iTime*pow(scale,0.2)+offset), sin(0.01*iTime*pow(scale,0.2)+offset))*10.0*scale;\n\tfloat height = getHeight(mapuv);\n    \n    // vignette & vertical gradient\n    float postfx = 0.05*(uv.y)-0.02*length(uv)*length(uv);\n    // Output to screen\n    fragColor = vec4(getColor(mapuv, height) + postfx,1.0);\n}","name":"Image","description":"","type":"image"}]}