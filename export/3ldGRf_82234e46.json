{"ver":"0.1","info":{"id":"3ldGRf","date":"1577080994","viewed":274,"name":"./banana.exe","username":"onlinerocker","description":"potassium\n\nnote: mouse moves the camera, but the banana is spinning (not the camera).\nso if you rotate the camera, you'll see the banana lit from different angles.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fruit","banana","potassium","nutrients"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define VIEW_DIST 20.0\n//change VIEW_DIST for farther or shorter render distance\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n \n//https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//iq\nfloat sdPlane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\n//iq\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n      p.y -= clamp( p.y, 0.0, h );\n      return length( p ) - r;\n}\n\n//iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.specVal = 20.0;\n    o.specKs = 0.1;\n    o.dist = 1000.0;\n    o.normEps = 0.00001;\n    o.color = vec3(0);\n    \n    pos -= vec3(0,0,0);\n    pos.xz = mat2(cos(-iTime), -sin(-iTime), sin(-iTime), cos(-iTime)) * pos.xz;\n    \n    vec3 banPos = pos + vec3(0,1.5,0);\n    banPos.x += sin(banPos.y) / 1.7;\n    float dBan = sdVerticalCapsule(banPos, 2.7, 0.50);\n\n    vec3 planePos = banPos;\n    planePos.y -= 1.5;\n    //planePos.x = abs(planePos.x);\n    planePos.z = abs(planePos.z);\n    float dPlane = sdPlane(planePos-vec3(-.6,0,-0.25), (vec4(-0.5, 0.0, 0.2, 0)));\n    dBan = max(dPlane, dBan);\n    vec3 green = vec3(.6,0.6,0);\n    vec3 brown = vec3(105,69,19)/255.0;\n    vec3 brown1 = vec3(105,69,19)/255.0;\n    \n    if(dBan < o.dist)\n    {\n     \to.dist = dBan;\n        //o.dist = max(o.dist, dPlane1);\n        \n        vec3 banCol = vec3(0.5, 0.5, 0)*fbm(pos*3.0) + brown*(1.0-fbm(pos*0.5));\n        banCol += vec3(0.5,0.5,0 )*fbm(pos*7.0) + brown1*(1.0-fbm(pos*7.0));\n        \n        o.color = green*(1.0-smoothstep(-0.6, 0.1, banPos.y)) + smoothstep(-0.6, 0.1, banPos.y)*banCol*step(banPos.y, 0.1);\n        o.color += step(0.1, banPos.y)*banCol*(1.0-smoothstep(2.3, 3.3, banPos.y)) + smoothstep(2.3, 3.3, banPos.y)*vec3(.6,0.7,0);\n    }\n    \n    vec3 banPosStem = banPos;\n    banPosStem.x += sin(banPos.y / 1.5);\n    float dBanStem =sdRoundBox(banPosStem-vec3(1.18,3.2,0), vec3(0.12, 0.206, 0.08), 0.1);\n    \n    float distTemp = o.dist;\n    o.dist = smin(o.dist, dBanStem, 0.1);\n    if(dBanStem < distTemp)\n    {  \n     \to.color = mix(o.color, brown, smoothstep(3.2, 3.5, banPos.y));     \n    }\n    \n    vec3 banBtmPos = banPos;\n    float ang = -PI/4.0;\n    banBtmPos.x -= 0.1*fbm(5.0*banBtmPos)\n        * step(-0.6, banBtmPos.y) * smoothstep(0.43, 0.63, banBtmPos.x)\n        * smoothstep(banBtmPos.y, banBtmPos.y+0.25, -0.1) ;\n    banBtmPos.xy = mat2(cos(ang), sin(ang), -sin(ang), cos(ang)) * banBtmPos.xy;\n    float dBanBtm = sdRoundBox(banBtmPos-vec3(-0.12, -0.40, 0), vec3(0.06, 0.06, 0.03), 0.2);\n    distTemp = o.dist;\n    o.dist = smin(o.dist, dBanBtm, 0.25);\n    if(dBanBtm < distTemp)\n    {\n        o.color = mix(o.color, brown*0.4, smoothstep(-0.58, -0.65, banBtmPos.y));\n    }\n    \n    float dBanCrease = sdVerticalCapsule(banPos - vec3(0.5,-0.25,0), 3.7, 0.01);\n    //dBan = \n    o.dist = smin(o.dist, dBanCrease, 0.2);\n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n\n    for(int x=0; x<200; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        if(abs(o.dist) < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nfloat calcShadow(vec3 pos, Light l)\n{\n    MarchRes res;\n    if(VIEW_DIST > 20.0)\n \t\tres = marchRay(pos, normalize(l.pos - pos), 0.3); //march slower to prevent shadow artifacts\n    else\n    \tres = marchRay(pos, normalize(l.pos - pos), 1.0);\n        \n    if(res.totalDist < VIEW_DIST)\n        return 0.0;\n\treturn 1.0;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   \n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    //lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n      \n    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0,0.0,3.5);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float camAng = PI/15.0 + iMouse.x/20.0;\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamX = mat2( vec2(cos(camAng), sin(camAng)), vec2(-sin(camAng), cos(camAng)) );\n\n    vec2 camXZ = rotCam * camEye.xz;\n    camEye = vec3(camXZ.x, camEye.y, camXZ.y);\n    vec2 dirXZ = rotCam * dir.xz;\n    dir = vec3(dirXZ.x, dir.y, dirXZ.y);\n    \n    Light light;\n    light.intensity = 1.00;\n    light.pos = vec3(5, 8, 10);\n    light.color = vec3(1);\n    \n    Light light1;\n    light1.intensity = 1.00;\n    light1.pos = vec3(-10, 4, -10);\n    light1.color = vec3(1);\n    \n    Light light2;\n    light2.intensity = 1.00;\n    light2.pos = vec3(10, 4, -10);\n    light2.color = vec3(0.7);\n    \n    Light lightSky;\n    lightSky.intensity = 3.1;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(0.1, 0.1, 0.1);\n    \n\tMarchRes res = marchRay(camEye, dir, 0.8);\n    vec3 pos = res.curRay;  \n    \n    float y = uv.y + 1.0;\n    y = y / 1.62;\n    y = clamp(y, 0.7, 1.0);\n    vec3 col = (vec3(0.3, 0.6, 0.85)*(y) + vec3(1)*(1.0 - y));\n\n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, pos) * calcShadow(pos, light) + calcDiffuseLight(res.obj, lightSky, vec3(0,0,0));\n        //col += calcDiffuseLight(res.obj, light1, pos);\n        //col += calcDiffuseLight(res.obj, light2, pos);\n        col += calcSpecLight(res.obj, light,pos, camEye) * calcShadow(pos, light);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}