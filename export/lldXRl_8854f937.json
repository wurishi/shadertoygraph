{"ver":"0.1","info":{"id":"lldXRl","date":"1481285398","viewed":153,"name":"Sunset on Sea","username":"azsteak","description":"a small animation !","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","training"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sun movement\nfloat mvtStart = 3.0;\nfloat mvtRadius;\nfloat speed = 30.0;\nvec2 offset;\n\n// Water\nfloat waterHeight = 0.2; // 0 to 1\nfloat waveMax = 0.5; \nfloat waveLength = 1.0;\nfloat waveSpeed = 0.02;\nfloat waveTransSpeed = 20.0;\n\nfloat waterLimit;\nfloat waveHeight;\n\n// Water color\nfloat degradeForce = 1.0;\nfloat degradeLength = 1.0;\n\n//tint\nfloat coefNuit;\n\n\nfloat rand( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}float randFromVec2(vec2 v){\n    return rand(v.x*rand(v.y)*rand(v.y*v.x));\n}\n\nvoid drawSun(out vec4 color, vec2 pixCoords, vec2 point, float luminosity,float radius){\n    \n    float d = sqrt(pow(pixCoords.x-point.x,2.0)+pow(pixCoords.y-point.y,2.0))/radius*1000.0;\n    float coef = (1.0-d/iResolution.x)*luminosity;\n    \n    \n    coefNuit=max(0.0,min(1.0,point.y/offset.y));\n    \n    float red=max(0.4,coef) * pow(coefNuit,1.0);\n    float green=max(0.4,coef) * pow(coefNuit,4.0);\n    float blue=(1.0-coef) * pow(coefNuit,4.0);\n    \n    color = vec4(red,green,blue,1.0*waterHeight);\n}\nvoid drawStars(out vec4 color, vec2 pixCoords){\n    float randomCycle = randFromVec2(pixCoords);\n    float starBrightness = (cos(3.14*iTime*0.01+2.0*3.1415*randomCycle)*0.5+0.5)*(1.0-coefNuit);\n    color += vec4(starBrightness,starBrightness,starBrightness,1.0);\n}\nvoid drawWater(out vec4 color, in vec2 pixCoords,float horizonHeight){\n    float heightDegrade = -pixCoords.y*(pixCoords.y/horizonHeight)/(iResolution.y*(1.0-waterHeight))*coefNuit*2.0;\n    \n    float coefWaterColor = max(coefNuit*degradeLength,0.1)+heightDegrade*degradeForce;\n    \n    color = vec4(0.2*coefWaterColor,0.2*coefWaterColor,1.0*coefWaterColor,1);\n}\nbool isWater(vec2 pixCoords){\n    waveHeight = cos(3.14*float(iFrame)*waveSpeed);\n    float sinusoide = 1.0;\n    for(float i = 1.0 ; i < 5.0 ; i++){\n        sinusoide  += cos(2.0*3.14*pixCoords.x*waveLength*rand(i)*0.01 + (iTime+i)*waveTransSpeed);\n    }for(float i = 1.0 ; i < 5.0 ; i++){\n        sinusoide  += cos(3.14*pixCoords.x*waveLength*rand(i)*0.01 - (iTime+i)*waveTransSpeed);\n    }\n    \n    waterLimit = iResolution.y*waterHeight + waveHeight*sinusoide*waveMax;\n    \n    return pixCoords.y< waterLimit;\n}\nbool isStar(in vec2 realCoords, float proba){\n      \n    bool a = randFromVec2(realCoords)>proba;\n    vec2 mCoords = realCoords; \n    mCoords.x += 1.0;\n    \n    bool b = randFromVec2(mCoords)>proba;\n    mCoords = realCoords; \n    mCoords.x -= 1.0;\n    bool c = randFromVec2(mCoords)>proba;\n    \n    mCoords = realCoords; \n    mCoords.y += 1.0;\n    bool d = randFromVec2(mCoords)>proba;\n    mCoords = realCoords; \n    mCoords.y -= 1.0;\n    bool e = randFromVec2(mCoords)>proba;\n    \n    return a || b || c || d || e;\n}\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{   \n    offset = vec2(iResolution.x/2.0,iResolution.y*waterHeight);\n\tmvtRadius = iResolution.x / 3.0;\n    float y = sin(3.14*iTime/1000.0*speed+mvtStart)*mvtRadius+offset.y;\n    coefNuit=max(0.0,min(1.0,y/offset.y));\n    \n    if(isWater(pixCoords)){\n        drawWater(color,pixCoords,waterLimit);\n    }else{\n        float x = cos(3.14*iTime/1000.0*speed+mvtStart+3.14)*mvtRadius+offset.x;\n        \n    \tvec2 center = vec2(x,y);\n        drawSun(color,pixCoords,center,2.0,100.0);\n        \n        \n        vec2 starCoords;\n        starCoords.x = pixCoords.x - float(iFrame);\n        starCoords.y = pixCoords.y;\n        \n        if(isStar(starCoords,0.999)){\n            drawStars(color,starCoords);\n        }\n    }\n}\n","name":"Image","description":"","type":"image"}]}