{"ver":"0.1","info":{"id":"tt3yWB","date":"1609871109","viewed":71,"name":"Truchet Custom Pattern","username":"qw","description":"Truchet custom Pattern","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","truchet","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cellCount 10.\n#define cellSize 1./cellCount\n#define halfPi 1.5707963\n\n\nfloat Rand2To1(vec2 id){\n    \n    //For flawless Looping, we should be able to use \"Polar Noise\" values,\n    //effectively sampling the x & y values of a circle, and use these to generate random seeds\n    //since we'll eventually loop around, the result shader effect should also flawlessly loop, \n    //... Not convinced my implementation is correct though :p \n    \n    float T = floor(iTime / 1.);\n    vec2 timeSeed = vec2( cos(T)+1., sin(T)+1. );\n    float timeFactor = fract( timeSeed.x*cos(timeSeed.y*timeSeed.x) );\n\n\n    return fract(sin(id.x*3.23+id.y*54.342)*854.53\n    * timeFactor * 0.4123);\n    ;\n}\n\n\nvec3 Rand2To3(vec2 id){\n    float r = Rand2To1(id);\n    return vec3( r, fract(r*10.), fract(r*100.));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, in float thick){\n\n    return 1.-smoothstep(thick - 1.5/iResolution.y, thick, sdSegment(p,a,b));\n}\n\nfloat TruchetPattern(vec2 cellCenter){\n\n    float d = cellSize*.5;\n    float sd = cellSize*0.1;//Small distance\n    float td = cellSize*0.01; // tiny distance\n    float thickness = 0.045/cellCount;\n\n    return clamp(\n        line( cellCenter, vec2(sd,sd), vec2(d,sd), thickness)\n        + line( cellCenter, vec2(-sd,-sd), vec2(d,-sd), thickness)\n        + line( cellCenter, vec2(sd,sd), vec2(sd,d), thickness)\n        + line( cellCenter, vec2(-sd,-sd), vec2(-sd,d+sd*cellSize), thickness)\n\n\n        //L\n        + line( cellCenter, vec2(-d,sd), vec2(-d*.5,sd), thickness)\n        + line( cellCenter, vec2(-d,-sd), vec2(-d*.75,-sd), thickness)\n\n        //B\n        + line( cellCenter, vec2(sd,-d), vec2(sd,-d*.5), thickness)\n        + line( cellCenter, vec2(-sd,-d), vec2(-sd,-d*0.75), thickness)\n\n        //Lower Left Shape\n        + line( cellCenter, vec2(-d*.5,sd), vec2(-d*.5,-d*.45), thickness)\n        + line( cellCenter, vec2(sd,-d*.5), vec2(-d*.45,-d*.5), thickness)\n\n        + line( cellCenter, vec2(-d*.75,-sd), vec2(-sd,-d*0.75), thickness)\n\n    ,0.,1.);\n}\n\nfloat DrawPattern(vec2 uv, vec2 id, float pattern){\n    \n    if(length(id) == 0. ){return 0.;}\n    \n    vec2 cellUV = uv - ( (id /cellCount) - (cellSize*0.5));\n    float angle = halfPi * pattern;\n    mat2x2 rot = mat2x2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    //Rotate by random * 90 degree rotations\n    cellUV *= rot;\n    \n    //Truchet pattern \n    return TruchetPattern( cellUV);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) /iResolution.y;\n\n    uv.x += 0.5; \n\n    vec2 id = floor(uv*(cellCount));\n    id++;\n    id *= step(0.,id.x-1.) * step(id.x,cellCount);\n    \n    vec3 col = vec3(0);\n    float pattern =  floor( Rand2To1(id) / 0.25) / 4.;\n    col += mix(vec3(.1),vec3(0.5,0.,0.), DrawPattern(uv, id, pattern*4.));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}