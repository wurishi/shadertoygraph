{"ver":"0.1","info":{"id":"43dXWs","date":"1719799592","viewed":44,"name":"图片在屏幕上的移动与缩放","username":"langzai","description":"图片以自身中心为原点的缩放和移动","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","texture","uv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 CenterUV(vec2 fragCoord )//uv的居中与反拉伸https://www.shadertoy.com/view/M3cSDS\n{\n    return (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\nfloat CrateCenterGrid(vec2 uv,float cellSize)//创建居中网格https://www.shadertoy.com/view/4fXyzr\n{\n    float line = 0.005;\n    vec2 gridUV= step(line,abs(0.5 * cellSize- mod(uv - 0.5 * cellSize,cellSize)));\n    return gridUV.x* gridUV.y;\n}\n//输入为（相对位置使用的uv坐标，图片的尺寸，图片的位置，图片的缩放）\nvec2 MoveTexUV(vec2 uv,vec2 TexSize,vec2 TexPos,float TexSacle)//图片排版\n{\n    vec2 texUV = uv-TexPos;\n    if(TexSize.x>TexSize.y) texUV.x *= TexSize.y/TexSize.x;\n    else texUV.y *= TexSize.x/TexSize.y;\n    return texUV/TexSacle + 0.5;\n}\n\nvec4 CoverTex(vec4 downColor,sampler2D tex,vec2 uv)\n{\n    vec4 upColor = vec4(0.);\n    if(uv.x>0.&&uv.x<1.&&uv.y>0.&&uv.y<1.)//去掉重复\n        upColor = texture(tex,uv);\n    vec3 color = downColor.rgb + upColor.rgb * upColor.a;//非重合区域的颜色是各自的颜色\n    return vec4(mix(color,upColor.rgb,downColor.a*upColor.a),min(1.,downColor.a+upColor.a));//重合区域的颜色为upcolor，alpha叠加\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = CenterUV(fragCoord );\n   \n    vec4 color = vec4(0.);\n    color = vec4(1.-CrateCenterGrid(uv,0.2));\n    color = CoverTex(color,iChannel0,MoveTexUV(uv,iChannelResolution[0].xy,vec2(0,.5),.4));\n    color = CoverTex(color,iChannel1,MoveTexUV(uv,iChannelResolution[1].xy,vec2(-1.2,-.4),1.));\n    color = CoverTex(color,iChannel2,MoveTexUV(uv,iChannelResolution[2].xy,vec2(0.,-.2),1.2));\n    color = CoverTex(color,iChannel3,MoveTexUV(uv,iChannelResolution[3].xy,vec2(0.5,-.2),0.8));\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}