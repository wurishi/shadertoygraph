{"ver":"0.1","info":{"id":"ssVfzm","date":"1658670908","viewed":95,"name":"Jordi PerlinNoise","username":"sp33s","description":"Utilized sources:\n\nhttps://en.wikipedia.org/wiki/Perlin_noise\nhttps://adrianb.io/2014/08/09/perlinnoise.html\nhttps://www.youtube.com/watch?v=MJ3bvCkHJtE","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Perlin noise shader, not written for performance but understandability :)\n\nconst float PHI = 1.61803398874989484820459; // Î¦ = Golden Ratio\nconst float GRID_SIZE_PX = 20.0;\nconst vec2 DIRECTIONS[12] = vec2[12]( \n    vec2(1.0, 1.0), vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(-1.0, -1.0),\n    vec2(1.0 ,0.0), vec2(-1.0, 0.0), vec2(1.0, 0.0), vec2(-1.0, 0.0),\n    vec2(0.0, 1.0), vec2(0.0, -1.0), vec2(0.0, 1.0), vec2(0.0, -1.0)\n); \nconst bool IMPROVED_PERLIN_NOISE = true;\n\n\n// Defines a point on the grid with its direction/gradient vector and px based position\nstruct GridPoint\n{\n    vec2 direction;\n    vec2 position;\n};\n\n// Ripped from https://stackoverflow.com/a/28095165/9763789\nfloat GoldNoise(const in vec2 xy, const in float seed)\n{\n    return fract(tan(distance(xy * PHI, xy) * seed) * xy.x);\n}\n\n// Converts a [-1..1] float to [0..1]\nfloat To01Space(const in float value)\n{\n    return (value + 1.0) / 2.0;\n}\n\n// Converts a [-1..1] vector to [0..1]\nvec2 To01Space(const in vec2 value)\n{\n    return vec2(To01Space(value.x), To01Space(value.y));\n}\n\n// Converts a [0..1] float to [-1..1]\nfloat To11Space(const in float value)\n{\n    return value * 2.0 - 1.0;\n}\n\n// Converts a [0..1] vector to [-1..1]\nvec2 To11Space(const in vec2 value)\n{\n    return vec2(To11Space(value.x), To11Space(value.y));\n}\n\n// Gets a grid point at a certain px position, clamping it down to the closest lower left gridpoint from that position\nGridPoint GetGridPoint(const in vec2 fragCoord)\n{\n    GridPoint gridPoint;\n    gridPoint.position = vec2(floor(fragCoord.x / GRID_SIZE_PX) * GRID_SIZE_PX, floor(fragCoord.y / GRID_SIZE_PX) * GRID_SIZE_PX);\n    \n    // Need to offset X by 1 because inputting 0 results in complete black\n    const vec2 offset = vec2(1.0, 0.0);\n\n    if (IMPROVED_PERLIN_NOISE)\n    {\n        float rand = GoldNoise(gridPoint.position + offset, 0.7);\n        gridPoint.direction = DIRECTIONS[int(rand * 12.0)];\n    }\n    else\n    {\n        // Get two random directions in [0..1] with two completely random seeds\n        // Uncomment for oldschool perlin noise\n        float directionX = GoldNoise(gridPoint.position + offset, 0.5);\n        float directionY = GoldNoise(gridPoint.position + offset, 0.7);\n\n        vec2 directionVector = vec2(directionX, directionY);\n        // Convert it to [-1..1]\n        directionVector = To11Space(directionVector);\n\n        // Normalize vector so its magnitude remains 1\n        gridPoint.direction = normalize(directionVector);\n    }\n    \n    return gridPoint;\n}\n\n// Returns the four direction vectors at each gridpoint given a point on screen\nGridPoint[4] GetGridPoints(const in vec2 fragCoord)\n{\n    GridPoint gridPoints[4];\n    gridPoints[0] = GetGridPoint(fragCoord); // lower left\n    gridPoints[1] = GetGridPoint(vec2(fragCoord.x, fragCoord.y + GRID_SIZE_PX)); // upper left\n    gridPoints[2] = GetGridPoint(vec2(fragCoord.x + GRID_SIZE_PX, fragCoord.y + GRID_SIZE_PX)); // upper right\n    gridPoints[3] = GetGridPoint(vec2(fragCoord.x + GRID_SIZE_PX, fragCoord.y)); // lower right\n    \n    return gridPoints;\n}\n\n// Calculate the dot product for all 4 gridpoints between the given gridpoint direction vector\n// and a direction vector pointing to the given pixel position.\nfloat[4] GetDotProducts(const in GridPoint[4] gridPoints, const in vec2 fragCoord)\n{\n    float dotProducts[4];\n    \n    for (int i = 0; i < 4; i++)\n    {\n        vec2 distanceVector = fragCoord - gridPoints[i].position;\n\n        // Our direction vectors sit in the [-1..1] range, therefore our distance vector\n        // needs to be converted to this range too. This is not the same as normalizing\n        // the vector, as this would guarantee a vector length of 1.\n        distanceVector = distanceVector / vec2(GRID_SIZE_PX, GRID_SIZE_PX);\n        \n        dotProducts[i] = dot(distanceVector, gridPoints[i].direction);\n    }\n    \n    return dotProducts;\n}\n\n// Fades from one dot product to the other, using mix as a lerp function\nfloat GetAverage(const in float[4] dotProducts, const in vec2 fragCoord)\n{\n    // Convert pixel position to a [0..1] position within that grid\n    float u = mod(fragCoord.x, GRID_SIZE_PX) / GRID_SIZE_PX;\n    float v = mod(fragCoord.y, GRID_SIZE_PX) / GRID_SIZE_PX;\n    \n    // Utilizing smoothstep to flatten curve out the linear part of the lerp\n    u = smoothstep(0.0, 1.0, u); \n    v = smoothstep(0.0, 1.0, v);\n    \n    // Lerp from lower left to lower right\n    float x1 = mix(dotProducts[0], dotProducts[3], u);\n    // Lerp from upper left to upper right\n    float x2 = mix(dotProducts[1], dotProducts[2], u);\n    \n    // Lerp vertically between the above two\n    return mix(x1, x2, v);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float color;\n    \n    vec2 pos = fragCoord;\n    //pos.x += iTime;\n    \n    GridPoint[4] gridPoints = GetGridPoints(pos);\n    float[4] dotProducts = GetDotProducts(gridPoints, pos);\n    //color = To01Space(gridPoints[0].direction.y);\n    //color = To01Space(dotProducts[0]);\n    color = To01Space(GetAverage(dotProducts, pos));\n    \n    // Output to screen\n    fragColor = vec4(color, color, color, 1.0);\n}","name":"Image","description":"","type":"image"}]}