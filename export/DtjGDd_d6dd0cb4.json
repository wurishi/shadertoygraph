{"ver":"0.1","info":{"id":"DtjGDd","date":"1674245539","viewed":579,"name":"Ruined Temple","username":"Poisson","description":"A pathtraced ruined temple on sand dunes, with 3 global illumination bounces, and volumetric clouds with isotropic scattering. For the temple, I used a simple kif fractal or mandelbox. I added blur and bloom to the final image using my bokeh blur function","likes":30,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","raymarching","fractal","raytracer","ray","volume","cloud","volumetric","raymarcher","pathtracing","pathtracer","path","sand","dune","kif"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I'm very happy with this one, because it's look like a film frame\n// for the temple, I used a simple kif fractal\n// and the scene is pathtraced with 3 global illumination bounces\n// I added blur and bloom to the final image using my bokeh blur function\n\n// ACES tomemapper\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// bokeh blur function\n// b is the blur value\nvec4 bokeh(sampler2D sam, vec2 p, float b) {    \n    vec4 col = vec4(0);\n    const int N = 8; // quality\n    \n    for (int i=-N; i<=N; i++)\n    for (int j=-N; j<=N; j++)  {\n        vec2 off = vec2(i,j) / float(N); // blur offset\n        if (dot(off, off)<1.) { // inside disk\n            // blurred texture\n            col += texture(iChannel0, p + b*off*vec2(iResolution.y/iResolution.x,1));\n        }\n    }\n    // output\n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n    \n    // base texture with blur on the edges of the screen\n    vec4 data = texture(iChannel0, p);\n    vec3 col = data.rgb/data.w;\n    \n    // color correction\n    col = pow(col, vec3(.4545)); // gamma correction\n    col = ACES(col); // tonemapping\n    col = col*col*(3.-2.*col); // contrast\n    \n    // bloom\n    vec3 bloom = bokeh(iChannel0, p, .1).rgb; // blurred texture\n    bloom = pow(bloom, vec3(.4545)); // gamma correction\n    bloom = ACES(bloom); // tonemapping\n    // adding the bloom to the final color\n    col += .4*pow(bloom,vec3(4));\n        \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DIST 70. // maximum render distance\n\n// sun direction\nconst vec3 lig = normalize(vec3(-.8,1,1));\n\n// randoms seed\nfloat seed;\n\n// hash functions by me\nfloat hash1() {return fract(sin(seed+=.1)*4561.7564);}\n\nvec2 hash2() {return fract(sin(seed+=.1)*vec2(8472.5636,9854.4213));}\n\nvec3 hash3() {return fract(sin(seed+=.1)*vec3(7653.1285,6912.8512,5914.7134));}\n\n// normalized 3d vector\nvec3 uniformVector() {\n    vec3 v = hash3()*2.-1.;\n    return normalize(v);\n}\n\n// 3d rotation function\nmat3 rot(vec3 a){\n    float c = cos(a.x), s = sin(a.x);\n    mat3 rx = mat3(1,0,0,0,c,-s,0,s,c);\n    c = cos(a.y), s = sin(a.y);\n    mat3 ry = mat3(c,0,-s,0,1,0,s,0,c);\n    c = cos(a.z), s = sin(a.z);\n    mat3 rz = mat3(c,-s,0,s,c,0,0,0,1);\n    \n    return rz * rx * ry;\n}\n\n// float random number between 0 and 1\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// 3d noise function by iq\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f); // S curve\n\n    float n = p.x + p.y*157. + 113.*p.z;\n\n    return mix(mix(mix(hash(n+  0.), hash(n+  1.),f.x),\n                   mix(hash(n+157.), hash(n+158.),f.x),f.y),\n               mix(mix(hash(n+113.), hash(n+114.),f.x),\n                   mix(hash(n+270.), hash(n+271.),f.x),f.y),f.z);\n}\n\n// 2d noise function by iq\nfloat noise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.-2.*f); // S curve\n\n    float n = p.x + p.y*138.;\n\n    return mix(mix(hash(n+  0.), hash(n+  1.),f.x),\n               mix(hash(n+138.), hash(n+139.),f.x),f.y);\n}\n\n// 3d fractal noise\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .125*noise(4.*p);\n    f += .0625*noise(8.*p);\n    return f;\n}\n\n// 2d fractal noise\nfloat fbm(vec2 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .125*noise(4.*p);\n    f += .0625*noise(8.*p);\n    return f;\n}\n\n// temple sdf\n// a simple fractal from my starship shader\n// https://www.shadertoy.com/view/ml2GWc\nfloat sdRuins(vec3 p) {\n    mat3 r = rot(vec3(2.));\n   \n    vec3 q = p;\n    float m = 1.;\n    \n\tfor (int i=0; i<7; i++) {\n    \tp = clamp(p,-1.,1.) * 2. - p;\n        float h = clamp(.25/dot(p, p), .25, 1.);\n    \tp *= h;\n        m *= h;\n        if(i<2) p *= r;\n    \tp = p*9. + q;\n        m = m*9.+1.;\n\t}\n    q = abs(p);\n\treturn (max(q.x,max(q.y,q.z))-3.) / m;\n}\n\n// smooth minimum\n// thanks to iq: https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5+.5*(b-a)/k, 0., 1.);\n\treturn mix(b, a, h) - k*h*(1.-h);\n}\n\n// scene sdf (temple + clouds + dunes)\nfloat map(vec3 p) { \n    // dunes\n    float d = p.y-3.+.05*fbm(p.xz*7.+.4*sin(35.*p.x+.5*sin(p.z*28.)))-.06*noise(2.5*p.xz);\n    // ruins\n    d = min(d, sdRuins(p));\n    // cheap clouds\n    float h = log(hash1());\n    d = min(d, smin(abs(p.y-10.)-.06, fbm((p*.3+10.+vec3(1,0,0))), -.1)-.7*fbm(p) - .2*(h+.5));\n    \n    return d;\n}\n\n// raymarching function\nfloat intersect(vec3 ro, vec3 rd, float tmax) {\n    float t = 0.; // distance travelled\n    \n    for (int i=0; i<256; i++) {\n        vec3 p = ro + rd*t; // current point\n        \n        float h = map(p); // distance to the scene\n        if (h<.001) break; // we hit the surface\n        \n        t += h; // march\n        if (t>tmax) return MAX_DIST;\n    }\n    // return distance\n    return t;\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p);\n    const vec2 e = vec2(.0001,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy),\n                              map(p-e.yxy),\n                              map(p-e.yyx)));\n}\n\n// shadow function\nfloat shadow(vec3 ro, vec3 rd, float tmax) {\n    for (float t=0.; t<tmax;) {\n        vec3 p = ro + rd*t;\n        float h = map(p);\n        if (h<.001) return 0.;\n        t += h;\n    }\n    return 1.;\n}\n\n// fog based on the distance t\nfloat fog(float t) {\n    return 1.-exp(-t*t*t*.000005); // beer's law\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    // background\n    vec3 bgCol = mix(vec3(.6,.8,1), vec3(.3,.5,1), clamp(1.-exp(-rd.y*8.),0.,1.));\n    \n    float fdis = 0.; // final distance\n    vec3 frd = rd; // final ray direction\n    \n    vec3 col = vec3(0); // accumulated color\n    vec3 emit = vec3(1); // color mask\n    \n    for (int i=0; i<3; i++) { // 3 global illumination bounces\n        float t = intersect(ro, rd, MAX_DIST);\n        if (i==0) fdis = t;\n        \n        // we don't hit the surface\n        if (t>=MAX_DIST) {\n            if (i==0) col = bgCol;\n            col += .25*emit*bgCol; // sky light\n            break;\n        }\n        \n        vec3 p = ro + rd*t; // hit point\n        vec3 n = calcNormal(p); // normal of the surface\n        \n        ro = p+n*.002; // new ray origin + bump to avoid self collision\n        \n        float dif = clamp(dot(n,lig), 0., 1.); // diffuse light\n        \n        if (p.y<6.) { // sand and temple BRDF\n            emit *= vec3(.8,.6,.4); // yellow\n            rd = normalize(n+uniformVector()); // cheap diffuse BRDF\n        } else { // clouds BRDF\n            emit *= .7;\n            rd = uniformVector(); // isotropic scattering (because clouds are volumes)\n            dif = 1.; // clouds don't need the diffuse component of the light\n        }   \n        // sun light\n        float sha = shadow(ro, lig, 16.);\n        col += emit*vec3(1,.7,.4)*dif*sha;\n    }\n    col = mix(col, bgCol, fog(fdis)); // fog\n    // sun glare\n    col += 2.*vec3(1,.5,.3)*pow(clamp(dot(frd, lig),0.,1.),5.);\n        \n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init randoms seed\n    seed = iTime+dot(sin(fragCoord),vec2(453.712,983.234));\n    \n    vec2 off = hash2()-.5; // antialiasing offset\n    // pixel coordinates centered at the origin + AA offset\n    vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n\n    float an = -1.3; // camera angle\n    vec3 ro = vec3(-5.5*sin(an),3.5,5.5*cos(an)); // ray origin\n    vec3 ta = vec3(0,3.9,0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n    \n    // render\n    vec3 col = render(ro, rd);\n       \n    // progressive rendering (mix the color with the previous frame)\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(col,1.0) + data;\n}","name":"Buffer A","description":"","type":"buffer"}]}