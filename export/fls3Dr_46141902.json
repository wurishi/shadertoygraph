{"ver":"0.1","info":{"id":"fls3Dr","date":"1622120317","viewed":394,"name":"Atmosphere Transmittance","username":"pajunen","description":"Transmittance LUT from paper Precomputed Atmospheric Scattering by Eric Bruneton and Fabrice Neyret 2008.\nhttps://hal.inria.fr/inria-00288758/document\nReference:\nhttps://ebruneton.github.io/precomputed_atmospheric_scattering/atmosphere/functions.glsl.html","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["transmittance","atmosphere","lut","neyret","bruneton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 get_transmittance_to_atm_top(float mu, float r) {\n    vec2 uv = mu_r_to_uv(mu, r, iResolution.xy);\n    return texture(iChannel0, uv).xyz;\n}\n\nvec3 get_transmittance(float mu, float r, float d, bool intersects_ground) {\n    float r_d = clamp(sqrt(d * d + 2. * r * mu * d + r * r), A_r, A_R);\n    float mu_d = clamp((r * mu + d) / r_d, -1., 1.);\n        \n    if (intersects_ground) {\n        return min(\n            get_transmittance_to_atm_top(-mu_d, r_d) /\n            get_transmittance_to_atm_top(-mu, r),\n            vec3(1.)\n        );\n    } else {\n        return min(\n            get_transmittance_to_atm_top(mu, r) /\n            get_transmittance_to_atm_top(mu_d, r_d),\n            vec3(1.)\n        );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x - vec2(.5, .5 * iResolution.y / iResolution.x);\n\n    vec3 X = vec3(0, 0, -4. * A_R);\n    vec3 V = normalize(vec3(uv, 1.));\n    \n    float mu;\n    float r;\n    bool intersects_ground;\n    float d;\n    bool hit = get_intersection_info(X, V, mu, r, intersects_ground, d);\n    \n    vec3 t = vec3(1.);\n    \n    if (hit) {\n        t = get_transmittance(mu, r, d, intersects_ground);\n    }\n    \n    fragColor = vec4(t, 1.);\n  \n    // Uncomment to see the raw transmittance LUT\n    //fragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).xyz, 1.);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float r;\n    float mu;\n    uv_to_mu_r(uv, mu, r, iResolution.xy);\n    fragColor = vec4(transmittance_to_atm_top(mu, r), 1);   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Based on https://hal.inria.fr/inria-00288758/document\n// Reference implementation github:\n// https://github.com/ebruneton/precomputed_atmospheric_scattering\n\nconst float A_r = 1000.; // Atmosphere bottom radius\nconst float A_R = 2000.; // Atmosphere top radius\n\nconst vec3  planet_pos = vec3(0); // Planet position\n\nconst float length_unit_in_meters = 1000.; // Kilometer\n\nconst float scale = 10. * 10e-6; // 10 times denser than earth atmosphere\n\n\n// Scattering, Absorption and Extinction coefficients //\n\n\n// Rayleigh\nconst vec3 ray_s = vec3(5.802, 13.558, 33.1) * scale;\nconst vec3 ray_a = vec3(0.);\nconst vec3 ray_e = ray_s + ray_a;\n\n// Mie\nconst vec3 mie_s = vec3(3.996) * scale;\nconst vec3 mie_a = vec3(4.4)   * scale;\nconst vec3 mie_e = mie_s + mie_a;\n\n// Ozone\nconst vec3 ozo_s = vec3(0.);\nconst vec3 ozo_a = vec3(0.65, 1.881, 0.085) * scale;\nconst vec3 ozo_e = ozo_s + ozo_a;\n\nconst float rayleigh_scale_height = 20. * 8000.0;\nconst float mie_scale_height      = 20. * 1200.0;\n\nstruct DensityProfileLayer {\n  float width;\n  float exp_term;\n  float exp_scale;\n  float linear_term;\n  float constant_term;\n};\n\nstruct DensityProfile {\n    DensityProfileLayer layers[2];\n};\n\n\nconst DensityProfile rayleigh_density = DensityProfile(\n    DensityProfileLayer[](\n        DensityProfileLayer(0.0,0.0,0.0,0.0,0.0),\n        DensityProfileLayer(\n            0.,\n            1.,\n            -length_unit_in_meters / rayleigh_scale_height,\n            0.,\n            0.\n        )\n    )\n);\n\nconst DensityProfile mie_density = DensityProfile(\n    DensityProfileLayer[](\n        DensityProfileLayer(0.0,0.0,0.0,0.0,0.0),\n        DensityProfileLayer(\n            0.,\n            1.,\n            -length_unit_in_meters / mie_scale_height,\n            0.,\n            0.\n        )\n    )\n);\n\nconst DensityProfile absorption_density = DensityProfile(\n    DensityProfileLayer[](\n        DensityProfileLayer(\n            25000. / length_unit_in_meters,\n            0.,\n            0.,\n            length_unit_in_meters / 15000.,\n            -2. / 3.),\n        DensityProfileLayer(\n            0.,\n            0.,\n            0.,\n            -length_unit_in_meters / 15000.,\n            8. / 3.)\n    )\n);\n\nfloat d_to_atm_top(float mu, float r) {\n    float discriminant = r * r * (mu * mu - 1.0) + A_R * A_R;\n    return max(-r * mu + sqrt(max(discriminant, 0.)), 0.);\n}\n\nfloat d_to_atm_bot(float mu, float r) {\n    float discriminant = r * r * (mu * mu - 1.0) + A_r * A_r;\n    return max(-r * mu + sqrt(max(discriminant, 0.)), 0.);\n}\n\nfloat unit_range_to_tex_coord(float x, float tex_size) {\n    return .5 / tex_size + x * (1. - 1. / tex_size);\n}\n\nfloat tex_coord_to_unit_range(float u, float tex_size) {\n    return (u - .5 / tex_size) / (1. - 1. / tex_size);\n}\n\n\nfloat get_layer_density(DensityProfileLayer layer, float h) {\n    float density = (\n        layer.exp_term * exp(layer.exp_scale * h) +\n        layer.linear_term * h + layer.constant_term);\n       return clamp(density, 0., 1.);\n}\n\nfloat get_profile_density(DensityProfile profile, float h) {\n    return h < profile.layers[0].width ?\n        get_layer_density(profile.layers[0], h) :\n        get_layer_density(profile.layers[1], h);\n}\n\nfloat optical_length_to_atm_top(DensityProfile profile, float mu, float r) {\n    int SAMPLE_COUNT = 15;\n    float dx = d_to_atm_top(mu, r) / float(SAMPLE_COUNT);\n    float res = 0.;\n    for (int i = 0; i <= SAMPLE_COUNT; ++i) {\n        float d_i = float(i) * dx;\n        float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);\n        float y_i = get_profile_density(profile, r_i - A_r);\n        float w_i = i == 0 || i == SAMPLE_COUNT ? 0.5 : 1.0;\n        res += y_i * w_i * dx;\n    }\n    return res;\n}\n\nvec3 transmittance_to_atm_top(float mu, float r) {\n    return exp(-(\n        ray_e *\n        optical_length_to_atm_top(rayleigh_density, mu, r) +\n        mie_e *\n        optical_length_to_atm_top(mie_density, mu, r) +\n        ozo_e *\n        optical_length_to_atm_top(absorption_density, mu, r)\n    ));\n}\n\nvec2 mu_r_to_uv(float mu, float r, vec2 tex_size) {\n    float H     = sqrt(A_R * A_R - A_r * A_r);\n    float rho   = sqrt(r * r - A_r * A_r);\n    float d     = d_to_atm_top(mu, r);\n    float d_min = A_R - r;\n    float d_max = rho + H;\n    float x_mu  = (d - d_min) / (d_max - d_min);\n    float x_r   = rho / H;\n        \n    return vec2(\n        unit_range_to_tex_coord(x_mu, tex_size.x),\n        unit_range_to_tex_coord(x_r, tex_size.y)\n    );\n}\n\nvoid uv_to_mu_r(vec2 uv, out float mu, out float r, vec2 tex_size) {\n    float x_mu  = tex_coord_to_unit_range(uv.x, tex_size.x);\n    float x_r   = tex_coord_to_unit_range(uv.y, tex_size.y);\n    float H     = sqrt(A_R * A_R - A_r * A_r);\n    float rho = H * x_r;\n    r = sqrt(rho * rho + A_r * A_r);\n    float d_min = A_R - r;\n    float d_max = rho + H;\n    float d = d_min + x_mu * (d_max - d_min);\n    mu = d == 0.0 ? 1. : (H * H - rho * rho - d * d) / (2. * r * d);\n    mu = clamp(mu, -1., 1.);\n}\n\n\n// Calculate mu,r from view ray\nbool get_intersection_info(\n    vec3 X,\n    vec3 V,\n    out float mu,\n    out float r,\n    out bool intersects_ground,\n    out float d) {\n    \n    float t_closest = dot(V, planet_pos - X);\n    vec3  x_closest = X + V * t_closest;\n    float d_closest = length(planet_pos - x_closest);\n            \n    if (d_closest > A_R) return false;\n    \n    vec3  Z = X - planet_pos;\n    float R = length(Z);\n    \n    bool inside_atmosphere = A_r < R && R < A_R;\n    \n    if (inside_atmosphere) {\n        mu = dot(Z, V) / R;\n        r = R;\n    \n        float a2 = A_r * A_r - d_closest * d_closest;\n        \n        if (a2 > 0.) {\n            intersects_ground = false;\n            d = d_to_atm_top(mu, r);\n        } else {\n            float a = sqrt(a2);\n            float ta_1 = t_closest - a;\n            float ta_2 = t_closest + a;\n        \n            intersects_ground = ta_1 > 0. || ta_2 > 0.;\n            d = intersects_ground ? d_to_atm_bot(mu, r) : d_to_atm_top(mu, r);\n        }\n    } else if (d_closest < A_r) {\n        float A = sqrt(A_R * A_R - d_closest * d_closest);\n        float a = sqrt(A_r * A_r - d_closest * d_closest);\n        vec3 isec = X + V * (t_closest - a);\n        mu = dot(isec - planet_pos, -V) / A_r;\n        r = A_r;\n        intersects_ground = false;\n        d = A - a;\n    } else {\n        float a = sqrt(A_R * A_R - d_closest * d_closest);\n        vec3 isec = X + V * (t_closest - a);\n        mu = dot(isec - planet_pos, V) / A_R;\n        r = A_R;\n        intersects_ground = false;\n        d = 2. * a;\n    }\n    \n    return true;\n}\n\n","name":"Common","description":"","type":"common"}]}