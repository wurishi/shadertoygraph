{"ver":"0.1","info":{"id":"MlSGRG","date":"1429824904","viewed":1450,"name":"Phosphenes","username":"toothmang","description":"What I see sometimes when I close my eyes, including the looping behavior. \n\nnoise functions thanks to greg from here: https://www.shadertoy.com/view/MdsGDN","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","phosphene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\n#define PERIOD 6.0\n#define CIRCLE_MIN_RADIUS 0.0\n#define CIRCLE_MAX_RADIUS 1.0\n\n#define BG_BASE vec3(0.1, 0.1, 0.1)\n\n#define START_COLOR vec3(0.4, 0.0, 1.0)\n#define END_COLOR vec3(0.5, 0.5, 0.1)\n\nfloat noise(vec2 pos)\n{\n\treturn fract( sin( dot(pos*0.001 ,vec2(24.12357, 36.789) ) ) * 12345.123);\t\n}\n\nfloat smooth_noise(vec2 pos)\n{\n\treturn   ( noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) ) / 16.0 \t\t\n\t\t   + ( noise(pos + vec2(1,0)) + noise(pos + vec2(-1,0)) + noise(pos + vec2(0,1)) + noise(pos + vec2(0,-1)) ) / 8.0 \t\t\n    \t   + noise(pos) / 4.0;\n}\n\nfloat interpolate_noise(vec2 pos)\n{\n\tfloat\ta, b, c, d;\n\t\n\ta = smooth_noise(floor(pos));\t\n\tb = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y)));\n\tc = smooth_noise(vec2(floor(pos.x), floor(pos.y+1.0)));\n\td = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y+1.0)));\n\t\t\n\ta = mix(a, b, fract(pos.x));\n\tb = mix(c, d, fract(pos.x));\n\ta = mix(a, b, fract(pos.y));\n\t\n\treturn a;\t\t\t\t   \t\n}\n\n\n\nfloat perlin_noise(vec2 pos)\n{\n\tfloat\tn;\n\t\n\tn = interpolate_noise(pos*0.0625)*0.5;\n\tn += interpolate_noise(pos*0.125)*0.25;\n\tn += interpolate_noise(pos*0.025)*0.225;\n\tn += interpolate_noise(pos*0.05)*0.0625;\n\tn += interpolate_noise(pos)*0.03125;\n\treturn n;\n}\n\nvec2 rotate(vec2 coord, vec2 center, float angle)\n{\n    // Step 1: rotate relative to center\n    vec2 result = coord - center;\n    \n    // Step 2: create rotation matrix of form [ cos, -sin; sin, cos]\n    float cosa = cos(angle);\n    float sina = sin(angle);\n    \n    mat2 rot = mat2(\n        cosa, -sina, \n        sina, cosa);\n    \n    return (rot * result) + center;\n}\n\n\nvec4 circle(vec2 uv)\n{\n    float tm = mod(iTime, PERIOD);\n    float t = tm / PERIOD;\n    t = 1.0 - t;\n    \n    vec2 center = vec2(0.);\n\n    float radius = mix(CIRCLE_MIN_RADIUS, CIRCLE_MAX_RADIUS, t);\n    \n    radius += 0.4 * smooth_noise(tm * uv);\n    \n    float rotateDir = noise(uv) > 0.5 ? 1.0 : -1.0;\n    \n    uv = rotate(uv, vec2(0.0), t * 6.28 * rotateDir);\n    \n    float dist = length(uv - center);\n    \n    dist += 0.1 * perlin_noise(uv * iResolution.xy);\n    \n    if (dist < radius)\n    {\n        vec3 color = mix(END_COLOR, START_COLOR, t);\n        \n        float dist_t = 1.0 - (dist / radius);\n        \n        return vec4(color + color * dist_t, 1.0);\n    }\n    else\n    {\n        vec3 color = BG_BASE;\n        \n        vec2 redCoord = rotate(uv, vec2(0.0), t * 6.28) + 0.1 * smooth_noise(uv * uv);\n        \n        float redVal = smooth_noise(redCoord);\n        float greenVal = smooth_noise(uv * uv * t);\n        float blueVal = smooth_noise(uv * t);\n\n        color = vec3(redVal, greenVal, blueVal);\n        \n        return vec4(color * 0.4, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize the fragCoord so that it's between [-1, -1] and [1, 1]\n    vec2 uv = fragCoord.xy - (iResolution.xy * 0.5);\n    uv = uv / (iResolution.xy * 0.5);\n    \n    // Aspect ratio correction\n    uv.x = uv.x * (iResolution.x / iResolution.y);\n    \n    // Slight adjustment to make it more ellipsoidal\n    uv.x *= 0.8;\n    \n    fragColor = circle(uv);\n}","name":"","description":"","type":"image"}]}