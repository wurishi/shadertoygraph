{"ver":"0.1","info":{"id":"WsVBRd","date":"1607737980","viewed":146,"name":"Multiple Helices","username":"Kamoshika","description":"https://twitter.com/kamoshika_vrc/status/1332346142638571520","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","helix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = acos(-1.0);\nfloat t;\n\nfloat rand2(in vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 hsv2rgb(in float h, in float s, in float v) {\n\treturn ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 twist(in vec3 p, in float a) {\n    return vec3(p.xy*rotate(a*p.z), p.z);\n}\n\nfloat interval;\nconst float angle1 = pi*.004;\nconst float size1 = 8.;\nconst float angle2 = pi*.05;\nconst float size2 = 2.;\nconst float angle3 = pi*.2;\nconst float size3 = .5;\nconst float radius = .2;\nfloat dist(in vec3 p) {\n    p.xy = mod(p.xy, interval) - .5*interval;\n    p.xy *= rotate(t);\n    p = twist(p, angle1);\n    p.xy = abs(p.xy) - size1;\n    p = twist(p, angle2);\n    p.xy = abs(p.xy) - size2;\n    p = twist(p, angle3);\n    p.xy = abs(p.xy) - size3;\n    return length(p.xy) - radius;\n}\n\nvec3 getNormal(in vec3 p) {\n    float e = 1e-4;\n    return normalize(vec3(dist(p+vec3(e,0,0))-dist(p+vec3(-e,0,0)),\n    dist(p+vec3(0,e,0))-dist(p+vec3(0,-e,0)),\n    dist(p+vec3(0,0,e))-dist(p+vec3(0,0,-e))));\n}\n\nfloat exp2Fog(in float dist, in float density) {\n    float s = dist * density;\n    return exp(-s*s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.y, iResolution.y);\n    vec3 color = vec3(1);\n    t = iTime * 1.;\n    \n    vec3 cPos = vec3(0, 0, 5.);\n    vec3 cDir = normalize(vec3(0, 0, -1));\n    \n    vec3 cUp = normalize(vec3(0, 1, 0));\n    cUp.xy *= rotate(t*.1);\n    \n    vec3 cSide = cross(cDir, cUp);\n    \n    float targetDepth = 2.5;\n    vec3 ray = normalize(vec3(p.x*cSide + p.y*cUp + cDir*targetDepth));\n    vec3 lightDir = normalize(vec3(-1, 1, 2));\n    lightDir.xy *= rotate(t*.1);\n    \n    interval = 32.+pow(sin(t*.5*pi)*.5+.5, 16.)*100.;\n    \n    float d;\n    vec3 rPos = cPos;\n    for(int i=0; i<200; i++) {\n        d = dist(rPos);\n        if(abs(d) < 0.007) {\n            break;\n        }\n        rPos += ray*d;\n    }\n    \n    if(d < 0.007) {\n        vec3 normal = getNormal(rPos);\n            \n        vec3 temp = rPos;\n        float T = floor(t*2.);\n\n        temp.xy = mod(rPos.xy, interval) - .5*interval;\n        vec2 id = floor(rPos.xy/interval);\n        float r1 = rand2(id*1.121+T);\n\n        temp.xy *= rotate(t);\n        temp = twist(temp, angle1);\n        id = sign(temp.xy);\n        float r2 = rand2(id*1.135+r1+T);\n        temp.xy = abs(temp.xy) - size1;\n\n        temp = twist(temp, angle2);\n        id = sign(temp.xy);\n        float r3 = rand2(id*1.212+r2+T);\n        temp.xy = abs(temp.xy) - size2;\n\n        temp = twist(temp, angle3);\n        id = sign(temp.xy);\n        //float r4 = rand2(id*1.174+r3+T);\n        float r4 = atan(id.y, id.x)/pi/2.+.5;\n\n        vec3 base = hsv2rgb(r1 + r2*.5 + r3*.25, r4, 1.);\n        float s = dot(normal, lightDir);\n        float diff = max(s, 0.2);\n        float spec = pow(max(s, 0.), 40.);\n\n        color = base*diff + spec;\n    }\n\n    float fog = exp2Fog(length(rPos-cPos), 0.001);\n    color = mix(vec3(1), color, fog);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}