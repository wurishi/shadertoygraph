{"ver":"0.1","info":{"id":"NsdcWj","date":"1654073919","viewed":70,"name":"Learn-Integrate-BRDF","username":"nelsonkuang","description":"Integrate BRDF Learning","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["integratebrdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mainly derive from: https://www.shadertoy.com/view/3tsGW2\n// BRDF approximation sample count (higher is better quality and slower)\nconst int BRDF_SAMPLE_COUNT = 4;\n\n// reflection convolution sample count (higher is better quality and slower)\nconst int REFLECTION_SAMPLE_COUNT = 16;\n\n// irradiance convolution step (lower is better quality and slower)\nconst float SAMPLE_DELTA = 0.2;\n\nconst int MAX_MARCHING_STEPS = 16;\n\nconst float PI = 3.14159265358979323846;\n\nconst float TWO_PI = PI * 2.0;\n\nconst float HALF_PI = PI / 2.0;\n\nconst float RADICAL_BASE = 2.0;\n\nconst int RADICAL_POINT_NUM = 8;\n\nvec3 albedo = vec3(.8, 0.4, 0.2);\n\nfloat roughness = 0.0;\nfloat metallic = 0.0;\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n// define our camera model with a lookat point.\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n  vec3 cd = normalize(lookAtPoint - cameraPos);\n  vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n  vec3 cu = normalize(cross(cd, cr));\n\n  return mat3(-cr, cu, -cd);\n}\n\n// ---- Geometry function ----\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n  float a = roughness;\n  float k = (a * a) / 2.0;\n\n  float nom = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return nom / denom;\n}\n\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = geometrySchlickGGX(NdotV, roughness);\n  float ggx1 = geometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n// ------------------------------\n\nfloat vanDerCorpus(int n, float base) {\n  float invBase = 1.0 / base;\n  float denom = 1.0;\n  float result = 0.0;\n\n  for(int i = 0; i < RADICAL_POINT_NUM; ++i) {\n    if(n > 0) {\n      denom = mod(float(n), base);\n      result += denom * invBase;\n      invBase = invBase / 2.0;\n      n = int(float(n) / 2.0);\n    }\n  }\n\n  return result;\n}\n\nvec2 hammersley(int i, int N) {\n  return vec2(float(i) / float(N), vanDerCorpus(i, RADICAL_BASE));\n}\n\nvec3 importanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\n  float a = roughness * roughness;\n\n  float phi = TWO_PI * Xi.x;\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n  vec3 H;\n  H.x = cos(phi) * sinTheta;\n  H.y = sin(phi) * sinTheta;\n  H.z = cosTheta;\n\n  vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n  return normalize(sampleVec);\n}\n\n// --- Fresnel equation ----\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// --------------------------\n\nvec3 filteredReflection(vec3 D, vec3 N) {\n\n  float totalWeight = 0.0;\n  vec3 prefilteredColor = vec3(0.0);\n\n  for(int i = 0; i < REFLECTION_SAMPLE_COUNT; ++i) {\n    vec2 Xi = hammersley(i, REFLECTION_SAMPLE_COUNT);\n    vec3 H = importanceSampleGGX(Xi, N, roughness);\n    vec3 L = normalize(2.0 * dot(D, H) * H - D);\n\n    float NdotL = max(dot(N, D), 0.0);\n    if(NdotL > 0.0) {\n      prefilteredColor += texture(iChannel0, L).xyz * 2.0 * NdotL;\n      totalWeight += NdotL;\n    }\n  }\n  prefilteredColor = prefilteredColor / totalWeight;\n  return prefilteredColor;\n}\n\nvec2 integrateBRDF(float NdotV, float roughness) {\n  vec3 V;\n  V.x = sqrt(1.0 - NdotV * NdotV);\n  V.y = 0.0;\n  V.z = NdotV;\n\n  float A = 0.0;\n  float B = 0.0;\n\n  vec3 N = vec3(0.0, 0.0, 1.0);\n\n  for(int i = 0; i < BRDF_SAMPLE_COUNT; ++i) {\n    vec2 Xi = hammersley(i, BRDF_SAMPLE_COUNT);\n    vec3 H = importanceSampleGGX(Xi, N, roughness);\n    vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(L.z, 0.0);\n    float NdotH = max(H.z, 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    if(NdotL > 0.0) {\n      float G = geometrySmith(N, V, L, roughness);\n      float G_Vis = (G * VdotH) / (NdotH * NdotV);\n      float Fc = pow(1.0 - VdotH, 5.0);\n\n      A += (1.0 - Fc) * G_Vis;\n      B += Fc * G_Vis;\n    }\n  }\n  A /= float(BRDF_SAMPLE_COUNT);\n  B /= float(BRDF_SAMPLE_COUNT);\n  return vec2(A, B);\n}\n\nvec3 light(vec3 N) {\n  vec3 irradiance = vec3(0.0);\n\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 right = cross(up, N);\n  up = cross(N, right);\n\n  float nrSamples = 0.0;\n  for(float phi = 0.0; phi < TWO_PI; phi += SAMPLE_DELTA) {\n    for(float theta = 0.0; theta < HALF_PI; theta += SAMPLE_DELTA) {\n      vec3 tangentSample = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n      vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\n\n      irradiance += texture(iChannel0, sampleVec).xyz * 2.0 * cos(theta) * sin(theta);\n      nrSamples++;\n    }\n  }\n  irradiance = PI * irradiance * (1.0 / nrSamples);\n  return irradiance;\n\n}\n\nvec3 surface(vec3 D, vec3 N) {\n  // vec3 albedo = vec3(1.0, 0.5, 0.0);\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, albedo, metallic);\n\n  vec3 F = fresnelSchlickRoughness(max(dot(N, D), 0.0), F0, roughness);\n  vec3 prefilteredColor = filteredReflection(D, N);\n\n  vec3 R = reflect(D, N);\n\n  vec2 brdf = integrateBRDF(dot(D, N), roughness);\n\n  vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\n\n  vec3 diffuse = light(N) * albedo;\n  return (kD * diffuse + specular);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset) {\n  return length(p - offset) - r;\n}\n\nfloat scene(vec3 position) {\n  return sdSphere(position, 1.3, vec3(0., 0., 0.));\n}\n\nvec3 getNormal(vec3 rayHitPosition, float smoothness) {\n  vec3 n;\n  vec2 dn = vec2(smoothness, 0.0);\n  n.x = scene(rayHitPosition + dn.xyy) - scene(rayHitPosition - dn.xyy);\n  n.y = scene(rayHitPosition + dn.yxy) - scene(rayHitPosition - dn.yxy);\n  n.z = scene(rayHitPosition + dn.yyx) - scene(rayHitPosition - dn.yyx);\n  return normalize(n);\n}\n\nfloat raymarch(vec3 position, vec3 direction) {\n  float totalDistance = 0.0;\n  for(int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n    float result = scene(position + direction * totalDistance);\n    if(result < 0.005) {\n      return totalDistance;\n    }\n    totalDistance += result;\n  }\n\n  return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.y;\n\n  roughness = 0.15; // iMouse.x / iResolution.x;\n  metallic = 0.5; // iMouse.y / iResolution.y;\n\n  uv -= vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n\n  vec3 origin = vec3(0.0, 0.0, 2.);\n  vec3 lp = vec3(0); // lookat point\n  // rotate around the camera, but we have to be conscious of how far away the camera is from the 3D object\n  // we can use the rotate2d function to move the camera around and use cameraRadius to control how far away the camera is.\n  float cameraRadius = 2.;\n  origin.yz = origin.yz * cameraRadius * 1.0;\n  origin.xz = origin.xz * rotate2d(iTime * 0.1) + vec2(lp.x, lp.z);\n\n  vec3 direction = camera(origin, lp) * normalize(vec3(uv, -1.0));\n  float dist = raymarch(origin, direction);\n\n  vec4 col = vec4(texture(iChannel0, direction).rgb, 1.0);\n\n  if(dist < 0.0) {\n    fragColor = col;\n  } else {\n    vec3 fragPosition = origin + direction * dist;\n    vec3 N = getNormal(fragPosition, 0.01);\n    fragColor = mix(col, vec4(surface(-direction, N), 1), smoothstep(.0, .15, dot(-direction, N) - .1));\n  }\n}","name":"Image","description":"","type":"image"}]}