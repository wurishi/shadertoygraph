{"ver":"0.1","info":{"id":"ttdyRn","date":"1616696631","viewed":107,"name":"[ RENDU ] PathTracing","username":"sassarotit","description":".","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\nFonctionalités du shadertoy\n\n- Sphere, Cube, Plane, Camera, Material\n- Plusieurs lumières\n- Réflections\n- Réfractions\n\n--------------------------------------\n\nUtiliser le shadertoy\n\n--------------------------------------\n\nINTERACTION\n\n\n- Un clic gauche sur l'écran changera le \"temps de la journée\"\n  (clic vers le haut = nuit, clic vers le bas = jour)\n  \nDEFINES\n\n- MAX_BOUNCES \n    Le nombre de rebonds maximaux d'un rayon\n    \n- SAMPLES\n    Le nombre d'échantillons pour calculer un pixel\n    \n- CAMERA_ROTATION_SPEED\n    La vitesse de rotation de la camera dans la scene\n    Une vitesse élevée facilite la perception du motion blur\n    \n--------------------------------------\n\nAJOUTER UN OBJET DANS LA SCENE\n\n\nDans la section SCENE :\n- Créer un identitfiant pour votre objet\n- Créer un objet (Sphere, Cube, Plane)\n- Créer un matériau\n\nDans la section INTERSECT dans la fonction intersect_scene\n- ajouter une ligne à la fin de la fonction sous la forme suivante :\n\n    intersect_min(intersect, id, intersect_** type d'objet **(ro, rd, ** objet **), ** id de l'objet **);\n  \n  exemples :\n    \n    intersect_min(intersect, id, intersect_sphere(ro, rd, maSphere), idMaSphere);\n    intersect_min(intersect, id, intersect_plane(ro, rd, monPlan), idMonPlan);\n    intersect_min(intersect, id, intersect_cube(ro, rd, monCube), idMonCube);\n    \nDans la section MATERIAL dans la fonction scene_material\n- ajouter un 'case' avec l'identifiant de votre objet et \n  assignez à la variable mat le materiau de votre objet\n- si vous voulez faire un materiau plus complexe ici en modifiant ses propriétés en fonction de \n  certains paramètres, vous le pouvez\n  \nCompilez, et espérez que mes explications soient bonnes (j'explique mal en général désolé)\n\n--------------------------------------\n\nAJOUTER UNE LUMIERE DANS LA SCENE\n\n\nLes lumières ne sont autres que des objets. Il suffit d'avoir un matériau avec une couleur d'émission.\n\n--------------------------------------\n\nMETTRE A JOUR LA SCENE\n\n\nDans la section UPDATE dans la fonction update:\n- mettez à jour votre scene\n\n\n\n**/\n\n#define DELTA_N 0.0001\n#define MAX_BOUNCES 5\n#define SAMPLES 10\n\n#define ID_NULL -1\n#define NO_INTERSECTION Intersect(vec3(0), vec3(0), vec3(0), -1.)\n\n/*                      \n\nYour scene here\n\n*/\n\n#define CAMERA_ROTATION_SPEED 0.5f\n// Cam (position, look at position, up, fov (in radians))\nCam maincam = Cam(vec3(0,0,0), vec3(0,.7,0), vec3(0,1,0), radians(80.));\n\n// Ids\nconst int id_ground  = 0;\nconst int id_sphere  = 1;\nconst int id_sphere2 = 4;\nconst int id_cube    = 3;\n\nconst int id_light  = 2;\nconst int id_light2 = 5;\nconst int id_light3 = 6;\nconst int id_light4 = 7;\n\n// Plane (position, normal, forward)\nconst Plane ground   = Plane(vec3(0), vec3(0,1,0), vec3(0,0,1));\n\n// Sphere (position, radius)\nconst Sphere sphere  = Sphere(vec3(0, 1.25,0), 1.5);\nconst Sphere sphere2 = Sphere(vec3(-4,1.25,0), 1.0);\nSphere light         = Sphere(vec3(0,3,0)    , 0.7);\nSphere light2        = Sphere(vec3(0,3,0)    , 0.4);\nSphere light4        = Sphere(vec3(0,3,0)    , 1.5);\n\n// Cube (position, radius)\nconst Cube cube      = Cube(vec3(4,1,0), 1.);\nCube light3          = Cube(vec3(0,3,0), 0.25);\n\n// Material (albedo, emission, roughness, reflectiveness, refractiveness, ior)\nconst Material mat_ground  = Material(vec3(1)      , vec3(0)    , 0., 0., 0., .0);\nconst Material mat_sphere  = Material(vec3(1,.3,.3), vec3(0)    , 1., .2, 0., .0);\nconst Material mat_sphere2 = Material(vec3(.7,.7,1), vec3(0)    , 0., 0., 1., 1.49);\nconst Material mat_cube    = Material(vec3(.4,1,.4), vec3(0)    , 0., 0., 0., .0);\nconst Material mat_light   = Material(vec3(0)      , vec3(2)    , 0., 0., 0., .0);\nconst Material mat_light2  = Material(vec3(0)      , vec3(0,2,0), 0., 0., 0., .0);\nconst Material mat_light3  = Material(vec3(0)      , vec3(0,0,2), 0., 0., 0., .0);\nconst Material mat_light4  = Material(vec3(0)      , vec3(2,0,0), 0., 0., 0., .0);\n\n// Colors for ground checker\nconst vec3 c1_ground = vec3(1);\nconst vec3 c2_ground = vec3(.8);\n\n/*               _       _       \n _   _ _ __   __| | __ _| |_ ___ \n| | | | '_ \\ / _` |/ _` | __/ _ \\\n| |_| | |_) | (_| | (_| | ||  __/\n \\__,_| .__/ \\__,_|\\__,_|\\__\\___|\n      |_|                        \n\n*/\n\nvoid update(float time) {\n    float rc = CAMERA_ROTATION_SPEED * time;\n    maincam.p.xz = 10.0f * vec2(cos(rc), sin(rc));\n    maincam.p.y  = 4.0f + sin(cos(time * 2.0f));\n    \n    light.p.xz = 4.0f * vec2(cos(time + 1.62f), sin(time + 1.62f));\n    light2.p.xz = 4.0f * vec2(cos(time + 3.14f), sin(time  + 3.14f));\n    light3.p.xz = 4.0f * vec2(cos(time + 4.76f), sin(time + 4.76f));\n    light4.p.xz = 4.0f * vec2(cos(time), sin(time)); \n    light4.r = 1.0f + 0.5 * cos(0.5 * time);\n}\n\n/*\n _       _                          _   \n(_)_ __ | |_ ___ _ __ ___  ___  ___| |_ \n| | '_ \\| __/ _ \\ '__/ __|/ _ \\/ __| __|\n| | | | | ||  __/ |  \\__ \\  __/ (__| |_ \n|_|_| |_|\\__\\___|_|  |___/\\___|\\___|\\__|\n                                        \n*/\n\n// Intersection entre un rayon et une sphere\nIntersect intersect_sphere( vec3 ro, vec3 rd, Sphere s ) {\n    // Recuperation equation\n    vec3 SR = ro - s.p;\n    float a = dot(rd, rd);\n    float b = 2. * dot(rd, SR);\n    float c = dot(SR, SR) - s.r * s.r;\n    float det = b * b - 4. * a * c;\n\n    // Resolution equation\n    // Pas de solutions\n    if (det < 0.) \n        return NO_INTERSECTION;\n\n    // Solutions\n    float sqrtDet = sqrt(det);\n    float d1 = (-b - sqrtDet) / (2. * a);\n    float d2 = (-b + sqrtDet) / (2. * a);\n    float d  = (d1 > 0.) ? d1 : d2;\n    \n    // Retour de l'intersection\n    vec3 p  = ro + rd * d;\n    vec3 tn = normalize(p - s.p);\n    vec3 n  = -sign(dot(tn, rd)) * tn;\n    return Intersect(p, n, tn, d);\n}\n\n// Intersection entre un rayon et un plan\nIntersect intersect_plane( vec3 ro, vec3 rd, Plane pl ) {\n    // Solutions\n    float d = dot(pl.p - ro, pl.n) / dot(rd, pl.n);\n    \n    // Retour de l'intersection\n    vec3 p  = ro + rd * d;\n    vec3 tn = pl.n;\n    vec3 n  = -sign(dot(tn, rd)) * tn;\n    return Intersect(p, n, tn, d);\n}\n\n// Intersection entre un rayon et un cube\nIntersect intersect_cube( vec3 ro, vec3 rd, Cube c ) {\n\n    // Calcul de la solution\n    float tmin = (c.p.x - c.s - ro.x) / rd.x; \n    float tmax = (c.p.x + c.s - ro.x) / rd.x; \n    if (tmin > tmax) {\n        float tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n \n    float tymin = (c.p.y - c.s - ro.y) / rd.y; \n    float tymax = (c.p.y + c.s - ro.y) / rd.y;\n    if (tymin > tymax) {\n        float tmp = tymin;\n        tymin = tymax;\n        tymax = tmp;\n    }\n \n    if ((tmin > tymax) || (tymin > tmax)) \n        return NO_INTERSECTION;\n    if (tymin > tmin) \n        tmin = tymin; \n    if (tymax < tmax) \n        tmax = tymax; \n \n    float tzmin = (c.p.z - c.s - ro.z) / rd.z; \n    float tzmax = (c.p.z + c.s - ro.z) / rd.z;\n    if (tzmin > tzmax) {\n        float tmp = tzmin;\n        tzmin = tzmax;\n        tzmax = tmp;\n    } \n \n    if ((tmin > tzmax) || (tzmin > tmax)) \n        return NO_INTERSECTION;\n    if (tzmin > tmin) \n        tmin = tzmin; \n    if (tzmax < tmax) \n        tmax = tzmax;\n \n    // Retour de l'intersection\n    float d = (tmin > 0.) ? tmin : tmax;\n    vec3 p = ro + rd * d;\n    vec3 tn;\n    if (d == tymin || d == tymax) tn = vec3(0,1,0);\n    else if (d == tzmin || d == tzmax) tn = vec3(0,0,1);\n    else tn = -vec3(1,0,0);\n    vec3 n = -sign(dot(tn, rd)) * tn;\n    return Intersect(p, n, tn, d);\n}\n\n// Trouve l'intersection valide la plus proche et retourne l'intersection et l'id\nvoid intersect_min( inout Intersect a, inout int aId, Intersect b, int bId ) {\n    if (b.d > 0. && (a.d < 0. || b.d < a.d)) {\n        a = b;\n        aId = bId;\n    }\n}\n\n// Calcule l'intersection avec la scene\nvoid scene_intersect( vec3 ro, vec3 rd, out Intersect intersect, out int id ) {\n    id = ID_NULL;\n    intersect = NO_INTERSECTION;\n\n    intersect_min(intersect, id, intersect_plane(ro, rd, ground), id_ground);\n    intersect_min(intersect, id, intersect_sphere(ro, rd, sphere), id_sphere);\n    intersect_min(intersect, id, intersect_sphere(ro, rd, light), id_light);\n    intersect_min(intersect, id, intersect_cube(ro, rd, cube), id_cube);\n    intersect_min(intersect, id, intersect_sphere(ro, rd, sphere2), id_sphere2);\n    intersect_min(intersect, id, intersect_sphere(ro, rd, light2), id_light2);\n    intersect_min(intersect, id, intersect_cube(ro, rd, light3), id_light3);\n    intersect_min(intersect, id, intersect_sphere(ro, rd, light4), id_light4);\n}\n\n/*               _            _       _ \n _ __ ___   __ _| |_ ___ _ __(_) __ _| |\n| '_ ` _ \\ / _` | __/ _ \\ '__| |/ _` | |\n| | | | | | (_| | ||  __/ |  | | (_| | |\n|_| |_| |_|\\__,_|\\__\\___|_|  |_|\\__,_|_|\n                                        \n*/\n\n// Calcule le material en fonction du rayon, de son intersection avec la scene et son id\nMaterial scene_material( vec3 ro, vec3 rd, Intersect intersect, int id ) {\n    Material mat = Material(vec3(0), vec3(0), 0., 0., 0., 0.);    \n    switch (id) {\n    \n        case id_ground:\n            vec2 uv = vec2(dot(intersect.p, ground.ww), dot(intersect.p, cross(ground.ww, ground.n)));\n            mat   = mat_ground;\n            mat.a = checker(c1_ground, c2_ground, uv);\n            break;\n            \n        case id_sphere: \n            mat = mat_sphere;\n            break;\n            \n        case id_light: \n            mat = mat_light;\n            break;\n            \n        case id_cube:\n            mat = mat_cube;\n            break;\n            \n        case id_sphere2:\n            mat = mat_sphere2;\n            break;\n            \n        case id_light2:\n            mat = mat_light2;\n            break;\n            \n        case id_light3:\n            mat = mat_light3;\n            break;\n            \n        case id_light4:\n            mat = mat_light4;\n            break;\n            \n        default:\n            mat.e = pow(texture(iChannel0, rd).rgb, vec3(2.22));\n            mat.e *= mix(vec3(1), vec3(.02,.01,.1), iMouse.y / iResolution.y);\n            break;\n    }\n    \n    return mat;\n}\n\n/*                  _           \n _ __ ___ _ __   __| | ___ _ __ \n| '__/ _ \\ '_ \\ / _` |/ _ \\ '__|\n| | |  __/ | | | (_| |  __/ |   \n|_|  \\___|_| |_|\\__,_|\\___|_|   \n                                \n*/\n\n// Calcule la couleur trouvee par l'envoi d'un seul rayon\nvec3 sample_ray( vec3 ro, vec3 rd, vec2 seed ) {\n    vec3 albedo = vec3(1);\n    vec3 color  = vec3(0);\n    float airIOR = 1.0003;\n\n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        // Generation d'un nombre aleatoire\n        float rng = rng1(seed + float(i) + mod(iTime, 14.5f));\n        \n        // Recupère l'intersection ET le matériau associé à l'objet intersecté\n        Intersect intersect;\n        int id;\n        scene_intersect(ro, rd, intersect, id);\n        Material mat = scene_material(ro, rd, intersect, id);\n\n        // Met a jour la couleur\n        color  += mat.e * albedo;\n        albedo *= mat.a;\n        \n        // Sort de la boucle si on n'intersecte rien\n        if (id == ID_NULL) break;\n\n        // Calcule si le rayon va être diffusé, réfléchi ou réfracté\n        bool isReflected = rng < mat.refl;\n        bool isRefracted = fract(rng * 153.252) < mat.refr;\n                \n        // Calcule le prochain rayon\n        if (isReflected) {\n            // Rayon réfléchi\n            ro = intersect.p + DELTA_N * intersect.n;\n            rd = rng_cone(seed + rng, reflect(rd, intersect.n), mat.rough);\n        } else if (isRefracted) {\n            // Rayon réfracté\n            ro = intersect.p - DELTA_N * intersect.n;\n            float ior = (intersect.n != intersect.tn) ? mat.ior / airIOR : airIOR / mat.ior;\n            rd = rng_cone(seed + rng, refract(rd, intersect.n, ior), mat.rough);\n        } else {\n            // Rayon diffus\n            ro = intersect.p + DELTA_N * intersect.n;\n            // redirection avec une diffusion arbitraire (j'aurais pu en faire un paramètre)\n            rd = rng_cone(seed + rng, intersect.n, 2.);\n        }\n    }\n    return color;\n}\n\n// Calcule la couleur trouvee par l'envoi de plusieurs rayon\nvec3 render_ray( vec3 ro, vec3 rd, vec2 uv ) {\n    vec3 col = vec3(0);\n    for (int i = 0; i < SAMPLES; i++)\n        col += sample_ray(ro, rd, uv + mod(iTime, 22.15) + float(i));\n    col /= float(SAMPLES);\n    return col;\n}\n\n// Correction gamma\nvec3 gamma_correct( vec3 col ) {\n    return pow(clamp(col,0.0,1.0), vec3(0.45));\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    update(iTime);\n    \n    // Convertion en coordonnées centrées\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.x;\n    \n    // Trouve le rayon à envoyer à partir de la camera\n    vec3 ro, rd;\n    ray_from_camera(maincam, uv, ro, rd);\n\n    // Calcule la couleur\n    vec3 col = render_ray(ro, rd, uv);\n    col = gamma_correct(col);\n    \n    // Output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n     _                   _       \n ___| |_ _ __ _   _  ___| |_ ___ \n/ __| __| '__| | | |/ __| __/ __|\n\\__ \\ |_| |  | |_| | (__| |_\\__ \\\n|___/\\__|_|   \\__,_|\\___|\\__|___/\n\n*/\n\nstruct Cam       { vec3 p, ta, up; float fov; };\nstruct Ray       { vec3 o, d; };\nstruct Material  { vec3 a, e; float refl, rough, refr, ior; };\nstruct Intersect { vec3 p, n, tn; float d; };\n\nstruct Sphere    { vec3 p; float r; };\nstruct Plane     { vec3 p, n, ww; };\nstruct Cube      { vec3 p; float s; };\n\n\n/*\n  __                  _   _                 \n / _| ___  _ __   ___| |_(_) ___  _ __  ___ \n| |_ / _ \\| '_ \\ / __| __| |/ _ \\| '_ \\/ __|\n|  _| (_) | | | | (__| |_| | (_) | | | \\__ \\\n|_|  \\___/|_| |_|\\___|\\__|_|\\___/|_| |_|___/\n                                                                                        \n*/\n\nvec3 checker( vec3 a, vec3 b, vec2 uv ) {\n    return mod(floor(uv.x) + floor(uv.y), 2.) < .5 ? a : b;\n}\n\n/*\n                  \n _ __ _ __   __ _ \n| '__| '_ \\ / _` |\n| |  | | | | (_| |\n|_|  |_| |_|\\__, |\n            |___/ \n            \n*/\n\nfloat rng1( vec2 seed ) { \n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); \n}\n\nvec2 rng2( vec2 seed ) { \n    float rng = rng1(seed);\n    return vec2(rng, fract(rng * 13.55));\n}\n\nvec3 rng3( vec2 seed ) { \n    float rng = rng1(seed);\n    float rng2 = rng1(seed + rng);\n    float rng3 = rng1(seed + rng + rng2);\n    return vec3(rng, rng2, rng3);\n}\n\nvec3 rng_cone( vec2 seed, vec3 normal, float disp ) {\n    return normalize(normal + disp * (rng3(seed) - .5));\n}\n\n/*\n                 \n _ __ __ _ _   _ \n| '__/ _` | | | |\n| | | (_| | |_| |\n|_|  \\__,_|\\__, |\n           |___/ \n\n*/\n\nvoid ray_from_camera( in Cam c, in vec2 uv, out vec3 ro, out vec3 rd ) {\n    // Near plane distance\n    float z = 1. / tan(c.fov / 2.);\n\n    // Vecteurs locaux\n    vec3 ww = normalize(c.ta - c.p);\n    vec3 uu = cross(ww, c.up);\n    vec3 vv = cross(uu, ww);\n    \n    // Calcul du rayon\n    ro = c.p + ww * z + uu * uv.x + vv * uv.y;\n    rd = normalize(ro - c.p);\n}","name":"Common","description":"","type":"common"}]}