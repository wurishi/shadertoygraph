{"ver":"0.1","info":{"id":"MXlXWj","date":"1710025832","viewed":144,"name":"Black hole (kinda)","username":"Nazlbit","description":"Black hole (kinda).","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Optical phenomena simulation\" by Nazlbit. https://shadertoy.com/view/43l3Dl\n// 2024-03-09 21:03:51\n\n// Use the mouse to emit light pulses. Hold the mouse button, pull and release.\n// Press Space to reverse the direction of the simulation.\n// Press Shift to clear the field.\n// Press Backspace to reset the simulation to the initial state.\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 tonemap(const vec3 c)\n{\n    return c / (c + 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coords = ivec2(fragCoord);\n    ivec2 extent = ivec2(iResolution.xy);\n    vec2 normalized_extent = iResolution.xy / iResolution.y;\n\n    vec4 field = read_buffer(iChannel0, coords);\n\n    if(iMouse.z > 0.)\n    {\n        field += mouse_pulse(coords, extent, iMouse);\n    }\n\n    float amp = length(field.xy);\n    float angle = atan(field.y, field.x);\n    float hue = (angle + radians(180.)) / radians(360.);\n    vec3 color = hsv2rgb(vec3(hue, 1., amp));\n\n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 field, in vec2 _coords )\n{\n    ivec2 coords = ivec2(_coords);\n    ivec2 extent = ivec2(iResolution.xy);\n\n    if(boundary(coords, extent))\n    {\n        field = vec4(0);\n        if(coords == ivec2(0, extent.y - 1))\n        {\n            field.y = iMouse.z;\n        }\n        return;\n    }\n\n    field = read_buffer(iChannel0, coords);\n\n    if(iFrame % 67200 == 0)\n    {\n        field += initial_state(coords, extent);\n        return;\n    }\n\n    simulation(field, coords, extent, iChannel0);\n\n    bool space_is_clicked = bool(texelFetch(iChannel1, ivec2(32, 1), 0).x);\n    bool shift_is_clicked = bool(texelFetch(iChannel1, ivec2(16, 1), 0).x);\n    bool backspace_is_clicked = bool(texelFetch(iChannel1, ivec2(8, 1), 0).x);\n    if(space_is_clicked)\n    {\n        // Reverse the direction of the simulation.\n        vec2 tmp = field.xy;\n        field.xy = field.zw;\n        field.zw = tmp;\n    }\n    else if (shift_is_clicked)\n    {\n        // Clear the field.\n        field = vec4(0);\n    }\n    else if (backspace_is_clicked)\n    {\n        // Reset the simulation.\n        field = initial_state(coords, extent);\n    }\n\n    bool prev_mouse_state = read_buffer(iChannel0, ivec2(0, extent.y - 1)).y > 0.;\n    if(iMouse.z < 0. && prev_mouse_state)\n    {\n        field += mouse_pulse(coords, extent, iMouse);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float c = 0.5;\nconst float damping_coeff = 0.99995;\nconst vec2 mouse_pulse_size = vec2(0.04);\nconst float mouse_pulse_wl = 8.;\nconst float size = 0.1;\nbool boundary(const ivec2 coords, const ivec2 extent)\n{\n    return any(lessThan(coords, ivec2(0))) ||     // bottom-left corner\n           any(greaterThan(coords, extent - ivec2(1, 2)));  // top-right corner\n}\n\n#define read_buffer(buffer, uv) texelFetch(buffer, uv, 0)\n\nvec2 sample_field(ivec2 coords, const ivec2 extent, const sampler2D channel)\n{\n    if(boundary(coords, extent))\n    {\n        // wall\n        return vec2(0);\n    }\n\n    return read_buffer(channel, coords).xy;\n}\n\nfloat density(const vec2 coords, const ivec2 extent)\n{\n    vec2 extent_f = vec2(extent);\n    vec2 normalized_coords = (vec2(coords) - extent_f * 0.5) / extent_f.y;\n    normalized_coords /= size;\n    float r = length(normalized_coords);\n    return 1. + 1. / (r * r);\n}\n\nvec4 pulse(const ivec2 coords, const ivec2 extent, const vec2 pos, const vec2 direction, const float wl, const float ampl, const vec2 pulse_size)\n{\n    vec4 result;\n    vec2 extent_f = vec2(extent);\n    vec2 normalized_coords = (vec2(coords) - extent_f * 0.5) / extent_f.y;\n\n    vec2 transformed_coords = normalized_coords - pos;\n    transformed_coords = vec2(dot(transformed_coords, vec2(direction.y, -direction.x)), dot(transformed_coords, direction));\n    float r = length(transformed_coords / pulse_size);\n    float phase = transformed_coords.y * extent_f.y * radians(360.) / wl;\n    result.xy = vec2(cos(phase), sin(phase)) * exp(-r*r);\n\n    transformed_coords += vec2(0, c / sqrt(density(vec2(coords), extent)) / extent_f.y);\n    r = length(transformed_coords / pulse_size);\n    phase = transformed_coords.y * extent_f.y * radians(360.) / wl;\n    result.zw = vec2(cos(phase), sin(phase)) * exp(-r*r);\n    return result * ampl;\n}\n\nvec4 initial_state(const ivec2 coords, const ivec2 extent)\n{\nreturn pulse(coords, extent, vec2(0.7, 0.1), vec2(-1, 0), 20., 1., vec2(0.11, 0.05)) +\n       pulse(coords, extent, vec2(-0.7, -0.1), vec2(1, 0), 20., 1., vec2(0.11, 0.05));\n}\n\nvec4 mouse_pulse(const ivec2 coords, const ivec2 extent, vec4 mouse)\n{\n    vec2 extent_f = vec2(extent);\n        \n    // Emit a pulse.\n    vec2 current_pos = (mouse.xy - extent_f * 0.5) / extent_f.y;\n    vec2 click_pos = (abs(mouse.zw) - extent_f * 0.5) / extent_f.y;\n\n    vec2 diff = current_pos - click_pos;\n    float ampl = length(diff);\n\n    if(ampl != 0.)\n    {\n        vec2 direction = diff / ampl;\n        return pulse(coords, extent, click_pos, direction, mouse_pulse_wl, ampl, mouse_pulse_size);\n    }\n    return vec4(0);\n}\n\n#define f(v, coords, offset, extent, channel) ((sample_field(coords + offset, extent, channel) - v) / density(vec2(coords) + vec2(offset) * 0.5, extent))\n\nvoid simulation(inout vec4 field, const ivec2 coords, const ivec2 extent, const sampler2D channel)\n{\n    if(boundary(coords, extent))\n    {\n        return;\n    }\n\n    vec2 a = f(field.xy, coords, +ivec2(1, 0), extent, channel) +\n             f(field.xy, coords, -ivec2(1, 0), extent, channel) +\n             f(field.xy, coords, +ivec2(0, 1), extent, channel) +\n             f(field.xy, coords, -ivec2(0, 1), extent, channel) +\n            (f(field.xy, coords, +ivec2(1, 1), extent, channel) +\n             f(field.xy, coords, -ivec2(1, 1), extent, channel) +\n             f(field.xy, coords, +ivec2(1,-1), extent, channel) +\n             f(field.xy, coords, -ivec2(1,-1), extent, channel)) * exp(-1.);\n    a /= 1. + sqrt(0.5);\n\n    vec2 prev = field.xy;\n    field.xy += (field.xy - field.zw)*damping_coeff + a * c * c;\n    field.zw = prev;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 field, in vec2 coords )\n{\n    field = read_buffer(iChannel0, ivec2(coords));\n    simulation(field, ivec2(coords), ivec2(iResolution.xy), iChannel0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 field, in vec2 coords )\n{\n    field = read_buffer(iChannel0, ivec2(coords));\n    simulation(field, ivec2(coords), ivec2(iResolution.xy), iChannel0);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 field, in vec2 coords )\n{\n    field = read_buffer(iChannel0, ivec2(coords));\n    simulation(field, ivec2(coords), ivec2(iResolution.xy), iChannel0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}