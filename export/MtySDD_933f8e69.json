{"ver":"0.1","info":{"id":"MtySDD","date":"1484343815","viewed":336,"name":"OJ - Fibber 28, scene 2","username":"rammoskar","description":"Full demo: https://www.youtube.com/watch?v=kw5uLHZiRpY\nCurrently a bit uglier then the original","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","morph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus62( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length6(q)-t.y;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b) //, float k )\n{\n\tfloat k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\n\n//uniform float tick;\n//uniform sampler2D noiseP;\n//uniform vec2 windowSize;\n\n#define MAT_BLOCK 1.0\n#define MAT_LIGHT 2.0\n#define MAT_SPHERE 3.0\n#define MAT_WATER 4.0\n#define MAT_S2_OBJECT 5.0\n#define MAT_DRILL 6.0\n#define MAT_S3_BLOCK 7.0\n#define MAT_BALL 8.0\n#define MAT_S2_BLOCK 9.0\n#define MAT_S4_FLOOR 10.0\n#define MAT_S4_MIRROR 11.0\n#define MAT_S1_TORUS 12.0\n#define MAT_S5_BLOB 13.0\n#define MAT_S5_FLOOR 14.0\n#define MAT_S5_PILLAR 15.0\n#define MAT_MORPH 16.0\n#define MAT_S6_ROOF 17.0\n#define MAT_S2_WATER 18.0\n#define MAT_S6_WATER 19.0\n#define MAT_TEXT 20.0\n#define MAT_TEXT2 21.0\n\n#define EPS 0.01\n\n#define SCENE_0 20\n#define SCENE_1 50\n#define SCENE_2 80\n#define SCENE_3 110\n#define SCENE_4 140\n#define SCENE_5 170\n#define SCENE_6 200\n#define SCENE_7 210\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\nvec2 unn(vec2 a, float dis, float mat)\n{\n\treturn a.x < dis ? a : vec2(dis, mat);\n}\n\n\n\nmat3 rot(float x, float y, float z)\n{\n\tfloat cx = cos(x);\n\tfloat sx = sin(x);\n\tfloat cy = cos(y);\n\tfloat sy = sin(y);\n\tfloat cz = cos(z);\n\tfloat sz = sin(z);\n\tmat3 xm = mat3(1, 0, 0,\n\t\t\t\t\t0, cx, -sx,\n\t\t\t\t\t0, sx, cx);\n\tmat3 ym = mat3(cy, 0, sy,\n\t\t\t  \t\t0, 1, 0,\n\t\t\t  \t\t-sy, 0, cy);\n\tmat3 zm = mat3(cz, -sz, 0,\n\t\t\t\t\tsz, cz, 0,\n\t\t\t\t\t0, 0, 1);\n\treturn xm * ym * zm; \n}\n\n\n\n\n\n\n\n\n\nvec2 water_2(vec3 p, vec3 rd)\n{\n\tfloat t = iTime - float(SCENE_1);\n\tif(rd.y > 0.0){\n\t\treturn vec2(999999, MAT_WATER);\n\t}\n\t\n\tfloat wdis = distance(p.xz, vec2(0, 6));\n\tfloat w = 0.0; \n\tfloat d = \n\t\t(sin(-t * 3.0 + 5.0 * wdis)) * w;// + \n\t\t//TODO texture length(texture(noiseP, p.xz*0.5 + vec2(0, tick*0.1)))*0.1 + \n\t\t//TODO texture length(texture(noiseP, p.xz*0.5 + vec2(tick*0.13, 0)))*0.1;\n\td *= 0.1 * smoothstep(0.0, 5.0, t);\n\n\tfloat h = p.y - d * 0.1;\n\t\n\tfloat dis = (0.1 -p.y)/rd.y;\n\n\treturn vec2(max(h, dis), MAT_S2_WATER);\n}\n\n\n\n\n\nbool inRefraction = false;\n\n\nvec2 scene(vec3 p, vec3 rd)\n{\n\tfloat t = mod(iTime,30.0);// - float(SCENE_1);\n\tvec3 s = vec3(1);\n\tvec3 q = mod(p, s) - 0.5 * s;\n\tivec3 n = ivec3(floor(p / s));\n\t\n\t\t\t\t\t\n\tfloat mt = 10.0;\n\tfloat siz = 1.5 + 0.5 * sin(t * 0.3);\n\tvec3 pm = p - vec3(0, 0.5 + sin(t) * 0.1 * t, 0);\n\tfloat a = sphere(pm * rot(t * 0.8, t * 0.5, t * 1.4), siz);\n\tfloat b = sdTorus(pm * rot(t * 0.8, t * 0.5, t * 1.4), vec2(siz, siz * 0.4));\n\tfloat c = sdTorus88(pm * rot(t * 0.8, t * 0.5, t * 1.4), vec2(siz, siz * 0.4));\n\t\n\tfloat t1 = smoothstep(mt*0.0, mt*1.0, t);\n\tfloat t2 = smoothstep(mt*1.0, mt*2.0, t); \n\tfloat t3 = smoothstep(mt*2.0, mt*3.0, t);\n\t\n\tfloat mdis = a*(1.0-t1) + b*t1*(1.0-t2) + c*t2; \n\t\n\tvec2 res = sunk(water_2(p, rd),\n\t\t\t\t\tvec2(mdis, MAT_BALL),\n\t\t\t\t\t0.8);\n\t\n\tfloat roomDis = -sphere(vec3(n), 20.0);//-sdBox(n - vec3(0, 10, 0), vec3(50, 10, 50));\n\tif (roomDis < 0.0) {\n\t\t//res = un(res, vec2(udRoundBox(q, vec3(0.4), 0.1), MAT_S2_BLOCK));\n\t\tvec2 np = vec2(p.x + p.y * 0.5, p.y * 0.5 + p.z);\n\t\tres = un(res, vec2(sdHexPrism(q.xzy + + 0.04 * (0.5 - 0.5/*texture(noiseP, np).x*/), vec2(0.5, 0.5)), MAT_S2_BLOCK));\n\t} else {\n\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\tfloat a = max(roomDis - 1.73, b + EPS); // TODO 1.73 kan vara for mycket \n\t\tres = un(res, vec2(max(EPS, a), -1));\n\t}\n\treturn res;\n}\n\n\nvec3 getNormal(vec3 p, vec3 rd, vec3 ro)\n{\n    vec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = scene(p + ep.xyz, rd).x - scene(p - ep.xyz, rd).x;\n    normal.y = scene(p + ep.yxz, rd).x - scene(p - ep.yxz, rd).x;\n    normal.z = scene(p + ep.yzx, rd).x - scene(p - ep.yzx, rd).x;\n    return normalize(normal);\n}\n\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, float mint, float maxt, float shadowAmbient)\n{\n    for( float t=mint; t < maxt; )\n    {\n        float h = scene(ro + rd*t, rd).x;\n        if( h<0.01 )\n            return shadowAmbient;\n        t += h;\n    }\n    return 1.0;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt )\n{\n\tfloat res = 1.0;\n    float t = mint;\n   for( float t=mint; t < maxt; )\n    {\n\t\tvec2 res = scene( ro + rd*t, rd );\n\t\tfloat h = res.x;\n\t\tfloat m = res.y;\n\t\tif (m  > 0.0) {\n       \t res = min( res, h );\n\t\t}\n\t\tt += h;\n        if( h<0.01 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n/*vec3 applyFog(vec3 rgb, float dis, vec3 rayDir, vec3 sunDir, vec3 p)\n{\n\tfloat fogAmount = 1.0 - exp(-dis*0.005);\n\tfloat sunAmount = 0; //max(0.0, dot(rayDir, sunDir));\n\tvec3 fogColor = mix(vec3(0.3), vec3(1.0,0.9,0.7), pow(sunAmount,12.0));\n\treturn mix(rgb, fogColor, fogAmount);\n}*/\n#define jumps 4\n#define imax 600\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 eye = vec3(0);\n\tvec3 light = vec3(0);\n\tvec3 tar = vec3(0);\n\tbool waterRefract = false;\n\tfloat lightInvSize = 0.5;\n\tfloat shadowAmbient = 0.3;\n\tfloat lightIntensity = 0.004;\n\tbool lightCollision = false;\n\tfloat refJumpDistance = 0.02;\n\tbool shadows = true;\n\tfloat tmax = 800.0;\n\tvec3 skyColor = vec3(0);\n\tbool cubicDis = false;\n\tvec3 rollV = vec3(0, 1, 0);\n    \n\tfloat time = iTime - float(SCENE_1);\n    time *= 0.2;\n    float r = 6.0 + 2.0 * sin(time * 0.1);\n    eye = vec3(cos(time * 0.5) * r, 2, sin(time * 0.5) * r);\n    tar = vec3(0, 1, 0);\n    light = vec3(-10, 5, -10);\n    lightIntensity = 0.001;\n    lightCollision = true;\n    refJumpDistance = 0.1;\n    shadowAmbient = 0.4;\n    shadows = false;\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(rollV, dir)); \n \tvec3 up = cross(dir, right);\n    \n    float u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (iResolution.y/iResolution.x); \n\n    vec3 color = skyColor;\n      \n    float t = 0.0;\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\t\n\tfloat ref = 1.0;\n\tfloat lightAura = 0.0;\n    float breakVar = 0.0;\n\tfor(int j = 0; j < jumps; ++j)\n    {\n        if (breakVar > 0.5) {\n            break;\n        }\n    \tt = 0.0;\n    \t for(int i = 0; i < imax; ++i)\n   \t\t {\n             if (t >= tmax) {\n             \tbreak;\n             }\n\t        vec3 p = ro + rd * t;\n\t        vec2 dm = scene(p, rd);\n\t        float d = dm.x;\n\t        float m = dm.y;\n\t\t\t\n\t\t\t\n\t        if(d < EPS || i == imax || t >= tmax) \n\t        {\n\t        \tvec3 x0 = light;\n\t        \tvec3 x1 = ro;\n\t        \tvec3 x2 = ro + rd;\n\t        \tfloat ldis = pow(length(cross(x2 - x1, x1 - x0)),2.0) / pow( distance(x2, x1), 2.0); \n\t        \tvec3 normal = getNormal(p, rd, ro);\n\t\t\t\t\n\t\t\t\tvec3 invLight = normalize(light - p);\n\t        \tfloat diffuse = max(0.,dot(invLight, normal));\n\t        \tvec3 refrd = reflect(rd, normal);\n\t        \t\n\n\t        \tvec3 n = floor(p);\n\t\t\t\tvec3 c = vec3(0.5);\n\t\t\t\t\n\t\t\t\tif(m == MAT_BLOCK){\n\t\t\t\t\tc = vec3(sin(n.y) * 0.1 + 0.3, sin(n.y) * 0.1 +0.1, sin(n.y) * 0.1 + 0.1)*1.1;\n\t\t\t\t}\n\t\t\t\telse if(m == MAT_SPHERE){\n\t\t\t\t\tc = vec3(0, 0.5, 0);\n\t\t\t\t}\n\t\t\t\telse if(m == MAT_WATER){\n\t        \t\tc = vec3(1); \n\t\t\t\t}\n\t\t\t\telse if (m == MAT_S2_OBJECT) {\n\t\t\t\t\tc = vec3(1, 0, 0);\n\t\t\t\t} else if (m == MAT_DRILL) {\n\t\t\t\t\t\n\t\t\t\t} else  if (m == MAT_S3_BLOCK) {\n\t\t\t\t\t/*if (n.z == 16) {\n\t\t\t\t\t\tc = sin(2*distance(vec2(n.xy), vec2(0, 0)) ) > 0 ? vec3(0.1, 0.2, 0.6) : vec3(0.01, 0.01, 0.01);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = vec3(0.1, 0.2, 0.6);\n\t\t\t\t\t}*/\n\t\t\t\t\tc = vec3(sin(n.x)*0.5 + 0.5, sin(n.y)*0.5 + 0.5, sin(n.z)*0.5 + 0.5);\n\t\t\t\t} else if (m == MAT_BALL) {\n\t\t\t\t\tc = vec3(0.5);\n\t\t\t\t} else if (m == MAT_S2_BLOCK) {\n\t\t\t\t\tint t = int(iTime - float(SCENE_1));\n\t\t\t\t\tc = vec3(n.y * 0.05, n.y * 0.08, n.y * 0.03);//vec3(sin(n) * 0.1);\n\t\t\t\t\t//if (int(n.y) % 6 == t % 6) {\n\t\t\t\t\t//\tc.r = 1;\n\t\t\t\t\t//}\n\t\t\t\t\tclamp(c, 0.0, 1.0);\n\t\t\t\t} else if (m == MAT_S4_FLOOR) {\n\t\t\t\t\t\n\t\t\t\t} else if (m == MAT_S4_MIRROR) {\n\t\t\t\t\tc = vec3(1);\n\t\t\t\t} else if (m == MAT_S1_TORUS) {\n\t\t\t\t\t\n\t\t\t\t} else if (m == MAT_S5_BLOB) {\n\t\t\t\t\tc = vec3(1);\n\t\t\t\t} else if (m == MAT_S5_FLOOR) {\n\t\t\t\t\tc = vec3(0.9);\n\t\t\t\t} else if (m == MAT_S5_PILLAR) {\n\t\t\t\t\tc = vec3(0.8, 0, 0);\n\t\t\t\t} else if (m == MAT_MORPH) {\n\t\t\t\t\tvec3 pc = p + vec3(90);\n\t        \t\tvec3 matCol = vec3(pc.x/10.0, (pc.x + pc.z) / 5.0, pc.z/8.0);\n\t        \t\tc = (sin(matCol) + 1.0) * 0.5;\n\t\t\t\t} else if (m == MAT_S6_ROOF) {\n\t\t\t\t\tc = vec3(0, 0, 1);\n\t\t\t\t} else if (m == MAT_S2_WATER) {\n\t\t\t\t\tc = vec3(0.3, 0.3, 0.6);\n\t\t\t\t} else if (m == MAT_S6_WATER) {\n\t\t\t\t\tc = vec3(0.6, 0.6, 1.0);\n\t\t\t\t} else if (m == MAT_TEXT) {\n\t\t\t\t\tc = vec3(1, 0, 0);\n\t\t\t\t}\n\t\t\t\t\n\t        \tif (inRefraction) {\n\t\t\t\t\t\n\t        \t} else {\n\t\t\t\t\tc = 0.7*c* (1.0 + diffuse);\n\t\t\t\t\tif(shadows && m != MAT_S5_BLOB){\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t        \tc += specular(normal, -invLight, normalize(eye - p), 70.0);\n\t        \t}\n\t            \n\t            float dis = length(light - p);\n\t            float disFact = 1.0 / (1.0 + lightIntensity*dis*dis * (cubicDis ? dis : 1.0 ));\n\t            c *= disFact;\n\t\t\t\t\n\t\t\t\t\t        \t\n\t        \tfloat tl = -dot(x1 - x0, x2 - x1)/pow(distance(x2,x1),2.0);\n\t        \tif(tl > 0.0 && ((lightCollision && distance(eye, light) < distance(eye, p)) || !lightCollision)){\n\t        \t\tlightAura = max(lightAura, 1.0/(0.01 + lightInvSize*ldis));\n\t        \t}\n\t\t\t\t//color = applyFog(color, distance(eye, p), rd, vec3(0, 0, 1), p);\n\n\t\t\t\tcolor = mix(color, c, ref);\n\t\t\t\t\n\t\t\t\tif(m == MAT_WATER || m == MAT_S2_WATER || m == MAT_S6_WATER){\n\t\t\t\t\tif (waterRefract) {\n\t\t\t\t\t\trd = refract(rd, normal, 1.0/1.333); \n\t\t\t\t\t\tro = p + rd*0.02;\n\t\t\t\t\t\tinRefraction = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trd = reflect(rd, normal);\n\t\t\t\t\t\tro = p + rd*0.02;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trd = reflect(rd, normal);\n\t         \t\t//ro = p + rd*0.02;\n\t         \t\tro = p + rd*refJumpDistance;\n\t\t\t\t}\n\n\t\t\t\t\n\t            if(m == MAT_LIGHT){\n\t            \tcolor = vec3(0.5, 0.5, 0.5);\n\t            }\n\n\t        \t\n\t        \tif (m == MAT_WATER) {\n\t        \t\t//inRefraction = true;\n\t        \t\tref = 0.8;\n\t        \t} else if (m == MAT_S6_WATER) {\n\t\t\t\t\tref *= 0.8;\n\t        \t} else if (m == MAT_S5_BLOB) {\n\t        \t\tref = 0.7;\n\t        \t} else if (m == MAT_S4_MIRROR) {\n\t        \t\tref = 0.9;\n        \t\t} else if (m == MAT_BALL) {\n\t\t\t\t\tref *= 0.4;\n\t       \t\t} else if (m == MAT_S2_WATER) {\n\t\t\t\t\tref *= 0.5;\n\t       \t\t} else if (m == MAT_MORPH) {\n\t        \t\tref *= 0.4;\n\t        \t} else {\n\t\t        \tref = 0.0;\n\t        \t}\n\t        \tif (ref <= 0.01) {\n\t        \t\t//j = 10000;\n\t\t\t\t\tbreakVar = 1.0;\t        \t\t\n\t        \t}\n\t           \tbreak;\n\t        }\n\t\n\t        t += d;\n    \t}\n    }\n    \n   \n    fragColor = vec4(color + vec3(lightAura),  1.0); \n}\n\n\n  ","name":"Image","description":"","type":"image"}]}