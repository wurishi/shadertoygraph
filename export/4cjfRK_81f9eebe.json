{"ver":"0.1","info":{"id":"4cjfRK","date":"1725205728","viewed":20,"name":"Study of Sun and Moon","username":"Peregrine","description":"2024-06-20, study of stereographic projection of a texture.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow","stereographicprojection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t   iTime\n#define PI  3.1415926535897932384626\n#define TAU (2. * PI)\n#define PHI 1.6180339887498948482045\n#define EPSILON 0.01\n\n#define max2(a, b) (a.x > b.x ? a : b)\n#define min2(a, b) (a.x < b.x ? a : b)\n#define pos(x) ((x) * .5 + .5)\n#define rep(p, r) mod((p) + .5 * (r), r) - .5 * (r)\n#define repid(p, r) floor(((p) + .5 * (r))/(r))\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define sat(x) clamp(x, 0., 1.)\n\n#define TR_MAX_STEPS   128\n#define TR_MAX_DIST    120.\n#define GLOW_RADIUS    .9\n#define GLOW_INTENSITY .09\n#define GLOW_THRESHOLD 5\n#define COLORBG        vec3(0.)\n#define COLOR1         vec3(1., .7, .4)\n#define COLOR2         vec3(.8, .8, .9)\n\nvec2 sdf(vec3 p) {\n  vec2 di = vec2(TR_MAX_DIST, -1.);\n  di = min2(di, vec2(length(p) - 1., 1.));\n  di = min2(di, vec2(length(p + 2. * vec3(cos(.3 * t), sin(.3 * t), 0.)) - .2, 2.));\n  return di;\n}\n\nvec3 glow;\nvoid acc_glow(int i, vec2 di) {\n  if (i > GLOW_THRESHOLD) {\n    float glow_factor = (1. - sat(di.x/GLOW_RADIUS)) * GLOW_INTENSITY;\n    if (di.y == 2.)\n      glow += COLOR2 * glow_factor;\n    if (di.y == 1.)\n      glow += COLOR1 * glow_factor;\n  }\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  float td = 0.;\n \n  glow = vec3(0.);\n  for (int i = 0; i < TR_MAX_STEPS && td < TR_MAX_DIST; i++) {\n    vec2 di = sdf(p);\n    if (di.x < EPSILON)\n      return vec2(td, di.y);\n    acc_glow(i, di);\n    p += di.x * rd;\n    td = distance(ro, p);\n  }\n  \n  return vec2(-1.);\n}\n\nvec3 get_normal(vec3 p) {\n  vec2 e = EPSILON * vec2(1., -1.);\n  return normalize(\n    e.xyy * sdf(p + e.xyy).x +\n    e.yxy * sdf(p + e.yxy).x +\n    e.yyx * sdf(p + e.yyx).x +\n    e.xxx * sdf(p + e.xxx).x\n  );\n}\n\nvec3 get_raydir(vec2 uv, vec3 ro, vec3 ta) {\n  vec3 rd = normalize(ta - ro),\n       r = normalize(cross(vec3(0., 1., 0.), rd)),\n       u = normalize(cross(rd, r));\n  return normalize(rd + r * uv.x + u * uv.y);\n}\n\nvec3 get_material(float id, vec3 p, vec3 n) {\n  // from higher to lower id\n  vec3 tex = texture(iChannel0, // stereographic projection of sphere onto plane:\n                     vec2(p.x/(.5 - p.z) - .1 * t, p.y/(.5 - p.z))).rgb;\n  if (id >= 2.) return COLOR2 + glow;\n  if (id >= 1.) return COLOR1 + tex + glow;\n  return COLORBG + glow;\n}\n\nvec3 render(vec2 uv) {\n  vec3 ro = vec3(0., 0., -5),\n       ta = vec3(0.),\n       rd = get_raydir(uv, ro, ta);\n  \n  vec2 tdi = trace(ro, rd);\n  if (tdi.x > 0.) {\n    vec3 p = ro + tdi.x * rd,\n         n = get_normal(p);\n    return get_material(tdi.y, p, n);\n  } else \n      return get_material(-1., vec3(0.), vec3(0.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\tvec3 c = render(uv);\n  \n\tfragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}