{"ver":"0.1","info":{"id":"mdyyR1","date":"1695873410","viewed":76,"name":"PBR in 2D with self-shadowing","username":"arkelley77","description":"This shader combines the Lambert model (for diffuse lighting) with the Cook-Torrance model (for specular lighting). Additionally, it uses ray marching to self-cast soft shadows.\n\nbump map conversion code from https://www.shadertoy.com/view/ld2cW1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// The light follows the mouse\n\nconst vec3 lightColor = normalize(vec3(251,176,59));\nconst float lightIntensity = 3.0;\nconst float lightHeightPx = 512.0;\nconst float lightRadiusPx = 128.0;\n\nconst float stoneRoughness = 0.7;\nconst float stoneReflectivity = 0.5;\nconst float stoneIOR = 1.5;\n\nconst int rayMarchSamples = 4;\n\n// ----\n\nconst float f0 = pow(stoneIOR - 1.0, 2.0) / pow(stoneIOR + 1.0, 2.0);\n\nconst float rayMarchSamplesPerSide = floor(sqrt(float(rayMarchSamples)));\n\nvec4 bumpMap(vec2 uv) {\n    float height = texture(iChannel0, uv).r;\n    \n    vec2 uv_grad_x = dFdx(uv), uv_grad_y = dFdy(uv);\n    mat2 kernel = mat2(uv_grad_y.y, -uv_grad_y.x, -uv_grad_x.y, uv_grad_x.x);\n    \n    vec2 height_grad = vec2(dFdx(0.1 * height), dFdy(0.1 * height)) * kernel\n        / (uv_grad_y.x * uv_grad_x.y - uv_grad_y.y * uv_grad_x.x);\n    \n    vec3 normal = vec3(height_grad, 1.0 - length(height_grad));\n    return vec4(normal, height * 255.0);\n}\n\n\nfloat lightFalloff(float lightSourceIntensity, float d) {\n    return lightSourceIntensity / pow(d, 2.0);\n}\n\n\nfloat ggx(float nDotH, float roughness) {\n    float alpha2 = pow(roughness, 2.0);\n    return (nDotH > 0.0) \n        ? (alpha2 / (4.0 * pow(1.0 + pow(nDotH, 2.0) * (alpha2 - 1.0), 2.0)))\n        : 0.0;\n}\nfloat geometricAttenuation(float nDotH, float nDotL, float nDotV, float vDotH) {\n    return min(1.0, 2.0 * nDotH * min(nDotV, nDotL) / vDotH);\n}\nfloat fresnel(float vDotH) {\n    return f0 + (1.0 - f0) * pow(1.0 - vDotH, 5.0);\n}\nfloat cookTorrance(vec3 dirToLight, vec3 dirToCamera, vec3 normal, float roughness) {\n    \n    vec3 reflectionAxis = (dirToLight + dirToCamera) / 2.0;\n    \n    float nDotH = dot(normal, reflectionAxis);\n    float nDotL = dot(normal, dirToLight);\n    float nDotV = dot(normal, dirToCamera);\n    float vDotH = dot(dirToLight, reflectionAxis);\n    float specularReflectance = ggx(nDotH, roughness) \n        * geometricAttenuation(nDotH, nDotL, nDotV, vDotH)\n        * fresnel(vDotH)\n        / (4.0 * nDotL * nDotV);\n        \n    return specularReflectance;\n}\n\n\nfloat rayMarch(vec3 fragLocation, vec3 lightLocation, float lightRadius) {\n    vec3 vToLight = lightLocation - fragLocation;\n    float dToLight = length(vToLight);\n    vec3 dirToLight = normalize(vToLight);\n    \n    float elAngleToLight = asin(dirToLight.z);\n    float lightRadiusArcAngle = atan(lightRadius / dToLight);\n    float minElAngleToLight = elAngleToLight - lightRadiusArcAngle;\n    float maxElAngleToLight = elAngleToLight + lightRadiusArcAngle;\n    float lightDiameterArcAngle = lightRadiusArcAngle * 2.0;\n    \n    float t = 0.25;\n    float amtOfLightVisible = 1.0;\n    while (t <= dToLight) {\n        vec2 marchCoord = fragLocation.xy + dirToLight.xy * t;\n        float marchHeight = bumpMap(marchCoord / iResolution.xy).a;\n        vec3 diff = vec3(marchCoord, marchHeight) - fragLocation;\n        \n        float elAngleToSurf = asin(diff.z / length(diff));\n        float localAmtLightVisible = (maxElAngleToLight - elAngleToSurf) / lightDiameterArcAngle;\n        \n        amtOfLightVisible = min(amtOfLightVisible, localAmtLightVisible);\n        \n        vec2 deltas = (step(0.0, dirToLight.xy) - fract(marchCoord)) / dirToLight.xy;\n        t += max(min(deltas.x, deltas.y), 0.1);\n    }\n    return clamp(amtOfLightVisible, 0.0, 1.0);\n}\nfloat occludedLight(vec3 fragLocation, vec3 lightLocation, float lightRadius, vec2 uv) {\n    if (rayMarchSamples > 0) {\n        float half_step = 1.0 / rayMarchSamplesPerSide;\n        float full_step = half_step * 2.0;\n        float ret = 0.0;\n        for (float samp_pos_y = half_step - 0.5; samp_pos_y < 1.0; samp_pos_y += full_step) {\n            for (float samp_pos_x = half_step - 0.5; samp_pos_x < 1.0; samp_pos_x += full_step) {\n                ret += rayMarch(fragLocation + vec3(samp_pos_x, samp_pos_y, 0.0), lightLocation, lightRadius);\n            }\n        }\n        ret /= rayMarchSamplesPerSide * rayMarchSamplesPerSide;\n        return ret;\n    } else {\n        return 1.0;\n    }\n}\n\n\nfloat luminance(vec3 color) {\n    return (color.r + color.g + color.b) / 3.0;\n}\n\nvec3 toneMap(vec3 hdrColor) {\n    float lum = luminance(hdrColor) / lightIntensity;\n    return hdrColor * lum / (lum + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 norm_height = bumpMap(uv);\n    vec3 normal = norm_height.rgb;\n    float height = norm_height.a;\n    \n    float iResDiagonal = length(iResolution.xy);\n    \n    vec3 fragCoord3d = vec3(fragCoord.xy, height);\n    vec3 fragLocation = fragCoord3d / iResDiagonal;\n    \n    vec3 lightCoord3d = vec3(iMouse.xy, lightHeightPx);\n    vec3 lightLocation = lightCoord3d / iResDiagonal;\n    \n    vec3 vToLight = lightLocation - fragLocation;\n    \n    float dToLight = length(vToLight);\n    vec3 dirToLight = vToLight / dToLight;\n    \n    vec3 stoneColor = texture(iChannel3, uv).rgb;\n    \n    float diffuse = max(dot(dirToLight, normal), 0.0);\n    vec3 diffuseColor = stoneColor * lightColor;\n    \n    float specular = cookTorrance(dirToLight, vec3(0.0, 0.0, 1.0), normal, stoneRoughness);\n    \n    vec3 reflectionVector = reflect(vec3(0.0, 0.0, 1.0), normal);\n    vec3 reflectionColor = (texture(iChannel2, reflectionVector).rgb * texture(iChannel1, uv).rgb);\n    //    + texture(iChannel2, normalize(reflectionVector + stoneRoughness * (texture(iChannel1, uv).rgb - 0.5))).rgb\n    //    + texture(iChannel2, normalize(reflectionVector + stoneRoughness * (texture(iChannel1, uv).gba - 0.5))).rgb\n    //) / 3.0;\n    \n    float localLightIntensity = lightFalloff(lightIntensity, dToLight) * luminance(lightColor);\n    float localOccludedLight = rayMarch(fragCoord3d, lightCoord3d, lightRadiusPx);\n    \n    vec3 colorHDR = \n        localLightIntensity * localOccludedLight *  (diffuseColor * diffuse * stoneRoughness + lightColor * specular * (1.0 - stoneRoughness))\n        + stoneReflectivity * reflectionColor;\n    \n    fragColor.rgb = //vec3(localOccludedLight);\n        toneMap(colorHDR);\n}","name":"Image","description":"","type":"image"}]}