{"ver":"0.1","info":{"id":"4tsyDn","date":"1504358441","viewed":112,"name":"CSG+AA Union","username":"rougier","description":"Antialiased union of two circles","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","antialias","csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Python and OpenGL for Scientific Visualization\n// 2017 Nicolas P. Rougier\n\n// This function compute the coverage according to the distance d (in pixels),\n// the desired linewidth and the antialias area. Usually antialias is 1.\n// Greater value means blurred lines, smaller values means hard lines.\nfloat coverage(float d, float width, float antialias)\n{\n    d -= width/2.0 - antialias;\n    float alpha = d/antialias;\n    if( d < 0.0 ) return 1.0;\n    return exp(-alpha*alpha);\n}\n\n// Union (A or B)\nfloat csg_union(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\n// Signed distance to a circle\nfloat circle(vec2 p, vec2 center, float radius)\n{\n    return length(p-center) - radius;\n}\n\n// Move circles using mouse\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float radius = max(iResolution.x, iResolution.y)/6.0;\n    vec2 center1 = vec2(iResolution.x/2.0 - radius/2.0,\n                        iResolution.y/2.0);\n    vec2 center2 = vec2(iResolution.x/2.0 + radius/2.0,\n                        iResolution.y/2.0);\n    // Uncomment to move second circle with mouse\n    // center2 = iMouse.xy;\n    \n    vec2 p = gl_FragCoord.xy + vec2(0.5);\n    float d1 = circle(p, center1, radius);\n    float d2 = circle(p, center2, radius);\n    float d = csg_union(d1,d2);\n    fragColor = mix(vec4(1.,1.,1.,1.),\n                    vec4(0.,0.,0.,1.),\n                    coverage(abs(d),1.,1.));\n}","name":"Image","description":"","type":"image"}]}