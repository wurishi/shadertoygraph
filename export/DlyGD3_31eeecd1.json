{"ver":"0.1","info":{"id":"DlyGD3","date":"1685008275","viewed":45,"name":"7px","username":"daryag","description":"7","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["7"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nconst int m = 3; \n\nfloat leftturn(vec2 v1, vec2 v2, vec2 p) {\n    float res = (p.x - v1.x) * (v2.y - v1.y) - (v2.x - v1.x) * (p.y - v1.y);\n    if (res < 0.) return -1.;\n    if (res == 0.) return 0.;\n    return 1.;\n}\n\nbool inSphere(vec3 cen, float rad) {\n    if (length(cen) < rad)\n        return true;\n    else return false;\n}\n\nfloat get_z_sph(vec3 cen, float rad, vec2 p) {\n    float z = sqrt(rad*rad - (p.x-cen.x)*(p.x-cen.x) - (p.y-cen.y)*(p.y-cen.y));\n    return cen.z-z;\n}\n\nbool inPolygon(int m,vec3 Verts[9],vec2 p) {\n    int i;\n    for (i = m*3+1; i < m*3+3; i++) {\n        if (leftturn(Verts[i-1].xy,Verts[i].xy,p) == -1.)\n            return false;\n    }\n    if(leftturn(Verts[i-1].xy,Verts[m*3].xy,p) == -1.)\n        return false;\n    return true;\n}\n\nvec3 color(int m, vec3 Verts[9],vec2 p) {\n    float s1 = Verts[8].y - Verts[6].y;\n    float s2 = Verts[8].x - Verts[6].x;\n    float s3 = Verts[7].y - Verts[6].y;\n    float s4 = p.y - Verts[6].y;\n\n    float w1 = (Verts[6].x * s1 + s4 * s2 - p.x * s1) / (s3 * s2 - (Verts[7].x-Verts[6].x) * s1);\n    float w2 = (s4- w1 * s3) / s1;\n\n    return \n        w1 >= 0.0 &&\n        w2 >= 0.0 &&\n        (w1 + w2) <= 1. ?\n\n        vec3(w1, w2, 1.) :\n        vec3(1.,1.,1.);\n}\n\nfloat get_z_pol(vec3 p,vec3 v) {\n    return length(p-v);\n}\n\nmat3 rotateX(float X) {\n    return mat3(1.,0.,0.,0.,cos(X),-sin(X),0.,sin(X),cos(X));\n}\n\nmat3 rotateY(float X) {\n    return mat3(cos(X),0.,sin(X),0.,1.,0.,-sin(X),0.,cos(X));\n}\n\nmat3 rotateZ(float X) {\n    return mat3(cos(X), -sin(X), 0.\t,sin(X), cos(X), 0.\t,0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = cos(uv.xxx)*vec3(8.,.8,.3);\n    \n    vec3 Vertices[9] = vec3[9](\n                vec3(1.,1.5,1.),\n                vec3(.5,-.6,1.),\n                vec3(0.,0.,1.),\n                \n                vec3(1.,-1.,1.),\n                vec3(.3,-.7,1.),\n                vec3(0.,1.,-5.),\n                \n                vec3(-.3,-.5,-3.),\n                vec3(-.7,-.8,-5.),\n                vec3(-.5,0.5,-1.)\n    );\n   \n                \n    int i;\n    \n    for(i = 0; i < 3; i++)\n        Vertices[i] *= rotateZ(iTime)*rotateX(iTime)*rotateY(iTime);\n    for(i = 3; i < 6; i++)\n        Vertices[i] *= rotateZ(iTime);\n    for(i = 6; i < 9; i++)\n        Vertices[i] *= rotateZ(iTime*0.5);\n        \n    vec3 colAr[4] = vec3[4](\n            cos(215.*uv.xxx),\n            vec3(.5,.7,.1),\n            color(3,Vertices,uv),\n            vec3(.3,.99,.4)\n    );\n\n    \n    float radAr[2] = float[2](0.2,0.25);\n    \n    float z, z1 = 1000.0;\n    \n    float d;\n    \n    if (inSphere(vec3(uv,1.)-vec3(0.2*sin(iTime),0.4*cos(iTime),1.),radAr[0]) == true) {\n        z = get_z_sph(vec3(0.2*sin(iTime),0.4*cos(iTime),1.),radAr[0],uv);\n        if (z1 > z) {\n            z1 = z;\n            col = vec3(.9,.4,.7);\n        }\n    }\n    for (i = 0; i < m; i++)\n        if (inPolygon(i,Vertices,uv) == true) {\n            z = get_z_pol(vec3(uv,0.),Vertices[i]);\n            if (z1 > z) {\n                z1 = z;\n                col = colAr[i];\n            }\n        }\n     \n    if (inSphere(vec3(uv,1.)-vec3(0.5*cos(iTime),0.3*sin(iTime),1.1),radAr[1]) == true) {\n        z = get_z_sph(vec3(0.5*cos(iTime),0.3*sin(iTime),1.1),radAr[1],uv);\n        if (z1 > z) {\n            z1 = z;\n            col = colAr[3];\n        }\n    }\n        \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}