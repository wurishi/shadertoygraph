{"ver":"0.1","info":{"id":"NtGBDR","date":"1676482698","viewed":176,"name":"Fluid sim mk2","username":"thepinkpanzer","description":"new fluid sim with a Godunov solver","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["simulation","fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T(p) texture(iChannel0,(p))\n#define B(p) texture(iChannel1,(p))\n\nvec4 jet(float x) // from 0 to 1\n{\n    return pow(vec4(x*x*(1.-x)/0.148, pow(x*(1.-x)*4.,2.), x*(1.-x)*(1.-x)/0.148, 0), vec4(1.6));\n}\nvec4 twilight(float x) // from -1 to 1\n{\n    float s  = sign(x);\n    x *= s;\n    \n    float r  = mix(1., (s > 0. ? x*x : x*x*x*x*x), 0.8);\n    float b  = mix(1., (s < 0. ? x*x : x*x*x*x*x), 0.8);\n    float g  = mix(1., x*x*x*x, 0.95);\n    return vec4(r, g, b, 0);\n}\n\nvec4 recolor(float x)\n{\n    x = tanh(x);\n    return jet(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord/iResolution.xy;\n    vec4 Q   = T(uv);\n    vec4 q   = Q/Q.r;\n    \n    float ek = 0.5*(q.g*q.g+q.b*q.b);\n    float t  = q.a-ek;\n    float s  = (GAMMA-1.)*t*pow(Q.r, -GAMMA);\n    \n    // ek  is kinetic energy per unit mass\n    // t   is thermal energy per unit mass\n    // s   is related to the entropy\n    // Q.r is density\n    \n    // Colour scheme: vec4(tanh(ek/t*10.));//\n    fragColor = tanh(normalize(recolor(sqrt(t)*0.4))*Q.r);//tanh(vec4(Q.r));//recolor(q.b*2.);\n    // Draw obstacles in black\n    fragColor*= (1.-B(uv).r);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T(p) texture(iChannel0,(p)/iResolution.xy)\n#define Y(p) texture(iChannel1,(p)/iResolution.xy)\n#define PI 3.1415926535897932384626\n\n\nvec4 Flux(vec4 Qn0, vec4 Qnp)\n{\n    // Momenta inside here are rotated so the outwards-facing normal is along +x\n    // Have to rotate to and from outside of here.\n    float z   = (GAMMA-1.)/(2.*GAMMA);\n    \n    float ek0 = (dot(Qn0.gb, Qn0.gb))/(2.*Qn0.r);\n    float T0  = Qn0.a-ek0;\n    float P0  = T0*(GAMMA-1.);\n    float a0  = sqrt(GAMMA*P0/Qn0.r);\n    float u0  = Qn0.g/Qn0.r;\n    \n    float ekp = (dot(Qnp.gb, Qnp.gb))/(2.*Qnp.r);\n    float Tp  = Qnp.a-ekp;\n    float Pp  = Tp*(GAMMA-1.);\n    float ap  = sqrt(GAMMA*Pp/Qnp.r);\n    float up  = Qnp.g/Qnp.r;\n    \n    float Pstar = pow((a0 + ap - (GAMMA-1.)*0.5*(up-u0))/(a0/pow(P0, z)+ap/pow(Pp, z)), 1./z);\n    float q0    = Pstar > P0 ? sqrt(1. + (GAMMA+1.)/(2.*GAMMA)*(Pstar/P0-1.)) : 1.;\n    float qp    = Pstar > Pp ? sqrt(1. + (GAMMA+1.)/(2.*GAMMA)*(Pstar/Pp-1.)) : 1.;\n    \n    // Wave speeds\n    float S0    = u0 - q0*a0;\n    float Sp    = up + qp*ap;\n    float Sstar = (Pp - P0 + Qn0.r*u0*(S0-u0) - Qnp.r*up*(Sp-up))\n                 /(Qn0.r*(S0-u0) - Qnp.r*(Sp-up));\n    \n    float k0    = Qn0.r*(S0-u0)/(S0-Sstar);\n    vec4  Qn1   = k0*vec4(1, Sstar, Qn0.b/Qn0.r, Qn0.a/Qn0.r + (Sstar-u0)*(Sstar + P0/(Qn0.r*(S0-u0))));\n    \n    float kp    = Qnp.r*(Sp-up)/(Sp-Sstar);\n    vec4  Qn2   = kp*vec4(1, Sstar, Qnp.b/Qnp.r, Qnp.a/Qnp.r + (Sstar-up)*(Sstar + Pp/(Qnp.r*(Sp-up))));\n    \n    // Fluxes\n    vec4 dQ     = (min(S0, 0.)*(Qn0-Qn1) + min(Sstar,0.)*(Qn1-Qn2) + min(Sp, 0.)*(Qn2-Qnp));\n       \n    return dQ*DT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Getting the data\n    float x   = fragCoord.x;\n    float y   = fragCoord.y;\n    \n    vec4 Q00  = T(vec2(x , y ));\n    // Q:    Quantities (vec4 of conserved quantities)\n    // Q.r:  Mass density\n    // Q.gb: X- and Y-momentum.\n    // Q.a:  Total energy (kinetic + thermal)\n    \n    // Boring boundary condition stuff\n    #if   X_BOUNDARY == 0\n        float xp  = mod(fragCoord.x + 1.0 + iResolution.x, iResolution.x);\n        float xm  = mod(fragCoord.x - 1.0 + iResolution.x, iResolution.x);\n\n        vec4 Qp0  = T(vec2(xp, y ));\n        vec4 Qm0  = T(vec2(xm, y ));\n    #elif X_BOUNDARY == 1\n        float xp  = x + 1.;\n        float xm  = x - 1.;\n        \n        vec4 Qp0;\n        vec4 Qm0;\n        if (xp >= iResolution.x)\n        {\n            Qp0 = T(vec2(xm, y))*vec4(1,-1,1,1);\n        }\n        else\n        {\n            Qp0 = T(vec2(xp, y));\n        }\n        if (xm < 0.)\n        {\n            Qm0 = T(vec2(xp, y))*vec4(1,-1,1,1);\n        }\n        else\n        {\n            Qm0 = T(vec2(xm, y));\n        }\n    #elif X_BOUNDARY == 2\n        float xp  = x + 1.;\n        float xm  = x - 1.;\n        \n        vec4 Qp0;\n        vec4 Qm0;\n        if (xp >= iResolution.x)\n        {\n            Qp0 = T(vec2(xm, y))*vec4(1,-1,-1,1);\n        }\n        else\n        {\n            Qp0 = T(vec2(xp, y));\n        }\n        if (xm < 0.)\n        {\n            Qm0 = T(vec2(xm, y))*vec4(1,-1,-1,1);\n        }\n        else\n        {\n            Qm0 = T(vec2(xm, y));\n        }\n    #elif X_BOUNDARY == 3\n        float xp  = x + 1.;\n        float xm  = x - 1.;\n        \n        vec4 Qp0;\n        vec4 Qm0;\n        if (xp >= iResolution.x)\n        {\n            Qp0 = mix(T(vec2(xm, y)), Q00, 1.+ALPHA);\n        }\n        else\n        {\n            Qp0 = T(vec2(xp, y));\n        }\n        if (xm < 0.)\n        {\n            Qm0 = mix(T(vec2(xp, y)), Q00, 1.+ALPHA);\n        }\n        else\n        {\n            Qm0 = T(vec2(xm, y));\n        }\n    #endif\n    #if   Y_BOUNDARY == 0\n        float yp  = mod(fragCoord.y + 1.0 + iResolution.y, iResolution.y);\n        float ym  = mod(fragCoord.y - 1.0 + iResolution.y, iResolution.y);\n        \n        vec4 Q0p  = T(vec2(x , yp));\n        vec4 Q0m  = T(vec2(x , ym));\n    #elif Y_BOUNDARY == 1\n        float yp  = y + 1.;\n        float ym  = y - 1.;\n        \n        vec4 Q0p;\n        vec4 Q0m;\n        if (yp >= iResolution.y)\n        {\n            Q0p = T(vec2(x, ym))*vec4(1,1,-1,1);\n        }\n        else\n        {\n            Q0p = T(vec2(x, yp));\n        }\n        if (ym < 0.)\n        {\n            Q0m = T(vec2(x, yp))*vec4(1,1,-1,1);\n        }\n        else\n        {\n            Q0m = T(vec2(x, ym));\n        }\n    #elif Y_BOUNDARY == 2\n        float yp  = y + 1.;\n        float ym  = y - 1.;\n        \n        vec4 Q0p;\n        vec4 Q0m;\n        if (yp >= iResolution.y)\n        {\n            Q0p = T(vec2(x, ym))*vec4(1,-1,-1,1);\n        }\n        else\n        {\n            Q0p = T(vec2(x, yp));\n        }\n        if (ym < 0.)\n        {\n            Q0m = T(vec2(x, yp))*vec4(1,-1,-1,1);\n        }\n        else\n        {\n            Q0m = T(vec2(x, ym));\n        }\n    #elif Y_BOUNDARY == 3\n        float yp  = y + 1.;\n        float ym  = y - 1.;\n        \n        vec4 Q0p;\n        vec4 Q0m;\n        if (yp >= iResolution.y)\n        {\n            Q0p = mix(T(vec2(x, ym)), Q00, 1.+ALPHA);\n        }\n        else\n        {\n            Q0p = T(vec2(x, yp));\n        }\n        if (ym < 0.)\n        {\n            Q0m = mix(T(vec2(x, yp)), Q00, 1.+ALPHA);\n        }\n        else\n        {\n            Q0m = T(vec2(x, ym));\n        }\n    #endif\n    \n    // Calculating the fluxes\n    vec4 dQp0 = Flux(Q00                    , Qp0                    )                    ;\n    vec4 dQm0 = Flux(Q00     *vec4(1,-1,1,1), Qm0     *vec4(1,-1,1,1))     *vec4(1,-1,1,1);\n    \n    vec4 dQ0p = Flux(Q00.xzyw               , Q0m.xzyw               ).xzyw               ;\n    vec4 dQ0m = Flux(Q00.xzyw*vec4(1,-1,1,1), Q0p.xzyw*vec4(1,-1,1,1)).xzyw*vec4(1,1,-1,1);\n    // Writing the new state of the system\n    vec4 Q1 = Q00 + (dQp0 + dQm0 + dQ0p + dQ0m);\n    \n    // Diffusion\n    Q1     += D0*(Qp0 + Qm0 + Q0p + Q0m - 4.*Q00)*DT;\n    \n    // Obstacles\n    float q = 0.5*Y(fragCoord).r;\n    Q1 *= vec4(1,1.-q,1.-q,1);\n    \n    // Initial conditions\n    if (iFrame == 0)\n    {\n        if (cos(3.*3.14159265*(fragCoord.y+5.*sin(3.14159*fragCoord.x/iResolution.x*3.))/iResolution.y) > 0.)\n        {\n            Q1 = vec4(1, 4.4,0,10);\n        }\n        else\n        {\n            Q1 = vec4(1,-4.4,0,10);\n        }\n    }\n    fragColor = Q1;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// here i will store the fundamental laws of the universe\n// DT:    Timestep\n// D0:    Diffusion coefficient (numerical dissipation)\n// GAMMA: Adiabatic constant for the gas (1.67=monatomic, 1.4=diatomic, 1.33=polyatomic)\n#define DT      0.05\n#define D0      0.0\n#define GAMMA   1.67\n\n// Boundary conditions\n// 0: Loop\n// 1: Smooth wall\n// 2: No-slip wall\n// 3: Open (linear)\n#define X_BOUNDARY 0\n#define Y_BOUNDARY 1\n\n// Alpha is just used by the OPEN boundary condition\n// Describes whether to be more linear or flat.\n#define ALPHA 0.95\n// Alpha=0 -> flat\n// Alpha=1 -> linear\n// Alpha>=1 will probably be unstable.","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Obstacles\n    // Modelled as porous; gas can flow through somewhat (makes for a bit less stress on the system)\n    if (distance(fragCoord, iResolution.xy/2.) < 20.)\n    {\n        fragColor = vec4(0);\n    }\n    else\n    {\n        fragColor = vec4(0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}