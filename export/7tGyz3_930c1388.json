{"ver":"0.1","info":{"id":"7tGyz3","date":"1665682822","viewed":166,"name":"orbit sight","username":"Gijlf","description":"volumetric light experiment","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["volumetriclight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926535898;\nconst float tau = pi * 2.0;\nconst vec2 r = normalize(vec2(1, sqrt(3.0)));\nconst vec2 h = r / 2.0;\n\nconst uint hk = 1103515245U;\nuint uh11(uint x) {\n    x = ((x>>8U)^x)*hk;\n    x = ((x>>8U)^x)*hk;\n    x = ((x>>8U)^x)*hk;\n    return x;\n}\nfloat h11(float x) {\n    return float(uh11(floatBitsToUint(x)))/float(0xffffffffU);\n}\nfloat n11(float x) {\n    float fx = floor(x);\n    return mix(h11(fx), h11(fx+1.0), fract(x));\n}\n\nuvec2 uh22(uvec2 x) {\n    x = ((x>>8U)^x.yx)*hk;\n    x = ((x>>8U)^x.yx)*hk;\n    x = ((x>>8U)^x.yx)*hk;\n    return x;\n}\nvec2 h22(vec2 x) {\n    return vec2(uh22(uvec2(\n        floatBitsToUint(x.x),\n        floatBitsToUint(x.y)\n    )))/float(0xffffffffU);\n}\nfloat h21(vec2 x) {\n    return h11(x.x+x.y*199.0);\n}\nfloat n21(vec2 p) {\n    vec2 t = smoothstep(0.0, 1.0, fract(p));\n    p = floor(p);\n    float h0 = h21(p);\n    float h1 = h21(p+vec2(1,0));\n    float h2 = h21(p+vec2(0,1));\n    float h3 = h21(p+vec2(1,1));\n    return (h0) + (h1-h0) * t.x + (h2-h0) * t.y + (h3-h1-h2+h0) * t.x * t.y;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat hex(vec2 p) {\n    p = abs(p);\n    return max(dot(p, r), p.x);\n}\n\nvec4 hexuv(vec2 p) {\n    vec2 a = mod(p, r)-h, b = mod(p-h, r)-h;\n    vec2 uv = (dot(a,a) < dot(b,b)) ? a : b;\n    vec2 id = p - uv;\n\n    return vec4(uv, id);\n}\n\nfloat extrude(float p, float d, float h) {\n    vec2 w = vec2(d, abs(p) - h);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat box(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return min(max(max(p.x, p.y),p.z), 0.0) + length( max(vec3(0), p) );\n}\n\n#define id zw\nfloat volumap(vec2 p, float t) {\n    vec4 huv = hexuv(p);\n    float hd = hex(huv.xy);\n    float l = length(huv.id);\n    float n = n21(huv.id + l * 2.0 + t) - 0.3;\n    l -= 3.0;\n    float s = (abs(l)/3.0) * 1.8;\n    return max(0.0, n) * smoothstep(0.02, 0.0, hd - n * s ) * step(l, 0.0);\n}\n\nfloat map(vec3 p, float t) {\n    float ti = (n11(t) + t) * 0.35;\n    float ground = p.y + 2.0;\n    p.y -= 0.6;\n    p.xy *= rot(ti); p.xz *= rot(ti);\n    float sp = box(p, vec3(0.43)) - 0.01;\n    float l = length(p);\n    float sph = mix(0.43, 0.87, 0.5 + sin(t) * 0.5);\n    float mi = 0.5+sin(ti * 6.0)*0.5;\n    sp = mix(sp, l - sph, mi);\n    for (int i=0; i<3; i++) {\n        float s = 1.1 * (float(i) / 2.0) + 1.1;\n        p.xy *= rot(ti*tau); p.xz *= rot(ti*tau);\n        float pl = i == 0 ? p.x : i == 1 ? p.y : p.z;\n        vec2 pl2 = i == 0 ? p.yz : i == 1 ? p.xz : p.xy;\n        vec3 pl3 = vec3(pl, pl2);\n        float sp1 = max( abs(l-s)-0.05, abs(pl)- 0.05);\n        s *= 5.0; float sp2 = extrude(pl, ( abs(hex(pl2 / s)-0.2) * s ) -0.05, 0.05);\n        sp = min(sp, mix(sp1, sp2, mi)-0.01);\n        s *= 5.0; sp = min(sp, extrude(pl3.y, ( abs(hex(pl3.xz / s)-0.2) * s ) -0.062, 0.062) -0.02);\n    }\n    return min(ground, sp);\n}\n\nvec3 norm(vec3 p, float t) {\n    const vec2 o = vec2(1e-3, 0);\n    return normalize(vec3(\n        map(p+o.xyy, t) - map(p-o.xyy, t),\n        map(p+o.yxy, t) - map(p-o.yxy, t),\n        map(p+o.yyx, t) - map(p-o.yyx, t)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    float ti = iTime;\n    float mti = ti * 1.2;\n\n    float a = ti * 0.2;\n    vec3 s1 = vec3(cos(a)*10.0,3,sin(a)*10.0);\n    a += 3.49;\n    vec3 s2 = vec3(cos(a)*12.0,0.4,sin(a)*18.0);\n    vec3 s=mix(s1, s2, 0.5+sin(n11(ti * 0.6) * 0.5))*0.4;\n\n    vec3 cz = normalize(-s);\n    vec3 cx = normalize(cross(cz, vec3(0,1,0)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(uv.x*cx + uv.y*cy + 0.3*cz);\n\n    const vec3 ld = normalize(vec3(0,-1,9));\n\n    float td = 0.0;\n    const float md = 100.0;\n    for (int i=0; i<128; i++) {\n        float d = (map(s + rd * td, mti));\n        if (abs(d) < 1e-3) { //break;\n            vec3 e = s + rd * td - vec3(0,0.6,0);\n            if (dot(e,e) > 0.87*0.87) break;\n            vec3 n = norm(e, mti);\n            rd = reflect(rd, n);\n            float lum = dot(n, ld); lum = mix(max(0.0, lum), lum*0.5+0.5, 0.1);\n            col += (lum) * 0.2;\n        }\n        if (td > md) break;\n        td += d;\n    }\n    td = min(td, md);\n    vec3 e = s + rd * td;\n    float fog = 1.0 - (td / md);\n    fog *= (e.y <= -1.9) ? volumap(e.xz, ti) : 1.0;\n\n    vec3 n = norm(e, mti);\n    float lum = dot(n, ld); lum = mix(max(0.0, lum), lum*0.5+0.5, 0.1);\n    float spec = pow( max(0.0, dot( reflect(rd, n), -ld)), 32.0);\n    col += pow(fog * (lum + spec), 0.85);\n\n    float vol = 0.0;\n    float stp = td / 128.0;\n    for (int i=0; i<128; i++) {\n        e += -rd * stp;\n        float v = (volumap(e.xz, ti) * (smoothstep(3.0, 0.0, e.y+2.1)) );\n        vol += v * (0.10 / map(e, mti));\n        if (e.y < -2.0) break;\n    }\n    col += max(0.0, vol * 0.2) * 0.6;\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}