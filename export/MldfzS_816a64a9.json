{"ver":"0.1","info":{"id":"MldfzS","date":"1540141264","viewed":393,"name":"Lit Surface","username":"ircss","description":"A work in progress of practicing some of the things I have learned about ligting in the past few days. Feedbacks very welcome. Uses mouse as input for light pos","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["noise","lighting","normals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid DrawCircle(inout vec3 lFragColor, in vec2 pos, in vec2 uv, in vec3 color){\n \t lFragColor=mix(color, lFragColor, smoothstep(0.1, 0.102, distance(pos, uv)));   \n}\nfloat randFloat( in float seed){\n \treturn fract(sin(seed)*50000.);   \n}\n\n\nfloat Noise(in vec2 st) {\n       vec2 uv = st;\n\n        //st.x+= iTime*0.1;\n    st *= 7.;\n    \n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n\n    float time = iTime * 0.4;\n    float time_i = floor(time);\n    float time_f = fract(time);\n    \n    float m_dist = 1.0;  // minimun distance\n    \n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i + neighbor);\n\t\t\tvec2 randSeed=point;\n            \n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f;\n\t\t\tfloat factor = .38;\n            \n             // Distance to the point\n            float dist = length(diff);\n            for (int d= -1; d <= 1; d++) {\n        \t\tfor (int j= -1; j <= 1; j++) {\n            \tvec2 neighborSecondIteration = vec2(float(d),float(j));\n\t\t\t\t\n                vec2 seed = random2(i + neighbor);\n                \n            \tfloat weight = seed.x;\n                factor +=  dist *weight* float ((d==0)&&(j==0)) * (sin(iTime*4.1*(1.-seed.x )+seed.y*4.21321)*0.5+0.5 ) ;\n            \n        \t\t}\n    \t\t}\n\t\t\t\n            // Keep the closer distance\n            if(dist/**factor*/<= m_dist){\n                m_dist =dist /**factor*/;\n            }\n            \n        }\n    }\n    return  1.-pow( m_dist*1.0,5.2);\n\n}\n\nfloat CalculateAttenuation(vec2 pixelUVPos, vec3 LightPos){\n    \n    float d = distance(vec3(pixelUVPos.xy, 0.), LightPos);\n    return 1./(1.+d*d);\n}\n\nvec3 CalculateNormals(vec2 st){\n    \n    vec2 delta = vec2(0.5/iResolution.y, 0.);\n    float h1 = Noise(st - delta);\n    float h2 = Noise(st + delta);\n    delta = vec2(0., 0.5/iResolution.y);\n    float h3 = Noise(st -delta);\n    float h4 = Noise(st +delta);\n    \n    vec3 du = vec3(1., 0, (h2 - h1)*8.);\n    vec3 dv = vec3(0.,1, (h4 - h3)*8.);\n   \tvec3 normal = cross(du,dv);\n\n    return normalize(normal);\n}\n\nfloat CalculateLighting(vec2 st, vec3 lightPos, vec3 normal){\n    vec3 lightDirection = normalize(vec3(st.xy, 0.)- lightPos);\n    float lighting = dot(lightDirection, normal);\n    return max(0.,lighting);\n}\n\nfloat CalculateSpecularFactor(vec3 CameraPos, vec2 st, vec3 Normal, vec3 LightPos){\n    vec3 PixelPos =  vec3(st.xy, 0.-Noise(st)*0.06);\n    vec3 LightDir = normalize(PixelPos-LightPos);\n    return max(0.,dot(reflect(LightDir, Normal), normalize(PixelPos-CameraPos)));\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec2 Mouse = iMouse.xy/iResolution.xy;\n    Mouse.x *=iResolution.x/iResolution.y;\n    vec3 color = vec3(0.);\n\n    vec3 pointLightPosition = vec3(Mouse.xy, -0.1);\n \n   \n    vec3 CameraPos = vec3(0.5, 0.5, -1.0);\n    CameraPos.x *= iResolution.x/iResolution.y;\n    vec3 albedo = vec3(0.2,0.4,0.9);\n    vec3 pointLightColor = vec3(0.9,0.3,0.01) * 6.;\n    \n    float lightingFactor=CalculateAttenuation(st, pointLightPosition);\n    vec3 Normal = CalculateNormals(st);\n    float specularFactor = CalculateSpecularFactor(CameraPos,st, Normal, pointLightPosition);\n    lightingFactor *= CalculateLighting(st, pointLightPosition, Normal);\n    vec3 speculartyColor = vec3(0.5,0.2,0.1);\n    float specularity= max(max(speculartyColor.x,speculartyColor.y), speculartyColor.z);\n    color = (albedo + lightingFactor* pointLightColor)*0.5*(1.-specularity);\n\tcolor += specularFactor*speculartyColor*lightingFactor;\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}