{"ver":"0.1","info":{"id":"X3f3R8","date":"1707098315","viewed":241,"name":"Sirius star","username":"afrhu","description":"Procedural recreation of Sirius star. Following \"The Art of Code\" tutorial (https://www.youtube.com/watch?v=rvDo9LvfoVE) and inspired by \"Sirius's heart\" by Isekaijoucho","likes":2,"published":1,"flags":4,"usePreview":0,"tags":["light","star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D Rotation matrix\nmat2 rotate(float angle){\n\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    mat2 m = mat2(c, -s, s, c);\n    \n    return m;\n}\n\n// Create a star\nfloat star(vec2 uv, float flare_intensity, float factor){\n    \n    //Distance to venter\n    float d = length(uv);\n    // Add circle\n    float m = 0.07*factor / d;\n    \n    //Rotate flares\n    // Rotate coordinates 10 degrees\n    uv = uv * rotate(3.1415*10.0/180.0);\n    \n    \n    // Add lens flare\n    float flares = 1.0 - abs(uv.x*uv.y*1000.0);\n    flares = max(0.0, flares*0.3);\n    \n    m += flares*flare_intensity;\n    \n    //limit light\n    m *= smoothstep(1.0, 0.2, d);\n    \n    return m;\n}\n\n//pseudo random number\nfloat hash21(vec2 p){\n    \n    p = fract(p*vec2(159.94, 456.21));\n    p += dot(p, p+24.47);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(0);\n    \n    //Multiple stars with tiles\n    vec2 tile_uv = uv*500.0;\n    vec2 tuv = fract(tile_uv)-0.5; //center\n    vec2 id = floor(tile_uv); // unique id for each tile\n    \n    //col += star(tuv, 1.0);\n    \n    //Smooth transition between tiles\n    // Iterate over tile 8 neighbours\n    for (int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x++){\n        \n            //offset\n            vec2 offs = vec2(x, y);\n            \n            //random number\n            float n = hash21(id + offs);\n            vec2 position = vec2(n, fract(n*845.0))-0.5;\n            \n            // Variable size\n            float size = fract(n*345.32);\n            \n            col += star(tuv - offs - position, 0.0, 0.2)*size;\n    \n        }\n    }\n    \n    // Add Sirius star\n    float sirius_star = star(uv*2.0, 1.0, 1.0);\n    // bluish halo\n    vec3 col_blue = vec3(0.1, 0.45, 0.95);\n    float halo = star(uv*1.4, 0.0, 1.0);\n    col += 0.7*halo*col_blue*smoothstep(0.02,0.07, length(uv));\n    // animation\n    col += sirius_star*(0.06*sin(2.0*iTime)+1.0);\n    \n    \n    float fft_high  = texelFetch( iChannel0, ivec2(33,0), 0 ).x;\n    if (fft_high > 0.90){    \n        col += 0.3*sirius_star*vec3(1.0,0.1,0.6);\n    } \n    \n    \n    //star\n    //col += star(uv, 1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}