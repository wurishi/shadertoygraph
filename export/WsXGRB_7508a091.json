{"ver":"0.1","info":{"id":"WsXGRB","date":"1546607978","viewed":107,"name":"Deferred Spheretracing","username":"nnorm","description":"octahedron encoded normals following this blog post: https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["normals","spheretracing","octahedron","deferred","gbuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Exposure/gamma correction + output\n\nconst float gammaNumber = 1.0/2.22;\nconst float exposure = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec4 shaded = texture(iChannel0, uv);\n    fragColor = pow(shaded * exposure, vec4(gammaNumber));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* G-Buffer pass */\n\n#define MAX_STEPS 512\n\nconst float t_min = 0.03;\nconst float t_max = 256.0;\nconst float t_epsilon = 0.001;\n\nfloat sdfSphere(in vec3 p, in float r)\n{ return length(p) - r; }\n\nfloat sdfPlane(in vec3 p, in vec3 n, in float d)\n{\n    return dot(p, n) + d;\n}\n\nfloat s0(in vec3 p) { return sdfSphere(p, 0.3); }\nfloat pl(in vec3 p) { return sdfPlane(p, vec3(0.0, 1.0, 0.0), 0.6); }\n\nfloat map(in vec3 p)\n{\n    return min(s0(p), pl(p));\n}\n\nfloat trace(in vec3 ro, in vec3 rd)\n{\n    vec3 p = ro;\n    float d = map(p + rd * t_min);\n    float dAcc = d;\n    bool hit = (dAcc >= t_max || d <= t_epsilon);\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        if(hit)\n            break;\n        p += rd * d;\n        d = map(p);\n        dAcc += d;\n        hit = (dAcc >= t_max || d <= t_epsilon);\n        \n    }\n    if(d <= t_epsilon)\n        return dAcc;\n    else\n        return t_max;\n}\n\nvec3 N(in vec3 p)\n{\n    vec2 eps = vec2(t_epsilon, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)));\n}\n\n\nfloat getMaterialID(in vec3 p)\n{\n    float d = map(p);\n    if(d == s0(p))\n        return 1.0;\n    else if(d == pl(p))\n        return 2.0;\n    else\n        return 0.0;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = g_CameraPos;\n    vec3 rd = getRayDir(uv);\n    float tr = trace(ro, rd);\n    \n    if(tr < t_max)\n    {\n        vec3 pos = tr * rd + ro;\n        \n    \tfragColor = vec4(Encode(N(pos)), tr, getMaterialID(pos));\n    }\n    else\n        fragColor = vec4(0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159264\n#define TAU 6.28318528\n\nfloat rand11(float n)\n{\n\treturn fract(sin(n) * 43758.5453123);\n}\n\nfloat noise11(float p)\n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand11(fl), rand11(fl + 1.0), fc);\n}\n\nfloat rand21(vec2 n)\n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise21(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u  = fract(p);\n\tu = u * u * (3.0 - 2.0 * u);\n\t\n\tfloat res = mix(\n\t\tmix(rand21(ip), rand21(ip + vec2(1.0, 0.0)), u.x),\n\t\tmix(rand21(ip + vec2(0.0, 1.0)), rand21(ip + vec2(1.0, 1.0)), u.x), u.y);\n\n\treturn res * res;\n}\n\nfloat saturate( float a )\n{\n    return clamp(a, 0.0, 1.0);\n}\n\nfloat remap01to_11(float a)\n{\n    return a * 2.0 + 1.0;\n}\n\nvec2 remap01to_11(vec2 a)\n{\n    return vec2(remap01to_11(a.x), remap01to_11(a.y));\n}\n\nfloat remap_11to01(float a)\n{\n    return a * 0.5 + 0.5;\n}\n\nvec2 remap_11to01(vec2 a)\n{\n    return vec2(remap_11to01(a.x), remap_11to01(a.y));\n}\n\n//https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/\nvec2 OctWrap( vec2 v )\n{\n    float cmp = ( v.x >= 0.0 ? 1.0 : -1.0 ) * ( v.y >= 0.0 ? 1.0 : -1.0 );\n    return ( 1.0 - abs( v.yx ) ) * cmp;\n}\n \nvec2 Encode( vec3 n )\n{\n    n /= ( abs( n.x ) + abs( n.y ) + abs( n.z ) );\n    n.xy = n.z >= 0.0 ? n.xy : OctWrap( n.xy );\n    n.xy = n.xy * 0.5 + 0.5;\n    return n.xy;\n}\n\nvec3 Decode( vec2 f )\n{\n    //https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/\n    f = f * 2.0 - 1.0;\n    // https://twitter.com/Stubbesaurus/status/937994790553227264\n    vec3 n = vec3( f.x, f.y, 1.0 - abs( f.x ) - abs( f.y ) );\n    float t = saturate( -n.z );\n    n.xy += (n.x >= 0.0 ? -t : t) * (n.y >= 0.0 ? -t : t);\n    return normalize( n );\n}\n\nmat3 computeTBN(in vec2 uv, in vec3 N)\n{\n    vec3 T = vec3(uv.x, 0.0, uv.y);\n    vec3 B = normalize(cross(N, T));\n    T = normalize(cross(B, N));\n    return mat3(T, B, N);\n}\n\nmat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )\n{\n    // get edge vectors of the pixel triangle\n    vec3 dp1 = dFdx( p );\n    vec3 dp2 = dFdy( p );\n    vec2 duv1 = dFdx( uv );\n    vec2 duv2 = dFdy( uv );\n\n    // solve the linear system\n    vec3 dp2perp = cross( dp2, N );\n    vec3 dp1perp = cross( N, dp1 );\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n    // construct a scale-invariant frame \n    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );\n    return mat3( T * invmax, B * invmax, N );\n}\n\n/*******************************************************************/\n\nconst vec3 g_CameraPos = vec3(0.0, 0.0, 1.0);\n\nvec3 getRayDir(in vec2 uv)\n{\n    return normalize(vec3(uv, -1.0));\n}\n\nstruct Material\n{\n    vec3 albedo;\n    float specExp;\n};\n\nconst int g_NumMat = 3;\nconst Material[g_NumMat] g_Mats = Material[g_NumMat](Material(vec3(0.25, 0.25, 0.25), 0.0), //default\n                     \t\t\t\t   \t\t\t\t Material(vec3(1.0, 0.0, 0.0), 64.0), //sphere\n                     \t\t\t\t   \t\t\t\t Material(vec3(0.0, 1.0, 0.0), 0.0)); //plane\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\nconst int g_NumLights = 2;\nconst Light[g_NumLights] g_Lights = Light[g_NumLights](Light(vec3(1.0, 1.0, 1.0), vec3(1.0), 7.0),\n                                                       Light(vec3(0.0, 0.0, 2.0), vec3(1.0), 0.0));\n\nconst vec3 g_AmbiantLight = vec3(0.005);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Direct lighting pass */\n\nvec3 getBrdf(in vec3 WorldPos, in vec3 N, in Material mat, in Light light)\n{\n    vec3 albedo = mat.albedo ;\n    float specExp = mat.specExp;\n    \n    vec3 L = (light.position - WorldPos);\n    float d = length(L);\n    L /= d;\n    float attenuation = 1.0 / (1.0 + d*d);\n    \n    float ndl = max(0.0, dot(N, L));\n    \n    vec3 V = normalize(g_CameraPos - WorldPos);\n    vec3 H = normalize(V + L);\n    \n    float spec = pow(max(0.001, dot(N, H)), specExp);\n    float specPower = clamp(specExp, 0.0, 1.0);\n    return ((albedo/PI) + spec * specPower) * light.color * light.intensity * attenuation * ndl;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 smpl = texture(iChannel0, uv);\n    \n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 N = Decode(smpl.xy);\n    vec3 P = g_CameraPos + smpl.z * getRayDir(uv);\n    \n    vec3 color;\n    int materialId = int(smpl.w);\n    if(materialId != 0)\n    {\n        color = g_AmbiantLight;\n\n        for(int i = 0; i < g_NumLights; i++)\n        {\n            color += getBrdf(P, N, g_Mats[materialId], g_Lights[i]);\n        } \n    }\n    else\n    {\n        color = g_Mats[materialId].albedo;\n    }\n    \n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}