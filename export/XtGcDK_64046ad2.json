{"ver":"0.1","info":{"id":"XtGcDK","date":"1537658774","viewed":5366,"name":"Interactive Fluid Simulation","username":"wyatt","description":"Interactive demonstration of my new fluid solving algo (shadertoy.com/view/4lyyzc). Best in full screen.","likes":99,"published":1,"flags":32,"usePreview":0,"tags":["fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see buffer A to learn how it works, this just makes it pretty\n\nvec4 t (vec2 v) {return texture(iChannel0,v/iResolution.xy);}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 me = t(U);\n    me.z-=1.;\n    \n    C = 1.-3.*me.wwww;\n    vec3 d = vec3(t(U+vec2(1,0)).w-t(U-vec2(1,0)).w,t(U+vec2(0,1)).w-t(U-vec2(0,1)).w ,2.);\n    \n    C.xyz -= max(vec3(0),sin(vec3(100.*length(me.xy),-5.*me.z,368.*d.y)*me.w));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tSo how this works makes total sense in my head, but\n\tits a little difficult to describe coherently\n\n\tI have been thinking about how to make a fluid for a long time.\n\tI came up with this algorithm by thinking about particles and waves\n\tand how they work together and are kind of the same thing\n\n\tso particles are like discritizations of a wave\n\tand waves are like large sums of particles\n\tthat create a continuum of information\n\n\tthe pressure in the feild is like a wave.\n\tit stores energy when the space contracts \n\tand releases that energy when the space expands\n    \n\ta particle would experience an acceleraton down\n    the slope of the wave just as a surfer would\n\n\tas the particles accelerate in the direction of the wave\n\tthey may start to move together or move apart\n\tthis affects the divergence/contraction of the space\n\t\n\tthis way there is a feedback between the wave-like characteristics\n    of the space and the particle-like characteristics of the space\n\n\tso I simulate a neighborhood of 5 particles and discern \n    how their interactions will predict the contraction of the space\n\n\tthen I accelerate the central particle in the direction of the\n\tpressure gradient which is found by measuring the pressure of \n\teach neighbor particle and doing a spacial derivative of these pressures\n\n*/\n\nvec2 R;\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);} // samples fluid\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \t// U A B C D are locations of particles that make a square with U in the middle\n \tvec2 O = U,A = U+vec2(1,0),B = U+vec2(0,1),C = U+vec2(-1,0),D = U+vec2(0,-1);\n \t// u a b c d are states of particles at there respective locations as per the fluid information feild\n \tvec4 u = T(U), a = T(A), b = T(B), c = T(C), d = T(D);\n \t// p is going to be the particle interaction force from a b c and d on u\n \tvec4 p;\n \t// g is going to be the average force of the pressure gradient on particle u\n \tvec2 g = vec2(0);\n \t// we iterate twice to advect the fluid and sum particle and wave forces\n \t#define I 2\n \tfor (int i = 0; i < I; i++) {\n        // here we increment the position of each particle by the velocity at that particle's location\n        U -=u.xy; A -=a.xy; B -=b.xy; C -=c.xy; D -=d.xy; \n        // here we add the particle force which is just the change in the distance between the particles\n        p += vec4(length(U-A),length(U-B),length(U-C),length(U-D))-1.;\n        // here we add the wave force which is just the gradient of the pressure\n        g += vec2(a.z-c.z,b.z-d.z);\n        // here we update the state of each particle based on its new location\n        u = T(U);a = T(A); b = T(B); c = T(C); d = T(D);\n \t}   \n \t// here we make the output equal to the previous state of the particle \n \tQ = u; // which is the state of particle u\n \tvec4 N = 0.25*(a+b+c+d);// average the neighbor particles to calculate laplacian\n \tQ = mix(Q,N, vec4(0,0,1,0)); // blend output with neighbors (just the pressure is blended)\n \tQ.xy -= g/10./float(I); // add the wave force (gradient of the pressure) to the velocity\n \tQ.z += (p.x+p.y+p.z+p.w)/10.; // add the particle force to the pressure of the output\n \t\n \t\n \t// for some reason the pressure slowly builds, this is just like a pressure release\n \tQ.z *= 0.9999;\n    // get mouse pos and prev pos from buffer D\n \tvec4 mouse = texture(iChannel1,vec2(0.5));\n \t\t// find distance to line segment that is from mouse start to mouse end\n        float q = ln(U,mouse.xy,mouse.zw);\n        vec2 m = mouse.xy-mouse.zw;\n        float l = length(m);\n        if (mouse.z>0.&&l>0.) {\n            // accelerate fluid and add ink\n            Q.xyw = mix(Q.xyw,vec3(-normalize(m)*min(l,20.)/25.,1.),max(0.,5.-q)/25.);\n        }\n \n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n \t// add some ink and velocity to the middle of the screen\n \tif (iFrame < 14 && length(U-0.5*R) < 20.) Q.xyw = vec3(0,.1,1);\n \t// bound the edges and make them still\n \tif (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xyw*=0.;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n\tSo how this works makes total sense in my head, but\n\tits a little difficult to describe coherently\n\n\tI have been thinking about how to make a fluid for a long time.\n\tI came up with this algorithm by thinking about particles and waves\n\tand how they work together and are kind of the same thing\n\n\tso particles are like discritizations of a wave\n\tand waves are like large sums of particles\n\tthat create a continuum of information\n\n\tthe pressure in the feild is like a wave.\n\tit stores energy when the space contracts \n\tand releases that energy when the space expands\n    \n\ta particle would experience an acceleraton down\n    the slope of the wave just as a surfer would\n\n\tas the particles accelerate in the direction of the wave\n\tthey may start to move together or move apart\n\tthis affects the divergence/contraction of the space\n\t\n\tthis way there is a feedback between the wave-like characteristics\n    of the space and the particle-like characteristics of the space\n\n\tso I simulate a neighborhood of 5 particles and discern \n    how their interactions will predict the contraction of the space\n\n\tthen I accelerate the central particle in the direction of the\n\tpressure gradient which is found by measuring the pressure of \n\teach neighbor particle and doing a spacial derivative of these pressures\n\n*/\n\nvec2 R;\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);} // samples fluid\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \t// U A B C D are locations of particles that make a square with U in the middle\n \tvec2 O = U,A = U+vec2(1,0),B = U+vec2(0,1),C = U+vec2(-1,0),D = U+vec2(0,-1);\n \t// u a b c d are states of particles at there respective locations as per the fluid information feild\n \tvec4 u = T(U), a = T(A), b = T(B), c = T(C), d = T(D);\n \t// p is going to be the particle interaction force from a b c and d on u\n \tvec4 p;\n \t// g is going to be the average force of the pressure gradient on particle u\n \tvec2 g = vec2(0);\n \t// we iterate twice to advect the fluid and sum particle and wave forces\n \t#define I 2\n \tfor (int i = 0; i < I; i++) {\n        // here we increment the position of each particle by the velocity at that particle's location\n        U -=u.xy; A -=a.xy; B -=b.xy; C -=c.xy; D -=d.xy; \n        // here we add the particle force which is just the change in the distance between the particles\n        p += vec4(length(U-A),length(U-B),length(U-C),length(U-D))-1.;\n        // here we add the wave force which is just the gradient of the pressure\n        g += vec2(a.z-c.z,b.z-d.z);\n        // here we update the state of each particle based on its new location\n        u = T(U);a = T(A); b = T(B); c = T(C); d = T(D);\n \t}   \n \t// here we make the output equal to the previous state of the particle \n \tQ = u; // which is the state of particle u\n \tvec4 N = 0.25*(a+b+c+d);// average the neighbor particles to calculate laplacian\n \tQ = mix(Q,N, vec4(0,0,1,0)); // blend output with neighbors (just the pressure is blended)\n \tQ.xy -= g/10./float(I); // add the wave force (gradient of the pressure) to the velocity\n \tQ.z += (p.x+p.y+p.z+p.w)/10.; // add the particle force to the pressure of the output\n \t\n \t\n \t// for some reason the pressure slowly builds, this is just like a pressure release\n \tQ.z *= 0.9999;\n    // get mouse pos and prev pos from buffer D\n \tvec4 mouse = texture(iChannel1,vec2(0.5));\n \t\t// find distance to line segment that is from mouse start to mouse end\n        float q = ln(U,mouse.xy,mouse.zw);\n        vec2 m = mouse.xy-mouse.zw;\n        float l = length(m);\n        if (mouse.z>0.&&l>0.) {\n            // accelerate fluid and add ink\n            Q.xyw = mix(Q.xyw,vec3(-normalize(m)*min(l,20.)/25.,1.),max(0.,5.-q)/25.);\n        }\n \n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n \t// add some ink and velocity to the middle of the screen\n \tif (iFrame < 14 && length(U-0.5*R) < 20.) Q.xyw = vec3(0,.1,1);\n \t// bound the edges and make them still\n \tif (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xyw*=0.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\tSo how this works makes total sense in my head, but\n\tits a little difficult to describe coherently\n\n\tI have been thinking about how to make a fluid for a long time.\n\tI came up with this algorithm by thinking about particles and waves\n\tand how they work together and are kind of the same thing\n\n\tso particles are like discritizations of a wave\n\tand waves are like large sums of particles\n\tthat create a continuum of information\n\n\tthe pressure in the feild is like a wave.\n\tit stores energy when the space contracts \n\tand releases that energy when the space expands\n    \n\ta particle would experience an acceleraton down\n    the slope of the wave just as a surfer would\n\n\tas the particles accelerate in the direction of the wave\n\tthey may start to move together or move apart\n\tthis affects the divergence/contraction of the space\n\t\n\tthis way there is a feedback between the wave-like characteristics\n    of the space and the particle-like characteristics of the space\n\n\tso I simulate a neighborhood of 5 particles and discern \n    how their interactions will predict the contraction of the space\n\n\tthen I accelerate the central particle in the direction of the\n\tpressure gradient which is found by measuring the pressure of \n\teach neighbor particle and doing a spacial derivative of these pressures\n\n*/\n\nvec2 R;\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);} // samples fluid\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \t// U A B C D are locations of particles that make a square with U in the middle\n \tvec2 O = U,A = U+vec2(1,0),B = U+vec2(0,1),C = U+vec2(-1,0),D = U+vec2(0,-1);\n \t// u a b c d are states of particles at there respective locations as per the fluid information feild\n \tvec4 u = T(U), a = T(A), b = T(B), c = T(C), d = T(D);\n \t// p is going to be the particle interaction force from a b c and d on u\n \tvec4 p;\n \t// g is going to be the average force of the pressure gradient on particle u\n \tvec2 g = vec2(0);\n \t// we iterate twice to advect the fluid and sum particle and wave forces\n \t#define I 2\n \tfor (int i = 0; i < I; i++) {\n        // here we increment the position of each particle by the velocity at that particle's location\n        U -=u.xy; A -=a.xy; B -=b.xy; C -=c.xy; D -=d.xy; \n        // here we add the particle force which is just the change in the distance between the particles\n        p += vec4(length(U-A),length(U-B),length(U-C),length(U-D))-1.;\n        // here we add the wave force which is just the gradient of the pressure\n        g += vec2(a.z-c.z,b.z-d.z);\n        // here we update the state of each particle based on its new location\n        u = T(U);a = T(A); b = T(B); c = T(C); d = T(D);\n \t}   \n \t// here we make the output equal to the previous state of the particle \n \tQ = u; // which is the state of particle u\n \tvec4 N = 0.25*(a+b+c+d);// average the neighbor particles to calculate laplacian\n \tQ = mix(Q,N, vec4(0,0,1,0)); // blend output with neighbors (just the pressure is blended)\n \tQ.xy -= g/10./float(I); // add the wave force (gradient of the pressure) to the velocity\n \tQ.z += (p.x+p.y+p.z+p.w)/10.; // add the particle force to the pressure of the output\n \t\n \t\n \t// for some reason the pressure slowly builds, this is just like a pressure release\n \tQ.z *= 0.9999;\n    // get mouse pos and prev pos from buffer D\n \tvec4 mouse = texture(iChannel1,vec2(0.5));\n \t\t// find distance to line segment that is from mouse start to mouse end\n        float q = ln(U,mouse.xy,mouse.zw);\n        vec2 m = mouse.xy-mouse.zw;\n        float l = length(m);\n        if (mouse.z>0.&&l>0.) {\n            // accelerate fluid and add ink\n            Q.xyw = mix(Q.xyw,vec3(-normalize(m)*min(l,20.)/25.,1.),max(0.,5.-q)/25.);\n        }\n \n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n \t// add some ink and velocity to the middle of the screen\n \tif (iFrame < 14 && length(U-0.5*R) < 20.) Q.xyw = vec3(0,.1,1);\n \t// bound the edges and make them still\n \tif (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xyw*=0.;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// keep track of mouse\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = texture(iChannel0,fragCoord/iResolution.xy);\n    if (iMouse.z>0.) {\n        if (p.z>0.) fragColor =  vec4(iMouse.xy,p.xy);\n    \telse fragColor =  vec4(iMouse.xy,iMouse.xy);\n    }\n    else fragColor = vec4(-iResolution.xy,-iResolution.xy);\n}","name":"Buffer D","description":"","type":"buffer"}]}