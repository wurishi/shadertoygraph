{"ver":"0.1","info":{"id":"ml3BWN","date":"1701236240","viewed":30,"name":"Fizz-Bizz","username":"cosparks","description":"first attempt at a charge-up shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fizz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 0: integer hash\n// 1: float hash (aliasing based) (don't do this unless you live in the year 2013)\n#define METHOD 0\n\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 0\n\n#if METHOD==0\nfloat hash( in ivec2 p )  // this hash is not production ready, please\n{                         // replace this by something better\n\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n#else\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n#endif\n\nfloat noise( in vec2 p )\n{\n    #if METHOD==0\n    ivec2 i = ivec2(floor( p ));\n    #else\n    vec2 i = floor( p );\n    #endif\n    vec2 f = fract( p );\n\t\n    #if INTERPOLANT==1\n    // quintic interpolant\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    #else\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n    #endif    \n\n    #if METHOD==0\n    return mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n    #else\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n    #endif\n}\n\n\n\nfloat outerRadius = 100.;\nfloat innerRadius = 90.;\nfloat noiseFactor = 35.0;\nfloat timeFactor = 8.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float noise_x = noiseFactor * noise( 55.0*uv ) * cos(iTime * timeFactor);\n    float noise_y = noiseFactor * noise( 55.0*uv.yx ) * sin(iTime * timeFactor);\n    \n    float dist = pow(fragCoord.x + noise_x - 500.0, 2.0) + pow(fragCoord.y + noise_y - 250.0, 2.0);\n    float f1 = pow(outerRadius, 2.) - dist;\n    float f2 = dist - pow(innerRadius, 2.);\n    \n    if (f1 > 1.0 && f2 > 1.0) {\n        float distFactor = (sqrt(dist) - innerRadius) / (outerRadius - innerRadius) * 2.0 - 1.0;\n        float colourFactor = abs(distFactor);\n        // Normalized pixel coordinates (from 0 to 1)\n        uv = 0.5 + 0.5*cos(iTime+uv.xy+vec2(0,2));\n        fragColor = vec4(1.0, 1.0, colourFactor,colourFactor);\n        //fragColor = vec4(col, 1.0);\n    }\n    else {\n        fragColor = vec4(0., 0., 0.,1.0);\n    }\n\n}","name":"Image","description":"","type":"image"}]}