{"ver":"0.1","info":{"id":"dl23Dh","date":"1673268248","viewed":125,"name":"Oil Stain","username":"Elise","description":"An attempt at a making an oil stain. Not realistic, but I like the dreamy outcome anyways","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 10\nfloat fbm_wrap(in vec2 st, in mat2 rot) {\n    // Initial values\n    float value = 0.;\n    float amplitude = 0.5;\n    // float frequency = 2.;\n    vec2 shift = vec2(100.);\n    // mat2 rot = mat2(cos(1.), sin(0.4),\n    //             -sin(0.4), cos(0.40));\n\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st = rot * st * 2. + shift;\n        amplitude *= 0.6;\n    }\n    return value;\n}\nfloat fbm(in vec2 st) {\n    // Initial values\n    float value = 0.;\n    float amplitude = 0.5;\n    float frequency = 2.;\n\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.192;\n        amplitude *= 0.6;\n    }\n    return value;\n}\n\nfloat fbm_ridge(in vec2 st) {\n    // Initial values\n    float value = 0.;\n    float amplitude = .5;\n    float frequency = 2.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * abs(noise(st));\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    vec2 c = fragCoord.xy/iResolution.xy-.5;\n\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    //static color split V1\n    // color.r += fbm(st+ 20.*(fbm(st+fbm(st))));\n    // color.g += fbm(st+ 4.*(fbm(st+fbm(st))));\n    // color.b += fbm(st+ 15.*(fbm(st+fbm(st))));\n\n\n    vec3 n = vec3(0.);\n\n    float fbm_value = 1.;\n\n    float a = iTime*0.1;\n    mat2 rot_coord = mat2(cos(a), sin(a),\n                -sin(a), cos(a));\n                \n    mat2 rot_noise = mat2(cos(0.4+iTime*0.00001), sin(0.5+iTime*0.0002),\n        -sin(0.5+iTime*0.00001), cos(0.5+iTime*0.0002));\n    // vec2 fbm_st = st*rot+10.;\n\n    // vec2 fbm_st = c*rot_coord;\n    vec2 fbm_st = c;\n\n\n    for(int i = 0; i < 2; i++){\n        float modifier = random(c);\n        fbm_value = fbm_wrap(fbm_st+fbm_value+iTime*0.025, rot_noise);\n    }\n\n    n.x = fbm_value;\n    \n    // fbm_st = c*rot_coord;\n\n    rot_noise = mat2(cos(0.4), sin(0.5),\n                -sin(0.5), cos(0.5));\n\n    for(int i = 0; i < 2; i++){\n        float modifier = random(c);\n        fbm_value = fbm_wrap(fbm_st+fbm_value+iTime*0.025, rot_noise);\n    }\n\n    n.y = fbm_value;\n\n    // fbm_st = c*rot_coord;\n\n    rot_noise = mat2(cos(0.3+iTime*0.00002), sin(0.5+iTime*0.00002),\n                -sin(0.4+iTime*0.0002), cos(0.5+iTime*0.0002));\n\n\n    for(int i = 0; i < 3; i++){\n        float modifier = random(c);\n        fbm_value = fbm_wrap(fbm_st+fbm_value+iTime*0.02, rot_noise);\n    }\n\n    n.z = fbm_value;\n\n    color.r = n.z;\n    color.g = n.x;\n    color.b = n.y;\n\n//----------------------------------------------\n\n    // //\"folded\" texture\n    // vec2 q = vec2(0.);\n    // q.x = fbm( st + 0.05*u_time);\n    // q.y = fbm( st);\n\n    // vec2 r = vec2(0.);\n    // r.x = fbm( st + 1.0*q + vec2(50.7,9.2)+ 0.09*u_time );\n    // r.y = fbm( st + 1.0*q + vec2(15.3,2.8)+ 0.0126*u_time);\n\n    // // //split colors with \"ridges\"\n    // color.r = fbm(st+r*20.);\n    // color.g = fbm(st+r*1.);\n    // color.b = fbm(st+r*13.);\n\n//----------------------------------------------\n    // //cloudy sin anim, one direction\n    // // color.r = fbm(vec2(st+20.+u_time*0.15));\n    // // color.g = fbm(vec2(st+4.+u_time*0.15));\n    // // color.b = fbm(vec2(st+15.+u_time*0.15));\n\n//-----------------------------------------------\n    // //f based colox mix for folded textures\n    // // float f = fbm(st+r);\n\n    // // color = mix(vec3(0.0392, 0.902, 0.9333),\n    // //             vec3(0.5686, 0.4118, 0.4118),\n    // //             clamp(f,0.0,1.0));\n\n                \n    // // color = mix(vec3(0.6784, 0.5137, 0.5137),\n    // //             vec3(1.0, 1.0, 1.0),\n    // //             clamp((f*f)*1.0,0.0,1.0));\n\n    // // color = mix(color,\n    // //             vec3(0.0431, 0.5294, 0.9255),\n    // //             clamp(length(q)*0.5,.0,1.0));\n\n    // // color = mix(color,\n    // //             vec3(0.666667,1,1),\n    // //             clamp(length(r.x)*50.,0.0,.0));\n\n    // // gl_FragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n\n\n    //regular color mapping\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}