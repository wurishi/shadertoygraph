{"ver":"0.1","info":{"id":"Mt2GRt","date":"1431520859","viewed":258,"name":"Magrathea","username":"WilstonOreo","description":"Distorsion Map applied to a sphere","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["distorsionmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nfloat distorsion = 0.5 * iMouse.y / iResolution.y;\nfloat radius = 1.5;\n\nconst float EPS = 0.000001;\nconst float MAX = 1000000.0;\nconst float PI = 3.14159;\n\n\n\n\nfloat grayscale(vec3 c)\n{\n    return 0.2126 * c.r + .7152 * c.g + .0722 * c.b;\n\n}\n\nvec2 sphereTexCoords(vec3 normal)\n{\n  return vec2(fract(atan(normal.x,normal.y) / (2.0*PI) - 0.5 +iTime*0.025),fract(acos(normal.z) / PI));\n}\n\n\n\n\n\nvec2 intersectSphere( vec3 p, vec3 dir, float r ) \n{\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( -MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n\nvec2 getIntersection(vec2 dInner, vec2 dOuter)\n{\n   \tfloat tInner = min(dInner.x,dInner.y);\n   \tfloat tOuter = min(dOuter.x,dOuter.y);\n    \n    if (tOuter < 0.0)\n    {\n        return vec2(-MAX, -MAX);\n    }\n    \n    if (tInner < 0.0)\n    {\n       \treturn vec2(dOuter.x,dOuter.y);\n    }\n    \n    return vec2(tOuter,tInner);\n}\n\n\nfloat map(vec3 p) \n{   \n    vec3 n = normalize(p);\n    \n    vec2 uv = sphereTexCoords(n);\n    \n    float v = grayscale( texture( iChannel0, uv).rgb);\n    \n    v *= v * v;\n    \n    return length(p) - radius + radius * (v - 0.5) * distorsion;\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat rand() { return fract(sin(53225.0)*43758.5453123); }\n\n\nconst int STEPS = 128;\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    float innerRadius = radius * (1.0 - distorsion * 0.5);\n    float outerRadius = radius * (1.0 + distorsion * 0.5);\n    \n    \n    vec3 origin = vec3(0.0,-4.0,0.0);\n    vec3 up = vec3 (0.0, 1.0, 0.0);\n    vec3 dir = normalize (vec3 (uv.x, 2.0, uv.y));\n    \n    vec2 innerSphereDist = intersectSphere(origin,dir,innerRadius);\n    vec2 outerSphereDist = intersectSphere(origin,dir,outerRadius);\n    \n    \n    // Calculate t min and max\n    vec2 t = getIntersection(innerSphereDist,outerSphereDist);\n    /*\n    if (t.x < 0.0 || t.y < 0.0) \n    {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n            return;\n    }*/\n    \n    vec3 iFront = t.x * dir + origin;\n    vec3 iBack = t.y * dir + origin;\n    \n    vec4 color = vec4(1.0,1.0,1.0,1.0);\n    \n    dir = normalize(iBack - iFront);\n    \n    \n    float h = length(iBack - iFront) / float(STEPS) / 4.0;\n    \n    \n    \n    vec3 pos = iFront + dir * h * (rand() - 0.5) * 4.0;\n    \n    \n    for (int i = 0; i < STEPS; ++i)\n    {\n        \n        float dist = map(pos);\n        \n        \n        if (dist < 0.01 * h) \n        {\n         //   fragColor = vec4(1.0,0.0,0.0,1.0);\n\n            break;\n        }\n        if (i == STEPS -1)\n        {\n            \n            fragColor = vec4(0.0,0.0,0.0,1.0);\n            return;\n        }\n            \n        pos += h * dir;\n        h *= 1.2;\n    }\n\n    \n    \n     vec3 nor = calcNormal(pos);\n      color = texture( iChannel0, sphereTexCoords(nor));\n    \n     vec3 ref = reflect( dir, nor );\n\n    \n     // Light position moves with mouse\n     \n     float theta = iMouse.x / iResolution.x * PI * 2.0;\n     vec3 lig = normalize(vec3(cos(theta),sin(theta),0.0));\n    \n        // lighitng        \n        float occ = 0.0 ; //calcAO( pos, nor );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 ) * 4.0;\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0  );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,dir),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0) * grayscale(color.rgb)*4.0;\n        \n            \n            dif *= softshadow( pos, lig, 0.02, 2.5 ) * 1.8;\n        //\tdom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\t\tvec3 brdf = vec3(0.0);\n        \tbrdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        \tbrdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        \tbrdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        \tbrdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        \tbrdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\t\tbrdf += 0.02;\n\t\t\tcolor = vec4(color.rgb*brdf,1.0);\n            \n           \n    \n    /*\n    vec3 iInner = min(innerSphereDist.x,innerSphereDist.y) * dir;\n    \n    vec3 n_inner = normalize(min(innerSphereDist.x,innerSphereDist.y) * dir + origin);\n    vec3 n_outer = normalize(min(outerSphereDist.x,outerSphereDist.y) * dir + origin);\n    \n    if (innerSphereDist.x > 0.0 || innerSphereDist.y > 0.0)\n        color.r = grayscale( texture( iChannel0, sphereTexCoords(n_inner)).rgb);\n    if (outerSphereDist.x > 0.0 || outerSphereDist.y > 0.0)\n        color.g = grayscale( texture( iChannel0, sphereTexCoords(n_outer)).rgb);\n    */\n    \n    \n    \n    \n\tfragColor = color;\n}","name":"","description":"","type":"image"}]}