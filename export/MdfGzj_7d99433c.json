{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n/*\n* GLSL HSV to RGB+A conversion. Useful for many effects and shader debugging.\n*\n* Copyright (c) 2012 Corey Tabaka\n*\n* Hue is in the range [0.0, 1.0] instead of degrees or radians.\n* Alpha is simply passed through for convenience.\n*/\n \nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n \n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t\t\n\t\tcolor.rgb += v - c;\n \n\t\treturn color;\n\t}\n \n\n\tcolor.rgb += v - c;\n \n\treturn color;\n}\n\n/*\n* Copyright (C) 2013 Martin Shirokov\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n* associated documentation files (the \"Software\"), to deal in the Software without restriction,\n* including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n* and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all copies or substantial\n* portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT\n* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nconst float MIN = 0.01;\nconst vec3 MINX = vec3(MIN, 0., 0.);\nconst vec3 MINY = vec3(0., MIN, 0.);\nconst vec3 MINZ = vec3(0., 0., MIN);\nconst float MAX = 10.0;\nconst int I = 50;\nconst int SHAPES = 20;\nconst int MAX_B = 5;\nconst float PI = 3.1415926535;\nconst float TWO_PI = 2. * PI;\n\nfloat sphere(vec3 p, vec3 c, float r){\n\t\n\treturn distance(p, c) - r;\n}\n\nfloat map(vec3 p){\n\tfloat dist = MAX;\n\t\n\tfor(int i = 0; i < SHAPES; i++){\n\t\tfloat ang2 = float(i) / float(SHAPES) * TWO_PI;\n\t\tfloat ang = ang2 + cos(2.824 + sin(iTime)) + iTime / 5.;\n\t\tdist = min(dist, sphere(p, vec3(sin(ang)*5., cos(1.243 + sin(iTime + ang2*5.)), cos(ang)*5.), 0.5));\n\t}\n\t\n\treturn dist;\n}\n\nvec3 ray(vec3 p, vec3 d){\n\t\n\tfloat dist = 1.0;\n\t\n\tfor(int i = 0; i < I; i++){\n\t\t\n\t\tif(dist < MIN)\n\t\t\treturn p;\n\t\tif(length(p) > MAX)\n\t\t\treturn p;\n\t\tdist = map(p);\n\t\tp += d * dist;\n\t}\n\treturn vec3(0.0);\n}\n\nvec3 cam(vec2 uv){\n\n\treturn normalize(vec3(uv, 1));\n}\n\nvec3 normal(vec3 p){\n\n\tvec3 n = vec3(0.);\n\tn.x = map(p + MINX) - map(p - MINX);\n\tn.y = map(p + MINY) - map(p - MINY);\n\tn.z = map(p + MINZ) - map(p - MINZ);\n\t\n\treturn normalize(n);\n}\n\n\nvec4 color(vec3 p){\n\t\n\treturn hsv_to_rgb(sin(atan(p.x/p.z)) + cos(2.824 + sin(iTime)) + iTime / 5., (1. - p.y) * 0.5, 1.0, 1.0);\t\n}\n\nvec4 render(vec3 p, vec3 d){\n\tvec4 c = vec4(1.);\n\tfor(int i = 0; i < MAX_B; i++){\n\t\tp = ray(p, d);\n\t\n\t\tif(length(p) > MAX)\n\t\t\treturn c*texture(iChannel0, d);\n\t\tvec3 n = normal(p);\n\t\td = n;\n\t\tc *= color(p);\n\t\tp += d * MIN;\n\t\t\n\t}\n\treturn vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tvec2 m = (iMouse.xy / iResolution.xy * vec2(1.0, -1.) + vec2(0., 0.5)) * PI;\n\tm.x *= 3.;\n\tm.x *= 3.;\n\tif(iTime < 5.) // For the thumbnail\n\t\tm = vec2(0.5);\n\tuv.x -= iResolution.x / iResolution.y / 4.0;\n\tmat3 r, rx, ry;\n\t\n\tfloat sx, cx, sy, cy;\n\t\n\tsx = sin(m.x);\n\tsy = sin(m.y);\n\tcx = cos(m.x);\n\tcy = cos(m.y);\n\t\n\try = mat3(\n\t\t\tcx,\t0,\tsx,\n\t\t\t0,\t1,\t0,\n\t\t\t-sx,0,\tcx);\n\t\t\n\trx = mat3(\n\t\t\t1,\t0,\t0,\n\t\t\t0,\tcy,\t-sy,\n\t\t\t0,\tsy,\tcy);\n\tr = rx * ry;\n\t\n\tvec3 d = cam(uv)*r;\n\tfragColor = render(vec3(0.), d);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdfGzj","date":"1374227642","viewed":271,"name":"Flying Spheres","username":"martin_shirokov","description":"Use mouse to look around!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","reflection","colorful","color","cubemapping","mirror","metal","silver","dragtolook"],"hasliked":0,"parentid":"","parentname":""}}