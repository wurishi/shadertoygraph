{"ver":"0.1","info":{"id":"td33Rj","date":"1569020785","viewed":574,"name":"fractal noise","username":"Nazlbit","description":"fractal_noise, value_noise, perlin_noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi2 = radians(360.);\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n\nvec2 random_unit_vector(vec2 uv)\n{\n    float theta = random(uv)*pi2;    \n    return vec2(cos(theta), sin(theta));\n}\n\n\nvec3 random_unit_vector(vec3 uv)\n{\n    const vec3 offset = vec3(531.2346,652.56,567.3);\n    \n    float theta = random(uv)*pi2;\n    float phi = acos(1. - 2. * random(uv+offset));\n    vec3 unit_vec;\n    unit_vec.x = sin(phi) * cos(theta);\n    unit_vec.y = sin(phi) * sin(theta);\n    unit_vec.z = cos(phi);\n    \n    return unit_vec;\n}\n\nvec2 smooth_func(vec2 x)\n{\n    return x*x*x*((6.*x - 15.)*x + 10.);\n}\n\nvec3 smooth_func(vec3 x)\n{\n    return x*x*x*((6.*x - 15.)*x + 10.);\n}\n\nfloat value_noise(vec2 uv)\n{\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n    \n    float lb = random(id);\n    float rb = random(id + vec2(1., 0.));\n    float lt = random(id + vec2(0., 1.));\n\tfloat rt = random(id + vec2(1., 1.));\n\n    return mix(mix(lb, rb, lv.x), mix(lt, rt, lv.x), lv.y);\n}\n\nfloat value_noise(vec3 uv)\n{\n    vec3 lv = smoothstep(0., 1., fract(uv));\n    vec3 id = floor(uv);\n    \n    float lbf = random(id);\n    float rbf = random(id + vec3(1., 0., 0.));\n    float ltf = random(id + vec3(0., 1., 0.));\n\tfloat rtf = random(id + vec3(1., 1., 0.));\n    \n    float lbb = random(id + vec3(0., 0., 1.));\n    float rbb = random(id + vec3(1., 0., 1.));\n    float ltb = random(id + vec3(0., 1., 1.));\n\tfloat rtb = random(id + vec3(1., 1., 1.));\n\t\n    float front = mix(mix(lbf, rbf, lv.x), mix(ltf, rtf, lv.x), lv.y);\n    float back = mix(mix(lbb, rbb, lv.x), mix(ltb, rtb, lv.x), lv.y);\n    return mix(front, back, lv.z);\n}\n\nfloat perlin_noise(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    vec2 lb, rb, lt, rt;\n    \n    lb = random_unit_vector(id);\n    rb = random_unit_vector(id + vec2(1., 0.));\n    lt = random_unit_vector(id + vec2(0., 1.));\n    rt = random_unit_vector(id + vec2(1., 1.));\n    \n    float dlb = dot(lb, lv);\n\tfloat drb = dot(rb, lv - vec2(1., 0.));\n    float dlt = dot(lt, lv - vec2(0., 1.));\n    float drt = dot(rt, lv - vec2(1., 1.));\n\n    lv = smooth_func(lv);\n\n    return mix(mix(dlb, drb, lv.x), mix(dlt, drt, lv.x), lv.y)*1.41421356*0.5+0.5;\n}\n\nfloat perlin_noise(vec3 uv)\n{\n    vec3 lv = fract(uv);\n    vec3 id = floor(uv);\n    \n    vec3 lbf, rbf, ltf, rtf, lbb, rbb, ltb, rtb;\n\n    lbf = random_unit_vector(id);\n    rbf = random_unit_vector(id + vec3(1., 0., 0.));\n    ltf = random_unit_vector(id + vec3(0., 1., 0.));\n    rtf = random_unit_vector(id + vec3(1., 1., 0.));\n    lbb = random_unit_vector(id + vec3(0., 0., 1.));\n    rbb = random_unit_vector(id + vec3(1., 0., 1.));\n    ltb = random_unit_vector(id + vec3(0., 1., 1.));\n    rtb = random_unit_vector(id + vec3(1., 1., 1.));\n    \n    float dlbf = dot(lbf, lv);\n\tfloat drbf = dot(rbf, lv - vec3(1., 0., 0.));\n    float dltf = dot(ltf, lv - vec3(0., 1., 0.));\n    float drtf = dot(rtf, lv - vec3(1., 1., 0.));\n    \n    float dlbb = dot(lbb, lv - vec3(0., 0., 1.));\n\tfloat drbb = dot(rbb, lv - vec3(1., 0., 1.));\n    float dltb = dot(ltb, lv - vec3(0., 1., 1.));\n    float drtb = dot(rtb, lv - vec3(1., 1., 1.));\n    \n    lv = smooth_func(lv);\n    \n    float f = mix(mix(dlbf, drbf, lv.x), mix(dltf, drtf, lv.x), lv.y);\n    float b = mix(mix(dlbb, drbb, lv.x), mix(dltb, drtb, lv.x), lv.y);\n\n    return mix(f, b, lv.z)*1.154700538*0.5+0.5;\n}\n\nfloat fractal_noise(vec2 uv, float octaves)\n{\n    float c = 0.;\n    float s = 0.;\n    for(float i = 0.; i < octaves; i++)\n    {\n        float a = pow(2., i);\n        float b = 1. / a;\n        c += perlin_noise(uv*a)*b;\n        s += b;\n    }\n    \n    return c / s;\n}\n\nfloat fractal_noise(vec3 uv, float octaves)\n{\n    float c = 0.;\n    float s = 0.;\n    for(float i = 0.; i < octaves; i++)\n    {\n        float a = pow(2., i);\n        float b = 1. / a;\n        c += perlin_noise(uv*a)*b;\n        s += b;\n    }\n    \n    return c / s;\n}\n\nfloat noise(vec2 uv)\n{\n    return fractal_noise(vec3(uv, iTime*0.2), 3.);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.y);\n    \n\tfragColor = vec4(hsv2rgb(vec3(noise(uv)*10., 1., 1.)), 1.);\n}","name":"Image","description":"","type":"image"}]}