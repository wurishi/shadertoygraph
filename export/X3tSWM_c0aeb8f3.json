{"ver":"0.1","info":{"id":"X3tSWM","date":"1719133737","viewed":19,"name":"BasicRayMarching","username":"dabingnn","description":"simple ray marching tut","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\nvec3 lighting(vec3 p, vec3 n)\n{\n    vec3 LightDir = normalize(vec3(-0.3, 1., -0.8));\n    vec3 LightCol = vec3(.5);\n    return LightCol * clamp(dot(LightDir, n), 0., 1.);\n}\n\nfloat getDist(vec3 p, out vec3 normal)\n{\n    vec4 Sphere = vec4(0.0, 2.0, 8.0, 2.0);\n    float sphereDist = length(p - Sphere.xyz) - Sphere.w;\n    float planeDist = p.y;\n    normal = vec3(0.0, 1.0, 0.0);\n    if(sphereDist < planeDist)\n    {\n        normal = normalize(p - Sphere.xyz);\n        return sphereDist;\n    }\n    else\n    {\n        return planeDist;\n    }\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 normal)\n{\n    float dO = 0.0f;\n    for(int i= 0; ; ++i)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = getDist(p, normal);\n        dO += ds;\n        if(ds < SURF_DIST) break;\n        if(dO > MAX_DIST || i == MAX_STEPS)\n        {\n            dO = -1.;\n            break;\n        }\n    }\n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0., 1., 0.);\n    vec3 rd = normalize(vec3(uv.x ,uv.y, 1));\n    vec3 normal = vec3(0, 0, 0);\n    float dO = rayMarch(ro, rd, normal);\n    vec3 col = vec3(0., 0.0, 0.0);\n    if(dO > 0.)\n    {\n        col = lighting(ro + rd * dO, normal);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}