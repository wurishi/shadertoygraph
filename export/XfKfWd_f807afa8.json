{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Github:  https://github.com/blurbusters/crt-beam-simulator/\n// Article: https://www.blurbusters.com/crt\n\n// FIX PROBLEMS / FLICKER / BANDING: https://github.com/blurbusters/crt-beam-simulator/issues/4\n// New version coming January 2025 with additional settings\n// Please star and monitor the github\n\n/*********************************************************************************************************************/\n//\n//                     Blur Busters CRT Beam Simulator BFI\n//                       With Seamless Gamma Correction\n//\n//         From Blur Busters Area 51 Display Science, Research & Engineering\n//                      https://www.blurbusters.com/area51\n//\n//             The World's First Realtime Blur-Reducing CRT Simulator\n//       Best for 60fps on 240-480Hz+ Displays, Still Works on 120Hz+ Displays\n//                 Original Version 2022. Publicly Released 2024.\n//\n// CREDIT: Teamwork of Mark Rejhon @BlurBusters & Timothy Lottes @NOTimothyLottes\n// Gamma corrected CRT simulator in a shader using clever formula-by-scanline trick\n// (easily can generate LUTs, for other workflows like FPGAs or Javascript)\n// - @NOTimothyLottes provided the algorithm for per-pixel BFI (Variable MPRT, higher MPRT for bright pixels)\n// - @BlurBusters provided the algorithm for the CRT electron beam (2022, publicly released for first time)\n//\n// Contact Blur Busters for help integrating this in your product (emulator, fpga, filter, display firmware, video processor)\n//\n// This new algorithm has multiple breakthroughs:\n//\n// - Seamless; no banding*!  (*Monitor/OS configuration: SDR=on, HDR=off, ABL=off, APL=off, gamma=2.4)\n// - Phosphor fadebehind simulation in rolling scan.\n// - Works on LCDs and OLEDs.\n// - Variable per-pixel MPRT. Spreads brighter pixels over more refresh cycles than dimmer pixels.\n// - No image retention on LCDs or OLEDs.\n// - No integer divisor requirement. Recommended but not necessary (e.g. 60fps 144Hz works!)\n// - Gain adjustment (less motion blur at lower gain values, by trading off brightness)\n// - Realtime (for retro & emulator uses) and slo-mo modes (educational)\n// - Great for softer 60Hz motion blur reduction, less eyestrain than classic 60Hz BFI/strobe.\n// - Algorithm can be ported to shader and/or emulator and/or FPGA and/or display firmware.\n//\n// For best real time CRT realism:\n//\n// - Reasonably fast performing GPU (many integrated GPUs are unable to keep up)\n// - Fastest GtG pixel response (A settings-modified OLED looks good with this algorithm)\n// - As much Hz per CRT Hz! (960Hz better than 480Hz better than 240Hz)\n// - Integer divisors are still better (just not mandatory)\n// - Brightest SDR display with linear response (no ABL, no APL), as HDR boost adds banding\n//     (unless you can modify the firmware to make it linear brightness during a rolling scan)\n//\n// *** IMPORTANT ***\n// *** DISPLAY REQUIREMENTS ***\n//\n// - Best for gaming LCD or OLED monitors with fast pixel response.\n// - More Hz per simulated CRT Hz is better (240Hz, 480Hz simulates 60Hz tubes more accurately than 120Hz).\n// - OLED (SDR mode) looks better than LCD, but still works on LCD\n// - May have minor banding with very slow GtG, asymmetric-GtG (VA LCDs), or excessively-overdriven.\n// - Designed for sample & hold displays with excess refresh rate (LCDs and OLEDs);\n//     Not intended for use with strobed or impulsed displays. Please turn off your displays' BFI/strobing.\n//     This is because we need 100% software control of the flicker algorithm to simulate a CRT beam.\n//\n// SDR MODE RECOMMENDED FOR NOW (Due to predictable gamma compensation math)\n//\n// - Best results occur on display configured to standard SDR gamma curve and ABL/APL disabled to go 100% bandfree\n// - Please set your display gamma to 2.2 or 2.4, turn off ABL/APL in display settings, and set your OLED to SDR mode.  \n// - Will NOT work well with some FALD and MiniLED due to backlight lagbehind effects.\n// - Need future API access to OLED ABL/ABL algorithm to compensate for OLED ABL/APL windowing interference with algorithm.\n// - This code is heavily commented because of the complexity of the algorithm.\n//\n/*********************************************************************************************************************/\n//\n// MIT License\n// \n// Copyright 2024 Mark Rejhon (@BlurBusters) & Timothy Lottes (@NOTimothyLottes)\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the “Software”), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n/*********************************************************************************************************************/\n\n//------------------------------------------------------------------------------------------------\n// Constants Definitions\n\n// Play with the documented constants:\n// - REALTIME: Use FRAMES_PER_HZ=4 for 240Hz and FRAMES_PER_HZ=8 for 480Hz, to simulate a 60Hz tube in realtime\n// - SLOMO: Use crazy large FRAMES_PER_HZ numbers to watch a CRT tube like a slo-motion video. Try FRAMES_PER_HZ=100!\n// - FRAMESTEP: Use low frame rates to inspect frames.  Try FRAMES_PER_HZ=8 and FPS_DIVISOR=0.02! \n// All are floats (keep a .0 for integers)\n\n#define MOTION_SPEED    10.0\n\n  // Ratio of native Hz per CRT Hz.  More native Hz per CRT Hz simulates CRT butter.\n  //   - Use 4.0 for 60fps at 240Hz realtime.\n  //   - Use 2.4 for 60fps at 144Hz realtime.\n  //   - Use 2.75 for 60fps at 165Hz realtime.\n  //   - Use ~100 for super-slo-motion.\n  //   - Best to keep it integer divisor but not essential (works!)\n#define FRAMES_PER_HZ   4.0     // For 240 Hz\n\n  // Your display's gamma value. Necessary to prevent horizontal-bands artifacts.\n#define GAMMA           2.4\n\n  // Brightness-vs-motionblur tradeoff for bright pixel.\n  //   - Defacto simulates fast/slow phosphor. \n  //   - 1.0 is unchanged brightness (same as non-CRT, but no blur reduction for brightest pixels, only for dimmer piels).\n  //   - 0.5 is half brightness spread over fewer frames (creates lower MPRT persistence for darker pixels).\n  //   - ~0.7 recommended for 240Hz+, ~0.5 recommended for 120Hz due to limited inHz:outHz ratio.\n#define GAIN_VS_BLUR    0.7\n\n  // Splitscreen versus mode for comparing to non-CRT-simulated\n#define SPLITSCREEN     1        // 1 to enable splitscreen to compare to non-CRT, 0 to disable splitscreen\n#define SPLITSCREEN_X   0.50     // For user to compare; horizontal splitscreen percentage (0=verticals off, 0.5=left half, 1=full sim).\n#define SPLITSCREEN_Y   0.00     // For user to compare; vertical splitscreen percentage (0=horizontal off, 0.5=bottom half, 1=full sim).\n#define SPLITSCREEN_BORDER_PX 2  // Splitscreen border thickness in pixels\n#define SPLITSCREEN_MATCH_BRIGHTNESS 1    // 1 to match brightness of CRT, 0 for original brightness of original frame\n\n  // Reduced frame rate mode\n  //   - This can be helpful to see individual CRT-simulated frames better (educational!)\n  //   - 1.0 is framerate=Hz, 0.5 is framerate being half of Hz, 0.1 is framerate being 10% of real Hz.\n#define FPS_DIVISOR     1.0    // Slow down or speed up the simulation\n\n  // LCD SAVER SYSTEM\n  //   - Prevents image retention from BFI interfering with LCD voltage polarity inversion algorithm\n  //   - When LCD_ANTI_RETENTION is enabled:\n  //     - Automatically prevents FRAMES_PER_HZ from remaining an even integer by conditionally adding a slew float.\n  //     - FRAMES_PER_HZ 2 becomes 2.001, 4 becomes 4.001, and 6 becomes 6.001, etc.  \n  //     - Scientific Reason: https://forums.blurbusters.com/viewtopic.php?t=7539 BFI interaction with LCD voltage polarity inversion \n  //     - Known Side effect: You've decoupled the CRT simulators' own VSYNC from the real displays' VSYNC.  But magically, there's no tearing artifacts :-)\n  //     - Not needed for OLEDs, safe to turn off, but should be ON by default to be foolproof.\n#define LCD_ANTI_RETENTION  true\n#define LCD_INVERSION_COMPENSATION_SLEW 0.001\n\n  // CRT SCAN DIRECTION. Can be useful to counteract an OS rotation of your display\n  //   - 1 default (top to bottom), recommended\n  //   - 2 reverse (bottom to top)\n  //   - 3 portrait (left to right)\n  //   - 4 reverse portrait (right to left)\n#define SCAN_DIRECTION 1\n\n//-------------------------------------------------------------------------------------------------\n// Utility Macros\n\n#define clampPixel(a) clamp(a, vec3(0.0), vec3(1.0))\n\n// Selection Function: Returns 'b' if 'p' is true, else 'a'.\nfloat SelF1(float a, float b, bool p) { return p ? b : a; }\n\n#define IS_INTEGER(x) (floor(x) == x)\n#define IS_EVEN_INTEGER(x) (IS_INTEGER(x) && IS_INTEGER(x/2.0))\n\n// LCD SAVER (prevent image retention)\n// Adds a slew to FRAMES_PER_HZ when ANTI_RETENTION is enabled and FRAMES_PER_HZ is an exact even integer.\n// We support non-integer FRAMES_PER_HZ, so this is a magically convenient solution\n// This is likely best done at the high level\nconst float EFFECTIVE_FRAMES_PER_HZ = (LCD_ANTI_RETENTION && IS_EVEN_INTEGER(float(FRAMES_PER_HZ))) \n                                      ? float(FRAMES_PER_HZ) + LCD_INVERSION_COMPENSATION_SLEW \n                                      : float(FRAMES_PER_HZ);\n                                      \n//-------------------------------------------------------------------------------------------------\n// sRGB Encoding and Decoding Functions, to gamma correct/uncorrect\n\n// Encode linear color to sRGB. (applies gamma curve)\nfloat linear2srgb(float c){\n    vec3 j = vec3(0.0031308 * 12.92, 12.92, 1.0 / GAMMA);\n    vec2 k = vec2(1.055, -0.055);\n    return clamp(j.x, c * j.y, pow(c, j.z) * k.x + k.y);\n}\nvec3 linear2srgb(vec3 c){\n  return vec3(linear2srgb(c.r), linear2srgb(c.g), linear2srgb(c.b));\n}\n\n// Decode sRGB color to linear. (undoes gamma curve)\nfloat srgb2linear(float c){\n    vec3 j = vec3(0.04045, 1.0 / 12.92, GAMMA);\n    vec2 k = vec2(1.0 / 1.055, 0.055 / 1.055);\n    return SelF1(c * j.y, pow(c * k.x + k.y, j.z), c > j.x);\n}\nvec3 srgb2linear(vec3 c){\n  return vec3(srgb2linear(c.r), srgb2linear(c.g), srgb2linear(c.b));\n}\n\n//------------------------------------------------------------------------------------------------\n// Gets pixel from the unprocessed framebuffer.\n//\n// Placeholder for accessing the 3 trailing unprocessed frames (for simulating CRT on)\n//   - Frame counter represents simulated CRT refresh cycle number.\n//   - Always assign numbers to your refresh cycles. For reliability, keep a 3 frame trailing buffer.\n//   - We index by frame counter because it is necessary for blending adjacent CRT refresh cycles, \n//      for the phosphor fade algorithm on old frame at bottom, and new frames at top.\n//   - Framebuffer to retrieve from should be unscaled (e.g. original game resolution or emulator resolution).\n//   - (If you do optional additional processing such as scaling+scanlines+masks, do it post-processing after this stage)\n// DEMO version:\n//   - We cheat by horizontally shifting shifted pixel reads from a texture.\n// PRODUCTION version:\n//   - Put your own code to retrieve a pixel from your series of unprocessed frame buffers.\n//     IMPORTANT: For integration into firmware/software/emulators/games, this must be executed \n//     at refresh cycle granularity independently of your underlying games' framerate! \n//     There are three independent frequencies involved:\n//     - Native Hz (your actual physical display)\n//     - Simulated CRT Hz (Hz of simulated CRT tube)\n//     - Underlying content frame rate (this shader doesn't need to know; TODO: Unless you plan to simulate VRR-CRT)\n//\nvec3 getPixelFromOrigFrame(vec2 uv, float getFromHzNumber, float currentHzCounter)\n{\n\n    // We simulate missing framebuffers (for accurate real world case)\n    if ((getFromHzNumber > currentHzCounter) ||          // Frame not rendered yet\n        (getFromHzNumber < currentHzCounter - 2.0)) {    // Frame over 3 frames ago\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // Continuous horizontal shift depending on hzCounter\n    float shiftAmount = MOTION_SPEED / 1000.0;\n    float baseShift = fract(getFromHzNumber * shiftAmount);\n\n    // We'll offset uv.x by baseShift, and round-off to screen coordinates to avoid seam artifacts\n    float px = 1.0 / iResolution.x;\n    uv.x = mod(uv.x + baseShift + px*0.1, 1.0) - px*0.1;\n\n    // Sample texture with no mip (textureLod)\n    vec4 c = textureLod(iChannel0, uv, 0.0);\n    return c.rgb;\n}\n\n//-------------------------------------------------------------------------------------------------\n// CRT Rolling Scan Simulation With Phosphor Fade + Brightness Redistributor Algorithm\n//\n// New variable 'per-pixel MPRT' algorithm that mimics CRT phosphor decay too.\n// - We emit as many photons as possible as early as possible, and if we can't emit it all (e.g. RGB 255)\n//   then we continue emitting in the next refresh cycle until we've hit our target (gamma-compensated).\n// - This is a clever trick to keep CRT simulation brighter but still benefit motion clarity of most colors.\n//   Besides, real CRT tubes behave roughly similar too! (overexcited phosphor take longer to decay)\n// - This also concurrently produces a phosphor-fade style behavior.\n// - Win-win!\n//\n// Parameters:\n// - c2: total brightness * framesPerHz per channel.\n// - crtRasterPos: normalized raster position [0..1] representing current scan line\n// - phaseOffset: fractional start of the brightness interval [0..1] (0.0 at top, 1.0 at bottom).\n// - framesPerHz: Number of frames per Hz. (Does not have to be integer divisible!)\n//\nvec3 getPixelFromSimulatedCRT(vec2 uv, float crtRasterPos, float crtHzCounter, float framesPerHz)\n{\n    // Get pixels from three consecutive refresh cycles\n    vec3 pixelPrev2 = srgb2linear(getPixelFromOrigFrame(uv, crtHzCounter - 2.0, crtHzCounter));\n    vec3 pixelPrev1 = srgb2linear(getPixelFromOrigFrame(uv, crtHzCounter - 1.0, crtHzCounter));\n    vec3 pixelCurr  = srgb2linear(getPixelFromOrigFrame(uv, crtHzCounter,      crtHzCounter));\n\n    vec3 result = vec3(0.0);\n\n    // Compute \"photon budgets\" for all three cycles\n    float brightnessScale = framesPerHz * GAIN_VS_BLUR;\n    vec3 colorPrev2 = pixelPrev2 * brightnessScale;\n    vec3 colorPrev1 = pixelPrev1 * brightnessScale;\n    vec3 colorCurr  = pixelCurr  * brightnessScale;\n      \n#if SCAN_DIRECTION == 1\n    float tubePos = (1.0 - uv.y);  // Top to bottom\n#elif SCAN_DIRECTION == 2\n    float tubePos = uv.y;          // Bottom to top\n#elif SCAN_DIRECTION == 3\n    float tubePos = uv.x;          // Left to right\n#elif SCAN_DIRECTION == 4\n    float tubePos = (1.0 - uv.x);  // Right to left\n#endif\n\n    // Process each color channel independently\n    for (int ch = 0; ch < 3; ch++) \n    {\n        // Get brightness lengths for all three cycles\n        float Lprev2 = colorPrev2[ch];\n        float Lprev1 = colorPrev1[ch];\n        float Lcurr  = colorCurr[ch];\n        \n        if (Lprev2 <= 0.0 && Lprev1 <= 0.0 && Lcurr <= 0.0) {\n            result[ch] = 0.0;\n            continue;\n        }\n        \n        // TODO: Optimize to use only 2 frames.\n        // Unfortunately I need all 3 right now because if I only do 2,\n        // I get artifacts at either top OR bottom edge (can't eliminate both)\n        // What I may do is use a phase offset (e.g. input framebuffer chain\n        // rotates forward in middle of emulated CRT Hz), as a workaround, and\n        // see if that solves the problem and reduces the queue to 2.\n        // (Will attempt later)\n\n        // Convert normalized values to frame space\n        float tubeFrame = tubePos * framesPerHz;\n        float fStart = crtRasterPos * framesPerHz;\n        float fEnd = fStart + 1.0;\n\n        // Define intervals for all three trailing refresh cycles\n        float startPrev2 = tubeFrame - framesPerHz;\n        float endPrev2   = startPrev2 + Lprev2;\n\n        float startPrev1 = tubeFrame;\n        float endPrev1   = startPrev1 + Lprev1;\n\n        float startCurr  = tubeFrame + framesPerHz; // Fix seam for top edge\n        float endCurr    = startCurr + Lcurr;\n        \n        // Calculate overlaps for all three cycles\n        #define INTERVAL_OVERLAP(Astart, Aend, Bstart, Bend) max(0.0, min(Aend, Bend) - max(Astart, Bstart))\n        float overlapPrev2 = INTERVAL_OVERLAP(startPrev2, endPrev2, fStart, fEnd);\n        float overlapPrev1 = INTERVAL_OVERLAP(startPrev1, endPrev1, fStart, fEnd);\n        float overlapCurr  = INTERVAL_OVERLAP(startCurr,  endCurr,  fStart, fEnd);\n\n        // Sum all overlaps for final brightness\n        result[ch] = overlapPrev2 + overlapPrev1 + overlapCurr;\n    }\n\n    return linear2srgb(result);\n}\n\n//-------------------------------------------------------------------------------------------------\n// Main Image Function\n//\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // LCD SAVER (prevent image retention)\n    // Adds a slew to FRAMES_PER_HZ when ANTI_RETENTION is enabled and FRAMES_PER_HZ is an exact even integer.\n    // We support non-integer FRAMES_PER_HZ, so this is a magically convenient solution\n    // This may be best done at the high level (software) rather than shader level (here)\n    // But we do this here, just for safety's sake (see https://forums.blurbusters.com/viewtopic.php?t=7539 )\n    float EFFECTIVE_FRAMES_PER_HZ = (LCD_ANTI_RETENTION && IS_EVEN_INTEGER(FRAMES_PER_HZ)) \n                                     ? FRAMES_PER_HZ + LCD_INVERSION_COMPENSATION_SLEW \n                                     : FRAMES_PER_HZ;\n                    \n    // Automatically use slo-mo mode for 60Hz visitors (useless at under ~100Hz)\n    if (EFFECTIVE_FRAMES_PER_HZ < 2.0) EFFECTIVE_FRAMES_PER_HZ = 100.0;\n\n    // uv: Normalized coordinates ranging from (0,0) at the bottom-left to (1,1) at the top-right.\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 c = vec4(0.0, 0.0, 0.0, 1.0);\n\n    //-------------------------------------------------------------------------------------------------\n    // CRT beam calculations\n    \n    // Frame counter, which may be compensated by slo-mo modes (FPS_DIVISOR). Does not need to be integer divisible.\n    float effectiveFrame = floor(float(iFrame) * FPS_DIVISOR);\n\n    // Normalized raster position [0..1] representing current position of simulated CRT electron beam\n    float crtRasterPos = mod(effectiveFrame, EFFECTIVE_FRAMES_PER_HZ) / EFFECTIVE_FRAMES_PER_HZ;\n\n    // CRT refresh cycle counter\n    float crtHzCounter = floor(effectiveFrame / EFFECTIVE_FRAMES_PER_HZ);\n\n#if SPLITSCREEN == 1\n    //-------------------------------------------------------------------------------------------------\n    // Splitscreen processing\n\n    // crtTube: Boolean indicating whether the current pixel is within the CRT-BFI region.\n    // When splitscreen is off, apply CRT-BFI to entire screen\n    bool crtArea = !((uv.x > SPLITSCREEN_X) && (uv.y > SPLITSCREEN_Y));\n\n    // Calculate border regions (in pixels)\n    float borderXpx = abs(fragCoord.x - SPLITSCREEN_X * iResolution.x);\n    float borderYpx = abs(fragCoord.y - SPLITSCREEN_Y * iResolution.y);\n    \n    // Border only exists in the non-BFI region (x > SPLITSCREEN_X || y > SPLITSCREEN_Y)\n    bool inBorderX = borderXpx < float(SPLITSCREEN_BORDER_PX) && uv.y > SPLITSCREEN_Y;\n    bool inBorderY = borderYpx < float(SPLITSCREEN_BORDER_PX) && uv.x > SPLITSCREEN_X;\n    bool inBorder = (SPLITSCREEN == 1) && (inBorderX || inBorderY);\n\n    // We #ifdef the if statement away for shader efficiency (though this specific one didn't affect performance)\n    if (crtArea) {\n#endif\n\n        //-----------------------------------------------------------------------------------------\n        // Get CRT simulated version of pixel\n        fragColor.rgb = getPixelFromSimulatedCRT(uv, crtRasterPos, crtHzCounter, EFFECTIVE_FRAMES_PER_HZ);\n\n#if SPLITSCREEN == 1\n    }\n    else if (!inBorder) {\n        fragColor.rgb = getPixelFromOrigFrame(uv, crtHzCounter, crtHzCounter);\n#if SPLITSCREEN_MATCH_BRIGHTNESS == 1\n        // Brightness compensation for unprocessed pixels through similar gamma-curve (match gamma of simulated CRT)\n        fragColor.rgb = srgb2linear(fragColor.rgb) * GAIN_VS_BLUR;\n        fragColor.rgb = clampPixel(linear2srgb(fragColor.rgb));\n#endif\n    }\n#endif\n}\n\n//-------------------------------------------------------------------------------------------------\n// Please credit MARK REJHON (BLUR BUSTERS) & TIMOTHY LOTTE if this algorithm is used in your project/product.\n// Hundreds of hours of research was done on related work that led to this algorithm.\n//-------------------------------------------------------------------------------------------------\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfKfWd","date":"1734588981","viewed":30372,"name":"CRT Beam Simulator (60fps 240Hz)","username":"BlurBusters","description":"CRT electron beam simulator, with realtime & slomo modes. This version is configured for 240Hz screens.\n- Uses @BlurBusters CRT Simulator algorithm\n- Uses @NOTimontyLottes Pixel variable black frame interpolation","likes":21,"published":3,"flags":0,"usePreview":1,"tags":["crtsimulator"],"hasliked":0,"parentid":"4fVBWd","parentname":"Fork LottesPVBF blurbuster 155"}}