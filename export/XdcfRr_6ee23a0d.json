{"ver":"0.1","info":{"id":"XdcfRr","date":"1523899924","viewed":494,"name":" GLSL smallpt progressive","username":"fjavifabre","description":"Progressive version of https://www.shadertoy.com/view/4sfGDB just for fun.\n\nUsing 2 buffer accumulation as shown in https://www.shadertoy.com/view/MsXfz4","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","reflection","refraction","globalillumination","pathtracing","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Display : average down and do gamma adjustment\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    \n    // color grading and vigneting\n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\nBased on https://www.shadertoy.com/view/4sfGDB\n\nImprovement in lines 163-183\n*/\n\n// Play with the two following values to change quality.\n// You want as many samples as your GPU can bear. :)\n#define SAMPLES 11\n#define MAXDEPTH 4\n#define ENABLE_NEXT_EVENT_PREDICTION\n\n// Uncomment to see how many samples never reach a light source\n//#define DEBUG\n\n// Not used for now\n#define DEPTH_RUSSIAN 2\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define NUM_SPHERES 9\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n};\n\nSphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), DIFF);\n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF);\n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF);\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC);\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR);\n\tspheres[8] = Sphere(600., vec3(50., 681.33, 81.6),\tvec3(12.), vec3(0.), DIFF);\n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id = intersect(r, t, obj, id)) < 0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d));\n\n\t\t//vec3 f = obj.c;\n\t\t//float p = dot(f, vec3(1.2126, 0.7152, 0.0722));\n\t\t//if (depth > DEPTH_RUSSIAN || p == 0.) if (rand() < p) f /= p; else { acc += mask * obj.e * E; break; }\n\n\t\tif (obj.refl == DIFF) {\n\t\t\tfloat r2 = rand();\n\t\t\tvec3 d = jitter(nl, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = vec3(0.);\n#ifdef ENABLE_NEXT_EVENT_PREDICTION\n\t\t\t//for (int i = 0; i < NUM_SPHERES; ++i)\n\t\t\t{\n\t\t\t\t// Sphere s = sphere(i);\n\t\t\t\t// if (dot(s.e, vec3(1.)) == 0.) continue;\n\n\t\t\t\t// Normally we would loop over the light sources and\n\t\t\t\t// cast rays toward them, but since there is only one\n\t\t\t\t// light source, that is mostly occluded, here goes\n\t\t\t\t// the ad hoc optimization:\n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 8;\n\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n\n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\te += (s.e * clamp(dot(l, n),0.,1.) * omega) / PI;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tfloat E = 1.;//float(depth==0);\n\t\t\tacc += mask * obj.e * E + mask * obj.c * e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, d);\n\t\t} else if (obj.refl == SPEC) {\n\t\t\tacc += mask * obj.e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t} else {\n\t\t\tfloat a=dot(n,r.d), ddn=abs(a);\n\t\t\tfloat nc=1., nt=1.5, nnt=mix(nc/nt, nt/nc, float(a>0.));\n\t\t\tfloat cos2t=1.-nnt*nnt*(1.-ddn*ddn);\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t\tif (cos2t>0.) {\n\t\t\t\tvec3 tdir = normalize(r.d*nnt + sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n\t\t\t\tfloat R0=(nt-nc)*(nt-nc)/((nt+nc)*(nt+nc)),\n\t\t\t\t\tc = 1.-mix(ddn,dot(tdir, n),float(a>0.));\n\t\t\t\tfloat Re=R0+(1.-R0)*c*c*c*c*c,P=.25+.5*Re,RP=Re/P,TP=(1.-Re)/(1.-P);\n\t\t\t\tif (rand()<P) { mask *= RP; }\n\t\t\t\telse { mask *= obj.c*TP; r = Ray(x, tdir); }\n\t\t\t}\n\t\t}\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinitSpheres();\n\tseed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec3 camPos = vec3((2. * (iMouse.xy==vec2(0.)?.5*iResolution.xy:iMouse.xy) / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), 169.);\n\tvec3 cz = normalize(vec3(50., 40., 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n\tvec3 color = vec3(0.);\n\tfor (int i = 0; i < SAMPLES; ++i)\n    {\n#ifdef DEBUG\n        vec3 test = radiance(Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n        if (dot(test, test) > 0.) color += vec3(1.); else color += vec3(0.5,0.,0.1);\n#else\n\t\tcolor += radiance(Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n#endif\n    }\n\n\tcolor /= vec3(SAMPLES);\n    vec3 col_acc = vec3(0);\n    vec2 coord = floor(fragCoord.xy);\n    if(all(equal(coord.xy,vec2(0)))) {\n        if( iMouse.z > 0.0 ) {\n            col_acc = vec3(iFrame);\n        } else {\n            col_acc = texture( iChannel0, vec2(0.5, 0.5)/iResolution.xy ).xyz;\n        }\n    } else {\n        if(iFrame == 0) {\n            col_acc = color;\n        } else {\n            int frame_start = int(texture( iChannel0, vec2(0.5, 0.5) / iResolution.xy ).x);\n            int spp1 = iFrame - frame_start;\n            int spp2 = 1;\n            vec3 col_new = color;\n            col_acc = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n            col_acc = mix(col_acc, col_new, float(spp2)/float(spp1+spp2));\n        }\n    }\n    fragColor = vec4(col_acc , 1.0 );\n}\n","name":"Buf A","description":"","type":"buffer"}]}