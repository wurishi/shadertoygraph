{"ver":"0.1","info":{"id":"dtsSWX","date":"1675437662","viewed":64,"name":"Pauvert_Solveig_GLSL_Partiel_2/2","username":"prabou","description":"shader2","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shader2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float opUnion(float d1, float d2) {\n    return min(d1,d2);\n}\nfloat opSubstraction(float d1, float d2) {\n    return max(-d1,d2);\n}\n\nfloat sdSphere(vec3 p, float s){\n    return length(p)-s;\n}\nfloat sdTorus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat sdBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//\nvec3 opRep( in vec3 p, in vec3 c ){\n    return mod(p+0.5*c,c)-0.5*c;\n}\n//\nfloat map(vec3 pos){\n    float v = 0.0;\n    pos = opRep(pos+vec3(-3.,.0,3.0), vec3(4.0,-3.0,-3.0));\n    \n    float sphere = sdSphere(pos, 2.0);    \n    float torus = sdTorus(pos, vec2(2.0,1.0));\n    float Tige = sdBox(pos+vec3(0.0,-3.0,0.0), vec3(.1,3.,.1));\n    float volume = opUnion(torus, sphere);\n  \n    \n    v = opSubstraction(torus, sphere);\n    v = opUnion(Tige, v);\n    return v;\n    \n   \n}\n   \n\n//\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){\n    return a + b*cos(6.28318*(c*t+d));\n}\n\n//\nfloat CastRay(vec3 ro, vec3 rd){\n    float c = 0.0; //contact par d√©faut\n    for(int i=0; i<64 ; i++){\n        float ray = map(ro + rd * c);\n        if(ray < (0.0001 * c)){\n            return float(i)/32. ;\n        }\n        c += ray;\n    }\n    return -1.0;\n}\n\n//\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n    float contact = CastRay(ro, rd); //nous ajouterons le raymarch ici\n    vec3 col = palette(0.5, vec3(0.2,0.8,0.6), vec3(0.4,0.2,0.8), vec3 (0.6,0.1,0.7), vec3(0.2,0.2,0.9));//vec3(0.2,0.4,0.7);\n    \n    vec3 pos = ro * rd + contact;\n    \n    if(contact == -1.0)\n    {\n        col = palette(iTime*0.5, vec3(0.2,0.8,0.6), vec3(0.4,0.2,0.8), vec3 (0.6,0.1,0.7), vec3(0.2,0.2,0.9));//vec3(0.1,0.5,0.6);\n    }\n    else\n    {\n        col = palette(iTime*sin(0.2), vec3(0.2,0.8,0.6), vec3(0.4,0.2,0.8), vec3 (0.6,0.1,0.7), vec3(0.2,0.2,0.9))-contact*0.4;//couleur du volume\n        \n        col += mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(uv.y)) * .5;\n    }\n    \n    return col;\n}  \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPos = vec3(5.0,5.,iTime-5.0);\n    vec3 cameraTar = vec3(0.0);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0,-1.0,0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n      \n\n    // Time varying pixel color\n    vec3 col = render(cameraPos, viewDir, uv);//vec3(uv.x, uv.y,0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}