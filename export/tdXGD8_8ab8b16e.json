{"ver":"0.1","info":{"id":"tdXGD8","date":"1545979761","viewed":257,"name":"Lunacy","username":"slimyfrog","description":"Testing using a texture for displacement","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["texture","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE   10.0\n#define MIN_DISTANCE    0.001\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sphereDf(vec3 p, vec3 spherePos, float radius, out float intensity)\n{\n    vec2 uv = vec2(p.x * 0.6, p.y * 0.75);\n    vec3 texColor = vec3(texture(iChannel0, uv));\n    vec3 texColor2 = vec3(texture(iChannel0, uv * 1.8));\n    \n    intensity = vec3(texture(iChannel0, uv * 0.15)).x * 0.012;\n\n    texColor = texColor * 0.01 + texColor2 * 0.005;\n    float dist =  length(spherePos + p) - radius;\n    dist += length(texColor);\n    return dist;\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sceneDf(vec3 p, out float intensity)\n{\n    //sphere position\n    vec3 spherePosition = vec3(0, 0, 0);\n    float dist = sphereDf(p, spherePosition, 2.0, intensity);\n    return dist;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 calcNormal(vec3 p)\n{\n    float e = 0.001f;\n    \n    vec3 normal;\n    float i;\n    normal.x = sceneDf(vec3(p.x + e,p.y,p.z), i) - sceneDf(vec3(p.x - e, p.y, p.z), i);\n    normal.y = sceneDf(vec3(p.x,p.y + e,p.z), i) - sceneDf(vec3(p.x, p.y - e, p.z), i);\n    normal.z = sceneDf(vec3(p.x,p.y,p.z + e), i) - sceneDf(vec3(p.x, p.y, p.z - e), i);\n    \n    return normalize(normal);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 processLighting(vec3 baseColor, vec3 eyePos, vec3 surfacePoint)\n{\n    vec3 diffuseDir = normalize(vec3(sin(iTime * 0.25),0, cos(iTime * 0.25)));\n    \n    vec3 normal = calcNormal(surfacePoint);\n    float diffDot = max(dot(-diffuseDir, normal), 0.0);\n    return  0.1 + vec3(diffDot) * baseColor;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 marchRay(vec3 eyePos,vec3 dir)\n{\n    vec3 color = vec3(0);\n    vec3 currentPoint = eyePos;\n    while(length(currentPoint) < MAX_DISTANCE)\n    {\n        float intensity;\n        float dist = sceneDf(currentPoint, intensity);\n        if(dist <= MIN_DISTANCE)\n        {\n            color = processLighting(vec3(1.0 - intensity*25.0), eyePos, currentPoint);\n            break;\n        }\n        currentPoint += (dist * dir);\n    }\n    return color;\n}\n\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera\t\n\tvec3 eye = vec3(0.0, 0.0, 6.0 );\n    vec3 lookat = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 forward = normalize( lookat - eye );\n    vec3 right = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 up = normalize( cross(right, forward));\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray\n    vec3 dir = normalize( p.x*right + p.y*up + 2.5*forward );\n       \n    vec3 color = marchRay(eye, dir);\n    \n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}