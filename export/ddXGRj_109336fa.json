{"ver":"0.1","info":{"id":"ddXGRj","date":"1666390000","viewed":68,"name":"Cave / CAFePARTY 2022","username":"jin_x","description":"Quarterfinal of Shader Showdown on CAFePARTY 2022 (21.10.2022)\nWith little modifications","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","shadershowdown","cafe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtBXW1","filepath":"https://soundcloud.com/denis-pokaliuk/ysek?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/denis-pokaliuk/ysek?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846264338327950\n#define EPS .001\n\nfloat time, ray = 0., vol;\nint idx;\n\nmat2 rot(float a)\n{\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat noise(vec2 p)\n{\n  return texture(iChannel0, p).x;\n}\n\nfloat sdf(vec3 p)\n{\n  float s[4];\n  vec3 q = fract(p + .5) - .5;\n  float r = .65 + noise(q.yz)*.05;\n  s[0] = r - length(q);  // walls\n  float snd = pow(texture(iChannel1, vec2(length(q.xz),.25)).x, .75) * vol * 2.;\n  s[1] = p.y + .5 - (sin(time) + noise(q.xz)*(.5+snd)) * .2;  // floor\n  vec3 qq = mod(p + vec3(noise(p.yz), time*100. + noise(p.xz)*3., noise(p.xy))*.02 + .1, .2) - .1;\n  s[2] = length(qq) - .001;  // snow\n  s[3] = length(q.xy) - .01;  // ray\n  idx = 0;\n  for (int i = 1; i < 4; ++i)\n    if (s[i] < s[idx])\n      if (i == 3)\n        if (s[i] < EPS) ray = 1.;\n        else { if (s[i] < s[idx]) return s[i]; }\n      else idx = i;\n  return s[idx];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Initialzation\n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n  uv *= vec2(iResolution.x / iResolution.y, 1) * 2.;\n    \n  time = iTime + noise(uv.yx)*.05;\n  time /= 2.;\n  \n  vol = texture(iChannel1, vec2(.01,.75)).x;\n  \n  // Ray marching\n  vec3 rp = vec3(sin(time*PI/5.)*2.7,-.05,time), rd = normalize(vec3(uv, 1.)), col;\n  rd.xz *= rot(sin(time/2.));\n  rd.xy *= rot(sin(time)/4.);\n  int i;\n  while (++i < 100) {\n    float d = sdf(rp);\n    if (d < EPS) break;\n    rp += d*rd;\n  }\n\n  // Output to screen \n  float br = clamp(pow(6./float(i), 2.), 0., 1.);\n  float v = vol*sin(time*.7)*1.;\n  vec3 c[] = vec3[](vec3(0,ray*8.+.2,1.-ray), vec3(1,v,-v), vec3(.5));\n  col = br * (c[idx]);\n\n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}