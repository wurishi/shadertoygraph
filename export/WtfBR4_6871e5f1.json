{"ver":"0.1","info":{"id":"WtfBR4","date":"1596068812","viewed":57,"name":"eindacor_flowers","username":"Eindacor_DS","description":"it's flowers, you dolt!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["flowers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA .002f\n#define PI 3.141592653f\n#define TWOPI 6.28318530718f\n#define skyColor vec3(.5f, .75f, 1.f)\n#define earthColor vec3(0.4f, .4f, 0.2f)\n#define sunColor vec3(1.f, 1.f, 0.f)\n#define stemColor vec3(0.f, 0.7f, 0.f)\n#define flowerColor vec3(1.f, 0.f, 0.f)\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat circleSmoothStep(vec2 center, float radius, float thickness, vec2 p, float antiAlias) {\n    float distFromCenter = distance(center, p);\n    float halfThickness = thickness / 2.f;\n    if (distFromCenter < radius) {\n        return smoothstep(radius - halfThickness - antiAlias, radius - halfThickness + antiAlias, distFromCenter);\n    } else {\n        return 1.f - smoothstep(radius + halfThickness - antiAlias, radius + halfThickness + antiAlias, distFromCenter);\n    }\n}\n\n/*\n\treturns smoothstep value for line segment\n\texample usage:\n\t\toutColor = mix(outColor, lineColor, lineSegmentSmoothStep(start, end, uv, thickness, AA, true));\n*/\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nvec2 rotatePointAroundOtherPoint(vec2 center, vec2 p, float angleInRadians) {\n    mat2x2 rotationMatrix = mat2x2(\n    \tcos(angleInRadians), -sin(angleInRadians),\n        sin(angleInRadians), cos(angleInRadians)\n    );\n    \n    return (rotationMatrix * (p - center)) + center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n      \n    float earthElevationOnScreen = 0.5f;\n    float earthRadius = .25f;\n    vec2 earthCenter = vec2(0.5f * aspectRatio, earthElevationOnScreen - earthRadius);\n    earthCenter.y = .5f;\n    float actualDist = distance(earthCenter, uv);\n    \n    float dayLength = 8.f;\n    float sunTimeScale = iTime * .8f;\n    float sunPositionValue = mod(sunTimeScale, dayLength) / dayLength;\n    float sunHeight = .25f;\n    vec2 sunAzimuthPos = vec2(earthCenter.x, earthCenter.y + earthRadius + sunHeight);\n    \n    vec2 sunPosition = rotatePointAroundOtherPoint(earthCenter, sunAzimuthPos, TWOPI * sunPositionValue);\n     \n    vec3 outColor = skyColor;\n    \n    float earthValue = smoothstep(actualDist - AA, actualDist + AA, earthRadius);\n    outColor = mix(outColor, earthColor, earthValue);\n       \n    float flowerAttractionCoeff = .3f;\n    float flowerStemThickness = .005f;\n    float flowerHeight = .025f;\n    vec2 flowerStart = vec2(earthCenter.x, earthCenter.y + earthRadius);\n    int flowerCount = 50 ;\n    float flowerGrowthFactor = .3f;\n    float flowerRadius = .012f;\n    \n    for (int i=0; i<flowerCount; i++) {\n        float rotation = float(i) / float(flowerCount) * TWOPI;\n        vec2 localFlowerStart = rotatePointAroundOtherPoint(earthCenter, flowerStart, rotation);   \n        vec2 flowerTangentVec = normalize(localFlowerStart - earthCenter);\n        vec2 flowerToSunVec = normalize(sunPosition - localFlowerStart);\n        \n        float normalizedTanDotSun = (dot(flowerTangentVec, flowerToSunVec) + 1.f) / 2.f;\n        \n        float bendFactor = 1.f - smoothstep(0.5, 1.f, normalizedTanDotSun);\n        if (bendFactor < .0000f) {\n         \t// treat like a straight line   \n        } else if (i==0) {\n            float circleRadius = mix(flowerHeight / PI, 1000.f, bendFactor);\n        }\n        \n        vec2 mixedVec = normalize(mix(flowerToSunVec, flowerTangentVec, pow(1.f - normalizedTanDotSun, flowerAttractionCoeff)));\n        vec2 flowerEnd = mixedVec * (flowerHeight + (pow(normalizedTanDotSun, 2.f) * flowerHeight * flowerGrowthFactor)) + localFlowerStart;\n        outColor = mix(outColor, stemColor, lineSegmentSmoothStep(localFlowerStart, flowerEnd, uv, flowerStemThickness, AA, true));\n        float flowerDist = distance(uv, flowerEnd);\n        outColor = mix(flowerColor, outColor, smoothstep(flowerRadius - AA, flowerRadius + AA, flowerDist));\n    }\n    \n       \n    float sunRadius = .05f;\n    float sunDistance = distance(sunPosition, uv);\n    float sunValue = smoothstep(sunDistance - AA, sunDistance + AA, sunRadius);\n     outColor = mix(outColor, sunColor, sunValue);\n    \n    fragColor = vec4(outColor, 1.f);\n}","name":"Image","description":"","type":"image"}]}