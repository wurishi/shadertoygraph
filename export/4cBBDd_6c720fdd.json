{"ver":"0.1","info":{"id":"4cBBDd","date":"1725629056","viewed":7,"name":"distortion 34784378","username":"khlorghaal","description":" exponential grid useful for infinities","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["grid","reference","infinity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SS 32\n\n//#define LINEAR_ZOOM 1\n\nconst float EXPOSURE= 2.;\nconst float GAMMA= 2.2;\n\nvec2 f(vec2 p){\n    #ifdef LINEAR_ZOOM\n        re p;\n        #endif\n    float k= 1.; float j= -1.;\n    vec2 a= -k/(p-j)+k;\n    vec2 b=  k/(p+j)-k;\n    p= a*b;    \n    re p;\n    \n}\n\nfloat grid(vec2 p){\n    p*= 8.;\n    #ifdef LINEAR_ZOOM\n        p*= nmapu(tri(time/16.))*1024.;\n    #endif\n    float a= 0.;\n    count(8){\n        float b= maxv(vec2(\n            tri(p.x),\n            tri(p.y)\n            ))*(1.-.0125*float(n));\n        p+= 8.;\n        p/= 8.;\n        a= max(a,b);\n    }\n    re a;\n}\n\n\n//ret color\nvec3 bg(vec2 p){\n        float s= grid(p);\n        s= s*16.-14.5;\n        s= pow(s,.25);\n        s= sat(s);\n        re vec3(s);\n}\n\nvec4 img(vec2 fg){\n    vec2 uv= fg/res;\n    vec2 uvn= nmaps(uv);\n    uvn.x*= asp;\n    \n    re vec4(bg(f(uvn)),1.);\n}\n\n\n#ifdef SHADERTOY\nvoid mainImage(out vec4 _col, vec2 fg){\n    \n    vec4 col;\n    \n    #ifndef SS\n        col=img(fg);\n    #else\n        for(int x=0; x<SS; x++){\n                vec2 fg_= fg+nmaps(fract(sin((fg+float(x)+time)*PHI*8.)*123.321));\n                col+=img(fg_);\n        }\n        col/= float(SS);\n    #endif\n    \n    #ifdef DEBUG\n        col= vec4(_err,1.);\n        return;\n    #endif\n    \n    //tonemap\n    col*=EXPOSURE;\n    col*= 1.-1./(1.+maxv(col));\n    col= pow(col,vec4(GAMMA));\n    col.a= 1.;\n    _col= col;\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Khlor's header\n//https://github.com/khlorghaal/shaderheaders\n//BSD license\n\n//vec4 img(vec2 uv){INIT; }\n\n//Define-Switches\n#define SHADERTOY\n#define GLES\n\n//hack from https://www.shadertoy.com/view/3ll3RH by ttg\n//violently jams uniforms into scope\nfloat _iTime= 1.;\nvec3 _iResolution= vec3(1.);\n#define INIT {_iTime=iTime; _iResolution=iResolution;}\n#define iTime _iTime\n#define iResolution _iResolution\n\n//Consts\n#define PI  3.14159265359\n#define TAU (PI*2.)\n#define PHI 1.61803399\n#define deg2rad 0.01745329251\n#define SQRT2 (sqrt(2.))\n#define BIG 1e8\n#define ETA 1e-4\n#define eqf(a,b) ( abs((a)-(b))<ETA )\n\n//Aliases\n#define fc (gl_FragCoord.xy)\n#define res (iResolution.xy)\n#define ires ivec2(iResolution.xy)\n#define aspect (res.x/res.y)\n#define asp aspect\n#define aspinv (1./aspect)\n#define vec1 float\n#define ivec1 int\n#define uvec1 uint\n#define len length\n#define lerp mix\n#define norm normalize\n#define sat saturate\n#define sats saturate_signed\n#define smooth(x) smoothstep(0.,1.,x)\n#define time float(iTime)\n#define mouse ((iMouse.xy-res/2.)/(res*2.))\n#define mouse_ang (mouse*TAU)\n#define tex texture\n#define re return\n\n#define RA(S,N) for(int S=0; S<N; S++)\n\nvec4   srgb(vec4 c){ return pow(c,vec4(   2.2)); }\nvec4 unsrgb(vec4 c){ return pow(c,vec4(1./2.2)); }\nvec4 texsrgb(sampler2D s,   vec2 uv){ return unsrgb(texture(s,uv)); }\nvec4 texsrgb(samplerCube s, vec3  r){ return unsrgb(texture(s, r)); }\n\n\nvec2 mods(vec2 x, vec1 y){ return mod(x,vec2(y));}\nvec3 mods(vec3 x, vec1 y){ return mod(x,vec3(y));}\nvec4 mods(vec4 x, vec1 y){ return mod(x,vec4(y));}\n\nvec2 pows(vec2 x, vec1 y){ return pow(x,vec2(y));}\nvec3 pows(vec3 x, vec1 y){ return pow(x,vec3(y));}\nvec4 pows(vec4 x, vec1 y){ return pow(x,vec4(y));}\n\n\n vec2 clamps( vec2 x,  vec1 min,  vec1 max){ return clamp(x,  vec2(min), vec2(max));}\n vec3 clamps( vec3 x,  vec1 min,  vec1 max){ return clamp(x,  vec3(min), vec3(max));}\n vec4 clamps( vec4 x,  vec1 min,  vec1 max){ return clamp(x,  vec4(min), vec4(max));}\nivec2 clamps(ivec2 x, ivec1 min, ivec1 max){ return clamp(x, ivec2(min),ivec2(max));}\nivec3 clamps(ivec3 x, ivec1 min, ivec1 max){ return clamp(x, ivec3(min),ivec3(max));}\nivec4 clamps(ivec4 x, ivec1 min, ivec1 max){ return clamp(x, ivec4(min),ivec4(max));}\n\n vec2 mins( vec2 v,  vec1 s){ return min(v,  vec2(s));}\n vec3 mins( vec3 v,  vec1 s){ return min(v,  vec3(s));}\n vec4 mins( vec4 v,  vec1 s){ return min(v,  vec4(s));}\n vec2 maxs( vec2 v,  vec1 s){ return max(v,  vec2(s));}\n vec3 maxs( vec3 v,  vec1 s){ return max(v,  vec3(s));}\n vec4 maxs( vec4 v,  vec1 s){ return max(v,  vec4(s));}\n vec2 mins( vec1 s,  vec2 v){ return min(v,  vec2(s));}\n vec3 mins( vec1 s,  vec3 v){ return min(v,  vec3(s));}\n vec4 mins( vec1 s,  vec4 v){ return min(v,  vec4(s));}\n vec2 maxs( vec1 s,  vec2 v){ return max(v,  vec2(s));}\n vec3 maxs( vec1 s,  vec3 v){ return max(v,  vec3(s));}\n vec4 maxs( vec1 s,  vec4 v){ return max(v,  vec4(s));}\nivec2 mins(ivec2 v, ivec1 s){ return min(v, ivec2(s));}\nivec3 mins(ivec3 v, ivec1 s){ return min(v, ivec3(s));}\nivec4 mins(ivec4 v, ivec1 s){ return min(v, ivec4(s));}\nivec2 maxs(ivec2 v, ivec1 s){ return max(v, ivec2(s));}\nivec3 maxs(ivec3 v, ivec1 s){ return max(v, ivec3(s));}\nivec4 maxs(ivec4 v, ivec1 s){ return max(v, ivec4(s));}\nivec2 mins(ivec1 s, ivec2 v){ return min(v, ivec2(s));}\nivec3 mins(ivec1 s, ivec3 v){ return min(v, ivec3(s));}\nivec4 mins(ivec1 s, ivec4 v){ return min(v, ivec4(s));}\nivec2 maxs(ivec1 s, ivec2 v){ return max(v, ivec2(s));}\nivec3 maxs(ivec1 s, ivec3 v){ return max(v, ivec3(s));}\nivec4 maxs(ivec1 s, ivec4 v){ return max(v, ivec4(s));}\n\nfloat maxv( vec2 a){ return                 max(a.x,a.y)  ;}\nfloat maxv( vec3 a){ return         max(a.z,max(a.x,a.y)) ;}\nfloat maxv( vec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\nfloat minv( vec2 a){ return                 min(a.x,a.y)  ;}\nfloat minv( vec3 a){ return         min(a.z,min(a.x,a.y)) ;}\nfloat minv( vec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n  int maxv(ivec2 a){ return                 max(a.x,a.y)  ;}\n  int maxv(ivec3 a){ return         max(a.z,max(a.x,a.y)) ;}\n  int maxv(ivec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\n  int minv(ivec2 a){ return                 min(a.x,a.y)  ;}\n  int minv(ivec3 a){ return         min(a.z,min(a.x,a.y)) ;}\n  int minv(ivec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n\n//normalized map to signed\n//[ 0,1]->[-1,1]\nvec1 nmaps(vec1 x){ return x*2.-1.; }\nvec2 nmaps(vec2 x){ return x*2.-1.; }\nvec3 nmaps(vec3 x){ return x*2.-1.; }\nvec4 nmaps(vec4 x){ return x*2.-1.; }\n//normalized map to unsigned\n//[-1,1]->[ 0,1]\nvec1 nmapu(vec1 x){ return x*.5+.5; }\nvec2 nmapu(vec2 x){ return x*.5+.5; }\nvec3 nmapu(vec3 x){ return x*.5+.5; }\nvec4 nmapu(vec4 x){ return x*.5+.5; }\n\n//[0,1]\nfloat saw(float x){ return mod(x,1.); }\nfloat tri(float x){ return abs( mod(x,2.) -1.); }\n  int tri(int x, int a){ return abs( abs(x%(a*2))-a ); }\n\nfloat sum ( vec2 v){ return dot(v,vec2(1));}\nfloat sum ( vec3 v){ return dot(v,vec3(1));}\nfloat sum ( vec4 v){ return dot(v,vec4(1));}\n  int sum (ivec2 v){ return v.x+v.y;}\n  int sum (ivec3 v){ return v.x+v.y+v.z;}\n  int sum (ivec4 v){ return v.x+v.y+v.z+v.w;}\nfloat prod( vec2 v){ return v.x*v.y;}\nfloat prod( vec3 v){ return v.x*v.y*v.z;}\nfloat prod( vec4 v){ return v.x*v.y*v.z*v.w;}\n  int prod(ivec2 v){ return v.x*v.y;}\n  int prod(ivec3 v){ return v.x*v.y*v.z;}\n  int prod(ivec4 v){ return v.x*v.y*v.z*v.w;}\n\n#define sqrtabs(x) sqrt(abs(x))\n#define powabs(x,p) pow(abs(x),p)\n\nvec1 saturate(vec1 x){ return clamp (x, 0.,1.);}\nvec2 saturate(vec2 x){ return clamps(x, 0.,1.);}\nvec3 saturate(vec3 x){ return clamps(x, 0.,1.);}\nvec4 saturate(vec4 x){ return clamps(x, 0.,1.);}\n#define lerpsat(a,b,x) lerp(a,b,saturate(x))\n\nvec1 saturate_signed(vec1 x){ return clamp (x, -1.,1.);}\nvec2 saturate_signed(vec2 x){ return clamps(x, -1.,1.);}\nvec3 saturate_signed(vec3 x){ return clamps(x, -1.,1.);}\nvec4 saturate_signed(vec4 x){ return clamps(x, -1.,1.);}\n\n#define smoother(x) (x*x*x * (x*(x*6.-15.)+10.) )\n\n\nfloat pow2i(int x){ return float(1<<x); }\n\n//nearest power of\nint npo2(float x){ return int(log2(x)); }\nint npo3(float x){ return int(log(x)/log(3.)); }\n\nfloat angle(vec2 v){ return atan(v.y,v.x); }\nvec1 angn(vec1 t){ return t-ceil(t/TAU-.5)*TAU; }\nvec2 angn(vec2 t){ return t-ceil(t/TAU-.5)*TAU; }\n\nbool real(vec1 x){ return !( isnan(x)||isinf(x) ); }\nbool real(vec2 x){ return real(prod(x)); }\nbool real(vec3 x){ return real(prod(x)); }\nbool real(vec4 x){ return real(prod(x)); }\n\nvec1 rationalize(vec1 x){ return real(x)? x:vec1(0.); }\nvec2 rationalize(vec2 x){ return real(x)? x:vec2(0.); }\nvec3 rationalize(vec3 x){ return real(x)? x:vec3(0.); }\nvec4 rationalize(vec4 x){ return real(x)? x:vec4(0.); }\n\n#define count(_n) for(int n=0; n!=_n; n++)\n\n//im not sure if this is linear or srgb, or if that even matters much\n#define LUMVEC vec3(0.2126, 0.7152, 0.0722)\nfloat lum(vec3 c){ return dot(c,vec3(LUMVEC)); }\n\n#define BLACK  vec3(0.,0.,0.)\n#define RED    vec3(1.,0.,0.)\n#define GREEN  vec3(0.,1.,0.)\n#define BLUE   vec3(0.,0.,1.)\n#define YELLOW vec3(1.,1.,0.)\n#define CYAN   vec3(0.,1.,1.)\n#define PURPLE vec3(1.,0.,1.)\n#define WHITE  vec3(1.,1.,1.)\n\n#define INT_MAX     0x7FFFFFFF\n#define INT_HALFMAX 0x00010000\n#define INT_MAXF     float(INT_MAX)\n#define INT_HALFMAXF float(INT_HALFMAX)\nvec1 unfix16(vec1 x){ return vec1(x)/INT_HALFMAXF; }\nvec2 unfix16(vec2 x){ return vec2(x)/INT_HALFMAXF; }\nvec3 unfix16(vec3 x){ return vec3(x)/INT_HALFMAXF; }\nvec4 unfix16(vec4 x){ return vec4(x)/INT_HALFMAXF; }\nivec1 fixed16(vec1 x){ return ivec1(INT_HALFMAXF*x); }\nivec2 fixed16(vec2 x){ return ivec2(INT_HALFMAXF*x); }\nivec3 fixed16(vec3 x){ return ivec3(INT_HALFMAXF*x); }\nivec4 fixed16(vec4 x){ return ivec4(INT_HALFMAXF*x); }\n\nivec4 hash(ivec4 x){\n\tx= ((x>>8)^x)*0x45d9f3b;\n\tx= ((x>>24)^x)*0x75d9f3b;\n\tx=  (x>>16)^x;\n    return x;\n}\n//[-max,+max]->[0,1]\nvec1 hashf(vec1 x){ return abs(vec1(hash(ivec4(fixed16(x),0.,0.,0.)).x  ))/INT_MAXF; }\nvec2 hashf(vec2 x){ return abs(vec2(hash(ivec4(fixed16(x),0.,0.   )).xy ))/INT_MAXF; }\nvec3 hashf(vec3 x){ return abs(vec3(hash(ivec4(fixed16(x),0.      )).xyz))/INT_MAXF; }\nvec4 hashf(vec4 x){ return abs(vec4(hash(ivec4(fixed16(x)         ))    ))/INT_MAXF; }\n\n#define R2A vec2(.99231, .9933)\n#define R2B vec2(.99111, .9945)\n#define R3A vec3(.99312, .98313, .9846)\n#define R3B vec3(.99111, .98414, .9935)\n#define R4A vec4(.99412, .99343, .99565, .99473)\n#define R4B vec4(.99612, .99836, .99387, .99376)\nvec1 rand (vec1 x){ return hashf(x);   }\nvec2 rand (vec2 x){ return hashf(x*hashf(x+x.yx)); }\nvec3 rand (vec3 x){ return hashf(x*1.e2*hashf(R3A+x+x.yzx+x.zxy)); }\nvec4 rand (vec4 x){ return hashf(x*hashf(x+x.yzwx+x.zwxy+x.wxyz)); }\nvec1 rand1(vec2 x){ return hashf(dot(x*R2A-R2B,-x*R2B+R2A)/x.x);  }\nvec1 rand1(vec3 x){ return hashf(dot(x+R3A-R3B,-x+R3B+R3A));  }\nvec1 rand1(vec4 x){ return hashf(dot(x+R4A-R4B,-x+R4B+R4A));  }\nvec2 rand2(vec1 x){ return hashf(x+R2A);   }\nvec3 rand3(vec1 x){ return hashf(x+R3A);   }\n\nfloat bilerp(\n\tfloat nn, float np,\n\tfloat pn, float pp,\n\tvec2 l\n){\n\tvec2 lx= lerp(\n\t\tvec2(nn,np),\n\t\tvec2(pp,pp),\n\t\tl.x\n\t\t);\n\treturn lerp(lx.x,lx.y,l.y);\n}\nvec2 bilerp(\n\tvec2 nn, vec2 np,\n\tvec2 pn, vec2 pp,\n\tvec2 l\n){\n\tvec4 lx= lerp(\n\t\tvec4(nn,np),\n\t\tvec4(pp,pp),\n\t\tl.xxxx\n\t\t);\n\treturn lerp(lx.xy,lx.zw,l.yy);\n}\n\nfloat trilerp(float nnn,float nnp,float npn,float npp,float pnn,float pnp,float ppn,float ppp,  vec3 l){\n\tfloat lnn= lerp(nnn, pnn, l.x);\n\tfloat lnp= lerp(nnp, pnp, l.x);\n\tfloat lpn= lerp(npn, ppn, l.x);\n\tfloat lpp= lerp(npp, ppp, l.x);\n\n\tfloat lln= lerp(lnn,lpn, l.y);\n\tfloat llp= lerp(lnp,lpp, l.y);\n\n\treturn lerp(lln,llp, l.z);\n}\nvec3 trilerp(vec3 nnn,vec3 nnp,vec3 npn,vec3 npp,vec3 pnn,vec3 pnp,vec3 ppn,vec3 ppp,  vec3 l){\n\tvec3 lnn= lerp(nnn, pnn, l.x);\n\tvec3 lnp= lerp(nnp, pnp, l.x);\n\tvec3 lpn= lerp(npn, ppn, l.x);\n\tvec3 lpp= lerp(npp, ppp, l.x);\n\n\tvec3 lln= lerp(lnn,lpn, l.y);\n\tvec3 llp= lerp(lnp,lpp, l.y);\n\n\treturn lerp(lln,llp, l.z);\n}\n\n\nfloat vnse(vec1 x){ return lerp(rand(floor(x)),rand(ceil(x)),fract(x)); }\nfloat vnse(vec2 p){\n\tvec2 fr= fract(p);\n\tvec2 f= floor(p);\n\tvec2 c= ceil(p);\n\tfloat nn= rand1(vec2(f.x,f.y));\n\tfloat np= rand1(vec2(f.x,c.y));\n\tfloat pn= rand1(vec2(c.x,f.y));\n\tfloat pp= rand1(vec2(c.x,c.y));\n\tvec4 v= vec4(nn,np,pn,pp);\n\tvec2 lx= lerp(v.xy,v.zw, fr.xx);\n\treturn lerp( lx.x,lx.y, fr.y );\n}\nfloat vnse(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tfloat nnn= rand1(vec3(f.x,f.y,f.z));\n\tfloat nnp= rand1(vec3(f.x,f.y,c.z));\n\tfloat npn= rand1(vec3(f.x,c.y,f.z));\n\tfloat npp= rand1(vec3(f.x,c.y,c.z));\n\tfloat pnn= rand1(vec3(c.x,f.y,f.z));\n\tfloat pnp= rand1(vec3(c.x,f.y,c.z));\n\tfloat ppn= rand1(vec3(c.x,c.y,f.z));\n\tfloat ppp= rand1(vec3(c.x,c.y,c.z));\n\tvec4 zn= vec4(\n\t\tnnn,\n\t\tnpn,\n\t\tpnn,\n\t\tppn\n\t);\n\tvec4 zp= vec4(\n\t\tnnp,\n\t\tnpp,\n\t\tpnp,\n\t\tppp\n\t);\n\tvec4 lx= lerp(zn,zp, fr.zzzz);\n\tvec2 ly= lerp(lx.xz, lx.yw, fr.yy);\n\treturn lerp(ly.x,ly.y, fr.x);\n}\n\nfloat perlin(float p){\n\tfloat fr= fract(p);\n\tfloat frn= fr-1.;\n\tfloat f= floor(p);\n\tfloat c= ceil(p);\n\tfloat a= nmaps(rand(f));\n\tfloat b= nmaps(rand(c));\n\treturn lerp(a,b,smooth(fr));\n}\nfloat perlin(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 frn= fr-1.;\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tvec3 nnn= nmaps(rand(vec3(f.x,f.y,f.z)));\n\tvec3 nnp= nmaps(rand(vec3(f.x,f.y,c.z)));\n\tvec3 npn= nmaps(rand(vec3(f.x,c.y,f.z)));\n\tvec3 npp= nmaps(rand(vec3(f.x,c.y,c.z)));\n\tvec3 pnn= nmaps(rand(vec3(c.x,f.y,f.z)));\n\tvec3 pnp= nmaps(rand(vec3(c.x,f.y,c.z)));\n\tvec3 ppn= nmaps(rand(vec3(c.x,c.y,f.z)));\n\tvec3 ppp= nmaps(rand(vec3(c.x,c.y,c.z)));\n\tfloat d_nnn= dot(nnn, vec3(fr .x, fr .y, fr .z));\n\tfloat d_nnp= dot(nnp, vec3(fr .x, fr .y, frn.z));\n\tfloat d_npn= dot(npn, vec3(fr .x, frn.y, fr .z));\n\tfloat d_npp= dot(npp, vec3(fr .x, frn.y, frn.z));\n\tfloat d_pnn= dot(pnn, vec3(frn.x, fr .y, fr .z));\n\tfloat d_pnp= dot(pnp, vec3(frn.x, fr .y, frn.z));\n\tfloat d_ppn= dot(ppn, vec3(frn.x, frn.y, fr .z));\n\tfloat d_ppp= dot(ppp, vec3(frn.x, frn.y, frn.z));\n\tvec4 zn= vec4(\n\t\td_nnn,\n\t\td_npn,\n\t\td_pnn,\n\t\td_ppn\n\t);\n\tvec4 zp= vec4(\n\t\td_nnp,\n\t\td_npp,\n\t\td_pnp,\n\t\td_ppp\n\t);\n\tvec4 lx= lerp(zn,zp, smooth(fr.zzzz));\n\tvec2 ly= lerp(lx.xz, lx.yw, smooth(fr.yy));\n\treturn nmapu(lerp(ly.x,ly.y, smooth(fr.x)));\n}\n\n\n//value noise smooth vector\nvec2 vnsesv(vec2 p){\n\tvec2 fr= fract(p);\n\tvec2 frn= fr-1.;\n\tvec2 f= floor(p);\n\tvec2 c= ceil(p);\n\tvec2 nn= rand(vec2(f.x,f.y));\n\tvec2 np= rand(vec2(f.x,f.y));\n\tvec2 pn= rand(vec2(f.x,c.y));\n\tvec2 pp= rand(vec2(f.x,c.y));\n\n\treturn bilerp(nn,np,pn,pp, smooth(fr));\n}\nvec3 vnsesv(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 frn= fr-1.;\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tvec3 nnn= rand(vec3(f.x,f.y,f.z));\n\tvec3 nnp= rand(vec3(f.x,f.y,c.z));\n\tvec3 npn= rand(vec3(f.x,c.y,f.z));\n\tvec3 npp= rand(vec3(f.x,c.y,c.z));\n\tvec3 pnn= rand(vec3(c.x,f.y,f.z));\n\tvec3 pnp= rand(vec3(c.x,f.y,c.z));\n\tvec3 ppn= rand(vec3(c.x,c.y,f.z));\n\tvec3 ppp= rand(vec3(c.x,c.y,c.z));\n\n\treturn trilerp(nnn,nnp,npn,npp,pnn,pnp,ppn,ppp, smooth(fr));\n}\n\n\nfloat worley(vec3 c){\n    float acc= 1.;\n    vec3 cfl= floor(c);\n    vec3 cfr= fract(c);\n    for(int i=-1; i<=1; i++){\n    for(int j=-1; j<=1; j++){\n    for(int k=-1; k<=1; k++){\n        vec3 g= vec3(i,j,k)+cfl;\n        vec3 p= rand(g)+g;\n        float l= len(p-c);\n        acc= min(acc,l);\n    }}}\n\treturn acc;\n}\n\n#define dFdxy(x) (vec2(dFdx(x),dFdy(x)))\n#define grad2(f,x) \\\n\t((vec2( \\\n    \tf(x+vec2(ETA,0)), \\\n\t\tf(x+vec2(0,ETA)) \\\n\t  )-f(x))/ETA)\n#define grad3(f,x) \\\n\t((vec3( \\\n    \tf(x+vec3(ETA,0,0)), \\\n\t\tf(x+vec3(0,ETA,0)), \\\n\t\tf(x+vec3(0,0,ETA)) \\\n\t  )-f(x))/ETA)\n\n#define gradnorm2(f,x)  \\\n\tnorm(vec3(grad2(f,x),1.))\n#define gradnorm3(f,x)  \\\n\tnorm(grad3(f,x))\n\nmat2 rot2d(float t){\n    float c= cos(t);\n    float s= sin(t);\n    return mat2(\n        c,-s,\n        s, c\n    );\n    \n}\nmat3 rotx(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n    );\n}\nmat3 roty(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n         c,0,s,\n         0,1,0,\n    \t-s,0,c\n    );\n}\nmat3 rotz(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        c,-s,0,\n        s, c,0,\n    \t0, 0,1\n    );\n}\n\n\nint doti(ivec2 a, ivec2 b){ return a.x*b.x + a.y*b.y; }\nint doti(ivec3 a, ivec3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\nint doti(ivec4 a, ivec4 b){ return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }\n\n//hacky\nint sqrti(int x){return int(sqrt(float(x)));}\nint cbrti(int x){return int( pow(float(x),1./3.));}\n\n\n\n#ifdef SHADERTOY\n//rip from https://www.shadertoy.com/view/llySRh\n#define KEY_LEFT   37\n#define KEY_UP     38\n#define KEY_RIGHT  39  \n#define KEY_DOWN   40   \n#define KEY_PGUP   33  \n#define KEY_PGDOWN 34  \n#define KEY_END    35  \n#define KEY_HOME   36\n#define KEY_SPACE  32\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#endif\n\n\n\n\n\n\n\n\n\n#define ase1(x) (x/(x+1.))\n#define sigmoid(x) ase1(abs(x))*sign(x)\n\n\n//ret distance\nfloat objects(vec2 p, float t){\n\n    float o=BIG;\n    #define PUT(n) o= min(o,len(p-n));\n    \n    {//orbiters\n        const vec2 pn= vec2(2.,0.);\n        const float w= 2.5;\n        PUT( rot2d(t*w    )*pn*2.  );\n        PUT( rot2d(t*w*-4.)*pn*2.2 );\n        PUT( rot2d(t*w*1.5)*pn*2.5 );\n        \n        PUT( rot2d(t*w*.5 )*pn*10.  );\n        PUT( rot2d(t*w*.5 )*pn*20.  );\n        PUT( rot2d(t*w*.5 )*pn*40.  );\n        PUT( rot2d(t*w*.5 )*pn*200. );\n    }\n    {//center\n        PUT(vec2(0.));\n    }\n    {//array\n        const float r= 1.5;\n        RA(j,8) RA(i,2)\n            PUT(vec2(i,j)*r)\n        RA(i,8)\n            PUT(vec2(i-4,0.)*r)\n    }\n    {//projectile\n        for(int i=-8;i!=8;i++){\n            float k= 128.;\n            float x= fract(float(i*16)*t*k)*k;\n            PUT(vec2(x,0.))\n        }\n    }\n    //o=1.;\n    return o;\n    #undef PUT\n}\n\n\n\n\n\n\n\n\n\n#undef iTime\n#undef iResolution","name":"Common","description":"","type":"common"}]}