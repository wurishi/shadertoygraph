{"ver":"0.1","info":{"id":"Wd2XRy","date":"1554284389","viewed":461,"name":"light ray marching thing","username":"samw","description":"Just messing about with some ray marching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lighting","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define PI 3.14159\n\n\nfloat distCuboid(vec3 pos, vec3 cubePos, vec3 size) \n{\n    \n    vec3 d = abs(pos - cubePos) - size;\n    \n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.);\n    float outsideDist = length(max(d, 0.));\n    \n    return insideDist + outsideDist;\n}\n\nfloat distSphere(vec3 pos, vec4 sphere)\n{\n\treturn length(pos-sphere.xyz)-sphere.w;\n}\n\nfloat dist(vec3 pos)\n{\n    vec4 sphere = vec4(0, 1, 0, 1);\n    vec3 center = vec3(0., 3., 0.);\n    float planeDist = pos.y;\n    \n    float sideLength = .8 + sin(iTime)/6.;\n    float sideLength2 = .8 + cos(iTime)/6.;\n    \n    float sphereDist1 = distSphere(pos, vec4(center.x, center.y, center.z, 1.9*sideLength));\n    float sphereDist2 = distSphere(pos, vec4(center.x, center.y, center.z, 1.7*sideLength));\n    \n    vec3 cuboid1 = vec3(1, 2.*(.8 + sin(iTime)/6.), 0.6);\n    vec3 cuboid2 = vec3(1, 2.*(.8 + sin(iTime + 2.*PI/3.)/6.), 0.6);\n    vec3 cuboid3 = vec3(1, 2.*(.8 + sin(iTime + 4.*PI/3.)/6.), 0.6);\n    float cuboidDist1 = distCuboid(pos, center, cuboid1.yxx);\n    float cuboidDist2 = distCuboid(pos, center, cuboid2.xyx);\n    float cuboidDist3 = distCuboid(pos, center, cuboid3.xxy);\n    \n    float cuboidDist4 = distCuboid(pos, center, 1.1*cuboid1.yzz);\n    float cuboidDist5 = distCuboid(pos, center, 1.1*cuboid2.zyz);\n    float cuboidDist6 = distCuboid(pos, center, 1.1*cuboid3.zzy);\n    \n    return min(planeDist, max(-min(cuboidDist4, min(cuboidDist5, cuboidDist6)), min(cuboidDist1, min(cuboidDist2, cuboidDist3))));\n}\n\nvec3 normal(vec3 pos)\n{\n\tvec2 e = vec2(.01, 0);\n    float d = dist(pos);\n    vec3 n = vec3(\n    \td-dist(pos-e.xyy),\n        d-dist(pos-e.yxy),\n        d-dist(pos-e.yyx)\n    );\n        \n    return normalize(n);\n}\n\nvec3 march(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.;\n    \n    for (int i=0; i<MAX_STEPS; i++)  {\n    \tvec3  p = ro + rd*dO;\n        float dS = dist(p);\n        dO += dS;\n        \n        if (dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return ro + rd*dO;\n}\n\nfloat light(vec3 pos)\n{\n    //vec3 lightSource = vec3(2.*cos(iTime), 10., 2.*sin(iTime));\n    vec3 lightSource = vec3(6., 10., 4.);\n    \n    vec3 lightDir = normalize(lightSource-pos);\n        \n        \n    vec3 d = march(pos+normal(pos)*SURF_DIST*2., lightDir);\n    \n    if (length(d)>length(pos-lightSource)) {\n    \treturn dot(normalize(lightSource.xyz-pos),  normal(pos));\n    } else {\n    \treturn dot(normalize(lightSource.xyz-pos),  normal(pos))*0.3;   \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //vec3 ro = vec3((iMouse.x-.5*iResolution.x)/200., 1, 0);\n    //vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //float angle = 0.1;\n    float angle = -(iMouse.x-.5*iResolution.x)/100.;\n    float angle2 = -(iMouse.y-.5*iResolution.y)/100.;\n    mat3 yaw = mat3(\n    \tcos(angle), 0., sin(angle),\n        0., 1., 0.,\n        -sin(angle), 0., cos(angle)\n    );\n    \n    mat3 pitch = mat3(\n        1., 0., 0.,\n    \t0., cos(angle2), sin(angle2),\n        0.,-sin(angle2), cos(angle2)\n    );\n    \n    mat3 rotation = yaw * pitch;\n    \n    vec3 ro = rotation * vec3(0., 0., -10.) + vec3(0., 3., 0.);\n    \n    vec3 rd = normalize(rotation*(vec3(uv.x, uv.y, 1)));\n\n    vec3 surfacePos = march(ro, rd);\n\n    float dif = light(surfacePos);\n    \n    vec3 col = dif * vec3(.75, .75, .75) + vec3(.25, .25, .25);\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}