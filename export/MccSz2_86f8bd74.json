{"ver":"0.1","info":{"id":"MccSz2","date":"1714162858","viewed":74,"name":"Texturing Raymarched Objects","username":"GarlicGraphix","description":"Following this wonderful tutorial by Art of Code: https://www.youtube.com/watch?v=VaYyPTw0V84\n\nThis code is very janky and I don't understand half of it but it does work and that's the important part!","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","texture","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n//sd functions by Inigo Quilez\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  //p.zy *= rot2D(PI/2.0);\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//From https://www.shadertoy.com/view/WtGXDD\nfloat getDist(vec3 p) {\n    float s = sdSphere(p , 1.0);\n    float t = sdTorus(p, vec2(1.5, 0.3));\n    t = max(sdPlane(p, normalize(vec3(0.0, 1.0, 0.0)), -0.01), t);\n    t = max(-sdPlane(p, normalize(vec3(0.0, 1.0, 0.0)), 0.01), t);\n    \n    return min(s, t);\n}\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = getDist(p) - \n        vec3(getDist(p-e.xyy), getDist(p-e.yxy),getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord *2. - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    m = vec2(0.68,0.53);\n    m.x += iTime*-0.1;\n    \n    vec3 origin = vec3(0.0, 0.0, -2.5);\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    origin.xz *= rot2D(-m.x*PI*2.0);\n    origin.yz *= rot2D(m.y*PI+1.);\n    \n    ray.xz *= rot2D(-m.x*PI*2.0);\n    ray.yz *= rot2D(m.y*PI+1.);\n        \n    float totDist = 0.0;\n    \n    for (int i = 0; i < 80; i++) {\n        vec3 pos = origin + ray * totDist;\n        \n        float dist = getDist(pos);\n        \n        totDist += dist;\n        \n        if (dist <= 0.001) {\n            break;\n        } else if (dist >= 100.0 || i == 79) {\n            fragColor = vec4(0.0);\n            return;\n        }\n    }\n\n    vec3 mask = vec3(totDist* 0.2);\n    vec3 finalRay = origin + ray*totDist;\n    finalRay.xz *= rot2D(iTime*0.4);\n    vec3 normal = getNormal(finalRay);\n    \n    vec3 colXZ = texture(iChannel0, finalRay.xz * 0.25 + 0.5).rgb;\n    vec3 colXY = texture(iChannel2, finalRay.xy * 0.5 + 0.5).rgb;\n    vec3 colYZ = texture(iChannel2, finalRay.yz * 0.5 + 0.5).rgb;\n    \n    finalRay.xz *= rot2D(iTime*-0.4);\n    finalRay.yz *= rot2D(.9);\n    \n    vec3 sunNormal = getNormal(finalRay);\n    \n    vec3 col = colXZ * abs(normal.y) + colXY * abs(normal.z) + colYZ * abs(normal.x);\n    col *= clamp(floor(1.0-sunNormal.z), 0.0, 1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= 5.0;\n    uv.y += iTime*0.1;\n    vec3 col = texture(iChannel0, uv.xy).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n    uv.xy *= length(uv)*5.0;\n    uv *= rot2D(iTime);\n    \n    fragColor = texture(iChannel0, uv)*clamp(floor(length(uv)*0.7), 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"mat2 rot2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"}]}