{"ver":"0.1","info":{"id":"XtjGzt","date":"1431982659","viewed":1020,"name":"2D Primitive Distance Functions","username":"104","description":"using distance functions to generate 2D filled shapes. Actually some of these are not 100% accurate but they're good for most applications.","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\n// convert distance to alpha\nfloat dtoa(float d, float amount)\n{\n    float a = clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n    return a;\n}\n\n\n\n// distance functions: ------------------------------------------------\n\n\n\n// circle\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    float d = length(uv - origin) - radius;\n    return d;\n}\n\n// signed distance to segment of 1D space. like, for making a vertical column\nfloat sdSegment1D(float uv, float a, float b)\n{\n    return max(a - uv, uv - b);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n  \tvec2 d = max(tl - uv, uv - br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\n// the big question is what is the best way to INPUT a free rect? tl+br+angle? p1,p2,p3?\nfloat sdRect(vec2 uv, vec2 a, vec2 b, float angle)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = b - a;\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n\treturn sdAxisAlignedRect(uv * rotMat, a, b);\n}\n\n// really a line segment with line width is just a rect expressed differently\nfloat sdLineSegment(vec2 uv, vec2 a, vec2 b, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = b - a;\n    float angle = atan(rectDimensions.x, rectDimensions.y);\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n    float halfLineWidth = lineWidth / 2.;\n    a -= halfLineWidth;\n    b += halfLineWidth;\n\treturn sdAxisAlignedRect(uv * rotMat, a, b);\n}\n\n// union of line segment and 2 circles\nfloat sdLineSegmentRounded(vec2 uv, vec2 a, vec2 b, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = b - a;\n    float angle = atan(rectDimensions.x, rectDimensions.y);\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n    float halfLineWidth = lineWidth / 2.;\n\n    uv *= rotMat;\n    vec2 tl = vec2(a.x - halfLineWidth, a.y);\n    vec2 br = vec2(b.x + halfLineWidth, b.y);\n\n    return min(min(sdAxisAlignedRect(uv, tl, br),\n                   sdCircle(uv, a, halfLineWidth)),\n                   sdCircle(uv, b, halfLineWidth));\n}\n\n\n// squircle\n// http://en.wikipedia.org/wiki/Squircle\nfloat sdSquircle(vec2 uv, vec2 origin, float radius, float power, float rot_)\n{\n    mat2 rot = rot2D(rot_);\n\tvec2 v = abs((origin*rot) - (uv*rot));\n    float d = pow(v.x,power) + pow(v.y, power);\n    d -= pow(radius, power);\n    return d;\n}\n\n// distance to edge of hexagon\nfloat sdHexagon(vec2 p, vec2 hexPos, float hexRadius, float hexRotation)\n{\n    mat2 rot = rot2D(hexRotation);\n\tvec2 v = abs((hexPos*rot) - (p*rot));\n\n\tvec2 topBottomEdge = vec2(0., 1.);\n\tconst vec2 sideEdges = vec2(0.86602540358, 0.5);// cos(radians(30)), sin(radians(30))\n\n\tfloat dot1 = dot(v, topBottomEdge);\n\tfloat dot2 = dot(v, sideEdges);\n    float dotMax = max(dot1, dot2);\n\t\n    return dotMax - hexRadius;\n}\n\n\n// signed distance to a 2D triangle\n// thank you iq: https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2)\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // background color\n    fragColor = vec4(1.0,0.94,0.67,1.0);\n    float dist;\n    float a, b, c, d, e, f;\n    vec2 tl, rectSize;\n    \n    // green column ------------------------------------------------\n    a = (sin(iTime+4.)+1.)/2.;\n    dist = sdSegment1D(uv.x, a, a + 0.3);\n\tfragColor = mix(fragColor, vec4(.1,0.5,0.2,1.0), 0.3 * dtoa(dist, 60.));\n\n    \n    \n    // axis-aligned rect ------------------------------------------------\n    vec4 circleColor = vec4(.4,0.5,0.6,1.0);\n    tl.x = (sin(iTime+5.)+1.)/3.;// top\n    tl.y = (sin(iTime+6.)+1.)/3.;// left\n    rectSize.x = (sin(iTime+7.)+2.5)/7.;// height\n\trectSize.y = (sin(iTime+8.)+2.5)/7.;// width\n    dist = sdAxisAlignedRect(uv, tl, tl + rectSize);\n    // the -0.05 here will make the object bigger, and reveal how accurate the distances are at corners.\n\tfragColor = mix(fragColor, circleColor, 0.9 * dtoa(dist-0.05, 60.));\n    \n    // draw the points\n    dist = sdCircle(uv, tl,0.);\n\tfragColor = mix(fragColor, circleColor * 0.5, 0.9 * dtoa(dist, 250.));\n    \n    dist = sdCircle(uv, tl + rectSize,0.);\n\tfragColor = mix(fragColor, circleColor * 0.5, 0.9 * dtoa(dist, 250.));\n\n    \n    // white rectangle ------------------------------------------------\n    vec4 rectColor = vec4(1.0);\n    a = 0.2+ (sin(iTime*0.25+25.)+.5)/5.;// top\n    b = 0.5;\n    c = 0.3;\n\td = 0.8;\n    vec2 br;\n    tl = vec2(min(a,c),min(b,d));\n    br = vec2(max(tl.x+0.1,max(a,c)),max(tl.y+0.1,max(b,d)));\n    \n    tl += vec2(.8,-0.4);\n    br += vec2(1.,-0.4);\n    \n    float angle = (sin(iTime)+1.0);// 0-2\n    angle = angle * pi / 9.;// restrict; many angles produce negative shape\n\n    dist = sdRect(uv, tl,br, angle);\n\tfragColor = mix(fragColor, rectColor, 0.9 * dtoa(dist - 0.05, 600.));\n    \n    // draw the points\n    dist = sdCircle(uv, tl,0.);\n\tfragColor = mix(fragColor, rectColor * 0.5, 0.9 * dtoa(dist, 250.));\n    \n    dist = sdCircle(uv, br,0.);\n\tfragColor = mix(fragColor, rectColor * 0.5, 0.9 * dtoa(dist, 250.));\n\n    \n    \n    // line segment ------------------------------------------------\n    vec4 lineSegmentColor = vec4(.1,0.5,0.2,1.0);\n    a = 0.4 + (sin(iTime*0.15+5.)+.5)/5.;// top\n    b = (sin(iTime*0.15+6.)+3.)/6.;// left\n    c = 0.5 + (sin(iTime*0.15+7.)+.5)/5.5;// height\n\td = (sin(iTime*0.15+8.)+3.5)/6.5;// width\n\n    float lineWidth = (sin(iTime*0.25+9.)+1.05)*0.18;\n    \n    dist = sdLineSegment(uv, vec2(a,b), vec2(c,d), lineWidth);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.6 * dtoa(dist, 600.));\n    \n    // draw the points\n    dist = sdCircle(uv, vec2(a,b),0.);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.8 * dtoa(dist, 250.));\n    \n    dist = sdCircle(uv, vec2(c,d),0.);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.8 * dtoa(dist, 250.));\n    \n    \n    \n    \n    // rounded line segment ------------------------------------------------\n    lineSegmentColor = vec4(.5,0.5,0.1,1.0);\n    a += 0.75;\n    c += 0.75;\n    dist = sdLineSegmentRounded(uv, vec2(a,b), vec2(c,d), lineWidth);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.6 * dtoa(dist, 600.));\n    \n    // draw the points\n    dist = sdCircle(uv, vec2(a,b),0.);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.8 * dtoa(dist, 250.));\n    \n    dist = sdCircle(uv, vec2(c,d),0.);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.8 * dtoa(dist, 250.));\n    \n    \n    \n    // triangle ------------------------------------------------\n    vec4 triangleColor = vec4(.3,0.1,0.3,1.0);\n    float time = iTime * 0.7;\n    a = (sin(time)+1.)/2.;\n    b = (sin(time+4.*0.4)+1.)/4.;\n    c = (sin(time+4.*0.4)+1.)/4.;;\n\td = 0.75;\n\te = 0.8;\n\tf = 0.75;\n    \n    dist = sdTriangle(uv, vec2(a,b), vec2(c,d), vec2(e,f));\n    // the -0.05 here will make the object bigger, and reveal how accurate the distances are at corners.\n\tfragColor = mix(fragColor, triangleColor, 0.7 * dtoa(dist - 0.05, 200.));\n    \n    // draw the points\n\tfragColor = mix(fragColor, triangleColor, 0.9 * dtoa(sdCircle(uv, vec2(a,b),0.005), 2000.));\n\tfragColor = mix(fragColor, triangleColor, 0.9 * dtoa(sdCircle(uv, vec2(c,d),0.005), 2000.));\n\tfragColor = mix(fragColor, triangleColor, 0.9 * dtoa(sdCircle(uv, vec2(e,f),0.005), 2000.));\n    \n    \n    \n    \n    \n    // red squircle ------------------------------------------------\n    dist = sdSquircle(uv,\n                      vec2(0.5 +((sin(iTime*0.75)+1.)/3.), (cos(iTime*1.3)/6.)+0.5),\n                      0.2, (sin(iTime)/1.2)+1.5, iTime);\n    // this converts distance -> alpha + color -> fragcolor\n\tfragColor = mix(fragColor, vec4(.85,0.,0.,1.0), 0.7 * dtoa(dist, 250.));\n    \n\n    // blue circle ------------------------------------------------\n    dist = sdCircle(uv,\n                    vec2(0.5 +((cos(iTime*0.85)+1.)/2.), (pow(cos(iTime*1.1),3.)/7.)+0.5),\n                    0.2);\n\tfragColor = mix(fragColor, vec4(.2,0.,0.8,1.0), 0.7 * dtoa(dist, 250.));\n    \n    \n    // yellow hex ------------------------------------------------\n\tdist = sdHexagon(uv,\n                     vec2(0.5 +((cos((iTime+1.4)*1.25)+1.)/4.), 0.6),\n                     0.2,\n                     iTime);\n\tfragColor = mix(fragColor, vec4(0.8,0.8,0.1,1.0), 0.7 * dtoa(dist, 60.));\n    \n\n}\n","name":"","description":"","type":"image"}]}