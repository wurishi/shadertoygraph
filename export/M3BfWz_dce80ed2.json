{"ver":"0.1","info":{"id":"M3BfWz","date":"1729854045","viewed":26,"name":"Raymarching Play","username":"kenbunroku","description":"Trial","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 translate(vec3 p, vec3 offset) {\n    return p - offset;\n}\n\n//回転の関数\nmat2 rot(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 m = mat2(c, -s, s, c);\n    return m;\n}\n\n\n// 球の距離関数\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\n// 立方体の距離関数\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size * (0.5 + 0.5 * cos(iTime * 2.));\n    p.xz *= rot(iTime);\n    float outsideDistance = length(max(d, 0.0));\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    return outsideDistance + insideDistance;\n}\n\n// スムーズな最小値を計算する関数\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\nfloat sceneSDF(vec3 p) {\n    float s = 1. + 0.5 * sin(iTime * 2.);\n    float dSphere = sphereSDF(p, s);\n    float dBox = boxSDF(p - vec3(0., 0.0, 0.0), vec3(1.0));\n    \n    vec3 p1 = p;\n    vec3 p2 = p;\n    vec3 p3 = p;\n    vec3 p4 = p;\n    vec3 p5 = p;\n    vec3 p6 = p;\n    vec3 p7 = p;\n    vec3 p8 = p;\n    \n    \n    p1.x -= 1.5 * cos(iTime);\n    p1.y -= 1.5 * sin(iTime);\n    p1 = translate(p1, vec3(sin(iTime) * 5., 0., 0.));\n    float dSphere2 = sphereSDF(p1, s * 0.3);\n    \n    p2.x += 1.5 * cos(iTime);\n    p2.y += 1.5 * sin(iTime);\n    p2 = translate(p2, vec3(sin(iTime * 2.) * 3., 0., 0.));\n    float dSphere3 = sphereSDF(p2, s * 0.4);\n    \n    p3.x += 2.5 * cos(iTime);\n    p3.y += 2.5 * sin(iTime);\n    p3 = translate(p3, vec3(sin(iTime * 4.) * 3., 0., 0.));\n    float dSphere4 = sphereSDF(p3, s * 0.5);\n    \n    p4.x -= 2.5 * cos(iTime);\n    p4.y -= 2.5 * sin(iTime);\n    p4 = translate(p4, vec3(sin(iTime * 5.) * 3., 0., 0.));\n    float dSphere5 = sphereSDF(p4, s * 0.6);\n    \n    p5.x -= 3.5 * cos(iTime);\n    p5.y -= 3.5 * sin(iTime);\n    p5 = translate(p5, vec3(sin(iTime * 6.) * 4., 0., 0.));\n    float dSphere6 = sphereSDF(p5, s * 0.7);\n\n    // 球と立方体を滑らかに合体\n    float scene = opSmoothSubtraction(dSphere, dBox, 0.5);\n    \n    scene = smin(scene, dSphere2, 0.5);\n    scene = smin(scene, dSphere3, 0.5);\n    scene = smin(scene, dSphere4, 0.5);\n    scene = smin(scene, dSphere5, 0.5);\n    scene = smin(scene, dSphere6, 0.5);\n    \n    return scene;\n}\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 n;\n    n.x = sceneSDF(p + vec3(epsilon, 0.0, 0.0)) - sceneSDF(p - vec3(epsilon, 0.0, 0.0));\n    n.y = sceneSDF(p + vec3(0.0, epsilon, 0.0)) - sceneSDF(p - vec3(0.0, epsilon, 0.0));\n    n.z = sceneSDF(p + vec3(0.0, 0.0, epsilon)) - sceneSDF(p - vec3(0.0, 0.0, epsilon));\n    return normalize(n);\n}\n\nvec3 lighting(vec3 p, vec3 col) {\n    vec3 lightDir = normalize(vec3(1.0, -1.0, -1.0)); // 光の方向\n    vec3 n = calculateNormal(p); // 法線\n    float diff = max(dot(n, lightDir), 0.0); // 拡散反射\n    return vec3(col) * diff + vec3(col) * 0.2; // 明るさを計算\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    float time = iTime;\n    \n    // カメラの設定\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // カメラの設定\n    vec3 target = vec3(0.0, 0.0, 0.0);      // カメラが注目するターゲット位置\n    vec3 cp = vec3(0., -5.0, -10.0);       // カメラの位置\n    cp.xz *= rot(time);\n    cp.yz *= rot(time * 0.2);\n    vec3 cd = normalize(target - cp);       // カメラの視線方向\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n    vec3 cu = normalize(cross(cd, cs));     // 上方向\n    \n    //最初は真っ黒にする\n    vec3 col = vec3(0.0);\n    \n    float fov = 2.5; // 視野角\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); // レイの方向\n\n    // レイマーチングのループ\n    float t = 0.0;\n    int maxSteps = 100;\n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = cp + t * rd;\n        float d = sceneSDF(p);\n        if (d < 0.001) break;\n        t += d;\n        if (t > 20.0) break;\n    }\n\n    // ヒットしたかどうかで色を決定\n    if (t < 20.0) {\n        vec3 p = cp + t * rd;\n        vec3 normal = calculateNormal(p);\n        \n        col = vec3(1.0, 0.0, 0.0);\n        col = lighting(p, vec3(uv, 0.5));\n    } else {\n        col = vec3(0.0);\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}