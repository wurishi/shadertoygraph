{"ver":"0.1","info":{"id":"3styzN","date":"1600543851","viewed":154,"name":"Smoothed Normal Capsule (Fake!)","username":"iY0Yi","description":"The right side is a fake capsule.\nIt has a smooth normal!\nBut... there's no mathematical basis for it.\nIt's just silly hand-tuned.\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fake","capsule","artifact","guts"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define saturate(x) clamp(x, 0., 1.)\n\n#define MAX_DIST 15.\n#define MIN_DIST .001\n#define MAT_VOID vec3(-1)\n\n// General capsule\nfloat sdCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Smoothed normal capsule (Fake!)\nfloat sdFakeCapsule(in vec3 p, float r, float c)\n{\n    float elg = c-min(.5,c);\n    p.y -= clamp(p.y,-elg,elg); // Elongation: https://www.shadertoy.com/view/Ml3fWj\n    \n    float a = .5*p.y*p.y+.5;\n    float b = abs(p.y);\n    p.y = b<1. ? a : b; // Smooth abs\n    \n    p.y -= min(.5,c); // Offset\n    return length(p)-r;\n}\n\n\nfloat sdScene(vec3 p)\n{\n    float h = 1.5, r = 2.;\n    mat2 rm;\n\t\n    // limitations for fake one...\n    const float minRad = 1.;\n    const float minHeight = 0.;\n    \n#if 0\n    if(iMouse.z>.5)\n    {\n        h = minHeight + (iMouse.y/iResolution.y)*1.5;\n        r = minRad + (iMouse.x/iResolution.x);\n    }\n    else\n    {\n        h = minHeight + (sin(iTime*.5)+1.);\n    \tr = minRad + (cos(iTime*.5)+1.)*.5;\n    }\n    rm = mat2(cos(cos(iTime*.5)*PI+vec4(0,11,33,0)));\n#else\n    if(iMouse.z>.5)\n    {\n        rm = mat2(cos((iMouse.y/iResolution.y)*PI+vec4(0,11,33,0)));\n    }\n    else\n    {\n        h = minHeight + (sin(iTime*.5)+1.);\n    \tr = minRad + (cos(iTime*.5)+1.)*.5;\n        rm = mat2(cos(cos(iTime*.5)*PI+vec4(0,11,33,0)));\n    }\n#endif\n    p.yz *= rm;\n\t\n\tfloat org  = sdCapsule(p+vec3(2.5, 0, 0), r, h);\n\tfloat fake = sdFakeCapsule(p+vec3(-2.5, 0, 0), r, h);\n    p.xy *= mat2(cos(PI*.5+vec4(0,11,33,0)));\n    //fake = min(sdFakeCapsule(p+vec3(-h*.5-r, 0, 0), r, 2.5), fake);\n    return min(org, fake);\n}\n\nvec3 ro = vec3(0), rd = vec3(0);\n\nfloat intersect()\n{\n    float d = MIN_DIST;\n\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + d * rd;\n        float res = sdScene(p);\n\n        if (abs(res) < MIN_DIST || res >= MAX_DIST) break;\n        d += res;\n        if (d >= MAX_DIST) break;\n    }\n\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    float c=sdScene(p);\n    float e=MIN_DIST*.1;\n    return normalize(vec3(\n        sdScene(p+vec3(e,0.,0.))-c,\n        sdScene(p+vec3(0.,e,0.))-c,\n        sdScene(p+vec3(0.,0.,e))-c)\n    );\n}\n\nvec3 render()\n{\n    float hit = intersect();\n    vec3 p = ro + hit * rd;\n    vec3 base_col = vec3(1);\n\tvec3 col;\n    \n    bool ref = fract(floor(iTime*.2)/2.)>0.; \n    if (hit>=MAX_DIST)\n    {\n        if(ref)\n            return texture(iChannel0, rd).rgb;\n        else\n            return vec3(.5);\n    }\n    vec3 n = normal(p);\n    vec3 ldir = normalize(vec3(-1,1,0));//normalize(vec3(sin(iTime),1,cos(iTime)));\n    float light1 = saturate(dot(n, ldir));\n    float light2 = 1.-light1;\n\n    float shade = light1*.99 + .01*light2;\n    //shade = smoothstep(.2, .21, shade);\n    col = base_col * shade;\n    //col = n*.5+.5;\n    \n    if(ref) col = texture(iChannel0, n).xyz;\n\n    return col;\n}\n\nvoid perspectiveCam(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    vec3 dir = vec3(0,0,1);\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,0,-10);\n    float fov = .4;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\nvoid camera(vec2 uv)\n{\n    perspectiveCam(uv, ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n    vec3 col = render();\n\tcol = pow(col, vec3(.4545));\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}