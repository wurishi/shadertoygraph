{"ver":"0.1","info":{"id":"4XffzH","date":"1727987191","viewed":79,"name":"Fast atmosphere (tiny version)","username":"Fewes","description":"Tiny version of www.shadertoy.com/view/lcfSRl\nI got a bit lost in adding new features to it so here's a version without the extras.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["clouds","sky","approximation","scattering","atmosphericscattering","atmosphere","mit","approximate","atmospheric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 Ray(vec2 uv)\n{\n    return normalize(vec3((uv-.5)*vec2(iResolution.x/iResolution.y,1.),1.));\n}\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float altitude = (-cos(iTime*.5)*.5+.5)*ATMOSPHERE_HEIGHT; \n    vec3 ro = vec3(0,altitude,0);\n    vec3 rd = Ray(uv);\n    float tod = -iTime*PI*.25+PI*.75;\n    vec3 ld = normalize(vec3(cos(tod)*.7,sin(tod)*.4,1));\n    vec3 lr = vec3(1);\n    \n    if (iMouse.z>0.)\n    {\n        ro.y = 100.;\n        ld = Ray(mouse);\n    }\n    \n    vec4 tsm;\n    vec3 color = GetAtmosphere(ro, rd, INFINITY, ld, lr, tsm, vec4(0), 1.0);\n    color += GetSunDisc(rd, ld) * tsm.xyz*tsm.w;\n    \n    color = color * 20.0; // Exposure\n    color = 1.0 - 1.0 / (1.0 + color); // Tonemap\n    color = pow(color, vec3(1./2.2)); // Gamma\n    color = color + hash33(vec3(uv,iFrame)) / 255.0;// Dither\n    \n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Copyright (c) 2024 Felix Westin\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/////////////////////////////////////////////////////////////////////////\n\n// Fast semi-physical atmosphere with planet view and aerial perspective.\n//\n// I have long dreamed of (and tried making) a function that\n// generates plausible atmospheric scattering and transmittance without\n// expensive ray marching that also supports aerial perspectives and\n// offers simple controls over perceived atmospheric density which do not\n// affect the color of the output.\n//\n// This file represents my latest efforts in making such a function and\n// this time I am happy enough with the result to release it.\n//\n// Big thanks to:\n// Inigo Quilez (https://iquilezles.org) for this site and his great\n// library of shader resources.\n// SÃ©bastien Hillaire (https://sebh.github.io) for his many papers on\n// atmospheric and volumetric rendering.\n\n/////////////////////////////////////////////////////////////////////////\n\n#ifndef FAST_ATMOSPHERE_INCLUDED\n#define FAST_ATMOSPHERE_INCLUDED\n\n// Lazy HLSL -> GLSL porting. Remove if you intend to use it with HLSL.\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define lerp mix\n\n// Config\n#define DRAW_PLANET                // Draw planet ground sphere.\n#define PREVENT_CAMERA_GROUND_CLIP // Force camera to stay above horizon. Useful for certain games.\n#define LIGHT_COLOR_IS_RADIANCE    // Comment out if light color is not in radiometric units.\n#define AERIAL_SCALE               1.0 // Higher value = more aerial perspective. A value of 1 is tuned to match reference implementation.\n#define NIGHT_LIGHT                2e-3 // Optional, cheap (free) non-physical night lighting. Makes twilight a bit purple which can look nice.\n#define SUN_DISC_SIZE              2.0 // 1 is physical sun size (0.5 degrees).\n\n// Math\n#define INFINITY 3.402823466e38\n#define PI       3.14159265359\n\n// Atmosphere\n#define ATMOSPHERE_HEIGHT  100000.0\n#define ATMOSPHERE_DENSITY 1.0\n#define PLANET_RADIUS      6371000.0\n#define PLANET_CENTER      float3(0, -PLANET_RADIUS, 0)\n#define C_RAYLEIGH         (float3(5.802, 13.558, 33.100) * 1e-6)\n#define C_MIE              (float3(3.996, 3.996, 3.996) * 1e-6)\n#define C_OZONE            (float3(0.650, 1.881, 0.085) * 1e-6)\n#define RAYLEIGH_MAX_LUM   2.5\n#define MIE_MAX_LUM        0.5\n\n// Magic numbers\n#define M_EXPOSURE_MUL        0.23 // Tuned to match physical reference.\n#define M_FAKE_MS             0.3 // Physical multiple scattering results in ~30% increase in energy.\n#define M_AERIAL              2.5\n#define M_TRANSMITTANCE       0.25\n#define M_LIGHT_TRANSMITTANCE 1e6\n#define M_MIN_LIGHT_ELEVATION -0.3\n#define M_DENSITY_HEIGHT_MOD  1e-12\n#define M_DENSITY_CAM_MOD     10.0\n#define M_OZONE               1.5\n#define M_OZONE2              5.0\n#define M_MIE                 float3(0.95, 0.85, 0.75)\n\nfloat sq(float x) { return x*x; }\nfloat pow4(float x) { return sq(x)*sq(x); }\nfloat pow8(float x) { return pow4(x)*pow4(x); }\nfloat saturate(float x) { return clamp(x, 0., 1.); }\n\n// https://iquilezles.org/articles/intersectors/\nfloat2 SphereIntersection(float3 rayStart, float3 rayDir, float3 sphereCenter, float sphereRadius)\n{\n\tfloat3 oc = rayStart - sphereCenter;\n    float b = dot(oc, rayDir);\n    float c = dot(oc, oc) - sq(sphereRadius);\n    float h = sq(b) - c;\n    if (h < 0.0)\n    {\n        return float2(-1.0, -1.0);\n    }\n    else\n    {\n        h = sqrt(h);\n        return float2(-b-h, -b+h);\n    }\n}\nfloat2 PlanetIntersection(float3 rayStart, float3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS);\n}\nfloat2 AtmosphereIntersection(float3 rayStart, float3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS + ATMOSPHERE_HEIGHT);\n}\n\nfloat PhaseR(float costh)\n{\n\treturn (1.0+sq(costh))*0.06;\n}\nfloat PhaseM(float costh, float g)\n{\n\tg = min(g, 0.9381);\n\tfloat k = 1.55*g-0.55*sq(g)*g;\n\tfloat a = 1.0-sq(k);\n\tfloat b = 12.57*sq(1.0-k*costh);\n\treturn a/b;\n}\n\nfloat3 GetLightTransmittance(float3 position, float3 lightDir, float multiplier, float ozoneMultiplier)\n{\n    float lightExtinctionAmount = exp(-(saturate(lightDir.y + 0.05) * 40.0)) +\n        exp(-(saturate(lightDir.y + 0.5) * 5.0)) * 0.4 +\n        sq(saturate(1.0-lightDir.y)) * 0.02 +\n        0.002;\n\treturn exp(-(C_RAYLEIGH + C_MIE + C_OZONE * ozoneMultiplier) * lightExtinctionAmount * ATMOSPHERE_DENSITY * multiplier * M_LIGHT_TRANSMITTANCE);\n}\nfloat3 GetLightTransmittance(float3 position, float3 lightDir)\n{\n\treturn GetLightTransmittance(position, lightDir, 1.0, 1.0);\n}\n\nvoid GetRayleighMie(float opticalDepth, float densityR, float densityM, out float3 R, out float3 M)\n{\n    // Approximate marched Rayleigh + Mie scattering with some exp magic.\n    R = (1.0 - exp(-opticalDepth * densityR * C_RAYLEIGH / RAYLEIGH_MAX_LUM)) * RAYLEIGH_MAX_LUM;\n\tM = (1.0 - exp(-opticalDepth * densityM * C_MIE / MIE_MAX_LUM)) * MIE_MAX_LUM;\n}\n\n// Main atmosphere function\nfloat3 GetAtmosphere(\n    float3 rayStart,      // Camera position\n    float3 rayDir,        // View direction\n    float  rayLength,     // View distance\n    float3 lightDir,      // Light (sun) direction\n\tfloat3 lightColor,    // Light (sun) color. Usually white\nout float4 transmittance, // Atmospheric transmittance in xyz, planet intersection flag in w\n    float4 fogFactor,     // (Optional) Fog \"fade\" factor. Can be used to add your own height fog or to fade the world out\n    float  occlusion      // (Optional) Scattering occlusion (god rays)\n) {\n#ifdef PREVENT_CAMERA_GROUND_CLIP\n\trayStart.y = max(rayStart.y, 1.0);\n#endif\n\n\t// Planet and atmosphere intersection to get optical depth\n\t// TODO: Could simplify to circle intersection test if flat horizon is acceptable\n\tfloat2 t1 = PlanetIntersection(rayStart, rayDir);\n\tfloat2 t2 = AtmosphereIntersection(rayStart, rayDir);\n    \n    // Note: This only works if camera XZ is at 0. Otherwise, swap for the line below.\n    float altitude = rayStart.y;\n    //float altitude = (length(rayStart - PLANET_CENTER) - PLANET_RADIUS);\n    float normAltitude = rayStart.y / ATMOSPHERE_HEIGHT;\n\n\tif (t2.y < 0.0)\n\t{\n\t\t// Outside of atmosphere looking into space, return nothing\n\t\ttransmittance = float4(1, 1, 1, 1);\n\t\treturn float3(0, 0, 0);\n\t}\n    else\n    {\n        // In case camera is outside of atmosphere, subtract distance to entry.\n        t2.y -= max(0.0, t2.x);\n\n#ifdef DRAW_PLANET\n        float opticalDepth = t1.x > 0.0 ? min(t1.x, t2.y) : t2.y;\n#else\n        float opticalDepth = t2.y;\n#endif\n\n        // Optical depth modulators\n        opticalDepth = min(rayLength, opticalDepth);\n        opticalDepth = min(opticalDepth * M_AERIAL * AERIAL_SCALE, t2.y);\n\n        // Altitude-based density modulators\n        float hbias = 1.0-1.0/(2.0+sq(t2.y)*M_DENSITY_HEIGHT_MOD);\n        hbias = pow(hbias, 1.0+normAltitude*M_DENSITY_CAM_MOD); // Really need a pow here, bleh\n        float sqhbias = sq(hbias);\n        float densityR = sqhbias * ATMOSPHERE_DENSITY;\n        float densityM = sq(sqhbias)*hbias * ATMOSPHERE_DENSITY;\n\n        // Apply light transmittance (makes sky red as sun approaches horizon)\n        float ly = lightDir.y;\n        ly += saturate(-lightDir.y + 0.02) * saturate(lightDir.y + 0.7);\n        ly = clamp(ly, -1.0, 1.0);\n        lightColor *= GetLightTransmittance(rayStart, float3(lightDir.x, ly, lightDir.z), hbias, M_OZONE2);\n\n#ifndef LIGHT_COLOR_IS_RADIANCE\n        // If used in an environment where light \"color\" is not defined in radiometric units\n        // we need to multiply with PI to correct the output.\n        lightColor *= PI;\n#endif\n\n        float3 R, M;\n        GetRayleighMie(opticalDepth, densityR, densityM, R, M);\n        \n        float3 E = (C_RAYLEIGH * densityR + C_MIE * densityM + C_OZONE * densityR * M_OZONE) * pow4(1.0 - normAltitude) * M_TRANSMITTANCE;\n\n        float costh = dot(rayDir, lightDir);\n        float phaseR = PhaseR(costh);\n        float phaseM = PhaseM(costh, 0.85);\n        \n#ifdef NIGHT_LIGHT\n        float nightLight = NIGHT_LIGHT;\n#else\n        float nightLight = 0.0;\n#endif\n        \n        // Combined scattering\n        float3 rayleigh = (phaseR * occlusion + phaseR * M_FAKE_MS) * lightColor + nightLight * phaseR;\n        float3 mie = ((phaseM * occlusion + phaseR * M_FAKE_MS) * lightColor + nightLight * phaseR) * M_MIE;\n        float3 scattering = mie * M + rayleigh * R;\n\n        // View extinction, matched to reference\n        transmittance.xyz = exp(-(opticalDepth + pow8(opticalDepth * 4.5e-6)) * E);\n        // Store planet intersection flag in transmittance.w, useful for occluding clouds, celestial bodies etc.\n        transmittance.w = step(t1.x, 0.0);\n\n        if (fogFactor.w > 0.0)\n        {\n            // 2nd sample (all the way to atmosphere exit), used for fog fade.\n            opticalDepth = t2.y;\n            GetRayleighMie(opticalDepth, densityR, densityM, R, M);\n            float3 scattering2 = mie * M + rayleigh * R;\n            float3 transmittance2 = exp(-opticalDepth * E);\n\n            scattering2 *= lerp(fogFactor.xyz, float3(1, 1, 1), sq(fogFactor.w)); // Fog color test\n            scattering = lerp(scattering, scattering2, fogFactor.w);\n            transmittance.xyz = lerp(transmittance.xyz, transmittance2, fogFactor.w);\n        }\n        \n        if (t1.y > 0.0 && t1.y < rayLength)\n        {\n            // Darken planet\n            float3 planetColor = float3(0.4, 0.4, 0.4);\n            float planetOpticalDepth = t1.y - max(0.0, t1.x);\n            float skyWeight = exp(-planetOpticalDepth * 1e-6);\n            scattering *= lerp(planetColor, float3(1, 1, 1), skyWeight);\n        }\n\n        return scattering * M_EXPOSURE_MUL;\n    }\n}\nfloat3 GetSunDisc(float3 rayDir, float3 lightDir)\n{\n    const float A = cos(0.00436 * SUN_DISC_SIZE);\n\tfloat costh = dot(rayDir, lightDir);\n\tfloat disc = sqrt(smoothstep(A, 1.0, costh));\n\treturn float3(disc, disc, disc);\n}\n\n#endif // FAST_ATMOSPHERE_INCLUDED\n","name":"Common","description":"","type":"common"}]}