{"ver":"0.1","info":{"id":"cdVcDh","date":"1696675401","viewed":122,"name":"Wavy surface reflection","username":"ishiyama","description":"Foreground: shallow waves, Background: deep waves.\n\nMouse up/down: camera movement, left/right: wave height adjustment.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926558979\nconst uint MATERIAL_ID_EMPTY    = 0u;\nconst uint MATERIAL_ID_WATER    = 1u;\nconst uint MATERIAL_ID_EMISSION = 2u;\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct HitResult\n{\n\tfloat depth;\n\tvec3 normal;\n\tuint materialID;\n};\n\nstruct Material\n{\n\tvec3 emission;\n\tvec3 f0;\n};\n\nMaterial NullMaterial()\n{\n\treturn Material(vec3(0.0), vec3(0.0));\n}\n\nstruct Geometry\n{\n\tvec3 position;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct MapResult\n{\n\tfloat depth;\n\tuint  materialID;\n};\n\nvec3 CheapTonecurve(vec3 x)\n{\n    vec3 a = vec3(0.6);\n    vec3 b = vec3(1.0);\n    return mix(x, a + b - b * b / (x - a + b), step(a, x));\n}\n\n// Carsten WÃ¤chter and Nikolaus Binder, \"A Fast and Robust Method for Avoiding Self-Intersection\"\nvec3 OffsetRay(vec3 inPos, vec3 inNormal)\n{\n\tconst float origin = 1.0 / 32.0;\n\tconst float float_scale = 1.0f / 65536.0;\n\tconst float int_scale = 256.0;\n\n\tivec3 of_i = ivec3(int_scale * inNormal.x, int_scale * inNormal.y, int_scale * inNormal.z);\n\tvec3 p_i = vec3(\n\t\tintBitsToFloat(floatBitsToInt(inPos.x) + ((inPos.x < 0.0) ? -of_i.x : of_i.x)),\n\t\tintBitsToFloat(floatBitsToInt(inPos.y) + ((inPos.y < 0.0) ? -of_i.y : of_i.y)),\n\t\tintBitsToFloat(floatBitsToInt(inPos.z) + ((inPos.z < 0.0) ? -of_i.z : of_i.z)));\n\t\n\treturn vec3(\n\t\tabs(inPos.x) < origin ? inPos.x + float_scale * inNormal.x : p_i.x,\n\t\tabs(inPos.y) < origin ? inPos.y + float_scale * inNormal.y : p_i.y,\n\t\tabs(inPos.z) < origin ? inPos.z + float_scale * inNormal.z : p_i.z);\n}\n\nvec3 SampleSurface(const Geometry inGeom, const vec3 inIncidentDir, out vec3 outReflectionDir)\n{\n    // perfect mirror reflection\n\toutReflectionDir = reflect(inIncidentDir, inGeom.normal);\n    vec3 f0\t= inGeom.material.f0;\n    float VoN = max(dot(-inIncidentDir, inGeom.normal), 0.0);\n\n    // fresnel reflectance (Schlick's approximation)\n    vec3 t = f0 + (vec3(1.0) - f0) * pow(vec3(1.0) - vec3(VoN), vec3(5.0));\n\n    return t;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// forward declaration\nMapResult Map(const vec3 inPos);\n\n// ref: http://www.iquilezles.org/articles/normalsSDF/\nvec3 CalcNormal(const vec3 inPos)\n{\n    // prevent unrolling for(..)\n\tint zero = min(0, int(iTime));\n    vec3 n = vec3(0.0);\n    for(int i = zero; i < 4; i++ )\n    {\n        vec3 e = 0.5773 * (2.0 * vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.0);\n        n += e * Map(inPos + 1e-5 * e).depth;\n    }\n    return normalize(n);\n}\n\nHitResult SphereTraceScene(const Ray inRay)\n{\n\tfloat tmin = 0.001;\n\tfloat tmax = 3.0;\n\n\tHitResult hit = HitResult(tmin, vec3(0.0), MATERIAL_ID_EMPTY);\n\tfor(uint i = 0u; i < 1024u && hit.depth < tmax; i++)\n\t{\n\t\tMapResult res = Map(inRay.origin + inRay.direction * hit.depth);\n\t\tfloat precis = 1e-5 * hit.depth;\n\t\tif (abs(res.depth) < precis) \n\t\t{\n\t\t\thit.materialID = res.materialID;\n\t\t\tbreak;\n\t\t}\n\t\thit.depth += res.depth;\n\t}\n\n\thit.normal = CalcNormal(inRay.origin + inRay.direction * hit.depth);\n\treturn hit;\n}\n\nvec3 CheapGerstnerWave(vec2 inPos, vec2 inDir, float inWaveLength) \n{\n    // ref: Tessendorf, J. (2001). Simulating ocean water.\n    const float g = 9.8;\n    float k = 2.0 * PI / inWaveLength;\n    float freq = sqrt(g / k);\n    float amp = 1.0 / k; // ref: https://catlikecoding.com/unity/tutorials/flow/waves/\n    float t = k * (dot(inDir, inPos) - freq * iTime);\n    return vec3(inDir.x * (amp * sin(t)), amp * cos(t), inDir.y * (amp * sin(t)));\n}\n\nMapResult Map(const vec3 inPos)\n{\n    const float MAX_DISTANCE = 10.0;\n\tvec2 result = vec2(MAX_DISTANCE, MATERIAL_ID_EMPTY);\n\n    // sphere light\n\tresult = opU(result, vec2(sdSphere(inPos - vec3(0.0, 0.0, 0.0), 0.5), MATERIAL_ID_EMISSION));\n    \n    // water surface\n    {\n        float mouse_x = clamp(1.0 - iMouse.x/iResolution.x, 0.0, 1.0);\n        vec3 waves = vec3(0.0);\n        vec2 p = inPos.xz * 700.0;\n        waves += CheapGerstnerWave(p, normalize(vec2(1.00, 1.00)), 61.0);\n        waves += CheapGerstnerWave(p, normalize(vec2(1.00, 0.61)), 31.0);\n        waves += CheapGerstnerWave(p, normalize(vec2(0.71, 1.00)), 29.0);\n        waves += CheapGerstnerWave(p, normalize(vec2(0.83, 0.59)), 23.0);\n        waves += CheapGerstnerWave(p, normalize(vec2(0.67, 0.89)), 19.0);\n        waves *= 1e-5 + mouse_x * 5.5e-4 * smoothstep(0.0, 1.0, clamp((1.9 - inPos.x)/1.0, 0.0, 1.0));\n        result = opU(result, vec2(sdBox(inPos - waves, vec3(10.0, 1e-2, 4.0)), MATERIAL_ID_WATER));\n    }\n\n\treturn MapResult(result.x, uint(result.y));\n}\n\nHitResult TraceScene(const Ray inRay)\n{\n\treturn SphereTraceScene(inRay);\n}\n\nstruct Payload\n{\n\tvec3 luminance;\n\tvec3 throughput;\n};\n\nvoid GetMaterial(const Ray inRay, const HitResult inHitResult, out Material outMaterial)\n{\n\toutMaterial = NullMaterial();\n\n\tvec3 pos = inRay.origin + inHitResult.depth * inRay.direction;\n\n\tswitch(inHitResult.materialID)\n\t{\n\t\tcase MATERIAL_ID_EMPTY:\n\t\t\toutMaterial.emission = vec3(0.4);\n\t\t\tbreak;\n\t\tcase MATERIAL_ID_WATER:\n\t\t\toutMaterial.f0 = vec3(0.02);\n\t\t\tbreak;\n\t\tcase MATERIAL_ID_EMISSION:\n            outMaterial.emission = 1.7 * mix(vec3(1.0, 0.05, 0.05), vec3(0.05, 1.0, 0.05), clamp(1.7 * pos.y, 0.0, 1.0));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n\nvec3 CastRay(in Ray inRay)\n{ \n\tPayload payload = Payload(vec3(0.0), vec3(1.0));\n\tRay ray = inRay;\n\n\tconst uint path_length = 3u;\n\tfor (uint i = 0u; i < path_length; ++i)\n\t{\n\t\t// get surface matrial\n\t\tHitResult hit = TraceScene(ray);\n\n\t\tGeometry geom;\n\t\tgeom.normal = hit.normal;\n\t\tgeom.position = ray.origin + hit.depth * ray.direction;\n\t\tGetMaterial(ray, hit, geom.material);\n\n\t\tvec3 refl_dir;\n\t\tvec3 t = SampleSurface(geom, ray.direction, refl_dir);\n\n\t\tpayload.luminance  += geom.material.emission * payload.throughput;\n\t\tpayload.throughput *= t;\n\n\t\t// exit if the ray did not hit any surfaces\n\t\tif (hit.materialID == MATERIAL_ID_EMPTY)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t// next ray\n\t\tray.origin = OffsetRay(geom.position, geom.normal);\n\t\tray.direction = refl_dir;\n    }\n\n\treturn payload.luminance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 total = vec3(0.0);\n    \n    // cast rays for samplesPerAxis x samplesPerAxis times per pixel.\n    // ref: https://www.shadertoy.com/view/Xds3zN\n    const int samplesPerAxis = 2;\n    for(int m = 0; m < samplesPerAxis; m++)\n    for(int n = 0; n < samplesPerAxis; n++)\n    {\n        // subpixel offset\n        vec2 offset = vec2(float(m),float(n)) / float(samplesPerAxis) - 0.5;\n\n        // pixel coordinates\n        vec2 p = (2.0 * (fragCoord + offset) - iResolution.xy) / iResolution.y;\n\n        // ray origin\n        float my = iMouse.y/iResolution.y;\n        vec3 ro = vec3(2.5, 0.05 + 0.5 * smoothstep(0.0, 1.0, my), 0.0);\n\n        // camera-to-world transformation\n        vec3 cw = normalize(-ro);\n        vec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n        mat3 camera_mat = mat3(cu, cross(cu, cw), cw);\n        \n        // ray direction\n        vec3 rd = camera_mat * normalize(vec3(p, 2.5 /* focal length */));\n        \n        Ray ray;\n        ray.origin    = ro;\n        ray.direction = rd;\n        total += CastRay(ray);\n    }\n    total /= vec3(samplesPerAxis * samplesPerAxis);\n    \n    vec3 col = pow(CheapTonecurve(total), vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}