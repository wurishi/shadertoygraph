{"ver":"0.1","info":{"id":"XtSGW1","date":"1428389787","viewed":497,"name":"trampoline","username":"Lio","description":"Trying to make the vibration from  jump","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","animation","trampoline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define time iTime\n#define EPSILON .0001\n#define PI 3.14159265\n\nconst int MAX_ITER = 80;\nvec3 lightDir    = normalize(vec3(-1.6, 0.7, -0.5));\nfloat speedJump = 0.8;  // Ð¡ÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ Ð¾Ñ‚ÑÐºÐ¾ÐºÐ°\nfloat heightJump = 7.;  // Ð’Ñ‹ÑÐ¾Ñ‚Ð° Ð¿Ñ€Ñ‹Ð¶ÐºÐ°\nfloat ballSize = 1.7;   // Ð“Ð»ÑƒÐ±Ð¸Ð½Ð° Ð¿Ñ€Ð¾Ð³Ð¸Ð±Ð°\n\nstruct mat\n{\n  float typeMat;  \n  bool  ref;     \n     \n};\nmat materialMy = mat(0.0, false);\n//-----------------------------\nvec3 getNormal(in vec3 p);\nfloat renderFunction(in vec3 pos);\nfloat render(in vec3 posOnRay, in vec3 rayDir);\nvec3 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor);\nfloat distMat(inout float curDist, float dist, in float typeMat, in bool refl);\n//-----------------------------\nvec3 rotationCoord(vec3 n, in float t, float paramRotate)\n{\n vec3 result;\n //--------------------------------------------\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n   if(paramRotate <= 0.1)\n   {\n\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0,  1.0,  0.0,\n                      0.0,  0.0,  1.0);   \n   }\n   else if(paramRotate <= 1.0)\n   {\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0, sc.y,-sc.x,\n                      0.0, sc.x, sc.y);\n   }\n   else if(paramRotate <= 2.0)\n   {\n       rotate = mat3(  1.0,  0.0,  0.0,\n                       0.0, sc.y,sc.x,\n                       0.0, -sc.x, sc.y);  \n   }\n   else if (paramRotate <= 3.0)\n   {\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n   }\n   else if (paramRotate <= 4.0)\n   {\n      rotate = mat3( sc.y,  0.0, sc.x,\n                     0.0,   1.0,  0.0,\n                    -sc.x,  0.0, sc.y);   \n   }   \n   else if (paramRotate <= 5.0)\n   {\n       rotate = mat3( sc.y,sc.x,  0.0,\n                     -sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }   \n   else if (paramRotate <= 6.0)\n   {\n       rotate = mat3( sc.y,-sc.x, 0.0,\n                      sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }     \n   else\n   {\n   mat3 rotate_x = mat3(  1.0,  0.0,  0.0,\n                          0.0, sc.y,-sc.x,\n                          0.0, sc.x, sc.y);\n   mat3 rotate_y = mat3( sc.y,  0.0, -sc.x,\n                         0.0,   1.0,  0.0,\n                         sc.x,  0.0,  sc.y);\n   mat3 rotate_z = mat3( sc.y, sc.x,  0.0,\n                        -sc.x, sc.y,  0.0,\n                         0.0,  0.0,   1.0);\n   rotate = rotate_z * rotate_y * rotate_z;                \n   }\n  result = n * rotate;\n  return result;\n}\n//----------------------------------------------------\n\n//------------------------------------------\nvec2 rot(vec2 p,float r){\n  vec2 ret;\n  ret.x=p.x*cos(r)-p.y*sin(r);\n  ret.y=p.x*sin(r)+p.y*cos(r);\n  return ret;\n}\n//------------------------------------------\nvec2 rotsim(vec2 p,float s)\n{\n  vec2 ret=p;\n  ret=rot(p,-PI/(s*2.0));\n  ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n  return ret;\n}\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n//------------------------------------------\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n//----------------------------------------------------\nfloat dTorus(vec3 p, vec2 t)\n{\n   vec2 q = vec2(length(p.xz) - t.x, p.y);\n   return length(q) - t.y;\n}\n//----------------------------------------------------\nfloat dSphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n//----------------------------------------------------\nfloat yCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n//--------------------------------------------------\n// capsule in Y axis\nfloat capsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n//--------------------------------------------------\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n   vec3 pa = p - a, ba = b - a;\n   float h = clamp( dot(pa, ba) / dot(ba , ba), 0.0, 1.0 );\n       return length( pa - ba * h ) - r;\n}\n//---------------------------------------------------\nfloat zCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\n//------------------------------------------\n//Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ https://www.shadertoy.com/view/ltXGRj\nfloat rays(in vec3 p, in vec2 size, in float r)\n{\n   float rad=length(p);\n   return (length(p.xz)- size.x + size.y * (rad - r)); \n}\nfloat astra(in vec3 p, in vec2 kol, in vec2 size, in float r)\n{\n   p.xy = rotsim(p.xy, kol.x);\n   p.zy = rotsim(p.zy, kol.y);\n   return rays(p, size, r);\n}\n//--------------------------------------------------\n//-------------------------------------------------\n//http://glslsandbox.com/e#20289.0\nfloat dSegment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n   vec3 pa = p - a;\n   vec3 ba = b - a;\n   float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n   return length( pa - ba*h ) - r1 + r2*h;\n}\n//--------------------------------------------------\nfloat smin( float a, float b, float k ) \n{\n   float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n   return mix( b, a, h ) - k*h*(1.0-h);\n}\n//\n//--------------------------------------------------ÐŸÑ€Ñ‹Ð³ÑƒÐ½\nfloat jumper(in vec3 pos, in float r,in float d)\n{\n   float d1 = 1.;\n   vec3 p = pos;\n   float angle = 0.;\n   float r25 = r*0.25, r15 =r*0.15, r30 = r* 0.3, r50 = r*0.5, r40 = r*0.4,\n         r60 = r*0.6, r80 = r*0.8, r70 = r*0.7, r90 = r*0.9;   \n  d1 = dSphere(p , r90); // Ð“Ð¾Ð»Ð¾Ð²Ð°\n  d1 = smin(d1, dSphere(p +  vec3(0., r25, -r80),r25), 0.1);\n  p.x = abs(p.x);\n  p -= vec3(r70, 0., r80);\n  p.yz = rot(p.yz, 1.);\n  d1 = max(d1, -dTorus(p , vec2(-r15, r40)));\n //--------// Ñ€ÑƒÐºÐ¸\n  p = pos;\n  float t = fract(speedJump * time);// Ð¡ÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ \n  t *= 4.0  * (1.0 - t);\n  angle = clamp(2.7 * t, 0.2, 2.7);   // Ð£Ð³Ð¾Ð» ÑÐ³Ð¸Ð±Ð°Ð½Ð¸Ñ Ñ€ÑƒÐº  \n \n vec3 offY = vec3(0., r + r50, 0.);\n d1 = min(d1,capsuleY(p + offY, r25, r50)); // Ð¨ÐµÑ\n p.x = abs(p.x);\n p -= vec3(r60, -(r+r90), 0.); \n p.xy = rot(p.xy, angle); \n d1 = min(d1,  capsuleY(p, r25,r*2.)); // Ñ€ÑƒÐºÐ¸\n d1 = min(d1,  dSphere(p - vec3(0., r*2., 0.), r30)); \n d =  distMat(d,  d1,2.0, false ); \n//----------- //Ð“Ð»Ð°Ð·Ð°\n  p = pos;\n  p.x = abs(p.x);\n  p -= vec3(r60, 0., r60);\n  d =  distMat(d,  dSphere(p , r15) ,  4.0, false) ; \n//----------// Ð¨Ð°Ð¿ÐºÐ°\n p = pos;\n p.yz = rot(p.yz, -0.8); \n d1 = min(d1, astra(p , vec2(20.), vec2(r25, 0.15 ), 0.));\n d1 = max(d1, -dSphere(p -  vec3(0., 0., r*2.),r*2.));\n d =  distMat(d,  d1   ,  5.0, false );  \n //--------// Ð ÑƒÐ±Ð°ÑˆÐºÐ°\n p = pos;\n offY = vec3(0., r*3.+r25, 0.);  \n d1 = capsuleY(p + offY, r90, r+r25);             // Ð ÑƒÐ±Ð°ÑˆÐºÐ°\n //--------\n offY = vec3(r60, -(r+r80), 0.); \n p.x = abs(p.x);\n p -= offY;\n p.xy = rot(p.xy, angle); \n d1 = min(d1,  capsuleY(p, r40, r80));   // Ð ÑƒÐºÐ°Ð²Ð°\n d =  distMat(d,  d1   ,  3.0, false ); \n //-----------\n d =  distMat(d,  dSphere(p , r70) ,  4.0, false ); \n //-------- // Ð¨Ñ‚Ð°Ð½Ñ‹\n angle = clamp(-1.5 * t, -2., 0.);  \n //------------------\n offY = vec3(0., r*3.+r60, 0.);  \n p = pos + offY;\n d1 = capsuleY(p, r80, r25); // Ð’ÐµÑ€Ñ…\n//------------------\n p = pos;\n p.x = abs(p.x);\n offY = vec3(r50, -(r*4.), 0.); \n p -= offY; \n//=================================================\n  vec3 p1 = vec3(0.);\n  vec3 p2 = vec3(0., -(r+r50), 0.);\n  vec3 p3 = vec3(0., -(r+r50), 0.);\n  p2.yz = rot(p2.yz, angle);  \n  p3.xy += p2.xy;\n   \n  d1 = smin(d1, dSegment(p, p1, p2, r50, 0.), 0.1);  // Ð’ÐµÑ€Ñ…Ð½ÑÑ Ñ‡Ð°ÑÑ‚ÑŒ ÑˆÑ‚Ð°Ð½Ð¸Ð½\n  d =  distMat(d,  d1   ,  4.0, false );  \n  d1 = dSegment(p, p2, p3, r30, 0.);        // ÐÐ¾Ð³Ð¸ \n  d =  distMat(d,  d1   ,  2.0, false );\n  p += vec3(0., r+r50, -r30);\n  p.xy -= p2.xy;\n  d1 = dSphere(p * vec3(1.5, 1.5, 0.6), r50);            //Ð¾Ð‘Ð£Ð’Ð¬\n  d =  distMat(d,  d1   ,  5.0, false);  \n//=================================================\n\n  return d;\n}\n\n//--------------------------------------------------\nfloat sinc(float x)\n{\n   return sin(x) / x;\n}\n//--------------------------------------------------\nfloat getY(in vec2 p, float push, float ballz)\n{\n   float stiffness = 0.4;\n   float dotP =dot(p,p); \n   float punch = exp2(-stiffness * dotP);\n   ballz -= (ballSize * ballSize - dotP);\n   return min(punch * push, ballz);\n}\n//--------------------------------------------------\nfloat  dTrampoline(in vec3 pos, in float r, in float d)\n{\n  vec3 p = pos;\n  float d1 = 1.;  \n  float t = fract(speedJump * time);\n  float push = -ballSize * sinc(42. * t); // Ð’Ð¸Ð±Ñ€Ð°Ñ†Ð¸Ñ Ð¿Ð¾ÑÐ»Ðµ Ð¿Ñ€Ñ‹Ð¶ÐºÐ°\n \n   float y = getY(p.xz, push, heightJump); \n   p.y -= y ;\n   d1=  yCylinder(p, vec2(r*7., 0.02));      // Ð¡Ð°Ð¼ Ð±Ð°Ñ‚ÑƒÑ‚\n   d =  distMat(d,  d1   ,  7.0, false );    \n   d1 = dTorus(p, vec2(r*7., r*0.4));         // ÐšÑ€Ð°Ð¹ Ð±Ð°Ñ‚ÑƒÑ‚Ð°\n   d =  distMat(d,  d1   ,  4.0, false ); \n   //----------\n   p = pos + vec3(0.,r*2., 0.);\n\n   p.xz = rotsim( p.xz, 6.);\n   p.xz = abs(p.xz); \n   p.z -= r*7.;\n   p.xy = rot(p.xy, 0.5);    \n   d1 = capsuleY(p, r*0.4, r*2.5);       // ÐÐ¾Ð¶ÐºÐ¸\n   d =  distMat(d,  d1   ,  1.0, false);     \n   //----------  \n  return d;\n}\n//------------------------------------------\nfloat distMat(inout float curDist, float dist, in float typeMat, in bool refl)\n{\n   float res = curDist;\n   if (dist < curDist) \n   {\n      materialMy.typeMat     = typeMat;\n      materialMy.ref         = refl;\n      res                    = dist;\n     return res;\n   }\n   return curDist;\n}\n\n//--------------------------------------------------\nfloat myObject(in vec3 p)\n{\n   float d =  1.0;\n   float r = 0.7;\n   materialMy.typeMat = 0.0;\n   materialMy.ref = false; \n   vec3 pos = p;\n   pos += vec3(0., 8., 0.);\n\n  d =  distMat(d,   udRoundBox( pos, vec3(10, 0.3, 10. ), 0.5),  1.0, true);    \n//======================================Ð‘Ð°Ñ‚ÑƒÑ‚ \n  pos = p + vec3(0., 6.,  0.);\n  d =  dTrampoline(pos, r,  d); \n//======================================ÐŸÑ€Ñ‹Ð³ÑƒÐ½\n  pos.y -= r*7.;\n  float t = fract(speedJump * time);// Ð¡ÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ñ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\n  t *= 4.0  * (1.0 - t);\n  pos.y -= heightJump * t ;\n  pos = rotationCoord(pos,t * 4., 3.);    \n//  pos = rotationCoord(pos,t * 8., 1.);    \n  d = jumper(pos,r,d);\n\n   return d; \n}\n//-------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nfloat renderFunction(in vec3 pos)\n{\n    return  myObject(pos);    \n}\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\nconst float precis = 0.00001;\n    vec3  eps = vec3(precis,0.0,0.0);\n    vec3 nor;\n    nor.x = renderFunction(p+eps.xyy) - renderFunction(p-eps.xyy);\n    nor.y = renderFunction(p+eps.yxy) - renderFunction(p-eps.yxy);\n    nor.z = renderFunction(p+eps.yyx) - renderFunction(p-eps.yyx);\n    return normalize(nor);\n\n}\n//ÐžÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ðµ, Ñ‚ÐµÐ½ÑŒ - Ð²ÑÐµ Ð²Ð·ÑÑ‚Ð¾  Ñƒ IQ\n//https://www.shadertoy.com/view/Xds3zN\n//-------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n   float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = renderFunction( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n//-------------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n   float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n      float h = renderFunction( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//-------------------------------------------------\nvec3 getLighting1(in vec3 ro, in vec3 rd ,in vec3 norm, in vec3 lightDir, in vec3 color, in float dist)\n{\n   vec3 col = color;\n   float occ = calcAO( ro, norm );\n   vec3 ref = reflect( rd, norm );\n   float amb = clamp( 0.5+0.5*norm.y, 0.0, 1.0 );\n   float dif = clamp( dot( norm, lightDir ), 0.0, 1.0 );\n   float bac = clamp( dot( norm, normalize(vec3(-lightDir.x,0.0,-lightDir.z))), 0.0, 1.0 )*clamp( 1.0-ro.y,0.0,1.0);\n   float dom = smoothstep( -0.1, 0.1, ref.y );\n   float fre = pow( clamp(1.0+dot(norm,rd),0.0,1.0), 2.0 );\n   float spe = pow(clamp( dot( ref, lightDir ), 0.0, 1.0 ),16.0);\n   dif *= softshadow( ro, lightDir, 0.02, 2.5 );\n   dom *= softshadow( ro, ref, 0.02, 2.5 );\n   vec3 brdf = vec3(0.0);\n   brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n   brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n   brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n   brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n   brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n   brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n   if(materialMy.ref)\n         col += pow(texture( iChannel2, ref ).xyz,vec3(2.2));\n   col = col*brdf;\n//   col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*dist*dist ) );\n   return col ; \n}\n\n//----------------------------------------------------------------------\nvec3 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor)\n{\n\n  vec3 color = texture( iChannel2, rd ).xyz;//vec4(1.);\n  vec3 hitPos = ro + rd * dist;\n  normal = normalize(getNormal(hitPos));  \n//----------------------------------\n\n  if (materialMy.typeMat == 0.0) \n  {\n    color = texture( iChannel2, rd ).xyz;\n   } \n else if (materialMy.typeMat == 1.0)    \n        color.rgb = texture( iChannel0, 0.15 * hitPos.xz ).xyz;\n else if (materialMy.typeMat == 2.0)   \n        color = vec3(1., 0.61, 0.43);      \n else if (materialMy.typeMat == 3.0)   \n        color = vec3(0.3, 0.7, 1.); \n else if (materialMy.typeMat == 4.0)   \n        color = vec3(0.07, 0.08, 0.46); \n else if (materialMy.typeMat == 5.0)   \n        color = vec3(0.38, 0.23, 0.67); \n else if (materialMy.typeMat == 7.)\n      color = texture( iChannel1, 0.15 * hitPos.xz ).xyz; \n else\n       color = vec3(0.5);\n\n   if(materialMy.typeMat !=0. )\n   {\n       color = getLighting1(hitPos, rd, normal, lightDir, color,dist);\n   }   \n    ro = hitPos;\n\n  return color;\n}\n\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir)\n{ \n  float t = 0.0;\n  float maxDist = 40.;\n  float d = 0.1;  \n\n  for(int i=0; i<MAX_ITER; ++i)\n  {\n    if (abs(d) <EPSILON || t > maxDist) \n         break;\n    t += d;\n    vec3 ro = posOnRay + t*rayDir;\n    d = renderFunction(ro);     \n  }\n\n   return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  gl_FragCoord.xy / iResolution.xy * 2. - 1.;\n    pos.x *= iResolution.x / iResolution.y;  \n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*PI*2.;\n    \n    vec3 camPos = vec3(0., 3., 17.);\n    camPos.yz=rot(camPos.yz, m.y);\n    camPos.xz=rot(camPos.yz, m.x+ 0.1*time+1.);\n    vec3 camP = rotationCoord(camPos,time * 0.1, 3.);\n    vec3 camUp = vec3(0. , 1., 0.);\n    vec3 camDir = normalize(-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(camDir * 2. + pos.x * u + pos.y * v);  \n\n   vec4 color    = vec4(1.0);\n    vec3 normal   = vec3(1.0);\n    vec3 posOnRay = camP; \n    float path = 0.;\n  //--------------------------- \n     path =  render(posOnRay, rayDir);  \n     color.rgb = getColorPixel(posOnRay, rayDir, normal, path, materialMy.typeMat); \n    // Gamma correct\n     color.rgb = pow(color.rgb , vec3(0.45));\n    // Contrast adjust - cute trick learned from iq\n     color.rgb  = mix( color.rgb , vec3(dot(color.rgb ,vec3(0.333))), -0.6 );\n     color.a = 1.;\n     fragColor =  color;\n\n}","name":"","description":"","type":"image"}]}