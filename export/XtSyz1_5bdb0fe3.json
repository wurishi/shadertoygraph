{"ver":"0.1","info":{"id":"XtSyz1","date":"1507316127","viewed":185,"name":"Wave!","username":"trillioneyes","description":"Simple wave propagation thing using entirely local computation","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["waves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// BEGIN HEADER\n\nconst float waveSpeed = 0.001;\n\nfloat displacement(vec2 point) {\n    return texture(iChannel0, point).x;\n}\n\nfloat velocity(vec2 point) {\n    return texture(iChannel1, point).x;\n}\n\nvec4 wrap(float scalar) {\n    return vec4(scalar, 0.0, 0.0, 1.0);\n}\n\n// END HEADER\n\nvec3 color(float disp) {\n    float clampTo = 1.0;\n    disp = clamp(disp, -clampTo, clampTo);\n    vec3 minColor = vec3(1.0, 1.0, 1.0),\n        maxColor = vec3(0.0, 0.0, 0.0);\n    return mix(minColor, maxColor, (disp + clampTo)/2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(color(displacement(uv)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// BEGIN HEADER\n\nconst float waveSpeed = 0.001;\n\nfloat displacement(vec2 point) {\n    return texture(iChannel0, point).x;\n}\n\nfloat velocity(vec2 point) {\n    return texture(iChannel1, point).x;\n}\n\nvec4 wrap(float scalar) {\n    return vec4(scalar, 0.0, 0.0, 1.0);\n}\n\n// END HEADER\n\n\nfloat fadeCircle(vec2 point, vec2 center, float radius) {\n    float d = distance(point, center);\n    return radius / (d+0.0001);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    if (iFrame == 0) {\n        fragColor = wrap(fadeCircle(uv, vec2(0.5, 0.5), 0.005));\n//        fragColor = texture(iChannel2, uv);\n    } else {\n        float d1 = displacement(uv);\n        float v = velocity(uv);\n        fragColor = wrap(d1 + v);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// BEGIN HEADER\n\nconst float waveSpeed = 0.005;\n\nfloat displacement(vec2 point) {\n    return texture(iChannel0, point).x;\n}\n\nfloat velocity(vec2 point) {\n    return texture(iChannel1, point).x;\n}\n\nvec4 wrap(float scalar) {\n    return vec4(scalar, 0.0, 0.0, 1.0);\n}\n\n// END HEADER\n\nconst float epsilon = 0.001;\n\nfloat slope(vec2 point, vec2 direction) {\n    vec2 point0 = point - direction*epsilon,\n        point1 = point + direction*epsilon;\n    float d0 = (displacement(point) - displacement(point0))/epsilon,\n        d1 = (displacement(point1) - displacement(point))/epsilon;\n    return (d0+d1)/2.0;\n}\n\nfloat slope2(vec2 point, vec2 direction) {\n    vec2 point0 = point - direction*epsilon,\n        point1 = point + direction*epsilon;\n    float d0 = (slope(point, direction) - slope(point0, direction))/epsilon,\n        d1 = (slope(point1, direction) - slope(point, direction))/epsilon;\n    return (d0+d1)/2.0;\n}\n\nfloat laplacian(vec2 point) {\n    return slope2(point, vec2(1.0, 0.0)) + slope2(point, vec2(0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float v0 = velocity(uv);\n    float dv = laplacian(uv) * pow(waveSpeed, 2.0) * iTimeDelta;\n    fragColor = wrap(v0 + dv);\n}","name":"Buf B","description":"","type":"buffer"}]}