{"ver":"0.1","info":{"id":"csBGzG","date":"1667756744","viewed":98,"name":"space thing sphere","username":"gabo6d","description":"a space thing sphere","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["space","thing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 duv = vec3(dFdx(uv.x)*.5, dFdy(uv.y)*.5, 0.);\n    \n    fragColor = vec4(0.);\n    for (int i = -1; i <= 1; i++)\n    for (int j = -1; j <= 1; j++)\n    {\n        vec2 n = vec2(duv.x*float(i), duv.y*float(i));\n        fragColor += texture(iChannel0, uv+n);\n    }\n    fragColor /= 9.;\n   \n   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define u_resolution iResolution\n#define u_time iTime\n#define CPOS vec3(0.675, -0.65, -1.85)*1.5\n#define LOOKAT vec3(-1.75, -0.1, 0.)\n#define PI 3.1415926535897932384626433832795\n#define PI_TWO 6.28318530718\n#define LPOS vec3(-0.5, 2., -1.)*1.5\n#define LPOS2 vec3(2.5, 1., 5.0)\n#define LCLR2 vec3(0.96,0.623*1.2,0.433*1.2) \n#define CLR_AMBIENT vec3(0.129, 0.01, 0.115)*.5\n\nfloat sdf_box(vec3 p, vec3 s)\n{\n    vec3 q = abs(p)-s;\n    return length(max(q, 0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdf_octahedron(vec3 p, float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.578;\n}\n\nfloat sdf_scene(vec3 p)\n{\n    p*=.25;\n    p-= vec3(-0.85, .15, -0.45 );\n    float t = u_time*0.125;\n    mat3 r_sph = mat3(\n        cos(t), 0., sin(t),\n        0., 1., 0.,\n        -sin(t), 0., cos(t)\n    );\n    mat3 r_oct = mat3(\n        vec3(cos(t), 0., sin(t)),\n        vec3(0., 1., 0.),\n        vec3(-sin(t), 0., cos(t))\n    )*mat3(\n        vec3(1., 0., 0.),\n        vec3(0., cos(t*2.), -sin(t*2.)),\n        vec3(0., sin(t*2.), cos(t*2.))\n    )*mat3(\n        vec3(cos(t*.5), -sin(t*.5), 0.),\n        vec3(sin(t*.5), cos(t*.5), 0.),\n        vec3(0., 0., 1.)\n    );\n    vec3 sp = r_oct*r_sph*p;\n    vec2 s = vec2(.275, .75);\n    float sph = max(-sdf_box(sp, s.xxy),max(-sdf_box(sp, s.yxx), max(-sdf_box(sp, s.xyx), length(sp)-.5)));\n    sph = min(sph, sdf_octahedron(r_oct*p, 0.25));\n\n\n\n    #ifdef DEBUG_LIGHT\n    float l1 = length(p-LPOS)-0.5;\n    float l2 = length(p-LPOS2)-0.5;\n    return min(sph,min(l1, l2));\n    #endif\n\n    return sph-0.01;\n}\n\nfloat march(vec3 p, vec3 d)\n{\n    float h = 0.;\n    vec3 cp = p;\n    for (int i = 0; i < 200; i++)\n    {\n        float cd = sdf_scene(cp);\n        h += cd;\n        cp += d*cd;\n        if (cd < 0.001 || cd > 999.) break;\n    }\n    return h;\n}\n\nvec3 lookat(vec3 p, vec2 uv, vec3 lookat, float fov)\n{\n    vec3 fwd = normalize(lookat-p);\n    vec3 right = normalize(cross(vec3(0.,1.,0.), fwd));\n    vec3 up = normalize(cross(fwd, right));\n    return normalize(\n        fwd*fov + right*uv.x + up*uv.y\n    );\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2(0.01,0.);\n    float d = sdf_scene(p);\n    return normalize(\n        d - vec3(\n            sdf_scene(p-e.xyy),\n            sdf_scene(p-e.yxy),\n            sdf_scene(p-e.yyx)\n        )\n    );\n}\n\nfloat hash2f(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.55, 4.55)))*999999.5);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 1./freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = hash2f((ij+vec2(0.,0.)));\n\tfloat b = hash2f((ij+vec2(1.,0.)));\n\tfloat c = hash2f((ij+vec2(0.,1.)));\n\tfloat d = hash2f((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p,f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat nebula_smoke(vec2 uv)\n{\n    float a = 8.;\n    float ut = 0.01;\n    float uva = 1.;\n    float t = 1.;\n    for (int i = 0; i < 2; i++)\n    {\n        float rt = sin(ut*u_time+uv.x*PI_TWO*uva)*radians(10.);\n        mat2 r = mat2(cos(rt), -sin(rt), sin(rt), cos(rt));\n        t *= a*pNoise(r*uv-vec2(u_time*ut,0.), 16);\n\n        a*=.5;\n        ut*=2.;\n        uva*=3.;\n    }\n    return t;\n}\n\nfloat voronoi(vec2 uv)\n{\n    vec2 id = floor(uv);\n    vec2 f = fract(uv);\n\n    float res = 1.;\n    for (int i = -1; i <= 1; i++)\n    for (int j = -1; j <= 1; j++)\n    {\n        vec2 n = vec2(i,j);\n        vec2 c = n-f+hash2f(id+n);\n        res = min(res, dot(c,c));\n    }\n    return sqrt(res);\n}\n\nvec2 sky_uv(vec3 p)\n{\n    p = normalize(p);\n    vec2 uv = vec2(\n        atan(p.z+1.85, p.x*3.) / PI_TWO + 0.5,\n        p.y * 0.5 + 0.5\n    );\n    return uv;\n}\n\nvec3 sky(vec2 uv, float uvz, vec3 p, float nuv, vec2 nuvo)\n{\n    // float uvz = 5.;\n    p = normalize(p);\n    float stars = 1.-voronoi(uv*uvz);\n    float starsn = noise(uv*uvz, uvz) ;\n    stars = pow(stars, mix(25., 200., starsn));\n    stars *= noise(uv+u_time*.05, uvz);\n\n    vec3 starcolors = vec3(1.);\n\n    vec3 nebulacolor = mix(CLR_AMBIENT, vec3(0.67, 0.3, 0.52), pNoise(uv-vec2(u_time*.006125, 0.), 16));\n    // float greennebulaf = pNoise(10.*uv+3.+u_time*0.01,16);\n    float greennebulaf = nebula_smoke(nuvo+uv*nuv);\n    vec3 greennebula = vec3(0.2, 0.67, 0.3);\n    greennebula = mix(\n        mix(\n        vec3(0.2, 0.67, 0.3), \n        vec3(0.67, 0.3, 0.52),\n        sin(dot(p, vec3(0.,1., 0.))*PI_TWO)*.5+.5\n    ),\n        vec3(0.34, 0.26, 0.67),\n        sin(dot(p, vec3(cos(u_time*.1),-1., sin(u_time*.05)))*PI_TWO)*.5+.5\n    );\n\n\n    // return greennebula*greennebulaf;\n    \n    nebulacolor = mix(nebulacolor, greennebula, greennebulaf);\n\n    vec3 skycolor = nebulacolor;\n    vec3 s = mix(starcolors, skycolor, 1.-stars);\n\n\n    float sunn = pNoise(uv+u_time*.1, 16)*.5;\n    float sunf = max(max(0., dot(uv, normalize(vec2(2.,-1.)))+sunn),\n    max(0., dot(p, normalize(vec3(1.,2.,100.)))));\n    vec3 sun = LCLR2*sunf*sunf*sunf*sunf*sunf*sunf*sunf*sunf*sunf*sunf*sunf;\n    s += sun;\n\n    return s;\n}\n\nvec3 sky(vec3 p)\n{\n    p = normalize(p);\n    vec2 uv = sky_uv(p);\n    return sky(uv, 50., p, 1., vec2(-1.));\n}\n\nvec3 shading(vec3 p, vec3 r, vec3 n, float d, vec3 cpos, vec3 lpos)\n{\n    if (d >= 999.)\n        return sky(p);\n    vec3 clr = vec3(0.24, 0.21, 0.332);\n    vec3 tol = lpos-p;\n    vec3 ldir = normalize(tol);\n    if (d <= 0.01)\n    {\n    #ifdef DEBUG_LIGHT\n    return vec3(1.);\n    #endif\n\n        float lambert = max(0., dot(ldir, n));\n        clr = mix(CLR_AMBIENT, clr,lambert);\n        // clr = vec3(1.);\n    }\n\n    // ambient occlusion\n    \n    \n    float ao = 1.;\n    float ao_dist = 0.1;\n    float ao_bias = 0.01;\n    float ao_scale = 2.;\n    float ao_intensity = 1.;\n    float dd = ao_dist;\n    for (int i = 0; i < 5; i++)\n    {\n        float hr = sdf_scene(p + n * ao_bias + r * dd);\n        ao -= hr * ao_scale;\n        dd += ao_dist;\n    }\n    ao = clamp(ao, 0., 1.);\n    ao = 1.-pow(ao, ao_intensity);\n    clr = mix(clr, CLR_AMBIENT, ao);\n\n    return clr;\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 cpos = CPOS;\n    vec3 cdir = lookat(cpos, uv, LOOKAT, 0.9);\n\n    float t = march(cpos, cdir);\n    vec3 p = cpos+cdir*t;\n    vec3 color = sky(uv, 25., vec3(uv.x, uv.y, 0.), .25, vec2(2.));\n    float d = sdf_scene(p);\n    if (d <= 0.001)\n    {\n        color = normal(p);\n        vec3 n = normal(p);\n        color = shading(p, cdir, n, t, cpos, LPOS);\n\n        float k = 120.;\n\n        vec3 reflp = p+n*0.01;\n        vec3 refln = n;\n        vec3 refldir = cdir;\n\n        for (int i = 1; i < 4; i++)\n        {\n            float spec = max(0., dot(reflect(normalize(LPOS-p), n), refldir));\n            color = mix(color, vec3(0.97, 0.98, 0.86)*0.8, pow(spec, 20.));\n\n            vec3 lpos2 = LPOS2;\n            float spec2 = max(0., dot(reflect(normalize(lpos2-p), n), cdir));\n\n            color = mix(color, LCLR2, pow(spec2, 0.5));\n            float reflectivity = max(0., 0.5-0.1*float(i));\n            refldir = reflect(refldir, refln);\n            reflp = reflp+refln*0.01;\n            float refld = march(reflp, refldir);\n            reflp = reflp+refldir*refld;\n            refln = normal(reflp);\n\n            vec3 reflclr = shading(reflp, refldir, refln, refld, cpos, LPOS);\n            float reflnoise = noise(p.xz*2.,100.)*hash2f(p.xy);\n            float reflfl = reflectivity-smoothstep(0., 1.,reflnoise)*.05;\n            color = mix(color, reflclr, reflfl);\n\n\n            if (refld >= 999.)\n            {\n                color = mix(color, sky(reflp), reflfl);\n                break;\n            }\n        }\n\n\n        \n    }\n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/u_resolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= u_resolution.x/u_resolution.y;\n\n    vec3 color = render(uv);\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}