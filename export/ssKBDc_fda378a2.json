{"ver":"0.1","info":{"id":"ssKBDc","date":"1658964159","viewed":208,"name":"Wave Equation 6 (use mouse)","username":"athibaul","description":"A very basic implementation of finite-difference time-domain numerical scheme for the acoustic equation. Use mouse to make waves.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fdtd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// SIMPLE FDTD SCHEME\n//\n// This shader simulates a lossy acoustic wave equation:\n//\n//     d^2p/dt^2 + alpha*dp/dt = Laplacian(p)\n//\n// using a very basic finite-difference time-domain scheme.\n//\n// Parameters are:\n// dt2_over_dx2 = 0.5 (largest allowed value for stability)\n// alpha/dt = 0 in the middle of the domain, up to 0.1 at the edge\n//\n// 2022 Alexis THIBAULT\n\n\n#define P(ij) texelFetch(iChannel0, (ij), 0)\n#define pal(x,c,d) abs(c*x+d)\n\nvec3 cmap(float v)\n{\n    vec3 col = abs(v) + vec3(0.8,0.2,-0.8)*v;\n    //return smoothstep(0.,1.,sqrt(1. - exp(-5.*col)));\n    //return (1. - exp(-5.*col));\n    return pow(1. - exp(-8.*col), vec3(0.4));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ij = ivec2(fragCoord);\n    ivec2 di = ivec2(1,0), dj = ivec2(0,1);\n\n    /*\n    float p = P(ij).x;\n    float q = sign(p) * pow(abs(p),0.8) * 3.0;\n    vec3 col = pal(q, vec3(-1.0,1.0,1.0), vec3(0.2,-0.1,0.15));\n    */\n    \n    // Output to screen\n    //fragColor = vec4(cmap(P(ij).x), 1);\n    //fragColor = vec4(col, 1);\n    \n    float p = P(ij).x;\n    float pi = P(ij+ivec2(1,0)).x;\n    float pj = P(ij+ivec2(0,1)).x;\n    float dxp = pi-p, dyp = pj-p;\n    float laplacian =   P(ij+di).x + P(ij-di).x \n                      + P(ij+dj).x + P(ij-dj).x \n                      - 4.*P(ij).x;\n    \n    vec3 col = vec3(0.);\n    col += 10.*vec3(1,0.8,0.6) * max(dyp - 0.5*dxp + 0.01,0.);\n               //+ 0.5*vec3(0.2,0.6,1.0) * max(dxp + 0.2,0.);\n               //+ 0.1*vec3(1.) * max(-dxp-dyp,0.);\n    col += 20.*vec3(0.2,0.6,1.0) * max(0.01 - dxp*dxp - dyp*dyp, 0.);\n    \n    float ao = (1. - 20.*laplacian);\n    //col *= ao;\n    \n    if(isObstacle(ij,ivec2(iResolution)))\n        col = vec3(0.);\n    \n    fragColor = vec4(sqrt(col), 0.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define P(ij) texelFetch(iChannel0, (ij), 0)\n\n\nfloat ramp(float d, float m)\n{\n    return (1. - d/m)*(1.-d/m) * step(d,m);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 coo )\n{   \n\n\n    ivec2 ij = ivec2(coo);\n    ivec2 wh = ivec2(iResolution.xy); // width-height\n    ivec2 di = ivec2(1,0), dj = ivec2(0,1);\n    \n    \n    if(isObstacle(ij, wh))\n    {\n        fragColor = vec4(0, 0, 0, iResolution.x);\n        return;\n    }\n    if(iFrame == 0 || P(ivec2(0)).a != iResolution.x)\n    {\n        // Initial conditions\n        //vec2 v = coo - iResolution.xy * vec2(0.51,0.55);\n        //float p0 = exp(-dot(v,v) / 100.) * 10.;\n        //float p0 = 0.;\n        vec2 uv = (2.*coo - iResolution.xy)/iResolution.y;\n        float p0 = 10.*smoothstep(0.1, 0.0, length(uv - vec2(0.12,0.1)));\n        fragColor = vec4(p0, p0, 0, iResolution.x);\n        return;\n    }\n    \n    // Neumann boundary conditions\n    // If we are on the wall, compute P as if we were slightly off\n    // the wall, so that at the next step P(ij) = P(ij+shift)\n    // i.e. the gradient in the direction normal to the boundary\n    // is zero.\n    if(ij.x == 0)\n        ij.x++;\n    else if(ij.x == wh.x - 1)\n        ij.x--;\n    else if(ij.y == 0)\n        ij.y++;\n    else if(ij.y == wh.y - 1)\n        ij.y--;\n    \n    \n    // We store vec4(p_n, p_nm1, 0, iResolution.x)\n    float laplacian =   P(ij+di).x + P(ij-di).x \n                      + P(ij+dj).x + P(ij-dj).x \n                      - 4.*P(ij).x;\n    float dt2_over_dx2 = 0.5;\n    //float damping = 0.05 * smoothstep(0.5,0.7, coo.x/iResolution.x);\n    float dist2wall = float(min(min(ij.x, wh.x-ij.x-1), min(ij.y, wh.y-ij.y-1)));\n    float damping = 0.1*ramp(dist2wall, 100.); // alpha / (2*dt)\n    // Without damping\n    //float p_np1 = 2.*P(ij).x - P(ij).y + cfl * laplacian;\n    // With damping\n    float p_np1 = 1./(1. + damping) * \n                  (2.*P(ij).x - (1. - damping) * P(ij).y \n                    + dt2_over_dx2 * laplacian);\n    \n    vec2 v = coo - iMouse.zw; // distance to source\n    float source = 5.*exp(-dot(v,v) / 100.);\n    \n    // rain\n    v = coo - iResolution.xy * (0.5 + 0.5*vec2(sin(float(iFrame)), sin(float(iFrame)*1.61803)));\n    //source += sin(float(iFrame)*1.41421)*0.002*exp(-dot(v,v) / 100.);\n    \n    \n    fragColor = vec4(p_np1 + source, P(ij).x + source, 0, iResolution.x);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nbool isObstacle(in ivec2 ij, in ivec2 wh)\n{\n    // Zero-pressure obstacles\n    \n    int dist2wall = min(min(ij.x, wh.x-ij.x-1), min(ij.y, wh.y-ij.y-1));\n    vec2 uv = (2.*vec2(ij)+1. - vec2(wh.xy))/float(wh.y);\n    \n    return (length(uv) < 0.3) && (length(uv) > 0.27) && abs(uv.y) > 0.04*step(0.,uv.x);\n    \n    //return (dist2wall > 100) && ((ij.x % 21) < 8) && ((ij.y % 34) < 13);\n}","name":"Common","description":"","type":"common"}]}