{"ver":"0.1","info":{"id":"wtsSDj","date":"1564391855","viewed":243,"name":"molten fractal","username":"jblanper","description":"Experimenting with the number of steps of the ray marching algorithm.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","blackwhite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float tt;\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin( float a, float b, float k ) {\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sphereSDF (vec3 p, vec3 c, float r) {\n  return length(c - p) - r;\n}\n\nfloat cubeSDF (vec3 p, vec3 c, vec3 dimensions, float borderRoundness) {\n  vec3 pos = abs(c - p) - dimensions;\n  return length(max(pos, 0.)) - borderRoundness + min(max(pos.x, max(pos.y, pos.z)), 0.);\n}\n\nvec2 map (vec3 p) {\n  //fractal\n  for (int i=0; i<3; i++) {\n    p = abs(p) - vec3(4., 3., 5.);\n\n    p.xz *= rotate(sin(tt) * .5 + .6);\n    p.yz *= rotate(cos(tt) * .5 + .8);\n    p.xy *= rotate(cos(tt) * .5 + 2.);\n    p += length(p.yx * sin(tt) * .2 + .4) * .5;\n  }\n\n  p *= .9; // to scale fractal .4\n\n  // primitives\n  float c1 = cubeSDF(abs(p) - vec3(length(p.yz) + .2, .1, .8), vec3(0.), vec3(.5, .2, .8), .05);\n  c1 += sin(p.x * 4.) * cos(p.y * 6. + sin(tt)) * sin(p.z * 3.) * .3;\n  float c2 = cubeSDF(abs(p) - vec3(.5, .3, 2.), vec3(0.), vec3(.3, .1, .6), .01);\n\n  vec2 t = vec2(smin(c1 * .3, c2 * .15, .5), 2.);\n  vec2 h = vec2(cubeSDF(abs(p) - vec3(.5, .2, .8), vec3(1.), vec3(.3, .3, .5), .03) * .3, .1);\n  t = (t.x < h.x) ? t : h; // merge materials\n\n  return t / .8;\n}\n\nvec2 trace (vec3 ro, vec3 rd) {\n  const float MAX_DEPTH = 50.;\n  vec2 h, t = vec2(.1);\n\n  for (int i = 0; i < 48; i++) {\n    h = map(ro + rd * t.x);\n    if (h.x < .0001 || t.x > MAX_DEPTH) break;\n    t.x += h.x; t.y = h.y;\n  }\n  if (t.x > MAX_DEPTH) t.x = 0.;\n  return t;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = map(p).x;\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    map(p - e.xyy).x,\n    // 0.,\n    map(p - e.yxy).x,\n    map(p - e.yyx).x));\n}\n\nstruct Material {\n  float ambient;\n  float diffuse;\n  float specular;\n};\n\nfloat getLight (vec3 lightPos, vec3 p, vec3 rd, float lightOcclusion, Material material) {\n  // https://www.shadertoy.com/view/ll2GW1\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  // phong reflection\n  float ambient = clamp(.5 + .5 * normal.y, 0., 1.);\n  float diffuse = clamp(dot(normal, light), 0., 1.);\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, normal), 0.0, 1.0), 16.);\n\n  return (ambient * material.ambient * lightOcclusion) +\n   (diffuse * material.diffuse * lightOcclusion) +\n   (diffuse * specular * material.specular * lightOcclusion);\n}\n\nvec3 getRayDirection (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  // https://www.youtube.com/watch?v=PBxuVlp7nuM\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  tt = mod(iTime * .1, 100.);\n\n  // camera\n  vec3 ro = vec3(0., 0., 25. + sin(tt) * 10.);\n  vec3 rd = getRayDirection(uv, ro, vec3(0.), 2.);\n\n  // color, fog and light direction\n  //vec3 ld = normalize(vec3(.5, .8, .5));\n  vec3 ld = vec3(5., 8., 3.);\n  vec3 fog = vec3(.01) * (.5 + (length(uv) - .3));\n  vec3 color = fog;\n\n  // scene\n  vec2 sc = trace(ro, rd);\n  float t = sc.x;\n\n  if (t > 0.) {\n    vec3 p = ro + rd * t;\n    vec3 normal = getNormal(p);\n    vec3 albido = vec3(.5);//base color\n\n    if (sc.y > .9) {\n      albido = vec3(2.);\n    }\n\n    // lightning\n    ld.xz *= rotate(tt * 5.);\n    color = getLight(ld, p, rd, .8, Material(.2, .7, 1.2)) * albido;\n    color = mix(color, fog, 1. - exp(-.00007*t*t*t)); //gradient\n  }\n\n  fragColor = vec4(pow(color, vec3(.45)), 1.);\n}","name":"Image","description":"","type":"image"}]}