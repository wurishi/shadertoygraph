{"ver":"0.1","info":{"id":"WldXz2","date":"1582367064","viewed":489,"name":"PBR GGX + Environment map","username":"winlandiano","description":"A simple PBR shader with environment map. Forward shading, directional+point light sources. Unity-style approximation.\nGGX: Walter et al.\nFresnel term: Schlick C.\nVisibility/geometry term: Smith shadow-masking\nDistribution term: Trowbridge-Reitz","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["pbr","ggx","environmentmap","unity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2020 Ridge/winlandiano\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright\n// notice and this permission notice shall be included in all copies or substantial portions of the Software. THE\n// SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple PBR shader with environment map. Forward shading, directional+point light sources. Unity-style approximation.\n// GGX: Walter et al.\n// Fresnel term: Schlick C.\n// Visibility/geometry term: Smith shadow-masking\n// Distribution term: Trowbridge-Reitz\n\n\n// ----------------  optional function macros  ----------------\n#define GAMMA_CORRECTION\n#define CAMERA_ANIMATION\n#define LIGHT_ANIMATION\n// ----------------  optional function ends  ----------------\n\n#define SPHERE_N 1\n#define LIGHT_N 2\n#ifdef GAMMA_CORRECTION\n    #define AMBIENT_WEIGHT 0.02\n#else\n    #define AMBIENT_WEIGHT 0.3\n#endif\n#define SPEED 0.5\n\n#define SPHERE_TYPE 1\n\n#define DIRECTIONAL_LIGHT_TYPE 51\n#define POINT_LIGHT_TYPE 52\n\n#define INF 1e10\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n\n#define saturate(x) clamp(x, 0., 1.)\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float t_max;\n    float t_min;\n};\n\nstruct Camera {\n    vec3 position;\n    float fov;\n    vec3 target;\n    vec3 up;\n};\n\nmat4 lookAt(Camera c) {\n    vec4 D = vec4(normalize(c.target - c.position), 0);\n    vec4 U = vec4(c.up, 0);\n    vec4 R = vec4(cross(D.xyz, U.xyz), 0);\n    vec4 P = vec4(c.position, 1);\n    mat4 m1 = mat4( vec4(R.x, U.x, D.x, 0), \n                    vec4(R.y, U.y, D.y, 0),\n                    vec4(R.z, U.z, D.z, 0),\n                    vec4(0, 0, 0, 1));\n    mat4 m2 = mat4( vec4(1, 0, 0, 0),\n                    vec4(0, 1, 0, 0),\n                    vec4(0, 0, 1, 0),\n                    vec4(-P.xyz, 1));\n    mat4 newView = m1 * m2;\n    return newView;\n}\n\nstruct LightSource {\n    vec3 position;\n    float intensity;\n    vec3 color;\n    int type;\n};\n\nstruct Sphere {\n    float radius;\n    vec3 center;\n    int type;\n};\n\nstruct Intersection {\n    vec4 P;\n    vec3 N;\n    vec3 V;\n    vec4 baseColor;\n    float metallic;\n    float roughness;\n};\n\nfloat SphereIntersect(Ray r, Sphere s) {\n    vec3 L = s.center - r.origin;\n    float d = length(L);\n    float d2 = d * d;\n    float cos_theta = saturate(dot(normalize(L), r.direction));\n    float cos_theta2 = cos_theta * cos_theta;\n    if (cos_theta <= 0.) {\n        return INF;\n    }\n    float sin_theta2 = 1. - cos_theta2;\n    float r2 = s.radius * s.radius;\n    float intersect_half2 = r2 - d2 * sin_theta2;\n    if (intersect_half2 < 0.) {\n        return INF;\n    }\n    float center_project_dist = d * cos_theta;\n    float intersect_half = sqrt(intersect_half2);\n    float t0 = center_project_dist - intersect_half;\n    if (t0 < 0.) {\n        return center_project_dist + intersect_half;\n    } else {\n        return t0;\n    }\n}\n\nvec2 Polar(vec3 norm) {\n    vec2 res;\n    res.y = (norm.y + 1.) / 2.;\n    res.x = atan(norm.z, norm.x) / TWOPI;\n    return res.xy;\n}\n\nvec2 PolarWrap(vec3 norm) {\n    vec2 res = Polar(norm);\n    res.x = abs(res.x - 0.5) * 2.;\n    return res;\n}\n\nstruct GlazeMaterial {\n    float f0, roughness;\n};\n\nconst GlazeMaterial BallMaterial = GlazeMaterial(0.2, 0.4);\n\nSphere spheres[SPHERE_N];\nLightSource lights[LIGHT_N];\nCamera camera;\nmat4 View;\n\nvoid SetupScene(float frame) {\n    spheres[0] = Sphere(0.3, vec3(0, 0, 0), SPHERE_TYPE);\n    lights[0] = LightSource(normalize(vec3(1, -1, 1)), 1., vec3(1, 1, 1), DIRECTIONAL_LIGHT_TYPE);\n#ifdef LIGHT_ANIMATION\n    lights[1] = LightSource(vec3(2. * cos(5. * frame), 2. * sin(5. * frame), 0.), 1., vec3(1, 1, 1), POINT_LIGHT_TYPE);\n#else\n    lights[1] = LightSource(vec3(-2., 2., 0.), 1., vec3(1, 1, 1), POINT_LIGHT_TYPE);\n#endif\n#ifdef CAMERA_ANIMATION\n    camera = Camera(1.5 * vec3(-cos(frame), 0., 1.5 * sin(frame)), 45., vec3(0, 0, 0), normalize(vec3(0, 1, 0)));\n#else\n    camera = Camera(vec3(-1., 0., 1.), 45., vec3(0, 0, 0), normalize(vec3(0, 1, 0)));\n#endif\n    View = lookAt(camera);\n}\n\n// ----------------  shading technics  ----------------\n\nvec3 Lambertian(Intersection i, LightSource light) {\n    vec3 L;\n    float intensity = light.intensity;\n    if (light.type == POINT_LIGHT_TYPE) {\n        L = light.position - i.P.xyz;\n        float d = length(L);\n        L = normalize(L);\n        intensity /= min(d * d, 1.);\n    } else {\n        L = -normalize(light.position);\n    }\n    vec3 col = i.baseColor.xyz;\n    #ifdef GAMMA_CORRECTION\n    col = pow(col, vec3(2.2));  // gamma correction to linear\n    #endif\n\n    return col * i.roughness * light.color * intensity * saturate(dot(i.N, L));\n           // + AMBIENT_WEIGHT * texture(iChannel2, i.N).xyz;\n}\n\nvec3 PerfectReflection(Intersection i, LightSource light) {\n    vec3 R = reflect(-i.V, i.N);\n    return texture(iChannel0, R).xyz;\n}\n\n// Fresnel term, Schlick's approximation\n// Schlick C. An inexpensive BRDF model for physically‐based rendering[C]//Computer graphics forum. Edinburgh, UK:\n// Blackwell Science Ltd, 1994, 13(3): 233-246.\nfloat F_Schlick(vec3 L, vec3 H_r, float f0) { return f0 + (1. - f0) * pow((1. - saturate(dot(L, H_r))), 5.); }\n\n// Bidirectional shadowing-masking function\n// Used Smith G Approximate, according to Walter et al.\n// Ref: http://jcgt.org/published/0003/02/03/paper.pdf\nfloat G_GgxSmith(float LdotN, float VdotN, float g) {\n    float g2 = g * g;\n    float lambdaV = LdotN * sqrt((-VdotN * g2 + VdotN) * VdotN + g2);\n    float lambdaL = VdotN * sqrt((-LdotN * g2 + LdotN) * LdotN + g2);\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-7f));\n    return 0.5 / (lambdaV + lambdaL + 1e-7f);\n}\n\n// Microfacet distribution function\n// Trowbridge-Reitz GGX function\nfloat D_GGX_TR(vec3 N, vec3 H, float d) {\n    float d2 = d * d;\n    float dotNH = saturate(dot(N, H));\n    float denomenator = dotNH * dotNH * (d2 - 1.) + 1.;\n    return d2 / (PI * denomenator * denomenator + 1e-7);\n}\n\nvec3 GGX(Intersection i, LightSource light) {\n    vec3 L;\n    float intensity = light.intensity;\n    if (light.type == POINT_LIGHT_TYPE) {\n        L = light.position - i.P.xyz;\n        float d = length(L);\n        L = normalize(L);\n        intensity /= min(d * d, 1.);\n    } else {\n        L = -normalize(light.position);\n    }\n    vec3 H = normalize(i.V + L);\n    float LdotN = saturate(dot(L, i.N));\n    float VdotN = saturate(dot(i.V, i.N));\n\n    float perceptualRoughness = i.roughness * i.roughness;\n    float roughness = max(perceptualRoughness, 0.002);\n    float F = F_Schlick(L, H, i.metallic);\n    float G = G_GgxSmith(LdotN, VdotN, roughness);\n    float _d = roughness * roughness;\n    float D = D_GGX_TR(i.N, H, _d);\n    float ggx = F * G * D;\n\n    // lambert model as diffuse part\n    vec3 diffuseLightColor = Lambertian(i, light);\n\n    vec3 HEnv = normalize(i.N + i.V);\n    float FEnv = F_Schlick(i.N, HEnv, i.metallic);\n\n    vec3 ggxColor = diffuseLightColor\n                    + texture(iChannel0, i.N).xyz * FEnv * AMBIENT_WEIGHT// * max(0., dot(i.N, L))\n                    + light.color * intensity * ggx;\n    #ifdef GAMMA_CORRECTION\n    ggxColor = pow(ggxColor, vec3(.4545)); // back to gamma\n    #endif\n    return ggxColor;\n}\n\n// ----------------  shading technics ends  ----------------\n\nvec3 Render(Ray r) {\n    vec3 col = vec3(0);\n\n    highp float t_min = INF;\n    int idx = -1;\n    for (int i = 0; i < SPHERE_N; i++) {\n        float t = SphereIntersect(r, spheres[i]);\n        if (t < t_min) {\n            t_min = t;\n            idx = i;\n        }\n    }\n\n    if (t_min < INF) {\n        for (int i = 0; i < LIGHT_N; i++) {\n            LightSource light = lights[i];\n            vec4 P = vec4(r.origin + r.direction * t_min, 1.);\n            vec3 N = normalize(P.xyz - spheres[idx].center);\n            Intersection intersection = Intersection(P, N, -r.direction, texture(iChannel1, PolarWrap(N)),\n                                                     BallMaterial.f0, BallMaterial.roughness);\n\n            col += GGX(intersection, light);\n        }\n    } else {\n        col = texture(iChannel0, r.direction).xyz;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(uv, 0);\n\n    SetupScene(iTime * SPEED);\n\n    // place screen infront of camera, transform to world space\n    Ray r = Ray(camera.position, normalize(inverse(View) * vec4(uv, 1, 0)).xyz, 0., 999.);\n\n    col = Render(r);\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}