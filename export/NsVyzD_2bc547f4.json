{"ver":"0.1","info":{"id":"NsVyzD","date":"1654570570","viewed":102,"name":"Temporal Explorer","username":"MisterSirCode","description":"Fiddling around.. This is just an experiment I forgot I had set \"unlisted\".. so now tis public... have fun I guess lol","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fractal","julia","interactive","burning","ship"],"hasliked":0,"parentid":"ssdyRf","parentname":"Julia of Mandelbrot"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = ((2.0 * fragCoord - iResolution.xy) / iResolution.x) * 2.0;\n    vec2 ms = ((2.0 * iMouse.xy - iResolution.xy) / iResolution.x) * 2.0;\n    float frac = texture(iChannel0, fragCoord / iResolution.xy).x;\n    \n    float p = length(uv - ms) - 0.025;\n    \n    if (p < 0.0) fragColor = vec4(vec3(1.0, 0.0, 0.0), 1.0);\n    else fragColor = vec4(vec3(0.4, 1.0, 1.3) * pow(frac, 2.0) * 1.5, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat mandelbrot(vec2 z, vec2 c) {\n    float l = 0.0;\n    for (l = 0.0; l < 100.0; l += 1.0) {\n        z = vec2(z.x * z.x - z.y * z.y, abs(2.0 * z.x * z.y)) + c;\n        if(dot(z, z) > 65536.0) break;\n    }\n    return l - log2(log2(dot(z, z))) + 4.0;\n}\n\nvec2 diskPt(vec2 p) {\n    return sqrt(p.x) * vec2(sin(6.2832 * p.y), cos(6.2832 * p.y));\n}\n\nbool useSquareDistribution = false; // Disk is much cleaner\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec4 pr = texture(iChannel0, fragCoord / res);\n    vec2 uv = ((2. * fragCoord - res) / res.x) * 2.;\n    vec2 ms = ((2. * iMouse.xy - res) / res.x) * 2.;\n    float ct = pr.w; // grab current time from last frame\n    if (useSquareDistribution) {\n        vec2 pad = 1.333 * hash21(mod(iTime, 1000.)) / res;\n        uv += pad;\n        ms += pad;\n    } else {\n        vec2 pad = 1.15 * diskPt(hash21(mod(iTime, 1000.))) / res;\n        uv += pad;\n        ms += pad;\n    }\n    \n    vec2 mnduv = vec2(uv.x + 1.2, uv.y + .2) * 2.;\n    vec2 julms = vec2(ms.x + 1.2, ms.y + .2) * 2.;\n    vec2 juluv = vec2(uv.x - 1., uv.y) * 2.;\n    \n    float fr; // frame, used for temporal denoising\n    \n    if (fragCoord.x > res.x / 2.0)\n        fr = mandelbrot(juluv, -julms) * 2.0;\n    else\n        fr = mandelbrot(vec2(0), -mnduv);\n    fr = (fr > 99.) ? 0. : sin(fr / 20.);\n    fr = clamp(fr, 0., 1.);\n    \n    float cfr = mix(fr, pr.x, .99);\n    cfr = mix(fr, cfr, clamp(ct, 0.0, 1.0));\n    \n    ct += 0.01;\n    // ct is basically a fake iTime. It transitions from the noisy image to the good image.\n    fragColor = vec4(cfr, res, ct);\n}","name":"Buffer A","description":"","type":"buffer"}]}