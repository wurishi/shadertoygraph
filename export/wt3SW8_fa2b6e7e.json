{"ver":"0.1","info":{"id":"wt3SW8","date":"1588252266","viewed":580,"name":"Voxel Traversal 2D","username":"spalmer","description":"lattice cell marching algorithm to compute which cells possibly intersect ray, in order.  Trying to get Bresenham style DDA to work w fractions.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["grid","line","bresenham","lattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this toy is so cluttered now, with variant implementations,\n// it really needs some work cleaning up.\n\n// btw this got forked into 3D in\n// toys https://shadertoy.com/view/WslBWH\n// and https://shadertoy.com/view/wdsfWn\n\n// iq's line segment distance, trimmed & renamed\n// just so I can see the mouse ray\nfloat seg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a; return length(p - b *\n        clamp(dot(p, b) / dot(b, b), 0., 1.));\n}\n\n// This is a testbed.  \n// A terrible testbed; I have better ones!\n// For this testbed, \n// the conditions and results of \n// the test are quite simple\n// and are communicated by \n// these global variables:\n\nbool celltouchesline = false;\n//vec2 qf;  // query pixel in grid space\nivec2 qi; // query pixel grid cell coordinate\n\n// simply checks if qi is among the cells visited\nbool Condition(ivec2 i) { return qi == i; }\n// return false to stop, true to keep going\nbool Traverse(ivec2 i) { celltouchesline = true; return true; }\n\n#if 0 \n// low-tech inefficient method I just made\n// just scans the segment's bounding box\n// for cells that are \"close enough\" to the line\n// which incorrectly flags some cells that it shouldn't FIXME\n// anyway yeah, it's way overly conservative and has issues\n// will flag too many cells that shouldn't be, but \n// will sort of get the job done for the time being\n// and is still better than the naive bounding\n// box iter without seg distance check.\n// really, if using a bounding box for each cell anyway,\n// could get away with just iterating the seg's bounding box.\n// anyway it basically *works* and \n// handles floating point coordinates properly.\n// it just isn't a very good algorithm.\nvoid Scan2B(vec2 pa, vec2 pb)\n{\n    ivec2 a = ivec2(floor(pa)), b = ivec2(floor(pb))\n        , d = b-a, s = sign(d);\n    if (s.x == 0) s.x = 1; // at least 1\n    if (s.y == 0) s.y = 1;\n    d += s;\n    for (int y = 0; y != d.y; y += s.y)\n    for (int x = 0; x != d.x; x += s.x) {\n        ivec2 p = ivec2(x,y) + a;\n        if (seg(vec2(p) + .5, pa, pb) <= .7072)\n\t        if (Condition(p)) // your condition\n                if (!Traverse(p)) // your traversal function\n       \t             break; \n   \t\t}\n}\n// this loop is a bit wacky due to bidirectionality.\n// if qi not in the [a,b] box, there's no\n// way it will flag a cell, could early out,\n// but this example should be kept simple\n#endif\n\n#if 0\n// try out some bresenham; \n// I have the original Gem book... doesn't help.\n// I'm sure I've done this before, I can't find my code though.\n\n// Integer voxel traversal\n\n// adapted from https://www.shadertoy.com/view/XdBGDG\n// by https://www.shadertoy.com/user/Dave_Hoskins\n\n// Originally from Graphics Gems IV\n// http://read.pudn.com/downloads56/sourcecode/graph/texture_mapping/194552/gemsiv/vox_traverse.c__.htm\n\n// only int adds...  old skool indeed!\n// when starting at p heading +d\n// you could obviously do something fancier\nvoid Scan2I(ivec2 p, ivec2 d)\n{\n\tivec2 s = sign(d), a = abs(d), b = a + a;\n\tint e = a.y - a.x, n = a.x + a.y;\n    for (int i = 0; i <= n; ++i) {\n\t\tif (Condition(p)) // your condition\n            if (!Traverse(p)) // your traversal function\n                 break; \n\t\tif (e < 0) {\n\t\t\tp.x += s.x;\n\t\t\te += b.y;\n\t\t} else {\n\t\t\tp.y += s.y;\n\t\t\te -= b.x;\n\t\t}\n    }\n}\n// actually a rather poor truncating wrapper over Scan2DI - do not use except to see Scan2D operate\nvoid Scan2IF(vec2 a, vec2 b)\n{\n    ivec2 o = ivec2(floor(a));\n\tScan2I(o, ivec2(floor(b))-o);\n}\n#endif\n\n#if 0\n// will need to modify this anyway since it must handle fractional starting position\n// and float vector direction\nvoid Scan2F(vec2 pa, vec2 pb)\n{ // not quite!  must initialize the error better\n\tvec2 d = pb - pa;\n    ivec2 s = ivec2(sign(d)), p = ivec2(floor(pa));\n    vec2 a = abs(d), b = a + a;\n\tfloat e = a.y - a.x;\n    int n = int(round(a.x) + round(a.y)); // idk if this is precise\n    // must bias away from .5 cell center depending on initial fraction of pa\n    // but I'll be damned if I can understand how to fudge this integer to account for that.\n    // e is really complicated.  Hoskins tore this out of the Gem already.\n    // but he didn't explain it to me when he did!  So I'm looking at it now\n    // trying to unravel the gradient ratios involved.  fun!\n    // Dammit I wish I hadn't lost my old implementation of this! \n    // I had this all worked out once upon a time.\n    // Alas I think I'll give up on it again for the day.  Hurts my brain.\n    vec2 f = pa - vec2(p);\n    vec2 bias = f - .5;\n\n    for (int i = 0; i <= n; ++i) {\n\t\tif (Condition(p)) // your condition\n            if (!Traverse(p)) // your traversal function\n                break;\n\t\tif (e < 0.) {\n\t\t\tp.x += s.x;\n\t\t\te += b.y;\n\t\t} else {\n\t\t\tp.y += s.y;\n\t\t\te -= b.x;\n\t\t}\n    }\n}\n// I actually need float precision in my coordinates\n// for perfect ray-cell traversal, so...\n// must redo part of the initialization anyway to handle that.\n// it's not that super tricky iirc.\n\n#endif \n// actual DDA - WIP\n\n// from https://shadertoy.com/view/ttyXRR\n#if 1\n// originally from unnick's https://shadertoy.com/view/wtXSW8\n// stripped down to just the DDA portion\n// the dda raycaster; returns fine distance traced which this toy doesn't use\nfloat Scan2DDA2(vec2 pa, vec2 pb)\n{ \n    vec2 ro = pa, pd = pb - pa\n    , rd = normalize(pd), nrd = normalize(rd)\n    , ad = abs(pd)\n    , dd = 1. / abs(nrd)\n    , pos = ro\n    , sd = fract(pos);\n    ivec2 mp = ivec2(floor(pa)) // tile iterator\n    , aid = abs(ivec2(floor(pb))-mp)\n    , st = ivec2(sign(rd)); // step direction\n    int side = 0;\n    if (st.x > 0) sd.x = 1. - sd.x;\n    if (st.y > 0) sd.y = 1. - sd.y;\n    sd *= dd;\n    int nsteps = 1+aid.x+aid.y;\n    for (int i = nsteps; --i >= 0; ) {\n        if (Condition(mp))\n            if (!Traverse(mp))\n            \tbreak;\n        side = int(sd.x >= sd.y);\n        switch (side) {\n            case 0: sd.x += dd.x; mp.x += st.x; break;\n        \tcase 1: sd.y += dd.y; mp.y += st.y; break;\n        }\n    }\n    float dist = float(mp[side]) - pos[side];\n    dist += float((1 - st[side]) / 2);\n    dist /= 1.*rd[side]; // unproject distance from axial to along ray\n    return dist;\n}\n#endif\n\n#if 0\n// from https://shadertoy.com/view/3lySWm\n// which is originally from https://shadertoy.com/view/ltXBz7\nfloat Scan2DDA3(vec2 m0, vec2 m1) //, vec2 result) \n{\n    vec2 ro = m0, rd = m1 - m0\n    , n = vec2(0), c = floor(ro) + .5;\n    ro -= c; // ro now just a (signed?) fraction\n    const int maxiter = 36; //40; //42; //\n    int niter = 0+int(ceil(abs(rd.x)))+int(ceil(abs(rd.y))); // borked\n    rd = normalize(rd);\n    float totald = 0.;\n    for (int s = min(niter,maxiter); s-- > 0; ) {\n        ivec2 q = ivec2(c + ro);\n        if (Condition(q))\n            if (!Traverse(q))\n            \tbreak;\n        vec2 d = (sign(rd)*.5 - ro) / rd;\n        float adv = min(d.x, d.y);\n        totald += adv; // all these small adds may not work though\n        ro += adv * rd;\n        n = -sign(rd) * step(d.xy, d.yx);\n        c -= n;\n       \tro += n;\n    }\n    return totald;\n}\n#endif\n// FIXME not quite working yet, need I bust out my sledgehammer?\n\n#if 1\n// my modification of ocb's idea\n// from ocb's https://shadertoy.com/view/4lscDn\n// was called getNextBox(); quite good DDA step function-\n// tiny, simple, completely dynamic, fast.  Clever!\n// but I had to change it up quite a bit to get it shoe-horned\n// into my existing framework, to provide the step distance required etc.\n// what I wound up with is pretty simple also; slightly refactored I suppose.\n\n// btw sign() for me on OpenGL ES is bugged and returns zero for zero inputs\n// instead of the expected positive 1, and also\n// can give slightly below 1.0 which truncates to zero incorrectly.\n// so I use these replacements:\nvec2 sgn(vec2 v)\n{\n    return vec2((v.x < 0. ? -1. : 1.)\n              , (v.y < 0. ? -1. : 1.));\n}\n\nvec3 sgn(vec3 v)\n{\n    return vec3((v.x < 0. ? -1. : 1.)\n              , (v.y < 0. ? -1. : 1.)\n              , (v.z < 0. ? -1. : 1.));\n}\n\nfloat nextCell(vec2 p, vec2 v)\n{\n    vec2 dt = (floor(p) + .5 + .5 * sgn(v) - p) / v;\n    return min(dt.x, dt.y);\n}\n\nfloat nextCell(vec3 p, vec3 v)\n{\n    vec3 dt = (floor(p) + .5 + .5 * sgn(v) - p) / v;\n    return min(min(dt.x, dt.y), dt.z);\n}\n\n// what makes a DDA special is the logic for multiple dimensions\n// to decide which is the *next* cell, whose boundary will be \n// crossed first.  Here that's a divide, some min, a step, and a few other ops.\n\nfloat Scan2DDAnext(vec2 pa, vec2 pb)\n{\n    float t = 0.;\n    vec2 ro = pa, pd = pb - pa\n    , rd = normalize(pd);\n    vec2 mp = pa; // tile iterator\n    ivec2 aid = abs(ivec2(floor(pb)-floor(pa)));\n    int nsteps = 1+aid.x+aid.y;\n    for (int i = nsteps; --i >= 0; ) {\n        ivec2 ip = ivec2(floor(mp));\n        if (Condition(ip))\n            if (!Traverse(ip))\n            \tbreak;\n        float tnc = nextCell(mp, rd);\n        tnc += 1e-5; // ensure we get all the way into the cell, since it's probably exactly on the edge\n\t\tt += tnc;\n        mp = ro + rd * t;\n    }\n    return t;\n}\n\n#endif\n\n#if 0\n// closer to ocb's originals\n// from ocb's https://shadertoy.com/view/4lscDn\n// was called getNextBox(); nicest DDA step function I've seen!\n// tiny, simple, completely dynamic, fast.  Clever!\n// TODO merge in somehow, try it out; I already rearranged\n// it somewhat, eliminated some temp variables used once.\n// changed dim (was boxDim) to an argument, etc.  Went back to 2D too.\n// Easy enough and good to have both variants in one place. --Sean\n// if you want to understand it, I made a 1D version that\n// simply uses sign to decide which way to step, plus or minus.\nfloat nextCell(float p, float v, float c) //, float dim)\n{ // since step(dt, dt) is equivalent to 1.0, just get rid of now-unused dt.\n    float d = sign(v); //, dt = ((c + d * .5) * dim - p) / v;\n    return c + d; // * step(dt, dt);\n}\n// it wound up not needing the dim, so what if none of them used dim?\n// I may have *caller* to do such coordinate system conversion/mapping,\n// so that the p coordinate here is always already in cell coordinates\n// which simplifies a few things\n// dim is size of cell hypercubes in p space, they don't have to\n// actually be the same size here, for these variants\n// which are closer to ocb's originals which were called getNextBox or getNextCell.  \n        // see, his may be just little too clever, as it integrates\n        // the tracking of the ray position in a way that is incompatible\n        // with keeping the same ray and just incrementing the offset along it.\n        // I prefer to avoid the accumulation of small errors from individual steps\n        // anyway I require new t, or delta to t, distance to the next cell\n    // knowing the cell id isn't helping much, for me; I need the distance to hit\n    // and, see, his thing is simply not set up to help calculate the needed step distance\n\n// key function to find the next Voxel along the ray\nvec2 nextCell(vec2 p, vec2 v, vec2 c, float dim)\n{\n    vec2 d = sign(v), dt = ((c + d * .5) * dim - p) / v;\n    return c + d * step(dt, vec2(min(dt.x, dt.y)));\n}\nvec3 nextCell(vec3 p, vec3 v, vec3 c, float dim)\n{\n    vec3 d = sign(v), dt = ((c + d * .5) * dim - p) / v;\n    return c + d * step(dt, vec3(min(min(dt.x, dt.y), dt.z)));\n}\n// p is a current position, c is corresponding id of cell\n// which p is currently inside, v is trace direction\n\n//vec2    return c + d * step(dt, vec2(min(dt.x, dt.y)));\n//vec3    return c + d * step(dt, vec3(min(min(dt.x, dt.y), dt.z)));\n// ocb's scanner was called browseBox and had totally different interface\n        //vec3 n = newBox - box; // but his allowed to find the hit normal with little cost!\n#endif\n\n#if 1 \n// extracting stb's voxel dda code\n// from https://shadertoy.com/view/Wt2cW3 or http://glslsandbox.com/e#58331.0\n// removed unneeded alpha / lighting stuff\n// kind of working, but needs tuned on the exit; records distance too early\n// also seems a little wonky on the traversal; unsure what's going on.\nfloat Scan2stb(vec2 m0, vec2 m1)\n{\n\tvec2 d = m1 - m0, s = sign(d), V = m0;\n\tint niter = int(floor(max(abs(d.x), abs(d.y)))) + 1;\n\tfor (int i = niter; i-- > 0; ) {\n        vec2 adj = mix(floor(V+s), ceil(V+s), .5-.5*s) - V\n        , xV = adj.x * vec2(1., d.y/d.x)\n        , yV = adj.y * vec2(d.x/d.y, 1.)\n        , dV = dot(xV,xV) < dot(yV,yV) ? xV : yV;\n        V += dV;\n        ivec2 q = ivec2(floor(V));\n        if (Condition(q))\n            if (!Traverse(q))\n            \tbreak;\n    }\n\tfloat dist;\n\t\tdist = length(V-m0); // seems wasteful to compute when not needed\n    return dist;\n}\n#endif\n\n#if 0\n// extracted the dda from kastorp's variant\n// of https://shadertoy.com/user/fb39ca4 's Voxel Game\n// https://shadertoy.com/view/MtcGDH\nfloat Scan2evolved(vec2 m0, vec2 m1)\n{\n    vec2 d = m1 - m0\n    , s = sign(d);\n    , rayInv = 1./d; // FIXME divides by zero\n\t, p = m0;\n    , mapPos = floor(p)\n    , sideDist = (mapPos - p + .5 + s*.5) * rayInv\n    , mask = vec2(0); \n    for (int i = 0; i < 32; ++i) {\n        if (i > 0)\n       \t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\tsideDist += mask * s * rayInv;\n        mapPos += mask * s;\n        //getVoxel(mapPos, vox, 3);\n        //etc.\n    }\n    return dist;\n}\n#endif\n// almost same as fb39ca4's original, must integrate all this back together somehow :)\n// or just pick one that works well\n#if 0\n// fb39ca4 makes some bad-ass DDA toys!  https://shadertoy.com/view/4dX3zl\n// based on the article http://lodev.org/cgtutor/raycasting.html btw\nfloat Scan2branchless(vec2 m0, vec2 m1)\n{\n\tivec2 q = ivec2(floor(m0));\n    vec2 d = m1 - m0\n    , deltaDist = abs(vec2(length(d)) / d) // FIXME divides by zero\n    , s = sign(d)\n\t, sideDist = (s * (vec2(q) - m0) + (s * .5) + .5) * deltaDist;\n\tivec2 rayStep = ivec2(s);\n\tivec2 aid = abs(ivec2(floor(m1)-floor(m0)));\n    int niter = 1+aid.x+aid.y;\n    for (int i = niter; i-- > 0; ) {\n        if (Condition(q))\n            if (!Traverse(q))\n            \tbreak;\n\t\t//Thanks kzy for the suggestion!\n        //bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        bvec2 mask = lessThanEqual(sideDist, sideDist.yx);\n\t\t// All components of mask are false except for the corresponding largest component\n\t\t// of sideDist, which is the axis along which the ray should be incremented.\n\t\tsideDist += vec2(mask) * deltaDist;\n\t\tq += ivec2(mask) * rayStep;\n\t}\n    return distance(vec2(q), m0); // FIXME not accurate yet\n}\n#endif\n\n#if 0\n// fork of Branchless Voxel Raycasting Tex by jt at https://shadertoy.com/view/7dK3D3\n// which is itself a fork of https://shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (with loop optimization by kzy),\n// based on the article http://lodev.org/cgtutor/raycasting.html.\n// ripe for cleanup!  hey... didn't I already clean up this same... crap yes, see above fb39ca4 toy ;)\n// well idk if I wanna do it again.  So far this doesn't work yet.\n// but it's great to have the original paper that fb39ca4's toy was based on, for reference!\nfloat Scan2jt(vec2 m0, vec2 m1)\n{\n    vec2 rayPos = m0;\n    vec2 rayDir = m1;\n    vec2 s = sign(rayDir);\n    ivec2 rayStep = ivec2(s);\n    rayDir = normalize(rayDir);\n    ivec2 mapPos = ivec2(floor(rayPos));\n    vec2 sideDist;\n    vec2 mask;\n    // core of https://shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n    int MAX_RAY_STEPS = 32;\n    vec2 deltaDist = 1.0 / abs(rayDir);\n    sideDist = (s * (vec2(mapPos) - rayPos + .5) + .5) * deltaDist; \n\n    for (int i = 0; i < MAX_RAY_STEPS; ++i) {\n        //if (getVoxel(mapPos)) continue;\n        if (Condition(mapPos))\n            if (!Traverse(mapPos))\n            \tbreak;\n\n        // Thanks kzy for the suggestion! for 3d\n        //mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        mask = vec2(lessThanEqual(sideDist.xy, sideDist.yx)); // for 2d\n        sideDist += mask * deltaDist;\n        mapPos += ivec2(mask) * rayStep;\n    }\n    // jt's texcoord addon recovering distance & subvoxel intersection-position of ray \n    // as described in https://lodev.org/cgtutor/raycasting.html (see \"perpWallDist\" there)\n    //float d = (mask.x ? sideDist.x - deltaDist.x : mask.y ? sideDist.y - deltaDist.y : mask.z ? sideDist.z - deltaDist.z : 0.0) / length(rayDir);\n    vec2 l = mask * (sideDist - deltaDist);\n    return l.x + l.y; // one will be zero\n}\n#endif\n\n#if 0\n// fb39ca4 makes some bad-ass DDA toys!  https://shadertoy.com/view/ldl3DS\n// pretty much same thing, but has some details I may need\nfloat Scan2branchless(vec2 m0, vec2 m1)\n{\n\tivec2 q = ivec2(floor(m0));\n    vec2 d = m1 - m0\n\t, deltaDist = abs(vec3(length(d)) / d) // FIXME divides by zero\n\t, s = sign(d)\n\t, sideDist = (s * (vec2(q) - m0) + s * .5 + .5) * deltaDist\n\t, mask;\n\tivec2 aid = abs(ivec2(floor(m1)-floor(m0)));\n    int niter = 1+aid.x+aid.y;\n    for (int i = niter; i-- > 0; ) {\n        if (Condition(q))\n            if (!Traverse(q))\n            \tbreak;\n\t\t//mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n        mask = step(sideDist, sideDist.yx); // TODO 2d\n\t\tsideDist += mask * deltaDist;\n\t\tq += mask * s;\n\t}\t\n\tvec2 /*intersectPlane = mapPos + vec3(lessThan(rayDir, vec3(0)))\n\t,*/ endRayPos = d / sum(mask * d)\n        * sum(mask * (vec2(q) + vec3(lessThan(d, vec3(0))) - m0))\n        + m0;\n    return totaldist; // TODO\n}\n#endif\n\n#if 0\n// from my unlisted deconstruction https://shadertoy.com/view/3lySWm\n// refactoring https://shadertoy.com/view/ltXBz7\n// by https://shadertoy.com/user/glk7\n// Created by genis sole - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\nfloat Scan2glk7(vec2 m0, vec2 m1) \n{\n    vec2 ro = m0\n    , rd = normalize(m1 - m0)\n    , n = vec2(0)\n    , c = floor(ro) + .5\n//    , q = floor(uv) + .5\n    , s = sign(rd)\n    //, v = vec2(point(uv, e, ro), step(.5, distance(q, c)))\n    ;\n    ro -= c;\n    float totald = 0.;\n    const int maxiter = 36; //40; //42; //\n    for (int it = maxiter; it-- > 0; ) {\n        vec2 d = (s*.5 - ro) / rd;\n        ro += min(d.x, d.y) * rd;\n        n = -s * step(d, d.yx);\n        c -= n;\n       \tro += n;\n//        totald += n;\n    }\n    return totald;\n}\n#endif\n\nconst int grid = 5;\nconst float scale = 1.1 * float(grid-1);\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n    return (s+s-r) * scale / r.y + .5;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    float a = .2 * iTime;\n    vec2 R = iResolution.xy\n\t\t, q = StoQ(p, R);\n\tvec2 m0 = StoQ(iMouse.zw, R)\n       , m1 = StoQ(iMouse.xy, R);\n    if (iMouse.z <= 0.) {\n        m0 = vec2(.5); m1 = m0 + float(grid-1)*vec2(vec2(sin(a), cos(a)));\n    }\n\tqi = ivec2(floor(q)); // gridcell\n\tcelltouchesline = false;\n    float l =\n    Scan2DDAnext //Scan2jt //Scan2DDA2 //Scan2branchless //Scan2stb //Scan2DDA3 //Scan2F //Scan2B //Scan2IF //\n        (m0, m1);\n    vec2 hp = m0 + normalize(m1 - m0) * l;\n    bool h = celltouchesline;\n    float g = h ? .1 : .85;\n    if (((qi.x^qi.y)&1)!=0) g += .05; // checks\n    g += max(0., 1.-.25*R.y/scale*seg(q, m0, m1));\n    g += max(0., .5 - 12.*(distance(hp, q) - .1));\n\tc = vec4(vec3(sqrt(g)), 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}