{"ver":"0.1","info":{"id":"MXjSDy","date":"1711036238","viewed":40,"name":"Perlin noise try","username":"vsav","description":"This is a sample of Perlin noise shader. I got some code for wiki, so don't forget to check it out as well ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float interpolate(float a0, float a1, float w)\n{\n    return (a1 - a0) * w + a0;\n}\n\nvec2 randomGradient(int ix, int iy) {\n    // From Wiki\n    const int w = 8 * 4;\n    const int s = w / 2; // rotation width\n    int a = ix, b = iy;\n    a *= 3284157443; b ^= a << s | a >> w-s;\n    b *= 1911520717; a ^= b << s | b >> w-s;\n    a *= 2048419325;\n    float random = float(float(a) * (3.14159265 / float(~(~0u >> 1)))); // in [0, 2*Pi]\n    vec2 v;\n    v.x = cos(random); v.y = sin(random);\n    return v;\n}\n\nfloat dotGridGradient(int ix, int iy, float x, float y) {\n    // Get gradient from integer coordinates\n    vec2 gradient = randomGradient(ix, iy);\n    // Maybe random func will work?\n    // vec2 gradient = random(ix);\n    \n    // Compute the distance vector\n    float dx = x - float(ix);\n    float dy = y - float(iy);\n\n    // Compute the dot-product\n    return (dx * gradient.x + dy * gradient.y);\n}\n\nfloat perlin(float x, float y) {\n    // Determine grid cell coordinates\n    int x0 = int(floor(x));\n    int x1 = x0 + 1;\n    int y0 = int(floor(y));\n    int y1 = y0 + 1;\n\n    // Determine interpolation weights\n    // Could also use higher order polynomial/s-curve here\n    float sx = x - float(x0);\n    float sy = y - float(y0);\n\n    // Interpolate between grid point gradients\n    float n0, n1, ix0, ix1, value;\n\n    n0 = dotGridGradient(x0, y0, x, y);\n    n1 = dotGridGradient(x1, y0, x, y);\n    ix0 = interpolate(n0, n1, sx);\n\n    n0 = dotGridGradient(x0, y1, x, y);\n    n1 = dotGridGradient(x1, y1, x, y);\n    ix1 = interpolate(n0, n1, sx);\n\n    value = interpolate(ix0, ix1, sy);\n    return value; // Will return in range -1 to 1. To make it in range 0 to 1, multiply by 0.5 and add 0.5\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float perl = perlin(fragCoord.x * iTime / 10.0, fragCoord.y * iTime / 10.0);\n    float perl = perlin(fragCoord.x, fragCoord.y);\n    // vec3 col = vec3(perl) * iTime;\n    vec3 col = vec3(perl);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}