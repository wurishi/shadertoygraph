{"ver":"0.1","info":{"id":"dtyyDD","date":"1702304105","viewed":33,"name":"1.3.4 Cornell Box","username":"yqzhang4480","description":"1.3 基本光照模型","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lighting","learning","raymatching"],"hasliked":0,"parentid":"mlycWW","parentname":"1.3.3 II 盒中阴影"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NONE -0.\n#define SPHERE 1.\n#define BOX_LEFT 2.\n#define BOX_RIGHT 3.\n#define BOX_OTHERS 4.\nvec3 calcNormal( in vec3 p );\n\nfloat sdBox(vec3 p, vec3 center, vec3 size) {\n    vec3 d = abs(p - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n// returns [x, y], where x := distance, y := index of hitted surface\nvec2 sdCornellBox(vec3 p) {\n    vec3 outerBox = vec3(1.01, 1.01, 1.01);\n    vec3 innerBox = vec3(1, 1.005, 1);\n    float d1 = sdBox(p, vec3(0,0,0), outerBox);\n    float d2 = sdBox(p, vec3(0,0.01,0), innerBox);\n    float dist = max(d1, -d2);\n    float hit_face = BOX_OTHERS;\n    if (abs(p.x) > 0.99) { hit_face = (p.x > 0.0) ? BOX_LEFT : BOX_RIGHT; }\n    return vec2(dist, hit_face);\n}\nvec2 sdSphere( vec3 p, vec3 center, float radius )\n{\n    return vec2(length(p - center) - radius, SPHERE);\n}\nvec2 sdScene( vec3 p )\n{\n    vec2 s1 = sdSphere(p, vec3(-0.4,-0.4,-0.5), 0.5);\n    vec2 s2 = sdSphere(p, vec3(0.4,0.4,-0.5), 0.5);\n\n    vec2 s = (s1.x < s2.x) ? s1 : s2;\n    vec2 b = sdCornellBox(p);\n    float d = s.x < b.x ? s.x : b.x;\n    float f = s.x < b.x ? s.y : b.y;\n    return vec2(d, f);\n}\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.00001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene( p + k.xyy*h ).x + \n                      k.yyx*sdScene( p + k.yyx*h ).x + \n                      k.yxy*sdScene( p + k.yxy*h ).x + \n                      k.xxx*sdScene( p + k.xxx*h ).x );\n}\n\nvec4 surfaceColor( float index )\n{\n    if (index == BOX_LEFT) { return vec4(1, 0.2, 0.2, 1); }\n    else if (index == BOX_RIGHT) { return vec4(0.2, 1, 0.2, 1); }\n    else if (index == SPHERE) { return vec4(0.3, 0.9, 1.0, 1); }\n    else if (index == BOX_OTHERS) { return vec4(0.85, 0.85, 0.7, 1); }\n    return vec4(0.2, 0.2, 0.2, 1.);\n}\n\nvec2 raymarch( in vec3 ro, in vec3 rd )\n{\n    float depth = 0.0;\n    for (int i = 0; i < 1000; i++) {\n        vec3 p = ro + depth * rd;\n        vec2 ret = sdScene(p);\n        if (ret.x < .0001) { return vec2(depth, ret.y); }\n        depth += ret.x;\n    }\n    return vec2(depth, NONE);\n}\nfloat shadowRaymarch(vec3 ro, vec3 rd, float distance_to_light) {\n    float depth = 0.01;  // 较小的初始偏移量，避免自阴影\n    float res = 1.0;     // 初始化阴影系数为完全照亮\n    for (int i = 0; i < 1000; ++i) {\n        float dist = sdScene(ro + depth * rd).x;\n        if (dist < 0.0001) return 0.35;  // 发现阻挡，处于阴影中\n        //res = min(res, 10.0 * dist / depth);  // 阴影软化\n        depth += dist / 1.0;\n        if (depth >= distance_to_light) { break; }\n    }\n    return max(res, 0.005);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float xmax = iResolution.x / iResolution.y;\n    float fovy = 38.0 * 3.14159 / 180.0;\n    \n    float mx = iMouse.x / iResolution.x;\n    float my = iMouse.y / iResolution.y;\n\n    vec3 p_light = vec3(1. - 2. * mx,-1. + 2. * my, 0.99 * cos(iTime / 2.));\n    //vec3 p_light = vec3(0,0,-0.5);\n    vec4 c_light = vec4(1.0,1.0,1.0, 1.0);\n    float i_light = 1.;\n    \n\n    vec3 p_camara = vec3(0,2.5,0);\n    vec3 look_at = normalize(-p_camara);\n    vec3 u_camara = cross(look_at, vec3(0.,0.,1.));\n    vec3 v_camara = -cross(look_at, u_camara);\n    vec3 bia = (u_camara * (uv.x - xmax / 2.) / (0.5)) + (v_camara * (uv.y - 0.5) / 0.5);\n    vec3 raydir = normalize(0.5 / tan(fovy/2.) * look_at + bia);\n    \n    vec2 ret = raymarch(p_camara, raydir);\n    vec4 color = vec4(0.05,0.05,0.05,1.);\n    if (ret.y != NONE) {\n        vec3 p_surface = p_camara + ret.x * raydir;\n        vec3 l = p_light - p_surface;\n        float shadow = shadowRaymarch(p_surface, normalize(l), length(l));\n        vec3 n = calcNormal(p_surface);\n        \n        color += i_light * c_light * max(0.0, dot(normalize(l), n)) * shadow * surfaceColor(ret.y) / dot(l, l);\n        vec3 h = normalize(normalize(l) + -raydir);\n        color += i_light * c_light * pow(max(0.0, dot(n, h)), 1e3) * shadow / dot(l, l); \n    } else { color = surfaceColor(ret.y); }\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}