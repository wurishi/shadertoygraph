{"ver":"0.1","info":{"id":"st3yzN","date":"1659423041","viewed":143,"name":"sparkle test","username":"alex2022","description":"test","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["sparkle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Credit to https://www.shadertoy.com/view/XdlXDn xwize for the raymarching\n//Credit to https://www.shadertoy.com/view/ll2fzt tachyonflux for the glints\n//gold color function derived from https://www.shadertoy.com/view/WlSGWw nabr\n\n//basically i just added floor(pos*layers)/layers to the glints so that they stay a little longer\n\n///RAYMARCHING UTILS\nhighp float Time;\n\nconst highp float PI = 3.1415926;\nconst highp float INV_PI = 1.0/PI;\nconst highp float PI_2 = PI * 2.0;\n\nconst highp float MARCH_EPS = 0.065;\nconst highp float GRAD_EPS = 0.005;\n\n//https://www.shadertoy.com/view/3tGcWt\n//Buffer A\n#define THRESHOLD 0.00\nconst int SAMPLES = 87;\nconst vec3 kernel[SAMPLES] = vec3[](\n                                 vec3(-3, -2, 0.0099343), vec3(-3, -1, 0.0158491), vec3(-3, 0, 0.0198582), vec3(-3, 1, 0.0193742), vec3(-3, 2, 0.01562), vec3(-3, 3, 0.0092086), vec3(-2, -3, 0.0036023), vec3(-2, -2, 0.017351), vec3(-2, -1, 0.026431), vec3(-2, 0, 0.0318141), vec3(-2, 1, 0.0318476), vec3(-2, 2, 0.0282652), vec3(-2, 3, 0.0207794), vec3(-2, 4, 0.0100408), vec3(-1, -3, 0.0118306), vec3(-1, -2, 0.0230702), vec3(-1, -1, 0.028688), vec3(-1, 0, 0.0287297), vec3(-1, 1, 0.0291755), vec3(-1, 2, 0.0288904), vec3(-1, 3, 0.0242141), vec3(-1, 4, 0.0133157), vec3(0, -3, 0.0177183), vec3(0, -2, 0.0269386), vec3(0, -1, 0.0255012), vec3(0, 0, 0.0231038), vec3(0, 1, 0.0240891), vec3(0, 2, 0.0266765), vec3(0, 3, 0.026509), vec3(0, 4, 0.0185881), vec3(1, -4, 0.0066892), vec3(1, -3, 0.0225386), vec3(1, -2, 0.0271861), vec3(1, -1, 0.0236909), vec3(1, 0, 0.0199988), vec3(1, 1, 0.0204911), vec3(1, 2, 0.0250744), vec3(1, 3, 0.0265619), vec3(1, 4, 0.0210398), vec3(2, -4, 0.0087099), vec3(2, -3, 0.0241667), vec3(2, -2, 0.027311), vec3(2, -1, 0.0227511), vec3(2, 0, 0.019024), vec3(2, 1, 0.0192731), vec3(2, 2, 0.023786), vec3(2, 3, 0.0278565), vec3(2, 4, 0.022605), vec3(2, 5, 0.0069317), vec3(3, -4, 0.0080222), vec3(3, -3, 0.0218081), vec3(3, -2, 0.0268296), vec3(3, -1, 0.0238996), vec3(3, 0, 0.0200351), vec3(3, 1, 0.0195484), vec3(3, 2, 0.0230739), vec3(3, 3, 0.0269896), vec3(3, 4, 0.0210053), vec3(3, 5, 0.0032463), vec3(4, -3, 0.0189985), vec3(4, -2, 0.026861), vec3(4, -1, 0.0267855), vec3(4, 0, 0.0236707), vec3(4, 1, 0.0230364), vec3(4, 2, 0.0262396), vec3(4, 3, 0.0261808), vec3(4, 4, 0.0176466), vec3(5, -3, 0.0156334), vec3(5, -2, 0.0255458), vec3(5, -1, 0.0285479), vec3(5, 0, 0.029006), vec3(5, 1, 0.0285642), vec3(5, 2, 0.0279639), vec3(5, 3, 0.0220895), vec3(5, 4, 0.011235), vec3(6, -3, 0.007862), vec3(6, -2, 0.021451), vec3(6, -1, 0.0280171), vec3(6, 0, 0.0326608), vec3(6, 1, 0.032852), vec3(6, 2, 0.0261432), vec3(6, 3, 0.0160087), vec3(7, -2, 0.0028554), vec3(7, -1, 0.0142694), vec3(7, 0, 0.0180889), vec3(7, 1, 0.0194572), vec3(7, 2, 0.0142807)\n                             );\n\nvec3 blurImage(sampler2D tex, vec2 uv, float coc) {\n    // uv *= 0.1;\n    ivec2 size = textureSize(tex, 0);\n    vec2 pix = 1.0 / vec2(float(size.x), float(size.y));\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < SAMPLES; i++) {\n        vec3 tap  = kernel[i];\n        vec3 samp = texture(tex, (uv + pix * tap.xy * coc)).rgb; //Multiply coords for some cheap detail\n        samp  = max(samp - THRESHOLD, 0.) / (1. - THRESHOLD);\n        color += tap.z * samp; // *vec3(0.8,0.7,1);\n    }\n\n    return color;\n}\n\nvec3 SampleSpriteTexture(sampler2D tex, vec2 uv, float coc)\n{\n    ivec2 size = textureSize(tex, 0);\n    vec2 offset = coc / vec2(float(size.x), float(size.y));\n\n    // 左上\n    vec4 color = texture(tex, uv + vec2(-1.0, -1.0) *  offset) * 0.0947416;\n    // 上\n    color += texture(tex, uv + vec2(0.0, -1.0) * offset) * 0.118318;\n    // 右上\n    color += texture(tex, uv + vec2(1.0, -1.0) * offset) * 0.0947416;\n    // 左\n    color += texture(tex, uv + vec2(-1.0, 0.0) * offset) * 0.118318;\n    // 中\n    color += texture(tex, uv + vec2(0.0, 0.0) * offset) * 0.147761;\n    // 右\n    color += texture(tex, uv + vec2(1.0, 0.0) * offset) * 0.118318;\n    // 左下º\n    color += texture(tex, uv + vec2(-1.0, 1.0) * offset) * 0.0947416;\n    // 下\n    color += texture(tex, uv + vec2(0.0, 1.0) * offset) * 0.118318;\n    // 右下\n    color += texture(tex, uv + vec2(1.0, 1.0) * offset) * 0.0947416;\n\n    float threshold = 0.00;\n    color = max(color - threshold, 0.) / (1. - threshold);\n    return color.rgb;\n}\n\n// fork of original 'A river' by Pierco https://shadertoy.com/view/MsSGWK\n// https://www.shadertoy.com/view/WsByzd\n#define T(p, lod) textureLod(iChannel0, p, lod).rgb\n\nvec3 flare(vec2 uv, vec2 dir, float brite)\n{\n    vec3 c = vec3(0);\n    vec2 gd = dir * .18; //vec2(-.02,.05); //, vec2(-.03,444.03);\n    // FIXME directions should take buffer aspect ratio into account\n    const float stp = .01;\n    for (float f = 0.; f < 1.001; f += stp)\n        c += .1 * pow(max(vec3(0),\n             T(uv + gd * (f * 2. - 1.), 0.)\n             - .9), vec3(8.));\n    return c * brite;\n}\n\nvec3 getFlare(vec2 uv)\n{\n    vec3 c = T(uv, 0.); //vec3(0); //\n    c += flare(uv, vec2(0., 1.2), 4.5);\n    c += flare(uv, vec2(.4, .7), 3.3);\n    c += flare(uv, vec2(-.3, .6), 3.4);\n    c += flare(uv, vec2(0.3, .0), 3.4);\n    c = max(c, vec3(0.));\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tTime = iTime;\n\t\n\thighp vec2 uv = fragCoord.xy / vec2(iResolution.x,iResolution.y);\n    \n    vec3 color = vec3(0.0);\n    vec4 sampleCurrent = texture(iChannel0, uv);\n    \n    //RESULTING COLOR\n    \n    //vec3 col = computeColor(camPos,camDir);\n    if (uv.x > iMouse.x / iResolution.x) {\n        if (uv.y > iMouse.y / iResolution.y) {\n            //右上\n            color = blurImage(iChannel0, uv, cos(iTime / 3.0));\n        } else {\n            //右下\n            color = SampleSpriteTexture(iChannel0, uv, 1.0);\n        }\n        \n    } else {\n        if (uv.y > iMouse.y / iResolution.y) {\n            //left up\n            color = sampleCurrent.rgb;\n        } else {\n            //left down\n            color = getFlare(uv);\n        }\n \n    }\n    \n    fragColor = vec4(color, 1.0);\n    \n    fragColor *= smoothstep( 0.0, 0.005, abs((fragCoord.x - iMouse.x) / iResolution.x) );\n    fragColor *= smoothstep( 0.0, 0.005, abs((fragCoord.y - iMouse.y) / iResolution.y) );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Credit to https://www.shadertoy.com/view/XdlXDn xwize for the raymarching\n//Credit to https://www.shadertoy.com/view/ll2fzt tachyonflux for the glints\n//gold color function derived from https://www.shadertoy.com/view/WlSGWw nabr\n\n//basically i just added floor(pos*layers)/layers to the glints so that they stay a little longer\n\n///RAYMARCHING UTILS\nhighp float Time;\n\nconst highp float PI = 3.1415926;\nconst highp float INV_PI = 1.0/PI;\nconst highp float PI_2 = PI * 2.0;\n\nconst highp float MARCH_EPS = 0.065;\nconst highp float GRAD_EPS = 0.005;\n\nstruct sdv\n{\n    highp float d;\n    highp int idx;\n};\n\nstruct rayHit\n{\n    highp vec3 p;\n    highp int idx;\n};\n\nsdv combine(sdv a, sdv b)\n{\n    if(a.d < b.d)\n    {  \n        return a;\n    }\n    return b;\n}\n\nconst int IDX_ROOM = 1;\nconst int IDX_ROOM_BOTTOM = 2;\nconst int IDX_SPHERE = 3;\n\nsdv scene(highp vec3 p)\n{\n    sdv sphere;\n    sphere.idx = IDX_SPHERE;\n\n\tvec3 c = vec3(0.0,0.0,0.0);\n\tfloat r = 24.0 + 0.5*(sin(0.05*p.x*p.y+iTime*1.0));\n\tsphere.d = length(p-c) - r;\n\t\n    return sphere;\n}\n\nhighp vec3 sceneGrad(highp vec3 p)\n{\n    const highp float h = GRAD_EPS;\n    highp vec3 g;\n    g.x = scene(p+vec3(h,0.0,0.0)).d - scene(p-vec3(h,0.0,0.0)).d;\n    g.y = scene(p+vec3(0.0,h,0.0)).d - scene(p-vec3(0.0,h,0.0)).d;\n    g.z = scene(p+vec3(0.0,0.0,h)).d - scene(p-vec3(0.0,0.0,h)).d;\n    return g / (2.0*h);\n}\n\nrayHit rayQuery(highp vec3 start, highp vec3 dir)\n{\n    highp float d = 0.0;\n    const highp float eps = MARCH_EPS;\n    const int numIter = 76;\n    \n    for(int i = 0; i < numIter; ++i)\n    {\n        highp vec3 p = start + dir * d;\n        sdv v = scene(p);\n        if(v.d < eps)\n        {\n            rayHit ret;\n            ret.idx = v.idx;\n            ret.p = p;\n            return ret;\n        }\n        \n        d += v.d;\n    }\n    \n    rayHit ret;\n    ret.idx = -1;\n    ret.p = vec3(0.0);\n    return ret;\n}\n\nhighp mat4 lookAtInv(highp vec3 eyePos, highp vec3 targetPos, highp vec3 upVector)\n{\n    highp vec3 forward = normalize(targetPos - eyePos);\n    highp vec3 right = normalize(cross(forward,upVector));\n    upVector = normalize(cross(right,forward));\n    \n    highp mat4 r;\n    r[0] = vec4(right,0.0);\n    r[1] = vec4(upVector,0.0);\n    r[2] = vec4(-forward,0.0);\n    r[3] = vec4(eyePos,1.0);\n    return r;\n}\n\n// COLORING THE OBJECT\n\nvec2 noise( in vec3 x )\n{\n    vec3 ip = floor(x);\n    vec3 fp = fract(x);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec4 rz = textureLod( iChannel1, (tap+0.5)/256.0, 0.0 );\n\treturn mix( rz.yw, rz.xz, fp.z );\n}\n\nhighp vec3 computeColor(highp vec3 camPos, highp vec3 camDir)\n{\n    rayHit q = rayQuery(camPos,camDir);\n    if(q.idx >= 0)\n    {\n        highp vec3 normal = normalize(sceneGrad(q.p));\n        float t = iTime;\n        vec3 n = normal;\n        \n        /////BASE COLOR\n        \n        //FRESNEL \n        \n        float fre = clamp(1. + dot(camDir,normal),-1.,1.);\n        float edge = sqrt(1.2-pow(fre,1./4.2));\n        \n        \n        //PICK YOUR COLOR\n        \n        vec3 colorPick = vec3(.65, .45, 0.);\n        \n        //COLOR FROM NORMALS AND FRESNEL\n        \n        vec3 c = 2.25*-sin(sin(t*0. + n.x*1.+ 1.57 + sin(n.z*1. + 0.76)) + n.y + t*0.+  colorPick);\n        float ss = min(.5 - edge, smoothstep(.45 - edge, 1., edge));\n        c *= ss;\n        \n        ///////GLINTS/GLITTER COMPUTATION\n        \n        #define PRIMARY_INTENSITY 0.3\n        #define PRIMARY_CONCENTRATION 6.\n        #define SECONDARY_INTENSITY 5.\n        #define SECONDARY_CONCENTRATION 0.9\n\n        // HOW BIG THE GLITTER SPECKS ARE ; BIGGER -> SMALLER SPECKS\n        // (7 is probably the smallest I would go)\n        \n        float scale = 10.;\n        q.p = floor(q.p*scale)/scale;\n        \n        vec3 ligt = vec3(1.);\n        vec3 h = normalize(ligt-camDir);\n        float nl = dot(n,ligt);\n        \n        vec3 coord = q.p*.5;\n        coord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n        coord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n        vec3 coord2 = coord;\n        \n        //first layer (inner glints)\n        float pw = .5*((iResolution.x));\n        vec3 aniso = vec3( noise((coord*pw)), noise((coord.yzx*pw)) )*2.0-1.0;\n        aniso -= n*dot(aniso,n);\n        float anisotropy = min(1.,length(aniso));\n        aniso /= anisotropy;\n        anisotropy = .55;\n        float ah = abs(dot(h,aniso));\n        float nh = abs(dot(n,h));\n        float qa = exp2((1.1-anisotropy)*3.5);\n        nh = pow( nh, qa*PRIMARY_CONCENTRATION );\n        nh *= pow( 1.-ah*anisotropy, 10.0 );\n        vec3 glints = c*nh*exp2((1.2-anisotropy)*PRIMARY_INTENSITY);\n\n        //second layer (outer glints)\n        pw = .145*((iResolution.x));\n        vec3 aniso2 = vec3( noise(coord2*pw), noise(coord2.yzx*pw).x )*2.0-1.0;\n        anisotropy = .6;\n        float ah2 = abs(dot(h,aniso2));\n        float nh2 = abs(dot(n,h));\n        float q2 = exp2((.1-anisotropy)*3.5);\n        nh2 = pow( nh, q2*SECONDARY_CONCENTRATION );\n        nh2 *= pow( 1.-ah2*anisotropy, 150.0 );\n        vec3 glints2 = c*nh2*((1.-anisotropy)*SECONDARY_INTENSITY);\n           \n        ///// ADD BASE COLOR AND GLINTS/GLITTER LAYERS   \n           \n        vec3 col;\n        col = vec3(c)/2.;\n        //col += (glints+glints2);\n        col += glints2;\n\n        return col;\n    }\n\t\n    return texture(iChannel0,camDir).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tTime = iTime;\n\t\n\thighp vec2 uv = fragCoord.xy / vec2(iResolution.x,iResolution.y);\n    \n    //RAYMARCHING STUFF\n\n\tfloat r = 120.0;\n\tfloat s = 0.;\n    float a = 1.2;\n\thighp mat4 m = lookAtInv(vec3(r*cos(Time*s + a),sin(Time*s + a)*50.0,r*sin(Time*s+a)),vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0));\n\thighp float sw = 0.0;\n\t\n\tconst highp float aspect = 2.0;\n\thighp vec3 camPos = vec3((uv.x-0.5)*aspect,uv.y-0.5,-30.);\n\thighp vec3 camDir = normalize(vec3(aspect*(uv.x-0.5),uv.y-0.5,-1.5-sw));\n\n    camPos = ( m * vec4(camPos,1.0) ).xyz;\n    camDir = ( m * vec4(camDir,0.0) ).xyz;\n    \n    //RESULTING COLOR\n    \n    vec3 col = computeColor(camPos,camDir);\n    fragColor = vec4(col,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}