{"ver":"0.1","info":{"id":"mtlczf","date":"1691031756","viewed":114,"name":"shadow/lighting test","username":"Swifter","description":"the raymarching journey continues","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\nconst vec3 UP = vec3(0, 1, 0);\nconst vec3 WHITE = vec3(1, 1, 1);\n\nconst float CAMERA_BACKWARD = 10.;\nconst float CAMERA_UPWARD = 2.;\nconst float PROJECTION_DIST = 0.6;\n\nconst float MAX_DIST = 30.;\nconst float GRID_SIZE = 1.;\n\nconst float SUN_THRESHOLD = 0.993;\n\nconst float SPHERE_RADIUS = 2.;\nconst vec3 SPHERE_CENTER = UP * (SPHERE_RADIUS + 1.5);\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x) {\n    return clamp(x, 0., 1.);\n}\n\nvec3 getSunColor() {\n    return 0.9 + 0.1*cos(iTime * 2.3 + vec3(0,1,2));\n}\n\nvec3 getSphereCenter() {\n    return SPHERE_CENTER + UP * sin(iTime * 3.) * 1.2;\n}\n\nvec3 getSunDir() {\n    return normalize(vec3(1., sin(iTime * 2.5) * 0.2 + 0.5, 0.));\n}\n\nvec3 skyColor(vec3 rayForward) {\n    float skyDot = dot(getSunDir(), rayForward);\n    float skySmooth = smoothstep(-0.5, 1., skyDot);\n    vec3 col = mix(vec3(0.4, 0.4, 0.4), getSunColor(), skySmooth);\n    \n    if (skyDot > SUN_THRESHOLD) {\n        float strength = (skyDot - SUN_THRESHOLD) * 1. / (1. - SUN_THRESHOLD);\n        col += WHITE * pow(strength, 5.);\n    }\n    \n    return col;\n}\n\nfloat sdfShadowScene(vec3 pos) {\n    return length(pos - getSphereCenter()) - SPHERE_RADIUS;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = sdfShadowScene(ro + t*rd);\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\nfloat random(vec2 st, int seed) {\n    return fract(sin(dot((st.xy + float(seed)),\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat voronoi2D(vec2 grid, int seed) {\n    vec2 centerPos = floor(grid);\n    float minDist = 1.;\n    \n    for (int x = 0; x <= 2; x++) {\n        for (int y = 0; y <= 2; y++) {\n            vec2 gridPos = centerPos + vec2(x, y);\n            float randX = random(gridPos, seed);\n            float randY = random(gridPos, seed + 1);\n            vec2 randOffset = vec2(randX, randY);\n            float dist = length(grid - gridPos + randOffset);\n            \n            if (dist < minDist) {\n                minDist = dist;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nfloat smax0(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nvec3 floorMaterial(vec3 currentPos, vec3 rayForward, float totalDist) {\n    float tileBrightness = smax0(voronoi2D(currentPos.xz + iTime * 5., 1), 0.2, 4.);\n    vec3 col = vec3(0.9,0.95,1) * mix(0.2, 0.8, tileBrightness);\n    vec3 sunDir = getSunDir();\n                \n    vec3 reflectionVec = rayForward * vec3(1, -1, 1);\n    float reflectionStrength = saturate(dot(reflectionVec, sunDir));\n    col = mix(col, skyColor(reflectionVec), reflectionStrength * 0.6);\n                \n    if (length(currentPos) < 20.) {\n        float shadow = softshadow(currentPos, sunDir, 0., 20., 0.3);\n        col *= shadow;\n    }\n                \n    return mix(col, skyColor(rayForward), 1. - pow(1. - totalDist / MAX_DIST, 3.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 sunColor = getSunColor();\n    vec3 sunDir = getSunDir();\n    \n    // Construct coordinate space\n    float worldRot = mod(iTime, PI * 2.);\n    \n    if (iMouse.z > 0.) {\n        worldRot = PI * 2. * iMouse.x / iResolution.x;\n    }\n    \n    vec3 forward = vec3(cos(worldRot), 0, sin(worldRot));\n    vec3 localX = vec3(sin(worldRot), 0, -cos(worldRot));\n    \n    // Get ray direction\n    vec3 camPos = -forward * CAMERA_BACKWARD + UP * CAMERA_UPWARD;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 rayForward = normalize(\n        localX * (uv.x - 0.5) * aspect +\n        UP * (uv.y - 0.5) +\n        forward * PROJECTION_DIST\n    );\n    \n    vec3 col = WHITE * 0.;\n    \n    // Travel ray\n    float totalDist = 0.;\n    vec3 currentPos = camPos;\n    bool hitSky = true;\n    \n    vec3 sphereCenter = getSphereCenter();\n    \n    while (totalDist < MAX_DIST) {\n        float floorSdf = currentPos.y;\n        float sdf = min(floorSdf, sdfShadowScene(currentPos));\n        \n        if (sdf < 0.01) {\n            if (floorSdf == sdf) {\n                // Floor\n                col = floorMaterial(currentPos, rayForward, totalDist);\n            }\n            else {\n                // Ball\n                vec3 normal = normalize(currentPos - sphereCenter);\n                float strength = dot(normal, sunDir);\n                vec3 fullColor = WHITE * 0.5 + sunColor * 0.5;\n                \n                col = WHITE * 0.4;\n                col += fullColor * strength * 0.34;\n                \n                vec3 reflection = reflect(sunDir, normal);\n                float diffuse = saturate(dot(normal, sunDir));\n                float specular = pow(saturate(dot(reflection, rayForward)), 120.);\n                \n                vec3 camReflection = reflect(rayForward, normal);\n                vec3 skyReflection = skyColor(camReflection) * 0.2;\n                \n                if (camReflection.y < 0.) {\n                    float distToGround = currentPos.y / -camReflection.y;\n                    vec3 floorPos = currentPos + camReflection * distToGround;\n                    \n                    float reflectIntensity = pow(saturate(1. - (length(distToGround)) / MAX_DIST), 3.);\n                    reflectIntensity *= saturate(dot(camReflection, -UP) / 2.);\n                    reflectIntensity *= 0.5;\n                    skyReflection *= 1.- reflectIntensity;\n                    \n                    vec3 floorCol = floorMaterial(floorPos, camReflection, length(distToGround));\n                    col += floorCol * reflectIntensity;\n                }\n                \n                col += skyReflection;\n                col = mix(col, mix(WHITE, sunColor, 0.1), specular);\n            }\n            \n            hitSky = false;\n            break;\n        }\n        \n        currentPos += rayForward * sdf;\n        totalDist += sdf;\n    }\n    \n    if (hitSky) {\n        col = skyColor(rayForward);\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}