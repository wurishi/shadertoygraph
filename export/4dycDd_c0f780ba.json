{"ver":"0.1","info":{"id":"4dycDd","date":"1523733531","viewed":282,"name":"Voxel /w diffuse","username":"konidia","description":"Voxel rendering is interesting","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","voxel","diffuse","traversal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITERATION = 256;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    float fovScalar;\n};\n\n// to setup camera\nvoid setCamera(vec3 pos, vec3 forward, vec3 upGuide, float fov, out Camera cam)\n{\n    cam.pos = pos;\n    cam.forward = normalize(forward);\n    cam.right = cross(-cam.forward, normalize(upGuide));\n    cam.up = cross(cam.right, -cam.forward);\n    cam.fovScalar = tan(radians(fov/2.0));\n}\n\n// to setup ray\nRay castRay(vec2 uv, in Camera cam)\n{\n    uv *= cam.fovScalar;\n    return Ray(\n        cam.pos,\n        normalize(cam.forward + uv.x * cam.right + uv.y * cam.up)\n    );\n}\n\n// rand generator\nfloat rand(float x)\n{\n    vec2 xx = vec2(x);\n    return fract(sin(dot(xx, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// test intersection with randomly generated voxel\nbool randIntersected(vec3 p)\n{\n    vec3 upperBound = vec3(4,4,4);\n    vec3 lowerBound = vec3(-4,0,-4);\n    \n    if(all(lessThanEqual(p, upperBound))\n       && all(greaterThanEqual(p, lowerBound)))\n    {\n        float x = ceil(iTime/4.+1.) * dot(p, p);\n        \n        if(rand(x) > 0.75)\n           return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n\tuv.y *= iResolution.y/iResolution.x;\n    \n    // sun pos\n    vec3 sunPos = vec3(cos(iTime)*7.,6,-sin(iTime)*7.);\n    \n    // camera\n    Camera cam;\n    vec3 pos = vec3(cos(iTime/4.)*20., sin(iTime)*10.+15., -sin(iTime/4.)*20.);\n    setCamera(pos, vec3(0, 1, 0)-pos, vec3(0, 1, 0), 70., cam);\n    \n    // initialize ray pos\n    vec3 mapPos = floor(cam.pos);\n    \n    // ray and ray displacement setup\n    Ray ray = castRay(uv, cam);\n    vec3 rayStep = sign(ray.dir);\n    vec3 deltaDist = abs(length(ray.dir)/ray.dir);\n    vec3 sideDist = sign(ray.dir)*(mapPos - ray.pos + sign(ray.dir)*0.5+0.5)*deltaDist;\n    \n    bvec3 mask;\n    vec3 col = vec3(0);\n    \n    // ray incrementation loop\n    for(int i = 0; i < MAX_ITERATION; ++i)\n    {\n        // check for intersection /w sun\n        if(all(equal(mapPos, ceil(sunPos))))\n        {\n            col = vec3(1);\n            break;\n        }\n        // check for intersection /w noise generated voxel\n        if(randIntersected(mapPos))\n        {\n            vec3 blockCol = vec3(\n                rand(mapPos.x+mapPos.y),\n                rand(mapPos.x-mapPos.y),\n                rand(mapPos.x*mapPos.y));\n            \n            vec3 normal = -normalize(rayStep*vec3(mask));\n            vec3 toSun = normalize(sunPos - mapPos);\n            col = blockCol*(vec3(max(dot(vec3(normal), toSun), 0.0)) + 0.35);\n            break;\n        }\n        // check for intersection /w floor\n        if(mapPos.y < 0.)\n        {\n            vec3 normal = -normalize(rayStep*vec3(mask));\n            vec3 toSun = normalize(sunPos - mapPos);\n            col = vec3(max(dot(vec3(normal), toSun), 0.0));\n            break;\n        }\n        \n        // increment ray in x, y, or z direction\n        \n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yxx, sideDist.zzy));\n        \n        mapPos += vec3(mask) * rayStep;\n    \tsideDist += vec3(mask) * deltaDist;\n    }\n    \n    // final color\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}