{"ver":"0.1","info":{"id":"cdScDc","date":"1688241596","viewed":253,"name":"Sierpi≈Ñski Square Snowflake","username":"spalmer","description":"space filling curve I extracted from FabriceNeyret2's H curve fork","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sierpinski","spacefillingcurve"],"hasliked":0,"parentid":"mlS3Rm","parentname":"H-Curve (better than Hilbert?)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n I extracted FabriceNeyret2's highly golfed fork of\n Marty McFly's H curve at http://shadertoy.com/view/mlS3Rm\n from comment there, then proceeded to remove the H curve part of it.\n Got it working again as a stand-alone bottom-up\n Sierpinski Square Snowflake space-filling curve.\n :D\n Enjoy!\n*/\n// this is what I'm really trying to golf:\n/*\nint Sierp(ivec2 p, int l)\n{\n    int i, s, n=1, m=1; ivec2 b, z;\n    for (; s++ <= l; m *= 4, n += n, p /= 2)\n        b = p&1, \n        z = b.x^b.y + 2*b,\n        i = (m-1&i\n             + (2*z.y + 3)*m/8) \n           ^ z.x * m;\n\treturn m/32\n\t\t- (i ^ m/8) - 1\n\t\t&m/4-1; // zeroes near center, fill each quadrant before proceeding to next\n\treturn i - m/8 + 1\n\t\t&m/4-1; // zeroes at outside corner\n    return i;\n}\n*/\n/*\n// Fabrice was busy today!!  :)  -16ch\nint Sierp(ivec2 p, int l)\n{\n    int i, s, n=1; \n    for (ivec2 z; s <= l; s++, n*=4)    \n       z = p<<s&n,\n       z = z.x^z.y + z+z,\n       i = (z.y/4 + i + 3*n/8&n-1) \n           + z.x;\n    return i;\n}\n*/\n\n// I shifted it around\nint Sierp(ivec2 p, int l)\n{\n    int i, s, n=1; \n    for (ivec2 z; s <= l; s++, n*=4)    \n       z = p<<s&n,\n       z = z.x^z.y + z+z,\n       i = (z.y/4 + i + 3*n/8&n-1) \n           + z.x;\n\treturn n/32\n\t\t- (i ^ n/8) - 1\n\t\t&n-1;\n}\n/*\n// inverse mapping function, see http://shadertoy.com/view/mtjSWc and http://shadertoy.com/view/ddsfWr\nivec2 Sierp_inverse_spalmer(int i, int l)\n{\n    int n = 1 << 2*l;\n    ivec2 p = ivec2(0);\n    while ((n >>= 2) > 0) {\n        int q = (i / n) & 3;\n        p += p + ivec2((q ^ (q>>1)) & 1, q>>1);\n        i += (q ^ 2) * (n >> 2) + (n >> 3);\n    }\n    return p;\n}\n*/\n\n// sad when obfuscating #defines like this actually help save ch\n#define F float\n\n// beware, now takes advantage of a few glsl quirks:  all local variables are initialized (to 0)\n// modifications to variables within expressions are handled left to right where not otherwise dictated by precedence\n// where C would consider such stuff undefined behavior.  The things we do for golfing!\n// so porting this back to C or hlsl would need some work.\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o.xyz = iResolution;\n    int l = int(5. * sqrt(cos(.3 * iTime) * .5 + .5)) + 1,\n        n = 1 << l, m = n-1, N = n * n, k, j;\n    ivec2 p = ivec2(u = F(n) * ((u - .5 * o.xy) / (o.y = min(o.x, o.y)) * 1.05 + .5)), q;\n        u -= .5;\n    F t, d = 9.;\n    j = Sierp(p, l);\n    for (; k < 9; ++k) { // check neighbors, 1 loop, Fabrice-style\n        q = p + ivec2(k%3, k/3) - 1;\n        // only scanning next and prior, there are some grid connection artifacts at corners; N, N/2 repeated FIXME\n        if (q == (q&m) && abs(((Sierp(q, l) - j + N/2) &N-1) - N/2) < 2) {\n            vec2 a = vec2(p), b = vec2(q) - a, s = u - a,\n              w = s - b * clamp(dot(s, b) / dot(b, b), 0., 1.); // vector to segment\n            d = min(d, dot(w, w));\n        } \n    }\n    t = fract(F(j) / F(N) - .05 * iTime);\n    o = sqrt(mix(vec4(.5),\n        (1. - pow(t, exp2(F(l + 3)))) // dark red crease on violet side\n         * min(abs(fract(t + vec4(3,2,1,0) / 3.) * 6. - 3.) - 1., 1.), // hue\n        clamp(.5-.5*(sqrt(d) - .2) / F(n)*o.y, 0., 1.) // antialiasing\n         * F(p == (p&m)) // mask off repeat tilings\n        ));\n}\n\n\n// TODO there's probably a simple way to make it look more like the snowflakes in the diagrams at Wikipedia etc.\n// Think need to move halfway to the next point somehow.  Plot the points in-between these points.\n\n// The main reason I posted this is because it seems somewhat useful,\n// as a compromise between the ease of computation of a Z-curve, and\n// the more optimal characteristics of the Hilbert curve (or H, maybe)\n// among the set of space-filling curves, which is apparently larger than I thought.\n// I might even be wrong about the name for this, I have no clue really.\n\n// In fact I'm unsure if this extends to 3d, it might just be a plane-filling curve.\n// Probably does, because the H and Hilbert do.  Would need to change 4s to 8s etc.\n// Interleave another bit.\n\n/*\n pattern if shift zeroes to inner corner isolates quadrants better:\n \n 0 \n\n 0  1 \n 3  2 \n\n 2  3  5  6 \n 1  0  4  7 \n f  c  8  9 \n e  d  b  a \n\n 8  9  b  c 14 15 17 18 \n 7  6  a  d 13 12 16 19 \n 5  2  e  f 11 1e 1a 1b \n 4  3  1  0 10 1f 1d 1c \n3c 3d 3f 30 20 21 23 24 \n3b 3a 3e 31 2f 2e 22 25 \n39 36 32 33 2d 2a 26 27 \n38 37 35 34 2c 2b 29 28 \n*/\n\n/*\n pattern if shift zeroes to outer corner, not quite as nice but still an improvement:\n\n 0 \n\n 0  3 \n 1  2 \n\n 0  f  d  c \n 1  2  e  b \n 3  6  a  9 \n 4  5  7  8 \n\n 0 3f 3d 3c 34 33 31 30 \n 1  2 3e 3b 35 36 32 2f \n 3  6 3a 39 37 2a 2e 2d \n 4  5  7  8 38 29 2b 2c \n c  b  9 18 28 27 25 24 \n d  e  a 17 19 1a 26 23 \n f 12 16 15 1b 1e 22 21 \n10 11 13 14 1c 1d 1f 20 \n*/\n\n/*\nthe original pattern is a bit bizarre, the zero wanders around as logN changes:\n\n 0 \n\n 1  0 \n 2  3 \n\n 7  6  4  3 \n 8  9  5  2 \n a  d  1  0 \n b  c  e  f \n\n1f 1e 1c 1b 13 12 10  f \n20 21 1d 1a 14 15 11  e \n22 25 19 18 16  9  d  c \n23 24 26 27 17  8  a  b \n2b 2a 28 37  7  6  4  3 \n2c 2d 29 36 38 39  5  2 \n2e 31 35 34 3a 3d  1  0 \n2f 30 32 33 3b 3c 3e 3f \n*/","name":"Image","description":"","type":"image"}]}