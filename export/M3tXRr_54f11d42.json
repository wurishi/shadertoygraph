{"ver":"0.1","info":{"id":"M3tXRr","date":"1718553909","viewed":70,"name":"Alpha Complex","username":"chronos","description":"The 2D Alpha Complex of a set of points for a given radius as a function of time. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["graph","complex","complex","alpha","topology","persistent","computational","homology"],"hasliked":0,"parentid":"l3tSzn","parentname":"Vietoris–Rips Complex"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Alpha Complex by chronos\n    --------------------------------------\n\n    An α-complex is generalization and a subcomplex of the Delaunay complex\n    which only includes simplicies that have a circumcircle smaller than\n    the given radius. α is the reciprocal of the generalized disc radius, 1/α. \n\n    Note that I use the radius 'r' as the threshold here, instead of using α = 1/r.\n    It seems some authors use α = r. It doesn't really matter though :)\n    In the code, the word alpha only refers to opacity.\n    \n    Note also that the rule for drawing edges used here is:\n        Edge circumsphere radius < r AND circumsphere does not contain other vertices.\n        OR\n        The edge is part of another simplex (triangle) already in the complex.\n\n    --------------------------------------\n    Forked shader description:\n    --------------------------------------\n\n        Vietoris–Rips Complex by chronos\n        --------------------------------------\n\n        Simple (and inefficient) rendering and demonstration of the\n        Vietoris–Rips complex of a set of points in 2D \n\n        The Vietoris–Rips complex contains all simplices constructed from points in the set whose \n        diameter is less than a specified value. The diameter of a set of points is the maximum of\n        all pairwise distances between points in the set.\n\n        As I understand, the Vietoris–Rips complex can contain subsets of\n        size greater than the (ambient-) dimension. E.g containing tetrahedrons even in 2D.\n        This is in contrast to Delaunay Complexes and Alpha Complexes.\n        Here I only include simplices of size up to 3 (aka triangles).\n    \n    Related concepts:\n    \n    Vietoris–Rips Complex\n        - See description in forked shader! :)\n    Delaunay complex ( and Voronoi diagram)\n        - Contains all simplices whose circumsphere do not contain other vertices.\n    Convex hull\n        - Intuitively the outline/surface of the Delaunay complex.\n    Čech complex\n        - Simplices are included based on the intersection of all balls centered at the vertices.\n          In contrast to Vietoris-Rips, where we only require *pairwise* intersections of the participating vertices.\n          There is also a 2x difference in scale due to one definition using radius and and the other using the diameter.\n          \n    Alpha Complex\n        - A generalization and a subcomplex of the Delaunay complex which only includes simplicies that have a circumcircle smaller than\n          the given radius. α is the reciprocal of the generalized disc radius, 1/α. \n          \n    Alpha Shape\n        - Intuitively the outline/surface of the alpha complex, so it only includes simplices with circumsphere radius *exactly* equal to 1/α,\n          which do not contain other vertices. Exact definition varies a bit it seems.\n    \n    \n    Links:\n    ----------------------------------------------------\n    https://en.wikipedia.org/wiki/Vietoris–Rips_complex\n    https://en.wikipedia.org/wiki/Čech_complex\n    https://en.wikipedia.org/wiki/Alpha_shape\n    https://en.wikipedia.org/wiki/Diameter#Generalizations\n    https://en.wikipedia.org/wiki/Delaunay_triangulation#d-dimensional_Delaunay\n    \n    self link: https://www.shadertoy.com/view/M3tXRr\n\n*/\n\n\nvec2 get_pos(int index)\n{\n    return  .8 * (-1. + 2. * texelFetch(iChannel0, ivec2(index, 9), 0).rg);\n}\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nfloat tri(vec2 a, vec2 b, vec2 c, vec2 p, float ps)\n{\n    c-= a; b-=a; p-=a;\n    float ABC = determinant(mat2(b,c));\n    float C = determinant(mat2(b,p));\n    float B = determinant(mat2(p,c));\n    float A = ABC - B - C;\n    ps *= ABC * 4.;\n    return smoothstep(-ps, ps, A) * smoothstep(-ps, ps, B) * smoothstep(-ps, ps, C);\n}\n\n\nvec2 circumcircle_center(vec2 a, vec2 b, vec2 c)\n{\n    float bdotb = dot(b,b);\n    vec2 rhs = vec2((bdotb - dot(a,a)), (dot(c,c) - bdotb)) / 2.;\n    return transpose(inverse(mat2x2(b-a, c-b))) * rhs;\n}\n\nfloat circumcircle_radius(vec2 q, vec2 a)\n{\n    return distance(q,a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float ps = 2. / iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float dotsize = 0.01;\n    float seg_thickness = 0.005;\n    \n    float t = fract(iTime*0.01);\n    float r = 2. * min(t,(1.-t));\n    \n    if(length(iMouse.xy) > 10.)\n        r = length(mouse)*.8;\n    \n    const int num_points = 20;\n    \n    // Loop over all points\n    for(int i = 0; i < num_points; i++)\n    {\n        vec2 pos = get_pos(i);\n        float d = length(uv-pos);\n\n        col += smoothstep(dotsize+ps,dotsize-ps, d); // Draw dot\n    }\n    \n    // Loop over all pairs\n    \n    float seg_alpha = 0.;\n    for(int i = 0; i < num_points; i++)\n    {\n        vec2 pos_i = get_pos(i);\n        for(int j = i; j < num_points; j++)\n        {\n            vec2 pos_j = get_pos(j);\n\n            vec2 center = (pos_i+pos_j)*.5;\n            float radius = length(pos_i-pos_j)*.5;\n            // Brute force check for containment\n            int l;\n            for(l = 0; l < num_points; l++)\n            {\n                if(l == j || l == i) continue;\n\n                vec2 pos_l = get_pos(l);\n\n                if(length(pos_l - center) < radius) break;\n\n            }\n\n            if(l == num_points)\n            {\n                float connected = smoothstep(radius-0.01, radius+0.01, r); // 1 if  radius < r\n                seg_alpha = max(seg_alpha, connected * 0.125 * smoothstep(seg_thickness+ps,seg_thickness-ps, seg(pos_i, pos_j, uv)));\n            }\n        }\n    }\n    \n    // Loop over all triples\n    float tri_alpha = 0.;\n    for(int i = 0; i < num_points; i++)\n    {\n        vec2 pos_i = get_pos(i);\n        for(int j = i; j < num_points; j++)\n        {\n            vec2 pos_j = get_pos(j);\n            \n            for(int k = j; k < num_points; k++)\n            {\n                vec2 pos_k = get_pos(k);\n                \n                vec2 center = circumcircle_center(pos_i, pos_j, pos_k);\n                float radius = circumcircle_radius(center, pos_i);\n                \n                // Brute force check for containment\n                int l;\n                for(l = 0; l < num_points; l++)\n                {\n                    if(l == k || l == j || l == i) continue;\n                    \n                    vec2 pos_l = get_pos(l);\n                \n                    if(length(pos_l - center) < radius) break;\n                \n                }\n                \n                if(l == num_points)\n                {\n                    float connected = smoothstep(r+0.01, r-0.01, radius);\n                \n                    float seg_alpha_ij = 0.125 * smoothstep(seg_thickness+ps,seg_thickness-ps, seg(pos_i, pos_j, uv));\n                    float seg_alpha_ik = 0.125 * smoothstep(seg_thickness+ps,seg_thickness-ps, seg(pos_i, pos_k, uv));\n                    float seg_alpha_jk = 0.125 * smoothstep(seg_thickness+ps,seg_thickness-ps, seg(pos_j, pos_k, uv));\n                    \n                    seg_alpha = max(seg_alpha, connected * max(seg_alpha_ij, max(seg_alpha_ik, seg_alpha_jk)));\n                    \n                    tri_alpha = max(tri_alpha, 0.1 * connected * tri(pos_i, pos_j, pos_k, uv, ps));\n                    \n                    float d = length(uv-center);\n                    float R = min(r, radius);\n                    col += ((1. + 3.*connected)*.25) * smoothstep(R+ps,R-ps, d) * 0.00125 * vec3(1, 2, 3); // Draw disc\n                    col += ((1. + 3.*connected)*.25) * smoothstep(3.*ps,ps, abs(d-R)) * 0.0125 * vec3(0.25, 1, 4); // Draw circle\n                }\n            }\n        }\n    }\n    \n    col = mix(col,  vec3(1, 3, 2), tri_alpha * (1.-8.*seg_alpha));\n    col = mix(col, vec3(3, 1, 3), seg_alpha);\n\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}