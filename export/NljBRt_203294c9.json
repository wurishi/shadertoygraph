{"ver":"0.1","info":{"id":"NljBRt","date":"1652639449","viewed":86,"name":"Nonuniform B-Spline (DeBoor)","username":"Envy24","description":"BufferA - drawing spline\nBufferB - drawing control points\nBufferC - drawind dashed convex hull\nImage - mixing and coloroing\n\nFour passes used for better readability of code.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["spline","curve","linear","cubic","quadratic","quartic","interpolation","quintic","bspline","open","deboor"],"hasliked":0,"parentid":"ft2fR3","parentname":"Bezier-DeCasteljau Curve"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    vec4 spline      = TEXF0(SC);\n    vec4 knot        = TEXF1(SC);\n    vec4 convex_hull = TEXF2(SC);\n    \n    float min = MIN3(spline.r, knot.r, convex_hull.r);\n    \n    O = \n        min == 1.0 ?\n            vec4(1) :                            // Background color\n            min == spline.r ?\n                vec4(0, spline.r, spline.r, 1) : // Spline color\n                min == knot.r ?\n                    vec4(0, knot.r, 0, 1) :      // Knot color\n                    vec4(convex_hull);           // Convex hull  color\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define INITIALLY_FAR               9e30\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(SC), 0) )\n#define TEXF2(SC)                 ( texelFetch(iChannel2, ivec2(SC), 0) )\n#define MIN3(a, b, c)             ( min(min((a), (b)), (c)) )\n#define NMY                       ( iMouse.y / R.y )                 // in range [0.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\n#define RANDOM\n\nconst int order = 4; \n/* order:           minimum requarements: \n   2 - linear        2 - control points, 5 knots\n   3 - quadratic     3 - control points, 6 knots\n   4 - cubic         4 - control points, 7 knots\n   5 - quartic       5 - control points, 8 knots\n   6 - quintic       6 - control points, 9 knots\n   e.t.c.\n*/ \nconst int num_of_ctrl = max(order, 6);\nconst int num_of_knots = num_of_ctrl + order;\nfloat knots[num_of_knots] = float[num_of_knots](\n    // Constrain: knots[n - 1] <= knots[n] <= knots[n + 1].\n    //0.0, 1.0, 2.0, 3.0, 4.0,   5.0, 6.0, 7.0, 8.0, 9.0  // uniform\n    //0.0, 0.0, 0.0, 0.0, 1.0,   2.0, 3.0, 3.0, 3.0, 3.0  // open uniform for order=4, num_of_ctrls=6\n    /* You can adjust this knots like this */\n    //0.0, 1.2, 2.2, 3.5, 4.6,    5.0, 6.2, 7.2, 8.0, 9.0 // nonuniform\n    0.0, 0.0, 0.0, 0.0, 1.2,   2.8, 3.5, 3.5, 3.5, 3.5  // open nonuniform for order=4, num_of_ctrls=6\n    /* But this can lead to disconnected spline */\n);\n\nvec2 ctrl[num_of_ctrl];\n/**\nvec2 ctrl[num_of_ctrl] = vec2[num_of_ctrl](\n    vec2( -1.1, -0.2),\n    vec2( -1.5, -0.3),\n    //vec2( -1.0, -0.9),\n    vec2(-0.33,  0.9),\n    vec2( 0.33,  0.9),\n    //vec2(  1.0, -0.9),\n    vec2(  1.5, -0.3),\n    vec2(  1.1, -0.2) \n);\n/**/\n\nfloat circleSQSDF(\n    in vec2 S,           // sample coordinates\n    in vec2 C,           // circle center\n    in float r,          // circle radius\n    in float smoothness) // AA parameter\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of areas (squared distancies).\n    float sds = _x * _x + _y *_y - r * r;\n    \n    float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 vector2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\n//\nvoid randomize_knots(float time)\n{\n    uint T = uint(time);\n    for (int k = 0; k < num_of_ctrl; ++k)\n    {\n        ctrl[k] = vector2HashUI32(T + uint(k), 2u * T + uint(k * 2));\n    }\n}\n\nvoid randomize_knots2(float time)\n{\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < num_of_ctrl; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = vector2HashUI32(x, y);\n        vec2 n = vector2HashUI32(x + 1u, y + 2u);\n    \n        ctrl[k] = c * (1. - t) + n * t;\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* source https://en.wikipedia.org/wiki/De_Boor%27s_algorithm */\nvec2 deBoorAlgorithm(\n    vec2[num_of_ctrl] ctrls,\n    float[num_of_knots] knots,\n    float t,\n    int inverval,\n    int _order)\n{    \n    const int size = 16; // size must be equal to _order + 1\n    \n    if (_order + 1 > size) { return vec2(0); }\n    vec2 buffer[size]; \n\n    int diff = inverval - _order;\n\n    for (int wIdx = 0; wIdx <= _order; ++wIdx)\n    {\n        buffer[wIdx] = \n            wIdx + diff < 0 ? \n                vec2(0) :\n                ctrls[wIdx + diff];\n    }\n\n    for (int r = 2; r <= _order; ++r)\n    {\n        for (int rwIdx = _order; rwIdx > r - 1; --rwIdx)\n        {\n            float alpha = \n                (t - knots[rwIdx + diff]) /\n                (knots[rwIdx + inverval + 1 - r] - knots[rwIdx + diff]);\n\n            buffer[rwIdx] = (1.0 - alpha) * buffer[rwIdx - 1] + alpha * buffer[rwIdx];\n        }\n    }\t\t\n\n    return buffer[_order];\n}\n\nint find_interval(\n    in float[num_of_knots] knots,\n    in float t)\n{\n    int i = 0;\n    \n    while (\n        (i < num_of_knots - 1) &&\n        (((t >= knots[i]) && (t < knots[i + 1])) == false))\n    {\n        ++i;\n    }\n    \n    return i;\n}\n\nvec2 find_closest_curve_point_to_pixel(\n    in vec2[num_of_ctrl] ctrl,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n\n    const int num_of_points = 35;\n    \n\tfloat tMin = knots[order - 1];\n\tfloat tMax = knots[num_of_knots - order];\n\tfloat dt = (tMax - tMin) / float(num_of_points);\n\n    for (float t = tMin; t <= tMax; t += dt)\n    {\n\t\tint interval = find_interval(knots, t);\n        vec2 P = deBoorAlgorithm(ctrl, knots, t, interval, order);\n\n        vec2 diff = P - NDC;\n        float sqDist = dot(diff, diff);\n\n        minSqDist = min(minSqDist, sqDist);\n\n        closestP = \n            minSqDist == sqDist ? \n                P :\n                closestP;\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n#ifdef RANDOM\n    //randomize_knots(iTime);\n    randomize_knots2(iTime);\n#endif\n\n    O = vec4(circleSQSDF(\n        find_closest_curve_point_to_pixel(ctrl, NDC),\n        NDC,\n        0.01,\n        0.011));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 find_closest_knot_to_pixel(\n    in vec2[num_of_ctrl] ctrl,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n\n    for (int k = 0; k < num_of_ctrl; ++k)\n    {\n        vec2 diff = ctrl[k] - NDC;\n        float sqDist = dot(diff, diff);\n       \n        minSqDist = min(minSqDist, sqDist);\n        \n        closestP = \n            minSqDist == sqDist ? \n                ctrl[k] :\n                closestP;\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n#ifdef RANDOM\n    //randomize_knots(iTime);\n    randomize_knots2(iTime);\n#endif\n\n    O = vec4(circleSQSDF(\n        find_closest_knot_to_pixel(ctrl, NDC),\n        NDC,\n        0.02,\n        0.018));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 find_closest_convex_hull_point_to_pixel(\n    in vec2[num_of_ctrl] ctrl,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n    \n    int num_of_lines = num_of_ctrl - 1; // 2 knots per line\n     \n    for (int l = 0; l < num_of_lines; ++l)\n    {\n        for (float t = 0.; t <= 1.; t += 0.1)\n        {\n            vec2 P = ctrl[l] * (1. - t) + ctrl[l + 1] * t;\n\n            vec2 diff = P - NDC;\n            float sqDist = dot(diff, diff);\n\n            minSqDist = min(minSqDist, sqDist);\n\n            closestP = \n                minSqDist == sqDist ? \n                    P :\n                    closestP;\n        }\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n#ifdef RANDOM\n    //randomize_knots(iTime);\n    randomize_knots2(iTime);\n#endif\n\n    O = vec4(circleSQSDF(\n        find_closest_convex_hull_point_to_pixel(ctrl, NDC),\n        NDC,\n        0.008,\n        0.0088));\n}","name":"Buffer C","description":"","type":"buffer"}]}