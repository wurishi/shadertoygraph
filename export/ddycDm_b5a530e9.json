{"ver":"0.1","info":{"id":"ddycDm","date":"1696198818","viewed":103,"name":"SDFotM Raymarch Template","username":"0xBAMA","description":"Very basic raymarch template for the Graphics Programming Discord's SDF of the Month - feel free to fork this as a starting point - click and drag to set camera direction","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDF of the Month Raymarch Template - jb 2023\n  // check out https://jbaker.graphics/writings/DEC.html for samples\nfloat de ( vec3 p ) { // your SDF goes here\n    vec4 p0 = vec4( p, 1.0f );\n    for ( int i = 0; i < 8; i++ ) {\n      p0.xyz = mod( p0.xyz - 1.0f, 2.0f ) - 1.0f;\n      p0 *= 1.4f / dot( p0.xyz, p0.xyz );\n    }\n    return ( length( p0.xz / p0.w ) * 0.25f );\n}\n\n// Raymarch Parameters\nconst float maxDistance = 1000.0f;\nconst int maxSteps = 100;\nconst float epsilon = 0.001f;\n\n// Distance to nearest scene intersection\nfloat Raymarch ( vec3 origin, vec3 direction ) {\n    float dTravel = 0.0f;\n    for ( int i = 0; i < maxSteps && dTravel < maxDistance; i++ ) {\n        float dQuery = de( origin + dTravel * direction );\n        if ( dQuery < epsilon ) { // the surface has been reached\n\t\t\treturn dTravel;\n        }\n        dTravel += dQuery;\n    }\n    return maxDistance; // the ray has escaped\n}\n\n// Returns a 3x3 rotation matrix from a defined forward vector and an up vector\nmat3x3 lookAt ( vec3 forwardVec, vec3 upVec ) {\n\tvec3 Z = normalize( forwardVec );\n    vec3 X = normalize( cross( forwardVec, upVec ) );\n    vec3 Y = normalize( cross( X, forwardVec ) );\n\n    return mat3x3( X, Y, Z );\n}\n\nconst float pi = 3.14159f;\nconst float fov = 1.0f;\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    // Screen UV coordinates ( from -1 to 1 )\n    vec2 uv = ( 2.0f * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Transform the mouse coordinates as well\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = ( mouse * 2.0f - 1.0f ) * vec2( pi, pi * 0.5f );\n    \n    // Mouse coordinates determine which direction the camera is facing\n    vec3 forwardDirection = vec3(\n        cos( mouse.x ) * cos( mouse.y ),\n        sin( mouse.y ),\n        sin( mouse.x ) * cos( mouse.y ));\n        \n    // Construct the view rotation matrix\n    mat3x3 rotMat = lookAt( forwardDirection, vec3( 0.0f, 1.0f, 0.0f ) );\n    \n    // Generate a ray origin + ray direction, very simple camera\n    vec3 rayOrigin = vec3( 1.5f, 2.5f, 3.3f ); // bear in mind you might be \"inside\" the object\n    vec3 rayDirection = normalize( rotMat * vec3( fov * uv, 1.0f ) );\n\n    // Get the raymarch result\n    float d = Raymarch( rayOrigin, rayDirection );\n\n    // Output to screen\n    fragColor = vec4( vec3( 1.0f / d ), 1.0f );\n}","name":"Image","description":"","type":"image"}]}