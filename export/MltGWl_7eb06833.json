{"ver":"0.1","info":{"id":"MltGWl","date":"1472522495","viewed":2785,"name":"Pottery [Interactive]","username":"lara","description":"Sculpt your own vase! See shader comment for controls.","likes":70,"published":3,"flags":48,"usePreview":1,"tags":["interactive","sculpt","pottery"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t================\n\t=== Controls ===\n\t================\n\n\tSpacebar (hold): rotate table (important!)\n\tLMB: sculpt (outside: make narrower, inside: make wider)\n\n\tX: Reset shape\n\tC: Reset color\n\tR: toggle rotate view\n\n    1: sculpt\n\t2: smoothing\n\t3: stretching (vertically)\n\t4: paint\n\n\tYou can enable multi-sampling in Buf B for a pretty render\n \tor change the resolution in Buf A to have it run smoother.\n\n\t=============\n\t=== Setup ===\n\t=============\n\n    BufA = Logic\n    BufB = Rendering\n\tBufC = GUI\n\n\t===============\n\t=== Credits ===\n\t===============\n\n\t96-bit 8x12 Font by Flyguy\n\thttps://www.shadertoy.com/view/Mt2GWD\n\n*/\n\n#define keyInfo(a,b) texture(iChannel3, vec2((a+.5)/256.,b)).x \n#define load(a,b) texture(b,(a+0.5)/iResolution.xy)\n\nconst vec2 tex_config = vec2(0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Hide data pixels\n    if (fragCoord.y == 0.5) fragCoord.y += 1.;\n    \n    float res = load(tex_config, iChannel0).y;\n    fragColor = texture(iChannel1, fragCoord.xy/iResolution.xy*res);\n    \n    if(keyInfo(82.,1.) < 1.)\n    fragColor += texture(iChannel2, fragCoord.xy/iResolution.xy);\n    \n    /* Shows the sculpt map for debugging\n    if(keyInfo(68.,1.)>0.) fragColor = texture(iChannel0, fragCoord.xy*99./pow(iResolution.xy,vec2(2)))*5.;\n    //*/\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n#define inside_range(a) (fragCoord.x >= a.x+0.5 && fragCoord.x <= (a.x+a.z)+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) texture(b,(a+0.5)/iResolution.xy)\n#define save(a,b) if(inside(a)){fragColor=b;return;}\n#define keyInfo(a,b) texture(iChannel3, vec2((a+.5)/256.,b)).x \n\n#define T iTime\n#define PI 3.14159\n#define TAU (PI*2.)\n\n// x*x pixels for the sculpt map and the two paint maps (inner + outer)\n// set to iResolution.x/3. for maximum resolution\n\nconst float _res_screen = 1.;\nconst float _max_acceleration = .5;\n\nconst vec2 tex_config = vec2(0,0);\nconst vec2 tex_table = vec2(1,0);\nconst vec2 tex_view = vec2(2,0);\nconst vec2 tex_mouse = vec2(3,0);\nconst vec3 tex_cast = vec3(0,0,1);\n\nconst vec2 tex_brush_size = vec2(0,0);\nconst vec2 tex_brush_blur = vec2(1,0);\nconst vec2 tex_brush_alpha = vec2(3,0);\nconst vec2 tex_color_picker = vec2(2,0);\n\nmat2 rot(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash11(float n)\n{\n    return (fract(sin(dot(vec2(n),vec2(12.9898,78.233)))*43758.5453)-.5)*2.;\n}\n\nfloat noise1D(float x, float s, float e, bool repeat)\n{    \n    x = abs(fract(x));\n    \n    const float n = 10.;\n    \n    float h = hash11(s);\n    if (e < 0.) e = floor((hash11(s+1.)+1.)/2.*n);\n    \n    float x1 = floor(x*e);\n    float x2 = fract(x*e);\n    \n    float m = -1e10;\n    \n    for(float i = 0.; i < n; i++)\n    {\n        m = max(m,abs(h));\n        \n        if (i == e) break;\n\n        h += hash11(h);       \n    }\n    \n    h = hash11(s);\n    \n    for(float i = 0.; i < n; i++)\n    {\n        if (x1 == i)\n        {\n            return mix(h,repeat == true && i == e-1. ? hash11(s) : h+hash11(h),smoothstep(0.,1.,x2))/m;\n        }\n        \n        h += hash11(h);\n    }\n    \n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    save(tex_mouse,iMouse);\n    \n    vec4 _c = load(tex_config, iChannel0);\n    float _res_map = iFrame < 2 ? floor(iResolution.x/3.) : _c.x;\n    \n    float key_x = keyInfo(88.,0.);\n    float key_c = keyInfo(67.,0.);\n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    if (inside(tex_config))\n    {\n        // x = sculpt resolution\n        // y = screen resolution\n        // z = tool index\n        \n        vec4 v = load(tex_config, iChannel0);\n        \n        if (iFrame < 2) v.x = floor(iResolution.x/3.);\n        v.y = _res_screen;\n        \n        float key_1 = keyInfo(49.,0.); // Sculpt\n        float key_2 = keyInfo(50.,0.); // Smoothen\n        float key_3 = keyInfo(51.,0.); // Stretch\n        float key_4 = keyInfo(52.,0.); // Paint\n        \n        if (key_1 > 0.) v.z = 0.;\n        if (key_2 > 0.) v.z = 1.;\n        if (key_3 > 0.) v.z = 2.;\n        if (key_4 > 0.) v.z = 3.;\n        \n        fragColor = v;\n    }\n    else if (inside(tex_table))\n    {\n        // x = table rotation\n        // y = table rotation accelertion\n        \n        vec4 v =  load(tex_table, iChannel0);\n        \n        float key_sp = keyInfo(32.,0.);\n        \n        v.x = mod(v.x+v.y,TAU);\n        v.y = clamp(v.y+(key_sp>0.?.008:-.008),0.,_max_acceleration);\n        \n        fragColor = v;\n    } \n    else if(inside(tex_view))\n    {\n        // x = rotx\n        // y = roty\n        // z = height\n        \n        vec4 v = load(tex_view, iChannel0);\n        vec4 h = load(tex_cast.xy, iChannel1);\n        vec4 c = load(tex_config, iChannel0);\n        \n        vec4 iMouseLast = load(tex_mouse,iChannel0);\n        if (iMouseLast.w < 1.0) { iMouseLast.xy = iMouse.xy; }\n        \n        float key_r = keyInfo(82.,1.);\n        \n        vec2 d = (iMouseLast.xy-iMouse.xy)/iResolution.xy*vec2(1,-1);\n        \n        if (key_r > 0.) v.xy += d*PI;\n        else if(h.w > 0. && c.z == 2.) v.z = clamp(v.z+=d.y*.2,0.3 ,1.);\n\n        if (iFrame < 2) v.z = .8;\n        \n         v.y = clamp(v.y,-PI/4.,1.);\n        \n        fragColor = v;\n    }\n    \n    // Sculpting/Painting\n    else if (fragCoord.x < _res_map*3. && fragCoord.y > 1. && fragCoord.y < _res_map+1.)\n    {\n        float index = floor(fragCoord.x/_res_map);\n        \n        vec2 uv = fragCoord.xy/iResolution.xy;\n        fragColor = texture(iChannel0,uv);\n        uv = clamp((mod(fragCoord.xy-vec2(0,1),vec2(_res_map)))/_res_map,0.,1.);\n        \n        if (index == 0.)\n        {\n            // Default vase\n            if(iFrame < 2)\n            {\n                fragColor.x = -(sin(uv.y*TAU)*2.5)*.05*.8;\n                return;\n            }\n            // Reset shape\n            else if (key_x > 0.)\n            {\n                fragColor.x = 0.;\n                return;\n            }\n            // Random vase (y)\n            else if (keyInfo(55.,0.) > 0.)\n            {\n                fragColor.x = noise1D(uv.y,iDate.w,-1.,false)*.15;\n                return;\n            }\n            // Random vase (x,y)\n            else if (keyInfo(56.,0.) > 0.)\n            {\n                fragColor.x = noise1D(uv.y,iDate.w,-1.,false)*noise1D(uv.x,iDate.w,-1.,true)*.15;\n                return;\n            }\n        }\n        \n        if (index > 0.)\n        {\n            // Default paint\n            if (iFrame < 2)\n            {\n                fragColor = index == 2. ? vec4(0) : vec4(1)\n                - vec4(1,0,0,.5)*clamp(smoothstep(0.,1.,1.-(abs(uv.y-.3)-.02)/.02),0.,1.)\n                - vec4(1,0,0,.5)*clamp(smoothstep(0.,1.,1.-(abs(uv.y-.4)-.02)/.02),0.,1.);\n                return;\n            }\n            // Reset color\n            else if (key_c > 0.)\n            {\n                fragColor = vec4(0);\n                return;\n            }\n            // Random paint (outer)\n            else if (index == 1. && keyInfo(57.,0.) > 0.)\n            {\n                float p1 = (hash11(iDate.w)+1.)/2.*3.;\n                float p2 = (hash11(iDate.w+1.)+1.)/2.*3.;\n                float p3 = (hash11(iDate.w+2.)+1.)/2.*3.;\n                float p4 = (hash11(iDate.w+3.)+1.)/2.*3.;\n                \n                float s1 = pow((noise1D(uv.y,iDate.w+1.,-1.,false)+1.)/2.,p1);\n                float s2 = pow((noise1D(uv.y,iDate.w+2.,-1.,false)+1.)/2.,p2);\n                \n                float h1 = pow((noise1D(uv.y,iDate.w+3.,-1.,false)+1.)/2.,p3);\n                float h2 = pow((noise1D(uv.y,iDate.w+4.,-1.,false)+1.)/2.,p4);\n                \n                fragColor = vec4(hsv2rgb(vec3(h1+h2,s1+s2,2.)/2.),1);\n                return;\n            }\n        }\n        \n        if (iMouse.w < 1.) return;\n        \n        // No sculpting/painting in view mode\n        float key_r = keyInfo(82.,1.);\n        if (key_r > 0.) return;\n        \n        \n        // Mouse not pointing at clay\n        vec4 h = load(tex_cast.xy, iChannel1);\n        if (h.w < 1.) return;\n        \n        vec4 c = load(tex_config, iChannel0);\n        vec4 v = load(tex_view, iChannel0);\n        vec4 t = load(tex_table, iChannel0);\n        vec3 n = load(tex_cast.xy+vec2(1,0), iChannel1).rgb;\n        vec3 p = h.xyz;\n        \n        vec3 r = p; r.xz *= rot(t.x);\n        float x = t.y == _max_acceleration ? uv.x : clamp((atan(r.z, r.x)+PI)/TAU,0.,1.);\n        float y = clamp(p.y/v.z,0.,1.);\n        \n        float dir = length(r.xz) < -texture(iChannel0, vec2(x,y)*_res_map/iResolution.xy).x+.29 ? -1. : 1.;\n        \n        // Fold x-space into a cylinder (thanks StackOverflow)\n        if (abs(x-uv.x)>0.5)\n        {\n            if (x<uv.x) x+= 1.;\n            else uv.x += 1.;\n        }\n        \n        float size = clamp(load(tex_brush_size, iChannel2).x,.1,1.);\n        float blur = clamp(load(tex_brush_blur, iChannel2).x,0.,1.);\n        float alpha = clamp(load(tex_brush_alpha, iChannel2).x,0.,1.);\n        \n        float d = length(vec2(x,y)-uv)-size*.5;\n        float f = smoothstep(d,d+blur*.5,0.0) * alpha;\n        \n        if (index == 0.)\n        {\n            // Sculpt\n            if (c.z == 0.)\n            {\n                fragColor.x = clamp(fragColor.x + f*0.005 * dir, -.4, .36);\n            }\n            // Smoothen\n            else if (c.z == 1.)\n            {\n                float s = .1;\n                d = 0.;\n                \n                float x1 = mod(fragCoord.x+s,1.);\n                float x2 = fragCoord.x-s;\n                \n                if (x2 < 0.) x2 += 1.;\n\n                d += texture(iChannel0, vec2(x1,fragCoord.y)/iResolution.xy).x;\n                d += texture(iChannel0, vec2(x2,fragCoord.y)/iResolution.xy).x;\n                //d += texture(iChannel0, vec2(uv.x,clamp(uv.y-s,0.,1.))*RES/iResolution.xy).x;\n                //d += texture(iChannel0, vec2(uv.x,clamp(uv.y+s,0.,1.))*RES/iResolution.xy).x;\n\n                d /= 2.;\n\n                fragColor.x = clamp(fragColor.x - f*(fragColor.x-d) * .1, -.4, .36);\n            }\n        }\n        else if(c.z == 3.)\n        {            \n            // Painting (outer)\n            if (index == 1. && dir == 1.)\n            {\n                vec4 picker = load(tex_color_picker,iChannel2); \n                vec4 col = vec4(hsv2rgb(vec3(clamp(picker.w,0.,1.),picker.xy)),f*alpha);\n                \n                fragColor.rgb = fragColor.rgb*(1.-col.a) + col.rgb*col.a;\n                fragColor.w = clamp(fragColor.w+col.a,0.,1.);\n            }\n            // Painting (inner)\n            else if (index == 2. && dir == -1.)\n            {\n                vec4 picker = load(tex_color_picker,iChannel2); \n                vec4 col = vec4(hsv2rgb(vec3(clamp(picker.w,0.,1.),picker.xy)),f*alpha);\n                \n                fragColor.rgb = fragColor.rgb*(1.-col.a) + col.rgb*col.a;\n                fragColor.w = clamp(fragColor.w+col.a,0.,1.);\n            }\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Data access makros\n#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n#define inside_range(a) (fragCoord.x >= a.x+0.5 && fragCoord.x <= (a.x+a.z)+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) textureLod(b,(a+0.5)/iResolution.xy,0.)\n\n// Data variables\nconst vec2 tex_config = vec2(0,0);\nconst vec2 tex_table = vec2(1,0);\nconst vec2 tex_view = vec2(2,0);\nconst vec3 tex_cast = vec3(0,0,1);\n\n#define P 0.001  // Precision\n#define D 25.    // Max distance\n#define S 512    // Marching steps\n#define R 3.     // Marching substeps\n#define K 4.     // Shadow softness\n#define A 4.     // AO steps\n#define M 0.     // Multisampling\n\n#define T iTime\n#define PI 3.14159\n#define TAU (PI*2.)\n\nstruct Hit {\n    vec3  p; // position\n    float t; // distance travelled\n    float d; // distance to object\n    float s; // steps required\n};\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n} _ray;\n\nstruct Cam {\n    vec3 u; // up vector\n    vec3 p; // position\n    vec3 t; // target\n} _cam;\n\nconst int _num_objects = 4;\nfloat _obj[_num_objects], _d;\nint _ignore_object = -1;\n\nvec2 _uv;\nvec4 _t, _v, _c; // table, view, config\n\nbool _shadowMarch = false;\nbool _normalMarch = false;\n\n/* ================= */\n/* === Utilities === */\n/* ================= */\n\nmat2 rot(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 smax(vec3 a,vec3 b,float k )\n{\n    vec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec2 hash22(vec2 p)\n{\n    return vec2(\n        fract(sin(dot(p, vec2(50159.91193,49681.51239))) * 73943.1699),\n        fract(sin(dot(p, vec2(90821.40973,2287.622010))) * 557.965570)\n    );\n}\n\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    \n    f += textureLod(iChannel2, p*08.,0.).x*1.;\n    f += textureLod(iChannel2, p*04.,0.).x*2.;\n    f += textureLod(iChannel2, p*02.,0.).x*4.;\n    f += textureLod(iChannel2, p*01.,0.).x*8.;\n    \n    return f/(1.+2.+4.+8.);\n}\n\n/* ============ */\n/* === Scene=== */\n/* ============ */\n\nfloat scene(vec3 p)\n{\n    float d = 1e10;\n\n    vec3 r  = p; r.xz *= rot(_t.x);\n    float a1 = clamp((atan(r.z, r.x)+PI)/TAU,0.01,1.);\n    float h = _v.z;\n    \n    // Table\n    _obj[0] = smax(length(p.xz)-.6,abs(p.y+.06)-.04,0.03);\n\n    // Pottery\n    float w1 = textureLod(iChannel0, vec2(floor(a1*_c.x),clamp(p.y/h,0.,1.)*(_c.x-1.)+2.)/iResolution.xy,0.).x;\n    _obj[1] = smax(abs(length(p.xz)-.3+w1)-.02,abs(p.y-h/2.)-h/2.,0.05);\n    \n    // Flooring\n    float w2 = textureLod(iChannel0, vec2(floor(a1*_c.x),10.)/iResolution.xy,0.).x;\n    _obj[2] = max(length(p.xz)-.3+w2,abs(p.y-.05)-.01);\n    \n    // Skybox\n    _obj[3] = abs(length(p-vec3(0,0,0))-18.)-P;\n    \n    if (_normalMarch == true)\n    {\n        float a2 = clamp((atan(r.z,-r.x)+PI)/TAU,0.01,1.);\n        float f = clamp(pow(abs(1.-min(abs(pow(a1*8.-4.,2.)),1.))*abs(1.-pow(a1*8.-4.,4.)),5.),0.,1.);\n        \n        // stretched wood distortion; simulates horizontal sculpting lines\n        // blend one part of the texture over the region where the seam would show\n        float t = smax(mix(\n            textureLod(iChannel1,vec2(a2/2.,r.y*4.),0.).r,\n            textureLod(iChannel1,vec2(a1/2.,r.y*4.),0.).r,\n        f),.5,.5);\n        \n        // fbm normal distortion; gives it a more clayish look\n        float s = mix(\n            fbm(vec2(a2,r.y)*.1),\n            fbm(vec2(a1,r.y)*.1),\n        f);\n        \n        // Only distort areas that are not painted\n        bool inside = length(r.xz) < -w1 + 0.29;\n        float p = textureLod(iChannel0, vec2(_c.x*(inside == true ? 2. : 1.) + floor(a2*_c.x),clamp(p.y/h,0.,1.)*_c.x+1.)/iResolution.xy,0.).w;\n\n        // Apply distortion\n        _obj[1] += t * .02 * s * (1.-p);\n    }\n\n    for(int i = 0; i < _num_objects; i++)\n    {\n        if (_ignore_object == i) continue;\n        d = min(d,_obj[i]);\n    }\n    \n    _d = d;\n\n    return d;\n}\n\n/* ================ */\n/* === Marching === */\n/* ================ */\n\nHit march(Ray r)\n{\n    vec3 p;\n    float t = 0., d, s;\n    \n    for(int i = 0; i < S; i++)\n    {\n        d = scene(p = r.o + r.d*t);\n\n        if (d < P || t > D)\n        {\n            s = float(i);\n            break;\n        }\n\n        t += d/R;\n    }\n\n    return Hit(p, t, d, s);\n}\n\nRay lookAt(Cam c, vec2 uv)\n{\n    vec3 d = normalize(c.t - c.p);\n    vec3 r = normalize(cross(d,c.u));\n    vec3 u = cross(r,d);\n\n    return Ray(c.p, normalize(uv.x*r + uv.y*u + d*2.));\n}\n\nvec3 getNormal(vec3 p)\n{\n    _normalMarch = true;\n    \n    vec2 e = vec2(P,0.);\n\n    return normalize(vec3(\n        scene(p+e.xyy)-scene(p-e.xyy),\n        scene(p+e.yxy)-scene(p-e.yxy),\n        scene(p+e.yyx)-scene(p-e.yyx)\n    ));\n}\n\n/* =============== */\n/* === Shading === */\n/* =============== */\n\nfloat getAmbietOcclusion(Hit h) \n{    \n    float t = 0., a = 0.;\n    \n    for(float i = 0.; i < A; i++)\n    {\n        float d = scene(h.p-_ray.d*i/A*.2);\n        t += d;\n    }\n\n    return clamp(t/A*10.,0.,1.);\n}\n\nfloat getShadow(vec3 light, vec3 origin)\n{\n    _shadowMarch = true;\n\n    float t = 0., s = 1.0;\n    float maxt = length(light - origin)-.1;\n    vec3 d = normalize(light - origin);\n\n    for(int i = 0; i < S; i++)\n    {\n        float d = scene(origin + d * t);\n        if (t > maxt || t > D) { break; }\n        t += d; s = min(s,d/t*K);\n    }\n\n    return s;\n}\n\nvec3 getColor(Hit h)\n{\n    if (h.d > P) { return vec3(0); }\n \n    vec3 n = getNormal(h.p);\n    vec3 r = h.p; r.xz *= rot(_t.x);\n\n    vec3 col = vec3(0);\n    vec3 light = vec3(0,1000,0);\n    \n    float diff = max(dot(n, normalize(light-h.p)),.4);\n    float spec = pow(max(dot(reflect(normalize(h.p-light),n),normalize(_cam.p-h.p)),0.),10.);\n\n    // Table\n    if (_d == _obj[0])\n    {    \n        col = mix(vec3(1,1,.8)*2., textureLod(iChannel1, r.xz,0.).rrr*1.5, .5) * diff + spec * 0.5;\n    }\n    // Clay, flooring\n    else if(_d == _obj[1] || _d == _obj[2])\n    {\n        float a1 = clamp((atan(r.z,-r.x)+PI)/TAU,0.01,1.);\n        float a2 = clamp((atan(r.z, r.x)+PI)/TAU,0.01,1.);\n        float l = _d == _obj[1] ? r.y : length(r.xz);\n\n        float f = clamp(pow(abs(1.-min(abs(pow(a2*8.-4.,2.)),1.))*abs(1.-pow(a2*8.-4.,2.)),5.),0.,1.);\n\n        // stretched wood distortion; simulates horizontal sculpting lines\n        // blend one part of the texture over the region where the seam would show\n        vec3 t = smax(mix(\n            textureLod(iChannel1,vec2(a1/2.,l*4.),0.).rrr,\n            textureLod(iChannel1,vec2(a2/2.,l*4.),0.).rrr,\n        f),vec3(.5),1.);\n        \n        // negative clamped fbm noise for a dried look\n        float s = 1.-pow(clamp(mix(\n            fbm(vec2(a2,l)*.5),\n            fbm(vec2(a1,l)*.5),\n        f)+.2,0.,1.),5.)*.25;\n\n        // Shape and paint textures\n        vec2 c = vec2(floor(a2*_c.x),clamp(h.p.y/_v.z,0.,1.)*_c.x+1.);\n        vec4 ts  = textureLod(iChannel0,  c                  / iResolution.xy,0.);\n        vec4 tpo = textureLod(iChannel0, (c+vec2(_c.x,   0)) / iResolution.xy,0.);\n        vec4 tpi = textureLod(iChannel0, (c+vec2(_c.x*2.,0)) / iResolution.xy,0.);\n        bool inside = length(r.xz) < -ts.x + 0.29;\n        \n        // extra ambient occlusion\n        float ao = max(smoothstep(0.,.1,h.p.y), .5);\n        \n        col = mix(\n            // clay\n            vec3(1,.9,.8)*t + spec * .5,\n            // paint\n            vec3(s) * (inside == false ? tpo.rgb : tpi.xyz) + sqrt(spec),\n            // paint density (alpha)\n            inside == false ? tpo.a : tpi.a\n        ) * ao;\n    }\n    // Skybox\n    else if(_d == _obj[3])\n    {\n        col = texture(iChannel3, n).bbg;\n    }\n\n    // ignore skybox while calculating the shadow\n    _ignore_object = 3;\n\n    return col * getAmbietOcclusion(h);\n}\n\n/* ============ */\n/* === Main === */\n/* ============ */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    _c = load(tex_config, iChannel0);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    // Discard pixels that are outside the defined resolution\n    if (uv.x > _c.y || uv.y > _c.y) { discard; }\n    \n    bool castRay = inside_range(tex_cast);\n    \n    if(castRay)\n    { _uv = (2.*iMouse.xy-iResolution.xy)/iResolution.xx; }\n    else    \n    { _uv = (2.*fragCoord.xy/_c.y-iResolution.xy)/iResolution.xx; }\n    \n    _v = load(tex_view, iChannel0);\n    _t = load(tex_table, iChannel0);\n\n    _cam = Cam(\n        vec3(0.0,1.0,0.0),\n        vec3(0.0,2.0,2.8),\n        vec3(0.0,0.4,0.0)\n    );\n\n    _cam.p.yz *= rot(-_v.y);\n    _cam.p.xz *= rot(_v.x*2.);\n    \n    _ray = lookAt(_cam,_uv);\n    \n    // Project mouse onto scene and store the information in the first two pixels\n    if(castRay)\n    {\n        Hit h = march(_ray);\n        \n        if (fragCoord.x < 1.)\n        {\n            fragColor.xyz = h.p;\n            fragColor.w = _d == _obj[1] ? 1. : _d == _obj[2] ? 2. : 0.;\n        }\n        else\n        {\n            fragColor.xyz = getNormal(h.p);\n        }\n    }\n    // Draw the scene with (optional) multisampling and a subtle vignette\n    else\n    {                   \n        vec3 col = getColor(march(_ray));\n        \n        for (float i = 0.0; i < M; i++)\n        {\n            _ignore_object = -1;\n            _shadowMarch = false;\n            _normalMarch = false;\n            \n            _ray = lookAt(_cam,_uv+hash22(_uv*i)/(iResolution.xy*_c.y));\n            col += getColor(march(_ray));\n        }\n        \n        float f = 1.-length((2.0*fragCoord.xy/_c.y-iResolution.xy)/iResolution.xy)*0.5;\n        fragColor = vec4(col/(M+1.)*f,1);\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define keyInfo(a,b) textureLod(iChannel3, vec2((a+.5)/256.,b),0.).x \nvec4 ch_spb = vec4(0x000000,0x00081,0xFF0000,0x000000);\n\n/* ======================= */\n/* ====== Font Code ====== */\n/* ======================= */\n\n// 96-bit 8x12 Font by Flyguy\n// https://www.shadertoy.com/view/Mt2GWD\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n/*\n--------\n-###----\n##-##---\n##-##---\n-###----\n#####-#-\n##-####-\n##--##--\n##-###--\n-###-##-\n--------\n--------\n\n00000000\n01110000\n11011000\n11011000\n01110000\n11111010\n11011110\n11001100\n11011100\n01110110\n00000000\n00000000\n\n//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.\n//Hexadecimal is being used to reduce clutter in the code but decimal still works.\n\n00000000\n01110000 -> 00000000 01110000 11011000 -> 0x0070D8\n11011000\n\n11011000\n01110000 -> 11011000 01110000 11111010 -> 0xD870FA\n11111010\n\n11011110\n11001100 -> 11011110 11001100 11011100 -> 0xDECCDC\n11011100\n\n01110110\n00000000 -> 01110110 00000000 00000000 -> 0x760000\n00000000\n\nvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n*/\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 res;\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n  return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n  for(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n          result += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n  for(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n          result += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n/* =========== */\n/* === GUI === */\n/* =========== */\n\n// From https://www.shadertoy.com/view/ldtGDX\n\n#define add(uiElem) if(uiElem == true) return;\n#define inside(a) (gl_FragCoord.x == a.x+0.5 && gl_FragCoord.y == a.y+0.5)\n#define load(a,b) textureLod(b,(a+0.5)/iResolution.xy,0.)\n\nfloat _d = 1e10, _t, _key_r;\nvec3 _colA = vec3(.25);\nvec3 _colB = vec3(.5);\nvec3 _colC = vec3(1);\n\nvec2 _uv, _uvm;\n\nconst vec2 tex_config = vec2(0,0);\nconst vec2 tex_brush_size = vec2(0,0);\nconst vec2 tex_brush_blur = vec2(1,0);\nconst vec2 tex_color_picker = vec2(2,0);\nconst vec2 tex_brush_alpha = vec2(3,0);\nconst vec2 tex_oninput = vec2(4,0);\n\nfloat udBox(vec2 p, vec2 s)\n{\n    return length(max(abs(p)-s,0.0));\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool hSlider(vec2 c, vec2 p, vec2 s, float x, inout vec4 fragColor)\n{    \n   s /= 2.;\n    \n   if (inside(c))\n   {\n       fragColor = textureLod(iChannel1, gl_FragCoord.xy/iResolution.xy,0.);\n       \n       if (iMouse.w > 0.0 && udBox(_uvm-p-s, s+vec2(s.y/4.,0)) == 0.0)\n       {\n           fragColor.x = (_uvm.x-p.x)/(s.x*2.);\n       }\n       \n       if (fragColor.x == 0.0) { fragColor.x = x; }\n       \n       return true;\n   }\n    \n   x = load(c, iChannel1).x;\n    \n   float d1 = udBox(_uv-p-s, s);\n   float d2 = udBox(_uv-p-s-vec2((x-0.5)*2.*(s.x-s.y/4.),0), vec2(s.y/4.,s.y));\n   \n   _d = min(_d,min(d1,d2));\n    \n   if (_d>0.0) { fragColor.w = -1.; return false; }\n   if (_d==d1) { fragColor = vec4(_colA,1); }\n   if (_d==d2) { fragColor = vec4(_colB,1); }\n    \n   return false;\n}\n\nbool colorPicker(vec2 c, vec2 p, vec2 s, float hue, inout vec4 fragColor)\n{\n   s /= 2.;\n    \n   if (inside(c))\n   {\n       fragColor = load(c,iChannel1);\n       if (fragColor.w == 0.0) { fragColor = vec4(0.5,.5,0.,hue); }       \n       \n       float d1 = udBox(_uvm-p-vec2(s.x-s.x/4.,s.y), vec2(s.x-s.x/4.,s.y));\n       float d2 = udBox(_uvm-p-vec2(2.*(s.x)-s.x/5.,s.y), vec2(s.x/5.,s.y+0.01));\n       \n       float d = min(d1,d2);\n       if (d > 0.0 || iMouse.w < 1.0) { return false; }\n       \n       p = (_uvm-p)/vec2(2.*(s.x)-s.x/5.,2.*s.y);\n       \n       if (d == d1)\n       { fragColor.xy = p.xy; }\n       else\n       { fragColor.w = p.y; }\n       \n       return true;\n   }\n    \n   vec4 data = load(c,iChannel1);\n   vec2 picker = data.xy*vec2(2.*(s.x)-s.x/5.,2.*s.y)+p;\n    \n   hue = clamp(data.w,0.,1.);\n\n   // spectrum\n   float d1 = udBox(_uv-p-vec2(s.x-s.x/4.,s.y), vec2(s.x-s.x/4.,s.y));\n   // hue slider\n   float d2 = udBox(_uv-p-vec2(2.*(s.x)-s.x/5.,(2.*s.y-0.01)*hue+0.005), vec2(s.x/5.,0.005));\n   // hue band\n   float d3 = udBox(_uv-p-vec2(2.*(s.x)-s.x/5.,s.y), vec2(s.x/5.,s.y));\n   // picker circle\n   float d4 = max(max(length(_uv-picker)-0.01,-length(_uv-picker)+0.007),sdBox(_uv-p-s,s));\n    \n   _d = min(_d,min(min(min(d1,d2),d3),d4));\n    \n   if (_d > 0.0 || _key_r > 0.)\n   {\n       fragColor.w = -1.;\n       return false;\n   }\n    \n   if (_d==d1)\n   {\n       p = (_uv-p)/vec2(2.*(s.x)-s.x/5.,2.*s.y);\n       fragColor = vec4(hsv2rgb(vec3(hue,p)),1);\n   }\n   else if (_d==d2)\n   {\n       fragColor = vec4(1);\n   }\n   else if (_d==d3)\n   {\n       p = (_uv-p)/vec2(2.*s.x/5.,2.*s.y);\n       fragColor = vec4(hsv2rgb(vec3(p.y,1,1)),1);\n   }\n   else if (_d==d4)\n   {\n       \n       fragColor = vec4(1);\n   }\n    \n   return false;\n}\n\nvec4 text()\n{\n  float s = 350.;\n    vec2 uv = floor(_uv*s);\n    vec3 c = vec3(0);\n\n    print_pos = vec2(.1,.9)*s;\n    \n    float d = 0.0;\n    \n    TEXT_MODE = INVERT;\n    d += char(ch_spc,uv);\n    \n    if (_t == 0.)\n    {\n        d += char(ch_s,uv);\n        d += char(ch_c,uv);\n        d += char(ch_u,uv);\n        d += char(ch_l,uv);\n        d += char(ch_p,uv);\n        d += char(ch_t,uv);\n    }\n    else if (_t == 1.)\n    {\n        d += char(ch_s,uv);\n        d += char(ch_m,uv);\n        d += char(ch_o,uv);\n        d += char(ch_o,uv);_key_r = keyInfo(82.,1.);\n        d += char(ch_t,uv);\n        d += char(ch_h,uv);\n        d += char(ch_e,uv);\n        d += char(ch_n,uv);\n    }\n    else if (_t == 2.)\n    {\n        d += char(ch_s,uv);\n        d += char(ch_t,uv);\n        d += char(ch_r,uv);\n        d += char(ch_e,uv);\n        d += char(ch_t,uv);\n        d += char(ch_c,uv);\n        d += char(ch_h,uv);\n    }\n    else if (_t == 3.)\n    {\n        d += char(ch_p,uv);\n        d += char(ch_a,uv);\n        d += char(ch_i,uv);\n        d += char(ch_n,uv);\n        d += char(ch_t,uv);\n    }\n    \n    d += char(ch_spc,uv);\n    TEXT_MODE = NORMAL;\n    \n    if (d > 0.) return vec4(vec3(.5),d); d = 0.;\n    \n  s = 480.;\n    uv = floor(_uv*s+.5);\n\n    float x = .22;\n    float y = .845;\n    \n    print_pos = vec2(x,y)*s;\n\n    d += char(ch_s,uv);\n    d += char(ch_i,uv);\n    d += char(ch_z,uv);\n    d += char(ch_e,uv);\n    \n    print_pos = vec2(x,y-STRHEIGHT(1.)/s*2.+.01)*s;\n        \n    d += char(ch_b,uv);\n    d += char(ch_l,uv);\n    d += char(ch_u,uv);\n    d += char(ch_r,uv);\n    \n    print_pos = vec2(x,y-STRHEIGHT(2.)/s*2.+.02)*s;\n    \n    if (_t == 3.)\n    {\n        d += char(ch_a,uv);\n        d += char(ch_l,uv);\n        d += char(ch_p,uv);\n        d += char(ch_h,uv);\n        d += char(ch_a,uv);\n    }\n    else\n    {\n        d += char(ch_s,uv);\n        d += char(ch_t,uv);\n        d += char(ch_r,uv);\n        d += char(ch_e,uv);\n        d += char(ch_n,uv); \n        d += char(ch_g,uv); \n        d += char(ch_t,uv); \n        d += char(ch_h,uv); \n    }\n    \n    if (d > 0.) return vec4(vec3(.5),d); d = 0.;\n    \n    x = .1;\n    y = .57;\n\n  float key_h = keyInfo(72.,1.);\n    \n    if (key_h < 1.)\n    {\n        print_pos = vec2(x,y)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_1,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_s,uv);        \n        d += char(ch_c,uv);\n        d += char(ch_u,uv);\n        d += char(ch_l,uv);\n        d += char(ch_p,uv);\n        d += char(ch_t,uv);\n\n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_2,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_s,uv);        \n        d += char(ch_m,uv);\n        d += char(ch_o,uv);\n        d += char(ch_o,uv);\n        d += char(ch_t,uv);\n        d += char(ch_h,uv);\n        d += char(ch_e,uv);\n        d += char(ch_n,uv);\n\n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_3,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_s,uv);        \n        d += char(ch_t,uv);\n        d += char(ch_r,uv);\n        d += char(ch_e,uv);\n        d += char(ch_t,uv);\n        d += char(ch_c,uv);\n        d += char(ch_h,uv);\n\n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_4,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_p,uv);        \n        d += char(ch_a,uv);\n        d += char(ch_i,uv);\n        d += char(ch_n,uv);\n        d += char(ch_t,uv);\n\n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_spb,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_r,uv);        \n        d += char(ch_o,uv);\n        d += char(ch_t,uv);\n        d += char(ch_a,uv);\n        d += char(ch_t,uv);\n        d += char(ch_e,uv);\n        \n        y -= .049;\n        \n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_7,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_r,uv);        \n        d += char(ch_a,uv);\n        d += char(ch_n,uv);\n        d += char(ch_d,uv);\n        d += char(ch_per,uv);\n        d += char(ch_spc,uv);\n        d += char(ch_s,uv);\n        d += char(ch_h,uv);\n        d += char(ch_a,uv);\n        d += char(ch_p,uv);\n        d += char(ch_e,uv);\n        d += char(ch_spc,uv);\n        d += char(ch_lbr,uv);\n        d += char(ch_y,uv);\n        d += char(ch_rbr,uv);\n        \n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_8,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_r,uv);        \n        d += char(ch_a,uv);\n        d += char(ch_n,uv);\n        d += char(ch_d,uv);\n        d += char(ch_per,uv);\n        d += char(ch_spc,uv);\n        d += char(ch_s,uv);\n        d += char(ch_h,uv);\n        d += char(ch_a,uv);\n        d += char(ch_p,uv);\n        d += char(ch_e,uv);\n        d += char(ch_spc,uv);\n        d += char(ch_lbr,uv);\n        d += char(ch_x,uv);\n        d += char(ch_com,uv);\n        d += char(ch_y,uv);\n        d += char(ch_rbr,uv);\n        \n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_9,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_r,uv);        \n        d += char(ch_a,uv);\n        d += char(ch_n,uv);\n        d += char(ch_d,uv);\n        d += char(ch_per,uv);\n        d += char(ch_spc,uv);\n        d += char(ch_p,uv);\n        d += char(ch_a,uv);\n        d += char(ch_i,uv);\n        d += char(ch_n,uv);\n        d += char(ch_t,uv);\n        \n        y -= .049;\n\n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_C,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_c,uv);        \n        d += char(ch_l,uv);\n        d += char(ch_e,uv);\n        d += char(ch_a,uv);\n        d += char(ch_r,uv);\n        d += char(ch_spc,uv);\n        d += char(ch_p,uv);\n        d += char(ch_a,uv);\n        d += char(ch_i,uv);\n        d += char(ch_n,uv);\n        d += char(ch_t,uv);\n\n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_X,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_r,uv);        \n        d += char(ch_e,uv);\n        d += char(ch_s,uv);\n        d += char(ch_e,uv);\n        d += char(ch_t,uv);\n        d += char(ch_spc,uv);\n        d += char(ch_s,uv);\n        d += char(ch_h,uv);\n        d += char(ch_a,uv);\n        d += char(ch_p,uv);\n        d += char(ch_e,uv);\n        \n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_R,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_t,uv);        \n        d += char(ch_o,uv);\n        d += char(ch_g,uv);\n        d += char(ch_g,uv);\n        d += char(ch_l,uv);\n        d += char(ch_e,uv);\n        d += char(ch_spc,uv);\n        d += char(ch_v,uv);\n        d += char(ch_i,uv);\n        d += char(ch_e,uv);\n        d += char(ch_w,uv);\n\n        print_pos = vec2(x,y-=STRHEIGHT(1.)/s+.01)*s;\n\n        TEXT_MODE = INVERT;\n\n        d += char(ch_spc,uv);\n        d += char(ch_H,uv);\n        d += char(ch_spc,uv);\n\n        TEXT_MODE = NORMAL;\n\n        d += char(ch_spc,uv);\n        d += char(ch_t,uv);        \n        d += char(ch_o,uv);\n        d += char(ch_g,uv);\n        d += char(ch_g,uv);\n        d += char(ch_l,uv);\n        d += char(ch_e,uv);\n        d += char(ch_spc,uv);\n        d += char(ch_h,uv);\n        d += char(ch_e,uv);\n        d += char(ch_l,uv);\n        d += char(ch_p,uv);\n  }\n    \n    return vec4(vec3(.25),d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = iResolution.xy / DOWN_SCALE;\n    \n    fragColor = textureLod(iChannel1, fragCoord/iResolution.xy,0.);\n    \n    _uv = fragCoord.xy/iResolution.yy;\n    _uvm = iMouse.xy/iResolution.yy;\n    \n    add(hSlider(tex_brush_size, vec2(0.1,0.8+.04), vec2(0.1,0.03), 0.5, fragColor));\n    add(hSlider(tex_brush_blur, vec2(0.1,0.8), vec2(0.1,0.03), 1., fragColor));\n    add(hSlider(tex_brush_alpha, vec2(0.1,0.8-.04), vec2(0.1,0.03), .5, fragColor));\n    \n    _t = load(tex_config, iChannel0).z;\n    _key_r = keyInfo(82.,1.);\n    \n    // show the color picker when the paint tool is selected\n    if (_t == 3.)\n    add(colorPicker(tex_color_picker, vec2(iResolution.x/iResolution.y-.25,.8), vec2(0.2,0.15), 0.6, fragColor));\n    \n    // keeps track of input/resolution changes\n    if (inside(tex_oninput))\n    {\n        vec4 v = load(tex_oninput, iChannel1);\n        \n        fragColor.y = v.x;\n        fragColor.z = v.w;\n        fragColor.w = iResolution.x;\n        \n        if( // r, h, 1, 2, 3, 4\n            keyInfo(72.,0.) > 0. ||\n            keyInfo(82.,0.) > 0. ||\n            keyInfo(49.,0.) > 0. ||\n            keyInfo(50.,0.) > 0. ||\n            keyInfo(51.,0.) > 0. ||\n            keyInfo(52.,0.) > 0.\n        )\n        {\n            fragColor.x = v.x == 0. ? 1. : 0.;\n        }\n        \n        return;\n    }\n    \n    vec4 oninput = load(tex_oninput, iChannel1);\n    \n    // only redraw the text when the GUI state changes\n    if (iFrame < 2 || oninput.x != oninput.y || oninput.z != oninput.w)\n    {\n        fragColor = vec4(0);\n            \n        if (_key_r < 1.)\n        {\n            vec4 t = text();\n            if (t.w > 0.) fragColor = vec4(t.xyz, 1.0);\n        }\n    }\n}","name":"Buf C","description":"","type":"buffer"}]}