{"ver":"0.1","info":{"id":"XdcXRf","date":"1460500833","viewed":453,"name":"Oh dear.....","username":"akohdr","description":"silliness....might be fun as a texture.\nOriginal implementation highlighted compilation limitations of using deep nested macros.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["retro","text","fun","word","characters","vic20"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Started off as a thought exercise for fast font system ...\n// .... then old memories crept in and an hour was lost :)\n\n// Irony is source is larger than VIC-20 RAM ?!!! ROFL\n\n// Originally implemented with cascaded macros much shorter <3000 chars\n// unfortunately unbearably slow to compile and publish and wouldn't work on iPhone\n\n#define BLU vec4(.0,.0,.7,1.)\n#define CYN vec4(.3,.8,.7,1.)\n#define WHT vec4(1)\n\n//<<<<<<<<<<<<<<<<<<<  UNCOMMENT for compile ERRORS\n// for those getting compilation errors uncomment this\n//  (you will loose everything but asterisk working on it...... )\n//#define LOW_MEMORY\n#define VDU_NOISE\n\n\n\n// Just enough to mockup screen, feel free to finish it, emulator in a shader anyone?\n\n// Using ASCII although if memory serves ye olde VIC-20 wasn't ASCII\n\n#define  s_ 32.\n#define  a_ 42.\n#define  d_ 46.\n#define n2_ 50.\n#define n3_ 51.\n#define n5_ 53.\n#define n8_ 56.\n#define  A_ 65.\n#define  B_ 66.\n#define  C_ 67.\n#define  D_ 68.\n#define  E_ 69.\n#define  F_ 70.\n#define  I_ 73.\n#define  M_ 77.\n#define  R_ 82.\n#define  S_ 83.\n#define  T_ 84.\n#define  V_ 86.\n#define  Y_ 89.\n\n// workaround for lack of arrays until GLSL 3\nbool bitIndex(float i,int a,int b,int c,int d,int e,int f,int g,int h)\n{\n    if(i<1.) return a>0;\n    else if(i<2.) return b>0;\n    else if(i<3.) return c>0;\n    else if(i<4.) return d>0;\n    else if(i<5.) return e>0;\n    else if(i<6.) return f>0;\n    else if(i<7.) return g>0;\n    return h>0;\n}\n\n// alternatively we can lean on mod masks.....  (why did it take till GLSL3 for bit ops?)\n\n/*\n\tWe can use exp2()\n// pow() has significant issues on iPad\n// quick dirty impl. provides integer powers of 2 up to 2^8\nfloat pow2_8(float p) {\n    if(p<1.) return 1.;\n    if(p<2.) return 2.;\n    if(p<3.) return 4.;\n    if(p<4.) return 8.;\n    if(p<5.) return 16.;\n    if(p<6.) return 32.;\n    if(p<7.) return 64.;\n    if(p<8.) return 128.;\n}\n*/\n\n\n// digit value from value v at column i (one based) under base b\nfloat modMask(lowp float v, lowp float i, lowp float b) {\n    float f = floor(i),           // forgetting to floor i causes headaches so included\n          p1 = pow(b,f-1.);\n    return (mod(v,pow(b,f))-mod(v,p1))/p1;\n}\n#define hexDigit(v,i) modMask(v,i,16.)\n//#define binDigit(v,i) modMask(v,i,2.)\n#define decDigit(v,i) modMask(v,i,10.)\n\n// fix for binDigit which was failing on iPad due to issues with pow()\nfloat binDigit(lowp float v, lowp float i) {\n    float f = floor(i),           // forgetting to floor i causes headaches so included\n          p1 = exp2(f-1.);\n    return (mod(v,exp2(f))-mod(v,p1))/p1;\n}\n\n// masks are input in reverse order and need index first for #define currying\nbool glyphMask(float x, float v) {\n    float f = 8.-floor(x),\n          p1 = pow(10.,f-1.),\n          m0 = mod(v,pow(10.,f)),\n          m1 = mod(v,p1);\n    return (m0-m1)/p1>.1;\n}\n\n// Turns out dangling static macros work fine (poor man's currying)\n#define MASK_1      if(y<=1.) glyphMaskY(b,h,y,0.5,x,\n#define MASK_2 else if(y<=2.) glyphMaskY(b,h,y,1.5,x,\n#define MASK_3 else if(y<=3.) glyphMaskY(b,h,y,2.5,x,\n#define MASK_4 else if(y<=4.) glyphMaskY(b,h,y,3.5,x,\n#define MASK_5 else if(y<=5.) glyphMaskY(b,h,y,4.5,x,\n#define MASK_6 else if(y<=6.) glyphMaskY(b,h,y,5.5,x,\n#define MASK_7 else if(y<=7.) glyphMaskY(b,h,y,6.5,x,\n#define MASK_8 else if(y<=8.) glyphMaskY(b,h,y,7.5,x,\n#define MASK_END return decDigit(b,y+1.)>.0;\n\n#define BITS_1      if(y<1.) return bitIndex(x,\n#define BITS_2 else if(y<2.) return bitIndex(x,\n#define BITS_3 else if(y<3.) return bitIndex(x,\n#define BITS_4 else if(y<4.) return bitIndex(x,\n#define BITS_5 else if(y<5.) return bitIndex(x,\n#define BITS_6 else if(y<6.) return bitIndex(x,\n#define BITS_7 else if(y<7.) return bitIndex(x,\n#define BITS_8 else if(y<8.) return bitIndex(x,\n\nvoid glyphMaskY(inout float b, float hmm, float y, float l, float x, float v) {\n\n    float a = abs(y-l);\n    \n    if(a<.5+hmm) {\n        \n        float f = 8.-floor(x+hmm),\n              p1 = pow(10.,f-1.),\n              m0 = mod(v,pow(10.,f)),\n              m1 = mod(v,p1);\n        b += pow(10.,y)*((m0-m1)/p1>.5 ? 1. : 0.);\n    }\n}\n\n// Nasty cascaded if impl.\n// makes for quick rendering after it eventually compiles\nbool glyph(const in vec4 p) {\n    float ch = p.w;\n    if((ch - s_)<.4) return false; //space\n\n    vec2 sl = mod(p.xy,8.);\n    float x = sl.x-1.05,   //used by macros\n          y = sl.y,\n\t\t  b = 0.;\n    \n    // OMG I think I inadvertently figured out why VIC-20 had wonky pixels(!)\n\t// likely artifacts of mains noise on comparator(s) in the rasterizer and demodulator\n    // tweak this for sub-pixel VDU effect  (US mains hum 60hz, UK 50hz)\n    // (could likely take it further with main noise bias in colour channels and interlacing)\n#ifdef  VDU_NOISE\n    float h = .07*(.3+abs(.3*sin(iTime)))*sin(50.*iTime);\n#else\n    float h = 0.;\n#endif\n/*\n    if((ch - a_)<1.){\n        glyphMaskY(b,h,y,0.5,x,00001000.);\n        glyphMaskY(b,h,y,1.5,x,00101010.);\n        glyphMaskY(b,h,y,2.5,x,00011100.);\n        glyphMaskY(b,h,y,3.5,x,00111110.);\n        glyphMaskY(b,h,y,4.5,x,00011100.);\n        glyphMaskY(b,h,y,5.5,x,00101010.);\n        glyphMaskY(b,h,y,6.5,x,00001000.);\n        glyphMaskY(b,h,y,7.5,x,00000000.);\n        return modMask(b,y+1.)>.0;\n    }\n*/\n/*\n    if((ch - a_)<1.){\n             if(y<1.) return glyphMask(x, 00001000.);\n        else if(y<2.) return glyphMask(x, 00101010.);\n        else if(y<3.) return glyphMask(x, 00011100.);\n        else if(y<4.) return glyphMask(x, 00011100.);\n        else if(y<5.) return glyphMask(x, 00011100.);\n        else if(y<6.) return glyphMask(x, 00101010.);\n        else if(y<7.) return glyphMask(x, 00001000.);\n        else if(y<8.) return glyphMask(x, 00000000.);\n    }\n*/    \n\n#ifdef LOW_MEMORY\n    #define  a_00101010 a_\n    if((ch - a_00101010)<.1){\n        MASK_1 00001000.);\n        MASK_2 00101010.);\n        MASK_3 00011100.);\n        MASK_4 00111110.);\n        MASK_5 00011100.);\n        MASK_6 00101010.);\n        MASK_7 00001000.);\n        MASK_8 00000000.);\n        MASK_END\n                        }\n#else\n\t// OK lets see if we can help out the compiler\n    // try (partial) red/black tree on value of ch\n    if(binDigit(ch,1.)<1.)   // fails on iPad ?! FIX: pow() has issues on iPad see binDigit()\n    {\n        if(binDigit(ch,2.)<1.) \n        {\n            #define n8_00111000 n8_\n            if((ch - n8_00111000)<.1){\n                MASK_1 00111100.);\n                MASK_2 01000010.);\n                MASK_3 01000010.);\n                MASK_4 00111100.);\n                MASK_5 01000010.);\n                MASK_6 01000010.);\n                MASK_7 00111100.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n            #define  D_01000100 D_\n            if((ch - D_01000100)<.1){\n                MASK_1 11110000.);\n                MASK_2 01001000.);\n                MASK_3 01000100.);\n                MASK_4 01000100.);\n                MASK_5 01000100.);\n                MASK_6 01001000.);\n                MASK_7 11110000.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n            #define  T_01010100 T_\n            if((ch - T_01010100)<.1){\n                MASK_1 01111100.);\n                MASK_2 00010000.);\n                MASK_3 00010000.);\n                MASK_4 00010000.);\n                MASK_5 00010000.);\n                MASK_6 00010000.);\n                MASK_7 00010000.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n        } \n        else \n        { //2\n            if(binDigit(ch,3.)<1.) \n            {\n                #define  a_00101010 a_\n                if((ch - a_00101010)<.1){\n                    MASK_1 00001000.);\n                    MASK_2 00101010.);\n                    MASK_3 00011100.);\n                    MASK_4 00111110.);\n                    MASK_5 00011100.);\n                    MASK_6 00101010.);\n                    MASK_7 00001000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define n2_00110010 n2_\n                if((ch - n2_00110010)<.1){\n                    MASK_1 00111100.);\n                    MASK_2 01000010.);\n                    MASK_3 00000010.);\n                    MASK_4 00001100.);\n                    MASK_5 00110000.);\n                    MASK_6 01000000.);\n                    MASK_7 01111110.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  B_01000010 B_\n                if((ch - B_01000010)<.1){\n                    MASK_1 11111000.);\n                    MASK_2 01000100.);\n                    MASK_3 01000100.);\n                    MASK_4 01111000.);\n                    MASK_5 01000100.);\n                    MASK_6 01000100.);\n                    MASK_7 11111000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  R_01010010 R_\n                if((ch - R_01010010)<.1){\n                    MASK_1 01111100.);\n                    MASK_2 01000010.);\n                    MASK_3 01000010.);\n                    MASK_4 01111100.);\n                    MASK_5 01001000.);\n                    MASK_6 01000100.);\n                    MASK_7 01000010.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n            } \n            else \n            {//3\n                #define  d_00101110 d_\n                if((ch - d_00101110)<.1){\n                    MASK_1 00000000.);\n                    MASK_2 00000000.);\n                    MASK_3 00000000.);\n                    MASK_4 00000000.);\n                    MASK_5 00000000.);\n                    MASK_6 00011000.);\n                    MASK_7 00011000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  F_01000110 F_\n                if((ch - F_01000110)<.1){\n                    MASK_1 01111110.);\n                    MASK_2 01000000.);\n                    MASK_3 01000000.);\n                    MASK_4 01111000.);\n                    MASK_5 01000000.);\n                    MASK_6 01000000.);\n                    MASK_7 01000000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  V_01010110 V_\n                if((ch - V_01010110)<.1){\n                    MASK_1 01000010.);\n                    MASK_2 01000010.);\n                    MASK_3 01000010.);\n                    MASK_4 01000010.);\n                    MASK_5 00100100.);\n                    MASK_6 00100100.);\n                    MASK_7 00011000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n            }\n        }\n    } \n    else // 1\n    {\n        if(binDigit(ch,2.)<1.) \n        {\n            if(binDigit(ch,3.)<1.) \n            {\n                #define  A_01000001 A_\n                if((ch - A_01000001)<.1){\n                    MASK_1 00011000.);\n                    MASK_2 00100100.);\n                    MASK_3 01000010.);\n                    MASK_4 01111110.);\n                    MASK_5 01000010.);\n                    MASK_6 01000010.);\n                    MASK_7 01000010.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  I_01001001 I_\n                if((ch - I_01001001)<.1){\n                    MASK_1 00111000.);\n                    MASK_2 00010000.);\n                    MASK_3 00010000.);\n                    MASK_4 00010000.);\n                    MASK_5 00010000.);\n                    MASK_6 00010000.);\n                    MASK_7 00111000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  Y_01011001 Y_\n                if((ch - Y_01011001)<.1){\n                    MASK_1 01000100.);\n                    MASK_2 01000100.);\n                    MASK_3 01000100.);\n                    MASK_4 00111000.);\n                    MASK_5 00010000.);\n                    MASK_6 00010000.);\n                    MASK_7 00010000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n            }\n            else \n            { //3\n                #define n5_00110101 n5_\n                if((ch - n5_00110101)<.1){\n                    MASK_1 01111110.);\n                    MASK_2 01000000.);\n                    MASK_3 01111000.);\n                    MASK_4 00000100.);\n                    MASK_5 00000010.);\n                    MASK_6 01000100.);\n                    MASK_7 00111000.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  E_01000101 E_\n                if((ch - E_01000101)<.1){\n                    MASK_1 01111110.);\n                    MASK_2 01000000.);\n                    MASK_3 01000000.);\n                    MASK_4 01111000.);\n                    MASK_5 01000000.);\n                    MASK_6 01000000.);\n                    MASK_7 01111110.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n                #define  M_01001101 M_\n                if((ch - M_01001101)<.1){\n                    MASK_1 01000010.);\n                    MASK_2 01100110.);\n                    MASK_3 01011010.);\n                    MASK_4 01000010.);\n                    MASK_5 01000010.);\n                    MASK_6 01000010.);\n                    MASK_7 01000010.);\n                    MASK_8 00000000.);\n                    MASK_END\n                        }\n            }\n        }\n        else \n        { //2\n            #define n3_00110011 n3_\n            if((ch - n3_00110011)<.1){\n                MASK_1 00111100.);\n                MASK_2 01000010.);\n                MASK_3 00000010.);\n                MASK_4 00011100.);\n                MASK_5 00000010.);\n                MASK_6 01000010.);\n                MASK_7 00111100.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n            #define  C_01000011 C_\n            if((ch - C_01000011)<.1){\n                MASK_1 00111000.);\n                MASK_2 01000100.);\n                MASK_3 10000000.);\n                MASK_4 10000000.);\n                MASK_5 10000000.);\n                MASK_6 01000100.);\n                MASK_7 00111000.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n            #define  S_01010011 S_\n            if((ch - S_01010011)<.1){\n                MASK_1 00111100.);\n                MASK_2 01000010.);\n                MASK_3 01000000.);\n                MASK_4 00111100.);\n                MASK_5 00000010.);\n                MASK_6 01000010.);\n                MASK_7 00111100.);\n                MASK_8 00000000.);\n                MASK_END\n                    }\n        }\n    }//1\n    \n#endif\n    \n\treturn false;\n}\n\n// Remainder of nested macro impl. messy but works\n#define k(C) if(i++>l){return C;}\nfloat frameBuffer(float loc) {\n    if(loc>110.) return s_;\n\n    int i = 1, l = int(loc);\n    if(l<23){\n        k(a_) k(a_) k(a_) k(a_) k(s_)\n        k(C_) k(B_) k(M_) k(s_) k(B_) k(A_) k(S_) k(I_) k(C_)\n        k(s_) k(V_) k(n2_) k(s_)\n        k(a_) k(a_) k(a_) k(a_)\n    }\n    if(l<44) return s_;\n    i = 45;\n    if(l<66){\n        k(n3_) k(n5_) k(n8_) k(n3_) k(s_) k(B_) k(Y_) k(T_) k(E_) k(S_) k(s_)\n        k(F_) k(R_) k(E_) k(E_) k(s_) k(s_) k(s_) k(s_) k(s_) k(s_) k(s_)\n    }\n    if(l<88) return s_;\n    i = 89;\n    if(l<110){\n    \tk(R_) k(E_) k(A_) k(D_) k(Y_) k(d_)\n    }    \n\n\treturn s_;\n}\n\nbool screen(in vec4 p) {\n    vec4 b = floor(p/8.);\n    p.z = floor(22.*b.y + b.x);\n    p.w = frameBuffer(p.z);\n    return glyph(p);\n}\n\nvec4 blink(vec2 p) {\n\treturn ((p.x>8.)||(p.x<1.)||(p.y>50.)||(p.y<42.)) ?\n        WHT : mod(iTime,1.2)<.6 ? BLU : WHT;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (iMouse.z>0.) ?\n        fragCoord/iMouse.xy :\n        fragCoord/iResolution.xy;\n\n    //flip screen\n    uv.y = 1.-uv.y;\n\n    vec2 b = vec2(.1,.15),\n         b1 = 1.01-b,\n         b2 = b/2.,\n         ins = uv-b2;\n    \n    if(ins.x<0. || ins.y<0. || ins.x>b1.x || ins.y>b1.y) {\n        fragColor = CYN;\n    } else {\n    \n        vec2 scr = (1.+b)*uv-b2,\n             xy = vec2(176.,184.)*scr;\n\n        xy.y -= 2.;  // feels just like adjusting V-sync on the portable telly :)\n\n        fragColor = screen(vec4(xy,0,0)) ? BLU : blink(xy);\n\n#ifdef VDU_NOISE\n        // interlacing noise suggestion per Andre\n        fragColor *= float(mod(float(iFrame)+floor(fragCoord.y),iResolution.y<768.?3.:4.));\n#endif\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}