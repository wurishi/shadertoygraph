{"ver":"0.1","info":{"id":"lcX3WN","date":"1703068287","viewed":20,"name":"Some Kind of Lines","username":"infiniteben","description":"Tried to do something clever with cellular noise and it did not work.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["lines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 nearest(vec2 a,vec2 b, vec2 p){\n    float rise = b.y-a.y;\n    float run = b.x-a.x;\n    float slope = rise/run;\n    vec2 p2 = p+vec2(-run,rise);\n    // we have two lines, figure out where they intersect\n    \n   \n    float x1 = a.x;\n    float y1 = a.y;\n    float x2 = b.x;\n    float y2 = b.y;\n    float x3 = p.x;\n    float y3 = p.y;\n    float x4= p2.x;\n    float y4 = p2.y;\n    float xT = (x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4);\n    float xB = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    float x = xT/xB;\n    float yT = (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4);\n    float yB = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    float y = yT/yB;\n    return vec2(x,y);\n}\n\nvec2 random2( vec2 p ,vec2 seed1, vec2 seed2) {\n    return fract(sin(vec2(dot(p,seed1),dot(p,seed2)))*43758.5453);\n}\nfloat line_blorps(vec2 uv,vec2 grid_i,vec2 grid_f,vec2 seed1, vec2 seed2){\n    float m_dist = 1.;  // minimum distance\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n           vec2 a = random2(grid_i + neighbor,seed1,seed2);\n            //b = random2(grid_i + neighbor,vec2(21.,3217.),vec2(141.,102.));\n           vec2 b = random2(grid_i + neighbor,seed2,vec2(102,23));\n            a=0.5+0.5*sin(iTime+ 6.2831*a);\n            b=0.5+0.5*sin(iTime+ 6.2831*b);\n\t\t\tvec2 point = nearest(a,b,grid_f);\n            // Animate the point\n            //point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            \n            \n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - grid_f;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n          \n        }\n    }\n    return m_dist;\n}\nfloat blorps(vec2 uv,vec2 grid_i,vec2 grid_f,vec2 seed1, vec2 seed2){\n    float m_dist = 1.;  // minimum distance\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(grid_i + neighbor,seed1,seed2);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - grid_f;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n    return m_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv*=3.;\n    \n    // Tile the space\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n     // Time varying pixel color\n    vec3 color= vec3(0.,0.,0.);\n    \n  \n  \n    vec2 a=vec2(0.,0.);\n    vec2 b=vec2(0.,0.);\n    float m_dist = line_blorps(uv,i_uv,f_uv, vec2(127.1,34.7), vec2(269.5,183.3));\n   float m_dist2 = blorps(uv,i_uv,f_uv, vec2(127.1,34.7), vec2(269.5,183.3));\n   \n    float m_dist3 = blorps(uv,i_uv,f_uv, vec2(269.5,183.3),vec2(102,23));\n    //float db = length(uv-b);\n    //color +=-step(.002,db);\n    //float m_dist2 = blorps(uv,i_uv,f_uv, vec2(552.1,34.7), vec2(39.5,183.3));\n    // Draw the min distance (distance field)\n    color += clamp(m_dist,0.,1.);\n    \n    // Draw cell center\n    color += 1.-step(.02, m_dist);\n    //color.xy += 1.-step(.02, m_dist2);\n    color.xz += 1.-step(.02, m_dist3);\n    // Draw cell center\n    //color += 1.-step(.02, m_dist2);\n    // Draw grid\n    //color.r += step(.98, f_uv.x) + step(.98, f_uv.y);\n   \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}