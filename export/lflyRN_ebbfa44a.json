{"ver":"0.1","info":{"id":"lflyRN","date":"1720912094","viewed":197,"name":"Harnack Lemniscate Surface","username":"mgillesp","description":"Render a level set of Piker's triply-periodic lemniscate surface via Harnack tracing\nSee https://mathstodon.xyz/@Danpiker/112700765144189568 and https://mathstodon.xyz/@Danpiker/112712824933016956 for more information about this surface","likes":9,"published":1,"flags":48,"usePreview":1,"tags":["3d","distancefield","sdf"],"hasliked":0,"parentid":"MffGzS","parentname":"Harnack Gyroid"},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader ray traces a triply-periodic implicit surface via Harnack tracing\n// See https://mathstodon.xyz/@Danpiker/112700765144189568\n// and https://mathstodon.xyz/@Danpiker/112712824933016956\n// for more information about this surface,\n// and https://markjgillespie.com/Research/harnack-tracing/\n// for more information about Harnack tracing\n\n// Camera controls: \n//   WASD / arrows: move forward, left, backward, right\n//   J,N          : move up & down\n//   K,M          : zoom in & out\n\n//=== program constants\nconst float epsilon = 0.05;\nconst int max_iterations = 350;\nconst float animation_speed = .5;\nconst float shift = .5 * PI;\nconst float global_scale = 5.;\n\n//=== isofunction parameters\n// 1 : plot imaginary part ( original lemniscate surface )\n// 0 : plot real part      ( orthogonal surface )\nconst int function_part = 1;\n\n//=== rendering method\n// 0 : harnack tracing\n// 1 : ray marching\nconst int method = 0;\n\n//=== scene parameters\n// 0 : clip to sphere\n// 1 : clip to cube\nconst int boundary_type = 1;\nconst vec3 sphereCenter = vec3( 0.f, 0.f, 0.f );\nconst float sphereRadius = .95;\nconst float outerRadius = sphereRadius + 0.5;\nconst float cylinder_radius = .025;\nconst vec3 light = vec3( 2., 10., 1. );\n\n//=== geometric helper functions\nvec2 nearest_lattice_point( vec2 p ) {\n    p *= global_scale;\n    \n    float n = round( ( p.x - 1. ) / 2. );\n    float m = round( ( p.y ) / 2. );\n    vec2 nearest = vec2( 2. * n + 1., 2. * m );\n    \n    return nearest / global_scale;\n}\n\nfloat cylinder_dist( vec2 p ) {\n    return length( nearest_lattice_point( p ) - p );\n}\n\nfloat cylinder_dist( vec3 p ) {\n    return min( min( cylinder_dist( p.xy ), cylinder_dist( p.yz ) ), cylinder_dist( p.zx ) ) - cylinder_radius; \n}\n\nvec3 nearest_lattice_point( vec3 p ) {\n    vec2 nxy = nearest_lattice_point( p.xy );\n    vec2 nyz = nearest_lattice_point( p.yz );\n    vec2 nzx = nearest_lattice_point( p.zx );\n    \n    float dxy = length( p.xy - nxy );\n    float dyz = length( p.yz - nyz );\n    float dzx = length( p.zx - nzx );\n    \n    if ( dxy <= dyz && dxy <= dzx ) {\n        return vec3( nxy.x, nxy.y,   p.z );\n    } else if ( dyz <= dzx ) {\n        return vec3(   p.x, nyz.x, nyz.y );\n    } else {\n        return vec3( nzx.y,   p.y, nzx.x );\n    }\n}\n\nbool intersect_boundary( vec3 ro, vec3 rd, out float t0, out float t1 ) {\n    switch ( boundary_type ) {\n    case 1 : // cube\n        return intersect_cube( ro, rd, sphereCenter, sphereRadius / sqrt( 3. ), t0, t1 );\n    case 0 : // sphere\n    default:\n        return intersectSphere( ro, rd, sphereCenter, sphereRadius, t0, t1 );\n    \n    }\n}\n\nvec3 max_component( vec3 v ) {\n    if ( abs( v.x ) >= abs( v.y ) && abs( v.x ) >= abs( v.z ) ) {\n        return vec3( 1., 0., 0. );\n    } else if ( abs( v.y ) >= abs( v.z ) ) {\n        return vec3( 0., 1., 0. );\n    } else {\n        return vec3( 0., 0., 1. );\n    }\n}\n\nvec3 boundary_normal( vec3 pos ) {\n    switch ( boundary_type ) {\n        case 1 : // cube\n            return max_component( pos - sphereCenter );\n        case 0 : // sphere\n        default:\n            return pos - sphereCenter;\n    }\n}\n\nbool intersect_singularities(vec3 ro, vec3 rd,  out float t, inout vec3 pos, float tmax, out vec3 normal ) {\n    float t0 = 0., t1 = tmax;\n    { // intersect ray with scene bounds\n        bool hitSphere = intersect_boundary(ro, rd, t0, t1);\n\n        if ( !hitSphere || t1 < 0. || t0 > tmax ) return false;\n        t0 = max( t0, 0. );\n        t1 = min( t1, tmax );\n    }\n\n    bool didHit = false;\n    \n    t = t0;\n    pos = ro + t * rd;\n    float epsilon = .00001;\n    if ( cylinder_dist( pos ) < epsilon ) {\n        normal = pos;\n        return true;\n    }\n    \n    for( int i=0; i<100 && t < t1; i++ ) {\n        pos = ro + t * rd;\n\n        float val = cylinder_dist( pos );\n        if ( val  < epsilon ) {\n            normal = pos - nearest_lattice_point( pos );\n            return true;\n        }\n        \n        t += val;\n    }\n    \n    normal = vec3(0.);\n    return false;\n}\n\n                      \n// only intersect from positive direction\nbool intersectPlane( vec3 ro, vec3 rd, vec3 n, float d, out float t ) {\n    // dot(n, ro + t rd - origin) == d\n    t = ( d - dot( n, ro ) ) / dot( n, rd );\n    return dot( rd, n ) < 0. && t >= 0.;\n}\n\nfloat getRadius( vec3 p ) {\n    return min( outerRadius - length( p ), cylinder_dist( p ) );\n}\n\nvec2 f_offset_cplex( vec2 z ) {\n    return sinlem( PI * cmul( z + vec2(1., 0.), vec2(1., 1.) / 4. ) );\n}\n\nfloat f_offset( vec2 z ) {\n    return clog( f_offset_cplex( z ) )[function_part];\n}\n\nfloat g( vec3 p ) {\n    return f_offset( p.xy ) + f_offset( p.yz ) + f_offset( p.zx );\n}\n\nfloat implicit_function( in vec3 pos ) {\n    return g( global_scale * pos );\n}\n\nvec2 g_cplex( vec3 p ) {\n    return cmul( f_offset_cplex( p.xy ), cmul( f_offset_cplex( p.yz ), f_offset_cplex( p.zx ) ) );\n}\n\nvec2 implicit_cplex( in vec3 pos ) {\n    return g_cplex( global_scale * pos );\n}\n\n// calculate gradient using finite differences\nvec3 calcGradAngleValued( in vec3 pos ) {\n    const float eps = 0.0005;      \n    const vec2 e = vec2(1., 0.);\n    \n    // use complex-valued version of function to avoid problems with finite differences mod 2π\n    vec2 g0 = g_cplex( pos + e.xxx * eps );\n    vec2 gx = g_cplex( pos + e.yxx * eps );\n    vec2 gy = g_cplex( pos + e.xyx * eps );\n    vec2 gz = g_cplex( pos + e.xxy * eps );\n    \n    float dx = arg( cdiv( gx, g0 ) );\n    float dy = arg( cdiv( gy, g0 ) );\n    float dz = arg( cdiv( gz, g0 ) );\n    \n    return vec3( dx, dy, dz ) / eps;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcGrad( in vec3 pos ) {\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    vec3 fd_grad =  e.xyy*g( pos + e.xyy*eps ) + \n\t\t            e.yyx*g( pos + e.yyx*eps ) + \n\t\t            e.yxy*g( pos + e.yxy*eps ) + \n\t\t            e.xxx*g( pos + e.xxx*eps );\n                    \n    if ( dot( fd_grad, fd_grad ) > 10. ) {\n        return calcGradAngleValued( pos );\n    } else {\n        return fd_grad;\n    }\n}\n\nvec3 gradient( in vec3 pos ) {\n    return global_scale * calcGrad( global_scale * pos );\n}\n\nbool closeToLevelset( float ang, float lowBound, float highBound, float tol ) {\n    return min( ang - lowBound, highBound - ang ) < tol;\n}\n\nbool raymarch(vec3 ro, vec3 rd, float tmax, out float t, out vec3 pos, out vec3 normal, out bool hit_boundary){\n    float levelset = mod( animation_speed * iTime, PI );\n    t = 0.0;\n    bool didHit = false;\n    \n    float t0 = 0., t1 = tmax;\n    {// intersect ray with scene bounds\n        bool hitSphere = intersect_boundary(ro, rd, t0, t1);\n\n        if ( !hitSphere || t1 < 0. || t0 > tmax ) return false;\n        if ( t0 > 0.f ) t = t0;\n        if ( t1 < tmax ) tmax = t1;\n        \n        // check for immediate intersection\n        vec3 pos = ro + t0 * rd;\n        float h = implicit_function( pos );\n        float val = mod( h - levelset, PI );\n        \n        vec3 gradF = gradient( pos );\n        if ( val <= epsilon || val >= PI - epsilon ) {\n            t = t0;\n            normal = boundary_normal( pos );\n            hit_boundary = true;\n            return true;\n        }\n    }\n    \n    t = t0;\n    pos = ro + t * rd;\n    \n    float loBound = 0.;\n    float hiBound = PI;\n    \n    for( int i=0; i<2000 && t < tmax; i++ ) {\n        pos = ro + t * rd;\n\n        float h = implicit_function( pos );\n        float val = mod( h - levelset, PI );\n        if (closeToLevelset(val, loBound, hiBound, epsilon )) {\n            normal = gradient( pos );\n            hit_boundary = false;\n            return true;\n        }\n        \n        t += 0.005;\n    }\n    \n    normal = vec3(0.);\n    hit_boundary = false;\n    return false;\n}\n\nfloat getMaxStep(float fx, float R, float lo_bound, float up_bound, float shift){\n    float w    = (fx + shift) / (up_bound + shift);\n    float v    = (fx + shift) / (lo_bound + shift);\n    float lo_r = -R / 2. * (v + 2. - sqrt(v * v + 8. * v));\n    float up_r =  R / 2. * (w + 2. - sqrt(w * w + 8. * w));\n    \n    return min(lo_r, up_r);\n}\n\nbool harnack(vec3 ro, vec3 rd,  out float t, inout vec3 pos, inout bool maxSteps, float tmax, out vec3 normal, out bool hit_boundary ) {\n    int iters = 0;\n    t = 0.f;\n    float levelset = mod( animation_speed * iTime, PI );\n    maxSteps = false;\n    \n    float t0 = 0., t1 = tmax;\n    { // intersect ray with scene bounds\n        bool hitSphere = intersect_boundary(ro, rd, t0, t1);\n\n        if ( !hitSphere || t1 < 0. || t0 > tmax ) return false;\n        if ( t0 > 0.f ) t = t0;\n        if ( t1 < tmax ) tmax = t1;\n        \n        // check for immediate intersection\n        vec3 pos = ro + t0 * rd;\n        float h = implicit_function( pos );\n        float val = mod( h - levelset, PI );\n        \n        vec3 gradF = gradient( pos );\n        if ( val <= epsilon || val >= PI - epsilon ) {\n            t = t0;\n            normal = boundary_normal( pos );\n            hit_boundary = true;\n            return true;\n        }\n    }\n    \n    t = t0;\n    pos = ro + t * rd;\n    \n    float loBound = 0.;\n    float hiBound = PI;\n    float t_overstep = 0.;\n\n    while (t < tmax){\n        iters++;\n\n        pos = ro + t * rd + t_overstep * rd;\n        if (iters > max_iterations){\n            maxSteps = true;\n            return false;\n        }\n        \n        float h = implicit_function( pos );\n        float val = mod( h - levelset, PI );\n        \n        if ( closeToLevelset(val, loBound, hiBound, epsilon ) ) {\n            normal = gradient( pos );\n            hit_boundary = false;\n            return true;\n        }\n\n        float R =  getRadius( pos );\n        float r = getMaxStep( val, R, loBound, hiBound, shift );\n        \n        // overstep was valid if r >= t_overstep\n        float stepSize = (r >= t_overstep) ? t_overstep + r : 0.;\n        t_overstep = (r >= t_overstep) ? r * .75 : 0.;\n        t += stepSize;\n     }\n     \n     normal = gradient( pos );\n    hit_boundary = false;\n     return false;\n}\n\nvec3 diffuseShade( vec3 pos, vec3 normal, vec3 light, vec3 materialColor ) {\n    return materialColor * max( dot( normalize( light - pos ), normal ), 0.3 );\n}\n\nvec3 fresnelShade( vec3 pos, vec3 ray, vec3 normal, vec3 materialColor ) {\n    return vec3( pow( 1. - abs( dot( ray, normal ) ), 4. ) );\n}\n\n// ( from https://www.shadertoy.com/view/7tKfz1 )\nvec3 normalShade(vec3 ray, vec3 normal, vec3 materialColor) {\n    // material\n    float metallic = 0.07;\n    float roughness = 0.1;\n    float fresnel_pow = mix(5.0, 3.5, metallic);\n    vec3 color_mod = vec3(1.0);\n    vec3 light_color = pow(texture(iChannel1,vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2));\n\n\n    // IBL\n    vec3 ibl_diffuse = pow(textureBlured(iChannel1,normal), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlured(iChannel1,reflect(ray,normal)), vec3(2.2));\n\n    // fresnel\n    float fresnel = max(1.0 - dot(normal,-ray), 0.0);\n    fresnel = pow(fresnel,fresnel_pow);    \n\n    // reflection        \n    vec3 refl = pow(texture(iChannel1,reflect(ray,normal)).xyz, vec3(2.2));\n    refl = mix(refl,ibl_reflection,(1.0-fresnel)*roughness);\n    refl = mix(refl,ibl_reflection,roughness);\n\n    // specular\n    vec3 light = normalize(vec3(-0.5,1.0,0.0));\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 spec = light_color * GGX(normal,-ray,light,roughness*0.7, 0.2);\n    refl -= spec;\n\n    // diffuse\n    vec3 diff = ibl_diffuse * pow(materialColor, vec3(2.2));\n    diff = mix(diff * color_mod,refl,fresnel);        \n\n    vec3 color = min( mix(diff,refl * color_mod,metallic) + spec, vec3(1., 1., 1.) );\n    return pow(color, vec3(1.0/2.2));\n}\n\nvec3 shade(vec3 pos, vec3 ray, vec3 normal, vec3 materialColor) {\n    return min(\n            diffuseShade( pos, normal, light, materialColor )\n            + 0.3 * normalShade( ray, normal, materialColor )\n            + 0.6 * fresnelShade( pos, ray, normal, materialColor ),\n            vec3(1., 1., 1.)\n        );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1\n#endif\n\nvec3 inBounds( float x, vec2 bounds ) {\n    return ( bounds.x <= x && x <= bounds.y ) ? vec3( 1. ) : vec3( 0. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    if ( false ) { // draw just the function f_offset and its marked singularities in 2D\n        vec2 cCoord = 1. * ( fragCoord - vec2( iResolution ) / 2. ) / iResolution.y;\n        fragColor = vec4( rainbow( f_offset( cCoord * global_scale ), vec2( -PI, PI ) ), 1. );\n        if ( cylinder_dist( cCoord ) < .05 / global_scale ) {\n            fragColor = vec4( 0., 0., 0., 1. );\n        }\n        \n        return;\n    }\n\n    // Calculate camera configuration from keyboard & mouse input buffer\n    // (from https://www.shadertoy.com/view/7tKfz1)\n    vec2 camRot = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 cr = cos(camRot);\n    vec2 sr = sin(camRot);\n    mat3 v2wRotMat = mat3(\n            cr.y,         0.0,  -sr.y,\n            sr.x * sr.y,  cr.x,  cr.y * sr.x,\n            cr.x * sr.y, -sr.x,  cr.x * cr.y);\n    vec4 camPosD = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 camPos = (camPosD.xyz + v2wRotMat * vec3(0.0, 0.0, 0.85) * camPosD.w); \n    float fovY = 50.0;\n    vec2 tanHalfFov = vec2(tan(radians(fovY) * 0.5)); \n    tanHalfFov.x *= iResolution.x / iResolution.y;\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n         // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        // vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0 + o / iResolution.y;\n        vec3 vDir = normalize(vec3(cCoord * tanHalfFov, -1.0));\n        #else    \n        // vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0;\n        vec3 vDir = normalize(vec3(cCoord * tanHalfFov, -1.0));\n        #endif\n\n\t    // create view ray\n        // vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        vec3 rd = normalize( v2wRotMat * vDir );\n        vec3 ro = camPos;\n\n        // raymarch\n        float tmax = 10.0;\n        vec3 pos, n;\n        bool didHit = false;\n        \n        bool hit_singularity;\n        vec3 sing_pos, sing_n;\n        float sing_t;\n        hit_singularity = intersect_singularities( ro, rd, sing_t, sing_pos, tmax, sing_n );\n        if ( hit_singularity ) tmax = sing_t;\n        \n        bool maxSteps, surfaceShadowed = false, hit_sphere = false;\n        float t;\n        if (method == 1) {\n            didHit = raymarch(ro, rd, tmax, t, pos, n, hit_sphere );\n        } else {\n            didHit = harnack(ro, rd, t, pos, maxSteps, tmax, n, hit_sphere );\n        }\n    \n        // shading/lighting\t\n        vec3 col = vec3(218., 214., 185.) / 255.;\n        if ( false && maxSteps && !hit_singularity ) {\n            col =  vec3(1.f,0.0,0.0);\n        } else if( didHit || ( maxSteps && !hit_singularity ) ) {\n            vec3 nor = normalize( n );\n            \n            float levelset = mod( animation_speed * iTime, 2. * PI );\n            float h = implicit_function( pos );\n            float val = mod( h - levelset, 2. * PI );\n            bool left = val < PI;\n            \n            vec3 baseColor = hit_sphere ? vec3(.025,.1, .15) : (left ? vec3(13., 72., 83.) / 255. : vec3(175., 80., 60.) / 255. );\n            \n            vec3 outwardNormal = dot( nor, rd ) > 0. ? -nor : nor;\n            col = shade( pos, rd, outwardNormal, baseColor );\n            // if ( surfaceShadowed ) col = vec3(0, 0, 1);\n        } else if ( hit_singularity ) {\n            vec3 nor = normalize( sing_n );\n            \n            vec3 baseColor = vec3(.05,.025, .2);\n            vec3 outwardNormal = dot( nor, rd ) > 0. ? -nor : nor;\n            col = shade( sing_pos, rd, outwardNormal, baseColor );\n        }\n        \n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358979323846;\n\n// find a vector orthogonal to v\nvec3 orthogonal( vec3 v ) {\n    if ( abs( v.x ) <= abs( v.y ) && abs( v.x ) <= abs( v.z ) ) {\n        return normalize( vec3( 0., -v.z, v.y ) );\n    } else if ( abs( v.y ) <= abs( v.x ) && abs( v.y ) <= abs( v.z ) ) {\n        return normalize( vec3( v.z, 0., -v.x ) );\n    } else {\n        return normalize( vec3( -v.y, v.x, 0. ) );\n    }\n}\n\nbool intersectSphere( vec3 ro, vec3 rd, vec3 center, float radius, inout float t0, inout float t1 ) {\n  float t = -1.0f;\n  float a = dot(rd, rd);\n  float b = 2.0f * dot(rd, ro - center);\n  float c = dot(ro-center, ro-center)-pow(radius, 2.f);\n  float discr = b * b - 4.f * a * c;\n  if (discr < 0.f) return false;\n  else if (discr < .0001){\n    t0 = - 0.5 * b / a;\n    t1 = t0;\n    return true;\n  }\n  else{\n    float q = (b > 0.f) ?\n            -0.5 * (b + sqrt(discr)) :\n            -0.5 * (b - sqrt(discr));\n        t0 = q / a;\n        t1 = c / q;\n        if (t1 < t0) {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n       \n        return true;\n  }\n}\n\nbool intersect_cube( vec3 ro, vec3 rd, vec3 center, float radius, inout float t0, inout float t1 ) {\n    // < ro + t rd, ei > = < center, ei > - radius\n    // <=> t rd = center - ro - radius\n    // <=> t = ( center - ro - radius ) / rd [componentwise]\n    \n    // Intuition (not exactly the same) from https://gamedev.stackexchange.com/a/39903\n    // Using your ray's direction vector, determine which 3 of the 6 candidate planes\n    // would be hit first. If your (unnormalized) ray direction vector is (-1, 1, -1),\n    // then the 3 planes that are possible to be hit are +x, -y, and +z.\n    // Of the 3 candidate planes, do find the t-value for the intersection for each.\n    // Accept the plane that gets the largest t value as being the plane that got hit,\n    // and check that the hit is within the box.\n    \n    vec3 vmin = center - radius;\n    vec3 vmax = center + radius;\n    \n    // https://gamedev.stackexchange.com/a/103714\n    float t[10];\n    t[1] = (vmin.x - ro.x)/rd.x;\n    t[2] = (vmax.x - ro.x)/rd.x;\n    t[3] = (vmin.y - ro.y)/rd.y;\n    t[4] = (vmax.y - ro.y)/rd.y;\n    t[5] = (vmin.z - ro.z)/rd.z;\n    t[6] = (vmax.z - ro.z)/rd.z;\n    t0 = max(max(min(t[1], t[2]), min(t[3], t[4])), min(t[5], t[6]));\n    t1 = min(min(max(t[1], t[2]), max(t[3], t[4])), max(t[5], t[6]));\n    \n    return t0 < t1;\n}\n\n//===== Complex arithmetic (from https://www.shadertoy.com/view/NlG3DD)\nfloat re( vec2 z ) { return z.x; }\nfloat im( vec2 z ) { return z.y; }\n\nvec2 cexp( float s ) {\n    return vec2( cos( s ), sin( s ) );\n}\n\nvec2 cexp( vec2 z ) {\n    return exp( z.x ) * cexp( z.y );\n}\n\nfloat arg( vec2 z ) {\n    return atan( z.y, z.x );\n}\n\nvec2 clog( vec2 z ) {\n    return vec2( log( length( z ) ), arg( z ) );\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\nvec2 imul( vec2 z ) {\n    return vec2( -z.y, z.x );\n}\n\n// complex conjugation\nvec2 conj(vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\n// complex inverse\nvec2 inv(vec2 a) {\n   return conj(a)/dot(a,a);\n}\n\n// complex division\nvec2 cdiv(vec2 a, vec2 b) {\n    return cmul(a,inv(b));\n}\n\n// complex square root\n// https://math.stackexchange.com/a/44500\nvec2 csqrt( vec2 z ) {\n    float r = length( z );\n    vec2 zr = z + vec2( r, 0. );\n    return sqrt( r ) * zr / length( zr );\n}\n\n// complex sine\nvec2 csin( vec2 z ) {\n    vec2 iz = imul( z );\n    return -imul(( cexp( iz ) - cexp( -iz ) ) / 2.);\n}\n\n// complex cosine\nvec2 ccos( vec2 z ) {\n    vec2 iz = imul( z );\n    return ( cexp( iz ) + cexp( -iz ) ) / 2.;\n}\n\n// complex arcsin\n// http://scipp.ucsc.edu/~haber/archives/physics116A10/arc_10.pdf\nvec2 carcsin( vec2 z ) {\n    vec2 w = vec2( 1., 0. ) - cmul( z, z );\n    return -imul( clog( imul( z ) + length( w ) *  cexp( arg( w ) / 2. ) ) );\n}\n\n\n//==== Jacobi Theta Functions\n// power series from here: https://mathworld.wolfram.com/JacobiThetaFunctions.html\nint roundF( float x ) {\n    return int( floor( x + .5 ) );\n}\n  \nvec2 jacobi_theta_1( vec2 z ) {\n    // really θ1( z, e^-π ) = θ1( z | i )\n    float x = PI * mod( z.x / (PI), 1. );\n    float y = PI * mod( z.y / (PI), 1. );\n    float a = ( z.x - x ) / (PI);\n    float b = ( z.y - y ) / (PI);\n    \n    // z = vec2( x, y );\n    \n    // by quasiperiodicity, θ1( z | i ) = scale * θ1( x + i y | i )\n    vec2 scale = (roundF( a + b ) % 2 == 0 ? 1. : -1.) * cexp( vec2( -PI * b * b, 0. ) - 2. * b * imul( z ) );\n    scale = vec2( 1., 0. );\n    \n    // series for θ1\n    vec2 series = vec2( 0. );\n    float q = exp( -PI );\n    // float coeff = q;\n    for ( int n = 0; n < 3; n++ ) {\n        float coeff = ((n % 2 == 0) ? 1. : -1. ) * pow( q, float( n * n + n ) );\n        series += coeff * csin( (float( 2 * n ) +1.) * z );\n    }\n    \n    return 2. * pow( q, .25 ) * cmul( scale, series );\n}\n\nvec2 jacobi_theta_3( vec2 z ) {\n    // really θ3( z, e^-π ) = θ3( z | i )\n    float x = PI * mod( z.x / (PI), 1. );\n    float y = PI * mod( z.y / (PI), 1. );\n    // float a = ( z.x - x ) / (PI);\n    float b = ( z.y - y ) / (PI);\n    \n    z = vec2( x, y );\n    \n    // by quasiperiodicity, θ1( z | i ) = scale * θ1( x + i y | i )\n    vec2 scale = cexp( vec2( -PI * b * b, 0. ) - 2. * b * imul( z ) );\n    // scale = vec2( 1., 0. );\n    \n    // series for θ3\n    vec2 series = vec2( 0. );\n    float q = exp( -PI );\n    for ( int n = 1; n < 3; n++ ) {\n        float coeff = pow( q, float( n * n ) );\n        series += coeff * ccos( 2. * float( n ) * z );\n    }\n    \n    return cmul( scale, vec2( 1., 0. ) + 2. * series );\n}\n\n// https://en.wikipedia.org/wiki/Lemniscate_elliptic_functions#Methods_of_computation\nvec2 sinlem( vec2 z ) {    \n    return cdiv( jacobi_theta_1( z ), jacobi_theta_3( z ) );\n}\n\n\n\n//============================================================================//\n\n// Start of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n// (taken from https://www.shadertoy.com/view/7tKfz1)\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n// GGX code from https://www.shadertoy.com/view/MlB3DV\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n\n\n// End of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\n\n// Smooth HSV to RGB conversion ( https://www.shadertoy.com/view/MsS3Wc )\nvec3 hsv( in float h, in float s, in float v )\n{\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn v * mix( vec3(1.0), rgb, s);\n}\n\n\n// Colormaps\nvec3[256] viridis_colors = vec3[](\n    vec3(0.26666666666666666, 0.00392156862745098, 0.32941176470588235),vec3(0.26666666666666666, 0.00784313725490196, 0.33725490196078434),vec3(0.27058823529411763, 0.01568627450980392, 0.3411764705882353),vec3(0.27058823529411763, 0.0196078431372549, 0.34901960784313724),vec3(0.27450980392156865, 0.027450980392156862, 0.35294117647058826),vec3(0.27450980392156865, 0.03137254901960784, 0.3607843137254902),vec3(0.27450980392156865, 0.0392156862745098, 0.36470588235294116),vec3(0.27450980392156865, 0.043137254901960784, 0.3686274509803922),vec3(0.2784313725490196, 0.050980392156862744, 0.3764705882352941),vec3(0.2784313725490196, 0.054901960784313725, 0.3803921568627451),vec3(0.2784313725490196, 0.06274509803921569, 0.38823529411764707),vec3(0.2784313725490196, 0.06666666666666667, 0.39215686274509803),vec3(0.2784313725490196, 0.07450980392156863, 0.396078431372549),vec3(0.2823529411764706, 0.0784313725490196, 0.403921568627451),vec3(0.2823529411764706, 0.08627450980392157, 0.40784313725490196),vec3(0.2823529411764706, 0.09019607843137255, 0.4117647058823529),vec3(0.2823529411764706, 0.09411764705882353, 0.41568627450980394),vec3(0.2823529411764706, 0.10196078431372549, 0.4235294117647059),vec3(0.2823529411764706, 0.10588235294117647, 0.42745098039215684),vec3(0.2823529411764706, 0.10980392156862745, 0.43137254901960786),vec3(0.2823529411764706, 0.11372549019607843, 0.43529411764705883),vec3(0.2823529411764706, 0.12156862745098039, 0.4392156862745098),vec3(0.2823529411764706, 0.12549019607843137, 0.44313725490196076),vec3(0.2823529411764706, 0.12941176470588237, 0.45098039215686275),vec3(0.2823529411764706, 0.13725490196078433, 0.4549019607843137),vec3(0.2823529411764706, 0.1411764705882353, 0.4588235294117647),vec3(0.2823529411764706, 0.1450980392156863, 0.4627450980392157),vec3(0.2823529411764706, 0.14901960784313725, 0.4666666666666667),vec3(0.2823529411764706, 0.1568627450980392, 0.47058823529411764),vec3(0.2823529411764706, 0.1607843137254902, 0.4745098039215686),vec3(0.2784313725490196, 0.16470588235294117, 0.47843137254901963),vec3(0.2784313725490196, 0.17254901960784313, 0.47843137254901963),vec3(0.2784313725490196, 0.17647058823529413, 0.4823529411764706),vec3(0.2784313725490196, 0.1803921568627451, 0.48627450980392156),vec3(0.2784313725490196, 0.1843137254901961, 0.49019607843137253),vec3(0.27450980392156865, 0.18823529411764706, 0.49411764705882355),vec3(0.27450980392156865, 0.19607843137254902, 0.49411764705882355),vec3(0.27450980392156865, 0.2, 0.4980392156862745),vec3(0.27450980392156865, 0.20392156862745098, 0.5019607843137255),vec3(0.27058823529411763, 0.20784313725490197, 0.5058823529411764),vec3(0.27058823529411763, 0.21568627450980393, 0.5058823529411764),vec3(0.27058823529411763, 0.2196078431372549, 0.5098039215686274),vec3(0.26666666666666666, 0.2235294117647059, 0.5137254901960784),vec3(0.26666666666666666, 0.22745098039215686, 0.5137254901960784),vec3(0.26666666666666666, 0.23137254901960785, 0.5176470588235295),vec3(0.2627450980392157, 0.23921568627450981, 0.5176470588235295),vec3(0.2627450980392157, 0.24313725490196078, 0.5215686274509804),vec3(0.25882352941176473, 0.24705882352941178, 0.5215686274509804),vec3(0.25882352941176473, 0.25098039215686274, 0.5254901960784314),vec3(0.25882352941176473, 0.2549019607843137, 0.5254901960784314),vec3(0.2549019607843137, 0.25882352941176473, 0.5294117647058824),vec3(0.2549019607843137, 0.26666666666666666, 0.5294117647058824),vec3(0.25098039215686274, 0.27058823529411763, 0.5333333333333333),vec3(0.25098039215686274, 0.27450980392156865, 0.5333333333333333),vec3(0.24705882352941178, 0.2784313725490196, 0.5333333333333333),vec3(0.24705882352941178, 0.2823529411764706, 0.5372549019607843),vec3(0.24313725490196078, 0.28627450980392155, 0.5372549019607843),vec3(0.24313725490196078, 0.2901960784313726, 0.5372549019607843),vec3(0.24313725490196078, 0.2980392156862745, 0.5411764705882353),vec3(0.23921568627450981, 0.30196078431372547, 0.5411764705882353),vec3(0.23921568627450981, 0.3058823529411765, 0.5411764705882353),vec3(0.23529411764705882, 0.30980392156862746, 0.5411764705882353),vec3(0.23529411764705882, 0.3137254901960784, 0.5450980392156862),vec3(0.23137254901960785, 0.3176470588235294, 0.5450980392156862),vec3(0.23137254901960785, 0.3215686274509804, 0.5450980392156862),vec3(0.22745098039215686, 0.3254901960784314, 0.5450980392156862),vec3(0.22745098039215686, 0.32941176470588235, 0.5490196078431373),vec3(0.2235294117647059, 0.3333333333333333, 0.5490196078431373),vec3(0.2235294117647059, 0.33725490196078434, 0.5490196078431373),vec3(0.2196078431372549, 0.34509803921568627, 0.5490196078431373),vec3(0.2196078431372549, 0.34901960784313724, 0.5490196078431373),vec3(0.21568627450980393, 0.35294117647058826, 0.5490196078431373),vec3(0.21568627450980393, 0.3568627450980392, 0.5529411764705883),vec3(0.21176470588235294, 0.3607843137254902, 0.5529411764705883),vec3(0.21176470588235294, 0.36470588235294116, 0.5529411764705883),vec3(0.20784313725490197, 0.3686274509803922, 0.5529411764705883),vec3(0.20784313725490197, 0.37254901960784315, 0.5529411764705883),vec3(0.20392156862745098, 0.3764705882352941, 0.5529411764705883),vec3(0.20392156862745098, 0.3803921568627451, 0.5529411764705883),vec3(0.2, 0.3843137254901961, 0.5529411764705883),vec3(0.2, 0.38823529411764707, 0.5529411764705883),vec3(0.19607843137254902, 0.39215686274509803, 0.5568627450980392),vec3(0.19607843137254902, 0.396078431372549, 0.5568627450980392),vec3(0.19215686274509805, 0.4, 0.5568627450980392),vec3(0.19215686274509805, 0.403921568627451, 0.5568627450980392),vec3(0.19215686274509805, 0.40784313725490196, 0.5568627450980392),vec3(0.18823529411764706, 0.4117647058823529, 0.5568627450980392),vec3(0.18823529411764706, 0.41568627450980394, 0.5568627450980392),vec3(0.1843137254901961, 0.4196078431372549, 0.5568627450980392),vec3(0.1843137254901961, 0.4235294117647059, 0.5568627450980392),vec3(0.1803921568627451, 0.42745098039215684, 0.5568627450980392),vec3(0.1803921568627451, 0.43137254901960786, 0.5568627450980392),vec3(0.1803921568627451, 0.43529411764705883, 0.5568627450980392),vec3(0.17647058823529413, 0.4392156862745098, 0.5568627450980392),vec3(0.17647058823529413, 0.44313725490196076, 0.5568627450980392),vec3(0.17254901960784313, 0.44313725490196076, 0.5568627450980392),vec3(0.17254901960784313, 0.4470588235294118, 0.5568627450980392),vec3(0.17254901960784313, 0.45098039215686275, 0.5568627450980392),vec3(0.16862745098039217, 0.4549019607843137, 0.5568627450980392),vec3(0.16862745098039217, 0.4588235294117647, 0.5568627450980392),vec3(0.16470588235294117, 0.4627450980392157, 0.5568627450980392),vec3(0.16470588235294117, 0.4666666666666667, 0.5568627450980392),vec3(0.16470588235294117, 0.47058823529411764, 0.5568627450980392),vec3(0.1607843137254902, 0.4745098039215686, 0.5568627450980392),vec3(0.1607843137254902, 0.47843137254901963, 0.5568627450980392),vec3(0.1607843137254902, 0.4823529411764706, 0.5568627450980392),vec3(0.1568627450980392, 0.48627450980392156, 0.5568627450980392),vec3(0.1568627450980392, 0.49019607843137253, 0.5568627450980392),vec3(0.15294117647058825, 0.49411764705882355, 0.5568627450980392),vec3(0.15294117647058825, 0.4980392156862745, 0.5568627450980392),vec3(0.15294117647058825, 0.5019607843137255, 0.5568627450980392),vec3(0.14901960784313725, 0.5058823529411764, 0.5568627450980392),vec3(0.14901960784313725, 0.5098039215686274, 0.5568627450980392),vec3(0.14901960784313725, 0.5098039215686274, 0.5568627450980392),vec3(0.1450980392156863, 0.5137254901960784, 0.5568627450980392),vec3(0.1450980392156863, 0.5176470588235295, 0.5568627450980392),vec3(0.1450980392156863, 0.5215686274509804, 0.5568627450980392),vec3(0.1411764705882353, 0.5254901960784314, 0.5568627450980392),vec3(0.1411764705882353, 0.5294117647058824, 0.5568627450980392),vec3(0.13725490196078433, 0.5333333333333333, 0.5568627450980392),vec3(0.13725490196078433, 0.5372549019607843, 0.5568627450980392),vec3(0.13725490196078433, 0.5411764705882353, 0.5529411764705883),vec3(0.13333333333333333, 0.5450980392156862, 0.5529411764705883),vec3(0.13333333333333333, 0.5490196078431373, 0.5529411764705883),vec3(0.13333333333333333, 0.5529411764705883, 0.5529411764705883),vec3(0.12941176470588237, 0.5568627450980392, 0.5529411764705883),vec3(0.12941176470588237, 0.5607843137254902, 0.5529411764705883),vec3(0.12941176470588237, 0.5647058823529412, 0.5529411764705883),vec3(0.12941176470588237, 0.5686274509803921, 0.5490196078431373),vec3(0.12549019607843137, 0.5725490196078431, 0.5490196078431373),vec3(0.12549019607843137, 0.5725490196078431, 0.5490196078431373),vec3(0.12549019607843137, 0.5764705882352941, 0.5490196078431373),vec3(0.12156862745098039, 0.5803921568627451, 0.5490196078431373),vec3(0.12156862745098039, 0.5843137254901961, 0.5450980392156862),vec3(0.12156862745098039, 0.5882352941176471, 0.5450980392156862),vec3(0.12156862745098039, 0.592156862745098, 0.5450980392156862),vec3(0.12156862745098039, 0.596078431372549, 0.5450980392156862),vec3(0.12156862745098039, 0.6, 0.5411764705882353),vec3(0.12156862745098039, 0.6039215686274509, 0.5411764705882353),vec3(0.11764705882352941, 0.6078431372549019, 0.5411764705882353),vec3(0.11764705882352941, 0.611764705882353, 0.5372549019607843),vec3(0.11764705882352941, 0.615686274509804, 0.5372549019607843),vec3(0.12156862745098039, 0.6196078431372549, 0.5372549019607843),vec3(0.12156862745098039, 0.6235294117647059, 0.5333333333333333),vec3(0.12156862745098039, 0.6274509803921569, 0.5333333333333333),vec3(0.12156862745098039, 0.6313725490196078, 0.5333333333333333),vec3(0.12156862745098039, 0.6313725490196078, 0.5294117647058824),vec3(0.12156862745098039, 0.6352941176470588, 0.5294117647058824),vec3(0.12549019607843137, 0.6392156862745098, 0.5254901960784314),vec3(0.12549019607843137, 0.6431372549019608, 0.5254901960784314),vec3(0.12941176470588237, 0.6470588235294118, 0.5215686274509804),vec3(0.12941176470588237, 0.6509803921568628, 0.5215686274509804),vec3(0.13333333333333333, 0.6549019607843137, 0.5215686274509804),vec3(0.13333333333333333, 0.6588235294117647, 0.5176470588235295),vec3(0.13725490196078433, 0.6627450980392157, 0.5137254901960784),vec3(0.1411764705882353, 0.6666666666666666, 0.5137254901960784),vec3(0.1450980392156863, 0.6705882352941176, 0.5098039215686274),vec3(0.1450980392156863, 0.6745098039215687, 0.5098039215686274),vec3(0.14901960784313725, 0.6784313725490196, 0.5058823529411764),vec3(0.15294117647058825, 0.6784313725490196, 0.5058823529411764),vec3(0.1568627450980392, 0.6823529411764706, 0.5019607843137255),vec3(0.1607843137254902, 0.6862745098039216, 0.4980392156862745),vec3(0.16470588235294117, 0.6901960784313725, 0.4980392156862745),vec3(0.17254901960784313, 0.6941176470588235, 0.49411764705882355),vec3(0.17647058823529413, 0.6980392156862745, 0.49019607843137253),vec3(0.1803921568627451, 0.7019607843137254, 0.48627450980392156),vec3(0.1843137254901961, 0.7058823529411765, 0.48627450980392156),vec3(0.19215686274509805, 0.7098039215686275, 0.4823529411764706),vec3(0.19607843137254902, 0.7137254901960784, 0.47843137254901963),vec3(0.20392156862745098, 0.7137254901960784, 0.4745098039215686),vec3(0.20784313725490197, 0.7176470588235294, 0.4745098039215686),vec3(0.21568627450980393, 0.7215686274509804, 0.47058823529411764),vec3(0.2196078431372549, 0.7254901960784313, 0.4666666666666667),vec3(0.22745098039215686, 0.7294117647058823, 0.4627450980392157),vec3(0.23137254901960785, 0.7333333333333333, 0.4588235294117647),vec3(0.23921568627450981, 0.7372549019607844, 0.4549019607843137),vec3(0.24705882352941178, 0.7372549019607844, 0.45098039215686275),vec3(0.25098039215686274, 0.7411764705882353, 0.4470588235294118),vec3(0.25882352941176473, 0.7450980392156863, 0.44313725490196076),vec3(0.26666666666666666, 0.7490196078431373, 0.4392156862745098),vec3(0.27450980392156865, 0.7529411764705882, 0.43529411764705883),vec3(0.2823529411764706, 0.7568627450980392, 0.43137254901960786),vec3(0.2901960784313726, 0.7568627450980392, 0.42745098039215684),vec3(0.2980392156862745, 0.7607843137254902, 0.4235294117647059),vec3(0.3058823529411765, 0.7647058823529411, 0.4196078431372549),vec3(0.3137254901960784, 0.7686274509803922, 0.41568627450980394),vec3(0.3215686274509804, 0.7725490196078432, 0.4117647058823529),vec3(0.32941176470588235, 0.7725490196078432, 0.40784313725490196),vec3(0.33725490196078434, 0.7764705882352941, 0.403921568627451),vec3(0.34509803921568627, 0.7803921568627451, 0.396078431372549),vec3(0.35294117647058826, 0.7843137254901961, 0.39215686274509803),vec3(0.3607843137254902, 0.7843137254901961, 0.38823529411764707),vec3(0.3686274509803922, 0.788235294117647, 0.3843137254901961),vec3(0.3764705882352941, 0.792156862745098, 0.3764705882352941),vec3(0.38823529411764707, 0.796078431372549, 0.37254901960784315),vec3(0.396078431372549, 0.796078431372549, 0.3686274509803922),vec3(0.403921568627451, 0.8, 0.3607843137254902),vec3(0.4117647058823529, 0.803921568627451, 0.3568627450980392),vec3(0.4235294117647059, 0.803921568627451, 0.35294117647058826),vec3(0.43137254901960786, 0.807843137254902, 0.34509803921568627),vec3(0.4392156862745098, 0.8117647058823529, 0.3411764705882353),vec3(0.45098039215686275, 0.8156862745098039, 0.33725490196078434),vec3(0.4588235294117647, 0.8156862745098039, 0.32941176470588235),vec3(0.4666666666666667, 0.8196078431372549, 0.3254901960784314),vec3(0.47843137254901963, 0.8196078431372549, 0.3176470588235294),vec3(0.48627450980392156, 0.8235294117647058, 0.3137254901960784),vec3(0.4980392156862745, 0.8274509803921568, 0.3058823529411765),vec3(0.5058823529411764, 0.8274509803921568, 0.30196078431372547),vec3(0.5176470588235295, 0.8313725490196079, 0.29411764705882354),vec3(0.5254901960784314, 0.8352941176470589, 0.28627450980392155),vec3(0.5372549019607843, 0.8352941176470589, 0.2823529411764706),vec3(0.5450980392156862, 0.8392156862745098, 0.27450980392156865),vec3(0.5568627450980392, 0.8392156862745098, 0.27058823529411763),vec3(0.5647058823529412, 0.8431372549019608, 0.2627450980392157),vec3(0.5764705882352941, 0.8431372549019608, 0.2549019607843137),vec3(0.5843137254901961, 0.8470588235294118, 0.25098039215686274),vec3(0.596078431372549, 0.8470588235294118, 0.24313725490196078),vec3(0.6078431372549019, 0.8509803921568627, 0.23529411764705882),vec3(0.615686274509804, 0.8509803921568627, 0.23137254901960785),vec3(0.6274509803921569, 0.8549019607843137, 0.2235294117647059),vec3(0.6352941176470588, 0.8549019607843137, 0.21568627450980393),vec3(0.6470588235294118, 0.8588235294117647, 0.21176470588235294),vec3(0.6588235294117647, 0.8588235294117647, 0.20392156862745098),vec3(0.6666666666666666, 0.8627450980392157, 0.19607843137254902),vec3(0.6784313725490196, 0.8627450980392157, 0.18823529411764706),vec3(0.6901960784313725, 0.8666666666666667, 0.1843137254901961),vec3(0.6980392156862745, 0.8666666666666667, 0.17647058823529413),vec3(0.7098039215686275, 0.8705882352941177, 0.16862745098039217),vec3(0.7215686274509804, 0.8705882352941177, 0.1607843137254902),vec3(0.7294117647058823, 0.8705882352941177, 0.1568627450980392),vec3(0.7411764705882353, 0.8745098039215686, 0.14901960784313725),vec3(0.7529411764705882, 0.8745098039215686, 0.1450980392156863),vec3(0.7607843137254902, 0.8745098039215686, 0.13725490196078433),vec3(0.7725490196078432, 0.8784313725490196, 0.12941176470588237),vec3(0.7843137254901961, 0.8784313725490196, 0.12549019607843137),vec3(0.792156862745098, 0.8823529411764706, 0.12156862745098039),vec3(0.803921568627451, 0.8823529411764706, 0.11372549019607843),vec3(0.8156862745098039, 0.8823529411764706, 0.10980392156862745),vec3(0.8235294117647058, 0.8862745098039215, 0.10588235294117647),vec3(0.8352941176470589, 0.8862745098039215, 0.10196078431372549),vec3(0.8470588235294118, 0.8862745098039215, 0.09803921568627451),vec3(0.8549019607843137, 0.8901960784313725, 0.09803921568627451),vec3(0.8666666666666667, 0.8901960784313725, 0.09411764705882353),vec3(0.8745098039215686, 0.8901960784313725, 0.09411764705882353),vec3(0.8862745098039215, 0.8941176470588236, 0.09411764705882353),vec3(0.8980392156862745, 0.8941176470588236, 0.09803921568627451),vec3(0.9058823529411765, 0.8941176470588236, 0.09803921568627451),vec3(0.9176470588235294, 0.8980392156862745, 0.10196078431372549),vec3(0.9254901960784314, 0.8980392156862745, 0.10588235294117647),vec3(0.9372549019607843, 0.8980392156862745, 0.10980392156862745),vec3(0.9450980392156862, 0.8980392156862745, 0.11372549019607843),vec3(0.9568627450980393, 0.9019607843137255, 0.11764705882352941),vec3(0.9647058823529412, 0.9019607843137255, 0.12549019607843137),vec3(0.9725490196078431, 0.9019607843137255, 0.12941176470588237),vec3(0.984313725490196, 0.9058823529411765, 0.13725490196078433),vec3(0.9921568627450981, 0.9058823529411765, 0.1450980392156863)\n);\nvec3 interpolate_colormap( in float val, in vec2 color_range, in vec3[256] colormap ) { \n    float h = ( val - color_range.x ) / (color_range.y - color_range.x);\n    h = min(max(h, 0.), 1.); // clamp to [0, 1]\n    return colormap[int(max(0., min(255., floor(h * 256.))))];\n}\nvec3 rainbow( in float val, in vec2 color_range ) {\n    float h = ( val - color_range.x ) / (color_range.y - color_range.x);\n    h = min(max(h, 0.), 1.); // clamp to [0, 1]\n    return hsv( h, 0.8, 1.0 );\n}\nvec3 redblue( in float val, in vec2 color_range ) {\n    float h = ( val - color_range.x ) / (color_range.y - color_range.x);\n    h = min(max(h, 0.), 1.); // clamp to [0, 1]\n    if ( h < 0.5 ) {\n        return hsv( 0.65, 1. - 2. * h, 1. );\n    } else {\n        return hsv( 0., 2. * h - 1., 1. );\n    }\n}\nvec3 viridis( in float val, in vec2 color_range ) {\n    return interpolate_colormap( val, color_range, viridis_colors );\n}\nvec3 blues( in float val, in vec2 color_range ) {\n    float h = ( val - color_range.x ) / (color_range.y - color_range.x);\n    h = min(max(h, 0.), 1.); // clamp to [0, 1]\n    // blue = hsv(.93, .67, .32);\n    return hsv( .73, h * .67, .32 + (1.-h) * .68 );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// (from https://www.shadertoy.com/view/7tKfz1)\n//-----------------------Keyboard & Mouse Input Handler-----------------------//\n\n// Settings: \nconst float MOUSE_SENSITIVITY = 5.0;  \nconst float MOVEMENT_SPEED = 4.0; // Units per second\n\n// Controls:\nconst float KEY_W = 87.0;     // forwards\nconst float KEY_A = 65.0;     // left\nconst float KEY_S = 83.0;     // backwards\nconst float KEY_D = 68.0;     // right\nconst float KEY_UP = 38.0;    // forwards\nconst float KEY_LEFT = 37.0;  // left\nconst float KEY_DOWN = 40.0;  // backwards\nconst float KEY_RIGHT = 39.0; // right\nconst float KEY_SPACE = 32.0; // up\nconst float KEY_SHIFT = -1.;  // down (disabled)\nconst float KEY_J = 74.0;     // up\nconst float KEY_N = 78.0;     // down\nconst float KEY_K = 75.0;     // decrease orbit radius\nconst float KEY_M = 77.0;     // increase orbit radius\n\n\n\n//============================================================================//\n\n\n\nbool keyPressed(float keyCode) {\n    return texture(iChannel0, vec2((keyCode + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    if (fragCoord == vec2(0.5, 0.5)) {\n        if (iMouse.z > 0.0) {\n            vec2 oldCamRot = texelFetch(iChannel1, ivec2(0, 0), 0).zw;\n            float mouseSens = -MOUSE_SENSITIVITY / iResolution.x;\n            fragColor = vec4(clamp(oldCamRot.x - (iMouse.y - abs(iMouse.w)) * mouseSens, -PI * 0.5, PI * 0.5),\n                                   oldCamRot.y + (iMouse.x - abs(iMouse.z)) * mouseSens,\n                                   oldCamRot);\n        } else {\n            vec2 camRot = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n            fragColor = camRot.xyxy;\n        }\n        \n        if (iFrame == 0 || iMouse.x == 0.0 && iMouse.z == 0.0) {\n            fragColor.x = mix(-0.3, 0.1, 0.5 - 0.5 * cos(iTime * 0.5));\n            fragColor.y = -0.5 + iTime * 0.3;\n        }\n    } else if (fragCoord == vec2(1.5, 0.5)) {\n        fragColor = texelFetch(iChannel1, ivec2(1, 0), 0);\n        float camRotY = texelFetch(iChannel1, ivec2(0, 0), 0).y;\n        float c = cos(camRotY);\n        float s = sin(camRotY);\n        mat3 rotMat = mat3(\n                c,   0.0,  -s,\n                0.0, 1.0,  0.0,\n                s,   0.0,  c\n            ) * MOVEMENT_SPEED * iTimeDelta;\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 forward = vec3(0.0, 0.0, -1.0);\n        \n        if (keyPressed(KEY_W) || keyPressed(KEY_UP)) {\n            fragColor.xyz += rotMat * forward;\n        }\n        if (keyPressed(KEY_S) || keyPressed(KEY_DOWN)) {\n            fragColor.xyz -= rotMat * forward;\n        }\n        \n        if (keyPressed(KEY_D) || keyPressed(KEY_RIGHT)) {\n            fragColor.xyz += rotMat * right;\n        }\n        if (keyPressed(KEY_A) || keyPressed(KEY_LEFT)) {\n            fragColor.xyz -= rotMat * right;\n        }\n        \n        if (keyPressed(KEY_SPACE) || keyPressed(KEY_J)) {\n            fragColor.xyz += rotMat * up;\n        }\n        if (keyPressed(KEY_SHIFT) || keyPressed(KEY_N)) {\n            fragColor.xyz -= rotMat * up;\n        }\n            \n        if (keyPressed(KEY_K)) {\n            fragColor.w   -= MOVEMENT_SPEED * iTimeDelta;\n        }\n        if (keyPressed(KEY_M)) {\n            fragColor.w   += MOVEMENT_SPEED * iTimeDelta;\n        }\n        \n        fragColor.w = iFrame == 0 ? 4.0 : max(fragColor.w, 0.0);\n    } else if (fragCoord == vec2(0.5, 1.5)) {\n        if (keyPressed(KEY_W)     || keyPressed(KEY_A)     || \n            keyPressed(KEY_S)     || keyPressed(KEY_D)     || \n            keyPressed(KEY_UP)    || keyPressed(KEY_LEFT)  || \n            keyPressed(KEY_DOWN)  || keyPressed(KEY_RIGHT) || \n            keyPressed(KEY_SPACE) || keyPressed(KEY_SHIFT) || \n            keyPressed(KEY_J)     || keyPressed(KEY_N)     || \n            keyPressed(KEY_K)     || keyPressed(KEY_M)     || \n            \n            iMouse.z > 0.0) {\n            fragColor.x = 1.0;\n        } else {\n            fragColor.x = texelFetch(iChannel1, ivec2(0, 1), 0).x + 1.0;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}