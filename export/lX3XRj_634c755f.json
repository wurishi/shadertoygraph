{"ver":"0.1","info":{"id":"lX3XRj","date":"1719328794","viewed":45,"name":"Simple 2D Matrix Transform","username":"luckebjucke","description":"An example of how to create a 3X3 Transform matrix that allows for Scale, Rotation and Translation on 2D UV-coordinates.\n\nPress the S-key to toggle scaling\nPress the R-key to toggle rotation\nPress the T-key to toggle translation","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["2d","uv","matrix","rotation","translation","coordinates","scale","transform","3x3matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265359\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Find the all Key codes here: http://gcctech.org/csc/javascript/javascript_keycodes.htm\n    const int S_KEY = 83;\n    const int R_KEY = 82;\n    const int T_KEY = 84;\n    \n    // Boolean for when a specific key is pressed. See https://www.shadertoy.com/view/lsXGzf from inigo quilez\n    float sKey = texelFetch( iChannel1, ivec2(S_KEY,2),0 ).x;\n          sKey = 1.0 - sKey;\n    float rKey = texelFetch( iChannel1, ivec2(R_KEY,2),0 ).x;\n          rKey = 1.0 - rKey;\n    float tKey = texelFetch( iChannel1, ivec2(T_KEY,2),0 ).x;\n          tKey = 1.0 - tKey;\n    \n    // Create occilation time that goes from 0 to 1 to 0\n    float time = (sin(iTime*pi)+1.0)*0.5; //Make the sin curve 0-1 range in both height and width\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Varibles to control Scale, Rotation, Translation and pivot\n    vec2 scale = vec2(1.0+time,1.0+time)*sKey+(1.0-sKey);\n    float angle = time*2.0*pi*rKey;\n    vec2 localPos = vec2(time*tKey,0.0);\n    vec2 pivot = vec2(0.5,0.5);\n    \n    // Subtract (offset) the UV:s by the pivot so the UV center point can be set. \n    uv -= pivot;\n    \n    // find the aspect ratio between X and Y\n    vec2 ratio = iResolution.xy / min(iResolution.x,iResolution.y);\n    \n    // Scale the UV:s so they are 1:1 aspect ratio\n    uv *= ratio.xy;\n    \n    // Add in a third component to the UV:s so translation is possible\n    vec3 uvMat3 = vec3(uv,1.0);\n    \n    // Scale, Rotation, Translation Matrix\n    mat3 Transform;\n         Transform[0] = vec3(cos(angle) * scale.x, -sin(angle) * scale.x, localPos.x);\n         Transform[1] = vec3(sin(angle) * scale.y, cos(angle) * scale.y, localPos.y);\n    \n    // Multiply the Transfrom Matrix with the UV:s\n    uvMat3 *= Transform;\n    \n    // Make the UV:s a vec2 again.\n    uv = uvMat3.xy;\n    \n    // Add back the pivot offset\n    uv += pivot;\n    \n    // remove tiling, make clamp the UV:s to 0 to 1\n    uv = clamp(uv,0.0,1.0);\n    \n    // Creates a mask of the UV space. \n    float mask = min(uv.x,1.0-uv.x)*2.0;\n          mask *= min(uv.y,1.0-uv.y)*2.0;\n          mask = step(mask, 0.0);\n          mask = 1.0-mask;\n    \n    vec4 tex = texture(iChannel0,uv);\n    tex *= mask;\n    \n\n    // Output to screen\n    fragColor = tex;\n    //fragColor = vec4(mask,0.0,0.0,1.0);\n}","name":"Image","description":"","type":"image"}]}