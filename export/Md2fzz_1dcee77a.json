{"ver":"0.1","info":{"id":"Md2fzz","date":"1499420809","viewed":436,"name":"Particle collision test","username":"Ultraviolet","description":"Basic test on particle collision.\nUse the mouse to control gravity.","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["2d","collision","physics","particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat M_PI = 3.1415972;\nfloat nb_particles = 20.0;\nfloat particle_radius = 0.05;\nfloat dt = 0.005;\n\nvec2 g = vec2(0.0,-9.8);\n\nvec2 getUV(float i)\n{\n    return vec2((i)/iResolution.x, 0);\n}\n\nvec2 particlePos(float i)\n{\n    return texture(iChannel0, getUV(i)).xy;\n}\n\nvec2 particleSpeed(float i)\n{\n    return texture(iChannel0, getUV(i)).zw;\n}\n\nfloat particleMass(float i)\n{\n    return 0.1;\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 particleColor(float i)\n{\n    return hsv2rgb(vec3((i-0.5)/nb_particles, 1.0, 1.0));\n}\n\nfloat particleRadius(float i)\n{\n    return particle_radius*(1.0+0.3*cos(i/nb_particles*2.0*M_PI*3.0));\n}\n\nvec4 drawParticleColors(vec2 p, float pixelSize)\n{\n    vec4 col = vec4(0.0);\n    \n    for(float i=0.5; i<nb_particles; ++i)\n    {\n        if(col.w > 0.99)\n            return col;\n            \n        //vec2 d = p-particlePos(i);\n        //float dist = length(d) - particleRadius(i)*(1.0 + pow(dot(d, particleSpeed(i))/length(d)/length(particleSpeed(i)), 2.0)*length(particleSpeed(i))*dt*500.0);\n        float dist = length(p-particlePos(i)) - particleRadius(i);\n        if(dist < 0.0)\n        {\n            vec3 partCol = particleColor(i);\n            float alpha = clamp(-dist / pixelSize*0.5, 0.0, 1.0);\n            \n            col = vec4((1.0-alpha)*col.xyz + alpha*partCol, min(col.w + alpha, 1.0));\n        }\n    }\n    \n    return col;\n}\n\nfloat dist(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 d = p1 - p0;\n    float t = clamp(dot(p - p0, d) / dot(d, d), 0.0, 1.0);\n    vec2 proj = (1.0-t)*p0 + t*p1;\n    return length(proj-p);\n}\n\nfloat angle(vec2 p0, vec2 p1)\n{\n    return mod(atan(p1.y, p1.x) - atan(p0.y, p0.x)+M_PI, 2.0*M_PI)-M_PI;\n}\n\nvec2 gravity()\n{\n    //return g;\n    if(iMouse.z > 0.5)\n    \treturn ((iMouse.xy)/iResolution.y - 0.5*vec2(iResolution.x/iResolution.y, 1.0)) * 20.0;\n    else\n    {\n        return g;\n        return vec2(sign(sin(iTime)), 0.0)*10.0;\n        if(iMouse.x<5.0 && iMouse.y < 5.0)\n        \treturn vec2(0.0, -10.0);\n    }\n}\n\nvec4 drawGravity(vec2 p, float pixelSize)\n{    \n    vec2 g = gravity()/10.0;\n    \n    if(dot(g,g) < 0.01)\n        return vec4(0.0);\n    \n    float theta = atan(g.y, g.x);\n    mat2 m = mat2(cos(theta), sin(theta), -sin(theta), cos(theta)) * length(g);\n    vec2 vert[] = vec2[](vec2(0.0), vec2(-0.25, -0.3)*0.8, vec2(0.65, -0.1), vec2(0.6, -0.3), vec2(1.0, 0.0),\n                         vec2(0.6, 0.3), vec2(0.65, 0.1), vec2(-0.25, 0.3)*0.8, vec2(0.0));\n    float d = 1000.0;\n    float a = 0.0;\n    for(int i=0; i<vert.length()-1; ++i)\n    {\n        a += angle(p-m*vert[i+1], p-m*vert[i]);\n        d = min(d, dist(p, m*vert[i], m*vert[i+1]));\n    }\n    \n    if(a > -0.01)\n        return vec4(0.0);\n    \n    return vec4(vec3(0.5), clamp(d/pixelSize*0.5, 0.0, 1.0));\n}\n\nvec4 drawParticleCount(vec2 p)\n{\n    float c = 0.0;\n    for(float i=0.5; i<nb_particles; ++i)\n    {\n        if(length(p-particlePos(i)) < particle_radius)\n        {\n            c = c + 0.2;\n        }\n    }\n    \n    return vec4(vec3(c), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y * 2.0;\n    \n    vec3 col = vec3(1.0);\n    \n    vec4 part_col;\n    \n    part_col = drawGravity(p, 1.0/iResolution.y);\n    col = col*(1.0 - part_col.w) + part_col.xyz*part_col.w;\n    \n    part_col = drawParticleColors(p, 1.0/iResolution.y);\n    //part_col = drawParticleCount(p);\n    col = col*(1.0 - part_col.w) + part_col.xyz;\n    \n    fragColor = vec4(col, 1.0); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst bool do_gravity = true;\nconst bool do_wall_collision = true;\nconst bool do_wind = true;\n\n\n\n\nfloat M_PI = 3.1415972;\nfloat nb_particles = 20.0;\nfloat dt = 0.005;\nvec2 g = vec2(0.0,-9.8);\nfloat friction = 0.1;\nfloat bouncyness = 0.99;\n\n\nvec2 windSpeed(vec2 pos)\n{\n    return vec2(0.0, 0.0);\n    if(-.5 < pos.x && pos.x < .5)\n    \treturn vec2(0.0,10.0);\n    return vec2(0.0);\n}\n\nfloat particle_radius = 0.05;\n\nvec2 gravity()\n{\n    //return g;\n    if(iMouse.z > 0.5)\n    \treturn ((iMouse.xy)/iResolution.y - 0.5*vec2(iResolution.x/iResolution.y, 1.0)) * 20.0;\n    else\n    {\n        return g;\n        return vec2(sign(sin(iTime)), 0.0)*10.0;\n        if(iMouse.x<5.0 && iMouse.y < 5.0)\n        \treturn vec2(0.0, -10.0);\n    }\n}\n\nvec2 getUV(float i)\n{\n    return vec2((i)/iResolution.x, 0);\n}\n\nvec2 particlePos(float i)\n{\n    return texture(iChannel0, getUV(i)).xy;\n}\n\nvec2 particleSpeed(float i)\n{\n    return texture(iChannel0, getUV(i)).zw;\n}\n\nfloat particleRadius(float i)\n{\n    return particle_radius*(1.0+0.3*cos(i/nb_particles*2.0*M_PI*3.0));\n}\n\nfloat particleMass(float i)\n{\n    //return 0.1;\n    return 50.0 * pow(particleRadius(i), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = fragCoord.x;\n    \n    if(i > nb_particles)\n    {\n    // no particle is represented in this pixel\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec2 cur_pos, cur_speed;\n    \n    // Init\n    if(iFrame == 0)\n    {\n    \tfloat t = (i-0.5)/nb_particles * M_PI * 2.0;\n        cur_pos = vec2(cos(t), sin(t))*0.5;\n        cur_speed = vec2(0.0);\n        fragColor = vec4(cur_pos, cur_speed);\n        return;\n    }\n    \n    // Retrieving data\n    vec2 prev_pos = particlePos(fragCoord.x);\n    vec2 prev_speed = particleSpeed(fragCoord.x);\n    \n    // Compute force\n    vec2 cur_force = vec2(0.0);\n    if(do_gravity)\n        cur_force += gravity()*particleMass(i);\n    \n    if(do_wind)\n        cur_force += -(prev_speed-windSpeed(prev_pos))*friction;\n    \n    // Forward integration\n        \n    cur_pos = prev_pos + dt*prev_speed;\n    cur_speed = prev_speed + dt*(cur_force)/particleMass(i);\n    \n    /// Walls collisions\n    if(do_wall_collision)\n    {\n        float dist_to_wall;\n        float ratio = iResolution.x/iResolution.y;\n\n        dist_to_wall = cur_pos.y-particleRadius(i)+1.0;\n        if(dist_to_wall < 0.0)\n        {\n            cur_speed.y *= -bouncyness;\n            cur_pos.y = -1.0-2.0*dist_to_wall + particleRadius(i);\n        }\n\n        dist_to_wall = 1.0-cur_pos.y-particleRadius(i);\n        if(dist_to_wall < 0.0)\n        {\n            cur_speed.y *= -bouncyness;\n            cur_pos.y = 1.0+2.0*dist_to_wall - particleRadius(i);\n        }\n\n        dist_to_wall = cur_pos.x-particleRadius(i)+ratio;\n        if(dist_to_wall < 0.0)\n        {\n            cur_speed.x *= -bouncyness;\n            cur_pos.x = -ratio-2.0*dist_to_wall + particleRadius(i);\n        }\n\n        dist_to_wall = ratio -cur_pos.x-particleRadius(i);\n        if(dist_to_wall < 0.0)\n        {\n            cur_speed.x *= -bouncyness;\n            cur_pos.x = ratio+2.0*dist_to_wall - particleRadius(i);\n        }\n    }\n    \n    fragColor = vec4(cur_pos, cur_speed);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nconst bool do_particle_collision = true;\nconst bool do_wall_collision = true;\n\n\nfloat M_PI = 3.1415972;\nfloat nb_particles = 20.0;\nfloat dt = 0.005;\nvec2 g = vec2(0.0, 9.8);\nfloat friction = 0.1;\nfloat bouncyness = 0.99;\n\nfloat particle_radius = 0.05;\n\n\nvec2 getUV(float i)\n{\n    return vec2((i)/iResolution.x, 0);\n}\n\nvec2 particlePos(float i)\n{\n    return texture(iChannel0, getUV(i)).xy;\n}\n\nvec2 particleSpeed(float i)\n{\n    return texture(iChannel0, getUV(i)).zw;\n}\n\nfloat particleRadius(float i)\n{\n    return particle_radius*(1.0+0.3*cos(i/nb_particles*2.0*M_PI*3.0));\n}\n\nfloat particleMass(float i)\n{\n    //return 0.1;\n    return 50.0 * pow(particleRadius(i), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = fragCoord.x;\n    \n    if(i > nb_particles)\n    {\n    // no particle is represented in this pixel\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec2 cur_pos = particlePos(i);\n    vec2 cur_speed = particleSpeed(i);\n    \n    if(!do_particle_collision)\n    {\n    \tfragColor = vec4(cur_pos, cur_speed);\n        return;\n    }\n    \n    /// Inter-particle collisions\n    \n    for(float j=0.5; j<nb_particles; ++j)\n    {\n        if(abs(i-j) < 0.001)\n            continue;\n        \n\t\tvec2 d = particlePos(j)-particlePos(i);\n        if(length(d) < particleRadius(j)+particleRadius(i))\n        {\n            d = normalize(d);\n            \n            // Looking for the time of collision\n            vec2 xi = particlePos(i);\n            vec2 xj = particlePos(j);\n            \n            float xi_2  = dot(xi, xi);\n            float xj_2  = dot(xj, xj);\n            float xi_xj = dot(xj, xi);\n            \n            float vi_2  = dot(particleSpeed(i), particleSpeed(i));\n            float vj_2  = dot(particleSpeed(j), particleSpeed(j));\n            float vi_vj = dot(particleSpeed(i), particleSpeed(j));\n            \n            float vi_xi = dot(particleSpeed(i), xi);\n            float vi_xj = dot(particleSpeed(i), xj);\n            float vj_xi = dot(particleSpeed(j), xi);\n            float vj_xj = dot(particleSpeed(j), xj);\n            \n            float r_2 = (particleRadius(j)+particleRadius(i))*(particleRadius(j)+particleRadius(i));\n            \n            float a = vi_2 + vj_2 -2.0*vi_vj;\n            float b = vi_xi + vj_xj - vi_xj - vj_xi;\n            float c = xi_2 + xj_2 - r_2 - 2.0*xi_xj;\n            \n            float delta = b*b-a*c;\n            float t = (-b-sqrt(delta))/a;\n            \n            // setting position back to when collision happened (t < 0)\n            xi = xi + particleSpeed(i)*t;\n            \n            // updating speed\n            // (see: en.wikipedia.org/wiki/Elastic_collision#Two-dimensional_collision_with_two_moving_objects)\n            cur_speed -= (1.0+bouncyness)*particleMass(j)/(particleMass(i)+particleMass(j)) * dot(particleSpeed(i)-particleSpeed(j), d)*d;\n            \n            // moving particle from impact point with updated speed\n            cur_pos = xi + cur_speed*(-t);\n        }\n    }\n    \n    /// Walls collisions\n    \n    if(do_wall_collision)\n    {\n        float dist_to_wall;\n        float ratio = iResolution.x/iResolution.y;\n\n        dist_to_wall = cur_pos.y-particleRadius(i)+1.0;\n        if(dist_to_wall < 0.0)\n        {\n            cur_speed.y *= -bouncyness;\n            cur_pos.y = -1.0-2.0*dist_to_wall + particleRadius(i);\n        }\n\n        dist_to_wall = 1.0-cur_pos.y-particleRadius(i);\n        if(dist_to_wall < 0.0)\n        {\n            cur_speed.y *= -bouncyness;\n            cur_pos.y = 1.0+2.0*dist_to_wall - particleRadius(i);\n        }\n\n        dist_to_wall = cur_pos.x-particleRadius(i)+ratio;\n        if(dist_to_wall < 0.0)\n        {\n            cur_speed.x *= -bouncyness;\n            cur_pos.x = -ratio-2.0*dist_to_wall + particleRadius(i);\n        }\n\n        dist_to_wall = ratio -cur_pos.x-particleRadius(i);\n        if(dist_to_wall < 0.0)\n        {\n            cur_speed.x *= -bouncyness;\n            cur_pos.x = ratio+2.0*dist_to_wall - particleRadius(i);\n        }\n    }\n    \n    fragColor = vec4(cur_pos, cur_speed);\n}","name":"Buffer B","description":"","type":"buffer"}]}