{"ver":"0.1","info":{"id":"3dV3Wm","date":"1570323065","viewed":214,"name":"ShaderTober - Build","username":"Flopine","description":"A small doodle with inktober's theme \"Build\"","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.45,24.5)))*1245.4);}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat g1 = 0.;\nfloat od (vec3 p, float d)\n{\n    float dist = dot(p,normalize(sign(p)))-d;\n    g1 += 0.1/(0.1+dist*dist);\n    return dist;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat pillars (vec3 p)\n{\n    float plane = dot(p,vec3(0.5,1.,-0.2));\n    float per = 3.;\n    p.x = abs(p.x)-2.5;\n    p.x = abs(p.x)-.5;\n    p.z = mod(p.z,per)-per*0.5;\n\n    return max(plane+texNoise(p.xz*0.15+iTime*0.3).r,cyl(p.xzy, 0.3,1e10));\n}\n\nfloat gem (vec3 p)\n{\n    p.xz *= rot(iTime*0.5);\n    p.y += sin(iTime)*0.2+0.1;\n    return od(p,.8);\n}\n\nfloat SDF (vec3 p)\n{\n    return stmin(pillars(p),stmin(-box(p,vec3(8.,3,8.)),gem(p),1.2,5.),0.3,4.);\n}  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.001,-2.,-5.),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<100.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/100.;\n            break;\n        }   \n        d *= 0.9+dither*0.1;    \n        p+=d*rd;\n    }\n\n    float t = length(ro-p);\n\n    col = vec3(abs(p.z*0.05));\n    col *= 1.-shad*2.;\n    col += g1*0.5;\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}