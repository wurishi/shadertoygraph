{"ver":"0.1","info":{"id":"Xtc3z2","date":"1470189579","viewed":385,"name":"Ocean floor (+sound)","username":"LukeRissacher","description":"Learning raymarching... ","likes":10,"published":1,"flags":8,"usePreview":0,"tags":["procedural","raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DEPTH = 10.0;\n\nvec2 Rotate(vec2 pos, float angle) {\n\treturn vec2(\n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.x * sin(angle) + pos.y * cos(angle)\n    );\n}\n\nfloat Cubic(float a, float b, float t) {\n    float blendFactor = t * t * (3.0 - 2.0 * t);\n    return mix(a, b, blendFactor);\n}\n\nfloat Rand(vec2 pos) {\n    return fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat SmoothRand(vec2 pos, vec2 stepSize) {\n    pos /= stepSize;\n    vec2 floored = floor(pos);\n    vec2 partial = fract(pos);\n    float top = Cubic(Rand(floored + vec2(0.0, 1.0)), Rand(floored + vec2(1.0, 1.0)), partial.x);\n    float bottom = Cubic(Rand(floored + vec2(0.0, 0.0)), Rand(floored + vec2(1.0, 0.0)), partial.x);\n    return Cubic(bottom, top, partial.y);\n}\n\nfloat OctaveNoise(vec2 pos, vec2 stepSize) {\n    float sum = 0.0;\n    float multiplier = 1.0;\n    float scale = 0.0;\n    for (int i = 0; i < 6; i++) {\n        sum += SmoothRand(pos, stepSize) * multiplier;\n        scale += multiplier;\n        multiplier *= 0.5;\n        stepSize *= 0.5;\n        pos = Rotate(pos, radians(60.0));\n    }\n    return sum / scale;\n}\n\nfloat SceneDistance(vec3 pos) {\n    vec3 planePos = vec3(0.0, -0.5, 0.0);\n    vec3 planeScale = vec3(0.0, 1.8 * OctaveNoise(pos.xz + vec2(0.0, iTime), vec2(1.7)), 0.0);\n    vec3 planeLocalPos = (pos - planePos);\n    planeLocalPos.yz = Rotate(planeLocalPos.yz, radians(20.0));\n    return (planeLocalPos + planeScale).y;\n}\n\nfloat RayMarch(vec3 startPos, vec3 dir) {\n\tfloat depth = 0.0;\n    for (int i = 0; i < 255; i++) {\n        vec3 pos = startPos + dir * depth;\n        float dist = SceneDistance(pos);\n        if (dist < 0.0001) {\n        \treturn depth;\n        }\n        depth += 0.7 * dist;\n        if (depth >= MAX_DEPTH) {\n            return MAX_DEPTH;\n        }\n    }\n    return MAX_DEPTH;\n}\n\nvec3 SceneNormal(vec3 pos) {\n\tconst float DX = 0.01;\n\tconst vec3 dx = vec3(DX, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, DX, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, DX);\n    return normalize(vec3(\n        SceneDistance(pos + dx) - SceneDistance(pos - dx),\n        SceneDistance(pos + dy) - SceneDistance(pos - dy),\n        SceneDistance(pos + dz) - SceneDistance(pos - dz)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tconst float FOV = radians(45.0);\n    vec3 eyePos = vec3(0.0, 0.0, -4.0);\n    \n    vec2 xy = (2.0 * fragCoord - iResolution.xy) * 0.5;\n    vec3 rayDir = normalize(vec3(xy, 1.0 / tan(0.5 * FOV) * 0.5 * iResolution.y));\n    vec3 lightDir = normalize(vec3(0.5, 0.8, -1.0));\n    \n    float depth = RayMarch(eyePos, rayDir);\n    if (depth < MAX_DEPTH) {\n        vec3 pos = eyePos + rayDir * depth;\n        vec3 normal = SceneNormal(pos);\n        float diffuse = clamp(dot(lightDir, normal), 0.0, 1.0);\n    \tfragColor = vec4(vec3(diffuse), 1.0) * (1.0 - depth / MAX_DEPTH);\n    }\n    else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"float Cubic(float a, float b, float t) {\n    float blendFactor = t * t * (3.0 - 2.0 * t);\n    return mix(a, b, blendFactor);\n}\n\nfloat Rand(float pos) {\n    return fract(sin(dot(vec2(pos), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat SmoothRand1d(float pos, float stepSize) {\n    pos /= stepSize;\n    float floored = floor(pos);\n    float partial = fract(pos);\n    return Cubic(Rand(floored), Rand(floored + 1.0), partial);\n}\n\nfloat Sine(float t) {\n    return sin(6.283 * t);\n}\n\nfloat GetWaterSample(float time, float randomizeHz, float baseFreq, float freqDelta) {\n    float noteTime = randomizeHz * time;\n    float freq = baseFreq + freqDelta * Rand(floor(noteTime));\n    float noteRamp = fract(noteTime);\n    float amplitude = (1.0 - noteRamp); // repeating decay\n    amplitude *= clamp(5.0 * noteRamp, 0.0, 1.0); // attack declick\n    amplitude *= Rand(floor(noteTime + 10.0)); // randomize amplitude\n    return Sine(freq * time) * amplitude;\n}\n\nvec2 mainSound( in int samp,float time) {\n    float deepBubbles = GetWaterSample(time, 16.0, 90.0, 60.0) * 0.4;\n    float littleBubbles = GetWaterSample(time, 26.0, 290.0, 100.0) * \n        (0.18 + 0.12 * sin(0.2 * time));\n    float rumble = SmoothRand1d(time, 0.002 + 0.00005 * sin(0.1 * time));\n    float ping = Sine(1000.0 * time) * pow(1.0 - fract(0.13 * (time + 2.0)), 17.0) * \n        SmoothRand1d(time, 0.005);\n    return vec2(\n        deepBubbles + littleBubbles + 0.5 * rumble + 0.5 * ping, \n        deepBubbles + 0.5 * littleBubbles + rumble - 0.3 * ping\n    \t) * 0.7;\n}","name":"Sound","description":"","type":"sound"}]}