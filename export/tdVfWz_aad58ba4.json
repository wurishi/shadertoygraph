{"ver":"0.1","info":{"id":"tdVfWz","date":"1606952621","viewed":130,"name":"European 4 in 1 chainmail weave","username":"athibaul","description":"A [url=https://www.mailleartisans.org/weaves/weavedisplay.php?key=6]very common chainmail weave[/url].","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","chainmail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define AA 1.\n\n#define R(th) mat2(cos(th),sin(th),-sin(th),cos(th))\n\nfloat dTorus(vec3 p, float r_large, float r_small)\n{\n    float h = length(p.xy) - r_large;\n    float d = sqrt(h*h + p.z*p.z) - r_small;\n    return d;\n}\n\nfloat torusGrid(vec3 p, float r_small, float r_large, float angle, vec2 sep)\n{\n    vec3 q = p - vec3(round(p.xy/sep)*sep,0) - vec3(0,sep.y/2.,0);\n    q.yz *= R(angle);\n    float d = dTorus(q, r_large, r_small);\n    q = p - vec3(round(p.xy/sep)*sep,0) - vec3(0,-sep.y/2.,0);\n    q.yz *= R(angle);\n    d = min(d, dTorus(q, r_large, r_small));\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    // Warp space\n    p.x += 0.5*cos(0.2*p.y);\n    p.y += 0.3*cos(0.3*p.x);\n    p.z += 0.3*sin(0.3*p.y+0.2*p.x);\n    \n    // Weave\n    float angle = 0.3;\n    vec2 sep = vec2(1,0.8);\n    float d = torusGrid(p, 0.07, 0.4, angle, sep);\n    d = min(d, torusGrid(p-vec3(sep/2.,0), 0.07, 0.4, -angle, sep));\n    \n    // Plane below\n    vec3 p2 = 12.3*p;\n    p2.yz *= R(0.7);\n    p2.xz *= R(-0.7);\n    vec2 q = p2.xy-round(p2.xy);\n    float bump = dot(q,q) * 0.005;\n    d = min(d, p.z+0.15+bump);\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = 0.001 * vec2(1,-1);\n    return normalize(\n        e.xxx*map(p+e.xxx)\n       +e.xyy*map(p+e.xyy)\n       +e.yxy*map(p+e.yxy)\n       +e.yyx*map(p+e.yyx));\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n    float d, t=0.;\n    for(int i=0;i<256;i++)\n    {\n        d = map(ro+t*rd);\n        if(d<0.001 || t>100.) break;\n        t += d;\n    }\n    return t;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occl = 0.;\n    for(float t=0.02; t<5.; t*=2.)\n    {\n        float d = map(p+n*t);\n        occl = max(occl, 1.-d/t);\n        if(occl > 0.99) break;\n    }\n    return max(1.-occl,0.) * (0.5+0.5*n.z);\n}\n\nvec3 shade(vec3 ro, vec3 rd)\n{\n    float t = raymarch(ro, rd);\n    if(t < 100.)\n    {\n        vec3 p = ro+t*rd;\n        vec3 n = normal(p);\n        /*\n        vec3 surfCol = 0.5+0.5*sin(5.*p);\n        vec3 dif = surfCol * (0.5+0.5*n.z);\n        return dif;\n\t\t*/\n        vec3 rrd = reflect(rd, n);\n        vec3 refl = 0.5+0.5*rrd;\n        float lod = max(log2(t), 0.);\n        vec3 reflCol = pow(textureLod(iChannel0, rrd.xzy, lod).rgb, vec3(2.2))*1.2;\n        vec3 fre0 = vec3(0.8);\n        vec3 fre = fre0 + (1.-fre0) * pow(clamp(1.+dot(rd,n),0.,1.),5.);\n        float ao = calcAO(p,n);\n        vec3 col = reflCol * ao * fre;\n        \n        float fog = 1.-exp(-0.002*t);\n        vec3 fogColor = vec3(0.7,0.8,0.9);\n        col = mix(col, fogColor, fog);\n        \n        return col;\n    }\n    else\n    {\n        return textureLod(iChannel0, rd.xzy, 0.).rgb;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float th = iTime*0.1+0.3+0.05*cos(0.5*iTime);\n    vec3 center = vec3(iTime*0.3,0,0);\n    vec3 ro = center + vec3(4.*cos(th),4.*sin(th),2.5+0.5*cos(0.2*iTime)+0.1*cos(iTime));\n    vec3 camFwd = normalize(vec3(0,1,1)*sin(iTime*0.3)+ center -ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    \n    vec3 col = vec3(0);\n    for(float i=0.;i<AA;i++)\n    {\n        for(float j=0.; j<AA; j++)\n        {\n            vec2 uv = ((fragCoord+vec2(i,j)/AA)*2.-iResolution.xy)/iResolution.y;\n            vec3 rd = normalize(camFwd + 0.5*(camRight*uv.x + camUp*uv.y));\n            col += shade(ro,rd);\n        }\n    }\n    col /= AA*AA;\n   \n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}