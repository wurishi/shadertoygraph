{"ver":"0.1","info":{"id":"Mdy3Dz","date":"1454001048","viewed":522,"name":"Motion Detection (anastadunbar)","username":"anastadunbar","description":"From previous shader https://www.shadertoy.com/view/4syGDR#","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["2d","test","detection","motion","point","backbuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(texture(iChannel0,uv).rgb,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define backbuffer(uv) (texture(iChannel0,uv).rgb)\n#define webcam(uv) (texture(iChannel1,uv).rgb)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float xdiv = 2.;\n    float ydiv= 1.;\n   \n    vec2 uv2 = vec2(uv.x-(1./xdiv),uv.y); //Take the picture from one step left\n    if (uv.x < (1./xdiv)) { //At left\n        uv2 = vec2(uv.x+((xdiv-1.)/xdiv),uv.y-(1./ydiv)); //Take the right to left and one step up\n    }\n    vec3 outc = (uv.x < (1./xdiv) && uv.y < (1./ydiv)) ? webcam(fract(uv*vec2(xdiv,ydiv))) : backbuffer(uv2);\n   \n    fragColor = vec4(outc,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Motion detection\n#define grayscale(x) ((x.r+x.g+x.b)/3.)\n#define difference(a,b) clamp(a-b,0.,1.)+clamp(b-a,0.,1.)\n#define clamps(x) clamp(x,0.,1.)\nfloat get_motion(vec2 uv) {\n    vec3 frame1 = texture(iChannel0,uv/vec2(2.,1.)).rgb;\n    vec3 frame2 = texture(iChannel0,(uv/vec2(2.,1.))+vec2(1./2.,0.)).rgb;\n    float motion = step(0.05,difference(grayscale(frame1),grayscale(frame2)));\n    return motion;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    const int loops = 20; //Accuracy, loops ^ 2\n    bool point_found = false;\n    vec2 point = vec2(0.);\n    float count = 1.;\n    for (int y = 0; y < loops; y++) {\n        for (int x = 0; x < loops; x++) {\n            if (get_motion(vec2(x,y)/float(loops)) == 1.) { \n                if (point_found == true) { //Already?\n                    point += (vec2(x,y)/float(loops));\n                    count++;\n                } else { //New\n                \tpoint = vec2(x,y)/float(loops);\n                }\n                point_found = true; \n            }\n    \t}\n    }\n    point /= count;\n    vec3 color = vec3(get_motion(uv))+(float(point_found)*clamps(vec3(1.,0.,0.)*(1.-((length(uv-point)-.04)*200.))));\n\tfragColor = vec4(color,1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}