{"ver":"0.1","info":{"id":"csjyDw","date":"1687781830","viewed":106,"name":"vanishing points from projection","username":"jt","description":"A simple demo how to calculate vanishing points given transform and projection.\nThe vanishing points are the column-vectors of the (inverse) transform matrix, projected (i.e. v.xy / v.z).\nReverse [url=https://www.shadertoy.com/view/mdByRG]here[/url].","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["projection","geometry","matrix","perspective","points","point","projective","vanishing"],"hasliked":0,"parentid":"DdSyDD","parentname":"playing around with projection"},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/csjyDw\n// vanishing points from projection - 2023 by Jakob Thomsen\n// A simple demo how to calculate vanishing points given transform and projection.\n\n// tags: projection, geometry, matrix, perspective, points, point, projective, vanishing\n\nfloat DrawLine(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n\nfloat DrawX(vec2 A, vec2 B, vec2 C, vec2 D, vec2 p)\n{\n    return min(DrawLine(A, C, p), DrawLine(B, D, p));\n}\n\nfloat SpotX(float Size, vec2 A, vec2 p)\n{\n    vec2 a = vec2( Size, Size);\n    vec2 b = vec2(-Size, Size);\n    return DrawX(A-a, A-b, A+a, A+b, p);\n}\n\n#define pi 3.1415926\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\nvec2 project(vec3 v)\n{\n    return vec2(v) / v.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord/iResolution.xy - 1.0;\n\n    // Rotate coordinate-system.\n    mat3 m = yaw_pitch_roll(iTime * 0.1 * pi, cos(iTime * 0.1 * pi) * 0.5 * pi, 0.0);\n\n    float o = 1.0;\n    // The vanishing points are the column-vectors of the (inverse) transform matrix, projected (i.e. v.xy / v.z).\n    vec2 vpx = project(inverse(m)[0]);\n    vec2 vpy = project(inverse(m)[1]);\n    vec2 vpz = project(inverse(m)[2]); // NOTE: here origin of plane, also would act as vanishing point for orthogonal planes\n    o = min(o, SpotX(0.025, vpx, p));\n    o = min(o, SpotX(0.025, vpy, p));\n    o = min(o, SpotX(0.025, vpz, p));\n\n    vec3 col = vec3(0.0);\n    if(true) // show coordinate-system?\n    {\n        col = max(col, mix(vec3(1,0,0), vec3(0.0), smoothstep(0.00, 0.01, DrawLine(vec2(0)/*-vpx*/,+vpx, p))));\n        col = max(col, mix(vec3(0,1,0), vec3(0.0), smoothstep(0.00, 0.01, DrawLine(vec2(0)/*-vpy*/,+vpy, p))));\n        col = max(col, mix(vec3(0,0,1), vec3(0.0), smoothstep(0.00, 0.01, DrawLine(vec2(0)/*-vpz*/,+vpz, p))));\n    }\n    col = max(col, mix(vec3(1,1,1), vec3(0.0), smoothstep(0.00, 0.01, o)));\n    p = project(m * vec3(p,1));\n\n    //fragColor = vec4(vec3(fract(p), 0.0), 1.0);\n    fragColor = texture(iChannel0, p); // NOTE: set texture to mipmap, repeat\n    \n    //fragColor = max(fragColor, vec4(col, 1));\n    fragColor = mix(fragColor, vec4(col, 1), max(max(col.x,col.y),col.z));\n}\n","name":"Image","description":"","type":"image"}]}