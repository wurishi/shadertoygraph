{"ver":"0.1","info":{"id":"mt2GWD","date":"1673346629","viewed":103,"name":"Spiral tessellation of sphere","username":"munrocket","description":"Alternative for fibonacci, each square tile preserves area.\nYou can use it for modelling disco ball or Igloo.\nMade for #genuary2023 Day12","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spiral","sphere","tesselation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License Â© 2023 Munrocket\n\n#define iTime (PI*(iTime+1.1))\n#define PI   3.1415926\n#define TWO_PI 6.2831853\n#define PI_2 1.5707963\n\n// Spiral tessellation of sphere.\n// Described by Marco Abrate and Fabrizio Pollastri\n\n////////////////////////////////////////////////////////////////////////////\n// Paper: https://www.iaeng.org/IJAM/issues_v42/issue_3/IJAM_42_3_01.pdf\n////////////////////////////////////////////////////////////////////////////\n\nvec2 sdSpiralSphere(vec3 p, float N) {\n    float turns = PI / sqrt(4. * PI / N);\n    \n    float dt = PI_2 / turns;\n    float r = length(p);\n\tfloat phi = acos(p.y / r) - PI_2;\n    float theta = sign(p.z) * acos(p.x / length(p.xz));\n    \n    float t = theta / 2. / turns + PI / turns *\n      floor((turns * (2. * phi+PI) - theta) / TWO_PI) - PI_2;\n    float id = 1. + floor((N - 2.) * (cos(PI_2 / turns) -\n\t  cos(t + (turns + 1.) * PI_2 / turns)) / (2. * cos(PI_2 / turns)));\n    float ti = acos(cos(PI / 2. / turns ) * (1. - 2. * (id - .5) / (N - 2.)))\n     - (turns + 1.) * PI_2 / turns;\n     \n    float costdt = cos(ti + dt);\n    vec3 pn = vec3(\n      costdt * cos(turns * (PI + 2. * ti)),\n      -sin(ti + dt),\n      costdt * sin(turns * (PI + 2. * ti)));\n    float d = distance(p, pn);\n    return vec2(id, d);\n}\n\n// It seems that it can be improved for 7 points\nvec2 sphereTessellation3(vec3 p, float N) {\n    float turns = PI / sqrt(4. * PI / N);\n    \n    float dt = PI_2 / turns;\n    float r = length(p);\n\tfloat phi = acos(p.y / r);\n    float theta = sign(p.z) * acos(p.x / length(p.xz));\n    \n    float t = theta / 2. / turns + PI / turns *\n      floor((turns * 2. * phi - theta) / TWO_PI) - PI_2;\n    float id = 1. + floor((N - 2.) * (cos(PI_2 / turns) -\n\t  cos(t + (turns + 1.) * PI_2 / turns)) / (2. * cos(PI_2 / turns)));\n    float ti = acos(cos(PI / 2. / turns ) * (1. - 2. * (id - .5) / (N - 2.)))\n     - (turns + 1.) * PI_2 / turns;\n    \n    float costdt = cos(ti + dt);\n    vec3 pn = vec3(\n      costdt * cos(turns * (PI + 2. * ti)),\n      -sin(ti + dt),\n      costdt * sin(turns * (PI + 2. * ti)));\n    float d = distance(p, pn);\n    \n    //second point\n    phi = phi + dt;\n    t = theta / 2. / turns + PI / turns *\n      floor((turns * 2. * phi - theta) / TWO_PI) - PI_2;\n    float id2 = 1. + floor((N - 2.) * (cos(PI_2 / turns) -\n\t  cos(t + (turns + 1.) * PI_2 / turns)) / (2. * cos(PI_2 / turns)));\n    ti = acos(cos(PI / 2. / turns ) * (1. - 2. * (id2 - .5) / (N - 2.)))\n     - (turns + 1.) * PI_2 / turns;\n    costdt = cos(ti + dt);\n    pn = vec3(\n      costdt * cos(turns * (PI + 2. * ti)),\n      -sin(ti + dt),\n      costdt * sin(turns * (PI + 2. * ti)));\n    float d2 = distance(p, pn);\n    id = (d2 < d) ? id2 : id;\n    d = min(d, d2);\n    \n    //third point\n    phi = phi - 2.*dt;\n    t = theta / 2. / turns + PI / turns *\n      floor((turns * 2. * phi - theta) / TWO_PI) - PI_2;\n    id2 = 1. + floor((N - 2.) * (cos(PI_2 / turns) -\n\t  cos(t + (turns + 1.) * PI_2 / turns)) / (2. * cos(PI_2 / turns)));\n    ti = acos(cos(PI / 2. / turns ) * (1. - 2. * (id2 - .5) / (N - 2.)))\n     - (turns + 1.) * PI_2 / turns;\n    costdt = cos(ti + dt);\n    pn = vec3(\n      costdt * cos(turns * (PI + 2. * ti)),\n      -sin(ti + dt),\n      costdt * sin(turns * (PI + 2. * ti)));\n    d2 = distance(p, pn);\n    id = (d2 < d) ? id2 : id;\n    d = min(d, d2);\n    \n    //float d = acos(sin(phi)*sin(phi2)+cos(phi)*cos(phi2)*cos(theta-theta2));\n    return vec2(id, d);\n}\n\n\n//=================================================================================================\n// sphere rendering by iq\n//=================================================================================================\n\nfloat hash1( float n ) { return fract(sin(n)*158.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n    //vec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n\tvec3 ro = vec3( 2.25*sin(an), 1.5 + sin(an), 2.5*cos(an));\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n    \n    vec3 col = vec3(1.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0/(l*l); \n        col = vec3(1.0);\n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n        \n        vec2 fi = (sin(.5 * iTime) > 0.) ?   \n                sdSpiralSphere(nor.xyz, 150.) :\n                sdSpiralSphere(nor.xyz, 150.);\n        col = 0.5 + 0.5*sin( hash1(fi.x*13.0)*3.0 + 1.0 + vec3(0.0,1.0,1.0));\n        col *= smoothstep(0.02, 0.025, fi.y);\n        col *= mix( 1.0, 1.0 - smoothstep(0.12, 0.125, fi.y), smoothstep(-0.1,0.1,sin(iTime)) );\n        col *= 1.0 + 0.1*sin(250.0*fi.y);\n        col *= 1.5;\n\t}\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t\tcol *= occ;\n\t\tcol = mix( col, vec3(1.0), 1.0-exp( -0.01*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}