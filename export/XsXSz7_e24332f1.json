{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// hash based 3d value noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nconst float KAPPA = 0.08;  // extinction coefficient\n\nvec3 sun_direction()\n{\n\tfloat freq = 1.0;\n\tfloat phase = 2.0 + freq*iTime;\n\treturn normalize(vec3(cos(phase), 0.1, sin(phase)));\n}\n\n// returns clouds extinction coeff. as a function of world position\nfloat clouds_extinction( in vec3 p )\n{\t\n\tfloat spatial_period = 32.0;\n\tp /= spatial_period;\n\t\n\tfloat timefreq = 0.5;\n\tvec3 q = p - vec3(1.0,0.1,0.0)*timefreq*iTime;\n\t\n\tfloat cloud_height = 2.5;\n\tfloat layer_y = -1.3*cloud_height;\n\n\tfloat N;\n\tfloat g = 1.0;\n\tfloat beta = 0.4;\n    N  = g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q );\n\t\n\tfloat s = 0.16; // edge smoothness (0=hard, 1=smooth)\n\t\n\tfloat cloudtop_y = layer_y + cloud_height*pow(abs(N), 0.7);\n\treturn KAPPA * (smoothstep(p.y-s*cloud_height, p.y+s*cloud_height, cloudtop_y));\n}\n\n\n// return sun+sky radiance\nvec3 sky_color( in vec3 rd )\n{\n\tvec3 skyColor = vec3(0.6,0.71,0.78) - rd.y*0.25*vec3(1.0,0.5,1.0);\n\tfloat sp = dot(sun_direction(), rd) - cos(radians(5.0));\n\tvec3 sun = 2.0e6 * vec3(1.0,0.9,0.7) * pow(sp * step(0.0, sp), 2.3);\n\tskyColor += sun;\n\treturn skyColor;\n}\n\n\n// return radiance reaching the point pos from the sun\nvec3 reduced_sun( in vec3 pos )\n{\n\tconst int num_steps = 2;\n\tconst float max_dist = 10.0;\n\tfloat dl = max_dist/float(num_steps);\n\tfloat Transmittance = 1.0;\n\tfor(int i=0; i<num_steps; i++)\n\t{\n\t\tif(Transmittance < 0.001) break;\n\t\tpos += dl*sun_direction();\n\t\tfloat kappa = clouds_extinction( pos );\n\t\tTransmittance *= exp(-kappa*dl);\n\t}\n\treturn Transmittance * sky_color(sun_direction());\n}\n\n\n// Henyey-Greenstein phase function\nfloat phasefunction(in vec3 a, in vec3 b)\n{\n\tfloat mu = dot(a, b);\n\tfloat g = 0.25;\n\tfloat gSqr = g*g;\n\tfloat oofp = 1.0/(4.0*3.141592);\n\treturn oofp * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\t\n}\n\n\n// raymarch to complete volume rendering integral\nvec3 primary( in vec3 ro, in vec3 rd )\n{\n\tconst float max_dist = 250.0;\n\tconst int num_steps = 64;\n\tfloat dl = max_dist/float(num_steps);\n\t\n\tvec3 pos = ro;\n\tfloat Transmittance = 1.0;\n\t\n\t// Calculate volume rendering integral along primary ray\n\tvec3 InScattered = vec3(0.0);\n\tfor(int i=0; i<num_steps; i++)\n\t{\n\t\tif(Transmittance < 0.01) break;\n\t\tpos += dl*rd;\n\t\tfloat kappa = clouds_extinction( pos );\n\t\tTransmittance *= exp(-kappa*dl);\n\t\t\n\t\t// single scattering given by in-scatter of sunlight\n\t\tconst vec3 albedo = vec3(0.85, 0.82, 0.79);\n\t\tvec3 single_scatt = albedo * kappa * dl * reduced_sun(pos) * phasefunction(sun_direction(), rd);\n\t\t\n\t\t// Fake multiple scattering by a constant emission field (power is an ad-hoc aesthetic tune-\n\t\t// though the power 1.0 possibly has some physical basis, since the diffuse light can be expected\n\t\t// to be roughly proportional to the density of scatterers\n\t\tvec3 fake_multiple_scatt = albedo * kappa * dl * pow(kappa/KAPPA, 1.0) * 2.5 * vec3(0.33, 0.35, 0.34);\n\t\t\n\t\t// Accumulate integrand\n\t\tInScattered += Transmittance * (single_scatt + fake_multiple_scatt);\n\t}\n\n\tvec3 AttenuatedBackground = Transmittance*sky_color(rd);\n\treturn InScattered + AttenuatedBackground;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 1.5+(2.0*mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t// raymarch to obtain transmittance along ray through clouds\n    vec3 L = primary( ro, rd );\n\n    fragColor = vec4( L, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsXSz7","date":"1398097702","viewed":665,"name":"Clouds, physically-based version","username":"jamiep","description":"Refactoring iq clouds, to figure out how it works in terms of volume rendering. Also adding HG phase function.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""}}