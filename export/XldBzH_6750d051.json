{"ver":"0.1","info":{"id":"XldBzH","date":"1538763568","viewed":135,"name":"try ray trace","username":"cailuming","description":"first ray trace, it is a pity that there is no shadows in that shadows is a little bit cost, maybe","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SMP 64\n#define cubeSize 0.5\n#define PI 3.1415926\n#define HPI 1.5707963\n\nstruct Ray {\n  vec3 o;\n  vec3 d;\n};\n    \nmat2 rot2D(float arc){\n  float c = cos(arc);\n  float s = sin(arc);  \n   \n  return mat2(c,s,-s,c);  \n}\n\n//objects\nvec2 light(vec3 p,vec3 c){\n    p-=c;\n   \n    return vec2(length(p)-0.5,-1);\n}\n\nvec2 sphere(vec3 p,vec3 c){\n    p-=c;\n    p.xz*=rot2D(iTime);\n    return vec2(length(p)-1.0+sin(p.x*20.)*sin(p.y*20.)*sin(p.z*20.)*0.01,0);\n}\n\nvec2 box(vec3 p,vec3 c){\n    p-=c;\n    p.xz*=rot2D(iTime);\n    p.xy*=rot2D(iTime);\n    \n    vec3 f = vec3(clamp(p.x,-cubeSize,cubeSize),clamp(p.y,-cubeSize,cubeSize),clamp(p.z,-cubeSize,cubeSize));\n    \n    return vec2(length(p-f)-0.3,1);\n}\n\nvec2 pyramid(vec3 p,vec3 c){\n    p-=c;\n    p.xz*=rot2D(iTime);\n   \n    float h = clamp(p.y,0.0,1.);\n \n    p = abs(p);\n    p.y+=0.8;\n    return vec2((p.x+p.y+p.z-2.)/sqrt(3.),2);\n}\n\nvec2 ground(vec3 p,vec3 c){\n    p-=c;\n    return vec2(p.y+1.0-exp(p.z*0.1),3);\n}\n \nvoid cmp(inout vec2 a,vec2 b){\n    a = a.x> b.x? b:a;\n}\n\nvec2 map(vec3 p){\n   vec2 ref = vec2(100);\n   \n   cmp(ref,light(p,vec3(5.*sin(iTime),3,5.*cos(iTime))));\n   cmp(ref,sphere(p,vec3(0,texture(iChannel0,vec2(0.5,0)).x*4.0,0)));\n   cmp(ref,box(p,vec3(-3,texture(iChannel0,vec2(0,0)).x*4.0,0)));\n   cmp(ref,pyramid(p,vec3(3,texture(iChannel0,vec2(0.7,0)).x*4.0,0)));\n   cmp(ref,ground(p,vec3(0,-2,0)));\n    \n   \n   return ref; \n}\n\nvec3 getNormal(vec3 p, float t){\n    vec2 e = vec2(1.0,0.0)*0.01*t;\n    float m = map(p).x;\n    \n    return normalize(vec3(map(p+e.xyy).x-m,map(p+e.yxy).x-m,map(p+e.yyx).x-m));\n}\n\n\nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n    vec3 look = normalize(tar-eye);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up  = normalize(cross(look,right));\n    \n    r.o  = eye;\n    r.d  = normalize(right*uv.x+up*uv.y+look);\n    \n}\n\n// get the fresnel value,it seems that a lot of people will use another simple equation\n// so I dont know why..\nfloat getReflectV(float nt,float arci,float arct){\n   float s = (nt*cos(arci)-cos(arct))/(nt*cos(arci)+cos(arct));\n   float p = (cos(arci)-nt*cos(arct))/(cos(arci)+nt*cos(arct));\n   return (pow(s,2.)+pow(p,2.))*0.5;\n}\n\n// all the shading stuff\nvoid doShading(inout Ray r,vec3 lp,vec2 res,inout vec3 col,float it){\n    vec3 p= r.o+res.x*r.d;\n    vec3 n = getNormal(p,res.x);\n    vec3 ld = normalize(lp-p);\n    vec3 rd = reflect(r.d,n);\n    vec3 lrd = reflect(ld,n);\n    \n    float nl = smoothstep(-.0,1.0,dot(n,ld));\n    float rl = dot(lrd,r.d);\n   \n    float nt=0.12;\n    \n    float fresnel = getReflectV(nt,rl,rl/nt);\n    fresnel = smoothstep(0.,1.0,fresnel);\n    \n    nl*=fresnel;\n    nl*=1./(it+1.);\n    if(res.y==0.){\n       \n        col+=texture(iChannel1,rd).xyz*nl;\n    }else if(res.y==1.){\n        col+=vec3(0.8,0.7,1.1)*nl;\n    }else if(res.y==2.){\n        col+= vec3(0.7,0.6,0.1)*nl;\n    }else if(res.y==3.){//floor\n        col+=vec3(1.)*nl;\n    }else if(res.y==-1.){\n        col= vec3(1.7,1.6,1.1);\n    }\n    // change the ray info each time when we bounced an object\n    r.o= p;\n    r.d = rd;\n}\n\n// a virtual wall, force the ray to bounce back in a given domain\nvoid clampRay(inout Ray r,vec3 p,float b){\n    if(p.x>=b){\n       r.o=p;\n       r.d.x = -r.d.x;\n    }\n    \n    if(p.x<=-b){\n       r.o=p;\n       r.d.x = -r.d.x;\n    }\n    \n    if(p.y<=-b){\n       r.o=p;\n       r.d.y = -r.d.y;\n    }\n    \n    if(p.y>=b){\n       r.o=p;\n       r.d.y = -r.d.y;\n    }\n    \n    if(p.z<=-b){\n       r.o=p;\n       r.d.z = -r.d.z;\n    }\n    \n    if(p.z>=b){\n       r.o=p;\n       r.d.z = -r.d.z;\n    }\n    \n}\n\nvoid rayTrace(inout Ray r,float ref,inout vec3 col,vec3 lp){\n    float t =0.;\n    vec2 res = vec2(0);\n    vec3 bgc = vec3(0.3,0.4,0.5);\n    vec3 p = vec3(0);\n    float btime =0.;\n    float fdeep =0.;\n    for (int i=0;i<SMP;i++){\n        \n        if(t>=128.0||btime>=5.) break;\n         \n        p = r.o+t*r.d;\n        clampRay(r,p,150.0);\n        res = map(p);\n        \n        if(res.x<=0.005){\n           doShading(r,lp,vec2(t,res.y),col,btime);\n           btime +=1.0;\n            if(fdeep<=0.0){\n                fdeep = t;\n            } \n        }\n        \n        t+=res.x; \n        \n    }\n    \n    col = mix(col,bgc,1.0-exp(-fdeep*fdeep*fdeep*0.0001));\n   \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 tuv = fragCoord/iResolution.xy;\n    vec2 cuv = tuv - vec2(0.5);\n    float as = iResolution.x/iResolution.y;\n    cuv.x*=as;\n    vec3 eye = vec3(0,2,-10);\n    vec3 tar = vec3(0,0, 1 );\n    \n    vec3 lp  = vec3(5.*sin(iTime),3,5.*cos(iTime));\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    vec2 res = vec2(1000);\n    Ray r;\n    \n    eye.z+=cos(iTime);\n    setCamera(r,eye,tar,cuv);\n    \n    rayTrace(r,200.,col,lp);\n    col = smoothstep(0.,1.0,col);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}