{"ver":"0.1","info":{"id":"MtGfRz","date":"1541876676","viewed":107,"name":"Shade","username":"dacruzquen","description":"shade","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shade"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//link : \n\n//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\n//camera parameters\nconst vec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\n\n//Sphere parameters\nconst vec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1);\nconst vec3 lightPos = vec3(8,10,-12);\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V)\n{\n    vec3 A = sphereMat.Ka * ambiantCol;\n    vec3 D = sphereMat.Kd * sphereCol * lightCol * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * lightCol * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n//The aim of this routine is to find the nearest intersection the ray has with all objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//pt is assumed to be on the place surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        \tbreak;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        \tbreak;\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n        \tbreak;\n    }\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    int objId;\n    vec3 intersec, normal;\n   \tfloat dist = computeNearestIntersection(rayPos, rayDir, objId, intersec, normal);\n    Material objMat;\n    vec3 col = getObjectColorAtPoint(objId, intersec, objMat);\n    \n    if(dist > 0.0)\n    {        \n    \t//Unit vector from the surface point towards the light\n    \tvec3 L = normalize(lightPos - intersec);\n        \n    \t//Unit vector of the reflection direction\n    \tvec3 R = normalize(2.0*dot(normal,L)*normal - L);\n        \n    \t//Unit vector going from the surface point towards the camera\n    \t//vec3 V = normalize(cameraPos - intersecS);\n    \tvec3 V = -rayDir;\n        \n        float Ldist = distance(intersec,lightPos);\n        \n        float shadowFactor = getShadowFactorAtPoint(intersec, normal, objMat, L, Ldist);\n        \n    \t//Phong shading to get the color of the surface point\n    \tfragColor = vec4(computePhongShading(col, objMat, shadowFactor, normal, L, R, V), 1);\n    }\n    \n    else //We didn't hit the sphere so background\n        fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}