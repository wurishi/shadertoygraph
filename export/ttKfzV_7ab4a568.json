{"ver":"0.1","info":{"id":"ttKfzV","date":"1614719179","viewed":113,"name":"lockless camera","username":"YielDuck","description":"implementation of lockless camera, parametrised by spherical angles, `at` and `distance`","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\nvec3 rayPoint(Ray r, float t) {return r.origin + t * r.direction;}\n\nstruct RayIntersection\n{\n    float t;\n    vec3 norm;\n};\nbool happened(RayIntersection i) {return i.t > 0.;}\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\nRayIntersection intersect(Ray r, Sphere s)\n{\n    vec3 dr = r.origin - s.center;\n    float p = dot(r.direction, dr);\n    if(p > 0.)\n        return RayIntersection(0., vec3(0.));\n    float d = p * p - dot(dr, dr) + s.radius * s.radius;\n    if(d < 0.)\n        return RayIntersection(0., vec3(0.));;\n    float t = -p - sqrt(d);\n    return RayIntersection(t, normalize(rayPoint(r, t) - s.center));\n}\n\nstruct Camera\n{\n    float phi, theta;\n    float d;\n    \n    vec3 at;\n    // vec3 up = vec3(0., 0., 1.);\n    \n    float aspectRatio;\n    float fov; // vertical\n};\nmat3 rotate(Camera camera)\n{\n    vec3 z = vec3\n    (\n        cos(camera.theta) * cos(camera.phi),\n        cos(camera.theta) * sin(camera.phi),\n        sin(camera.theta)\n    );\n    // in case up != (0, 0, 1), z must be rotated\n    // using quaternion which rotates (0, 0, 1) to up\n\n    vec3 x = normalize(cross(vec3(0., 0., 1.), z));\n\n    const float pi = 3.1415926535;\n    x = mod(floor(camera.theta / pi + 0.5), 2.) == 0. ? x : -x;\n\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\nRay castRay(Camera camera, vec2 uv)\n{\n    mat3 m = rotate(camera);\n    float f = tan(0.5 * camera.fov);\n    return Ray\n    (\n        camera.at + camera.d * m[2],\n        normalize\n        (\n            m[0] * (uv.x * f * camera.aspectRatio)\n          + m[1] * (uv.y * f)\n          - m[2]\n        )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera camera = Camera\n    (\n        0.02 * (iMouse.x - iResolution.x * 0.5),\n        0.02 * (iMouse.y - iResolution.y * 0.5),\n        3.,\n        vec3(0.),\n        float(iResolution.x) / float(iResolution.y),\n        1.\n    );\n    vec2 uv = 2. * fragCoord / iResolution.xy - vec2(1.);\n    Ray ray = castRay(camera, uv);\n\n    Sphere sphere0 = Sphere(vec3(0.), 0.5);\n    Sphere sphere1 = Sphere(vec3(0.5), 0.3);\n\n    RayIntersection i0 = intersect(ray, sphere0);\n    RayIntersection i1 = intersect(ray, sphere1);\n\n    RayIntersection i;\n    if(happened(i0) && happened(i1))\n    {\n        if(i0.t < i1.t)\n            i = i0;\n        else\n            i = i1;\n    }\n    else if(happened(i0))\n        i = i0;\n    else\n        i = i1;\n\n    vec3 color = happened(i)\n        ? vec3(i.norm.z + 0.5, i.norm.z - 0.5, 0.3)\n        : vec3(0.);\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}