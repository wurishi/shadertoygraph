{"ver":"0.1","info":{"id":"3dSBRG","date":"1590228016","viewed":768,"name":"Rocket Toy","username":"sylvain69780","description":"My son's rocket toy, use mouse to move camera and rotate the rocket.\n[url]https://www.elc.co.uk/action-figures-and-playsets/Happyland-Lift-Off-Rocket/p/541321[/url]","likes":34,"published":1,"flags":64,"usePreview":0,"tags":["modeling","stars","rocket"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ltSSRz","filepath":"https://soundcloud.com/danz-cheng-shih-ee/fly-me-to-the-moon-in-other?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/danz-cheng-shih-ee/fly-me-to-the-moon-in-other?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Rocket Toy\n    ----------\n    \n    This is my first shader published, was so proud that I use it now for my profile picture.\n    \n    The \"Happyland Lift-Off Rocket\" is a very nicely designed toy, and I had the idea to\n    replicate it, as it uses quite basic shapes. Looking at it, it seems a quite\n    good sample of use of IQ's SDF functions. \n\n    The 2D Vesica SDF is used with opRevolution and rounding for the body of the rocket.\n    The rocket is carved using onioning.\n    The polar domain repetition is used for creating 3 reactors for the price of one. \n    You may have fun by modifing the line with comment \"HERE you can tune the number of engines.\"\n    \n    Related references:\n    \n    IQ awesome tutorial \"LIVE Coding and Painting with Maths\" : \n    https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n    \n    IQ Distance functions\n    https://iquilezles.org/articles/distfunctions\n    https://iquilezles.org/articles/distfunctions2d\n\n    Starfield from BigWings (Art of code)\n    https://www.youtube.com/watch?v=rvDo9LvfoVE\n    \n    Glow effect inspired by Shaw - WASP Coils by shau (no more available)\n    \n    3D GLOW TUTORIAL - alro\n    https://www.shadertoy.com/view/7stGWj\n\n*/\n\n#define TAU 6.283185\n\nvec2 sdAlien ( vec3 pos, float atime ) {\n    if ( length(pos) > 1.0 || pos.y < -2.0 ) { return vec2(length(pos)-0.99,2.); }\n    vec3 q = pos;\n    q.y-=-.1+abs(0.15*sin(atime*2.*0.7));\n    q.yz*=rot(-0.10+0.10*sin(atime*1.4));\n    q.xz*=rot(0.20*sin(atime*0.7));\n    q.x=abs(q.x); // symetry !\n    float d = sdEllipsoid(q,vec3(0.45,0.20,0.45)) ;\n    q.z-=.1;\n    vec3 top = vec3(0.15,0.5,0.2);\n    vec2 sti = sdStick(q,vec3(0.1,0.,0.),top,0.15,0.08);\n    d = smin(d,sti.x,0.05);\n    d = smin(d,sdSphere(q-top,.12),0.03);\n    top=vec3(0.0,0.70,0.25);\n    sti = sdStick(q,vec3(0.,0.,0.),top,0.15,0.08);\n    d = smin(d,sti.x,0.05);\n    d = smin(d,sdSphere(q-top,.14),0.03);\n    vec2 res = vec2 ( d, 5. );\n    // neck\n    sti = sdStick(q,vec3(0.,0.,-0.2),vec3(0.,-1.,-0.2),0.25,0.30);\n    d = smin(d,sti.x,0.05);\n    // mouth\n    top=vec3(0.0,0.02,0.04);\n    d = smin(d,sdTorus(q-top,vec2(.35,.03)),0.01);\n    res = vec2 ( d, 5. );\n    top=vec3(0.0,-0.02,0.04);\n    d = smin(d,sdTorus(q-top,vec2(.35,.03)),0.01);\n    res = vec2 ( d, 5. );\n    // eyes\n    // 1\n    top = vec3(0.15,0.5,0.26);\n    float s = sdSphere(q-top,.08);\n    if ( s < res.x ) { res.x=s ; res.y=6.; }\n    top = vec3(0.14,0.5,0.30);\n    s = sdSphere(q-top,.05);\n    if ( s < res.x ) { res.x=s ; res.y=7.; }\n    // 3\n    top=vec3(0.0,0.70,0.32);\n    s = sdSphere(q-top,.09);\n    if ( s < res.x ) { res.x=s ; res.y=6.; }\n    top=vec3(0.0,0.69,0.38);\n    s = sdSphere(q-top,.05);\n    if ( s < res.x ) { res.x=s ; res.y=7.; }    \n    return res;\n}\n\n// simple function if you have all objets identical (no need to manage an ID)\nvec3 opRepRoundabout(vec3 p,float radius,float sectors) {\n    float angle = TAU/sectors;\n    float sector = round(atan(p.z,p.x)/angle); // thanks to IQ video https://youtu.be/sl9x19EnKng?t=1745\n    p.xz *= Rot(-angle*sector);\n    p.x -= radius;\n    return p;\n}\n\nvec3 sdRocket( vec3 pos, float atime )\n{\n    float m = 2.; // material 2 = red, 3 = gray , 4 = portholes\n    // try to box in a sphere for optimization\n    if ( length(pos) > 1.5 ) { return vec3(length(pos)-1.3,-1.,0.); }\n\tfloat d = 1e10;\n    float g = 0.;\n    // body\n\tvec3 q; \n    q = pos - vec3(0.,0.,0.);\n  \td = min( d, -0.03+abs(-0.1 + sdVesica(opRevolution(q,0.0), 1.4, 1.1 )));  // ABS for onioning\n\n    if ( pos.y > 0.74 ) { m = 3.; } // painting\n    if ( pos.y < -0.90 ) { m = 3.; } // painting bottom \n    // strips \n    float vangle = atan(pos.z,pos.x); // angle from left to front\n    if ( sin(vangle*3.) <.5 ) {\n    if ( pos.y < -0.3  && pos.y > -0.5 && cos(vangle*6.)>.0 )  { m = fract(.54*atime) > .5 ? 3.:4. ; }\n    if ( pos.y < -0.5  && pos.y > -0.65 && cos(vangle*6.)<.0 ) { m = fract(.24*atime) > .5 ? 3.:4. ; }\n    if ( pos.y < -0.65 && pos.y > -0.80 && cos(vangle*6.)>.0 ) { m = fract(.34*atime) > .5 ? 3.:4. ; }\n    }\n  \n    // porthole\n    q = pos;\n    float ln;\n    // hole with cylinder\n    ln = max(-q.z,sdCylinder(q.yzx-vec3(0.0,0.0,0.0), vec3(0.,0.,0.15)));\n   \tif (max(ln,d) <.01) g+=.05;\n    if ( ln < -d ) { m = 3.; d = -ln ; }\n\t// alien on board\n    vec2 dm = sdAlien( (q.yxz-vec3(-0.0,-0.05,0.3))*5. ,atime);\n    dm.x/=5.;\n    if ( dm.x < d ) { m = dm.y; d = dm.x ; }\n    \n    // 3 sectors for engines\n    q = pos;\n    float engines = 3.0; // HERE you can tune the number of engines.\n    q.xz *= rot(-0.25*TAU/engines); // rotation to position first piece\n\tq = opRepRoundabout(q,.05,engines); // https://www.shadertoy.com/view/ts3yzB\n    ln = -0.05 + sdVesica(opRevolution(vec3(q.x-.6,q.y+.8,q.z),0.0), 0.65, 0.5 ) ;\n    if ( ln < d ) { m = 2. ; d = ln ; }\n    // cut the bottom\n\td = smax( d, -pos.y-1.1, 0.05 );\n    if ( pos.y < -0.96 ) { m = 3.; } // painting bottom \n    // link between engines and rocket's body\n\tq = vec3(q.x+0.1,q.y+1.13,q.z+0.0);\n    float lnd = sdCircle(q.xy, 1.00 );\n        lnd = max(lnd,-sdCircle(q.xy+vec2(-0.3,0.3),0.6));\n        lnd = max(lnd,-sdCircle(q.xy+vec2(0.8,-1.1),1.3));\n        lnd = max(lnd,q.x-0.8);\n        lnd = max(lnd,-q.y+0.2);\n\tln = opExtrussion (q,lnd,0.02)-0.01;\n    if ( ln < d ) { m = 3. ; d = ln ; }\n\tg += 0.09*smoothstep(-0.87,-0.96,pos.y)*smoothstep(.2,0.,d)*(.8+.2*sin(pos.y*30.+10.*atime)); // reactor glowing\n\tg -= 0.09*smoothstep(0.64,0.85,pos.y)*smoothstep(.25,0.,d)\n        *smoothstep(.45,.55,fract(atime));   // noze blick \n    \n    return vec3(d,m,g);\n\n}\n\nvec3 animateRocket(vec3 pos,float atime) {\n    float sequence = 10.*fract(atime/20.);\n    vec3 q = pos;\n    \tq.x=-q.x+sin(atime)*0.5+0.2;  \n        q.xz*=rot(-3.14/2.0);\n        q -= vec3(0.,0.2+0.2*sin(atime*5.0),0.);   // this gives the nice rock of the rocket\n        q.yz*=rot(cos(atime*5.0)/5.-3.14/2.0);\n        q.xz*=rot(1.2*3.14/2.0);\n    return q;\n}\n\nvec3 map( in vec3 pos, float atime )\n{\n\tvec3 q = pos;\n    // rocket\n    return sdRocket(animateRocket(q,atime*0.7),atime); \n}\n\n\nvec3 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec3 res = vec3(-1.0,-1.0,0.);\n    float tmin = 0.5;\n    float tmax = 20.0;\n    float t = tmin;\n    for( int i=0; i<512 ; i++ )\n    {\n        vec3 h = map( ro+rd*t, time );\n        if ( h.z != 0. ) { // slow the ray marching for fake glow effect\n            res.z += h.z;\n            h.x=min(h.x,.1);\n        }\n        if( h.x<0.001 )\n        { \n            res = vec3(t,h.y,res.z); \n            break;\n        }\n        t += h.x;\n        if (t>=tmax) break;\n    }    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, float time )\n{\n    vec2 e = vec2(0.0005,0.0);\n    return normalize( vec3( \n        map( pos + e.xyy, time ).x - map( pos - e.xyy, time ).x,\n\t\tmap( pos + e.yxy, time ).x - map( pos - e.yxy, time ).x,\n\t\tmap( pos + e.yyx, time ).x - map( pos - e.yyx, time ).x ) );\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd, float time, vec4 starPosition )\n{ \n    vec3 col = starField(starPosition.xy,time*.1,starPosition.z,starPosition.w);     \n    vec3 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        \n\t\tcol = vec3(0.2);\n\n\t\tif( res.y>6.5 ) // black\n        { \n            col = vec3(0.00,0.00,0.00);\n        }\n\t\telse if( res.y>5.5 ) // white\n        { \n            col = vec3(0.5,0.5,0.5);\n        }\n\t\telse if( res.y>4.5 ) // alien\n        { \n            col = vec3(0.05,0.20,0.05);\n        }\n\t\telse if( res.y>3.5 ) // not used color\n        { \n            col = vec3(0.1,0.1,0.1);\n            res.z = .4;\n        }\n\t\telse if( res.y>2.5 ) // rocket gray part\n        { \n            col = vec3(0.1,0.1,0.1);\n        }\n\t\telse if( res.y>1.5 ) // rocket red part\n        { \n            col = vec3(0.5,0.00,0.00);\n        }\n\t\telse // terrain (not used)\n        {\n            col = vec3(0.02,0.02,0.02);\n        }\n        \n        // lighting , in these few lines there is all the magic from IQ copied from Happy Jumping\n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd ); // Blinn halfway vector\n        float sun_sha = step(castRay( pos+0.001*nor, sun_lig,time ).y,0.0);\n        float ks = 1.0;\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha;\n        lin += sky_dif*vec3(0.50,0.70,1.00);\n        lin += bou_dif*vec3(0.40,1.00,0.40);\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n    }\n    if ( res.z > 0. ) col += res.z*res.z*vec3(0.5,0.5,1.0); // fake glowing\n    if ( res.z < 0. ) col += res.z*res.z*vec3(1.0,0.02,0.02); // fake red glowing\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    float time = iTime-3.0;\n\n    time *= 0.9;\n\n    // camera\t\n    vec3  ta = vec3( 0.0, 0.3, 0.0);\n    vec3  ro =  vec3 (0.,1.,2.5);\n    float an = 0.0*time*.1;\n    vec2 m=(iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n    if ( iMouse.x > 0.0 ) {\n\t// mouse\n        an=m.x*6.28;\n        ro.yz *= rot(m.y);\n    }\n    ro.xz *= rot(an);\n    \n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p,2.5+.5*sin(iTime)) );\n    vec4 starPosition = vec4(p,.2*iTime*vec2(cos(an),-sin(an)));  // the only way I found to make the starfield rotate with the camera\n    vec3 col = render( ro, rd, time, starPosition );\n       \n    col = pow( col, vec3(1.0/2.2) ); // Gamma , always at the end if we are computing colors in linear color space\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// some general use functions\n\nmat2 rot(float angle)\n{\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n//-------------------------------------------------\n\n// https://www.shadertoy.com/view/4lyfzw\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d); // can delay this sqrt\n    return ((p.y-b)*d > p.x*b) \n            ? length(p-vec2(0.0,b))\n            : length(p-vec2(-d,0.0))-r;\n}\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p)-r; \n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.shadertoy.com/view/4sc3D7\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\nvec3 colorTemperatureToRGB(float kelvin){\n    // https://gist.github.com/paulkaplan/5184275\n  \n    float temp = kelvin / 100.;\n    float red, green, blue;\n    if( temp <= 66. ){ \n        red = 255.; \n        green = temp;\n        green = 99.4708025861 * log(green) - 161.1195681661;        \n        if( temp <= 19.){\n            blue = 0.;\n        } else {\n            blue = temp-10.;\n            blue = 138.5177312231 * log(blue) - 305.0447927307;\n        }\n    } else {\n        red = temp - 60.;\n        red = 329.698727446 * pow(red, -0.1332047592);\n        green = temp - 60.;\n        green = 288.1221695283 * pow(green, -0.0755148492 );\n        blue = 255.;\n    }\n\tred = clamp(red,   0., 255.)/255.;\n    green = clamp(green, 0., 255.)/255.;\n    blue = clamp(blue, 0., 255.)/255.;\n    return vec3(red,green,blue);\n}\n\n\n// Starfield Tutorial by Martijn Steinrucken aka BigWings - 2020\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.youtube.com/watch?v=rvDo9LvfoVE\n// https://www.shadertoy.com/view/wt3XDH\n// https://www.shadertoy.com/view/tlyGW3\n// This is the end result of a tutorial on my YouTube channel The Art of Code\n// \n\n#define NUM_LAYERS 4.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\n\nfloat Star(vec2 gv, float sz, float flare) {    \n    float d = length(gv);\n    float col = smoothstep(.99,.8,d) * .01*sz/d;\n    col*=col;\n    float a = smoothstep(.995, 1., 1.-abs(gv.x)) * .01/d * flare;\n    a+= smoothstep(.995, 1., 1.-abs(gv.y)) * .01/d * flare;\n    col += a;    \n    return col;\n}\n\nvec3 StarLayer(vec2 uv, float t) {\n\tvec3 col = vec3(0);\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    for(int y=-1;y<=1;y++) {\n    \tfor(int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x, y);\n    \t\tfloat n = Hash21(id+offs); // random between 0 and 1\n            float size = fract(n*345.32);\n            float phase = sin(t*40.+n*6.2831)*.5+1.;\n            float kelvin = fract(n*782.71);\n    \t\tfloat star = Star(gv-offs-vec2(n, fract(n*34.))+.5, size, smoothstep(.5, 1., size)*.2);\n            vec3 color = vec3(\n                mix(1.,.60,smoothstep(.3,.8,kelvin)),\n                mix(.1,1.,smoothstep(.0,.3,kelvin))*mix(1.,.70,smoothstep(.3,.8,kelvin)),\n                mix(0.0,1.0,smoothstep(.1,.3,kelvin))\n            );\n            star *= phase;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\n\nvec3 starField ( vec2 p, float t, float vx,float vy) {\n        // stars \n    vec3 starcol = vec3(0);\n    vec2 uv= p;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n    \tfloat depth = fract(i-vy*4.);\n        float scale = mix(5., 0.3, depth);\n        float fade = depth*smoothstep(1., .9, depth);\n        starcol += StarLayer(uv*scale+i*453.2+vec2(vx*20.,0.),t)*fade;\n    }\n    return starcol;\n}\n\n","name":"Common","description":"","type":"common"}]}