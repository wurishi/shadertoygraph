{"ver":"0.1","info":{"id":"sssGR8","date":"1615542831","viewed":90,"name":"Fork musk's tex samrrr 174","username":"samrrr","description":"Mipmapped, 2D texture based 4D noise. This is mostly a test shader where I developed the noise functions for [url]https://www.shadertoy.com/view/XsSGDy[/url]","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","texture","mipmap"],"hasliked":0,"parentid":"4dSGDy","parentname":"musk's texturenoise"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tThis is mostly a test shader where I developed the noise functions for \n\tFloating Mountains https://www.shadertoy.com/view/XsSGDy\n\n\tThe input texture is 2d however I'm generating upto 4d texture by \nadding the same slice of texture with random offsets. Mipmapping along \ngenerated dimensionns produces some artifacts but it's good enough.\n\t\n\t- There are some minor artifacts (at least on my hardware)\n\t- Mipmapping can be disabled by using a negative lod parameter.\n\t- The noise is smoothened if you use a positive lod parameter.\n    - The texture has 4 channels. There is absolutely no reason not to use them.\n\n*/\n\n/* short singleline version\n//2D texture based 4 component 1D, 2D, 3D noise\nvec4 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0));}\nvec4 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy);}\nvec4 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev).yz*21.421),texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s).yz*14.751),m);}\nvec4 noise(vec4 p){float m = mod(p.w,1.0);float s = p.w-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(noise(p.xyz+noise(sprev).wyx*3531.123420),\tnoise(p.xyz+noise(s).wyx*4521.5314),\tm);}\nvec4 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod);}\nvec4 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod);}\nvec4 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev,lod).yz,lod*21.421),texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s,lod).yz,lod*14.751),m);}\n*/\n\n//2D texture based 4 component 1D, 2D, 3D noise\nvec4 noise(float p)\n{\n\treturn texture(iChannel0,vec2(p/iChannelResolution[0].x,.0));\n}\n\nvec4 noise(vec2 p)\n{\n\treturn texture(iChannel0,p/iChannelResolution[0].xy);\n\n}\nvec4 noise(vec3 p)\n{\n\tfloat m = mod(p.z,1.0);\n\tfloat s = p.z-m; \n\tfloat sprev = s-1.0;\n\tif (mod(s,2.0)==1.0) \n\t{ \n\t\ts--; \n\t\tsprev++; \n\t\tm = 1.0-m; \n\t};\n\treturn mix(\n\t\ttexture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev).yz*21.421),\n\t\ttexture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s).yz*14.751)\n\t\t,m\n\t);\n}\n\nvec4 noise(vec4 p)\n{\n\tfloat m = mod(p.w,1.0);\n\tfloat s = p.w-m; \n\tfloat sprev = s-1.0;\n\tif (mod(s,2.0)==1.0) \n\t{ \n\t\ts--; \n\t\tsprev++; \n\t\tm = 1.0-m; \n\t};\n\treturn mix(\n\t\tnoise(p.xyz+noise(sprev).wyx*3531.123420),\n\t\tnoise(p.xyz+noise(s).wyx*4521.5314),\n\t\tm\n\t);\n}\n\nvec4 noise(float p, float lod)\n{\n\treturn texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod);\n}\n\nvec4 noise(vec2 p, float lod)\n{\n\treturn texture(iChannel0,p/iChannelResolution[0].xy,lod);\n}\n\nvec4 noise(vec3 p, float lod)\n{\n\tfloat m = mod(p.z,1.0);\n\tfloat s = p.z-m; \n\tfloat sprev = s-1.0;\n\tif (mod(s,2.0)==1.0) \n\t{ \n\t\ts--; \n\t\tsprev++; \n\t\tm = 1.0-m; \n\t};\n\treturn mix(\n\t\ttexture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev,lod).yz,lod*21.421),\n\t\ttexture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s,lod).yz,lod*14.751)\n\t\t,m\n\t);\n}\n\nvec4 noise(vec4 p, float lod)\n{\n\tfloat m = mod(p.w,1.0);\n\tfloat s = p.w-m; \n\tfloat sprev = s-1.0;\n\tif (mod(s,2.0)==1.0) \n\t{ \n\t\ts--; \n\t\tsprev++; \n\t\tm = 1.0-m; \n\t};\n\treturn mix(\n\t\tnoise(p.xyz+noise(sprev).wyx*3531.123420,lod),\n\t\tnoise(p.xyz+noise(s).wyx*4521.5314,lod),\n\t\tm\n\t);\n}\n\n// New hash based on hash13() from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Bnoise(in vec4 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.zwyx + 31.32);\n    return fract((p.x + p.y) * p.z - p.x * p.w);\n}\n\nfloat Bsnoise(in vec4 p) {\n    vec4 cell = floor(p);\n    vec4 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldbq = Bnoise(cell);\n    float rdbq = Bnoise(cell + vec4(1.0, 0.0, 0.0, 0.0));\n    float ldfq = Bnoise(cell + vec4(0.0, 0.0, 1.0, 0.0));\n    float rdfq = Bnoise(cell + vec4(1.0, 0.0, 1.0, 0.0));\n    float lubq = Bnoise(cell + vec4(0.0, 1.0, 0.0, 0.0));\n    float rubq = Bnoise(cell + vec4(1.0, 1.0, 0.0, 0.0));\n    float lufq = Bnoise(cell + vec4(0.0, 1.0, 1.0, 0.0));\n    float rufq = Bnoise(cell + vec4(1.0, 1.0, 1.0, 0.0));\n    float ldbw = Bnoise(cell + vec4(0.0, 0.0, 0.0, 1.0));\n    float rdbw = Bnoise(cell + vec4(1.0, 0.0, 0.0, 1.0));\n    float ldfw = Bnoise(cell + vec4(0.0, 0.0, 1.0, 1.0));\n    float rdfw = Bnoise(cell + vec4(1.0, 0.0, 1.0, 1.0));\n    float lubw = Bnoise(cell + vec4(0.0, 1.0, 0.0, 1.0));\n    float rubw = Bnoise(cell + vec4(1.0, 1.0, 0.0, 1.0));\n    float lufw = Bnoise(cell + vec4(0.0, 1.0, 1.0, 1.0));\n    float rufw = Bnoise(cell + 1.0);\n\n    return mix(mix(mix(mix(ldbq, rdbq, local.x),\n                       mix(lubq, rubq, local.x),\n                       local.y),\n\n                   mix(mix(ldfq, rdfq, local.x),\n                       mix(lufq, rufq, local.x),\n                       local.y),\n\n                   local.z),\n\n               mix(mix(mix(ldbw, rdbw, local.x),\n                       mix(lubw, rubw, local.x),\n                       local.y),\n\n                   mix(mix(ldfw, rdfw, local.x),\n                       mix(lufw, rufw, local.x),\n                       local.y),\n\n                   local.z),\n\n               local.w);\n}\n\nfloat Bfnoise(in vec4 p, in float scale, in float octaves) {\n    p *= scale;\n    float nscale = 1.0;\n    float tscale = 0.0;\n    float value = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += Bsnoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvec4 Bfnoise(in vec4 p){\n    return vec4(\n    Bfnoise(p,1.0,1.0)\n    );\n}\n\n#define t (iTime+16.0)\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat object(vec3 p)\n{ \n\tfloat sphere = length(p+vec3(1.5,0.0,0.0))-1.;\n\tsphere = min(sphere,length(p+vec3(-1.5,0.0,0.0))-1.);\n\t//for (float i = .0; i<1.0; i+=.09)\n\t//{\n\t//\tfloat plane = (p*rotate_x(t*.05+i*3214.1)*rotate_y(t*.06+i*12342.581)*rotate_z(t*.07+i*7342.581)).z;\n\t//\tplane = plane+sin(t*0.2)*.4-.6;\n\t//\tsphere = max(plane,sphere);\n\t//}\n\treturn sphere;\n}\n\nfloat dist(vec3 p)\n{\n\treturn object(p);\n}\n\nvec3 normal(vec3 p) //returns the normal, uses the distance function\n{\n\tfloat e = .03; float d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n\t\n}\n\nmat4 rot_mat(){\n\n    float[6] rot;\n    rot[0] = 4461.0;\n    rot[1] = 22345.0;\n    rot[2] = 45456.0;\n    rot[3] = 5173.0;\n    rot[4] = 6456.0;\n    rot[5] = 734.0;\n\n    mat4 rotation = mat4(1);\n\n    mat4 newrotation = rotation;\n\n    newrotation[0] = (rotation[0]*cos(rot[0])+rotation[1]*sin(rot[0]));\n    newrotation[1] = (rotation[1]*cos(rot[0])-rotation[0]*sin(rot[0]));\n\n    rotation = newrotation;\n\n    newrotation[0] = (rotation[0]*cos(rot[1])+rotation[2]*sin(rot[1]));\n    newrotation[2] = (rotation[2]*cos(rot[1])-rotation[0]*sin(rot[1]));\n\n    rotation = newrotation;\n\n    newrotation[0] = (rotation[0]*cos(rot[2])+rotation[3]*sin(rot[2]));\n    newrotation[3] = (rotation[3]*cos(rot[2])-rotation[0]*sin(rot[2]));\n\n    rotation = newrotation;\n\n    newrotation[1] = (rotation[1]*cos(rot[3])+rotation[2]*sin(rot[3]));\n    newrotation[2] = (rotation[2]*cos(rot[3])-rotation[1]*sin(rot[3]));\n\n    rotation = newrotation;\n\n    newrotation[1] = (rotation[1]*cos(rot[4])+rotation[3]*sin(rot[4]));\n    newrotation[3] = (rotation[3]*cos(rot[4])-rotation[1]*sin(rot[4]));\n\n    rotation = newrotation;\n\n    newrotation[2] = (rotation[2]*cos(rot[5])+rotation[3]*sin(rot[5]));\n    newrotation[3] = (rotation[3]*cos(rot[5])-rotation[2]*sin(rot[5]));\n\n    rotation = newrotation;\n    \n    return rotation;\n}\n\nvec4 texture4d(vec4 p) //4d texture\n{\n    if(p.x>0.0)\n        return Bfnoise(p);\n\t\t\n    return Bfnoise(rot_mat()*p);\n}\n\nvec3 background(vec3 p, vec3 d)\n{\n\tvec3 a = vec3(.0);\n\tfor (float i=.0; i<1.0; i+=.2)\n\t{\n\t\tvec3 light = normalize(noise(t*.2+i*142100.0).xyz-vec3(.5));\n\t\tvec3 light_color = normalize(noise(t*.1+i*15400.0).xyz);\n\t\ta += (dot(light,d)*.5+.5)*light_color*(i+.2)*.2;;\n\t\ta += ((vec3(1.0)-light_color)*.125)*.1;\n\t}\n\treturn a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\tvec3 c = (uv.y*.5+.5)*vec3(.4,.6,.9);\n\t\n\tvec3 p = vec3(.0,.0,3.0);\n\tvec3 d = normalize(vec3(uv,-1.0));\n\t\n\tmat3 rotation = rotate_x(mouse.y*+4.0)*rotate_y(mouse.x*+4.0);\n\tmat3 inv_rot = rotate_y(mouse.x*-4.0)*rotate_x(mouse.y*-4.0);\n\tp*=rotation; d*=rotation;\n\t\n\tfloat ds;\n\tfor (int i=0; i<80; i++)\n\t{\n\t\tds = dist(p);\n\t\tp+=ds*d*1.0;\n\t\tif (ds>40.1001||ds<.001) break;\n\t}\n\t\n\t//shading\n\t\n\tvec3 backdrop = background(p,d);\n\tvec3 a = backdrop;\n\t\n\t\n\t\n\tif (ds<1.0)\n\t{\n\t\ta = vec3(.0);\n\t\t//use noise functions for coloring\n\t\tvec4 tex;\n\t\n\t\t\ttex = \n\t\t\t\ttexture4d(vec4(p*10.0,t*0.8)).xyzw;\n\t\t\n\t\tvec3 diffuse_color = tex.xyz;\n\t\t\n\t\tvec3 n = normal(p);\n\t\tn = normalize(n+(tex.zyx-vec3(.5))*tex.w);\n\t\t\n\t\tdiffuse_color = mix(diffuse_color,vec3(.2,.4,.8),.5);\n\n\t\tfloat fresnel = pow(1.0+dot(d,n),2.0);\n\t\tfresnel = min(1.0,fresnel);\n\t\t\n\t\tfor (float i=.0; i<1.0; i+=.2)\n\t\t{\n\t\t\tvec3 light = normalize(noise(t*.2+i*142100.0).xyz-vec3(.5)+vec3(0.0,10.0,0.0));\n\t\t\t\n\t\t\tfloat diffuse = dot(n,light);\n\t\t\tdiffuse = pow(max(.0,diffuse*.9+.1),.7);\n\t\t\tvec3 light_color = normalize(noise(t*.1+i*15400.0).xyz);\n\t\t\tvec3 shading = mix((vec3(1.0)-light_color)*.125,light_color,diffuse);\n\t\t\tfloat highlight = pow(dot(reflect(d,n),light)*.5+.5,100.0)*2.0;\n\t\t\ta += (diffuse_color*shading+vec3(highlight)*fresnel)*(i+.2)*.7;\n\t\t}\n\t\t\n\t\t\n\t\ta += background(p,reflect(d,n))*fresnel;\n\t}\n\t\n\ta += noise(vec3(fragCoord.xy,t*24.0)).xyz*.02;\n\ta -= length(uv)*.1;\n\ta = mix(a,vec3(length(a)),a*1.5-.5);\n\t\n\tfragColor = vec4(pow(a,vec3(.7)),1.0);\n\t\n}","name":"Image","description":"","type":"image"}]}