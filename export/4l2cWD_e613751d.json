{"ver":"0.1","info":{"id":"4l2cWD","date":"1508703030","viewed":763,"name":"Fractal Fireworks 1.3","username":"AustinSpafford","description":"Quick experiment in using shadertoy's buffer ping-ponging and mouse input features.\n\nControls: Click to launch fireworks, otherwise the shader will occasionally spawn ambient fireworks.","likes":37,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mouse","simulation","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pass: Glow horizontal-blur and final output.\n\n// Version 1.1:\n// - Disabled cellular-automata based blur/glow.\n// - Added a glow that uses a gaussian-like blur.\n// - Fixed clicking in full-screen mode failing to spawn fractals (apparently mouse-coordinates are no longer texel-aligned in fullscreen).\n\n// Version 1.2:\n// - Added per-generation mutation to branch lengths, controlled by \"kMaxGenerationMutation\".\n\n// Version 1.3:\n// - To fix the shader's thumbnail failing to display fireworks for a while, forced always-on spawning.\n// - To help avoid oddly clipped fireworks, added a gutter around the edge of the screen for placement of ambient fireworks.\n\nvec2 sTexelSize;\n\nvec3 hsbToRgb(\n    vec3 hsbColor)\n{\n    // From: https://www.shadertoy.com/view/MsS3Wc\n    vec3 rgb = clamp(abs(mod((hsbColor.x * 6.0) + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = (rgb * rgb * (3.0 - (2.0 * rgb)));\n    return (hsbColor.z * mix(vec3(1.0), rgb, hsbColor.y));\n}\n\nvec3 cellStateToCellColor(\n    vec4 cellState)\n{\n    return hsbToRgb(vec3(\n        fract(0.0471 * cellState.z), \n        0.9, \n        cellState.w));\n}\n\nfloat blurWeight(\n    float radiusFraction)\n{\n    float result = smoothstep(1.0, 0.0, radiusFraction);\n    result = (result * result * result);    \n    return result;\n}\n\nvoid mainImage(\n    out vec4 outFragColor,\n    in vec2 fragCoord)\n{\n    sTexelSize = (1.0 / iResolution.xy);\n    \n    vec3 cellColor = cellStateToCellColor(texture(iChannel0, (fragCoord.xy * sTexelSize)));\n\t\n    vec3 glowColor;\n    {\n    \tglowColor = texture(iChannel1, (fragCoord.xy * sTexelSize)).rgb;\n        \n        vec3 accumulator = vec3(0.0);\n        float totalWeight = 0.0;\n\n        float oneOverBlurRadius = (1.0 / 10.0);\n\n        for (float xDelta = -10.0; xDelta <= 10.0; xDelta++)\n        {\n            vec2 sampleCoord = (fragCoord.xy + vec2(xDelta, 0.0));\n            vec3 sampleColor = texture(iChannel1, (sampleCoord * sTexelSize)).rgb;\n            \n            float sampleWeight = blurWeight(abs(xDelta) * oneOverBlurRadius);\n            \n            accumulator += (sampleColor * sampleWeight);\n            totalWeight += sampleWeight;\n        }\n        \n        glowColor = (accumulator / totalWeight);\n    }\n    \n\toutFragColor = vec4(\n        mix(glowColor, cellColor, sign(dot(cellColor, cellColor))),\n        1.0);\n    \n    outFragColor.rgb = pow(outFragColor.rgb, vec3(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Pass: Simulation\n\n// Cell format:\n// x = remainingSteps\n// y = direction\n// z = edgeTotalSteps\n// w = brightness\n\n#define AMBIENT_FIREWORKS_ENABLED\n//#define CELLULAR_BLUR_ENABLED\n\nconst float kAmbientFireworkPeriod = 3.0;\nconst float kFadeRate = 0.5;\nconst float kBlurFadeSteps = 50.0;\nconst float kMaxGenerationMutation = 1.0;\n\nvec2 sTexelSize;\n\nfloat randomFloat(\n  vec2 testCoord)\n{\n\t// From: https://www.shadertoy.com/view/Xd23Dh\n\t// (just removed some dimensions)\n\tfloat testCoordInGeneratorSpace = \n\t\tdot(testCoord, vec2(127.1, 311.7));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nvec2 randomVec2(\n  vec2 testCoord)\n{\n\t// From: https://www.shadertoy.com/view/Xd23Dh\n\t// (just removed some dimensions)\n\tvec2 testCoordInGeneratorSpace = vec2(\n\t\tdot(testCoord, vec2(127.1, 311.7)),\n\t\tdot(testCoord, vec2(269.5, 183.3)));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nvec3 randomVec3(\n  vec2 testCoord)\n{\n    // From: https://www.shadertoy.com/view/Xd23Dh\n    // (just removed some dimensions)\n    vec3 testCoordInGeneratorSpace = vec3(\n        dot(testCoord, vec2(127.1, 311.7)),\n        dot(testCoord, vec2(269.5, 183.3)),\n        dot(testCoord, vec2(419.2, 371.9)));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nfloat wrapDirection(\n    float unboundedDirectionIndex)\n{\n    return mod(unboundedDirectionIndex, 8.0);\n}\n\nvoid considerBlurCandidate(\n    vec2 selfCoord,    \n    vec2 candidateIndexDelta,\n    inout vec4 inoutSelfState)\n{\n\tvec2 candidateCoord = (selfCoord + candidateIndexDelta);\n\tvec4 candidateState = texture(iChannel0, (candidateCoord * sTexelSize));\n    \n    if (candidateState.w > inoutSelfState.w)\n    {\n        inoutSelfState = vec4(\n            0.0,\n            candidateState.y,\n            candidateState.z,\n            (candidateState.w - (kBlurFadeSteps * (kFadeRate * iTimeDelta))));\n    }\n}\n\nvoid considerTrailCandidate(\n    vec2 selfCoord,\n    float selfToCandidateDirection,\n    vec2 candidateIndexDelta,\n    inout vec4 inoutSelfState,\n\tinout int inoutAcceptedCandidateCount)\n{\n\tvec2 candidateCoord = (selfCoord + candidateIndexDelta);\n\tvec4 candidateState = texture(iChannel0, (candidateCoord * sTexelSize));\n    \n    if (candidateState.x > 0.0)\n    {\n        float candidateToSelfDirection = wrapDirection(selfToCandidateDirection + 4.0);\n        \n        // If this candidate is travelling, otherwise it's dying/splitting.\n        if (candidateState.x > 1.1)\n        {\n            if (abs(candidateToSelfDirection - candidateState.y) < 0.5)\n            {\n                inoutSelfState = vec4(\n                    (candidateState.x - 1.0),\n                    candidateState.y,\n                    candidateState.z,\n                    1.0);\n                \n        \t\tinoutAcceptedCandidateCount++;\n            }\n        }\n        else\n        {\n            float leftTurnDirection = wrapDirection(candidateState.y + 1.0);\n            float rightTurnDirection = wrapDirection(candidateState.y - 1.0);\n            float newEdgeSteps = (candidateState.z - mix(1.0, (1.0 + kMaxGenerationMutation), randomFloat(selfCoord)));\n            \n            if (abs(candidateToSelfDirection - leftTurnDirection) < 0.5)\n            {\n                inoutSelfState = vec4(\n                    newEdgeSteps,\n                    leftTurnDirection,\n                    newEdgeSteps,\n                    1.0);\n                \n                inoutAcceptedCandidateCount++;\n            }\n            else if (abs(candidateToSelfDirection - rightTurnDirection) < 0.5)\n            {\n                inoutSelfState = vec4(\n                    newEdgeSteps,\n                    rightTurnDirection,\n                    newEdgeSteps,\n                    1.0);\n                \n                inoutAcceptedCandidateCount++;\n            }\n        }\n    }\n}\n\nvoid mainImage(\n    out vec4 outFragColor,\n    in vec2 fragCoord)\n{\n    sTexelSize = (1.0 / iResolution.xy);\n        \n\tvec4 selfState = texture(iChannel0, (fragCoord.xy * sTexelSize));\n    \n    // If the cell is not yet part of a trail, attempt to become part of a trail.\n    if (selfState.x == 0.0)\n    {\n        vec4 trailState = selfState;\n        int acceptedCandidateCount = 0;\n        \n        considerTrailCandidate(fragCoord, 0.0, vec2(1.0, 0.0), trailState, acceptedCandidateCount);\n        considerTrailCandidate(fragCoord, 1.0, vec2(1.0, 1.0), trailState, acceptedCandidateCount);\n        considerTrailCandidate(fragCoord, 2.0, vec2(0.0, 1.0), trailState, acceptedCandidateCount);\n        considerTrailCandidate(fragCoord, 3.0, vec2(-1.0, 1.0), trailState, acceptedCandidateCount);\n        considerTrailCandidate(fragCoord, 4.0, vec2(-1.0, 0.0), trailState, acceptedCandidateCount);\n        considerTrailCandidate(fragCoord, 5.0, vec2(-1.0, -1.0), trailState, acceptedCandidateCount);\n        considerTrailCandidate(fragCoord, 6.0, vec2(0.0, -1.0), trailState, acceptedCandidateCount);\n        considerTrailCandidate(fragCoord, 7.0, vec2(1.0, -1.0), trailState, acceptedCandidateCount);\n        \n        // To avoid giving directional-preference, only accept trails when there are no conflicts.\n        if (acceptedCandidateCount == 1)\n        {\n            selfState = trailState;\n        }\n    }\n    else\n    {\n        // We were part of a trail, but we'll just turn into a fade-particle.\n        selfState.x = 0.0;\n    }\n    \n    // If the cell is alive, decay, otherwise blur.\n    if (selfState.w > 0.0)\n    {\n        selfState.w -= (kFadeRate * iTimeDelta);\n        \n        // If the cell just died.\n        if (selfState.w <= 0.0)\n        {\n            selfState = vec4(0.0);\n        }\n    }\n    else\n    {\n\t\t#ifdef CELLULAR_BLUR_ENABLED\n        considerBlurCandidate(fragCoord, vec2(1.0, 0.0), selfState);\n        considerBlurCandidate(fragCoord, vec2(1.0, 1.0), selfState);\n        considerBlurCandidate(fragCoord, vec2(0.0, 1.0), selfState);\n        considerBlurCandidate(fragCoord, vec2(-1.0, 1.0), selfState);\n        considerBlurCandidate(fragCoord, vec2(-1.0, 0.0), selfState);\n        considerBlurCandidate(fragCoord, vec2(-1.0, -1.0), selfState);\n        considerBlurCandidate(fragCoord, vec2(0.0, -1.0), selfState);\n        considerBlurCandidate(fragCoord, vec2(1.0, -1.0), selfState);\n\t\t#endif // CELLULAR_BLUR_ENABLED      \n    }\n    \n    // If any mouse button is pressed.\n    if (iMouse.z > 0.0)\n    {\n        vec2 fragToMouse = ((iMouse.xy + 0.5) - fragCoord.xy);\n        \n        if (dot(fragToMouse, fragToMouse) < 0.5)\n        {\n            //float edgeLength = mix(15.0, 25.0, randomFloat(fragCoord + vec2(iTime)));\n            float edgeLength = 22.0;\n            \n\t\t\tselfState = vec4(\n                edgeLength, // remainingSteps\n                2.0, // direction\n                edgeLength, // edgeTotalSteps\n                1.0); // brightness\n        }\n    }\n    \n    // Spawn ambient fireworks.\n    #ifdef AMBIENT_FIREWORKS_ENABLED\n    {\n        float currentFireworkIndex = floor(iTime / kAmbientFireworkPeriod);\n        float currentFireworkPeriodStartTime = (kAmbientFireworkPeriod * currentFireworkIndex);\n        \n        float ambientFireworkTime = (currentFireworkPeriodStartTime + randomFloat(vec2(currentFireworkIndex, 0.0)));\n        \n        bool shaderIsThumbnail = (iResolution.y < 300.0);\n        \n        // If the firework was located in the previous frame.\n        bool fireworkTriggered = (((iTime - iTimeDelta) <= ambientFireworkTime) && (ambientFireworkTime < iTime));\n        \n        // To force the thumbnail-view to work, launch fireworks unconditionally.\n        fireworkTriggered = (shaderIsThumbnail ? true : fireworkTriggered);\n            \n        if (fireworkTriggered)\n        {\n            float placementGutterFraction = 0.2;\n            \n            vec2 randomPlacementFraction = mix(\n                vec2(placementGutterFraction), \n                vec2(1.0 - placementGutterFraction), \n                randomVec2(vec2(currentFireworkIndex, 1.1)));\n            \n            randomPlacementFraction = (shaderIsThumbnail ? vec2(0.5, 0.25) : randomPlacementFraction);\n            \n            vec2 fireworkCoord = (floor(randomPlacementFraction * iResolution.xy) + 0.5);\n\n            vec2 fragToFirework = (fireworkCoord - fragCoord.xy);\n\n            if (dot(fragToFirework, fragToFirework) < 0.5)\n            {\n                float edgeLength = mix(15.0, 25.0, randomFloat(vec2(currentFireworkIndex, 2.0)));\n\n                selfState = vec4(\n                    edgeLength, // remainingSteps\n                    2.0, // direction\n                    edgeLength, // edgeTotalSteps\n                    1.0); // brightness\n            }\n        }\n    }\n\t#endif // AMBIENT_FIREWORKS_ENABLED\n    \n    outFragColor = selfState;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Pass: Glow vertical-blur.\n\nvec2 sTexelSize;\n\nvec3 hsbToRgb(\n    vec3 hsbColor)\n{\n    // From: Iñigo Quiles \n    // https://www.shadertoy.com/view/MsS3Wc\n    vec3 rgb = clamp(abs(mod((hsbColor.x * 6.0) + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = (rgb * rgb * (3.0 - (2.0 * rgb)));\n    return (hsbColor.z * mix(vec3(1.0), rgb, hsbColor.y));\n}\n\nvec3 cellStateToCellColor(\n    vec4 cellState)\n{\n    return hsbToRgb(vec3(\n        fract(0.0471 * cellState.z), \n        0.9, \n        cellState.w));\n}\n\nfloat blurWeight(\n    float radiusFraction)\n{\n    float result = smoothstep(1.0, 0.0, radiusFraction);\n    result = (result * result * result);\n    return result;\n}\n\nvoid mainImage(\n    out vec4 outFragColor,\n    in vec2 fragCoord)\n{\n    sTexelSize = (1.0 / iResolution.xy);\n    \n    vec3 glowColor;\n    {\n        vec3 accumulator = vec3(0.0);\n        float totalWeight = 0.0;\n\n        float oneOverBlurRadius = (1.0 / 10.0);\n\n        for (float yDelta = -10.0; yDelta <= 10.0; yDelta++)\n        {\n            vec2 sampleCoord = (fragCoord.xy + vec2(0.0, yDelta));            \n            vec3 sampleColor = cellStateToCellColor(texture(iChannel0, (sampleCoord * sTexelSize)));\n            \n            float sampleWeight = blurWeight(abs(yDelta) * oneOverBlurRadius);\n\n            accumulator += (sampleColor * sampleWeight);\n            totalWeight += sampleWeight;\n        }\n        \n        glowColor = (accumulator / totalWeight);\n    }\n    \n    outFragColor = vec4(glowColor, 1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}