{"ver":"0.1","info":{"id":"4sfyWl","date":"1490204532","viewed":287,"name":"Penn Seal of Arms","username":"mmerchante","description":"A procedural representation of University of Pennsylvania's Seal of Arms for a procedural class I'm taking there :). I couldn't reproduce correctly some of the details, I will iterate on it later.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","logo","university"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//TODO:\n// - Iterate on the dolphin\n// - Improve edges\n// - Optimize/reduce code\n\n// Note: some of the functions are taken from mercury's HG_SDF\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat vmax(vec2 v) { return max(v.x, v.y); }\n\nfloat fCircle(vec2 p, float r) { return length(p) - r; }\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\tfloat box = length(max(d, vec2(0))) + vmax(min(d, vec2(0)));    \n    return box;//mix(box, fCircle(p, length(b) * .5), .5 - sin(iTime * .5) * .5);\n}\n\n// Hashes from iq\nfloat hash1( vec2 p )\n{\n    p  = 50.0 * fract(p * 0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\nfloat shieldSDF(vec2 uv, float scale) \n{\n    uv *= 100.0 * scale;\n    uv *= 1.75;\n    float dist = fBox2((uv - vec2(0.0, 75.0) * scale), vec2(125.0, 75.0) * scale);\n    \n    float leftQuad = saturate(fBox2((uv - vec2(-62.5, -75.0) * scale), vec2(62.5, 75.0) * scale));\n    dist = min(dist, max(leftQuad, fCircle((uv - vec2(52.5, 25.0) * scale), 180.0 * scale)));\n    \n    uv.x *= -1.0;\n    leftQuad = saturate(fBox2((uv - vec2(-62.5, -75.0)* scale), vec2(62.5, 75.0) * scale));    \n    dist = min(dist, max(leftQuad, fCircle((uv - vec2(52.5, 25.0)* scale), 180.0 * scale)));\n    \n    return dist;\n}\n\nfloat shield(vec2 uv) { return shieldSDF(uv, 1.0); }\n\nfloat stripe(vec2 uv) { return step(24.0, abs((abs(uv.x) + uv.y - .05) * 100.0)); }\n\nfloat book(vec2 uv)\n{\n    float dist = fBox2(uv, vec2(15.0, 15.0));\n    \n    dist = min(dist, fCircle(abs(uv - vec2(0.0, 4.0)) - vec2(13.0, 7.0), 4.5));\n        \n\treturn dist;\n}\n\nfloat innerBook(vec2 uv)\n{\n    uv.y -= pow(sin(uv.x * .3), 2.0) - 1.0 / (abs(uv.x * .2) + .25);\n    return fBox2(uv - vec2(0.0, 5.0), vec2(11.0, 13.0));    \n}\n\n// Whyyyy did they choose a dolphin\nfloat dolphin(vec2 uv)\n{\n    uv += vec2(0.0, .01);\n    uv.x = uv.x * 1.15 - .05;\n    vec2 baseUV = uv * 100.0;\n    float boundary = fBox2(uv * 100.0 - vec2(0.0, 55.0), vec2(17.0, 18.0));  \n    float y1 = sin(uv.x * 11.0 - 1.5) * .075;\n    uv.y -= .525 - y1;\n    uv.y *= 2.5 + saturate((uv.x * 4.0 + .45) * 1.0) * 3.0;\n    uv.y += uv.x;\n    uv *= 100.0;\n    \n    float base = smoothstep(23.0, 27.0, abs(uv.y) - .5);\n    \n    base = max(base, boundary);    \n    base = smoothstep(.1, .95, base);\n    return base;\n}\n\nfloat dolphinHead(vec2 uv)\n{\n    uv.x = uv.x * 1.15 - .05;\n    vec2 baseUV = uv * 100.0;\n    float head = fCircle(baseUV - vec2(-28.0, 65.0), 12.0);\n    \n    head = min(head, fCircle(baseUV - vec2(-15.0, 58.0), 4.0));\n    head = min(head, fCircle(baseUV - vec2(-17.0, 50.0), 7.0));\n    head = min(head, fCircle(baseUV - vec2(-27.0, 54.0), 9.0));\n    \n    // Masks\n    head = max(head, fCircle(baseUV - vec2(-30.0, 80.0), 35.0));\n    head = max(head, fCircle(baseUV - vec2(-10.0, 46.0), 23.0));\n    \n    head = min(head, fCircle(baseUV - vec2(-30.0, 51.5), 3.0));\n    \n    return head;\n}\n\nfloat dolphinMouth(vec2 uv)\n{\n    vec2 baseUV = uv * 200.0 - vec2(-38.0, 104.0);\n    baseUV.y *= .9;\n    baseUV.y += sin(baseUV.x * .175 + 2.0) * 1.75;\n    \n    float mouth = fBox2(baseUV, vec2(10.0, .5));\n    \n    float eye = fCircle(baseUV - vec2(1.0, 10.0), 3.0);\n    eye = max(eye, fCircle(baseUV - vec2(-3.0, 17.0), 10.0));\n    mouth = min(mouth, eye);\n    \n    baseUV = uv * 200.0 - vec2(3.0, 120.0);\n    baseUV.y *= .9;\n    baseUV.y += sin(baseUV.x * .65 + 2.0) * 1.75 + baseUV.x * baseUV.x * .03;\n    float innerScales = fBox2(baseUV, vec2(15.0, 1.4));\n\n    mouth = min(mouth, innerScales);\n    \n    return mouth;\n}\n\nfloat dolphinScales(vec2 uv)\n{\n    uv.x = uv.x * 1.15 - .05;\n    vec2 baseUV = uv * 100.0;\n        \n    float scale = fCircle(baseUV - vec2(-15.0, 68.0), 4.0);\n    scale = min(scale, fCircle(baseUV - vec2(-10.0, 70.0), 4.0));\n    scale = min(scale, fCircle(baseUV - vec2(-5.0, 69.5), 4.0));    \n    scale = min(scale, fCircle(baseUV - vec2(0.0, 68.5), 4.0)); \n    scale = min(scale, fCircle(baseUV - vec2(5.0, 64.5), 4.0));\n    scale = min(scale, fCircle(baseUV - vec2(8.0, 60.5), 4.0));\n    scale = min(scale, fCircle(baseUV - vec2(10.0, 55.5), 4.0));\n    \n    return scale;\n}\n\nfloat dolphinTail(vec2 uv)\n{\n    vec2 baseUV = uv * 100.0 - vec2(21.6, 57.0);\n    baseUV.x *= 1.3;\n    \n    float tail = fCircle(baseUV - vec2(-5.0, 0.0), 11.2);\n    tail = smoothstep(0.0, 4.0, tail * fCircle(baseUV - vec2(-5.0, 6.0), 10.5));\n    \n    float mask = fBox2(baseUV - vec2(3.0, -5.0), vec2(10.0, 7.0));\n    tail = max(tail, mask);\n    \n    mask = fCircle(baseUV - vec2(0.195, 0.0), 13.0);\n    tail = max(tail, mask);\n    \n    return tail * tail;\n}\n\nfloat dolphinTailEnd(vec2 uv)\n{\n    vec2 baseUV = uv * 150.0 - vec2(39.0, 88.0);\n \n    float end = fCircle(baseUV - vec2(-10.0, 0.0), 11.95);\n    end = end * fCircle(baseUV - vec2(-5.0, 6.0), 10.0);    \n    \n    float mask = fBox2(baseUV - vec2(-2.0, 10.0), vec2(10.0, 7.0));\n   \tend = max(end, mask);\n    \n    float end2 = fCircle(baseUV - vec2(10.0, 6.0), 13.0);\n    end2 = end2* fCircle(baseUV - vec2(17.0, 6.0), 12.0);\n    \n    float mask2 = fBox2(baseUV - vec2(8.0, 14.0), vec2(7.0, 9.0));\n   \tend2 = max(end2, mask2);\n    \n    end = min(end, end2);\n    \n    return smoothstep(0.0, 2.0, end);\n}\n\nvec3 evaluateShieldColor(vec2 uv)\n{\n    vec3 whiteBorder = mix(vec3(1.0), vec3(0.0), shield(uv));\n    \n    float innerShieldMask = saturate(shield(uv * 1.065));\n    \n    vec3 blueBorder = mix(vec3(0, 0.294, 0.557), whiteBorder, innerShieldMask);\n    vec3 innerWhite = mix(vec3(1.0), blueBorder, saturate(shield(uv * 1.125)));\n    \n    float upperQuad = saturate(fBox2((uv * 100.0 - vec2(0.0, 54.0)), vec2(63.5, 23.0)));\n    vec3 upperRed = mix(vec3(0.706, 0.031, 0.22), innerWhite, upperQuad);\n    \n    vec2 bookMask = vec2(abs(uv.x), uv.y) * 110.0 - vec2(50.0, 60.0);\n    vec3 books = mix(vec3(0, 0.294, 0.557), upperRed, saturate(book(bookMask)));\n    books = mix(vec3(1.0), books, saturate(book(bookMask * 1.15)));\n    \n    // Inner book\n    books = mix(vec3(0, 0.294, 0.557), books, saturate(innerBook(bookMask)));\n    books = mix(vec3(1.0), books, saturate(innerBook(bookMask * 1.25 - vec2(0.0, 2.0))));\n    books = mix(vec3(0, 0.294, 0.557), books, saturate(fBox2(bookMask - vec2(0.0, 4.0), vec2(1.0, 12.5))));\n    \n    upperQuad = saturate(fBox2((uv * 100.0 - vec2(0.0, 31.0)), vec2(64, 1.0)));\n    vec3 upperBlueLine = mix(vec3(0, 0.294, 0.557), books, upperQuad); \n    \n    vec3 blueStripe = mix(vec3(0, 0.294, 0.557), upperBlueLine, max(innerShieldMask, saturate(stripe(uv)))); \n    \n    vec3 circles = mix(vec3(1.0), blueStripe, saturate(fCircle(uv * 200.0 + vec2(0.0, -2.5), 21.0)));\n    circles = mix(vec3(1.0), circles, saturate(fCircle(uv * 200.0 + vec2(60.0, 50.0), 21.0)));\n    circles = mix(vec3(1.0), circles, saturate(fCircle(uv * 200.0 + vec2(-60.0, 50.0), 21.0)));\n    \n    // Make fish smaller\n    uv *= 1.3;\n    uv += vec2(.025, -.1);\n    vec3 dolphinColor = mix(vec3(0, 0.294, 0.557), circles, saturate(dolphinScales(uv * .935 + vec2(0.0, .02))));\n    dolphinColor = mix(vec3(1.0), dolphinColor, saturate(dolphinScales(uv * 1.1 - vec2(0.0, .08))));\n    \n    float dolphinBase = saturate(dolphin(uv * vec2(.95, .94) + vec2(0.01, .005)));\n    // We need to fix the connection...\n    dolphinBase = max(dolphinBase, saturate(fBox2(uv * 100.0 - vec2(-0.0, 33.5), vec2(16.0, 40.0))));    \n    dolphinBase = min(dolphinBase, saturate(dolphinTail(uv * vec2(.8, .77) + vec2(0.025, .105))));\n    \n    dolphinBase = min(dolphinBase, saturate(dolphinTailEnd(uv * vec2(.8, .75) + vec2(0.05, .17))));\n    \n\tdolphinColor = mix(vec3(0, 0.294, 0.557), dolphinColor, dolphinBase);\n    \n    dolphinColor = mix(vec3(1.0), dolphinColor, saturate(dolphin(uv * vec2(1.075, 1.15) - vec2(0.0, .1225))));\n    dolphinColor = mix(vec3(1.0), dolphinColor, saturate(dolphinTail(uv * .915 + vec2(0.0, .03))));\n    \n    dolphinColor = mix(vec3(0, 0.294, 0.557), dolphinColor, saturate(dolphinHead(uv * .915 + vec2(0.0, .03))));\n    dolphinColor = mix(vec3(1.0), dolphinColor, saturate(dolphinHead(uv * 1.1 - vec2(-.025, .08))));\n    \n    dolphinColor = mix(vec3(0, 0.294, 0.557), dolphinColor, saturate(dolphinMouth(uv * .915 + vec2(0.0, .03))));\n    \n    dolphinColor = mix(vec3(1.0), dolphinColor, saturate(dolphinTailEnd(uv)));\n    \n    return dolphinColor;\n}\n\n// Uff I'll optimize it later\nfloat worley(vec2 uv)\n{\n    uv += uv * sin(-iTime * 2.0 + 7.0 * length(uv)) * .05;\n    \n    float scale = 5.0;\n    vec2 p = floor(uv * scale);\n    \n    vec2 p1 = p + vec2(0.0, 0.0);\n    p1 += hash2(p) * .5;\n    \n    vec2 p2 = p + vec2(1.0, 0.0);\n    p2 += hash2(p2) * .5;\n    \n    vec2 p3 = p + vec2(1.0, 1.0);\n    p3 += hash2(p3) * .5;\n    \n    vec2 p4 = p + vec2(0.0, 1.0);\n    p4 += hash2(p4) * .5;\n\n    vec2 p5 = p + vec2(-1.0, 0.0);\n    p5 += hash2(p5) * .5;\n    \n    vec2 p6 = p + vec2(-1.0, -1.0);\n    p6 += hash2(p6) * .5;\n    \n    vec2 p7 = p + vec2(0.0, -1.0);\n    p7 += hash2(p7) * .5;\n    \n    vec2 p8 = p + vec2(-1.0, 1.0);\n    p8 += hash2(p8) * .5;\n    \n    vec2 p9 = p + vec2(1.0, -1.0);\n    p9 += hash2(p9) * .5;\n    \n    p = uv * scale;\n    \n    float d1 = length(p - p1);\n    float d2 = length(p - p2);\n    float d3 = length(p - p3);\n    float d4 = length(p - p4);\n    float d5 = length(p - p5);\n    float d6 = length(p - p6);\n    float d7 = length(p - p7);\n    float d8 = length(p - p8);\n    float d9 = length(p - p9);\n    \n    float d = d1;\n    d = min(d, d2);\n    d = min(d, d3);\n    d = min(d, d4);\n    d = min(d, d5);\n    d = min(d, d6);\n    d = min(d, d7);\n    d = min(d, d8);\n    d = min(d, d9);\n    \n    float c = mix(0.0, p1.x - floor(p1.x), step(abs(d - d1), 0.0));\n    \n    c = mix(c, p2.x - floor(p2.x), step(abs(d - d2), 0.0));\n    c = mix(c, p3.x - floor(p3.x), step(abs(d - d3), 0.0));\n    c = mix(c, p4.x - floor(p4.x), step(abs(d - d4), 0.0));\n    c = mix(c, p5.x - floor(p5.x), step(abs(d - d5), 0.0));    \n    c = mix(c, p6.x - floor(p6.x), step(abs(d - d6), 0.0));\n    c = mix(c, p7.x - floor(p7.x), step(abs(d - d7), 0.0));\n    c = mix(c, p8.x - floor(p8.x), step(abs(d - d8), 0.0));\n    c = mix(c, p9.x - floor(p9.x), step(abs(d - d9), 0.0));\n    \n    return c;\n}\n\nvec3 background(vec2 uv)\n{   \n    float dist = fBox2(uv, vec2(.15)) * .65;\n    vec3 color = mix(vec3(0.169, 0.322, 0.49) * 1.5, vec3(0, 0.11, 0.298), saturate(vec3(dist)));    \n    float shadow = smoothstep(0.0, 1.0, .35 + shieldSDF(uv, .001) * 50.0);\n       \n    float voronoi = 1.75 * (worley(uv) + .35);\n    return voronoi * color * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;    \n    uv.x *= aspect;\n    \n    //uv.x += sin(uv.y * .002 * iTime);\n    \n    vec3 bgColor = background(uv);\n    vec3 shieldColor = evaluateShieldColor(uv);\n    \n    vec3 outColor = mix(shieldColor, bgColor, saturate(shield(uv)));\n    \n    fragColor = vec4(outColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}