{"ver":"0.1","info":{"id":"Mt23Rc","date":"1455484838","viewed":146,"name":"ray tracing #1","username":"davidp","description":"Trace pixels into rays that hit various shapes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// We want to translate a screen position into a box rendering.\n//\n// To do that, we need to cast a ray from each fragment location (uv).\n// We \"project\" the ray into a function that returns a pixel color.\n//\n// We're saying \"at this position on the screen, the scene looks like this\" and\n// we return the fragment at that position.\n//\n// Movement can be simple -- we apply some offset to the ray position and convert into\n// a vec3 ray.  As long as our rendering function takes a vec3 as the ray, then we should be good!\n//\n// Two strategies:\n// - Use traditional ray tracing where we cast a ray and see if it hits geometry.\n// - Use ray marching, same concept except we step each ray\n \nconst float pi = 3.14159265359;\n \nvec3 offy(float i) {\n    float f = sin(iTime) * .5 + .5;\n    return vec3(0);//texture(iChannel0, vec2(i * 0.07 + f, i * 0.09 +f)).xy, 0.);\n}\n \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n   \nstruct AABB {\n    vec3 lower;\n    vec3 upper;\n};\n \n \nmat3 rotateX(float th) {\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(1, 0, 0,\n                0, c, -s,\n                0, s, c);\n}\n \n \nmat3 rotateY(float th) {\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(c, 0, s,\n                0, 1, 0,\n                -s,0, c);\n}\n \n// via http://prideout.net/blog/?p=64\nbool IntersectBox(Ray r, AABB box, out float t0, out float t1)\n{\n    vec3 invR = 1.0 / r.direction;\n    vec3 tbot = invR * (box.lower - r.origin);\n    vec3 ttop = invR * (box.upper - r.origin);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    t1 = min(t.x, t.y);\n    return t0 <= t1;\n}\n \n \nbool pointInsideBox(vec3 point, AABB box) {    \n    vec3 lower = box.lower;\n    vec3 upper = box.upper;\n \n    return (lower.x <= point.x && upper.x >= point.x &&\n            lower.y <= point.y && upper.y >= point.y &&\n            lower.z <= point.z && upper.z >= point.z);\n}\n \n \nfloat rayDistance;\nbool shittyRayMarch(Ray ray, AABB box) {\n    const float steps = 40.;\n    const float fraction = 0.5 / steps;\n   \n    vec3 delta = vec3(0.);\n    ///for (float i = 0.; i < steps; i += 1.) {\n        //delta = delta + (fraction * ray.direction);\n        //if (pointInsideBox(ray.origin + delta, box)) {\n            float t0, t1;\n            if (IntersectBox(ray, box, t0, t1)) {\n                rayDistance = (1. - t0); //distance(ray, delta));\n                return true;\n            }\n        //}\n    //}\n    return false;\n}\n \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    float st = 0.15 * pi * sin(iTime);\n   \n    mat3 rot = rotateY(st) * rotateX(st);\n    vec3 origin = rot * vec3(uv, 0.0);\n    vec2 uvp = (uv * 2. - 1.) * .4;\n    vec3 direction = normalize(rot * vec3(uvp.x, uvp.y, 1.0));\n   \n    Ray ray = Ray (origin, direction);\n   \n    AABB box1 = AABB( vec3(0.25, 0.0, 0.15), vec3(0.55, 0.55, 2.55));\n    AABB box2 = AABB( vec3(0.65, 0.65, 0.55), vec3(0.85, 0.85, 0.85));\n    AABB box3 = AABB( vec3(0.0, 0.65, 0.95), vec3(0.85, 0.85, 0.85));\n   \n    if (shittyRayMarch(ray, box1)) {\n        fragColor = vec4(rayDistance, rayDistance, rayDistance, 1.);\n        return;\n    } else if (shittyRayMarch(ray, box2)) {\n        fragColor = vec4(rayDistance, rayDistance, rayDistance, 1.);\n        return;\n    } else if (shittyRayMarch(ray, box3)) {\n        fragColor = vec4(rayDistance, rayDistance, rayDistance, 1.);\n        return;\n    }\n    fragColor = vec4(0);\n    // uv,0.5+0.5*sin(iTime)\n   \n}","name":"Image","description":"","type":"image"}]}