{"ver":"0.1","info":{"id":"Xl23D3","date":"1433556513","viewed":172,"name":"My Raytracer Test","username":"jackdavenport","description":"A simple raytracer, which uses quadratic equations to calculate objects and lighting. It then uses cubemaps to create baked reflections","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","lighting","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"vec4 clearColor1 = vec4(0.,0.6,0.9,1.);\nvec4 clearColor2 = vec4(0.8,0.8,0.8,1.);\n\n//lights\nvec3 light1 = vec3(-2, 2, 5);\n\n// sphere\nvec3 center = vec3(1., -0.5, 0);\nfloat radius = .1;\n\n// plane\nvec3 planeCenter = vec3(0,-2,-6);\nvec3 planeSize = vec3(50,1,50);\n\nvec4 renderSphere(vec3 dir, vec2 uv) {\n \n    float a = dot(dir, dir);\n    float b = 2. * dot(dir, center);\n    float c = dot(center, center) -(radius * radius);\n    \n    float det = (b * b) - 4. * a * c;\n    \n    if(det < 0.) {\n     \n        //return mix(clearColor1, clearColor2, 1. - uv.y);\n        return texture(iChannel0, dir);\n        \n    } else {\n     \n        float lambda = (-b + sqrt(det)) / (2. * a);\n        vec3 p = -lambda * dir;\n        vec3 n = p - center;\n       \n        vec3 l = light1 - p;\n        float diffuse = dot(normalize(n), normalize(l));\n        \n        //return vec4(normalize(l).xyz,1.0);\n        vec4 diffuseColor = vec4(1.,0.,0.,1.);\n     \treturn mix(diffuseColor, texture(iChannel0, normalize(reflect(dir, n))), 0.4) * diffuse;\n        \n    }\n    \n}\n\nvec4 renderPlane(vec3 dir, vec2 uv) {\n \n    vec3 n = vec3(0., 1., 0.);\n    \n    float a = dot(dir, dir);\n    float b = 2. * dot(dir, planeCenter);\n    float c = dot(planeCenter, planeCenter);\n    \n    float det = (b * b) - 4. * a * c;\n    \n    if(det < 0.) {\n     \n        //return mix(clearColor1, clearColor2, 1. - uv.y);\n        return texture(iChannel0, dir);\n        \n    } else {\n     \n        float lambda = (-b + sqrt(det)) / (2. * a);\n        vec3 p = -lambda * dir;\n       \n        vec3 l = light1 - p;\n        float diffuse = dot(normalize(n), normalize(l));\n        \n        //return vec4(normalize(l).xyz,1.0);\n        vec4 diffuseColor = vec4(1.,0.,0.,1.);\n     \treturn mix(diffuseColor, texture(iChannel0, normalize(reflect(dir, n))), 0.4) * diffuse;\n        \n    }\n    \n}\n\n// borrowed from iq's Primitives Shader\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 raytrace(vec3 pos, vec3 dir, vec2 uv) {\n    \n    float time = iTime;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 0., 0. );\n    \n    vec3 ray = setCamera(ro, ta, 0.) * normalize(vec3(dir.xy,2.3));\n    vec4 col = renderSphere(ray,uv);\n    \n    if(col == texture(iChannel0, ray)) {\n        \n        return renderPlane(ray, uv);\n        \n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy / 2.;\n    uv /= iResolution.y;\n    \n    //center = vec3(3. * sin(iTime), 0, -6);\n    vec3 dir = vec3(uv.x, uv.y, -1);\n    \n\tfragColor = raytrace(vec3(0., 0., 0.), dir, (fragCoord.xy / iResolution.xy));\n}","name":"","description":"","type":"image"}]}