{"ver":"0.1","info":{"id":"3dSXD1","date":"1553553482","viewed":2109,"name":"[twitch] Paper City","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and SHADOW_STEPS if too slow\nYou can find the original shader here: http://lezanu.fr/LiveCode/PaperCity.glsl\nInspired by https://www.shadertoy.com/view/tsjGRG","likes":86,"published":1,"flags":0,"usePreview":0,"tags":["3d","volumetric","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and SHADOW_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/PaperCity.glsl\nInspired by https://www.shadertoy.com/view/tsjGRG\n*/\n\n#define MARCH_STEPS 60\n#define SHADOW_STEPS 10\n\n#define time iTime\nfloat PI=acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat box(vec3 p, vec3 s) {\n  vec3 ap=abs(p)-s;\n  //return length(max(vec3(0),ap)) + min(0, max(ap.x,max(ap.y,ap.z)));\n  return max(ap.x,max(ap.y,ap.z));\n}\n\nfloat tri(vec3 p, vec3 s) {\n  p.y=-p.y;\n  p.xz=abs(p.xz);\n  return max(max(-p.y-s.y, dot(p.xy,vec2(0.7))-s.x), p.z-s.z);\n}\n\nfloat cone(vec3 p, float a, float b) {\n  return max(length(p.xz)-p.y*a, p.y-b);\n}\n\nvec3 rep(vec3 p, vec3 s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nvec2 rep(vec2 p, vec2 s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nfloat rep(float p, float s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nfloat house(vec3 p, float s) {\n  float t=tri(p+vec3(0,3,0)*s, vec3(1,1,3.5)*s);\n  t = min(t, box(p, vec3(2,2,3)*s));\n  return t;\n}\n\nfloat minitower(vec3 p) {\n  p.y+=5.0;\n  vec3 p2 = p;\n  if(abs(p2.x)<abs(p2.z)) p2.xz=p2.zx;\n  float t = min(house(p+vec3(0,3,0),0.5), house(p2, 1.0));\n  t = min(t, house(p-vec3(0,5,0),1.5));\n  return t;\n}\n\nfloat tower(vec3 p) {\n  p.y+=15.0;\n  vec3 p2 = p;\n  if(abs(p2.x)<abs(p2.z)) p2.xz=p2.zx;\n  float t = min(house(p+vec3(0,3,0),0.5), house(p2, 1.0));\n  t = min(t, house(p-vec3(0,5,0),1.5));\n  p2.x -= sign(p2.x)*5.0;\n  p2.x = abs(p2.x);\n  p2.z = abs(p2.z);\n  t = min(t, house(p2.zyx-vec3(2,8,2),0.3));  \n  t = min(t, house(p2-vec3(0,12,0),1.5));\n  return t;\n}\n\nfloat wall(vec3 p) {\n  \n  p.x -= cos(p.z*0.1)*2.0;\n  p.x -= sin(p.z*0.03)*3.0;\n  \n  vec3 rp=p;\n  rp.z = rep(rp.z, 5.0);\n  float w = box(rp+vec3(0,1,0), vec3(2,1,50));\n  rp.x = abs(rp.x)-2.0;\n  float m = box(rp-vec3(0,2,0), vec3(0.25,5,1.6));\n  return min(w, m);\n  \n}\n\nfloat field(vec3 p) {\n  vec3 p2 = p;\n  if(abs(p2.x)<abs(p2.z)) p2.xz=p2.zx;\n  \n  float tmp = box(p2, vec3(5,5,5));\n  float f = max(abs(tmp-4.0), -p.y-2.0);\n  f=min(f, box(p, vec3(7,0.5,7)));\n  \n  vec3 p3 = p;\n  p3.xz=rep(p3.xz, vec2(2.5));\n  \n  float a = box(p3, vec3(0.2,2,0.2));\n  a = min(a, cone(p3+vec3(0,4,0), 0.3,3.0));\n  f=min(f, max(a,tmp-3.8));\n  \n  return f;\n}\n\nfloat village(vec3 p) {\n  vec3 p2=p;\n  p2.xz = abs(p2.xz);\n  float w = wall(p);\n  p2.xz -= 23.0;\n  float t=tower(p2);\n  vec3 p3 = p;\n  p3.z = p3.z-4.5*sign(p.x);\n  p3.x = abs(p3.x)-25.0;\n  float f=field(p3);\n  \n  float res = t;\n  res = min(res, w);\n  res = min(res, f);\n  \n /*\n  p2.xz*=rot(0.3);\n  res = min(res, house(p2+vec3(13,0,0), 1));\n  p2.xz*=rot(0.6);\n  res = min(res, house(p2+vec3(18,1,-2.5), 1.5));\n  */\n  p.z = p.z+10.0*sign(p.x);\n  p.x = -abs(p.x);\n  res = min(res, minitower(p+vec3(29,1,0)));\n  \n  return res;\n}\n\nfloat map(vec3 p) {\n  \n  float t1=sin(length(p.xz)*0.009);\n  float s=12.0;\n  for(int i=0; i<6; ++i) {\n    p.xz=abs(p.xz)-s;\n    p.xz *= rot(0.55+t1+float(i)*0.34);\n    s /= 0.85;\n  }\n  p.x+=3.0;\n  \n  return min(village(p), -p.y);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist, 0.0, 1.0);\n}\n\nfloat noise(vec2 p) {\n  vec2 ip=floor(p);\n  p=smoothstep(0.0,1.0,fract(p));\n  vec2 st=vec2(67,137);\n  vec2 v=dot(ip,st)+vec2(0,st.y);\n  vec2 val=mix(fract(sin(v)*9875.565), fract(sin(v+st.x)*9875.565), p.x);\n  return mix(val.x,val.y,p.y);\n}\n\nfloat fractal(vec2 p) {\n  float d=0.5;\n  float v=0.0;\n  for(int i=0; i<5; ++i) {\n    v+=noise(p/d)*d;\n    d *= 0.5;\n  }\n  return v;\n}\n\nvec3 sky(vec3 r, vec3 l) {\n  float v=pow(max(dot(r,l),0.0),3.0);\n  \n  vec2 sphereuv = vec2(abs(atan(r.z,r.x))+time*0.03,atan(r.y,length(r.xz)));\n  \n  float skyn = fractal(sphereuv*vec2(5,10));\n  float skyn2 = fractal(sphereuv*vec2(5,10)*0.3-vec2(time*0.06,0));\n  skyn2=smoothstep(0.3,0.7,skyn2);\n  \n  vec3 blue = mix(vec3(0.5,0.5,0.8), vec3(0.0), skyn2*skyn);\n  \n  return mix(blue*0.2, vec3(1,0.7,0.4)*(skyn2*0.8+0.2), v);\n}\n\nvec3 sky2(vec3 r, vec3 l) {\n  float v=pow(max(dot(r,l),0.0),3.0);\n  \n  vec3 blue = vec3(0.5,0.5,0.8);\n  \n  return mix(blue*0.2, vec3(1,0.7,0.4), v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float t2=time+10.0;\n  vec3 s=vec3(0,0,-100);\n  s.yz *= rot(sin(t2*0.3)*0.2+0.5);\n  s.xz *= rot(t2*0.2);\n  vec3 t=vec3(0,30,60);\n  t.yz *= rot(sin(t2)*0.3-0.2);\n  t.xz *= rot(t2*0.32);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  //vec3 r=normalize(vec3(-uv, 0.7));\n  vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n  \n  \n  \n  vec3 p=s;\n  float dd=0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p);\n    if(abs(d)<0.001) break;\n    if(dd>500.0) {dd=500.0; break;}\n    p+=d*r*0.8;\n    dd+=d;\n  }\n  \n  float fog = 1.0-clamp(dd/500.0,0.0,1.0);\n  \n  vec3 col=vec3(0);\n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  float ao = (getao(p, n, 12.0) * 0.5 + 0.5) * (getao(p, n, 2.0) * 0.3 + 0.7) * (getao(p, n, 0.5) * 0.8 + 0.2);\n  \n  vec3 l=normalize(vec3(-1,-2,-2.5));\n  float f = pow(1.0-abs(dot(n,r)), 3.0);\n  \n  float shad = 1.0;\n  vec3 sp = p + n * 0.5 - r * 0.2;\n  for(int i=0; i<SHADOW_STEPS; ++i) {\n    float d=map(sp);\n    if(d<0.2) { shad = 0.0; break; }\n    sp+=d*l*3.0;\n  }\n  \n  col += max(0.0,dot(n,l)) * fog * vec3(1,0.7,0.4) * 1.5 * mix(0.0, ao*0.5+0.5, shad);\n  col += (-n.y*0.5+0.5) * ao * fog * vec3(0.5,0.5,0.8) * 0.5;\n  col += sky2(reflect(r,n), l)*f*10.0*fog * (0.5+0.5*shad);\n    \n  col += sky(r, l) * pow(dd*0.01,1.4);\n  \n  //col = vec3(shad);\n  \n  col = 1.0-exp(-col*2.5);\n  col = pow(col, vec3(2.3));\n  col = pow(col, vec3(0.4545));\n  \n  //col = vec3(skyn);\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}