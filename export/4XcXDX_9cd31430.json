{"ver":"0.1","info":{"id":"4XcXDX","date":"1719811352","viewed":60,"name":"Raymarched Sky-Cover Cloud","username":"GoodName","description":"Version of my original raymarched cloud renderer(https://www.shadertoy.com/view/4X3SWj) with a more practical sky based object. \n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud"],"hasliked":0,"parentid":"4X3SWj","parentname":"Raymarched Cloud"},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float falloff(float density)\n{\n    return pow(2., (density-1.) * 5.);\n}\n\nvec2 rand2( vec2 p)\t{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\nfloat voronoi(vec2 x){\n\t\tvec2 p = floor(x);\n\t\tvec2 f = fract(x);\n\t\tfloat res=8.0;\n\t\tfor (int j=-1;j<=1;j++) {\n\t\t\tfor (int i=-1;i<=1;i++){\n\t\t\t\tvec2 b = vec2(i,j);\n\t\t\t\tvec2 r = b-f+rand2(p+(b));\n\t\t\t\t//float d = max(abs(r.x),abs( r.y));\n\t\t\t\t//float d = pow(r.x*r.x*r.x*r.x+r.y*r.y*r.y*r.y,0.25);\n\t\t\t\tfloat d = (r.x*r.x+r.y*r.y);\n\t\t\t\tres = min(res, d);\n\t\t\t}\n\t\t}\n\t\treturn (res * -1.) + 1.;\n\t\t\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0. )/k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\n\nfloat map(vec3 p) {\n    vec3 q = p;\n    q.x = mod(p.x, 100.) - 50.;\n    q.z = mod(p.z, 100.) - 50.;\n    //float s1 = sdEllipsoid(q - vec3(0, 0., 0), vec3(5, 2., 3.5)); \n    //float s2 = sdEllipsoid(q - vec3(.5, .7, 0), vec3(3.2, 2.5, 1.5));\n    //float s3 = sdEllipsoid(q - vec3(-.5, -1.1, 1.), vec3(1., 1., 1.5));\n    //return smin(smin(s1, s2, 1.5), s3, 1.5);\n    \n   return sdBox(q - vec3(0., 20., 0.), vec3(100., 5., 100.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / 100.;\n\n    bool cloud = false;\n    float density = 0.;\n    \n    vec3 light = vec3(1., 20000., 1.);\n    float lightIntensity = 2.6;\n    \n    float move = float(iTime*5.);\n    vec3 ro = vec3(move, 0, -6. /*+ float(iFrame)/25.*/);       \n    vec3 rd = normalize(vec3(uv, 1)); \n    vec3 col = vec3(0);               \n    float d;\n\n    float t = 0.; \n    \n    //ro.xz *= rot2D(/*0.785398*/-m.x);\n    //rd.xz *= rot2D(/*0.785398*/-m.x);\n    \n    ro.yz *= rot2D(/*0.785398*/-m.y);\n    rd.yz *= rot2D(/*0.785398*/-m.y);\n    \n\n    vec3 p;\n    bool done = false;\n    \n    float darkness = 0.;\n    vec3 blend = vec3(.1, .5, 1.);\n    vec2 offset = vec2(731., 269.);\n    \n    float iterations = 10.;\n    \n    if (true)\n    {\n        for (int i = 0; i < 80; i++) {\n            p = ro + rd * max(t, .2);     \n\n            d = map(p);         \n\n            t += d;                 \n\n            if (d < .001)\n            {\n                cloud = true;\n                break;\n            }\n            if (t > 250.) \n            {\n                done = true;\n                break;    \n            }\n        }\n\n        if (cloud == true)\n        { \n            int count = 0;\n            \n            do\n            {\n                t += .05*iterations;\n                p = ro + rd * t;\n\n                d = map(p);\n                density += (texture(iChannel0,vec3((p.x/40.)+float(iTime/50.), vec3(p/40.).yz)).r\n                    * max(falloff(falloff(voronoi(vec2((p.x + float(iTime/5.))/15., p.z/15.)))), \n                    falloff(falloff(voronoi(vec2((p.x+offset.x + float(iTime/2.))/10., (p.z + offset.y)/10.)))))\n                    ) * .04*iterations;\n                \n                if (d < .01)\n                {\n                    int lightCount = 0;\n                    count++;\n                    float d2;\n                    float t2 = 0.;\n                    vec3 ld = normalize(vec3(light-p));\n                    \n                    do\n                    {\n                        d2 = map(vec3(p + ld * t2));\n                        t2 += 1.;\n                        lightCount++;\n                        \n                    }while(d2 < 0.);\n                    \n                    darkness += float(lightCount)/(10.*lightIntensity);\n                }\n            } while (d < 0. && density < 1.);\n            darkness = darkness / float(count);\n        }\n    }\n    \n    density = max(min(falloff(density)  - .1, 1.), 0.);\n    \n    float lighting = 1.-darkness;\n    \n    blend = vec3(.1, .5, 1.);\n    \n    if (cloud == false) col = vec3(.1, .5, 1.);\n    else col = vec3(blend.x + density * (lighting-blend.x), blend.y + density * (lighting-blend.y), blend.z + density * (lighting-blend.z));\n\n    fragColor = vec4(col, .1);\n}\n\n","name":"Image","description":"","type":"image"}]}