{"ver":"0.1","info":{"id":"dtsyRf","date":"1694824433","viewed":77,"name":"[phreax] akashic deconstruction","username":"phreax","description":"base on https://www.shadertoy.com/view/dllcDM","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax aka jiagual 2023\n*/\n\n#define PI 3.141592\n#define SIN(x) (sin(x)*.5+.5)\n#define PHI 1.618033988749895\n#define S(t1, t2) smoothstep(t1, t2, tt)\n\n\nfloat tt;\nvec3 gP = vec3(0);\n\n\nmat2 rot2(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n\n// by Nusan\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 10.));\n}\n\nvec3 rep(inout vec3 p, vec3 size) {\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 rep(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat rep(inout float p, float size) {\n  float c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nfloat box(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\nvec3 transform(vec3 p) {\n\n    float a = PI*.5 + iTime;\n    p.xz *= rot2(a);\n    p.xy *= rot2(a);\n    \n    return p;\n}\n\n\nfloat map(vec3 p) {\n\n    vec3 bp = p;\n    p.z += 0.9*tt;\n    gP = p;\n   \n    vec3 p2 = p;\n    p.xy *= rot2(PI*.25);\n    \n     \n\n    rep(p2.z, .3);\n    vec2 id = rep(p.xy, vec2(.6));\n    \n    //gUV += abs(gap);\n    vec3 s = vec3(vec2(.4)-.15*S(0., 1.), 1.3);\n    \n    float off =.4*(length(id)*1.5-4.5)*(S(0., 1.5));\n    p.z -= off;\n    \n    float d = box(p, s)-.005;\n    \n    d = max(d, -box(p2, vec3(100, 100, mix(0., .06, S(2.5, 3.)))));\n    return d*.1;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    uv.y -= .05;\n    \n    tt = 4.*SIN(.5*(iTime-2.5));  \n    vec3 ro = vec3(0, .4, -5),\n         rd = normalize(vec3(uv, .6)),\n\n         lp = vec3(-3., 4., -8);\n         \n             \n    vec3 p = ro;\n    vec3 col;\n    \n    vec2 UV;\n    vec3 P;\n    \n    float t, d = 0.1;\n\n    \n    for(float i=.0; i<200.; i++) {\n    \n        d = map(p);\n        P = gP;\n        \n        if(d < 0.0001 || t > 100.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    vec3 al = vec3(0.102,0.216,0.196);\n    vec3 bg =  mix(vec3(0.149,0.196,0.212), vec3(1), (1.-pow(dot(uv, uv), .5)));\n    if(d < 0.001) {\n         vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                             e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));    \n       \n        vec3 l = normalize(lp-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n        \n        float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n\n        float ao = calcAO(p, n);\n\n        {\n        n = abs(n);\n      \n        if(n.z > n.x && n.z > n.y) {\n             UV = P.xy/vec2(iResolution.x/iResolution.y, 1.);\n            vec2 tuv = UV*(.1+0.5*pow(0.1*tt, 0.5)) +.5;\n            al = texture(iChannel0, tuv).rgb;\n            al = clamp(al, vec3(0), vec3(1));\n            col +=  al*dif + .3*spe + .3*sss + .1*dif;\n            col = mix(col, bg, 1.-exp(-mix(.001, .01, S(0., 1.))*t*t));\n        } else {\n            al = vec3(0.012,0.325,0.388)*.3;\n            \n       \n            UV = P.yz/vec2(iResolution.x/iResolution.y, 1.);\n            vec2 tuv = UV*1.5;\n            al = mix(al, 1.-texture(iChannel0, tuv, 0.1).rgb, 1.);\n            al = clamp(al, vec3(0), vec3(1));\n            \n            col =  1.8*al*(.3+.8*spe+(.9*dif+1.5*sss));\n\n            rd = reflect(rd, n);\n\n\n            vec3 refl = texture(iChannel1, rd, 5.).rgb;\n\n            col = mix(col, refl, .4);\n\n            col = mix(col, bg, 1.-exp(-3.*t*t));\n        }\n        \n        col = clamp(col, vec3(0), vec3(1));\n        col *= (1.-ao);\n\n      }  \n      \n    } else {\n        col = bg;\n    }\n\n    col = clamp(col, vec3(0), vec3(1));\n    col *= mix(0.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n\n    // Output to screen\n    fragColor = vec4(col, 1.0 - t * 0.3);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// based on https://www.shadertoy.com/view/dllcDM\n\n#define SIN(x) (.5+.5*sin(x))\n\nvec3 pal(float t) {\n\n    vec3 a = vec3(.6);\n    vec3 b = vec3(1.);\n    vec3 c = vec3(.5);\n    vec3 d = vec3(0.161,1.000,0.902);\n    \n   // vec3 d = vec3(0.216,0.14,0.545);\n    return a + b*cos(6.283*(c*t+d));\n}\n\n// chebyshev distance\nfloat d2(vec2 v, float k) {\n    return pow(pow(abs(v.x), k)+pow(abs(v.y), k), 1./k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    \n    vec2 uv0 = uv;\n    vec2 uv2 = uv;\n\n    vec3 col = vec3(0);\n    \n    float z = 0.;\n    for(float i=0.; i< 8.; i++) {\n    \n        uv = fract(uv*(1.4-z))-.5;\n        uv2 = fract(uv2*(1.+.5*sin(iTime*.1)+z))-.5;\n        \n        vec3 c = pal(length(uv0) + iTime*.4 + i*.4);\n        \n        float d = (d2(uv, 1.2)+length(uv2)*exp(-length(uv0)));\n        \n        d = abs(.1*d+sin(d*8.+iTime)/8.);\n\n        d = .1*pow(0.02/d, 1.2) + smoothstep(.02, .0, d);\n        col += c*d;\n    \n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}