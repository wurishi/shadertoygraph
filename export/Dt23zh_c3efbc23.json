{"ver":"0.1","info":{"id":"Dt23zh","date":"1672984178","viewed":97,"name":"Atomic Model","username":"nethe550","description":"A simplified model of an atom.\n\nThis isn't realistic at all, simply just a pleasant animation.\n\n(There's an issue with the ellipse SDF causing some undefined results for certain pixels at certain orientations, causing mild line segmentation.)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","simulation","model","ellipse","atom","sim","atomic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// uncomment this to show ellipse foci.\n// #define SHOW_FOCI\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 ndc = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float scene = 0.0;\n    \n    const float semiMajor = 0.5;\n    \n    for (int i = 0; i < 3; i++) {\n        vec2 axes = vec2(semiMajor, (sin(iTime + PI * ONE_SIXTH * float(i)) * 0.5 + 0.5) * (0.35 - ONE_SIXTH) + ONE_SIXTH);\n        vec2 ellipseNDC = rotate(ndc, iTime + PI * ONE_THIRD * float(i));\n        float ellipse = sdfEllipseOutline(ellipseNDC, axes, 0.0075);\n        #ifdef SHOW_FOCI\n            vec4 foci = ellipseFoci(axes);\n            float fociSDF = sdfCircleOutline(abs(ellipseNDC) + foci.xy, 0.0125, 0.0075);\n            ellipse = max(ellipse, fociSDF);\n        #endif\n        scene = max(scene, ellipse);\n    }\n    \n    vec2 seed = vec2(iTime);\n    float center = sdfCircle(ndc + vec2(snoise(seed) * 2.0 - 1.0, snoise(seed + iTime) * 2.0 - 1.0) * 0.01, 0.033);\n    for (int i = 0; i < 6; i++) {\n        vec2 pos = rotate(ndc + vec2(0.0, 0.05), vec2(0.0, 0.05), float(i) + ONE_SIXTH);\n        vec2 offset = vec2(snoise(seed + float(i)) * 2.0 - 1.0, snoise(seed + iTime + float(i)) * 2.0 - 1.0) * 0.01;\n        center = min(center, sdfCircle(pos + offset, 0.033)); \n    }\n    \n    scene = max(scene, smoothstep(3.0 / iResolution.y, 0.0, center));\n    \n    \n    vec3 bg = vec3(snoise(-ndc - iTime * 0.05) * 1.25, snoise(-ndc + iTime * 0.1 - ONE_SIXTH), snoise(-ndc - iTime * 0.1 + ONE_THIRD) * 2.5) * 0.2 + 0.4;\n    vec3 color = scene * (0.5 + 0.5 * cos(0.5 * iTime + ndc.xyx + vec3(0.0, 2.0, 4.0))) + bg * 0.05;\n    \n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358979846264;\nconst float ONE_THIRD = 1.0 / 3.0;\nconst float ONE_SIXTH = 1.0 / 6.0;\n\nvec2 rotate(in vec2 p, in vec2 o, in float a) {\n    p -= o;\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(\n        c * p.x - s * p.y,\n        c * p.y + s * p.x\n    ) + o;\n}\n\nvec2 rotate(in vec2 p, in float a) {\n    return rotate(p, vec2(0), a);\n}\n\nfloat sdfEllipse(in vec2 p, in vec2 axes) {\n    p = abs(p); \n    if(p.x > p.y) { // flip major axis\n        p = p.yx; \n        axes = axes.yx;\n    }\n\t\n    float l = axes.y * axes.y - axes.x * axes.x;\n    float m = axes.x * p.x / l; \n    float m2 = m * m;\n    float n = axes.y * p.y / l;\n    float n2 = n * n;\n    float c = (m2 + n2 - 1.0) * ONE_THIRD;\n    float c3 = c * c * c;\n    float q = c3 + m2 * n2 * 2.0;\n    float d = c3 + m2 * n2;\n    float g = m + m * n2;\n\n    float co;\n\n    if (d < 0.0) {\n        float p = acos(q / c3) / 3.0;\n        float s = cos(p);\n        float t = sin(p) * sqrt(3.0);\n        float rx = sqrt(-c * (s + t + 2.0) + m2);\n        float ry = sqrt(-c * (s - t + 2.0) + m2);\n        co = (ry + sign(l) * rx + abs(g) / (rx * ry) - m) * 0.5;\n    }\n    else {\n        float h = 2.0 * m * n * sqrt(d);\n        float s = sign(q + h) * pow(abs(q + h), ONE_THIRD);\n        float u = sign(q-h)*pow( abs(q-h), ONE_THIRD);\n        float rx = -s - u - c * 4.0 + 2.0 * m2;\n        float ry = (s - u) * sqrt(3.0);\n        float rm = sqrt(rx * rx + ry * ry);\n        float p = ry / sqrt(rm - rx);\n        co = (p + 2.0 * g / rm - m) / 2.0;\n    }\n\n    float si = sqrt(1.0 - co * co);\n \n    vec2 _q = vec2(axes.x * co, axes.y * si);\n\t\n    return length(_q - p) * sign(p.y - _q.y);\n}\n\nfloat sdfEllipseOutline(in vec2 p, in vec2 axes, in float thickness) {\n    float hThickness = thickness * 0.5;\n    float ellipse = sdfEllipse(p, axes);\n    return smoothstep(-hThickness, 0.0, ellipse) - smoothstep(0.0, hThickness, ellipse);\n}\n\nfloat sdfCircle(in vec2 p, in float radius) {\n    return length(p) - radius;\n}\n\nfloat sdfCircleOutline(in vec2 p, in float radius, in float thickness) {\n    float hThickness = thickness * 0.5;\n    float circle = sdfCircle(p, radius);\n    return smoothstep(-hThickness, 0.0, circle) - smoothstep(0.0, hThickness, circle);\n}\n\nfloat ellipseEccentricity(in vec2 axes) {\n    // sqrt(1 - a^2 / b^2)\n    return sqrt(1.0 - (axes.y * axes.y) / (axes.x * axes.x));\n}\n\nvec4 ellipseFoci(in vec2 axes) {\n    float mAxis = max(axes.x, axes.y);\n    float mAxisE = ellipseEccentricity(axes) * mAxis;\n    return (mAxis == axes.x) ? vec4(-mAxisE, 0.0, mAxisE, 0.0) : vec4(0.0, -mAxisE, 0.0, mAxisE);\n}\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+10.0)*x);\n}\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n  \n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}","name":"Common","description":"","type":"common"}]}