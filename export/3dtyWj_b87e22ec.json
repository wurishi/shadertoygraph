{"ver":"0.1","info":{"id":"3dtyWj","date":"1601749379","viewed":113,"name":"watching cloud","username":"danhel95","description":"trying pseudo marching clouds mechanism with a small noise function","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","tutorial","cloud","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Learning tutorial 13\n//pseudo cloud marching mechanism\n// based on Shane small noise and Hazel.\n\n\n// use the mouse to oriente the face :)\n\n\n\n#define ZERO min(iFrame,0)\n\n\n\nobj scene( vec3 p )\n{\n\n    vec3 q = p*3.;\n    float t = iTime;\n     q -=  1.0 * sin(.2*vec3(t, .0, t)) ;\n    vec3 vc = vec3(.8+.1*sin(1.*t -.5),.01 ,.7) ;\n    vec3 pt = vec3(.0,-1. , .0 ) ;\n    float f = N31(q);\n    f *= .02;\n    float s0 = sphere(p , vec3(.0,1.,-1.5) , .3+.2*sin(.4*t));\n    float s1 = sphere(p , vec3(.0,1.,1.5) , .3+.2*sin(.4*t));\n    float b = box(p , vec3(.0,-1.5,0.) , vc,.0);\n    s0 = smin(s0 ,s1, 1.5) ;\n    b = smin(b ,s0, .5) ;\n    p.yx *= R2(.5*t);\n    float g = torus(p , pt , vec2(4.,.01 ));\n    g = smin(g ,b, 2.) ;\n    f += g *.1;\n    cld.sdi.x = f ;\n    return cld;;\n}\n\n\nvec3 render(ray r) {\n\n    float rd = 6.  ,t = iTime*.25;\n    vec3 sp = vec3(rd*cos(1.5*t), .5, rd*sin(t));\n    yellow = star(sp, vec3(1.,1.,.2), 1. );\n    const float d = 1.5;\n    const float s = .1;\n    float vis = 1.;\n    float light = 0.;\n    vec3 p = r.o  ;\n    vec3 lp = normalize(yellow.pos-p);\n    obj ob  , dob ;\n    vec3 color = vec3(0.);\n    float vs = .0  ;\n\n\n    for ( float i= .0; i < 1.; i+=1./ITR )\n    {\n        ob = scene(p) ;\n        float h = ob.sdi.x;\n        lp = normalize(yellow.pos-p);\n        vs = smoothstep(EPSILON,s,h);\n        h = max(h,EPSILON);\n        if ( vs < 1. )\n        {\n            float nvis = vis * pow(vs,h*d);\n            float k = scene(p+ lp * s).sdi.x ;\n            light += (vis - nvis) * smoothstep( -1., 1., (k - h) );\n            vis = nvis;\n        }\n\n        if ( vs <= 0. ) break;\n        ob.sdi.y += h ;\n        p += h*r.d;\n\n    }\n\n\n    color += .5*vec3(.1,.1,2.) * pow( yellow.col,vec3(.25));\n    vec3 res = vec3(light) ;\n    color = mix(res ,  color , vis);\n    return color ;\n\n}\n\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec2 ms = iMouse.xy/R ;\n    vec2 uv = (U.xy-.5*R.xy)/R.y;\n    ray r = raydir(uv,ms);\n    o.rgb = render(r);\n    o = pow(o,vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 50.\n#define SURF 1e-3\n#define FAR 60.\n#define REFSTEP 2.\n#define pow(a,b) pow(abs(a),(b))\n\nstruct star{ vec3 pos; vec3 col; float rad; };\nstruct ray { vec3 o; vec3 d; vec3 t; float zoom; };\nstruct material { vec3 col;\n    vec3 ads; // amb, diff, spec\n    vec3 stg; // shiness , transparency,glow\n};\n\nstruct obj\n{\n    vec3 sdi ; // dS , d , id\n    material mtr;\n};\n\nvec3 normal;\nray r ;\nstar yellow;\n\n\nobj cld = obj(vec3(FAR , 0.,  0.),\n    material(vec3(1.,1.,1.),vec3(.5, 1., 3.), vec3(100.,.5,1.)));\n\n\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); \n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); \n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.; ray r ; r.zoom = 1.;\n    r.o = vec3(0., 6., 10.); r.t = vec3(.5);\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI/2.);\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat torus( in vec3 p, vec3 pos, vec2 rad )\n{\n    p = p - pos ;\n    return length( vec2(length(p.xz)-rad.x,p.y) )-rad.y;\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b,float r) {\n    vec3 d = abs(p-pos) - b;\n    return  length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.) - r ;\n}\n\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    return length(p-pos) - r ;\n\n}\n\n\nobj suop(in obj a, in obj b, float k)\n{\n    obj o;\n    if (a.sdi.x < b.sdi.x) o = a; else o = b;\n    float h = clamp( 0.5+0.5*(b.sdi.x-a.sdi.x)/k, 0.0, 1.0 );\n    o.sdi.x = mix( b.sdi.x, a.sdi.x, h ) - k*h*(1.0-h);\n    return o;\n\n}\n\n\n\nfloat N31(vec3 p){\n\n\tvec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n    p = p*p*(3. - 2.*p);\n\th = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n\n}\n\n","name":"Common","description":"","type":"common"}]}