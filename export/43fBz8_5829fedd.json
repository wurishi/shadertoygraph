{"ver":"0.1","info":{"id":"43fBz8","date":"1727978108","viewed":20,"name":"ghh ripples","username":"garrisonhh","description":"uses white noise to warp a view of  itself iteratively","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","text","warp","iterations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\n#define PI      3.1415926538\n#define TAU     (2.0 * PI)\n\n/* === text === */\n\n// input units are in pixels\nfloat drawCharacter(vec2 fragCoord, float x, float y, float fontSize, lowp uint id) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = vec2(x, iResolution.y - y - fontSize) / iResolution.xy;\n    vec2 size = vec2(fontSize) / iResolution.xy;\n\n    // find source sample\n    id = (id % 16u) + (15u - (id / 16u)) * 16u;\n    float idf = float(id) / 16.0;\n    vec2 srcPos = vec2(\n        fract(idf),\n        fract(floor(idf) / 16.0)\n    );\n    vec2 srcOffset = ((uv - pos) / size) * vec2(1.0 / 16.0);\n\n    float fontSample = texture(iChannel0, srcPos + srcOffset).r;\n\n    // bound sample to single character\n    float bounded =\n        step(pos.x, uv.x) *\n        step(pos.y, uv.y) *\n        step(uv.x - size.x, pos.x) *\n        step(uv.y - size.y, pos.y);\n\n    return bounded * fontSample;\n}\n\n/*\n * helpful python oneliner lambda for generating uint text arrays:\n * `convert = lambda str: \"uint[](\" + \", \".join(map(lambda x: f\"{ord(x)}u\", str)) + \")\"`\n */\nfloat drawAllText(vec2 fragCoord) {\n    float text = 0.0;\n    \n#define DRAW_TEXT(POS, FONTSIZE, TEXT, LEN) \\\n    { \\\n        float fontSize = FONTSIZE; \\\n        vec2 pos = POS; \\\n        float offset = 0.0; \\\n        for (uint i = 0u; i < LEN; ++i) { \\\n            float c = drawCharacter(fragCoord, pos.x + offset, pos.y, fontSize, TEXT[i]); \\\n            text = max(text, c); \\\n            offset += fontSize * 0.5; \\\n        } \\\n    }\n    \n    \n    const uint ripplesLen = 7u;\n    const lowp uint ripples[ripplesLen] = uint[](114u, 105u, 112u, 112u, 108u, 101u, 115u);\n    DRAW_TEXT(iResolution.xy - vec2(90.0, 30.0), 20.0, ripples, ripplesLen);\n\n#undef DRAW_TEXT\n\n    return text;\n}\n\n\n/* === oklab === */\n\n// taken from https://www.shadertoy.com/view/WtccD7\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n\n    return mix(xlo, xhi, step(vec3(0.04045), x));\n}\n\nconst mat3 fwdA = mat3(\n    1.0, 1.0, 1.0,\n    0.3963377774, -0.1055613458, -0.0894841775,\n    0.2158037573, -0.0638541728, -1.2914855480\n);\nconst mat3 fwdB = mat3(\n    4.0767245293, -1.2681437731, -0.0041119885,\n    -3.3072168827, 2.6093323231, -0.7034763098,\n    0.2307590544, -0.3411344290,  1.7068625689\n);\nconst mat3 invB = mat3(\n    0.4121656120, 0.2118591070, 0.0883097947,\n    0.5362752080, 0.6807189584, 0.2818474174,\n    0.0514575653, 0.1074065790, 0.6302613616\n);\nconst mat3 invA = mat3(\n    0.2104542553, 1.9779984951, 0.0259040371,\n    0.7936177850, -2.4285922050, 0.7827717662,\n    -0.0040720468, 0.4505937099, -0.8086757660\n);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n    vec3 lms = invB * c;\n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n    vec3 lms = fwdA * c;\n    return fwdB * (lms * lms * lms);\n}\n\nvec3 oklab_from_srgb(vec3 c) {\n    return oklab_from_linear_srgb(linear_srgb_from_srgb(c));\n}\n\nvec3 srgb_from_oklab(vec3 c) {\n    return srgb_from_linear_srgb(linear_srgb_from_oklab(c));\n}\n\nvec3 mix_srgb(vec3 a, vec3 b, float x) {\n    vec3 a_lab = oklab_from_srgb(a);\n    vec3 b_lab = oklab_from_srgb(b);\n    vec3 mixed = mix(a_lab, b_lab, x);\n    return srgb_from_oklab(mixed);\n}\n\n/* === noise === */\n\nfloat hashVec2(vec2 pos) {\n    return fract(sin(dot(pos, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat slerp(float a, float b, float x) {\n    x = clamp(x, 0.0, 1.0);\n    return a + (b - a) * ((1.0 - cos(x * PI)) / 2.0);\n}\n\nfloat valueNoise(vec2 pos, vec2 kernelSize) {\n    vec2 pixel = pos / kernelSize;\n    vec2 pixelFloor = floor(pixel);\n\n    float a = hashVec2(pixelFloor);\n    float b = hashVec2(pixelFloor + vec2(1.0, 0.0));\n    float c = hashVec2(pixelFloor + vec2(0.0, 1.0));\n    float d = hashVec2(pixelFloor + vec2(1.0, 1.0));\n\n    vec2 pixelFract = abs(fract(pixel));\n    float interpolated = slerp(\n        slerp(a, b, pixelFract.x),\n        slerp(c, d, pixelFract.x),\n        pixelFract.y\n    );\n\n    return interpolated;\n}\n\nfloat fluidNoise(vec2 pos, vec2 kernelSize, float t) {\n    float tA = t;\n    float tB = t + 1.0;\n    float tC = t + 2.0;\n    float tD = t + 3.0;\n\n    float a = valueNoise(pos + vec2(tA, tA), kernelSize);\n    float b = valueNoise(pos + vec2(tB, -tB), kernelSize);\n    float c = valueNoise(pos + vec2(-tC, tC), kernelSize);\n    float d = valueNoise(pos + vec2(-tD, -tD), kernelSize);\n\n    return (a + b + c + d) / 4.0;\n}\n\nfloat warpingFluidNoise(vec2 pos, vec2 kernelSize, float t, float jump, int iterations) {\n    for (int i = 0; i < iterations; ++i) {\n        float noise = fluidNoise(pos, kernelSize, t);\n        float angle = noise * TAU;\n        pos += vec2(cos(angle), sin(angle)) * jump;\n    }\n\n    return fluidNoise(pos, kernelSize, t);\n}\n\n/* === */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float text = drawAllText(fragCoord);\n    vec3 textColor = vec3(0.0);\n    \n    vec2 kernelSize = vec2(min(iResolution.x, iResolution.y) / 16.0);\n    float jump = distance(kernelSize, vec2(0.0)) * 0.5;\n    float noise = warpingFluidNoise(fragCoord, kernelSize, iTime * 10.0, jump, 15);\n    \n    vec3 colA = vec3(1.0, 0.0, 0.0);\n    vec3 colB = vec3(0.0, 1.0, 0.0);\n    vec3 colC = vec3(0.0, 0.0, 1.0);\n    vec3 noiseColor = mix_srgb(colB, colC, noise);\n\n    vec3 finalColor = mix(noiseColor, textColor, text);\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}