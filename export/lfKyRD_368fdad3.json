{"ver":"0.1","info":{"id":"lfKyRD","date":"1731680286","viewed":63,"name":"iterative gradient","username":"hakrackete","description":"planets and colors\ndependant on resolution","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"X3sBDn","parentname":"something fractal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N_ATT 4\n\nstruct Att{\n    vec2 pos;\n    vec3 color;\n    float mass;\n    };\n    \n\nvoid drawAttractor(in vec2 fragCoord,Att att, inout vec3 col){\n    if (distance(att.pos,fragCoord) < 10.0){\n        col =  att.color;\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float delta = 10.0;\n    vec3 c1 = vec3(253.0,235.0,210.0)/255.0;\n    vec3 c2 = vec3(249.0,163.0,101.0)/255.0;  \n    vec3 c3 = vec3(248.0,118.0,67.0)/255.0;  \n    vec3 c4 = vec3(175.0,79.0,65.0)/255.0;  \n    vec3 c5 = vec3(39.0,50.0,72.0)/255.0;  \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    Att myMouse;\n    myMouse.pos = iMouse.xy;\n    //myMouse.pos = iResolution.xy * vec2(0.25,0.75);\n    myMouse.color = vec3(1.0,0.0,0.0);\n    //myMouse.color = c2;\n    \n    myMouse.mass = 3.0;\n    \n    Att green;\n    green.pos = iResolution.xy * vec2(0.75,0.75);\n    green.color = vec3(0.0,1.0,0.0);\n    green.color = c3;\n    \n    green.mass = 10.0;\n    \n    \n    Att blue;\n    blue.pos = iResolution.xy * vec2(0.25,0.25);\n    blue.color = vec3(0.0,0.0,1.0);\n    blue.color = c5;\n    \n    blue.mass = 20.0;\n    \n    \n    Att yellow;\n    yellow.pos = iResolution.xy * vec2(0.75,0.25);\n    yellow.color = vec3(0.0,0.0,0.0);\n    //yellow.color = c5;\n    \n    yellow.mass = 10.0;\n    \n    int num = N_ATT;\n    //Att attArray[N_ATT] = Att[N_ATT](myMouse,green,blue);\n    Att attArray[N_ATT] = Att[N_ATT](myMouse,yellow,blue,green);\n    \n    \n\n    vec3 col;\n\n    \n    vec2 location = fragCoord.xy;\n    \n    float greatest_dist = 0.0;\n    int closest_count[N_ATT];\n    \n    for (int i = 0; i < N_ATT; i++){\n        closest_count[i] = 0;\n    }\n    int iterations;\n    iterations = int(iTime * 10.0);\n    //iterations = int(200.0/delta);\n    //iterations = 13;\n    \n    \n    vec2 vel = vec2(0.0);\n    for(int i = 0; i < iterations; i++){\n        vec2 direction = vec2(0.0);\n        for (int j = 0; j < num; j++){\n            \n            float dist = max(1.0,distance(location,attArray[j].pos));\n            float F = (1.0 * attArray[j].mass) / (pow(dist,0.3));\n            direction += F * normalize(attArray[j].pos - location);\n        }\n        // direction *= 0.999;\n        \n        int max_index = 0;\n        float greatest_dist = -1.0;\n        vel += (direction* delta);\n        location += vel * delta;\n        \n        for (int j = 0; j < num; j++){\n            float dist = distance(location,attArray[j].pos);\n            if(dist< greatest_dist || greatest_dist <= 0.0){\n                max_index = j;\n                greatest_dist = dist;\n            }\n        }\n        closest_count[max_index] += 1; \n        \n    }\n    \n    \n    for (int j = 0; j < num; j++){\n        col += (float(closest_count[j]) / float(iterations)) * attArray[j].color ;\n    }\n\n    for (int i = 0; i < num; i++){\n        //drawAttractor(fragCoord,attArray[i],col);\n        }\n    fragColor = vec4(col,1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}