{"ver":"0.1","info":{"id":"ss3SR8","date":"1633707286","viewed":66,"name":"armillary sphere","username":"Aiibow","description":"implement armillary by raymarching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define EPS 0.001\n\n#define AA 2\n\nvec3 lightDir = normalize(vec3(1.,1., 1));\n\nfloat dRing(vec3 p, float exR, float inR, float thick){\n\tfloat sdf2d = abs(length(p.xy)-exR)-inR;\n\tfloat d = abs(p.z)-thick;\n\treturn max(sdf2d, d);\n}\n\nfloat dSphere(vec3 p, float r){\n    vec3 sphere = vec3(0.);\n    \n    return length(p - sphere) - r;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat getDist(vec3 p){\n\tvec3 q=p,r = p,po = r;\n    float time = iTime;\n\tp.xy *= rot(time*.5);\n\tp.xz *= rot(time*.3);\n\tfloat ring1 = dRing(p, .8, .02, .03);\n\tq.xy *= rot(time*-1.3);\n\tq.xz *= rot(time*-1.);\n\tfloat ring2 = dRing(q, .74, .02, .03);\n\tr.yz *= rot(time*2.);\n\tr.xz *= rot(time*-2.);\n\tfloat ring3 = dRing(r, .70, .02, .03);\n    \n    float d = min(ring1, min(ring2, ring3));\n    float factor = sin(time) * 0.5 + 0.5;\n    float blender = mix(dSphere(po, .5),dBox(po, vec3(0.3)), factor); // sphere to box\n    po.yz *= rot(time*.5);\n    blender = mix(sdTorus(po, vec2(0.3,.05)),dSphere(po, .5), factor);\n    d = min(blender, d);\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n    float d = getDist(p);\n\treturn normalize(d - vec3(\n\t\tgetDist(vec3(p.x-EPS, p.yz)),\n\t\tgetDist(vec3(p.x, p.y-EPS, p.z)),\n\t\tgetDist(vec3(p.xy, p.z-EPS))\n\t\t));\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        rd = normalize(i-p);\n    return rd;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float curDist = 0.;\n\n    for(int i = 0; i <100;i++){\n\t\tvec3 p = ro + rd * curDist;\n        float dS = abs(getDist(p));\n        if(dS < EPS || dS > 100.){\n            break;\n        }\n        curDist += dS;\n\t}\n    \n    return curDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 tot = vec3(0.);\n// MSAA\n#if AA > 1\n    for (int i = 0; i < AA; i++)\n    for (int j = 0; j < AA; j++){\n    \n    vec2 o = vec2(float(i), float(j)) / float(AA) - 0.5;\n    vec2 uv = ((fragCoord.xy + o)*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n#else\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n#endif\n\n\tvec3 col = vec3(.1, 0.3, clamp(uv.y, 0., 1.) + 0.5);\n\tvec3 ro = vec3(0.,0,10.);\n\tvec3 rd = R(uv, ro, vec3(0.,0.,0.), 10.);\n    \n    float d = rayMarch(ro, rd);\n    if (d < 100.){\n        vec3 p = ro + rd * d;\n        vec3 normal = getNormal(p);\n        col = vec3(.5, .35, .05);\n        col+= dot(normal, lightDir)+vec3(.1);\n    }\n    col = pow(col, vec3(0.4545));\n    \n    tot += col;\n    \n#if AA > 1\n    }\n    tot /= float(AA * AA);\n#endif\n\n\tfragColor = vec4(tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}