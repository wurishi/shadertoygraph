{"ver":"0.1","info":{"id":"fsKSDt","date":"1635514674","viewed":215,"name":"Spectral Bar","username":"antone","description":"Spectral Colors","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["color","grain","spectral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define MIN_MARCH_DIST 0.0001\n#define MAX_MARCH_STEPS 500\n#define MAX_VOLUME_STEPS 5000\n#define VOLUME_STEP_SIZE 0.01\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nvec4 Volume(vec3 pos)\n{\n    float rand = 80.;\n    \n    //float vol = dot(normalize(pos),vec3(1,1,1));\n    float vol = normalize(pos.x);\n    vec3 col = mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),step(0.0,vol));\n    \n    vol = smoothstep(0.6,1.0,abs(vol));\n    \n \n\t//return vec4(snoise(vec2(1.0,pos.x)));\n    //float noise = (1.0/(1.0+exp(-2.*snoise(vec2(pos.x/6.-rand)))) - 0.5 ) * 2.0;\n    //noise -=  (1.0/(1.0+exp(-2.*snoise(vec2(pos.x/5.-rand)))) - 0.5 ) * 2.0;\n    //noise *=7.;\n    //noise = clamp(noise,0.0,1.0);\n    return vec4(spectral_zucconi((pos.x/3.+1.0)/2.0*200.0+450.0),clamp(0.12-length(vec2(pos.y,pos.z)/8.),0.0,1.0));\n    //return vec4(1.0,1.0,1.0,0.0002);\n}\n\nvec3 MarchVolume(vec3 orig, vec3 dir)\n{\n    //Ray march to find the cube surface.\n    float t = 0.0;\n    vec3 pos = orig;\n    for(int i = 0;i < MAX_MARCH_STEPS;i++)\n    {\n        pos = orig + dir * t;\n        float dist = 100.0;\n        \n        dist = min(dist, 12.0-length(pos));\n        dist = min(dist, max(max(abs(pos.x/5.),abs(pos.y)),abs(pos.z))-1.0);//length(pos)-1.0);\n        \n        t += dist;\n        \n        if(dist < MIN_MARCH_DIST){break;}\n    }\n    \n    //Step though the volume and add up the opacity.\n    vec4 col = vec4(0.0);\n    for(int i = 0;i < MAX_VOLUME_STEPS;i++)\n    {\n    \tt += VOLUME_STEP_SIZE;\n        \n    \tpos = orig + dir * t;\n        \n        //Stop if the sample becomes completely opaque or leaves the volume.\n        if(max(max(abs(pos.x/5.),abs(pos.y)),abs(pos.z))-1.0 > 0.0) {break;}\n        \n        vec4 vol = Volume(pos);\n        vol.rgb *= vol.w;\n        \n        col += vol;\n        //col = clamp(col,0.0,1.0);\n    }\n    \n    col.rgb = (1.0/(1.0+exp(-0.3*col.rgb)) - 0.5 ) * 2.0;\n    \n    return col.rgb;///2.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv-res/2.0,1.0));\n    vec3 orig = vec3(0,0,-9.5);\n\n        \n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n\n    \n    vec3 color = MarchVolume(orig,dir);\n    vec2 seed = fragCoord.xy;\n    float x = (seed.x / 3.14159 + 4.) * (seed.y / 13. + 4.) * ((fract(iTime) + 1.) * 10.);\n    float grain = mod((mod(x, 13.) + 1.) * (mod(x, 123.) + 1.), 0.01) - 0.005;\n\n    \n\tfragColor = grain*20. + vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}