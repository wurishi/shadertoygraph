{"ver":"0.1","info":{"id":"WtlSWf","date":"1564492417","viewed":220,"name":"Refractive Volumetric Marble","username":"peet","description":"Click the mouse and drag to be in control of camera. Click on left side to relinquish control.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["noise","refraction","sphere","volumetric","cubemap","marble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n\n// comment me out if you need some more FPS!\n#define HIGHER_QUALITY\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MARCH_ITERATIONS \t250\n#define MARCH_DELTA\t\t\t0.005\n#define MARCH_DELTA2\t\t1.01\n#define START_DIST \t\t\t3.5\n    \n///////////////////////////////////////////////////////////////////////////////////\n\nMaterial g_NoMaterial = Material(vec3(1.0, 0.0, 1.0), 0.0, 1.0);\nResult g_result;\n    \n///////////////////////////////////////////////////////////////////////////////////\n\nconst int lightarraysize = 2;\nconst int numlights = 1;\nLight g_lights[lightarraysize];\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's noise functions\n\nfloat noise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    //f = (f*f*(3.0-2.0*f)+f)*0.5;\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat mist(vec3 p, int LOD)\n{   \n    vec3 p2 = p;\n    p *= 2.25;\n    float weight = 0.25;\n    float totalweight = 0.0;\n    float value = 0.0;\n    for (int i=0; i<LOD; i++)\n    {\n        totalweight += weight;\n        value += noise2(p)*weight;    \n        p *= 2.03;\n        weight *= 0.7;\n    }\n    \n    if (length(p2-vec3(0.0, 0.0, 0.0)) > 2.5)\n        return 0.0;\n        \n    return 0.01 + value/totalweight;\n}\n\nResult raymarch_query(inout Ray ray, int iterations, float delta)\n{\n    Result result = Result(ray.pos+ray.dir*10000.0, vec3(0.0, 0.0, 0.0), g_NoMaterial, vec4(0.0, 0.5, 0.0, 0.0));    \n    float dist = 0.0;\n    float fog=0.0;\n    float dstalpha = 0.0;\n    float srcalpha = 0.0;\n    const float densitythreshold = 0.70;\n    const float densityscale = 100.0/(1.0-densitythreshold);\n    const float lightstep = 0.6;\n    const float lightatten = 1.0 / (sqrt(lightstep)*1.8);\n    \n    vec3 lighting = vec3(-1.0, -1.0, 1.0);\n    lighting = normalize(lighting);\n    \n    float time = iTime + 1.5;\n    float material = sin(time*0.5);\n    float transtint = 1.0;\n    float opaquetint = 0.0;\n    \n\tfor (int i=0; i<iterations; i++)\n    {        \n\t\tfloat v = mist(ray.pos, 3);\n        vec3 colour = vec3(0.0);\n        float density = 0.0;\n        if (v>0.2)\n        {\n\t\t\tcolour = mix(vec3(0.2, 1.0, 0.7)*sqrt(transtint), vec3(1.0, 1.0, 1.0)*sqrt(opaquetint), v);\n\t\t\t//colour = mix(vec3(0.0), vec3(1.0), v);\n            \n            vec3 norm=vec3(mist(ray.pos+vec3(0.2, 0.0, 0.0), 3), \n                           mist(ray.pos+vec3(0.0, 0.2, 0.0), 3), \n                           mist(ray.pos+vec3(0.0, 0.0, 0.2), 3));\n            norm=normalize(norm);\n            \n            density = (v-0.6)*2.0;            \n            \n            vec3 reflected = reflect(ray.dir, norm);\n            colour += texture(iChannel1, reflected).xyz*1.7*(1.0-dstalpha);\n            \n            vec3 refracted = refract(ray.dir, norm, 1.0);\n            ray.dir = mix(ray.dir, refracted, 0.01);\n            ray.dir=normalize(ray.dir);\n            \n            // density is the value times the step       \n            density*=clamp(delta*10.0, 0.0, 1.0);\n            // update the alpha\n            srcalpha = density;\n\n            if (srcalpha>0.01)\n            {                \n                // modify the destingation alpha, based on the current srcalpha\n                float prevdstalpha = dstalpha;\n                dstalpha = dstalpha + srcalpha*(1.0 - dstalpha);\n                result.fog.xyz = mix(colour, result.fog.xyz, prevdstalpha/dstalpha);\n            }\n            if (dstalpha>0.95)\n            {\n                result.fog.w = dstalpha;\n                return result;            \n            }            \n        }\n             \n        ray.pos += ray.dir*delta;\n        delta*=MARCH_DELTA2;\n    }\n            \n   \tresult.fog.w = dstalpha;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 raymarch(Ray inputray, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;    \n    \n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    Ray ray=inputray;        \n    g_result = raymarch_query(ray, MARCH_ITERATIONS, MARCH_DELTA);\n    colour = mix(texture(iChannel1, ray.dir).xyz, g_result.fog.xyz, g_result.fog.w);       \n        \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    Ray ray;\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    float time = iTime;    \n    vec3 p0, p1;\n    \n    vec3 stick;\n    vec2 sunVec;\n    if (iMouse.x<20.0)\n    {\n        stick = vec3(0.5 + sin(time*0.5)*0.5, -0.25 + cos(time*0.35)*0.5, -1.0);        \n    }    \n    else\n    {\n\t\tstick = vec3(iMouse.x/iResolution.x, iMouse.y/iResolution.y - 0.5, -1.0);        \n    }\n    \n    stick = normalize(stick);\n    p0=stick*6.0;\n    p1=vec3(0.0, 0.0, 0.0);\n    //ViewVector(time, p0, p1); \n        \n    vec3 dir = (p1-p0);\n    dir = normalize(dir);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    up = normalize(up);\n    vec3 right = cross(dir, up);\n    right = normalize(right);\n    up = cross(right, dir);\n    up = normalize(up);\n    \n    ray.pos = p0;\n    ray.dir = dir*1.0 + up*uv.y + right*uv.x;\n    ray.dir = normalize(ray.dir);\n        \n    ray.pos += ray.dir*START_DIST;\n            \n    fragColor.xyz = vec3(0.0);        \n    fragColor.xyz += raymarch(ray, fragCoord); \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n    vec4 fog;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\nvoid ViewVector(in float time, out vec3 p0, out vec3 p1)\n{\n    float ft = time-1.0;\n\tp0 = vec3(4.0 - perlin(ft*0.25, 7.5)*8.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0);  \n    ft+=0.5;\n\tp1 = vec3(4.0 - perlin(ft*0.25, 7.5)*8.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0); \n}","name":"Common","description":"","type":"common"}]}