{"ver":"0.1","info":{"id":"fttBW8","date":"1663041158","viewed":79,"name":"two beans vibing","username":"heccyeah","description":"Submission usage for CS4710","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["beans"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Object bases (subtracting a sphere from a chainlink)\n//https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s){\n    return length(p) - s;\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n// Rotation Animation as demonstrated in CS4710\nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc,   0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts,   0.0, c\n\t);\n}\n\n// Does the ray hit anything in the scene?\nbool ifRayHits(vec3 eye, vec3 dir, out vec3 outPos){\n\n    float t = 0.0;\n    for (int i = 0; i < 50; i++){\n    \n    // Calculate the positions from view rays\n    vec3 pos = eye + dir * t;\n    \n    // Get distance from positions to spheres and chain links\n    float dist = opSmoothSubtraction(\n                    sdSphere(rotateY(iTime)*pos, 5.0f),\n                    sdLink(rotateY(iTime)*pos, 4.2f, 3.0f, 3.0f),\n                    3.5);\n                    \n                    \n    // Check if ray is hit\n    if (dist < 0.001){\n        outPos = pos;\n        return true;\n    }\n    t += dist;\n}\nreturn false;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5,0.64);\n\n    // Set Background Color\n    vec3 col = texture(iChannel1, uv+vec2(0.5) +vec2(iTime/10.0)).rrr;\n    \n    // Value Initializations\n    vec3 pos, posdy, posdx;\n    vec3 dir = normalize(vec3(uv.x, uv.y-0.4, 5));\n    vec3 dirdx = normalize(vec3(uv.x+0.0001, uv.y-0.4, 5));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.0001-0.4, 5));\n    vec3 eye   = vec3(0,11.0,-100);\n    vec3 normal = vec3(0,0,1);\n   \n    if(ifRayHits(eye, dir, pos) &&\n        ifRayHits(eye, dirdx, posdx) &&\n        ifRayHits(eye, dirdy, posdy)){\n        \n        // Find Vector Direction - Slightly downward\n        vec3 CA = normalize(posdy - pos);\n        \n        // Find Vector Direction - Slightly rightward\n        vec3 BA = normalize(posdx - pos);\n        \n        // Calculate Normals\n        normal = cross(CA, BA);\n        // Normal Z-Direction Fix\n        normal.z = -normal.z;\n        \n        // Light direction from mouse position\n        //vec3 lightDir = normalize(vec3(-(iMouse.xy/iResolution.xy- vec2(0.5)),1));\n        vec3 lightDir = normalize(vec3(0.0,1.0,-1.0));\n        \n        //col = normal;\n        col = vec3(abs(cos(iTime/4.0)),mod(normal.z,1.0),1.0 - abs(cos(uv.x * mod(iTime,1.0))))*dot(lightDir,normal);\n        //col = vec3(1.0)*dot(lightDir,normal);\n        //col = vec3(1) + vec3(1) * (clamp(dot(-lightDir,normal) + pow(dot(-dir,reflect(-lightDir,normal)),15.0),0.0,1.0));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col + texture( iChannel0 , vec2(uv.x + sin(iTime), uv.y + cos(iTime))).ggg , 1.0);\n    //+ cos( fragCoord.x + iTime/10.0)\n}","name":"Image","description":"","type":"image"}]}