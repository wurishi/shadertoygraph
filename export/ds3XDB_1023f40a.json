{"ver":"0.1","info":{"id":"ds3XDB","date":"1680349714","viewed":208,"name":"Correct Ellipsoid Soft shadow","username":"Poisson","description":"A new way to make analytical ellipsoid soft shadows, now the penumbra is inside so it's more realistic.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raytracer","shadow","sphere","raytraced","ao","occlusion","aa","ambient","analytical","soft","analytic","pbr","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 4 // antialiasing\n\n// ray ellipsoid intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\n// sph[0] is the center of the ellipsoid\n// sph[1] id the size\nfloat elliIntersect(vec3 ro, vec3 rd, mat2x3 sph) {\n    vec3 oc = ro - sph[0];\n    vec3 r2 = sph[1]*sph[1]; // squared size\n    \n    float a = dot(rd, rd/r2);\n\tfloat b = dot(oc, rd/r2);\n\tfloat c = dot(oc, oc/r2);\n\tfloat h = b*b - a*(c-1.); // discriminant\n    \n\tif (h<0.) return -1.;    \n    return (-b - sqrt(h))/a;\n}\n\n// ellipsoid soft shadow function\n// k is the softness of the shadow\nfloat elliSoftShadow(vec3 ro, vec3 rd, mat2x3 sph, float k) {\n    vec3 oc = ro - sph[0];\n    vec3 r2 = sph[1]*sph[1]; // squared size\n    \n    float a = dot(rd, rd/r2);\n\tfloat b = dot(oc, rd/r2);\n\tfloat c = dot(oc, oc/r2);\n\tfloat h = b*b - a*(c-1.); // discriminant\n    \n    #if 1\n    // semi correct soft shadow, penumbra inside\n    \n    float d = -h/24.; // (fake) distance\n    float t = (-b - sqrt(max(h,0.))) / a; // intersection distance\n            \n    float res = b>0. ? 1. : .5+.5*clamp(k*d/t, -1., 1.);\n    \n    #elif 0\n    // cheap approximation, penumbra inside\n    \n    float res = b>0. ? 1. : .5+.5*clamp(k*h/b, -1., 1.);\n    \n    #elif 0\n    // old way, penumbra outside\n    float d = -h/24.; // distance\n    float t = (-b - sqrt(max(h,0.))) / a; // intersection distance\n    \n    float res = b>0. ? 1. : clamp(k*d/t, 0., 1.);\n    \n    #endif\n    return res*res*(3.-2.*res); // S curve\n}\n\n// ellipsoid occlusion\n// thanks to iq: https://www.shadertoy.com/view/MlsSzn\nfloat elliOcclusion(vec3 p, vec3 n, mat2x3 sph) {\n    vec3 r = (sph[0] - p)/sph[1];\n    float l = length(r);\n    return dot(n,r)/(l*l*l);\n}\n\n// ellipsoid\n                       // center, radius\n                       //   |        |\nconst mat2x3 sph = mat2x3(0,0,0,.15,.5,.4);\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0); // background\n        \n    float t = 1e10; // final distance\n    vec3 n; // normal\n    float occ = 1.; // occlusion\n    \n    // ellipsoid\n    float t1 = elliIntersect(ro, rd, sph);\n    if (t1>0.) {\n        t = t1;\n        vec3 p = ro + rd*t;\n        n = normalize((p - sph[0])/(sph[1]*sph[1]));\n        occ = .5+.5*n.y; // plane occlusion\n    }\n    \n    // plane\n    float t2 = (-.5-ro.y) / rd.y;\n    if (t2>0. && t2<t) {\n        t = t2;\n        vec3 p = ro + rd*t;\n        n = vec3(0,1,0);\n        occ = 1.-elliOcclusion(p, n, sph); // sphere occlusion\n    }\n    \n    if (t<1e10) { // we hit the surface\n        vec3 p = ro + rd*t; // hit point\n        \n        const vec3 lig = vec3(.57735); // light direction\n        float dif = clamp(dot( n, lig), 0., 1.); // diffuse light\n        float bac = clamp(dot(-n, lig), 0., 1.); // bac light\n        float bou = .5-.5*n.y; // bounce light\n        \n        float k = .5+4.*(.5+.5*sin(2.*iTime)); // shadow softness\n        float sha = elliSoftShadow(p, lig, sph, k); // shadow\n        \n        col = vec3(0);\n        col += vec3(1,.8,.6) * dif*sha; // direct light\n        col += .25*vec3(1,.8,.6) * occ*(.5+bac)*bou; // indirect light\n        col += .2*vec3(.3,.6,1) * occ; // sky light\n                \n        col = mix(col, vec3(0), 1.-exp(-t*t*.02)); // fog\n    }\n    \n    return 1.5*col/(1.+col); // tonemapping\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates centered at the origin\n    vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n    \n    float an = .2*iTime + m.x*3.141592; // camera xz rotation\n    vec3 ro = vec3(2.5*sin(an),1,2.5*cos(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 tot = vec3(0); // accumulated color\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n\n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n        vec3 col = render(ro, rd); // render\n\n        col = pow(col, vec3(.4545)); // gamma correction\n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .5+.5*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}