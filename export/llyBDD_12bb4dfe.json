{"ver":"0.1","info":{"id":"llyBDD","date":"1542566209","viewed":88,"name":"WarpingBall","username":"Falko","description":"use mouse to rotate camera","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 v;\nvec3 lightSource = vec3(20.0, 0.0, 6.0);\nfloat bLightSource = 0.6;\nfloat ba = 0.4;\n\nvec2 random2(vec2 st, float n){\n    //computed values have to be n-periodic in y-direction\n    //on both poles of the sphere gradients are identically\n    //set to zero to avoid discontinuity\n    vec2 stPeriodic = vec2(st.x, mod(st.y, n));\n    if(abs(st.x)<=1.01 || abs(st.x-n)<=1.01){\n        return vec2(0.0);\n    }\n    else{\n    //hash function to generate noise\n    stPeriodic = vec2( dot(stPeriodic,vec2(127.1,311.7)),\n              dot(stPeriodic,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(stPeriodic)*43758.177);\n    }\n    \n    }\n\n\n\n\n\nfloat gNoise(vec2 st, float n) {\n    //gradient noise\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0), n), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0), n), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0), n), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0), n), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n\nfloat pi(){\n \treturn radians(180.0);   \n}\n\n\nvec2 intersectCircle(vec2 cp, vec2 rView){\n    //compute p and q from pq-formula\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\nvec2 intersectBall(vec3 cp, vec3 rView){\n    //compute p and q from pq-formula\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\nfloat diffuse(vec3 p, vec3 normal){\n            vec3 dirLight = normalize(lightSource-p);\n            return bLightSource*max(0.0, dot(normal, dirLight));\n    }\n\n\nfloat specular(vec3 normal, vec3 p, vec3 rCamera){\n            vec3 dir_light = normalize(p-lightSource);\n            vec3 dir_reflect = reflect(dir_light, normal);\n            float spec = pow(max(0.0, dot(rCamera, dir_reflect)), 200.0);\n            return spec;\n            \n    }\n\nvec3 chess(vec3 p, vec3 pFrag){\n    //computes the chess pattern with diffuse lightning\n    vec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n \t\n    float tileSize = 4.0;\n    float pixSize = 3.0*2.0*length(v-p)\n        \t\t\t\t\t\t\t/(min(iResolution.x, iResolution.y)\n                                    *length(v-pFrag)\n                                    *tileSize);\n    \n    vec2 ij = floor(p.xy/tileSize);\n   \tvec3 cChess;\n    if(mod(ij.x, 2.0)==mod(ij.y, 2.0)){\n        cChess = cSand;\n    }\n    else{\n     \tcChess = cSandStone;   \n    }\n    \n    vec2 pLocal = abs(fract(p.xy/tileSize)-0.5);\n    float maxLocal = max(pLocal.x, pLocal.y);\n    \n    float bd = diffuse(p, vec3(0.0, 0.0, 1.0));\n    return (ba+bd)*mix(cRock, cChess, smoothstep(0.0, pixSize, 0.49-maxLocal));  \n}\n\nvec3 rostrum(vec3 p, vec3 rView, float radius){\n    //essentially intersect ray with cylinder\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n    float h = 2.0;\n \t\n    vec2 sol = intersectCircle(-p.xy, normalize(rView.xy));\n    \n    vec3 pCylinder = p + rView*\n        \t\t\t\t(sol.x+sqrt(sol.y+pow(radius, 2.0)))\n                         /length(rView.xy);\n    \n    vec3 nCylinder = normalize(vec3(-pCylinder.xy, 0.0));\n    vec3 pPlane = p - (p.z-h) * rView / rView.z;\n    \n    float bd = mix(diffuse(pCylinder, nCylinder),\n             diffuse(pPlane, vec3(0.0, 0.0, 1.0)),\n             smoothstep(h-0.1, h, pCylinder.z));\n    return (ba+bd)*cRock;\n}\n\nvec3 computeBackground(vec3 p, vec3 rView){\n \tvec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cSky = vec3(0.5, 0.76, 0.7);\n    \n    //check if XY-plane is visible\n    if(dot(rView, vec3(0.0, 0.0, 1.0))>-0.01*3.14){\n     \treturn cSky;   \n    }\n    \n    //calculate intersection with XY-plane\n    vec3 pXY = p - p.z * rView / rView.z;\n    float l0 = length(pXY);\n    float l1 = length(p - (p.z-2.0) * rView / rView.z);\n    \n    \n    if(l1>30.0){\n        \n     \treturn cSky;  \n    }\n    else if(l0>25.0){\n        vec3 cRostrum = rostrum(p, rView, 25.0);\n        vec3 mix0 = mix(chess(pXY, p), cRostrum,\n                   smoothstep(25.0, 25.4, l0));  \n     \treturn mix(mix0, cSky,\n                   smoothstep(29.3, 30.0, l1));   \n    }\n    else{\n        return chess(pXY, p); \n     \t\n    }\n}\n\n\n    \n\nmat3 rotationMatrix(const float angle, const vec3 axis){\n \tfloat alpha = radians(angle);\n    float c = cos(alpha);\n    float s = sin(alpha);\n    mat3 R;\n    R[0] = axis * axis.x * (1.0-c) + vec3(c, axis.z*s, -axis.y*s);\n    R[1] = axis * axis.y * (1.0-c) + vec3(-axis.z*s, c, axis.x*s);\n    R[2] = axis * axis.z * (1.0-c) + vec3(axis.y*s, -axis.x*s, c);\n    return R;\n}\n\nvec3 getCameraPosition(vec4 mouse){\n    //computes position of camera from difference between\n    //clicked and current pixel-coordinates\n    vec3 v0 = 20.0*vec3(1.0, 0.0, 1.0);\n    \n    if(iMouse.w<0.){\n        return v0;\n    }\n    else{\n        vec3 v;\n    \tvec2 angle = 200.0*(mouse.xy-mouse.zw);\n        angle.y = min(abs(angle.y), 40.0)*sign(angle.y);\n        \n        vec3 axVert = vec3(0.0, 0.0, 1.0);\n        mat3 rVert = rotationMatrix(angle.x, axVert);\n        v = rVert*v0;\n        \n        vec3 axFlat = normalize(cross(-v, axVert));\n\t\tmat3 rFlat = rotationMatrix(angle.y, axFlat);\n        return rFlat*v;\n    }\n}\n\nfloat f(vec2 polar, float n){\n \t//deviation from radius\n    \n    \n    return 0.5*(1.0+sin(iTime+5.0*gNoise(polar, n)));\n}\n\nvec3 polarToSpace(vec2 polar, float n){\n    //convert polar coordinates to euclidean\n    polar = vec2(polar.x*pi()/n, 2.0*pi()*polar.y/n); \n \treturn vec3(cos(polar.x), \n               \tsin(polar.x)*-sin(polar.y),\n               \tsin(polar.x)*-cos(polar.y));\n    \n}\n\nvec3 reflectionBall(vec3 pSurface, vec3 normal, vec3 pFrag, vec3 rView){\n    //compute the reflection in the balls surface\n    vec3 rReflected = reflect(rView, normal);\n    vec3 pFragReflected = pSurface - rReflected * length(pSurface-pFrag);\n    return computeBackground(pFragReflected, rReflected);\n               \n}\n\nvec3 warpedSurface(vec3 p, vec3 center, vec3 rView, float radius){\n    //compute the perturbed normals of the \n    //warped surface (bump map, no true normals or positions)\n    \n    vec3 cLemon = vec3(1.0, 0.88, 0.0);\n    vec3 pNormalized = normalize(p-center);\n   \tfloat n = 13.0;\n    \n   \tvec2 pz = normalize(pNormalized.zy);\n           \n   \tvec2 polar = vec2(n*acos(pNormalized.x)/pi(),\n                      0.5*n*(acos(pz.x)*sign(pz.y)/pi()+1.0));\n    \n    float h = 0.05;\t   \n   \n    float factor = 0.01;\n    float fVal = factor*f(polar, n);\n    \n  \tvec3 dx = ((1.0-factor*f(vec2(polar.x+h, polar.y), n))*\n               polarToSpace(vec2(polar.x+h, polar.y), n)-\n               (1.0-fVal)*\n               pNormalized)/h;\n    vec3 dy = ((1.0-factor*f(vec2(polar.x, polar.y+h), n))*\n               polarToSpace(vec2(polar.x, polar.y+h), n)-\n               (1.0-fVal)*\n               pNormalized)/h;\n                      \n    vec3 normal = -normalize(cross(dx, dy));\n    \n    //add lightning and reflection\n    float bd = diffuse(p, normal); \n    float spec = specular(normal, p, -rView);\n    \n    vec3 reflection = reflectionBall(p+pNormalized*fVal,\n                                     normal,\n                                     v,\n                                     rView);\n   \treturn mix(mix((ba+bd)*cLemon, reflection, 0.3),\n              vec3(1.0), spec);\n           \n           \n   \n   }\n\n\nvec4 computeObject(vec3 p, vec3 rView){\n    //compute intersection of viewing ray with sphere\n    //calculate color\n    vec3 center = vec3(0.0, 0.0, 6.0);\n    float radius =  5.0;\n    \n    vec2 sol = intersectBall(center-p, rView);\n    \n    if(pow(radius, 2.0)+sol.y>0.0){\n           float temp = sol.x+sqrt(sol.y+pow(radius, 2.0));\n           vec3 p1 = p+(-sol.y-pow(radius, 2.0)+pow(sol.x, 2.0))*rView/temp;\n           \n           vec3 color = warpedSurface(p1, center, rView, radius);\n           return vec4(color , smoothstep(0.0, 0.3, pow(radius, 2.0)+sol.y));\n           }\n           else{\n           return vec4(0.0);\n            }        \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec4 mouse = iMouse/min(iResolution.x, iResolution.y);\n    \n    // set up camera\n   \n    v = getCameraPosition(mouse);\n    vec3 vDir = normalize(-v);\n    vec3 vLeft = normalize(cross(vDir, vec3(0.0, 0.0, 1.0)));\n    vec3 vUp = cross(vLeft, vDir);\n    float dScreen = 2.5;\n    \n    //calculate fragment position in space\n    vec3 pFrag = v + dScreen * vDir + uv.x*vLeft + uv.y * vUp;\n    \n    vec3 rView = normalize(pFrag-v);\n    \n    vec4 colorBall = computeObject(pFrag, rView);\n    \n    vec3 color = computeBackground(pFrag, rView);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(mix(color, colorBall.xyz, colorBall.w),1.0);\n}","name":"Image","description":"","type":"image"}]}