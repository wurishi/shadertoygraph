{"ver":"0.1","info":{"id":"3sfBD8","date":"1588097958","viewed":188,"name":"3D Perlin Noise Function Test","username":"jstrom2002","description":"Testing the 3D perlin noise functions from Micah Caunter's book on procedural generation: https://openworks.wooster.edu/cgi/viewcontent.cgi?article=1705&context=independentstudy","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float perlinNoise3D(float x , float y , float z );\nfloat noise3D(float x , float y , float z );\nfloat findNoise3D(int x, int y , int z);\nfloat interpolate(float a , float b , float x);\n\nivec3 seed=ivec3(10,200,300);\nint octaves=11;\nfloat zoom=0.001;\nfloat persistence=50.;\n\nfloat interpolate(float a, float b, float x)\n{\n   //Quintic Interpolation Formula\n\tfloat f = 6.0 * pow(x , 5.0) - 15.0 * pow(x , 4.0) + 10.0 * pow(x , 3.0);\n\treturn a * (1.0 - f) + b * f ; \n}\n\nfloat findNoise3D(int x ,int y ,int z)\n{\n\tint n = x*seed.x + y*seed.y + z*seed.z;\n\tn = (n << 13) ^ n;\n\tint nn = (60493 * (n * n * n) + 19990303 * n + 1376312589) & 0x7fffffff;\n\treturn 1.0 * (float(nn) / 1073741824.0);\n}\n\nfloat perlinNoise3D(float x,float y, float z)\n{\n\tfloat frequency, amplitude ,returnVal = 0.0, maxH= 0.0;\n    for (int o = 0 ; o < octaves ; o++){\n\t\tfrequency = pow(2.0,float(o));\n\t\tamplitude = pow(persistence, float(o) );\n\t\tmaxH += amplitude ;\n\t\treturnVal += (noise3D(x*frequency / zoom, y * frequency / zoom, z * frequency/zoom)) * amplitude;\n\t}\n\treturn (returnVal/maxH);\n}   \n    \n\nfloat noise3D(float x ,float y ,float z)\n{\n\tvec3 Pos = vec3(x , y , z );\n\tivec3 Flr = ivec3 (floor(Pos));\n    \n\tfloat s,t,u,v,a,b,c,d;\n    \n\ts = findNoise3D(Flr.x, Flr.y, Flr.z);\n\tt = findNoise3D(Flr.x + 1, Flr.y, Flr.z);\n\tu = findNoise3D(Flr.x, Flr.y + 1, Flr.z);\n\tv = findNoise3D(Flr.x + 1, Flr.y + 1, Flr.z);\n\ta = findNoise3D(Flr.x, Flr.y, Flr.z + 1);\n\tb = findNoise3D(Flr.x + 1, Flr.y, Flr.z + 1);\n\tc = findNoise3D(Flr.x, Flr.y + 1, Flr.z + 1);\n\td = findNoise3D(Flr.x + 1, Flr.y + 1, Flr.z + 1);\n\n\tfloat int1 = interpolate(s, t, fract(x));\n\tfloat int2 = interpolate(u, v, fract(x));\n\tfloat int3 = interpolate(a, b, fract(x));\n\tfloat int4 = interpolate(c, d, fract(x));\n\tfloat int5 = interpolate(int1, int2, fract(y));\n\tfloat int6 = interpolate(int3, int4, fract(y));\n\n\treturn interpolate(int5, int6 , fract(z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = iTime*fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(perlinNoise3D(uv.x,uv.y,sin(uv.y)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}