{"ver":"0.1","info":{"id":"slccDX","date":"1664146629","viewed":994,"name":"CURIOUS CRYSTAL","username":"alro","description":"Item 3071 (Pike expedition, 1832): Small gem, regular cut. Interior shows billowing shapes of many colours set in a sea of clear blue. Reports of hypnagogia and glimpses of strange places on the far side. Not to be removed from the Archive.","likes":79,"published":1,"flags":32,"usePreview":0,"tags":["3d","volumetric","glass","transparent","ice","translucent","gem","transmission","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Scattering media inside a refractive substance. Use mouse to move camera.\n*/\n\n// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\nconst int MAX_STEPS = 64;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 5.0;\nconst float EPSILON = 1e-3;\nconst float DETAIL_EPSILON = 2e-3;\nconst float DETAIL_HEIGHT = 0.002;\nconst vec3 DETAIL_SCALE = vec3(0.35);\nconst vec3 BLENDING_SHARPNESS = vec3(4.0);\n\n#define IOR 2.0\n\n// Ratios of air and crystal IOR for refraction\n// Air to crystal\n#define ETA 1.0/IOR\n// Crystal to air\n#define ETA_REVERSE IOR\n\n// Internal structure\nconst vec3 mainColour = vec3(0.935, 0.75, 0.5);\n\nconst float DENSITY = 1000.0;\nconst float DENSITY_POW = 1.0;\nconst float SCALE = 24.0;\n\nconst vec3 light = vec3(0.35);\nconst vec3 lightDirection = normalize(vec3(1));\n\nvec3 getSkyColour(vec3 rayDir){\n    return pow(texture(iChannel1, rayDir).rgb, vec3(2.2));\n}\n\n\n//-------------------------------- Camera --------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 at, vec3 up){\n  vec3 zaxis = normalize(at-camera);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//-------------------------------- Rotations --------------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\nvec3 rotateX(vec3 p, float angle){\n    return rotate(p, vec4(sin(angle/2.0), 0.0, 0.0, cos(angle/2.0)));\n}\nvec3 rotateY(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, sin(angle/2.0), 0.0, cos(angle/2.0)));\n}\nvec3 rotateZ(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, 0.0, sin(angle), cos(angle)));\n}\n\n\n//---------------------------- Distance functions ----------------------------\n\n// Distance functions and operators from:\n// https://iquilezles.org/articles/distfunctions\n\nfloat displacement(vec3 p){\n    return sin(p.x)*sin(p.y)*sin(p.z);\n}\n\nfloat opDisplace(vec3 p){\n    vec3 offset = normalize(vec3(1));\n    return displacement(15.0*(p+offset));\n}\n\nfloat opSmoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat planeSDF(vec3 p, vec3 normal, float dist){\n\treturn dot(p, normal) - dist;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smoothMin(float a, float b, float k){\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 getRotatedPoint(vec3 p){\n     return rotateX(p, 0.6);\n}\n\nfloat getSDF(vec3 p, float sdfSign){\n    \n    p = getRotatedPoint(p);\n    \n    const float SIDES = 7.0;\n    float k = 0.002;\n    float dist = sphereSDF(p, 10.0);\n    for(float i = 0.0; i < SIDES; i += 1.0){\n        float angle = i * TWO_PI/SIDES;\n        vec3 n = normalize(rotateY(vec3(1, 0, 0), angle+0.707));\n        float sideDist = planeSDF(p, n, -0.45);\n        dist = opSmoothSub(sideDist, dist, k);\n        \n        n = normalize(rotateX(vec3(0,0,1), 0.65));\n        n = normalize(rotateY(n, angle));\n        float topDist = planeSDF(p, n, -0.65);\n        dist = opSmoothSub(topDist, dist, k);\n        \n        n = normalize(rotateX(vec3(0,0,1), -0.65));\n        n = normalize(rotateY(n, angle));\n        topDist = planeSDF(p, n, -0.65);\n        dist = opSmoothSub(topDist, dist, k);\n    }\n\n    return sdfSign * dist;\n}\n\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, float sdfSign){\n\t\n    // Start at a predefined distance from the camera in the ray direction\n    float depth = start;\n    \n    // Variable that tracks the distance to the scene at the current ray endpoint\n    float dist;\n    \n    // For a set number of steps\n    for (int i = ZERO; i < MAX_STEPS; i++) {\n        \n        // Get the sdf value at the ray endpoint, giving the maximum \n        // safe distance we can travel in any direction without hitting a surface\n        dist = getSDF(cameraPos + depth * rayDir, sdfSign);\n        \n        // If it is small enough, we have hit a surface\n        // Return the depth that the ray travelled through the scene\n        if (dist < EPSILON){\n            return depth;\n        }\n        \n        // Else, march the ray by the sdf value\n        depth += dist;\n        \n        // Test if we have left the scene\n        if (depth >= end){\n            return end;\n        }\n    }\n\n    return depth;\n}\n\n\n//----------------------------- Normal mapping -----------------------------\n\n// https://tinyurl.com/y5ebd7w7\nfloat getTriplanar(vec3 position, vec3 normal){\n    float xaxis = texture(iChannel2, DETAIL_SCALE.x*(position.zy)).b;\n    float yaxis = texture(iChannel2, DETAIL_SCALE.y*(position.zx)).b;\n    float zaxis = texture(iChannel2, DETAIL_SCALE.z*(position.xy)).b;\n\n    vec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n    blending = pow(blending, BLENDING_SHARPNESS);\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= b;\n\n    return\txaxis * blending.x + \n       \t\tyaxis * blending.y + \n        \tzaxis * blending.z;\n}\n\n// Return the position of p extruded in the normal direction by normal map\nvec3 getDetailExtrusion(vec3 p, vec3 normal){\n    float detail = DETAIL_HEIGHT * getTriplanar(p, normal);\n    return p + detail * normal;\n}\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p, float sdfSign){\n    vec3 n = vec3(0.0);\n    int id;\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*getSDF(p+e*EPSILON, sdfSign);\n    }\n    return normalize(n);\n}\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\n// Return the normal after applying a normal map\nvec3 getDetailNormal(vec3 p, vec3 normal){\n\n    vec3 tangent;\n    vec3 bitangent;\n    \n    // Construct orthogonal directions tangent and bitangent to sample detail gradient in\n    pixarONB(normal, tangent, bitangent);\n    \n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n\n    vec3 delTangent = vec3(0);\n    vec3 delBitangent = vec3(0);\n    \n    for(int i = ZERO; i < 2; i++){\n        \n        //i to  s\n        //0 ->  1\n        //1 -> -1\n        float s = 1.0 - 2.0 * float(i&1);\n    \n        delTangent += s * getDetailExtrusion(p + s * tangent * DETAIL_EPSILON, normal);\n        delBitangent += s * getDetailExtrusion(p + s * bitangent * DETAIL_EPSILON, normal);\n\n    }\n    \n    return normalize(cross(delTangent, delBitangent));\n}\n\nfloat getPerlinNoise(vec3 pos){\n\n    // Find an interesting section of the noise field\n    pos += vec3(0.0, 12.0, -3.0);\n\n    // The noise texture is an atlas of 6*6 tiles (36). \n    // Each tile is 32*32 with a 1 pixel wide boundary.\n    // Per tile:\t\t32 + 2 = 34.\n    // Atlas width:\t6 * 34 = 204.\n    // The rest of the texture is black.\n    // The 3D texture the atlas represents has dimensions 32 * 32 * 36.\n    // The green channel is the data of the red channel shifted by one tile.\n    // (tex.g is the data one level above tex.r). \n    // To get the necessary data only requires a single texture fetch.\n    const float dataWidth = 204.0;\n    const float tileRows = 6.0;\n    const vec3 atlasDimensions = vec3(32.0, 32.0, 36.0);\n\n    // Change from Y being height to Z being height.\n    vec3 p = pos.xzy;\n\n    // Pixel coordinates of point in the 3D data.\n    vec3 coord = vec3(mod(p, atlasDimensions));\n    float f = fract(coord.z);  \n    float level = floor(coord.z);\n    float tileY = floor(level/tileRows); \n    float tileX = level - tileY * tileRows;\n\n    // The data coordinates are offset by the x and y tile, the two boundary cells \n    // between each tile pair and the initial boundary cell on the first row/column.\n    vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n    vec2 pixel = coord.xy + offset;\n    vec2 data = texture(iChannel2, mod(pixel, dataWidth)/iChannelResolution[0].xy).xy;\n    return smoothstep(0.45, 1.0, mix(data.x, data.y, f));\n}\n\nfloat getInternalDensity(vec3 pos){\n    pos = getRotatedPoint(pos);\n    float clearSides = smoothstep(0.4, 0.0, length(pos.xz));\n    float clearTop = smoothstep(0.5, 0.0, pos.y);\n    return 0.2 + clearSides * clearTop * DENSITY * pow(getPerlinNoise(SCALE * pos), DENSITY_POW);\n}\n\nconst vec3 sigmaS = 1.0-mainColour;\nconst vec3 sigmaA = vec3(0);\n// Extinction coefficient.\nconst vec3 sigmaE = max(sigmaS + sigmaA, vec3(1e-6));\n\n// Get the amount of light that reaches a sample point.\nvec3 lightRay(vec3 org, vec3 p, vec3 lightDirection){\n\n    float distToStart = 0.0;\n    const float STEPS_LIGHT = 3.0;\n    float stepL = 0.03;\n\n\tfloat lightRayDensity = 0.0;\n\n\t// Collect total density along light ray.\n\tfor(float j = 0.0; j < STEPS_LIGHT; j++){      \n\t\tlightRayDensity += getInternalDensity(p + lightDirection * j * stepL);\n\t}\n    \n\treturn exp(-lightRayDensity * sigmaS * stepL);\n}\n\nvec3 getInterior(vec3 org, vec3 rayDir, float rayLength, out vec3 totalTransmittance){\n    const float STEP_COUNT = 20.0;\n    float stepS = rayLength / STEP_COUNT;\n\n    float density = 0.0;\n    vec3 pos = org;\n    float dist = 0.0;\n    totalTransmittance = vec3(1);\n\n    vec3 colour = vec3(0);\n    \n    for(float i = 0.0; i < STEP_COUNT; i++){\n        density += getInternalDensity(pos);\n  \n        vec3 sampleSigmaS = sigmaS * density;\n        vec3 sampleSigmaE = sigmaE * density;\n\n        // If there is a cloud at the sample point.\n        if(density > 0.0 ){\n\n            //Constant lighting factor based on the height of the sample point.\n            vec3 ambient = vec3(1);\n\n            // Amount of sunlight that reaches the sample point through the cloud \n            // is the combination of ambient light and attenuated direct light.\n            vec3 luminance = light * lightRay(org, pos, lightDirection);\n\n            // Scale light contribution by density of the cloud.\n            luminance *= sampleSigmaS;\n\n            // Beer-Lambert.\n            vec3 transmittance = exp(-sampleSigmaE * stepS);\n\n            // Better energy conserving integration\n            // \"From Physically based sky, atmosphere and cloud rendering in Frostbite\" 5.6\n            // by Sebastian Hillaire.\n            colour += \n                totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE; \n\n            // Attenuate the amount of light that reaches the camera.\n            totalTransmittance *= transmittance;  \n\n            // If ray combined transmittance is close to 0, nothing beyond this sample \n            // point is visible, so break early.\n            if(length(totalTransmittance) <= 0.001){\n                totalTransmittance = vec3(0.0);\n                break;\n            }\n        }\n\n        dist += stepS;\n\n\t\t// Step along ray.\n\t\tpos = org + rayDir * dist;\n    }\n\n    return colour;\n}\n\n// From the closest intersection with the scene, raymarch the negative SDF field to \n// find the far instersection. The distance inside the crystal is used to determine \n// transmittance and the attenuation of the environment.\nvec3 getEnvironment(vec3 org, vec3 rayDir){\n    float sdfSign = -1.0;\n\n    float distFar = distanceToScene(org, rayDir, MIN_DIST, MAX_DIST, sdfSign);\n\n    vec3 positionFar = org + rayDir * distFar;\n    vec3 geoNormalFar = getNormal(positionFar, sdfSign);\n\n    //Use the geometry normal on the far side to reduce noise\n    vec3 refractedDir = normalize(refract(rayDir, geoNormalFar, ETA_REVERSE));\n\n    // When total internal reflection occurs, reflect the ray off the far side\n    if(dot(-rayDir, geoNormalFar) <= cos(asin(ETA))){\n        refractedDir = normalize(reflect(rayDir, geoNormalFar));\n    }\n\n    vec3 transmitted = getSkyColour(refractedDir);\n\n    vec3 totalTransmittance = vec3(1);\n    vec3 col = getInterior(org, rayDir, distFar, totalTransmittance);\n    \n    col += transmitted * totalTransmittance;\n    return col;\n}\n\n//------------------------------- Shading -------------------------------\n\n// Fresnel-Schlick\nvec3 fresnel(float cosTheta, vec3 F0){\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n} \n\nvec3 shading(vec3 p, vec3 n, vec3 rayDir, vec3 geoNormal){\n    vec3 I = vec3(0);\n\n    vec3 albedo = vec3(0.5);    \n\n    // Reflectance of the surface when looking straight at it along the negative normal\n    vec3 F0 = vec3(pow(IOR - 1.0, 2.0) / pow(IOR + 1.0, 2.0));\n        \n    vec3 ambientColour = getEnvironment(p + rayDir * 2.0 * EPSILON, refract(rayDir, n, ETA));                          \n    vec3 reflectedCol = getSkyColour(reflect(rayDir, n));\n\n    vec3 F = fresnel(dot_c(n, -rayDir), F0);\n    \n    return mix(ambientColour, reflectedCol, F);\n}\n\n//----------------------------- Tonemapping and output ------------------------------\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\t//----------------- Define a camera -----------------\n    \n    vec3 rayDir = rayDirection(60.0, fragCoord);\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n    vec3 targetDir = -cameraPos;\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    // Transform the ray to point in the correct direction.\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n    \n    // Find the distance to where the ray stops.\n    float dist = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST, 1.0);\n    \n    vec3 col = vec3(0);\n    \n    if(dist < MAX_DIST){\n        vec3 position = cameraPos + rayDir * dist;\n        vec3 geoNormal = getNormal(position, 1.0);\n\n        // Avoid artefacts when trying to sample detail normals across Z-plane.\n        if(abs(geoNormal.z) < 1e-5){\n            geoNormal.z = 1e-5;\n        }\n\n        geoNormal = normalize(geoNormal);\n\n        vec3 detailNormal = normalize(getDetailNormal(getRotatedPoint(position), geoNormal));\n\n        col = shading(position, detailNormal, rayDir, geoNormal);\n\n    } else {\n        col = 0.02 * mix(vec3(0.81, 0.09, 0.33), vec3(0.09, 0.33, 0.81), (0.5 + 0.5 * rayDir.y));\n        // col = getSkyColour(rayDir);\n    }\n    \n    // Tonemapping\n    col = ACESFilm(col);\n\n    // Gamma\n    col = pow(col, vec3(0.4545));\n    \n    //vec2 uv = fragCoord/iResolution.xy;\n    //col = texture(iChannel2, uv).rgb;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2022 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define PI 3.14159\n#define TWO_PI 6.283185\n#define FOUR_PI 12.56637\n\n// Minimum dot product value\nconst float minDot = 1e-3;\n\n// Clamped dot product\nfloat dot_c(vec3 a, vec3 b){\n\treturn max(dot(a, b), minDot);\n}\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat remap(float x, float low1, float high1, float low2, float high2){\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n\nfloat modulo(float m, float n){\n  return mod(mod(m, n) + n, n);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Track mouse movement and resolution change between frames and set camera position.\n\n#define EPS 1e-4\n#define CAMERA_DIST 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = modulo(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(2.6, 1.7);\n                mouse = vec2(0);\n            }\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Create a Perlin texture atlas for interior shapes\n// Store normal map in blue channel\n// Runs only once in the first frame or when resolution changes\n// Based on https://github.com/sebh/TileableVolumeNoise/blob/master/main.cpp\n\n// The atlas is a 6*6 grid of 32*32 tiles with a single layer of halo cells around each tile. \n\n// TODO: Assumes a size of at least 204 * 204. Make it work with any reasonable resolution.\n\n\n//-------------------------------- 3D --------------------------------\n\nvec3 modulo(vec3 m, float n){\n  return mod(mod(m, n) + n, n);\n}\n\n// 5th order polynomial interpolation\nvec3 fade(vec3 t){\n    return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n#define SIZE 4.0\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n    p3 = modulo(p3, SIZE);\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx) - 1.0;\n}\n\nfloat gradientNoise(vec3 p){\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = fade(f);\n    \n    /*\n    * For 1D, the gradient of slope g at vertex u has the form h(x) = g * (x - u), where u \n    * is an integer and g is in [-1, 1]. This is the equation for a line with slope g which \n    * intersects the x-axis at u.\n    * For N dimensional noise, use dot product instead of multiplication, and do \n    * component-wise interpolation (for 3D, trilinear)\n    */\n    return mix( mix( mix( dot( hash(i + vec3(0.0,0.0,0.0)), f - vec3(0.0,0.0,0.0)), \n              dot( hash(i + vec3(1.0,0.0,0.0)), f - vec3(1.0,0.0,0.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,0.0)), f - vec3(0.0,1.0,0.0)), \n              dot( hash(i + vec3(1.0,1.0,0.0)), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n    mix( mix( dot( hash(i + vec3(0.0,0.0,1.0)), f - vec3(0.0,0.0,1.0)), \n              dot( hash(i + vec3(1.0,0.0,1.0)), f - vec3(1.0,0.0,1.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,1.0)), f - vec3(0.0,1.0,1.0)), \n              dot( hash(i + vec3(1.0,1.0,1.0)), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\nfloat getPerlinNoise(vec3 pos, float frequency){\n\n\t//Compute the sum for each octave.\n\tfloat sum = 0.0;\n\tfloat weightSum = 0.0;\n\tfloat weight = 1.0;\n\n\tfor(int oct = 0; oct < 4; oct++){\n\n        vec3 p = pos * frequency;\n        float val = 0.5 + 0.5 * gradientNoise(p);\n        sum += val * weight;\n        weightSum += weight;\n\n        weight *= 0.5;\n        frequency *= 2.0;\n\t}\n\n\treturn saturate(sum / weightSum);\n}\n\n//-------------------------------- 2D --------------------------------\n\nvec2 modulo(vec2 m, float n){\n  return mod(mod(m, n) + n, n);\n}\n\n#define SIZE_2D 16.0\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash(vec2 p){\n    p = modulo(p, float(SIZE_2D));\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return 2.0 * fract((p3.xx+p3.yz)*p3.zy) - 1.0;\n}\n\n// 5th order polynomial interpolation\nvec2 fade(vec2 t){\n    return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat gradientNoise( in vec2 p ){\n\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = fade(f);\n    \n    // For 1D, the gradient of slope g at vertex u has the form h(x) = g * (x - u), where u is an integer and g is in [-1, 1].\n    // This is the equation for a line with slope g which intersects the x-axis at u.\n    // For N dimensional noise, use dot product instead of multiplication, and do component-wise interpolation.\n    // For 2D, bilinear. For 3D, trilinear.\n    return  mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                      dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                 mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                      dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat getPerlinNoise(vec2 pos, float frequency){\n\n\t//Compute the sum for each octave.\n\tfloat sum = 0.0;\n\tfloat weightSum = 0.0;\n\tfloat weight = 1.0;\n\n\tfor(int oct = 0; oct < 4; oct++){\n\n        vec2 p = pos * frequency;\n        float val = 0.5 + 0.5 * gradientNoise(p);\n        sum += val * weight;\n        weightSum += weight;\n\n        weight *= 0.5;\n        frequency *= 3.0;\n\t}\n\n\treturn saturate(sum / weightSum);\n}\n\n//--------------------------------------------------------------------\n\n//Return the 3D coordinate corresponding to the 2D atlas uv coordinate.\nvec3 get3Dfrom2D(vec2 uv, float tileRows){\n    vec2 tile = floor(uv);\n    float z = floor(tileRows * tile.y + tile.x);\n    return vec3(fract(uv), z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    bool resolutionChanged = texelFetch(iChannel2, ivec2(0.5, 2.5), 0).r > 0.0;\n    \n    if(iFrame == 0 || iFrame == 260 || texelFetch(iChannel1, ivec2(0), 0).b == 0.0 \n                  || resolutionChanged){\n        vec3 col = vec3(0);\n        //32 with 1 pixel on either side.\n        float tileSize = 34.0;\n        float padWidth = 1.0;\n        float coreSize = tileSize - 2.0 * padWidth;\n        float tileRows = 6.0;\n        float tileCount = tileRows * tileRows;\n        vec2 tile = floor((fragCoord.xy - 0.5) / tileSize);\n\n        bool padCell = false;\n        if(mod(fragCoord.x, tileSize) == 0.5 || mod(fragCoord.x, tileSize) == tileSize - 0.5){\n            padCell = true;\n        }\n        if(mod(fragCoord.y, tileSize) == 0.5 || mod(fragCoord.y, tileSize) == tileSize - 0.5){\n            padCell = true;\n        }\n\n        bool startPadX = false;\n        bool endPadX = false;\n        bool startPadY = false;\n        bool endPadY = false;\n\n        if(fragCoord.x == tile.x * tileSize + 0.5){\n            startPadX = true;\n        }\n        if(fragCoord.y == tile.y * tileSize + 0.5){\n            startPadY = true;\n        }\n        if(fragCoord.x == (tile.x + 1.0) * tileSize - 0.5){\n            endPadX = true;\n        }\n        if(fragCoord.y == (tile.y + 1.0) * tileSize - 0.5){\n            endPadY = true;\n        }\n\n        vec2 padding = vec2(2.0 * padWidth) * tile;\n        vec2 pixel;\n        vec2 uv;\n        \n        if(!padCell){\n            pixel = fragCoord.xy - padWidth - padding;\n            uv = vec2(pixel.xy/coreSize);\n        }else{\n            pixel = fragCoord.xy - padWidth - padding;\n            if(startPadX){\n                pixel.x += coreSize;\t\n            }\n            if(startPadY){\n                pixel.y += coreSize;\t\n            }\n            if(endPadX){\n                pixel.x -= coreSize;\t\n            }\n            if(endPadY){\n                pixel.y -= coreSize;\t\n            }\n            uv = vec2(pixel.xy/coreSize);\n        }\n        \n        vec3 p_ = get3Dfrom2D(uv, tileRows);\n        vec3 p = p_;\n        p.z /= (tileRows*tileRows);\n\n        // Get Perlin noise for level l\n        col.r = getPerlinNoise(p, SIZE);\n        p_ = mod(p_ + 1.0, tileRows * tileRows);\n        p = p_;\n        p.z /= (tileRows*tileRows);\n\n        // Get Perlin noise for level l+1\n        col.g = getPerlinNoise(p, SIZE);\n\n        // Unused cells\n        if(gl_FragCoord.x > tileRows * tileSize || gl_FragCoord.y > tileRows * tileSize){\n            col = vec3(0);\n        }\n        \n        // 2D noise texture for normal mapping\n        uv = fragCoord/iResolution.xy;\n        col.b = 2.0 * getPerlinNoise(uv, SIZE_2D) - 1.0;\n        col.b *= 0.5 + 2.0*pow(abs(2.0*length(texture(iChannel1, uv).rgb)-1.0), 4.0);\n        \n    \tfragColor = vec4(col, 1.0);\n        \n    }else{\n        \n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0).rgba;\n        \n    }\n\n}","name":"Buffer B","description":"","type":"buffer"}]}