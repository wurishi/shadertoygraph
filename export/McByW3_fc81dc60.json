{"ver":"0.1","info":{"id":"McByW3","date":"1723132164","viewed":31,"name":"Reflective raymarched objects","username":"ttofu","description":"First time trying raymarching! The SDFs and the soft shadow function is from https://iquilezles.org. I tried improving the readability of the code in those functions. I did my own thing with the reflections, looks good enough. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define CAMERA_POSITION vec3(-2.0, 5.0, -5.0)\n#define CAMERA_LOOK_AT vec3(0.0, 1.5, 0.0)\n#define FOV 130.0\n\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_DIST 100000.0\n#define MIN_MARCH_STEP 0.00001\n#define MARCH_ITERATION_COUNT 100\n#define NORMAL_EPSILON 0.001\n\n#define SUN_DIRECTION normalize(vec3(1.0, 1.0, 2.0))\n#define SUN_COLOR vec3(1.0, 0.8, 0.3)\n#define SKY_COLOR vec3(0.1, 0.1, 0.2)\n#define SKY_SDF_THRESHOLD 1.0\n#define REFLECTION_COUNT 5\n#define MIN_RAY_STRENGTH 0.001\n#define SHADOW_SOFTNESS 0.1\n#define CHECKERBOARD\n\n#define PLANES\n#define SPHERES\n#define BOXES\n#define CAPSULES\n#define TORUSES\n\nstruct Material {\n    vec3 color;\n    float reflectiveness;\n};\n\n\n#ifdef PLANES\nstruct Plane {\n    vec4 parameters; // ax + by + cz + d = 0;\n    Material material;\n};\n\nfloat sdf(vec3 position, Plane plane) {\n    return (dot(position, plane.parameters.xyz) + plane.parameters.w) / (length(plane.parameters.xyz));\n}\n\nconst Plane[] planes = Plane[](\n    Plane(\n        vec4(0.0, 1.0, 0.0, 0.0), \n        Material(\n            vec3(0.5, 0.5, 0.5),\n            0.5\n        )\n    )\n);\n#endif\n\n\n#ifdef SPHERES\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nfloat sdf(vec3 position, Sphere sphere) {\n    return length(position - sphere.position) - sphere.radius;\n}\n\nconst Sphere[] spheres = Sphere[](\n    Sphere(\n        vec3(2.0, 2.0, 2.0), \n        1.0, \n        Material(\n            vec3(1.0, 0.0, 0.0), \n            0.5\n        )\n    )\n);\n#endif\n\n\n#ifdef BOXES\nstruct Box {\n    vec3 position;\n    vec3 scale;\n    Material material;\n};\n\nfloat sdf(vec3 position, Box box) {\n    vec3 dist = abs(position - box.position) - box.scale;\n    float max_dist = max(dist.x, max(dist.y, dist.z));\n    return min(max_dist, 0.0) + length(max(dist, 0.0));\n}\n\nconst Box[] boxes = Box[](\n    Box(\n        vec3(-2.0, 2.0, 2.0), \n        vec3(1.0, 1.0, 1.0), \n        Material(\n            vec3(0.0, 0.0, 1.0), \n            0.5\n        )\n    )\n);\n#endif\n\n\n#ifdef CAPSULES\nstruct Capsule {\n    vec3 point_1;\n    vec3 point_2;\n    float radius;\n    Material material;\n};\n\nfloat sdf(vec3 position, Capsule capsule) {\n  vec3 pa = position - capsule.point_1, ba = capsule.point_2 - capsule.point_1;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - capsule.radius;\n}\n\nconst Capsule[] capsules = Capsule[](\n    Capsule(\n        vec3(2.0, 2.0, -2.0), \n        vec3(2.0, 4.0, -2.0), \n        1.0, \n        Material(\n            vec3(1.0, 1.0, 0.0), \n            0.5\n        )\n    )\n);\n#endif\n\n\n#ifdef TORUSES\nstruct Torus {\n    vec3 position;\n    float width;\n    float radius;\n    Material material;\n};\n\nfloat sdf(vec3 position, Torus torus) {\n  vec2 to_ring = vec2(length((position - torus.position).xz) - torus.width, (position - torus.position).y);\n  return length(to_ring) - torus.radius;\n}\n\nconst Torus[] toruses = Torus[](\n    Torus(\n        vec3(-2.0, 2.0, -2.0), \n        1.0,\n        0.5, \n        Material(\n            vec3(0.0, 1.0, 0.0), \n            0.5\n        )\n    )\n);\n#endif\n\n\nfloat sdf(vec3 position) {\n    float dist = 1e18;\n    #ifdef PLANES\n    for (int i = 0; i < planes.length(); i++) {\n        dist = min(dist, sdf(position, planes[i]));\n    }\n    #endif\n    #ifdef SPHERES\n    for (int i = 0; i < spheres.length(); i++) {\n        dist = min(dist, sdf(position, spheres[i]));\n    }\n    #endif\n    #ifdef BOXES\n    for (int i = 0; i < boxes.length(); i++) {\n        dist = min(dist, sdf(position, boxes[i]));\n    }\n    #endif\n    #ifdef CAPSULES\n    for (int i = 0; i < capsules.length(); i++) {\n        dist = min(dist, sdf(position, capsules[i]));\n    }\n    #endif\n    #ifdef TORUSES\n    for (int i = 0; i < toruses.length(); i++) {\n        dist = min(dist, sdf(position, toruses[i]));\n    }\n    #endif\n    return dist;\n}\n\nMaterial closest_material(vec3 position) {\n    float dist = 1e18;\n    Material material;\n    \n    #ifdef PLANES\n    for (int i = 0; i < planes.length(); i++) {\n        float cur = sdf(position, planes[i]);\n        if (cur < dist) {\n            dist = cur;\n            material = planes[i].material;\n        }\n    }\n    #endif\n    #ifdef SPHERES\n    for (int i = 0; i < spheres.length(); i++) {\n        float cur = sdf(position, spheres[i]);\n        if (cur < dist) {\n            dist = cur;\n            material = spheres[i].material;\n        }\n    }\n    #endif\n    #ifdef BOXES\n    for (int i = 0; i < boxes.length(); i++) {\n        float cur = sdf(position, boxes[i]);\n        if (cur < dist) {\n            dist = cur;\n            material = boxes[i].material;\n        }\n    }\n    #endif\n    #ifdef CAPSULES\n    for (int i = 0; i < capsules.length(); i++) {\n        float cur = sdf(position, capsules[i]);\n        if (cur < dist) {\n            dist = cur;\n            material = capsules[i].material;\n        }\n    }\n    #endif\n    #ifdef TORUSES\n    for (int i = 0; i < toruses.length(); i++) {\n        float cur = sdf(position, toruses[i]);\n        if (cur < dist) {\n            dist = cur;\n            material = toruses[i].material;\n        }\n    }\n    #endif\n    #ifdef CHECKERBOARD\n    float checkerboard = (fract(round((position.x) + round(position.y) + round(position.z)) / 2.0) + 0.5);\n    material.reflectiveness *= checkerboard;\n    #endif\n    return material;\n}\n\nvec3 calculate_normal(vec3 position) {\n    float center_distance = sdf(position);\n    vec3 delta_distance = vec3(\n    sdf(position + vec3(NORMAL_EPSILON, 0.0, 0.0)), \n    sdf(position + vec3(0.0, NORMAL_EPSILON, 0.0)),\n    sdf(position + vec3(0.0, 0.0, NORMAL_EPSILON)));\n    return (delta_distance - center_distance) / NORMAL_EPSILON;\n}\n\n\nvec3 march(vec3 start, vec3 direction) {\n    float march_dist = MIN_MARCH_DIST;\n    float cur_dist = 1.0;\n    for (int i = 0; \n        i < MARCH_ITERATION_COUNT && \n        march_dist < MAX_MARCH_DIST && \n        cur_dist > MIN_MARCH_STEP; \n        i++) {\n        cur_dist = sdf(start + direction * march_dist);\n        march_dist += cur_dist;\n    }\n    return start + direction * march_dist;\n}\n\nbool is_sky(vec3 destination) {\n    return sdf(destination) > SKY_SDF_THRESHOLD;\n}\n\nfloat soft_shadow(vec3 start, vec3 direction) {\n    float shadow = 1.0;\n    float march_dist = MIN_MARCH_DIST;\n    float cur_dist = 1.0;\n    for (int i = 0; \n        i < MARCH_ITERATION_COUNT && \n        march_dist < MAX_MARCH_DIST && \n        shadow >= -1.0 &&\n        cur_dist > MIN_MARCH_STEP; \n        i++) {\n        cur_dist = sdf(start + direction * march_dist);\n        shadow = min(shadow, cur_dist / (SHADOW_SOFTNESS * march_dist));\n        march_dist += clamp(cur_dist, 0.005, 0.50);\n    }\n    shadow = max(shadow, -1.0);\n    return 0.25 * (1.0 + shadow) * (1.0 + shadow) * (2.0 - shadow);\n}\n\nvec3 sky_color(vec3 direction) {\n    return mix(SKY_COLOR, SUN_COLOR, 1.1 - length(direction - SUN_DIRECTION));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 normalized_uv = (fragCoord - (iResolution.xy / 2.0)) / min(iResolution.x, iResolution.y);\n    \n    #ifdef CAMERA_POSITION\n    vec3 camera_position = CAMERA_POSITION;\n    #else\n    vec2 mouse = iMouse.xy / iResolution.xy * vec2(5.0, 1.0);\n    float time = iTime / 5.0;\n    vec3 camera_position = 5.0 * vec3(sin(time + mouse.x), 0.4 + mouse.y, cos(time + mouse.x));\n    #endif\n    \n    vec3 center_direction = normalize(CAMERA_LOOK_AT - camera_position);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 screen_right = normalize(cross(center_direction, up));\n    vec3 screen_up = normalize(cross(screen_right, center_direction));\n    float screen_plane_distance = tan(radians(90.0 - (FOV / 2.0)));\n    vec3 direction = normalize(center_direction * screen_plane_distance + screen_right * normalized_uv.x + screen_up * normalized_uv.y);\n    \n    vec3 start = camera_position;\n    vec3 destination = march(start, direction);\n    if (is_sky(destination)) {\n        fragColor = vec4(sky_color(direction), 1.0);\n        return;\n    }\n    vec3 normal = calculate_normal(destination);\n    Material material = closest_material(destination);\n    float ray_strength = material.reflectiveness;\n    vec3 color = material.color * (1.0 - material.reflectiveness);\n    color *= soft_shadow(destination, SUN_DIRECTION);\n    \n    start = destination;\n    for (int i = 0; i < REFLECTION_COUNT && ray_strength > MIN_RAY_STRENGTH; i++) {\n        start = destination;\n        direction = reflect(direction, calculate_normal(destination));\n        destination = march(start, direction);\n        if (is_sky(destination)) {\n            color += sky_color(direction) * ray_strength;\n            break;\n        }\n        material = closest_material(destination);\n        color += material.color * ray_strength * soft_shadow(destination, SUN_DIRECTION);\n        ray_strength *= material.reflectiveness;\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}