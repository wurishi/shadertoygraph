{"ver":"0.1","info":{"id":"NlBcRD","date":"1677675669","viewed":53,"name":"3DWheel","username":"humblots","description":"jsp","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["jsp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 30.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\n// material structure\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\n// surface structure\nstruct Surface {\n    float sd; // surface distance\n    Material mat; // surface color\n};\n\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial silver() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// opUnion\nSurface add(Surface obj1, Surface obj2) {\n  if (obj1.sd > obj2.sd) return obj2;\n  return obj1;\n}\n\n// Surface - torus and material\nSurface sdTorus( vec3 p, vec2 t, vec3 offset, Material mat, mat3 transform )\n{\n  p = p * transform - offset;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return Surface(length(q)-t.y, mat);\n}\n\n// Surface - torus and material\nSurface sdCylinder( vec3 p, float h, float r, vec3 offset, Material mat, mat3 transform )\n{\n  p = p * transform - offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return Surface(min(max(d.x,d.y),0.0) + length(max(d,0.0)), mat);\n}\n\n// Surface - torus and material\nSurface sdVCapsule( vec3 p, float h, float r, vec3 offset, Material mat, mat3 transform )\n{\n  p = p * transform - offset;\n  p.y -= clamp( p.y, 0.0, h );\n  return Surface(length( p ) - r, mat);\n}\n\n// Surface - SingleWheel and material\nSurface sdSingleWheel(vec3 p, int nb, vec3 offset, mat3 transform) {\n    p = p * transform - offset;\n    Surface wheel = sdTorus(p, vec2(1.5,0.02), vec3(0), silver(), identity());\n  \n    // angle determined by the number of segments\n    float angle = ((180.0/float(nb))/360.0)*2.0*PI;\n    for(int i=0;i<nb;++i) {\n        Surface cylinder = sdCylinder(p, 0.02, 1.5, vec3(0), silver(), rotateZ(PI/2.)*rotateX(angle*float(i)));\n        wheel = add(wheel, cylinder);\n    }\n    \n   return wheel;\n}\n\n// Surface - Full Wheel and material\nSurface sdWheel(vec3 p, int nb, vec3 offset, mat3 transform) {\n    p = p * transform - offset;\n    Surface lWheel = sdSingleWheel(p, nb, vec3(0), identity());\n    Surface rWheel = sdSingleWheel(p, nb, vec3(0,0.5,0), identity());\n    Surface wheel = add(lWheel, rWheel);\n        \n    // angle determined by the number of segments\n    float angle = ((180.0/float(nb))/360.0)*2.0*PI;\n    float l = .25;\n    float w = .02;\n    \n    Surface center = sdCylinder(p, 0.05, l, vec3(0.,.25,0.), silver(), identity());\n    wheel = add(wheel, center);\n    \n    // add the wheel spokes\n    for(int i=0;i<nb;++i) {\n        Surface cylinder = sdCylinder(p, w, l, vec3(1.5,.25, 0.), silver(), rotateY(angle*float(i)));\n        Surface cylinder2 = sdCylinder(p, w, l, vec3(-1.5,.25, 0.), silver(), rotateY(angle*float(i)));\n        wheel = add(wheel, cylinder);\n        wheel = add(wheel, cylinder2);\n    }\n    return wheel;\n\n}\n\n// Surface - Triangular prism and material\nSurface sdTriPrism( vec3 p, vec2 h, vec3 offset, Material mat, mat3 transform)\n{\n  p = p * transform - offset;\n  vec3 q = abs(p);\n  return Surface(max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5), mat);\n}\n\n// Surface - Triangular prism and material\nSurface sdFoot(vec3 p, vec3 offset, Material mat, mat3 transform) {\n    p = p * transform - offset;\n    Surface foot = sdTriPrism(p, vec2(2, 0.1), vec3(0), mat, identity());\n    \n    // hole not working without substract operation\n    // Surface hole = sdTriPrism(p, vec2(1.8, 0.1), vec3(0.,.2,0.), mat, identity());\n    \n    return foot;\n}\n\n// Surface - Wheel with capsules and material\nSurface sdBigWheel(vec3 p, int nb, vec3 offset, mat3 transform) {\n    p = p * transform - offset;\n    Surface bigWheel = sdWheel(p, 10, vec3(0), rotateZ(PI/2.));\n        \n    // angle determined by the number of segments\n    float angle = ((180.0/float(nb))/360.0)*2.0*PI;\n    for(int i=0;i<nb;++i) {\n        Surface capsule = sdVCapsule(p, .1, .2, vec3(.25, 1.2, 0), gold(), rotateX(angle*float(i)));\n        Surface capsule2 = sdVCapsule(p, .1, .2, vec3(.25, -1.3, 0), gold(), rotateX(angle*float(i)));\n        bigWheel = add(bigWheel, capsule);\n        bigWheel = add(bigWheel, capsule2);\n    }\n    \n    return bigWheel;\n}\n\nSurface scene(in vec3 p) {\n    Surface sFloor = Surface( p.y + 1., checkerboard(p));\n    Surface bigWheel = sdBigWheel(p + vec3(0,-2,0), 5, vec3(0), rotateX(iTime*.5));\n    Surface lfoot = sdFoot(p, vec3(0,.3,-0.6), gold(),rotateY(PI/2.));\n    Surface rfoot = sdFoot(p, vec3(0,.3,.1), gold(),rotateY(PI/2.));\n    bigWheel = add(bigWheel, lfoot);\n    bigWheel = add(bigWheel, rfoot);\n    return add(bigWheel, sFloor);\n}\n\n\nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n        if(s.sd<RAY_MARCH_PRECI) {\n            return Surface(t+s.sd, s.mat);\n        }\n        t = t+s.sd;\n    }\n\n    return Surface(DIST_MAX, silver());\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.sd*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).sd-scene(vec3(p.x-e,p.y,p.z)).sd;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).sd-scene(vec3(p.x,p.y-e,p.z)).sd;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).sd-scene(vec3(p.x,p.y,p.z-e)).sd;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n\nvec3 shade(in Surface surf, in Ray ray) {\n    // shading vectors\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(vec3(1.));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // ambient\n    vec3 ambient = surf.mat.ambientColor;\n    \n    // diffuse\n    float dotLN = clamp(dot(l, n), 0., 1.);\n    vec3 diffuse = surf.mat.diffuseColor * dotLN;\n\n    // specular\n    float dotRV = clamp(dot(reflect(l, n), -r*v), 0., 1.);\n    vec3 specular = surf.mat.specularColor * pow(dotRV, surf.mat.alpha);\n\n    return ambient + diffuse + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n        \n    vec3 lp = vec3(0); // lookat point (aka camera target)\n    vec3 ro = vec3(0, 4, 0); // ray origin that represents camera position\n  \n    float cameraRadius = 4.;\n    ro.x = cameraRadius * cos(iTime*.1) + lp.x; // convert to polar \n    ro.z = cameraRadius * sin(iTime*.1) + lp.z;\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n    Ray r = Ray(ro, rd);\n    Surface s = march(r);\n    \n    // backgroundColor\n    vec3 c = vec3(.5,.5,1.);\n    \n    if(s.sd<DIST_MAX) {\n        c = shade(s,r);\n    }\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}