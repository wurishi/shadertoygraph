{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define alpha 0.0\n#define beta 10.0\n\n// Thanks to Lance for the insight on making more than 1 spiral branch\n#define NUM_BRANCHES 1.\n\n#define PI 3.14159\n\nvec4 getCornerColors(vec2 coord)\n{\n    vec4 cornerColors[4];\n\t\n    cornerColors[0] = vec4(1.0, 0, 0, 1.0);\n    cornerColors[1] = vec4(0, 0, 1.0, 1.0);\n    cornerColors[2] = vec4(0, 1.0, 0.0, 1.0);\n    cornerColors[3] = vec4(1.0, 1.0, 0.0, 1.0);\n        \n    vec2 cornerCoords[4];\n    cornerCoords[0] = vec2(0);\n    cornerCoords[1] = vec2(1, 0);\n    cornerCoords[2] = vec2(1);\n    cornerCoords[3] = vec2(0, 1);\n\n    \n\tvec4 result = vec4(0.0);\n\n\tfloat totalArea = dot(iResolution.xy, iResolution.xy);\n\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 cCoord = cornerCoords[i] * iResolution.xy;\n\n\t\tvec2 diff = coord - cCoord;\n\n\t\tfloat area = dot(diff, diff);\n\n\t\tresult += ((totalArea - area) / totalArea) * cornerColors[i];\n\t}\n\n\treturn result;\n}\n\nvec4 spiral4(vec2 coord)\n{\t\n\tfloat alpha_t = alpha - iTime * 50.0;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(dot(coord, coord));\n\n\tfloat phi = atan(y, x);\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 0.5)\n\t{\n\t\treturn vec4(vec3(0), 1.0);\n\t}\n\telse\n\t{\n\t\treturn vec4(vec3(remainder), 1.0);\n\t}\n}\n\nvec4 spiral5(vec2 coord)\n{\n\tfloat alpha_t = alpha - iTime * 50.;\n\n\t//coord = coord / fres;\n\n\t//coord = (2.0 * coord) - vec2(1.0);\n\n\t//coord = coord - (iResolution.xy * 0.5);\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(x * x + y * y);\n\n\tfloat phi = atan(y, x) * NUM_BRANCHES;\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\t//float remainder = abs(cos(phi) - cos(phi_r));\n\n\tfloat remainder = abs(sin(phi) - sin(phi_r));\n\n\tremainder += abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 1.0)\n\t{\n\t\tvec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n\n\t\tfloat t = (phi / (2. * PI)) + 0.5;\n\n\t\treturn mix(c1, c2, remainder);\n\t}\n\telse\n\t{\n        vec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n        return mix(c1, c2, remainder);\n\t}\n}\n\nvec4 spiral6(vec2 coord)\n{\n\tfloat alpha_t = alpha - iTime * 50.;\n\n\t//coord = coord / fres;\n\n\t//coord = (2.0 * coord) - vec2(1.0);\n\n\t//coord = coord - (iResolution.xy * 0.5);\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(x * x + y * y);\n\n\tfloat phi = atan(y, x) * -NUM_BRANCHES;\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\t//float remainder = abs(cos(phi) - cos(phi_r));\n\n\tfloat remainder = abs(sin(phi) - sin(phi_r));\n\n\tremainder += abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 1.0)\n\t{\n\t\tvec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n\n\t\tfloat t = (phi / (2. * PI)) + 0.5;\n\n\t\treturn mix(c1, c2, remainder);\n\t}\n\telse\n\t{\n        vec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n        return mix(c1, c2, remainder);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - (iResolution.xy * 0.5);\n\t//fragColor = spiral4(uv) * vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = spiral5(uv) * (getCornerColors(fragCoord.xy) * 0.5);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsBXWm","date":"1412632120","viewed":313,"name":"Spiral out","username":"toothmang","description":"Just an Archimedean spiral in GLSL.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","animation","polar"],"hasliked":0,"parentid":"","parentname":""}}