{"ver":"0.1","info":{"id":"4ccSD4","date":"1713897661","viewed":45,"name":"Mandlebulb Rendering","username":"MeHigh_","description":"Rendering a mandlebulb","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uniform float angle;\n\nvec3 toSphericalCoords(vec3 v) {\n    float r = sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n    float theta = atan(sqrt(v.x * v.x + v.y * v.y), v.z);\n    float phi = atan(v.y, v.x);\n    \n    return vec3(r, theta, phi);\n}\n\nmat3 rotY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\nfloat distEst(vec3 pos, float pow_, const int max_iter) {\n    vec3 zeta = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    \n    for(int n = 0; n > -1; n++) {\n        if(n > max_iter) break;\n        \n        vec3 c = toSphericalCoords(zeta);\n        \n        r = c.x;\n        if(r > 16.0) {\n            break;\n        }\n        \n        dr = pow(r, pow_ - 1.0) * pow_ * dr + 1.0;\n    \n        float newx = pow(c.x, pow_) * sin(c.y * pow_) * cos(c.z * pow_);\n        float newy = pow(c.x, pow_) * sin(c.y * pow_) * sin(c.z * pow_);\n        float newz = pow(c.x, pow_) * cos(c.y * pow_);\n    \n        zeta.x = newx + pos.x;\n        zeta.y = newy + pos.y;\n        zeta.z = newz + pos.z;\n    }\n    \n    return 0.5 * log(r) * r / dr;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat3 rot = rotY(iTime);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 pos = vec3(uv, 1.0);\n    pos.xy = pos.xy * 3.0 - 1.5;\n    \n    pos = rot * pos;\n    vec3 forward = rot * vec3(0.0, 0.0, 1.0);\n    \n    \n    float dist_est = 1.0;\n    float n = 0.0;\n    float total_dist = 0.0;\n\n    for(int i = 0; i > -1; i++) {\n        if(!(dist_est > 0.001 && total_dist < 2.0)) break;\n\n        dist_est = distEst(pos, 8.0, 100);\n        total_dist += dist_est;\n        pos -= forward * dist_est;\n        n += 1.0;\n    }\n\n    if(n > 255.0) n = 255.0;\n    if(total_dist >= 2.0) n = 255.0;\n    vec3 color = vec3(1.0);\n    \n    color *= abs(n/255.0 - 1.0);\n    color *= pow(color, vec3(0.4545));\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n   \n}","name":"Image","description":"","type":"image"}]}