{"ver":"0.1","info":{"id":"Xd2cWG","date":"1493590817","viewed":141,"name":"buggy stuff","username":"sigveseb","description":"test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["testing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n\n\nfloat sphere(vec3 position, float radius) {\n    return length(position) - radius;\n}\n\nfloat box(vec3 position, vec3 size) {\n    vec3 d = abs(position) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d ,0.));\n}\n\nfloat map(vec3 position) {\n    float size = 64.;\n    float radius = size / 2.;\n    float repeater = 1.;\n    float container = sphere(position, radius);\n    float amount = 0.5 * sin(position.x);\n    \n    //amount = .5;\n    \n    vec3 repeatedPosition = mod(position, repeater) - .5 * repeater;\n    float boxes = box(repeatedPosition, vec3(.5 * amount));\n    return max(boxes, container);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 cameraPosition = vec3(\n        2. * sin(iTime / 10.),\n        0.,\n        2. * cos(iTime / 10.));\n    vec3 cameraTarget = vec3(0.);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDirection = normalize(cameraTarget - cameraPosition);\n    vec3 cameraRight = normalize(cross(cameraPosition, upDirection));\n    vec3 cameraUp = cross(cameraDirection, cameraRight);\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= 16. / 9.;\n    vec3 rayDirection = normalize(\n        cameraRight * uv.x + cameraUp * uv.y + cameraDirection);\n\n\n    const int MAX_ITERATIONS = 512;\n    const float MAX_DISTANCE = 100000.0;\n    const float EPSILON = 0.00001;\n    float totalDistance = 0.0;\n    vec3 position = cameraPosition;\n    float distanceDelta = EPSILON;\n    \n    float steps = 0.;\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        steps = float(i);\n        if (distanceDelta < EPSILON ||\n            totalDistance > MAX_DISTANCE) {\n            break;\n        }\n        distanceDelta = map(position);\n        totalDistance += distanceDelta;\n        position += distanceDelta * rayDirection;\n    }\n\n    vec3 color = vec3(0.);\n    if(distanceDelta < EPSILON) {\n        vec2 epsilon = vec2(0., EPSILON);\n        vec3 surfaceNormal = normalize(vec3(\n            map(position + epsilon.yxx) - map(position - epsilon.yxx),\n            map(position + epsilon.xyx) - map(position - epsilon.xyx),\n            map(position + epsilon.xxy) - map(position - epsilon.xxy)));\n        float diffuse = max(0., dot(-rayDirection, surfaceNormal));\n        float specular = pow(diffuse, 32.);\n        color = vec3(diffuse + specular);\n    }\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}