{"ver":"0.1","info":{"id":"cd2GWd","date":"1671296508","viewed":187,"name":"\"Pocket Ink\" Font","username":"EisernSchild","description":"Since all glyphes Ascii 0-127 are calculated the full demonstration of this font needs a LONG TIME TO COMPILE.\nUse Mouse to scroll.","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["simple","bezier","font","ascii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Pocket Ink\" Font (simple)\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    Font \"Pocket Ink\"\n       \n    Define \"DEMO\" to \"1\" for full glyph set. Use Mouse to scroll !!\n    \n    WARNING : VERY LONG COMPILE TIMES HERE DUE TO FULL BASIC ASCII GLYPH SET (0..127)\n*/\n\n#define DEMO 0\n\n#define STRING_LEN 0x20\n#define str int[STRING_LEN]\n#define PI 3.141592654f\n\n// ascender height\nconst float fAsc = 1.f;\n// cap height\nconst float fCap = .8f;\n// mean height\nconst float fMea = .6f;\n// base height\nconst float fBse = .0f;\n// descender height\nconst float fDsc = -.35f;\n// font thickness (max .3f)\nconst float fR = .03f;\n// constant smooth factor here for now, adjust by zoom factor\nconst float fSmooth = 0.018f;\n// helper lines ? font styles ?\nbool \n    bDrawLines = false, \n    bGlitch = false,\n    bRising = false, \n    bHollow = true,\n    bLcd = false,\n    bShowStyles = true,\n    bDemoCamera = true, \n    bCycleColor = false,\n    bInvColor = false;\n// letter + line space\nconst float fLettSpc = fR, fLineSpc = 0.1f;\n\n// the width of each glyph (ASCII Idc x00-xff)\nconst float afGlyphW[256] = float[256](\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, // ASCII control chars (x00-x0f)\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, // ASCII control chars (x10-x1f)\n    .50f, .07f, .20f, .35f, .40f, .25f, .28f, .07f, .16f, .16f, .38f, .38f, .07f, .38f, .07f, .25f, //  !\"#$%&'()*+,-./    (x20-x2f)\n    .36f, .16f, .29f, .29f, .26f, .29f, .24f, .29f, .34f, .24f, .07f, .07f, .20f, .16f, .20f, .24f, // 0123456789:;<=>?    (x30-x3f)\n    .36f, .48f, .39f, .39f, .37f, .36f, .35f, .37f, .38f, .10f, .20f, .34f, .25f, .45f, .35f, .36f, // @ABCDEFGHIJKLMNO    (x40-x4f)\n    .32f, .36f, .38f, .40f, .36f, .44f, .44f, .36f, .36f, .33f, .36f, .23f, .36f, .23f, .24f, .43f, // PQRSTUVWXYZ[\\]^_    (x50-x5f)\n    .15f, .26f, .27f, .25f, .27f, .25f, .16f, .26f, .28f, .09f, .16f, .25f, .13f, .26f, .26f, .26f, // `abcdefghijklmno    (x60-x6f)\n    .21f, .25f, .25f, .31f, .18f, .35f, .35f, .31f, .25f, .24f, .25f, .22f, .06f, .22f, .35f, .00f, // pqrstuvwxyz{|}~     (x70-x7f)\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, // \n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, // TODO !! Idc x80 - xff\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f  //\n);\n\n#define XNEG vec2(-1.f, 1.f)\n#define CAP_0 vec2(.03f, fCap)\n#define CAP_1 vec2(.115f, fCap)\n#define CAP_2 vec2(.2f, fCap)\n#define CAP_3 vec2(.3f, fCap)\n#define CAP_4 vec2(.4f, fCap)\n#define CAP_5 vec2(.5f, fCap)\n#define CAP_2_N1 vec2(.2f, fCap - .1f)\n#define CAP_3_N1 vec2(.3f, fCap - .1f)\n#define CAP_5_N1 vec2(.5f, fCap - .1f)\n#define MEAN_0_0 vec2(.03f, fMea)\n#define MEAN_0_1 vec2(.03f, fMea + .1f)\n#define MEAN_1_0 vec2(.12f, fMea)\n#define MEAN_1_1 vec2(.12f, fMea + .1f)\n#define MEAN_2_0 vec2(.21f, fMea)\n#define MEAN_2_1 vec2(.21f, fMea + .1f)\n#define MEAN_3_0 vec2(.32f, fMea)\n#define MEAN_4_0 vec2(.4f, fMea)\n#define MEAN_5_0 vec2(.5f, fMea)\n#define MEAN_6_0 vec2(.62f, fMea)\n#define MEAN_0_N1 vec2(.03f, fMea - .1f)\n#define MEAN_2_N2 vec2(.21f, fMea - .2f)\n#define MEAN_3_N1 vec2(.3f, fMea - .1f)\n#define MEAN_3_N2 vec2(.3f, fMea - .2f)\n#define MEAN_N1_0 vec2(-.12f, fMea)\n#define BASE_0_0 vec2(.03f, fBse)\n#define BASE_0_1 vec2(.03f, .11f)\n#define BASE_0_2 vec2(.03f, .21f)\n#define BASE_0_3 vec2(.03f, .31f)\n#define BASE_0_4 vec2(.03f, .4f)\n#define BASE_0_5 vec2(.03f, .5f)\n#define BASE_1_0 vec2(.1f, fBse)\n#define BASE_1_1 vec2(.1f, .1f)\n#define BASE_1_2 vec2(.1f, .21f)\n#define BASE_1_3 vec2(.1f, .31f)\n#define BASE_1_4 vec2(.1f, .4f)\n#define BASE_2_0 vec2(.22f, fBse)\n#define BASE_2_1 vec2(.21f, .1f)\n#define BASE_2_2 vec2(.2f, .2f)\n#define BASE_2_3 vec2(.22f, .3f)\n#define BASE_2_4 vec2(.22f, .41f)\n#define BASE_3_0 vec2(.33f, fBse + .02f)\n#define BASE_3_1 vec2(.31f, .1f)\n#define BASE_3_2 vec2(.32f, .2f)\n#define BASE_3_3 vec2(.32f, .33f)\n#define BASE_3_4 vec2(.32f, .4f)\n#define BASE_4_0 vec2(.42f, fBse)\n#define BASE_4_1 vec2(.42f, .1f)\n#define BASE_4_2 vec2(.43f, .215f)\n#define BASE_4_3 vec2(.43f, .31f)\n#define BASE_5_0 vec2(.52f, fBse)\n#define BASE_5_2 vec2(.52f, .2f)\n#define BASE_6_3 vec2(.62f, .3f)\n#define BASE_7_1 vec2(.7f, .1f)\n#define BASE_0_N1 vec2(.03f, -.1f)\n#define BASE_2_N1 vec2(.2f, -.1f)\n#define BASE_N1_2 vec2(-.1f, .2f)\n#define BASE_N2_1 vec2(-.18f, .1f)\n#define BASE_N2_2 vec2(-.2f, .2f)\n#define BASE_N1_4 vec2(-.1f, .4f)\n#define DESC_0 vec2(.03f, fDsc + .03f)\n#define DESC_1 vec2(.1f, fDsc + .03f)\n#define DESC_2 vec2(.2f, fDsc + .03f)\n#define DESC_3 vec2(.3f, fDsc + .03f)\n#define DESC_4 vec2(.4f, fDsc + .03f)\n\n#define PB(a, b, c) fD = min(fD, sdBezier(vP, a, b, c))\n#define DL(a, b) fD = min(fD, udSegment(vP, a, b))\n\n// by Inigo Quilez : https://www.shadertoy.com/view/3tdSDj\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n// by Inigo Quilez : https://www.shadertoy.com/view/MlKcDD\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat sdBezier( vec2 p, vec2 v0, vec2 v1, vec2 v2 )\n{\n\tvec2 i = v0 - v2;\n    vec2 j = v2 - v1;\n    vec2 k = v1 - v0;\n    vec2 w = j-k;\n\n\tv0-= p; v1-= p; v2-= p;\n    \n\tfloat x = cro(v0, v2);\n    float y = cro(v1, v0);\n    float z = cro(v2, v1);\n\n\tvec2 s = 2.0*(y*j+z*k)-x*i;\n\n    float r =  (y*z-x*x*0.25)/dot(s,s);\n    float t = clamp( (0.5*x+y+r*dot(s,w))/(x+y+z),0.0,1.0);\n    \n\treturn length( v0+t*(k+k+t*w) );\n}\n\n// dashed line sdf ... based on segment sdf https://www.shadertoy.com/view/3tdSDj by IQ\nfloat sdLineDashed(in vec2 vP, in vec2 vA, in vec2 vB, in float fR, in float fDashL)\n{\n  vec2 vPA = vP - vA, vBA = vB - vA;\n  float fH = clamp( dot(vPA, vBA) / dot(vBA, vBA), 0.f, 1.f );\n  return length( vPA - vBA * fH ) - fR * step(.5f, fract(fH * length(vBA) * (1.f / fDashL)));\n}\n\n// draw a glyph (ascii 0..127)\nvoid Glyph(in vec2 vP, in uint uAscii, inout float fD)\n{    \n    if (uAscii == uint(0x21)) // !\n    {\n        DL(BASE_0_0, (BASE_0_0 + BASE_0_1) * .5f);\n        DL(BASE_0_2, MEAN_0_0);\n    }\n    else if (uAscii == uint(0x22)) // \"\n    {\n        DL(CAP_0, (CAP_0 + MEAN_0_0) * .5f);\n        DL(CAP_1, (CAP_1 + MEAN_1_0) * .5f);\n    }\n    else if (uAscii == uint(0x23)) // #\n    {\n        DL(BASE_1_1, MEAN_1_0);        \n        DL(BASE_2_1, MEAN_2_0);\n        DL(MEAN_0_N1, MEAN_3_N1);\n        DL(BASE_0_2, BASE_3_2);\n    }\n    else if (uAscii == uint(0x24)) // $\n    {\n        PB(BASE_2_3, BASE_0_2, BASE_0_4);\n        PB(BASE_2_4, MEAN_2_1, BASE_0_4);\n        PB(BASE_2_0, BASE_3_2, BASE_2_3);\n        PB(BASE_2_0, BASE_0_0, BASE_0_1);\n        DL(BASE_2_N1, MEAN_1_1);\n    }\n    else if (uAscii == uint(0x25)) // %\n    {\n        DL(BASE_0_0, MEAN_2_0);\n        DL(BASE_0_5, BASE_0_5);\n        DL(BASE_2_1, BASE_2_1);\n    }\n    else if (uAscii == uint(0x26)) // &\n    {\n        PB(BASE_2_0, BASE_0_2, BASE_0_4);\n        PB(BASE_2_4, MEAN_2_1, BASE_0_4);\n        PB(BASE_1_0, BASE_3_2, BASE_2_3);\n        PB(BASE_1_0, BASE_0_0, BASE_0_1);\n        DL(BASE_0_1, BASE_2_4);\n    }\n    else if (uAscii == uint(0x27)) // ' Single quote\n    {\n        DL(CAP_0, (CAP_0 + MEAN_0_0) * .5f);\n    }\n    else if (uAscii == uint(0x28)) // (\n    {\n        PB(DESC_1, BASE_0_4, CAP_1);\n    }\n    else if (uAscii == uint(0x29)) // )\n    {\n        PB(DESC_0, BASE_1_4, CAP_0);\n    }\n    else if (uAscii == uint(0x2a)) // *\n    {\n        DL((BASE_1_1 + BASE_2_1) * .5f, (MEAN_1_0 + MEAN_2_0) * .5f);        \n        DL(MEAN_0_N1, BASE_3_2);\n        DL(BASE_0_2, MEAN_3_N1);\n    }\n    else if (uAscii == uint(0x2b)) // +\n    {\n        DL((BASE_1_1 + BASE_2_1) * .5f, (MEAN_1_0 + MEAN_2_0) * .5f);        \n        DL((BASE_0_2 + MEAN_0_N1) * .5f, (BASE_3_2 + MEAN_3_N1) * .5f);\n    }\n    else if (uAscii == uint(0x2c)) // ,\n    {\n        DL(BASE_0_N1, BASE_0_0);\n    }\n    else if (uAscii == uint(0x2d)) // -\n    {\n        DL((BASE_0_2 + MEAN_0_N1) * .5f, (BASE_3_2 + MEAN_3_N1) * .5f);\n    }\n    else if (uAscii == uint(0x2e)) // .\n    {\n        DL(BASE_0_0, BASE_0_0);\n    }\n    else if (uAscii == uint(0x2f)) // /\n    {\n        DL(BASE_0_0, MEAN_2_0);\n    }\n    else if (uAscii == uint(0x30)) // 0\n    {\n        PB(MEAN_3_0, CAP_3, CAP_2);\n        PB(MEAN_0_0, CAP_0, CAP_2);\n        PB(MEAN_0_0, BASE_0_0, BASE_2_0);\n        PB(MEAN_3_0, BASE_3_0, BASE_2_0);\n        DL((BASE_0_2 + BASE_1_2) * .5f, MEAN_3_0);\n    }\n    else if (uAscii == uint(0x31)) // 1\n    {\n        PB(MEAN_0_0, MEAN_1_0, CAP_1);\n        DL(BASE_1_0, CAP_1);\n    }\n    else if (uAscii == uint(0x32)) // 2\n    {\n        PB(BASE_1_3, CAP_4, CAP_1);\n        PB(MEAN_0_0, CAP_0, CAP_1);\n        PB(BASE_0_0, BASE_0_2, BASE_1_3);\n        DL(BASE_0_0, BASE_2_0);\n    }\n    else if (uAscii == uint(0x33)) // 3\n    {\n        PB(BASE_1_4, CAP_4, CAP_1);\n        PB(MEAN_0_0, CAP_0, CAP_1);\n        PB(BASE_0_0, BASE_4_1, BASE_1_4);\n    }\n    else if (uAscii == uint(0x34)) // 4\n    {\n        DL(BASE_2_0, BASE_2_4);\n        DL(BASE_0_2, BASE_2_2);\n        PB(BASE_0_2, BASE_1_3, CAP_2);\n    }\n    else if (uAscii == uint(0x35)) // 5\n    {\n        PB(BASE_2_4, MEAN_1_0, MEAN_0_0);\n        DL(MEAN_0_0, CAP_0);\n        DL(CAP_0, CAP_2);\n        PB((BASE_1_0 + BASE_2_0) * .5f, BASE_3_2, BASE_2_4);\n        PB((BASE_1_0 + BASE_2_0) * .5f, BASE_0_1, BASE_0_2);\n    }\n    else if (uAscii == uint(0x36)) // 6\n    {\n        PB(BASE_0_2, MEAN_0_0, CAP_2);\n        PB(BASE_1_0, BASE_3_1, (MEAN_1_0 + MEAN_0_N1) * .5f);\n        PB(BASE_1_0, BASE_0_1, BASE_0_2);\n    }\n    else if (uAscii == uint(0x37)) // 7\n    {\n        DL(CAP_0, (CAP_2 + CAP_3) * .5f);\n        PB(BASE_0_0, BASE_1_4, (CAP_2 + CAP_3) * .5f);\n    }\n    else if (uAscii == uint(0x38)) // 8\n    {\n        PB((BASE_1_4 + BASE_2_4) * .5f, MEAN_N1_0, CAP_2);\n        PB((BASE_1_4 + BASE_2_4) * .5f, MEAN_4_0, CAP_2);\n        PB(BASE_1_0, BASE_4_1, (BASE_1_4 + BASE_2_4) * .5f);\n        PB(BASE_1_0, BASE_0_1, BASE_0_2);\n        PB(BASE_0_2, BASE_0_3, (BASE_1_4 + BASE_2_4) * .5f);\n    }\n    else if (uAscii == uint(0x39)) // 9\n    {\n        PB(MEAN_2_0, BASE_2_2, BASE_0_0);\n        PB(CAP_1, vec2(-.1f, fMea + .1f), (BASE_1_2 + BASE_2_3) * .5f);\n        PB(CAP_1, MEAN_2_1, MEAN_2_0);\n    }\n    else if (uAscii == uint(0x3a)) // :\n    {\n        DL(BASE_0_2, BASE_0_2);\n        DL(BASE_0_0, BASE_0_0);\n    }\n    else if (uAscii == uint(0x3b)) // ;\n    {\n        DL(BASE_0_2, BASE_0_2);\n        DL(BASE_0_N1, BASE_0_0);\n    }\n    else if (uAscii == uint(0x3c)) // <\n    {\n        DL(BASE_0_3, (MEAN_2_0 + BASE_1_4) * .5f);\n        DL(BASE_0_3, (BASE_1_2 + BASE_2_1) * .5f);\n    }\n    else if (uAscii == uint(0x3d)) // =\n    {\n        DL(BASE_0_4, BASE_1_4);\n        DL((BASE_0_2 + BASE_0_3) * .5f, (BASE_1_2 + BASE_1_3) * .5f);\n    }\n    else if (uAscii == uint(0x3e)) // >\n    {\n        DL((BASE_2_3 + BASE_1_3) * .5f, BASE_0_5);\n        DL((BASE_2_3 + BASE_1_3) * .5f, (BASE_0_1 + BASE_0_2) * .5f);\n    }\n    else if (uAscii == uint(0x3f)) // ?\n    {\n        PB(BASE_1_2, MEAN_3_0, MEAN_0_0);\n        DL(BASE_1_1, BASE_1_2);\n        DL(BASE_1_0, BASE_1_0);\n    }\n    else if (uAscii == uint(0x40)) // @\n    {\n        DL(BASE_2_3, BASE_2_4);\n        PB(BASE_2_4, BASE_0_2, BASE_2_2);\n        PB(BASE_2_2, BASE_4_3, MEAN_2_0);\n        PB(MEAN_2_0, BASE_1_2 * XNEG, BASE_2_0);\n    }\n    else if (uAscii == uint(0x41)) // A\n    {\n        DL(BASE_4_0, CAP_2);\n        PB(BASE_0_0, BASE_0_5, CAP_2);\n        DL(BASE_0_1, BASE_3_3);\n    }\n    else if (uAscii == uint(0x42)) // B\n    {\n        DL(BASE_0_0, CAP_0);\n        PB(BASE_0_0, BASE_7_1, BASE_0_5);\n        PB(MEAN_2_N2, CAP_5_N1, CAP_0);\n    }\n    else if (uAscii == uint(0x43)) // C\n    {\n        PB(BASE_2_0, BASE_N1_4, CAP_2);\n        PB(BASE_2_0, BASE_3_1, BASE_3_2);\n        PB(MEAN_3_0, CAP_3, CAP_2);\n    }\n    else if (uAscii == uint(0x44)) // D\n    {\n        PB(BASE_0_0, BASE_1_1, CAP_0);\n        PB(BASE_0_0, BASE_6_3, CAP_0);\n    }\n    else if (uAscii == uint(0x45)) // E\n    {\n        PB(BASE_0_0, BASE_1_1, CAP_0);\n        PB(BASE_0_0, BASE_2_0, BASE_3_1);\n        PB(CAP_0, CAP_3, CAP_3_N1);\n        DL(BASE_1_4, (BASE_2_4 + BASE_3_4) * .5f);\n    }\n    else if (uAscii == uint(0x46)) // F\n    {\n        PB(BASE_0_0, BASE_1_1, CAP_0);\n        PB(CAP_0, CAP_3, CAP_3_N1);\n        DL(BASE_1_4, (BASE_2_4 + BASE_3_4) * .5f);\n      }\n    else if (uAscii == uint(0x47)) // G\n    {\n        PB(BASE_2_0, BASE_N1_4, CAP_2);\n        PB(BASE_2_0, BASE_3_1, BASE_3_3);\n        PB(MEAN_3_0, CAP_3, CAP_2);       \n        PB(BASE_2_3, (BASE_2_3 + BASE_3_3) * .5f, BASE_3_3);\n    }\n    else if (uAscii == uint(0x48)) // H\n    {\n        PB(BASE_0_0, BASE_1_2, CAP_0);\n        PB(MEAN_0_N1, MEAN_2_N2, MEAN_3_N2);\n        DL(BASE_3_0, CAP_3);\n    }\n    else if (uAscii == uint(0x49)) // I\n    {\n        DL(BASE_0_0, CAP_0);\n    }\n    else if (uAscii == uint(0x4a)) // J\n    {\n        PB((BASE_1_0 + BASE_2_0) * .5f, MEAN_1_0, (CAP_0 + CAP_1) * .5f);\n        PB((BASE_1_0 + BASE_2_0) * .5f, BASE_1_0, BASE_0_1);\n    }\n    else if (uAscii == uint(0x4b)) // K\n    {\n        PB(BASE_0_0, BASE_1_2, CAP_0);\n        PB(BASE_3_0, BASE_3_4, MEAN_0_N1);\n        PB(BASE_2_4, MEAN_3_0, CAP_3);\n    }\n    else if (uAscii == uint(0x4c)) // L\n    {\n        DL(BASE_0_0, CAP_0);\n        PB(BASE_0_0, BASE_2_0, BASE_2_1);\n    }\n    else if (uAscii == uint(0x4d)) // M\n    {\n        PB(BASE_0_0, BASE_1_2, CAP_0);\n        PB(BASE_2_3, MEAN_0_0, CAP_0);\n        PB(BASE_2_3, MEAN_3_N2, CAP_4);\n        PB(BASE_4_0, MEAN_3_0, CAP_4);\n    }\n    else if (uAscii == uint(0x4e)) // N\n    {\n        PB(BASE_0_0, BASE_1_2, CAP_0);\n        PB(BASE_3_0, MEAN_0_0, CAP_0);\n        DL(BASE_3_0, CAP_3);\n    }\n    else if (uAscii == uint(0x4f)) // O\n    {\n        PB(MEAN_3_0, CAP_3, CAP_2);\n        PB(MEAN_0_0, CAP_0, CAP_2);\n        PB(MEAN_0_0, BASE_0_0, BASE_2_0);\n        PB(MEAN_3_0, BASE_3_0, BASE_2_0);\n    }\n    else if (uAscii == uint(0x50)) // P\n    {\n        PB(BASE_0_0, MEAN_1_0, CAP_0);\n        PB(BASE_1_4, MEAN_5_0, CAP_0);\n    }\n    else if (uAscii == uint(0x51)) // Q\n    {\n        PB(MEAN_3_0, CAP_3, CAP_2);\n        PB(MEAN_0_0, CAP_0, CAP_2);\n        PB(MEAN_0_0, BASE_0_0, BASE_2_0);\n        PB(MEAN_3_0, BASE_3_0, BASE_2_0);\n        PB(BASE_3_0, BASE_3_1, BASE_2_1);\n    }\n    else if (uAscii == uint(0x52)) // R\n    {\n        DL(BASE_0_0, CAP_0);\n        PB(MEAN_2_N2, CAP_5_N1, CAP_0);\n        PB(BASE_3_0, MEAN_3_N2, MEAN_0_N1);\n    }\n    else if (uAscii == uint(0x53)) // S\n    {\n        PB(BASE_2_4, MEAN_N1_0, CAP_2);\n        PB(MEAN_3_0, CAP_3, CAP_2);\n        PB(BASE_2_0, BASE_5_2, BASE_2_4);\n        PB(BASE_2_0, BASE_0_1, BASE_0_2);\n    }\n    else if (uAscii == uint(0x54)) // T\n    {\n        PB(BASE_2_0, BASE_1_0, (CAP_2 + CAP_2_N1) * .5f);\n        PB(CAP_0, CAP_1, (CAP_2 + CAP_2_N1) * .5f);\n        PB((CAP_2 + CAP_2_N1) * .5f, CAP_3_N1, CAP_3);\n    }\n    else if (uAscii == uint(0x55)) // U\n    {\n        PB(BASE_2_0, BASE_0_0, CAP_0);\n        PB(BASE_2_0, BASE_4_0, CAP_4);\n    }\n    else if (uAscii == uint(0x56)) // V\n    {\n        PB(BASE_2_0, BASE_0_3, CAP_0);\n        PB(BASE_2_0, BASE_4_3, CAP_4);\n    }\n    else if (uAscii == uint(0x57)) // W\n    {\n        PB(BASE_0_0, BASE_1_2, CAP_0);\n        PB(BASE_0_0, BASE_1_2, (BASE_1_4 + BASE_2_4) * .5f);\n        PB(BASE_3_0, BASE_3_2, (BASE_1_4 + BASE_2_4) * .5f);\n        PB(BASE_3_0, MEAN_3_0, (CAP_3 + CAP_2) * .5f);\n    }\n    else if (uAscii == uint(0x58)) // X\n    {\n        PB((BASE_1_4 + BASE_2_4) * .5f, MEAN_0_0, CAP_0);\n        PB((BASE_1_4 + BASE_2_4) * .5f, MEAN_2_0, CAP_3);\n        PB(BASE_0_0, BASE_1_2, (BASE_1_4 + BASE_2_4) * .5f);\n        PB(BASE_3_0, BASE_3_2, (BASE_1_4 + BASE_2_4) * .5f);\n    }\n    else if (uAscii == uint(0x59)) // Y\n    {\n        PB((BASE_1_4 + BASE_2_4) * .5f, MEAN_0_0, CAP_0);\n        PB((BASE_1_4 + BASE_2_4) * .5f, MEAN_2_0, CAP_3);\n        PB(BASE_1_0, BASE_2_3, (BASE_1_4 + BASE_2_4) * .5f);\n    }\n    else if (uAscii == uint(0x5a)) // Z\n    {\n        PB(BASE_0_0, BASE_0_2, CAP_3);\n        PB(CAP_0, CAP_2_N1, CAP_3);\n        PB(BASE_0_0, BASE_0_1, BASE_3_0);\n    }\n    else if (uAscii == uint(0x5b)) // [\n    {\n        DL(CAP_0, CAP_2);\n        DL(DESC_0, CAP_0);\n        DL(DESC_0, DESC_2);\n    }\n    else if (uAscii == uint(0x5c)) // \\ backslash\n    {\n        DL(MEAN_0_0, BASE_3_0);\n    }\n    else if (uAscii == uint(0x5d)) // ]\n    {\n        DL(CAP_0, CAP_2);\n        DL(DESC_2, CAP_2);\n        DL(DESC_0, DESC_2);\n    }\n    else if (uAscii == uint(0x5e)) // ^\n    {\n        DL(MEAN_0_0, CAP_1);\n        DL(MEAN_2_0, CAP_1);\n    }\n    else if (uAscii == uint(0x5f)) // _\n    {\n        DL(DESC_0, DESC_4);\n    }\n    else if (uAscii == uint(0x60)) // `\tGrave / accent\n    {\n        DL(MEAN_1_0, CAP_0);\n    }\n    else if (uAscii == uint(0x61)) // a\n    {\n        PB(BASE_2_0, BASE_2_3, MEAN_2_0);\n        PB(BASE_2_1, -(BASE_1_2 + BASE_2_2) * .5f, MEAN_2_0);\n    }\n    else if (uAscii == uint(0x62)) // b\n    {\n        DL(BASE_0_0, CAP_0);\n        PB(BASE_0_0, BASE_4_2, MEAN_0_0);\n    }\n    else if (uAscii == uint(0x63)) // c\n    {\n        PB(MEAN_1_0, BASE_0_3, BASE_0_1);\n        PB(BASE_1_0, BASE_0_0, BASE_0_1);\n        PB(BASE_1_0, BASE_2_1, BASE_2_2);\n        PB(BASE_2_4, MEAN_2_0, MEAN_1_0);\n    }\n    else if (uAscii == uint(0x64)) // d\n    {\n       DL(MEAN_2_0, CAP_2);\n       PB(BASE_2_0, BASE_2_3, MEAN_2_0);\n       PB(BASE_2_1, -(BASE_1_2 + BASE_2_2) * .5f, MEAN_2_0);\n    }\n    else if (uAscii == uint(0x65)) // e\n    {\n        PB(MEAN_1_0, BASE_0_3, BASE_0_1);\n        PB(BASE_1_0, BASE_0_0, BASE_0_1);\n        PB(BASE_1_0, BASE_2_0, BASE_2_1);\n        PB(BASE_2_4, MEAN_2_0, MEAN_1_0);\n        DL(BASE_0_1, BASE_2_4);\n    }\n    else if (uAscii == uint(0x66)) // f\n    {\n        PB(BASE_1_0, MEAN_0_0, CAP_1);\n        DL(CAP_1, (CAP_1 + MEAN_1_0) * .5f);\n        DL(MEAN_0_0, MEAN_1_0);\n    }\n    else if (uAscii == uint(0x67)) // g\n    {\n        PB(BASE_2_0, BASE_2_3, MEAN_2_0);\n        PB(BASE_2_1, -(BASE_1_2 + BASE_2_2) * .5f, MEAN_2_0);\n        PB(DESC_1, DESC_0, (BASE_0_0 + DESC_0) * .5f);\n        PB(DESC_1, DESC_2, BASE_2_0);\n    }\n    else if (uAscii == uint(0x68)) // h\n    {\n        DL(BASE_0_0, CAP_0);\n        PB(BASE_2_0, BASE_3_3, MEAN_0_0);\n    }\n    else if (uAscii == uint(0x69)) // i\n    {\n        PB(BASE_0_0, (BASE_0_1 + BASE_1_2) * .5f, MEAN_0_0);\n        DL(CAP_0, (CAP_0 + MEAN_0_0) * .5f);\n    }\n    else if (uAscii == uint(0x6a)) // j\n    {\n        PB(DESC_1, (BASE_1_1 + BASE_2_2) * .5f, MEAN_1_0);\n        PB(DESC_1, DESC_0, (BASE_0_0 + DESC_0) * .5f);\n    }\n    else if (uAscii == uint(0x6b)) // k\n    {\n        DL(BASE_0_0, CAP_0);\n        PB(BASE_2_0, BASE_2_2, BASE_0_3);\n        DL(BASE_0_3, MEAN_2_0);\n    }\n    else if (uAscii == uint(0x6c)) // l\n    {\n        PB(BASE_1_0, -BASE_0_1, CAP_0);\n    }\n    else if (uAscii == uint(0x6d)) // m\n    {\n        DL(BASE_0_0, MEAN_0_0);\n        PB(BASE_1_2, MEAN_1_0, MEAN_0_0);\n        DL(MEAN_1_0, BASE_1_2);\n        PB(BASE_2_0, MEAN_2_0, MEAN_1_0);\n    }\n    else if (uAscii == uint(0x6e)) // n\n    {\n        DL(BASE_0_0, MEAN_0_0);\n        PB(BASE_2_0, MEAN_2_0, MEAN_0_0);\n    }\n    else if (uAscii == uint(0x6f)) // o\n    {\n        PB((MEAN_2_0 + BASE_2_0) * .5f, MEAN_2_0, MEAN_1_0);\n        PB((MEAN_0_0 + BASE_0_0) * .5f, MEAN_0_0, MEAN_1_0);\n        PB((MEAN_0_0 + BASE_0_0) * .5f, BASE_0_0, BASE_1_0);\n        PB((MEAN_2_0 + BASE_2_0) * .5f, BASE_2_0, BASE_1_0);\n    }\n    else if (uAscii == uint(0x70)) // p\n    {\n        DL(DESC_0, MEAN_0_0);\n        PB(MEAN_0_0, BASE_3_2, BASE_0_0);\n    }\n    else if (uAscii == uint(0x71)) // q\n    {\n        DL(BASE_2_0, DESC_2);\n        PB(BASE_2_0, BASE_2_3, MEAN_2_0);\n        PB(BASE_2_1, -(BASE_1_2 + BASE_2_2) * .5f, MEAN_2_0);\n    }\n    else if (uAscii == uint(0x72)) // r\n    {\n        DL(BASE_0_0, MEAN_0_0);\n        PB(BASE_2_4, MEAN_2_0, MEAN_0_0);\n    }\n    else if (uAscii == uint(0x73)) // s\n    {\n        PB(BASE_2_3, BASE_0_2, BASE_0_4);\n        PB(BASE_2_4, MEAN_2_1, BASE_0_4);\n        PB(BASE_2_0, BASE_3_2, BASE_2_3);\n        PB(BASE_2_0, BASE_0_0, BASE_0_1);\n    }\n    else if (uAscii == uint(0x74)) // t\n    {   \n        PB(BASE_1_0, BASE_0_1, CAP_1);\n        DL(MEAN_0_0, MEAN_1_0);\n    }\n    else if (uAscii == uint(0x75)) // u\n    {\n        PB((BASE_1_0 + BASE_2_0) * .5f, BASE_0_0, MEAN_0_0);\n        PB((BASE_1_0 + BASE_2_0) * .5f, BASE_3_0, MEAN_3_0);\n    }\n    else if (uAscii == uint(0x76)) // v\n    {\n        PB((BASE_1_0 + BASE_2_0) * .5f, BASE_0_3, MEAN_0_0);\n        PB((BASE_1_0 + BASE_2_0) * .5f, BASE_3_3, MEAN_3_0);\n    }\n    else if (uAscii == uint(0x77)) // w\n    {\n        PB(BASE_0_0, BASE_1_2, MEAN_0_0);\n        PB(BASE_0_0, BASE_1_2, (BASE_1_4 + BASE_2_4) * .5f);\n        PB((BASE_2_0 + BASE_3_0) * .5f, BASE_2_3, (BASE_1_4 + BASE_2_4) * .5f);\n        DL((BASE_2_0 + BASE_3_0) * .5f, (MEAN_2_0 + MEAN_3_0) * .5f);\n    }\n    else if (uAscii == uint(0x78)) // x\n    {\n        DL(BASE_0_0, MEAN_2_0);\n        DL(BASE_2_0, MEAN_0_0);\n    }\n    else if (uAscii == uint(0x79)) // y\n    {\n        DL(BASE_1_3, MEAN_2_0);\n        DL(BASE_1_3, MEAN_0_0);\n        DL(BASE_1_3, BASE_1_0);\n    }\n    else if (uAscii == uint(0x7a)) // z\n    {\n        PB(BASE_0_0, BASE_0_3, MEAN_2_0);\n        DL(MEAN_0_0, MEAN_2_0);\n        PB(BASE_0_0, BASE_0_1, BASE_2_0);\n    }\n    else if (uAscii == uint(0x7b)) // {\n    {\n        PB(BASE_1_2, CAP_0, CAP_2);\n        PB(DESC_2, DESC_0, BASE_1_2);\n    }\n    else if (uAscii == uint(0x7c)) // |\n    {\n        DL(DESC_0, CAP_0);\n    }\n    else if (uAscii == uint(0x7d)) // }\n    {\n        PB(BASE_1_2, CAP_2, CAP_0);\n        PB(DESC_0, DESC_2, BASE_1_2);\n    }\n    else if (uAscii == uint(0x7e)) // -\n    {\n        PB(BASE_0_2, BASE_0_3, (BASE_2_2 + BASE_2_3) * .5f);\n        PB((BASE_2_2 + BASE_2_3) * .5f, BASE_3_2, BASE_3_3);\n    }\n}\n\n// print a string\nvoid PrintStr(in vec2 vP, in str auTxt, in float fCharSpc, inout float fD)\n{\n    float afGlyphX[STRING_LEN];\n    \n    // out of bounds vertically or negative x ?\n    if ((vP.y < fDsc) || (vP.y > fAsc) || (vP.x < 0.f)) return;\n    \n    // calculate line length and glyph x position... in your project you would precalculate that within your c++ code\n    float fLineL = afGlyphW[auTxt[0]] + fCharSpc;\n    afGlyphX[0] = 0.f;\n    for (int nI = 1; nI < STRING_LEN; nI++)\n    {\n        // set glyph x position\n        afGlyphX[nI] = fLineL;\n\n        // clamp index to byte\n        if (auTxt[nI] > 0xff) continue;\n        \n        // get glyph index\n        uint uAscii = uint(auTxt[nI]);\n        \n        // for (space) and (_) there is no character spacing\n        if ((uAscii != uint(0x20)) && (uAscii != uint(0x5b))) fLineL += fCharSpc;\n        \n        // add glyph width\n        fLineL += afGlyphW[auTxt[nI]];\n    }\n    \n    // out of bounds positive x ?\n    if (vP.x >= (fLineL - fCharSpc)) return;\n    \n    // get glyph index\n    int nIx = 0;\n    for (; nIx < STRING_LEN; nIx++)\n        if (vP.x < (afGlyphX[nIx] + afGlyphW[auTxt[nIx]])) break;\n        \n    // print glyph\n    uint uAscii = uint(auTxt[nIx]);\n    vec2 vGP = vP + vec2(-afGlyphX[nIx],0.);\n    Glyph(vGP, uAscii, fD);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// lcd effect...\nvec4 lcd(vec4 c, vec2 vU, float fN)\n{\n    // noise\n    c.rgb -= min(fN, hash12(vU + mod(iTime, 100.f)));\n    \n    // shift, adjust\n    ivec2 vXy = ivec2(mod(vU,3.f));\n    c.rgb = vec3((vXy.x == 1) ? c.g : c.r, (vXy.x == 2) ? c.b : c.g, (vXy.x == 3) ? c.r : c.b);\n    c.rgb = vec3((vXy.y == 1) ? pow(c.r, 2.f) : c.r, \n                 (vXy.y == 2) ? pow(c.g, .5f) : c.g, \n                 (vXy.y == 3) ? pow(c.b, .1f) : c.b);\n    return c;\n}\n\n// simple palette by Inigo Quilez : https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos( 6.28318f * (c * t + d) );\n}\n\nvoid mainImage( out vec4 cO, in vec2 vU )\n{\n    // normalize, zoom, offset\n    vec2 vP = vU/iResolution.xy;\n    if (iMouse.z > 0.f)\n    {\n        vP *= 3.5f;\n        vP += vec2(10.f, -1.f) + abs(iMouse.xy / iResolution.xy) * vec2(-10.f, -3.5f);\n    }\n    else\n    {\n        if (bDemoCamera) vP *= 1.5f + sin(mod(iTime * .2f, 3.14f)); else vP *= 4.5f;\n        vP -= vec2(.1f, .5f);\n        if (bDemoCamera) vP.x += 8.f * sin(mod(iTime * .03f, 3.14f));\n#if (DEMO == 1)\n        if (bDemoCamera) vP.y -= 4.f * sin(mod(iTime * .041f, 3.14f));\n#endif\n    }\n    \n    // style demonstration ?\n    if (bShowStyles)\n    {\n        float fTimer = mod(iTime - vU.y / iResolution.y - sin((vU.x / iResolution.x) * 64.f) * .03f, 18.f);\n        bLcd = (fTimer < 9.f);\n        bHollow = (mod(fTimer, 6.f) < 3.f);\n        bRising = (mod(fTimer, 9.f) < 4.5f);\n    }\n    \n    if ((bGlitch) && (!bShowStyles))\n    {\n        // scanline glitch by gimbo : https://www.shadertoy.com/view/Xd2BWt\n        float fIv = 18.3f;\n        vec2 vGlitchOff = vec2(0.f,\n            clamp(sin(fIv*iTime),0.,1.)*\n            clamp(sin(fIv*iTime*3.),0.,1.)*\n            clamp(sin(fIv*iTime*17.),0.,1.)*\n            clamp(sin(fIv*iTime*13.),0.,1.)\n                        *sin(vP.x*600.*sin(iTime)+iTime*10.));\n        vP += vGlitchOff * .1f;\n    }\n    \n    // print red helper lines ?\n    float fL = 1.f;\n    if (bDrawLines)\n    {\n        // ascender, mean, base, descender helper lines\n        fL = smoothstep(.0, .01, sdLineDashed(vP, vec2(-100.f, fCap), vec2(100.f, fCap), .01f, .05f) + .01f);\n        fL = min(fL, smoothstep(.0, .01, sdLineDashed(vP, vec2(-100.f, fMea), vec2(100.f, fMea), .01f, .05f) + .01f));\n        fL = min(fL, smoothstep(.0, .01, sdLineDashed(vP, vec2(-100.f, fBse), vec2(100.f, 0.f), .01f, .05f) + .01f));\n        fL = min(fL, smoothstep(.0, .01, sdLineDashed(vP, vec2(-100.f, fDsc), vec2(100.f, fDsc), .01f, .05f) + .01f));\n        fL = min(fL, smoothstep(.0, .01, sdLineDashed(vP, vec2(0.f, fCap), vec2(0.f, fDsc), .01f, .05f) + .01f));\n    }\n    fL = 1.f - fL;\n\n    // fields\n    float fD = 10000.f;\n    float fLineYN = abs(fDsc) + fLineSpc;\n    float fLineY = fAsc + fLineYN;\n\n#if (DEMO == 1)\n    // text data\n    const int auL00[STRING_LEN] = int[STRING_LEN](32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63);\n    const int auL01[STRING_LEN] = int[STRING_LEN](64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95);\n    const int auL02[STRING_LEN] = int[STRING_LEN](96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127);\n    const int auL03[STRING_LEN] = int[STRING_LEN](66, 108, 111, 119, 122, 121, 32, 110, 105, 103, 104, 116, 45, 102, 114, 117, 109, 112, 115, 32, 118, 101, 120, 39, 100, 32, 74, 97, 99, 107, 81, 46);\n\n    // print strings\n    PrintStr(vP, auL00, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n    PrintStr(vP, auL01, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n    PrintStr(vP, auL02, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n    PrintStr(vP, auL03, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n\n#else\n    // one string\n    const int auL00[STRING_LEN] = int[STRING_LEN](35, 100, 101, 102, 105, 110, 101, 32, 68, 69, 77, 79, 32, 49, 32, 61, 62, 32, 40, 108, 111, 110, 103, 32, 99, 111, 109, 112, 105, 108, 101, 41);\n    PrintStr(vP, auL00, fLettSpc, fD);\n    \n#endif\n    \n    // style ?\n    float fRr = bRising ? mod(vP.y + fLineYN, fLineY) * fR : fR;\n    float fA = bHollow ? fD < (fRr * .5f) ? (fRr * .5f - fD) / (fRr * .5f) : (fD - fRr * .5f) / (fRr * .5f) : fD / fRr;\n    \n    // occlusion\n    fA = 1. - fA * fA;\n    fA = fA <= 0.f ? 0.f : clamp(sqrt(fA), 0.f, 1.f);\n    \n    if (bLcd)\n    {\n        // lcd screen\n        vec4 cLcd = lcd(bCycleColor ? vec4(1.f) : vec4(.3f, 1.f, .5f ,1.f), vU, .3f);\n        cO = mix(vec4(.0f, .0f, .0f, 1.f), cLcd, fA);\n    }\n    else\n        cO = vec4(max(fA, fL), min(fA, 1.f), min(fA, 1.f) , 1.f);\n    \n    if (bCycleColor)\n        cO.rgb *= clamp(\n                    pal(fract(floor(iTime) * .1f), \n                      vec3(0.8,0.5,0.4), vec3(0.2,0.4,0.2), vec3(2.0,1.0,1.0), vec3(0.0,0.25,0.25) ), \n                    0.f, 1.f);\n                    \n    if (bInvColor)\n        cO.rgb =  vec3(1.f) - clamp(cO.rgb, 0.f, 1.f);\n}","name":"Image","description":"","type":"image"}]}