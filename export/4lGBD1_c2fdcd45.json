{"ver":"0.1","info":{"id":"4lGBD1","date":"1542307089","viewed":408,"name":"Gear tower","username":"Flopine","description":"Shader made in 20 minutes during GROW Shader Showdown in Paris. The colours and the pixellate effect were supposed to represent an old gameboy style, as the music was generated on gameboys by https://twitter.com/cyanidedansen  <3","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","gameboy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n\n#define time iTime\n#define ITER 64.\n#define PI 3.141592\n#define beat (50./60.)\n\nmat2 rot(float a)\n{ return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\n\nvec2 moda(vec2 p, float per)\n{\n    float a = atan(p.x,p.y);\n    float l = length(p);\n    a = mod(a-per/2., per) -per/2.;\n    return vec2 (cos(a),sin(a))*l;\n}\n\nfloat cylY(vec3 p, float r, float h)\n{\n    return max(length(p.xz)-r, abs(p.y)-h);\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nfloat gears(vec3 p, float c_size)\n{\n    float c = max(-cylY(p,0.4, 10.),cylY(p,1.,0.2));\n    p.xz = moda(p.xz, 2.*PI/7.);\n    p.x -= 1.;\n    float b = box(p, vec3(0.2));\n    return min(b,c);\n}\n\nfloat prim1 (vec3 p)\n{\n  \tfloat c= cyl(p.xz, 0.3);\n  \n  \tfloat p_mod = fract(p.y - 0.5);\n  \tfloat p_index = floor(p.y - 0.5);\n  \n\tfloat t0 = floor(time*beat);\n    float t1 = fract(time*beat);\n    t1 = pow(t1, 6.);\n    float anim = (PI/2.)*(t0+t1);\n    \n    p.y = p_mod - 0.5;\n    if (mod(p_index, 2.)==0.) p.xz *= rot(anim);\n    else p.xz *= rot(-anim);\n    float g = gears(p, 0.);\n    return min(c,g);\n}\n\n\nfloat SDF(vec3 p)\n{\n    vec3 pp = p;\n    float per = 5.;\n    p.xz = mod(p.xz - per/2., per) - per/2.;\n    float pr1 = prim1(p);\n\n    p = pp;\n    float per2 = 10.;\n    p.xy = mod(p.xy, per) - per/2.;\n    p.yz *= rot(PI/2.);\n    float pr2 = prim1(p);\n\n    return min(pr1,pr2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy) -1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    \n  \tfloat detail = 80.;\n  \tuv = floor(uv*detail) / detail;\n\n  \tvec3 ro = vec3(-1.,0.001 + time,-2.); vec3 p = ro;\n\tvec3 rd = normalize(vec3(uv,1.));\n\n    float shad = 0.;\n        for (float i = 0.; i<ITER; i++)\n        {\n            float d = SDF(p);\n            if (d<0.001)\n            {\n              shad = i/ITER;\n            \tbreak;\n            }\n       \t\tp+=d*rd;\n        }\n\n    float t = length(ro-p);\n\n\n\tvec3 col = vec3(shad) * 0.3;\n\tcol = mix(col, vec3(131.0,145.0,0.)/255.0, 1.-exp(-0.002*t*t));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}