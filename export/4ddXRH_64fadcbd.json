{"ver":"0.1","info":{"id":"4ddXRH","date":"1457659028","viewed":530,"name":"Playing with splines","username":"JohanKohler","description":"Playing around with beziers, trying to find a way to get a bounding area so I can limit where the more complex part of the rootsolver is run. No luck so far.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["bezier","spline","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Playing around with beziers, trying to find a way to get a bounding area \n// so I can limit where the more complex part of the rootsolver is run. \n// No luck so far.\n// There is code to turn a quadratic spline into a parabola, might be usefull for something.\n\n// Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by http://www.pouet.net/topic.php?which=9119\n// and various shaders by iq, T21, and demofox\n// \n// I needed the -signed- distance to a quadratic bezier\n// curve but couldn't find any examples online that\n// were both fast and precise. This is my solution.\n//\n// v1 - Initial release\n// v2 - Faster and more robust sign computation\n//\n\n// #define TURN_QUADRATIC_SPLINE_INTO_PARABOLA\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\nfloat sdLine(vec2 a, vec2 b, vec2 p)\n{\n    a -= p;\n    b -= p;\n    vec2 ba = b-a;\n    return length(a + ba * clamp( -dot(a,ba)/dot(ba,ba),0.0,1.0));\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p, out vec3 color)\n{   \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n\tfloat dd[3];\n    color = vec3(0.0,0.0,1.0);\n    dd[0] = dis;\n    dd[1] = length(pos - p);\n    dis = min(dis, dd[1]);\n    pos = A + (c + b*t.z)*t.z;\n    dd[2] = length(pos - p);\n    dis = min(dis, dd[2]);\n    color = vec3(0.0,0.0,0.0);\n    if(dis == dd[0])\n    {\n       color += vec3(0.0,0.0,1.0) * vec3(t.x == 0.0 || t.x == 1.0 ? 0.5 : 1.0);\n    }\n    if(dis == dd[1])\n    {\n       color += vec3(0.0,1.0,0.0) * vec3(t.y == 0.0 || t.y == 1.0 ? 0.5 : 1.0);\n    }\n    if(dis == dd[2])\n    {\n       color += vec3(1.0,0.0,0.0) * vec3(t.z == 0.0 || t.z == 1.0 ? 0.5 : 1.0);\n    }\n    if(dis == 1.0 || dis == 0.0 || (dd[0] == dd[1] && dd[1] == dd[2]))\n    {\n       color *= vec3(0.5);\n    }\n    return dis;\n}\n\nvec2 EvalQuadratic(vec2 A, vec2 B, vec2 C, float t)\n{\n    return (1.0-t)*(1.0-t)*A + 2.0*(1.0-t)*t*B + t*t*C;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.0, -0.6), C = vec2(0.1, +0.4), B = (4.0 * m - A - C) / 2.0;\n    // Render the control points\n    float d = min(distance(p, A),(min(distance(p, m),distance(p, C))));\n    vec3 color = vec3(1.0);\n\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n    \n    {\n        mat2 seg;\n        seg[1]= normalize((C+A)*0.5-B);\n        seg[0] = vec2(seg[1].y,-seg[1].x);\n        \n#if 0\n        d = min(sdLine(A,A-seg[0]*1.0,p),d);\n        d = min(sdLine(A,A-seg[1]*1.0,p),d);\n        if (d < 0.04/4.0) { fragColor = vec4(1.0 - smoothstep(0.025/4.0, 0.034/4.0, d)); return; }\n#endif\n        vec2 AA = A * seg;\n        vec2 BB = B * seg;\n        vec2 CC = C * seg;\n#if 0\n        float s = (AA.y-BB.y) / (AA.y-2.0*BB.y+CC.y);\n        vec2 mm = EvalQuadratic(A,B,C,s);\n\n        d = distance(mm,p);\n\t    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n#else\n        \n#ifdef TURN_QUADRATIC_SPLINE_INTO_PARABOLA\n        float s = (AA.y-BB.y) / (AA.y-2.0*BB.y+CC.y);\n        vec2 mm = EvalQuadratic(AA,BB,CC,s);\n        AA -= mm;\n        BB -= mm;\n        CC -= mm;\n        float k = sqrt(AA.y) / AA.x;\n\n        d = distance(EvalQuadratic(AA,BB,CC,0.5),p);\n\t    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n\n        d = distance(AA,p);\n\t    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n        d = distance(BB,p);\n\t    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n        d = distance(CC,p);\n\t    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n\n        A = AA;\n        B = BB;\n        C = CC;\n        //p = p * seg;\n        //p -= mm;\n        d = 8.0;\n\n        \n        for(float v = 0.0;v <= 0.5; v += 0.025)\n        {\n            float a = p.x < 0.0 ? -v : v;\n            d = min(d, distance(p,vec2(a,(a*k)*(a*k))));\n        }\n\t    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n#endif\n        \n\n#if 0\n        d = 8.0;\n        float f = (p.x*k)*(p.x*k) - p.y;\n        float slope = dFdy(f) / dFdy(p.x);\n        d = abs(f) /length(vec2(slope, -1.0));\n#endif\n        \n#if 0\n        float s = sqrt((2.0*BB.y - 2.0*AA.y) * (2.0*BB.y - 2.0*AA.y) - 2.0*AA.y*(A.y - 2.0*BB.y+CC.y));\n        float iA = ((2.0*AA.y-2.0*BB.y) + s) / (2.0*(AA.y-2.0*BB.y+CC.y));\n        float iC = ((2.0*AA.y-2.0*BB.y) - s) / (2.0*(AA.y-2.0*BB.y+CC.y));\n        A = AA;\n        B = BB;\n        C = CC;\n        AA = EvalQuadratic(A,B,C,iA);\n        CC = EvalQuadratic(A,B,C,iC);\n        vec2 mm = EvalQuadratic(A,B,C,(iA+iC)*0.5);\n        A = AA;\n        C = CC;\n        B = (4.0 * mm - A - C) / 2.0;\n#endif\n#endif\n    }\n\n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p, color);\n    \n    // Visualize the distance field using iq's orange/blue scheme\n    fragColor = vec4(color,1.0);\n    fragColor *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}","name":"Image","description":"","type":"image"}]}