{"ver":"0.1","info":{"id":"Mc3cRN","date":"1730318943","viewed":61,"name":"Fork Gingerbrea AtCat 261","username":"AtCat","description":"base code for ray marching","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raymarch","learning"],"hasliked":0,"parentid":"XftyR8","parentname":"Gingerbread Face Base"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PROCEDURAL GINGERBREAD FACE\n#define RAD(degree) degree * 3.14159265358978 * 0.0055556\n\n\nvec3 eyeBrowQueryPos(vec3 queryPos, vec3 eyeBrowPos, float angle)\n{\n    return rotatePointAroundAxis(queryPos - eyeBrowPos, vec3(0, 0, 1), RAD(angle)) + eyeBrowPos;\n}\n\nfloat faceSDF(vec3 queryPos)\n{\n    // Procedural Face Attributes\n    // These should all be values [0, 1]\n    //float EYE_SEPARATION = sin(iTime) * 0.5 + 0.5;\n    float EYE_SEPARATION = 0.5;\n    float SUPRISE = sin(iTime * 2.0) * 0.5 + 0.5;\n    float HAPPINESS = sin(iTime * 2.0 + 3.14) * 0.5 + 0.5;\n    \n    float ball = sphereSDF(queryPos, vec3(0.0, 1.0, 0.0), 2.0);\n\n    float eyePosition = mix(0.5, 0.9, EYE_SEPARATION);\n    vec3 scale = vec3(0.9 + 0.1 * HAPPINESS, 0.5 + 0.1 * HAPPINESS, 0.9 + 0.1 * HAPPINESS);\n    float eyeLeft = sphereSDF(queryPos, vec3(-eyePosition, 0.9 - 0.1 * SUPRISE, 2.0), 0.3 + 0.05 * SUPRISE);\n    float eyeRight = sphereSDF(queryPos, vec3(eyePosition, 0.9 - 0.1 * SUPRISE, 2.0), 0.3 + 0.05 * SUPRISE);\n    \n    float supriseAngle = mix(0.0, 20.0, SUPRISE);\n    float happyAngle = mix(0.0, -10.0, HAPPINESS);\n    float eyeBrowLeft = capsuleSDF(eyeBrowQueryPos(queryPos, vec3(-0.7, 1.5, 2.0), mix(supriseAngle, happyAngle, HAPPINESS / (SUPRISE + HAPPINESS))), vec3(-0.5, 1.5, 2.0), vec3(-0.9, 1.5, 2.0), 0.1);\n    float eyeBrowRight = capsuleSDF(eyeBrowQueryPos(queryPos, vec3(0.7, 1.5, 2.0), mix(-supriseAngle, -happyAngle, HAPPINESS / (SUPRISE + HAPPINESS))), vec3(0.5, 1.5, 2.0), vec3(0.9, 1.5, 2.0), 0.1);\n\n    float mouthBase = sphereSDF(queryPos, vec3(0.0, -0.2, 1.5), 0.5 * (SUPRISE * 0.8 + 0.2));\n    \n    // happy mouth\n    scale = vec3(2.0 + 2.0 * (HAPPINESS), HAPPINESS, 1.0);\n    float mouthHappy = sphereSDF(queryPos / scale, vec3(0.0, -0.2, 1.5), 0.5) * min(scale.x, min(scale.y, scale.z));\n    mouthBase = mix(mouthBase, mouthHappy, HAPPINESS);\n    \n    float eyes = smoothUnion(eyeRight, eyeLeft, 0.1);\n    float eyebrows = smoothUnion(eyeBrowLeft, eyeBrowRight, 0.1);\n    float eyeStuff = smoothUnion(eyes, eyebrows, 0.0);\n    float faceBase = smoothSubtraction(mouthBase, ball, 0.05);\n    return smoothUnion(faceBase, eyeStuff, 0.1);\n}\n\n\nfloat sceneSDF(vec3 queryPos) \n{\n    float model1 = faceSDF(queryPos);\n    \n    return model1;\n\n    float plane = planeSDF(queryPos, 0.0);\n        \n    //return smoothUnion(plane, smoothUnion(smoothUnion(model2, model1, 0.25), model3, 0.25), 0.25);\n}\n\n\nRay getRay(vec2 uv) {\n    Ray ray;\n    \n    float len = tan(3.14159 * 0.125) * distance(EYE, REF);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), REF - EYE));\n    vec3 V = normalize(cross(H, EYE - REF));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = REF + uv.x * H + uv.y * V;\n    vec3 dir = normalize(p - EYE);\n    \n    ray.origin = EYE;\n    ray.direction = dir;\n    return ray;\n}\n\nIntersection getRaymarchedIntersection(vec2 uv)\n{\n    Ray ray = getRay(uv);\n    Intersection intersection;\n    \n    vec3 queryPoint = ray.origin;\n    for (int i=0; i < MAX_RAY_STEPS; ++i)\n    {\n        float distanceToSurface = sceneSDF(queryPoint);\n        \n        if (distanceToSurface < EPSILON)\n        {\n            \n            intersection.position = queryPoint;\n            intersection.normal = vec3(0.0, 0.0, 1.0);\n            intersection.distance = length(queryPoint - ray.origin);\n            \n            return intersection;\n        }\n        \n        queryPoint = queryPoint + ray.direction * distanceToSurface;\n    }\n    \n    intersection.distance = -1.0;\n    return intersection;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 getSceneColor(vec2 uv)\n{\n    Intersection intersection = getRaymarchedIntersection(uv);\n    \n    DirectionalLight lights[3];\n    vec3 backgroundColor = vec3(0.);\n   \n    \n    lights[0] = DirectionalLight(normalize(vec3(10.0, 10.0, 15.0)),\n                                 SUN_KEY_LIGHT);\n    lights[1] = DirectionalLight(vec3(0., 1., 0.),\n                                 SKY_FILL_LIGHT);\n    lights[2] = DirectionalLight(normalize(-vec3(15.0, 0.0, 10.0)),\n                                 SUN_AMBIENT_LIGHT);\n    backgroundColor = SUN_KEY_LIGHT;\n    \n    vec3 albedo = vec3(0.5);\n    vec3 n = estimateNormal(intersection.position);\n        \n    vec3 color = albedo *\n                 lights[0].color *\n                 max(0.0, dot(n, lights[0].dir));\n    \n    if (intersection.distance > 0.0)\n    { \n        for(int i = 1; i < 3; ++i) {\n            color += albedo *\n                     lights[i].color *\n                     max(0.0, dot(n, lights[i].dir));\n        }\n    }\n    else\n    {\n        color = vec3(0.5, 0.7, 0.9);\n    }\n        color = pow(color, vec3(1. / 2.2));\n        return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Make symmetric [-1, 1]\n    uv = uv * 2.0 - 1.0;\n\n    // Time varying pixel color\n    vec3 col = getSceneColor(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Smooth combination and SDF geometry operators attributed to Inigo Quilez\n// https://iquilezles.org/ @iquilezles\n\nconst int MAX_RAY_STEPS = 128;\nconst float FOV = 45.0;\nconst float EPSILON = 1e-2;\n\nconst vec3 EYE = vec3(0.0, 0.0, 6.0);\nconst vec3 REF = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_RIGHT = vec3(-1.0, 0.0, 0.0);\nconst vec3 WORLD_FORWARD = vec3(0.0, 0.0, 1.0);\nconst vec3 LIGHT_DIR = vec3(0.6, 1.0, 1.0) * 1.5;\n\n// Want sunlight to be brighter than 100% to emulate\n// High Dynamic Range\n#define SUN_KEY_LIGHT vec3(1.0, 0.5, 0.1) * 1.5\n// Fill light is sky color, fills in shadows to not be black\n#define SKY_FILL_LIGHT vec3(0.7, 0.2, 0.7) * 0.2\n// Faking global illumination by having sunlight\n// bounce horizontally only, at a lower intensity\n#define SUN_AMBIENT_LIGHT vec3(0.6, 1.0, 0.4) * 0.2\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Intersection \n{\n    vec3 position;\n    vec3 normal;\n    float distance;\n    int material_id;\n};\n\nstruct DirectionalLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\nfloat sphereSDF(vec3 query_position, vec3 position, float radius)\n{\n    return length(query_position - position) - radius;\n}\n\nfloat planeSDF(vec3 queryPos, float height)\n{\n    return queryPos.y - height;\n}\n\nfloat capsuleSDF( vec3 queryPos, vec3 a, vec3 b, float r )\n{\n  vec3 pa = queryPos - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat smoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nvec3 bendPoint(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n\nvec4 quaternionMultiply(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nvec3 rotatePointAroundAxis(vec3 p, vec3 axis, float angle)\n{\n    float halfAngle = angle * 0.5;\n    float sinHalfAngle = sin(halfAngle);\n    vec4 rotationQuat = vec4(axis * sinHalfAngle, cos(halfAngle));\n    vec4 rotationQuatConjugate = vec4(-rotationQuat.xyz, rotationQuat.w);\n\n    vec4 pointQuat = vec4(p, 0.0);\n    vec4 rotatedPointQuat = quaternionMultiply(quaternionMultiply(rotationQuat, pointQuat), rotationQuatConjugate);\n\n    return rotatedPointQuat.xyz;\n}\n\nfloat getBias(float t, float bias)\n{\n    return (t / ((((1.0/bias) - 2.0)*(1.0 - t))+1.0));\n}\n\nfloat getGain(float t, float gain)\n{\n    return t < 0.5 ? getBias(t * 2.0, gain) / 2.0 : getBias(t * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\n}\n    \n\n\n","name":"Common","description":"","type":"common"}]}