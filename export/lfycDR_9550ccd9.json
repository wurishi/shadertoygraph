{"ver":"0.1","info":{"id":"lfycDR","date":"1732647763","viewed":87,"name":"Morphing Mandelbulb","username":"Tsuki","description":"The map function for calculating the mandelbulb came from this project:\nhttps://www.shadertoy.com/view/WsySDR","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbrot","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/WsySDR\n// ^^^ most of the mandelbulb functions and raymarching\n\nfloat hash(float p)\n{\n    return fract(sin(dot(vec2(p), vec2(12.9898, 78.233))) * 43758.5453);    \n}\n\nfloat map( in vec3 pos, out vec3 orbit_trap )\n{\n    float thres = length(pos) - 1.2;\n    if (thres > 0.2) {\n        return thres;\n    }\n    \n    // Zn <- Zn^8 + c\n    // Zn' <- 8*Zn^7 + 1    \n    float power = sin(iTime*0.15)*3.5 + 7.0; //8.0;\n    vec3 z = pos;\n    vec3 c = pos;\n    \n    orbit_trap = vec3(1e20);\n    \n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < 25; ++i) { //100       \n        // to polar\n        r = length(z);\n        if (r > 2.0) { break; }        \n        float theta = acos(z.z/r);\n        float phi = atan(z.y, z.x);\n        \n        // derivate\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n        \n        // scale and rotate\n        float zr = pow(r, power);\n        theta *= power;\n        phi *= power;\n        \n        // to cartesian\n        z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));        \n        z += c;\n               \n        orbit_trap.x = min(pow(abs(z.z),0.1), orbit_trap.x);\n        orbit_trap.y = min(abs(z.x) - 0.15, orbit_trap.y);\n        orbit_trap.z = min(length(z), orbit_trap.z);\n    }\n    \n    return 0.5 * log(r) * r / dr;\n}\n\n////////////////////\n\nvec3 calcNormal(vec3 pos)\n{\n    vec3 trash;\n\n    // Tetrahedron technique\n    // https://iquilezles.org/articles/normalsSDF\n    const float h = 0.01; //0.0001\n    const vec2 k = vec2(1,-1);\n    return normalize(\n        k.xyy * map(pos + k.xyy * h, trash) + \n        k.yyx * map(pos + k.yyx * h, trash) + \n        k.yxy * map(pos + k.yxy * h, trash) + \n        k.xxx * map(pos + k.xxx * h, trash)\n    );\n}\n\n\nfloat ambientOcclusion(vec3 pos, vec3 N, float fallout)\n{\n    vec3 trash;   \n    const int nS = 10; // number of samples\n    const float max_dist = 0.07;\n    \n    float diff = 0.0;\n    for (int i = 0; i < nS; ++i)\n    {        \n        float dist = max_dist * hash(float(i)); // rand dist        \n        float s_dist = max(0.0, map(pos + dist * N, trash)); // sample\n        \n        diff += (dist - s_dist) / max_dist;\n    }\n    \n    float diff_norm = diff / float(nS);\n    float ao = 1.0 - diff_norm/fallout;\n    \n    return clamp(0.0, 1.0, ao);\n}\n\n////////////////////\n\nfloat castRay(vec3 cam_pos, vec3 cam_dir, out vec3 trap)\n{\n    const float dist_max = 200.0;\n    float dist = 0.0;\n    for (int i = 0; i < 100; ++i)\n    {\n        vec3 pos = cam_pos + dist * cam_dir;\n        float dist_remaining = map(pos, trap);\n        if (dist_remaining < 0.001) //0.0003\n        {\n            break;\n        }\n        dist += dist_remaining;\n        if (dist > dist_max)\n        {\n            dist = -1.0;\n            break;\n        }\n    }\n    return dist;\n}\n\n////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n        \n    float freq = 80.0 + iTime;\n    \n// Camera //\n    //vec3 cam_pos = vec3(3.0 * cos(0.1 * 0.125 * freq) * sin(0.1 * 0.5*freq), sin(0.1 * freq), 2.0 * cos(0.1 * 0.5 * freq));\n    vec3 cam_pos = vec3(-20.0,20.0,-20.0); \n    const vec3 cam_target = vec3(0.0);\n    \n    const float fov = 90.0 * 3.141592 / 180.0;\n    \n    vec3 cam_ww = normalize(cam_target - cam_pos);\n    \n    vec3 cam_uu = normalize(cross(vec3(0,1,0), cam_ww));\n    vec3 cam_vv = normalize(cross(cam_ww, cam_uu));\n//////////   \n\n    vec3 cam_dir = normalize(uv.x * cam_uu + uv.y * cam_vv + cam_ww - cam_pos);\n\n    vec3 trap;\n    float ray_dist = castRay(cam_pos, cam_dir, trap);\n    \n    vec3 col;\n    if (ray_dist > 0.0)\n    {           \n        //col = vec3(1.0) * clamp(pow(trap.x,20.0),0.0,1.0);\n        //col += vec3(1.0) * clamp(pow(trap.y,20.0),0.0,1.0);\n        //col += vec3(1.0) * clamp(pow(trap.z,20.0),0.0,1.0);\n        col = vec3(1.0);\n\n        vec3 pos = cam_pos + ray_dist * cam_dir;\n        vec3 normal = calcNormal(pos);\n        float ao = ambientOcclusion(pos, normal, 0.46);\n\n        //col += 0.6 * texture(iChannel0, reflect(normal, rd)).xyz;\n        col += 0.6 * -normal;\n        col *= 0.01 + ao * 1.5;\n    }\n    else\n    {\n        vec3(0.0);\n\t}\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}