{"ver":"0.1","info":{"id":"MfGyzz","date":"1731423182","viewed":100,"name":"Super simple simplex noise","username":"stegu","description":"2-D \"Simplex noise\", written for clarity rather than speed. Turned out to be quite fast, though. Trigonometric functions are highly HW accelerated these days, and on a desktop GPU there is no real need to fiddle with points on a square or diamond for g_i.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","simplex"],"hasliked":0,"parentid":"XfcyRs","parentname":"Classic 2-D \"Perlin\" Noise"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// simple simplex noise (c) Stefan Gustavson,\n// ver. 2024-11-12, published under CC-BY-SA 4.0\n// https://creativecommons.org/licenses/by-sa/4.0/\n//\nfloat ssnoise(vec2 p)\n{\n    // Staggered grid, points at integer y and integer/half x\n    // (Yields a slightly non-uniform triangular/hex grid.)\n    vec2 uv = vec2(p.x+p.y*0.5, p.y + 0.001); // Transform to skewed space\n    vec2 i0 = floor(uv); // Which grid rhombus are we in?\n    vec2 f0 = fract(uv); // And which of the two triangles?\n    vec2 o1 = (f0.y<f0.x) ? vec2(1.0,0.0) : vec2(0.0,1.0); // offset to 2nd corner\n    vec2 i1 = i0 + o1, i2 = i0 + 1.0; // Grid coordinates, used for hash\n    vec2 p0 = vec2(i0.x - i0.y*0.5, i0.y); // Transform back to p space\n    vec2 p1 = vec2(p0.x + o1.x - o1.y*0.5, p0.y + o1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2; // Vectors from corners to p\n\n    // Compute a simple hash for each of the three corners using\n    // permutation polynomials (predictable, and floating-point only)\n    vec3 iu = vec3(i0.x, i1.x, i2.x); // Hash coords\n    vec3 iv = vec3(i0.y, i1.y, i2.y);\n    vec3 hash = mod(iu, 289.0); // Mod to avoid truncations below\n    hash = mod((hash*51.0 + 2.0)*hash + iv, 289.0); // These are not great,\n    hash = mod((hash*34.0 + 10.0)*hash, 289.0);     // but \"good enough\"\n    vec3 psi = hash*0.07482; // Scale the hash (and jumble it some more)\n\n    // Generate three gradients\n    vec3 gx = cos(psi); // sin and cos are usually fast these days\n    vec3 gy = sin(psi);\n    vec2 g0 = vec2(gx.x, gy.x);\n    vec2 g1 = vec2(gx.y, gy.y);\n    vec2 g2 = vec2(gx.z, gy.z);\n\n    // Compute the kernels of influence from each corner\n    // The radial decay part\n    vec3 w = 0.8 - vec3(dot(v0, v0), dot(v1, v1), dot(v2, v2));\n    w = max(w, 0.0); // Cut off the negative part\n    vec3 w2 = w*w;\n    vec3 w4 = w2*w2; // This is our radial weight\n    // The extrapolated linear ramp part\n    vec3 gdotv = vec3(dot(g0, v0), dot(g1, v1), dot(g2, v2));\n    // Compute and sum up the three contributions in one go\n    float n = dot(w4, gdotv);\n\n    // Scale the noise value to span the range [1,1]\n    return 10.9*n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Semi-normalized coordinate: [0,1] along shortest dim\n    vec2 P = fragCoord/min(iResolution.x, iResolution.y);\n\n    // Plain 2-D simplex noise, no frills\n    float n = ssnoise(P*5.0);\n\n    // Output to screen\n    fragColor = vec4(vec3(0.5 + n*0.5), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}