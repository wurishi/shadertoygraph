{"ver":"0.1","info":{"id":"Xfy3z1","date":"1712410227","viewed":66,"name":"Focal to Field of View Checker","username":"chronos","description":"Focal to Field of View Checker","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["simple","checker","distance","field","fov","of","diagram","focal","view"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Focal to Field of View Checker by chronos\n\n    -----------------------------------------------------\n    \n    Just a simple function / texture to quickly check the field of view in degrees.\n    \n    \n*/\nconst float PI = 3.14159265;\n\n\nvec3 fovchecker(vec3 rd, vec3 forward) // Assumed normalized!\n{\n    vec3 color = vec3(0);\n\n    float cos_angle = dot(rd, forward);\n    \n    float angle_radians = 2. * acos(cos_angle);\n    \n    float angle_degrees = angle_radians * 180. / PI;\n    \n    if(angle_degrees < 180.) color = vec3(0.2);\n    if(angle_degrees < 160.) color = vec3(0.4);\n    if(angle_degrees < 140.) color = vec3(0.6);\n    \n    if(angle_degrees < 120.) color = vec3(1,0,1); // Magenta 120 degrees\n    if(angle_degrees <  90.) color = vec3(0,0,1); // Blue     90 degrees\n    if(angle_degrees <  75.) color = vec3(0,1,1); // Cyan     75 degrees\n    if(angle_degrees <  60.) color = vec3(0,1,0); // Green    60 degrees\n    if(angle_degrees <  30.) color = vec3(1,0,0); // Red      30 degrees\n    if(angle_degrees <  15.) color = vec3(1,1,1); // White    15 degrees\n    \n    // 1 and 5 degree increments between lines\n    \n    color = mix(color, vec3(0), 0.25*pow(.5+.5*cos(angle_degrees * 2. * PI     ), 8.));\n    color = mix(color, vec3(0), pow(.5+.5*cos(angle_degrees * 2. * PI / 5.), 32.));\n    \n    return color;\n}\n\n\n\n\n\n\n\nfloat rayplane(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n    float denom = dot(rd, n);\n    if(denom == 0.) return -1.;\n    float t = dot(p - ro, n) / denom;\n    return t;\n}\n\nfloat rayplane_seg(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n    float denom = dot(rd, n);\n    \n    if(denom == 0.) return -1.;\n    float t = dot(p-ro, n) / denom;\n    \n    vec3 h = ro + t * rd;\n    vec3 H = abs(h-p);\n    if(max(max(H.x, H.y), H.z) > 1.) return -1.;\n    \n    return t;\n}\n\nvec3 render_scene(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0);\n    \n    vec3 scene_translation = vec3(0,0,2);\n    \n    vec3 p,n, N;\n    float min_t=9e9, t;\n    \n    // back wall\n    p = vec3(0,0,-3.) + scene_translation;\n    n = vec3(0,0,1);\n    t = rayplane_seg(ro, rd, p, n);\n    \n    if(t > 0. && t < min_t)\n    {\n        min_t = t;\n        color = vec3(0.5);\n        N = n;\n    }\n    \n    // ceiling\n    p = vec3(0,1,-2.) + scene_translation;\n    n = vec3(0,-1,0);\n    t = rayplane_seg(ro, rd, p, n);\n    \n    if(t > 0. && t < min_t)\n    {\n        min_t = t;\n        color = vec3(0.75);\n        N = n;\n    }\n    \n    // floor\n    p = vec3(0,-1,-2.) + scene_translation;\n    n = vec3(0,1,0);\n    t = rayplane_seg(ro, rd, p, n);\n    \n    if(t > 0. && t < min_t)\n    {\n        min_t = t;\n        vec3 P = ro + t * rd;\n        float tile = float(mod(floor(P.x*4.), 2.) != mod(floor(P.z*4.), 2.));\n        color = vec3(0.25) * mix(tile, 1., 0.5);\n    \n        N = n;\n    }\n    \n    // right wall\n    p = vec3(1,0,-2.) + scene_translation;\n    n = vec3(-1,0,0);\n    t = rayplane_seg(ro, rd, p, n);\n    \n    if(t > 0. && t < min_t)\n    {\n        min_t = t;\n        color = vec3(0,1,0);\n        N = n;\n    }\n    \n    // left wall\n    p = vec3(-1,0,-2.) + scene_translation;\n    n = vec3(1,0,0);\n    t = rayplane_seg(ro, rd, p, n);\n    \n    if(t > 0. && t < min_t)\n    {\n        min_t = t;\n        color = vec3(1,0,0);\n        N = n;\n    }\n    \n    vec3 P = ro + min_t * rd;\n    \n    vec3 uvw = fract(P*4.);\n    \n    vec3 axes = max(smoothstep(0.9, 1., uvw), smoothstep(0.1, 0., uvw));\n    axes *= max(axes.yzx, axes.zxy);\n    float grid = max(max(axes.x, axes.y), axes.z);\n    \n    color = mix(color, vec3(0), grid);\n    \n    color = color * exp(-min_t*.125);\n    \n    // ground\n    p = vec3(0,-2, 0.);\n    n = vec3(0,1,0);\n    t = rayplane(ro, rd, p, n);\n    \n    if(t > 0. && t < min_t)\n    {\n        min_t = t;\n        N = n;\n        color = vec3(0.125);\n        vec3 P = ro + min_t * rd;\n    \n        vec3 uvw = fract(P);\n\n        vec3 axes = max(smoothstep(0.9, 1., uvw), smoothstep(0.1, 0., uvw));\n        axes *= max(axes.yzx, axes.zxy);\n        float grid = max(max(axes.x, axes.y), axes.z);\n        \n        //\n        float tile = float(mod(floor(P.x), 2.) != mod(floor(P.z), 2.));\n        color = mix(color, vec3(tile), .25);\n        //color = max(color, vec3(grid));\n        \n        color *= exp(-min_t*.125);\n    }\n    \n    return color;\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    vec3 projection = dot(p, axis) * axis;\n    \n    vec3 rejection = p - projection;\n    vec3 perpendicular = cross(axis, p);\n\n    return projection + rejection * cos(angle) + perpendicular * sin(angle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    vec3 color = vec3(0);\n\n    float focal = mix(.5, 1.95, length(mouse));\n    \n    if(length(iMouse.xy) < 10.)\n        focal = 2.;//sqrt(sqrt(3.) * 3.07); //mix(.5, 1.95, length(mouse));\n    vec3 rd = normalize(vec3(uv, -focal));\n    vec3 ro = vec3(0,0,8);\n    \n    ro = rot(ro, vec3(0,1,0), iTime);\n    rd = rot(rd, vec3(0,1,0), iTime);\n    vec3 forward = rot(vec3(0,0,-1), vec3(0,1,0), iTime);\n    \n    color = render_scene(ro, rd);\n    \n    color = mix(color, fovchecker(rd, forward), 0.125);\n    \n    if(abs(uv).x > 1. || abs(uv).y > 1.) color *= 0.5;\n\n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}