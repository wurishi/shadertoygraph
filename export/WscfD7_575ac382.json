{"ver":"0.1","info":{"id":"WscfD7","date":"1605403837","viewed":83,"name":"Unite Circles","username":"rito15","description":".","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circles","smax","unite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**************************************************************************************************\n * DEFINITIONS : Unity Compatibility\n **************************************************************************************************/\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat3\n\n#define frac(x)     fract(x)\n#define saturate(x) clamp(x, 0., 1.)\n\n#define atan2(x,y)    atan(y,x)\n#define tex2D(s,t)    texture(s,t)\n#define mul(mat,vec)  vec*mat;\n\n#define lerp(a,b,t) mix(a,b,t)\n\n/**************************************************************************************************\n * DEFINITIONS\n **************************************************************************************************/\n#define S(a, b, t) smoothstep(a, b, t)\n\n\n/**************************************************************************************************\n * Basic Shapes\n **************************************************************************************************/\n// 원 : 중심좌표, 반지름\nfloat Circle(float2 uv, float2 center, float radius, float smoothness)\n{\n    return smoothstep(radius, radius - smoothness, length(uv - center));\n}\n\n// 물방울\nfloat Drop(float2 uv, float2 center, float2 size, float smoothness)\n{\n    float2 uvDrop = (uv - center) / (size * float2(1., 0.5));\n    uvDrop = -uvDrop;\n    \n    float k = max(min(-0.45 * (uvDrop.y - 0.5), 1.), 0.); // k = max(min(-y, 1), 0) 변형\n    float s = k * k * (2.5 - 2. * k);                     // s = k^2(3 - 2k) 변형\n    float dropBase = abs(uvDrop.x) + s;\n    float drop = smoothstep(0.5, 0.5 - smoothness, dropBase);\n    \n    // 상하 가로로 자르기\n    float dropClip = smoothstep(1.0, 0.5, abs(uvDrop.y + 0.2));\n    drop *= dropClip;\n    \n    // 물방울 하단부 원\n    float dropCircle = smoothstep(0.5, 0.5 - smoothness, length(uvDrop - float2(0., 0.5)));\n    dropCircle *= 1. - dropClip;\n    drop += dropCircle;\n    \n    drop = smoothstep(0., 1., drop);\n    \n    return drop;\n}\n\n// 하트\nfloat Heart(float2 uv, float2 center, float size, float smoothness)\n{\n    float2  uvHeart   = (uv - center) / size * float2(1.15, 0.97);\n    float2  heartBase = float2(uvHeart.x, uvHeart.y - sqrt(abs(uvHeart.x)) * 0.7 + 0.18);\n    float heart = smoothstep(0.87, 0.87 - smoothness, length(heartBase));\n    return heart;\n}\n\n/**************************************************************************************************\n * Calc Functions \n **************************************************************************************************/\n// Smooth Max\nfloat smax(float a, float b, float k)\n{\n    float h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    return mix(a, b, h) + h * (1.0 - h) * k * 0.5;\n}\n\n// Smooth Min\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn lerp(b, a, h) - k * h * (1.0 - h);\n}\n\n// 회전 : 기본 시계방향\nfloat2 Rotate(float2 org, float deg)\n{\n    float2x2 rotMat = float2x2(cos(deg), -sin(deg),\n                               sin(deg),  cos(deg));\n    return mul(rotMat, org);\n}\n\n/**************************************************************************************************\n * UV Functions \n **************************************************************************************************/\n// 타일링\nfloat2 UvTile(float2 uv, float2 size, float2 offset)\n{\n    return frac(uv * size) - offset;\n}\n\n// 회전\nfloat2 UvRotate(float2 uv, float rot)\n{\n    return Rotate(uv, rot);\n}\n\n// 스케일 박동\nfloat2 UvPulse(float2 uv, float range, float t)\n{\n    return uv * (1. + sin(t)* range);\n}\n\n// 꿀렁꿀렁 - a : x꿀렁, b : y꿀렁, c : 꿀렁 범위 / t : 시간\nfloat2 UvWave(float2 uv, float a, float b, float c, float t)\n{\n    float x = abs(uv.x) * a;\n    float y = abs(uv.y) * b;\n    float k;\n    \n    k = sin(x * y + t); // 기본\n    //k *= cos(x *b + cos(t)*0.5) * 0.5 + 0.5; \n    \n    float kkc = abs(k * k * c);\n    float w1 = 1. + kkc * a;\n    float w2 = 1. + kkc * b;\n    return float2(uv.x * w1, uv.y / w2);\n}\n\n// 진동\nfloat2 UvVibrate(float2 uv, float a, float b, float c, float t)\n{\n    float x = abs(uv.x) * a;\n    float y = abs(uv.y) * b;\n    float w = 1. + abs(sin(t*x * y + t) * sin(t*x * y + t) * c);\n    \n    return float2(uv.x * w, uv.y * w);\n}\n\n// 흩뿌리기\nfloat2 UvScatter(float2 uv, float2 scale)\n{\n    float x = uv.x;\n    float y = uv.y;\n    float2 s = 2. - float2(cos(x * scale) * cos(y * scale));\n    return uv * s;\n}\n\n/**************************************************************************************************\n * Screen Filter Functions \n **************************************************************************************************/\n// 모자이크\nfloat FilterMosaic(float2 uv, float scale, float smoothness)\n{\n    float2 uv2 = frac((uv - float2(0.5, 0.5)) * scale);\n    float2 mBase = uv2 - float2(0.5, 0.5);\n    float mosaic = smoothstep(0.5, 0.5 - smoothness, length(mBase));\n    return mosaic;\n}\n\n/**************************************************************************************************\n * Functions \n **************************************************************************************************/\n\nfloat Random11(float seed, float min, float max)\n{\n    float t = frac(sin(seed * 13.421 + 23.512) * 17593.39482);\n    return lerp(min, max, t);\n}\n\nfloat GetT(float seed)\n{\n    //float r1 = Random11(seed, 0.3, 0.6);\n    //float k = atan( lerp(-1., 0., frac(iTime * r1) ) );\n    //return k;\n    \n    float r1 = Random11(seed, 0.3, 0.6);\n    float r2 = Random11(seed, 0.1, 0.9);\n    float r3 = Random11(seed, 0.2, 0.8);\n    \n    float k = sin( iTime * r1 * r2 * r3 );\n    return k;\n}\n\nfloat GetRadius(float seed)\n{\n    return Random11(seed, 0.2, 0.3) + sin(iTime)*0.02;\n}\n\n/**************************************************************************************************\n * Main\n **************************************************************************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 해상도를 800x450에서 450x450으로 맞추고 화면 중앙 정렬하기\n    float ratioWH = iResolution.x / iResolution.y;\n    float ratioHW = iResolution.y / iResolution.x;\n    float2 adjMul = float2(ratioWH, 1.);\n    float2 adjSub = float2((1.-ratioHW) * 0.5 * ratioWH, 0.);\n    float2 uv = (fragCoord/iResolution.xy) * adjMul - adjSub;\n    \n    float3 shp = float3(0.); // 최종 모양\n    float3 col = float3(1.); // 최종 컬러\n    // => 최종 결과 = shp * col\n    \n    // uv2 이동\n    float2 uvOffset = float2(0.0, 0.0);\n    \n    // uv Remap : 0. ~ 1. => -1. ~ 1.\n    float2 uv2 = uv *2. - 1. - uvOffset;\n    \n    // 특정 UV 적용\n    float2 uv3 = uv2;\n    \n    //uv3 = UvTile(uv3, float2(2., 2.), float2(0.5));\n    uv3 = UvRotate(uv3, iTime*0.2);\n    uv3 = UvPulse(uv3, 0.1, iTime * 10.0);\n    uv3 = UvWave(uv3, 0.5, 0.5, 0.1, iTime * 5.0);\n    //uv3 = UvVibrate(uv3, 1., -1., 0.50, iTime * 5.0);\n    //uv3 = UvScatter(uv3, float2(1000.0));\n    \n    float seed = 0.01;\n    float cSmoothness = 0.1;\n    \n    //uv2 = UvRotate(uv2, -iTime * 0.2 + length(uv));\n    float c0 = Circle(uv3, float2(0., 0 ), 0.5, 0.1);\n    \n    float c1 =  Circle(uv2, float2(0.         ,  GetT(seed)),      GetRadius(seed), cSmoothness); seed += 0.01;\n    float c2 =  Circle(uv2, float2(GetT(seed) ,  0         ),      GetRadius(seed), cSmoothness); seed += 0.01;\n    float c3 =  Circle(uv2, float2(0.         , -GetT(seed)),      GetRadius(seed), cSmoothness); seed += 0.01;\n    float c4 =  Circle(uv2, float2(-GetT(seed),  0         ),      GetRadius(seed), cSmoothness); seed += 0.01;\n    float c5 =  Circle(uv2, float2( GetT(seed),  GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c6 =  Circle(uv2, float2( GetT(seed), -GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c7 =  Circle(uv2, float2(-GetT(seed),  GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c8 =  Circle(uv2, float2(-GetT(seed), -GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c9 =  Circle(uv2, float2( GetT(seed),  GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c10 = Circle(uv2, float2( GetT(seed), -GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c11 = Circle(uv2, float2(-GetT(seed),  GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c12 = Circle(uv2, float2(-GetT(seed), -GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c13 = Circle(uv2, float2( GetT(seed),  GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c14 = Circle(uv2, float2( GetT(seed), -GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c15 = Circle(uv2, float2(-GetT(seed),  GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c16 = Circle(uv2, float2(-GetT(seed), -GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c17 = Circle(uv2, float2( GetT(seed),  GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c18 = Circle(uv2, float2( GetT(seed), -GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c19 = Circle(uv2, float2(-GetT(seed),  GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    float c20 = Circle(uv2, float2(-GetT(seed), -GetT(seed*seed)), GetRadius(seed), cSmoothness); seed += 0.01;\n    \n    float circles = smax(c0,      c1, 1.0);\n          circles = smax(circles, c2, 1.0);\n          circles = smax(circles, c3, 1.0);\n          circles = smax(circles, c4, 1.0);\n    \n          circles = smax(circles, c5, 1.0);\n          circles = smax(circles, c6, 1.0);\n          circles = smax(circles, c7, 1.0);\n          circles = smax(circles, c8, 1.0);\n    \n          circles = smax(circles, c9,  1.0);\n          circles = smax(circles, c10, 1.0);\n          circles = smax(circles, c11, 1.0);\n          circles = smax(circles, c12, 1.0);\n    \n          circles = smax(circles, c13, 1.0);\n          circles = smax(circles, c14, 1.0);\n          circles = smax(circles, c15, 1.0);\n          circles = smax(circles, c16, 1.0);\n    \n          circles = smax(circles, c17, 1.0);\n          circles = smax(circles, c18, 1.0);\n          circles = smax(circles, c19, 1.0);\n          circles = smax(circles, c20, 1.0);\n    \n    //circles = step(0.5, circles);\n    \n    float changeSmooth = sin(iTime) * 0.099;\n    shp += smoothstep(0.8 + changeSmooth, 1.0, circles );\n    \n    // 색상 ==================================================================\n    \n    float gd = smoothstep(0. , 1.0, length(uv2));\n    col = float3(gd, 1. - gd * cos(uv.y + iTime), sin(uv.x + iTime *2.) * 0.5 + 0.5);\n    \n    // 스크린 필터 ============================================================\n    if(iMouse.z > 1.)\n    {\n        float2 mousePos = iMouse.xy / iResolution.xy;\n        mousePos = mousePos * 2. - 1.;\n        \n    \tshp *= FilterMosaic(uv, 100. * length(mousePos) + 10., sin(iTime * 10.) * 0.05 + 0.5);\n        \n        //shp = float3(1.);\n        //col = float3(1.);\n        //col *= smoothstep(0.5, 1.0, 1. - length(uv - (mousePos + 1.) * 0.5));\n    }\n    \n    // =========================================================================\n    fragColor = vec4(shp * col,1.0);\n}","name":"Image","description":"","type":"image"}]}