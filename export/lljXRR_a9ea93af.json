{"ver":"0.1","info":{"id":"lljXRR","date":"1441132638","viewed":261,"name":"HAPPY BIRTHDAY LUKE","username":"cabbibo","description":"Taking IQ's Cloud shader: https://www.shadertoy.com/view/XslGRr#\n\nAnd making it as weird as possible!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["volumetric","raytrace","smoothmin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Everything cool comes from: https://www.shadertoy.com/view/XslGRr#\n\n\nconst float MAX_TRACE_DISTANCE = 6.0;             // max trace distance\nconst float INTERSECTION_PRECISION = 0.01;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst int FOG_STEPS = 40;\nconst float PI = 3.14159;\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat4 translate(vec3 t)\n{\n\treturn mat4(1.0, 0.0, 0.0, -t.x, 0.0, 1.0, 0.0, -t.y, 0.0, 0.0, 1.0, -t.z, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat box(vec3 p, vec3 s)\n{ \n    vec3 w = abs(p) - s/2.0;\n    return min(max(w.x,max(w.y,w.z)),0.0) + length(max(w,0.0));   \n}\n\n\nfloat sdCap( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat luke( vec3 inP ){\n    \n    float smoothAmount = .1 + sin( iTime  * .3 ) * .05;\n    \n    \n    vec3 p = inP + vec3( \n          sin( length(inP.xy) * 10. + iTime ) * .1 \n        , sin( length(inP.yz) * 10. + iTime ) * .1  \n        , sin( length(inP.xyz) * 10. + iTime ) * .1 \n    );\n    \n    \n    \n    p = inP + vec3( \n          sin( length(inP.xzy * sin( p.x * 1. )) * 3. + iTime ) * .1 \n        , sin( length(inP.yz) * 1. + iTime ) * .3  \n        , sin( length(inP.xyz) * 4. + iTime ) * .3 \n    ); \n    \n    ///p = inP;\n    \n    \n    \n    vec3 startPos = vec3( -.25 , -0.2 , -0.5 );\n    \n    \n    \n    \n    //--------------------------------\n\t// L\n\t//--------------------------------\n    vec3 pos =  startPos - vec3(1.5 , 0. , 0. );\n    \n    \n    float l = smin( \n        \n        sdCap( p , pos + vec3( .0 ,-.5 , 0. ) , pos + vec3( .0 , 0.5 , 0. ), .1 ),\n        sdCap( p , pos + vec3( 0. , -.5 , 0. ), pos + vec3( .5 , -0.5 , 0. ), .1 ),\n        smoothAmount\n        /*box( p + pos , vec3(.1 , 1. , .1 )),\n        box( p + pos + vec3(-.2 , .5 , 0. ) , vec3(.5 , .1 , .1 ))*/\n    );\n    \n    \n    \n    //--------------------------------\n\t// U\n\t//--------------------------------\n    pos =  startPos - vec3(.5 , 0. , 0. );\n    \n    \n    float u =smin( \n        \n        sdCap( p , pos + vec3(.0 ,-.5 , 0. ) , pos + vec3( .0 , 0.5 , 0. ), .1 ),\n        sdCap( p , pos + vec3( 0. , -.5 , 0. ), pos + vec3( .5 , -0.5 , 0. ),.1 ),\n         smoothAmount\n    );\n    \n    u = smin( u ,sdCap( p , pos + vec3( 0.5 , -.5 , 0. ), pos + vec3( .5 , .5 , 0. ),.1 ) , smoothAmount);\n            \n    \n    \n        \n    //--------------------------------\n\t// k\n\t//--------------------------------\n    pos =  startPos - vec3(-.5 , 0. , 0. );\n    \n    \n    float k =smin( \n        \n        sdCap( p , pos + vec3(.0 ,-.5 , 0. ) , pos + vec3( .0 , 0.5 , 0. ), .1 ),\n        sdCap( p , pos + vec3( 0. , 0. , 0. ), pos + vec3( .6 , 0.5 , 0. ),.1 ),\n         smoothAmount\n    );\n    \n    k = smin( k ,sdCap( p , pos + vec3( 0. , 0. , 0. ), pos + vec3( .6 , -.5 , 0. ),.1 ) , smoothAmount );\n            \n    \n            \n           \n    //--------------------------------\n\t// k\n\t//--------------------------------\n    pos =  startPos - vec3(-1.5 , 0. , 0. );\n    \n    \n    float e =smin( \n        \n        sdCap( p , pos + vec3(.0 ,-.5 , 0. ) , pos + vec3( .0 , 0.5 , 0. ), .1 ),\n        sdCap( p , pos + vec3( 0. , 0.5 , 0. ), pos + vec3( .5 , 0.5 , 0. ),.1 ),\n         smoothAmount\n    );\n    \n    e = smin( e ,sdCap( p , pos + vec3( 0. , 0. , 0. ), pos + vec3( 0.5 , .0 , 0. ),.1 ) , smoothAmount);\n    e = smin( e ,sdCap( p , pos + vec3( 0. , -0.5 , 0. ), pos + vec3( 0.5 , -0.5, 0. ),.1 ) , smoothAmount );\n        \n    \n            \n    \n\n    \n    return min(min(min(l,u),k),e);\n    \n    \n    \n}\n\nfloat tree( vec3 inP ){\n    \n    vec3 p = inP + vec3( \n          sin( length(inP.xy) * 10. + iTime ) * .1 \n        , sin( length(inP.yz) * 10. + iTime ) * .1  \n        , sin( length(inP.xyz) * 10. + iTime ) * .1 \n    );\n    \n    \n    \n    p = inP + vec3( \n          sin( length(inP.xzy * sin( p.x * 1. )) * 3. + iTime ) * .1 \n        , sin( length(inP.yz) * 1. + iTime ) * .3  \n        , sin( length(inP.xyz) * 4. + iTime ) * .3 \n    );\n    \n    // p = inP;\n    \n    \n    vec3 startPos = vec3( .25 , 0.2 , 0.5 );\n    \n    \n    \n    \n    //--------------------------------\n\t// T\n\t//--------------------------------\n    vec3 pos =  startPos + vec3(1.5 , 0. , 0. );\n    \n    \n    \n    \n  \tfloat t = min( \n        box( p + pos , vec3(.1 , 1. , .1 )),\n        box( p + pos + vec3(0. , -.5 , 0. ) , vec3(1. , .1 , .1 ))\n    );\n    \n    \n\n    \n    //--------------------------------\n\t// R\n\t//--------------------------------\n    pos = startPos +  vec3(.5 , 0. , 0. );\n   \n\n  /*  p = inP + vec3( \n          sin( length(inP.xzy * sin( p.x * 1. )) * 3. + iTime ) * .1 \n        , sin( length(inP.yz) * 1. + iTime ) * .3  \n        , sin( length(inP.xyz) * 4. + iTime ) * .3 \n    );*/\n    \n    \n    float r = min(\n        box( p + pos , vec3(.1 , 1. , .1 )),\n        box( p + pos + vec3(-.2 , -.5 , 0. ) , vec3(.5 , .1 , .1 ))\n    );\n    \n    r = min( r , box( p + pos + vec3(-.4 , -.25 , 0. ) , vec3(.1 , .5 , .1 )));\n    r = min( r , box( p + pos + vec3(-.2 , 0. , 0. ) , vec3(.5 , .1 , .1 )));\n    \n    mat3 rot = zrotate( -.9 );\n    \n    r = min( r , box( rot * ( p + pos + vec3(-.23 , 0.23 , 0. )) , vec3(.65 , .1 , .1 )));\n    \n    \n    //--------------------------------\n\t// E\n\t//--------------------------------\n    \n    pos = startPos + vec3( -.5 , 0. , 0. );\n    \n    /*p = inP + vec3( \n          sin( length(inP.xy) * 13. + iTime ) * .1 \n        , sin( length(inP.yz) * 15. + iTime ) * .1  \n        , sin( length(inP.xyz) * 41. + iTime ) * .05 \n    );*/\n    \n    \n    float e1 = min( \n        box( p + pos , vec3(.1 , 1. , .1 )), \n        box( p + pos + vec3(-.2 , -.5 , 0. ) , vec3(.5 , .1 , .1 ))\n    );\n    e1 = min( e1 , box( p + pos + vec3(-.2 , 0. , 0. ) , vec3(.5 , .1 , .1 )));\n    e1 = min( e1 , box( p + pos + vec3(-.2 , 0.5 , 0. ) , vec3(.5 , .1 , .1 )));\n\n    \n    //--------------------------------\n\t// E\n\t//--------------------------------\n    pos = startPos + vec3( -1.5 , 0. , 0. );\n      \n    /*p = inP + vec3( \n          sin( length(inP.xy) * 43. + iTime ) * .03\n        , sin( length(inP.yz) * 15. + iTime ) * .1  \n        , sin( length(inP.xyz) * 11. + iTime ) * .1 \n    );*/\n    \n    \n    float e2 = min( \n        box( p + pos , vec3(.1 , 1. , .1 )), \n        box( p + pos + vec3(-.2 , -.5 , 0. ) , vec3(.5 , .1 , .1 ))\n    );\n    \n    e2 = min( e2 , box( p + pos + vec3(-.2 , 0. , 0. ) , vec3(.5 , .1 , .1 )));\n    e2 = min( e2 , box( p + pos + vec3(-.2 , 0.5 , 0. ) , vec3(.5 , .1 , .1 )));\n            \n    return min(min( min( t,r), e1),e2);\n          \n    \n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\n\nvec3 hsv(float h, float s, float v)\n{\n    \n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \t//vec2 res = vec2( (abs(sin( pos.x * pos.y * pos.z  * 10.)) * 1.9 ) + length( pos ) - 1., 0.0 );\n  \n \n    \n    vec2 res = vec2( luke( pos ) , 1. );\n    \n \n    \n    /*\n    for( int i = 0; i < lightNum; i++ ){\n    \n        float d = length( pos - lightPos[i] );\n        vec2 res2 =vec2( d - (pow(((sin(float( i) + 4.*sin( iTime ))) / float(lightNum)) , 2.) * 8.5 + .1) , 1. ); \n        res = opU( res ,  res2 );\n        \n    }*/\n    \n   \treturn res;\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 1.0*mouseX;\n\t//camPos = vec3(3.5*sin(an),cos( time * .1 ),3.5*cos(an));\n    camPos = vec3( 3.5*sin(mouseX * .4) , 0.6 , 3.5*cos(mouseX * .4));\n    camTar = vec3(0. ,0.0,0.0);\n}\n\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n   \n}\n\nvec3 doBackground( vec3 rd , vec3 ogRD ){\n \n    vec3 col = vec3(0.);\n    col = hsv( abs(sin(pow(  dot( ogRD , rd ) , 1.) * 10.)), 1.,1.);//* vec3( 1. , .6 , .2 );; \n    //col +=hsv(pow( max( 0. , dot( vec3( 0. , 0. , 1. ) , rd )) , 10.),1.,1.);//* vec3( 1. , .5 , .2 );\n    //col +=hsv(pow( max( 0. , dot( normalize(vec3( 1. , 1. , -1. )) , rd )) , 10.),1.,1.);//* vec3( 1. , .5 , .2 );   \n    \n    return col;\n}\n\n\n\nfloat densityFunction( vec3 p ){\n    return triNoise3D( p * .05 , 0. ) * max( 0. , -p.y + .1 );\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);//*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);//*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);//*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);//*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\n\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    // lighting\n    vec3 lin = vec3(0.65,0.68,0.7)*1.3 + 0.5*vec3(0.7, 0.5, 0.3)*dif;        \n    vec4 col = vec4( hsv( den , 1. , 1. ) , den );//vec4( mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.65), den ), den );\n    col.xyz *= hsv( length( lin ) , 1. , 1.);\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; vec2 res =map( pos ); if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 || res.x < .05 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.1,0.02*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(30,map5);\n    MARCH(30,map4);\n    MARCH(30,map3);\n    MARCH(30,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n/*\nvec4 doFog( vec3 ro , vec3 rd ){\n \n   \tvec3 col = vec3( 0. );\n    float lum = 0.;\n    \n    for( int i = 0; i < FOG_STEPS; i++ ){\n        \n        vec3 p = ro * ( 1. )  + rd  * ( MAX_TRACE_DISTANCE / float( FOG_STEPS))  * float( i );\n        \n        vec2 m  = map( p );\n\n        if( m.x < 0.0 ){ return vec4( col , lum ) / float( FOG_STEPS ); }\n        \n        \n        \n      \n        vec3 lightDir = normalize( p - lightPos );\n        float d = densityFunction( p );\n        float dif = clamp( (densityFunction( p + .01 * lightDir ) - d )/.01 , 0. , 1. ); \n\n        col += vec3( dif );//hsv( pow(dif, 10. ) ,1.,1.) * dif ;\n        lum = float(i);\n\n        \n    }\n    \n    col /= float( FOG_STEPS );\n    \n    return vec4( col , lum );\n    \n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m.x = sin( iTime * .1 );\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime,m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    vec3 ogRD = normalize( camMat * vec3(0. , 0.,2.0) );\n    \n        \n    vec2 res = calcIntersection( ro , rd  );\n    \n    vec3 col = doBackground(rd , sundir );  \n    //col = vec3(;\n    \n    \n            // If we have hit something lets get real!\n    if( res.y > -.5 ){\n        \n\n          \n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal( pos );\n        \n\n        \n        vec3 refl = reflect( sundir , nor );\n        \n        float lamb = max( 0. , dot( sundir,  nor ) );\n        float spec = max( 0. , dot( refl , rd ) );\n        \n        float AO = calcAO ( pos , nor );\n        col = lamb *  vec3(AO); \n        col += vec3( pow( spec, 10. ));\n        col += vec3( .1 );\n        \n        col = hsv(lamb, 1. , 1.);\n        \n       // col = vec3( 0. );\n       // col = vec3( 1. , 0. , 0. ) * lamb + vec3( 0. , 0. , 1. ) * pow( spec, 20. );\n        \n        \n     \n        //col = nor * .5 + .5;\n    }\n    \n   // clouds    \n    vec4 resCloud = raymarch( ro, rd, col );\n    col = col*(1.0-resCloud.w) + resCloud.xyz;\n    \n    \n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n            \n}\n","name":"","description":"","type":"image"}]}