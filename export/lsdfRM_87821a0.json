{"ver":"0.1","info":{"id":"lsdfRM","date":"1524557875","viewed":237,"name":"Procedural Thread Texture Model ","username":"stuck_in_math","description":"Implementation of \"A Procedural Thread Texture Model by Neeharika Adabala and Nadia Magnenat-Thalmann\"\nfound here (5 pages total with reference images)\nhttps://www.researchgate.net/publication/230605029_A_Procedural_Thread_Texture_Model","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","cloth","weave","thread","yarn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// First I implemented model in full\n// When it weren't behaving as it should i started commenting out parts trying to pinpoint\n// problematic spot\n// It seems to be displacement calculation that is a problem \n// but maybe there is something in twist_trajectory calculation also\n//\n// Commenting out all parts that seem irrelevant to the problem \n// as to concentrate just on the problematic spot \n\n// UPDATE: FIXED, displacement calculation indeed was lacking small detail which is \n// thickness change compensation at the beginning of formula \n// instead of just ( 2.0 ) we need ( 2.0 / thickness )\n// uncommenting full model\n\n#define M_PI 3.1415926535897932384626433832795\n\n// Used to perturb the value of the displacement for rough thread appearance\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat remap( float range_a_point, float a0, float a1, float b0, float b1 ){\n    return (((range_a_point - a0) * (abs(b1-b0)))/abs(a1-a0)) + b0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float x = uv.x * 5.;\n    float y = uv.y * 1.;\n    \n    \n    // When the facet length increases, if we still keep x and y varying between [0,1], \n    // then the texture stretches to facetlength and would appear loose. \n    // By increasing the tightness by a factor of facetlength, the thread appears tight again \n    \n    float facetlength = 5.0;\n    float tightness = 0.5; // (0,1]\n    float twist_trajectory = \n        ( ( asin( 2. * y - 1. )/( M_PI / 2. ) + 1. ) * tightness * facetlength ) / 2.; // (1)\n    \n    \n    // The trajectory of the twist in equation (1) is used to deﬁne the shading by \n    // considering the distance/displacement of a point from the trajectory\n    // where thickness indicates the thickness of the bundle that is twisted and has values in (0,1]\n    \n    float thickness = 1. - remap( sin( iTime - M_PI / 2.), -1., 1., 0., 0.6 ); // (0,1]\n    float x_plus_traj = x + twist_trajectory;\n    float displacement = \n        ( 2. / thickness ) * ( x_plus_traj - ( floor( x_plus_traj / thickness ) * thickness) ) - 1.; // (2)\n\n    \n    // To add roughness to the appearance of the twist \n    // we perturb the value of the displacement by a random value\n    // For this a parameter smoothness in [0,1] is introduced\n    // where rand_value has values in [ 0, thickness )\n    \n    float smoothness = 1.; //[0,1]\n    float rand_value = rand( uv ) * thickness;\n    float pdisplacement = \n        smoothness * displacement + ( 1. - smoothness) * rand_value; // (3)\n    \n    \n    // When the displacement is zero we would like the shading to be maximum \n    // and as the displacement increases we would like the value to decrease \n    // therefore we use the Gaussian function to achieve this behavior \n    \n    float twist_shading = exp( -(  pow( pdisplacement, 2. )/0.5 ) ); // (4)\n    \n    // Linear shading also looks great\n    // twist_shading = abs(pdisplacement);\n    \n    // The appearance of a thread facet is created by \n    // modulating the above shading of the twist of ﬁbers with \n    // the shading resulting from the shape of the thread. \n    // offset in [0,1] is used to control the darkness of shading at the periphery\n \n    float y_offset = 0.1; // [0,1]\n    float y_shading = y_offset + ( 1. - y_offset ) * sin( y * M_PI );\n    \n    \n    // The same formula can be used for the shading in the x direction \n    // if the thread facet is short. However the length of a facet can vary \n    // depending on the weave pattern, and if the facet is long the above shading \n    // gives the appearance of a wicker basket to the weave \n    // The shading when the thread facet is long is therefore deﬁned with the help \n    // of the tanh function as follows\n    \n    float x_shading = 1.;\n    float x_offset = 0.3; // [0,1]\n    float steepness = facetlength; // facetlength used as in original paper\n    if( uv.x < 0.5 ){\n        x_shading = x_offset + ( 1. - x_offset ) * tanh( uv.x * steepness );\n    }\n    if( uv.x >= 0.5 ){\n        x_shading = x_offset + ( 1. - x_offset ) * tanh( ( 1.0 - uv.x ) * steepness );\n    }\n    \n    // Final calculation of thread appearance\n    float thread_shading = twist_shading * y_shading * x_shading;\n    \n    vec3 col = vec3( thread_shading );\n    \n    // Output to screen\n    fragColor = vec4( col, 1.0);\n}","name":"Image","description":"","type":"image"}]}