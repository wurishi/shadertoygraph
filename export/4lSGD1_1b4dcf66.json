{"ver":"0.1","info":{"id":"4lSGD1","date":"1428420465","viewed":391,"name":"Shading model test","username":"sergei_am","description":"First steps in shadertoy","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sphere","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float TIME_MODIFIER = 0.3;\nconst float PI = 3.141592;\n\n\nvec4 eval_sphere( in vec3 pos, in vec4 sphere, in vec3 color )\n{\n\tvec3 d = pos - sphere.xyz;\n    return vec4(color, 1.0) * sphere.w / dot( d, d );\n}\n\nvec3 lissajous( in vec3 pos, in float fx, in float fy )\n{\n    return vec3(\n        pos.x * sin( fx * iTime * TIME_MODIFIER ),\n        pos.y * sin( fy * iTime * TIME_MODIFIER ),\n        0.0\n    );\n}\n\nvec4 eval(in vec3 pos)\n{\n    vec4 s1 = vec4(lissajous( vec3( 0.2, -0.3,  0.1), 1.3,  5.0), 1.5);\n    vec4 s2 = vec4(lissajous( vec3(-0.1,  1.0, -0.3), 1.0, -2.0), 0.9);\n    vec4 s3 = vec4(lissajous( vec3(-0.7, -0.1,  0.2), -1.0, 1.0), 1.8);\n    vec4 s4 = vec4(lissajous( vec3(0.1, -0.7,-0.8), 1.0,-1.0), 1.3);\n    vec4 s5 = vec4(lissajous( vec3(0.2, 1.2, 0.2), 0.5,-1.3),0.5);\n    \n    vec4 e =\n          eval_sphere(pos, s1, vec3(1.0,1.0,0.0))\n        + eval_sphere(pos, s2, vec3(0.0,1.0,1.0))\n        + eval_sphere(pos, s3, vec3(1.0,0.0,1.0))\n        + eval_sphere(pos, s4, vec3(0.5,0.5,1.0))\n        + eval_sphere(pos, s5, vec3(1.0,0.5,0.0));\n        \n    vec3 cols[5] = vec3[](vec3(0.,0.,0.),vec3(1.,0.,0.), vec3(0.,1.,0.), vec3(0.,0.,1.), vec3(1.,1.,1.));\n    for(int i=0; i<5; ++i)\n    {\n        float angle = iTime + PI*2.0*float(i)/5.0;\n        float color = (i&1) > 0 ? 1.0 : 0.0;\n        e += eval_sphere(pos, vec4(cos(angle)*0.8, sin(angle)*0.8, 0.0, 1.0), cols[i]);\n    }\n    return e;\n}\n\nbool scene( in vec3 ray, in vec3 eye, out vec3 P, out vec3 N, out vec3 albedo )\n{\n    const float N_STEP = 0.1;\n    const float B = 56.0;\n    \n    float prev = 0.0;\n    vec3 prev_eye = eye;\n    float e00;\n    \n    for( int i=0; i<355; ++i )\n    {\n        prev = e00;\n        prev_eye = eye;\n        \n        e00 = eval(eye).w;\n        eye += ray * 0.005;\n        if( e00 > B ) break;\n    }\n    \n    if( e00 > B*0.9 )\n    {\n        P = mix( prev_eye, eye, (e00 - B) / (e00 - prev));\n\n        vec3 ofs = vec3(1.0,0.0,0.0)*0.001;\n        \n        vec3 dummy;\n        vec4 e = eval(eye);\n        float base = e.w;\n        albedo = e.xyz;\n        \n        N =  ofs.xyz*(eval(eye + ofs.xyz).w - base);\n        N += ofs.yxz*(eval(eye + ofs.yxz).w - base);\n        N += ofs.yzx*(eval(eye + ofs.yzx).w - base);\n        N = normalize(-N);\n        \n        return true;\n    }\n    \n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.xy = (fragCoord.xy - iResolution.xy*0.5)/iResolution.yy;\n\n    vec3 V = normalize(vec3(fragCoord.xy, 1.0));\n    vec3 L = normalize(vec3(0.0, 1.0, -1.0));\n    \n    float Y = fragCoord.y;\n    \n    vec3 sky = vec3( 0.45, 0.75, 1.0 )*(Y+0.5);//*0.5;\n    \n    vec3 frag = vec3(0.3,0.5,0.7)*(1.0 - pow(abs(Y),0.5));\n    \n    vec3 P, N, albedo;\n    if( scene( V, vec3(0,0,-1.7), P, N, albedo ))\n    {\n        float dotNL = dot( N, L );\n        vec3 H = normalize( reflect(V,N) - V );\n        float dotHL = max( dot( H, L ), 0.0 );\n        float spec = pow( dotHL, 16.0 );\n        \n        //spec = max( spec - 0.7, 0.0 ) / 0.3;\n        \n        float F = pow( 1.0 - max( dot( -V, N ), 0.0 ), 5.0);  // fresnel\n        \n        frag = albedo*0.02*max( dotNL*0.5 + 0.5, 0.0);\n        \n        //frag += vec3(0.1,0.2,0.25) * F * 0.5;\n        \n        frag += spec*0.6;\n        \n\n    }\n    fragColor = vec4( frag, 1.0 );\n}","name":"Image","description":"","type":"image"}]}