{"ver":"0.1","info":{"id":"ltfyWS","date":"1506188813","viewed":305,"name":"Sun Rays ","username":"UglySwedishFish","description":"Probably going to be added inside of vrinnevi. Combined with lens flares this could create a very interesting looking light effect. Light count does not impact performance and reflected light can also create this effect.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["rays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat3 ACESInputMat = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nmat3 ACESOutputMat = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108, 1.10813, -0.07276,\n    -0.07367, -0.00605, 1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec4 ACESFitted(vec4 Color, float Exposure)\n{\n    Color.rgb *= Exposure;\n    Color.rgb = ACESInputMat * Color.rgb;\n    Color.rgb = RRTAndODTFit(Color.rgb);\n    Color.rgb = ACESOutputMat * Color.rgb;\n    return Color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texturesize = vec2(textureSize(iChannel0,0)); \n    vec2 TexelSize = 1.0 / texturesize; \n    vec4 finalColor = vec4(0.); \n  \n    \n     vec2 addon[4]; \n    addon[0] = vec2(15.,0.); \n    addon[1] = vec2(0.,15.); \n    addon[2] = vec2(10.,10.); \n    addon[3] = vec2(10.,-10.); \n    \n    //rotate them ever so slightly \n    mat4 rot = rotationMatrix(vec3(0.0,0.0,1.0),((sqrt(uv.x*uv.y)*0.5+0.5)+cos(sin(iTime))*0.05)+0.4); \n    for(int i=0;i<4;i++) {\n    \n    addon[i].xy = (vec4(addon[i].xy,0.0,1.0)*rot).xy; \n\n    }\n    \n    \n    \n\n    for(int x=-40;x<40;x++) {\n        if(x == 0)\n            x=1; \n        float Distance = abs(float(x)*(float(x)/2.0)) / 10.0; \n        \n      \n        \n        for(int i=0;i<4;i++) \n            finalColor+=texture(iChannel0,uv+(addon[i]*vec2(x))*TexelSize) * (1.0/Distance); \n        \n        \n   \t\n    }\n    \n    \n\t\n    \n\tfragColor = ACESFitted(finalColor,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define colorRange 32.0\n\nfloat getSquare(vec2 p, vec2 rp){\n    p *= vec2(iResolution.x, iResolution.y);\n    p /= max(iResolution.x, iResolution.y);\n        \n    p += rp;\n    vec2 bl = step(abs(p * 2.0 - 1.0),vec2(0.2));\n    float rt = bl.x * bl.y;\n    \n\treturn rt;\n}\n\nfloat getCircle(vec2 p, vec2 rp){\n\tp *= vec2(iResolution.x, iResolution.y);\n    p /= max(iResolution.x, iResolution.y);\n    \n    return step(distance(p, rp), 0.1);\n}\n\nfloat getTriangle(vec2 p, vec2 rp){\n    p *= vec2(iResolution.x, iResolution.y);\n    p /= max(iResolution.x, iResolution.y);\n    \n    p -= rp;\n\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n\n    // Remap the space to -1. to 1.\n    p = p *2.-1.;\n\n    // Number of sides of your shape\n    int N = 3;\n\n    // Angle and radius from the current pixel\n    float a = atan(p.x,p.y)+PI;\n    float r = TWO_PI/float(N);\n\n    // Shaping function that modulate the distance\n    d = cos(floor(.5+a/r)*r-a)*length(p);\n\n    return 1.0-step(.12,d);\n}\n\nvec3 getTexture(vec2 uv){\n    vec4 textureSample = texture(iChannel0, uv);\n\treturn sqrt(textureSample.rgb * textureSample.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / vec2(iResolution.x, iResolution.y);\n    \n\n    \n    vec3 rectangle = getSquare(uv, vec2(-0.3, 0.21)) * vec3(2.0, 12.0, 30.0) * 2.0;\n    vec3 circle = getCircle(uv, vec2(0.2, 0.29)) * vec3(30.0, 12.0, 2.0) * 2.0;\n    vec3 triangle = getTriangle(uv, vec2(0.0, -0.23)) * vec3(2.0, 30.0, 2.0) * 2.0;\n    \n    vec3 color = rectangle + circle + triangle;\n    \n    //color = pow(getTexture(uv), vec3(2.2)) * 10.0;\n    \n    fragColor = vec4(pow(color, vec3(1.0 / 1.)) / colorRange,1.0);\n    fragColor.xyz *= 0.25f;\n    \n   // fragColor.xyz = length(texture(iChannel0, uv).xyz) > 0.5f ? vec3(1.) : vec3(0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float Kernels[19] = float[](\n\n0.00001,\t\n\n    0.000078\t,\n    0.000489\t,\n    0.002403\t,\n    0.009245\t,\n    0.027835\t,\n    0.065591\t,\n    0.120978\t,\n    0.174667\t,\n    0.197413\t,\n    0.174667\t,\n    0.120978\t,\n    0.065591\t,\n    0.027835\t,\n    0.009245\t,\n    0.002403\t,\n    0.000489\t,\n    0.000078\t,\n    0.00001\n\n   );\n\nvec4 Gaussian(sampler2D t,vec2 tc) {\nvec2 t_size = 1.0/vec2(textureSize(t,0)); \nvec4 Final = vec4(0.); \n    for(int x=-9;x<9;x++) {\n    \tFinal += texture(t,vec2(tc.x,tc.y+t_size.y*float(x*3))) * Kernels[x+9]; \n    }\nreturn Final; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = Gaussian(iChannel0,uv); \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float Kernels[19] = float[](\n\n0.00001,\t\n\n    0.000078\t,\n    0.000489\t,\n    0.002403\t,\n    0.009245\t,\n    0.027835\t,\n    0.065591\t,\n    0.120978\t,\n    0.174667\t,\n    0.197413\t,\n    0.174667\t,\n    0.120978\t,\n    0.065591\t,\n    0.027835\t,\n    0.009245\t,\n    0.002403\t,\n    0.000489\t,\n    0.000078\t,\n    0.00001\n   );\n\n\nvec4 Gaussian(sampler2D t,vec2 tc) {\nvec2 t_size = 1.0/vec2(textureSize(t,0)); \nvec4 Final = vec4(0.); \n    for(int x=-9;x<9;x++) {\n    \tFinal += texture(t,vec2(tc.x+t_size.x*float(x*3),tc.y)) * Kernels[x+9]; \n    }\nreturn Final; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = Gaussian(iChannel0,uv); \n}","name":"Buffer B","description":"","type":"buffer"}]}