{"ver":"0.1","info":{"id":"XddfDr","date":"1524743124","viewed":753,"name":"fourier convergence transitions","username":"akhgary","description":"visualization of fourier series for square, triangle and sawtooth waves.\n\nspecial thanks to FabriceNeyret2.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["wave","triangle","visualization","animation","square","plot","convergence","fourier","squarewave","trianglewave","sawtooth","series","sawtoothwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fourier series:\n// https://en.wikipedia.org/wiki/Fourier_series#Convergence\n//\n// ========================================\n// Square wave:\n// http://mathworld.wolfram.com/FourierSeriesSquareWave.html\n//\n// Triangle wave:\n// http://mathworld.wolfram.com/TriangleWave.html\n//\n// Sawtooth wave:\n// http://mathworld.wolfram.com/SawtoothWave.html\n//\n// ========================================\n// distance formula used to plot waves smoothly\n// d = |fx-y|/sqrt(1+(dfx/dx)^2)\n// https://iquilezles.org/articles/distance\n// ========================================\n//\n// hue color picker taken from :\n// https://www.shadertoy.com/view/ll2cDc\n//\n// following function is used for smooth transition:\n// https://math.stackexchange.com/questions/2746958/smooth-floor-function\n\nconst float pi = 3.14159265359;\nconst float scale = 2.0;\nconst float thickness = 3.0*scale;\n\nconst float duration = 12.0; // duration visualizing each wave in seconds.\nconst float transition = 5.0; // transition speed. (dont know the unit) \n                              // but 1.0 means transition takes half of duration.\n                              // so it takes half of duration to make \"n\" terms\n                              // and another half of duration to remove \"n\" terms\n\nconst int terms = 10; // number of terms to produce\nconst float freq = 0.795; // frequency in hz\nconst float len = 2.0; // length of the wave. (period)\nconst float amp = 1.0; // amplitude of the wave.\n\nvec2 uvmap(vec2 uv)\n{\n    return (2.0*uv - iResolution.xy)/iResolution.y;\n}\n\n// color picker:\n// https://www.shadertoy.com/view/ll2cDc\nvec3 pickColor(float n) {\n    return 0.6+0.6*cos(6.3*n+vec3(0,23,21));\n}\n\nfloat smoothout(float dist){\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat circle(vec2 uv, vec2 C, float r, bool fill)\n{\n    vec2 p = uv-C;\n    float fx = length(p)-r;\n    float dist = fill? fx:abs(fx);\n    return smoothout(dist);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a; \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float dist = length(pa - ba * h);\n    return smoothout(dist);\n}\n\n// ==================Square Wave===================== \nfloat squarewave(float n, float x, float l, float phase){\n    n = n*2.0+1.0;\n    return amp*4.0/(n*pi)*sin(n*pi*x/l+phase);\n}\n\n// derivative of series terms.\nfloat dsquarewave(float n, float x, float l, float phase){\n    n = n*2.0+1.0;\n    return amp*4.0/l*cos(n*pi*x/l+phase);\n}\n\n// ===================Triangle Wave==================\nfloat trianglewave(float n, float x, float l, float phase){\n    float k = n*2.0+1.0;\n    return amp*8.0/(pi*pi)/(k*k)*cos(pi*n)*sin(k*pi*x/l+phase);\n}\n\nfloat dtrianglewave(float n, float x, float l, float phase){\n    float k = n*2.0+1.0;\n    return amp*8.0/pi/(k*l)*cos(pi*n)*cos(k*pi*x/l+phase);\n}\n\n// ====================Sawtooth Wave===================\nfloat sawtoothwave(float n, float x, float l, float phase){\n    n++;\n    return amp*2.0/(pi*n)*sin(n*pi*x/l+phase);\n}\n\nfloat dsawtoothwave(float n, float x, float l, float phase){\n    n++;\n    return amp*2.0/l*cos(n*pi*x/l+phase);\n}\n\n// ====================Wave switch===================\nfloat wave(float n, float x, float l, float phase){\n    switch(int(mod(iTime, duration*3.0) / duration))\n    {\n        case 0: return squarewave(n,x,l,phase);\n        case 1: return sawtoothwave(n,x,l,phase);\n        case 2: return trianglewave(n,x,l,phase);\n    }\n}\n\n// derivative of series terms.\nfloat dwave(float n, float x, float l, float phase){\n    switch(int(mod(iTime, duration*3.0) / duration))\n    {\n        case 0: return dsquarewave(n,x,l,phase);\n        case 1: return dsawtoothwave(n,x,l,phase);\n        case 2: return dtrianglewave(n,x,l,phase);\n    }\n}\n// =======================================\n\n// used for smooth transitions\nfloat smoothfloor(float x) {\n    return x - sin(2.0*pi*x)/(2.0*pi);\n}\n\n// maps sin wave with amplitude [-1,1]    and period 2*pi\n// to   sin wave with amplitude [0,terms] and period duration\nfloat clock(){\n    return float(terms)/2.0*(1.0 - cos(iTime*2.0*pi/duration));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = uvmap(fragCoord.xy)*scale;\n    vec3 col = vec3(0);\n        \n    float l = len/2.0; // wave length divided by two.\n    vec2 c = vec2(0); // center of the circles\n    float sum = 0.0; // fourier series sum\n    float dsum = 0.0; // derivative of the sum\n    float tsum = 0.0; // sum for red line\n    \n    float smfloor = smoothfloor(clock()*transition);\n    float time = iTime*freq;\n    \n    for(int i=0; i<terms; i++) {\n        float n = float(i);\n        vec3 color = pickColor(n/float(terms));\n        \n        float mul = clamp(smfloor - n,0.0,1.0);\n        \n        // calculate fourier series terms for circles\n        float term = wave(n, time, l, 0.0)*mul;\n        float cterm = wave(n, time, l, pi/2.0)*mul;\n        vec2 r = vec2(cterm,term);\n        \n        // plot circles\n        col += circle(uv,c,length(r),false)*color;\n        col += line(uv,c, c += r)*color;\n        \n        // calculate fourier series terms for wave plot\n        sum += wave(n, time-uv.x+len/2.0, l, 0.0)*mul;\n        dsum += dwave(n, time-uv.x+len/2.0, l, 0.0)*mul;\n        tsum += term;\n    }\n    \n    // wave plot\n    float dist = abs(uv.y-sum)/sqrt(1.0+dsum*dsum);\n    col+=smoothout(dist);\n\n    // red line\n    col+=(line(uv,c,vec2(+l,c.y))\n        + line(uv,c,vec2(-l,c.y))\n        + circle(uv,vec2(+l,tsum),0.01,true)\n        + circle(uv,vec2(-l,tsum),0.01,true))*vec3(1,0,0);\n    \n    // grid lines\n    col+=(smoothout(abs(uv.y+amp))\n        + smoothout(abs(uv.y-amp))\n        + smoothout(abs(uv.x+l))\n        + smoothout(abs(uv.x-l)))*vec3(0.25);\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}