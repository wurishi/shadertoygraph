{"ver":"0.1","info":{"id":"Mc3cW7","date":"1730733123","viewed":53,"name":"Sparkling Globs - Course Project","username":"victorlga","description":"Done by Victor Assis for Computer Graphics course at Insper (Brazil)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circles","edu","sparkling","globs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Generates a pseudo-random float value based on input `x` using a sine-based hash function\nfloat randomFloat(float x) {\n    return fract(sin(x) * 43758.5453);\n}\n\n// Generates a pseudo-random float value from a 2D vector `v` using a dot-product hash function\nfloat randomFloatFromVec2(vec2 v) {\n    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Generates a random color based on the input vector `v`, using randomFloat on each component\nvec3 randomColor(vec3 v){\n    return vec3(randomFloat(v.x) - 0.08, randomFloat(v.y), randomFloat(v.z) + 0.15);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize fragment coordinates to range [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n    float ratio = iResolution.y / iResolution.x;\n    \n    // Center and adjust coordinates for aspect ratio\n    uv -= 0.5;\n    uv.x /= ratio;\n    \n    // Define the grid size for positioning circles\n    float gridCount = 3.0;\n    uv *= gridCount;\n    \n    // Compute grid position and offset for centering within each grid cell\n    vec2 grid = fract(uv) - 0.5;\n\n    vec3 glob = vec3(0.0); // Accumulator for color output\n    vec2 globCoord = floor(uv); // Integer grid coordinates\n    \n    float r = 0.001; // Base radius for circles\n    float k = 0.02;  // Smoothing factor\n    \n    // Determine the number of circles in each cell, slightly randomized\n    float n_iter = floor(16.0 - randomFloatFromVec2(globCoord) * 4.0);\n    \n    // Loop to generate multiple circles per cell\n    for (float i = 0.0; i < n_iter; i++) {\n        \n        // Generate a seed value for randomness within the grid cell\n        vec2 seed = globCoord * randomFloat(i) * randomFloat(n_iter) + i;\n        \n        // Compute random offsets for the x and y positions of the circle's center\n        float offsetX = randomFloat(globCoord.x * seed.y + globCoord.y + seed.x) * 2.2831;\n        float offsetY = randomFloat(globCoord.y * seed.x + globCoord.x + seed.y) * 6.2831;\n        \n        // Define the circle's center with a small animated offset\n        vec2 center = vec2(sin(iTime * randomFloat(seed.y) + offsetX) * 0.18, cos(iTime * randomFloat(seed.x) + offsetY) * 0.18);\n       \n        \n        // Generate a smooth circle with smooth edges\n        float circle = smoothstep(\n            r + randomFloatFromVec2(globCoord * i - i) * 0.13 + k,\n            r + randomFloatFromVec2(globCoord * i - i) * 0.13,\n            length(grid - center)\n        );\n        \n        // Sparkle effect: Modulate brightness based on time to create a pulsing effect\n        float sparkleFactor = 0.9 + 0.1 * sin(iTime * 2.5 + randomFloat(seed.x * seed.y) * 4.2831);\n        \n        // Apply random color and sparkle effect to the circle\n        vec3 coloredCircle = circle * randomColor(vec3(seed, randomFloat(i))) * sparkleFactor;\n        \n        // Accumulate color for each circle in the grid\n        glob += coloredCircle * coloredCircle * coloredCircle * coloredCircle;\n    }\n    \n    vec3 finalGlob = smoothstep(0.2, 0.5, glob);\n    \n    // Output the final color\n    fragColor = vec4(finalGlob, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}