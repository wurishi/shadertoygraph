{"ver":"0.1","info":{"id":"43dGR2","date":"1719558459","viewed":45,"name":"raytracing.github.io","username":"thacuber2a03","description":"part of the raytracer in the first book of the Raytracing in One Weekend series done for fun.\nstuck because I don't know how to recurse iteratively well enough.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926535897932385;\nconst float infinity = 1. / 0.000001;\n\n#define deg2rad(deg) ((deg) * pi / 180.0)\n\nstruct ray { vec3 orig, dir; };\n#define ray_at(r, t) ((r).orig + (t) * (r).dir)\n\nstruct interval { float min, max; };\n#define interval_empty() interval(infinity, -infinity)\n#define interval_universe() interval(-infinity, infinity)\n\n#define interval_size(i) ((i).max - (i).min)\n#define interval_contains(i,x) \\\n    ((i).min <= (x) && (x) <= (i).max)\n\n#define interval_surrounds(i,x) \\\n    ((i).min < (x) && (x) <= (i).max)\n\n/************************************************/\n\n// gold_noise by @dcerisano\n// https://www.shadertoy.com/view/ltB3zD\n\nconst float PHI = 1.61803398874989484820459; // Î¦ = Golden Ratio \n\nfloat gold_noise(in vec2 xy, in float seed)\n{\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n/************************************************/\n\nstruct hitRecord\n{\n    bool hit;\n    vec3 p, normal;\n    float t;\n    bool frontFace;\n};\n\nhitRecord setFaceNormal(\n    hitRecord rec, const ray r, const vec3 outwardNormal)\n{\n    hitRecord res;\n    \n    res.hit = rec.hit;\n    res.p = rec.p;\n    res.t = rec.t;\n    res.frontFace = dot(r.dir, outwardNormal) < 0.;\n    res.normal = res.frontFace ?\n        outwardNormal : -outwardNormal;\n\n    return res;\n}\n\n/************************************************/\n\nstruct sphere {\n    vec3 center;\n    float radius;\n};\n\n#define SPHERE_AMT 2\n\nhitRecord hit(\n    sphere s, const ray r, interval rayT)\n{\n    hitRecord rec;\n    rec.hit = false;\n\n    vec3 oc = s.center - r.orig;\n    float a = dot(r.dir, r.dir);\n    float h = dot(r.dir, oc);\n    float c = dot(oc, oc) - s.radius*s.radius;\n    \n    float discriminant = h*h - a*c;\n    if (discriminant < 0.) return rec;\n    \n    float sqrtd = sqrt(discriminant);\n    \n    float root = (h - sqrtd) / a;\n    if (!interval_surrounds(rayT, root))\n    {\n        root = (h + sqrtd) / a;\n        if (!interval_surrounds(rayT, root))\n            return rec;\n    }\n    \n    rec.hit = true;\n    rec.t = root;\n    rec.p = ray_at(r, rec.t);\n    vec3 outwardNormal = (rec.p - s.center) / s.radius;\n    return setFaceNormal(rec, r, outwardNormal);\n}\n\nhitRecord hit(\n    sphere[SPHERE_AMT] s, const ray r, interval rayT)\n{\n    hitRecord rec;\n    rec.hit = false;\n    float closestSoFar = rayT.max;\n    \n    for (int i = 0; i < SPHERE_AMT; i++)\n    {\n        hitRecord tempRec =\n            hit(s[i], r, interval(rayT.min, closestSoFar));\n\n        if (tempRec.hit)\n        {\n            rec = tempRec;\n            closestSoFar = tempRec.t;\n        }\n    }\n    \n    return rec;\n}\n\n/************************************************/\n\nstruct camera\n{\n    vec3 center;\n    vec3 pixel00Loc;\n    vec3 pixelDeltaU, pixelDeltaV;\n    int samplesPerPixel;\n    float pixelSamplesScale;\n};\n\ncamera cam_initialize(camera cam)\n{\n    cam.pixelSamplesScale = 1. / float(cam.samplesPerPixel);\n    cam.center = vec3(0,0,0);\n    \n    float focalLength = 1.0;\n    const float viewportHeight = 2.0;\n    float viewportWidth = viewportHeight * (float(iResolution.x) / iResolution.y);\n        \n    vec3 viewportU = vec3(viewportWidth, 0, 0);\n    vec3 viewportV = vec3(0, viewportHeight, 0);\n    \n    cam.pixelDeltaU = viewportU / iResolution.x;\n    cam.pixelDeltaV = viewportV / iResolution.y;\n    \n    vec3 viewportUpperLeft = cam.center\n        - vec3(0, 0, focalLength)\n        - viewportU/2. - viewportV/2.;\n    \n    cam.pixel00Loc = viewportUpperLeft + 0.5 * (cam.pixelDeltaU + cam.pixelDeltaV);\n    \n    return cam;\n}\n\nvec3 cam_rayColor(\n    const camera c, const ray r, sphere[SPHERE_AMT] s)\n{\n    hitRecord rec = hit(s, r, interval(0., infinity));\n    if (rec.t > 0.0)\n        // stuck here. how to recurse iteratively?\n        return 0.5 * (rec.normal + vec3(1));\n\n    vec3 unitDirection = normalize(r.dir);\n    float a = 0.5 * (unitDirection.y + 1.0);\n    return mix(vec3(1), vec3(0.5, 0.7, 1), a);\n}\n\nray cam_getRay(const camera cam, vec2 fragCoord, float idx)\n{\n    vec3 offset = vec3(\n        clamp(gold_noise(fragCoord, fract(idx+iTime)), 0., 1.) - 0.5,\n        clamp(gold_noise(fragCoord, fract(idx+iTime)), 0., 1.) - 0.5,\n        0\n    );\n    \n    vec3 pixelSample = cam.pixel00Loc\n        + ((fragCoord.x + offset.x) * cam.pixelDeltaU)\n        + ((fragCoord.y + offset.y) * cam.pixelDeltaV);\n    \n    vec3 origin = cam.center;\n    vec3 direction = pixelSample - origin;\n    return ray(origin, direction);\n}\n\nvec4 cam_render(const camera cam, sphere[SPHERE_AMT] world, vec2 fragCoord)\n{\n    vec4 col = vec4(0);\n    \n    for (int i = 0; i < cam.samplesPerPixel; i++)\n    {\n        ray r = cam_getRay(cam, fragCoord, float(i));\n        col += vec4(cam_rayColor(cam, r, world), 1);\n    }\n    \n    return col * cam.pixelSamplesScale;\n}\n\n/************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sphere[SPHERE_AMT] world;\n    world[0] = sphere(vec3(0,0,-1), 0.5);\n    world[1] = sphere(vec3(0, -100.5, -1), 100.);\n\n    camera cam;\n    cam.samplesPerPixel = 10;\n    cam = cam_initialize(cam);\n    fragColor = cam_render(cam, world, fragCoord);\n}","name":"Image","description":"","type":"image"}]}