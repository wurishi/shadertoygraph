{"ver":"0.1","info":{"id":"dlfXRM","date":"1674475114","viewed":632,"name":"Sprite rotation via 3x shear ops","username":"Farbs","description":"An implementation of the 3x shear algorithm for sprite rotation described here:\nhttps://cohost.org/tomforsyth/post/891823-rotation-with-three\n\nNote that eye pixels are never lost or duplicated, and cheeks are always tetronimoes!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sprite","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord / 5.0);\n    \n    // rotate via shears!\n    // from https://cohost.org/tomforsyth/post/891823-rotation-with-three\n    // this should maintain a 1:1 relationship between source and destination pixels\n    // so cool!\n    //\n    // Instead of shearing the sprite data tho I'm shearing the texture sample coords. Same thing but backwards.\n    //\n    // shear in X by -tan(angle/2)\n    // shear in Y by sin(angle)\n    // shear in X by -tan(angle/2)\n    //\n    \n    float angle = fract(iTime * 0.003);// angle in 0..1 space, representing -90 to 270 degrees.\n    if( angle > 0.5 ) // if beyond a quarter turn, flip x and y and fix angle. For some reason shear doesn't work nicely outside that range.\n    {\n        fragCoord = -fragCoord;\n        angle -= 0.5;\n    }\n    angle = (angle-0.25) * 2.0 * 3.14159265359; // re,a[ tp radians\n    \n    \n    fragCoord.x -= floor(tan(angle/2.0)*fragCoord.y);\n    fragCoord.y += floor(sin(angle)*fragCoord.x);\n    fragCoord.x -= floor(tan(angle/2.0)*fragCoord.y);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, fragCoord / vec2(textureSize(iChannel0, 0))).rgb;//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}