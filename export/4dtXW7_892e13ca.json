{"ver":"0.1","info":{"id":"4dtXW7","date":"1459753789","viewed":372,"name":"Shader Lesson #4: Pythagoras","username":"hubbe","description":"Demonstrates the pythagorean theorem.  Moving the red, blue and green triangles will either let you build two squares, with sides matching the sides of the triangle (in white). Or, you can build one larger square with sides matching the hypotenuse. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["educational","mondrian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Plot a function, and a background grid.\n\nhighp float pi = 3.14159265;\n\n// Fom -2 to 2\nhighp float scale = 4.0;\n\n// Transform an vec2 onscreen coordinate (0.0-1.0) to a coordinate that\n// we want to plot the function for. (+/- scale*2)\nvec2 p2v(vec2 pos) {\n    pos -= vec2(0.5 * iResolution.x/iResolution.y, 0.5);\n    pos *= scale;\n    return pos;\n}\n\nfloat a() {\n    float f = sin(iTime / 2.0) * 0.8;\n    return f + 1.1;\n}\n\nfloat b() {\n    float f = sin(iTime / 2.0 / pi) * 0.8;\n    return f + 1.1;\n}\n\n// Draws the triangle.\nbool t(vec2 pos) {\n    pos = p2v(pos);\n//    if (pos.x < 0.0 && pos.y < 0.0 && pos.x > -b() * pos.y / a()- b())\n//        return true;\n\n    return pos.x > 0.0 && pos.y > 0.0 && pos.x < a() - a() * pos.y / b();  \n}\n\n// Draws one side square.\nbool c1(vec2 pos) {\n    pos = p2v(pos);\n    if (a() < b()) {\n      return pos.x > 0.0 && pos.y > 0.0 && pos.x < a() && pos.y < a();\n    } else {\n       return pos.x > 0.0 && pos.y < 0.0 && pos.x < a() && pos.y > - a();\n    }        \n}\n\n// Draws the other side square.\nbool c2(vec2 pos) {\n    pos = p2v(pos);\n    if (a() < b()) {\n       return pos.x < 0.0 && pos.y > 0.0 && pos.x > -b() && pos.y < b();\n    } else {\n       return pos.x > 0.0 && pos.y > 0.0 && pos.x < b() && pos.y < b();\n    }        \n}\n\n// Draws the square for the hypotenuse.\nbool h(vec2 pos) {\n    pos = p2v(pos);\n    vec2 av = vec2(a(), 0.0);\n    vec2 bv = vec2(0.0, b());\n    vec2 ab = bv - av;\n    float l = length(ab);\n    ab /= l;\n    vec2 abx = vec2(ab.y, -ab.x);\n    pos -= bv;\n    vec2 v = vec2(dot(abx, pos), dot(ab, pos));\n    return v.y < 0.0 && v.y > -l && v.x < 0.0 && v.x > -l;\n}\n\n\nvec4 squares(vec2 pos) {\n   \tbool H = h(pos);\n    bool C1 = c1(pos);\n    bool C2 = c2(pos);\n    vec4 ret = vec4(H ? 1.0 : 0.5, C1 ? 1.0 : 0.5, C2 ? 1.0 : 0.5, \n                (H || C1 || C2) ? 1.0 : 0.0);\n\tvec2 p = p2v(pos);\n    if (a() < b()) {\n        if (!H && C2 && p.y < b() - a())\n            ret = vec4(0,0,1,1);\n        if (H && p.x > 0.0 && p.y > a())\n            ret = vec4(0,0,1,1);\n        if (!H && C1)\n            ret = vec4(0,1,0,1);\n        if (H && p.y < 0.0 && p.x < a() - b())\n            ret = vec4(0,1,0,1);\n        if (!H && C2 && p.y > b() - a())\n            ret = vec4(1,0,0,1);\n        if (H && p.y < 0.0 && p.x > a() - b())\n            ret = vec4(1,0,0,1);\n    } else {\n        if (!H && C1 && p.x < a() - b())\n            ret = vec4(0,1,0,1);\n        if (H && p.y > 0.0 && p.x > b())\n            ret = vec4(0,1,0,1);\n        if (!H && C2)\n            ret = vec4(0,0,1,1);\n        if (H && p.x < 0.0 && p.y < b() - a())\n            ret = vec4(0,0,1,1);\n        if (!H && C1 && p.x > a() - b())\n            ret = vec4(1,0,0,1);\n        if (H && p.x < 0.0 && p.y > b() - a())\n            ret = vec4(1,0,0,1);\n    }\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    int cnt = 0;\n    int cnt2 = 0;\n    int cnt3 = 0;\n    int cnt4 = 0;\n    int max_cnt = 0;\n    // Multisample.\n    vec4 sum = vec4(0.0);\n    for (float x = -1.25; x <= 1.25; x += 0.25) {\n        for (float y = -1.25; y <= 1.25; y += 0.25) {\n            max_cnt ++;\n            if (t((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt ++;\n            if (c1((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt2 ++;\n            if (c2((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt3 ++;\n            if (h((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt4 ++;\n            sum += squares((fragCoord.xy + vec2(x, y)) / iResolution.yy);\n        }\n    }\n    if (cnt > max_cnt / 2) cnt = max_cnt - cnt;\n    if (cnt2 > max_cnt / 2) cnt2 = max_cnt - cnt2;\n    if (cnt3 > max_cnt / 2) cnt3 = max_cnt - cnt3;\n    if (cnt4 > max_cnt / 2) cnt4 = max_cnt - cnt4;\n    sum /= float(max_cnt);\n    \n    float color = float(cnt) * 2.0 / float(max_cnt);\n    float color2 = float(cnt2) * 2.0 / float(max_cnt);\n    float color3 = float(cnt3) * 2.0 / float(max_cnt);\n    float color4 = float(cnt4) * 2.0 / float(max_cnt);\n\tfloat bg = 0.0;\n    vec2 v = p2v(uv);\n    // Black axis\n//    if (abs(v.x) < scale/iResolution.x || abs(v.y) < scale/iResolution.y) {\n//      bg = 0.0;\n//    } else {\n\t    vec2 grid = step(mod(v, vec2(2.0, 2.0)), vec2(1.0, 1.0));\n    \tif (grid.x == grid.y) {\n          bg = 0.3;\n        } else {\n          bg = 0.4;\n        }\n//    }\n    \n    // Blend colors.\n    fragColor = vec4(bg);\n    fragColor = mix(fragColor, sum, sum.w);\n    fragColor = mix(fragColor, vec4(0.0), color2);\n    fragColor = mix(fragColor, vec4(0.0), color3);\n    fragColor = mix(fragColor, vec4(0.0), color4);\n    fragColor = mix(fragColor, vec4(2.0), color);\n}","name":"Image","description":"","type":"image"}]}