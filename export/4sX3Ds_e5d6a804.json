{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n// turn this to 1 to use manhattan distance.  Thanks Mx7f!\n#if 0\nfloat lengthM(vec2 v) { return abs(v.x) + abs(v.y); }\n#define length(x) lengthM(x)\n#endif\n\n//==============================================\n// Structs\n//==============================================\nstruct SCircle\n{\n\tvec2  m_center;\n\tfloat m_radius;\n\tvec3  m_color;\n};\n\t\nstruct STriangle\n{\n\tvec2 m_pointA;\n\tvec2 m_pointB;\n\tvec2 m_pointC;\n\tvec3 m_color;\n};\n\t\nstruct SSquare\n{\n\tvec2 m_pointA;\n\tvec2 m_pointB;\n\tvec2 m_pointC;\n\tvec2 m_pointD;\n\tvec3 m_color;\t\n};\n\t\nstruct SPentagon\n{\n\tvec2 m_pointA;\n\tvec2 m_pointB;\n\tvec2 m_pointC;\n\tvec2 m_pointD;\n\tvec2 m_pointE;\n\tvec3 m_color;\t\n};\n\t\nstruct SHitInfo\n{\n\tfloat m_distance;\n\tvec3 m_color;\n};\n\t\n//==============================================\n// Functions for global object support\n//==============================================\nvec2 Rotate2d (vec2 point, float angle)\n{\n\treturn vec2\n\t\t(\n\t\t\tpoint.x * cos(angle) - point.y * sin(angle),\n\t\t\tpoint.y * cos(angle) + point.x * sin(angle)\n\t\t);\n}\t\n\t\nSCircle circle1 =\n\tSCircle\n\t(\n\t\tvec2(0.5,0.5),\n\t\t0.1,\n\t\tvec3(1.0,0.0,0.0)\n\t);\n\t\nSCircle circle2 =\n\tSCircle\n\t(\n\t\tvec2(1.3,0.3),\n\t\t0.15,\n\t\tvec3(0.0,1.0,0.0)\n\t);\t\n\nSCircle circle3 =\n\tSCircle\n\t(\n\t\tvec2(1.2,0.8),\n\t\t0.01 + (sin(iTime*0.87) + 1.0) * 0.05,\n\t\tvec3(0.0,0.0,1.0)\n\t);\n\nvec2 triangle1Offset = vec2(cos(iTime*0.93)*0.1, sin(iTime*0.93)*0.1);\nSTriangle triangle1 =\n\tSTriangle\n\t(\n\t\tvec2(0.8, 0.3) + triangle1Offset,\n\t\tvec2(0.9, 0.4) + triangle1Offset,\n\t\tvec2(1.0, 0.3) + triangle1Offset,\n\t\tvec3(1.0,1.0,0.0)\n\t);\n\n\nfloat square1Rotation = iTime * 0.74;\nvec2 square1Pos = vec2(1.0, 0.6);\nSSquare square1 =\n\tSSquare\n\t(\n\t\tRotate2d(vec2(-0.025,  0.1), square1Rotation) + square1Pos,\n\t\tRotate2d(vec2( 0.025,  0.1), square1Rotation) + square1Pos,\n\t\tRotate2d(vec2( 0.025, -0.1), square1Rotation) + square1Pos,\n\t\tRotate2d(vec2(-0.025, -0.1), square1Rotation) + square1Pos,\n\t\tvec3(1.0,0.0,1.0)\n\t);\n\nvec2 pentagon1Offset = vec2(0.0, sin(iTime * 0.83) * 0.5 + 0.5);\nSPentagon pentagon1 =\n\tSPentagon\n\t(\n\t\tvec2(0.05, 0.0)   + pentagon1Offset,\t\t\n\t\tvec2(0.05, 0.05)  + pentagon1Offset,\n\t\tvec2(0.1 , 0.1)   + pentagon1Offset,\t\t\n\t\tvec2(0.15, 0.05)  + pentagon1Offset,\n\t\tvec2(0.15, 0.0)   + pentagon1Offset,\n\t\tvec3(0.0,1.0,1.0)\n\t);\n\n//==============================================\n// Macro lists\n//==============================================\n\n#define SHAPES CIRCLE(circle1) CIRCLE(circle2) CIRCLE(circle3) TRIANGLE(triangle1) SQUARE(square1) PENTAGON(pentagon1)\n\n//==============================================\n// taken from \"real time collision detection\" 5.1.9.1\nfloat Signed2DTriArea (vec2 a, vec2 b, vec2 c)\n{\n\treturn (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\n}\n\n//==============================================\nfloat SignedDistanceToLineSegment (in vec2 coordinate, in vec2 pointA, in vec2 pointB)\n{\n\tvec2 AB = pointB - pointA;\n\tfloat ABlen = length(AB);\n\tAB = normalize(AB);\n\tvec2 AtoCoord = coordinate - pointA;\n\t\n\tfloat proj = dot(AtoCoord, AB);\n\tproj = max(proj, 0.0);\n\tproj = min(proj, ABlen);\n\tvec2 closestPoint = pointA + AB * proj;\n\t\n\tfloat sign = Signed2DTriArea(coordinate, pointA, pointB);\n\tif (sign > 0.0)\n\t\treturn length(closestPoint - coordinate);\n\telse\n\t\treturn -length(closestPoint - coordinate);\n}\n\n//==============================================\nbool PointInFeatureSegment (in vec2 coordinate, in vec2 A, in vec2 B)\n{\n\t// check if it's on the positive side of AB\n\tif (SignedDistanceToLineSegment(coordinate, A, B) < 0.0)\n\t\treturn false;\n\n\t// make sure it's between A and B\n\tvec2 AB = B - A;\n\tvec2 normal = vec2(AB.y, -AB.x);\t\n\treturn SignedDistanceToLineSegment(coordinate, A, A + normal) >= 0.0 &&\n\t       SignedDistanceToLineSegment(coordinate, B, B + normal) <= 0.0;\n}\n\n\n//==============================================\nbool PointInFeaturePoint (in vec2 coordinate, in vec2 A, in vec2 B, in vec2 C)\n{\n\tvec2 AB = B - A;\n\tvec2 ABnormal = vec2(AB.y, -AB.x);\n\n\tvec2 BC = C - B;\n\tvec2 BCnormal = vec2(BC.y, -BC.x);\n\t\n\treturn SignedDistanceToLineSegment(coordinate, B, B + ABnormal) >= 0.0 &&\n\t\t   SignedDistanceToLineSegment(coordinate, B, B + BCnormal) <= 0.0;\n}\n\n//==============================================\nSHitInfo TestPentagon (in vec2 coordinate, in SPentagon pentagon)\n{\n\t// test the segment features\n\tif (PointInFeatureSegment(coordinate, pentagon.m_pointA, pentagon.m_pointB)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, pentagon.m_pointA, pentagon.m_pointB),\n\t\t\t\tpentagon.m_color*0.5\t\n\t\t\t);\n\t}\n\n\tif (PointInFeatureSegment(coordinate, pentagon.m_pointB, pentagon.m_pointC)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, pentagon.m_pointB, pentagon.m_pointC),\n\t\t\t\tpentagon.m_color*0.5\t\n\t\t\t);\n\t}\n\t\n\tif (PointInFeatureSegment(coordinate, pentagon.m_pointC, pentagon.m_pointD)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, pentagon.m_pointC, pentagon.m_pointD),\n\t\t\t\tpentagon.m_color*0.5\t\n\t\t\t);\n\t}\n\t\n\tif (PointInFeatureSegment(coordinate, pentagon.m_pointD, pentagon.m_pointE)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, pentagon.m_pointD, pentagon.m_pointE),\n\t\t\t\tpentagon.m_color*0.5\t\n\t\t\t);\n\t}\t\n\t\n\tif (PointInFeatureSegment(coordinate, pentagon.m_pointE, pentagon.m_pointA)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, pentagon.m_pointE, pentagon.m_pointA),\n\t\t\t\tpentagon.m_color*0.5\t\n\t\t\t);\n\t}\t\n\t\n\t// test the point features\n\tif (PointInFeaturePoint(coordinate, pentagon.m_pointA, pentagon.m_pointB, pentagon.m_pointC)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - pentagon.m_pointB),\n\t\t\t\tpentagon.m_color*0.25\t\n\t\t\t);\n\t}\n\t\n\tif (PointInFeaturePoint(coordinate, pentagon.m_pointB, pentagon.m_pointC, pentagon.m_pointD)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - pentagon.m_pointC),\n\t\t\t\tpentagon.m_color*0.25\t\n\t\t\t);\n\t}\n\n\tif (PointInFeaturePoint(coordinate, pentagon.m_pointC, pentagon.m_pointD, pentagon.m_pointE)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - pentagon.m_pointD),\n\t\t\t\tpentagon.m_color*0.25\t\n\t\t\t);\n\t}\t\t\n\n\tif (PointInFeaturePoint(coordinate, pentagon.m_pointD, pentagon.m_pointE, pentagon.m_pointA)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - pentagon.m_pointE),\n\t\t\t\tpentagon.m_color*0.25\t\n\t\t\t);\n\t}\t\t\n\t\n\tif (PointInFeaturePoint(coordinate, pentagon.m_pointE, pentagon.m_pointA, pentagon.m_pointB)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - pentagon.m_pointA),\n\t\t\t\tpentagon.m_color*0.25\t\n\t\t\t);\n\t}\t\t\t\n\t\n\t\n\t// if we got here, the point is inside the triangle\n\treturn SHitInfo\n\t\t(\n\t\t\t0.0,\n\t\t\tpentagon.m_color\n\t\t);\n}\n\n\n//==============================================\nSHitInfo TestSquare (in vec2 coordinate, in SSquare square)\n{\n\t// test the segment features\n\tif (PointInFeatureSegment(coordinate, square.m_pointA, square.m_pointB)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, square.m_pointA, square.m_pointB),\n\t\t\t\tsquare.m_color*0.5\t\n\t\t\t);\n\t}\n\n\tif (PointInFeatureSegment(coordinate, square.m_pointB, square.m_pointC)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, square.m_pointB, square.m_pointC),\n\t\t\t\tsquare.m_color*0.5\t\n\t\t\t);\n\t}\n\t\n\tif (PointInFeatureSegment(coordinate, square.m_pointC, square.m_pointD)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, square.m_pointC, square.m_pointD),\n\t\t\t\tsquare.m_color*0.5\t\n\t\t\t);\n\t}\n\t\n\tif (PointInFeatureSegment(coordinate, square.m_pointD, square.m_pointA)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, square.m_pointD, square.m_pointA),\n\t\t\t\tsquare.m_color*0.5\t\n\t\t\t);\n\t}\t\n\t\n\t// test the point features\n\tif (PointInFeaturePoint(coordinate, square.m_pointA, square.m_pointB, square.m_pointC)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - square.m_pointB),\n\t\t\t\tsquare.m_color*0.25\t\n\t\t\t);\n\t}\n\t\n\tif (PointInFeaturePoint(coordinate, square.m_pointB, square.m_pointC, square.m_pointD)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - square.m_pointC),\n\t\t\t\tsquare.m_color*0.25\t\n\t\t\t);\n\t}\n\n\tif (PointInFeaturePoint(coordinate, square.m_pointC, square.m_pointD, square.m_pointA)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - square.m_pointD),\n\t\t\t\tsquare.m_color*0.25\t\n\t\t\t);\n\t}\t\t\n\n\tif (PointInFeaturePoint(coordinate, square.m_pointD, square.m_pointA, square.m_pointB)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - square.m_pointA),\n\t\t\t\tsquare.m_color*0.25\t\n\t\t\t);\n\t}\t\t\n\t\n\t\n\t// if we got here, the point is inside the triangle\n\treturn SHitInfo\n\t\t(\n\t\t\t0.0,\n\t\t\tsquare.m_color\n\t\t);\n}\n\n//==============================================\nSHitInfo TestTriangle (in vec2 coordinate, in STriangle triangle)\n{\n\t// test the segment features\n\tif (PointInFeatureSegment(coordinate, triangle.m_pointA, triangle.m_pointB)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, triangle.m_pointA, triangle.m_pointB),\n\t\t\t\ttriangle.m_color*0.5\t\n\t\t\t);\n\t}\n\n\tif (PointInFeatureSegment(coordinate, triangle.m_pointB, triangle.m_pointC)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, triangle.m_pointB, triangle.m_pointC),\n\t\t\t\ttriangle.m_color*0.5\t\n\t\t\t);\n\t}\n\t\n\tif (PointInFeatureSegment(coordinate, triangle.m_pointC, triangle.m_pointA)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tSignedDistanceToLineSegment(coordinate, triangle.m_pointC, triangle.m_pointA),\n\t\t\t\ttriangle.m_color*0.5\t\n\t\t\t);\n\t}\n\t\n\t// test the point features\n\tif (PointInFeaturePoint(coordinate, triangle.m_pointA, triangle.m_pointB, triangle.m_pointC)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - triangle.m_pointB),\n\t\t\t\ttriangle.m_color*0.25\t\n\t\t\t);\n\t}\n\t\n\tif (PointInFeaturePoint(coordinate, triangle.m_pointB, triangle.m_pointC, triangle.m_pointA)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - triangle.m_pointC),\n\t\t\t\ttriangle.m_color*0.25\t\n\t\t\t);\n\t}\n\n\tif (PointInFeaturePoint(coordinate, triangle.m_pointC, triangle.m_pointA, triangle.m_pointB)) {\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tlength(coordinate - triangle.m_pointA),\n\t\t\t\ttriangle.m_color*0.25\t\n\t\t\t);\n\t}\t\t\n\n\t// if we got here, the point is inside the triangle\n\treturn SHitInfo\n\t\t(\n\t\t\t0.0,\n\t\t\ttriangle.m_color\n\t\t);\n}\n\n//==============================================\nSHitInfo TestCircle (in vec2 coordinate, in SCircle circle)\n{\n\tfloat dist = length(circle.m_center - coordinate) - circle.m_radius;\n\t\n\tif (dist <= 0.0)\n\t{\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\t0.0,\n\t\t\t\tcircle.m_color\n\t\t\t);\n\t}\n\telse\n\t{\n\t\treturn SHitInfo\n\t\t\t(\n\t\t\t\tdist,\n\t\t\t\tcircle.m_color * 0.25\n\t\t\t);\t\t\n\t}\n}\n\n//==============================================\nvoid CombineHitInfo (inout SHitInfo bestHit, in SHitInfo latestHit)\n{\n\tif (latestHit.m_distance < bestHit.m_distance)\n\t{\n\t\tbestHit = latestHit;\n\t}\n}\n\n//==============================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get our 2d coordinates where y is from 0 to 1, and x is from\n\t// whatever is needed to correct for aspect ration\n\tvec2 coord = fragCoord.xy / iResolution.xy;\n\tcoord.x *= (iResolution.x / iResolution.y);\n\t\n\t// init best hit distance to something large and the color to black\n\tSHitInfo bestHit =\n\t\tSHitInfo\n\t\t(\n\t\t\t100.0,\n\t\t\tvec3(0.0,0.0,0.0)\n\t\t);\n\t\n\t// test our shapes\n\t#define CIRCLE(x) CombineHitInfo(bestHit, TestCircle(coord, x));\n\t#define TRIANGLE(x) CombineHitInfo(bestHit, TestTriangle(coord, x));\n\t#define SQUARE(x) CombineHitInfo(bestHit, TestSquare(coord, x));\n\t#define PENTAGON(x) CombineHitInfo(bestHit, TestPentagon(coord, x));\n\tSHAPES\n\t#undef PENTAGON\n\t#undef SQUARE\n\t#undef TRIANGLE\n\t#undef CIRCLE\n\t\n\t// display our result\n\tfragColor = vec4(bestHit.m_color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sX3Ds","date":"1381382816","viewed":242,"name":"Point Poly Feature Proximity 2d","username":"demofox","description":"The color of each pixel represents which shape it's closest to.  The brighter color is where a line segment is the closest shape feature to the point.  The darker color is where a point is the closest shape feature to the point.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["visualization","experimental"],"hasliked":0,"parentid":"","parentname":""}}