{"ver":"0.1","info":{"id":"X3KXWw","date":"1720091824","viewed":134,"name":"my attempt at mountains","username":"Ronush","description":"My template","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"M3ySDm","parentname":"empty raymarch"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 450\n#define MAX_DIST 500.\n#define SURF_DIST .01\n\n//ty iq\n//https://www.youtube.com/watch?v=BFld4EBO2RE\n\n\n//global variables\nvec3 lightPos = vec3(10.5, 0.7, -3.5);\nvec2 t;\n\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.2330)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 10\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = 0.7;\n    float frequency=0.0;\n    float shift=.0;\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st = 2.*st*rot+shift;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\n//PLACE SHAPES HERE\nvec2 GetDist(vec3 p) {\n\n    //for every general point p, define h \n    vec2 h = vec2((p.y+fbm(p.xz)), 2.);\n    t=vec2(-p.y+6.5, 10.);\n    t.y+=smoothstep(0.45, 1., fbm(p.xz*.5+(iTime/10.)));\n    float u = 0.05;\n    vec2 m=floor(p.xz/u);\n    vec2 c=u*m+u/2.;\n    vec3 w = vec3(p.x-c.x, p.y+fbm(vec2(c.x, c.y)), p.z-c.y);\n    vec2 spheres = vec2(length(w)-0.00000001, 1.);\n    t = (t.x<h.x)?t:h; //merge\n    //t = (t.x<spheres.x)?t:spheres;\n    \n    t.x*=0.5; //clean\n    \n    return t;\n}\n\n\nvec2 map(vec3 p)\n{\n    p/=4.;\n    vec2 t = GetDist(p);\n    return t;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = map(p).x;\n        dO += dS;\n        if(dO>MAX_DIST || dS*dO<SURF_DIST) break;\n    }\n    if(dO>MAX_DIST) dO=0.;\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//DIFFUSE LIGHTING\nfloat GetLight(vec3 p) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(max(dot(n, l)+(1.+n.y)/30., 0.), 0.0, 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    d=0.000001/d;\n    if(d<length(lightPos-p)) dif *= 0.4; //shadow\n    dif = smoothstep(0.0, 1., dif); \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 backgroundColor=vec3(.1,.1,.1)-length(uv)*.1;\n    vec3 col = backgroundColor;\n    vec3 ro = vec3(-0.8, -1.9, -4.1); //camera pos\n    vec3 cw=normalize(vec3(7., -1.1, 7)-ro); // point towards\n\tvec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n\tvec3 cv = normalize(cross(cw, cu));\n\tvec3 rd = mat3(cu, cv, cw)*normalize(vec3(-uv, 0.5));\n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    vec3 n = GetNormal(p);\n    col = normalize(vec3(135, 206, 255))-0.4*uv.y;\n    if (d>0.){ //we inside broski\n        float id = map(p).y;\n        vec3 hue;\n\n        \n        //colour id's\n        if (id ==2.){\n        float s=smoothstep(0.6, 0.9 , n.y);\n        hue = normalize(vec3(180.,92.,62.))*(1.2-s)+s*normalize(vec3(124, 252, 84));\n        }\n        if (id >9.) hue = vec3(0.8, 0.8, 1.)*(id-9.);\n        col = hue;\n        col*=dif;\n        float fadeExp=1.;\n        float fadeCoef = -0.002;\n        float fadered = exp(fadeCoef*d);\n        float fadegreen = exp(fadeCoef*d*pow(2.,fadeExp));\n        float fadeblue = exp(fadeCoef*d*pow(4.,fadeExp));\n        \n        col.r = fadered*col.r + (1.-fadered);\n        col.g = fadegreen*col.g + (1.-fadegreen);\n        col.b = fadeblue*col.b + (1.-fadeblue);\n        col = smoothstep(0., 1., col);\n        \n       \n    }\n\n    fragColor = vec4(pow(col,vec3(.4545)),1);\n}","name":"Image","description":"","type":"image"}]}