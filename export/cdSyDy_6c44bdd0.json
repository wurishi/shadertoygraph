{"ver":"0.1","info":{"id":"cdSyDy","date":"1688089466","viewed":51,"name":"heat?","username":"boytoy","description":"trying to play with discretization of pde's. Not sure if this is the correct way... but let's find out!\n\nheat is unstable right now. it seems cfl condition is hard to apply here... maybe i will discretize the mesh via pixelation","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["simulation","experimentation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"laplacian = 0?\" by boytoy. https://shadertoy.com/view/csBcWy\n// 2023-06-30 01:40:09\n\nconst float DOSPI = 2.*3.141592;\n\n#define color1 vec3(0.075,1.000,1.000)\n#define color2 vec3(0.973,0.114,0.133)\n\nfloat t0 = 0.;\nfloat t1 = 1.;\n\n\nvec4 colorpalette(float t){\n    float lambda = (t-t0)/(t1-t0) + t0;\n    vec3 color = (1.-lambda)*color1 + lambda * color2;\n\n    return vec4(color,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvo = uv;\n    uv *= 2.;\n    uv -= 1.;\n    \n    float light = texture(iChannel0,uvo).r;\n\n    // Output to screen\n    fragColor = colorpalette(light);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.141592;\nconst float d = 0.01;\nconst float pixel_scale = 10.;\nconst vec2 pixels = pixel_scale * vec2(1./d,1./d);\n\nconst float time_step = 0.001; // should be small in order to satisfy CFL condition for heat equation.\n\n\nvec4 u(vec2 uv){return texture(iChannel0,uv);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord/iResolution.xy;\n    vec2 uvo = uv;\n    uv *= 2.;\n    uv -= 1.;\n    \n    // pixelation (meshing)\n    uv = (floor(uv*pixels) + 0.5)/pixels;\n    \n    // values calculation\n    vec4 last = u(uvo);\n   \n    vec2 dx = vec2(d,0.);\n    vec2 dy = vec2(0.,d);\n    vec4 laplacian =\n        (u(uvo + dx) - 2.*u(uvo) + u(uvo - dx)) +\n        u(uvo + dy) - 2.*u(uvo) + u(uvo - dy)   ;\n    laplacian /= d*d;\n    \n    // border conditions\n    if((max(abs(4.*uv.x),abs(uv.y*0.15)))<0.1){\n        fragColor = vec4(0.);\n    }else if((max(abs(uv.y),abs(uv.x*0.15)))<0.1) {\n        fragColor = vec4(0.25);\n    }else if((abs(uv.x-0.3)<0.1) && (abs(uv.y-0.3)<0.1) ){\n        fragColor = vec4(1.);\n    }else if((length(uv)>0.9) && length(uv)<0.95){\n        fragColor = vec4(1.);\n    }else if (iTime < 1.){\n        fragColor = vec4(0.5);\n    }else{\n        fragColor = last + iTimeDelta * laplacian * time_step; // finite difference scheme\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}