{"ver":"0.1","info":{"id":"fldyzs","date":"1660348334","viewed":122,"name":"Colorful 2D metaballs","username":"techroot","description":"Colorful model of electric balls' field potential.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","metaball","vectorfield","electricity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Circle {\n  vec2 o; // position of center\n  float q; // charge\n  float r; // radius\n  vec3 color;\n};\n\nconst float epsilon = 1.0/15.0;\n\nconst float velocity = 0.5;\n\nconst float netLineStep = 0.03;\nconst float netLineWidth = 0.005;\nconst float netLineMinFieldStrength = 0.0;\nconst float netLineMaxFieldStrength = 0.7;\nconst vec3 netLineColor = vec3(0.0, 1.0, 0.0);\n\n// distance with respect to wrap over screen borders\nfloat wrapDistance(vec2 a, vec2 b, vec2 screen) {\n  vec2 direct_d = abs(a - b);\n  vec2 wrapped_d = screen - direct_d;\n  vec2 d = min(direct_d, wrapped_d);\n  \n  return sqrt(dot(d, d));\n}\n\nfloat brightness(vec3 color) {\n  vec3 n = normalize(color);\n  // return sqrt(dot(n, n));\n  \n  return 0.299*color.r*color.r +\n   0.587*color.g*color.g +\n   0.114*color.b*color.b;\n}\n\n// \"playing with colors\"\nvoid lut(inout vec3 color) {\n  float brightness =\n    0.299*color.r*color.r +\n    0.587*color.g*color.g +\n    0.114*color.b*color.b;\n  color *= brightness;\n}\n\n// returns 0 if x > edge, otherwise 1\nfloat negStep(float edge, float x) {\n  return step(edge, -x + 2.0*edge);\n}\n\nvec2 translate_and_rotate(vec2 origin, float angle, vec2 p) {\n  mat2 t = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  return t * (p - origin);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.y;\n  vec2 screen = vec2(iResolution.x/iResolution.y, 1.0);\n\n  // sorted by radius\n  const int N = 3;\n  Circle circles[N] = Circle[N](\n    Circle(vec2(0.5*screen.x, 0.5), 2.0, 0.14, vec3(0.0, 0.0, 1.0)),\n    Circle(vec2(fract(0.40 + velocity*iTime)*screen.x, 0.5), 1.0, 0.06, vec3(1.0, 0.0, 0.0)),\n    Circle(vec2(0.3*cos(2.0*iTime) - 0.5*screen.x, 0.3*sin(2.0*iTime) - 0.5), 0.5, 0.03, vec3(0.0, 1.0, 0.0))\n  );\n\n  float strength = 0.0;\n  vec3 metaCircleColor = vec3(0.0, 0.0, 0.0);\n  \n  vec3 metaCircleColors[N];\n  float metaCircleDistances[N];\n  float metaCircleStrength[N];\n\n  for (int i = 0; i < circles.length(); i++) {\n    Circle circle = circles[i];\n    float d = wrapDistance(uv, circle.o, vec2(screen.x, 1.0));\n    metaCircleDistances[i] = d;\n    float d_strength = epsilon * circle.q / d;\n    metaCircleStrength[i] = d_strength;\n    strength += d_strength;\n    metaCircleColors[i] = circle.color * d_strength;\n    metaCircleColor += metaCircleColors[i];\n  };\n  \n  metaCircleColor = normalize(metaCircleColor);\n  \n  float metaCircleBrightness = clamp(smoothstep(0.3, 1.0, strength), 0.0, 0.9);\n  metaCircleColor = metaCircleBrightness * metaCircleColor;\n  \n  // 1 if should draw equipotential line, 0 otherwise\n  float drawNetLine =\n    step(netLineMinFieldStrength, strength) *\n    negStep(netLineMaxFieldStrength, strength);\n  \n  float netLineBrightness =\n    smoothstep(netLineWidth, 0.0, mod(strength, netLineStep));\n \n  //vec3 color = vec3(metaCircleBrightness);\n  //vec3 color = vec3(metaCircleBrightness) + drawNetLine * netLineColor;\n  //vec3 color = metaCircleColor + drawNetLine * netLineBrightness * netLineColor;\n  vec3 color = metaCircleColor + drawNetLine * netLineBrightness * metaCircleColor;\n  \n  for (int i = 0; i < circles.length(); i++) {\n    float r = step(0.5, metaCircleStrength[i] * brightness(metaCircleColors[i]));\n    color = mix(metaCircleColors[i], color, step(r, metaCircleDistances[i]));\n  };\n\n  // lut(color);\n  fragColor = vec4(color, 1.0);\n  //fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n  // draw color temperature instead?\n}","name":"Image","description":"","type":"image"}]}