{"ver":"0.1","info":{"id":"WdccRM","date":"1600595886","viewed":131,"name":"temple V2 ","username":"danhel95","description":"Adaptive antialiasing test ","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// temple with Fabs AA\n\n#define N 3      // pixel oversampling NxN ( only where necessary )\n#define eps .05  // similarity threshold, is case of continuous mask\n#define R  iResolution.xy\n#define ZERO min(iFrame,0)\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define T(U,l)          texelFetch(iChannel0, ivec2(U) >>l, l)\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    vec2 U = ( u - R/2. ) / R.y;\n\n    vec2 ms = iMouse.xy/R.xy ;\n    float n = float(N),\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n    \n\n    if ( u.x > s\n         && length( T(u,1)-T(u,0) ) > eps ) { \n        O -= O;\n        for (int k=0; k<N*N; k++) {    // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            ray r = raydir(U + 2.*D/R.y, ms , R, iTime, ZERO);\n            O.rgb += render( r );\n        }\n        O /= n*n;\n    }\n    else                               // LOD#0 is ok\n        O = T( u, 0 ),\n         keyToggle(32) \n            ? O.r += .3, O.b -= .3 : 0.;\n\n    \n    O = pow( O, vec4(1./2.2) );        // to sRGB\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define pi 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 80.\n#define SURF 1e-3\n#define FAR 100.\n#define REFSTEP 2.\n#define pow(a,b) pow(abs(a),(b))\n#define sqrt2 1.41421\n#define sqrt3 1.7320508\n\nint ZERO;\nvec2 R ;\nfloat time;\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\n\n\nstruct obj\n{\n\n    float d;\n    vec3 c;\n    vec3 material;\n    vec3 col; //final\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n    float id;\n\n};\n\nvec2 opRepLim(in vec2 p, in float s, in vec2 lima, in vec2 limb)\n{\n    return p - s*clamp(round(p / s), lima, limb);\n}\n\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b) {\n    vec3 d = abs(p-pos) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat plane(vec3 p, vec3 n, float h)\n{\n    return dot(p, n) + h;\n}\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    vec3 q = p-pos;\n    return length(q) - r  ;\n\n}\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\nfloat cyl(vec3 p, float r) {\n    vec3 q = p;\n\n    r -= 0.05 * q.y;\n    r -= 0.05 * pow((0.5 + 0.5 * sin(12.0 * atan(q.x, q.z))), 2.0);\n    r -= 0.1 * pow((0.5 + 0.5 * sin(2.5 * sin(3.5 * q.y))), 0.15) - 0.1;\n\n    float d = length(q.xz) - r ;\n    d = max(d, abs(q.y - .1) - 4. );\n    //d = max(d, -q.y );\n    d *= 0.7;\n    return d;\n\n}\n\n\n\nobj temple(vec3 p) {\n\n    vec3 q = p - vec3(-10.0, 1.0, -4.);\n    vec3 s = vec3(q);\n    q.xz = opRepLim(q.xz, 2.0, vec2(1.0, 1.0), vec2(8.0, 4.0));\n    vec3 qq = vec3(q.x, abs(q.y - 2.0) - 2.0, q.z);\n    float d = cyl(q, 0.4);\n    d = min(d, box(qq, vec3(0.6, 0.1, 0.6)));\n    d = max(d, - box(s - vec3(9.0, 0.0, 5.0), vec3(6.0, 4.0, 2.0)));\n\n    vec3 f = s - vec3(0.0, - 0.1, 0.0);\n    f.y = abs(f.y- 2.)-2.2;\n    vec3 sz = vec3(0.95, 0.01, 0.95);\n    f.xz = opRepLim(f.xz, 2., vec2(1.0, 1.0), vec2(8, 4.0));\n    d = min(d, box(f, sz - 0.1) - 0.2);\n\n    vec3 g = s - vec3(-3.0, - 0.6, - 3.0);\n    vec3 gsz = vec3(1.5, 0.2, 1.5);\n    g.xz = opRepLim(g.xz, 3.0, vec2(1.0, 1.0), vec2(7.0, 4.0));\n    d = min(d, box(g, gsz - 0.2) - 0.2);\n\n\n    obj templ = obj(d ,vec3(.0),vec3(.7,.7,.7),vec3(0.), 1., .5, 1.5, 150., 1., 2.);\n    return templ;\n\n}\n\n\nobj scene(vec3 p) {\n    float b = plane(p, vec3(0.0, 1.0, 0.0), 0.1);\n    obj flor = obj(b ,vec3(.0),vec3(.8,.8,.8),vec3(0.), .8, .7, 3., 100., 1., 1.);\n    obj tmpl = temple(p);\n\n    tmpl = uop(tmpl,flor);\n\n\n    return tmpl;\n\n\n}\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m, vec2 Res,float tme,int Z) {\n\n\tR = Res;\n    time = tme;\n    ZERO = Z ;\n    float roll = 0.;\n    ray r ;\n    r.zoom = 1.;\n    \n    float ang = sin(0.2 * time*PI + TWO_PI*m.x) * .5;\n    vec3 camR = vec3( sin(ang + m.x), 0. , cos(ang+ m.y));\n    r.o = vec3(.0, 2.0, 20.0) + camR;\n    //r.o = vec3(0., 5., -10.);\n    r.t = vec3(0.);\n\n    r.o.yz *= R2( - m.y * PI/4. );\n    r.o.xz *= R2( - m.x * TWO_PI + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\n\n\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<8; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        t += s.d;\n    }\n\n    s.d = t;\n    return s;\n}\n\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n\n    //ob.col = vec3(.0);\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.material * Kd * l.col* ob.diffuse;\n    vec3 spec = ob.material * Ks * l.col*  ob.specular;\n    vec3 ambi = ob.material *  ob.amb;\n\n    ob.col += dif + spec + ambi ;\n\n\n}\n\n\nvec3 draw_star(vec3 p, star s, vec3 rd, float d, float i)\n{\n    vec3 lp = s.pos - p;\n    float l = dot(lp,lp);\n    float a = max(abs(dot(normalize(lp), rd)), 0.1);\n    float foff = smoothstep(FAR/15. , .0, (l - s.rad) /d ) ;\n    float g = pow(a,5000.) * foff ;\n   return s.col * g * i;\n}\n\n\n\nvec3 render(ray r) {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 3.  ,theta= time*.5;\n    vec3 spos = vec3(2. + radius * cos(theta), 3.0 + sin(theta ), 2.+ radius * sin(theta));\n    star blue = star(spos, vec3(.9,.6,.1), 1. );\n\n    for(float i = 0.; i < 1.; i += 1./REFSTEP) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tvec3 normal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n        vec3 s = draw_star(p,blue,r.d,ob.d,10.);\n        resCol += s ;\n\n        ob.col *= pow(smoothstep(FAR, 10., 2.*ob.d), 2.);\n        resCol += ob.col * alpha  ;\n   \t\talpha *= 0.1;\n        r.d = reflect(r.d, normal);\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n    }\n\treturn resCol;\n\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define R  iResolution.xy\n#define ZERO min(iFrame,0)\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  U = ( u - .5*R ) / R.y;      // normalized centered coords\n    vec2 m = iMouse.xy/R.xy ;\n    ray r = raydir(U,m,R,iTime,ZERO);\n\tvec3 color = render(r);\n\n    O = vec4( color, 1. );\n}","name":"Buffer A","description":"","type":"buffer"}]}