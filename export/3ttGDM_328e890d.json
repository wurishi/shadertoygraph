{"ver":"0.1","info":{"id":"3ttGDM","date":"1576615546","viewed":512,"name":"Quantum Fluid 3D(FORK)","username":"Ecter","description":"Refactored so that code is no longer quite as obsfucated. \nold description:\nQuantized vortex filaments!\n\nPressure solving a schrodinger equation makes quantized fluid dynamics. (Making it make sense...)","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["3d","physics","landau","ginzburg","refactor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Quantum Fluid 3D\" by wyatt. https://shadertoy.com/view/wltGWN\n// 2019-12-16 21:53:48\n\n#define PREVIOUS_PHI_CHANNEL iChannel0\n\nconst int volumetric_iteration_count = 120;\nconst float max_cube_distance = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iResolution2D = iResolution.xy;\n    vec3 iVoxelResolution = getVoxelResolution(iResolution);\n    VoxelStorageDimensions storage_dim = getStorageDimensions(iResolution);\n    vec3 center_voxel_coord = iVoxelResolution/2.0;\n    vec3 view_position = vec3(0,0,-0.8*iVoxelResolution.x);\n    \n    vec3 view_direction = normalize(vec3((fragCoord-0.5*iResolution2D)/iResolution2D.y,1));\n    //if mouse clicked\n    if (iMouse.z>0.) {\n \t\tview_position.xz *= eulerRotation(6.2*iMouse.x/iResolution2D.x);\n\t\tview_direction.xz *= eulerRotation(6.2*iMouse.x/iResolution2D.x);\n        view_position.yz *= eulerRotation(6.2*iMouse.y/iResolution2D.y);\n\t\tview_direction.yz *= eulerRotation(6.2*iMouse.y/iResolution2D.y);\n    } else {\n\t\tview_position.xz *= eulerRotation(.2*iTime);\n\t\tview_direction.xz *= eulerRotation(.2*iTime);\n\t}\n    fragColor = vec4(0);\n    \n    //volumetric rendering via stepping through wave function\n    for (int i = 0; i < volumetric_iteration_count; i++) {\n        vec3 cube_length_difference = abs(view_position)-center_voxel_coord;\n        float cube_difference = length(max(cube_length_difference,0.));\n        if (cube_difference < max_cube_distance)\n        { \t\n            vec4 a = getVoxelLinear3DFilter(storage_dim, PREVIOUS_PHI_CHANNEL, view_position + center_voxel_coord, iResolution2D);\n            float aa = abs(length(a.xy)-1.);\n            //assume this is making the bright ring effects?\n            fragColor += .04*(1.-exp(-aa))*(0.5+0.5*abs(a.xwyw));\n            //don't move as far when we find something? \n            view_position += view_direction*exp(-3.*aa);\n        } else{\n            view_position += view_direction*max(cube_length_difference.x,max(cube_length_difference.y,cube_length_difference.z));\n        }\n        \n \t} \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//width which determines the width of a small screen, ie not fullscreen window\nconst float small_screen_width = 400.0;\n\nvec3 getVoxelResolution(vec3 iresolution){\n    float resolution_scale = iresolution.y > small_screen_width ? 10.0 : 8.0;\n\treturn vec3(iresolution.xy * (1.0/resolution_scale), resolution_scale*resolution_scale);      \n}\n\n\n//storing in texture is not easy, we cannot directly store all z dimensions,\n// each has to be split up independntly hence the z_frame_count, and z_block_count\nstruct VoxelStorageDimensions{\n\tfloat width;\n    float height;\n    float z_frame_count;\n    float z_block_count;\n};\n    \nvec2 frameSize(VoxelStorageDimensions storage_dim){\n    return vec2(storage_dim.width, storage_dim.height);\n}\n\nvec3 totalSize(VoxelStorageDimensions storage_dim){\n    return vec3(frameSize(storage_dim), storage_dim.z_frame_count * storage_dim.z_block_count);\n}\n   \n\nVoxelStorageDimensions getStorageDimensions(vec3 iresolution){\n    float resolution_scale = iresolution.y > small_screen_width ? 10.0 : 8.0;\n\tvec3 iVoxelResolution = vec3(iresolution.xy * (1.0/resolution_scale), resolution_scale*resolution_scale);\n    return VoxelStorageDimensions(iVoxelResolution.x, iVoxelResolution.y, resolution_scale, resolution_scale);\n}\n    \n//2d texture coordinates that coordespond to the given 3d coordinate for voxel. \nvec2 voxelStorageCoords(VoxelStorageDimensions storage_dim, vec3 voxel_coord){\n    //repeat coordinates\n\tvoxel_coord = mod(voxel_coord, totalSize(storage_dim));\n    //we can't deal with fractional z cordinates since we aren't using a true 3d texture\n    voxel_coord.z = floor(voxel_coord.z);\n    //z_frame count is essentially the \"x\" dimension of the z dimension for 2d texture 3d storage, so we mod to get 2d like coordinates\n    // similarly to get the \"y\" coordinate we divide voxel_coord.z by the frame count\n    vec2 voxel2d_z_offset = vec2(mod(voxel_coord.z, storage_dim.z_frame_count), \n                                 floor(voxel_coord.z/storage_dim.z_frame_count)) * frameSize(storage_dim);\n    return voxel_coord.xy + voxel2d_z_offset;\n}\n\nvec4 getVoxel(VoxelStorageDimensions storage_dim, sampler2D voxel_texture, vec3 voxel_coord){\n    vec2 texture_coords = voxelStorageCoords(storage_dim, voxel_coord);\n    return texelFetch(voxel_texture, ivec2(texture_coords), 0);\n}\n\nvec4 getVoxelLinear2Dfilter(VoxelStorageDimensions storage_dim, sampler2D voxel_texture, vec3 voxel_coord, vec2 iResolution2D){\n        vec2 texture_coords = voxelStorageCoords(storage_dim, voxel_coord);\n    return texture(voxel_texture, (texture_coords/iResolution2D));\n}\n\n//should approximate trilinear filtering, except at the edges of 2D image. \nvec4 getVoxelLinear3DFilter(VoxelStorageDimensions storage_dim, sampler2D voxel_texture, vec3 voxel_coord, vec2 iResolution2D){\n    return mix(getVoxelLinear2Dfilter(storage_dim, voxel_texture, vec3(voxel_coord.xy, floor(voxel_coord.z)),iResolution2D), \n               getVoxelLinear2Dfilter(storage_dim, voxel_texture, vec3(voxel_coord.xy, ceil(voxel_coord.z)), iResolution2D),         \n               fract(voxel_coord.z));\n}\n\n//looks like they meant to use divergence in code? \nvec4 adjacentVoxelAverage(VoxelStorageDimensions storage_dim, sampler2D voxel_texture, vec3 voxel_coord){\n    vec4 sum = (getVoxel(storage_dim, voxel_texture, voxel_coord+vec3(1,0,0))\n                + getVoxel(storage_dim, voxel_texture, voxel_coord + vec3(0,1,0))\n                + getVoxel(storage_dim, voxel_texture, voxel_coord + vec3(0,0,1))\n                + getVoxel(storage_dim, voxel_texture, voxel_coord - vec3(1,0,0))\n                + getVoxel(storage_dim, voxel_texture, voxel_coord - vec3(0,1,0))\n                + getVoxel(storage_dim, voxel_texture, voxel_coord - vec3(0,0,1)));\n\treturn sum / 6.0;\n}\n\nvec4 computeLaplacian(VoxelStorageDimensions storage_dim, sampler2D voxel_texture, vec3 voxel_coord, vec4 phi){\n    vec4 adjacent_average = adjacentVoxelAverage(storage_dim, voxel_texture, voxel_coord);\n    return adjacent_average - phi;\n}\n\n//apparently the source for the equation is Here, page 61 eq 2.54 https://www.mobt3ath.com/uplode/book/book-28656.pdf\n//but michael0884 recommends \"using .5*(L.xy-0.25*Q.xy*(dot(Q.xy,Q.xy)-1.)), makes the vortexes larger.\"\n//EDIT: michael0884 clarified it is taken directly from http://multires.caltech.edu/pubs/SchrodingersSmoke.pdf under section 1.1, \n// which makes far more sense. \nvec4 nonLinearShrodinger(VoxelStorageDimensions storage_dim, sampler2D voxel_texture, vec3 voxel_coord, vec4 phi){\n    vec4 laplacian = computeLaplacian(storage_dim, voxel_texture, voxel_coord, phi);\n    return (laplacian - 0.01*phi*(dot(phi.xy,phi.xy) - phi.z))/2.0;\n}\n\nvec4 nonLinearShrodinger(VoxelStorageDimensions storage_dim, sampler2D voxel_texture, vec3 voxel_coord, vec4 phi, vec4 laplacian){\n\treturn (laplacian - 0.01*phi*(dot(phi.xy,phi.xy) - phi.z))/2.0;\n}\n\nvec3 voxelCoordFromFragCoord(VoxelStorageDimensions storage_dim, vec2 fragCoord){\n    vec2 voxel2d_z_offset = floor(fragCoord/frameSize(storage_dim));\n    float z = voxel2d_z_offset.x+voxel2d_z_offset.y*storage_dim.z_frame_count;\n\treturn vec3(mod(fragCoord,frameSize(storage_dim)),z);\n}\n\n// counterclockwise rotation https://en.wikipedia.org/wiki/Rotation_matrix\nmat2 eulerRotation(float theta){\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    return mat2(cos_theta, -sin_theta,\n                sin_theta,  cos_theta);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PREVIOUS_PHI_CHANNEL iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iResolution2D = iResolution.xy;\n    vec3 iVoxelResolution = getVoxelResolution(iResolution);\n    VoxelStorageDimensions storage_dim = getStorageDimensions(iResolution);\n    vec3 voxel_coord = voxelCoordFromFragCoord(storage_dim, fragCoord);\n    vec4 phi = getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord);\n    vec4 adjacent_average = adjacentVoxelAverage(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord);\n    vec4 laplacian = adjacent_average - phi;\n    phi.x += nonLinearShrodinger(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord, phi, laplacian).y;\n    phi.xy = mix(phi.xy, normalize(adjacent_average.xy), 0.05);\n    // init\n    if (iFrame < 1){\n    \t//I think this is real, imag, real, imag? phi should be C^2, which is a pair of complex numbers\n        phi = vec4(0,1,0,0);\n    }\n\n    // boundary conditions\n    //center around (0,0,0) instead of (iVoxeResolution/2.0)\n    vec3 centered_voxel_coord = voxel_coord - iVoxelResolution/2.0;\n    //rotating coordinates so we see a rotated view of the scene?\n    centered_voxel_coord.xz *= eulerRotation(.1*iTime);\n    centered_voxel_coord.zy *= eulerRotation(.1*iTime);\n    //at the boundary?\n    if (length(centered_voxel_coord.xy)<8.0&&abs(centered_voxel_coord.z)<5.0&&iFrame%600 < 10){\n        //create pulse in center every so often\n        phi = vec4(0,1,0,0);\n        phi.xy *= eulerRotation(2.*iTime+centered_voxel_coord.z);\n    }\n    fragColor = phi;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PREVIOUS_PHI_CHANNEL iChannel0\n//gradient of the phase(complex angle)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iResolution2D = iResolution.xy;\n    vec3 iVoxelResolution = getVoxelResolution(iResolution);\n    VoxelStorageDimensions storage_dim = getStorageDimensions(iResolution);\n    vec3 voxel_coord = voxelCoordFromFragCoord(storage_dim, fragCoord);\n    vec4 phi = getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord);\n    vec4 adjacent_average = adjacentVoxelAverage(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord);\n    vec4 laplacian = adjacent_average - phi;\n    //actually computing gradient of phase, the imaginary part, y. \n    phi.y -= nonLinearShrodinger(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord, phi, laplacian).x;\n    fragColor = phi;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define PREVIOUS_PHI_CHANNEL iChannel0\n//calculating the velocity from the wave function\nfloat angle_between(vec2 a, vec2 b) {\n\treturn atan(a.x*b.y-a.y*b.x,dot(a.xy,b.xy));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iResolution2D = iResolution.xy;\n    vec3 iVoxelResolution = getVoxelResolution(iResolution);\n    VoxelStorageDimensions storage_dim = getStorageDimensions(iResolution);\n    vec3 voxel_coord = voxelCoordFromFragCoord(storage_dim, fragCoord);\n    vec4 velocity; //= getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord); not needed, velocity.w isn't used. \n    \n    velocity.x = angle_between(getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord+vec3(1,0,0)).xy,\n                          getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord-vec3(1,0,0)).xy);\n    velocity.y = angle_between(getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord+vec3(0,1,0)).xy,\n                          getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord-vec3(0,1,0)).xy);\n    velocity.z = angle_between(getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord+vec3(0,0,1)).xy,\n                          getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord-vec3(0,0,1)).xy);\n    \n   fragColor =  velocity;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define PREVIOUS_PHI_CHANNEL iChannel0\n#define VELOCITY_CHANNEL iChannel1\n//solving the poisson equation/pressure equation \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iResolution2D = iResolution.xy;\n    vec3 iVoxelResolution = getVoxelResolution(iResolution);\n    VoxelStorageDimensions storage_dim = getStorageDimensions(iResolution);\n    vec3 voxel_coord = voxelCoordFromFragCoord(storage_dim, fragCoord);\n    vec4 phi = getVoxel(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord);\n    vec4 adjacent_average = adjacentVoxelAverage(storage_dim, PREVIOUS_PHI_CHANNEL, voxel_coord);\n    //p = positive, n = negative, ie px, = positive x. \n    vec4\n        px = getVoxel(storage_dim, VELOCITY_CHANNEL, voxel_coord+vec3(1,0,0)),\n        nx = getVoxel(storage_dim, VELOCITY_CHANNEL, voxel_coord-vec3(1,0,0)),\n        py = getVoxel(storage_dim, VELOCITY_CHANNEL, voxel_coord+vec3(0,1,0)),\n        ny = getVoxel(storage_dim, VELOCITY_CHANNEL, voxel_coord-vec3(0,1,0)),\n        pz = getVoxel(storage_dim, VELOCITY_CHANNEL, voxel_coord+vec3(0,0,1)),\n        nz = getVoxel(storage_dim, VELOCITY_CHANNEL, voxel_coord-vec3(0,0,1));\n    \n    phi.z = mix(phi.z,adjacent_average.z,0.1) + ((px.x-nx.x+py.y-ny.y+pz.z-nz.z)/6.0);\n    fragColor = phi;\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}