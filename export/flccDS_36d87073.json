{"ver":"0.1","info":{"id":"flccDS","date":"1660409272","viewed":75,"name":"Gauss-Chebyshev Quadrature","username":"Envy24","description":"Green - f(x)\nBlue - exact definite integral of f(x)\nRed - numerical definite integral of f(x) calculated with Gauss-Chebyshev Quadrature.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["numerical","integral","gauss","integration","chebyshev","quadrature","definite"],"hasliked":0,"parentid":"st3yzs","parentname":"Gauss-Legendre Quadrature"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n// Redefine this macroses for your function.\n#define integ(x)         ( -cos(x) + 1. )  // analytic definite integral form a to b of func(x) (by default a = 0 = const).\n#define func(x)          ( sin(x) )\n#define deriv(x)         ( cos(x) )\n\n/*\n    Calculators for roots and weights:\n        https://keisan.casio.com/exec/system/1281438499\n        https://keisan.casio.com/exec/system/1504154178\n*/\n\nfloat GaussChebyshevQuadratureOrder2(float a, float b)\n{\n    const float xs[2] = float[2]( -0.5 * sqrt(2.), 0.5 * sqrt(2.) );\n    const float ws[2] = float[2](\n        (PI / 2.) * sqrt(1. - xs[0]*xs[0]),\n        (PI / 2.) * sqrt(1. - xs[1]*xs[1])\n    );  \n    \n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n          \n    float I = 0.;\n    for (int i = 0; i < 2; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += func(x)*ws[i];\n    }\n          \n    return I * mean;\n}\n\nfloat GaussChebyshevQuadratureOrder3(float a, float b)\n{\n    const float xs[3] = float[3]( -0.5 * sqrt(3.), 0.0, 0.5 * sqrt(3.) );\n    const float ws[3] = float[3](\n        (PI / 3.) * sqrt(1. - xs[0]*xs[0]),\n        (PI / 3.) * sqrt(1. - xs[1]*xs[1]),\n        (PI / 3.) * sqrt(1. - xs[2]*xs[2])\n    ); \n\n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n\n    float I = 0.;\n    for (int i = 0; i < 3; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += func(x)*ws[i];\n    }\n\n    return I * mean;\n}\n\nfloat normalization_weight(float x) { return 1. / sqrt(1. - x*x); }\n\nvoid calculateRootsAndWeightsForT(\n    inout float xs[16],\n    inout float ws[16],\n    in float order)\n{\n    order = clamp(order, 0., 15.);\n    float inv = PI / order;\n    \n    for (float i = 0.; i < order; i+= 1.)\n    {\n        xs[int(i)] = cos((i + 0.5) * inv);\n        \n        ws[int(i)] = inv * sqrt(1. - xs[int(i)]*xs[int(i)]);\n        //ws[int(i)] = inv / normalization_weight(xs[int(i)]);\n    }\n}\n\nvoid calculateRootsAndWeightsForU(\n    inout float xs[16],\n    inout float ws[16],\n    in float order)\n{\n    order = clamp(order, 0., 15.);\n    float inv = PI / (order + 1.);\n    \n    for (float i = 0.; i < order; i+= 1.)\n    {\n        xs[int(i)] = cos((i + 1.) * inv);\n        \n        ws[int(i)] = inv * sqrt(1. - xs[int(i)]*xs[int(i)]);\n        //ws[int(i)] = inv / normalization_weight(xs[int(i)]);\n    }\n}\n\nfloat GaussChebyshevQuadrature(\n    float xs[16],\n    float ws[16],\n    float a,\n    float b,\n    float order)\n{  \n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n          \n    float I = 0.;\n    for (int i = 0, e = int(order); i < e; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += func(x)*ws[i];\n    }\n\n    return I * mean;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 3.0\n#define YSCALE 1.0\n#define OFFSET vec2(1.5, 0.25)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n            \n         NDC.x *= 2.0;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*deriv(NDC.x));\n         color.rg -= draw_func(NDC, YSCALE*integ(NDC.x), YSCALE*func(NDC.x));\n         \n    float a = 0.,  b = NDC.x, y = 0., yn = 0., dx = 0.1;\n         \n    float xs[16];\n    float ws[16];\n    //                      current                 min and max orders.\n    float order = clamp(1. + floor(mod(iTime, 8.)), 1.,     15.);\n    \n    calculateRootsAndWeightsForT(xs, ws, order);\n    //calculateRootsAndWeightsForU(xs, ws, order);\n\n    y = GaussChebyshevQuadrature(xs, ws, a, b, order);\n    yn = GaussChebyshevQuadrature(xs, ws, a, b + dx, order);\n         \n    color.gb -= draw_func(NDC, YSCALE*y, YSCALE*(y-yn)/dx);\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}