{"ver":"0.1","info":{"id":"3tfSWs","date":"1566205772","viewed":530,"name":"volume_experiment","username":"skaplun","description":"Another example of volumetric rendering","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.\n#define MAX_DIST 20.\n#define EPSILON MIN_FLOAT\n#define MAX_MARCHING_STEPS 64\n\nfloat noiseInside(vec3 p){\n  if(layer() > 3){\n  \tp.xz *= 1. + pow(abs(p.y), .5) * .3;\n  \tfloat a = p.y * 2.;\n  \tp.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n  }\n  if(layer() > 4)\n  \tp = p * vec3(1., .5 + p.y * .1, 1.) - vec3(0., iTime * 1.25, 0.);\n  \n  return simplex3D(p);\n}\n\nfloat scene(vec3 p){\n    vec3 mp = p;\n    mp.y -= 1.62999;\n    if(layer() >= 2){\n        float yFactor = p.y;\n        float time = iTime * 2.;\n        mp.xz -= vec2(fbm1x(yFactor, time), fbm1x(yFactor + 78.233, time))\n               * smoothstep(0., 3., yFactor);\n        \n    }\n    if(layer() >= 1){\n        return smin1( sdCone(mp, 1.5, .8, .1 ),\n                      sdSphere(p, 1.), 1.);\n    }else{\n        return sdSphere(p, 1.);\n    }\n}\n\nfloat march(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(eye + depth * marchingDirection);\n        if (dist < MIN_FLOAT) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\nvec3 norm(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = (iResolution.x - iMouse.x) * .01;\n    vec3 origin = vec3(7. * sin(ang), 0., 7. * cos(ang));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0., 1., 0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray r = Ray(origin, dir);\n    \n    vec3 finalColor = vec3(0.);\n    float dist = march(r.origin, r.dir, MIN_DIST, MAX_DIST);\n    if (dist < MAX_DIST - MIN_FLOAT) {\n        if(layer() < 3){\n        \tvec3 p = (r.origin + dist * r.dir);\n        \tfinalColor = norm(p) * .5;\n        }else{\n        \tRay trRay = Ray(r.origin + dist * r.dir, r.dir);\n        \n            const float stepSize = .025;\n            float t = MIN_FLOAT * 20.;\n            for(float i=0.; i<300.; i++){\n                vec3 p = trRay.origin + trRay.dir * t;\n                float s = scene(p);\n                if(s > 0.)\n                    break;\n                float noiseVal = noiseInside(p);\n                float cutOffDist = .25 * smoothstep(-.3, -.15, s);\n                if(distance(noiseVal, cutOffDist) < stepSize + stepSize * 12. * cutOffDist){\n                    if(layer() <= 5){\n                \t\tfinalColor = vec3(pow(1. - i/300., 16.));\n                        break;\n                    }else if(layer() == 6){\n                        finalColor += (1. - i/300.) * .15;\n                    }else{\n\t\t\t\t\t\tfinalColor += abs(norm(p)) * (1. - i/300.) * .15;\n                    }\n                }\n                t += stepSize;\n            }\n        }\n    }\n    return finalColor;\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    uv = fragCoord/iResolution.xy;\n    time = iTime;\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n    if(layer() < 7)\n    \tfragColor.rgb = mix(vec3(1.), fragColor.rgb, stripe());\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Box{ vec3 origin; vec3 bounds;};\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{ float t[2]; vec3 p[2];};\n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\nfloat noise3D(vec3 p){\n    return fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p){\n    float f3 = 1.0/3.0;\n    float s = (p.x+p.y+p.z)*f3;\n    int i = int(floor(p.x+s));\n    int j = int(floor(p.y+s));\n    int k = int(floor(p.z+s));\n    \n    float g3 = 1.0/6.0;\n    float t = float((i+j+k))*g3;\n    float x0 = float(i)-t;\n    float y0 = float(j)-t;\n    float z0 = float(k)-t;\n    x0 = p.x-x0;\n    y0 = p.y-y0;\n    z0 = p.z-z0;\n    int i1,j1,k1;\n    int i2,j2,k2;\n    if(x0>=y0)\n    {\n        if      (y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n        else if (x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n        else            { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Z order\n    }\n    else \n    { \n        if      (y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n        else if (x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n        else            { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n    }\n    float x1 = x0 - float(i1) + g3; \n    float y1 = y0 - float(j1) + g3;\n    float z1 = z0 - float(k1) + g3;\n    float x2 = x0 - float(i2) + 2.0*g3; \n    float y2 = y0 - float(j2) + 2.0*g3;\n    float z2 = z0 - float(k2) + 2.0*g3;\n    float x3 = x0 - 1.0 + 3.0*g3; \n    float y3 = y0 - 1.0 + 3.0*g3;\n    float z3 = z0 - 1.0 + 3.0*g3;            \n    vec3 ijk0 = vec3(i,j,k);\n    vec3 ijk1 = vec3(i+i1,j+j1,k+k1);   \n    vec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n    vec3 ijk3 = vec3(i+1,j+1,k+1);       \n    vec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n    vec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n    vec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n    vec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n    float n0 = 0.0;\n    float n1 = 0.0;\n    float n2 = 0.0;\n    float n3 = 0.0;\n    float t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n    if(t0>=0.0)\n    {\n        t0*=t0;\n        n0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n    }\n    float t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n    if(t1>=0.0)\n    {\n        t1*=t1;\n        n1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n    }\n    float t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n    if(t2>=0.0)\n    {\n        t2 *= t2;\n        n2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n    }\n    float t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n    if(t3>=0.0)\n    {\n        t3 *= t3;\n        n3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n    }\n    return 96.0*(n0+n1+n2+n3);\n}\n\nfloat sdSphere( vec3 p, float s ){\n    return length(p)-s;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat smin1(float a, float b, float k){\n    float s = max((k-abs(a-b))*(.5/k),0.);\n    s*=s;\n    s*=s*(2.*k);\n    return min(a-s,b-s);\n}\n\nvec2 uv;\nfloat time;\n#define LAYERS_CNT 14.\nint layer(){\n    return int(floor(mod(abs(uv.x*.25 - time - uv.y*.5), LAYERS_CNT)));\n}\n\nfloat stripe(){\n    return smoothstep(.4975, .495, distance(fract(uv.x*.25 - time - uv.y*.5), .5));\n}","name":"Common","description":"","type":"common"}]}