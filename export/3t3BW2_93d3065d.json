{"ver":"0.1","info":{"id":"3t3BW2","date":"1613434934","viewed":129,"name":"Quadratic surface","username":"JeanArthurDeda","description":"Homage to quadratic surfaces rendering","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Quadratic surface:\n// - A surface that contains all the points p for which qsample(p, q)=0\n// - They have some beautiful props which allows for easy calculation of the projective\n// curve and even further the calculation of the hor&ver min&max making them a \n// great candidate for scanline rendering alongside polys.\n\n// They were used extensively by Jim Blinn in the Voyanger film for NASA ~'78:\n// https://www.youtube.com/watch?v=SQk7AFe13CY\n// and in the movie \"The works\" by New York Institute of Technology ~'79\n// https://www.youtube.com/watch?v=g_q38qWv1fo\n// https://www.worthpoint.com/worthopedia/byte-magazine-nov-1980-volume-number-1856336512\n\n// As the CG world moved towards triangles, quads and splines the quadratic surfaces \n// become just a mathematical curiosity lost in hystory.\n// Here I'm doing just a ray trace over 1 quadratic surface as an homage to the pioneers\n// who used them a long time ago.\n\n#define PI 3.141592653589793238f\n\n// Quadratic surface helpers.All done with respect to homogenous coordonates.Old school.\nfloat qsample(vec4 a,mat4 q,vec4 b){return dot(a,q*b);}\nfloat qsample(vec4 p,mat4 q){return qsample(p,q,p);}\nfloat qray(vec4 p,vec4 d,mat4 q)\n{\n    float dqp=qsample(d,q,p);\n    float dqd=qsample(d,q,d);\n    float pqp=qsample(p,q,p);\n    float delta = dqp*dqp-dqd*pqp;\n    if (delta < .0) return -1.;\n    float oo_dqd = 1.0/dqd;\n    float sq_delta = sqrt (delta);\n    float t1 = (-dqp - sq_delta) * oo_dqd;\n    float t2 = (-dqp + sq_delta) * oo_dqd;\n    return min(t1, t2);\n}\nvec4 qplane(vec4 p, mat4 q) {return p*q;}\nvec3 qnor(vec4 p, mat4 q) {return normalize (qplane(p,q).xyz);}\nmat4 qtransf(mat4 i,mat4 it, mat4 q){return i*q*it;}\n\nvec2 map(vec3 n, vec3 p)\n{\n    float v[3] = float[3](n.x,n.y,n.z);\n    int m = 0;\n    for (int i = 1; i < 3;i++)\n        if (abs(v[i])>abs(v[m]))\n            m = i;\n    v = float[3](p.x,p.y,p.z);\n    return vec2 (v[(m+1)%3],v[(m+2)%3]);\n}\n\nfloat saw(float v){return 1.-abs(1.-fract(v)*2.);}\n\nfloat s(float t, float p, float r)\n{\n    float v = fract(t/p)/r;\n    return floor(v) < 1.f?clamp(saw(v)*3.,.0,1.):0.;\n}\n\n//-------------------------Noise--------------------------\n// IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0-2.0*p);\n    vec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + p.xy;\n    uv = texture( iChannel1, (uv+ 0.5)/256.0, -100.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement (from IQ)\n\tfloat an = 0.2*iTime;\n\tvec3 ro = vec3( 3.2*cos(an), 2.5, 3.2*sin(an) );\n    vec3 ta = vec3( 0.0, -0.05, 0.0 );\n    // camera matrix (from IQ)\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray (from IQ)\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww);\n    \n    \n    float time=iTime+111.;\n    // primitive\n    mat4 q = mat4 \n    (\n        1.0-s(time+0.,12.0,.5), -s(time*.2,5.,.5)*.1,0.0, 0.0,\n        -s(time*.2,5.,.5)*.1, 1.0-s(time+4.,10.0,.3), 0.0, 0.0,\n        0.0, 0.0, 1.0-s(time+8.,10.0,.4), 0.0,\n        0.0, 0.0, 0.0, -.25\n    );\n    // a primitive from the future\n    time+=.25;\n    mat4 q2 = mat4 \n    (\n        1.0-s(time+0.,12.0,.5), -s(time*.2,5.,.5)*.1,0.0, 0.0,\n        -s(time*.2,5.,.5)*.1, 1.0-s(time+4.,10.0,.3), 0.0, 0.0,\n        0.0, 0.0, 1.0-s(time+8.,10.0,.4), 0.0,\n        0.0, 0.0, 0.0, -.25\n    );\n    fragColor = vec4(0);\n\n    // raytrace\n    float t = qray(vec4(ro,1),vec4(rd,0),q);\n    if (t >= 0.0)\n    {\n        vec3 hit = ro+t*rd;\n        vec3 n = qnor(vec4(hit,1),q);\n        float d = clamp(dot(n,normalize(vec3(0.7,0.6,0.3))), 0.0, 1.0 );        \n        fragColor = (d+.2)*texture (iChannel0, map(n,hit));\n        vec3 l = smoothstep(vec3(0.01),vec3(0),abs(fract (hit-vec3(.3,.6,.3))-vec3(.5)));\n        fragColor += vec4(max(l.y,max(l.x,l.z)))*vec4(.2,0.4,.4,.0);\n    }\n    else\n    {\n        // background stars based on https://www.shadertoy.com/view/ltjSWV\n        fragColor += vec4(smoothstep(0.95, 1.0, pn(rd*30.0)*.5+.5));\n    }\n    \n    // Render some '80s CGI tech info\n    float ar = iResolution.x / iResolution.y;\n    vec2 m = fragCoord/iResolution.xy * vec2 (ar, 1.0) * 2.0 - vec2 (ar, 1.0);\n    for (int i = 0; i < 10; ++i)\n    {\n        vec3 p = vec3 (m, cos(float(i)/5.));\n        m*=1.05;\n        // render q slice\n        float v = abs(qsample(vec4(p, 1), q2)) / 0.02;\n        fragColor += vec4(clamp(0.5-v,.0,1.),0,0,1);\n    }\n}","name":"Image","description":"","type":"image"}]}