{"ver":"0.1","info":{"id":"XsdSDH","date":"1459112146","viewed":176,"name":"Easter Eggs on Parade","username":"hubbe","description":"Happy Easter","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["eggs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ball radius\n#define R 0.07\n\nfloat map(vec3 p, bool tangent_distance) {\n    // This makes everything below repeat infinitely.\n    p = mod(p, 0.2) - vec3(0.1);\n\n    // Distance to center of ball, squared.\n    float l2 = dot(p, p);\n            \n    // Fall back on a regular distance map.\n    return (length(p)*3.0  - R + length(p + vec3(0, -0.04,0)) - R) /4.0;\n}\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    float last_travel_distance = 0.0;\n    bool hit = false;\n    for (int i = 0; i < 80; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n\t    float distance_to_closest_object = map(position, !hit);\n\n        if (distance_to_closest_object < 0.0001) {\n        \tif (distance_to_closest_object < 0.0) {\n                // We are inside of an object. Go back to the\n                // previous position and stop using tangent distances\n                // so that we can find the surface.\n            \thit = true;\n          \t    travel_distance = last_travel_distance;\n           \t    continue;\n            }\n            return travel_distance;\n        }\n        last_travel_distance = travel_distance;\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += distance_to_closest_object;\n    }\n    // We hit something, but then we ran out of iterations while\n    // finding the surface.\n    if (hit) return travel_distance;\n    // We walked 50 steps without hitting anything.\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -1);\n\n    // Animate\n    camera_position.z += iTime/2.0;\n    camera_position.x += iTime/7.0;\n    \n    // Note that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    float zoom = 1.0;\n    \n    // Uncomment this for a very funky zoom effect.\n    // float zoom = sin(iTime / 5.0) + 0.4;\n    vec3 ray_direction = normalize(vec3(uv, zoom));\n\n\t// Direction of the sun.\n    vec3 sun_direction = normalize(vec3(0.2, 1, -1));\n        \n    // Cast a ray, see if we hit anything.\n    float travel_distance = ray(camera_position, ray_direction);\n    \n    // If we didn't hit anything, go with black.\n    if (travel_distance == 0.0) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    // Point in space where our ray intersects something.\n    vec3 hit_position = camera_position + ray_direction * travel_distance;\n\n    // Distance from surface.\n    float surface_dist = map(hit_position, false);\n    \n    // How far we step towards the sun.\n    float sun_ray_step_length = 0.005;\n    \n    // Take a small step in the direction of the light source and measure how\n    // far we are from the surface. The further away we got, the brighter this\n    // spot should be.\n    float surface_dist_nearer_sun = map(hit_position + sun_direction * sun_ray_step_length, false);\n    \n    // Calculate how much sunlight is falling on this spot (hit_position).\n    float sunlight = max(0.0, (surface_dist_nearer_sun - surface_dist) / sun_ray_step_length);\n\n    // Reduce the sunlight with distance to make it fade out far away.\n    sunlight /= (1.0 + travel_distance * travel_distance * 0.2);\n    \n    // Alternate blue and orange balls using magic.\n    float n = dot(vec3(1.0), floor(hit_position * 5.0));\n    if (mod(n, 2.0) == 0.0) {    \n    \t// Blue palette.\n    \tfragColor = vec4(sunlight * 1.5, sunlight * 1.5, sunlight * 1.5, 1.0);\n    } else {\n        // Fire palette.\n    \tfragColor = vec4(sunlight * 1.5, pow(sunlight, 2.5), pow(sunlight, 12.), 1.0);\n    }\t\n}\n\n","name":"Image","description":"","type":"image"}]}