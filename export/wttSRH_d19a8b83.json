{"ver":"0.1","info":{"id":"wttSRH","date":"1580419214","viewed":173,"name":"realistic double slit","username":"stuxxnet42","description":"(semi-)realistic simulation of light going through a double slit.\nmove mouse and hold left button to change display position\n(the function plotting on the right could use some work....)","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["light","physics","photon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    if(uv.x > 0.5f){\n        float x_norm = (uv.x - 0.5f)*4.0f;\n        vec2 uv_bar = vec2(uv.x, uv.y);\n        //vec2 uv_bar = uv;\n    \tvec3 val = texture(iChannel0, uv_bar).xyz;\n        //val = clamp(val, 0.0f, 1.0f);\n        if(abs(x_norm-val.x*2.0f) < 0.01f){\n            vec3 col_add = vec3(1.0f, 0.0f, 0.0f);\n            col = clamp(col_add + col*0.5f, 0.0f, 1.0f);\n        }\n    }\n    fragColor = vec4(col, 1.0f);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float scaling_factor = 125653.5f;\nconst float x0_start = -0.01f; //starting position of the detector\nconst float pi = 3.141592;\n\nconst int N = 101;\nconst float N_f = 101.0f;\nconst float deltax0 = (-2.0f * x0_start);\n\nconst float a = 1.0f; //distance source->slit\nconst float D = 1.0e-3; //slit width\nconst float slit_dist = 1.0e-2; //distance of the two slits\n\n\nvec2 split(float a){\n    float c = 4097.0f * a;\n    float a_big = c - a;\n    float a_hi = c - a_big;\n    float a_lo = a - a_hi;\n    return vec2(a_hi, a_lo);\n}\n\nvec2 mul_vec2(float a, float b){\n    float x = a*b;\n    vec2 a_split = split(a);\n    vec2 b_split = split(b);\n    float err1 = x - (a_split.x * b_split.x);\n    float err2 = err1 - (a_split.y * b_split.x);\n    float err3 = err2 - (a_split.x * b_split.y);\n    float y = (a_split.y * b_split.y) - err3;\n    return vec2(x,y);\n}\n\nvec2 div_flt(float a, float b){\n    float q = a/b;\n    float r = a - q*b;\n    float q2 = r / b;\n    return vec2(q, q2);\n}\n\nvec2 div_vec2(vec2 a, float b){\n    vec2 q0 = div_flt(a.x, b);\n    vec2 q1 = div_flt(a.y, b);\n    return vec2(q0.x, q0.y + q1.x);\n}\n\nfloat sexy_scaled_fmod(float x, float y, float z){\n    vec2 xy = mul_vec2(x,y);\n    vec2 d = div_vec2(xy, z);\n    float frac_part = fract(d.x) + fract(d.y);\n    return frac_part * z;\n}\n\n\nvec2 calc_amp(float p, float b, float x0){\n    float distance = sqrt( p*p + a*a ) + sqrt( (x0+p)*(x0+p) + b*b);\n    float t = sexy_scaled_fmod(distance, scaling_factor, 2.0f * pi);\n    vec2 result = vec2(cos(-t), sin(-t));\n    return result;\n}\n\nvec2 calc_brightness_slit(float pos, float b, float offset){\n    float p = -D / 2.0f; //we start at the lower end of the slit\n    p+=offset;\n    float x0 = x0_start + pos * deltax0;\n    vec2 sum = vec2(0.0f, 0.0f);\n    for(int i=0; i<=N; i++){\n        vec2 tmp = calc_amp(p,b,x0); //get the amplitude for one ray\n        sum += tmp;\n        p += D/N_f; //move the position in the slit for the next ray\n    }\n    return sum;\n}\n\nfloat calc_brightness(float pos, float b){\n    vec2 sum1 = calc_brightness_slit(pos, b, -slit_dist/2.0f);\n    vec2 sum2 = calc_brightness_slit(pos, b, +slit_dist/2.0f);\n    vec2 sum = sum1+sum2;\n    sum /= (N_f*2.0f); //normalize the sum\n    float normsum = sum.x * sum.x + sum.y * sum.y; //calculate the abs-square of the normalized sum\n    return normsum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float mx = iMouse.x/iResolution.x;\n    vec3 col;\n    \n    if(uv.x > 0.5f){\n        float arg_dist = (mx-0.3f)*10.0f;\n        float detec_dist = exp(arg_dist)*0.1;\n        float brightness = calc_brightness(uv.y, detec_dist);\n        col = vec3(brightness);\n    }\n    else{\n        if(abs(mx - uv.x)<0.01){\n            col = vec3(1.0f);\n        }\n        else{\n            col = vec3(0.0f);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Buf A","description":"","type":"buffer"}]}