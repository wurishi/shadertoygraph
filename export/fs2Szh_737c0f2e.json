{"ver":"0.1","info":{"id":"fs2Szh","date":"1619644471","viewed":84,"name":"December Overkill 2020 MS","username":"MonsieurSoleil","description":"Coding style test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    So,\n    This shader is important, because it's the first attemp i made to create my own \n    Code structure.\n\n    The basic idea is to code a certain way it's easy for me to \n    learn/add/remove/integrate new codes from \n    personnal work, research, art residencies, livecoding.\n    \n    The main goal that motivates it, is to be able to VJ with raymarching/bonzomatic only\n    and so to use always the same tools.\n\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\n#define time iTime\n#define mod01 floor(mod(time * 1.0, 4.0))\n#define mod02 floor(mod(time * 2.0, 4.0))\n#define mod03 floor(mod(time * 2.0, 8.0))\n#define mod04 floor(mod(time * 4.0, 8.0))\n\nstruct matter\n{\n  float m;\n  int type;\n  bool reflected;\n  vec3 p;\n  vec3 dir;\n  float dist;\n  float glow;\n  vec3 col;\n  bool doBreak;\n};\n\nmat2 rot(float a)\n{\n    float ca=cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat sphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  \n  return max(p.x, max(p.y, p.z));\n}\n\nvec3 random3f(vec3 p)\n{\n    return texture(iChannel0, (p.xy + vec2(2.0, 1.0) * p.z * 0.5) / 256.0, 0.0).xyz;\n}\n\nfloat rnd(vec2 x)\n{\n    return fract(dot(sin(x * 1235.236 + x.yx * 521.326), vec2(451.2365)));\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tv += a * random3f(x).x;\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec3 voronoi(in vec3 x)\n{\n   vec3 p = floor( x );\n  vec3 f = fract( x );\n  \n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for(int k = -1; k < 1; ++k)\n  for(int j = -1; j < 1; ++j)\n  for(int i = -1; i < 1; ++i)\n  {\n    vec3 b = vec3(float(i),float(j),float(k));\n    vec3 r = vec3(b) - f + random3f( p + b);\n    float d = dot(r,r);\n    \n    if(d < res.x)\n    {\n        id = dot(p+b, vec3(1.0, 57.0, 113.0));\n      res = vec2(d, res.x);\n    } else if (d < res.y)\n    {\n      res.y = d;\n    }\n    \n  }\n  \n  return vec3(sqrt(res), abs(id)) ;\n}\n\nfloat Circleline(vec3 p, float s)\n{\n    float mat01;\n\n    mat01 = sphere(p, s);\n\n    mat01 = max(mat01, -box(p + vec3(0.0, 0.0, 0.525*s), vec3(s*2.0,s*2.0, 0.5250255*s)));\n    mat01 = max(mat01, -box(p - vec3(0.0, 0.0, 0.525*s), vec3(s*2.0,s*2.0, 0.5250255*s)));\n\n    mat01 = max(mat01, -sphere(p, s*0.996));\n    \n    return mat01;\n}\n\nvec2 repeat(vec2 p, float rep)\n{\n    return (fract(p/rep - 0.5) - 0.5) * rep;\n}\n\nfloat repeat(float p, float rep)\n{\n    return (fract(p/rep - 0.5) - 0.5) * rep;\n}\n\nvec2 id(vec2 p, float rep)\n{\n    return (floor(p/rep - 0.5) - 0.5) * rep;\n}\n\nvec2 repLim(vec2 p, vec2 c, float l)\n{\n  vec2 q = p-c*clamp(round(p/c), -l, l);\n  return q;\n}\n\nvoid map01(inout matter mat, vec3 p)\n{\n  \n  \n  \n  vec3 p01 = p, p02 = p, p03 = p;\n  \n  p.xz *= rot(sin(time * 0.0002) * 2.0  * mod03) ;\n  p.yz *= rot(sin(time * 0.0002) * 1.0  * mod03) ;\n  \n  p01.z = repeat(p.z, 0.95);\n  p02.z = repeat(p.z, 0.45);\n  p03.z = repeat(p.z, 0.25);\n  \n  \n  float mat01 = Circleline(p01 + vec3(0.10 * cos(time * 0.75), 0.0, 0.15 * sin(time * 0.75)), 0.2 * mod04 + 0.1);\n  float mat02 = Circleline(p02 + vec3(0.10 * sin(time * 0.15), 0.0, 0.10 * sin(time * 0.15)), 0.2 * mod03 + 0.5);\n  float mat03 = Circleline(p02 + vec3(0.15 * sin(time * 0.05), 0.0, 0.15 * sin(time * 0.01)), 0.25 * mod02 + 0.3);\n  \n  float mat04 = -box(p, vec3(7.5));\n  \n  if(mat04 < 0.01)\n  {\n      mat.type = 1;\n    \n  }\n  \n     \n  mat.m = min(mat01, mat02);\n   mat.m = min(mat.m, mat03);\n    mat.glow += 0.15/(0.05+abs(mat.m));\n  \n  //mat.m = matFinal;\n}\n\nvoid map02(inout matter mat, vec3 p)\n{\n  p.xz *= rot(time * 0.5);\n  p.yz *= rot(time * 0.5);\n  \n  vec3 p01 = p, p02 = p;\n  \n  \n  \n  vec2 id01 = id(p.xz,  0.5 * mod02 + 2.5);\n  vec2 id02 = id(p.xy,  0.5 * mod02 + 2.5);\n  p01.xz = repLim(p.xz, vec2(0.1 + mod03 * 0.025), 0.5 * mod02 + 2.5);\n  p02.xy = repLim(p.xy, vec2(0.1 + mod03 * 0.025), 0.5 * mod02 + 2.5);\n  \n  float rnd01 = rnd(id01 * 32.0);\nfloat rnd02 = rnd(id02 * 32.0);\n  \n  float mat01 = box(p01, vec3(0.01,(0.1 * mod01 + 0.5 + fract(time * 1.25) * rnd01 * 0.2) , 0.01));\n  \nfloat mat02 = box(p02, vec3(0.01,0.01, (0.1 * mod01 + 0.1 + ((fract(time * 0.25) * rnd02 * mod03 * 0.5))) ));\n  \n     \n  \n  mat.m = min(mat01, mat02);\n    mat.glow += 0.15/(0.05+abs(mat.m));\n  //mat.m = matFinal;\n}\n\nvoid map03(inout matter mat, vec3 p)\n{\n // p.xy *= rot(0.01 * mod03);\n  //p.yz *= rot(0.01 * mod03);\n  //p.yz *= rot(0.2 * mod03);\n  \n  vec3 p01 = p;\n  \n  float mat04 = -box(p - vec3(0.0, 1.5, 2.0 * time), vec3(4.5));\n  \n  if(mat04 < 0.01)\n  {\n      mat.type = 1;\n  }\n  \n  //float mat01 = box(p, vec3(0.05, 0.05, 0.05));\n  vec2 id01 = id(p.xz, 1.2);\n  p01.xz = repeat(p.xz, 1.2);\n  float rnd01 = rnd(id01 * 8.0);\n  \n  float mat01 = box(p01 + vec3(0.0, 0.25 * sin(p.z * 0.4 + time * 4.0) + 1.5, 0.0), vec3(0.5,0.02 * mod03 + 0.2 + rnd01 * 1.5, 0.5));\n  float mat02 = box(p01 + vec3(0.0, 1.25 * sin(p.z * 0.15 + time * 2.0) - 5.5, 0.0), vec3(0.5,0.02 * mod03 + 0.2 + rnd01 * 1.5, 0.5));\n  \n  mat.m = min(mat01, mat02);\n  \n  mat.glow += 0.15/(0.05+abs(mat.m));\n}\n\nvec3 normals01(vec3 p)\n{\n    vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map01(m01, p);\n  map01(m02, p - uv.xyy);\n  map01(m03, p - uv.yxy);\n  map01(m04, p - uv.yyx);\n  \n  return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n  \n}\n\nvec3 normals03(vec3 p)\n{\n    vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map03(m01, p);\n  map03(m02, p - uv.xyy);\n  map03(m03, p - uv.yxy);\n  map03(m04, p - uv.yyx);\n  \n  return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n  \n}\n\nvoid Glow01(inout matter mat)\n{\n  mat.col += pow(mat.glow * 0.0085 * abs(sin(mat.p.z * 0.05 * ((mod03)/ 4.0) + time * 2.0)), 8.5) * vec3(1.0, 1.0, 1.0);\n}\n\nvoid Glow02(inout matter mat)\n{\n  mat.col -= pow(mat.glow * 0.02 * abs(sin(mat.p.z * 1.55 + time * 12.0))  + 0.005 * mod03 , 6.0) * vec3(1.0, 1.0, 1.0);\n}\n\nvoid Glow03(inout matter mat)\n{\n  mat.col += pow(mat.glow * 0.006 * abs(sin(mat.p.z * 0.55 + time * 4.0))  + 0.0025 * mod04, 12.0) * vec3(1.0, 1.0, 1.0);\n}\n\nvoid chooseMap(inout matter mat)\n{\n    if(mod01 == 0.0f)\n    {\n      map01(mat, mat.p);\n    }\n    if(mod01 > 0.0 && !(mod01 > 1.0))\n    {\n      map01(mat, mat.p);\n    }\n    if(mod01 > 1.0 && !(mod01 > 2.0))\n    {\n      map03(mat, mat.p);\n    }\n    if(mod01 > 2.0)\n    {\n      map02(mat, mat.p);\n    }\n}\n\nvoid ChooseGlow(inout matter mat)\n{\n    if(mod01 == 0.0f)\n    {\n      Glow01(mat);\n    }\n    else if(mod01 > 0.0 && !(mod01 > 1.0))\n    {\n      Glow01(mat);\n    }\n    else if(mod01 > 1.0 && !(mod01 > 2.0))\n    {\n      Glow03(mat);\n    }\n    else if(mod01 > 2.0)\n    {\n      Glow02(mat);\n    }\n}\n\nvoid Process01(inout matter mat)\n{\n  if(mat.m < 0.01)\n  {\n    mat.m = 0.05;\n    \n    if(mat.type == 1 && mat.reflected == false)\n    {\n      vec3 n = normals01(mat.p);\n      mat.dir = reflect(-n, mat.dir);\n      mat.type = 0;\n       mat.reflected = true;\n     // mat.col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  }\n  \n  if(mat.m < 0.0002)\n  {\n    mat.m = 1.5;\n    \n    \n    \n  }\n}\n\nvoid Process02(inout matter mat)\n{\n  if(mat.m < 0.02)\n  {\n    mat.m = 0.7;\n    \n    if(mat.type == 1 && mat.reflected == false)\n    {\n      vec3 n = normals01(mat.p);\n      mat.dir = reflect(-n, mat.dir);\n      mat.type = 0;\n       mat.reflected = true;\n     // mat.col = vec3(1.0, 0.0, 0.0);\n    }\n  }\n}\n\nvoid Process03(inout matter mat)\n{\n  if(mat.m < 0.01)\n  {\n    mat.m = 1.5;\n    \n    if(mat.type == 1)\n    {\n      vec3 n = normals03(mat.p);\n      mat.dir = reflect(-n, mat.dir);\n      mat.type = 1;\n       mat.reflected = true;\n      //mat.col = vec3(1.0, 0.0, 0.0);\n    }\n  }\n}\n\nvoid ChooseProcess(inout matter mat)\n{\n    if(mod01 == 0.0f)\n    {\n      Process01(mat);\n    }\n    else if(mod01 > 0.0 && !(mod01 > 1.0))\n    {\n      Process01(mat);\n    }\n    else if(mod01 > 1.0 && !(mod01 > 2.0))\n    {\n      Process02(mat);\n    }\n    else if(mod01 > 2.0)\n    {\n      Process02(mat);\n    }\n}\n\nvec3 ChooseOrigin()\n{\n  if(mod01 == 0.0f)\n    {\n      return vec3(0.0, 0.0, 2.0 * time + mod02 * 0.5);\n    }\n    if(mod01 > 0.0 && !(mod01 > 1.0))\n    {\n       return vec3(0.0, 0.0, 2.0 * time + mod03 * 0.2);\n    }\n    if(mod01 > 1.0 && !(mod01 > 2.0))\n    {\n       return vec3(0.0, 1.5, 2.0 * time + mod04 * 2.0);\n    }\n    if(mod01 > 2.0)\n    {\n        return vec3(10.0 * cos(time * 1.0), 0.5, 0.5 * sin(time * 0.5));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord/iResolution.xy);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);matter mat;\n  \n  if(mod01 > 2.0)\n  {\n     mat.col = vec3(1.0);\n  }\n  \n  vec3 o = ChooseOrigin(), t = vec3(0.0);\n  vec3 fr = normalize(t - o);\n  vec3 ri = normalize(cross(vec3(0., 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  \n  mat.dir = normalize(fr + uv.x * ri + uv.y *up);\n  mat.p = mat.dir * 0.25 + o;\n  \n  for(int i = 0; i < 100; ++i)\n  {\n    chooseMap(mat);\n\n    ChooseProcess(mat);\n\n    ChooseGlow(mat);\n\n    mat.p += mat.m * mat.dir;\n    mat.dist += mat.m;\n  }\n  \n  if(mod01 > 1.0 && mod01 <= 2.0)\n  {\n    //mat.col = clamp((mat.dist/100.0), 0.0, 1.0) * vec3(1.5);\n     //mat.col += pow(clamp((mat.dist/100.0), 0.0, 1.0) * vec3(0.0, 0.5, 1.0) * 0.15, vec3(2.0));\n  }\n  \n  mat.col = pow(mat.col, vec3(1.0/2.2)) * 0.75;\n  \n  fragColor = vec4(mat.col,1.0);\n}","name":"Image","description":"","type":"image"}]}