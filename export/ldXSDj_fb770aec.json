{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n    \nstruct Material{\n\tfloat specular;\n\tfloat diffuse;\n\tfloat ambient;\n\tfloat shininess;\n    float reflectivity;\n    float transparency;\n};\n    \nstruct Sphere{\n\tvec3 position;\n\tvec3 colour;\n\tfloat radius;\n    Material mat;\n};\n   \nstruct Plane{\n\tvec3 position;\n    vec3 colour;\n    vec3 normal;\n    Material mat;\n};\n\t\nstruct PointLight{\n\tvec3 position;\n\tvec3 colour;\n};\n\n\nstruct Output{\n\tvec3 origin;\n\tvec3 normal;\n\tfloat dis;\n\tMaterial material;\n    vec3 colour;\n};\n    \n#define numSphere 6\nSphere sphere[numSphere];\n\n#define numPlane 3\nPlane plane[numPlane];\n\n#define numLight 6\nPointLight pointlight[numLight];\n\n#define numMaterial 8\nMaterial material[numMaterial];\n\n#define PI 3.14159\nvec3 backgroundColour = vec3(0.0, 0.0, 0.7);\nvec3 eye;\n\nRay castRay(vec3 lookat){\n\tvec2 uv = (gl_FragCoord.xy * 2.1 - iResolution.xy) / iResolution.xx;\n\n\tvec3 forward = normalize(lookat - eye);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\t\n\tvec3 right = cross(up, forward);\n\tup = cross(forward, right);\n\t\n\tRay ray;\n\t\n\tray.origin = eye;\n\tray.direction = normalize(right * uv.x + up * uv.y + forward);\n\t\n\teye = ray.origin;\n\t\n\treturn ray;\n}\n\n\nvoid sphereIntersect(const Sphere sphere, const Ray ray, inout Output o) {\n\tvec3 d = ray.origin - sphere.position;\n\t\n\tfloat a = dot(ray.direction, ray.direction);\n\tfloat b = dot(ray.direction, d);\n\tfloat c = dot(d, d) - sphere.radius * sphere.radius;\n\t\n\tfloat g = b*b - a*c;\n\t\n\tif(g > 0.0) {\n\t\tfloat dis = (-sqrt(g) - b) / a;\n\t\tif(dis > 0.0 && dis < o.dis) {\n\t\t\to.dis = dis;\n\t\t\to.origin = ray.origin + ray.direction * dis;\n\t\t\to.normal = (o.origin - sphere.position) / sphere.radius;\n            o.colour = sphere.colour;\n\t\t\to.material = sphere.mat;\n\t\t}\n\t}\n}\n\nvoid planeIntersect(const Plane plane, const Ray ray, inout Output o){\n    float denom = dot(ray.direction, plane.normal);\n    if (denom <= 0.0001){\n    \treturn;\n    }\n    \n    vec3 p0l0 = plane.position - ray.origin;\n    float t = dot(p0l0, plane.normal) / denom;\n    vec3 newOrigin = ray.origin + t * ray.direction;\n    float dis = length(t * ray.direction);\n    if (dis > 0.0 && dis < o.dis){\n    \to.dis = dis;\n        o.origin = newOrigin;\n        o.normal = plane.normal;\n        o.material = plane.mat;\n        o.colour = plane.colour;\n    }\n}\n\nSphere makeSphere(float offset, Material mat){\n    float t = iTime + offset;\n    float x = cos(t);\n    float y = sin(t * 1.5);\n\tfloat z = sin(t * 2.0) * 3.5;\n\treturn Sphere(vec3(x, y, z),\n\t\t\t\t  vec3(sin(offset) + 1.0 / 2.0, cos(offset) + 1.0 / 2.0, 0.2),\n\t\t\t\t  0.5,\n                 mat);\n}\n\nvoid makeScene(){\n\t\n    material[0] = Material(0.1, 0.6, 0.1, 0.0, 0.2, 0.0);\n    material[1] = Material(0.0, 0.8, 0.0, 0.0, 0.1, 0.0);\n    material[2] = Material(0.2, 0.6, 0.5, 0.0, 0.7, 0.0);\n    material[3] = Material(0.1, 0.6, 0.1, 1.0, 0.3, 0.0);\n    material[4] = Material(0.1, 0.6, 0.7, 0.0, 0.2, 0.0);\n    material[5] = Material(0.0, 0.8, 0.0, 0.0, 0.1, 0.0);\n    material[6] = Material(0.2, 0.6, 0.5, 0.0, 0.7, 0.0);\n    material[7] = Material(0.1, 0.6, 0.1, 1.0, 0.3, 0.0);\n    \n\tfor (int i = 0; i < numSphere; i++){\n\t\tsphere[i] = makeSphere(float(i), material[i]);\n\t}\n    \n    plane[0] = Plane(vec3(0.0, 2.0, 0.0), vec3(1.1, 1.0, 1.0), vec3(0.0,1.0,0.1), material[1]);\n    plane[1] = Plane(vec3(0.0, -1.3, 0.0), vec3(1.1, 1.0, 1.1), vec3(0.0,-1.0,0.0), material[1]);\n    plane[2] = Plane(vec3(0.0, 0.0, 5.5), vec3(0.0), vec3(1.0,1.0,1.0), material[2]);\n\t\n    float r = 4.0;\n\tfloat y = 0.0;\n\t\n\tfloat t0 = -iTime + PI * 0.0;\n\tpointlight[0].position = vec3(cos(t0) * r, y, sin(t0) * r);\n\tpointlight[0].colour = vec3(0.5, 0.0, 0.0);\n\tfloat t1 = -iTime + PI * 0.333333;\n\tpointlight[1].position = vec3(cos(t1) * r, y, sin(t1) * r);\n\tpointlight[1].colour = vec3(0.4, 0.4, 0.0);\n\n\tfloat t2 = -iTime + PI * 0.666666;\n\tpointlight[2].position = vec3(cos(t2) * r, y, sin(t2) * r);\n\tpointlight[2].colour = vec3(0.75, 0.75, 0.75);\n\n\tfloat t3 = -iTime + PI * 1.0;\n\tpointlight[3].position = vec3(cos(t3) * r, y, sin(t3) * r);\n\tpointlight[3].colour = vec3(0.0, 0.4, 0.4);\n\n\tfloat t4 = -iTime + PI * 1.333333;\n\tpointlight[4].position = vec3(cos(t4) * r, y, sin(t4) * r);\n\tpointlight[4].colour = vec3(0.0, 0.0, 0.5);\n\n\tfloat t5 = -iTime + PI * 1.666666;\n\tpointlight[5].position = vec3(cos(t5) * r, y, sin(t5) * r);\n\tpointlight[5].colour = vec3(0.4, 0.0, 0.4);\n    \n\t//pointlight[0] = PointLight(vec3(-4.0, 4.0, -8.0), vec3(0.5, 0.5, 0.5));\n\t//pointlight[1] = PointLight(vec3(4.0, -4.0, 5.0), vec3(0.5, 0.5, 0.5));\n    //pointlight[2] = PointLight(vec3(2.0, 5.0, 0.0), vec3(1.0, 0.0, 1.0));\n\n}\n\nvec3 illuminatePointLight(PointLight light, Output o){\n    vec3 brightness = vec3(0.0);\n    \n\tvec3 pointToLight = o.origin - light.position;\n    for (int j = 0; j < 3; j++){\n\t\tbrightness[j] += light.colour[j] * o.material.diffuse * dot(normalize(pointToLight), normalize(o.normal));\n\t\tbrightness[j] += light.colour[j] * o.material.specular * dot(normalize(2.0 * dot(normalize(pointToLight), normalize(o.normal))\n\t\t\t\t\t\t\t\t\t\t\t\t * normalize(o.normal) - normalize(pointToLight)),\n\t\t\t\t\t\t\t\t\t   eye - o.origin);\n    }\n    return brightness;\n}\n\nvec3 shade(Output o){\n    vec3 brightness = vec3(o.material.ambient);\n\t\n\tfor (int i = 0; i < numLight; i++){\n\t\tbrightness += illuminatePointLight(pointlight[i], o);\n\t}\n\tbrightness[0] = clamp(brightness[0], 0.0, 1.0);\n    brightness[1] = clamp(brightness[1], 0.0, 1.0);\n    brightness[2] = clamp(brightness[2], 0.0, 1.0);\n\t\n    float dis = length(eye - o.origin);\n\t\n\tdis -= 10.0;\n\tdis *= 0.07;\n\tdis = clamp(dis, 0.0, 1.0);\n    brightness *= o.colour;\n\treturn brightness * (1.0 - dis);\n}\n\nOutput traceStep(in Ray ray){\n    Output o  = Output(vec3(0.0), \n                       vec3(0.0, 0.0, 0.1), \n                       1.0e4,\n                       Material(\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t \t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n                        0.0),\n                       vec3(0.0));\n                      \n\tvec3 colour = vec3(0.0);\n\tfor (int i = 0; i < numSphere; i++){\n\t\tsphereIntersect(sphere[i], ray, o);\n    }\n    \n    for (int i = 0; i < numPlane; i++){\n    \tplaneIntersect(plane[i], ray, o);\n    }\n    \n    return o;\n}\n\nvec3 trace(in Ray ray){\n\tvec3 colour = vec3(0.0);\n    float reflectivity = 1.0;\n    Output o;\n    \n    for (int i = 0; i < 2; i++){\n    \to = traceStep(ray);\n        \n        if (o.dis > 1.0e3) break;\n        \n        colour += shade(o) * reflectivity;\n        \n        reflectivity *= o.material.reflectivity;\n        \n        float l = length(ray.origin - o.origin) + 0.0001;\n\t\tcolour -= 0.02 / l;\n\n\t\treflectivity *= o.material.reflectivity;\n        \n\t\tif(reflectivity < 0.05) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tray = Ray(o.origin + o.normal * 0.0001, reflect(normalize(o.origin - ray.origin), o.normal));\n    }\n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmakeScene();\n\t//eye = vec3(5.0, 1.0, -2.0);\n    eye = vec3(sin(iTime) * 4.0, cos(iTime), -4.0);\n    Ray ray = castRay(vec3(0.0));\n\t\n\tvec3 color = trace(ray);\n\tfragColor = vec4(color, 1.0);\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXSDj","date":"1406775356","viewed":280,"name":"RayTracer Learning","username":"twitchingace","description":"Building my first ray tracer.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["phong","lighting","sphere","raytrace"],"hasliked":0,"parentid":"","parentname":""}}