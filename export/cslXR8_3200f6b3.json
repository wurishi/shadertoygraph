{"ver":"0.1","info":{"id":"cslXR8","date":"1669672336","viewed":97,"name":"SpotLight Spheres","username":"Famousghost","description":"Simple algorithm to create spotlight\nCamera movement via mouse ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lightdiffusespotlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 250\n#define MAX_DIST 100.0\n#define MIN_DIST 0.03\n#define RADIUS 3.0\n\nmat3 lookAt(vec3 pos, vec3 up, vec3 forward)\n{\n    vec3 direction = normalize(forward - pos);\n\n    vec3 right = normalize(cross(up, direction));\n    vec3 newUp = normalize(cross(direction, right));\n\n    \n    return mat3(right, \n                newUp,\n                direction);\n}\n\nfloat sdfSphere(vec3 p, vec3 offset, float r)\n{\n    return length(p - offset) - r;\n}\n\nfloat sdScene(vec3 p)\n{\n    float sphere1 = sdfSphere(p, vec3(1.0f, 0.0f, 0.0f), 1.0f);\n    float sphere2 = sdfSphere(p, vec3(-1.5f, 1.0f, 1.0f), 1.0f);\n    float sphere3 = sdfSphere(p, vec3(-1.5f, 1.0f, 3.0f), 1.0f);\n    float sphere4 = sdfSphere(p, vec3(-3.0f, 0.0f, 5.0f), 1.0f);\n    float sphere5 = sdfSphere(p, vec3(-3.0f, 0.0f, 7.5f), 1.0f);\n    float sphere6 = sdfSphere(p, vec3(3.0f, 1.0f, 8.0f), 1.0f);\n\n    return min(min(min(sphere1, sphere2), min(sphere3, sphere4)), min(sphere5, sphere6));\n}\n\nfloat rayMarching(vec3 ro, vec3 rd)\n{\n    float depth = 0.0f;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ro + rd * depth;\n        float d = sdScene(p);\n        depth += d;\n        if(d <= MIN_DIST || d >= MAX_DIST)\n            break;\n    }\n    return depth;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    float e = 0.005f;\n    return normalize(vec3(sdScene(vec3(p.x + e, p.y, p.z)) - sdScene(vec3(p.x - e, p.y, p.z)),\n                          sdScene(vec3(p.x, p.y + e, p.z)) - sdScene(vec3(p.x, p.y - e, p.z)),\n                          sdScene(vec3(p.x, p.y, p.z + e)) - sdScene(vec3(p.x, p.y, p.z - e))));\n}\n\nfloat diffuse(vec3 p, vec3 lightPos, vec3 normal)\n{\n    vec3 lightDir = normalize(lightPos - p);\n    return max(0.0f, dot(lightDir, normal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5f * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.2f);\n    \n    vec3 ro = vec3(0.0f, 0.0f, 6.0f);\n\n    float pi = atan(1.0f) * 4.0f;\n    float xAngle = iMouse.y / iResolution.y;\n    float yAngle = iMouse.x / iResolution.x;\n    \n\n    float x = cos(yAngle * 2.0f * pi)* cos(xAngle * 2.0f * pi);\n    float y = sin(xAngle * 2.0f * pi);\n    float z = sin(yAngle * 2.0f * pi) * cos(xAngle * 2.0f * pi);\n    \n    vec3 dir = vec3(x, y, z);\n    \n    vec3 lightPos = ro;\n    vec3 rd = normalize(vec3(uv, -1.0f));\n    \n    rd = lookAt(ro, vec3(0.0f, 1.0f, 0.0f), ro + dir) * rd;\n  \n    \n    float depth = rayMarching(ro, rd);\n    \n    float k1 = 1.1f;\n    float k2 = 0.1f;\n    float k3 = 0.01f;\n    \n    float lightCutoff = cos(radians(13.0f));\n    float lightCutoffOuter = cos(radians(19.0f));\n    \n    float e = lightCutoffOuter - lightCutoff;\n    \n    if(depth <= MAX_DIST)\n    {\n        vec3 p = ro + rd * depth;\n        vec3 normal = calcNormal(p);\n        vec3 pp = ro - p;\n        float dist = length(pp);\n        float spot = dot(normalize(pp), dir);\n\n\n        vec3 sphereColorXY = texture(iChannel0, p.xy).rgb;\n        vec3 sphereColorXZ = texture(iChannel0, p.xz).rgb;\n        vec3 sphereColorYZ = texture(iChannel0, p.yz).rgb;\n        \n        float intensity = clamp((lightCutoffOuter - spot) / e, 0.0f, 1.0f);\n\n        float attenuation = clamp(intensity / (k1 + k2 * dist + k3 * dist * dist), 0.0f, 1.0f);\n\n        float diff = diffuse(p, lightPos, normal) * attenuation ;\n        \n        normal = abs(normal);\n        \n        \n        \n        vec3 spheresColor = sphereColorXY * normal.z + sphereColorXZ * normal.y + sphereColorYZ * normal.x;\n        \n        col = spheresColor * (0.2f + diff);\n\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}