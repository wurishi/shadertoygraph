{"ver":"0.1","info":{"id":"wlVSDw","date":"1582900237","viewed":173,"name":"Sphere(Distortion by flockaroo)","username":"JohnnyRainbow81","description":"Buffer A is copied from MudPlanet by flockaroo!! https://www.shadertoy.com/view/4sXfDX","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["distortion","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 sph2frag(vec3 p)\n{\n\tfloat r = min(iResolution.x/4.,400.);\n    vec2 center = vec2(r,r);\n    p=normalize(p);\n    if(p.z<.0) center.x += 2.*r;\n    return center+sqrt(1.-abs(p.z))*normalize(p.xy)*r;\n}\n\nvec4 Sphere(vec3 p, float radius, vec3 color) {\n\tvec4 d;\n    p += (texture(iChannel0,sph2frag(p)/iResolution.xy).xyz-.5)*.75;\n    d.w = length(p)-radius;\n    d.rgb = color;\n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n\tvec4 sphereDist = Sphere(p-vec3(0.,2.,6.), 1.5, vec3(.5, .3, .3));\n    vec4 floorDist = vec4(vec3(.6,.5,.5), p.y);\n    vec4 d;\n    //d = min(sphereDist.w, floorDist.w);\n    d = sphereDist.w < floorDist.w ? sphereDist : floorDist;\n    return d;\n}\n\nvec4 Raymarch(vec3 ro, vec3 rd) {\n\tvec4 d = vec4(0.);\n    for(int i =0; i < 100; i++) {\n    vec4 dStep = GetDist(ro + rd * d.w);\n        d.w += dStep.w;\n        d.rgb = dStep.rgb;\n        if(d.w < 0.0001 || d.w > 100.) break;\n    }\n    return d;\n}\nvec3 GetNormal(vec3 p) {\n\tvec4 d = GetDist(p);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = d.w - vec3(GetDist(p-e.xyy).w,\n                           GetDist(p-e.yxy).w,\n                           GetDist(p-e.yyx).w);\n    normal = normalize(normal);\n    return normal;\n}\nvec4 GetLight(vec3 p) {\n\tvec3 light = vec3(1.,7.,5.);\n    vec3 lightVec = normalize(light-p);\n    vec3 normal = GetNormal(p);\n    vec4 dif;\n    dif.w = clamp(dot(normal, lightVec),0.,1.);\n    float shadow = Raymarch(p+normal*0.0002, lightVec).w;\n    if(shadow < length(light-p)) dif.w *=clamp(shadow,0.,1.);\n    vec3 halfway = normalize(vec3(normalize(-p)+lightVec));\n    vec4 spec;\n    spec.w = pow(max(dot(normal, halfway), 0.0), 32.0);\n    return dif*1.3+spec*3.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.);\n\tvec3 ro = vec3(0.,2.,0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    vec4 d = Raymarch(ro, rd);\n    vec4 dif = GetLight(ro + rd * d.w);\n    col = vec3(dif.w * d.rgb*1.4 + (1.-dif.w)*vec3(0.1,.1,.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// mud planet\n// single pass CFD on spherical symetry\n// based on \"spilled\" (https://www.shadertoy.com/view/MsGSRd)\n\n#define MAX_RADIUS 400.\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nvec2 sph2frag(vec3 p)\n{\n    //p=p.zxy;\n\tfloat r = min(iResolution.x/4.,MAX_RADIUS);\n    vec2 center = vec2(r,r);\n    p=normalize(p);\n    if(p.z<0.0) center.x += 2.*r;\n    return center+sqrt(1.-abs(p.z))*normalize(p.xy)*r;\n}\n\nvec3 frag2sph(vec2 f)\n{\n\tfloat r = min(iResolution.x/4.,MAX_RADIUS);\n    vec2 center = vec2(r,r);\n    float sz=1.;\n    if(f.x>2.*r)  { center.x += 2.*r; sz=-1.; }\n    vec2 R = (f-center)/r/sqrt(2.);\n    if(dot(R,R)>.55) return vec3(100);\n    //R/=sqrt(2.);\n    vec3 n = vec3(R.xy,sqrt(1.-dot(R,R))*sz);\n    vec3 p = reflect(vec3(0,0,-1.*sz),n);\n    //p=p.yzx;\n    return p;\n}\n\nvec3 frag2sphDiff(vec2 p, vec2 dp)\n{\n    float eps=.001;\n    return (frag2sph(p+normalize(dp)*eps)-frag2sph(p))/eps*length(dp);\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvec3 rotAx(vec3 p, vec3 ang)\n{\n\treturn transformVecByQuat( p, rotateQuatbyAngle(vec4(0,0,0,1), ang) );\n}\n\nvec3 getRot(vec3 pos, vec3 b)\n{\n    vec3 n=normalize(pos);\n    vec3 p = normalize(b-dot(b,n)*n);\n    vec3 rot=vec3(0);\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 fr = sph2frag(pos+p);\n        vec2 v2d = texture(iChannel0,fr/Res.xy).xy-vec2(0.5);\n        vec3 v = texture(iChannel0,fr/Res.xy).xyz-.5;\n        //vec3 v = frag2sphDiff(fr,v2d);\n        rot+=cross(v,p);\n        p = rotAx(p,n*ang);\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvec3 getSun()\n{\n    float phi=.2*iTime;\n    float phi2=.7*cos(phi);\n    vec3 sun=vec3(vec2(cos(phi),sin(phi))*cos(phi2),sin(phi2));\n    return sun;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = frag2sph(fragCoord.xy);\n    if(pos.x>10.) discard;\n    vec3 n = normalize(pos);\n    //float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec3 b = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).xyz;\n    b=normalize(b-dot(b,n)*n)*.01;\n    \n    vec3 v=vec3(0);\n    float bbMax=5.; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec3 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n            float str=.01;\n            str*=pow(dot(b,b),.25)*5.;\n            v+=cross(getRot(pos+p,b),p)*str;\n            p = rotAx(p,n*ang);\n        }\n        b*=2.;\n    }\n    \n    fragColor=texture(iChannel0,sph2frag(pos+v)/iResolution.xy);\n    // mix the flow field with its own velocity field for consistency\n    // (actually i have the suspicion that this does not what its supposed to do)\n    fragColor.xyz=mix(fragColor.xyz,v*5.0+.5,.01);\n\n    // add a little \"motor\" where the sun shines most\n    vec3 sun=getSun();\n    vec3 vel = vec3(sun.yx*vec2(1,-1),0)*.5;\n    //vel *= 0.01/(dot(pos-pos0,pos-pos0)/.2+.2);\n    fragColor.xyz = mix(fragColor.xyz,vel+.5,0.01/(dot(pos-sun,pos-sun)/.2+.2));\n\n    // add a little \"freezer\" on the poles\n    //fragColor.xyz = mix(fragColor.xyz,vec3(.5),pow(pos.z*pos.z,10.));\n\n    if(iFrame<=4 || KEY_I>0.5) fragColor=mix(vec4(.5),texture(iChannel2,fragCoord.xy/iResolution.xy*.5),.2);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}