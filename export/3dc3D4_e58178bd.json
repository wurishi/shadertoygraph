{"ver":"0.1","info":{"id":"3dc3D4","date":"1568484851","viewed":55,"name":"06_Ray Marching","username":"CptSloth199","description":"Ray Marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 500.\n#define SURF_DIST 0.001\n#define MAX_STEPS 680\n#define BOUNCE_N 1\t\t//<---Change number of Reflections, i.e. n>1 makes Reflections contain other Reflections.\n\n#define LIGHT_MODE 1\t//<---Change this to get different PointLight behaviour!\n\n#define SPHERE vec4(0,1,5,1)\n\n#define SPHERE_MAT vec3(.9,1,0.)\n#define MOV_SPHERE_MAT vec3(.7,.3,.2)\n#define MOV_SPHERE2_MAT vec3(.2,1.,.2)\n#define GROUND_MAT vec3(.5,.8,1)\n#define SKY_MATA vec3(0.,0.,0.)\n#define SKY_MATB vec3(.2,.4,.6)\n#define SUB_ZONE_MAT vec3(.2,1.,1.)\n\n#define LIGHT_RADIUS 0.02\n#define LIGHT_INTENSITY 1.\n#define LIGHT_COLOR vec3(1,1,1)\n#define AMBIENT_INTENSITY 1.25\n#define AMBIENT_COLOR vec3(.9,.6,.4)\n#define SPECULARITY 1.5\n#define ROUGHNESS 32.\n\n#define AO_DISTANCE 0.82\n#define AO_MAX_OCCLUSION 0.25\n\n#define PI 3.14159265359\n\nstruct Cylinder{\n    vec3 pos;\n    vec2 hr;\n    } cylinder;\n\n\t//Camera\n\tvec3 getcP(){   \n\t    return vec3(0,1.6,0);\n\t}\n\tvec3 getcD(vec2 uv){\n    \treturn normalize(vec3(uv.x, uv.y, .75));\n\t}\n\n\t//Update Moving Spheres Pos\n\tvec4 getMsphereState(){\n    \treturn vec4(SPHERE.xyz, 0) + vec4(sin(iTime)*2.,sin(iTime*5.)*.5,cos(iTime)*2.,.2); \n\t}\n\n\tvec4 getMsphere2State(){\n    \treturn vec4(SPHERE.xyz, 0) + vec4(sin(iTime)*1.2,sin(iTime*2.)*.3,cos(iTime)*2.8,.2); \n\t}\n\n\tvec4 subSphereState(){\n        return vec4(SPHERE.x, SPHERE.y, SPHERE.z,0.325)+ vec4(sin(iTime*0.8)*SPHERE.w,0.,cos(iTime*0.8)*SPHERE.w,0.);\n\t}\n\n\tvec4 subSphere2State(){\n        return vec4(SPHERE.x, SPHERE.y, SPHERE.z,0.325)+ vec4(sin(iTime*0.8+PI)*SPHERE.w,0.,cos(iTime*0.8+PI)*SPHERE.w,0.);\n\t}\n\n\tfloat SphereDistance(vec3 point, vec4 sphere){\n\t    return length(point-sphere.xyz)-sphere.w;\n\t}\n\n\tfloat CylinDistance(vec3 point, Cylinder cylin){\n        float vert = clamp(point.y,cylin.pos.y + cylin.hr.x*-.5,cylin.pos.y + cylin.hr.x*.5);\n\t    return length(vec3(point.x,point.y,point.z) - vec3(cylin.pos.x,vert,cylin.pos.z)) - cylin.hr.y;\n\t}\n\n\tfloat CapsulDistance(vec3 point, Cylinder caps){\n        float vert = clamp(point.y, caps.pos.y + caps.hr.x*-.5, caps.pos.y + caps.hr.x*.5);\n\t    return length(vec3(point.x,point.y,point.z) - vec3(caps.pos.x, vert, caps.pos.z)) - caps.hr.y;\n\t}\n\n\tfloat SphereBoolSub(vec3 point,vec4 SphereA, vec4 SphereB){\n        return max(SphereDistance(point, SphereB)*-1., SphereDistance(point, SphereA));\n\t}\n\n\tfloat WavePlaneDistance(vec3 point){\n    \treturn (point.y - max( (cos(point.x*6.)*.225) - length(point - getcP())*.048, 0.));\n\t}\n\n\t//Get Closest Distance to Surface\n\tfloat getDist(vec3 point, vec3 lP){\n        //Position, Radius\n        vec4 sphere = SPHERE;\n        vec4 msphere = getMsphereState();\n        vec4 msphere2 = getMsphere2State();\n        float dMovSphere = length(point-msphere.xyz)-msphere.w;\n        float dMovSphere2 = length(point-msphere2.xyz)-msphere2.w;\n        float dSurface = SphereDistance(point, sphere);\n        dSurface = max(SphereBoolSub(point, sphere, subSphereState()),SphereBoolSub(point, sphere, subSphere2State()));\n        float dPlane = WavePlaneDistance(point);\n        float dLight = length(point-vec3(lP.x,lP.y,lP.z*(1.-LIGHT_RADIUS*1.5)))-LIGHT_RADIUS;\n        float dist = min(min(min(dSurface, dPlane),min(dLight, dMovSphere)),dMovSphere2);//Replace with loop for min value!\n    \treturn dist;\n\t}\n\n    //Ray Marching\n    float RayMarch(vec3 RayO, vec3 RayDir, vec3 lP)\t{\n        float dOrigin = 0.;\n        for(int i=0; i < MAX_STEPS; i++){\n            vec3 p = RayO + dOrigin * RayDir;\n            float dSurface = getDist(p, lP);\n            dOrigin = dOrigin + dSurface;\n            if(dSurface < SURF_DIST || dOrigin > MAX_DIST) break;\n        }\n        return dOrigin;\n    }\n\n\t//SphereNormal\n\tvec3 SphereSurfaceNormal(vec3 HitPos){\n        if(HitPos.y > SURF_DIST && HitPos.z < SPHERE.z+SPHERE.w){\n        \treturn normalize(HitPos - SPHERE.xyz);\n        }else if(HitPos.y <= SURF_DIST)return vec3(0,1,0);\n         else return vec3(0);\n    }\n\n\t//TangentNormal\n\tvec3 TangentNormal(vec3 HitPos, vec3 lP){\n        float d = getDist(HitPos, lP);\n        vec2 e = vec2(.001,0.);\n        vec3 p = HitPos;\n        \n        vec3 n = d - vec3(\n            getDist(p-e.xyy, lP),\n            getDist(p-e.yxy, lP),\n            getDist(p-e.yyx, lP));      \n        return normalize(n);\n\t}\n\n\t//Separate Scene Elements with Color ID\n\tvec4 getElemID(vec3 point){\n    \tvec4 c = vec4(0);\n        \n        //Ground\n        if(WavePlaneDistance(point) <= SURF_DIST) c = vec4(1,0,0,0);\n        \n        //Sky\n        if(WavePlaneDistance(point) > SURF_DIST && point.z > SPHERE.z+SPHERE.w) c = vec4(0,0,1,0);\n        \n        //Sphere\n        if(length(point - SPHERE.xyz) <= SPHERE.w + SURF_DIST) c = vec4(0,1,0,0);\n        \n        //Sub Zone\n        if((length(point - SPHERE.xyz) <= SPHERE.w + SURF_DIST)&&(length(point - subSphereState().xyz) <= subSphereState().w + SURF_DIST)) c = vec4(0,1,0,1);\n        //Sub Zone 2\n        if((length(point - SPHERE.xyz) <= SPHERE.w + SURF_DIST)&&(length(point - subSphere2State().xyz) <= subSphere2State().w + SURF_DIST)) c = vec4(0,1,0,1);\n        \n        //MovingSphere1\n        if(length(point - getMsphereState().xyz) <= getMsphereState().w + SURF_DIST*1.2) c = vec4(1,1,0,0);\n        \n        //MovingSphere2\n        if(length(point - getMsphere2State().xyz) <= getMsphere2State().w + SURF_DIST*1.2) c = vec4(0,1,1,0);\n        return c;\n\t}\n\t\n\t//ShadowProjection\n\tfloat projectShadow(vec3 HitPoint, vec3 lP){\n        if(getElemID(HitPoint) != vec4(0,0,1,0)){      \n        float lightImpactD = RayMarch(lP, normalize(HitPoint - lP), lP);\n        float directImpactD = length(HitPoint - lP);\n        float deltaD = min(directImpactD - lightImpactD,1.);\n        return clamp((1. - deltaD*15.),0.,1.);\n        \t} \n        return 1.;    \t\n    }\n\n\t//Background Material\n\tvec3 SkyDomeMat(vec3 point, vec2 uv){\n        vec3 bgMat = vec3(0);\n        bgMat = mix(SKY_MATA, SKY_MATB, uv.y * 2.);\n\t    return bgMat;\n\t}\n\n\t//Materials\n\tvec3 MaterialShading(vec3 point, vec2 uv){\n        \n        if(getElemID(point) == vec4(1,1,0,0)) return vec3(MOV_SPHERE_MAT);\n        if(getElemID(point) == vec4(0,1,1,0)) return vec3(MOV_SPHERE2_MAT);\n        if(getElemID(point) == vec4(0,1,0,1)) return vec3(SUB_ZONE_MAT);\n        \n        return vec3 (getElemID(point).x * GROUND_MAT) +\n                    (getElemID(point).y * SPHERE_MAT) +\n                    (getElemID(point).z * SkyDomeMat(point, uv));\n\t}\n\n\t//DirLightIntensity\n\tfloat DirIntensity(vec3 lP, vec3 pos){\n\t    return max(LIGHT_INTENSITY / pow(length(lP - pos),.01),0.);\n\t}\n\n\t//Directional Light\n\tvec3 DirectionalLight(vec3 lN, vec3 sN, float dirInt){\n\t\treturn (max(dot(lN, sN),0.) * LIGHT_COLOR * dirInt);\n\t}\n\n\t//LightDummy Shading\n\tvec3 LightDummyShading(vec3 point, vec2 uv){\n        vec3 LightProxy = vec3(0);\n        if(getElemID(point) == vec4(0))LightProxy = vec3(1);\n        return LightProxy;\n\t}\n\n\t//Ambient Light\n\tvec3 AmbientLight(vec3 point, vec3 cP, vec3 lP){\n        if(getElemID(point) != vec4(0,0,1,0))return (AMBIENT_COLOR * AMBIENT_INTENSITY / RayMarch(cP, normalize(point-cP), lP));\n        else return vec3(1);\n\t}\n\n\t//AO\n\tfloat AmbientOcclusion(vec3 point,vec3 Normal, vec3 lP){\n        float dAO = pow(RayMarch((point + Normal * SURF_DIST * 1.5), Normal, lP),AO_MAX_OCCLUSION);\n        return dAO = clamp(pow(dAO + (1. - AO_DISTANCE),1.),AO_MAX_OCCLUSION,1.);\n    }\n\n\t//Specular Reflection\n\tvec3 SpecReflection(vec3 cP,vec3 cD, vec3 SurfaceNormal, vec3 lP, vec3 HitPos){\n        //return normalize(lP-HitPos);\n        vec3 refl = reflect(normalize(HitPos - lP), SurfaceNormal);\n        //return vec3(dot(normalize(lP-HitPos),reflect(cD, SurfaceNormal)));\n        //Fake Glass Refraction\n    \t//return vec3(pow(dot(reflect(cD, SurfaceNormal),normalize(lP-HitPos)),4.));\n        vec3 SpecRefl = pow(vec3(max(dot(normalize(cP-HitPos),refl),0.)) * clamp(SPECULARITY + .8, 0., 1.),vec3(ROUGHNESS));\n        return SpecRefl;\t//Add proper Specular focus in line above!\n\t}\n\n\n\tvec4 Get3ndBounceLight(vec3 lP,vec3 campos, vec3 pos, vec3 sn, int BC){\n        vec3 raydir = reflect(normalize(pos-campos),sn);\n        //return vec4(raydir,1);\n        vec3 raystart = pos + sn * SURF_DIST * 1.1;\n        float raydist = RayMarch(raystart, raydir, lP);\n        //return vec4(raydist, raydist, raydist, 1) * .2;\n        vec3 newPos = raystart + raydist * raydir;\n        vec3 newN = TangentNormal(newPos, lP);\n        vec3 reflectionCol = MaterialShading(newPos, vec2(0));\n        vec3 LightExp = DirectionalLight(normalize(lP - newPos), TangentNormal(newPos, lP), DirIntensity(lP, newPos));\n        vec3 DirectionalLight = LightExp* projectShadow(newPos, lP);\n        vec3 AmbientLight = AMBIENT_COLOR * AMBIENT_INTENSITY / RayMarch(campos, normalize(pos-campos), lP);\n        float AO = AmbientOcclusion(newPos, TangentNormal(newPos, lP), lP);        \n        vec4 BounceResult = vec4(((DirectionalLight) + AmbientLight)* reflectionCol,0);\n        vec4 subTotal = BounceResult;\n        return subTotal;        \n\t}\n\n\tvec4 Get2ndBounceLight(vec3 lP,vec3 campos, vec3 pos, vec3 sn, int BC){\n        vec3 raydir = reflect(normalize(pos-campos),sn);\n        //return vec4(raydir,1);\n        vec3 raystart = pos + sn * SURF_DIST * 1.1;\n        float raydist = RayMarch(raystart, raydir, lP);\n        //return vec4(raydist, raydist, raydist, 1) * .2;\n        vec3 newPos = raystart + raydist * raydir;\n        vec3 newN = TangentNormal(newPos, lP);\n        vec3 reflectionCol = MaterialShading(newPos, vec2(0));\n        vec3 LightExp = DirectionalLight(normalize(lP - newPos), TangentNormal(newPos, lP), DirIntensity(lP, newPos));\n        vec3 DirectionalLight = LightExp* projectShadow(newPos, lP);\n        vec3 AmbientLight = AMBIENT_COLOR * AMBIENT_INTENSITY / RayMarch(campos, normalize(pos-campos), lP);\n        float AO = AmbientOcclusion(newPos, TangentNormal(newPos, lP), lP);        \n        vec4 BounceResult = vec4(((DirectionalLight) + AmbientLight)* reflectionCol,0);\n        vec4 subTotal = BounceResult;\n        if(BC == 3){\n        \tsubTotal = mix(BounceResult, Get3ndBounceLight(lP, campos, newPos, newN, BC - 1), .5);\n        }\n        return subTotal;        \n\t}\n\n\tvec4 GetBounceLight(vec3 lP,vec3 campos, vec3 pos, vec3 sn, int BC){\n        \n        if(BC == 0)return vec4(0.);\n        \n        vec3 raydir = reflect(normalize(pos-campos),sn);\n        //return vec4(raydir,1);\n        vec3 raystart = pos + sn * SURF_DIST * 1.1;\n        float raydist = RayMarch(raystart, raydir, lP);\n        //return vec4(raydist, raydist, raydist, 1) * .2;\n        vec3 newPos = raystart + raydist * raydir;\n        vec3 newN = TangentNormal(newPos, lP);\n        vec3 reflectionCol = MaterialShading(newPos, vec2(0));\n        vec3 LightExp = DirectionalLight(normalize(lP - newPos), TangentNormal(newPos, lP), DirIntensity(lP, newPos));\n        vec3 DirectionalLight = LightExp* projectShadow(newPos, lP);\n        vec3 AmbientLight = AMBIENT_COLOR * AMBIENT_INTENSITY / RayMarch(campos, normalize(pos-campos), lP);\n        float AO = AmbientOcclusion(newPos, TangentNormal(newPos, lP), lP);        \n        vec4 BounceResult = vec4(((DirectionalLight) + AmbientLight)* reflectionCol,0);\n        vec4 subTotal = BounceResult;\n        if(BC >= 2){\n        \tsubTotal = mix(BounceResult, Get2ndBounceLight(lP, campos, newPos, newN, BC - 1), .2);\n        }\n        return subTotal;        \n\t}\n\t//Shading\n\tvec3 Shading(vec3 cP, vec3 cD, vec3 lP, vec2 uv){\n        //if(dOrigin > 0.5) return vec3(0,1,0);\n        //else return vec3(1,0,0);\n        float dOrigin = RayMarch(cP, cD, lP);\n        vec3 HitPos = vec3(cP + cD * dOrigin);\n        //Debug Depth\n        //return vec3(dOrigin)*.1;\n        //Debug Position\n        //return HitPos;   \n                \n        //Surface Normal\n        //vec3 SurfaceNormal = SphereSurfaceNormal(HitPos);\n        vec3 SurfaceNormal = TangentNormal(HitPos, lP);\n        //Debug\n        //return SurfaceNormal;\n        \n        //Light Normal\n        \t//Camera emits Light\n        //vec3 LightNormal = normalize(cP - HitPos);\n        \t//Mouse emits Light\n        vec3 LightNormal = normalize(lP - HitPos);\n        //Debug\n        //return LightNormal;\n        \n        //Materials\n        vec3 Mats = vec3(1);\n        Mats = MaterialShading(HitPos, uv);\n        //Debug IDs\n        //return vec3(getElemID(HitPos));\n        //Debug Materials\n        //return Mats;\n        \n        //Bounce\n        vec4 Bounce = GetBounceLight(lP, cP, HitPos, SurfaceNormal, BOUNCE_N);\n        //Debug Reflections\n        //return Bounce.xyz;\n        \n        //LightDummy\n        vec3 LightDummy = vec3(0);\n        LightDummy = LightDummyShading(HitPos, uv);\n        \n        //LightFalloff\n        float DirIntensity = DirIntensity(lP, HitPos);\n\n        //DirectLight\n        vec3 DirLight = vec3(0);\n        DirLight = DirectionalLight(LightNormal, SurfaceNormal, DirIntensity) * Mats;\n        \n        //ShadowProjection\n        float Shadow = 1.;\n        Shadow = projectShadow(HitPos, lP);\n        //Debug Shadows\n        //return vec3(Shadow);\n        \n        //Cheat AO attempt\n        float AO = 1.;\n        AO = AmbientOcclusion(HitPos, SurfaceNormal, lP);\n        //Debug AO\n        //return vec3(AO);\n        \n        //Ambient Sky Light\n        vec3 AmbLight = vec3(0);\n        AmbLight = AmbientLight(HitPos, cP , lP) * Mats * AO;\n        //Debug AmbLight\n        //return AmbLight;\n        \n        //Spec Reflections\n        vec3 SpecRefl = vec3(0);\n        SpecRefl = (SpecReflection(cP, cD, SurfaceNormal, lP, HitPos)) * Shadow; //No Spec in Shadow!\n        \n        vec3 LightAssembly = vec3(1);\n        LightAssembly = mix((DirLight*Shadow) + AmbLight + SpecRefl + LightDummy, Bounce.xyz, .1);\n        //Debug Directional Light\n        //return DirLight;\n        \n        //return Shaded Scene;\n        return LightAssembly;\n\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //Mouse ControlPoint\n    vec3 MWSPos = getcP() + vec3(((iMouse.xy/iResolution.xy)-.5)*4.5,0);\n    \n    //Mouse Initial Position, before any clicks\n    if(iMouse.zw == vec2(0))MWSPos = getcP() + vec3(-2.,1.,0.);\n    \n    //Limit Mouse Y\n    MWSPos = vec3(MWSPos.x,max(MWSPos.y,0.1),MWSPos.z);\n    //Set Light Position\n    \n    vec3 LightPos = vec3(SPHERE.x, SPHERE.y + 2., SPHERE.z);\n    \n    //Static Light\n\tif(LIGHT_MODE == 0)LightPos = vec3(MWSPos.xy,SPHERE.z * 0.55);\n    //Ocillating Light\n    if(LIGHT_MODE == 1)LightPos = vec3(MWSPos.x + cos(iTime * .9) * 3.2, max(MWSPos.y + sin(iTime), 0.1), SPHERE.z + sin(iTime * .65) * 2.5);\n    \n    vec3 col = vec3(0, 0, 0);\n    \n    //Debug Position\n    //vec3 point = camPos + camDir * RayMarch(camPos, camDir, LightPos);\n        \n    //Render:\n    //Test RayMarch\n    //col = vec3(point);\n    //TestSphereNormal\n    //col = SphereSurfaceNormal(point);\n    //Test TangentNormal\n    //col = TangentNormal(point);\n    //Test ElemID\n    //col = getElemID(point);\n    col = Shading(getcP(), getcD(uv.xy), LightPos, uv);\n    \n    // Output to screen\n    fragColor = vec4(col,0);\n}\n","name":"Image","description":"","type":"image"}]}