{"ver":"0.1","info":{"id":"fdBXRm","date":"1619981714","viewed":581,"name":"Path Tracer (oopsie)","username":"trigophers","description":"accidentally deleted, imported and once again uploaded from a .json export.\nAll code by me other than code credited within comments","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["monte","carlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n- Move your mouse to see the whole scene. You will have to hold down left click.\n- You may also navigate around the scene using WASD controls, as well as shift and space keys, similar to movement in minecraft.\n- To save an image, right click and wait until the noise goes away.\n\nPath traced spheres and planes\nNot super accurate to real life...\n\nFEATURES:\n\n  Diffuse\n  Specular\n  Glossy\n  Light source\n  Any resolution\n  Keyboard movement\n  Mouse movement\n  Sky lighting\n  Plane color texturing\n\n  Gamma correction\n  Automatic anti aliasing via randomized camera rays\n  Fresnel reflection via Schlick Approximation\n  Progressive sampling\n\n  Global Illumination\n\nTO DO:\n  Depth of field\n  Electric objects\n  Importance sampling\n  Bidirectional raytracing\n  Normal maps\n  Triangles\n  Transparent objects\n\nSuggest other features?\n\nORIGINALLY MADE IN SCRATCH (yes scratch): https://scratch.mit.edu/projects/507498834/\nThanks to MILES WAUGH for the original scene: https://scratch.mit.edu/projects/391016539/\nHASH functions by @Nimitz: https://www.shadertoy.com/view/Xt3cDn/\n\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n    vec3 col = data.xyz/data.w;\n    \n\tfragColor = vec4( pow(col, vec3(0.45)), 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.1415926536\n#define SCENE 0\n\nvec2 pixel;\nvec3 color;\nvec3 c;\nvec3 finC;\nvec3 point;\nvec3 vec;\nvec3 normal;\nvec4 temp;\nfloat rDist;\nint material;\nbool AspectDim;\n\nconst float KEY_W =87.;\nconst float KEY_A =65.;\nconst float KEY_S =83.;\nconst float KEY_D =68.;\nconst float KEY_SHIFT = 16.;\nconst float KEY_SPACE = 32.;\n\n// - - - - - - - - - - - - - - - - - Common Functions - - - - - - - - - - - - - - - -\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n//my single axis based normalization, such that aspect ratio is preserved\n//but fits to any resolution\nvoid aspectNorm(vec2 fragCoord, vec2 scale) {\n    if (iResolution.x<iResolution.y) {\n        pixel = scale*(fragCoord/iResolution.xx-vec2(0.5, iResolution.y/iResolution.x/2.0));\n        AspectDim = false;\n    } else {\n        pixel = scale*(fragCoord/iResolution.yy-vec2(iResolution.x/iResolution.y/2.0, 0.5));\n        AspectDim = true;\n    }\n    \n}\n\n//Schlick's Approximation, here's a desmos graph I made: https://www.desmos.com/calculator/nks7jgzgd6\nfloat calcFresnel(float n0, float n1) {\n    float r = (n0-n1)/(n0+n1);\n    r = r*r;\n    float a = dot(vec, normal);\n    return r+(1.-r)*pow((1.+a), 5.);\n}\n\n//random vector\nvec3 randVec(float seed) {\n    vec3 randV = vec3(1, 1, 1);\n    while (length(randV) > 1.0) {\n        randV = vec3(hash1(seed), hash1(seed), hash1(seed));\n    }\n    return randV;\n}\nvec3 cosineDirection(vec3 nor, float seed) {\n    float u = hash1(seed)*2.0-1.0;\n    float a = hash1(seed)*6.28318531;\n    return normalize(nor+vec3(sqrt(1.0-u*u)*vec2(cos(a),sin(a)), u) );\n}\n\n// - - - - - - - - - - - - - - - - - Distance Functions - - - - - - - - - - - - - - - -\n//Sphere distance\nvoid sphere(vec3 sPos, float rad, vec3 sColor, int mat, float seed) {\n    vec3 obj = sPos - point;\n    temp.x = dot(obj, vec);\n    temp.y = dot(obj, obj);\n    if ((temp.x > 0.0) && (rad * rad > (temp.y - temp.x * temp.x))) {\n        temp.z = sqrt(rad * rad - (temp.y - temp.x * temp.x));\n        if ((temp.y > rad * rad) && rDist > temp.x - temp.z) {\n            rDist = temp.x - temp.z;\n            normal = normalize(point + vec * rDist - sPos);\n            c = sColor;\n            if (mat == 3) {\n                material = 0;\n                float f = calcFresnel(1.0, 1.25);\n                if (hash1(seed)<f) {\n                    material = 1;\n                    c = vec3(255);\n                }\n            } else {\n                material = mat;\n            }\n        }\n    }\n}\n\n\n//inigo quilez\nvoid triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if(! (t<0.0 || u<0.0 || v<0.0 || (u+v)>1.0 ) ) {\n        if (t < rDist) {\n            normal = normalize(n);\n            rDist = t;\n            c = vec3(75, 75, 75);\n            material = 0;\n        }\n    }\n    //return vec3( t, u, v );\n}\n\n//Finite plane distance\nvoid fPlane(int t, vec3 pPos, vec2 dim, vec3 pColor, vec3 pColor2, float scale, int mat, float seed) {\n    if (t == 0) { //x normal\n        temp.x = 0.0-(point.x - pPos.x)/vec.x;\n        if ((vec.x != 0.0) && ((0.0-temp.x) < 0.0) && (temp.x < rDist)) {\n            if ((pPos.y-dim.x)<(vec.y*temp.x+point.y)&&\n                (pPos.y+dim.x)>(vec.y*temp.x+point.y)&&\n                (pPos.z-dim.y)<(vec.z*temp.x+point.z)&&\n                (pPos.z+dim.y)>(vec.z*temp.x+point.z)) {\n                rDist = temp.x;\n                if (int(mod( round((rDist*vec.y+point.y)/scale) + round((rDist*vec.z+point.z)/scale) , 2.0)) == 1) {\n                    c = pColor;\n                } else {\n                    c = pColor2;\n                }\n                normal = vec3((point.x>pPos.x)?1.0:-1.0, 0.0, 0.0);\n                material = 0;\n                if (mat == 3) {\n                    float f = calcFresnel(1.0, 1.5);\n                    if (hash1(seed)<f) {\n                        material = 1;\n                        c = vec3(255);\n                    }\n                } else {\n                    material = mat;\n                }\n            }\n        }\n    } else if (t == 1) { //y normal\n        temp.x = 0.0-(point.y - pPos.y)/vec.y;\n        if ((vec.y != 0.0) && ((0.0-temp.x) < 0.0) && (temp.x < rDist)) {\n            if ((pPos.x-dim.x)<(vec.x*temp.x+point.x)&&\n                (pPos.x+dim.x)>(vec.x*temp.x+point.x)&&\n                (pPos.z-dim.y)<(vec.z*temp.x+point.z)&&\n                (pPos.z+dim.y)>(vec.z*temp.x+point.z)) {\n                rDist = temp.x;\n                if (int(mod( round((rDist*vec.x+point.x+19.)/scale) + round((rDist*vec.z+point.z+19.)/scale) , 2.0)) == 1) {\n                    c = pColor;\n                } else {\n                    c = pColor2;\n                }\n                normal = vec3(0.0, (point.y>pPos.y)?1.0:-1.0, 0.0);\n                material = 0;\n                if (mat == 3) {\n                    float f = calcFresnel(1.0, 1.5);\n                    if (hash1(seed)<f) {\n                        material = 1;\n                        c = vec3(255);\n                    }\n                } else {\n                    material = mat;\n                }\n            }\n        }\n    } else { //z normal\n        temp.x = 0.0-(point.z - pPos.z)/vec.z;\n        if ((vec.z != 0.0) && ((0.0-temp.x) < 0.0) && (temp.x < rDist)) {\n            if ((pPos.x-dim.x)<(vec.x*temp.x+point.x)&&\n                (pPos.x+dim.x)>(vec.x*temp.x+point.x)&&\n                (pPos.y-dim.y)<(vec.y*temp.x+point.y)&&\n                (pPos.y+dim.y)>(vec.y*temp.x+point.y)) {\n                rDist = temp.x;\n                if (int(mod( round((rDist*vec.x+point.x)/scale) + round((rDist*vec.y+point.y)/scale) , 2.0)) == 1) {\n                    c = pColor;\n                } else {\n                    c = pColor2;\n                }\n                normal = vec3(0.0, 0.0, (point.z>pPos.z)?1.0:-1.0);\n                material = 0;\n                if (mat == 3) {\n                    float f = calcFresnel(1.0, 1.5);\n                    if (hash1(seed)<f) {\n                        material = 1;\n                        c = vec3(255);\n                    }\n                } else {\n                    material = mat;\n                }\n            }\n        }\n    }\n}\n\n\n\n\n// - - - - - - - - - - - - - - - - - - - - Scene - - - - - - - - - - - - - - - - - - - -\nvoid scene(float seed) {\n  if (SCENE == 0) { //My Showcase of GI Scene\n    triIntersect(point, vec, vec3(-30.0, -49.0,  40.0), vec3(0, 100, 0), vec3( 40.0, -59.0, -20.0));\n  \n    sphere(vec3( 40.0, -59.0, -20.0), 40.0, vec3(200.0, 200.0, 200.0), 1, seed);\n    sphere(vec3(-30.0, -49.0,  40.0), 50.0, vec3(255.0, 255.0, 255.0), 0, seed);\n    \n    fPlane(0, vec3( 100,   0,   0), vec2(100,100),        vec3( 25,150,25),        vec3( 25,150,25),  1.0,       0, seed); //right\n    fPlane(0, vec3(-100,   0,-100), vec2(100,200),        vec3(150, 25,25),        vec3(150, 25,25),  1.0,      0, seed); //left\n    fPlane(0, vec3( 300,   0,-200), vec2(100,100),        vec3(250,250,250),       vec3(250,250,250),  1.0,      0, seed); //far right\n    \n    fPlane(1, vec3( 100, 100,-200), vec2(200,100), vec3(  255,  255,  255),  vec3(  250,  250,  250),  1.0,                   0, seed); //ceiling\n    fPlane(1, vec3( 100,-100,-100), vec2(200,200), vec3(  255,  255,  100),  vec3(  100,  100,  150), 40.0, 3     , seed); //floor\n    fPlane(1, vec3(   0, 100,   0), vec2(33, 33), vec3(400000, 360000,300000), vec3(400000, 360000,300000),  1.0,     2, seed); //light\n    fPlane(1, vec3(   0, 100,   0), vec2(100,100), vec3(250, 250, 250), vec3(250, 250, 250),  1.0,         0, seed); //light\n    \n    fPlane(2, vec3(   0,   0, 100), vec2(100,100),       vec3(150,150,150),        vec3(150,150,150),  1.0,        0, seed); //front\n    fPlane(2, vec3( 100,   0,-300), vec2(200,100),       vec3( 50, 50,200),        vec3( 50, 50,200),  1.0,      0, seed); //back\n    fPlane(2, vec3( 200,   0,-100), vec2(100,100),       vec3(255,255,255),        vec3(250,250,250),  1.0,      0, seed); //side front\n    \n    \n    \n  } else if (SCENE == 1) { //piano_miles's pathtracer scene (https://scratch.mit.edu/projects/391016539/)\n    fPlane(1, vec3(0, -200, 0), vec2(200, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(1, vec3(0, 200, 0), vec2(200, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(1, vec3(125, 100, 0), vec2(50, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(1, vec3(125, 0, 0), vec2(50, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(1, vec3(125, -100, 0), vec2(50, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(1, vec3(-125, 100, 0), vec2(50, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(1, vec3(-125, 0, 0), vec2(50, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    \n    fPlane(0, vec3(75, 50, 0), vec2(50, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(0, vec3(75, -150, 0), vec2(50, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(0, vec3(-75, 150, 0), vec2(50, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(0, vec3(-75, -100, 0), vec2(100, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(0, vec3(175, 150, 0), vec2(50, 100), vec3(600000, 420000, 260000), vec3(600000, 420000, 260000), 50.0, 2, seed);\n    fPlane(0, vec3(175, -50, 0), vec2(50, 100), vec3(15000, 30000, 150000), vec3(15000, 30000, 150000), 50.0, 2, seed);\n    fPlane(0, vec3(-175, 50, 0), vec2(100, 100), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    \n    fPlane(2, vec3(0, 0, 100), vec2(200, 200), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed);\n    fPlane(2, vec3(0, 0, -100), vec2(200, 200), vec3(240, 240, 240), vec3(75, 75, 75), 50.0, 0, seed); \n    \n    \n    \n  } else if (SCENE == 2) { //Ballsrender from wikipedia >:)\n    fPlane(1, vec3(60., 80, -80.)*4., vec2(64, 64), vec3(900000, 900000, 900000), vec3(9000000, 9000000, 9000000), 1.0, 2, seed);\n    fPlane(1, vec3(0, -0.5, 0)*4., vec2(20000, 20000), vec3(80, 80, 80),  vec3(50, 50, 50), 38.0, 3, seed);\n\n    sphere(vec3(05.38326, 09.48362, -109.691)*4., 09.75855*4., vec3(70, 70, 70), 3, seed);\n    sphere(vec3(-11.8142, 06.83359, -94.0422)*4., 07.11052*4., vec3(25, 8, 95), 3, seed);\n    sphere(vec3(-34.1409, 07.85611, -95.5498)*4., 08.13467*4., vec3(5, 90, 5), 3, seed);\n    sphere(vec3(-23.9994, 18.7003, -124.832)*4., 18.9863*4., vec3(130, 5, 5), 3, seed);\n    sphere(vec3(32.3795, 11.6985, -98.1731)*4., 11.9819*4., vec3(5, 5, 90), 3, seed);\n    sphere(vec3(36.9962, 14.3103, -139.278)*4., 14.5811*4., vec3(35, 8, 95), 3, seed);\n    sphere(vec3(27.3374, 07.51414, -115.845)*4., 07.7825*4., vec3(130, 10, 10), 3, seed);\n    sphere(vec3(14.9821, 05.74386, -124.279)*4., 06.00562*4., vec3(5, 90, 5), 3, seed);\n    sphere(vec3(-01.04378, 11.5052, -146.261)*4., 11.7685*4., vec3(5, 5, 90), 3, seed);\n    \n    \n  \n  } else { //piano_miles's other path tracer scene (https://scratch.mit.edu/projects/425020125/)\n    fPlane(1, vec3(0,-100,0), vec2(20000,20000), vec3(  200,  200,  200),  vec3(  25,  25,  25), 60.0, 3, seed); //floor\n    \n    sphere(vec3(126.983, 0, 502.544), 100.0, vec3(250, 25, 25)/2., 3, seed);\n    sphere(vec3(099.6031, -054.2131, 360.426), 024.6911, vec3(70, 38, 150)/2., 3, seed);    \n    sphere(vec3(330.538, -110.349, 1216.35), 354.71, vec3(230, 90, 15)/2., 3, seed);\n    sphere(vec3(039.3969, -83.0, 384.57), 016.0, vec3(250, 250, 20)/2., 3, seed);\n    sphere(vec3(020.3895, 030.2426, 438.208), 018.7254, vec3(50, 250, 50)/2., 3, seed);\n    sphere(vec3(005.7289, -049.0, 605.545), 050.0, vec3(50, 250, 250)/2., 3, seed);\n    sphere(vec3(-026.4944, -067.0, 392.281), 032.0, vec3(180, 10, 150)/2., 3, seed);\n    sphere(vec3(-119.437, -049.0, 423.011), 050.0, vec3(20, 20, 200)/2., 3, seed);\n    sphere(vec3(-035.6911, -049.1123, 499.068), 029.0709, vec3(220, 220, 220)/2., 3, seed);\n    sphere(vec3(-184.946, 036.8301, 781.645), 127.904, vec3(130, 100, 40), 1, seed); \n    \n    sphere(vec3(-500.0, 500.0,  300.0),200.0, vec3(1600000.0, 1600000.0, 1600000.0), 2, seed);\n  }\n}\n\n\n\n// - - - - - - - - - - - - - - - - - - - Rendering - - - - - - - - - - - - - - - - - - -\nvec3 skyColoring() { //From https://raytracing.github.io/books/RayTracingInOneWeekend.html\n    temp.x = (vec.y + 1.0) / 2.0;\n    temp.y = (1.0 - temp.x)*255.0;\n    return (vec3(temp.y, temp.y, temp.y)\n         + vec3(temp.x, temp.x, temp.x)\n         * vec3(50.0, 90.0, 150.0));\n}\n\nvoid setVec(vec3 cameraPosition, vec3 cameraVector) {\n    point = cameraPosition;\n    vec = normalize(cameraVector);\n}\n\nvoid dirVec(vec2 cameraDirection) {\n    temp.x = vec.z;\n    vec.z = vec.z * cos(cameraDirection.y) - vec.y * sin(cameraDirection.y);\n    vec.y = vec.y * cos(cameraDirection.y) + temp.x * sin(cameraDirection.y);\n    temp.x = vec.z;\n    vec.z = vec.z * cos(cameraDirection.x) - vec.x * sin(cameraDirection.x);\n    vec.x = vec.x * cos(cameraDirection.x) + temp.x * sin(cameraDirection.x);\n}\n\nvec3 raytrace(vec3 cameraPosition, vec2 cameraDirection, float FoV, float RenderDistance, int maxRefs, float fogFact, float seed) {\n    setVec(cameraPosition, vec3(pixel+(AspectDim?vec2(hash1(seed)/iResolution.yy):vec2(hash1(seed)/iResolution.xx)), FoV));\n    dirVec(cameraDirection);\n    finC = vec3(1.0, 1.0, 1.0);\n    c = vec3(0.0, 0.0, 0.0);\n    rDist = 0.0;\n    int refsI = 0;\n    material = 0;\n    while ((rDist < RenderDistance) && (refsI < maxRefs) && !(finC == vec3(0.0, 0.0, 0.0)) && !(material == 2)) {\n        rDist = RenderDistance;\n        scene(seed);\n        if (rDist<RenderDistance) {\n            if (hash1(seed)>(1.0/(rDist*fogFact))) {\n                setVec(point+vec*rDist*hash1(seed)+normal, normal+(randVec(seed)-vec3(0.5))*4.0);\n            } else { \n                if (true) {\n                finC *= c/vec3(255.0);\n                }\n                if (material == 0) {\n                    setVec(point+vec*rDist+normal, cosineDirection(normal, seed));\n                } else if (material == 1) {\n                    setVec(point+vec*rDist+normal, vec-normal*vec3(2.0)*dot(normal, vec));\n                \n                } else {\n                }\n            }\n        }\n        refsI++;\n    }\n    \n    if (SCENE == 3) {\n        if (!(rDist<RenderDistance)) {\n            finC *= vec3(46, 100, 160);\n        }\n    } else if (SCENE == 2) {\n        if (!(rDist<RenderDistance)) {\n            finC *= vec3(0, 0, 0);\n        }\n    } else {\n    if (!(rDist<RenderDistance)) {\n            finC *= skyColoring();\n        }\n    }\n    \n    return finC-1.0;\n}\n\n// - - - - - - - - - - - - - - - - - - - - Display - - - - - - - - - - - - - - - - - - -\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cameraDirection;\n    if (iFrame == 0) {\n        cameraDirection = vec2(pi+0.2, pi/2.);\n    } else {\n        cameraDirection = vec2((iMouse.x-iResolution.x/2.0)/iResolution.x*8.0, \n                              clamp((iMouse.y-iResolution.y/2.0)/iResolution.y*4.5, pi/-2.0, pi/2.0));\n    }\n    float w = texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x;\n    float a = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x;\n    float s = texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x;\n    float d = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x;\n    float shift = texelFetch( iChannel1, ivec2(KEY_SHIFT,0), 0 ).x;\n    float space = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x;\n    if (fragCoord.x <= 1. && fragCoord.y <= 1.) {\n        vec4 data = texture( iChannel0, vec2(0.0, 0.0) )*1.0;\n        data += vec4((w-s)*2.*sin(cameraDirection.x)+(d-a)*2.*cos(0.-cameraDirection.x), space-shift,\n                     (w-s)*2.*cos(cameraDirection.x)+(d-a)*2.*sin(0.-cameraDirection.x), 0.0);\n        fragColor = vec4(data.xyz, 1);\n    } else {   \n        vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\n        aspectNorm(fragCoord, vec2(1.0, 1.0));\n        float FoV = 1.0;\n        float RenderDistance = 10000000.0;\n        int maxRefs = 5;\n        float foggy;\n        vec3 cameraPosition;\n        \n        vec3 texPos = texture( iChannel0, vec2(0, 0) ).xyz;\n        if (SCENE == 0) {\n            cameraPosition = vec3(-50, 0, -250)+texPos;\n            foggy = 0.0001;\n        } else if (SCENE == 1) {\n            cameraPosition = vec3(0, -199, 0)+texPos;\n            foggy = 0.003;\n        } else if (SCENE == 2) {\n            cameraPosition = vec3(0.06972*4., 19.3017*4., -10.851*4.);\n            cameraDirection = vec2(pi, -0.05);\n            foggy = 0.;\n            FoV = 1.8;\n        } else {\n            cameraPosition = vec3(0, 0, 0)+texPos;\n            foggy = 0.00001;\n            FoV = 1.75;\n        }\n\n        color = raytrace(cameraPosition, cameraDirection, FoV, RenderDistance, maxRefs, foggy, seed);\n        color += raytrace(cameraPosition, cameraDirection, FoV, RenderDistance, maxRefs, foggy, seed);\n        color += raytrace(cameraPosition, cameraDirection, FoV, RenderDistance, maxRefs, foggy, seed);\n        color += raytrace(cameraPosition, cameraDirection, FoV, RenderDistance, maxRefs, foggy, seed);\n        vec4 data = texture( iChannel0, fragCoord/iResolution.xy );\n        if(iFrame==0 || space == 1.0 || shift == 1.0 || iMouse.z > 0.0 || w==1.0 || a==1.0 || s==1.0 || d==1.0) data = vec4(0.0);\n        data += vec4(color/vec3(255.0), 4.0);\n\n        fragColor = data;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}