{"ver":"0.1","info":{"id":"NdlSDn","date":"1618516559","viewed":83,"name":"rotate and translate","username":"leopard","description":"I had huge problems with rotate and couldn't find any tutorial that would show how to move multiple objects, so had to try by my self, tested multiple different rotation functions from jcant0n and IQ, I found 'jcantos' 's was easier to use.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["kokeilu"],"hasliked":0,"parentid":"NdjGRd","parentname":"tesmi 3d basic shapes"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.02\n#define PI 3.1415\n\n//from https://www.shadertoy.com/view/llsSWr\nvec2 rotate( vec2 vector, float angle )\n{\n\tvec2 sincos = vec2( sin(angle), cos(angle) );\n\treturn vec2( vector.x * sincos.y - vector.y * sincos.x, \n\t\t\t\tvector.x * sincos.x + vector.y * sincos.y );\n}\n\n\n//from IQ\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\n\nvec3 translate(vec3 p, vec3 t)\n{\n\treturn p - t;\n}\n\n\n\nfloat dBox(vec3 p, vec3 s){\n\n    return length(max(abs(p)-s,0.));\n}\n\nfloat GetDist(vec3 p) {\n    \n\n    float planeDist = p.y+2.;\n\n    float dist_to_0=8.; //center of car rotates around 0.0 with this distance\n    \n    //grp_translate sets group placement\n    vec3 grp_translate = vec3(sin(iTime)*dist_to_0, 0, cos(iTime)*dist_to_0);\n    float grp_angle  = iTime+PI/2.;\n    \n    float dist_to_center=8.;\n    float rengas =3.;\n    float text_tmp;\n    \n    //car body\n    vec3 q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(0,1,0));\n    float body = dBox(q-vec3(0.0, 0.0, 0.),vec3(1,1,5));\n    text_tmp = abs(dot(sin(q*6.),cos(q.yzx*6.))); //texture\n    body-=text_tmp*0.1;\n\n    \n    q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(2,0,2));\n    q.yz=rotate(q.yz,-grp_angle*rengas);//right front wheel rotation\n    float bd1 = dBox(q-vec3(0., 0.0, 0.),vec3(1));\n    text_tmp = abs(dot(sin(q*6.),cos(q.xzy*6.))); //texture\n    bd1-=text_tmp*0.1;\n    \n    q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(-2,0,2));\n    q.yz=rotate(q.yz,-grp_angle*rengas*1.5);//left front wheel rotation\n    float bd2 = dBox(q-vec3(0., 0.0, 0.),vec3(1));\n    text_tmp = abs(dot(sin(q*6.),cos(q.xzy*6.))); //texture\n    bd2-=text_tmp*0.1;\n    \n    q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(2,0,-2));\n    q.yz=rotate(q.yz,-grp_angle*rengas); //right rear wheel rotation\n    float bd3 = dBox(q-vec3(0., 0.0, 0.),vec3(1));\n    text_tmp = abs(dot(sin(q*6.),cos(q.xzy*6.))); //texture\n    bd3-=text_tmp*0.1;\n    \n    q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(-2,0,-2));\n    q.yz=rotate(q.yz,-grp_angle*rengas*1.5); //left rear wheel rotation\n    float bd4 = dBox(q-vec3(0., 0.0, 0.),vec3(1));\n    text_tmp = abs(dot(sin(q*6.),cos(q.xzy*6.))); \n    bd4-=text_tmp*0.1;\n\n    q = p;\n    //q=translate(q,group);\n    //q.xz=rotate(q.xz,kulma);\n    q=translate(q,vec3(0,0,0));\n    float palikka = dBox(q-vec3(0., 0.0, 0.),vec3(1,1,1));\n    \n    float d = planeDist;\n    \n    d = min(d, body*0.6); \n    d = min(d, bd1);\n    d = min(d, bd2);\n    d = min(d, bd3);\n    d = min(d, bd4);\n    d = min(d, palikka);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        \n        return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    \n    vec3 lightPos = vec3(4,5,-2);\n\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n,l),0.,1.);\n\n    float d = RayMarch(p+n*SURF_DIST*1.5,l);\n\n\n    if(d<length(lightPos-p)){\n        dif *=0.7;\n    }\n\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0.,3,-17);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro+rd*d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    col += 0.2* GetNormal(p);\n\n    // Output to screen\n    fragColor = vec4(col,0.4);\n}","name":"Image","description":"","type":"image"}]}