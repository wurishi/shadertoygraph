{"ver":"0.1","info":{"id":"ll3yRr","date":"1531246863","viewed":1599,"name":"Palindrome startrails","username":"zproxy","description":"https://www.shadertoy.com/view/XsX3Dr\n","likes":29,"published":1,"flags":1,"usePreview":0,"tags":["pyramid","startrails"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/XsX3Dr\n\n#define kRaymarchMaxIter 226\n\n//#define LOW_QUALITY\n\n//#define OVERRIDE_TIME\n\nconst vec3 cSkyColourTop = vec3(0.2, 0.05, 0.15) * 0.5;\nconst vec3 cSkyColourHorizon = vec3(0.4, 0.1, 0.01) * 2.0;\nconst vec3 cSunScatteringColour = vec3(1.0, 0.01, 0.005) * 1.0;\n\nconst vec3 cFogColour = vec3(0.4, 0.05, 0.01) * 2.0;\n\nconst vec3 cSunColour = vec3(1.0, 0.01, 0.005) * 5.0;\nvec3 vSunDirection = normalize(vec3(-0.3, 0.2, -0.7));\n\nconst vec3 cSunLightColour = vec3(1.0, 0.15, 0.025) * 1.0;\nconst vec3 cAmbientLight = vec3(0.4, 0.1, 0.01) * 0.2;\n\nconst vec3 vPortalPos = vec3(0.0, 2.7, 20.0);\n\nconst float fSequenceLength = 18.0;\n\nmat3 g_mPortalRotation;\nfloat g_fTime = 0.0;\nfloat g_fSceneTime = 0.0;\nfloat g_ReverseEffectEnabled= 0.0;\n\nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n    float fStartDistance;\n    float fLength;\n};\n\nstruct C_HitInfo\n{\n    vec3 vPos;\n    float fDistance;\n    float fObjectId;\n};\n    \nstruct C_Surface\n{\n    vec3 vNormal; \n};\n\nstruct C_Material\n{\n    vec3 cAlbedo;\n};\n\t\n/////////////////////////////////////\n// Distance Field CSG\n// These carry with them the material parameters in y\n\nvec2 DistCombineUnion( const in vec2 v1, const in vec2 v2 )\n{\n    //if(v1.x < v2.x) return v1; else return v2;\n    return mix(v1, v2, step(v2.x, v1.x));\n}\n\n/////////////////////////////////////\n// Scene Description \n\nfloat GetRayFirstStep( const in C_Ray ray )\n{\n\treturn ray.fStartDistance;\n}\n\nfloat hash( const in float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat smoothnoise(const in float o) \n{\n\tfloat p = floor(o);\n\tfloat f = fract(o);\n\t\t\n\tfloat n = p;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\t\n\tfloat f2 = f * f;\n\tfloat f3 = f2 * f;\n\t\n\tfloat t = 3.0 * f2 - 2.0 * f3;\n\t\n\treturn mix(a, b, t);\n}\n\nfloat smoothnoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\tfloat c = hash(n+ 57.0);\n\tfloat d = hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat du = dt.x;\t\n\tfloat v = t.y;\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n\t\n\t//float dx = (b-a)*du + (a-b+d-c)*du*v;\n\t//float dy = (c-a)*dv + (a-b+d-c)*u*dv;\n\t\n\treturn res;\n}\n\nfloat smoothnoise(const in vec3 o) \n{\n\tvec3 p = floor(o);\n\tvec3 fr = fract(o);\n\t\t\n\tfloat n = p.x + p.y*101.0 + p.z * 4001.0;\n\n\tfloat a = hash(n+   0.0);\n\tfloat b = hash(n+   1.0);\n\tfloat c = hash(n+ 101.0);\n\tfloat d = hash(n+ 102.0);\n\tfloat e = hash(n+4001.0);\n\tfloat f = hash(n+4002.0);\n\tfloat g = hash(n+4102.0);\n\tfloat h = hash(n+4103.0);\n\t\n\tvec3 fr2 = fr * fr;\n\tvec3 fr3 = fr2 * fr;\n\t\n\tvec3 t = 3.0 * fr2 - 2.0 * fr3;\n\t\t\n\treturn mix(\n\t\t\t    mix( mix(a,b, t.x),\n\t\t             mix(c,d, t.x), t.y),\n\t\t\t    mix( mix(e,f, t.x),\n\t\t             mix(g,h, t.x), t.y),\n\t\t\tt.z);\n}\n\nfloat GetDistanceGround( const in vec3 vPos )\n{\n\tfloat fResult = vPos.y;\n\t\n\tfloat h = smoothnoise(vPos.xz * 0.1);\t\t\n\tfloat fRidgePos = vPos.x + h * 10.0;\n\t\n\tfloat s = sin(fRidgePos);\n\ts *= sin(vPos.z * 0.1 + vPos.x * 0.2);\n\ts = s * 0.5 + 0.5;\t\n\ts = sqrt(s);\n\t\n\tvec2 vFlattenPos = abs(vPos.xz);\n\tfloat fFlattenDist = max(vFlattenPos.x, vFlattenPos.y);\n\tfloat fFlatten = smoothstep(50.0, 65.0, fFlattenDist);\n\tfResult += mix(0.0, s, fFlatten);\n\n\t#ifndef LOW_QUALITY\n\tfloat s2= sin(fRidgePos * 40.0);\n\ts2 = s2 * 0.5 + 0.5;\t\n\tfResult += s2 * s * 0.01;\n\t#endif\n\n\treturn fResult;\n}\n\nvec2 GetDistancePyramid(const in vec3 vPos, const in float fWorldNoise)\n{\n\tvec2 vResult;\n\tvResult.y = 2.0; // object id\n\n\tfloat fPyramidSize = 50.0;\n\t\n\tvec3 vStepPos = vPos;\n\tvStepPos.y -= fPyramidSize;\n\tvStepPos.xz = abs(vStepPos.xz) - 0.5;\n\tvec2 vStepOffset = floor((vStepPos.y - vStepPos.xz) * 0.5 + 0.5);\n\tfloat fStepOffset = min(vStepOffset.x, vStepOffset.y);\n\t\n\tvStepPos.x += fStepOffset;\t\n\tvStepPos.y -= fStepOffset;\n\tvStepPos.z += fStepOffset;\n\n\tvec3 vClosest = min(vStepPos.xyz, vec3(0.0));\t\n\t\n\tvResult.x = length(vStepPos - vClosest);\t\n\t\n\tfloat fFlatSide = (vPos.y + max(abs(vPos.x), abs(vPos.z))) - 50.0;\n\tvResult.x = mix(vResult.x, fFlatSide, 0.3);\n\t\t\n\tconst float fTunnelHeight = 4.0;\n\tconst float fTunnelWidth = 1.0;\n\tfloat fTunnelInner = min(min(fTunnelWidth - abs(vPos.x), fTunnelHeight - vPos.y), 35.0-vPos.z);\n\n\tconst float fTunnelThickness = 1.5;\n\tconst float fTunnelExtent = 2.0;\n\tfloat fTunnelOuter = max(abs(vPos.x) - (fTunnelWidth + fTunnelThickness), vPos.y - (fTunnelHeight + fTunnelThickness));\n\tfTunnelOuter = max(fTunnelOuter, vPos.y + abs(vPos.z + fTunnelExtent) - (fPyramidSize));\n\t\n\tvResult.x = min(vResult.x, fTunnelOuter);\n\tvResult.x = max(vResult.x, fTunnelInner);\n\t\n\tfloat fRoomWallDist = (vPos.y + max(abs(vPos.x), abs(vPos.z - 20.0)));\n\tfloat fInnerRoom = 20.0 - fRoomWallDist;\n\tvResult.x = max(vResult.x, fInnerRoom);\n\t\n\tvResult.x -= 0.1 - clamp(fWorldNoise, 0.0, 1.0) * 0.1;\t\n\t\n\treturn vResult;\n}\n\nvec2 GetDistancePyramids( const in vec3 vPos )\n{\n\t#ifdef LOW_QUALITY\n\tfloat fWorldNoise = 0.0;\n\t#else\n\tfloat fWorldNoise = smoothnoise(vPos * 2.0);\n\t#endif\n\t\t\n\tfloat fHeight = 0.0;\n\tvec3 vPyramidPos = vPos;\n\tif(vPyramidPos.x > 50.0)\n\t{\n\t\tvPyramidPos.x -= 100.0;\n\t\tvPyramidPos.z += 100.0;\n\t\tfHeight = 10.0;\n\t}\n\n\tif(vPyramidPos.x < -70.0)\n\t{\n\t\tvPyramidPos.x += 100.0;\n\t\tvPyramidPos.z += 200.0;\n\t\tfHeight = 20.0;\n\t}\n\t\n\tvPyramidPos.y = max(vPyramidPos.y + fHeight, fHeight);\n\t\n\tvec2 vPyramidDistance = GetDistancePyramid( vPyramidPos, fWorldNoise );\t\n\t\n\treturn vPyramidDistance;\n}\n\n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec2 GetDistanceScene( const in vec3 vPos, const in float fShadow )\n{          \n    vec2 vResult = vec2(10000.0, -1.0);\n    \n\tfloat fScale = 1.0;\n\tvec3 vPyramidPos = vPos;\n\tvec3 vSmallPyramidPos = vPyramidPos - vec3(0.0, 0.0, 20.0);\n\tvec3 vAbsPos = abs(vSmallPyramidPos);\t\n\tif( max(vAbsPos.x, vAbsPos.z) + vSmallPyramidPos.y < 15.0 )\n\t{\n\t\tvSmallPyramidPos.y -= 0.5;\n\t\tfScale = 30.0;\n\t\tvPyramidPos = vSmallPyramidPos * fScale;\n\t}\t\n\t\n\tvec2 vPyramidDistance = GetDistancePyramids( vPyramidPos );\t\n\tvPyramidDistance.x /= fScale;\n\t\n\tfloat fRoomWallDist = (vPos.y + max(abs(vPos.x), abs(vPos.z - 17.0)));\n\tfloat fPedistalDist = max(fRoomWallDist - 7.0, vPos.y - 0.5);\n\tvPyramidDistance.x = min(vPyramidDistance.x, fPedistalDist);\n\t\n\tvec2 vFloorDistance = vec2(GetDistanceGround( vPos ), 1.0);\n\tvResult = vFloorDistance;\n\n\tvResult = DistCombineUnion(vResult, vPyramidDistance);\n\t\n\tif(fShadow > 0.5)\n\t{\n\t\tvec2 vPortalDistance = vec2( (length(vPos - vPortalPos) - 0.1), 3.0);\n\t\tvResult = DistCombineUnion(vResult, vPortalDistance);\n\t}\n\t\n    return vResult;\n}\n\nC_Material GetObjectMaterial( const in C_HitInfo hitInfo )\n{\n    C_Material mat;  \n        \n\tmat.cAlbedo = vec3(0.8, 0.5, 0.3);\n\t\n\tif(hitInfo.fObjectId > 1.0)\n\t{\n    \tmat.cAlbedo = vec3(1.0, 0.8, 0.5);\n\t}\n\telse if(hitInfo.fObjectId > 2.0)\n\t{\n\t\tmat.cAlbedo = vec3(1.0, 1.0, 1.0);\n\t}\n\n    return mat;\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\n\n    float fBlend = clamp(vDir.y, 0.0, 1.0);\n\tfBlend = 1.0 - fBlend;\n\t\n\t\n    vec3 vResult =  mix(cSkyColourHorizon, cSkyColourTop, 1.0 - fBlend * fBlend * fBlend);\n\t\t\n\tfloat fSunDot = max(dot(vDir, vSunDirection), 0.0);\n\tvResult += (pow(fSunDot, 500.0) + fSunDot * fSunDot) * cSunScatteringColour;\n\t\n\tfloat fSun = clamp(5000.0 * (fSunDot - 0.999), 0.0, 1.0);\t\n\tvResult = vResult + cSunColour * fSun;\n\t\n\treturn vResult;\n}\n\n////////////////////////////////\n// Raymarching \n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    // tetrahedron normal\n    const float fDelta = 0.025;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetDistanceScene( vPos + vOffset1, 1.0 ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2, 1.0 ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3, 1.0 ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4, 1.0 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\n#define kRaymarchEpsilon 0.001\n\n// This is an excellent resource on ray marching -> https://iquilezles.org/articles/distfunctions\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter, const in float fShadow )\n{        \n    result.fDistance = GetRayFirstStep( ray );\n    result.fObjectId = 0.0;\n        \n    for(int i=0;i<=kRaymarchMaxIter;i++)              \n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        vec2 vSceneDist = GetDistanceScene( result.vPos, fShadow );\n        result.fObjectId = vSceneDist.y;\n        \n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))\n        {\n            break;\n        }                        \n\n        result.fDistance = result.fDistance + vSceneDist.x; \n    }\n\n\n    if(result.fDistance >= ray.fLength)\n    {\n        result.fDistance = 1000.0;\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        result.fObjectId = 0.0;\n    }\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = GetDistanceScene( aopos, 0.0 ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 1.0*totao, 0.0, 1.0 );\n}\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.25; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec3 startrails(in vec3 rd)\n{\n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.5)));\n\n    vec3 col = col0;\n\n    for (int i = -120; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.5 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\n\nvec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material, float fInsideDist)\n{\n    vec3 cScene;\n    \n    vec3 vAmbientLight;\n\t\t\t\n\tvec3 vDiffuseLight = vec3(0.0);\n\n\tvec3 vToLight;\n\tvec3 cLightColour;\n\t\n\tfloat fPortalOn = smoothstep(9.0, 9.5, g_fTime);\n\t\n\tif(fInsideDist > 0.0)\n\t{\n\t\tvToLight = vSunDirection * 100.0;\n\t\tcLightColour = cSunLightColour;\n\t\tvAmbientLight = cAmbientLight;\n\t}\n\telse\n\t{\n\t\tvec3 vLightPos;\t\t\n\t\t\n\t\t// apply point light\n\t\t{\n\t\t\t\n\t\t\tif((hitInfo.vPos.z - hitInfo.vPos.y) < 0.01)\n\t\t\t{\n\t\t\t\tfloat fLightId = floor(min(max(hitInfo.vPos.z, -50.0), 0.0) * 0.1 + 0.5);\n\t\t\t\tvLightPos = vec3(0.5 * sign(hitInfo.vPos.x), 2.5, 10.0 * fLightId - 0.5);\t\t\n\t\t\t\t\n\t\t\t\tfloat fFlicker = (smoothnoise(fLightId + iTime * 500.0) * 0.5 + 0.5);\n\t\t\t\tcLightColour = vec3(1.0, 0.5, 0.1) * fFlicker * 0.01;\n\t\t\t\tvAmbientLight = cAmbientLight * 0.01;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvLightPos = vPortalPos;\n\t\t\t\tvec3 vToLight = vLightPos - hitInfo.vPos;\n\t\t\t\t\n\t\t\t\t//cLightColour = textureLod(iChannel0, vToLight * g_mPortalRotation, 0.0).rgb;\n                //cLightColour = startrails(  vToLight * g_mPortalRotation ).rgb;\n                cLightColour = startrails(  vToLight  ).rgb;\n                \n\t\t\t\t//cLightColour = (1.0 - cLightColour*cLightColour)*  10.0 * vec3(0.0, 1.0, 0.0);\n                cLightColour = (  cLightColour*cLightColour)*  10.0 * vec3(0.0, 1.0, 0.0);\n                //cLightColour = 10.0 * vec3(0.0, 1.0, 0.0);\n\n\n\t\t\t\t//float fFft = smoothstep(0.7, 0.9, textureLod(iChannel3, vec2(0.018, 0.0), 0.0).r);\n\t\t\t\t//fFft = fFft * fFft;\n\t\t\t\t//cLightColour = vec3(1.0, 0.2, 0.1) * fFft + cLightColour * fPortalOn;\n                //cLightColour =  0.1*vec3(1.0, 0.2, 0.1) + cLightColour  ;\n                cLightColour =  0.1*vec3(0.0, 10.2, 0.0) + cLightColour  ;\n\t\t\t\t\n\t\t\t\tvAmbientLight = vec3(1.0, 0.2, 0.1) * 0.0001;\t\t\t\t\t\t\t\t\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\t\n\t\tvToLight = vLightPos - hitInfo.vPos;\n\t\tfloat fDist2 = dot(vToLight, vToLight);\n\t\tcLightColour /= fDist2;\n\t}\n\n\tC_Ray shadowRay;\n\tshadowRay.vOrigin = hitInfo.vPos;\n\tshadowRay.fLength = length(vToLight);\n\tshadowRay.vDir = normalize(vToLight);\n\tshadowRay.fStartDistance = dot(shadowRay.vDir, surface.vNormal);\n\tC_HitInfo shadowHitInfo;\n\tRaymarch(shadowRay, shadowHitInfo, 64, 0.0);\n\t\n\tfloat fShadow = 1.0;\n\tif(shadowHitInfo.fDistance < 90.0)\n\t{\n\t\tfShadow = 0.0;\n\t}\n\t\n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDiffuseLight = clamp(dot(surface.vNormal, vLightDir), 0.0, 1.0) * fShadow;\n\t\n\tvDiffuseLight += fDiffuseLight * cLightColour;\n\t\n\tfloat fAmbientOcclusion = calcAO(hitInfo.vPos, surface.vNormal);\n\t\n    vDiffuseLight += vAmbientLight * fAmbientOcclusion;\n              \n    vec3 vDiffuseReflection = vDiffuseLight * material.cAlbedo;              \n\n    cScene = vDiffuseReflection;\n    \n    return cScene;\n}\n\nvec3 GetSceneColour( const in C_Ray ray )\n{                                                          \n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 256, 1.0);\n                \n    vec3 cScene;\n\n    if(intersection.fObjectId < 0.5)\n    {\n\t\tcScene = GetSkyColour(ray.vDir);\n    }\n    else\n    {\n        C_Surface surface;\n        \n        surface.vNormal = GetSceneNormal(intersection.vPos);\n\n\t\tif(intersection.fObjectId > 2.5)\n\t\t{\n\t\t\t// flip portal light source surface\n\t\t\tsurface.vNormal = -surface.vNormal;\n\t\t}\n\n        C_Material material = GetObjectMaterial(intersection);\n\n\t\tvec3 vAbsPos = abs(intersection.vPos);\n\t\tfloat fInsideDist = (max(vAbsPos.x, vAbsPos.z) + vAbsPos.y) - 46.0;\n\n        // apply lighting\n        cScene = ShadeSurface(ray, intersection, surface, material, fInsideDist);\t\t\t\t\t\n\t\t\n\t\tif( fInsideDist > 0.0 )\n\t\t{\n\t\t\t// apply fog\t\n\t\t\tfloat fNoise = smoothnoise((intersection.vPos.xz) * 0.1 + g_fSceneTime * 10.0);\n\t\t\tfloat fDensity= 0.04;\n\t\t\tfloat fHeightFalloff = 0.5;\n\t\t\t\n\t\t\tfloat fogAmount = fDensity * exp(-ray.vOrigin.y*fHeightFalloff) * (1.0-exp(-intersection.fDistance*ray.vDir.y*fHeightFalloff ))/ray.vDir.y;\n\t\t\tfogAmount *= (0.5 + fNoise * 0.5);\n\t\t\tcScene = mix(cScene, cFogColour, fogAmount);\n\t\t}\n    }\n\t\n    return cScene;\n}\n\nfloat kFarClip = 1000.0;\n\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, in vec2 fragCoord, out C_Ray ray)\n{\n    vec2 vUV = ( fragCoord.xy / iResolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n\t\n    float fRatio = iResolution.x / iResolution.y;\n    vViewCoord.y /= fRatio;                          \n\n\tvViewCoord *= 0.75;\n\t\n    ray.vOrigin = vPos;\n\t\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n        \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); \n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;      \n}\n\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, in vec2 fragCoord, out C_Ray ray)\n{\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\t\n}\n\n\nvoid GetCameraPosAndTarget( float fCameraIndex, out vec3 vCameraPos, out vec3 vCameraTarget )\n{\n\tfloat fCameraCount = 14.0;\n\tfloat fCameraIndexModCount = max(min(fCameraIndex, fCameraCount), 0.0);\n\n    \t\tvCameraPos = vec3(10.0 + cos(iTime*0.1) * 2.0, 6.0, sin(iTime*0.1)*2.0 + 30.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n    return;\n    \n\tif(fCameraIndexModCount < 0.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 3.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(-10.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 1.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 4.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(-10.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 2.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 3.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -4.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 3.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 20.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -8.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 4.5)\n\t{\n\t\tvCameraPos = vec3(500.0, 20.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 5.5)\n\t{\n\t\tvCameraPos = vec3(500.0, 3.0, 500.0) + vec3(100.0, 0.0, 0.0);\n\t\tvCameraTarget = vCameraPos + vec3(10.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 6.5)\n\t{\n\t\tvCameraPos = vec3(500.0, 5.0, 500.0) + vec3(100.0, 0.0, 0.0);\n\t\tvCameraTarget = vec3(0.0, 10.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 7.5)\n\t{\n\t\tvCameraPos = vec3(-30.0, 20.0, -200.0);\n\t\tvCameraTarget = vec3(0.0, 10.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 8.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 5.0, -100.0);\n\t\tvCameraTarget = vec3(0.0, 0.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 9.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 1.0, 5.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 10.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 2.0, 5.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 11.5)\n\t{\n\t\tvCameraPos = vec3(10.0, 5.0, 30.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 12.5)\n\t{\n\t\tvCameraPos = vec3(10.0, 6.0, 30.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 13.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 6.0, 20.0);\n\t\tvCameraTarget = vec3(0.0, -1.0, 19.0);\n\t}\n\telse\n\t{\n\t\tvCameraPos = vec3(0.0, 2.0, 20.0);\n\t\tvCameraTarget = vec3(0.0, -10.0, 19.0);\n\t}\n}\n\nvec3 BSpline( const in vec3 a, const in vec3 b, const in vec3 c, const in vec3 d, const in float t)\n{\n\tconst mat4 mSplineBasis = mat4( -1.0,  3.0, -3.0, 1.0,\n\t\t\t\t\t\t\t         3.0, -6.0,  0.0, 4.0,\n\t\t\t\t\t\t\t        -3.0,  3.0,  3.0, 1.0,\n\t\t\t\t\t\t\t         1.0,  0.0,  0.0, 0.0) / 6.0;\t\n\t\n\tfloat t2 = t * t;\n\tvec4 T = vec4(t2 * t, t2, t, 1.0);\n\t\t\n\tvec4 vWeights = T * mSplineBasis;\n\t\n\tvec3 vResult;\n\n\tvec4 vCoeffsX = vec4(a.x, b.x, c.x, d.x);\n\tvec4 vCoeffsY = vec4(a.y, b.y, c.y, d.y);\n\tvec4 vCoeffsZ = vec4(a.z, b.z, c.z, d.z);\n\t\n\tvResult.x = dot(vWeights, vCoeffsX);\n\tvResult.y = dot(vWeights, vCoeffsY);\n\tvResult.z = dot(vWeights, vCoeffsZ);\n\t\n\treturn vResult;\n}\n\nvoid GetCamera(out vec3 vCameraPos, out vec3 vCameraTarget)\n{\n\tfloat fCameraGlobalTime = g_fSceneTime;\t\t\n\t\n\tfloat fCameraTime = fract(fCameraGlobalTime);\n\tfloat fCameraIndex = floor(fCameraGlobalTime);\n\t\n\tvec3 vCameraPosA;\n\tvec3 vCameraTargetA;\n\tGetCameraPosAndTarget(fCameraIndex, vCameraPosA, vCameraTargetA);\n\t\n\tvec3 vCameraPosB;\n\tvec3 vCameraTargetB;\n\tGetCameraPosAndTarget(fCameraIndex + 1.0, vCameraPosB, vCameraTargetB);\n\t\n\tvec3 vCameraPosC;\n\tvec3 vCameraTargetC;\n\tGetCameraPosAndTarget(fCameraIndex + 2.0, vCameraPosC, vCameraTargetC);\n\t\n\tvec3 vCameraPosD;\n\tvec3 vCameraTargetD;\n\tGetCameraPosAndTarget(fCameraIndex + 3.0, vCameraPosD, vCameraTargetD);\n\t\n\tvCameraPos = BSpline(vCameraPosA, vCameraPosB, vCameraPosC, vCameraPosD, fCameraTime);\n\tvCameraTarget = BSpline(vCameraTargetA, vCameraTargetB, vCameraTargetC, vCameraTargetD, fCameraTime);\n}\n\n\nvec3 Tonemap( const in vec3 cCol )\n{\n    return sqrt(1.0 - exp(-cCol));\n}\n\nfloat GetTime()\n{\n//\tfloat fTime = iChannelTime[3] / 8.0;\n\tfloat fTime = iTime / 8.0;\n\n    #ifdef OVERRIDE_TIME\n\tfTime = iMouse.x * fSequenceLength / iResolution.x;\n\t#endif\n\t\n\t// hack the preview image\n\tif(iTime == 10.0)\n\t{\n\t\tfTime = 30.0 / 8.0;\n\t}\n\t\n\treturn mod(fTime, fSequenceLength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\tg_fTime = GetTime();\n\n\t// (noisy) motion blur by dithering time per pixel!\n\t//g_fTime += (texture(iChannel1, (fragCoord.xy / 64.0) + 0.5).r - 0.5) * 0.005;\t\n\t\n\tfloat fTimeWarp = 0.0;\n\t\n\tg_ReverseEffectEnabled = smoothstep(13.0, 14.0, g_fTime);\n\t\n\t// During the reverse sequence time is further backward at the edge of the screen\n\tg_fSceneTime = g_fTime;\n\tif(g_fSceneTime > 13.0)\n\t{\n\t\tfloat t = (g_fSceneTime - 13.0);\n\t\t\n\t\tfloat l = length(vUV);\n\t\tfTimeWarp = l * l * g_ReverseEffectEnabled;\n\t\tt += fTimeWarp * 0.2;\n\t\t\n\t\tg_fSceneTime = 13.0 - t * t;\n\n\t}\t\n\n\tg_fSceneTime = max(g_fSceneTime, 0.0);\n\t\n\tfloat a = (g_fSceneTime - 8.0);\n\ta = a * a * a;\n\tg_mPortalRotation = mat3(sin(a), 0.0, cos(a), \n\t\t\t\t\t  0.0, 1.0, 0.0,\n\t\t\t\t\t  cos(a), 0.0, -sin(a));\n \n    vec3 vCameraPos;\n    vec3 vCameraInterest;\n\tGetCamera(vCameraPos, vCameraInterest);\n\t\n\tC_Ray ray;\n    GetCameraRayLookat( vCameraPos, vCameraInterest, fragCoord, ray);\n\n    vec3 cScene = GetSceneColour( ray );  \n    \n\tfloat fExposure = 1.5;    \n\t\n\tfExposure = mix(fExposure, 0.3, smoothstep(3.45, 3.6, g_fTime));\n\tfExposure = mix(fExposure, 1.0, smoothstep(5.35, 5.5, g_fTime));\n\tfExposure = mix(fExposure, 20.0, smoothstep(7.6, 7.8, g_fTime));\n\n\tfExposure = mix(fExposure, 1.5, smoothstep(15.0, 17.0, g_fTime));\n\t\n\t// vignette\n\tfloat fDist = dot(vUV, vUV);\n\tfDist = fDist * fDist;\n\tfloat fAmount = 1.0 / (fDist + 1.0);\n\t//cScene = cScene * fAmount;\t\n\t\n\tvec3 cColour = Tonemap(cScene * fExposure);\n\n    fragColor = vec4(cColour, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tvec2 vUV = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\tg_fTime = GetTime();\n\n\t// (noisy) motion blur by dithering time per pixel!\n\t\n    //g_fTime += (texture(iChannel1, (fragCoord.xy / 64.0) + 0.5).r - 0.5) * 0.005;\t\n\t\n\tfloat fTimeWarp = 0.0;\n\t\n\tg_ReverseEffectEnabled = smoothstep(13.0, 14.0, g_fTime);\n\t\n\t// During the reverse sequence time is further backward at the edge of the screen\n\tg_fSceneTime = g_fTime;\n\tif(g_fSceneTime > 13.0)\n\t{\n\t\tfloat t = (g_fSceneTime - 13.0);\n\t\t\n\t\tfloat l = length(vUV);\n\t\tfTimeWarp = l * l * g_ReverseEffectEnabled;\n\t\tt += fTimeWarp * 0.2;\n\t\t\n\t\tg_fSceneTime = 13.0 - t * t;\n\n\t}\t\n\n\tg_fSceneTime = max(g_fSceneTime, 0.0);\n\t\n\tfloat a = (g_fSceneTime - 8.0);\n\ta = a * a * a;\n\tg_mPortalRotation = mat3(sin(a), 0.0, cos(a), \n\t\t\t\t\t  0.0, 1.0, 0.0,\n\t\t\t\t\t  cos(a), 0.0, -sin(a));\n \n    vec3 vCameraPos;\n    vec3 vCameraInterest;\n\tGetCamera(vCameraPos, vCameraInterest);\n\t\n    fragRayOri += vCameraPos;\n    \n\tC_Ray ray;\n    ray.vOrigin = fragRayOri;\n    ray.vDir = fragRayDir;\n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;\n    //GetCameraRayLookat( vCameraPos, vCameraInterest, fragCoord, ray);\n\n    vec3 cScene = GetSceneColour( ray );  \n    \n\tfloat fExposure = 1.5;    \n\t\n\tvec3 cColour = Tonemap(cScene * fExposure);\n\n    fragColor = vec4(cColour, 1.0 );    \n}","name":"Image","description":"","type":"image"}]}