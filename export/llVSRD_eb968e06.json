{"ver":"0.1","info":{"id":"llVSRD","date":"1483397550","viewed":115,"name":"Evidence","username":"Draedrus","description":"An eye ball","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["eye","brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * author: Pierre-Marie Plans\n * mail: pierre.plans@gmail.com\n **/\n\n#define CAMPOS vec3(0.0, 0.0, -5.0)\n#define LOOKAT vec3(0.0, 0.0, 0.0)\n#define FAR 5.0\n#define NEAR 0.1\nvec3 lPos = vec3(0.0, 2.0, 0.0);\nvec3 lPos2 = vec3(2.0, 0.0, 0.0);\nvec3 eyeLP;\nvec3 eyeLD = normalize(vec3(1.0, 0.0, 1.0));\n\n\nstruct Camera {\n    mat3 m;\n    mat3 mI;\n};\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\nfloat hash1D(float x)\n{\n \treturn fract(sin(x*13.14434)*1.40503503);   \n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 10.4294, 42.40594))*13.4959451);    \n}\n\n#define HASHC(x,d) fract(dot(x, d)*0.124243434)\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n        \tfor( int k=-1; k<=1; k++ ) {\n                vec3 p = vec3(i, j, k);\n                float h = hash3D(fl+p);\n                vec3 vp = p-fr+h;\n                float d = dot(vp, vp);\n\n                res +=1.0/pow(d, 8.0);\n            }\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(hash1D(wx+0.0)     ,      hash1D(wx+1.0), f.x),\n                mix(hash1D(wx+0.0+winy), \thash1D(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(hash1D(wx+0.0+winz)     ,      hash1D(wx+1.0+winz), f.x),\n                mix(hash1D(wx+0.0+winy+winz), hash1D(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\nfloat fbm3D(vec3 p)\n{\n    float total = 0.0;\n    total  = 0.5000* smoothNoise(p); p = p*2.0;\n    total += 0.2500* smoothNoise(p); p = p*2.0;\n    total += 0.1250* smoothNoise(p); p = p*2.0;\n    total += 0.0625* smoothNoise(p);\n    return total;\n}\n\n/******************\n * RENDERING\n ******************/\n\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.000001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(roughness, NdotH);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)*max(0.0, dot(N, L))+Ks*specularColor*spec) * Oi;\n}\n\n// the camera construction method is inspired by the one from IQ\nCamera setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n    Camera cam;\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    cam.m = mat3( cu, cv, cw );\n    cam.mI = mat3(\n        \t\tcu.x, cv.x, cw.x,\n        \t\tcu.y, cv.y, cw.y,\n        \t\tcu.z, cv.z, cw.z);\n    return cam;\n}\n\nfloat fresnel(vec3 I, vec3 N, float B, float S, float E)\n{\n    return B+S*pow(max(0.0, 1.0+dot(I,N)),E);\n}\n\nvec3 rendering(float depth, vec3 ro, vec3 rd, vec2 uv, mat3 M, mat3 IM)\n{\n    #define BLACK vec3(0.0)\n    #define WHITE vec3(1.0)\n    #define RED vec3(1.0, 0.0, 0.0)\n    #define DARKBLUE vec3(0.0, 0.01, 0.4)\n    #define BLUE\tvec3(0.0, 0.0, 0.9)\n    #define YELLOW vec3(0.6, 0.6, 0.2)\n    vec3 p = vec3(ro+rd*depth);\n    vec3 N = normalize(p-eyeLP);\n    vec3 L = M*normalize(p-lPos);\n    vec3 L2 = M*normalize(p-lPos2);\n    vec3 color = vec3(0.0);\n    if(depth>0.0)\n    {\n        float eyeLens = floor(1.0-(clamp(pow(max(0.0, dot(N, eyeLD)), 128.0), 0.4, 1.0)-0.4));\n        float eyeLensAA = 1.0-(clamp(pow(max(0.0, dot(N, eyeLD)), 64.0), 0.0, 0.75)+0.25);\n        float eyeIrisDotP = max(0.0, min(1.0, pow(max(0.0, dot(N, eyeLD))+0.5, 6.0)-8.0));\n        float eyeIrisMask = ceil(clamp(eyeIrisDotP, 0.4, 1.0)-0.4);\n        float eyeIrisInternalMask = (max(0.0, min(1.0, pow(max(0.0, dot(N, eyeLD))+0.02, 6.0)-0.99)));\n        float retinaEffectMask = max(0.0, (pow(eyeIrisDotP+0.6, 6.0)-0.0));\n        // angle Iris computation\n        float iD = 0.0, iDump = 0.0;\n    \tfloat d = IntersectSphere(CAMPOS, normalize(eyeLP-CAMPOS), eyeLP, 1.0, iD, iDump);\n        \n        float iDUp = 0.0;\n    \td = IntersectSphere(CAMPOS, normalize(eyeLP+vec3(0.0, 0.1, 0.0)-CAMPOS), eyeLP, 1.0, iDUp, iDump);\n        vec3 iOrigin = CAMPOS+normalize(eyeLP-CAMPOS)*iD;\n        vec3 iUp = CAMPOS+normalize(eyeLP+vec3(0.0, 0.1, 0.0)-CAMPOS)*iDUp;\n        \n        /*vec3 xAxis = normalize(p-iOrigin);\n        vec3 zAxis = normalize(iUp-iOrigin);\n        float angleIris = length(p-iD)/5.0;//acos(dot(normalize(p.xyz-iOrigin), normalize(vec3(0.0, 0.0, 1.0)-iOrigin)));\n        float radialIrisMask = cos(angleIris*10.0)*cos(angleIris)+sin(angleIris*10.0)*sin(angleIris);\n        vec3 irisColor = mix(DARKBLUE, YELLOW, radialIrisMask);\n        color = color*eyeLens;*/\n        vec3 xAxis = IM*(p-iOrigin);\n        vec2 x2D = xAxis.xy/xAxis.z;\n        vec3 zAxis = IM*(iUp-iOrigin);\n        vec2 z2D = zAxis.xy/zAxis.z;\n        float angleIris = acos(dot(normalize(x2D), normalize(z2D)));\n        //color = vec3(dot(xAxis, zAxis));\n        //color.x = abs(dot(normalize(x2D), normalize(z2D)));\n        float radialIrisMask = max(0.0, cos(angleIris*70.0)+sin(angleIris*70.0));//cos(angleIris*10.0)*cos(angleIris)+sin(angleIris*10.0)*sin(angleIris);\n        \n        float v3DIris = voronoi3D(p*25.0*angleIris)*0.1;\n        \n        color = mix(DARKBLUE, BLUE, v3DIris);\n        color = mix(color, mix(BLUE, YELLOW, v3DIris), eyeIrisInternalMask*4.0);\n        //color = DARKBLUE+YELLOW*v3DIris;\n        color = mix(BLACK, color, retinaEffectMask*eyeIrisDotP);\n        \n        color = mix(WHITE, color, eyeIrisMask*eyeIrisDotP);\n        color = mix(BLACK, color*1.25, eyeLensAA);\n        //color = vec3(eyeIrisDotP);\n        \n        color += brdf(\n            1.0, // specular\n            1.0, // diffuse\n            0.1, // roughness\n            1.0, // opacity\n            color, // specular color\n            color, // diffuse color\n            rd,\n            N,\n            L);\n        color += brdf(\n            1.0, // specular\n            1.0, // diffuse\n            0.1, // roughness\n            1.0, // opacity\n            color, // specular color\n            color, // diffuse color\n            rd,\n            N,\n            L2);\n        // reflection\n        vec3 R = reflect(-rd, N);\n        color += brdf(\n            1.0, // specular\n            1.0, // diffuse\n            0.1, // roughness\n            1.0, // opacity\n            texture(iChannel1, R).rgb, // specular color\n            texture(iChannel0, R).rgb, // diffuse color\n            rd,\n            N,\n            L);\n        // cheap \"antialiasing\"\n        float lim = dot(-rd, N);\n        if(lim<0.3)\n        {\n            vec3 bg = texture(iChannel0, -rd).rgb;\n            color = mix(bg, color, max(0.0, lim/0.3));\n            //color = vec3(lim);\n        }\n        //color = vec3(eyeLensAA);\n    }\n    else\n        color = texture(iChannel0, -rd).rgb;\n    return color;\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    eyeLP = vec3(0.0, sin(iTime)*0.4, 0.0);\n    \n    Camera ca = setCamera(ro, LOOKAT, vec3(0.0, 1.0, 0.0));\n    rd = ca.m*normalize(vec3(pixel.xy, 2.0));\n    \n    Camera caEL = setCamera(LOOKAT, ro, vec3(0.0, 1.0, 0.0));\n    \n    vec2 mv = 3.5*(-1.0 + 2.0*iMouse.xy/iResolution.xy);\n    vec3 rdEL = caEL.m*normalize(vec3(mv.xy-vec2(0.0, eyeLP.y), 1.0));\n    rdEL.x = -rdEL.x;\n    /*ro = RotYV3(ro, mv.x);\n    rd = RotYV3(rd, mv.x);\n    ro = RotXV3(ro, mv.y);\n    rd = RotXV3(rd, mv.y);*/\n    \n    float depth = 0.0, dump = 0.0;\n    float d = IntersectSphere(ro, rd, eyeLP, 1.0, depth, dump);\n    \n    eyeLD = normalize(rdEL);\n    \n    vec3 color = rendering(depth, ro, rd, uv, ca.m, ca.mI);\n    \n    color = tonemapping(color);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}