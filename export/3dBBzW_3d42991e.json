{"ver":"0.1","info":{"id":"3dBBzW","date":"1589548765","viewed":109,"name":"2D projections \"ЯАО\"","username":"ayakushyna","description":"2D projections using pixel grapghics and primitive functions","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pixelgraphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\n// some primitive functions (returning positive number inside and negative number outside)\nfloat box(float x,float y) {\n\treturn 1.0 - max(abs(x),abs(y));\n}\n\nfloat triangle(float x,float y) {\n\treturn min(0.0 - (x + y),min( 1.0 + x, 1.0 + y));\n}\n\n// some linear transformations of the arguments (incapsulated in vector v) of implicit functions\n\nvec2 rotate(float a,vec2 v) {\n\tfloat c_a = cos(a);\n\tfloat s_a = sin(a);\n\tfloat x1 = v.x * c_a + v.y * s_a;\n\tfloat y1 = v.x * -s_a + v.y * c_a;\n\tv.x = x1;\n\tv.y = y1;\n    return v;\n}\nvec2 scale(float s1,float s2,vec2 v) {\n\tv.x /= s1;\n\tv.y /= s2;\n    return v;\n}\n\nvec2 translate(vec2 dv,vec2 v) {\n\tv.x -= dv.x;\n\tv.y -= dv.y;\n    return v;\n}\n\nfloat axes(float x, float y)\n{\n    float axis_y;\n    float axis_x;\n    if(abs(x)< 0.1) axis_y=1.0;\n    if(abs(y)< 0.1) axis_x=1.0;\n    return   axis_y+axis_x;           \n}\n\nfloat grid(float x, float y)\n{\n    float grid_y = 0.0;\n    float grid_x = 0.0;\n    if(abs(mod(x,1.0)) < 0.15) grid_x=1.0;\n    if(abs(mod(y,1.0)) < 0.15) grid_y=1.0;\n    return (grid_y+grid_x)/3.0;\n}\n\nfloat drawA(float x, float y)\n{\n    vec2 leftLegAV = vec2(x, y);\n\tleftLegAV = translate(vec2(5, 11), leftLegAV);\n\tleftLegAV = scale(2.0, 8.0, leftLegAV);\n\tfloat leftLegA = box(leftLegAV[0], leftLegAV[1]);\n\n\tvec2 rightLegAV = vec2(x, y);\n\trightLegAV = translate(vec2(21, 11), rightLegAV);\n\trightLegAV = scale(2.0, 8.0, rightLegAV);\n\tfloat rightLegA = box(rightLegAV[0], rightLegAV[1]);\n\n\tvec2 midLineAV = vec2(x, y);\n\tmidLineAV = translate(vec2(13, 13), midLineAV);\n\tmidLineAV = rotate(PI / 2.0, midLineAV);\n\tmidLineAV = scale(2.0, 6.0, midLineAV);\n\tfloat midLineA = box(midLineAV[0], midLineAV[1]);\n\n\tvec2 topLineAV = vec2(x, y);\n\ttopLineAV = translate(vec2(13, 21), topLineAV);\n\ttopLineAV = rotate(PI / 2.0, topLineAV);\n\ttopLineAV = scale(2.0, 6.0, topLineAV);\n\tfloat topLineA = box(topLineAV[0], topLineAV[1]);\n\n\tvec2 topLeftTrinagleAV = vec2(x, y);\n\ttopLeftTrinagleAV = translate(vec2(5, 21), topLeftTrinagleAV);\n\ttopLeftTrinagleAV = rotate(PI / 2.0, topLeftTrinagleAV);\n\ttopLeftTrinagleAV = scale(2.0, 2.0, topLeftTrinagleAV);\n\tfloat topLeftTrinagleA = triangle(topLeftTrinagleAV[0], topLeftTrinagleAV[1]);\n\n\tvec2 topRightTrinagleAV = vec2(x, y);\n\ttopRightTrinagleAV = translate(vec2(21, 21), topRightTrinagleAV);\n\ttopRightTrinagleAV = scale(2.0, 2.0, topRightTrinagleAV);\n\tfloat topRightTrinagleA = triangle(topRightTrinagleAV[0], topRightTrinagleAV[1]);\n\n\tvec2 midRightTrinagleAV = vec2(x, y);\n\tmidRightTrinagleAV = translate(vec2(16, 17), midRightTrinagleAV);\n\tmidRightTrinagleAV = rotate(PI, midRightTrinagleAV);\n\tmidRightTrinagleAV = scale(3.0, 2.0, midRightTrinagleAV);\n\tfloat midRightTrinagleA = triangle(midRightTrinagleAV[0], midRightTrinagleAV[1]);\n\n\tvec2 midLeftTrinagleAV = vec2(x, y);\n\tmidLeftTrinagleAV = translate(vec2(10, 17), midLeftTrinagleAV);\n\tmidLeftTrinagleAV = rotate((3.0 * PI) / 2.0, midLeftTrinagleAV);\n\tmidLeftTrinagleAV = scale(2.0, 3.0, midLeftTrinagleAV);\n\tfloat midLeftTrinagleA = triangle(midLeftTrinagleAV[0], midLeftTrinagleAV[1]);\n\n\treturn \n        max(leftLegA,\n\t\tmax(rightLegA,\n\t\tmax(midLineA,\n\t\tmax(topLineA,\n\t\tmax(topLeftTrinagleA,\n\t\tmax(topRightTrinagleA,\n\t\tmax(midLeftTrinagleA,\n\t\tmidRightTrinagleA)))))));\n}\n\nfloat drawYa(float x, float y)\n{\n \tvec2 leftLegYaV = vec2(x, y);\n\tleftLegYaV = translate(vec2(-21, 7), leftLegYaV);\n\tleftLegYaV = scale(2.0, 4.0, leftLegYaV);\n\tfloat leftLegYa = box(leftLegYaV[0], leftLegYaV[1]);\n\n\tvec2 leftLineYaV = vec2(x, y);\n\tleftLineYaV = translate(vec2(-21, 17), leftLineYaV);\n\tleftLineYaV = scale(2.0, 2.0, leftLineYaV);\n\tfloat leftLineYa = box(leftLineYaV[0], leftLineYaV[1]);\n\n\tvec2 rightLegYaV = vec2(x, y);\n\trightLegYaV = translate(vec2(-5, 13), rightLegYaV);\n\trightLegYaV = scale(2.0, 10.0, rightLegYaV);\n\tfloat rightLegYa = box(rightLegYaV[0], rightLegYaV[1]);\n\n\tvec2 midLineYaV = vec2(x, y);\n\tmidLineYaV = translate(vec2(-13, 13), midLineYaV);\n\tmidLineYaV = rotate(PI / 2.0, midLineYaV);\n\tmidLineYaV = scale(2.0, 6.0, midLineYaV);\n\tfloat midLineYa = box(midLineYaV[0], midLineYaV[1]);\n\n\tvec2 topLineYaV = vec2(x, y);\n\ttopLineYaV = translate(vec2(-13, 21), topLineYaV);\n\ttopLineYaV = rotate(PI / 2.0, topLineYaV);\n\ttopLineYaV = scale(2.0, 6.0, topLineYaV);\n\tfloat topLineYa = box(topLineYaV[0], topLineYaV[1]);\n\n\tvec2 topLeftTrinagleYaV = vec2(x, y);\n\ttopLeftTrinagleYaV = translate(vec2(-21, 21), topLeftTrinagleYaV);\n\ttopLeftTrinagleYaV = rotate(PI / 2.0, topLeftTrinagleYaV);\n\ttopLeftTrinagleYaV = scale(2.0, 2.0, topLeftTrinagleYaV);\n\tfloat topLeftTrinagleYa = triangle(topLeftTrinagleYaV[0], topLeftTrinagleYaV[1]);\n\n\tvec2 midTopTrinagleYaV = vec2(x, y);\n\tmidTopTrinagleYaV = translate(vec2(-21, 14), midTopTrinagleYaV);\n\tmidTopTrinagleYaV = rotate(PI, midTopTrinagleYaV);\n\tmidTopTrinagleYaV = scale(2.0, 1.0, midTopTrinagleYaV);\n\tfloat midTopTrinagleYa = triangle(midTopTrinagleYaV[0], midTopTrinagleYaV[1]);\n\n\tvec2 midBotTrinagleYaV = vec2(x, y);\n\tmidBotTrinagleYaV = translate(vec2(-21, 12), midBotTrinagleYaV);\n\tmidBotTrinagleYaV = rotate(PI / 2.0, midBotTrinagleYaV);\n\tmidBotTrinagleYaV = scale(1.0, 2.0, midBotTrinagleYaV);\n\tfloat midBotTrinagleYa = triangle(midBotTrinagleYaV[0], midBotTrinagleYaV[1]);\n\n\treturn \n        max(leftLegYa,\n\t\tmax(leftLineYa,\n\t\tmax(rightLegYa,\n\t\tmax(midLineYa,\n\t\tmax(topLineYa,\n\t\tmax(topLeftTrinagleYa,\n\t\tmax(midTopTrinagleYa,\n\t\tmidBotTrinagleYa))))))); \n}\n\nfloat drawO(float x, float y)\n{\n\tvec2 leftLegOV = vec2(x, y);\n\tleftLegOV.xy = translate(vec2(-21, -13), leftLegOV);\n\tleftLegOV.xy = scale(2.0, 6.0, leftLegOV);\n\tfloat leftLegO = box(leftLegOV[0], leftLegOV[1]);\n\n\tvec2 rightLegOV = vec2(x, y);\n\trightLegOV = translate(vec2(-5, -13), rightLegOV);\n\trightLegOV = scale(2.0, 6.0, rightLegOV);\n\tfloat rightLegO = box(rightLegOV[0], rightLegOV[1]);\n\n\tvec2 butLineOV = vec2(x, y);\n\tbutLineOV = translate(vec2(-13, -21), butLineOV);\n\tbutLineOV = rotate(PI / 2.0, butLineOV);\n\tbutLineOV = scale(2.0, 6.0, butLineOV);\n\tfloat butLineO = box(butLineOV[0], butLineOV[1]);\n\n\tvec2 topLineOV = vec2(x, y);\n\ttopLineOV = translate(vec2(-13, -5), topLineOV);\n\ttopLineOV = rotate(PI / 2.0, topLineOV);\n\ttopLineOV = scale(2.0, 6.0, topLineOV);\n\tfloat topLineO = box(topLineOV[0], topLineOV[1]);\n\n\tvec2 topLeftTrinagleOV = vec2(x, y);\n\ttopLeftTrinagleOV = translate(vec2(-21, -5), topLeftTrinagleOV);\n\ttopLeftTrinagleOV = rotate(PI / 2.0, topLeftTrinagleOV);\n\ttopLeftTrinagleOV = scale(2.0, 2.0, topLeftTrinagleOV);\n\tfloat topLeftTrinagleO = triangle(topLeftTrinagleOV[0], topLeftTrinagleOV[1]);\n\n\tvec2 topRightTrinagleOV = vec2(x, y);\n\ttopRightTrinagleOV = translate(vec2(-5, -5), topRightTrinagleOV);\n\ttopRightTrinagleOV = scale(2.0, 2.0, topRightTrinagleOV);\n\tfloat topRightTrinagleO = triangle(topRightTrinagleOV[0], topRightTrinagleOV[1]);\n\n\tvec2 botLeftTrinagleOV = vec2(x, y);\n\tbotLeftTrinagleOV = translate(vec2(-21, -21), botLeftTrinagleOV);\n\tbotLeftTrinagleOV = rotate(PI, botLeftTrinagleOV);\n\tbotLeftTrinagleOV = scale(2.0, 2.0, botLeftTrinagleOV);\n\tfloat botLeftTrinagleO = triangle(botLeftTrinagleOV[0], botLeftTrinagleOV[1]);\n\n\tvec2 botRightTrinagleOV = vec2(x, y);\n\tbotRightTrinagleOV = translate(vec2(-5, -21), botRightTrinagleOV);\n\tbotRightTrinagleOV = rotate(3.0*PI/2.0, botRightTrinagleOV);\n\tbotRightTrinagleOV = scale(2.0, 2.0, botRightTrinagleOV);\n\tfloat botRightTrinagleO = triangle(botRightTrinagleOV[0], botRightTrinagleOV[1]);\n\n\treturn \n\t\tmax(leftLegO,\n\t\tmax(rightLegO,\n\t\tmax(butLineO,\n\t\tmax(topLineO,\n\t\tmax(topLeftTrinagleO,\n\t\tmax(topRightTrinagleO,\n\t\tmax(botLeftTrinagleO,\n\t\tbotRightTrinagleO)))))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float wmax=max(iResolution.x,iResolution.y);\n    float aspect =iResolution.y/iResolution.x;\n    vec2  vnorm = vec2(wmax,wmax);   \n    vec2 uv = fragCoord/vnorm ; //iResolution.xy;\n    float x=uv.x;\n    float y=uv.y;\n\n    x *=100.0;\n    y *=100.0;\n    \n    x -=50.0;\n    y -=50.0*aspect;\n    \n\n    float grid =  max(grid(x,y), axes(x,y))/2.0;\n\n    float f = drawO(x,y)/10.0;\n    f = max(f, drawYa(x,y)/10.0);\n    f = max(f, drawA(x,y)/10.0);\n    f = 0.01/f; \n\n    // Time varying pixel color\n\n    vec3 col = vec3(0.0,grid,0.0);\n\n    if(f >= 0.0)col.x =  f;//+cos(iTime);// + 0.5*cos(iTime*iTime/1000.0+uv.xyx+vec3(10,2,4));\n    else      col.z = -f;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n\n}","name":"Image","description":"","type":"image"}]}