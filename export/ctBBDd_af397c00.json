{"ver":"0.1","info":{"id":"ctBBDd","date":"1694609635","viewed":82,"name":"Shader-6 deadzero","username":"deadzero","description":"shader 6, just tests","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["rotate","shape","forms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI * 2. / s;\n    a = floor(a / n) * n;\n    p *= rot(a + iTime * 0.5);  // Added time-dependent rotation for more dynamic pattern\n    return p;\n}\n\nfloat sdRect( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y),0.0) + length(max(d,0.0));\n}\n\nfloat tex(vec2 p, float z)\n{\n    p = foldRotate(p, 6.0);  // Modified foldRotate parameter for a different pattern\n    vec2 q = (fract(p / 8.0) - 0.5) * 10.0;  // Adjusted the fract() scaling\n    for (int i = 0; i < 3; ++i) {\n        q = abs(q) - .35;\n        q *= rot(PI * .35); // Modified rotation angle\n        q = foldRotate(q, 2.0);\n    }\n    float d = sdRect(q, vec2(0.8, 1.2));\n    float f = 1.0 / (1.0 + abs(d));\n    return smoothstep(.8, 1., f);  // Adjusted smoothstep values\n}\n\nfloat sm(float start, float end, float t, float smo)\n{\n    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453) * 2.0 - 1.0;\n}\n\nfloat dirt(vec2 uv, float n)\n{\n    vec2 p = fract(uv * n);\n    vec2 st = (floor(uv * n) + 0.5) / n;\n    vec2 rnd = hash(st);\n    float d = length(p - vec2(0.5, 0.5) - vec2(0.2) * rnd);\n    float c = smoothstep(0.05, 0.05*(1.-0.25), d);\n    c *= mix(abs(rnd.y * 0.4) + 0.3, 1., smoothstep(0.05*0.8, 0.05, d));\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.2;  // Slightly increased scaling\n    \n    vec3 col = vec3(0.0);\n\n    float time = iTime * 0.9;  // Slowed down the time progression\n    for(int i = 0; i < 6; i++) {  // Kept the loop count same to maintain complexity\n        float t, ii = float(6 - i);\n        \n        // Adjusted some parameters in the below calculations for variety\n        t = ii * 3.0 - mod(time - 3.0 * 0.85, 3.0);\n        col = mix(col, vec3(0.6, 0.8, 0.7), dirt(mod(uv * max(0.0, t) * 0.12 + vec2(.3, -.3) * time, 1.3), 3.2));\n        \n        t = ii * 3.0 - mod(time + 3.0 * 0.55, 3.0);\n        col = mix(col, vec3(0.6, 0.7, 1.0) * 1.4, tex(uv * max(0.0, t), 4.25));\n        \n        t = ii * 3.0 - mod(time - 3.0 * 0.35, 3.0);\n        col = mix(col, vec3(1.0, 0.8, 0.9), dirt(mod(uv * max(0.0, t) * 0.12 + vec2(-.3, -.3) *  time, 1.3), 3.2));\n\n        t = ii * 3.0 - mod(time, 3.0);\n    \tfloat r = length(uv * 2.1 * max(0.0, t));\n    \tfloat rr = sm(-24.0, -0.0, (r - mod(time * 32.0, 88.0)), 9.0);\n        col = mix(col, mix(vec3(1.0, 0.8, 0.7), vec3(0.6, 0.5, 1.0) * 2.9, rr), tex(uv * 2.1 * max(0.0, t), 0.29 + (1.9 * rr)));\n    }\n\n\tfragColor = vec4(col, 1.0);  // Made sure the alpha is 1.0 for proper visibility\n}\n","name":"Image","description":"","type":"image"}]}