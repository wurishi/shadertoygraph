{"ver":"0.1","info":{"id":"ml2yRd","date":"1692202542","viewed":54,"name":"Gradient noise circle","username":"zlnimda","description":"Learning stuff","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"dtjczt","parentname":"_noise_grad_zln"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// degenerative values from fractional value from high frequency sinus values\nfloat rand(float x)\n{\n    return fract(sin(x) * 4973.363);\n}\n\n// random for 2dimension value\nvec2 rand2(vec2 v)\n{\n    v = vec2(\n        dot(v, vec2(127.35, 224.52)),\n        dot(v, vec2(269.27, 111.42)));\n    return fract(sin(v) * 4973.363);\n}\n\n// Remap to [-1;+1]\nvec2 remap(vec2 i)\n{\n    return i * 2. - 1.;\n}\n\n// Unmap to [+0;+1]\nfloat unmap(float i)\n{\n    return i * .5 + .5;\n}\n\n// animate uv\nvec2 PanUV(vec2 uv)\n{\n    return uv + iTime * 53.5;\n}\n\n// noise gradient\nfloat noise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 xo = vec2(0., 1.);\n    \n    // smooth interpolator\n    vec2 u = smoothstep(0., 1., f);\n    \n    // get 4 corners random directions values\n    //  note the importance of remapping to avoid loss of distribution\n    float v00 = dot(remap(rand2(i+xo.xx)), f-xo.xx);\n    float v01 = dot(remap(rand2(i+xo.xy)), f-xo.xy);\n    float v10 = dot(remap(rand2(i+xo.yx)), f-xo.yx);\n    float v11 = dot(remap(rand2(i+xo.yy)), f-xo.yy);\n    \n    // bilinear interpolation\n    //  note the unmap to original range to preserve distribution\n    return unmap(mix( mix(v00, v10, u.x),\n                      mix(v01, v11, u.x), u.y));\n}\n\nfloat sdf(vec2 uv)\n{\n    float f1 = abs(acos(uv.x/length(uv))) * 5.25 + iTime * 1.2;\n    float f2 = abs(asin(uv.y/length(uv))) * 1.53 - iTime * 1.5;\n    return length(uv) - .5 - noise(vec2(f1, f2)) * .1;\n}\n\nfloat circle(vec2 uv)\n{\n    float f = abs(sdf(uv));\n    f = smoothstep(1.f, 0.f, f /.02);\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized equidistant pixel coordinates zero centered\n    vec2 uv = 2. * (fragCoord/iResolution.xy - .5) * iResolution.xy / min(iResolution.x,iResolution.y);\n    \n    // noise 2d\n    float r = circle(uv);\n\n    vec3 col = vec3(r,r,r);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}