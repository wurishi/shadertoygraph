{"ver":"0.1","info":{"id":"tdtcRS","date":"1601207815","viewed":420,"name":"Nebula v1.1 ","username":"phomo","description":"Adaptive Step Size optimisation - when further away from light sources, increase the step size to save number of loops.   24fps -> (30.....54) fps\nBut does introduce a noticeable ringing artifact and is still not fast enough","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","game","nebula","optimisation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 repeatingLightSource(vec3 samplePoint, float spacing)\n{   \n   \tfloat halfSpacing = spacing / 2.0;\n    vec3 lightPos = (floor( (samplePoint + halfSpacing) / spacing) * spacing);\n    \n    float rnd = rand(lightPos);\n    vec3 offset = halfSpacing * vec3(rnd,-rnd,-rnd);\n    \n    /*float rndX = 2.0 * (0.5 * rnd11(lightPos.x));\n    float rndY = 2.0 * (0.5 * rnd11(lightPos.y));\n    float rndZ = 2.0 * (0.5 * rnd11(lightPos.z));\n    vec3 offset = halfSpacing * vec3(rndX,rndY,rndZ);*/\n    \n    return lightPos + offset * 2.0;\n}\n\nvec3 singleLightSource(vec3 samplePoint, float spacing)\n{   \n    return vec3(360,-530, 2000);\n}\n\nfloat baseNoise(vec3 samplePoint, float noiseFreqFactor)\n{\n\treturn fbmdcol(samplePoint * noiseFreqFactor).r;\n}\n\nfloat calculateDensity(float noiseVal)\n{\n    return smoothstep(0.0,1.0, noiseVal);\n}\n\nfloat distToNearestLight(vec3 lightPos, vec3 samplePoint)\n{    \n    return length(lightPos - samplePoint);\n}\n\nfloat nrmDistToNearestLight(vec3 lightPos, vec3 samplePoint, float lightSize)\n{\n    return saturate(distToNearestLight(lightPos, samplePoint) / lightSize);\n}\n\nvec3 drawStar(vec3 starPos, vec3 samplePoint, float interval, float starSize)\n{    \n    float lightAttenuationCurve = 1.0;\n    float gain = 10.0;\n    float lighting = 0.0;\n    float nrmDist = length(starPos - samplePoint) / 0.25;\n    lighting += smoothstep(starSize, 0.0, nrmDist);\n    return vec3(lighting,lighting,lighting) *  interval * gain;\n}\n\nvec3 inScatter(float density, vec3 lightPos, vec3 samplePoint, float interval, float lightSize)\n{    \n    float lightAttenuationCurve = 2.0;\n    float minLightValue = 0.3;\n    float lightGain = 5.0;\n        \n    float lighting = 1.0 - nrmDistToNearestLight(lightPos, samplePoint, lightSize);\n                                                \n    lighting = max(minLightValue, lightGain * pow(saturate(lighting), lightAttenuationCurve));\n    \n    //view lighting directly\n    //return vec3(lighting,lighting,lighting) *  interval;\n    \n    vec3 peaks = vec3(0.4,0.5,0.2);\n    \n    //this defines how much overlap / colour blended regions\n    vec3 under = peaks - 0.2;\n    vec3 over = peaks + 0.20;\n    \n    //prevelant\n    float col1Factor = smoothstep(under.r,peaks.r, density) * smoothstep(over.r,peaks.r, density);\n    \n    //prevelant\n    float col2Factor = smoothstep(under.g,peaks.g, density) * smoothstep(over.g,peaks.g,density);    \n    \n    //rare\n    float col3Factor = smoothstep(under.b,peaks.b, density) * smoothstep(over.b,peaks.b,density);\n    \n    //Orange, deep blues, bright pinks\n    //vec3 col1 = vec3(1.5, 0.5, 0.1);\tvec3 col2 = vec3(0.2, 0.2, 1.0);\tvec3 col3 = vec3(5.0, 3.0, 0.0);\n\n    //Blues yellows and whites    \n    //vec3 col1 = vec3(0.2, 1.4, 2.0);\tvec3 col2 = vec3(0.25, 0.5, 0.1);\tvec3 col3 = vec3(5.0, 3.0, 0.0);\n\n    //Deep blue dust cloud with bright spots\n    //vec3 col1 = vec3(2.2, 1.0, 0.2);\tvec3 col2 = vec3(0.3, 0.55, 1.5);\tvec3 col3 = vec3(-1.5, -1.5, -1.0);\n    \n    //Orange blue dust with bright spots\n    vec3 col1 = vec3(2.2, 1.0, 0.2);\tvec3 col2 = vec3(0.3, 0.55, 1.5);\tvec3 col3 = vec3(-0.5, -0.5, -0.5);\n    \n    //Blue orange\n    //vec3 col1 = vec3(0.15, 0.0, 1.5);\tvec3 col2 = vec3(0.5, 0.3, 0.0);\tvec3 col3 = vec3(3.0, 2.0, 0.0);\n    \n    return lighting * (col1 * col1Factor + col2 * col2Factor + col3 * col3Factor) * interval;\n}\n\nvec3 extinguishDueToDust(vec4 col, float density, float interval)\n{\n    return col.rgb * saturate((1.0 - pow(saturate(density),16.0) * interval * 0.5));\n}\n\nvec3 extinguishDueToTransmittance(vec4 col, float noiseVal, float interval, vec3 rgbPowers)\n{\n    float amt = saturate(noiseVal * 4.0);\n    float rExt = 1.0 - interval * pow(amt, rgbPowers.r);\n    float gExt = 1.0 - interval * pow(amt, rgbPowers.g);\n    float bExt = 1.0 - interval * pow(amt, rgbPowers.b);\n    return col.rgb * vec3(rExt, gExt, bExt);\n}\n\nvec3 warpSamplePoint(vec3 samplePoint, float noiseFreqFactor, float domainWarp)\n{\n    float noise = baseNoise(samplePoint, noiseFreqFactor);\n    float lowFreqNoise = baseNoise(samplePoint, noiseFreqFactor * 2.25);\t//higher = more distorted + more aliased\n    domainWarp *= (1.0 - lowFreqNoise);\n    return samplePoint + noise * domainWarp;    \n}\n\n//a1,a2 results of intersection test (enter,leave distances)\nvec4 integrate(vec3 eyePos, vec3 eyeDir, float a1, float a2, float domainWarp, float noiseFreqFactor, vec4 baseColour, vec3 rgbTransmittancePowers)\n{\n    float num_view_ray_steps = 125.0;\n    \n    float lightSpacing = 4500.0;\n    float lightSize = 2000.0;\n    float starSize = 500.0;\t\n    float totalDist = a2 - a1;\n\tvec3 rayStart = eyePos + eyeDir * a1;\n\tvec3 rayEnd = eyePos + eyeDir * a2;\n    vec3 samplePoint;\t\n    vec3 oldSamplePoint;\n    vec3 baseDelta = setupBackToFrontIterator(rayStart, rayEnd, num_view_ray_steps, rayStart, rayEnd);\n    oldSamplePoint = rayStart;\n    \n\tvec4 colourAccumulator = baseColour;\n    \n    float i = 0.0;\n\twhile (i < num_view_ray_steps)\n\t{\n        float fadeout = smoothstep(num_view_ray_steps, num_view_ray_steps*0.875, i);         \n        samplePoint = flatDelta(rayStart, baseDelta, i, num_view_ray_steps);\n        //samplePoint = backToFrontOneMinusPowDelta(rayStart, rayEnd, i, num_view_ray_steps);        \n        //samplePoint = backToFrontAdaptiveDelta2(rayStart, baseDelta, i, 0.33, 0.33, num_view_ray_steps);\n        vec3 delta = samplePoint - oldSamplePoint;\n        float interval = length(delta) / totalDist;\n        oldSamplePoint = samplePoint;\n        \n        vec3 noiseSamplePoint = warpSamplePoint(samplePoint, noiseFreqFactor, domainWarp);\n        //vec3 starPos = singleLightSource(samplePoint, lightSpacing);\n        vec3 starPos = repeatingLightSource(samplePoint, lightSpacing);\n        float noiseVal = baseNoise(noiseSamplePoint, noiseFreqFactor);\n        float density = calculateDensity(noiseVal) * 3.0;\n        \n        colourAccumulator.rgb += drawStar(starPos, samplePoint, interval, starSize) * fadeout * 2.0;\n        colourAccumulator.rgb += inScatter(noiseVal, starPos, samplePoint, interval, lightSize) * fadeout * 1.5;\n        colourAccumulator.rgb = extinguishDueToDust(colourAccumulator, density, interval);\n        colourAccumulator.rgb = extinguishDueToTransmittance(colourAccumulator, noiseVal, interval, rgbTransmittancePowers);\n        \n        float len = length(starPos - samplePoint);\n        \n        i+=1.0;\n        \n        \n        \n        //when further away from light sources, increase the step size\n        const float threshold = 2250.0;\n        \n        if ( len > threshold)\n        {\n\t\t\tfloat t = (len-threshold) / threshold;\n            t = max(0.0, min(1.75, t));\t\t\t\t//0 .. 1.75\n            i += t;\n        }\n\t}\n\t\n\treturn colourAccumulator;\t\n}\n\nvec4 tonemap(vec4 col)\n{\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // These are the shader constants passed in from the game\n    vec4 nebulaSettingsProvider = vec4(1.0, 0.002, 1.0, 0.40);\n    vec4 nebulaTextureSettingsProvider = vec4(5.0,3.0,4.0,0.25);  \n    \n    float noiseFreqFactor = 0.0005 * nebulaSettingsProvider.r;\n    float domainWarp = 3000.0 * nebulaSettingsProvider.b;\n    vec3 rgbTransmittancePowers = vec3(nebulaTextureSettingsProvider.rgb);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Emulated screen-space eye Vectors        \n    vec3 eyeDir = fovEyeDir( 90.0, iResolution.xy, fragCoord.xy );\n    \n    // Work out camera position, eye rays, fov etc\n    float speed = 1320.0;\n    float startTime = 23.0;\n    vec3 eyePos = vec3(500.0,-400.0, -700.0 + (iTime + startTime) * speed);\n    //vec3 eyePos = vec3(0.0,0.0,0.0);\n    \n    // Distance we will march through the volume.  a1 = start of ray, a2 = end of ray.\n    float a1 = 0.0;\n    float a2 = 7500.0;\n                \n    vec4 baseColour = vec4(0.0,0.0,0.0,0.0);\n    vec4 col = integrate(eyePos, eyeDir, a1, a2, domainWarp, noiseFreqFactor, baseColour, rgbTransmittancePowers);\n\n    // Output to screen   \n    fragColor = tonemap(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//------------------------------------------------------------------------\n// hlsl_compatibility.h\n//------------------------------------------------------------------------\nfloat saturate(float source)\n{\n    return clamp(source, 0.0,1.0);\n}\n\nvec4 saturatev4(vec4 source)\n{\n    return clamp(source, vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));\n}\n\nvec2 nrmCenteredUv(vec2 fragPos)\n{\n    return vec2(2.0 * (fragPos.x-0.5), 2.0 * (fragPos.y-0.5));\n}\n\n//This emulates the shader setup that gives per-vertex eyeDir for screenspace effects\nvec3 fovEyeDir( float fov, vec2 size, vec2 pos )\n{\n\tvec2 xy = pos - size * 0.5;\n\tfloat cot_half_fov = tan( radians( 90.0 - fov * 0.5 ) );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\treturn normalize( vec3( xy, z ) );\n}\n\n//------------------------------------------------------------------------\n// deltas.h\n//------------------------------------------------------------------------\nvec3 setupBackToFrontIterator(vec3 rayStart, vec3 rayEnd, float steps, out vec3 outRayStart, out vec3 outRayEnd)\n{\t\n    vec3 delta = (rayStart - rayEnd) / steps;\n    vec3 temp = rayStart;\n\toutRayStart = rayEnd;\n\toutRayEnd = temp;\n\treturn delta;\n}\n\nvec3 flatDelta(vec3 rayStart, vec3 delta, float i, float totalI)\n{\n\t//vec3 extrapolatedRayStart = rayStart + i * delta;\n\t//vec3 rayMid = extrapolatedRayStart + (delta / 2.0);\n\t//return rayMid;\n    return rayStart + (i * delta);\n}\n\nvec3 logDelta(vec3 rayStart, vec3 baseDelta, float i, float num_view_ray_steps)\n{\n    float tAmt = log(saturate(i / num_view_ray_steps));\t\t// 0 .. 1  back .. front\n    float tAmt2 = log(saturate((i + 1.0) / num_view_ray_steps));\t\t// 0 .. 1  back .. front\n    float interval = tAmt2 - tAmt;\n    vec3 delta = baseDelta * interval;\n    vec3 rayMid = rayStart + delta / 2.0;\n    return rayMid;\n}\n\n//This gives more detail up close than at the back\nvec3 backToFrontOneMinusPowDelta(vec3 rayStart, vec3 rayEnd, float i, float num_view_ray_steps)\n{\n    float tValue = (i / num_view_ray_steps);\t//0 .. 1 back .. front\n    float logTValue = 1.f - pow( (1.f - tValue), 2.f );\t//tValue changes quickly at first, then gradually        \n    vec3 rayMid = mix(rayStart, rayEnd, logTValue);    \n    return rayMid;\n}\n\n\n// 1/3 of samples go from the back to bandAPct of the total region\n// 1/3 of samples go from bandAPct to bandBPct\n// 1/3 of samples go from bandBPct to the front.\nvec3 backToFrontAdaptiveDelta2(vec3 rayStart, vec3 baseDelta, float i, float bandAPct, float bandBPct, float bandT)\n{\n\tfloat bandA = bandT * bandAPct;\n\tfloat bandB = bandT * bandBPct;\n    \n\tvec3 bandADelta = baseDelta * 1.5;\n\tvec3 bandBDelta = baseDelta * 1.0;\n\tvec3 bandCDelta = baseDelta * 0.5;\n\n\tif (i < bandA)\n\t{\t\t\n\t\tvec3 extrapolatedRayStart = rayStart + i * bandADelta;\n\t\tvec3 rayMid = extrapolatedRayStart + (bandADelta / 2.0);\n\t\treturn rayMid;\n\t}\n\telse if (i < bandB)\n\t{\n\t\tvec3 extrapolatedRayStart = rayStart + (bandA * bandADelta) + (i - bandA) * bandBDelta;\n\t\tvec3 rayMid = extrapolatedRayStart + (bandBDelta / 2.0);\n\t\treturn rayMid;\n\t}\n\telse\n\t{\n\t\tvec3 extrapolatedRayStart = rayStart + (bandA * bandADelta) + ( (bandB-bandA) * bandBDelta) + (i - bandB) * bandCDelta;\n\t\tvec3 rayMid = extrapolatedRayStart + (bandCDelta / 2.0);\n\t\treturn rayMid;\n\t}\n}\n//------------------------------------------------------------------------\n// random.h\n//------------------------------------------------------------------------\nfloat rand(vec3 n){\n  return fract(sin(dot(n ,vec3(12.9898,78.233,54.3819))) * 43758.5453);\n}\n\n//------------------------------------------------------------------------\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//------------------------------------------------------------------------\nfloat rnd11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------\n// noise.h\n//------------------------------------------------------------------------\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\n\nvec4 noise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 w = fract(x);\n\tvec3 u = w*w*(3.0 - 2.0*w);\n\tvec3 du = 6.0*w*(1.0 - w);\n\n\tfloat n = p.x + p.y*157.0 + 113.0*p.z;\n\n\tfloat a = hash(n + 0.0);\n\tfloat b = hash(n + 1.0);\n\tfloat c = hash(n + 157.0);\n\tfloat d = hash(n + 158.0);\n\tfloat e = hash(n + 113.0);\n\tfloat f = hash(n + 114.0);\n\tfloat g = hash(n + 270.0);\n\tfloat h = hash(n + 271.0);\n\n\tfloat k0 = a;\n\tfloat k1 = b - a;\n\tfloat k2 = c - a;\n\tfloat k3 = e - a;\n\tfloat k4 = a - b - c + d;\n\tfloat k5 = a - c - e + g;\n\tfloat k6 = a - b - e + f;\n\tfloat k7 = -a + b + c - d + e - f - g + h;\n\n\treturn vec4(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z,\n\t\tdu * (vec3(k1, k2, k3) + u.yzx*vec3(k4, k5, k6) + u.zxy*vec3(k6, k4, k5) + k7*u.yzx*u.zxy));\n}\n\nvec4 fbmdcol(vec3 x)\n{\n\tconst float scale = 1.5;\n\n\tfloat a = 0.0;\n\tfloat b = 0.5;\n\tfloat f = 1.0;\n\tvec3  d = vec3(0, 0, 0);\n\n\tfor (int i = 0; i<8; i++)\n\t{\n\t\tvec4 n = noise(f*x*scale);\n\t\ta += b*n.x;           // accumulate values\t\t\n\t\td += b*n.yzw*f*scale; // accumulate derivatives\n\t\tb *= 0.5;             // amplitude decrease\n\t\tf *= 1.8;             // frequency increase\n\t}\n\n\treturn vec4(a, a, a, d);\n}\n\n\nvec4 fbmd(vec3 x)\n{\n\tconst float scale = 1.5;\n\n\tfloat a = 0.0;\n\tfloat b = 0.5;\n\tfloat f = 1.0;\n\tvec3  d = vec3(0, 0, 0);\n\n\tfor (int i = 0; i<8; i++)\n\t{\n\t\tvec4 n = noise(f*x*scale);\n\t\ta += b*n.x;           // accumulate values\t\t\n\t\td += b*n.yzw*f*scale; // accumulate derivatives\n\t\tb *= 0.5;             // amplitude decrease\n\t\tf *= 1.8;             // frequency increase\n\t}\n\n\treturn vec4(a, a, a, d);\n}","name":"Common","description":"","type":"common"}]}