{"ver":"0.1","info":{"id":"lsV3zD","date":"1453580980","viewed":146,"name":"Day 002 - SDF","username":"mwalczyk","description":"Day 002 - SDF","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Much love / credit to @cabbibo for his SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n\n#define PI 3.14159\n\nconst float MAX_TRACE_DIST = 3.0;\t// Max trace distance\nconst float MIN_HIT_DIST = 0.001;\t// Precision of the intersection\nconst int MAX_NUM_STEPS = 100;\t\t// Max number of steps we take along a ray\n\n// Polynomial smooth min (k = 0.1) and opBlend from IQ\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat opBlend(float a, float b)\n{\n    // Added this for the animation\n    float k = (sin(iTime + 0.2) + 1.0) / 2.0;\n    k = max(0.2, k);\n\n\treturn smin(a, b, k);\n}\n\nfloat sdSphere(in vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nvec2 map(in vec3 pos)\n{\n    // This is where we actually define all of the properties of \n    // the objects in our scene and perform any unions, intersections, \n    // deformations, etc.\n    float sphere1 = sdSphere(pos - vec3(0.5, 0.0, -1.0), 0.5);\n    float sphere2 = sdSphere(pos - vec3(-0.5, 0.0, -1.0), 0.5);\n    \n    vec2 res = vec2(opBlend(sphere1, sphere2), \n        \t\t\t1.0); \n    \n    return res;\n}\n\n// Calculate the normal of the surface at position pos\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\n// Calculate intersections\nvec2 calcIntersection(in vec3 ro, in vec3 rd)\n{\n    // This is where we do the actual \"marching\"\n    \n    float h =  MIN_HIT_DIST * 2.0;\t// Distance to the closest surface, which we overwrite each iteration\n    float t = 0.0;\t\t\t\t\t// Total distance traveled along the ray\t\t\t\t\t\t\n\tfloat finalDist = -1.0;\t\t\t// We haven't hit anything yet, so make this negative\n    float id = -1.0;\t\t\t\t// We haven't hit anything yet, so make this negative\n    \n    for(int i = 0; i < MAX_NUM_STEPS; ++i)\n    {\n        // Are we close enough to the surface? OR\n        // Have we traveled far enough to safely say we won't hit anything?\n    \tif(h < MIN_HIT_DIST || t > MAX_TRACE_DIST) break;\n        \n        vec2 distToClosest = map(ro + rd * t);\n        h = distToClosest.x;\t// The distance\n        id = distToClosest.y;\t// The object id\n        t += h;\t\t\t\t\t// Clever optimization: see literature on \"Distance Aided Raymarching\"\n    }\n    \n    if(t < MAX_TRACE_DIST) finalDist = t;\n    if(t < MAX_TRACE_DIST) id = -1.0;\n    return vec2(finalDist, id);\n}\n\n// Calculate the color at the ray position\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv)\n{\n    // Make a corny ass background gradient\n    float ssDistToCenter = length(uv);\n    vec3 bgColor1 = vec3(0.6, 0.2, 0.9);\n    vec3 bgColor2 = vec3(0.0, 0.2, 0.8); \n    vec3 surfaceColor = mix(bgColor1, bgColor2, ssDistToCenter);\n    \n    vec2 results = calcIntersection(ro, rd);\n    float t = results.x;\t\t\t\t\t\t// Where along our ray did we hit?\n    float id = results.y;\t\t\t\t\t\t// what did we hit?\n    \n    if(t > -0.5)\n    {\n    \t// Here, we could use the 'id' to change lighting / material \n   \t\t// params on a per-object basis\n   \t\t\n        vec3 lightPos = vec3(1.0, 4.0, 3.0);\n   \t \tvec3 pos = ro + rd * t;\n    \tvec3 n = calcNormal(pos);\n    \tvec3 l = normalize(lightPos - pos);\n        \n    \tvec3 diffColor = n;\n    \tvec3 ambientColor = vec3(0.3 , 0.1, 0.2);\n    \n    \tfloat diffStrength = max(dot(n, l), 0.0);\n    \tsurfaceColor = diffStrength * diffColor + ambientColor;\n    }\n    \n    return surfaceColor;\n}\n    \nmat3 setCamMatrix(in vec3 ro, in vec3 ta, float roll)\n{\n\tvec3 ww = normalize(ta - ro);\t// Look-at direction, normalized\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Need to review this calculation...\n   \tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    \n    // Shape that shit\n    float camX = sin(iTime);\n    camX = 1.0 - pow(abs(sin(PI * camX / 2.0)), 2.0);\n   \n    vec3 ro = vec3(camX,0., 2.0);\t\t\t\t\t\t\t\t\t// Ray origin\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\t\t\t\t\t\t\t\t\t// Look-at position\n    mat3 cameraMatrix = setCamMatrix(ro, ta, 0.0);\t\t\t\t\t// Position, look-at, roll\n    \n    float lensLength = 2.0;\n    vec3 rd = normalize(cameraMatrix * vec3(p.xy, lensLength));\t\t// Ray direction\n    \n    vec3 color = render(ro, rd, p);\n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}