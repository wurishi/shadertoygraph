{"ver":"0.1","info":{"id":"lljBDW","date":"1515876457","viewed":451,"name":"Volumetric_0","username":"balkhan","description":"volumetric torus","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FUDGE .25\n#define INVERT_COLOR\n\nvec3\tcam(vec2 u);\nvoid\tscene(vec3 p);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nvoid rotate(inout vec2 v, float angle);\n\nfloat\ttnear, tfar, step_dist;\nvec3\th;\nvec3 _ColorOne = vec3(.25, .2, .7);\nvec3 _ColorTwo = vec3(.15, .72, .7);\n\nstruct Ray\n{\n\tvec3\to;\n\tvec3\td;\n};\n\n// nvidia paper : http://http.download.nvidia.com/developer/presentations/2005/GDC/Sponsored_Day/GDC_2005_VolumeRenderingForGames.pdf\nbool\tIntersectBox(Ray r, vec3 boxmin, vec3 boxmax, out float tnear,\nout float tfar)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / r.d;\n\tvec3 tbot = invR * (boxmin.xyz - r.o);\n\tvec3 ttop = invR * (boxmax.xyz - r.o);\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\t// check for hit\n\tbool hit;\n\tif ((tnear > tfar))\n\t\thit = false;\n\telse\n\thit = true;\n\treturn hit;\n}\n\n// taken from : https://www.shadertoy.com/view/4lscW8\nvec3 cameraLookAt(vec3 target, vec3 camPos, vec3 up, vec2 uv, float camNear)\n{\n    vec3 axisZ = normalize(target - camPos);\n    vec3 axisX = cross(axisZ, up);\n    vec3 axisY = cross(axisX, axisZ);\n    return normalize(axisX * uv.x + axisY * uv.y + camNear * axisZ); \n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    h = vec3(0.);\n\tvec2 R = iResolution.xy, u = (f.xy-R.xy*.5) / R.yy;\n    o = vec4(0.);\n    vec3\tpos = vec3(.0+sin(iTime*2.*.5+.57)*4.*1.,.0+cos(iTime*1.*.5+.57)*4.*1.,4.);\n    vec3\tcm = cameraLookAt(vec3(.0,.0,.0), pos, vec3(.0,1.,.0), u, 1.);\n    vec2\tdist = vec2(0.);\n    vec3\tp;\n    float\tii = 0.;\n    Ray eyeray;\n    eyeray.o = pos;\n    eyeray.d = cm;\n    bool hit = IntersectBox(eyeray, vec3(-2.,-1.,-1), vec3(2,1,1), tnear, tfar );\n    vec3\tpnear = eyeray.o + tnear * eyeray.d;\n\tvec3\tpfar  = eyeray.o + tfar  * eyeray.d;\n    eyeray.d = normalize(pfar-pnear);\n\teyeray.o += tnear * eyeray.d;\n\tif (tnear < 0.)\n\t\ttnear = 0.;\n\n    if (hit == true)\n    {\n\t    for (float i = 0.; i < 400.; i++)\n\t    {\n\t        p = dist.y * eyeray.d + eyeray.o;\n\t    \tdist.x = step_dist + .5/abs(tnear-tfar);\n            scene(p);\n\t        dist.y += dist.x * FUDGE;\n\t    }\n    }\n\n    o.w = 1.;\n    if (hit == false)\n\t\to.xyz = vec3(.25, .25, .5+.25*floor(sin(u.x*50.)*cos(u.y*50.) ) ); \n    if (hit == true)\n\t    o.xyz += 1.-h;\n}\n\nvoid\tscene(vec3 ap)\n{\n    rotate(ap.zy, 1.*.7+iTime*1.4);\n    rotate(ap.zx, 1.*.35-iTime*1.25);\n    float\tdensity = \n\t\t-\n\t\t(\n\t\t\tlength(vec2(length(ap.xy)-.75, ap.z))-.25\n            -.2*texture(iChannel0, (ap*.25)+vec3(-iTime*.4,.0,.0)  ).x\n\t\t)\n        ;\n    density *= length( vec2( length(ap.xz*.5)-.75, ap.y*.5) )+.1*texture(iChannel0, ap*.030-iTime*.125).x;\n    float\td = min(abs(density)*1.6-.125, 1.0);\n    step_dist = d;\n    // Can't remember where I took the base formula\n    float\tT = .125;\n    {\n        float\tbrightness = exp(-.3*d+1.);\n\t\th.xyz +=\n                #ifdef INVERT_COLOR\n                1./450.-\n                #endif\n\t\t\t\t(1./450. )*(1./(density*density+.01) )\n                *\n\t\t\t\tvec3(mix(_ColorOne.xyz, _ColorTwo.xyz, clamp(density, -1., 1.)) )\n\t\t\t\t*\n\t\t\t\tT\n\t\t\t\t*\n\t\t\t\tbrightness;\n    }\n}\n\nvec3\tcam(vec2 u)\n{\n    vec3\tret;\n    \n    vec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n    ret = normalize(forw * 1. + right * u.x + up * u.y);\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    ret = max( ret, abs(p.z)+.5*abs(p.x) );\n    return ret;\n}\n","name":"Image","description":"","type":"image"}]}