{"ver":"0.1","info":{"id":"MddXDs","date":"1462314523","viewed":725,"name":"Temporal Text","username":"akohdr","description":"By tracking time and appropriately sequencing temporal primitives we can mimic simple hand printed text.\nOutput progressively slows to better show the development of each individual stroke.  Mouse resizes characters.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["2d","bezier","text","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Example showing sequencing of temporal drawing primitives to mimic hand printed text\n//\n// Font 'eidos' is more or less the same as previous examples with few ordering tweaks\n// and addition of circle starting and direction meta information.\n//\n\n// use of temporal primitives refer https://www.shadertoy.com/view/lstXDj\n#define TEMPORAL_TEXT\n#define STAGGERED\n\n// Use debug flag to colour primitives RGB\n//#define DEBUG\n\n#define INK ORG\n//#define INK GRN\n//#define LINE_WIDTH 1.1\n#define LINE_WIDTH 5.1\n\n// Select screen mode text res. size\n//#define MODE vec2(14,7)\n#define MODE vec2(26,9)\n//#define MODE vec2(40,25)\n\n// Advise full screen and/or resizing chars with mouse\n//#define MODE vec2(80,30)\n//#define MODE vec2(132,43)\n//#define MODE vec2(132,60)\n\n// For those with retina display and magnifying glass (it's there!)\n//#define MODE vec2(264,128)\n\n// Using point to line distances gives us an antialiasing pointcut we can exploit\nvoid antialias(inout vec4 k, float d, float w, vec4 K) {\n    // Standard filled antialiased lines\n//    k += K*(w-d);\n\n    // Neon glow\n    k += K/d;\n    \n\t// Partially stenciled lines \n//    k += K*sin(d-w);\n    \n    // Hollow lines (provides reasonable high res. legibility)\n//    k += K*cos(1.5+d-w);\n    \n    // Center line plus outline\n//  k += K*tan(.2+d-w);\n    \n    // Stripe filled (using screen x/y would give stable fill)\n//    k += K*max(K*cos(d-w), cos(7.*(d-w)));\n    \n    // Temporally striped and outlined\n//  k += K*max(K*cos(d-w), 1.+2.*cos(7.*(d-w)*(1.1+sin(iTime/2.))));\n    \n    // Flashing font (temporal)\n//    k += K*max(K*cos(d-w), sin(5.*iTime));\n}\n\n\n#define BLK vec4(.0,.0,.0,1.)\n#define GRY vec4(.5,.5,.5,1.)\n#define WHT vec4(1.,1.,1.,1.)\n#define RED vec4(1.,.0,.0,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n#define YEL vec4(1.,1.,.0,1.)\n#define ORG vec4(1.,.5,.0,1.)\n#define PNK vec4(1.,.0,.5,1.)\n#define MAG vec4(1.,.0,1.,1.)\n#define CYN vec4(0.,1.,1.,1.)\n#define PRP vec4(.5,.0,.5,1.)\n\nfloat dBezier1(vec2 p, vec4 ac, vec2 b);// exact  https://www.shadertoy.com/view/Mlj3zD\nfloat dBezier2(vec2 p, vec4 ac, vec2 b);// approx https://www.shadertoy.com/view/XsX3zf\n\n// Provides distance of p to quadratic bezier curve described by abc\n#define dBezier dBezier1\n\n//=============================================================================\n// The primitives.\n\n#define PI  3.14159265358979\n#define PI2 6.28318530717858\n\nvec2 rot2D(vec2 p, float a) \n{\n    vec3 csa = vec3(cos(a),-sin(a),0);\n               csa.z = -csa.y;\n    return p * mat2( csa.xyzx);\n}\n\n           \nvec2 polar(vec2 p)\n{\n    float x = p.x,  \n          y = p.y,\n          a = atan(abs(y/x)),\n          r = sqrt(x*x+y*y);\n    a = x>0. ? y>0. ?    a : PI2-a :\n               y>0. ? PI-a :  PI+a;\n                   \n\treturn vec2(r, a);    \n}\n\n\nvoid antialias(inout vec4 k, float d, float w)\n{\n    float w1 = max(.2,.5*w),\n          s  = w1/(d+2e-9);\n    \t  s += w1/(d-3e-9);\n    \n    k += vec4(1)*s;\n}\n\n\nfloat dLine(vec2 p, vec2 a, vec2 b) \n{\n    b -= a;  \n    p -= a;\n    return length (p - clamp (dot (p, b) / dot (b, b), .0, 1.) * b);\n}\n\n\nvec2 linePos(vec2 a, vec2 b, float t)\n{\n\tt = clamp(t,0.,1.);\n    vec2 d = b - a;\n    return a + t * d;\n}\n\nfloat dCircle(vec2 p, vec2 a, float r, float w)\n{\n    float w2 = w/2.,\n           l = length(p-a);\n    return (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\n}\n\n\nvec2 cirPos(vec2 a, float r, float t)\n{\n    return a+r*vec2(cos(PI2*t),sin(PI2*t));\n}\n\nfloat dCircle(vec2 p, vec2 a, float r, float w, float t, float s)\n{\n    t *=PI2;\n    vec2 pa = rot2D(p-a,abs(s)),\n        pol = polar(pa);\n    float l = length(pa),\n         w2 = w/2.;\n    \n    bool bo = s<0. ? pol.y < PI2-t : pol.y > t;\n        \n    return (pol.x>r+w || bo) ? 1e9 : \n    \t\t(l>r) ? abs((l-r)+w2) : abs((r-l)-w2);\n}\n\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c); \n\nfloat dBezierSegs(vec2 p, vec4 ac, vec2 b, float dt) {\n    float d = 9999.;\n    vec2 a = ac.xy, c = ac.zw, q = a, r;\n    \n    for(float t=0.; t<=1.; t+=.03) {\n        r = bzPos(t,a,b,c);\n        d = min(d, dLine(p,q,r));   //TODO make temporal\n        q = r;\n        if(t>dt) return d;\n    }\n    \n    return d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid bezier(inout vec4 k, vec2 p, vec4 ac, vec4 bw, vec4 K, float t) {\n    if(t<.1) return;\n#ifdef DEBUG \n    K = RED; \n#endif\n    \n#ifdef TEMPORAL_TEXT\n    float d = dBezierSegs(p,ac,bw.xy,t);\n#else\n    float d = dBezier(p,ac,bw.xy);    \n#endif\n    if(d<bw.z) antialias(k,d,bw.z,K);\n}\n\nvoid circle(inout vec4 k, in vec2 p, vec4 a, vec4 K, float t, float s) \n{\n    if(t<.1) return;\n#ifdef DEBUG \n    K = GRN; \n#endif\n    float r = a.z,\n          w = a.w,\n          w2 = w/2.,\n          l = length(p-a.xy),\t\t\t\t\t\t\t// distance from p to center\n#ifdef TEMPORAL_TEXT\n          d = dCircle(p,a.xy,r,w,t,s);\n#else\n          d = (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\t\t// distance to edge line width(w)\n#endif\n    if(d<w) antialias(k,d,w,K);\n}\n\nvoid line(inout vec4 k, vec2 p, vec4 l, float w, vec4 K, float t) \n{\n    if(t<.1) return;\n#ifdef DEBUG \n    K = BLU; \n#endif\n    vec2 a = l.xy, \n         b = l.zw;\n    \n#ifdef TEMPORAL_TEXT\n    float d = dLine(p,a,linePos(a,b,t));\n#else\n    float d = dLine(p,a,b);\n#endif \n\n    if(d<w) antialias(k,d,w,K);\n}\n\n//=============================================================================\n// We (micro)codify the control point data to drive the rendering process\n\n// input params getting unwieldy start using context struct\nstruct glyphCtx {\n    vec2 p; \t\t// fragCoord\n    vec2 s; \t\t// scale XY\n    float w; \t\t// line width\n    vec4 K;\t\t\t// colour\n    mat4 gp; \t\t// glyph microcode\n    int gw;\t\t\t// glyph width\n    float t;\t\t// time\n};\n\nvoid procGlyph(inout vec4 k, inout vec4 c, \n               glyphCtx g)\n{\n    vec2 s = g.s;\n    \n    vec4 ss = vec4(s,s);\n    bool skip = false;\n    for(int i=0;i<4;i++) {\n        if(skip) {skip = false; continue;}\n        \n        float t = g.t-float(i)/2.;\n        vec4 u = ss*g.gp[i];\n        if(u.x<0.)\n            if(u.z<0.){ // second point x \n                vec4 v = ss*g.gp[i+1]; skip = true;\n                bezier(k, g.p, vec4(-u.x,u.y,-u.z,u.w), vec4(v.xy,g.w,0.), g.K, t);\n            }\n        else\n            circle(k, g.p, vec4(-u.x,u.yz,g.w), g.K, t, u.w);\n        else\n            if(u.z>0.)   // 0 is NOP\n                line(k, g.p, u,g.w, g.K, t);\n    }\n    // advance cursor in font x direction (proportional font)\n    c.x += s.x*float(g.gw);\n}\n\n// glyph functions ============================================================\n// hanging macro (compile quicker less source noise)\n//#define PROC procGlyph(k,c,p,s,w,K,mat4(\nmat4 retMat(mat4 m, int w) { return m; }\n#define PROC retMat(mat4(\n#define Z4 0,0,0,0\n#define Z8 Z4,Z4\n\n//The 'eidos' of the font.....\n\n//#define R 6.\n#define R 8.\n//#define R 10.\n#define a_    PROC -6,-2,.8*R,-4, \tZ4,\t\t\t -2,8,-13,-8, \t16,15,0,0),\t\t20)\n#define b_    PROC 1,20,1,-7,   \tZ4,          -8,0,R,-4,   \tZ4),\t\t\t20)\n#define c_    PROC -13,5,-1,0,   \t3,12,0,0, \t -1,0,-14,-3,   -2,-12,0,0), \t22)\n#define d_    PROC -5,0,R,0,  \t\tZ4,          13,20,13,-7,   Z4), \t\t\t20)\n#define e_    PROC  -1,-2,-6,6,   \t25,2,0,0,\t -6,6,-15,-6,   -8,-10,0,0), \t22)\n#define f_    PROC -9,18,-2,-8,  \t1,25,0,0,    Z4,            1,4,9,5),\t    14)\n#define g_    PROC -7,0,R,0,   \t\tZ4,          -15,8,-1,-16,  17,-28,0,0),    22)\n#define h_    PROC 1,20,1,-8,   \tZ4,          -1,4,-14,-8,   13,15,0,0),     18)\n#define i_    PROC -2,7,-4,-6,  \t-1,-16,0,0,  Z4,            -3,13,2,0), \t10)\n#define j_    PROC -5,7,-1,-10, \t8,-25,0,0,   Z4,            -5,13,2,0), \t12)\n#define k_    PROC 1,18,1,-8,   \t13,6,1,-2,   Z4,            5,0,13,-8), \t18)\n#define l_    PROC -1,19,-6,-5,  \t0,-18,0,0,   Z8), \t\t\t\t\t\t\t12)\n#define m_    PROC -1,-9,-8,-3,   \t2,20,0,0,  \t -8,-3,-16,-9,  14,20,0,0),\t\t24)\n#define n_    PROC 1,7,1,-8,   \t\tZ4,          -1,4,-14,-8,   15,15,0,0), \t20)\n#define o_    PROC -7,0,R,-6, \t\tZ4, \t\t Z8), \t\t\t\t\t\t\t20)\n#define p_    PROC 1,7,1,-20,\t\tZ8,          -9,0,R,-4),         \t\t\t22)\n#define q_    PROC -6,0,R,0,   \t\tZ8,\t\t\t 14,7,14,-20), \t     \t\t\t20)\n#define r_    PROC 1,8,1,-7,   \t\tZ4,\t\t\t -2,3,-13,5,    11,12,0,0), \t20)\n#define s_    PROC -8,7,-6,-1,   \t-8,8,0,0,  \t -6,-1,-1,-6,   15,-11,0,0), \t14)\n#define t_    PROC -4,15,-12,-5, \t1,-15,0,0,   1,8,8,8, \t\tZ4),         \t16)\n#define u_    PROC -1,8,-13,-4,  \t0,-16,0,0,   Z4,\t\t\t14,8,14,-8), \t20)\n#define v_    PROC 1,8,6,-8,   \t\tZ4,\t\t\t 6,-8,11,8,   \tZ4), \t\t\t16)\n#define w_    PROC 1,8,4,-8,   \t\t4,-8,9,4,    9,4,14,-8,   \t14,-8,18,8), \t23)\n#define x_    PROC 1,8,8,-8,   \t\tZ8,\t\t\t 8,8,1,-8), \t\t\t\t\t12)\n#define y_    PROC -2,8,-13,-4,  \t4,-11,0,0,   -14,8,-1,-18,  14,-28,0,0), \t22)\n#define z_    PROC 1,8,8,8,   \t\t8,8,1,-8,    1,-8,8,-8,   \tZ4), \t\t\t14)\n\n#define Sp_ c.x += s.x*16.;\n#define Cr_ c.y -= s.x*35.; c.x = s.x*40.;\n\nvoid mainImage(out vec4 k, in vec2 p )\n{   \n    k = vec4(0);\n    \n    vec2 ir = iResolution.xy,\n         sc = MODE,\n         cr = ir/sc,\n          s,\n        off = cr/vec2(4.,2.),\n         mp = mod(p, ir/sc)-off;\n\n     vec4 c = vec4(floor(p/cr),0,0),\n          K = INK;\n    \n    s = (iMouse.x>0.) ? \n        3.*iMouse.xy/iResolution.xy :\n    \tvec2(.04,.02)*ir/sc;\n    \n    float ch = floor(p.x/cr.x);\n\n    // need vectored jump?!\n    mat4 gp = ch< 1. ? a_ :\n       \t      ch< 2. ? b_ :\n       \t      ch< 3. ? c_ :\n              ch< 4. ? d_ :\n      \t      ch< 5. ? e_ :\n      \t      ch< 6. ? f_ :\n       \t      ch< 7. ? g_ :\n       \t      ch< 8. ? h_ :\n       \t      ch< 9. ? i_ :\n       \t      ch<10. ? j_ :\n       \t      ch<11. ? k_ :\n       \t      ch<12. ? l_ :\n       \t      ch<13. ? m_ :\n       \t      ch<14. ? n_ :\n       \t      ch<15. ? o_ :\n       \t      ch<16. ? p_ :\n       \t      ch<17. ? q_ :\n       \t      ch<18. ? r_ :\n       \t      ch<19. ? s_ :\n       \t      ch<20. ? t_ :\n       \t      ch<21. ? u_ :\n       \t      ch<22. ? v_ :\n       \t      ch<23. ? w_ :\n       \t      ch<24. ? x_ :\n       \t      ch<25. ? y_ :\n    \t      z_;\n    \nglyphCtx ctx;\n    ctx.p = mp;\n    ctx.s = s;\n    ctx.w = LINE_WIDTH;\n    ctx.K = K;\n    ctx.gp = gp;\n    ctx.gw = 0;\t\t\t\t\t// fixed width for now....\n    \n#ifdef STAGGERED\n    ctx.t = -48.+(-2.*ch)+2.*iTime*(.7*c.y) + 6.*c.y;\n#else\n    ctx.t = (-2.*ch)+2.*iTime;\n#endif\n    \n    \n    procGlyph(k, c, ctx);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//Bezier line implementations follow\n//=============================================================================\n// derived from bezier code @ https://www.shadertoy.com/view/Mlj3zD\n#define PI 3.14159265358979\nint findRoots(vec4 abcd, out vec3 r)\n{\n    float a = abcd[0],\n    b = abcd[1],\n    c = abcd[2],\n    d = abcd[3];\n    vec3 vS = vec3(-1);\n    if (abs(a) > 1e-9){\n        \n        float z = 1./a;\n        abcd *= z;\n        a = abcd[1];\n        b = abcd[2];\n        c = abcd[3];\n        \n        float d3 = 1./3.,\n        aa = a*a,\n        d27 = 1./27.,\n        p = b-aa*d3,\n        q = a*(2.*aa-9.*b)*d27+c,\n        ppp = p*p*p,\n        D = q*q+4.*ppp*d27,\n        delta = -a*d3;\n        \n        if (D > 1e-9){\n            z = sqrt(D);\n            vec2 uv = .5*(vec2(z,-z)-q),\n            s = sign(uv);\n            uv = abs(uv);\n            float u = s.x*pow(uv.x,d3),\n            v = s.y*pow(uv.y,d3);\n            r.x = u+v+delta;\n            return 1;\n        }\n        else if (D < -1e-9){\n            float u = sqrt(-p*d3)*2.,\n            s = -sqrt(-27.0/ppp)*q*.5;\n            if (abs(s) > 0.) {}\n            r = u*cos(vec3(acos(s)*d3) + vec3(0,2,4)*PI*d3)+delta;\n            return 3;\n        }\n        else {\n            q = sign(q)*pow(abs(q)*.5,d3);\n            r.xy = vec2(-q,q)+delta;\n            r.x *= 2.;\n            return 2;\n        }\n    }\n    else {\n        if (abs(b) <= 1e-9 && abs(c) > 1e-9) {\n            r.x = -d/c;\n            return 1;\n        }\n        else {\n            float D = c*c-4.*b*d,\n            z = 1./(2.*b);\n            if (D > 1e-9) {\n                D = sqrt(D);\n                r.xy = (vec2(-D,D)-c)*z;\n                return 2;\n            }\n            else if (D > -1e-9) {\n                r.x = -c*z;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c)\n{\n    float mT = 1.-t;\n    vec2 pos = mT*mT*a+2.*t*mT*b+t*t*c;\n    return pos;\n}\n\nfloat dBezier1(vec2 p, vec4 ac, vec2 b)\n{\n    vec2 a = ac.xy,\n    c = ac.zw,\n    dap = a-p,\n    dba = b-a,\n    sac = a+c-b*2.;\n    vec3 r;\n    float dist = 999.;\n    int roots = findRoots(vec4(dot(sac,sac),\n                               dot(dba,sac)*3.,\n                               dot(dba,dba)*2.+dot(dap, sac),\n                               dot(dap,dba)),r);\n    float r1 = r.x,\n    r2 = r.y,\n    r3 = r.z;\n    if (roots > 0 && r1 >= 0. && r1 <= 1.)\n        dist = distance(p,bzPos(r1,a,b,c));\n    if (roots > 1 && r2 >= 0. && r2 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[1],a,b,c)));\n    if (roots > 2 && r3 >= 0. && r3 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[2],a,b,c)));\n    return min(dist, min(distance(p, a), distance(p, c)));\n}\n\n\n//=============================================================================\n// Alternative Bezier Implementation derived from https://www.shadertoy.com/view/XsX3zf\n// approximation shows on thicker lines when endpoints are close\n// may be useful for finer lines/small text higher speed (?)\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 bzPtInSeg( vec2 a, vec2 b ){\n    vec2 d = b - a;\n    return a + d*clamp( -dot(a,d)/dot(d,d), 0., 1. );\n}\n\nvec2 bzVec(vec2 a, vec2 b, vec2 c) {\n    float q = det(a,c),\n    r = det(b,a),\n    s = det(c,b),\n    q2 = 2.*(q + r + s);\n    if( abs(q2) < 1000. )\n        return bzPtInSeg(a,c);\n    vec2 dba = b - a,\n    dca = c - a,\n    gf = q*dca + 2.*(r*(c-b) + s*dba),\n  \t\tgs = 2.*vec2(gf.y,-gf.x),\n    d = a + (4.*r*s - q*q)*gs/dot(gs,gs);\n    \n    float t = clamp((det(d,dca) + 2.*det(dba,d)) / q2, 0. ,1.);\n    \n    return mix(mix(a,b,t),mix(b,c,t),t);\n}\n\nfloat dBezier2(vec2 p, vec4 ac, vec2 b) {\n    return length(bzVec(ac.xy-p, b-p, ac.zw-p));\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}