{"ver":"0.1","info":{"id":"fl2yWm","date":"1649800101","viewed":69,"name":"Some sort of landscape","username":"rucksack","description":"Drag mouse around to position light source.\nDidn't get the clouds quite right, and my attempt at volumetric clouds dropped the fps to *unbearable* levels.\nFollowed some of the steps in https://www.youtube.com/watch?v=BFld4EBO2RE.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// For easily pasting this into a project I'm working on\n#define time iTime\n\n// This shader is based on https://www.youtube.com/watch?v=BFld4EBO2RE\n\n// Raymarching parameters\n#define MAX_STEPS 300\n#define NEAR_ENOUGH 0.01\n#define NORMAL_EPSILON 0.01\n#define TOO_FAR 100.0\n#define UNDERSTEPPING 0.4\n\n// Lighting parameters\n#define DIFFUSE_FACTOR 1.2\n\n// Colors\n#define BACKGROUND_COLOR_BOTTOM vec3(0.35686,0.14902,0.20392)\n#define BACKGROUND_COLOR_TOP .2*vec3(0.35686,0.14902,0.20392)\n#define SHADOW_COLOR .2*vec3(0.35686,0.14902,0.20392)\n#define FOG_COLOR .6*vec3(0.95686,0.14902,0.40392)\n#define CLOUD_COLOR vec3(0.96863,0.96078,0.86667)\n\n#define PI 3.14159265359\n\n#define ROT(a)           \\\n    transpose(mat2(      \\\n         cos(a), sin(a), \\\n        -sin(a), cos(a)  \\\n    ))\n\nconst mat2 rot4 = ROT(10./42.);\n\n// Value noise thing from iq's video\n\nfloat coefficient(vec2 ij) {\n    vec2 uv = 69.*fract(ij/PI/3.);\n    return 2.*fract(uv.x*uv.y*(uv.x+uv.y))-1.;\n}\n\nfloat noise(vec2 point) {\n    float x = point.x;\n    float z = point.y;\n    // Get indices in floor grid and coefficients based on it\n    vec2 ij = floor(point.xy);\n    float a = coefficient(ij);\n    float b = coefficient(vec2(ij.x+1., ij.y));\n    float c = coefficient(vec2(ij.x, ij.y+1.));\n    float d = coefficient(ij+1.);\n\n    return a +\n        (b-a)*smoothstep(0., 1., x-ij.x) +\n        (c-a)*smoothstep(0., 1., z-ij.y) +\n        (a-b-c+d)*smoothstep(0., 1., x-ij.x)*smoothstep(0., 1., z-ij.y);\n}\n\nfloat terrain(vec2 point) {\n    float d = noise(point);\n    mat2 rot = rot4;\n    float scale = 2.;\n    // Fourier-like summation\n    for (int i = 0; i < 6; i++) {\n        d += noise(scale*rot*point)/scale;\n        scale *= 2.;\n        rot *= rot;\n    }\n    return d;\n}\n\nfloat distance_from_everything(vec3 point) {\n    point.z += time;\n    float d = point.y;\n    d += terrain(point.xz/3.)/1.;\n    return d;\n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction) {\n    // How far we've traveled\n    float d = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on\n        d += current_distance * UNDERSTEPPING;\n        // Check status - have we reached a surface?\n        if (current_distance < NEAR_ENOUGH || d > TOO_FAR)\n            break;\n    }\n    return d;\n}\n\n// Approach taken from https://iquilezles.org/articles/rmshadows\nfloat ray_shadow(vec3 ray_origin, vec3 ray_direction) {\n    // Start some distance along the rain to avoid counting shadow because we're close to the surface\n    float d = NEAR_ENOUGH;\n    float shade = 1.0;\n    float shadow_factor = 32.;\n    // Sign of the direction we're travelling,\n    // if this changes we know that we passed the light source.\n    for (int i = 0; i < MAX_STEPS/2; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on\n        d += current_distance*UNDERSTEPPING*1.5;\n        // Update to more significant shadow value\n        shade = min(shade, shadow_factor * current_distance / d);\n        // Only check if we've gone too far or gone beyond the light source\n        if (d > TOO_FAR)\n            break;\n    }\n    return max(shade, 0.);\n}\n\n// See https://iquilezles.org/articles/normalsSDF\nvec3 estimate_normal(vec3 point) {\n    vec2 e = vec2(NORMAL_EPSILON, 0); // x smol, y none\n    // Find normal as tangent of distance function\n    return normalize(vec3(\n        distance_from_everything(point + e.xyy) - distance_from_everything(point - e.xyy),\n        distance_from_everything(point + e.yxy) - distance_from_everything(point - e.yxy),\n        distance_from_everything(point + e.yyx) - distance_from_everything(point - e.yyx)\n    ));\n}\n\n\nvec3 lighting(vec3 point, vec3 camera, vec3 ray_direction, float dist) {\n    vec2 mouse = (iMouse.xy/iResolution.xy-.5)*2.;\n    // Use a light source infinitely far away instead of a point light\n    vec3 l = normalize(vec3(mouse.x, .1, mouse.y));\n    vec3 c = normalize(camera-point);\n    vec3 light;\n    if (length(point - camera) > TOO_FAR*0.99) {\n        // Draw sky\n        light = mix(BACKGROUND_COLOR_BOTTOM, BACKGROUND_COLOR_TOP, ray_direction.y);\n        // Add clouds\n        // Project raydir.xy (screen pos) onto sky plane\n        vec2 cloud_pos = vec2(0);\n        cloud_pos.x = 9. + 24.*mix(ray_direction.x, ray_direction.x/10., sqrt(max(0., ray_direction.y+.1)));\n        cloud_pos.y = 10./(ray_direction.y*.5+.5) + time*.2;\n        light += CLOUD_COLOR*.5*smoothstep(-.2, .8, terrain(cloud_pos));\n    } else {\n        vec3 n = estimate_normal(point);\n        vec3 r = reflect(-l, n);\n\n        // Material color\n        vec3 surface_color = (.2*n+.8).rbg; // color values in the range [0.6, 1.0]\n        // Mix in some snow at the mountaintops\n        surface_color = mix(surface_color, vec3(1), smoothstep(0.5, 1.5, point.y));\n\n        // Lighting color\n\n        // Standard phong lighting\n        float diffuse = max(dot(n, l), 0.);\n        light = DIFFUSE_FACTOR * diffuse * surface_color;\n\n        // Find shadow factor by marching from where you stand\n        float shade = ray_shadow(point, l);\n        // Mix in shadow\n        light = mix(SHADOW_COLOR, light, shade);\n        // Add some detail to the shadows\n        // (simulating light bouncing around to areas in shadow)\n        light += (1.+n.y)/2.*BACKGROUND_COLOR_BOTTOM/8.;\n        light += max(0., dot(n, -l))*surface_color/4.;\n\n        // Mix in fog\n        light = mix(FOG_COLOR, light, exp(-0.03*dist));\n    }\n    // Sun highlight TODO\n    //light += pow(max(0., dot(c, -l)), 16.)*vec3(0,0,1);\n    // Enhance contrast & saturation I guess\n    light = smoothstep(0., 1., light);\n    return light;\n}\n\n// From assignment template code in TDT4230\n// (really just the same random function as in the book of shaders and other places)\nfloat rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }\nfloat dither(vec2 uv) { return (rand(uv)*2. - 1.) / 512.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    // Ray origin\n    vec3 camera = vec3(2., 2.5, -4.);\n    // Ray direction\n    vec3 ray_direction = vec3(xy, 1.);\n\n    float d = ray_march(camera, ray_direction);\n    \n    vec3 point = camera + ray_direction * d;\n    \n    vec3 base_color = lighting(point, camera, ray_direction, d) + dither(fragCoord);\n\n\n    fragColor = vec4(base_color, 1.);\n}","name":"Image","description":"","type":"image"}]}