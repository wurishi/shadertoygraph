{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const vec2 charSize = vec2(8.0, 16.0);\nconst float fontSize = 32.0;\nconst int COLS = 3;\nconst int ROWS = 2;\n\nvec2 getClockPosition(int index) {\n    float col = float(index % COLS);\n    float row = float(index / COLS);\n    return vec2(\n        -1.7 + col * 1.7,  // Horizontal spacing\n        0.75 - row * 1.5    // Moved up an extra 5 points\n    );\n}\n\nfloat drawChar(vec2 pos, vec2 uv, float charCode) {\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return 0.0;\n    vec2 glyph = vec2(mod(charCode, 16.0), floor(charCode / 16.0));\n    vec2 textUV = (glyph + uv) / 16.0;\n    return texture(iChannel0, textUV).r;\n}\n\nvec3 drawClock(vec2 uv, float moveAngle) {\n    // Base arm (fixed horizontal)\n    vec2 arm1Start = vec2(0.0);\n    vec2 arm1End = vec2(0.5, 0.0);\n    \n    // Moving arm\n    vec2 arm2Start = vec2(0.0);\n    vec2 arm2End = vec2(cos(moveAngle), sin(moveAngle)) * 0.5;\n    \n    // Calculate distance to arms\n    vec2 pa1 = uv - arm1Start;\n    vec2 ba1 = arm1End - arm1Start;\n    float h1 = clamp(dot(pa1, ba1) / dot(ba1, ba1), 0.0, 1.0);\n    float d1 = length(pa1 - ba1 * h1);\n    \n    vec2 pa2 = uv - arm2Start;\n    vec2 ba2 = arm2End - arm2Start;\n    float h2 = clamp(dot(pa2, ba2) / dot(ba2, ba2), 0.0, 1.0);\n    float d2 = length(pa2 - ba2 * h2);\n    \n    float arms = smoothstep(0.02, 0.01, min(d1, d2));\n    \n    // Calculate angle and area fill\n    float angle = acos(dot(normalize(ba1), normalize(ba2)));\n    float r = length(uv - arm1Start);\n    float theta = atan(uv.y - arm1Start.y, uv.x - arm1Start.x);\n    if (theta < 0.0) theta += 2.0 * 3.14159;\n    \n    vec3 color = vec3(1.0);  // White background\n    bool isAcute = angle < 1.5707963;\n    \n    // Fill angle area with colors\n    if (r < 0.5) {\n        if (moveAngle > 3.14159) {\n            if (theta <= moveAngle && theta > 0.0) {\n                color = vec3(0.0, 1.0, 0.0);\n            }\n        } else {\n            if (theta <= moveAngle) {\n                color = isAcute ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n            }\n        }\n    }\n    \n    // Add black arms\n    color = mix(color, vec3(0.0), arms);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 3.0;  // Scale to fit all clocks\n    \n    // Use iMouse.xy for both touch and mouse input\n    vec2 inputPos = iMouse.xy;\n    bool isInputActive = iMouse.z > 0.0 || iMouse.w > 0.0;  // Check both mouse and touch\n\n    // Convert input position to same coordinate space as UV\n    vec2 normalizedPos = (inputPos - 0.5 * iResolution.xy) / iResolution.y * 3.0;\n    \n    vec3 finalColor = vec3(0.2); // Background color\n    \n    // Find the closest clock to the touch/mouse position\n    float minDist = 1000.0;\n    int selectedClock = -1;\n    \n    if (isInputActive) {\n        for (int i = 0; i < COLS * ROWS; i++) {\n            vec2 clockPos = getClockPosition(i);\n            float dist = length(normalizedPos - clockPos);\n            if (dist < minDist && dist < 0.5) {\n                minDist = dist;\n                selectedClock = i;\n            }\n        }\n    }\n    \n    // Draw each clock\n    for (int i = 0; i < COLS * ROWS; i++) {\n        vec2 clockPos = getClockPosition(i);\n        vec2 localUV = uv - clockPos;\n        \n        // Check if we're within the drawing area\n        if (length(localUV) < 0.5) {\n            float moveAngle;\n            vec2 localInput = normalizedPos - clockPos;\n            \n            // Calculate angle based on input position\n            moveAngle = atan(localInput.y, localInput.x);\n            if (moveAngle < 0.0) moveAngle += 2.0 * 3.14159;\n            \n            // Only update the angle if this clock is selected or no clock is selected\n            if (!isInputActive || i == selectedClock) {\n                vec3 clockColor = drawClock(localUV, moveAngle);\n                finalColor = clockColor;\n            } else {\n                // Keep the last angle for unselected clocks\n                vec3 clockColor = drawClock(localUV, moveAngle);\n                finalColor = clockColor;\n            }\n        }\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McyBzd","date":"1734351003","viewed":66,"name":"Acute vs Obtuse Time","username":"Chimel","description":"• Acute = Sharp Angle (< 90°) = Red\n• Obtuse = Wide Angle (> 90°) = Green\n\nOn touchscreen double tab to move angels, need to fix this\nNote, seems like the selection area is a bit too wide to control the clocks individually.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["angles","acute","obtuse"],"hasliked":0,"parentid":"","parentname":""}}