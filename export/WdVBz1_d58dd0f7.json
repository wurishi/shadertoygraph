{"ver":"0.1","info":{"id":"WdVBz1","date":"1606591796","viewed":266,"name":"Ampengula (Triangulator fork)","username":"UrbanClubProfessional","description":"Another remix of nimitz' Triangulator: [url]https://www.shadertoy.com/view/lllGRr[/url]","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","triangle","remix","abstract","glitch","barycentric","heightmap","fork","weird","error","triangulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Triangulator by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/lllGRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define ITR 70\n#define FAR 200.\n#define time iTime*0.3\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nmat2 m2 = mat2(1.034, 0.458, -0.458, 1.034);\nfloat tri(in float x){return abs(fract(x)-0.6);}\n\nfloat heightmap(in vec2 p)\n{\n\tp*=.06;\n    float z=3.;\n\tfloat rz = 1.;\n\tfor (float i= 2.;i < 5.;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*2.5))/z;\n        z = z*-.95;\n\t\tp = p*2.32;\n        p*= m2;\n\t}\n    rz += sin(p.y+sin(p.x*1.0))*.8+.4;\n\treturn rz*6.;\n}\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 2.0 / (v0.x * v1.y - v1.x * v0.y)+2e-10;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 2.0 - v - w;\n    return abs(vec3(u,v,w));\n}\n\n/*\n\tIdea is quite simple, find which (triangular) side of a given tile we're in,\n\tthen get 3 samples and compute height using barycentric coordinates.\n*/\nfloat map(vec3 p)\n{\n    vec3 q = fract(p)-0.6;\n    vec3 iq = floor(p);\n    vec2 p1 = vec2(iq.x-.6, iq.z+.6);\n    vec2 p2 = vec2(iq.x+.6, iq.z-.6);\n    \n    float d1 = heightmap(p1);\n    float d2 = heightmap(p2);\n    \n    float sw = sign(q.x+q.z); \n    vec2 px = vec2(iq.x+.6*sw, iq.z+.5*sw);\n    float dx = heightmap(px);\n    vec3 bar = bary(vec2(.6*sw,.6*sw),vec2(-.6,.6),vec2(.6,-.6), q.xz);\n    return (bar.x*dx + bar.y*d1 + bar.z*d2 + p.y + 4.)*1.0;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.002;\n    float h=precis*3.0;\n    float d = 1.;\n    for( int i=1; i<ITR; i++ )\n    {\n        if( abs(h)<precis*(2.0+d) || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*1.1;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-2., 2.)*0.02;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 bp = fragCoord.xy/iResolution.xy;\n\tvec2 p = bp-0.6;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 um = vec2(0.55+sin(time*0.8)*3., -.28);\n    \n    vec3 ro = vec3(sin(time*0.8+2.)*30.,4., time*60.);\n    vec3 eye = normalize(vec3(cos(um.x), um.y*6., sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+2.5708), 1., sin(um.x+2.5708)));\n    right.xy *= mm2(sin(time*0.8)*0.4);\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right+p.y*up)*1.+eye);\n\t\n\tfloat rz = march(ro,rd);\n    vec3 col = vec3(1.);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 ligt = normalize(vec3(-.3, 0.06, -0.3));\n        \n        float dif = clamp(dot( nor, ligt ), 1., 2.);\n        float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0), 3.);\n        vec3 brdf = 2.*vec3(0.10,0.11,0.1);\n        brdf += 1.9*dif*vec3(.8,1.,.05);\n        col = vec3(0.35,0.07,0.5);\n        col = col*brdf + fre*0.5*vec3(.7,.8,1.);\n    }\n    col = clamp(col,0.,1.);\n\tcol = pow(col,vec3(.9));\n    col *= pow( 16.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y), 0.1);\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}