{"ver":"0.1","info":{"id":"4tVBzz","date":"1541636040","viewed":497,"name":"Ames Window illusion","username":"Observer","description":"Do you see the an oscillating window frame with bars acting really weird?\nEven if you understand the illusion, you cannot 'unsee' it... \nMouse.x: Angle, Mouse.y: Opacity","likes":10,"published":1,"flags":32,"usePreview":1,"tags":["raytracing","raymarching","illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ames Window illusion\n// Do you see the an oscillating window frame with bars acting really weird...\n// Even if you understand the illusion, you cannot 'unsee' it... \n// Mouse.x: Angle, Mouse.y: Opacity\n\n// Based on IQ's primitives (https://www.shadertoy.com/view/Xds3zN)\n\n// Image raytraces a plane with Buf A texture and raycasts some bars\n\n#define AA 4   // make this 1 is your machine is too slow\n\n\n//------------------------------------------------------------------\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n\tvec2 res = vec2(1000.0, 0.0);\n   \n    res = opU( res, vec2( sdBox(pos - vec3(0.0, -0.67, -0.2), vec3(1.0, 0.1, 0.1)), 1.0 ) );\n    res = opU( res, vec2( sdBox(pos - vec3(0.0, 0.55, 0.55), vec3(1.0, 0.1, 0.1)), 2.0 ) );\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.2;\n    float tmax = 30.0;\n\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.001*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x < precis || t > tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    \n    // Raytrace the rotating plane\n    vec3 colPlane = vec3(0.0);\n    float t1 = -ro.x / rd.x;\n    float a = 0.0;\n    vec3 pos = ro + t1 * rd;\n    float f = iMouse.z > 0.5 ? iMouse.y / iResolution.y : 0.0;\n    if (abs(pos.y) <= 1.5 && abs(pos.z) <= 2.5)\n    {\n        vec4 res = texture(iChannel0, pos.zy * vec2(0.1025, 0.317) + vec2(0.524, 0.5));\n        colPlane = res.rgb;\n        vec3 grd = pos * 2.0;\n        \n        // Add grid\n        grd = abs(round(grd) - grd);\n        colPlane = mix(colPlane, vec3(pow(grd.y + 0.5, 120.0) + pow(grd.z + 0.5, 120.0)), f); \n        a = mix(res.a, 1.0, f);\n    }\n    \n\t// Raycast the rest\n    vec3 col = colPlane;\n    vec2 res = castRay(ro,rd);\n    float t2 = res.x;\n\tfloat m = res.y;\n    if( m>-0.5)\n    {\n        vec3 pos = ro + t2*rd;\n        \n        // material\n        col = vec3(m, m - 1.0, 0.7);\n        vec3 nor = calcNormal( pos );\n        \n        vec3  lig = normalize( vec3(0.6, 10.0, -0.2) );\n        col = col * (dot(nor, lig) + 0.4);\n        if (t1 < t2) col = mix(col, colPlane, a);\n\n        a = 1.0;\n    }\n\n\treturn mix(vec3(0.2, 0.5, sin(rd.y * 20.0)), clamp(col,0.0,1.0), a);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\n        float ang = iMouse.z > 0.5 && iMouse.x > 20. ? iMouse.x * 7.0 / iResolution.x : iTime * 0.4;\n        float dist = 20.0;\n        vec3 ro = vec3( cos(ang) * dist, -0.1, sin(ang) * dist);\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy, 10.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n    //fragColor = vec4( texture(iChannel0, fragCoord / iResolution.xy));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Ames Window illusion\n// Do you see the an oscillating window frame with bars acting really weird...\n// Even if you understand the illusion, you cannot 'unsee' it... \n// Mouse.x: Angle, Mouse.y: Opacity\n\n// Based on IQ's primitives (https://www.shadertoy.com/view/Xds3zN)\n\n// Buf A renders a straight window frame seen from an angle\n\n#define AA 3   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n\tvec2 res = vec2(1000.0, 0.0);\n    \n    pos += vec3(-1.0, 0.1, 0.0);\n    res = opU( res, vec2( sdBox( pos - vec3( 0.0, -1.0, 0.0), vec3(0.1, 0.1, 2.2) ), 3.0 ) );\n    res = opU( res, vec2( sdBox( pos - vec3( 0.0, 0.0, 0.0), vec3(0.1, 0.1, 2.2) ), 3.0 ) );\n    res = opU( res, vec2( sdBox( pos - vec3( 0.0, 1.0, 0.0), vec3(0.1, 0.1, 2.2) ), 3.0 ) );\n\n    \n    res = opU( res, vec2( sdBox( pos - vec3( 0.0, 0.0, 2.0), vec3(0.1, 1.1, 0.2) ), 3.0 ) );\n    res = opU( res, vec2( sdBox( pos - vec3( 0.0, 0.0, 0.666), vec3(0.1, 1.1, 0.1) ), 3.0 ) );\n    res = opU( res, vec2( sdBox( pos - vec3( 0.0, 0.0, -0.666), vec3(0.1, 1.1, 0.1) ), 3.0 ) );\n    res = opU( res, vec2( sdBox( pos - vec3( 0.0, 0.0, -2.0), vec3(0.1, 1.1, 0.2) ), 3.0 ) );\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.2;\n    float tmax = 20.0;\n\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<30; i++ )\n    {\n\t    float precis = 0.001*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{ \n\tvec3 col = vec3(0.0);\n    float alpha = 0.0;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material\n        vec2 uv = abs(nor.x) > abs(nor.y) && abs(nor.x) > abs(nor.z) ? pos.zy :\n           abs(nor.y) > abs(nor.z) ? pos.xz : pos.yx;\n        \n\t\tcol = texture(iChannel0, uv * vec2(0.5, 2.0)).rgb;\n        alpha = 1.0;\n\n        // lighting        \n\t\tvec3  lig = normalize( vec3(0.5, 1.0, 1.0) );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.60*dif + 0.5;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec4( clamp(col,0.0,1.0), alpha );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec4 tot = vec4(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\n        float ang = 0.8;\n        float dist = 5.0;\n        vec3 ro = vec3( cos(ang) * dist, -0.1, sin(ang) * dist);\n        vec3 ta = vec3( 0.0, -0.1, 0.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy, 2.2) );\n\n        // render\t\n        vec4 col = render( ro, rd );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = tot;\n}","name":"Buffer A","description":"","type":"buffer"}]}