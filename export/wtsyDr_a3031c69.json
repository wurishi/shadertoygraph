{"ver":"0.1","info":{"id":"wtsyDr","date":"1591884708","viewed":129,"name":"multiple gears ⚙⚙⚙","username":"HaleyHalcyon","description":"aoeuaoeua","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["aoeuaoeu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nfloat remap(float x, float lowIn, float rangeIn, bool invert)\n{\n    float o = clamp(clamp(x - lowIn, 0., rangeIn) / rangeIn, 0., 1.);\n    if (invert) {\n        return 1. - o;\n    }\n    return o;\n}\n\nvec3 blend(vec3 x1, vec3 x2, float factor)\n{\n    return x2 * factor + x1 * (1. - factor);\n}\n\nfloat zigzag(float x)\n{\n    return abs(1. - mod(x, 2.0));\n}\n\nfloat timeBounce(float x)\n{\n    return -3. * sin(PI * x) + x;\n}\n\nfloat gear(float x, float y, float rot, float scale, float teethCount, float spokeCount, float center, float inner, float outer)\n{\n    // constants\n    float d = sqrt(x*x+y*y);\n    float theta = atan(y, x) + rot;\n    // teeth\n    const float teethWidth = 0.3; // from 0.0 to 1.0\n    const float teethSlant = 0.2; // purely radial sides don't look right\n    const float teethSmoothing = 0.06;\n    // spokes\n    const float spokeWidth = 0.08; // from 0.0 to 1.0\n    const float spokeSlant = 0.3; // purely radial sides don't look right\n    const float spokeSmoothing = 0.04;\n    // radii\n    // const float scale = 0.5; // total size of the gear\n    const float smoothing = 0.02; // radial; teeth and spoke smoothing are defined separately\n    //const float center = 0.2; // spokes start here\n    //const float inner = 0.5; // spokes end here\n    //const float outer = 0.75; // teeth start here\n    \n    d /= scale;\n    \n    if (d < center) {\n        return 1.;\n    } else if (d < inner) {\n        float slant = remap(\n                    d, center, inner + smoothing - center, true\n                );\n        return clamp(\n            remap(d, center, 0.25 * smoothing, true) // center smoothing (quarter)\n            +\n            remap( // spokes\n                1. - zigzag(theta / PI * spokeCount) - slant * slant * spokeSlant,\n                spokeWidth,\n                spokeSmoothing,\n                true\n            )\n            +\n            remap(\n                d,\n                inner - smoothing,\n                smoothing,\n                false\n            )\n        , 0., 1.);\n    } else if (d < outer) {\n        return 1.;\n    } else if (d < 1.) {\n        return clamp(\n            min(\n                remap(d, outer, smoothing, true) // ring smoothing\n                +\n                remap( // teeth\n                    1. - zigzag(theta / PI * teethCount) - remap(\n                        d, outer, 1. + smoothing - outer, true) * teethSlant,\n                    teethWidth,\n                    teethSmoothing,\n                    true\n                )\n            ,\n                remap( // smooth outer rim of gear\n             \t\td,\n                    1. - 2. * smoothing, // smooth double for outside\n                    smoothing,\n                    true\n                )\n            )\n        , 0., 1.);\n    }\n    return 0.;\n}\n\nfloat tick(float t){\n    const float ticksPerRot = 24.0;\n    const float tickLength = 0.125;\n    const float tickPeriod = 1.;\n    t += 0.5 * tickLength + 0.5 * tickPeriod;\n    return (\n        floor(t / tickPeriod) + smoothstep(0., 1., (mod(t / tickPeriod, 1.) - 0.5) / tickLength)\n \t\t) / ticksPerRot\n    ;\n}\n  \nfloat spiral(float x) {\n  return max(0.0, sin(x) * 0.75 + 0.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  // colors\n  const vec3 colorBase = vec3(0.2, 0.3, 0.5);\n  const vec3 colorGear = vec3(0.9, 0.95, 0.95);\n\n  // more params for the ticking inside the tick() function\n  float time = tick(iTime);\n\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale * 1.41421356;\n  \n  float angle = atan(uv.y, uv.x);\n\n  // Time varying pixel color\n  float cGear = gear(uv.x, uv.y, 2. * PI * time, 0.3, 8., 4., 0.2, 0.5, 0.75);\n  // add another gear\trotation speed & offset--v                       v--size\n  cGear += gear(uv.x - 0.49, uv.y - 0.19,  0.42 + -2. * PI * time,        0.3, 8., 4., 0.2, 0.5, 0.75);\n  cGear += gear(uv.x + 0.19, uv.y - 0.49,  0.42 + -2. * PI * time,        0.3, 8., 4., 0.2, 0.5, 0.75);\n  cGear += gear(uv.x - 0.27, uv.y + 0.35, 0.6 + -2. * PI * time * 4./3., 0.2, 6., 4., 0.15, 0.4, 0.7);\n  cGear += gear(uv.x + 0.52, uv.y + 0.34,  0.34 + -2. * PI * time * 2./3., 0.4, 12., 6., 0.2, 0.6, 0.8);\n  \n  vec3 colBase = colorBase;\n  vec3 colComp = blend(colBase, colorGear, cGear);\n\n  // Output to screen\n  fragColor =\n    vec4(\n        colComp\n      , 1.\n    );\n}","name":"Image","description":"","type":"image"}]}