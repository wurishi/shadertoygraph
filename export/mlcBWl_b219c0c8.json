{"ver":"0.1","info":{"id":"mlcBWl","date":"1701765041","viewed":90,"name":"Height Blend Switch","username":"gehtsiegarnixan","description":"This shader showcases a method to alternate between samples using a height and weight value. ","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["mix","contrast","barycentric","lerp","blend","height","interpolation","interpolation","bilinear","heightblend"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis shader demonstrates a cost-effective height blend method. It alternates \nbetween samples based on the combination of weights and heights. It requires \nonly one sample, but it would be desirable to have a smooth variant of this, \neven if it requires more samples.\n\nHeight interpolation is a common technique in computer graphics used to blend\nsamples (typically texture colors) based on their height information. Heightmaps\nassociated with each sample introduce a bias to the blending weight, resulting\nin a more natural transition between textures. Regardless of height at 100% \nweight, a sample is fully visible, and at 0% weight, it's entirely hidden.\n\nThe three columns from left to right demonstrate linear (2 value), barycentric \n(3 value), and bilinear (4 value) interpolation. This shader allows mouse control \nfor you to enlarge one of the columns by moving the X-axis to the column center. \nGlobal constants below further enhance control and alternate views.\n\nFor background reading, consider reading my source at:\nhttps://playerunknownproductions.net/news/stochastic-texturing\n\nOr see my biom texture shuffle for a shader where this could be used:\nhttps://www.shadertoy.com/view/dsVyRw\n*/\n\n// Enable to show the weights (Alpha); disable to show albedo\n#define SHOWWEIGHTS\n\n// Uncomment and set height values; heights should be in the range of 0-1\n// Linear interpolation is XY, barycentric is XYZ, and bilinear is XYZW\n//#define HEIGHT vec4(1.0, 1.0, 1.0, 1.0)\n\n// switch between 2 samples using height bias\n// https://www.desmos.com/calculator/3yoqgulaww\nvec3 heightSwitch(vec2 gridUV, vec2 detailUV) {\n    // Calculate zigzag linear weight\n    float weight = abs(fract(gridUV.y) * 2.0 - 1.0);\n    \n    // Split the weight into two components\n    vec2 weights = vec2(1.0 - weight, weight);\n\n    // Choose between using constant height values or sampling heightmaps\n    #ifdef HEIGHT\n        // Use constant height values\n        vec2 height = HEIGHT.xy;\n    #else\n        // Sample heightmaps\n        float heightA = texture(iChannel0, detailUV).x;\n        float heightB = texture(iChannel1, detailUV).x;\n        \n        // Combine heights\n        vec2 height = vec2(heightA, heightB);\n    #endif\n\n    // add bounds to height so nothing odd happens at 0. or 1.\n    height = clamp(height, 0.01, 0.99);\n    \n    // scale heights with their weight\n    vec2 sHeight = height * weights;\n    \n    // Debug view of weight\n    #ifdef SHOWWEIGHTS\n        // Height switch\n        if (sHeight.x > sHeight.y) {        \n            return vec3(1.,0.,0.);\n        } else {\n            return vec3(0.,0.,0.);\n        }\n    #endif\n\n    // Height switch to alternate texture sample\n    if (sHeight.x > sHeight.y) {        \n        return texture(iChannel0, detailUV).xyz;\n    } else {\n        return bone(texture(iChannel1, detailUV).x);\n    }\n}\n\n// switch between 3 samples using height bias\nvec3 baryHeightSwitch(vec2 gridUV, vec2 detailUV) {\n    // Create zigzag tiling for UVs\n    gridUV = abs(fract(gridUV) - 0.5) * 2.0;\n\n    // Calculate barycentric weights for a square pattern\n    vec3 weights = baryWeights(gridUV);\n\n    // Choose between using constant height values or sampling heightmaps\n    #ifdef HEIGHT\n        // Use constant height values\n        vec3 height = HEIGHT.xyz;\n    #else\n        // Sample heightmaps\n        float heightA = texture(iChannel0, detailUV).x;\n        float heightB = texture(iChannel1, detailUV).x;\n        float heightC = texture(iChannel2, detailUV).y;\n\n        // Combine heights\n        vec3 height = vec3(heightA, heightB, heightC);\n    #endif\n    \n    // add bounds to height so nothing odd happens at 0. or 1.\n    height = clamp(height, 0.01, 0.99);\n    \n    // scale heights with their weight\n    vec3 sHeight = height * weights;\n\n    // Debug view of weights\n    #ifdef SHOWWEIGHTS\n        // Height switch\n        if (sHeight.x > sHeight.y && sHeight.x > sHeight.z) {\n            return vec3(1.,0.,0.);\n        } else if (sHeight.y > sHeight.z) {\n            return vec3(0.,1.,0.);\n        }\n        return vec3(0.,0.,1.);\n    #endif    \n\n    // Height switch\n    if (sHeight.x > sHeight.y && sHeight.x > sHeight.z) {\n        return texture(iChannel0, detailUV).xyz;\n    } else if (sHeight.y > sHeight.z) {\n        return bone(texture(iChannel1, detailUV).x);\n    } else {\n        return texture(iChannel2, detailUV).xyz; \n    }\n}\n\n// switch between 4 samples using height bias\nvec3 bilinearHeightSwitch(vec2 gridUV, vec2 detailUV) {   \n    // Create zigzag tiling for UVs\n    gridUV = abs(fract(gridUV) - 0.5) * 2.0;\n    \n    // Calculate vanilla bilinear weights\n    vec4 weights = bilinearWeights(gridUV);\n    \n    // Choose between using constant height values or sampling heightmaps\n    #ifdef HEIGHT\n        // Use constant height values\n        vec4 height = HEIGHT;\n    #else\n        // Sample heightmaps\n        float heightA = texture(iChannel0, detailUV).x;\n        float heightB = texture(iChannel1, detailUV).x;\n        float heightC = texture(iChannel2, detailUV).y;\n        float heightD = texture(iChannel3, detailUV).x;\n        \n        // Combine heights\n        vec4 height = vec4(heightA, heightB, heightC, heightD);\n    #endif\n        \n    // add bounds to height so nothing odd happens at 0. or 1.\n    height = clamp(height, 0.01, 0.99);\n    \n    // scale heights with their weight\n    vec4 sHeight = height * weights; \n    \n    // Debug view of weights\n    #ifdef SHOWWEIGHTS    \n        // Height switch\n        if (sHeight.x > sHeight.y && sHeight.x > sHeight.z && sHeight.x > sHeight.w) {\n            return vec3(1.,0.,0.);\n        } else if (sHeight.y > sHeight.z && sHeight.y > sHeight.w) {\n            return vec3(0.,1.,0.);\n        } else if (sHeight.z > sHeight.w) {\n            return vec3(0.,0.,1.);    \n        }\n        return vec3(0.,0.,0.);\n    #endif\n     \n    // Height switch\n    if (sHeight.x > sHeight.y && sHeight.x > sHeight.z && sHeight.x > sHeight.w) {\n        return texture(iChannel0, detailUV).xyz;\n    } else if (sHeight.y > sHeight.z && sHeight.y > sHeight.w) {\n        return bone(texture(iChannel1, detailUV).x);\n    } else if (sHeight.z > sHeight.w) {\n        return texture(iChannel2, detailUV).xyz;\n    } else {\n        return texture(iChannel3, detailUV).xyz;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    // Calculate UVs for the x-axis of the window\n    vec2 uv = fragCoord / iResolution.x;\n    \n    // Calculate UVs for the blend grids\n    vec2 gridUV = uv * 3.0;\n    \n    // Calculate UVs for the detail texture\n    vec2 detailUV = uv * 7.0;\n    \n    // Create a float to divide into sections for comparisons\n    float comparisonX = uv.x * 3.0;\n\n    // Enable mouse controls when clicked; otherwise, animate\n    float pointer;\n    if (iMouse.x > 0.0) {\n        // Mouse controls\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        pointer = mouse.x * 3.0;\n    } else {\n        // Animation when no mouse input is used\n        float myTime = iTime * 1.0;\n        // pointer = fract(iTime * 0.05) * 3.0;\n    }\n    \n    // Create zigzag weights\n    float weight = abs(fract(pointer - 0.5) * 2.0 - 1.0);\n    \n    // make transitions deadzones for easier use\n    weight = straightContrast(weight, 2.);\n            \n    // Define default edge locations for the columns\n    vec2 columnEdges = vec2(1.0, 2.0); \n    \n    // Mouse-controlled animations to zoom into the columns    \n    vec2 zoomColumnEdges = columnEdges;\n    if (pointer <= 1.0) {\n        // Zoom into the left side        \n        zoomColumnEdges = vec2(2.8, 2.9);\n    } else if (pointer <= 2.0) {\n        // Zoom into the center column\n        zoomColumnEdges = vec2(0.1, 2.9);\n    } else {\n        // Zoom into the right column\n        zoomColumnEdges = vec2(0.1, 0.2);\n    }\n\n    // Interpolate between default column edge positions and zoom\n    columnEdges = mix(columnEdges, zoomColumnEdges, weight);    \n    \n    // Choose interpolation method based on the x-coordinate\n    vec3 color;\n    if (comparisonX <= columnEdges.x) {\n        // Left side\n        color = heightSwitch(gridUV, detailUV);\n                        \n    } else if (comparisonX <= columnEdges.y) {\n        // Center section\n        color = baryHeightSwitch(gridUV, detailUV);\n        \n    } else {\n        // Right side        \n        color = bilinearHeightSwitch(gridUV, detailUV);\n    }\n    \n    // Add lines between columns\n    float BorderThickness = 0.004;    \n    color += step(abs(comparisonX - columnEdges.x), BorderThickness);\n    color += step(abs(comparisonX - columnEdges.y), BorderThickness);\n    \n    // Add arrows pointing at the center of columns\n    color += step(uv.y + abs(fract(comparisonX)-0.5), BorderThickness*5.);\n        \n    // Set the output color\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//_____________________________Generic Functions________________________________\n\n// Linearly increases contrast of Alpha\n// See: https://www.desmos.com/calculator/k1g3naqoue\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// make square tiling of barycentric weights\nvec3 baryWeights(vec2 uv) {\n    // make individual weights for pattern\n    float weightA = min(uv.x, uv.y);\n    float weightB = min(1.-uv.x, 1.-uv.y);\n    float weightC = 1. - weightA - weightB;\n    \n    // Join weights together\n    return vec3(weightA, weightB, weightC);\n}\n\n// make mirroring bilinear tiling weights\nvec4 bilinearWeights(vec2 uv) {    \n    // Invert coords as a partial of the weights\n    vec2 invUV = 1.0 - uv;\n\n    // Generate alpha values (weights) for bilinear interpolation.\n    float weightA = uv.x * uv.y;\n    float weightB = uv.x * invUV.y;\n    float weightC = invUV.x * uv.y;\n    float weightD = invUV.x * invUV.y;\n    \n    // Combine weight/alpha values. \n    return vec4(weightA, weightB, weightC, weightD);\n}\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes bone colormap with polynimal 6\nvec3 bone(float t) {\n    const vec3 c0 = vec3(-0.005007,-0.003054,0.004092);\n    const vec3 c1 = vec3(1.098251,0.964561,0.971829);\n    const vec3 c2 = vec3(-2.688698,-0.537516,2.444353);\n    const vec3 c3 = vec3(12.667310,-0.657473,-8.158684);\n    const vec3 c4 = vec3(-27.183124,8.398806,10.182004);\n    const vec3 c5 = vec3(26.505377,-12.576925,-5.329155);\n    const vec3 c6 = vec3(-9.395265,5.416416,0.883918);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}","name":"Common","description":"","type":"common"}]}