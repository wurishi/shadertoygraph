{"ver":"0.1","info":{"id":"tdlBRj","date":"1588662783","viewed":504,"name":"stereographic 3d","username":"matthen","description":"stereographic 3d","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["stereographic3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\n// reference: https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p, vec4 n )\n{\n\t// n must be normalized\n\treturn dot( p, n.xyz ) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec3 translate( vec3 v, vec3 t )\n{\n\treturn v - t;\n}\n\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n\nvec3 reverseProj(in vec3 p) {\n    float r = dot(p.xz, p.xz);\n    \n    return vec3(\n    \tp.x * (1. - (3. + r)/(9. + r)),\n        (3. * (3. + r))/(9. + r),\n        p.z * (1. - (3. + r)/(9. + r))\n    );\n}\n\nvec3 proj(in vec3 p) {\n    float yy = 3. - p.y;\n    return vec3(\n        p.x * (1. - p.y / yy),\n        3. * p.y / yy + p.y * (1. - p.y / yy),\n        p.z * (1. - p.y / yy)\n    );\n}\n\nvec3 sphericalCentre(in vec3 a, in vec3 b) {\n    vec3 centre = .5 * (a +  b);\n    centre -= vec3(0, 2, 0);\n    centre = normalize(centre);\n    centre += vec3(0, 2, 0);\n    return centre;\n}\n\nfloat makeHole(in vec2 p, in vec3 pos, in float d) {\n    vec3 p1 = reverseProj(vec3(p.x, 0., p.y + 0.5));\n    vec3 p2 = reverseProj(vec3(p.x, 0., p.y - 0.5));\n    vec3 centre = sphericalCentre(p1, p2);\n    float r = length(p1 - centre);\n    float hole = sdSphere(translate(pos, centre), 0.9 * r);\n    return opS(hole, d);\n}\n\nfloat makeCut(in vec3 p, in vec3 pos, in float d) {\n    vec3 pp = reverseProj(p);\n    vec3 np = vec3(0., 3., 0.);\n    vec3 centre = sphericalCentre(np, pp);\n    float r = length(pp - centre);\n    float hole = sdSphere(translate(pos, centre), r);\n    return opS(hole, d);\n    \n}\n\nfloat scene( in vec3 pos )\n{\n\tvec4 plane = vec4( 0.0, 1.0, 0.0, 0.0 ); // xyz, d\n\tfloat dPlane = sdPlane( pos, plane );\n    \n    pos -= vec3(0., 2., 0.);\n    float t = mod(iTime, 18.);\n    float theta = 0.9 * sin(2.09 * t);\n    theta *= (smoothstep(6., 7., t) - smoothstep(8., 9., t));\n    pos = rotation(pos, vec3(1., 0., 0.), theta);\n    pos += vec3(0., 2., 0.);\n    \n\n\tfloat sphere = sdSphere( translate( pos, vec3(0., 2., 0.)), 1. );\n\tfloat innerSphere = sdSphere( translate( pos, vec3(0., 2., 0.)), 0.99);\n\t\n    float hole1 = sdSphere( translate( pos, vec3(0., 3., 0.)), 0.6);\n    float hole2 = sdSphere( translate( pos, vec3(0., 1., 0.)), 0.6);\n    \n    float d =  opS(hole1, opS(innerSphere, sphere));\n    float w = 3.;\n    for (float i = -w; i <= w; i++) {\n        for (float j = -w; j <= w; j++) {\n        \td = makeHole(vec2(i, j), pos, d);\n        }\n    }\n    \n    w += 0.7;\n    d = makeCut(vec3(w, 0., 0.), pos, d);\n    d = makeCut(vec3(-w, 0., 0.), pos, d);\n    d = makeCut(vec3(0., 0., w), pos, d);\n    d = makeCut(vec3(0., 0., -w), pos, d);\n    \n   \t\n\treturn opU(dPlane, d);\n}\n\n// calculate scene normal using forward differencing\nvec3 sceneNormal( vec3 pos, float d )\n{\n    float eps = 0.001;\n    vec3 n;\n\t\n    n.x = scene( vec3( pos.x + eps, pos.y, pos.z ) ) - d;\n    n.y = scene( vec3( pos.x, pos.y + eps, pos.z ) ) - d;\n    n.z = scene( vec3( pos.x, pos.y, pos.z + eps ) ) - d;\n\t\n    return normalize(n);\n}\n\nbool raymarch( Ray ray, out vec3 hitPos, out vec3 hitNrm )\n{\n\tconst int maxSteps = 256;\n\tconst float hitThreshold = 0.00001;\n\n\tbool hit = false;\n\thitPos = ray.org;\n\n\tvec3 pos = ray.org;\n\n\tfor ( int i = 0; i < maxSteps; i++ )\n\t{\n\t\tfloat d = scene( pos );\n\n\t\tif ( d < hitThreshold )\n\t\t{\n\t\t\thit = true;\n\t\t\thitPos = pos;\n\t\t\thitNrm = sceneNormal( pos, d );\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * ray.dir;\n\t}\n\treturn hit;\n}\n\n\nfloat shadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n\tfloat t = mint;\n    for ( int i = 0; i < 64; ++i )\n    {\n        float h = scene( ro + rd * t );\n        if ( h < 0.001 && i > 0) {\n            return 0.2;\n        }\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return 1.0;\n}\n\n\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.0;\n   \tfloat vis = shadow( pos, toLight, 0.01, toLightLen );\n\n\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n        comb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// fragCoord: location (0.5, 0.5) is returned \n\t// for the lower-left-most pixel in a window\n\t\n\t// XY of the normalized device coordinate\n\t// ranged from [-1, 1]\n    float t = iTime;\n    t = mod(t, 18.);\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 scaledXY = ndcXY * vec2( aspectRatio, 1.0 );\n\t\n\t// camera XYZ in world space\n\tvec3 camWsXYZ = vec3( 0.0, 2.2, 2.0 );\n    \n   camWsXYZ.y -= smoothstep(3., 6., t);\n    \n\tcamWsXYZ.z += 3. * smoothstep(3., 6., t);\n\tcamWsXYZ.y *= (1. - smoothstep(10., 12., t))\n        ;\n    camWsXYZ.y += 2.2 * smoothstep(13., 15., t);\n    camWsXYZ.z *= (1. - smoothstep(13., 15., t));\n    camWsXYZ.z += smoothstep(13., 15., t) * 2.;\n    \n    \n\t// construct the ray in world space\n\tRay ray;\n\tray.org = camWsXYZ;\n\tray.dir =  normalize(vec3( scaledXY, -1 )); // OpenGL is right handed\n    \n    float theta = -0.3 + 0.7 * smoothstep(3., 6., t);\n    \n    theta += (1.57 - 0.4) * smoothstep(10., 12., t);\n    theta *= (1. - smoothstep(13., 15., t));\n    theta += smoothstep(13., 15., t) * (-0.3);\n    \n    ray.dir = rotation(ray.dir, vec3(1., 0., 0.), theta);\n    ray.org = rotation(ray.org, vec3(1., 0., 0.), theta);\n    \n    theta = -0.71 + 2.28 * smoothstep(6., 9., t);\n    theta -= smoothstep(13., 18., t) * 2.28;\n    ray.dir = rotation(ray.dir, vec3(0., 1., 0.), theta);\n    ray.org = rotation(ray.org, vec3(0., 1., 0.), theta);\n\t\n\t// define the point light in world space (XYZ, range)\n\tvec4 light1 = vec4( 0.0, 0., 0.0, 8.0 );\n    light1.y = 7. - 4. * (\n        smoothstep(0., 2.8, t)\n        -  smoothstep(13., 18., t));\n    \n    vec4 light2 = vec4( 1.0, 2.0, 4.2, 9.0 );\n\t\n\tvec3 sceneWsPos;\n\tvec3 sceneWsNrm;\n\t\n\tif ( raymarch( ray, sceneWsPos, sceneWsNrm ) )\n\t{\n\t\t// our ray hit the scene, so shade it with 2 point lights\n\t\tvec3 shade1 = shade( sceneWsPos, sceneWsNrm, light1 );\n        vec3 shade2 = shade( sceneWsPos, sceneWsNrm, light2 );\n        \n\t\tvec3 shadeAll = \n\t\t\t  0.8 * shade1 * vec3( 0.5, 0.5, 0.8 )\n\t\t\t+  0.5 * shade2 * vec3( 0.5, 0.5, 1.0 );\n\t\t\n\t\tfragColor = vec4( shadeAll, 1.0 );\n\t}\n\telse\n\t{\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t}\n    \n    if (sceneWsPos.y < 0.01) {\n    \tfragColor.rgb += vec3(0.1, 0.3, 0.3);   \n    }\n    \n    // point source of light.\n    float flare = dot(normalize(ray.dir), normalize(light1.xyz - ray.org));\n    fragColor += 0.6 * smoothstep(0.999, 1., pow(flare, 2.));\n    fragColor += 0.4 * smoothstep(0.97, 0.9999, pow(flare, 0.5));\n    \n    \n}\n","name":"Image","description":"","type":"image"}]}