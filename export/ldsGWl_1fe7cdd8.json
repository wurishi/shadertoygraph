{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Last time I blabber on about raymarching being fixed point iteration, I promise! (I think)\n\n// In my last shader I observed that ray marching is equivalent to fixed point iteration\n// with a relaxed termination condition: https://www.shadertoy.com/view/4ssGWl\n\n// This shader illustrates the connection between raymarching and finding roots of the\n// distance function along the ray.\n// The graph shows the distance function along the ray that is marked with a cross in the\n// 3D view. The gray axis is the ray parameter value (scaled arbitrarily).\n\n// Note that these are signed distance values - they are positive (above the axis) when the\n// ray is above the surface.\n\n// Raymarching will walk along the axis from left to right. At every stop it queries\n// the distance value and then walks forward by that amout.\n\n// The red regions of the distance curve show regions where the ray march\n// will tend to be inaccurate. These regions won't occur for a real distance field,\n// but do here because we are using a heightfield as a distance field, and so the\n// distance values vary in an unnatural way (decrease or increase too quicky).\n\n// If the intersection point lies within a red region, the solution obtained is likely\n// to be inaccurate. If FPI is used it won't converge but will orbit (as is the case here)\n// around the intersection forever, at a radius proportional to the gradient (which is why\n// bright spots appear on the when the front facing bumps become steep).\n\n\n#define ITERCNT 60\n#define STEPMULT 1.\n#define SHOW_RAY_STEPS\n\n// the wavy surface\nfloat surfHeight( vec2 xz )\n{\n\tfloat result = 2.*fract((iTime+3.)/10.)* (cos(xz.x) + cos(xz.y));\n\tresult *= 1.-exp(-length(xz)/10.);\n\treturn result;\n}\n\n// evaluate the ray\nvec3 rayPt( vec3 ro, vec3 rd, float t )\n{\n\treturn ro + rd * t;\n}\n\n// the distance field\nfloat distField( vec3 pt )\n{\n\tfloat dSurf = pt.y - surfHeight(pt.xz);\n\t\n\tvec4 sph1 = vec4(0.,2.7,0.,1.);\n\tfloat dSph1 = 1000.;//length(pt.xyz-sph1.xyz)-sph1.w;\n\tvec4 sph2 = vec4(1.5,2.4,0.,0.5);\n\tfloat dSph2 = length(pt.xyz-sph2.xyz)-sph2.w;\n\tvec4 sph3 = vec4(-1.5,2.4,0.,0.5);\n\tfloat dSph3 = length(pt.xyz-sph3.xyz)-sph3.w;\n\treturn min( dSph3, min( dSph2, min( dSph1, dSurf ) ) );\n}\n\n// raymarch with FPI termination criteria\nfloat raymarchFPI( vec3 ro, vec3 rd, out float cnt )\n{\n\t// FPI solves equations f(x)=x.\n\t// Choose\n\t//\t\tf(t) = distField(ro+rd*t) + t\n\t// and use FPI to iterate on t until\n\t// \t\tf(t) = t\n\t// (Which means distField() == 0)\n\t\n\t// initial guess for t - just pick the start of the ray\n\tfloat t = 0.;\n\t\n\tcnt = 0.;\n\tfloat last_t = 10000.; // something far away from t0\n\tfor( int i = 0; i < ITERCNT; i++ )\n\t{\n\t\t// termination condition - iteration has converged to surface\n\t\tif( abs(last_t - t) < 0.001 )\n\t\t\tcontinue;\n\t\t\n\t\tcnt += 1.;\n\t\t\n\t\tlast_t = t;\n\t\t\n\t\tvec3 pt = rayPt(ro,rd,t);\n\t\tfloat d = distField( pt );\n\t\tt += STEPMULT*d;\n\t}\n\t\n\treturn t;\n}\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.1);\n\t\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 pp = -1.0 + 2.0*q;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tpp.x *= aspect;\n    \n\tif( pp.y > 0. )\n\t{\n\t\t// top half of screen. draw the 3d scene with a cross indicating\n\t\t// a particular ray\n\n\t\tpp.y = 2. * (pp.y-.5);\n\t\t\n\t\t// cross\n\t\tif( \n\t\t\t(abs(pp.x) < 0.0125/aspect && abs(pp.y) < 0.1) ||\n\t\t\t(abs(pp.y) < 0.0125 && abs(pp.x) < 0.1/aspect) )\n\t\t{\n\t\t\tfragColor.rgb = vec3(0.,1.,0.);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tpp.x *= 2.;\n\t\t\n\t\t// ray march and shade based on iteration count\n\t\tvec3 ro;\n\t\tvec3 rd = computePixelRay( pp, ro );\n\t\t\n\t\tfloat cnt;\n\t\tfloat t = raymarchFPI(ro,rd, cnt);\n\t\tfloat iters = clamp(cnt/float(ITERCNT),0.,1.);\n\t\t\n\t\tfragColor.xyz = vec3( iters );\n\t}\n\telse\n\t{\n\t\t// bottom half of screen. here we will draw the graph. this is done by finding\n\t\t// out which pixel we are on, computing a graph coordinate from that, and then\n\t\t// checking if we are close to the curve.\n\t\t\n\t\t// axis\n\t\tif( abs(fragCoord.y - iResolution.y/4.) < 1.)\n\t\t{\n\t\t\tfragColor.rgb = vec3(0.4);\n\t\t}\n\t\t\n\t\t// compute ray for the middle of the screen. this is where the cross\n\t\t// is located, and this is the ray that is graphed\n\t\tvec3 ro;\n\t\tvec3 rd = computePixelRay( vec2(0.), ro );\n\t\t\n\t\t// compute the t (x-axis) value for this pixel\n\t\tfloat tmax = 50.0;\n\t\tfloat thist = tmax * fragCoord.x / iResolution.x;\n\t\t\n\t\t// evaluate the distance field for this value of t\n\t\tvec3 thisPt = rayPt( ro, rd, thist );\n\t\tfloat dist = distField( thisPt );\n\t\t\n\t\t// compute the dist (y-axis) value for this pixel\n\t\t// compute max y axis value from x axis range\n\t\tfloat maxDist = tmax * (iResolution.y*0.5/iResolution.x);\n\t\tfloat thisDist = maxDist * (pp.y+.5);\n\t\t\n\t\t// we'll also want the gradient, which tells us whether the\n\t\t// iteration will converge. compute it using forward differences\n\t\t// along the ray\n\t\tfloat eps = tmax/iResolution.x;\n\t\tvec3 nextPt = rayPt( ro, rd, thist + eps );\n\t\tfloat nextDist = distField(nextPt );\n\t\tfloat distGradient = (nextDist - dist) / eps;\n\t\t\n\t\t\n\t\t// when using FPI, the iterated function is t = distField + t\n\t\t// therefore the gradient of the iteration is d/dt(distField) + 1\n\t\tfloat fpiGrad = distGradient + 1.;\n\t\t\n\t\t// for fpi to converge, the gradient has to be in (-1,1). the next\n\t\t// few lines compute a color, blending to red over the last 20% of\n\t\t// this range\n\t\tfpiGrad = abs(fpiGrad);\n\t\tfpiGrad = smoothstep( .8, 1., fpiGrad );\n\t\tfloat g = 1.5 + -2.*fpiGrad;\n\t\tfloat r =  2.*fpiGrad;\n\t\tvec3 lineColor = clamp(vec3(r,g,0.),.0,1.);\n\t\tlineColor.g *= .85;\n\t\t\n\t\t// iq's awesome distance to implicit https://iquilezles.org/articles/distance\n\t\tfloat alpha = abs(thisDist - dist)*iResolution.y/sqrt(1.+distGradient*distGradient);\n\t\t// antialias\n\t\talpha = smoothstep( 80., 30., alpha );\n\t\tfragColor.rgb = (1.-alpha) * fragColor.rgb + lineColor * alpha;\n\t\t\n\t\t\n\t\t// additional visualisation - for sphere tracing, visualise each sphere\n\t\t// need each t value, then plot circle at each t with the radius equal to the distance\n\t\t\n\t\t#ifdef SHOW_RAY_STEPS\n\t\t\n\t\tfloat stepTotalAlpha = 0.;\n\t\t\n\t\tfloat stept = 0.;\n\t\t\n\t\tfloat last_t = 10000.; // something far away from t0\n\t\tfor( int i = 0; i < ITERCNT; i++ )\n\t\t{\n\t\t\t// termination condition - iteration has converged to surface\n\t\t\tif( abs(last_t - stept) < 0.001 )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tlast_t = stept;\n\t\t\t\n\t\t\tfloat stepx = -aspect + 2.*aspect * stept / tmax ;\n\t\t\tvec3 stepPt = rayPt( ro, rd, stept );\n\t\t\t\n\t\t\tfloat d = distField( stepPt );\n\t\t\t\n\t\t\tfloat stepDist = abs( d );\n\t\t\tfloat R = length( vec2(stepx,-.5) - pp );\n\t\t\t\n\t\t\tfloat circleR = stepDist / ( maxDist);\n\t\t\t// circle boundary\n\t\t\tfloat stepAlpha = 0.2*smoothstep( 5.0/iResolution.x, 0.0, abs(circleR - R) );\n\t\t\t// add a dot at the center\n\t\t\tstepAlpha += 0.3*smoothstep(5.0/iResolution.x,0.0,R);\n\t\t\t\t\n\t\t\tstepTotalAlpha += stepAlpha;\n\t\t\t\n\t\t\tstept += STEPMULT*d;\n\t\t}\n\t\tfragColor.rgb += (1.-alpha) * clamp(stepTotalAlpha,0.,1.)*vec3(1.0,1.0,0.);\n\t\t\n\t\t#endif\n\t}\n}\n\n\n\n\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 3.8;\n\t// use mouse x coord\n\tfloat a = iTime*20.;\n\t//if( iMouse.z > 0. )\n\t//\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)/80.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,2.5,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,2.,0.);\n     \n    // camera frame\n\txoff = 0.;\n\tfloat yoff = 0.;\n\tif( iMouse.z > 0. )\n\t{\n\t\txoff = -2.5*(iMouse.x/iResolution.x - .5);\n\t\tyoff = 4.25*(iMouse.y/iResolution.y - .5);\n\t}\n\t\n\tvec3 toTarget = target-cameraPos;\n\tvec3 right = vec3(-toTarget.z,0.,toTarget.x);\n\t\n    vec3 fo = normalize(target-cameraPos + vec3(0.,yoff,0.) + xoff*right );\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n\n\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldsGWl","date":"1381950545","viewed":718,"name":"Raymarching as root finding","username":"huwb","description":"Illustration that raymarching is a root finding method. Top view shows scene with a cross at a particular ray. Bottom view shows distance values along this ray, and red shows regions where the iteration will struggle to converge. Mouse rotates the view.","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fpi","iteration"],"hasliked":0,"parentid":"","parentname":""}}