{"ver":"0.1","info":{"id":"mtlcR4","date":"1690477177","viewed":37,"name":"tg dual camera shapes","username":"dkaraush","description":"camera","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 pixelWH = vec2(1280., 720.);\nconst float roundRadius = 32.;\nconst float scale = 1.;\n\nfloat modI(float a,float b) {\n  return floor(a-floor((a+0.5)/b)*b+0.5);\n}\n\nbool eq(float a, float b) {\n    return abs(a - b) < .1;\n}\n\nbool eq(float a, float b, float b2) {\n    return abs(a - b) < .1 || abs(a - b2) < .1;\n}\n\nfloat box(vec2 position, vec2 halfSize, float cornerRadius) {\n  position = abs(position) - halfSize + cornerRadius;\n  return length(max(position, 0.0)) + min(max(position.x, position.y), 0.0) - cornerRadius;\n}\n\nfloat star(in vec2 p, in float r) {\n    const vec2  acs = vec2(.9659258, .258819);\n    const vec2  ecs = vec2(.8090169, .5877852);\n    float bn = mod(atan(p.x,p.y),.52359876)-.26179938;\n    p = length(p)*vec2(cos(bn),abs(sin(bn))) - r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat scene(vec2 uv, float shapeFrom, float shapeTo, float shapeT) {\n  vec2 p = (uv - vec2(.5)) * vec2(1., pixelWH.x / pixelWH.y);\n  vec2 r = .5 * vec2(1., pixelWH.x / pixelWH.y) * scale;\n  float R = min(r.x, r.y), rr = roundRadius / pixelWH.y;\n  float a = modI(shapeFrom, 4.), b = modI(shapeTo, 4.);\n  float boxSDF = box(\n    p, \n    mix(eq(a, 2.)     ? r : vec2(R), eq(b, 2.)     ? r : vec2(R), shapeT),\n    mix(eq(a, 0., 3.) ? R : rr,      eq(b, 0., 3.) ? R : rr,      shapeT)\n  ) * pixelWH.x;\n  if (eq(3., a, b)) {\n    float starSDF = opSmoothUnion(box(p, vec2(R * .9), R), star(p, R * .9), .2) * pixelWH.x;\n    float starA = eq(a, 3.) ? 1. - shapeT : 0.;\n    float starB = eq(b, 3.) ? shapeT : 0.;\n    return mix(boxSDF, starSDF, starA + starB);\n  } else {\n    return boxSDF;\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv.x = (uv.x - .5) * (iResolution.x * iResolution.x / iResolution.y / iResolution.y) + .5;\n  \n  float t = iTime * 2.;\n  \n  float shapeFrom = floor(t);\n  float shapeTo = ceil(t);\n  float shapeT = t - shapeFrom;\n  \n  float alpha = clamp(1. - scene(uv, shapeFrom, shapeTo, shapeT), 0., 2.) / 2.;\n\n  fragColor = vec4(alpha);\n}","name":"Image","description":"","type":"image"}]}