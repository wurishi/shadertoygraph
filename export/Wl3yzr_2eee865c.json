{"ver":"0.1","info":{"id":"Wl3yzr","date":"1608373426","viewed":205,"name":"JSplacement with vehicles","username":"kastorp","description":"fork of \"JSplacement-style greebles\"  by TekF [url]https://www.shadertoy.com/view/wsGBzV[/url]\nclick z to edit map\nfor a complete traffic simulation see \"City Game II\"","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["displacementmap","traffic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//fork of \"JSplacement-style greebles\"  by TekF\n//https://www.shadertoy.com/view/wsGBzV\n\nstruct cell {\n    vec3 coord;\n    block b;\n    vehicle v;\n    float pd;\n};\n\ncell c;\n\nvec4 map(vec2 P,float h) {\n        vec4 Q=vec4(0.);\n        vec2 P0 = floor(P.xy)+.5; //position center\n\n        vec3 coord= buffer2coord(P0);\n        vec2 point = buffer2point(P.xy); //RELATIVE COORDS\n        bool outside =  min(P.x,P.y)<0. || max(P.x/RZ.x,P.y/RZ.y)>1.; //true if outside buffer A\n        \n        if(length(c.coord.xy -coord.xy)>.1){\n            vec4 data=A(P0);              \n            c.b = decodeBlock(A(coord2buffer(vec3(coord.xy,0.))),coord.xy); //CURRENT BLOCK             \n        }\n        \n        //BUILDINGS --> JSPlacement \n        if(c.b.btype==0 &&!outside) {\n                Q= texture(iChannel3,fract(P.xy*vec2(1.,R.x/R.y)/120.));\n                Q.a =(Q.a+1.2)*6.;\n                return Q;\n        }\n        \n        if(length(c.coord -coord)>.1 ){\n            vec4 data=A(P0);\n            c.coord= coord;\n            c.v = decodeVehicle(data,c.coord); //CURRENT CELL/VEHICLE\n   \n        }   \n        \n        c.pd= 1.;  //DISTANCE FROM CLOSEST VEHICLE\n        //neghtbours\n        if(c.v.road &&h<5.){\n\n            if(c.v.vtype>0) c.pd = vdist(mod(point,1.),c.v);\n            for(int i =0;i<4;i++){\n                vec3 ncoord =buffer2coord(P0 + DIRS[i]);\n                vec4 ndata = A(P0 + DIRS[i]);\n                vehicle nv = decodeVehicle(ndata,ncoord);\n                if(nv.vtype>0) c.pd=min(c.pd, vdist(mod(point,1.) - DIRS[i],nv));\n\n            }\n        }\n    \n        float fJun= (c.b.btype==1)?2.:0.; //used by stripes       \n        \n\n\n//DISPLACEMENT\n\n         if (h>10.) Q=vec4(0.);\n        \n        else if(isBlockCoord(c.coord) || !c.v.road  || outside) {\n            \n           //GRASS\n             if(hash(P0) >.8)Q=vec4(0.8,0.4,0.1,3.+sin(floor(iTime) + P0.x+P0.y*6.)*2. );\n             else Q=vec4(0.5,.5 ,0.5,0.);\n        } \n        \n\n        //STRIPES:\n        else if((c.b.conns&1)>0 &&  abs(point.x-3.05 ) <.10   &&  point.y>3. + fJun)  Q=vec4(1.,1.,1.,0.5);\n        else if((c.b.conns&4)>0 &&  abs(point.x-3.05 ) <.10   &&  point.y<3. - fJun)  Q=vec4(1.,1.,1.,0.5);\n        else if((c.b.conns&2)>0 &&  abs(point.y-3.05 ) <.10   &&  point.x>3. + fJun)  Q=vec4(1.,1.,1.,0.5);\n        else if((c.b.conns&8)>0 &&  abs(point.y-3.05 ) <.10   &&  point.x<3. - fJun)  Q=vec4(1.,1.,1.,0.5);\n        //VEHICLE\n        else if(c.pd<.0 ) Q=vec4(1.,1.,0.,2.);\n\n        //ASPHALT   \n        else Q=vec4(.2);\n        \n        return Q;\n   \n}   \n    \n\n\nvec4 FoldHeight( sampler2D ch, vec2 uv,float h )\n{\n    \n    //if(h+1.5>1.5) return vec4(0.);\n    //if((h+1.5)<0.) return vec4(1.);   \n    vec4 fh= map(uv*60.,(h+1.5)*10.) ;\n    fh.a =fh.a/20. +.3;    \n    return fh;\n\t\n}\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 U )\n{\n\n    vec2 P= U/ ZOOM;\n    vec2 M = (iMouse.xy)/ZOOM;\n    if(M.x<1.)  M= R / ZOOM /2.;\n    if(!zoomMode) {fragColour=map(P.xy,0.); return;}\n    \n    \n    float r = R.x/60.;\n\tfloat zoom = 1.;\n\tvec3 rayDirection = normalize( vec3( (U-iResolution.xy*.5)/iResolution.y, zoom ) );\n    vec3 cameraCenter =  vec3(10.+r,0,10.+r);\n    float time = iTime/4.;\n    vec3 cameraTarget =  cameraCenter+ vec3(cos((time+1.4)/3.),0, sin((time+1.4) /3.))*r;\n    vec3 cameraPosition = cameraCenter + vec3(0.,r/2.,0.) + vec3(cos(time/3.),0, sin(time/3.))*r;\n\n   \n    \n    vec3 cameraForward = normalize( cameraTarget - cameraPosition );\n    vec3 upAxis = vec3(0,1,0);\n    vec3 cameraRight = normalize( cross( upAxis, cameraForward ) );\n    vec3 cameraUp = cross( cameraForward, cameraRight );\n    \n    // rotate ray to camera orientation\n    rayDirection = rayDirection.x*cameraRight + rayDirection.y*cameraUp + rayDirection.z*cameraForward;\n    \n    vec3 planeNormal = vec3(0,1,0);\n    float planeOffset = 0.; // from world origin, in direction of plane normal\n\n    // precompute some things\n    float rayDotPlaneNormal = dot(rayDirection,planeNormal);\n    float invRayDotPlaneNormal = 1. / rayDotPlaneNormal;\n    float cameraDotPlaneNormal = dot(cameraPosition,planeNormal);\n    float distanceToPlaneAlongNormal = planeOffset - cameraDotPlaneNormal; // note this is negative, so maybe shouldn't be called \"distance\"\n\n\tfloat invTextureScale = .04; // correct the aspect ratio\n\n\t// only support viewing the plane from in-front (even though it has depth it will break down when viewed edge-on)\n    if ( rayDotPlaneNormal >= 0. || cameraDotPlaneNormal < planeOffset )\n    {\n    \tfragColour = vec4(1);\n        return;\n    }\n\n    // draw the displacement map as a series of slices through the texture, not a solid object\n    float displacementHeight = 2.;\n    int numSlices = int(R.y/4.);\n    float sliceStep = displacementHeight / float(numSlices);\n    \n    vec2 textureCoordinate = vec2(0);\n    float currentHeight=0.; \n    float sliceProportion = 0.;\n    float distanceToIntersection = 0.;\n    float height = 0.;\n    vec4 fh=vec4(0.);\n    c.coord=vec3(-100.);\n    for ( int slice = 0; slice < numSlices; slice++ )   \n    {\n    \tsliceProportion = float(slice)/float(numSlices); // how far we are through the full stack of slices, in [0,1)\n    \n    \t// how far along the ray do we have to travel to hit the plane\n    \tdistanceToIntersection = distanceToPlaneAlongNormal * invRayDotPlaneNormal;\n        \n        vec3 intersectionPosition = cameraPosition + rayDirection*distanceToIntersection;\n        \n        textureCoordinate = intersectionPosition.xz*invTextureScale;\n         \n        \n        // on firefox on my home PC it works without this, but I guess repeat texture mode doesn't working with frame buffers reliably\n\t\t//textureCoordinate = fract(textureCoordinate);\n        \n\t\t// point sample - might be better to have 2 versions of the texture with different filter modes rather than all this maths\n        //fragColour = texelFetch(iChannel0,ivec2(textureCoordinate*iResolution.xy)%ivec2(iResolution.xy),0);\n        currentHeight=intersectionPosition.y;\n        \n        fh= FoldHeight(iChannel0,textureCoordinate,currentHeight);\n        height=fh.a;\n        fragColour=fh;\n        // stop marching once we sample something at or above the march height\n        if ( 1.-height < sliceProportion ) break;\n        \n        distanceToPlaneAlongNormal -= sliceStep; // subtract because distance is negative, easy to explain with a diagram\n    }\n    \n    // sorry for the cryptic maths here\n    vec2 d = vec2(1.,0)/iResolution.xy;\n    vec3 normal = cross(\n    \t\t\t\tvec3(0,\n    \t\t\t\t(\n                    \tFoldHeight(iChannel0, textureCoordinate+d.yx,currentHeight ).a\n    \t\t\t\t\t-FoldHeight( iChannel0, textureCoordinate-d.yx,currentHeight ).a\n                     ) * displacementHeight\n                    ,d.x / invTextureScale)\n                    ,\n    \t\t\t\tvec3(d.x / invTextureScale,\n                    (\n                        FoldHeight( iChannel0, textureCoordinate+d.xy,currentHeight ).a\n                        -FoldHeight( iChannel0, textureCoordinate-d.xy,currentHeight).a\n                     ) * displacementHeight\n                    ,0)\n                   );\n// can get better normals for walls with less bevel if use Channel1 and smaller d, but that will break on smooth curves\n\n    \n\tnormal = normalize(normal);\n\n\tvec3 reflectDirection = reflect(rayDirection,normal);\n    vec3 reflectionColour = texture(iChannel2,reflectDirection).rgb;\n    vec3 reflectionBlurred = textureLod(iChannel2,reflectDirection,3.).rgb;\n    \n    // darken reflections below the horizon so it looks like the plane's reflecting itself\n    reflectionColour *= mix( vec3(.3), reflectionColour, smoothstep(.0,.1,reflectDirection.y) );\n    reflectionBlurred *= mix( vec3(.3), reflectionColour, smoothstep(.0,.1,reflectDirection.y) );\n    \n    // fake - desaturate metallic reflections\n    reflectionBlurred = mix( reflectionBlurred.ggg, reflectionBlurred, .1 );\n    \n    \n    float metallicity =  step(.7,fract(fh.a*11.));\n\n\t// lighting\n    vec3 lighting = vec3(.1,.2,.3)+ vec3(2.5,2.2,2)*1.5 * max(0.,dot(normal,normalize(vec3(2,1,3))));\n    fragColour.rgb *= mix( lighting, reflectionBlurred, metallicity );\n    \n    // reflection\n    float fresnel = .02+.98*pow(min(1.+dot(rayDirection,normal),1.),5.);\n    fragColour.rgb = mix( fragColour.rgb, reflectionColour, fresnel );\n\n\t// darken deeper parts\n   fragColour = mix( fragColour, vec4(0), sliceProportion ); \n    \n    // atmospheric fog\n    fragColour = mix( vec4(1.), fragColour, exp2( -distanceToIntersection * vec4(.1,.125,.2,1)/20. ) );\n    \n    // stretch contrast\n    fragColour = clamp(fragColour*1.-.04,0.,1.);\n\n    \n//\tfragColour.rgb = .5+.5*normal/(abs(normal)+.1);//\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n\n/*\n// debug greeble buffer\n    fragColour = texelFetch( iChannel0, ivec2(fragCoord + iTime*vec2(80,30))%ivec2(iResolution.xy), 0 );\n//    fragColour = step(vec4(abs(fract(iTime*.1)*2.-1.)),fragColour);\n*/\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//SETTINGS\n#define ZOOM  4.0\n#define ZOOM2 5.\n#define VSTEP 64.\n#define VMAX 1.\n#define BLOCK_BUFFER vec2(6.,6.)\n#define VEHICLE_DENSITY .5\n\n#define HEIGHT 30 //set to 0 to display 2D in zoom panel\n#define DEBUG 0\n\n#if DEBUG>0\n    #define  ALERT_COLOR vec4(0.,1.,1.,0.)\n    #define DEBUG_COLOR vec4(0.2,0.,0.,0.)\n    #define DEBUG_COLOR2 vec4(0.,.2 ,0.,0.)\n\t#define DEBUG_COLOR1 vec4(.6,.6,0.,0.)\n\t#define DEBUG_COLOR3 vec4(.6,.6,0.,0.)\n#else\n    #define ALERT_COLOR vec4(0.2,0.2,0.2,0.)\n    #define DEBUG_COLOR vec4(0.15,0.15,0.15,0.)\n\t#define DEBUG_COLOR2 vec4(0.,.5 ,0.,0.)\n    #define DEBUG_COLOR1 vec4(0.15,0.15,0.15,0.)\n    #define DEBUG_COLOR3 vec4(0.15,0.15,0.15,0.)\n#endif\n\n//CALCULATED:\n#define BMAX floor(iResolution.xy/BLOCK_BUFFER/ZOOM)\n//#define PMAX int(BLOCK_BUFFER.x*BLOCK_BUFFER.y)\n#define OSTEP VSTEP\n#define AMAX= 1/VSTEP\n\n\n//RESOLUTION\n#define R iResolution.xy\n#define RZ (R/ZOOM)\n#define Main void mainImage(out vec4 Q, vec2 U)\n#define zoomMode  (!keyToggle(CH_Z) )\n\n//BUFFER INPUT\n//#define A(U) texture(iChannel0,(U)/R)\n#define A(U) texelFetch(iChannel0, ivec2(mod(U,R)), 0)\n\n    \n    //Neighborhood;\n    // 0 1 2\n    // 3 4 5\n    // 6 7 8  \n#define TS vec2(textureSize(iChannel0,0))\n \n//#define Directions vec2 d[4] = vec2[] (vec2(0,1), vec2(-1,0),vec2(1,0) ,vec2(0,-1));            \n     \nconst vec2 DIRS[4] = vec2[] (vec2(0,1), vec2(1,0),vec2(0,-1) ,vec2(-1,0));  \nconst float PI = 3.14159265359;\n\n//KEYBOARD\n\n#define CH_Z 90  \n#define CH_SHIFT 16 \n#define keyDown(k) (texelFetch(iChannel1, ivec2(k,0), 0).r>.5)\n#define keyPress(k) (texelFetch(iChannel1, ivec2(k,1), 0).r>.5)\n#define keyToggle(k) (texelFetch(iChannel1, ivec2(k,2), 0).r>.5)\n            \nfloat hash(in float x) { return fract(sin(x*.0007)*29835.24389); }\nfloat hash(in vec2 x) { return hash(dot(x,vec2(23.17,17.23))); }\nvec2 hash22( vec2 p ) { float t = hash(p);\treturn vec2( t,hash(t)); }\n\n\n\n//PACKING/UNPACKING         \n//from https://www.shadertoy.com/view/wsBfzW\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits\n//lazy version:\n//#define sb(f,s,b,v) f+=(v-gb(f,s,b))*pow(2.,s)\n//strict version (use in case of strange behaviours):\n#define sb(f,s,b,v) f+=(clamp(floor(v+.5),0.,pow(2.,b)-1.)-gb(f,s,b))*pow(2.,s)\n\n       \n//VEHICLE\nstruct vehicle {\n    vec2 block_pos; // block xy  (not persistent)\n    int pos; //  (not persistent)\n    bool road;\n    int vtype; //2 bit 0=none 1=car,... \n    int dir_in; // 0..3 DIRS[i]\n    int dir_out;        \n\tfloat offset; //4 bit -.5 .. + .5\n\tfloat vel; //4bit 0 .. + 1.\n\tvec2 target; //target block 8+8 bit\n       \n};\n \n    \nvehicle newVehicle(vec3 coord, bool road, int vtype,float vel, float off, vec2 tg , int di, int dout){\n    vehicle o;\n    o.block_pos=coord.xy; // 6 + 6   \n    o.pos=int(coord.z); //4 bit\n    o.road=road;\n    o.vtype=vtype; //2 bit 0=none 1=car,... \n    o.dir_in= di ;\n    o.dir_out=dout;\n\to.offset= off; \n\to.vel=vel; \n\to.target=tg; //target block 8+8 bit\n\n    return o;\n}\n\n\nvehicle decodeVehicle(vec4 t,vec3 coord) {\n\tvehicle o;\n    o.pos=int(coord.z);\n    o.block_pos= coord.xy;   \n    o.vtype= int(gb(t.g,0., 1.)); //2 bit 0=none 1=car,... \n    o.dir_in = int(gb(t.g,1., 2.));\n    o.dir_out = int(gb(t.g,3., 2.));\n    o.road=gb(t.g,5., 1.)<.5;\n\n\to.offset= gb(t.b,0., 6.) /OSTEP  -.5; \n\to.vel= gb(t.b,6., 6.) /VSTEP;\n    \n\to.target= vec2(  \n        gb(t.a,0., 8.),\n        gb(t.a,8., 8.)\n        );\n          \n    return o;\n}\n\n\nvec4 encodeVehicle(vehicle o) {\n\tvec4 t=vec4(0.);\n    \n    sb(t.g,0.,1.,float(o.vtype));\n\tsb(t.g,1.,2.,float(o.dir_in));\n    sb(t.g,3.,2.,float(o.dir_out));\n    sb(t.g,5.,1.,o.road?0.:1.);\n    \n    sb(t.b,0.,6.,(o.offset +.5)* OSTEP);\n    sb(t.b,6.,6.,o.vel * VSTEP);\n    \n    \n    sb(t.a,0.,8.,o.target.x);\n    sb(t.a,8.,8.,o.target.y);\n\n    return t;\n}\n\n//BLOCK\nstruct block {\n    vec2 block_pos;\n    int btype; //3 bit 0=none 1=cross 2=hstreet, 3= vstreet, 4=bridge,... \n    int conns; // 4 bits\n       \n};\n\nblock newBlock(vec3 coord, int btype){\n\tblock o;\n    o.block_pos= coord.xy;\n    o.btype=btype; \n    o.conns=15;\n    return o;               \n}\n                 \n                 \nblock decodeBlock(vec4 t,vec2 coord) {\n\tblock o;\n    o.block_pos= coord;\n    o.btype = int(gb(t.r,0., 3.)); \n    o.conns = int(gb(t.r,4., 4.)); \n    return o;\n}\n\nvec4 encodeBlock(block o) {\n\tvec4 t=vec4(0.);\n    \n    sb(t.r,0.,3.,float(o.btype));\n    sb(t.r,4.,4.,float(o.conns));\n    return t;\n}\n\n//MAPPING FUNCTIONS\nbool isBlockCoord(vec3 coord) {\n    return (int(coord.z)== 0);\n}\n    \nvec3 buffer2coord (vec2 b) {  \n    return vec3(\n        floor(b.x/BLOCK_BUFFER.x),\n        floor(b.y/BLOCK_BUFFER.y),\n        floor(mod(b.x, BLOCK_BUFFER.x))* BLOCK_BUFFER.x +floor(mod(b.y, BLOCK_BUFFER.y))\n     );\n\n}\n\nvec2 buffer2point(vec2 b){\n\treturn vec2(\n    \t\tmod(b.x, BLOCK_BUFFER.x),\n        \tmod(b.y, BLOCK_BUFFER.y)\n    );\n}\n\n    \n    \nvec2 coord2buffer(vec3 c){\n\treturn vec2(\n        floor(c.x) * BLOCK_BUFFER.x  + floor(c.z/BLOCK_BUFFER.x),\n        floor(c.y) * BLOCK_BUFFER.y  + floor(mod(c.z,BLOCK_BUFFER.x))\n    );\n}\n\n//ROUTING\nvec2  next(vec2 point, block b,bool turn){\n\n    \n    //block position is always excluded\n\tif( abs(point.x-.5) <.5 && abs(point.y-.5)<.5) return vec2(0.);\n    \n    \n    \n    vec2 d = (vec2(point.x-3.,point.y-3.));\n    \n    float dm=max(abs(d.x),abs(d.y));\n   \n\n    // CROSS   \n    if(b.btype==1 ){\n        //TURN DIRECTION\n        if(turn==true){\n        \tif(abs(point.x-4.5) <.5 && abs(point.y-2.5)<.5 && (b.conns&2)>0) return vec2(1.,2.);\n            if(abs(point.y-4.5) <.5 && abs(point.x-3.5)<.5 && (b.conns&1)>0) return vec2(0.,2.);\n            if(abs(point.x-1.5) <.5 && abs(point.y-3.5)<.5 && (b.conns&8)>0) return vec2(3.,2.);\n            if(abs(point.y-1.5) <.5 && abs(point.x-2.5)<.5 && (b.conns&4)>0) return vec2(2.,2.);\n        \n        }\n        // DEFAULT DIRECTION\n        else{\n            if( (abs(point.x-3.5) <1.5 && abs(point.y-4.5)<.5 ) || (abs(dm-2.5) <.5 && abs(d.y-.5)<.5 )) return vec2(3.,15.);   \n            if( (abs(point.x-4.5) <.5 && abs(point.y-2.5)<1.5)  || (abs(dm-2.5) <.5 && abs(d.x-.5)<.5 ))return vec2(0.,15.);\n            if( (abs(point.x-2.5) <1.5 && abs(point.y-1.5)<.5)  || (abs(dm-2.5) <.5 && abs(d.y+.5)<.5 ))return vec2(1.,15.);\n            if( (abs(point.x-1.5) <.5 && abs(point.y-3.5)<1.5)  || (abs(dm-2.5) <.5 && abs(d.x+.5)<.5 )) return vec2(2.,15.);\n        }\n    }\n    //JUNCTION\n\tif(b.btype==4 && turn==false){ \n        \n        bool central = (abs(dm) <1.);\n        \n        //UP\n        if(abs(point.x-3.5)<.5 &&(\n            ( (b.conns&1)>0 && abs(point.y-5.)<1.  )  \n            ||( (b.conns&4)>0 && abs(point.y-1.)<1.  )  \n            ||( (b.conns&2)==0 && abs(point.y-2.5)<.5  )  \n            ||( (b.conns&1)==1 && abs(point.y-3.5)<.5  )  \n        )) return vec2(0.,15.);\n\t\t//DOWN\n         if(abs(point.x-2.5)<.5 &&(\n            ( (b.conns&4)>0 && abs(point.y-1.)<1.  )  \n            ||( (b.conns&1)>0 && abs(point.y-5.)<1.  )  \n            ||( (b.conns&8)==0 && abs(point.y-3.5)<.5  )  \n            ||( (b.conns&4)==4 && abs(point.y-2.5)<.5  )  \n        )) return vec2(2.,15.);\n        //RIGHT\n        if(abs(point.y-2.5)<.5 &&(\n            ( (b.conns&2)>0 && abs(point.x-5.)<1.  )  \n            ||( (b.conns&8)>0 && abs(point.x-1.)<1.  )  \n            ||( (b.conns&4)==0 && abs(point.x-2.5)<.5  )  \n            ||( (b.conns&2 )==2 && abs(point.x-3.5)<.5  )  \n        )) return vec2(1.,15.);\n        //LEFT\n        if(abs(point.y-3.5)<.5 &&(\n            ( (b.conns&2)>0 && abs(point.x-5.)<1.  )  \n            ||( (b.conns&8)>0 && abs(point.x-1.)<1.  )  \n            ||( (b.conns&1)==0 && abs(point.x-3.5)<.5  )  \n            ||( (b.conns&8 )==8 && abs(point.x-2.5)<.5  )  \n        )) return vec2(3.,15.);\n        \n    }\n    \n    return vec2(.0,0.);\n\n}\n\n//iq\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n\nmat2 rot(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\nvec2 rpos(float off, int di, int dout){\n\tif(off<0.) return  .5- DIRS[di]*off;\n    else return  .5+ DIRS[dout]*off;\n}\n\nfloat vdist(vec2 p, vehicle nv){\n vec2 dir = normalize(rpos(nv.offset+.5,nv.dir_in,nv.dir_out)-rpos(nv.offset-.5,nv.dir_in,nv.dir_out));\n vec2 pos=p-rpos(nv.offset,nv.dir_in,nv.dir_out);\n    pos= vec2(pos.x* dir.x + pos.y*dir.y , pos.y*dir.x-pos.x*dir.y);\n return sdBox(pos,vec2(0.3,0.2));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//based on \"Traffic Sim\"\n//for a complete simulation see \"City Game II\"\n\nMain {\n    \n \tQ =vec4(0.);\n \n\tvec3 coord = buffer2coord(U);\n    vec3 bcoord= vec3( coord.xy,0.);\n    \t\t\n    \n    if(coord.x>BMAX.x || coord.y> BMAX.y) discard;\n    \n    //reset:\n    if (iFrame==0 || TS.x != A(vec2(0.)).z){\n\n       \n        int btype=min(int(hash(U +iTime)*3.),1);\n       \n        \n        if(isBlockCoord(coord)){\n        \tblock b = newBlock(coord,btype);\n            Q= encodeBlock(b);\n        \n        }\n         \n        else if(hash(U)<VEHICLE_DENSITY) {\n          \tvehicle v = newVehicle(\n                coord,\n                true,\n                1,\n        \t\t//vec3(mod(U.x , BMAX.x), mod(U.y ,  BMAX.y),float(int(U.x)% PMAX )),\n                \n                3./  VSTEP,\n                -.5  + hash(U),\n                vec2(vec2(mod(U.x , BMAX.x), mod(U.y ,  BMAX.y))),\n                int(mod(U.x , 2.) +2.* mod(U.y ,  2.)),\n                int(mod(U.x/4. , 2.) +2.* mod(U.y/4. ,  2.))\n            );\n        \n\n        \t//packing\n            Q= encodeVehicle(v);\n        }\n        else Q =vec4(0.);\n        \n\n        \n    } else{\n        \n        Q = A(U);\n        \n        block b = decodeBlock(A(coord2buffer(bcoord)),bcoord.xy);\n        \n        //block logic\n        if(isBlockCoord(coord)){\n            \n            \n \n            //MOUSE click\n            vec3 mcoord=buffer2coord(  iMouse.zw/ZOOM +.5);\n            if(!zoomMode && length(mcoord.xy-bcoord.xy )<1. ) \n            { \n               if(keyDown(CH_SHIFT) ) b.btype=0;\n               else b.btype=1;\n              \n            }\n            \n        \t//connections:\n        \tint conX =0,conY=0, conns=0;\n            for(int i=0;i<4;i++){\n            \tvec3 nbCoord=vec3(coord.xy + DIRS[i], coord.z);\n                block nb = decodeBlock(A(coord2buffer(nbCoord)),nbCoord.xy);\n                if(nb.btype!=0 && i%2==0) conY++;\n                if(nb.btype!=0 && i%2==1) conX++;\n                if(nb.btype!=0) conns +=  int(pow(2., float(i)));// 1>>i;\n            }\n            \n            \n            if(mod(coord.x,2.)+mod(coord.y,2.)<.5) b.btype=0;\n            else if(conX+conY<1) {b.btype=0;}\n            //else if(conX+conY>=4 && mod(bcoord.x+bcoord.y,2.)<1. ) b.btype=0;\n            else if(conX+conY>2 &&  b.btype>0 ) b.btype=1;\n            //else if(conX==2 && b.btype>0 ) b.btype=2;\n            //else if(conY==2 && b.btype>0 ) b.btype=3;\n            //else if(conX + conY==2  && b.btype>0 ) b.btype=4;\n            else if(b.btype>0) b.btype=4;\n            \n            b.conns=conns;\n                              \n            Q= encodeBlock(b);\n                \n                \n        }\n        //vehicle logic\n        else{\n            //unpacking\n            vehicle v = decodeVehicle(Q,coord);\n            vec2 point=buffer2point(U);\n   \t\t\tv.road=true;\n\n            //logic\n            float fCross= (b.btype==1)?1.:0.;\n            if( b.btype==0)  {v.road=false;}\n            else if(b.btype==1 &&  (abs(point.x-3.) +abs(point.y-3.) >3.  || abs(point.x-3.) +abs(point.y-3.) <2. )) {v.road=false;}\n            //else if(b.btype==2 &&  abs(point.x-3.) >1. )  {v.road=false;}\n            //else if(b.btype==3 &&  abs(point.y-3.) >1. )  {v.road=false;}\n            \n            else if((b.conns&1)==0 &&  abs(point.y-1. ) >3. +fCross  )  {v.road=false;}\n            else if( (b.conns&2)==0 &&  abs(point.x-1. ) >3. +fCross )  {v.road=false;}\n            else if( (b.conns&4)==0 &&  abs(point.y-5. ) >3. +fCross  )  {v.road=false;}\n            else if( (b.conns&8)==0 &&  abs(point.x-5. ) >3. + fCross )  {v.road=false;}\n            else if( b.btype==4 &&  (min(abs(point.x-3.),abs(point.y-3.)) >1.)    ) {v.road=false;}\n            \n\t\t\t//clean vehicles outside road\n            if(!v.road ) v = newVehicle( coord, false, 0, 0.,0. ,vec2(0.),0,0);\n            \n            else if(v.vtype>0) {\n                \n                //next direction (very simple at the moment...)\n                vec2 nx =next(point,b,false);\n                if(nx.y>0.) {v.dir_out=int(nx.x); }\n               \n                vec2 nx2 =next(point,b,true);\n                if(nx2.y>0. ) {v.dir_out=int(nx2.x); nx=nx2;}\n                \n                vec3 ncoord =buffer2coord(U + DIRS[v.dir_out]);\n        \t\tvec4 ndata = A(U + + DIRS[v.dir_out]);\n        \t\tvehicle nv = decodeVehicle(ndata,ncoord);\n                \n                float dist = 1.; //1. s\n                \n        \t\tif(nv.vtype>0)  dist = (1.+ nv.offset-v.offset +nv.vel- v.vel);\n                else v.vel = clamp(v.vel+( -1. +mod(iTime*1.5 + U.x*.5+U.y*.5,3.)) /VSTEP,1./VSTEP,5./VSTEP)  ;\n               \n                if(dist < 1.) v.vel=nv.vel;\n                \n                 \n                //update offset                          \t                \n                v.offset += v.vel;\n                      \n                //vehicle leaving cell\n                if(v.offset>=.5) {\n                    v.offset=-.5;v.vel=1./VSTEP;\n                    v = newVehicle( coord, false, 0, 0.,0. ,vec2(0.),0,0);\n                    v.road=true;\n                    \n                };\n                \n\n                           \n            }\n            \n            if(v.vtype==0){ \n                //incoming vehicles   \n                for(int i =0;i<4;i++){\n                    vec3 ncoord =buffer2coord(U + DIRS[i]);\n                    vec4 ndata = A(U + DIRS[i]);\n                    vehicle nv = decodeVehicle(ndata,ncoord);\n                    if(nv.vtype>0 && nv.offset+nv.vel>=.4 && abs(nv.dir_out -i)==2 ){\n                        //vec2 nx =next(point,b,false);\n                        //if(nx.y>0. &&  abs(int(nx.x)-i)==2) {\n\t\t\t\t\t\t\tv.vtype=nv.vtype;\n                            v.offset=nv.offset+nv.vel -1.;\n                       \t\tv.vel=nv.vel;\n                        \tv.dir_in= i;\n                            v.dir_out=nv.dir_in;\n                \t\t//}\n               \t\t }\n                }\n    \n            }\n                  \n            //packing\n            Q= encodeVehicle(v);\n        }\n    }\n    \n    \n    // save CURRENT TEXTURE SIZE\n    if(max(U.x,U.y)<1.) Q.zw= TS.xy;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// set this to 1 to stop the pattern refreshing periodically\n#define BUILD_ONLY_ONCE 0\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n// Draw a JSplacement style pattern to use as a displacement map\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tfragColour = texelFetch( iChannel3, ivec2(fragCoord), 0 );\n    \n#if (BUILD_ONLY_ONCE)\n\t// generate only first time\n\tif ( iFrame == 0 ) fragColour = vec4(.5);\n\tif ( iFrame > 256 ) return;\n#else\n\t// generate repeatedly\n\tif ( iFrame%1024 == 0  || TS.x != A(vec2(0.)).z) fragColour = vec4(.05);\n    if ( fragColour.a>.1 ) return;\n#endif\n    \n    // draw a shape\n    vec4 rand = hash4(coord2(ivec2(iFrame,1)));\n    vec4 rand2 = hash4(coord2(ivec2(iFrame,2)));\n    vec4 rand3 = hash4(coord2(ivec2(iFrame,3)));\n    \n    vec2 pos = iResolution.xy*rand.xy;\n\tfloat scale = exp2((rand.z-.5)*1.);\n    \n\tscale *= 640./iResolution.x;\n    \n\tfragCoord -= pos;\n    fragCoord *= scale;\n    \n    int rotFlip = int(floor(rand.w*8.))%8;\n    if ( (rotFlip&1) != 0 ) fragCoord.x = -fragCoord.x;\n    if ( (rotFlip&2) != 0 ) fragCoord.y = -fragCoord.y;\n    if ( (rotFlip&4) != 0 ) fragCoord.xy = fragCoord.yx;\n\n    \n    // draw blit with a wrap, to make a tileable texture\n    fragCoord = mod(fragCoord+iResolution.xy*.5,iResolution.xy)-iResolution.xy*.5;\n    \n\t// choose blit type\n    int blitType = int(floor(rand.x*255.999));\n    \n    // rectangle with missing corner\n//    if ( abs(fragCoord.x) < 30. && abs(fragCoord.y) < 20. && fragCoord.x+fragCoord.y < 30. )\n    \n    bool blit = abs(fragCoord.x) < 30.;\n    blit = blit && abs(fragCoord.y) < 20.;\n    if ( (blitType&1) != 0 ) blit = blit && fragCoord.x+fragCoord.y < 30.;\n    if ( (blitType&10) == 10 ) blit = blit && mod(fragCoord.x,8.) < 3.5;\n    if ( (blitType&12) == 12 ) blit = blit && mod(fragCoord.y,8.) < 2.5;\n    if ( (blitType&16) != 0 ) blit = blit && abs(fragCoord.x) > 3.;\n    if ( (blitType&32) != 0 ) blit = blit && abs(fragCoord.y) > 3.;\n    if ( (blitType&64) != 0 ) blit = blit && abs(fragCoord.x-20.) > 2.;\n    if ( (blitType&(128+16)) == 128 ) blit = blit && max(abs(fragCoord.x+10.),abs(fragCoord.y)) > 15.;\n\n\tif ( blit )\n    {\n    \t// can store any colour I want here, or generate it from height like jsplacement does\n    \t//fragColour = rand3;\n        float height = rand2.y;\n        fragColour.a = height;\n        \n        // colour lookup\n        // just use a slice of a texture! - meh\n        //fragColour.rgb = texture( iChannel1, vec2(height,.7) ).rgb;\n        vec3 clut[] = vec3[](vec3(0),vec3(.04),vec3(.08),vec3(.12),vec3(.16),vec3(.2),vec3(.5,.2,0),vec3(.5),vec3(.5),vec3(0,.1,.4),vec3(1),vec3(0,.3,.7));\n        fragColour.rgb = clut[min(int(floor(rand.z*12.)),11)];\n\n/*        float f = height*11.;//can't remember how to do this: float(length(clut)-1);\n        int idx = int(floor(f));\n        fragColour.rgb = mix( clut[idx], clut[idx+1], f-float(idx) );*/\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}