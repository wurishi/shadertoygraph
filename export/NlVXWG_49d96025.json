{"ver":"0.1","info":{"id":"NlVXWG","date":"1641297992","viewed":344,"name":"Parallel Error Diffusion Dither","username":"soudfv","description":"Left - Stable parallel error diffusion dithering, using hysteresis in discretization threshold.\nRight - regular bluenoise dithering","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["diffusion","error","dithering","bluenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(texture(iChannel0, fragCoord / iResolution.xy).x),1.);\n    //fragColor = vec4(vec3(texture(iChannel0, fragCoord / iResolution.xy).z*.5+.5),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DIFF_COEF_SUM      (DIFF_COEF_CENTER + DIFF_COEF_DIAG * 4.)\n#define GET_ERROR(offset)  texture(iChannel1, (fragCoord + vec2 offset) / iResolution.xy).z\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > (iMouse.xy != vec2(0) ? iMouse.x : iResolution.x * .5)) {\n        vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n      #if defined(GAMMA_FACTOR)\n        col = pow(col, vec3(GAMMA_FACTOR));\n      #endif\n        float brightness = dot(col,vec3(0.2988, 0.5869, 0.1143));\n        float i = step(texture(iChannel2, mod(fragCoord,1024.) / 1024.).r, brightness);\n        fragColor = vec4(i);\n        return;\n    }\n    \n#if defined(INPUT_GRADIENT)\n    float brightness = fragCoord.x / iResolution.x;\n#else\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n  #if defined(GAMMA_FACTOR)\n    col = pow(col, vec3(GAMMA_FACTOR));\n  #endif\n    float brightness = dot(col,vec3(0.2988, 0.5869, 0.1143));\n#endif\n\n#if defined(FEED_NOISE_ON_START)\n    if (iFrame == 0) {\n        brightness = hash12(iResolution.xy - fragCoord);\n    }\n#endif\n\n#if defined(NOISE_FACTOR)\n    brightness += hash12(fragCoord) * 2. * NOISE_FACTOR - NOISE_FACTOR;\n#endif\n    \n    float prevResult = texture(iChannel1, fragCoord / iResolution.xy).x;\n    \n    float errorUL = GET_ERROR((-.5,-.5));\n    float errorUR = GET_ERROR(( .5,-.5));\n    float errorDL = GET_ERROR((-.5, .5));\n    float errorDR = GET_ERROR(( .5, .5));\n    \n    float errorSum = (errorUL + errorUR + errorDL + errorDR) * DIFF_COEF_DIAG;\n\n    float correctedBrightness = brightness - errorSum * ERROR_FEEDBACK;\n    \n    float th = step(prevResult, THRESH_LVL) * THRESH_HYST * 2. - THRESH_HYST + THRESH_LVL;\n    float result = step(th, correctedBrightness);\n    float error = result - correctedBrightness;\n    float resultError = (errorSum + error * DIFF_COEF_CENTER) / DIFF_COEF_SUM;\n\n    fragColor = vec4(result, correctedBrightness, resultError * ERROR_ATTENUATION, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define CONFIG  2\n//#define INPUT_GRADIENT\n\n#if CONFIG == 1\n    // More stable, less quality, noise on start only\n\n    #define DIFF_COEF_CENTER 1.\n    #define DIFF_COEF_DIAG   0.95\n\n    #define ERROR_FEEDBACK     .4\n    #define ERROR_ATTENUATION  .88\n\n    #define THRESH_LVL         .5\n    #define THRESH_HYST        .2\n\n    #define FEED_NOISE_ON_START\n    //#define NOISE_FACTOR     0.05\n    #define GAMMA_FACTOR         1.3\n\n#elif CONFIG == 2\n    // Less stable, better quality, noise used continuously\n\n    #define DIFF_COEF_CENTER 1.\n    #define DIFF_COEF_DIAG   1.\n\n    #define ERROR_FEEDBACK     .5\n    #define ERROR_ATTENUATION  .83\n\n    #define THRESH_LVL         .5\n    #define THRESH_HYST        .3\n\n    #define FEED_NOISE_ON_START\n    #define NOISE_FACTOR     0.05\n    #define GAMMA_FACTOR     1.3\n\n#endif\n\n#if defined(NOISE_FACTOR) || defined(FEED_NOISE_ON_START)\n    // Noise: 1 out, 2 in... (Dave_Hoskins)\n    float hash12(vec2 p)\n    {\n        vec3 p3  = fract(vec3(p.xyx) * .1031);\n        p3 += dot(p3, p3.yzx + 33.33);\n        return fract((p3.x + p3.y) * p3.z);\n    }\n#endif\n","name":"Common","description":"","type":"common"}]}