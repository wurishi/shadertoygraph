{"ver":"0.1","info":{"id":"M3BXWR","date":"1710528570","viewed":60,"name":"to somewhere","username":"0x177","description":"if have had the idea to make a roguelike set on an infinite bridge for a while. decided to prototype what the environment might look like","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"l3XGRl","parentname":"raymarching startingpoint"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\nconst float globalAmbient = 0.8; // how strong is the ambient lightning\nconst float globalDiffuse = 1.0; // how strong is the diffuse lightning\nconst float globalSpecular = 1.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 64.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(30.0, 0.0, 0.0); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat noise(vec3 x) // iq's 3D noise\n{\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel1, (uv + 0.5)/256.0, -100.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<2; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nvec4 triplanar( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat vmax(vec3 x) {\n    return max(max(x.y,x.z),x.x);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat cylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat smin(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvec2 stairs(vec3 p) {\n    float d = 999.0;\n    float m = 0.0;\n    \n    vec3 c = p;\n    c.z = mod(c.z,2.0);\n    \n    float stair = box(c-vec3(0.0,-2.0,0.0),vec3(1.5,0.1,1.0));\n    d = min(d,stair);\n    \n    vec3 q = c;\n    q.x = abs(q.x);\n    \n    vec2 uv = vec2(q.y*3.0*cos(p.x),q.y*3.0*sin(q.x));\n    float rope = cylinder(q-vec3(1.4,-1.0,.5),0.03+(sin(uv.x*24.0)+sin(uv.y*24.0)+2.0)/128.,0.9);\n    d = smin(d,rope*0.8,0.1);\n    \n    //q.z = p.z;\n    uv = vec2(q.z*3.0*cos(p.x),q.z*3.0*sin(q.x));\n    rope = cylinder(q.yzx-vec3(-0.1,0.0,1.4),0.03+(sin(uv.x*24.0)+sin(uv.y*24.0)+2.0)/128.,2.0);\n    \n    d = min(d,rope);\n    m = (d==stair) ? 0.0 : 1.0;\n    \n    return vec2(d,m);\n}\n\nvec2 GetDist(vec3 p) {    \n    float d = 999.0;\n    float mat = 0.0;\n    \n    vec2 st = stairs(p);\n    \n    d = min(d,st.x);\n    mat = (d==st.x) ? st.y : mat;\n    \n    // why the fuck does it need length() if length(float x) returns x?\n    // or atleast i think it does. that is logical since it would be sqrt(x^2) which is equal to x\n    float cloud = length(p.y-12.0) - 9.3;\n    cloud -= fbm(p)*3.0;\n    d = min(d,cloud);\n    mat = (d==cloud) ? 2.0 : mat;\n    \n    return vec2(d,mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n  vec3 blinn_phong(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n\n    return ambientFactor + diffuseFactor + specularFactor;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    float z = max(0.0,sin(-iTime))-iTime;\n    \n    vec3 ro = vec3(0, -1., z);\n    \n    vec3 rd = vec3(uv*Rot(sin(z*6.0)*0.05),-1.0);\n    vec3 bg = vec3(1.,0.992,0.796);\n    vec3 col = bg;\n   \n    vec2 rm = RayMarch(ro, rd);\n    float d = rm.x;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        if (rm.y == 0.0) {\n            col = triplanar(iChannel0,p,n,0.1).xyz;\n        } else if (rm.y == 1.0) {\n            col = vec3(0.529,0.337,0.22);\n        } else if (rm.y == 2.0) {\n            col = vec3(2.0);\n        }\n        col *= blinn_phong(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent,ro);\n        col *= ambientOcclusion(p+n*0.1,n);\n        col *= softshadow(p,lightPos,0.1,50.);\n        col = mix(col,bg,1.0 - exp(-0.003*d*d));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}