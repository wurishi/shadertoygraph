{"ver":"0.1","info":{"id":"XlsBRs","date":"1513442790","viewed":220,"name":"Perpetual Pipe Dream 2","username":"KilledByAPixel","description":"I optimized the shader and fixed some bugs. The pipes are more pipelike and interconnected then the original. Also played with the colorization rule and spacial warping.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","zoom","pixel","endless","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Perpetual Pipe Dream 2 - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -0.5;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.2;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 3.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 16;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.0;\t// how much to center the glyph in each pixel\nconst float timeWarp\t\t\t= 1.0;\t// time warp to add curvature\nconst int glyphs[glyphSize*glyphCount] = int[]\n(// glyph sheet - pipes corospond to neighbor connection bits\n 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0,\n 0x05760, 0x00057, 0x76000, 0x77777, 0x00000, 0x00577, 0x77600, 0x77777, 0x09FA0, 0x0DFF7, 0x7FFE0, 0x7FFF7, 0x0DFE0, 0x0DFF7, 0x7FFE0, 0x7FFF7,\n 0x0DFE0, 0x001FF, 0xFF200, 0xFFFFF, 0x00400, 0x05FFF, 0xFFF60, 0xFFFFF, 0x00800, 0x09FFF, 0xFFFA0, 0xFFFFF, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF,\n 0x09BA0, 0x0009B, 0xBA000, 0xBBBBB, 0x05F60, 0x0DFFB, 0xBFFE0, 0xBFFFB, 0x00000, 0x009BB, 0xBBA00, 0xBBBBB, 0x0DFE0, 0x0DFFB, 0xBFFE0, 0xBFFFB,\n 0x00000, 0x00000, 0x00000, 0x00000, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x00000, 0x00000, 0x00000, 0x00000, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0\n);// o       x-       -x       ╾        ,       ┍        ┑       ┭       '       ┖        ┚       ┶       ┃      ┝         ┦       ╀\n//0000=0   0001=1   0010=2   0011=3   0100=4   0101=5   0110=6   0111=7   1000=8   1001=9   1010=A   1011=B   1100=C   1101=D   1110=E   1111=F\n//TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 8;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5433)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nfloat GetRecursionFade2(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec3 InitPixelColor() \n{ \n    vec3 color = vec3(0,0.4,0.1);\n    color.x -= (0.033*iTime);\n    return color; \n}\n\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    float f = GetRecursionFade(r, timePercent);\n    //if (f == 0.0)\n    //    return color;\n    \n    vec3 myColor = vec3\n    (\n    \tmix( 0.5, 0.7, RandFloat(i + r + 419*glyphPosLast.x + 773*glyphPosLast.y)),\n    \tmix(-0.7, 0.7, RandFloat(i + r + 929*glyphPosLast.x + 499*glyphPosLast.y)),\n        1.0\n    );\n    //\n    //float f2 = smoothstep(3.0, 4.0, float(r) + timePercent);\n    //if (r == 5|| r == 6)\n    //    myColor.x = mix(-0.5, 0.5, RandFloat(i + r + 419*glyphPosLast.x + 773*glyphPosLast.y)),\n\n    // combine with my color\n    myColor.x = pow(myColor.x, 3.0);\n    myColor.y = pow(myColor.y, 3.0);\n    float f2 = GetRecursionFade2(r, timePercent);\n    color.x += f2*myColor.x;\n    color.y = max(min( color.y + myColor.y*f2, 1.0), 0.0);\n    color.z = max(color.z, myColor.z*f);\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // rotate over time\n    float theta = 0.01177*iTime;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n    uv *= mat2(-s, c, c, s);\n    \n    // color wander\n    color.x += (0.1*uv.y + 0.1*uv.x + 0.01*iTime);\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.005*sin(10.0*uv.y + 0.51*iTime);\n\tuv.y += 0.005*sin(10.0*uv.x + 0.53*iTime);\n\tuv.x += 0.05*sin(2.0*uv.y + 0.57*iTime);\n\tuv.y += 0.05*sin(2.0*uv.x + 0.55*iTime);\n    \n    // rotate over time\n    float theta = 0.01*iTime;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    \n    return uv;\n}\n\nfloat TimeWarp(vec2 uv)\n{\n    // time warp to add add some 3d curve\n    return timeWarp*(uv.x*uv.x + uv.y*uv.y);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return RandInt(i) % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyphs[g + (glyphSize - 1 - y)*glyphCount]; }\n\nint GetGlyphPixel(ivec2 pos, int g)\n{\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return min(1, 0xF & (glyphRow >> (glyphSize - 1 - pos.x) * 4));\n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) { return focusList[i+2]; }\n\nint neighborsGrid[glyphSize*glyphSize];\nvoid GetNeighbors(int lastGlyph)\n{\n    for (int y = glyphCount*(glyphSize - 1), z = -1; y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[lastGlyph + y];\n        for (int x = 4*(glyphSize-1); x >= 0; x -= 4)\n            neighborsGrid[++z] = (0xF & (glyphRow >> x));\n    }\n    \n    // slower way of building neigbors if not precomputed\n    /*for (int y = 0; y < glyphSize; ++y)\n    for (int x = 0; x < glyphSize; ++x)\n    {\n        int neighbors = 0;\n        if (GetGlyphPixel(ivec2(x, y), lastGlyph) != 0)\n        {\n            neighbors |= GetGlyphPixel(ivec2(x+1, y), lastGlyph) << 0; // right\n            neighbors |= GetGlyphPixel(ivec2(x-1, y), lastGlyph) << 1; // left\n            neighbors |= GetGlyphPixel(ivec2(x, y-1), lastGlyph) << 2; // top\n            neighbors |= GetGlyphPixel(ivec2(x, y+1), lastGlyph) << 3; // bottom\n        }\n        \n        neighborsGrid[x + y*glyphSize] = neighbors;\n    }*/\n}\n\nivec2 CalculateFocusPos(int iterations)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n    \n  \t// current focus glyph must appear in correct location\n    int focusGlyph = GetFocusGlyph(iterations); \n    \n    // find all pixels that have the right neighbors (or more) for focus glyph\n    ivec2 validPlaces[glyphSize*glyphSize];\n    int c = 0;\n    \n    ivec2 pos;\n    for (int y = glyphCount*(glyphSize - 2), z = -1; y >= 1; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[glyphLast + y];\n        for (int x = 4*(glyphSize-2); x >= 1; x -= 4)\n        {\n            int neighbors = (0xF & (glyphRow >> x));\n            if (neighbors > 0 && ((neighbors & focusGlyph) == focusGlyph))\n                validPlaces[c++] = ivec2(glyphSize - 1 - x/4, glyphSize - 1 -y/glyphCount);\n        }\n    }\n\n    // pick one at random\n    return validPlaces[RandInt(iterations) % c];\n}\n  \nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, bool isFocus, ivec2 focusPos)\n{ \n    GetNeighbors(glyphLast);\n\n    // randomly remove some links\n    int r = iterations + 17*glyphPosLast.x + 23*glyphPosLast.y;\n    // random change over time\n    //r += 23*int(0.01*float((11*glyphPos.x + 7*glyphPos.y + 17*glyphPosLast.x + 13*glyphPosLast.y))+ float(glyphLast)/float(glyphCount) + 0.1*iTime);\n    \n   \tint removeCount = 10 + RandInt(++r) % 40;\n    for (int i = 0; i < removeCount; ++i)\n    {\n        int x = RandInt(++r) % (glyphSize);\n        int y = RandInt(++r) % (glyphSize);\n        \n        // remove a link\n        int neighbors = neighborsGrid[x + y*glyphSize];\n        int bit = 3*(RandInt(++r) % 2);\n        neighbors = neighbors & ~(1 << bit);\n        \n        // prevent orphans\n        if (neighbors == 0 && (RandInt(++r) % 5 < 4))\n            continue;\n        if (bit == 0)\n        {\n            if (x == glyphSize-1) continue;\n            int n = neighborsGrid[(x+1) + y*glyphSize] & ~(1 << 1);\n            if (n == 0) continue;\n            neighborsGrid[(x+1) + y*glyphSize] = n;\n        }\n        if (bit == 3)\n        {\n            if (y == glyphSize-1) continue;\n            int n = neighborsGrid[x + (y+1)*glyphSize] & ~(1 << 2);\n            if (n == 0) continue;\n            neighborsGrid[x + (y+1)*glyphSize] = n;\n        }\n        \n        neighborsGrid[x + y*glyphSize] = neighbors;\n    }\n    \n    if (isFocus)\n    {\n        // stamp down the focus glyph\n        int x = focusPos.x;\n        int y = focusPos.y*glyphSize;\n        int n = GetFocusGlyph(iterations);\n        neighborsGrid[x + y] = n; \n        \n        // fix up neighbors\n        neighborsGrid[(x-1) + y] = (0 == (n & (1 << 1)))? \n            neighborsGrid[(x-1) + y] & ~(1 << 0) : neighborsGrid[(x-1) + y] | (1 << 0);\n        neighborsGrid[(x+1) + y] = (0 == (n & (1 << 0)))?\n            neighborsGrid[(x+1) + y] & ~(1 << 1) : neighborsGrid[(x+1) + y] | (1 << 1);\n        neighborsGrid[x + y-glyphSize] = (0 == (n & (1 << 2)))?\n            neighborsGrid[x + y-glyphSize] & ~(1 << 3) : neighborsGrid[x + y-glyphSize] | (1 << 3);\n        neighborsGrid[x + y+glyphSize] = (0 == (n & (1 << 3)))?\n            neighborsGrid[x + y+glyphSize] & ~(1 << 2) : neighborsGrid[x + y+glyphSize] | (1 << 2);\n    }\n    \n    return neighborsGrid[glyphPos.x + glyphPos.y*glyphSize];\n}\n\n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (isFocus && r == 3 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z += 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, isFocus, focusPos);\n        isFocus = (glyphPos == focusPos);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n\t\n\t// get time \n    float timePercent = (3.0 + iTime + 180.+TimeWarp(uv))*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);;\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}