{"ver":"0.1","info":{"id":"lllfzX","date":"1512833264","viewed":376,"name":"Mobius Ball","username":"shau","description":"Rework of an old shader demonstrating mobius projection from a sphere","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["3d","mobius"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime * 0.5\n#define EPS 0.005\n#define FAR 100.0 \n#define PI 3.14159265359\n#define FLOOR 1.0\n#define SPHERE 2.0\n\nvec3 lp = vec3(4.0, 5.0, 2.0);\nvec4 sphere = vec4(0.0, 0.0, 0.0, 1.5);\nvec3 fo = vec3(0.0, -2.0, 0.0);\nvec3 fn = vec3(0.0, 1.0, 0.0);\nvec3 pp = vec3(0.0, 1.5 - EPS, 0.0); //projection point just under topmost pole of sphere\n\nfloat rotation = 0.0;\nfloat displayScene = 0.0;\nfloat displayProjection = 0.0;\nfloat rotateProjection = 0.0;\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQ Sphere functions\n\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(0.0);\n    h = sqrt(h);\n    float tN = -b - h;\n    float tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nvec3 sphNormal(in vec3 pos, in vec4 sph) {\n    return normalize(pos - sph.xyz);\n}\n\nfloat sphSoftShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float r = sph.w * sph.w;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r;\n    float h = b * b - c;\n    float d = -sph.w + sqrt(max(0.0, r - h));\n    float t = -b - sqrt(max(0.0, h));\n    return (t < 0.0) ? 1.0 : smoothstep(0.0, 1.0, k * d / t);\n}\n\nstruct Scene {\n    float t;\n    vec3 n;\n    float id;\n    float bft;\n};\n\nScene drawScene(vec3 ro, vec3 rd) {\n    \n    float mint = FAR;\n    float bft = 0.0;\n    vec3 minn = vec3(0.0);\n    float id = 0.0;\n    \n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0) {\n        mint = ft;\n        minn = fn;\n        id = FLOOR;\n    }\n    \n    vec2 st = sphIntersect(ro, rd, sphere);\n    if (st.x > 0.0 && st.x < mint) {\n        \n        vec3 rp = ro + rd * st.x;\n   \n        mint = st.x;\n        bft = st.y;\n        minn = sphNormal(rp, sphere);\n        id = SPHERE;\n    }\n    \n    return Scene(mint, minn, id, bft);\n}\n\nvec3 gridColour(vec3 rp, vec3 col) {\n \n    vec3 pc = vec3(0.0);\n    \n    vec2 grid = fract(rp.xz * 2.0);\n    pc += col * (step(grid.x, 0.1) + step(0.9, grid.x));\n    pc += col * (step(grid.y, 0.1) + step(0.9, grid.y));    \n    pc *= step(abs(rp.x), 2.55) * step(abs(rp.z), 2.55);\n\n    return pc;\n}\n\nvec3 sphereProjectionColour(vec3 rp, vec3 col) {\n    \n    vec3 pc = vec3(0.0);\n\n    rp.xy *= rot(rotation * rotateProjection);\n        \n    vec3 pd = normalize(rp - pp);\n    float ft = planeIntersection(pp, pd, fn, fo);\n    if (ft > 0.0) {\n        vec3 prp = pp + pd * ft; \n        pc += gridColour(prp, col);\n    }\n\n    return pc;\n}\n\nvec3 floorProjectionColour(vec3 rp, vec3 col) {\n \n    vec3 pc = vec3(0.0);\n    \n    vec3 pd = normalize(pp - rp);\n    vec2 st = sphIntersect(rp, pd, sphere);\n    if (st.x > 0.0) {\n        vec3 srp = rp + pd * st.x;\n        pc += sphereProjectionColour(srp, col);            \n    }\n    \n    return pc * 0.4;\n}\n\nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\n \n    vec3 pc = vec3(0.0);\n    \n    vec3 rp = ro + rd * scene.t;\n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    float diff = max(dot(ld, scene.n), 0.03);\n    float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 16.0);\n    float atten = 1.0 / (1.0 + lt * lt * 0.008);\n    float sh = 1.0; \n    \n    //scene colour\n    vec3 sc = vec3(0.05, 0.0, 0.3) * 0.1 * clamp(scene.n.y * -1.0, 0.0, 1.0);\n    sc += vec3(0.0, 0.5, 0.0) * diff; \n    sc += vec3(1.0) * spec;\n    sc *= atten;\n    \n    //projection colour\n    vec3 prc = vec3(0.0);\n    \n    if (scene.id == FLOOR) {\n        \n        sh = sphSoftShadow(rp - (rd * EPS), ld, sphere, 2.0);\n        \n        prc += floorProjectionColour(rp, vec3(0.0, 1.0, 0.0));\n\n    } else if (scene.id == SPHERE) {\n                        \n        prc += sphereProjectionColour(rp, vec3(0.0, 1.0, 0.0));\n        //back face\n        vec3 bfrp = ro + rd * scene.bft;\n        prc += sphereProjectionColour(bfrp, vec3(0.0, 1.0, 0.0)) * (1.0 - displayScene) * 0.8;\n\n        //see through to floor\n        vec3 fpc = vec3(0.0);\n        float ft = planeIntersection(ro, rd, fn, fo);\n        if (ft > 0.0) {\n            vec3 frp = ro + rd * ft;\n            fpc = floorProjectionColour(frp, vec3(0.0, 1.0, 0.0)) * (1.0 - displayScene);\n        }  \n        //TODO: this is a bit crap\n        prc += fpc;\n    }\n    \n    sc *= sh;\n    pc += sc * displayScene;\n    \n    prc *= atten;\n    pc += prc * displayProjection;\n    \n    return pc;\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    ro = lookAt + vec3(3.0, 2.0, -5.0);\n    \n    ro.xz *= rot(T);\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid setupScene() {\n    \n    float timeline = mod(T, 20.0);\n    \n    if (timeline < 5.0) {\n        displayScene = 1.0;\n        displayProjection = 0.0;\n        rotateProjection = 0.0;\n    } else if (timeline < 10.0) {\n        displayScene = 1.0;\n        displayProjection += clamp((timeline - 5.0) * 0.5, 0.0, 1.0);\n        rotateProjection = 0.0;\n    } else if (timeline < 15.0) {\n        displayScene = clamp(1.0 - (timeline - 10.0) * 0.5, 0.0, 1.0);\n        displayProjection = 1.0;\n        rotateProjection = 1.0;\n        rotation = timeline - 10.0;\n    } else if (timeline < 20.0) {\n        displayScene = clamp((timeline - 15.0) * 0.5, 0.0, 1.0);\n        displayProjection = clamp(1.0 - (timeline - 15.0) * 0.5, 0.0, 1.0);\n        rotateProjection = 1.0;\n        rotation = timeline - 10.0;        \n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        \n    vec3 pc = vec3(0.0);\n    \n    setupScene();\n    \n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n    \n    Scene scene = drawScene(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        pc = colourScene(ro, rd, scene);        \n    }\n\t\n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}