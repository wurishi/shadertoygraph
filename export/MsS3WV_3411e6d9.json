{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define OBJ_ORIGINAL\n//#define BG_ORIGINAL\n\n//#define LOW_Q\n\n#ifdef LOW_Q\n    #define MARCHSTEPS 60\n#else\n    #define MARCHSTEPS 30\n    #define AMBIENT_OCCLUSION\n    #define DOUBLE_SIDED_TRANSPARENCY\n#endif\n\n#define maxDist 10.0\n\n#define SPECULAR\n#define REFLECTIONS\n#define TRANSPARENCY\n#define SHADOWS\n#define FOG\n\n#define DIRECTIONAL_LIGHT\n#define DIRECTIONAL_LIGHT_FLARE\n\n#define PI 3.141592654\n\n#define kNt  -1.0\t\t//no trans\n#define kTt  1.0\t\t//yes trans\n#define kIt  0.0\t\t//inverse trans\n\nconst float mate1 = 1.0;\n\nstruct sRay { vec3 ro; vec3 rd; float sd; float rl; };\nstruct sHit { vec3 hp; float hd; vec3 oid; };\nstruct sSurf { vec3 nor; vec3 ref; vec3 tra; };\nstruct sMat { vec3 ctc; float frs; float smt; vec2 par; float trs; float fri; };\nstruct sShade { vec3 dfs; vec3 spc; };\nstruct sLight { vec3 rd; vec3 col; };\n\n\n/***********************************************/\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n/***********************************************/\nfloat sdBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0)-r + length(max(d,0.0)) ;\n}\n/***********************************************/\nfloat sminp(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n/***********************************************/\nfloat smine(float a, float b, float k) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n/***********************************************/\n#ifdef OBJ_ORIGINAL\nfloat skull(vec3 p) {\n    vec3 q=p;\n    p.y+=sin(p.y*1.6)*0.2;\n    p.z-=p.x*0.05;\n    float e=sdTorus(p+vec3(-0.4,0.0,0.0),vec2(0.3,0.1));   //eye\n    p.z=q.z;\n    p.z+=p.x*0.05;\n    float f=sdTorus(p+vec3( 0.4,0.0,0.0),vec2(0.3,0.1));   //eye\n    p.x+=sin(p.x);\n    float n=sdTorus(p+vec3( 0.0,0.45,0.19),vec2(0.2,0.05));  //nose\n    p=q;\n    p.x+=sin(p.x*0.07);\n    p.x*= cos(p.y*0.6+abs(cos(3.7+p.y)*0.2)*1.1) ;\n    float s=length(p+vec3( 0.0,-0.14,-0.79))-0.98; //back\n    p=q;\n    p.y+=sin(p.y*1.7)*0.3;\n    float d=length(p+vec3(-0.4,0.0,0.1))-0.25; //eyehole\n        s=max(s,-d);\n          d=length(p+vec3( 0.4,0.0,0.1))-0.25;  //eyehole  \n        s=max(s,-d);\n    p=q;\n    p.z+=p.z-p.y*0.4;\n    float v=sdBox(p+vec3(0.0,0.68,-0.7),vec3(0.02,0.07,0.8), 0.27);   //chin\n    float o=sminp(e,f,0.5);\n    o=smine(o,n,14.0);\n    o=sminp(o,s,0.09);\n    return smine(o,v,12.0);\n}\n#else\nfloat skull(vec3 p) {\n\tp.x = -abs(p.x);\n    vec3 q=p;\n    p.y+=sin(p.y*1.6)*0.2;\n    p.z=q.z;\n    p.z+=p.x*0.05;\n    float f=sdTorus(p+vec3( 0.4,0.0,0.0),vec2(0.3,0.1));   //eye\n    p.x+=sin(p.x);\n    float n=sdTorus(p+vec3( .03,0.45,0.19),vec2(0.2,0.05));  //nose\n    p=q;\n    p.x+=sin(p.x*0.07);\n    p.x*= cos(p.y*0.6+abs(cos(3.7+p.y)*0.2)*1.1) ;\n    float s=length(p+vec3( 0.0,-0.14,-0.79))-0.98; //back\n    p=q;\n    p.y+=sin(p.y*1.7)*0.3;\n    float d=length(p+vec3( 0.4,0.0,0.1))-0.25;  \n    s=max(s,-d);\n    p=q;\n    float o = sminp(length(p+vec3(.42,.35,-.05))-.15,f,0.08);\n    p.z+=p.z-p.y*0.4;\n    float v=sdBox(p+vec3(0.0,0.68,-0.7),vec3(0.02,0.07,0.8), 0.27);   //chin\n    o=smine(o,n,14.0);\n    o=sminp(o,s,0.09);\n    return smine(o,v,12.0);\n}\n#endif\n/***********************************************/\nvec4 opU( vec4 a, vec4 b ) {\n    return mix(a, b, step(b.x, a.x));\n}\n/***********************************************/\nvec4 opUt( vec4 a, vec4 b, float fts ){    \n    vec4 vScaled = vec4(b.x * (fts * 2.0 - 1.0), b.yzw);\n    return mix(a, vScaled, step(vScaled.x, a.x) * step(0.0, fts));\n}\n/***********************************************/\nvec4 DE( vec3 hp, float fts ) {          \n    vec4 vResult = vec4(maxDist, -1.0, 0.0, 0.0);\n    vec4 vDistSkull = vec4(skull(hp), mate1, hp.xz);  \n    return opUt(vResult, vDistSkull, fts);\n}\n/***********************************************/\nsMat getMat( sHit hitInfo ) {\n    sMat mat;\n //   if(hitInfo.oid.x == mate1) {\n        mat.frs = 0.31;\n        mat.smt = 1.0;\n        mat.trs = 1.0;\n        mat.fri = 0.75;\n        const float fExtinctionScale = 2.0;\n            vec3 tc = vec3(0.93,0.96,1.0);        //tex/col\n        mat.ctc = (vec3(1.0) - tc) * fExtinctionScale; \n//    }\n    return mat;\n}\n/***********************************************/\nvec3 getbg( vec3 rd ) {\n#ifdef BG_ORIGINAL\n    const vec3 tc = vec3(0.65, 0.78, 1.0);\n    const vec3 cc = tc * 0.5;\n    float f = clamp(rd.y, 0.0, 1.0);\n    return mix(cc, tc, f);\n#else\n\treturn texture(iChannel0, rd).xyz;\n#endif\t\n}\n/***********************************************/\nsLight GetDLight() {\n    sLight result;\n    result.rd = normalize(vec3(-0.2, -0.3, 0.5));\n    result.col = vec3(8.0, 7.5, 7.0);\n    return result;\n}\n/***********************************************/\nvec3 GetAmb(vec3 nor) {\n    return getbg(nor);\n}\n/***********************************************/\nvec3 normal(vec3 p, float fts) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy,fts).x +\te.yyx*DE(p+e.yyx,fts).x +\te.yxy*DE(p+e.yxy,fts).x +\te.xxx*DE(p+e.xxx,fts).x));\n}\n/***********************************************/\nvoid march( sRay ray, out sHit res, int maxIter, float fts ) {        \n    res.hd = ray.sd;\n    res.oid.x = 0.0;\n        \n    for(int i=0;i<=MARCHSTEPS;i++) {\n        res.hp = ray.ro + ray.rd * res.hd;\n        vec4 r = DE( res.hp, fts );\n        res.oid = r.yzw;\n        if((abs(r.x) <= 0.01) || (res.hd >= ray.rl) || (i > maxIter)) break;\n        res.hd = res.hd + r.x; \n    }\n    if(res.hd >= ray.rl) {\n        res.hd = maxDist;\n        res.hp = ray.ro + ray.rd * res.hd;\n        res.oid.x = 0.0;\n    }\n}\n/***********************************************/\nfloat csh( vec3 hp, vec3 nor, vec3 lrd, float d ) {\n    #ifdef SHADOWS\n        sRay ray;\n        ray.rd = lrd;\n        ray.ro = hp;\n        ray.sd = 0.05 / abs(dot(lrd, nor));\n        ray.rl = d - ray.sd;\n        sHit si;\n        march(ray, si, 32, kNt);\n        float s = step(0.0, si.hd) * step(d, si.hd );\n        return s;          \n    #else\n            return 1.0;\n    #endif\n}\n\n/***********************************************/\nfloat cao( sHit hi, sSurf s) {\n    #ifdef AMBIENT_OCCLUSION    \n        vec3 hp = hi.hp;\n        vec3 nor = s.nor;\n        float ao = 1.0;\n        \n        float d = 0.0;\n        for(int i=0; i<=5; i++) {\n            d += 0.1;\n            vec4 r = DE(hp + nor * d, kNt);\n            ao *= 1.0 - max(0.0, (d - r.x) * 0.2 / d );                                  \n        }\n        return ao;\n    #else\n            return 1.0;\n    #endif    \n}\n/***********************************************/\n\nvec3 getfog( vec3 col,  sRay ray, sHit hi) {\n    #ifdef FOG\n        float a = exp(hi.hd * - 0.05);\n        vec3 fog = getbg(ray.rd);\n\n        #ifdef DIRECTIONAL_LIGHT_FLARE\n            sLight lig = GetDLight();\n            float f = clamp(dot(-lig.rd, ray.rd), 0.0, 1.0);\n            fog += lig.col * pow(f, 10.0);\n        #endif \n\n        col = mix(fog, col, a);\n    #endif\n\n    return col;    \n}\n/***********************************************/\nfloat Schlick(vec3 nor, vec3 v, float frs, float sf) {\n    float f = dot(nor, -v);\n    f = clamp((1.0 - f), 0.0, 1.0);\n    float fDotPow = pow(f, 5.0);\n    return frs + (1.0 - frs) * fDotPow * sf;\n}\n/***********************************************/\nvec3 Fresnel( vec3 dif, vec3 spe, vec3 nor, vec3 v, sMat m) {\n    float f = Schlick(nor, v, m.frs, m.smt * 0.9 + 0.1);\n    return mix(dif, spe, f);    \n}\n/***********************************************/\nfloat Phong( vec3 ird, vec3 lrd, vec3 nor, float smt) {          \n    vec3 v = normalize(lrd - ird);\n    float f = max(0.0, dot(v, nor));\n    float sp = exp2(4.0 + 6.0 * smt);\n    float si = (sp + 2.0) * 0.125;\n    return pow(f, sp) * si;\n}\n\n/***********************************************/\nsShade setDLight(sLight l, vec3 p, vec3 d, vec3 nor, sMat m ) {\n    sShade s;\n    vec3 lrd = -l.rd;\n    float sf = csh( p, nor, lrd, 8.0 );\n    vec3 il = l.col * sf * max(0.0, dot(lrd, nor));\n    s.dfs = il;                                  \n    s.spc = Phong( d, lrd, nor, m.smt ) * il;\n    return s;\n}  \n/***********************************************/\nvec3 setcol( sRay ray, sHit hi, sSurf sc, sMat m) {\n    vec3 col;\n    sShade s;\n    s.dfs = vec3(0.0);\n    s.spc = vec3(0.0);\n    float ao = cao(hi, sc);\n    vec3 al = GetAmb(sc.nor) * ao;\n    s.dfs += al;\n    s.spc += sc.ref;\n\n    #ifdef DIRECTIONAL_LIGHT\n    sLight dl = GetDLight();\n    sShade sh = setDLight(dl, hi.hp, ray.rd, sc.nor, m);\n    s.dfs += sh.dfs;\n    s.spc += sh.spc;\n    #endif\n\n    vec3 dr = s.dfs * m.ctc;              \n\n    dr = mix(dr, sc.tra, m.trs);    \n\n    #ifdef SPECULAR\n        col = Fresnel(dr , s.spc, sc.nor, ray.rd, m);\n    #else\n        col = dr;\n    #endif\n    \n    return col;\n}\n/***********************************************/\nvec3 getcol2(sRay ray ) {\n    sHit hi;\n    march(ray, hi, 32, kNt);\n    vec3 col;\n\n    if(hi.oid.x < 0.5) {\n        col = getbg(ray.rd);\n    } else {\n        sSurf s;        \n        s.nor = normal(hi.hp, kNt);\n        sMat m = getMat(hi);\n        s.ref = getbg(reflect(ray.rd, s.nor));\n        m.trs = 0.0;\n        col = setcol(ray, hi, s, m);\n    }\n    col=getfog(col, ray, hi);\n    return col;\n}\n/***********************************************/\nvec3 getref( sRay ray, sHit hitInfo, sSurf s ) {\n    #ifdef REFLECTIONS    \n        sRay rRay;\n        rRay.rd = reflect(ray.rd, s.nor);\n        rRay.ro = hitInfo.hp;\n        rRay.rl = 16.0;\n        rRay.sd = 0.1 / abs(dot(rRay.rd, s.nor));\n        return getcol2(rRay);      \n    #else\n        return getbg(reflect(ray.rd, s.nor));                              \n    #endif\n}\n/***********************************************/\nvec3 gettrans( sRay ray, sHit hit, sSurf s, sMat m ) {\n    #ifdef TRANSPARENCY  \n        sRay rRay;\n        rRay.rd = refract(ray.rd, s.nor, m.fri);\n        rRay.ro = hit.hp;\n        rRay.rl = 16.0;\n        rRay.sd = 0.05 / abs(dot(rRay.rd, s.nor));\n        #ifdef DOUBLE_SIDED_TRANSPARENCY\n            sHit hit2;\n            march(rRay, hit2, 32, kIt);\n            vec3 nor = normal(hit2.hp, kIt);\n                sRay rRay2;\n                rRay2.rd = refract(rRay.rd, nor, 1.0 / m.fri);\n                rRay2.ro = hit2.hp;\n                rRay2.rl = 16.0;\n                rRay2.sd = 0.0;\n            float ed = hit2.hd;\n            vec3 col = getcol2(rRay2);\n        #else\n            vec3 col = getcol2(rRay);                                                                        \n            float ed = 0.5;\n                \n        #endif\n\n        return col * clamp(exp(-(m.ctc * ed)),0.0,1.0);\n    #else\n        return getbg(reflect(ray.rd, s.nor));                              \n    #endif\n}\n/***********************************************/\nvec3 getcol( sRay ray ) {                                                          \n    sHit i;\n    march(ray, i, MARCHSTEPS, kTt);   //256\n    vec3 col;\n\n    if(i.oid.x < 0.5) {\n        col = getbg(ray.rd);\n    } else  {\n        sSurf s;\n        s.nor = normal(i.hp, kTt);\n        sMat m = getMat(i);\n        s.ref = getref(ray, i, s);\n        if(m.trs > 0.0) s.tra = gettrans(ray, i, s, m);\n        col = setcol(ray, i, s, m);\n    }\n    getfog(col, ray, i);\n\n    return col;\n}\n/***********************************************/\nsRay setcray( vec3 hp, vec3 i, vec2 fragCoord) {\n    sRay ray;\n    vec3 f = normalize(i - hp);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    vec2 vUV = ( fragCoord.xy / iResolution.xy );\n    vec2 vvc = vUV * 2.0 - 1.0;\n    float fRatio = iResolution.x / iResolution.y;\n    vvc.y /= fRatio;                          \n    ray.ro = hp;\n    vec3 r = normalize(cross(f, vUp));\n    vUp = cross(r, f);\n    ray.rd = normalize( r * vvc.x + vUp * vvc.y + f); \n    ray.sd = 0.0;\n    ray.rl = maxDist;     \n    return ray;\n}\n\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.xy;    \n    \n    /* animate */\n    float rot=iTime*0.234;\n    /* animate */\n    \n    float h = mix(0.0, PI, m.x+1.0-rot);\n    float e = mix(0.0, 2.5, m.y);\n    float d = mix(2.5, 2.5, m.y);\n    \n    vec3 ro = vec3(sin(h) * cos(e), sin(e), cos(h) * cos(e)) * d;\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    sRay ray=setcray( ta + ro, ta, fragCoord);\n\n    vec3 col = getcol( ray );  \n\n    vec3 tcol=col*2.0;\n    col=tcol/(1.0+tcol);\n  \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsS3WV","date":"1393492122","viewed":1509,"name":"Crystal Skull","username":"avix","description":"A work of the aliens ?","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["3d","transparency","raymarch","glass"],"hasliked":0,"parentid":"","parentname":""}}