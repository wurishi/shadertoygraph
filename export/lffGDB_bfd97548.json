{"ver":"0.1","info":{"id":"lffGDB","date":"1703447333","viewed":40,"name":"combination colorful","username":"nayk","description":"neon,coroful,new,combination,moving,rotate","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["rotate","moving","new","neon","combination","coroful"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* original https://www.shadertoy.com/view/MfsGRs https://www.shadertoy.com/view/DtGyWh*/\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(34,2,51))*.5+.5)\nvec3 r;\n\nfloat sph (vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat aabb(vec3 p, vec3 d) {\n  \n    vec3 neg = -(d / 2. - p)/r;\n    vec3 pos =  (d / 2. - p)/r;\n\n    vec3 bot = min(neg, pos);\n \n    float top = max(max(bot.x, bot.y), bot.z);\n\n    return max(0.0, top); // Ensure we don't return a negative value\n}\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float shape = box(p, vec3(f1 * .46));\n\n   float bound = aabb(p, vec3(scale*1.01));\n   \n   return min(bound , shape)/scale;\n}\nfloat rnd(float t) { return fract(sin(t*758.655)*352.741); }\nfloat curve(float t, float d) { \n    t/=d; \n    \n    return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));}\n    \n    \n    float map(vec3 p) {\n    vec3 q = p;\n    float pos = p.y + 5.;\n\n    float f1 = curve(iTime,1.);\n    for (float i = 1.; i < 2.; i++) {\n            \n           q.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n            pos = max(pos, -field(q,pow(01.4 + f1/20.,i)/16.));\n     \n    }\n    \n    return pos;\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 uv=C.xy/iResolution.xy-.5;\n     float t = iTime * .1 + ((.25 + .05 * sin(iTime * 1.1))/(length(uv.xy) + .222)) * 10.2;\nfloat si = sin(t);\nfloat co = cos(t);\n\nmat2 ma = mat2(co, si, -si, co);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n    \n        p=g*d;\n\n        p.z+=-iTime*1.5;\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n           p.xy*=mat2(cos(iTime*0.12),sin(iTime*0.12),-sin(iTime*0.12),cos(iTime*0.12) );\n           \n        s=8.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n           p+=map(p); \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            p.y<p.x?p=p.zyx:p;\n             \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+cos(iTime*.03+.5*cos(iTime*.03))*3.,\n                    70,\n                    8.+cos(iTime*.05)*5.\n                 );\n         }\n       g+=e=length(p.xy/s);\n       \n    }\n}","name":"Image","description":"","type":"image"}]}