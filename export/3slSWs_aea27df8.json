{"ver":"0.1","info":{"id":"3slSWs","date":"1552587402","viewed":1184,"name":"Random Vector Field","username":"bonsairobo","description":"Flow along a random velocity vector field; integrate using state in a texture buffer. Resolution gets set at t = 5 so go fullscreen before then.","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["warping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n)\n{\n    return fract(10000.0 * sin(n));\n}\n\n// Do cubic interpolation between random numbers at each point on a grid.\nfloat noise2_param(vec2 p, float s, float t)\n{\n    vec2 fl = floor(p);\n    vec2 fr = fract(p);\n\n    vec2 terp = fr * fr * (3.0 - 2.0 * fr);\n\n    float n = fl.x * s + fl.y * t;\n\n    return mix(\n        mix(hash(n),     hash(n + s),     terp.x),\n        mix(hash(n + t), hash(n + s + t), terp.x),\n        terp.y);\n}\n\nfloat noise2(vec2 p)\n{\n    return noise2_param(p, 87.0, 37.0);\n}\n\n// Fractional Brownian motion\nconst float theta = 60.0;\nconst mat2 m = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n\nfloat fbm(vec2 p)\n{\n    float ret = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 5; ++i) {\n        ret += amp * noise2(p);\n        p = 2.0 * m * p;\n        amp *= 0.5;\n    }\n\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n    fragColor = vec4(fbm(pos), fbm(pos + 1.0), 1.0, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash(float n)\n{\n    return fract(10000.0 * sin(n));\n}\n\n// Do cubic interpolation between random numbers at each point on a grid.\nfloat noise2_param(vec2 p, float s, float t)\n{\n    vec2 fl = floor(p);\n    vec2 fr = fract(p);\n\n    vec2 terp = fr * fr * (3.0 - 2.0 * fr);\n\n    float n = fl.x * s + fl.y * t;\n\n    return mix(\n        mix(hash(n),     hash(n + s),     terp.x),\n        mix(hash(n + t), hash(n + s + t), terp.x),\n        terp.y);\n}\n\nfloat noise2(vec2 p)\n{\n    return noise2_param(p, 87.0, 37.0);\n}\n\n// Fractional Brownian motion\nconst float theta = 60.0;\nconst mat2 m = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n\nfloat fbm(vec2 p)\n{\n    float ret = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 5; ++i) {\n        ret += amp * noise2(p);\n        p = 2.0 * m * p;\n        amp *= 0.5;\n    }\n\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iTime < 5.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    // [-1, 1] coordinate frame\n    vec2 q = fragCoord / iResolution.xy;\n    vec2 p = 2.0 * q - 1.0;\n\n    // Aspect correction\n    p.x *= iResolution.x / iResolution.y;\n\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 offset = texel.xy;\n    float t = texel.z;\n    vec2 pos = p + offset;\n    vec2 vector = vec2(fbm(pos), fbm(pos + 1.0));\n\n    float new_t = iTime;\n    float dt = new_t - t;\n    vec2 new_offset = offset + dt * vector;\n\n\tfragColor = vec4(new_offset, new_t, 0.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}