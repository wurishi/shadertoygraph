{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//Purple haze! All in my torus. \n//Lately rays don't just trace one surface. \n//Unstable root solver, don't know why. \n//Scuse me while I rip POVRay.  \n//Dow dow dow, widdly widdly squee!\n\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord);\nvec4 Sort(vec4 n);\nvoid quartic_descartes(float a, float b, float c, float d, inout vec4 rts);\nvec4 RayTorus(vec3 A, vec3 B, float R, float r);\nfloat noise( in vec3 x );\nvec2 noise2( in vec3 x );\n\nfloat sdTorus( vec3 p, vec2 t );\n\n#define pi 3.1415927\n\n\n\nvec3 RotY(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.z*s,\n\t\t\t\tp.y,\n\t\t\t\t-p.x*s+p.z*c);\n}\n\nvec3 RotZ(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.y*s,\n\t\t\t\t-p.x*s+p.y*c,\n\t\t\t\tp.z);\n}\n\nvec4 quat_rotation( float half_angr, vec3 unitVec )\n{\n    float s, c;\n    s = sin( half_angr );\n    c = cos( half_angr );\n    return vec4( unitVec*s, c );\n}\n\nvec3 quat_times_vec(vec4 q, vec3 v)\n{\n\t//http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n\tvec3 t = 2. * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n#define R ((1.+sin(iTime*0.7))*1.2)\nfloat r=.75;\n\n\n#define RATE\t7.\t\t\t\n\nfloat DensityFalloff(vec3 p)\n{\t\n\tfloat sdf = max(-sdTorus( p, vec2(R,r)),0.);\n\tfloat falloff = sdf/r;\n//\tfalloff*=falloff;\n//\tfalloff*=falloff;\n\t\n\treturn falloff;\n}\n\nvec3 animate(vec3 p)\n{\n\tp=RotZ(p, iTime*0.5);\t//spin on main axis\n\n#if 1\t\n\tvec3 q = vec3(normalize(p.xy),0.);\t//vec to main ring\n\tvec3 ax = vec3(-q.y,q.x,0.);\t\t//perpendicular axis of rotation\n\tq.xy *= R;\t\t\t\t\t\t\t//point on main ring\n\tvec3 loc = p-q;\t\t\t\t\t\t//offset along little ring\n\tvec4 quat_rot = quat_rotation( iTime, ax );\n\tloc = quat_times_vec(quat_rot, loc);\n\tp = q + loc;\t\n#endif\n\t\n\treturn p;\n}\n\nvec2 density(vec3 p)\n{\n\tfloat falloff =\tDensityFalloff(p);\n\t\n\tp = animate(p);\n\n\tfloat\td = noise( p*RATE);\n\td *= noise( p*(RATE*1.17) )-0.3;// * 0.5;\n\td *= noise( p*(RATE*4.03) )-0.2;// * 0.25;\t\t\t\t\n\td *= noise( p*(RATE*8.11) )-0.1;// * 0.125;\n\t\n\t\n\tfloat dd = 4.*d*falloff;\n\tfloat c = noise( p*RATE*0.3);\n\treturn vec2(dd, c);\n}\n\nvec3 lightDir = normalize(vec3(-.25,1,1));\n\n\nvec4 march(vec4 accum, vec3 viewP, vec3 viewD, float tt, float end)\n{\n\t//exponential stepping\n\tfloat slices = 300.;\n\tfloat Far = 10.;\n\t\n\tfloat sliceStart = log2(tt)*(slices/log2(Far));\n\tfloat sliceEnd = log2(end)*(slices/log2(Far));\n\t\t\n\tfloat sliceRate = 1./ exp2(log2(Far)/slices);\n\t\n\tfloat last_tt = tt;\n\t\n#define STEPS\t64\t\n\tif (tt< 1e5)\t\t\n\tfor (int i=0; i<STEPS; i++)\n\t{\t\t\t\t\n\t\tfloat sliceI = sliceStart + float(i);\t//advance an exponential step\n\t\ttt = exp2(sliceI*(log2(Far)/slices));\t//back to linear\n\t//\ttt = min(tt,end);\t//no sense sampling past the last intersection ... \n\n\t\tvec3 p = viewP+tt*viewD;\n\t\t\n\t//\tp = animate(p);\n\t\t\n\t\tvec2 dc = density(p);\n\t\t\n\t\tvec3 h = hsv2rgb(vec3(dc.y*0.5+0.5,0.7,0.2));\n\n\t\t//lighting\n\t\tfloat inside=1.-DensityFalloff(p);\n#if 0\t\n\t\t//gradient ... too much for chrome/angle/win\n\t\tfloat e = 0.5;\n\t\tfloat dx = density(p + vec3(e,0,0)).x;\n\t\tfloat dy = density(p + vec3(0,e,0)).x;\n\t\tfloat dz = density(p + vec3(0,0,e)).x;\n\t\tfloat d = dc.x;\n\t\tvec3 n = -normalize(vec3(dx-d,dy-d,dz-d));\n\n\t\tvec3 n = lightDir;\n\t\th *= max(dot(n,lightDir),0.)+.2*inside;\n#endif\t\t\n\t\t\n#if 1\n\t\t//dodgy lighting/gradient\t\t\n\t\tfloat e = 0.5;\n\t\tfloat dl = density(p - lightDir*e).x / e;\n\t\th *= clamp(inside + .4,0.,1.);\n\t\th += (dl- 0.125 )* 0.25 ;\n#endif\t\t\n\t\tdc.x *= (tt-last_tt)*100.;\t//density ought to be proportional to integral over step length?\n\t\tlast_tt = tt;\n\t\t\n\t\tvec4 col = vec4(h,dc.x);\n//\t\tcol = clamp(col,vec4(0),vec4(1));\t//screw it, the clipping looks magically sparkly\n\t\tcol.rgb *= col.a + .025;\n\t\taccum = accum + col*(1.0 - accum.a);\t\n\n\t\tif (accum.a > 1.) break;\n\t\t\n\t\tif (sliceI > sliceEnd) break; //out of exponential steps\t\n\t}\t\n\t\n\treturn accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewP, viewD;\n\tMakeViewRay(viewP, viewD, fragCoord);\n\n\t//ground plane\n\tfloat floor_height = -3.;\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\n\tvec3 p = viewP+viewD*floor_intersect_t;\n\tvec3 c = texture(iChannel0,p.xz*0.1).xyz;\n\tc = pow(c,vec3(2.2));\n#if 1\t\n\t//darken by shadow ray through torus\n\tvec4 shadow_roots = RayTorus(p, lightDir, R, r);\n\tfloat thick=0.;\n\tfor (int i=0; i<4; i+=2)\n\t{\n\t\tif (shadow_roots[i+1]<1e5)\n\t\t{\n\t\t\tvec3 sp = p + lightDir * ((shadow_roots[i+1]+shadow_roots[i])*0.5);\n\t\t\tfloat d = density(sp).x;\n\t\t\td=sqrt(d);\n\t\t\td=sqrt(d);\n\t\t\tthick += (shadow_roots[i+1]-shadow_roots[i])*d;\n\t\t}\n\t}\n\t\n\tc *= max(1.0-thick*.5,.2);\n#endif\t\n\n\t//ray marching segments of torus intersections\n\tvec4 roots = RayTorus(viewP, viewD, R, r);\n\n\tvec4 accum = vec4(0);\n\taccum = march(accum,viewP, viewD, roots[0],roots[1]);\n\taccum = march(accum,viewP, viewD, roots[2],roots[3]);\n\n\t//comp over background \n\tc = mix( c, accum.xyz, accum.a);\n\n\t\n\tc=pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n}\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = vec3(0.);\n\teye = vec3(2.5,3.,-2.5) * 1.5; \t\n\teye = RotY(eye,iTime*.4);\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\nvec4 Sort( vec4 a)\n{\n\tvec4 m = vec4(min(a.xz,a.yw), max(a.xz,a.yw) );\n\tvec4 r = vec4(min(m.xz,m.yw), max(m.xz,m.yw) ); \n\ta = vec4( r.x, min(r.y,r.z),  max(r.y,r.z), r.w );\n\treturn a;\n}\n\n//watch out, unstable on \"small\" R, r, certain planes and slight breezes!! :(\n//http://research.microsoft.com/en-us/um/people/awf/graphics/ray-torus.html\nvec4 RayTorus(vec3 A, vec3 B, float RR, float r)\n{\n\t//B assumed normalized\n\t\n\tfloat aa = dot(A,A);\n\tfloat ab = dot(A,B);\n\t\t\n\t// Set up quartic in t:\n\t//\n\t//  4     3     2\n\t// t + A t + B t + C t + D = 0\n\t//\n\t\n\tfloat R2 = RR*RR;\n\tfloat K = aa - r*r - R2;\n\tK *= 0.5;\n\tfloat qA = ab;\n\tfloat qB = ab*ab + K + R2*B.z*B.z;\n\tfloat qC = K*ab + R2*A.z*B.z;\n\tfloat qD = K*K +  R2*(A.z*A.z - r*r);\n\n    // 4t^3 + 3At^2 + 2Bt + C\n\t//12t^2 + 6At   + 2B\n\t\n\tvec4 roots = vec4(1e10);\n\tquartic_descartes(qA,qB,qC,qD, roots);\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tif (roots[i] < 0.) \n\t\t\troots[i] = 1e10;\t\n\t}\n\t\n\troots = Sort(roots);\n\t\t\n\treturn roots;\n}\n\n\n//https://github.com/POV-Ray/povray/blob/3.7-stable/source/backend/math/polysolv.cpp#L808\n\n#define DBL float \n\n#define SMALL_ENOUGH 1.0e-3\n\nfloat solve_cubic(float a1, float a2, float a3)\n{\n\tDBL Q, RR, Q3, R2, sQ, d, an, theta;\n\tDBL A2;\n\t\n\tA2 = a1 * a1;\n\n\tQ = (A2 - 3.0 * a2) * (1./ 9.0);\n\n\t/* Modified to save some multiplications and to avoid a floating point\n\t   exception that occured with DJGPP and full optimization. [DB 8/94] */\n\n\tRR = (a1 * (A2 - 4.5 * a2) + 13.5 * a3) * (1./ 27.0);\n\n\tQ3 = Q * Q * Q;\n\n\tR2 = RR * RR;\n\n\td = Q3 - R2;\n\n\tan = a1 * (1./3.);\n\n\tif (d >= 0.0)\n\t{\n\t\t/* Three real roots. */ //but only use the first!\n\n\t\td = RR * inversesqrt(Q3);\n\n\t\ttheta = acos(d) * (1. / 3.0);\n\n\t\tsQ = -2.0 * sqrt(Q);\n\n\t\treturn sQ * cos(theta) - an;\n\t}\n\n\tsQ = pow(sqrt(R2 - Q3) + abs(RR), 1.0 / 3.0);\n\n\tDBL t = sQ + Q / sQ;\n\t\n\tt = RR < 0. ? t : -t;\n\treturn t - an;\n}\n\nvoid quartic_descartes(float c1, float c2, float c3, float c4, inout vec4 results)\n{\n\tDBL c12, z, p, q, q1, q2, r, d1, d2;\n\t\n\t/* Compute the cubic resolvant */\n\n\tc12 = c1 * c1;\n\tp =  -6. * c12 + 4.*c2;\n\tq =  c12 * c1 - c1 * c2 + c3;\n\tq *= 8.;\n\tr = -3. * c12 * c12 + c12 *4.*c2 - c1 * 8.*c3 + 4.*c4;\n\t\t\t\t\n\tfloat cubic_a1 = -0.5 * p;\n\tfloat cubic_a2 = -r;\n\tfloat cubic_a3 = 0.5 * r * p - 0.125 * q * q;\n\n\tz = solve_cubic(cubic_a1, cubic_a2, cubic_a3);\n\n\td1 = 2.0 * z - p;\n\n\tif (d1 < 0.0)\n\t{\n\t\tif (d1 > -SMALL_ENOUGH)\n\t\t{\n\t\t\td1 = 0.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (d1 < SMALL_ENOUGH)\n\t{\n\t\td2 = z * z - r;\n\n\t\tif (d2 < 0.0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\td1 = sqrt(d1);\n\t\td2 = 0.5 * q * (1./ d1);\n\t}\n\n\t/* Set up useful values for the quadratic factors */\n\n\tq1 = d1 * d1;\n\tq2 = -c1;\n\n\t/* Solve the first quadratic */\n\n\tp = q1 - 4.0 * (z - d2);\n\n\tif (p > 0.)\n\t{\n\t\tp = sqrt(p);\n\t\tresults[0] = -0.5 * (d1 + p) + q2;\n\t\tresults[1] = -0.5 * (d1 - p) + q2;\n\t}\n\n\t/* Solve the second quadratic */\n\n\tp = q1 - 4.0 * (z + d2);\n\n\tif (p > 0.)\n\t{\n\t\tp = sqrt(p);\n\t\tresults[2] = 0.5 * (d1 + p) + q2;\n\t\tresults[3] = 0.5 * (d1 - p) + q2;\n\t}\n}\n\n\n//iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z ); //*2.-1.;\n}\n\nvec2 noise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = texture( iChannel1, (uv+ 0.5)/256.0, -100.0 ).yxwz;\n\treturn mix( rg.xz, rg.yw, f.z ); //*2.-1.;\n}\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdSGWy","date":"1392719466","viewed":1880,"name":"Purple Haze","username":"Antonalog","description":"Purple haze! All in my torus. Lately rays don't just trace one surface.  Unstable root solver, don't know why. Scuse me while I rip POVray.  Dow dow dow, widdly widdly squee!","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","torus","multifractal"],"hasliked":0,"parentid":"","parentname":""}}