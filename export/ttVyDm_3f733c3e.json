{"ver":"0.1","info":{"id":"ttVyDm","date":"1611176578","viewed":106,"name":"Gravity contours","username":"EatThePath","description":"log distance scale, equidistant(in view space) bands marking the falloff of net gravitational acceleration. Centered on earth, includes earth, sol, luna, and jupiter. Top to bottom of screen is about 12 AU.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["visualization"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //credit to https://shadertoyunofficial.wordpress.com/\n    //sets U to the normalized screen coordinates of the fragment\n    //with the shortest side of the display being [-1,1]\n    vec2 R = iResolution.xy,\n       U = ( 2.*fragCoord - R ) / min(R.x,R.y);\n    \n    //Get the force vector at this place and time, then the size of it\n    vec2 tforce = spin(U,iTime);\n    float val = length(tforce);\n\n    \n    //Map our rings to ever smaller rings of diminishing force because the inverse square law makes life difficult\n    val = 1.0/pow(val,1.0/10.0); //with the world mapped to a log scale this should make rings equidistant\n    \n    //We're going to animate things a bit, make the rings move\n    float t=iTime*0.25;\n    \n    val = val + 1.0-(t-float(int(t)));\n    val = val - abs(float(int(val)));\n    \n \n    //make it fuzzy\n    float crank = 5.0;\n    val=(sin(val*2.0*3.1415)*crank)-(crank-1.0);\n    val=clamp(val,0.0,1.0);\n    //val = 1.0-val;\n\tfragColor = vec4(val,val,val,0.0);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float gravForce(float m,float l){\n    float g = 0.000000000066743;\n    float f = -1.0*(g*m)/(l*l);\n    return f;\n}\nfloat gravForce(float m,float l,float c){\n    float f = gravForce(m,l);\n    clamp(f,-c,c);\n    return f;\n}\n\nvoid orbit(in float iTime, in float period, in float phase, out vec2 dir){\n    float offset = phase*period;\n    dir = vec2(cos(iTime/period+offset),(sin(iTime/period+offset)));\n    dir = dir/length(dir);\n\n}\n\nvec2 spin(in vec2 uv, in float iTime ){\n    vec2 a = vec2(0.0,0.0);\n    vec2 b;\n    float year = 10.0;\n    \n    orbit(iTime, year,0.0,b);\n    //lets center us on earth okay?\n    //earth\n    float ma = 5972000000000000000000000.00;//earth mass\n    float ra = 0.0; //dist from earth to earth\n    a=a*ra;\n    //sol\n    float mb = 1988500000000000000000000000000.00; //sol mass\n    float rb = 149600000000.0; //Dist from earth to sol\n    b=b*rb;\n    //luna\n    vec2 c;\n    orbit(iTime, year/2.0,0.0,c);\n    float mc = 73420000000000000000000.00;\n    float rc = 384399000.00;\n    c=c*rc;\n    //jupiter\n    vec2 d;\n    orbit(iTime, year*11.895,0.0,d);\n    float md = ma*317.8;\n    float rd = 5.204*rb;\n    d=d*rd;\n    d=d+b;//jupiter's vector is relative to sol, not to earth. Fix that.\n    \n    \n    float scale = rd+rb;//1 scale unit = 1 au, explode out the screen coords before we do further math to them.\n    uv *= pow(length(uv),10.0);\n    uv=uv*scale;\n    \n    float adist = length(uv-a);\n    float bdist = length(uv-b);\n    float cdist = length(uv-c);\n    float ddist = length(uv-d);\n    \n    vec2 adir = normalize(uv-a);\n    vec2 bdir = normalize(uv-b);\n    vec2 cdir = normalize(uv-c);\n    vec2 ddir = normalize(uv-c);\n    \n    vec2 aforce = gravForce(ma,adist)*adir;\n    vec2 bforce = gravForce(mb,bdist)*bdir;\n    vec2 cforce = gravForce(mc,cdist)*cdir;\n    vec2 dforce = gravForce(md,ddist)*ddir;\n\n    \n    vec2 tforce = aforce+bforce+cforce+dforce;\n    //return aforce;\n    return tforce;\n}\n\n","name":"Common","description":"","type":"common"}]}