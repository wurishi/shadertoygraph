{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage(out vec4 O, in vec2 fc)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    col = texture(iChannel0, uv).xyz;\n    vec2 cv = (fc-0.5*R.xy)/R.y;\n    col = mix(col, col*col*0.5, 0.7*smoothstep(0.6, 1.3, length(cv)));\n    col = mix(col, col*vec3(0.8, 0.8, 1.), 0.21);\n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime+6.845)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, OB, id_) if (id_ != skip && var < dist) { id = id_; o = OB, dist = var; }\n#define AMBIENT 0.04\nfloat luma(in vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Object { vec3 p; vec3 r; };\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\nstruct Material { float rough; float spec; float metallic; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\nstruct Data { vec3 p; vec3 n; float d; int id; int skip; Material m; Object o; };\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, 0, 0, NEW_MATERIAL, NEW_OBJECT)\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\nvec3 getLightDir(in Light light, in vec3 p) { return light.type == LIGHT_AMBIENT ? normalize(light.p) : light.type == LIGHT_POINT ? normalize(light.p - p) : normalize(light.d);}\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(distance(\n            light.p, p), 2.0))); break;\n        case LIGHT_DIR: return light.c * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    return vec3(0.0);\n}\nvec2 boxUv(in vec3 p, in vec3 n) { return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0)))); }\n\nvec3 fixNormal(vec3 wn, vec3 n, float th, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(th, dot(wn, n))));\n}\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sclamp(float v, float mi, float ma, float k) {\n    return smax(mi, smin(ma, v, k), k);\n}\n\nfloat sabs(float a, float k) {\n    return smax(-a, a, k);\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":3,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 84\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_POOL 2\n#define ID_WATER 3\n#define ID_RING 4\n#define ID_STAIR 5\n#define ID_RAIL 6\n#define ID_TRAMP 7\n\n#define FREE_MOVE 0\n\n#define POOL_RATIO (16.0/10.0)\n#define POOL_W 4.\n#define POOL_W_IN 3.0\n#define POOL_SIZE vec3(POOL_W, 2., POOL_W*POOL_RATIO)\n#define POOL_SIZE_IN vec3(POOL_W_IN, 2., POOL_W_IN*POOL_RATIO)\n\nfloat rand(in vec2 p, in float seed) {\n    vec2 p2 = fract(p*10.9281821391)*2.2938185-0.928821231;\n    float r1 = fract(dot(p, p2));\n    return fract(cos((r1+seed)*6.22828281823) * dot(p-(p2*seed), vec2(16.2939281, 19.982717145)));\n}\n\nvec3 noise(in vec2 p, in float seed) {\n    return textureLod(iChannel3, (p+((seed*2.0-1.0)*1.9981898593))/256., 0.0).xyz;\n}\n\nvec3 snoise(in vec2 p, in float seed) {\n    p += 0.092818723;\n    vec2 id = floor(p); vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(noise(id, seed), noise(id + vec2(1, 0), seed), lv.x),\n        mix(noise(id + vec2(0, 1), seed), noise(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise6(in vec2 p, in float seed, in float freq) {\n    p += 0.123456789;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 6; i++) {\n        n += amp * snoise(p*freq, seed*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    }  \n    return n/div;\n}\n\nvec3 noiseLod(in vec2 p, in float seed, in float lod) {\n    return textureLod(iChannel3, (p+((seed*2.0-1.0)*1.2981898593))/256., lod).xyz;\n}\n\nvec3 snoiseLod(in vec2 p, in float seed, in float lod) {\n    p += 0.999927271;\n    vec2 id = floor(p); vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(noiseLod(id, seed, lod), noiseLod(id + vec2(1, 0), seed, lod), lv.x),\n        mix(noiseLod(id + vec2(0, 1), seed, lod), noiseLod(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise6Lod(in vec2 p, in float seed, in float freq, in float lod) {\n    p += 0.902329128459;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 6; i++) {\n        n += amp * snoiseLod(p*freq, seed*freq, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }  \n    return n/div;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat poolSDF(in vec3 p) {\n    float base = boxSDF(p - vec3(0, -1., 0), POOL_SIZE * vec3(1, 0.5, 1));\n    float inside = boxSDF(p - vec3(0, -0.9, 0), POOL_SIZE_IN * vec3(0.9, 0.5, 0.9));\n\n    base = max(base, -inside);\n    \n    return base;\n}\n\nfloat groundSDF(in vec3 p) {\n    float d = p.y;\n    \n    float pool = boxSDF(p, POOL_SIZE);\n    \n    d = max(d, -pool);\n    \n    return d;\n}\n\nfloat waterSDF(in vec3 p) {\n    if (p.y > 10.) return p.y;\n    vec3 size = POOL_SIZE + vec3(0.002, 0., 0.002);\n    \n    float time = T*0.1;\n    vec2 shift = vec2(cos(time), sin(time));\n    \n    vec3 lf1 = snoise6Lod(p.xz + shift, 0.9281835, 0.9, 1.);\n    \n    shift += (lf1.x + lf1.y + lf1.z)/6.;\n    \n    vec3 lf2 = snoise6(p.xz - shift, 2.3928195, 0.6);\n    \n    shift += (lf2.x + lf2.y + lf2.z)/6.;\n    \n    vec3 mixer = snoise6Lod(p.xz + (shift*2.), 6.6938182, 0.5, 1.);\n    \n    shift -= (mixer.x+mixer.y+mixer.z)/6.;\n    \n    vec3 lf3 = snoise6Lod(p.xz - (shift*2.), 10.3929815, 0.4, 2.5);\n    \n    shift -= (lf3.x+lf3.y+lf3.z)/6.;\n    \n    vec3 lf4 = snoise6Lod(p.zx - (shift+vec2(sin(time), cos(time))), 20.98717156, 0.9, 2.);\n    \n    float nlf1 = mix(lf1.x, lf2.x, mixer.x);\n    float nlf2 = mix(lf1.y, lf2.y, mixer.y);\n    float nlf3 = mix(lf1.z, lf2.z, mixer.z);\n    float nlf4 = mix(mix(lf3.x, lf3.y, mixer.x), lf3.z, mixer.y);\n    \n    float h = -0.5;\n    \n    vec3 pp = abs(p);\n    float f = (1.0-smoothstep(0.0, 1.7, max(0.0, abs(p.z)-(size.z-0.01)))) * \n        (1.0-smoothstep(0.0, 1.7, max(0.0, abs(p.x)-(size.x-0.01))));;\n        \n    float w = 0.0;\n    \n    w += (nlf1*2.0-1.0);\n    w += (nlf2*2.0-1.0);\n    w += (nlf3*2.0-1.0);\n    w *= nlf4;\n    w += (lf4.x*2.0-1.0)*mixer.z;\n    \n    h -= w * 0.2 * clamp(f, 0.0, 1.0);\n    \n    p.y -= h;\n    p = abs(p) - vec3(size.x, 0.1, size.z);\n    float d = length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.);\n    \n    return d;\n}\n\nfloat stairSDF(in vec3 p, inout int id) {\n    id = ID_STAIR;\n    vec3 poolSize = POOL_SIZE;\n    float railHeight = 2.;\n    float railR = 0.05;\n    float width = 0.65;\n    float rail = cylSDF(vec3(abs(p.x), p.y, p.z) - vec3(width, 0., poolSize.z-1.5), vec3(0), vec3(0, railHeight, 0), railR)-0.02;\n    \n    \n    float stairHeight = 0.05;\n    float stairDim = 0.2;\n    \n        float trampLength = 1.3;\n    float tramp = boxSDF(p - vec3(0, railHeight-0.45, poolSize.z-(1.5+(trampLength))), vec3(width, stairHeight, trampLength))-0.01;\n    \n    float py = p.y;\n    p.y = mod(p.y, 0.5);\n    float stair = py > railHeight ? FAR: boxSDF(p - vec3(0, stairHeight, poolSize.z-1.5), vec3(width, stairHeight, stairDim))-0.03;\n    \n\n    float d = FAR;\n    if (rail < d) { d = rail; id = ID_RAIL; }\n    if (stair < d) { d = stair; id = ID_STAIR; }\n    if (tramp < d) { d = tramp; id = ID_TRAMP; }\n    \n    return d/1.2;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    float pool = poolSDF(p);\n\n    Object oRing = Object(vec3(sin((T*0.5)+(cos((T*0.33)-2.29191825)))*0.1, -(0.35 + 0.11*(0.5+(0.5*sin(T*1.2)))), cos(((T*0.5)-(sin((T*0.33)+3.92919825))))*0.1), vec3(0.));\n    float ring = torusSDF(p - oRing.p, 0.5, 0.2);\n    \n    int stairId = 0;\n    float stair = stairSDF(p, stairId);\n\n    SAMPLE(ground, o, ID_GROUND);\n    SAMPLE(pool, o, ID_POOL);\n    \n    \n    SAMPLE(ring, oRing, ID_RING);\n    SAMPLE(stair, o, stairId);\n\n    \n    data.id = id;\n    data.d = dist;\n    data.o = o;   \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        float next = sdf(data, ro+rd*d); d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break; if (abs(d) >= FAR) return false;\n    }\n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    data.p = p;\n    data.n = n;\n    data.d = d;\n    return true;\n}\n\nbool marchWater(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < 64; i++) {\n        vec3 p = ro+rd*d;\n        float next = waterSDF(p); d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break; if (abs(d) >= 20. || p.y > 30.) return false;\n    }\n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(waterSDF(p) - vec3(\n        waterSDF(p - e.xyy),\n        waterSDF(p - e.yxy),\n        waterSDF(p - e.yyx)\n    ));\n    data.id = ID_WATER;\n    data.p = p;\n    data.n = n;\n    data.d = d;\n    return true;\n}\n\nfloat getShadow(in int skip, in vec3 ro, in vec3 rd, in float near, in float far) {\n    float d = 0.0;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    for (int i = ZERO; i < STEPS; i++) {\n        float next = sdf(data, ro+rd*d); d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break; if (abs(d) >= far) return 1.0;\n    }\n    return clamp(pow(d/(1.0+d), 2.), AMBIENT, 1.0);\n}\n\nvec3 woodTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise6(uv, 2.3339281, 60.);\n    vec3 lf1 = snoise6(uv, 0.9288737, 20.);\n    float grain = textureLod(iChannel2, uv/2., 0.0).r;\n    \n    vec3 w1 = rgb(133, 107, 82);\n    vec3 w2 = rgb(143, 110, 78);\n    vec3 w3 = rgb(99, 58, 36);\n    vec3 w4 = rgb(171, 102, 61);\n    \n    vec3 woodCol = mix(mix(mix(w1, w2, hf1.x), w3, hf1.y), w4, hf1.z);\n    col += woodCol;\n    \n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    vec2 lvs = lv*lv*(3.0-2.0*lv);\n    vec2 lvc = lv*2.0-1.0;\n    vec2 alv = abs(lvc);\n    \n    const float seed = 3.3928195;\n    float idr = mix(mix(rand(id, seed), rand(id+vec2(1, 0), seed), lvs.x),\n                mix(rand(id+vec2(0, 1), seed), rand(id+vec2(1, 1), seed), lvs.x), lvs.y);\n    \n    \n\n    \n    float ra = max(0.0, 0.4 + 0.2*((0.5-idr)*0.5));\n    float fe = ra*(0.9*mix(1.0, 0.5, idr*idr*idr*0.7));\n    lvc += vec2(cos(idr*6.), sin(idr*6.))*0.5*idr;\n    col = mix(col, mix(col*col, col*idr, idr), smoothstep(0.6-0.3, 0.6+0.3, idr) * max(0.0, 1.0-smoothstep(ra-fe, ra+fe, length(lvc))));\n    \n    \n    \n    float s = pow(exp((cos((idr*idr*idr*(9.21223*(0.5+length(lvc))))*(lvc.x-((0.1+(idr*2.))*\n        sin((lvc.y-sin(lvc.x*M_PI*(0.5+(idr))))*M_PI)))*TAU)) - 1.), 3.0);\n    \n    col = mix(col, mix(w3, w4, hf1.x*lf1.z)*col, clamp(s*lf1.x*hf1.z*2., 0.0, 1.0));\n    col = mix(col, col*col, grain*grain);\n    \n    m.spec = clamp((s*s*grain), grain*lf1.x, 1.0);\n    return col;\n}\n//#define DEBUG_TEXTURE mosaicTexture\nvec3 mosaicTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    float tile = 4.0;\n    \n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n     \n    float r1 = rand(id, 24.291982315);\n    float r2 = rand(id, 7.2781823923);\n    float r3 = rand(id, 8.2223929186);\n    float r4 = rand(id, 14.444291842);\n    \n    vec3 hf1 = snoise6(uv, 3.32898123, 32.);\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    vec3 c1 = rgb(143, 181, 195);\n    vec3 c2 = rgb(114, 162, 172);\n    vec3 c3 = rgb(71, 121, 180);\n    vec3 c4 = rgb(13, 116, 175);\n    \n    vec3 tileCol = mix(mix(mix(c1, c2, r1), c3, r2), c4, r3);\n    col += tileCol;\n    \n    vec3 s1 = rgb(86, 81, 49);\n    vec3 s2 = rgb(175, 173, 149);\n    vec3 s3 = rgb(82, 94, 82);\n    vec3 s4 = rgb(190, 192, 170);\n    vec3 sepCol = mix(mix(mix(s1, s2, grain.x), s3, grain.y), s4, grain.z);\n    \n    float g = clamp(max(0.0, round(max(alv.x, alv.y)-0.44)), 0.0, 1.0);\n    float thick = 0.5 + (hf1.x*0.01);\n    float sg = max(0.0, 1.0-smoothstep(1., 1.0-thick, max(alv.x + ((hf1.x*2.0-1.0)*0.1), alv.y + ((hf1.y*2.0-1.0)*0.1))));\n    col = mix(col, sepCol, sg*clamp((hf1.x+grain.z)/1.6, 0.0, 1.0));\n    col = mix(col, col*col, g*hf1.z);\n    col = mix(col, s4, g*hf1.y*hf1.x);\n    \n    col = mix(col, col*((grain.x+grain.y+grain.z)/3.), hf1.z*r4*0.6);\n    \n    m.spec = clamp(sg*grain.y*hf1.z, grain.x*0.2, 1.0);\n    m.spec = clamp(m.spec + (pow(clamp(0.3 / pow(length(alv), 2.), 0.0, 1.0), 1.5)*0.5*grain.z*r3*r4), 0.0, 1.0);\n    //1.0-smoothstep(0.2-0.4, 0.2+0.4, pow(length(alv), 2.));\n    \n    return col;\n}\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    //uv *= 10.;\n    \n    vec3 hf1 = snoise(uv*200., 0.28827815);\n    vec3 hf2 = snoise6(uv, 3.33387762113, 64.);\n    vec3 hf3 = snoise6Lod(uv, 10.111182838, 100.0, 2.5);\n    \n    vec3 lf1 = snoise6Lod(uv, 6.6837177739, 4., 1.5);\n    vec3 lf2 = snoise6(uv, 16.39288883989, 3.);\n    vec3 lf3 = snoise6Lod(uv*0.5, 0.002988152, 0.5, 3.);\n    \n    vec3 g1 = rgb(97, 123, 27);\n    vec3 g2 = rgb(105, 109, 72);\n    vec3 g3 = rgb(50, 55, 34);\n    vec3 g4 = rgb(110, 121, 83);\n    \n    vec3 grassCol = mix(mix(mix(g1, g2, hf1.x), g3, hf1.y), g4, hf1.z);\n    col += grassCol;\n    \n    vec3 d1 = rgb(76, 62, 49);\n    vec3 d2 = rgb(127, 102, 82);\n    vec3 d3 = rgb(120, 101, 94);\n    vec3 d4 = rgb(156, 129, 97);\n    \n    vec3 dirtCol = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n    dirtCol = mix(dirtCol, dirtCol*dirtCol, clamp(lf2.y*2., 0.0, 1.0));\n    \n    float dirtReg = pow(lf1.x, 2.);\n    dirtReg = clamp(smoothstep(0.16, 0.6, dirtReg)*2., 0.0, 1.0);\n    dirtReg *= clamp(pow(lf2.x, 6.)*3., 0.0, 1.0);\n    \n    col = mix(col, dirtCol, dirtReg);\n    float grain = clamp(smoothstep(0.39, 1., hf3.x)*4., 0.0, 1.0);\n    \n    float wetReg = clamp(smoothstep(0.34, 1., lf3.x)*4., 0.0, 1.0)*lf1.z;\n    \n    \n    col = mix(col, col*col, grain);\n    col = mix(col, col*col, wetReg);\n    \n    m.spec = clamp(((dirtReg*dirtReg) + (wetReg*0.2*wetReg)), grain*0.2, 1.0);\n    \n    return col;\n}\n\nvec3 metalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    vec3 hf1 = snoise6(uv, 3.3333333129, 86.);\n    vec3 hf2 = abs(normalize(reflect(mix(grain, hf1, 0.8), hf1)));\n    vec3 lf1 = snoise6(uv, 2.2232921856, 9.);\n    vec3 lf2 = abs(normalize(cross(reflect(lf1, hf2), hf1)));\n    vec3 lf3 = snoise6(uv, 14.4982872125, 10.);\n    \n    vec3 m1 = rgb(171, 164, 148);\n    vec3 m2 = rgb(167, 156, 148);\n    vec3 m3 = rgb(172, 163, 165);\n    vec3 m4 = rgb(83, 82, 88);\n    \n    vec3 metalColor = mix(mix(mix(m1, m2, lf1.x), m3, lf1.y), m4, lf1.z);\n    metalColor = mix(metalColor, mix(m3, m4, hf2.y), hf2.x*0.5);\n    col += metalColor;\n    \n    vec3 r1 = rgb(162, 122, 101);\n    vec3 r2 = rgb(158, 88, 71);\n    vec3 r3 = rgb(100, 58, 61);\n    vec3 r4 = rgb(170, 115, 38);\n    \n    vec3 rustCol = mix(mix(mix(r1, r2, grain.x), r3, grain.y), r4, grain.z);\n    rustCol = mix(rustCol, rustCol*rustCol, lf2.x*lf1.z);\n    \n    float rustReg = smoothstep(0.5, 1.0, lf3.x+(grain.x*0.05));\n    \n    rustReg = clamp(rustReg, 0.0, 1.0);\n    \n    col = mix(col, rustCol*rustCol, rustReg);\n    \n    m.spec = clamp(max(0.0, 1.0 - rustReg), 0.0, lf3.x);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE plasticTexture\n\nvec3 plasticTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(128, 167, 198);\n    vec3 c2 = rgb(26, 131, 171);\n    vec3 c3 = rgb(174, 185, 167);\n    vec3 c4 = rgb(173, 179, 147);\n    \n    vec3 hf1 = snoise6(uv, 2.29919292, 64.);\n    vec3 hf2 = snoise6(uv, 0.09989812, 16.);\n    \n    vec3 plaCol = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    vec3 grain = textureLod(iChannel3, hf1.xy*0.1+hf1.z*0.1, 0.0).xyz;\n    \n    vec3 plaCol2 = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    \n    col = mix(plaCol, plaCol2, clamp(hf2.z*2.*hf2.y, 0.0, 1.0));\n    \n    m.spec = clamp(grain.y*hf1.x, hf2.y*hf2.y, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = grassTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoPool(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = mosaicTexture(uv, p, data.m);\n    \n    float e = 0.022;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(mosaicTexture(uv + vec2(e, 0), p, data.m)),\n        luma(mosaicTexture(uv + vec2(0, e), p, data.m)),\n        0.6\n    )), 0.1, 0.9);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoWater(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    return vec3(0.01, 0.09, 0.06)*0.1;\n}\n\nvec3 getAlbedoRing(inout Data data) {\n    vec3 p = data.p - data.o.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = snoise6(uv, 1.2928155, 3.0);\n    return col;\n}\n\nvec3 getAlbedoStair(inout Data data) {\n    vec3 p = data.p - data.o.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = woodTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoRail(inout Data data) {\n    vec3 p = data.p - data.o.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = metalTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoTramp(inout Data data) {\n    vec3 p = data.p - data.o.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = plasticTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_POOL: return getAlbedoPool(data); break;\n        case ID_WATER: return getAlbedoWater(data); break;\n        case ID_RING: return getAlbedoRing(data); break;\n        case ID_STAIR: return getAlbedoStair(data); break;\n        case ID_RAIL: return getAlbedoRail(data); break;\n        case ID_TRAMP: return getAlbedoTramp(data); break;\n    }\n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n  vec3 col = vec3(0.0);\n  vec2 uv = rd.xz / rd.y;\n  vec3 blue = vec3(0.3, 0.56, 0.8);\n  \n  float dotup = cdot(rd, vec3(0, 1, 0));\n\n  col = pow(blue, vec3(1.0 + (dotup * 2.)));\n    \n  if (dotup <= 0.0) return col;\n\n  float time = T * 0.2;\n\n  vec2 shift = vec2(cos(time), sin(time));\n  uv += sin(shift * 6.) * 0.01;\n\n  vec3 lf1 = snoise6(uv + shift, 0.03291895, 0.9);\n  vec3 hf1 = snoise6(uv - (shift * 0.2), 1.2321956,\n                    16.0 + mix(0.0, 1., pow(lf1.z, 2.0)));\n  vec3 mixer = snoise6(uv + sin(shift), 0.11111223, 0.9);\n\n  float mixf = mix(mixer.x, mixer.y, 0.5 + (0.5 * sin(time)));\n\n  float low = mix(lf1.x, lf1.y, 0.5 + (0.5 * cos(time)));\n  float high = mix(hf1.x, hf1.y, 0.5 + (0.5 * sin(time)));\n\n  vec3 lfi = snoise6(uv + shift, 0.53928111, 1.0);\n  float inv = pow(mix(lfi.x, lfi.y, 0.5 + (0.5 * cos(time))), 2.0);\n\n  float clouds = mix(low, high, mixf);\n\n  clouds = mix(clouds, 0.0, inv);\n  clouds = pow(clouds, 3.0);\n  \n  clouds *= clamp(dotup*40., 0.0, 1.0);\n\n  col = mix(col + clouds, mix(col, vec3(1.0), clouds),\n            0.5 + (0.5 * cos(time + low + high + inv)));\n\n  return col;\n}\n\nvec3 lightEffect(in vec3 ro, in vec3 rd, in Light light) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    \n    col += light.c * light.s * pow(VdotL, 16.);\n    \n    return col;\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 diffuse, in vec3 ro, in vec3 rd) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.);\n    vec3 att = getLightAtt(light, p, n);\n    int skip = data.id == ID_POOL ? -1 : data.id;\n    float shadow = getShadow(skip, p+(n*NEAR*2.), L, data.d, light.type == LIGHT_AMBIENT ? FAR : distance(light.p, p));\n    \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    //Light lights[NUM_LIGHTS];\n    Light light = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.97, 0.59), 2.0, LIGHT_AMBIENT);\n    \n    bool hit = false;\n    \n    vec3 primRo = ro;\n    vec3 primRd = rd;\n    float primDist = FAR;\n    \n    if (march(data, ro, rd)) {\n        hit = true;\n        primDist = data.d;\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        \n        for (int i = 0; i < NUM_LIGHTS; i++) {\n          //  Light light = lights[i];\n            col += forEachLight(data, light, diffuse, ro, rd);\n        }\n    }\n    \n    Data waterData = NEW_DATA;\n    float waterDist = FAR;\n    vec3 mixF = vec3(1.0);\n    vec3 waterP = vec3(0.0);\n    vec3 waterN = vec3(0.0);\n    bool hitWater = false;\n    for (int j = 0; j < 2; j++) {\n        bool nextHit = j <= 0 ? marchWater(waterData, ro, rd) : march(waterData, ro, rd);\n        if (nextHit) {\n            if (j <= 0) {\n                if (!(waterData.d < data.d)) break;\n                waterDist = waterData.d;\n                waterP = waterData.p;\n                waterN = waterData.n;\n                col /= 1.6;\n            }\n            \n            float diff = abs(waterDist - data.d);\n            col *= max(0.0, 1.0 - smoothstep(0.0, 3.0, diff));\n            \n            vec3 albedo = getAlbedo(waterData);\n            vec3 diffuse = albedo / M_PI;\n\n           // Light light = lights[0];\n            \n            col += forEachLight(waterData, light, diffuse, ro, rd) * mixF;\n            \n            \n            vec3 n = waterData.n;\n            vec3 p = waterData.p;\n            rd = reflect(rd, n);\n            ro = p+(n*NEAR*2.);\n            \n            \n            float NdotV = dot(n, rd);\n            vec3 f0 = vec3(0.04);\n            float rough = 0.1;\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n            \n            mixF = clamp(F, 0.0000001, 1.0);\n            \n            hit = true;\n            hitWater = true;\n        } else {\n            col += getSky(ro, rd) * float(j > 0) * mixF * vec3(0.7, 0.9, 0.79);\n            break;\n        }\n    }\n    \n    if (hitWater) {\n        Data refData = NEW_DATA;\n        vec3 ro = waterData.p + (waterData.n*NEAR*2.);\n        vec3 rd = refract(primRd, waterData.n, 1.0 /  1.33);\n        if (march(refData, ro, rd)) {\n            vec3 albedo = getAlbedo(refData);\n            vec3 diffuse = albedo / M_PI;\n            vec3 refCol = forEachLight(refData, light, diffuse, ro, rd);\n            col = mix(col, (col + refCol) / 2., clamp((luma(refCol) + length(refCol))*M_PI, 0.0, 1.0));\n        }\n    }\n    \n    if (!hit) { col += getSky(primRo, primRd);}\n  \n    col += lightEffect(primRo, primRd, light);\n    \n    depth = primDist / FAR;\n    \n    col += smoothstep(0.1, 1.0, depth) * max(0.0, 1.0 - smoothstep(0.0, 0.3, dotup)) * 0.16;\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -8.);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if FREE_MOVE\n    m.z = 1.;\n    #endif\n    \n    if (length(m.xy) > 0.001 && m.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        ro = vec3(cos(T*0.5)*6., 2., sin(T*0.5)*6.);\n        rd = look(uv, vec3(0.0), ro);\n        \n    }\n    \n    ro.y += 0.5;\n    ro.y = max(0.5, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    depth = 0.;\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col += (col*col*luma(col));\n    col /= 1.0 + max(col-0.5, 0.0);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(clamp(col, 0.0, 1.0), depth);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\nvoid edgeKernel(inout vec4 n[9], sampler2D tex, vec2 coord, float width, float height)\n{\n  float w = 1.0/width;\n  float h = 1.0/height;\n\n  n[0] = texture(tex, coord + vec2( -w, -h));\n  n[1] = texture(tex, coord + vec2(0.0, -h));\n  n[2] = texture(tex, coord + vec2(  w, -h));\n  n[3] = texture(tex, coord + vec2( -w, 0.0));\n  n[4] = texture(tex, coord);\n  n[5] = texture(tex, coord + vec2(  w, 0.0));\n  n[6] = texture(tex, coord + vec2( -w, h));\n  n[7] = texture(tex, coord + vec2(0.0, h));\n  n[8] = texture(tex, coord + vec2(  w, h));\n}\n\nfloat edgeDetect(sampler2D tex, vec2 coord) {\n\n  vec2 texSize = vec2(textureSize(tex, 0).xy);\n\n  vec4 n[9];\n  edgeKernel(n, tex, coord, texSize.x, texSize.y);\n\n  vec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n\n  return max(max(sobel.r, sobel.g), sobel.b);\n}\n\nvec3 getAvg(vec2 uv, float f) {\n    vec2 e = (1.0 + f) / R.xy;\n    \n    vec3 center = getColor(uv);\n    vec3 left = getColor(uv + vec2(-e.x, 0));\n    vec3 right = getColor(uv + vec2(e.x, 0));\n    vec3 up = getColor(uv + vec2(0, e.y));\n    vec3 down = getColor(uv + vec2(0, -e.y));\n    \n    return (center + left + right + up + down) / 5.;\n}\n\nvec3 blurx(vec2 uv, float f) {\n  vec3 col = vec3(0.0);\n  const int filterSize = 8;\n  const int halfFilterSize = filterSize / 2;\n\n  const int start = -halfFilterSize;\n  const int end = -halfFilterSize + filterSize;\n\n  float shadow = 0.0;\n  vec2 texelSize = clamp(1.0+f, 1.0, 8.0) / vec2(R.xy);//vec2(textureSize(iChannel0, 0).xy);\n  int count = 0;\n  for(int x = start; x < end; ++x)\n  {\n      for(int y = start; y <= end; ++y)\n      {\n         vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n         col += next;\n         count += 1;\n      }\n  }\n\n  col /= float(count);\n  return col;\n}\n\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.9) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    float n = max(n1, max(n2, max(n3, max(n4, n5))));\n    n = smoothstep(0.01, 0.5, n);\n    return clamp(n * M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 old = clamp(texture(iChannel1, uv).rgb, 0.0, 1.0);\n    vec3 col = getColor(uv);\n    \n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    float edge = edgeDetect(iChannel0, uv);\n    \n    vec3 smo = blurx(uv, depth);\n    vec3 smo2 = getAvg(uv, 1.0);\n    col = mix(col, mix(smo2, smo, 0.5), 0.3*clamp(noiseEst*noiseEst, 0.0, 1.0));\n    col = mix(col, smo, smoothstep(0.0, 0.32, depth)*0.9);\n    \n    vec3 smo3 = textureLod(iChannel0, uv, 2.5).rgb;\n    edge = pow(clamp(edge, 0.0, 1.0), 6.);\n    col = mix(col, smo3, edge);\n    \n    col += (col*col*luma(col))*max(0.0, 1.0-(depth))*0.7;\n    \n    float ndiff = distance(col, old);\n    \n    col = mix(col, old, \n        clamp(((noiseEst*2.)+edge) * max(0.0, 1.0 - (clamp(iMouse.z, 0.0, 1.0)*0.8)), 0.0, 0.7) *\n        max(0.0, 1.0 - ndiff)\n    );\n    return clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n   //col =vec3(estimateNoise(getColor(uv), uv));\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"cdd3Df","date":"1677963689","viewed":210,"name":"Tiny Swimming pool","username":"ianertson","description":"Use the mouse to look around :)","likes":10,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","raymarching","raymarch","water","art","pool","swimmingpool"],"hasliked":0,"parentid":"","parentname":""}}