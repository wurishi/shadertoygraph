{"ver":"0.1","info":{"id":"ddtGWM","date":"1677445991","viewed":104,"name":"you are getting sleepy","username":"pb","description":"idk","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","wheel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tol = .2;\nvec3 ro;\n\n\nconst float an = .001;\nconst float cw = cos(an);\nconst float sw = sin(an);\n\n\nmat2 rot(float an) { float cc=cos(an),ss=sin(an); return mat2(cc,ss,-ss,cc); }\n\nfloat wheel(vec3 p) {\n    \n    \n    vec4 q = vec4(p , 11. );  \n    \n    \n    vec4 jc = q; \n    \n    float ww = 10.;\n    \n    \n    float i=0.;\n    float scale = 1.63;\n    \n    for (;i<6.;i++){\n        \n        if ( q.x > 1. )  q.x = 2. - q.x;\n        else if ( q.x < -1.) q.x = -2. - q.x;\n        \n        if ( q.y > 1. )  q.y = 2. - q.y;\n        else if ( q.y < -1.) q.y = -2. - q.y;\n        \n        if ( q.z > 1. )  q.z = 2. - q.z;\n        else if ( q.z < -1.) q.z = -2. - q.z;\n        \n        if ( q.w > 1. )  q.w = 2. - q.w;\n        else if ( q.w < -1.) q.w = -2. - q.w;\n        \n        float lz1 = length(q.xyz);\n        float lz2 = length(q.yzw);\n        float lzz1, lzz2;\n        \n        float tt=iTime/2.;\n        \n        if ( lz1 < .7 ) { q.xyz *= 4.; ww *= 4.; q.xy = rot( tt )*q.xy; }\n        else if ( lz1 < 1.5) { q.xyz = q.xyz/(lzz1=lz1*lz1); ww *= lzz1; q.xy = rot(-tt)*q.xy; }\n       \n        //if ( lz2 < 1.5 ) { q.yzw *= 4.; ww *= 4.; q.zw = rot(-iTime)*q.zw; }\n        //else if ( lz2 < 2.5) { q.yzw = q.yzw/(lzz2=lz2*lz2); ww *= lzz2; }   \n        \n        q = scale * q + jc/2.3;\n        \n        ww *= scale;\n    \n      \n    }\n    \n    return (length(q))/ ww;\n    \n\n}\n\n\n\nvec2 scene(vec3 p) {\n\n    \n    return vec2(  max( wheel(p), -(length(p-ro)-.3*(1.+.1*sin(iTime/20.)) ) ) ,  1.);\n}\n\n\nvec3 gradient(vec3 p) {\n\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = 1e-4 * dpn; \n\n    vec3 df = dpn.xxx * scene(p+dp.xxx).x +\n              dpn.yyx * scene(p+dp.yyx).x +\n              dpn.xyy * scene(p+dp.xyy).x +\n              dpn.yxy * scene(p+dp.yxy).x;\n\n    return normalize(df); \n\n}\n\n\nvec3 march( vec3 ro, vec3 rd) {\n\n    float dist = 1e6,  totDist=0.,  distFac=1.;\n    \n    vec3 p = ro;\n    \n    for (float i=0.; i<60.; i++) {\n    \n        dist = scene(p).x;\n \n        if  (  dist < tol * distFac )  { return exp(-totDist/2.)*vec3(dot(gradient(p),-rd)); }\n        \n        p += dist * rd;\n        \n        distFac *= (1.+totDist*60.);\n        \n        totDist += dist;\n        \n    }\n    \n    return vec3(0);\n}\n\n\n\nvoid mainImage0( out vec4 O, in vec2 U )\n{\n\n    U = (2.*U - iResolution.xy) / iResolution.y *2.;\n    \n    vec3 rd = normalize( vec3(U, 6.) );\n    \n    //rd.xz = rot(iTime/5.)*rd.xz;\n    \n    ro = vec3(0.,0.,-1.9);\n    \n    vec3 color = march( ro, rd );\n    \n    if ( length(U) > 2.2) color=vec3(0.);\n    \n    O = vec4( pow(color,vec3(.44)), 1);\n\n}\n\n\n//thanks Faabrice\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .001 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Image","description":"","type":"image"}]}