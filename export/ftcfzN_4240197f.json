{"ver":"0.1","info":{"id":"ftcfzN","date":"1662720838","viewed":69,"name":"Reflect ior learning","username":"wingto","description":"ref: https://www.shadertoy.com/view/wt2GDW","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["reflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vUV = fragCoord/iResolution.xy;\n    vec2 lens_uv = fragCoord * vUV.y;\n    \n    \n  //--------------object normal  \n    vec2 lens_delta =vec2(vUV-0.5);\n    float lens_dist = length(lens_delta);\n    //relative distance\n    \n    //Knobs to control the size and the \"zoom\" amount of the lens\n    float lens_radius = 0.95;\n    float lens_zoom = 1.0;\n    // pretend that the lens is spherical\n    // Fudge the z component for stylistic control\n    float lens_radius_fudge = 0.1;\n    vec3 lens_normal =\n      normalize(vec3(lens_delta.xy, lens_zoom * \n                     sqrt(lens_radius_fudge * lens_radius - lens_dist*lens_dist)\n                     ));\n\n\n\n\n\n\n    // the incoming light direction\n    vec3 incident = normalize(vec3(0.0, 0.0, -1.0));\n\n    // ior ratios of (medium A)/(medium B). \n    // medium A is outside the lens, medium B is inside the lens\n    // - Use an ior of 1.0, corresponding to air, for medium A\n    // - Use a slightly higher ior for medium B. Tune to taste!\n    // See \n    // - https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml\n    // - https://pixelandpoly.com/ior.html\n    float eta_r = 1.0 / 1.15;\n    float eta_y = 1.0 / 1.17;\n    float eta_g = 1.0 / 1.19;\n    float eta_c = 1.0 / 1.21;\n    float eta_b = 1.0 / 1.23;\n    float eta_v = 1.0 / 1.25;\n  \n  \n  \n    // Calculate different refraction vectors for each color channel\n  vec2 refract_r = refract(incident, lens_normal, eta_r).xy;\n  vec2 refract_y = refract(incident, lens_normal, eta_y).xy;\n  vec2 refract_g = refract(incident, lens_normal, eta_g).xy;\n  vec2 refract_c = refract(incident, lens_normal, eta_c).xy;\n  vec2 refract_b = refract(incident, lens_normal, eta_b).xy;\n  vec2 refract_v = refract(incident, lens_normal, eta_v).xy;\n\n  vec3 tex = texture(iChannel0, vUV).rgb;\n  vec3 tex_r = texture(iChannel0, refract_r + vUV).rgb;\n  vec3 tex_y = texture(iChannel0, refract_y + vUV).rgb;\n  vec3 tex_g = texture(iChannel0, refract_g + vUV).rgb;\n  vec3 tex_c = texture(iChannel0, refract_c + vUV).rgb;\n  vec3 tex_b = texture(iChannel0, refract_b + vUV).rgb;\n  vec3 tex_v = texture(iChannel0, refract_v + vUV).rgb;\n  \n//---------------------------------------------------------------------\n\n  float r = tex_r.r * 0.5;\n  float g = tex_g.g * 0.5;\n  float b = tex_b.b * 0.5;\n  float y = dot(vec3(2.0, 2.0, -1.0), tex_y)/6.0;\n  float c = dot(vec3(-1.0, 2.0, 2.0), tex_c)/6.0;\n  float v = dot(vec3(2.0, -1.0, 2.0), tex_v)/6.0;\n\n  float R = r + (2.0 * v + 2.0 * y - c)/3.0;\n  float G = g + (2.0 * y + 2.0 * c - v)/3.0;\n  float B = b + (2.0 * c + 2.0 * v - y)/3.0;\n\n\n\n\n//---------------------------------------------------------------------\n\n\n   // vec3 color = mix(tex, vec3(R, G, B), step(lens_dist, lens_radius));\n     vec3 color = vec3(R, G, B);\n     \n  float ring = smoothstep(\n      0.0,3.0 / iResolution.y,\n     0.5);\n  color *= ring;\n\n\n\n\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}