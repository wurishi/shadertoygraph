{"ver":"0.1","info":{"id":"dlyBRh","date":"1701850504","viewed":62,"name":"letters!!!!","username":"crimew","description":"I remember watching a video on youtube a long time ago and seeing someone do this on the cpu and it had performance issues. I looked at it and said \"this is dumb, I can do better, I just have to write my own text rendering software\". This took me all day.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["font","letter","letterdisplay","yeehaw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n// this was for when I still thought myself to be a decent programmer. ignore accordingly.\n//const float[94] LightnessValues = float[94](0.,0.23913043,0.19565217,0.7826087,0.69565217,0.82608696,0.84782609,0.06521739,0.34782609,0.34782609,0.36956522,0.2826087,0.06521739,0.10869565,0.06521739,0.2826087,0.65217391,0.30434783,0.54347826,0.58695652,0.60869565,0.58695652,0.65217391,0.41304348,0.7173913,0.65217391,0.10869565,0.15217391,0.30434783,0.30434783,0.30434783,0.39130435,1.,0.65217391,0.84782609,0.52173913,0.73913043,0.63043478,0.5,0.65217391,0.7173913,0.47826087,0.34782609,0.67391304,0.39130435,0.97826087,0.82608696,0.69565217,0.60869565,0.7826087,0.73913043,0.58695652,0.41304348,0.67391304,0.54347826,0.82608696,0.58695652,0.45652174,0.58695652,0.45652174,0.2826087,0.45652174,0.2826087,0.13043478,0.04347826,0.56521739,0.65217391,0.39130435,0.65217391,0.56521739,0.45652174,0.76086957,0.63043478,0.43478261,0.45652174,0.58695652,0.45652174,0.69565217,0.5,0.52173913,0.65217391,0.65217391,0.30434783,0.45652174,0.43478261,0.5,0.41304348,0.69565217,0.47826087,0.54347826,0.43478261,0.41304348,0.30434783,0.41304348);\n\n// idexes characters 33-126 by brightness\nconst int[94] LightnessSort = int[94](0,64,7,12,14,13,26,63,27,2,1,11,15,60,62,17,28,29,30,82,92,8,9,42,10,31,44,67,23,52,86,91,93,73,84,90,57,59,61,70,74,76,83,41,88,38,78,85,35,79,18,54,89,65,69,19,21,51,56,58,75,20,48,37,72,16,22,25,33,39,66,68,80,81,43,53,4,47,77,87,24,40,36,50,71,3,49,5,46,55,6,34,45,32);\n\n//lower number = smaller letter\nconst int LOD = 3; //The LOD from the mipmap to sample from buffer A\n\n\n// I stole this from anastadunbar because I can;t be bothered.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lowRes = texelFetch(iChannel0, ivec2(fragCoord*pow(2.0,-float(LOD))), LOD); // get the correct Buffer A mipmap\n    \n    float letter = float(LightnessSort[int(93.0*lowRes.w)]); // this is fucking jank as hell but I couldn't figure out how to sort stuff\n    \n    letter += 32.0; // offset because only characters 33-126 are used (ascii)\n\n    vec2 letterIndexPos = vec2(mod(letter,16.0),15.0-floor(letter/16.0)); // turn the 'letter' number into coords corresponding to font image\n    vec2 letterPos = 64.0*letterIndexPos/1024.0; // put coords in texture space\n    \n    float verticlepixelcount = iResolution.y*pow(2.0,-float(LOD)); // count of vertical pixels from the mipmap\n    \n    vec2 uv = verticlepixelcount*mod(fragCoord/iResolution.y,1.0/verticlepixelcount); // sets the uv for all the letters to use when rendering them\n    \n    fragColor = texture(iChannel1,uv/16.0+letterPos).r*vec4(hsv2rgb(vec3(lowRes.r,1.0,1.0)),0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this is arbitrary and I didn't add comments when I wrote it and I don't want to right now.\n//It's a very simple ray marching thing but with my own makeshift way of getting the vector's direction from the camera because I think I'm hot shit or something. It works poorly\n//you know how to use a search engine tho, you can look up how to make these things.\n\nprecision highp float;\n\nconst float TAU = 6.28318530718;\nconst float FOV = 1.57079632679;\nconst int MAX_RAY_STEP = 150;\nconst float MAX_RAY_HIT_DISTANCE = 0.0001;\nconst float NEAR_CLIP_DISTANCE = 0.5;\nconst float ROTATION_CONTROL_MODIFIER = 0.01;\n\n\nfloat DE(in vec3 p)\n{\n    vec3 q = mod(p+5.0,10.0)-5.0;\n    return length(q*vec3(1.0,1.0,1.0))-1.0;\n}\n\nvec3 cameraPosition = vec3(0.0,0.0,3.0);\nvec2 cameraAngles = vec2(0.0);\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    cameraPosition = vec3(55.0*cos(iTime/20.0),55.0*sin(iTime/20.0),55.0*sin(iTime/20.0));\n    cameraAngles = vec2(-iTime/20.0,0.0);\n\n    vec2 vectorAngles = mod(cameraAngles+FOV*(fragCoord-iResolution.xy/2.0)/iResolution.x,TAU);\n    vec3 vectorCoefficients = vec3(\n        cos(vectorAngles.y) * cos(vectorAngles.x),\n        cos(vectorAngles.y) * sin(vectorAngles.x),\n        sin(vectorAngles.y)\n    );\n    \n    int rayStep = 0;\n    float rayDistance = NEAR_CLIP_DISTANCE;\n    float rayDE = DE(cameraPosition+rayDistance*vectorCoefficients);\n    \n    while(rayStep < MAX_RAY_STEP && rayDE > MAX_RAY_HIT_DISTANCE )\n    {\n        rayDE = DE(cameraPosition+rayDistance*vectorCoefficients);\n        rayDistance += rayDE;\n        rayStep++;\n    }\n    \n    float AE = float(MAX_RAY_STEP-rayStep)/float(MAX_RAY_STEP);\n    \n    vec3 pos = (cameraPosition+rayDistance*vectorCoefficients)/10.0/TAU;\n    \n    vec3 rayNormal = -normalize(mod(cameraPosition+rayDistance*vectorCoefficients+5.0,10.0)-5.0);\n    float reflection = sign(AE)*dot(rayNormal, normalize(vec3(1.0,1.0,-1.0)));\n    \n    fragColor = vec4((atan(pos.x+3.0,pos.y)+TAU/2.0)/TAU,0.0,0.0,AE*(reflection/TAU+1.0));//vec4(fragCoord.x/iResolution.x);//\n}","name":"Buffer A","description":"","type":"buffer"}]}