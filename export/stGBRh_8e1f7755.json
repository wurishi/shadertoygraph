{"ver":"0.1","info":{"id":"stGBRh","date":"1665654560","viewed":184,"name":"kidach1 - Color blend with smin","username":"kidach1","description":"color blend","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_DIST 1000.\n#define SURF_DIST .001\n#define MAX_ITER 100\n#define PI 3.14159265\n\n\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdTorus(vec3 p, vec2 r)\n{\n    vec2 peri = vec2(length(p.xz)-r.x, p.y);\n    return length(peri)-r.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = exp(-k*a) + exp(-k*b);\n    return -log(h)/k;\n}\n\nstruct Obj\n{\n    float dist;\n    vec3 col;\n};\n\nObj blend(Obj o1, Obj o2)\n{\n    Obj o;\n    float k = 2.2;\n    o.dist = smin(o1.dist, o2.dist, k);\n    // この方式だと、Intersectで先に書いたObjectの色が有利（支配的になる）。\n    o.col = mix(o1.col, o2.col, clamp(o1.dist - o.dist, 0.0, 1.0));\n    return o;\n}\n\nObj Intersect(vec3 p)\n{\n    Obj o = Obj(9999.9, vec3(0));\n    \n    vec3 sp = p-vec3(0,-1.3,0);\n    sp.x += cos(iTime*2.2)*5.3;\n    sp.y += sin(iTime*2.8)*3.3;\n    vec3 scol = vec3(1.0, 0.7, 0.3);\n    float sd = sdSphere(sp, 3.0);\n    \n    vec3 bp = p-vec3(2,3,0);\n//    bp.y += sin(iTime*2.)*2.;\n    float bd = sdBox(bp, vec3(2.2));\n    float bd2 = sdSphere(bp, 2.2);\n    vec3 bcol = vec3(0.3, 1.0, 0.7);\n    bd = mix(bd, bd2, sin(iTime*3.)*.5+.5);\n\n    vec3 floorp = p-vec3(0,-2,0);\n    vec3 floorcol = vec3(.8);\n    float floord = sdBox(floorp, vec3(8, 0.8, 5));\n\n    vec3 tp = p-vec3(3,0,0);\n    tp.x += sin(iTime*.8)*7.;\n    tp.xy *= rot(iTime);\n    vec3 tcol = vec3(0.0, 0.3, 1.0);\n    float td = sdTorus(tp, vec2(3.2, .5));\n\n    \n    o = blend(o, Obj(sd, scol));\n    o = blend(o, Obj(bd, bcol));\n    o = blend(o, Obj(floord, floorcol));\n    o = blend(o, Obj(td, tcol));\n    \n    return o;\n}\n\n\nfloat GetDist(vec3 p)\n{\n    vec3 sp = p-vec3(0,-1.3,0);\n    sp.x += cos(iTime*2.2)*5.3;\n    sp.y += sin(iTime*2.8)*3.3;\n    float sd = sdSphere(sp, 3.5);\n    \n    vec3 bp = p-vec3(2,3,0);\n//    bp.y += sin(iTime*2.)*2.;\n    float bd = sdBox(bp, vec3(2.2));\n    float bd2 = sdSphere(bp, 2.2);\n    bd = mix(bd, bd2, sin(iTime*3.)*.5+.5);\n\n    vec3 floorp = p-vec3(0,-2,0);\n    float floord = sdBox(floorp, vec3(8, 0.8, 5));\n\n    vec3 tp = p-vec3(3,0,0);\n    tp.x += sin(iTime*.8)*7.;\n    tp.xy *= rot(iTime);\n    float td = sdTorus(tp, vec2(3.2, .5));\n    \n    float d = 1e+8;\n\n    float k = 1.7;\n    d = smin(d, sd, k);\n    d = smin(d, bd, k);\n    d = smin(d, td, k);\n    d = smin(d, floord, k);\n    \n    return d;\n}\n\nObj RayMarch(vec3 ro, vec3 rd)\n{\n    Obj o;\n    float depth = 0.0;\n\n    for (int i = 0 ; i < MAX_ITER; i++)\n    {\n        vec3 p = ro + rd * depth;\n//        float res = GetDist(p);\n        o = Intersect(p);\n        depth += o.dist;\n        if (o.dist < SURF_DIST || depth > MAX_DIST) break;        \n    }\n    return Obj(depth, o.col);\n}\n\nvec3 GetRayDir(vec3 ro, vec3 lookAt, vec2 uv, float z)\n{\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f, r);\n    \n    return normalize(f * z + r * uv.x + u * uv.y);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = Intersect(p).dist;\n    vec2 e = vec2(.01, 0);\n    return normalize(d - vec3(\n        Intersect(p-e.xyy).dist,\n        Intersect(p-e.yxy).dist,\n        Intersect(p-e.yyx).dist\n    ));\n}\n\nvec3 Render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool isLast)\n{\n    Obj o;\n    vec3 col = texture(iChannel0, rd).rgb;\n    ref = vec3(0);\n\n    o = RayMarch(ro, rd);\n    \n    if (o.dist < MAX_DIST)\n    {\n        vec3 p = ro + rd * o.dist;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 lightPos = vec3(3, 3, -6);\n        vec3 l = normalize(lightPos - p);\n        float nDotL = clamp(dot(n, l), 0., 1.);\n        vec3 diffuse = nDotL * o.col;\n        col = isLast ? texture(iChannel0, r).rgb : vec3(nDotL)*.1;\n\n        ref = o.col;\n        ro = p+n*SURF_DIST*3.;\n        rd = r;\n    }    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 5, -10);\n    vec2 m = iMouse.xy/iResolution.xy;\n    ro.xz *= rot(iTime*.2);\n//    ro.xz *= rot(-m.x*PI*2.);\n//    ro.yz *= rot(m.y*PI-1.);\n\n    vec3 rd = GetRayDir(ro, vec3(0), uv, 1.0);\n        \n    vec3\n        fil = vec3(1.),\n        ref = vec3(0);\n\n    vec3 col = Render(ro, rd, ref, false);\n        \n    const int BOUNCE_NUM = 2;\n    \n    for (int i = 0; i < BOUNCE_NUM; i++)\n    {\n        fil *= ref;\n        vec3 bounce = fil*Render(ro, rd, ref, BOUNCE_NUM-1==i);\n        col += bounce;\n    }\n\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}