{"ver":"0.1","info":{"id":"Mccczr","date":"1730157876","viewed":59,"name":"raymarching trial 1fe1","username":"Pangolecimal","description":"raymarching demo","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\niform   vec3      iResolution;           // viewport resolution (in pixels)\nuniform float     iTime;                 // shader playback time (in seconds)\nuniform float     iTimeDelta;            // render time (in seconds)\nuniform float     iFrameRate;            // shader frame rate\nuniform int       iFrame;                // shader playback frame\nuniform float     iChannelTime[4];       // channel playback time (in seconds)\nuniform vec3      iChannelResolution[4]; // channel resolution (in pixels)\nuniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\nuniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cube\nuniform vec4      iDate;                 // (year, month, day, time in seconds)\nuniform float     iSampleRate;           // sound sample rate (i.e., 44100)\n\nhttps://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n*/\n\n\n// 0: integer hash\n// 1: float hash (aliasing based)\n#define METHOD 0\n\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 0\n\n#if METHOD==0\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n#else\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n#endif\n\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x )\n{\n    #if METHOD==0\n    ivec3 i = ivec3(floor(x));\n    #else\n    vec3 i = floor(x);\n    #endif\n    vec3 w = fract(x);\n    \n    #if INTERPOLANT==1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n \n    #if METHOD==0\n    float a = hash(i+ivec3(0,0,0));\n    float b = hash(i+ivec3(1,0,0));\n    float c = hash(i+ivec3(0,1,0));\n    float d = hash(i+ivec3(1,1,0));\n    float e = hash(i+ivec3(0,0,1));\n\tfloat f = hash(i+ivec3(1,0,1));\n    float g = hash(i+ivec3(0,1,1));\n    float h = hash(i+ivec3(1,1,1));\n\t#else\n    float a = hash(i+vec3(0,0,0));\n    float b = hash(i+vec3(1,0,0));\n    float c = hash(i+vec3(0,1,0));\n    float d = hash(i+vec3(1,1,0));\n    float e = hash(i+vec3(0,0,1));\n\tfloat f = hash(i+vec3(1,0,1));\n    float g = hash(i+vec3(0,1,1));\n    float h = hash(i+vec3(1,1,1));\n    #endif\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}\n\n// -----------------------------------------------------------------------------------------------------------------------\n\n#define PI 3.141592653589\nconst int MAX_MARCHING_STEPS = 1024;\nconst float MIN_DEPTH = 0.0;\nconst float MAX_DEPTH = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 pow3(vec3 b, float p) {\n    return vec3(\n        pow(b.x, p),\n        pow(b.y, p),\n        pow(b.z, p)\n    );\n}\n\nfloat smin( float a, float b, float k ) {\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\nfloat smax( float a, float b, float k ) {\n    return -smin(-a, -b, k);\n}\n\nfloat sphere_sdf(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box_sdf(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene_sdf(vec3 p) {\n    float s2 = sphere_sdf(p - vec3(0, 2.5, 2.0*sin(PI*iTime/10.0)), 1.);\n    float s1 = sphere_sdf(p - vec3(2.0*sin(PI*iTime/10.0), 1.5, 0), 1.);\n    float b1 = box_sdf(p - vec3(0,1,0), vec3(1, 1, 1));\n    \n    return smin(smax(smin(b1, s1, .1), -s2, .1), p.y, .5);\n}\n\nfloat scene_depth(vec3 ro, vec3 rd) {\n    float depth = MIN_DEPTH;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene_sdf(ro + depth * rd);\n        if (dist < EPSILON) { return depth; }\n        depth += dist;\n        if (dist >= MAX_DEPTH) { return MAX_DEPTH; }\n    }\n    return MAX_DEPTH;\n}\n\nvec3 estimate_normal(vec3 p) {\n    return normalize(vec3(\n        scene_sdf(vec3(p.x + EPSILON, p.y, p.z)) - scene_sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        scene_sdf(vec3(p.x, p.y + EPSILON, p.z)) - scene_sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        scene_sdf(vec3(p.x, p.y, p.z + EPSILON)) - scene_sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 ray_direction(vec3 ro, vec3 target, vec2 fragCoord) {\n    vec3 dir = normalize(target - ro);\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 rx = -normalize(cross(dir, vec3(0,1,0)));\n    vec3 ry = normalize(cross(dir, rx));\n    \n    return normalize(dir + rx*uv.x + ry*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro = vec3(cos(iTime/10.)*3.0, 3.0, sin(iTime/10.)*3.0);\n    vec3 target = vec3(0, 1, 0);\n    vec3 rd = ray_direction(ro, target, fragCoord);\n    \n    \n    float depth = scene_depth(ro, rd);\n    \n    if (depth > MAX_DEPTH - EPSILON) {\n        fragColor = vec4(vec3(0.5), 1);\n        return;\n    }\n    \n    vec3 p = ro + rd * depth;\n    vec3 normal = estimate_normal(p);\n    \n    vec3 light = vec3(3,6,3);\n    vec4 n = fbmd(p);\n    vec3 color = pow3(vec3(  -n.x, n.x, 0  ), 1.) * pow(length(n.yzw), 0.5);\n    //vec3 color = pow3(1.0-2.0*abs(0.5-mod(p,1.0)), 4.0) * (dot(normal, normalize(light-p))/2.+.5);\n    \n    if (p.y > -EPSILON && p.y < EPSILON) {\n        vec3 dp = round(mod(p / 2.0, 1.0));\n        float d = round(mod((dp.x + dp.z), 2.0));\n        color = vec3(0.5) * d;\n    }\n    \n    if (depth > 10.0) {\n        color = mix(color, vec3(0.5), 1.0 - exp(-0.001 * depth * depth));\n    }\n    \n    fragColor = vec4(color, 1);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}