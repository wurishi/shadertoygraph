{"ver":"0.1","info":{"id":"tstSz7","date":"1573052000","viewed":3293,"name":"Thousands of indexed particles","username":"morimea","description":"Based on [url]https://www.shadertoy.com/view/wdG3Wd[/url]\nEach particle has its own unique index, base on it each particle can have/use its own unique values. Those values can be controlled outside by index\nTotal-total active particles spawned(reset only)","likes":64,"published":1,"flags":32,"usePreview":0,"tags":["2d","collision","particles","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// base on https://www.shadertoy.com/view/wdG3Wd\n\n// Created by Danil (2019+) https://github.com/danilw\n// The MIT License\n\n\n// NOTE 2020\n// Warning - in this shader I use INT 0xffffff (24bits) from 32bit FBO\n// 0xff from pos is unused (0xff from speed(vel) can not be used because speed can be negative)\n// if you rework(by using floatBitsToUint) save/load logic to use UINT then 0xff can be used\n\n\n//bufA UI\n//bufB data by index for particles\n//bufC particle logic\n//image draw particles\n\n// data (bufC)\n// in [x,y,z,w]\n// x-0xfffff-posx, 0xf-data\n// y-0xfffff-posy, 0xf-data\n// z-0xffff-velx, 0xff-data\n// w-0xffff-vely, 0xff-data\n// data used to store particle IDs (or other unique data as you need)\n\n// Particles jittering - because floats converted to INT 0xfffff and result precision loss\n// because of logic with store/get value (that use (1./0xfffff) as float step for pos)\n// (and when you set speed to 0 particles will travel because of float-to-int precision loss)\n\n// bufB data by index for particles:\n// used only [pixel.x] to store data, [y,z,w] unused \n// particle_ID==position on texture(coordinate.xy), index(ID) converted form 1d to 2d obviously\n// Image shader read particle ID, and get its color by its ID set any color for any ID in bufB to test\n\n\n\nvec4 loadval(ivec2 ipx) {\n    return texelFetch(iChannel0, ipx, 0);\n}\n\n// https://www.shadertoy.com/view/llyXRW\n\nvoid C(inout vec2 U, inout vec4 T, in int c){\n    U.x+=.5;\t\n    if(U.x<.0||U.x>1.||U.y<0.||U.y>1. ){\n        T+= vec4(0);\n    }\t\t\n    else{\n        vec2 tu=U/16. + fract( vec2(float(c), float(15-c/16)) / 16.);\n\t\t//tu.y=1.-tu.y;\n        T+= textureGrad( iChannel3,tu, dFdx(tu/16.),dFdy(tu/16.));\n    }\n}\n\nfloat print_int(vec2 U, int val) {\n    vec4 T = vec4(0);\n    int cval=val;\n    int X=8;\n    for(int i=0;i<X;i++){\n            if(cval>0){\n        int tv=cval%10;\n        C(U,T,48+tv);\n        cval=cval/10;\n    }\n    else{\n        if(length(T.yz)==0.)\n            return 0.;\n        else return T.x;\n    }\n    }\n\n    if(length(T.yz)==0.)\n        return 0.;\n    else return T.x;\n}\n\nvec4 ballD(in vec2 ipos, in vec2 ballp)\n{\n    float d = distance(ipos, ballp)/BALL_SIZE;\n    return vec4(clamp(sign(1.0-d), 0.0, 1.0)*(1.-d) * float(ballp.x > 0.0)) ;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nvec4 getV(in ivec2 p,float max_pos){\n    vec4 tval=texelFetch( iChannel2, ivec2(p), 0 );\n    float p1=decodeval_pos(int(tval.x))*max_pos;\n    float p2=decodeval_pos(int(tval.y))*max_pos;\n    float v1=decodeval_vel(abs(int(tval.z)));\n    float v2=decodeval_vel(abs(int(tval.w)));\n    float si=1.;\n    if(tval.z<0.)si=-1.;\n    float si2=1.;\n    if(tval.w<0.)si2=-1.;\n    vec2 unp=vec2(si*v1,si2*v2);\n\treturn vec4(vec2(p1,p2),unp.xy);\n}\n\nivec2 extra_dat_vel(ivec2 p){\n    vec4 tval=texelFetch( iChannel2, ivec2(p), 0 );\n    return ivec2(abs(int(tval.z))&0xff,abs(int(tval.w))&0xff);\n}\n\nivec2 extra_dat_pos(ivec2 p){\n    vec4 tval=texelFetch( iChannel2, ivec2(p), 0 );\n    return ivec2(int(tval.x)&0xf,int(tval.y)&0xf);\n}\n\nint get_id(ivec2 p){\n    ivec2 v1=extra_dat_pos(p);\n    ivec2 v2=extra_dat_vel(p);\n    int iret=(v1[0]<<20)|(v1[1]<<16)|(v2[0]<<8)|(v2[1]<<0);\n    return iret;\n}\n\nivec2 index_x(int id){\n    ivec2 p_res=ivec2(iResolution.xy);\n\tint x=id%p_res.x;\n\tint y=id/p_res.x;\n\treturn ivec2(x,y);\n}\n\nvec3 get_col_byid(int id){\n    ivec2 pos=index_x(id);\n    int val=int(texelFetch(iChannel1,pos,0).x);\n    return vec3(decodeval16(val))/float(0xff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        float max_pos=abs(loadval(ivec2(1,0)).x);\n        float max_posy=abs(loadval(ivec2(1,0)).y);\n        float scale = max(0.001,SCALE_size_non_linear(loadval(ivec2(0,0)).x));\n\n        if(SCALE_size_non_linear(loadval(ivec2(0,0)).x)>0.95)scale=1.;\n        float scpx=loadval(ivec2(0,0)).z-0.015;\n        float scpy=loadval(ivec2(0,0)).w-0.015;\n        float mn=1.;\n        if(loadval(ivec2(0,0)).x>0.95)mn=0.;\n        vec2 fc=fragCoord;\n        fc+=mn*iResolution.y*vec2(scpx,scpy)/scale; //real scale\n\n\n\n        ivec2 cellIndex = ivec2(fc * scale);\n        vec2 cellp = mod(fc, scale)/scale;\n\n        vec4 res = vec4(0.0, 0.0, 0.0, 1.0);\n        vec2 worldPos = fc * scale;\n        float overlaps = 0.0;\n        vec4 normSum = vec4(0.0);\n        for (int x=-1; x<=1; x++) {\n            for (int y=-1; y<=1; y++) {\n\n                ivec2 tp = max(cellIndex+ivec2(x,y), ivec2(0));\t\t\t\n\n                vec4 ball  = getV(tp,max_pos);\n                vec2 p = ball.xy;\n                vec2 vel = ball.zw;\n\n                float d=sdBox((worldPos-p.xy)*SIZE_to_draw,vec2(BALL_SIZE*SIZE_to_draw)*.5);\n                ///normSum += vec4(p.xy-worldPos, 0.0, 0.0)/BALL_SIZE*(d < 1.0 ? 1.0 : 0.0);\n                vec4 shade = vec4(clamp(sign(1.0-d), 0.0, 1.0)*(1.-d) * float(ball.x > 0.0)) ;\n\n\n                int self_id=get_id(tp);\n\n                //color by id without data buf\n    /*\n                float mpx=0.5*max_pos/SSIZE;\n                int sx=self_id%int(mpx);\n                int sy=(self_id/int(mpx));\n                shade.r*=(float(sx%20)/20.);\n                shade.g*=(float(sy%20)/20.);\n                shade.b*=0.25+0.75*(float(self_id)/(mpx*max_posy));\n    */\n\n                //from data\n                shade.rgb*=get_col_byid(self_id);\n\n                if((loadval(ivec2(0,0)).x)<0.6){\n                float nba=max(float(print_int((worldPos-p.xy+vec2(-0.35,0.15))*SIZE_to_draw*1.,self_id)),0.);\n                shade.rgb=shade.rgb*(1.-nba)+nba*(1.-shade.rgb);\n                }\n\n                //vec4 shade = vec4(nc(worldPos-p.xy),1.);\n\n                //vec4 shade = vec4(d < 1.0 ? 1.0 : 0.0) ;\n                //res=max(res, shade*vec4(vel.x,-vel.x-vel.y,vel.y, 1.0));\n                res=max(res, shade);\n                //overlaps += d < 1.0 ? 1.0 : 0.0;\n            }\n        }\n        fragColor = res;\n    //fragColor = res * vec4(2.0 - overlaps, 3.0 - 2.0*overlaps, 1.0, 1.0);\n    //fragColor = normSum+vec4(1.0, 1.0, 1.0,1.0)*0.5;\n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    //fragColor.gb*=(float(abs(int(fragColor.w))&0xff)/float(0xff));\n    \n    vec2 uv=fragCoord/iResolution.xy;\n    fragColor=fragColor*(1.-texture(iChannel0,uv).a)+texture(iChannel0,uv)*texture(iChannel0,uv).a;\n    \n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//UI\n\n// data\n// [0,0] [zoom,speed_scale,posx,posy]\n// [1,0] [iResolution.x*3.,iResolution.y,is_reset,is_clean]\n// [1,1] [focus_posx,focus_posy,is_focus,n/f/s]\n// [0,1] [grav_x,grav_y,last_mouse.x,last_mouse.y]\n\n#define res ((iResolution.xy/iResolution.y)*0.5)\n\n// https://www.shadertoy.com/view/XsBBRd\n// ------------------------------------------------------------------------------------------------\nfloat m_stretch(float point, float stretch){\n    return .5 * (sign(point) * stretch - point) * (sign(abs(point) - stretch) + 1.);\n}\n\nfloat ollj_rotate(vec2 uv){\n    float ROTATE_PARAM0 = sqrt(1.);\n    float ROTATE_PARAM1 = sqrt(.0);\n    return dot(uv, vec2(ROTATE_PARAM0 + ROTATE_PARAM1, ROTATE_PARAM0 - ROTATE_PARAM1));\n}\n\n\nfloat sdf_arrow(vec2 uv, float norm, float angle, float head_height, float stem_width){\n    uv = vec2(cos(angle) * uv.x + sin(angle) * uv.y, -sin(angle) * uv.x + cos(angle) * uv.y);\n\n    norm -= head_height;\n    uv.x -= norm;\n\n    uv.y = abs(uv.y);\n    float head = max(ollj_rotate(uv) - head_height, -uv.x);\n\n    uv.x = (.5 * m_stretch(2. * uv.x + norm, norm));\n    uv.y = (.5 * m_stretch(2. * uv.y, stem_width));\n    float stem = length(uv);\n\n    return min(head, stem);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmat2 MD(float a) {return mat2(vec2(cos(a), -sin(a)), vec2(sin(a), cos(a)));}\n\nfloat angle2d(vec2 c, vec2 e) {\n    float theta = atan(e.y-c.y, e.x-c.x);\n    return theta;\n}\n\nfloat my_sign(float v){return v<0.?-1.:1.;}\n\n\n// https://www.shadertoy.com/view/llyXRW\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\n// U.x+=<X>*(0.5-0.2812*(res.x/0.5)); added to fix proportion moving\n\nfloat text_z(vec2 U) {\n    initMsg;\n    U.x+=3.*(0.5-0.2812*(res.x/0.5));\n    C(90);C(111);C(111);C(109);\n    endMsg;\n}\n\nfloat text_s(vec2 U) {\n    initMsg;\n    U.x+=10.*(0.5-0.2812*(res.x/0.5));\n    C(83);C(112);C(101);C(101);C(100);C(32);C(115);C(99);C(97);C(108);C(101);\n    endMsg;\n}\n\nfloat text_g(vec2 U) {\n    initMsg;\n    U.x+=6.*(0.5-0.2812*(res.x/0.5));\n    C(71);C(114);C(97);C(118);C(105);C(116);C(121);\n    endMsg;\n}\n\nfloat text_t(vec2 U) {\n    initMsg;\n    U.x+=5.*(0.5-0.2812*(res.x/0.5));\n    C(84);C(111);C(116);C(97);C(108);C(126);\n    endMsg;\n}\n\nfloat text_m(vec2 U) {\n    initMsg;\n    U.x+=5.5*(0.5-0.2812*(res.x/0.5)); //4.+1.5\n    C(77);C(111);C(117);C(115);C(101);;\n    endMsg;\n}\n\nfloat text_f(vec2 U) {\n    initMsg;\n    U.x+=4.*(0.5-0.2812*(res.x/0.5));\n    C(70);C(111);C(114);C(99);C(101);\n    endMsg;\n}\n\nfloat text_n(vec2 U) {\n    initMsg;\n    U.x+=4.*(0.5-0.2812*(res.x/0.5)); //3.+1.\n    C(78);C(111);C(110);C(101);\n    endMsg;\n}\n\nfloat text_ms(vec2 U) {\n    initMsg;\n    U.x+=4.*(0.5-0.2812*(res.x/0.5));\n    C(83);C(112);C(97);C(119);C(110);\n    endMsg;\n}\n\nfloat text_r(vec2 U) {\n    initMsg;\n    U.x+=4.*(0.5-0.2812*(res.x/0.5));\n    C(82);C(101);C(115);C(101);C(116);\n    endMsg;\n}\n\nfloat text_c(vec2 U) {\n    initMsg;\n    U.x+=4.*(0.5-0.2812*(res.x/0.5));\n    C(67);C(108);C(101);C(97);C(110);\n    endMsg;\n}\n\nfloat text_nui(vec2 U) {\n    initMsg;\n    U.x+=4.*(0.5-0.2812*(res.x/0.5));\n    C(110);C(111);C(32);C(85);C(73);\n    endMsg;\n}\n\nfloat text_floor(vec2 U) {\n    initMsg;\n    U.x+=4.*(0.5-0.2812*(res.x/0.5));\n    C(70);C(108);C(111);C(111);C(114);C(48);\n    endMsg;\n}\n\nfloat text_floor2(vec2 U) {\n    initMsg;\n    U.x+=4.*(0.5-0.2812*(res.x/0.5));\n    C(70);C(108);C(111);C(111);C(114);C(49);\n    endMsg;\n}\n\nvoid Cd(inout vec2 U, inout vec4 T, in int c){\n    U.x+=.5;\t\n    if(U.x<.0||U.x>1.||U.y<0.||U.y>1. ){\n        T+= vec4(0);\n    }\n    else{\n        vec2 tu=U/16. + fract( vec2(float(c), float(15-c/16)) / 16.);\n\t\t//tu.y=1.-tu.y;\n        T+= textureGrad( iChannel3,tu, dFdx(tu/16.),dFdy(tu/16.));\n    }\n}\n\nfloat print_int(vec2 U, int val) {\n    vec4 T = vec4(0);\n    int cval=val;\n    int X=8;\n    for(int i=0;i<X;i++){\n            if(cval>0){\n        int tv=cval%10;\n        Cd(U,T,48+tv);\n        cval=cval/10;\n    }\n    else{\n        if(length(T.yz)==0.)\n            return 0.;\n        else return T.x;\n    }\n    }\n\n    if(length(T.yz)==0.)\n        return 0.;\n    else return T.x;\n}\n\nvec4 loadval(ivec2 ipx) {\n    return texelFetch(iChannel0, ipx, 0);\n}\n\nbool is_scrollx(vec2 p){\n    return (-p.y>res.y-0.035)&&(-p.x<res.x-0.035);\n}\n\nbool is_scrolly(vec2 p){\n    return (-p.x>res.x-0.035);\n}\n\nbool is_reset(vec2 p){\n    return (step(abs(p.x-0.3937*(res.x/0.5)),0.13)*step(abs(p.y+0.3),0.035)>0.5);\n}\n\nbool is_clean(vec2 p){\n    return (step(abs(p.x-0.3937*(res.x/0.5)),0.13)*step(abs(p.y+0.2),0.035)>0.5);\n}\n\nbool is_grav(vec2 p){\n    return (step(abs(p.x-0.3937*(res.x/0.5)),0.115)*step(abs(p.y-0.28),0.115)>0.5);\n}\n\nbool is_n(vec2 p){\n    return (step(abs(p.x-0.3994*(res.x/0.5)),0.13)*step(abs(p.y-0.07),0.03)>0.5);\n}\n\nbool is_f(vec2 p){\n    return (step(abs(p.x-0.3994*(res.x/0.5)),0.13)*step(abs(p.y-0.01),0.03)>0.5);\n}\n\nbool is_s(vec2 p){\n    return (step(abs(p.x-0.3994*(res.x/0.5)),0.13)*step(abs(p.y+0.05),0.03)>0.5);\n}\n\nbool is_speed(vec2 p){\n    return (step(abs(p.x-0.16994*(res.x/0.5)),0.15)*step(abs(p.y-.44),0.03)>0.5);\n}\n\nbool is_zoom(vec2 p){\n    return (step(abs(p.x+0.26994*(res.x/0.5)),0.15)*step(abs(p.y-.44),0.03)>0.5);\n}\n\nbool is_m_scroll(vec2 p){\n    return ((!(is_scrollx(p)&&is_scrolly(p)))&&((step(abs(p.x-0.3937*(res.x/0.5)),0.115)+step(abs(p.y-.44),0.03))<0.5));\n}\n\nbool is_nui(vec2 p){\n    return (step(abs(p.x-0.3937*(res.x/0.5)),0.13)*step(abs(p.y+0.4),0.035)>0.5);\n}\n\nbool is_floor(vec2 p){\n    return (step(abs(p.x-0.3937*(res.x/0.5)),0.1)*step(abs(p.y+0.1),0.015)>0.5);\n}\nbool is_floor2(vec2 p){\n    return (step(abs(p.x-0.3937*(res.x/0.5)),0.1)*step(abs(p.y+0.14),0.015)>0.5);\n}\n\nfloat draw_grav_w(vec2 uv, vec2 im){\n    vec2  arrow_uv = uv;\n    float arrow_norm =clamp(length(im),0.05,1.); \n    float arrow_angle = angle2d(vec2(0.),im);\n    float arrow_head_height = .1;  \n    float arrow_stem_width = .04; \n    float arrow_aa = (4. * 1. / iResolution.y)*7.5;\n    float arrow=0.;\n    arrow = sdf_arrow(arrow_uv, arrow_norm, arrow_angle, arrow_head_height, arrow_stem_width);\n    arrow = smoothstep(arrow_aa, 0., arrow);\n\n    return arrow;\n}\n\nconst vec3 whitel = vec3(0xdc, 0xe0, 0xd1) / float(0xff);\nconst vec3 darkb = vec3(0x00, 0x20, 0x59) / float(0xff);\nconst vec3 redd = vec3(0xe1, 0x46, 0x14) / float(0xff);\nconst vec3 green = vec3(0x00, 0x66, 0x33) / float(0xff);\n\nvec4 draw_ui(vec2 fc){\n    vec2 uv=fc/iResolution.y-res;\n    vec3 col=vec3(0.);\n    bool is_nuion=loadval(ivec2(1,0)).x<=0.;\n    float a=0.;\n    if(is_nuion){\n    if(is_scrolly(uv)){\n        float scp=loadval(ivec2(0,0)).w;\n        if((uv.y+res.y<scp+0.05)&&(uv.y+res.y>scp-0.05))\n            col=whitel*0.5;\n        else\n            col=whitel;\n        a=0.68;\n    }\n    else\n    if(is_scrollx(uv)){\n        float scp=loadval(ivec2(0,0)).z;\n        if((uv.x+res.x<scp+0.05)&&(uv.x+res.x>scp-0.05))\n            col=whitel*0.5;\n        else\n            col=whitel;\n        a=0.68;\n    }}\n    \n    if(is_nuion)\n    if(uv.y>0.3){\n        float d=text_z((uv+vec2(0.47817*(res.x/0.5),-0.40))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n        d=text_s((uv+vec2(0.19689*(res.x/0.5),-0.40))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n        d=text_g((uv+vec2(-0.28127*(res.x/0.5),-0.40))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n        d=text_t((uv+vec2(0.11251*(res.x/0.5),-0.30))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n        if((uv.x>0.0562*(res.x/0.5))&&(uv.x<0.28127*(res.x/0.5))&&(uv.y<0.4))\n        {\n            float max_pos=abs(loadval(ivec2(1,0)).x);\n            float max_posy=abs(loadval(ivec2(1,0)).y);\n            d=print_int((uv+vec2(-0.19689*(res.x/0.5),-0.30))*13.,int(max_pos/SSIZE)*int(max_posy*H/2.)/2);\n            col+=whitel*d;\n            a=max(a,d);\n        }\n    }\n    \n    if(is_nuion)\n    if((uv.x>0.0562*(res.x/0.5))&&(uv.y>-0.1)){\n        float d=text_m((uv+vec2(-0.28127*(res.x/0.5),-0.10))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n        d=text_n((uv+vec2(-0.3094*(res.x/0.5),-0.03))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n        d=text_f((uv+vec2(-0.3094*(res.x/0.5),0.03))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n        d=text_ms((uv+vec2(-0.3094*(res.x/0.5),0.09))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n        int sid=int(loadval(ivec2(1,1)).w);\n        if(sid==0)\n            if(is_n(uv)){\n                d=.8;\n                col+=green;\n                a=max(a,d);\n            }\n        if(sid==1)\n            if(is_f(uv)){\n                d=.8;\n                col+=green;\n                a=max(a,d);\n            }\n        if(sid==2)\n            if(is_s(uv)){\n                d=.8;\n                col+=green;\n                a=max(a,d);\n            }\n    }\n    \n    if(is_reset(uv)&&is_nuion)\n    {\n        float d=1.;\n        col+=redd*d;\n        a=max(a,d*0.75);\n        d=text_r((uv+vec2(-0.3094*(res.x/0.5),0.34))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n    }\n    \n    if(is_clean(uv)&&is_nuion)\n    {\n        float d=1.;\n        col+=darkb*d;\n        a=max(a,d*0.75);\n        d=text_c((uv+vec2(-0.3094*(res.x/0.5),0.24))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n    }\n    \n    if(is_grav(uv))\n    {\n        vec2 gravity=loadval(ivec2(0,1)).xy;\n        float d=1.;\n        col=vec3(0.);\n        a=max(a,d*(0.6-(is_nuion?0.:0.3)));\n        d=draw_grav_w((uv-vec2(0.3937*(res.x/0.5),0.28))*7.5,gravity);\n        col=whitel*d;\n        a=max(a,d);\n    }\n    \n    if(is_zoom(uv))\n    {\n        float state=loadval(ivec2(0,0)).x*0.15*2.;\n        float d=1.-(is_nuion?0.:0.3);\n        col=vec3(0.);\n        if(abs(uv.x+0.26994*(res.x/0.5)-state+0.15-0.007)>0.015)\n            col=whitel*d;\n        else\n            col=whitel*0.5;\n        a=max(a,d*0.68);\n    }\n    \n    if(is_speed(uv))\n    {\n        float state=loadval(ivec2(0,0)).y*0.15*2.;\n        float d=1.-(is_nuion?0.:0.3);\n        col=vec3(0.);\n        if(abs(uv.x-0.16994*(res.x/0.5)-state+0.15-0.007)>0.015)\n            col=whitel*d;\n        else\n            col=whitel*0.5;\n        a=max(a,d*0.68);\n    }\n    \n    if(is_nui(uv))\n    {\n        float d=1.-(is_nuion?0.:0.3);\n        col+=darkb*d;\n        a=max(a,d*0.75);\n        d=text_nui((uv+vec2(-0.3094*(res.x/0.5),0.44))*13.);\n        col+=whitel*d;\n        a=max(a,d);\n    }\n    \n    if(is_floor(uv)&&is_nuion)\n    {\n        float d=1.;\n        if(loadval(ivec2(0,1)).w>=0.)col+=green*d;\n        a=max(a,d*0.75);\n        d=text_floor((uv+vec2(-0.324*(res.x/0.5),0.13))*18.);\n        col+=whitel*d;\n        a=max(a,d);\n    }\n    if(is_floor2(uv)&&is_nuion)\n    {\n        float d=1.;\n        if(loadval(ivec2(0,1)).w<0.)col+=green*d;\n        a=max(a,d*0.75);\n        d=text_floor2((uv+vec2(-0.324*(res.x/0.5),0.168))*18.);\n        col+=whitel*d;\n        a=max(a,d);\n    }\n    \n    \n    col=clamp(col,0.,1.);\n    //a=dot(col,vec3(1.))/3.;\n    return vec4(col,a);\n}\n\n// data\n// [0,0] [zoom,speed_scale,posx,posy]\n// [1,0] [iResolution.x*3.,iResolution.y,is_reset,is_clean] //sign of [x,y] x for noUI flag, y for click once\n// [1,1] [focus_posx,focus_posy,is_focus,n/f/s]\n// [0,1] [grav_x,grav_y,last_mouse.x,last_mouse.y] //sign of [z,w] w for floor0/1\n\nvec4 init(ivec2 io){\n    if(io==ivec2(0,0)){\n        float z=.42;\n        float s=.4;\n        float px=res.x/2.;\n        float py=0.01;\n        return vec4(z,s,px,py);\n    }\n    if(io==ivec2(1,0)){\n        float irx=-iResolution.x*SSIZE; //size of board //bug float\n        float iry=-iResolution.y; //only for init/reset\n        float a=-1.;\n        float b=-1.;\n        return vec4(irx,iry,a,b);\n    }\n    if(io==ivec2(1,1)){\n        float fpx=0.;\n        float fpy=0.;\n        float a=-1.;\n        float b=0.;\n        return vec4(fpx,fpy,a,b);\n    }\n    if(io==ivec2(0,1)){\n        float gx=0.0;\n        float gy=-0.5;\n        float a=0.;\n        float b=0.;\n        return vec4(gx,gy,a,b);\n    }\t\n    return vec4(0.);\n}\n\nvec4 store_data(vec2 fc){\n    vec4 col=vec4(0.);\n    ivec2 io=ivec2(fc);\n    if(iFrame<10){\n        col=init(io);\n        return col;\n    }\n    \n    vec4 focus_dat=loadval(ivec2(1,1));\n    vec2 ifp=focus_dat.xy/iResolution.y-res;\n    bool is_nuion=loadval(ivec2(1,0)).x<0.;\n    \n    if(io==ivec2(0,0)){\n        vec4 self_dat=loadval(ivec2(0,0));\n        float z=self_dat.x;\n        float s=self_dat.y;\n        float px=self_dat.z;\n        float py=self_dat.w;\n        if(focus_dat.z>0.){\n            vec2 im=iMouse.xy/iResolution.y-res;\n            if(is_scrolly(ifp)&&is_nuion){\n                py=im.y+res.y;\n            }\n            if(is_scrollx(ifp)&&is_nuion){\n                px=im.x+res.x;\n            }\n            if(is_m_scroll(ifp)||(!is_nuion)){\n                vec4 px_dat=loadval(ivec2(0,1));\n                vec4 px_dat2=loadval(ivec2(1,1));\n                if(px_dat2.w<0.5){\n                vec2 iom=abs(px_dat.zw)/iResolution.y-res;\n                px+=(-im.x+iom.x)*max(0.001,SCALE_size_non_linear(z));\n                py+=(-im.y+iom.y)*max(0.001,SCALE_size_non_linear(z));\n                }\n                \n            }\n            if(is_zoom(ifp)){\n                z=((im.x+0.26994*(res.x/0.5))+0.15)/(0.15*2.);\n                z=clamp(z,0.001,1.);\n            }\n            if(is_speed(ifp)){\n                s=((im.x-0.16994*(res.x/0.5))+0.15)/(0.15*2.);\n                s=clamp(s,0.,1.);\n            }\n        }\n        px=clamp(px,-0.01,iResolution.x/iResolution.y+0.01);\n        py=clamp(py,-0.005,1.005);\n        col=vec4(z,s,px,py);\n        return col;\n    }\n    \n    if(io==ivec2(1,0)){\n        vec4 self_dat=loadval(ivec2(1,0));\n        float irx=self_dat.x;\n        float iry=self_dat.y;\n        float a=-1.;\n        float b=-1.;\n        \n        if(focus_dat.z>0.){\n            if(is_reset(ifp)&&is_nuion){\n                \n                irx=my_sign(irx)*iResolution.x*SSIZE;\n                iry=my_sign(iry)*iResolution.y;\n                a=1.;\n            }\n            if(is_clean(ifp)&&is_nuion){\n                b=1.;\n            }\n            if(is_nui(ifp)&&(iry<0.)){\n                irx=-irx;\n            }\n            iry=abs(iry);\n        }\n        else{\n            iry=-abs(iry);\n        }\n        \n        col = vec4(irx,iry,a,b);\n        return col;\n    }\n    \n    if(io==ivec2(1,1)){\n        vec4 self_dat=loadval(ivec2(1,1));\n        float fpx=self_dat.x;\n        float fpy=self_dat.y;\n        float a=self_dat.z;\n        float b=self_dat.w;\n        \n        if(focus_dat.z>0.)\n            if(is_n(ifp)&&is_nuion)b=0.;\n            if(is_f(ifp)&&is_nuion)b=1.;\n            if(is_s(ifp)&&is_nuion)b=2.;\n        \n        if(iMouse.z>0.){\n            if(a<0.){\n                fpx=iMouse.x;\n                fpy=iMouse.y;\n            }\n            a=1.;\n        }\n        else{\n            a=-1.;\n        }\n        col = vec4(fpx,fpy,a,b);\n        return col;\n    }\n    \n    if(io==ivec2(0,1)){\n        vec4 self_dat=loadval(ivec2(0,1));\n        float gx=self_dat.x;\n        float gy=self_dat.y;\n        float a=self_dat.z;\n        float b=self_dat.w;\n        \n        if(focus_dat.z>0.){\n            if(is_grav(ifp)){\n                vec2 im=iMouse.xy/iResolution.y-res;\n                im+=-vec2(0.3937*(res.x/0.5),0.28);\n                \n                im*=7.5;\n                im=normalize(im)*min(length(im),1.);\n                //im=clamp(im,-1.,1.);\n                gx=im.x;\n                gy=im.y;\n            }\n            if(is_floor(ifp)){\n                b=abs(b);\n            }\n            if(is_floor2(ifp)){\n                b=-abs(b);\n            }\n        }\n        a=my_sign(a)*iMouse.x;\n        b=my_sign(b)*iMouse.y;\n        col = vec4(gx,gy,a,b);\n        return col;\n    }\n    \n    return vec4(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(any(greaterThan(fragCoord,vec2(2.))))\n        fragColor=draw_ui(fragCoord);\n    else\n        fragColor=store_data(fragCoord);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst float SPAWN_point_size=3.; //spawn in square X*X pixel\n\n//this used only to have particles keep its position on changeing to fullscreen, it has no use if your FBO is static size\nconst float SSIZE = 3.0; //max particle posiiton *X\n\nconst float SIZE_to_draw = 3.0; //ball size to draw\nconst float BALL_SIZE = 0.90; // should be between sqrt(2)/2 and 1\nconst float BALL_D = 2.0 * BALL_SIZE; \nconst float H = 0.5; // on init fill % of screen iResolution.y\nconst float VEL_LIMIT = 0.52 * BALL_SIZE;\nconst float maxG = 0.006; // max gravity\nconst float E_FORCE = 1.9;\nconst float M = 0.6 * BALL_SIZE;\nconst float DAMP_K = 0.98;\nconst float SQ_K = 0.0;\nconst float MOUSE_F = 0.38;\n\t\nivec3 decodeval16(int varz) {\n    ivec3 iret=ivec3(0);\n    iret.x=varz>>16;\n    iret.y=(varz>>8)&0xff;\n    iret.z=(varz>>0)&0xff;\n    return iret;\n}\n\nint encodeval16(ivec3 colz) {\n    return int(((colz[0]&0xff)<<16)|((colz[1]&0xff)<< 8)|((colz[2]&0xff)<< 0));\n}\n\nfloat decodeval_vel(int varz) {\n    int iret=0;\n    iret=varz>>8;\n    return float(iret)/float(0xffff);\n}\n\nint encodeval_vel(ivec2 colz) {\n    return int(((colz[0]&0xffff)<< 8)|((colz[1]&0xff)<< 0));\n}\n\nfloat decodeval_pos(int varz) {\n    int iret=0;\n    iret=varz>>4;\n    return float(iret)/float(0xfffff);\n}\n\nint encodeval_pos(ivec2 colz) {\n    return int(((colz[0]&0xfffff)<< 4)|((colz[1]&0xf)<< 0));\n}\n\nfloat SCALE_size_non_linear(float val){\n    //return val; //linear\n    return min(smoothstep(0.,5.,val)+smoothstep(0.5,1.6,val)+smoothstep(0.7,1.3,val),1.);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n//UI\n\n// data\n// [0,0] [zoom,speed_scale,posx,posy]\n// [1,0] [iResolution.x*3.,iResolution.y,is_reset,is_clean]\n// [1,1] [focus_posx,focus_posy,is_focus,n/f/s]\n// [0,1] [grav_x,grav_y,last_mouse.x,last_mouse.y]\n\n\n#define SETTING_ZOOM loadval(ivec2(0,0)).x\n#define SETTING_SPEED_SCALE loadval(ivec2(0,0)).y\n#define SETTING_VIEW_POS (loadval(ivec2(0,0)).zw)\n#define SETTING_RESOLUTION (loadval(ivec2(1,0)).xy)\n#define SETTING_IS_RESET loadval(ivec2(1,0)).z > 0.5\n#define SETTING_IS_CLEAN loadval(ivec2(1,0)).w > 0.5\n#define SETTING_FOCUS_POS loadval(ivec2(1,1)).xy\n#define SETTING_IS_FOCUS loadval(ivec2(1,1)).z\n\n#define SETTING_MOUSE_MODE_NONE (int(loadval(ivec2(1,1)).w) == 0)\n#define SETTING_MOUSE_MODE_FORCE (int(loadval(ivec2(1,1)).w) == 1)\n#define SETTING_MOUSE_MODE_SPAWN (int(loadval(ivec2(1,1)).w) == 2)\n\n#define SETTING_GRAVITY (loadval(ivec2(0,1)).xy)\n#define SETTING_LAST_MOUSE (loadval(ivec2(0,1)).zw)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// this is example store of data for particles\n// particle ID==fragCoord\n// I store only particle color as RGB(0xff,0xff,0xff) in .x\n\nvec4 loadval(ivec2 ipx) {\n    return texelFetch(iChannel0, ipx, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 oldc=texelFetch(iChannel1,ivec2(fragCoord),0);\n    bool mouseReset = (loadval(ivec2(1,0)).z>0.5)||(loadval(ivec2(1,0)).w>0.5);\n    float max_pos=abs(loadval(ivec2(1,0)).x/SSIZE);\n    float max_posy=abs(loadval(ivec2(1,0)).y);\n    int self_id=int(floor(fragCoord.x)+floor(fragCoord.y)*iResolution.x);\n    \n    //set collors by ID, as example\n        if(self_id==902){\n            fragColor=vec4(float(0xff0000),0.,0.,0.);\n            return;\n        }\n        if(self_id==903){\n            fragColor=vec4(float(0x00ff00),0.,0.,0.);\n            return;\n        }\n        if(self_id==904){\n            fragColor=vec4(float(0x0000ff),0.,0.,0.);\n            return;\n        }\n    \n    \n    if((iFrame<10)||(oldc.x<1.)||(mouseReset)){\n        vec3 shade=vec3(1.);\n        if((fragCoord.x<iResolution.x/4.)||((fragCoord.x>iResolution.x/2.)&&(fragCoord.x<iResolution.x-iResolution.x/4.))){\n            float mpx=max_pos;\n            int sx=self_id%int(mpx);\n            int sy=(self_id/int(mpx));\n            shade.r*=(float(sx%20)/20.);\n            shade.g*=(float(sy%20)/20.);\n            shade.b*=0.25+0.75*(float(self_id)/(mpx*max_posy));}\n        else\n        shade=texture(iChannel3,(fragCoord/iResolution.xy)*vec2(1.,2.)*4.,0.0).rgb; //texture as color\n        shade=shade*float(0xff);\n        int val=encodeval16(ivec3(shade));\n        fragColor=vec4(float(val),0.,0.,0.);\n        return;\n    }\n    fragColor=oldc;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// base on https://www.shadertoy.com/view/wdG3Wd\n// thanks to https://www.shadertoy.com/user/capsadmin for making BufC little better\n\nvec2 GRID_POS;\n\nvec4 loadval(ivec2 ipx) {\n    return texelFetch(iChannel0, ipx, 0);\n}\n\n// data (used 0xffffff INT without conversion to uint)\n// in [x,y,z,w]\n// x-0xfffff-posx, 0xf-data\n// y-0xfffff-posy, 0xf-data\n// z-0xffff-velx, 0xff-data\n// w-0xffff-vely, 0xff-data\n// data used to store particle IDs\n\n// get [pos,vel]\n\nvec2 get_particle_pos(in vec2 p) {\n    if(p.x < 0.001 || p.y < 0.001)\n        return vec2(0);\n\n    float max_pos = abs(SETTING_RESOLUTION.x);\n    vec4 tval = texelFetch(iChannel2, ivec2(p), 0);\n    float p1 = decodeval_pos(int(tval.x)) * max_pos;\n    float p2 = decodeval_pos(int(tval.y)) * max_pos;\n\n    return vec2(p1, p2);\n}\n\nvec2 get_particle_vel(in vec2 p) {\n    if(p.x < 0.001 || p.y < 0.001)\n        return vec2(0);\n\n    vec4 tval = texelFetch(iChannel2, ivec2(p), 0);\n    float v1 = decodeval_vel(abs(int(tval.z)));\n    float v2 = decodeval_vel(abs(int(tval.w)));\n    float si = 1.;\n    if(tval.z < 0.)\n        si = -1.;\n    float si2 = 1.;\n    if(tval.w < 0.)\n        si2 = -1.;\n    vec2 unp = vec2(si * v1, si2 * v2);\n    return unp.xy;\n}\n\nivec2 extra_dat_vel(vec2 p) {\n    vec4 tval = texelFetch(iChannel2, ivec2(p), 0);\n    return ivec2(abs(int(tval.z)) & 0xff, abs(int(tval.w)) & 0xff);\n}\n\nivec2 extra_dat_pos(vec2 p) {\n    vec4 tval = texelFetch(iChannel2, ivec2(p), 0);\n    return ivec2(int(tval.x) & 0xf, int(tval.y) & 0xf);\n}\n\n// get saved unique ID\nint get_particle_uid(vec2 p) {\n    ivec2 v1 = extra_dat_pos(p);\n    ivec2 v2 = extra_dat_vel(p);\n    int iret = (v1[0] << 20) | (v1[1] << 16) | (v2[0] << 8) | (v2[1] << 0);\n    return iret;\n}\n\nivec4 encode_particle_uid(int id) {\n    int a = (id >> 20) & 0xf;\n    int b = (id >> 16) & 0xf;\n    int c = (id >> 8) & 0xff;\n    int d = (id >> 0) & 0xff;\n    return ivec4(a, b, c, d);\n}\n\nvec2 pack_pos(vec2 pos, ivec2 extra_val, float max_pos) {\n    int v1 = max(int((pos.x / max_pos) * float(0xfffff)), 0);\n    int v2 = max(int((pos.y / max_pos) * float(0xfffff)), 0);\n    float px = float(encodeval_pos(ivec2(v1, extra_val.x)));\n    float py = float(encodeval_pos(ivec2(v2, extra_val.y)));\n    return vec2(px, py);\n}\n\nvec2 pack_vel(vec2 vel, ivec2 extra_val) {\n    int v1 = abs(int(vel.x * float(0xffff)));\n    int v2 = abs(int(vel.y * float(0xffff)));\n    float vx = float(encodeval_vel(ivec2(v1, extra_val.x)));\n    float vy = float(encodeval_vel(ivec2(v2, extra_val.y)));\n    float si = 1.;\n    if(vel.x < 0.)\n        si = -1.;\n    float si2 = 1.;\n    if(vel.y < 0.)\n        si2 = -1.;\n    return vec2(vx * si, vy * si2);\n}\n\n// save everything to pixel color\nvec4 encode_particle(vec2 pos, vec2 vel, int id) {\n    ivec4 tid = encode_particle_uid(id);\n    ivec2 extra_data_pos = tid.xy;\n    ivec2 extra_data_vel = tid.zw;\n    float max_pos = abs(SETTING_RESOLUTION.x);\n    vec2 pos_ret = pack_pos(pos, extra_data_pos, max_pos);\n    vec2 vel_ret = pack_vel(vel, extra_data_vel);\n    return vec4(pos_ret, vel_ret);\n}\n\nbool should_apply_mouse_force() {\n    return SETTING_MOUSE_MODE_FORCE || SETTING_MOUSE_MODE_SPAWN;\n}\n\nbool is_spawning_particles() {\n    return SETTING_MOUSE_MODE_SPAWN && iMouse.z > 0.0;\n}\n\nbool should_reset() {\n    bool mouseReset = (SETTING_IS_RESET) || (SETTING_IS_CLEAN);\n    return iFrame <= 10 || mouseReset;\n}\n\nvec2 get_particle_gravity() {\n    return SETTING_GRAVITY * maxG * M;\n}\n\nvec2 get_world_mouse_position() {\n    vec2 cam_pos = SETTING_VIEW_POS - vec2(0.015);\n    float cam_scale = max(0.001, SCALE_size_non_linear(SETTING_ZOOM));\n\n    float mn = 1.0;\n    if(cam_scale > 0.95)\n        cam_scale = 1.0;\n\n    if(SETTING_ZOOM > 0.95)\n        mn = 0.0;\n\n    return (iMouse.xy + mn * iResolution.y * cam_pos / cam_scale) * cam_scale;\n}\n\nvec2 get_mouse_force(vec2 pos) {\n    vec2 mouseDir = pos - get_world_mouse_position();\n    float d2 = dot(mouseDir, mouseDir);\n\n    return M * MOUSE_F *\n        clamp(iMouse.z, 0.0, 1.0) * // mouse clicked outside zoom region\n        mouseDir * BALL_SIZE / max(d2, 0.01);\n}\n\nvec4 reset_sim() {\n    if(SETTING_IS_CLEAN) {\n        return vec4(0);\n    }\n\n    ivec2 iv = ivec2(GRID_POS);\n    float max_posy = abs(SETTING_RESOLUTION.y);\n\n    if((iv.x + iv.y) % 2 == 0 && iv.y % 2 == 0 && iv.y < int(max_posy * H)) {\n\n        int id = int(floor(GRID_POS.x) + floor(GRID_POS.y - GRID_POS.y / 2.) * iResolution.x) / 2;\n        vec2 pos = (GRID_POS + (rand(GRID_POS) - 0.5) * 0.25);\n        vec2 vel = vec2(0.);\n\n        return encode_particle(pos, vel, id);\n\n    }\n\n    return vec4(0);\n}\n\nvec3 do_collisions(vec2 pos) {\n    vec2 force = vec2(0);\n    float stress = 0.0;\n\n    for(int x = -2; x <= 2; x++) {\n        for(int y = -2; y <= 2; y++) {\n            if(x != 0 || y != 0) {\n                vec2 other_pos = get_particle_pos(GRID_POS + vec2(x, y));\n                if(other_pos.x <= 0.0)\n                    continue;\n\n                vec2 dir = pos - other_pos;\n                float len = length(dir);\n                float f = BALL_D - len;\n                if(len >= 0.001 * BALL_SIZE && f > 0.0) {\n                    float f2 = f / (BALL_D);\n                    f2 += SQ_K * f2 * f2;\n                    f2 *= BALL_D;\n                    vec2 force_part = E_FORCE * normalize(dir) * f2;\n                    force += force_part;\n                    stress += abs(force_part.x) + abs(force_part.y);\n                }\n            }\n        }\n    }\n\n    return vec3(force, stress);\n}\n\nvec4 spawn_particles() {\n    if(iFrame % 3 == 0) {\n        // don't spawn too fast\n        return vec4(0);\n    }\n\n    if((length(trunc(GRID_POS) - trunc(get_world_mouse_position())) < SPAWN_point_size)) {\n\n        int uid = iFrame;\n        vec2 pos = (GRID_POS + (rand(GRID_POS) - 0.5) * 0.25);\n        vec2 vel = vec2(0);\n\n        return encode_particle(pos, vel, uid);\n    }\n\n    // spawn nothing outside of the mouse point\n    return vec4(0);\n}\n\nstruct Particle {\n    int uid;\n    vec2 pos;\n    vec2 vel;\n};\n\nbool load_particle(out Particle particle) {\n    particle.uid = 0;\n    particle.pos = vec2(0.0);\n    particle.vel = vec2(0.0);\n\n    for(int x = -1; x <= 1; x++) {\n        for(int y = -1; y <= 1; y++) {\n            vec2 grid_pos_offset = GRID_POS + vec2(x, y);\n            vec2 pos = get_particle_pos(grid_pos_offset);\n\n            if(trunc(GRID_POS) == trunc(pos)) {\n                particle.uid = get_particle_uid(trunc(grid_pos_offset));\n                particle.pos = pos;\n                particle.vel = get_particle_vel(grid_pos_offset);\n\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nvec4 sim_step() {\n    Particle particle;\n\n    if(!load_particle(particle)) {\n        if(is_spawning_particles()) {\n            return spawn_particles();\n        }\n\n        return vec4(0);\n    }\n\n    vec3 res = do_collisions(particle.pos);\n    vec2 direction = res.xy;\n\n    if(should_apply_mouse_force()) {\n        float stress = res.z;\n        direction += get_mouse_force(particle.pos) * max(stress, 1.0);\n    }\n\n    direction += get_particle_gravity();\n\n    // don't apply damping to freely flying balls\n    float damp_k = length(direction) > 0.001 ? DAMP_K : 1.0;\n\n    particle.vel = damp_k * particle.vel + direction / M;\n    particle.vel = clamp(particle.vel, vec2(-1.0), vec2(1.0));\n\n    // what's this?\n    if(SETTING_LAST_MOUSE.y < 0.0) {\n        if((particle.pos.x <= 1.) || (particle.pos.x >= iResolution.x - 2.))\n            particle.vel = vec2(0.);\n        if((particle.pos.y <= 1.) || (particle.pos.y >= iResolution.y - 2.))\n            particle.vel = vec2(0.);\n    }\n\n    particle.pos += particle.vel * VEL_LIMIT * SETTING_SPEED_SCALE;\n    particle.pos = clamp(particle.pos, vec2(BALL_SIZE * (1.0 + sin(particle.pos.y) * 0.1), BALL_SIZE), iResolution.xy - vec2(BALL_SIZE));\n\n    return encode_particle(particle.pos, particle.vel, particle.uid);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord_) {\n    // this is used all over the place so lets make it a global\n    GRID_POS = fragCoord_;\n\n    if(should_reset()) {\n        fragColor = reset_sim();\n    } else {\n        fragColor = sim_step();\n    }\n}\n","name":"Buffer C","description":"","type":"buffer"}]}