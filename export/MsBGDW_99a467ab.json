{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"float sphere\n\t(vec3 ray, vec3 dir, vec3 center, float radius, vec3 color, inout vec3 nml, inout vec3 mat, float closestHit)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d)) * step(t, closestHit);\n\tclosestHit = mix(closestHit, t, st);\n\tnml = mix(nml, (center-(ray+dir*t)) / radius, st);\n\tmat = mix(mat, color, st);\n\treturn closestHit;\n}\n\nfloat scene(float t, vec3 ro, vec3 rd, inout vec3 nml, inout vec3 mat, float dist)\n{\n\tdist = sphere(ro, rd, vec3(0.0), 1.0, vec3(0.5, 0.8, 1.0), nml, mat, dist);\n\tdist = sphere(ro, rd, \n\t\t\t\t  vec3(sin(t*3.0)*3.0, cos(t*3.0)*3.0, cos(t)*8.0), \n\t\t\t\t  1.5, vec3(1.0, 0.8, 1.0), \n\t\t\t\t  nml, mat, dist);\n\tdist = sphere(ro, rd, \n\t\t\t\t  vec3(sin(t*3.0)*-3.0, cos(t*3.0)*-3.0, sin(t)*8.0), \n\t\t\t\t  1.5, vec3(0.5, 0.8, 0.5), \n\t\t\t\t  nml, mat, dist);\n\treturn dist;\n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 sunColor = vec3(2.0, 1.6, 1.0);\n\tvec3 skyColor = vec3(0.5, 0.6, 0.7);\n\tvec3 sunDir = normalize(vec3(sin(t), sin(t*1.2), cos(t)));\n\treturn\n\t\tpow(max(0.0, dot(sunDir, rd)), 128.0)*sunColor + \n\t\t0.2*pow(max(0.0, dot(sunDir, rd)), 2.0)*sunColor + \n\t\tpow(max(0.0, -dot(vec3(0.0, 1.0, 0.0), rd)), 1.0)*(1.0-skyColor) +\n\t\tpow(max(0.0, dot(vec3(0.0, 1.0, 0.0), rd)), 1.0)*skyColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = \n\t\t(-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n\tvec3 light = vec3(0.0); // How much light hits the eye through the ray.\n\t\n\tfloat epsilon = 0.001;\n\tfloat maxDist = 1e5;\n\t\n\tconst int mblur_count = 3;  // How many motion blur rays we trace.\n\tconst int bounce_count = 3; // How many scene rays we trace.\n\t\n\tfloat exposureTime = 1.0/15.0;\n\tvec2 tuv = vec2(float(mblur_count), 1.0)*(fragCoord.xy / 256.0);\n\t\n\tfor (int j=0; j<mblur_count; j++) {\n\t\tfloat rand = texture(iChannel0, tuv+vec2(float(j)/256.0, 0.0), -100.0).r;\n\t\tfloat t = iTime + exposureTime*((float(j)+2.0*(0.5-rand))/float(mblur_count));\n\t\tvec3 ro = vec3(0.0, 0.0, -6.0);     // Ray origin.\n\t\tvec3 rd = normalize(vec3(uv, 1.0)); // Ray direction.\n\t\tvec3 transmit = vec3(1.0);          // How much light the ray lets through.\n\t\t\n\t\tfor (int i=0; i<bounce_count; i++) {\n\t\t\tvec3 mat, nml;\n\t\t\tfloat dist = scene(t, ro, rd, nml, mat, maxDist);\n\t\t\tif (dist < maxDist) { // Object hit.\n\t\t\t\ttransmit *= mat;       // Make the ray more opaque.\n\t\t\t\tro += rd*dist;         // Move the ray to the hit point.\n\t\t\t\trd = reflect(rd, nml); // Reflect the ray.\n\t\t\t\t// Move the ray off the surface to avoid hitting the same point twice.\n\t\t\t\tro += rd*epsilon;\n\t\t\t} else { // Background hit.\n\t\t\t\t// Put the background light through the ray \n\t\t\t\t// and add it to the light seen by the eye.\n\t\t\t\tlight += transmit * background(t,rd);\n\t\t\t\tbreak; // Don't bounce off the background.\n\t\t\t}\n\t\t}\n\t}\n\tlight /= float(mblur_count);\n\tfragColor = vec4(light, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsBGDW","date":"1388009340","viewed":17886,"name":"Motion blur example","username":"kig","description":"Simple ray tracing example with motion blur.","likes":39,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","motionblur"],"hasliked":0,"parentid":"","parentname":""}}