{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n\"Cloth Texture Simulation\" by Emmanuel Keller aka Tambako - February 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n    \nLamp lamps[2];\n\nconst vec3 campos0 = vec3(40.3, -26.0, 1.2);\nvec3 campos;\nvec3 camdir = vec3(0., 0.75, -1.);\nvec3 camtarget0 = vec3(40.3, -26.0 , 0.);\nfloat fov = 10.;\n\nconst vec3 ambientColor = vec3(0.3, 0.4, 0.5);\nconst float ambientint = 0.03;\nconst vec3 objcolor1 = vec3(0.87);\nconst vec3 objcolor2 = vec3(0.39, 0.62, 0.85);\nconst vec3 objcolor3 = vec3(0.85, 0.33, 0.23);\n\nconst float tbrl = 3.;\nconst float difi = 0.73;\nconst float specint = 0.002;\nconst float specshin = 0.8;\nconst float aoint = 0.42;\nconst float ssstrmr = 0.18;\nconst float sssInt = 0.35;\n\nconst float txti0 = 0.4;\nconst float txtf = 30.;\n\nfloat normdelta = 0.00002;\n\nconst float fr0 = 0.022;\nfloat fr;\nconst float fe = 0.057;\nconst float fd = 0.395;\nconst float fds = 0.176;\nconst float twf = 65.;\nconst float twfs = -110.;\nconst float clsize = 60.;\nconst float tdv = 0.22;\nconst float tdd = 0.15;\nconst float ttwd = 0.002;\nconst float crv = 0.2;\nconst vec2 ffa = vec2(0.14, 0.37);\nconst float fft = 0.68;\n\nconst float maxdist = 1500.;\n\n// Be careful setting it, since it drastically increase the compiling time, but in the other\n// hand, it reduces the moire quite much.\n//#define ANTIALIASING\nconst float aawidth = 0.63;\nconst int aasamples = 1;\n\n#define SPECULAR\n#define SH_OA\n#define SS_SCATERING\n#define COL_TEXTURE\n#define POSSIZE_VAR\n\nfloat gtf;\nfloat gtf2;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\n// Simple \"random\" function\nfloat random(float co)\n{\n    return fract(sin(co*752.19) * 238.5);\n}\n\nfloat map_f_hor(vec3 pos, vec2 delta, float n)\n{\n    return length(vec2(mod(pos.y + delta.x, fe) - fe*0.6, pos.z + delta.y + fr*sin((pos.x + fe*2. + fe*floor(pos.y/fe))/fe*pi))) - fr*fds*0.86;\n}\n\nfloat hsf;\nfloat map_hor_small(vec3 pos, vec2 delta, float n)\n{\n    float fy = 132.*random(12.54*floor(pos.y/fe));\n    float ad = 1. + ttwd*hsf;\n                          \n    float angle = ad*twf*pos.x;\n    vec2 d1 = rotateVec(vec2(fr*fd, fr*fd), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_f_hor(pos, d1 + delta, n + 1.), map_f_hor(pos, d2 + delta, n + 2.)), map_f_hor(pos, -d2 + delta, n + 3.)), map_f_hor(pos, -d1 + delta, n + 4.)); \n}\n\nfloat pyd;\nfloat map_hor(vec3 pos)\n{  \n    float fy = 132.*random(1.254*floor(pos.y/fe));\n\n    fy = 17.5*random(2.452*floor(pos.y/fe));\n    pyd = fe*tdd*(1. - 0.45*0.5*sin(pos.x*2.15 + 13.*fy) - 0.3*0.5*sin(pos.x*4.12 + 42.*fy) - 0.25*0.5*sin(pos.y*8.72 + 70.*fy));\n    pos.y+= pyd;\n\n    hsf = 0.35*sin(pos.x*4.3 + 20.*fy) + 0.4*sin(pos.x*5.7 + 45.*fy) + 0.25*sin(pos.x*8.48 + 55.*fy);\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*tdv*hsf);\n    \n    float angle = twfs*pos.x;\n    vec2 d1 = rotateVec(vec2(fr*fds, fr*fds), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_hor_small(pos, d1, 1.), map_hor_small(pos, d2, 5.)), map_hor_small(pos, -d2, 9.)), map_hor_small(pos, -d1, 13.)); \n}\n\nfloat map_f_ver(vec3 pos, vec2 delta, float n)\n{\n    return length(vec2(mod(pos.x + delta.x, fe) - fe*0.6, pos.z + delta.y - fr*sin((pos.y + fe*2. + fe*floor(pos.x/fe))/fe*pi))) - fr*fds*0.86;\n}\n\nfloat vsf;\nfloat map_ver_small(vec3 pos, vec2 delta, float n)\n{    \n    float fx = 145.*random(19.36*floor(pos.x/fe));\n    float ad = 1. + ttwd*vsf;            \n    \n    float angle = ad*twf*pos.y;\n    vec2 d1 = rotateVec(vec2(fr*fd, fr*fd), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_f_ver(pos, d1 + delta, n + 1.), map_f_ver(pos, d2 + delta, n + 2.)), map_f_ver(pos, -d2 + delta, n + 3.)), map_f_ver(pos, -d1 + delta, n + 4.)); \n}\n\nfloat pxd;\nfloat map_ver(vec3 pos)\n{   \n    float fx = 145.*random(1.936*floor(pos.x/fe));\n    \n    fx = 45.8*random(1.885*floor(pos.x/fe)); \n    pxd = fe*tdd*(1. + 0.45*0.5*sin(pos.y*1.3 + 27.*fx) + 0.3*0.5*sin(pos.y*3.7 + 74.*fx) - 0.25*0.5*sin(pos.y*9.48 + 112.*fx));\n    pos.x+= pxd;\n    \n    vsf = 0.35*tdv*sin(pos.y*4.3 + 31.*fx) - 0.4*tdv*sin(pos.y*5.7 + 58.*fx) - 0.25*tdv*sin(pos.y*8.48 + 38.*fx);\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*tdv*vsf);\n    \n    float angle = twfs*pos.y;\n    vec2 d1 = rotateVec(vec2(fr*fds, fr*fds), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_ver_small(pos, d1, 1.), map_ver_small(pos, d2, 5.)), map_ver_small(pos, -d2, 9.)), map_ver_small(pos, -d1, 13.)); \n}\n\nfloat map_s(vec3 pos)\n{  \n    vec3 pos0 = pos;\n    float fy = 132.*random(1.254*floor(pos.y/fe));\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*hsf);\n\n    pos.y+= pyd;\n    float fh = length(vec2(mod(pos.y, fe) - fe*0.6, pos.z + fr*sin((pos.x + fe*2. + fe*floor(pos.y/fe))/fe*pi))) - fr*1.1;\n \n    pos = pos0;\n    \n    float fx = 145.*random(1.936*floor(pos.x/fe));\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*vsf);\n    \n    pos.x+= pxd;\n    \n    float fv = length(vec2(mod(pos.x, fe) - fe*0.6, pos.z - fr*sin((pos.y + fe*2. + fe*floor(pos.x/fe))/fe*pi))) - fr*1.1;\n    return min(fh, fv);\n}\n\nfloat map_s2(vec3 pos)\n{\n    return mix(map_s(pos), abs(pos.z) - fr*1.1, smoothstep(14., 23., iTime));\n}\n\nfloat map(vec3 pos)\n{\n    float disth = map_hor(pos);\n    float distv = map_ver(pos);\n    return mix(min(disth, distv), map_s2(pos), gtf);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor*hr + pos;\n        \n    \tfloat dd = map(aopos);\n        \n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float o;\n    float t = -cam.z/ray.z -0.05;\n    \n  \tfor (int i = 0; i < 27; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = map(pos);\n        if (dist<0.0006 || dist>maxdist)\n        {\n            o = (abs(dist-map_ver(pos))<abs(dist-map_hor(pos))?1.:0.);\n            break;\n        }\n        t+= dist*(0.75 + float(i)*0.06);\n  \t}\n  \treturn vec2(t, o);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e, float o)\n{\n    vec2 q = vec2(0., e); //vec2(0.,distance(campos, pos)*0.0005);\n    return normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\nvec3 color_hor(vec3 norm, vec3 pos)\n{\n    vec3 col = mix(mix(mix(objcolor1, mix(objcolor1, objcolor2, smoothstep(-0.1, 0.1, sin(abs(pos.y)*3.74*50./clsize))), smoothstep(0.66, 0.665, abs(pos.y/clsize))), objcolor2, smoothstep(0.88, 0.89, abs(pos.y/clsize))), objcolor3, smoothstep(0.62, 0.621, abs(pos.y/clsize))*smoothstep(0.6508, 0.6503, abs(pos.y/clsize)));\n\n    #ifdef COL_TEXTURE\n    float txti = txti0;\n    float fx = 14.64*random(2.857*floor(pos.x/fe));\n    float fc = 1. - crv*0.5*(1. + 0.5*sin(pos.y*1.6 + 60.*fx) + 0.5*sin(pos.y*2.5 + 90.*fx) + crv*0.5*sin(pos.y*3.88 + 155.*fx));\n    \n    col*= 1.1*fc*vec3(1. - txti + txti*clamp(2.*texture(iChannel0,pos.xy*vec2(5., txtf)).r, 0., 1.));\n    #endif\n    return col;\n}\n\nvec3 color_ver(vec3 norm, vec3 pos)\n{\n    vec3 col = mix(mix(mix(objcolor1, mix(objcolor1, objcolor2, smoothstep(-0.02, 0.02, sin(abs(pos.x + 0.02)*3.74*50./clsize))), smoothstep(0.66, 0.665, abs(pos.x/clsize))), objcolor2, smoothstep(0.88, 0.89, abs(pos.x/clsize))), objcolor3, smoothstep(0.62, 0.621, abs(pos.x/clsize))*smoothstep(0.6508, 0.6503, abs(pos.x/clsize)));\n\n    #ifdef COL_TEXTURE\n    float txti = txti0;\n    float fy = 21.23*random(2.316*floor(pos.y/fe));\n    float fc = 1. - crv*0.5*(1. + 0.2*sin(pos.x*1.6 + 70.*fy) + 0.3*sin(pos.x*2.2 + 90.*fy) + 0.25*sin(pos.x*3.88 + 130.*fy));    \n\n    col*= 1.1*fc*vec3(1. - txti + txti*clamp(2.*texture(iChannel0,pos.xy*vec2(txtf, 5.)).r, 0., 1.));\n    #endif\n    return col;\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n      \n    // Diffuse shading\n    float b = abs(dot(norm, pli));\n    if (b<0.5 && norm.z<0.65 && iTime>18.4) b=1.3;\n    vec3 col = (1. - 0.35*smoothstep(14.7, 19., iTime))*lamp.intensity*ocol*(1. - difi + difi*nlcol*pow(b, tbrl));\n\n    // Specular shading\n    #ifdef SPECULAR\n    //if (dot(norm, lamp.position - pos) > 0.0)\n        col+= vec3(1., 0.7, 0.3)*nlcol*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n\t// Sub surface scattering from https://www.shadertoy.com/view/MdXSzX\n    #ifdef SS_SCATERING\n\tfloat transmission = map(pos + pl*ssstrmr)/ssstrmr;\n\tvec3 sssLight = ocol*nlcol*smoothstep(0.0,1.0,transmission);\n    col = col*(1. - sssInt) + sssInt*sssLight;\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-70., 10., 190.), vec3(1., 0.99, 0.92), 1.5, .0001);\n  lamps[1] = Lamp(vec3(70., -40., 190.), vec3(1., 1., 1.), 1.5, .0001);\n    \n  vec2 uv = fragCoord.xy;\n  uv/= iResolution.xy;\n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x/iResolution.y;\n    \n  vec3 ray =  GetCameraRayDir(uv, camdir, fov);         \n    \n  vec2 t = trace(campos, ray, maxdist);\n  float tx = t.x;\n  vec3 col;\n\n  if (tx<maxdist)\n  {\n      vec3 pos = campos + tx*ray;\n      \n      if (abs(pos.x)>clsize || abs(pos.y)>clsize)\n          return vec4(ambientColor, 1.0);\n      \n      vec3 norm = getNormal(pos, normdelta, t.y);\n\n      vec3 colh = color_hor(norm, pos);\n      vec3 colv = color_ver(norm, pos);\n      if (t.y==0.) // Horizontal\n          col = colh;\n      else // Vertical\n          col = colv;\n      col = mix(col, (colh + colv)/2., smoothstep(14., 21., iTime));\n      \n      // Shading\n      col = ambientColor*ambientint + lampsShading(norm, pos, col);\n      \n      // Ambient Occlusion\n      #ifdef SH_OA\n      col*= 1. - aoint + 1.25*aoint*vec3(calcAO(pos, norm));\n      #endif\n  }\n  else\n  {\n      // Background\n      col = ambientColor;\n  }\n      \n  return vec4(col, 1.0);\n}\n\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.5, 0.4);\n   else\n      iMouse2 = iMouse.xy;\n   float tf = pow(80.*smoothstep(0., 80., iTime), 1.9)/9.;\n   //float tf = 0.;\n   //gtf2=0.;\n   vec3 camtarget = camtarget0*(1. - gtf2);\n   campos = campos0*(1. - gtf2) + tf*vec3(-5.*cos(2.*iMouse2.x/iResolution.x + 0.4),\n                 5.*cos(1.2*iMouse2.y/iResolution.y + 1.5),\n                 5.*sin(2.*iMouse2.x/iResolution.x)*sin(1.2*iMouse2.y/iResolution.y + 1.5));\n   camdir = camtarget-campos;   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tgtf = smoothstep(5., 17., iTime);\n\tgtf2 = smoothstep(15., 55., iTime);\n    \n    setCamera();\n    \n    // Antialiasing\n    #ifdef ANTIALIASING\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dKGWW","date":"1454503043","viewed":1334,"name":"Cloth Texture Simulation","username":"TambakoJaguar","description":"I could simulate a cloth, and I think it finally got quite realistic. Sadly it needs much time to compile. There is an animation, but you can also change the perspective with the mouse.\nI now used a cheap trick to reduce moiré/aliasing.","likes":40,"published":1,"flags":0,"usePreview":1,"tags":["test","texture","cloth","fabrics","threads","woven"],"hasliked":0,"parentid":"","parentname":""}}