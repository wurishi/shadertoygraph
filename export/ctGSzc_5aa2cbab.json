{"ver":"0.1","info":{"id":"ctGSzc","date":"1700588094","viewed":47,"name":"cube moving through 4d space","username":"HoosierTransfer","description":"a cube moving through 4 dimensional space","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["4draymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.0\n#define EPSILON 0.001\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n\nvec4 rotXY(in vec4 pos, in float a){\n    return pos * mat4(\n    \tcos(a), sin(a), 0, 0,\n    \t-sin(a), cos(a), 0, 0,\n    \t0, 0, 1, 0,\n    \t0, 0, 0, 1\n    );\n}\n\nvec4 rotYZ(in vec4 pos, in float a){\n    return pos * mat4(\n    \t1, 0, 0, 0,\n    \t0, cos(a), sin(a), 0,\n    \t0, -sin(a), cos(a), 0,\n    \t0, 0, 0, 1\n    );\n}\n\nvec4 rotXZ(in vec4 pos, in float a){\n    return pos * mat4(\n    \tcos(a), 0, -sin(a), 0,\n    \t0, 1, 0, 0,\n    \tsin(a), 0, cos(a), 0,\n    \t0, 0, 0, 1\n    );\n}\n\n\nvec4 rotXU(in vec4 pos, in float a){\n    return pos * mat4(\n    \tcos(a), 0, 0, sin(a),\n    \t0, 1, 0, 0,\n    \t0, 0, 1, 0,\n    \t-sin(a), 0, 0, cos(a)\n    );\n}\n\nvec4 rotYU(in vec4 pos, in float a){\n    return pos * mat4(\n    \t1, 0, 0, 0,\n    \t0, cos(a), 0, -sin(a),\n    \t0, 0, 1, 0,\n    \t0, sin(a), 0, cos(a)\n    );\n}\n\nvec4 rotZU(in vec4 pos, in float a){\n    return pos * mat4(\n    \t1, 0, 0, 0,\n    \t0, 1, 0, 0,\n    \t0, 0, cos(a), -sin(a),\n    \t0, 0, sin(a), cos(a)\n    );\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 rotateX(vec3 p, float theta) {\n    return mat3(1.0, 0.0, 0.0, 0.0, cos(theta), sin(theta), 0.0, -sin(theta), cos(theta)) * p;\n}\n\nvec3 rotateY(vec3 p, float theta) {\n    return mat3(cos(theta), 0.0, -sin(theta), 0.0, 1.0, 0.0, sin(theta), 0.0, cos(theta)) * p;\n}\n\nvec3 rotateZ(vec3 p, float theta) {\n    return mat3(cos(theta), sin(theta), 0.0, -sin(theta), cos(theta), 0.0, 0.0, 0.0, 1.0) * p;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAt) {\n    vec3 cd = normalize(lookAt - cameraPos);\n    vec3 cr = normalize(cross(vec3(0.0, 1.0, 0.0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n    \n    return mat3(-cr, cu, -cd);\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float radius) {\n    return length(p-pos) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSquare(vec2 uv, vec2 pos, float size) {\n    uv-=pos;\n    return max(abs(uv.x), abs(uv.y)) - size;\n}\n\nfloat sdTesseract( vec4 p, vec4 b )\n{\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z, q.w))),0.0);\n}\n\nfloat sdBoundingBox( vec4 p, vec4 b, float e )\n{\n       p = abs(p  )-b;\n  vec4 q = abs(p+e)-e;\n  return min(min(min(\n      length(max(vec4(p.x,q.y,q.z,q.w),0.0))+min(max(p.x,max(q.y,max(q.z, q.w))),0.0),\n      length(max(vec4(q.x,p.y,q.z,q.w),0.0))+min(max(q.x,max(p.y,max(q.z, q.w))),0.0)),\n      length(max(vec4(q.x,q.y,p.z,q.w),0.0))+min(max(q.x,max(q.y,max(p.z, q.w))),0.0)),\n      length(max(vec4(q.x,q.y,q.z,p.w),0.0))+min(max(q.x,max(q.y,max(q.z, p.w))),0.0));\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e10, 0.0);\n    \n    vec4 p4 = vec4(p, abs(sin(iTime)));\n    res = vec2(sdBoundingBox(rotXY(rotXZ(rotXU(rotYU(rotZU(p4, iTime), iTime), iTime), iTime), iTime), vec4(0.5), 0.1), 1.0);\n    return res;\n}\n\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * 0.0005;\n  return normalize(\n    e.xyy * map(p + e.xyy).x +\n    e.yyx * map(p + e.yyx).x +\n    e.yxy * map(p + e.yxy).x +\n    e.xxx * map(p + e.xxx).x);\n}\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    vec2 res = vec2(0.0);\n    float id = 0.0;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        res = map(p);\n        \n        depth+= res.x;\n        \n        id = res.y;\n        if(res.x < EPSILON || depth > MAX_DIST) break;\n    }\n    \n    return vec2(depth, id);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec2 res = rayMarch(ro, rd);\n    float d = res.x;\n    \n    vec3 p = ro + rd * d;\n        \n    vec3 normal = calcNormal(p);\n    \n    vec3 col = vec3(0.0);\n        \n    vec3 lightPosition = vec3(2, 2, 4);\n    vec3 lightDirection = normalize(lightPosition - p);\n            \n    float dif = clamp(dot(normal, lightDirection), 0., 1.);\n    \n    return vec3(dif);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    uv-=0.5;   \n    \n    uv.x*=iResolution.x/iResolution.y;\n    vec3 lp = vec3(0.0, 0.0, 0.0);\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n        \n    vec3 col = render(ro, rd);\n            \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}