{"ver":"0.1","info":{"id":"dsKfDh","date":"1698259097","viewed":53,"name":"Quasicrystal Exploration","username":"lucent","description":"Parameterizing quasicrystal animations.\n\nInspired by this article http://wealoneonearth.blogspot.com/2011/11/visual-analogue-of-shepard-tone.html#comment-form","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["quasicrystal","zoom","psychedelic","fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185307\n#define ZOOM 0.3\n#define TIME_SCALE 0.2\n#define N_OCTAVES 9\n#define BASE_FREQ 1.0\n\n#define SIGMA 0.4\n#define ROT_SPEED 0.3\n#define PHASE_SPEED 0.8\n#define PHASE_MOD_AMP 0.1\n#define ZOOM_SPEED 2.0\n\n#define BASE_DIVISIONS 7.0\n#define DIV_MULTIPLIER 1.0\n#define DIV_SPEED 0.0\n\n\nvec3 samplePalette( in float t, in vec3 amp, in vec3 bias, in vec3 freq, in vec3 phase)\n{\n    return amp*cos(TAU*(freq*t+phase)) + bias;\n}\n\nfloat spatialFreqFactor(int i) {\n    float baseValue = 1.0;\n    for (int j = 0; j < i; j++) {\n        baseValue *= 2.0;\n    }\n    return baseValue;\n}\n\nfloat gaussian(float x) {\n    return exp(-x * x / 2.0) / sqrt(TAU);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = TIME_SCALE * iTime;\n    // Normalized pixel coordinates (from -1 to 1, centered on canvas)\n    vec2 uv = ((fragCoord.xy * 2.0 - iResolution.xy) / (iResolution.y * ZOOM));\n\n    // Number of divisions around the circle\n    float numDivisions = BASE_DIVISIONS * DIV_MULTIPLIER + t*DIV_SPEED;\n    float baseFrequency = BASE_FREQ;\n    float mean = log(spatialFreqFactor(int(floor(float(N_OCTAVES) / 2.0))));\n    \n    float v = 0.0;\n    \n    // calculate frequencies at each octave\n    float freqs[N_OCTAVES];\n    float weights[N_OCTAVES];\n    float weightSum = 0.0;\n        \n    float geomScale = 1.0 * pow(2.0, -mod(ZOOM_SPEED*t, 1.0));\n        \n    for (int oct=0; oct < N_OCTAVES; oct++){\n        freqs[oct] = baseFrequency * spatialFreqFactor(oct) * geomScale;\n        weights[oct] = gaussian((log(freqs[oct]) - mean) / SIGMA);\n        weightSum += weights[oct];\n    }\n        \n    weightSum *= numDivisions;\n    \n    float phaseMod = PHASE_MOD_AMP*sin(TAU + PHASE_SPEED*t);  \n    \n    // Iterate through each plane\n    for (float i = 0.0; i < numDivisions; i += 1.0)\n    {\n        // Calculate the angle for the current division\n        float angle = (i / numDivisions) * TAU + ROT_SPEED * t;\n        float phase = (uv.x * cos(angle) + uv.y * sin(angle)) + phaseMod;\n            \n        // Calculate octaves of base frequency and add to accumulated wave       \n        for (int oct=0; oct < N_OCTAVES; oct++){\n        \n            v += cos((freqs[oct]) * phase) * weights[oct] / (1.0/sqrt(TAU));\n        }\n    }\n        \n\n    // convert v to value between 0.0 and 1.0\n    v = 0.5 * (v / weightSum + 1.0);\n    \n    // Mask to quantize to either 0.2 or 0.8 grayscale vals\n    if (v < 0.5){\n        v = 0.2;\n    } else if (v >= 0.5) {\n        v = 0.8;\n    }\n    \n    vec3 col = vec3(v,v,v);  \n    //col = samplePalette(v, vec3(0.23, 0.7, 0.27),\n    //                            vec3(0.77, 0.3, 0.3),\n    //                            (1.0/vec3(1.0, 1.0, 0.5))*0.15,\n    //                            vec3(0.5, 0.5, 0.0));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}