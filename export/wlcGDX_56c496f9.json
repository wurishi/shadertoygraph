{"ver":"0.1","info":{"id":"wlcGDX","date":"1577739285","viewed":247,"name":"Sobel corner detection","username":"eXponenta","description":"Sobel features searcher","likes":5,"published":1,"flags":34,"usePreview":0,"tags":["sobel","edge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat G(vec2 pos) {\n    return texture(iChannel1, pos).r;\n}\n\n\nconst float OFF[8] = float[8]( -1., -1., -1., 0., 1., 1., 1., 0. );\n\nfloat cornerPart(vec2 pos) {\n    vec2 s = 1./iResolution.xy;\n    \n    float diff = 0.0;\n    \n    for(int i = 0; i < 4; i++) {\n        float t = G(pos + s * vec2(OFF[i], OFF[(i + 2) % 8]));\n        float t2 = G(pos - s * vec2(OFF[ (i + 2) % 8], OFF[(i + 4) % 8]));\n        \n        diff += abs(t - t2);\n    }\n    \n    return diff / 8.;//step(cornerGap, diff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float res = cornerPart(uv);\n    \n    fragColor = \n        texture(iChannel0, uv);\n    \n    if(uv.x > 0.75 && uv.y > 0.75) {\n        fragColor += texture(iChannel1, (uv - vec2(0.75)) / 0.25  );\n    }\n    \n    fragColor.xyz +=  + vec3(res);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Blur pass\n\n\nfloat sigma = blurSigma;\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\t\n    //declare stuff\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n\n\n    fragColor = vec4(final_colour/(Z*Z), 1.0);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Sobel pass and threshold pass\n\nfloat s = 1.0;\nfloat threshold = sobelThreshold;\n\nfloat intensity(in vec4 color){\n\treturn sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z));\n}\n\nfloat th(float v) {\n    return step(threshold, v);\n}\n\nfloat sobel( vec2 center, vec2 size){\n    float stepx = size.x;\n    float stepy = size.y;\n        \n\t// get samples around pixel\n    float tleft = intensity(texture(iChannel0,center + vec2(-stepx,stepy)));\n    float left = intensity(texture(iChannel0,center + vec2(-stepx,0)));\n    float bleft = intensity(texture(iChannel0,center + vec2(-stepx,-stepy)));\n    float top = intensity(texture(iChannel0,center + vec2(0,stepy)));\n    float bottom = intensity(texture(iChannel0,center + vec2(0,-stepy)));\n    float tright = intensity(texture(iChannel0,center + vec2(stepx,stepy)));\n    float right = intensity(texture(iChannel0,center + vec2(stepx,0)));\n    float bright = intensity(texture(iChannel0,center + vec2(stepx,-stepy)));\n \n\t// Sobel masks (see http://en.wikipedia.org/wiki/Sobel_operator)\n\t//        1 0 -1     -1 -2 -1\n\t//    X = 2 0 -2  Y = 0  0  0\n\t//        1 0 -1      1  2  1\n\t\n\t// You could also use Scharr operator:\n\t//        3 0 -3        3 10   3\n\t//    X = 10 0 -10  Y = 0  0   0\n\t//        3 0 -3        -3 -10 -3\n \n    float x = tleft + 2.0*left + bleft - tright - 2.0*right - bright;\n    float y = -tleft - 2.0*top - tright + bleft + 2.0 * bottom + bright;\n    \n    return sqrt((x*x) + (y*y));\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel0, uv.xy);\n    \n\tfragColor.xyz = vec3( th( sobel(uv, s/iResolution.xy)));\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//Dialte pass\n\nfloat mode = 0.0; //delate, 0 - erode;\n\nfloat G(vec2 pos) {\n    return texture(iChannel0, pos).r;\n}\n\nfloat process(vec2 pos) {\n    vec2 s = 1./iResolution.xy;\n    \n    float summ = G(pos + vec2(0., -1.) * s)\n        + G(pos + vec2(1., -1.) * s)\n        + G(pos + vec2(1., -0.) * s)\n        + G(pos + vec2(1., 1.) * s)\n        + G(pos + vec2(0., 1.) * s)\n        + G(pos + vec2(-1., 1.) * s)\n        + G(pos + vec2(-1., 0.) * s)\n        + G(pos + vec2(-1., -1.) * s);\n   \t\n    summ /= 8.0;\n    \n    if(mode > 0.0)\n        return summ;\n    else\n        return 1. - step(summ, erodeGap);\n        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float res = process(uv);\n\n    fragColor.xyz = vec3(res);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float sobelThreshold = 0.2;\nconst float blurSigma = 3.0;\nconst float erodeGap = .4;\nconst float cornerGap = 3.2;\n","name":"Common","description":"","type":"common"}]}