{"ver":"0.1","info":{"id":"Mtdyzl","date":"1533739847","viewed":278,"name":"Sunday Morning","username":"qjcm","description":"It's early on a Sunday morning.\nThere isn't any wind yet, there will be later though.\nIt's very calm out here.\nDefinitely worth getting up so early.\nA fog horn goes off in the distance.\n","likes":7,"published":1,"flags":64,"usePreview":0,"tags":["procedural","raymarching","noise","waves","water","fog","mist"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lsBXDV","filepath":"https://soundcloud.com/user-876112150/lake","previewfilepath":"https://soundcloud.com/user-876112150/lake","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0},{"id":"MlfGRX","filepath":"https://soundcloud.com/matwhill/inertia","previewfilepath":"https://soundcloud.com/matwhill/inertia","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Sunday Morning\" by Quentin Corker-Marin, 2018\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: quentinjcm@hotmail.com\n */\n\nconst vec3 SUN_DIR = vec3(0.323768, 0.2 , -0.940721);\nconst vec3 SUN_COL = vec3(1.1, 0.9, 0.6);\nconst vec3 WATER_TINT = vec3(0.026, 0.118, 0.071);\n\n/////////////////////////////////////////\n// STRUCTS\n// question: are structs bad form? should I use in and out instead?\n/////////////////////////////////////////\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n    \nstruct sdf {\n    float d;\n    float id;\n};\n    \n\n/////////////////////////////////////////\n// TRANSFORMATIONS\n///////////////////////////////////////// \nmat3 ry( float rad  ){\n\tmat3 m;\n    m[0] = vec3(cos( rad ), 0., -sin( rad ));\n    m[1] = vec3(0.0, 1.0, 0.0);\n    m[2] = vec3(sin( rad ), 0.0, cos( rad ));\n    return m;\n}\n\n\n/////////////////////////////////////////\n// SDF OPS\n///////////////////////////////////////// \nsdf opU( sdf x, sdf y ) {\n    sdf res;\n    res.d = min( x.d, y.d );\n    float x_is_min = 1.0 - abs( sign( res.d - x.d ) );\n    res.id = mix( y.id, x.id, x_is_min );\n\treturn res;    \n}\n\nfloat rand( float seed ) {\n\treturn fract( fract( sin( seed ) ) * 1e4 );\n}\n    \n\n/////////////////////////////////////////\n// FAST 2D NOISE: https://www.shadertoy.com/view/Ms2SD1\n///////////////////////////////////////// \nfloat hash( vec2 p ) {\n\tfloat h = dot( p, vec2(127.1,311.7) );\t\n    return fract( sin( h ) * 43758.5453123 );\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f * f * (  3.0 - 2.0 * f );\n    return -1.0 + 2.0 * mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0, 0.0) ), u.x ),\n                mix( hash( i + vec2(0.0, 1.0) ), \n                     hash( i + vec2(1.0, 1.0) ), u.x ), u.y );\n}\n\n\n/////////////////////////////////////////\n// SLOWER 3D SIMPLEX NOISE: www.shadertoy.com/view/XsX3zB\n///////////////////////////////////////// \nvec3 random3( vec3 c ) {\n\tfloat j = 4096.0 * sin( dot( c, vec3(17.0, 59.4, 15.0) ) );\n\tvec3 r;\n\tr.z = fract( 512.0 * j );\n\tj *= 0.125;\n\tr.x = fract( 512.0 * j );\n\tj *= 0.125;\n\tr.y = fract( 512.0 * j );\n\treturn r - 0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nfloat snoise(vec3 p) {\n\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\t \n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\tvec4 w, d;\n\t \n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\t \n\tw = max(0.6 - w, 0.0);\n\t \n\td.x = dot(random3(s), x);\n\td.y = dot(random3(s + i1), x1);\n\td.z = dot(random3(s + i2), x2);\n\td.w = dot(random3(s + 1.0), x3);\n\t \n\tw *= w;\n\tw *= w;\n\td *= w;\n\t \n\treturn dot(d, vec4(52.0));\n}\n\n\n/////////////////////////////////////////\n// SCENE DISTANCE ESTIMATORS\n/////////////////////////////////////////\nfloat estimateWaterBase( vec3 p ) {\n    mat3 m = ry( -0.436471 );\n    p *= m;\n    float d = p.y;\n    float n1 = noise( p.xz * 0.25 );\n    d += sin( p.x / 2.0 - iTime * 0.5 ) * 0.1 * n1;\n    d += sin( p.x - iTime*1.0 ) * 0.05;\n    d += sin( p.x * 3.0 - iTime * 1.5 ) * 0.02;\n    d += sin( ( p.x + 1.0 )*3.0 - iTime*1.5 ) * 0.02;\n    d += sin( ( p.x + 2.0 )*5.0 - iTime*3.0 ) * 0.001; \n    return d;\n}\n\nfloat estimateWaterRipples( vec3 p ) {\n    mat3 m = ry( -0.436471 );\n    p *= m;\n    p.y = iTime;\n    float n1 = snoise( p * vec3(1.0, 0.0, 1.0) + vec3(0.0, iTime * 0.5, 0.0) ) * 0.008;\n    float n2o = noise( p.xz * vec2(2.0, 2.0) + vec2(iTime * 0.5, 0.0) ) * 0.5;\n    float n2 = snoise( p * vec3(1.5, 0.0, 1.5) + vec3(n2o, iTime * 0.75, 0.0) ) * 0.004;\n    float n3 = snoise( p * vec3(6.0, 0.0, 6.0) + vec3(0.0, iTime, 0.0) ) * 0.0008;\n    return ( n1 + n2 + n3);\n}\n\nfloat estimateWater( vec3 p ){\n    return estimateWaterBase( p ) + estimateWaterRipples( p ); \n}\n\nvec3 getWaterHeight( vec3 p ) {\n    ray r;\n    r.o = vec3(p.x, 10, p.z);\n    r.d = vec3(0, -1, 0);\n    int hit = 0;\n    float t;\n    for (t = 0.01; t < 5.0;){\n    \tfloat e = estimateWaterBase( r.o + r.d * t );\n        if ( e < 0.01 ){\n        \thit = 1;\n            break;\n        }\n        t += e;\n    }\n    return vec3(r.o + r.d * t);\n}\n\nfloat estimateFarBuoys( vec3 p ) {    \n    float freq = 0.15;\n    float fl_x = floor( p.x * freq );\n    float p_x = ( fl_x + rand( fl_x ) - 0.5 ) / freq;\n    vec3 buoy_p = vec3( p_x, 0.0, -14.0 + rand( fl_x + 500.0 ) * 3.0 );\n    \n    vec3 water_level = getWaterHeight( buoy_p );\n    water_level.y += 0.05;\n\n    return distance( p, water_level ) - 0.2;\n}\n\nfloat estimateMidBuoys( vec3 p ) {\n    float freq = 0.05;\n    float fl_x = floor( p.x * freq );\n    float p_x = ( fl_x + rand( fl_x ) + 0.5 ) / freq;\n    vec3 buoy_p = vec3( p_x, 0.0, -2.0 + rand( fl_x + 100.0 ) * 2.0 );\n    \n    vec3 water_level = getWaterHeight( buoy_p );\n\twater_level.y += 0.05;\n \n    return distance( p, water_level ) - 0.2;;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n    //https://iquilezles.org/articles/distfunctions\n    return length( max( abs( p ) - b, 0.0 ) ) - r; \n}\n\nfloat estimateBreakwaters( vec3 p ) {\n    vec3 mod_p = p; \n    vec3 reps = vec3( 30.0, 1.0, 1.5 );\n    vec3 floor_p = floor( p * reps - reps / 2.0 );\n    float r1 = rand( floor_p.x * floor_p.z );\n    float r2 = rand( floor_p.x * floor_p.z + 100.0 );\n    float r3 = rand( floor_p.x * floor_p.z + 110.0 );\n    mod_p.x = mod( p.x, reps.x )-reps.x / 2.0;\n    mod_p.z = mod( min( p.z, -13.0 + r3 * 0.1 ), reps.z ) - reps.z / 2.0;\n    \n    float w = mix( 0.03, 0.05, r2 );\n    vec3 b = vec3( w, 0.1 + r1 * 0.5, w );\n    return udRoundBox( mod_p, b, 0.01 );;\n}\n\nfloat estimateWaterElements( vec3 p ) { \n\tfloat far_buoys = estimateFarBuoys( p );\n    float mid_buoys = estimateMidBuoys( p );\n    float breakwaters = estimateBreakwaters( p );\n    return min( min( far_buoys, mid_buoys ), breakwaters );\n}\n\nsdf estimate( vec3 p ) {                     \n    sdf grid;\n    grid.id = 1.0;\n    grid.d = estimateWater( p );\n    \n    sdf water_elements;\n    water_elements.id = 0.0;\n    water_elements.d =  estimateWaterElements( p );\n\n    return opU( grid, water_elements );  \n}\n\nvec3 waterGrad( vec3 p ) {\n    float o = estimateWater( p );\n    float dx = estimateWater( p - vec3(0.001, 0., 0.) );\n    float dy = estimateWater( p - vec3(0., 0.001, 0.) );\n    float dz = estimateWater( p - vec3(0., 0., 0.001) );\n    \n    vec3 grad = vec3( o - dx, o - dy, o - dz );\n\treturn normalize( grad );\n}\n\n\nvec2 toNDC(vec2 frag_cord){\n    vec2 uv = frag_cord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    return uv;\n}\n\nray genRay( vec2 ndc ) {\n    //camera positioning and allignment\n    vec3 cam_pos = vec3(0.0, 1.0, 5.0);\n    vec3 cam_tar = vec3(0.0);\n    vec3 cam_up = vec3(0.0, 1.0, 0.0);\n    \n    //cam animation\n    cam_pos.y += sin( iTime * 2.0 ) * 0.05;\n    cam_tar.y += sin( ( iTime - 0.3 ) * 2.0 ) * 0.05;\n    cam_up.z += sin( iTime * 2.0 ) * 0.001;\n    \n    vec3 cam_dir = normalize(cam_tar - cam_pos);   \n    \n    //camera space s and t vectors\n    vec3 cam_s = normalize(cross(cam_dir, cam_up));\n    vec3 cam_t = cross(cam_s, cam_dir);\n    \n    cam_pos -= cam_s * iTime * 0.2;\n    \n    //intersection with \"film\" plane\n    vec3 cam_c = cam_pos + cam_dir;\n    vec3 cam_i = cam_c + cam_s * ndc.x + cam_t * ndc.y;\n    \n    //build ray\n    ray r;\n    r.o = cam_pos;\n    r.d = normalize( cam_i - cam_pos );\n    return r;\n}\n\nvec3 sphereLookUp( vec3 dir ) {\n    // a \"hdri\" for for water reflection lookup\n    //vertical fade\n    vec3 horizon_col = vec3(0.8, 0.8, 0.9);\n    vec3 up_col = vec3(0.0, 0.12, 0.9);\n    float ver_mix = dot( dir, vec3(0.0, 1.0, 0.0) ) * 2.0;\n    vec3 vert_fade = mix( horizon_col, up_col, ver_mix );\n    \n    //sun spot\n\tfloat sun_ang = dot( dir, SUN_DIR );\n    float sun_int = smoothstep( 0.7, 1.0, sun_ang ); \n    vec3 sun_spot = SUN_COL * sun_int * 2.0;\n    float sun_int_inner = smoothstep( 0.95, 1.0, sun_ang );\n    vec3 sun_spot_inner = SUN_COL * sun_int * 4.0;\n    \n\treturn vert_fade + sun_spot;\n}\n\nfloat traceRefl( ray r ){\n\tfloat t;\n    for( t = 0.01; t < 5.0; ){\n    \tfloat e = estimateWaterElements( r.o + r.d * t );\n        if( e < 0.01 ){\n        \treturn 0.0;\n        }\n        t += e;\n    }\n    return 1.0;\n}\n\nvec3 shadeWater(ray r, float t){\n    vec3 hit_p = r.o + r.d * t;\n    vec3 n = waterGrad(hit_p);\n    \n    float cosi = dot(-r.d, n);\n    vec3 refl_dir = r.d + 2.0 * cosi * n;\n    vec3 refl_col = sphereLookUp( refl_dir );\n    float refr_depth = 0.752 * cosi;\n    vec3 refr_col = mix( WATER_TINT, vec3(-0.8), clamp( refr_depth, 0.01, 0.999 ) );\n    \n    float icosi = 1.0 - cosi;\n    float rschlick = 0.02 + 0.98 * icosi * icosi * icosi * icosi * icosi;\n    \n    ray refl;\n    refl.o = hit_p;\n    refl.d = refl_dir;\n    float refl_hit = traceRefl(refl);\n\n    return mix(refr_col, refl_col * refl_hit, rschlick);\n    \n}\n\nvec3 applyFog(vec3 col, ray r, float t){\n\t//https://iquilezles.org/articles/fog\n    float fog_amount = 1.0 - exp(-t*0.18);\n    float sun_amount = max(dot(r.d, SUN_DIR) , 0.0);\n    sun_amount = sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount;\n    vec3 fog_color = mix(vec3(0.7, 0.8, 0.9), vec3(1.5, 1.4, 1.3), sun_amount);\n    return mix(col, fog_color, fog_amount);\n}\n\nvec3 renderScene( ray r ) {\n\tfloat hit = 0.0;\n    sdf e;\n    float t = 0.0;\n    for ( t = 0.001; t < 30.0; ){\n    \te = estimate( r.o + r.d * t );\n        if( e.d < 0.001 ){\n        \thit = 1.0;\n            break;\n        }\n        t += e.d;\n    } \n    vec3 out_col = mix( vec3(0.0), shadeWater( r, t ), e.id );\n    out_col = applyFog( out_col, r, t );\n    return out_col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 ndc = toNDC( fragCoord );\n    ray r = genRay( ndc );\n    vec3 c = renderScene( r );\n    float vignette = clamp( ( 1.1 - length( ndc * 0.7 ) ), 0.0, 1.0 );\n    c *= vignette;\n    c *= 0.6;\n    c = pow( c, vec3(0.4545) );\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}