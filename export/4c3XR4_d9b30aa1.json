{"ver":"0.1","info":{"id":"4c3XR4","date":"1718368838","viewed":177,"name":" Infinite Devouring 无限吞噬","username":"shadertoyjiang","description":"sunflower 2\n[url=https://www.shadertoy.com/view/lcG3zy]https://www.shadertoy.com/view/lcG3zy[/url]","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["mouse","eye","limit","sunflower","devouring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define C(n) sqrt(n)*cos((n+t)*2.4+vec2(0,11))\n\nint absi(int i){ return int(abs(float(i)));}\nint signi(int i){ return int(sign(float(i)));}\nint fb(int k)\n{\n        int v,a=1,b=1,c;\n        if(k==1)v=4;\n        for(int i=2;i<15;i++)\n        {\n               if(k==i){v=a;break;};\n               c=a; a=a+b; b=c;\n        }\n        return v;\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        O = vec4(0);\n        vec2 R = iResolution.xy,\n        u = 9.*(U+U +.1- R) / min(R.x,R.y), \n            c= vec2(0), w=c;\n        float d=0., m=0., \n              t = ceil((iTime-4.6)*60.); \n        int e=0, n=0,   \n            o = int(ceil(dot(u,u))) ;\n        //float fb[12] = float[12](0.,4., 1.,2.,3.,5.,8.,13.,21.,34.,55.,89.); \n        \n        // 根据序号求坐标 \n        // 找最近细胞，最后一轮求细胞壁\n        for(int k=1;k<5;k++)\n        {\n                m = 1e8;\n                c = C(float(o));\n                // 扫描邻居\n                for(int i=-12;i<=12;i++) \n                {\n                        n = o + fb(absi(i))*signi(i); // 细胞n是细胞o的邻居（或自身）\n                        w=C(float(n)); \n                        d = length(u - w)*.5; // 细胞核距离\n                        if(o!= n && k>3)d = abs(dot(u-(w+c)*.5, normalize(w-c)));// 细胞壁距离 \n                        if(m > d)m = d, e = n; \n                }\n                o=e; // 更新最接近\n        }\n        //O=vec4(m*6.);return;// 441 chars\n        \n        // color\n        vec4 Q = vec4(.9) -7.*exp(-2e2*abs(m-.3) * m); \n        O = vec4(1,.9-m,0,0) - 2e1*exp(-10.* abs(cos(m* (length(c)* 1. +1.) ))); //23432019 eye 15. 9.\n        d=.5*max(dot(u-c,u-c)+.6+ c.y-u.y,0.);\n        O.xy *= d;\n        Q.xy *= d;\n        \n        //if(tp==0)\n                O.x *= min(length(c*.25),1.);\n        //else \n                //O.x *= pow(min(length(u*.2),1.),sin(t/5.));\n        if(iMouse.x<R.x/2.) O += exp(-59.*m); // 抗锯齿 += -= \n        \n        m=length(u+9.*vec2(cos(t/71.),sin(t/51.))); \n        if(m<4.6)O=Q, O.z+=.08, O =sqrt(O) ; \n        d=9.*exp(-20.*abs(m-4.7));\n        Q = O;Q.xy+=d*.8;\n        O += step(.5,d)>.05? d-Q:O-O;\n\n}\n\n\n\n\n\n/*\n// 2024年4月20日\n// 2D\n\n//#define tp 0\n\n#define C(n) sqrt(n)*cos((n+t)*2.4+vec2(0,11))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        O = vec4(0);\n        vec2  R = iResolution.xy,\n              u = 9.*(U+U +.1- R) / min(R.x,R.y), \n              c= vec2(0), w=c;\n        float d=0., m=0., \n              t = ceil(iTime*60.);//*.618*.618*.618*.618;//(1.-.618)*.618;//55./89.;\n        int   e=0, n=0, i=0, k=0,\n              o = int(ceil(dot(u,u))),\n              N;\n        int fb[12] = int[12](0,4, 1,2,3,5,8,13,21,34,55,89);    //,144,233,377,610,987,1597,2584);  \n        N = 12;//fb.length();\n\n        // 根据序号求坐标      \n        // 找最近细胞，最后一轮求细胞壁\n        while(k++<4)\n        {\n                m = 1e8;\n                c = C(float(o));\n                // 扫描邻居\n                for(i=-N;i<=N;i++)         \n                {\n                        n =  o + fb[abs(i)]*sign(i); // 细胞n是细胞o的邻居（或自身）\n                        w=C(float(n));     \n                        d = length(u - w)*.5; // 细胞核距离\n                        if(o!= n && k>3)d = abs(dot(u-(w+c)*.5, normalize(w-c)));// 细胞壁距离                        \n                        if(m > d)m = d, e = n;                       \n                }\n                o=e; // 更新最接近\n        }\n        //O=vec4(m*6.);return;// 441 chars\n        \n        // color\n        vec4 Q = vec4(.9) -7.*exp(-2e2*abs(m-.3) * m);        \n        O = vec4(1,.9-m,0,0) - 2e1*exp(-10.* abs(cos(m* (length(c)* 1. +1.)  ))); //23432019  eye 15. 9.\n        d=.5*max(dot(u-c,u-c)+.6+ c.y-u.y,0.);\n        O.xy *= d;\n        Q.xy *= d;\n               \n        //if(tp==0)\n                 O.x *= min(length(c*.25),1.);\n        //else \n                 //O.x *= pow(min(length(u*.2),1.),sin(t/5.));\n        if(iMouse.x<R.x/2.)  O += exp(-59.*m); // 抗锯齿  +=  -=   \n        \n        \n        m=length(u+9.*vec2(cos(t/71.),sin(t/51.))); \n        if(m<4.6)O=Q, O.z+=.08, O =sqrt(O) ; \n        d=9.*exp(-20.*abs(m-4.7));\n        Q = O;Q.xy+=d*.8;\n        O += step(.5,d)>.05? d-Q:O-O;\n        \n}\n*/","name":"Image","description":"","type":"image"}]}