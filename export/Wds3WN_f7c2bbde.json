{"ver":"0.1","info":{"id":"Wds3WN","date":"1546789042","viewed":179,"name":"scattering sky on earth","username":"cailuming","description":"another one for  atmosphere scattering, including fbm ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","ao","rayleigh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define INNER 0.0\n#define OUTTER 40.0\n#define FAREST 150.0\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n\nvec2 sphereIntersect(vec3 o,vec3 dir,vec4 sp){\n   vec3 a = sp.xyz - o;\n   float b = dot(dir,a);\n   float d = sqrt(dot(a,a)-b*b);\n   float t = sqrt(sp.w*sp.w-d*d);\n   if(d>sp.w) return vec2(-1);\n    \n   return vec2(b-t,b+t);\n}\n\nfloat density(float h,float s){\n    return exp(-h/s);\n}\n    \nfloat phase_ray(float c){\n    return 3.0/16.0/PI*(1.+c*c);    \n}\n\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn ( 3.0 / 8.0 / PI ) * a / b;\n}\n\n\nfloat optics(vec3 hi,vec3 lw,float s){\n    vec3  a   = hi-lw;\n    vec3  d   = normalize(a);\n    vec3  c   = lw;  \n    float ret = 0.0;\n    float smp = 8.0;\n    float t   = 0.0;\n    \n    float stp = length(a)/smp;\n    \n    for(float i=0.0;i<smp;i++){\n       t= c.y-INNER;\n       \n       if(t<=0.){\n           break;\n       }\n       ret+= density(t*0.5,s);\n       c+=d*stp; \n    }\n    \n    return ret*stp;\n}\n\n\nmat2 rot2D(float a){\n   float c = cos(a);\n   float s = sin(a);\n   return mat2(c,s,-s,c); \n}\n\nmat3 rot3D(vec4 a){\n   float c  = cos(a.w);\n   float s  = sin(a.w);\n   float rc = 1.0-c;\n   \n   float m00 = a.x*a.x*rc+c;\n   float m01 = a.y*a.x*rc+a.z*s;\n   float m02 = a.z*a.x*rc-a.y*s;\n   \n   float m10 = a.x*a.y*rc-a.z*s;\n   float m11 = a.y*a.y*rc+c;\n   float m12 = a.z*a.y*rc+a.x*s;\n   \n   float m20 = a.x*a.z*rc+a.y*s;\n   float m21 = a.y*a.z*rc-a.x*s;\n   float m22 = a.z*a.z*rc+c;\n    \n   return mat3(\n      m00,m01,m02,\n      m10,m11,m12,\n      m20,m21,m22\n   ); \n}\n\n\nfloat hash1(float x){\n    \n\treturn fract(sin(dot(vec2(x),vec2(PI,2.73461)))*327672.0);\n}\n\nfloat hash1(vec2 v){\n   return fract(sin(dot(v,vec2(1623713,1241701)))*3267137.0);\n}\n\nvec2 hash2(vec2 v){\n   float x =  fract(sin(dot(v,vec2(1.4623713,0.734566)))*100000.0*PI);\n    \n   float y =  fract(sin(dot(v,x*vec2(0.923713,-0.7441701)))*100000.0*PI);\n    \n   return vec2(x,y);\n}\n\nvec3 hash3(vec3 v){\n   float x =  fract(sin(dot(v,vec3(1.4623713,0.734566,0.334566)))*100000.0*PI);\n   float y =  fract(sin(dot(v,x*vec3(0.923713,-0.7441701,-0.334566)))*100000.0*PI);\n   float z =  fract(sin(dot(v,y*vec3(-0.223713,1.4441701,0.634566)))*100000.0*PI);\n    //*rot3D(vec4(0.5,0.5,0,iTime*0.1+y))\n   return vec3(x,y,z);\n}\n\n\nfloat curve_cubic(float v){\n   return v*v*(3.0-2.0*v);\n}\n\nvec2 curve_cubic(vec2 v){\n   return v*v*(3.0-2.0*v);\n}\n\nfloat curve_pro(float v){\n   return v*v*v*(v*(6.0*v-15.0)+10.0);\n}\n\nvec2 curve_pro(vec2 v){\n   return v*v*v*(v*(6.0*v-15.0)+10.0);\n}\n\nvec3 curve_pro(vec3 v){\n   return v*v*v*(v*(6.0*v-15.0)+10.0);\n}\n\n\nvec3 getColor(float v){\n   float r = cos((v-0.78)*PI*1.66);\n   float g = cos((v-0.58)*PI*1.66);\n   float b = cos((v-0.28)*PI*1.66);\n   return vec3(r,g,b); \n}\n\n    \nfloat noise1D(float x){\n   float p  = floor(x);\n   float f  = fract(x); \n    \n   float v1 = hash1(p);\n   float v2 = hash1(p+1.0);\n    \n   f  = curve_pro(f);\n    \n   return mix(v1,v2,f); \n}\n\nfloat noise2D(vec2 v){\n   vec2 p = floor(v);\n   vec2 f = fract(v); \n   vec2 e = vec2(1,0);\n    \n   vec2 h00 = hash2(p);\n   vec2 h01 = hash2(p+e.xy);\n   vec2 h10 = hash2(p+e.yx);\n   vec2 h11 = hash2(p+e.xx);\n     \n   float d00 = dot(h00,f);\n   float d01 = dot(h01,f-e.xy);\n   float d10 = dot(h10,f-e.yx);\n   float d11 = dot(h11,f-e.xx);\n    \n   f = curve_pro(f);\n   \n   return mix(mix(d00,d01,f.x),mix(d10,d11,f.x),f.y); \n}\n\n\n// 3d noise ,inspired by iq ,but without the gradient\nfloat noise3D(vec3 p){\n   vec3 x000 = floor(p);\n   //evaluate the eight corner first \n   vec3 x001 = x000+vec3(0,0,1);\n   vec3 x010 = x000+vec3(0,1,0);\n   vec3 x011 = x000+vec3(0,1,1);\n   \n   vec3 x100 = x000+vec3(1,0,0);\n   vec3 x101 = x000+vec3(1,0,1);\n   vec3 x110 = x000+vec3(1,1,0);\n   vec3 x111 = x000+vec3(1,1,1);\n   \n   // get the interpolation coe  \n   vec3 cp  = fract(p);\n   \n   //get each random vector of the corner \n   vec3 v000 = hash3(x000);\n   vec3 v001 = hash3(x001);\n   vec3 v010 = hash3(x010);\n   vec3 v011 = hash3(x011);\n   vec3 v100 = hash3(x100);\n   vec3 v101 = hash3(x101);\n   vec3 v110 = hash3(x110);\n   vec3 v111 = hash3(x111);\n    \n   //do the projection \n   float d000 = dot(v000,p-x000);\n   float d001 = dot(v001,p-x001);\n   float d010 = dot(v010,p-x010);\n   float d011 = dot(v011,p-x011);\n    \n   float d100 = dot(v100,p-x100);\n   float d101 = dot(v101,p-x101);\n   float d110 = dot(v110,p-x110);\n   float d111 = dot(v111,p-x111);\n    \n   //interpolation curve vector \n   cp = curve_pro(cp);\n   \n    \n   d000 = mix(d000,d010,cp.y);\n   d100 = mix(d100,d110,cp.y);\n   \n   d001 = mix(d001,d011,cp.y);\n   d101 = mix(d101,d111,cp.y);\n   \n   return mix(mix(d000,d100,cp.x),mix(d001,d101,cp.x),cp.z);\n    \n}\n//fbm stuffs\nfloat fbm1(float x){\n   float freq = 0.5;\n   float am   = 1.0;\n   float ret  = 0.0;\n   \n   for(int i=0;i<5;i++){\n       ret+=noise1D(x*freq)*am;\n       freq *=2.0;\n       am   *=0.5;\n   }\n    \n   return ret; \n}\n\nfloat fbm2(vec2 x){\n   float freq = 0.5;\n   float am   = 5.0;\n   float ret  = 0.0;\n    \n   for(int i=0;i<9;i++){\n       ret+=noise2D(x*freq)*am;\n       \n       freq *=2.;\n       am   *=.4;\n       x    *=rot2D(freq);\n   } \n    \n   return ret; \n}\n \nfloat getHeight(vec2 p){\n   \n  return fbm2(p.xy*0.1)*1.4;\n}\nvec2 ground(vec3 p ,vec3 c){\n    p-=c;\n    float m = getHeight(p.xz)+fbm1(p.y*0.9+noise1D(p.x*.1)*0.5)*1.2;\n    return vec2(p.y-m,0);\n}\n \nvec2 sphere(vec3 p ,vec3 c){\n    p-=c;\n    return vec2(length(p)-4.0,1);\n}\n\n\nvoid cmp(inout vec2 a,vec2 b){\n    a = a.x>b.x?b:a;\n}\n\nvec2 map(vec3 p){\n   vec2 res = vec2(1000.0);\n    \n   cmp(res,ground(p,vec3(0)));\n   //cmp(res,sphere(p,vec3(1,1,40)));\n     \n   return res;\n}\n\nfloat occlusion(vec3 p,vec3 norm){\n    float scalor=0.7;\n    \n    float occ =0.;\n    float sm = 4.0;\n    for(float i=0.;i<sm;i++){\n       float k= i/sm;\n       k*=scalor;\n       float d=map(p+k*norm).x;\n       occ+= pow(0.5,i*0.3)*(k-d);\n    }\n    occ=1.-clamp(occ,0.,1.);\n    return occ;\n}\n\n\nvec3 grad(vec3 p){\n   float m = map(p).x;\n   vec2 e = vec2(1,0)*0.01; \n   return normalize(vec3(map(p+e.xyy).x-m,map(p+e.yxy).x-m,map(p+e.yyx).x-m)); \n}\n\nvoid atmosphere(inout vec3 col,vec3 sp,vec3 endp,vec3 lp){\n    float t_ray0 = 0.0;\n    float t_ray1 = 0.0;\n    float t_mie0 = 0.0;\n    float t_mie1 = 0.0;\n    float d_ray  = 0.0;\n    float d_mie  = 0.0;\n    float g = -0.9;\n    float h_ray  = 10.5;\n    float h_mie  = h_ray*0.225;\n    \n    vec3 kray = vec3(5.5e-2,13e-2,22.4e-2);\n    vec3 kmie = vec3(20e-4);\n\n    vec3  cmul   = vec3(0.0);\n    vec3  sray   = vec3(0.0);\n    vec3  smie   = vec3(0.0);\n    vec3  ld     = normalize(lp);\n    vec3  d      = normalize(endp-sp);\n    \n    float c      = dot(-d,ld);\n    float intens = 2.7;\n    float s = 0.11;\n    \n    \n    float smp    = 16.0;\n    float t      = 0.0;\n    vec3  p      = vec3(0);\n    float stp    = length(endp-sp)/smp;\n    \n    vec2 v1 = sphereIntersect(lp,-ld,vec4(0,0,0,OUTTER));\n    \n    for(float i=0.0;i<smp;i++){\n       p = sp+d*t;\n       if(p.y<0.) break; \n       d_ray = density(p.y,h_ray)*stp;\n       d_mie = density(p.y,h_mie)*stp;\n        \n       t_ray0 += d_ray;\n       t_mie0 += d_mie;\n        \n       t_ray1 = optics(OUTTER*ld,p,h_ray);\n       t_mie1 = optics(OUTTER*ld,p,h_mie);\n          \n       cmul = (t_ray0+t_ray1)*kray+(t_mie0+t_mie1)*kmie*0.;\n       cmul = exp(-cmul*s);\n       sray += cmul*d_ray;\n       smie += cmul*d_mie;\n           \n       t+=stp; \n    }\n    \n    col+= (sray*kray*phase_ray(c)+smie*kmie*phase_mie(g,c,c*c))*intens;\n}\n void shading(inout Ray r,vec3 lp,inout vec3 col,vec2 res){\n    vec3 p = r.o+r.d*res.x;\n    vec3 n = grad(p);\n    vec3 ld = normalize(lp);\n    float nl = smoothstep(-1.0,1.,dot(ld,n));\n    float oc = occlusion(p,n);    \n    float hv = dot(normalize(-ld+r.d),n);\n    hv = 0.3+0.7*(1.0-pow(hv,5.0)); \n    atmosphere(col,r.o,p,lp);\n    if(res.x<FAREST){\n   \n        if(res.y==0.0){\n           float v = fbm2(p.xz*0.1); \n           col = mix(col,(nl*oc)*getColor(nl*0.08+0.66),nl+1.0-exp(-res.x*0.1));\n            \n        }  \n    } \n}\n    \nvoid rayMarch(in Ray r,vec3 lp,inout vec3 col,inout vec2 res){\n    float t =0.0;\n    vec2 h  = vec2(0);\n    vec3 p  = vec3(0);\n     \n    for(int i=0;i<64;i++){\n       p = r.o+r.d*t;\n       h = map(p);\n      \n       if(t>=FAREST){\n           t=FAREST;\n  \n           break;\n       }\n        \n       if(h.x<=0.0005){\n                 \n           break;\n       } \n       \n        t+=h.x; \n    }\n     \n    res = vec2(t,h.y);\n}\n       \nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n    vec3 look = normalize(tar-eye);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up   = normalize(cross(look,right));\n    \n    r.o = eye;\n    r.d = normalize(uv.x*right + uv.y*up+ look);\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv- vec2(0.5);\n    cuv.x*=iResolution.x/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    float a = PI*0.44;\n    float t = sin(iTime*0.5);\n  \n \n    vec3 lp  = vec3(0,50.0*cos(a),100.0*sin(a));\n    vec3 eye = vec3(0,4.,-9.0);\n    vec3 tar = vec3(0,3.,1);\n    eye*=rot3D(vec4(normalize(vec3(0,1,0)),iTime*0.1));\n    vec2 res = vec2(0);\n    \n    Ray r;\n    setCamera(r,eye,tar,cuv);\n    rayMarch(r,lp,col,res);\n    shading(r,lp,col,res);\n    \n    col = smoothstep(0.,1.,col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}