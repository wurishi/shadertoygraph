{"ver":"0.1","info":{"id":"WdSyDh","date":"1586749492","viewed":97,"name":"Octahedralis I","username":"sl2c","description":"Another circle inversion fractal shader.  This one has six \"base\" circles and eight reflection circles.  The \"I\" in the title is because this is definitely not the last time I work with this fractal.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circles","hyperbolic","projective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \nvec3 color(vec2 z) {\n    float s = 0.4142135623730951; // silver ratio\n    vec3[3] colors;\n    colors[0]=vec3(1.0,0.0,0.0);\n    colors[1]=vec3(0.0,1.0,0.0);\n    colors[2]=vec3(0.0,0.0,1.0);\n    float r2;\n    bool fl = false;\n    for(int i=0;i<100;i++) {\n        if (z.x < 0.0) {\n            z.x = -z.x;\n            colors[2]=1.0-colors[2];\n        }\n        if (z.y < 0.0) {\n            z.y = -z.y;\n            colors[1]=1.0-colors[1];\n        }\n        r2 = dot(z,z);\n        if (r2 > 1.0) {\n            z /= r2;\n            colors[0]=1.0-colors[0];\n        }\n        z -= vec2(s,s);\n        r2 = dot(z,z);\n        if (r2 < s * s) {\n            z *= s * s / r2;\n            fl = !fl;\n            z += vec2(s,s);\n        } else {\n            z += vec2(s,s);\n            vec3 col;\n            if (dot(z,z) < s * s) {\n                col = colors[0];\n            } else if (z.x < z.y) {\n                col = colors[1];\n            } else {\n                col = colors[2];\n            }\n            if (fl) col *= 0.5;\n            return col;\n        }\n    }\n    if (z.x < 0.0) {\n        z.x = -z.x;\n        colors[2]=1.0-colors[2];\n    }\n    if (z.y < 0.0) {\n        z.y = -z.y;\n        colors[1]=1.0-colors[1];\n    }\n    r2 = dot(z,z);\n    if (r2 > 1.0) {\n        z /= r2;\n        colors[0]=1.0-colors[0];\n    }\n    float zz = 0.5 * (1.0 - dot(z,z));\n    if (zz > z.x && zz > z.y) {\n        return colors[0] * 0.75;\n    }\n    if (z.y > z.x) {\n        return colors[1] * 0.75;\n    }\n    return colors[2] * 0.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;   \n    uv = vec2(uv.x+uv.y,uv.x-uv.y);\n    \n    float period = 2.2924316695611773;\n    \n    float t = mod(iTime * 0.5+3.0,period * 2.0);\n    bool r = false;\n    \n    if (t > period * 1.0) {\n        t -= period * 2.0;\n    }\n    \n    uv *= exp(-t);\n    \n    uv += vec2(0.2886751345948129,0.2886751345948129);\n    uv /= dot(uv,uv);\n    uv += vec2(-1.3660254037844382,-1.3660254037844382);\n\n    fragColor = vec4(color(uv),1.0);\n}","name":"Image","description":"","type":"image"}]}