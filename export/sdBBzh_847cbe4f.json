{"ver":"0.1","info":{"id":"sdBBzh","date":"1645683040","viewed":226,"name":"Fast blurred polygon with hole","username":"carrot","description":"Fast Gaussian-blurred polygon with holes.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","gaussianblur","polygon","hole"],"hasliked":0,"parentid":"fdffDS","parentname":"Fast Gaussian-blurred polygon"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nI, Michel Rouzic, have been researching this problem for years and at last I have just (in February 2022) solved it.\nThis directly calculates, in one pass, a visually fully accurate approximation of a Gaussian-blurred polygon,\nin this case a polygon with 4 (easy to modify) sides which can be concave or convex.\nThis works by calculating the Gaussian-weighted area of the polygon around the coordinate of the pixel being rendered.\nEach side of the polygon forms a subtriangle with the pixel, and each subtriangle is split into two right triangles.\nTheir weights are calculated mainly according to the approximation of an integral, and depending on the angle at the\npixel some other operations have to be done. Then all the weights are added together and multiplied by the colour.\n\nThe Gaussian blurring gets no smaller than 0.8 pixels wide because that's what I consider the best Gaussian blurring\nfor a sharp antialiasing. I made this so that I could render perfectly antialiased polygons (even on the CPU)\nefficiently without any multisampling. I think this method is a pretty big deal due to how efficient and practically\nperfect it is.\n\nBonuses include a fast approximation of the error function (erf) which you can reuse whenever you need erf() and \na way to convert linear pixel values to sRGB without using pow() (although I'm not sure this is more efficient).\n*/\n#define SIZE_I 20\n\nfloat sq(float x)\n{\n    return x * x;\n}\n\nfloat erf_fast(float x)\n{\n\tfloat y, xa = abs(x);\n\n\t// erf(x) ~= 1 - exp(<polynomial>) for x >= 0, max error 1/4249\n\t// 2 mad, 1 mul, 1 +-, 1 copysign, 1 exp = ~9 FR\n\ty = ((-0.06388*xa - 0.66186)*xa - 1.123613)*xa;\n\ty = 1. - exp(y);\n\ty *= sign(x);\n\n\treturn y;\n}\n\nfloat erf_right_triangle_acute_integral(float x, float y)\n{\n\tfloat x2 = x*x, y2 = y*y;\n\tfloat v = (((((-1.6663128e-05*y2 + 5.104393e-06)*x2 +\n\t\t\t0.0005496131*y2 - 5.30433e-05)*x2 +\n\t\t\t(0.0001584783*y2 - 0.00741157237)*y2 - 0.0018265954)*x2 +\n\t\t\t(-0.003881739*y2 + 0.0523013844)*y2 + 0.04582956)*x2 +\n\t\t\t((-0.00368418*y2 + 0.03692744)*y2 - 0.1996548)*y2 - 0.50360028)*x2 +\n\t\t\t((-0.0012717*y2 - 0.0101518)*y2 + 0.0109084)*y2 - 1.836892;\n\treturn exp(v) * x2 * y;\t// 25 FR\n}\n\nfloat calc_right_triangle_pixel_weight(vec2 rp)\n{\n\tvec2 rpa;\n\tbool use_obtuse;\n\tfloat slope, acute, obtuse;\n\n\trpa = abs(rp);\n\n\t// Pick method\n\tuse_obtuse = rpa.y > rpa.x;\n\tif (use_obtuse)\t\t\t// if we use the obtuse method\n\t{\n\t\t// Swap axes\n\t\tfloat t = rp.x;\n\t\trp.x = rp.y;\n\t\trp.y = t;\n\t}\n\n\t// Prepare the arguments (slope and clamped x)\n\tslope = abs(rp.x) < 1e-5 ? 0. : rp.y / rp.x;\n\tslope = clamp(slope, -1., 1.);\n\trp.x = clamp(rp.x, -3., 3.);\n\n\tacute = erf_right_triangle_acute_integral(rp.x, slope);\n\tobtuse = 0.25 * erf_fast(rp.y) * erf_fast(rp.x) - acute;\n\tacute = abs(acute) * sign(slope);\n\tobtuse = abs(obtuse) * sign(slope);\n\n\treturn use_obtuse ? obtuse : acute;\n}\n\nfloat calc_subtriangle_pixel_weight(vec2 p0, vec2 p1)\n{\n\tvec2 rot, r0, r1, np;\n\tfloat weight;\n\n\t// Rotate points\n\trot = normalize(p1 - p0);\n\tr0.x = rot.x*p0.y - rot.y*p0.x;\n\tr0.y = rot.x*p0.x + rot.y*p0.y;\n\tr1.x = rot.x*p1.y - rot.y*p1.x;\n\tr1.y = rot.x*p1.x + rot.y*p1.y;\n\n\t// Calc weights\n\tweight = calc_right_triangle_pixel_weight(r1);\n\tweight -= calc_right_triangle_pixel_weight(r0);\n\n\treturn weight;\n}\n\nfloat draw_tetragon(vec2 p[SIZE_I], int start, int end, float rad, vec2 pf)\n{\n\tfloat weight = 0.;\n    \n\t// Transform polygon coordinates\n    for (int i = start; i < end; i++) {\n        p[i] = (p[i] - pf) * rad;\n    }\n\n\t// Calculate weight for each subtriangle\n    for (int i = start; i < end; i++) {\n        if (i == end - 1) {\n            weight += calc_subtriangle_pixel_weight(p[i], p[start]);\n        } else {\n            weight += calc_subtriangle_pixel_weight(p[i], p[i+1]);\n        }\n    }\n\n\treturn weight;\n}\n\nfloat lsrgb(float l)\t// converts a [0.0, 1.0] linear value into a [0.0, 1.0] sRGB value\n{\n\tfloat x, line, curve;\n\n\t// 13 FR every time + 2 FR once\n\tline = l * 12.92;\t// 1 FR\n\tx = sqrt(l);\t// 4 FR\n\tcurve = ((((0.455*x - 1.48)*x + 1.92137)*x - 1.373254)*x + 1.51733216)*x - 0.0404733783;\t// 5 FR + 2 FR once, error 0.145 sRGB units\n\n\treturn l <= 0.0031308 ? line : curve;\t// 3 FR\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Clockwise means fill\n    vec2 rp, p[SIZE_I] = vec2[] ( vec2(200., 200.), vec2(200., -200.), vec2(-200., -200.), vec2(-200., 200.),\n    vec2(50., 50.), vec2(50., 150.), vec2(150., 150.), vec2(150., 50.),\n    vec2(50., -150.), vec2(50., -50.), vec2(150., -50.), vec2(150., -150.),\n    vec2(-100., 0.), vec2(-20., -180.), vec2(-100., -100.), vec2(-180., -180.),\n    vec2(-150., 50.), vec2(-150., 150.), vec2(-50., 150.), vec2(-50., 50.));\n    \n    // Pixel to world coordinates\n    vec2 uv = fragCoord-iResolution.xy*0.5;\n    \n    \n    // Tetragon rotation\n    float th = iTime * 6.2831853 / 40.;\n    float costh = cos(th);\n    float sinth = sin(-th);\n    \n    for (int i=0; i < SIZE_I; i++)\n    {\n        rp.x = p[i].x * costh - p[i].y * sinth;\n        rp.y = p[i].x * sinth + p[i].y * costh;\n        p[i] = rp;\n    }\n    \n\n    // Varying blurriness\n    float rad = sq(1.-abs(cos(iTime * 6.2831853 / 16.))) * 800.;\n    rad = length(vec2(rad, 0.8));\n\n    // Time varying pixel color\n    vec3 pv = vec3(1.);\n    pv *= (draw_tetragon(p, 0, 4, 1.0/rad, uv) - draw_tetragon(p, 4, 8, 1.0/rad, uv) - draw_tetragon(p, 8, 12, 1.0/rad, uv)\n    - draw_tetragon(p, 12, 16, 1.0/rad, uv) - draw_tetragon(p, 16, 20, 1.0/rad, uv));\n\n    // Output to screen\n    fragColor = vec4(lsrgb(pv.r), lsrgb(pv.g), lsrgb(pv.b), 1.);\n}","name":"Image","description":"","type":"image"}]}