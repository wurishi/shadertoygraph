{"ver":"0.1","info":{"id":"wssyDs","date":"1585910845","viewed":94,"name":"Kaleidoscopic Fractal","username":"kruzifix","description":"Based on http://roy.red/folding-the-koch-snowflake-.html","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Source Material:\n// Great source for all kinds of computer graphics stuff: https://iquilezles.org/\n// Fractals: http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\n\n// Videos:\n// Ray marching setup and HDR colors: https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n// SDF maths: https://www.youtube.com/watch?v=sl9x19EnKng\n\nconst float PI = 3.141592;\n\nvec2 fold(in vec2 p, in float angle)\n{\n    vec2 n = vec2(cos(angle), sin(angle));\n    p -= 2.0 * min(0.0, dot(p, n)) * n;\n    return p;\n}\n\nvec3 fold(vec3 p)\n{\n    float t = iTime;\n    p.xy = fold(p.xy, -PI / 3.0 - cos(t * 0.5) * 0.1);\n    p.xy = fold(p.xy, PI / 3.0);\n    p.yz = fold(p.yz, -PI / 6.0 + sin(t * 0.4) * 0.022);\n    p.yz = fold(p.yz, +PI / 6.0);\n    \n    return p;\n}\n\nvec3 curve(vec3 p)\n{\n    for (int i = 0; i < 11; ++i)\n    {\n        p *= 2.0;\n        p.x -= 2.6;\n        p = fold(p);\n    }\n    \n    return p;\n}\n\n// Signed distance function that describes the scene\nfloat sceneSDF(vec3 pos)\n{\n    pos.x += 1.7;\n    pos = curve(pos);\n    \n    return length(pos * 0.0004) - 0.0006;\n}\n\n// Approximates the normal of the surface at the given position\n// by calculating the gradient of the scene SDF\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n    return normalize(vec3(\n        sceneSDF(pos + e.xyy) - sceneSDF(pos - e.xyy),\n        sceneSDF(pos + e.yxy) - sceneSDF(pos - e.yxy),\n        sceneSDF(pos + e.yyx) - sceneSDF(pos - e.yyx)));\n}\n\n// Returns the distance to scene surface.\n// If the ray hit nothing this returns -1.0\nfloat rayMarchScene(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; ++i)\n    {\n        vec3 pos = rayOrigin + rayDir * t;\n        \n        float dist = sceneSDF(pos);\n        t += dist;\n        if (dist < 0.001)\n            break;\n        if (t > 100.0)\n            return -1.0;\n    }\n    \n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    //vec2 mouse = vec2(0.5, 1.0);\n    float time = mouse.x * 6.28;//iTime * 0.2;\n    float cameraDist = mix(1.0, -0.1, mouse.y);\n    \n    vec3 rayOrigin = vec3(cos(time), 0.1, sin(time)) * cameraDist;\n    vec3 lookAtPos = vec3(0.2, -0.3, 0.0);\n    \n    vec3 forward = normalize(lookAtPos - rayOrigin);\n    vec3 right = cross(forward, vec3(0.0, 1.0, 0.0));\n    vec3 up = cross(right, forward);\n    \n    vec3 rayDir = normalize(forward + right * uv.x + up * uv.y);\n    \n    float t = rayMarchScene(rayOrigin, rayDir);\n    \n    // Skybox color\n    vec3 skyCol = vec3(0.3, 0.5, 0.4) - rayDir.y * 0.3;\n    vec3 col = skyCol;\n    if (t > 0.0)\n    {\n        vec3 surfacePos = rayOrigin + rayDir * t;\n        vec3 normal = calcNormal(surfacePos);\n        \n        float fogStart = 0.3;\n        float fogEnd = 1.0;\n        float fog = smoothstep(fogStart, fogEnd, t);\n        \n        vec3 sunDir = normalize(vec3(-0.8, 0.4, 0.3));\n        float sunDiffuse = clamp(dot(normal, sunDir), 0.0, 1.0);\n        float sunShadow = step(rayMarchScene(surfacePos + normal * 0.0001, sunDir), 0.0);\n        float skyDiffuse = clamp(0.5+0.5*dot(normal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        \n        col = vec3(1.8, 1.0, 0.7) * sunDiffuse;\n        col *= mix(0.5, 1.0, sunShadow);\n        \n        col = mix(col, skyCol, fog);\n    }\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}