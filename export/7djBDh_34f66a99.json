{"ver":"0.1","info":{"id":"7djBDh","date":"1646161391","viewed":334,"name":"rocks pbr","username":"kaylent","description":"You can use your mouse.\nAn implementation of PBR,  Parallax Mapping, parallax self shadows, close ambient occlusion, far ambient occlusion.\n(updated version: https://www.shadertoy.com/view/Nsdyzf)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["rocks","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\n///////////////////////<CHANGE IT>///////////////////////\n//parallax self shadows\n#define lightSourceRadius 0.5\n\n//ambient occlusion\n#define numRotateStepAO 10;\n#define numDistanceStepAO 10;\n#define maxDistanceAO 0.015;\n#define expStrengthAO 3.\n\n//shading\n#define heightCoef 10.\n\nconst vec3 albedo = vec3(0.7f,0.7f,0.8f);\nconst float metallic = 0.9f;\nconst float roughness = 0.10f;\nconst float lightStrength = 8.0f;\n///////////////////////</CHANGE IT>///////////////////////\nvec3 lightPosition = vec3(0.,0.,0.);\n\n\nvec3 getLo_IBL(vec3 N, vec3 V, vec3 H);\nvec3 BRDF_DL(vec3 N, vec3 V, vec3 L, vec3 H);\nfloat getSelfShadow(vec2 displacedTexCoords, vec3 lightPos, vec3 pixelPosition, int numOfSamplesPerAxis);\nfloat AmbientOcclusion(vec2 texCoords);\nvec3 HDR(vec3 inColor);\nfloat summFor(int a);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPosition = vec3(iMouse.xy/ iResolution.xy, 1.0f);\n    vec3 cameraPosition = vec3(0.5f, 0.5f, 0.5f);    \n    vec2 uv = fragCoord/iResolution.y*2.;    \n    vec3 pixelPosition = vec3(fragCoord/iResolution.xy, 0.0f);    \n    vec3 lightDir = normalize(lightPosition - pixelPosition );\n    vec3 viewDir = normalize(cameraPosition - pixelPosition );    \n    float shadowMultiplier = getSelfShadow(uv, lightPosition, pixelPosition, 11);\n    \n    /////////////////////////////////////////////////\n    ////calculate normal/////////////////////////////\n    /////////////////////////////////////////////////\n    vec3 vector1;\n    vec3 vector2;\n    vec3 normal;\n    float deltaHeight;\n    float step = 1.0f/512.0f;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x+step, uv.y)).x - texture(iChannel0, vec2(uv.x-step, uv.y)) ).x * heightCoef;\n    vector1.x = 1.0;\n    vector1.y = 0.0f;\n    vector1.z = deltaHeight;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x, uv.y+step)).x - texture(iChannel0, vec2(uv.x, uv.y-step)) ).x * heightCoef;\n    vector2.x = 0.0f;\n    vector2.y = 1.0;\n    vector2.z = deltaHeight;\n    \n    normal = normalize(cross(vector1, vector2));\n    \n    //////////////////////////////////////////////\n    ////PBR///////////////////////////////////////\n    //////////////////////////////////////////////\n    float AO = AmbientOcclusion(uv);\n    vec4 lightColor = vec4(1., 1., 1., 1.0f)*lightStrength;\n    float gamma = 2.2f;\n\n    vec3 halfviewDir = normalize(lightDir + viewDir);\n    \n    float lightDistance = distance(lightPosition, pixelPosition);\n    float attenuation = 1.0f/lightDistance/lightDistance;\n    vec3 radiance = lightColor.xyz*attenuation;\n    \n    float NdotL = max(dot(normal, lightDir), 0.0); \n    vec3 Lo = getLo_IBL(normal, viewDir, halfviewDir);\n    Lo+=BRDF_DL(normal, viewDir, lightDir, halfviewDir)*radiance*NdotL;\n    \n    fragColor = vec4((Lo*shadowMultiplier)* AO, 1.0f);\n        \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0f/gamma));;\n    fragColor.xyz = HDR(fragColor.xyz);\n    \n    //light source visualization for tests/////////////////////////////////\n    if (distance(lightPosition.xy*iResolution.xy, fragCoord.xy) < 6.){\n        fragColor = vec4(1.0f, 0.0f,0.0f,1.0f);\n    }\n    \n}\n\n    \n//////////////////////////////////////////////\n////IBL///////////////////////////////////////\n//////////////////////////////////////////////\n\nvec3 fresnelSchlick_IBL(float cosTheta, vec3 F0){\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat DistributionGGX_IBL(vec3 N, vec3 H, float roughness){\n    float a = pow(roughness, 2.0);\n    float a2 = pow(a, 2.0);\n    float NdotH = max(dot(N, H), 0.0f);\n    float NdotH2 = pow(NdotH, 2.0);\n    \n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0f) + 1.0f);\n    denom = PI * pow(denom, 2.0);\n    \n    return num / denom;\n}\n\nfloat GeometrySchlickGGX_IBL(float NdotV, float roughness){\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith_IBL(vec3 N, vec3 V, vec3 L, float roughness){\n    float NdotV = max(dot(N, V), 0.0f);\n    float NdotL = max(dot(N, L), 0.0f);\n    float ggx2 = GeometrySchlickGGX_IBL(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX_IBL(NdotL, roughness);\n    \n    return ggx1 * ggx2;\n}\n\n\nfloat RadicalInverse_VdC(uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n\nvec3 ImportanceSampleGGX_IBL(vec2 Xi, vec3 N, float roughness)\n{\n    float a = roughness*roughness;\n\t\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\t\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent   = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\t\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n    return normalize(sampleVec);\n}  \n\nvec3 getFilteredEnvironmentMap(vec3 N, vec3 V)\n{\n    const uint SAMPLE_COUNT = 32u;\n    float totalWeight = 0.0;   \n    vec3 prefilteredColor = vec3(0.0);     \n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX_IBL(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        if(NdotL > 0.0)\n        {\n            prefilteredColor += texture(iChannel2, L).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n    prefilteredColor = prefilteredColor / totalWeight;\n\n    return prefilteredColor;\n}\n\nvec2 IntegrateBRDF(float NdotV)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 32u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX_IBL(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith_IBL(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nvec3 getLo_IBL(vec3 N, vec3 V, vec3 H){\n    vec3 F0 = vec3(0.74f, 0.74f, 0.74f);\n    F0 = mix(F0, albedo, metallic);\n    vec3 F = fresnelSchlick_IBL(max(dot(N, V), 0.0f), F0);\n    vec2 envBRDF = IntegrateBRDF(dot(N, V));\n    vec3 prefilteredColor = getFilteredEnvironmentMap(N, V);\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n    vec3 kD = vec3(1.0f) - F; \n    kD *= 1.0f - metallic;    \n    vec3 irradiance = texture(iChannel1, N).rgb;\n    vec3 ambient = kD * irradiance * albedo;\n    \n    vec3 fr = ambient + specular;\n    \n    return fr;\n}\n\n//////////////////////////////////////////////\n////Direct lighting///////////////////////////\n//////////////////////////////////////////////\n\nvec3 fresnelSchlick_DL(float cosTheta, vec3 F0){\n    return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);\n}\n\nfloat DistributionGGX_DL(vec3 N, vec3 H, float roughness){\n    float a = pow(roughness, 2.0);\n    float a2 = pow(a, 2.0);\n    float NdotH = max(dot(N, H), 0.0f);\n    float NdotH2 = pow(NdotH, 2.0);\n    \n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0f) + 1.0f);\n    denom = PI * pow(denom, 2.0);\n    \n    return num / denom;\n}\n\nfloat GeometrySchlickGGX_DL(float NdotV, float roughness){\n    float r = (roughness + 1.0f);\n    float k = (r*r)/8.0f;\n    \n    float num = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    \n    return num / denom;\n}\n\nfloat GeometrySmith_DL(vec3 N, vec3 V, vec3 L, float roughness){\n    float NdotV = max(dot(N, V), 0.0f);\n    float NdotL = max(dot(N, L), 0.0f);\n    float ggx2 = GeometrySchlickGGX_DL(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX_DL(NdotL, roughness);\n    \n    return ggx1 * ggx2;\n}\n\nvec3 BRDF_DL(vec3 N, vec3 V, vec3 L, vec3 H)\n{\n    vec3 F0 = vec3(0.74f, 0.74f, 0.74f);\n    F0 = mix(F0, albedo, metallic);\n    vec3 F = fresnelSchlick_DL(max(dot(H, V), 0.0f), F0);\n    float NDF = DistributionGGX_DL(N, H, roughness);\n    float G = GeometrySmith_DL(N, V, L, roughness);\n    \n    vec3 numerator = NDF*F*G;\n    float denominator = 4.0 * max(dot(N, V), 0.0f) * max (dot(N, L), 0.0f) + 0.001; // 0.001 is for no division by zero\n    vec3 specular = numerator / denominator;\n    \n    vec3 kS = F;\n    vec3 kD = vec3(1.0f) - kS;    \n    kD *= 1.0f - metallic;\n    \n    vec3 fr = kD*albedo/PI + specular;\n    \n    return fr;\n}\n\n//////////////////////////////////////////////\n////Other////////////////////////////////////\n//////////////////////////////////////////////\nfloat isShadowed(vec2 displacedTexCoords, vec3 L){\n    float depthScale = 1.;\n    float shadowMultiplier = 1.;\n    float alignFactor = dot(vec3(0.0,0.0,1.0), L);\n    float currentLayerDepth = 1.-texture(iChannel0, displacedTexCoords).x;\n    if (alignFactor>0.) {\n        const float minLayers = 8.;\n        const float maxLayers = 16.;\n        float numLayers = mix(maxLayers, minLayers, abs(alignFactor));\n        float perLayerDepth = currentLayerDepth/numLayers;\n        vec2 p = depthScale*L.xy/(numLayers*L.z);\n        vec2 currentTexCoords = displacedTexCoords + p;\n        int samplesUnderSurfaceCounter = 0;\n        currentLayerDepth -= perLayerDepth;\n        float currentDepthValue = 1. - texture(iChannel0, currentTexCoords).x;\n        while(currentLayerDepth > 0.){\n            if (currentDepthValue < currentLayerDepth){\n                shadowMultiplier = 0.;\n                break;\n            }\n            currentLayerDepth -= perLayerDepth;\n            currentTexCoords += p;\n            currentDepthValue = 1. - texture(iChannel0, currentTexCoords).x;\n        }\n        return shadowMultiplier;\n    }\n}\n\n//numOfSamplesPerAxis must be > 1\nfloat getSelfShadow(vec2 displacedTexCoords, vec3 lightPos, vec3 pixelPosition, int numOfSamplesPerAxis)\n{\n    float shadowMultiplier = 0.;\n    float sampleStepSize = lightSourceRadius * 2. / float(numOfSamplesPerAxis - 1);\n    for (int i = 0; i < numOfSamplesPerAxis; ++i)\n    {\n        vec3 lightPosX = lightPos + vec3(- lightSourceRadius + sampleStepSize*float(i), 0., 0.);\n        vec3 lightDir = normalize(lightPosX - pixelPosition );\n        shadowMultiplier += isShadowed(displacedTexCoords, lightDir);\n        \n        vec3 lightPosY = lightPos + vec3(0., -lightSourceRadius + sampleStepSize*float(i), 0.);\n        lightDir = normalize(lightPosY - pixelPosition );\n        shadowMultiplier += isShadowed(displacedTexCoords, lightDir);\n        \n        vec3 lightPosZ = lightPos + vec3(0., 0., -lightSourceRadius + sampleStepSize*float(i));\n        lightDir = normalize(lightPosZ - pixelPosition );\n        shadowMultiplier += isShadowed(displacedTexCoords, lightDir);\n    }\n    return shadowMultiplier /= float(numOfSamplesPerAxis)*3.;\n}\n\nfloat AmbientOcclusion(vec2 displacementTexCoords){\n    const int numRotateStep = numRotateStepAO;\n    const int numDistanceStep = numDistanceStepAO;\n    const float maxDistance = maxDistanceAO;\n    float rotateStep = 2.*3.14/float(numRotateStep);\n    float distanceStep = float(maxDistance)/float(numDistanceStep);\n    float multiplierAO = 1.;\n    float dMAO = 1./(float(numRotateStep)*float(numDistanceStep));\n    float fragmentDepth = 1. - texture(iChannel0, displacementTexCoords).x;\n    for (int i = 0; i<numRotateStep; ++i){\n        for(int j = 0; j<numDistanceStep; ++j){\n            vec2 pRandVec = vec2(0);\n            pRandVec.x = cos(rotateStep*float(i));\n            pRandVec.y = sin(rotateStep*float(i));\n            pRandVec *= float(j)*distanceStep;\n            if (1. - texture(iChannel0, displacementTexCoords+pRandVec).x < fragmentDepth){\n                multiplierAO-=dMAO;\n            }\n        }\n    }\n    return pow(multiplierAO, expStrengthAO);\n}\n\nfloat summFor(int a){\n    float sa = 0.;\n    for (int i = 0; i<a; ++i){\n        sa+=float(i);\n    }\n    return sa;\n}\n\nvec3 HDR(vec3 inColor){\n    return inColor/(inColor+vec3(1.));\n}","name":"Image","description":"","type":"image"}]}