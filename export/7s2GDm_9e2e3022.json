{"ver":"0.1","info":{"id":"7s2GDm","date":"1617538544","viewed":278,"name":"Infinite Spheres Ray Marching 2","username":"CustomPhase","description":"Forked to show the \"infinite-ness\" of it a bit better. The lighting artifacts are due to lazy implementation of the Distance Estimator (it only considers current cell, instead of current and all neighbouring cells)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres"],"hasliked":0,"parentid":"tdXXWX","parentname":"Infinite Spheres Ray Marching"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 990\n#define MINDIST .01\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec3 randColor(vec3 center) {\n    return vec3(random(center*vec3(5)), random(center*vec3(15)+vec3(50)), random(center*vec3(35)+vec3(90)));\n}\n\nvec3 cameraMovement() {\n    return vec3(sin(iTime*1.0)*5.8,-0.5*iTime,iTime*2.8);\n}\n\nfloat DistanceEstimator(vec3 pos, vec3 cameraPos, out vec3 center, out vec3 normal) {\n    \n    // translate\n    //pos = pos + cameraMovement();\n    \n    center = floor(pos/2.0)*2.0+1.;\n    float rand = random(center*30.);\n    float randRad = random(center*20.+44.)*0.5+0.5;\n    vec3 offsCenter = center + vec3(sin(iTime*4.0+rand*27.0)*0.3,sin(iTime*5.0+rand*9.0)*0.3,0);\n    normal = normalize(pos - offsCenter);\n\n    float d1 = distance(mod(pos, 2.), mod(offsCenter, 2.))-.42321 * randRad;\n    \n    return d1;\n}\n\nvec3 trace(vec3 from, vec3 direction) {\n\tfloat totalDistance = 0.0;\n\tint steps;\n    vec3 lastP = vec3(0);\n    vec3 lastCenter = vec3(0);\n    vec3 lastNormal = vec3(0);\n\tfor (steps=0; steps < MAXSTEPS; steps++) {\n\t\tvec3 p = from + totalDistance * direction;\n\t\tfloat dist = DistanceEstimator(p, from, lastCenter, lastNormal);\n\t\ttotalDistance += dist;\n        lastP = p;\n\t\tif (dist < MINDIST) break;\n\t}\n    //lastP += cameraMovement(); \n    vec3 center = lastCenter;\n    vec3 normal = lastNormal;\n    float light = dot(normal, normalize(vec3(0.6,1,-0.2)));\n    vec3 amb = pow(light*0.5+0.5, 0.8) * vec3(0.3, 0.45, 0.6);\n\treturn (amb + clamp(light, 0., 1.)*vec3(1.5, 1.3, 0.8)) * randColor(center);\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0, 2, 0) + cameraMovement();\n\tvec3 camViewDir = normalize(vec3(uv.xy, 1));\n    \n\tvec3 dist = trace(camPos, camViewDir);\n    \n    fragColor = vec4(aces_tonemap(dist), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}