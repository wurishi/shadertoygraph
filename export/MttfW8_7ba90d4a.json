{"ver":"0.1","info":{"id":"MttfW8","date":"1539697288","viewed":2682,"name":"Water Wave sample2","username":"edo_m18","description":"Water Wave sample.\n\nI referred this post \"https://www.shadertoy.com/view/Ms2SD1\"\n\nI have commented each functions and expressions.\n\nI have posted an article of this code commentary, but in Japanese.\nhttps://qiita.com/edo_m18/items/a575606a60b21f0d2c57","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Refer: \"https://www.shadertoy.com/view/Ms2SD1\"\n */\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n\n#define EPSILON_NRM (0.1 / iResolution.x)\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1, 0.19, 0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nconst mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);\n\n// Get random value.\nfloat hash(vec2 p)\n{\n\tfloat h = dot(p, vec2(127.1, 311.7));\t\n    return fract(sin(h) * 43758.5453123);\n}\n\n// Get Noise.\nfloat noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    // u = -2.0f^3 + 3.0f^2\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    \n    // Get each grid vertices.\n    // +---+---+\n    // | a | b |\n    // +---+---+\n    // | c | d |\n    // +---+---+\n    float a = hash(i + vec2(0.0,0.0));\n    float b = hash(i + vec2(1.0,0.0));\n    float c = hash(i + vec2(0.0,1.0));\n    float d = hash(i + vec2(1.0,1.0));\n    \n    // Interpolate grid parameters with x and y.\n    float result = mix(mix(a, b, u.x),\n                        mix(c, d, u.x), u.y);\n    \n    // Normalized to '-1 - 1'.\n    return (2.0 * result) - 1.0;\n}\n\n// lighting\nfloat diffuse(vec3 n, vec3 l, float p)\n{\n    return pow(dot(n, l) * 0.4 + 0.6, p);\n}\n\nfloat specular(vec3 n, vec3 l, vec3 e, float s)\n{\n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;\n}\n\n// Get sky color by 'eye' position.\n// So, The color changed smoothly by eye level.\nvec3 getSkyColor(vec3 e)\n{\n    e.y = max(e.y, 0.0);\n    float r = pow(1.0 - e.y, 2.0);\n    float g = 1.0 - e.y;\n    float b = 0.6 + (1.0 - e.y) * 0.4;\n    return vec3(r, g, b);\n}\n\n// Get sea wave octave.\nfloat sea_octave(vec2 uv, float choppy)\n{\n    uv += noise(uv);        \n    vec2 wv = 1.0 - abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv, swv, wv);\n    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n}\n\n// p is ray position.\nfloat map(vec3 p)\n{\n    float freq = SEA_FREQ; // => 0.16\n    float amp = SEA_HEIGHT; // => 0.6\n    float choppy = SEA_CHOPPY; // => 4.0\n    \n    // XZ plane.\n    vec2 uv = p.xz;\n    \n    float d, h = 0.0;    \n    \n    // ITER_GEOMETRY => 3\n    for (int i = 0; i < ITER_GEOMETRY; i++)\n    {       \n    \td = sea_octave((uv + SEA_TIME) * freq, choppy);\n    \td += sea_octave((uv - SEA_TIME) * freq, choppy);\n        h += d * amp;\n    \tuv *= octave_m;\n        freq *= 2.0;\n        amp *= 0.2;\n        choppy = mix(choppy, 1.0, 0.2);\n    }\n    \n    return p.y - h;\n}\n\n// p is ray position.\n// This function calculate detail map with more iteration count.\nfloat map_detailed(vec3 p)\n{\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    \n    vec2 uv = p.xz;\n    \n    float d, h = 0.0;\n    \n    // ITER_FRAGMENT = 5\n    for (int i = 0; i < ITER_FRAGMENT; i++)\n    {        \n    \td = sea_octave((uv + SEA_TIME) * freq, choppy);\n    \td += sea_octave((uv - SEA_TIME) * freq, choppy);\n        h += d * amp;        \n    \tuv *= octave_m;\n        freq *= 2.0;\n        amp *= 0.2;\n        choppy = mix(choppy, 1.0, 0.2);\n    }\n    \n    return p.y - h;\n}\n\n// p = ray position\n// n = surface normal\n// l = light\n// eye = eye\n// dist = ray marching distance\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist)\n{\n    float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);\n    fresnel = pow(fresnel, 3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye, n));    \n    vec3 refracted = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    \n    float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n, l, eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps)\n{\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x + eps, p.y, p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x, p.y, p.z + eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\n// Get Height Map\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p)\n{\n    float tm = 0.0;\n    \n    float tx = 1000.0;\n    \n    // Calculate 1000m far distance map.\n    float hx = map(ori + dir * tx);\n    \n    // if hx over 0.0 is that ray on the sky. right?\n    if(hx > 0.0)\n    {\n        p = vec3(0.0);\n        return tx;   \n    }\n    \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    \n    // NUM_STEPS = 8\n    for (int i = 0; i < NUM_STEPS; i++)\n    {\n        // Calculate weight for 'tm' and 'tx' mixing.\n        float f = hm / (hm - hx);\n        \n        tmid = mix(tm, tx, f);                   \n        p = ori + dir * tmid;\n        \n    \tfloat hmid = map(p);\n        \n\t\tif (hmid < 0.0)\n        {\n        \ttx = tmid;\n            hx = hmid;\n        }\n        else\n        {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    \n    return tmid;\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n \n    const vec3 light = normalize(vec3(0.0, 1.0, 0.8)); \n    \n    // ray \n    vec3 ori = vec3(0.0, 3.5, 5.0);\n    vec3 dir = normalize(vec3(uv.xy, -2.0));\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori, dir, p);\n    \n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist, dist) * EPSILON_NRM);\n    \n    // color\n    vec3 sky = getSkyColor(dir);\n    vec3 sea = getSeaColor(p, n, light, dir, dist);\n    \n    // This is coefficient for smooth blending sky and sea.\n    float t = pow(smoothstep(0.0, -0.05, dir.y), 0.3);\n    vec3 color = mix(sky, sea, t);\n    \n    // post\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}