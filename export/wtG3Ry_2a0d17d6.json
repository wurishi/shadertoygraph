{"ver":"0.1","info":{"id":"wtG3Ry","date":"1579282514","viewed":388,"name":"Pong Game","username":"DannnYXZ","description":"Simple PvP pong game. P1 - <W, S>, P2 - <UP, DOWN>.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["game","pong","ping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// logic\nvec2 paddle_pos(vec4 paddle, ivec2 key){\n    float vy = 0.;\n    if(texelFetch(iChannel1, ivec2(key.x, 0), 0).x == 1.) vy = 1.;\n    if(texelFetch(iChannel1, ivec2(key.y, 0), 0).x == 1.) vy = -1.;\n    vec2 new_pos = vec2(paddle.x, clamp(paddle.y+vy*PADDLE_SPEED*iTimeDelta,\n                                        PADDLE_SIZE.y+PADDLE_OFFSET,\n                                        1.-PADDLE_SIZE.y-PADDLE_OFFSET));\n    return new_pos;\n}\nvec4 collide(vec4 ball, vec4 paddle){\n    if(sd_rect(ball.xy-paddle.xy,PADDLE_SIZE)-BALL_R < 0.){\n        ball.zw = normalize((ball.xy-paddle.xy)*vec2(1., .2));\n    }\n    return ball;\n}\nvec4 collide(vec4 ball, vec2 p, vec2 n){\n    if(dot(ball.xy-p, n)-BALL_R < 0.){\n    \tball.zw = mirror(ball.zw, n);   \n    }\n    return ball;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 id = ivec2(fragCoord);\n    vec2 res = vec2(iResolution.x/iResolution.y, 1.);\n    if(id == PADDLE_L){\n        vec4 paddle = texelFetch(iChannel0, PADDLE_L, 0);\n        if(iFrame == 0) paddle.xy = vec2(PADDLE_SIZE.x + PADDLE_OFFSET, .5);\n        fragColor = vec4(paddle_pos(paddle, ivec2(KEY_W, KEY_S)),0.,0.);\n        return;\n    }\n    if(id == PADDLE_R){\n        vec4 paddle = texelFetch(iChannel0, PADDLE_R, 0);\n        if(iFrame == 0) paddle.xy = vec2(res.x-PADDLE_SIZE.x-PADDLE_OFFSET, .5);\n        fragColor = vec4(paddle_pos(paddle, ivec2(KEY_UP, KEY_DOWN)),0.,0.);\n        return;\n    }\n    if(id == BALL || id == SCORE){\n        vec4 ball = texelFetch(iChannel0, BALL, 0);\n        ball.xy += ball.zw * iTimeDelta * BALL_SPEED;\n        vec4 score = texelFetch(iChannel0, SCORE, 0);\n        if(iFrame == 0) ball = vec4(.5 * res, 1., 0.);\n        if(ball.x < 0. || ball.x > res.x){\n            if(ball.x < 0.) {score.y++; ball.zw=vec2(1., 0.);}\n            else {score.x++; ball.zw=vec2(-1., 0.);}\n            ball.xy = vec2(.5 * res);\n        }\n        vec4 paddle_l = texelFetch(iChannel0, PADDLE_L, 0);\n        vec4 paddle_r = texelFetch(iChannel0, PADDLE_R, 0);\n        ball = collide(ball, paddle_l);\n        ball = collide(ball, paddle_r);\n        ball = collide(ball, vec2(0.), vec2(0., 1.));\n        ball = collide(ball, vec2(0., 1.), vec2(0., -1.));\n        if(id == BALL) fragColor = vec4(ball);\n        if(id == SCORE) fragColor = vec4(score);\n        return;\n    }\n    fragColor = vec4(0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// visuals\nint chr[12]=int[12](0xe9d72e, 0xe210c4, 0x1f0ba0f, 0xf8320f, 0x1087a31, 0x1f87c3f, 0xe8bc3e, 0x84221f, 0xe8ba2e, 0xe87a2e, 0x007c00, 0xc60000);\nfloat font(vec2 p, float code) {\n    if(p.x > 1. || p.y > 1. || p.x < 0. || p.y < 0.) return 0.;\n    p = ((p - vec2(0., 1.)) * vec2(1., -1.)) * 5.;\n    float pos = floor(p.x) + 5.0 * floor(p.y);\n    return float((chr[int(code)]>>int(pos))&1);\n}\nfloat number(vec2 uv, float x) {\n    float a, mask = 0., d = 1.1;\n    if(x < 0.) {\n        mask += font(uv, 10.);\n        uv.x -= d;\n        x = abs(x);\n    }\n    float b = modf(x, a);\n    float la = ceil(log(a + 1.) / log(10.)), lb = 4.;\n    if(a == 0.) la = 1.;\n    vec2 uva = uv - vec2((la - 1.) * d, 0.);\n    vec2 uvb = uv - vec2((la + 1.) * d, 0.);\n    while(la > 0.) {\n        mask += font(uva, mod(a, 10.));\n        a /= 10.;\n        uva.x += 1.1;\n        la -= 1.;\n    }\n    return mask;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(iResolution.x/iResolution.y);\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy*4.;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 paddle_l = texelFetch(iChannel0, PADDLE_L, 0);\n    vec4 paddle_r = texelFetch(iChannel0, PADDLE_R, 0);\n    col += S(.01,.009,sd_rect(uv-paddle_l.xy, PADDLE_SIZE));\n    col += S(.01,.009,sd_rect(uv-paddle_r.xy, PADDLE_SIZE));\n    col += S(.001,.0009,sd_rect(vec2(uv.x+100.*(.5*sign(sin(uv.y*90.))+.5), uv.y)-.5*res, vec2(.003, 1.)));\n    vec4 ball = texelFetch(iChannel0, BALL, 0);\n    col += S(.001,.0009, sd_circ((uv-ball.xy), BALL_R));\n    vec4 score = texelFetch(iChannel0, SCORE, 0);\n    col += number((uv-vec2(res.x*.25, .8))*10., score.x);\n    col += number((uv-vec2(res.x*.75, .8))*10., score.y);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define S(a,b,x) smoothstep(a,b,x)\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_W     = 87;\nconst int KEY_S     = 83;\n\nivec2 PADDLE_L = ivec2(0,0);\nivec2 PADDLE_R = ivec2(1,0);\nvec2  PADDLE_SIZE = vec2(.005, .1);\nfloat PADDLE_SPEED = 1.1;\nfloat PADDLE_OFFSET = .02;\nivec2 BALL = ivec2(2,0);\nfloat BALL_SPEED = 1.;\nfloat BALL_R = .025;\nivec2 SCORE = ivec2(3,0);\n\n\nfloat sd_circ(vec2 uv, float r){\n    return length(uv)-r;\n}\nfloat sd_rect(vec2 uv, vec2 r){\n    return length(max(abs(uv)-r,0.));\n}\nvec2 mirror(vec2 p, vec2 n){\n    float d = dot(p, n);\n    return p - min(d, 0.)*n*2.;\n}","name":"Common","description":"","type":"common"}]}