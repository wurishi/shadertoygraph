{"ver":"0.1","info":{"id":"XlyXRh","date":"1482685969","viewed":137,"name":"Raymarching Iterations","username":"ptrgags","description":"I'm trying out raymarching using this tutorial: http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n\nI liked the look of the iteraton count map, so I decided to make my own! Next time, I'll add lighting and shadow.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","simple","tutorial","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define EPSILON 0.0001\n#define CENTER (iResolution.xy / 2.0)\n\n//Translate a point in space\nvec3 translate(vec3 point, vec3 displacement) {\n    return point - displacement;\n}\n\n//Distance estimators from https://iquilezles.org/articles/distfunctions\n//Distance to sphere centered at the origin\nfloat sphere_dist(vec3 ray, float radius) {\n    return length(ray) - radius;\n}\n\n//Distance from the infinte plane y = ground_y\nfloat ground_dist(vec3 ray, float ground_y) {\n    return abs(ray.y - ground_y);\n}\n\n//Distance to a box centered at the origin with given dimensions.\n//This is the unsigned implementation\nfloat box_dist(vec3 ray, vec3 box_dims) {\n    return length(max(abs(ray) - box_dims, 0.0));\n}\n\nfloat scene_dist(vec3 ray_pos) {\n    //Sphere of radius 0.5 centered at the origin\n    float sphere1 = sphere_dist(ray_pos, 0.5);\n    \n    //Sphere of radius 0.5 centered at (1, 0, 1)\n    vec3 sphere2_pos = translate(ray_pos, vec3(1.0, 0.0, 1.0));\n    float sphere2 = sphere_dist(sphere2_pos, 0.5);\n    \n    //Infinte plane of the ground\n    float ground = ground_dist(ray_pos, -0.4);\n    \n    //box centered at (-2, 1, 1)\n    vec3 box_pos = translate(ray_pos, vec3(-1.5, 0.5, 1.0));\n    vec3 box_dims = vec3(0.5, 1.0, 0.5);\n    float box = box_dist(box_pos, box_dims);\n    \n    //carve a hole in the box\n    float hole = sphere_dist(box_pos, 0.6);\n    box = max(box, -hole);\n    \n    //Union of all the elements\n    float spheres = min(sphere1, sphere2);\n    float plus_box = min(spheres, box);\n   \tfloat plus_ground = min(plus_box, ground);\n    \n    //Return the whole scene\n    return plus_ground;\n}\n\n//Following tutorial from http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n//however, this function returns the iteration count for coloring\nint raymarch(vec3 origin, vec3 direction) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        //Current position of ray\n        vec3 ray_pos = origin + t * direction;\n        \n        //Distance from ray to nearest point in scene\n        float dist = scene_dist(ray_pos);\n        \n        //If we're close to the surface, return the iteration count\n        if (dist < EPSILON)\n            return i;\n       \t//Otherwise, march forwards \n        else\n       \t\tt += dist;\n    }\n    return -1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \t//UV Coordinates, accounting for aspect ratio\n\tvec2 uv = (fragCoord.xy - CENTER) / iResolution.y;\n    \n    //Pretend the screen coordinate is on a plane\n    //at z=-0.5\n    vec3 image = vec3(uv, -0.6);\n    \n    //Camera's eye, looking in the +z direction\n    vec3 eye = vec3(0.0, 0.0, -1.0);\n    \n    //Direction from eye to screen\n    vec3 direction = normalize(image - eye);\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    //Raymarch\n    int steps = raymarch(eye, direction);\n    if (steps != -1) {\n        //get a range from few iterations -> many iterations\n        float mix_percent = float(steps) / float(MAX_STEPS);\n        \n        //quick calculations are orange, slow calculations are blue\n        vec4 color_gradient = mix(\n            vec4(1.0, 0.5, 0.0, 1.0), \n            vec4(0.1, 0.0, 1.0, 1.0), \n            mix_percent);\n        fragColor = color_gradient;\n    }\n}","name":"Image","description":"","type":"image"}]}