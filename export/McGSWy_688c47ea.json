{"ver":"0.1","info":{"id":"McGSWy","date":"1715715319","viewed":80,"name":"Brownian Truchets","username":"GarlicGraphix","description":"Implementing fbm (as I understand it I'm not a mathematician lol) with random truchet patterns instead of noise, and then using this fbm to warp the image a la https://iquilezles.org/articles/warp/","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fbm","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Get pixel colour from iChannel0\n    vec3 col = texture(iChannel0, uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n#define ITERATIONS 10\n\n\nmat2 rot2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat textureTile(vec2 tile, vec2 uv) {\n    // Horizontally flip random 50% of tiles\n    if (random(tile) <= 0.5) {\n        uv.x = 1.0-uv.x;\n    }\n    // Vertically flip random 50% of tiles\n    if (random(tile*0.71) <= 0.5) {\n        uv.y = 1.0-uv.y;\n    }\n    \n    // Apply colour based on equation\n    float col = 0.0;\n    if (uv.x-uv.y <= 0.0) {\n        col = 1.0;\n    }\n    \n    return col;\n}\n\nfloat fbm(vec2 uv) {\n    float col = 0.0;\n    \n    // Looping for fbm\n    for (int i = 1; i < ITERATIONS; i++) {\n        // Tiling screen (16x9) and creating a local UV for each tile\n        vec2 tileDimensions = vec2(2.0*float(i), 1.125*float(i));\n        vec2 tile = floor(uv*tileDimensions);\n        vec2 tileUV = vec2(mod(uv.x*tileDimensions.x, 1.0), mod(uv.y*tileDimensions.y, 1.0));\n\n\n        col += textureTile(tile, tileUV)*(1.0-0.2*float(i));\n    }\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= rot2D(iTime*0.05);\n    uv += iTime*0.02;\n    \n    vec2 q = vec2( fbm( uv + vec2(0.0,0.0) ),\n                   fbm( uv + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( fbm( uv + 4.0*q + vec2(1.7,9.2) ),\n                   fbm( uv + 4.0*q + vec2(8.3,2.8) ) );\n    \n    float time = iTime*0.004;\n    vec3 col = vec3(fbm( uv+time + 4.0*r*time ));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}