{"ver":"0.1","info":{"id":"WtKSDt","date":"1583861572","viewed":703,"name":"Heightmap","username":"vegvarizalan","description":"This shader renders  a heightmap based on a texture.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original: https://www.shadertoy.com/view/lsj3z3\n\n#define M_PI 3.1415926535897932384626433832795\n\n\nfloat terrain( in vec2 p)\n{\n    \n    const float heightScale = 1.0;\n   \tconst bool flip = true;\n    \n    p = p*0.1;\n    float scale = 1.0;\n    //float scale = max(0.0, mix(1.0, 0.0, max(1.0, 2.0*max(abs(p.x), abs(p.y))) - 1.0));\n    p = p+vec2(0.5);\n    //scale = -2.0*scale*scale*scale + 3.0*scale*scale;\n    if (p.x < 0.0 || p.x >= 1.0 || p.y < 0.0 || p.y >= 1.0)\n        return 0.0;\n   \tp = mix(vec2(0.5, 0.0), vec2(1.0, 0.5), p);\n    float val = texture( iChannel0, p, 0.0 ).x;\n    if (flip)\n        val = 1.0 - val;\n   \t//val = (val-0.5)*5.0;\n\treturn val * scale * heightScale;\n}\n\nfloat map( in vec3 p )\n{\n    return p.y - terrain(p.xz);\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n\tfloat e = 0.001;\n\te = 0.0001*t;\n    vec3  eps = vec3(e,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 40.0;\n    const float precis = 0.001;\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        float h = map( ro+rd*t );\n        if( abs(h)<precis || t>maxd ) break;\n        t += h*0.5;\n    }\n    return (t>maxd)?-1.0:t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    float rotTimeScale = 0.3;\n    \n    //vec4 m = iMouse / iResolution.xxxx;\n    \n    float mousePos = -iMouse.x/iResolution.x * 2.0 * M_PI * 8.0;\n    time = mousePos;\n\t\n\t// Normal set up code for ray trace.\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 s = (-1.0 + 2.0* xy) * vec2(iResolution.x/iResolution.y, 1.0);\n    \n    vec3 planeNormal = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 planeUp = abs(planeNormal.y) < 0.5\n        ? vec3(0.0, 1.0, 0.0)\n        : vec3(0.0, 0.0, 1.0);\n   \tvec3 planeSide = normalize(cross(planeNormal, planeUp));\n    planeUp = cross(planeSide, planeNormal);\n\t\n    float dist = 8.0;\n    float height = 2.0;\n    \n\tvec3 ro = vec3(sin(time * rotTimeScale) * dist, height, cos(time * rotTimeScale) * dist);\n    ro.y += (planeSide*ro.x + planeNormal*ro.y + planeUp*ro.z).y;\n\tvec3 cd = normalize(-ro);\n\tvec3 cu = vec3(0.0, 1.0, 0.0);\n\tvec3 cr = normalize(cross(cd, cu));\n\tcu = normalize(cross(cr, cd));\n\n\tvec3 rd = normalize( s.x*cr + s.y*cu + 2.0*cd );\n\n\tvec3 col = vec3(0.7, 0.7, 0.7);\n    \t\n    vec3 sunDir = normalize(vec3(-1, -1, -1));\n    vec3 ambientLight = vec3(0.3);\n    vec3 sunLight = vec3(0.9);\n    \n    \n    // transform ray\n    ro = vec3(\n        dot(ro, planeSide),\n        dot(ro, planeNormal),\n        dot(ro, planeUp)\n    );\n    rd = vec3(\n        dot(rd, planeSide),\n        dot(rd, planeNormal),\n        dot(rd, planeUp)\n    );\n    \n    \n    float t = intersect(ro, rd);\n    \n    if(t > 0.0)\n    {\t\n\t\t// Get some information about our intersection\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 normal = calcNormal(pos, t);\n        \n        float shadow = intersect(pos, -sunDir) > 0.0 ? 0.0 : 1.0;\n\t\t\n\t\tvec2 uvp = vec2(dot(pos, planeUp), dot(pos, planeSide));\n\t\t\n\t\tvec3 texCol = texture(iChannel1, uvp, 0.0).xyz;\n\t\t\n\t\tcol = texCol * clamp(-dot(normal, sunDir), 0.0f, 1.0f) * shadow * sunLight + ambientLight; \n\t}\n\t\n\tfragColor = vec4(pow(col*1.2, vec3(2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}