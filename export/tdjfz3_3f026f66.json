{"ver":"0.1","info":{"id":"tdjfz3","date":"1590543681","viewed":82,"name":"Mandelbrot Set Bruh","username":"bruhSoundEffectShader","description":"The Mandelbrot set (implemented in probably the most expensive way possible)\nUp/Down Arrow to zoom in/out\nWASD to move around\nClick and drag around to view a bunch of julia sets.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrotset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int iterations = 200;\nconst float threshold = 3.0f;\nvec2[iterations] tests;\n\n// I DIDN'T WRITE THIS HSVtoRGB FUNCTION, NOT MY WORK. COPY AND PASTED STRAIGHT FROM GOOGLE.\nvec3 HSVtoRGB(float h, float s, float v )\n{\n\tfloat r, g, b;\n    \n    int i;\n\tfloat f, p, q, t;\n\tif( s == 0.0f ) {\n\t\t// achromatic (grey)\n\t\tr = g = b = v;\n\t\treturn vec3(v, v, v);\n\t}\n\th /= 60.0f;\t\t\t// sector 0 to 5\n\ti = int(floor( h ));\n\tf = h - float(i);\t\t\t// factorial part of h\n\tp = v * ( 1.0f - s );\n\tq = v * ( 1.0f - s * f );\n\tt = v * ( 1.0f - s * ( 1.0f - f ) );\n\tswitch( i ) {\n\t\tcase 0:\n\t\t\tr = v;\n\t\t\tg = t;\n\t\t\tb = p;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tr = q;\n\t\t\tg = v;\n\t\t\tb = p;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tr = p;\n\t\t\tg = v;\n\t\t\tb = t;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tr = p;\n\t\t\tg = q;\n\t\t\tb = v;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tr = t;\n\t\t\tg = p;\n\t\t\tb = v;\n\t\t\tbreak;\n\t\tdefault:\t\t// case 5:\n\t\t\tr = v;\n\t\t\tg = p;\n\t\t\tb = q;\n\t\t\tbreak;\n\t}\n    \n    return vec3(r, g, b);\n}\n\nvec2 cmplxSquare(vec2 c) {\n\treturn vec2(pow(c.x, 2.0f) - pow(c.y, 2.0f), 2.0f * c.x * c.y);\n}\n\nfloat fmod(float a, float d) {\n\ta = abs(a); \n    d = abs(d);\n    \n    int t = int(floor(a / d));\n    \n    return a - (d * float(t));\n}\n\nvec2 dataPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[1].x),\n                 floor(vf / iChannelResolution[1].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[1].xy;\n  return xy;\n}\n\nvec2 mapScreen(vec2 sc) {\n    return vec2((sc.x - iResolution.x/2.0f) / iResolution.x, (sc.y - iResolution.y/2.0f) / iResolution.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n  \n    float xOff = texture(iChannel1, dataPos(2)).x;\n    float yOff = texture(iChannel1, dataPos(3)).x;\n    float scalePixel = texture(iChannel1, dataPos(1)).x;\n    float scale = 5.0f * (1.0f - scalePixel);\n    \n    vec2 m = mapScreen(vec2(iMouse.x, iMouse.y)) * 2.5f;\n    \n    vec2 p = fragCoord;\n    vec2 c = mapScreen(p);\n\tvec2 o = 40.0f * vec2(xOff-.5f, yOff - .5f) + vec2(19.0f, 20.0f);\n\tc = c*scale+o;\n\n    \n    bool stable = false;\n    tests[0] = c;\n    \n    int failedIndex = -1;\n    \n    for (int i = 1; i < iterations; i++) {\n        if (iMouse.x == 0.0f && iMouse.y == 0.0f) {\n            tests[i] = cmplxSquare(tests[i - 1]) + c; \n        } else {\n            tests[i] = cmplxSquare(tests[i - 1]) + m; \n        }    \n          \n            \n        if (length(tests[i]) > threshold) {\n            failedIndex = 0; \n                \n            if (i > 1) {\n        \t\tfailedIndex = i - 1;   \n            }\n            \n            break;\n        }\n    }\n\t\n    float base = 0.0f;\n    float divisor = 1.0f;\n    \n    fragColor = vec4(0, 0, base, 1);\n    \n    int cValue = 80;\n    if (failedIndex > 0) {\n       \tfloat alpha = mod(float(failedIndex), float(cValue));\n        alpha = alpha / float(cValue);\n        fragColor = vec4(0, 0, alpha, 1);\n        fragColor = vec4(HSVtoRGB(alpha * 360.0f, 1.0f, alpha), 1.0f);\n        \n    }\n\t\n    if (failedIndex == -1) {\n    \tfragColor = vec4(1, 1, 1, 1);   \n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// this script handles user-input\n\nconst float ZOOM_SPEED_BASE = .01f;\nconst float MOVE_SPEED_BASE = .00009f;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int W = 87;\nconst int S = 83;\nconst int A = 65;\nconst int D = 68;\n\n\nint dataIndex(vec2 xy) {\n\txy *= iChannelResolution[1].xy;\n  \txy = floor(xy);\n \treturn int(xy.x + xy.y * iChannelResolution[1].x);\n}\n\nvec2 dataPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[1].x),\n                 floor(vf / iChannelResolution[1].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[1].xy;\n  return xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float scalePixel = 1.0f - texture(iChannel1, dataPos(1)).x;\n    float moveSpeed = MOVE_SPEED_BASE * scalePixel;\n    \n    \n    int di = dataIndex(uv);\n    if (di < 0 || di > 20) discard;\n    \n    switch(di) {\n    case 1:\n        float scale = 1.0f - texture(iChannel1, dataPos(1)).x;\n\n        if (1.0f == texelFetch( iChannel0, ivec2(KEY_DOWN,0), 0).x) {\n            scale=scale * (1.0f+ZOOM_SPEED_BASE);\n           \n            if (scale == 0.0f) {\n                scale = .0001;\n            }\n        } else if (1.0f == texelFetch( iChannel0, ivec2(KEY_UP,0), 0).x) {\n            scale=scale * (1.0f-ZOOM_SPEED_BASE);\n        }\n        \n        scale = 1.0f - scale;\n        \n        fragColor = vec4(clamp(scale, 0.0f, 1.0f), 0, 0, 1);\n        break;\n        \n    case 2:\n        float xOff = texture(iChannel1, uv).x;\n\n        if (1.0f == texelFetch( iChannel0, ivec2(A,0), 0).x) {\n            xOff-=moveSpeed;\n        } else if (1.0f == texelFetch( iChannel0, ivec2(D,0), 0).x) {\n            xOff+=moveSpeed;\n        }\n        \n        fragColor = vec4(clamp(xOff, -1.0f, 1.0f), 0, 0, 1);\n        break;\n    case 3:\n        float yOff = texture(iChannel1, uv).x;\n\n        if (1.0f == texelFetch( iChannel0, ivec2(W,0), 0).x) {\n            yOff+=moveSpeed;\n        } else if (1.0f == texelFetch( iChannel0, ivec2(S,0), 0).x) {\n            yOff-=moveSpeed;\n        }\n        \n        fragColor = vec4(clamp(yOff, 0.0f, 1.0f), 0, 0, 1);\n        break;\n    }\n\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}