{"ver":"0.1","info":{"id":"tlX3R8","date":"1555596040","viewed":352,"name":"Textured Torus (phasor) - cracks","username":"sylefeb","description":"Torus textured with surface phasor noise, see https://hal.archives-ouvertes.fr/hal-02118508 for details.\nThis implements a surface noise following the parametrization free on-surface Gabor noise technique (https://hal.inria.fr/inria-00606821/).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Torus cracks with surface phasor noise, Sylvain Lefebvre\n// see https://hal.archives-ouvertes.fr/hal-02118508 for details\n// The MIT License\n//\n// -------------------------------------------------------\n// routine for ray-torus intersection, https://www.shadertoy.com/view/4sBGDy\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// -------------------------------------------------------\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 torus )\n{\n\tfloat Ra2 = torus.x*torus.x;\n\tfloat ra2 = torus.y*torus.y;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\t\t\n\tfloat k = (m - ra2 - Ra2)/2.0;\n\tfloat a = n;\n\tfloat b = n*n + Ra2*rd.z*rd.z + k;\n\tfloat c = k*n + Ra2*ro.z*rd.z;\n\tfloat d = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    //----------------------------------\n\n\tfloat p = -3.0*a*a     + 2.0*b;\n\tfloat q =  2.0*a*a*a   - 2.0*a*b   + 2.0*c;\n\tfloat r = -3.0*a*a*a*a + 4.0*a*a*b - 8.0*a*c + 4.0*d;\n\tp /= 3.0;\n\tr /= 3.0;\n\tfloat Q = p*p + r;\n\tfloat R = 3.0*r*p - p*p*p - q*q;\n\t\n\tfloat h = R*R - Q*Q*Q;\n\tfloat z = 0.0;\n\tif( h < 0.0 )\n\t{\n\t\tfloat sQ = sqrt(Q);\n\t\tz = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n\t}\n\telse\n\t{\n\t\tfloat sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n\t\tz = sign(R)*abs( sQ + Q/sQ );\n\n\t}\n\t\n\tz = p - z;\n\t\n    //----------------------------------\n\t\n\tfloat d1 = z   - 3.0*p;\n\tfloat d2 = z*z - 3.0*r;\n\n\tif( abs(d1)<1.0e-4 )\n\t{\n\t\tif( d2<0.0 ) return -1.0;\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\tif( d1<0.0 ) return -1.0;\n\t\td1 = sqrt( d1/2.0 );\n\t\td2 = q/d1;\n\t}\n\n    //----------------------------------\n\t\n\tfloat result = 1e20;\n\n\th = d1*d1 - z + d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = -d1 - h - a;\n\t\tfloat t2 = -d1 + h - a;\n\t\t     if( t1>0.0 ) result=t1;\n\t\telse if( t2>0.0 ) result=t2;\n\t}\n\n\th = d1*d1 - z - d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = d1 - h - a;\n\t\tfloat t2 = d1 + h - a;\n\t\t     if( t1>0.0 ) result=min(result,t1);\n\t\telse if( t2>0.0 ) result=min(result,t2);\n\t}\n\n\treturn result;\n}\n\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nfloat max2(vec2 v) { return max(v.x,v.y); }\nfloat min2(vec2 v) { return min(v.x,v.y); }\n\n// -------------------------------------------------------\n// Main\n// -------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 1.7;\n\tvec3 ro  = vec3( 0.0, -1.5, 2.5*sin(an) );\n    vec3 ta  = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww  = normalize( ta - ro );\n    vec3 uu  = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv  = normalize( cross(uu,ww));    \n    vec3 tot = vec3(0.0);    \n    // pixel coordinates\n    vec2 p   = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    // raytrace torus\n    vec2 torus = vec2(1.0,0.45 + 0.04 * (1.0 - cos(iTime)));\n    float t    = iTorus( ro, rd, torus );\n    // shading/lighting\t\n    vec3 col = vec3(0.0);\n    if( t>0.0 && t<100.0 ) {\n        // there is a hit, get the normal\n        vec3 pos = ro + t*rd;\n        vec3 nor = nTorus( pos, torus );        \n        // create cracks with phasor\n        // -> first phasor\n        _omega_0     = M_PI/2.0;\n        vec2 phasor1 = phasorNoiseSrf(pos,nor);\n        float u      = abs(0.5 - fract(atan(phasor1.y,phasor1.x) / (2.0*M_PI)));\n        // -> second phasor, crossing the first\n        _omega_0     = M_PI/2.0 + M_PI/7.0;\n        vec2 phasor2 = phasorNoiseSrf(pos,nor);\n        float v      = abs(0.5 - fract(atan(phasor2.y,phasor2.x) / (2.0*M_PI)));\n        // width of the cracks\n        float w = max(0.0, 0.15 * (1.0 - cos(iTime)) - 0.02);\n        // combine phasor noises into the cracks pattern        \n        float h = 1.0 - clamp( (max2(abs(vec2(u,v) - vec2(0.5,0.5))) - (0.5-w))/(w) ,0.0,1.0) > 0.5 ? 1.0 : 0.0;\n        // shaed\n        float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n        float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n        // done\n        col       = vec3(h*(dif+amb));\n    } else {\n        // no hit, background color\n        col = vec3(0.9);\n    }\n\n    col = sqrt( col );\n\n    tot += col;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// surface phasor noise , Sylvain Lefebvre\n// see https://hal.archives-ouvertes.fr/hal-02118508 for details\n//\n// The MIT License\n// Copyright © 2019 Sylvain Lefebvre\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst int   MaxInt = 2147483647; // 2^31 - 1\n\n#define M_PI   3.1415926535897932385\n\nfloat  _a            = 6.0;   // noise bandwidth\nfloat  _F_0          = 7.0;  // main frequency\nfloat  _F_w          = 0.0;   // frequency random spread\nfloat  _omega_0      = 0.0;   // main orientation\nfloat  _omega_w      = 0.3;   // orientation spread\nint    Seed          = 42;    // random seed\n\nconst int ImpPerKernel  = 32; // impulses per kernel, higher is better but slower\n\nconst vec3 Vup = vec3(0.0,0.0,1.0);\n\n//-----------------------------------------------------------------------------\n\nint hash_linear(ivec4 ijkl)\n{\n  return (ijkl.x + (ijkl.y << 10) + (ijkl.z << 20));\n}\n\n//-----------------------------------------------------------------------------\n\nint hash(ivec2 ij)\n{\n  return hash_linear( ij.xyxy );\n}\n\nint hash3(ivec3 ijk)\n{\n  return hash_linear( ijk.xyzx );\n}\n\nconst int MaxHash = MaxInt;\n\n//-----------------------------------------------------------------------------\n\nfloat drand(int r, out int _r)\n{\n  _r = r * 3039177861;\n  return float(_r & MaxInt) / float(MaxInt);\n}\n\n//-----------------------------------------------------------------------------\n\nconst float truncate = 0.01;\n\nfloat kernelRadius(float ka)\n{\n  return (sqrt( - log( truncate ) / M_PI ) / float(ka));\n}\n\n// -----------------------------------------------------\n\nfloat gaussian(vec2 uv, float a)\n{\n  // gaussian\n  float lsq = dot(uv, uv);\n  return exp(-M_PI * (a*a) * lsq);\n}\n\n//-----------------------------------------------------------------------------\n \nvec2 sampleCellSrf(\n  ivec3 ijk, vec3 uvw,\n  vec3  wu, vec3 wv, vec3  wn, // surface frame (u,v, normal)\n  float f0, float o0, float ow, float a, float kr)\n{  \n\n  // init random number generator \n  int   h = 1 + hash3(ijk);\n  int rnd = Seed + h;\n  \n  vec2 phasor  = vec2(0.0);\n    \n  vec3  cellsz = vec3(2.0*kr);\n  \n  int   N = ImpPerKernel;\n  for (int nIter = 0; nIter < N; nIter++) {\n    // generate a 3D sample in the virtual grid    \n    float rx  = drand(rnd, rnd);\n    float ry  = drand(rnd, rnd);\n    float rz  = drand(rnd, rnd);\n    vec3 ctr3 = vec3(rx, ry, rz);\n\n    // project it to the surface\n    vec3   v           = (uvw - ctr3) * cellsz;  \n    vec2   x_minus_x_i = vec2(dot(v, wu), dot(v, wv));\n    vec2   k           = vec2(0.0,0.0);\n    vec3  wctr         = (vec3(ijk) + ctr3);\n    vec2  plane_uv     = vec2(dot(wctr, wu), dot(wctr, wv)) * cellsz.xy;\n    float o0 = _omega_0;\n    // randomize orientation\n    float o   = o0;\n    float o_r = drand(rnd, rnd);\n    float o1  = o0 - ow;\n    float o2  = o0 + ow;\n    o         = o1 + o_r * (o2 - o1);\n    // randomize freq\n    float f;\n    float f_r = drand(rnd, rnd);\n    float f1  = f0 - _F_w;\n    float f2  = f0 + _F_w;\n    f         = f1 + f_r * (f2 - f1);\n    // if within kernel radius (kernel might contribute to the result)\n    if (dot(v, v) < kr*kr*2.0) {\n      vec2  u_i   = vec2(cos(o), sin(o));\n      float phase = 2.0 * M_PI * f * dot(u_i,x_minus_x_i);\n      // compute weight, takes into acount distnace between\n      // 3d sample and surface (samples far away contribute less)\n      float  z    = max(0.0, 1.0 - abs(dot(v, wn) / kr));\n      float  i    = z * gaussian(x_minus_x_i,a);\n      // add kernel contribution\n      phasor += i * vec2(cos(phase),sin(phase));\n    }\n  }\n  return phasor;\n}\n\n// ---------------------------------------------------------------\n\nvec2 makeNoiseSrf(vec3 tuv,vec3 wu, vec3 wv,vec3 nrm)\n{\n  vec2 phasor = vec2(0.0,0.0);\n  vec3 uvw    = tuv;\n  // sparse convolution\n  float kr = kernelRadius(_a);\n  // generate virtual grid coordinates\n  vec3  cellsz = vec3(2.0*kr);\n  vec3  _ijk   = uvw / cellsz;\n  ivec3 ijk    = ivec3(round(_ijk));\n  vec3  fijk   = _ijk - vec3(ijk);\n  // sample eight 3d cells in the virtual grid\n  ivec3 nd = ivec3(0);\n  nd.x = (fijk.x > 0.5) ? 1 : -1;\n  nd.y = (fijk.y > 0.5) ? 1 : -1;\n  nd.z = (fijk.z > 0.5) ? 1 : -1;\n  for (int k = 0; k < 2; k++) {\n    for (int j = 0; j < 2; j++) {\n      for (int i = 0; i < 2; i++) {\n        phasor += sampleCellSrf(\n          ijk + ivec3(i, j, k)*nd, fijk - vec3(i, j, k) * vec3(nd), \n          wu, wv, nrm, \n          _F_0, _omega_0, _omega_w, _a, kr);\n      }\n    }\n  }\n  return phasor; \n}\n\n// ---------------------------------------------------------------\n\n// Phasor noise returns a vec2(.,.) which is directly the phasor vector\n// - the atan of the vector gives the instantaneous phase\n// - the modulus gives the gabor intensity\nvec2 phasorNoiseSrf(vec3 point, vec3 normal)\n{\n  vec3 tuv = point;\n  vec3 nrm = normalize(normal);\n  // generate a tangential u,v, frame\n  vec3 wu  = normalize(cross(nrm, Vup));\n  vec3 wv  = cross(wu, nrm);\n  // make some noise!\n  vec2 phasor = makeNoiseSrf(tuv, wu, wv, nrm);\n  return phasor;\n}\n\n// ---------------------------------------------------------------\n","name":"Common","description":"","type":"common"}]}