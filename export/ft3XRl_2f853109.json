{"ver":"0.1","info":{"id":"ft3XRl","date":"1639579910","viewed":95,"name":"Cube 4D","username":"romeosoft","description":"4D Cube","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["4d","4dcube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// colors\nconst vec3 \n    c1 = vec3(0.8, 0.5, 0.0),\n\tc2 = vec3(.0, .0,.8);\n\n// light direction\nvec3 light = vec3(-1.414 / 2.,-1.414 / 2.,0.);   \n\nconst float PI = 3.1415926;\n//--------------------------------------------------------------\n// Cross4 computes the four-dimensional cross product of the three vectors\n// U, V and W, in that order. It returns the resulting four-vector.\nvec4 cross4D(vec4 U, vec4 V, vec4 W)\n{\n    vec4 result;\n    float A, B, C, D, E, F;       // Intermediate Values\n\n    // Calculate intermediate values.\n\n    A = (V.x * W.y) - (V.y * W.x);\n    B = (V.x * W.z) - (V.z * W.x);\n    C = (V.x * W.w) - (V.w * W.x);\n    D = (V.y * W.z) - (V.z * W.y);\n    E = (V.y * W.w) - (V.w * W.y);\n    F = (V.z * W.w) - (V.w * W.z);\n\n    // Calculate the result-vector components.\n\n    result.x = (U.y * F) - (U.z * E) + (U.w * D);\n    result.y = -(U.x * F) + (U.z * C) - (U.w * B);\n    result.z = (U.x * E) - (U.y * C) + (U.w * A);\n    result.w = -(U.x * D) + (U.y * B) - (U.z * A);\n\n    return result;\n}\nmat4 rotXY(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,st,0.0,0.0,\n        -st,ct,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n\nmat4 rotYZ(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,ct,st,0.0,\n        0.0,-st,ct,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n        \nmat4 rotXZ(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,0.0,-st,0.0,\n        0.0,1.0,0.0,0.0,\n        st,0.0,ct,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n        \nmat4 rotXW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,0.0,0.0,st,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        -st,0.0,0.0,ct\n    );\n}\n\nmat4 rotYW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,ct,0.0,-st,\n        0.0,0.0,1.0,0.0,\n        0.0,st,0.0,ct\n    );\n}\n\nmat4 rotZW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,ct,-st,\n        0.0,0.0,st,ct\n    );\n}\n\n// geom\nfloat box(vec4 p, vec4 o, float r)\n{\n    if(    (p.x > o.x - r && p.x < o.x + r)\n         &&(p.y > o.y - r && p.y < o.y + r)\n         &&(p.z > o.z - r && p.z < o.z + r)\n         &&(p.w > o.w - r && p.w < o.w + r)\n        )\n        return -1.;\n    return 0.;\n}\n\nfloat udBox( vec4 p, vec4 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// render\nvec3 shade(vec4 p, float v)\n{\n    vec3 cor = mix(c2, c1, 0.5 + 0.5 * sin(p.x*p.y*p.z*50. + 25. * p.w));\n    \n    return mix(cor, vec3(0.1), dot(p.xyz, light));\n}\n\n// camera dirction\nvoid calc4matrix(\n    vec4 From, vec4 To, vec4 Up, vec4 Over,\n    out vec4 Wa, out vec4 Wb, out vec4 Wc, out vec4 Wd\n)\n{\n    // Get the normalized Wd column-vector.\n    Wd = To - From;\n    Wd=normalize(Wd);\n\n    // Calculate the normalized Wa column-vector.\n    Wa = cross4D(Up, Over, Wd);\n    Wa=normalize(Wa);\n\n    // Calculate the normalized Wb column-vector.\n    Wb = cross4D(Over, Wd, Wa);\n    Wb=normalize(Wb);\n\n    // Calculate the Wc column-vector.\n    Wc = cross4D(Wd, Wa, Wb);\n    Wc=normalize(Wc);\n}\n//--------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -(iMouse.x / iResolution.x) * PI * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * PI * 2.0;\n    \n\tvec4 cam = vec4(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        0.5,\n        eyer * sin(eyea) * sin(eyef));\n    float ang = iTime * 0.25;\n    cam = cam * (rotXY(iTime * 0.25) * rotZW(iTime * 0.5 + PI / 1.5)); // DOUBLE ROTATION\n    \n    vec4 front, left;\n    vec4 to = vec4(0.0);\n    vec4 up = vec4(0.0, 1.0, 0.0, 0.0);\n    vec4 over = vec4(0.0, 0.0, 0.0, 1.0);\n    calc4matrix(\n        cam, to, up, over, \n        left, up, over, front);\n    \n    vec4 v = normalize(front*1.5 - left*pp.x - up*pp.y);\n    \n    vec4 p = cam;\n    float dt = 0.01;\n    vec3 cor = vec3(0.0);\n    \n    for(int i = 0; i < 250; i ++)\n    {\n       float f = box(p, vec4(0.0,0.0,0.0,0.0),0.5);\n        if(f < 0.0)\n        {\n            cor = shade(p, f);\n            break;\n        }\n        p += v*dt;\n    }\n    \n    fragColor = vec4(cor,1.0);\n}","name":"Image","description":"","type":"image"}]}