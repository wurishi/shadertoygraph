{"ver":"0.1","info":{"id":"fttGRM","date":"1635874027","viewed":182,"name":"Sphere tracing visualization","username":"kiglo","description":"Controls:\n - use WASD or arrow keys and mouse to move around\n - press O to open, I to close the lid\n - press keys 1 to 3 to press pedals\n - see top of common tab for visualization controls","likes":13,"published":1,"flags":48,"usePreview":1,"tags":["sdf","visualization","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This file contains the \n// ---- SPHERE TRACING ----\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, -1);\n    Value val;\n    \n    int i = 0; do\n    {\n        val = sdf(ray.P+ret.T*ray.V);\n        ret.T+=val.d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\tval.d > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(val.d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    ret.mat = val.mat;\n    return ret;\n}\n\nvec3 ray_pos = vec3(0);\nvec3 ray_dir = vec3(0);\nfloat move_plane = 0.;\nfloat rot_plane  = 0.;\n\n\n// ---- SHADING ----\nint light_n = 3;\nvec3 lights[3] = vec3[3](\n    vec3(10.,15.,10.),\n    vec3(0, 30, 0),\n    vec3(10, 6, 10)\n);\n\n// from https://iquilezles.org/articles/palettes\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)).d,sdf(p+vec3(0,eps,0)).d,sdf(p+vec3(0,0,eps)).d);\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)).d,sdf(p-vec3(0,eps,0)).d,sdf(p-vec3(0,0,eps)).d);\n    return normalize(plus-minu);\n}\n\nvec4 shading(vec3 p, vec3 v, vec3 n, vec3 l, int m, float t) \n{\n    Material mat = materials[m];\n    \n    vec3 F0 = mat.metalness > 0.1 ? mat.color*mat.metalness : vec3(mat.metalness);\n    vec3  h = normalize(l + v);\n\n    float hn = max(dot(h, n), 0.0), vn = max(dot(v, n), 0.0);\n\tfloat ln = max(dot(l, n), 0.0), vh = max(dot(v, h), 0.0);\n    float G = min( 2.*hn*min( vn, ln)/vh, 1.0 );\n\n\n    float hn2 = hn*hn, m2 = mat.roughness*mat.roughness;\n    float D = exp((hn2-1.)/(hn2*m2)) / (m2*hn2*hn2*pi);\n\n    vec3 F = F0 + (1.-F0)*pow(1.-ln,5.);\n\tvec3 specular  = D*F*G / (vn * ln);\n\t\n    if (m == MAT_FLOOR) mat.color = texture(iChannel3, p.xz / 15.).xyz;\n    if (m == MAT_SPHERE) { // visualization material\n        mat.color = palette(t,vec3(0.5),vec3(0.5),vec3(0.7),vec3(0.5,0.2,0.25));\n        mat.emission = mat.color * 0.1;\n    }\n\tvec3 diffuse = mat.color * (1. - F);\n    \n\treturn vec4(max(specular + diffuse,0.)*ln+mat.emission,1);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,float t, vec3 n, int m, float vt)\n{\n    \n    vec3 p = ray.P + ray.V*t;\n    \n    vec3 v = -ray.V;\n    vec4 col = vec4(0);\n    //calculate shading for every light source\n    for (int i = 0; i < light_n; ++i)\n    {\n        vec3 l = normalize(lights[i]-p);\n        col += shading(p, v, n, l, m, vt);\n    }\n    \n    return col / float(light_n);\n}\n\n\n// ---- sphere tracing visualizaion -----\nvec3 traceColor(Ray ray, float rayT)\n{\n    vec3 col = vec3(0);\n    float sphere_t = TRACE_MAX_DIST * 2.;\n    \n    //ray to render\n    Ray r = Ray(ray_pos, TRACE_MIN_DIST, ray_dir, TRACE_MAX_DIST); \n    int i = 0;\n    float t = r.Tmin;\n    float d = 1.;\n    do { //sphere tracing along r\n        vec3 c = r.P+t*r.V;\n        d = sdf(c).d;\n        float st = IntersectSphere(ray, c, d); //intersection of current sphere\n        if (st > 0. && st < sphere_t && rayT > st) {\n            if (TRANSPARENT_SPHERE == 0.)\n                sphere_t = st;\n            vec3 n = normalize(ray.P+st*ray.V-c);\n            //if transparent then +=, else =\n            //color with palette\n            col = TRANSPARENT_SPHERE * col + hitColor(ray, st, n, MAT_SPHERE, float(i)/float(VISUAL_MAX_STEP)).xyz;\n        }\n        t += d;\n        ++i;\n    } while (i < VISUAL_MAX_STEP && t < r.Tmax);\n    return col;\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65, KeyLeft2 = 37;\nconst int KeyRight = 68, KeyRight2 = 39;\nconst int KeyUp    = 87, KeyUp2 = 38;\nconst int KeyDown  = 83, KeyDown2 = 40;\nconst int OpenBtn  = 79;\nconst int CloseBtn = 73;\nconst int Pedal1   = 49;\nconst int Pedal2   = 50;\nconst int Pedal3   = 51;\nconst int KeyVis   = 81;\nconst int KeyCtrl  = 17;\nconst int ToggleSphere = 32;\nconst int TogglePlane  = 80;\nconst int KeyReset = 82;\n\nconst vec3 EyeStartPosition = vec3(3.5,20.2,-20.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec3 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    vec4 t1 = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec4 t2 = texelFetch(iChannel0, ivec2(2,0), 0);\n    vec4 t3 = texelFetch(iChannel0, ivec2(3,0), 0);\n    vec4 t4 = texelFetch(iChannel0, ivec2(4,0), 0);\n    vec4 t5 = texelFetch(iChannel0, ivec2(5,0), 0);\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = t1.yzw;\t// spherical coordinates\n    pedal_t = t2.xyz;\n    ray_pos = t3.xyz;\n    ray_dir = vec3(t1.x,t2.w,t3.w);\n    plane_p = t4.yzw;\n    plane_n = t5.yzw;\n    move_plane = t4.x;\n    rot_plane  = t5.x;\n    vec2 planeUV = vec2(atan(plane_n.z, plane_n.x), acos(plane_n.y));\n    vec2 uv\t= abs(data2.xy);\n    \n    // fallboard rotation\n    // if negative then decrease, if positive then increase value\n    // if greater than 5pi/2, stop\n    if (abs(data2.z) < 5.*pi/2.) \n        data2.z += sgn(data2.z) * iTimeDelta * FALLBOARD_SPEED;\n    if (abs(data2.z) > 5.*pi/2.)\n        data2.z = 5.*pi/2.*sgn(data2.z);\n    \n    // pedal rotation from 0 to pi\n    if (pedal_t.x == 0. || pedal_t.x > pi) pedal_t.x = 0.;\n    else pedal_t.x += PEDAL_SPEED*iTimeDelta;\n    if (pedal_t.y == 0. || pedal_t.y > pi) pedal_t.y = 0.;\n    else pedal_t.y += PEDAL_SPEED*iTimeDelta;\n    if (pedal_t.z == 0. || pedal_t.z > pi) pedal_t.z = 0.;\n    else pedal_t.z += PEDAL_SPEED*iTimeDelta;\n    \n   \tif(iMouse.z>0. || data2.x >= 0.) {\t//mouse held or was held last frame\n        vec3 fw = vec3(cos(uv.x)*cos(-uv.y),sin(-uv.y),sin(uv.x)*cos(-uv.y));\n        vec3 u = normalize(cross(vec3(0,1,0),fw));\n        vec3 v = cross(fw,u);\n        vec2 d = (iMouse.xy/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n        vec3 dir = normalize(fw+d.x*u+d.y*v);\n        //t1, t2: intersections of ray with red and green spheres\n        float t1 = IntersectSphere(Ray(eye,0.,dir,0.), plane_p, PLANE_CONTROL_SIZE);\n        float t2 = IntersectSphere(Ray(eye,0.,dir,0.), plane_p+plane_n*PLANE_CONTROL_SIZE*3., PLANE_CONTROL_SIZE);\n        // plane not visible, there was no intersection or mouse is moving\n        // then rotate camera\n        if (!isOn(TogglePlane) || move_plane == 0. && rot_plane == 0. && (t1 < 0. && t2 < 0. || data2.x >= 0.)) {\n            uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n        // red sphere moved\n        } else if (rot_plane == 0. && t1 > 0. && (t2 < 0. || t2 > t1)) {\n            move_plane = 1.;\n            if (!isKeyHeld(KeyCtrl)) {\n                t1 = min(IntersectPlane(Ray(eye,0.,dir,0.), plane_p, vec3(0,1,0)), 100.);\n                plane_p.xz = (eye + t1*dir).xz;\n            } else {\n                t1 = min(IntersectPlane(Ray(eye,0.,dir,0.), plane_p, vec3(1,0,0)), 100.);\n                plane_p.y = (eye+t1*dir).y;\n            }\n        // green sphere moved\n        } else if (t2 > 0. || rot_plane > 0.) {\n            rot_plane = 1.;\n            if (!isKeyHeld(KeyCtrl)) {\n                t2 = min(IntersectPlane(Ray(eye,0.,dir,0.), plane_p, vec3(0,1,0)), 100.);\n                vec3 p2 = eye + t2*dir - plane_p;\n                planeUV.x = atan(p2.z, p2.x);\n            } else {\n                t2 = min(IntersectPlane(Ray(eye,0.,dir,0.), plane_p, fw), 100.);\n                vec3 p2 = clamp((eye + t2*dir - plane_p)/PLANE_CONTROL_SIZE/3., -0.999, 1.);\n                planeUV.y = acos(p2.y);\n            }\n        }\n        \n    }\n    // reseting everything in the first frame\n    if (iFrame <= 1) {\n        uv = vec2(1.8, pi/6.);\n        data2 = vec3(uv, fallboard_t);\n        pedal_t = vec3(0);\n        ray_dir = vec3(1,0,0);\n        plane_n = vec3(0,1,0);\n        move_plane = rot_plane = 0.;\n    }\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft ) || isKeyHeld(KeyLeft2)) eye -= u*speed;\n    if (isKeyHeld(KeyRight) || isKeyHeld(KeyRight2)) eye += u*speed;\n    if (isKeyHeld(KeyUp   ) || isKeyHeld(KeyUp2)) eye += w*speed;\n    if (isKeyHeld(KeyDown ) || isKeyHeld(KeyDown2)) eye -= w*speed;\n    // open/close the lid\n    if (isKeyHeld(OpenBtn )) data2.z = data2.z < 0. ? data2.z : -1.5*pi;\n    if (isKeyHeld(CloseBtn)) data2.z = data2.z > 0. ? data2.z :  1.5*pi;\n    // pressing pedals\n    if (isKeyHeld(Pedal1  )) pedal_t.x = pedal_t.x == 0. ? 0.01 : pedal_t.x;\n    if (isKeyHeld(Pedal2  )) pedal_t.y = pedal_t.y == 0. ? 0.01 : pedal_t.y;\n    if (isKeyHeld(Pedal3  )) pedal_t.z = pedal_t.z == 0. ? 0.01 : pedal_t.z;\n    if (isKeyHeld(KeyReset)) {plane_p = vec3(0); planeUV = vec2(0); }\n    if(iMouse.z>=0.)\t\t//mouse held\n        data2.xy = abs(data2.xy);\n\telse if(data2.x >= 0.) {//mouse released\n        move_plane = rot_plane = 0.;\n        data2.xy = -mod(uv,2.*pi);\n        // if Q was pressed, then store ray data\n        if (isKeyHeld(KeyVis)) {\n            ray_pos = eye;\n            vec2 d = (iMouse.xy/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n            ray_dir = normalize(w+d.x*u+d.y*v);\n        }\n    }\n    \n        \n    fallboard_t = data2.z;\n    planeUV.x = mod(planeUV.x,2.*pi);\n    planeUV.y = mod(planeUV.y,   pi);\n    plane_n = vec3(cos(planeUV.x)*sin(planeUV.y), cos(planeUV.y), sin(planeUV.x)*sin(planeUV.y));\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               TRACE_MIN_DIST,\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               TRACE_MAX_DIST);\t\t\t    //maxT\n}\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lights[2] = BODY_P+BODY_S*1.5*vec3(4.*cos(iTime),1,4.*sin(iTime));\n\n    // Generate ray from pixel\n    vec3 eye; vec3 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(TRACE_EPSILON, TRACE_MAX_STEP);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n\n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T, normal(ray.P+result.T*ray.V), result.mat, 0.);\n                                   // too many iterations -> probably hit\n    else \t        \t\t\t  fragColor = hitColor(ray, result.T, normal(ray.P+result.T*ray.V), result.mat, 0.);\n\n\n    if (isOn(ToggleSphere)) {\n        vec3 c = traceColor(ray, result.T);\n        if (c != vec3(0)) fragColor.xyz = c + TRANSPARENT_SPHERE * fragColor.xyz;\n    }\n    \n    if (isOn(TogglePlane)) {\n        float t = IntersectPlane(ray, plane_p, plane_n);\n        if (t > 0. && t < TRACE_MAX_DIST) {\n            vec3 p = ray.P+t*ray.V;\n            float d = sdf(p).d;\n            d *= 0.1;\n            vec3 c;\n            if (abs(d) < TRACE_EPSILON)\n                c = vec3(mix(0.5, 1., mod(iTime, 1.)));\n            else if (d > 0.)\n                c = palette((d*5.), vec3(0.5),vec3(0.5,0.2,0.7),vec3(1.0,0.5,1.0),vec3(0.3,0.20,0.20));\n            else\n                c = palette(d, vec3(0.5),vec3(0.5),vec3(1.0),vec3(0.0,0.33,0.37));\n            if ((d < 0. || abs(d) < 5.*TRACE_EPSILON || t < result.T))\n                fragColor.xyz = mix(fragColor.xyz, c, PLANE_ALPHA);\n        }\n        float ts = IntersectSphere(ray, plane_p, PLANE_CONTROL_SIZE);\n        if (ts > 0.) fragColor.xyz = mix(fragColor.xyz, vec3(1,0,0), 0.6);\n        float ts2 = IntersectSphere(ray, plane_p+plane_n*PLANE_CONTROL_SIZE*3., PLANE_CONTROL_SIZE);\n        if (ts2 > 0. && (ts > ts2 || ts < 0.)) fragColor.xyz = mix(fragColor.xyz, vec3(0,1,0), 0.6);\n    }\n    \n    // First six pixels are reserved\n    if (fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if (fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor = vec4(ray_dir.x, data);\n    if (fragCoord.x == 2.5 && fragCoord.y == 0.5)\n        fragColor = vec4(pedal_t, ray_dir.y);\n    if (fragCoord.x == 3.5 && fragCoord.y == 0.5)\n        fragColor = vec4(ray_pos, ray_dir.z);\n    if (fragCoord.x == 4.5 && fragCoord.y == 0.5)\n        fragColor = vec4(move_plane, plane_p);\n    if (fragCoord.x == 5.5 && fragCoord.y == 0.5)\n        fragColor = vec4(rot_plane, plane_n);\n        \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//===============SDF visualization==================\n//\n// Visualization of SDF values evaluated on a plane. Different color palettes represent\n// the positive and the negative values, white color is used around the surface. \n//\n// The plane is defined by its point and normal.\n//\n// Turn on/off: press P\n// Drag red circle: move the plane around the horizontal axes\n// Drag red cirlce while holding CTRL: move the plane along the vertical axis\n// Drag green circle: rotate the plane around the vertical axis\n// Drag green circle while holding CTRL: rotate the plane around the horizontal axis\n// Reset position and normal: press R\n//\n\n//==============Sphere tracing visualization========\n//\n// Visualization of sphere tracing steps by rendering spheres along the ray.\n//\n// Turn on/off: press SPACE\n// Select rays by Mouse left click while holding Q\n// After moving, the selected ray will remain fixed \n//\n\n// Credits: primitives and operations from IQ\n// https://iquilezles.org/articles/distfunctions\n\n\n//==============Rendering properties================\n#define TRACE_MAX_STEP 100\t\t\t\t\t//maximum sphere tracing iterations\n#define TRACE_EPSILON 0.003\t\t\t\t\t//the distance from the surface at which we stop iterating\n#define TRACE_MIN_DIST 0.5\t\t\t\t\t//minimum tracing disance\n#define TRACE_MAX_DIST 400.\t\t\t\t\t//maximum tracing disance\n\n#define VISUAL_MAX_STEP 15\t\t\t\t\t//number of rendered spheres, large value highly reduces performance\n#define TRANSPARENT_SPHERE 0.\t\t\t\t//0. or 1.\n\n#define PLANE_CONTROL_SIZE 1.5\t\t\t\t//radius of the red and green contol circles\n#define PLANE_ALPHA 0.5                     //transparency value of the plane\n\n// ============Piano properties=====================\n//\n// These values can be changed to get a more realistic result, I had no piano at hand to be modelled. \n//\n#define KEY_SIZE_W vec3(0.235,0.2,1.5)\t\t//white key size\n#define KEY_SIZE_B vec3(0.137,0.23,0.9)\t\t//black key size\n#define KEY_GAP 0.45\t\t\t\t\t\t//multiplier of space between keys\n\n#define BODY_S vec3(14.8, 3, 19.4)\t\t\t//main part dimensions\n#define BODY_CURVE_R vec3(5, 7.9, 3.5)\t\t//the radii of the cylinders defining the body's shape\n\n#define WHEEL_R 0.6\t\t\t\t\t\t\t//wheel radius\n#define WHEEL_W 0.3\t\t\t\t\t\t\t//wheel width\n\n#define LYRE_S vec3(3, 1, 1)\t\t\t\t//lyre dimensions\n#define PEDAL_S vec3(0.45, 0.35, 1)\t\t\t//pedal dimensions\n\n#define PEDAL_SPEED 5.\t\t\t\t\t\t//pedal movement speed\n#define FALLBOARD_SPEED 5.\t\t\t\t\t//fallboard movement speed\n\nstruct Material { \n    vec3  color;        // [0,1/pi] \n    float roughness;    // [0,~7] \n    vec3  emission;\t    // [0, inf] \n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals \n}; \n\n#define MAT_WHITE  0\n#define MAT_BLACK  1\n#define MAT_BODY   2\n#define MAT_WHEEL  3\n#define MAT_PEDAL  4\n#define MAT_FLOOR  5\n#define MAT_SPHERE 6\n\nMaterial materials[] = Material[](\n    Material(vec3(1.), 0.2, vec3(0.1), 0.04),\t\t\t//white keys\n    Material(vec3(0), 0.2, vec3(0.), 0.06),\t\t\t\t//black keys\n    Material(vec3(0.2), .6, vec3(0.03), 0.03),\t\t\t//body\n    Material(vec3(0.18,0.18,0), 0.04, vec3(0), 0.9),\t//wheels\n    Material(vec3(0.2), .1, vec3(0.), 0.94),\t\t\t//pedals\n    Material(vec3(0.2,0.15,0.1), .3, vec3(0), 0.02),\t//floor\n    Material(vec3(0), 0.55, vec3(0.0), 0.04)\t\t\t//sphere tracing visualization\n);\n\nstruct Value {\n    float d;\n    int mat;\n};\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int mat;\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nfloat sgn(float a)\n{\n    return a >= 0. ? 1. : -1.;\n}\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n#define isOn(k)  (texelFetch(iChannel1, ivec2(k,2), 0).x > 0.)\n\nvec3 plane_p = vec3(0);\nvec3 plane_n = normalize(vec3(0));\n\nconst float pi = 3.1415926535897932384626433832795;\nfloat fallboard_t = -5.*pi/2.;\nvec3 pedal_t = vec3(0);\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCylinderY( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCylinderX( vec3 p, vec3 c )\n{\n  return length(p.yz-c.xy)-c.z;\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca,ca),dot(cb, cb)) );\n}\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// CSG op\n\nValue Union(Value v, float d, int m)\n{\n    if (v.d < d) return v;\n    else return Value(d, m);\n}\n\nValue Union(float d1, int m1, float d2, int m2)\n{\n    if (d1 < d2) return Value(d1, m1);\n    else return Value(d2, m2);\n}\n\nValue Union(Value v1, Value v2) \n{\n    if (v1.d < v2.d) return v1;\n    else return v2;\n}\n\nValue Intersect(Value v, float d, int m)\n{\n    if (v.d > d) return v;\n    else return Value(d, m);\n}\n\nValue Intersect(float d1, int m1, float d2, int m2)\n{\n    if (d1 > d2) return Value(d1,m1);\n    else return Value(d2, m2);\n}\n\nValue Intersect(Value v1, Value v2) \n{\n    if (v1.d > v2.d) return v1;\n    else return v2;\n}\n\nValue Subtract(Value v, float d, int m)\n{\n    if (-d > v.d) return Value(-d, m);\n    else return v;\n}\n\nValue Subtract(float d1, int m1, float d2, int m2)\n{\n    if (-d2 > d1) return Value(-d2, m2);\n    else return Value(d1, m1);\n}\n\nValue Subtract(Value v1, Value v2) \n{\n    if (-v2.d > v1.d) return Value(-v2.d, v2.mat);\n    else return v1;\n}\n\nfloat Repeat(float p, float s, float mi, float ma )\n{\n    return p-s*clamp(round(p/s),mi,ma);\n}\n\nfloat Round(float p, float r)\n{\n    return p - r;\n}\n\nvec3 RotateX(vec3 p, float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat3(1,0,0,0,c,-s,0,s,c) * p;\n}\nvec3 RotateY(vec3 p, float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat3(c,0,-s,0,1,0,s,0,c) * p;\n}\n\nValue Round(Value v, float r)\n{\n    return Value(v.d - r, v.mat);\n}\n\nValue RoundCorner(vec3 p, Value v, float r, vec2 c, vec2 d)\n{\n    Value box = Value(sdBox(p-vec3(c.x,0,c.y), vec3(r,100,r)), v.mat);\n    Value corner = Intersect(v, box);\n    v = Subtract(v, box);\n    \n    corner = Intersect(corner, sdCylinderY(p, vec3(c-d*r,r)), v.mat);\n    return Union(v, corner); \n}\n\n\n#define KEY_MAX 45.\n\n#define KEYBOARD_S vec3(KEY_SIZE_W.x * (2.+ KEY_GAP) * KEY_MAX / 2., KEY_SIZE_W.yz)\n#define KEYBOARD_P vec3(-KEY_SIZE_W.x*(2.+KEY_GAP/2.),6,0)\n\n#define BODY_P vec3(KEYBOARD_P.x, KEYBOARD_P.y + BODY_S.y/2., KEYBOARD_P.z + BODY_S.z - KEYBOARD_S.z - 2.*KEY_SIZE_W.x)\n#define FALLBOARD_S vec3(BODY_S.x - KEY_SIZE_W.x * 3.7, KEY_SIZE_W.z, 0.1)\n\nValue WheeledLeg(vec3 p, vec2 center, float h) \n{ \n    vec3 wPos = vec3(center.x,-h-BODY_S.y/2.+WHEEL_R,center.y);\n    Value wheel = Value(sdBox(p-wPos, vec3(WHEEL_W, WHEEL_R, WHEEL_R)), MAT_WHEEL);\n    wheel = Intersect(wheel, sdCylinderX(p, vec3(wPos.yz, WHEEL_R)), MAT_WHEEL);\n    Value v = Value(sdCappedCone(p - vec3(center.x, 1.*WHEEL_R-BODY_S.y/2., center.y), h - 1.*WHEEL_R, 0.4, 1.2), MAT_BODY);\n    \n    return Union(wheel, v);\n}\n\nValue Pedal(vec3 p, float angle)\n{\n    p = RotateX(p, -pi/2.-angle);\n    Value val = Value(sdCapsule(p, PEDAL_S.z, PEDAL_S.x), MAT_PEDAL);\n    val = Subtract(val, sdBox(p - vec3(0,PEDAL_S.z*0.5,PEDAL_S.x + PEDAL_S.y), 2.*PEDAL_S.xzx), MAT_PEDAL);\n    return val;\n}\n\n// SDF\n// TODO: optimalization\n\nValue sdf(in vec3 p)\n{\n    //-----keyboard---------\n    Value whiteKeys = Value(sdBox( vec3(Repeat(p.x,KEY_SIZE_W.x*(2.+KEY_GAP),-KEY_MAX/2.-0.5,KEY_MAX/2.-1.5),p.yz-KEYBOARD_P.yz), KEY_SIZE_W), MAT_WHITE);\n    vec3 a = vec3(Repeat(p.x - KEY_SIZE_W.x*(1.+KEY_GAP/2.),KEY_SIZE_W.x*(2.+KEY_GAP),-KEY_MAX/2.-0.5,KEY_MAX/2.-2.5),\n        p.y-KEY_SIZE_B.y/2.-KEYBOARD_P.y, p.z-(KEY_SIZE_W-KEY_SIZE_B).z-KEYBOARD_P.z);\n    Value blackKeys = Value(sdBox( a, KEY_SIZE_B), MAT_BLACK);\n    float m = mod(round((p.x - KEY_SIZE_W.x*(1.+KEY_GAP/2.))/(KEY_SIZE_W.x*(2.+KEY_GAP))), 7.0);\n    if (m == 2.0 || m == 6.0) blackKeys = whiteKeys; // no black keys between E/F and B/C\n    \n    Value keys = Union(whiteKeys, blackKeys);\n    keys = Round(keys, 0.02);\n    \n    //------body main------------------\n    Value body = Value(sdBox(p-BODY_P, BODY_S), MAT_BODY); \n    body = Subtract(body, sdCylinderX(p, vec3(BODY_P.y+BODY_S.y-1.,BODY_P.z-BODY_S.z,2)), MAT_BODY);\n    body = RoundCorner(p, body, BODY_CURVE_R.x, vec2(BODY_P.x-BODY_S.x,BODY_P.z+BODY_S.z),vec2(-1,1));\n    body = RoundCorner(p, body, BODY_CURVE_R.y, vec2(BODY_P.x+BODY_S.x-BODY_CURVE_R.y-2.,BODY_P.z+BODY_S.z), vec2(1,1));\n    body = Subtract(body, sdBox(p - vec3(BODY_P.x+BODY_S.x-2.,BODY_P.y,BODY_P.z+BODY_S.z-BODY_CURVE_R.y+1.),\n        vec3(BODY_CURVE_R.yy, BODY_CURVE_R.y+1.)),MAT_BODY);\n    body = Subtract(body, sdCylinderY(p, vec3(BODY_P.x+BODY_S.x-2.,BODY_P.z+BODY_S.z-BODY_CURVE_R.y*2.,BODY_CURVE_R.y)), 2);\n    float cornerDist = sqrt(BODY_CURVE_R.y*BODY_CURVE_R.y+BODY_CURVE_R.y*(BODY_CURVE_R.z-2.)*2.)-BODY_CURVE_R.z+2.;\n    body = RoundCorner(p, body, BODY_CURVE_R.z, vec2(BODY_P.x+BODY_S.x,BODY_P.z+BODY_S.z-BODY_CURVE_R.y*2.-cornerDist), vec2(1,1));\n    \n    //------keyboard's place----------\n    body = Subtract(body, sdBox(p - KEYBOARD_P + vec3(0,-BODY_S.y+KEY_SIZE_W.y,KEYBOARD_S.z),\n        vec3(FALLBOARD_S.x*1.02 ,BODY_S.y,KEYBOARD_S.z * 2.)), MAT_BODY);\n    float gs = (BODY_S.x-KEYBOARD_S.x) / 2.2;\n    body = Union(body, sdBox(p - KEYBOARD_P + vec3(KEYBOARD_S.x+gs+KEY_SIZE_W.x*KEY_GAP,0,0),\n        vec3(gs, KEY_SIZE_W.y, KEY_SIZE_W.z)), MAT_BODY);\n    body = Union(body, sdBox(p - KEYBOARD_P - vec3(KEYBOARD_S.x+gs,0,0), vec3(gs, KEY_SIZE_W.y, KEY_SIZE_W.z)), MAT_BODY);\n    \n    //------fallboard---------------\n    vec3 d = KEYBOARD_P+KEYBOARD_S+vec3(0,KEY_SIZE_W.y*2., 0.);\n    vec3 rp = RotateX(p-d, -(sin(fallboard_t)+1.)/2.*pi/2.)+d;\n    rp = rp-vec3(0,FALLBOARD_S.y*2.+KEY_SIZE_W.y*3.,KEYBOARD_S.z/2. - FALLBOARD_S.z*1.)+vec3(0,KEYBOARD_P.y, KEYBOARD_P.z-0.1);\n    Value fb = Intersect(sdCylinderX(rp-KEYBOARD_P, vec3(KEYBOARD_P.yz, 0.6)), MAT_BODY,\n                     sdBox(rp-KEYBOARD_P-vec3(0,KEYBOARD_P.yz+FALLBOARD_S.y), vec3(FALLBOARD_S.xyy)), MAT_BODY);\n    Value fb2= Intersect(sdCylinderX(rp-KEYBOARD_P, vec3(KEYBOARD_P.yz-FALLBOARD_S.zz*0.9, 0.6)), MAT_BODY,\n                     sdBox(rp-KEYBOARD_P-vec3(0,KEYBOARD_P.yz+FALLBOARD_S.y/2.-FALLBOARD_S.zz*0.9),\n                     vec3(FALLBOARD_S.xyy)+vec3(1,0,0)), MAT_BODY);\n    fb = Subtract(fb, fb2);\n    fb = Union(fb, sdBox(rp-KEYBOARD_P-vec3(0,KEYBOARD_P.y-FALLBOARD_S.y, KEYBOARD_P.z+0.6-FALLBOARD_S.z/2.),\n        vec3(FALLBOARD_S.x, FALLBOARD_S.y, FALLBOARD_S.z/2.)), MAT_BODY);\n    body = Union(body, fb);\n    \n    \n    //------legs----------\n    body = Union(body, WheeledLeg(p, vec2(BODY_P.x - BODY_S.x/2. + 2., BODY_P.z + BODY_S.z/1.4), BODY_P.y-BODY_S.y/2.));\n    body = Union(body, WheeledLeg(p, vec2(BODY_P.x - BODY_S.x + 2., BODY_P.z - BODY_S.z/1.5), BODY_P.y-BODY_S.y/2.));\n    body = Union(body, WheeledLeg(p, vec2(BODY_P.x + BODY_S.x - 2., BODY_P.z - BODY_S.z/1.5), BODY_P.y-BODY_S.y/2.));\n    \n    \n    //----lyre and pedals------\n    vec3 lyre_p = BODY_P - vec3(0, 2.*BODY_P.y-LYRE_S.y, BODY_S.z/1.5);\n    Value lyre = Value(sdBox(p - lyre_p, LYRE_S), MAT_BODY);\n    lyre = Union(lyre, sdBox(p-lyre_p+vec3( 4.*PEDAL_S.x,-BODY_P.y/2.-BODY_S.y,0), vec3(PEDAL_S.x,BODY_P.y-BODY_S.y/2.,PEDAL_S.x)), MAT_BODY);\n    lyre = Union(lyre, sdBox(p-lyre_p+vec3(-4.*PEDAL_S.x,-BODY_P.y/2.-BODY_S.y,0), vec3(PEDAL_S.x,BODY_P.y-BODY_S.y/2.,PEDAL_S.x)), MAT_BODY);\n    lyre = Union(lyre, Intersect(sdCylinderY(p, vec3(lyre_p.xz, PEDAL_S.x/3.)), MAT_BODY, \n            sdBox(p-lyre_p+vec3(0,-BODY_P.y/2.-BODY_S.y,0), vec3(PEDAL_S.x,BODY_P.y-BODY_S.y/2.,PEDAL_S.x)), MAT_BODY));\n    lyre = Subtract(lyre, sdSphere(p-lyre_p-LYRE_S*vec3( 1,1, 1), 0.4), MAT_BODY);\n    lyre = Subtract(lyre, sdSphere(p-lyre_p-LYRE_S*vec3(-1,1, 1), 0.4), MAT_BODY);\n    lyre = Subtract(lyre, sdSphere(p-lyre_p-LYRE_S*vec3(-1,1,-1), 0.4), MAT_BODY);\n    lyre = Subtract(lyre, sdSphere(p-lyre_p-LYRE_S*vec3( 1,1,-1), 0.4), MAT_BODY);\n    body = Union(body, lyre);\n    body = Union(body, Pedal(p-lyre_p+vec3( 4.*PEDAL_S.x,0,PEDAL_S.z), abs(sin(pedal_t.x))*pi/10.));\n    body = Union(body, Pedal(p-lyre_p+vec3( 0.*PEDAL_S.x,0,PEDAL_S.z), abs(sin(pedal_t.y))*pi/10.));\n    body = Union(body, Pedal(p-lyre_p+vec3(-4.*PEDAL_S.x,0,PEDAL_S.z), abs(sin(pedal_t.z))*pi/10.));\n    \n    \n    Value ground = Value(sdPlane(p, vec3(0,1,0),BODY_P.y), MAT_FLOOR);\n    return Union(Union(body, keys), ground);\n}\n\nvec2 solveQuadratic(float a, float b, float c)\n{\n\tfloat d = b*b-4.0*a*c;\n\tfloat t1 = (-b-sgn(b)*sqrt(d))/(2.0*a);\n\tfloat t2 = c/(a*t1);\n\treturn d<0.0 ? vec2(-1e10, 1e10) : vec2(min(t1,t2), max(t1,t2));\n}\n\nfloat IntersectSphere(Ray r, vec3 p, float radius) \n{\n    vec2 t12 = solveQuadratic(1., 2.*dot(r.P-p,r.V), dot(r.P-p,r.P-p)-radius*radius);\n    return t12.x;\n}\n\nfloat IntersectPlane(Ray r, vec3 q, vec3 n) \n{\n    return -dot(r.P-q, n)/dot(r.V,n);\n}\n","name":"Common","description":"","type":"common"}]}