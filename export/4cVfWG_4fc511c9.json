{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    Playing in 2D for something I want to make in 3D/Raymarching. \n    Then got caught up in the polar coords thing, and said - thats \n    a neat design!\n    \n    Hexagon X5\n    12/17/2024  @byt3_m3chanic\n    \n*/\n\n#define R     iResolution\n#define T     iTime\n#define M     iMouse\n\n#define PI    3.141592653\n#define PI2   6.283185307\n\nconst float N = 3.;\nconst float s4 = .577350, s3 = .288683, s2 = .866025;\nconst vec2 s = vec2(1.732,1);\n\nvec3 clr, trm;\nfloat tk, ln;\nmat2 r2,r3;\n\nmat2 rot(float g) { return mat2(cos(g), sin(g),-sin(g), cos(g)); }\nfloat hash21(vec2 p) { \n    p.x = mod(p.x,3.*N);\n    return fract(sin(dot(p,vec2(26.37,45.93)))*4374.23); \n}\n\n// Hexagon grid system, can be simplified but\n// written out long-form for readability. \n// return vec2 uv and vec2 id\nvec4 hexgrid(vec2 uv) {\n    vec2 p1 = floor(uv/vec2(1.732,1))+.5,\n         p2 = floor((uv-vec2(1,.5))/vec2(1.732,1))+.5;\n    vec2 h1 = uv- p1*vec2(1.732,1),\n         h2 = uv-(p2+.5)*vec2(1.732,1);\n    return dot(h1,h1) < dot(h2,h2) ? vec4(h1,p1) : vec4(h2,p2+.5);\n}\n\nvoid draw(float d, float px, inout vec3 C) {\n    float b = abs(d)-tk;\n    C = mix(C,C*.25,smoothstep(.1+px,-px,b-.01) );\n    C = mix(C,clr,smoothstep(px,-px,b ));\n    C = mix(C,clamp(C+.2,C,vec3(.95)),smoothstep(.01+px,-px, b+.1 ));\n    C = mix(C,trm,smoothstep(px,-px,abs(b)-ln ));\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    r2 = rot( 1.047);\n    r3 = rot(-1.047);\n    \n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n  \n    uv = -vec2(log(length(uv)),atan(uv.y,uv.x))-((2.*M.xy-R.xy)/R.xy);\n    uv /= 3.628;\n    uv *= N;\n        \n    uv.y += T*.05;\n    uv.x += T*.15;\n    vec2 mv=uv;\n    float sc = 3., px = fwidth(uv.x*sc);\n\n    vec4 H = hexgrid(uv.yx*sc);\n    vec2 p = H.xy, id = H.zw;\n\n    float hs = hash21(id);\n    \n    if(hs<.5) p *= hs < .25 ? r3 : r2;\n\n    vec2 p0 = p - vec2(-s3, .5),\n         p1 = p - vec2( s4,  0),\n         p2 = p - vec2(-s3,-.5);\n\n    vec3 d3 = vec3(length(p0), length(p1), length(p2));\n    vec2 pp = vec2(0);\n\n    if(d3.x>d3.y) pp = p1;\n    if(d3.y>d3.z) pp = p2;\n    if(d3.z>d3.x && d3.y>d3.x) pp = p0;\n     \n    ln = .015;\n    tk = .14+.1*sin(uv.x*5.+T);\n    \n    vec3 C = vec3(0);\n    \n    // tile background\n    float d = max(abs(p.x)*.866025 + abs(p.y)/2., abs(p.y))-(.5-ln);\n    C = mix(vec3(.0125),texture(iChannel0,p*2.).rgb*vec3(0.906,0.282,0.075),smoothstep(px,-px,d) );\n    C = mix(C,C+.1,mix(smoothstep(px,-px,d+.035),0.,clamp(1.-(H.y+.15),0.,1.)) );\n    C = mix(C,C*.1,mix(smoothstep(px,-px,d+.025),0.,clamp(1.-(H.x+.5),0.,1.)) );\n    \n    // base tile and empty vars\n    float b = length(pp)-s3;\n    float t = 1e5, g = 1e5;\n    float tg= 1.;\n    \n    hs = fract(hs*53.71);\n\n    // alternate tiles\n    if(hs>.95) {\n        vec2 p4 = p*r3, p5 = p*r2;\n        \n        b = length(vec2(p.x,abs(p.y)-.5));\n        g = length(p5.x);\n        t = length(p4.x);\n        tg= 0.;\n    }else if(hs>.65) {\n        b = length(p.x);\n        g = min(length(p1)-s3,length(p1+vec2(1.155,0))-s3);\n        \n        tg= 0.;\n    } else if(hs<.15) {\n        vec2 p4 = p*r3, p5 = p*r2;\n        \n        t = length(p.x);\n        b = length(p5.x);\n        g = length(p4.x);\n        \n        tg= 0.;\n    } else if(hs<.22) {\n        b = length(vec2(p.x,abs(p.y)-.5));\n        g = min(length(p1)-s3,length(p1+vec2(1.155,0))-s3);\n\n    }\n    \n    clr = vec3(0.420,0.278,0.043);\n    trm = vec3(.0);\n    \n    // draw segments\n    draw(t,px,C);\n    draw(g,px,C);\n    draw(b,px,C);\n    // solid balls\n    if(tg>0.){\n        float v = length(p)-.25;\n        C = mix(C,C*.25,smoothstep(.1+px,-px,v-.01) );\n        C = mix(C,clr,smoothstep(px,-px,v ));\n        C = mix(C,clamp(C+.2,C,vec3(.95)),smoothstep(.01+px,-px, v+.1 ));\n        C = mix(C,trm,smoothstep(px,-px,abs(v)-ln ));\n    \n    }\n    \n    C = pow(C,vec3(.4545));\n    O = vec4(C,1);\n}\n\n// end\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cVfWG","date":"1734480684","viewed":229,"name":"Hexagon X5","username":"byt3_m3chanic","description":"Playing in 2D for something I want to make in 3D/Raymarching. Then got caught up in the polar coords thing, and said - that's a neat design!","likes":39,"published":3,"flags":0,"usePreview":1,"tags":["2d","hexagon","truchet","wood","pattern","tiles"],"hasliked":0,"parentid":"","parentname":""}}