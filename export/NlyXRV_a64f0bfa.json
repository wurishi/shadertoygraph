{"ver":"0.1","info":{"id":"NlyXRV","date":"1640983637","viewed":45,"name":"Stephen's Mandelbrot","username":"stephenw","description":"Basic Mandelbrot set. Todo: better colours, fix iteration bounce","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Draw the Mandelbrot set.\n//\n// Click with the mouse to zoom or use +/- keys.\n// Use arrow keys to pan.\n// Press R to reset to initial view.\n//\n\n// Official HSV to RGB conversion \nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp(\n        abs(mod(c.x*6.0+vec3(0., 4., 2.), 6.) - 3.) - 1.,\n        0.0, 1.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid colour(out vec4 fragColor, in int iter) {\n    // Add time for slow colour cycling.\n    float hue = 1. - log(float(iter%256)) / log(256.) + iTime/42.;\n    fragColor = vec4(hsv2rgb(vec3(hue, 1., 1.)), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 state = GET_STATE(0);\n\n    // state.z is zoom level, .xy is view centre, .w is max iters.\n    vec2 c = MAP_COORD(fragCoord, state.z) + vec2(-.5, 0.) + state.xy;\n    \n    // Algorithm from https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set#Optimized_escape_time_algorithms\n    // Don't use periodicity check, it makes it much slower.\n\n    int max_iter = 500 + int(state.w);\n    int i, j;\n    vec2 z, z2 = vec2(0);\n    float w = 0.;\n    const int unroll = 16;\n\n    for (i = 0; i < max_iter; i+=unroll) {\n        for (j = 0; j < unroll; j++) {\n\n            if (z2.x + z2.y > 4.) {\n                // Outside the set.\n                colour(fragColor, i + j);\n                return;\n            }\n        \n            z = vec2(z2.x - z2.y, w - z2.x - z2.y) + c;\n            z2 = z * z;\n            w = (z.x + z.y) * (z.x + z.y);\n        }\n    }\n    \n    // Within the set.\n    fragColor = vec4(0., 0., 0., 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Handle mouse and keyboard input, and save the state\n// to pixel (0,0) of iChannel0.\n// .xy is the view centre, .z is the zoom, .w is max iterations.\n// All are biased so the initial values can be 0.\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_R     = 82;\nconst int KEY_PLUS  = 61;\nconst int KEY_MINUS = 173;\n#define KEY_STATE(k) (texelFetch(iChannel1, ivec2(k, 0), 0).x)\n\nvoid calc_scale(out vec4 fragColor)\n{\n    // Get current zoom state, or press R to reset.\n    vec4 old_state = GET_STATE(0);\n    vec4 state = old_state * (1. - KEY_STATE(KEY_R));\n    float zoom = state.z + 1.;\n    \n    // Movement velocity depends on frame rate.\n    float vel = iTimeDelta;\n    \n    // Mouse button down: zoom in towards the mouse pos.\n    if (iMouse.z > 0. && iMouse.w < 0.) {\n        zoom *= 1. + vel/2.;\n        state.xy += MAP_COORD(iMouse.xy, state.z) * vel;\n    }\n    \n    // Zoom with +/- keys.\n    zoom *= 1. + (KEY_STATE(KEY_PLUS) - KEY_STATE(KEY_MINUS)) * vel;\n    \n    // Arrow keys move view centre.\n    vec2 left = KEY_STATE(KEY_LEFT) * vec2(-1, 0);\n    vec2 up = KEY_STATE(KEY_UP) * vec2(0, 1);\n    vec2 right = KEY_STATE(KEY_RIGHT) * vec2(1, 0);\n    vec2 down = KEY_STATE(KEY_DOWN) * vec2(0, -1);\n    state.xy += (left + up + right + down) * vel * 1./zoom;\n\n    // Adjust zoom back to 0-based, and avoid zooming out too far.\n    state.z = max(0., zoom - 1.);\n    \n    // Adaptive iteration limit: decrease if frame rate is too low,\n    // else increase. Allow a lower frame rate when not moving.\n    float delta_min = state.xyz != old_state.xyz ? 1./30. : 1./10.;\n    float diff = (delta_min - GET_STATE(1).x)*10000.;\n    //clamp(diff, -1000., 1000.)\n    //if (abs(diff) > .01) {\n        state.w = clamp(state.w + diff, 0., 10000.);\n    //}\n    \n    fragColor = state;\n}\n\nvoid calc_average_delta(out vec4 fragColor)\n{\n    vec4 state = GET_STATE(1);\n    state.x = (state.x + iTimeDelta)/2.;\n    fragColor = state;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord == vec2(.5, .5)) {\n        calc_scale(fragColor);\n    } else if (fragCoord == vec2(1.5, .5)) {\n        calc_average_delta(fragColor);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define GET_STATE(x) (texelFetch(iChannel0, ivec2(x,0), 0))\n\n#define MAP_COORD(coord, zoom) \\\n    ((2.5 / (1. + zoom)) * (coord - .5 * iResolution.xy) / iResolution.y)\n","name":"Common","description":"","type":"common"}]}