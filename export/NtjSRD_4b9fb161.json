{"ver":"0.1","info":{"id":"NtjSRD","date":"1627215255","viewed":164,"name":"Jagged Plain 1D slice","username":"spalmer","description":"just a 1D slice of Shane's Jagged Plane triangle-wave-based noise function\n\nI tried to simplify to a true 1D function, decided that was an exercise in futility, and just rewrote a new triangle-wave-based FBM that gets similar results but is much simpler","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 1d fork of Jagged Plain by Shane https://shadertoy.com/view/4tSXRm\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(vec3 x) { return abs(x-floor(x)-.5); } // Triangle wave vector overload.\n\n// my attempt to extract a 1D noise function from the original\n// basically all I did here is just inline all the 0.5 coordinates\n// that I was hard-coding prior, then optimize what's left\nfloat tri(float x) { return abs(x-floor(x)-.5); } // triangle wave 0 to 1/2\n\nfloat W(float x) { return 4.*abs(fract(x)-.5) - 1.; } // triangle wave returning -1..1\n\nconst float phi = (1. + sqrt(5.)) / 2.;\n// I had a different idea.  Make a function that bumpifies the input and just call it repeatedly.\n// performs one iteration of a linear fbm\nfloat bump(float x) \n{\n    return W(x);\n    const float a = .11, b = 1./phi;\n    return (1.5 * tri(a * x) + .5 * tri(b * x) - .5) * 2.;\n}\n//        x = tri(x * inversesqrt(3.) - inversesqrt(7.))\n//          + tri(x *        sqrt(2.) - inversesqrt(13.));\n\n// I simply gave up trying to simplify the original jaggy3 function any further\n// since it just became a snarl of nested tri calls\n// the general idea seems to be this:\n// x = tri(munge(x)), repeat until bumpy enough\n// in fact it seems to be a form of fbm with multiscale bump contributions\n// this gets *similar* results to the original, but certainly is not tuned identically\nfloat jaggy(float x)\n{\n    float r = 0., t = 1e-9, s = 1., l = .15;\n    for (int i = 4; i-- > 0; )\n    {\n        r += bump(x * l) * s;\n        t += s;\n        l *= 2. / phi;\n        s *= sqrt(.5); //.5 * phi; //.5 / phi;\n    }\n    return r / t;\n}\n // tuned to keep in -1..1 range\n    //x *= .15; // initial scale\n     // FIXME exp2 is cheap but not that cheap; can just scale each step\n        //float s = exp2(-float(i)) / phi;\n        //float l = exp2(1./phi * float(i));\n/*\n    vec3 p = vec3(x,.5,.5);\n    //float n = dot(tri(p*.15 + tri(p.yzx*.075)), vec3(.444));\n    float n = (tri(x*.15 + -.4625) + .1125 + tri(.075 + tri(x * .075))) * .444; \n    p *= 1.5773;\n    // tracking what goes where during this scrambling is just insane!\n    p.yz = vec2(p.y + p.z, p.z - p.y) * .866;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * .866;\n    //float j = 1.3659418 * x, k = -1.3659418 * x;\n    vec3 v = tri(p.yzx*.1125);\n    //float vx = tri(.1125 * k), w = tri(.1125 * j);\n    n += dot(tri(p*.225 + v), vec3(.222)); \n    //n += .222 * (tri(.225 * j + v) + tri(.225 * k) + tri(w));\n    //n += .222 * (tri(.225 * j + v) + tri(.225 * k + w));\n    return .5 - abs(n-.5) * 2.85;\n*/\n\n// early WIP of jaggy that still has lots of internal vec3 stuff\nfloat jaggy3(float x)\n{\n    // tri(x) is abs(x-floor(x)-.5), so tri(.5) == abs(.5 - 0 - .5) == 0\n    vec3 p = vec3(x, .5, .5);\n    vec3 a = tri(p.yzx*.075);\n    float n = dot(tri(p*.15 + a), vec3(.444));\n    p = p*1.5773;// - n; // The \"n\" mixes things up more.\n    p.yz = vec2(p.y + p.z, p.z - p.y) * .866;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * .866;\n    ///n += dot(tri(p*.225 + tri(p.yzx*.1125)), vec3(.222)); // broke original loc up into parts\n    vec3 v = tri(p.yzx*.1125);\n    n += dot(tri(p*.225 + v), vec3(.222)); \n    return .5 - abs(n-.5)*1.9 * 1.5; // + (1.-abs(sin(n*9.)))*0.05;\n}\n\n// This is a cheap...ish routine - based on the triangle function - that produces a pronounced jagged \n// looking surface. It's not particularly sophisticated, but it does a surprizingly good job at laying \n// the foundations for a sharp rock face. Obviously, more layers would be more convincing. In fact, \n// I'm disappointed that there weren't enough cycles for one more layer. Unfortunately, this is a \n// GPU-draining distance function. The really fine details have been bump mapped.\nfloat surfFunc(vec3 p)\n{    \n    float n = dot(tri(p * .15 + tri(p.yzx * .075)), vec3(.444));\n    p = p * 1.5773;// - n; // The \"n\" mixes things up more.\n    p.yz = vec2(p.y + p.z, p.z - p.y) * .866;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * .866;\n    n += dot(tri(p * .225 + tri(p.yzx * .1125)), vec3(.222)); \n    // You can barely even notice the sine part, \n    // seems just to prevent surface from being perfectly flat,\n    // but all it really does is botch the distance field\n    // and take up processor cycles unnecessarily.\n    return abs(n-.5) * 1.9; // + (1.-abs(sin(n*9.)))*0.05; // Range [0, 1]\n}\n\n// Standard setup for a plane at zero level with a perturbed surface on it.\nfloat map(vec3 p)\n{ \n    return p.y - surfFunc(p) * 1.5;\n}\n\nfloat F(float x)\n{\n//    return jaggy(x); // rewrite as 1D fbm\n    return jaggy3(x); // simplified but still interally 3D\n//    return .5 - surfFunc(vec3(x, .5, .5)) * 1.5; // bypass map entirely\n//    return map(vec3(x, .5, .5)); // a 1D slice of the map function\n}\n\n// iq sdf colorization stolen from https://shadertoy.com/view/ft2SRh\nvec3 ColorSDF(float d)\n{\n    vec3 col = vec3(1) - sign(d)*vec3(.1,.4,.7);\n\tcol *= 1. - exp(-2.*abs(d));\n\tcol *= .8 + .2*cos(128.*abs(d));\n\treturn mix(col, vec3(1), 1.-smoothstep(.0,.015,abs(d)));\n}\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    float r = F(.12 * iTime + u.x*12./iResolution.x);\n    r = r * .5 + .5;\n    float q = ((iResolution.y * r - u.y) / (.5*iResolution.y*abs(dFdx(r)) + 1.)); // + .5); // antialias SDF\n    //vec3 sceneCol = vec3(clamp(q/2., 0., 1.));\n    vec3 sceneCol = ColorSDF(q*2. / iResolution.y);\n\to = vec4(sqrt(max(sceneCol, 0.)), 1); // gamma\n}\n\n\n/* // TODO see also Shane http://shadertoy.com/view/MlXSWX\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz http://shadertoy.com/view/4ts3z2\n// Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n    \n\treturn dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.666));\n}\n*/","name":"Image","description":"","type":"image"}]}