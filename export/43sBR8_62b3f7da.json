{"ver":"0.1","info":{"id":"43sBR8","date":"1728785540","viewed":48,"name":"ray tracing1111","username":"zeutd","description":"1","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int maxTrace = 300;\nconst int maxIterations = 1;\n\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\nstruct Material\n{\n    vec4 albedo;\n    float glowStrength;\n    float smoothness;\n};\nstruct Sphere {\n    float radius;\n    vec3 pos;\n    Material material;\n};\nstruct Plane {\n    vec3 pos;\n    vec3 normal;\n    Material material;\n};\nstruct HitInfo\n{\n    bool hit;\n    float d;\n    vec3 p;\n    vec3  normal;\n    Material material;\n};\nfloat random(inout int seed){\n    seed *= (seed + 9382939) * (seed + 5463725) * (seed + 32673527);\n    return intBitsToFloat(seed) / 4294967295.0;\n}\nfloat randomAngle(inout int seed){\n    return random(seed) * 2. * 3.14;\n}\nvec3 randomDirection(inout int seed){\n    return vec3(cos(randomAngle(seed)), cos(randomAngle(seed)), cos(randomAngle(seed)));\n}\nvec3 randomReflection(inout int seed, vec3 normal){\n    vec3 dir = randomDirection(seed);\n    return dir * sign(dot(normal, dir));\n}\nvec3 specularReflection(vec3 dirIn, vec3 normal){\n    return dirIn - 2. * dot(dirIn, normal) * normal;\n}\nvoid hit(Ray ray, Sphere sphere, inout HitInfo info)\n{\n    float a = dot(ray.dir, ray.dir);\n    float b = 2. * dot(ray.dir, ray.pos - sphere.pos);\n    float c = dot(ray. pos - sphere.pos, ray.pos - sphere.pos) - sphere.radius * sphere.radius;\n    float delta = b*b-4.*a*c;\n    if (delta >= .0)\n    {\n        \n        float d = (-b - sqrt(delta))/2./a;\n        if(d >= 0.){\n            info.hit = true;\n            if(info.d > d){\n                info.p = ray.pos + ray.dir * d;\n                info.d = d;\n                info.material = sphere.material;\n                info.normal = normalize(info.p - sphere.pos);\n            }\n        }\n    }\n}\nvoid hit(Ray ray, Plane plane, inout HitInfo info)\n{\n    float d = -dot(ray.pos - plane.pos, plane.normal) / dot(ray.dir, plane.normal);\n    if(d > 0.){\n        info.hit = true;\n        if(info.d > d){\n            info.d = d;\n            info.p = ray.pos + ray.dir * d;\n            info.normal = plane.normal;\n            info.material = plane.material;\n        }\n    }\n}\nvec3 lerp(vec3 a, vec3 b, float prog){\n    return a * (1. - prog) + b * prog;\n}\nconst int sphereCount = 5;\nconst int planeCount = 2;\nHitInfo hit(Ray ray){\n    Sphere spheres[sphereCount];\n    spheres[0] = Sphere(0.1, vec3(cos(0.6) / 2., sin(0.6) / 2., 1.), Material(vec4(0.,1.,1.,1.), 0., 0.));\n    spheres[1] = Sphere(0.1, vec3(cos(0.) / 2., sin(0.) / 2., 1.), Material(vec4(1.,1.,1.,1.), 0., 1.));\n    spheres[2] = Sphere(10., vec3(0, 10, -10), Material(vec4(1.,1.,1.,1.), 3., 0.));\n    spheres[3] = Sphere(.1, vec3(0, 0.2, 1), Material(vec4(1.,0.,0.,1.), 0., 0.1));\n    spheres[4] = Sphere(.07, vec3(0, -0.13, 1.3), Material(vec4(0.,1.,0.,1.), 0., 0.1));\n    Plane planes[planeCount];\n    planes[0] = Plane(vec3(0., -0.3, 0.), vec3(0., 1., 0.), Material(vec4(1.,1.,1.,0.), 0., 0.1));\n    planes[1] = Plane(vec3(0., 0, 10), vec3(0., 0, 1), Material(vec4(1.,1.,1.,0.), 0., 0.3));\n    Material defaultMaterial = Material(vec4(0.,0.,0.,0.), 0., 0.);\n    HitInfo info = HitInfo(false, 100000., vec3(0.,0.,0.), vec3(0., 0., 0.), defaultMaterial);\n    for(int i = 0; i < sphereCount; i++){\n        hit(ray, spheres[i], info);\n    }\n    for(int i = 0; i < planeCount; i++){\n        hit(ray, planes[i], info);\n    }\n    return info;\n}\nvec4 trace(Ray ray, inout int seed){\n    vec4 rayColor = vec4(1., 1., 1., 1.);\n    vec4 result = vec4(0., 0., 0., 1.);\n    for(int i = 0; i < maxTrace; i++){\n        HitInfo info = hit(ray);\n        if(info.hit){\n            ray.pos = info.p;\n            vec3 diffuse = normalize(info.normal + randomReflection(seed, info.normal));\n            vec3 specular = specularReflection(ray.dir, info.normal);\n            ray.dir = lerp(diffuse, specular, info.material.smoothness);\n            Material material = info.material;\n            vec4 light = material.glowStrength * material.albedo;\n            rayColor *= material.albedo;\n            result += rayColor * light;\n        }\n        else{\n            break;\n        }\n    }\n    return result;\n}\nvec4 color(Ray ray, inout int seed, vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 prev = texture(iChannel0, uv);\n    vec4 col = vec4(0., 0., 0., 0.);\n    float w = 1. / (prev.w + 1.);\n    //float w = 1. / (iTime + 1.);\n    vec4 traced = vec4(0., 0., 0., 1.);\n    for(int i = 0; i < maxIterations; i++){\n        traced += trace(ray, seed);\n    }\n    traced /= intBitsToFloat(maxIterations);\n    col = prev * (1. - w) + trace(ray, seed) * w;\n    col.w = prev.w + 1.;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int seed = floatBitsToInt(fragCoord.x + fragCoord.y * iResolution.x) + iFrame * 9999;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = vec3(0.0, 0.0, 1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    Ray ray = Ray(camPos, rayDir);\n    fragColor = color(ray, seed, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}