{"ver":"0.1","info":{"id":"NslBR7","date":"1644625438","viewed":114,"name":"Koch Grid","username":"mAmaro","description":"kaleidoscopic iterative function system\n\nvariant of what is taught here by Art of Code:\nhttps://www.youtube.com/watch?v=il_Qg9AqQkE","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractalkochkifsgrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//NOTE(): Show how bending space of uv coordinates are can be used\n//        to tiles arbitrary shapes. This will use a Koch curve.\n\n#define PI32 3.141592653589793238462\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n/*\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n*/\nvec2 GetNormal(float angle)\n{\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u_time = iTime;\n    vec2 u_mouse = iMouse.xy;\n\n    vec2 u_resolution = iResolution.xy;\n    \n    float scale = 1.5;\n    vec2 st = fragCoord.xy/u_resolution.xy; //NOTE: Normalization\n    st.x *= u_resolution.x/u_resolution.y; //NOTE(): Aspect ratio adjustment\n    vec2 uv = (fragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y; //NOTE(): Aspect ratio adjustment and normailization\n    uv *= scale;\n    vec2 mouse = (u_mouse.xy / u_resolution.xy)* 4.0 - 2.0;\n    mouse.x = min(abs(mouse.x),1.0);\n    mouse.y = min(abs(mouse.y),1.0);\n    vec3 color = vec3(0.0);\n    //-----\n \n    uv.y += tan((5.0/6.0) *PI32 ) * 0.5;\n    uv.x = abs(uv.x);\n    vec2  normal = GetNormal(mouse.x * (5.0/6.0)* PI32);\n    float dist   = dot(uv, normal);\n    uv -= normal * max(0.0, dot(uv - vec2(0.5, 0.0), normal)) * 2.0;\n    \n    color.rg +=  max(0.5 * (sin(uv  + iTime) + 1.0), 0.6);\n    \n    color += smoothstep(0.001 + abs(dist) - 0.5 * normal.x , 0.0, abs(dist) - 0.5 * normal.x);\n    \n    //-----    \n    \n    /*\n     Drawing a line segment.\n     The way this works is by defining a range [-0.5, 0.5] and we look at the uv value\n     of the fragment and compared it to the range. If the fragment is in range it is not\n     changed by the clamp function. This means there are 2 cases uv is not clamped and uv is \n     clamped. Let's say uv is is not clamped. We take the difference of the uv and the uv after\n     using clamp(which did nothing) which will end giving us a vector(0, 0). Then we get the\n     distance of that uv(0,0) and the origin(0,0) which is zero. That gives us the value of our\n     fragment, Black\n     If the uv for the frag is outside then it is clamped which give us a length greater than zero.\n     The steps above are repeated and the result is a distance a greater than 0 for pixel farther from\n     the range. These framents are white.\n    */\n    \n    float uvcompression = 1.0;\n    normal = GetNormal(mouse.y * (2.0/3.0)*PI32);\n    uv.x += 0.5;\n    for(int i=0; i<3; i++)\n    {\n        uv *= 3.0;\n        uvcompression *= 3.0;\n        uv.x -= 1.5;\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv -= normal    * min(0.0, dot(uv, normal)) * 2.0;\n        //    rotation    mask (reflection)\n    }\n    \n    dist = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0));\n\tcolor += min(0.6, dist); //NOTE(): Original line\n    color += smoothstep(1.0/u_resolution.y, 0.0, dist/uvcompression); //TODO(): Explain this\n    \n    vec3 grid = vec3(0.1);\n    grid.rg -= smoothstep(1.0, 0.8, 1.0 - fract(uv * 10.0) + 0.03);\n    grid.gr += smoothstep(0.1, 0.094, 1.0 - fract(uv) + 0.08);\n    grid.gb -= smoothstep(0.01, 0.0, uv.x);\n    \n    color += grid;\n    uv /= uvcompression;\n    color += texture(iChannel0, uv * 2.0-u_time*0.2).rgb * 0.3;\n    \n    \n    fragColor = vec4(color,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}