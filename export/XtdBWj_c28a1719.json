{"ver":"0.1","info":{"id":"XtdBWj","date":"1541083906","viewed":100,"name":"Funky Penguin","username":"Moosichu","description":"Let's see what I can make!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) -r;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n \nfloat SDF(vec3 pos)\n{\n    float head = sdSphere(pos - vec3(-7, 20, -10), 15.0);\n    {\n        mat4 beakT = rotationMatrix(vec3(-7, 2, 1), 2.0);\n        vec4 beakPos = beakT * vec4(pos, 1);\n        beakPos += vec4(6, -22, -19, 0);\n    \tfloat beak = sdCappedCone(beakPos.xyz, 10., 10., 2.);\n        head = opSmoothUnion(head, beak, 1.);\n    }\n        \n    {\n        float eye = sdSphere(pos - vec3(0, 23, -23), 2.0);\n        head = opSmoothUnion(head, eye, 1.);\n        \n    }\n  \n    \n    \n    float crowBody = sdSphere(pos - vec3(5, -5, 5), 30.);\n   \n    float fullShape = opSmoothUnion(crowBody, head, 5.);\n     \n    return fullShape;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = SDF(pos);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3( SDF(pos + eps_zero.xyy), SDF(pos + eps_zero.yxy), SDF(pos + eps_zero.yyx) ) - c);\n}\n\n\nconst float threshold = .01;\nconst int maxIter = 70;\nconst float maxDist = 1000.;\n\nfloat EvaluateSDF(in vec3 rayDir, inout vec3 pos, float maxDist)\n{\n    float distTravelled = 0.;\n\tfor(int i = 0; i < maxIter && distTravelled < maxDist; i++)\n    {\n        vec3 currentPos = pos + (rayDir * distTravelled );\n     \tfloat SDF_val = SDF(currentPos);\n        if(SDF_val < threshold)\n        {\n            pos = currentPos;\n         \treturn distTravelled;   \n        }\n        distTravelled += SDF_val;\n    }\n    return -1.;\n}\n\nvec3 Sky(vec3 rayDir)\n{\n    return vec3(0.30, 0.36, 0.60) - (rayDir.y * 0.7);\n}\n\nstruct Material\n{\n    vec3 ambientCol;\n    vec3 specularCol;\n    vec3 diffuseCol;\n};\n\nstruct PointLight\n{\n \tvec3 pos;\n    vec3 col;\n};\n    \n    \nconst int numLights = 1;    \nPointLight pointLights[numLights];\n\nvec3 Surface(float dist, vec3 inDir, vec3 pos, vec3 norm, vec3 refl, Material mat)\n{\n    pointLights[0].pos = vec3(60, -1, -10);\n    pointLights[0].col = vec3(1, 1, 1);\n    \n    \n    vec3 finalCol = mat.ambientCol;\n    for(int lightIndex = 0; lightIndex < numLights; lightIndex++)\n    {\n     \tPointLight pointLight = pointLights[lightIndex];\n        \n        vec3 rayToLight = pointLight.pos - pos;\n        vec3 rayToLightNorm = normalize(rayToLight);\n        vec3 lightProbePos = pos + (norm * threshold * 1.1);\n        if(EvaluateSDF(rayToLightNorm,lightProbePos, length(rayToLight)) < 0.)\n        {\n        \n            // diffuse\n            {\n                float dotRes = dot(normalize(rayToLight), norm);\n                if(dotRes > 0.)\n                {\n                    vec3 diffuse = dotRes * pointLight.col * mat.diffuseCol;\n                    finalCol += diffuse;\n                }\n            }\n            // specular\n            {\n             \tfloat dotRes = dot(rayToLightNorm, inDir);\n                if(dotRes > 0.)\n                {\n                    vec3 specular = dotRes * pointLight.col * mat.specularCol;\n                    finalCol += specular;\n                }\n            }\n           \n\n        }\n    }\n    return finalCol;\n}\n\nvec3 render(in vec3 rayDir, in vec3 origin)\n{\n    vec3 pos = origin;\n    float dist = EvaluateSDF(rayDir, pos, maxDist);\n    \n    vec3 col = vec3(0.);\n    if(dist < 0.)\n    {\n        col = Sky(rayDir);\n    } else {\n        vec3 N = calcNormal(pos);\n        vec3 reflDir = reflect(rayDir, N);\n        \n        col = (reflDir * vec3(0.5) + vec3(0.5)) * vec3(.3, .05, .05);\n        \n        Material m;\n        m.ambientCol = vec3(0.1);\n        m.specularCol = vec3(0.5);\n        m.diffuseCol = vec3(.5, .3, .7);\n        //col = Surface(dist, rayDir, pos, N, reflDir, m);\n        //col = vec3(1. - dist * .0075);\n        \n    }\n    \n    col = pow(col, vec3(0.4545)); // Gamma correction\n    return col;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord)/ iResolution.y;\n\n    vec3 camPos = vec3(0., 0., -100.);\n    vec3 camTarget = vec3(0., 0., 0.);\n    \n    vec3 ray = getCameraRayDir(uv, camPos, camTarget);\n    vec3 pos = camPos;\n    fragColor = vec4(render(ray, pos), 0);\n\n}\n","name":"Image","description":"","type":"image"}]}