{"ver":"0.1","info":{"id":"ld3SDn","date":"1465392378","viewed":163,"name":"wave of balls","username":"bitek","description":"calculating intersections with spheres using dot products of view port rays and a sphere centre","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracinganalytical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// A textured spheres scene.\n// (c) 2016, Viktor Korsun.\n//\n// The shader is provided \"as is\", with no warranty of any kind, uner MIT license.\n// https://opensource.org/licenses/MIT.\n//\n\nconst float spheresCount = 40.0;\nconst float spread = 6.0;\n\nconst float initialDistance = 300.0;\nconst float aureole = 2.5;\nconst float speed = 0.05;\nconst float initialSize = 0.5;\n\n\nvec4 getSphere(float sphereNo, float time)\n{\n\tfloat lifetimedelta = sphereNo / spheresCount;\n    \n    time *= speed;\n\n    float lifetimeDiv = floor(time + lifetimedelta);\n    float lifetimeFrac = time + lifetimedelta - lifetimeDiv;\n\n\tsphereNo = sphereNo + lifetimeDiv * spheresCount;\n    \n    if (sin(sphereNo * 3.141) > 0.0) {sphereNo += spheresCount;};\n    \n    float x = sin(sphereNo/6.0)*spread;\n    float y = sin(sphereNo/7.0)*spread;\n    return vec4(x, y, initialDistance - lifetimeFrac * initialDistance, abs(sin(sphereNo*3.0))*initialSize + initialSize);\n}\n\nvec3 intersects(vec3 src, vec3 direction, float globalTime)\n{   \n    float alpha = sin(iTime * speed * 2.0) * 0.1;\n\tmat2 rotation = mat2(cos(alpha), -sin(alpha), sin(alpha), cos(alpha));\n    \n    float z = 0.0;\n    \n\tfloat minDistance = initialDistance;\n    vec4 final_sphere;\n    vec3 final_point;\n    \n \tvec3 normDirection = normalize(direction);\n    float aura = 0.0;\n\n    for (float sphereNo = 0.0; sphereNo < spheresCount; sphereNo++) {\n\t    vec4 sphere = getSphere(sphereNo, globalTime);\n        vec4 oldSphere = sphere;\n        \n        sphere.xz = sphere.xz * rotation;\n        \n        sphere.x += sin(iTime*4.2*speed) * 8.0;\n        sphere.y += sin(iTime*3.0*speed) * 7.0;\n        \n        vec3 tcenter = sphere.xyz - src;\n                \n\t\tfloat centerProjectionLength = dot(tcenter, normDirection);\n\t\tvec3 projectionPoint = centerProjectionLength * normDirection;\n        vec3 projection = sphere.xyz - projectionPoint;\n\t    float l = length(projection);\n        if (l < sphere.a)\n        {\n\t\t\tfloat deltaToIntersection = sqrt(sphere.a*sphere.a - l*l);\n\t\t\tvec3 intersection = projectionPoint - deltaToIntersection * normDirection;\n\t\t\tif (minDistance > length(intersection))\n            {\n                minDistance = length(intersection);\n\t            final_sphere = oldSphere;\n    \t        final_point = sphere.xyz - intersection;\n                z = final_sphere.z;\n            }\n            \n        } else {\n            if (l < aureole)\n\t\t\t\taura += pow(((aureole - l) / aureole), 3.0) * (1.0 - smoothstep(0.0, initialDistance, oldSphere.z) / 4.0);\n        }\n    }\n\n    vec3 result = vec3(0,0,0);\n    vec3 light = vec3(0,0,1);\n    light.xz = light.xz * rotation;\n        \n    vec3 mapped = final_point;\n    vec3 compSphere = vec3(\n            pow(sin(sin(mapped.x*30.0) * sin(final_sphere.x*100.0)*20.0 + sin(mapped.y*20.0)*2.0 + sin((mapped.x + mapped.y)*20.0) * 3.0), 4.0),\n            pow(abs(sin(mapped.y * (4.0 + sin(final_sphere.y * 10.0) * 10.0) + mapped.x * 4.0 + sin(mapped.x * 5.0 + mapped.y) * 1.0)), 50.0) / 2.0,\n            pow(abs(sin(mapped.x + sin(mapped.y*4.0 + final_sphere.a * 100.0) * 2.0)), 40.0)\n        );\n    \n    compSphere *= 50.0;\n    compSphere += sin(mapped.z);\n    \n    vec3 aureole = vec3(aura, aura / 2.0,aura / 4.0) / 3.0;\n\n    float space = (pow(abs(dot(normalize(direction), normalize(light))), 12.0));\n    vec3 compSpace = vec3(space, space, space);\n    float blend = smoothstep(0.0, initialDistance, z);\n    \n    if (minDistance < initialDistance) {\n        result = (1.0 -  blend) * compSphere;\n      \tresult += compSpace * blend;\n    } else {\n        result = compSpace;\n        result += aureole * (1.0 - blend);\n    }\n\n    return result;\n}\n\nvec4 ray(vec3 src, vec3 direction, float globalTime)\n{\n\treturn vec4(intersects(src, direction, globalTime), 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv_n = vec2(uv.x, uv.y / ratio);\n\n\tvec3 initialPosition = vec3(uv_n, 0);\n    vec3 direction = initialPosition+vec3(uv_n, 5.0 - length(uv_n.xy));\n\t    \n    fragColor = ray(initialPosition, direction, iTime);\n}","name":"Image","description":"","type":"image"}]}