{"ver":"0.1","info":{"id":"lX3Szl","date":"1722128841","viewed":64,"name":"A Small Pool","username":"Joshy20XX","description":"I wanted to see if I could simulate water ripples on a object. With the help of the Art of Code YouTube channel, I created a noise map that displaces the water and added some other effects. Tutorial reference and update log in the code comments. =)","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["beginner","water","pool","wonders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**********************************************************************\n*   Author: Joshy20XX, Date: 7/27/24\n*   A small pool of rippling water to test out displacement with noise\n*   Tutorial Reference: Go to buffer A to find the link\n*\n*   Update (7/30/24): Added a sphere to showcase hi/low-res reflections.\n*   You can always remove it by commenting \"res = opU(res, sphere1)\" in\n*   the map function below. Reflection options are in the \"render\" codeblock.\n***********************************************************************/\n#define rtime iTime\n#define PI 3.14159265359\n#define ZERO min(iFrame, 0)\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 150.0;\nconst float PRECISION = 0.001;\nconst float REFLECT_PRECISION = 0.002;\nconst vec3 COLOR_BACKGROUND = vec3(0.702,0.894,0.976);\n\n//X rotation\nmat3 rotX(float theta) {\n    return mat3 (\n        vec3(1, 0, 0),\n        vec3(0, cos(theta), -sin(theta)),\n        vec3(0, sin(theta), cos(theta))\n    );\n}\n\n//Y rotation\nmat3 rotY(float theta) {\n    return mat3 (\n        vec3(cos(theta), 0, sin(theta)),\n        vec3(0, 1, 0),\n        vec3(-sin(theta), 0, cos(theta))\n    );\n}\n\n//Z rotation\nmat3 rotZ(float theta) {\n    return mat3 (\n        vec3(cos(theta), -sin(theta), 0),\n        vec3(sin(theta), cos(theta), 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//2D rotation\nmat2 rot2D(float theta) {\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\n//Identity matrix\nmat3 identity() {\n    return mat3 (\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAt) {\n    vec3 cam_dir = normalize(lookAt - cameraPos);\n    vec3 cam_right = normalize(cross(vec3(0, 1, 0), cam_dir));\n    vec3 cam_up = normalize(cross(cam_dir, cam_right));\n    \n    return mat3(-cam_right, cam_up, -cam_dir);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  float d = length(p) - r;\n  return d;\n}\n\nfloat sdFloor(vec3 p) {\n  float d = p.y + 1.;\n  return d;\n}\n\nfloat sdfBox(vec3 p, vec3 b) {\n    b.y -= 3.;\n    b.x += 1.;\n    b.z += 1.2;\n    p.y -= -0.4;\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfBox2(vec3 p, vec3 b) {\n    b.y -= 1.7;\n    p.y -= .7;\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat pillar(vec3 p, vec3 b) {\n    b.y += 10.;\n    b.x += -1.5;\n    b.z += -1.2;\n    \n    p.xz = abs(p.xz);\n    p.xz -= 45.;\n    p.xz *= rot2D(sin(p.y) / 2.);\n    \n    \n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat pillar2(vec3 p, vec3 b) {\n    b.y += 10.;\n    b.x += -1.5;\n    b.z += -1.2;\n    \n    p.xz = abs(p.xz);\n    p.xz -= 25.;\n    p.xz *= rot2D(sin(p.y) / 2.);\n    \n    \n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat water(vec3 p, vec3 b) {\n    b.y += .5;\n    b.x += .75;\n    b.z += .9;\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - (3. * t.x), p.y);\n  return length(q) - t.y;\n}\n\nvec3 twist(vec3 p) {\n    vec3 q = (rotX(1.) * (2. * cos(rtime/.5))) * vec3(sin(p.y) * .2);\n    return q;\n}\n\nfloat disp(vec3 p) {\n    vec2 uv = vec2((sin((p.x) * .2))/6.2832, p.z/24.5) + .2;\n    float displace = texture(iChannel1, uv).r;\n    return displace;\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\n\nfloat smin(float a, float b, float k)\n{\n    k *= 1.0;\n    float r = exp2(-a / k) + exp2(-b / k);\n    return -k * log2(r);\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.); // ID = 0\n  vec2 flooring = vec2(sdFloor(p), 0.5); // ID = 0.5\n  vec2 box1 = vec2(sdfBox(p, vec3(5.)), 3.5);\n  vec2 sphere1 = vec2(sdSphere(p - vec3(0., 7., 0.), 2.), 2.5);\n  vec2 box2 = vec2(sdfBox2(p, vec3(4.5)), 2.5);\n  vec2 pool = vec2(float(max(box1, -box2)), 3.5);\n  vec2 water = vec2(water(p - disp(p) - vec3(-.1, -4.5, .0), vec3(4.5)), 4.5);\n  vec2 pillar = vec2(pillar(p - vec3(0., 4., 0.), vec3(3.)), 5.5);\n  vec2 pillar2 = vec2(pillar2(p - vec3(0., 4., 0.), vec3(3.)), 5.5);\n\n  res = opU(res, flooring);\n  //res = opU(res, box1);     //Revealing the secrets eh?\n  //res = opU(res, box2);\n  res = opU(res, pool);\n  res = opU(res, water);\n  res = opU(res, pillar);\n  res = opU(res, pillar2);\n  res = opU(res, sphere1);\n  \n  return res; // the y-component is the ID of the object hit by the ray\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, float side) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p) * side; // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (abs(res.x) < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\nvec2 rayMarch_ref_low(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p); // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (abs(res.x) < REFLECT_PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\n//This is based on playbyan1453's shader that uses a simplified version\n//of the Enhanced Sphere Tracing paper: https://www.shadertoy.com/view/ft3GDX\nvec2 rayMarch_ref_hi(vec3 ro, vec3 rd)\n{\n    float d = MIN_DIST; //depth adds to the sdf x-component\n    vec2 res = vec2(0.0);\n    float id = 0.0;\n    float radius = 0.;\n    float last_radius = 0.;\n    float relax = .5;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        if (res.x > MAX_DIST) break;\n        vec3 p = ro + rd * d; //Create a sample point\n        res = map(p); // Get the distance from the camera to the object\n        \n        if (relax != 1.0 && abs(radius) + abs(res.x) < last_radius) {\n            res.x += (1. - relax) * last_radius;\n            relax = 1.;\n            continue;\n        }\n        \n        if (res.x < MIN_DIST) break;\n        d += res.x * relax;\n        last_radius = relax * d;\n        radius = d;\n        //if (res.x < PRECISION || res.x > MAX_DIST) break;\n        id = res.y;\n        \n    }\n    return vec2(d, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.yxy * map(p + e.yxy).x +\n      e.xxx * map(p + e.xxx).x);\n}\n\nvec3 getRefColor(in vec3 ro, in vec3 rd, float id, vec3 normal) {\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - ro);\n    vec3 attenuation = vec3(1.0);\n    float dif = clamp(dot(normal, lightDirection), 0.5, 1.);\n    float frensel = pow(clamp(1. - dot(normal, -rd), 0., 5.), 5.);\n    attenuation *= 0.5;\n    vec3 sceneColor = dif * attenuation;\n    vec3 difColor = vec3(0.761,0.000,0.000);\n    \n    if (id > 0.) sceneColor = dif * vec3(0.2 + .3*mod(floor(ro.x) + sin(ro.z), 2.0));\n    if (id > 1.) sceneColor = dif + 9. * vec3(1.000,0.000,0.000);;\n    if (id > 2.) sceneColor = (dif * difColor) + frensel * vec3(0.000,0.059,0.400);\n    \n    return sceneColor;\n}\n\n/* Soft shadowing component using an optimized version from IQ\nhttps://iquilezles.org/articles/rmshadows/ */\n\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float maxt, float w) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 256 && t < maxt; i++ )\n    {\n        float h = float(map(ro + t * rd));\n        res = min(res, h/(w * t));\n        t += clamp(h, 0.009, 0.50);\n        if (res < -1.0 || t > maxt) break;\n    }\n    res = max(res, -1.0);\n    return 0.25 * (1.0 + res) * (1.0 + res) * (2.0 - res);\n}\n\n/* Ambient Occlusion code borrowed from IQ's raymarching primitives shader\nhttps://www.shadertoy.com/view/Xds3zN */\n\nfloat raymarchAO(in vec3 p, in vec3 normal) {\n    float occlusion = 0.0;\n    float scale = 1.0;\n    \n    for (int i = ZERO; i < 5; i++) {\n        float h = 0.01 + 0.12 * float(i)/4.0;\n        float d = map(p + h * normal).x;\n        occlusion += (h - d) * scale;\n        scale *= 0.95;\n        if (occlusion > 0.35) break;\n    }\n    return clamp(1.0 - 3.0 * occlusion, 0.0, 1.0) * (0.5 + 0.5 * normal.y);\n}\n\n//Render reflection function: hi/low res\nvec3 lowResRef(vec2 res, vec3 col, vec3 p, vec3 ro, vec3 rd, float d) {\n    // get ray direction\n    vec3 ref_Rd = rd;\n    vec3 ref_Ro = ro;\n    vec3 ref_Normal = calcNormal(p);\n    \n    //render reflection \n    ref_Ro += ref_Rd * d;\n    \n    ref_Rd = reflect(ref_Rd, ref_Normal);\n    res = rayMarch_ref_low(ref_Ro + ref_Normal * .003, ref_Rd);\n    \n    //reflection display and color\n    float d_ref = res.x;\n    float ref_id = res.y; //the id of the reflected object\n    col += getRefColor(ref_Ro, ref_Rd, ref_id, ref_Normal);\n    \n    return vec3(d_ref) + col; //return reflection material\n}\n\nvec3 hiResRef(vec2 res, vec3 col, vec3 p, vec3 ro, vec3 rd, float d) {\n    // get ray direction\n    vec3 ref_Rd = rd;\n    vec3 ref_Ro = ro;\n    vec3 ref_Normal = calcNormal(p);\n    \n    //render reflection \n    ref_Ro += ref_Rd * d;\n    \n    ref_Rd = reflect(ref_Rd, ref_Normal);\n    res = rayMarch_ref_hi(ref_Ro + ref_Normal * .003, ref_Rd);\n    \n    //reflection display and color\n    float d_ref = res.x;\n    float ref_id = res.y; //the id of the reflected object\n    col += getRefColor(ref_Ro, ref_Rd, ref_id, ref_Normal);\n    \n    return vec3(d_ref) + col; //return reflection material\n}\n\nvec3 refracted(vec3 p, vec2 res, vec3 col, vec3 ro, vec3 rd, float d) {\n    /* My first time figuring out refraction rendering with trial and error.\n    It's not a proper refraction but it works in this case. */\n    \n    vec3 refract_ro = ro;\n    vec3 refract_rd = rd;\n    vec3 refract_norm = calcNormal(p);\n    float waterIOR = 1.33;\n    \n    refract_ro += refract_rd * d;\n    res = rayMarch(refract_ro, refract_rd, 1.);\n    \n    refract_norm = calcNormal(p);\n    refract_ro += refract_rd * .01;\n    res = rayMarch(refract_ro, refract_rd, -1.);\n    refract_rd = refract(refract_rd, refract_norm, 1./waterIOR);\n    \n    refract_norm = -calcNormal(p);\n    refract_ro += refract_rd * .01;\n    res = rayMarch(refract_ro, refract_rd, -1.);\n    refract_rd = refract(refract_rd, refract_norm, 1./waterIOR);\n    \n    float refract_buffer = res.x;\n    return col * refract_buffer;\n    \n}\n\nfloat BeersLaw(float absorption_factor, float absorptionDistance) {\n    return exp(-absorption_factor * absorptionDistance);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 col = COLOR_BACKGROUND;\n    \n    //Trace ray\n    vec2 res = rayMarch(ro, rd, 1.);\n    float d = res.x; // signed distance value\n    if (d > MAX_DIST) return col; // render background color since ray hit nothing\n    \n\tfloat id = res.y; // id of object\n    \n    vec3 p = ro + rd * d; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(7, 45, 25);\n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    //Material properties\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n    float frensel = pow(clamp(1. - dot(normal, -rd), 0., 5.), 5.); //Render SDF with Frensel model\n    \n    //Two reflection options\n    //-------------------------//\n    //Uncomment the first line for regular low-res mode\n    vec3 reflection = lowResRef(res, col, p, ro, rd, d);\n    \n    //Uncomment the second line for a higher res mode\n    //vec3 reflection = hiResRef(res, col, p, ro, rd, d);\n    //------------------------------------------------------//\n    \n    vec3 refraction = refracted(p, res, col, ro, rd, d) * BeersLaw(.06, 60.3);\n    vec3 difColor = vec3(0.039,0.678,1.000);\n    vec3 difColor2 = vec3(0.020,0.039,0.137);\n    \n    //Testing textures\n    vec3 colXZ = texture(iChannel0, p.xz *.5 + .5).rgb;\n    vec3 colYZ = texture(iChannel0, p.yz *.5 + .5).rgb;\n    vec3 colXY = texture(iChannel0, p.xy *.5 + .5).rgb;\n    vec3 tex_normal = abs(normal);\n    vec3 r = normalize((colXY * colXZ * colYZ) * p);\n    tex_normal *= pow(tex_normal, vec3(19));\n    tex_normal /= tex_normal.x + tex_normal.y + tex_normal.z;\n    vec3 difTexture = (colYZ*tex_normal.x + colXZ*tex_normal.y + colXZ*tex_normal.z); //Texture material\n    \n    // Let's draw some shadows. Technique reference in the shadowing and AO functions above.\n    float softShadow = clamp(softShadow(p, lightDirection, 0.02, 10., 0.019), 0.1, 1.0);\n    float ambientOcclusion = raymarchAO(p, normal);\n    \n    if (id > 0.) col = dif * vec3(0.2 + .3*mod(floor(p.x) + sin(p.z), 2.0)); //tiled floor\n    //if (id > 1.) col = (dif + difTexture) * vec3(0.780,1.000,0.957); //Front sdf sphere\n    if (id > 2.) col = (dif * difColor) * reflection * vec3(0.451,0.451,0.451); //Middle sdf sphere\n    if (id > 3.) col = (dif * difColor + -.2) * reflection + frensel * vec3(0.000,0.000,0.000);\n    if (id > 4.) col = (dif * difColor2 + (frensel / 2.5)) * refraction;\n    if (id > 5.) col = (dif) * vec3(0.845,0.83,0.75);\n    \n    col += COLOR_BACKGROUND * 0.2 * softShadow * ambientOcclusion; // add a bit of the background color to blend objects more with the scene\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 uv2 = (fragCoord-.0*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  vec3 lp = vec3(0., 3.5, .5); \n  vec3 ro = vec3(.7, 4.5, -1); // ray origin that represents camera position\n  \n  float cameraRadius = 3.5;\n  ro.yz = ro.yz * cameraRadius * rot2D(mix(PI/2., 0., mouseUV.y));\n  ro.xz = ro.xz * rot2D(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n  \n  /*Uncomment these line to get auto 360 rotation\n  -----------------------------------------------*/\n  //ro.x = cameraRadius * cos(iTime) + lp.x;\n  //ro.z = cameraRadius * sin(iTime) + lp.z; \n  \n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  vec3 col = render(ro, rd, uv);\n  //vec3 col = texture(iChannel1, uv2 * .5).rgb;\n  //col /= normalize(col);\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Learnt value noise from the Art of Code tutorial:\n//https://www.youtube.com/watch?v=zXsWftRdsvU&list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5&index=18\n\n#define rtime iTime\n\nfloat hash(vec2 p) {\n    return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);\n}\n\nfloat smoothnoise(vec2 uv) {\n    \n    vec2 lv = fract(uv * 2.5);\n    vec2 id = floor(uv * 2.5);\n    \n    lv = lv*lv*(3.-2.*lv);\n    float bl = hash(id);\n    float br = hash(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = hash(id + vec2(0,1));\n    float tr = hash(id + vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat smoothnoise2(vec2 uv) {\n    float j = .5;\n    float noise = smoothnoise(uv * 4.);\n    \n    for (float i = 8.; i < 128.; i *= 2.) {\n        noise += smoothnoise(uv * i) * j;\n        j *= pow(j, 2.);\n        \n    }\n    \n    return noise / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x += iTime/12.;\n    \n    float noise = smoothnoise2(uv * 2.);\n    \n    vec3 color = vec3(noise); \n    fragColor = vec4(color, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}