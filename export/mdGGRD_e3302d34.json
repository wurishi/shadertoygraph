{"ver":"0.1","info":{"id":"mdGGRD","date":"1678239268","viewed":354,"name":"3D Texture Volume Rendering","username":"PrzemyslawZaworski","description":"I have written the code of basic 3D texture volume rendering, and my AI assistant has written the comments below the source code. We are the perfect team !","likes":8,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","volume","tutorial","cube","texture","beginner","voxel","intersection","volumetric","box","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float _Alpha = 1.0;\nconst vec3 _SliceMin = vec3(-0.51,-0.51,-0.51);\nconst vec3 _SliceMax = vec3( 0.51, 0.51, 0.51);\n\n// http://http.download.nvidia.com/developer/presentations/2005/GDC/Sponsored_Day/GDC_2005_VolumeRenderingForGames.pdf\nbool IntersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)\n{\n\tvec3 invR = 1.0 / rd;\n\tvec3 tbot = invR * (boxmin.xyz - ro);\n\tvec3 ttop = invR * (boxmax.xyz - ro);\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\treturn (tnear > tfar) ? false : true;\n}\n\nmat3 RotationY(float y) \n{\n\treturn mat3(cos(y),0.0,-sin(y),0.0,1.0,0.0,sin(y),0.0,cos(y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3(0.0, sin(iTime * 0.33), -1.8) * RotationY(iTime);\n\tvec3 rd = normalize(vec3(uv, 2.0)) * RotationY(iTime);\n\tvec4 color = vec4(0.0);\n\tfloat near = 0.0, far = 0.0;\n\tbool hit = IntersectBox(ro, rd, vec3(-0.5), vec3(0.5), near, far);\n\tif (hit)\n\t{\n\t\tfloat stepSize = 0.01;\n\t\tfor(float t = near; t < far; t += stepSize)\n\t\t{\n\t\t\tvec3 p = ro + t * rd;\n\t\t\tvec4 s = texture(iChannel0, p + vec3(0.5));\n            s.a *= _Alpha;\n\t\t\tbool insideSlice = all(greaterThan(p, _SliceMin)) && all(lessThan(p, _SliceMax));\n\t\t\tfloat weight = (1.0 - color.a) * s.a;\n\t\t\tcolor.rgb += insideSlice ? weight * s.rgb : vec3(0.0);\n\t\t\tcolor.a += insideSlice ? weight : 0.0;    \n\t\t}\n\t}\n\tfragColor = vec4(color.rgb, 1.0); \n}\n\n/*\nThese lines of code are implementing a basic volume rendering algorithm using ray marching.\n\nThe constant vectors _SliceMin and _SliceMax define the bounding box that limits the region \nwhere the volume data is rendered.\n\nThe IntersectBox function is used to test whether a given ray intersects with the volume. \nIt takes in the ray origin and direction, and the minimum and maximum corners of the bounding box as input, \nand returns the distances tnear and tfar from the ray origin to the near and far intersection points, \nrespectively. It also returns a boolean value indicating whether the ray intersects the box or not.\n\nThe RotationY function returns a 3x3 matrix representing a rotation of the given angle y around the y-axis.\n\nThe mainImage function is the main entry point of the shader. \nIt takes in the output color fragColor and the current pixel coordinates fragCoord as input, \nand outputs the final color value.\n\nWithin mainImage, the following steps are performed:\n* Compute the normalized ray direction rd based on the current pixel coordinates and the current time iTime.\n* Compute the ray origin ro based on the current time iTime.\n* Test whether the ray intersects the volume using IntersectBox.\n* If the ray intersects the volume, loop over the ray from the near intersection point to the far intersection \n  point in small steps, and at each step:\n\t* Sample the volume data at the current position p using texture.\n\t* Check whether the current position is inside the slice region defined by _SliceMin and _SliceMax.\n\t* Compute the weight of the current sample based on its opacity and the current accumulated \n      opacity of the ray.\n\t* Accumulate the color and opacity of the current sample if it is inside the slice region.\n\t* Output the final color value fragColor.\n\nOverall, this code is rendering a basic 3D volume using ray marching, \nwith the added feature of rendering only a slice of the volume defined by the _SliceMin and _SliceMax vectors. \nThe algorithm uses a simple compositing scheme based on the accumulation of color and opacity values \nalong the ray, weighted by the opacity of each sample.\n*/","name":"Image","description":"","type":"image"}]}