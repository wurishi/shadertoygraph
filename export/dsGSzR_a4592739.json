{"ver":"0.1","info":{"id":"dsGSzR","date":"1680646728","viewed":83,"name":"Ray March Reflective Spheres","username":"ni_cc","description":"Includes anti-aliasing, soft shadows, reflections, a halo-like 'glow', and a sort of ambient occlusion. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int SUN_MARCHES = 70;\nconst int VIEW_MARCHES = 300;\nconst int REFLECTIONS = 10;\nconst bool ANTI_ALIASED = true;\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdSphere1(vec3 p) {\n    vec3 p1 = vec3(p.x-1.0, p.y, p.z - 4.0);\n    return sdSphere(p1,1.0);\n}\n\nfloat sdSphere4(vec3 p) {\n    vec3 p4 = vec3(p.x-1.1, p.y-0.66, p.z - 2.3);\n    return sdSphere(p4, 0.33);\n}\n\n\nfloat dist(in vec3 p) {\n    /*vec3 p1 = vec3(mod(p.x,2.0)-1.0, p.y-1.0, mod(p.z,2.0)-1.0);\n    vec3 p2 = vec3(mod(p.x,2.0)-1.0, p.y+1.0, mod(p.z,2.0)-1.0);\n    return min(2.0 - p.y, min(sdSphere(p1, 0.5), sdSphere(p2,0.5)));*/\n    \n    vec3 p2 = vec3(p.x+0.5, p.y-0.5, p.z - 3.5);\n    vec3 p3 = vec3(p.x+0.3, p.y+0.5, p.z - 4.0);\n    return min(min(1.0 - p.y, sdSphere(p3, 0.5)), min(sdSphere1(p), min(sdSphere(p2,0.5), sdSphere4(p))));\n}\n\nvec3 normal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*dist( p + k.xyy*h ) + \n                      k.yyx*dist( p + k.yyx*h ) + \n                      k.yxy*dist( p + k.yxy*h ) + \n                      k.xxx*dist( p + k.xxx*h ) );\n}\n\nfloat march_sun(in vec3 start, in vec3 sun, in float sharpness) {\n    vec3 p = start;\n    vec3 r = sun;\n    vec3 n = normal(p);\n    \n    float PRECISION = 0.001;\n    p = p + n*PRECISION*1.5;\n    \n    float min_d = 1.0;\n    float td = 0.0;\n    \n    for(int i = 0; i < SUN_MARCHES; i++) {\n        float d = max(0.0, dist(p));\n        if(d < PRECISION) {\n            \n            return 0.0;\n        }\n        if(d > 1000000000.0) {\n            break;\n        }\n        \n        td += d;\n        min_d = min(min_d,sharpness * d/td);\n        p = p + r*d;\n    }\n    \n    return max(dot(n,r)*dot(n,r) * (min_d),0.0);\n}\n\nvec4 march_view(in vec3 start, in vec3 direction, int reflection_count) {\n    \n    vec4 final_color = vec4(0.0,0.0,0.0,1.0);\n    float frac = 1.0; // Fraction of my color to add to final color.\n    \n    vec3 next_r = direction;\n    vec3 next_p = start;\n    \n    for(int j = 0; j < reflection_count+1; j++) {\n    \n\n        vec3 r = next_r;\n        vec3 p = next_p;\n        float PRECISION = 0.001;\n        float DISTANCE_CUTOFF = 1000000000.0;\n\n        float min_d = 1.0;\n        float td = 0.0;\n        float glow_sharpness = 3.0;\n        \n        vec4 added_color; // Will be set when we find this hit's color.\n        \n        bool found_something = false;\n        for(int i = 0; i < VIEW_MARCHES; i++) {\n            float d = max(0.0, dist(p));\n            if(d < PRECISION) {\n                found_something = true;\n                \n                vec3 sun_direction = normalize(vec3(sin(iTime),(sin(iTime/5.0)-1.0)/2.0 - 0.5,cos(iTime)));\n                float sunlight = march_sun(p, sun_direction, 10.0);\n\n                float percent_marched = float(i)/float(VIEW_MARCHES);\n                float ambient_light = 1.0-percent_marched;\n\n                float light = sunlight*0.8 + ambient_light*0.2;\n                \n                \n                vec4 my_color;\n                \n                if(p.y >= 1.0 - PRECISION) {\n                    my_color = vec4(0.0,1.0,0.3,1.0);\n                } else if(sdSphere1(p) <= PRECISION) {\n                    my_color = vec4(1.0,0.3,0.0,1.0);\n                } else if(sdSphere4(p) <= PRECISION) {\n                    my_color = vec4(0.0,0.8,0.8,1.0);\n                } else {\n                    my_color = vec4(0.1,0.3,0.9,1.0);\n                }\n                vec4 my_lit_color = light * my_color;\n                \n                    \n                int mat = 1;\n                \n                if(mat == 0) { // MATTE\n                    added_color = my_lit_color;\n                    final_color += frac * added_color;\n                    frac = 0.0;\n                    break;\n\n                } else if(mat == 1) { // REFLECTIVE\n                    \n                    vec3 norm = normal(p);\n                    vec3 start = p + normal(p)*PRECISION*2.0;\n                    // For goofy reflections, do next_r = norm;.\n                    next_r = r - 2.0*dot(r,norm)*norm;\n                    next_p = start;\n\n                    float reflectivity = 0.5;\n                    \n                    added_color = my_lit_color;\n                    final_color += frac * (1.0-reflectivity) * added_color;\n                    frac *= reflectivity;\n                    break;\n                }\n\n            }\n            if(d > DISTANCE_CUTOFF) { // Sometimes we get so far out that it causes problems.\n                break;\n            }\n            td += d;\n            min_d = min(min_d,glow_sharpness * d/td);\n            p = p + r*d;\n        }\n        \n        if(!found_something) {\n            added_color = (1.0-min_d)*vec4(1.0,1.0,1.0,1.0) + (min_d)*vec4(0.5, 0.7, 1.0,1.0);\n            final_color += frac*added_color;\n            frac = 0.0;\n        }\n        if(frac < 0.01) {\n            break;\n        }\n        if(j == reflection_count) {\n            final_color += frac*added_color;\n        }\n    }\n    return final_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float aspect_ratio = 16.0 / 9.0;\n    const float viewport_height = 1.0;\n    const float viewport_width = aspect_ratio * viewport_height;\n    const float focal_length = 1.0;\n    \n    //vec3 origin = vec3(sin(iTime),0.0, iTime);\n    vec3 origin = vec3(0.3,0.0,0.2);\n    vec3 horizontal = vec3(viewport_width,0.0,0.0);\n    vec3 vertical = vec3(0,viewport_height,0.0);\n    vec3 lower_left_corner = origin + vec3(-viewport_width/2.0,-viewport_height/2.0, -focal_length);\n    \n    if(ANTI_ALIASED) {\n        vec4 sum = vec4(0.0,0.0,0.0,0.0);\n        for(float i = 0.0; i < 2.0; i++) {\n            for(float j = 0.0; j < 2.0; j++) {\n            // This pattern isn't used anywhere, I just made it up.\n                float x = uv.x + (0.66*i - 0.33 + 0.1*j - 0.2)*(1.0/iResolution.x); \n                float y = uv.y + (0.66*j - 0.33 + 0.1*i - 0.2)*(1.0/iResolution.y);\n                vec3 ray = origin - (lower_left_corner + x*horizontal + y*vertical);\n                vec3 start = lower_left_corner + x*horizontal + y*vertical;\n                vec3 direction = normalize(ray);\n\n                vec4 col = march_view(start, direction, REFLECTIONS);\n                sum += 0.25 * col;\n            }\n        }\n        fragColor = sum;\n    } else {\n        vec3 ray = origin - (lower_left_corner + uv.x*horizontal + uv.y*vertical);\n        vec3 start = lower_left_corner + uv.x*horizontal + uv.y*vertical;\n        vec3 direction = normalize(ray);\n\n        vec4 col = march_view(start, direction, REFLECTIONS);\n        fragColor = col;\n    }\n    //float t = 0.5*(direction.y + 1.0);\n    //fragColor =  (1.0-t)*vec4(1.0, 1.0, 1.0,0.0) + t*vec4(0.5, 0.7, 1.0,0.0);\n}\n","name":"Image","description":"","type":"image"}]}