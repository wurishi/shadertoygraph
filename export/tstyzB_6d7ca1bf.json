{"ver":"0.1","info":{"id":"tstyzB","date":"1601237664","viewed":65,"name":"Ray Marching - Light & Shadow","username":"qw","description":"A raymarched scene with a sphere and plane scene\nincludes diffuse lighting and shadow","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE 0.01\n\nfloat GetDistanceToScene(vec3 position)\n{\n\t//Sphere (pos.xyz, radius)\n    vec4 sphere = vec4(0,1.5,4, 1.5);\n    float sphereDistance = length( sphere.xyz - position) - sphere.w; \n    \n    //Plane (plane is flat at height 0, which means it's at \"y\" distance from camera\n    float planeDistance = position.y;\n    \n    \n    // find closest object('s distance)\n    float distance = min(sphereDistance, planeDistance);\n    return distance;\n    \n}\n\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir )\n{\n\tfloat distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 pos = rayOrigin + rayDir*distanceFromOrigin;\n        float distanceToScene = GetDistanceToScene(pos);\n        distanceFromOrigin += distanceToScene;\n        if(distanceFromOrigin > MAX_DISTANCE || distanceToScene < SURFACE_DISTANCE)\n        {\n        \tbreak;\n        }    \n        \n    }\n    \n    \n    return distanceFromOrigin;\n}\n\nvec3 GetNormal(vec3 scenePos)\n{\n    float distance = GetDistanceToScene(scenePos);\n    \n    //We use derivatives to calculate normal of a position\n    vec2 smallDiff = vec2(0.01, 0);\n    \n    vec3 normal = distance - vec3(\n        GetDistanceToScene(scenePos - smallDiff.xyy),\n        GetDistanceToScene(scenePos - smallDiff.yxy),\n        GetDistanceToScene(scenePos - smallDiff.yyx)\n        );\n\n\treturn normalize(normal);\n    \n}\n\nfloat GetLight( vec3 scenePos )\n{\n    //Light position in world\n    vec3 lightPos = vec3(0, 3.5, 2);\n    //make light move in circle\n    lightPos.xz += vec2(cos(iTime), -sin(iTime) );\n    \n    vec3 lightDir = normalize( lightPos-scenePos);\n    vec3 normal = GetNormal(scenePos);\n    float diffuse = dot(normal, lightDir);\n    //Clamp diffuse\n    diffuse = clamp(diffuse,0.0,1.0);\n    \n    //Shadow ((normal*SURFACE_DISTANCE*2.0) -> offset shading point a little bit away of surface to not intersect with it again,\n    //*2 is to avoid artefacts\n    float distanceToLightRayMarch = RayMarch(scenePos + (normal*SURFACE_DISTANCE*2.0), lightDir);\n    if( distanceToLightRayMarch < length( scenePos - lightPos) )\n    {\n        //something is in between the point in the world and the light, ie: we're in shadow\n        diffuse *= 0.1;\n    }\n    \n    return diffuse;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Change to square aspect ratio & center in middle of viewport\n    uv = (uv-0.5) * 2.0;\n    uv.x *= iResolution.x/iResolution.y;\n\t     \n    vec3 cameraPos = vec3(0,1,0);\n    vec3 rayDir = normalize(vec3(uv.xy,1));\n        \n    float rayMarchDistance = RayMarch(cameraPos, rayDir);\n    vec3 scenePos = cameraPos + rayDir * rayMarchDistance;\n\tfloat diffuseLighting = GetLight(scenePos);\n    \n       \n    vec3 col =  vec3(diffuseLighting);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}