{"ver":"0.1","info":{"id":"wllcWl","date":"1594675204","viewed":150,"name":"Simple ray tracing","username":"akanarika","description":"A simple ray tracing demo","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---- Util ----\nconst float Pi = 3.14159265359;\nfloat remap01(float a, float b, float t) { return (t - a) / (b - a);}\nfloat eps = 0.001; // epsilon\nvec4 bg_color = vec4(.9, .8, .6, 1.);\n\n// ---- Material ----\nstruct Material {\n    vec3 dif;\n    vec3 spec;\n    bool ref;\n};\n    \nMaterial makeMaterial(in vec3 d, in vec3 s, in bool r) { \n    Material m; m.dif = d; m.spec = s; m.ref = r;\n    return m;\n}\n\n// ---- Ray ----\nstruct Ray {\n\tvec3 o;\n    vec3 d;\n    float tmin;\n    float tmax;\n};\n    \nstruct Hit {\n    bool did;\n    bool inside;\n    vec3 p;\n    vec3 n;\n    float t;\n    Material m;\n};\n    \nRay makeRay(in vec3 o, in vec3 d) { \n    Ray r; r.o = o; r.d = d; r.tmin = 0.; r.tmax = 1000000000.; \n    return r;\n}\n\n// ---- Geometry ----\nstruct Plane {\n    vec3 n;\n    vec3 p;\n    Material m;\n};\n    \nPlane makePlane(in vec3 n, in vec3 p, in Material m) {\n    Plane pl; pl.n = n; pl.p = p; pl.m = m;\n    return pl;\n}\n\nstruct Sphere {\n    vec3 o;\n    float r;\n    Material m;\n};\n\nSphere makeSphere(in vec3 o, in float r, in Material m) { \n    Sphere s; s.o = o; s.r = r; s.m = m; \n    return s;\n}\n\nbool intersectPlane(in Plane p, in Ray r, inout Hit hit) {\n    float t = (dot(p.n, p.p) - dot(p.n, r.o)) / dot(p.n, r.d);\n    if (dot(p.n, r.d) > 0.) return false;\n    if (t > r.tmin && t < r.tmax) {\n        hit.did = true;\n        hit.t = t;\n        hit.p = r.o + r.d * t;\n        hit.n = normalize(p.n);\n        hit.m = p.m;\n        return true;\n    }\n    return false;\n}\n    \nbool intersectSphere(in Sphere s, in Ray r, inout Hit hit) {\n    float a = dot(r.d, r.d);\n    float b = 2. * dot(r.o - s.o, r.d);\n    float c = dot(r.o - s.o, r.o - s.o) - s.r * s.r;\n    float delta = b * b - 4. * a * c;\n    if (delta < 0.) return false;\n    float t = (-b - sqrt(delta)) / (2. * a);\n    if (t > r.tmin && t < r.tmax) {\n        hit.did = true;\n        hit.t = t;\n        hit.p = r.o + r.d * t;\n        hit.n = normalize(hit.p - s.o);\n        hit.m = s.m;\n        if (dot(hit.n, r.d) > 0.) {\n            hit.inside = true;\n            hit.n = -hit.n;\n        }\n        return true;\n    }\n    t = (-b + sqrt(delta)) / (2. * a);\n    if (t > r.tmin && t < r.tmax) {\n        hit.did = true;\n        hit.t = t;\n        hit.p = r.o + r.d * hit.t;\n        hit.n = normalize(hit.p - s.o);\n        hit.m = s.m;\n        if (dot(hit.n, r.d) > 0.) {\n            hit.inside = true;\n            hit.n = -hit.n;\n        }\n        return true;\n    }\n    return false;\n}\n\nbool intersectScene(in Ray r, inout Hit hit) {\n\tbool didHit = false;\n    \n    Plane p = makePlane(vec3(0., 1., 0.), vec3(0., -1., 0.),\n                        makeMaterial(vec3(.6, .5, .2), vec3(0.), false));\n    if (intersectPlane(p, r, hit)) {\n        r.tmax = hit.t;\n        didHit = true;\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        float ra = fract(sin(float(i + 2))) * .3 + 2.;\n        float cr = fract(cos(float(i + 4))) * .5 + .4;\n        float cg = fract(sin(float(i + 5))) * .5 + .2;\n        float cb = fract(1. - cos(float(i + 6))) * .5 + .5;\n        Sphere s = makeSphere(vec3(-sin(float(i * 2)) * 10. + 3., ra - 1.,  -25. -cos(float(i + 2) * 3.) * 10.), ra, \n                           makeMaterial(vec3(cr, cg, cb), vec3(.6), i == 3 ? true : false));\n        s.o.x += ra * sin(ra * iTime * .4);\n        s.o.z += 2. * ra * cos(ra * iTime * .4);\n    \tif (intersectSphere(s, r, hit)) {\n            r.tmax = hit.t;\n        \tdidHit = true;\n    \t}\n    }\n                        \n    return didHit;\n}\n\nvec4 color(in Ray r, inout Hit hit) {\n    // Light direction\n    vec3 light = normalize(vec3(5., 8., 5.));\n    \n    vec4 col;\n    if (intersectScene(r, hit)) {\n        vec3 l = light;\n        float dif = max(0., dot(l, hit.n));\n        vec3 h = normalize(l + r.d);\n        float spc = pow(max(0., dot(h, hit.n)), 16.);\n        \n        // Shadow test ray\n        Ray str = makeRay(hit.p + eps * l, l);\n        Hit sth;\n        col += 2. * vec4(hit.m.dif, 1.)  // diffuse color\n                  * dif\n             + 8. * vec4(hit.m.spec, 1.)  // spec color\n                 * spc\n             + .02 * vec4(hit.m.dif, 1.);  // ambient color**/\n        return intersectScene(str, sth) ?  sqrt(col) * .2 : sqrt(col);\n    }\n    return col;\n}\n\n\nvec4 calcColor(in Ray r) {\n    Ray nr = r;\n    float fac = 1.;\n    vec4 col = bg_color;\n    for (int i = 0; i < 5; i++) {\n        Hit hit;\n        vec4 att = color(nr, hit);\n        if (!hit.did) {\n            return col;\n        } else if (!hit.m.ref) {\n            nr.d = normalize(reflect(nr.d, hit.n));\n            nr.o = hit.p + eps * nr.d;\n            col *= att;\n            if (hit.m.spec == vec3(0.)) return col;\n        } else {\n            att = vec4(.9, .9, .9, 1.);\n            float eoe = 1.3;\n            if (!hit.inside) eoe = 1. / eoe;\n            nr.d = normalize(refract(nr.d, hit.n, eoe));\n            nr.o = hit.p + eps * nr.d;\n            col *= att;\n        }\n    }\n    return vec4(0.);\n}\n\nvoid shootRays(vec3 ro, vec3 rd, out vec4 col) {\n    float unit_x = 1. / iResolution.x;\n    float unit_y = 1. / iResolution.y;\n    // 4 samples\n    vec2 offset[4] = vec2[4](vec2(-unit_x / 2., -unit_y / 2.), vec2(-unit_x / 2., unit_y / 2.),\n                             vec2(unit_x / 2., -unit_y / 2.), vec2(unit_x / 2., unit_y / 2.));\n    vec4 total;\n    for (int i = 0; i < 4; i++) {\n        vec2 off = offset[i];\n        Ray r = makeRay(ro - vec3(off, 0.), normalize(rd));\n        total += calcColor(r);\n    }\n\tcol = total / 4.;\n}\n\nmat3 lookat(vec3 cam, vec3 target) {\n    vec3 forward = normalize(target - cam);\n    vec3 right = cross(normalize(vec3(0, 1, 0)), forward);\n    vec3 up = cross(forward, right);\n   \n    return mat3(right, up, forward);\n}\n\n// ---- main ----\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (y from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // y from -.5 to .5\n    uv -= 0.5;\n    // x from -.5 * ratio to .5 * ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Mouse\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // Ray\n    vec3 ro = vec3(0., 0., 1.);\n    vec3 tar = vec3(0., 0., 0.);\n    mat3 view = lookat(ro, tar);\n    \n    vec3 rd = normalize(view * vec3(uv.x, uv.y, 1));\n    \n    // Output to screen\n    vec4 col;\n    shootRays(ro, rd, col);\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}