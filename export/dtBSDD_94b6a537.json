{"ver":"0.1","info":{"id":"dtBSDD","date":"1676066225","viewed":86,"name":"Rocks in space (pseudo 3D)","username":"ianertson","description":"Some rocks floating around in space (pseudo-3D using a spherical projection).\nUse the mouse to look around","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["space","rocks","fake3d","art","asteroids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// set this to one to be able to look in all directions,\n// this will result in a very long compile time for some reason,\n// so that's why it's disabled.\n#define RENDER_IN_ALL_DIRECTIONS 0\n\n\n\n#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\n\n\nfloat hash1(float x, float seed) {\n    uint y = floatBitsToUint(x+0.000319281) << 3u;\n    uint w = (y ^ (y << 9u)) >> 3u;\n    uint z = floatBitsToUint(seed+0.001);\n    y ^= (y << 17u); y ^= (y >> 5u); y ^= (y << 9u); y ^= (y << (w ^ (y>>3u))); y ^= (y >> 3u); y += (z >> 3u);\n    return float(y * 921u) / float(0xFFFFFFFFU);\n}\n\nfloat hash2(vec2 x, float seed) {\n    uvec2 y = uvec2(floatBitsToUint(hash1(x.x+0.00072, seed)), floatBitsToUint(hash1(x.y+0.00072, seed)));\n    uvec2 w = (y ^ (y << 9u)) >> 3u;\n    uvec2 z = uvec2(floatBitsToUint(seed+0.0001214) >> 2u) << ((y.x << 3u) ^ (y.y >> 3u)); \n    y ^= (y << w); y ^= (z << w); y ^= (y << 17u); y ^= (y >> 5u); y ^= (y << 9u);\n    return hash1(float((((y.x ^ (y.y<<7u)) + (y.y ^ (y.x << 7u)) >> 3u) <<\n        ((z.x<<w.y>>3u) ^ (z.y>>3u))) * 9289u) / float(0xFFFFFFFFU), seed+0.291);\n}\n\nfloat hash3(vec3 p, float seed) {\n    float x = hash2(p.xz, seed);\n    float y = hash2(p.yz, seed);\n    float z = hash2(p.xy, seed);\n    return (x+y+z)/3.0;\n}\n\nfloat noise(vec2 uv, float seed) {\n    vec2 id = floor(uv);\n    vec2 lv = smoothstep(0.0, 1.0, fract(uv));\n    return mix(\n        mix(hash2(id, seed), hash2(id+vec2(1.0, 0.0), seed), lv.x),\n        mix(hash2(id+vec2(0, 1.0), seed), hash2(id+vec2(1.0, 1.0), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat noise3(vec2 uv, float seed, float freq) {\n    float n = 0.0;\n    float div = 0.0;\n    float amp = 1.0;\n    n += amp*noise(uv*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp*noise(uv*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp*noise(uv*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}\n\nfloat getBox(vec2 p, vec2 pos, vec2 size, inout vec2 uv) {\n    vec2 mi = pos-(size*0.5);\n    vec2 ma = pos+(size*0.5);\n    if (p.x < mi.x || p.x > ma.x) return 0.0f;\n    if (p.y < mi.y || p.y > ma.y) return 0.0f;\n    vec2 s = (ma-mi);\n    uv = (p - mi)/((size*0.5));\n    return 1.0f;\n}\n\n\nvec3 shadeItem(vec2 uv, float itemId) { return vec3(noise3(uv*2., 1.23 + (itemId*0.321), 2.));}\n\nvec3 rock(vec2 uv) {\n    vec2 id = floor(uv);\n    float z = hash2(id*20.9821, 9.2132);\n    uv = fract(uv);\n    uv = uv * 2.0 - 1.0;\n    float iid = float(id.x+id.y);\n    float s = (mix(1.0, 0.5, z));\n    uv *= s;\n    float x = hash2(id*30.2918, 0.2312);\n    float y = hash2(id*33.9215, 3.2185);\n    uv += ((vec2(x, y)*2.0-1.0)*0.1)*s;\n    float a = fract(fract(x+y)*10.29315);\n    float r = fract(fract((a+x+y)*10.9712951)*10.876216);\n    float g = fract((a+r)*10.18720331);\n    vec2 move = vec2(cos(T*x), sin(T*y));\n    uv += (move*0.5)*s;\n    vec2 buv = vec2(0.);\n    uv *= rot((a*TAU)*T*(g));\n    vec3 A = (getBox(uv, vec2(0.0), vec2(0.5), buv) * shadeItem(buv, 0.213 + (iid*20.2912)));\n    uv *= rot(radians(45.));\n    vec3 B = (getBox(uv, vec2(0.0), vec2(0.5), buv) * shadeItem(buv, 1.215 + (iid*22.94721)));\n    return A*B;\n}\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0.0);\n    vec3 layerA = (1.3 / 3.0)*rock(((uv*16.0) + vec2(42.0, -33.177)) + vec2(cos(T*0.2), sin(T*0.2)));\n    vec3 layerB = (1.3 / 2.0)*rock(((uv*8.0) + vec2(4.0, -3.291)) + vec2(cos(T*0.2), T*0.5));\n    vec3 layerC = rock((uv*4.0) + vec2(sin(T*0.2), T*0.1));\n    return max(layerC, max(layerA, layerB));\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.x > 0.03) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    }\n\n    #if RENDER_IN_ALL_DIRECTIONS > 0\n    vec3 colxy = render(rd.xy);\n    vec3 colyz = render(rd.yz);\n    \n    col = mix(col, colxy, abs(dot(rd, vec3(0, 0, 1))));\n    col = mix(col, colyz, abs(dot(rd, vec3(1, 0, 0))));\n    #else\n    col = render(rd.xy);\n    #endif\n    \n    if (dot(col, col) <= 0.01) {\n        float bg = hash3(rd, 0.2321);\n        bg = pow(bg, 7.5);\n        col += bg / 2.0;\n    }\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 1.6));\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}