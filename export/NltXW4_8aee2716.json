{"ver":"0.1","info":{"id":"NltXW4","date":"1639130553","viewed":73,"name":"evankh_WaterRipples","username":"evankh","description":"This should look kinda like a rippling surface of water with Phong shading.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["phong","perlin","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Generates a rippling water surface with a shiny texture.\n// Makes a thin block of something like 3D Perlin noise at each time step, and uses it as a heightmap\n// Naturally, this would be infinitely more efficient if the noise could be generated once and stored.\n// But that's not something ShaderToy is set up to do.\n\nvec2 gridSize = vec2(15.0, 10.0); // number of grid cells on screen\nfloat gridTime = 0.75; // duration of a grid cell, controls the speed of rippling\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 future = vec3(0.0, 0.0, 1.0);\nvec3 lightPos = vec3(5.0, 5.0, 5.0);\n\nuint rot(uint x, int k) {\n    return (x << k) | (x >> (32 - k));\n}\nfloat noise(vec3 seed) {\n    uint s0 = floatBitsToUint(seed.x) ^ (floatBitsToUint(seed.z) >> 16);\n    uint s1 = floatBitsToUint(seed.y) ^ (floatBitsToUint(seed.z) << 16);\n    s1 ^= s0;\n    s0 = rot(s0, 26) ^ s1 ^ (s1 << 9);\n    s1 = rot(s1, 13);\n    s1 ^= s0;\n    s0 = rot(s0, 26) ^ s1 ^ (s1 << 9);\n    s1 = rot(s1, 13);\n    uint result = rot(s0 * 0x9e3779bbu, 5) * 5u;\n    return float(result) / float(0xffffffffu);\n}\n\nfloat smooth1(float x) {\n    return x * x * (3.0 - 2.0 * x);\n}\nfloat smooth_d(float x) {\n    return 6.0 * x * (1.0 - x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pos = vec3(uv * gridSize, iTime / gridTime);\n    vec3 cell = floor(pos);\n    vec3 offs = fract(pos);\n    vec2 d_offs;\n    d_offs.x = smooth_d(offs.x);\n    d_offs.y = smooth_d(offs.y);\n    //offs.x = smooth1(offs.x);\n    //offs.y = smooth1(offs.y);\n    \n    float val_ldp = noise(cell);\n    float val_rdp = noise(cell + right);\n    float val_lup = noise(cell + up);\n    float val_rup = noise(cell + right + up);\n    float val_ldf = noise(cell + future);\n    float val_rdf = noise(cell + right + future);\n    float val_luf = noise(cell + up + future);\n    float val_ruf = noise(cell + right + up + future);\n    \n    float val_ld = mix(val_ldp, val_ldf, offs.z);\n    float val_rd = mix(val_rdp, val_rdf, offs.z);\n    float val_lu = mix(val_lup, val_luf, offs.z);\n    float val_ru = mix(val_rup, val_ruf, offs.z);\n    \n    float val_l = mix(val_ld, val_lu, offs.y);\n    float val_r = mix(val_rd, val_ru, offs.y);\n    \n    float val = mix(val_l, val_r, offs.x);\n    \n    float dx = (val_r - val_l) * d_offs.x;\n    float dy = (mix(val_lu, val_ru, offs.x) - mix(val_ld, val_rd, offs.x)) * d_offs.y;\n    vec3 norm = normalize(vec3(dx, dy, 1.0));\n    \n    lightPos.x = lightPos.x + 10.0 * sin(2.0*3.14159*iTime / 8.0);\n    lightPos.y = lightPos.y + 3.0 * sin(2.0*3.14159*iTime / 4.0);\n    vec3 lightVec = lightPos - vec3(pos.xy,val);\n    float ambient = 2.0 / length(lightVec);\n    float specular = dot(norm, normalize(lightVec));\n    specular = clamp(specular, 0.0, 1.0) * 0.5;\n    \n    fragColor = vec4(vec3(ambient + specular), 1.0);\n    //fragColor = vec4(norm*vec3(0.5,0.5,1.0)+vec3(0.5,0.5,0.0), 1.0);\n    //fragColor = vec4(vec3(specular), 1.0);\n}","name":"Image","description":"","type":"image"}]}