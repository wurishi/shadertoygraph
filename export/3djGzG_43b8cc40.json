{"ver":"0.1","info":{"id":"3djGzG","date":"1550395576","viewed":128,"name":"Unknown Shallow Waters","username":"PaulHi","description":"Just wanted to try out raymarching, and this is what I came up with.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shallowwaters"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON .001\n#define MAX_DIST 80.\n#define BIAS .01\n#define MAX_STEPS 128\n\nvec3 lightPos = vec3(0., 2., 0.);\nvec3 sky = vec3(0., 0., .2);\nvec3 eye;\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat ripple(in vec3 p)\n{\n    return .00025 * ((sin(iTime) + 1.) * 15. * texture(iChannel0, p.xz).x) +\n        \t.000025 * ((cos(iTime) + 1.) * 10. * texture(iChannel1, p.zx).x);\n}\n\nfloat sdPlane(in vec3 p, in vec4 n)\n{\n  //p.x = abs(p.x) - 1.;\n  //p.z = abs(p.z) - 1.;\n  return dot(p,n.xyz) + n.w * ripple(p);\n}\n\nfloat smoothAdd(float d1, float d2, float k) \n{\n\tfloat h = clamp(.5 + .5 * (d2 - d1) / k, 0., 1.);\n    return mix( d2, d1, h ) - k * h * (1. - h);\n}\n\nint material; // 0 = water, 1 = rock, 2 = sphere\n\nfloat map(in vec3 p) {\n    float plane = sdPlane(p, vec4(0., 1., 0., .4));\n    p.x = mod(p.x, 5.) - 2.5;\n    p.z = mod(p.z, 5.) - 2.5;\n    float box =  sdRoundBox(p, vec3(1., .3, 1.), .1);\n    p.y -= sin(iTime * 2.25);\n    float sphere =  sdSphere(p,  .7);\n    \n    material = plane < box ? 0 : box < sphere ? 1 : 2;\n    \n    return min(plane, smoothAdd(sphere, box, .2));\n}\n\nfloat shadow(in vec3 origin, in vec3 direction)\n{\n    float res = 1.;\n    float ph = 1e20;\n    for(float t = BIAS; t < MAX_DIST;)\n    {\n        float h = map(origin + direction * t);\n        if( h < EPSILON)\n            return 0.0;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 16.* d / max(0., t - y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map(p + k.xyy * EPSILON) + \n                      k.yyx * map(p + k.yyx * EPSILON) + \n                      k.yxy * map(p + k.yxy * EPSILON) + \n                      k.xxx * map(p + k.xxx * EPSILON));\n}\n\n\nfloat march(in vec3 origin, in vec3 direction)\n{\n    float t = 0.;\n    for(int s = 0; s < MAX_STEPS; ++s)\n    {\n        vec3 p = origin + direction * t;\n        float minD = map(p);\n        if(minD < EPSILON) break;\n        t += minD;\n        if(t > MAX_DIST) break;\n    }\n    return t;\n}\n\n\nvec3 phongRef(in vec3 p, in vec3 o)\n{\n    vec3 materialColor = \n        material == 0 ? vec3(0., .6, .5) :\n    \tmaterial == 1 ? vec3(.4) :\n    \t\t\t\t\tvec3(1., 0., 0.);\n    vec3 N = calcNormal(p);\n    vec3 L = lightPos - p;\n    float blend = smoothstep(1., 0., length(L) / 30.);\n    L = normalize(L);\n    float dif = dot(L, N);\n    vec3 V = normalize(p - o);\n    vec3 H = normalize(L - V);  \n    float spec = pow(max(dot(N, H), 0.0), 4.0) * 2.;\n    return max(0.3, (dif + spec)  * shadow(p, L)) * materialColor * blend;\n}\n\nvec3 phong(in vec3 p, in vec3 o)\n{\n    vec3 materialColor = \n        material == 0 ? vec3(0., .6, .5) :\n    \tmaterial == 1 ? vec3(.4) :\n    \t\t\t\t\tvec3(1., 0., 0.);\n    vec3 N = calcNormal(p);\n    vec3 L = lightPos - p;\n    float blend = smoothstep(1., 0., length(L) / 30.);\n    L = normalize(L);\n    float dif = dot(L, N);\n    vec3 V = normalize(p - o);\n    vec3 H = normalize(L - V);  \n    float spec = pow(max(dot(N, H), 0.0), 16.0) * .8;\n    if(material == 0)\n    {\n        //cast reflect ray\n        vec3 refDir = reflect(V, N);\n        float depth = march(p + BIAS, refDir);\n        \n    \tvec3 i = p + BIAS + refDir * depth;\n        \n        vec3 col = depth < MAX_DIST ? phongRef(i, eye) : sky;\n        materialColor *= .5;\n        materialColor += col * .5;\n    }\n    return max(0.3, (dif + spec)  * shadow(p, L)) * materialColor * blend;\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 lookAt, vec3 up)\n{\n\tvec3 f = normalize(lookAt - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPos = vec3(-sin(iTime * 2.) * 4., 4., -cos(iTime * 2.) * 4.);\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    eye = vec3(sin(iTime *.5) * 3., (-cos(iTime) * .5 + .8) * 2.5, cos(iTime *.5) *  4.);\n    \n    vec3 direction = normalize(vec3(uv.x, uv.y, -1.));\n    \n    mat4 view = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.));\n    vec3 worldDir = normalize((view * vec4(direction, 0.0)).xyz);\n    \n    float depth = march(eye, worldDir);\n    \n    vec3 p = eye + worldDir * depth;\n    \n    vec3 col = depth < MAX_DIST ? phong(p, eye) : sky;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}