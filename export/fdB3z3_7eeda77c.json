{"ver":"0.1","info":{"id":"fdB3z3","date":"1617709551","viewed":39,"name":"324_Alibaeva_v0v3","username":"blaresadn","description":"Task for CMC CG course","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["compgraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 CAMERA_POS = vec3(1.5, 1.2, -6.);\nconst float INF = 1e10;\nvec3 randDir;\n\n// три источника света, один из которых не видно при исходном CAMERA_POS\nconst int LIGHT_NUM = 3;\n\nvec3 LIGHT_POS[LIGHT_NUM] = vec3[](vec3(-2, 1.5, 5.), vec3(1.5, 1., 1.),\n    vec3(0.7, 3.5, -2.));\n    \nfloat LIGHT_RADIUS[LIGHT_NUM] = float[](0.5, 0.25, 0.3);\n\nvec3 LIGHT_COLOR[LIGHT_NUM] = vec3[](vec3(0.766, 0.848, 0.898),\n    vec3(1, 0.953, 0.95), vec3(1, 0.867, 0.879));\n\nconst float CYLINDER_RADIUS = 0.5;\n\nfloat EPS = 1e-5;\n\nconst float AIR_N = 1.0;\nconst float GLASS_N = 1.5;\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nvec3 MSU_COLOR1 = vec3(0.492, 0.207, 0.078);\nvec3 MSU_COLOR2 = vec3(206. / 256., 198. / 256., 166. / 256.);\nvec3 MSU_COLOR3 = vec3(0.492 / 2., 0.207 / 2., 0.078 / 2.);\n\nconst int MSU_ELEMENTS_NUM = 10;\n\nvec3 msu_pos[MSU_ELEMENTS_NUM] = vec3[](vec3(0., -0.18, 0.), vec3(0., -0.25, 0.),\n    vec3(0.33, -0.25, -0.1), vec3(-0.33, -0.25, -0.1), vec3(0., 0.05, 0.),\n    vec3(0.34, -0.1, -0.23), vec3(-0.34, -0.1, -0.23), vec3(0., -0.33, 0.),\n    vec3(-0.08, -0.18, -0.1), vec3(0.08, -0.18, -0.1));\n\nvec3 msu_sizes[MSU_ELEMENTS_NUM] = vec3[](vec3(0.12, 0.2, 0.1), vec3(0.3, 0.13, 0.07), \n    vec3(0.05, 0.13, 0.2), vec3(0.05, 0.13, 0.2), vec3(0.07, 0.15, 0.07),\n    vec3(0.03, 0.05, 0.06), vec3(0.03, 0.05, 0.06), vec3(0.06, 0.05, 0.2),\n    vec3(0.021, 0.2, 0.03), vec3(0.021, 0.2, 0.03));\n    \nconst int CYL_NUM = 3;\n\nvec3 cyl_pos[CYL_NUM] = vec3[](vec3(0., -1.1, 0.), vec3(0., 0.25, 0.),\n    vec3(0., 0.35, 0.));\n\nvec2 cyl_sizes[CYL_NUM] = vec2[](vec2(0.5, 0.2), vec2(0.002, 0.1), vec2(0.00025, 0.2));\n\nvec3 FOG_POS = vec3(0, -0.3, 0);\nfloat FOG_RADIUS = 0.3;\n\nfloat SPHERE_RADIUS = 1.0;\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal)\n{\n    float t = (-1.2 - pos.y) / dir.y;\n    normal = vec3(0, 1, 0);\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal)\n{\n    float b = dot(pos, dir);\n    float D1 = b * b - dot(pos, pos) + r * r;\n    if (D1 < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D1);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D1);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\n//трассировка цилиндров по квадрату радиуса и высоте\nfloat traceCylinder(vec3 pos, vec3 dir, float r, float h, out vec3 normal) {\n    float t = (h / 2. - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < r) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (abs(worldPos.y) <= h / 2.) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (abs(worldPos.y) <= h / 2.) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\n// трассировка параллелепипедов для деталей ГЗ МГУ\nfloat traceCube(vec3 pos, vec3 dir, vec3 size, out vec3 normal)\n{\n    float t;\n    float min_t = INF;\n    vec3 cur_norm;\n    vec3 worldPos;\n    \n    t = (-size.x - pos.x) / dir.x;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.y) <= size.y && abs(worldPos.z) <= size.z) {\n            normal = vec3(-1, 0, 0);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n\n    t = (size.x - pos.x) / dir.x;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.y) <= size.y && abs(worldPos.z) <= size.z) {\n            normal = vec3(1, 0, 0);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n    \n    t = (-size.y - pos.y) / dir.y;\n        if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.x) <= size.x && abs(worldPos.z) <= size.z) {\n            normal = vec3(0, -1, 0);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n\n    t = (size.y - pos.y) / dir.y;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.x) <= size.x && abs(worldPos.z) <= size.z) {\n            normal = vec3(0, 1, 0);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n    \n    t = (-size.z - pos.z) / dir.z;\n        if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.x) <= size.x && abs(worldPos.y) <= size.y) {\n            normal = vec3(0, 0, -1);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n\n    t = (size.z - pos.z) / dir.z;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.x) <= size.x && abs(worldPos.y) <= size.y) {\n            normal = vec3(0, 0, 1);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n    normal = cur_norm;\n    return min_t;\n}\n\nbool isOccluded(vec3 pos, vec3 target)\n{\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    if (abs(pos.x) >= SPHERE_RADIUS - EPS || abs(pos.y) >= SPHERE_RADIUS - EPS || abs(pos.z) >= SPHERE_RADIUS - EPS) {\n        vec3 sphNorm;\n        float sphT = traceSphere(pos, dir, SPHERE_RADIUS, sphNorm);\n        if (sphT < dist) {\n            return true;\n        }\n    }\n    \n    vec3 cylNorm;\n    float cylT = traceCylinder(pos - cyl_pos[0], dir, cyl_sizes[0].x, cyl_sizes[0].y, cylNorm);\n    return cylT < dist;\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal)\n{\n    vec3 sum = vec3(0.);\n    for (int i = 0; i < LIGHT_NUM; i++) {\n        vec3 toLight = LIGHT_POS[i] - pos;\n        float distSq = dot(toLight, toLight);\n        float att = isOccluded(pos, LIGHT_POS[i] + randDir * LIGHT_RADIUS[i]) ? 0.0 : 10.0f / distSq;\n        sum += LIGHT_COLOR[i] * att * max(0.0, dot(normal, normalize(toLight)));\n    }\n    \n    return color * (sum + texture(iChannel1, normal).rgb * 0.1);\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2)\n{\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    \n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.) {\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat pow2(float x)\n{\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\nvec4 GetRGBA(vec3 curPos, vec3 curDir)\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    \n    float n1 = AIR_N;\n    float n2 = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    \n    for (int i = 0; i < 10; i++) {\n        float t = INF;\n        int materialType;\n        float nEnter = AIR_N;\n        vec3 color;\n        vec3 normal;\n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb * vec3(0.7);\n            normal = planeNorm;\n        }\n        for (int i = 0; i < LIGHT_NUM; i++) {\n            vec3 lNorm;\n            float lightT = traceSphere(curPos - LIGHT_POS[i], curDir, LIGHT_RADIUS[i], lNorm);\n            if (lightT < t) {\n                t = lightT;\n                materialType = EMISSION;\n                color = LIGHT_COLOR[i];\n                normal = lNorm;\n            }\n        }\n        vec3 sphNorm;\n        float sphT = traceSphere(curPos, curDir, 1.0, sphNorm);\n        if (sphT < t) {\n            t = sphT;\n            normal = sphNorm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos - cyl_pos[0], curDir, cyl_sizes[0].x, cyl_sizes[0].y, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            vec4 clr = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                return vec4(color, 0.);\n            } else if (materialType == DIFFUSE) {\n                return vec4(computeLight(worldPos, color, normal), 0.);\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, n2);\n                curPos = worldPos + curDir * 1e-5;\n                float tmp = n1;\n                n1 = n2;\n                n2 = tmp;\n            }\n        } else {\n            return texture(iChannel1, curDir);\n        }\n    }\n}\n\nvec3 GetMSU(vec3 curPos, vec3 curDir)\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    \n    float n1 = AIR_N;\n    float n2 = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n\n    for (int i = 0; i < 10; i++) {\n        float t = INF;\n        int materialType;\n        float nEnter = AIR_N;\n        vec3 color;\n        vec3 normal;\n        bool f = false;\n        vec3 sphNorm;\n        float sphT = traceSphere(curPos, curDir, 1.0, sphNorm);\n        if (sphT < t) {\n            t = sphT;\n            normal = sphNorm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 sph1Norm;\n        float sph1T = traceSphere(curPos - vec3(0, 0.45, 0), curDir, 0.03, sph1Norm);\n        if (sph1T < t) {\n            t = sph1T;\n            normal = sph1Norm;\n            materialType = DIFFUSE;\n            color = MSU_COLOR3;\n            f = true;\n        }\n        vec3 cyl1Norm;\n        float cyl1T = traceCylinder(curPos - cyl_pos[1], curDir, cyl_sizes[1].x, cyl_sizes[1].y, cyl1Norm);\n        if (cyl1T < t) {\n            t = cyl1T;\n            materialType = DIFFUSE;\n            color = MSU_COLOR2;\n            vec3 worldPos = t * curDir + curPos;\n            if ((cyl_pos[1].y + cyl_sizes[1].y / 2. - worldPos.y) < 0.03) {\n                    color = MSU_COLOR1;\n            }\n            normal = cyl1Norm;\n            f = true;\n        }\n        vec3 cyl2Norm;\n        float cyl2T = traceCylinder(curPos - cyl_pos[2], curDir, cyl_sizes[2].x, cyl_sizes[2].y, cyl2Norm);\n        if (cyl2T < t) {\n            t = cyl2T;\n            materialType = DIFFUSE;\n            color = MSU_COLOR3;\n            normal = cyl2Norm;\n            f = true;\n        }\n        for (int j = 0; j < MSU_ELEMENTS_NUM; j++) {\n            vec3 cubeNorm;\n            float cubeT = traceCube(curPos - msu_pos[j], curDir, msu_sizes[j], cubeNorm);\n            if (cubeT < t) {\n                t = cubeT;\n                materialType = DIFFUSE;\n                color = MSU_COLOR2;\n                vec3 worldPos = t * curDir + curPos;\n                if (j >= 8) {\n                    color = MSU_COLOR2 / 1.2;\n                }\n                if ((msu_pos[j].y + msu_sizes[j].y - worldPos.y) < 0.03) {\n                    color = MSU_COLOR1;\n                }\n                normal = cubeNorm;\n                f = true;\n            }\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            if (materialType == DIFFUSE && f) {\n                return computeLight(worldPos, color, normal);\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, n2);\n                curPos = worldPos + curDir * 1e-5;\n                float tmp = n1;\n                n1 = n2;\n                n2 = tmp;\n            }\n        } else {\n            return vec3(float(INF));\n        }\n    }\n}\n\nvec4 GetFog(vec3 curPos, vec3 curDir)\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    \n    float n1 = AIR_N;\n    float n2 = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n\n    for (int i = 0; i < 10; i++) {\n        float t = INF;\n        int materialType;\n        float nEnter = AIR_N;\n        vec3 color;\n        vec3 normal;\n        bool f = false;\n        vec3 sphNorm;\n        float sphT = traceSphere(curPos, curDir, 1.0, sphNorm);\n        if (sphT < t) {\n            t = sphT;\n            normal = sphNorm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 inner_size = vec3(0.8, 0.5, 0.4);\n        vec3 size = vec3(1., 0.7, 0.5);\n        vec3 pos = vec3(0., -0.2, 0.);\n        float opacity = 0.7;\n        vec3 sph1Norm;\n        float sph1T = traceCube(curPos - pos, curDir, size, sph1Norm);\n        if (sph1T < t) {\n            t = sph1T;\n            materialType = DIFFUSE;\n            normal = sph1Norm;\n            vec3 worldPos = t * curDir + curPos;\n            color = vec3(texture(iChannel3, worldPos * 0.07).r);\n            if (abs(worldPos.x) >= inner_size.x / 2. || abs(worldPos.y - pos.y) >= inner_size.y / 2.  || abs(worldPos.z) >= inner_size.z / 2.) {\n                float len = min(abs(worldPos.x - size.x), min(abs(worldPos.y - pos.y - size.y), abs(worldPos.y - pos.y + size.y)));\n                len = min(len, abs(worldPos.x + size.x));\n                opacity = min(3. * len * color.r, 0.7);\n            }\n            f = true;\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            if (materialType == DIFFUSE && f) {\n                if (length(worldPos) <= 1.) {\n                    return vec4(color, opacity);\n                }\n                return vec4(INF);\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, n2);\n                curPos = worldPos + curDir * 1e-5;\n                float tmp = n1;\n                n1 = n2;\n                n2 = tmp;\n            }\n        } else {\n            return vec4(INF);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    for (int i = 0; i < LIGHT_NUM; i++) {\n        LIGHT_POS[i] = LIGHT_POS[i] + vec3(1., 0., 0.) * randVals.x * 0.05;\n    }\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    \n    vec4 color = GetRGBA(curPos, curDir);\n    vec3 msu = GetMSU(curPos, curDir);\n    vec4 fog = GetFog(curPos, curDir);\n    \n    //выводим прозрачное ГЗ МГУ\n    if (msu.x != INF) {\n        color = vec4(mix(color.rgb, msu, 0.3), color.a);\n    }\n    //выводим туман\n    if (fog.x != INF) {\n        color = vec4(mix(color.rgb, fog.rgb, fog.a + 0.1), color.a);\n    }\n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n     fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}