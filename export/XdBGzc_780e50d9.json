{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct sphere_t\n{\n    vec3 position;\n    float radius;   \n};\n\n\nstruct ray_t\n{\n    vec3 origin;\n    vec3 direction;   \n};\n    \n\nstruct plane_t\n{\n    vec3 normal;\n    vec3 orientation;\n    float offset;   \n};\n\t\nstruct light_t\n{\n\tvec3 direction;\n\tfloat contribution;\n\t\n};\n   \nconst float max_distance = 1e5;\n\n\nfloat intersect_sphere(const in ray_t ray,const in sphere_t sphere)\n{\n   \n    float a = (ray.direction.x * ray.direction.x)\n            +(ray.direction.y * ray.direction.y)\n            +(ray.direction.z* ray.direction.z);\n   \n    float b = ((ray.origin.x-sphere.position.x)*ray.direction.x)\n            +((ray.origin.y-sphere.position.y)*ray.direction.y)\n            +((ray.origin.z-sphere.position.z)*ray.direction.z);\n   \n    b *= 2.0;\n\n    float c = ((ray.origin.x-sphere.position.x) * (ray.origin.x-sphere.position.x))\n            +((ray.origin.y-sphere.position.y) * (ray.origin.y-sphere.position.y))\n            +((ray.origin.z-sphere.position.z) * (ray.origin.z-sphere.position.z)) - (sphere.radius*sphere.radius);\n   \n    float delta = b*b - (4.0*a*c);\n   \n    if(!(delta < 0.0)){\n        float dist = (-b + sqrt(delta))/(2.0*a);\n        float dist2 = (-b - sqrt(delta))/(2.0*a);\n        return    min(dist,dist2);\n    }\n    else\n    {   \n        return max_distance;\n    }\n   \n}\n\nfloat intersect_plane(const in ray_t ray,const in plane_t plane)\n{    \n    float a = plane.normal.x;\n    float b = plane.normal.y;\n    float c = plane.normal.z;\n    float result = -(plane.offset+ a*ray.origin.x + b*ray.origin.y+c*ray.origin.z)/(a*ray.direction.x+b*ray.direction.y+c*ray.direction.z);\n    if(result > 0.0){\n        return   result;\n    }\n    else\n    {   \n        return max_distance;\n    }\n   \n}\n\nfloat intersect(const in ray_t ray){\n   \n\tsphere_t sphere;\n    sphere.position = vec3(0.0,0.0,0.0);\n    sphere.radius = 1.0;  \n    \n    plane_t plane;\n    plane.normal = vec3(0.0, 0.9, 0.04);\n    plane.offset= 0.1;\n    \n    return min( intersect_plane(ray, plane), intersect_sphere(ray, sphere));\n}\n\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coordonate = fragCoord.xy/iResolution.xy;\n    vec2 screen_coordonate_centered = 2.0 * screen_coordonate -1.0;\n    \n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2  screen_coordonate_cor = vec2(aspect_ratio, 1.0)*screen_coordonate_centered;\n   \n    ray_t primary_ray;\n    primary_ray.origin = vec3(0.0, 0.0,mix(1.5,3.0,0.5+0.5*sin(iTime)));\n    primary_ray.direction = normalize(vec3(screen_coordonate_cor,-1.5));  \n   \n\t\n    float distance_from_origin = intersect(primary_ray);\n    \n    if(distance_from_origin < max_distance)\n    {\n        vec3 sphere_color = vec3(distance_from_origin/5.0,distance_from_origin/5.0,distance_from_origin/5.0);\n        fragColor = vec4(sphere_color,1.0);\n    }\n    else\n    {\n        const vec3 background_color = vec3(1.0,1.0,1.0);\n        fragColor = vec4(background_color,1.0);       \n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdBGzc","date":"1391437252","viewed":130,"name":"SoleilLevant","username":"Tarokh","description":"SoleilLevant!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""}}