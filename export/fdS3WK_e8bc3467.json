{"ver":"0.1","info":{"id":"fdS3WK","date":"1617926246","viewed":100,"name":"Momo The Monster (redux)","username":"valalalalala","description":" Much faster without arrays, picked 5 joints arbitrarily. Comment out the macro DISARMING for increased monstrosity. \n\nWindowed, 35 arms runs around 30ps on the desktop and 3 around 20 fps laptop. With 3 joint, 22 arms  fullscreen is ok.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fabrik","iksolve","inversekinematics"],"hasliked":0,"parentid":"sdXGWs","parentname":"Momo The Monster (vllll)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        //////////////////////////////////////////////////////////////////////\n       //                                                                  ///  \n      //  \"Momo The Monster (redux)\"                                      ////   \n     //                                                                  // //   \n    //  Inverse kinetics are super cool and useful for all sorts        //  //  \n   //  of animation, this is a \"quick\" implementation of FABRIK        //   // \n  //  http://www.andreasaristidou.com/publications/papers/FABRIK.pdf  //    // \n //                                                                  //    //\n//////////////////////////////////////////////////////////////////////    // \n//                                                                 //    //\n// CC0 1.0 Universal                                               //   //\n// https://creativecommons.org/publicdomain/zero/1.0/              //  //\n//                                                                 // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                               ////\n//                                                                 ///\n/////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////\n//\n// Forked of https://www.shadertoy.com/view/sdXGWs\n//\n// The original paper:\n// \n// http://www.andreasaristidou.com/publications/papers/FABRIK.pdf\n//\n// My (fixed) 2d js version:\n// \n// https://editor.p5js.org/luckybit4755/sketches/Pu8BCdPfm\n//\n// Related shaders:\n//\n// FABRIK demo #1 (mplanck) <-- wish I'd seed this earlier on :-P\n// https://www.shadertoy.com/view/MtdSzn\n//\n// Robotic Arm Hunting Lights (reinder)\n// https://www.shadertoy.com/view/tlSSDV\n//\n// IK Solver (iq) MIT\n// https://www.shadertoy.com/view/ldlGR7\n//\n// The Popular Shader\n// https://www.shadertoy.com/view/XdB3Dw\n//\n// Insect (iq) can't be c/p'd\n// https://www.shadertoy.com/view/Mss3zM\n//\n// Fk and IK (mxr233)\n// https://www.shadertoy.com/view/3tfGz4\n//\n// The Momo I knew was a yellow version of something like:\n//\n// https://www.youtube.com/watch?v=57uZNmIu45g\n//\n/////////////////////////////////////////////////////////////////////\n\n#define DISARMING\n\n#ifdef DISARMING\n    const int ARM_COUNT    = 5;\n    const int FABRIK_STEPS = 3;\n#else\n    const int ARM_COUNT    = 35;\n    const int FABRIK_STEPS = 3;\n#endif\n\n#define STOP_EARLY\n\n/////////////////////////////////////////////////////////////////////\n// implementation of the FABRIK heuristic: \n\n#define FIO inout vec3\n\nfloat fabrik( vec3 goal, FIO p0, FIO p1, FIO p2, FIO p3, FIO p4 ) {\n    float d0, d1, d2, d3, total = .0;\n    total += d0 = distance( p1, p0 );\n    total += d1 = distance( p2, p1 );\n    total += d2 = distance( p3, p2 );\n    total += d3 = distance( p4, p3 );\n\n    // put distance goals within reach.\n    \n    float toGoal = length( goal );\n    \n    if ( total < toGoal ) {\n        goal = total * normalize( goal );\n    }\n    \n    // forward reach: figure 1 (a-d)\n\n    vec3 f4 = goal; // set last joint to to goal (figure 1.b)\n    vec3 f3 = f4 + d3 * normalize( p3 - f4 ); // eg, p3'\n    vec3 f2 = f3 + d2 * normalize( p2 - f3 ); \n    vec3 f1 = f2 + d1 * normalize( p1 - f2 ); \n    vec3 f0 = f1 + d0 * normalize( p0 - f1 ); \n\n    // backwards reach: figure 1 (e,f)\n    \n    p1 = p0 + d0 * normalize( f1 - p0 );\n    p2 = p1 + d1 * normalize( f2 - p1 );\n    p3 = p2 + d2 * normalize( f3 - p2 );\n    p4 = p3 + d3 * normalize( f4 - p3 );\n\n    return distance( p4, goal );\n}\n\nfloat fabrik( vec3 goal, FIO p0, FIO p1, FIO p2, FIO p3 ) {\n    float d0, d1, d2, total = .0;\n    total += d0 = distance( p1, p0 );\n    total += d1 = distance( p2, p1 );\n    total += d2 = distance( p3, p2 );\n\n    // put distance goals within reach.\n    \n    float toGoal = length( goal );\n    \n    if ( total < toGoal ) {\n        goal = total * normalize( goal );\n    }\n    \n    // forward reach: figure 1 (a-d)\n\n    vec3 f3 = goal;\n    vec3 f2 = f3 + d2 * normalize( p2 - f3 ); \n    vec3 f1 = f2 + d1 * normalize( p1 - f2 ); \n    vec3 f0 = f1 + d0 * normalize( p0 - f1 ); \n\n    // backwards reach: figure 1 (e,f)\n    \n    p1 = p0 + d0 * normalize( f1 - p0 );\n    p2 = p1 + d1 * normalize( f2 - p1 );\n    p3 = p2 + d2 * normalize( f3 - p2 );\n    return distance( p3, goal );\n}\n    \nfloat fabrik( vec3 goal, FIO p0, FIO p1, FIO p2 ) {    \n    float d0, d1, total = .0;\n    total += d0 = distance( p1, p0 );\n    total += d1 = distance( p2, p1 );\n\n    // put distance goals within reach.\n    \n    float toGoal = length( goal );\n    \n    if ( total < toGoal ) {\n        goal = total * normalize( goal );\n    }\n    \n    // forward reach: figure 1 (a-d)\n\n    vec3 f2 = goal;\n    vec3 f1 = f2 + d1 * normalize( p1 - f2 ); \n    vec3 f0 = f1 + d0 * normalize( p0 - f1 ); \n\n    // backwards reach: figure 1 (e,f)\n    \n    p1 = p0 + d0 * normalize( f1 - p0 );\n    p2 = p1 + d1 * normalize( f2 - p1 );\n\n    return distance( p2, goal );\n}\n\nfloat fabrik( vec3 goal, FIO p0, FIO p1 ) {    \n    float d0, total = .0;\n    total += d0 = distance( p1, p0 );\n\n    // put distance goals within reach.\n    \n    float toGoal = length( goal );\n    \n    if ( total < toGoal ) {\n        goal = total * normalize( goal );\n    }\n    \n    // forward reach: figure 1 (a-d)\n\n    vec3 f1 = goal;\n    vec3 f0 = f1 + d0 * normalize( p0 - f1 ); \n\n    // backwards reach: figure 1 (e,f)\n    \n    p1 = p0 + d0 * normalize( f1 - p0 );\n\n    return distance( p1, goal );\n}\n\n/////////////////////////////////////////////////////////////////////\n// ik solving and drawing for each arm trying to reach its goal\n\n#ifdef DISARMING\nvec2 jointed( in vec3 p, in vec3 goal, FIO p0, FIO p1, FIO p2/*, FIO p3, FIO p4*/ ) {\n#else\nvec2 jointed( in vec3 p, in vec3 goal, FIO p0, FIO p1, FIO p2, FIO p3, FIO p4 ) {\n#endif\n    // run fabrik for the current goal on with the current joints\n    \n    #if 1\n    float old = 1e33;\n    for ( int i = 0 ; i < FABRIK_STEPS ; i++ ) {\n        #ifdef DISARMING\n        float d = fabrik( goal, p0, p1, p2 );\n        #else\n        float d = fabrik( goal, p0, p1, p2, p3, p4 );\n        #endif\n        #ifdef STOP_EARLY\n            if ( old < d ) break;\n            old = d;\n        #endif\n    }\n    #else\n        // doesn't help much...\n        fabrik( goal, p0, p1, p2, p3, p4 );\n        fabrik( goal, p0, p1, p2, p3, p4 );\n        fabrik( goal, p0, p1, p2, p3, p4 );\n    #endif\n    \n    // show the goal\n    \n    float r = .003;\n\n    vec2 value = vec2( sdBall( p - goal, 4. * r ), colorIndex( 5 ) );\n\n    // pretty gross...\n    \n    #if 1\n        float d;\n        int i = 0;\n        d = sdCapsule( p, p0, p1, r ); if ( d < value.x ) { value.x = d; value.y = float( i ); } i++; \n        d = sdCapsule( p, p1, p2, r ); if ( d < value.x ) { value.x = d; value.y = float( i ); } i++; \n        #ifndef DISARMING\n        d = sdCapsule( p, p2, p3, r ); if ( d < value.x ) { value.x = d; value.y = float( i ); } i++; \n        d = sdCapsule( p, p3, p4, r ); if ( d < value.x ) { value.x = d; value.y = float( i ); } i++;\n        #endif\n    #else\n        // doesn't help much...\n        float d = min( sdCapsule( p, p0, p1, r ), \n            min( sdCapsule( p, p1, p2, r ), \n                min( sdCapsule( p, p2, p3, r ), sdCapsule( p, p3, p4, r ) )\n            )\n        );\n        value.x = min( value.x, d );\n    #endif\n\n    return value;\n}\n\n/////////////////////////////////////////////////////////////////////\n// less and less interesting from here...\n\n#ifdef DISARMING\nvec2 map( vec3 p, float time, int i, vec3 p0, vec3 p1, vec3 p2 ) {\n#else\nvec2 map( vec3 p, float time, int i, vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4 ) {\n#endif\n    time *= .2;\n    vec2 t = trig( time );\n    float d = .11 + abs( t.x * .22 );\n    \n    d *= .8;\n    \n    vec3 goal = d  * t.xyx;\n    goal.z = d * sin( time + 1. );\n    \n    #ifdef DISARMING\n        return jointed( p, goal, p0, p1, p2 );\n    #else\n        return jointed( p, goal, p0, p1, p2, p3, p4 );\n    #endif\n}\n\nvec2 map( vec3 p ) {   \n    // little gross...\n    \n    float x = .0;\n    float l = .11;\n    float f = .77;\n    vec3 p0 = vec3( x ); x += l; l *= f;\n    vec3 p1 = vec3( x ); x += l; l *= f;\n    vec3 p2 = vec3( x ); x += l; l *= f;\n    #ifndef DISARMING\n    vec3 p3 = vec3( x ); x += l; l *= f;\n    vec3 p4 = vec3( x ); x += l; l *= f;\n    #endif\n    \n    vec2 value = vec2( 1e33, -1. );\n    \n    for ( int i = 0 ; i < ARM_COUNT ; i++ ) {\n        #ifdef DISARMING\n            vec2 j = map( p, iTime + float( i ), i, p0, p1, p2 );\n        #else\n            vec2 j = map( p, iTime + float( i ), i, p0, p1, p2, p3, p4 );\n        #endif\n        if( j.x < value.x ) value = j;\n\n    }\n    \n    return value;\n}\n\n/////////////////////////////////////////////////////////////////////\n// yeah...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fromScreen( fragCoord, iResolution );\n    vec3 color = uv.xyx * .0;\n    \n    float d = 4.;\n    \n    vec3 eye = vec3( .0, .0, -4. );\n    eye = cameraEye( d, iMouse, iResolution, iTime );\n\n    vec3 towards = vec3( .0 );\n    vec3 direction = normalize( camera( eye, towards ) * vec3( uv, d ) );\n    \n    vec2 hit = march( eye,  direction);\n    if ( hit.y  < .0 ) {\n        fragColor *= .0;\n        return;\n    }\n     \n    vec3 p = eye + hit.x * direction;\n    vec3 n = mapNormal( p, hit.x );\n    \n    color = COLORS[ int( hit.y ) ] * ( n.y * .5 + .5 );\n\n    fragColor = vec4( color, 1. );\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#ifndef HW_PERFORMANCE\n#define _SHADERTOY_TAB_COMMON // https://www.shadertoy.com/view/WldSRj\n#endif\n\nconst float FAR  = 55.;\nconst float NEAR = .01;\nconst float TAU  = 6.283185307179586;\n\nconst vec2 HILO = vec2(.1,.9);\nconst vec3[7] COLORS = vec3[] ( HILO.xxy, HILO.xyx, HILO.yxx, HILO.yxy, HILO.xyy, HILO.yyx, HILO.yyy );\n\nfloat colorIndex( int n ) {\n    return mod( float( n ), float( COLORS.length() ) );\n}\n\nvec2 map( vec3 p );\n#ifdef _SHADERTOY_TAB_COMMON\nvec2 map( vec3 p ) { return vec2( .33, 44. ); }\n#endif\n\nvec2 fromScreen( in vec2 fragCoord, in vec3 resolution ) {\n    return ( fragCoord - resolution.xy * .5 ) / resolution.y;\n}\n\n// zxy:ab,zup,xz\nmat3 camera( vec3 eye, vec3 towards ) {\n    vec3 up = vec3( .0, 1., .0 );\n    vec3 z = normalize( towards - eye );\n    vec3 x = normalize( cross( z, up ) );\n    vec3 y = normalize( cross( x, z ) );\n    return mat3( x, y, z );\n}\n\nvec2 march( vec3 eye, vec3 direction ) {\n    vec2 total = vec2( .0, -1. );\n    vec3 p = eye;\n    for ( float i = .0 ; i < FAR ; i++ ) {\n        vec2 current = map( p );\n        total.x += current.x;\n        total.y = current.y;\n        if ( total.x > FAR || abs( current.x ) < NEAR ) break;\n        p += current.x * direction;\n    }\n    total.y = mix( -1., total.y, step( total.x, FAR ) );\n    return total;\n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 mapNormal(vec3 p,float d) {\n    mat3 k = mat3( p, p, p ) - mat3( NEAR );// * d );\n    return normalize(map(p).x - vec3(map(k[0]).x,map(k[1]).x,map(k[2]).x) );\n}\n\nvec2 trig( float a ) {\n    return vec2( cos( a  * TAU ), sin( a * TAU ) );\n}\n\nvec3 cameraEye( float viewDistance, vec4 mouse, vec3 resolution, float time ) {\n    vec2 ms = mouse.z > -999999.0 ? mouse.xy / resolution.xy : vec2( time *.1, .0 );\n    vec2 t = viewDistance * trig( ms.x );\n    float ey = viewDistance * sin( (ms.y*2.-1.) * TAU * .5 );\n    return vec3( t.x, ey, t.y );\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdBall( vec3 p, float r ) {\n    return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}","name":"Common","description":"","type":"common"}]}