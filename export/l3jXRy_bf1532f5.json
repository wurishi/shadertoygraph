{"ver":"0.1","info":{"id":"l3jXRy","date":"1710861557","viewed":85,"name":"Plasma_Orb","username":"Tsuki","description":"Raymarched sphere with distance based glow and a sin displacement.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere","glow","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getRythm () {\n    return 0.5 * sin(4.0 * iTime);\n}\n\nfloat distanceFromSphere (in vec3 pos, in vec3 sphere, float radius) {\n    return length(pos - sphere) - radius;\n}\n\nfloat calcDisplace (in float pos) {\n    return sin(1.0 * pos + iTime * 1.0);\n}\n\nfloat mapWorld (in vec3 pos, in vec4 sphere)\n{\n    float sphere0 = distanceFromSphere(pos, sphere.xyz, sphere.w);\n    float displacement = calcDisplace(pos.x) *  calcDisplace(pos.y) * calcDisplace(pos.z) * 0.25;\n\n    return sphere0 + displacement;\n}\n\nvec3 calculateNormal (in vec3 pos, in vec4 sphere)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = mapWorld(pos + small_step.xyy, sphere) - mapWorld(pos - small_step.xyy, sphere);\n    float gradient_y = mapWorld(pos + small_step.yxy, sphere) - mapWorld(pos - small_step.yxy, sphere);\n    float gradient_z = mapWorld(pos + small_step.yyx, sphere) - mapWorld(pos - small_step.yyx, sphere);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 raymarch(in vec3 rayOrigin, in vec3 rayDirection, in vec3 lightSource, in vec4 sphere, in vec2 uv) {\n    \n    float distanceTraveled = 0.0;\n    float closestDistance = iResolution.x + iResolution.y;\n    \n    const int NUMBER_OF_STEPS = 64;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i) {\n    \n        vec3 currentPos = rayOrigin + distanceTraveled * rayDirection;\n\n        float distanceToClosest = mapWorld(currentPos, sphere);\n\n        if (distanceToClosest < MINIMUM_HIT_DISTANCE) {\n        \n            vec3 normal = calculateNormal(currentPos, sphere);\n            vec3 directionToLight = normalize(currentPos - lightSource);\n\n            float diffuseIntensity = max(0.0, dot(normal, directionToLight));\n\n            return vec3(1.0);    // * diffuseIntensity * 2.0;\n        }\n        \n        if (closestDistance > distanceToClosest) {\n            closestDistance = distanceToClosest;\n        }\n\n        if (distanceTraveled > MAXIMUM_TRACE_DISTANCE) {\n            \n            break;\n        }\n        \n        distanceTraveled += distanceToClosest;\n    }\n    \n    return vec3(\n        0.5 * cos(1.0 * iTime) + 1.5,\n        0.5 * cos(1.0 * iTime + 1.0) + 1.5,\n        0.5 * cos(1.0 * iTime + 2.0) + 1.5\n        ) / pow(closestDistance, 2.0);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n            \n    vec3 cameraPosition = vec3(0.0, 0.0, -5.0);\n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDirection = vec3(uv, 1.0);\n    \n    vec3 lightSource = vec3(3.0, -5.0, 5.0);\n    \n    vec3 spherePos = vec3(0.0, 0.0, 2.0); // Position\n    vec4 sphere = vec4(spherePos, 3.0); // Radius\n    \n    vec3 color = raymarch(rayOrigin, rayDirection, lightSource, sphere, uv);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}