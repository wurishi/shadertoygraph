{"ver":"0.1","info":{"id":"Xt2yzR","date":"1507191004","viewed":534,"name":"Interactive Marble Exploration","username":"colonel_hilbert","description":"I picked 12 on-off parameters, and divided the screen into 2^12 regions. Click and drag to select which one generates the Marble.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","interactive","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015 - https://www.shadertoy.com/view/MtX3Ws\n// Modified by C. Hinrichs 2017\n\n\nfloat zoom=0.28;\n\n\n//vec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph, bool has0 )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 )\n        if(has0) return vec2(-4.0);\n        else     return vec2(-.50);\n        \n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p, bool has1, bool has2, bool has3, bool has4) {\n\tfloat res = 0.;\n\t\n    vec3 pw = vec3(sin((iTime + 5.)/10.)*0.35 + 1.);\n    \n    vec3 c = p;\n\tfor (int i = 0; i < 5; ++i) {\n        p =.7*pow(abs(p), pw)/dot(p,p) -.7;\n        if(has1) p.yz = csqr(p.yz);\n        if(has2) p    = p.zxy;\n        \n        if(has3) res += exp(-19. *     (abs(dot(p,c))));\n        else     res += exp(-19. * sqrt(abs(dot(p,c))));\n        \n\t}\n    \n    if(!has4) return    (res/2.); \n    else      return log(res/2.);\n}\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax, vec2 m )\n{\n    float t = tminmax.x;\n    float dt = .02;\n    // dt = .2 - .195*cos(iTime*.05);//animated\n    \n    vec3 col= vec3(0.);\n    float c = 0.;\n    float sc = 0.14;\n    \n    //moving these computations outside of the main loop\n    bool has1  = mod(m.x *  .5, 1.) > 0.5;\n    bool has2  = mod(m.x      , 1.) > 0.5;\n    bool has3  = mod(m.x *  2., 1.) > 0.5;\n    bool has4  = mod(m.x *  4., 1.) > 0.5;\n    bool has5  = mod(m.x *  8., 1.) > 0.5;\n   \n    \n    bool has6  = mod(m.y * .25, 1.) > 0.5;\n    bool has7  = mod(m.y *  .5, 1.) > 0.5;\n    bool has8  = mod(m.y      , 1.) > 0.5;\n    bool has9  = mod(m.y *  2., 1.) > 0.5;\n    bool has10 = mod(m.y *  4., 1.) > 0.5;\n    bool has11 = mod(m.y *  8., 1.) > 0.5;\n    \n    \n    for( int i=0; i<68; i++ )\n\t{\n        if(    has6) \n            if(has7) t+=dt*exp(-11.*c);\n            else     t+=dt*exp(-1.8*c);\n        else\n            if(has7) t+=dt*exp(-3.6*c);\n            else     t+=dt*exp(-7.8*c);\n        \n        vec3 pos = ro+t*rd;\n        \n        c = map(pos, has1, has2, has3, has4);           \n        if(t>tminmax.y && tminmax.x != tminmax.y && has4 ) break; // c /= 1.25;\n        \n        //There are some interactions between flags 3&4 and 6&7\n        if(has3){\n            c=c*c;\n            if(has6 || has7) sc = 0.005;\n            if(has4) sc = sc/5.;\n        }\n        \n        if(    !has9)\n            if(!has10) col +=  sc*vec3(c*c*c, c*c, c);//blue\n            else       col +=  sc*vec3(c*c, c, c*c*c);//green\n        else\n        \tif(!has10) col +=  sc*vec3(c, c*c, c*c*c);//red\n            else       col +=  sc*vec3(c*c, c*c, c*c);//white\n    }\n    \n    if(! has11) col *= log(1.25 + 2.*abs(rd.yxz));\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy*3.14;\n    else               m = vec2(mod(iTime/83., iTime/199.), 0.89);\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    \n    \n    //m=p;\n    vec2 tmm = iSphere( ro, rd, vec4(.8,0.,.45,1.), mod(m.x * .25, 1.) <= 0.5 );\n\n\t// raymarch\n    vec3 col = raymarch(ro,rd,tmm, m);\n    //if (tmm.x<0.)col = texture(iChannel0, rd).rgb;\n    //else {\n    //    vec3 nor=(ro+tmm.x*rd)/2.;\n    //    nor = reflect(rd, nor);        \n    //    float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\n    //    col += texture(iChannel0, nor).rgb * fre;\n    //}\n\t\n\t// shade\n    \n    if(mod(m.x *  8., 1.) <= 0.5) col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n     \n    fragColor = vec4( col, 1.0 );\n}\n\n\n/*\n\tParameters:\n\tl. 21 return -2. or -1.\t\t0x001\n\tl. 33 do or don't do\t\t0x002\n\tl. 34 do or don't do\t\t0x004\n\tl. 35 do sqrt or not\t\t0x008\n\tl. 38 log or not\t\t\t0x010\n\tl. 45 or l.46\t\t\t\t0x020\n\tl. 55 do or don't do\t\t0x040\n\n\tl. 51 12.0, 7.8, 3.6, 1.8 \t0x080, 0x100\n\tl. 57-59 R,G,B or white\t\t0x200, 0x400\n\tl. 61 Do chroma or not\t\t0x800\n\n\t12 bits - 128x32 for every combination\n*/","name":"Image","description":"","type":"image"}]}