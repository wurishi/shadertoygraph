{"ver":"0.1","info":{"id":"MtdfRB","date":"1540215655","viewed":73,"name":"Extracredit-ZenOhDBZ","username":"tqle","description":"extracredit","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["extracredit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat (v, r) (mod(v, r) - r/2.)\n\nstruct Shape {\n    float dist;\n    vec4 color;\n};\n//Randomizing vectors, parametizes a vec2 to return a float\nfloat random(vec2 v) {\n    return fract(sin(dot(v*1., vec2(324.654, 156.546)))*46556.2);\n}\n//Rotating shape using matrix transformation\nmat2 rot(float a) {\n    float r = cos(a);\n    float f = sin(a);\n    return mat2(r, f, -f, r);\n}\n//Produces a cylinder, \nfloat fCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\n//Produces a sphere\nfloat sphere(vec3 v, float r) {\n    return length(v) - r;\n}\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n//Produces a box\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n//Mixing colors, where the 3rd parameter is the mixing ratio \nfloat mixColors(float r, float v, float z) {\n    return clamp(.5 + .5*(v - r)/z, 0., 1.);\n}\n//Mixing shapes, or blending the pixels projected onto the screen\nfloat mixShapes(float v, float f, float r) {\n    float z = mixColors(v, f, r);\n    return mix(f, v, z) - r*z*(1. - z);\n}\n//Produces a cone(circular base)\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\nfloat sdEllipsoid(in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0 - 1.0)/k1;\n}\n\n//float opTwist(vec3 p) {\n//    float c = cos(20.0*p.y);\n//    float s = sin(20.0*p.y);\n//    mat2  m = mat2(c,-s,s,c);\n//    vec3  q = vec3(m*p.xz,p.y);\n//    return primitive(q);\n//}\n//Changing coordinate system to polar coordinates, making it easy to stretch shapes\nfloat pModPolar(inout vec2 v, float r) {\n    float f = 6.28318/r;\n    float z = atan(v.y, v.x) + f*.5;\n    float m = floor(z/f);\n    z = mod(z, f) - f*.5;\n    v = vec2(cos(z), sin(z))*length(v);\n    return m;\n}\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(.5);\n}\n//Modifying the coordinate system\nfloat pMod1(inout float p, float size) {\n    float halfSize = size*.5;\n    float c = floor((p + halfSize)/size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\n//Similar to smooth step function, removing edges of shapes\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n//Rotating shapes on Y axis\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n//Blending shapes, merging them together while creating rippples\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.)/2.*r;\n        p.x += columnradius*sqrt(2.);\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\nfloat sdCappedCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n    a = -a;\n    float m = min(a, b);\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/n/2.;\n        columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.y += columnradius;\n        p.x -= sqrt(2.)/2.*r;\n        p.x += -columnradius*sqrt(2.)/2.;\n       \t\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = -length(p) + columnradius;\n        result = max(result, p.x);\n        result = min(result, a);\n        return -min(result, b);\n    } else {\n        return -m;\n    }\n}\n//Projecting shapes\nShape character(vec3 c) {\n    Shape shape;\n    shape.dist = 1000.;\n    shape.color = vec4(1.);\n    //instiating vars\n   \tvec3 h = c; //head \n    vec3 be = c; //beak\n    vec3 e = c; //eyes \n    vec3 p = c; //pupil\n    vec3 br = c; //brows\n    vec3 b = c; //body \n    vec3 f = c; //feathers/halo\n    vec3 arone = c; //arms\n    vec3 artwo = c;\n    vec3 pro = c; //propeller \n    vec3 m = c;\n    \n    vec4 hColor = vec4(1., 1., 1., 1.);\n    h.x *= cos(sin(h.x*3.))*.6;\n    float head = sphere(h - vec3(0., 1., 0.), 1.);\n    m.xy *= cos(sin(m.x*3.));\n    float mouth = fBox(m - vec3(0., .6, -1.5), vec3(.1, .1, .1));\n    be.xy *= rot(radians(270.));\n    vec4 beColor = vec4(.9, 0., 0., .5);\n    float beak = fCone(be - vec3(-.85, .8, -.4), .25, .5);\n    p.x = abs(p.x) - .45;\n    float pupil = sphere(p - vec3(0., .95, -1.25), .1);\n    e.x = abs(e.x) - .085;\n    float eyes = sphere(e - vec3(.4, 1., -1.), .15);\n   \t//float eyes = sphere(e - vec3(.4, 1., -1.), .2);\n    //float pupil = sphere(p - vec3(.5, 1., -1.25), .07);\n    br.xy *= rot(radians(350.));\n    //br.x +=  sin(br.x*5. - iTime*1.5)*(2. - br.y)*.3;\n    vec4 brColor = vec4(0., 0., 0., 1.);\n    float brow = fBox(br - vec3(.3, 1.3, -1.), vec3(.25, .07, .25));\n    arone.xy *= rot(radians(80.));\n    vec4 aroneColor = vec4(0., 0., 0., 1.);\n\tfloat armone = sdEllipsoid(arone - vec3(-.5, .75, -1.), vec3(.5, .25, .5));\n    artwo.xy *= rot(radians(100.));\n    vec4 artwoColor = vec4(0., 0., 0., 1.);\n    float armtwo = sdEllipsoid(artwo - vec3(-.5, -.75, -1.), vec3(.5, .25, .5));\n    vec4 bColor = vec4(1., 1., .9, 1.);\n    float body = sphere(b - vec3(0., -.5, 0.), 1.25);\n\tpro.x += sin(pro.x*15. - iTime*2.)*(2. - pro.y)*.03;\n    pro.xy *= rot(radians(180.));\n    vec4 proColor = vec4(1., 0., 0., .9);\n    float propeller = fCone(pro - vec3(0., 1.6, 0.), .5, 1.);\n    //Create effects of an Emperor penguin, crown on top of head\n    //f.x = abs(f.x)-.1; \n  \t//f.x = abs(f.x)-0.1; \n  \t//f.x += sin(f.y*15. - iTime * 2.)*(2. - f.y)*.03; \n  \t//float feathers = fCone(f + vec3(0., -1.25, 2.5), .14, .3); \n    f.xy *= rot(radians(5.*sin(iTime)));\n    vec4 haColor = vec4(1., 1., 0., 1.);\n    float halo = sdTorus(f - vec3(0., 2.25, 0.), vec2(.7, .1));\n    shape.dist = head;\n    //shape.dist = fOpUnionRound(shape.dist, beak, .15);\n    shape.dist = min(shape.dist, eyes);\n    shape.dist = min(shape.dist, pupil);\n    //shape.dist = min(shape.dist, brow);\n    shape.dist = fOpUnionRound(shape.dist, body, .1);\n    //shape.dist = fOpUnionRound(shape.dist, feathers, .1);\n    shape.dist = min(shape.dist, halo);\n    shape.dist = min(shape.dist, armone);\n    shape.dist = min(shape.dist, armtwo);\n    shape.dist = min(shape.dist, propeller);\n    shape.dist = min(shape.dist, mouth);\n   \n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    shape.color = mix(bColor, hColor, mixColors(head, body, 0.));\n    //shape.color = mix(shape.color, brColor, mixColors(brow, shape.dist, .1));\n    shape.color = mix(shape.color, haColor, mixColors(halo, shape.dist, .1));\n    //shape.color = mix(shape.color, beColor, mixColors(beak, shape.dist, .1));\n    shape.color = mix(shape.color, aroneColor*10., mixColors(armone, shape.dist, .25));\n    shape.color = mix(shape.color, artwoColor*10., mixColors(armtwo, shape.dist, .25));\n    shape.color = mix(shape.color, proColor*10., mixColors(propeller, shape.dist, .1));\n    return shape;\n}\n\nShape map(vec3 c){\n  Shape shape = character(c);\n  return shape;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  //modifying the coordinate system \n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  //setting camera position \n  vec3 cam = vec3(0., 0., -8.5);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1; z <= 1.;z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1. - z); // Hit  - invert pixels\n      break;\n    }\n    scene += f*c.dist;\n\n\n  }\n}\n    ","name":"Image","description":"","type":"image"}]}