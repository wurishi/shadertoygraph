{"ver":"0.1","info":{"id":"ltdyRX","date":"1533504907","viewed":149,"name":"Glass blob inception","username":"bit2shift","description":"The cubemapped-on-itself version of [url]https://www.shadertoy.com/view/MsGGRG[/url]","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","cubemap","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 color, in vec2 coord)\n{\n    vec2 uv = ((2.0 * coord) - iResolution.xy) / min(iResolution.x, iResolution.y) * tan(radians(FOV) / 2.0);\n    \n    mat3 rot = rotY(iTime * 50.0);\n    vec3 origin = rot * vec3(0, 0, -3.0);\n    vec3 direction = rot * normalize(vec3(uv, 1));\n    \n    time_is_relative = sin(iTime);\n    vec3 p = march(origin, direction);\n    if(map(p) < EPSY)\n    {\n        vec3 n = norm(p);\n        vec3 fl = reflect(direction, n);\n        vec3 fr = refract(direction, n, (1.0 / 1.5));\n        color = mix(texture(iChannel0, fl), texture(iChannel0, fr), 0.75);\n    }\n    else\n        color = texture(iChannel0, direction);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap(out vec4 color, in vec2 coord, in vec3 ignored_1, in vec3 ignored_2)\n{\n    vec2 uv = ((2.0 * coord) - iResolution.xy) / min(iResolution.x, iResolution.y) * tan(radians(FOV) / 2.0);\n    \n    mat3 rot = rotY(iTime * 50.0);\n    vec3 origin = rot * vec3(0, 0, -3.0);\n    vec3 direction = rot * normalize(vec3(uv, 1));\n    \n    time_is_relative = sin(iTime);\n    vec3 p = march(origin, direction);\n    if(map(p) < EPSY)\n    {\n        vec3 n = norm(p);\n        vec3 fl = reflect(direction, n);\n        vec3 fr = refract(direction, n, (1.0 / 1.5));\n        color = mix(texture(iChannel0, fl), texture(iChannel0, fr), 0.75);\n    }\n    else\n        color = texture(iChannel0, direction);\n}\n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"const float FOV = 90.0;\nconst int STEPS = 128;\nconst float EPSY = 0.001;\n\nfloat time_is_relative = 0.0;\n\nfloat map(vec3 p)\n{\n    return (length(p) - 1.0) +\n        sin(2.0 * p.x * time_is_relative) *\n        sin(2.0 * p.y * time_is_relative) *\n        sin(2.0 * p.z * time_is_relative);\n}\n\nfloat diff(vec3 p, vec3 h)\n{\n    return (map(p + h) - map(p - h)) / (2.0 * length(h));\n}\n\nvec3 norm(vec3 p)\n{\n    mat3 e = mat3(EPSY);\n    float x = diff(p, e[0]);\n    float y = diff(p, e[1]);\n    float z = diff(p, e[2]);\n    return normalize(vec3(x, y, z));\n}\n\nvec3 march(vec3 origin, vec3 direction)\n{\n    for(int i = 0; i < STEPS; i++)\n    {\n        float dist = map(origin);\n        if(dist < EPSY)\n            break;\n        else\n            origin += (direction * dist);\n    }\n    return origin;\n}\n\nmat3 rotX(float angle)\n{\n    float cs = cos(radians(angle));\n    float sn = sin(radians(angle));\n    \n    vec3 c0 = vec3(1,   0,  0);\n    vec3 c1 = vec3(0,  cs, sn);\n    vec3 c2 = vec3(0, -sn, cs);\n    return mat3(c0, c1, c2);\n}\n\nmat3 rotY(float angle)\n{\n    float cs = cos(radians(angle));\n    float sn = sin(radians(angle));\n    \n    vec3 c0 = vec3(cs, 0, -sn);\n    vec3 c1 = vec3( 0, 1,   0);\n    vec3 c2 = vec3(sn, 0,  cs);\n    return mat3(c0, c1, c2);\n}\n","name":"Common","description":"","type":"common"}]}