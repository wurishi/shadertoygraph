{"ver":"0.1","info":{"id":"3tBSWG","date":"1566866538","viewed":1646,"name":"Better SDF soft shadows","username":"stduhpf","description":"I came up with a simple trick to improve variable penumbra shadows for distance field raymarching. It's still not perfect, but i think it's still better than what we are used to.","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","showcase"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = (iTime<55.)?texture(iChannel0,uv):texture(iChannel1,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float csize = .0625;\nconst float PI = acos(-1.);\nconst float newTime = 26.;\n\n\n//map paramerters\nconst vec2 circlePos = vec2(.9,.75);\nconst vec2 circleSize = vec2(.9,.75);\n\nvec4 getchar(vec2 uv ,int id)\n{\n    vec2 o =floor(uv/csize);\n\tfloat c = float (id);\n\tuv=mod(uv,csize);\n\tuv.y = csize-uv.y;\n\tuv.x=mod(uv.x+csize*c,1.);\n\tuv.y+=csize*floor(c*csize);\n\t\n\treturn texture(iChannel1, vec2(uv.x,1.-uv.y));\n}\n\nfloat sdfCircle(vec2 p, vec2 c, float r){\n    return distance(p,c)-r;\n}\n\nfloat dfLine( vec2 p, vec2 a, vec2 ba)\n{\n    vec2 pa = p - a;\n    ba=ba.yx*vec2(1.,-1.);\n    float h = dot(pa,ba)/dot(ba,ba);\n    return abs(h);\n}\nfloat dfSeg( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat map(vec2 tc){\n\treturn sdfCircle(tc,circlePos,.15);    \n}\n\nfloat getSoftShadows(vec2 ro, vec2 rd,float sunsize){\n    float d =0.0;\n    float k=tan(sunsize);\n    float r =1.;\n    for(int i =0;i<1000;i++){\n        float h =map(ro+d*rd);\n        if(h<.001)\n            return 0.;\n        r=min(r,h/(max(0.,d)*(k+k)));\n        d+=h;\n        if(d>10.)\n            break;\n    }\n    return r;\n}\nfloat getSofterShadows(vec2 ro, vec2 rd,float sunsize){\n    float d =0.00;\n    float k=tan(sunsize);\n    float r =1.;\n    for(int i =0;i<1000;i++){\n        float h =map(ro+d*rd)+((d*k));//the magic happens here\n        if(h<.001)\n            return 0.;\n        r=min(r,h/(max(0.,d)*(k+k)));\n        d+=h*inversesqrt(d+1.);\n        if(d>10.)\n            break;\n    }\n    return r;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = I/iResolution.xy,tc=I/iResolution.y;\n    float eps = 3./iResolution.y;\n    float noise = .2*texture(iChannel0,3.*uv).b;\n    O = vec4(0.0,0.0,1.0-noise*1.5,1.0)*.8;\n    O.rg=.65*vec2(smoothstep(.95,.98,cos(tc*20.*PI*2.)))*(1.-noise);\n    O.rg = max(O.xy,O.yx);\n    O.b-=O.r*.2;\n    \n    float dither =(.5+.5*sin(dot(I,vec2(.75))))*.65+.35*(.5+.5*sin(dot(I,vec2(.5,-.5))));\n    dither=sqrt(dither);\n    float sunsize = .09250245;\n    if(iTime>12.&&iTime<newTime)\n        sunsize = sunsize+(iTime-12.)*.02;\n    if(iTime-newTime>12.&&iTime<2.*newTime)\n        sunsize = sunsize+(iTime-12.-newTime)*.02;\n\n    vec2 cs = vec2(cos(sunsize),sin(sunsize));\n    \n    vec2 ld = normalize(vec2(.5,.95));\n    vec2 ldm = ld*mat2(cs,-cs.y,cs.x);\n    vec2 ldp = ld*mat2(cs.x,-cs.y,cs.yx);\n    \n    vec2 ro = vec2(.7,.05);\n    //ro.x = iMouse.x/iResolution.y;\n    \n    if(iTime<newTime){\n        if(tc.y<.05){\n            O.rgb = vec3(pow(getSoftShadows(vec2(tc.x,.05),ld,sunsize),1./2.4));\n        }else{\n            float draw = 0.;\n            if(uv.y>csize*14.2&&uv.x<csize*3.){\n                vec4 c = vec4(0);\n                vec2 tc = uv-csize*vec2(1.1,14.2);\n                if(floor(tc/csize)==vec2(0.))c=getchar(tc,79);\n                tc.x-=csize*.52;\n                if(floor(tc/csize)==vec2(0.))c=max(getchar(tc,108),c);\n                tc.x-=csize*.52;\n                if(floor(tc/csize)==vec2(0.))c=max(getchar(tc,100),c);\n                draw = max(draw,c.r);\n            }\n            float df = map(tc);\n            draw = max(draw,smoothstep(eps,0.,abs(df)));\n            draw = max(draw,smoothstep(eps,0.,dfLine(tc,ro, ld)));\n            draw = max(draw,smoothstep(eps,0.,dfLine(tc,ro, ldm)));\n            draw = max(draw,smoothstep(eps,0.,dfLine(tc,ro, ldp)));\n            \n            O=mix(O,vec4(1.),draw);\n            float sm = smoothstep(11.,12.,iTime);\n\t\t\tif(iTime<12.){\n                float d = 0.;\n                for(float i =0.;i<10.;i++){\n                    if(iTime>i+1.){\n                        vec2 p =ro+d*ld;\n                        float h =map(p);\n                        O=mix(O,vec4(1.,0.,0.,1.),smoothstep(eps+.001,.001,distance(tc,p))*(1.-sm));\n                        O=mix(O,vec4(.1,1.,.1,1.),smoothstep(eps,0.,abs(sdfCircle(tc,p,h)))*(1.-sm));\n                        d+=h;\n                    }\n                }\n            }\n\t\t\tif(iTime>11.){\n                float s = sm*.75*step(dither*1.2+.01,1.-getSoftShadows(tc,ld,sunsize));\n                O=mix(O,vec4(.9,.8,.7,1.),s);\n            }\n        }\n    }else{\n        if(tc.y<.05){\n            O.rgb = vec3(pow((getSofterShadows(vec2(tc.x,.05),ld,sunsize)),1./2.4));\n        }else{\n            float draw = 0.;\n            if(uv.y>csize*14.2&&uv.x<csize*3.){\n                vec4 c = vec4(0);\n                vec2 tc = uv-csize*vec2(1.1,14.2);\n                if(floor(tc/csize)==vec2(0.))c=getchar(tc,78);\n                tc.x-=csize*.52;\n                if(floor(tc/csize)==vec2(0.))c=max(getchar(tc,101),c);\n                tc.x-=csize*.52;\n                if(floor(tc/csize)==vec2(0.))c=max(getchar(tc,119),c);\n                draw = max(draw,c.r);\n            }\n            float df = map(tc);\n            draw = max(draw,smoothstep(eps,0.,abs(df)));\n            \n            draw = max(draw,smoothstep(eps,0.,dfLine(tc,ro, ld)));\n            draw = max(draw,smoothstep(eps,0.,dfLine(tc,ro, ldm)));\n            draw = max(draw,smoothstep(eps,0.,dfLine(tc,ro, ldp)));\n            \n            O=mix(O,vec4(1.),draw);\n            float sm = smoothstep(12.,11.,iTime-newTime);\n\t\t\tvec2 ldo = vec2(-ld.y,ld.x);\n            if(iTime-newTime<12.){\n                float d = 0.;\n                float k = tan(sunsize);\n                for(float i =0.;i<10.;i++){\n                    if(iTime-newTime>i+1.){\n                        vec2 p =ro+d*ld;\n                        float h =map(p)+d*k;\n                        O=mix(O,vec4(1.,.5,.1,1.),smoothstep(eps,0.,abs(map(tc)+d*k))*sm);\n                        O=mix(O,vec4(.8,.7,.5,1.),\n                              .75*smoothstep(eps,0.,abs(sdfCircle(tc,p-ldo*(d*k+h),h)))*sm);\n                        O=mix(O,vec4(.1,1.,.1,1.),smoothstep(eps,0.,abs(sdfCircle(tc,p,h)))*sm);\n                        //O=mix(O,vec4(.55,.5,.1,1.),smoothstep(eps,0.,abs(dfSeg(tc,circlePos,p,0.)))*sm);\n                        O=mix(O,vec4(1.,0.,0.,1.),smoothstep(eps+.001,.001,distance(tc,p))*sm);\n\n                        d+=h*inversesqrt(d+1.); //i forgot to show this,it's important because otherwise some geometry can be ignored\n                    }\n                }\n            }\n\t\t\tif(iTime-newTime>11.){\n                float s = .75*step(dither*1.2+.01,1.-getSofterShadows(tc,ld,sunsize));\n                O=mix(O,vec4(.9,.8,.7,1.),s);\n            }\n        }\n    }\n    //O=vec4(dither);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float sunsize = .09250245; //10 times larger than real life sun\n\nfloat map(vec3 p){\n    return min(p.y+.5,\n        min(distance(p,vec3(2.,1.25+sin(3.*iTime),0))-.75,\n            distance(p,vec3(-2.,1.25+cos(3.*iTime),0))-.75\n           ));\n}\n\nvec3 nor(vec3 p){\n    vec2 e = vec2(.001,0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy)\n        ,map(p+e.yxy)-map(p-e.yxy)\n        ,map(p+e.yyx)-map(p-e.yyx)));\n}\n\nfloat intersect(vec3 ro, vec3 rd){\n    float d =0.;\n    for(int i =0;i<1000;i++){\n        float h =map(ro+d*rd);\n        if(h<.01)\n            return d;\n        d+=h;\n    }\n    return -1.;\n}\n\nfloat getSoftShadows(vec3 ro, vec3 rd){\n    float d =0.02;\n    float k=tan(sunsize);\n    float r =1.;\n    for(int i =0;i<1000;i++){\n        float h =map(ro+d*rd);\n        if(h<.001)\n            return 0.;\n        r=min(r,h/(max(0.,d)*(k+k)));\n        d+=h;\n        if(d>10.)\n            break;\n    }\n    return r;\n}\nfloat getSofterShadows(vec3 ro, vec3 rd){\n    float d =0.02;\n    float k=tan(sunsize);\n    float r =1.;\n    for(int i =0;i<1000;i++){\n        float h =map(ro+d*rd)+((d*k));//the magic happens here\n        if(h<.001)\n            return 0.;\n        r=min(r,h/(max(0.,d)*(k+k)));\n        d+=h*inversesqrt(d+1.);\n        if(d>10.)\n            break;\n    }\n    return r;\n}\n\nfloat ao(vec3 p, vec3 n){\n    float oc =0.;\n    float d=0.02;\n    for(int i=0;i<5;i++){\n        float h =map(p+d*n);\n        oc+=(d-h)*exp2(-float(i));\n        d+=h;\n    }\n    return 1.-8.*(oc);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord-iResolution.xy;\n    \n\tvec3 rd = normalize(vec3(uv,1.5*iResolution.y));\n\tvec3 ro = vec3(0,1.8,-10);\n    \n    float d = intersect(ro,rd);\n    vec3 p = ro+d*rd;\n    vec3 n = nor(p);\n    \n    vec3 ld = normalize(vec3(0,.5,1));\n    \n    float shd =uv.x<0.?getSoftShadows(p,ld):getSofterShadows(p,ld);\n    float dif = max(0.,dot(n,ld))*shd+.0*max(0.,.5+n.y)*ao(p,n);\n\n    fragColor = (.5+.5*sign(d))>0.?pow(vec4(dif),vec4(1./2.4)):\n            vec4(smoothstep(.01+sunsize,sunsize,asin(distance(rd,ld))))\n            ;\n}","name":"Buffer B","description":"","type":"buffer"}]}