{"ver":"0.1","info":{"id":"mtX3zl","date":"1672225463","viewed":96,"name":"Cross-Correlation","username":"Envy24","description":"Read Image tab header.\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["linear","system","response","graphs","autocorrelation","dsp","crosscorrelation"],"hasliked":0,"parentid":"DtfGzs","parentname":"Linear Convolution"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n   n = f(t)  - discrete function of time,\n   Blue      - input signal x(n),\n   Purple    - other input signal h(n),\n   Red       - demonstration of cross-correlation process,\n   Dark Cyan - cross-correlation[x(n), h(n)].\n   \n   Source: https://upload.wikimedia.org/wikipedia/commons/2/21/Comparison_convolution_correlation.svg\n   \n   Cross-correlation is not commutative, e.g. xcross(x, h) != xcross(h, x).\n*/\n\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define ORIGIN                    ( vec2(0, 0) )\n#define SCENE_SCALE               ( 15.0 )\n#define UNIT                      ( 2.0*SCENE_SCALE / R.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx); // arclength change over argument change\n    return SMAA(abs(sdf) / dsdx);\n                           \n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nfloat step_(float n) { return n < 0. ? 0. : 1.; } // step signal\nfloat unit(float n) { return n == 0. ? 1. : 0.; } // unit impulse\n\n#define MIN (-21.)\n#define MAX (20.)\n#define T (iTime * 0.1)\n\n//#define LOOP(T) ( loop_continuous(MIN, MAX, T) )\n#define LOOP(T) ( loop_discrete(MIN, MAX, T) )\n//#define LOOP(T) ( (40.*T) )\n//#define LOOP(T) ( 0. ) // off loop\n\nfloat x(float n)\n{\n    //return unit(n) * 1.;\n    \n    //if (abs(n) <= 15.) { return (15. - abs(n)) / 3.; }\n    if (abs(n) <= 3.) { return 6.; }\n    return 0.;\n}\nfloat h(float n) // filter\n{\n    //return unit(n) * 1.;\n\n    if (abs(n) <= 3.) { return (3. - n); }\n    return 0.;\n}\n\nfloat cross_correlation(float n)\n{\n    float sum = 0., f = x(n);\n    for (float k = MIN; k <= MAX; k += 1.)\n    {\n        //sum += x(k)*h(n + k); // xcross(x, h)\n        sum += h(k)*x(n + k); // xcross(h, x)\n        // Cross-correlation is not commutative, e.g. xcross(x, h) != xcross(h, x).\n    }\n    return sum;\n}\nfloat auto_correlation(float n)\n{\n    float sum = 0., f = x(n);\n    for (float k = MIN; k <= MAX; k += 1.)\n    {\n        sum += x(n + k)*x(k); // autocorr(x)\n        //sum += h(n + k)*h(k); // autocorr(h)\n    }\n    return sum;\n}\nfloat y(float n) { return cross_correlation(n); }\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    float vert_offset = 7.,  // offset relative to y = 0 line\n          vert_shift = -0.,  // shifts plot up or down\n          x_offs = vert_offset + vert_shift,\n          y_offs = vert_shift - vert_offset;\n\n    vec3 X_col = vec3(0,0,1), Y_col = vec3(1,0,0), H_col = vec3(1,0,1), color = vec3(1.);\n    /* Common stuff */\n         color -= x_axis(vec2(NDC.x, NDC.y - x_offs)); \n         color -= x_axis(vec2(NDC.x, NDC.y - y_offs));\n         color -= y_axis(NDC);\n         color = mix(color, vec3(0,.5,0), vertical_line(NDC, MIN));\n         //color = mix(color, vec3(0,.5,0), vertical_line(NDC, MAX)); // for [min, max)   see discrete_loop\n         color = mix(color, vec3(0,.5,0), vertical_line(NDC, MAX + 1.)); // for [min, max]\n         color = mix(color, vec3(0,0,.5), vertical_line(NDC, LOOP(T)));\n\n    /* Input signal x(n) and impulse response h(n) */\n    float n = round(NDC.x), X = x(n) + x_offs, H = h(n - LOOP(T)) + x_offs;\n         color = mix(color, X_col, SMAA(segmentSDF_L2(NDC, vec2(n, x_offs), vec2(n, X), UNIT*0.25)));\n         color = mix(color, X_col, SMAA(diskSDF_L2(NDC, vec2(n, X), 2.5*UNIT)));\n         \n         color = mix(color, H_col, SMAA(segmentSDF_L2(NDC, vec2(n, x_offs), vec2(n, H), UNIT*0.25)));\n         color = mix(color, H_col, SMAA(diskSDF_L2(NDC, vec2(n, H), 2.5*UNIT)));\n              \n    /* Full system response y(n) to signal x(n) */\n    float scale = pow(2., -4.), // if output is too high, then scale it down.\n          Y = y(n) * scale + y_offs; \n          \n          color = mix(color, 0.75-Y_col, SMAA(segmentSDF_L2(NDC, vec2(n, y_offs), vec2(n, Y), UNIT*0.25)));\n          color = mix(color, 0.75-Y_col, SMAA(diskSDF_L2(NDC, vec2(n, Y), 2.5*UNIT)));\n          \n    /* Partial system response y(n) to signal x(n)  (for demonstration of cross-correlation process) */     \n    for (float s = MIN; s < LOOP(T); s += 1.)\n    {\n        Y = cross_correlation(s) * scale;\n        Y += y_offs; // shift graph to bottom\n        \n        color = mix(color, Y_col, SMAA(segmentSDF_L2(NDC, vec2(s, y_offs), vec2(s, Y), UNIT*0.25)));\n        color = mix(color, Y_col, SMAA(diskSDF_L2(NDC, vec2(s, Y), 2.5*UNIT)));\n    }\n        \n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float loop_continuous(in float min, in float max, in float T)\n{\n    float //range = max - min;        // [min; max)\n          range = (max + 1.) - min; // [min; max]\n    return (min + fract(T) * range);\n}\nfloat loop_discrete(in float min, in float max, in float T)\n{\n    float //range = max - min;        // [min; max)\n          range = (max + 1.) - min; // [min; max]\n    return round(min + fract(T) * range);\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}","name":"Common","description":"","type":"common"}]}