{"ver":"0.1","info":{"id":"csjXzt","date":"1670736578","viewed":195,"name":"dodeca","username":"ENDESGA","description":"///////","likes":16,"published":3,"flags":32,"usePreview":0,"tags":["sdf","wireframe","dodecahedron","dodeca"],"hasliked":0,"parentid":"mdjSR3","parentname":"dodecahedron edges sdf"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//fast bloom: https://www.shadertoy.com/view/MdSyWh\nvec3 srgbToLinear(const vec3 x){\n    return 0.315206*x*((2.10545+x)*(0.0231872+x));\n}\nvec3 linearToSrgb(const vec3 x){\n    return 1.14374*(-0.126893*x+sqrt(x));\n}\n\nvec3 t(vec2 p,float m){\n    return srgbToLinear(texture(iChannel0,p,m).rgb);\n}\n\nvec3 fastBloom (vec2 p,vec2 r){\n    float mip = 2.;\n    float scale = exp2(mip);\n    vec3 c =\n        t((p+vec2(-1.5,-0.5)*scale)/r,mip)*.1+\n        t((p+vec2( 0.5,-1.5)*scale)/r,mip)*.1+\n        t((p+vec2( 1.5, 0.5)*scale)/r,mip)*.1+\n        t((p+vec2(-0.5, 1.5)*scale)/r,mip)*.1+\n        t((p)/r,mip)*.7+\n        t(p/r,0.)*.7;\n    return c;\n}\n\n\nvec3 jodieRobo2(const vec3 d){\n    float c=dot(d,vec3(.2126,.7152,.0722));\n    vec4 e=vec4(d,c)*inversesqrt(c*c+1.);\n    vec3 a=e.rgb;\n    float b=e.a;\n    float f=max(max(max(e.r,e.g),e.b),1.);\n    return (b*a-a-(f*b-b))/(b-f);\n}\n\nvoid mainImage( out vec4 c, in vec2 fc )\n{\n    fc.y=1.-fc.y;\n    vec2 uv = fc.xy/iResolution.xy;\n    c.rgb = linearToSrgb(jodieRobo2(fastBloom(fc.xy,iResolution.xy)));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdf_dodeca_edge(vec3 p, float r, float cr, float b) {\n    vec3 p1 = abs(vec3(0.5,-0.809016994375,0.309016994375) *\n              abs(p.x) + vec3(0.809016994375,0.309016994375,-0.5) *\n              abs(p.y) + vec3(0.309016994375,0.5,0.809016994375) *\n              abs(p.z));\n    vec3 p2 = abs(vec3(0.809016994375,0.309016994375,-0.5) *\n              p1.x + vec3(0.309016994375,0.5,0.809016994375) *\n              p1.y + vec3(0.5,-0.809016994375,0.309016994375) *\n              p1.z);\n    vec3 p3 = abs(vec3(-0.309016994375,-0.5,0.809016994375) *\n              p2.x + vec3(0.5,-0.809016994375,-0.309016994375) *\n              p2.y + vec3(0.809016994375,0.309016994375,0.5) *\n              p2.z);\n    p = (vec3(0.587785252292,-0.809016994375,0.) *\n              p3.x + vec3(-0.425325404176,-0.309016994375,0.850650808352) *\n              p3.y + vec3(0.688190960236,0.5,0.525731112119) *\n              p3.z) -\n              r * vec3(0.3902734644166273,0.2835502694506667,0.63147573033330584);\n    return (b<=1.) ? (mix(\n        length(vec3(max(p.x, 0.0), max(p.y, 0.0), max(p.z, 0.0))) - cr,\n        length(vec3(p.x, max(p.y, 0.0), p.z)) - cr,\n        b)) : (mix(\n        length(vec3(p.x, max(p.y, 0.0), p.z)) - cr,\n        length(vec3(p.x, p.y, p.z)) - cr,\n        b-1.));\n}\n\n\nbool is_bg = false;\nfloat map(vec3 pos){\n    float d = sdf_dodeca_edge(pos - vec3(0.0), 3.0, .1,sin(iTime * 2.)+1.);\n    if(d >= 0.01) is_bg = true; else is_bg = false;\n    return d;\n}\n\nfloat map_approx(vec3 pos) {\n    float d = length(pos) - 3.;\n    if(d >= 0.01) is_bg = true; else is_bg = false;\n    return d;\n}\n\nvec3 norm( vec3 pos )\n{    \n    const float eps = 0.001;\n    float dist = map( pos );\n    return normalize( vec3( dist - map( pos + vec3(eps,0,0) )\n                          , dist - map( pos + vec3(0,eps,0) )\n                          , dist - map( pos + vec3(0,0,eps) ) ) );\n}\n\nvec3 norm_approx( vec3 pos )\n{    \n    const float eps = 0.001;\n    float dist = map_approx( pos );\n    return normalize( vec3( dist - map_approx( pos + vec3(eps,0,0) )\n                          , dist - map_approx( pos + vec3(0,eps,0) )\n                          , dist - map_approx( pos + vec3(0,0,eps) ) ) );\n}\n\nvec3 rotx(vec3 p,float a){\n    return vec3(p.x, p.y * cos(a) + p.z * sin(a), p.y * -sin(a) + p.z * cos(a));\n}\n\nvec3 roty(vec3 p,float a){\n    return vec3(p.x * cos(a) + p.z * sin(a), p.y, p.x * -sin(a) + p.z * cos(a));\n}\n\nvoid mainImage(out vec4 c, in vec2 fc){\n    vec2 sp=(fc * 2. - iResolution.xy) / iResolution.y;\n    vec3 r=normalize(vec3(sp, 7.777));\n    vec3 p=vec3(0, 0, -27.);\n\n    float t = sin(iTime) * 0.777;\n    p = roty(rotx(p, t), iTime * -2.);\n    r = roty(rotx(r, t), iTime * -2.);\n\n    float approx_d = map_approx(p), d = 0.;\n\n    for(int i=0; i<100; i++){\n        if (approx_d <= 0.01) {\n            d = map(p);\n        } else {\n            d = approx_d;\n        }\n\n        p += r * d;\n        if (d <= .01 || d > 100.) break;\n        approx_d = map_approx(p);\n    }\n\n    vec3 n = 1. - exp(-(norm(p) + norm_approx(p)) * .5);\n    c = vec4(vec3(1.-exp(-length(n) * 2.)), 1.0);\n    c *= c * vec4(1.,0.,.25,1.);\n    if(is_bg) c = vec4(0);\n}","name":"Buffer A","description":"","type":"buffer"}]}