{"ver":"0.1","info":{"id":"7sXcR7","date":"1641861869","viewed":144,"name":"Just Another Ray Cast","username":"crowemagnon","description":"Ray casting gone wild. Well... actually... pretty tame. Inspired by an exercise to understand https://www.shadertoy.com/view/WslGWl and https://www.shadertoy.com/view/lss3zr.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Z_MAX 0.7\n#define Z_MIN -0.7\n#define N_MARCHING_STEPS 64\n#define N_LIGHT_MARCHING_STEPS 16\n#define STEP_LENGTH (Z_MAX - Z_MIN)/float(N_MARCHING_STEPS)\n\nuniform float i_time;\nuniform vec2 i_resolution;\n\n// --- \\/ Morgan noise functions and lisence\n\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\n\n// All noise functions are designed for values on integer scale.\n// They are tuned to avoid visible periodicity for both positive and\n// negative coordinates within a few orders of magnitude.\n\n#define NUM_NOISE_OCTAVES 5\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n// --- /\\ Morgan McGuire zone\n\n\n// --- Ray casting functions\n\nfloat sphereDensity(vec3 position) {\n    return 1.0 - length(position)*1.8;\n}\n\nfloat fbmDensity(vec3 position) {\n    vec3 scaledPosition = vec3(\n        position.x + iTime*0.05, \n        position.y, \n        position.z*0.5 + iTime*0.05);\n    return fbm(10.0*scaledPosition);\n}\n\nfloat raySample(vec3 ray) {\n    return fbmDensity(ray)*sphereDensity(ray);\n}\n\n// --- The main show!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord =   vec2(0, 0.4) + 2.*(fragCoord.xy/iResolution.x - 0.5);\n\n    float density = 0.0;\n    float absorption = 100.0;\n    float intensity = 1.0;\n\n    vec3 densityColor = vec3(0.8863, 0.5529, 0.5412);\n    vec3 brightRedishColor = vec3(0.9863, 0.7529, 0.7412);\n    vec3 sunDirection = vec3(1.0, 0., 1.0);\n    \n    vec3 color = vec3(0.);\n\n\n    for (int i = 0 ; i < N_MARCHING_STEPS ; i++) {\n        \n        density += 3.*raySample(\n            vec3(\n                coord.x,\n                coord.y, \n                Z_MIN + STEP_LENGTH*float(i) \n        ))/float(N_MARCHING_STEPS);\n\n        if (density > 0.) {\n            intensity *= 1.-density*absorption;\n            if (intensity < 0.01) {\n                break;\n            }\n\n            float scatter = 1.0;\n\n            color+= vec3(intensity)*density + densityColor*180.*density*intensity*scatter;\n        }\n\n\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}