{"ver":"0.1","info":{"id":"dt3BDM","date":"1701553856","viewed":50,"name":"CSE386 Atmospheric Simulation","username":"faganip","description":"Atmospheric simulation. Forked from a previous attempt to make sure camera stuff didn't screw up the project.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["atmosphere"],"hasliked":0,"parentid":"Dl3BD7","parentname":"CSE386 Final Pt2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n------------------------------------------------------------\nctr + shift + i to open inspector and paste this into console:\n    gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/88u2uo8dxdmgzxo/world2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\nHeavy inspiration from this video by Sebastian Lague:\n    https://www.youtube.com/watch?v=DxfEbulyFcY&t=1110s\n    \nInspiration from this nvidia article:\n    https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n------------------------------------------------------------\n*/\n\n#define PI 3.14159\n\n\n/*\n------------------------------------------------------------\nAtmosphere + Planet Settings\n------------------------------------------------------------\n*/\n\n\n//more inPoints & opticalPoints = more quality = less speed\n#define inPoints 8\n#define opticalPoints 8\n#define planetPos vec3(0.)\n#define radius 1.0\n#define aRadius (radius+1.0)\n//higher number means less dense the further out you go\n#define densityFalloff 5.\n//small number to eliminate collision problems\n#define epsilon 1e-4\n\n\n/*\n------------------------------------------------------------\nLight Settings\n------------------------------------------------------------\n*/\n\n#define sunSpeed .7\n#define sunPos normalize(vec3(-sin(-iTime * sunSpeed) / 2., sin(iTime * sunSpeed), cos(iTime * sunSpeed) / 2.))\n\n\n/*\n------------------------------------------------------------\nColor Settings\n------------------------------------------------------------\n*/\n\n//change these wavelengths to get different colors\n#define WAVELENGTHX 700.\n#define WAVELENGTHY 530.\n#define WAVELENGTHZ 440.\n//Higher scattering strength = lower wavelengths come through more\n#define SCATTERING_STRENGTH 10.\n\n\n/*\n------------------------------------------------------------\nCamera Settings\n------------------------------------------------------------\n*/\n\n//toggle if you want to see planet from distance\n#define isAnimating true\n//look at start\n#define atStart vec3(0.)\n//ray origin start\n#define roStart vec3(0., 0., -6.)\n#define atEnd vec3(0., 1., 0.)\n#define roEnd vec3(0., .8, -.8)\n//the lower the number, the slower it goes (1 is 1 second to zoom in)\n#define animationSpeed .2\n\n//Initializing scattering Coeficients for calculating color falloff\nconst float scatterR = pow(400. / WAVELENGTHX, 4.) * SCATTERING_STRENGTH;\nconst float scatterG = pow(400. / WAVELENGTHY, 4.) * SCATTERING_STRENGTH;\nconst float scatterB = pow(400. / WAVELENGTHZ, 4.) * SCATTERING_STRENGTH;\nconst vec3 scatteringCoef = vec3(scatterR, scatterG, scatterB);\n\n//initializing \nvec3 at = atStart; //change to atEnd to zoom in\nvec3 ro = roStart; //change to orEnd to zoom in\nconst vec3 atDif = vec3(atEnd.x - atStart.x, atEnd.y - atStart.y, atEnd.z - atStart.z);\nconst vec3 roDif = vec3(roEnd.x - roStart.x, roEnd.y - roStart.y, roEnd.z - roStart.z);\n\n//checking for sphere collisions\nvec2 sphereIntersect(vec3 ro, vec3 rd, vec3 p, float r) {\n    vec3 offset = ro - p;\n    float a = 1.;\n    float b = 2.0 * dot(offset, rd);\n    float c = dot(offset, offset) - r * r;\n    float d = b * b - 4. * a * c;\n    \n    //if d > 0, it hit 2 things\n    if (d > 0.) {\n        float s = sqrt(d);\n        //Distance to the sphere near\n        float DSN = max(0.0, (-b - s) / (2. * a));\n        //Distance to the sphere far\n        float DSF = (-b + s) / (2.0 * a);\n        \n        //ignores the hit behind the ray and returns distance to hit and distance of ray through\n        if (DSF >= 0.0) {\n            return vec2(DSN, DSF - DSN);\n        }\n    }\n    \n    //ray didn't hit anything\n    return vec2(0.);\n}\n\n//returns the normal of a sphere\nvec3 sphereNormal(vec3 p, vec3 sphere) {\n    return normalize(p - sphere);\n}\n\n//gets the density of a point within the atmosphere\nfloat densityAtPoint(vec3 p) {\n    float heightAboveSurface = length(p-planetPos) - radius;\n    //changes height between 0 (planet surface) and 1 (top of atmosphere)\n    float height01 = heightAboveSurface / (aRadius - radius);\n    //gets the density at the height based on falloff\n    float localDensity = exp(-height01 * densityFalloff) * (1.0 - height01);\n    return localDensity;\n}\n\n//gets the average density along a ray\nfloat opticalDepth(vec3 ro, vec3 rd, float rl) {\n    //sets first point to the ray origin\n    vec3 densityPoint = ro;\n    //determines how far along the ray to move each step\n    float stepSize = rl / float(opticalPoints-1);\n    //initializes the density total\n    float opticalDepth;\n\n    //goes through all the points along the ray\n    for(int i = 0; i < opticalPoints; i++) {\n        //gets the density at that point\n        float localDensity = densityAtPoint(densityPoint);\n        //adds it to the total with step size accounted for\n        opticalDepth += localDensity * stepSize;\n        //goes to next point\n        densityPoint += rd * stepSize;\n    }\n    return opticalDepth;\n}\n\n//calculates the light at a point\nvec3 light(vec3 ro, vec3 rd, float rl) {\n    //sets initial point to the ray origin\n    vec3 inPoint = ro;\n    //calculates how far along the ray to go each step\n    //depending on the amount of points\n    float stepSize = rl / float(inPoints-1);\n    //initializes the inScatterLight variable\n    vec3 inScatterLight;\n    //loop through all the points along the ray\n    for(int i = 0; i < inPoints; i++) {\n        //gets the length of the ray from the sun to the point\n        float sunRayLength = sphereIntersect(inPoint, sunPos, planetPos, aRadius).y;\n        //gets the average density along that sunray\n        float sunOpticalDepth = opticalDepth(inPoint, sunPos, sunRayLength);\n        //gets the average density along the viewray\n        float viewOpticalDepth = opticalDepth(inPoint, -rd, stepSize * float(i));\n        //how much light is left after some is scattered off through the atmosphere\n        vec3 transmittance = exp(-(sunOpticalDepth + viewOpticalDepth) * scatteringCoef);\n        //gets the density at the current point\n        float localDensity = densityAtPoint(inPoint);\n        \n        //adds the light to the total with step size accounted for\n        inScatterLight += localDensity * transmittance * scatteringCoef * stepSize;\n        //goes to the next point along the ray\n        inPoint += rd * stepSize;\n    }\n    return inScatterLight;\n}\n\n//calculates the camera pos (ray origin) and the look at (at)\nvoid calculateCamera() {\n    \n    if (isAnimating) {\n        //interpolates between the start and end look at and ray origin values\n        at = atStart + atDif * ((sin(iTime * animationSpeed) + 1. )/ 2.);\n        ro = roStart + roDif * ((sin(iTime * animationSpeed) + 1. )/ 2.);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    \n    calculateCamera();\n    \n    //calculates the orientation of the camera to get the ray direciton\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 2.0 * cam_z);\n\n    //initializes screen as black\n    vec3 col = vec3(0);\n    //checks for collisions with planet\n    vec2 s = sphereIntersect(ro, rd, planetPos, radius);\n    //checks for collisions with atmosphere\n    vec2 a = sphereIntersect(ro, rd, planetPos, aRadius);\n    float tmin = 1e19;\n    \n    //the ray hit the planet\n    if(s.x > 0.0 && tmin > s.x) {\n        tmin = s.x;\n        //gets the normal of the planet\n        vec3 sN = sphereNormal(normalize(ro+rd*tmin), planetPos);\n       \n        //gets the point along the ray that hit the planet\n        vec3 p = ro + rd * s.x;\n        //the UV of the texture mapped to the planet\n        vec2 polarUV = vec2(atan(p.x, p.z)/PI, p.y/2.) + .5;\n        \n        //uncomment if you want the planet to spin\n        //polarUV.x -= iTime * .1;\n        \n        //stores the color of the texture at the point on the sphere\n        vec3 bufferA = texture(iChannel0, polarUV).rgb;\n        //sets the color of the sphere\n        col = vec3(max(0.0, dot(sN, sunPos))) * bufferA;\n    }\n    \n    //Distance through the atmosphere whether it hit the planet or not\n    float dtA = min(a.y, tmin-a.x);\n    //if the ray hit the atmosphere\n    if(dtA > 0.0 && tmin > a.x) {\n        //get the point at which it hit the atmosphere\n        vec3 inPoint = ro+rd*(a.x-epsilon);\n        //calculate the light at that point\n        vec3 light = light(inPoint, rd, dtA+epsilon*2.0);\n        //color the screen\n        col = col * (1.0-light) + light;\n    }\n\n    fragColor = vec4(col, 1.0);;\n}","name":"Image","description":"","type":"image"}]}