{"ver":"0.1","info":{"id":"lcKyDm","date":"1731976209","viewed":94,"name":"Black Hole With Kuwahara Filter","username":"Rugged","description":"Added a kuwahara filter to my black hole trave.\n\nClick and hold to see without filter.","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["ray","kuwahara","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 Kuwahara(vec2 uv, int radius){\n    \n    //float version of the radius\n    float r = float(radius);\n    \n    //array of the averages for each pixel region\n    vec3 avg[4];\n    avg[0] = vec3(0.);\n    avg[1] = vec3(0.);\n    avg[2] = vec3(0.);\n    avg[3] = vec3(0.);\n    \n    \n    \n    \n    //array of the standard deviaitons for each pixel region\n    vec3 std[4];\n    std[0] = vec3(0.);\n    std[1] = vec3(0.);\n    std[2] = vec3(0.);\n    std[3] = vec3(0.);\n    \n    \n    //the offsets for each reigon to sample over\n    vec2 offs[4];\n    offs[0] = vec2(-r);\n    offs[1] = vec2(-r, 0.);\n    offs[2] = vec2(0, -r);\n    offs[3] = vec2(0.);\n    \n    \n    //position and color holders\n    vec2 p;\n    vec3 col;\n    \n    //loop through each region\n    for(int i = 0; i < 4; i++){\n    \n        //for each x\n        for(int x = 0; x <= radius; x++){\n            \n            //for each y\n            for(int y = 0; y <=radius; y++){\n                \n                //the positon is each pixel within each region i\n                p = vec2(float(x), float(y)) + offs[i];\n                \n                //the uv position of the pixel to sample is the base uv plus the pixel offset\n                vec2 uvp = uv + (p / iResolution.xy);\n                \n                \n                //sample the texture at that position\n                col = texture(iChannel0, uvp).rgb;\n                \n                \n                //add in the color to the average color of the region\n                avg[i] += col;\n                \n                //add the standard deviation of this color from the region color\n                std[i] += col * col;\n                \n            }\n        }\n        \n    }\n    \n    \n    \n    //the total number of pixels that were sampled\n    float n = pow(r + 1., 2.);\n    \n    \n    \n    //holder for the lowest value\n    float minV = 1.;\n    \n    //holder for the standard deviation of the corresponding lowest value\n    float stdf;\n    \n    for(int i = 0; i < 4; i++){\n        \n        //make the average colors actually averaged (the are simply sums right now)\n        avg[i] /= n;\n        \n        //calculate standard deviation according to standard deviation formula\n        std[i] = abs((std[i] / n) - (avg[i] * avg[i]));\n        \n        //sum the standard deviation of each rgb value for this region\n        stdf = std[i].r + std[i].g + std[i].b;\n        \n        //if this region's standard deviation is the lowest then use it\n        if(stdf < minV){\n            \n            //record this standard deviation\n            minV = stdf;\n            \n            //select the value with the lowest standard deviation\n            col = avg[i];\n        }\n        \n    }\n    \n    \n    \n    return col;\n    \n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    vec3 col = Kuwahara(uv, 3);\n    \n    if(iMouse.z > 0.){\n        col = texture(iChannel0, uv).rgb;\n    }\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 prop = iResolution.xy / iResolution.x;\n    vec2 uvc = prop * (2. * (uv - 0.5));\n    \n    vec4 col = vec4(0.);\n    \n    \n    \n    float oneThird = 1. / 3.;\n    float root3 = sqrt(3.);\n    vec3 rayD = vec3(sqrt(1. - (oneThird * dot(uvc, uvc))), uvc.x / root3, uvc.y / root3);\n    \n    \n    float phi = .05 * iTime;\n    phi -= 2.;\n    float theta = .1 * iTime;\n    \n    \n    float camCL = -2. * (.2 * sin(iTime * .5) + 1.);\n    vec3 camC = camCL * vec3(1., 0., 0.);\n    \n    \n    rayD = rotate3D(rayD, phi, theta);\n    \n    camC = rotate3D(camC, phi, theta);\n    \n    \n    vec3 lightDir = normalize(vec3(1., 0., -1.));\n    vec3 p = camC;\n    \n    float l = 0.;\n    float l2 = 0.;\n    \n    float g = 0.008;\n    \n    float noiseFactor = 0.0;\n    \n    //for film grain\n    float blurStrength = 0.00055;\n    float blurPhi = 0.0;\n    float blurTheta = 0.0;\n    \n    for(int i = 0; i < 1000; i++){\n        \n        \n        l = length(p);\n        l2 = (l * l) + .0001;\n        \n        //add gravity to the ray direction\n        rayD -= (g * p / (l2)) * .2;\n        rayD = normalize(rayD);\n        \n        //this just turns the ray a tiny bit in a random direction causing a noisy blur effect\n        //(basically film grain)\n        // VERY EXPENSIVE due to rotate3D function in the ray loop\n        // so I have it off for now\n        /*\n        blurPhi = blurStrength * ((2. * hash3(p.xy)) - 1.);\n        blurTheta = blurStrength * ((2. * hash3(p.yz)) - 1.);\n        rayD = rotate3D(rayD, blurPhi, blurTheta);\n        */\n        \n        \n        \n        //variance in the ray stepping\n        noiseFactor = cloudNoise1(p.xy + (float(i) * .01), 200.);\n        \n        //step the ray point\n        p += rayD * (  .01  + (.0025 * (noiseFactor - .5))  );\n        \n        if(l < .1){\n            \n            //col -=  .01 / l2;\n            break;\n        }\n        \n        if(abs(p.z * (l / .1)) < 0.05){\n            \n            float rotAng = iTime + 1. / l;\n            \n            mat2 nrot;\n            nrot[0] = vec2(cos(rotAng), -sin(rotAng));\n            nrot[1] = vec2(sin(rotAng), cos(rotAng));\n            \n            col +=  .07 * texture(iChannel0, nrot * (p.xy * .1)).r *  vec4(1., .77, .53, 1.) / (l2*l + .12);\n            //cloudNoise1(nrot * p.xy , 70.)\n        }\n        \n    }\n    \n    \n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx,vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\nvec2 rotate(vec2 v, float theta){\n    mat2 rot;\n    rot[0] = vec2(cos(theta), -sin(theta));\n    rot[1] = vec2(sin(theta), cos(theta));\n    \n    \n    return rot * v;\n}\n\nvec3 rotate3D(vec3 v, float phi, float theta){\n    mat3 rot = mat3(\n        vec3( cos(phi)*cos(theta), -sin(phi), cos(phi)*sin(theta)),\n        vec3( sin(phi)*cos(theta), cos(phi), sin(phi)*sin(theta)),\n        vec3( -sin(theta), 0., cos(theta))\n    );\n    \n    \n    return rot * v;\n}\n\n\nfloat cloudNoise1(vec2 frag, float scale){\n    \n    frag *= scale;\n    \n    frag = floor(frag);\n    \n    frag += 1000.0f;\n    \n    vec2 frag2 = rotate(frag, frag.y);\n    vec2 frag3 = rotate(frag, frag.x);    \n    \n    \n    \n    return fract(frag2.y - frag3.x);// * frag2.y;\n}","name":"Common","description":"","type":"common"}]}