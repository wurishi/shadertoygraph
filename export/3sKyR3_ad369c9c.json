{"ver":"0.1","info":{"id":"3sKyR3","date":"1603388992","viewed":258,"name":"TriangleSphere","username":"MarvelousBilly","description":"Made a sphere out of an octohedron \nYou can move around with wasd + mouse","likes":3,"published":1,"flags":49,"usePreview":0,"tags":["triangle","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 res;\nfloat fov = 400.;\nmat3 rotmat(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n} //rotate a matrix\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdTriangleEdge(vec3 p,vec3 a, vec3 b, vec3 c){\n    float v =  sdCapsule(p,a,b,0.1);\n    v = min(v, sdCapsule(p,b,c,0.1));\n    v = min(v, sdCapsule(p,c,a,0.1));\n    return v;\n\n}\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdfSphere(vec3 p, vec3 c, float r){\n\treturn distance(p,c)-r;   \n}\n\nfloat map(vec3 p){\n    float minQ = 10000.;\n    float s = sdfSphere(p,vec3(0.),30.);\n    if (s < 0.0005){\n        for(int i = 0; i < totalTris; i++){\n            minQ = min(minQ, sdTriangleEdge(p, texelFetch(iChannel2, ivec2(i,0), 0).xyz, texelFetch(iChannel2, ivec2(i,1), 0).xyz, texelFetch(iChannel2, ivec2(i,2), 0).xyz));\n        }\n    }\n    else{\n     \treturn s;   \n    }\n    return minQ;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, float minD, float maxD){ //ray from camera to direction (extended into infinity)\n    rd = normalize(rd);\n    for(float i = 0.3; i < maxD;){ //i = length of ray\n        vec3 p = ro + i * rd;\n    \tfloat h = map(p); //smallest distance from all objects to point\n    \tif(h < minD){\n\t\t\treturn p; //successfully hit something at point \"point\"\n        }\n        i += h;\n    }\n    return ro;\n} //travel along a ray taking steps only as large as the map function above returns\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = (iResolution.xy / 3.) + vec2(3.,0.);\n    float pi = 3.141592;\n    vec2 Mouse = texelFetch(iChannel0, ivec2(res)+ivec2(2,0), 0).xy; //get the mouse position in pixels to the normalized value from 0 to 1\n    vec3 cam = vec3(0.,0.,-35.); //position of the camera\n    cam += vec3(texelFetch(iChannel0, ivec2(res), 0));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord-iResolution.xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv2 = fragCoord / iResolution.xy;\n    vec3 dir = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * vec3(uv.x,uv.y,fov) + cam; //rotate the direction you look\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    vec3 p = raymarch(cam, dir, 0.0005, 200.);\n    if(p != cam){\n\t\tcol = vec3(1.);\n    }\n    else{\n      col = texture(iChannel1, dir- cam).xyz; //skybox\n    }\n    fragColor = vec4(col,1.0);// + texelFetch(iChannel2, ivec2(fragCoord) / 4, 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define fov 400 //field of view \n#define key(ascii)   (texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.)\nbool vr = false;\nvec3 vrDir;\nvec2 res;\n\nvoid prevMouse(out vec4 fragColor) {//mouse position\n    vec4 v = vec4(iMouse.xy/iChannelResolution[0].xy,1.,0.); \n    fragColor = v; //update value stored (mouse position normalized)\n}\n\nvoid initVal(out vec4 fragColor){\n    vec4 val = vec4(0.5,0.5,0.,0.);\n    fragColor = val;\n}\n\nvoid deltaMouse(out vec4 fragColor) {//color stored\n    vec4 val = texelFetch(iChannel0, ivec2(res)+ivec2(2,0), 0);\n    //grab current delta mouse position\n    vec4 oldMouse = texelFetch(iChannel0, ivec2(res)+ivec2(1,0), 0);\n    //grab previous mouse position (last frame)\n    if(iMouse.z > 0.5 && val.w >= 0.5){ //if mouse was not pressed on prev frame, do not update delta\n        //this means it only changes when the mouse is down and does not warp colors.\n        vec2 deltaM = (iMouse.xy/iChannelResolution[0].xy)-oldMouse.xy;\n        //set delta to be the change in mouse positions between frames\n    \tval.xy+=deltaM;\n        //add the delta to val\n    }\n    if(val.x >= 1.){\n    \tval.x = 0.;   \n    }\n    if(val.y >= 1.){\n    \tval.y = 0.;   \n    }\n    val.w = iMouse.z; //update click state\n    fragColor = val;\n}\n\nmat3 rotmat(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n} //rotate a matrix\n\nvoid position(out vec4 fragColor){\n    vec4 val = texelFetch(iChannel0, ivec2(res), 0);\n    vec2 mid = res;\n    vec3 dir;\n    vec3 dirL;\n    if(!vr){\n        vec2 Mouse = texelFetch(iChannel0, ivec2(res)+ivec2(2,0), 0).xy;\n        vec2 uv = iChannelResolution[0].xy/2.-iChannelResolution[0].xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n        dir = normalize(rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * vec3(uv.x,uv.y,fov));\n        //need to fix this because I don't quite understand why this works \\/\n        //its just taking the direction and rotating it 90 degrees\n        vec2 MouseL = vec2((Mouse.x + 0.25),0.5); // Normalized pixel coordinates (from 0 to 1)\n        dirL = normalize(rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (MouseL.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (MouseL.y * 2.0 - 1.0)) * vec3(uv.x,uv.y,fov));\n    }\n    else{\n        //vec2 Mouse = texelFetch(iChannel0, ivec2(2,0), 0).xy;\n        //vec2 uv = iChannelResolution[0].xy/2.-iChannelResolution[0].xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n        dir = vrDir;\n    \t//need to fix this because I don't quite understand why this works \\/\n        //its just taking the direction and rotating it 90 degrees\n        //vec2 MouseL = vec2((Mouse.x + 0.25),0.5); // Normalized pixel coordinates (from 0 to 1)\n        dirL = dir;\n  \n        \n    }\n    float speed = 0.5;\n    if(key(16)){\n    \tspeed++; \n    }\n    if(key(87)){\n    \tval.xyz+=dir*speed;\n    }\n    if(key(83)){\n    \tval.xyz-=dir*speed;   \n    }\n    if(key(68)){\n    \tval.xyz+=dirL*speed;   \n    }\n    if(key(65)){\n    \tval.xyz-=dirL*speed;   \n    }\n\n \tfragColor = val; \n}\n\nvoid buffer(out vec4 fragColor, in vec2 fragCoord){\n    res = (iResolution.xy / 3.) + vec2(3.,0.);\n\n    if(iFrame == 0){\n        if(ivec2(fragCoord.xy) == ivec2(res)+ivec2(2, 0)){\n    \t\tinitVal(fragColor);\n        }\n    }\n    else{\n        if (ivec2(fragCoord.xy) == ivec2(res)) {\n            position(fragColor);\n        }\n        if (ivec2(fragCoord.xy) == ivec2(res)+ivec2(1, 0)) {\n            //if pixel that is being checked is 0,0\n            //update the stored value\n            prevMouse(fragColor);\n        }\n        if (ivec2(fragCoord.xy) == ivec2(res)+ivec2(2, 0)) {\n            //if pixel that is being checked is 0,0\n            //update the stored value\n            deltaMouse(fragColor);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    buffer(fragColor, fragCoord);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vrDir = fragRayDir;\n    buffer(fragColor, fragCoord);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"struct triangle{\n\tvec3 va;\n    vec3 vb;\n    vec3 vc;\n};\n//[(p1,p2,p3),]\ntriangle[totVert] Tris; //array with all triangle positions\nvec3[totVert] circles;  //array with all vertex positions\n\n//(x,y,z) < indexes that make up triangle\n\nvec3 triangles(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f, in vec2 fragCoord, in vec4 fragColor){\n\tfloat segLeng = distance(b,a)/float(n-1); //const\n    vec3 av = a;\n    vec3 bv = b;\n    vec3 cv = c;\n    vec3 dv = d;\n    vec3 ev = e;\n    vec3 fv = f;\n    \n    int C = 0; //current index of the circles array\n\tint K = 0;\n    for(int q = 1; q <= t; q++){\n        int T1 = 0;\n        int T2 = 0;\n        vec3[totVert] vertIndxUp;     //array with all vertex forming triangle indices\n        vec3[totVert] vertIndxDown;     //array with all vertex forming triangle indices\n\n        int CQ = 0;\n        if(q == 2 || q == 4 ||  q == 6 || q == 8){\n            cv = dv; \n        }\n        else if(q == 3 || q == 7){\n        \tbv = ev; \n            cv = c;\n        }\n        else if(q == 5){\n        \tav = fv;   \n            bv = b;\n            cv = c;\n        } //change which triangle to make\n        \n        vec3 translationAToB = normalize(bv-av) * segLeng; //direction each step goes from A to B\n        vec3 translationBToC = normalize(cv-bv) * segLeng; //direction each step goes from B to C\n\n        for(int i = 0; i < n; i++){ //the amount down\n            vec3 p = float(i)*translationAToB + av; //direction moved based on the distance down\n            circles[C] = p; //create vertex at point p, index C\n            C++;\n            CQ++;\n            for(int l = 1; l <= i; l++){ //this is horizontal steps\n                circles[C] = float(l)*translationBToC + p; //make another vertex\n                vertIndxUp[T1] = vec3(C, C-1, C-i-1); //make triangle from current vertex, previous vertex, and vertex above that makes the isometric triangle\n                T1++;\n                if(CQ+i+1 < vertPerFace){ //if going to go too low down where a vertex doesn't exist\n                    vertIndxDown[T2] = vec3(C, C-1, C+i+1); //make a triangle but pointed downwards\n                    T2++;\n                }\n                C++; //increase the vertex count now that you've finished with the triangles\n                CQ++;\n            }\n        }    \n        int v = 0;\n        for(int w = 0; w < trisPerFace - (((n-3)*(n-3))+1); w++){\n            Tris[w+K].va = circles[int(vertIndxUp[w].x)];\n            Tris[w+K].vb = circles[int(vertIndxUp[w].y)];\n            Tris[w+K].vc = circles[int(vertIndxUp[w].z)];\n            v = w;\n        }\n        for(int w = 0; v < trisPerFace; w++){\n            Tris[v+K].va = circles[int(vertIndxDown[w].x)];\n            Tris[v+K].vb = circles[int(vertIndxDown[w].y)];\n            Tris[v+K].vc = circles[int(vertIndxDown[w].z)];\n            v++;\n        }\n        K += trisPerFace;\n\n    }\n\n    if(sphereify){\n        for(int i = 0; i < totVert; i++){\n            Tris[i].va = 30.*normalize(Tris[i].va);\n            Tris[i].vb = 30.*normalize(Tris[i].vb);\n            Tris[i].vc = 30.*normalize(Tris[i].vc);\n        }\n    }\n    int y = int(fragCoord.y);\n    int x = int(fragCoord.x);\n    if(y == 0){\n    \treturn Tris[x].va;\n    }\n    if(y == 1){\n    \treturn Tris[x].vb;\n    }\n    if(y == 2){\n    \treturn Tris[x].vc;\n    }\n    if(y == 3){\n    \treturn circles[x];\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    if (int(fragCoord.x) <= totalTris && int(fragCoord.y) <= 6) {\n        if(iFrame == 0){\n            fragColor = vec4(triangles(30.*vec3(0.0, 1.0, 0.0), \n                                       30.*vec3(1.0, 0.0, 0.0), \n                                       30.*vec3(0.0, 0.0, 1.0), \n                                       30.*vec3(0.0, 0.0, -1.0),\n                                       30.*vec3(-1.0, 0.0, 0.0),\n                                       30.*vec3(0.0, -1.0, 0.0),\n                                       fragCoord, fragColor),0.);\n        }\n        else{\n            fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xyz,0.);\n        }\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"bool sphereify = true; //normilize all vertices\nconst int n = 4; //amount of vertices per edge\nconst int t = 8;\n\n\nconst int vertPerFace = (n*(n+1))/2 + 1;\nconst int trisPerFace = (n-1) * (n-1);\nconst int totVert     = t*vertPerFace;\nconst int totalTris   = t*trisPerFace;\n","name":"Common","description":"","type":"common"}]}