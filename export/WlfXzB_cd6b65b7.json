{"ver":"0.1","info":{"id":"WlfXzB","date":"1563318821","viewed":569,"name":"Rainbow Water","username":"96logda","description":"One of my first versions of my water shader from glslsandbox converted to shadertoy.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["water","sky","rainbow","rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright (c) 2019-07-02 - 2019-07-23 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//My orginal version: http://glslsandbox.com/e#55788.0\n\n//Latest version of my water with sky shader:\n//Copyright (c) 2019-06-23 - 2019-07-17 by Angelo Logahd\n//http://glslsandbox.com/e#56195.1\n\nconst float PI\t \t= 3.1415;\nfloat EPSILON_NRM\t= 0.001;\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n#define true  \t\t\t\t\t\t\t1\n#define false \t\t\t\t\t\t\t0\n\n#define saturate(x)\t\t\t\t\t\tclamp(x, 0.0, 1.0)\n#define mul3x(x) \t\t\t\t\t\tx * x * x\n\n#define SIMULATE \t\t\t\t\t\t0\n#define SIMULATE2x\t\t\t\t\t\t1\n#define SIMULATE3x\t\t\t\t\t\t2\n#define SIMULATE4x\t\t\t\t\t\t3\n#define SIMULATE5x\t\t\t\t\t\t4\n#define PAUSED\t\t\t\t\t\t\t5\n#define SLOW_MOTION\t\t\t\t\t\t6\n\n#define WAVES_WATER\t\t\t\t\t\t0\n#define CALM_WATER\t\t\t\t\t\t1\n\n#define SIMULATE_MODE\t\t\t\t\tSIMULATE\n#define WATER_TYPE\t\t\t\t\t\tCALM_WATER\n#define RAINBOW_WATER\t\t\t\t\ttrue\n#define FANTASY_WATER_PATH\t\t\t\tfalse\n#define FLIP_WATER_AND_SKY\t\t\t\tfalse\n#define DAY_AND_NIGHT\t\t\t\t\tfalse\n#define SUN_LIGHT\t\t\t\t\t\ttrue\n#define HDR\t\t\t\t\t\t\t\ttrue\n\n//...........................................................\n//\t\t\tWeathers\n//...........................................................\n#define\tRAIN\t\t\t\t\t\t\ttrue\n#define RAINBOW\t\t\t\t\t\t\ttrue\n\n#if RAINBOW\n#define RAINBOW_START_Y\t\t\t\t\t0.0\n\nconst float RAINBOW_BRIGHTNESS  \t\t= 1.0;\nconst float RAINBOW_INTENSITY   \t\t= 0.30;\nconst vec3  RAINBOW_COLOR_RANGE \t\t= vec3(50.0, 53.0, 56.0);  // The angle for red, green and blue\nvec3 RAINBOW_POS\t\t\t\t\t\t= vec3(4.5, 0.0, 0.5);\nvec3 RAINBOW_DIR \t\t\t\t\t\t= vec3(-0.2, -0.1, 0.0);\n\t\nvec3 rainbow_pos;\nvec3 rainbow_camera_dir;\nvec3 rainbow_up; \nvec3 rainbow_vertical;\nvec3 rainbow_w;\n#endif\n//...........................................................\n\n//...........................................................\n//\t\t\tPost Processing\n//...........................................................\n#define APPLY_LUMINANCE\t\t\t\t\ttrue\n#if HDR\n#define APPLY_TONEMAP\t\t\t\t\ttrue\n#endif\n#define APPLY_GAMMA_CORRECTION\t\t\ttrue\n\nconst float INTENSITY\t\t\t\t\t= 1.5;\nconst float CONTRAST\t\t\t\t\t= 1.0;\n\n#if APPLY_GAMMA_CORRECTION\nconst float GAMMA\t\t\t\t\t\t= 2.2;\n#endif\n\n#if HDR\n#if APPLY_TONEMAP\n\n#define LINEAR_TONEMAP\t\t\t\t\t0\n#define EXPONENTIAL_TONEMAP\t\t\t\t1\n#define REINHARD_TONEMAP\t\t\t\t2\n#define REINHARD2_TONEMAP\t\t\t\t3\n#define FILMIC_HEJL2015\t\t\t\t\t4\n#define FILMIC_TONEMAP_UNCHARTED2\t\t5\n#define FILMIC_TONEMAP_ACES\t\t\t\t6\n\n//Note: If you use FILMIC_HEJL2015 Tonemap then you should use 2.4 as gamma.\n#define TONEMAP_TYPE\t\t\t\t\tFILMIC_TONEMAP_UNCHARTED2\t\t\n \n#if TONEMAP_TYPE == LINEAR_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == EXPONENTIAL_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == REINHARD_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == REINHARD2_TONEMAP\nconst float LDR_WHITE\t\t\t\t\t= 1.2;\nconst float TONEMAP_EXPOSURE\t\t\t= 0.25;\n#endif\n#if TONEMAP_TYPE == FILMIC_HEJL2015\nconst float TONEMAP_WHITE_POINT\t\t\t= 1.0;\nconst float TONEMAP_EXPOSURE\t\t\t= 0.25;\nconst float TONEMAP_EXPOSURE_BIAS \t\t= 0.85;\n#endif\n#if TONEMAP_TYPE == FILMIC_TONEMAP_UNCHARTED2\n//https://www.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting\n//http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\n//Uncharted2Tonemap:\n//Orginal Values:\n//A = 0.22\n//B = 0.30\n//C = 0.10\n//D = 0.20\n//E = 0.02\n//F = 0.30\n//W = 11.2\n\nconst float A = 0.22;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\nconst float W = 11.2;\n\nconst float TONEMAP_EXPOSURE\t\t\t= 1.0;\nconst float TONEMAP_EXPOSURE_BIAS \t\t= 2.0;\n#endif\n#if TONEMAP_TYPE == FILMIC_TONEMAP_ACES\n\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nconst float W = 11.2;\n\t\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\nconst float TONEMAP_EXPOSURE_BIAS \t\t= 1.0;\n#endif\n#endif\n\n#endif\n//...........................................................\n\n//Day and night properties\n#if DAY_AND_NIGHT\n#define DAY_AND_NIGHT_TIME\t\t\t\t0.1\n#define DAY_AND_NIGHT_MIN_BRIGHTNESS\t0.2\n#define DAY_AND_NIGHT_MAX_BRIGHTNESS\t1.0\n#endif\n\n//Sun light properties\n#if SUN_LIGHT\nvec3  SEA_SUN_DIRECTION\t\t        \t= vec3(0.0, -1.0, -0.5);\nvec3  SEA_SUN_COLOR     \t\t\t\t= vec3(1.0, 1.0, 1.0);    //vec3(1.0, 1.0, 0.0) to use a yellow reflection color\nfloat SEA_SUN_DIFFUSE  \t\t\t\t\t= 0.65; \nvec3  SEA_SUN_SPECULAR      \t\t\t= vec3(0.65);\n#endif\n\n//Geometry / Fragment properties\nconst int SEA_GEOMETRY_ITERATIONS   \t= 8;\nconst int SEA_FRAGMENT_ITERATIONS   \t= 10;\n\n// sea base properties\nconst vec3  SEA_BASE_COLOR \t\t\t\t= vec3(0.15, 0.19, 0.25);\nconst vec3  SEA_WATER_COLOR \t\t\t= vec3(0.1, 0.1, 0.15);\nconst vec3  SEA_ORI\t\t\t\t\t\t= vec3(0.0, 3.5, 0.0);\t\t\nconst float SEA_HEIGHT    \t\t\t\t= 0.9;\nconst float SEA_SPEED     \t\t\t\t= 1.6;\nconst float SEA_FREQ      \t\t\t\t= 0.15;\nconst float SEA_GEOMETRY_FREQ_MUL\t\t= 1.9;\nconst float SEA_GEOMETRY_AMPLITUDE_MUL \t= 0.22;\nconst float SEA_FREQ_MUL  \t\t\t\t= 2.3;\nconst float SEA_AMPLITUDE_MUL \t\t\t= 0.22;\nconst float SEA_REFRACTION_MUL_VALUE\t= 0.12;\nconst float SEA_ATTENUATION             = 0.001;\nconst float SEA_ATTENUATION_MUL_FACTOR  = 0.18;\nconst float SEA_CHOPPY    \t\t\t\t= 5.2;\nconst float SEA_CHOPPY_MIX_VALUE\t\t= 1.0;\nconst float SEA_CHOPPY_MIX_FACTOR\t\t= 0.4;\n\n// sea heightmap\nconst int HEIGHTMAP_NUM_STEPS     \t\t= 20;\n\n// sea direction\nconst float SEA_DIR_Z_SCALE \t\t\t= 0.02;\n\n//.................................................\n// \t\tsea PBR properties\n//.................................................\nconst float SEA_SPECULAR_FACTOR\t\t\t= 60.0;\nconst float FRESNEL_POW_FACTOR\t\t\t= 3.0;\nconst float FRESNEL_MUL_FACTOR\t\t\t= 0.65;\nconst float DIFFUSE_POW_FACTOR\t\t\t= 80.0;\n//.................................................\n\nconst float SEA_PAUSED_SPEED\t\t\t= 0.0;\nconst float SEA_SLOWMOTION_SPEED        = 0.5;\n\n#if RAINBOW_WATER\nconst float RAINBOW_WATER_SATURATION\t= 0.35;\nconst float RAINBOW_WATER_LIGHTNESS\t\t= 0.1;\nconst float RAINBOW_WATER_SPEED \t\t= 0.1;\n#endif\n\n#if FANTASY_WATER_PATH\nconst float UV_START_X\t\t\t\t\t= -5.0;\nconst float UV_END_X\t\t\t\t\t=  5.0;\n#endif\n\nmat2 octave_matrix \t\t\t\t\t\t= mat2(1.6, 1.2, -1.2, 1.6);\n\nfloat SEA_CURRENT_TIME\t\t\t\t\t= 0.0;\n\n//Color mixing\nconst float SMOOTH_MIX_Y\t\t\t\t= -1.2; \nconst float MIX_SEA_AND_SKY_FACTOR\t\t= 0.11;\nconst vec3  COLOR_GRADING\t\t\t\t= vec3(0.0, 0.0, 0.01);\n\n//..................................................................\n//\t\t\t\tFog\n//..................................................................\n#define ALWAYS_FOG\t\t\t0\n#define NEVER_FOG\t\t\t1\n\n#define FOG_MODE\t\t\t\tNEVER_FOG\nconst vec3  FOG_COLOR  \t\t\t= vec3(0.15, 0.15, 0.15);\nconst float FOG_START \t\t\t= 0.04;\nconst float FOG_END \t\t\t= 500.0;\nconst float FOG_DENSITY \t\t= 0.2;\n//..................................................................\n\n\nvec3 hsv(float hue, float saturation, float value)\n{\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(hue) + t.xyz) * 6.0 - vec3(t.w));\n    return value * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), saturation);\n}\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat hash(vec2 p)\n{\t\n    return rand(dot(p, vec2(12.9898, 78.233)));\n}\n\nvec2 _smoothstep(in vec2 p)\n{\n    vec2 f = fract(p);\n    return f * f * (3.0 - 2.0 * f);\n}\n\nvec3 _smoothstep(in vec3 p)\n{\n     return p * p * 3.0 - 2.0 * mul3x(p);\n}\n\nfloat noise(in vec2 p) \n{\n    vec2 i = floor(p);\t\n    vec2 sp = _smoothstep(p);\n    return -1.0 + 2.0 * mix(mix(hash(i + vec2(0.0, 0.0)), \n                                hash(i + vec2(1.0, 0.0)), sp.x),\n                            mix(hash(i + vec2(0.0, 1.0)), \n                                hash(i + vec2(1.0, 1.0)), sp.x), sp.y);\n}\n\nvec3 sky(vec3 e) \n{\n    e.y = max(e.y, 0.0);\n    vec3 ret;\n    ret.x = pow(1.0 - e.y, 2.0) * 2.5;\n    ret.y = 1.0 - e.y;\n    ret.z = 0.8;\n    return ret;\n}\n\nfloat sea_octave(vec2 uv, float choppy) \n{\t\n    #if WATER_TYPE == WAVES_WATER \n    uv += noise(uv);\n    vec2 wv = 1.0 - abs(sin(uv));   \n    wv = mix(wv, abs(cos(uv)), wv);\n    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n    #elif WATER_TYPE == CALM_WATER\n    //Author: Angelo Logahd \n    //2019-06-29\n    float noise = noise(uv);\n    float x = cos(noise);\n    float y = sin(noise);\n    return pow(pow(abs(x * y), 0.65), choppy);\n    #endif\n}\n\nfloat sea_geometry_map(vec3 p) \n{\n    #if WATER_TYPE == WAVES_WATER\n    vec2 uv = p.xz * vec2(0.85, 1.0);\n\t\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    \n    float d = 0.0;\n    float h = 0.0;    \n    for (int i = 0; i < SEA_GEOMETRY_ITERATIONS; ++i) \n    {   \n\t\t#if FANTASY_WATER_PATH\n\t   \tif (uv.x > UV_START_X && uv.x < UV_END_X)\n        {\n\t\t\tcontinue;\n        }\n\t\t#endif\n\n    \td =  sea_octave((uv + SEA_CURRENT_TIME) * freq, choppy);\n    \td += sea_octave((uv - SEA_CURRENT_TIME) * freq, choppy);\n        h += d * amp; \n\t    \n\t\tfreq *= SEA_GEOMETRY_FREQ_MUL; \n\t\tamp  *= SEA_GEOMETRY_AMPLITUDE_MUL;\n\t    \n        choppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);\n\t    \n\t\tuv *= octave_matrix; \n    }\n    return p.y - h;\n    #else\n    return p.y;\n    #endif\n}\n\nfloat sea_fragment_map(vec3 p) \n{\n    vec2 uv = p.xz * vec2(0.85, 1.0); \n    \n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;  \n    float choppy = SEA_CHOPPY;\n\t\n    float d = 0.0;\n    float h = 0.0;    \n    for(int i = 0; i < SEA_FRAGMENT_ITERATIONS; ++i) \n    {\t    \n    \td =  sea_octave((uv + SEA_CURRENT_TIME) * freq, choppy);\n\t\td += sea_octave((uv - SEA_CURRENT_TIME) * freq, choppy); \n\t\th += d * amp;\n\t\n\t\tfreq *= SEA_FREQ_MUL; \n\t\tamp  *= SEA_AMPLITUDE_MUL;\n\t\n\t\tchoppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);\n\t\n\t\tuv *= octave_matrix;\n    }\n    return p.y - h;\n}\n\nfloat diffuse(vec3 normal, vec3 light, float powFactor) \n{\n    return pow(dot(normal, light) * 0.4 + 0.6, powFactor);\n}\n\nvec3 normal(vec3 p, vec3 dist) \n{\n    float eps = dot(dist, dist) * EPSILON_NRM;\n    vec3 n;\n    n.y = sea_fragment_map(p); \n    n = vec3(sea_fragment_map(vec3(p.x + eps, p.y, p.z)) - n.y,\n\t     sea_fragment_map(vec3(p.x, p.y, p.z + eps)) - n.y,\n\t     eps);\n    return normalize(n);\n}\n\nfloat specular(vec3 eye, vec3 normal, vec3 light) \n{    \n    float nrm = (SEA_SPECULAR_FACTOR + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(eye, normal), light), 0.0), SEA_SPECULAR_FACTOR) * nrm;\n}\n\nfloat fresnel(vec3 normal, vec3 eye) \n{  \n    float fresnel = 1.0 - max(dot(normal, -eye), 0.0);\n    fresnel = pow(fresnel, FRESNEL_POW_FACTOR) * FRESNEL_MUL_FACTOR;\n    return fresnel;\n}\n\nvec3 sea(vec3 p, vec3 l, vec3 eye) \n{  \n    vec3 dist = p - SEA_ORI;  \n    vec3 normal = normal(p, dist);\n    float diffuse = diffuse(normal, l, DIFFUSE_POW_FACTOR);\n    float fresnel = fresnel(normal, eye);\n\t\n    vec3 reflected = sky(reflect(eye, normal));    \n    vec3 refracted = SEA_BASE_COLOR + diffuse * SEA_WATER_COLOR * SEA_REFRACTION_MUL_VALUE; \n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    \n    float atten = max(0.0, 1.0 - dot(dist, dist) * SEA_ATTENUATION) * SEA_ATTENUATION_MUL_FACTOR;\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * atten;\n    \n    color += vec3(specular(normal, l, eye));\n    \n    #if SUN_LIGHT\n    vec3 sunDiffuseColor = max(dot(SEA_SUN_DIRECTION, normal), 0.0) * SEA_SUN_COLOR * SEA_SUN_DIFFUSE;\n    vec3 reflection = normalize(reflect(-SEA_SUN_DIRECTION, normal));\n    float direction = max(0.0, dot(eye, reflection));\n    vec3 sunSpecular = direction * SEA_SUN_COLOR * SEA_SUN_SPECULAR;\n    color = color + sunDiffuseColor + sunSpecular;\n    #endif\n\t\n    #if RAINBOW_WATER\n    color += hsv((p.z * 0.3) - iTime * RAINBOW_WATER_SPEED, RAINBOW_WATER_SATURATION, RAINBOW_WATER_LIGHTNESS);\n    #endif\n\n    return color;\n}\n\nvec3 seaHeightMap(vec3 dir) \n{\n    vec3 p = vec3(0.0);\n    float x = 1000.0;\n\t\n    if (sea_geometry_map(SEA_ORI + dir * x) > 0.0)\n    {\n\t\treturn p;\n    }\n    \n    float mid = 0.0;\n    float m = 0.0; \n    float heightMiddle = 0.0;\n    for(int i = 0; i < HEIGHTMAP_NUM_STEPS; ++i) \n    {\n        mid = mix(m, x, 0.5); \n        p = SEA_ORI + dir * mid;                   \n    \theightMiddle = sea_geometry_map(p);\n\t\tif (heightMiddle < 0.0) \n\t\t{\n            x = mid;\n        } \n\t\telse \n\t\t{\n        \tm = mid;\n        }\n    }\n\t\n    return p;\n}\n\nvec3 fog(vec3 sceneColor, float dist)\n{\n    vec3 fragRGB = sceneColor;\n    const float FogEnd   = FOG_END;\n    const float FogStart = FOG_START;\n    float distanceF = (FogEnd - dist) / (FogEnd - FogStart);\n    float fogAmount = saturate(1.0 - exp(-distanceF * FOG_DENSITY));\n    return mix(fragRGB, FOG_COLOR, fogAmount);\n}\n\nfloat rainHash(float p)\n{\n    vec2 p2 = fract(vec2(p) * vec2(0.16632, 0.17369));\n    p2 += dot(p2.xy, p2.yx + 19.19);\n    return fract(p2.x * p2.y);\n}\n\nfloat rainNoise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = _smoothstep(x);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(rainHash(n +  0.0), rainHash(n +  1.0), f.x),\n               mix(rainHash(n + 57.0), rainHash(n + 58.0), f.x), f.y);\n}\n\nfloat rain(vec2 uv, vec2 xy)\n{\t\n    float travelTime = (iTime * 0.7) + 0.1;\n\t\n    float x1 = (0.5 + xy.x + 1.0) * 0.3;\n    float y1 = 0.01;\n    float x2 = travelTime * 0.5 + xy.x * 0.2;\n    float y2 = travelTime * 0.2;\n\t\n    vec2 st = uv * vec2(x1, y1) + vec2(x2, y2);\n    \n    float rain = 0.1;  \n    float f = rainNoise(st * 200.5) * rainNoise(st * 125.5);  \n    f = clamp(pow(abs(f), 20.0) * 1.5 * (rain * rain * 125.0), 0.0, 0.1);\n    return f;\n}\n\nvec3 rainbowColor(in vec3 ray_dir) \n{ \n    RAINBOW_DIR = normalize(RAINBOW_DIR);   \n\t\t\n    float theta = degrees(acos(dot(RAINBOW_DIR, ray_dir)));\n    vec3 nd = clamp(1.0 - abs((RAINBOW_COLOR_RANGE - theta) * 0.2), 0.0, 1.0);\n    vec3 color = _smoothstep(nd) * RAINBOW_INTENSITY;\n    \n    return color * max((RAINBOW_BRIGHTNESS - 0.75) * 1.5, 0.0);\n}\n\nvoid rainbowSetup()\n{\n    rainbow_pos =  RAINBOW_POS;\n    rainbow_w   = -normalize(-rainbow_pos);\n    rainbow_up  =  normalize(cross(rainbow_w, up));\n    rainbow_vertical = normalize(cross(rainbow_up, rainbow_w));\n}\n\nvec3 rainbow(vec2 fragCoord)\n{\n     vec2 uv = fragCoord.xy / iResolution.xy;\n     vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x / iResolution.y, 1.0);\n\n     vec3 color = vec3(0.0);\n     if (p.y >= RAINBOW_START_Y)\n     {\n\t\t vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    \t rainbowSetup();\n\n     \t vec3 dir = normalize(vec3(p, 0.0) - vec3(0.0, 0.0, -1.5));\n     \t vec3 wdDir = normalize(dir.x * rainbow_up + dir.y * rainbow_vertical - dir.z * rainbow_w);\n\t     \n         color += rainbowColor(wdDir);\n     }\t\n     return clamp(color, 0.0, 1.0);  \n}\n\n#if HDR\n#if TONEMAP_TYPE == FILMIC_TONEMAP_UNCHARTED2\nvec3 Uncharted2Tonemap(vec3 x)\n{\n   return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n#elif TONEMAP_TYPE == FILMIC_TONEMAP_ACES\nvec3 TonemapACESFilm(vec3 x)\n{\n    return saturate((x * (A * x + B)) / (x * (C * x + D) + E));\n}\n#elif TONEMAP_TYPE == FILMIC_HEJL2015\n// https://twitter.com/jimhejl/status/633777619998130176\nvec3 ToneMapFilmic_Hejl2015(vec3 hdr) \n{\n    vec4 vh = vec4(hdr, TONEMAP_WHITE_POINT);\n    vec4 va = 1.425 * vh + 0.05;\n    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;\n    return vf.rgb / vf.www;\n}\n#endif\n\n#define LINEAR_TO_SRGB_ALPHA \t  \t\t0.055\n#define LINEAR_TO_SRG_LOWER_MUL_FACTOR\t12.92\n#define LINEAR_TO_SRGB_CONDITION  \t\t0.0031308\n// https://en.wikipedia.org/wiki/SRGB\nvec3 linearTo_sRGB(vec3 linearColor) \n{\n    vec3 sRGB_Higher = (1.0 + LINEAR_TO_SRGB_ALPHA) * pow(linearColor, vec3(1.0 / GAMMA)) - vec3(LINEAR_TO_SRGB_ALPHA);\n    return vec3(linearColor.r > LINEAR_TO_SRGB_CONDITION ? sRGB_Higher.r : LINEAR_TO_SRG_LOWER_MUL_FACTOR * linearColor.r,\n        \tlinearColor.g > LINEAR_TO_SRGB_CONDITION ? sRGB_Higher.g : LINEAR_TO_SRG_LOWER_MUL_FACTOR * linearColor.g,\n        \tlinearColor.b > LINEAR_TO_SRGB_CONDITION ? sRGB_Higher.b : LINEAR_TO_SRG_LOWER_MUL_FACTOR * linearColor.b);\n}\n\nvec3 Tonemap(vec3 color)\n{\n    #if TONEMAP_TYPE == LINEAR_TONEMAP\n    color *= vec3(TONEMAP_EXPOSURE);\n    #endif\n    #if TONEMAP_TYPE == EXPONENTIAL_TONEMAP\n    color = 1.0 - exp2(-color * TONEMAP_EXPOSURE);\n    #endif\n    #if TONEMAP_TYPE == REINHARD_TONEMAP\n    color *= TONEMAP_EXPOSURE;\n    color = color / (1.0 + color);\n    #endif\n    #if TONEMAP_TYPE == REINHARD2_TONEMAP\n    color *= TONEMAP_EXPOSURE;\n    color = (color * (1.0 + color / (LDR_WHITE * LDR_WHITE))) / (1.0 + color);\n    #endif\n    #if TONEMAP_TYPE == FILMIC_HEJL2015\n    color *= TONEMAP_EXPOSURE;\n    color = linearTo_sRGB(ToneMapFilmic_Hejl2015(TONEMAP_EXPOSURE_BIAS * color));\n    #endif\n    #if TONEMAP_TYPE == FILMIC_TONEMAP_UNCHARTED2    \n    color *= TONEMAP_EXPOSURE;\n    vec3 tonemapedColor = Uncharted2Tonemap(TONEMAP_EXPOSURE_BIAS * color);\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\n    color = tonemapedColor * whiteScale;\n    #endif\n    #if TONEMAP_TYPE == FILMIC_TONEMAP_ACES\n    color *= TONEMAP_EXPOSURE;\n    vec3 tonemapedColor = TonemapACESFilm(TONEMAP_EXPOSURE_BIAS * color);\n    vec3 whiteScale = 1.0 / TonemapACESFilm(vec3(W));\n    color = tonemapedColor * whiteScale;\n    #endif\n   \n    return color;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\t\n    float intensity = INTENSITY;\n    #if DAY_AND_NIGHT\n    intensity *= clamp(sin(iTime * DAY_AND_NIGHT_TIME) + DAY_AND_NIGHT_MIN_BRIGHTNESS, \n\t\t\t    \t   DAY_AND_NIGHT_MIN_BRIGHTNESS, \n\t\t\t    \t   DAY_AND_NIGHT_MAX_BRIGHTNESS);\n    #endif\n\t\n    EPSILON_NRM = 0.5 / iResolution.x;\n\t\n    #if SIMULATE_MODE == SIMULATE\n\tSEA_CURRENT_TIME = 0.4 * iTime * SEA_SPEED;\n    #elif SIMULATE_MODE == SIMULATE2x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 2.0;\n    #elif SIMULATE_MODE == SIMULATE3x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 3.0;\n    #elif SIMULATE_MODE == SIMULATE4x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 4.0;\n    #elif SIMULATE_MODE == SIMULATE5x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 4.0;\n    #elif SIMULATE_MODE == PAUSED\n\tSEA_CURRENT_TIME = 0.0;\n    #elif SIMULATE_MODE == SLOW_MOTION\n\tSEA_CURRENT_TIME = iTime * SEA_SLOWMOTION_SPEED;\n    #endif\n \n    #if FLIP_WATER_AND_SKY\n    vec3 dir = normalize(vec3(-uv.xy, -1.0));\n    #else\n    vec3 dir = normalize(vec3(uv.xy, -1.0));\n    #endif\n    dir.z += length(uv) * SEA_DIR_Z_SCALE;\n    dir = normalize(dir);\n \n    vec3 p = seaHeightMap(dir);\n    vec3 dirLight = normalize(vec3(0.0, 1.0, 0.0)); \n    \n    float smothMixFactor = pow(smoothstep(0.0, SMOOTH_MIX_Y, dir.y), MIX_SEA_AND_SKY_FACTOR);\n    \n    vec3 sky = sky(dir);\n    vec3 sea = sea(p, dirLight, dir);\n     \n    vec3 color = mix(sky, sea, smothMixFactor);\n\t\n    #if APPLY_LUMINANCE\n    float luminance = dot(color, vec3(0.3, 0.59, 0.11));\n    luminance = saturate(luminance);\n    vec3 resLuminance = vec3(length(color.r * luminance), \n\t\t\t     \t\t     length(color.g * luminance), \n\t\t\t     \t\t\t length(color.b * luminance));\n\n    color.rgb = resLuminance;\n    #endif\n\t\n    color = color * CONTRAST + 0.5 - CONTRAST * 0.5;\n\t\n    #if FOG_MODE != NEVER_FOG\n    color = fog(color, dir.z);\n    #endif\n    \n    #if RAIN\n    vec3 rainColor = vec3(1.0, 1.0, 1.0) * 1.5;\n    float rainFactor = rain(uv, xy);\n    color = mix(color, rainColor, rainFactor);\n    #endif\n    \n    color = color * intensity + COLOR_GRADING;\n\t\n    #if RAINBOW\n    color += rainbow(fragCoord);\n    #endif\n\t\n    #if HDR && APPLY_TONEMAP\n    color = Tonemap(color);\n    #endif\n\t\n    #if APPLY_GAMMA_CORRECTION\n    color = pow(color, vec3(1.0 / GAMMA));\n    #endif\n\t\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}