{"ver":"0.1","info":{"id":"sty3Dz","date":"1637488685","viewed":174,"name":"Clockwork Mandelbrot","username":"soudfv","description":"Using ending complex phase instead of number of iterations. Next thing to try is using phase and iterations with log correction to transform some image.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","palette","phase"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\n#define PALETTE   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30)\n//#define PALETTE   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)\n//#define PALETTE   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20)\n\n#define REPEAT 2.\n\n#define TYPE_PALETTE 0\n#define TYPE_TEXTURE 1\n#define TYPE_CLOCK 2\n\n#define TYPE TYPE_CLOCK\n//#define TYPE TYPE_PALETTE\n\n#define AA 1\n\n// iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palClock( in float phi0 )\n{\n    float t = fract(phi0 + floor(iTime * 0.1 * 60.) * (1./60.));\n    float t1 = fract(phi0 + floor(iTime * 0.1 * (1./60.) * 60.) * (1./60.));\n    return vec3(1.-(smoothstep(0.3, 0.305, t)-smoothstep(0.32, 0.325, t))\n        -(smoothstep(0.3, 0.305, t1)-smoothstep(0.34, 0.345, t1)));\n}\n\nvec3 mc(vec2 uv)\n{\n    vec2 z = vec2(0.);\n    int i0 = 0;\n    \n    for (int i = 0; i < 60; ++i)\n    {\n        vec3 z2 = z.xyx * z.xyy;\n        z = vec2(z2.x - z2.y, 2. * z2.z) + uv;\n        float l2 = dot(z,z);\n        if (l2 > 4.) {\n            i0 = i;\n            break;\n        }\n    }\n    \n    float phi0 = ((atan(z.y,z.x) + 2.*PI) / (2.*PI));\n #if TYPE != TYPE_CLOCK\n    phi0 += iTime * 0.5;\n #endif\n    float phi = fract(phi0);\n        \n    \n #if TYPE == TYPE_CLOCK\n    vec3 col = palClock(phi0) * (1. - float(i0) / 60.);\n #elif TYPE == TYPE_TEXTURE\n    vec3 col = texture(iChannel0, vec2(float(i0)/60.,phi)).xyz;\n #else\n    vec3 col = pal(fract(phi*REPEAT), PALETTE) * (1.-float(i0) / 60.);\n #endif\n     return col;\n}\n\nvoid\n#if AA == 2\n    mainImage0\n#else\n    mainImage\n#endif\n( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= vec2(1.25, 0.5);\n    uv *= 2.;\n\n    vec3 col;\n    vec3 col00 = mc(uv);\n #if AA\n    vec2 duv = vec2(dFdx(col00.x), dFdy(col00.x));\n    vec2 subpixel = 1./iResolution.yy;\n    vec3 col11 = mc(uv + subpixel * /*normalize*/(duv));\n    col = (col00 + col11) * 0.5;\n #else\n    col = col00;\n #endif\n\n    fragColor = vec4(col,1.0);\n}\n\n#if AA == 2\n    void mainImage(out vec4 O, vec2 U) {\n        mainImage0(O,U);\n        if ( fwidth(length(O)) > .1 ) {  // difference threshold between neighbor pixels\n            vec4 o;\n            for (int k=0; k < 9; k++) if (k != 4) {\n                mainImage0(o,U+vec2(mod(float(k),3.)-1.,k/3-1)/3.);\n                O += o;\n            }\n            O /= 9.;\n          //O.r++;                        // uncomment to see where the oversampling occurs\n        }\n    }\n#endif\n","name":"Image","description":"","type":"image"}]}