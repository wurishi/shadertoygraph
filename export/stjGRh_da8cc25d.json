{"ver":"0.1","info":{"id":"stjGRh","date":"1623921866","viewed":134,"name":"2D rational quadratic Bezier","username":"kajbostrom","description":"Distance to a rational (a.k.a. weighted / conic / trigonometric) quadratic Bezier curve. These curves can perfectly fit circular arcs/conic sections, unlike standard quadratic Beziers, but analytic distance requires solving a quartic.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["bezier","distance","curve","quadratic","primitive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float THIRD = 1.0/3.0;\nconst float NINTH = 1.0/9.0;\nconst float FIFTYFOURTH = 1.0/54.0;\nconst float HALFROOTTHREE = 0.5*sqrt(3.0);\n#define EPS 0.00001\n#define M_2PI 6.283185307179586\n\nvec2 ratQuadBezier(float t, vec2 p0, vec2 p1, vec2 p2, vec3 w) {\n    float mt = 1.0 - t;\n    vec3 wt = w*vec3(mt*mt, 2.0*t*mt, t*t);\n    return (wt.x*p0 + wt.y*p1 + wt.z*p2) / (wt.x + wt.y + wt.z);\n}\n\n// Quartic +cubic solution methods ported from https://github.com/sasamil/Quartic\n\n//---------------------------------------------------------------------------\n// solve cubic equation x^3 + a*x^2 + b*x + c\n// x - array of size 3\n// In case 3 real roots: => x[0], x[1], x[2], return 3\n//         2 real roots: x[0], x[1],          return 2\n//         1 real root : x[0], x[1] ± i*x[2], return 1\nint solveP3(out vec3 x, float a, float b, float c) {\n\tfloat a2 = a*a;\n    \tfloat q  = (a2 - 3.0*b)*NINTH;\n\tfloat r  = (a*(2.0*a2-9.0*b) + 27.0*c)*FIFTYFOURTH;\n    float r2 = r*r;\n\tfloat q3 = q*q*q;\n\tfloat A; float B;\n    if(r2<q3)\n    {\n        float t = clamp(r/sqrt(q3), -1.0, 1.0);\n        t=acos(t);\n        a *= THIRD; q=-2.0*sqrt(q);\n        x.x = q*cos(t*THIRD)-a;\n        x.y = q*cos((t+M_2PI)*THIRD)-a;\n        x.z = q*cos((t-M_2PI)*THIRD)-a;\n        return 3;\n    }\n    else\n    {\n        A =-pow(abs(r)+sqrt(r2-q3),THIRD);\n        if( r<0.0 ) A=-A;\n        B = (A ==0.0 ? 0.0 : q/A);\n\n        a *= THIRD;\n        x.x = (A+B)-a;\n        x.y = -0.5*(A+B)-a;\n        x.z = HALFROOTTHREE*(A-B);\n        if(abs(x.z) < EPS) { x.z = x.y; return 2; }\n\n        return 1;\n    }\n}\n\nfloat udRatQuadBezier(vec2 x, vec2 p0, vec2 p1, vec2 p2, vec3 w)\n{\n\n    // Calculate parameters of general quartic qa*t^4 + qb*t^3 + qc*t^2 + qd*t + qe\n    // solutions to which are zeroes of the derivative of distance between x and the curve of interest\n    \n    float p0dotp0 = dot(p0, p0);\n    float p0dotp1 = dot(p0, p1);\n    float p0dotp2 = dot(p0, p2);\n    float p1dotp1 = dot(p1, p1);\n    float p1dotp2 = dot(p1, p2);\n    float p2dotp2 = dot(p2, p2);\n    float p0dotx = dot(p0, x);\n    float p1dotx = dot(p1, x);\n    float p2dotx = dot(p2, x);\n    float g0 = w.x*w.x;\n    float g1 = w.z*w.z;\n    float g2 = w.x*w.z;\n    float g3 = p0dotx*g2;\n    float g4 = p2dotx*g2;\n    float g5 = w.y*w.y;\n    float g6 = 2.0*g5;\n    float g7 = g6*(p0dotp1 - p0dotx + p1dotx - p1dotp1);\n    float g8 = w.z*g0*(p2dotx - p0dotp2 + p0dotp0 - p0dotx);\n    float g9 = w.y*g0*(p0dotp1 + p0dotx - p0dotp0 - p1dotx);\n    float g10 = w.x*g1*(p2dotx - p0dotx - p2dotp2 + p0dotp2) + w.z*g6*(p1dotp1 + p2dotx - p1dotp2 - p1dotx);\n    float g11 = g2*(p0dotp0 - p0dotp2);\n    float g12 = g3 - g4 - g7 - g11;\n    float qa = w.y*(3.0*(g2*(p1dotp2 - p0dotp1) + g3 - g4) + g1*(p1dotx - p1dotp2 + p2dotp2 - p2dotx)) + w.x*g7 + g8 + g9 + g10;\n    float qb = 6.0*(w.y*(g2*(p0dotp1 - p1dotp2) - g3 + g4) + g5*w.x*(p0dotx - p0dotp1 + p1dotp1 - p1dotx)) - 3.0*g8 - 4.0*g9 - g10;\n    float qc = 3.0*w.x*(w.y*w.z*(p0dotx - p0dotp1 + p1dotp2 - p2dotx) + 2.0*w.y*w.x*(p0dotx + p0dotp1 - p0dotp0 - p1dotx) - g12);\n    float qd = w.x*(4.0*w.y*w.x*(p0dotp0 - p0dotx + p1dotx - p0dotp1) + g12);\n    float qe = g9;\n    \n\tvec3 x3;\n\n    float r;\n    vec2 dx;\n    float minDistSq = -1.0;\n    \n    if (abs(qa) < 0.0001) {\n        // Reduction to cubic\n        float invQb = 1.0/qb;\n        int iZeroes = solveP3(x3, qc*invQb, qd*invQb, qe*invQb);\n        r = clamp(x3[0], 0.0, 1.0);\n        dx = x - ratQuadBezier(r, p0, p1, p2, w);\n        minDistSq = dot(dx, dx);\n        if (iZeroes >= 2) {\n            r = clamp(x3[1], 0.0, 1.0);\n            dx = x - ratQuadBezier(r, p0, p1, p2, w);\n            minDistSq = min(minDistSq, dot(dx, dx));\n        }\n        return sqrt(minDistSq);\n    }\n    float invQa = 1.0/qa;\n\n    float a = invQa*qb;\n    float b = invQa*qc;\n    float c = invQa*qd;\n    float d = invQa*qe;\n    \n    // Solve quartic equation x^4 + a*x^3 + b*x^2 + c*x + d\n\tfloat a3 = -b;\n\tfloat b3 =  a*c -4.0*d;\n\tfloat c3 = -a*a*d - c*c + 4.0*b*d;\n\n\t// cubic resolvent\n\t// y^3 − b*y^2 + (ac−4d)*y − a^2*d−c^2+4*b*d = 0\n\n\tint iZeroes = solveP3(x3, a3, b3, c3);\n\n\tfloat q1, q2, pa, pb, D, sqD, y;\n\n\ty = x3[0];\n\tif(iZeroes >= 2) {\n        if (abs(x3[1]) > abs(y)) y = x3[1];\n    }\n\n\t// h1+h2 = y && h1*h2 = d  <=>  h^2 -y*h + d = 0    (h === q)\n\n\tD = y*y - 4.0*d;\n\tif(abs(D) < EPS) { //in other words - D==0\n\t\tq1 = q2 = y * 0.5;\n\t\t// g1+g2 = a && g1+g2 = b-y   <=>   g^2 - a*g + b-y = 0    (p === g)\n\t\tD = a*a - 4.0*(b-y);\n\t\tif(abs(D) < EPS) { //in other words - D==0\n\t\t\tpa = pb = a * 0.5;\n        } else {\n\t\t\tsqD = sqrt(D);\n\t\t\tpa = (a + sqD) * 0.5;\n\t\t\tpb = (a - sqD) * 0.5;\n\t\t}\n\t} else {\n\t\tsqD = sqrt(D);\n\t\tq1 = (y + sqD) * 0.5;\n\t\tq2 = (y - sqD) * 0.5;\n\t\t// g1+g2 = a && g1*h2 + g2*h1 = c       ( && g === p )  Krammer\n\t\tpa = (a*q1-c)/(q1-q2);\n\t\tpb = (c-a*q2)/(q1-q2);\n\t}\n\n\t// solving quadratic eq. - x^2 + p1*x + q1 = 0\n\tD = pa*pa - 4.0*q1;\n\tif(D > 0.0) {\n\t\tsqD = sqrt(D);\n\t\tr = (-pa + sqD) * 0.5;\n        r = clamp(r, 0.0, 1.0);\n        // CALC MIN DIST\n        dx = x - ratQuadBezier(r, p0, p1, p2, w);\n        minDistSq = dot(dx, dx);\n\t\tr = (-pa - sqD) * 0.5;\n        r = clamp(r, 0.0, 1.0);\n        // CHECK MIN DIST\n        dx = x - ratQuadBezier(r, p0, p1, p2, w);\n        minDistSq = min(dot(dx, dx), minDistSq);\n\t}\n\n\t// solving quadratic eq. - x^2 + p2*x + q2 = 0\n\tD = pb*pb - 4.0*q2;\n\tif(D > 0.0) {\n\t\tsqD = sqrt(D);\n\t\tr = (-pb + sqD) * 0.5;\n        r = clamp(r, 0.0, 1.0);\n        // CHECK MIN DIST\n        dx = x - ratQuadBezier(r, p0, p1, p2, w);\n        minDistSq = minDistSq == -1.0 ? dot(dx, dx) : min(dot(dx, dx), minDistSq);\n\t\tr = (-pb - sqD) * 0.5;\n        r = clamp(r, 0.0, 1.0);\n        // CHECK MIN DIST\n        dx = x - ratQuadBezier(r, p0, p1, p2, w);\n        minDistSq = min(dot(dx, dx), minDistSq);\n\t}\n\n    return sqrt(minDistSq);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 v0 = vec2(0, -0.5);\n    vec2 v1 = vec2(cos(iTime), 0);\n    vec2 v2 = vec2(0, 0.5);\n    \n\tfloat d = udRatQuadBezier(\n        p, v0, v1, v2,\n        vec3(1.0, cos(iTime*0.5) + 1.25, 1.0)\n    );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n    \n    \n    if( cos(0.5*iTime)<-0.5 )\n    {\n        d = min( udSegment(p,v0,v1),\n                 udSegment(p,v1,v2) );\n        d = min( d, length(p-v0)-0.02 );\n        d = min( d, length(p-v1)-0.02 );\n        d = min( d, length(p-v2)-0.02 );\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\n    }\n\n\tfragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}