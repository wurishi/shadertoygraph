{"ver":"0.1","info":{"id":"cdVyRd","date":"1696524139","viewed":174,"name":"soundwaves inferno","username":"Carandiru","description":"soundwave propagation","likes":4,"published":3,"flags":8,"usePreview":0,"tags":["sound","wave","propogation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// https://www.shadertoy.com/view/WlfXRN\nvec3 inferno(float t) {\n\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// viridis palette function port //             \n#define fma(a,b,c) (a*b+c)\n\nvec3 viridis(float t) \n{\n\tconst vec3 _c0 = vec3( 0.2777273272234177, 0.005407344544966578, 0.3340998053353061 );\n\tconst vec3 _c1 = vec3( 0.1050930431085774, 1.404613529898575, 1.384590162594685 );\n\tconst vec3 _c2 = vec3( -0.3308618287255563, 0.214847559468213, 0.09509516302823659 );\n\tconst vec3 _c3 = vec3( -4.634230498983486, -5.799100973351585, -19.33244095627987 );\n\tconst vec3 _c4 = vec3( 6.228269936347081, 14.17993336680509, 56.69055260068105 );\n\tconst vec3 _c5 = vec3( 4.776384997670288, -13.74514537774601, -65.35303263337234 );  \n    const vec3 _c6 = vec3( -5.435455855934631, 4.645852612178535, 26.3124352495832 );  \n\n\tvec3 xmT = vec3(t);\n    \n    vec3 x;\n\n    // c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))))\n    x = fma(xmT, _c6, _c5);\n    x = fma(x, xmT, _c4);\n    x = fma(x, xmT, _c3);\n    x = fma(x, xmT, _c2);\n    x = fma(x, xmT, _c1);\n    x = fma(x, xmT, _c0);\n\n    return(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0f * fragCoord.xy / R.xy - 1.0f;\n    uv *= iResolution.y/R.x;\n   \n    // Set your frequency here (in Hz)  22kHz to 85kHz\n    float freq_high = 85e3f; \n    float freq_low = 22e3f; \n    \n    float max_dist = length(R) * 0.618034f;\n    const float wave_count = 4.0f; // -1\n    const float wave_slices = 25.0f;\n    const float wave_speeds = 4.0f; // to capture (subsampling)\n    \n    float wave_accumulator = 0.0f;\n    \n    vec3 bn = textureLod(iChannel0, (fragCoord + vec2(0, float(iFrame))) / 1024.0f, 0.0f).rgb;\n    \n    for (float waves = 0.0f; waves < wave_count; ++waves) {\n    \n        float freq = mix(freq_low, freq_high, waves / wave_count);\n        float depth = (freq - freq_low) / (freq_high - freq_low);\n        \n        float t = 1.0f;\n        \n        for (float slice = 0.0f; slice < wave_slices; ++slice) {\n        \n            vec3 offset = vec3(0.0f, (sin(7e4f/freq) * slice)/R.y * max_dist * depth/R.y, 0.0f);\n            offset = offset * 16.18034f * (smoothstep(0.0f, 1.0f, sin(iTime/pi2) * 0.5f + 0.5f) * 2.0f - 1.0f);\n            offset = offset + bn * offset * 0.01111111111f;\n            \n            float dist = distance(vec3(vec2(uv.x, uv.y), depth), offset - vec3(0, 0.1f, 0));\n\n            // Simulate the wave propagation\n            float wave_rt = sin(max_dist * dist - iTime * freq * 10.0f); // real-time\n            float wave_1k = sin(max_dist * dist - iTime * freq * 0.01f);  // time / 1000\n            float wave_10k = sin(max_dist * dist - iTime * freq * 0.001f);  // time / 10000\n            float wave_100k = sin(max_dist * dist - iTime * freq * 0.0001f);  // time / 100000\n            float wave_1000k = sin(max_dist * dist - iTime * freq * 0.00001f);  // time / 1000000\n\n            // auto - scaling\n            float wave = wave_rt;\n            wave = mix(wave, wave_1k, freq > 1e2f);\n            wave = mix(wave, wave_10k, freq > 1e3f);\n            wave = mix(wave, wave_100k, freq > 1e4f);\n            wave = mix(wave, wave_1000k, freq > 1e5f);\n\n            wave = wave * 0.5f + 0.5f;\n\n            float wave_shade = 0.0f;\n\n            for (float speeds = 1.0f; speeds <= wave_speeds; ++speeds) {\n\n                float capture_speed = speeds / wave_speeds;\n\n                float ndist = dist * max_dist/(max_dist * capture_speed);\n\n                float attenuation = clamp(1.0f / (0.0000001f + ndist*ndist), 0.0f, 2.0f);\n\n                float speed = 1.0f - exp(-freq/wave_speeds * abs(ndist - dist)/max_dist);\n\n                float shaded_wave = wave*depth*attenuation;\n\n                wave_shade += shaded_wave * mix(capture_speed, capture_speed*capture_speed, speed);\n            }\n\n            float dt = exp(-0.7e-2f * wave_shade * dist);\n            wave_accumulator = wave_accumulator * t + mix(pow(wave_shade, 5.0f), wave_shade, 1.0f - t) * (slice)/(wave_slices - 1.0f);\n            t *= dt;\n        }\n    }\n\n    fragColor = vec4(inferno(min(1.0f, wave_accumulator/(wave_count*wave_slices))), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nfloat wave(vec2 uv, vec2 p, float o, float f, float t)\n{\n    float d = distance(uv, p);\n    float w = sin(((d - t) * f - o) * pi2) / (1.0 + 256.0 * d * d);\n    return w;\n}\n\nfloat getWave(vec2 uv, float t)\n{\n    float w = 0.0;\n    // Higher frequency = Further travel (Until it glitches out and everything explodes, don't try at home)\n    for (float i = 0.0; i <= 0.25; i += 0.002)\n        w += wave(uv, vec2(0, i * 2.0 - 0.25), 0.0, 64.0, t) * 0.15;\n    \n    return w;\n}\n\n#define WIDTH 8.0\n#define AMP 8.0\n#define SAMPLE_WEIGHT (AMP/WIDTH)\n\nvec2 sampling(in sampler2D bnsampler, in vec2 t)\n{\n    t = t + 50.0f;\n    \n    float current = t.x*t.x;\n    \n    float weight = SAMPLE_WEIGHT;\n    \n    float a = getWave(vec2(0.5f * cos(t.x), fract(t.x)), current) * weight;\n    \n    float b = getWave(vec2(0.5f * sin(t.y), 1.0f - fract(t.y)), current) * weight;\n    \n    vec2 bn = textureLod(bnsampler, vec2(a, b), 0.0f).rr;\n    bn = bn * 0.5f + 0.5f;\n    \n    for ( float i = WIDTH - 1.0f ; i >= 0.0f ; --i )\n    {\n        a += getWave(vec2(0.5f * cos(t.x), fract(t.x)), current) * weight;\n        b += getWave(vec2(0.5f * sin(t.y), 1.0f - fract(t.y)), current) * weight;\n        \n        float tmp = a;\n        a = b;\n        b = tmp;\n        \n        t = t * 0.618034f;\n        current = current / 1.618034f;\n        weight = clamp(weight * 1.618034f, 0.0f, 1.0f);\n    }\n    \n    return(0.15f*vec2(a*0.1f+b*bn.x*0.1f,b*0.1f+a*bn.y*0.1f));\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 c = sampling(iChannel0, vec2(time));\n    \n    return c;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n\nconst float pi2 = 6.28318530718;\nconst float pi = pi2*0.5f;","name":"Common","description":"","type":"common"}]}