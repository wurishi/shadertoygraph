{"ver":"0.1","info":{"id":"M3lBD2","date":"1728949105","viewed":72,"name":"spooder","username":"veeluminati","description":"that THANG","likes":0,"published":3,"flags":4,"usePreview":0,"tags":["spooder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple hash function\nfloat hash(float n) { return fract(sin(n) * 43758.5453); }\n\n// Smooth noise function\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = dot(i, vec3(1.0, 57.0, 113.0));\n\n    return mix(mix(mix(hash(n + dot(vec3(0.0, 0.0, 0.0), i)),\n                       hash(n + dot(vec3(1.0, 0.0, 0.0), i)), f.x),\n                   mix(hash(n + dot(vec3(0.0, 1.0, 0.0), i)),\n                       hash(n + dot(vec3(1.0, 1.0, 0.0), i)), f.x), f.y),\n               mix(mix(hash(n + dot(vec3(0.0, 0.0, 1.0), i)),\n                       hash(n + dot(vec3(1.0, 0.0, 1.0), i)), f.x),\n                   mix(hash(n + dot(vec3(0.0, 1.0, 1.0), i)),\n                       hash(n + dot(vec3(1.0, 1.0, 1.0), i)), f.x), f.y), f.z);\n}\n\n// Fractal Brownian Motion (FBM) function for evolving patterns\nfloat fbm(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 6; i++) {\n        value += amplitude * noise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n\n    return value;\n}\n\n// Function to map mic input directly to rainbow colors, but with a darker, more muted palette\nvec3 rainbow(float t) {\n    float r = abs(sin(t * 6.2831 + 0.0)) * 0.5;  // Darkened red\n    float g = abs(sin(t * 6.2831 + 2.0944)) * 0.4;  // Darkened green\n    float b = abs(sin(t * 6.2831 + 4.1888)) * 0.6;  // Darkened blue\n    return vec3(r, g, b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Microphone input from iChannel0, using the red channel\n    float micInput = texture(iChannel0, vec2(0.0, 0.5)).r;\n\n    // Time-based distortions\n    float time = iTime * 0.5 + micInput * 10.0;  // React more intensely to sound\n\n    // Circular pattern with continuous distortion based on time\n    vec2 center = vec2(0.0);\n    float radius = length(uv - center);\n    float angle = atan(uv.y, uv.x) + time * 3.0;  // Rotate faster with mic input\n\n    // FBM-based distortion for psychedelic effect\n    vec3 pos = vec3(radius * 2.0, angle, time);\n    float pattern = fbm(pos);\n\n    // Sound-reactive ripple effect based on mic input\n    float ripple = sin(radius * 10.0 - time * 3.0) * (0.3 + micInput * 0.6);  // Increase ripple size based on sound\n\n    // Combine ripple and pattern for the final visual\n    float finalPattern = pattern + ripple;\n\n    // Map micInput directly to rainbow colors for fast-reacting shifts\n    vec3 color = rainbow(micInput * 10.0 + finalPattern * 2.0);  // Noise controls rainbow shifts\n\n    // Reduce overall brightness to prevent blinding\n    color *= 0.8;  // Darken all colors by 20%\n\n    // Amplify color changes based on mic input, but keep them muted\n    color += micInput * 0.3;  // Brightness reacts to amplitude, but at a reduced scale\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}