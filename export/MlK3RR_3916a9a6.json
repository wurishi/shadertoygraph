{"ver":"0.1","info":{"id":"MlK3RR","date":"1476805957","viewed":197,"name":"First Raymarching attempt","username":"TheRomanOne","description":"First raymarching experiment.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Added specular light, shadows and lightSource visualization.\n//Special thanks to jackdavenport!\n\n\n#define MAX_DIST 100.0\n#define PI 3.141592654\n#define EULER 2.718281828\n#define EPSILON 0.001\n#define SHADOW 0.01\n\nstruct SphereData\n{\n    float len;\n    vec3 center;\n    float size;\n    vec3 color;\n    float specular;\n    float dumper;\n};\n    \nSphereData sphere(vec3 center, vec3 ray, float size, vec3 color, float spec, float dump)\n{\n    SphereData sp;\n    \n    sp.len = length(ray - center) - size;\n    sp.color = color;\n    sp.center = center;\n    sp.size = size;\n    sp.specular = spec;\n    sp.dumper = dump;\n    \n    return sp;\n}\n\nSphereData map(vec3 ray)\n{\n    vec3 p1 = vec3(-5.*sin(iTime/4.), 5.*cos(iTime/4.), 0.);\n    vec3 p2 = vec3(4.5*sin(iTime/2. + PI), 0, 4.5*cos(iTime/2. + PI));\n    vec3 p3 = vec3(.125 * cos(iTime*3.), .125 * sin(iTime*1.5), .125 * cos(iTime*3.));\n    \n    SphereData[3] spheres;\n    spheres[0] = sphere(p1, ray, 1., vec3(0., 0., .5), 20., 1.5);\n    spheres[1] = sphere(p2, ray, .5, vec3(.5, 0., 0.), -1., 8.);\n    spheres[2] = sphere(p3, ray, 2.5, vec3(0., .5, 0.), 15., 2.5);\n    \n    SphereData temp = spheres[0];\n    \n    for(int index = 0; index < 3; index++)\n        if(spheres[index].len < temp.len)\n            temp = spheres[index];   \n        \n    return temp;\n}\n\nvec3 getNormal(vec3 ray)\n{\n\tvec3 grad = vec3\n    (\n      map(ray + vec3(EPSILON, 0, 0)).len - map(ray - vec3(EPSILON, 0, 0)).len,\n      map(ray + vec3(0, EPSILON, 0)).len - map(ray - vec3(0, EPSILON, 0)).len,\n      map(ray + vec3(0, 0, EPSILON)).len - map(ray - vec3(0, 0, EPSILON)).len\n    );\n    \n    return normalize(grad);\n}\n\nfloat trace(vec3 origin, vec3 dir)\n{\n \tfloat dist = 0.;\n    for(int i = 0;i<128;i++)\n        if(dist < MAX_DIST)\n        {\n        \tvec3 ray = origin + dir * dist;\n        \tdist += map(ray).len;\n        }else return -1.;\n            \n    return dist;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n        \n    vec3 ray = normalize(vec3(uv, 1.));\n    vec3 origin = vec3(0./*5.*sin(iTime/3.)*/,0., -6.);\n    vec3 camDir = normalize(-origin);\n    \n    //vec3 light = vec3(20.*sin(iTime/3.), 0., -20.*cos(iTime/3.));\n    vec3 light = vec3(20.*sin(iTime/5.), 50. * cos(iTime * 2.) * sin(iTime/3.), 20.*cos(iTime/5.));\n    vec3 lightDir = normalize(light);\n    vec3 lightColor = vec3(0.69, 0.0015, .7);\n    \n    ray = (viewMatrix(ray, vec3(0.), vec3(.0, 1.0, 0.0)) * vec4(ray, 0.)).xyz;\n\n    float dist = trace(origin, ray);\n    vec3 color = vec3(0.);\n    if(dist > 0.)\n    {\n        vec3 position = origin + ray * dist;\n        SphereData sp = map(position);\n        vec3 baseColor = sp.color;\n\n        vec3 normal = getNormal(position);\n         \n        float diffuse = max(SHADOW, dot(normal, lightDir));\n        float specular = 0.;\n        if(sp.specular > 0. )\n            specular = pow(max(0., dot(normalize(reflect(ray, normal)), lightDir)), sp.specular)/(sp.dumper);\n        \n        \n        if(trace(position + lightDir * 0.1, lightDir) > 0.)\n        {\n            specular = 0.;\n            diffuse = SHADOW;\n        }\n        \n        float shineBack = 0.;//pow(max(0., dot(lightDir, ray)), 60.);\n        \n        color = baseColor * diffuse + (shineBack*0.1 + specular) * sqrt(lightColor);\n        \n    } else\n    {\n     \tfloat shine = pow(max(0., dot(lightDir, ray)), 20.);\n        float shineBack = pow(max(0., dot(lightDir, camDir)), 2.2);\n        color = (shineBack + shine) * lightColor;\n    }\n    \n    fragColor = vec4(sqrt(color), 1.);\n}","name":"Image","description":"","type":"image"}]}