{"ver":"0.1","info":{"id":"cd23DD","date":"1667629902","viewed":117,"name":"Ray Marching v3 - azavier","username":"azavier","description":"i like re-writing things.\n\nto be fair, i went from ~15 fps with AA : 2 to ~25 fps with AA : 4. Big performance","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SKY_COLOR(dir) vec3(0, 0.4, 1)\n#define FLOOR_COLOR vec3(0, 0.4, 0.3)\n#define FAR_PLANE 100.\n\n#define HIT_DISTANCE 0.004\n\n#define AMBIENT_PERCENT vec3(0.01)\n\n#define AMBIENT 1.\n#define DIFFUSE 1.\n#define SPECULAR 10.\n#define EMISSIVE 1.\n\n#define SPECULAR_FALLOFF 40.\n\n#define REFLECTIONS 4\n\n#define SHADOWS 1\n\n#define SHADOW_MAX_DARKNESS 0.2\n#define SHADOW_PENUMBRA 22.5\n#define SHADOW_MAX_STEPS 32\n#define SHADOW_MAX_DISTANCE 14.\n\nstruct Material {\n  float roughness;\n  float metallic;\n  float specular;\n  \n  vec3 albedo;\n  vec3 emissive;\n};\n// the very first material in this list is the default material\nMaterial[] Materials = Material[](\n  Material( // 0:Matte white\n    1.,  // roughness\n    0.,  // metallicity\n    1.,  // specular highlight\n    vec3(0), // albedo\n    vec3(0.05)  // emissive lighting\n  ),\n  Material( // 1:Mirror\n    0.,\n    2.,\n    5.,\n    vec3(0.65),\n    vec3(0)\n  ),\n  Material( // 2:The sun thing\n    1.,\n    0.,\n    0.,\n    vec3(0.9, 1, 0),\n    vec3(1)\n  ),\n  Material( // 3:the ground\n    1.,\n    0.,\n    1.,\n    vec3(0), // we will be updating the albedo when we render. No need to specify a color.\n    vec3(0.05)\n  ),\n  Material( // 4:normal ball\n    1.,\n    1.,\n    1.,\n    vec3(0),\n    vec3(0.5)\n  )\n);\nMaterial GetMaterial(in float matID) {\n  return Materials[int(matID)];\n}\nvoid UpdateMaterialAlbedo(in int matID, in vec3 albedo) {\n  Materials[int(matID)].albedo = albedo;\n}\n\nfloat SignedSphereDistance(in vec3 point, in vec4 sphere) {\n  return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat SMin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(b - a)/k, 0., 1.);\n  return mix(b, a, h) - k*h*(1. - h);\n}\nvoid MatMin(inout float[2] data, in float distance, in float matID) {\n  if(distance < data[0]) {\n    data[0] = distance;\n    data[1] = matID;\n  }\n}\nvoid MatSMin(inout float[2] data, in float distance, in float matID, float k) {\n  if(distance < data[0]) {\n    data[0] = SMin(data[0], distance, k);\n    data[1] = matID;\n  }\n}\nvoid MatMax(inout float[2] data, in float distance, in float matID) {\n  if(distance > data[0]) {\n    data[0] = distance;\n    data[1] = matID;\n  }\n}\nvec3[] lightPositions = vec3[] (\n  vec3(5, 6.5, 5)*8.\n);\nvec4[] lightColors = vec4[] (\n  vec4(0.9, 1, 0, 100)\n);\nfloat recipLights = 1./float(lightPositions.length() + 1);\n// 0: closest distance to any object in the scene\n// 1: material index of said object\nfloat[2] SceneField(in vec3 point) {\n  float[2] data;\n  data[0] = FAR_PLANE;\n  \n  vec4[] spheres = vec4[]( // x,y,z, r\n    // the mirror ball\n    vec4(0,1,0, 1), \n    // the normal ball\n    vec4(-2,2,-2, 1.25),\n    // the sun\n    vec4(vec3(5, 5, 5)*15., 20)\n  );\n  \n  // Mirror ball thing\n  float sphereDistance = SignedSphereDistance(point, spheres[0]);\n  MatMin(data, sphereDistance, 1.);\n  \n  // Normal ball\n  sphereDistance = SignedSphereDistance(point, spheres[1]);\n  vec3 normalColor = vec3(0.5*sin(point.y) + 0.5);\n  UpdateMaterialAlbedo(4, normalColor);\n  MatMin(data, sphereDistance, 4.);\n  \n  // the sun\n  sphereDistance = SignedSphereDistance(point, spheres[2]);\n  MatMin(data, sphereDistance, 2.);\n  \n  \n  vec2 ground = vec2(\n    point.y, // Distance\n    3 // matID\n  );\n  vec3 groundColor = \n   FLOOR_COLOR*(0.5+0.5*ceil(\n    clamp(vec3(\n     sin(2.*point.x) + \n     sin(2.*point.z)), \n    0., 1.))\n   );\n  UpdateMaterialAlbedo(3, groundColor);\n  MatMin(data, ground.x, ground.y);\n  \n  return data;\n}\n\nvoid MarchScene(inout float[2] hit, in vec3 rayOrigin, in vec3 rayDirection) {\n  float[2] data;\n  for(hit[0] = 0.; hit[0] <= FAR_PLANE;) {\n    data = SceneField(rayOrigin + rayDirection*hit[0]);\n    \n    if(data[0] < HIT_DISTANCE)\n      break;\n      \n    hit[0] += data[0];\n  }\n  if(hit[0] > FAR_PLANE) {\n    hit[0] = -1.;\n  } else\n    hit[1] = data[1];\n}\n\nvec3 SurfaceNormal(in vec3 point) {\n  vec2 delta = vec2(0.0001, 0);\n  vec3 gradient = vec3(\n    SceneField(point - delta.xyy)[0],\n    SceneField(point - delta.yxy)[0],\n    SceneField(point - delta.yyx)[0]\n  );\n  return normalize(SceneField(point)[0] - gradient);\n}\n\nvec3 GlobalIllumination(in float[2] hit, in vec3 rayOrigin, in vec3 rayDirection) {\n  Material mat = GetMaterial(hit[1]);\n  vec3 point = rayOrigin + rayDirection*hit[0];\n  vec3 normal = SurfaceNormal(point);\n  \n  float shadow = 1.;\n  vec3 ambient = AMBIENT_PERCENT, diffuse, specular;\n  for(int i = 0; i < lightPositions.length(); i++) {\n    vec3 lightVector = lightPositions[i] - point;\n    float lightDistance = length(lightVector);\n    lightVector = normalize(lightVector);\n    \n    float attenuation = 1./lightDistance;\n    \n    ambient += lightColors[i].rgb*attenuation*1.;\n   \n    diffuse += mat.albedo*lightColors[i].rgb*dot(normal, lightVector)*lightColors[i].w*attenuation*1.;\n   \n    vec3 halfway = normalize(normalize(rayOrigin - point) + lightVector);\n    float halfwayComparedWithNormal = clamp(dot(normal, halfway), 0., 1.);\n    float specularIntensity = pow(halfwayComparedWithNormal, mat.metallic*SPECULAR_FALLOFF);\n    specular += lightColors[i].rgb*specularIntensity*mat.specular*attenuation*1.;\n   #if SHADOWS == 1\n    float rayDistance;\n    float[2] data;\n    float tmpShadow = 1.;\n    for(int step = 0; step < SHADOW_MAX_STEPS && rayDistance < SHADOW_MAX_DISTANCE; step++) {\n      data = SceneField(point + normal*HIT_DISTANCE*2. + lightVector*rayDistance);\n    \n      if(data[0] < 0.)\n        break;\n    \n      tmpShadow = min(tmpShadow, smoothstep(-6., 6., SHADOW_PENUMBRA*data[0]/rayDistance));\n      rayDistance += data[0];\n    }\n    shadow += min(max(tmpShadow, SHADOW_MAX_DARKNESS), 1.);\n   #endif\n  }\n  ambient *= mat.albedo;\n  \n  specular *= mat.albedo;\n  specular = clamp(specular, 0., 1.);\n  \n  if(SHADOWS == 1)\n    shadow *= recipLights;\n  \n  vec3 global = ambient*AMBIENT + diffuse*DIFFUSE + specular*SPECULAR + mat.emissive*EMISSIVE;\n  \n  return global*shadow;\n}\n\nfloat Hash21(in vec2 hash) {\n  vec2 p = fract(hash*vec2(25.124, 85.124));\n  p += dot(p, p + 234.124);\n  return fract(p.x * p.y);\n}\n\nvec3 randomVec3(in vec3 point) {\n  vec3 ret;\n  ret.x = Hash21(vec2(point.x * point.y, point.z * point.y));\n  ret.y = Hash21(vec2(point.x * point.z, point.y * point.x));\n  ret.z = Hash21(vec2(point.y * point.z, point.z * point.y));\n  return normalize(ret);\n}\n\nvec3 SurfaceReflection(inout float[2] hit, in vec3 rayOrigin, inout vec3 rayDirection) {\n  vec3 reflectionOrigin = rayOrigin + rayDirection*hit[0];\n  Material mat = GetMaterial(hit[1]);\n  vec3 normal = SurfaceNormal(reflectionOrigin);\n  \n  rayDirection = reflect(rayDirection, normal + mat.roughness*randomVec3(reflectionOrigin)*0.1);\n  MarchScene(hit, reflectionOrigin + normal*HIT_DISTANCE, rayDirection);\n  if(hit[0] < 0.)\n    return SKY_COLOR(rayDirection);\n  mat.albedo *= GetMaterial(hit[1]).albedo;\n  \n  return GlobalIllumination(hit, reflectionOrigin, rayDirection);\n}\n\n// https://www.shadertoy.com/view/tlKSzK\nvec3 LookAt(in vec2 uv, in vec3 rayOrigin, in vec3 lookPoint){\n  \n  vec3 toVec = normalize(lookPoint - rayOrigin),\n       r = normalize(cross(toVec, vec3(0, 1, 0))),\n       upVector = cross(r, toVec),\n       c = rayOrigin + toVec,\n       i = c - r*uv.x + upVector*uv.y;\n    \n  return normalize(i-rayOrigin);\n}\n\nvec3 PixelColor(vec2 uv) {\n  vec3 cameraPosition = vec3(0, 2, 0);\n  vec3 cameraFocus = vec3(0, 1, 0);\n  cameraPosition.xz += 5.*vec2(sin(iTime), cos(iTime));\n  vec3 pixelColor;\n   \n  float[2] hit;\n  \n  vec3 rayDirection = LookAt(uv, cameraPosition, cameraFocus);\n  MarchScene(hit, cameraPosition, rayDirection);\n  \n  if(hit[0] > 0.) {\n    pixelColor = GlobalIllumination(hit, cameraPosition, rayDirection);\n    \n    int lightBounces;\n    for(lightBounces; hit[0] > 0. && GetMaterial(hit[1]).roughness < 1. && lightBounces < REFLECTIONS; lightBounces++)\n      pixelColor += SurfaceReflection(hit, cameraPosition, rayDirection);\n      \n    if(lightBounces > 0)\n      pixelColor /= float(lightBounces);\n  } else {\n    pixelColor = SKY_COLOR(rayDirection);\n  }\n  return pixelColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n  vec3 pixelColor;\n#if AA > 1\n  vec2 AAO;\n  const float AA_INCREMENT = 1./float(AA);\n    \n  for(AAO.x = -0.5; AAO.x < 0.5; AAO.x += AA_INCREMENT) {\n    for(AAO.y = -0.5; AAO.y < 0.5; AAO.y += AA_INCREMENT) {\n      pixelColor += PixelColor(uv + AAO/iResolution.y);\n    }\n  }\n  pixelColor /= float(AA*AA);\n#else\n  pixelColor += PixelColor(uv);\n#endif\n  \n  fragColor = vec4(sqrt(clamp(pixelColor, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"}]}