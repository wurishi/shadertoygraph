{"ver":"0.1","info":{"id":"DdcXzf","date":"1680174398","viewed":80,"name":"raytracing experiments","username":"erdUha","description":"just following the book \"Computer graphics from scratch\" by Gabriel Gambetta: https://gabrielgambetta.com/computer-graphics-from-scratch/index.html","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int PIXEL_SAMPLING_SIZE=3;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 resCol;\n    \n     for (int i=0; i<PIXEL_SAMPLING_SIZE; i++) \n     {\n         float n1 = float(i) / float(PIXEL_SAMPLING_SIZE)-0.5;\n         for (int j=0; j<PIXEL_SAMPLING_SIZE; j++)\n         {\n         \tfloat n2 = float(j) / float(PIXEL_SAMPLING_SIZE)-0.5;                                   \n             vec2 Coordtemp =fragCoord+ vec2(n1, n2);\n             resCol += texture(iChannel0,Coordtemp/iResolution.xy).rgb;\n          }\n     }\n    resCol /= float(PIXEL_SAMPLING_SIZE * PIXEL_SAMPLING_SIZE);\n    fragColor=vec4(resCol,1.0);\n    //fragColor=texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = 3.141;\nconst float pih = 1.57;\n\n// Normalized pixel coordinates (from 0 to 1)\nvec2 uv;\n\n// Second uv for camera\nvec2 uv2;\n\n// Mouse input\nvec3 mouse;\nivec2 u = ivec2(0.,0.);\nivec2 u1 = ivec2(1.,0.);\nvec3 mouseLast;\nint click[2];\n\n// Camera\nvec3 O;\nvec3 D = vec3(0.0);\n    \n\n// Ambient light\nstruct ambientLight{\n    float intensity;\n};\nambientLight ambient;\n\n\n// Sun\nstruct directionalLight{\n    float intensity;\n    vec3 direction;\n};\ndirectionalLight sun;\n\n\n// Point lights\nstruct pointLight{\n    float intensity;\n    vec3 position;\n    float r;\n};\nconst int numberOfPointLights = 2;\npointLight pointLights[numberOfPointLights];\n\n// Spheres\nstruct sphere {\n    vec3 C;\n    float r;\n    vec3 color;\n    float roughness;\n    float emission;\n};\nconst int numberOfSpheres = 5;\nsphere spheres[numberOfSpheres];\n\nvec4 spheresImg[numberOfSpheres];\nvec4 spheresImg2[numberOfSpheres];\n\n\n// Smallest z sphere and zbuffer\nvec2 closestSphere = vec2(-1.0,9999999999999999999999.0);\n\nvec2 closestSphere2 = vec2(-1.0,9999999999999999999999.0);\n\n// Lights intensity throughout image\nfloat I[numberOfSpheres]; // Diffuse\nfloat S[numberOfSpheres]; // Specular\n\nfloat I2[numberOfSpheres]; // Diffuse\nfloat S2[numberOfSpheres]; // Specular\n\n// Color if ray don't interact with any sphere\nconst vec3 backgroundColor = vec3(0.15);\n\n\n\nvec4 traceRay(vec2 fragCoord, vec3 O, vec3 D){\n    vec4 fragColor;\n    for (int i = 0; i < int(numberOfSpheres); i++) {\n        // Ray to sphere \n        vec2 distanceToSphere=vec2(0.0);\n        float discriminant=pow((2.0*dot(O-spheres[i].C,D)),2.0)-(4.0)*(dot(D,D)*(dot(O-spheres[i].C,O-spheres[i].C)-(spheres[i].r*spheres[i].r)));\n        if (discriminant>=0.0){\n            distanceToSphere.x=((-(2.0*dot(O-spheres[i].C,D))-sqrt(discriminant))/(2.0*dot(D,D)))*D.z;\n            distanceToSphere.y=((-(2.0*dot(O-spheres[i].C,D))+sqrt(discriminant))/(2.0*dot(D,D)))*D.z;}\n        // Point of sphere and ray intesection\n        vec3 P = O+(D*(distanceToSphere.x/D.z));\n        // Normal vector\n        vec3 N = (P-spheres[i].C)/length(P-spheres[i].C);\n        N.xy *= -1.0;\n        if (discriminant >= 0.0) {\n                vec3 tmp;\n\n                tmp = sun.direction;\n                tmp.xy *= -1.0;\n                if (dot(N,tmp)/(length(N)*length(tmp)) > 0.0){\n                    // Diffuse light for sun\n                    I[i] = pow(dot(N,tmp)/(length(N)*length(tmp)),3.0-(spheres[i].roughness*2.0))*sun.intensity;\n                    // Specular light for sun\n                    S[i] += pow((dot(N,tmp)/(length(N)*length(tmp))),320.0-(spheres[i].roughness*300.0))*sun.intensity;}\n\n            for(int b = 0; b < int(numberOfPointLights); b++){\n                tmp = pointLights[b].position-P+O;\n                tmp.xy *= -1.0;\n                if (dot(N,tmp)/(length(N)*length(tmp)) > 0.0){\n                    I[i] += pow(dot(N,tmp)/(length(N)*length(tmp)),3.0-(spheres[i].roughness*2.0))*pointLights[b].intensity;\n                    S[i] += pow((dot(N,tmp)/(length(N)*length(tmp))),320.0-(pow(spheres[i].roughness+0.001,1.01-(atan(pointLights[b].r*0.4)/pih))*300.0))*pointLights[b].intensity;}\n            }\n        }\n        if (I[i]<0.0){I[i]=0.0;}\n        if (S[i]<0.0){S[i]=0.0;}\n        // Output\n        if (discriminant > 0.0 && distanceToSphere.x>0.0){\n            spheresImg[i].rgb = vec3(0.0),1.0;\n            spheresImg[i].rgb += vec3(I[i]*0.05+(I[i]*0.8*spheres[i].color+(spheres[i].color*ambient.intensity)))+(S[i]*0.05+(S[i]*0.1*(1.0-spheres[i].roughness))),0.0;\n            spheresImg[i].rgb += vec3(spheres[i].emission);}\n        if (distanceToSphere.x<closestSphere.y && discriminant>0.0){\n            closestSphere=vec2(i,distanceToSphere.x);}\n    }\n    if (int(closestSphere.x)==-1 && (fragCoord.y>1.0 || fragCoord.x>2.0)){\n        fragColor.rgb+=backgroundColor;\n    }\n    if (int(closestSphere.x)!=-1 && (fragCoord.y>1.0 || fragCoord.x>2.0)){\n        fragColor+=spheresImg[int(closestSphere.x)];\n        //fragColor+=vec4(reflectedImages[2],0.0);\n\n    }\n    return fragColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0.0);\n    // Defining objects\n    ambient.intensity = 0.2;\n    sun.intensity = 0.5;\n    sun.direction = vec3(1.0,1.0,-0.0);\n    sun.direction /= length(sun.direction);\n    pointLights[0].intensity = 0.0;\n    pointLights[0].position = vec3(-400.0,300.0,5000.0);\n    pointLights[0].r = 30.0;\n    pointLights[1].intensity = 0.0;\n    pointLights[1].position = vec3(400.0,-200.0,2000.0);\n    pointLights[1].r = 30.0;\n    spheres[0].C = vec3(1200.0,-50.0,10000.0);\n    spheres[0].r = 500.0;\n    spheres[0].color = vec3(1.0,0.5,0.5);\n    spheres[0].roughness = 1.0;\n    spheres[1].C = vec3(-500.0,-450.0,6000.0);\n    spheres[1].r = 150.0;\n    spheres[1].color = vec3(0.5,1.0,0.5);\n    spheres[1].roughness = 0.6;\n    spheres[2].C = vec3(-200.0,50.0,3400.0);\n    spheres[2].r = 70.0;\n    spheres[2].color = vec3(0.5,0.5,1.0);\n    spheres[2].roughness = 0.0;\n    spheres[3].C = vec3(-400.0,300.0,5000.0);\n    spheres[3].r = 30.0;\n    spheres[3].emission = 1.0;\n    spheres[4].C = vec3(400.0,-200.0,2000.0);\n    spheres[4].r = 30.0;\n    spheres[4].emission = 1.0;\n\n    uv = fragCoord/iResolution.xy;\n    uv2 = fragCoord-(iResolution.xy*0.5);\n    \n    mouseLast = texelFetch(iChannel0,u,0).rgb;\n    \n    mouse.z = iMouse.z;\n    if (mouse.z>0.0){\n            mouse.xy = (iMouse.xy-(iResolution.xy*0.5))/(iResolution.y/360.0);\n        }\n    else {\n            mouse.xy = iMouse.xy;\n        }\n    if (mouse.z>0.0){\n        click[0]=1;}\n    if (mouseLast.b>0.0){\n        click[1]=1;}\n    D.xy = uv2/(iResolution.y/360.0);\n    D.z = 1000.0;\n    \n    \n    \n    \n    O = texelFetch(iChannel0,u1,0).rgb;\n    if (click[0]==click[1]){\n        O.xy -= (mouse.xy-mouseLast.xy)*4.0;}\n    \n    \n    \n    \n\n    fragColor = traceRay(fragCoord, O, D);\n\n    // Sending information to future frame via two pixels in bottom-left corner\n    if(ivec2(fragCoord.xy) == ivec2(u)){\n        fragColor.rg = mouse.xy;\n        fragColor.b = mouse.z;\n\n    }\n    if(ivec2(fragCoord.xy) == ivec2(u1)){\n\n        fragColor.rgb = O.xyz;\n    }\n}\n\n\n\n\n\n\n//vec3 rayTrace(vec3 O,vec3 D, ){\n    \n//}","name":"Buffer A","description":"","type":"buffer"}]}