{"ver":"0.1","info":{"id":"fscyRB","date":"1653588983","viewed":263,"name":"Simple Raytracer by Omni","username":"Omniscience","description":"My first shader here, a simple raytracer with all scene data hardcoded in VRAM featuring bounces per fragment, and a hardcoded material composed of a perfect matte layer with a perfect mirror clearcoat layer, environment maps, and the fresnel effect.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","pathtrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.141592653589793238462643327950;\nconst float DEG_TO_RAD = PI / 180.0;\nconst vec3 FWD = vec3(0.0, 0.0, 1.0);\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\nconst vec3 ZERO3 = vec3(0.0, 0.0, 0.0);\nconst vec3 ONE3 = vec3(1.0, 1.0, 1.0);\n\nmat4 identity() {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 translate(vec3 pos) {\n    return mat4(\n        1.0, 0.0, 0.0, pos.x,\n        0.0, 1.0, 0.0, pos.y,\n        0.0, 0.0, 1.0, pos.z,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateX(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c,   -s,  0.0,\n        0.0, s,   c,   0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateY(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n        c,   0.0, s,   0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -s,  0.0, c,   0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateZ(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n        c,   -s,  0.0, 0.0,\n        s,   c,   0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Material {\n    vec3 diffuse;\n    vec3 specular;\n};\nconst Material BLACK = Material(ZERO3, ZERO3);\nconst Material WHITE = Material(vec3(1.0).xxx, ZERO3);\nconst Material RED   = Material(vec3(1.0, 0.0, 0.0), ZERO3);\nconst Material GREEN = Material(vec3(0.0, 1.0, 0.0), ZERO3);\nconst Material BLUE  = Material(vec3(0.0, 0.0, 1.0), ZERO3);\nconst Material BACKGROUND = Material(vec3(0.5, 0.75, 1.0), ZERO3);\n\nMaterial mat(vec3 c) { return Material(c, ZERO3); }\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nstruct Contact {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\nconst Contact NO_CONTACT = Contact(false, ZERO3, ZERO3, BACKGROUND);\n\nstruct Sample {\n    vec3 light;\n    Contact contact;\n};\n\nContact raySphereContact(Ray ray, Sphere sphere) {\n    vec3 O = ray.pos;\n    vec3 D = ray.dir;\n    vec3 C = sphere.position;\n    float r = sphere.radius;\n    float r2 = r*r;\n    vec3 L = C - O;\n    \n    float tca = dot(L, ray.dir);\n    //if (tca < 0.0) return NO_CONTACT;\n    \n    float d2 = dot(L, L) - tca*tca;\n    if (d2 > r2) return NO_CONTACT;\n    \n    float thc = sqrt(r2 - d2);\n    float t0 = min(tca - thc, tca + thc);\n    if (t0 < 0.0) return NO_CONTACT;\n    \n    vec3 P = O + t0 * D;\n    \n    return Contact(true, P, normalize(P - C), sphere.material);\n}\n\nconst float _m = 0.125;\nconst float _M = 0.5;\n\nconst int NUM_OBJECTS = 3;\nconst Sphere objects[] = Sphere[](\n    Sphere(vec3(-2.5, 1.0, 0.0), 1.0, Material(vec3(_M, _m, _m), ZERO3)),\n    Sphere(vec3(0.0,  1.0, 0.0), 1.0, Material(vec3(_m, _M, _m), ZERO3)),\n    Sphere(vec3(2.5,  1.0, 0.0), 1.0, Material(vec3(_m, _m, _M), ZERO3))\n);\n\nRay reflectRay(Ray ray, Contact contact) {\n    return Ray(contact.position, reflect(ray.dir, contact.normal));\n}\n\nconst int MAX_DEPTH = 4;\n\nfloat lerp(float a, float b, float x) { return a + (b-a) * x; }\n\nContact sampleRayOnce(Ray ray) {\n    Contact best = NO_CONTACT;\n    float bestDist = 0.0;\n    \n    for (int i=0; i<NUM_OBJECTS; ++i) {\n        Contact contact = raySphereContact(ray, objects[i]);\n        if (contact.hit) {\n            float d = distance(ray.pos, contact.position);\n            if (!best.hit || d < bestDist) {\n                best = contact;\n                bestDist = d;\n            }\n        }\n    }\n\n    if (ray.dir.y < 0.0 && ray.pos.y > 0.0) {\n        float y = ray.pos.y;\n        float aspect = y / ray.dir.y;\n        float h = -1.0 * aspect;\n        vec3 pos = ray.pos + ray.dir * h;\n\n        Material mat = BLACK;\n        bool bx = fract(pos.x * 0.5) < 0.5;\n        bool bz = fract(pos.z * 0.5) < 0.5;\n        if (bx ^^ bz) mat = WHITE;\n        \n        Contact contact = Contact(true, pos, UP, mat);\n        \n        float d = distance(ray.pos, contact.position);\n        if (!best.hit || d < bestDist) {\n            best = contact;\n            bestDist = d;\n        }\n    }\n    \n    if (!best.hit) {\n        best.material.diffuse = texture(iChannel0, ray.dir).xyz;\n        //best.material.diffuse = BACKGROUND.diffuse * lerp(0.5, 1.5, pow(1.0 - ray.dir.y, 1.5));\n    }\n    \n    return best;\n}\n\nSample sampleRay(Ray ray) {\n    Contact firstContact = NO_CONTACT;\n    vec3 light = ZERO3;\n    float absorbtion = 1.0;\n    \n    for (int depth=0; depth<MAX_DEPTH; ++depth) {\n        Contact contact = sampleRayOnce(ray);\n        \n        if (depth == 0) firstContact = contact;\n        \n        if (contact.hit) {\n            float dp = clamp(-dot(ray.dir, contact.normal), 0.0, 1.0);\n            float kd = pow(dp, 0.99);\n            float ks = lerp(0.0, 1.0, 1.0 - pow(kd, 0.75));\n\n            light += contact.material.diffuse * kd * absorbtion;\n            absorbtion *= ks;\n\n            ray = reflectRay(ray, contact);\n        }\n        else {\n            light += contact.material.diffuse * absorbtion;\n            break;\n        }\n    }\n    \n    return Sample(light, firstContact);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 screenPos = vec4(-1.0 + 2.0 * fragCoord / iResolution.xy, 0.0, 1.0);\n    screenPos.x *= aspectRatio;\n    \n    mat4 projection = identity();\n    projection *= translate(vec3(0.0f, 0.0, -6.0));\n    projection *= rotateX(5.0 * DEG_TO_RAD);\n    projection *= rotateY(mod(iTime * 10.0, 360.0) * DEG_TO_RAD);\n    projection *= translate(vec3(1.0f, 0.75, 0.0));\n    \n    vec4 rayPos = vec4(ZERO3, 1.0) * projection;\n    vec3 rayDir = normalize(vec3(screenPos.xy, 2.0)) * mat3(projection);\n    Ray ray = Ray(rayPos.xyz, rayDir);\n    Sample raySample = sampleRay(ray);\n    Contact contact = raySample.contact;\n    \n    fragColor = vec4(rayDir, 1.0);\n    fragColor = vec4(rayPos.yyy, 1.0);\n    fragColor = vec4(contact.normal, 1.0);\n    fragColor = vec4(raySample.light, 1.0);\n}","name":"Image","description":"","type":"image"}]}