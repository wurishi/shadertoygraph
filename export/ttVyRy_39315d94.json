{"ver":"0.1","info":{"id":"ttVyRy","date":"1611270279","viewed":106,"name":"Cube room","username":"SID37","description":"Attempt to write a path trace","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","reflection","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 frame = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(frame.xyz, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STACK_SIZE 20\n#define TRACE_COUNT 1\n\n#define INFINITY (1e300 * 1e300)\n#define EPSILON 1e-5\n\n\n// ***********************************************\n// *                 Random                      *\n// ***********************************************\n\n#define RAND_MAX 0x7fff\n\nint _random_seed = 0;\n\nint Rand()\n{\n\treturn (((_random_seed = _random_seed * 214013 + 2531011) >> 16) & 0x7fff);\n}\n\nvoid SRand(int seed)\n{\n\t_random_seed = seed;\n}\n\nvoid SRand(vec2 coord)\n{\n\tint x = int(coord.x);\n\tint y = int(coord.y);\n\tSRand(int(iTimeDelta * iTime * 100000.0) + 3547 * (x * x * y + y * y * x) + x * 231 + y * 132);\n}\n\nfloat Rand01()\n{\n\treturn float(Rand()) * (1.0 / float(RAND_MAX));\n}\n\nfloat Rand11()\n{\n\treturn (float(RAND_MAX) - float(Rand()) * 2.0) * (1.0 / float(RAND_MAX));\n}\n\n\n// ***********************************************\n// *                   Ray                       *\n// ***********************************************\n\nstruct Ray\n{\n\tvec3 p;\n\tvec3 t;\n\tvec3 color;\n};\n\n\n// ***********************************************\n// *                 Triangle                    *\n// ***********************************************\n\nstruct Triangle\n{\n\tvec3 p1;\n\tvec3 p2;\n\tvec3 p3;\n\tint mtl;\n};\n\nstruct PreTriangle\n{\n\tvec3 p;\n\tvec3 u;\n\tvec3 v;\n\tvec3 n;\t\t// non-normalized normal\n\tint mtl;\n};\n\nPreTriangle Prepare(Triangle triangle)\n{\n\tvec3 u = triangle.p2 - triangle.p1;\n\tvec3 v = triangle.p3 - triangle.p1;\n\treturn PreTriangle(\n\t\ttriangle.p1,\n\t\tu, v,\n\t\tcross(u, v),\n\t\ttriangle.mtl\n\t);\n}\n\n// ***********************************************\n// *               LightSphere                   *\n// ***********************************************\n\nstruct LightSphere\n{\n\tvec3 p;\n\tfloat r;\n\tint mtl;\n};\n\n\n// ***********************************************\n// *                  World                      *\n// ***********************************************\n\n#define TRIANGLE_COUNT 36\n#define MATERIAL_COUNT 5\n#define LIGHT_SPHERE_COUNT 1\n\nstruct Material\n{\n\tvec3 diffuse;\n\tvec3 mirror;\n\tvec3 light;\n\n\tbool is_diffuse;\n\tbool is_mirror;\n\tbool is_light;\n};\n\n\nMaterial materials[MATERIAL_COUNT];\nPreTriangle preTriangles[TRIANGLE_COUNT];\nLightSphere lightSpheres[LIGHT_SPHERE_COUNT];\n\n\nvoid InitWorld()\n{\n\t//\tInit material\n\tmaterials[0] = Material(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), true, false, false);\n\tmaterials[1] = Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 0.99, 0.9) * 4.0, false, false, true);\n\tmaterials[2] = Material(vec3(0.9, 0.9, 0.9), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.3)*3.0, true, false, true);\n\tmaterials[3] = Material(vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5), vec3(0.0, 0.0, 0.0), false, true, false);\n\tmaterials[4] = Material(vec3(0.8, 0.4, 0.4), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), true, false, false);\n\n\t//\tInit light\n\tlightSpheres[0] = LightSphere(vec3(0.0, 1.0, 2.0), 0.3, 1);\n\n\t//\tInit triangles\n\tTriangle triangles[TRIANGLE_COUNT];\n\ttriangles[0] = Triangle(vec3(2, 2, 4), vec3(2, 2, 0), vec3(2, -2, 0), 3);\n\ttriangles[1] = Triangle(vec3(2, 2, 4), vec3(2, -2, 0), vec3(2, -2, 4), 3);\n\ttriangles[2] = Triangle(vec3(2, 2, 4), vec3(-2, 2, 0), vec3(2, 2, 0), 0);\n\ttriangles[3] = Triangle(vec3(2, 2, 4), vec3(-2, 2, 4), vec3(-2, 2, 0), 0);\n\ttriangles[4] = Triangle(vec3(2, -2, 4), vec3(2, -2, 0), vec3(-2, -2, 0), 0);\n\ttriangles[5] = Triangle(vec3(2, -2, 4), vec3(-2, -2, 0), vec3(-2, -2, 4), 0);\n\ttriangles[6] = Triangle(vec3(2, 2, 4), vec3(-2, -2, 4), vec3(-2, 2, 4), 0);\n\ttriangles[7] = Triangle(vec3(2, 2, 4), vec3(2, -2, 4), vec3(-2, -2, 4), 0);\n\ttriangles[8] = Triangle(vec3(2, 2, 0), vec3(-2, 2, 0), vec3(-2, -2, 0), 0);\n\ttriangles[9] = Triangle(vec3(2, 2, 0), vec3(-2, -2, 0), vec3(2, -2, 0), 0);\n\ttriangles[10] = Triangle(vec3(-2, 2, 4), vec3(-2, -2, 0), vec3(-2, 2, 0), 4);\n\ttriangles[11] = Triangle(vec3(-2, 2, 4), vec3(-2, -2, 4), vec3(-2, -2, 0), 4);\n\n\ttriangles[12] = Triangle(vec3(-0.5, -2, 1.5), vec3(-0.5, -2, 2.5), vec3(-0.5, -1, 2.5), 0);\n\ttriangles[13] = Triangle(vec3(-0.5, -2, 1.5), vec3(-0.5, -1, 2.5), vec3(-0.5, -1, 1.5), 0);\n\ttriangles[14] = Triangle(vec3(-0.5, -2, 1.5), vec3(0.5, -2, 2.5), vec3(-0.5, -2, 2.5), 0);\n\ttriangles[15] = Triangle(vec3(-0.5, -2, 1.5), vec3(0.5, -2, 1.5), vec3(0.5, -2, 2.5), 0);\n\ttriangles[16] = Triangle(vec3(-0.5, -1, 1.5), vec3(-0.5, -1, 2.5), vec3(0.5, -1, 2.5), 0);\n\ttriangles[17] = Triangle(vec3(-0.5, -1, 1.5), vec3(0.5, -1, 2.5), vec3(0.5, -1, 1.5), 0);\n\ttriangles[18] = Triangle(vec3(-0.5, -2, 1.5), vec3(0.5, -1, 1.5), vec3(0.5, -2, 1.5), 0);\n\ttriangles[19] = Triangle(vec3(-0.5, -2, 1.5), vec3(-0.5, -1, 1.5), vec3(0.5, -1, 1.5), 0);\n\ttriangles[20] = Triangle(vec3(-0.5, -2, 2.5), vec3(0.5, -2, 2.5), vec3(0.5, -1, 2.5), 0);\n\ttriangles[21] = Triangle(vec3(-0.5, -2, 2.5), vec3(0.5, -1, 2.5), vec3(-0.5, -1, 2.5), 0);\n\ttriangles[22] = Triangle(vec3(0.5, -2, 1.5), vec3(0.5, -1, 2.5), vec3(0.5, -2, 2.5), 0);\n\ttriangles[23] = Triangle(vec3(0.5, -2, 1.5), vec3(0.5, -1, 1.5), vec3(0.5, -1, 2.5), 0);\n\n\ttriangles[24] = Triangle(vec3(1.25, -0.95, 3.75), vec3(1.75, -0.95, 4.25), vec3(1.25, -0.95, 4.25), 2);\n\ttriangles[25] = Triangle(vec3(1.25, -0.95, 3.75), vec3(1.75, -0.95, 3.75), vec3(1.75, -0.95, 4.25), 2);\n\ttriangles[26] = Triangle(vec3(1.25, -0.45, 3.75), vec3(1.25, -0.45, 4.25), vec3(1.75, -0.45, 4.25), 2);\n\ttriangles[27] = Triangle(vec3(1.25, -0.45, 3.75), vec3(1.75, -0.45, 4.25), vec3(1.75, -0.45, 3.75), 2);\n\ttriangles[28] = Triangle(vec3(1.25, -0.95, 3.75), vec3(1.75, -0.45, 3.75), vec3(1.75, -0.95, 3.75), 2);\n\ttriangles[29] = Triangle(vec3(1.25, -0.95, 3.75), vec3(1.25, -0.45, 3.75), vec3(1.75, -0.45, 3.75), 2);\n\ttriangles[30] = Triangle(vec3(1.25, -0.95, 4.25), vec3(1.75, -0.95, 4.25), vec3(1.75, -0.45, 4.25), 2);\n\ttriangles[31] = Triangle(vec3(1.25, -0.95, 4.25), vec3(1.75, -0.45, 4.25), vec3(1.25, -0.45, 4.25), 2);\n\ttriangles[32] = Triangle(vec3(1.75, -0.95, 3.75), vec3(1.75, -0.45, 4.25), vec3(1.75, -0.95, 4.25), 2);\n\ttriangles[33] = Triangle(vec3(1.75, -0.95, 3.75), vec3(1.75, -0.45, 3.75), vec3(1.75, -0.45, 4.25), 2);\n\ttriangles[34] = Triangle(vec3(1.25, -0.95, 3.75), vec3(1.25, -0.95, 4.25), vec3(1.25, -0.45, 4.25), 2);\n\ttriangles[35] = Triangle(vec3(1.25, -0.95, 3.75), vec3(1.25, -0.45, 4.25), vec3(1.25, -0.45, 3.75), 2);\n\n\t//\tPrepare triangles\n\tfor(int i = 0; i < TRIANGLE_COUNT; ++i)\n\t\tpreTriangles[i] = Prepare(triangles[i]);\n}\n\n\n// ***********************************************\n// *                  Stack                      *\n// ***********************************************\n\nstruct StackFrame\n{\n\tRay ray;\n\tint dif_depth;\n\tint ref_depth;\n};\n\nstruct ShadowFrame\n{\n\tRay ray;\n\tint index;\n};\n\nStackFrame _stack[STACK_SIZE + TRACE_COUNT];\nShadowFrame _shadowStack[STACK_SIZE * LIGHT_SPHERE_COUNT];\nint _stack_top = -1;\nint _shadow_top = -1;\n\nvoid PushFrame(StackFrame frame)\n{\n\t++_stack_top;\n\t_stack[_stack_top] = frame;\n}\n\nvoid PushShadow(ShadowFrame frame)\n{\n\t++_shadow_top;\n\t_shadowStack[_shadow_top] = frame;\n}\n\nStackFrame TopFrame()\n{\n\treturn _stack[_stack_top];\n}\n\nShadowFrame TopShadow()\n{\n\treturn _shadowStack[_shadow_top];\n}\n\nvoid PopFrame()\n{\n\t--_stack_top;\n}\n\nvoid PopShadow()\n{\n\t--_shadow_top;\n}\n\nbool EmptyFrames()\n{\n\treturn _stack_top < 0;\n}\n\nbool EmptyShadows()\n{\n\treturn _shadow_top < 0;\n}\n\n\n// ***********************************************\n// *              Intersection                   *\n// ***********************************************\n\nstruct TriangleInter\n{\n\tint index;\n\tfloat dist;\n\tfloat v;\n\tfloat u;\n};\n\nstruct SphereInter\n{\n\tint index;\n\tfloat dist;\n};\n\nstruct Inter\n{\n\tvec3 norm;\n\tvec3 point;\n\tfloat dist;\n\tint mtl;\n};\n\nvoid Intersect(Ray ray, PreTriangle t, out TriangleInter inter, int index)\n{\n\tvec3 norm = t.n;\n\tfloat det = -dot(ray.t, norm);\n\tif (det < EPSILON && det > -EPSILON) return;\n\n\tvec3 D = (ray.p - t.p) / det;\n\tfloat dist = dot(D, norm);\n\n\tif (dist < EPSILON || dist > inter.dist)\n\t\treturn;\n\n\tvec3 C = cross(D, ray.t);\n\n\tfloat u = dot(t.v, C);\n\tfloat v = -dot(t.u, C);\n\tif (u < 0.0 || v < 0.0 || u + v > 1.0)\n\t\treturn;\n\n\tinter.index = index;\n\tinter.dist = dist;\n\tinter.v = v;\n\tinter.u = u;\n}\n\nvoid Intersect(Ray ray, LightSphere s, out SphereInter inter, int index)\n{\n\tvec3 delta = s.p - ray.p;\n\tfloat cosa = min(dot(normalize(delta), ray.t), 0.9999);\n\tfloat t = length(delta);\n\tfloat k = t * cosa;\n\tfloat D = s.r * s.r - t * t + k * k;\n\t\n\tif (D < 0.0)\n\t\treturn;\n\n\tfloat dist = k - sqrt(D);\n\tif (dist < EPSILON || dist > inter.dist)\n\t\treturn;\n\n\tinter.dist = dist;\n\tinter.index = index;\n}\n\nvoid Intersect(Ray ray, out TriangleInter tInter, out SphereInter sInter)\n{\n\ttInter.dist = INFINITY;\n\tfor(int i = 0; i < TRIANGLE_COUNT; ++i)\n\t\tIntersect(ray, preTriangles[i], tInter, i);\n\n\tsInter.dist = tInter.dist;\n\tfor(int i = 0; i < LIGHT_SPHERE_COUNT; ++i)\n\t\tIntersect(ray, lightSpheres[i], sInter, i);\n}\n\nvoid Intersect(Ray ray, out Inter inter, bool intersectlightSphere)\n{\n\tinter.dist = INFINITY;\n\n\tTriangleInter tInter;\n\tSphereInter sInter;\n\tIntersect(ray, tInter, sInter);\n\n\tif (sInter.dist < tInter.dist)\n\t{\n\t\tif(!intersectlightSphere)\n\t\t\treturn;\n\t\tLightSphere s = lightSpheres[sInter.index];\n\t\tinter.dist = sInter.dist;\n\t\tinter.mtl = s.mtl;\n\t\tinter.point = ray.p = ray.t * sInter.dist;\n\t\tinter.norm = normalize(inter.point - s.p);\n\t}\n\telse if (tInter.dist != INFINITY)\n\t{\n\t\tPreTriangle t = preTriangles[tInter.index];\n\t\tinter.dist = tInter.dist;\n\t\tinter.mtl = t.mtl;\n\t\tinter.point = t.p + t.v * tInter.v + t.u * tInter.u;\n\t\tinter.norm = normalize(t.n);\n\t}\n}\n\n// ***********************************************\n// *                  Trace                      *\n// ***********************************************\n\nvoid Mirror(StackFrame frame, Inter inter, Material mtl)\n{\n\tif (frame.dif_depth >= 3 || frame.ref_depth >= 5)\n\t\treturn;\n\n\tvec3 reflection = frame.ray.t - inter.norm * dot(inter.norm, frame.ray.t) * 2.0;\n\tPushFrame(StackFrame(\n\t\tRay(inter.point,\n\t\t\treflection,\n\t\t\tframe.ray.color * mtl.mirror),\n\t\tframe.dif_depth,\n\t\tframe.ref_depth + 1));\n}\n\nvec3 RandomSphereXRay(float minSinps)\n{\n\tfloat sinph = minSinps + Rand01() * (1.0 - minSinps);\n\tfloat cosph = sqrt(1.0 - sinph * sinph);\n\tfloat ps = Rand01() * (2.0 * 3.1415926535897932);\n\tfloat sinps = sin(ps);\n\tfloat cosps = cos(ps);\n\n\treturn vec3(sinph, sinps * cosph, cosps * cosph);\n}\n\nvec3 RotateToVector(vec3 base, vec3 v)\n{\n\tfloat xylen = sqrt(base.x * base.x + base.y * base.y);\n\tif (xylen < EPSILON && xylen > -EPSILON)\n\t\treturn v * base.z;\n\n\tfloat xzsin = xylen;\n\tfloat xzcos = -base.z;\n\tv = vec3(v.x * xzsin + v.z * xzcos, v.y, -v.x * xzcos + v.z * xzsin);\n\tfloat xycos = base.y / xylen;\n\tfloat xysin = base.x / xylen;\n\tv = vec3(v.x * xysin - v.y * xycos, v.x * xycos + v.y * xysin, v.z );\n\treturn v;\n}\n\nvoid Diffuse(StackFrame frame, Inter inter, Material mtl)\n{\n\tif (frame.dif_depth >= 3 || frame.ref_depth >= 5)\n\t\treturn;\n\n\tfloat k_sum = 1.0;\n\tfloat ray_k = 0.5;\n\tfloat path_k = 1.0 - ray_k;\n\tray_k *= k_sum;\n\tpath_k *= k_sum;\n\t\n\tvec3 color = frame.ray.color * mtl.diffuse;\n\tvec3 shadColor = ray_k * color;\n\tvec3 randColor = path_k * color;\n\t//\tshadow ray\n\tfor(int i = 0 ; i < LIGHT_SPHERE_COUNT; ++i)\n\t{\n\t\tLightSphere s = lightSpheres[i];\n\t\tfloat sina = s.r / length(s.p - frame.ray.p) * 0.4;\n\t\tvec3 lightRotation = RotateToVector(normalize(s.p - inter.point),\n\t\t\tRandomSphereXRay(sqrt(1.0 - sina * sina))); //sqrt(1.0 - sina * sina)\n\t\tif(dot(lightRotation, inter.norm) < 0.0)\n\t\t\tcontinue;\n\t\tif (dot(lightRotation, inter.norm) > 0.0)\n\t\tPushShadow(ShadowFrame(\n\t\t\tRay(inter.point,\n\t\t\t\tlightRotation,\n\t\t\t\tshadColor),\n\t\t\ti));\n\t}\n\n\t//\trandom ray\n\tvec3 diffuse = RandomSphereXRay(-1.0);\n\n\tif (dot(diffuse, inter.norm) < 0.0)\n\t\tdiffuse = -diffuse;\n\n\tPushFrame(StackFrame(\n\t\tRay(inter.point,\n\t\t\tdiffuse,\n\t\t\trandColor),\n\t\tframe.dif_depth + 1,\n\t\tframe.ref_depth + 1));\n}\n\nfloat _depth = 0.0;\n\nvec3 FrameTrace()\n{\n\tvec3 result = vec3(0, 0, 0);\n\n\twhile(!EmptyFrames())\n\t{\n\t\tStackFrame frame = TopFrame();\n\t\tPopFrame();\n\t\t\n\t\tInter inter;\n\t\tIntersect(frame.ray, inter, frame.dif_depth < 1);\n        if(frame.dif_depth < 1 && frame.ref_depth < 1)\n            _depth += inter.dist;\n\t\tif (inter.dist == INFINITY)\n\t\t\tcontinue;\n\t\tMaterial mtl = materials[inter.mtl];\n\t\tif (mtl.is_light)\n\t\t\tresult += mtl.light * frame.ray.color;\n\t\tif (mtl.is_mirror)\n\t\t\tMirror(frame, inter, mtl);\n\t\tif (mtl.is_diffuse)\n\t\t\tDiffuse(frame, inter, mtl);\n\t}\n\treturn result;\n}\n\nvec3 ShadowTrace()\n{\n\tvec3 result = vec3(0, 0, 0);\n\n\twhile(!EmptyShadows())\n\t{\n\t\tShadowFrame frame = TopShadow();\n\t\tPopShadow();\n\t\tTriangleInter tInter;\n\t\tSphereInter sInter;\n\t\tIntersect(frame.ray, tInter, sInter);\n\n\t\tif(sInter.dist < tInter.dist && sInter.index == frame.index)\n\t\t{\n\t\t\tLightSphere s = lightSpheres[sInter.index];\n\t\t\tfloat mult = s.r / length(s.p - frame.ray.p);\n\t\t\tresult += materials[s.mtl].light * frame.ray.color * mult;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nvec3 Trace()\n{\n\treturn FrameTrace() + ShadowTrace();\n}\n\n\n// ***********************************************\n// *                  Main                       *\n// ***********************************************\n\nvoid FillStack(vec2 coord)\n{\n\tint x = int(coord.x);\n\tint y = int(iResolution.y - coord.y);\n\tint w = int(iResolution.x);\n\tint h = int(iResolution.y);\n\tfloat k = 1.0 / float(h);\n\n\tvec3 d = vec3(iMouse.x, -iMouse.y, 0.0) / vec3(iResolution.xy, 1.0) + vec3(-0.5, 0.5, 0.0);\n\tfor (int i = 0; i < TRACE_COUNT; ++i)\n\t{\n\t\tPushFrame(StackFrame(Ray(\n\t\t\t\tvec3(0, 0, 0) + d,\n\t\t\t\tnormalize(vec3(k * (float(w) * 0.5 - float(x) + Rand01()),\n\t\t\t\t\tk * (float(h) * 0.5 - float(y) + Rand01()), 0.5)),\n\t\t\t\tvec3(1, 1, 1)\n\t\t\t), 0, 0));\n\t}\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 coord)\n{\n\tSRand(coord);\n\tInitWorld();\n\tFillStack(coord);\n    float denoise_k = 0.5;\n    \n    vec3 trace = Trace() / float(TRACE_COUNT);\n    vec4 delta = (iMouse - texture(iChannel1, coord / iResolution.xy));\n    _depth = _depth / float(TRACE_COUNT);\n    vec4 screenDelta = delta * _depth / (15.0 + _depth)*0.4;\n    \n    vec3 lastColor = texture(iChannel0, (coord - screenDelta.xy) / iResolution.xy).xyz;\n\t\n    fragColor = vec4(trace * (1.0 - denoise_k) + \n       lastColor * denoise_k, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iMouse.xy,0.0,0.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}