{"ver":"0.1","info":{"id":"MlBfDG","date":"1517918644","viewed":262,"name":"test_Pierre","username":"marzinp","description":"Sorry if it looks very naive, but I'm trying to learn... I know there are lots of mistakes! Please do tell me where I'm wrong! ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["refraction","reflexion","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n  #define OBJECT_REFLECTIVITY 0.1 \n  // Created by inigo quilez - iq/2013\n  // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n  // A list of usefull distance function to simple primitives, and an example on how to \n  // do some interesting boolean operations, repetition and displacement.\n  //\n  struct Ray { \n  vec3 origin; \n  vec3 direction;\n};\n\nstruct Material { \n  vec3 baseColor;\n  float metallic;\n  float refractindex;\n  float transparency;\n  float reflectivity;\n  float spec;\n};\n\nstruct Intersection {\n  float dist;\n  vec3 position;\n  vec3 normal;\n  Material material;\n  float thickness;\n};\nMaterial material0=Material(vec3(.2, 0.01, .05), .3, 1.25, .3, .6,.6);\nMaterial material1=Material(vec3(0., .3, .1), .3, 1.25, .7, .5,.7);\nMaterial material2=Material(vec3(0., 0.0, .3), .3, 1.35, .6, .4,.2);\nMaterial matplane=Material(vec3(0., 0.0, .0), .0, 1.0, .0, .9,.7);\nMaterial matbackground=Material(vec3(0.8, 0.9, 1.0),0.,0.,0.,0.,0.);\nMaterial material3=Material(vec3(0.3, 0.3, .0), .3, 1.45, .6, .3,1.2);\n\nvec3 rotateY(vec3 v,float alpha){\n    float c=cos(alpha);\n    float s=sin(alpha);\n    return mat3(c,0.,s,0.,1.,0.,-s,0.,c)*v;\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n//Union\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  if (d1.x<d2.x)return d1;\n  else return d2;\n}\n//Substraction\nfloat opS( float d1, float d2 )\n{\n  return max(-d1, d2);\n}\n//Intersection\nfloat opI( float d1, float d2 )\n{\n  return max(d1, d2);\n}\n\nvec2 map(in vec3 q) {\n  vec2 m=opU(opU(vec2(sdBox(rotateY(q,.3)+vec3(-.2,0.,.8), vec3(.5, 1.0, 2.0)), 0.),\n                 vec2 (sdSphere(q+vec3(1.0, 0.5, 0.), .5), 1.)), \n  vec2(sdSphere(q+vec3(1.5, 0.5, 1.0), .5), 2.0));\n  m=opU(m, vec2(sdPlane(q+vec3(0.0, 1.0, 0.0)), 1.5)); \n  m=opU(m,vec2(sdEllipsoid(q+vec3(-1.5,-.5, 1.0), vec3(.3,1.5,.3)),3.0));\n  return m;\n}\nvec2 castRay( in vec3 ro, in vec3 rd, float tmin, float tmax )//spheretracing\n{\n  float omega = 1.6;\n  float t = tmin;\n  float candidate_error = 1000.;\n  float candidate_t = tmin;\n  float previousRadius = 0.;\n  float stepLength = 0.;\n  float m=-1.0;\n  vec2 res;\n  int maxiterations=256;\n  float precis=.0001;\n  float functionSign = map(ro).x < 0. ? -1. : +1.;\n\n    for (int i = 0; i < 10000; ++i) {\n        if(i>maxiterations)break;\n    res=map(rd*t + ro);\n    float signedRadius = functionSign * res.x;\n    float radius = abs(signedRadius);\n    bool sorFail = omega > 1. &&(radius + previousRadius) < stepLength;\n    if (sorFail) {\n      stepLength -= omega * stepLength;\n      omega = 1.;\n    } else {\n      stepLength = signedRadius * omega;\n    }\n    previousRadius = radius;\n    float error = radius / t;\n    if (!sorFail && error < candidate_error) {\n      candidate_t = t;\n      candidate_error = error;\n    }\n    if (!sorFail && error < precis&&signedRadius>0.|| t > tmax)break;\n    t += stepLength;\n  }\n  if (t > tmax) return vec2(tmax, -1.0);\n  return vec2(candidate_t, res.y);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n  float t = mint;\n  for ( int i=0; i<128; i++ )\n  {\n    float h = map( ro + rd*t ).x;\n    res = min( res, 32.0*h/t );\n    t += clamp( h, 0.01, 0.10 );\n    if ( h<0.001 || t>tmax ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3( 0.001, 0.0, 0.0 );\n  vec3 nor = vec3(\n    map(pos+eps.xyy).x - map(pos-eps.xyy).x, \n    map(pos+eps.yxy).x - map(pos-eps.yxy).x, \n    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n  return normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n \nMaterial getMaterial(float c) {\n  Material material=matbackground;\n  if (c==0.)material=material0;\n  else if (c==1.)material=material1;\n  else if (c==2.)material=material2;\n  else if (c==3.)material=material3;\n  else if ( c==1.5)material=matplane;\n  return material;\n}\n\nvec3 getColor(Material mat, vec3 pos) {\n    vec3 col = vec3(0);\n    if (mat == matplane) {\n        col =vec3(mod(floor(pos.x * 4.0) + floor(pos.z * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n    } \n    else col = mat.baseColor;\n\n \treturn col;\n\n}  \n   \nIntersection trace( in vec3 ro, in vec3 rd, float tmin, float tmax)//modified sphere tracing\n{\n  float t = tmin;\n  Material m0=getMaterial(map(ro+tmin*rd).y);\n  float m;\n  vec2 res;\n  vec3 nor;\n  int maxiterations=256;\n  float precis=.0001;\n  float t0=tmin;  \n  float count=0.;\n  for ( int i=0; i<10000; i++ )\n  {\n    if(i>maxiterations)break;\n    res = map( ro+rd*t );\n    m = res.y;//material index\n      if ((abs(res.x)<precis) || t>tmax ) {\n          count++;           \n          if(count>1.)break;//we reached another object, or the same one again\n          else{\n          \tt0=t;//we're to exit the object\n            vec3 pos0=ro+rd*t;\n          \tt+=.002;//actually exit it\n          \tro+=rd*t;//ray origin is now the exit point\n          \trd=refract(rd,-calcNormal(pos0),getMaterial(m).refractindex);//and the ray is refracted back\n          \tt=0.001;\n          }\n      }\n      \n    t +=abs(res.x);\n  }\n    if ( t+t0>tmax ) {\n        m=-1.0;\n        //t=0.;\n    }\n  return Intersection( t+t0,ro+rd*t,calcNormal(ro+t*rd), getMaterial(m),t0 );//we'll use t0 to calculate the color of the \"translucent\" object\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n  vec3 col = vec3(0.8, 0.9, 1.0);\n  vec2 res = castRay(ro, rd, 0., 10.);\n  float t = res.x;\n  float m = res.y;\n  Material material=getMaterial(m);\n  if ( m>=0.0)\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    if(m==1.0)nor*=vec3(abs(sin(pos.y*55.)));//bump map\n    vec3 refl = normalize(reflect( rd, nor));\n    vec3 col1;\n\tvec3 refr = normalize(refract(rd, nor, 1.0/material.refractindex));\n    vec3 col2;\n\n    // material        \n    col=getColor(material,pos);\n\n    // lighting        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(3.0*sin(iTime/3.0), 1.5, 3.0*cos(iTime/3.0)) );\n    \n      // fresnel\n    float fresnel =.05+0.95*pow(clamp(1.0 - dot(nor,-rd), 0.0,1.),3.0);\n    \n    if (material.reflectivity>0.) {//reflection\n      res=castRay(pos, refl, 0.01, 10.0);\n      float trefl= res.x;\n      float mrefl=res.y;\n      vec3 posr=pos+trefl*refl;\n      col1=getColor(getMaterial(mrefl),posr);\n      col1 *=(1.0+softshadow(posr, lig, 0.02, 2.5));\n    }\n    if (material.transparency>0.) {//refraction\n      Intersection intersrefr=trace(pos, refr, 0.002, 10.0-t);\n      float trefr= intersrefr.dist;\n      Material mrefr=intersrefr.material;\n      vec3 posr=pos+trefr*refr;\n      col2=getColor(mrefr,posr);\n      //if(mrefr==material3){\n            //trefr /= 3.0;\n  \t\t\t//col2 *= exp( -0.15*trefr*trefr );\n        //} \n      col2*=(1.0+softshadow(posr, lig, 0.02, 2.5));\n      float beers=(1.0-material.transparency)*intersrefr.thickness;\n      col2*=vec3(pow(material.baseColor.x,beers),pow(material.baseColor.y,beers),pow(material.baseColor.z,beers));\n    }\n    col1=col2*(1.0-fresnel)+material.reflectivity*col1*(fresnel);\n    \n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif =clamp( dot( nor, lig ), 0.0, 1.0 );\n    float spe = pow(clamp( dot( normalize(-rd + lig),nor ), 0.0, 1.0 ), 40.0*material.spec);\n    dif *= softshadow( pos, lig, 0.02, 2.5 )*(1.-material.transparency);\n    vec3 brdf = vec3(0.0);\n    brdf += dif;//*material.transparency;\n    brdf += 1.30*spe*vec3(1.00);\n    brdf += 0.80*amb*vec3(1.)*occ;\n    brdf += 0.40*fresnel*vec3(1.00)*occ;\n    col = col*brdf;\n    col+=col1;\n    col = mix( col, vec3(0.8, 0.9, 1.0), 1.0-exp( -0.0005*t*t ) );\n  } else t /= 15.0;\n  col *= exp( -0.015*t*t );\n\n  return vec3( clamp(col, 0.0, 1.0) );\n}  \n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 q = gl_FragCoord.xy/iResolution.xy;\n  vec2 p = -1.0+2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  vec2 mo = .5-iMouse.xy/iResolution.xy;\n  float time = 15.0 + iTime;\n\n  // camera  \n  vec3 ro = vec3(6.0*sin(2.0*mo.x*PI)*(mo.y+.7),1., 6.0*cos(2.0*mo.x*PI)*(mo.y+.7));\n  vec3 ta = vec3( -1., .5, 0.0 );\n  // camera-to-world transformation\n  mat3 ca = setCamera( ro, ta, 0.0 );\n\n  // ray direction\n  vec3 rd =  normalize( ca *vec3(p.xy, 2.0) );\n\n  // render  \n  vec3 col = render( ro, rd );\n\n  col = pow( col, vec3(0.445) );\n  fragColor=vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}