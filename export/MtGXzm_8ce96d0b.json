{"ver":"0.1","info":{"id":"MtGXzm","date":"1483592542","viewed":616,"name":"Glittery Bouncy Ball","username":"demofox","description":"Using raytracing to make a bouncy ball which has glitter in it. The glitter is randomly distributed inside the sphere so is a white noise distribution and can have clumping.  Could be macro and micro optimized but just experimenting with the look.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","ball","sparkle","glint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n\n#define REFRACTIONRATIO 0.9  // the ratio of refraction index of the air to the marble.\n#define NUMGLINTS 100        // how many sparkles are inside the marble\n#define GLINTSIZE 0.025   \t // the size of the glint quads\n#define FOGDENSITY 0.7       // the fog density in the ball\n#define FOGCOLOR vec3(0.3, 0.05, 1.0)  // the fog color inside the ball\n\n//For a sparkly marble look, try these values instead, but prepare for much worse framerate!\n/*\n#define REFRACTIONRATIO 0.9\n#define NUMGLINTS 2000 \n#define GLINTSIZE 0.01\n#define FOGDENSITY 8.7\n#define FOGCOLOR vec3(0.3, 0.05, 1.0)\n*/\n\n//----------------------------------------------------------------------------------------\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\tvec3 rdd = rayDirection;\n\tvec3 roo = rayOrigin;\n\n\t// ray-box intersection\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxHalfSizes;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\tvec3 normal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n\t// texture coordinates \n\tvec3 uaxis = vec3(1.0,0.0,0.0);\n\tvec3 vaxis = vec3(0.0,1.0,0.0);\n\t\n\tif (abs(normal.x) > 0.9)\n\t{\n\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\n\t}\n\telse if (abs(normal.y) > 0.9)\n\t{\n\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\t\t\n\t}\n    \n    vec3 relPoint = roo + rdd * timeNear;\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis) * 0.25,\n\t\tdot(relPoint, vaxis) * 0.25\n\t);    \n\n\treturn vec4( timeNear, normal );\n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    float checkerboard = mod(floor(uv.x * 16.0) + floor(uv.y * 16.0), 2.0) < 1.0 ? 1.0 : 0.4;\n    return vec3(checkerboard);//, 0.0, 0.0);\n}\n\n//============================================================\nvec3 LightPixel (vec3 diffuse, vec3 rayDir, vec3 normal, float specPower)\n{\n    vec3 lightAmbient\t\t\t\t= vec3(0.01);\n    vec3 directionalLightReverseDir = normalize(vec3(1.0,2.0,1.0));\n    vec3 directionalLightColor = vec3(1.0);\n    \n    vec3 pixelColor = diffuse * lightAmbient;\n    float dp = clamp(dot(normal, directionalLightReverseDir), 0.0, 1.0);\n    pixelColor += diffuse * dp * directionalLightColor;\n    vec3 reflection = reflect(directionalLightReverseDir, normal);\n    dp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\tpixelColor += directionalLightColor * pow(dp, specPower);    \n    return pixelColor;\n}\n\n//============================================================\nvec3 LightPixelGlint (vec3 spec, vec3 rayDir, vec3 normal, float specPower)\n{\n    vec3 light0 = normalize(vec3(1.0,2.0,1.0));\n    vec3 light1 = normalize(cross(light0, vec3(0.0, 1.0, 0.0)));\n    vec3 light2 = normalize(cross(light0, light1));\n\n    vec3 reflection = reflect(light0, normal);\n    float dp = abs(dot(rayDir, reflection));\n\tvec3 pixelColor = pow(dp, specPower) * spec;\n    \n    reflection = reflect(light1, normal);\n    dp = abs(dot(rayDir, reflection));\n\tpixelColor += pow(dp, specPower) * spec;    \n    \n    reflection = reflect(light2, normal);\n    dp = abs(dot(rayDir, reflection));\n\tpixelColor += pow(dp, specPower) * spec;     \n    \n    return pixelColor;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    float fogAmount = 0.0;\n        \n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.5, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    rayInfo = RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(vec3(0.1), rayDir, rayInfo.yzw, 40.0);\n\n        // move the ray to be just inside the sphere and refract the ray direction\n        rayPos += rayDir * (rayInfo.x + 0.01);\n        rayDir = refract(rayDir, rayInfo.yzw, REFRACTIONRATIO);\n        \n        // reset the best hit info so we can test only against the glints\n        bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);       \n        \n        // ray trace the glints\n        for (int i = 0; i < NUMGLINTS; ++i)\n        {      \n        \tvec3 plane = normalize(hash32(vec2(float(i), float(i)*1.337)));\n            vec3 offset = (hash32(vec2(float(i)*1.756, float(i)*1.534)) * 2.0 - 1.0) * 0.4;\n            vec3 glintColor = hash32(vec2(float(i)*5.362, float(i)*9.253)) * 10.0;\n        \trayInfo = RayIntersectPlane(rayPos + offset, rayDir, vec4(plane, 0.0), uv);\n\n        \tif (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x && abs(uv.x) < GLINTSIZE*0.5 && abs(uv.y) < GLINTSIZE*0.5)\n            {\n                bestRayHitInfo = rayInfo;  \n                rayHitDiffuse = glintColor;\n            }\n        }\n        \n        // If we hit a glint, return the lit glint color\n        if (bestRayHitInfo.x < 1000.0)\n        {\n            fogAmount = 1.0 - exp( -FOGDENSITY * bestRayHitInfo.x );\n            vec3 glintColor = LightPixelGlint(rayHitDiffuse, rayDir, bestRayHitInfo.yzw, 10.0);\n            return mix(glintColor, FOGCOLOR, fogAmount) + additiveColor;\n        }\n        \n        // ray trace out the back of the sphere and refract the ray direction again by the inverse amount.\n        // Reset the best ray hit info so we can see if we hit anything\n        rayInfo = RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n        if(rayInfo.x >= 0.0)\n        {\n        \trayPos += rayDir * rayInfo.x;\n        \trayDir = refract(rayDir, rayInfo.yzw, 1.0 / REFRACTIONRATIO);    \n        \tbestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n        \trayHitDiffuse = vec3(0.0);     \n            \n            fogAmount = 1.0 - exp( -FOGDENSITY * rayInfo.x );\n        }\n        \n        // once outside of the sphere, need to test against platform again, after resetting the best ray hit info\n\t\trayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.5, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    \tif (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    \t{\n        \tbestRayHitInfo = rayInfo;\n        \trayHitDiffuse = Checkerboard(uv);\n    \t}        \n    }\n    \n    vec3 color;\n    if (bestRayHitInfo.x == 1000.0)    \n\t\tcolor = texture(iChannel0, rayDir).rgb;\n    else\n        color = LightPixel(rayHitDiffuse, rayDir, bestRayHitInfo.yzw, 100.0);\n    \n\n    return mix(color, FOGCOLOR, fogAmount) + additiveColor;\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = RayTracePixelColor(cameraPos, rayDir);\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n/*\n\nImprovement Ideas:\n* could try ray marching through a grid in the inside of the sphere and doing tests only against the glitter in each cell (fewer tests?)\n* make the code less branchy / explicit\n* make the LightPixelGlint code better - like take max of the 3 dps, make the glints \"flashier\", fake the math more for a similar result.\n* fresnel on ball surface\n\n*/\n","name":"Image","description":"","type":"image"}]}