{"ver":"0.1","info":{"id":"4c2Szz","date":"1705977504","viewed":95,"name":"basic spiral shader 19577448333","username":"HaleyHalcyon","description":"r","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["r"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is a shader in the GLSL programming language.\nIt’s most directly based on C, with a few additions and quirks.\n\n// It runs every pixel every frame\n\nThis code runs every time a pixel is drawn.\nYou have the current pixel position (vec2 fragCoord)\nthe canvas resolution (vec3 iResolution, z is pixel aspect ratio)\nand the current time (float iTime).\nYou can also choose to use the current frame (int iFrame)\nfor frame-perfect effects.\n\n// New data types\n\nIt has the vector data types vec2, vec3, vec4,\nthe integer vector data types ivec2~ivec4,\ntheir unsigned versions uvec2~uvec4,\nand matrix data types mat2x2~mat4x4.\n\nVectors can be used to store coordinates (xyzw)\nor colors (rgba). In fact, you can “swizzle” vectors\nto make address one element or combine them.\ne.g.: vec3 hueRotated = color.gbr;\n\nColors are defined with channel values\nfrom 0.0 to 1.0, not 0.0 to 255.0!\nI have a macro that lets you use hex codes,\nso if you find it useful, you can use it like:\nvec3 colorBg = HEX(0xFF4080);\n\n// Useful functions\n\nWhen making a basic, painting-based spiral shader,\nalways start by rescaling the pixel coordinates\nwith the center being the origin (0, 0).\nTo do this, you can do:\nvec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy)\nThis sets the center to (0, 0)\nand makes the distance from there to the corners\nequal to 1.\n\nTo get π, use acos(-1.).\nI recommend defining a const float\nthat stores 2π, named “TURN”.\n\nTo get the angle from the origin, use atan(y, x).\nThis will get you the number of radians from\ndirectly to the right.\nTo convert it to turns (as you may often want to do)\ndivide by 2π.\ne.g.: float theta = atan(uv.y, uv.x) / TURN;\n\nTo get the distance from the origin, use length(uv).\nThis gets linear distance, but often times\nyou may want to use log(length(uv))\nor 1. / length(uv) instead.\nlog(length) has the advantage that it’s self-similar,\nso zooming in is perfectly seamless.\n1. / length is more accurate to perspective,\nbut you need to a render distance fading effect,\nbecause without it, the center gets messy.\n\nSome useful functions you may encounter are:\n* step(threshold, x)\nif (threshold <= x) { return 1.0; } return 0.0;\n\n* mix(x1, x2, blending)\nBlends between x1 and x2 based on the blending ratio.\nIf that’s 0.0, x1 is returned; if that’s 1.0, x2 is returned.\nNote that blending may go below or 0 above 1!\n\n* smoothstep(toZero, toOne, x)\nApplies a smoothed step function to x,\nmapping `toZero` to 0.0 and `toOne` to 1.0.\nNumbers in between will get a sigmoid easing,\nwhile numbers out of that range will be 0 or 1.\n\n* fract(x) and mod(x, period)\nfract(x) throws away the integer portion of a float,\nmaking the range of [0, 1) repeat.\nmod(x, period) does the same, but for the range of [0, period).\n\n* sin(x), cos(x), and tan(x)\nThe trigonometric functions.\n\nA sample spiral is given below.\n*/\n\n#define HEX(x) vec3((ivec3(x)>>ivec3(16,8,0))&255)/255.\nconst float TURN = 2. * acos(-1.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime);\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    \n    float r = log(length(uv));\n    float theta = atan(uv.y, uv.x) / TURN;\n    \n    float spiral = fract(\n        1.36 * r\n        + 2. * theta\n        + 1. * t\n        // add bulging effect\n        + 0.25 * sin((\n            0.5 * r\n            + -1. * t\n        ) * TURN)\n    );\n    \n    vec3 col = mix(\n        mix(\n            HEX(0x80c0ff),\n            HEX(0xff80c0),\n            step(0.25, spiral)\n        ), mix(\n            HEX(0xffef80),\n            HEX(0xcccccc),\n            step(0.75, spiral)\n        ),\n        step(0.5, spiral)\n    );\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}