{"ver":"0.1","info":{"id":"7slSD4","date":"1618673571","viewed":54,"name":"547C3F01-575C-4F21-AE29-6A040C5D","username":"Ubsefor","description":"uuid: 77B02461-04FD-4371-A8AD-056ED7D1E67E by uuidgenâ„¢\nt.me/ubsefor\n\nMakhov A. M., 327 \nTask: 1, 0 => cube with fire inside.\nSee GSE comment for details of completed task","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["e47d49eef8ef413590180e14b769a4b7"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(1,4,8.8);\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nconst float PLANE_HEIGHT = -1.4;\n\nstruct Light {\n    vec3 pos;\n    float radius;\n    vec3 color;\n    float intensity;\n};\n\nconst int LIGHT_NUM = 2;\n\nLight Lights[LIGHT_NUM] = Light[LIGHT_NUM](\nLight(vec3(-1, 1.5, -3), 0.25, vec3(0.5, 0.5, 1), 30.0f),\nLight(vec3(1, 2, 1), 0.5, vec3(1, 0.5, 0.5), 20.0f));\n\nconst float CYL_RADIUS = 3.0;\nconst float CYL_SLOPE = 0.5;\nconst float CYL_HEIGHT = 0.5;\nconst vec3 CYL_BASE_POS = vec3(0, PLANE_HEIGHT + 0.001, 0);\n\nconst float AIR_N = 1.0;\nconst float GLASS_N = 1.5;\nconst float DIAMOND_N = 2.5;\n\nconst float BLUR_RATE = 0.05;\n//const float BLUR_RATE_2 = 0.0001;\n\nconst vec3 CUBE_COLOR = vec3(0.7, 0.7, 0.7);\nconst float CUBE_SIZE = 2.;\nconst vec3 CUBE_DIMS = vec3(0.0, -0.14, 0.0);\n\nvec3 RAND_DIR;\n\nfloat traceCubeSide1(vec3 pos, vec3 dir, float size, out vec3 norm) \n{ \n    float t1 = (-size / 2.0 - pos.z) / dir.z; \n    vec3 worldPos = t1 * dir + pos; \n\n    if ((t1 <= 0.0) || !((worldPos.x >= (-size / 2.0)) \n        && (worldPos.x <= (size / 2.0)) \n        && (worldPos.y >= (-size / 2.0)) \n        && (worldPos.y <= (size / 2.0)))) \n    { \n        //norm = vec3(0, 0, 0); \n        return INF; \n    } \n    norm = vec3(0, 0, -1); \n    return t1; \n} \n\nfloat traceCubeSide2(vec3 pos, vec3 dir, float size, out vec3 norm) \n{ \n    float t2 = (size / 2.0 - pos.z) / dir.z; \n    vec3 worldPos = t2 * dir + pos; \n\n    if ((t2 <= 0.0) || !((worldPos.x >= (-size / 2.0)) \n        && (worldPos.x <= (size / 2.0)) \n        && (worldPos.y >= (-size / 2.0)) \n        && (worldPos.y <= (size / 2.0)))) \n    { \n        //norm = vec3(0, 0, 0); \n        return INF; \n    } \n    norm = vec3(0, 0, 1); \n    return t2; \n} \n\nfloat traceCubeSide3(vec3 pos, vec3 dir, float size, out vec3 norm) \n{ \n    float t3 = (-size / 2.0 - pos.x) / dir.x; \n    vec3 worldPos = t3 * dir + pos; \n    if ((t3 <= 0.0) || !((worldPos.z >= (-size / 2.0)) \n        && (worldPos.z <= (size / 2.0)) \n        && (worldPos.y >= (-size / 2.0)) \n        && (worldPos.y <= (size / 2.0)))) \n    { \n        //norm = vec3(0, 0, 0); \n        return INF; \n    } \n    norm = vec3(-1, 0, 0); \n    return t3; \n} \n\nfloat traceCubeSide4(vec3 pos, vec3 dir, float size, out vec3 norm) \n{ \n    float t4 = (size / 2.0 - pos.x) / dir.x; \n    vec3 worldPos = t4 * dir + pos; \n    if ((t4 <= 0.0) || !((worldPos.z >= (-size / 2.0)) \n    && (worldPos.z <= (size / 2.0)) \n    && (worldPos.y >= (-size / 2.0)) \n    && (worldPos.y <= (size / 2.0)))) \n    { \n        //norm = vec3(0, 0, 0); \n        return INF; \n    } \n    norm = vec3(1, 0, 0); \n    return t4; \n} \n\nfloat traceCubeSide5(vec3 pos, vec3 dir, float size, out vec3 norm) \n{ \n    float t5 = (-size / 2.0 - pos.y) / dir.y; \n    vec3 worldPos = t5 * dir + pos; \n    if ((t5 <= 0.0) || !((worldPos.x >= (-size / 2.0)) \n    && (worldPos.x <= (size / 2.0)) \n    && (worldPos.z >= (-size / 2.0)) \n    && (worldPos.z <= (size / 2.0)))) \n    { \n        //norm = vec3(0,0,0);\n        return INF; \n    } \n    norm = vec3(0, -1, 0); \n    return t5; \n} \n\nfloat traceCubeSide6(vec3 pos, vec3 dir, float size, out vec3 norm) \n{ \n    float t6 = (size / 2.0 - pos.y) / dir.y; \n    vec3 worldPos = t6 * dir + pos; \n    if ((t6 <= 0.0) ||!((worldPos.x >= (-size / 2.0)) \n    && (worldPos.x <= (size / 2.0)) \n    && (worldPos.z >= (-size / 2.0)) \n    && (worldPos.z <= (size / 2.0)))) \n    { \n        //norm = vec3(0,0,0);\n        return INF; \n    } \n    norm = vec3(0, 1, 0); \n    return t6; \n} \n\nfloat traceCube(vec3 pos, vec3 dir, float size, float t, out vec3 norm) \n{ \n    vec3 cubeNorm1; \n    vec3 cubeNorm2; \n    vec3 cubeNorm3; \n    vec3 cubeNorm4; \n    vec3 cubeNorm5; \n    vec3 cubeNorm6; \n\n    float cubePlane2 = traceCubeSide2(pos, dir, size, cubeNorm2); \n    if (cubePlane2 < t) \n    { \n        t = cubePlane2; \n        norm = cubeNorm2; \n    } \n    float cubePlane4 = traceCubeSide4(pos, dir, size, cubeNorm4); \n    if (cubePlane4 < t) \n    { \n        t = cubePlane4; \n        norm = cubeNorm4; \n    } \n    float cubePlane5 = traceCubeSide5(pos, dir, size, cubeNorm5); \n    if (cubePlane5 < t) \n    { \n        t = cubePlane5; \n        norm = cubeNorm5; \n    } \n    float cubePlane1 = traceCubeSide1(pos, dir, size, cubeNorm1); \n    if (cubePlane1 < t) \n    { \n        t = cubePlane1; \n        norm = cubeNorm1; \n    } \n    float cubePlane3 = traceCubeSide3(pos, dir, size, cubeNorm3); \n    if (cubePlane3 < t) \n    { \n        t = cubePlane3; \n        norm = cubeNorm3; \n    } \n\n    float cubePlane6 = traceCubeSide6(pos, dir, size, cubeNorm6); \n    if (cubePlane6 < t) \n    { \n        t = cubePlane6; \n        norm = cubeNorm6; \n    } \n    return t; \n}\n\nfloat tracePlane(vec3 pos, vec3 dir, float height, out vec3 normal) {\n    float t = (height  - pos.y) / dir.y;\n    if (t <= 0.0) return INF;\n    vec3 worldPos = pos + t * dir;\n    if (dot(worldPos.xz, worldPos.xz) >= 50.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal, bool rand) {\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    if (rand) {\n        c = dot(pos, pos) - pow2(r + RAND_DIR.x * 1.);\n    }\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, float radius, float height, out vec3 normal) {\n    float t = INF;\n    vec3 worldPos;\n    float curT = (height - pos.y) / dir.y;\n    if (t > curT && curT > 0.0) {\n        worldPos = curT * dir + pos;\n        if (dot(worldPos.xz, worldPos.xz) <= radius) {\n            normal = vec3(0, 1, 0);\n            t = curT;\n        }\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - radius;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    curT = (-b - sqrt(D)) / a;\n    if (t > curT && curT > 0.0) {\n        worldPos = curT * dir + pos;\n        if (worldPos.y <= height) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            t = curT;\n        }\n    }\n    curT = (-b + sqrt(D)) / a;\n    if (t > curT && curT > 0.0) {\n        worldPos = curT * dir + pos;\n        if (worldPos.y <= height) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            t = curT;\n        }\n    }\n    return t;\n}\n\nvec3 OcculedLight(vec3 pos, vec3 target, float t) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    vec3 res = vec3(1, 1, 1);\n   \n    vec3 cylNorm;\n    float cylT = traceCylinder(pos - CYL_BASE_POS, dir, CYL_RADIUS, CYL_HEIGHT, cylNorm);\n    if (cylT < dist) res *= vec3(0);\n    \n    // cannot occule fire instance because its based on random radius value, meaning\n    // that my intel graphics card will toast itself :(\n\n    return res;\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal, float t) {\n    vec3 intensity = texture(iChannel1, normal).rgb * 0.1;\n    \n    for (int i = 0; i < LIGHT_NUM; i++) {\n        vec3 toLight = Lights[i].pos - pos;\n        vec3 attr = OcculedLight(pos, Lights[i].pos \n            + RAND_DIR * Lights[i].radius, t) \n            * Lights[i].intensity / dot(toLight, toLight);\n        intensity += attr * max(0.0, dot(normal, normalize(toLight))) * Lights[i].color;\n    }\n    \n    return color * intensity;\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2, out bool isReflected) {\n\n    isReflected = false;\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0) {\n        isReflected = true;\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\tuv *= res;\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\tvec3 f = fract(uv); \n\tf = f*f*(3.0-2.0*f);\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t              uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec3 burn (vec2 p) \n{\n\tfloat color1 = 4.0 - (3.*length(2.5*p));\n    \n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\tfor(int i = 1; i <= 3; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor1 += 0.5*(1.5 / power) * snoise(coord + vec3(0.,.05, .01), power*16.);\n\t}\n\tcolor1 *= 0.6;\n\treturn vec3( color1, pow(max(color1,0.),2.)*0.4, pow(max(color1,0.),3.)*0.10);\n}\n\n\nvec3 drawFire(vec2 p) {\n  return mix(vec3(1.,1.,1.), burn(p), 0.7);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    RAND_DIR = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)*2.) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float n1 = AIR_N;\n    float n2 = DIAMOND_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    const float DIAMOND_N = 2.5;\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    \n    bool isReflected = false;\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < LIGHT_NUM; i++) {\n        Lights[i].pos = Lights[i].pos + vec3(0, 1, 0) * randVals.x * BLUR_RATE;\n    }\n    \n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, PLANE_HEIGHT + normalize(randVals.x)* BLUR_RATE, planeNorm);\n        if (planeT < t) {\n            t = planeT; \n            normal = planeNorm;\n            vec3 worldPos = curPos + t * curDir;\n            if (randVals.z < 0.1) {\n                materialType = REFLECTION;\n                color = vec3(1, 1, 1);\n            } else {\n                materialType = DIFFUSE;\n                color = texture(iChannel0, worldPos.xz * 1.0).rgb;\n            }\n        }\n        vec3 lightNorm;\n        float lightT;\n        for (int i = 0; i < LIGHT_NUM; i++) {\n            lightT = traceSphere(curPos - Lights[i].pos, curDir, Lights[i].radius, lightNorm, false);\n            if (lightT < t) {\n                t = lightT;\n                normal = lightNorm;\n                materialType = EMISSION;\n                vec3 worldPos = curPos + t * curDir;\n                color = Lights[i].color;// * texture(iChannel3, worldPos.xz * 0.2).rgb;\n            }\n        }\n        \n        vec3 cubeNorm;\n        \n        float cubeT = traceCube(curPos + vec3(0, 1, 0) * randVals.x * BLUR_RATE, curDir, CUBE_SIZE, t, cubeNorm);\n        if (cubeT < t) {\n            t = cubeT;\n            normal = cubeNorm;\n            vec3 worldPos = curPos + t * curDir;\n            if (randVals.x * 0.7 < GLASS_R) {\n                materialType = REFLECTION;\n                \n            } else {\n                materialType = REFRACTION;\n                \n            }\n            \n            color = CUBE_COLOR;\n        }\n        \n        vec3 fireNorm;\n        float fireT = traceSphere(curPos + vec3(0, 1, 0) * randVals.x * BLUR_RATE, curDir, 0.5, fireNorm, true);\n        if (fireT < t) {\n            t = fireT;\n            normal = fireNorm;\n            vec3 worldPos = t * curDir + curPos;\n            color = drawFire(uv * sqrt(dot(CAMERA_POS, CAMERA_POS) / 45.0) * 3.35);\n            materialType = EMISSION;\n        }\n        \n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos - CYL_BASE_POS, curDir, CYL_RADIUS + normalize(randVals.x)* BLUR_RATE, CYL_HEIGHT + normalize(randVals.x)* BLUR_RATE, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            normal = cylNorm;\n            vec3 worldPos = curPos + t * curDir;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n        } \n        if (t != INF) {\n            vec3 worldPos = curPos + t * curDir;\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal, t) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n                colorMult = colorMult * color;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, n2, isReflected);\n                colorMult = color;\n                curPos = worldPos + curDir * 1e-5;\n                if (!isReflected) {\n                    float swap = n1;\n                    n1 = n2;\n                    n2 = swap;\n                }\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}