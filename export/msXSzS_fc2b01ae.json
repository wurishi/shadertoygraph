{"ver":"0.1","info":{"id":"msXSzS","date":"1669127885","viewed":96,"name":"SimulateRaymarching","username":"Mario8664","description":"Simulate raymarching in 2d.\nClick and drag to make ray.\nW/S key to increase or decrease marching count.\n\n#define AVGSTEP to use the same step but not sdf step","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["sdf2d","raymarching2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define UNIT 0.001\n#define MAXITER 64.0\n#define STEP 0.01\n\n#define KEY_W 87\n#define KEY_S 83\n\n//#define AVGSTEP\n#define DRAW","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//input buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if(uv.x < 0.5)\n    {\n        if(iFrame == 0)\n        {\n            fragColor = vec4(0.0);\n        }\n        else\n        {\n            if(iMouse.w > 0.5)\n            {\n                fragColor = vec4(iMouse.xy / iResolution.y + iResolution.y / iResolution.xy - 1.0, 0.0, 0.0);\n            }\n            else\n            {\n                fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n            }\n        }\n    \n    }\n    else\n    {\n        if(iFrame == 0)\n        {\n            fragColor = vec4(8.0 / MAXITER);\n        }\n        else\n        {\n            float ws = texture(iChannel0, fragCoord / iResolution.xy).x;\n            float wsInput = texelFetch(iChannel1, ivec2(KEY_W,1), 0).r - texelFetch(iChannel1, ivec2(KEY_S,1), 0).r;\n            ws = ws * MAXITER + wsInput;\n            ws = clamp(ws, 1.0, MAXITER);\n            ws /= MAXITER;\n            fragColor = vec4(ws);\n        }\n    \n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float sdCircle(vec2 pos, vec2 uv, float r)\n{\n    return distance(uv, pos) - r;\n}\n\nfloat sdBox(vec2 pos, vec2 uv, vec2 s)\n{\n    vec2 p = abs(uv - pos);\n    vec2 q = max(p - s, 0.0);\n    return length(q);\n}\n\nfloat sdTriangle(vec2 pos, vec2 uv, vec2 p0, vec2 p1, vec2 p2 )\n{\n    vec2 p = uv - pos;\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdf(vec2 uv)\n{\n    float b1 = sdBox(vec2(0.5), uv, vec2(0.1));\n    float c1 = sdCircle(vec2(0.8), uv, 0.2);\n    float c2 = sdCircle(vec2(0.1, 0.8), uv, 0.2);\n    float t1 = sdTriangle(vec2(0.0, 0.2), uv, vec2(0.0, 0.3), vec2(0.1, 0.1), vec2(-0.1, 0.1));\n    float d = min(b1, c1);\n    d = min(d, c2);\n    d = min(d, t1);\n    return d;\n}\n\nfloat marchCircle(vec2 pos, vec2 uv)\n{\n    float dm = sdf(pos);\n    float c = length(pos - uv) - dm;\n    c = 1.0 - c;\n    c = floor(c) - clamp(floor(c - 0.005), 0.0, 1.0);\n    return clamp(c, 0.0, 1.0);\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    float h = dot(ap, ab) / dot(ab, ab);\n    h = clamp(h, 0.0, 1.0);\n    \n    float d = length(ap - h * ab);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sdfuv = fragCoord / iResolution.y + iResolution.y / iResolution.xy - 1.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float drawSurface;\n    if(iFrame == 0)\n    {\n        drawSurface = 0.0;\n    }\n    else\n    {\n        drawSurface = texture(iChannel1, uv).a;\n    }\n    \n    float d = sdf(sdfuv);\n    vec4 col = vec4(d);\n    \n    vec2 ro = texture(iChannel0, vec2(0.25)).rg;\n    vec2 pos = ro;\n    float t = 0.0;\n    vec2 m = iMouse.xy / iResolution.y + iResolution.y / iResolution.xy - 1.0;\n    vec2 rd = m - ro;\n    if(length(rd) < 0.0001)\n    {\n        d = ceil(d);\n        drawSurface = 0.0;\n        fragColor = vec4(d, d, d, drawSurface);\n        return;\n    }\n    rd = normalize(rd);\n    \n    float c = 0.0;\n    float cr = 0.0;\n    float cb = 0.0;\n    int iter = int(texture(iChannel0, vec2(0.75)).r * MAXITER);\n    for(int i = 0; i < iter; i++)\n    {\n        float dd = sdf(pos);\n        //draw\n#ifdef AVGSTEP\n        float mc = 0.0;\n#else\n        float mc = marchCircle(pos, sdfuv);\n#endif\n        float draw = max(mc, ceil(1.0 - length(sdfuv - pos) - 0.99));\n        \n        c = max(c, draw * float(i + 1) / float(iter + 1));\n        if(dd < 0.001)\n        {\n            vec2 o = vec2(-0.02, 0.02);\n            cr = sdLine(sdfuv, pos + o.xx, pos + o.yy);\n            cr = min(cr, sdLine(sdfuv, pos + o.xy, pos + o.yx));\n            cr = 1.0 - floor(cr + 0.995);\n            \n            \n            drawSurface = max(drawSurface, ceil(1.0 - length(sdfuv - pos) - 0.995));\n            \n            break;\n        }\n#ifdef AVGSTEP\n        t += STEP;\n#else\n        t += dd;\n#endif\n        pos = ro + rd * t;\n    }\n    \n    vec2 o = vec2(-0.01, 0.01);\n    cb = sdLine(sdfuv, pos + o.xx, pos + o.yy);\n    cb = min(cb, sdLine(sdfuv, pos + o.xy, pos + o.yx));\n    cb = clamp(1.0 - floor(cb + 0.994), 0.0, 1.0);\n    \n    float line = sdLine(sdfuv, ro, pos);\n    line = floor(line + 0.998);\n    //c = max(c, line);\n    \n    d = ceil(d);\n    \n    // Output to screen\n    vec3 ddd = vec3(d);\n    c = clamp(c, 0.0, 1.0);\n    vec3 ccc = vec3(1.0, 1.0 - c, 1.0 - c) * line;\n    ccc = mix(ddd * ccc, vec3(1.0, 0.8, 0.0), cb);\n#ifdef DRAW\n    ccc = mix(ccc, vec3(0.5, 0.8, 0.2), drawSurface);\n#endif\n    cr = clamp(cr, 0.0, 1.0);\n    ccc = mix(ccc, vec3(pos, 1.0), cr);\n    fragColor = vec4(ccc,drawSurface);\n}","name":"Buffer B","description":"","type":"buffer"}]}