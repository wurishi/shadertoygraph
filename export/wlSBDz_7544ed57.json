{"ver":"0.1","info":{"id":"wlSBDz","date":"1598883105","viewed":93,"name":"Pulsing rods","username":"nicoleslaw","description":"Another learning experience.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["rods","hyperbolicparaboloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n//----------------------- FUNCTIONS -----------------------//\n\n/*\n * Get the 4x4 rotation matrix for rotating about <axis> by angle <theta> in radians.\n */\nmat4 rotation_about_axis(vec3 axis, float theta) {\n    \n    axis = normalize(axis);\n    float x = axis.x; float y = axis.y; float z = axis.z;\n    mat4 R = mat4(x*x+(1.0-x*x)*cos(theta),\n                  x*y*(1.0-cos(theta))-z*sin(theta),\n                  x*z*(1.0-cos(theta))+y*sin(theta), 0.0,\n                  y*x*(1.0-cos(theta))+z*sin(theta),\n                  y*y+(1.0-y*y)*cos(theta),\n                  y*z*(1.0-cos(theta))-x*sin(theta), 0.0,\n                  z*x*(1.0-cos(theta))-y*sin(theta),\n                  z*y*(1.0-cos(theta))+x*sin(theta),\n                  z*z+(1.0-z*z)*cos(theta), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    return R;\n}\n\n\nfloat bump(float d) {\n    return 1.0/(1.0 + sqrt(d));\n}\n\nfloat dist_from_line(vec2 p, vec2 A, vec2 B) {\n    float x0 = p.x; float y0 = p.y;\n    float x1 = A.x; float y1 = A.y;\n    float x2 = B.x; float y2 = B.y;\n    return abs((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)/sqrt((y2-y1)*(y2-y1) + (x2-x1)*(x2-x1));\n}\n\n//----------------------- SCENE -----------------------//\n\n/*\n * Signed distance function for a sphere centered at the <origin> with radius <radius>.\n */\nfloat sphereSDF(vec3 sample_point, vec3 origin, float radius) {\n    return length(sample_point - origin) - radius;\n}\n\n/*\n * Signed distance function for a capsule with origin <a>, endpoint <b>, and radius <r>.\n * https://iquilezles.org/articles/distfunctions\n */\nfloat capsule_SDF( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n/*\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 sample_point) {\n    /*\n    float dist = 1e5; int N = 10; float L = 2.0;\n    for (int i=0; i < N; i++) {\n        vec3 src = vec3(cos(2.0*PI*float(i)/float(N)), sin(2.0*PI*float(i)/float(N)), 0.0);\n        vec3 dst = L*vec3(cos(2.0*PI*float(i+1)/float(N)), sin(2.0*PI*float(i+1)/float(N)), 0.0);\n        vec3 diff = dst - src;\n        src -= diff*0.5; dst -= diff*0.5;\n        dist = min(dist, capsule_SDF(sample_point, src, dst, 0.1));\n    }\n    return dist;\n\t*/\n    \n    float dist=1e5; float l = 0.5;\n    int N = 5; float r = 0.1;\n    for (int i=-N; i < N; i++) {\n        for (int j=-N; j < N; j++) {\n            float x = float(i);\n            float y = float(j);\n            float z = float(i*j);\n            //dist = min(dist, sphereSDF(sample_point, vec3(x,y,z), r));\n            float t = iTime*0.7;\n            vec3 src;\n            vec3 dst;\n            if (-sin(t) > 0.0) {\n                src = vec3(x-(l*sin(t)),y-(l*sin(t)),(x-(l*sin(t)))*(y-(l*sin(t))));\n            \tdst = vec3(x+(l*sin(t)),y+(l*sin(t)),(x+(l*sin(t)))*(y+(l*sin(t))));\n            }\n            else {\n                src = vec3(x-(l*sin(t)),y+(l*sin(t)),(x-(l*sin(t)))*(y+(l*sin(t))));\n                dst = vec3(x+(l*sin(t)),y-(l*sin(t)),(x+(l*sin(t)))*(y-(l*sin(t))));\n            }\n            dist = min(dist, capsule_SDF(sample_point, src, dst, 0.05));\n        }\n    }\n    return dist;\n}\n\n\n/*\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/*\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//----------------------- Lighting functions -----------------------//\n\n\n/*\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\n/*\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p); // vector from point on surface to the light\n    vec3 V = normalize(eye - p); // vector from camera to point on surface\n    vec3 R = normalize(reflect(L, N));\n    \n    float dotLN = max(0.0, dot(N, L));\n    float dotRV = max(0.0, dot(R, V));\n\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\n/*\n * Lighting (using Phong illumination in this example.)\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n */\nvec3 lighting(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    \n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);  \n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0, 2.0, 4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0,2.0,2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);\n    \n    return color;\n}\n\n//----------------------- MAIN -----------------------//\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Determine the direction to ray march along.\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    // Location of the camera (eye).  \n    vec3 eye = vec3(0.0, 0.0, 20.0); \n    // Rotate the camera and view direction.\n    mat4 R = rotation_about_axis(vec3(1,-1,0), 2.0*PI*iTime*0.0);\n    eye = (R*vec4(eye,1.0)).xyz;\n    dir = (R*vec4(dir,1.0)).xyz;\n    \n    // Do ray-marching.\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0); // background\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    // Compute lighting at that point.\n    vec3 k_a = vec3(1.0, 0.7, 0.2); // ambient \n    vec3 k_d = vec3(0.9, 0.2, 0.7); // diffuse\n    vec3 k_s = vec3(1.0, 1.0, 1.0); // specular\n    float shininess = 5.0;\n    vec3 color = lighting(k_a, k_d, k_s, shininess, p, eye);\n    \n    // Add \"flashes of white light\"\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime/0.7; float travel = 7.0*sin(0.5*t-PI/2.0);\n    vec2 A = vec2(1.0+travel, travel); vec2 B = vec2(travel, 1.0+travel);\n    float pulse = dist_from_line(uv, A, B); pulse = 1.0/(1.0+pow(pulse,10.0));\n    color += vec3(pulse, pulse, pulse);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}