{"ver":"0.1","info":{"id":"NtyXzV","date":"1640995418","viewed":135,"name":"Segmented Torus Knot","username":"PGRacer","description":"TY to IWBTShyGuy (https://www.shadertoy.com/user/IWBTShyGuy) for helping me clean up some errors!\n\nBased off BigWIngs Torus Knot tutorial - https://www.shadertoy.com/view/ttXBzB","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","knot","twisted"],"hasliked":0,"parentid":"slVXDz","parentname":"PGRacer - Raymarching Template"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////\n// IMAGE SHADER //\n//////////////////\n\n// Define Objects Here - Based off BigWIngs Torus Knot Tutorial - https://www.shadertoy.com/view/ttXBzB\nfloat SubGetDist(vec3 p, vec3 q)\n{\n    float segmentation = 10.0;\n    float errorCorrection = 0.25;\n    float rotations = 4.0; // Multiples of two cause the tori to self-align at end cycle\n    \n    //segmentation = nsin(TIME) * segmentation; // uncomment to see segmentation change with time\n    \n    float r1 = 1.0, r2 = .1;\n    vec2 cp = vec2(length(p.xz)-r1, p.y);\n    float angle = atan(q.x, q.z) * segmentation;\n    angle = rotations * (angle - mod(angle, PI / 2.0)); // segmentation - comment out this line to see smooth twist\n    \n    cp = Rot2(nsin(TIME) * angle) * cp;\n    cp.y = abs(cp.y) - r2;\n    \n    float d = length(cp) - r2;\n    \n    return d * errorCorrection;\n}\n\nfloat GetDist(vec3 p)\n{\n    return SubGetDist(p, p);\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 e = vec2(NORMAL_CHECK_OFFSET, 0);\n\tvec3 n = vec3(\n\t\tSubGetDist(p + e.xyy, p) - SubGetDist(p - e.xyy, p),\n\t\tSubGetDist(p + e.yxy, p) - SubGetDist(p - e.yxy, p),\n\t\tSubGetDist(p + e.yyx, p) - SubGetDist(p - e.yyx, p)\n\t\t);\n\treturn normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Keep outline width same in full screen\n    float outlineWidth = OUTLINE_WIDTH / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    float vignette = smoothstep(0.9, 0.001, length(uv));\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    // Camera Stuff\n    vec3 camPos = vec3(0.0, 1.0, -2.0);\n    \n    mat3x3 rotMat = Rot3(-PI / 5.25, RIGHT);\n    vec3 camDir = rotMat * normalize(vec3(uv.x, uv.y, 1.0));\n    \n    // Do raymarching\n    float dO = 0.0;\n\tvec3 p;\n\tbool hit = false;\n\tbool outline = false;\n    float prevDist = MAX_DIST * MAX_DIST;\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tp = camPos + camDir * dO;\n\t\tfloat d = GetDist(p);\n\t\tdO += d;\n\n\t\tif (!outline && d < outlineWidth * (log2(dO + 1.0)) + SURF_DIST)\n\t\t{\n\t\t\toutline = true;\n\t\t}\n\n\t\tif (dO > MAX_DIST)\n\t\t{\n            outline = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (d <= SURF_DIST)\n\t\t{\n            hit = true;\n            outline = false;\n\t\t\tbreak;\n\t\t}\n        \n        // If at any point we've gotten within the thickness of our outline and \n        // then we get further away from a hit we break out and draw the outline\n        if (outline && prevDist < d)\n        {\n            break;\n        }\n        \n        prevDist = d;\n\t}\n    \n    vec3 col;\n    vec3 bgcol = mix(vec3(0.0), vec3(1.0, 1.0, 1.0), smoothstep(-1.0, -.25, -abs(camDir.y)));\n    \n    if (hit)\n    {\n        vec3 normal = GetNormal(p);\n        vec3 absNormal = abs(normal);\n        col = vec3(\n            pow(absNormal.x, COLOR_SEPARATION),\n            pow(absNormal.y, COLOR_SEPARATION),\n            pow(absNormal.z, COLOR_SEPARATION)\n        );\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, -0.5));\n        float scalar = dot(lightDir, normal);\n        scalar = clamp(scalar, 0.0, 1.0);\n        scalar *= LIGHT_POWER;\n        scalar = (scalar + 1.0) / 2.0;\n        col *= scalar;\n        float distRatio = dO / MAX_DIST;\n        col = mix(col, bgcol, distRatio);\n    }\n    else if (outline)\n    {\n        col = vec3(0.0);\n        col = mix(bgcol, col, smoothstep(MAX_DIST, 0.0, dO));\n    }\n    else\n    {\n        col = bgcol;\n    }\n    \n    // Fade scene in at start\n    col *= smoothstep(FADE_IN_DELAY, FADE_IN_DELAY + FADE_IN_LENGTH, iTime);\n    col *= vignette;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////\n// COMMON FUNCTIONS AND VALUES //\n/////////////////////////////////\n\n// RAYMARCHING\n#define MAX_STEPS 500\n#define MAX_DIST 10.0\n#define SURF_DIST 0.001\n#define NORMAL_CHECK_OFFSET 0.01\n\n// OUTLINE\n#define OUTLINE_WIDTH 1.0\n\n// LIGHTING\n#define COLOR_SEPARATION 3.0\n#define LIGHT_POWER 3.0\n\n// TIMING\n#define TIME iTime * 0.25\n\n// SCENE START\n#define FADE_IN_DELAY 0.1\n#define FADE_IN_LENGTH 1.0\n\n// COMMON CONSTANTS\n#define PI 3.141592\n\n// VECTORS\n#define FORWARD vec3(0.0, 0.0, 1.0)\n#define BACKWARD vec3(0.0, 0.0, -1.0)\n#define LEFT vec3(-1.0, 0.0, 0.0)\n#define RIGHT vec3(1.0, 0.0, 0.0)\n#define UP vec3(0.0, 1.0, 0.0)\n#define DOWN vec3(0.0, -1.0, 0.0)\n\n// MOUSE CLICK STATES\nbool IsNewClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y < 1.0;\n}\n\nbool IsPersistentClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y > 0.0;\n}\n\nbool IsNewRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y > 0.0;\n}\n\nbool IsPersistentRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y < 1.0;\n}\n\nbool ReadKey(sampler2D sampler, int key, bool toggle)\n{\n\treturn textureLod(sampler, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x > 0.0;\n}\n\n// MATRICES\nmat2x2 Rot2(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\n\nmat3x3 Rot3(float angle, vec3 axis)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n\n\tfloat t = 1.0 - c;\n\tfloat x = axis.x;\n\tfloat y = axis.y;\n\tfloat z = axis.z;\n\n\treturn mat3x3\n\t(\n        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,\n\t\tt * x * y + s * z,  t * y * y + c,      t * y * z - s * x,\n\t\tt * x * z - s * y,  t * y * z + s * x,  t * z * z + c\n\t);\n}\n\n// USEFUL MATH STUFF\nfloat AvgComponentLength(vec3 v)\n{\n    return (abs(v.x) + abs(v.y) + abs(v.z)) / 3.0;\n}\n\nfloat SmoothBlend(float a, float b, float smoothing)\n{\n    float h = clamp((b - a) / smoothing + 0.5, 0.0, 1.0);\n    float m = h * (1.0 - h) * smoothing;\n    return h * a + (1.0 - h) * b - m * 0.5;\n}\n\nfloat nsin(float value)\n{\n    return sin(value) * 0.5 + 0.5;\n}\n\nfloat ncos(float value)\n{\n    return cos(value) * 0.5 + 0.5;\n}\n\nfloat sfract(float v)\n{\n    if (v >= 0.0)\n    {\n        return v - floor(v);\n    }\n    return -(v - ceil(v));\n}\n\nvec2 sfract(vec2 v)\n{\n    return vec2(sfract(v.x), sfract(v.y));\n}\n\nvec3 sfract(vec3 v)\n{\n    return vec3(sfract(v.xy), sfract(v.z));\n}\n\nfloat smod(float v, float x)\n{\n    return x == 0.0 ? v : sfract(v / x) * x;\n}\n\nvec2 smod(vec2 v, vec2 x)\n{\n    return vec2(smod(v.x, x.x), smod(v.y, x.y));\n}\n\nvec3 smod(vec3 v, vec3 x)\n{\n    return vec3(smod(v.xy, x.xy), smod(v.z, x.z));\n}\n\n// PRIMITIVES\nfloat Sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat Torus(vec3 p, float w, float r)\n{\n\treturn length(vec2(length(p.xz) - w, p.y)) - r;\n}\n\nfloat CappedTorus(in vec3 p, in float angle, in float ra, in float rb)\n{\n    vec2 c = vec2(sin(angle),cos(angle));\n    \n    p.x = abs(p.x);\n    float k = (c.y*p.x>c.x*p.y) ? dot(p.xy,c) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat Capsule(vec3 p, float len, float rad)\n{\n\tvec3 a = vec3(len * 0.5, 0.0, 0.0);\n\tvec3 b = vec3(-len * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n\treturn length(p - c) - rad;\n}\n\nfloat Cylinder(vec3 p, float l, float r)\n{\n\tvec3 a = vec3(l * 0.5, 0.0, 0.0);\n\tvec3 b = vec3(-l * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\n\tvec3 c = a + t * ab;\n\tfloat x = length(p - c) - r;\n\tfloat y = (abs(t - 0.5) - 0.5) * length(ab);\n\tfloat e = length(max(vec2(x, y), 0.0));\n\tfloat i = min(max(x, y), 0.0);\n\n\treturn e + i;\n}\n\nfloat Gyroid(vec3 p, vec3 repetition, float width, vec2 bias)\n{\n    p *= repetition;\n    float avgRepetition = AvgComponentLength(repetition);\n    return abs(dot(sin(p * bias.x), cos(p.zxy * bias.y))) / avgRepetition - width;\n}\n\nfloat Box(vec3 p, vec3 dimensions)\n{\n\treturn length(max(abs(p) - (0.5 * dimensions), 0.0));\n}\n\nfloat BoxFrame(vec3 p, vec3 b, float e)\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat Link(vec3 p, float le, float r1, float r2)\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le / 2.0,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat Plane(vec3 p)\n{\n    return abs(p.y);\n}","name":"Common","description":"","type":"common"}]}