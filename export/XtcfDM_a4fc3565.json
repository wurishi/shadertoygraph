{"ver":"0.1","info":{"id":"XtcfDM","date":"1539754615","viewed":954,"name":"my universe","username":"mastersun","description":"my universe, not finished yet","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float N21(vec2 p) {\n\tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p) {\n\tfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset) {\n\tvec2 n = N22(id + offset);\n    float x = cos(iTime * n.x);\n    float y = sin(iTime * n.y);\n    return vec2(x, y) * 0.4 + offset;\n}\n\nfloat distanceToLine(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - t * ba);\n}\n\nfloat getLine(vec2 p, vec2 a, vec2 b) {\n\tfloat distance = distanceToLine(p, a, b);\n    float dx = 15./iResolution.y;\n    return smoothstep(dx, 0., distance) * smoothstep(1.2, 0.3, length(a - b));\n}\n\nfloat layer(vec2 st) {\n    float m = 0.;\n    vec2 gv = fract(st) - 0.5;\n    vec2 id = floor(st);\n    // m = gv.x > 0.48 || gv.y > 0.48 ? 1. : 0.;\n    // vec2 pointPos = getPos(id, vec2(0., 0.));\n    // m += smoothstep(0.05, 0.03, length(gv - pointPos));\n    \n    float dx=15./iResolution.y;\n    // m += smoothstep(-dx,0., abs(gv.x)-.5);\n    // m += smoothstep(-dx,0., abs(gv.y)-.5);\n    // m += smoothstep(dx, 0., length(gv - pointPos)-0.03);\n    \n    vec2 p[9];\n    int i = 0;\n    for (float x = -1.; x <= 1.; x++) {\n        for (float y = -1.; y <= 1.; y++) {\n        \tp[i++] = getPos(id, vec2(x, y));\n        }\n    }\n    \n    for (int j = 0; j <= 8; j++) {\n    \tm += getLine(gv, p[4], p[j]);\n        vec2 temp = (gv - p[j]) * 20.;\n        m += 1./dot(temp, temp) * (sin(10. * iTime + fract(p[j].x) * 20.) * 0.5 + 0.5);\n        \n    }\n    \n    m += getLine(gv, p[1], p[3]);\n    m += getLine(gv, p[1], p[5]);\n    m += getLine(gv, p[3], p[7]);\n    m += getLine(gv, p[5], p[7]);\n    \n    // m += smoothstep(0.05, 0.04, length(st - vec2(0., 0.)));\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float m = 0.;\n    \n    float theta = iTime * 0.1;\n    mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    vec2 gradient = uv;\n    uv = rot * uv;\n    \n    for (float i = 0.; i < 1.0 ; i += 0.25) {\n    \tfloat depth = fract(i + iTime * 0.1);\n        m += layer(uv * mix(10., 0.5, depth) + i * 20.) * smoothstep(0., 0.2, depth) * smoothstep(1., 0.8, depth);\n    }\n    \n    vec3 baseColor = sin(vec3(3.45, 6.56, 8.78) * iTime * 0.2) * 0.5 + 0.5;\n    \n    vec3 col = (m - gradient.y) * baseColor;\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}