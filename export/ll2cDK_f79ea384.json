{"ver":"0.1","info":{"id":"ll2cDK","date":"1510250276","viewed":219,"name":"Hilbert Curve Visualization","username":"Equations","description":"Since Hilbert curve iterations contain one another, we can use that to create a (kind of) nice zoom out effect.\nAlso knowing myself, this Code is probably rater unoptimized, so feel free to send suggestions!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["hilbertcurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//scaleFactor = ln(2) / 2 / pi\nconst float scaleFactor = 0.110317800;\n//zoomSpeed: at 2.0 new Iteration every P√ç seconds\nconst float zoomSpeed = 2.0;\nconst float lineThicknessBase = 0.025;\nconst float lineThicknessIncrease = 0.5;\nconst int maxIterations = 10;\n//maxsize = 2^maxIterations\nconst float maxSize = 1024.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    float scale = min(exp((zoomSpeed * iTime - sin(zoomSpeed * iTime)) * scaleFactor), maxSize);\n    //different scale depending on if your screen is higher or wider\n    vec2 uv = vec2(fragCoord.x - max((iResolution.x - iResolution.y) / 2.0, 0.0), \n                   fragCoord.y - max((iResolution.y - iResolution.x) / 2.0, 0.0)) \n        / min(iResolution.y, iResolution.x) * scale;\n    \n    float lineThickness = lineThicknessBase * pow(scale, lineThicknessIncrease);\n    \n    float size = maxSize;\n    for(int it = 0; it < maxIterations; ++it)\n    {\n        if(scale < size)\n        {\n            size = size / 2.0;\n        \tcontinue;\n        }\n    \t\n        size = size / 2.0;\n        //test if uv is at a left/middle/right connection piece of iteration\n        if(  (abs(uv.x - 0.5) < lineThickness && uv.y >= size - 0.5 && uv.y <= size + 0.5)\n          || (abs(uv.y - size + 0.5) < lineThickness && uv.x >= size - 0.5 && uv.x <= size + 0.5) \n          || (abs(uv.x - 2.0 * size + 0.5) < lineThickness && uv.y >= size - 0.5 && uv.y <= size + 0.5))\n        {\n        \tfragColor = vec4(0.0);\n            return;\n        }\n        //rotate vector uv into correct quadrant for next iteration\n        if(uv.y > size)\n        {\n            uv = vec2(2.0 * size - uv.y, abs(uv.x - size));\n        }\n        else if(uv.x > size)\n        {\n        \tuv.x = uv.x - size;\n        }\n    }\n    //add dot\n    if(distance(uv, vec2(0.5, 0.5)) < lineThickness)\n    {\n        fragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}