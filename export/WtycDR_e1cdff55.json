{"ver":"0.1","info":{"id":"WtycDR","date":"1610756609","viewed":64,"name":"plaid to meet ya! (vlllll)","username":"valalalalala","description":"fun with mod and iterative patterns","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","experiment","plaid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////\n//\n// \"plaid to meet ya!\" \n// fun with mod and iterative patterns\n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n/////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// scene controls\n\n// just show single object (take off _)\n#define LOOKIE_\n\n// bring the noise!\n#define NOISY_\n\n// s'hell is other people\n#define SHELL_ .4\n\n////////////////////////////////////////////////////////////////\n// handy constants\n\n#define ZED   .0\n#define PI    3.141592653589793 \n#define PI2   6.283185307179586\n\n////////////////////////////////////////////////////////////////\n// ray marching\n\n#define STEPS 77\n#define CLOSE .001\n#define FAR   77.\n#define EPZ   vec2( ZED, CLOSE )\n\n////////////////////////////////////////////////////////////////\n\n#define FROM_SCREEN(uv)  ( ( uv - iResolution.xy *.5 ) / iResolution.y * 2. )\n#define MAP_11_01(v)     ( v * .5 + .5 )\n\n#define TRIG(a)   vec2( cos( a  * PI2 ), sin( a * PI2 ) )\n#define MAX3(v)   max( v.x, max( v.y, v.z ) )\n#define SUM3(v)   ( v.x + v.y + v.z )\n#define MODO(v,f) ( mod( v + .5 * f, f ) - .5 * f )\n#define HASH31(v) fract( 33433.44469 * sin( dot( v + vec3( 17.76, 20.21, 19.99 ), vec3( 449.457, 359.367, 513.312 ) ) ) )\n\n////////////////////////////////////////////////////////////////\n\nmat2 rotate2d( float angle ) {\n    vec2 t = TRIG( angle );\n    return mat2( t.x, -t.y, t.y, t.x ); //c-ssc\n}\n\nconst mat2 QUARTER = mat2( .7071, -.7071, .7071, .7071 );\n\n////////////////////////////////////////////////////////////////\n\nfloat sdBox( vec3 p, float s ) {\n    return MAX3( (abs( p ) - vec3( s ) ) );\n}\n\nfloat sdQuadBlob( vec3 p, float s ) {\n    return dot( p, p ) / SUM3( abs( p ) ) - s;\n}\n\nfloat sdBall( vec3 p, float r ) {\n    return length( p ) - r;\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat getDistance( vec3 p ) {\n    vec3 og = p;\n    \n#ifndef LOOKIE\n    p = MODO( p, 2. );  \n#endif\n\n    vec3 id = p - og;\n    float angulo = HASH31( id );\n    \n    vec2 t = TRIG( iTime *.22 + angulo );\n    float s = abs( t.x ); \n    \n    float d_box = sdBox( p, 1. );\n#ifdef SHELL\n    d_box = abs( d_box ) - SHELL;\n#endif\n\n    float r = .734 + .15 * s;      \n    \n    float d_quad =  sdQuadBlob( p, r );\n    float d = max( d_box, -d_quad );\n        \n    t *= .6;\n    vec3 o = vec3( t.x, .5 * t.x + .5 * t.y, t.y );\n    float d_ball = sdBall( p - o, .13 );\n\n    return min( d, d_ball );\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat march( vec3 a, vec3 ab ) {\n    float d = .0;\n    for ( int i = 0 ; i < STEPS ; i++ ) {\n        vec3 b = a + d * ab;\n        float n = getDistance( b );\n        d += n;\n#ifdef NOISY\n        ab += .001 * HASH31( b ); // further means furrier\n#endif\n        if ( abs( n ) < CLOSE || d > FAR ) break;\n    }\n    return d;\n}\n\nvec3 getDistances( vec3 a, vec3 b, vec3 c ) {\n    return vec3( getDistance( a ), getDistance( b ), getDistance( c ) );\n}\n\nvec3 getNormal( vec3 p ) {\n    return normalize( getDistance( p ) - \n        getDistances( p - EPZ.yxx, p - EPZ.xyx, p - EPZ.xxy )\n    );\n}\n\n////////////////////////////////////////////////////////////////\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( TRIG( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nvec2 getMouse() {\n    return FROM_SCREEN( iMouse.xy );\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat checked( vec2 uv, float scale ) {\n    vec2 st = floor( uv * scale );\n    return mod( st.x + st.y, 2. );\n}\n\nvec2 quoitah( vec2 uv ) {\n    return ( uv - .5 ) * QUARTER + .5;\n}\n\nvec4 texaco( vec2 uv ) {\n    vec3 t = vec3( .0 );\n    t += .5 * checked( quoitah( uv ),  23. ) * vec3( .9, .1,.1 );   \n    t += .4 * checked( uv,  47. ) * vec3( .1, .9,.1 );\n    t += .3 * checked( uv,  93. ) * vec3( .1, .1,.9 );\n    t += .2 * checked( uv, 191. ) * vec3( .9, .1,.1 );\n    t += .1 * checked( uv, 191. ) * vec3( .9, .1,.1 );\n    return vec4( t, 1. );\n}\n\nvec3 colorHit( vec3 p ) {\n    // after watching https://www.youtube.com/watch?v=VaYyPTw0V84&ab_channel=TheArtofCode\n    vec3 n = getNormal( p );\n    float l = max( .1, pow( MAP_11_01( n.y ), 3. ) );\n    \n    n = pow( abs(n), vec3( 4. ) );\n    n /= SUM3( n ); // pseudo normalize\n    \n    vec4 tX = texaco( MAP_11_01( p.yz ) );\n    vec4 tY = texaco( MAP_11_01( p.xz ) );\n    vec4 tZ = texaco( MAP_11_01( p.xy ) );\n\n    return l * ( n.x * tX + n.y * tY + n.z * tZ ).xyz;\n}\n\nvec3 colorMiss( in vec2 uv ) {\n    return .4 * texaco( MAP_11_01( uv * .5 ) ).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = FROM_SCREEN( fragCoord );\n    float view = 6.;\n    float zoom = 1.;\n\n    vec2 m = getMouse();  \n    vec2 t = view * TRIG( m.x );\n\n#ifdef LOOKIE\n    vec3 a = .33 * vec3( t.x, view * TRIG( m.y ).y, t.y );       \n    vec3 b = vec3( ZED );\n#else\n    vec3 a = vec3( .6, .4, .6 );\n    a.z += cos( iTime * .01 ) * 99.;\n    \n    float by = view * sin( PI * m.y * 1.5 );\n    vec3 b = a + vec3( t.x, by, t.y );      \n#endif\n    vec3 ab = normalize( makeCamera( a, b, .0 ) * vec3( uv, zoom ) );\n\n    float d = march( a, ab );\n    float hit = step( d, FAR );\n\n    vec3 p = hit * ( a + ab * d );\n    vec3 color = mix( colorMiss( uv ), colorHit( p ), hit );\n    \n    float foginess = pow( d / FAR, .33 ) - .0;\n    vec3 fog = vec3( .22, .11, .4 ) * hit;\n    color = mix( color, fog, foginess );\n    \n    fragColor = vec4( color, 1. );\n}","name":"Image","description":"","type":"image"}]}