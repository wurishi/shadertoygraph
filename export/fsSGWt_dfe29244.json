{"ver":"0.1","info":{"id":"fsSGWt","date":"1618074802","viewed":287,"name":"Voxel Gyroid II","username":"kastorp","description":"Lighting, bumps and textures from Shane's:  [url]https://www.shadertoy.com/view/MdVSDh[/url].\nit was so easy :)","likes":23,"published":1,"flags":32,"usePreview":0,"tags":["voxel","gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Voxel Gyroid\" by kastorp. https://shadertoy.com/view/7djGDw\n// 2021-04-10 16:59:26\n\n//Voxel Gyroid II  by Kastorp\n//\n// lighting,bumps, textures and other goodies copied from Shane's: https://www.shadertoy.com/view/MdVSDh\n//\n//------------------------\n\nint gFrame=0;\nfloat csz; //voxel size\nfloat shape; //<=0. none, <.35 sphere >=.35 cube\nfloat mapVoxel(in vec3 p) {\n    \n    float d =1e5;         \n    vec3 c = floor(p / csz) * csz;\n    vec3 dc= sin(c.zxy*3.+iTime)*csz*(.5+shape);\n    d=mix( min(d, length(p -c + dc-csz/2.)-csz*(-shape)),    \n           min(d, sdBox(p- c-csz/2.,vec3(csz*clamp(-shape,0.,.5))) ),\n           clamp(-shape*shape*shape*8.,0.,1.));\n    return d; \n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    vec3 e =vec3(0.001,0,0);\n    for(int i=gFrame;i<=2;i++){       \n        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapVoxel(p + j* e) ;\n        e=e.zxy; //TdHopper trick\n    }\n    return normalize(n);\n}\n\nvec3 rayDirection(vec3 cameraDir, vec2 uv){\n    \n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nvec4 rayCast(vec3 ro,vec3 rd,bool sh)\n{    \n    //RAYTRACING BOUNDING BOX    \n    vec3 bb =  csz*vec3(vec2(calcLoadDist(iChannelResolution[0].xy)),heightLimit*.5);\n    bb =min(bb,vec3(csz*N*.50+.00001));    \n    vec2 tb= boxIntersection(  ro,  rd, bb ) ;\n    if(tb.y<0.) return vec4(0.);\n    \n    //VOXEL TRAVERSAL\n    vec3 rs= sign(rd);\n    vec3 ri = 1./rd;\n\tvec3 rp0 =ro +  max(tb.x,0.)*rd,rp=rp0; \n    \n    vec3 mp=floor(rp/csz)*csz;\n    vec3 sd = (mp-rp + 0.5*csz + rs*0.5*csz) *ri;\n    vec3 mask=vec3(0.);    \n    \n    for (int i = gFrame; i < (sh?70:200); i++) {\n        \n        if(i>0||!sh){\n            //mask = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n            mask = step(sd, sd.yzx)*(1.-step(sd.zxy, sd)); \n            sd += mask *  rs *ri*csz;\n            mp += mask *  rs*csz;\n\n\n            vec3 mini = (mp-rp + 0.5*csz - csz*0.5*vec3(rs))*ri;\n            float t1=  max ( mini.x, max ( mini.y, mini.z ) );\n             rp= t1*rd+rp ;\n        }\n        if(length(rp-ro)>tb.y) break; //outside bounding box\n        \n        shape = getVoxel( mp/csz,iChannel0,iChannelResolution[0]).x;  \n        if(shape<0.)  {\n            \n            //SDF RAYTRACING INSIDE VOXEL\n            float t2 = 0.0001;          \n            for (int iters=gFrame; iters < 30; iters++) {\n                \n                vec3 p = rp + rd * t2;\n\n                if(sdBox(p-mp-.5*csz,vec3(.5*csz))>0.) break;\n               \n                float d = mapVoxel(p);\n                if (d < 0.001) return vec4(p,-shape);\n \n                t2 += d;\n            }\n        }\n\t} \n    return vec4(tb.x,tb.y,0.,0.);\n}\n//--------------------SHANE---------------------\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n//--------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    csz = L*.5/N;\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2  m =  iMouse.x<=0. ? vec2(-0.3): (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y*3.14;\n\n    fragColor = vec4(0.4,0.4,0.7,1.0);\n    gFrame=min(iFrame,0);\n\n    vec3 ro = vec3(sin(m.y*.5+.76) * cos(-m.x), sin(m.y*.5+.76) * sin(-m.x), cos(m.y*.5 +.76))*16.*(.8+sin(iTime/3.)*.2);\n    vec3 cd = -normalize(ro); \n    vec3 rd = rayDirection(cd ,uv);\n    \n    vec4 r= rayCast(ro,rd,false);\n    \n    if(r.a>0.){\n            vec3 p =r.xyz, \n                 n = getNormal(p);\n             \n             vec3 l=normalize(vec3(.6,-.4,1));            \n             float shading=1.;\n             for(int i=gFrame+1;i<4;i++){ //didn't have a better idea...\n                 vec4 s= rayCast(p+n*.005*csz*float(i*i*i) ,l,true); \n                 shading *= step(0., -s.a)*.33 + .67;\n             }\n                      \n             vec3 c = floor(p / csz) * csz;\n             vec3 dc= sin(c.zxy*3.+iTime)*csz*.2;\n             float mx =clamp(r.a*2.,0.,1.);\n             n = mix( doBumpMap( iChannel1, (p+dc)*.25/csz, n, 0.02),doBumpMap( iChannel2, p*.25/csz, n, 0.02),mx);\n             fragColor.rgb= mix(tex3D(iChannel1, (p+dc)*.25/csz, n).grb, tex3D(iChannel2, p*.25/csz, n),mx);                      \n                           \n             float ambience = 0.25;\n             float diff = max( dot(n, l), 0.0);\n             float spec = pow(max( dot( reflect(-l, n), -rd ), 0.0 ), 32.);\n             \n             fragColor.rgb = fragColor.rgb*(diff + ambience) + vec3(.7, .9, 1.)*spec;            \n             fragColor.rgb *= shading;             \n             fragColor = vec4(sqrt(clamp(fragColor, 0., 1.)));             \n    }\n    \n    fragColor =mix(fragColor,vec4(0.2), (r.y-r.x)/L*1.4);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n//https://www.shadertoy.com/view/4tVSzR\nfloat map(vec3 p)\n{\n\n    // Shane's variation\n    float d0=dot(sin(p),cos(p.yzx));\n    \n    float d1=abs(p.y+6.3);\n    float d2=length(p)-min(9.,5.5-cos(iTime/8.)*3.5);\n    float d=smax(-d0,d2,3.);\n    d=min(d1,d);\n   \n    return clamp(d,-.49,+.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 textelCoord = floor(fragCoord);    \n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset); \n\n    \n    float data;\n    //    if(iFrame>0) data = getVoxel( voxelCoord,iChannel0,iChannelResolution[0]).x; else  \n    data = map(voxelCoord*18./N);\n       \n    fragColor = vec4( data);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst float L= 30., //cube size\n            N= 30.; //number of voxel x side (TOT=N^3)\n\nvec3 offset = floor(vec3(0.,0.,-L/2.));\nconst vec2 packedChunkSize= ceil(sqrt(N) * vec2(1.25 ,0.8)); // iResolution.xy/iResolution.yx \nconst float heightLimit = packedChunkSize.x * packedChunkSize.y; //must be > N\n\n//-----------------------------------------\n// VOXEL CACHE FUNCTIONS from fb39ca4\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float o = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - o);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float o = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + o;\n}\n\nfloat calcLoadDist(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset) {\n\n    vec2 packedChunkSize= packedChunkSize;\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec2 packedChunkSize= packedChunkSize;\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nvec4  getVoxel(vec3 p,sampler2D iChannel,vec3 resolution) {\n    p.z-= offset.z;\n    if(p.z>heightLimit || p.z<0.){return vec4(0.);}  \n    return texelFetch(iChannel, ivec2(voxToTexCoord(p))  , 0); \n    //return texture(iChannel, (floor(voxToTexCoord(p)) + 0.5) /  (floor (resolution.xy)), 0.0);\n\n}\n//-----------------------------\n\n//Iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    \n    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}","name":"Common","description":"","type":"common"}]}