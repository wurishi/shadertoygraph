{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define MIN_F 0.00001\n\nfloat asr = 835./469.;\nfloat scale;\n\nvec2 uv;\nvec2 xy;\nvec3 col;\n\n\nvec3 l_col = vec3(0., 1., 0.);\nvec3 p_col = vec3(1., 0., 1.);\nvec3 y_col = vec3(1., 1., 0.);\nvec3 b_col = vec3(0., 0., 1.);\nvec3 r_col = vec3(1., 0., 0.);\nvec3 w_col = vec3(1.);\nvec3 g_col = vec3(.6);\n\nfloat[50] const_lst;\nint const_num = 0;\n\nvec2 nx(vec2 v) {\n    return vec2((v.x - .5)*asr, v.y - .5)*2.*scale;\n}\n\nvoid draw(float edge, float x, vec3 x_col) {\n    float d = fwidth(edge);\n    float a = smoothstep(edge - d, edge + d, x);\n    col = mix(col, x_col, a);\n}\n\nvoid draw_area(vec2 center, float radius, vec3 color) {\n    draw(length(xy - center), radius, color);\n}\n\nvoid draw_greed() {\n    float ax_big = .005;\n    float ax_smal = .001;\n    int x_start = 2 * int(scale);\n    \n    for(int i = -x_start; i <= x_start; i++) {\n        float crd = float (i);\n        draw_area(vec2(xy.x, crd), ax_smal*scale, g_col);\n        draw_area(vec2(crd, xy.y), ax_smal*scale, g_col);\n    }\n    \n    draw_area(vec2(xy.x, 0.), ax_big*scale, g_col);\n    draw_area(vec2(0., xy.y), ax_big*scale, g_col);\n}\n\nvoid draw_fn(float g, float y, float thick, vec3 f_col) {\n    float x0 = (g*xy.x - y)/g;\n    \n    vec2\n        a = vec2(x0, 0.),\n        b = vec2(xy.x - x0, y);\n    \n    float t = dot(xy - a, b)/dot(b, b);\n    vec2 o = a + b*t;\n    \n    draw_area(o, thick, f_col);\n}\n\nvoid draw_polynom(float thick, vec3 f_col) {\n    float x = xy.x, y, g;\n        \n    for(int i = 0, j = const_num - 1; i < const_num; i++, j--) {\n        y += const_lst[i]*pow(x, float(j));\n        g += const_lst[i]*float(j)*pow(x, float(j - 1));\n    }\n    \n    draw_fn(g, y, thick, f_col);\n}\n\nvoid const_push(float c) {\n    const_lst[const_num++] = c;\n}\n\nvoid lst_reset() {\n    const_num = 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.xy;\n    scale = 7.;\n    xy = nx(uv);\n    col = vec3((1.-uv.y)*.3, (1.-uv.y)*.25, (1.-uv.y)*.5);\n    \n    draw_greed();\n    \n    //linear function y = a*x + b\n    //where const_lst[0] = a, const_lst[1] = b\n    const_push(.7);\n    const_push(3.);\n    draw_polynom(.07, b_col);\n    \n    lst_reset();\n    \n    //quadratic function y = a*x^2 + b*x + c\n    //where const_lst[0] = a, const_lst[1] = b, const_lst[2] = c\n    const_push(1.);\n    const_push(-6.);\n    const_push(5.);\n    draw_polynom(.07, l_col);\n    \n    lst_reset();\n    \n    //cubic function y = a*x^3 + b*x^2 + c*x + d\n    //where const_lst[0] = a, const_lst[1] = b, const_lst[2] = c, const_lst[3] = d\n    const_push(1.);\n    const_push(9.);\n    const_push(27.);\n    const_push(29.);\n    draw_polynom(.07, r_col);\n\n    lst_reset();\n    \n    //function y = a*x^4 + b*x^3 + c*x^2 + d*x + e\n    //where const_lst[0]=a,const_lst[1]=b,const_lst[2]=c,const_lst[3]=d,const_lst[4]=e\n    const_push(.3);\n    const_push(0.);\n    const_push(0.);\n    const_push(0.);\n    const_push(-2.);\n    draw_polynom(.07, y_col);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcKfD3","date":"1734595744","viewed":42,"name":"Greed for drawing functions","username":"dsd","description":"Shader for drawing polynomial functions of different sizes.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["functions","coordinates","greed"],"hasliked":0,"parentid":"","parentname":""}}