{"ver":"0.1","info":{"id":"X3fXDj","date":"1709960185","viewed":43,"name":"Voronoi 0308","username":"kukovisuals","description":"voronoi diagram 101","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Number of cells\nconst int cellCount = 30;\nconst float sqrtCellCount = sqrt(float(cellCount)); // Pre-computed for speed-up\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.y;\n\n    // More or less evenly spaced cell centers\n    vec2 cellPositions[cellCount];\n    for (int i = 10; i < cellCount; i++) {\n        float index = float(i);\n        cellPositions[i].x = index / float(cellCount) * iResolution.x / iResolution.y;\n        cellPositions[i].y = mod(index, sqrtCellCount) / sqrtCellCount;\n        // move centers in circles\n        cellPositions[i] +=( 0.2 + 0.1 * cos(1.03)) * vec2(sin(index * 1.05),cos( index * 1.07));\n    }\n    \n    // Voronoi-like processing, find squared distance to the nearest center\n    float minDistance = 1.0; // Initialize with max distance\n    for (int i = 0; i < cellCount; i++) {\n        vec2 distance = uv - cellPositions[i];\n        minDistance = min(minDistance, dot(distance, distance));\n    }\n\n    // Scale the result to make it closer to white\n    minDistance *= 10.0;\n    \n    // Output to screen\n    fragColor = vec4(minDistance, minDistance, minDistance, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}