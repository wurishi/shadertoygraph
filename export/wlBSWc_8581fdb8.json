{"ver":"0.1","info":{"id":"wlBSWc","date":"1675080229","viewed":50,"name":"The Cogs","username":"Peetu","description":"Scene from my Assembly 2020 demo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarch","cog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float ar = 1.8;\nconst float E = 0.001;\nconst float start = 0.01;\nconst float end = 100.0;\nconst float PI = 3.14159;\n\nmat3 rotationMatrixY(float rad) {\n    return mat3(\n        vec3(cos(rad), 0.0, sin(rad)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(rad), 0.0, cos(rad))\n    );\n}\n\nmat3 rotationMatrixX(float rad) {\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(rad), -sin(rad)),\n        vec3(0.0, sin(rad), cos(rad))\n    ); \n}\n\nmat3 rotationMatrixZ(float rad) {\n    return mat3(\n        vec3(cos(rad), -sin(rad), 0.0),\n        vec3(sin(rad), cos(rad), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat2 rot(float a) {\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nfloat cylinder(vec3 p, float r, float h) {\n\treturn max(length(p.xz) - r, abs(p.y) - h ); \n}\n\nfloat ball(vec3 p) {\n\treturn length(p) - .1;\n}\n\nfloat os0(float r) {\n\treturn sin(r * 10.)*.05;\n}\n\nfloat cog(vec3 p, float dir) {\n    p.xz = rot(dir * iTime) * p.xz;\n    float os = os0(atan(p.x, p.z));\n    return max(\n        cylinder(p, 0.5 + os, 0.2),\n    \t-cylinder(p, 0.2 + sin(mod(iTime, 23.))*.05, 0.3)    \n    );\n}\n\nfloat SDF(vec3 p) {\n    float s = 1.;\n    \n    float dir = floor(mod(p.x, s * 2.) / s) * 2. - 1.;\n    dir *= floor(mod(p.z, s * 2.) / s) * 2. - 1.;\n    \n    p.xz = mod(p.xz, s) - s*.5;   \n    \n\treturn cog(p, dir);   \n}\n\nvec3 rayMarch(vec3 eye, vec3 ray, float t0) {\n\n\tfloat depth = 0.;\n\tfor(int i = 0; i < 128 && depth < 15.; i++) {\n\t\tvec3 p = eye + ray * depth;\n\t\tfloat dist = SDF(p);\n\n\t\tif(dist < E) {\n\t\t\treturn vec3(depth - 5.5 + t0) * .2;\n\t\t}\n        depth += dist;\n\t}\n    \n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= vec2(.9, .5);\n    float t = mod(iTime, 23.) + 2.;\n    float t0 = max(0., t - 20.)*(t - 20.)*.5;\n    mat3 rot = rotationMatrixX(3.8 + t * .01) * rotationMatrixZ(12.8 + sin(t * .1)*.7);\n\tvec3 eye = rot * vec3(t0 * -.035, 3. - t * .2 + t0 * -.03, -6. + t0);\n\tvec3 ray = rot * normalize(vec3(uv, 2.));\n\tvec3 col = rayMarch(eye, ray, t0);\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}