{"ver":"0.1","info":{"id":"7sd3zs","date":"1630531433","viewed":186,"name":"Homemade camera \"filter\"","username":"playersteve19","description":"GMDN function based on the xkcd webcomic 2435: Geothmetic Meandian. After that I was just messing around with cross() and mix(). Still no idea what's actually going on here","likes":0,"published":3,"flags":34,"usePreview":0,"tags":["effect","webcam","noisy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x*=iResolution.x/iResolution.y;\n    float t = iTime * 0.1;\n    vec3 col=texturenice(iChannel0,uv).xyz;\n    //col=vec3(uv,iTime/10.);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//major props to AntoineC\n/*\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/scl/fi/e95juh7ue0k8mi45rfgut/original.png?rlkey=xtudhurf32vhasmmjira5ka0t&dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n\nvec3 GMDN(in vec3 c){\n    float scale = 1.;\n    c *= scale;\n    float arithmean = c.r + c.g + c.b;\n    arithmean /= 3.;\n    float geomean = c.r * c.b *c.g; \n    geomean = pow(geomean, (1./3.));\n    float median = c.r + c.g + c.b - min(min(c.r,c.g),c.b) - max(max(c.r,c.g),c.b);\n    c=vec3(median, geomean, arithmean);\n    c /= scale;\n    return c;\n}\nvec3 rgb2hsv( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                 d / (q.x + e),\n                q.x);\n}\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x = 1.0 - uv.x; /*Horizontal mirror*/\n    vec3 col;\n    col=texturenice(iChannel0,uv).xyz;\n    //col=vec3(uv,fract(iTime/60.));/*debug*/\n    float amp = 1.5;/*adjusts brightness/gamma curves*/\n    vec3 color = tanh(amp*vec3(\n        mix(\n            mix(\n                hsv2rgb(vec3(\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).x,\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).y*.25,\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).z+.5)),\n                col,\n                .5),\n            GMDN(mix(\n                hsv2rgb(vec3(\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).x,\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).y*.5,\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).z+.5)),\n                col,\n                .5)),\n            2.)));/*Jam2Go, if you end up using this, map this value to the depth buffer maybe*/\n            col=color;/*disable for direct comparisons*/\n    fragColor=vec4(col,1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//thanks once again to Iñigo Quilez. \nvec4 texturenice( sampler2D sam, vec2 uv )\n{\n    float textureResolution = float(textureSize(sam,0).x);\n    uv = uv*textureResolution + 0.5;\n    vec2 iuv = floor( uv );\n    vec2 fuv = fract( uv );\n    uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    uv = (uv - 0.5)/textureResolution;\n    return texture( sam, uv );\n}","name":"Common","description":"","type":"common"}]}