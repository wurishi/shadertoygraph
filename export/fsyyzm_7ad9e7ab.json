{"ver":"0.1","info":{"id":"fsyyzm","date":"1654721438","viewed":211,"name":"Nacreous Volume Ring","username":"okelly4408","description":"Playing around with volumes. Drag to change position. ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["volume","torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//cloud marching function from shader \"Cloudy Shapes\" by kaneta: https://www.shadertoy.com/view/WdXGRj\n//cosine color palette function courtesy of iq\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 rot_x(in vec3 v, in float theta) {\n    mat3 rotx = mat3(1.0, 0.0, 0.0, 0.0, cos(theta), sin(theta), 0.0, -sin(theta), cos(theta));\n    return rotx * v;\n}\nvec3 rot_y(in vec3 v, in float theta) {\n    mat3 roty = mat3(cos(theta), 0.0, -sin(theta), 0.0, 1.0, 0.0, sin(theta), 0.0, cos(theta));\n    return roty * v;\n}\n\nfloat noise(\n\tin vec3 x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nfloat fbm (in vec3 p)\n{\n    float f = 0.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        float n = noise(p * freq) / freq;\n        f += n;\n        freq *= 2.0;\n    }\n    return f;\n}\nfloat rmf(vec3 p)\n{\n    float signal = 0.0;\n    float value  = 0.0;\n    float weight = 1.0;\n    float h = 1.0;\n    float f = 1.0;\n\n    for (int i=0; i < 4; i++) \n    {\n        signal = noise(p)*2.0-0.4;\n        signal = pow(1.0 - abs(signal), 2.0) * weight;\n        weight = clamp(0.0, 1.0, signal * 16.0);\n        value += (signal * pow(f, -1.0));\n        f *= 2.0;\n        p *= 2.0;\n    }\n    \n    return (value * 1.25) - 1.0;\n}\n\n  \nfloat sdSphere(vec3 p, vec3 c, float r) {\n    \n    return length(p - c) - (r + fbm(p * 0.5));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat map(in vec3 p){\n    float t = iTime * 0.125;\n    return 1.- sdTorus(p, vec2(6.0, 1.0)) +rmf(t+p*2.5*(fbm(t+p)*0.425))*.5;\n}\nvec3 sNormal(in vec3 p){\n    float e = 0.001;\n    float d = map(p);\n    float xd = map(p+vec3(e,0,0));\n    float yd = map(p+vec3(0,e,0));\n    float zd = map(p+vec3(0,0,e));\n    vec3 n = (vec3(xd,yd,zd)-d)/e;\n    return n;\n}\n    \n//fixed value for now\nfloat jitter = 0.35;\n\n#define MAX_STEPS 50\n#define SHADOW_STEPS 6\n#define VOLUME_LENGTH 60.\n#define SHADOW_LENGTH 2.\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (abs(sum.a) < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if(d> 0.001)\n        {\n            vec3 lpos = pos + light * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n    \n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n            sum.a *= 1.-density;\n            vec3 pa_col = pal( density*2.0, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n            sum.rgb += exp(-map(pos+ vec3(0,0.25,0.0)) * .2) *pa_col * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n\nvec3 camera(in vec2 uv, in vec3 ro, vec3 ta, float fd){\n    vec3 up = vec3(0,1,0); \n    vec3 ww = normalize(ta-ro); \n    vec3 uu = normalize(cross(ww, up)); \n    vec3 vv = normalize(cross(uu, ww)); \n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + fd*ww);\n    return rd;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 li = normalize(vec3(0.5, .8, 3.0));\n    float a = 10.0 * iMouse.x/iResolution.x;\n    vec3 ro = 1.05*vec3( 10.0 * sin(a), 9.0, 10.0* cos(a));\n    vec3 ta = vec3(0,0,0);   \n    vec3 rd = camera(uv, ro, ta, 1.0);\n    fragColor = pow(cloudMarch(ro, rd), vec4(1.15)) * 0.15;\n}","name":"Image","description":"","type":"image"}]}