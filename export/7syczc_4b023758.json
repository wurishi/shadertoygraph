{"ver":"0.1","info":{"id":"7syczc","date":"1655289251","viewed":149,"name":"oklab gradient comparison","username":"JuanDeager","description":"Comparison between blending in different color spaces and encodings.\ntop = blend in oklab\nmiddle = blend in linear srgb\nbottom = blend in nonlinear srgb","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["color","gradient","oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// linear to nonlinear sRGB\nfloat linear_to_nonlinear_srgb(float x)\n{\n    if (x >= 0.0031308)\n        return (1.055) * pow(x, 1.0/2.4) - 0.055;\n    else\n        return 12.92 * x;\n}\n\nvec3 linear_to_nonlinear_srgb(vec3 x)\n{\n    return vec3(linear_to_nonlinear_srgb(x.x), linear_to_nonlinear_srgb(x.y), linear_to_nonlinear_srgb(x.z));\n}\n\n// nonlinear to linear sRGB\nfloat nonlinear_to_linear_srgb(float x)\n{\n    if (x >= 0.04045)\n        return pow((x + 0.055)/(1.0 + 0.055), 2.4);\n    else \n        return x / 12.92;\n}\n\nvec3 nonlinear_to_linear_srgb(vec3 x)\n{\n    return vec3(nonlinear_to_linear_srgb(x.x), nonlinear_to_linear_srgb(x.y), nonlinear_to_linear_srgb(x.z));\n}\n\n// https://bottosson.github.io/posts/oklab/\nvec3 linear_srgb_to_oklab(vec3 c) \n{\n    float l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n    \n    return vec3(\n        0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_,\n        1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_,\n        0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_\n    );\n}\n\nvec3 oklab_to_linear_srgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec3 L = vec3(1, 1, 1);\n    //vec3 R = vec3(242.0/255.0, 12.0/255.0, 63.0/255.0);\n    vec3 L = vec3(76./255., 6./255., 252./255.);\n    vec3 R = vec3(252./255., 216./255., 2./255.);\n\n    vec3 col = vec3(0);\n    \n    // blend in oklab\n    if (uv.y >= .67)\n    {\n        vec3 L_ok = linear_srgb_to_oklab(nonlinear_to_linear_srgb(L));\n        vec3 R_ok = linear_srgb_to_oklab(nonlinear_to_linear_srgb(R));\n        col = linear_to_nonlinear_srgb(oklab_to_linear_srgb(mix(L_ok, R_ok, uv.x)));\n    }\n    \n    // blend in linear sRGB\n    if (uv.y >= .33 && uv.y < .67)\n    {\n        col = linear_to_nonlinear_srgb(mix(nonlinear_to_linear_srgb(L), nonlinear_to_linear_srgb(R), uv.x));\n    }\n    \n    // blend in nonlinear sRGB (notice the hue shift)\n    if (uv.y < .33)\n    {\n        col = mix(L, R, uv.x);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}