{"ver":"0.1","info":{"id":"MfXyWs","date":"1721756494","viewed":61,"name":"Holly Snake","username":"andy_che","description":"Hello, my snaky shader","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"MfsyRl","parentname":"Snaky shapes"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n\n#define TWO_PI 6.28318530718\n\n\nfloat remap(float val, float from_min, float from_max, \n    float to_min, float to_max){\n    val = clamp(from_min, from_max, val);\n    // Normalize the input value to a [0, 1] range\n    float norm_val = (val - from_min) / (from_max - from_min);\n\n    // Scale and shift to the target range\n    return to_min + norm_val * (to_max - to_min);\n}\n\n\nfloat shape_mask(vec2 st,\n    int N, \n    float extra_rot, float shape_size, \n    float smooth_border){\n\n    // Angle and radius from the current pixel\n    float a = atan(st.x, st.y) + PI + extra_rot;\n    float r = TWO_PI / float(N);\n\n    // Reference to\n    // http://thndl.com/square-shaped-shaders.html\n    // Shaping function that modulate the distance\n    float d = cos(floor(.5 + a / r) * r - a) * length(st);\n    float shape_mask = 1.0 - smoothstep(shape_size - smooth_border/ 2., shape_size + smooth_border / 2., d);\n    \n    return shape_mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 st_zero_one = fragCoord.xy / iResolution.xy;\n\n    // Remap the space to -1. to 1.\n    vec2 st = st_zero_one * 2. - 1.;\n\n    float x_squeeze = iResolution.x / iResolution.y;\n    st.x *= x_squeeze;\n\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n\n    float mask = 0.;\n    int N = 5;\n    // vec2 offset = vec2(0.,0.);\n    float move_speed = 1.;\n    float trail_step = -.2 ;\n    float trail_brightness = .97;\n    float trail_brightness_edge = .99;\n    const int cycles_num = 20;\n    float last_mask = 0.;\n    float shape_size = .2;\n    float inner_shape_coef = 1.5;\n    for(int cycle_i = 0; cycle_i < cycles_num; cycle_i++){\n        int cycle = cycles_num - cycle_i;\n        vec2 offset = vec2(0.,0.);\n        float trail_time = iTime + float(cycle) * trail_step;\n        offset.y += remap(sin(trail_time\n            * move_speed * 2.), -1., 1., 0., 1.) * .2;\n        offset.x += remap(sin(trail_time * move_speed), \n            -1., 1., -1., 1.) * .4;\n        \n        vec2 shape_st = st - offset;\n        float cycle_shape_size = shape_size * pow(.98, float(cycle));\n\n        float rot = float(cycle) * .01 +  cos(trail_time\n            * move_speed * -1.) ;\n        float cycle_border = shape_mask(shape_st, N, 0. + rot, \n            cycle_shape_size * 1.08, .01);\n        float cycle_mask = shape_mask(shape_st, N, 0.+ rot, \n            cycle_shape_size, .01) \n            ;\n        float cycle_mask_inside = shape_mask(shape_st, N, 0.+ rot, \n            cycle_shape_size/inner_shape_coef, .01) \n            ;\n        float cycle_mask_border_inside = shape_mask(shape_st, N, 0.+ rot, \n            cycle_shape_size / inner_shape_coef * 1.06, .01) \n            ;\n        cycle_mask_border_inside -= cycle_mask_inside;\n\n        cycle_mask -= cycle_mask_inside;\n        cycle_mask -= cycle_mask_border_inside;\n        cycle_border -= cycle_mask + cycle_mask_inside ;\n\n        cycle_border += cycle_mask_border_inside;\n        // cycle_border -= cycle_mask_inside;\n\n        float cycle_alpha = pow(trail_brightness, float(cycle));\n        float cycle_alpha_edge = pow(trail_brightness_edge, float(cycle));\n\n        // cycle_mask *= cycle_alpha;\n\n        mask = clamp(mask - cycle_border * cycle_alpha_edge, 0., 1.);\n        mask = clamp(mask + cycle_mask * cycle_alpha, 0., 1.);\n        // mask += cycle_border;\n        if(cycle == 1)\n            last_mask = cycle_mask;\n    }\n\n    color = vec3(mask);\n    color = mix(color, vec3(0.902, 0.1686, 0.1686), last_mask);\n\n\n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}