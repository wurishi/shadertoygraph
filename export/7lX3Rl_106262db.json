{"ver":"0.1","info":{"id":"7lX3Rl","date":"1622599571","viewed":215,"name":"Procedural cave generation","username":"Andrew900460","description":"Here I am using what I call \"Procedurally generated geometry\" to build caves that are based on predictable and controllable shapes.\n\nClick and drag left and right to change the distortion that is applied to the lines. They will look more organic!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["minecraft","cave","generation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat rand2d(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nbool squareHasCaveEnd(vec2 point,float threshold) {\n    return rand2d(point) > threshold;\n}\n\nbool squareHasCaveEnd(vec2 point) {\n    return squareHasCaveEnd(point,0.1);\n}\n\nivec2 getConnectedOffset(vec2 intCoord, float seed) {\n    return ivec2(\n    \tint(floor(rand2d(intCoord+vec2(seed,seed))*3.0-1.0)),\n        int(floor(rand2d(intCoord-vec2(seed,seed))*3.0-1.0))\n    );\n}\n\nivec2 getConnectedOffset(vec2 intCoord) {\n    return getConnectedOffset(intCoord,0.1);\n}\n\nvec2 getPointInSquare(vec2 intCoord) {\n    return vec2(\n    \trand2d(intCoord+vec2(0.2,0.2)),\n        rand2d(intCoord-vec2(0.2,0.2))\n    );\n}\n\nbool isPointInLine(vec2 point, vec2 vert1, vec2 vert2){\n    vec2 line = normalize(vert2-vert1);\n    vec2 a = normalize(point-vert1);\n    vec2 b = normalize(point-vert2);\n    return dot(line,a)>0.0 && dot(line,b)<0.0;\n}\n\nfloat pointDistanceToLine(vec2 point, vec2 vert1, vec2 vert2){\n    float top = abs((vert2.y-vert1.y)*point.x-(vert2.x-vert1.x)*point.y+vert2.x*vert1.y-vert2.y*vert1.x);\n    float bottom = distance(vert1,vert2);\n    return top/bottom;\n}\n\nvec2 hasCave(vec2 p,float seed){\n    vec2 result;\n    ivec2 corner = ivec2(floor(p));\n    for(int y=-1;y<=1;y++){\n    \tfor(int x=-1;x<=1;x++){\n            ivec2 offset = ivec2(x,y);\n    \t\tivec2 localCorner = corner+offset;\n            float noi = noise(vec2(localCorner)*0.05)+0.5;\n            noi = pow(noi,2.0);\n            if(squareHasCaveEnd(vec2(localCorner),noi)) {\n                ivec2 endCorner = localCorner+getConnectedOffset(vec2(localCorner),seed);\n                \n                if(squareHasCaveEnd(vec2(endCorner),0.3)) {\n                    vec2 caveStart = vec2(localCorner) + getPointInSquare(vec2(localCorner));\n                    vec2 caveEnd = vec2(endCorner) + getPointInSquare(vec2(endCorner));\n                    \n                    float dist = pointDistanceToLine(p,caveStart,caveEnd);\n                    \n                    if(distance(p,caveStart)<0.05){\n                    \tresult.y = 0.5;\n                    }\n                    if(dist < 0.05  && isPointInLine(p,caveStart,caveEnd)){\n                        result.x = 1.0;\n                    }\n                }\n            }\n    \t}\n    }\n    return result;\n}\n\nfloat octaveNoise(vec2 p){\n    float f;\n    p *= 1.0;\n    //mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    mat2 m = mat2( 2.8,  2.6, -2.6,  2.8 );\n    f  = 0.3333*noise( p ); p = m*p;\n    f += 0.1111*noise( p ); p = m*p;\n    f += 0.0370*noise( p ); p = m*p;\n    f += 0.0123*noise( p ); p = m*p;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    \n    uv*=16.0;\n    \n    \n    float morphScale = iMouse.x/1000.0;\n    \n    vec2 morphSplit = vec2(100.0,100.0);\n    \n    vec3 value;\n    vec2 cave = hasCave( uv+vec2(octaveNoise(uv)*morphScale,octaveNoise(uv+morphSplit)*morphScale),0.1 );\n    cave += hasCave( uv+vec2(octaveNoise(uv)*morphScale,octaveNoise(uv+morphSplit)*morphScale) , 0.5 );\n    value.b = cave.x;\n    value.r = cave.y;\n    //float mx = iMouse.x;\n    //value.b = float(squareHasCaveEnd(vec2(corner)));\n    \n    // Output to screen\n    fragColor = vec4(vec3(value),1.0);\n}","name":"Image","description":"","type":"image"}]}