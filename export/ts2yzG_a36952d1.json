{"ver":"0.1","info":{"id":"ts2yzG","date":"1587542753","viewed":128,"name":"blob zwy","username":"asforever123","description":"My first 3D shader\ntry blob","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdfsample"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//common\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n//ray\n#define TOLERANCE 0.01\n#define MAX_DEPTH 100.\n#define MAX_MARCHING_STEPS 255\n\n#define DIRECTIONAL_LIGHT_NUM 2\n#define POINT_LIGHT_NUM 1\n\nmat3 rotateByEuler(vec3 euler){\n\tfloat x = euler.x, y = euler.y, z = euler.z;\n    float a = cos( x ), b = sin( x );\n\tfloat c = cos( y ), d = sin( y );\n\tfloat e = cos( z ), f = sin( z );\n    float ae = a * e, af = a * f, be = b * e, bf = b * f;\n\treturn  mat3(\n    \tvec3(c * e,af + be * d,bf - ae * d),\n\t\tvec3( - c * f,ae - bf * d,be + af * d),\n        vec3(d,- b * c,a * c)\n    );\n}\n\nmat3 rotateX(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn  mat3(\n    \tvec3(1.,0.,0.),\n\t\tvec3(0.,c,-s),\n        vec3(0.,s,c)\n    );\n}\n\nmat3 rotateY(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn  mat3(\n    \tvec3(c,0.,s),\n\t\tvec3(0.,1.,0.),\n        vec3(-s,0.,c)\n    );\n}\n\nmat3 rotateZ(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn  mat3(\n    \tvec3(c,-s,0.),\n\t\tvec3(s,c,0.),\n        vec3(0.,0.,0.)\n    );\n}\n\nmat3 rotateAxis(vec3 axis,float rad){\n\tfloat c = cos( rad );\n\tfloat s = sin( rad );\n\tfloat t = 1. - c;\n\tfloat x = axis.x, y = axis.y, z = axis.z;\n\tfloat tx = t * x, ty = t * y;\n    \n\treturn  mat3(\n    \tvec3(tx * x + c,tx * y + s * z, tx * z - s * y),\n\t\tvec3(tx * y - s * z,ty * y + c,ty * z + s * x),\n        vec3(tx * z + s * y,ty * z - s * x,t * z * z + c)\n    );\n}\n\nstruct Camera{\n\tvec3 eye;\n};\n\nstruct DirectionalLight{\n\tvec3 diffuse;\n    vec3 specular;\n    vec3 dir;\n    float intensity;\n};\n\nstruct PointLight{\n    vec3 diffuse;\n    vec3 specular;\n    vec3 position;\n\tfloat constant;\n    float linear;\n    float quadratic;\n    float intensity;\n};\n\nstruct Geometry{\n\tvec3 position;\n    vec3 normal;\n};\nstruct Material{\n\tvec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n};\n\nfloat sphereSDF(vec3 p,float radius){\n\treturn length(p) - radius;\n}\n\nfloat boxSDF(vec3 p,float l,float w,float h){\n    vec3 d = abs(p) - vec3(l,w,h);\n\treturn length(max(d,0.0));\n}\n\nfloat planeSDF(vec3 p,vec3 normal){\n\treturn dot(p,normal);\n}\n//https://www.shadertoy.com/view/Xls3R7\nfloat blob(float d1,float d2,float d3,float d4){\n    float k = 3.;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4))/k;\n}\n\nfloat sceneSDF(vec3 p){\n    float x = 3.0*sin(iTime*2.);\n    float z = 3.0*cos(iTime*2.);\n    vec3 a = vec3(0.,-z-1.,x);\n    vec3 b = vec3(x,z-1.5,0.);\n    vec3 v = vec3(-x,z-1.5,-.5);\n    \n\tfloat sphere = sphereSDF(p + a,2.);\n    float sphere1 = sphereSDF(p + b,2.);\n    float box = boxSDF(p + v,1.,1.,1.);\n    float plane = boxSDF(p + vec3(.0,2.,0.),10.,.2,10.);\n   \treturn blob(sphere,box,sphere1,plane);\n}\n\n//https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p )\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h ) + \n                      k.yyx*sceneSDF( p + k.yyx*h ) + \n                      k.yxy*sceneSDF( p + k.yxy*h ) + \n                      k.xxx*sceneSDF( p + k.xxx*h ) );\n}\n\nvec3 ray(vec2 uv,float fovy,float aspect){\n    float z = -1./tan(fovy/2.);\n    return normalize(vec3(uv.x*aspect,uv.y,z));\n}\n\nfloat rayCast(vec3 ro,vec3 rd){\n   float depth = 0.;\n   for(int i=0;i<MAX_MARCHING_STEPS&&depth<MAX_DEPTH;i++){\n      vec3 pos = ro + rd * depth;\n      float distance = sceneSDF(pos);\n      depth+=distance;\n   }\n   return depth;\n}\n\n\nReflectedLight calcReflectedLight(\n    Camera camera,\n    DirectionalLight directionalLights[DIRECTIONAL_LIGHT_NUM],\n\tPointLight pointLights[POINT_LIGHT_NUM],\n    Geometry geometry,\n    Material material\n){\n    vec3 diffuse = vec3(0.);\n    vec3 specular = vec3(0.);\n    \n    vec3 position = geometry.position;\n    vec3 mDiffuse = material.diffuse;\n    vec3 mSpecular = material.specular;\n    float shininess = material.shininess;\n    \n    vec3 N = geometry.normal;\n    vec3 V = camera.eye - position;\n    \n    ReflectedLight reflectedLight;\n    for(int i =0;i<DIRECTIONAL_LIGHT_NUM;++i){\n    \tDirectionalLight directionalLight = directionalLights[i];\n     \n        vec3 dDiffuse = directionalLight.diffuse;\n        vec3 dSpecular = directionalLight.specular;\n        \n        float intensity = directionalLight.intensity;\n        \n        vec3 L = -normalize(directionalLight.dir);\n        vec3 R = reflect(-L,N);\n        vec3 H = normalize(V + L);\n    \n        float dotNL = dot(N,L);\n        float dotNH = dot(N,H);\n        float spec = pow(max(0.,dotNH),shininess);\n        \n        diffuse += dDiffuse*dotNL*mDiffuse*intensity;\n        specular += dSpecular*spec*mSpecular*intensity;\n    }\n   \n    reflectedLight.directDiffuse = diffuse;\n    reflectedLight.directSpecular = specular;\n    return reflectedLight;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord/iResolution.xy-1.;\n\n   \t//camera\n    float aspect = iResolution.x/iResolution.y;\n    float fovy = PI/3.;\n    float angleX = PI/4.;\n    float angleY = iMouse.x/100.;\n    mat3 cameraMat = rotateY(angleY) * rotateX(angleX);\n    vec3 ro = cameraMat * vec3(0.,0.,15.);\n    vec3 rd = cameraMat * ray(uv, fovy, aspect);\n    float depth = rayCast(ro,rd);\n    \n\n    //geometry\n    vec3 p = ro + rd * depth;\n    vec3 n = calcNormal(p);\n    Geometry geometry = Geometry(p,n);\n    //material\n    vec3 diffuse = vec3(0.4,0.7,0.9);\n    vec3 specular = vec3(1.);\n    Material material = Material(diffuse,specular,32.);\n    //lights\n    DirectionalLight directionalLight = DirectionalLight(\n        vec3(0.6),\n        vec3(0.4),\n        vec3(0.0,-1.0,0.0),\n        1.\n    );\n    DirectionalLight directionalLight1 = DirectionalLight(\n        vec3(.6,0.2,0.7),\n        vec3(0.4),\n   \t\tvec3(0.0,-0.4,-1.),\n        1.\n    );\n    \n    PointLight pointLight = PointLight(\n     \tvec3(1.),\n        vec3(0.),\n        vec3(-1.,-1.,-1.),\n        1.,\n        0.01,\n        0.00032,\n        1.\n    );\n   \n    \n    DirectionalLight directionalLights[DIRECTIONAL_LIGHT_NUM];\n    PointLight pointLights[POINT_LIGHT_NUM];\n    directionalLights[0] = directionalLight;\n    directionalLights[1] = directionalLight1;\n    pointLights[0] = pointLight;\n    //lights\n    Camera camera = Camera(ro);\n    \n   \n    \n    ReflectedLight reflectedLight = calcReflectedLight(\n        camera,\n        directionalLights,\n        pointLights,\n        geometry,\n        material\n        \n    );\n\n    //result\n    vec3 color = reflectedLight.directDiffuse + reflectedLight.directSpecular;\n        \n    if(depth>=MAX_DEPTH){\n    \tfragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n        \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}