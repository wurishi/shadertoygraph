{"ver":"0.1","info":{"id":"ds2GWD","date":"1667641490","viewed":320,"name":"glass cylinder","username":"celyk","description":"a","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"mdBGW1","parentname":"Fork Fork menis celyk 903"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_RAYS = 5;\nconst int SSAA = 3;\n\n\nHit getCylinderIntersection(vec3 ro,vec3 rd,vec2 r,bool invert){\n    Hit hit = noHit;\n    \n    vec4 tnor = cylIntersect(ro,rd,vec3(0,-r.y,0),vec3(0,r.y,0),r.x);\n    \n    float w = .04;\n    \n    hit.t = tnor.x;\n    hit.p = ro + rd*hit.t;\n    hit.n = tnor.yzw; \n    hit.n = normalize(\n        hit.p - NearestCylinderPoint(\n            hit.p,vec3(0,-(r.y-w),0),vec3(0,r.y-w,0),r.x-w)); \n    \n    hit.mat.emission = vec3(0);\n    hit.mat.specular = invert?0.0:1.0;\n    hit.mat.ior = invert?1.0:1.5;\n    \n    if(hit.t<=0.){\n        tnor = cylIntersect(ro+rd*100.,-rd,vec3(0,-r.y,0),vec3(0,r.y,0),r.x);\n        \n        if(tnor.x > 0.){\n            hit.t = 100. - tnor.x;\n            hit.p = ro + rd*hit.t;\n            hit.n = -tnor.yzw;\n            hit.n = -normalize(\n                hit.p - NearestCylinderPoint(\n                    hit.p,vec3(0,-(r.y-w),0),vec3(0,r.y-w,0),r.x-w));  \n\n            hit.mat.emission = vec3(0);\n            hit.mat.specular = invert?1.0:0.0;\n            hit.mat.ior = invert?1.5:1.0;\n        }\n    }\n\n\n    return hit;\n}\n\nHit trace(Ray ray){\n    Hit hit = getCylinderIntersection(ray.ro,ray.rd,vec2(1),false);\n    Hit hit2 = getCylinderIntersection(ray.ro,ray.rd,vec2(.9),true);\n    \n    hit = chooseNearest(hit,hit2);\n    if(hit.t <= 0.){\n        hit = noHit;\n        hit.mat.albedo = vec3(0);\n        hit.mat.emission = vec3(0);\n        hit.mat.specular = 0.0;\n        hit.mat.ior = -1.0;\n    }\n    \n    return hit;\n}\n\nvec3 shade(Ray ray,Hit hit){\n    vec3 ld = normalize(vec3(1,.7,1));\n    vec3 L = vec3(0);\n    \n    \n    L += hit.mat.emission;\n    \n    vec3 T = textureLod(iChannel0,hit.p,2.).xyz - .05;\n    vec3 n = hit.n + T.xyz*.02;\n    vec3 rd1 = reflect(ray.rd,n);\n    \n    L += hit.mat.specular*4.*pow(1.-textureLod(iChannel0,rd1,2.).xyz,vec3(20.));\n    \n    \n    return L;\n}\n\nvec3 Sample(Ray ray){\n    vec3 col = vec3(0);\n    \n    float current_ior = 1.0;\n    \n    for(int i=0; i<MAX_RAYS; i++){\n        Hit hit = trace(ray);\n\n        col += shade(ray,hit);\n        \n        // if the material is opaque, break out of the loop\n        if(hit.mat.ior <= 0.0) break;\n            \n        vec3 new_rd = refract(ray.rd,hit.n,current_ior/hit.mat.ior);\n\n        if(new_rd != vec3(0)){\n            ray.ro = hit.p - hit.n*.01;\n            ray.rd = new_rd;\n\n            current_ior = hit.mat.ior;\n        }\n        else{\n            ray.ro = hit.p + hit.n*.01;\n            ray.rd = reflect(ray.rd,hit.n);\n        }\n    }\n    \n    col += pow( 1.-textureLod(iChannel0,ray.rd,0.0) , vec4(2.2) ).xyz;\n        \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n    fragColor = vec4(0,0,0,1);\n    \n    // supersampling\n    for(int i = 0; i<SSAA; i++)\n    for(int j = 0; j<SSAA; j++){\n        vec2 o = vec2(float(i),float(j)) / float(SSAA) - 0.5;\n        vec2 uv = (2.0*(fragCoord + o) - iResolution.xy)/iResolution.y*.2;\n        vec2 m = (2.0*iMouse.xy - iResolution.xy)/iResolution.y*3.;\n        \n        //m = vec2(1,.3);\n        \n        // set up camera ray\n        Ray ray = Ray(vec3(0,0,-8),normalize(vec3(uv,1)));\n        ray.ro.yz *= rot(-m.y);\n        ray.rd.yz *= rot(-m.y);\n        ray.ro.xz *= rot(-m.x);\n        ray.rd.xz *= rot(-m.x);\n        \n        ray.ro += vec3(0,0,0);\n        \n        // compute a sample\n        fragColor.xyz += Sample(ray);\n    }\n    fragColor.xyz /= float(SSAA*SSAA);\n    \n    \n    // tonemapping\n    fragColor.xyz = 1.-exp(-fragColor.xyz);\n    \n    // transfer linear color to srgb\n    fragColor = pow(fragColor,vec4(1)/2.2);\n    \n    // debanding\n    fragColor += (texture(iChannel1,fragCoord/iChannelResolution[1].xy) - .5)/255.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926;\nmat2 rot(float c){float s=sin(c);return mat2(c=cos(c),s,-s,c);}\n\n// data structures\nstruct Ray{\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Material{\n    vec3 albedo;\n    vec3 emission;\n    float specular;\n    float ior;\n};\nconst Material noMat = Material(vec3(0),vec3(1,0,1),0.0,-1.0);\n\nstruct Hit{\n    float t;\n    vec3 p;\n    vec3 n;\n    Material mat;\n};\nconst Hit noHit = Hit(-1.0,vec3(0),vec3(0),noMat);\n\n\nHit chooseNearest(Hit a,Hit b){\n    if(a.t <= 0.) return b;\n    if(b.t <= 0.) return a;\n    \n    if(b.t<a.t){\n        a = b;\n    }\n    \n    return a;\n}\n\nfloat dot2(vec3 v){return dot(v,v);}\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n// cylinder defined by extremes pa and pb, and radious ra\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ba = pb-pa;\n    vec3 oc = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);//no intersection\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return vec4( t, (oc+t*rd - ba*y/baba)/ra );\n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        return vec4( t, ba*sign(y)/sqrt(baba) );\n    }\n    return vec4(-1.0);//no intersection\n}\n\nvec3 NearestCylinderPoint(vec3 p,vec3 a,vec3 b,float r){\n    p -= a;\n    b -= a;\n    \n    float t = dot(p,b)/dot(b,b);\n    \n    p -= b*t;\n    \n    float l = length(p);\n    \n    if(l > r) p = p/l*r;\n    //p = p/max(l,1.0);\n    \n    p += b*clamp(t,0.,1.);\n    \n    return p + a;\n}","name":"Common","description":"","type":"common"}]}