{"ver":"0.1","info":{"id":"4lBfWR","date":"1515215804","viewed":766,"name":"Ray-marching with phong shading","username":"Brendan","description":"A ray-marcher with phong shading. I'm not quite sure I got the phong shading right (the wikipedia article was super confusing) but i tried my best. Please like and it will make my day :)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float EPSILON = 0.001;\nconst float limit = 100.0;\n\n\n//material parameters\nconst float ks = 3.0;\nconst float kd = 3.0;\nconst float ka = 1.0;\nconst float al = 20.0;\n//light parameters\nconst float ia = 1.0;\nconst vec3 lm = normalize(vec3(5,3,-1));\nconst float id = 1.0;\nconst float is = 1.0;\n\nfloat map(vec3 p){\n\t\n\t// Repeat cubic grid. \n\t// Equivalent to the following: p = mod(p, 3.) - 1.5;\n\tp = fract(p/3.)*3. - 1.5; // Note the division by 3.\n\n\treturn length(p) - .5;\n}\n\nfloat march(vec3 o, vec3 r){\n \t\n    float t = 0., d;\n    \n    for(int i=0;i<64;++i){\n       \n        d = map(o+r*t);\n        \n        if(d<EPSILON || t>limit) break;\n        \n        t+=d;\n    }\n    \n    return min(t, limit);\n}\n\nvec3 phong(vec3 n, vec3 v){\n    \n    vec3 rm = 2.0*dot(lm,n)*n-lm;\n    \n    float ip = ka*ia+(kd*clamp(dot(lm,n),0.0,1.1)*id + ks*pow(clamp(dot(rm,v),0.0,1.0),al)*is);\n    \n    return ip*vec3(0.1,0.2,0.5);\n        \n   }\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x+EPSILON,p.y,p.z))-map(vec3(p.x-EPSILON,p.y,p.z)),\n        map(vec3(p.x,p.y+EPSILON,p.z))-map(vec3(p.x,p.y-EPSILON,p.z)),\n        map(vec3(p.x,p.y,p.z+EPSILON))-map(vec3(p.x,p.y,p.z-EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0;\n\n    uv.x*= iResolution.x/iResolution.y;\n    \n    float theta = iTime/20.0;\n    \n    //took me forever to figure out this\n    mat3 rotate = mat3(\n        cos(theta),sin(theta),0,\n        -sin(theta),cos(theta),0,\n        0,0,1\n        );\n\n    vec3 r = normalize(vec3(uv,2))*rotate;\n\n    vec3 o = vec3(iTime/2.0,0,iTime/2.0);\n\n    float t = march(o,r);\n\n    if((t == limit) || map(t * r + o)>EPSILON){\n        fragColor = vec4(0,0,0,1);\n    }else{\n        \n    vec3 fc = pow(phong(getNormal(t*r+o),-r),vec3(1));\n\n\tfragColor = vec4(fc, 1);\n\n    }\n}","name":"Image","description":"","type":"image"}]}