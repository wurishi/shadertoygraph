{"ver":"0.1","info":{"id":"ldVfDc","date":"1530921030","viewed":196,"name":"Flight over Eggland","username":"rkibria","description":"So many omelettes!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThanks to\n\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://iquilezles.org/articles/distfunctions\nhttp://shadertoy.wikia.com/wiki/Noise\n\n*/\n\n#define MAX_MARCHING_STEPS 100\n#define EPSILON 0.1\n#define MAX_DIST 1000.0\n\nfloat rand(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p - s)-s;\n}\n\nfloat sdf( in vec3 p )\n{\n    const float r = 3.5;\n    vec3 q = vec3(\n        p.x,\n        p.z,\n        p.y +\n        \t(2.0 * r\n               \t* sin(1.1 - 0.1 * length(p.zy))\n            )\n        \t* 1.3\n        \t* cos( p.x * 0.03 + p.z * 0.02 )\n        \t* cos( 0.5 + p.x * 0.01 + p.z * 0.005 )\n    \t);\n\n    float d = sdSphere(\n        vec3(\n            mod( q.x, 2. * r ),\n            mod( q.y, 2. * r ),\n            q.z\n        ), r );\n\treturn d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 background(in vec2 uv)\n{\n    return mix( vec3(1., 1., 1.), vec3( 0.2, 0.2, 1. ), uv.y *2. + 0.5 );\n}\n\nvec3 lighting(in vec2 uv, in vec3 eye, in vec3 pos, in vec3 n)\n{\n    vec3 a = vec3( 0.05 + max(0., dot(n, vec3(1., 0.5, -0.5)) ) );\n\n    // Linear fog\n    float d = length(pos - eye);\n    vec3 cf = background(uv);\n    const float ze = 1000.;\n    const float za = 30.;\n    float f = (ze - d) / (ze - za);\n    \n    a = mix(cf, a, f);\n    \n    return a;\n}\n\nvec3 march(in vec2 uv, in vec3 eye, in vec3 ray)\n{\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + depth * ray;\n        float dist = sdf( pos );\n        if( dist < EPSILON ) {\n            return lighting( uv, eye, pos, estimateNormal( pos ) );\n        }\n\n        depth += dist;\n\n        if ( depth >= MAX_DIST ) {\n            return background(uv);\n        }\n    }\n    return background(uv);\n}\n\nmat4 rotZMatrix(in float phi)\n{\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    cos_phi,      sin_phi,        0.0,            0.0,\n\t    -sin_phi,     cos_phi,        0.0,            0.0,\n\t    0.0,          0.0,            1.0,            0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.x;\n    \n    vec3 eye = vec3(\n        80. * cos(iTime),\n        20. + 15.*(sin(iTime)+1.),\n        100. * iTime\n    \t);\n\n    vec3 col = vec3( 0 );\n    const int N = 3;\n    float dd = 1./iResolution.x;\n    vec3 ray0 = normalize( vec3( 1.5 * uv, 1. ) );\n    mat4 rmat = rotZMatrix(0.2 * sin(iTime));\n    for(int i = 0; i < N; ++i)\n    {\n        vec3 ray = ray0 + vec3(\n            (rand(iTime + float(i)     ) - 0.5) * 2. * dd,\n            (rand(iTime + float(i) + 1.) - 0.5) * 2. * dd,\n            (rand(iTime + float(i) + 2.) - 0.5) * 2. * dd\n        \t);\n\n        ray = (rmat * vec4(ray, 0.)).xyz;\n\t    col += march( uv, eye, ray );\n    }\n    col /= float(N);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}