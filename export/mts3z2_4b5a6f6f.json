{"ver":"0.1","info":{"id":"mts3z2","date":"1672089351","viewed":68,"name":"Understanding Ocean [BROKEN]","username":"ang_rq","description":"Ocean","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define DRAG_MULT 0.048\n#define ITERATIONS_RAYMARCH 13\n#define ITERATIONS_NORMAL 48\n#define MAX_DIST 100.\n#define eps 0.001\n\n#define Mouse (iMouse.xy / iResolution.xy)\n#define Resolution (iResolution.xy)\n#define Time (iTime)\n\n\n\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = (axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n\nvec3 getRay(vec2 uv){\n    //uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n    if(Resolution.x < 400.0) return proj;\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\n    return ray;\n}\n\n\nfloat SDFsphere(vec3 p, float r)\n{\n    return length(p)-r;\n\n}\n\nfloat getDist(vec3 p)\n{\n    return SDFsphere(p, 0.92);\n\n}\n\n\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    float epss = 0.00001;\n    return normalize(vec3(d-getDist(vec3(p.x-epss, p.y, p.z)),\n                d-getDist(vec3(p.x, p.y-epss, p.z)),\n                d-getDist(vec3(p.x, p.y, p.z-epss))));\n}\n\n\n\n\nfloat rayMarch(vec3 origin, vec3 dir)\n{\n    float dist = 0.;\n    vec3 p = origin;\n    float d = 0.;\n    for(int i = 0; i <= ITERATIONS_RAYMARCH; i++)\n    {\n        if(dist < MAX_DIST)\n        {\n            d = getDist(p + dist*dir);\n            if(d > eps)\n                dist += d;\n            else\n                return dist;\n        }\n        else\n            return -1.;\n    \n    }\n\n    return dist;\n\n}\n\n\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\n\t//sundir.y = max(sundir.y, -0.07);\n\tfloat special_trick = 1.0 / (raydir.y * 2.0 + 0.2);\n\tfloat special_trick2 = 1.0 / (sundir.y * 1.0 + 1.0);\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 80.0);\n\tfloat mymie = sundt * special_trick * 0.2;\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 220.4 * suncolor;\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n\treturn bluesky2 * (1.0 + 2.0 * pow(1.0 - raydir.y, 1.0));// + mymie * suncolor;\n} \nvec3 getatm(vec3 ray){\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\n    \n}\n\nfloat sun(vec3 ray){\n \tvec3 sd = normalize(vec3(1.0));   \n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\n}\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\n    \n\tfloat waterdepth = 2.1;\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\n    \n    vec3 ray = getRay(uv);\n    \n    float hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n    \n    if(ray.y >= -0.09){\n        vec3 C = getatm(ray) * 2.0;// + sun(ray);\n        //tonemapping\n    \tC = aces_tonemap(C);\n     \tfragColor = vec4( C,1.0);   \n        return ;\n    }\n    fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    /*\n    vec3 mysun = vec3(-1., -1., -2.);\n    mysun = normalize(mysun);\n    \n    vec3 dir = getRay(uv);\n    vec3 n = vec3(0.);\n    float dist = rayMarch(orig, dir);\n    if(dist > 0.)\n    {\n        n = getNormal(orig + dist*dir);\n        float col = dot(sun, n);\n        fragColor = vec4(col);\n        \n    }\n    else\n        fragColor = vec4(0.);\n    */\n    \n}","name":"Image","description":"","type":"image"}]}