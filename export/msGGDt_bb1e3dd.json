{"ver":"0.1","info":{"id":"msGGDt","date":"1679347897","viewed":143,"name":"Glass of Coca-Cola","username":"ianertson","description":"Use the mouse to look around :)\n\nChallenge:\nAdd carbonation / bubbles :)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarching","ray","sdf","rays","raytrace","cola","cocacola"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 iceTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(124, 158, 202);\n    vec3 c2 = rgb(184, 216, 220);\n    vec3 c3 = rgb(232, 245, 246);\n    vec3 c4 = rgb(196, 217, 242);\n    \n    vec3 hf1 = snoise(uv, 0.003882, 0.5, 32.0, 6);\n    vec3 lf1 = snoise(uv, 1.202939, 0.3, 8.0, 6);\n    vec3 lf2 = snoise(uv, 5.595983, 0.3, 8.0, 6);\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    col += col1;\n    \n    float wet = smoothstep(0.2, 0.7, lf1.z);\n    col = mix(col, col*col, wet);\n    \n    float cracks = max(0.0, 1.0-smoothstep(0.001, 0.04, abs(lf1.x-lf2.x)));\n    cracks *= hf1.y;\n    \n    col = mix(col, c3, cracks);\n    \n    m.ior = mix(mix(1.309, 1.33, wet), 0.1, cracks);\n    m.spec = mix(1.0, 0.02, cracks);\n    m.rough = mix(0.02, 1.0, cracks);\n    \n    return col;\n}\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 g1 = rgb(118, 167, 66);\n    vec3 g2 = rgb(113, 118, 38);\n    vec3 g3 = rgb(131, 144, 86);\n    vec3 g4 = rgb(53, 76, 31);\n\n    vec3 d1 = rgb(125, 116, 108);\n    vec3 d2 = rgb(100, 86, 51);\n    vec3 d3 = rgb(124, 100, 76);\n    vec3 d4 = rgb(71, 55, 40);\n    \n    vec3 hf1 = snoise(uv, 0.39281254, 0.5, 120.0, 6);\n    vec3 hf2 = snoiseWarp(uv, 5.58983955, 0.5, 64.0, 6, 0.5);\n    vec3 lf1 = snoise(uv, 9.982773828, 0.3, 8.0, 6);\n    vec3 lf2 = snoise(uv, 16.66899344, 0.3, 4.0, 6);\n    \n    vec3 grassCol = mix4(g1, g2, g3, g4, hf1);\n    col += grassCol;\n    \n    vec3 dirtCol = mix4(d1, d2, d3, d4, hf2);\n    \n    float dirtReg1 = smoothstep(0.4, 0.7, lf1.x);\n    float dirtReg2 = smoothstep(0.4, 0.7, lf2.x);\n    float dirtReg = (dirtReg1+dirtReg2)/2.;\n    \n    col = mix(col, dirtCol, dirtReg);\n   \n    float wetReg1 = smoothstep(0.2, 0.8, lf1.y);\n    float wetReg2 = smoothstep(0.2, 0.8, lf2.y);\n    float wetReg = (wetReg1+wetReg2)/2.;\n    \n    col = mix(col, col*col, wetReg);\n    \n    m.spec = clamp(pow(((wetReg+dirtReg)/2.)*((hf2.z+lf1.y)/2.), 2.5), 0.0, 1.0);\n    \n    m.z = clamp(1.0-((dirtReg+wetReg)), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 colaTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1  = rgb(130, 44, 20);\n    vec3 c2 = rgb(74, 20, 14);\n    vec3 c3 = rgb(45, 35, 32);\n    vec3 c4 = rgb(69, 16, 10);\n    \n    /*\n    vec3 w1 = rgb(212, 132, 100);\n    vec3 w2 = rgb(224, 216, 199);\n    vec3 w3 = rgb(180, 166, 141);*/\n\n    vec3 hf1 = snoise(uv, 0.000333, 0.5, 64.0, 6);\n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    col += col1;\n    \n    return col;\n}\n\nvec3 plankTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 0.0321122, 0.33, 128.0, 6);\n    vec3 hf2 = snoise(uv, 1.0928325, 0.5, 128.0, 6);\n    \n    vec3 lf1 = snoise(uv, 4.3092911, 0.1, 4.0, 6);\n    \n    vec3 c1 = rgb(159, 112, 90);\n    vec3 c2 = rgb(204, 131, 74);\n    vec3 c3 = rgb(156, 126, 108);\n    vec3 c4 = rgb(99, 54, 30);\n    vec3 c5 = rgb(230, 192, 141);\n    \n    vec3 col1 = mix(mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z), c5, hf2.x*hf2.x);\n    col += col1;\n    \n    float tile = 2.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float lines = mod(length(vec2(alv.x/2., alv.y)), 0.4*cos(alv.y*(TAU-(alv.x/2.+hf2.y)))*hf2.z);\n    lines = max(0.002, 1.0-max(0.0, 0.5-lines));\n    \n    col = mix(col, col*col*col, lines);\n    \n    float x = 1.0+fract(uv.x/2.);\n    \n    float w2 = fract(mod((x*tile)*10.*lf1.y, sin((uv.y*tile)*TAU)*2.));\n    col = mix(col, mix(c1, c5, hf1.z), w2*0.6);\n    \n    float t2 = fract(uv.y*tile*2.);\n    float gs = smoothstep(0.5-0.25, 0.5+0.25, abs(t2*2.0-1.0)-0.5);\n    col = mix(col, col*col, gs);\n    \n    m.z = clamp(1.0-((gs*0.1)+(lines*0.5)), 0.0, 1.0);\n    m.spec = clamp(w2*lf1.y, 0.0, 1.0);\n    \n    return col;\n}\n\n#define ID_GROUND 0\n#define ID_BOX1 1\n#define ID_ICE 2\n#define ID_CUP 3\n#define ID_COLA 4\n\nfloat getGroundHeight(in vec3 p) { return 0.0; }\n\nfloat cupSDF(in vec3 p, in float h, in float r) {\n    r = mix(r, r*0.5, smoothstep(0.0, 0.7, max(0.0, h-p.y)));\n    float d = cylSDF(p, vec3(0, 0, 0), vec3(0, h, 0), r);\n    float inside = cylSDF(p - vec3(0, 0.03, 0), vec3(0, 0, 0), vec3(0, h, 0), r*0.915);\n    d = smax(d, -inside, 0.03);\n    return d/1.4;\n}\n\nfloat colaSDF(in vec3 p, in float r, in float cupH) {\n    float h = cupH*0.5;\n    r -= 0.004;\n    \n    r = mix(r, r*0.5, smoothstep(0.0, 0.7, max(0.0, cupH-p.y)));\n    float d = cylSDF(p, vec3(0, 0, 0), vec3(0, h, 0), r);\n\n    return d;\n}\n\nMARCHER(\n    // ray origin\n    vec3(0, 0.6, -1.),\n    // Scene\n    {\n        float ground = groundSDF(p);\n        SAMPLE(ground, 1.0, ID_GROUND);\n        \n        float box1 = boxSDF(p - vec3(0, 0.2, 0), vec3(0.4, 0.2, 0.4)) - 0.05;\n        SAMPLE(box1, 1.0, ID_BOX1);\n        \n        p.y -= 0.4;\n        \n        float cup = cupSDF(p, 0.5, 0.22);\n        SAMPLE(cup, 0.5, ID_CUP);\n        \n        float ice1 = boxSDF(p - vec3(0.05, 0.35, 0), vec3(0.034));\n        SAMPLE(ice1, 1.0, ID_ICE);\n        \n        float ice2 = boxSDF(p - vec3(-0.05, 0.35, 0.09), vec3(0.034));\n        SAMPLE(ice2, 1.0, ID_ICE);\n        \n        float cola = colaSDF(p - vec3(0, 0.1, 0), 0.22, 0.5);\n        cola = max(cola, -min(ice1, ice2));\n        SAMPLE(cola, 1.0, ID_COLA);\n    },\n    // Textures    \n    {\n        case ID_GROUND: {\n            vec3 col = grassTexture(uv, data.p, data.m);\n            data.n = makeNormal(data.n, data.m.z, 0.3, 0.5);\n            return col;\n        }; break;\n        case ID_BOX1: {\n            vec3 col = plankTexture(uv, data.p, data.m);\n            data.n = makeNormal(data.n, data.m.z, 0.4, 0.5);\n            return col;\n        }; break;\n        case ID_ICE: {\n            vec3 col = iceTexture(uv, data.p, data.m);\n            return col;\n        }; break;\n        case ID_COLA: {\n            data.m.ior = 1.33;\n            data.m.rough = 0.2;\n            vec3 col = colaTexture(uv, data.p, data.m);\n            return col;\n        }; break;\n        case ID_CUP: {\n            data.m.ior = 1.6;\n            data.m.rough = 0.2;\n            return vec3(0.15);\n            break;\n        }; break;\n    },\n    // Setup lights\n    Light[2](\n        Light(vec3(1, 2, -3), vec3(0.0), COLOR_SUN, 1.5, LIGHT_AMBIENT),\n        Light(vec3(0, 8, 0), normalize(vec3(sin(T+2.2938215), -1, cos(T+3.3092815))), vec3(1, 0.2, 0.2), 4.0, LIGHT_DIR)\n    ),\n    // How many lights\n    2\n)\n\nvoid mainImage( out vec4 O, in vec2 fc ) {\n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    O = vec4(DEBUG_TEXTURE(fc.xy/R.xy, vec3(0.0), ma), 1.0);\n    #else\n    O = blit(fc);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, ALPHA, id_)\\\n    alpha = min(alpha, ALPHA);\\\n    if ((!(ALPHA < 0.93 && skip_trans)) && (ALPHA < 0.93 ? !skip_trans : skip_trans) && id_ != skip && var < dist) {\\\n      id = id_;\\\n      dist = var;\\\n      alpha = min(alpha, ALPHA);\\\n    }\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.001\n#define AMBIENT 0.05\n#define NUM_BOUNCES 2\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n#define ID_NONE -1\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, FAR, ID_NONE, ID_NONE, NEW_MATERIAL, 1.0, 1.0, true, 0)\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    float alpha_d;\n    int skip;\n    int id;\n    Material m;\n    float sig;\n    float alpha;\n    bool skip_trans;\n    int count;\\\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves);\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp);\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y)); uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U; p ^= (p << 17U); s ^= (~p.x); s ^= (~p.y);\n    p ^= (p >> 11U); p ^= (p << 5U); p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) {return float(hash21u(ip, seed))/float(0xFFFFFFFFU);}\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed); n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0003) return wn;\n    cp = normalize(cp);   \n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0003) return wn;\n    return next;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\n#define MARCHER(RAY_ORIGIN, SDF_FUN, TEX_LOOKUP, LIGHTS, NUM_LIGHTS)\\\n    vec3 snoise(in vec2 p, in float seed, in float lod) {\\\n        p += 0.99288124;\\\n        vec2 id = floor(p);\\\n        vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\\\n        return mix(\\\n            mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\\\n            mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\\\n            lv.y\\\n        );\\\n    }\\\n    vec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\\\n        p += 0.99288124;\\\n        float div = 0.0;\\\n        float amp = 1.0;\\\n        vec3 n = vec3(0.0);\\\n        for (int i = ZERO; i < octaves; i++) {\\\n            n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\\\n        }\\\n        return n / div;\\\n    }\\\n    vec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\\\n        p += 0.99288124;\\\n        float div = 0.0;\\\n        float amp = 1.0;\\\n        vec3 n = vec3(0.0);\\\n        for (int i = ZERO; i < octaves; i++) {\\\n            n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\\\n            p += (n.xy*n.z)*warp;\\\n        }\\\n        return n / div;\\\n    }\\\n    mat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\\\n    float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\\n    vec3 aces(vec3 x) { return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\\\n    vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\\\n        return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\\\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\\\n    }\\\n    struct Ray {\\\n        vec3 ro;\\\n        vec3 rd;\\\n    };\\\n    \\\n    \\\n    struct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\\\n    \\\n    vec3 getLightDir(in Light light, in vec3 p) {\\\n        return light.type == LIGHT_AMBIENT ? normalize(light.p) :\\\n               light.type == LIGHT_POINT ? normalize(light.p - p) :\\\n               normalize(-light.d);\\\n    }\\\n    \\\n    vec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\\\n        vec3 L = getLightDir(light, p);\\\n        float NdotL = max(AMBIENT, dot(n, L));\\\n        \\\n        switch (light.type) {\\\n            case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\\\n            case LIGHT_POINT: return light.c * NdotL * (\\\n                pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\\\n            ); break;\\\n            case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\\\n                normalize(light.p - p),\\\n                L\\\n            )); break;\\\n        }\\\n        \\\n        return vec3(0.0);\\\n    }\\\n    vec2 boxUv(in vec3 p, in vec3 n) {\\\n        return mix(mix(p.xy, p.zy, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\\\n    }\\\n    \\\n    vec2 sphereUv(in vec3 p) {\\\n        float u = acos(p.y);\\\n        float v = atan(p.x, p.z);\\\n        \\\n        u = 0.5 - u / M_PI;\\\n        v = 0.5 + v / M_PI;\\\n        return vec2(u, v);\\\n    }\\\n    float getGroundHeight(in vec3 p);\\\n    float groundSDF(in vec3 p) {\\\n        return p.y - getGroundHeight(p);\\\n    }\\\n    float sdf(inout Data data, in vec3 p) {\\\n        int skip = data.skip;\\\n        int id = ID_NONE;\\\n        float dist = FAR;\\\n        float alpha_dist = FAR;\\\n        bool skip_trans = data.skip_trans;\\\n        float alpha = 1.0;\\\n        int count = data.count;\\\n        SDF_FUN\\\n        data.id = id;\\\n        data.alpha = alpha;\\\n        return dist;\\\n    }\\\n    \\\n    bool march(inout Data data, in vec3 ro, in vec3 rd) {\\\n        float d = 0.0;\\\n        float sig = data.sig;\\\n        for (int i = ZERO; i < STEPS; i++) {\\\n            vec3 p = ro+rd*d;\\\n            float next = sig * sdf(data, p);\\\n            d += next;\\\n            if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\\\n            if (abs(d) >= FAR) return false;\\\n        }\\\n        \\\n        vec3 p = ro+rd*d;\\\n        vec2 e = vec2(NORMAL_RANGE, 0.0);\\\n        vec3 n = normalize(sdf(data, p) - vec3(\\\n            sdf(data, p - e.xyy),\\\n            sdf(data, p - e.yxy),\\\n            sdf(data, p - e.yyx)\\\n        ));\\\n        \\\n        data.d = d;\\\n        data.p = p;\\\n        data.n = n;\\\n        \\\n        return true;\\\n    }\\\n    \\\n    float getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float far, in int skip) {\\\n        float NdotL = cdot(n, rd);\\\n        if (NdotL <= SHADOW_NDOTL_EPSILON) return 1.0;\\\n        \\\n        Data data = NEW_DATA;\\\n        data.skip = skip;\\\n        \\\n        float d = 0.0;\\\n        float r = 1.0;\\\n        for (int i = ZERO; i < SHADOW_STEPS; i++) {\\\n            vec3 p = ro+rd*d;\\\n            float next = sdf(data, p);\\\n            r = min(r, next/0.44);\\\n            d += next*0.13;\\\n            if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\\\n            if (abs(d) >= far) break;\\\n        }\\\n        \\\n        return clamp(r + 0.77*(d / (1.0 + d)), AMBIENT, 1.0);\\\n    }\\\n    \\\n    Ray getRay(in vec2 uv, in vec4 m) {\\\n        vec3 org = RAY_ORIGIN;\\\n        vec3 ro = vec3(0, 0, org.z);\\\n        vec3 rd = normalize(vec3(uv.xy, 1.0));\\\n        if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\\\n            ro.yz *= rot(m.y*TAU);\\\n            ro.xz *= rot(m.x*TAU);\\\n            \\\n            rd.yz *= rot(m.y*TAU);\\\n            rd.xz *= rot(m.x*TAU);\\\n            ro.xy += org.xy;\\\n            ro.y = max(org.y, ro.y);\\\n        } else {\\\n            ro.xy += org.xy;\\\n            ro.y += org.y;\\\n            ro.y = max(org.y, ro.y);\\\n            ro.xz = vec2(cos(T*0.5), sin(T*0.5))*0.5;\\\n            rd = look(uv, vec3(0.0, 0.7, 0.0), ro);\\\n        }\\\n        return Ray(ro, rd);\\\n    }\\\n    vec3 getAlbedo(inout Data data) {\\\n        vec2 uv = boxUv(data.p, data.n);\\\n        switch (data.id) \\\n            TEX_LOOKUP\\\n        \\\n        \\\n        return vec3(0.77);\\\n    }\\\n    \\\n    vec3 getSky(in vec3 rd) {\\\n        float dotup = cdot(rd, vec3(0, 1, 0));\\\n        vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\\\n        return col;\\\n    }\\\n    \\\n    vec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\\\n        vec3 p = data.p;\\\n        vec3 n = data.n;\\\n        vec3 L = getLightDir(light, p);\\\n        vec3 ref = reflect(L, n);\\\n        float VdotR = cdot(rd, ref);\\\n        float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\\\n        vec3 att = getLightAtt(light, p, n);\\\n        float shadow = getShadow(p + (n*NEAR*2.0), L, n, light.type == LIGHT_AMBIENT ? FAR :\\\n            distance(light.p, p), data.id);\\\n            \\\n        return (diffuse + spec) * att * shadow; \\\n    }\\\n    vec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\\\n        vec3 col = vec3(0.0);\\\n        depth = 1.0;\\\n        vec3 oro = ro;\\\n        vec3 ord = rd;\\\n        Data od = data;\\\n        float minDist = FAR;\\\n        float dotup = cdot(rd, vec3(0, 1, 0));\\\n        for (int k = ZERO; k < 2; k++) {\\\n           vec3 mixf = vec3(1.0);\\\n            ord = rd;\\\n            oro = ro;\\\n            bool hit = false;\\\n            data.count = k;\\\n            for (int j = ZERO; j < NUM_BOUNCES; j++) {\\\n                if (march(data, ro, rd)) {\\\n                    if (k > 0 && data.d > minDist) break;\\\n                    if (k > 0 && j <= 0) { col = mix(col, col*col, clamp(0.5*(abs(minDist - data.d)/FAR), 0.0, 1.0)); mixf *= 1.33; };\\\n                    hit = true;\\\n                    vec3 albedo = getAlbedo(data);\\\n                    vec3 diffuse = albedo / M_PI;\\\n                    for (int i = ZERO; i < NUM_LIGHTS; i++) {\\\n                        Light light = LIGHTS[i];\\\n                        col += forEachLight(light, data, ro, rd, diffuse) * mixf;\\\n                    }\\\n                    if (j <= 0) { od = data; minDist = min(minDist, data.d); }\\\n                    float rough = data.m.rough;\\\n                    if (rough >= 0.992) break;\\\n                    float metallic = data.m.metallic;\\\n                    ro = (data.p + (data.n*NEAR*2.));\\\n                    rd = reflect(rd, data.n);\\\n                    float NdotV = dot(data.n, rd);\\\n                    vec3 f0 = mix(vec3(0.04), diffuse, metallic);\\\n                    vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\\\n                    mixf = F;\\\n                } else if (k <= 0 || j > 1) {\\\n                    col += getSky(rd) * mixf;\\\n                    col += smoothstep(0.001, 1.0, data.d/FAR) * max(0.0, 1.0-smoothstep(0.0, 0.25, cdot(rd, vec3(0, 1, 0))));\\\n                    break;\\\n                }\\\n            }\\\n            ro = oro;\\\n            rd = ord;\\\n            data = od;\\\n            if (hit && data.m.ior > 0.003) {\\\n                vec3 ro = ro;\\\n                vec3 rd = rd;\\\n                vec3 mixf = vec3(0.5);\\\n                float ior = data.m.ior;\\\n                vec3 n = data.n;\\\n                vec3 p = data.p;\\\n                rd = refract(rd, n, 1.0/ior);\\\n                ro = p - (n*NEAR*8.);\\\n                data.sig = -1.;\\\n                int iid = data.id;\\\n                vec3 rdEnter = rd;\\\n                for (int j = ZERO; j < 3; j++) {\\\n                    if (march(data, ro, rd)) {\\\n                        vec3 albedo = getAlbedo(data);\\\n                        vec3 diffuse = albedo / M_PI;\\\n                        for (int i = ZERO; i < NUM_LIGHTS; i++) {\\\n                            Light light = LIGHTS[i];\\\n                            col += forEachLight(light, data, ro, rd, diffuse) * mixf;\\\n                        }\\\n                        rd = (refract(rd, -data.n, data.sig < 0.0 ? 1.0/ior : ior));\\\n                        data.sig = 1.0;\\\n                        ro = data.p+(data.n*NEAR*2.);\\\n                        data.skip = iid;\\\n                        mixf /= (1.0 + float(j));\\\n                        mixf *= clamp(diffuse + 0.29, 0.0, 1.0);\\\n                        if (length(rd) <= 0.0000000001) { ro -= (data.n*NEAR*8.3); data.sig = -1.0; data.skip = -1; rd = reflect(rdEnter,-data.n);}\\\n                    } else if (k <= 0 || j > 1) {\\\n                        if (data.sig > 0.0) {\\\n                            col += getSky(rd) * col * mixf;\\\n                            col += smoothstep(0.001, 1.0, data.d/FAR) * max(0.0, 1.0-smoothstep(0.0, 0.25, cdot(rd, vec3(0, 1, 0))));\\\n                        }\\\n                    }\\\n                }\\\n            }\\\n            data = od;\\\n            if (hit && data.alpha >= 0.991) break;\\\n            data = NEW_DATA;\\\n            data.skip = data.id;\\\n            data.skip_trans = false;\\\n            rd = ord;\\\n            ro = oro;\\\n        }\\\n        \\\n        if (minDist < FAR) {\\\n            col += smoothstep(0.001, 1.0, minDist/FAR) * max(0.0, 1.0-smoothstep(0.0, 0.25, dotup));\\\n        }\\\n        return col;\\\n    }\\\n    \\\n    vec4 blit(in vec2 fc) {\\\n        vec3 col = vec3(0.0);\\\n        vec2 uv = (fc-0.5*R.xy)/R.y;\\\n        vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\\\n        \\\n        Ray ray = getRay(uv, m);\\\n        vec3 ro = ray.ro;\\\n        vec3 rd = ray.rd;\\\n        Data data = NEW_DATA;\\\n        float depth = 1.0;\\\n        col += render(data, ro, rd, depth);\\\n        col = aces(col);\\\n        col = pow(col, vec3(1.0 / 2.2));\\\n        return vec4(col, depth);\\\n    }\n","name":"Common","description":"","type":"common"}]}