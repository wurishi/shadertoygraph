{"ver":"0.1","info":{"id":"ss33Rn","date":"1628967721","viewed":83,"name":"Fractal Noise (Cubic 2D/Worley)","username":"lerping","description":"Fractal noise. (Cubic value noise / Worley noise)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random2D(vec2 xy, vec2 dir)\n{\n    float val = dot(xy, dir);\n    return fract(100.0 * sin(val));\n}\n\n// cubic value noise (2D)\nfloat cubicNoise2D(vec2 uv, vec2 dir)\n{\n    vec2 id = floor(uv);\n    vec2 nfc = fract(uv);\n    \n    vec2 bl = id;\n    vec2 br = id + vec2(1.0, 0.0);\n    vec2 tl = id + vec2(0.0, 1.0);\n    vec2 tr = id + vec2(1.0, 1.0);\n    \n    float a = random2D(bl, dir);\n    float b = random2D(br, dir);\n    float c = random2D(tl, dir);\n    float d = random2D(tr, dir);\n\n    // cubic interpolation of random noise across normalized frag coordinates\n    nfc = nfc*nfc*(3.0-2.0*nfc);\n    \n    float mask_bl = (1.0-nfc.x) * (1.0-nfc.y);\n    float mask_br = nfc.x * (1.0-nfc.y);\n    float mask_tl = (1.0-nfc.x) * nfc.y;\n    float mask_tr = nfc.x * nfc.y;\n    \n    float noise = (a * mask_bl) + (b * mask_br) + (c * mask_tl) + (d * mask_tr);\n    return noise;\n\n}\n\n\n// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec2 hash33(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tq = (q.x ^ q.y )*UI2;\n\treturn -1. + 2. * vec2(q) * UIF;\n}\n\n\n// modified 3D Worley noise example by piyushslayer - https://www.shadertoy.com/view/3dVXDc\nfloat worleyNoise2D(vec2 uv, float freq)\n{    \n    vec2 id = floor(uv);\n    vec2 p = fract(uv);\n    \n    float minDist = 10000.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 h = hash33(mod(id + offset, vec2(freq))) * .5 + .5;\n            h += offset;\n            vec2 d = p - h;\n            minDist = min(minDist, dot(d, d));\n\n        }\n    }\n    \n    // inverted worley noise\n    return 1. - minDist;\n}\n\nfloat worleyFbm(vec2 uv, float freq)\n{\n    return worleyNoise2D(uv*freq, freq) * .625 +\n        \t worleyNoise2D(uv*freq*2., freq*2.) * .25 +\n        \t worleyNoise2D(uv*freq*4., freq*4.) * .125;\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 1.0;\n    float frequency = 6.0;\n    vec3 noiseWorley = vec3(worleyFbm(uv, frequency), worleyFbm(uv, frequency*2.0), worleyFbm(uv, frequency*4.0) ) ;\n    float worley = noiseWorley.x * .625 +\n        \t\t noiseWorley.y * .125 +\n        \t\t noiseWorley.z * .25; \n      \n    vec2 noiseDir = vec2(1.5, 0.6);\n    frequency = 5.0;\n    float amplitude = 0.75f;\n    \n    float lacunarity = 2.0;\n    float gain = 0.4; \n    int octaves = 8;    \n    \n    float noiseGradient = 0.0;\n    for (int i=0; i<octaves; i++)\n    {\n        noiseGradient += amplitude * cubicNoise2D(uv * frequency , noiseDir);\n        frequency *= lacunarity;\n        amplitude *= gain;  \n    }\n    \n    noiseGradient = mix(1.0, noiseGradient, 0.5);\n    noiseGradient = abs(noiseGradient * 2. - 1.);     \n    float noise = noiseGradient * noiseWorley.x;\n    \n    noise = remap(noise, worley - 1., 1., 0., 1.); \n    \n    float coverage = 0.1;\n    noise = remap(noise, coverage, 1., 0., 1.); \n\n    vec3 col = vec3(noise);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}