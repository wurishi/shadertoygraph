{"ver":"0.1","info":{"id":"XdGSWy","date":"1466502099","viewed":334,"name":"Hyperbolic Tiling Test","username":"Ultraviolet","description":"Test inspired from http://images.math.cnrs.fr/Une-chambre-hyperbolique \nVery unoptimized code, lots of improvements to come.\nComments welcomed !\nDo not hesitate to change the visualization mode (line 161/612) and the tiling (line 148/149).","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","tiling","hyperbolic","poincarspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141597\n\n#define SCALE\t\t\t1.2\n#define DISPLACEMENT\tvec2(0.0)\n\n#define AA\t\t\t\t4.0\n\n\n#define NB_ITER \t\t50.0\n#define POLY_CENTRE\t\tvec2(0.0, 0.0)\n#define POLY_CENTRE\t\tvec2(0.0, 0.0)\n\nbool LineLineIntersect(out vec2 P, in vec2 P0, in vec2 d0, in vec2 P1, in vec2 d1)\n{\n    vec2 d0c = d0 / dot(d0, d0);\n    vec2 X = d1 - d0 * dot(d1, d0c);\n    vec2 Y = P1 - P0 - d0*dot(P1, d0c);\n\n    float t1 = -dot(Y, X) / dot(X, X);\n\n    vec2 Pd1 = P1 + t1 * d1;\n\n    float t0 = dot((Pd1 - P0), d0) / dot(d0, d0);\n    P = P0 + t0 * d0;\n    \n    return true;\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR)\n{\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nvec2 ortho(in vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float NB_PTS = (iMouse.y>0.1)?(2.0 + ceil(iMouse.y/iResolution.y*10.0)):4.0;\n    float POLY_RADIUS = (iMouse.x > 0.1)?(iMouse.x / iResolution.x):pow(cos(iDate.w*0.5), 2.0);\n    \n    fragColor = vec4(0.0);\n    for(float aaX=.0; aaX < AA; aaX++)\n    {\n    \tfor(float aaY=.0; aaY < AA; aaY++)\n        {\n            \n            float ratio = iResolution.x / iResolution.y;\n            vec2 uv = (fragCoord.xy+ vec2(aaX, aaY)/AA - iResolution.xy * 0.5) / iResolution.y;\n            uv *= 2.0 * SCALE;\n            uv += DISPLACEMENT;\n\n\n            int inv = 0;\n            bool found = true;\n\n            for(float iter = .0; iter < NB_ITER; iter++)\n            {\n                vec2 C = vec2(1000.0);\n                float R = -1.0;\n\n                /// Checking if the current point is inside the original polygon\n                bool found_2 = true;\n\n                for(float i=.0; i<100.0; i++)\n                {\n\n                    if(i > NB_PTS)\n                        break;\n                    \n                    vec2 P = POLY_CENTRE + POLY_RADIUS*vec2(cos( i     /NB_PTS*PI*2.0), sin( i     /NB_PTS*PI*2.0));\n                    vec2 Q = POLY_CENTRE + POLY_RADIUS*vec2(cos((i+1.0)/NB_PTS*PI*2.0), sin((i+1.0)/NB_PTS*PI*2.0));\n\n                    vec2 M = 0.5*(P+Q);\n                    vec2 Pp = circleInverse(P, vec2(0.0), 1.0);\n                    vec2 N = 0.5*(P+Pp);\n\n                    LineLineIntersect(C, M, normalize(ortho(Q-P)), N, normalize(ortho(Pp-P)));\n                    R = length(P-C);\n\n                    if(distance(uv, C) < R)\n                    {\n                        found_2 = false;\n                        break;\n                    }\n                }\n\n                if(found_2)\n                {\n                    found = true;\n                    break;\n                }\n\n\n\n                /// Identifying the best circle for inversion\n                for(float i=.0; i<100.0; i++)\n                {\n                    \n                    if(i > NB_PTS)\n                        break;\n                    \n                    vec2 P = POLY_CENTRE + POLY_RADIUS*vec2(cos( i     /NB_PTS*PI*2.0), sin( i     /NB_PTS*PI*2.0));\n                    vec2 Q = POLY_CENTRE + POLY_RADIUS*vec2(cos((i+1.0)/NB_PTS*PI*2.0), sin((i+1.0)/NB_PTS*PI*2.0));\n\n                    vec2 M = 0.5*(P+Q);\n                    vec2 Pp = circleInverse(P, vec2(0.0), 1.0);\n                    vec2 N = 0.5*(P+Pp);\n\n                    vec2 C_temp;\n                    LineLineIntersect(C_temp, M, normalize(ortho(Q-P)), N, normalize(ortho(Pp-P)));\n                    float R_temp = length(P-C_temp);\n\n                    if(distance(C_temp, uv) < distance(C, uv))\n                    //if((distance(C_temp, uv)-R_temp) < (distance(C, uv)-R))\n                    //if(length(circleInverse(uv, C_temp, R)) < length(uv))\n                    {\n                        C = C_temp;\n                        R = R_temp;\n                    }\n                }\n\n                /// Performing inversion \n                uv = circleInverse(uv, C, R);\n                inv++;\n\n                /// Inverting points outside the unit circle\n                if(length(uv) > 1.0)\n                    uv = circleInverse(uv, vec2(0.0), 1.0);\n            }\n\n            // Create triangular tiling (optional)\n            //*\n            if(mod(atan(uv.y, uv.x) * NB_PTS, 2.0*PI) > PI )\n                inv++;\n            //*/\n\n            // Computing color\n\n            /*\n            if(mod(float(inv),2.0) < 0.001)\n                fragColor += vec4(vec3(float(inv) / NB_ITER, 0.0, 0.0), 1.0);\n            else\n                fragColor += vec4(vec3(0.0, 0.0, float(inv) / NB_ITER), 1.0);\n            //*/\n\n            //fragColor += vec4(vec3(1.0-pow(float(inv) / NB_ITER, 1.0)), 1.0);\n            \n            float nb_color = 10.0;\n            fragColor += vec4(vec3(1.0-pow(min(mod(float(inv), 2.0*nb_color), mod(2.0*nb_color-float(inv), 2.0*nb_color)) / nb_color, 1.0)), 1.0);\n            \n            //fragColor += vec4(vec3(mod(float(inv),2.0)), 1.0);\n\n            // Creating mask (optional)\n            //if(length(uv) > 1.0)\n            //\tfragColor += vec4(vec3(0.5),1.0);\n        }\n    }\n    \n\tfragColor = fragColor / AA / AA;\n}","name":"Image","description":"","type":"image"}]}