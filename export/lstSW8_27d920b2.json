{"ver":"0.1","info":{"id":"lstSW8","date":"1459187307","viewed":323,"name":"Pick the dots game","username":"irealex","description":"Have fun and try to reach 20 points!\nMade by Irene Bouzon and Alexandra Vicente for our second PGATR assignment.\nComputer Graphics, Virtual Reality and Videogames University Master. URJC.","likes":5,"published":1,"flags":112,"usePreview":0,"tags":["2d","raymarching","game","interactive","dots","cell","buffer","pgatr","multipass","migjrv","urjc","cellularmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdsGz2","filepath":"https://soundcloud.com/moreramusic/morera-i-pray-original-mix","previewfilepath":"https://soundcloud.com/moreramusic/morera-i-pray-original-mix","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//=================================================================================================\n// Use arrow keys to move your ball and pick the dots, go for a high score!\n// Spacebar resets the game if you lose\n// Have fun and try to reach 20 points! :D\n// \n// Made by Alexandra Vicente and Irene Bouzon for our PGATR second assignment\n// MIGJRV 2015/2016. URJC.\n//\n// Reference shaders (try them!):\n// > https://www.shadertoy.com/view/MddGzf\n// > https://www.shadertoy.com/view/XsdGDX\n//=================================================================================================\n\n\n\n#define MAX_STEPS 32\n#define MAX_DIST 100.0\n#define EPSILON 0.001\n\n#define POINT_R 0.03\n#define ENEMY_R 0.15\n\n\n\n// Storage register/texel addresses\nconst vec2 txMyPos \t\t= vec2(0.0,0.0);\t\t// position of my ball\nconst vec2 txMyRad \t\t= vec2(1.0,0.0);\t\t// radius of my ball\nconst vec2 txPoints     = vec2(2.0,0.0);\t\t// score\nconst vec2 txState      = vec2(3.0,0.0);\t\t// game state: -1, 0, 1\nconst vec2 txBadRad \t= vec2(4.0,0.0);\t\t// centered bad ball radius\nconst vec2 txPointPos \t= vec2(5.0,0.0);\t\t// position of point (z = spawn)\nconst vec2 txEnemy1Pos\t= vec2(6.0,0.0);\t\t// position of enemy ball 1\nconst vec2 txEnemy2Pos\t= vec2(7.0,0.0);\t\t// position of enemy ball 2\nconst vec2 txEnemy1Vel\t= vec2(8.0,0.0);\t\t// velocity of enemy ball 1\nconst vec2 txEnemy2Vel\t= vec2(9.0,0.0);\t\t// velocity of enemy ball 2\n\n\n\n// CAMERA\nvec3 up = vec3(0.0, 1.0, 0.0);\t\t\t\t\t// up vector\nvec3 right = vec3(1.0, 0.0, 0.0);\t\t\t\t// right vector\nvec3 forward;\t\t\t\t\t\t\t\t\t// forward vector\nvec3 eye = vec3(0.0, 0.0, -1.0);\t\t\t\t// focal point\n\n// LIGHT\nvec3 lightPosition = vec3(0.0, 0.0, -1.35);\nvec3 lightColor = vec3(1.0);\n\n\n\nvec2  myPos; float myRad; float badRad;\nconst vec2 shadowOffset = vec2(-0.03,0.03);\n\n\n\n\n\n\n//=================================================================================================\n// Utility functions\n//=================================================================================================\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nvec3 randomColor(float n)\n{\n    return vec3(hash1(n*2.0), hash1(n*n), hash1(n));\n}\n\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n\n\n//=================================================================================================\n// Distance functions\n//=================================================================================================\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udHorizontalSegment( in vec2 p, in float xa, in float xb, in float y )\n{\n    vec2 pa = p - vec2(xa,y);\n    float ba = xb - xa;\n    pa.x -= ba*clamp( pa.x/ba, 0.0, 1.0 );\n    return length( pa );\n}\n\nfloat udRoundBox( vec2 p, vec2 c, vec2 b, float r )\n{\n  return length(max(abs(p-c)-b,0.0))-r;\n}\n\n\n\n//=================================================================================================\n// Painting functions\n//=================================================================================================\n\nvec3 drawBall(vec3 color, vec3 myColor, float myGlow, float myRad, vec2 myPos, vec2 uv, float px, bool rand)\n{\n    // randomize color by radius\n    if (rand)\n    {\n        myColor = randomColor(myRad);\n        if (myColor.x + myColor.y + myColor.z < 1.5)\n        {\n            // dark color! :(\n            myColor *= 2.0;\n        }\n    }\n    \n    \n\t// shadow\n    float f = 1.0-smoothstep( myRad*0.5, myRad*2.0, length( uv - myPos + shadowOffset ) );\n    color = mix( color, color*0.4, f );\n\n    // shape\n    f = length( uv - myPos ) - myRad;\n    vec3 bcol = myColor;\n    bcol *= 1.0 + 0.7*smoothstep( -3.0*px, -1.0*px, f );\n    bcol *= 0.7 + 0.3*myGlow;\n    color = mix( color, bcol, 1.0-smoothstep( 0.0, px, f ) );\n    \n    return color;\n}\n\nvec3 shadeSimple(vec2 p, vec3 col)\n{\n\tvec3 normal = vec3(0.0, 0.0, -1.0);\n\tvec3 lightDir = normalize(lightPosition - vec3(p.xy, 0.0));\n    float cosL = dot(normal, lightDir);\n\tvec3 lightIntensity = lightColor * cosL;   \n    float sp = exp2(4.0 + 6.0 * 0.0005);\n    float f  = max(0.0, dot(lightDir, normal));\n    \n    // Final result\n    return col.xyz * pow(f, sp) * lightIntensity;\n}\n\n\n\n//=================================================================================================\n// Raymarching functions\n//=================================================================================================\n\n// Sphere\nfloat sdSphere( vec3 p, float r )\n{\n  return (length(p)-r);\n}\n\nfloat sdSphereC( vec3 p, vec3 c, float r )\n{\n  return length (p-c) - r;\n}\n\n// Raymarching scene\nfloat distanceField(vec3 p, out float r)\n{\n    // Bad centered ball\n    float res = sdSphere(p, badRad);\n    r = 30.4; // radius of hit ball\n    \n    return res;\n}\n\n// Normal calculation\nvec3 getNormal(vec3 p)\n{\n    vec3 epsX = vec3(EPSILON, 0.0, 0.0);\n    vec3 epsY = vec3(0.0, EPSILON, 0.0);\n    vec3 epsZ = vec3(0.0, 0.0, EPSILON);\n    \n    float rr;\n    \n    vec3 grad = vec3( distanceField(p+epsX, rr) - distanceField(p-epsX, rr),\n\t\t\t\t\t  distanceField(p+epsY, rr) - distanceField(p-epsY, rr),\n\t\t\t\t\t  distanceField(p+epsZ, rr) - distanceField(p-epsZ, rr) );\n    \n    vec3 n = normalize(grad);\n \n    return n;\n}\n\n// Soft shadows\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    // > https://iquilezles.org/articles/rmshadows\n    float res = 1.0;\n    float t = mint;\n    \n    for (int i = 0; i < 16; i++)\n    {\n        float rr;\n        float h = distanceField(ro + rd*t, rr);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        \n        t += h;\n        if (t > maxt)\n        {\n            break;\n        }\n    }\n    return res;\n}\n\n\n// Phong shading\nvec4 shadePhong( vec3 p, vec4 col, float smt)\n{\n    vec3 nor = getNormal(p);\n    vec3  v  = normalize(lightPosition - p);\n    float f  = max(0.0, dot(v, nor));\n    float sp = exp2(4.0 + 6.0 * smt);\n    float si = (sp + 2.0) * 0.125;\n    return pow(f, sp) * si * col;\n}\n\n\n// Ambient occlusion\nfloat ambientOcclusion( in vec3 pos, in vec3 nor )\n{\n    // > https://www.shadertoy.com/view/Xds3zN\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    \n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float rr;\n        float dd = distanceField( aopos, rr );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    \n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n// Lambertian shading\nvec4 shade(vec3 p, vec4 col)\n{\n\tvec3 normal = getNormal(p);\n\tvec3 lightDir = normalize(lightPosition - p);\n    float cosL = dot(normal, lightDir);\n\tvec3 lightIntensity = lightColor * cosL;   \n    \n    // Soft shadows\n    float shadow = softShadow(p, lightDir, 0.05, 5.0, 2.0);\n    \n    // Specular (Phong)\n    lightIntensity += shadePhong(p, col, 0.5).xyz;\n    \n    // Ambient occlusion\n    float ao = ambientOcclusion(p, normal);\n    \n    \n    // Final result\n    return vec4(col.xyz * lightIntensity * shadow * ao, 1.0);\n}\n\n// Raymarching algorithm\nvec4 raymarch(vec3 rayOrigin, vec3 rayDirection, vec4 color)\n{\n    vec4 finalColor = color; \t// init as background\n    vec4 fogColor = vec4(1.0);\t// fog color: white\n    \n\tfloat t = 0.0;\n\tfor(int i = 0; i < MAX_STEPS; ++i)\n    {\n        if (t > MAX_DIST)\n        {\n            // Ray length out of our volume -> stop\n            break;\n        }\n        \n        vec3 p = rayOrigin + rayDirection * t; // the point\n        \n        float r;\n\t\tfloat d = distanceField(p, r);\n\t\tif(d < EPSILON)\n        {\n            // Color\n\t\t\tfinalColor = vec4(randomColor(r).xyz, 1.0);\n            \n            // Fog: over operator\n            //float alpha = t / MAX_DIST;\t// fog intensity based on distance\n            //alpha *= 20.0;\t\t\t\t// factor to increase fog\n            //finalColor = alpha*fogColor + (1.0 - alpha)*finalColor;\n  \n            // Shade\n            finalColor = shade(p, finalColor);\n            \n\t\t\treturn finalColor;\n\t\t}\n\t\tt += d;\n\t}\n    \n\treturn finalColor;\n}\n\n// Supersampling 4x\nvec4 superSampling4xRaymarch(float f, float u, float v, float du, float dv, vec4 color)\n{\n    vec3 p;\n    vec3 direction;\n    \n    // Do raymarching 4 times for this point\n    p = eye + forward*f + (right*u - right*0.25*du) + (up*v - up*0.25*dv);\n    direction = p - eye;\n    vec4 c0 = raymarch(eye, direction, color);\n    \n    p = eye + forward*f + (right*u + right*0.25*du) + (up*v - up*0.25*dv);\n    direction = p - eye;\n    vec4 c1 = raymarch(eye, direction, color);\n    \n    p = eye + forward*f + (right*u - right*0.25*du) + (up*v + up*0.25*dv);\n    direction = p - eye;\n    vec4 c2 = raymarch(eye, direction, color);\n    \n    p = eye + forward*f + (right*u + right*0.25*du) + (up*v + up*0.25*dv);\n    direction = p - eye;\n    vec4 c3 = raymarch(eye, direction, color);\n    \n    // Merge results\n    vec4 result = (c0 + c1 + c2 + c3) / 4.0;\n    \n    return result;\n}\n\n\n\n\n\n\n\n//=================================================================================================\n// Main function\n//=================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    //------------------------\n    // load game state\n    //------------------------\n    myPos   \t\t= texture( iChannel0, (txMyPos+0.5)/iChannelResolution[0].xy ).xy;\n    myRad \t\t\t= texture( iChannel0, (txMyRad+0.5)/iChannelResolution[0].xy ).x;\n    badRad\t\t\t= texture( iChannel0, (txBadRad+0.5)/iChannelResolution[0].xy ).x;\n    float points    = texture( iChannel0, (txPoints+0.5)/iChannelResolution[0].xy ).x;\n    float state     = texture( iChannel0, (txState+0.5)/iChannelResolution[0].xy ).x;\n    vec4 pointPos\t= texture( iChannel0, (txPointPos+0.5)/iChannelResolution[0].xy );\n    vec4 enemy1Pos\t= texture( iChannel0, (txEnemy1Pos+0.5)/iChannelResolution[0].xy );\n    vec4 enemy2Pos\t= texture( iChannel0, (txEnemy2Pos+0.5)/iChannelResolution[0].xy );\n\n    lightPosition = vec3(myPos.xy, lightPosition.z);\n    \n    \n    //------------------------\n    // draw\n    //------------------------\n    vec3 color = 0.8*vec3(0.1,0.1,0.1)*(1.0-0.3*length( uv )); // background color gradient\n    \n    // Background\n    {\n        color   = mix( texture( iChannel3, fragCoord/iChannelResolution[3].xy ).xyz,\n            \t\t   color,\n                       step(points, 4.0) ); // 1st diff increase: points >= 5\n        \n        // Another background\n        //color = 0.8*vec3(0.5,0.9,0.9)*(1.0-0.3*length( uv )); // background color gradient\n        //color *= 1.0 - 0.1*smoothstep( 0.0,1.0, 1.0 -sin(uv.y*30.0)); // horizontal lines\n        //color *= 1.0 - 0.1*smoothstep( 0.0,1.0, 1.0 - sin(uv.x*30.0)); // vertical lines\n    } \n    \n    // Point\n    {\n        float glow = 1.0-abs(sin(5.0*iTime));\n        color = mix( color,\n                     drawBall(color, vec3(0.9,0.9,0.7), glow, POINT_R, pointPos.xy, uv, px, false),\n                     pointPos.z); // z == 0 -> not spawned, do not paint\n    }\n    \n    // Ball\n    {\n        color = drawBall(color, vec3(1.0,0.6,0.2), 0.0, myRad, myPos, uv, px, true);\n    }\n        \n    // Raymarched enemy ball\n    {\n        forward = normalize(cross(right, up));\n    \n    \tvec3 eyeToOrigin = vec3(0.0) - eye;\n    \tfloat f = dot(eyeToOrigin, forward);\t\t\t// projection\n    \n    \tcolor = superSampling4xRaymarch(f, uv.x, uv.y, px, px, vec4(color, 1.0)).xyz;\n    }    \n    \n    // Enemy ball 1\n    {\n        // 2nd diff increase: points >= 10\n        color = mix( drawBall(color, vec3(1.0,0.2,0.2), 0.0, ENEMY_R, enemy1Pos.xy, uv, px, false),\n            \t\t color,\n                     abs(enemy1Pos.z)); // z == -1 -> not spawned, do not paint\n    }\n    \n    // Enemy ball 2\n    {\n        // 3rd diff increase: points >= 15\n        color = mix( drawBall(color, vec3(1.0,0.2,0.2), 0.0, ENEMY_R, enemy2Pos.xy, uv, px, false),\n            \t     color,\n                     abs(enemy2Pos.z)); // z == -1 -> not spawned, do not paint\n    }\n    \n    // Shade\n    {\n    \tcolor = mix( shadeSimple(uv, color),\n                     color,\n                     step(points, 19.0)); // 4th diff increase: points >= 20\n    }\n    \n    // score\n    {\n        float f = PrintInt( (uv-vec2(-1.5,0.8))*10.0, points );\n        color = mix( color, vec3(1.0,1.0,1.0), f );\n    }\n    \n    // game over\n    {\n        color = mix( color, vec3(1.0,0.4,0.2), state * (0.5+0.5*sin(30.0*iTime)) );\n    }\n    \n    \n \n    fragColor.xyz = color;\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//=================================================================================================\n// Use arrow keys to move your ball and pick the dots, go for a high score!\n// Spacebar resets the game if you lose\n// Have fun and try to reach 20 points! :D\n// \n// Made by Alexandra Vicente and Irene Bouzon for our PGATR second assignment\n// MIGJRV 2015/2016. URJC.\n//\n// Reference shaders (try them!):\n// > https://www.shadertoy.com/view/MddGzf\n// > https://www.shadertoy.com/view/XsdGDX\n//=================================================================================================\n\n\n\n#define POINT_R 0.03\n#define ENEMY_R 0.15\n#define NUM_VBLES 10.0\n\n\n// storage register/texel addresses\nconst vec2 txMyPos \t\t= vec2(0.0,0.0);\t\t// position of my ball\nconst vec2 txMyRad \t\t= vec2(1.0,0.0);\t\t// radius of my ball\nconst vec2 txPoints     = vec2(2.0,0.0);\t\t// score\nconst vec2 txState      = vec2(3.0,0.0);\t\t// game state: -1, 0, 1\nconst vec2 txBadRad \t= vec2(4.0,0.0);\t\t// centered bad ball radius\nconst vec2 txPointPos \t= vec2(5.0,0.0);\t\t// position of point (z = spawn)\nconst vec2 txEnemy1Pos\t= vec2(6.0,0.0);\t\t// position of enemy ball 1\nconst vec2 txEnemy2Pos\t= vec2(7.0,0.0);\t\t// position of enemy ball 2\nconst vec2 txEnemy1Vel\t= vec2(8.0,0.0);\t\t// velocity of enemy ball 1\nconst vec2 txEnemy2Vel\t= vec2(9.0,0.0);\t\t// velocity of enemy ball 2\n\n\nconst float gameSpeed =  3.0;\nconst float inputSpeed = 2.0;\nconst float speed = 0.0005;\nconst float enemySpeed = 0.007;\nconst float baseBadRad = 0.1;\nconst vec4 badPos = vec4(0.0);\n\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\n\n\n\n// Methods for data storage by Inigo Quilez\n// > https://www.shadertoy.com/view/MddGzf\n//----------------------------------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\n\nfloat hash1( float n ) { return fract(sin(n)*138.5453123); }\n\nfloat rand(vec2 co)\n{\n    // > https://www.shadertoy.com/view/XsdGDX\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//----------------------------------------------------------------------------------------------\n\n\n\nvoid moveAndBounce(float rad, inout vec4 pos, inout vec2 speed)\n{   \n    pos.x += speed.x;\n    pos.y += speed.y;   \n    \n    \n    if (pos.y-rad < -1.0)\n    {\n        speed.y = abs(speed.y);\n    }\n    \n    else if (pos.y+rad > 1.0)\n    {\n        speed.y = -abs(speed.y);\n    }\n    \n    if (pos.x-rad < -1.75)\n    {\n        speed.x = abs(speed.x);\n    }\n    else if (pos.x+rad > 1.75)\n    {\n        speed.x = -abs(speed.x);\n    }    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Don't compute gameplay outside of the data area\n    if( fragCoord.x > NUM_VBLES || fragCoord.y > NUM_VBLES ) discard;\n    \n    \n    \n    //---------------------------------------------------------------------------------   \n\t// Load game state\n\t//---------------------------------------------------------------------------------\n    vec4  myPos \t= loadValue( txMyPos );\n    float myRad \t= loadValue( txMyRad ).x;\n    float points    = loadValue( txPoints ).x;\n    float state     = loadValue( txState ).x;\n    float badRad\t= loadValue( txBadRad ).x;\n    vec4 pointPos\t= loadValue( txPointPos );\n    vec4 enemy1Pos\t= loadValue( txEnemy1Pos);\n    vec4 enemy2Pos\t= loadValue( txEnemy2Pos);\n    vec2 enemy1Vel \t= loadValue( txEnemy1Vel).xy;\n    vec2 enemy2Vel \t= loadValue( txEnemy2Vel).xy;\n    \n    \n\t\n    //---------------------------------------------------------------------------------\n    // Reset (or init)\n\t//---------------------------------------------------------------------------------\n\tif( iFrame==0 ) state = -1.0;\n\t\n    if( state < -0.5 )\n    {\n        // INITIAL STATE\n        \n        myPos = vec4(0.0, -0.5, 0.0, 1.0);\n        myRad = 0.04;\n        points = 0.0;\n        state = 0.0;\n        badRad = baseBadRad;\n        pointPos = vec4(0.0);\n        enemy1Pos = vec4(0.5, 0.0, -1.0, 0.0);\n        enemy2Pos = vec4(-0.5, 0.0, -1.0, 0.0);\n        enemy1Vel = vec2(2.0*enemySpeed, 0.5*enemySpeed);\n        enemy2Vel = vec2(1.0*enemySpeed, 3.0*enemySpeed);\n    }\n    \n    \n    \n    //---------------------------------------------------------------------------------\n    // Do game\n    //---------------------------------------------------------------------------------\n\n    else if( state > 0.5 )\n    {\n        // GAME OVER -> press space to reset\n        \n        float pressSpace = texture( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n        if( pressSpace>0.5 )\n        {\n            state = -1.0;\n        }\n    }\n    \n    else if( state < 0.5 ) \n\t{\n        // PLAY\n        \n        //-------------------\n        // my ball\n\t\t//-------------------\n        \n        /*if( iMouse.w>0.01 )\n        {\n            // Mouse input\n            myPos.x = (-1.0 + 2.0*iMouse.x/iResolution.x)*iResolution.x/iResolution.y;\n            myPos.y = (-1.0 + 2.0*iMouse.y/iResolution.y);\n        }\n        else*/\n        {\n        \t// Keyboard input\n        \tfloat moveRight = texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x;\n        \tfloat moveLeft  = texture( iChannel1, vec2(KEY_LEFT,0.25) ).x;\n            float moveUp  \t= texture( iChannel1, vec2(KEY_UP,0.25) ).x;\n            float moveDown  = texture( iChannel1, vec2(KEY_DOWN,0.25) ).x;\n            float pressSpace = texture( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n        \t\n            // Movement\n            vec2 add = vec2(moveRight - moveLeft, moveUp - moveDown);\n            myPos.xy += speed*(1.0/myRad)*inputSpeed*add;\n        }      \n        \n        // don't allow outside window\n        myPos.x = clamp(myPos.x, -1.75 +myRad, 1.75 -myRad);\n        myPos.y = clamp(myPos.y, -1.00 +myRad, 1.00 -myRad);\n\n        \n        // detect collision with bad centered ball\n        float dist = length(myPos.xy - badPos.xy);\n        if( dist < (myRad + badRad) )\n        {\n            state = 1.0; // game over\n        }\n        \n        // detect collision with enemy 1 if active\n        if (enemy1Pos.z == 0.0)\n        {\n        \tdist = length(myPos.xy - enemy1Pos.xy);\n        \tif( dist < (myRad + ENEMY_R) )\n        \t{\n           \t\tstate = 1.0; // game over\n        \t}\n        }\n        \n        // detect collision with enemy 2 if active\n        if (enemy2Pos.z == 0.0)\n        {\n        \tdist = length(myPos.xy - enemy2Pos.xy);\n        \tif( dist < (myRad + ENEMY_R) )\n        \t{\n           \t\tstate = 1.0; // game over\n        \t}\n        }\n        \n        // detect collision with point\n        if (pointPos.z != 0.0)\n        {\n        \tdist = length(myPos.xy - pointPos.xy);\n            if ( dist < (myRad + POINT_R) )\n            {\n                // point is picked\n                points += 1.0;\n                                \n                // increase my ball radius\n                myRad += 0.001;\n                \n                // set as not spawned\n            \tpointPos = vec4(0.0);\n            }\n        }\n        \n        \n        //-------------------\n        // point spawn\n\t\t//-------------------\n        if (pointPos.z == 0.0)\n        {\n            // random position\n            pointPos.x = rand(vec2(float(iFrame)*0.122+iDate.w*0.845, float(iFrame)*0.647+iDate.w*0.753)) *3.0 -1.5;\n            pointPos.y = rand(vec2(float(iFrame)*0.546+iDate.w*0.342, float(iFrame)*0.342+iDate.w*0.935)) *2.0 -1.0;\n            \n            // don't spawn outside window\n        \tpointPos.x = clamp(pointPos.x, -1.75 +POINT_R, 1.75 -POINT_R);\n        \tpointPos.y = clamp(pointPos.y, -1.00 +POINT_R, 1.00 -POINT_R);\n            \n            // set as spawned\n            pointPos.z = 1.0;\n            \n            // don't spawn inside bad ball or my ball\n            dist = length(pointPos.xy - badPos.xy);\n            float dist2 = length(myPos.xy - pointPos.xy);\n        \tif( dist  < (POINT_R + badRad) ||\n                dist2 < (POINT_R + myRad) )\n        \t{\n                // set as not spawned -> select another position in next frame\n            \tpointPos = vec4(0.0);\n        \t}\n        }\n        \n        \n        //-------------------\n        // centered evil ball\n\t\t//-------------------\n        if (points >= 1.0)\n        {\n        \tbadRad = baseBadRad + 0.075*sin(2.0*iTime);\n        }\n        \n        \n        //-------------------\n        // moving enemy balls\n\t\t//-------------------\n       \tmoveAndBounce(ENEMY_R, enemy1Pos, enemy1Vel);\n        moveAndBounce(ENEMY_R, enemy2Pos, enemy2Vel);\n        \n        // Spawn enemy 1\n        if (enemy1Pos.z != 0.0 && points >= 10.0)\n        {\n            enemy1Pos.z = 0.0;\n            \n            // don't spawn over my ball\n            dist = length(myPos.xy - enemy1Pos.xy);\n        \tif( dist  < (myRad + ENEMY_R))\n            {\n                // set as not spawned -> try again in next frame\n            \tenemy1Pos.z = -1.0;\n        \t}\n        }\n        \n        // Spawn enemy 2\n        if (enemy2Pos.z != 0.0 && points >= 15.0)\n        {\n            enemy2Pos.z = 0.0;\n            \n            // don't spawn over my ball\n            dist = length(myPos.xy - enemy2Pos.xy);\n        \tif( dist  < (myRad + ENEMY_R))\n            {\n                // set as not spawned -> try again in next frame\n            \tenemy2Pos.z = -1.0;\n        \t}\n        }   \n    }\n\n    \n    \n    //---------------------------------------------------------------------------------\n\t// Store game state\n\t//---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n \n    storeValue( txMyPos,\tvec4(myPos),             \tfragColor, fragCoord );\n    storeValue( txMyRad,\tvec4(myRad,0.0,0.0,0.0), \tfragColor, fragCoord);\n    storeValue( txPoints,   vec4(points,0.0,0.0,0.0),\tfragColor, fragCoord );\n    storeValue( txState,    vec4(state,0.0,0.0,0.0),    fragColor, fragCoord );\n    storeValue( txBadRad,   vec4(badRad,0.0,0.0,0.0),   fragColor, fragCoord );\n    storeValue( txPointPos, vec4(pointPos),\t\t\t\tfragColor, fragCoord );\n    storeValue( txEnemy1Pos,vec4(enemy1Pos),\t\t\tfragColor, fragCoord );\n    storeValue( txEnemy2Pos,vec4(enemy2Pos),\t\t\tfragColor, fragCoord );\n    storeValue( txEnemy1Vel,vec4(enemy1Vel.xy,0.0,0.0),\tfragColor, fragCoord );\n    storeValue( txEnemy2Vel,vec4(enemy2Vel.xy,0.0,0.0),\tfragColor, fragCoord );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//=================================================================================================\n// Use arrow keys to move your ball and pick the dots, go for a high score!\n// Spacebar resets the game if you lose\n// Have fun and try to reach 20 points! :D\n// \n// Made by Alexandra Vicente and Irene Bouzon for our PGATR second assignment\n// MIGJRV 2015/2016. URJC.\n//\n// Reference shaders (try them!):\n// > https://www.shadertoy.com/view/MddGzf\n// > https://www.shadertoy.com/view/XsdGDX\n//=================================================================================================\n\n\n\n#define ANIMATE\n#define SCALE 25.0\n#define MOV_FACTOR 8.0\n#define TEX_SIZE 256.0\n\nvec2 hash2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\nfloat euclideanDist2(vec2 v)\n{\n    return dot(v,v);\n}\n\nvec2 animateCell1(vec2 noise)\n{\n \tnoise = sin(iTime+MOV_FACTOR*noise);\n    return 0.5*noise + 0.5; //NORMALIZE\n}\n\nvec2 cellNoise(vec2 point )\n{\n    float d = 1e30, daux;\n    vec2 v, vaux;\n    vec2 o, offset;\n    vec2 noise;    \n    \n    // 1st Worley pass (Inside cells)\n    vec2 pi = floor(point); // Integer part of the point\n    vec2 pf = fract(point); // Decimal part of the point\n\n    for( int i=-1; i<=1; i++ )\n    {\n        for( int j=-1; j<=1; j++ )\n        {\n            offset = vec2(i,j); \n            noise = hash2( pi + offset ); // noise for the int point+offset\n            #ifdef ANIMATE\n           \t \tnoise = animateCell1(noise); // lets animate the cells!\n            #endif\t\n            vaux = offset + noise - pf;\n            float daux = euclideanDist2(vaux); // Compute square distance from the point to this cell\n\n            if( daux<d )\n            {\n                d = daux; // keep min distance\n                v = vaux; // keep v of the cell with min dist\n                o = offset; // keep offset of the cell with min dist\n            }\n        }\n    }\n\n    // 2nd Worley pass (cell borders) \n    d=1e30;\n    for( int i=-2; i<=2; i++ )\n    {\n        for( int j=-2; j<=2; j++ )\n        {\n            offset = o + vec2(i,j); // Get global offset (Old offset + new (borders) offset)\n            noise = hash2( pi + offset ); // Get the noise for the int point + global offset\n            #ifdef ANIMATE\n            \tnoise = animateCell1(noise); // lets move these cells!\n            #endif\t\n            vaux = offset + noise - pf; \n\t\t\t\n            daux = dot( 0.5*(v+vaux), normalize(vaux-v)); // Compute square distance\n            d = min(d,daux); // Keep the minimun distance\n        }\n    }\n\t// Return the minimun distance and a lineal combination of the noise for coloring purposes\n    // Adding a sin that depends on the time we get the turning on and off effect of the texture\n    return vec2(d*2.0*(0.5*sin(iTime*1.6)+0.9),8.0*noise.x+5.0*noise.y);\n}\n\n// Returns a periodic color for the given value\nvec3 cellColor(float c)\n{\n    float r = 0.5*sin(c*0.7)+0.5;\n    float g = 0.5*cos(c*0.6)+0.5;\n    float b = 0.5*sin(c*c*0.1)+0.5;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xx;\n\t\n    vec2 c = cellNoise( SCALE*p ); // Get float cell noise\n    vec3 col = vec3(c.x,c.x,c.x); // Gray scale cell noise\n\t\n    col = c.x*cellColor(c.y); // Get the cell color\n    // Get the border color\n    col = mix( col, col - vec3(0.5), smoothstep( 0.2, 0.3, c.x ) ); // 1.0-c.x\n    col *= 2.0;    \n\t\n    fragColor = vec4(col,1.0);    \n}","name":"Buf B","description":"","type":"buffer"}]}