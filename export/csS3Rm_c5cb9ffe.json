{"ver":"0.1","info":{"id":"csS3Rm","date":"1667362442","viewed":173,"name":"Lyapunov Fractal Cube","username":"Desdenova","description":"A 3D Lyapunov Fractal in the shape of a cube.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["lyapunovfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 logisticMap(vec3 coord, int n, float x);\nfloat getForcedParameter(int n, vec3 coord);\nfloat getLambda(vec3 coord, float x0);\nvec3 getColor(float lambda);\nvec2 rotate(float theta, vec2 p);\nvec2 shear(float theta, vec2 p);\nfloat oscillate(vec2 range, float period);\nfloat pi = acos(-1.0);\n\n\n//uncomment one S-sequence at a time\n\n//S = ABC\nint s[3] = int[](0,1,2);\n\n//S = ACBC\n//int s[4] = int[](0,2,1,2);\n\n//S = ABBBCA\n//int s[6] = int[](0,1,1,1,2,0);\n\n//CACBCA\n//int s[6] = int[](2,0,2,1,2,0);\n\n\nint maxN = 4000; //number of iterations\nint colorScheme = 0; //(0=yellow-blue, 1=silvery)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.2);//background color\n    vec2 scaledCoord = vec2(0.0);\n    \n    //range is the dimensions of the cube\n    //default range is from 0 to 0->4 over 10 seconds:\n    vec2 range = vec2(0.0, oscillate(vec2(0.0,4.0),10.0));\n    //range = vec2(0.0,3.999999);\n    \n    //top face (AB-plane, C=range.y)\n    if(uv.x * -iResolution.x + uv.y * iResolution.y * sqrt(3.0) >= -iResolution.x/2.0 + iResolution.y * sqrt(3.0)/2.0\n    //&& uv.x * -iResolution.x + uv.y * iResolution.y * sqrt(3.0) <= -iResolution.x/2.0 + iResolution.y * sqrt(3.0)\n    && uv.x *  iResolution.x + uv.y * iResolution.y * sqrt(3.0) >=  iResolution.x/2.0 + iResolution.y * sqrt(3.0)/2.0\n    //&& uv.x *  iResolution.x + uv.y * iResolution.y * sqrt(3.0) <=  iResolution.x/2.0 + iResolution.y * sqrt(3.0)\n    ){        \n        scaledCoord = rotate(0.75*pi,\n            2.0*sqrt(2.0)*vec2(-iResolution.x/iResolution.y * 1.0/sqrt(3.0),1.0)*(uv-vec2(0.5,0.75)));\n        \n        scaledCoord = (range.y-range.x)*(scaledCoord+0.5)+range.x;\n        \n        col = getColor(getLambda(vec3(scaledCoord.x,scaledCoord.y,range.y),0.5));\n    }\n        \n    //left face (AC-plane, B=range.y)\n    if(/*uv.x * iResolution.x + uv.y * iResolution.y * sqrt(3.0) >= iResolution.x/2.0\n    && */uv.x * iResolution.x + uv.y * iResolution.y * sqrt(3.0) <= iResolution.x/2.0 + iResolution.y * sqrt(3.0)/2.0\n    //&& uv.x >= 0.5 - iResolution.y/iResolution.x * sqrt(3.0)/4.0\n    && uv.x <= 0.5){\n        col = vec3(1.0,0.0,0.0);\n        \n        scaledCoord = vec2(iResolution.x/iResolution.y,1.0)*(uv - 0.5);\n        \n        scaledCoord = vec2(4.0/sqrt(3.0),2.0) * (shear(pi/6.0, scaledCoord) + vec2(sqrt(3.0)/4.0,0.5));\n        \n        scaledCoord = (range.y-range.x)*scaledCoord+range.x;\n        \n        col = getColor(getLambda(vec3(scaledCoord.x,range.y,scaledCoord.y),0.5));\n    }\n    \n    //right face (BC-plane, A=range.y)\n    if(/*uv.x * -iResolution.x + uv.y * iResolution.y * sqrt(3.0) >= -iResolution.x/2.0\n    &&*/ uv.x * -iResolution.x + uv.y * iResolution.y * sqrt(3.0) <= -iResolution.x/2.0 + iResolution.y * sqrt(3.0)/2.0\n    //&& uv.x <= 0.5 + iResolution.y/iResolution.x * sqrt(3.0)/4.0\n    && uv.x >= 0.5){\n        col = vec3(0.0,0.0,1.0);\n        \n        scaledCoord = vec2(iResolution.x/iResolution.y,1.0)*(uv - 0.5);\n        \n        scaledCoord = vec2(-4.0/sqrt(3.0),2.0) * (shear(-pi/6.0, scaledCoord) + vec2(-sqrt(3.0)/4.0,0.5));\n        \n        scaledCoord = (range.y-range.x)*scaledCoord+range.x;\n        \n        col = getColor(getLambda(vec3(range.y,scaledCoord.x,scaledCoord.y),0.5));\n    }\n    \n    //if(length((uv-0.5)*vec2(iResolution.x/iResolution.y,1.0)) > 0.5)\n        //col = vec3(0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvec2 logisticMap(vec3 coord, int n, float x){\n    float r = getForcedParameter(n, coord);\n    x = r*x*(1.0-x);\n    float dx = r*(1.0-2.0*x);\n    return vec2(x,dx);\n}\n\nvec2 gaussMap(vec3 coord, int n, float x){\n    float alpha = 4.9;\n    float beta = getForcedParameter(n, coord);\n    x = exp(-alpha*x*x) + beta;\n    float dx = -2.0*x*alpha*exp(-alpha*x*x);\n    return vec2(x,dx);\n}\n\nfloat getForcedParameter(int n, vec3 coord){\n    n = int(mod(float(n-1), float(s.length())));\n    \n    switch(s[n]){\n        case 0: return coord.x; break;  //A\n        case 1: return coord.y; break;  //B\n        case 2: return coord.z; break;  //C\n        default: return 0.0;\n    }\n}\n\nfloat getLambda(vec3 coord, float x0){\n    float lambda = 0.0;\n    float maxLambda = pow(10.0,5.0);\n    int n0=600;//ignore the first 600 iterates (ignore the inital transient behavior)\n    vec2 info = vec2(x0,0.0);\n    \n    n0 = clamp(min(n0,maxN-n0),1,maxN); //make n0 smaller if maxN is small\n    \n    for(int n=1; n<=maxN && abs(lambda)<=maxLambda; n++){\n        info = logisticMap(coord, n, info.x);\n        \n        if(n>=n0)        \n            lambda += log(abs(info.y))/float(maxN);\n    }\n    \n    return lambda;\n}\n\nvec3 getColor(float lambda){\n    int numOfColorSchemes = 2;\n    colorScheme = clamp(colorScheme, 0, numOfColorSchemes-1);\n    float negScale = 1.0;\n    float posScale = 1.0;\n    \n    \n    switch(colorScheme){\n        case 0: //yellow-blue color scheme\n            //color goes from black to yellow as lambda goes from -inf to 0\n            negScale = 1.0; //this controls how quickly the color goes from black to yellow (bigger = faster)\n            //negScale = 1.7;\n            \n            \n            //color goes from blue to black as lambda goes from 0 to inf\n            posScale = 2.0; //this controls how quickly the color goes from blue to black (bigger = faster)\n            //posScale = 9.0;\n            \n            \n            if(lambda<=0.0){ //stable color\n                lambda = exp(abs(negScale) * lambda);\n                 \n                float cutoff = 0.98;                \n                vec3 col1 = vec3(0.0,0.0,0.0);\n                vec3 col2 = vec3(1.0,0.76,0.0);\n                vec3 col3 = vec3(1.0,0.8,0.7);\n                \n                if(lambda <= cutoff){\n                    return col1 + (col2-col1) * lambda/cutoff;\n                }else{\n                    return col2 + (col3-col2) * (cutoff-lambda)/(cutoff-1.0);\n                }\n                    \n                    \n            }else{ //chaotic color\n                lambda = exp(-abs(posScale) * lambda);\n                return vec3(0.0, 0.0, lambda);\n            }\n        break;\n        \n        case 1: //silvery color scheme\n            negScale = 0.5;\n            posScale = 4.0;\n            posScale = 8.0;\n            \n            if(lambda<=0.0){ //stable color\n                lambda = abs((1.0 - exp(negScale * lambda))/0.35);\n                return (0.5 + 0.5*sin(vec3(0.0,0.4,0.7) + 2.5 * lambda)) * pow(lambda, 0.25);\n            \n            }else{ //chaotic color\n                lambda = exp(-abs(posScale) * lambda);\n                return vec3(lambda, 0.0, 0.0);\n                //return vec3(0.0, lambda, 0.0);\n                //return vec3(0.0, 0.0, lambda);\n            }\n        break;\n        \n        default:\n        return vec3(0.0);\n    }\n}\n\nvec2 rotate(float theta, vec2 p){\n    return vec2(p.x*cos(theta)-p.y*sin(theta), p.x*sin(theta)+p.y*cos(theta));\n}\n\nvec2 shear(float theta, vec2 p){\n    return vec2(p.x, p.y + p.x*tan(theta));\n}\n\nfloat oscillate(vec2 range, float period){\n    return (range.y+range.x - (range.y-range.x)*cos(pi*iTime/period))/2.0;\n}","name":"Image","description":"","type":"image"}]}