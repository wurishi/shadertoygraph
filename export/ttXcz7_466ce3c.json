{"ver":"0.1","info":{"id":"ttXcz7","date":"1591672152","viewed":177,"name":"broken icosa","username":"darkfox","description":"icosahedron broken.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["icosahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// constant.\n#define pi 3.14159\n// palette\nconst vec3 black = vec3(0.2);\nconst vec3 green = vec3(0.3, 0.9, 0.4);\nconst vec3 white = vec3(1.0);\nconst vec3 silver = vec3(0.5);\n// for folding.\nconst vec3 nc5 = vec3(-0.5, -0.809017, 0.309017);\nconst vec3 pab5 = vec3(0.0, 0.0, 0.809017);\nconst vec3 pbc5 = vec3(0.5, 0.0, 0.809017);\nconst vec3 pca5 = vec3(0.0, 0.269672, 0.706011);\nconst vec3 nab5 = vec3(0.0, 0.0, 1.0);\nconst vec3 nbc5 = vec3(0.525731, 0.0, 0.850651);\nconst vec3 nca5 = vec3(0.0, 0.356822, 0.934172);\n// hsb to rgb.\nvec3 getRGB(float h, float s, float b){\n  vec3 c = vec3(h, s, b);\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// rotation.\nvec2 rotate(vec2 p, float t){\n  return p * cos(t) + vec2(-p.y, p.x) * sin(t);\n}\n// x axis rotation.\nvec3 rotateX(vec3 p, float t){\n  p.yz = rotate(p.yz, t);\n  return p;\n}\n// y axis rotation.\nvec3 rotateY(vec3 p, float t){\n  p.zx = rotate(p.zx, t);\n  return p;\n}\n// z axis rotation.\nvec3 rotateZ(vec3 p, float t){\n  p.xy = rotate(p.xy, t);\n  return p;\n}\n// fold H3 with counting.\nint foldH3Count(inout vec3 p){\n  int n = 0;\n  float _dot;\n  for(int i = 0; i < 5; i++){\n    if(p.x < 0.0){ p.x = -p.x; n++; }\n    if(p.y < 0.0){ p.y = -p.y; n++; }\n    _dot = dot(p, nc5);\n    if(_dot < 0.0){ p -= 2.0 * _dot * nc5; n++; }\n  }\n  return n;\n}\nvec3 getP5(vec3 u){\n  return u.x * pab5 + u.y * pbc5 + u.z * pca5;\n}\nvec3 getP5(float u1, float u2, float u3){\n  return u1 * pab5 + u2 * pbc5 + u3 * pca5;\n}\n// sphere.\nfloat sphere(vec3 p, float r){\n  return length(p) - r;\n}\n// bar. (n:direction, r:radius)\nfloat bar(vec3 p, vec3 n, float r){\n  return length(p - dot(p, n) * n) - r;\n}\n// half open bar.\nfloat halfBar(vec3 p, vec3 n, float r){\n  return length(p - min(0.0, dot(p, n)) * n) - r;\n}\n// update distance.\n// 0:min, union.\n// 1:max, intersection.\n// 2:minus min, difference.\nvoid updateDist(inout vec3 color, inout float dist, vec3 c, float d, int modeId){\n  if(d < dist && modeId == 0){ color = c; dist = d; }\n  if(d > dist && modeId == 1){ color = c; dist = d; }\n  if(-d > dist && modeId == 2){ color = c; dist = -d; }\n}\n// map function.\nvec4 map(vec3 p){\n  vec3 color = black;\n  float t = 1e20;\n  int n = foldH3Count(p);\n  float base = 1.0;\n  float thick = 0.1;\n  float ratio = 2.0 + sin(iTime * pi);\n  base *= ratio;\n  thick *= ratio;\n  updateDist(color, t, getRGB(float(n) / 15.0, 1.0, 1.0), max(dot(p - pbc5 * base, nca5), dot(p - pbc5 * (base - thick), -nca5)), 0);\n  vec3 v = normalize(cross(pbc5 - pab5, nca5));\n  updateDist(color, t, black, dot(p - getP5(0.0, 1.0 / ratio, 0.0) * base, v), 1);\n  updateDist(color, t, silver, halfBar(p - getP5(0.0, 0.0, 0.9) * base, nca5, 0.05), 0);\n  return vec4(color, t);\n}\n// normal vector.\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n  // mathematical procedure.\n  vec3 n;\n  n.x = map(p + eps.xyy).w - map(p - eps.xyy).w;\n  n.y = map(p + eps.yxy).w - map(p - eps.yxy).w;\n  n.z = map(p + eps.yyx).w - map(p - eps.yyx).w;\n  return normalize(n);\n}\n// ray marching.\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; // searching limit.\n  const float precis = 0.001; // precision.\n  const int ITERATION = 64; // iteration limit.\n  float h = precis * 2.0; // heuristics.\n\n  float t = 0.0; // current distance.\n\n  float result = -1.0;\n  for(int i = 0; i < ITERATION; i++){\n    if(h < precis || t > maxd){ break; }\n    // adding heuristics value.\n    h = map(camera + t * ray).w;\n    t += h;\n  }\n  // if t < maxd, it means success(h < precis).\n  if(t < maxd){ result = t; }\n  return result;\n}\n// camera move.\nvoid transform(inout vec3 p){\n  p = rotateX(p, pi * iTime * 0.3);\n  p = rotateY(p, pi * iTime * 0.15);\n}\n// background.\nvec3 getBackground(vec2 p){\n  vec2 i = floor(p * 10.0);\n  vec3 color = mix(green, white, 0.6 + 0.3 * mod(i.x + i.y, 2.0));\n  return color;\n}\n// main.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color;\n  // ray vector.\n  vec3 ray = normalize(vec3(p, -1.8));\n  // camera position.\n  vec3 camera = vec3(0.0, 0.0, 4.5);\n  // light vector.\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  // camera rotation.\n  transform(ray);\n  transform(camera);\n  transform(light);\n  color = getBackground(p);\n  // get ray marching result.\n  float t = march(ray, camera);\n  // if t > -0.001, it means success. if not, background color.\n  if(t > -0.001){\n    vec3 pos = camera + t * ray;\n    vec3 n = calcNormal(pos);\n    // lighting.\n    float diff = clamp((dot(n, light) + 0.5) * 0.7, 0.3, 1.0);\n    vec3 baseColor = map(pos).xyz;\n    baseColor *= diff;\n    // fadeout.\n    color = mix(baseColor, color, tanh(t * 0.04));\n  }\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}