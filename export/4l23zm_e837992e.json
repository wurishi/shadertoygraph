{"ver":"0.1","info":{"id":"4l23zm","date":"1427739997","viewed":190,"name":"Moons","username":"shezard","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const int MAT0 = 0;\nconst int MAT1 = 1;\nconst int MAT2 = 2;\nconst int MAT3 = 3;\n\nfloat noise(in vec2 uv) {\n\treturn sin(1.5*uv.x)*sin(1.5*uv.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 uv ) {\n    float f = 0.0;\n    f += 0.5000*noise(uv); uv = m*uv*2.02;\n    f += 0.2500*noise(uv); uv = m*uv*2.03;\n    f += 0.1250*noise(uv); uv = m*uv*2.01;\n    f += 0.0625*noise(uv);\n    return f/0.9375;\n}\n\nfloat fbm2( in vec2 uv ){\n   vec2 p = vec2( fbm( uv + vec2(0.0,0.0) ),\n                  fbm( uv + vec2(5.2,1.3) ) );\n\n   return fbm( uv + 4.0*p );\n}\n\nfloat rand(in vec2 uv){\n    return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rep(vec3 p, vec3 c) {\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 torus(vec3 p, vec2 t, int mat) {\n    \n  t = vec2(1.5,0.3);\n    \n  vec2 q = vec2(length(p.xz)-t.x,p.y*8.0)-vec2(0.1);\n  return vec2(length(q)-t.y, mat);\n}\n\nvec2 sphere(in vec3 p, float r, int mat) {\n    return vec2(length(p) - r, mat);\n}\n\nvec2 add(in vec2 a, in vec2 b) {\n \n    int mat = 0;\n    if(a.x < b.x) {\n      mat = int(a.y);\n    } else {\n      mat = int(b.y);\n    }\n    \n    return vec2(min(a.x,b.x), mat);\n}\n\nfloat map(in vec3 p, inout int mat) {\n   \n   vec2 scene = vec2(999.0, MAT0);\n    \n   vec3 meteorP = vec3(p.x - mod(iTime,12.0)+6.0,\n                       p.y + 2.0,\n                       p.z);\n    \n   float distorsion = .1 + 0.05*fbm(p.yz*24.0);\n   vec2 meteor = sphere(meteorP, distorsion, MAT3);\n    \n   scene = add(scene, meteor);\n    \n   p.xy = rotate(p.xy,.075);\n   p.yz = rotate(p.yz,-.05);\n    \n   p.xz = rotate(p.xz,iTime*.35);\n\n   vec2 planet = sphere(p, 1.0, MAT0);\n  \n   vec2 ring = torus(p,vec2(1.5,0.1), MAT3);\n    \n   vec2 moon = sphere(p-vec3(1.7,1.0,0.0),0.2, MAT2);\n \n    \n   scene = add(scene, planet);\n   scene = add(scene, ring);\n   scene = add(scene, moon);\n    \n   mat = int(scene.y);\n    \n   return scene.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // Approximation de la correction de fov\n    //p.x /= cos(p.y*1.1);\n    //p.y /= cos(p.y*1.1);\n    \n    vec3 ro = vec3(0.0,0.0,3);\n    vec3 rd = normalize(vec3(p,-1.0));\n    \n    float h = 0.001;\n    float tmax = 20.0;\n    float t = 1.0;\n    \n    int mat = MAT0;\n    \n    vec3 c = vec3(.3,.1,.1);\n    vec3 ao = vec3(0.0);\n    \n    for(int i = 0 ; i < 100 ; i++) {\n        \n        if(h < 0.001 || t > tmax ) {\n        \tao = vec3(1.0) - float(i)/100.0;\n            break;\n        }\n        \n        h = map(ro + t *rd, mat);\n        t += h;\n    }\n    \n    if(t<tmax) {\n      \t\n        vec3 pos = ro+rd*t;\n        \n        vec2 r = vec2(0.00001,0.0);\n        vec3 nor = normalize(vec3(map(pos+r.xyy, mat)-map(pos-r.xyy, mat),\n                                  map(pos+r.yxy, mat)-map(pos-r.yxy, mat),\n                                  map(pos+r.yyx, mat)-map(pos-r.yyx, mat)));\n      \t\n        if(mat == MAT0) {\n          c = vec3(.85, .15, .15) + fbm2(vec2(pos.x-iTime*.125,pos.y));\n        } else if(mat == MAT1) {\n          c = vec3(.85, .15, .15) + fbm2(vec2(sin(pos.x-iTime*.125),cos(pos.x-iTime*.125)));\n        } else if(mat == MAT2) {\n          c = vec3(.40,.60,.20) + fbm2(vec2(pos.x+iTime*0.125,pos.y));\n        } else if(mat == MAT3) {\n          c = vec3(.80,.40,.20) * pos.y + fbm2(vec2(pos))*0.1;\n        }\n        \n        vec3 lat = vec3(0.5773);\n        \n        c *= clamp(dot(nor,lat), 0.0, 1.0);\n        c += vec3(.2,.3,.2) * clamp(dot(-nor.zyx,lat), 0.0, .4);;\n\n        c += ao * .05;\n        \n    } else {\n        c = vec3(.2,.3,.5)*fbm2(vec2(p.x+iTime*.125,p.y))*pow(rand(p.xy),10.0);\n    }\n    \n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}