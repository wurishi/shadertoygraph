{"ver":"0.1","info":{"id":"lsySDz","date":"1463775656","viewed":296,"name":"Wax Tunnel (Split Screen)","username":"MichaelPohoreski","description":"Instructions:Click & Drag mouse left/right\n\nVerification of simplified Stephane Cuillerdier's wax tunnel in the half-half.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["tunnel","wax","splitscreen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\ntrying to do one approch of Sub Surface Scattering.\nthe wax is better without texture lol. do you prefer with or without displaced texture ?\n*/\n\nconst float AA = 4.;\n   \n// shane code\nvoid mainImage( out vec4 f, vec2 g )\n{\n    // Split screen\n    float    ar = iResolution.x/iResolution.y; // aspect ratio\n    vec2 p = ar*(-iResolution.xy+2.0*     g.xy)/iResolution.y;\n    vec2 m = ar*(-iResolution.xy+2.0*iMouse.xy)/iResolution.y;\n\n    if( p.x > m.x ) // right-half\n        f = vec4( clamp(texture(iChannel0,g/iResolution.xy).rgb, 0., 1.), 1. );\n    else // left-half\n    {\n       \tvec2 si = iResolution.xy;\n        vec2 uv = g/si;\n        vec3 col = vec3(0);\n        for (float i=0.; i<AA; i++)\n        {\n            vec2 uvOffs = uv + vec2(floor(i/AA), mod(i, AA))*(2./si/AA);\n            col += clamp(texture(iChannel0,uvOffs).rgb, 0., 1.);\n        }\n        f = vec4(col/AA, 1.);   \n    }\n\n    f *= smoothstep( 0.006, 0.008, abs(p.x-m.x) );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n#define POINT_FLARE\n//#define POSITIVE_DISPLACE\n\nfloat hash(float n){ return fract(cos(n)*76543.);}\nvec3 hash3(vec3 p){return normalize(vec3(hash(p.x), hash(p.y), hash(p.z)));}\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.2), sin(t*0.2)) * 2.;\n}\n\nvec2 df(vec3 p)\n{\n\tp.xy -= path(p.z);\n\tp *= RotZ(p.z*0.45);\n\tp.xy *= sin(p.z + cos(p.z));\n\tfloat y = 1.72 - max(max(p.x, -p.x) + p.y, -p.y);\n\tvec3 tex = texture(iChannel0, vec2(max(p.x, -p.x), p.z)*0.06).rgb;\n\tfloat d = dot(tex, vec3(0.71));\n#ifdef POSITIVE_DISPLACE\n    d *= -1.;\n#endif\n\tvec2 res = vec2(y+d, 1);\n    return res;\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat SubSurfaceScattering(vec3 surfPoint, vec3 lightPoint)\n{\n\tvec3 lightdir = normalize(lightPoint - surfPoint);\n\tfloat lightlen = length(lightPoint - surfPoint);\n\t\n\tvec3 rd = lightdir;\n\t\n\tconst float sssiter = 300.; // sub surface scattering steps // decrease cause banding\n\tfloat ms = lightlen / sssiter; // min step len\n\t\n\tvec3 p = surfPoint;\n\t\n\tfloat d = 0., s = 0.;\n\t\n\tfloat accum = 0.; // accumulation range [0 1]\n\t\n\tfor (float i=0.;i<sssiter;i++)\n\t{\n\t\t// next ray direction ( use hash for perturbated normal like)\n\t\trd = refract(rd, hash3(normalize(lightPoint-p)), 0.4); \n        \n\t\t// we have only one ray\n\t\t// so for create cheap ray distribution we change rd and \n\t\t// ray march distance d but keep original surfPoint\n\t\tp = surfPoint + rd * d;\n\t\t\n        // at beginning i would use different attenuation coef for inside ond outside ray\n        // but there is somme noise, and the result was not very good, so i compute the ray march distance only when ray is inside material\n        // i can break when s is positive, but it add some noise, and like i continue to evaluate the ray, \n        // the accum will be better for closely thin Walls \n\t\t// s negative => interior of the df\n\t\tif (s < 0.) accum += ms ; \n\t\t//else accum += ms * ms;\n\n\t\ts = df(p).x;\n\t\td += ms; // d must be positive\n\t}\n\t\n\treturn accum;\n}\n\nvec4 light(vec3 ro, vec3 rd, float d, vec3 lightpos, vec3 lc)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, 0.1);\n\tvec3 refl = reflect(rd,n);\n\t\t\n\tvec3 lightdir = normalize(lightpos - p);\n\tfloat lightlen = length(lightpos - p);\n\t\n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, lightdir ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, lightdir ), 0.0, 1.0 ),16.);\n        \n\tvec3 brdf = vec3(0);\n\tbrdf += amb * vec3(1,0,0); // color mat\n\tbrdf += diff * 0.6;\n\tbrdf += spe * lc * 0.8;\n\t\n\treturn vec4(brdf, lightlen);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\n// not very satisfied by this, because, the redius of the point light not change very \n// well along z axis and the point light seems to be not to the good z, when is close to the cam its very bad :)\nvec3 DrawPointLight(vec3 ro, vec3 rd, float d, vec3 lp, float len, vec3 lc)\n{\n\tvec3 res = vec3(0);\n\tif (d>=len)\n\t{\n\t\tvec3 k = rd - normalize(lp-ro);\n\t\tres += lc * (len / 1000.) /dot(k, k);\n\t}\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 3.;\n     \n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord-si)/si.y;\n    \n    vec3 col = vec3(0.);\n    \n\t// first pointclose to the cam, light for the first plane ( without subsurface scatering)\n    vec3 lpNear = vec3(path(t+0.55),t+0.55);\n    \n    // second point light, far (with subsurface scatering)\n\tfloat k = (sin(t*0.3)*.5+.5);\n    vec3 lpFar = vec3(path(t+0.55 + 22.56*k),t+0.55 + 22.56*k);\n\t\n\tvec3 ro = vec3(path(t),t);\n  \tvec3 cv = vec3(path(t+0.1),t+0.1);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 100.;\n    float s = 1., so = s;\n    float d = 1.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (s<0.002*log(d*d)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s * (s>0.1?0.15:0.1);\n    }\n    \n\tif (d<md)\n\t{\n\t\tvec3 p = ro+rd*d;\n\t\t\n\t\tvec4 lightNear = light(ro, rd, d, lpNear, vec3(1));\n\t\tfloat attenNear = 0.9 / lightNear.w; // basic attenuation\n\t\tcol += lightNear.rgb * attenNear;\n\t\t\n\t\tvec4 lightFar = light(ro, rd, d, lpFar, vec3(1,0.57,0));\n        // ratio of len from surface point to the light in the material and len from cam to the light \n\t\tfloat attenFar = 0.8 * (lightFar.w - SubSurfaceScattering(p, lpFar)) / lightFar.w; \n\t\tcol += lightFar.rgb * attenFar;\n\t\t\n        #ifdef POINT_FLARE\n\t\tcol += DrawPointLight(ro, rd, d, lpFar, lightFar.w, vec3(1,0.57,0));\n        #endif\n\t}\n\t\n\tfragColor = vec4(col,1);\n}","name":"Buf A","description":"","type":"buffer"}]}