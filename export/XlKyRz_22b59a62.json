{"ver":"0.1","info":{"id":"XlKyRz","date":"1534935862","viewed":431,"name":"Hexagon effect","username":"Ion824","description":"My recreation of a hexagon screen effect (inspired by Heroes of the storm screen effect when you die)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["filter","hexagon","imageeffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 cube_to_axial(vec3 cube)\n{\n    float q = cube.x;\n    float r = cube.z;\n    return vec2(q, r);\n}\n\nvec3 axial_to_cube(vec2 hex)\n{\n    float x = hex.x;\n    float z = hex.y;\n    float y = -x-z;\n    return vec3(x, y, z);\n}\n\nvec3 cube_round(vec3 cube)\n{\n    float rx = round(cube.x);\n    float ry = round(cube.y);\n    float rz = round(cube.z);\n\n    float x_diff = abs(rx - cube.x);\n    float y_diff = abs(ry - cube.y);\n    float z_diff = abs(rz - cube.z);\n\n    if (x_diff > y_diff && x_diff > z_diff)\n        rx = -ry-rz;\n    else if (y_diff > z_diff)\n        ry = -rx-rz;\n    else\n        rz = -rx-ry;\n\n    return vec3(rx, ry, rz);\n}\n\nvec2 hex_round(vec2 hex)\n{\n    return cube_to_axial(cube_round(axial_to_cube(hex)));\n}\n\nvec2 pixel_to_pointy_hex(vec2 point)\n{\n\n    float q = (sqrt(3.0)/3.0 * point.x  -  1./3.0 * point.y);\n    float r = (                        2.0/3.0 * point.y);\n    return hex_round(vec2(q, r));\n}\n\nvec2 RandomDirection2D(vec2 hexCoord)\n{\n\tfloat azimuth = rand(hexCoord) * 2.0 * M_PI;\n\treturn vec2(cos(azimuth), sin(azimuth));\n}\n\nfloat GetRefractionFactor(vec2 uv)\n{\n\tfloat dx = abs(0.5 - uv.x);\n    float dy = abs(0.5 - uv.y);\n    float dist = sqrt(dx * dx + dy * dy);\n    dist *= 2.0;\n    dist = clamp(dist, 0.0, 1.0);\n    //if(dist <= 0.5) return 0.0;\n    return pow(dist, 1.5);\n}\n\nfloat GetVignetteFactor(vec2 uv)\n{\n\tfloat dx = abs(0.5 - uv.x);\n    float dy = abs(0.5 - uv.y);\n    float dist = sqrt(dx * dx + dy * dy);\n    dist *= 2.0;\n    //dist = clamp(dist, 0.0, 1.0);\n    //if(dist <= 0.5) return 0.0;\n    if(dist < 0.9/* + rand(uv) * 0.4*/) return 1.0;\n    dist += 0.10;\n    return pow(dist, 0.35);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec2 uv0 = fragCoord / iResolution.xy;\n    \n    float hexSize = 13.0;\n    \n    float H = sqrt(3.0) * hexSize;\n    float W = 2.0 * hexSize;\n    \n    float hexSpaceX = uv.x / W;\n    float hexSpaceY = uv.y / H;\n    \n    float s = floor(hexSpaceX);\n    float t = floor(hexSpaceY);\n    \n    float d = distance(vec2(hexSpaceX, hexSpaceY), vec2(s,t));\n    \n    vec2 hexa = pixel_to_pointy_hex(vec2(hexSpaceX, hexSpaceY));\n    \n    float rr = rand(vec2(hexa.x,hexa.x));\n    float gg = rand(vec2(hexa.y,hexa.y));\n    float bb = rand(vec2(hexa.x,hexa.y));\n    float sc = rand(vec2(hexa.y,hexa.x));\n    \n    vec2 offsetDir = RandomDirection2D(hexa);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec3 col = vec3(rr, gg, bb);\n\n    // Output to screen\n    float factor = GetRefractionFactor(uv0);\n    vec2 dist_uv = uv0 + offsetDir /** vec2(sin(iTime), sin(iTime + 1.05))*/* factor * 0.02;\n    vec3 col = texture(iChannel0, dist_uv).xyz;\n    col -= vec3(rr,gg,bb) * sc * factor * 0.05;\n    col /= GetVignetteFactor(uv0);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}