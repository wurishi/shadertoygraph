{"ver":"0.1","info":{"id":"mdf3DM","date":"1666209712","viewed":93,"name":"Smooth operators for SDF","username":"Envy24","description":"Hold LMB and drag to change SMOOTHNESS to see distance fields.\nPress Q to toggle visualization mode.","likes":4,"published":1,"flags":16,"usePreview":0,"tags":["sdf","intersection","smooth","difference","union","operator"],"hasliked":0,"parentid":"DdX3W7","parentname":"Operators for SDF"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )\n#define UNIT                      (  5.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n//#define SMAA(x)                   ( smoothstep(UNIT, 0., abs(x)) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define KEY_Q                     ( 81.5 )\n#define DF_MODE                   ( texelFetch(iChannel3,ivec2(KEY_Q,2),0).x > 0.)\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\n\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 ndc_offset)\n{\n    /**\n    vec2 M = \n        iMouse.z > 0. ?\n            iMouse.xy - R.xy * 0.5 : // map xy from [0; R.x][0; R.y] to [-R.x/2; R.x/2][-R.y/2; R.y/2]\n            vec2(0);                 // supress mouse offset\n    SC -= M;                         // apply mouse offset\n    /**/\n    SC = 2. * SC - R.xy;             // map xy from [0; R.x][0; R.y] to [-R.x; R.x][-R.y; R.y]\n    SC /= R.y;                       // map xy from [-R.x; R.x][-R.y; R.y] to [-AR; AR][-1; 1]\n    SC *= scale;                     // map xy from [-AR;AR][-1;1] to [-AR*scale; AR*scale][-scale; scale]\n    \n    return SC - ndc_offset;          // apply \"static\" offset in ndc space\n}\n#define STD_MAP(SC) ( map_to_centered_ndc(SC, 1., vec2(0)) )\n\n// Source: https://iquilezles.org/articles/smin/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 scene_sdf(vec2 NDC)\n{\n    float offs = sinOSC(-4.*UNIT, 4.*UNIT, iTime);\n    vec2 diskA = vec2(0., offs),\n         diskB = vec2(6.*offs, 0.);\n    return \n        vec2(\n            diskSDF_L2(NDC, diskA, 15.*UNIT),\n            diskSDF_L2(NDC, diskB, 15.*UNIT));\n}\n\n/* IQ coloring scheme */\nvec3 colorize_field(float dist, vec3 color)\n{\n    // Change color if dist is negative.\n    color = 1.0 - sign(dist) * color;\n    \n    // Attenuate color around edges.\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n    \n    // Add interleaved curves.\n\tcolor *= 0.7 + 0.2 * cos(50.0 * dist);\n    \n    // Add white edges.\n    return mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 6./R.y, abs(dist)));\n}\n\n#define H ( 0.53*0.5 )\n#define SMOOTHNESS ( LMB_IS_HOLD == true ? iMouse.y/(R.y*3.) : 0.05 )\n\nvoid right_sub_scene0(in vec2 SC, inout vec3 color)\n{   \n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(1,0.795));\n    if (!(SC.x > R.x/2. && abs(NDC.y) < H)) { return; }\n    \n    vec2 sdf = scene_sdf(NDC);    \n    if (DF_MODE == true) { color = colorize_field( opSmoothIntersection(sdf.x, sdf.y, SMOOTHNESS), vec3(0.1, 0.4, 0.7) ); }\n    else { color = mix( color, vec3(1,0,0), SMAA(opSmoothIntersection(sdf.x, sdf.y, SMOOTHNESS)) ); }   \n}\n\nvoid right_sub_scene1(in vec2 SC, inout vec3 color)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(1,0.8-0.535));\n    if (!(SC.x > R.x/2. && abs(NDC.y) < H)) { return; }\n    \n    vec2 sdf = scene_sdf(NDC); \n    if (DF_MODE == true) { color = colorize_field( opSmoothUnion(sdf.x, sdf.y, SMOOTHNESS), vec3(0.1, 0.4, 0.7) ); }\n    else { color = mix( color, vec3(1,0,0), SMAA(opSmoothUnion(sdf.x, sdf.y, SMOOTHNESS)) ); }\n}\n\nvoid right_sub_scene2(in vec2 SC, inout vec3 color)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(1,-0.8+0.535));\n    if (!(SC.x > R.x/2. && abs(NDC.y) < H)) { return; }\n    \n    vec2 sdf = scene_sdf(NDC);   \n    if (DF_MODE == true) { color = colorize_field( opSmoothSubtraction(sdf.x, sdf.y, SMOOTHNESS), vec3(0.1, 0.4, 0.7) ); }\n    else { color = mix( color, vec3(1,0,0), SMAA(opSmoothSubtraction(sdf.x, sdf.y, SMOOTHNESS)) ); }\n}\n\nvoid right_sub_scene3(in vec2 SC, inout vec3 color)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(1,-0.795));\n    if (!(SC.x > R.x/2. && abs(NDC.y) < H)) { return; }\n    \n    vec2 sdf = scene_sdf(NDC);    \n    if (DF_MODE == true)\n    { color = colorize_field( opSmoothSubtraction(sdf.y, sdf.x, SMOOTHNESS), vec3(0.1, 0.4, 0.7) ); }\n    else { color = mix( color, vec3(1,0,0), SMAA(opSmoothSubtraction(sdf.y, sdf.x, SMOOTHNESS)) ); }\n}\n\nvoid left_sub_scene(in vec2 SC, inout vec3 color)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(-AR+AR/2.,0));\n    float offs = sinOSC(-12.*UNIT, 12.*UNIT, iTime);\n    vec2 diskA = vec2(0., offs),\n         diskB = vec2(6.*offs, 0.);\n    /*Coloring*/\n    color = mix( color, vec3(0,1,0), SMAA(diskSDF_L2(NDC, diskA, 45.*UNIT)) );\n    color = mix( color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, diskB, 45.*UNIT)) );  \n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec3 color = vec3(1);\n    \n    right_sub_scene0(SC, color);\n    right_sub_scene1(SC, color);\n    right_sub_scene2(SC, color);\n    right_sub_scene3(SC, color);\n    \n    vec2 NDC = STD_MAP(SC);\n\n    color -= vertical_line(NDC, 0.);\n    \n    if (NDC.x > 0.)\n    {\n        color -= horizontal_line(NDC, 0.);\n        color -= horizontal_line(abs(NDC), 0.53);\n    }\n    else { left_sub_scene(SC, color); }\n    \n    O = vec4(color, 1); \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}","name":"Common","description":"","type":"common"}]}