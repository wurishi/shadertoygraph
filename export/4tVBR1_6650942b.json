{"ver":"0.1","info":{"id":"4tVBR1","date":"1541822307","viewed":740,"name":"Triforce","username":"surma","description":"Much shader, very animation, wow.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["zelda","trifoce"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nfloat fsin(float f, float t) {\n  return sin(t/f * 2.0 * PI);\n}\n\n\nfloat psin(float f, float t) {\n  return fsin(f, t) * 0.5 + 0.5;\n}\n\nfloat minmaxsin(float min, float max, float f, float t) {\n  return psin(f, t) * (max - min) + min;\n}\n\nfloat spike(float steepness, float at, float x) {\n  return exp(-pow(x-at, 2.0) * steepness);\n}\n\nfloat bezier1(float p1, float p2, float t) {\n  return 0.0 + 3.0*pow(1.0-t, 2.0)*t*p1 + 3.0*(1.0-t)*pow(t, 2.0)*p2 + pow(t, 3.0);\n}\n\nvec2 bezier2(vec2 p1, vec2 p2, float t) {\n  return vec2(\n    bezier1(p1.x, p2.x, t),\n    bezier1(p1.y, p2.y, t)\n  );\n}\n\nfloat bezier(vec2 p1, vec2 p2, float x0) {\n  float t = 0.5;\n  vec2 p;\n  for(int i = 1; i < 10; i++) {\n    p = bezier2(p1, p2, t);\n    if(p.x < x0) {\n      t += pow(2.0, float(-i));\n    } else {\n      t -= pow(2.0, float(-i));\n    }\n  }\n  return bezier2(p1, p2, t).y;\n}\n\nmat3 translate(vec2 d) {\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 1.0,\n    -d.x, -d.y, 1.0\n  );\n}\n\nmat3 rotate(float alpha) {\n  return mat3(\n    cos(alpha), sin(alpha), 0.0,\n    -sin(alpha), cos(alpha), 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nmat3 scale(vec2 s) {\n  return mat3(\n    s.x, 0.0, 0.0,\n    0.0, s.y, 1.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nfloat sdHalfplane(vec2 normal, vec2 o, vec2 p) {\n  return dot(normal, -o-p);\n}\n\nvec2 sdTranslate(vec2 delta, vec2 p) {\n  return p + delta;\n}\n\nfloat sdUnion3(float f1, float f2, float f3) {\n  return min(min(f1, f2), f3);\n}\n\n\nfloat sdIntersection3(float f1, float f2, float f3) {\n  return max(max(f1, f2), f3);\n}\n\nfloat deg2rad(float deg) {\n  return deg/360.0 * 2.0 * PI;\n}\n\nfloat sdTriangle(float size, vec2 p) {\n  return sdIntersection3(\n\tsdHalfplane(\n      vec2(\n        cos(deg2rad(0.0)), \n        sin(deg2rad(0.0))\n      ), \n      vec2(\n        cos(deg2rad(0.0))*size, \n        sin(deg2rad(0.0))*size\n      ), \n      p\n    ),\n    sdHalfplane(\n      vec2(\n        cos(deg2rad(120.0)), \n        sin(deg2rad(120.0))\n      ), \n      vec2(\n        cos(deg2rad(120.0))*size,\n        sin(deg2rad(120.0))*size\n      ), \n      p\n    ),\n    sdHalfplane(\n      vec2(\n        cos(deg2rad(240.0)), \n        sin(deg2rad(240.0))\n      ), \n      vec2(\n        cos(deg2rad(240.0))*size,\n        sin(deg2rad(240.0))*size\n      ), \n      p\n    )\n  );\n}\n\nvec2 rotatePoint(vec2 o, float angle, vec2 p) {\n  return sdTranslate(-o, (rotate(angle) * vec3(sdTranslate(o, p), 1.0)).xy);\n}\n\nfloat maxTime = 5.0;\n\nfloat time() {\n  return mod(iTime, maxTime);\n}\n\nfloat subTimeline(float start, float end) {\n  return (clamp(\n    time(),\n    start,\n    end\n  ) - start) / (end - start);\n}\n\nfloat triangleRotateTimeline() {\n  float t = subTimeline(2.0, 3.0);\n  \n  return bezier(vec2(0.7, 0.0), vec2(0.3, 1.0), t) * (360.0 + 120.0);\n}\n\nfloat step2(float e1, float e2, float t) {\n  return step(e1, t) * (1.0 - step(e2, t));\n}\n\nvec2 triangleTranslateTimeline(vec2 start, vec2 end) {\n  float t1 = subTimeline(1.3, 2.0);\n  float t2 = 1.0 - subTimeline(3.0, 3.7);\n  \n  float t = step2(1.3, 2.0, time())*t1 + step2(3.0, 3.7, time())*t2 + step2(2.0, 3.0, time());\n\n  return mix(\n    start,\n    end,\n    bezier(vec2(0.7, 0.0), vec2(0.3, 1.0), t)\n  );\n}\n\nfloat sdWorld(vec2 p) {\n  float outset = 1.5;\n  float size = 50.0;\n  float side = 2.0 * size * sqrt(3.0);\n  p = rotatePoint(vec2(0.0), deg2rad(90.0), p);\n  \n  vec2 t1 = rotatePoint(vec2(0.0), deg2rad(0.0), vec2(2.0*size, 0.0));\n  vec2 t2 = rotatePoint(vec2(0.0), deg2rad(120.0), vec2(2.0*size, 0.0));\n  vec2 t3 = rotatePoint(vec2(0.0), deg2rad(240.0), vec2(2.0*size, 0.0));\n\n  float r = deg2rad(triangleRotateTimeline() + 60.0);\n  return sdUnion3(\n    sdTriangle(size, rotatePoint(vec2(0.0), r, sdTranslate(triangleTranslateTimeline(t1, outset*t1),  p))),\n    sdTriangle(size, rotatePoint(vec2(0.0), r, sdTranslate(triangleTranslateTimeline(t2, outset*t2), p))),\n    sdTriangle(size, rotatePoint(vec2(0.0), r, sdTranslate(triangleTranslateTimeline(t3, outset*t3), p)))\n  );\n}\n\nmat3 camera(vec2 pos, float s, float alpha) {\n  return rotate(alpha) * scale(vec2(s)) * translate(pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pixel) {\n  float radiance = 50.0;\n  float ripples = 10.0;\n  vec2 center = iResolution.xy/2.0;\n  mat3 cameraT = camera(center, 1.0, 0.0);\n  pixel = (cameraT * vec3(pixel, 1.0)).xy;\n\n  float d = sdWorld(pixel);\n  fragColor = mix(\n    vec4(vec3(0.2), 1.0),\n    mix(\n      vec4(vec3(0.8), 1.0),\n      vec4(vec3(0.6), 1.0),\n      spike(3.0, 3.0, mod(d - iTime*10.0, ripples))* clamp(0.0, radiance, radiance-d)/radiance\n    ),\n    clamp(0.0, 1.0, d)\n  );\n}\n","name":"Image","description":"","type":"image"}]}