{"ver":"0.1","info":{"id":"l3jGWD","date":"1708475408","viewed":61,"name":"spiral attempt 1","username":"hackerzilla","description":"Learning to write shaders by making a spiral.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spiral","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Following portion written with some help from GPT 4.0\n    // Although I got most of the way there, GPT just helped with the aspect ration and threshold logic\n    // and specific values for a and b. \n    // Normalized coordinates\n    float PI = 3.141592653589793;\n    float scale = 3.5;\n    vec2 offset = vec2(0.0, 0.1);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv = scale * (uv + offset);\n    \n    // Rotate the uv coords by an angle every frame\n    float angularSpeed = 0.5;\n    float rot = iTime * angularSpeed;\n    \n    mat2 rotMat;\n    rotMat[0] = vec2(cos(rot), sin(rot)); // first column\n    rotMat[1] = vec2(-sin(rot), cos(rot));\n    \n    //uv = rotMat * uv;\n    \n    // Convert to polar coordinates\n    float r = length(uv);\n    //float theta = atan(uv.y, uv.x);\n    //float theta = atan(uv.y, uv.x) - 0.1 * sin(pow(iTime * 1.0, 1.0));\n    float theta = atan(uv.y, uv.x);\n    \n    // Parameters for the spiral: adjust these as needed\n    float a = 0.5; //0.2 * sin(iTime * 1.1); // Starting radius\n    float b = 0.15 + 0.1 * sin(iTime); // How tightly the spiral winds\n    \n    // Calculate the ideal radius for the current angle\n    \n    float rIdeal;\n    float minDist = 100000.;\n    float bestRing = 0.;\n    float dist;\n    float prevDist = 100000.;\n    for (float i = 1.; i < 10.; i++)\n    {\n        rIdeal = a + b * theta * 2. * PI * i;\n        dist = abs(r - rIdeal);\n        if (dist < minDist)\n        {\n            minDist = dist;\n            bestRing = i;\n        }\n        if (dist > prevDist)\n        {\n            i = 10.; // break loop\n        }\n        prevDist = dist;\n    }\n    \n    // Determine the distance to the spiral\n    \n    \n    // Threshold for being \"on\" the spiral\n    float threshold = 0.1;\n    \n    // Color the pixel\n    if (minDist < threshold) {\n        fragColor = vec4(vec3(minDist), 1.0); // Black\n    } else {\n        fragColor = vec4(0.3, (1.0 + sin(1.0 * uv.x * uv.y - uv.y + 10.0)) / 2.0, 0.9, 1.0); \n    }\n}\n","name":"Image","description":"","type":"image"}]}