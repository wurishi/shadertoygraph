{"ver":"0.1","info":{"id":"st3XWs","date":"1640230090","viewed":68,"name":"Raymarching experiment 0","username":"Ciubix8513","description":"Just trying out raymarching while following this great tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int maxSteps = 100;\nconst float minDist = 0.0;\nconst float maxDist = 100.0;\nconst float E = 0.0001;\n\nvec3 rayDir(float FOV, vec2 size,vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(FOV)/2.0);\n    return normalize(vec3(xy,-z));\n}\nmat4 viewMat(vec3 eye,vec3 center,vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f,up));\n    vec3 u = cross(s,f);\n    return mat4(vec4(s,0.0),vec4(u,0.0),vec4(-f,0.0),vec4(0.0,0.0,0.0,1.0));\n}\nmat4 rotMat(vec3 r)\n{\n    mat4 roll = mat4(\n    vec4(1,0,0,0),\n    vec4(0,cos(r.x),-sin(r.x),0),\n    vec4(0,sin(r.x),cos(r.x),0),\n    vec4(0,0,0,1));\n    mat4 pitch = mat4(\n    vec4(cos(r.y),0,sin(r.y) ,0),\n    vec4(0,1,0,0),\n    vec4(-sin(r.y),0,cos(r.y),0),\n    vec4(0,0,0,1));\n    mat4 yaw = mat4(\n    vec4(cos(r.z),-sin(r.z),0,0),\n    vec4(sin(r.z),cos(r.z),0,0),\n    vec4(0,0,1,0),\n    vec4(0,0,0,1));   \n    \n    return roll * pitch * yaw;    \n}\n\nfloat Intersect(float a, float b){return max(a,b);}\nfloat Union(float a, float b){return min(a,b);}\nfloat Diff(float a, float b){return max(a,-b);}\n\n\nfloat Sphere(vec3 p,float s){ return length(p) - s;}\nfloat Box(vec3 p, vec3 b, float r)\n{    \n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat Cylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat SceneSDF(vec3 p) //Defining the scene\n{\n    float sphereOffset = 1. + (sin(iTime)) * .5;\n    float SphereR = .2;\n\n    p = (vec4(p,0) * rotMat(vec3(iTime,iTime,iTime))).xyz;//Rotation\n    float b = .65 + sin(iTime) * .4;\n    float r = 2.;\n    float c =Union( Union(Cylinder(p,b,r),\n    Cylinder((vec4(p,0)*rotMat(radians(vec3(90,0,0)))).xyz,b,r)),\n    Cylinder((vec4(p,0)*rotMat(radians(vec3(0,0,90)))).xyz,b,r));\n    float cu =Intersect(Sphere(p,1.2) ,Box(p,vec3(1),0.0) );   \n    \n    float Spheres = Union(Union(Union(Union(Union(\n    Sphere(p - (vec3(0,1,0) * sphereOffset),SphereR),\n    Sphere(p - (vec3(0,-1,0) * sphereOffset),SphereR)),\n    Sphere(p - (vec3(1,0,0) * sphereOffset),SphereR)),\n    Sphere(p - (vec3(-1,0,0) * sphereOffset),SphereR)),\n    Sphere(p - (vec3(0,0,1) * sphereOffset),SphereR)),\n    Sphere(p - (vec3(0,0,-1) * sphereOffset),SphereR));\n    \n    return Union(Diff(cu,c),Spheres);\n}\n\nfloat March(vec3 eye, vec3 dir,float minDist, float maxDist)\n{\n    float depth = minDist;\n    for(int i = 0; i < maxSteps;i++)\n    {\n       float dst = SceneSDF(eye + depth *dir);\n       if(dst < E)return depth;\n       depth+= dst;\n       if(depth >= maxDist)return maxDist;\n    }\n    return maxDist;\n}\n\nvec3 estNorm(vec3 p)\n{   \n    return normalize(vec3(\n    SceneSDF(vec3(p.x + E,p.y,p.z)) - SceneSDF(vec3(p.x - E,p.y,p.z)),\n    SceneSDF(vec3(p.x ,p.y + E,p.z)) - SceneSDF(vec3(p.x ,p.y- E,p.z)),\n    SceneSDF(vec3(p.x ,p.y,p.z+E)) - SceneSDF(vec3(p.x,p.y,p.z - E))\n    ));\n}\n\n//Blinn - Phong lighting\nvec4 Light(vec3 eye, vec3 point, vec3 light)\n{\n    vec3 n = estNorm(point);\n    vec3 LightDifuse = vec3(1);\n    vec3 LightSpec = vec3(.5);\n    \n     float DifuseCnst = .5;\n    float SpecCnst = 1.0;\n    float Shininess = 15.0;\n    \n    vec3 lightDir = normalize(light - point);\n    \n    //vec3 lightRefl = normalize(reflect(-lightDir,n));    \n    float lightDot = dot(lightDir,n);\n    vec3 H = normalize( lightDir + normalize(eye - point)); \n    float ReflViewDot = dot(H,n) ;  //dot( lightRefl, normalize(eye - point));//\n    \n    vec3 Difuse = vec3(0);        \n    if(lightDot > 0.0)\n \n    Difuse = DifuseCnst * lightDot * LightDifuse;\n    \n    vec3 Spec = vec3(0);    \n    \n    if(ReflViewDot > 0.0)   \n    Spec = SpecCnst *pow(ReflViewDot,Shininess) * LightSpec;   \n    \n    return vec4(Difuse + Spec,0);\n    \n}\n\nvec4 Lighting(vec3 eye,vec3 point, vec4 baseColor)\n{\n    float ambient = 0.2;\n    float ambientInt = 1.0;      \n    return (baseColor * ambient * ambientInt) + \n    Light(eye,point,vec3(4.0*sin(iTime),2.0,4.0 * cos(iTime)))+\n    Light(eye,point,vec3(2.0 * sin(0.37 * iTime),2.0 * cos(0.37 * iTime),2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eyeDir = rayDir(45.0,iResolution.xy,fragCoord);\n    vec3 eye = vec3(5,8,7); \n    vec3 dir = (viewMat(eye,vec3(0),vec3(0,1,0)) * vec4(eyeDir,0)).xyz;\n    float  dst = March(eye,dir,minDist,maxDist);\n    if(dst > maxDist - E){fragColor = vec4(0); return;}       \n    \n    fragColor = Lighting(eye, eye+dir*dst,vec4(1));\n}","name":"Image","description":"","type":"image"}]}