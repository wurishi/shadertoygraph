{"ver":"0.1","info":{"id":"mltyW4","date":"1699655723","viewed":23,"name":"finale m1 tp image","username":"Serine","description":"shading","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Cylinder {\n    vec3 a;  // One end point of the cylinder\n    vec3 b;  // Opposite end point of the cylinder\n    float r;  // Radius of the cylinder\n    int i;    // Texture Id (or any other identifier you might need)\n};\n\nstruct Ellipsoid {\n    vec3 center;     // Center point\n    vec3 radii;      // Radii for the three axes\n    mat3 rotation;   // Rotation matrix for orientation\n    int i;           // Texture Id or other identifier\n};\n\nstruct Capsule{\n    vec3 a; // Start point\n    vec3 b; // End point\n    float r; // Radius\n    int i; // Texture Id\n};\n\nstruct Box {\n    vec3 min; // Point minimal\n    vec3 max; // Point maximal\n    int i;    // Texture Id\n};\n\nstruct Light {\n    vec3 position;  // Light position\n    vec3 color;     // Light color\n    float intensity; // Light intensity\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material {\n    vec3 d; // Diffuse\n    vec3 s; // Specular\n    float shininess; // Shininess coefficient for specular highlight\n};\n\n// reflection direction\nvec3 reflectDir(vec3 I, vec3 N) {\n    return I - 2.0 * dot(N, I) * N;\n}\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(cos((p-.5*w)*.5)-.2)-abs(cos((p+.5*w)*.5)-.2))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\n\nMaterial Texture2(vec3 p, int i) {\n    if (i > 0) {\n        float r=sqrt(p.x*p.x+p.y*p.y);\n        float colorValue = 1.5 + 0.5 * cos (13.1415927 * r ) ;//cos(distance * 15.0) * 0.3 + 1.5+0.3; // Sine wave for smooth color transition\n        return Material(vec3(0.3*colorValue, 2.0 - 1.2*colorValue, 1.0),vec3(1.0), 32.0);\n    } else if (i == 0) {\n        float f = Checkers(.5 * p.xy);\n        vec3 col = vec3(.2, .5, .7) + f * vec3(0.4);\n        return Material(col, vec3(0.0), 1.0); // No specular highlight\n    }\n    return Material(vec3(0), vec3(0.0), 1.0);\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectBox(Ray ray, Box box, out Hit x)\n{\n    float tmin_x = (box.min.x - ray.o.x) / ray.d.x;\n    float tmax_x = (box.max.x - ray.o.x) / ray.d.x;\n    float tmin_y = (box.min.y - ray.o.y) / ray.d.y;\n    float tmax_y = (box.max.y - ray.o.y) / ray.d.y;\n    float tmin_z = (box.min.z - ray.o.z) / ray.d.z;\n    float tmax_z = (box.max.z - ray.o.z) / ray.d.z;\n\n    float tmin = max(max(min(tmin_x, tmax_x), min(tmin_y, tmax_y)), min(tmin_z, tmax_z));\n    float tmax = min(min(max(tmin_x, tmax_x), max(tmin_y, tmax_y)), max(tmin_z, tmax_z));\n\n    if (tmin <= tmax && tmax > 0.0)\n    {\n        vec3 p = Point(ray, tmin);\n\n        vec3 normal = vec3(0);\n\n        if (abs(p.x - box.min.x) < 0.001) normal = vec3(-1, 0, 0);\n        else if (abs(p.x - box.max.x) < 0.001) normal = vec3(1, 0, 0);\n        else if (abs(p.y - box.min.y) < 0.001) normal = vec3(0, -1, 0);\n        else if (abs(p.y - box.max.y) < 0.001) normal = vec3(0, 1, 0);\n        else if (abs(p.z - box.min.z) < 0.001) normal = vec3(0, 0, -1);\n        else if (abs(p.z - box.max.z) < 0.001) normal = vec3(0, 0, 1);\n\n        x = Hit(tmin, normal, box.i);\n        return true;\n    }\n\n    return false;\n}\n\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x)\n{\n    vec3 A = cyl.a;\n    vec3 B = cyl.b;\n    float r = cyl.r;\n    int textureId = cyl.i;\n\n    vec3 AB = B - A;\n    vec3 AO = ray.o - A;\n    vec3 D = normalize(AB);\n\n    float a = dot(ray.d - dot(ray.d, D) * D, ray.d - dot(ray.d, D) * D);\n    float b = 2.0 * dot(ray.d - dot(ray.d, D) * D, AO - dot(AO, D) * D);\n    float c = dot(AO - dot(AO, D) * D, AO - dot(AO, D) * D) - r * r;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    x = Hit(1e6, vec3(0), -1); \n    bool hasIntersection = false;\n\n    if (discriminant >= 0.0)\n    {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        vec3 p1 = Point(ray, t1);\n        vec3 p2 = Point(ray, t2);\n\n        float h1 = dot(p1 - A, D);\n        float h2 = dot(p2 - A, D);\n\n        if (t1 >= 0.0 && h1 >= 0.0 && h1 <= length(AB) && t1 < x.t)\n        {\n            vec3 normal = normalize((p1 - A) - dot(p1 - A, D) * D);\n            x = Hit(t1, normal, textureId);\n            hasIntersection = true;\n        }\n\n        if (t2 >= 0.0 && h2 >= 0.0 && h2 <= length(AB) && t2 < x.t)\n        {\n            vec3 normal = normalize((p2 - A) - dot(p2 - A, D) * D);\n            x = Hit(t2, normal, textureId);\n            hasIntersection = true;\n        }\n    }\n\n    vec3 normalTop = normalize(cyl.b - cyl.a);\n    vec3 normalBottom = -normalTop;\n\n    float tBottom = dot(cyl.a - ray.o, normalBottom) / dot(ray.d, normalBottom);\n    vec3 pointBottom = ray.o + tBottom * ray.d;\n    if (tBottom > 0.0 && length(pointBottom - cyl.a) <= cyl.r && tBottom < x.t)\n    {\n        x = Hit(tBottom, normalBottom, cyl.i);\n        hasIntersection = true;\n    }\n\n    float tTop = dot(cyl.b - ray.o, normalTop) / dot(ray.d, normalTop);\n    vec3 pointTop = ray.o + tTop * ray.d;\n    if (tTop > 0.0 && length(pointTop - cyl.b) <= cyl.r && tTop < x.t)\n    {\n        x = Hit(tTop, normalTop, cyl.i);\n        hasIntersection = true;\n    }\n\n    return hasIntersection;\n}\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x)\n{\n    vec3 localO = ellipsoid.rotation * (ray.o - ellipsoid.center);\n    vec3 localD = ellipsoid.rotation * ray.d;\n\n    localO /= ellipsoid.radii;\n    localD /= ellipsoid.radii;\n\n    float a = dot(localD, localD);\n    float b = 2.0 * dot(localO, localD);\n    float c = dot(localO, localO) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0)\n        return false;\n\n    float sqrtDiscriminant = sqrt(discriminant);\n    float t1 = (-b - sqrtDiscriminant) / (2.0 * a);\n    float t2 = (-b + sqrtDiscriminant) / (2.0 * a);\n\n    if (t1 > t2) \n    {\n        float temp = t1;\n        t1 = t2;\n        t2 = temp;\n    }\n\n    vec3 p1 = Point(ray, t1);\n    vec3 normal1 = normalize(transpose(ellipsoid.rotation) * (2.0 * (p1 - ellipsoid.center) / (ellipsoid.radii * ellipsoid.radii)));\n\n    if (t1 > 0.0 && t1 < x.t)\n    {\n        x = Hit(t1, normal1, ellipsoid.i);\n        return true;\n    }\n\n    vec3 p2 = Point(ray, t2);\n    vec3 normal2 = normalize(transpose(ellipsoid.rotation) * (2.0 * (p2 - ellipsoid.center) / (ellipsoid.radii * ellipsoid.radii)));\n\n    if (t2 > 0.0 && t2 < x.t)\n    {\n        x = Hit(t2, normal2, ellipsoid.i);\n        return true;\n    }\n\n    return false;\n}\n\nmat3 rotationMatrix(vec3 angles) {\n    float c1 = cos(angles.x);\n    float s1 = sin(angles.x);\n    float c2 = cos(angles.y);\n    float s2 = sin(angles.y);\n    float c3 = cos(angles.z);\n    float s3 = sin(angles.z);\n    \n    mat3 rx = mat3(\n        1, 0, 0,\n        0, c1, -s1,\n        0, s1, c1\n    );\n    \n    mat3 ry = mat3(\n        c2, 0, s2,\n        0, 1, 0,\n        -s2, 0, c2\n    );\n    \n    mat3 rz = mat3(\n        c3, -s3, 0,\n        s3, c3, 0,\n        0, 0, 1\n    );\n    \n    return rz * ry * rx;\n}\n\nbool IntersectHemisphere(Ray ray, vec3 center, vec3 axis, float r, out Hit x) {\n    vec3 oc = ray.o - center;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - r * r;\n    float h = b * b - c;\n    if (h > 0.0) {\n        h = sqrt(h);\n        float t = -b - h;\n        if (t < 0.0) t = -b + h;\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            vec3 n = normalize(p - center);\n            if (dot(n, axis) > 0.0) {\n                x = Hit(t, n, 5);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x) {\n    vec3 p = ray.o - cap.a;\n    vec3 ba = cap.b - cap.a;\n    float baba = dot(ba, ba);\n    float bap = dot(ba, p);\n    float papa = dot(p, p);\n    \n    float a = baba - dot(ba, ray.d) * dot(ba, ray.d);\n    float b = baba * dot(p, ray.d) - bap * dot(ba, ray.d);\n    float c = baba * papa - bap * bap - (cap.r * cap.r * baba);\n    \n    float h = b * b - a * c;\n    if (h >= 0.0) {\n        float t = (-b - sqrt(h)) / a;\n        float y = bap + t * dot(ba, ray.d);\n        if (y > 0.0 && y < baba && t > 0.0) {\n            vec3 hitPoint = Point(ray, t);\n            vec3 normal = normalize(hitPoint - (cap.a + ba * (y / baba)));\n            x = Hit(t, normal, cap.i);\n            return true;\n        }\n    }\n\n    Hit h1, h2;\n    vec3 axis = normalize(ba);\n    bool hitHemisphere1 = IntersectHemisphere(ray, cap.a, -axis, cap.r, h1);\n    bool hitHemisphere2 = IntersectHemisphere(ray, cap.b, axis, cap.r, h2);\n    bool hitCylinder = false;\n    \n    x.t = 1e6;\n    \n    if (hitHemisphere1 && h1.t < x.t) {\n        x = h1;\n        hitCylinder = true;\n    }\n    \n    if (hitHemisphere2 && h2.t < x.t) {\n        x = h2;\n        hitCylinder = true;\n    }\n\n    return hitCylinder;\n}\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph2=Sphere(vec3(0.,7.,10.),3.,1);\n    const Sphere sph1=Sphere(vec3(5.,13.,6.),2.,6);\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);    \n    const Cylinder cylinder = Cylinder(vec3(-1.,1.,3.),vec3(0.,3.,5.), 1.5, 4);\n//    const Box box = Box(vec3(-2., 16.0, 3.0), vec3(1.0, 12.0, 7.0), 3);\n    const Box box = Box(vec3(-4., 15.0, 3.0), vec3(-1.0, 11.0, 7.0), 1);\n//Ellipsoid ellipsoid = Ellipsoid(vec3(2.0, -3.0, 5.0), vec3(-2.0, -2.0, 3.),\n    Ellipsoid ellipsoid = Ellipsoid(vec3(6.0, 4.5, 4.0), vec3(2.0, 2.0, 4.),\n    rotationMatrix(vec3(1.0, radians(20.0), 0.0)), 4);    \n    const Capsule cap = Capsule(vec3(-5., 6., 2.), vec3(-7., 8., 7.), 1., 5);\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n    if(IntersectBox(ray, box, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectCylinder(ray, cylinder, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if(IntersectEllipsoid(ray, ellipsoid, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectCapsule(ray, cap, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n   if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.9, .9, .95), vec3(.8, .85, .9), rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n\nvec3 Color2(Material m, vec3 p, vec3 n, vec3 viewDir, Light lights[3], int numLights) {\n    vec3 color = vec3(.2, .2, .2); // Start with ambient term\n\n    for (int i = 0; i < numLights; ++i) {\n        vec3 lightDir = normalize(lights[i].position - p);\n        vec3 reflectDir = reflect(-lightDir, n);\n        \n        // Shadow check\n        Ray shadowRay = Ray(p + n * 0.001, lightDir);\n        Hit shadowHit;\n        if (!Intersect(shadowRay, shadowHit) || shadowHit.t > length(lights[i].position - p)) {\n            float diff = clamp(dot(n, lightDir), 0., 1.);\n            float spec = pow(max(dot(viewDir, reflectDir), 0.0), m.shininess);\n\n            color += m.d * diff * lights[i].color * lights[i].intensity; // Diffuse term\n            color += m.s * spec * lights[i].color * lights[i].intensity; // Specular term\n        }\n    }\n    return color;\n}\n\n\nvec3 Shade2(Ray ray) {\n    const int maxReflections = 3; // Maximum number of reflections\n    \n    vec3 color = vec3(0); // Initialize color\n    const int numLights = 3;\n    Light lights[numLights];\n    lights[0] = Light(vec3(2, 5, 20), vec3(1), 1.);\n    lights[1] = Light(vec3(-5, -3, 10), vec3(0.3, 0.8, 0.8), 0.7);\n    lights[2] = Light(vec3(-2, -3, 10), vec3(1), 0.5);\n    \n    for (int i = 0; i <= maxReflections; ++i) {\n        lights[i].position.xz += vec2(sin(iTime), cos(iTime))*2.;\n\n        Hit x;\n        bool idx = Intersect(ray, x);\n\n        if (idx) {\n            vec3 p = Point(ray, x.t);\n            Material mat = Texture2(p, x.i);\n            //return Color(mat,x.n);\n\n            vec3 viewDir = normalize(-ray.d); \n            \n            if (x.i == 1 && i < maxReflections) { \n                vec3 reflectedRayDir = reflect(ray.d, x.n);\n               ray = Ray(p + reflectedRayDir * 0.001, reflectedRayDir);\n                color = mat.d; \n            } else {\n                color = Color2(mat, p, x.n, viewDir,lights,numLights);\n                break; \n           }\n        } else {\n            color = Background(ray.d);\n            break; // No intersection, break out of the loop\n        }\n    }\n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=2.+40.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,1.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade2(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}