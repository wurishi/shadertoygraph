{"ver":"0.1","info":{"id":"wsB3DR","date":"1548582723","viewed":157,"name":"emit fractal","username":"ukeyshima","description":"emit fractal","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n\nconst vec3 cPos = vec3(0.0, 0.0, -2.0);\nconst vec3 cDir = vec3(0.0, 0.0, 1.0);\nconst vec3 cUp = vec3(0.0, 1.0, 0.0);\nconst float depth = 1.0;\nconst vec3 lPos = vec3(10.0, 10.0, -10.0);\n\nvec3 rotate(vec3 p, float angle, vec3 axis) {\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m =\n      mat3(a.x * a.x * r + c, a.y * a.x * r + a.z * s, a.z * a.x * r - a.y * s,\n           a.x * a.y * r - a.z * s, a.y * a.y * r + c, a.z * a.y * r + a.x * s,\n           a.x * a.z * r + a.y * s, a.y * a.z * r - a.x * s, a.z * a.z * r + c);\n  return m * p;\n}\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nfloat fractal(vec3 p) {\n  float result = 100.0;\n  for (float i = 0.0; i < 10.0; i++) {\n    p = rotate(p, iTime, vec3(0.2, 0.3, 0.5));\n    result = min(result, sphere(p, exp(-i / 1.2)));\n    result =\n        max(result, -sphere(p, exp(-i / 1.2 * abs(1.5 * sin(iTime / 2.0)))));\n    p = abs(p) - exp(-i / 1.2) / 2.0;\n  }\n  return result;\n}\n\nfloat distFunc(vec3 p) { return fractal(p); }\n\nvec3 getNormal(vec3 p) {\n  float d = 0.001;\n  return normalize(\n      vec3(distFunc(p + vec3(d, 0.0, 0.0)) - distFunc(p + vec3(-d, 0.0, 0.0)),\n           distFunc(p + vec3(0.0, d, 0.0)) - distFunc(p + vec3(0.0, -d, 0.0)),\n           distFunc(p + vec3(0.0, 0.0, d)) - distFunc(p + vec3(0.0, 0.0, -d))));\n}\n\nvec3 rayMarching(vec3 color, vec2 p) {\n  vec3 cSide = cross(cDir, cUp);\n  vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * depth);\n  vec3 rPos = cPos;\n  float rLen = 0.0;\n  for (float i = 0.0; i < 22.0; i++) {\n    float distance = distFunc(rPos);\n    color = clamp(vec3(0.8, 0.2, 0.6) / distance, 0.0, 1.0);\n    if (distance < 0.01) {\n      vec3 normal = getNormal(rPos);\n      float diffuse = clamp(dot(normal, -lPos), 0.0, 1.0) + 0.03;\n      color = (color / diffuse / 50.0);\n      break;\n    }\n    rLen += distance;\n    rPos = cPos + rLen * ray;\n  }\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p =\n      (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color = rayMarching(vec3(0.0), p);\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}