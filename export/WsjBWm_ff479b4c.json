{"ver":"0.1","info":{"id":"WsjBWm","date":"1590365385","viewed":449,"name":"Jelly Bean manufacture","username":"dpiponi","description":"Attempt to recreate a RenderMan example I wrote many years ago. The original used a photon mapping pass to simulate subsurface scattering but I found a hack.\n\nStill buggy. Work in progress.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["confectionery"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float theTime = 0.0;\n\nmat4 translate(vec3 p) {\n    return mat4(1.0,  0.0,  0.0,  -p.x,\n              0.0,  1.0,  0.0,  -p.y,\n              0.0,  0.0,  1.0,  -p.z,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 scale(vec3 s) {\n    return mat4(s.x,  0.0,  0.0,  0.0,\n              0.0,  s.y,  0.0,  0.0,\n              0.0,  0.0,  s.z,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  -s,  0.0,  0.0,\n              s,  c,  0.0,  0.0,\n              0.0,  0.0,  1.0,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  0.0, s,  0.0,\n              0.0,  1.0, 0.0, 0.0,\n              -s,  0.0, c,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,  0.0, \n                0.0, s,  c,  0.0,\n                0.0,  0.0,  0.0,  1.0);\n}\n\nvec2 xy;\n\n// From https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h *(1.0 - h);\n}\n\nfloat softmin(float x, float y) {\n    return smin(x, y, 0.55);\n}\n\nfloat hash(ivec3 xyz0) {\n    return -0.5 + fract(dot(vec3(1132.312, -19.121311, -12.2312), vec3(xyz0)));\n}\n\n// Thanks iq!\nvec3 center(ivec3 i)\n{\n    float ph = hash(i);\n    return vec3(i) + 0.5*cos( 0.5*theTime + ph*3.14159 + vec3(0,7,4) );\n}\n\n// From https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 colour(ivec3 i) {\n    float cx = 0.5 + hash(i.zxy);\n    float cy = 1.8;\n    float cz = 0.5 + 0.5 * hash(i + ivec3(12, 111, -3));\n\treturn hsv2rgb(vec3(cx, cy, cz));\n}\n\nfloat cube(vec3 x, float top) {\n    float s = 3.0;\n    return max(x.x - s,\n               max(-s - x.x,\n                   max(x.y - top,\n                       max(-s - x.y,\n                           max(x.z - s, -s - x.z)))));\n}\n\n\n// This is the function we're marching into.\nvec4 f(vec3 x) {\n    \n    float a = cube(x, 2.*cos(0.2 * theTime));\n    ivec3 b = ivec3(floor(x + 0.5));\n   \n    float dist;\n    float weight = 35.0;\n    vec3 col = weight * vec3(0.95, 0.85, 0.8);\n\n\n    // Main cause of GPU time.\n    for (int ix = -2; ix <= 2; ++ix) {\n        for (int iy = -2; iy <= 2; ++iy) {\n            for (int iz = -2; iz <= 2; ++iz) {\n                ivec3 ii = b + ivec3(ix, iy, iz); \n\n                // Hole in middle saves some render time.\n                if (ii.x > -2 && ii.x < 2 && ii.y > -2 &&\n                    ii.y < 2 && ii.z > -2 && ii.z < 2) continue;\n                if (ii.x < -2) continue;\n                if (ii.x > 2) continue;\n                if (ii.y < -2) continue;\n                if (ii.y > 2) continue;\n                if (ii.z < -2) continue;\n                if (ii.z > 2) continue;\n                \n                // Note: maybe cache computed centres?\n                vec3 c = center(ii);\n                vec3 cc = colour(ii);\n\n                float s = length(x - c) - 0.5;\n                \n                dist = max(0.0001, s + 0.4);\n                float w = 1. / (dist * dist * dist * dist);\n                col += w * cc;\n                weight += w;\n                a = softmin(a, s);\n            }\n        }\n    }\n\n    return vec4(col / weight, a);\n}\n\n\n\n// Doesn't compute colour.\nfloat fastf(vec3 x) {\n    return f(x).a;\n}\n\nfloat eps = 0.0001;\n//float lambda = 2.0;\n\nfloat lighting(vec3 x, vec3 n, vec3 d, vec3 l) {\n    // Crudely measures curvature.\n    float t = min(1., exp(1.5 * fastf(x + 0.25 * d)));\n    \n    // Sort of transports light under surface.\n    t += min(1., exp(1.5 * fastf(x - 0.15 * l)));\n    \n    return t;\n}\n\nmat4 view() {\n    return rotateY(0.25 * theTime) * rotateX(0.);\n}\n\n\nfloat phong(vec3 n, vec3 light, vec3 d) {\n    vec3 r = reflect(light, n);\n    float e = dot(r, -d);\n    return e > 0. ? pow(e, 16.0) : 0.;\n}\n\nvec3 march(vec3 p, vec3 d) {\n    float c;\n    c = fastf(p);\n    if (c < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    vec3 col;\n    vec3 bestcol;\n    float bestc = 100.0;\n    // Other cause of GPU time.\n    for (int i = 0; i < 50; ++i) {\n        float step = max(0.005, c);\n        p = p + step * d;\n        vec4 result = f(p);\n        c = result.a;\n        col = result.xyz;\n        if (c < bestc) {\n            bestc = c;\n            bestcol = col;\n        }\n        if (c < 0.01) break;\n    }\n    if (c < 0.01) {\n        // Arrived!\n\n        // Gradient of sdf\n        float ex, ey, ez;\n        ex = fastf(p + vec3(eps, 0.0, 0.0));\n        ey = fastf(p + vec3(0.0, eps, 0.0));\n        ez = fastf(p + vec3(0.0, 0.0, eps));\n        vec3 n = vec3(ex - c, ey - c, ez - c) / eps;\n        n = normalize(n);\n\n        mat4 m = view();\n        vec3 light = normalize((vec4(1.0, 1.0, -1.0, 1.0) * m).xyz);\n        float l = 0.0;\n        l += 0.5 * (0.1 + 0.65 * max(dot(n, light)/sqrt(3.0), 0.0));\n        l += 1.0 * (0.4 * (phong(n, -light, d)));\n        l += 1.2 * (0.5 * lighting(p, n, d, light));\n\n        return vec3(l) * col;\n    }\n    if (c < 0.5) {\n        // Gross hack to fill holes due to grazing rays.\n        // Probably a better way.\n    \treturn 1.5 * bestcol;\n    } else {\n        return vec3(0.1, 0.1, 0.1);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    theTime = iTime;\n    \n    vec2 uv = fragCoord.xy-0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n    xy = iMouse.xy/iResolution.xy;\n\n    vec3 p = vec3(0.0, 2.0, -8.0);\n    // Initial ray direction\n    vec3 d = normalize(vec3(0.5*uv, 1.0));\n    d = (rotateX(-0.25) * vec4(d, 1.0)).xyz;\n    mat4 m = view();\n    p = (vec4(p, 1.0)*m).xyz;\n    d = (vec4(d, 1.0)*m).xyz;\n    d = normalize(d);\n    vec3 color = march(p, d);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}