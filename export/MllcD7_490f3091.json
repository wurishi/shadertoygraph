{"ver":"0.1","info":{"id":"MllcD7","date":"1505159168","viewed":628,"name":"Voxel Space Skipping Example","username":"fizzer","description":".","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Set this to nonzero to enable SDF-based space skipping.\n#define SKIP_SPACE 1\n\n// In this example:\n//   288 SDF samples when space skipping is enabled.\n//  1600 SDF samples when space skipping is disabled.\n\n// Signed distance field.\nfloat dist(vec3 p)\n{\n    // Just a field of repeating spheres.\n    p=mod(p,40.)-20.;\n    return length(p)-10.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n    vec2 t=uv-.5;\n    t.x*=iResolution.x/iResolution.y;\n\n    vec2 p=t.xy;\n\n    // Set up primary ray.\n    vec3 ro=vec3(0,30,-iTime*4.);\n    vec3 rd=normalize(vec3(p,-1.4));\n\n    vec3 co=ro;\n    vec3 ord=rd;\n\n    vec3 n;\n\n#if SKIP_SPACE\n    for(int j=0;j<4;++j)\n#endif\n    {\n        vec3 oro=ro;\n\n#if SKIP_SPACE\n\t\t// Use signed distance field raymarching to skip space quickly.\n        float t=0.;\n        for(int i=0;i<40;++i)\n        {\n            ro=oro+rd*t;\n            float d=dist(ro);\n            if(d<-3.)\n            {\n                break;\n            }\n            t+=d;\n        }\n#endif\n\n        // Prepare for uniform grid traversal.\n        oro=ro;\n        vec3 c=floor(ro);\n        vec3 ts=(c+max(vec3(0.),sign(rd))-ro)/rd;\n\n        // Perform uniform grid traversal.\n#if SKIP_SPACE\n        for(int i=0;i<32;++i)\n#else\n        // Use (many) more iterations to reach the same distances as would be reached with space skipping.\n        for(int i=0;i<1600;++i)\n#endif\n        {\n            // n holds 1.0 in the axis for which ts's component in that axis is\n            // the smallest, and 0.0 elsewhere. This indicates the axis plane with the closest intersection.\n            n=step(ts,ts.yzx)*step(ts,ts.zxy);\n            c+=sign(rd)*n;\n            float d=dist(c);\n            if(d<-1.7)\n            {\n\t\t        // Advance the ray march position to the next grid cell.\n                ro=oro+rd*min(ts.x,min(ts.y,ts.z));\n                break;\n            }\n            // Increment the axis plane inersections.\n            vec3 dd=sign(rd)/rd*n;\n            ts+=dd;\n        }\n        // Advance the ray march position to the next grid cell.\n        ro=oro+rd*min(ts.x,min(ts.y,ts.z));\n    }\n\n\n    // Checkerboard texture.\n    ro+=1e-3;\n    float tex=.8+.2*step(.5,fract(ro.x+.5*step(.5,fract(ro.y+.5*step(.5,fract(ro.z))))));\n\n    // Basic lighting.\n    vec3 ld=normalize(vec3(3,4,1));\n    fragColor.rgb=tex*vec3(.5+.5*dot(n*-sign(rd),ld));\n\n    // Distance fading.\n    float fogstrength=.001;\n    float fogamount=exp(-distance(ro,co)*fogstrength);\n    fragColor.rgb=mix(vec3(0),fragColor.rgb,fogamount);\n    \n    // Gamma.\n    fragColor.rgb=sqrt(fragColor.rgb);\n}\n\n","name":"Image","description":"","type":"image"}]}