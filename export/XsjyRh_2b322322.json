{"ver":"0.1","info":{"id":"XsjyRh","date":"1497573685","viewed":161,"name":"Raytraced Cubemap Lighting","username":"rodolphito","description":"Raytrace a sphere and accumulate diffuse, gloss, and normals in separate buffers. Let it run for ~4 seconds.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["lighting","cubemap","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//This code is mine if u take it i kill u\n//Rodol Phito's Don't Copy My Code License\n//jk you can use just give credit\n\n#define FRAME_OFFSET 60\n#define PI 3.1415926535897\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nvec3 decode(vec2 n)\n{\n    float z=.5-dot(n,n);\n    return vec3(n*sqrt(z+.5),z)*2.;\n}\n\nvec2 encode(vec3 n)\n{\n    return n.xy/sqrt(n.z*2.0+2.0);\n}\n\nvec3 r(vec3 v, vec2 r)\n{\n\tvec4 t = sin(vec4(r, r + 1.5707963268));\n    vec4 g = vec4(v, dot(v.yz, t.yw));\n    return vec3(g.x * t.z - g.w * t.x,\n                g.y * t.w - g.z * t.y,\n                g.x * t.x + g.w * t.z);\n}\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 gaussianhash31(float p)\n{\n    return 0.23*sqrt(-log(hash31(p)+vec3(0.00001)))*cos(2.0*3.141592*hash31(p + 4.243));\n}\n\nvec2 rand2dunit(float p)\n{\n  float a = hash11(p);\n  return sin(vec2(a + 0.25, a) * 2.0 * PI);\n}\n\nvec3 rand3dunit(float p)\n{\n  vec3 r = hash21(p).xxy*2.0+vec3(0.5,0.0,-1.0);\n  r.xy = sin(r.xy*PI)*sqrt(1.0-r.z*r.z);\n  return r;\n}\n\nvec3 linear(vec3 col)\n{\n\treturn pow(col, vec3(2.2));\n}\nvec3 gamma(vec3 col)\n{\n\treturn pow(col, vec3(0.4545));\n}\n\nvec2 getuv(vec2 i)\n{\n    vec2 size = iResolution.xy * 0.5;\n    return (i - size.xy) / size.yy;\n}\n\nvec2 geti(vec2 uv)\n{\n    vec2 size = iResolution.xy * 0.5;\n    return uv * size.yy + size.xy;\n}\n\nvec2 getTexcoord(vec3 normal)\n{\n   \treturn encode(normal) * 0.5 + 0.5;\n}\n\nvec3 sampleHDR(sampler2D t, vec3 n)\n{\n    vec4 s = texture(t, getTexcoord(n));\n    return s.rgb / s.a;\n}\n\nfloat schlickFresnel(float f)\n{\n    float fresnel = min(1.0,1.0+f);\n    return pow(fresnel, 5.0);\n}\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    //o = texture(iChannel0, i/iResolution.xy);\n    //o.rgb = gamma(o.rgb / o.a);\n    //return;\n    \n    vec2 diruv = getuv(i);\n    float dist = 4.0;\n    vec3 ro = vec3(0.0,0.0,dist);\n    vec3 rd = normalize(vec3(diruv, -2.0));\n    vec2 rot = -iMouse.xy * 0.01 + vec2(iTime * 0.3, 0.0);\n    \n\tfloat b = dot(ro,rd);\n    rd = r(rd,rot);\n    ro = r(ro,rot);\n\tfloat h = b*b-dist*dist+1.0;\n    o = texture(iChannel2, rd);\n\tif(h>0.0)\n    {\n\t\tfloat t = -b-sqrt(h);\n        vec3 normal = ro + rd * t;\n        normal = normalize(sampleHDR(iChannel3, normal) + normal * 0.1);\n        vec3 tangent = cross(normal, vec3(0.0,1.0,0.0));\n        vec3 bitangent = cross(tangent, normal);\n        \n        vec3 refldir = reflect(rd, normal);\n        \n        vec3 diffuse = sampleHDR(iChannel0, normal);\n        vec3 specular = sampleHDR(iChannel1, refldir);\n        float fresnel = schlickFresnel(dot(rd,normal));\n        \n        vec3 specularcolor = vec3(0.95, 0.64, 0.54);\n        vec3 diffusecolor = specularcolor * .1;\n        vec3 diffuseterm = diffuse * diffusecolor * (1.0 - fresnel);\n        vec3 specularterm = specular * mix(specularcolor, vec3(1.0), fresnel);\n        //specularterm = vec3(0.0);\n        //diffuseterm = vec3(0.0);\n        vec3 color = specularterm * 1.4 + diffuseterm;\n        //color = tangent*0.5+0.5;\n        o = mix(vec4(gamma(color), 1.0), o, smoothstep(10.0/iResolution.y,0.0,h));\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FRAME_OFFSET 60\n#define PI 3.1415926535897\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nvec3 decode(vec2 n)\n{\n    float z=0.5-dot(n,n);\n    return vec3(n*sqrt(z+0.5),z)*2.0;\n}\nvec2 encode(vec3 n)\n{\n    return n.xy/sqrt(n.z*2.0+2.0);\n}\n\nvec3 linear(vec3 col)\n{\n\treturn pow(col, vec3(2.2));\n}\nvec3 gamma(vec3 col)\n{\n\treturn pow(col, vec3(0.4545));\n}\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 gaussianhash31(float p)\n{\n    return 0.23*sqrt(-log(hash31(p)+vec3(0.00001)))*cos(2.0*3.141592*hash31(p + 4.243));\n}\n\nvec2 rand2dunit(float p)\n{\n  float a = hash11(p);\n  return sin(vec2(a + 0.25, a) * 2.0 * PI);\n}\n\nvec3 rand3dunit(float p)\n{\n  vec3 r = hash21(p).xxy*2.0+vec3(0.5,0.0,-1.0);\n  r.xy = sin(r.xy*PI)*sqrt(1.0-r.z*r.z);\n  return r;\n}\n\n\nfloat ndf(float f,float roughness)\n{\n    return f;\n}\nvec4 getsample(vec3 dir, vec3 rand)\n{\n    float roughness = 0.3;\n    float contrib = ndf(max(dot(rand, dir), 0.0), roughness);\n    vec3 col = linear(texture(iChannel0, rand).rgb);\n    return vec4(col, contrib);\n}\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    if (iFrame < FRAME_OFFSET)\n    {\n     \to = vec4(0.0);\n        return;\n    }\n    vec2 uv = i / iResolution.xy;\n    vec3 dir = decode(uv * 2.0 - 1.0);\n    vec3 rand = rand3dunit(iTime * 60.0);\n    vec4 col = getsample(dir, rand);\n    col.rgb *= col.a;\n    vec4 cur = texture(iChannel1, uv);\n    o = cur + col;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define FRAME_OFFSET 60\n#define PI 3.1415926535897\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nvec3 decode(vec2 n)\n{\n    float z=0.5-dot(n,n);\n    return vec3(n*sqrt(z+0.5),z)*2.0;\n}\nvec2 encode(vec3 n)\n{\n    return n.xy/sqrt(n.z*2.0+2.0);\n}\n\nvec3 linear(vec3 col)\n{\n\treturn pow(col, vec3(2.2));\n}\nvec3 gamma(vec3 col)\n{\n\treturn pow(col, vec3(0.4545));\n}\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 gaussianhash31(float p)\n{\n    return 0.23*sqrt(-log(hash31(p)+vec3(0.00001)))*cos(2.0*3.141592*hash31(p + 4.243));\n}\n\nvec2 rand2dunit(float p)\n{\n  float a = hash11(p);\n  return sin(vec2(a + 0.25, a) * 2.0 * PI);\n}\n\nvec3 rand3dunit(float p)\n{\n  vec3 r = hash21(p).xxy*2.0+vec3(0.5,0.0,-1.0);\n  r.xy = sin(r.xy*PI)*sqrt(1.0-r.z*r.z);\n  return r;\n}\n\n\nfloat ndf(float f,float roughness)\n{\n    return pow((3.0-2.0*f)*f*f, 1.0/(roughness*roughness));\n}\nvec4 getsample(vec3 dir, vec3 rand)\n{\n    float roughness = 0.03;\n    float contrib = ndf(max(dot(rand, dir), 0.0), roughness);\n    vec3 col = linear(texture(iChannel0, rand).rgb);\n    return vec4(col, contrib);\n}\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    if (iFrame < FRAME_OFFSET)\n    {\n     \to = vec4(0.0);\n        return;\n    }\n    vec2 uv = i / iResolution.xy;\n    vec3 dir = decode(uv * 2.0 - 1.0);\n    vec3 rand = rand3dunit(iTime * 60.0);\n    vec4 col = getsample(dir, rand);\n    col.rgb *= col.a;\n    vec4 cur = texture(iChannel1, uv);\n    o = cur + col;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define FRAME_OFFSET 60\n#define PI 3.1415926535897\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nvec3 decode(vec2 n)\n{\n    float z=0.5-dot(n,n);\n    return vec3(n*sqrt(z+0.5),z)*2.0;\n}\nvec2 encode(vec3 n)\n{\n    return n.xy/sqrt(n.z*2.0+2.0);\n}\n\nvec3 linear(vec3 col)\n{\n\treturn pow(col, vec3(2.2));\n}\nvec3 gamma(vec3 col)\n{\n\treturn pow(col, vec3(0.4545));\n}\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 gaussianhash31(float p)\n{\n    return 0.23*sqrt(-log(hash31(p)+vec3(0.00001)))*cos(2.0*3.141592*hash31(p + 4.243));\n}\n\nvec2 rand2dunit(float p)\n{\n  float a = hash11(p);\n  return sin(vec2(a + 0.25, a) * 2.0 * PI);\n}\n\nvec3 rand3dunit(float p)\n{\n  vec3 r = hash21(p).xxy*2.0+vec3(0.5,0.0,-1.0);\n  r.xy = sin(r.xy*PI)*sqrt(1.0-r.z*r.z);\n  return r;\n}\n\n\nfloat ndf(float f,float roughness)\n{\n    return pow((3.0-2.0*f)*f*f, 1.0/(roughness*roughness));\n}\nvec4 getsample(vec3 dir, vec3 rand)\n{\n    float roughness = 0.03;\n    float contrib = ndf(max(dot(rand, dir), 0.0), roughness);\n    return vec4(rand, contrib);\n}\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    vec2 uv = i / iResolution.xy;\n    o = texture(iChannel0, uv);\n    if (iFrame < FRAME_OFFSET || iFrame > 350)\n    {\n        return;\n    }\n    vec3 dir = decode(uv * 2.0 - 1.0);\n    vec3 rand = rand3dunit(iTime * 60.0);\n    vec4 col = getsample(dir, rand);\n    col.rgb *= col.a;\n    o += col;\n}","name":"Buf C","description":"","type":"buffer"}]}