{"ver":"0.1","info":{"id":"3ddGWM","date":"1568671836","viewed":454,"name":"[twitch] City Borealis","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CityBorealis_v2","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","reflections","translucency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nAfter the stream, I fixed a major glitch in how I apply alpha, this is the fixed version.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CityBorealis.glsl\nOr the modify version for bonzomatic here: http://lezanu.fr/LiveCode/CityBorealis_v2\n*/\n\nfloat time=0.0;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;  \n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;  \n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;  \n}\n\nvec3 kifs(vec3 p, float t) {\n  \n  p.xz = repeat(p.xz, vec2(28));\n  p.xz = abs(p.xz);\n  \n  vec2 s=vec2(10,7) * 0.6;\n  for(int i=0; i<5; ++i) {\n    p.xz *= rot(t);\n    //p.xz = repeat(p.xz, vec2(28-i*0));\n    p.xz = abs(p.xz) - s;\n    p.y += 0.1*abs(p.z);\n    s*=vec2(0.7,0.5);\n  }\n  \n  return p;\n}\n\nvec3 kifs3d(vec3 p, float t) {\n  \n  p.xz = repeat(p.xz, vec2(17));\n  p = abs(p);\n  \n  vec2 s=vec2(10,7) * 0.4;\n  for(int i=0; i<5; ++i) {\n    p.yz *= rot(t*0.7);\n    p.xz *= rot(t);\n    //p.xz = repeat(p.xz, vec2(28-i*0));\n    p.xz = abs(p.xz) - s;\n    //p.y += 0.1*abs(p.z);\n    s*=vec2(0.7,0.6);\n  }\n  \n  return p;\n}\n\nvec3 tunnel(vec3 p) {\n  \n  vec3 off=vec3(0);\n  \n  off.x += abs(repeat(p.z, 15.0))*0.5;\n  off.x += abs(repeat(p.z, 19.0))*0.6;\n  \n  return off;\n}\n\nbool gold = false;\nfloat goldvalue = 0.0;\nfloat solid(vec3 p) {\n  \n  vec3 pp = p;\n  pp += tunnel(p);\n  float path = abs(pp.x)-1.5;\n    \n  vec3 p2 = kifs(p, 0.5);\n  vec3 p3 = kifs(p+vec3(3,0,0), 1.91);\n  \n  float b1 = box(p2,vec3(1,1.3,0.5));\n  float b2 = box(p3,vec3(0.5,1.3,1));\n  \n  float m1 = max(abs(b1), abs(b2)) - 0.2;\n  \n  float s1 = length(p2+vec3(0,1.4,0))-0.8;\n  float s2 = length(p3+vec3(0,1.7,0))-0.9;\n  float top = max(abs(abs(abs(s1)-0.1)-0.05),abs(s2))-0.02;\n  goldvalue = top;\n  \n  m1 = min(m1,top);\n  \n  m1 = max(m1, -path);\n  \n  float d = m1;\n  \n  \n  d = min(d, -p.y);\n  \n  //d *= 0.7;\n  \n  return d;\n}\n\nfloat rnd(float a) {\n  return fract(sin(a*425.621)*342.512);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)),rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 10.0));\n}\n\nfloat at=0.0;\nfloat at2=0.0;\nfloat at3=0.0;\nfloat ghost(vec3 p) {\n  \n  p.y += 3.0;\n  \n  float off = time * 0.1 - p.z*0.09;\n  \n  vec3 p2 = kifs3d(p-vec3(0,2,3), 0.8 + curve(off, 0.3) + off*0.9);\n  vec3 p3 = kifs3d(p-vec3(6,0,0), 1.2 + curve(off, 0.4) + off* 0.7);\n  \n  float b1 = box(p2,vec3(1));\n  float b2 = box(p3,vec3(0.7));\n  \n  float m1 = max(abs(b1), abs(b2)) - 0.1;\n  \n  //float s1 = length(p2.xz)-0.3;\n  float s1 = box(p2, vec3(0.3,10,0.5));\n  float s2 = box(p3, vec3(10,0.4,0.5));\n  \n  float tt=time*0.3;\n  /*\n  at += 0.1/(0.02+abs(s1+sin(p.x*0.13 + tt)*0.5));\n  at2 += 0.1/(0.02+abs(s2+cos(p.z*0.2 + tt)*0.5));\n  at3 += 0.25/(0.2+abs(m1+sin(p.x*0.59 + tt)*0.4));\n  */\n  at = 0.1/(0.02+abs(s1+sin(p.x*0.13 + tt)*0.5));\n  at2 = 0.1/(0.02+abs(s2+cos(p.z*0.2 + tt)*0.5));\n  at3 = 0.25/(0.2+abs(m1+sin(p.x*0.59 + tt)*0.4));\n  \n  //m1 *= 0.7;\n  \n  return abs(m1);\n  \n}\n\nbool isghost = true;\nfloat map(vec3 p) {\n  \n  float sol = solid(p);\n  \n  float gho = ghost(p);\n    \n  isghost = gho<sol;\n  float d = min(sol, gho);\n  gold = goldvalue<d+0.01;\n  //return gho;\n  \n  //d *= 0.7;\n  \n  return d;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*724.512+uv.yx*568.577),vec2(342.814)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  time = mod(iTime, 200.0);\n\n  vec3 s=vec3(0,-1.0,-3);\n  vec3 t=vec3(0,-1.0 + sin(time*0.2)*0.5,0);\n  \n  float adv = time * 0.9;\n  s.z += adv;\n  t.z += adv;\n  \n  s -= tunnel(s);\n  t -= tunnel(t);\n  //s.xz *= rot(time*0.3);\n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz, vec3(sin(time)*0.1,1,0)));\n  vec3 cy=normalize(cross(cz, cx));\n  \n  vec3 r = normalize(uv.x*cx + uv.y*cy + cz);\n  //vec3 r=normalize(vec3(-uv, 1));\n  \n  vec2 off=vec2(0.01,0);\n  \n  vec3 p=s;\n  float dd=0.0;\n  float maxdist=100.0;\n  vec3 alpha=vec3(1);\n  vec3 emi = vec3(0);\n  float rand=mix(rnd(uv),1.0,0.9);\n  float firsthit = maxdist;\n  vec3 b1 = vec3(0);\n  vec3 b2 = vec3(0);\n  vec3 b3 = vec3(0);\n  // this is done to ensure the loop is not unrolled, so compile time doesnt explode\n  float iterationcount = (100.0+min(time,0.0));\n  for(float i=0.0; i<iterationcount; ++i) {\n    float d=map(p)*rand;\n    if(abs(d)<0.003) {\n      if(!isghost) {\n        bool copygold = gold;\n        \n\t\tvec3 n=normalize(d-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        \n        if(p.y>-0.02) {\n          \n          float d3 = map(p-vec3(0,2,0));\n          //n.xz += sin(d3*vec2(10,0.3) + time*vec2(0.3,0.7)) * 0.3;\n          float fac = 0.02 / max(1.0,abs(d3));\n          n.x += sin(d3*45.0 + time) * 0.5 * fac;\n          n.x += sin(d3*17.0 + time*3.0) * fac;\n          n.z += sin(d3*23.0 + time*0.7) * 0.8 * fac;\n          \n          n = normalize(n);\n        }\n        \n        float fre = pow(1.0-abs(dot(n,r)),1.0);\n        r = reflect(r,n);\n        //break;\n        \n        alpha *= fre;\n\t\t\n        if(copygold) {\n          //emi += vec3(1,0.9,0.5) * alpha*0.0;\n          alpha *= vec3(1,0.9,0.5) * 2.0;\n        }\n        firsthit = min(firsthit, dd);\n      }\n      d = 0.1;\n    }\n    /*if(dd>maxdist) {\n      dd=maxdist;\n      break;\n    }*/\n      \n    b1 += at * alpha;\n    b2 += at2 * alpha;\n    b3 += at3 * alpha;\n      \n    p+=r*d;\n    dd+=d;\n  }\n  firsthit = min(firsthit, dd);\n  \n  vec3 sky = mix(vec3(0.7,0.5,1), vec3(0), pow(abs(r.y),0.4));\n  \n  vec3 col = vec3(0);\n  //col += pow(1.0-float(i)/101.0,6.0);\n  col += b1*0.005*vec3(0.3,0.5,1) * curve(time+12.2, 0.9);\n  col += b2*0.013*vec3(0.4,0.7,0.5) * curve(time, 1.2);\n  col += b3*0.014*vec3(0.8,0.2,0.5) * curve(time+17.4, 1.7);\n  col += emi;\n  float fog = pow(clamp(firsthit*3.0/maxdist,0.0,1.0),1.3);\n  //col *= 1-fog;\n  col += fog * sky *  1.0;\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}