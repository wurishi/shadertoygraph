{"ver":"0.1","info":{"id":"msdXRj","date":"1680146872","viewed":99,"name":"Wet troll","username":"ianertson","description":"Kind of looks like a troll :)\nUse the mouse to look around :)","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","raymarch","sdf","face","human","troll","bust"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ID_GROUND 1\n#define ID_FACE 2\n#define ID_FACE_EYE 3\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\n\n\nfloat faceSDF(in vec3 p, inout int id, inout Object o, in int skip) {\n    float dist = FAR;\n    float r = 0.5;\n    id = ID_FACE;\n    \n    float head = distance(p - vec3(0, r, 0), vec3(-p.x*0.25, 0.0, -p.z*0.2)) - r;\n    head += smoothstep(0.0, 1.5, (-p.z+0.09)*(1.0+abs(p.x)*2.)) *\n            sgt(p.y, 0.09, 1.5) *\n            slt(p.y, 0.22, 1.);\n    \n    float bot = 0.06;\n    float top = 0.5;\n    head += 0.15 * smoothstep(0.0, 0.3, 0.49-p.y) * smoothstep(0.0, 0.25, p.y-0.15) * smoothstep(0.0, 0.25, -p.z);\n\n    head -= smoothstep(bot, top, p.y) * smoothstep(top, bot, p.y) * smoothstep(0.0, 0.5, -p.z) *\n            smoothstep(0.4, 0.0, abs(p.x)) * 0.65;\n    \n    bot -= 0.1;\n    top += 0.35;\n    head += smoothstep(0., 1.0, abs(p.x)) * smoothstep(bot, top, p.y) * smoothstep(top, bot, p.y);\n    head += smoothstep(0.5, 9., dot(p-vec3(0, 1.5, 0), vec3(0, -1, 0)));\n    \n\n    \n    // neck\n    head -= smoothstep(0.0, 1.0, sclamp(-p.y+0.2, 0.0, 1.0, 0.9));\n    \n    head -= 0.15*smoothstep(r+0.05, r+0.12+0.2, (p.y-0.055)+0.01) * smoothstep(r+0.12+0.29, r+0.02, (p.y-0.1)) * \n           smoothstep(0.0, 0.4, -p.z)*smoothstep(0.4, 0.0, abs(p.x));\n    \n    float noseR = 0.033;\n    vec3 noseDir = normalize(vec3(0, -0.9, -0.8));\n    float noseLen = 0.1;\n    vec3 nosePos = vec3(0, r+0.11, -r*0.8);\n    float nose = lineSDF(p - nosePos, vec3(0, 0, 0), noseDir*noseLen, noseR);\n    nose += smoothstep(0.0, 1.0, abs(p.x)+0.02)*smoothstep(0.2, 0.3, p.z+(r+0.2));\n    \n    \n    nose -= smoothstep(0.0, 1.0, dot(p - vec3(0, r+0.11, -r*0.8), noseDir))*sclamp(-p.z, 0.0, 0.4, 0.5);\n    nose += 0.8*smoothstep(1.5, 0.0, dot(p - vec3(0, r+0.11, -r*0.001), -noseDir))*sclamp(p.z+0.37, 0.0, 1., 0.2);\n    float noseHole = cylSDF(vec3(abs(p.x)-0.003, p.y, p.z) - (vec3(0.015, r+0.015, -r*0.998)+(noseDir*noseLen*-0.5)), vec3(0, 0, 0), noseDir*noseLen, 0.016);\n    \n    nose = smax(nose, -noseHole, 0.004);\n    \n    float browLen = 0.16;\n    float browCycle = mod((T+3.39298124)*0.6, 4.0);\n    float browLift = 0.0;\n    browLift = mix(browLift, 1.0, smoothstep(0.0, 0.5, browCycle));\n    browLift = mix(browLift, 0.0, smoothstep(0.5, 3.0, browCycle));\n    browLift = mix(browLift, -0.08, smoothstep(3.0, 3.5, browCycle));\n    browLift = mix(browLift, 0.0, smoothstep(3.4, 4.0, browCycle));\n    browLift *= sclamp(sin(T*0.55), -0.25, 1.0, 0.3);\n    \n    float eyeR = 0.08;\n    float eyeHole = sphereSDF(vec3(abs(p.x), p.y, p.z) - vec3(eyeR*1.69, r+0.12, -r*0.79), eyeR);\n    eyeHole += smoothstep(0.06, 0.2, p.y-(r+0.05))*max(0.0, 1.0-(browLift*0.33));\n    head = smax(head, -eyeHole, 0.04);\n    \n    vec3 eyePos = vec3(eyeR*1.4, r+0.1055-0.01, -r*0.627);\n    float eye = sphereSDF(vec3(abs(p.x), p.y, p.z) - eyePos, eyeR*0.41);\n    \n    \n    // top lid\n    float blink = 0.0;\n    float blinkCycle = mod(T*0.5, 2.0);\n    blink = mix(blink, 1.0, smoothstep(0.0, 0.15, blinkCycle));\n    blink = mix(blink, 0.0, smoothstep(0.14, 0.25, blinkCycle));\n    {\n        float lidLen = 0.1;\n        float lidR = 0.021;\n        lidR += smoothstep(0.0, 0.15, abs(p.y))*0.19*smoothstep(0.4, 0.0, abs(p.z)+0.004);\n        vec3 lidDir = normalize(vec3(1, 0, 0.5));\n        float eyeLid = lineSDF(vec3(abs(p.x), p.y, p.z) - (vec3(eyeR*1.4, r+0.1055+(lidR*0.5)-(mix(0.0, 0.05, blink)), -r*0.61) + vec3(0, 0.015, -0.025)), -lidDir*lidLen*0.5, lidDir*lidLen*0.5, lidR);\n        head = smin(head, eyeLid, 0.02);\n    }\n    \n    // bot lid\n    {\n        float lidLen = 0.1;\n        float lidR = 0.021;\n        vec3 lidDir = normalize(vec3(1, smoothstep(0.0, 0.3, abs(p.x)), 0.5));\n        float eyeLid = lineSDF(vec3(abs(p.x), p.y, p.z) - (vec3(eyeR*1.4, r+0.1055-(lidR*2.9), -r*0.62) + vec3(0, 0.015, -0.025)), -lidDir*lidLen*0.5, lidDir*lidLen*0.5, lidR);\n        head = smin(head, eyeLid, 0.012);\n    }\n    \n    \n    \n    browLift *= srange(abs(p.x)-(browLen/3.), browLen/3.5, browLen*1.2, 0.18);\n    vec3 browDir = vec3(1.0, 0.02, 0.4);\n    browDir = mix(browDir, vec3(0.02, 0.02, 1.), smoothstep(0.1, 0.3, abs(p.x)));\n    //browDir = mix(browDir, vec3(0.04, 0.02 - (0.05*sign(p.x)), 0.05), browLift);\n    browDir.xy *= rot(browLift*0.45);\n    browDir = normalize(browDir);\n    \n    float brow = lineSDF(vec3(abs(p.x), p.y, p.z) - vec3(eyeR*1.4, r+0.18 + (browLift*0.02), -r*0.77), -browDir*browLen*0.5, browDir*browLen*0.5, 0.01);\n    \n    vec3 mouthPos =  vec3(0, r-0.08, -r);\n    \n    float mouthBulge = 0.9*(1.0-smoothstep(0.09-0.05, 0.09+0.07, length(vec3(p.x/1.7, p.y, p.z) - mouthPos)))*0.06;\n    \n    head += smoothstep(mouthPos.y+0.01, mouthPos.y-0.29, p.y) * \n            smoothstep(mouthPos.y-0.06, mouthPos.y+0.02, p.y) *\n            smoothstep(0.21, 0.4, (-p.z*max(0.0, 0.5+abs(p.y+0.1)))-0.1)*max(0.0, 1.0-mouthBulge*9.);\n    head -= mouthBulge*0.9 * max(0.0, 1.0-0.6*(sgt(p.y, nosePos.y-0.2, 0.25) * slt(p.y, nosePos.y+0.2, 0.25) ));\n    head += 0.5*smoothstep(0.1, 0.9, abs(p.x))*smoothstep(-0.7, 0.2, -p.y+0.05)*smoothstep(-0.25, 0.5, p.y-0.2);\n    \n    head += 0.05*smoothstep(0.01, 0.26, p.y+0.06) * smoothstep(0.25, 0.01, p.y-0.06);\n   \n    head += 0.25*smoothstep(0.001, 0.5, p.y+0.02)*smoothstep(0.9, 0.0, p.y-0.02)*smoothstep(0.0, 0.25, p.z+0.2);\n    head += smoothstep(0.001, 2.5, abs(p.x));\n    \n   \n    head += 0.06 * smoothstep(0.0, 0.12, (r+0.09)-p.y) *\n                  smoothstep(-0.05, 0.09, p.y-0.3)  *\n                  smoothstep(-0.09, 0.15, (eyeR*1.9)-abs(p.x)) *\n                  smoothstep(-0.02, 0.09, abs(p.x)-0.05) *\n                  smoothstep(0.0, 0.09, -p.z);\n    head += sgt(abs(p.x), 0.02, 1.) * slt(abs(p.x), 0.15, 1.) * slt(p.y+0.01, nosePos.y,0.5) * sgt(p.y, nosePos.y-0.2, 0.5) * sclamp(-p.z, 0.0, 1., 0.25);\n\n    head /= 1.7;\n    nose /= 1.8;\n    float shoulderLen = 1.2;\n    float shoulderR = 0.19;\n    float shoulder = lineSDF(p - vec3(0, -0.15, 0), vec3(-shoulderLen/2., 0, 0), vec3(shoulderLen/2., 0, 0), shoulderR);\n    shoulder /= 1.2;\n    \n    head = smin(head, shoulder, 0.2);\n    head = smin(head, nose, 0.06);\n    head = smin(head, brow, 0.09);\n    \n    float earLen = 0.05;\n    vec3 earDir = normalize(vec3(1, -0.2, -0.56));\n    vec3 earPos = (vec3((r*0.48), r+0.02, 0.) + (earDir*earLen));\n    float ear = cylSDF(vec3(abs(p.x), p.y - (0.8*smoothstep(0.0, 0.8, p.z+0.08)), p.z) - earPos, vec3(0, 0, 0), earDir*earLen, 0.14);\n    float earInside = cylSDF(vec3(abs(p.x), p.y, p.z) - (vec3((r*0.49)-0.01, r+0.02, 0.) + (earDir*earLen*1.29)), vec3(0, 0, 0), earDir*earLen*1.15, 0.10);\n    vec3 earP = vec3(abs(p.x), p.y, p.z) - earPos;\n    float earFreq = clamp(1.0/max(0.035, distance(vec3(abs(p.x), p.y, p.z), earPos)), 0.0, 64.0);\n    ear += (exp(sin(0.5*earFreq)-1.)*0.15*sclamp(abs(p.x)-earPos.x, 0.0, 0.5, 0.15))-0.002;\n    ear -= 0.003;\n    ear = smax(ear, -earInside, 0.03);\n    ear /= 1.23;\n    head = smin(head, ear, 0.05);\n    \n    dist = min(dist, head);\n    \n    dist /= 1.1;\n    \n    vec3 eyeRot = vec3(0.10*cos(T), 0.25*sin(T)*sign(p.x), 0);\n    Object oEye = Object(o.p + eyePos, o.q+eyeRot);\n    SAMPLE(eye, oEye, ID_FACE_EYE);\n    // = min(head, eye);\n    \n\n    \n    return dist;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, o, ID_GROUND);\n    \n    int faceId = 0;\n    Object oFace = Object(vec3(0.0, 0.2, 0), vec3(0.0));\n    float face = faceSDF(p - oFace.p, faceId, oFace, skip);\n    SAMPLE(face, oFace, faceId);\n    \n    data.id = id;\n    data.o = o;\n    return dist;\n}\n\nfloat checkerTexture(in vec2 uv, in float s) {\n    vec2 d = max(abs(dFdx(uv)), abs(dFdy(uv))) + s;\n    vec2 t1 = vec2(1.-2.0*abs(fract((uv.x+.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y+.5*d.y)*.5)-0.5));\n    vec2 t2 = vec2(1.-2.0*abs(fract((uv.x-.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y-.5*d.y)*.5)-0.5));\n    return 0.5 - 0.5*((t1.x-t2.x)/d.x)*(t1.y-t2.y)/d.y;\n}\n\n\n//#define DEBUG_TEXTURE eyeTexture\n//#define DEBUG_CENTER_UV 1\nvec3 eyeTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = rgb(186, 181, 173);\n    \n    float ra = 0.006;\n    float fe = ra*0.44;\n    #ifdef DEBUG_TEXTURE\n    float front = 1.0;\n    ra += 0.05;\n    #else\n    float front = float(p.z < -0.03);\n    #endif\n    \n\n    \n    vec3 hf1 = snoise(uv, 0.00923912, 0.02, 24.0, 6);\n    vec3 lf1 = snoise(uv, 2.99828285, 0.2, 8.0, 6);\n    vec3 warp = snoiseWarp(uv, 6.6998493, 1.1, 32.0, 6, 0.9);\n    vec3 warp2 = snoiseWarp(uv, 10.2988929, 0.9, 24.0, 6, 0.9);\n    vec3 grain = abs(normalize(cross(warp*2.0-1.0, lf1*2.0-1.0)));\n    \n    float veins = 1.0-smoothstep(0.02, 0.04, abs((warp2.y-lf1.z)));\n    veins *= smoothstep(0.4, 0.7, warp.y);\n  //  col += max(smoothstep(0.48, 0.5, alv.x-0.5), smoothstep(0.48, 0.5, alv.y-0.5));\n\n    \n    vec3 v1 = rgb(193, 118, 107);\n    vec3 v2 = rgb(114, 43, 29);\n    vec3 v3 = rgb(122, 45, 49);\n    vec3 v4 = rgb(119, 41, 41);\n    \n    vec3 veinCol1 = mix4(v1, v2, v3, v4, warp2);\n    vec3 veinCol2 = mix4(v4, v3, v2, v1, warp);\n    vec3 veinCol = mix(veinCol1, veinCol2, smoothstep(0.4, 0.7, lf1.y));\n    \n    \n    float pupil = (1.0-smoothstep(ra-fe, ra+fe, length(uv))) * front;\n    \n    float irisRa = ra*2.3;\n    float irisFe = irisRa*0.19;\n    float iris = (1.0-smoothstep(irisRa-irisFe, irisRa+irisFe, length(uv)));\n    \n    vec3 irisColor = vec3(0, 1, 0);\n    \n    vec3 b1 = rgb(98, 110, 101);\n    vec3 b2 = rgb(138, 137, 106);\n    vec3 b3 = rgb(95, 109, 103);\n    vec3 b4 = rgb(155, 179, 175);\n\n    vec3 bg1 = mix4(b1, b2, b3, b4, smoothstep(0.4, 0.7, hf1));\n    vec3 bg2 = mix4(b4, b3, b2, b1, smoothstep(0.4, 0.7, hf1));\n    \n    irisColor = mix(bg1, bg2, smoothstep(0.4, 0.6, lf1.x));\n\n    vec3 f1 = rgb(100, 69, 3);\n    vec3 f2 = rgb(89, 50, 0);\n    vec3 f3 = rgb(133, 125, 88);\n    vec3 f4 = rgb(79, 60, 17);\n    \n    vec3 spotCol1 = mix4(f1, f2, f3, f4, smoothstep(0.4, 0.7, warp));\n    vec3 spotCol2 = mix4(f4, f3, f2, f1, smoothstep(0.4, 0.7, warp));\n    vec3 spotCol = mix(spotCol1, spotCol2, lf1.y);\n    \n    float spotArea = 1.0-smoothstep(0.4, 0.7, abs(grain.y*2.0-1.0));\n    spotArea *= smoothstep(0.3, 0.7, lf1.z);\n    \n    irisColor = mix(irisColor, spotCol, spotArea);\n    \n    irisColor = irisColor*irisColor;\n    col = mix(col, irisColor, iris);\n    col = mix(col, vec3(0.0), pupil);\n    \n    veins *= max(0.0, 1.0 - (iris + pupil + (spotArea*iris)));\n\n    col = mix(col, veinCol, veins);\n    \n    m.lum = 1.;\n    \n    m.rough = clamp(0.3-iris, 0.002, 0.4);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE skinTexture\n\nvec3 skinTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(186, 115, 85);\n    vec3 c2 = rgb(211, 162, 132);\n    vec3 c3 = rgb(175, 112, 58);\n    vec3 c4 = rgb(220, 164, 136);\n    \n    float pat = voronoi2D(uv*16., 3.39291);\n    \n    vec3 hf1 = snoise(uv, 0.092931, 0.02, 32.0, 6);\n    vec3 lf1 = snoise(uv, 4.494929, 0.03, 8.0, 6);\n    vec3 lf2 = snoise(uv, 9.982835, 0.04, 5.0, 6);\n    \n    pat *= smoothstep(0.4, 0.7, clamp(lf2.x+(lf1.z*0.15), 0.0, 1.0));\n    pat *= 0.4;\n    \n    vec3 patCol1 = mix4(c1, c2, c3, c4, smoothstep(0.4, 0.7, lf2));\n    vec3 patCol2 = mix4(c4, c3, c2, c1, smoothstep(0.4, 0.7, hf1));\n    vec3 patCol = mix(patCol1*c2, patCol2*patCol1, smoothstep(0.4, 0.7, lf1.z));\n    \n    vec3 skin1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 skin2 = mix4(c4, c3, c2, c1, hf1);\n    vec3 skinCol = mix(skin1, skin2, lf1.x);\n    col += skinCol;\n\n    float mouth = smoothstep(0.18, 0.02, abs(p.x))*sgt(p.y, 0.3, 0.2)*slt(p.y, 0.47, 0.2)*smoothstep(0.25, 0.33, max(0.0, -p.z)-0.1);\n    mouth *= smoothstep(0.0, 0.25, dot(p, normalize(vec3(0, -0.4, -1))));\n    \n    col = mix(col, mix(col, col*c1, clamp(hf1.y*1.5, 0.8, 1.0)), mouth);\n    col = mix(col, vec3(1, 0.39, 0.39), mouth*0.2);\n    \n\n    float mouthSep = slt(abs(p.x), 0.12, 0.18)*srange(p.y, 0.37, 0.38, 0.002+0.33*(smoothstep(0.0, 4.4, abs(p.y))*smoothstep(0.09, 0.03, abs(p.x))))*mouth;\n    col = mix(col, mix(col, col*col, hf1.x), mouthSep);\n   \n    \n    pat *= max(0.0, 1.0-mouth*2.);\n    \n    \n    col = mix(col, patCol, pat);\n    m.z = 0.5-pat;\n    m.spec = clamp(pat*3.5, 0.4, 0.7);\n    m.rough = clamp(((pat*2.)+(lf1.x*0.6))-(mouth*mouth*0.8), 0.38, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    uv -= 1.;\n    vec3 col = vec3(0.0)+checkerTexture(uv*0.5, 0.02);\n    data.m.rough = 0.5;\n    data.m.metallic = 0.55;\n    return col;\n}\n\nvec3 getAlbedoFace(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = pointRot(data.n, data.o.q);\n    vec2 uv = boxUv(p, n);\n    uv *= 6.;\n    vec3 col = skinTexture(uv, p, data.m);\n   data.n = makeNormal(data.n, data.m.z, 0.16, 0.09);\n    return col;\n}\n\nvec3 getAlbedoFaceEye(inout Data data) {\n    vec3 p = pointRot(vec3(abs(data.p.x), data.p.y, data.p.z) - data.o.p, data.o.q);\n    vec3 n = pointRot(data.n, data.o.q);\n    vec2 uv = p.xy;\n    vec3 col = eyeTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_FACE: return getAlbedoFace(data); break;\n        case ID_FACE_EYE: return getAlbedoFaceEye(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    depth = 1.0;\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = LIGHT_SUN; \n    \n    raycast(data, lights, col, ro, rd);\n    \n    depth = data.d / FAR;\n    \n    return col;\n}\n\nRay getRay(in vec2 uv, in vec4 m) {\n    vec3 ro = vec3(0, 0, -1.8);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        \n        const float y = 0.5;\n        ro.y += y;\n        ro.y = max(ro.y, y);\n    } else {\n        vec3 olook = vec3(0.0, 0.45, 0.0);\n        vec3 lookp = olook;\n        vec3 oro = vec3(0, 1.0, -1.8);\n        ro = oro;\n        rd = look(uv, lookp, ro, 1.0);\n        \n        if (iFrame > 1 && iTime > 0.002) {\n            const float transTime = 0.9;\n            float time = T*0.5;\n            const float numFrames = 15.0;\n            float cycle = mod(time, numFrames+transTime);\n            float frame = 1.0;\n\n            #define MX smoothstep(frame - transTime, frame + transTime, cycle)\n            #define MOVE_TO(POINT, LOOKP)\\\n                ro = mix(ro, POINT, MX);\\\n                lookp = mix(lookp, LOOKP, MX);\\\n                frame += max(1.0, float(ZERO));\n\n            MOVE_TO(oro + vec3(1.5, 0, 0.0), olook);\n            MOVE_TO(oro + vec3(0., 0, 0.0), olook);\n            MOVE_TO(oro + vec3(-1.5, 0, 0.0), olook);\n            MOVE_TO(vec3(-0.5, 0.5, -0.7), olook + vec3(0, 0.1, 0));\n            MOVE_TO(vec3(0.0, 0.6, -0.7), olook + vec3(0, 0.3, 0));\n            MOVE_TO(vec3(0.2, 0.6, -0.7), olook + vec3(0, 0.3, 0));\n            MOVE_TO(vec3(0.3, 1.0, -0.9), olook);\n            MOVE_TO(vec3(0.4, 1.1, -0.9), olook);\n            MOVE_TO(vec3(1.5, 1.2, 0.), olook);\n            MOVE_TO(vec3(1.9, 1.3, 1.5), olook);\n            MOVE_TO(vec3(2., 1.2, 1.9), olook);\n            MOVE_TO(vec3(-2., 1.2, 1.5), olook);\n            MOVE_TO(vec3(-2.2, 1.2, 0.0), olook);\n            MOVE_TO(vec3(-1.5, 1.2, -1.), olook);\n            MOVE_TO(oro, olook);\n\n\n            #undef MX\n            #undef MOVE_TO\n        \n        }\n        \n        rd = look(uv, lookp, ro, 1.0);\n    }\n\n    return Ray(ro, rd);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    Ray ray = getRay(uv, m);\n    vec3 ro = ray.ro;\n    vec3 rd = ray.rd;\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    #ifdef DEBUG_CENTER_UV\n    vec2 debugUv = (fc-0.5*R.xy)/R.y;\n    #else\n    vec2 debugUv = fc.xy/R.xy;\n    #endif\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(debugUv, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#ifndef HW_PERFORMANCE\n#define iTime (0.0)\n#define iFrame (0)\nuniform sampler2D iChannel3;\n#define iResolution vec2(0.0)\n#define iMouse vec4(0.0)\n#endif\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n\n\n#define FORWARD_DECL\\\n    float sdf(inout Data data, in vec3 p) { return FAR; }\\\n    vec3 getAlbedo(inout Data data) { return vec3(0.0); }\\\n    vec3 getSky(in vec3 rd) { return vec3(0.0); }\n\n#define SAMPLE(var, OBJ, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OBJ; }\n// Ray marcher constants\n\n#define NEAR 0.003\n#define FAR 60.0\n#define STEPS 86\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.001\n#define USE_LOOP_NORMALS 1\n#define AMBIENT 0.18\n#define NUM_LIGHTS 1\n#define ID_NONE -1\n\n// Colors\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n// Render constants\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n// Default sun light\n\n#define LIGHT_SUN Light(vec3(1, 2, -3), vec3(0.0), COLOR_SUN, 2.0, LIGHT_AMBIENT)\n\nstruct Object {\n    vec3 p;\n    vec3 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 q;\n    vec3 ro;\n    vec3 rd;\n    vec3 p;\n    vec3 n;\n    float d;\n    int skip;\n    int id;\n    float sig;\n    Material m;\n    Object o;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0),vec3(0.0), vec3(0.0), vec3(0.0), FAR, ID_NONE, ID_NONE, 1., NEW_MATERIAL, NEW_OBJECT)\n\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n#ifndef HW_PERFORMANCE\nfloat sdf(inout Data data, in vec3 p) { return FAR; }\nvec3 getAlbedo(inout Data data) { return vec3(0.0); }\nvec3 getSky(in vec3 rd) { return vec3(0.0); }\n#else\nfloat sdf(inout Data data, in vec3 p);\nvec3 getAlbedo(inout Data data);\nvec3 getSky(in vec3 rd);\n#endif\n\n\n// Utilities\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sclamp(in float v, in float mi, in float ma, in float k) {\n    return smin(smax(v, mi, k), ma, k);\n}\n\nfloat sgt(in float value, in float t, in float k) {\n    return smoothstep(0.0, abs(t*k), value-t);\n}\n\nfloat slt(in float value, in float t, in float k) {\n    return smoothstep(0.0, abs(t*k), t-value);\n}\n\nfloat srange(in float value, in float mi, in float ma, in float k) {\n    return smoothstep(mi, ma, value+k) * smoothstep(ma, mi, value-k);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.0000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0001);\n    vec2 dy = vec2(0.0001, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.00002) return wn;\n    cp = normalize(cp);\n    mx *= max(0.0, 1.0 - max(0.0, dot(cp, -wn)));\n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0001) return wn;\n    return next;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 look(in vec2 uv, in vec3 point, in vec3 ro, in float zoom) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    return p;\n}\n\n// UV functions\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec2 sphereUv(in vec3 p) {\n    float u = acos(p.x);\n    float v = atan(p.y, p.z);\n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    return vec2(u, v);\n}\n\n// Distance functions\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\n// Noise functions\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = floatBitsToUint(ip);\n    uint s = floatBitsToUint(seed)>>3U;\n    p ^= (p << 17U);\n    p.x ^= (p.x << s);\n    p.y ^= (~p.y << s) ^ ~p.x << 3U;\n    p ^= (p >> 13U);\n    p.y ^= (p.y << s);\n    p.x ^= (~p.x << s) ^ ~p.y >> 3U;\n    p ^= (p << 5U);\n    return 5031U*((p.x + p.y) + ((p.x ^ p.y) * ((s << ~p.x) + (s << ~p.y))));\n}\n\nfloat hash21(in vec2 p, in float seed) { return float(hash21u(p, seed)) / float(0xFFFFFFFFU); }\n\nfloat voronoi2D(in vec2 p, in float seed){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    float r = 1.0;\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, seed+3.328123), hash21(Pi+lattice, seed+5.58931));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            r = min(r, dist/0.56);\n            if(r < dmin){\n                dmin = r;\n                res = lattice + offset;\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\nfloat hash21Fast(in vec2 p, in float seed) {\n    float ma = 64.092391;\n    float x = mod(p.x*4.0291, ma) / ma;\n    float y = mod(p.y*5.5920, ma) / ma;\n    vec2 p2 = mix(vec2(x,y), vec2(y, x), fract(seed*10.29891231))*2.0-1.0;\n    float r1 = mod(100.2891382*fract(seed+(dot(p, p2)*16.2099123)), ma)/ma;\n    float r2 = fract((p.x*3.392912+p.y)*distance(p2, p-seed));\n    return fract(dot(p, vec2(r1, r2)));\n}\n\nfloat noiseFast(in vec2 p, in float seed) {\n    p += 0.0982812+seed;\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash21Fast(id, seed), hash21Fast(id+vec2(1,0), seed), lv.x),\n        mix(hash21Fast(id+vec2(0, 1), seed), hash21Fast(id+vec2(1,1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat noiseFast(in vec2 p, in float seed, in float freq, const in int octaves) {\n    p += 0.0982812+seed;\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * noiseFast(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy*n.z)*warp;\n    }\n    return n / div;\n}\n\n// Shading & Colors\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvec3 fresnelSchlickRoughness(float NdotV, vec3 F0, float rough) {\n  return F0 + (max(vec3(1.0 - rough), F0) - F0) * pow(max(1.0 - NdotV, 0.0), 5.0);\n}\n\nvec3 fresnelSchlick(vec3 F0, float cosTheta) {\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat ndfGGX(float cosLh, float roughness) {\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (cosLh * cosLh) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float cosTheta, float k) {\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float cosLi, float cosLo, float roughness) {\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return specularColor * AB.x + AB.y;\n}\n\n// Marching\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    \n    #if USE_LOOP_NORMALS\n    // from https://iquilezles.org/articles/normalsSDF/\n    const float h = NORMAL_RANGE;\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdf(data, p+e*h);\n    }\n    n = normalize(n);\n    #else\n    \n    vec2 e = vec2(NORMAL_RANGE, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    #endif\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    \n    return true;\n}\n\n// Modified version of iq's https://www.shadertoy.com/view/lsKcDD\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    Data data = NEW_DATA;\n    float NdotL = dot(n, rd);\n    float nl = max(0.0, NdotL);\n    float res = 1.0;\n    float ep = 1e20;\n    float t = NEAR+0.03;\n    float ss = (far/FAR)+0.2;\n    float tot = 0.0;\n    int lastId = -1;\n    float jumps = 0.0;\n    for(int i = ZERO; i < SHADOW_STEPS && t < far; i++){\n        vec3 p = ro + rd*t;\n        float j = float(i);\n        \n        // Move point away from surface\n        float jump = 0.5*clamp(pow(max(0.0, dot(normalize(rd+p), n)), 2.)*clamp(t/far, 0.5, 1.0), 0.0, 0.56)*\n             (1.0 + 0.5*float(lastId == skip)) * (1.0 + 1.5*max(0.0, dot(n, vec3(0, 1, 0))));\n        p += n*jump;\n        jumps += jump;\n        \n        \n        float h = sdf(data, p);\n        lastId = data.id;\n        tot += h;\n        float y = h*h / (2.9 * ep);\n        float d = sqrt(h*h-y*y);\n        res = min(res, d/(ss*max(0.0, t-y)));\n        ep = h;\n        t += h;\n        \n        if (t <= -0.5 || h <= -0.5 || d <= -0.5) break;\n    }\n    jumps /= float(SHADOW_STEPS);\n    float ra = far*0.5; // radius\n    float fe = ra*0.9; // feather\n    res = max(res, 0.0002);\n    res = max(mix(res*res,\n        (1.0-smoothstep(ra-fe, ra+fe, far-tot)),\n        0.8*smoothstep(0.0, 0.63, res+smoothstep(0.0, 0.9, tot / (1.0+tot*6.)))\n    ), 0.);\n    \n    res += (((0.5*res)*res*res) + (max(0.0, (t/far)*0.25*res*res)))*(1.0+(res*0.1));\n    res += max(0.0, 1.0-(res*res))*(res / (1.0 + res));\n    res /= (1.0 + ((jumps*(0.2+(res*res*2.5))) / (1.0+(nl*nl*2.*(1.0+nl)))));\n    res = mix(res, res / (1.0+res), 0.5*jumps*jumps);\n    res += 0.25*(0.5*(0.45+(res*res)));\n    res /= (1.0+((res+0.05)*max(0.0, 0.5-(nl*nl*2.))));\n    return clamp(res, AMBIENT, 1.);\n}\n\n\n// Lighting\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n           light.type == LIGHT_POINT ? normalize(light.p - p) :\n           normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.0), L, n, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    float metallic = data.m.metallic;\n    float rough = data.m.rough;\n    float specF = data.m.spec;\n    \n    vec3 LH = normalize(L + -rd);\n    float cosLi = max(0.0001, dot(n, L));\n\tfloat cosLh = max(0.0001, dot(n, LH));\n    float cosLo = max(0.0001, dot(n, -rd));\n    vec3 F0 = mix(vec3(0.04), diffuse, metallic);\n    vec3 F  = fresnelSchlick(F0, max(0.0, dot(LH, -rd)));\n    float D = ndfGGX(cosLh, rough);\n    float G = gaSchlickGGX(cosLi, cosLo, rough);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metallic);\n    vec3 diffuseBRDF = kd * diffuse;\n    vec3 specularBRDF = (F * D * G) / max(0.00003, 4.0 * cosLi * cosLo);\n    \n    return (diffuseBRDF + specF*specularBRDF) * max(att * shadow, diffuse*data.m.lum); \n}\n\n\n\nbool rayGetColor(inout Data data, in Light lights[NUM_LIGHTS],\n    in bool with_sky, inout vec3 col, in vec3 ro, in vec3 rd, inout vec3 diffuse) {\n    if (!march(data, ro, rd)) {\n        if (with_sky) {\n            col += getSky(rd);\n        }\n        return false;\n    }\n    vec3 albedo = getAlbedo(data);\n    diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n        Light light = lights[i];\n        col += forEachLight(light, data, ro, rd, diffuse);\n    }\n    return true;\n}\n\nbool raycast(\n    inout Data data,\n    in Light lights[NUM_LIGHTS],\n    inout vec3 col,\n    in vec3 ro,\n    in vec3 rd\n ) {\n    \n    vec3 diffuse = vec3(0.0);\n    if (!rayGetColor(data, lights, true, col, ro, rd, diffuse)) return false;\n    float rough = data.m.rough;\n    float metallic = data.m.metallic;\n    vec3 n = data.n;\n    vec3 p = data.p;\n    \n    if (rough < 0.993) {\n        vec3 F0 = mix(vec3(0.04), diffuse, metallic);\n        float NdotV = max(0.0, dot(n, -rd));\n        vec3 F = fresnelSchlickRoughness(NdotV, F0, rough);\n        Data reflectData = NEW_DATA;\n        vec3 reflectRo = p + (n*NEAR*3.);\n        vec3 reflectDir = reflect(rd, n);\n        vec3 reflectDiffuse = vec3(0.0);\n        vec3 reflectColor = vec3(0.0);\n        vec3 env = EnvBRDFApprox(vec3(0.77), rough*rough, NdotV);\n        reflectData.skip = data.id;\n        \n        rayGetColor(reflectData, lights, true, reflectColor, reflectRo, reflectDir, reflectDiffuse);\n        \n        col += reflectColor * (F * env.x * env.y);\n    }\n    \n    return true;\n}\n","name":"Common","description":"","type":"common"}]}