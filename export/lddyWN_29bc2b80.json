{"ver":"0.1","info":{"id":"lddyWN","date":"1527094747","viewed":143,"name":"spyro orb 2","username":"hclarke","description":"this one is nicer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CAM_POS vec3(3,1,1)\n#define LIGHT_DIR vec3(1., 1., -1.)\n#define saturate(x) min(1., max(0., (x)))\n\n//maths\nvec4 plane_decompose(vec3 point, vec3 normal) {\n    float d = dot(point,normal);\n    return vec4(point-normal*d, d);\n}\n\n//colors\nconst mat3 YUV_to_RGB = mat3(\n         1.0,1.0,1.0,\n        0.0,-0.39465,2.03211,\n        1.13983,-0.58060,0.0);\n\nconst mat3 XYZ_to_RGB = mat3(\n    3.2406, -0.9689, 0.0557,\n    -1.5372, 1.8758, -0.2040,\n    -0.4986, 0.0415, 1.0570);\n\nconst vec3 D65_XYZ = vec3(.95047, 1.0, 1.08883);\nconst vec3 D65_xyY = vec3(0.31271, 0.32902, 1.0);\nconst vec3 D65_Yuv = vec3(1.0, 0.19784, 0.46834);\nconst vec3 ONE = vec3(1.0,1.0,1.0);\n\nvec3 XYZ_to_xyY(vec3 XYZ) {\n \tfloat inv_sum = 1.0/dot(XYZ,ONE);\n    return XYZ.xyy * vec3(inv_sum,inv_sum,1.0);\n}\n\nvec3 xyY_to_XYZ(vec3 xyY) {\n \tfloat s = xyY.z/xyY.y;\n    float z = 1.0-dot(vec2(1.0,1.0), xyY.xy);\n    return vec3(xyY.x, xyY.z, z) * vec3(s,1.0,s);\n}\n\nvec3 LUV_to_XYZ(vec3 LUV) {\n    vec2 uv = LUV.yz / (13.0*LUV.x) + D65_Yuv.yz;\n    float Y = LUV.x > 8.0 ? \n        D65_Yuv.x * pow((LUV.x+16.0)/116.0, 3.0) : \n    \tLUV.x * D65_Yuv.x * 0.00110705645;\n    float X = Y * 9.0 * uv.x / (4.0*uv.y);\n    float Z = Y * (12.0-3.0*uv.x-20.0*uv.y)/(4.0*uv.y);\n    return vec3(X,Y,Z);\n}\n\nvec3 YUV_spiral(float v, float r, float l, float L, float h, float H) {\n    float hue = mix(h,H,v);\n    float lum = mix(l,L,v);\n    float amp = r*lum*(1.0-lum);\n \tfloat a = 3.14159*2.0*(hue);\n    vec3 c = vec3(lum,sin(a),cos(a));\n   \tc.yz *= amp;\n    return YUV_to_RGB*c;\n}\n\nvec3 LUV_spiral(float v, float r, float l, float L, float h, float H) {\n    float hue = mix(h,H,v);\n    float lum = mix(l,L,v);\n    float amp = r*lum*(1.0-lum);\n \tfloat a = 3.14159*2.0*(hue);\n    vec3 c = vec3(lum,sin(a),cos(a))*100.0;\n   \tc.yz *= amp;\n    return XYZ_to_RGB*LUV_to_XYZ(c);\n}\n\n\n// signed distance stuff\nfloat sd_sphere(vec3 pos, vec3 c, float r) {\n \treturn length(c-pos)-r;   \n}\n\nfloat sd_plane(vec3 pos, vec3 normal, vec3 point) {\n\treturn dot(normal, pos-point);    \n}\n\nfloat sd_torus(vec3 pos, vec3 mid, vec3 axis, float radius, float thickness) {\n \tpos -= mid;\n    vec4 d = plane_decompose(pos, axis);\n    return length(vec2(length(d.xyz)-radius, d.w)) - thickness;\n}\n\nfloat sd_union(float a, float b) {\n \treturn min(a,b);   \n}\n\nfloat sd_intersect(float a, float b) {\n \treturn max(a,b);   \n}\n\n//mixing params\nfloat sd_union_mix(float a, float b) {\n \treturn a < b ? 0. : 1.;   \n}\n\nfloat sd_intersect_mix(float a, float b) {\n \treturn a > b ? 0. : 1.;   \n}\n\n// hit/material stuff\nstruct Hit {\n \tfloat dist;\n    vec3 albedo;\n    float wrap;\n    float smoothness;\n    float metallic;\n    float spec; // f0 = t*0.8\n};\n    \nHit default_hit() {\n\tHit h;\n    h.dist = 1000.;\n    h.albedo = vec3(0,0,0);\n    h.wrap = 0.;\n    h.smoothness = 0.;\n    h.metallic = 0.;\n    h.spec = 0.5;\n    return h;\n}\n\nHit lerp(Hit a, Hit b, float x) {\n    float y = 1.0-x;\n    Hit c;\n    c.dist = a.dist*y + b.dist*x;\n    c.albedo = a.albedo*y + b.albedo*x;\n    c.wrap = a.wrap*y + b.wrap*x;\n    c.smoothness = a.smoothness*y + b.smoothness*x;\n    c.metallic = a.metallic*y + b.metallic*x;\n    c.spec = a.spec * y + b.spec * x;\n    return c;\n}\n\nHit hit_union(Hit a, Hit b) {\n \treturn lerp(a,b,sd_union_mix(a.dist,b.dist));   \n}\n\n// lighting maths\n\nfloat wrap_diffuse(float ndotl, float wrap) {\n    float div = (1.+wrap)*(1.+wrap);\n \treturn saturate((ndotl+wrap)/div);\n}\n\n// visibility = 0.25*geometry/(ndotl*ndotv)\nfloat visibility(float ndotl, float ndotv, float roughness) {\n    float rr = roughness * roughness;\n    float ll = ndotl * sqrt((-ndotl*rr+ndotl)*ndotl+rr);\n    float lv = ndotv * sqrt((-ndotv*rr+ndotv)*ndotv+rr);\n    return 0.5 / (ll+lv+1e-6);\n}\n\nfloat ndf(float ndoth, float roughness) {\n \tfloat d = (ndoth  * roughness - ndoth) * ndoth + 1.;\n    return roughness / (d*d+1e-7) / 3.14195;\n}\n\nvec3 fresnel(vec3 f0, float ndoth) {\n \tfloat t = (1.-ndoth);\n    t = t*t*t*t*t;\n    return f0 + (1. - f0)*t;\n}\n\nvec3 fresnelMix(vec3 f0, vec3 f90, float ndotv) {\n \tfloat t = (1.-ndotv);\n    t = t*t*t*t*t;\n    return mix(f0, f90, t);\n}\n\nvec3 specular(float ndotl, float ndotv, float ndoth, vec3 f0, float smoothness) {\n    float roughness = 1.-smoothness;\n    roughness *= roughness;\n \tfloat D = ndf(ndoth, roughness);\n    float V = visibility(ndotl, ndotv, roughness);\n    vec3 F = fresnel(f0, ndoth);\n    \n    return D*V*F;\n}\n\n\n//materials\n\nHit gold(float sd) {\n  Hit h = default_hit();\n  h.albedo = vec3(1.0, 0.835, 0.5);\n  h.smoothness = 0.99;\n  h.metallic = 1.0;\n  h.dist = sd;\n  return h;\n}\n\nHit silver(float sd) {\n  Hit h = default_hit(); \n  h.albedo = vec3(1.0, 1.0, 1.0);\n  h.smoothness = 0.99;\n  h.metallic = 1.0;\n  h.dist = sd;  \n  return h;\n}\n\nHit obsidian(float sd) { \n  Hit h = default_hit();\n  h.albedo = vec3(0.0, 0.0, 0.0);\n  h.smoothness = 0.99;\n  h.metallic = 0.0;\n  h.spec = 0.8;\n  h.dist = sd;\n  return h;\n}\n\nHit emerald(float sd) {\n  Hit h = default_hit();\n  h.albedo = vec3(0.3, 1.0, 0.2);\n  h.smoothness = 0.1;\n  h.metallic = 1.0;\n  h.spec = 0.5;\n  h.dist = sd;\n  return h;\n}\n\n\nHit scene(vec3 pos) {\n  float t = iTime * 2.*3.14159 / 4.;\n   \n  // sphere\n  Hit s = emerald(sd_sphere(pos, vec3(0,0,0), 0.85));\n  Hit h = s;\n    \n  // outer ring\n  vec3 r0n = normalize(vec3(sin(t),40.,cos(t)));\n  Hit r0 = gold(sd_torus(pos, vec3(0,0,0), r0n*0.5, 1.0, 0.1));\n  h = hit_union(h, r0);\n  \n  // middle ring\n  vec3 r1n = vec3(sin(t),0,cos(t));\n  Hit r1 = gold(sd_torus(pos, vec3(0,0,0), r1n*0.5, 1.0, 0.1));\n  h = hit_union(h, r1);\n    \n  // inner ring\n  vec3 r2n = vec3(cos(t), 0, sin(-t));\n  Hit r2 = gold(sd_torus(pos, vec3(0,0,0), r2n*0.5, 1.0, 0.1));\n  h = hit_union(h, r2);\n    \n  return h;\n}\n\nfloat sd_scene(vec3 pos) {\n \treturn scene(pos).dist;   \n}\n\nvec3 normal_scene(vec3 pos) {\n\tvec2 e = vec2(0.00001, 0.0);\n    return normalize(vec3(\n       sd_scene(pos+e.xyy) - sd_scene(pos-e.xyy),\n       sd_scene(pos+e.yxy) - sd_scene(pos-e.yxy),\n       sd_scene(pos+e.yyx) - sd_scene(pos-e.yyx)\n    ));\n}\n\n\nvec3 sky(vec3 dir, float lod) {\n    //this is awful. really want mipmaps here\n    vec3 h = texture( iChannel0, dir).xyz;\n    vec3 l = texture( iChannel1, dir).xyz;\n    if(lod < 0.5) return mix(h,l,lod*2.);\n    else return mix(l, vec3(1,1,1) * 0.5, lod*2.-1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy;\n    \n    float time = iTime * 2. * 3.15159 / 6.;\n    vec3 pos = CAM_POS;//vec3(sin(time), 0.3, cos(time)) * 4.0;\n    vec3 focus = vec3(0,0,0);\n    vec3 fwd = normalize(focus-pos);\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(up,fwd));\n    up = normalize(cross(fwd,right));\n    vec3 dir = normalize(right*uv.x + up*uv.y + fwd);\n    \n    \n    float d = 0.0;\n    for(int i = 0; i < 512; ++i) {\n        vec3 p = pos+dir*d;\n        float sd = sd_scene(p);\n        if(abs(sd) < 0.001 || d > 200.0) break;\n        d += sd * 1.0;\n    }\n    \n    Hit hit = scene(pos+dir*d);\n    if(hit.dist > 0.1) {\n        float c = 0.6;\n        vec3 bgc = LUV_spiral(uv.y + 0.5, 1.2-length(uv)*1.2, 0.6, 0.7, c, c+0.2);\n        fragColor = vec4(bgc,1);\n        return;\n    }\n    vec3 N = normal_scene(pos+dir*d);\n    vec3 L = normalize(LIGHT_DIR);\n    vec3 V = -dir;\n    vec3 H = normalize(V+L);\n    vec3 R = reflect(dir,N);\n    \n    \n    float ndotl = dot(N,L);\n    float ndotv = saturate(dot(N,V));\n    float ndoth = saturate(dot(N,H));\n    \n    float diff = wrap_diffuse(dot(N,L), hit.wrap)/3.14159;\n    diff *= (1.-hit.metallic);\n    \n    float f0d = hit.spec * 0.8;\n    \n    vec3 specColor = mix(vec3(f0d,f0d,f0d), hit.albedo, hit.metallic);\n    vec3 spec = specular(saturate(ndotl), ndotv, ndoth, specColor, hit.smoothness);\n    spec *= ndotl * 3.14195;\n    spec = max(vec3(0,0,0),spec);\n    \n    \n    float proughness = 1.0-hit.smoothness;\n    float mip = proughness;\n    vec3 refl = sky(R,mip);\n    float roughness = proughness * proughness;\n    vec3 grazingColor = vec3(1,1,1) * saturate(hit.smoothness + mix(f0d, 1.0, hit.metallic));\n    refl *= 1.0 / (roughness*roughness+1.0);\n    refl *= fresnelMix(hit.albedo, grazingColor, ndotv);\n\n    fragColor = vec4(hit.albedo * diff + spec + refl,1);\n}","name":"Image","description":"","type":"image"}]}