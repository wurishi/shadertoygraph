{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime tmod + ;\n\niResolution frag->position =p\n\n:m blend /{ ( x ) [ x .yz.x 1 mod swap ] -1 1 clamp } \\+ ;\n:m blend-avg !size =>s /{ ( x ) [ x .yz.x 1 mod swap ] -1 1 clamp } \\+ s / ;\n\n:m center-mod ( x a ) x a deg->rad mod a 2 / deg->rad - a 2 / deg->rad / ;\n\n: base ( tmod:float p:vec2 -> vec3 )\n\tp cart->polar =p\n\t[ p .y pi * time 7 / sin * 0 ] p + =p\n\ttime p - =p\n\t[ p .x 90 center-mod p .y ] polar-norm =d\n\t[ d .x time + [ d .x d .y 5 * d .y time sin 2 d .x * * * ] length sin abs p .x 8 * sin abs ]\n;\n\n: shadow ( tmod:float p:vec2 -> vec3 )\n\tp cart->polar =p\n\ttime sin 3 ** abs .5 1 clamp =pulse\n\t[ 0 p .y neg pulse * dup ]\n;\n\n$[-.5:+.5:.125] /{ ( tmod )\n\t[\n\t\ttmod p base\n\t\ttmod p shadow\n\t] blend hsv1->rgb\n} !size =>s \\+ s 2 / / ->fragcolor\n*/\n\nvec2 cart_polar(vec2 p) {\n\treturn vec2(atan(p.y, p.x), length(p));\n}\nvec3 hsv1_rgb(vec3 hsv) {\n\treturn mix(vec3(1., 1., 1.), clamp(abs(mod(hsv.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.), hsv.y) * hsv.z;\n}\nvec2 polar_norm(vec2 p) {\n\treturn vec2(mod(p.x + 6.2832, 6.2832), p.y);\n}\nvec3 shadow(float tmod, vec2 p) {\n\tp = cart_polar(p);\n\tfloat pulse = clamp(abs(pow(sin(iTime + tmod), 3.)), .5, 1.);\n\tfloat var_3 = -p.y * pulse;\n\treturn vec3(0., var_3, var_3);\n}\nvec3 base(float tmod, vec2 p) {\n\tp = cart_polar(p);\n\tp = vec2(p.y * 3.14159 * sin((iTime + tmod) / 7.), 0.) + p;\n\tp = iTime + tmod - p;\n\tvec2 d = polar_norm(vec2((mod(p.x, 1.5708) - .78538) / .78538, p.y));\n\treturn vec3(d.x + iTime + tmod, abs(sin(length(vec3(d.x, d.y * 5., d.y * sin(iTime + tmod) * 2. * d.x)))), abs(sin(p.x * 8.)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tfragColor = vec4((hsv1_rgb(clamp(vec3(mod(base(-.5, p).x, 1.), base(-.5, p).yz), -1., 1.) + clamp(vec3(mod(shadow(-.5, p).x, 1.), shadow(-.5, p).yz), -1., 1.)) + hsv1_rgb(clamp(vec3(mod(base(-.375, p).x, 1.), base(-.375, p).yz), -1., 1.) + clamp(vec3(mod(shadow(-.375, p).x, 1.), shadow(-.375, p).yz), -1., 1.)) + hsv1_rgb(clamp(vec3(mod(base(-.250, p).x, 1.), base(-.250, p).yz), -1., 1.) + clamp(vec3(mod(shadow(-.250, p).x, 1.), shadow(-.250, p).yz), -1., 1.)) + hsv1_rgb(clamp(vec3(mod(base(-.125, p).x, 1.), base(-.125, p).yz), -1., 1.) + clamp(vec3(mod(shadow(-.125, p).x, 1.), shadow(-.125, p).yz), -1., 1.)) + hsv1_rgb(clamp(vec3(mod(base(0., p).x, 1.), base(0., p).yz), -1., 1.) + clamp(vec3(mod(shadow(0., p).x, 1.), shadow(0., p).yz), -1., 1.)) + hsv1_rgb(clamp(vec3(mod(base(.125, p).x, 1.), base(.125, p).yz), -1., 1.) + clamp(vec3(mod(shadow(.125, p).x, 1.), shadow(.125, p).yz), -1., 1.)) + hsv1_rgb(clamp(vec3(mod(base(.250, p).x, 1.), base(.250, p).yz), -1., 1.) + clamp(vec3(mod(shadow(.250, p).x, 1.), shadow(.250, p).yz), -1., 1.)) + hsv1_rgb(clamp(vec3(mod(base(.375, p).x, 1.), base(.375, p).yz), -1., 1.) + clamp(vec3(mod(shadow(.375, p).x, 1.), shadow(.375, p).yz), -1., 1.)) + hsv1_rgb(clamp(vec3(mod(base(.500, p).x, 1.), base(.500, p).yz), -1., 1.) + clamp(vec3(mod(shadow(.500, p).x, 1.), shadow(.500, p).yz), -1., 1.))) / 4.5, 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xtf3z7","date":"1419710389","viewed":190,"name":"Dec 26","username":"daeken","description":"Just some tinkering.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["colorful","shaderforth"],"hasliked":0,"parentid":"","parentname":""}}