{"ver":"0.1","info":{"id":"3llfDn","date":"1596474463","viewed":142,"name":"Messing around with physics","username":"CoolerZ","description":"Try changing the number of particles.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["particles","rainbow","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = texelFetch(iChannel0, ivec2(fragCoord-.5), 0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_PARTICLES 10\n#define time (iTime*.01)\n#define delta_time (100.*iTimeDelta)\n#define GRAVITATIONAL_FORCE (.1+.25*sin(.5*iTime))\n#define REPULSIVE_FORCE (.25+.1*sin(iTime))\n#define MASS 10.\n#define PARTICLE_SIZE .1\n#define PERSISTENCE .9\n#define VEL_CONSTRAINT .05\n#define FORCE_CONSTRAINT .1\n\n#define FORCE_CENTER vec2(cos(iTime),sin(iTime))","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = texelFetch(iChannel0, ivec2(fragCoord-.5), 0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 mymod(vec2 p)\n{\n    float ratio = iResolution.x/iResolution.y;\n    float inv_ratio = iResolution.y/iResolution.x;\n\t//return 2.*fract(.5+.5*p)-1.;\n\treturn vec2(2.*ratio,2.)*fract(.5+vec2(.5*inv_ratio,.5)*p)-vec2(ratio,1.);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 pixel_coords = ivec2(fragCoord-.5);\n    vec4 pos_vel = texelFetch(iChannel0, pixel_coords, 0);\n    if(iFrame < 32)\n    {\n        // SETUP\n        const float PI = radians(180.);\n        const float PI2 = PI*2.;\n        const float ANGLE_OFFSET = PI2/float(NUM_PARTICLES);\n        int p_idx = pixel_coords.x;\n        float angle = float(p_idx)*ANGLE_OFFSET;\n        vec2 pos = vec2(cos(angle),sin(angle));\n        pos_vel = vec4(pos,-pos);\n    }\n    else if(pixel_coords.y == 0 && pixel_coords.x < NUM_PARTICLES)\n    {\n        // PHYSICS\n        vec2 pos = pos_vel.xy;\n        vec2 vel = pos_vel.zw;\n\n        vec2 force = vec2(0.);\n        for(int i = 0; i < NUM_PARTICLES; i++)\n        {\n            if(i==pixel_coords.x)continue;\n            vec2 other_pos = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n            vec2 t1 = (other_pos-pos);\n            float t2 = length(t1);\n            vec2 t3 = normalize(t1);\n            vec2 gravity = GRAVITATIONAL_FORCE*t3/(t2*t2);\n            vec2 repulsion = REPULSIVE_FORCE*(-t3)/(t2*t2*t2);\n            vec2 curr_force = clamp(gravity + repulsion, -FORCE_CONSTRAINT, FORCE_CONSTRAINT);\n            force += curr_force;\n        }\n        vec2 acc = force/MASS;\n        vec2 new_pos = mymod(pos + vel*delta_time);\n        //vec2 new_vel = vel + acc*time;\n        vec2 new_vel = clamp(vel + acc*delta_time, -VEL_CONSTRAINT, VEL_CONSTRAINT);\n        pos_vel = vec4(new_pos, new_vel);\n    }\n    else if(pixel_coords.y == 10 && pixel_coords.x < NUM_PARTICLES)\n    {\n        // DENSITY\n        vec2 pos = pos_vel.xy;\n        float density = 0.;\n        const float MIN_DISTANCE = 2.*PARTICLE_SIZE;\n        //float THRESHOLD = MIN_DISTANCE+float(pixel_coords.x)/float(2*NUM_PARTICLES)+(-1.+2.*sin(time));\n        float hmm = float(pixel_coords.x)/float(2*NUM_PARTICLES);\n        float THRESHOLD = MIN_DISTANCE+4.*MIN_DISTANCE*sin(10.*hmm*iTime);\n        for(int i = 0; i < NUM_PARTICLES; i++)\n        {\n            if(i==pixel_coords.x)continue;\n            vec2 other_pos = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n            if(length(other_pos-pos) < THRESHOLD)density++;\n        }\n        density /= float(NUM_PARTICLES);\n        pos_vel = vec4(density);\n    }\n    fragColor = pos_vel;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float particle_d(vec2 p, vec2 pos)\n{\n    return length(p-pos)-PARTICLE_SIZE;\n}\n\n/*\n// pick raw cosine, or band-limited cosine\nbool mode = false;\nfloat mcos(float x){return mode ? cos(x) : fcos(x);}\n\nvec3 get_color(float t)\n{\n    const float F = PI2;\n    const float A = .5;\n    vec3 col = vec3(1,0,0)*Z(mcos(F*t)) + vec3(0,1,0)*Z(mcos(F*t-PI2/3.)) + vec3(0,0,1)*Z(mcos(F*t-2.*PI2/3.));\n    return col;\n}\n*/\n\n#define Z(X) (.5+.5*(X))\n\nvec3 get_color(float t)\n{\n    const float PI = radians(180.);\n    const float PI2 = PI*2.;\n    const float F = PI2;\n    const float A = .5;\n    vec3 col = vec3(1,0,0)*Z(cos(F*t)) + vec3(0,1,0)*Z(cos(F*t-PI2/3.)) + vec3(0,0,1)*Z(cos(F*t-2.*PI2/3.));\n    return col;\n}\n\nvec2 combine(vec2 d1, vec2 d2)\n{\n    return d1.x <= d2.x ? d1 : d2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 d = vec2(10000.0, -1.);\n    for(int i = 0; i < NUM_PARTICLES; i++)\n    {\n        vec2 pos = texelFetch(iChannel0, ivec2(i,0), 0).xy;\n        d = combine(d, vec2(particle_d(uv, pos), i));\n    }\n    // float mask = 1.-smoothstep(0.,.5,d.x); // blobs\n    float mask = 1.-smoothstep(0.,.1,d.x);\n    vec3 rainbow = vec3(0.);\n    if(d.y > 0.)\n    {\n        // rainbow = get_color(texelFetch(iChannel0, ivec2(d.y, 10), 0).x);\n        vec2 pos = uv;\n        float density = 0.;\n        for(int i = 0; i < NUM_PARTICLES; i++)\n        {\n            vec2 other_pos = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n            density += length(other_pos-pos);\n        }\n        //rainbow = get_color(density/float(NUM_PARTICLES));\n        //rainbow = get_color(float(NUM_PARTICLES)/density);\n        density = smoothstep(0., 1., float(NUM_PARTICLES)/density);\n        rainbow = get_color(density);        \n    }\n    vec3 col = mix(vec3(0.), rainbow, mask);\n    //vec3 col = vec3(mask);\n\n    /*\n    float center_d = particle_d(uv, FORCE_CENTER);\n    float center_mask = 1.-smoothstep(0.,.01,center_d);\n    col = mix(col, vec3(1.,0.,0.), center_mask);\n\t*/\n    vec3 prev_col = texelFetch(iChannel1, ivec2(fragCoord-.5), 0).rgb;\n    //col = mix(col, prev_col, PERSISTENCE);\n    col = col + prev_col*PERSISTENCE;\n    //if(uv.x < -1. || uv.x > 1.)col = get_color(uv.y);\n\tfragColor = vec4(col,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 new_col = texelFetch(iChannel0, ivec2(fragCoord-.5), 0);\n    vec4 old_col = texelFetch(iChannel1, ivec2(fragCoord-.5), 0);\n\tfragColor = mix(new_col, old_col, PERSISTENCE);\n}","name":"Buffer D","description":"","type":"buffer"}]}