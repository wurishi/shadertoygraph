{"ver":"0.1","info":{"id":"4sK3WV","date":"1456497647","viewed":357,"name":"Solaris","username":"piratehurrdurr","description":"Modified this after receiving some advice.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","trippy","whynot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IT 64\n#define MAX 10.0\n#define EP 1e-3\n#define EPN 1e-2\n#define CS .xzy\n\n#define E 2.71828182845904523536028747135266249775724709369995\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Uncomment to only see AO\n//#define AMBONLY\n\n#define aoc 12\n#define aos 0.109\n\nvec3 aoOffsets[aoc];\n\nvec3 amb(vec3 dir) {\n    \n    vec3 skyBase = vec3(0.6, 0.8, 0.9)*(1.0+0.6*dot(dir, vec3(0.0,0.0,-1.0)));\n    float sunStr = pow(max(1.05* dot(dir, normalize(vec3(1.0,1.0,1.0))),0.0),6.0);\n\tvec3 skySun = vec3(0.5,0.5,0.2)*sunStr;\n    \n    skyBase = rgb2hsv(skySun*5.0+skyBase);\n    skyBase.x += iTime/5.0;\n    skyBase.y =(skyBase.y +1.0)/2.0;\n    skyBase = hsv2rgb(skyBase);\n    \n    return skySun+skyBase;\n    \n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat terrain(vec2 pos) {\n    return (\n        texture(iChannel0,pos/15.0).r/3.0-texture(iChannel1,pos/64.0).g/5.0)\n        -(pow(length(pos.xy),2.0)*0.003)\n        +sin(-iTime+length(pos)*5.0)/10.0\n        \n        ;\n        ;\n}\n\n\nfloat dist(vec3 pos) {\n    \n    \n    return max(min(\n        max(sphere(pos,0.5), -sphere(vec3(0.5)-pos,0.5)),\n        -(terrain(pos.xy)-pos.z)\n        ),min(-sphere(-pos,0.48),pos.z-0.2));\n    \n}\n\n\nfloat AO(vec3 pos) {\n    float hit;\n    float total = float(aoc);\n    \n    for (int i=0; i<aoc; i++) {\n        float d = dist(pos+aoOffsets[i]);\n        if (d>0.0) {\n            hit+=d;\n        }\n    }\n    \n    //float total = 3.0*3.0*3.0;\n    //for (int i=-1; i<=1; i++) {\n    //    for (int j=-1; j<=1; j++) {\n    //        for (int k=-1; k<=1; k++) {\n    //            float d= dist(pos+vec3(i,j,k)*0.1);\n    //            if (d>=0.0) {\n    //                hit+=d;\n    //            }\n    //                 }\n    //    }\n    //}\n    return max(min(hit*32.0/total,1.0),0.0);\n}\n\nvec3 scan(vec3 pos, vec3 dir) {\n    \n    float totalDistance=0.0;\n    for (int i=0; i<IT; i++) {\n        float rayDist = dist(pos);\n        totalDistance+=rayDist;\n        if (abs(rayDist)<=EP) {\n            \n           #ifdef AMBONLY\n            return vec3(AO(pos));\n            #endif\n            \n            if (pos.z<0.0) {\n            //return amb(reflect(dir, vec3(0.0,0.0,1.0)));\n            }\n            \n            vec2 eps = vec2(0.0, EPN);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdist(pos + eps.yxx) - dist(pos - eps.yxx),\n    \t\tdist(pos + eps.xyx) - dist(pos - eps.xyx),\n    \t\tdist(pos + eps.xxy) - dist(pos - eps.xxy)));\n            \n            \n            \n            vec3 sunColor = vec3(1.0,0.8,0.4);\n            vec3 sunVector = normalize(vec3(1.0,1.0,1.0));\n            float sunAtten = max(0.0, dot(sunVector,normal));\n            \n            vec3 ambientColor = vec3(0.6,0.8,1.0);\n            float ambientAtten = AO(pos);\n            \n            vec3 reflDir = reflect(dir, normal);\n            sunAtten+=pow(max(dot(reflDir, sunVector),0.0),16.0)*ambientAtten;\n            \n            //return vec3(ambientAtten);\n            \n            vec4 fog = vec4(0.6, 0.8, 0.9,1.0-1.0/pow(E,totalDistance*0.05));\n            fog.a=0.0;\n            \n            vec3 light = sunColor*sunAtten + ambientColor*ambientAtten;\n            vec3 world = mix(texture(iChannel1, pos.xy/7.0).rgb,texture(iChannel1,pos.xy).rgb,0.5)*light;\n            \n            vec3 finalColor = mix(world, fog.rgb,fog.a);\n            \n            finalColor = rgb2hsv(finalColor);\n            finalColor.x -= iTime;\n            finalColor.x += totalDistance*3.0+ length(pos+vec3(cos(iTime)*20.0,sin(iTime)*20.0,0.0));\n            finalColor = hsv2rgb(finalColor);\n            \n            return finalColor ;//*texture(iChannel2, normal).rgb;\n        }\n        if (totalDistance>=MAX) {\n            return amb( reflect(dir, vec3(0.0,0.0,1.0)));\n        }\n        pos+=dir*(rayDist);\n    }\n    \n    if (dir.z<0.0) {\n    \treturn amb( reflect(dir, vec3(0.0,0.0,1.0)));\n    }\n    return amb(dir);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 uv){\n    uv = (uv-iResolution.xy/2.0)/iResolution.y;\n    float a = iTime*0.125;\n    \n    \n\naoOffsets[0]=vec3(\taos*0.0\t\t\t,aos*-0.525731\t\t,aos*0.850651);\naoOffsets[1]=vec3(\taos*0.850651\t,aos*0.0\t\t\t\t,aos*0.525731);\naoOffsets[2]=vec3(\taos*0.850651\t,aos*0.0\t\t\t\t,aos*-0.525731);\naoOffsets[3]=vec3(\taos*-0.850651\t,aos*0.0\t\t\t\t,aos*-0.525731);\naoOffsets[4]=vec3(\taos*-0.850651\t,aos*0.0\t\t\t\t,aos*0.525731);\naoOffsets[5]=vec3(\taos*-0.525731\t,aos*0.850651\t\t,aos*0.0);\naoOffsets[6]=vec3(\taos*0.525731\t,aos*0.850651\t\t,aos*0.0);\naoOffsets[7]=vec3(\taos*0.525731\t,aos*-0.850651\t\t,aos*0.0);\naoOffsets[8]=vec3(\taos*-0.525731\t,aos*-0.850651\t\t,aos*0.0);\naoOffsets[9]=vec3(\taos*0.0\t\t\t,aos*-0.525731\t\t,aos*-0.850651);\naoOffsets[10]=vec3(\taos*0.0\t\t\t,aos*0.525731\t\t,aos*-0.850651);\naoOffsets[11]=vec3(\taos*0.0\t\t\t,aos*0.525731\t\t,aos*0.850651);\n\t\n\n    \n    //vec3 pos = vec3(cos(a/4.0+sin(a/2.0)),cos(a*0.2),sin(a*0.31)/4.5+1.0)*3.0;\n    vec3 pos = vec3(cos(iMouse.x/64.0),sin(iMouse.x/64.0),iMouse.y/64.0+0.3);\n    vec3 on = vec3(1.0,uv.x,uv.y);\n    vec3 n = pos;\n\n    //n = normalize(pos + (0.1*vec3(cos(a*2.3),cos(a*2.61),cos(a*1.62))));\n\tvec3 crossRight = normalize( cross(n,vec3(0.0,0.0,1.0)));\n\tvec3 crossUp = normalize(cross(n, crossRight));\n\tn = n*(0.5+sin(length(uv-0.5)*5.0+iTime)/5.0) + crossRight*uv.x + crossUp*uv.y;\n    \n    fragColor.rgb = scan(pos,-normalize(n)).rgb;\n}","name":"Image","description":"","type":"image"}]}