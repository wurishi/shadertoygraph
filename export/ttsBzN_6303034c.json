{"ver":"0.1","info":{"id":"ttsBzN","date":"1596223477","viewed":109,"name":"Slanted Capped Cone","username":"mskr","description":"The caps of this capped cone can be oriented by individual normals.\nBased on David Eberly's GeometricTools.com (Line-Cone intersection).\nUsed iq's Ray-Capped-Cone intersection as scene template.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["intersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//\n// Intersection of a ray and a capped cone oriented in an arbitrary direction\n//\n//\n// Other cone functions:\n//\n// Cone bbox:         https://www.shadertoy.com/view/WdjSRK\n// Cone distance:     https://www.shadertoy.com/view/tsSXzK\n// Cone intersection: https://www.shadertoy.com/view/llcfRf\n//\n//\n// Other intersectors: https://iquilezles.org/articles/intersectors\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n\n#define Real float\n#define Real3 vec3\n#define fabs abs\n#define INFINITY 3.402823e+38\n\n\n/**\n* Ray in 3-space\n*/\nstruct Ray3 {\n    Real3 origin, direction;\n} ;\n\n\n/**\n* Cone in 3-space.\n* The cone has vertex V, unit-length axis direction D, angle theta in (0,pi/2).\n* Also a height and cap position are defined along the axial ray.\n* The cone vertex is the ray origin and the cone axis direction is the\n* ray direction. The direction must be unit length. The angle must be\n* in (0,pi/2). The height must be in (0,+infinity), where +infinity is INFINITY.\n*/\nstruct Cone3 {\n    Ray3 ray;\n    Real angle;\n    Real height;\n    Real cap; // to cap the pointy end, set this to a value in (0,height)\n    Real3 heightNormal;\n    Real3 capNormal;\n};\n    \n/**\n* Line in 3-space\n*/\nstruct Line3 {\n    Real3 start;\n    Real3 end;\n};\n    \n/**\n*\n*/\nstruct Plane3 {\n    Real3 middle;\n    Real3 normal;\n};\n\n\n/*\n* Distance of p to plane with origin o and normalized normal n\n*/\nReal calcPointPlaneDistance(Real3 p, Real3 o, Real3 n) {\n    Real a = dot(o, n);\n    a -= dot(n, p);\n    a /= dot(n, n);\n    return fabs(a);\n}\n\n\n/*\n* An intersection routine for rays and planes\n*/\nReal intersectPlane(Real3 pos, Real3 dir, Real3 middle, Real3 normal) {\n    Real a = dot(dir, normal);\n    if (a > -1e-6) return -1.0; // facing away\n    Real b = dot(middle - pos, normal);\n    if (b > -1e-6) return -1.0; // behind plane\n    return b / a;\n}\n\n\n/**\n* Get point rotated 90 degrees around vector (counter-clockwise).\n* Basically application of rotation matrix with simplified sines and cosines.\n* https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n*/\nReal3 rotate90PointAroundVector(Real3 vector, Real3 point) {\n    Real3 u = normalize(vector);\n    return Real3(\n        point.x * (u.x*u.x) + point.y * (u.x*u.y-u.z) + point.z * (u.x*u.z+u.y),\n        point.x * (u.y*u.x+u.z) + point.y * (u.y*u.y) + point.z * (u.y*u.z-u.x),\n        point.x * (u.z*u.x-u.y) + point.y * (u.z*u.y+u.x) + point.z * (u.z*u.z));\n}\n\n\n/**\n* Get point on plane that minimizes distance to another point\n* http://immersivemath.com/ila/ch03_dotproduct/ch03.html#ex_dp_ortho_proj_onto_plane\n*/\nReal3 projectPointToPlane(Plane3 plane, Real3 point) {\n    Real3 v = point - plane.middle;\n    Real3 proj = (dot(v, plane.normal) / pow(length(plane.normal), 2.)) * plane.normal;\n    return v - proj;\n}\n\n/**\n* David Eberly, Geometric Tools, Redmond WA 98052\n* Copyright (c) 1998-2018\n* Distributed under the Boost Software License, Version 1.0.\n* http://www.boost.org/LICENSE_1_0.txt\n* http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt\n* File Version: 3.0.2 (2018/10/05)\n*\n*   type  intersect  valid data\n*   0     none       none\n*   1     point      parameter[0] = parameter[1], finite\n*                    point[0] = point[1]\n*   2     segment    parameter[0] < parameter[1], finite\n*                    point[0,1] valid\n*   3     ray        parameter[0] finite, parameter[1] maxReal\n*                    point[0] = rayOrigin, point[1] = lineDirection\n*   4     ray        parameter[0] -maxReal, parameter[1] finite\n*                    point[0] = rayOrigin, point[1] = -lineDirection\n*   5     line       parameter[0] -maxReal, parameter[1] maxReal,\n*                    point[0] = lineOrigin, point[1] = lineDirection\n* If the cone height h is finite, only types 0, 1, or 2 can occur.\n* https://www.geometrictools.com/Documentation/IntersectionLineCone.pdf\n*/\nReal intersectCone(Real3 lineOrigin, Real3 lineDirection, Cone3 cone, out Real3 outNormal) {\n    int type;\n    float parameter0;\n    float parameter1;\n    // The cone has vertex V, unit-length axis direction D, angle theta in\n    // (0,pi/2), and height h in (0,+infinity).  The line is P + t*U, where U\n    // is a unit-length direction vector.  Define g = cos(theta).  The cone\n    // is represented by\n    //   (X-V)^T * (D*D^T - g^2*I) * (X-V) = 0,  0 <= dot(D,X-V) <= h\n    // The first equation defines a double-sided cone.  The first inequality\n    // in the second equation limits this to a single-sided cone containing\n    // the ray V + s*D with s >= 0.  We will call this the 'positive cone'.\n    // The single-sided cone containing ray V + s * t with s <= 0 is called\n    // the 'negative cone'.  The double-sided cone is the union of the\n    // positive cone and negative cone.  The second inequality in the second\n    // equation limits the single-sided cone to the region bounded by the\n    // height.  Setting X(t) = P + t*U, the equations are\n    //   c2*t^2 + 2*c1*t + c0 = 0,  0 <= dot(D,U)*t + dot(D,P-V) <= h\n    // where\n    //   c2 = dot(D,U)^2 - g^2\n    //   c1 = dot(D,U)*dot(D,P-V) - g^2*dot(U,P-V)\n    //   c0 = dot(D,P-V)^2 - g^2*dot(P-V,P-V)\n    // The following code computes the t-interval that satisfies the quadratic\n    // equation subject to the linear inequality constraints.\n    \n    Real t;\n    \n    // Handle degenerate case, when there is no cone direction.\n    // We interpret the cone for our use case as an annulus in the xy plane.\n    // Cap and height are interpreted as inner and outer radii of the annulus.\n    if (cone.ray.direction.x==0.0&&cone.ray.direction.y==0.0&&cone.ray.direction.z==0.0) {\n        Real3 normal = normalize(Real3(0,0,-sign(lineDirection.z)));\n        t = intersectPlane(lineOrigin, lineDirection, cone.ray.origin, normal);\n        if (t > 0.0) {\n            Real3 p = lineOrigin + t * lineDirection;\n            Real r = length(p.xy - cone.ray.origin.xy);\n            if (r >= cone.cap && r <= cone.height) {\n                outNormal = normal;\n                return t;\n            }\n        }\n        return -1.0;\n    }\n\n    Real3 PmV = lineOrigin - cone.ray.origin;\n    Real DdU = dot(cone.ray.direction, lineDirection);\n    Real DdPmV = dot(cone.ray.direction, PmV);\n    Real UdPmV = dot(lineDirection, PmV);\n    Real PmVdPmV = dot(PmV, PmV);\n    Real cosAngle = cos(cone.angle);\n    Real cosAngleSqr = cosAngle * cosAngle;\n    Real c2 = DdU * DdU - cosAngleSqr;\n    Real c1 = DdU * DdPmV - cosAngleSqr * UdPmV;\n    Real c0 = DdPmV * DdPmV - cosAngleSqr * PmVdPmV;\n\n    if (c2 != Real(0))\n    {\n        Real discr = c1 * c1 - c0 * c2;\n        if (discr < Real(0))\n        {\n            // The quadratic has no real-valued roots.  The line does not\n            // intersect the double-sided cone.\n            type = 0;\n            return -1.0;\n        }\n        else if (discr > Real(0))\n        {\n            // The quadratic has two distinct real-valued roots.  However, one\n            // or both of them might intersect the negative cone.  We are\n            // interested only in those intersections with the positive cone.\n            Real root = sqrt(discr);\n            Real invC2 = (Real(1)) / c2;\n            bool found1 = false;\n            bool found2 = false;\n\n            t = (-c1 - root) * invC2;\n            if (DdU * t + DdPmV >= Real(0))\n            {\n                parameter0 = t;\n                found1 = true;\n            }\n\n            t = (-c1 + root) * invC2;\n            if (DdU * t + DdPmV >= Real(0))\n            {\n                if (!found1) parameter0 = t;\n                else parameter1 = t;\n                found2 = true;\n            }\n\n            if (found2)\n            {\n                // The line intersects the positive cone in two distinct\n                // points.\n                type = 2;\n                if (parameter0 > parameter1)\n                {\n                    Real tmp = parameter0;\n                    parameter0 = parameter1;\n                    parameter1 = tmp;\n                }\n            }\n            \n            else if (found1)\n            {\n                // The line intersects the positive cone in a single point and\n                // the negative cone in a single point.  We report only the\n                // intersection with the positive cone.\n                if (DdU > Real(0))\n                {\n                    // Line enters positive cone at t==parameter[0]\n                    // and keeps intersecting until t==INFINITY,\n                    // in case there is no cone height constraint.\n                    type = 3;\n                    parameter1 = INFINITY;\n                }\n                else\n                {\n                    // Line comes from t==-INFINITY and enters positive\n                    // cone at t==parameter[0] (assuming no height constraint).\n                    type = 4;\n                    parameter1 = parameter0;\n                    parameter0 = -INFINITY;\n                }\n            }\n            else\n            {\n                // The line intersects the negative cone in two distinct\n                // points, but we are interested only in the intersections\n                // with the positive cone.\n                type = 0;\n                return -1.0;\n            }\n        }\n        else  // discr == 0\n        {\n            // One repeated real root; the line is tangent to the double-sided\n            // cone at a single point.  Report only the point if it is on the\n            // positive cone.\n            t = -c1 / c2;\n            if (DdU * t + DdPmV >= Real(0))\n            {\n                type = 1;\n                parameter0 = t;\n                parameter1 = t;\n            }\n            else\n            {\n                type = 0;\n                return -1.0;\n            }\n        }\n    }\n    else if (c1 != Real(0))\n    {\n        // c2 = 0, c1 != 0; U is a direction vector on the cone boundary\n        t = -(Real(0.5))*c0 / c1;\n        if (DdU * t + DdPmV >= Real(0))\n        {\n            // The line intersects the positive cone and the ray of\n            // intersection is interior to the positive cone.\n            if (DdU > Real(0))\n            {\n                type = 3;\n                parameter0 = t;\n                parameter1 = INFINITY;\n            }\n            else\n            {\n                type = 4;\n                parameter0 = -INFINITY;\n                parameter1 = t;\n            }\n        }\n        else\n        {\n            // The line intersects the negative cone and the ray of\n            // intersection is interior to the positive cone.\n            type = 0;\n            return -1.0;\n        }\n    }\n    else if (c0 != Real(0))\n    {\n        // c2 = c1 = 0, c0 != 0.  Cross(D,U) is perpendicular to Cross(P-V,U)\n        type = 0;\n        return -1.0;\n    }\n    else\n    {\n        // c2 = c1 = c0 = 0; the line is on the cone boundary.\n        type = 5;\n        parameter0 = -INFINITY;\n        parameter1 = +INFINITY;\n    }\n\n    // Post processing for bounded cones (cap,height)\n    if (cone.height < INFINITY)\n    {\n        if (DdU != Real(0))\n        {\n            // Ignore intersections outside\n            if (type > 0) {\n                Real3 p0 = lineOrigin + parameter0 * lineDirection;\n                Real3 p1 = lineOrigin + parameter1 * lineDirection;\n                \n                Real3 capPoint = cone.ray.origin + cone.cap * cone.ray.direction;\n                Real3 heightPoint = cone.ray.origin + cone.height * cone.ray.direction;\n                \n                bool p0outsideCap = dot(cone.capNormal, p0 - capPoint) > 0.0;\n                bool p0outsideHeight = dot(cone.heightNormal, p0 - heightPoint) > 0.0;\n                \n                bool p1outsideCap = dot(cone.capNormal, p1 - capPoint) > 0.0;\n                bool p1outsideHeight = dot(cone.heightNormal, p1 - heightPoint) > 0.0;\n                \n                bool p0outside = p0outsideCap || p0outsideHeight;\n                bool p1outside = p1outsideCap || p1outsideHeight;\n                if (p0outside && p1outside) type = 0;\n                else if (p0outside) parameter0 = parameter1;\n                else if (p1outside) parameter1 = parameter0;\n            }\n        }\n        else if (type > 0)\n        {\n            if (DdPmV > cone.height || DdPmV < cone.cap)\n            {\n                type = 0;\n            }\n        }\n    }\n\n    if (type > 0) {\n        // Extract smallest path length to intersection\n        Real t = parameter0;\n\n        // Calc normal\n        Real3 p = lineOrigin + t*lineDirection;\n        Real3 grad = normalize(p - cone.ray.origin);\n        Real3 normal = normalize(cross(grad, cross(grad, cone.ray.direction)));\n        outNormal = normal;\n\n        // Return smallest path length to intersection\n        return t;\n    } else {\n        return -1.0;\n    }\n}\n\nvec3  A = vec3(-.5 ,0, 0);\nvec3  B = vec3(-.2, .3, 0);\nfloat Ra = 0.2;\nfloat Rb = 0.1;\nvec3 Na = vec3(-1, 0, 0);\nvec3 Nb = vec3(1, 0, 0);\n\nvec3  A2 = vec3(-.2, .3, 0);\nvec3  B2 = vec3(.4, .4, 0);\nfloat Ra2 = 0.1;\nfloat Rb2 = 0.2;\nvec3 Na2 = vec3(-1, 0, 0);\nvec3 Nb2 = vec3(1, 0, 0);\n\nvec4 iCappedConeDE( in vec3  ro, in vec3  rd, \n                  in vec3  pb, in vec3  pa, \n                  in float rb, in float ra, vec3 na, vec3 nb )\n{\n    if (rb < ra) {\n        float tmp = ra;\n        ra = rb;\n        rb = tmp;\n        vec3 tmp2 = pa;\n        pa = pb;\n        pb = tmp2;\n        vec3 tmp3 = na;\n        na = nb;\n        nb = tmp3;\n    }\n    \n    float slope = (rb - ra) / distance(pa, pb);\n    float pzero = -ra / slope;\n    vec3 coneDir = normalize(pb - pa);\n    vec3 coneOrigin = pa + pzero * coneDir;\n    float coneAngle = atan(slope);\n    float coneCap = distance(pa, coneOrigin);\n    float coneHeight = distance(pb, coneOrigin);\n    \n    vec3 normal;\n    float t = intersectCone(ro, rd, Cone3(Ray3(coneOrigin, coneDir), coneAngle, \n                                          coneHeight, coneCap, na, nb), normal);\n    return vec4(t, normal);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec4 iCappedConeIQ( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb, vec3 na, vec3 nb )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(rd,ba);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float m9 = dot(ob,ba); \n    \n    // caps\n    if( m1<0.0 )\n    {\n        if( dot2(oa*m2-rd*m1)<(ra*ra*m2*m2) ) // delayed division\n            return vec4(-m1/m2,-ba*inversesqrt(m0));\n    }\n    else if( m9>0.0 )\n    {\n        float t = -m9/m2;                     // NOT delayed division\n        if( dot2(ob+rd*t)<(rb*rb) )\n            return vec4(t,ba*inversesqrt(m0));\n    }\n    \n    // body\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    float k2 = m0*m0    - m2*m2*hy;\n    float k1 = m0*m0*m3 - m1*m2*hy + m0*ra*(rr*m2*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    float t = (-k1-sqrt(h))/k2;\n    float y = m1 + t*m2;\n    if( y<0.0 || y>m0 ) return vec4(-1.0); //no intersection\n    return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));\n}\n\n\n// 2D cross-section space\nvec2 project(vec3 p, vec3 radialDir, vec3 origin) {\n\tvec3 startPos = A, endPos = B;\n    vec3 tubeDir = normalize(endPos-startPos);\n    vec3 tmp = (p - origin);\n    return vec2(dot(tmp, tubeDir), dot(tmp, radialDir));\n}\n\nvec3 unproject(vec2 p, vec3 radialDir, vec3 origin) {\n\tvec3 startPos = A, endPos = B;\n    vec3 tubeDir = normalize(endPos-startPos);    \n    return origin + tubeDir * p.x + radialDir * p.y;\n}\n\nvec2 intersect(vec2 A, vec2 B, vec2 C, vec2 D) {\n    float x1 = A.x, y1 = A.y, x2 = B.x, y2 = B.y;\n    float x3 = C.x, y3 = C.y, x4 = D.x, y4 = D.y;\n    return vec2(\n        ((x1*y2-y1*x2)*(x3-x4) - (x1-x2)*(x3*y4-y3*x4)),\n        ((x1*y2-y1*x2)*(y3-y4) - (y1-y2)*(x3*y4-y3*x4)))\n        / ((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4));\n}\n\nvoid connect(vec3 nextPos, vec3 radialDir, vec3 nextRadialDir, float radius[2], float nextRadius, vec3 projOrigin,\n             out vec2 E, out vec2 F, out vec2 G, out vec2 H) {\n\tvec3 startPos = A, endPos = B;\n    vec2 A = project(startPos +radialDir*radius[0],      radialDir, projOrigin);\n    vec2 B = project(endPos   +radialDir*radius[1],      radialDir, projOrigin);\n    vec2 C = project(endPos   +nextRadialDir*radius[1],  radialDir, projOrigin);\n    vec2 D = project(nextPos  +nextRadialDir*nextRadius, radialDir, projOrigin);\n    vec2 A_ = project(startPos-radialDir*radius[0],      radialDir, projOrigin);\n    vec2 B_ = project(endPos  -radialDir*radius[1],      radialDir, projOrigin);\n    vec2 C_ = project(endPos  -nextRadialDir*radius[1],  radialDir, projOrigin);\n    vec2 D_ = project(nextPos -nextRadialDir*nextRadius, radialDir, projOrigin);\n    E = intersect(A,B,C,D);\n    F = intersect(A_,B_,C_,D_);\n    G = intersect(E,F,vec2(-1,0),vec2(1,0));\n    H = intersect(E,F,project(endPos,radialDir,projOrigin), project(nextPos,radialDir,projOrigin));\n}\n\nvec3 findOrthogonalVector(vec3 v) {\n    vec3 b = cross(v, vec3(0, 0, 1));\n    if (dot(b, b) < 0.01) {\n        b = cross(v, vec3(0, 1, 0));\n    }\n    return b;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 startPos = A, endPos = B;\n    vec3 nextPos = B2;\n    vec3 tubeDir = normalize(B-A);\n    vec3 radialDir = findOrthogonalVector(tubeDir);\n    vec3 nextTubeDir = normalize(nextPos-endPos);\n    vec3 nextRadialDir = normalize(cross(cross(nextTubeDir, radialDir), nextTubeDir));\n    float radius[2];\n    radius[0] = Ra;\n    radius[1] = Rb;\n    float nextRadius = Rb2;\n    vec3 radialDirCross = cross(tubeDir, radialDir);\n    vec3 nextRadialDirCross = cross(nextTubeDir, nextRadialDir);\n    \n    vec2 E, F, G, H;\n    connect(nextPos, radialDir, nextRadialDir, radius, nextRadius, endPos, E, F, G, H);\n    vec3 B_connected = unproject(G, radialDir, endPos);\n    vec3 A2_connected = unproject(H, radialDir, endPos);\n    vec3 planeVec1 = unproject(F, radialDir, endPos) - unproject(E, radialDir, endPos);\n    connect(nextPos, radialDirCross, nextRadialDirCross, radius, nextRadius, endPos, E, F, G, H);\n    vec3 planeVec2 = unproject(F, radialDirCross, endPos) - unproject(E, radialDirCross, endPos);\n    vec3 connectionNormal = cross(normalize(planeVec1), normalize(planeVec2));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        \n        // raytrace\n        //vec4 tnor = iCappedConeDE( ro, rd, A2, B2, Ra2, Rb2, Na2, Nb2 );\n        vec4 tnor = iCappedConeDE( ro, rd, A2_connected, B2, Ra2, Rb2, -connectionNormal, Nb2 );\n        //vec4 tnor = iCappedConeIQ( ro, rd, A, B, Ra, Rb, Na, Nb );\n\n        float t = tnor.x;\n    \n        // shading/lighting\t\n        vec3 lightsource = vec3(1,0,0);\n        vec3 col = vec3(0.0);\n        if( t>0.0 )\n        {\n                col = vec3(clamp(dot(tnor.yzw, lightsource), 0., 1.)) + vec3(.05);\n        }\n        \n        // raytrace 2\n        //tnor = iCappedConeDE( ro, rd, A, B, Ra, Rb, Na, Nb );\n        tnor = iCappedConeDE( ro, rd, A, B_connected, Ra, Rb, Na, connectionNormal );\n        \n        if (tnor.x < t || t < 0.0) {\n            t = tnor.x;\n\n            // shading/lighting\t 2\n            if( t>0.0 )\n            {\n                col = vec3(clamp(dot(tnor.yzw, lightsource), 0., 1.)) + vec3(.05);\n            }\n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}