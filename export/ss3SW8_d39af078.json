{"ver":"0.1","info":{"id":"ss3SW8","date":"1633702393","viewed":147,"name":"Depth Mips","username":"spalmer","description":"WIP experimenting with basic cone tracing depth lods in a way that hopefully will accelerate overall ray marching significantly.\nbe sure to try the different visualization mode options in #if in Image!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cone","lod","mip","depth","march","trace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// FIXME there's obviously some error with the low-LOD depth encoding/decoding\n// resulting in need for huge error bias in Common tab depth fn\n// but it's better than when I first public'd this toy because\n// at first it wasn't actually using the low-LOD depths AT ALL\n// due to stupid human programmer.  DOH!  ;)\n\n#define T(ch, p) (1. - texelFetch(ch, ivec2(p), 0))\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    o = vec4(0,.0,0,1);\n  #if 0 \n    // you can see even in fullscreen that this is still plenty efficient\n    // just top, highest detail layer, tune fog visually\n    o = vec4(depth(iChannel3, r, iTime, iFrame, p, 0, .5, .9));\n  #elif 1\n    // reverse order blends better\n    o = mix(o, T(iChannel0, p*exp2(-4.)) * vec4(1,1,1,1), .7);\n    o = mix(o, T(iChannel1, p*exp2(-3.)) * vec4(0,0,1,1), .4);\n    o = mix(o, T(iChannel2, p*exp2(-2.)) * vec4(0,1,0,1), .4);\n    o = mix(o, T(iChannel3, p*exp2(-1.)) * vec4(1,0,0,1), .4);\n    o = mix(o, vec4(depth(iChannel3, r, iTime, iFrame, p, 0, .5, .5)), .4);\n  #elif 1\n    // all on top one another\n    o = vec4(depth(iChannel3, r, iTime, iFrame, p, 0, .5, .5)) * .7;\n    o = mix(o, T(iChannel3, p*exp2(-1.)) * vec4(1,0,0,1), .4);\n    o = mix(o, T(iChannel2, p*exp2(-2.)) * vec4(0,1,0,1), .4);\n    o = mix(o, T(iChannel1, p*exp2(-3.)) * vec4(0,0,1,1), .4);\n    o = mix(o, T(iChannel0, p*exp2(-4.)) * vec4(1,1,1,1), .1);\n  #elif 0\n    // FIXME now doesn't compile anymore?!\n    // separate mip overlays in lower-left\n    int lod = min(4,int(floor(log2(min(r.x/p.x, r.y/p.y))+0.)));\n    switch (lod) {\n      case 0:\n        o = vec4(depth(iChannel3, r, iTime, iFrame, p, 0, .5, .5));\n        break;\n      case 1:\n        o = T(iChannel3, p) * vec4(1,0,0,1);\n        break;\n      case 2:\n        o = T(iChannel2, p) * vec4(0,1,0,1);\n        break;\n      case 3:\n        o = T(iChannel1, p) * vec4(0,0,1,1);\n        break;\n      case 4:\n        o = T(iChannel0, p);\n        break;\n    }\n  #endif\n}\n\n// FIXME there's something wrong with a fg pillar at top right of screen","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// experiment in depth cone tracing lod mipmaps\n// the idea is to move the brunt of the looping\n// into the low-resolution lods, saving total work.\n\n// HOWEVER after trying it, I found that simply doing one\n// smaller depth buffer with 8x8 tiles of the main image\n// is sufficient to give huge wins and costs less.\n// Gets as much wins or may be even more efficient than this.\n// Oh well, this was a good idea though!\n\n// thanks blackle!  https://shadertoy.com/view/WtByzV\nfloat dScene(vec3 q)\n{\n    return min(.5 - abs(q.y), length(.5 - fract(q.xz)) - .1);\n}\n\n// sa = blah blah something about sine of angle // sqrt(max(0., 1.-ca*ca)), \nfloat march(vec3 o, vec3 d, float t, float e, float sa, int iter)\n{\n    float h = 9e9;\n    for (int i = iter; i-- > 0 && t < e && abs(h) > t * sa; ) {\n        h = dScene(t * d + o);\n        t += .9 * h;\n    }\n    return t;\n}\n// TODO for debugging I want to count how many total iterations (in all contributing LODs)\n// went to computing this pixel, so can get an idea of work saved by lods.\n\nfloat depth(sampler2D inch, vec2 r, float time, int frame, vec2 p, int lod, float gi, float go)\n{\n    vec2 rl = ceil(r / float(1<<lod)); //* exp2(float(-lod))); // \n    if (any(lessThan(rl, p))) { discard; return 0.; }\n    vec2 q = (2. * p - rl) / rl.y;\n    vec3 o = vec3(0,0,.3*sin(.1*time))\n    , d = normalize(vec3(q, 2.));\n    float t = 0.;\n    // first frame will just be slow\n    if (gi > 0. && frame > 0)\n        t = pow(1.-texelFetch(inch, ivec2(p / float(2<<lod)), 0).x, -1./gi)\n            * .3 // be a little conservative - wtf is wrong?!?!\n            ;\n    float pixelsin = 1.2/rl.y; // use size of pixel at this lod\n    int izero = min(frame, 0);\n    t = march(o, d, t, 1e2, pixelsin, 100 + izero);\n    return pow(t, -go);\n}\n// handles input/output gamma; what's good for buffer \n// encoding isn't good for viewing, visualizing depths\n// minus signs on gamma exponents give inverted \"fog\" look in buffers\n// without which you'd need to handle infinite range.\n\n#define LOD(ch, lod, gi, go) \\\nvoid mainImage(out vec4 o, vec2 p) \\\n{ \\\n    o = vec4(1.-depth(ch, iResolution.xy, iTime, iFrame, p, lod, gi, go)); \\\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"LOD(iChannel0,4, 0., .5)","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"LOD(iChannel0, 3, .5, .5)","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"LOD(iChannel1, 2, .5, .5)","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"LOD(iChannel2, 1, .5, .5)","name":"Buffer D","description":"","type":"buffer"}]}