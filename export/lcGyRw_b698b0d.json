{"ver":"0.1","info":{"id":"lcGyRw","date":"1731686528","viewed":43,"name":"Bicubic Filter Comparison (WIP)","username":"kenhu","description":"bicubic texture filteirng","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["texture","filtering","bicubic"],"hasliked":0,"parentid":"4df3Dn","parentname":"bicubic"},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Forked from https://www.shadertoy.com/view/4df3Dn\n\n// MODE_BICUBIC_BSPLINE_BILINEAR\n//   4x4 bicubic filter using 4 bilinear texture lookups\n//   See GPU Gems 2: \"Fast Third-Order Texture Filtering\", Sigg & Hadwiger:\n//   http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter20.html\n\n// MODE_BICUBIC_BSPLINE_BILINEAR_TSUSHIMA\n//   h0, h1 approximation\n//   Real-Time Samurai Cinema: Lighting, Atmosphere, and Tonemapping in Ghost of Tsushima\n//   https://youtu.be/GOee6lcEbWg?si=74BM1Bch3HNp3ko1&t=2242\n//   https://advances.realtimerendering.com/s2021/jpatry_advances2021/index.html#/111/0/2\n//   https://www.desmos.com/calculator/udlencsh7k\n\n// w0, w1, w2, and w3 are the four cubic B-spline basis functions\nfloat w0(float a)\n{\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nfloat w1(float a)\n{\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nfloat w2(float a)\n{\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nfloat w3(float a)\n{\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 and g1 are the two amplitude functions\nfloat g0(float a)\n{\n    return w0(a) + w1(a);\n}\n\nfloat g1(float a)\n{\n    return w2(a) + w3(a);\n}\n\n// h0 and h1 are the two offset functions\nfloat h0(float a)\n{\n    float h0_standard = w1(a) / (w0(a) + w1(a));     // offset from first point\n    float center_to_first_point = -1.5;\n    return center_to_first_point + h0_standard;\n}\n\nfloat h1(float a)\n{\n    float h1_standard = w3(a) / (w2(a) + w3(a));     // offset from third point\n    float center_to_third_point = 0.5;\n    return center_to_third_point + h1_standard;\n}\n\nfloat h0_tsushima(float a)\n{\n    float h0_approx = 0.2 + a * (0.24 * a + 0.56);   // https://www.desmos.com/calculator/tverpeanps\n    float h0_standard = 1.0 - h0_approx + a;         // offset from first point\n    float center_to_first_point = -1.5;\n    return h0_standard + center_to_first_point;\n}\n\nfloat h1_tsushima(float a)\n{\n    float h1_approx = 1.0 + a * (0.24 * a - 1.04);   // https://www.desmos.com/calculator/tverpeanps\n    float h1_standard = h1_approx + a - 1.0;         // offset from third point\n    float center_to_third_point = 0.5;\n    return h1_standard + center_to_third_point;\n}\n\nvec4 texture_bicubic(sampler2D tex, vec2 uv, vec4 texelSize, bool useTsushimaApprox)\n{\n\tuv = uv * texelSize.zw + 0.5;\n\tvec2 iuv = floor(uv);                            // center of 4 points\n\tvec2 fuv = fract(uv);                            // fraction from second point\n\n    // calculate amplitude and offset\n    float g0x = g0(fuv.x);\n    float g1x = g1(fuv.x);\n    float h0x = useTsushimaApprox ? h0_tsushima(fuv.x) : h0(fuv.x);\n    float h1x = useTsushimaApprox ? h1_tsushima(fuv.x) : h1(fuv.x);\n    float h0y = useTsushimaApprox ? h0_tsushima(fuv.y) : h0(fuv.y);\n    float h1y = useTsushimaApprox ? h1_tsushima(fuv.y) : h1(fuv.y);\n\n    // h and g are adjusted to offset from center\n\tvec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y)) * texelSize.xy;\n\tvec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y)) * texelSize.xy;\n\tvec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y)) * texelSize.xy;\n\tvec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y)) * texelSize.xy;\n\t\n    return g0(fuv.y) * (g0x * texture(tex, p0)  +\n                        g1x * texture(tex, p1)) +\n           g1(fuv.y) * (g0x * texture(tex, p2)  +\n                        g1x * texture(tex, p3));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col    = vec3(0.0);\n    vec2 p      = fragCoord.xy / iResolution.xy;    \n    \n    uvec4 state = floatBitsToUint(texelFetch(iChannel1, ivec2(0, 0), 0));\n    uint mode   = fragCoord.x < iMouse.x ? state.x : state.y;\n    \n    vec4 offset = texelFetch(iChannel1, ivec2(1, 0), 0);\n    \n    vec2 uv = p / float(state.z) + offset.xy;\n    vec4 texelSize = vec4( 1.0 / iChannelResolution[0].xy,  iChannelResolution[0].xy);\n    \n    switch(mode)\n    {\n        case MODE_BILINEAR:\n            col = texture(iChannel0, uv).xyz;\n            break;\n        case MODE_BICUBIC_BSPLINE_BILINEAR:\n            col = texture_bicubic(iChannel0, uv, texelSize, false).xyz;\n            break;\n        case MODE_BICUBIC_BSPLINE_BILINEAR_TSUSHIMA:\n            col = texture_bicubic(iChannel0, uv, texelSize, true).xyz;\n            break;\n        default:\n            break;\n    }\n    \n    fragColor = vec4(col, 1.0);\n    \n    // Debug    \n    if (fragCoord.y < 64.)\n    {\n        fragColor = mix(fragColor, vec4(1), PrintValue(fragCoord, vec2(0,10), vec2(16,30), float(state.x), 3., 0.));\n        fragColor = mix(fragColor, vec4(1), PrintValue(fragCoord, vec2(iResolution.x - 96.0,10), vec2(16,30), float(state.y), 3., 0.));\n        fragColor = mix(fragColor, vec4(1), PrintValue(fragCoord, vec2(iResolution.x / 2.0 - 48.0,10), vec2(16,30), float(state.z), 3., 0.));\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// State from keyboard/mouse input\n// Keycode Viewer https://www.shadertoy.com/view/4tt3Wn\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n    {\n        uvec4 state = floatBitsToUint(texelFetch(iChannel0, ivec2(0, 0), 0));\n        \n        if (iFrame == 0)\n        {\n            state.x = MODE_BILINEAR;\n            state.y = MODE_BICUBIC_BSPLINE_BILINEAR_TSUSHIMA;\n            state.z = 1u;\n        }\n\n        const int KEY_0     = 48;\n        const int KEY_SHIFT = 16;\n        const int KEY_W     = 87;\n        const int KEY_D     = 83;\n        \n        bool shift = texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0).r > 0.0;\n        bool w     = texelFetch(iChannel1, ivec2(KEY_W,     1), 0).r > 0.0;\n        bool d     = texelFetch(iChannel1, ivec2(KEY_D,     1), 0).r > 0.0;\n        \n        if (w) state.z *= 2u;\n        if (d) state.z /= 2u;\n        state.z = max(state.z, 1u);\n        \n        for (uint i = 0u; i <= 9u; i++)\n            if (texelFetch(iChannel1, ivec2(KEY_0 + int(i), 0), 0).r > 0.0)\n                if (shift)\n                    state.y = i;\n                else\n                    state.x = i;\n                    \n        fragColor = vec4(uintBitsToFloat(state));\n    }\n    else if (int(fragCoord.x) == 1 && int(fragCoord.y) == 0)\n    {\n        vec4 state = texelFetch(iChannel0, ivec2(1, 0), 0);\n        \n        if (iFrame == 0)\n        {\n            state = vec4(0.0);\n        }\n        \n        const int KEY_LEFT  = 37;\n        const int KEY_UP    = 38;\n        const int KEY_RIGHT = 39;\n        const int KEY_DOWN  = 40;\n        \n        float speed = 0.01;\n        \n        if (texelFetch(iChannel1, ivec2(KEY_LEFT,     1), 0).r > 0.0) state.x -= speed;\n        if (texelFetch(iChannel1, ivec2(KEY_UP,       1), 0).r > 0.0) state.y += speed;\n        if (texelFetch(iChannel1, ivec2(KEY_RIGHT,    1), 0).r > 0.0) state.x += speed;\n        if (texelFetch(iChannel1, ivec2(KEY_DOWN,     1), 0).r > 0.0) state.y -= speed;\n        \n        fragColor = state;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst uint MODE_INVALID = 0u;\nconst uint MODE_BILINEAR = 1u;\nconst uint MODE_BICUBIC_BSPLINE_BILINEAR = 2u;\nconst uint MODE_BICUBIC_BSPLINE_BILINEAR_TSUSHIMA = 3u;\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n","name":"Common","description":"","type":"common"}]}