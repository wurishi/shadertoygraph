{"ver":"0.1","info":{"id":"DljXDc","date":"1676708694","viewed":78,"name":"Super Simple Ray Tracer","username":"MN8R","description":"just a simple 3d program","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel and mouse coordinates (from 0 to 1)\n    vec2 pxl = fragCoord / iResolution.xy - 0.5;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    pxl.x *= iResolution.x / iResolution.y;\n\n    // Variables\n    vec3 pos = vec3(0.0, 0.0, 4.0);\n    float FOV = PI / 2.0;\n    float ha = TWO_PI * (mouse.x - 0.5);\n    float va = PI * (mouse.y - 0.5);\n\n    // Find raycast direction from pixel\n    Direction dir = projectPixel(ha, va, pxl.x, pxl.y, FOV);\n\n    // Cast ray to floor\n    vec3 pt = intersectingRayFloor(pos, dir.va, dir.ha);\n    float tx = fmod(pt.x, 3.0);\n    float ty = fmod(pt.y, 3.0);\n    \n    // Calculate texture\n    float v = 0.0;\n    \n    // If intercept exist, texture it\n    if (pt.z > 0.0) v = xor((tx > 1.5), (ty > 1.5)) ? 0.0 : 1.0;\n\n    // Shade by distance\n    v *= 20.0 / (pt.z * pt.z + 1.0);\n\n    // Color of pixel\n    vec3 col = vec3(v, v, v);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265358\n#define TWO_PI PI * 2.0\n\nstruct Direction {\n  vec3 ray;\n  float ha;\n  float va;\n};\n\nfloat fmod(float x, float y) {\n    return x - y * floor(x / y);\n}\n\nbool xor(bool a, bool b) {\n  return (a && !b) || (!a && b);\n}\n\nvec2 vec3ToAngles(vec3 vector) {\n  vec2 angles;\n  angles.x = atan(vector.y / vector.x);\n  angles.y = asin(vector.z);\n  return angles;\n}\n\nvec3 intersectingRayFloor(vec3 initialPosition, float verticalAngle, float horizontalAngle) {\n    verticalAngle += PI/2.0;\n    float t = initialPosition.z / cos(verticalAngle);\n    float d = initialPosition.z * tan(verticalAngle);\n    float x = cos(horizontalAngle) * d + initialPosition.x;\n    float y = sin(horizontalAngle) * d + initialPosition.y;\n    vec3 pt = vec3( x, y, t );\n    return pt;\n}\n\nDirection projectPixel(float ha, float va, float x, float y, float FOV) {\n\n  float HFOV = FOV;\n  float VFOV = FOV;\n\n  // Z Rotation Matrix\n  float sin0 = sin(-ha);\n  float cos0 = cos(-ha);\n  mat3 matrixRotateZ = mat3(\n    vec3(cos0, -sin0, 0.0),\n    vec3(sin0, cos0, 0.0),\n    vec3(0.0, 0.0, 1.0)\n  );\n  \n  // Y Rotation Matrix\n  sin0 = sin(va);\n  cos0 = cos(va);\n  mat3 matrixRotateY = mat3(\n    vec3(cos0, 0.0, sin0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(-sin0, 0.0, cos0)\n  );\n\n  // Cast Ray\n  const float near = 0.7;\n  vec3 ray = normalize(vec3(near, x * HFOV, y * VFOV));\n\n  // Rotate vectors\n  ray = matrixRotateY * ray;\n  ray = matrixRotateZ * ray;\n    \n  // Convert to angles\n  vec2 rot = vec3ToAngles(ray);\n\n  return Direction(ray, rot.x, rot.y);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}