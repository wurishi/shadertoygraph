{"ver":"0.1","info":{"id":"3sy3Dm","date":"1570396597","viewed":201,"name":"Hex or square undicisive","username":"BagelOrb","description":"Distance measure based on closest point in two grids which are moving wrt each other.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["grid","hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415\n\nfloat move(float i) {\n    float s = sin(i);\n    float sgn = (s > 0.)? 1. : -1.;\n    s = min(1., 1.1* abs(s));\n    return .99*pow(abs(s), 11.) * sgn;\n}\n\nvec3 coords(vec2 uv)\n{\n    float s3 = 1.73205080757;\n    \n    float t = iTime * .4;\n    vec2 v = vec2(move(t), move(t + .3 * pi));\n    v *= .5 * vec2(s3, 1.);\n    \n    vec2 r = vec2(s3,1.);\n    vec2 h = .5*r;\n    vec2 a = mod(uv + v, r) - h;\n    vec2 b = mod(uv -h, r) - h;\n    \n    vec3 ret;\n    vec2 l = (length(a) < length(b))? a : b;\n    \n    float d = length(a) + length(b);\n    for (float dir = -1.; dir <= 1.; dir += 2. )\n    {\n        for (int i = 0 ; i <= 1; i++)\n        {\n            vec2 rr = r;\n\t\t\trr[i] = 0.;\n            vec2 ab = a;\n            for (int j = 0 ; j <= 1 ; j++)\n            {\n                float here = length(ab) + length(dir * rr - ab);\n                d = min(d, here);\n                ab = b;\n            }\n        }\n    }\n    \n\n    ret.yz = vec2(0, d *.5 - length(l)) * d / length(l);\n    \n    vec2 id = floor((uv - l) / r + vec2(200));\n    ret.x = id.x * 3. + id.y * 5.;\n    if (length(a) < length(b)) ret.x += 200.;\n    ret.x = 500. * sin(ret.x * 700.);\n    \n    \n    return ret;\n}\n\nfloat rnd(float f, float n) {\n    float d = 1.0;\n    \n    float r = f / n;\n    float b = floor(r);\n    float p = smoothstep(b+.5 - d / 2., b+.5 + d / 2., r) + b;\n    return p * n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pix = 20.;\n    //fragCoord = vec2(rnd(fragCoord.x, pix), rnd(fragCoord.y, pix));\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    uv *= 5.;\n    \n    vec3 cs = coords(uv);\n    \n    fragColor.rg = cs.yz;\n    float tt = iTime * .5;\n    fragColor.rgb = .6 + .4 * vec3(sin(cs.x*300. + tt), sin(cs.x*700. + 123. + tt), sin(cs.x*700. + 123.4 + tt));\n    fragColor.rgb /= length(fragColor.rgb);\n    fragColor.rgb *= 1.5;\n    fragColor.r = min(1., fragColor.r);\n    fragColor.g = min(1., fragColor.g);\n    fragColor.b = min(1., fragColor.b);\n    fragColor.rgb *= 1. + .5 * pow(.5 + .5 * sin(245.*cs.x + sin(iTime) / sin(iTime)  * 14. * ( sin(iTime * .1) ) ), 3.);\n    //fragColor.rg = sin(cs.xy) *.2 + .5;\n    \n    \n    fragColor.rgb -= 2. * smoothstep(.05, 0., vec3(1) * length(cs.yz) * (0. + pow(.3 + .3 * sin(cs.x + iTime * .5), 3. * (.5 + .5 * sin(iTime*.3)) )));\n}","name":"Image","description":"","type":"image"}]}