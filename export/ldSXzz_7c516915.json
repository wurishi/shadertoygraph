{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//\n// Scene variables\n//\n\n#define NUM_SPHERES 4\n#define MAX_BOUNCES 3\n#define NUM_LIGHTS  1\n#define DRAW_ROOM\n#define DRAW_SPHERES\n\nvec2 mouse;\nvec2 uv;\nfloat hit = 0.0;\n\n//\n// Scene constants\n//\n\n#define NUM_PLANES 5\n#define PI 3.14159265358979323846264\n#define INFINITY 1e32\n#define EPSILON  1e-3\n\nvec3 ambLight = vec3(0.2);\n\n\n//\n// Material struct\n//\n\nstruct mat_t\n{\n    vec3 ka;  // ambient color\n\tvec3 kd;  // diffuse color\n    vec3 ks;  // specular color\n    float ns; // specular exponent (shininess)\n} mats;\n\n//\n// Ray struct\n//\n\nstruct ray_t\n{\n\tvec3 o; // origin\n    vec3 d; // direction\n} ray;\n\n\n//\n// Point light struct\n//\n\nstruct pLight_t\n{\n\tvec3 pos; // position of the light\n    vec3 col; // color (intensity) of the light\n} lights[ NUM_LIGHTS ];\n\n//\n// Intersection struct\n//\n\nstruct intersection_t\n{\n    mat_t mat;   // material at intersection point\n    vec3 hitpt;  // position in world space\n    vec3 iray;   // incoming ray direction\n    vec3 normal; // normal vector\n\tfloat t;     // direction along iray from ray origin\n} ist;\n\nvec3 intersection_shade( intersection_t hit )\n{\n\tvec3 endCol = vec3(0);\n\n    // Ambient\n    endCol += hit.mat.ka * ambLight;\n    \n    for( int i = 0; i < NUM_LIGHTS; i++ )\n    {\n        // Diffuse\n        vec3 l = normalize( lights[ i ].pos - hit.hitpt );\n        vec3 n = hit.normal;\n    \tendCol += hit.mat.kd * max( dot( n, l ), 0.0 ) * lights[ i ].col;\n        \n        // Specular\n        vec3 r = reflect( -l, n);\n    \tvec3 v = -hit.iray;\n    \tfloat s =  pow( max( dot( r, v ), 0.0) , hit.mat.ns );\n    \tendCol += hit.mat.ks * s * lights[ i ].col;\n    }\n    \n    return endCol;\n}\n\n//\n// Plane struct\n//\n\nstruct plane_t\n{\n    mat_t mat;   // material\n    vec3 center; // location\n\tvec3 normal; // normal defining plane\n    vec3 up;     // up vector defining orientation\n    vec2 dims;   // dimensions along up and normal x up\n\n} planes[ NUM_PLANES ];\n\nintersection_t plane_intersect( plane_t p, ray_t r)\n{\n\tintersection_t ist;\n    ist.t = INFINITY;\n    \n    float t = dot( ( p.center - r.o ), p.normal ) / dot( r.d, p.normal );\n    if( t < 0.0 ) { return ist; }\n    \n    vec3 pt = (r.d * t) + r.o;\n    vec3 rad = pt - p.center;\n    if( ( abs( dot( rad, p.up ) ) < p.dims.y ) && ( abs( dot( rad, cross( p.up, p.normal ) ) ) < p.dims.x ) )\n    {\n    \tist.t = t;\n        ist.iray = r.d;\n        ist.hitpt = pt;\n        ist.normal = p.normal;\n        ist.mat = p.mat;\n    }\n    \n    return ist;\n}\n\n//\n// Sphere struct\n//\n\nstruct sphere_t\n{\n    mat_t mat;\n\tvec3 pos;\n    float r;\n} spheres[ NUM_SPHERES ];\n\nintersection_t sphere_intersect( sphere_t s, ray_t r )\n{\n    intersection_t intersection;\n    \n    float a = dot( r.d, r.d );\n    float b  = 2.0 * dot( r.o - s.pos, r.d );\n    float c  = - (s.r * s.r) + dot( r.o  - s.pos, r.o - s.pos );\n    float d  = b*b - 4.0*a*c;\n    if( d < 0.0 ) { ist.t = INFINITY; return ist; }\n    ist.t = ( - b - sqrt( d ) ) / (2.0 * a);\n    if( ist.t < 0.0 ) { ist.t = INFINITY; return ist; }\n    ist.iray = r.d;\n    ist.hitpt = (r.d * ist.t) + r.o;\n    ist.normal = normalize( ist.hitpt - s.pos );\n    ist.mat = s.mat;\n    \n    return ist;\n}\n\n//\n// Camera struct\n//\n\nstruct camera_t\n{\n\tvec3 pos;\n    \n} cam;\n\nray_t camera_getRay( camera_t c, vec2 uv )\n{\n    ray_t ray;\n    ray.o = c.pos;\n    \n    // Rotate camera according to mouse position\n    float ca = cos(mouse.x), sa = sin(mouse.x);\n    mat3 rotX = mat3(ca, 0.0, sa, 0.0, 1.0, 0.0, -sa, 0.0, ca);\n    ca = cos(mouse.y), sa = sin(mouse.y);\n    mat3 rotY = mat3(1.0, 0.0, 0.0, 0.0, ca, -sa, 0.0, sa, ca);\n    mat3 rotM = rotX * rotY;\n    \n\tray.o = rotM*c.pos;\n    ray.d = rotM*normalize( vec3( uv, -1.0 ) ); // should be -1! facing into scene\n    \n\treturn ray;\n}\n\n//\n// Scene functions\n//\n\nvoid init_scene( void )\n{\n    // Initialize lights\n    float w = float(NUM_LIGHTS)*8.0;\n    float lr = w*0.5;\n    for( int i = 0; i < NUM_LIGHTS; i++)\n    {\n    \tlights[ i ].pos = vec3( -lr + w*float( i + 1 ) / float( NUM_LIGHTS + 1 ), 2, 3 );\n        lights[ i ].col = vec3( 0.8 );\n    }\n    \n    // Initialize camera\n    cam.pos = vec3( 0.0, 0.0, 3.9 );\n\n    // Initialize spheres\n    float t = iTime * 0.5;\n#ifdef DRAW_SPHERES\n    for(int i = 0; i < NUM_SPHERES; i++)\n    {\n        float ifrc = float(i)/float(NUM_SPHERES)*2.0*PI;\n        float r = 1.0;\n        spheres[ i ].r = r;\n        r *= 2.0;\n        float ipi = float( i ) * 2.0 * PI / float( NUM_SPHERES );\n        spheres[ i ].pos = vec3( r * sin( ipi + t ), r * cos( ipi + t ), -0.0 );\n        spheres[ i ].mat.kd = vec3( 0.4 ) + 0.4 * vec3( sin(ifrc + t), sin(ifrc + t + 2.0*PI/3.0), sin(ifrc + t + 2.0*2.0*PI/3.0));      \n        spheres[ i ].mat.ka = spheres[ i ].mat.kd;\n        spheres[ i ].mat.ks = vec3(0.7);\n        spheres[ i ].mat.ns = 128.0;\n    }\n#endif\n#ifdef DRAW_ROOM\n    float br = 4.0;\n    for( int i = 0; i < NUM_PLANES; i++)\n    {\n        float fiPI = float(i)*0.5*PI;\n        planes[ i ].center = vec3(cos(fiPI)*br,0,-sin(fiPI)*br);\n        planes[ i ].normal = -normalize( planes[ i ].center );\n        planes[ i ].up     = vec3(0,1,0);\n        planes[ i ].dims   = vec2(br);\n        planes[ i ].mat.ka = vec3(0.1);\n\t    planes[ i ].mat.ks = vec3(0.3);\n    \tplanes[ i ].mat.ns = 128.0;\n\n    }\n    planes[ 3 ].center = vec3(0,br-EPSILON,0);\n    planes[ 3 ].normal = vec3(0,-1,0);\n    planes[ 3 ].up     = vec3(0,0,1);\n    planes[ 3 ].dims   = vec2(br);\n    planes[ 3 ].mat.ka = vec3(0.1);\n    planes[ 3 ].mat.ks = vec3(0.0);\n    planes[ 3 ].mat.ns = 128.0;\n    planes[ 4 ].center = vec3(0,-br+EPSILON,0);\n    planes[ 4 ].normal = vec3(0,1,0);\n    planes[ 4 ].up     = vec3(0,0,1);\n    planes[ 4 ].dims   = vec2(br);\n    planes[ 4 ].mat.ka = vec3(0.1);\n    planes[ 4 ].mat.ks = vec3(0.0);\n    planes[ 4 ].mat.ns = 128.0;\n    planes[ 0 ].mat.kd = vec3(0.9,0.1,0.1);\n    planes[ 1 ].mat.kd = vec3(0.8,0.8,0.8);\n    planes[ 2 ].mat.kd = vec3(0.1,0.9,0.1);\n    planes[ 3 ].mat.kd = vec3(0.8,0.8,0.8);\n    planes[ 4 ].mat.kd = vec3(0.8,0.8,0.8);\n#endif\n}\n\nvec3 intersect_scene( ray_t ray )\n{\n    vec3 endCol = vec3(0);\n    vec3 specMod = vec3(1);\n    intersection_t bestI;\n    intersection_t ht;\n    ray_t r = ray;\n    for( int j = 0; j < MAX_BOUNCES; j++)\n    {\n        bestI.t = INFINITY;\n        // Intersect geometry, finding closest point\n#ifdef DRAW_SPHERES\n        for(int i = 0; i < NUM_SPHERES; i++)\n        {\n            ht = sphere_intersect( spheres[ i ], r );\n            if( ht.t < bestI.t ) { bestI = ht; }\n        }\n#endif\n#ifdef DRAW_ROOM\n        for( int i = 0; i < NUM_PLANES; i++)\n        {\n            ht = plane_intersect( planes[ i ], r );\n            if( ht.t < bestI.t ) { bestI = ht; }\n        }\n#endif\n        // Quit if we don't hit anything\n        if( bestI.t == INFINITY ) { break; }\n     \thit = 1.0;\n        \n        // Shade\n        endCol += specMod*intersection_shade( bestI );\n        specMod *= bestI.mat.ks; // Keep track of specular intensity of each reflection\n        \n        // Reflect ray about normal\n        r.o = bestI.hitpt + bestI.normal * EPSILON;\n        r.d = reflect( r.d, bestI.normal );        \n    }\n    \n    return endCol;\n}\n\n//\n// Main loop\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get screen coordinate\n\tuv = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n    uv.x *= (iResolution.x/iResolution.y);\n    mouse = -1.0 + 2.0 * ( iMouse.xy / iResolution.xy );\n    mouse *= 2.0*PI;\n    \n    // Initialize scene\n    init_scene();\n    \n    // Intersect scene\n    ray_t ray = camera_getRay( cam, uv );\n    vec3 col = intersect_scene( ray );\n    \n    // Add background\n    col = hit*col + (1.0-hit)*(1.0-0.2*length(uv))*vec3(1,1,0);\n    fragColor = vec4( col, 1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldSXzz","date":"1412198131","viewed":519,"name":"Verbose Raytracer","username":"GraphicsMuncher","description":"Basic analytical raytracer.\n\nThe code is purposefully unoptimized and not very GPU-friendly. My hope is that someone can start at main() and read through each function step by step.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","basic","tutorial","readable"],"hasliked":0,"parentid":"","parentname":""}}