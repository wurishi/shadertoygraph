{"ver":"0.1","info":{"id":"WtGSDK","date":"1583550054","viewed":93,"name":"Path Tracer (First Attempt)","username":"kbjwes77","description":"My first attempt at stitching some pieces of path tracers together to get a working demo\n\nFixed gamma correction (thx @spalmer)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sphere","tracer","first","path","attempt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// constants\nconst float PI = 3.14159;\nconst float GR = 1.61803;\nconst float E  = 2.71828;\nconst float GAMMA = 1.0/2.2;\n\n// path tracer setup\nvec3 pt_origin = vec3(0.0,0.0,-PI); // observer origin\nvec3 pt_up_vec = vec3(0.0,+1.0,0.0); // up vector\n// sphere setup\nvec3  sphere_col = vec3(0.45,0.35,0.65);\nvec3  sphere_pos = vec3(0.0,0.0,0.0);\nfloat sphere_rad = GR;\n// colors\nvec3 sun_col = vec3(1.00,0.85,0.55);\nvec3 flr_col = vec3(0.30,0.05,0.05);\nvec3 sky_col = vec3(0.25,0.30,0.75);\n\n// sphere intersection test\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n\t{\n    vec3 rc = ray-center;\n    float c = dot(rc,rc) - (radius*radius);\n    float b = dot(dir,rc);\n    float d = b*b - c;\n    float t = -b - sqrt(abs(d));\n    float st = step(0.0,min(t,d));\n    return mix(-1.0,t,st);\n\t}\n\n// calculate color based on ray direction\nvec3 background(vec2 dir, vec3 rd)\n\t{\n    vec3 light = normalize(vec3(sin(dir.x),dir.y,cos(dir.x)));\n    float sun = max(0.0, dot(rd,light));\n    float sky = max(0.0, dot(rd,pt_up_vec));\n    float flr = max(0.0,-dot(rd,pt_up_vec));\n    return \n        pow(sun,96.0)*1.0*sun_col+ // sun\n        pow(sun,04.0)*0.1*sun_col+ // sun\n        pow(flr,02.0)*1.0*flr_col+ // floor\n        pow(sky,02.0)*1.0*sky_col; // sky\n\t}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n\t{\n    // normalize uv coordinates from [-1,1]\n    vec2 uv = (-1.0 + 2.0*fragCoord/iResolution.xy)*vec2(iResolution.x/iResolution.y,1.0);\n    \n    // ray direction\n    vec3 pt_ray_dir = normalize(vec3(uv,1.0));\n    vec2 rotation = vec2(-PI+(iMouse.xy/iResolution.xy)*(2.0*PI)); // mouse rotation\n    \n    // sphere intersection/normal\n    float sphere_int = sphere(pt_origin,pt_ray_dir,sphere_pos,sphere_rad);\n    vec3  sphere_nrm = normalize(sphere_pos - (pt_origin+pt_ray_dir*sphere_int));\n    \n    // ray color\n    vec3 bg_col = background(rotation,pt_ray_dir); // no intersection\n    vec3 int_col = background(rotation,reflect(pt_ray_dir,sphere_nrm))*sphere_col; // intersection with sphere\n    \n    // output\n    vec3 out_col = mix(bg_col,int_col,step(0.0,sphere_int));\n    out_col = pow(out_col,vec3(GAMMA)); // gamma correction\n    fragColor = vec4(out_col,1.0);\n    }","name":"Image","description":"","type":"image"}]}