{"ver":"0.1","info":{"id":"fscSDn","date":"1633644323","viewed":138,"name":"TP1_MG_Falcon_millenium","username":"AaronTerg","description":"Tp de modélisation géometrique M2 ID3D\nEngine by Eric Galin","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["mg","id3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Common\n#define PI 3.141592\n#define e0 vec2(1.,0.)\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n  return fract(sin(seed)*43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed,in vec3 nor)\n{\n  float u=Hash(78.233+seed);\n  float v=Hash(10.873+seed);\n  \n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a=6.2831853*v;\n  u=2.*u-1.;\n  return normalize(nor+vec3(sqrt(1.-u*u)*vec2(cos(a),sin(a)),u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\nmat3 rotate_y(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca, 0., sa,\n              0., 1. ,0.,\n              -sa, 0., ca);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m,in vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.8;\n  \n  ro=vec3(40.,0.,20.);\n  ro*=rotate_z(3.14*m.x);\n  ro*=rotate_y(3.14*m.y);\n  \n  vec3 ta=vec3(0.,0.,1.);\n  vec3 ww=normalize(ta-ro);\n  vec3 uu=normalize(cross(ww,vec3(0.,0.,1.)));\n  vec3 vv=normalize(cross(uu,ww));\n  rd=normalize(p.x*uu+p.y*vv+le*ww);\n}\n\n// Main\n\nconst int Steps=1000;\nconst float Epsilon=.05;// Marching epsilon\nconst float T=.5;\n\nconst float rA=10.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.;\n\n// Transforms\nvec3 rotateX(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(p.x,ca*p.y-sa*p.z,sa*p.y+ca*p.z);\n}\n\nvec3 rotateY(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.z,p.y,-sa*p.x+ca*p.z);\n}\n\nvec3 rotateZ(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.y,-sa*p.x+ca*p.y,p.z);\n}\n\nvec3 translateX(vec3 p, float dx){\n  return vec3(p.x + dx, p.yz);\n}\n\nvec3 translateY(vec3 p, float dy){\n  return vec3(p.x, p.y + dy, p.z);\n}\n\nvec3 translateZ(vec3 p, float dz){\n  return vec3(p.xy, p.z + dz);\n}\n\nvec3 scaleX(vec3 p, float dx){\n  return vec3(p.x*dx, p.yz);\n}\n\nvec3 scaleY(vec3 p, float dy){\n  return vec3(p.x, p.y * dy, p.z);\n}\n\nvec3 scaleZ(vec3 p, float dz){\n  return vec3(p.xy, p.z * dz);\n}\n\nvec3 scale(vec3 p, vec3 dp){\n  return vec3(p.x * dp.x, p.y * dp.y, p.z*dp.z);\n}\n\nvec3 translate(vec3 p, vec3 dp){\n  return p + dp;\n}\n\n// Arrondi les bords\n// x : distance\n// R : radius\nfloat roundCorner(float sdf,float R)\n{\n  return sdf - R;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat point(vec3 p,vec3 c, float R)\n{\n  return length(p-c) - R;\n}\n\nfloat box(vec3 p, vec3 c, vec3 dim){\n  //  return (max(max(max(b.x, b.z), b.y), 0.)) - R;\n    return length(max(abs(p-c) - dim, vec3(0.))) - 0.05;\n}\n\nfloat segment(vec3 p, vec3 a, vec3 b, float R){\n  vec3 ab = b - a, ap = p - a;\n  // trouver le point q sur le segment ab\n  float q = clamp(dot(ab, ap) / dot(ab, ab), 0., 1.); \n  // si q = 0 => l = length(ap)\n  // si q = 1 => l = length(bp) (p - a - (b -a) = p - b)\n  float l = length(ap - q*ab );\n  return l - R;\n}\n\n// Inigo quilez\nfloat torus(vec3 p, vec3 c, vec2 R){\n  vec3 cp = p-c;\n  return length(vec2(length(cp.xz) - R.x, cp.y)) - R.y;\n}\n\n// Inigo quilez\nfloat cylinder(vec3 p, vec3 c, float h, float R){\n  vec3 cp = p -c;\n  vec2 base = abs(vec2(length(cp.xz), cp.y)) - vec2(R, h);\n  return min(max(base.x, base.y), 0.) + length(max(base, vec2(0.)));\n}\n\n\nfloat hemisphere(vec3 p, vec3 c, float R, vec3 n){\n  vec3 pc = p-c;\n   float d =max(-dot(n, pc), length(pc) - R); \n  return d;\n}\n\nfloat plane(vec3 p, vec3 c, vec2 R, vec3 n){\n  vec3 pc = p-c;\n  float d =abs(dot(n, pc));\n  return max(d - R.y , 0.); // TODO : trouver constante liptchitch 3.4;//length(p - c) - d;\n}\n\nfloat baril(vec3 p, vec3 c, vec2 R, vec3 n){\n  vec3 pc = p-c;\n  float d =abs(dot(n, pc)) - R.y;\n  return max(d, length(pc) - R.x);//length(p - c) - d;\n}\n\n// Inigo quilez\nfloat cone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n  return min(a,b);\n}\n\n// Blending\n// a,b : field function of the sub-trees\nfloat Blend(float a,float b, float k)\n{\n  float h = max(k - abs(a - b), 0.) / k;\n\n  return Union(a, b) - (k* (h* h*h)) / 6.;\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a, float b){\n  return max(a, b);\n}\n\n// Difference\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Difference(float a, float b){\n  return Intersection(a,- b);\n}\n\n// Union for color\n// a : field function of left sub-tree + color\n// b : field function of right sub-tree + color\nvec4 UnionCol(vec4 a,vec4 b)\n{\n  if( a.w < b.w) return a;\n  return b;\n}\n\n// Union for color\n// a : field function of left sub-tree + color\n// b : field function of right sub-tree\nvec4 UnionCol(vec4 a, float b)\n{\n  return vec4(a.rgb, Union(a.w, b));\n}\n\n// Blending for color\n// a,b : field function of the sub-trees  + color\n// k: intensité d'arrondissement\nvec4 BlendCol(vec4 a,vec4 b, float k)\n{\n  float h = max(k - abs(a.w - b.w), 0.) / k;\n  vec4 uc = UnionCol(a, b);\n  float blendingVal = (k* (h* h*h)) / 6.;\n  return vec4(uc.rgb, uc.w - blendingVal);\n}\n\n// Blend for color\n// a : field function of left sub-tree + color\n// b : field function of right sub-tree + color\n// k: intensité d'arrondissement\nvec4 BlendCol(vec4 a,float b, float k)\n{\n  float h = max(k - abs(a.w - b), 0.) / k;\n  vec4 uc = UnionCol(a, b);\n  return vec4(uc.rgb, uc.w - (k* (h* h*h)) / 6.);\n}\n\nvec4 IntersectionCol(vec4 a, vec4 b){\n  return vec4(mix(a.rgb, b.rgb, .5), Intersection(a.w, b.w));\n}\n\n// Intersection for color\n// a : field function of left sub-tree + color\n// b : field function of right sub-tree\nvec4 IntersectionCol(vec4 a, float b){\n  return vec4(a.rgb, Intersection(a.w, b));\n}\n\n// Difference for color\n// a : field function of left sub-tree + color\n// b : field function of right sub-tree + color\nvec4 DifferenceCol(vec4 a, vec4 b){\n  return vec4(a.rgb, Intersection(a.w,- b.w));\n}\n\n// Difference for color\n// a : field function of left sub-tree + color\n// b : field function of right sub-tree\nvec4 DifferenceCol(vec4 a, float b){\n  return vec4(a.rgb, Intersection(a.w,- b));\n}\n\n\n#define WHITE e0.xxx\n#define BLACK e0.yyy\n#define RED e0.xyy\n#define BLUE e0.yyx\n\n// falcon millenium\n// Potential field of the object\n// p : point\nfloat Object(vec3 p, out vec3 color)\n{\n\n  p.z=-p.z;\n  \n  // pour la symétrie\n  vec3 pp = vec3(p.x, p.y, abs(p.z));\n  vec3 pyz = vec3(p.x, abs(p.y), abs(p.z));\n  vec3 py = vec3(p.x, abs(p.y), p.z);\n  vec3 px = vec3(abs(p.x), p.y, p.z); \n \n  vec4 spaceship = vec4(WHITE, roundCorner(cylinder(p, vec3(0.), .5, 5.5), 0.3));\n\n  // main frame\n  { \n    vec4 segmenter = vec4(WHITE, 1);\n    segmenter.w = box(p, vec3(0.), vec3(.8, .8, 8.));\n    vec4 reactorHor = vec4(WHITE, 1);\n    reactorHor.w = roundCorner(cylinder(rotateX(pp, PI / 2.), vec3(0., -1. , 0.), 4.5, .8), 0.13);\n    reactorHor.w = Union(reactorHor.w,\n                      box(pyz, e0.yyx*3.5, vec3(1., 1.25, 1.35)));\n    reactorHor.w = Intersection(reactorHor.w,  box(rotateZ(translateZ(pp, -5.6), PI / 4.), vec3(0., 0., 0.), vec3(1.2, 1.2, 5.6)));\n    segmenter.w = Union(segmenter.w,\n                box(rotateY(translateZ(pp, -5.6), PI / 4.), vec3(0., 0., 0.), vec3(1.2))\n                ); \n    spaceship = BlendCol(DifferenceCol(spaceship, segmenter), reactorHor, 0.3);\n\n    // frame back\n    {\n        vec4 reactorBack = vec4(e0.yxx, 1);\n        vec4 reactorBackFrame = vec4(WHITE, 1);\n\n        reactorBack.w = cylinder(p, vec3(0.), .45, 6.5);\n        reactorBackFrame.w = Intersection(roundCorner(reactorBack.w, 0.3), \n                      box(rotateY(p - e0.xyy*-6., PI /4.), vec3(0., 0., 0.), vec3(4., 1., 4.))\n                      );\n        reactorBack.w = Intersection(reactorBack.w,\n                      box(p, vec3(-6., 0., 0.), vec3(2., 1., 4.))\n                      );\n        reactorBackFrame.w = Difference(reactorBackFrame.w, \n        box(p, vec3(-6., 0., 0.), vec3(5., .3, 5.)));\n\n        vec4 pyloneBack = vec4(BLACK, 1);\n        pyloneBack.w = cylinder(pp, vec3(-2.5, -.8, 1.3), .1, .6);\n        pyloneBack.w = Union(pyloneBack.w, \n        cylinder(p, vec3(-2.8, -.8, 0.), .1, .6));\n        pyloneBack.w = Union(pyloneBack.w, \n        cylinder(pp, vec3(-4.1, -.8, 1.5), .1, .6));\n        pyloneBack.w = Union(pyloneBack.w, \n        cylinder(p, vec3(-4.4, -.8, 0.), .1, .6));\n        spaceship = BlendCol(spaceship, pyloneBack, 0.3);\n\n        reactorBackFrame = UnionCol(reactorBack, reactorBackFrame);\n        spaceship = BlendCol(spaceship, reactorBackFrame, .2);\n    }\n\n  }\n\n  // roof asset\n  { \n    \n    // parabollique\n    { \n\n      vec4 parabolique = vec4(WHITE, 1);\n      vec4 paraboliqueSupport = vec4(WHITE, 1);\n      vec4 paraboliquePointe = vec4(WHITE, 1);\n\n      parabolique.w =  point(p, vec3(4.3, -2.5, -3.), 1.5);\n      paraboliqueSupport.w = cylinder(p, vec3(2.8, -1, -3.), .1, .8);\n      paraboliquePointe.w = cone(p, vec3(3., -2.5, -3.), vec3(3.5, -2.5, -3.), .3, .01);//box(p, vec3(3., -2.5, -3.), vec3(.5, .01, .001));// segment(p, vec3(3., -2.5, -3.), vec3(3.5, -2.5, -3.), .0);\n\n      parabolique.w = abs(parabolique.w) - .05;\n      parabolique.w = Intersection(parabolique.w,point(p, vec3(2.5, -2.5, -3.), 1.8)) / 2.;\n      parabolique = UnionCol(parabolique, paraboliquePointe);\n      \n\n      parabolique = UnionCol(parabolique, paraboliqueSupport);\n      parabolique.w = Union(parabolique.w, box(p, vec3(2.5, -2., -3.), vec3(.25, 1., .2)));\n      spaceship = UnionCol(spaceship, parabolique);\n    }\n\n    // turret\n    { \n    \n      vec4 turret = vec4(WHITE, 1);\n      vec4 canon = vec4(WHITE, 1);\n\n      canon.w = cylinder(rotateZ(pyz,  PI / 2.), vec3(1.85, -1., .2), .5, .08);\n      turret.w = roundCorner(cylinder(p, vec3(0.), 1., 1.5), 0.3);\n      canon = BlendCol(canon, vec4(BLUE, cylinder(rotateZ(pyz,  PI / 2.), vec3(1.85, -.5, .2), .2, .1)), 0.3);\n      turret.w = Union(turret.w,\n          Difference(\n            box(pyz,  vec3(0., 1.7, .0), vec3(.4, 0.4, .4)),\n            box(pyz, vec3(0., 2.1, 0.), vec3(0.3, 0.01, .6))\n      )); \n      turret.w = Difference(turret.w, \n          box(rotateZ(pyz, PI /4.), vec3(1.2, 1.7, 0.), vec3(0.3, 0.1, .6))\n      );\n      canon.w = Union(canon.w, \n                    Blend( cylinder(rotateZ(pyz,  PI / 2.), vec3(1.55, -1., .2), .5, .08), \n                    cylinder(rotateZ(pyz,  PI / 2.), vec3(1.55, -.5, .2), .2, .1), 0.3)\n     );\n    \n      turret = UnionCol(turret, canon);\n      spaceship = BlendCol(turret, spaceship, 0.3);\n    }\n\n    // cockpit\n    { \n      vec4 tunnel = vec4(WHITE, 1);\n      vec4 cockpit = vec4(BLACK, 1);\n      \n      cockpit.w = cone(p, vec3(5., -1., 4.5), vec3(6.5, -1., 4.5), .8, .5);\n      tunnel.w = segment(p, vec3(0.), vec3(3.5, -1., 4.5), .8);\n      cockpit = UnionCol(cockpit,\n            vec4(WHITE, cylinder(rotateZ(p,  PI / 2.), vec3(-1.,-4.5, 4.5), .8, .78)));\n      \n      tunnel = BlendCol(tunnel, cockpit, .1);\n      spaceship = BlendCol(tunnel, spaceship, 0.01);\n    }\n  }\n\n  // detail\n  { \n    \n\n\n    vec4 circleDetail = vec4(BLACK *0.25, 1);\n    circleDetail.w = torus(vec3(p.x, abs(p.y), p.z), .8*e0.yxy, vec2(4.8, .022));\n    circleDetail.w = Union(circleDetail.w,\n    torus(vec3(p.x, abs(p.y), p.z), .8*e0.yxy, vec2(4., .022))\n    ); \n    circleDetail.w = Union(circleDetail.w,\n    torus(vec3(p.x, abs(p.y), p.z), .8*e0.yxy, vec2(3., .022))\n    ); \n\n    float dirLine = 0.707 * 5.5;\n    spaceship = BlendCol(spaceship, vec4(circleDetail.rgb, segment( abs(p), e0.yxy*.8, vec3(dirLine, .8, dirLine), 0.022)), 0.01);\n    spaceship = BlendCol(spaceship, vec4(circleDetail.rgb, segment( abs(p), e0.yxy*.8, vec3(dirLine* .25, .8, dirLine), 0.022)), 0.01);\n    spaceship = BlendCol(spaceship, circleDetail, 0.01); \n  }\n  \n  // frame below\n  {\n    spaceship = UnionCol(spaceship,\n        vec4(WHITE, box(pp, vec3(3., 1., 2.), vec3(1.3, .2, 1.)))\n        );\n    spaceship = UnionCol(spaceship,\n        vec4(WHITE, box(p, vec3(3., 1., 0.), vec3(2.3, .2, .6)))\n        );\n  }\n\n  // pointe\n  { \n    float b4 =box(rotateY(translateX(pp, -4.), - PI / 6.), vec3(-2., 0., .5),vec3(8., .5, 3.));\n    float flatBox = box(p, vec3(4., 0., 0.), vec3(5., 0.5, 4.25));\n    float inbetweenBox = box(p, vec3(6., 0., 0.), vec3(.8, 1., 1.));\n    float front = box(pp, vec3(4.35, -1., .4), vec3(2.3, .2, .3));\n    vec4 pointe = vec4(WHITE, 1);\n    \n    pointe.w = roundCorner(Intersection(b4, flatBox), 0.2 );\n    \n    pointe.w = Difference(pointe.w, box(p, vec3(8., 0., 0.), vec3(5., 1., 0.8)));\n    pointe.w = Difference(pointe.w,\n              roundCorner(inbetweenBox, .2)\n              );\n    pointe.w = Union(pointe.w,\n              roundCorner(inbetweenBox, .02)\n              );\n              \n    pointe.w = Blend(front, pointe.w, 0.01);\n    pointe.w = Blend(pointe.w, \n            box(pp, vec3(8., 0., .8), vec3(.8, .1, .1))\n            , 0.01);\n    \n    // detail pointe\n    float pylonePointe = cylinder(vec3(pp.x, abs(pp.y), pp.z), vec3(5.6, .7, 2.5), .1, .4);\n    pylonePointe = Union(pylonePointe, \n    cylinder(vec3(pp.x, abs(pp.y), pp.z), vec3(6.6, .7, 1.7), .1, .4));\n  \n    pointe = DifferenceCol(pointe, pylonePointe);\n    // Assemblage ss arbre\n    \n    spaceship = BlendCol(spaceship, pointe, 0.01);\n  }\n  color = spaceship.rgb;\n  return spaceship.w;\n}\n\n\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p)\n{\n  float eps=.0001;\n  vec3 n, dummy = e0.yyy;\n  \n  float v=Object(p, n);\n  n.x=Object(vec3(p.x+eps,p.y,p.z), dummy)-v;\n  n.y=Object(vec3(p.x,p.y+eps,p.z), dummy)-v;\n  n.z=Object(vec3(p.x,p.y,p.z+eps), dummy)-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    vec3 dummy;\n    float v=Object(p, dummy);\n    // Hit object\n    if(v>0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=Epsilon;\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float rB,out bool h,out int s, inout vec3 pt, inout vec3 color)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    pt=o+t*u;\n    float v;\n    pt = rotateX(pt, PI  / 2.);\n    //pt = translateZ(pt, 4.*sin(iTime));\n   // pt = scale(pt, vec3(.5, .5, 0.5));\n\n  //  pt = translateX(pt, (4.*abs(fract(iTime) -.5) * 2.* PI));\n    v = Object(pt, color);\n    //v = Object(scale(p, vec3(.8)));\n    // Hit object\n    if(v<0.0001)\n    {\n      s=i;\n      h=true;\n      //color = v.rgb;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,abs(v)/4.);\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n,int a)\n{\n  if(a==0){return 1.;}\n  \n  float ao=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    \n    int s;\n    bool h;\n    vec3 dummy = vec3(0.);\n    float t=SphereTrace(p,d,10.,h,s, dummy, dummy);\n    if(!h){ao+=1.;}\n    else if(t>5.)\n    {\n      ao+=1.;\n    }\n  }\n  \n  ao/=float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  if(mod(Hash(rd.x), 2.) == mod(Hash(rd.x+ 1.), 2.)) return WHITE;\n  else return BLACK;\n  return mix(vec3(.652,.451,.995),vec3(.552,.897,.995),rd.z*.5+.5);\n}\n\nfloat Light(vec3 p,vec3 n)\n{\n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff=pow(.5*(1.+dot(n,l)),2.);\n  \n  bool h;\n  int s;\n  vec3 dummy = vec3(0.);\n  float t=SphereTrace(p+.1*n,l,100.,h,s, dummy, dummy);\n  if(!h)\n  {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p,vec3 n,int a)\n{\n  if(a==0)\n  return 1.;\n  \n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  float lo=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    d=normalize(l+d*.15);\n    int s;\n    bool h;\n    vec3 dummy = vec3(0.);\n    float t=SphereTrace(p,d,10.,h,s, dummy, dummy);\n    if(!h){lo+=1.;}\n    else if(t>100.)\n    {\n      lo+=1.;\n    }\n  }\n  \n  lo/=float(a);\n  return lo;\n  \n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p,vec3 n, vec3 color)\n{\n  vec3 c = .05*background(n);\n  c+=.35*AmbientOcclusion(p+.1*n,n,0)*color;\n  c+=.60*Light(p,n);\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return .5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=false;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  vec3 col;\n  vec3 pt;\n  // // Position\n  float t=SphereTrace(ro,rd,100.,hit,s, pt, col);\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Compute normal\n    vec3 n=ObjectNormal(pt);\n    \n    // Shade object with light\n    rgb=Shade(pt,n, col);\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}