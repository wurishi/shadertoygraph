{"ver":"0.1","info":{"id":"mdySDW","date":"1681183884","viewed":129,"name":"2d gradient","username":"c0rymcg","description":"I've been trying to find a good way to make a nice gradient image in 2d by defining arbitrary points at arbitrary colours and filling everything else in. I tried a few things but settled on this system based on weighted averages.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//colorspots\n\nvec3 colors[6] = vec3[6](vec3(1,0.,0.), vec3(1.,1.,0), vec3(0.,1,0.5), vec3(1,1,1), vec3(0.1), vec3(0.8,0., 1.));\nvec2 mPos = vec2(0);\nvec2 positions[6] = vec2[6](\n    vec2(-0.5,-0.125),\n    vec2(0.0,0.45),\n    vec2(-0.1,-0.35),\n    vec2(0.5,-0.2),\n    vec2(1.,0.5),\n    vec2(0.15,0.0)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xx-vec2(0.5,0.3);\n    uv*=2.;\n    positions[5] = vec2(sin(iTime), cos(iTime)*sin(iTime))*0.8;\n    positions[4] = vec2(sin(iTime*0.5)*0.5, cos(iTime*0.5)*.5);\n    if(iMouse.z>0.){\n        mPos = iMouse.xy/iResolution.xx;\n        mPos -= vec2(0.5,0.3);\n        mPos*=2.;\n        positions[5] = mPos;\n      \n    }\n    \n    vec3 col = vec3(0);\n    float amount = 0.;\n    for(int i = 0; i < 6; i++){\n        float dist = distance(uv, positions[i])/1.5+1e-6;//adding very small number to avoid infinity later\n        dist = 1.-exp(-dist*dist*10.); //upsidedown gaussian curve\n        float strength = 1.-min(1e-6,1.*log(dist))-1.;\n        \n        //average with weights\n        col = (colors[i]*strength + col *amount)/(amount+strength);\n        amount+=strength;\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}