{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define INF 7.0\n\nfloat marched = 0.0;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat sdSphere( vec3 p, float size)\n{\n  return length(p)-1.2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(INF,1.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,INF,1.0));\n  float dc = sdBox(p.zxy,vec3(1.0,1.0,INF));\n  return min(da,min(db,dc));\n}\n\n\n\n\t\nfloat map( vec3 p )\n{\n   vec3 pui;\n   pui.x = 1.0;\n   pui.y = 1.0;\n   pui.z = 1.0;\n   float d = sdBox(p,pui);\n   int m;\n   float s = 1.0;\n   for( int m=0; m<2;m++ )\n   {\n   \t  vec3 a;\n   \t  vec3 q;\n   \t  q=p*s;\n      a = mod( q, 1.0 )-0.5;\n     \n      s *= 6.0;\n      \n      vec3 r = 1.2 - 6.8*abs(a);\n   \n      float c = sdCross(r)/s;\n      d = max(d,-c);\n   }\n\n   return d;\n}\nfloat rm(vec3 origin, vec3 ray, float min_distance, float max_distance) {\n\tint i;\n\tfloat distance_marched = min_distance;\n\tfor (int i=0; i<400; i++) {\n\t\tvec3 indi = ray*distance_marched;\n\t\n\t\tvec3 moi = indi + origin;\n\t\t\n\t\tfloat step_distance = map(moi);\n\t\tif (abs(step_distance) < 0.0001) {\n\t\t\treturn distance_marched/(max_distance-min_distance);\n\t\t}\n\t\tdistance_marched += step_distance;\n\t\tmarched=distance_marched;\n\t\tif (distance_marched > max_distance) {\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\tvec3 render(vec2 q) {\n\tvec3 dir;\n\tvec3 screen;\n\tvec3 ray;\n    vec2 moro = vec2 (iTime);\n\n\tdir.x = 0.0;\n\tdir.y = 0.0;\n\tdir.z = -.9;\n\tmat3 rot = rotationXY(moro);\n\tscreen.x = q.x;\n\tscreen.y = q.y;\n\tscreen.z =-.6;\n\tray = screen - dir;\n\t\n\t\n\tfloat s = rm(rot*dir, rot*ray, 1.0, 4.0);\n\t\n\tvec3 col;\n\t\n\tif (s == -1.0) {\n\t\t\t\tcol.x = 0.0;\n\t\t\t\tcol.y = 0.0;\n\t\t\t\tcol.z = 0.0;\n\n\t} else {\n\t\n\t\tcol = vec3(s-.3*.8+0.4*q.y *sin(q.x))*marched/1.76;\n\t\tcol.rg *= marched*.6;\n\t}\n\t\n\treturn col;\n\t\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = (2.0*fragCoord.xy - iResolution.xy)/iResolution.x;\n\t\n\tvec3 col = render(q);\n\tfragColor = vec4(col.xyz, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsBSzW","date":"1409729226","viewed":539,"name":"Menger build structure","username":"rebb","description":"iteration over mengerish object, this time from inside of object.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}