{"ver":"0.1","info":{"id":"M3fSRB","date":"1709654338","viewed":49,"name":"TP2 : bipboupbipbip ","username":"Raphalator","description":"L’objectif est de définir des textures procédurales (damier, bois, roche, sable, métal rouillé) par\ncombinaison de fonctions de bruit multifréquences. Le code de calcul d’un point de la surface\na été modifié de manière à retourner non seulement la fonctio","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["textureetshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing and noise \n\n// Texturing\n// Eric Galin\n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Camera -----------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0, -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(100.0,0.0,15.0);\n    ro*=Rz(3.0*3.14*m.x); \n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct T {\nvec3 c;\nfloat s;\n};\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(vec3 p, float size)\n{\n    vec3 i = floor(p/size);\n    vec3 f = fract(p/size);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nfloat Voronoi(vec3 x, float scale)\n{\n    vec3 p = floor(x / scale);\n    vec3 f = fract(x / scale);\n\n    float Distance = 100.0;\n    for (int k = -1; k <= 1; k++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            for (int i = -1; i <= 1; i++)\n            {\n                vec3 b = vec3(float(i), float(j), float(k)) ;\n                vec3 r = vec3(b) - f + Hash(p + b);\n                float d = dot(r, r);\n\n                if (d < Distance)\n                {\n                    Distance = d;\n                }\n            }\n        }\n    }\n\n    return sqrt(Distance);\n}\n\n\n\nT UnionT(T a,T b)\n{\n    if (a.c.x < b.c.x && a.c.y < b.c.y && a.c.z < b.c.z )\n        return T(a.c,a.s);\n    else \n    {\n        return T(b.c,b.s);\n    }\n}\n\nvec3 MergeColor(vec3 color1, vec3 color2, float function)\n{\n    return function * color1 + (1.-function) * color2;\n}\n\nvec3 MergeColor2(vec3 color1, vec3 color2, float function1, float function2)\n{\n    return function1 * color1 + (1.-function2) * color2;\n}\n\nfloat MergeFunction(float f1, float f2, float factor)\n{\n    return f1 * factor + f2 * (1.-factor);\n}\n\nfloat Ramp(float f, float bot, float top)\n{\n    if(f>=top)\n        return 1.0;\n    if(f<bot)\n        return 0.0;\n    else\n        return f;\n}\n\nfloat Turbulence(vec3 p, float size)\n{\n    float f=Noise(p,size)*Noise(p,size/2.)*Noise(p,size/4.)*Noise(p,size/8.);\n    return min(f*5.,1.);\n}\n\nvec3 Color(float r, float g, float b)\n{\n    return vec3(r,g,b);\n}\n\n\n\n\nfloat Axial(vec3 p, float size) \n{\n    float r=sqrt(p.x * p.x + p.y * p.y);\n    r=r+0.5 * Turbulence(p, 5.);\n    return 0.5 + 0.5 * cos(3.1415927 * r * size);\n} \n\nfloat modifierAmplitude(float valeurNoise, float baseAmplitude, float newAmplitude)\n{\n    return baseAmplitude + (valeurNoise * newAmplitude);\n}\n\nvec3 modifierPlane(vec3 p, float size, float baseAmplitude, float newAmplitude, float movement)\n{\n    float valeurNoise = Noise(p + movement, size);\n    float modifierAmplitudePlan = modifierAmplitude(valeurNoise, baseAmplitude, newAmplitude);\n    return p + vec3(0.0, 0.0, modifierAmplitudePlan);\n}\n\nT Grass(vec3 p, vec3 grass1, vec3 grass2){\n    //Color(0.2,0.6,0.2), // Vert foncé\n        //Color(0.4,0.8,0.4)// Vert clair\n    \n    return T(\n    MergeColor(grass1, \n        grass2,          \n        Noise(p, 1.)),\n    0.); \n}\n\nT SimpleColor(vec3 p, vec3 color, float specular){\n    return T(color, specular); \n}\n\nvec3 wood(vec3 p, vec3 wood1, vec3 wood2){\n     return MergeColor(wood1,wood2,\n        Ramp(Axial(p,3.),0.5,1.0));\n        \n}\n\nT woodMouss(vec3 p, vec3 wood1, vec3 wood2, float moussy){\n\n    vec3 color1 = Color(0.2,0.6,0.2); // Vert foncé\n    vec3 color2 = Color(0.4,0.8,0.4);\n\n    float moussMerge = Ramp(Noise(p,3.),0.2,0.8);\n\n    vec3 moussColor = MergeColor(color1,color2,moussMerge);\n\n    vec3 woodColor = wood(p + 10., wood1, wood2);\n\n    vec3 textureColor = MergeColor(moussColor, woodColor, Ramp(Turbulence(p,1.5),0.0,0.3));\n\n    float specular = Ramp(Noise(p,3.),0.2,0.8);\n\n    return T(textureColor,specular);\n}\n\nT metal(vec3 p, vec3 metal){\n     return SimpleColor(p, metal, 1.);\n        \n}\n\nT metalRust(vec3 p, float rust){\n      \n    vec3 color1 = Color(0.6, 0.3, 0.1);\n    vec3 color2 = Color(0.8, 0.5, 0.3);\n\n    float rustMerge = Ramp(Turbulence(p,rust),0.2,0.8);\n\n    vec3 rustColor = MergeColor(color1,color2,rustMerge);\n\n    color1 = Color(0.55, 0.5, 0.5);\n    color2 = Color(0.7, 0.7, 0.7);\n\n    float metalMerge = Ramp(Turbulence(p,4.0),0.1,0.5);\n\n    vec3 metalColor = MergeColor(color1,color2,metalMerge);\n\n    vec3 textureColor = MergeColor(rustColor,metalColor,Ramp(Turbulence(p,1.5),0.0,0.3));\n\n    float specular = Ramp(1.0-Ramp(Turbulence(p,1.5),0.0,0.3),0.1,0.9);\n\n    return T(textureColor,specular);\n}\n\n\nfloat Checker(vec3 p, float size) {\n    float sizeChecker = max(1.0/size,0.1);\n    return mod(floor(sizeChecker * p.x) + floor(sizeChecker * p.y) + floor(sizeChecker * p.z), 2.0);\n}\n\nT Liquid( vec3 p, vec3 color1, vec3 color2, float scale){\n\n   return T(MergeColor(color1,  \n        color2,\n        Voronoi(p + iTime, scale))\n    ,\n    0.0);\n}\n\nT Ore( vec3 p, vec3 ore){\n\n   vec3 Stone = MergeColor(vec3(0.5, 0.5, 0.5), vec3(0.4, 0.4, 0.4), Turbulence(p, 0.2)); // Couleur principale du marbre, proche du blanc\n\n\n   return T(\n    MergeColor2(ore,  // Gris moyen\n        Stone,           // Gris clair\n        Turbulence(p, 2.), Turbulence(p, 1.)),\n    Turbulence(p, 2.)); \n}\n\nT Marbre( vec3 p,vec3 color1, vec3 color2, vec3 color3, float scale){\n\n\n\n    vec3 p2 = vec3(p.x * 4.0,p.y * 2.5,p.z);\n\n    float voronoi = Ramp(Voronoi(p2, 1.0 * scale),0.5,0.8);\n    float noise1 = Ramp(Turbulence(p,0.7 * scale),0.3,0.8);\n    float noise2 = Ramp(Turbulence(p2,2.0 * scale),0.3,0.5);\n\n    float function1 = MergeFunction(voronoi,noise1,0.7) * noise2;\n\n    noise1 = Ramp(Turbulence(p,1.0 * scale),0.1,0.4);\n    noise2 = Ramp(Turbulence(p2,1.5 * scale),0.0,0.5);\n\n    float function2 = MergeFunction(voronoi,noise1,0.7) * noise2;\n\n    vec3 shade1 = MergeColor(color2\n                            ,color1\n                            ,function1);\n\n    vec3 shade2 = MergeColor(color3\n                            ,color1\n                            ,function2);\n\n    return T(shade1 * shade2, 1.);\n}\n\n\n\nT MarbreSansVeine(vec3 p,vec3 color1, vec3 color2, float scale){\n\n    vec3 p2 = vec3(p.x * 4.0,p.y * 2.5,p.z);\n\n    float voronoi = Ramp(Voronoi(p2, 1.0 * scale),0.5,0.8);\n    float noise1 = Ramp(Turbulence(p,0.7 * scale),0.3,0.8);\n    float noise2 = Ramp(Turbulence(p2,2.0 * scale),0.3,0.5);\n\n    float function1 = MergeFunction(voronoi,noise1,0.7) * noise2;\n\n    noise1 = Ramp(Turbulence(p,1.0 * scale),0.1,0.4);\n    noise2 = Ramp(Turbulence(p2,1.5 * scale),0.0,0.5);\n\n    float function2 = MergeFunction(voronoi,noise1,0.7) * noise2;\n\n    vec3 shade1 = MergeColor(color2\n                            ,color1\n                            ,function1);\n\n\n    return T(shade1, 1.);\n}\n\n\n\n\n// Rotation\n// p : point a transformer\n// angle : angle rotation\nvec3 RotateZ(vec3 p, float angle) {\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    mat3 rotationMatrix = mat3( \n        c, s, 0,\n        -s, c, 0,\n        0, 0, 1\n    );\n\n    return rotationMatrix * p;\n}\n\nvec3 RotateY(vec3 p, float angle) {\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    mat3 rotationMatrix = mat3( \n        c, 0, -s,\n        0, 1, 0,\n        s, 0, c\n    );\n\n    return rotationMatrix * p;\n}\n\nvec3 RotateX(vec3 p, float angle) {\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    mat3 rotationMatrix = mat3( \n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n\n    return rotationMatrix * p;\n}\n\n// Rotation 3d\n// p : point a transformer\n// x : angle rotation x\n// y : angle rotation x\n// z : angle rotation x\nvec3 rotateXYZ(vec3 p, float angleX, float angleY, float angleZ) {\n    vec3 rotated_p = RotateX(p, angleX);\n    rotated_p = RotateY(rotated_p, angleY);\n    rotated_p = RotateZ(rotated_p, angleZ);\n    return rotated_p;\n}\n\n\n//Operator float////////////\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\n\n\nfloat Union2(float a,float b)\n{\n  return min(a,b);\n}\n\nfloat Intersect2(float a, float b){\n    return max(a,b);\n}\n\nfloat Difference2(float a, float b){\n    return max(a,-b);\n}\n\nfloat Arrondi2(float a, float b){\n    return a - b;\n}\n\nfloat Maigrir2(float a, float b){\n    return a + b;\n}\n\nvec3 Translation2(vec3 p, vec3 translation)\n{\n    return p + translation;\n}\n\nfloat Lissage2(float a, float b, float r){\n    float h = max(r - abs(a - b), 0.) / r;\n    return min(a, b) - ((1. / 6.) * r * (h * h * h));\n}\n\nfloat random(vec2 seed) {\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//Primitive float//////////////\n\nfloat Sphere2(vec3 p,vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\nfloat Plan2(vec3 p, vec3 c, vec3 n){\n    return dot(p-c, normalize(n));\n}\n//Cube\n//c : center of skeleton\n//p : Position\n//h : hauteur\n//l : largeur\n//w : profondeur\nfloat Cube2(vec3 p, vec3 c, float h, float l, float w){  \n    h = h / 2.0;\n    l = l / 2.0;\n    w = w / 2.0;\n\n    // Plan du cube\n    float p1 = Plan2(p, Translation2(c, vec3(-h, 0.0, 0.0)), vec3(-1.0, 0.0, 0.0));\n    float p2 = Plan2(p, Translation2(c, vec3(h, 0.0, 0.0)), vec3(1.0, 0.0, 0.0));\n    float p3 = Plan2(p, Translation2(c, vec3(0.0, 0.0, w)), vec3(0.0, 0.0, 1.0));\n    float p4 = Plan2(p, Translation2(c, vec3(0.0, 0.0, -w)), vec3(0.0, 0.0, -1.0));\n    float p5 = Plan2(p, Translation2(c, vec3(0.0, l, 0.0)), vec3(0.0, 1.0, 0.0));\n    float p6 = Plan2(p, Translation2(c, vec3(0.0, -l, 0.0)), vec3(0.0, -1.0, 0.0));\n\n    // Intersection des plans pour former le cube\n    return Intersect2(Intersect2(p1, Intersect2(p2, Intersect2(p3, p4))), Intersect2(p5, p6));\n}\n\n//Pyramid\n//c : center of skeleton\n//p : Position\n//L : Longueur\n//l : largeur\nfloat Pyramid2(vec3 p, vec3 c, float l, float L){\n    L ;\n    l ;\n    \n    // Base pyramide\n    float basePlane = Plan2(p, Translation2(c, vec3(0.0, -L, 0.0)), vec3(0.0, -1.0, 0.0));\n\n    // Côtés pyramide\n    float p1 = Plan2(p, Translation2(c, vec3(l, 0., l)), normalize(vec3(1.0, 1.0, 0.0)));\n    float p2 = Plan2(p, Translation2(c, vec3(-l, 0., l)), normalize(vec3(-1.0, 1.0, 0.0)));\n    float p3 = Plan2(p, Translation2(c, vec3(0.0, -L, -l)), normalize(vec3(0.0, 1.0, -1.0)));\n    float p4 = Plan2(p, Translation2(c, vec3(0.0, -L, l)), normalize(vec3(0.0, 1.0, 1.0)));\n\n    // Intersection des plans \n    return Intersect2(basePlane, Intersect2(p1, Intersect2(p2, Intersect2(p3, p4))));\n}\n\n\n\nfloat Capsule2(vec3 p, vec3 a, vec3 b, float r){\n    vec3 u = normalize(b-a);\n    if(dot(p-a,u) < 0.){\n        return length(p-a) - r;\n        }\n    else if (dot(p-b,-u) < 0.){\n        return length(p-b) - r;\n        }\n    else {\n        return sqrt( length(p-a) * length(p-a) - dot(p-a, u) * dot(p-a, u)) - r;\n    }\n}\n\n\n//Cylinder\n//p : Position\n//a : Centre 1\n//b : Centre 2\nfloat Cylinder1 (vec3 p, vec3 a, vec3 b, float r){\n    float v = Capsule2(p,a,b,r);\n    float p1 = Plan2(p,a,a-b);\n    float p2 = Plan2(p,b,b-a);\n    return Intersect2(p1,(Intersect2(p2,v)));\n}\n\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n\n\nV Intersect(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\nV Difference(V a, V b){\n     if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(-b.v,b.i);\n    }\n}\n\nV Arrondi(V a, float b) {\n    return V(a.v - b, a.i); \n}\n\n\nvec3 Translation(vec3 p, vec3 translation)\n{\n    return p + translation;\n}\n\nV Lissage(V a, V b, float r) {\n    float h = max(r - abs(a.v - b.v), 0.) / r;\n    float smoothedValue = min(a.v, b.v) - ((1. / 6.) * r * (h * h * h));\n    return V(smoothedValue, 0); \n}\n\n\n\n\nfloat teleButton(vec3 p){\n\n    float v6 = Difference2(Cylinder1(rotateXYZ(p, 0.,0.,90.), vec3(0.,-5.,-4.),vec3(-5.5,-5.,-4.), 1.),\n    Cube2(rotateXYZ(p - vec3(-5.,10.4,-4.), 0., 90. + (iTime *20.), 0.), vec3(0.,0,0.), 3.,10.,0.4));\n    float v7 = Difference2(Cylinder1(rotateXYZ(p, 0.,0.,90.), vec3(0.,-5.,-1.),vec3(-5.5,-5.,-1.), 1.),\n    Cube2(rotateXYZ(p - vec3(-5.,10.4,-1.), 0., 50. - (iTime *20.), 0.), vec3(0.,0,0.), 3.,10.,0.4));\n    \n    \n    return Union2(v6, v7);\n}\n\nV ecran(vec3 p, int i){\n    float v12 = Lissage2(Cube2(p, vec3(2.2,2.5,0.), 8.,5.,9.4),\n                         Sphere2(p,vec3(2.2,2.,0.), 5. ),3.);\n    return V(v12, i);\n}\n\nV antenne(vec3 p, int i){\n    float v1 = Union2(\n    Difference2(\n    Lissage2(\n    Sphere2(p,vec3(-2.,0.,6.), 2. ),\n    Sphere2(p,vec3(2.,0.,6.), 2. ), 10.),\n    Cube2(p, vec3(0.,0.,6.), 5.,1.,12.)),\n    Union2(Union2(Cylinder1(rotateXYZ(p, 0.,-50.,0.), vec3(-11.,0.,5.),vec3(-6.,0.,5.), 0.2),\n    Sphere2(p,vec3(-3.5,0.,12.), 0.6 )),\n    Union2(Cylinder1(rotateXYZ(p, 0.,50.,0.), vec3(13.,0.,5.),vec3(6.,0.,5.), 0.2),\n    Sphere2(p,vec3(4.5,0.,13.), 0.6 ))\n    ));\n    \n    return V(v1, i);\n}\n\nV metalBackTele(vec3 p, int i){\n    float v35 = Cube2(p, vec3(0.,-11.5,0.), 18.,10.,30.);\n    float v34 = Difference2(Lissage2(Intersect2(\n    Plan2(p, vec3(0.,-6.5,0.),vec3(0.0, -1.0, 0.0)),\n    Pyramid2(rotateXYZ(p, 0.,0.,180.), vec3(0.,7.,0.), 4.,2.)),\n    Lissage2(\n    Cylinder1(p,vec3(1.5,-6.5,0.), vec3(1.5,-2.,0.), 2. ),\n    Cylinder1(p,vec3(-1.5,-6.5,0.), vec3(-1.5,-2.,0.), 2. ),\n    10.),\n    3.),\n    v35);\n    return V(v34, i);\n}\n\nV TVblock( vec3 p, int i){\n    float v33 = Cube2(p, vec3(0.,-10.,0.), 18.,10.,30.);\n    \n    float v13 = Difference2(Lissage2(Cube2(p, vec3(0.,0.,0.), 15.,10.,12.),\n    Lissage2(Capsule2(p,vec3(2.5,3.,0.), vec3(2.5,-2.,0.), 6. ),\n    Capsule2(p,vec3(-2.5,3.,0.), vec3(-2.5,-2.,0.), 6. ), 3.), 3.), v33);\n    \n    float v3 = Cube2(p, vec3(0.,9.9,0.), 18.,10.,30.);\n    \n    return V( Difference2(v13,v3), i);\n}\n\nV TVblock2( vec3 p, int i){\n    float v33 = Cube2(p, vec3(0.,-10.,0.), 30.,10.,30.);\n    \n    float v14 = Difference2(Lissage2(Cube2(p, vec3(0.,2.,0.), 15.,10.,12.),\n    Lissage2(Capsule2(p,vec3(2.5,4.,0.), vec3(2.5,0.,0.), 6. ),\n    Capsule2(p,vec3(-2.5,4.,0.), vec3(-2.5,0.,0.), 6. ), 3.), 3.), v33);\n    \n    float v13 = Difference2(Difference2(Lissage2(Cube2(p, vec3(0.,0.,0.), 16.,10.,13.),\n    Lissage2(Capsule2(p,vec3(2.5,3.,0.), vec3(2.5,-2.,0.), 7. ),\n    Capsule2(p,vec3(-2.5,3.,0.), vec3(-2.5,-2.,0.), 7. ), 3.), 3.), v33),v14);\n    \n    float v3 = Cube2(p, vec3(0.,10.2,0.), 30.,10.,30.);\n    \n    return V( Difference2(v13,v3), i);\n}\n\n\n\n\nV plateTV( vec3 p, int i, int i2){\n    \n    float v32 = Cube2(p, vec3(0.,10.2,0.), 18.,10.,30.);\n    \n    float v10 = Union2(Union2(Union2(Union2(\n    Cube2(p, vec3(-5,7.,0.8), 3.,10.,0.5),\n    Cube2(p, vec3(-5,7.,1.8), 3.,10.,0.5)),\n    Cube2(p, vec3(-5,7.,4.8), 3.,10.,0.5)),\n    Cube2(p, vec3(-5,7.,3.8), 3.,10.,0.5)),\n    Cube2(p, vec3(-5,7.,2.8),3.,10.,0.5)\n    );\n    \n    float v11 = Cube2(p, vec3(-5,4.8,0.8), 3.,0.2,9.8);\n\n    float v5 = Difference2(Difference2(Difference2(Lissage2(Cube2(p, vec3(-5.,4.9,0.), 4.,1.5,11.4),  \n    Lissage2(Cylinder1(p,vec3(-4.,5.,1.),vec3(-4.,3.,1.),3. ),\n    Cylinder1(p,vec3(-4.,5.,-1.),vec3(-4.,3.,-1.),3. ), 3.)\n    , 2.5), v10), v32),  \n    Cube2(p, vec3(-5.,0.5,0.), 4.,1.,11.4));\n    \n    return Union(V(v5, i), V(v11, i2));\n}\n\nV cadreEcran( vec3 p, int i){\n    \n    float v36 = Cube2(p, vec3(0.,10.5,0.), 18.,10.,30.);\n    float v37 = Cube2(p, vec3(0.,0.,0.), 15.,10.,12.);\n    float v15 = Lissage2(Cube2(p, vec3(2.2,3.5,0.), 7.5,5.,8.9),\n    Sphere2(p,vec3(2.2,3.,0.), 5. ),2.5);\n    \n    float v14 = Difference2(Difference2(Difference2(Lissage2(Cube2(p, vec3(2.2,5.,0.), 8.5,4.5,9.9),\n    Capsule2(p,vec3(2.2,4.,0.),vec3(2.2,-1.,0.) ,5.5 ),3.),v36),v15), v37);\n    \n    return V(v14, i);\n}\n\n\nV tele( vec3 p , int i){\n    return V(teleButton(p), i);\n}\n\nV TvFoot(vec3 p, int i){\n    float v8 = Union2(\n    Cylinder1(p, vec3(6.5,-4.,-9.),vec3(6.,-4.,0.), 0.5),\n    Cylinder1(p, vec3(-6.5,-4.,-9.),vec3(-6.,-4.,0.), 0.5)\n    );\n    \n    float v9 = Union2(\n    Cylinder1(p, vec3(6.5,4.,-9.),vec3(6.,4.,0.), 0.5),\n    Cylinder1(p, vec3(-6.5,4.,-9.),vec3(-6.,4.,0.), 0.5)\n    );\n    \n    return V( Union2(v9, v8), i);\n    }\n    \nV CompleteTV(vec3 p){\n  V u= tele(p,5);\n  u=Union(u, ecran(p,6));\n  u=Union(u, metalBackTele(p,16));\n  u= Union(u,antenne(p,16));\n  u=Union(u, TVblock(p, 10));\n  u=Union(u, TVblock2(p, 2));\n  u=Union(u, plateTV(p, 16, 1));\n  u=Union(u, cadreEcran(p, 14));\n  u=Union(u, TvFoot(p, 11));\n  return u;\n}\n//Primitive V ///////////////\n\nV Cylinder(vec3 p, vec3 a, vec3 b, float r, int i){\n    return V(Cylinder1 (p, a, b, r), i);\n}\n\n\n\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nV Sphere(vec3 p, vec3 c,float r,int index)\n{\n  return V(length(p-c)-r,index);\n}\n\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\n\nV Plan(vec3 p, vec3 n, vec3 o,int index)\n{\n    return V(dot((p-o),n),index);\n}\n\n//Cube\n//c : center of skeleton\n//p : Position\n//h : hauteur\n//l : largeur\n//w : profondeur\nV Cube(vec3 p, vec3 c, float h, float l, float w, int i){  \n    vec3 q = abs(p-c) - vec3(h, l, w);\n    return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),i);\n}\n\nV CubeDice(vec3 p,vec3 c,float r,int index)\n{\n   vec3 q = abs(p-c) - vec3(r);\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),index);\n}\n\n\n\n//Capsule\n//p : Position\n//a : Extrémité 1\n//b : Extremité 2\n//r : rayon\nV Capsule(vec3 p, vec3 a, vec3 b, float r, int i){\n    vec3 u = normalize(b-a);\n    if(dot(p-a,u) < 0.){\n        return V(length(p-a) - r, i);\n        }\n    else if (dot(p-b,-u) < 0.){\n        return V(length(p-b) - r, i);\n        }\n    else {\n        return V(sqrt( length(p-a) * length(p-a) - dot(p-a, u) * dot(p-a, u)) - r, i);\n    }\n}\n\n\n\n// Dice \n// p : point\n// c : center \n// r : radius\nV Dice(vec3 p,vec3 c,float r,int index)\n{\n  return Intersect(CubeDice(p,c,0.75 * r,index),Sphere(p,c,r,index));\n}\n\n\n\n\n\n// Potential field of the object\n// p : point\nV object(vec3 p)\n{\n  V u = Lissage(Plan(modifierPlane(p, 20., 0., 5., 0.),vec3(0.0,0.0,1.0),vec3(0.0,0.0,-6.0),0),\n  Arrondi(Lissage(Cube(p, vec3( 0.0, 0, -8.), 8.5,5.5, 0.1, 0),\n  Capsule(p  , vec3( -0.1, -1.5, -8.), vec3( 0.1, 1.5,-8.), 0.25, 0), 15.), 1.),\n  5.);\n  \n  \n  /*u=Union(u,Dice(p,vec3( -15.0, 0.0, 2.0),4.0,13));\n  u=Union(u,Dice(p,vec3( 15.0, 0.0, 2.0),4.0,9));\n  u=Union(u,Dice(p,vec3( -8.0, 0.0, 2.0),4.0,16));\n  u=Union(u,Dice(p,vec3( 8.0, 0.0, 2.0),4.0,6)); \n  u=Union(u,Dice(p,vec3( 0.0, 0.0, 2.0),4.0,2)); \n  u=Union(u,Dice(p,vec3( -15.0, 0.0, 10.0),4.0,18));\n  u=Union(u,Dice(p,vec3( 15.0, 0.0, 10.0),4.0,19));\n  u=Union(u,Dice(p,vec3( -8.0, 0.0, 10.0),4.0,20));\n  u=Union(u,Dice(p,vec3( 8.0, 0.0, 10.0),4.0,21)); \n  u=Union(u,Dice(p,vec3( 0.0, 0.0, 10.0),4.0,22)); \n  u=Union(u,Dice(p,vec3( -15.0, 0.0, 17.0),4.0,17)); \n  u=Union(u,Dice(p,vec3( -8.0, 0.0, 17.0),4.0,10));\n  u=Union(u,Dice(p,vec3( 0.0, 0.0, 17.0),4.0,12));\n  u=Union(u,Dice(p,vec3( 8., 0.0, 17.0),4.0,23));\n  u=Union(u,Dice(p,vec3( 15., 0.0, 17.0),4.0,14));\n  u=Union(u,Dice(p,vec3( 15., 0.0, 24.0),4.0,15));\n  u=Union(u,Cube(p,vec3( 0.0, 0.0, -6),30., 15., 5.,23));*/\n  \n  \n  u = Union(u, CompleteTV(p)); \n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  V vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n    vec3 color1 = vec3(0.529, 0.808, 0.922);\n    vec3 color2 = vec3(0.529, 0.808, 0.980);\n    float coefficient = d.z * 0.5 + 0.5;\n    vec3 skyBlue = mix(color1, color2, coefficient);\n\n    return skyBlue;\n}\n\n\n// Direct lighting\nfloat Light(vec3 p,vec3 n)\n{\n   // point light\n  const vec3 lp = vec3(5.0, 10.0, 15.0);\n\n  vec3 l = normalize(lp - p);\n\n  // Phong shading\n  float diff = clamp(dot(n, l),0.0,3.0);\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,100.0,h,s);\nif (!h)\n    {\n     return diff;\n    }\n    return 0.0; \n}\n\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\nT Texture0(in vec3 p)\n{\n    vec3 grass1 = Color(0.2,0.6,0.2); // Vert foncé\n    vec3 grass2 = Color(0.4,0.8,0.4);\n    return Grass(p, grass1, grass2); \n}\n\nT Texture1(in vec3 p)\n{\n    return SimpleColor(p, Color(0.,0.,0.), 1.);  \n}\n\nT Texture2(in vec3 p)\n{\n    vec3 wood1 = Color(0.26, 0.05, 0.02);\n    vec3 wood2 = Color(0.4, 0.2, 0.1);\n    return woodMouss(p + 5., wood1, wood2, 50.); \n}\n\n\n\n\nT Texture4(in vec3 p)\n{\n  return T(\n    MergeColor(Color(0.6, 0.3, 0.2),  // Rouge brique\n        Color(0.8, 0.4, 0.3),           // Orange brique\n        Noise(p, 1.)),\n        0.1);\n}\n\nT Texture5(in vec3 p)\n{\n   // vec2 seed = vec2(gl_FragCoord.x * 20., gl_FragCoord.y * 20.6);\n    \n    return SimpleColor(p, Color(0.898, 0.906, 0.902), 1.0);\n\n}\n\nT Texture35(in vec3 p)//trop stylé cette texture\n{\n  return T(\n    MergeColor2(Color(0.2,0.8,0.4),  // Gris moyen\n        Color(0.6, 0.6, 0.6),           // Gris clair\n        Turbulence(p, 2.), Turbulence(p, 5.)),\n    0.1);  \n}\n\nT Texture6(in vec3 p)//trop stylé cette texture\n{\n  return T(//Voronoi(p + iTime),0.);\n   MergeColor(\n        Color(0.0, 0.0, 0.0),  // Rouge brique\n        Color(1., 1., 1.),\n        Noise(p + iTime, 0.1)),\n        1.); \n}\n\nT Texture7(in vec3 p)\n{\n    return T(\n    MergeColor(Color(0.0, 0.0, 0.0),  // Rouge brique\n        Color(1., 1., 1.),\n        Axial(RotateX(p,90.),1.+ iTime)),\n    0.25);  \n}\n\nT Texture8(in vec3 p)\n{\n   \n    return T(MergeColor(Color(0.0, 0.0, 0.0),  // Rouge brique\n        Color(1., 1., 1.),\n        Axial(RotateX(p,90.),1.+ iTime))\n    ,\n    0.0);  \n}\n\nT Texture9(in vec3 p)\n{\n\n    vec3 Lava1 = Color(1.0, 0.8, 0.0); \n    vec3 Lava2 = Color(1.0, 0.3, 0.0);  \n   \n    return Liquid(p, Lava1, Lava2, 2.); \n}\n\nT Texture10(in vec3 p){\n     return SimpleColor(p, Color(1.0, 0.749, 0.4),\n        1.0);\n}\n\nT Texture12(in vec3 p)\n{\n    vec3 wood1 = Color(0.788, 0.588, 0.454);\n    vec3 wood2 = Color(0.963, 0.873, 0.802);\n\n    return T( wood(p + 5., wood1, wood2), 0.8); \n}\n\nT Texture11(in vec3 p)\n{\n\n    vec3 wood1 = Color(0.4, 0.2, 0.1);\n    vec3 wood2 = Color(0.5, 0.3, 0.2);\n\n    return woodMouss(p + 5., wood1, wood2, 50.); \n}\n\nT Texture13(in vec3 p)\n{\n\n    vec3 water1 = Color(1., 1., 1.0); \n    vec3 water2 = Color(0.0, 0.5, 1.00);  \n   \n    return Liquid(p, water1, water2, 2.); \n}\n\nT Texture14(in vec3 p)\n{   \n    return Marbre(rotateXYZ(p, 90., 0., 0.),Color( 1.0, 1.0, 1.0), \n                     Color( 0.5, 0.5, 0.5), \n                     Color( 0.969, 0.894, 0.769),  2.); \n}\n\nT Texture15(in vec3 p)\n{\n    return MarbreSansVeine(p,Color( 1.0, 1.0, 1.0), Color( 0.969, 0.894, 0.769), 2.); \n}\n\nT Texture16(in vec3 p)\n{\n    return metalRust(p,4.); \n}\n\nT Texture17(in vec3 p)\n{\n   \n   return T(MergeColor(vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0),Voronoi(p + iTime, 2.))\n    ,\n    0.0);\n}\n\nT Texture18(in vec3 p, int i)\n{\n   \n   switch (i) {\n        case 0:\n            return Ore(p, vec3(0.0, 0.8, 0.8));\n            break;\n        case 1:\n            return Ore(p, vec3(0.0, 0.8, 0.4));\n            break;\n        case 2:\n            return Ore(p, vec3(0.8, 0.8, 0.8));\n            break;\n        \n        case 3:\n            return Ore(p, vec3(0.6, 0.0, 0.0));\n            break;\n        case 4:\n            return Ore(p, vec3(1.0, 0.8, 0.0));\n            break;\n        \n        default:\n            return Texture0(p);\n            break;\n    } \n }   \nT Texture19(in vec3 p)\n    {\n\n    return T(MergeColor(Marbre(rotateXYZ(p, 90., 0., 0.),Color( 0., 0., 0.0), \n                     Color( 1., 1., 1.), \n                     Color( 0.969, 0.894, 0.769),  1.).c, Marbre(rotateXYZ(p, 90., 0., 0.),Color( 1.0, 1.0, 1.0), \n                     Color( 0.5, 0.5, 0.5), \n                     Color( 0.969, 0.894, 0.769),  1.).c,\n                     Checker(p, 3.)),\n                     1.0);\n    }\n\n\n// Compute texture \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= object(p);\n    int index = vp.i;\n\n    switch (index) {\n        case 0:\n            return Texture0(p);\n            break;\n        case 1:\n            return Texture1(p);\n            break;\n        case 2:\n            return Texture2(p);\n            break;\n        \n        case 4:\n            return Texture4(p);\n            break;\n        case 5:\n            return Texture5(p);\n            break;\n        case 6:\n            return Texture6(p);\n            break;\n        case 7:\n            return Texture7(p);\n            break;\n        case 8:\n            return Texture8(p);\n            break;\n        case 9:\n            return Texture9(p);\n            break;\n        case 10:\n            return Texture10(p);\n            break;\n        case 11:\n            return Texture11(p);\n            break;\n        case 12:\n            return Texture12(p);\n            break;\n        case 13:\n            return Texture13(p);\n            break;\n        case 14:\n            return Texture14(p);\n            break;\n        case 15:\n            return Texture15(p);\n            break;\n        case 16:\n            return Texture16(p);\n            break;\n        case 17:\n            return Texture35(p);\n            break;\n        case 18:\n            return Texture18(p, 0);\n            break;\n        case 19:\n            return Texture18(p, 1);\n            break;\n        case 20:\n            return Texture18(p, 2);\n            break;\n        case 21:\n            return Texture18(p, 3);\n            break;\n        case 22:\n            return Texture18(p, 4);\n            break;\n        case 23:\n            return Texture19(p);\n            break;\n        default:\n            return Texture0(p);\n            break;\n    }\n    \n}   \n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p,l,100.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    vec3 lp = vec3(0.,20.,25.);\n    \n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    T tex=Color(p,n);\n\n    // Ambient color\n    vec3 ambient = 0.5*tex.c;\n        \n    // Shadow computation\n    float s = Shadow(p+0.01*n,n,l);\n\n// Phong diffuse\n    vec3 diffuse = 0.5  * clamp(dot(n, l),0.0,1.0) * tex.c;\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = tex.s * pow(clamp(dot(r,l),0.0,1.0),28.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + s * (diffuse + specular);\n    return c *1.2;\n}\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=false;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 200.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}