{"ver":"0.1","info":{"id":"4llfDs","date":"1515082157","viewed":4157,"name":"â™« [MAGFest] Station event","username":"patu","description":"TROUBLESHOOTING: Try to pause and start SoundCloud channel in Buf A \n-----\n\n\"Demoscene at MAGFest\" Remote compo entry.\nmusic: https://soundcloud.com/noisia/noisia-raw-synth-demosong-exiled\n\nhttp://www.pouet.net/prod.php?which=73281","likes":56,"published":1,"flags":96,"usePreview":0,"tags":["compo","magfest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\n MAGFest 2018 remote entry.\n http://super.magfest.org/guest2018/demoscene-at-magfest-2018/\n\n music: https://soundcloud.com/noisia/noisia-raw-synth-demosong-exiled\n \n\n\n http://bit.ly/shadertoy-plugin\n*/\n\nconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 \n        buff = texture(iChannel0, uv),\n    \tmipm = textureLod(iChannel0, uv, 4.);\n    \n    float dof = buff.a;\n    \n    // fake dof\n\tfragColor = mix(buff, mipm, min(1., dof * 18.));\n    \n    // fake bloom\n    vec4 bm = dot(mipm.rgb, W) >\n        dot(buff.rgb, W) ? mipm : buff;  \n    \n    fragColor += pow(bm * dot(bm.rgb, W) * 3., vec4(1.2)) * .6;\n        \n    // contrast\n    fragColor = pow(fragColor, vec4(1.15));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xd2XRc","filepath":"https://soundcloud.com/noisia/noisia-raw-synth-demosong-exiled","previewfilepath":"https://soundcloud.com/noisia/noisia-raw-synth-demosong-exiled","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define getNormal getNormalHex\n\n#define FAR 500.\n#define INFINITY 1e32\n#define time iChannelTime[1]\n#define mt iChannelTime[1]\n#define FOV 130.0\n#define FOG 1.\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nvec3 h;\nfloat part2Time;\n    \n// int hash\n#define kk 1103515245U\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*kk;\n    x = ((x>>8U)^x.yzx)*kk;\n    x = ((x>>8U)^x.yzx)*kk;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat vol = 0.;\n\nconst vec3 light = vec3(20., 1., -10.);        \nconst vec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { \n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec3 blob(vec3 bp) {\n    vec3 p = bp;\n    \n    bp.xzy *= 0.1;\n    \n    pR(bp.xz, iTime);\n    pR(bp.yx, iTime * .8 + vol * .0);\n    \n    bp.xyz += sin(  2.0*bp.yzx + vec2(0., iTime + vol).xxy);\n    bp.xyz -= sin(  4.0*bp.yzx + vec2(0., iTime + vol).yxx) * .5;\n    \n    return vec3(\n        mix(fBox(p, vec3(10.)), fSphere(bp, 1. + vol * .1), min(1., pow(vol, 1.2) * .3)),// + sin(p.x / 14. + p.z / 13. + t * 4.) * 2. ),\n        3.,\n        0.\n    );\n}\n\nvec3 map(vec3 o) {\n    \n    vec3 p = o;\n   \n    vec3 obj_blob = length(p) < 30. ? blob(p) : vec3(3., 0., 0.);\n    \n    vec3 \n        obj = vec3(FAR, -1.0, 0.0),\n        obj2 = obj,\n        stat;\n    \n    float mat = 2.;\n\n    pModPolar(p.zx, 16.);\n    \n    pMirrorOctant(p.zy, vec2(32., 12.));\n    pMirrorOctant(p.xz, vec2(16., 22.));\n    \n    pR(p.zy, 1.57 );\n    \n    p.x += 3.8;\n    \n    pModPolar(p.xz, 9.);\n\tpMirrorOctant(p.zy, vec2(6.4, .5));    \n    pMirrorOctant(p.xy, vec2(6.1, 4.));\n    \n    p.yx += 2.;\n\t\n    obj = vec3(\n        fBox2Cheap(p.xy, vec2(4.4, 1.5)),\n        mat,\n        0.\n    );\n    \n    p.z -= 12.;\n    \n    obj2 = vec3(\n        fBox(p, vec3(6., 2., .1)),\n        1.,\n        0.\n    );\n    \n    stat = opU2(obj, obj2);\n    obj = opU2(stat, obj_blob);\n    \n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 100;\n\nvec3 trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 0.003;\n    float functionSign = map(o).x < 0. ? -1. : +1.;\n    vec3 mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.x;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) return vec3(INFINITY, 0., 0.);\n    \n    return vec3(candidate_t, mp.yz);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 28;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = .9;\n    float dist = 0.25;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        shade = min(shade, k*h/dist);\n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.7), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).x;\n    return clamp(sdist / dist, 0.1, 1.0);\n}\n\nfloat tri( in vec2 p )\n{\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \n   float sunSize = 12.5;\n   float sunAmount = max(dot(rd, lightDir), 0.4);\n   float v = pow(abs(1.2 - max(rd.y, 0.0)), 5.1);\n   vec3 sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32) * 1.2, v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 442.0)* sunSize, 0.2 * sunSize);\n   return clamp(sky, 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, vec3 obj) {\n    vec3 col = vec3(.0);\n    \n    if (obj.y == 1.0) return vec3(1.);\n    if (obj.y == 2.0) return vec3(1., .7, 0.4);\n    if (obj.y == 3.0) return vec3(12., 12., 12.); \n     \n    return col;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec3 obj) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp - sp; \n    float lDist = max(length(ld / 2.), 0.001); \n    ld /= lDist;\n\n    float atten = 1.0 / (1.0 + lDist * 0.025 + lDist * lDist * 0.02);\n    float diff = max(dot(sn, ld), .1);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.2), 2.0);\n\n    vec3 objCol = getObjectColor(sp, sn, obj);\n    sceneCol += (objCol * (diff + .15) * spec * .5) * atten;\n   \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    \n    if (abs(uv.y) > .0 + min(.35, time * .065)) {\n     \tfragColor *= 0.;\n        return;\n    }\n    \n    part2Time = (max(79., time) - 79.);\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    uv.y *= 1.2;\n    vol = texture(iChannel1, vec2(.2, .25)).r  * 4.; \n\n    h = hash(uvec3((max(31., time + .1) - 31.) / 87. * 60. - 1.2)) * 2. + 3.;\n    \n    float \n        sk = sin(-time * .1 + h.b  + 1.) * 42.0, \n        ck = cos(-time * .1 + h.r ) * 42.0;    \n    \n    vec3 \n        vuv = vec3(0., 1., 0.),\n    \tro = vec3(ck, -2. + part2Time  * h.z * .25, sk),\n        vrp =  vec3(0., 15., 0.);\n    \n    vrp -= tri(vec2(ro.xz * .2));\n    vuv.x += tri(vrp.xy * .2) * .03;\n    \n    vec3\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n\t\n    ro.yx += tri(vec2(time * .2));\n    \n    rd = normalize(rd);\n    \n    vec3 tr = trace(ro, rd);    \n    \n    ro += rd * tr.x;\n    \n    vec3 oro = ro;\n    \n    vec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    vec3 skyns = Sky(rd, false, normalize(light)) * 1.;\n    vec3 otr = tr;\n    vec3 osn;\n    vec3 sn;\n    \n    vec3 sceneColor = sky;\n    \n    float dof = 0.;    \n    \n    if (tr.x < FAR) { \n        \n        sn = getNormal(ro);\n        osn = sn;\n        \n        sceneColor = saturate(doColor(ro, rd, sn, light, tr));\n        \n        dof = tr.x / FAR;\n        \n        if (tr.y == 3.) {\n            rd = reflect(rd, sn);\n            ro += rd * .01;\n            tr = trace(ro, rd); \n            ro += rd * tr.x;\n            \n            if (tr.x > FAR) {\n                sceneColor += Sky(rd, false, normalize(light)) * .75;\n            }\n        } else {\n            vec3 p2 = ro;\n            \n            pR(ro.yz, iTime * 3.);\n            sceneColor += max(0., 1. - blob(ro).x * .25) * 2. * vol * vec3(1., .5, .25) * .25;\n            ro = p2;\n        }\n        \n        sceneColor *= saturate(getAO(ro, sn, 6.0));\n        sceneColor = mix(sceneColor, skyns, saturate(otr.x * 4.7 / FAR));\n    }\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), dof) * clamp((107. - time) * .3, 0., 1.) ;\n}\n","name":"Buf A","description":"","type":"buffer"}]}