{"ver":"0.1","info":{"id":"ltdBDH","date":"1539552327","viewed":127,"name":"Character Project- Penguin","username":"tiff","description":"Penguin Character","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["penguin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\nmat2 rot2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co);\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x - sa*p.y, sa*p.x + ca*p.y, p.z);\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n//Cone shape\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0.)));\n\t}\n\treturn d;\n}\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat fOpUnionRound(float a, float b, float r) { //rounds intersection of two objects\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nfloat fOpUnionColumns(float a, float b, float r, float n) { //creates columns/ripples when the shapes/distance fields overlaps\n    //a 1st distance field\n    //b 2nd distance field\n    //r is how fast it's merging\n    //n is how many repitions/ripples/columns\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n//=======================\n\nShape character(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  vec3 h = c; // Head\n  vec3 b = c; // Body\n  vec3 rf = c; // Feet\n  vec3 lf = c;\n  vec3 a = c; // Arms \n  vec3 e = c; // Eyes\n  vec3 bk = c; //Beak  \n  vec3 ice = c; //iceberg\n  \n  \n    //Head\n    float head = sphere(h+vec3(0., -0.65, 0.),.75); //create head\n    vec4 hColor = vec4(.75, .9, 1., 1.);\n\n    \n    //Body\n    b.y *= .9;\n    float body = sphere(b+vec3(0., 0.5, 0.),.99); // create body\n    vec4 bColor = vec4(1., 1., 1., 1.);\n\n    \n \t//Feet\n    lf.yz *= rot(sin(iTime*1.5)*.2);\n    float feet1 = sphere(lf+vec3(.3, 1.5, -.2),.12); // create bottom of Feet\n    float feet2 = sphere(lf+vec3(.5, 1.5,.3),.12); // create top of Feet\n    float feet = fOpUnionRound(feet1, feet2, 1.); // merge to make one Feet\n    \n    rf.yz *= rot(cos(iTime*1.5)*.2);\n    float rfeet1 = sphere(rf+vec3(-.3, 1.5,- .2),.12); // create bottom of Feet\n    float rfeet2 = sphere(rf+vec3(-.5, 1.5,.3),.12); // create top of Feet\n    float rightfeet = fOpUnionRound(rfeet1, rfeet2, 1.); // merge to make one Feet\n    vec4 fColor = vec4(1.5, 1.2, -0.2, 1.);\n    \n    //Arms\n    a.x = abs(a.x) -2.;\n    \n    a.y *= cos(sin(a.x*1.8))*.5;\n    a.z *= cos(sin(a.x*2.5));\n    a.zx *= cos(sin(60.))*.75;\n    float arm = sphere(a + vec3(.85, 0.2, .25), .2);\n    \n    //Eyes\n    e.x = abs(e.x) -1.;\n    float eyes = sphere(e+vec3(.75, -.63, .75),.2);\n    float pupil = sphere(e+vec3(.78, -.6, .6),.12);\n    //Pupil Color\n    vec4 eColor = vec4(-.5, -.5, -.5, 1.);\n    vec4 pColor = vec4(2., 2., 2., 1.);\n    \n     //Beak\n    bk -= vec3(0.,0.25,-.7); //moving the center to (0,1,0)\n    //if bk was (0,1,0) it will now be (0,1,0)-(0,1,0)=(0,0,0) center\n    \n    pModPolar(bk.zy, 1.0); \n    bk -= vec3(0.,0.,0.); //moving center after modpolar making it happen 12 times\n    bk.yz *= rot(radians(-90.0)); //rotate beak\n    \n    bk.z *=1.7;//compress beak\n    float beak = fCone(bk, .2 ,.3);\n    vec4 bkColor = vec4(1.2, 1.2, .1, 1.);\n\n    \n    //Iceberg\n    float iceberg = fCylinder(ice+vec3(0., 1.7, 0.), 1.75, .075);\n    vec4 iceColor = vec4(.1, .5, .7, 1.);\n    \n    \n    \n    //draw shapes to screen\n    shape.dist = fOpUnionRound(head, body, .25); //merge head and body\n    shape.dist = min(shape.dist, feet);\n    shape.dist = min(shape.dist, rightfeet);\n    \n    shape.dist = fOpUnionRound(shape.dist, arm, .06);\n    shape.dist = max(shape.dist, -eyes);\n    shape.dist = min(shape.dist, pupil);\n    shape.dist = min(shape.dist, beak);\n    shape.dist = min(shape.dist, iceberg);\n    \n    shape.color = mix(hColor, bColor, mixColors(head, body, 0.5));\n    shape.color = mix(shape.color, fColor, mixColors(feet, body, .3));\n    shape.color = mix(shape.color, fColor, mixColors(rightfeet, body, 0.3));\n    shape.color = mix(shape.color, bkColor, mixColors(beak, shape.dist, .01));\n    shape.color = mix(shape.color, iceColor, mixColors(iceberg, body, 1.));\n    shape.color = mix(shape.color, eColor, mixColors(eyes, shape.dist, 0.01));\n    shape.color = mix(shape.color, pColor, mixColors(pupil, shape.dist, 0.01));\n\n    \n\n    \n  return shape;\n}\n\n\nShape map(vec3 c){\n  //c.xz *= rot(iTime);\n    \n  Shape face = character(c);\n  return face;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -5.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n    scene.xy *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}