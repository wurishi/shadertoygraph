{"ver":"0.1","info":{"id":"4fjXRK","date":"1706549766","viewed":78,"name":"weird gama build","username":"chenxianming","description":"weird gama build","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Raymarching template from\n    Tutorial: youtu.be/PGtv-dBi2wE\n*/\n\n\n#define I iResolution\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define rot( a ) mat2( cos( a + vec4( 0, 11, 33, 0 ) ) )\n#define s vec4(1, 1, v*2, 1)\n#define smax( a, b ) sm( a, b, .15 )\n#define v 6 // this for layers\n\n// smax\nfloat sm(float a, float b, float c) {\n    float d = clamp(.5 + .5 * (-b + a) / c, 0., 1.);\n    return -(mix(-b, -a, d) - c * d * (1. - d));\n}\n\nfloat prisDist( vec3 p ){\n    return smax(\n        smax(\n            abs( p.x ),\n            abs( p.z )\n        ) - s.w * p.y,\n        abs( p.y ) - s.w\n    );\n}\n\nfloat intri( vec3 p, int l ){\n    \n    vec3 q = p, b = p;\n    b.y += float(l);\n    float d = 1., pDist;\n    \n    int j = l-1;\n    \n    for( float i = float(l); i > 1.; i-- ){\n        int od = int(i) % 2;\n        \n        q = b;\n        q.y -= i;\n        \n        if( od > 0 ){\n            q.xz -= 2. * clamp( round( q.xz / 2. ), -( floor(i/2.)), ( floor(i/2.)) );\n        }else{ // also can be used\n            for( float j; j < i-1.; j++ )\n                q.xz = abs(q.xz) - 1.;\n        }\n        \n        pDist = prisDist( q );\n        d = min(d, pDist);\n    }\n    \n    q = b;\n    q.y -= 1.;\n    pDist = prisDist( q );\n    d = min(d, pDist);\n\n    return d;\n}\n\nfloat GetDist(vec3 p) {\n\n    vec3 q = s.xyz - p;\n    q.xz *= rot( iTime * .2 );\n    vec3 q2 = q;\n    \n    float d = intri( q, v );\n    \n    \n    float planeDist = p.y;\n    \n    d = min(d, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 6);\n    lightPos.xz -= vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = ( V + V - I.xy ) / I.y;\n\n    // Time varying pixel color\n    vec3 col = vec3( 0 );\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(u.x, u.y, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n\n    // Output to screen\n    U = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}