{"ver":"0.1","info":{"id":"wtlyzX","date":"1592678627","viewed":289,"name":"test:secondAttempt tri-planar","username":"mehow_one","description":"Second attempt at 3-planar mapping.\n","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["triplanar","uv","planar","coord"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = normalize(vec3(0, 1, 0));\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n)\n{\n    vec3 blending = abs(p);\n    blending = normalize(max(blending, 0.00001));\n    \n    // normalized total value to 1.0\n    float b = (blending.x + blending.y + blending.z);\n    blending /= b;\n    \n    vec4 xaxis = texture(tex, p.yz);\n    vec4 yaxis = texture(tex, p.xz);\n    vec4 zaxis = texture(tex, p.xy);\n    \n    // blend the results of the 3 planar projections.\n    return (xaxis * blending.x + yaxis * blending.y + zaxis * blending.z).rgb;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdSphere(vec3 p, vec3 offs, float r)\n{\n    return length(p - offs) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat map(vec3 p)\n{\n    float d1 = sdSphere(p, vec3(-1, sin(iTime)*-1., 0), 1.0);\n    float d2 = sdBox(p, vec3(0.5));\n    return smin(d1, d2, .4);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - e.xyy*p),\n        map(p - e.yxy*p),\n        map(p - e.yyx*p));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(0);\n    \n    float time = iTime * 0.5;\n    vec3 ro = vec3(cos(time) * 7., 2., sin(time) * 7.);\n    vec3 ta = vec3(0);\n    \n    vec3 p = ro;\n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.5));\n    \n    float d = 0., t = 0.;\n\n    for (int i = 0; i < 64; i++)\n    {\n        d = map(p);\n        if (d < 0.01) break;\n        p += ray * d;\n    }\n    \n    if (d < 0.01)\n    {\n        vec3 n = normal(p);\n        vec3 tex = tex3D(iChannel0, p, n);\n        col = tex;\n    }\n    else\n    {\n    \tvec3 sky = vec3(0.5, 0.8, 1.5) * abs(1.0 - uv.y);\n    \tcol = sky;\n    }\n    \n    col.rgb = pow(col.rgb,vec3(1./1.65));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}