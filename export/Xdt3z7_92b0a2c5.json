{"ver":"0.1","info":{"id":"Xdt3z7","date":"1448670140","viewed":379,"name":"BinaryTreeAnim","username":"jt","description":"A growing binary tree with polar-coordinates.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["animated","branching","binarytree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Animated (growing) Binary Tree variant with (almost) fix line-size - written 2015 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Overview:\n// This tree is basically made by repeating a Y shaped branch\n// and then bending the coordinate-system (rectangular to polar).\n// To understand the steps:\n// Like applying fract() on texture coordinates can be used to repeat the texture,\n// what I do here is using something similar to repeat the Y shaped branch.\n// The essence is shown in https://www.shadertoy.com/view/ll2SW3 BinarySubDiv2.\n// First logarithm is applied to the coordinates\n// (scaled coordinates are mapped to linear coordinates),\n// followed by ceil (to partition the coordinates into a \"staircase\" pattern),\n// then exp is used to transform everything back.\n// The difference between the original coordinates\n// and the coordinates modified as described gives the local coordinates,\n// which are used to render the Y-shapes.\n// Some additional code is required to end the repetition sideways.\n// To construct the Y-shaped branch we need at least a diagonal line,\n// mirrored in the top half using the abs function,\n// as in e.g. https://www.shadertoy.com/view/lljXW3 BinaryTree2Fix.\n// To obtain a nicer branch a sine function or parabolic arcs can be used.\n// Also the coordinates are transformed from rectangular to polar,\n// as in https://www.shadertoy.com/view/4dcGzS BinarySubDiv2Polar.\n// Finally for the animation the scaling parameters are coupled to the timer.\n\n#define pi 3.1415926\n\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\nfloat C01(float v)\n{\n    v += .25;\n    float w = abs(2. * fract(v*2.) - 1.);\n    return 0.5 + 0.5 * sign(.5-fract(v))*(1.-w*w);\n}\n/*\nfloat c01(float v)\n{\n    return 0.5 + 0.5 * cos(2.0 * 3.1415926 * v);\n}\n*/\nvoid mainImage( out vec4 o, in vec2 U )\n//void mainImage( inout vec4 o, vec2 U ) // ERROR: overloaded functions must have the same parameter qualifiers\n{\n    U /= iResolution.xy;\n    U = 2.*U-1.;\n    U.y += 1.1;\n    U *= .5;\n    U.x *= iResolution.x / iResolution.y;\n    U.xy = U.yx;\n    U = vec2(atan(U.y, U.x) / pi, length(U));\n    //U.x *= .5;\n    //U.y = 2./(2.-U.y) - 1.;\n    U.y = 1.-log2(2.-U.y);\n    float y = (1.-U.y);\n    float n = 7.;\n    //float t = (1.-mirror(iTime*.1));\n    float t = .9*(1.-C01(iTime*.05));\n    float f = n*t;\n    U.y *= n;//f;\n    //U.x = .5+.5*clamp((2.*U.x-1.)/t,-1.,1.);\n    U.x = clamp((2.*U.x+t/2.)/t,0.,1.);\n    U.x *= exp2(ceil(U.y))/2.;\n    U = fract(U);\n    o -= o;\n    //o += 1. - smoothstep(0., n*(.02 - .01 * U.y)/t, abs(4. * abs(U.x - .5) - C01(.5 * (U.y + 1.0)))); // \"plant\"\n    o += 1. - smoothstep(0., n*(.02 - .01 * U.y)/y/t, abs(4. * abs(U.x - .5) - C01(.5 * (U.y + 1.0)))); // fixed size\n    o *= smoothstep(n-f-.1,n-f,y * n);\n}\n","name":"Image","description":"","type":"image"}]}