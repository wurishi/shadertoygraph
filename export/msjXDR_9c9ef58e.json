{"ver":"0.1","info":{"id":"msjXDR","date":"1670173979","viewed":2197,"name":"Curved Surface Reflection","username":"NuSan","description":"Test reflection of rays on curved surface\nClick and drag on the control points to change the surface\nTop-left knob control the \"spread\" of the emitted light\nOther settings are in the \"Common\" tab","likes":118,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Test reflection of rays on curved surface\n// Click and drag on the control points to change the surface\n// Top-left knob control the \"spread\" of the emitted light\n// Other settings are in the \"Common\" tab\n\nvec2 GetCurvePos(int i) {\n    return texture(iChannel0, vec2(float(i)/float(line_points-1),(0.5)/iResolution.y)).xy;\n}\n\nvec2 GetCtrlPos(int i) {\n    return texture(iChannel0, vec2((float(i)+0.5)/float(iResolution.x),(1.5)/iResolution.y)).xy;\n}\n\nvec4 GetValue(int idx) {\n    return texture(iChannel0, vec2((float(idx)+0.5)/float(iResolution.x),(5.5)/iResolution.y));\n}\n\nvec4 GetUIValue(int idx) {\n    return texture(iChannel0, vec2((float(idx)+0.5)/float(iResolution.x),(1.5)/iResolution.y));\n}\n\nvec4 CurveAABB;\nvec3 CurveBounds;\nvoid FindCurveBounds() {\n    CurveAABB=vec4(10000,10000,-10000,-10000);\n    for(int i=0; i<line_points; ++i) {\n        vec2 pos = GetCurvePos(i);\n        CurveAABB.xy = min(CurveAABB.xy, pos);\n        CurveAABB.zw = max(CurveAABB.zw, pos);\n    }\n    vec2 center=(CurveAABB.xy+CurveAABB.zw)*0.5;\n    CurveBounds=vec3(center, length(center-CurveAABB.xy));\n}\n\nbool curveIntersection(vec2 Start, vec2 End, out vec2 p, out vec2 t) {\n    bool res=false;\n    float mindist=10000.0;\n    int inter=0;\n    vec2 prev=vec2(0);\n    for(int i=0; i<line_points; ++i) {\n        vec2 pos = GetCurvePos(i);\n        if(i>0) {\n           vec2 cp=vec2(0);\n           if (lineIntersection(Start, End, pos, prev, cp)) {\n               float ls=lengthSquared(Start, cp);\n               if(ls < mindist) {\n                   res=true;\n                   inter=i;\n                   p=cp;\n                   t=pos-prev;\n                   mindist=ls;\n               }\n           }\n        }\n        prev=pos;\n    }\n    if(res) {\n        vec2 p0 = GetCurvePos(inter-2);\n        vec2 p1 = GetCurvePos(inter-1);\n        vec2 p2 = GetCurvePos(inter);        \n        vec2 p4 = GetCurvePos(inter+1);\n        vec2 t1 = (p2-p0);\n        vec2 t2 = (p4-p1);\n        float perc = NearestPercentSegment(p, p1, p2);\n        \n        t = mix(t1,t2,perc);\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.y;\n    \n\tvec3 color = vec3(0);\n    \n    color = texture(iChannel0, fragCoord.xy/iResolution.xy).xyz;\n    if(fragCoord.y<2.0) color=vec3(0);\n    \n    // tonemapping\n    color = smoothstep(0.,1.,color);\n    color = pow(color, vec3(0.4545));\n    \n    vec2 rayp0 = GetCtrlPos(ctrl_points);\n    vec2 rayp1 = GetCtrlPos(ctrl_points+1);\n    vec2 rayp2 = GetCtrlPos(ctrl_points+2);\n    vec2 raymid = (rayp0+rayp1)*0.5;\n\n    if(DrawUI) {\n        /*\n        FindCurveBounds();\n        vec2 diffbound=abs(uv-CurveBounds.xy)-(CurveAABB.zw-CurveAABB.xy)*0.5;\n        color += vec3(0.5,0,0.5)*smoothstep(0.005,0.002,abs(max(diffbound.x, diffbound.y))); \n        color += vec3(0.5,0.5,0.0)*smoothstep(0.005,0.002,abs(length(uv-CurveBounds.xy)-CurveBounds.z)); \n        */\n        \n\n        color += vec3(0.5)*smoothstep(0.01,0.,distanceToSegment(uv, rayp0, rayp1));\n        color += vec3(0.5)*smoothstep(0.01,0.,distanceToSegment(uv, ButtonSpread, rayp2));\n\n        vec2 mousePos = (iMouse.xy-iResolution.xy*0.5) / iResolution.y;\n        vec2 mousePosClick = (iMouse.zw-iResolution.xy*0.5) / iResolution.y;\n\n        // Full Curve\n        vec2 prev=vec2(0);\n        float curvenear=10000.0;\n        for(int i=0; i<line_points; ++i) {\n            vec2 pos = GetCurvePos(i);\n            if(i>0) {\n                curvenear=min(curvenear, distanceToSegmentSquared(uv, prev, pos));\n            }\n            //color += vec3(1,0,0)*smoothstep(0.01,0.009,length(uv-pos));\n            prev=pos;\n        }\n        color += vec3(.7)*smoothstep(0.005,0.003,sqrt(curvenear)); \n\n        // Control Points\n        prev=vec2(0);        \n        float ctrlnear=10000.0;\n        float psize = 0.015;\n        for(int i=0; i<ctrl_points; ++i) {\n            vec2 pos = GetCtrlPos(i);\n            if(i>0) {\n                ctrlnear=min(ctrlnear, distanceToSegmentSquared(uv, prev, pos));               \n            }\n            ctrlnear=min(ctrlnear, max(abs(dot(uv-pos,uv-pos)-psize*psize*2.)-psize*psize*0.1,0.));\n            prev=pos;\n        }\n        \n        \n        int mousePoint = int(GetValue(1).x);\n        float nearestmousedist=100.0;\n        vec2 nearmousepoint=vec2(0);\n        for(int i=0; i < ctrl_points + ButtonNumber; ++i) {\n            vec2 pos = GetCtrlPos(i);\n            ctrlnear=min(ctrlnear, max(abs(dot(uv-pos,uv-pos)-psize*psize*2.)-psize*psize*0.1,0.));\n            float distmouse=length(mousePos-pos);\n            if(i == mousePoint) {\n                nearestmousedist=distmouse;\n                nearmousepoint=pos;\n            }\n            prev=pos;\n        }\n        \n        ctrlnear=sqrt(ctrlnear);        \n        \n        float bdist=length(ButtonSpread-uv);\n        //ctrlnear=min(ctrlnear,3.* min(abs(bdist-.01), abs(bdist-length(rayp2-ButtonSpread))));\n        ctrlnear=min(ctrlnear,3.* abs(bdist-.01));\n        \n        color += vec3(0.6)*smoothstep(psize,psize*0.2,ctrlnear); \n        if(mousePoint>=0) {\n            color += vec3(0.5)*smoothstep(psize,psize*0.9,length(uv-nearmousepoint));\n        }    \n    }\n        \n    if(DrawTestRay) {\n        \n        vec2 rayaxe = (rayp1-rayp0);\n        vec2 rayaxen = normalize(rayaxe);\n        vec2 raynorm = vec2(-rayaxen.y, rayaxen.x);\n        float rayrealspread = length(rayp2-ButtonSpread);\n        \n        vec2 raystart = raymid - rayaxen*0.0;\n        vec2 raydir = normalize(raynorm + rayaxen * (rayrealspread*(sin(iTime)*0.5)));\n        float maxraydir=10.0f;\n\n        for(int i=0; i<maxReflect; ++i) {\n\n            vec2 p;\n            vec2 t;\n            if (!curveIntersection(raystart, raystart + raydir*maxraydir, p, t))\n            {\n                color += vec3(0,1,0) * smoothstep(0.005,0.002,distanceToSegment(uv, raystart, raystart + raydir*maxraydir)); \n                break;\n\n            }\n\n            vec2 n=normalize(vec2(t.y, -t.x));\n\n            color += vec3(0,1,0) * smoothstep(0.005,0.002,distanceToSegment(uv, raystart, p)); \n            if (length(p - uv) < 0.02)\n            {\n                color = vec3(0,0,1);\n            }\n\n            color += vec3(0,1,1) * smoothstep(0.005,0.002,distanceToSegment(uv, p, p+n*0.1)); \n\n\n            raystart=p-raydir*0.01;\n\n            raydir=reflect(raydir, n);\n\n        }\n    }\n    \n    float h=fragCoord.x/iResolution.x;\n    //if(fragCoord.y<100.0) color=max(vec3(1.-h*2.,1.-abs(h-.5)*2.,h*2.-1.),0.);\n                \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float rayangle = 0.3;\nconst float rayspread = 0.2;\nconst vec2 raybase = vec2(0.6f,0.0f);\n\nvec4 getPoint(float p) {\n    p=clamp(p, 0.0, float(ctrl_points)-1.0);\n    return texture(iChannel0, vec2((p+0.5)/float(iResolution.x),1.5/iResolution.y));\n}\n\nvec4 GetValue(int idx) {\n    return texture(iChannel0, vec2((float(idx)+0.5)/float(iResolution.x),(5.5)/iResolution.y));\n}\n\nvec2 GetCtrlPos(int i) {\n    return texture(iChannel0, vec2((float(i)+0.5)/float(iResolution.x),(1.5)/iResolution.y)).xy;\n}\nvec2 GetCurvePos(int i) {\n    return texture(iChannel0, vec2(float(i)/float(line_points-1),(0.5)/iResolution.y)).xy;\n}\n\nbool curveIntersection(vec2 Start, vec2 End, out vec2 p, out vec2 t) {\n    bool res=false;\n    float mindist=10000.0;\n    int inter=0;\n    vec2 prev=vec2(0);\n    for(int i=0; i<line_points; ++i) {\n        vec2 pos = GetCurvePos(i);\n        if(i>0) {\n           vec2 cp=vec2(0);\n           if (lineIntersection(Start, End, pos, prev, cp)) {\n               float ls=lengthSquared(Start, cp);\n               if(ls < mindist) {\n                   res=true;\n                   inter=i;\n                   p=cp;\n                   //t=pos-prev;\n                   mindist=ls;\n               }\n           }\n        }\n        prev=pos;\n    }\n    if(res) {\n        vec2 p0 = GetCurvePos(inter-2);\n        vec2 p1 = GetCurvePos(inter-1);\n        vec2 p2 = GetCurvePos(inter);        \n        vec2 p4 = GetCurvePos(inter+1);\n        vec2 t1 = (p2-p0);\n        vec2 t2 = (p4-p1);\n        float perc = NearestPercentSegment(p, p1, p2);\n        \n        t = mix(t1,t2,perc);\n    }\n    return res;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = (iMouse.xy-iResolution.xy*0.5) / iResolution.y;\n    \n    vec4 prevColor = texture(iChannel0, fragCoord/iResolution.xy);\n    bool init = iFrame<1;\n\n    vec4 col=vec4(0);\n    if(fragCoord.y<1.0) {\n        // Smoothed Curve\n        float prog=((float(fragCoord.x))/float(iResolution.x)) * float(ctrl_points);\n        vec4 p1 = getPoint(floor(prog)-1.0);\n        vec4 p2 = getPoint(floor(prog)-0.5);        \n        vec4 p3 = getPoint(floor(prog)+0.5);\n        vec4 p4 = getPoint(floor(prog)+1.0);\n        \n        vec4 p5 = mix(p2, 2.0*p2-p1, fract(prog));\n        vec4 p6 = mix(2.0*p3-p4, p3, fract(prog));\n        col = mix(p5, p6, fract(prog));\n        //col = mix(p1, p2, fract(prog));        \n        \n    } else if(fragCoord.y<2.0) {\n        // Control Curve\n        int idx=int(fragCoord.x)+1;\n        float prog=float(idx)/float(ctrl_points);\n        bool viewinit=false;\n        if(init || viewinit) {\n            col.xy=vec2(cos(prog*3.2+1.7)*0.8, sin(prog*3.5+1.7)*0.45+prog*0.5-0.24);\n            if(idx==(ctrl_points+1)) {\n                col.xy=raybase-vec2(0,rayspread*0.5);\n            }\n            if(idx==(ctrl_points+2)) {\n                col.xy=raybase+vec2(0,rayspread*0.5);\n            }\n            if(idx==(ctrl_points+3)) {\n                col.xy=ButtonSpread+normalize(vec2(1,-1))*rayspread;\n            }\n        } else {\n            col = prevColor;\n            int mousePoint = int(GetValue(1).x)+1;\n            if(iMouse.w<=0.0) { // not the frame clicked, as there is a one frame latency on the selected point\n                if(idx==mousePoint) {\n                    col.xy = mousePos;\n                }\n            }\n        }\n    } else {    \n        // raycast image\n        \n        vec2 rayp0 = GetCtrlPos(ctrl_points);\n        vec2 rayp1 = GetCtrlPos(ctrl_points+1);\n        vec2 rayp2 = GetCtrlPos(ctrl_points+2);\n        vec2 raypos = (rayp0+rayp1)*.5;\n        vec2 rayaxe = (rayp1-rayp0);\n        vec2 rayaxen = normalize(rayaxe);\n        vec2 raynorm = vec2(-rayaxen.y, rayaxen.x);\n        float rayrealspread = length(rayp2-ButtonSpread);\n                \n        vec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.y;\n        float maxraydir=10.0f;\n        vec3 color=vec3(0);\n        for(int j=0; j<ray_per_frame; ++j) {\n            vec3 rr = rnd3(vec3(uv, fract(iTime*0.1)+float(j)));\n            //vec2 rr = hash23(vec3(fragCoord.xy, fract(iTime)));\n            float h=(float(j)+rr.x)/float(ray_per_frame);\n            float v=rr.y;\n            //float h=rr.x;\n            //float v=(float(j)+rr.y)/float(ray_per_frame);\n            vec2 raystart = raypos + rayaxe*(h-0.5);\n            vec3 addcol = max(vec3(1.-h*2.,1.-abs(h-.5)*2.,h*2.-1.),0.);\n            vec2 raydir = normalize(raynorm + rayaxen * (rayrealspread*(v-0.5)));\n            //vec2 raydir = -normalize(rayp2-raystart);\n            raystart-=raydir;\n            for(int i=0; i<maxReflect; ++i) {\n\n                vec2 p;\n                vec2 t;\n                if (!curveIntersection(raystart, raystart + raydir*maxraydir, p, t))\n                {\n                    float dist = distanceToSegment(uv, raystart, raystart + raydir*maxraydir);\n                    color += addcol*clamp(1.-dist/rayblur,0.,1.); \n                    break;\n\n                }\n\n                vec2 n=normalize(vec2(t.y, -t.x));\n\n                float dist = distanceToSegment(uv, raystart, p);\n                color += addcol*clamp(1.-dist/rayblur,0.,1.); \n                raystart=p-raydir*0.01;\n                raydir=reflect(raydir, n);\n            }\n        }\n        color *= luminosity/float(ray_per_frame);\n        \n        vec3 histo = prevColor.xyz;\n        // spatial blur\n        if(spatialBlur) {\n            float blurdist=rnd3(vec3(uv, fract(iTime)+7.3)).x*2.0;\n            histo += texture(iChannel0, (fragCoord+vec2(blurdist,0))/iResolution.xy).xyz;\n            histo += texture(iChannel0, (fragCoord-vec2(blurdist,0))/iResolution.xy).xyz;\n            histo += texture(iChannel0, (fragCoord+vec2(0,blurdist))/iResolution.xy).xyz;\n            histo += texture(iChannel0, (fragCoord-vec2(0,blurdist))/iResolution.xy).xyz;\n            histo *= 0.2;\n        }\n        \n        col.xyz = mix(color, histo, timeblur);\n    }\n    \n    if(int(fragCoord.x) == 1) {\n        if(int(fragCoord.y) == 5 ) {\n            col = prevColor;\n            if(iMouse.w>0.0) {\n                vec2 mousePosClick = (iMouse.zw-iResolution.xy*0.5) / iResolution.y;\n\n                float nearestmousedist=100.0;\n                vec2 nearmousepoint=vec2(0);\n                int nearmouseIndex=-1;\n                for(int i=0; i<ctrl_points+ButtonNumber; ++i) {\n                    vec2 pos = texture(iChannel0, vec2((float(i)+0.5)/float(iResolution.x),(1.5)/iResolution.y)).xy;\n                    float distmouse=length(mousePos-pos);\n                    if(distmouse<nearestmousedist) {\n                        nearestmousedist=distmouse;\n                        nearmousepoint=pos;\n                        nearmouseIndex=i;\n                    }\n                }\n                if(nearestmousedist<0.05) {\n                    col.x=float(nearmouseIndex);\n                } else {\n                    col.x=-1.;\n                }\n            }\n            if(init) col.x=-1.0;\n        }\n    }\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\nconst int line_points=30;\nconst int ctrl_points=6;\nconst int maxReflect=6;\nconst int ray_per_frame=20;\nconst float timeblur=0.9;\nconst float luminosity=6.0;\nconst float rayblur = 0.02;\n\n\nconst bool spatialBlur = false;\n\nconst bool DrawUI = true;\nconst bool DrawTestRay = false;\n\nconst int ButtonNumber = 3;\nconst vec2 ButtonSpread = vec2(-0.75,0.35);\n\nfloat rnd(float t) {\n    return fract(sin(t*547.824)*324.384);\n}\n\nvec3 rnd3(vec3 t) {\n    return fract(sin(t*547.824 + t.yzx*827.398 + t.zxy*241.154)*324.384);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//length squared\nfloat lengthSquared(vec2 v, vec2 w)\n{\n    return (v.x - w.x) * (v.x - w.x) + (v.y - w.y) * (v.y - w.y);\n}\n\n//Returns squared distance between point p and line segment L defined by endpoints LA, LB\nfloat distanceToSegmentSquared(vec2 p, vec2 LA, vec2 LB)\n{\n    //distance of line segment\n    float l2 = lengthSquared(LA,LB);\n    //If line segment is 0 length, just get difference with first endpoint\n    if (l2 == 0.0) \n        return lengthSquared(p, LA);\n    \n    //Vector representation of L\n    vec2 v = LB - LA;\n    vec2 w = p - LA;\n    \n    //t is percentage along line L point p falls\n    float t = dot(w,v) / l2;  \n    t = clamp(t,0.0,1.0);\n    \n    //projection of p onto v,w is nearest point\n    vec2 nearestPoint = vec2(LA.x + t * v.x, LA.y + t * v.y);\n    \n    //Distance between p and projectedpoint\n    return lengthSquared(p, nearestPoint);\n}\n\n\nfloat NearestPercentSegment(vec2 p, vec2 LA, vec2 LB) {\n//distance of line segment\n    float l2 = lengthSquared(LA,LB);\n    //If line segment is 0 length, just return 0\n    if (l2 == 0.0) \n        return 0.0;\n    \n    //Vector representation of L\n    vec2 v = LB - LA;\n    vec2 w = p - LA;\n    \n    //t is percentage along line L point p falls\n    float t = dot(w,v) / l2;  \n    t = clamp(t,0.0,1.0);\n    \n    return t;\n}\n\nfloat distanceToSegment(vec2 p, vec2 v, vec2 w)\n{\n    return sqrt(distanceToSegmentSquared(p,v,w));\n}\n\n//Cross product of 2d vectors returns scalar\n//1 = perpendicular, 0 = colinear\nfloat cross2D(vec2 v1, vec2 v2)\n{\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\n//Line intersection algorithm\n//Based off Andre LeMothe's algorithm in \"Tricks of the Windows Game Programming Gurus\".\nbool lineIntersection(vec2 L1A, vec2 L1B, vec2 L2A, vec2 L2B, out vec2 p)\n{\n    vec2 v1 = L1B - L1A;\n    vec2 v2 = L2B - L2A;\n    float d = cross2D(v1,v2);\n   \n    vec2 LA_delta = L1A - L2A;\n\n    float s = cross2D(v1,LA_delta) / d;\n    float t = cross2D(v2,LA_delta) / d;\n    \n    if (s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0)\n    {\n        p = vec2(L1A.x + (t * v1.x), L1A.y + (t * v1.y)); \n        return true;\n    }\n    return false;\n}\n\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}]}