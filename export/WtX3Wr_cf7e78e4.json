{"ver":"0.1","info":{"id":"WtX3Wr","date":"1559159660","viewed":989,"name":"Egg Sac","username":"trevorleake","description":"A raymarching scene of a lovely pulsating egg sac. This is a first pass. I'm now looking to take away the four ugly vertical lines of symmetry.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","light","scattering","subsurface","scene","eggs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\nmat3 rotateX(float angle)\n{\n    return mat3(1, 0, 0,\n                0, cos(angle), sin(angle),\n                0, -sin(angle), cos(angle));\n}\nmat3 rotateY(float angle)\n{\n    return mat3(cos(angle), 0, sin(angle),\n                0, 1, 0,\n                -sin(angle), 0, cos(angle));\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute(vec4 x) {\n  return mod289((34.0 * x + 1.0) * x);\n}\n\n// Modulo 7 without a division\nvec4 mod7(vec4 x) {\n  return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 cellular2x2(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define K2 0.0714285714285 // K/2\n#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\tvec2 Pi = mod289(floor(P));\n \tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 ox = mod7(p)*K+K2;\n\tvec4 oy = mod7(floor(p*K))*K+K2;\n\tvec4 dx = Pfx + jitter*ox;\n\tvec4 dy = Pfy + jitter*oy;\n\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t// Sort out the two smallest distances\n#if 0\n\t// Cheat and pick only F1\n\td.xy = min(d.xy, d.zw);\n\td.x = min(d.x, d.y);\n\treturn vec2(sqrt(d.x)); // F1 duplicated, F2 not computed\n#else\n\t// Do it right and find both F1 and F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx;\n\td.y = min(d.y, d.z);\n\td.y = min(d.y, d.w);\n\treturn sqrt(d.xy);\n#endif\n}\n\n\n\n\n\n\nfloat signedDistanceRoundCone( in vec3 position, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(position.xz), position.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\nvec3 bend(vec3 position, float k) \n{\n    float c = cos(k*position.x);\n    float s = sin(k*position.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*position.xy, position.z);\n}\n\nvec3 twist(vec3 position, float k) \n{\n    float c = cos(k*position.y);\n    float s = sin(k*position.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*position.xz,position.y);\n}\n\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\n\nfloat distanceMap(in vec3 position) \n{\n    position = bend(position, .2+-.1*cos(iTime*10.));\n    position = twist(position, .1*sin(iTime*20./2.)).yzx;\n    \n    float value = 1e10;\n    value = signedDistanceRoundCone(position, .35+.05*sin(iTime), .1, 1.6);\n//\tvalue = min(value, sdEllipsoid(position, vec3(.35, .35, -.3)));\n    \n    return min(1e10, value);\n}\n\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float initialLength = 1.;\t\t// Length on first ray marching step\n    float maxLength = 10.;\t\t\t// Max length for a ray to march (pick a distance beyond the scene).\n\tint maxIterations = 50;\t\t\t// Max allowed steps for a ray to march\n    float closeEnough = 0.001;\t\t// How close must we be to hit the surface\n\n    // Special result which implies we got an non-collision\n    vec2 res = vec2(-1.0,-1.0);\n    \n    float rayLength = initialLength;\n    for(int i=0; i<maxIterations && rayLength<maxLength; i++)\n    {\n        // Find current position\n        vec3 currentPosition = rayOrigin + rayLength*rayDirection;\n        \n        // Check the distance map for our distance to any scene object\n        float rayToCone = distanceMap(currentPosition);\n        \n        // If we're close enough (or within) and object, call it a hit -- abs as distance is signed\n        if(abs(rayToCone) <= closeEnough)\n        { \n            // Mark how far we marched & our distance from the hit surface\n            res = vec2(rayLength, rayToCone); \n            break;\n        }\n        \n        // Prepare to take the next step\n        rayLength += rayToCone;\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 surfaceNormal( vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*distanceMap( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*distanceMap( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*distanceMap( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*distanceMap( pos + e.xxx ));\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = distanceMap(aopos);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\n\n\n\n\n\n// from \"Magic Fractal\" by dgreensp\n// https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 15;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\n\n\n\n\n\n\nfloat maxHei = .8;\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = distanceMap( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1. + 2. * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n        \n    // Place the camera at 3-units away from the origin\n    vec3 rayOrigin = vec3(3,0,0);\n    \n    // Rotate the camera about the Y-axis\n    float angle = iTime/7. + .05*sin(iTime/3.);\n    if(iMouse.z > 0.)\n        angle = 6.28*iMouse.x/iResolution.x;\n    rayOrigin *= rotateY(angle);\n\n \t// Construction of our lookat matrix.\n    vec3 lookatTarget = vec3(0);\n  \tlookatTarget = vec3(.05*cos(iTime/3.),.1*sin(iTime),0); // Wiggle the target a bit for nausea. :)\n    vec3 worldUp = vec3(0,1,0);\n    vec3 cameraForward = normalize(lookatTarget - rayOrigin);\n    vec3 cameraLeft = normalize(cross(cameraForward, worldUp));\n    vec3 cameraUp = normalize(cross(cameraLeft, cameraForward));\n\n\t// TODO: Explain this :/\n    float focalLength = 2.;\n    \n    // Cast our UV coordinate onto the image plane \n    vec3 uvImagePlane = vec3(\n        \tuv.x * cameraLeft +\n        \tuv.y * cameraUp +\n        \tfocalLength * cameraForward\n    );\n    \n    // We don't actually care  about where the UV lives in space, just the direction of it\n    vec3 rayDirection = normalize(uvImagePlane);    \n    \n    \n    \n//    col = vec3(0.7, 0.9, 1.0) +rayDirection.y*0.8;\n\n    \n    \n    // Paint background\n    vec3 col = texture( iChannel0, rayDirection).xyz;\n    \n    // Returns distance travelled until collision & distance from surface on collision\n    vec2 ret = rayMarch(rayOrigin, rayDirection);\n    float distanceToIntersection = ret.x;\n    float distanceToSurface = ret.y;\n\n    if(distanceToIntersection != -1.)\n    {\n        // Find the position, and normal and reflection directions for the ray\n    \tvec3 position = rayOrigin + distanceToIntersection * rayDirection;\n        vec3 normal = surfaceNormal(position);\n        vec3 reflection = reflect(rayDirection, normal); \n\n\n\n        //////////////////////////////////////\n        \n        // material        \n        col = vec3(0.3);\n\n        vec2 v = vec2(magicBox(position.xy), magicBox(position.zy));\n        vec2 F = cellular2x2(v/(25.+2.*sin(iTime)));\n\n        vec3 sacColor = vec3(\n            1, \n            .9+.1*position.y, \n            .3+.2*sin(iTime/5.)*(1.-smoothstep(.3, .6, position.y))\n        );\n        col += sacColor * step(.0, F.y-F.x) * (1.-F.x);\n        \n\n        float occ = calcAO(position, normal);\n\t\tvec3  directionLight = normalize(vec3(-0.4, 0.7, -0.6));\n        vec3  hal = normalize(directionLight-rayDirection);\n\t\tfloat amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n        float diffuse = clamp( dot( normal, directionLight ), 0.0, 1.0 );\n        float bac = clamp( dot( normal, normalize(vec3(-directionLight.x,0.0,-directionLight.z))), 0.0, 1.0 )*clamp( 1.0-position.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, reflection.y );\n        float fre = pow( clamp(1.0+dot(normal,rayDirection),0.0,1.0), 2.0 );\n        \n        diffuse *= calcSoftshadow( position, directionLight, 0.02, 2.5 );\n        dom *= calcSoftshadow( position, reflection, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( normal, hal ), 0.0, 1.0 ),16.0)*\n                    diffuse *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rayDirection),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.10*diffuse*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n        col *= lin;\n\n\n       \n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n        \n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*pow(distanceToIntersection,3.) ) );\n \t\t//////////////////////////////////////\n\n\t}\n    \n    fragColor = vec4(col, 0.);\n}","name":"Image","description":"","type":"image"}]}