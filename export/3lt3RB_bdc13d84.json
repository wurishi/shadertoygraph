{"ver":"0.1","info":{"id":"3lt3RB","date":"1576761924","viewed":152,"name":"cravo-elfhead","username":"cravo","description":"A festive elf head.  It was going to be santa but I ran out of time for the beard :-)  Imagine he's saying \"Ho ho ho\" over and over again.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["christmas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by cravo\n\n// Makes use of a lot of distance functions and noise stuff by iq\n// More info here: https://iquilezles.org/articles/distfunctions\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat noise(vec3 x) // iq's 3D noise\n{\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\nfloat fbm(vec3 x)\n{   \n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n   \nfloat sdFluffBall(vec3 p, float s)\n{\n    float rad2 = s * 0.3;\n    s-= rad2 * fbm(p*8.0);\n    \n    float d = sdSphere(p,s);\n    \n    return d;\n}\n\nfloat sdFluffTorus(vec3 p, vec2 s)\n{\n    float rad2 = s.y * 0.3;\n    s.y -= rad2 * fbm(p*8.0);\n    return sdTorus(p,s);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n//----------------------------------------------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opBlend( vec3 p, float d1, float d2 )\n{\n    return smin( d1, d2, 0.5 );\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{  \n    vec3 facePos = vec3(0.0,0.5,0.0);\n    float face = sdEllipsoid(pos - facePos, vec3(0.4,0.5,0.4));\n    \n    vec3 nosePos = vec3(0.0,0.5,0.4);\n    float nose = opBlend(pos, sdEllipsoid(pos - nosePos, vec3(0.1,0.05,0.05)),0.25);\n    \n    vec3 ear1Pos = vec3(-0.37, 0.6, 0.1);\n    float ear1 = sdEllipsoid(pos - ear1Pos, vec3(0.1,0.1,0.05));\n\n    vec3 ear2Pos = vec3(0.37, 0.6, 0.1);\n    float ear2 = sdEllipsoid(pos - ear2Pos, vec3(0.1,0.1,0.05));\n    \n    vec3 eye1Pos = vec3(-0.1,0.65,0.325);\n    float eye1 = sdEllipsoid(pos - eye1Pos, vec3(0.05,0.1,0.05));\n\n    vec3 eye2Pos = vec3(0.1,0.65,0.325);\n    float eye2 = sdEllipsoid(pos - eye2Pos, vec3(0.05,0.1,0.05));\n\n    vec3 mouthPos = vec3(0.0,0.25,0.28);\n    float mouth = sdEllipsoid(pos - mouthPos, vec3(0.1,abs(sin(iTime*4.0))*0.05,0.1));\n    \n    vec3 hatPos = vec3(0.0, 1.05, 0.0);\n    float hat = sdCone(pos - hatPos, 0.22, 0.3, 0.0);\n    \n    vec3 hatBobblePos = vec3(0.0,1.2,0.0);\n    float hatBobble = sdFluffBall(pos - hatBobblePos, 0.1);\n    \n    vec3 hatRingPos = vec3(0.0,0.8,0.0);\n    float hatRing = sdFluffTorus(pos - hatRingPos,vec2(0.3,0.1));\n    \n    face = opSubtraction(mouth,face);\n    \n    vec2 res = vec2(sdPlane(pos), 1.0);\n\tres = opU(vec2(face,2.0), res);\n    res = opU(vec2(nose,2.0), res);\n    res = opU(vec2(ear1, 2.0), res);\n    res = opU(vec2(ear2, 2.0), res);\n    res = opU(vec2(eye1,3.0), res);\n    res = opU(vec2(eye2,3.0), res);\n    res = opU(vec2(hat, 4.0), res);\n    res = opU(vec2(hatBobble,3.0), res);\n    res = opU(vec2(hatRing, 3.0), res);\n    \n    //res = vec2(sdFluffTorus(pos - facePos,vec2(0.5,0.1)),3.0);\n    \n    \n    return res;\n}\n\n\n\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<128; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<60; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n        \tfloat h = map( ro + rd*t ).x;\n        \tres = min( res, k*h/t );\n        \tt += 0.02;\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd,20.0);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n\t\tcol = vec3(0.8);\n\t\t\n        if(m == 2.0)\n        {\n            col = vec3(1.0,0.8,0.7);\n        }\n        else if(m == 4.0)\n        {\n            col = vec3(1.0,0.0,0.0);\n        }\n        \n\t\tvec3 lig = normalize( vec3(0.3, 0.6, 0.5) );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { sh = softshadow( pos, lig, 0.02, 10.0, 7.0 ); dif *= sh; }\n\n\t\tvec3 brdf = 1.20*dif*vec3(1.00,1.0,1.0);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = sh*pow(pp,16.0);\n\n\t\tcol = bac + col*brdf + vec3(1.0)*col*spe;\n\n\t}\n\n\t// light falloff with distance\n\tcol *= exp( -0.01*t*t );\n\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\t// camera\t\n\tvec3 ro = vec3( sin(iTime) * 0.5, 0.7, 2.5 );\n\tvec3 ta = vec3( 0.0, 0.5, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    fragColor=vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}