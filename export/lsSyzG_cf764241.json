{"ver":"0.1","info":{"id":"lsSyzG","date":"1492534314","viewed":96,"name":"ray-marching-helloworld","username":"hikiko","description":"my helloworld based on iq's tutorials and code","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbulb","ambientocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T 0.001 //threshold\n#define MAX_POS 1000.0\n#define MAX_STEPS 500\n#define MAX_STEP_SIZE 0.3\n#define DELTA 0.001\n#define M_PI 3.14168\n\n#define NUM_ITER 50\n#define POWER 9.0\n#define MAX_ITER 100.0\n\n#define AO_STEP 0.05\n#define AO_MAGIC 8.0\n\nconst vec3 bcolor = vec3(0.0, 0.0, 0.03);\nconst vec3 ldir = vec3(1.0, 1.0, -1.5);\nconst vec3 fcolor = vec3(0.1, 0.46, 0.52);\n\nvec3 get_ray_direction(in vec2 uv, in float z)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return normalize(vec3(aspect * (uv.x - 0.5) * 2.0, (uv.y - 0.5) * 2.0, z));\n}\n\nfloat frac_distance(vec3 pos)\n{\n    // from iq's blog post\n\n    vec3 p = pos;\n    float dr = 1.0;\n    float r = 1.0;\n    \n    for(int i=0; i<NUM_ITER; i++) {\n        r = length(p);\n        if(r > MAX_ITER) {\n            break;\n        }\n        \n        // conversion to polar coordinates\n        \n        float theta = acos(p.z/r);\n        float phi = atan(p.y, p.x);\n        dr = pow(r, POWER - 1.0) * POWER * dr + 1.0;\n\n        // scale and rotate the point\n\n        float pr = pow(r, POWER);\n        theta = theta * POWER;\n        phi = phi * POWER;\n        \n        // conversion to cartesian coordinates\n        \n        p = pr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        p += pos; \n    }\n    return 0.5 * log(r) * r/dr;\n}\n\nfloat min_distance(vec3 position)\n{\n    return frac_distance(position);\n    \n    // distance from sphere for test\n    vec3 fish_local_pos = position * vec3(0.4, 1.0, 2.0); //warped\n    float radius = 3.0;\n    float sph_distance = length(fish_local_pos) - radius;\n    \n    return sph_distance;\n}\n\nfloat ambient_occlusion(in vec3 pos, in vec3 normal)\n{\n    float ao = 0.0;\n\n    for(int i=0; i<5; i++) {\n    \t// step away from the surface\n        float sample_dist = float(i) * AO_STEP;\n        vec3 new_pos = pos + sample_dist * normal;\n        float dist = frac_distance(new_pos);\n        \n        float dist_diff = max(sample_dist - dist, T);\n        ao += 1.0 / pow(2.0, float(i)) * dist_diff;\n    }\n    ao = 1.0 - AO_MAGIC * ao;\n    return clamp(ao, 0.0, 1.0);\n}\n\nvec3 shade(in vec3 pos, in vec3 normal, in vec3 color)\n{\n/*\n\tfloat ndotl = max(dot(normal, normalize(ldir)), 0.0);\n    vec3 diffuse = fcolor * ndotl;\n    return diffuse;\n*/\n    return ambient_occlusion(pos, normal) * color;\n}\n\nvec3 ray_march(vec3 pos, vec3 dir, vec3 color)\n{\n    float dist;\n    int steps = 0;\n    while((dist = min_distance(pos)) > T) {\n        pos += dir * min(dist, MAX_STEP_SIZE);\n        ++steps;\n        \n        if((steps > MAX_STEPS) || (dot(pos, pos) > MAX_POS * MAX_POS)) {\n            return bcolor;\n        }\n    }\n\n    /* normal = grad = vec3(af/ax, af/ay, af/az) */\n    \n    float dfdx = min_distance(pos + vec3(DELTA, 0.0, 0.0)) - dist;\n    float dfdy = min_distance(pos + vec3(0.0, DELTA, 0.0)) - dist;\n    float dfdz = min_distance(pos + vec3(0.0, 0.0, DELTA)) - dist;\n    \n    vec3 normal = normalize(vec3(dfdx, dfdy, dfdz));\n    return shade(pos, normal, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rd = get_ray_direction(uv, 2.0);\n    vec3 origin = vec3(0.01, 0.01, -3.0);\n    \n    float theta;\n    float phi;\n    \n    if (iMouse.xy != vec2(0.0)) {\n        theta = -(iMouse.x / iResolution.x) * 8.0;\n        phi = ((iMouse.y / iResolution.y) * 2.0 - 1.0) * M_PI;\n    } else {\n        theta = -8.0;\n        phi = M_PI;\n    }\n    \n    mat3 rot_x = mat3(cos(theta), 0.0, sin(theta),\n                   0.0, 1.0, 0.0,\n                   -sin(theta), 0.0, cos(theta));\n    mat3 rot_y = mat3(1.0, 0.0, 0.0,\n                      0.0, cos(phi), -sin(phi),\n                      0.0, sin(phi), cos(phi));\n    mat3 cam_trans = rot_x * rot_y;\n   \n    \n    vec3 color = normalize(vec3(sin(theta) + 1.0 / AO_MAGIC, cos(phi) + 1.0 / AO_MAGIC, sin(phi + theta) + 1.0 / AO_MAGIC));\n\tfragColor.rgb = ray_march(cam_trans * origin, cam_trans * rd, color);\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}