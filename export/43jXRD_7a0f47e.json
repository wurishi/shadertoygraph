{"ver":"0.1","info":{"id":"43jXRD","date":"1710510888","viewed":231,"name":"Velocity Design Comfort","username":"rclovis","description":"The cover of velocity design comfort by sweet trip","likes":7,"published":1,"flags":96,"usePreview":0,"tags":["3d","raymarching","distancefields","music","primitives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdcGWs","filepath":"https://soundcloud.com/sweettrip/dsco","previewfilepath":"https://soundcloud.com/sweettrip/dsco","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nvec3 hash(float n)\n{\n    n = n * 3.;\n    return normalize(sin(vec3(n * 3.4 + 0.5, n * 4.5, n * 6.3))*iTime);\n    //return \n}\n\nfloat rays(vec2 uv, float gap, float strokewidth)\n{\n    uv.y = gap / abs(uv.y);\n    uv.x *= uv.y * 0.5;\n\n    vec2 size = vec2(uv.y, 0.) * 0.005;\n    uv.x = abs(fract(uv.x) - 0.5);\n \tvec2 lines = smoothstep(size * strokewidth, vec2(0.), uv);\n    return lines.x;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat lines (vec2 uv, float gap, float strokewidth)\n{\n    uv.y = gap / abs(uv.y);\n    uv.x *= uv.y * 0.5;\n\n    vec2 size = vec2(0., uv.y * uv.y * 0.2) * 0.005;\n    uv.y += iTime;\n    uv.y = abs(fract(uv.y) - 0.5);\n \tvec2 lines = smoothstep(size * strokewidth, vec2(0.), uv);\n    return lines.y;\n}\n\nfloat disk (vec2 uv, float pre, float strokeWidth, float radius)\n{\n    return 1.0 - smoothstep(strokeWidth, strokeWidth + pre, length(uv) - radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    uv.y += 0.1;\n    vec3 col = vec3(0.0);\n    float gridVal = rays(uv, 21., 0.5) * smoothstep(0., 1., abs(uv.y) + 0.2);\n    if (uv.y < 0.) {\n        gridVal += rays(uv, 3., 1.);\n        gridVal += lines(uv, 2., 4.0) * smoothstep(0., 1., abs(uv.y) + 0.2);\n        gridVal += lines(uv, 2., 4.0) * smoothstep(0., 1., abs(uv.y) + 0.2);\n        gridVal = min(gridVal, 1.);\n        col += (1. - vec3(0.2, 0.73, 0.85)) * gridVal;\n    } else {\n        gridVal = min(gridVal, 1.);\n        col += 1. - mix(vec3(0, 0.23, 0.63), vec3(0.2, 0.73, 0.85), 1.-smoothstep(0., 1., abs(uv.y) + 0.3));\n        col += (vec3(0, 0.23, 0.63) - vec3(0.2, 0.73, 0.85)) * gridVal;\n        vec4 clouds = texture(iChannel0, fragCoord / iResolution.xy);\n        col = mix(col, 1.-clouds.xyz, clouds.w);\n    }\n    \n    float angle = atan(normalize(uv).y, normalize(uv).x);\n    angle = PI - round(angle / 0.06) * 0.06 - PI / 2.;\n    if (angle > 0. && angle < 2.2)\n        col = (hash(angle));\n\n    float d = disk(uv, 0.05, 0., 0.04);\n    col *= 1. - d;\n    vec4 boxes = texture(iChannel1, fragCoord / iResolution.xy);\n    \n    col = col * (1. - step(0.1, boxes.w)) + mix(vec3(col.x), 1.-vec3(0.13, 0.5, 0.6), 0.9) * boxes.w;\n    fragColor = vec4(1. - col - (d * (1. - vec3(0.2, 0.73, 0.85))), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This is for clouds\n//The code comes from https://www.shadertoy.com/view/XtBXDw\n\n\n#define COVERAGE\t\t.45\n#define THICKNESS\t\t12.\n#define ABSORPTION\t\t1.030725\n#define WIND\t\t\tvec3(0, 0, -u_time * .2)\n\n#define FBM_FREQ\t\t2.76434\n#define NOISE_VALUE\n#define FAKE_LIGHT\n#define SUN_DIR\t\t\tnormalize(vec3(0, abs(sin(u_time * .3)), -1))\n\n#define STEPS\t\t\t25\n\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\n\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n\n#define PI 3.14159265359\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nstruct hit_t {\n\tfloat t;\n\tint material_id;\n\tvec3 normal;\n\tvec3 origin;\n};\n#define max_dist 1e8\n_constant(hit_t) no_hit = _begin(hit_t)\n\tfloat(max_dist + 1e1), // 'infinite' distance\n\t-1, // material id\n\tvec3(0., 0., 0.), // normal\n\tvec3(0., 0., 0.) // origin\n_end;\n\n// ----------------------------------------------------------------------------\n// Various 3D utilities functions\n// ----------------------------------------------------------------------------\n\nray_t get_primary_ray(in vec3 cam_local_point, inout vec3 cam_origin, inout vec3 cam_look_at){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = _begin(ray_t)\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t\t_end;\n\treturn r;\n}\n\nmat2 rotate_2d(in float angle_degrees){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat2(_cos, -_sin, _sin, _cos);\n}\n\nmat3 rotate_around_z(in float angle_degrees){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\nmat3 rotate_around_y(in float angle_degrees){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nmat3 rotate_around_x(in float angle_degrees){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\nvec3 corect_gamma(in vec3 color, in float gamma){\n\tfloat p = 1.0 / gamma;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\n\nfloat checkboard_pattern(in vec2 pos, in float scale){\n\tvec2 pattern = floor(pos * scale);\n\treturn mod(pattern.x + pattern.y, 2.0);\n}\n\nfloat band (in float start, in float peak, in float end, in float t){\n\treturn\n\tsmoothstep (start, peak, t) *\n\t(1. - smoothstep (peak, end, t));\n}\nvoid intersect_sphere(in ray_t ray, in sphere_t sphere, inout hit_t hit){\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2)\n\t\treturn;\n\n\tfloat thc = sqrt(radius2 - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\n\tif (t0 < 0.) t0 = t1;\n\tif (t0 > hit.t)\n\t\treturn;\n\n\tvec3 impact = ray.origin + ray.direction * t0;\n\n\thit.t = t0;\n\thit.material_id = sphere.material;\n\thit.origin = impact;\n\thit.normal = (impact - sphere.origin) / sphere.radius;\n}\n\nvoid intersect_plane(in ray_t ray, in plane_t p, inout hit_t hit){\n\tfloat denom = dot(p.direction, ray.direction);\n\tif (denom < 1e-6) return;\n\n\tvec3 P0 = vec3(p.distance, p.distance, p.distance);\n\tfloat t = dot(P0 - ray.origin, p.direction) / denom;\n\tif (t < 0. || t > hit.t) return;\n\t\n\thit.t = t;\n\thit.material_id = p.material;\n\thit.origin = ray.origin + ray.direction * t;\n\thit.normal = faceforward(p.direction, ray.direction, p.direction);\n}\n\nfloat hash(in float n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nfloat noise_iq(in vec3 x){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nvec3 hash_w(in vec3 x){\n\treturn texture(iChannel0, (x.xy + vec2(3.0, 1.0)*x.z + 0.5) / 256.0, -100.0).xyz;\n}\n\nvec3 noise_w(in vec3 x){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tfloat id = 0.0;\n\tvec2 res = vec2(100.0, 100.0);\n\tfor (int k = -1; k <= 1; k++)\n\t\tfor (int j = -1; j <= 1; j++)\n\t\t\tfor (int i = -1; i <= 1; i++)\n\t\t\t{\n\t\t\t\tvec3 b = vec3(float(i), float(j), float(k));\n\t\t\t\tvec3 r = vec3(b) - f + hash_w(p + b);\n\t\t\t\tfloat d = dot(r, r);\n\n\t\t\t\tif (d < res.x)\n\t\t\t\t{\n\t\t\t\t\tid = dot(p + b, vec3(1.0, 57.0, 113.0));\n\t\t\t\t\tres = vec2(d, res.x);\n\t\t\t\t}\n\t\t\t\telse if (d < res.y)\n\t\t\t\t{\n\t\t\t\t\tres.y = d;\n\t\t\t\t}\n\t\t\t}\n\n\treturn vec3(sqrt(res), abs(id));\n}\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1, 1, 1); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1, 1, 1); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(.5, .5, .5, .5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0, 0, 0, 0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(.5, .5, .5, .5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0, 0, 0, 0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1, 1, 1), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1, 1, 1); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(.5, .5, .5, .5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0, 0, 0, 0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(.5, .5, .5, .5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0, 0, 0, 0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n#define noise(x) noise_iq(x)\n\nfloat fbm(in vec3 pos, in float lacunarity){\n\tvec3 p = pos;\n\tfloat\n\tt  = 0.51749673 * noise(p); p *= lacunarity;\n\tt += 0.25584929 * noise(p); p *= lacunarity;\n\tt += 0.12527603 * noise(p); p *= lacunarity;\n\tt += 0.06255931 * noise(p);\n\treturn t;\n}\n\n\nfloat get_noise(in vec3 x)\n{\n\treturn fbm(x, FBM_FREQ);\n}\n\n_constant(vec3) sun_color = vec3(1., .7, .55);\n\n_constant(sphere_t) atmosphere = _begin(sphere_t)\n\tvec3(0, -450, 0), 500., 0\n_end;\n_constant(sphere_t) atmosphere_2 = _begin(sphere_t)\n\tatmosphere.origin, atmosphere.radius + 50., 0\n_end;\n_constant(plane_t) ground = _begin(plane_t)\n\tvec3(0., -1., 0.), 0., 1\n_end;\n\n\nfloat density(in vec3 pos, in vec3 offset, in float t){\n\t// signal\n\tvec3 p = pos * .0212242 + offset;\n\tfloat dens = get_noise(p);\n\t\n\tfloat cov = 1. - COVERAGE;\n\t//dens = band (.1, .3, .6, dens);\n\t//dens *= step(cov, dens);\n\t//dens -= cov;\n\tdens *= smoothstep (cov, cov + .05, dens);\n\n\treturn clamp(dens, 0., 1.);\t\n}\n\nfloat light(in vec3 origin){\n\tconst int steps = 8;\n\tfloat march_step = 1.;\n\n\tvec3 pos = origin;\n\tvec3 dir_step = SUN_DIR * march_step;\n\tfloat T = 1.; // transmitance\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tfloat dens = density(pos, WIND, 0.);\n\n\t\tfloat T_i = exp(-ABSORPTION * dens * march_step);\n\t\tT *= T_i;\n\n\t\tpos += dir_step;\n\t}\n\n\treturn T;\n}\n\nvec4 render_clouds(in ray_t eye){\n\thit_t hit = no_hit;\n\tintersect_sphere(eye, atmosphere, hit);\n\t//hit_t hit_2 = no_hit;\n\t//intersect_sphere(eye, atmosphere_2, hit_2);\n\n\tconst float thickness = THICKNESS; // length(hit_2.origin - hit.origin);\n\t//const float r = 1. - ((atmosphere_2.radius - atmosphere.radius) / thickness);\n\tconst int steps = STEPS; // +int(32. * r);\n\tfloat march_step = thickness / float(steps);\n\n\tvec3 dir_step = eye.direction / eye.direction.y * march_step;\n\tvec3 pos = //eye.origin + eye.direction * 100.; \n\t\thit.origin;\n\n\tfloat T = 1.; // transmitance\n\tvec3 C = vec3(0, 0, 0); // color\n\tfloat alpha = 0.;\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tfloat h = float(i) / float(steps);\n\t\tfloat dens = density (pos, WIND, h);\n\n\t\tfloat T_i = exp(-ABSORPTION * dens * march_step);\n\t\tT *= T_i;\n\t\tif (T < .01) break;\n\n\t\tC += T * \n\t\t\t(exp(h) / 1.75) *\n\t\t\tdens * march_step;\n\t\talpha += (1. - T_i) * (1. - alpha);\n\n\t\tpos += dir_step;\n\t\tif (length(pos) > 1e3) break;\n\t}\n\n\treturn vec4(C, alpha);\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\tfloat fov = tan(radians(45.0));\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n\n\tvec3 point_cam = vec3((2.0 * point_ndc - 1.0) * aspect_ratio * fov, -1.0);\n\tvec3 col = vec3(0);\n\n\tvec3 eye = vec3(0, 0.9, 0);\n\tvec3 look_at = vec3(0, 1., -1);\n\tray_t eye_ray = get_primary_ray(point_cam, eye, look_at);\n\n\thit_t hit = no_hit;\n\tintersect_plane(eye_ray, ground, hit);\n    float tmp;\n\tif (hit.material_id != 1) {\n\t\tvec4 cld = render_clouds(eye_ray);\n\t\tcol =cld.rgb/(0.000001+cld.a);\n        tmp = cld.a;\n\t}\n\tfragColor = vec4(col, tmp);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 hash(float n)\n{\n    return fract(sin(vec3(n, n*5., n*8.))*40.f);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(100.);\n    for (int i = 0;i < 16;i++) {\n        vec3 posT = pos - vec3(0.65, -0.4 + sin(iTime + hash(float(i)).y) / 10., 0.)-hash(float(i));\n        vec2 tmp = vec2(sdBox(posT,  hash(float(i + 10)) / 2.), 37.0 + hash(float(i + 2)).x );\n        if (res.x > tmp.x) {\n            res = tmp;\n        }\n    }\n    return res;\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n    float t = 0.;\n    for( int i=0; i<70; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    vec3 col;\n    \n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        \n\t\tvec3 lin = vec3(0.0);\n        vec3 lig = normalize( vec3(-0.9, -0.6, -0.5) );\n        vec3 hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.5, 1.0 );\n        lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n\t\tcol = lin;\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(uv, -1.0);\n    vec3 rd = normalize(vec3(0.1, 0.1, 1.));\n\n    vec3 col = render( ro, rd);\n    fragColor = vec4(length(col)*2.);\n}","name":"Buffer B","description":"","type":"buffer"}]}