{"ver":"0.1","info":{"id":"dsdXRH","date":"1679413606","viewed":68,"name":"Roboto extraction version 2","username":"ianertson","description":"Alternative version of my previous found here:\n[url]https://www.shadertoy.com/view/DscXRr[/url]\n\nI was now able to get a little bit more resolution from the font, by packing each row into a uint.\n\nAgain C-code is pasted into the \"Common\" tab","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["font","ttf","roboto","freetype"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// extracted using freetype2.\n// I pasted the C-code in the \"Common\" tab.\n\n// Note, only A-Z is extracted (uppercase).\n\n#define R (iResolution.xy)\n\n#define CHAR_COLS 11\n#define CHAR_ROWS 10\n// original size\n#define FONT_UNPACKED_LEN 3146\n// packed \"compressed\" size\n#define FONT_LEN 286\nuint[FONT_LEN] font = uint[FONT_LEN](\n24U,56U,60U,60U,100U,102U,126U,195U,195U,0U,0U,63U,99U,99U,99U,63U,99U,\n99U,99U,63U,0U,0U,124U,238U,198U,2U,3U,2U,198U,238U,124U,\n0U,0U,63U,115U,99U,99U,99U,99U,99U,115U,63U,0U,0U,127U,3U,3U,3U,\n63U,3U,3U,3U,127U,0U,0U,127U,3U,3U,3U,63U,3U,3U,3U,3U,0U,0U,124U,\n206U,134U,2U,243U,194U,198U,206U,252U,0U,0U,195U,195U,195U,195U,255U,195U,\n195U,195U,195U,0U,0U,3U,3U,3U,3U,3U,3U,3U,3U,3U,0U,0U,48U,48U,48U,48U,48U,\n48U,50U,54U,30U,0U,0U,99U,51U,59U,31U,31U,31U,51U,99U,227U,0U,0U,3U,3U,3U,3U,3U,3U,\n3U,3U,127U,0U,0U,263U,391U,399U,399U,475U,475U,371U,371U,307U,0U,0U,199U,199U,207U,219U,\n251U,243U,227U,227U,195U,0U,0U,124U,238U,198U,194U,194U,194U,198U,238U,124U,0U,0U,63U,99U,99U,\n99U,63U,3U,3U,3U,3U,0U,0U,124U,238U,198U,194U,194U,194U,198U,238U,124U,192U,128U,63U,99U,99U,99U,\n63U,51U,99U,99U,67U,0U,0U,62U,102U,66U,14U,60U,112U,98U,102U,60U,0U,0U,127U,12U,12U,12U,12U,12U,\n12U,12U,12U,0U,0U,99U,99U,99U,99U,99U,99U,98U,102U,60U,0U,0U,195U,195U,102U,102U,38U,60U,60U,24U,\n24U,0U,0U,99U,115U,114U,118U,470U,478U,412U,396U,396U,0U,0U,99U,102U,60U,60U,24U,60U,60U,102U,227U,\n0U,0U,198U,198U,108U,44U,56U,24U,24U,24U,24U,0U,0U,63U,48U,24U,24U,12U,6U,6U,3U,63U,0U,0U\n);\n\nfloat get_pixel(int x, int y, int c) {\n    int idx = CHAR_ROWS-(y+1);\n    idx += CHAR_COLS*c;\n    uint font_row = font[idx];\n    uint bit = (font_row >> x) & 0x1U;\n    return float(bit);\n}\n\n// just wrapping the integer version for a more convenient usage.\nfloat get_pixel(vec2 uv, int c) { return get_pixel(int(uv.x), int(uv.y), c); }\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.y;\n    \n    vec3[6] colors = vec3[6](\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1),\n        \n        vec3(1, 1, 0),\n        vec3(0, 1, 1),\n        vec3(1, 0, 1)\n    );\n    \n    if (fc.x > R.x/4.3 && fc.y > R.y/2.5) {\n        uv.x -= (R.x/4.3)/R.y;\n        uv.y -= (R.y/2.5)/R.y;\n        vec2 id = floor(uv*6.);\n        vec2 lv = fract(uv*6.);\n\n        int ii = int(id.x);\n        int c = 0;\n\n        switch (ii) {\n            case 0: c = 17; break; // R\n            case 1: c = 14; break; // O\n            case 2: c = 1;  break; // B\n            case 3: c = 14; break; // O\n            case 4: c = 19; break; // T\n            case 5: c = 14; break; // O\n        }\n\n        col += colors[int(id.x)%6] * get_pixel(lv*vec2(CHAR_COLS, CHAR_ROWS), c) * float(id.x < 6.0 && id.y <= 0.);\n    }\n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n#include <freetype/freetype.h>\n#include <freetype2/freetype/freetype.h>\n#include <freetype2/freetype/ftimage.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define FONT_PATH \"/usr/share/fonts/truetype/roboto/unhinted/RobotoTTF/Roboto-Regular.ttf\"\n#define FONT_SIZE 3\n#define FONT_THRESHOLD 0.15f\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n#ifndef MAX\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#endif\n\n#define TRUE_TYPE_BITS FT_LOAD_RENDER | FT_LOAD_CROP_BITMAP\n\ntypedef struct {\n  unsigned int *packed;\n  int nr_packed;\n  int row_cap;\n  int row_width;\n} Font;\n\nvoid font_init(Font *font, int row_cap, int row_width) {\n  font->row_cap = row_cap;\n  font->row_width = row_width;\n  font->packed = calloc(row_cap * row_width, sizeof(unsigned int));\n  font->nr_packed = 0;\n}\n\nvoid font_add_row(Font *font, int *row) {\n  unsigned int rowint = 0;\n\n  for (unsigned int i = 0; i < font->row_width; i++) {\n    int bit = (row[i] << i) & 0x1FF;\n    rowint |= bit;\n  }\n\n  font->packed[font->nr_packed++] = rowint;\n}\n\nvoid font_print_unpacked(Font font) {\n  for (unsigned int y = 0; y < font.nr_packed; y++) {\n    for (unsigned int k = 0; k < font.row_width; k++) {\n      unsigned int bit = ((font.packed[y] >> k) & 0x1);\n      printf(\"%d \", bit);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid font_print_packed(Font font) {\n  int num_chars = (font.nr_packed/2)/(font.row_width/2);\n  printf(\"#define CHAR_COLS %d\\n\", font.row_width);\n  printf(\"#define CHAR_ROWS %d\\n\", font.nr_packed/num_chars);\n  printf(\"#define FONT_UNPACKED_LEN %d\\n\", font.nr_packed*font.row_width);\n  printf(\"#define FONT_LEN %d\\n\", font.nr_packed);\n  printf(\"#define FONT_NUM_CHARS %d\\n\", num_chars);\n  printf(\"uint[FONT_LEN] font = uint[FONT_LEN](\\n\");\n  for (unsigned int y = 0; y < font.nr_packed; y++) {\n    //  for (unsigned int x = 0; x < font.row_width; x++) {\n    //int idx = y*1+x;\n    //  if (idx >= font.nr_packed-1) break;\n      unsigned int v = font.packed[y];\n      printf(\"%dU%s\", v, y+1 < font.nr_packed ? \",\" : \"\");\n      // }\n  }\n  printf(\"\\n);\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  FT_Library ft;\n  FT_Face face;\n  int error = FT_Init_FreeType(&ft);\n\n  if (error) {\n    fprintf(stderr, \"Error loading freetype library.\\n\");\n    return 1;\n  }\n\n  error = FT_New_Face(ft, FONT_PATH, 0, &face);\n  if (error) {\n    fprintf(stderr, \"Error reading font `%s`\\n\", FONT_PATH);\n    return 1;\n  }\n\n  FT_Set_Char_Size(face,\n\t\t   0,\n\t\t   64 * FONT_SIZE,\n\t\t   300,\n\t\t   300);\n\n  if (error) {\n    fprintf(stderr, \"Error setting pixel sizes.\\n\");\n    return 1;\n  }\n\n  int maxw = -1;\n  int maxh = -1;\n\n  // first loop just to compute the max width and max height\n  for (int i = 65; i < 90; i++) {\n    int character = i;\n    int glyph_index = 0;\n    if (!(glyph_index = FT_Get_Char_Index(face, character))) {\n      fprintf(stderr, \"Could not get char index.\\n\");\n      continue;\n    }\n\n    if (FT_Load_Glyph(face, glyph_index, TRUE_TYPE_BITS)) {\n      fprintf(stderr, \"Unable to load glyph `%d`\\n\", i);\n      continue;\n    }\n\n    FT_GlyphSlot g = face->glyph;\n\n    int w = g->bitmap.width;\n    int h = g->bitmap.rows;\n\n    maxw = w > maxw ? w : maxw;\n    maxh = h > maxh ? h : maxh;\n  }\n\n  int cols = maxw;\n  int rows = maxh;\n\n  Font font = {0};\n  font_init(&font, 26, rows);\n\n  for (int i = 65; i < 91; i++) {\n    int character = i;\n    int glyph_index = 0;\n    if (!(glyph_index = FT_Get_Char_Index(face, character))) {\n      fprintf(stderr, \"Could not get char index.\\n\");\n      continue;\n    }\n\n    if (FT_Load_Glyph(face, glyph_index, TRUE_TYPE_BITS)) {\n      fprintf(stderr, \"Unable to load glyph `%d`\\n\", i);\n      continue;\n    }\n\n    FT_GlyphSlot g = face->glyph;\n\n    int w = g->bitmap.width;\n    int h = g->bitmap.rows;\n\n    for (int x = 0; x < cols; x++) {\n      int row[rows];\n      for (int y = 0; y < rows; y++) {\n\tint idx = (MIN(x, h - 1) * w + MIN(y, w - 1));\n\tunsigned char *data = (unsigned char *)g->bitmap.buffer;\n\tunsigned char px = (x >= h || y >= w) ? 0 : data[idx];\n\tfloat s = (float)px;\n\ts /= 255.0f;\n\trow[y] = (int)(s > FONT_THRESHOLD);\n      }\n\n      font_add_row(&font, row);\n    }\n  }\n\n  // prints unpacked font\n  // font_print_unpacked(font);\n\n  // prints packed font\n  font_print_packed(font);\n  \n  free(font.packed);\n  \n  return 0;\n}\n\n*/","name":"Common","description":"","type":"common"}]}