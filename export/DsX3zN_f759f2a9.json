{"ver":"0.1","info":{"id":"DsX3zN","date":"1665988075","viewed":241,"name":"SH Spherical Harmonics from Cube","username":"magician0809","description":"Generate SH coefficients from Cubemap.\nIrradiance map and SH coefficients refresh every 10 seconds.\nChange iChannel1 in label \"Cube A\" then press space to refresh SH immediately.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["sphericalharmonics","spherical","harmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/**\n * Explanations: (my English is not very good XD)\n * We use SH for reconstructing approximation of a function, whatever the function is.\n * \n * SH can reconstruct irradiance from irradiance map.\n * Here are the steps of generating SH coefficients:\n * 1. Generate irradiance map from cubemap. Just integral cosine hemisphere in every direction.\n * 2. Integral irradiance * SH in every direction for each SH with specifc 'l' and 'm'.\n * 3. Then we get SH coefficients of every specifc SH. Save them!\n * 4. For reconstructing irradiance in specific direction, just sum every SH coefficient * SH.\n * \n * SH can also reconstruct irradiance from cubemap directly.\n * Open macro 'USE_SH_ROTATION' in 'Common' label and then refresh SH to see the results.\n */\n\n#define CAMERA_ORBIT\n#define SAFE_RAY_MARCH\n#define SH_CHANGE_INTERVAL 2.0\n#define SH_POS_COL vec3(1.0, 1.0, 1.0)\n#define SH_NEG_COL vec3(1.0, 0.0, 0.0)\n//#define SH_POS_COL vec3(0.2, 0.4, 0.5)\n//#define SH_NEG_COL vec3(1.0, 0.6, 0.15)\n\nCamera GetCamera()\n{\n    vec3 forward;\n    if (iMouse.z > 0.5)\n    {\n        forward = MouseRotation(iMouse.xy, iResolution.xy);\n    }\n    else\n    {\n#ifdef CAMERA_ORBIT\n        float period = iTime * (DOUBLE_PI / 120.0);\n        forward.y = -sin(0.618 * period) * 0.8;\n        forward.xz = vec2(-sin(period), cos(period));\n        forward = normalize(forward);\n#else\n        forward.xyz = vec3(-0.57735027, -0.57735027, 0.57735027);\n#endif\n    }\n    Camera cam;\n    cam.forward = forward;\n    cam.up = vec3(0.0, 1.0, 0.0);\n    cam.position = -1.5 * cam.forward;\n    cam.aspect = iResolution.x / iResolution.y;\n    cam.fieldOfView = 60.0;\n    return cam;\n}\n\nvoid SampleMaterial(vec3 albedo, out vec3 diffuse, out vec3 specular, out float roughness)\n{\n    roughness = 0.25;\n    float metallic = 0.0;\n    MetallicSteup(albedo, metallic, diffuse, specular);\n}\n\nvec3 XYZ2YZ_X(vec3 v)\n{\n    return vec3(-v.z, v.x, v.y);\n}\n\nvec3 YZ_X2XYZ(vec3 v)\n{\n    return vec3(v.y, v.z, -v.x);\n}\n\nvec4 sdSHCurve(int l, int m, vec3 pos, out vec4 val)\n{\n    float len = length(pos);\n    vec3 dir = pos / len;\n    val = EvaluateSH(l, m, XYZ2YZ_X(dir));\n    val.xyz = YZ_X2XYZ(val.xyz);\n    float sd = len - abs(val.w);\n    return vec4(dir, sd);\n}\n\nfloat RayMarchSH(vec3 ro, vec3 rd, out float maxd, out vec4 val)\n{\n    // sh changes\n    float period = iTime / (float(SH_MAX_L_M) * SH_CHANGE_INTERVAL);\n    int l = int(sqrt(fract(period) * float(SH_MAX_L_M)));\n    int m = int(fract(period) * float(SH_MAX_L_M)) - l * l - l;\n\n    // ray march\n    maxd = max(length(ro) + 1.0, 0.0);\n    float d = max(length(ro) - 1.0, 0.0);\n    for (int i = 0; i < 180; ++i)\n    {\n        vec3 pos = ro + rd * d;\n        vec4 sd = sdSHCurve(l, m, pos, val);\n        if (sd.w < 0.001 || d > maxd) break;\n#ifdef SAFE_RAY_MARCH\n        d += sd.w * max(0.1, dot(sd.xyz, val.xyz));\n#else\n        d += sd.w * 0.2;\n#endif\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    // camera\n    Camera cam = GetCamera();\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec2 uvScreen = fragCoord * texelSize;\n\n    // anti-aliasing\n    AA_BEGIN(2, uv, uvScreen)\n\n        // ray march\n        vec3 col0 = vec3(0);\n        vec3 ro = cam.position;\n        vec3 rd = MakeWorldRay(uv, cam);\n        float maxd;\n        vec4 val;\n        float d = RayMarchSH(ro, rd, maxd, val);\n\n        // render\n        if (d < maxd)\n        {\n            // material\n            vec3 diffuse, specular;\n            float roughness;\n            vec3 albedo = mix(SH_NEG_COL, SH_POS_COL, step(0.0, val.w));\n            SampleMaterial(albedo, diffuse, specular, roughness);\n            \n            // lighting\n            float fakeAO = smoothstep(-0.05, 0.35, abs(val.w));\n            vec3 hitNormal = val.xyz;\n            vec3 radiance = vec3(0.0);\n            radiance += IndirectSpecular(iChannel1, 256.0, hitNormal, -rd, specular, roughness);\n            radiance += fakeAO * diffuse * SampleSH2(iChannel0, hitNormal);\n            col0 = radiance;\n        }\n        else\n        {\n            // sample background\n            col0 = pow(texture(iChannel1, rd).rgb, vec3(2.2));\n        }\n    \n    AA_END(col, col0)\n    \n    // vignette effect\n    col *= smoothstep(0.707107, 0.35, length(vec2(0.5) - uvScreen));\n\n    // linear to gamma\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//============================================================ Macro\n\n#define E 2.71828182846\n#define PI 3.14159265359\n#define HALF_PI (PI * 0.5)\n#define DOUBLE_PI (PI * 2.0)\n#define GOLDEN_RATIO 0.61803399\n\n#define AA_BEGIN(aa,uv,uv0) const int AA=aa; \\\n    for(int aj=0;aj<AA;++aj)for(int ai=0;ai<AA;++ai){ \\\n    vec2 uv=uv0;uv+=vec2(dFdx(uv.x),dFdy(uv.y))*((vec2(ai,aj)+.5)/float(AA)-.5);\n#define AA_END(col,col0) col.rgb+=(col0).rgb/float(AA*AA);}\n\n#define SH_MAX_L 3\n#define SH_MAX_L_M ((SH_MAX_L + 1) * (SH_MAX_L + 1))\n\n//#define USE_SH_ROTATION // Generate SH from cubemap directly.\n// https://www.shadertoy.com/view/sd33Wr\n// An Efficient Representation for Irradiance Environment Maps (Ravi et al)\n// https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n\n//============================================================ Common\n\nfloat pow2(float x) {return x * x;}\nfloat pow3(float x) {return x * x * x;}\nfloat pow4(float x) {return pow2(x) * pow2(x);}\nfloat pow5(float x) {return pow4(x) * x;}\n\nbool GetKeyDown(sampler2D keyMap, int keyCode)\n{\n    return texture(keyMap, vec2((float(keyCode) + 0.5) / 256.0, 0.25)).x >= 0.5;\n}\n\nbool GetKeyToggle(sampler2D keyMap, int keyCode)\n{\n    return texture(keyMap, vec2((float(keyCode) + 0.5) / 256.0, 0.75)).x >= 0.5;\n}\n\n//============================================================ Camera\n\nstruct Camera\n{\n    vec3 position;\n    vec3 forward;\n    vec3 up;\n    float aspect;\n    float fieldOfView;\n};\n\nmat3 LookAt(vec3 forward, vec3 up)\n{\n    mat3 m;\n    m[2] = forward;\n    m[0] = normalize(cross(up, m[2]));\n    m[1] = cross(m[2], m[0]);\n    return m;\n}\n\nvec3 MakeViewRay(vec2 uv, Camera cam)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.x *= cam.aspect;\n    ray.xy *= tan(radians(cam.fieldOfView * 0.5));\n    return normalize(ray);\n}\n\nvec3 MakeWorldRay(vec2 uv, Camera cam)\n{\n    vec3 ray = MakeViewRay(uv, cam);\n    return LookAt(cam.forward, cam.up) * ray;\n}\n\nvec3 MouseRotation(vec2 screenPos, vec2 screenSize)\n{\n    vec2 muv = screenPos / screenSize;\n    muv = muv * 2.0 - 1.0;\n    muv.x *= screenSize.x / screenSize.y;\n    muv *= vec2(PI, HALF_PI);\n    muv.y = clamp(muv.y, -0.99 * HALF_PI, 0.99 * HALF_PI);\n    vec4 rot = vec4(cos(muv.x), sin(muv.x), cos(muv.y), sin(muv.y));\n    return normalize(vec3(rot.y * rot.z, rot.w, rot.x * rot.z));\n}\n\n//============================================================ PBR\n\nvoid MetallicSteup(vec3 albedo, float metallic, out vec3 diffuse, out vec3 specular)\n{\n    diffuse = albedo * (1.0 - metallic);\n    specular = mix(vec3(0.04), albedo, metallic);\n}\n\nvec3 Fresnel(float NoV, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow5(1.0 - NoV);\n}\n\nvec3 IndirectSpecular(samplerCube envMap, float mapSize, vec3 normal, vec3 viewDir, vec3 specular, float roughness)\n{\n    vec3 reflDir = reflect(-viewDir, normal);\n    float NoV = max(dot(normal, viewDir), 0.0);\n    vec3 F = Fresnel(NoV, specular);\n    float sigma = pow2(roughness) / (1.0 + roughness);\n\tfloat lod = 1.0 + log2(sigma * mapSize);\n    return F * pow(textureLod(envMap, reflDir, lod).rgb, vec3(2.2));\n}\n\n//============================================================ Spherical Harmonics\n\nvec4 EvaluateSH00(vec3 d)\n{\n    return vec4(d, 0.28209479); // sqrt(1/(4π))\n}\n\nvec4 EvaluateSH10(vec3 d)\n{\n    const float c = 0.48860251; // sqrt(3/(4π))\n    vec4 o;\n    o.w = c * d.z;\n    vec3 p = o.w * d;\n    o.x = 2.0 / c * p.x;\n    o.y = 2.0 / c * p.y;\n    o.z = 2.0 / c * p.z - 1.0;\n    o.xyz *= sign(o.w);\n    return o;\n}\n\nvec4 EvaluateSH11(vec3 d)\n{\n    const float c = 0.48860251; // sqrt(3/(4π))\n    vec4 o;\n    o.w = -c * d.x;\n    vec3 p = o.w * d;\n    o.x = 2.0 / c * p.x + 1.0;\n    o.y = 2.0 / c * p.y;\n    o.z = 2.0 / c * p.z;\n    o.xyz *= sign(o.w);\n    return o;\n}\n\nvec4 EvaluateSH1_1(vec3 d)\n{\n    const float c = 0.48860251; // sqrt(3/(4π))\n    vec4 o;\n    o.w = -c * d.y;\n    vec3 p = o.w * d;\n    o.x = 2.0 / c * p.x;\n    o.y = 2.0 / c * p.y + 1.0;\n    o.z = 2.0 / c * p.z;\n    o.xyz *= sign(o.w);\n    return o;\n}\n\nvec4 EvaluateSH20(vec3 d)\n{\n    const float c = 0.31539157; // sqrt(5/(16π))\n    vec4 o;\n    o.w = c * (3.0 * d.z * d.z - 1.0);\n    vec3 p = o.w * d;\n    o.x = (3.0 / c * o.w + 2.0) * p.x;\n    o.y = (3.0 / c * o.w + 2.0) * p.y;\n    o.z = (3.0 / c * o.w - 4.0) * p.z;\n    o.xyz = normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH21(vec3 d)\n{\n    const float c = 1.09254843; // sqrt(15/(4π))\n    vec4 o;\n    o.w = -c * (d.x * d.z);\n    vec3 p = o.w * d;\n    o.x = 3.0 / c * o.w * p.x + p.z;\n    o.y = 3.0 / c * o.w * p.y;\n    o.z = 3.0 / c * o.w * p.z + p.x;\n    o.xyz = normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH2_1(vec3 d)\n{\n    const float c = 1.09254843; // sqrt(15/(4π))\n    vec4 o;\n    o.w = -c * (d.y * d.z);\n    vec3 p = o.w * d;\n    o.x = 3.0 / c * o.w * p.x;\n    o.y = 3.0 / c * o.w * p.y + p.z;\n    o.z = 3.0 / c * o.w * p.z + p.y;\n    o.xyz = normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH22(vec3 d)\n{\n    const float c = 0.54627422; // sqrt(15/(16π))\n    vec4 o;\n    o.w = c * (d.x * d.x - d.y * d.y);\n    vec3 p = o.w * d;\n    o.x = (3.0 / c * o.w - 2.0) * p.x;\n    o.y = (3.0 / c * o.w + 2.0) * p.y;\n    o.z = 3.0 / c * o.w * p.z;\n    o.xyz = normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH2_2(vec3 d)\n{\n    const float c = 1.09254843; // sqrt(15/(4π))\n    vec4 o;\n    o.w = c * (d.x * d.y);\n    vec3 p = o.w * d;\n    o.x = 3.0 / c * o.w * p.x - p.y;\n    o.y = 3.0 / c * o.w * p.y - p.x;\n    o.z = 3.0 / c * o.w * p.z;\n    o.xyz = normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH30(vec3 d)\n{\n    const float c = 0.37317633; // sqrt(7/(16π))\n    vec4 o;\n    o.w = c * (5.0 * d.z * d.z - 3.0) * d.z;\n    vec3 p = o.w * d;\n    float ww = o.w * o.w;\n    o.x = (4.0 / c * ww + 6.0 * p.z) * p.x;\n    o.y = (4.0 / c * ww + 6.0 * p.z) * p.y;\n    o.z = (4.0 / c * ww - 9.0 * p.z) * p.z + 3.0 * ww;\n    o.xyz = sign(o.w) * normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH31(vec3 d)\n{\n    const float c = 0.45704580; // sqrt(21/(32π))\n    vec4 o;\n    o.w = -c * (5.0 * d.z * d.z - 1.0) * d.x;\n    vec3 p = o.w * d;\n    float ww = o.w * o.w;\n    o.x = (4.0 / c * ww - 2.0 * p.x) * p.x + 5.0 * p.z * p.z - ww;\n    o.y = (4.0 / c * ww - 2.0 * p.x) * p.y;\n    o.z = (4.0 / c * ww - 2.0 * p.x) * p.z + 10.0 * p.x * p.z;\n    o.xyz = sign(o.w) * normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH3_1(vec3 d)\n{\n    const float c = 0.45704580; // sqrt(21/(32π))\n    vec4 o;\n    o.w = -c * (5.0 * d.z * d.z - 1.0) * d.y;\n    vec3 p = o.w * d;\n    float ww = o.w * o.w;\n    o.x = (4.0 / c * ww - 2.0 * p.y) * p.x;\n    o.y = (4.0 / c * ww - 2.0 * p.y) * p.y + 5.0 * p.z * p.z - ww;\n    o.z = (4.0 / c * ww - 2.0 * p.y) * p.z + 10.0 * p.y * p.z;\n    o.xyz = sign(o.w) * normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH32(vec3 d)\n{\n    const float c = 1.44530572; // sqrt(105/(16π))\n    vec4 o;\n    o.w = c * (d.x * d.x - d.y * d.y) * d.z;\n    vec3 p = o.w * d;\n    float ww = o.w * o.w;\n    o.x = (4.0 / c * ww - 2.0 * p.z) * p.x;\n    o.y = (4.0 / c * ww + 2.0 * p.z) * p.y;\n    o.z = 4.0 / c * ww * p.z - p.x * p.x + p.y * p.y;\n    o.xyz = sign(o.w) * normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH3_2(vec3 d)\n{\n    const float c = 2.89061144; // sqrt(105/(4π))\n    vec4 o;\n    o.w = c * (d.x * d.y * d.z);\n    vec3 p = o.w * d;\n    float ww = o.w * o.w;\n    o.x = 4.0 / c * ww * p.x - p.y * p.z;\n    o.y = 4.0 / c * ww * p.y - p.z * p.x;\n    o.z = 4.0 / c * ww * p.z - p.x * p.y;\n    o.xyz = sign(o.w) * normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH33(vec3 d)\n{\n    const float c = 0.59004359; // sqrt(35/(32π))\n    vec4 o;\n    o.w = -c * (d.x * d.x - 3.0 * d.y * d.y) * d.x;\n    vec3 p = o.w * d;\n    float ww = o.w * o.w;\n    o.x = (4.0 / c * ww + 3.0 * p.x) * p.x - 3.0 * p.y * p.y;\n    o.y = (4.0 / c * ww - 6.0 * p.x) * p.y;\n    o.z = 4.0 / c * ww * p.z;\n    o.xyz = sign(o.w) * normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH3_3(vec3 d)\n{\n    const float c = 0.59004359; // sqrt(35/(32π))\n    vec4 o;\n    o.w = -c * (3.0 * d.x * d.x - d.y * d.y) * d.y;\n    vec3 p = o.w * d;\n    float ww = o.w * o.w;\n    o.x = (4.0 / c * ww + 6.0 * p.y) * p.x;\n    o.y = (4.0 / c * ww - 3.0 * p.y) * p.y + 3.0 * p.x * p.x;\n    o.z = 4.0 / c * ww * p.z;\n    o.xyz = sign(o.w) * normalize(o.xyz);\n    return o;\n}\n\nvec4 EvaluateSH(int l, int m, vec3 d)\n{\n    int lm = l * l + l + m;\n    vec4 val = vec4(0.0);\n    switch (lm)\n    {\n        case 0: val = EvaluateSH00(d); break;\n\n        case 1: val = EvaluateSH1_1(d); break;\n        case 2: val = EvaluateSH10(d); break;\n        case 3: val = EvaluateSH11(d); break;\n\n        case 4: val = EvaluateSH2_2(d); break;\n        case 5: val = EvaluateSH2_1(d); break;\n        case 6: val = EvaluateSH20(d); break;\n        case 7: val = EvaluateSH21(d); break;\n        case 8: val = EvaluateSH22(d); break;\n\n        case 9: val = EvaluateSH3_3(d); break;\n        case 10: val = EvaluateSH3_2(d); break;\n        case 11: val = EvaluateSH3_1(d); break;\n        case 12: val = EvaluateSH30(d); break;\n        case 13: val = EvaluateSH31(d); break;\n        case 14: val = EvaluateSH32(d); break;\n        case 15: val = EvaluateSH33(d); break;\n    }\n    return val;\n}\n\nvec3 SampleSH(sampler2D texSH, vec3 normal, int maxL)\n{\n    vec3 col = vec3(0.0);\n    for (int l = 0; l <= maxL; ++l)\n    {\n        for (int m = -l; m <= l; ++m)\n        {\n            int lm = l * l + l + m;\n            vec3 shC = texelFetch(texSH, ivec2(lm, 0), 0).rgb;\n            col += shC * EvaluateSH(l, m, normal).w;\n        }\n    }\n    return col;\n}\n\nvec3 SampleSH2(sampler2D texSH2, vec3 normal)\n{\n#ifdef USE_SH_ROTATION\n    vec3 L00  = texelFetch(texSH2, ivec2(0, 0), 0).rgb;\n    vec3 L1_1 = texelFetch(texSH2, ivec2(1, 0), 0).rgb;\n    vec3 L10  = texelFetch(texSH2, ivec2(2, 0), 0).rgb;\n    vec3 L11  = texelFetch(texSH2, ivec2(3, 0), 0).rgb;\n    vec3 L2_2 = texelFetch(texSH2, ivec2(4, 0), 0).rgb;\n    vec3 L2_1 = texelFetch(texSH2, ivec2(5, 0), 0).rgb;\n    vec3 L20  = texelFetch(texSH2, ivec2(6, 0), 0).rgb;\n    vec3 L21  = texelFetch(texSH2, ivec2(7, 0), 0).rgb;\n    vec3 L22  = texelFetch(texSH2, ivec2(8, 0), 0).rgb;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    L1_1 = -L1_1;\n    L11  = -L11;\n    L2_1 = -L2_1;\n    L21  = -L21;\n    mat4 RM = mat4(vec4(c1*L22.r,c1*L2_2.r,c1*L21.r,c2*L11.r),\n                  vec4(c1*L2_2.r,-c1*L22.r,c1*L2_1.r,c2*L1_1.r),\n                  vec4(c1*L21.r,c1*L2_1.r,c3*L20.r,c2*L10.r),\n                  vec4(c2*L11.r,c2*L1_1.r,c2*L10.r,c4*L00.r-c5*L20.r));\n    mat4 GM = mat4(vec4(c1*L22.g,c1*L2_2.g,c1*L21.g,c2*L11.g),\n                  vec4(c1*L2_2.g,-c1*L22.g,c1*L2_1.g,c2*L1_1.g),\n                  vec4(c1*L21.g,c1*L2_1.g,c3*L20.g,c2*L10.g),\n                  vec4(c2*L11.g,c2*L1_1.g,c2*L10.g,c4*L00.g-c5*L20.g));\n    mat4 BM = mat4(vec4(c1*L22.b,c1*L2_2.b,c1*L21.b,c2*L11.b),\n                  vec4(c1*L2_2.b,-c1*L22.b,c1*L2_1.b,c2*L1_1.b),\n                  vec4(c1*L21.b,c1*L2_1.b,c3*L20.b,c2*L10.b),\n                  vec4(c2*L11.b,c2*L1_1.b,c2*L10.b,c4*L00.b-c5*L20.b));\n    vec4 n4 = vec4(normal,1.0);\n    vec3 diffuse = vec3(dot(n4, RM*n4), dot(n4, GM*n4), dot(n4, BM*n4));\n    return diffuse / PI;\n#else\n    return SampleSH(texSH2, normal, 2);\n#endif\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#ifdef USE_SH_ROTATION\n#define SAMPLE_COUNT 288\n#else\n#define SAMPLE_COUNT 72\n#endif\n\nvec3 IntegralSHCoefficients(samplerCube envMap, int l, int m, int sampleCount)\n{\n    vec3 coeff = vec3(0.0);\n    int sampleCountTheta = max(int(sqrt(float(sampleCount / 2))), 1);\n    int sampleCountPhi = sampleCountTheta * 2;\n    for (int y = 0; y < sampleCountTheta; ++y)\n    {\n        float v = (float(y) + 0.5) / float(sampleCountTheta);\n        //float theta = v * PI;\n        //float cosTheta = cos(theta);\n        //float sinTheta = sin(theta);\n        float cosTheta = 1.0 - 2.0 * v;\n        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n        for (int x = 0; x < sampleCountPhi; ++x)\n        {\n            float u = (float(x) + 0.5) / float(sampleCountPhi);\n            float phi = u * DOUBLE_PI;\n            float cosPhi = cos(phi);\n            float sinPhi = sin(phi);\n            vec3 sampleDir = vec3(cosPhi * sinTheta, sinPhi * sinTheta, cosTheta);\n            vec3 sampleCol = textureLod(envMap, sampleDir, 0.0).rgb;\n            float shY = EvaluateSH(l, m, sampleDir).w;\n            //coeff += sinTheta * shY * sampleCol;\n            coeff += shY * sampleCol;\n        }\n    }\n    //coeff *= (2.0 * PI * PI) / float(sampleCountTheta * sampleCountPhi);\n    coeff *= (4.0 * PI) / float(sampleCountTheta * sampleCountPhi);\n    return coeff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 threadID = ivec2(fragCoord);\n\n    if (threadID.x < SH_MAX_L_M && threadID.y == 0)\n    {\n        if (iFrame % 600 == 60 || GetKeyDown(iChannel2, 32))\n        {\n            int l = int(sqrt(float(threadID.x)));\n            int m = threadID.x - l * l - l;\n            vec3 shC = IntegralSHCoefficients(iChannel1, l, m, SAMPLE_COUNT);\n            fragColor = vec4(shC, 1.0);\n            return;\n        }\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor = texelFetch(iChannel0, threadID, 0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\n#define SAMPLE_COUNT 144\n\nvec3 IntegralIrradiance(samplerCube envMap, vec3 normal, int sampleCount)\n{\n    vec3 irradiance = vec3(0.0);\n    \n    vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    vec3 binormal = cross(tangent, normal);\n    mat3 tangentSpace = mat3(tangent, binormal, normal);\n\n    int sampleCountTheta = max(int(sqrt(float(sampleCount / 4))), 1);\n    int sampleCountPhi = sampleCountTheta * 4;\n    for (int y = 0; y < sampleCountTheta; ++y)\n    {\n        float v = (float(y) + 0.5) / float(sampleCountTheta);\n        //float theta = v * HALF_PI;\n        //float cosTheta = cos(theta);\n        //float sinTheta = sin(theta);\n        float cosTheta = sqrt(1.0 - v);\n        float sinTheta = sqrt(v);\n        for (int x = 0; x < sampleCountPhi; ++x)\n        {\n            float u = (float(x) + 0.5) / float(sampleCountPhi);\n            float phi = u * DOUBLE_PI;\n            float cosPhi = cos(phi);\n            float sinPhi = sin(phi);\n            vec3 sampleDir = vec3(cosPhi * sinTheta, sinPhi * sinTheta, cosTheta);\n            sampleDir = tangentSpace * sampleDir;\n            vec3 radiance = pow(textureLod(envMap, sampleDir, 0.0).rgb, vec3(2.2));\n            //irradiance += sinTheta * cosTheta * radiance;\n            irradiance += radiance;\n        }\n    }\n    //irradiance *= PI * PI / float(sampleCountTheta * sampleCountPhi);\n    irradiance *= PI / float(sampleCountTheta * sampleCountPhi);\n    return irradiance;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n#ifdef USE_SH_ROTATION\n    fragColor.rgb = pow(textureLod(iChannel1, rayDir, 0.0).rgb, vec3(2.2));\n    fragColor.a = 1.0;\n#else\n    if (iFrame % 600 == 0 || GetKeyDown(iChannel2, 32))\n    {\n        vec3 irradiance = IntegralIrradiance(iChannel1, rayDir, SAMPLE_COUNT);\n        fragColor = vec4(irradiance / PI, 1.0);\n        return;\n    }\n    fragColor = textureLod(iChannel0, rayDir, 0.0);\n#endif\n}\n","name":"Cube A","description":"","type":"cubemap"}]}