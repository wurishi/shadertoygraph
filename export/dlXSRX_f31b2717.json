{"ver":"0.1","info":{"id":"dlXSRX","date":"1675104041","viewed":228,"name":" Hyperbolic dodecahedron (fork)","username":"kastorp","description":"forked from Fizzer shader, with different equations I found [url=https://www.sciencedirect.com/topics/biochemistry-genetics-and-molecular-biology/virus-morphology]here[/url]","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["geometry","surface","dual","real","algebraic","sextic"],"hasliked":0,"parentid":"DlfXzB","parentname":"Barth Sextic (+ Halley's Method)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Hyperbolic Dodecahedron + Icosahedron\n// https://www.sciencedirect.com/topics/biochemistry-genetics-and-molecular-biology/virus-morphology\n\n//forked from https://www.shadertoy.com/view/DlfXzB\n \n#define AA         2\n#define USE_NEWTON 0\n\n#define CAVITY 0. //1.= with holes\n//#define INVERT    //uncomment to see smooth polygon \n\nconst float outerDodecahedronCircumradius = 2.;\n\n// Sphere intersection function from IQ\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    vec3 qc = oc - b*rd;\n    float h = ra*ra - dot( qc, qc );\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Extended dual number\nstruct Dual\n{\n   float  f; // f\n   vec2   d; // df/dt, d²f/dt²\n};\n\nconst Dual w = Dual(1., vec2(0));\nconst float  phi = (1. + sqrt(5.)) / 2.;\n\nDual dMul(Dual a, Dual b)\n{\n    Dual res;\n    res.f = a.f * b.f;\n    res.d = vec2(a.d.x * b.f + a.f * b.d.x, a.f * b.d.y + a.d.y * b.f + 2. * a.d.x * b.d.x);\n    return res;\n}\n\nDual dSqr(Dual a)\n{\n    return dMul(a, a);\n}\n\nDual dExp(Dual a)\n{\n    Dual res;\n    res.f = exp(a.f);\n    res.d = vec2(a.d.x*exp(a.f), (a.d.x*a.d.x+a.d.y) *exp(a.f));\n    return res;\n}\n\n\nDual dAdd(Dual a, Dual b)\n{\n   return Dual(a.f + b.f, a.d + b.d);\n}\n\nDual dSub(Dual a, Dual b)\n{\n   return Dual(a.f - b.f, a.d - b.d);\n}\n\nDual dConst(float x)\n{\n    return Dual(x, vec2(0));\n}\n\nDual dLinear(float x)\n{\n    return Dual(0., vec2(x, 0.));\n}\n\nDual dPow(Dual a, int n)\n{\n    Dual r = Dual(0., vec2(0));\n    Dual b = a;\n    for(int i = 0; i < 4; ++i)\n    {\n        if((n & (1 << i)) != 0)\n            r = dAdd(r, b);\n        b = dMul(b, a);\n    }\n    return r;\n}\n\n#define GENERATE_OVERLOADS(op) \\\n    Dual op(Dual a, Dual b, Dual c) { return op(op(a, b), c); } \\\n    Dual op(Dual a, Dual b, Dual c, Dual d) { return op(op(a, b, c), d); } \\\n    Dual op(Dual a, Dual b, Dual c, Dual d, Dual e) { return op(op(a, b, c, d), e); } \\\n    Dual op(Dual a, Dual b, Dual c, Dual d, Dual e, Dual f) { return op(op(a, b, c, d, e), f); }\n    \nGENERATE_OVERLOADS(dAdd)\nGENERATE_OVERLOADS(dSub)\nGENERATE_OVERLOADS(dMul)\n\n// Hyperbolic dodecahedron\n//e^((ϕ^2 + 1) (x^2 + y^2 + z^2)) - e^((x ϕ - y)^2) - e^((x ϕ + y)^2) - e^((x - z ϕ)^2) - e^((x + z ϕ)^2) - e^((y ϕ - z)^2) - e^((y ϕ + z)^2) + 0\nDual dHyperDodecahedron(Dual x, Dual y, Dual z)\n{\n    float w = .98 +sin(iTime)*.02;\nif(  sin(iTime*.3)>0.){\n    return\n#ifdef INVERT\n        //SMOOTH DODECAHEDRON\n        dAdd(dConst(-.022*CAVITY),\n        dMul(dConst(.01), //invert sign and decrease step\n            dSub(\n                //e^((ϕ^2 + 1) (x^2 + y^2 + z^2))  - (...)\n                dExp(dMul(dConst(.5),dAdd(dAdd(dSqr(x),dSqr(y)),dSqr(z)))),\n                dMul(dConst(.001),dAdd(\n#else  \n        //HYPERBOLIC DODECAHEDRON\n        dAdd(dConst(-.063*CAVITY), //cavity\n        dMul(dConst(-.01), //invert sign and decrease step\n            dSub(\n                //e^((ϕ^2 + 1) (x^2 + y^2 + z^2))  - (...)\n                dExp(dMul(dConst((phi*phi+1.)),dAdd(dAdd(dSqr(x),dSqr(y)),dSqr(z)))),\n                dMul(dConst(w),dAdd(\n#endif               \n                    // e^((x ϕ + y)^2) +\n                    dExp(dSqr(dAdd(dMul(dConst(phi),x),y))),\n                    // e^((x ϕ - y)^2) +\n                    dExp(dSqr(dAdd(dMul(dConst(-phi),x),y))),\n                    // e^((y ϕ + x)^2) +                  \n                    dExp(dSqr(dAdd(dMul(dConst(phi),y),z))),\n                    // e^((y ϕ - x)^2) +\n                    dExp(dSqr(dAdd(dMul(dConst(-phi),y),z))),                    \n                    // e^((z ϕ + x)^2) +                   \n                    dExp(dSqr(dAdd(dMul(dConst(phi),z),x))),\n                    // e^((z ϕ - x)^2)+\n                    dExp(dSqr(dAdd(dMul(dConst(-phi),z),x)))                                                         \n                ))\n            )            \n        )); \n}else{       \n    //Hyperbolic Icosahedron\n    Dual dPhi2= dConst(phi*phi),dPhi2N= dConst(-phi*phi);   \n    return\n#ifdef INVERT\n    dAdd(dConst(-.00315*CAVITY), \n    dMul(dConst(.002),dSub(\n    //   exp( (phi^3 + phi^2 + 1 ) ( x^2 + y^2 + z^2 )) \n        dExp(dMul(dConst(.2),dAdd(dSqr(x),dSqr(y),dSqr(z)))),\n        dMul(dConst(1e-9),dAdd(\n#else\n    dAdd(dConst(-.038*CAVITY), \n    dMul(dConst(-.002),dSub(\n    //   exp( (phi^3 + phi^2 + 1 ) ( x^2 + y^2 + z^2 )) \n        dExp(dMul(dConst((phi*phi*phi+ phi*phi+1.)*1.),dAdd(dSqr(x),dSqr(y),dSqr(z)))),\n        dMul(dConst(w*1.),dAdd(\n#endif\n            dAdd(\n                // − exp( phi^2 ( x + y + z )^2)    \n                dExp(dMul(dPhi2,dSqr(dAdd(x,y,z)))),\n                // − exp( phi^2 ( -x + y + z )^2)                  \n                dExp(dMul(dPhi2,dSqr(dSub(dAdd(x,y),z)))),\n                // − exp( phi^2 (  x + y - z )^2)                \n                dExp(dMul(dPhi2,dSqr(dSub(dAdd(y,z),x)))),\n                // − exp( phi^2 ( x - y + z )^2 )             \n                dExp(dMul(dPhi2,dSqr(dSub(dAdd(x,z),y))))\n            ),\n            dAdd( \n                  // − exp(( x + phi^2 y )^2)  \n                  dExp(dSqr(dAdd(x,dMul(y,dPhi2)))),\n                  // − exp(( y + phi^2 z )^2 ) \n                  dExp(dSqr(dAdd(y,dMul(z,dPhi2)))), \n                  // − exp(( z + phi^2 x  )^2) \n                  dExp(dSqr(dAdd(z,dMul(x,dPhi2)))),  \n                  // − exp(( x − phi^2 y )^2 ) \n                  dExp(dSqr(dAdd(x,dMul(y,dPhi2N)))),  \n                  // − exp(( y - phi^2 z )^2) \n                  dExp(dSqr(dAdd(y,dMul(z,dPhi2N)))),  \n                  // − exp(( z − phi^2 x )^2)  \n                  dExp(dSqr(dAdd(z,dMul(x,dPhi2N))))  \n            )\n        ))        \n    )));\n}\n        \n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a),  0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nvec3 traceRay(vec2 fragCoord)\n{\n    // Set up ray.\n    vec3 ro = vec3(0., 0., outerDodecahedronCircumradius * 2.);\n    vec3 rd = normalize(vec3((fragCoord.xy - iResolution.xy / 2.) / iResolution.y, -1.));\n\n    mat3 m = mat3(1.);        \n            \n    if(iMouse.z > 0.)\n        m = rotY((iMouse.x / iResolution.x * 2. - 1.) * 2.) *\n            rotX((iMouse.y / iResolution.y * 2. - 1.) * 2.);\n    else\n        m = rotY(-sin(iTime / 2.)) * rotX(-sin(iTime / 3.));\n\n    ro = m * ro;\n    rd = m * rd;\n\n    float t = 1e5;\n\n    // Use ray-bounding-sphere intersection test to find initial estimate for root-finding.\n    vec2 s = sphIntersect(ro, rd, vec3(0), outerDodecahedronCircumradius);\n\n    bool hit = false;\n    \n    if(s.x > 0. && s.x < s.y)\n    {\n        t = s.x;\n        \n        for(int i = 0; i < 60; ++i)\n        {\n            vec3 rp = ro + rd * t;\n            // Instead of the usual \"divide by length of gradient\", here the gradient along\n            // the ray is computed directly.\n            Dual res = dHyperDodecahedron(dAdd(dConst(rp.x), dLinear(rd.x)),\n                                    dAdd(dConst(rp.y), dLinear(rd.y)),\n                                    dAdd(dConst(rp.z), dLinear(rd.z)));\n            if(t >= s.y)\n                break;\n                \n            if(res.f > -2e-6)\n            {\n                hit = true;\n                break;\n            }\n#if USE_NEWTON\n            // Newton: x = x - f(x) / f'(x)\n            t += min(.25, abs((res.f) / (res.d.x)));\n#else\n            // Halley: x = x - 2f(x)f'(x) / (2(f'(x)²) - f(x)f''(x))\n            t += min(.25, abs(2. * res.f * res.d.x / (2. * res.d.x * res.d.x - res.f * res.d.y)));\n#endif\n        }\n    }\n    \n    vec3 col = vec3(.06);\n\n    if(hit)\n    {\n        vec3 rp = ro + rd * t;\n        \n        // Surface normal from gradient of scalar field.\n        Dual res_x = dHyperDodecahedron(dAdd(dConst(rp.x), dLinear(1.)),\n                                  dAdd(dConst(rp.y), dLinear(0.)),\n                                  dAdd(dConst(rp.z), dLinear(0.)));\n        Dual res_y = dHyperDodecahedron(dAdd(dConst(rp.x), dLinear(0.)),\n                                  dAdd(dConst(rp.y), dLinear(1.)),\n                                  dAdd(dConst(rp.z), dLinear(0.)));\n        Dual res_z = dHyperDodecahedron(dAdd(dConst(rp.x), dLinear(0.)),\n                                  dAdd(dConst(rp.y), dLinear(0.)),\n                                  dAdd(dConst(rp.z), dLinear(1.)));\n        vec3 n = normalize(vec3(res_x.d.x, res_y.d.x, res_z.d.x));\n\n        // Base surface colour\n        vec3 diff = .5+.5*cos(vec3(0,2,4) + length(rp)*10.);\n        diff = mix(diff, diff * .75, mod(floor(rp.x * 4.) + floor(rp.y * 4.) + floor(rp.z * 4.), 2.));\n        \n        \n        // Basic lighting\n        \n        float fr = mix(.01, 1., pow(1. - clamp(dot(rd, n), 0., 1.), 2.));\n        vec3 r = reflect(-rd, n);\n\n        vec3 l = normalize(vec3(1));\n        col = diff * (dot(l, -n) * .5 + .5) * (1. - fr) * vec3(1., 1., .9);\n        col += diff * mix(.25, 1., (dot(vec3(0,-1,0), -n) * .5 + .5) * (1. - fr)) * vec3(.2,.2,.4);\n        col += smoothstep(.5, 1., max(0., dot(-r, l))) * fr * 1.1;\n    }\n    \n    return clamp(col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            col += traceRay(fragCoord + vec2(x, y) / float(AA));\n        }\n\n    col /= float(AA) * float(AA);\n\n    fragColor = vec4(sqrt(col), 1.);\n}","name":"Image","description":"","type":"image"}]}