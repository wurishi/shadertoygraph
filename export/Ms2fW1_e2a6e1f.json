{"ver":"0.1","info":{"id":"Ms2fW1","date":"1500349794","viewed":175,"name":"smin'd sdfs with colors?","username":"floopfloop","description":"How can I 'properly' apply the color to the smin blending here?\n\nThanks.\n\n(first attempt: https://www.shadertoy.com/view/ldSfDD)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","color","help","smin","question"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I want these SDF's to blend their colors at the edges\n//   see below\n\n// signed distance field box\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// polynomial smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rotate(vec3 p, vec3 e) {\n\t// yzx rotation order\n\tfloat sa = sin(e.z);\n\tfloat ca = cos(e.z);\n\tfloat sb = sin(e.x);\n\tfloat cb = cos(e.x);\n\tfloat sh = sin(e.y);\n\tfloat ch = cos(e.y);\n\t\n\tmat3 m = inverse(mat3(\n\t\tch * ca, \n\t\t-ch * sa * cb + sh * sb, \n\t\tch * sa * sb + sh * cb,\n\t\t\n\t\tsa, \n\t\tca * cb, \n\t\t-ca * sb,\n\t\t\n\t\t-sh * ca, \n\t\tsh * sa * cb + ch * sb, \n\t\t-sh * sa * sb + ch * cb\n\t));\n    \n    return m * p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 screen_space_mouse_position = iMouse.xy;\n\tvec2 screen_space_center = vec2(0.5, 0.5) * iResolution.xy;\n\tvec3 curpos = vec3(fragCoord.xy - screen_space_mouse_position, 0.0);\n    \n    // Explicitly rotated for demonstration purposes\n\tvec3 euler_angles = vec3(0.5, 0.657, 0.0);\n    \n    // use this for mouse based rotation\n    //vec3 euler_angles = vec3(screen_space_mouse_position.x * 0.01, screen_space_mouse_position.y * 0.01, 0.0);\n    \n\tvec3 box1_position = rotate(curpos, euler_angles);\n\tvec3 box2_position = rotate(curpos + vec3(180, 60, 0.0), euler_angles);\n\t\n\tvec3 box1_scale = vec3(100., 100., 100.);\n\tvec3 box2_scale = vec3(50., 50., 50.);\n\t\n    // defining the silouette fields here\n\tfloat box1_silouette = sdBox(box1_position, box1_scale);\n\tfloat box2_silouette = sdBox(box2_position, box2_scale);\n\t\n\tfloat merged_silouette = smin(box1_silouette, box2_silouette, 20.0);\n\t\n    // defining the colors here\n\tvec3 box1_color = vec3(1.0, 0.0, 1.0);\n\tvec3 box2_color = vec3(0.0, 1.0, 1.0);\n\t\n    \n    // This use of mix() kinda works, but seems to gives a preference to parameter #2 \n    //   (see below), causing box2's color to bleed from box1's side\n    // Try swapping them to see what I mean.\n    \n    // here's a hack that seems to get more expected behaviour, \n    // for reasons I'm not entirely clear on yet. just uncomment to test\n    /*\n    if (box1_silouette > 5.0) { box1_silouette = 1.0; } else { box1_silouette = 0.0; }    \n    if (box2_silouette > 5.0) { box2_silouette = 1.0; } else { box2_silouette = 0.0; }\n    */\n\tvec3 merged_color = mix(\n        mix(box1_color, box2_color, box1_silouette), // #1\n        mix(box1_color, box2_color, box2_silouette), // #2\n        merged_silouette\n    );\n    \n    // Gives hard blending, which is neat\n    // Doesn't look quite as good on mouse-based rotations as expected though, \n    //   what with it following the field.\n    \n    //   Be careful what you wish for an all, right? :)\n    if (merged_silouette > 0.0) {\n        fragColor = vec4(0.0);\n    } else {\n\t\tfragColor = vec4(merged_color, 1.0);\n    }\n    \n    // First attempt to replace the above branch with math.\n    // It has some unpleasant color artifacts when SDF's barely touch\n    /*\n    fragColor = mix(\n    \tvec4(merged_color, 1.0), \n\t\tvec4(0.0), \n\t\tclamp(\n\t\t\tmerged_silouette + 1.0, \n\t\t\t0.0, \n\t\t\t1.0\n\t\t)\n\t);\n\t*/\n    \n\t// Debugs\n    //fragColor = vec4(box1_silouette * merged_silouette);\n    //fragColor = vec4(box2_silouette * merged_silouette);\n    \n}","name":"Image","description":"","type":"image"}]}