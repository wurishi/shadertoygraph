{"ver":"0.1","info":{"id":"7dsSD4","date":"1618685324","viewed":64,"name":"CG task 2","username":"VaryaK","description":"Made by: Varvara Kondratyeva\nVariant: icosahedron + water","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"fsfXW4","parentname":" Attempt 6 rubin & emerald"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float eps = 0.001;\nconst float INF = 1e10;\n\nconst vec3 CAMERA_POS = vec3(7, 3.2, -5);\n\nconst vec3 ICOS_POS = vec3(0.0, 0.0, -0.6);\nconst vec3 SP_POS = vec3(0.0, 0.4, 0.5);\nconst vec3 RUBIN_POS = vec3(2.3,-0.9,0);\nconst vec3 EMERALD_POS = vec3(1.3, -0.9, -1.7);\nconst vec3 SAPPHIRE_POS = vec3(-0.5, -0.8, -2.0);\nconst vec3 PRISM_POS = vec3(-2.0, -1.2, -3.0);\n\nconst vec3 LIGHT1_POS = vec3(-1, 1.5, 5);\nconst float LIGHT1_RADIUS = 0.5;\nconst vec3 LIGHT1_COLOR = vec3(1, 1, 1);\n\nconst vec3 LIGHT2_POS = vec3(2, 2.5, -3);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec3 LIGHT2_COLOR = vec3(0.9, 0.9, 0.98);\n\nconst vec3 BALL_POS = vec3(0.0, 0.4, 0.5);\nconst float BALL_RADIUS = 0.7;\nconst vec3 BALL_COLOR = vec3(1,1,1);\n\nvec3 randDir;\n\nbool isIcos = false;\nbool isCyl = false;\nbool isRubin = false;\nbool isEmerald = false;\nbool isSphere = false;\nbool isSapphire = false;\nbool isPrism = false;\n\n//Icosahedron's vertexes\nconst float phi = (1.0 + sqrt(5.0)) / 2.0;\n\nconst vec3 p2 = vec3(-1.0, 0.0 + 0.5, -phi + 1.0);\nconst vec3 p6 = vec3(1.0, 0.0 + 0.5, -phi + 1.0);\n\nconst vec3 p12 = vec3(0.0, phi + 0.5, -1.0 + 1.0);\nconst vec3 p17 = vec3(0.0, -phi + 0.5, -1.0 + 1.0);\n\nconst vec3 p27 = vec3(-phi, 1.0 + 0.5, 0.0 + 1.0);\nconst vec3 p31 = vec3(phi, 1.0 + 0.5, 0.0 + 1.0);\nconst vec3 p33 = vec3(phi, -1.0 + 0.5, 0.0 + 1.0);\nconst vec3 p37 = vec3(-phi, -1.0 + 0.5, 0.0 + 1.0);\n\nconst vec3 p46 = vec3(0.0, phi + 0.5, 1.0 + 1.0);\nconst vec3 p51 = vec3(0.0, -phi + 0.5, 1.0 + 1.0);\n\nconst vec3 p54 = vec3(-1.0, 0.0 + 1.0, phi + 1.0);\nconst vec3 p58 = vec3(1.0, 0.0 + 1.0, phi + 1.0);\n\n\n//Octahedron's vertexes\nconst vec3 v1 = vec3(0.5, 0.0, 0.0);\nconst vec3 v2 = vec3(-0.5, 0.0, 0.0);\nconst vec3 v3 = vec3(0.0, 0.5, 0.0);\nconst vec3 v4 = vec3(0.0, -0.5, 0.0);\nconst vec3 v5 = vec3(0.0, 0.0, 0.5);\nconst vec3 v6 = vec3(0.0, 0.0, -0.5);\n\n//Prism's vertexes\nconst vec3 d1 = vec3(0.0, 0.0, 0.0);\nconst vec3 d2 = vec3(0.6, 0.0, 0.0);\nconst vec3 d3 = vec3(0.0, 1.0, 0.0);\nconst vec3 d4 = vec3(0.0, 0.0, 2.0);\nconst vec3 d5 = vec3(0.6, 0.0, 2.0);\nconst vec3 d6 = vec3(0.0, 1.0, 2.0);\n\n\n\n//intersection of 1 (one) triangle\nfloat traceTriangle(vec3 pos, vec3 direction, vec3 a, vec3 b, vec3 c, out vec3 normal) {\n    vec3 ba = b - a;\n    vec3 ac = c - a;\n    vec3 dir = normalize(direction);\n    normal = normalize(cross(ba,ac));\n    if (dot(normal, dir) > 0.0){\n        normal = -normal;\n    }\n    float D = -dot(normal, a);\n    float n = dot(normal, dir);\n    if (n < eps && n > (-eps)) {\n        return INF;\n    }\n    float t = -(dot(normal, pos)+D)/n;\n    if (t < 0.0) {\n        return INF;\n    }\n    vec3 x;\n    x.x = pos.x+dir.x*t;\n    x.y = pos.y+dir.y*t;\n    x.z = pos.z+dir.z*t;\n    float dab = sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n    float dac = sqrt((a.x-c.x)*(a.x-c.x)+(a.y-c.y)*(a.y-c.y)+(a.z-c.z)*(a.z-c.z));\n    float dax = sqrt((a.x-x.x)*(a.x-x.x)+(a.y-x.y)*(a.y-x.y)+(a.z-x.z)*(a.z-x.z));\n    float dbc = sqrt((b.x-c.x)*(b.x-c.x)+(b.y-c.y)*(b.y-c.y)+(b.z-c.z)*(b.z-c.z));\n    float dbx = sqrt((b.x-x.x)*(b.x-x.x)+(b.y-x.y)*(b.y-x.y)+(b.z-x.z)*(b.z-x.z));\n    float dcx = sqrt((c.x-x.x)*(c.x-x.x)+(c.y-x.y)*(c.y-x.y)+(c.z-x.z)*(c.z-x.z));\n    float ppabc = (dab + dbc + dac)/2.0;\n    float ppabx = (dab + dbx + dax)/2.0;\n    float ppacx = (dac + dcx + dax)/2.0;\n    float ppbcx = (dbc + dcx + dbx)/2.0;\n    float pabc = sqrt(ppabc*(ppabc-dab)*(ppabc-dbc)*(ppabc-dac));\n    float pabx = sqrt(ppabx*(ppabx-dab)*(ppabx-dbx)*(ppabx-dax));\n    float pacx = sqrt(ppacx*(ppacx-dac)*(ppacx-dcx)*(ppacx-dax));\n    float pbcx = sqrt(ppbcx*(ppbcx-dbc)*(ppbcx-dcx)*(ppbcx-dbx));\n    if (pabc + eps > pabx + pacx + pbcx){\n        return t;\n    }\n    return INF;\n}\n\n\n//intersection of icosahedron's and octahedron's side\nvoid triangleIntersect (const vec3 a, const vec3 b, const vec3 c, vec3 pos, \n                        vec3 dir, out float tmin, out vec3 normal)\n{\n    vec3 norm;\n    float tmp = traceTriangle(pos, dir, a, b, c, norm);\n\tif (tmp > eps && tmp < tmin) {\n\t\ttmin = tmp;\n\t\tnormal = norm;\n\t}\n}\n\n\nfloat traceIcos(vec3 pos, vec3 dir, out vec3 normal) {\n    float tmin = INF;\t\n    \n\ttriangleIntersect(p2, p6, p17, pos, dir, tmin, normal);\n\ttriangleIntersect(p2, p12, p6, pos, dir, tmin, normal);\n\ttriangleIntersect(p2, p17, p37, pos, dir, tmin, normal);\n\ttriangleIntersect(p2, p37, p27, pos, dir, tmin, normal);\n\t\n\ttriangleIntersect(p2, p27, p12, pos, dir, tmin, normal);\n\ttriangleIntersect(p37, p54, p27, pos, dir, tmin, normal);\n\ttriangleIntersect(p27, p54, p46, pos, dir, tmin, normal);\n\ttriangleIntersect(p27, p46, p12, pos, dir, tmin, normal);\n\t\n\ttriangleIntersect(p12, p46, p31, pos, dir, tmin, normal);\n\ttriangleIntersect(p12, p31, p6, pos, dir, tmin, normal);\n\ttriangleIntersect(p6, p31, p33, pos, dir, tmin, normal);\n\ttriangleIntersect(p6, p33, p17, pos, dir, tmin, normal);\n\t\n\ttriangleIntersect(p17, p33, p51, pos, dir, tmin, normal);\n\ttriangleIntersect(p17, p51, p37, pos, dir, tmin, normal);\n\ttriangleIntersect(p37, p51, p54, pos, dir, tmin, normal);\n\ttriangleIntersect(p58, p54, p51, pos, dir, tmin, normal);\n\t\n\ttriangleIntersect(p58, p46, p54, pos, dir, tmin, normal);\n\ttriangleIntersect(p58, p31, p46, pos, dir, tmin, normal);\n\ttriangleIntersect(p58, p33, p31, pos, dir, tmin, normal);\n\ttriangleIntersect(p58, p51, p33, pos, dir, tmin, normal);\n\t\n\tif (tmin>0.0 && tmin<INF)\n\t\treturn tmin;\n\treturn INF;\n}\n\nfloat traceOct(vec3 pos, vec3 dir, out vec3 normal) {\n    float tmin = INF;\t\n    \n\ttriangleIntersect(v1, v3, v5, pos, dir, tmin, normal);\n\ttriangleIntersect(v1, v3, v6, pos, dir, tmin, normal);\n\ttriangleIntersect(v2, v3, v5, pos, dir, tmin, normal);   \n\ttriangleIntersect(v2, v3, v6, pos, dir, tmin, normal);\n    \n\ttriangleIntersect(v1, v4, v6, pos, dir, tmin, normal);\n\ttriangleIntersect(v1, v4, v5, pos, dir, tmin, normal);\n    triangleIntersect(v2, v4, v6, pos, dir, tmin, normal);\n\ttriangleIntersect(v2, v4, v5, pos, dir, tmin, normal);\n\n    if (tmin>0.0 && tmin<INF)\n\t\treturn tmin;\n\treturn INF;\n}\n\nfloat tracePrism(vec3 pos, vec3 dir, out vec3 normal) {\n    float tmin = INF;\t\n    \n\ttriangleIntersect(d1, d2, d3, pos, dir, tmin, normal);\n\ttriangleIntersect(d1, d2, d4, pos, dir, tmin, normal);\n\ttriangleIntersect(d2, d4, d5, pos, dir, tmin, normal);   \n\ttriangleIntersect(d4, d5, d6, pos, dir, tmin, normal);\n    \n\ttriangleIntersect(d2, d5, d6, pos, dir, tmin, normal);\n\ttriangleIntersect(d2, d3, d6, pos, dir, tmin, normal);\n    triangleIntersect(d1, d3, d6, pos, dir, tmin, normal);\n\ttriangleIntersect(d1, d4, d6, pos, dir, tmin, normal);\n\n    if (tmin>0.0 && tmin<INF)\n\t\treturn tmin;\n\treturn INF;\n}\n\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 1.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 1.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    if (!isSphere) {\n        vec3 sphNorm;\n        float sphT = traceSphere(pos - BALL_POS, dir, BALL_RADIUS, sphNorm);\n        if (sphT < dist)\n            return true;\n    }\n    \n    \n    if (!isCyl) {\n        vec3 cylNorm;\n        float cylT = traceCylinder(pos, dir, cylNorm);\n        if (cylT < dist)\n            return true;\n    }\n    if (!isIcos) {\n        vec3 icosNorm;\n        float icosT = traceIcos(pos - ICOS_POS, dir, icosNorm);\n        if (icosT < dist)\n            return true;\n    }\n    \n    \n    if (!isRubin) {\n        vec3 octNorm;\n        float octT = traceOct(pos - RUBIN_POS, dir, octNorm);\n        if (octT < dist)\n            return true;\n    }\n    \n    if (!isEmerald) {\n        vec3 octNorm;\n        float octT = traceOct(pos - EMERALD_POS, dir, octNorm);\n        if (octT < dist)\n            return true;\n    }\n    \n    if (!isSapphire) {\n        vec3 octNorm;\n        float octT = traceOct(pos - SAPPHIRE_POS, dir, octNorm);\n        if (octT < dist)\n            return true;\n    }\n    \n    if (!isPrism) {\n        vec3 prismNorm;\n        float prismT = tracePrism(pos - PRISM_POS, dir, prismNorm);\n        if (prismT < dist)\n            return true;\n    }\n    \n    return false;\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    //sharp shadows\n    float att1 = isOccluded(pos, LIGHT1_POS/* + randDir * LIGHT1_RADIUS*/) ? 0.0 : 20.0f / distSq1;\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    //soft shadows\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 35.0f / distSq2;\n   \n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    \n    //total internal reflection can be seen only if n2>n1 (ray is going from glass/rubin/etc into air)\n    //critical angle = arcsin(n2/n1)\n    if (n1 > n2 && asin(sinA) > asin(n2/n1) ) {\n        return reflect(v, normal);\n    }\n  \n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    const int WATER = 4;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float GLASS_N = 1.51;\n    const float AIR_N = 1.0;\n    const float RUBIN_N = 1.77;\n    const float EMERALD_N = 1.58;\n    const float SAPPHIRE_N = 1.76;\n\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float RUBIN_R = pow2(RUBIN_N - GLASS_N) / pow2(RUBIN_N + GLASS_N);\n    float EMERALD_R = pow2(EMERALD_N - GLASS_N) / pow2(EMERALD_N + GLASS_N);\n    float SAPPHIRE_R = pow2(SAPPHIRE_N - GLASS_N) / pow2(SAPPHIRE_N + GLASS_N);\n\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        isIcos = false;\n        isCyl = false;\n        isRubin = false;\n        isEmerald = false;\n        isSphere = false;\n        isSapphire = false;\n        isPrism = false;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        \n        \n        vec3 ballNorm;\n        float ballT = traceSphere(curPos - BALL_POS, curDir, BALL_RADIUS, ballNorm);\n        if (ballT < t) {\n            t = ballT;\n            isSphere = true;\n            isIcos = true;\n            materialType = DIFFUSE;\n            color = BALL_COLOR;\n            normal = ballNorm;\n        }\n        \n        \n        vec3 sphNorm;\n        float sphT = traceSphere(curPos - SP_POS, curDir, 0.9, sphNorm);\n        if (sphT < t) {\n            t = sphT;\n            normal = sphNorm;\n            isIcos = true;\n            isSphere = true;\n            materialType = WATER;\n            \n            vec3 worldPos = t * curDir + curPos;\n            colorMult = vec3(1,1,1);\n            colorMult *= texture(iChannel3, fragCoord/iResolution.xy).rgb;\n        }\n        \n        \n        vec3 icosNorm;\n        float icosT = traceIcos(curPos - ICOS_POS, curDir, icosNorm);\n        if (icosT < t) {\n           t = icosT;\n           normal = icosNorm;\n           isIcos = true;\n           if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = REFRACTION;\n                if (n1 == AIR_N)\n                    nEnter = GLASS_N;\n                if (n1 == GLASS_N)\n                    nEnter = AIR_N;\n            }\n            \n        }\n        \n       \n        \n        vec3 octNorm;\n        float octT = traceOct(curPos - RUBIN_POS, curDir, octNorm);\n        if (octT < t) {\n            t = octT;\n            isRubin = true;\n            normal = octNorm;\n            if (randVals.x < RUBIN_R) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1.0, 0.0, 0.5);\n                materialType = REFRACTION;\n                if (n1 == AIR_N)\n                    nEnter = RUBIN_N;\n                if (n1 == RUBIN_N)\n                    nEnter = AIR_N;\n                \n            }\n        }\n        \n        \n        vec3 octNorm2;\n        float octT2 = traceOct(curPos - EMERALD_POS, curDir, octNorm2);\n        if (octT2 < t) {\n            t = octT2;\n            isEmerald = true;\n            normal = octNorm2;\n            if (randVals.x < EMERALD_R) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.1, 0.8, 0.1);\n                materialType = REFRACTION;\n                if (n1 == AIR_N)\n                    nEnter = EMERALD_N;\n                if (n1 == EMERALD_N)\n                    nEnter = AIR_N;\n            }\n        }\n        \n        \n        vec3 octNorm3;\n        float octT3 = traceOct(curPos - SAPPHIRE_POS, curDir, octNorm3);\n        if (octT3 < t) {\n            t = octT3;\n            isSapphire = true;\n            normal = octNorm3;\n            if (randVals.x < SAPPHIRE_R) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.1, 0.1,1.0);\n                materialType = REFRACTION;\n                if (n1 == AIR_N)\n                    nEnter = SAPPHIRE_N;\n                if (n1 == SAPPHIRE_N)\n                    nEnter = AIR_N;\n            }\n        }\n        \n        \n        vec3 prismNorm;\n        float prismT = tracePrism(curPos - PRISM_POS, curDir, prismNorm);\n        if (prismT < t) {\n            t = prismT;\n            isPrism = true;\n            normal = prismNorm;\n            materialType = REFLECTION;\n        }\n        \n        \n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            isCyl = true;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            } else if (materialType == WATER) {\n                curPos = worldPos + curDir * 1e-5;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat rand (vec2 v) {\n    return fract(sin(dot(v.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n\nfloat noise (in vec2 v) {\n    vec2 whole = floor(v);\n    vec2 fractional = fract(v);\n\n    float a = rand(whole);\n    float b = rand(whole + vec2(1.0, 0.0));\n    float c = rand(whole + vec2(0.0, 1.0));\n    float d = rand(whole + vec2(1.0, 1.0));\n\n    vec2 u = fractional * fractional * (3.0 - 2.0 * fractional);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm (in vec2 v) {\n    float value = 0.0;\n    float amplitude = 0.5;\n   \n    for (int i = 0; i < 6; i++) {\n        value += amplitude * noise(v);\n        v *= 1.4;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 coord1 = rotate2d(0.9*PI ) * uv;\n    vec2 coord2 = rotate2d(0.06*PI ) * uv;\n \n    float wave1 = fbm(vec2(coord1.x*30.0,coord1.y*3.0));\n\tfloat wave2 = fbm(vec2(coord2.x*30.0,coord2.y*3.0));\n    \n    float Waves = pow(mix(wave1,wave2,0.5), 2.0);\n        \n    fragColor = vec4(Waves);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 samp1 = texture(iChannel0, uv);\n    \n    vec2 disp = uv;\n    disp.x += samp1.x*0.08;\n    \n    vec4 samp2 = texture(iChannel0, disp);\n  \n    vec3 final = mix(vec3(0.1,1,1),samp2.rgb, 0.7);\n    \n    fragColor = vec4(final.r,final.g,final.b,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}