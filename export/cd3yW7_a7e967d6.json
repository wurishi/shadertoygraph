{"ver":"0.1","info":{"id":"cd3yW7","date":"1695366024","viewed":98,"name":"SuperBokeh","username":"vemodalen","description":"test demo for bokeh effect","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bokeh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The Golden Angle is (3.-sqrt(5.0))*PI radians, which doesn't precompiled for some reason.\n// The compiler is a dunce I tells-ya!!\n#define ITERATIONS 1000\n#define GOLDEN_ANGLE 2.3999632\n#define HIGHLIGHT_BOOST 1.05\n#define PI 3.1415926535897932384626433832795\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n//-------------------------------------------------------------------------------------------\nvec4 Bokeh(sampler2D tex, vec2 uv, float radius){\n    vec4 color;\n    vec4 tmp = texture(tex, uv);\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    float gamma = 2.2;\n    float count = 0.06;\n    tmp = tmp*count;\n    float weight = 1.0;\n    \n    // Calculate distance to frame center and direction\n    vec2 dir = uv - vec2(0.5);\n    float edgeDistance = pow(length(dir),2.);\n    float angle = atan(dir.y, dir.x);\n    \n    for (int j = 0; j < ITERATIONS; j++)\n    {\n        // the approx increase in the scale of sqrt(0, 1, 2, 3...)\n        r += 1. / r;\n        vangle = rot * vangle;\n       // Apply cat-eye effect   \n        // Calculate the distance to the center\n        /// Apply elliptical, directional, and swirling distortion\n        float swirl = angle ;\n        mat2 swirlMat = mat2(cos(swirl), -sin(swirl), sin(swirl), cos(swirl));\n        \n        vec2 distorted_vangle = vangle * vec2(1.0 + edgeDistance, 1.0 / (1.0 + edgeDistance));\n        distorted_vangle = swirlMat  * distorted_vangle;\n\n        vec2 p = uv + (r - 1.) * distorted_vangle;\n        \n        vec4 subsample  = texture(tex, p); /// ... Sample the image// . \n         // Calculate the average intensity of the accumulated color\n        float intensity = dot(subsample.rgb, vec3(0.299, 0.587, 0.114));\n        float brightness = max(max(subsample.r, subsample.g), subsample.b);\n\n         // Highlight Boosting and Saturation\n        if(intensity  > 0.9){\n            subsample.rgb = vec3(subsample.r * HIGHLIGHT_BOOST, subsample.g * HIGHLIGHT_BOOST, subsample.b * HIGHLIGHT_BOOST);\n        }\n        else{\n            subsample.rgb = subsample.rgb;\n        }\n        \n        \n        if(brightness  < 0.99 && brightness>=0.5)\n        {\n           weight=1.;\n        }\n        else if(brightness < 0.7)\n            weight=2.;\n        else\n            weight=4.;\n\n\n        // Modify color for warmer tone\n        //subsample.rgb = vec3(subsample.r * 1.05, subsample.g * 1.0, subsample.b * 0.9);\n\n        tmp += pow(subsample, vec4(gamma))*weight;\n        \n        count +=weight;\n   }\n         color = pow(tmp/count, vec4(1.0/gamma));\n         return color;\n}\n\nvec4 Bokeh2(sampler2D tex0,sampler2D tex1, vec2 uv, float radius){\n    vec4 color;\n    vec4 tmp = texture(tex0, uv); \n    vec4 acc = vec4(0), div = acc;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    float gamma = 4.; \n    vec4 forwardgamma = vec4(gamma); \n    vec4 backwardgamma = vec4(1./gamma); \n    float count = 0.06;  \n                tmp = tmp*count;\n                float weight; \n        for (int j = 0; j < ITERATIONS; j++)\n    {  \n        // the approx increase in the scale of sqrt(0, 1, 2, 3...)\n        r += 1. / r;\n        vangle = rot * vangle;\n        vec2 p = uv + (r-1.) * vangle;\n        vec4 subsample  = texture(tex0, p); /// ... Sample the image// .\n        weight = texture(tex1, p).x;  \n        tmp += pow(subsample, forwardgamma)*weight*weight*weight;   \n        count +=(weight*weight*weight);    \n             \n   }\n         vec4 color1 = pow(tmp/count, backwardgamma); \n         color.rgb = color1.rgb; \n         return color;\n}\nfloat computeLocalExposure(vec2 uv, float radius, sampler2D tex) {\n    vec4 sum = vec4(0.0);\n    int samples = 10; // Number of samples\n    for (int i = 0; i < samples; i++) {\n        float angle = float(i) * 2.0 * 3.14159 / float(samples);\n        vec2 offset = radius * vec2(cos(angle), sin(angle));\n        sum += texture(tex, uv + offset);\n    }\n    return sum.a / float(samples);\n}\n\nfloat gaussianWeight(float distance, float sigma) {\n    return exp(-distance * distance / (2.0 * sigma * sigma));\n}\nvec4 Bokeh3(sampler2D tex0,sampler2D tex1,sampler2D tex2, vec2 uv, float radius){\n    vec4 color;\n    vec4 tmp = texture(tex0, uv); \n    vec4 acc = vec4(0), div = acc;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    float gamma = 4.; \n    vec4 forwardgamma = vec4(gamma); \n    vec4 backwardgamma = vec4(1./gamma); \n    vec4 depth = texture(tex2, uv);  \n    float scale = depth.x;  \n     float count = 0.06;  \n                tmp = tmp*count;\n    float weight; \n\n        for (int j = 0; j < ITERATIONS; j++)\n    {  \n        // the approx increase in the scale of sqrt(0, 1, 2, 3...)\n        r += 1. / r;\n        vangle = rot * vangle;\n        vec2 p = uv + (r-1.) * vangle * scale;\n        //vec4 subsample  = texture(tex0, p); /// ... Sample the image// .\n        //weight = texture(tex1, p).x;  \n         // 计算边缘因子\n       float edgeFactor = 1.0 + 10.0 * distance(vangle, vec2(0.0));\n\n       vec4 subsample  = texture(tex0, p);\n       weight = texture(tex1, p).x * edgeFactor;  // 加入边缘因子\n\n        tmp += pow(subsample, forwardgamma)*weight*weight;   \n        count +=(weight*weight); \n\n        //float distance = length(vangle);\n        //float sigma = 0.5;\n       // weight = gaussianWeight(distance, sigma);\n\n        //float threshold = 0.5;\n        //if (weight > threshold) {\n           // tmp += pow(subsample, forwardgamma) * weight * weight;\n           // count += (weight * weight);\n        //}\n\n   }\n         vec4 color1 = pow(tmp/count, backwardgamma); \n         color.rgb = color1.rgb * 1.; \n         \n         //float localExposure = computeLocalExposure(uv, radius, tex0);\n         //color.rgb = color1.rgb * localExposure; \n         //color.rgb = (color.rgb * (2.51 * color.rgb + 0.03)) / (color.rgb * (2.43 * color.rgb + 0.59) + 0.14);\n         return vec4(color.rgb, 1.0);;\n}\n\n\n\n//-------------------------------------------------------------------------------------------\nvec4 Bokeh_Weighted(sampler2D tex0,sampler2D tex1,sampler2D tex2, float fscale,vec2 texcoord)\n{\n                vec4 color;\n                float gamma = 4.;\n                ivec2 imgSize = textureSize(tex0, 0);\n                float xStep = 1.0 / float(imgSize.x);\n                float yStep = 1.0 / float(imgSize.y);\n                vec2 dxy = vec2(xStep, yStep);  \n                vec4 samples[32];  \n                samples[0] = vec4(0.857612, 0.019885, 0.563809, -0.028071);\n                samples[1] = vec4(0.825599, -0.346856, 0.126584, -0.380959);\n                samples[2] = vec4(0.782948, 0.594322, 0.292148, -0.543265); \n                samples[3] = vec4(0.130700, 0.330220, 0.236088, 0.159604);  \n                samples[4] = vec4(-0.305259, 0.810505, 0.269616, 0.923026);  \n                samples[5] = vec4(0.484486, 0.371845, -0.638057, 0.080447);  \n                samples[6] = vec4(0.199629, 0.667280, -0.861043, -0.370583);  \n                samples[7] = vec4(-0.040652, -0.996174, 0.330458, -0.282111);  \n                samples[8] = vec4(0.647795, -0.214354, 0.030422, -0.189908);  \n                samples[9] = vec4(0.177430, -0.721124, -0.461163, -0.327434);  \n                samples[10] = vec4(-0.410012, -0.734504, -0.616334, -0.626069);  \n                samples[11] = vec4(0.590759, -0.726479, -0.590794, 0.805365);  \n                samples[12] = vec4(-0.924561, -0.163739, -0.323028, 0.526960);  \n                samples[13] = vec4(0.642128, 0.752577, 0.173625, -0.952386);  \n                samples[14] = vec4(0.759014, 0.330311, -0.360526, -0.032013);  \n                samples[15] = vec4(-0.035320, 0.968156, 0.585478, -0.431068);  \n                samples[16] = vec4(-0.244766, -0.906947, -0.853096, 0.184615);  \n                samples[17] = vec4(-0.089061, 0.104648, -0.437613, 0.285308);  \n                samples[18] = vec4(-0.654098, 0.379841, -0.128663, 0.456572);  \n                samples[19] = vec4(0.015980, -0.568170, -0.043966, -0.771940);  \n                samples[20] = vec4(0.346512, -0.071238, -0.207921, -0.209121);  \n                samples[21] = vec4(-0.624075, -0.189224, -0.120618, 0.689339);  \n                samples[22] = vec4(-0.664679, -0.410200, 0.371945, -0.880573);  \n                samples[23] = vec4(-0.743251, 0.629998, -0.191926, -0.413946);  \n                samples[24] = vec4(0.449574, 0.833373, 0.299587, 0.449113);  \n                samples[25] = vec4(-0.900432, 0.399319, 0.762613, -0.544796);  \n                samples[26] = vec4(0.606462, 0.174233, 0.962185, -0.167019);  \n                samples[27] = vec4(0.960990, 0.249552, 0.570397, 0.559146);  \n                samples[28] = vec4(-0.537514, 0.555019, 0.108491, -0.003232);  \n                samples[29] = vec4(-0.237693, -0.615428, -0.217313, 0.261084);  \n                samples[30] = vec4(-0.998966, 0.025692, -0.418554, -0.527508);  \n                samples[31] = vec4(-0.822629, -0.567797, 0.061945, 0.522105);  \n                vec4 tmp = texture(tex2, texcoord);  \n                float scale = tmp.x;  \n                float count = 0.06;  \n                tmp = tmp*count;\n                float weight; \n                vec4 forwardgamma = vec4(gamma); \n                vec4 backwardgamma = vec4(1.0 /gamma);\n                for(int i = 0; i < 16; i++) {  \n                    vec2 p = samples[2*i].rg; \n                    p =  texcoord +  scale * p * dxy * fscale; \n                    vec4 subsample = texture(tex0, p);  \n                    weight = texture(tex1, p).x;  \n                    tmp += pow(subsample, forwardgamma)*weight;   \n                    count += weight;    \n                    p = samples[2*i].ba;  \n                    p =  texcoord +  scale * p * dxy * fscale;  \n                     subsample = texture(tex0, p);  \n                    weight = texture(tex1, p).x;  \n                    tmp += pow(subsample, forwardgamma)*weight;   \n                    count += weight;    \n                    p = samples[2*i+1].rg;  \n                    p =  texcoord +  scale * p * dxy * fscale;  \n                     subsample = texture(tex0, p);  \n                    weight = texture(tex1, p).x;  \n                    tmp += pow(subsample, forwardgamma)*weight;   \n                     count += weight;    \n                     p = samples[2*i+1].ba;  \n                     p =  texcoord +  scale * p * dxy * fscale;  \n                    subsample = texture(tex0, p);  \n                    weight = texture(tex1, p).x; \n                    tmp += pow(subsample, forwardgamma)*weight;   \n                    count += weight;    \n                }\n                vec4 color1 = pow(tmp/count, backwardgamma); \n                color.rgb = color1.rgb; \n                return color;\n                \n}\nvec4 alphablend(sampler2D tex0,vec4 tex1,sampler2D tex2,vec2 texcoord)\n{\n     vec4 color = vec4(0);\n     vec4 rgba0 = texture(tex0, texcoord);\n\n     vec4 rgba1 = tex1;\n\n     float mask = texture(tex2, texcoord).r;\n\n     color.rgb = mix(rgba1.rgb, rgba0.rgb, min(mask * 2.0, 1.0));\n     color.a = 1.0;\n     return color;\n\n    \n}\n\n\nvec4 HDRBokeh3(sampler2D tex0,sampler2D tex1,sampler2D tex2,sampler2D tex3, vec2 uv, float radius){\n    vec4 acc = vec4(0), div = acc;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    float gamma = 1.; \n    vec4 forwardgamma = vec4(gamma); \n    vec4 backwardgamma = vec4(1./gamma); \n\n        for (int j = 0; j < ITERATIONS; j++)\n    {  \n        // the approx increase in the scale of sqrt(0, 1, 2, 3...)\n        r += 1. / r;\n        vangle = rot * vangle;\n\n        vec4 col0 = texture(tex0, uv + (r-1.) * vangle) *256.; \n        vec4 col1 = texture(tex1, uv + (r-1.) * vangle)*256.;\n        vec4 col2 = texture(tex2, uv + (r-1.) * vangle)*256.;\n        vec4 col3 = texture(tex3, uv + (r-1.) * vangle)*256.;\n        vec4 col = (col0*256.+col1)/65535.+col2*256.+col3; /// ... Sample the image\n        vec4 bokeh = vec4(1.);\n        acc += col * bokeh;\n        div += bokeh;\n        }\n        return pow((acc / div),vec4(1./2.2));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; //... with correct aspect ratio\n    \n    float time = mod(iTime*.2 +.25, 3.0);\n    \n\tfloat rad = (.8 - .8*cos(time * 6.283));\n  \n    if (iMouse.w >= 1.0)\n    {\n    \trad = (iMouse.x/iResolution.x)*3.0;\n\n    }   \n     fragColor = texture(iChannel0, uv);\n\t\t fragColor = vec4(Bokeh(iChannel0, uv, 1.2));\n        // fragColor = vec4(Bokeh2(iChannel0,iChannel1, uv, rad));\n        //fragColor = vec4(HDRBokeh3(iChannel0,iChannel1,iChannel2,iChannel3, uv, rad));\n        // fragColor = vec4(Bokeh_Weighted(iChannel0,iChannel1,iChannel3, rad*50., uv));\n        //fragColor = alphablend(iChannel0,fragColor,iChannel2,uv);\n  // fragColor = vec4(Bokeh_Weighted(iChannel0,iChannel1,rad,fragCoord));\n\n}","name":"Image","description":"","type":"image"}]}