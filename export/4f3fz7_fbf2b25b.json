{"ver":"0.1","info":{"id":"4f3fz7","date":"1732843165","viewed":130,"name":"xenogarden","username":"pb","description":"mandelbox is always full of surprises","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["3d","fractal","raymarch"],"hasliked":0,"parentid":"4ftczN","parentname":"metallique"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float totdist = texture(iChannel0,uv).a;\n    \n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n\n    //O +=  fwidth(O*4.)*vec4(1,1,0,0)*totdist;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//philip.bertani@gmail.com\n\nvec3  ro, ifs_color, light_direction;\nfloat max_iter, normal_mult, norm_dist_expand, sc, glow=0.;\n\nmat3 rot_xz_yz(float a1, float a2) {\n    float c1=cos(a1),c2=cos(a2),s1=sin(a1),s2=sin(a2);\n    return mat3(    c1, 0.,    -s1,\n                -s2*s1, c2, -s2*c1,\n                 c2*s1, s2,  c2*c1 );\n}\n\nfloat mbox (vec3 p)\n{\n    ifs_color = vec3(0.);\n    vec4 offset=vec4(p,1.), v=offset;\n  \n    float n=0.;\n    for (; n<40.;n++) {\n\n        v.xyz = clamp (v.xyz,-2.,1.75) * 1.92 \n                - v.xyz;\n\n        v = v * 3.05\n        / clamp (dot (v.xyz, v.xyz),\n          0.05, 3.) + .9*offset;\n\n    }\n    \n    sc = v.w;  //for coloring\n  \n    return length (v.xyz) / v.w ;\n}\n\nfloat all_objects(vec3 p) {\n    return max( mbox(p), -(length(p-ro)-.001 ) );\n}\n\nvec3 gradient(vec3 p) {\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = (1e-5 + norm_dist_expand) * dpn; \n    vec3 df = dpn.xxx * all_objects(p+dp.xxx) +\n              dpn.yyx * all_objects(p+dp.yyx) +\n              dpn.xyy * all_objects(p+dp.xyy) +\n              dpn.yxy * all_objects(p+dp.yxy);\n    return normalize(df); \n}\n\n\nvec3 bg(vec3 p, vec3 rd, float dist, float totdist) {\n\n    vec3 color = cos(log(1.+sc)+10.*vec3(1,2,3)) * .9;\n    return color*color;\n}\n\nvec3 color(vec3 p, vec3 rd, float dist, float totdist) {\n\n    float t2 = totdist;\n    \n    norm_dist_expand = totdist/300.;\n\n    vec3 nv = gradient(p);\n\n    vec3 color = cos(log(sc)+vec3(1,2,3));\n    \n    color = 1. - exp(-color*color);\n\n    color = 2.*exp(-t2/2.)*color \n              * max (0., dot (nv, -light_direction))  \n              \n         +  exp(-t2*2.)\n            *pow ( max (0., dot (-light_direction,\n                reflect (rd, nv))), 16. );\n\n    return color;\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n\n    float tt = mod(iTime,70.);\n    \n    xy = (2.*xy - iResolution.xy)/iResolution.y;\n    \n    ro = vec3(.1,0,-.2);\n    \n    mat3 rot = rot_xz_yz(.9,-3.25);\n  \n    vec3 rd = rot * normalize(vec3(xy,-1.8));\n      \n    tt > 34. ? rd *= rot_xz_yz(1.,0.) : rd;\n    \n    ro -= rot[2] * (tt*20.+10.)/1500.;\n      \n    float lt =  2.5; //iTime;\n    light_direction = \n        normalize(-rot[2]*rot_xz_yz(sin(lt),cos(lt)) ); \n    \n    vec3  p=ro;\n    float dist,totdist;\n    float eps = 4e-5, hit_threshold=eps;\n\n    float distfac = 2.;\n    vec3  rgb = vec3(0.);\n    \n    for (float f=0.; f<1000.; f++) {\n    \n        dist = .5*all_objects(p);\n        \n        if ( \n            dist < hit_threshold || totdist > 1.) \n            { rgb = totdist > 1.\n              ? bg(p, rd, dist, totdist)\n              : color(p, rd, dist, totdist)\n             ;\n             \n             if (p.y > 0.001 ) rgb *= vec3(0,0,1);\n            break; }\n        \n        float stepsize = dist;\n        p += rd*stepsize;\n\n        totdist += stepsize;\n        \n        hit_threshold = eps*(1.+totdist*distfac);\n    \n    }\n    \n    \n    rgba = vec4( rgb, totdist);\n    rgba +=  fwidth(rgba)*vec4(1,1,0,0)*totdist;\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}