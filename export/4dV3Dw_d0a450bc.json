{"ver":"0.1","info":{"id":"4dV3Dw","date":"1454826057","viewed":161,"name":"WaterLand","username":"VoidChicken","description":"A simple raymarched world.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","refraction","water","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n float rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat height(vec2 va) {\n   \tfloat v = 0.0;\n   \tv = noise(va/10.0);\n    return v;\n}\n\n\nvec3 land(vec2 xz, float x, float t) {\n   \tvec3 a = texture(iChannel0, xz).rgb;\n    vec3 b = texture(iChannel1, xz).rgb;\n    vec3 f = mix(a,b,t-x);\n    return f;\n}\nbool pCollide(vec3 v, out bool w) {\n     w = false;\n     if (v.y < -7.0-2.0*height(v.xz+vec2(time*5.0))) {\n        w = true;  \n    }\n    if (v.y < -5.0-10.0*height(v.xz)) {\n\n    \treturn true;   \n    }\n    return false;\n}\nbool rayHit(vec3 str, vec3 dir, out float d, out vec3 hit, out bool w, out vec3 wv) {\n    bool lwv = w;\n    vec3 dd = dir;\n    vec3 v = str;\n    for (float i = 0.0; i < 100.0; i += 1.0/10.0) {\n        v+=dd/10.0;\n    \tbool c= pCollide(v, w);\n        d = 100.0-i;\n        hit = v;\n        if (w&&!lwv) {\n            wv = v;\n            dd+= vec3(\n                0.5- (height(wv.xz+vec2(-time*5.0)))\n                ,0,\n                0.5-(height(wv.xz+100.0+vec2(time*5.0))\n                    ))/5.0;\n        }\n        lwv = w;\n        if(c)return true;\n    }\n    return false;\n}\nvec3 ray (vec3 str, vec3 dir) {\n    \n    float d;\n    vec3 v;\n    bool w= false;\n    vec3 wv;\n    bool rH = rayHit(str, dir, d, v, w, wv);\n    float x =1.0-height(v.xz);\n    vec3 a = land(v.xz, x, 0.5);\n    float foam = height(wv.xz*10.0+vec2(time*5.0));\n    foam += height(wv.xz*9.0+vec2(time*5.0));\n    foam += height(wv.xz*8.0+vec2(time*5.0));\n    foam += height(wv.xz*7.0+vec2(time*5.0));\n    foam += height(wv.xz*6.0+vec2(time*5.0));\n    foam += height(wv.xz*5.0+vec2(time*5.0));\n    foam/=5.0;\n    foam*=  height(wv.xz*1.0+vec2(time*5.0));\n    foam*=  height(wv.xz*2.0+vec2(time*5.0));\n    foam*=  height(wv.xz*3.0+vec2(time*5.0));\n    vec3 wt =  (a*x)*vec3(0, .5, 1)+foam;\n    return rH?(w?wt:a)*vec3(d/100.0):vec3(0);\n}\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nvec3 nFu(vec2 uv, float rot) {\n    return (vec4(uv-vec2(.5), 1, 1)*rotationMatrix(vec3(0,1,0),rot)).xyz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(ray(vec3(0,1.0-sin(time)*5.0,-15.0+time*10.0), nFu(uv, 0.0)),1.0);\n}","name":"Image","description":"","type":"image"}]}