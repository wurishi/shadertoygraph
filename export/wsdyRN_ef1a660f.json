{"ver":"0.1","info":{"id":"wsdyRN","date":"1600622631","viewed":243,"name":"Menger Fusion Facility","username":"jaburns","description":"Working liberally through these blog posts: https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["ray","marching","menger","tracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    color *= .5; // exposure\n    color = ACESFilm(color);\n    color = LinearToSRGB(color);\n    \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 tri( vec3 x )\n{\n    return abs(x-floor(x)-.5);\n} \nfloat surfFunc( vec2 p0 ) // range 0-1\n{\n    vec3 p = vec3(p0.xy,0);\n    \n    float n = dot(tri(p*.15 + tri(p.yzx*.075)), vec3(.444));\n    p = p*1.5773 - n;\n    p.yz = vec2(p.y + p.z, p.z - p.y) * .866;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * .866;\n    n += dot(tri(p*.225 + tri(p.yzx*.1125)), vec3(.222));     \n    return abs(n-.5)*1.9 + (1.-abs(sin(n*9.)))*.05;\n}\n\nfloat sdBox2d(vec2 p, float r)\n{\n    vec2 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdCross(vec3 p, float r)\n{\n    return min(sdBox2d(p.yz, r), min(sdBox2d(p.xy, r), sdBox2d(p.xz, r)));\n}\n\nfloat opSubtract(float a, float b)\n{\n    return max(a, -b);\n}\n\nmat2 rot( float t )\n{\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nvec2 min2( vec2 a, vec2 b )\n{\n    return a.x < b.x ? a : b;\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * 2. * 3.14159;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec3 getEmissive( float mat, vec3 p, vec3 n )\n{\n    if( mat == 0. ) return vec3( 0 );\n    if( mat == 1. ) return 10.*vec3( 1 );\n    if( mat == 2. ) return 1.*vec3( .5,.2,1 );\n    if( mat == 3. ) return .1*vec3(.5,.1,1);\n}\nvec3 getAlbedo( float mat, vec3 p, vec3 n )\n{\n    if( mat == 0. ) return vec3(1);\n    if( mat == 1. ) return vec3( 1 );\n    if( mat == 2. ) return vec3( 0,0,1 );\n    if( mat == 3. ) return vec3(.5,.1,1);\n}\nfloat getPercentSpecular( float mat, vec3 p, vec3 n )\n{\n    if( mat == 0. ) return 1.;\n    if( mat == 3. ) return 1.;\n    return 0.;\n}\nfloat getRoughness( float mat, vec3 p, vec3 n )\n{\n    if( mat == 0. ) return .8;\n    if( mat == 3. ) return 0.;\n    return 0.;    \n}\nvec3 getSpecularColor( float mat, vec3 p, vec3 n )\n{\n    if( mat == 0. ) return vec3(255., 165., 50.) / 255.;\n    if( mat == 3. ) return vec3(.5,.1,1);\n    return vec3(1);\n}\n\n\n\nvec2 map( vec3 p )\n{\n    vec2 d = vec2( -p.y + 2., 2. );\n    vec3 p1 = mod(p + 3., 6.) - 3.;\n    \n    d = min2( d, vec2( length( p1 + vec3(2,0,2) ) - .45, 1. ));\n    d = min2( d, vec2( length( p1 + vec3(2,0,-2) ) - .45, 1. ));\n    d = min2( d, vec2( length( p1 + vec3(-2,0,2) ) - .45, 1. ));\n    d = min2( d, vec2( length( p1 + vec3(-2,0,-2) ) - .45, 1. ));\n    return d;\n}\n\nvec2 map2( vec3 p, float waterDir )\n{\n    p = mod(p + 3., 6.) - 3.;\n    \n    float d = sdBox(p, vec3(3));        \n    d = opSubtract(d, sdCross(p, 1.));\n\n    float s = 1.;\n    for (int i = 0; i < 5; ++i) {\n        vec3 p1 = mod(s*p + 1., 2.) - 1.;\n        float cutDist = sdCross(p1, 1. / 3.) / s;\n        d = opSubtract(d, cutDist);\n        s *= 3.;\n    }\n\n    float surf = .003*(\n        sin(20.*length(p.xz - vec2(2)))\n        //+sin(17.*length(p.xz + vec2(2)))\n        );\n    return min2( vec2(d, 0.),\n                min2(map(p), vec2(waterDir*(p.y+surf+ 1.1),3.))\n                );\n}\n\nvec3 getNormal( vec3 p, float waterDir )\n{\n    vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(\n        map2(p + e.xyy, waterDir).x - map2(p - e.xyy, waterDir).x,\n        map2(p + e.yxy, waterDir).x - map2(p - e.yxy, waterDir).x,\n        map2(p + e.yyx, waterDir).x - map2(p - e.yyx, waterDir).x));\n}\n\nvec3 trace( vec3 ro, vec3 rd,  uint rngState )\n{\n    vec3 color = vec3( 0 );\n    vec3 throughput = vec3( 1 );\n    float waterDir = 1.;\n    float firstDist = -1.;\n    \n    for( int b = 0; b < 8; ++b )\n    {\n        vec2 distMat;\n        float totalDist = 0.0;    \n        vec3 roo = ro;\n\n        for( int m = 0; m < 200; ++m )\n        {\n            distMat = map2( ro, waterDir );\n            if( distMat.x < .001 || totalDist > 5000. ) break;\n            totalDist += distMat.x;\n            ro += rd * distMat.x;\n        }\n        \n        firstDist = firstDist < 0. ? totalDist : firstDist;\n        \n        if( distMat.x >= .001 )\n            break;\n     \n        /*\n        if( distMat.y == 3. )\n        {\n            waterDir *= -1.;\n            vec3 norm = getNormal( ro, waterDir );\n            ro += norm * .002;\n            rd = refract( rd, -norm, waterDir > 0. ? 1.4 : 1./1.4 );\n            throughput *= vec3(.5,.5,1);\n        }\n*/\n        else\n        {\n            vec3 norm = getNormal( ro, waterDir );\n            ro += norm * .002;\n            float doSpecular = (RandomFloat01(rngState) < getPercentSpecular(distMat.y, ro, norm)) ? 1.0f : 0.0f;\n            float rawRough = getRoughness( distMat.y, ro, norm );        \n            vec3 diffuseRayDir = normalize(norm + RandomUnitVector(rngState));\n            vec3 specularRayDir = reflect(rd, norm);\n            specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, rawRough * rawRough));\n            rd = mix(diffuseRayDir, specularRayDir, doSpecular);\n\n            color += getEmissive( distMat.y, ro, norm ) * throughput;\n            throughput *= mix(getAlbedo( distMat.y, ro, norm ), getSpecularColor( distMat.y, ro, norm ), doSpecular);\n        }\n    }\n    \n    return mix( .1*vec3(.5,0,1), color, exp( -.08 * firstDist ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 fc = fragCoord + vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - .5;\n    vec2 uv = fc/iResolution.yy - vec2(.5*iResolution.x/iResolution.y, .5);\n\n    vec3 ro = vec3( 0,.2,3 );\n    vec3 rd = normalize(vec3(uv, -1));\n    rd.yz *= rot(.1);\n    rd.xz *= rot(.45 );\n\n    \n\n    vec3 color = trace( ro, rd, rngState );\n\n    bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n    \n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    fragColor = vec4(color, blend);   \n} ","name":"Buffer A","description":"","type":"buffer"}]}