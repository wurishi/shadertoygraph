{"ver":"0.1","info":{"id":"NdcyDj","date":"1654042756","viewed":297,"name":"Progressive PathTracer 2 by Omni","username":"Omniscience","description":"WASD/RF/QE/mouselook controls.\nFeatures emissive materials as well as fixes to lighting model. Try messing with the box size, lower or raise the roof, remove faces, add the front face, etc., and see the scene lit with small cracks VS open atmosphere.","likes":18,"published":1,"flags":48,"usePreview":0,"tags":["gi","raytrace","pathtrace","brdf","flycam"],"hasliked":0,"parentid":"fdtczs","parentname":"Progressive PathTracer 1 by Omni"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 kres = 1.0 / iResolution.xy;\n    vec4 samples = texture(iChannel0, fragCoord * kres);\n    \n    fragColor = vec4(samples.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653589793238462643327950;\nconst float TWO_PI = PI * 2.0;\nconst float PI_BY_90 = PI / 90.0;\nconst float DEG_TO_RAD = PI / 180.0;\nconst vec3 FWD = vec3(0.0, 0.0, 1.0);\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\nconst vec3 RIGHT = vec3(1.0, 0.0, 0.0);\nconst vec3 ZERO3 = vec3(0.0, 0.0, 0.0);\nconst vec3 ONE3 = vec3(1.0, 1.0, 1.0);\n\nfloat lerp(float a, float b, float x) { return a + (b-a) * x; }\nvec3 lerp(vec3 a, vec3 b, float x) { return a + (b-a) * x; }\n\nmat4 identity() {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 translate(vec3 pos) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        pos.x, pos.y, pos.z, 1.0\n    );\n}\nmat4 rotateX(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateY(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateZ(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matrixFromQuat(vec4 q) {\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x*x, y2 = y*y, z2 = z*z;\n    \n    float xy = x*y, xz = x*z, yz = y*z,\n          xw = x*w, yw = y*w, zw = z*w;\n    \n    return identity() + 2.0 * mat4(\n        -(y2 + z2),  (xy + zw),  (xz - yw), 0.0,\n         (xy - zw), -(x2 + z2),  (yz + xw), 0.0,\n         (xz + yw),  (yz - xw), -(x2 + y2), 0.0,\n               0.0,        0.0,        0.0, 0.0\n    );\n}\n\nvec4 quatConjugate(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 qmul(vec4 a, vec4 b) {\n    float ax = a.x, ay = a.y, az = a.z, aw = a.w;\n    float bx = b.x, by = b.y, bz = b.z, bw = b.w;\n    return vec4(\n        aw*bx + ax*bw + ay*bz - az*by,\n        aw*by + ay*bw + az*bx - ax*bz,\n        aw*bz + az*bw + ax*by - ay*bx,\n        aw*bw - ax*bx - ay*by - az*bz\n    );\n}\n\nvec3 qmulv(vec4 q, vec3 v) {\n    vec4 vq = vec4(v, 0.0);\n    vec4 c = quatConjugate(q);\n    q = qmul(q, vq);\n    q = qmul(q, c);\n    return q.xyz;\n}\nvec4 qmulv(vec4 q, vec4 v) {\n    return vec4(qmulv(q, v.xyz), v.w);\n}\n\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    angle *= 0.5;\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return vec4(\n        axis.x * sa,\n        axis.y * sa,\n        axis.z * sa,\n        ca\n    );\n}\n\nvec4 quatFromEulerDeg(vec3 euler) {\n    float ex = euler.x, ey = euler.y, ez = euler.z;\n    float ep = ex * PI_BY_90,\n          eq = ey * PI_BY_90,\n          er = ez * PI_BY_90,\n        sinp = sin(ep),\n        siny = sin(eq),\n        sinr = sin(er),\n        cosp = cos(ep),\n        cosy = cos(eq),\n        cosr = cos(er);\n    vec4 q = vec4(\n        sinr * cosp * cosy - cosr * sinp * siny,\n        cosr * sinp * cosy + sinr * cosp * siny,\n        cosr * cosp * siny - sinr * sinp * cosy,\n        cosr * cosp * cosy + sinr * sinp * siny\n    );\n    return normalize(q);\n}\n\nstruct Transform {\n    vec3 pos;\n    vec4 rot;\n};\n\nTransform t_identity() {\n    return Transform(ZERO3, vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 matrixFromTransform(Transform xform) {\n    mat4 m = identity();\n    m *= translate(xform.pos);\n    m *= matrixFromQuat(xform.rot);\n    return m;\n}\n\nconst vec4 gSeed = vec4(12.9898, 77.233, 14.66337, 23.53277);\n\nfloat hash(float p) { return fract(sin(p * gSeed.x)*43758.5453123); }\nfloat hash(vec2 p) { return fract(sin(dot(p, gSeed.xy))*43758.5453123); }\nvec2 hash2(vec2 p) { return fract(sin(p * gSeed.xy)*43758.5453123); }\n\nvec2 rand2(float p) {\n    return hash2(vec2(p).xx);\n}\nvec3 rand3(float p) {\n    vec3 s = gSeed.xyz * p;\n    return vec3(hash(s.x), hash(s.y), hash(s.z));\n}\n\nvec2 randBoxMuller(vec2 U) {\n    float R = sqrt(-2.0 * log(max(U.x, EPSILON)));\n    float t = 2.0 * PI * U.y;\n    return vec2(\n        R*cos(t),\n        R*sin(t)\n    );\n}\n\nvec3 gauss3(vec3 v, float std, float p) {\n    vec2 seed = rand2(p);\n    vec2 r = std * clamp(randBoxMuller(seed), -TWO_PI, TWO_PI);\n    vec4 q = qmul(\n        quatFromAxisAngle(RIGHT,  r.x),\n        quatFromAxisAngle(UP,     r.y)\n    );\n    return qmulv(q, v);\n}\n\nvec3 gaussReflect(vec3 v, vec3 n, float u, float p) {\n    vec2 seed = rand2(p);\n    vec3 r = reflect(v, n);\n    //float dp = dot(r, n);\n    //return gauss3(r,u,p);\n    \n    vec2 r2 = u * clamp(randBoxMuller(seed), -TWO_PI, TWO_PI);\n    \n    vec4 q = qmul(\n        quatFromAxisAngle(RIGHT,  r2.x),\n        quatFromAxisAngle(UP,     r2.y)\n    );\n    \n    vec3 gr = qmulv(q, r);\n    vec3 gn = qmulv(q, n);\n    if (dot(gr, n) < 0.0)\n        return gn;\n    return gr;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define STATE_LENGTH   5.0\n#define STATE_LENGTH_I 5\n\n#define STATE_FLAGS 0.5\n#define STATE_POS   1.5\n#define STATE_ROT   2.5\n#define STATE_VEL   3.5\n#define STATE_MOUSE 4.5\n\n#define STATE_FLAGS_I 0\n#define STATE_POS_I   1\n#define STATE_ROT_I   2\n#define STATE_VEL_I   3\n#define STATE_MOUSE_I 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 kres = 1.0 / iResolution.xy;\n    vec2 uvi = fragCoord;\n    vec2 uv = uvi * kres;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if (uvi.y < 1.0 && uvi.x < STATE_LENGTH) {\n        vec4 state[] = vec4[] (\n            texture(iChannel0, vec2(0.5, 0.5) * kres),\n            texture(iChannel0, vec2(1.5, 0.5) * kres),\n            texture(iChannel0, vec2(2.5, 0.5) * kres),\n            texture(iChannel0, vec2(3.5, 0.5) * kres),\n            texture(iChannel0, vec2(4.5, 0.5) * kres)\n        );\n        \n        vec4 flags = state[STATE_FLAGS_I];\n        \n        // Catch initial load and set default values\n        if (flags.x != 1.0) {\n            flags.x = 1.0;\n            state[STATE_POS_I] = vec4(-2.0, 5.0, 12.0, 0.0);\n            state[STATE_ROT_I] = qmul(\n                quatFromAxisAngle(UP, 170.0 * DEG_TO_RAD),\n                quatFromAxisAngle(RIGHT, 20.0 * DEG_TO_RAD)\n            );\n        }\n        \n        // Controls\n        vec4 kbW = texture(iChannel1, vec2(87.0/256.0, 0.0));\n        vec4 kbA = texture(iChannel1, vec2(65.0/256.0, 0.0));\n        vec4 kbS = texture(iChannel1, vec2(83.0/256.0, 0.0));\n        vec4 kbD = texture(iChannel1, vec2(68.0/256.0, 0.0));\n        vec4 kbR = texture(iChannel1, vec2(82.0/256.0, 0.0));\n        vec4 kbF = texture(iChannel1, vec2(70.0/256.0, 0.0));\n        vec4 kbQ = texture(iChannel1, vec2(81.0/256.0, 0.0));\n        vec4 kbE = texture(iChannel1, vec2(69.0/256.0, 0.0));\n        \n        vec4 prevMouse = state[STATE_MOUSE_I];\n        state[STATE_MOUSE_I] = iMouse;\n        if (prevMouse.z != iMouse.z)\n            prevMouse = iMouse;\n        vec4 dMouse = iMouse - prevMouse;\n        \n        vec2 sensitivity = vec2(1.5, 2.0);\n        \n        // Rotation\n        float roll = (kbQ.x - kbE.x) * 0.02;\n        vec2 mouse_norm = dMouse.xy * kres * sensitivity;\n        vec3 angles = vec3(-mouse_norm.y, mouse_norm.x, roll);\n        \n        vec4 rot = state[STATE_ROT_I];\n        rot = qmul(rot, quatFromAxisAngle(FWD, angles.z));\n        rot = qmul(rot, quatFromAxisAngle(UP, angles.y));\n        rot = qmul(rot, quatFromAxisAngle(RIGHT, angles.x));\n        \n        state[STATE_ROT_I] = normalize(rot);\n        \n        // Translation\n        vec4 velocity = state[STATE_VEL_I];\n        \n        vec4 accel = vec4(kbD.x - kbA.x, kbR.x - kbF.x, kbW.x - kbS.x, 0.0);\n        accel *= 0.0125;\n        accel = qmulv(rot, accel);\n        \n        velocity += accel;\n        velocity *= 0.875;\n        if (dot(velocity, velocity) < 0.00001)\n            velocity.xyz = ZERO3;\n        \n        state[STATE_VEL_I] = velocity;\n        state[STATE_POS_I] += velocity;\n        \n        // Moving flag\n        if (dot(dMouse,dMouse) > 0.0 || dot(velocity,velocity) > 0.0 || dot(angles,angles) > 0.0)\n            flags.y = 1.0;\n        else\n            flags.y = 0.0;\n        \n        state[STATE_FLAGS_I] = flags;\n        \n        // Write\n        color = state[int(uvi.x - 0.5)];\n    }\n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 emission;\n    float roughness;\n    float metallic;\n    float ior;\n};\n\n#define mtlBasic(col, r)         Material(col, ZERO3, r, 1.0-r, 1.5)\n#define mtlBasic2(col, r, m)     Material(col, ZERO3, r, m, 1.5)\n#define mtlBasic3(col, r, m, ir) Material(col, ZERO3, r, m, ir)\n#define mtlEmissive(emission)    Material(ZERO3, emission, 1.0, 0.0, 1.0)\n\nconst Material BLACK      = mtlBasic2(vec3(0.125).xxx, 0.125, 0.625);\nconst Material WHITE      = mtlBasic2(vec3(0.875).xxx, 0.375, 0.625);\nconst Material BACKGROUND = mtlBasic2(ZERO3, 0.0, 0.0);\nconst Material ATMOSPHERE = mtlEmissive(vec3(0.5,0.75,1.0) * 1.5);\nconst Material SUN        = mtlEmissive(vec3(1.0,0.75,0.5) * 4.0);\n\nstruct AABB {\n    vec3 p0;\n    vec3 p1;\n    Material material;\n};\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nstruct Contact {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\nconst Contact NO_CONTACT = Contact(false, ZERO3, ZERO3, BACKGROUND);\n\nstruct Sample {\n    vec3 light;\n    Contact contact;\n};\n\nContact rayAABBContact(Ray ray, AABB aabb) {\n    vec3 O = ray.pos;\n    vec3 D = ray.dir;\n    \n    vec3 minB = aabb.p0;\n    vec3 maxB = aabb.p1;\n    vec3 maxT = vec3(-1.0).xxx;\n    vec3 coord = ZERO3;\n    vec3 norm = ZERO3;\n    bvec3 inside = bvec3(true, true, true);\n    \n    if (O.x < minB.x) { coord.x = minB.x; norm.x = -1.0; inside.x = false; }\n    if (O.x > maxB.x) { coord.x = maxB.x; norm.x = 1.0; inside.x = false; }\n    if (O.y < minB.y) { coord.y = minB.y; norm.y = -1.0; inside.y = false; }\n    if (O.y > maxB.y) { coord.y = maxB.y; norm.y = 1.0; inside.y = false; }\n    if (O.z < minB.z) { coord.z = minB.z; norm.z = -1.0; inside.z = false; }\n    if (O.z > maxB.z) { coord.z = maxB.z; norm.z = 1.0; inside.z = false; }\n    \n    if (inside.x && inside.y && inside.z)\n        return NO_CONTACT;\n    \n    if (!inside.x && D.x != 0.0) maxT.x = (coord.x - O.x) / D.x; else maxT.x = -1.0;\n    if (!inside.y && D.y != 0.0) maxT.y = (coord.y - O.y) / D.y; else maxT.y = -1.0;\n    if (!inside.z && D.z != 0.0) maxT.z = (coord.z - O.z) / D.z; else maxT.z = -1.0;\n    \n    int tBestAxis = 0;\n    float tBest = -1.0;\n    \n    if (maxT.x > tBest) { tBestAxis = 0; tBest = maxT.x; }\n    if (maxT.y > tBest) { tBestAxis = 1; tBest = maxT.y; }\n    if (maxT.z > tBest) { tBestAxis = 2; tBest = maxT.z; }\n    \n    if (tBest < 0.0)\n        return NO_CONTACT;\n    \n    if (tBestAxis != 0) {\n        norm.x = 0.0;\n        coord.x = O.x + tBest * D.x;\n        if (coord.x < minB.x || coord.x > maxB.x)\n            return NO_CONTACT;\n    }\n    if (tBestAxis != 1) {\n        norm.y = 0.0;\n        coord.y = O.y + tBest * D.y;\n        if (coord.y < minB.y || coord.y > maxB.y)\n            return NO_CONTACT;\n    }\n    if (tBestAxis != 2) {\n        norm.z = 0.0;\n        coord.z = O.z + tBest * D.z;\n        if (coord.z < minB.z || coord.z > maxB.z)\n            return NO_CONTACT;\n    }\n    \n    return Contact(true, coord, norm, aabb.material);\n}\n\nContact raySphereContact(Ray ray, Sphere sphere) {\n    vec3 O = ray.pos;\n    vec3 D = ray.dir;\n    vec3 C = sphere.position;\n    float r = sphere.radius;\n    float r2 = r*r;\n    vec3 L = C - O;\n    \n    float tca = dot(L, D);\n    //if (tca < 0.0) return NO_CONTACT;\n    \n    float d2 = dot(L, L) - tca*tca;\n    if (d2 > r2) return NO_CONTACT;\n    \n    float thc = sqrt(r2 - d2);\n    float t0 = min(tca - thc, tca + thc);\n    if (t0 < 0.0) return NO_CONTACT;\n    \n    vec3 P = O + t0 * D;\n    \n    return Contact(true, P, normalize(P - C), sphere.material);\n}\n\nContact rayFloorContact(Ray ray) {\n    vec3 O = ray.pos;\n    vec3 D = ray.dir;\n    if (D.y < 0.0 && O.y > 0.0) {\n        float y = O.y;\n        float aspect = y / D.y;\n        float h = -1.0 * aspect;\n        vec3 P = O + D * h;\n\n        Material mat = BLACK;\n        bool bx = fract(P.x * 0.5) < 0.5;\n        bool bz = fract(P.z * 0.5) < 0.5;\n        if (bx ^^ bz) mat = WHITE;\n        \n        return Contact(true, P, UP, mat);\n    }\n    return NO_CONTACT;\n}\n\nfloat genSeed(float x, vec3 c) { return x + fract(sin(dot(c,c))) + fract(sin(iTime/100.0)); }\n\nconst int MAX_DEPTH = 6;\n\nconst float _m = 0.0;\nconst float _M = 1.0;\nconst float _r = 0.125;\nconst vec3 _c = vec3(1.0, 0.75, 0.25);\nconst float _kR = 0.1;\nconst float _kM = 0.5;\nconst float _ior = 1.5;\n\nconst int NUM_AABBS = 4;\nconst int NUM_SPHERES = 10;\n\nconst vec3 ext = vec3(4.0, 6.0, 5.0);\nconst float thk = 0.5;\nconst float raise = 0.0;\n// top, back, front, left, right\nconst AABB aabbs[] = AABB[](\n    AABB(vec3(-ext.x-thk, ext.y+raise, -ext.z), vec3(ext.x+thk, ext.y+thk+raise, ext.z     ), mtlBasic(vec3(1.0, 1.0, 1.0), 1.0)),\n    AABB(vec3(-ext.x    , 0.0        , -ext.z), vec3(ext.x    , ext.y          , -ext.z+thk), mtlBasic(vec3(1.0, 1.0, 1.0), 1.0)),\n    //AABB(vec3(-ext.x    , 0.0     , ext.z-thk), vec3(ext.x    , ext.y          , ext.z     ), mtlBasic(vec3(1.0, 1.0, 1.0), 1.0)),\n    AABB(vec3(-ext.x-thk, 0.0        , -ext.z), vec3(-ext.x   , ext.y          , ext.z     ), mtlBasic(vec3(1.0, 0.25, 0.25), 1.0)),\n    AABB(vec3(ext.x     , 0.0        , -ext.z), vec3(ext.x+thk, ext.y          , ext.z     ), mtlBasic(vec3(0.25, 0.25, 1.0), 1.0))\n);\nconst Sphere spheres[] = Sphere[](\n    Sphere(vec3(0.0, 4.0, 0.0), 1.0, Material(ZERO3, SUN.emission, 1.0, 0.0, 1.5)),\n    Sphere(vec3(-2.5, 1.0, -2.5), 1.0, mtlBasic3(_c, _m, _m, _ior)),\n    Sphere(vec3(0.0,  1.0, -2.5), 1.0, mtlBasic3(_c, _m, 0.5, _ior)),\n    Sphere(vec3(2.5,  1.0, -2.5), 1.0, mtlBasic3(_c, _m, _M, _ior)),\n    Sphere(vec3(-2.5, 1.0, 0.0), 1.0, mtlBasic3(_c, 0.5, _m, _ior)),\n    Sphere(vec3(0.0,  1.0, 0.0), 1.0, mtlBasic3(_c, 0.5, 0.5, _ior)),\n    Sphere(vec3(2.5,  1.0, 0.0), 1.0, mtlBasic3(_c, 0.5, _M, _ior)),\n    Sphere(vec3(-2.5, 1.0, 2.5), 1.0, mtlBasic3(_c, _M, _m, _ior)),\n    Sphere(vec3(0.0,  1.0, 2.5), 1.0, mtlBasic3(_c, _M, 0.5, _ior)),\n    Sphere(vec3(2.5,  1.0, 2.5), 1.0, mtlBasic3(_c, _M, _M, _ior))\n);\n\nContact sampleRayOnce(Ray ray) {\n    Contact best = NO_CONTACT;\n    float bestDist = 0.0;\n    \n    for (int i=0; i<NUM_AABBS; ++i) {\n        AABB aabb = aabbs[i];\n        Contact contact = rayAABBContact(ray, aabb);\n        if (contact.hit) {\n            float d = distance(ray.pos, contact.position);\n            if (!best.hit || d < bestDist) {\n                best = contact;\n                bestDist = d;\n            }\n        }\n    }\n    \n    for (int i=0; i<NUM_SPHERES; ++i) {\n        Sphere sphere = spheres[i];\n        Contact contact = raySphereContact(ray, sphere);\n        if (contact.hit) {\n            float d = distance(ray.pos, contact.position);\n            if (!best.hit || d < bestDist) {\n                best = contact;\n                bestDist = d;\n            }\n        }\n    }\n\n    Contact floorContact = rayFloorContact(ray);\n    if (floorContact.hit) {\n        Contact contact = floorContact;\n        float d = distance(ray.pos, contact.position);\n        if (!best.hit || d < bestDist) {\n            best = contact;\n            bestDist = d;\n        }\n    }\n    \n    if (!best.hit) {\n        if (true) {\n            vec3 SUN_DIR = normalize(vec3(1.0, 1.0, 1.0));\n            vec3 emit = ATMOSPHERE.emission * lerp(0.5, 1.0, pow(1.0 - ray.dir.y, 2.0));\n            emit += SUN.emission * pow(clamp(dot(ray.dir, SUN_DIR), 0.0, 1.0), 256.0);\n            best.material.emission = emit;\n        }\n        else {\n            best.material.emission = texture(iChannel1, ray.dir).xyz;\n        }\n        \n        best.material.emission = pow(best.material.emission, vec3(1.0)) * 1.0;\n    }\n    \n    return best;\n}\n\nfloat fresnelApprox(float ior, vec3 incident, vec3 normal) {\n    float F0 = abs((1.0 - ior) / (1.0 + ior));\n    F0 *= F0;\n\n    float dp = clamp(-dot(incident, normal), 0.0, 1.0);\n    float kFresnel = pow(1.0 - dp, 5.0);\n    float fresnel = F0 + (1.0 - F0) * kFresnel;\n    return fresnel;\n}\n\nSample sampleRay(Ray ray, vec3 seed) {\n    Contact firstContact = NO_CONTACT;\n    vec3 light = ZERO3;\n    vec3 absorbtion = ONE3;\n    float absorbtionf = 1.0;\n    \n    for (int depth=0; depth<MAX_DEPTH; ++depth) {\n        Contact contact = sampleRayOnce(ray);\n        Material mtl = contact.material;\n        \n        if (depth == 0) firstContact = contact;\n        \n        if (contact.hit) {\n            float fresnel = fresnelApprox(mtl.ior, ray.dir, contact.normal);\n            float kAbsorb = (1.0 - fresnel) * (1.0 - mtl.metallic);\n            float kReflect = 1.0 - kAbsorb;\n            \n            float roughness = mtl.roughness;\n            roughness *= roughness * (1.0 - fresnel);\n            \n            float s = genSeed(1.0 + float(depth), seed+ray.pos+ray.dir);\n            vec3 idealRef = reflect(ray.dir, contact.normal);\n            vec3 ref = gaussReflect(ray.dir, contact.normal, roughness, s);\n            ray = Ray(contact.position, ref);\n            \n            //float amtReflected = clamp(dot(idealRef, ref), 0.0, 1.0);\n            \n            vec3 absorbed = mix(mtl.albedo, ONE3, kReflect);\n            \n            light += mtl.emission * absorbtion;\n            absorbtion *= absorbed;\n        }\n        else {\n            light += mtl.emission * absorbtion;\n            break;\n        }\n    }\n    \n    return Sample(light, firstContact);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 kres = 1.0 / iResolution.xy;\n\n    vec4 state[] = vec4[] (\n        texture(iChannel0, vec2(0.5, 0.5) * kres),\n        texture(iChannel0, vec2(1.5, 0.5) * kres),\n        texture(iChannel0, vec2(2.5, 0.5) * kres),\n        texture(iChannel0, vec2(3.5, 0.5) * kres)\n    );\n    Transform xform = Transform(state[1].xyz, state[2]);\n    mat4 view = matrixFromTransform(xform);\n    float moving = state[0].y;\n    vec3 velocity = state[3].xyz;\n    float speed = dot(velocity, velocity);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 screenPos = vec4(-1.0 + 2.0 * fragCoord * kres, 0.0, 1.0);\n    screenPos.x *= aspectRatio;\n    \n    const float SUPERSAMPLE_STD = 0.0005;\n    \n    vec4 rayPos = view * vec4(ZERO3, 1.0);\n    vec3 rayDir = normalize(vec3(screenPos.xy, 2.0));\n    rayDir = mat3(view) * gauss3(rayDir, SUPERSAMPLE_STD, genSeed(0.0, screenPos.xyz));\n    Ray ray = Ray(rayPos.xyz, rayDir);\n    \n    Sample raySample = sampleRay(ray, screenPos.xyz);\n    Contact contact = raySample.contact;\n    \n    vec4 prevColor = texture(iChannel3, fragCoord * kres);\n    vec3 nextColor = raySample.light;\n    \n    const float exposure = 60000.0;\n    const float kShutter = 1.0 / exposure;\n    \n    const float MIN_W = kShutter;\n    float w = 1.0;\n    \n    if (moving > 0.0) prevColor.w = 1.0;\n    \n    if (prevColor.w > 0.0) {\n        w = 1.0 / (1.0 / prevColor.w + 1.0);\n        \n        //vec3 err = clamp(nextColor - prevColor.xyz, 0.0, 1.0);\n        \n        /*vec3 err = abs(nextColor - prevColor.xyz);\n        err = err*err;\n        err = err*err;\n        float mse = (err.x + err.y + err.z) / 3.0;\n        //float mse = max(max(err.x, err.y), err.z);\n        w += pow(mse, 1.5) * 0.125;*/\n        w = clamp(w, MIN_W, 1.0);\n    }\n    \n    nextColor *= w;\n    nextColor += (1.0 - w) * prevColor.xyz;\n    \n    fragColor = vec4(nextColor, w);\n}","name":"Buffer B","description":"","type":"buffer"}]}