{"ver":"0.1","info":{"id":"tslGDN","date":"1669052824","viewed":165,"name":"Generative-Planet-Desmarkie","username":"desmarkie","description":"Generative Planet with Simplex Noise","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// simple noise via https://www.shadertoy.com/view/Msf3WH\nvec2 hashB( vec2 uv )\n{\n\tuv = vec2( dot( uv, vec2(127.1,311.7) ),\n\t\t\t  dot( uv, vec2(269.5,183.3) ) );\n\n\treturn -1.0 + 2.0 * fract( sin( uv ) * 43758.5453123 );\n}\n\nfloat simplex_noise( in vec2 uv )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( uv + (uv.x+uv.y)*K1 );\n\t\n    vec2 a = uv - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hashB(i+0.0)), dot(b,hashB(i+o)), dot(c,hashB(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nfloat noise_01( vec2 uv, float time )\n{\n\n\tvec2 noiseUV = uv * 3.0;\n\tfloat noiseVal = simplex_noise( vec2( time / 4.0, 0.0 ) + noiseUV ) * 0.5;\n\tnoiseVal += simplex_noise( vec2( time / 2.0, 0.0 ) + noiseUV * 4.0 ) * 0.25;\n\tnoiseVal += simplex_noise( vec2( time / 1.5, 0.0 ) + noiseUV * 8.0 ) * 0.125;\n\tnoiseVal += simplex_noise( vec2( time, 0.0 ) + noiseUV * 16.0 ) * 0.0625;\n\n\treturn 0.5 + noiseVal * 0.5;\n}\n\nvec3 cloudCover( vec2 uv, float time, float distort )\n{\n\n\tvec2 cloudUV = uv;\n\tcloudUV += time * 0.3;\n\tcloudUV.x += cos( distort ) * 0.15;\n\tcloudUV.y += sin( distort ) * 0.15;\n\n\tfloat cloudNoise = simplex_noise( cloudUV * 3.3 );\n\tcloudNoise += 0.5 * simplex_noise( cloudUV * 9.0 );\n\tcloudNoise += 0.25 * simplex_noise( cloudUV * 27.0 );\n\tcloudNoise += 0.125 * simplex_noise( cloudUV * 80.0 );\n\tcloudNoise = 0.5 + cloudNoise * 0.5;\n\tcloudNoise = smoothstep( distort, 1.0, cloudNoise );\n\t\n\treturn vec3( cloudNoise );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    uv *= 2.0;\n\tuv -= 0.5;\n\n\tfloat time = iTime / 6.0;\n\tfloat distFromMiddle = distance( uv, vec2( 0.5 ) );\n\n\t// highlight effect\n\tvec3 fade = vec3( pow( 1.0 - distFromMiddle * 0.6, 7.0 ) ) * 1.75;\n\n\t// globe mask\n\tvec3 globeMask = vec3( 1.0 - step( 0.5, distFromMiddle ) );\n\n\t// atmos\n\tvec3 atmos = vec3( clamp( distFromMiddle * distFromMiddle * 4.0, 0.0, 1.0 ) ) * vec3( 0.8, 0.8, 1.0 ) * 0.3 ;\n\n\tvec3 ozone = mix( vec3( 0.7, 0.7, 1.0 ), vec3( 0.0, 0.0, 1.0 ), vec3( distFromMiddle / 1.5 ) - 0.2 );\n\n\tvec3 vignette = vec3( 0.5 - distFromMiddle / 2.5 ) * 2.0;\n\n\tvec3 ring = vec3( smoothstep( 0.4, 0.5, distFromMiddle ) - smoothstep( 0.5, 0.65, distFromMiddle ) );\n\tring *= vec3( 1.0, 2.0, 5.0 );\n\tvec3 ringOuter = ring * ( 1.0 - globeMask );\n\tvec3 ringInner = ( ring * globeMask ) * 0.5;\n\n\tring = ringInner + ringOuter;\n\n\tuv.x += time;\n\n\t\n\n\tvec2 p = -2.0 + ( fragCoord * iResolution.xy ) * 4.0;//-1.0 + 2.0 * v_texcoord;\n\tfloat r = dot( p, p );\n\t// if( r > 0.8 ) discard;\n\tfloat f = ( 1.0 - sqrt( 1.0 - r ) ) / r;\n\n\tvec2 ruv;\n\truv.x = p.x * f + time;\n\truv.y = p.y * f + time / 4.0;\n\n\tfloat landNoise = noise_01( uv, time * 0.5 );\n\tvec3 color = vec3( landNoise );\n\tvec3 smoothColor = smoothstep( 0.525, 0.675, color );\n\n\t// quick and dirty land colors\n\tvec3 landColor = mix( vec3( 0.01, 0.3, 0.7 ), vec3( 0.3, 0.7, 0.1 ), smoothColor );\n\n\tsmoothColor = smoothstep( 0.7, 1.0, color );\n\tvec3 mountains = mix( vec3( 0.0, 0.0, 0.0 ), vec3( 0.95, 0.95, 1.0 ), smoothColor );\n\n\n\tvec3 cloudColor = cloudCover( ruv, time, landNoise );\n\tvec3 cloudShadow = cloudCover( ruv + 0.02, time, landNoise );\n\n\tlandColor += mountains * 10.0;\n\tlandColor *= landNoise - 0.1;\n\tlandColor *= ( 1.0 - ( cloudShadow * 0.5 ) );\n\tlandColor += cloudColor;\n\tlandColor *= globeMask;\n\n\tlandColor = clamp( landColor, 0.0, 1.0 );\n\n\tlandColor += ring / 2.0;\n\n\t//fragColor = vec4( landColor, 1.0 );\n\tfragColor = vec4( ( landColor * fade ) + ( atmos * ozone * 6.0 ) * 0.6 * vignette, 1.0 );\n}","name":"Image","description":"","type":"image"}]}