{"ver":"0.1","info":{"id":"cttSzH","date":"1685028333","viewed":54,"name":"the nosie have voro,noise2d","username":"macoofi","description":"the nosie have voro,1d,2d","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random_11(float _uv_x){\n    return fract(sin(_uv_x*1600.)*5000.);\n}\n//smooth noise 1d\nfloat smoothNoise_11(float _uv_x){\n    float decimal_fraction = fract(_uv_x);\n    float id = floor(_uv_x);\n    \n    decimal_fraction = decimal_fraction*decimal_fraction*(3.-2.*decimal_fraction);\n   \n    float left  = random_11(id+0.0);\n    float right = random_11(id+1.0);\n    float value = mix(left,right,decimal_fraction);\n\n    return  value;\n}\n//noise 2d\nfloat random_21(vec2 _uv){\n    return fract(sin(_uv.x*1600.+_uv.y*6400.)*8000.);\n}\n\n//smooth noise 2d\nfloat smoothNoise_21(vec2 _uv){\n    vec2 decimal_fraction= fract(_uv);\n    vec2 ID = floor(_uv);\n   \n   \n    decimal_fraction = decimal_fraction*decimal_fraction*(3.-2.*decimal_fraction);\n   \n   \n    float buttom_left = random_21(ID+vec2(0,0));\n    float buttom_right = random_21(ID+vec2(1.,0));\n    float buttom = mix(buttom_left,buttom_right,decimal_fraction.x);\n    \n    float top_left = random_21(ID+vec2(0,1));\n    float top_right = random_21(ID+vec2(1,1));\n    float top = mix(top_left,top_right,decimal_fraction.x);\n\n    return  mix(buttom,top,decimal_fraction.y);\n}\n// voro\nvec2 random_22(vec2 _uv){\n    vec2 random_vec2 = vec2(fract(sin(_uv.x*123.+_uv.y*456.)),fract(cos(_uv.y*789.+_uv.x*1234.)));\n    return random_vec2;\n}\nfloat voro(vec2 _uv){\n    vec2 grad = fract(_uv) - 0.5;\n    vec2 id = floor(_uv);\n    float mindist = 1000000.;\n    \n    for(int i = -1;i<2;i++){\n        for(int j = -1;j<2;j++){\n        \n        \n            vec2 offset = vec2(float(i),float(j));\n            \n            vec2 offset_point = random_22(id+offset);//对应ID随机点的坐标\n            \n            vec2 point_location = offset+sin(offset_point*1234.)*0.5;//和时间结合动起来\n            \n            float f = length(grad-point_location);//计算_uv到顶点的距离\n            \n            if(mindist>f){\n                mindist = f;//取最小值\n            }\n        }\n    }\n    return mindist;\n}\n\nfloat voro_move_time(float _time,vec2 _uv){\n    vec2 grad = fract(_uv) - 0.5;\n    vec2 id = floor(_uv);\n    float mindist = 1000000.;\n    \n    for(int i = -1;i<2;i++){\n        for(int j = -1;j<2;j++){\n        \n        \n            vec2 offset = vec2(float(i),float(j));\n            \n            vec2 offset_point = random_22(id+offset);//对应ID随机点的坐标\n            \n            vec2 point_location = offset+sin(offset_point*_time)*0.5;//和时间结合动起来\n            \n            float f = length(grad-point_location);//计算_uv到顶点的距离\n            \n            if(mindist>f){\n                mindist = f;//取最小值\n            }\n        }\n    }\n    return mindist;\n}\n\n//the API\nfloat FBM_1D_noise(float _uv_x, int octaves,float frequency,float lacunarity,float amplitude,float gain){\n    float value = 0.;\n    float count_amplitude = amplitude;\n    for(int i = 0;i<octaves;i++){\n        value     += amplitude * smoothNoise_11(frequency * _uv_x);\n        amplitude *= gain;\n        frequency *= lacunarity;\n        \n        count_amplitude += amplitude;\n    }\n    value/=count_amplitude;\n    return(value);\n}\n\nfloat FBM_2D_noise(vec2  _uv  , int octaves,float frequency,float lacunarity,float amplitude,float gain){\n    float value = 0.;\n    float count_amplitude = amplitude;\n    for(int i = 0;i<octaves;i++){\n        value     += amplitude * smoothNoise_21(frequency*_uv);\n        amplitude *= gain;\n        frequency *= lacunarity;\n        \n        count_amplitude += amplitude;\n    }\n    value/=count_amplitude;\n    //from scratcha pixel\n    //noiseMap[j * imageWidth + i] = (sin((i + noiseValue * 100) * 2 * M_PI / 200.f) + 1) / 2.f; \n    //marble //value = (sin((_uv.x+v)*20.))/2.+0.5;\n    return(value);\n}\n\nfloat     FBM_voro(vec2  _uv  , int octaves,float frequency,float lacunarity,float amplitude,float gain){\n    float value = 0.;\n    float count_amplitude = amplitude;\n    for(int i = 0;i<octaves;i++){\n        value     += amplitude * voro(frequency*_uv);\n        amplitude *= gain;\n        frequency *= lacunarity;\n        \n        count_amplitude += amplitude;\n    }\n    value/=count_amplitude;\n    return(value);\n}\n\nfloat FBM_voro_time(float _time,vec2  _uv  , int octaves,float frequency,float lacunarity,float amplitude,float gain){\n    float value = 0.;\n    float count_amplitude = amplitude;\n    for(int i = 0;i<octaves;i++){\n        value     += amplitude * voro_move_time(_time,frequency*_uv);\n        amplitude *= gain;\n        frequency *= lacunarity;\n        \n        count_amplitude += amplitude;\n    }\n    value/=count_amplitude;\n    return(value);\n}\n\nfloat FBM_1D_noise_beta(float _uv_x,float seed){\n\n    _uv_x+=seed;\n    \n    float c0;\n    c0  = smoothNoise_11(_uv_x*4.);\n    c0 += smoothNoise_11(_uv_x*8.)*0.5;\n    c0 += smoothNoise_11(_uv_x*16.)*0.25;\n    c0 += smoothNoise_11(_uv_x*32.)*0.125;\n    c0 += smoothNoise_11(_uv_x*64.)*0.0625;\n    \n    \n    c0/=2.;\n    return c0;\n}\n\n\n\n//1d noise\nint   D1_octaves = 5;//层数\nfloat D1_frequency = 4.0;//uv的缩放权重\nfloat D1_lacunarity = 2.0;//uv的缩放权重的增减，越大，uv的图越小\n\nfloat D1_amplitude = 1.0;//衰减权重\nfloat D1_gain = 0.5;//衰减权重的增减，越小，权重越小\n\n//2d nosie \nint   D2_octaves = 5;//层数\nfloat D2_frequency = 1.0;//uv的缩放权重\nfloat D2_lacunarity = 1.5;//uv的缩放权重的增减，越大，uv的图越小\n\nfloat D2_amplitude = 1.0;//衰减权重\nfloat D2_gain = 0.5;//衰减权重的增减，越小，权重越小\n\n//voro noise\nint   voro_octaves = 2;//层数\nfloat voro_frequency = 10.0;//uv的缩放权重\nfloat voro_lacunarity = 1.5;//uv的缩放权重的增减，越大，uv的图越小\n\nfloat voro_amplitude = 1.0;//衰减权重\nfloat voro_gain = 0.5;//衰减权重的增减，越小，权重越小\n\n\nfloat mountain(vec2 uv){\n    //float height = FBM_1D_noise_beta(uv.x,100.0);\n    float height = FBM_1D_noise(uv.x,D1_octaves,D1_frequency,D1_lacunarity,D1_amplitude,D1_gain);\n    float color_h;\n    \n    if(uv.y-0.3<height/2.0){\n        color_h = 0.2;\n    }else{\n        color_h = 0.8;\n    }\n    return color_h;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x = uv.x+iTime*0.5;\n    \n    //vec3 col = vec3(FBM_voro(uv,voro_octaves,voro_frequency,voro_lacunarity,voro_amplitude,voro_gain));\n   //vec3 col = vec3(FBM_2D_noise(uv,D2_octaves,D2_frequency,D2_lacunarity,D2_amplitude,D2_gain));\n    vec3 col =vec3(mountain(uv));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}