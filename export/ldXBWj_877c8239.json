{"ver":"0.1","info":{"id":"ldXBWj","date":"1498071102","viewed":126,"name":"First SDF shader","username":"revillo","description":"First attempt at writing ray marching and basic sdf boolean geometry + rendering. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere_sdf(vec3 center, float radius, vec3 pos) {\n\n \treturn (length(center - pos) - radius);\n}\n\n\nfloat box_sdf(vec3 center, vec3 dimensions, vec3 pos) {\n\n\tvec3 dist = abs(pos - center) - dimensions;\n    return max(max(dist.x, dist.y), dist.z);\n    \n    \n}\n\nfloat union_sdf(float sdf1, float sdf2) {\n\n    return min(sdf1, sdf2);\n\n}\n\nfloat intersect_sdf(float sdf1, float sdf2) {\n\n\treturn max(sdf1, sdf2);\n    \n}\n\nfloat exclude_sdf(float sdf1, float sdf2) {\n\n    return max(sdf1, -sdf2);\n\n}\n\nfloat cone(in vec3 p, in vec3 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -p.y-c.z;\n    float d2 = max(dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2),0.0)) + min(max(d1, d2), 0.0);\n}\n\n\nfloat gem_sdf(in vec3 ray)\n{\n    float heightFactor = 1.5;\n    vec3 coneBase = vec3(0.35, 0.4, 1.64 * heightFactor);\n    vec3 coneBase2 = vec3(0.4, 0.3, 2.5 * heightFactor);\n\n\n    // your magical distance function\n    float cone1 = cone(vec3(ray.x, ray.y - coneBase.z , ray.z), coneBase);\n    float cone2 = cone(vec3(ray.x, -ray.y - coneBase2.z, ray.z), coneBase2);\n    return max(ray.y - coneBase.z * 0.3, min(cone1, cone2));\n\n}\n\n\n\nvec3 repeat_y(vec3 pos) {\n  float y = mod(pos.y, 30.0);\n  return vec3(pos.x, y, pos.z);\t\n}\n\nvec3 repeat_x(vec3 pos) {\n  float x = mod(pos.x + iTime * 35.0, 30.0);\n  return vec3(x, pos.yz);\n}\n\nvec3 repeat_z(vec3 pos) {\n  float z = mod(pos.z - 40.0, 50.0);\n  return vec3(pos.xy, z);\n}\n\n\n\n\n\nfloat sdf(vec3 pos) {\n\n    \n   // pos = repeat_x(pos);\n   // pos = repeat_y(pos);\n   // pos = repeat_z(pos);\n    \n    //return intersect_sdf(sphere_sdf(vec3(15.0,15.0,50.0), 15.0, pos),\n\t//box_sdf(vec3(15.0, 15.0, 50.0), vec3(12.0, 12.0, 2.0), pos));\n    \n    //return exclude_sdf(box_sdf(vec3(15.0, 15.0, 35.0), vec3(12.0, 12.0, 2.0), pos),\n    //                   sphere_sdf(vec3(15.0,15.0,35.0), 10.0, pos));\n\t\n    \n    \n    pos.z -= 5.0;\n    return gem_sdf(pos);\n    //return box_sdf(vec3(0.0, 0.0, 50.0), vec3(2.0, 2.0, 2.0), pos);\n}\nvec3 roundNormal(vec3 n, float tf, float pf) {\n      \n    /*\n    float phi = asin(n.z) / 3.14159 + 0.5;\n\n    float theta = atan(n.y, n.x) / 3.14159 + 0.5;\n\n    theta = ((floor(theta * tf + 0.5) / tf) - 0.5) * 3.14159;\n    phi = ((floor(phi * pf + 0.5) / pf) - 0.5) * 3.14159;\n\n    return vec3(cos(theta) * cos(phi), sin(theta) * cos(phi), sin(phi));*/\n    \n    return floor(n * 5.0) / 5.0;\n}\n\nvec3 normal_sdf(vec3 pos) {\n\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n    \n  const float eps = 0.02;\n\n  return normalize( v1 * sdf( pos + v1*eps ) +\n                    v2 * sdf( pos + v2*eps ) +\n                    v3 * sdf( pos + v3*eps ) +\n                    v4 * sdf( pos + v4*eps ) );\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\t\n    uv *= 2.0;\n    uv -= vec2(iResolution.x / iResolution.y, 1.0);\n    \n    vec3 ray = normalize(vec3(uv, 1.0) - vec3(0.0,0.0,0.6 + sin(iTime * 2.0) * 0.05));\n    \n    vec3 eye = -ray;\n    \n    float minMarch = 0.05 + max(sin(iTime * 10.0) * 0.0, 0.0);\n    float dist = 1.0;\n    const float maxDist = 150.0;\n    \n \n    const int maxSteps = 40;\n    int currentStep = 0;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 pos;\n    \n    \n    float currentDistance;\n    \n    int hit = 0;\n    vec3 hitposition = vec3(0.0, 0.0, 0.0);\n    \n    while(currentStep < maxSteps)\n    {\n        pos = ray * dist;\n        currentDistance = sdf(pos);\n        \n    \tdist += max(0.0, currentDistance);\n        \n        \n        hit += int(currentDistance < 0.01);\n        ++currentStep;\n    }\n    \n  \n    vec3 normal = roundNormal(normal_sdf(pos), 8.0 ,64.0);\n    float diffuse = (dot(normal, normalize(vec3(1.0, 0.2, -1.0))) * 0.5 + 0.5) * (1.0 - dist / maxDist);\n            \n    vec2 specShift = vec2(sin(iTime * 5.0), cos(iTime * 5.0));\n            \n    float specular = pow(max(0.0, dot(reflect(eye, normal), normalize(vec3(specShift, 1.0)))), 2.0) * 0.3;\n    \n    diffuse = diffuse * float(hit > 0);\n    specular = specular * float(hit > 0);\n    \n    fragColor = vec4(vec3(1.0,0.5,0.5) * diffuse + vec3(0.9, 0.9, 0.7) * specular, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}