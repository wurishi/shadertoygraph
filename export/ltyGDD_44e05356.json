{"ver":"0.1","info":{"id":"ltyGDD","date":"1474654507","viewed":181,"name":"Lette.GraphingTest","username":"lette","description":"Baby steps. Smooth graphs with adjustable range/size/ticks. Resolution independent - uses zoom level to determine pixel resolution.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["test","graphs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265;\n\nconst float xMax = 5.;\nconst float xMin = -5.;\nconst float xTick = pi / 4.;\n\nconst float yMax = 3.5;\nconst float yMin = -3.5;\nconst float yTick = .5;\n\nfloat theFunc(float x)\n{\n\tfloat time = iTime / 3.;\n    \n    return\n        0.75 * sin((3. * x + pi / 7. + time * -.5 * pi) / 2. * pi) +\n        2.00 * cos( 2. * x + time * 2. * pi);\n}\n\nconst vec3 white = vec3(1., 1., 1.);\nconst vec3 gray = vec3(.5, .5, .5);\nconst vec3 black = vec3(0., 0., 0.);\nconst vec3 orange = vec3(1.0, 0.39, 0.);\nconst vec3 red = vec3(1., .3, .3);\nconst vec3 blue = vec3(.3, .3, 1.);\n\nconst vec3 background = white;\nconst vec3 axes = orange;\nconst vec3 ticks = black;\nconst vec3 gridLines = gray;\nconst vec3 graph = blue;\n\nvec4 getCoordinateInGraphSystem(vec2 coordinate)\n{\n    vec2 normalizedCoordinate = coordinate / iResolution.xy;\n    vec2 zoom = vec2(xMax - xMin, yMax - yMin);\n    vec2 pan = vec2(xMin, yMin);\n    \n    vec2 c = normalizedCoordinate * zoom + pan;\n    \n    return vec4(c, zoom / iResolution.xy);\n}\n\nvoid drawAxes(inout vec4 color, in vec4 coord)\n{\n    float absX = abs(coord.x);\n    float absY = abs(coord.y);\n    float resX = coord.z;\n    float resY = coord.w;\n    \n    // main x-axis\n    if (absY <= 2. * resY)\n    {\n        color = vec4(axes, 1.);\n    }\n\n    // main y-axis\n    if (absX <= 2. * resX)\n    {\n        color = vec4(axes, 1.);\n    }\n\n    if (absX > xTick / 2. && mod(absX, xTick) <= 1. * resX)\n    {\n        if (absY <= 4. * resY)\n        {\n\t\t    // ticks on x-axis\n\t        color = vec4(ticks, 1.);\n        }\n        else if (mod(absY, 4.0 * resY) < 2.0 * resY)\n        {\n            // x-grid-lines\n            color = vec4(gridLines, 1.);\n        }\n    }\n            \n    if (absY > yTick / 2. && mod(absY, yTick) <= 1. * resY)\n    {\n        if (absX <= 4. * resX)\n        {\n\t\t\t// ticks on y-axis\n        \tcolor = vec4(ticks, 1.);\n        }\n        else if (mod(absX, 4.0 * resX) < 2.0 * resX)\n        {\n        \t// y-grid-lines\n            color = vec4(gridLines, 1.);\n        }\n    }\n}\n\nvoid alphaBlend(inout vec4 color, in vec4 newColor)\n{\n    color = newColor + color * (1. - newColor.a);\n}\n\nvoid drawFunc(inout vec4 color, in vec4 coord, float alpha)\n{\n    float y = theFunc(coord.x);\n    \n    float yNext = theFunc(coord.x + 1. * coord.z);\n    float yPrev = theFunc(coord.x - 1. * coord.z);\n    \n    float dNext = (yNext - y) / 2.;\n    float dPrev = (yPrev - y) / 2.;\n    \n    float lMax = max(max(dNext, dPrev), 0.5 * coord.w);\n    float lMin = min(min(dNext, dPrev), -0.5 * coord.w);\n    \n    if (y + lMin <= coord.y && coord.y < y + lMax)\n    {\n        alphaBlend(color, vec4(graph, alpha));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = vec4(white, 1.);\n    \n    vec4 coord = getCoordinateInGraphSystem(fragCoord);\n    \n    drawAxes(fragColor, coord);\n    \n    // draw main function value\n    drawFunc(fragColor, coord, 1.);\n\n    // draw extra lines next to main line with lower alpha\n    vec4 unitX = vec4(coord.z, 0., 0., 0.);\n    vec4 unitY = vec4(0., coord.w, 0., 0.);\n    \n    drawFunc(fragColor, coord + unitX, .6);\n    drawFunc(fragColor, coord - unitX, .6);\n    drawFunc(fragColor, coord + unitY, .6);\n    drawFunc(fragColor, coord - unitY, .6);\n}","name":"Image","description":"","type":"image"}]}