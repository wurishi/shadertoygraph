{"ver":"0.1","info":{"id":"3tjGDR","date":"1559551586","viewed":718,"name":"Infinite recursive helix","username":"holtsetio","description":"My first shadertoy doodle! Rendering of an infinite recursive helix with raymarching. It still has some glitches, which might be caused by floating point precision.\nThe helix distance function is in the ClosestPointHelix() function.\nSuggestions welcome!","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","spiral","loop","helix","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Parameters \n#define FUZZ 0.99\n#define PHASELENGTH 2.50\n#define RECURSION_LEVEL 6\n#define NUM_STRANDS 3.0\n#define TR_RATIO 0.7\n#define RADIUS_FACTOR 0.38\n#define RIBBONRADIUS 0.032\n\n// comment/uncomment the following defines to toggle effects\n#define FLIPFLOP\n#define GLOWONLY\n\n//The Following don't work for now\n//#define VARIANCE\n//#define WOBBLE\n\n\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define EPSILON 0.0005\n#define KEPLER_MAXITER 2\n#define MAXSTEPS 30\n#define MAXDIST 55.0\n#define PHASE mod(iTime/PHASELENGTH,1.0)\n#define PHASEN floor(iTime/PHASELENGTH)\n\nvec3 glow = vec3(0);\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 buildtransform(vec3 point, float off, vec3 trans, bool isNeg) {\n    vec3 zaxis = normalize(point);\n    vec3 xaxis = normalize(vec3(zaxis.z, 0.0, -zaxis.x));\n    if (!isNeg) {\n        xaxis *= -1.0;\n        //zaxis *= -1.0;\n        //off *= -1.0;\n    }\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat4(xaxis.x, yaxis.x, zaxis.x, 0,\n                xaxis.y, yaxis.y, zaxis.y, 0,\n                xaxis.z, yaxis.z, zaxis.z, 0,\n                dot(xaxis,trans),dot(yaxis,trans),dot(zaxis,trans)+off,1);\n}\n\n   \nfloat solveKeplerHalley(float e,float M) {\n    float E =clamp(M+PI,0.00,PI);\n    int i=0;\n    while(i<KEPLER_MAXITER) {\n        float esinE = e*sin(E);\n        float k0mM = (E-esinE)-M;\n        float k1 = (1.0-e*cos(E));\n        E -= (2.0*k0mM*k1)/(2.0*k1*k1-k0mM*(esinE));\n        i++;\n    }\n    return E;\n}\n\nfloat solveKepler(float e, float M) {\n    //http://www.jgiesen.de/kepler/kepler.html\n    if (e >= 1.0) {\n        return solveKeplerHalley(e,M);\n    }\n    float E = (e < 0.8 ? M : PI);\n    float F = E - e*sin(M)-M;\n    int i = 0;\n    while (i < KEPLER_MAXITER) {\n    \tE -= F/(1.0 - e*cos(E));\n        F = E - e*sin(E) - M;\n        i++;\n    }\n\treturn E;\n}\n\n\nstruct HelixHit {\n\tvec4 p;\n    float strand;\n    float theta;\n};\n\n// Computes the closest point to p on a Helix (R,T) with n strands.\n// The returned struct contains the closest point, the strand and the point Theta on the helix.\nHelixHit ClosestPointHelix(vec4 p, float R, float T, float n_helices) {\n    // Nievergelt 2009\n    // doi: 10.1016/j.nima.2008.10.006\n    \n    //Helix: H(Theta) = [R*cos(Theta), R*sin(Theta), T*Theta]\n    //Point: D = (u, v, w) = [r * cos(delta), r * sin(delta), w]\n    HelixHit res;\n    float delta = atan(p.y, p.x);\n    float r = length(p.yx);\n    float kt = ((p.z/T)-delta)/TWOPI;\n    float inv_n_helices = 1.0/n_helices;\n    float n = floor((fract(kt) + 0.5*inv_n_helices)/inv_n_helices -0.5);\n    float s_offset = -(n+0.5)*inv_n_helices*TWOPI;\n    float dktp = delta + round(kt-(n+0.5)*inv_n_helices) * TWOPI; \n    float M = PI + (p.z/T) + s_offset - dktp;\n    float e = (r*R)/(T*T);\n    float E = solveKepler(e,M);\n    float Theta = E - PI + dktp;\n    res.theta = (Theta-s_offset);\n    res.strand=n;\n    #ifdef WOBBLE\n    \tR*= 1.0+0.2*sin(0.01*iTime/(abs(T))+res.theta*3.0);\n    #endif\n    res.p = vec4(R*cos(Theta), R*sin(Theta), res.theta*T,1.0);\n\n    return res;\n}\n\nfloat getT(float R, float baseRot, float subphase, bool isNeg) {\n\tfloat T = tan(baseRot + pow(subphase,6.0) * (PI*0.5 - baseRot))*R;\n    T *= (isNeg ? -1.0 : 1.0);\n    return T;\n}\n\n\nstruct Result {\n\tfloat dist;\n    vec4 n;\n};\n\nResult HelixRecursive(vec4 pos, float R, float startTR, float Rmult, int iter, float strands) {\n\tHelixHit hit;\n    float baseRot = atan(startTR);\n    float phase = PHASE;\n    \n    mat4 transform = mat4(1.0);\n    \n    R = R/mix(1.0,Rmult,phase);\n    transform[3][0] = pow(phase,1.3)*R;\n    \n    float rot = 0.5*PI;\n    vec2 vrot = vec2(sin(rot),cos(rot));\n    \n    transform[1].y = vrot.y;\n    transform[1].z = -vrot.x;\n    transform[2].yz = vrot.xy;\n    \n    transform = rotationY(PI) * transform;\n    \n    float frac = (1.0/float(iter));\n    float subphase = 1.0 - (1.0-phase)*frac;\n    \n    bool flipflop = false;\n    #ifdef FLIPFLOP\n    \tflipflop = true;\n    #endif\n    \n    bool isNeg = flipflop&&(int(PHASEN)%2==0);\n    for (int i=0; i<iter-1; i++) {\n        float T = getT(R,baseRot,subphase,isNeg);\n\n        subphase -= frac;\n        \n        hit = ClosestPointHelix(transform*pos,R,T,strands);     \n        vec3 lookDir = (vec3(hit.p.y,-hit.p.x,-T));\n        float offset = -(hit.theta/TWOPI)*sqrt((T*T+R*R) * 4.0*PI*PI);\n        #ifdef MOVE\n        \toffset -= (i>0?abs(PHASE*T):0.0);\n        #endif\n       \n        transform = buildtransform(lookDir,offset,-hit.p.xyz,isNeg) * transform;\n            \n        #ifdef VARIANCE\n        Rmult *= 1.0-mod(hit.strand,strands)*(0.6/strands);\n\t\t#endif\n        \n        R *= Rmult;\n        isNeg = flipflop&&!isNeg;\n    }\n    float T = getT(R,baseRot,subphase,isNeg);\n    \n    vec4 p = transform*pos;\n    hit = ClosestPointHelix(p,R*sqrt(phase),T,strands);\n    \n    mat4 inv = inverse(transform);\n    Result res;\n\tres.dist = distance(pos,inv * hit.p)-RIBBONRADIUS;\n    res.n = inv * normalize(p-hit.p);\n\treturn res;\n}\n\nResult ED(vec4 p) {\n    float r1 = 7.0;\n    return HelixRecursive(p,r1,TR_RATIO,RADIUS_FACTOR,RECURSION_LEVEL,NUM_STRANDS);\n}\n\nvec3 getColor(vec4 n) {\n    float c = max(0.0,dot(n, normalize(vec4(3,8,2,0))));\n    float c2 = max(0.0,dot(n, normalize(vec4(3,-8,-1,0))));\n    return vec3(c*0.7+c2*0.3,0,c*0.3+c2*0.7);\n}\n\nvec3 raymarch(vec4 orig, vec4 dir) {\n    float dist = 0.0;\n    float minDist = 1e9;\n    int steps = 0;\n    vec4 pos = orig;\n    Result res;\n    res.dist = 1e9;\n    \n    while (dist < MAXDIST && steps < MAXSTEPS && res.dist >= EPSILON) {\n    \tres = ED(pos);\n        minDist = min(minDist,res.dist);\n        glow += vec3(1) * pow(max(0.0,1.0-5.0*minDist),4.0) * 0.03;\n        \n        \n        dist += FUZZ*res.dist;\n        \n        pos = orig + dist*dir;\n    \tsteps++;\n    }\n    #ifdef GLOWONLY\n    return vec3(1)-glow;\n    #else\n    if (res.dist < EPSILON) {\n     \tfloat shadow = (1.0/float(steps))*10.0;\n        shadow *= 1.0-pow(dist/MAXDIST,5.0);\n            \n        return getColor(res.n)*(shadow);   \n    }\n    return vec3(0,0,0);\n    #endif\n\t//return vec3(1,1,1) * (1.0-pow(float(steps)/float(MAXSTEPS),0.5)) * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =(fragCoord-.5*iResolution.xy)/iResolution.x * PI * 0.5;\n    \n    vec4 raydir = normalize(vec4(sin(uv.x),1.0,-sin(uv.y),0.0));\n\tvec4 rayorig = vec4(20.0,0.0,-0.0,1);\n    \n    vec2 rot = vec2(0.3,0.1)*(iMouse.xy / iResolution.xy - 0.5) * 2.0 * PI;\n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n    \trot = vec2(0,0);\n    rot += vec2(-0.5,1.0)*PI;\n    vec2 sins = sin(rot);\n    vec2 coss = cos(rot);\n    float ry = coss.y*raydir.y+sins.y*raydir.z;\n    raydir =  vec4(coss.x*raydir.x-sins.x*ry, sins.x*raydir.x+coss.x*ry, sins.y*raydir.y-coss.y*raydir.z,0.0);\n    \n    fragColor = vec4(raymarch(rayorig, raydir),1.0);\n}","name":"Image","description":"","type":"image"}]}