{"ver":"0.1","info":{"id":"4X3XWH","date":"1718977884","viewed":179,"name":"hilbert curve 2","username":"shadertoyjiang","description":" [url=https://www.shadertoy.com/view/4XtXz7]hilbert curve:  https://www.shadertoy.com/view/4XtXz7[/url]","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["mouse","hilbertcurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024-6-22\n// -27 chars thanks to FabriceNeyret2\n\n\n\n#define M(x) .x *= mat2(cos( t +vec4(0, 11, 33, 0)));\n\nvoid mainImage(out vec4 O, vec2 U)\n{  \n        vec2 R = iResolution.xy,\n             u = ( U+U - R ) / R.y;\n        if( dot(u,u) > 1. ) return;        \n        \n        \n        #define Z vec3(0,0,1)      \n        \n        vec3 f[] = vec3[]( Z.zxx, Z, -Z.xzx, -Z, Z.zxx, Z, Z.xzx, -Z, Z.xzx ),            \n             o = -8.*Z,\n             r = normalize(vec3(u,2)),\n             x,y,z,w,c,p;\n             \n        float d, h, t=iTime,L,n;        \n        for( int N = 3, i,j,k,e,s ; j++<128 && h<12. ; h += d )\n        {\n            p = o + r * h;\n            c = vec3(-1,2,-3);                   \n            p M(xy) c M(xy) \n            p M(xz) c M(xz)             \n            p M(yz) c M(yz) \n\n            for(k=1,i=s=0 ; i++ < N; )\n            {                   \n                w = sign(p); w.y *= w.x; w.z *= -w.y; \n                e = int( dot( vec3(4,2,1) , w*.5+.5) );                \n                \n                s = s * 8 + (k<0?7-e:e);        \n                                 \n                x = f[e], \n                y = f[e+1], \n                z = cross(x,y);      \n                \n                if( p.z<0. && e>0 ) z = -z;     \n                if( e<2||e==3||e==5 ) w=-x, x=-y, y=w,  k=-k; \n                mat3 m = mat3(x,y,z);                        \n                p += p - 2.*sign(p); \n                p *= m; c *= m;\n            }\n            \n            if( s>0 && s<(1<<N*3)-1 )\n             if( -p.x < p.y ) p = -p.yxz, c = -c.yxz;\n            p.x = max(0., abs(p.x+1.) - 1.);\n            L = length(p);    \n            d = (L-1.) / float(1<<N+1);\n            if( d < .02 )\n            {\n                d = .5 + dot(p/L,c)/ 7.5;\n                O =  ( .8 -.1*d + pow(d,2e2) ) \n                    * exp(-.4*(h+o.z+2.)) \n                    * vec4(1,.5,.7,1);                        \n                break;\n            }                \n        }\n}\n\n\n\n\n\n\n\n\n\n/*\n\n#define M(x) .x *= mat2(cos( t +vec4(0, 11, 33, 0)));\n\nvoid mainImage(out vec4 O, vec2 U)\n{  \n        vec2 R = iResolution.xy,\n             u = ( U+U - R ) / R.y;\n        if( dot(u,u) > 1. ) return;        \n        \n        \n        #define Z vec3(0,0,1)      \n        //const vec3 Z = vec3(0,0,1);\n        vec3 f[] = vec3[]( Z.zxx, Z, -Z.xzx, -Z, Z.zxx, Z, Z.xzx, -Z, Z.xzx ),            \n             o = -8.*Z,\n             r = normalize(vec3(u,2)),\n             x,y,z,w,c,p;\n             \n        float d, h, t=iTime,L,n;        \n        for( int N = 3, i,j,k,e,s ; j++<128 && h<12. ; h += d )\n        {\n            p = o + r * h;\n            c = vec3(-1,2,-3);                   \n            p M(xy) c M(xy) \n            p M(xz) c M(xz)             \n            p M(yz) c M(yz) \n\n            for(k=1,i=s=0 ; i++ < N; )\n            {                   \n                w = sign(p); w.y *= w.x; w.z *= -w.y; \n                e = int( dot( vec3(4,2,1) , w*.5+.5) ); \n                \n                //w = sign(p) * .5 + .5;\n                //int g[]=int[8](3,2,0,1,4,5,7,6);                \n                //e = g[ int(w.x*4. + w.y * 2. + w.z) ];\n                \n                \n                s = s * 8 + (k<0?7-e:e);        //s = s * 8 + e*k+(1-k)/2*7;  \n                \n                /* // No need for arrays\n                #define F(c, e) c = vec3(e>>2,e/2&1,e&1)*2.-1.;c.z*=-c.y;c.y*=c.x;\n                vec3 a,b,v;  F(a,(e-1&7)) F(b,e) F(v,(e+1&7))\n                x = (b-a)*.5; y = (v-b)*.5;\n                if(e==0)x=vec3(1,0,0);  \n                if(e==7)y=vec3(0,1,0);                \n                z=cross(x,y);* /\n                \n                x = f[e], \n                y = f[e+1], \n                z = cross(x,y);      \n                \n                if( p.z<0. && e>0 ) z = -z;     // //( e==3||e==4||e==7 )\n                if( e<2||e==3||e==5 ) w=-x, x=-y, y=w,  k=-k; \n                mat3 m = mat3(x,y,z);                        \n                p += p - 2.*sign(p); \n                p *= m; c *= m;\n            }\n            \n            if( s>0 && s<(1<<N*3)-1 )\n             if( -p.x < p.y ) p = -p.yxz, c = -c.yxz;\n            p.x = max(0., abs(p.x+1.) - 1.);\n            L = length(p);    \n            d = (L-1.) / float(1<<N+1);\n            if( d < .02 )\n            {\n                d = .5 + dot(p/L,c)/ 7.5;\n                O =  ( .8 -.1*d + pow(d,2e2) ) \n                    * exp(-.4*(h+o.z+2.)) \n                    * vec4(1,.5,.7,1);                        \n                break;\n            }                \n        }\n}\n\n\n/*\n// 2024年6月20日 \n// 简版皮亚诺曲线\n\nvoid mainImage(out vec4 O, vec2 U)\n{  \n        vec2 R = iResolution.xy,\n             u = (U+U +.1- R) / R.y;\n        if(length(u)>1.)return;\n        #           define Z  vec3(0,0,1)\n        vec3 f[] = vec3[]( Z.zxx, Z, -Z.xzx, -Z, Z.zxx, Z, Z.xzx, -Z, Z.xzx ), // calc             \n             o = vec3(0,0,-8),\n             r = normalize(vec3(u,2)),\n             x,y,z,w,c,p,n;\n        \n        int N = 3 ,\n            i,j,e;\n                \n        for(float k, d, h, t=iTime,L,n,s; j++<128 && h<22.;h += d)\n        {\n                p = o + r * h;\n                c = vec3(-1,2,-3); // light\n                ///////////////////////////////////////////////////////////////\n                #define M(x) .x*= mat2(cos(t+vec4(0, 11, 33, 0)));                \n                                //t=iTime;\n                p M(xy) c M(xy) //t+=.5;\n                p M(xz) c M(xz) //t*=.7;               \n                p M(yz) c M(yz) \n                \n                for(s=0.,k=1.,i=0;i++<N;)\n                {                   \n                        w=sign(p); w.y*=w.x; w.z*=-w.y;                    // Find the nearest sequence number \"e\" to the coordinate \"p\".\n                        e=int(L=dot(vec3(4,2,1),w*.5+.5));                 // L and e： Current serial number\n                        s= s * 8. + (L-3.5)*k+3.5;                         // s： Real serial number   k=(1 or -1)Eight points in reverse.      \n                        x = f[e], y =f[e+1], z = cross(x,y);\n                      //if(p.z<0.&&e!=0))\n                        if(e==3||e==4||e==7)z=-z;                          // Reverse \"z\" axis\n                        if(e==0||e==1||e==3||e==5)w=-x, x=-y, y=w,   k=-k; // inverse chronological order\n                        mat3 m=mat3(x,y,z);                        \n                        p += p -  2.*sign(p) ; // Pan and zoom the nearest cube to the standard cube.\n                        p *= m;                // Transform orientation to standard square\n                        c *= m;\n                }\n                \n                w=p;\n                n=float(1<<N*3);  \n                if(s!=0. && s!=n-1.) // The serial number \"s\" is now only used to remove the two tails in the entry and exit positions.\n                 if(-p.x<p.y)p=-p.yxz, c=-c.yxz;\n                p.x=max(abs(p.x+1.)-1.,0.);\n                L=length(p);    \n                d=(L-1.)/float(1<<N+1); // (d / 2.) <≈≈> (d = min(d,edge))\n                //////////////////////////////////////////////////////////////\n                if(d<.02)\n                {\n                        //O = O * 0. + .5+.5*dot(n, normalize(c));\n                        //O = O * 0. + .5+.6*dot(p.yz, c.yz/3.7); \n                        //O = O * 0. + .5+.1*dot(p,c); // 6≈sqrt(3.)*length(light) .5/6≈.1\n                        \n                        //p=normalize(p);//,c=normalize(c);\n                        d = .5 + dot(p/L,c)/ 7.5; // 7.5≈length(light)*2.\n                        O = O * 0. + .8-.1*d+pow(d,200.); \n                        O *= exp(-.4*(h+o.z+2.))*vec4(1,.5,.7,1);                        \n                        if(iMouse.x/R.x>.5){\n                                O = O * 0. + .8-.1*d+pow(d,200.); \n                                vec4 clr=vec4(s/n,1.-s/n,4.*s/n*(1.-s/n),1);\n                                O *= exp(-.6*(h+o.z+2.)*clr);\n                                O*=O;\n                        }\n                        \n                        // facula /////////\n                    /*  w-=vec3(-2,2,0);\n                        h = atan(w.y,w.x)/1.57; // 1.57≈PI/2.\n                        s += (h+.5)*k+.5;                        \n                        t=1.;\n                        t=mod(t*n/5.,  n*(5.+1.)/5.);                    \n                        O.xy += .6* exp(-.01*abs(t-s));\n                        O*=O+.2;\n                        //** ///////////////\n                        break;\n                }                \n        }\n}\n*/\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}