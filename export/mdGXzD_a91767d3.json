{"ver":"0.1","info":{"id":"mdGXzD","date":"1680786484","viewed":49,"name":"outline_time","username":"wenyingwang","description":"outline","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SAMPLE 16\n#define PI 3.14159265359\n\nvec4 getColorFromTexture(sampler2D _texture,vec2 uv){\n\tvec4 textureColor = texture(_texture, uv);  \n\tvec4 color=vec4(1,1,1,1);\n\tcolor *= textureColor;\n\treturn color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 o = vec4(1, 1, 1, 1);\n\tvec2 textureSize = vec2(1280.0, 720.0);\n\tfloat radius = 10.0;\n    float unitWidth=1.0/textureSize.x;  //单个像素的宽占uv.x的百分比\n    float unitHeight=1.0/textureSize.y; //单个像素的高占uv.y的百分比\n    float width=radius*unitWidth;   //radius为边缘高光的半径\n    float height=radius*unitHeight;\n    \n    float angle=0.0;  //角度\n    float maxAlpha=0.0; //透明度，经过下面的循环后，如果透明度为0则说明该像素周围没有颜色，即它不是图像的边缘；反之则是图像的边缘\n    for(int i=0;i<SAMPLE;i++){\n        angle+=1.0/float(SAMPLE)*2.0*PI;  //角度每个循环增加一次，循环结束时角度为2PI，整好一个圆的角度，圆的精度由SAMPLE决定，SAMPLE越高圆越精细，但运算量也会增加\n        vec2 testPoint_uv=vec2(width*cos(angle),height*sin(angle));//该点的圆上该角度的相对UV坐标\n        testPoint_uv=clamp(fragCoord+testPoint_uv,vec2(0,0),vec2(1,1));//加上该点的UV坐标变为绝对UV坐标\n        float tempAlpha=getColorFromTexture(iChannel0,testPoint_uv).a;//用绝对UV坐标从texture读取颜色，看它的透明度\n        maxAlpha=max(maxAlpha,tempAlpha);//把透明度结果保存起来\n    }\n    maxAlpha = abs(sin(iTime))*maxAlpha;\n\n    vec4 finalColor=mix(vec4(0.0),vec4(1.0) ,maxAlpha);//根据检测后的透明度决定该点最终的颜色\n    o=getColorFromTexture(iChannel0,uv);//读取该点本来的颜色\n    o*=vec4(0.5);//乘上顶点颜色，如果想要边缘高光也受node.color的影响，那么也要finalColor*=v_color;\n    \n    \n    //fragColor = texture(iChannel0, uv);\n    fragColor = mix(finalColor,o,o.a);\n}","name":"Image","description":"","type":"image"}]}