{"ver":"0.1","info":{"id":"lXScWh","date":"1731271235","viewed":18,"name":"calcul de cout englobant camion","username":"lindoush","description":"troisieme partie du tp sur les volumes englobants. Camion transportant un objet dont lequel on calcul le cout de l'image du lancer de rayon avec optimisation (avec un objet englobant).  ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.09.15\n// Eric Galin\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Val {\n  float v; // Signed distance\n  int c; // Cost\n};\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t) \n{\n    return ray.o+t*ray.d;\n}\n\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\nRay CreateRay(vec2 m,vec2 p)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n  \n  // Origin\n  vec3 ro=vec3(37.,0.,15.);\n  ro*=Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  vec3 rd=normalize(p.x*u+p.y*v+le*w);\n  return Ray(ro,rd);\n}\n\n// Object transformations ------------------------------------------------------------------\n\n// Translate a point\n// p : the point to translate\n// t : translation vector\nvec3 Translate(vec3 p, vec3 t) {\n    return p - t;\n}\n\n// Scale (Homothety)\n// p : the point to scale\n// s : scaling factor (can be a vector for non-uniform scaling)\nvec3 Scale(vec3 p, vec3 s) {\n    return p / s;\n}\n\n// Rotate around X axis\n// p : the point to rotate\n// a : angle (in radians) to rotate around the X-axis\nvec3 RotateX(vec3 p, float a) {\n    float sa = sin(a); \n    float ca = cos(a);\n    return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n\n// Rotate around Y axis\n// p : the point to rotate\n// a : angle (in radians) to rotate around the Y-axis\nvec3 RotateY(vec3 p, float a) {\n    float sa = sin(a); \n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Rotate around Z axis\n// p : the point to rotate\n// a : angle (in radians) to rotate around the Z-axis\nvec3 RotateZ(vec3 p, float a) {\n    float sa = sin(a); \n    float ca = cos(a);\n    return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n// Transform a point with translation, scaling (homothety), and rotation\n// p : the point to transform\n// t : translation vector\n// s : scaling vector (non-uniform scaling possible)\n// r : rotation angles for X, Y, and Z axes (in radians)\nvec3 Transform(vec3 p, vec3 t, vec3 s, vec3 r) {\n    p = Translate(p, t);\n    p = Scale(p, s);\n    p = RotateX(p, r.x);\n    p = RotateY(p, r.y);\n    p = RotateZ(p, r.z);\n    return p;\n}\n\n// Operators -------------------------------------------------------------------------------\n\n// Union\n// a,b : field function of left and right sub-trees\nVal Union(Val a,Val b) // cout de la somme des deux objets + 1 \n{\n  return Val(min(a.v,b.v),a.c+b.c+1);\n}\n\n// Difference of two signed distance functions\nVal Difference(Val a, Val b) { //cout de la somme des deux objets + 1\n    return Val(max(a.v, -b.v), a.c + b.c + 1); // Subtract b from a\n}\n\n// Intersection of two signed distance functions\nVal Intersection(Val a, Val b) { // cout de la somme des deux objets + 1\n    return Val(max(a.v, b.v), a.c + b.c + 1); // Keep the larger distance\n}\n\n\n// Primitives -------------------------------------------------------------------------------\n\n// Sphere => renvoie la distance signée d'un point à une sphère\n// p : point\n// c : center of skeleton\n// r : radius\nVal Sphere(vec3 p,vec3 c,float r)\n{\n  return Val(length(p-c)-r,1); // => cout à 1 \n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nVal Plane(vec3 p, vec3 n, vec3 o)\n{\n    return Val(dot((p-o),n),1); // => cout à 1 \n}\n\n// Ellipsoid\n// p : point to test\n// c : center of the ellipsoid\n// r : radii along the ellipsoid axes (as a vec3)\nVal Ellipsoid(vec3 p, vec3 c, vec3 r) {\n    return Val(length((p - c) / r) - 1.0, 5); // => cout à 5\n}\n\n// Box\n// p : point to test\n// c : center of the box\n// r : half-extents (size in each direction from the center) of the box\nVal Box(vec3 p, vec3 c, vec3 r) {\n    vec3 d = abs(p - c) - r;\n    return Val(length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0), 3); // => cout à 3 \n}\n\n// Cylinder\n// p : point to test\n// c : center of the base of the cylinder\n// r : radius of the cylinder\n// h : height of the cylinder\nVal Cylinder(vec3 p, vec3 c, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz - c.xz), p.y - c.y)) - vec2(r, h);\n    return Val(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), 7); // => cout à 7 \n}\n\n// Capsule\n// p : point to test\n// a : starting point of the capsule's line segment\n// b : ending point of the capsule's line segment\n// r : radius of the capsule\nVal Capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return Val(length(pa - ba * h) - r, 9); // => cout à 9 \n}\n\n// Torus\n// p : point to test\n// c : center of the torus\n// t : 2D vector representing the major (t.x) and minor (t.y) radii of the torus\nVal Torus(vec3 p, vec3 c, vec2 t) {\n    vec3 q = p - c;\n    return Val(length(vec2(length(q.xz) - t.x, q.y)) - t.y, 11); // => cout à 11\n}\n\n// BoundingBox\n// p : point à tester\n// minCorner : coin minimum de la boîte englobante\n// maxCorner : coin maximum de la boîte englobante\nVal BoundingBox(vec3 p, vec3 minCorner, vec3 maxCorner) {\n    vec3 d = max(minCorner - p, p - maxCorner);\n    float dist = length(max(d, 0.0));\n    return Val(dist, 1); // => cout à 1 \n}\n\n\n// Transformed primitives ------------------------------------------------------------\n\nVal object(vec3 p) {\n    // la boite englobante pour le camion \n    Val boundingBoxTruck = BoundingBox(p, vec3(-12.0, -6.5, -7.0), vec3(7.0, 6.5, 12.0));\n    \n    \n    // si le rayon ne touche pas la boite, on passe \n    if (boundingBoxTruck.v > 0.0) {\n        return boundingBoxTruck;  \n    }\n\n    // si le rayon touche la boite on teste les objets à l interieur \n    vec3 translationDown = vec3(0.0, 0.0, -5.0);  \n    vec3 translatedP = Translate(p, translationDown);\n\n    // coprs du camion \n    Val remorque = Box(translatedP, vec3(-1.5, 0.0, 0.75) * 2.0, vec3(3.0, 1.2, 0.75) * 2.0);\n    Val cabine = Box(translatedP, vec3(2.0, 0.0, 1.0) * 2.0, vec3(1.0, 1.0, 1.0) * 2.0);  \n\n    // roues \n    Val roueAvantGauche = Cylinder(translatedP, vec3(1.5, -1.0, 0.3) * 2.0, 0.5 * 2.0, 0.25 * 2.0);  \n    Val roueAvantDroite = Cylinder(translatedP, vec3(1.5, 1.0, 0.3) * 2.0, 0.5 * 2.0, 0.25 * 2.0);  \n    Val roueArriereGauche = Cylinder(translatedP, vec3(-2.0, -1.0, 0.3) * 2.0, 0.5 * 2.0, 0.25 * 2.0);  \n    Val roueArriereDroite = Cylinder(translatedP, vec3(-2.0, 1.0, 0.3) * 2.0, 0.5 * 2.0, 0.25 * 2.0);  \n\n    // ce qui a en dessus du camion \n    Val spokeRotated90 = Cylinder(RotateZ(translatedP, radians(90.0)), vec3(0.0, -3.0, 10.0), 6.0, 0.5);             \n    Val ring = Torus(translatedP, vec3(-3.5, 0.0, 10.0), vec2(5.5, 0.8));\n\n    // construction du camion complet \n    Val camion = Union(remorque, \n                       Union(cabine, \n                             Union(roueAvantGauche, \n                                   Union(roueAvantDroite, \n                                         Union(roueArriereGauche, \n                                               Union(roueArriereDroite, \n                                                   Union(spokeRotated90, ring)))))));\n\n    return camion;\n}\n\n\n\n// Analysis of the scalar field -----------------------------------------------------------------\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  Val val=object(p);\n  float v=val.v;\n  n.x=object(vec3(p.x+eps,p.y,p.z)).v-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z)).v-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps)).v-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\nbool SphereTrace(Ray ray,float e,out float t,out int s,out int c)\n{\n  bool h=false;\n  \n  // Start at the origin\n  t=0.0;\n  c=0;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=Point(ray,t);\n    Val val=object(p);\n    float v=val.v;\n    c+=val.c;\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return h;\n}\n\n// Lighting -------------------------------------------------------------------------------\n\n// Background color\n// ray : Ray \nvec3 background(Ray ray)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),ray.d.z*.5+.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  float t;\n  int s;\n  int c;\n  bool hit=SphereTrace(Ray(p+Epsilon*n,l),100.,t,s,c);\n  if(!hit)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Shading and lighting\n//   p : Point\n//   n : Normal at point\n// eye : Eye direction\nvec3 Shade(vec3 p,vec3 n,Ray eye)\n{\n  // Point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n  \n  // Ambient color\n  vec3 ambient=.25+.25*background(Ray(p,n));\n  \n  // Shadow computation\n  float shadow=Shadow(p,n,l);\n  \n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n  \n  // Specular\n  vec3 r=reflect(eye.d,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n,int m)\n{\n  float t=float(n)/(float(m));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n\n// Main image function\nvoid mainImage(out vec4 color, in vec2 pxy) {  \n    // Convert pixel coordinates\n    vec2 pixel = (-iResolution.xy + 2.0 * pxy) / iResolution.y;\n\n    // Mouse\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    // Camera\n    Ray ray = CreateRay(m, pixel);\n    \n    // Trace ray\n    float t = 0.0;\n    int s = 0;\n    int c = 0;  // Cost\n    bool hit = SphereTrace(ray, 100.0, t, s, c); // cout calculé ici \n    \n    // Background color\n    vec3 rgb = background(ray);\n    \n    if (hit) {\n        vec3 p = Point(ray, t);\n        vec3 n = ObjectNormal(p);\n        rgb = Shade(p, n, ray);\n    }\n    \n    // Uncomment this line to shade cost\n    rgb=ShadeSteps(c,500);\n\n    \n    color = vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}