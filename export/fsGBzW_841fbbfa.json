{"ver":"0.1","info":{"id":"fsGBzW","date":"1657732359","viewed":193,"name":"pico arieiro sunset flight","username":"Mojomajor","description":"inspired by a sunset at pico arieiro, Madeira\n\nprops to BlockMaster for https://www.shadertoy.com/view/3tXBWj","likes":10,"published":1,"flags":64,"usePreview":1,"tags":["perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtjXRW","filepath":"https://soundcloud.com/mojomajor-zen/sleepy-beach","previewfilepath":"https://soundcloud.com/mojomajor-zen/sleepy-beach","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// A simple 2D landscape created using Perlin noise.\n\n\nfloat random(vec2 _st)\n{\n    return fract(sin(dot(_st.xy,\n                         vec2(0.630, 0.710))) *\n        43759.329);\n}\n\n//柏林噪声\nfloat noise(vec2 _st)\n{\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 6\n\n//布朗分形\nfloat fbm(vec2 _st)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0, 100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n\n    for (int i = 0; i < NUM_OCTAVES; ++i)\n    {\n        v += a * noise(_st);\n        //_st = mul(_st, rot) * 2.0 + shift;\n        _st = _st*rot * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec3 FilterColor(vec3 color1, vec3 color2)\n{\n    //变亮\n    //Y(亮度)=(0.299*R)+(0.587*G)+(0.114*B)\n    //float brightness1 = (0.299 * color1.r) + (0.587 * color1.g) + (0.114 * color1.b);\n    //float breghtness2 = (0.299 * color2.r) + (0.587 * color2.g) + (0.114 * color2.b);\n    //return brightness1 > breghtness2 ? color1 : color2;\n\n    //滤色\n    return 1.0 - (1.0 - color1) * (1.0 - color2);\n}\n\n//USEFUL FUNCTIONS//\n//RNG Returning a Float (0. to 1.)\nfloat randomValue(vec2 uv)\n{\n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//RNG Returning a Vec2 (0. to 1.)\nvec2 randomVector(vec2 uv)\n{\n    vec3 a = fract(uv.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n//RNG Returning a Diagonal Vec2 (4 Directions)\nvec2 randomLimitedVector(vec2 uv)\n{\n    vec2 randomVector = randomVector(uv);\n    return vec2(round(randomVector.x) * 2. - 1.,\n                round(randomVector.y) * 2. - 1.);\n}\n\n//Map\nfloat map(float value, float currentMin, float currentMax, float targetMin, float targetMax)\n{\n    return targetMin + (targetMax - targetMin) * ((value - currentMin) / (currentMax - currentMin));\n}\n\n//Smootherstep\nfloat smootherstep(float value)\n{\n    return 6.0 * pow(value, 5.) - 15. * pow(value, 4.) + 10. * pow(value, 3.);\n}\n\nvec2 lengthdir(vec2 basePoint, float direction, float lngth)\n{\n    return basePoint + vec2(cos(direction) * lngth, sin(direction) * lngth);\n}\n\n//RGB to HSV Converter (Not My Code)\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//DRAW FUNCTIONS//\n//Draw a Line\nvoid drawLine(vec2 uv, vec2 point1, vec2 point2, float thickness, float blur, inout float value)\n{\n    //Get Sides of a Triangle\n    float a = distance(uv, point2);\n    float b = distance(uv, point1);\n    float c = distance(point1, point2);\n    \n    //Calculate Point's Distance from the Line\n    float distanceFromLine = sqrt(abs(pow(a, 2.) - pow((pow(a, 2.) - pow(b, 2.) + pow(c, 2.)) / (2. * c), 2.)));\n    \n\t//Get Pixel's Value\n    float pixelValue = smoothstep(thickness + blur, thickness, distanceFromLine);\n    pixelValue *= smoothstep(thickness + blur, thickness, a + b - c);\n    value = mix(value, 1., pixelValue);\n}\n\n//Draw a Disk\nvoid drawDisk(vec2 uv, vec2 position, float radius, float blur, vec3 colour, inout vec3 value)\n{\n    float pixelValue = smoothstep(radius + blur, radius, distance(position, uv));\n    value = mix(value, colour, pixelValue);\n}\n\n//Draw a Disk with Return Value\nfloat diskValue(vec2 uv, vec2 position, float radius, float blur)\n{\n    return smoothstep(radius + blur, radius, distance(position, uv));\n}\n\n//Perlin Noise\nfloat perlinNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float amplitude = 1.;\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    \n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get Pixel's Position Within the Cell && Cell's Position Within the Grid\n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\n        //Get Gradient Vectors of the Cell's Points\n        vec2 gradientVector1 = randomLimitedVector(cellPosition);\n        vec2 gradientVector2 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y));\n        vec2 gradientVector3 = randomLimitedVector(vec2(cellPosition.x, cellPosition.y + 1.));\n        vec2 gradientVector4 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y + 1.));\n\n        //Calculate Distance Vectors from the Cell's Points to the Pixel\n        vec2 distanceVector1 = vec2(pixelPosition.x, - pixelPosition.y);\n        vec2 distanceVector2 = vec2(- (1. - pixelPosition.x), - pixelPosition.y);\n        vec2 distanceVector3 = vec2(pixelPosition.x, 1. - pixelPosition.y);\n        vec2 distanceVector4 = vec2(- (1. - pixelPosition.x), 1. - pixelPosition.y);\n\n        //Calculate Dot Product of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n\n        //Apply Smootherstep Function on the Pixel Position for Interpolation\n        vec2 pixelPositionSmoothed = vec2(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y));\n\n        //Interpolate Between the Dot Products\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        \n        pixelValue += (interpolation3 * 0.5 + 0.5) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//Draw a Hill\nvoid drawHill(vec2 uv, vec3 colour, float blur, float speed, float flatness, float xOffset, float yOffset, bool drawTrees, inout vec3 value, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float noiseValue = perlinNoise(vec2(uv.x + xOffset + iTime * speed, 0.5), frequency, octaves, lacunarity, persistence) * flatness;\n    float pixelValue = smoothstep(noiseValue, noiseValue - blur, uv.y - yOffset);\n    value = mix(value, colour, pixelValue);\n}\n\n//Draw Fog\nvoid drawFog(vec2 uv, vec2 yBorders, float speed, float density, float contrast, float frequency, int octaves, float lacunarity, float persistence, inout vec3 value)\n{\n    //return;\n    //Get the Noise Value\n    float noiseValue = perlinNoise(vec2(uv.x * 0.8 + iTime * speed, uv.y), frequency, octaves, lacunarity, persistence);\n    float ampl = sin(texture(iChannel0,uv).x)*0.5+0.5;\n    noiseValue*=ampl*sin(iTime)*0.25+1.0;\n    //Create Gradient Masks\n    float densityGradient = smoothstep(yBorders.y + 0.6, yBorders.y, uv.y);\n    float whiteGradient = smoothstep(yBorders.x + 0.3, yBorders.x - 0.2, uv.y) * 0.3 * density;\n    \n    //Adjust the Value\n    noiseValue = smoothstep(0.2, 0.7, noiseValue) * densityGradient * 0.75 * density + whiteGradient;\n    noiseValue = clamp(map(noiseValue, 0., 1., 0. - contrast, 1.1) * densityGradient, 0., 1.);\n    value = mix(value, vec3(noiseValue + 0.2), noiseValue);\n    //value = vec3(noiseValue);\n}\n\n\n//MAIN//\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Remap the fragCoord\n    vec2 uv = fragCoord / iResolution.y;\n    //uv *= mat2(.707, -.707, .707, .707);\n    \n    float shake = sin(iTime)*0.015;\n    uv *= mat2(cos(shake), -sin(shake), sin(shake), cos(shake));\n    // zoomout/in\n    uv*=sin(iTime/3.)*0.5+1.5;\n    //uv *= mat2(cos(iTime)*0.5, -sin(iTime)*0.5, sin(iTime)*0.5, cos(iTime)*0.5);\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    //Set the Colours\n    vec3 skyColour1 = vec3(47./255.,90./255.,163./255.);//hsv2rgb(vec3(216. / 360., 17. / 100., 100. / 100.));\n    vec3 skyColour2 = vec3(254./255.,193./255.,116./255.);//hsv2rgb(vec3(37. / 360., 34. / 100., 92. / 100.));\n    //texture(iChannel0,uv).xyz;\n    vec3 hillColour1 = hsv2rgb(vec3(200. / 360., 16. / 100., 59. / 100.));\n    vec3 hillColour2 = hsv2rgb(vec3(15. / 360., 6. / 100., 30. / 100.));\n    vec3 hillColour3 = hsv2rgb(vec3(194. / 360., 35. / 100., 28. / 100.));\n    \n    vec3 sunColour = vec3(45. / 360., 0. / 100., 100. / 100.);\t//in HSV model\n\n    // enable mouse\n    //float my = (iMouse.y/iResolution.y)*1.0;\n    float my = 0.;\n    vec2 sunPosition = vec2(1.4-my, 0.45+my);\n    \n    //Set the Background Colour\n    vec3 colourValue = mix(skyColour2, skyColour1, uv.y*1.82);\n    \n    \n    \n    \n    //Draw the Sun\n    \n    sunColour.y = diskValue(uv, vec2(sunPosition.x, sunPosition.y - 0.15), 0.2, 0.8) * 0.4;\n    colourValue *= hsv2rgb(sunColour);\n    colourValue += diskValue(uv, vec2(sunPosition.x, sunPosition.y - 0.15), 0.1, 0.8) * 0.3;\n    drawDisk(uv, sunPosition, 0.02, 0.005, vec3(1., 1., 1.), colourValue);\n    \n    bool drawTrees = false;\n    //Draw the Hills && Fog\n    \n    // upper hill flatness\n    float uhFlatness= 0.5;\n    float ampl = sin(texture(iChannel1,uv).x)*0.5+0.5;\n    drawHill(uv, hillColour1, 0.002, 0.1, uhFlatness, 6.8, 0.10, drawTrees, colourValue, 3., 6, 2., 0.5);\n    drawFog(uv, vec2(0.35, 0.282), 0.12, 1., 0., 1.3, 6, 2., 0.5, colourValue);\n    drawHill(uv, hillColour2, 0.0236/2., 0.2, 0.4, 2.0, 0.05, drawTrees, colourValue, 2., 5, 2., 0.5);\n    drawFog(uv, vec2(0.25, 0.236), 0.25, 0.6, 0., 1.4, 6, 2., 0.5, colourValue);\n    drawHill(uv, hillColour3, 0.0786*ampl, 0.5, 0.2, 4.0, - 0.05, drawTrees, colourValue, 0.9, 5, 1.9, 0.45);\n    drawFog(uv, vec2(- 0.3, 0.2), 0.6, 0.4, 0., 1., 5, 2., 0.5, colourValue);\n    \n    // hills are overlapping the sun?\n    // perlinNoise(vec2(uv.x + xOffset + iTime * speed, 0.5), frequency, octaves, lacunarity, persistence) * flatness;\n    float hillNoiseValue = perlinNoise(vec2(sunPosition.x + 6.8 + iTime * 0.1, 0.5), 3., 6, 2., 0.5)*uhFlatness;\n    float sunIntensity = smoothstep(hillNoiseValue - 0.03, hillNoiseValue + 0.03, sunPosition.y - 0.10)*.681;\n    \n    //Draw the Sun Glow\n    \n    sunColour.y = diskValue(uv, sunPosition, 0.2, 0.8) * 0.3 * sunIntensity;\n\tcolourValue *= hsv2rgb(sunColour);\n    colourValue += diskValue(uv, sunPosition, 0.3, 0.8) * 0.1 * sunIntensity;\n    colourValue += diskValue(uv, sunPosition, 0.05, 0.5) * 0.15 * sunIntensity;\n    colourValue += diskValue(uv, sunPosition, 0.01, 0.3) * 0.2 * sunIntensity;\n    colourValue += hsv2rgb(sunColour) * 0.1 * sunIntensity;\n    \n    float highlight = smoothstep(1., 0.7, (colourValue.r + colourValue.g + colourValue.b) / 3.);\n    \n    //Make the Scene Darker\n    colourValue -= ((1. - sunIntensity) * 0.1) * highlight;\n    colourValue -= (1. - diskValue(uv, vec2(0.89, 0.5), 0.4, 1.7)) * 0.3;\n    \n    //Set the fragColor\n    fragColor = vec4(colourValue, 1.);\n    return;\n    vec3 backcolor = colourValue;\n    \n    // 2d clouds\n    uv.y = 1.0 - uv.y;\n    \n    uv.x=abs(uv.x);\n    vec2 st = uv * 1.0f*sin(ampl*ampl);\n    st.x += iTime * 0.1f;\n    st.y -= sin(iTime) * 0.2f;\n    st += st * abs(iTime/300.0);\n    vec3 color;\n\n    vec2 q;\n    q.x = fbm(st + 0.00 * iTime*5.0);\n    q.y = fbm(st + vec2(1.0, 1.0));\n\n    vec2 r;\n    r.x = fbm(st + 1.0 * q + vec2(1.7, 9.2) + 0.15 * sin(iTime)*5.0);\n    r.y = fbm(st + 1.0 * q + vec2(8.3, 2.8) + 0.126 * cos(iTime)*5.0);\n\n    float f = fbm(st + r);\n\n    color = mix(vec3(1.0, 1.0, 1.0),\n                vec3(1.0, 1.0, 1.0),\n                clamp((f * f) * 4.0, 0.0, 1.0));\n\n    color = mix(color,\n                vec3(1.0, 1.0, 1.0),\n                clamp(length(q), 0.0, 1.0));\n\n    color = mix(color,\n                vec3(1.0, 1.0, 1.0),\n                clamp(length(r.x), 0.0, 1.0));\n\n    vec3 cloud = vec3((f * f * f + 0.3 * f * f + 0.5 * f) * color);\n\n    cloud = mix(vec3(0.0f, 0.0f, 0.0f), cloud, uv.y);\n    \n    fragColor = vec4(FilterColor(cloud, backcolor), 1.);\n}\n","name":"Image","description":"","type":"image"}]}