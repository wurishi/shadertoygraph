{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n\nBlack hole with gravitational lensing and accretion disc.\n\nReference: \n  Bozza, Valerio. \"Gravitational lensing by black holes.\" General Relativity and Gravitation 42.9 (2010): 2269-2300.\n\nJun 2014.11.24\n\n*/\n\n// #define MOVE_CAMERA\n#define GRAV_LENSING\n#define PI 3.14159\n\nvec3 bh=vec3(0.0);\nconst float bh_M=1.2; // G=1,c=1\nconst float r_bar=2.7*bh_M;\nconst float disc_r_orig=r_bar * 2.1;\nvec3 disc_n=vec3(0.,1.,0.);\nvec3 disc_s=vec3(1.,0.,0.);\nvec3 eye=vec3(0.,0.4,10.);\nvec3 up=normalize(vec3(0.08,1.,0.));\nmat3 cam_mat;// camera -> world\nconst float tan_half_vfov=1.0;\n\nvec3 rot_x(vec3 v,float theta)\n{\n    float s=sin(theta),c=cos(theta);\n    return vec3(v.x,c*v.y-s*v.z,s*v.y+c*v.z);\n}\nvec3 rot_y(vec3 v,float theta)\n{\n    float s=sin(theta),c=cos(theta);\n    return vec3(c*v.x+s*v.z,v.y,c*v.z-s*v.x);    \n}\nvec3 rot_z(vec3 v,float theta)\n{\n    float s=sin(theta),c=cos(theta);\n    return vec3(c*v.x-s*v.y,s*v.x+c*v.y,v.z);\n}\nvoid setupCamera()\n{\n#ifdef MOVE_CAMERA\n    vec2 rxy=(iMouse.xy / iResolution.xy-0.5) * PI;\n    eye=rot_x(eye,rxy.y); // fixed target(0,0,0)\n    eye=rot_y(eye,-rxy.x);\n    //up=rot_z(up,-rxy.x);\n#endif\n\tvec3 n=normalize(eye-bh);\n\tvec3 s=normalize(cross(up,n));\n\tvec3 t=cross(n,s);\n    cam_mat[0]=s;\n    cam_mat[1]=t;\n    cam_mat[2]=n;\n}\n\nvec4 disc_color(vec3 p_disc, float disc_r)\n{\n    vec3 v=p_disc-bh;\n    float d=length(v);v/=d;\n    if(d<disc_r)\n    {   \n        //return vec4(1.0,0.,0.,1.);\n   \t \tvec2 uv=vec2((atan(dot(v,disc_s),dot(v,cross(disc_s,disc_n)))/(2.*PI)*1.-iTime*0.3),\n                 (d-r_bar)/(disc_r-r_bar));    \n    \treturn 3.*texture(iChannel0,uv)*smoothstep(disc_r,r_bar,d);\n    }\n    else return vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupCamera();\n\tfloat ruv = length((fragCoord.xy-0.5*iResolution.xy)/iResolution.y);\n    vec4 color=vec4(0.7,0.6,0.8,1.) * exp(-ruv*1.1)*1.15;\n    \n    \n \tvec2 iplane_size=2.*tan_half_vfov*vec2(iResolution.x/iResolution.y,1.);\n    vec2 ixy=(fragCoord.xy/iResolution.xy - 0.5)*iplane_size;\n    vec3 ray_dir=cam_mat*normalize(vec3(ixy,-1.));\n    vec3 h2e=eye-bh;\n    float l2_h2e=dot(h2e,h2e);\n    float rm=length(cross(ray_dir,h2e)); // smallest distance\n    float t_cp=sqrt(l2_h2e-rm*rm); // t of closest point\n    \n\tfloat disc_r=disc_r_orig;\n    \n    //if(rm>r_bar)\n    {\n#ifdef GRAV_LENSING\n        float alpha=4.*bh_M/rm;   \n        disc_r=disc_r_orig;\n        if(rm<r_bar) // hack\n            alpha*=(1.-abs(dot(disc_n,up))),disc_r*=1.25;\n#else\n        float alpha=0.;\n#endif\n        float tan_a_2=tan(alpha*0.5);\n        \n        vec3 cp=eye+ray_dir*t_cp;// closest point\n        vec3 coord_origin=cp+ray_dir*(rm*tan_a_2);\n        vec3 x_axis=normalize(bh-coord_origin);\n        vec3 y_axis=normalize(ray_dir+tan_a_2*normalize(bh-cp));\n       \tvec3 z_axis=cross(x_axis,y_axis);\n       \t\n        float c=length(bh-coord_origin);\n        float k=tan_a_2; // a/b\n        \n        // the intersection line pass through bh\n        vec3 iline_r=normalize(cross(z_axis,disc_n));\n        \n        float x1=-1.,x2=-1.,y1,y2;\n\n#ifdef GRAV_LENSING\n\t\tfloat k2=k*k;\n        float b2=c*c/(1.0+k2);\n        float a2=k2*b2;\n        float a=sqrt(a2);\n        // x^2/a2 - y^2/b2 = 1\n\n        float denom=dot(x_axis,iline_r);\n        if(denom==0.)\n        {\n            x1=x2=c;\n            y1=-b2/sqrt(a2);\n            y2=-y1;\n        }\n        else\n        {\n            float slope=dot(y_axis,iline_r)/denom; // y=slope*(x-c)\n            k2=slope*slope; // override k2\n            float A=a2*k2-b2;\n            float B=-2.*a2*k2*c;\n            float C=a2*(k2*c*c+b2);\n            // B*B-4AC>=0\n            float delta=sqrt(B*B-4.*A*C);\n            x1=(-B-delta)/(2.*A);\n\t\t\tx2=(-B+delta)/(2.*A);\n\t\t\ty1=slope*(x1-c);\n            y2=slope*(x2-c);\n        }\n#else\n        float denom=dot(x_axis,iline_r);\n        if(denom!=0.) // else no intersection\n        {\n            float slope=dot(y_axis,iline_r)/denom;\n            x1=0.;y1=-slope*c;\n        }\n#endif\n        \n        vec3 o2e=eye-coord_origin;\n        float yeye=dot(o2e,y_axis);\n        vec3 p1=coord_origin+x1*x_axis+y1*y_axis,\n            p2=coord_origin+x2*x_axis+y2*y_axis;\n        if(x1>=0.&&y1>=yeye && ((y1<0.&&length(p1-bh)>r_bar)||rm>r_bar))\n        {\n           color+=disc_color(p1, disc_r);\n        }\n        if(x2>=0.&&y2>=yeye && ((y2<0.&&length(p2-bh)>r_bar) ||rm>r_bar))\n        {\n           color+=disc_color(p2, disc_r);\n        }\n    }\n    \n    fragColor=color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldjSDc","date":"1416816917","viewed":3543,"name":"Gargantua","username":"jun","description":"My attempt to reproduce the Gargantua black hole appeared in movie Interstellar using ray tracing. Open the MOVE_CAMERA marco to move.\n* weak gravitational lensing + textured disc\n* trace hyperbola against disc","likes":30,"published":1,"flags":0,"usePreview":1,"tags":["raytrace","blackhole","gravitationallensing","gargantua","interstella","accretiondisc","relativity"],"hasliked":0,"parentid":"","parentname":""}}