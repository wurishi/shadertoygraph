{"ver":"0.1","info":{"id":"4lKfWh","date":"1542477159","viewed":89,"name":"smallCloud","username":"Falko","description":"move mouse to rotate camera","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 v;\nvec3 lightSource = vec3(15.0, 0.0, 20.0);\nfloat bLightSource = 0.6;\nfloat ba = 0.4;\n\n\nfloat pi(){\n \treturn radians(180.0);   \n}\n\nfloat random3(vec3 p){\n \treturn textureLod(iChannel1, p/32.0, 0.0).x;   \n}\n\nfloat vNoise(vec3 st) {\n    //simple space-interpolated white noise from texture\n    vec3 i = floor(st);\n    vec3 f = fract(st);\n\n    vec3 u = f;\n\n    float z0 =  mix( mix( random3(i + vec3(0.0,0.0,0.0) ),\n                     random3(i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( random3(i + vec3(0.0,1.0,0.0) ),\n                     random3(i + vec3(1.0,1.0,0.0) ), u.x), u.y);\n    float z1 =  mix( mix(random3(i + vec3(0.0,0.0,1.0) ),\n                     random3(i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( random3(i + vec3(0.0,1.0,1.0) ),\n                     random3(i + vec3(1.0,1.0,1.0) ), u.x), u.y);\n    \n    return mix(z0, z1, u.z);\n    }\n\nvec2 intersectCircle(vec2 cp, vec2 rView){\n    \t\t//calculate p and q from pq-formula\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\nvec2 intersectBall(vec3 cp, vec3 rView){\n    \t\t//calculate p and q from pq-formula\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\nfloat diffuse(vec3 p, vec3 normal){\n            vec3 dirLight = normalize(lightSource-p);\n            return bLightSource*max(0.0, dot(normal, dirLight));\n    }\n\nvec3 chess(vec3 p, vec3 pFrag){\n    //computes the chess pattern with diffuse lightning\n    vec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n \t\n    float tileSize = 4.0;\n    float pixSize = 3.0*2.0*length(v-p)\n        \t\t\t\t\t\t\t/(min(iResolution.x, iResolution.y)\n                                    *length(v-pFrag)\n                                    *tileSize);\n    \n    vec2 ij = floor(p.xy/tileSize);\n   \tvec3 cChess;\n    if(mod(ij.x, 2.0)==mod(ij.y, 2.0)){\n        cChess = cSand;\n    }\n    else{\n     \tcChess = cSandStone;   \n    }\n    \n    vec2 pLocal = abs(fract(p.xy/tileSize)-0.5);\n    float maxLocal = max(pLocal.x, pLocal.y);\n    \n    float bd = diffuse(p, vec3(0.0, 0.0, 1.0));\n    return (ba+bd)*mix(cRock, cChess, smoothstep(0.0, pixSize, 0.49-maxLocal));  \n}\n\nvec3 rostrum(vec3 p, vec3 rView, float radius){\n    //essentially intersect ray with cylinder\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n    float h = 2.0;\n \t\n    vec2 sol = intersectCircle(-p.xy, normalize(rView.xy));\n    \n    vec3 pCylinder = p + rView*\n        \t\t\t\t(sol.x+sqrt(sol.y+pow(radius, 2.0)))\n                         /length(rView.xy);\n    \n    vec3 nCylinder = normalize(vec3(-pCylinder.xy, 0.0));\n    vec3 pPlane = p - (p.z-h) * rView / rView.z;\n    \n    float bd = mix(diffuse(pCylinder, nCylinder),\n             diffuse(pPlane, vec3(0.0, 0.0, 1.0)),\n             smoothstep(h-0.1, h, pCylinder.z));\n    return (ba+bd)*cRock;\n}\n\nvec3 computeBackground(vec3 p, vec3 rView){\n \tvec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cSky = vec3(0.5, 0.76, 0.7);\n    \n    //check if XY-plane is visible\n    if(dot(rView, vec3(0.0, 0.0, 1.0))>-0.01*3.14){\n     \treturn cSky;   \n    }\n    \n    //calculate intersection with XY-plane\n    vec3 pXY = p - p.z * rView / rView.z;\n    float l0 = length(pXY);\n    float l1 = length(p - (p.z-2.0) * rView / rView.z);\n    \n    \n    if(l1>30.0){\n        \n     \treturn cSky;  \n    }\n    else if(l0>25.0){\n        vec3 cRostrum = rostrum(p, rView, 25.0);\n        vec3 mix0 = mix(chess(pXY, p), cRostrum,\n                   smoothstep(25.0, 25.4, l0));  \n     \treturn mix(mix0, cSky,\n                   smoothstep(29.3, 30.0, l1));   \n    }\n    else{\n        return chess(pXY, p); \n     \t\n    }\n}\n\n\n    \n\nmat3 rotationMatrix(const float angle, const vec3 axis){\n \tfloat alpha = radians(angle);\n    float c = cos(alpha);\n    float s = sin(alpha);\n    mat3 R;\n    R[0] = axis * axis.x * (1.0-c) + vec3(c, axis.z*s, -axis.y*s);\n    R[1] = axis * axis.y * (1.0-c) + vec3(-axis.z*s, c, axis.x*s);\n    R[2] = axis * axis.z * (1.0-c) + vec3(axis.y*s, -axis.x*s, c);\n    return R;\n}\n\nvec3 getCameraPosition(vec4 mouse){\n    //computes position of camera from difference between\n    //clicked and current pixel-coordinates\n    vec3 v0 = 20.0*vec3(1.0, 0.0, 1.0);\n    \n    if(iMouse.w<0.){\n        return v0;\n    }\n    else{\n        vec3 v;\n    \tvec2 angle = 200.0*(mouse.xy-mouse.zw);\n        angle.y = min(abs(angle.y), 40.0)*sign(angle.y);\n        \n        vec3 axVert = vec3(0.0, 0.0, 1.0);\n        mat3 rVert = rotationMatrix(angle.x, axVert);\n        v = rVert*v0;\n        \n        vec3 axFlat = normalize(cross(-v, axVert));\n\t\tmat3 rFlat = rotationMatrix(angle.y, axFlat);\n        return rFlat*v;\n    }\n}\n\nfloat density(vec3 p){\n   // density-function of cloud\n   float l = length(p);\n   vec3 pScaled = 0.5*(1.0+p);\n   float n = 0.4*vNoise(4.0*pScaled);\n         n = n+0.3*vNoise(6.0*pScaled);\n         //n = n+0.2*gNoise(18.0*pScaled);\n         //n = n+0.1*gNoise(36.0*p);\n   \n    return 10.0*pow(1.0-l, 1.9)*n;\n   }\n\n\n\nfloat calc_alpha(float sumRho){\n    //calculate opacity given the integral value\n    //of density along ray\n           return 1.0-exp(-sumRho);\n   }\n\nfloat integrate(vec3 p0, vec3 p1, float h){\n           //calculate opacity of cloud along\n    \t   //viewing direction\n    \t   //basically integrate the density \n    \t   //along the connecting line p0-p1,\n    \t   //then calculate alpha as function of value\n           vec3 rView = p1-p0;\n           float l = length(rView);\n           if(l<h){\n                   return 0.0;\n           }\n           else{\n               rView = rView/l;\n               \n               \n               float n = floor(l/h);\n               float hHat = l/n;\n               \n               \n               float tol = 0.12;\n               float sumRho = hHat*0.5*(density(p0)+density(p1));\n               float alpha = calc_alpha(sumRho);\n               \n               float w;\n               float rho;\n               vec3 pStep;\n               float i = 1.0;\n               \n               while(alpha < 1.0-tol && i<n){\n                       \n                       pStep = p0+i*hHat*rView;\n                       \n                       \n                       \n                       rho = density(pStep);\n                       sumRho = sumRho+hHat*rho;\n                       alpha = calc_alpha(sumRho);\n                       i = i+1.0;\n               }\n               \n               return max(0.0, alpha);\n           }\n   }\n\nvec4 computeObject(vec3 p, vec3 rView, float h){\n    //check weather viewing ray intersects\n    //containing sphere, if yes calculate\n    //opacity of cloud\n    vec3 cCloud = vec3(1.0);\n    vec3 center = vec3(0.0, 0.0, 6.0);\n    float radius =  6.0;\n    \n    vec2 sol = intersectBall(center-p, rView);\n    \n    if(pow(radius, 2.0)+sol.y>0.0){\n           \n           float temp = sol.x+sqrt(sol.y+pow(radius, 2.0));\n           vec3 p0 = p+(-sol.y-pow(radius, 2.0)+pow(sol.x, 2.0))*rView/temp;\n           vec3 p1 = p+temp*rView; \t   \n        \n           float alpha = integrate(normalize(p0-center),\n                                   normalize(p1-center),\n                                   h);\n           return vec4(cCloud , alpha);\n     }\n     else{\n           return vec4(0.0);\n     }        \n    \n}\n\nfloat computeShadow(vec3 p, vec3 rView){\n    //compute opacity of cloud along\n    //the line connecting the light source\n    //and the visible background-element\n    vec3 pXY = p - p.z * rView / rView.z;\n    vec3 rLight = normalize(pXY-lightSource);\n    \n    float alpha = computeObject(lightSource, rLight, 0.2).w;\n    return 1.0-0.5*alpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec4 mouse = iMouse/min(iResolution.x, iResolution.y);\n    \n    // set up camera\n    \n    v = getCameraPosition(mouse);\n    vec3 vDir = normalize(-v);\n    vec3 vLeft = normalize(cross(vDir, vec3(0.0, 0.0, 1.0)));\n    vec3 vUp = cross(vLeft, vDir);\n    float dScreen = 2.5;\n    \n    //calculate fragment position in space\n    vec3 pFrag = v + dScreen * vDir + uv.x*vLeft + uv.y * vUp;\n    \n    vec3 rView = normalize(pFrag-v);\n    \n    vec4 colorBall = computeObject(pFrag, rView, 0.1);\n    \n    float shadow = computeShadow(pFrag, rView);\n    vec3 color = shadow*computeBackground(pFrag, rView);\n\n\n    // Output to screen\n    fragColor = vec4(mix(color, colorBall.xyz, colorBall.w),1.0);\n}","name":"Image","description":"","type":"image"}]}