{"ver":"0.1","info":{"id":"lddSW8","date":"1459173973","viewed":678,"name":"Animated Coloured Worley","username":"irealex","description":"Flashing colored Worley noise!\nMade by Alexandra Vicente and Irene Bouzon for our second PGATR assignment.\nComputer Graphics, Virtual Reality and Videogames University Master. URJC.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["worley","cellular","neon","voronoise","cellmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//=================================================================================================\n// Use arrow keys to move your ball and pick the dots, go for a high score!\n// Spacebar resets the game if you lose\n// Have fun and try to reach 20 points! :D\n// \n// Made by Alexandra Vicente and Irene Bouzon for our PGATR second assignment\n// MIGJRV 2015/2016. URJC.\n//\n// Reference shaders (try them!):\n// > https://www.shadertoy.com/view/MddGzf\n// > https://www.shadertoy.com/view/XsdGDX\n//=================================================================================================\n\n#define ANIMATE\n#define SCALE 25.0\n#define MOV_FACTOR 8.0\n#define TEX_SIZE 256.0\n\nvec2 hash2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\nfloat euclideanDist2(vec2 v)\n{\n    return dot(v,v);\n}\n\nvec2 animateCell1(vec2 noise)\n{\n \tnoise = sin(iTime+MOV_FACTOR*noise);\n    return 0.5*noise + 0.5; //NORMALIZE \n}\n\nvec2 cellNoise(vec2 point )\n{\n    float d = 1e30, daux;\n    vec2 v, vaux;\n    vec2 o, offset;\n    vec2 noise;    \n    \n    // 1st Worley pass (Inside cells)\n    vec2 pi = floor(point); // Integer part of the point\n    vec2 pf = fract(point); // Decimal part of the point\n\n    for( int i=-1; i<=1; i++ )\n    {\n        for( int j=-1; j<=1; j++ )\n        {\n            offset = vec2(i,j); \n            noise = hash2( pi + offset ); // noise for the int point+offset\n            #ifdef ANIMATE\n           \t \tnoise = animateCell1(noise); // lets animate the cells!\n            #endif\t\n            vaux = offset + noise - pf;\n            float daux = euclideanDist2(vaux); // Compute square distance from the point to this cell\n\n            if( daux<d )\n            {\n                d = daux; // keep min distance\n                v = vaux; // keep v of the cell with min dist\n                o = offset; // keep offset of the cell with min dist\n            }\n        }\n    }\n\n    // 2nd Worley pass (cell borders) \n    d=1e30;\n    for( int i=-2; i<=2; i++ )\n    {\n        for( int j=-2; j<=2; j++ )\n        {\n            offset = o + vec2(i,j); // Get global offset (Old offset + new (borders) offset)\n            noise = hash2( pi + offset ); // Get the noise for the int point + global offset\n            #ifdef ANIMATE\n            \tnoise = animateCell1(noise); // lets move these cells!\n            #endif\t\n            vaux = offset + noise - pf; \n\t\t\t\n            daux = dot( 0.5*(v+vaux), normalize(vaux-v)); // Compute square distance\n            d = min(d,daux); // Keep the minimun distance\n        }\n    }\n\t// Return the minimun distance and a lineal combination of the noise for coloring purposes\n    // Adding a sin that depends on the time we get the turning on and off effect of the texture\n    return vec2(d*2.0*(0.5*sin(iTime*1.6)+0.9),8.0*noise.x+5.0*noise.y);\n}\n\n// Returns a periodic color for the given value\nvec3 cellColor(float c)\n{\n    float r = 0.5*sin(c*0.7)+0.5;\n    float g = 0.5*cos(c*0.6)+0.5;\n    float b = 0.5*sin(c*c*0.1)+0.5;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xx;\n\t\n    vec2 c = cellNoise( SCALE*p ); // Get float cell noise\n    vec3 col = vec3(c.x,c.x,c.x); // Gray scale cell noise\n\t\n    col = c.x*cellColor(c.y); // Get the cell color\n    // Get the border color\n    col = mix( col, col - vec3(0.5), smoothstep( 0.2, 0.3, c.x ) ); // 1.0-c.x\n    col *= 2.0;    \n\t\n    fragColor = vec4(col,1.0);    \n}","name":"Image","description":"","type":"image"}]}