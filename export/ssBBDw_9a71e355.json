{"ver":"0.1","info":{"id":"ssBBDw","date":"1646390134","viewed":103,"name":"Eat your veg","username":"j0","description":"2D SDF-driven vegetables morphing into each other\n\nMight come back to this later to add leaves/more variations","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["veg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat rand(float n){ return fract(sin(n) * 43758.5453123); }\n\n// 2D SDF functions\nfloat circle (vec2 uv, vec2 centre, float radius) {\n    return length(uv-centre)-radius;\n}\nfloat triangle (vec2 uv, vec2 a, vec2 b, vec2 c) {\n    vec2 ab = b-a;\n    vec2 bc = c-b;\n    vec2 ca = a-c;\n    float dir = sign(ab.x * ca.y - ca.x * ab.y);\n    vec2 a2uv = uv-a;\n    vec2 b2uv = uv-b;\n    vec2 c2uv = uv-c;\n    vec2 dA = a2uv - ab * clamp(dot(a2uv, ab) / dot(ab, ab), 0.0, 1.0);\n    vec2 dB = b2uv - bc * clamp(dot(b2uv, bc) / dot(bc, bc), 0.0, 1.0);\n    vec2 dC = c2uv - ca * clamp(dot(c2uv, ca) / dot(ca, ca), 0.0, 1.0);\n    vec2 distA = vec2(dot(dA, dA), dir * (a2uv.x * ab.y - ab.x * a2uv.y));\n    vec2 distB = vec2(dot(dB, dB), dir * (b2uv.x * bc.y - bc.x * b2uv.y));\n    vec2 distC = vec2(dot(dC, dC), dir * (c2uv.x * ca.y - ca.x * c2uv.y));\n    vec2 result = min(min(distA, distB), distC);\n    return sqrt(result.x) * sign(-result.y);\n}\n\n\nfloat smin (float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n// --- Radish ---\nconst vec3 radishLeftEye = vec3(-0.2, -0.2, 0.12);\nconst vec3 radishRightEye = vec3(0.2, -0.2, 0.12);\nfloat radish (vec2 uv) {\n    return smin(\n        circle(uv, vec2(0.0), 0.5),\n        triangle(uv, vec2(-0.2, -0.3), vec2(0.2, -0.3), vec2(0.0, -0.8)),\n        0.2\n    );\n}\nvec3 radishColour (vec2 uv) {\n    vec3 top = vec3(0.94, 0.36, 0.5);\n    vec3 bottom = vec3(0.9);\n    return mix(top, bottom, clamp(-uv.y * 1.5 - 0.2 + rand(uv.x*uv.y) * 0.2, 0.0, 1.0));\n}\n\n\n// --- Carrot ---\nconst vec3 carrotLeftEye = vec3(-0.05, 0.23, 0.07);\nconst vec3 carrotRightEye = vec3(0.05, 0.22, 0.07);\nfloat carrot (vec2 uv) {\n    return triangle(uv, vec2(-0.2, 0.2), vec2(0.2, 0.2), vec2(0.0, -0.8)) - 0.025;\n}\nvec3 carrotColour (vec2 uv) {\n    vec3 top = vec3(0.8, 0.6, 0.1);\n    vec3 bottom = vec3(1.0, 0.5, 0.0);\n    return mix(top, bottom, clamp(0.2-uv.y + rand(uv.x*uv.y) * 0.5, 0.0, 1.0));\n}\n\n\n\n// ------------\n\nvec3 vegetable (vec3 colour, vec2 uv, float time, float aa) {\n\n    // lerp between shapes and colours\n    float t = sin(time) * 0.5 + 0.5;\n    vec2 offset = vec2(-0.1, 0.05);\n\n    float veg = mix(carrot(uv), radish(uv), t);\n    float shadow = mix(carrot(uv+offset), radish(uv+offset), t);\n    vec3 vegColour = mix(carrotColour(uv), radishColour(uv), t);\n    vec3 leftEye = mix(carrotLeftEye, radishLeftEye, t);\n    vec3 rightEye = mix(carrotRightEye, radishRightEye, t);\n    \n    // eyes\n    float eyes = min(circle(uv, leftEye.xy, leftEye.z), circle(uv, rightEye.xy, rightEye.z));\n    vec2 pupilOffset = vec2(cos(time), sin(time*0.8)) * 0.03;\n    vec2 reflOffset = vec2(-0.015, 0.015);\n    float pupils = min(circle(uv, leftEye.xy+pupilOffset, 0.03), circle(uv, rightEye.xy+pupilOffset, 0.03));\n    float reflection = min(circle(uv, leftEye.xy+pupilOffset+reflOffset, 0.027), circle(uv, rightEye.xy+pupilOffset+reflOffset, 0.027));\n    pupils = max(pupils, -reflection);\n    \n    // layer up the results together\n    colour = mix(colour, colour * vec3(0.85, 0.7, 0.75), smoothstep(0.15+uv.y*0.12, 0.0, shadow));\n    colour = mix(colour, vec3(0.0), smoothstep(aa, 0.0, veg-0.005));\n    colour = mix(colour, vegColour, smoothstep(aa, 0.0, veg));\n    colour = mix(colour, vec3(0.0), smoothstep(aa, 0.0, eyes-0.005));\n    colour = mix(colour, vec3(0.97), smoothstep(aa, 0.0, eyes));\n    colour = mix(colour, vec3(0.1), smoothstep(aa, 0.0, pupils));\n    return colour;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float time = iTime;\n    float aa = 10.0/iResolution.x;\n    \n    // background with stripes\n    vec2 bgUv = mat2x2(sin(5.0), cos(5.0), -cos(5.0), sin(5.0))*uv;\n    vec3 colour = vec3(1.1, 0.96, 0.86) * 0.75;\n    colour *= mix(vec3(1.0), vec3(1.0, 0.8, 0.8), clamp(25.0*(fract(bgUv.x*5.0+time*0.2)-0.95), 0.0, 1.0));\n    colour *= mix(vec3(1.0), vec3(1.0, 0.8, 0.8), clamp(25.0*(fract(bgUv.y*5.0-time*0.2)-0.95), 0.0, 1.0));\n    colour *= mix(vec3(1.0), vec3(1.0, 0.8, 0.8), clamp(25.0*(fract(bgUv.x*5.0+time*0.2+0.1)-0.95), 0.0, 1.0));\n    colour *= mix(vec3(1.0), vec3(1.0, 0.8, 0.8), clamp(25.0*(fract(bgUv.y*5.0-time*0.2+0.1)-0.95), 0.0, 1.0));\n    \n    vec2 mUv = uv + vec2(time*0.15, -time*0.08);\n    colour = vegetable(colour, fract(mUv+vec2(0.33, 0.33))*2.0-1.0, time - floor(mUv.x+0.33), aa);\n    colour = vegetable(colour, fract(mUv+vec2(0.67, 0.67))*2.0-1.0, time - floor(mUv.x+0.67), aa);\n    colour = vegetable(colour, fract(mUv)*2.0-1.0, time - floor(mUv.x), aa);\n    \n    // add some slight noise to give a posterized effect\n    vec3 noise = vec3(rand(uv.x*uv.y)) * 0.05 - 0.025;\n\tfragColor = vec4(colour + noise, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}