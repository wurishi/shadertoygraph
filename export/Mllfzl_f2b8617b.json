{"ver":"0.1","info":{"id":"Mllfzl","date":"1513067635","viewed":2534,"name":"Isopleth","username":"Ultraviolet","description":"Some iso-surfaces and iso-line of a layered noise function computed in a separate buffer (you may replace it with something else).\nClick for view control.\nOther controls:\n - [b]C[/b] cube on/off\n - [b]I[/b] isolines on/off\n - [b]S[/b] shadow on/off","likes":74,"published":1,"flags":48,"usePreview":0,"tags":["isosurface","iso","isoline","datavis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI\t\t\t\t3.1415926535\n#define SQRT2\t\t\t0.707\n\n#define LIGHT_DIR\t\tnormalize(vec3(cos(-iTime*.3+PI*.5), 1.0, sin(-iTime*.3+PI*.5)))\n#define CAM_SPEED\t\t.3\n#define CAM_POS \t\tvec3(4.*cos(-iTime*CAM_SPEED), 4.0, 4.*sin(-iTime*CAM_SPEED))\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_SPACE = 32;\n\n#define KEY_PRESSED(KEY) !(texelFetch( iChannel1, ivec2(KEY,2), 0 ).x>0.5)\n\n\n// strait from https://iquilezles.org/articles/boxfunctions\n// added a parameter for the far intersection normal computation\nvec2 boxIntersection( vec3 ro, vec3 rd, vec3 boxSize, mat4 txx, out vec3 outNormal, out vec3 outNormal2 )\n{\n    // convert from ray to box space\n    vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n    vec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n\n    outNormal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    vec3 d = abs(roo+rdd*tF);\n    outNormal2 = -sign(rdd)*vec3(d.x>d.y&&d.x>d.z?1.:0., d.y>d.x&&d.y>d.z?1.:0., d.z>d.y&&d.z>d.x?1.:0.);\n\n    return vec2( tN, tF );\n}\n\n\nfloat getVal(in vec3 p)\n{\n    vec4 val0 = texture(iChannel0, p.xz*.5+vec2(.5));\n    p.y *= .5;\n    \n    //return p.y;\n    //return length(p*vec3(1.,2.,1.)-vec3(1., 1., -1.));\n    //return min(min(length(p*vec3(1.,2.,1.)-vec3(1., 1., -1.)), length(p*vec3(1.,2.,1.)-vec3(1., 0., 1.))),length(p*vec3(1.,2.,1.)-vec3(-1., 1., 0.)));\n    \n    //return mix(val0.x, val0.z, p.y);\n    \n    \n    //float t = mod(3.*p.y, 1.);\n    //t = smoothstep(0., 1., t);\n    \n    if(p.y<1./3.)\n        //return mix(val0.x, val0.y, p.y*3.);\n        return mix(val0.x, val0.y, smoothstep(0., 0.333, p.y));\n    \n    if(p.y<2./3.)\n        //return mix(val0.y, val0.z, (p.y-1./3.)*3.);\n        return mix(val0.y, val0.z, smoothstep(0.333, 0.666, p.y));\n    \n    //return mix(val0.z, val0.w, (p.y-2./3.)*3.);\n    return mix(val0.z, val0.w, smoothstep(0.666, 1., p.y));\n}\n\n\nvec3 getNorm(in vec3 p)\n{\n    vec2 d = vec2(0.01, 0.);\n    \n    return vec3(getVal(p+d.xyy)-getVal(p), getVal(p+d.yxy)-getVal(p), getVal(p+d.yyx)-getVal(p));\n}\n\n\nfloat marchIso(vec3 ro, vec3 rd, float t_min, float t_max, float iso)\n{\n    float t;\n    float dt = 0.01;\n    \n    \n    vec3 p = ro+rd*(t_min);\n    float inv = getVal(p)>iso?1.0:-1.0;\n    //inv = 1.;\n    \n    for(t = t_min; t<t_max; t += dt)\n    {\n        p = ro+rd*t;\n        float val = getVal(p);\n\n        if((val-iso)*inv < 0.)\n        {\n            break;\n        }\n    }\n    \n    return t;\n}\n\n\nfloat marchMultiIso(vec3 ro, vec3 rd, float t_min, float t_max, float iso_[6], out int kkk)\n{    \n    float val = getVal(ro+rd*(t_min));\n\n    int iso_k[2] = int[](0, 0);\n\n    int kk;\n    for(kk = 0; kk<iso_.length(); ++kk)\n        if(val < iso_[kk])\n            break;\n\n    iso_k[0] = (val<iso_[0]) ? -1: kk-1;\n    iso_k[1] = (val>iso_[iso_.length()-1]) ? -1: kk;\n    \n\n    float t_int = t_max;\n    for(int k = 0; k<2; ++k)\n    {\n        if(iso_k[k] == -1)\n            continue;\n\n        float tt = marchIso(ro, rd, t_min, t_max, iso_[iso_k[k]]);\n\n        if(tt < min(t_int, t_max))\n        {\n            t_int = tt;\n            kkk = iso_k[k];\n        }\n    }\n    \n    return min(t_int, t_max);\n}\n\n\n\nfloat distIsoLine(vec3 p, vec3 n, vec3 grad, float iso, float val)\n{\n\treturn abs(val-iso)/length(grad);\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    \n    float t = (-0.-ro.y)/rd.y;\n    \n    //t = 100.0;\n    \n    \n    if(t<0. || rd.y >0.)\n    \tt = 10000.;\n    \n    vec3 col = mix(vec3(0.9), vec3(0.5,0.6,0.9), 1.-exp(-0.05*t));\n    \n    vec3 n, n2;    \n        \n    vec3 size = vec3(1.);\n    mat4 txx = mat4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0. , -1., 0., 1.);\n    \n    \n    float iso_[6] = float[](0.083, 0.25, 0.416, 0.583, 0.75, 0.916);\n    vec3  color[6]     = vec3[](\n        vec3(1., 0., 0.),\n        vec3(SQRT2, SQRT2, 0.), \n        vec3(0., 1., 0.), \n        vec3(0., SQRT2, SQRT2), \n        vec3(0., 0., 1.), \n        vec3(SQRT2, 0., SQRT2));\n    \n    \n    if(t<100.)\n    {\n        vec3 roo = ro+rd*t;\n        vec3 rdd = LIGHT_DIR;\n\n        vec2 tnf = boxIntersection(roo, rdd, size, txx, n, n2);\n        \n        float t_min = max(0., tnf.x), t_max = tnf.y;\n        float depth = max(0., t_max-t_min);\n\n        // shadow\n        if(depth > 0. && KEY_PRESSED(KEY_S))\n        {\n            int kk;\n            float tt = 0.;\n    \t\tif(KEY_PRESSED(KEY_C))\n            \ttt = marchMultiIso(roo, rdd, t_min, t_max, iso_, kk);\n            if(tt < t_max)\n            {\n            \tcol *= 0.5;\n            }\n        }\n        \n        // ambiant occlusion (extremely cheap)\n        \n        if(KEY_PRESSED(KEY_C))\n        {\n            float val = getVal(roo);\n            vec3 grad = getNorm(roo);\n            grad.y = 0.;\n            float w = 100.;\n            for(int k = 0; k<6; ++k)\n            {\n                w = min(w,abs(val-iso_[k])/length(grad));\n            }\n            w = max(w, max(max(abs(roo.x),abs(roo.z)) - 1., 0.)*100.);\n            w = clamp(w/12., 0., 1.);\n            col *= 0.6+0.4*smoothstep(0., 1.0, w);\n        }\n    }\n    \n    \n    vec2 tnf = boxIntersection(ro, rd, size, txx, n, n2);\n    \n    float t_min = max(0., tnf.x), t_max = min(t, tnf.y);\n    float depth = max(0., t_max-t_min);\n    \n    if(depth > 0.)\n    {\n    \tif(KEY_PRESSED(KEY_C))\n        {\n            int kk;\n            float tt = marchMultiIso(ro, rd, t_min, t_max, iso_, kk);\n            if(tt < t_max)\n            {\n                vec3 cur_col = color[kk];\n                vec3 p = ro + rd*tt;\n                vec3 nn = normalize(getNorm(p));\n\n                if(dot(nn, rd) > 0.)\n                {\n                    cur_col = 0.4+0.6*cur_col;\n                    nn *= -1.;\n                }\n                col = cur_col*(0.5+0.5*max(0.,dot(nn, LIGHT_DIR))) \n                    + vec3(pow(max(0.,dot(LIGHT_DIR, reflect(rd, nn))), 128.));\n                t_max = tt;\n            }\n        }\n        else\n        {\n            vec3 cur_col = vec3(1.0);\n            \n            float val = getVal(ro + rd*tnf.x);\n            for(int kk = 0; kk<6; ++kk)\n                if(val < iso_[kk])\n                {\n                    cur_col = color[kk];\n                    break;\n                }\n            col = cur_col*(0.5+0.5*max(0., dot(n, LIGHT_DIR)));\n            tnf.y = tnf.x + 0.001;\n        }\n    }\n    \n    \n    // isolines\n    float line_width = .2;\n    if(KEY_PRESSED(KEY_I) && depth > 0.001)\n    {\n    \t// front facing\n        vec3 p = ro+rd*(tnf.x+0.01);\n        float val = getVal(p);\n        vec3 grad = getNorm(p);\n        grad -= n*dot(grad,n);\n        for(int k = 0; k<6; ++k)\n        {\n            float w = abs(val-iso_[k])/length(grad);\n            col = mix(col, \n                      color[k]*.1, \n                      mix(1., 0., clamp((w-line_width*tnf.x),0.,1.)));\n        }\n        \n    \t// back facing\n        if(tnf.y<t_max+0.01)\n        {\n            p = ro+rd*(tnf.y-0.01);\n            val = getVal(p);\n            vec3 grad = getNorm(p);\n            grad -= n2*dot(grad,n2);\n            for(int k = 0; k<6; ++k)\n            {\n                float w = abs(val-iso_[k])/length(grad);\n                col = mix(col, color[k]*.1, mix(1., 0., clamp((w-line_width*tnf.y),0.,1.)));\n            }\n        }\n    }\n    \n        // @oneshade suggestion: ground semi-transparent if viewed from below\n    if(ro.y < 0.)\n        col = mix(vec3(0.9), col, 0.5);\n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n        \n    float phi = (iMouse.x-0.5)/iResolution.x * PI * 2.0;\n    float psi = -((iMouse.y-0.5)/iResolution.y-0.5) * PI;\n    \n    \n    vec3 ro = 5.0*vec3(cos(phi)*cos(psi), sin(psi), sin(phi)*cos(psi));\n    if(iMouse.z < 0.5)\n        ro = CAM_POS;\n    vec3 ta = vec3(0., .5, .0);\n    mat3 m = setCamera(ro, ta, 0.0);\n\t\n    float zoom = 2.;\n    //zoom = iMouse.y/iResolution.y * 5.;\n    vec3 rd = m*normalize(vec3(p, zoom));\n    \n    // scene rendering\n    vec3 col = render( ro, rd);\n    \n    // gamma correction\n    col = sqrt(col);\n\n    fragColor = vec4(col, 1.0);\n    \n    //fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n// Cloud parameters\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat noiseMulti( in vec3 pos)\n{\n    vec3 q = pos;\n    float f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n\n    float w = 0.5000+0.25+0.125+0.0625;\n    return f/w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*4.;\n    float speed = 0.5;\n    fragColor = vec4(noise(vec3(uv, iTime*speed)), \n                     noise(vec3(uv + vec2(100.0), iTime*speed)), \n                     noise(vec3(uv + vec2(200.0), iTime*speed)), \n                     noise(vec3(uv + vec2(300.0), iTime*speed)));\n    \n    /*\n    fragColor = vec4(noiseMulti(vec3(uv, iTime*speed)), \n                     noiseMulti(vec3(uv + vec2(100.0), iTime*speed)), \n                     noiseMulti(vec3(uv + vec2(200.0), iTime*speed)), \n                     noiseMulti(vec3(uv + vec2(300.0), iTime*speed)));\n\t//*/\n}","name":"Buffer A","description":"","type":"buffer"}]}