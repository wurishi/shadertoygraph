{"ver":"0.1","info":{"id":"wllcW4","date":"1592136972","viewed":127,"name":"Light experiments","username":"julianlumia","description":"just playing a bit:)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 54\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\n\nfloat displacement(vec3 p, float scale)\n{\n    return sin(scale*p.x)*sin(scale*p.y)*sin(scale*p.z);\n}\n\n\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g5;\n\n\n\nconst float PI = 3.14159265;\n\n\n\nvec3 spherepos;\nvec2 GetDist(vec3 p) {\n vec2 d;\n vec2 e = vec2(p.y +2.5,3);\n vec3 p4 = p;\n float the;\n the = iTime *.2;\n p4.zx *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n     the = iTime *.123;\n\n     p4.yx *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n\n vec2 box11 = vec2((sdOctahedron(p4, 1.3)),5.);\n     vec2 dbox2 = vec2(sdBox( p4,vec3(1.3)),5);\n\n    box11.x = mix (dbox2.x,box11.x,sin(iTime)*0.5+.7);\n\n \n vec2 box10 = vec2((sdBox(p, vec3(.5,1.,0.0))),5.);\n float displacement = sin(1.5*p.x+ iTime*0.5)*sin(1.2*p.y+ iTime)*cos(.5*p.z+ iTime);\n box10.x += displacement;\n spherepos = vec3(-0.0,2.5,-0.);\n float box9 = (sdSphere(p-spherepos, 0.));\n vec2 box;\n vec3 p2 = p;\n the = (iTime*0.2);\n float two = ((dot(sin(p2.zxy+iTime*0.2)*5., cos(p2.zxy*4.+iTime))));\n\n two = ((dot(sin(p2.zxy*2.+0.), cos(p2.zxy*8.+iTime))));\n box10.x = mix(box10.x,two,0.1);\n box10 = vec2(box10.x,3);\nbox10.x *= 0.7;\n g5 +=1./(.15+pow(abs(box11.x),1.));\n\n    box10.x = smin(box10.x,box11.x,.5);\n\nd = condmin(box10,e);\n return  d;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=100.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i < 30; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.001 || (t)>10.) break;\n  t += d * .3;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n float d = .1;\n float shadow = 1.0;\n while(d < maxDist)\n {\n  float t = GetDist(r0 + d * rd).x;\n  if(t < 0.002) return 0.0;\n  d += t;\n  shadow = min(shadow,50.0 * (t / d));\n }\n return shadow;\n}\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(spherepos);\n vec3 l = normalize(lightPos-p);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n float d = RayMarch(p+n*SURF_DIST*1., l).x;\n return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\nvec2 m = iMouse.xy/iResolution.xy;\n\nvec3 eye = 1.0*vec3(0.,1.,5.);\nvec3 col;\nvec2 d;\nvec3 hoek = vec3(0,-0.,-2.);  \nfloat   the = (iTime*.5);\n     eye.zx *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n\nmat3 camera = setCamera( eye, hoek,0.);\nfloat fov = 1.;\nvec3 dir = camera * normalize(vec3(uv, fov));\nvec3 p;\nvec3 n;\nvec3 focalPoint = eye + (dir * 1.);\nvec3 shiftedRayOrigin = eye;\nvec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n d = RayMarch(shiftedRayOrigin, shiftedRay);\nfloat t =d.x *1.;\nvec3  shiftedRayOrigin2 = shiftedRayOrigin;\nvec3  shiftedRay2= shiftedRay;\nif(t<MAX_DIST) {\n shiftedRayOrigin2 += shiftedRay2 * t;\n vec3 sn = GetNormal(shiftedRayOrigin2);\n shiftedRay2 = reflect(shiftedRay2, sn);\n if(d.y==3.) traceRef(shiftedRayOrigin2 +  shiftedRay2*0.1, shiftedRay2);\n p = shiftedRayOrigin + shiftedRay * t;\n n= GetNormal(p.xyz);\n vec3 lp =    spherepos*1.;\n const int numIter = 90;\n vec3 vD = shiftedRay;\n vD = normalize(vD);\n float stepSize = length(p - shiftedRayOrigin) / float(numIter);\n vec3 vO = shiftedRayOrigin + stepSize * vD;\n float accum = 0.0;\n for(int i = 0; i  < numIter; ++i)\n  {\n\tvec3 ld = normalize(lp - vO);\n\tfloat shad = shadow(vO, ld, 5.);\n\tfloat d = dot(vO, vO);\n\taccum += (.00001+abs(sin(iTime)*0.0008-0.001) / d ) * shad;\n\tvO += stepSize * vD;\n   }\n  vec3   color= vec3(1., 1., 1.);\n col +=g5*vec3(0.015)*vec3(1.,1.,1.)*1.;    \n \n col *= marchCount * vec3(1., 1.,1.) * 0.0003;\n float dif = GetLight(p);\n vec3 sky = vec3(1., 1., 1.);\n col *= mix(sky, col, 10./(t*t/1./1.*1.+1.5));   \n\n col *= accum * color *30.;\n }\n col*=10.;\n col=smoothstep(0.0,15.,col);\n col=pow(col, vec3(0.4545));\n fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}