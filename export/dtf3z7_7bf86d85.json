{"ver":"0.1","info":{"id":"dtf3z7","date":"1671497256","viewed":83,"name":"Better R2 Sequence QMC Error","username":"MartyMcFly","description":"Integration error for different operations with my new variant vs canonical R2 sequence. Error x 1000 in log10 plot or white number, red number is amount of samples. Mine is mostly better except for triangle in the high counts sometimes.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["goldenratio","lowdiscrepancy","quasirandom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//see https://www.shadertoy.com/view/mts3zN \n//for details regarding optimized R2 sequence coefficients\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint count = floatBitsToUint(texelFetch(iChannel0, ivec2(fragCoord), 0).x);\n#if INTEGRAL == 0\n    uint shouldbecount = uint(iFrame) / 2u * uint(NUM_SAMPLES_PER_FRAME);\n#else\n    uint shouldbecount = uint(float(iFrame) * 3.14159265359 / 4.0 * float(NUM_SAMPLES_PER_FRAME));\n#endif\n\n    float error = count > shouldbecount ? float(count - shouldbecount) : float(shouldbecount - count); //avoid overflow, I know it's a weird solution bruv\n    error /= float(shouldbecount);    \n  \n    \n    vec2 uv = fragCoord / iResolution.xy; \n    float logaxis = uv.x * 8.0;    \n    vec3 col = vec3(0.0);                   \n    if(logaxis < log2(error)/log2(10.0) + 3.0) //+3.0 -> x1000\n        col = uv.y > 0.5 ? vec3(0.5, 1.0, 0.5) : vec3(0.5);\n    \n    col += smoothstep(2.0, 0.0, fract(logaxis) / abs(dFdx(fract(logaxis))));\n\n    // Output to screen\n    fragColor = vec4(col, 2.0);\n    \n    \n    fragColor.rgb = mix( fragColor.rgb, vec3(1.0, 0.5, 0.5), PrintValue( uv * 80.0 * vec2(1.0, iResolution.y / iResolution.x) - vec2(66.5, 2.0), float(iFrame * NUM_SAMPLES_PER_FRAME), 12.0, 0.0));\n    fragColor.rgb = mix( fragColor.rgb, vec3(1.0, 1.0, 1.0), PrintValue( uv * 80.0 * vec2(1.0, iResolution.y / iResolution.x) - vec2(58.5, 4.0), error, 12.0, 7.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_SAMPLES_PER_FRAME 1000\n#define INTEGRAL 1  //0 = triangle, 1 = quarter circle\n\n\nvec2 r2_canonical(in float idx, in vec2 seed)\n{    \n    return fract(seed + float(idx) * vec2(0.7548776662467, 0.569840290998));\n}\n\nvec2 r2_modified(in float idx, in vec2 seed)\n{\n    return fract(seed + float(idx) * vec2(0.245122333753, 0.430159709002));\n}\n\n\n//this splits the index into blocks of N indices, computes the first index\n//per block immediately and permutes into actual index\n//has the benefit that at no point, intermediate float values are scaled by the original\n//high index value.\nvec2 r2_skippy(in float idx, in vec2 seed)\n{\n     uint w = 4096u;\n     uint i = uint(idx);\n     \n     vec2 phi = vec2(0.245122333753, 0.430159709002); //original phis     \n     vec2 phi_skip_w = fract(seed + float(w) * phi); //using these in place of regular R2 gives every w-th index\n     \n     //computing first index per block (i/w is small), then adding the remaining\n     //in-block index (i%w is again small)\n     return fract(fract(float(i/w) * phi_skip_w + seed) + float(i%w) * phi + seed);\n}\n\n//using unsigned integer overflow instead of fract\n//this stretches the 0.0-1.0 domain into (integer) 0-2^32 -1 range\n//computes everything as integer, then remaps to float after\n//highest precision, requires correct integer math (emulated uint on DX9 ... meh)\nvec2 r2_overflow(in float idx, in vec2 seed)\n{\n    uint max_uint = 0xFFFFFFFFu;\n    uvec2 useed = uvec2(seed * float(max_uint));    \n    uvec2 phi = uvec2(3242174889u, 2447445413u);    \n    return vec2(phi * uint(idx) + useed)/float(max_uint);\n    \n}\n\n\n//I honestly forgot where that's from, please lmk it's awesome\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    \n    return PrintValue( vStringCharCoords, fValue, fMaxDigits, fDecimalPlaces );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint count = floatBitsToUint(texelFetch(iChannel0, ivec2(fragCoord), 0).x);\n    \n    if(iFrame == 0) count = 0u;\n    \n    if(fragCoord.y / iResolution.y < 0.5)\n    {\n        for(int j = 0; j < NUM_SAMPLES_PER_FRAME; j++)\n        {\n            vec2 t = r2_overflow(float(j + NUM_SAMPLES_PER_FRAME * iFrame), vec2(0.5, 0.5));\n#if INTEGRAL == 0\n            count += t.x < t.y ? 1u : 0u;\n#else \n            count += length(t) < 1.0 ? 1u : 0u;\n#endif        \n            \n        }\n    }\n    else \n    {\n        for(int j = 0; j < NUM_SAMPLES_PER_FRAME; j++)\n        {\n            vec2 t = r2_skippy(float(j + NUM_SAMPLES_PER_FRAME * iFrame), vec2(0.5, 0.5));\n#if INTEGRAL == 0\n            count += t.x < t.y ? 1u : 0u;\n#else \n            count += length(t) < 1.0 ? 1u : 0u;\n#endif  \n        }\n    }    \n    \n    \n    fragColor = vec4(uintBitsToFloat(count));\n}","name":"Buffer A","description":"","type":"buffer"}]}