{"ver":"0.1","info":{"id":"XdK3Ww","date":"1454800134","viewed":142,"name":"Quadratics","username":"ur_faec","description":"Phase diagrams of quadratic polynomials z^2 + az + b near the origin. Clicking the mouse adjusts a and b (a is horizontal axis, b is vertical).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","algebra","complexfunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793238462643383;\n\nconst vec2 origin = vec2(0.0, 0.0);\nconst float ViewRadius = 2.0;\n\nconst float GridCoefficientLight = 0.6;\nconst float GridCoefficientDark = 0.6;\n\n\nvec3 hueForPhase(float phase) {\n    vec3 hue = vec3(\n        sin(phase + 0.5 * iTime) + 1.0,\n        sin(2.0*(phase + 0.67*PI) + 0.3 * iTime) + 1.0,\n        sin(2.0*phase + 0.7 * iTime) + 1.0);\n    \n    return hue / sqrt(dot(hue, hue));\n}\n\n// Should be ~1 at the origin, ~0 at any significant distance from it\nfloat decay(float x) {\n\tif (abs(x) >= 0.1) {\n\t\treturn 0.0;\n\t}\n\treturn 1.0 - abs(x*10.0);//pow(abs(x*10.0), 1)\n}\n\n// Offset of x from the integer grid, ignoring integer multiples of n.\nfloat offsetFromGridExcept(int n, float x) {\n\tfloat below = floor(x);\n    float above = ceil(x);\n    if (abs(mod(below, float(n))) < 0.5) {\n        below -= 1.0;\n    }\n    if (abs(mod(above, float(n))) < 0.5) {\n        above += 1.0;\n    }\n\treturn min(x-below, above-x);\n}\n\nfloat offsetFromGrid(float x) {\n\treturn min(x-floor(x), ceil(x)-x);\n}\n\nfloat gridFn(float x) {\n    return offsetFromGrid(x);\n}\n\nvec4 eval(vec2 z, vec2 param) {\n    float a = param.x;\n    float b = param.y;\n    vec2 z2 = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n    return vec4(z2 + a*z + b*vec2(1.0,0.0),\n                2.0*z + a*vec2(1.0, 0.0));\n}\n\n// Scaling weirdness: \"hue\" is expected to be an angle measured in radians,\n// sv are [0, 1].\nvec3 HSVtoRGB(vec3 hsv) {\n    vec3 hue = hueForPhase(hsv.x);\n    return (hsv.y * hue + (1.0 - hsv.y)) * hsv.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uv = 2.0 * ViewRadius * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 param = 2.0 * ViewRadius * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    if (iMouse.xy == vec2(0.0, 0.0)) {\n        param = vec2(0.0, 0.0);\n    }\n\n    \n    vec4 value = eval(uv, param);\t// xy = function, zw = derivative\n    \n    float vabs = sqrt(dot(value.xy, value.xy));\n    float dvabs = sqrt(dot(value.zw, value.zw));\n    float phase = atan(value.y, value.x);// / (2.0 * PI) + 0.5;\n    float dphase = dvabs / (vabs+0.01);\n    \n    float phaseOffset = offsetFromGridExcept(4, 16.0*phase / (2.0 * PI));\n    float phaseFactor = 1.0 - decay(phaseOffset * 5.0 / (ViewRadius * (dphase + 0.01)));\n    \n    float absFactor = 1.0;\n    if (vabs > 0.5) {\n        float absOffset = vabs * GridCoefficientLight;\n        absFactor = 1.0 - decay(gridFn(absOffset) * 12.0 /\n            (GridCoefficientLight * ViewRadius * (dvabs + 0.01)));\n    }\n    \n    float imagOffset = abs(value.y * GridCoefficientDark) + 1.0;\n    float imagFactor = 1.0 - decay(gridFn(imagOffset) * 15.0 /\n                                   (GridCoefficientDark * ViewRadius * (dvabs + 0.01)));\n    float realOffset = abs(value.x * GridCoefficientDark) + 1.0;\n\n    float realFactor = 1.0 - decay(gridFn(realOffset) * 15.0 /\n                                   (GridCoefficientDark * ViewRadius * (dvabs + 0.01)));\n\n    vec3 hsv = vec3(\n        phase,\n        phaseFactor * absFactor,\n        imagFactor * realFactor);\n        \n    fragColor = vec4(HSVtoRGB(hsv), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}