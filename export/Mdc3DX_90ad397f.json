{"ver":"0.1","info":{"id":"Mdc3DX","date":"1452449506","viewed":921,"name":"Comics Shader Multi pass Dither","username":"raja","description":"Multipass with Kuwahara, and Median !!","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["npr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define SORT_SIZE\t8\n\n//get color by packing 3 channels into 1 Or just do luminance to get some fps back :)\n#define COLOR 1\t\n\n//ramp the radius up and down... at the cost of some silly code which goes also slower\n#define RAMP 0\n\n\nfloat sort[SORT_SIZE];\n\n#define SWAP(a,b) { float t = max(sort[a],sort[b]); sort[a] = min(sort[a],sort[b]); sort[b] = t; }\n\n//various sized sorting networks generated with this:\n//http://pages.ripco.net/~jgamble/nw.html\n\n#define SORT8 SWAP(0, 1);  SWAP(2, 3); SWAP(0, 2); SWAP(1, 3); SWAP(1, 2); SWAP(4, 5); SWAP(6, 7); SWAP(4, 6); SWAP(5, 7); SWAP(5, 6); SWAP(0, 4); SWAP(1, 5); SWAP(1, 4); SWAP(2, 6); SWAP(3, 7); SWAP(3, 6); SWAP(2, 4); SWAP(3, 5); SWAP(3, 4);\n\n//There are 60 comparators in this network, grouped into 10 parallel operations.\n#define SORT16 SWAP(0, 1); SWAP(2, 3); SWAP(4, 5); SWAP(6, 7); SWAP(8, 9); SWAP(10, 11); SWAP(12, 13); SWAP(14, 15); SWAP(0, 2); SWAP(4, 6); SWAP(8, 10); SWAP(12, 14); SWAP(1, 3); SWAP(5, 7); SWAP(9, 11); SWAP(13, 15); SWAP(0, 4); SWAP(8, 12); SWAP(1, 5); SWAP(9, 13); SWAP(2, 6); SWAP(10, 14); SWAP(3, 7); SWAP(11, 15); SWAP(0, 8); SWAP(1, 9); SWAP(2, 10); SWAP(3, 11); SWAP(4, 12); SWAP(5, 13); SWAP(6, 14); SWAP(7, 15); SWAP(5, 10); SWAP(6, 9); SWAP(3, 12); SWAP(13, 14); SWAP(7, 11); SWAP(1, 2); SWAP(4, 8); SWAP(1, 4); SWAP(7, 13); SWAP(2, 8); SWAP(11, 14); SWAP(2, 4); SWAP(5, 6); SWAP(9, 10); SWAP(11, 13); SWAP(3, 8); SWAP(7, 12); SWAP(6, 8); SWAP(10, 12); SWAP(3, 5); SWAP(7, 9); SWAP(3, 4); SWAP(5, 6); SWAP(7, 8); SWAP(9, 10); SWAP(11, 12); SWAP(6, 7); SWAP(8, 9);\n\n//There are 191 comparators in this network, grouped into 15 parallel operations.\n#define SORT32 SWAP(0, 16); SWAP(1, 17); SWAP(2, 18); SWAP(3, 19); SWAP(4, 20); SWAP(5, 21); SWAP(6, 22); SWAP(7, 23); SWAP(8, 24); SWAP(9, 25); SWAP(10, 26); SWAP(11, 27); SWAP(12, 28); SWAP(13, 29); SWAP(14, 30); SWAP(15, 31); SWAP(0, 8); SWAP(1, 9); SWAP(2, 10); SWAP(3, 11); SWAP(4, 12); SWAP(5, 13); SWAP(6, 14); SWAP(7, 15); SWAP(16, 24); SWAP(17, 25); SWAP(18, 26); SWAP(19, 27); SWAP(20, 28); SWAP(21, 29); SWAP(22, 30); SWAP(23, 31); SWAP(8, 16); SWAP(9, 17); SWAP(10, 18); SWAP(11, 19); SWAP(12, 20); SWAP(13, 21); SWAP(14, 22); SWAP(15, 23); SWAP(0, 4); SWAP(1, 5); SWAP(2, 6); SWAP(3, 7); SWAP(24, 28); SWAP(25, 29); SWAP(26, 30); SWAP(27, 31); SWAP(8, 12); SWAP(9, 13); SWAP(10, 14); SWAP(11, 15); SWAP(16, 20); SWAP(17, 21); SWAP(18, 22); SWAP(19, 23); SWAP(0, 2); SWAP(1, 3); SWAP(28, 30); SWAP(29, 31); SWAP(4, 16); SWAP(5, 17); SWAP(6, 18); SWAP(7, 19); SWAP(12, 24); SWAP(13, 25); SWAP(14, 26); SWAP(15, 27); SWAP(0, 1); SWAP(30, 31); SWAP(4, 8); SWAP(5, 9); SWAP(6, 10); SWAP(7, 11); SWAP(12, 16); SWAP(13, 17); SWAP(14, 18); SWAP(15, 19); SWAP(20, 24); SWAP(21, 25); SWAP(22, 26); SWAP(23, 27); SWAP(4, 6); SWAP(5, 7); SWAP(8, 10); SWAP(9, 11); SWAP(12, 14); SWAP(13, 15); SWAP(16, 18); SWAP(17, 19); SWAP(20, 22); SWAP(21, 23); SWAP(24, 26); SWAP(25, 27); SWAP(2, 16); SWAP(3, 17); SWAP(6, 20); SWAP(7, 21); SWAP(10, 24); SWAP(11, 25); SWAP(14, 28); SWAP(15, 29); SWAP(2, 8); SWAP(3, 9); SWAP(6, 12); SWAP(7, 13); SWAP(10, 16); SWAP(11, 17); SWAP(14, 20); SWAP(15, 21); SWAP(18, 24); SWAP(19, 25); SWAP(22, 28); SWAP(23, 29); SWAP(2, 4); SWAP(3, 5); SWAP(6, 8); SWAP(7, 9); SWAP(10, 12); SWAP(11, 13); SWAP(14, 16); SWAP(15, 17); SWAP(18, 20); SWAP(19, 21); SWAP(22, 24); SWAP(23, 25); SWAP(26, 28); SWAP(27, 29); SWAP(2, 3); SWAP(4, 5); SWAP(6, 7); SWAP(8, 9); SWAP(10, 11); SWAP(12, 13); SWAP(14, 15); SWAP(16, 17); SWAP(18, 19); SWAP(20, 21); SWAP(22, 23); SWAP(24, 25); SWAP(26, 27); SWAP(28, 29); SWAP(1, 16); SWAP(3, 18); SWAP(5, 20); SWAP(7, 22); SWAP(9, 24); SWAP(11, 26); SWAP(13, 28); SWAP(15, 30); SWAP(1, 8); SWAP(3, 10); SWAP(5, 12); SWAP(7, 14); SWAP(9, 16); SWAP(11, 18); SWAP(13, 20); SWAP(15, 22); SWAP(17, 24); SWAP(19, 26); SWAP(21, 28); SWAP(23, 30); SWAP(1, 4); SWAP(3, 6); SWAP(5, 8); SWAP(7, 10); SWAP(9, 12); SWAP(11, 14); SWAP(13, 16); SWAP(15, 18); SWAP(17, 20); SWAP(19, 22); SWAP(21, 24); SWAP(23, 26); SWAP(25, 28); SWAP(27, 30); SWAP(1, 2); SWAP(3, 4); SWAP(5, 6); SWAP(7, 8); SWAP(9, 10); SWAP(11, 12); SWAP(13, 14); SWAP(15, 16); SWAP(17, 18); SWAP(19, 20); SWAP(21, 22); SWAP(23, 24); SWAP(25, 26); SWAP(27, 28); SWAP(29, 30); \n\n//There are 543 comparators in this network, grouped into 21 parallel operations.\n#define SORT64 SWAP(0, 32); SWAP(1, 33); SWAP(2, 34); SWAP(3, 35); SWAP(4, 36); SWAP(5, 37); SWAP(6, 38); SWAP(7, 39); SWAP(8, 40); SWAP(9, 41); SWAP(10, 42); SWAP(11, 43); SWAP(12, 44); SWAP(13, 45); SWAP(14, 46); SWAP(15, 47); SWAP(16, 48); SWAP(17, 49); SWAP(18, 50); SWAP(19, 51); SWAP(20, 52); SWAP(21, 53); SWAP(22, 54); SWAP(23, 55); SWAP(24, 56); SWAP(25, 57); SWAP(26, 58); SWAP(27, 59); SWAP(28, 60); SWAP(29, 61); SWAP(30, 62); SWAP(31, 63); SWAP(0, 16); SWAP(1, 17); SWAP(2, 18); SWAP(3, 19); SWAP(4, 20); SWAP(5, 21); SWAP(6, 22); SWAP(7, 23); SWAP(8, 24); SWAP(9, 25); SWAP(10, 26); SWAP(11, 27); SWAP(12, 28); SWAP(13, 29); SWAP(14, 30); SWAP(15, 31); SWAP(32, 48); SWAP(33, 49); SWAP(34, 50); SWAP(35, 51); SWAP(36, 52); SWAP(37, 53); SWAP(38, 54); SWAP(39, 55); SWAP(40, 56); SWAP(41, 57); SWAP(42, 58); SWAP(43, 59); SWAP(44, 60); SWAP(45, 61); SWAP(46, 62); SWAP(47, 63); SWAP(16, 32); SWAP(17, 33); SWAP(18, 34); SWAP(19, 35); SWAP(20, 36); SWAP(21, 37); SWAP(22, 38); SWAP(23, 39); SWAP(24, 40); SWAP(25, 41); SWAP(26, 42); SWAP(27, 43); SWAP(28, 44); SWAP(29, 45); SWAP(30, 46); SWAP(31, 47); SWAP(0, 8); SWAP(1, 9); SWAP(2, 10); SWAP(3, 11); SWAP(4, 12); SWAP(5, 13); SWAP(6, 14); SWAP(7, 15); SWAP(48, 56); SWAP(49, 57); SWAP(50, 58); SWAP(51, 59); SWAP(52, 60); SWAP(53, 61); SWAP(54, 62); SWAP(55, 63); SWAP(16, 24); SWAP(17, 25); SWAP(18, 26); SWAP(19, 27); SWAP(20, 28); SWAP(21, 29); SWAP(22, 30); SWAP(23, 31); SWAP(32, 40); SWAP(33, 41); SWAP(34, 42); SWAP(35, 43); SWAP(36, 44); SWAP(37, 45); SWAP(38, 46); SWAP(39, 47); SWAP(0, 4); SWAP(1, 5); SWAP(2, 6); SWAP(3, 7); SWAP(56, 60); SWAP(57, 61); SWAP(58, 62); SWAP(59, 63); SWAP(8, 32); SWAP(9, 33); SWAP(10, 34); SWAP(11, 35); SWAP(12, 36); SWAP(13, 37); SWAP(14, 38); SWAP(15, 39); SWAP(24, 48); SWAP(25, 49); SWAP(26, 50); SWAP(27, 51); SWAP(28, 52); SWAP(29, 53); SWAP(30, 54); SWAP(31, 55); SWAP(0, 2); SWAP(1, 3); SWAP(60, 62); SWAP(61, 63); SWAP(8, 16); SWAP(9, 17); SWAP(10, 18); SWAP(11, 19); SWAP(12, 20); SWAP(13, 21); SWAP(14, 22); SWAP(15, 23); SWAP(24, 32); SWAP(25, 33); SWAP(26, 34); SWAP(27, 35); SWAP(28, 36); SWAP(29, 37); SWAP(30, 38); SWAP(31, 39); SWAP(40, 48); SWAP(41, 49); SWAP(42, 50); SWAP(43, 51); SWAP(44, 52); SWAP(45, 53); SWAP(46, 54); SWAP(47, 55); SWAP(0, 1); SWAP(62, 63); SWAP(8, 12); SWAP(9, 13); SWAP(10, 14); SWAP(11, 15); SWAP(16, 20); SWAP(17, 21); SWAP(18, 22); SWAP(19, 23); SWAP(24, 28); SWAP(25, 29); SWAP(26, 30); SWAP(27, 31); SWAP(32, 36); SWAP(33, 37); SWAP(34, 38); SWAP(35, 39); SWAP(40, 44); SWAP(41, 45); SWAP(42, 46); SWAP(43, 47); SWAP(48, 52); SWAP(49, 53); SWAP(50, 54); SWAP(51, 55); SWAP(4, 32); SWAP(5, 33); SWAP(6, 34); SWAP(7, 35); SWAP(12, 40); SWAP(13, 41); SWAP(14, 42); SWAP(15, 43); SWAP(20, 48); SWAP(21, 49); SWAP(22, 50); SWAP(23, 51); SWAP(28, 56); SWAP(29, 57); SWAP(30, 58); SWAP(31, 59); SWAP(4, 16); SWAP(5, 17); SWAP(6, 18); SWAP(7, 19); SWAP(12, 24); SWAP(13, 25); SWAP(14, 26); SWAP(15, 27); SWAP(20, 32); SWAP(21, 33); SWAP(22, 34); SWAP(23, 35); SWAP(28, 40); SWAP(29, 41); SWAP(30, 42); SWAP(31, 43); SWAP(36, 48); SWAP(37, 49); SWAP(38, 50); SWAP(39, 51); SWAP(44, 56); SWAP(45, 57); SWAP(46, 58); SWAP(47, 59); SWAP(4, 8); SWAP(5, 9); SWAP(6, 10); SWAP(7, 11); SWAP(12, 16); SWAP(13, 17); SWAP(14, 18); SWAP(15, 19); SWAP(20, 24); SWAP(21, 25); SWAP(22, 26); SWAP(23, 27); SWAP(28, 32); SWAP(29, 33); SWAP(30, 34); SWAP(31, 35); SWAP(36, 40); SWAP(37, 41); SWAP(38, 42); SWAP(39, 43); SWAP(44, 48); SWAP(45, 49); SWAP(46, 50); SWAP(47, 51); SWAP(52, 56); SWAP(53, 57); SWAP(54, 58); SWAP(55, 59); SWAP(4, 6); SWAP(5, 7); SWAP(8, 10); SWAP(9, 11); SWAP(12, 14); SWAP(13, 15); SWAP(16, 18); SWAP(17, 19); SWAP(20, 22); SWAP(21, 23); SWAP(24, 26); SWAP(25, 27); SWAP(28, 30); SWAP(29, 31); SWAP(32, 34); SWAP(33, 35); SWAP(36, 38); SWAP(37, 39); SWAP(40, 42); SWAP(41, 43); SWAP(44, 46); SWAP(45, 47); SWAP(48, 50); SWAP(49, 51); SWAP(52, 54); SWAP(53, 55); SWAP(56, 58); SWAP(57, 59); SWAP(2, 32); SWAP(3, 33); SWAP(6, 36); SWAP(7, 37); SWAP(10, 40); SWAP(11, 41); SWAP(14, 44); SWAP(15, 45); SWAP(18, 48); SWAP(19, 49); SWAP(22, 52); SWAP(23, 53); SWAP(26, 56); SWAP(27, 57); SWAP(30, 60); SWAP(31, 61); SWAP(2, 16); SWAP(3, 17); SWAP(6, 20); SWAP(7, 21); SWAP(10, 24); SWAP(11, 25); SWAP(14, 28); SWAP(15, 29); SWAP(18, 32); SWAP(19, 33); SWAP(22, 36); SWAP(23, 37); SWAP(26, 40); SWAP(27, 41); SWAP(30, 44); SWAP(31, 45); SWAP(34, 48); SWAP(35, 49); SWAP(38, 52); SWAP(39, 53); SWAP(42, 56); SWAP(43, 57); SWAP(46, 60); SWAP(47, 61); SWAP(2, 8); SWAP(3, 9); SWAP(6, 12); SWAP(7, 13); SWAP(10, 16); SWAP(11, 17); SWAP(14, 20); SWAP(15, 21); SWAP(18, 24); SWAP(19, 25); SWAP(22, 28); SWAP(23, 29); SWAP(26, 32); SWAP(27, 33); SWAP(30, 36); SWAP(31, 37); SWAP(34, 40); SWAP(35, 41); SWAP(38, 44); SWAP(39, 45); SWAP(42, 48); SWAP(43, 49); SWAP(46, 52); SWAP(47, 53); SWAP(50, 56); SWAP(51, 57); SWAP(54, 60); SWAP(55, 61); SWAP(2, 4); SWAP(3, 5); SWAP(6, 8); SWAP(7, 9); SWAP(10, 12); SWAP(11, 13); SWAP(14, 16); SWAP(15, 17); SWAP(18, 20); SWAP(19, 21); SWAP(22, 24); SWAP(23, 25); SWAP(26, 28); SWAP(27, 29); SWAP(30, 32); SWAP(31, 33); SWAP(34, 36); SWAP(35, 37); SWAP(38, 40); SWAP(39, 41); SWAP(42, 44); SWAP(43, 45); SWAP(46, 48); SWAP(47, 49); SWAP(50, 52); SWAP(51, 53); SWAP(54, 56); SWAP(55, 57); SWAP(58, 60); SWAP(59, 61); SWAP(2, 3); SWAP(4, 5); SWAP(6, 7); SWAP(8, 9); SWAP(10, 11); SWAP(12, 13); SWAP(14, 15); SWAP(16, 17); SWAP(18, 19); SWAP(20, 21); SWAP(22, 23); SWAP(24, 25); SWAP(26, 27); SWAP(28, 29); SWAP(30, 31); SWAP(32, 33); SWAP(34, 35); SWAP(36, 37); SWAP(38, 39); SWAP(40, 41); SWAP(42, 43); SWAP(44, 45); SWAP(46, 47); SWAP(48, 49); SWAP(50, 51); SWAP(52, 53); SWAP(54, 55); SWAP(56, 57); SWAP(58, 59); SWAP(60, 61); SWAP(1, 32); SWAP(3, 34); SWAP(5, 36); SWAP(7, 38); SWAP(9, 40); SWAP(11, 42); SWAP(13, 44); SWAP(15, 46); SWAP(17, 48); SWAP(19, 50); SWAP(21, 52); SWAP(23, 54); SWAP(25, 56); SWAP(27, 58); SWAP(29, 60); SWAP(31, 62); SWAP(1, 16); SWAP(3, 18); SWAP(5, 20); SWAP(7, 22); SWAP(9, 24); SWAP(11, 26); SWAP(13, 28); SWAP(15, 30); SWAP(17, 32); SWAP(19, 34); SWAP(21, 36); SWAP(23, 38); SWAP(25, 40); SWAP(27, 42); SWAP(29, 44); SWAP(31, 46); SWAP(33, 48); SWAP(35, 50); SWAP(37, 52); SWAP(39, 54); SWAP(41, 56); SWAP(43, 58); SWAP(45, 60); SWAP(47, 62); SWAP(1, 8); SWAP(3, 10); SWAP(5, 12); SWAP(7, 14); SWAP(9, 16); SWAP(11, 18); SWAP(13, 20); SWAP(15, 22); SWAP(17, 24); SWAP(19, 26); SWAP(21, 28); SWAP(23, 30); SWAP(25, 32); SWAP(27, 34); SWAP(29, 36); SWAP(31, 38); SWAP(33, 40); SWAP(35, 42); SWAP(37, 44); SWAP(39, 46); SWAP(41, 48); SWAP(43, 50); SWAP(45, 52); SWAP(47, 54); SWAP(49, 56); SWAP(51, 58); SWAP(53, 60); SWAP(55, 62); SWAP(1, 4); SWAP(3, 6); SWAP(5, 8); SWAP(7, 10); SWAP(9, 12); SWAP(11, 14); SWAP(13, 16); SWAP(15, 18); SWAP(17, 20); SWAP(19, 22); SWAP(21, 24); SWAP(23, 26); SWAP(25, 28); SWAP(27, 30); SWAP(29, 32); SWAP(31, 34); SWAP(33, 36); SWAP(35, 38); SWAP(37, 40); SWAP(39, 42); SWAP(41, 44); SWAP(43, 46); SWAP(45, 48); SWAP(47, 50); SWAP(49, 52); SWAP(51, 54); SWAP(53, 56); SWAP(55, 58); SWAP(57, 60); SWAP(59, 62); SWAP(1, 2); SWAP(3, 4); SWAP(5, 6); SWAP(7, 8); SWAP(9, 10); SWAP(11, 12); SWAP(13, 14); SWAP(15, 16); SWAP(17, 18); SWAP(19, 20); SWAP(21, 22); SWAP(23, 24); SWAP(25, 26); SWAP(27, 28); SWAP(29, 30); SWAP(31, 32); SWAP(33, 34); SWAP(35, 36); SWAP(37, 38); SWAP(39, 40); SWAP(41, 42); SWAP(43, 44); SWAP(45, 46); SWAP(47, 48); SWAP(49, 50); SWAP(51, 52); SWAP(53, 54); SWAP(55, 56); SWAP(57, 58); SWAP(59, 60); SWAP(61, 62); \n\nvoid Sort()\n{\n\t#if (SORT_SIZE == 8)\n\tSORT8\n\t#endif\t\n\t#if (SORT_SIZE == 16)\n\tSORT16\n\t#endif\n\t#if (SORT_SIZE == 32)\n\tSORT32\n\t#endif\n\t#if (SORT_SIZE == 64)\n\tSORT64\n\t#endif\t\n}\n\nfloat medians[SORT_SIZE];\n\nfloat quant(float x)\n{\n\tx = clamp(x,0.,1.);\n\treturn floor(x*255.);\n}\n\nfloat pack(vec3 c)\n{\t\n\tfloat lum = (c.x+c.y+c.z)*(1./3.);\n\n#if COLOR\t\n\t//want to sort by luminance I guess so put that in MSB and quantize everything to 8 bit\n\t//since floats represent 24 bit ints you get 3 channels and only have to sort a scalar value\n\treturn quant(c.x) + quant(c.y)*256. + quant(lum) * 65536.;\n#else\t\n\treturn lum;\n#endif\t\n}\n\nvec3 unpack(float x)\n{\n#if COLOR\t\t\n\tfloat lum = floor(x * (1./65536.)) * (1./255.);\n\tvec3 c;\n\tc.x = floor(mod(x,256.)) \t\t\t* (1./255.);\n\tc.y = floor(mod(x*(1./256.),256.)) * (1./255.);\n\tc.z = lum * 3. - c.y - c.x;\n\treturn c;\n#else\n\treturn vec3(x);\t\n#endif\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ooRes = vec2(1) / iResolution.xy;\n    vec2 inuv = fragCoord/iResolution.xy;\n    inuv.y = 1.0 - inuv.y;\n    vec4 invec = texture(iChannel0,inuv);\n    vec4 stvec = texture(iChannel1,inuv);\n\n#if RAMP\t\n\t//pick a radius to ramp up and down to demo the effect ... sorting networks are fixed size.\n\tfloat r = float(SORT_SIZE/2)*1.1;\n#endif\n\t\n\t//do a bunch of 1D sorts on X\n\tfor (int j=0; j<SORT_SIZE; j++)\n\t{\n\t\t//gather all X the texels for this Y\n\t\tfor (int i=0; i<SORT_SIZE; i++)\n\t\t{\n\t\t\tvec2 uv = (fragCoord.xy + vec2(i,j)-vec2(SORT_SIZE/2)) * ooRes;\n\t\t\tuv.y=1.-uv.y; //upside down\n\t\t\tfloat c = pack( texture(iChannel0,uv).xyz );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#if RAMP\t\n\t\t\tif (float(i)<float(SORT_SIZE/2) - r) c=-1e10;\t//force to beginning of sorted list\n\t\t\tif (float(i)>float(SORT_SIZE/2) + r) c=1e10;\t//force to end of sorted list\n#endif\t\t\t\n\t\t\tsort[i]=c;\t\t\t\n\t\t}\n\t\t\t\n\t\tSort();\n\t\t\n\t\t//keep the median from X\n\t\tfloat m = sort[(SORT_SIZE/2)];\n\n#if RAMP\t\t\t\n\t\tif (float(j)<float(SORT_SIZE/2) - r) m=-1e10;\n\t\tif (float(j)>float(SORT_SIZE/2) + r) m=1e10;\t\t\t\t\n#endif\t\n\t\tmedians[j] = m;\n\t}\n\n\t//sort the medians\n\tfor (int i=0; i<SORT_SIZE; i++)\n\t{\n\t\tsort[i]=medians[i];\n\t}\t\n\tSort();\n\t\n    vec4 outvec = vec4(unpack(sort[(SORT_SIZE/2)]),1.0);\n    outvec = mix(stvec, outvec, 0.45);\n\tfragColor = mix(invec, outvec, 0.25);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\nconst int radius = 4;\n\nvec3 darken( vec3 s, vec3 d )\n{\n\treturn min(s,d);\n}\n\nvec3 multiply( vec3 s, vec3 d )\n{\n\treturn s*d;\n}\n\nvec3 colorBurn( vec3 s, vec3 d )\n{\n\treturn 1.0 - (1.0 - d) / s;\n}\n\nvec3 linearBurn( vec3 s, vec3 d )\n{\n\treturn s + d - 1.0;\n}\n\nvec3 darkerColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z < d.x + d.y + d.z) ? s : d;\n}\n\nvec3 lighten( vec3 s, vec3 d )\n{\n\treturn max(s,d);\n}\n\nvec3 screen( vec3 s, vec3 d )\n{\n\treturn s + d - s * d;\n}\n\nvec3 colorDodge( vec3 s, vec3 d )\n{\n\treturn d / (1.0 - s);\n}\n\nvec3 linearDodge( vec3 s, vec3 d )\n{\n\treturn s + d;\n}\n\nvec3 lighterColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d;\n}\n\nfloat overlay( float s, float d )\n{\n\treturn (d < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 overlay( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = overlay(s.x,d.x);\n\tc.y = overlay(s.y,d.y);\n\tc.z = overlay(s.z,d.z);\n\treturn c;\n}\n\nfloat softLight( float s, float d )\n{\n\treturn (s < 0.5) ? d - (1.0 - 2.0 * s) * d * (1.0 - d) \n\t\t: (d < 0.25) ? d + (2.0 * s - 1.0) * d * ((16.0 * d - 12.0) * d + 3.0) \n\t\t\t\t\t : d + (2.0 * s - 1.0) * (sqrt(d) - d);\n}\n\nvec3 softLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = softLight(s.x,d.x);\n\tc.y = softLight(s.y,d.y);\n\tc.z = softLight(s.z,d.z);\n\treturn c;\n}\n\nfloat hardLight( float s, float d )\n{\n\treturn (s < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 hardLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = hardLight(s.x,d.x);\n\tc.y = hardLight(s.y,d.y);\n\tc.z = hardLight(s.z,d.z);\n\treturn c;\n}\n\nfloat vividLight( float s, float d )\n{\n\treturn (s < 0.5) ? 1.0 - (1.0 - d) / (2.0 * s) : d / (2.0 * (1.0 - s));\n}\n\nvec3 vividLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = vividLight(s.x,d.x);\n\tc.y = vividLight(s.y,d.y);\n\tc.z = vividLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 linearLight( vec3 s, vec3 d )\n{\n\treturn 2.0 * s + d - 1.0;\n}\n\nfloat pinLight( float s, float d )\n{\n\treturn (2.0 * s - 1.0 > d) ? 2.0 * s - 1.0 : (s < 0.5 * d) ? 2.0 * s : d;\n}\n\nvec3 pinLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = pinLight(s.x,d.x);\n\tc.y = pinLight(s.y,d.y);\n\tc.z = pinLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 hardMix( vec3 s, vec3 d )\n{\n\treturn floor(s + d);\n}\n\nvec3 difference( vec3 s, vec3 d )\n{\n\treturn abs(d - s);\n}\n\nvec3 exclusion( vec3 s, vec3 d )\n{\n\treturn s + d - 2.0 * s * d;\n}\n\nvec3 subtract( vec3 s, vec3 d )\n{\n\treturn s - d;\n}\n\nvec3 divide( vec3 s, vec3 d )\n{\n\treturn s / d;\n}\n\n//\trgb<-->hsv functions by Sam Hocevar\n//\thttp://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\t\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hue( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.x = rgb2hsv(s).x;\n\treturn hsv2rgb(d);\n}\n\nvec3 color( vec3 s, vec3 d )\n{\n\ts = rgb2hsv(s);\n\ts.z = rgb2hsv(d).z;\n\treturn hsv2rgb(s);\n}\n\nvec3 saturation( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.y = rgb2hsv(s).y;\n\treturn hsv2rgb(d);\n}\n\nvec3 luminosity( vec3 s, vec3 d )\n{\n\tfloat dLum = dot(d, vec3(0.3, 0.59, 0.11));\n\tfloat sLum = dot(s, vec3(0.3, 0.59, 0.11));\n\tfloat lum = sLum - dLum;\n\tvec3 c = d + lum;\n\tfloat minC = min(min(c.x, c.y), c.z);\n\tfloat maxC = max(max(c.x, c.y), c.z);\n\tif(minC < 0.0) return sLum + ((c - sLum) * sLum) / (sLum - minC);\n\telse if(maxC > 1.0) return sLum + ((c - sLum) * (1.0 - sLum)) / (maxC - sLum);\n\telse return c;\n}\nvec3 sample( vec2 fragCoord, const int x, const int y)\n{\n\tvec2 uv = (fragCoord.xy + vec2(x, y)) / iResolution.xy;\n\t//uv.y = 1.0 - uv.y;\n\t\n\treturn texture(iChannel0, uv).xyz;\n}\n\n\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n {\n\t vec2 src_size = vec2 (1.0 / iResolution.x, 1.0 / iResolution.y);\n     vec2 uv = fragCoord.xy/iResolution.xy;\n     uv.y = 1.0 - uv.y;\n     float n = float((radius + 1) * (radius + 1));\n     int i; \n\t int j;\n     vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n     vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n     vec3 c;\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m0 += c;\n             s0 += c * c;\n         }\n     }\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m1 += c;\n             s1 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m2 += c;\n             s2 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m3 += c;\n             s3 += c * c;\n         }\n     }\n\n\n\t vec4 result;\n     float min_sigma2 = 1e+2;\n     m0 /= n;\n     s0 = abs(s0 / n - m0 * m0);\n\n     float sigma2 = s0.r + s0.g + s0.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m0, 1.0);\n     }\n\n     m1 /= n;\n     s1 = abs(s1 / n - m1 * m1);\n\n     sigma2 = s1.r + s1.g + s1.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m1, 1.0);\n     }\n\n     m2 /= n;\n     s2 = abs(s2 / n - m2 * m2);\n\n     sigma2 = s2.r + s2.g + s2.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m2, 1.0);\n     }\n\n     m3 /= n;\n     s3 = abs(s3 / n - m3 * m3);\n\n     sigma2 = s3.r + s3.g + s3.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m3, 1.0);\n     }\n\t\n\t const vec3 lumi = vec3(0.2126, 0.7152, 0.0722);\n\t\n\tvec3 hc =sample(uv,-1,-1) *  1.0 + sample( uv,0,-1) *  2.0\n\t\t \t+sample( uv,1,-1) *  1.0 + sample(uv,-1, 1) * -1.0\n\t\t \t+sample( uv,0, 1) * -2.0 + sample( uv,1, 1) * -1.0;\n\t\t\n\tvec3 vc =sample(uv,-1,-1) *  1.0 + sample(uv,-1, 0) *  2.0\n\t\t \t+sample(uv,-1, 1) *  1.0 + sample( uv,1,-1) * -1.0\n\t\t \t+sample(uv, 1, 0) * -2.0 + sample( uv,1, 1) * -1.0;\n\t\n\tvec3 c2 = sample(uv,0, 0);\n\t\n\t\n\tc2 -= pow(c2, vec3(0.2126, 0.7152, 0.0722)) * pow(dot(lumi, vc*vc + hc*hc), 0.5);\n\tvec4 outvec = vec4(overlay(screen( result.rgb,c2.rgb), result.rgb) , 1.0); \n    fragColor = outvec;\n }\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//checkerboard noise\nvec2 stepnoise(vec2 p, float size) {\n    p += 10.0;\n    float x = floor(p.x/size)*size;\n    float y = floor(p.y/size)*size;\n    \n    x = fract(x*0.1) + 1.0 + x*0.0002;\n    y = fract(y*0.1) + 1.0 + y*0.0003;\n    \n    float a = fract(1.0 / (0.000001*x*y + 0.00001));\n    a = fract(1.0 / (0.000001234*a + 0.00001));\n    \n    float b = fract(1.0 / (0.000002*(x*y+x) + 0.00001));\n    b = fract(1.0 / (0.0000235*b + 0.00001));\n    \n    return vec2(a, b);\n    \n}\nfloat tent(float f) {\n    return 1.0 - abs(fract(f)-0.5)*2.0;\n}\n\n#define SEED1 (1.705)\n#define SEED2 (1.379)\n#define DMUL 8.12235325\n\nfloat poly(float a, float b, float c, float ta, float tb, float tc) {\n    return (a*ta + b*tb + c*tc) / (ta+tb+tc);\n}\nfloat mask(vec2 p) {\n    vec2 r = stepnoise(p, 5.5)-0.5;\n    p[0] += r[0]*DMUL;\n    p[1] += r[1]*DMUL;\n    \n    float f = fract(p[0]*SEED1 + p[1]/(SEED1+0.15555))*1.03;\n    return poly(pow(f, 150.0), f*f, f, 1.0, 0.0, 1.3);\n}\n\nfloat s(float x, float y, vec2 uv) {\n    vec4 clr = texture(iChannel0, vec2(x, y)/iResolution.xy + uv);\n    float f = clr[0]*0.3 + clr[1]*0.6 + clr[1]*0.1;\n    \n    return f;\n}\n\nmat3 normalize(mat3 mat) {\n    float sum = mat[0][0]+mat[0][1]+mat[0][2]\n              + mat[1][0]+mat[1][1]+mat[1][2]\n              + mat[2][0]+mat[2][1]+mat[2][2];\n    return mat / sum;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 uv2 = fragCoord.xy / iResolution.x;\n    \n    vec2 r = stepnoise(uv, 6.0);\n    \n    vec4 clr = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    float slide = tent(-0.0*iTime+uv2[0]*0.5);\n    \n    float f = clr[0]*0.3 + clr[1]*0.6 + clr[1]*0.1;\n    \n    //sharpen input.  this is necassary for stochastic\n    //ordered dither methods.\n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n\n\n    float d = 0.5;\n    mat3 mat = mat3(\n        vec3(d, d,   d),\n        vec3(d, 2.0, d),\n        vec3(d, d,   d)\n    );\n    \n    float f1 = s(0.0, 0.0, uv3);\n    \n    mat = normalize(mat)*1.0;\n    f = s(-1.0, -1.0, uv3)*mat[0][0] + s(-1.0, 0.0, uv3)*mat[0][1] + s(-1.0, 1.0, uv3)*mat[0][2]\n      + s( 0.0, -1.0, uv3)*mat[1][0] + s( 0.0, 0.0, uv3)*mat[1][1] + s( 0.0, 1.0, uv3)*mat[1][2]\n      + s( 1.0, -1.0, uv3)*mat[2][0] + s( 1.0, 0.0, uv3)*mat[2][1] + s( 1.0, 1.0, uv3)*mat[2][2];\n    \n    f = (f-s(0.0, 0.0, uv3));\n    f *= 40.0;\n    f = f1 - f;\n    \n    float c = mask(uv) * 0.1;\n    \n    if (uv2[1] < 0.01) {\n        c = float(slide >= c);\n    } else {\n\t    c = float(f >= c);\n    }\n    \n\tfragColor = vec4(c, c, c, 1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}