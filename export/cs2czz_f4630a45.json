{"ver":"0.1","info":{"id":"cs2czz","date":"1691518259","viewed":52,"name":"Abstract Fake Waves","username":"sagescherrytree","description":"A basic repetition with some SDF action (used a simple sphere SDF). I thought it looked cool despite its somewhat random origins. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","perlinnoise","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 4.0\n// Controls the sample density, which in turn, controls the sample spread.\nfloat density = 5.0; \n    \nvec3 palette(float t) {\n    //vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 a = vec3(0.500, 0.500, 0.770);\n    //vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.610, 0.500, 0.790);\n    //vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 c = vec3(0.801, 0.800, 0.664);\n    //vec3 d = vec3(0.263,0.416,0.557);\n    //vec3 d = vec3(1.388, -0.842, -0.132);\n    //vec3 d = vec3(1.388, -0.842, 0.628);\n    vec3 d = vec3(-0.682, -0.485, 2.675);\n    //vec3 d = vec3(-0.682, -0.485, -2.675);\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\n// Going to try to make a circle hehe\nfloat SDF_Sphere(vec3 query, float radius ) {\n    return length(query) - radius;\n}\n\nvec2 random(vec2 r) {\n    return fract(sin(vec2(dot(r, vec2(127.1, 311.7)), dot(r, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat surflet(vec2 P, vec2 gridPoint) {\n    // Compute falloff function by converting linear distance to a polynomial\n    float distX = abs(P.x - gridPoint.x);\n    float distY = abs(P.y - gridPoint.y);\n    float tX = 1.0 - 6.0 * pow(distX, 5.f) + 15.0 * pow(distX, 4.f) - 10.0 * pow(distX, 3.f);\n    float tY = 1.0 - 6.0 * pow(distY, 5.f) + 15.0 * pow(distY, 4.f) - 10.0 * pow(distY, 3.f);\n    // Get the random vector for the grid point\n    vec2 gradient = 2.f * random(gridPoint) - vec2(1.f);\n    // Get the vector from the grid point to P\n    vec2 diff = P - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * tX * tY;\n}\n\n\nfloat perlinNoise(vec2 uv) {\n        float surfletSum = 0.f;\n        // Iterate over the four integer corners surrounding uv\n        for(int dx = 0; dx <= 1; ++dx) {\n                for(int dy = 0; dy <= 1; ++dy) {\n                        surfletSum += surflet(uv, floor(uv) + vec2(dx, dy));\n                }\n        }\n        return surfletSum;\n}\n\n// Offset\nvec3 offset(vec2 query){    \n    float c = cos(-0.1 * query.x);\n    float s = sin(-0.1 * query.y);\n    // Rotation matrix\n    mat2 a = mat2(c, s, -s, c);\n    \n    // What is l? TODO: modify l\n    vec3 l = normalize(vec3(50.5, 10., -0.05));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalCol = vec3(0.0);\n    // Offset. Gets updated? Possibly? \n    vec3 off = offset(uv0);\n    \n    for (float i = 1.0; i < MAX_ITERATIONS; i+=1.0) {\n        uv = fract(uv * 1.5) - 0.5 - off.xy * .45;\n        \n        vec2 densityUV = uv * density / 3.0;\n        \n        float d = length(uv) * exp(-length(uv0));\n        \n        vec2 colUV = finalCol.xy;\n        float perlinCircle = perlinNoise(densityUV);\n        float circle = SDF_Sphere(finalCol *1.1, perlinCircle);\n        circle += perlinNoise(colUV);\n        \n        float x = perlinNoise(uv * 0.5);\n        vec3 col = palette(length(uv0) + iTime * 0.4 + i * 0.4);\n        col += vec3(x);\n    \n        //d = sin(d*8.0 + iTime) / 8.0;\n        d = 3.0 * sin(d * iTime)/iTime + 3.0 * cos(d * iTime) / iTime;\n        //d = 3.0 * sin(perlinCircle * iTime) / iTime;\n        d += mod(x,i);\n        d = abs(d);\n        d = pow(0.01/d, circle * 0.3);\n        d *= 1.0 / pow(0.5, i);\n        \n        // Time varying pixel color\n        finalCol += col * d;\n        finalCol -= circle;\n    }\n\n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}","name":"Image","description":"","type":"image"}]}