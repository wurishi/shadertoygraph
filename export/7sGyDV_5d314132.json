{"ver":"0.1","info":{"id":"7sGyDV","date":"1655627613","viewed":75,"name":"Ray tracing (graphics lab)","username":"yuliiasha","description":"Computer Graphics Lab","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec2 sdfBalloon( vec3 currentRayPosition, vec3 centerPos, float balloonRadiusSet, float balloonId ){\n  vec3 balloonPosition = centerPos;\n  float balloonRadius = balloonRadiusSet;\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n  float balloonID = balloonId;\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n  return balloon;\n}\n\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2, vec2 thing3 ){ \n   vec2 closestThing;\n   if( thing1.x <= thing2.x  && thing1.x <= thing3.x ){\n       closestThing = thing1;\n   }else if( thing2.x <= thing1.x && thing2.x <= thing3.x ){\n       closestThing = thing2;\n   } else if(thing3.x <= thing1.x && thing3.x <= thing2.x){\n       closestThing = thing3;\n   }\n   return closestThing;\n}\n\nvec2 mapTheWorld( vec3 currentRayPosition ){\n  vec2 result;\n  vec2 balloon = sdfBalloon( currentRayPosition,  vec3( 0. , 0. , 0.), .65, 1.);\n  vec2 balloon1 = sdfBalloon( currentRayPosition,  vec3( -.5 , .4 , 0.3 ), .3, 2.);\n  vec2 balloon2 = sdfBalloon( currentRayPosition, vec3( 0.5 , .4 , 0.3 ), .3, 2. );\n  result = whichThingAmICloserTo( balloon , balloon1, balloon2 );\n  return result;\n}\n\n\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.001;\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.;\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 100;\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  float distanceToSurface       = HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n  float totalDistanceTraveledByRay   = 0.;\n  float finalDistanceTraveledByRay   = -1.;\n  float finalID = -1.;\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n    distanceToSurface           = distanceToThingsInTheWorld;\n    finalID = idOfClosestThingInTheWorld;  \n    totalDistanceTraveledByRay += distanceToThingsInTheWorld;\n  }\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n    finalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n    finalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n  vec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n     float upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n  vec3 normal = vec3(\n               tinyChangeInX,\n              tinyChangeInY,\n              tinyChangeInZ\n             );\n    \n  return normalize(normal);\n}\nvec3 doBackgroundColor(){\n  return vec3( 0.011, 0.244, 0.335 );\n}\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 2. , 4. , 0. );\n    vec3 lightDirection = sunPosition - positionOfHit;\n    lightDirection = normalize( lightDirection );\n    float faceValue = dot( lightDirection , normalOfSurface );\n    faceValue = max( 0. , faceValue );\n    vec3 balloonColor = vec3( 0.045 , 0.910 , 0.350 );\n    vec3 color = balloonColor * faceValue;\n    color += vec3( 0.007 , 0.432, 0.353 );\n  return color;\n}\n\nvec3 doSecondBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){    \n    vec3 sunPosition = vec3( 2. , 4. , 0. );\n    vec3 lightDirection = sunPosition - positionOfHit;\n    lightDirection = normalize( lightDirection );\n    float faceValue = dot( lightDirection , normalOfSurface );\n    faceValue = max( 0. , faceValue );\n    vec3 balloonColor = vec3( 0.579 , 0.883 , 0.613 );\n    vec3 color = balloonColor * faceValue;\n    color += vec3( 0.259 , 0.737, 0.662 );\n  return color;\n}\n\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n  vec3 color;\n  if( rayHitInfo.y < 0.0 ){\n    color = doBackgroundColor();  \n  }else{\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      if( rayHitInfo.y == 1.0 ){\n      color = doBalloonColor( positionOfHit , normalOfSurface ); \n      }else if( rayHitInfo.y == 2.0 ){\n        color = doSecondBalloonColor( positionOfHit , normalOfSurface );    \n      }\n    }\n\n    return color;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    vec2 xyPositionOfPixelInWindow = p;\n    vec3 eyePosition = vec3( 0., 0., 2.);    \n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n  vec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n  fragColor = vec4(color,1.0);\n\n       \n}","name":"Image","description":"","type":"image"}]}