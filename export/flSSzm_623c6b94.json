{"ver":"0.1","info":{"id":"flSSzm","date":"1627300071","viewed":99,"name":"My Swimming Pool","username":"Binbinbins","description":"泳池里的小球\nBlinn-Phong shading","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 ambient = vec3(1, 0.8, 1);\n\nconst vec3 cam = vec3(0.6, 0.6, 1);\nconst vec3 sphereCen = vec3(0.2,0.8, -0.9);  //r = 0.1\nconst float sphereR = 0.1;\nconst vec3 sphereColor = vec3(1, 0.8, 0);\nconst vec3 lightPos = vec3(1.3, 0.3, 1);\nconst float lightIntensity = 5.;\n\nconst float n_i = 1.0;\nconst float n_t = 1.333;\n\nconst float param0 = 0.02;\nconst float param1 = 10.;\nconst float param2 = 3.;\n\nvec3 getLightPos(){\n    float x = sin(iTime* 0.5) + 1.;\n    float y = cos(iTime* 0.5) + 1.;\n    return vec3(x, y, 1);\n}\n\nvec3 getSphereCen(){\n    float x = cos(iTime* 0.5)/3. + .5;\n    float y = 1. -x;//sin(iTime* 0.5)/3. + .5;\n    return vec3(x,y, -0.9);\n    return vec3(0.3,0.3, -0.9);\n}\n\n\nfloat water(vec2 uv){\n    float t = uv.x - uv.y;\n    return param0 * (sin(t  * param1 + iTime * param2) + 1.);\n}\n\nvec3 water_normal(vec2 uv){\n    float dz_dx = param0 * cos((uv.x - uv.y) * param1 + iTime * param2) * param1;\n    float dz_dy = - param0 * cos((uv.x - uv.y) * param1 + iTime * param2) * param1;\n    return normalize(vec3(dz_dx, dz_dy, 1));\n}\n\n\nvec3 getColorFromBufA(vec2 uv){\n    uv = (uv - vec2(0.5, 0.5))/2. + vec2(0.5, 0.5);\n    return texture(iChannel0, uv).xyz;\n}\n\n\nfloat hit_sphere(vec3 o, vec3 dir){\n    float a = dot(dir, dir);\n    vec3 cen = getSphereCen();\n    float b = 2. * dot((o - cen), dir);\n    float c = dot(o - cen, o - cen) - sphereR * sphereR;\n    float delta = b * b - 4. * a * c;\n    if (delta < 0.){\n        return -1.;\n    }\n    float t1 = (- b + sqrt(delta)) / (2. * a);\n    float t2 = (- b - sqrt(delta)) / (2. * a);\n    return min(t1, t2);\n}\n\nvec4 shade_bg(vec3 o, vec3 hit_p){\n    vec3 n = vec3(0,0,1);\n    vec3 l = getLightPos() - hit_p;\n    vec3 dir = normalize(l);\n    float r = length(l);\n    l = normalize(l);\n    vec3 v = normalize(o - hit_p);\n    vec3 h = normalize(v + l);\n    vec3 color;\n    float t = hit_sphere(hit_p, dir);\n    float i = lightIntensity / r / r;\n    \n    vec3 La = ambient * 0.2;\n    \n    if (t > 0.){\n        color = La;\n    }else{\n        color = getColorFromBufA(hit_p.xy);\n        vec3 Ld =  color * i * max(0., dot(n, l));\n        color = La + Ld;\n    }\n    \n    return vec4(color, hit_p.z);  //z for depth here\n}\n\nvec4 shade_sphere(vec3 o, vec3 hit_p){\n    vec3 cen = getSphereCen();\n    vec3 n = normalize(hit_p - cen);\n    vec3 l = getLightPos() - hit_p;\n    float r = length(l);\n    float i = lightIntensity / r / r;\n    vec3 v = o - hit_p;\n    vec3 h = normalize(v + l);\n    l = normalize(l);\n    vec3 La = ambient * 0.2;\n    vec3 Ld = sphereColor * i * max(0., dot(n, l));\n    vec3 Ls = 0.2 * sphereColor * i * max(0., pow(dot(n, h), 50.));\n    return vec4(La + Ld + Ls, hit_p.z);\n}\n\n\nvec3 my_refract(vec3 w_n, vec3 d_in){\n    float cos_i = dot(w_n, d_in);\n    float ni_over_nt = n_i / n_t;\n    float delta = 1. - ni_over_nt * ni_over_nt * (1. - cos_i * cos_i);\n    if (delta < 0.){\n        return vec3(0,0,0);\n    }else{\n        float cos_t = sqrt(delta);\n        return normalize((ni_over_nt * cos_i - cos_t) * w_n -  ni_over_nt * d_in);\n    }\n}\n\nvec3 trace(vec2 uv){\n    vec3 screen_p = vec3(uv, 0);\n    vec3 dir = normalize(screen_p - cam);\n    vec3 hit_p = vec3(0,0, -1);\n\n    vec4 res;\n    vec3 w_p = vec3(uv, -0.2 + water(uv));\n    vec3 w_n = water_normal(uv);\n    \n    vec3 ref_dir = my_refract(w_n, cam - w_p);\n    if (length(ref_dir) == 0.) return vec3(1,1,1);\n    \n    float t = hit_sphere(w_p, ref_dir);\n    if (t >= 0.){\n        hit_p = w_p + ref_dir * t;\n        res = shade_sphere(w_p, hit_p);\n    }else{\n        float t = (-1. - w_p.z)/ dir.z;\n        hit_p = w_p + ref_dir * t;\n        res = shade_bg(w_p, hit_p);\n    }\n    return res.xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float w = water(uv);\n    \n    vec3 color = trace(uv);\n    \n    //vec3 color = mix(color1, color2, w);\n\n    fragColor = vec4(color, 1);//+ bg;\n} ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 bg = vec3(0,0.8,1);\nconst float pi = 3.14159265359;\n\nfloat drawLine(float t){\n    return smoothstep(-0.2, 0.0, t) - smoothstep(0.0, 0.2, t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = clamp(drawLine(sin((uv.x+0.3)*pi*5.)) + drawLine(sin((uv.y+0.3)*pi*5.)), 0.0, 1.0);\n    \n    \n    vec3 color = (1. - t) * bg + t * vec3(1,1,1);\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}