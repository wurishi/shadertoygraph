{"ver":"0.1","info":{"id":"lXVGR1","date":"1717315885","viewed":96,"name":"Cornell Box?","username":"uk0141","description":"My first shader (unfinished)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cornellboxraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ID_NONE -1.0\n#define ID_SPHERE 1.0\n#define ID_FLOOR 1.1\n#define ID_MIRROR 1.2\n#define ID_LIGHT 1.3\n#define ID_LEFTWALL 1.4\n#define ID_RIGHTWALL 1.5\n#define ID_BACKWALL 1.6\n#define TMIN 0.01\n#define TMAX 5000.0\n#define param vec4(1., 4.2, 20., 3.)\n#define EPS 0.0001\n#define ITR 128\n#define lightPos vec3(5.*cos(iTime), 6.*iMouse.y/iResolution.y, 5.*sin(iTime))\n\n\n// primitives\n// sdBox\nfloat sdBox(in vec3 p, in vec3 box) {\n   vec3 d = abs(p) - box;\n   return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sdSphere\nfloat sdSphere(vec3 p, float s) {\n   return length(p) - s;\n}\n\n// distance function hub\nvec2 intersect(vec3 p){\n\tvec2 res = vec2(ID_NONE, 2000.0);\n\n\t// light sphere\n\tvec2 obj = vec2(ID_LIGHT, sdSphere(p - lightPos, 0.05));\n\tif(obj.y < res.y) res = obj;\n\n\t// red sphere\n\tobj = vec2(ID_SPHERE, sdSphere(p - vec3(-2.5, 0.0, 0.0), 2.0));\n\tif(obj.y < res.y) res = obj;\n\n\t// mirror sphere\n\tobj = vec2(ID_MIRROR, sdSphere(p - vec3(2.5, 0.0, 0.0), 2.0));\n\tif(obj.y < res.y) res = obj;\n\n\t// floor\n\tobj = vec2(ID_FLOOR, sdBox(p - vec3(0.0, -2.0, 0.0), vec3(6.0, 0.01, 6.0)));\n\tif(obj.y < res.y) res = obj;\n\t\n\t// left wall\n\tobj = vec2(ID_LEFTWALL, sdBox(p - vec3(-6.0, 4.0, 0.0), vec3(0.01, 6.0, 6.0)));\n\tif(obj.y < res.y) res = obj;\n\n\t// right wall\n\tobj = vec2(ID_RIGHTWALL, sdBox(p - vec3(6.0, 4.0, 0.0), vec3(0.01, 6.0, 6.0)));\n\tif(obj.y < res.y) res = obj;\n\t\n\t// back wall\n\tobj = vec2(ID_BACKWALL, sdBox(p - vec3(0.0, 4.0, -6.0), vec3(6.0, 6.0, 0.01)));\n\tif(obj.y < res.y) res = obj;\n\n\treturn res;\n}\n\n// ray marching\nvec2 rayMarching(vec3 ro, vec3 rd, float tmin, float tmax){\n\tvec3 res = vec3(ID_NONE);\n\tvec3 ray = ro;\n\tfloat t = tmin;\n\tfor(int i = 0;i < ITR;i++){\n\t\tray = ro + rd*t;\n\t\tres = vec3(intersect(ray), t);\n\t\tif(res.y < EPS || t > tmax){\n\t\t\tbreak;\n\t\t}\n\t\tt += 0.7*res.y;\n\t}\n\treturn res.xz;\n}\n\n// Normal\nvec3 getNormal(vec3 p) {\n\treturn normalize(vec3(\n\tintersect(p + vec3(EPS, 0.0, 0.0)).y - intersect(p + vec3(-EPS, 0.0, 0.0)).y,\n\tintersect(p + vec3(0.0, EPS, 0.0)).y - intersect(p + vec3(0.0, -EPS, 0.0)).y,\n\tintersect(p + vec3(0.0, 0.0, EPS)).y - intersect(p + vec3(0.0, 0.0, -EPS)).y\n\t));\n}\n\n// shadow\nfloat genShadow(vec3 pos){\n\tvec2 obj = rayMarching(pos, normalize(lightPos - pos), TMIN, TMAX);\n\tif(obj.y > length(lightPos - pos)){\n\t\treturn 0.0;\n\t}else if(obj.x == ID_LIGHT){\n\t\treturn 0.0;\n\t}else{\n\t\treturn obj.y;\n\t}\n}\n// sphere color\nvec3 getSphereColor(vec2 obj, vec3 pos, vec3 rd, vec3 nor){\n\tvec3 diffuse = vec3(max(dot(nor, normalize(lightPos-pos)), 0.0));\n\tvec3 speculer = vec3(pow(max(dot(nor, normalize(lightPos-pos-rd)), 0.0), 50.));\n\tvec3 destColor = vec3(0.5, 0.0, 0.0) + diffuse + speculer;\n\t//if(genShadow(pos))destColor = vec3(0.1);\n\treturn destColor;\n}\n// floor color\nvec3 getFloorColor(vec2 obj, vec3 pos, vec3 rd, vec3 nor){\n\tvec3 diffuse = vec3(max(dot(nor, normalize(lightPos-pos)), 0.0));\n\tvec3 speculer = vec3(pow(max(dot(nor, normalize(lightPos-pos-rd)), 0.0), 50.));\n\tvec3 destColor = vec3(0.1, 0.1, 0.1) + diffuse + speculer;\n\tfloat shadow = genShadow(pos);\n\tif(shadow != 0.0)destColor *= vec3(shadow/8.0);\n\treturn destColor;\n}\n// left wall color\nvec3 getLeftWallColor(vec2 obj, vec3 pos, vec3 rd, vec3 nor){\n    float shadow = genShadow(pos);\n    vec3 destColor = vec3(0. ,0.3, 0.);\n    if(shadow == 0.){\n        vec3 diffuse = vec3(max(dot(nor, normalize(lightPos-pos)), 0.0));\n        vec3 speculer = vec3(pow(max(dot(nor, normalize(lightPos-pos-rd)), 0.0), 50.));\n        destColor = vec3(0.0, 0.3, 0.0) + diffuse/(length(lightPos-pos) + 2.) + speculer;\n    }\n\tif(shadow != 0.0)destColor *= vec3(shadow/8.0);\n\treturn destColor;\n}\n// right wall color\nvec3 getRightWallColor(vec2 obj, vec3 pos, vec3 rd, vec3 nor){\n\tfloat shadow = genShadow(pos);\n    vec3 destColor = vec3(0.3, 0.0, 0.0);    \n    if(shadow == 0.){\n        vec3 diffuse = vec3(max(dot(nor, normalize(lightPos-pos)), 0.0));\n        vec3 speculer = vec3(pow(max(dot(nor, normalize(lightPos-pos-rd)), 0.0), 50.));\n        destColor = vec3(0.3, 0.0, 0.0) + diffuse/(length(lightPos-pos) + 2.) + speculer;\n    }\n\tif(shadow != 0.0)destColor*=vec3(shadow/8.0);\n\treturn destColor;\n}\n// back wall color\nvec3 getBackWallColor(vec2 obj, vec3 pos, vec3 rd, vec3 nor){\n\tvec3 diffuse = vec3(max(dot(nor, normalize(lightPos-pos)), 0.0));\n\tvec3 speculer = vec3(pow(max(dot(nor, normalize(lightPos-pos-rd)), 0.0), 50.));\n\tvec3 destColor = vec3(0.0, 0.0, 0.3) + diffuse/(length(lightPos-pos) + 2.) + speculer;\n\tfloat shadow = genShadow(pos);\n\tif(shadow != 0.0)destColor *= vec3(shadow/8.0);\n\treturn destColor;\n}\n\n// mirror sphere color\nvec3 getMirrorSphereColor(vec2 obj, vec3 pos, vec3 rd, vec3 nor){\n\tvec3 diffuse = vec3(max(dot(nor, normalize(lightPos-pos)), 0.0));\n\tvec3 speculer = vec3(pow(max(dot(nor, normalize(lightPos-pos-rd)), 0.0), 50.));\n\t// reflect\n\tvec3 refrd = reflect(rd, nor);\n\tvec2 refObject = rayMarching(pos, refrd, TMIN, TMAX);\n\tvec3 refpos = pos + refrd*refObject.y;\n\tvec3 refnor = getNormal(refpos);\n\tvec3 reflectColor;\n\tif(refObject.x == ID_SPHERE)reflectColor = getSphereColor(refObject, refpos, refrd, refpos);\n\telse if(refObject.x == ID_FLOOR)reflectColor = getFloorColor(refObject, refpos, refrd, refnor);\n\telse if(refObject.x == ID_LEFTWALL)reflectColor = getLeftWallColor(refObject, refpos, refrd, refnor);\n\telse if(refObject.x == ID_RIGHTWALL)reflectColor = getRightWallColor(refObject, refpos, refrd, refnor);\n\telse if(refObject.x == ID_BACKWALL)reflectColor = getBackWallColor(refObject, refpos, refrd, refnor);\n\telse reflectColor = vec3(0.0);\n\tvec3 destColor = reflectColor + diffuse + speculer;\n\t//if(genShadow(pos))destColor = vec3(0.1);\n\treturn destColor;\n}\n\nvec3 postGlow(vec3 ro, vec3 rd){\n\tvec3 destColor = vec3(0.0);\n\tfloat glow = 0.0;\n\tvec3 ray = ro;\n\tfloat t = TMIN;\n\tfor(int i = 0;i < ITR;i++){\n\t\tray = ro + rd*t;\n\t\tvec2 obj = intersect(ray);\n\t\tif(obj.x == ID_LIGHT && obj.y < 0.2){\n\t\t\tglow += 1.0/(100.*obj.y + 15.0); // 距離に基づく光彩の減衰\n\t\t\tdestColor = vec3(glow);\n\t\t}\n\t\tif(t > TMAX)break;\n\t\tt += 0.7*obj.y;\n\t}\n\treturn destColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec3 destColor = vec3(0.0);\n\n\tvec2 p = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n\tfloat focus = 1.0 + param.x;\n\tvec3 rd = normalize(vec3(p, -focus));\n\n\tvec3 ro = vec3(0.0, param.w, param.z);\n\t\n\tvec2 obj = rayMarching(ro, rd, TMIN, TMAX);\n\n\tvec3 pos = ro + rd*obj.y;\n\tvec3 nor = getNormal(pos);\n\n\n\n\tif(obj.x == ID_SPHERE){\n\t\tdestColor = getSphereColor(obj, pos, rd, nor);\n\t}else if(obj.x == ID_FLOOR){\n\t\tdestColor = getMirrorSphereColor(obj, pos, rd, nor);\n\t}else if(obj.x == ID_MIRROR){\n\t\tdestColor = getMirrorSphereColor(obj, pos, rd, nor);\n\t}else if(obj.x == ID_LIGHT){\n\t\tdestColor = vec3(1.0);\n\t}else if(obj.x == ID_LEFTWALL){\n\t\tdestColor = getLeftWallColor(obj, pos, rd, nor);\n\t}else if(obj.x == ID_RIGHTWALL){\n\t\tdestColor = getRightWallColor(obj, pos, rd, nor);\n\t}else if(obj.x == ID_BACKWALL){\n\t\tdestColor = getBackWallColor(obj, pos, rd, nor);\n\t}\n\n\tif(obj.x != ID_LIGHT)destColor += postGlow(ro, rd);\n\n\tfragColor = vec4(destColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}