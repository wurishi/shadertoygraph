{"ver":"0.1","info":{"id":"WdlyWs","date":"1585853895","viewed":3312,"name":"Voxel Cone Tracing","username":"Mathis","description":"Voxel Cone Tracing","likes":94,"published":1,"flags":48,"usePreview":1,"tags":["global","illumination","light","voxel","cone","tracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFeatures:\n    64*40*64 resolution\n    Clamped sampling of voxel-mipmaps (avoids ugly artifacts)\n    Temporal mipmaps and better storage\n*/\n\nvec3 acesFilm(vec3 x) {\n    //Aces film curve\n    return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.,1.);\n}\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    vec3 D=vec3(UV*I512-1.,1.);\n    return texture(iChannel3,D);\n}\n\nvec4 SampleMip0(vec3 sp) {\n    sp.y=sp.y-0.5; float fy=floor(sp.y);\n    vec2 cuv1=vec2(sp.x+floor(fy*0.2)*64.,sp.z+mod(fy,5.)*64.);\n    vec2 cuv2=vec2(sp.x+floor((fy+1.)*0.2)*64.,sp.z+mod(fy+1.,5.)*64.);\n    return mix(textureCube(cuv1),\n               textureCube(cuv2),fract(sp.y));\n}\n\nvec4 SampleMip1(vec3 sp) {\n    sp.y=sp.y-0.5;\n    vec2 cuv1=vec2(sp.x+floor(sp.y)*32.,sp.z+320.);\n    return mix(textureCube(cuv1),\n               textureCube(cuv1+vec2(32.,0.)),fract(sp.y));\n}\n\nvec4 SampleMip2(vec3 sp) {\n    sp.y=sp.y-0.5;\n    vec2 cuv1=vec2(sp.x+floor(sp.y)*16.,sp.z+320.+32.);\n    return mix(textureCube(cuv1),\n               textureCube(cuv1+vec2(16.,0.)),fract(sp.y));\n}\n\nvec4 SampleMip3(vec3 sp) {\n    sp.y=sp.y-0.5;\n    vec2 cuv1=vec2(sp.x+floor(sp.y)*8.,sp.z+320.+48.);\n    return mix(textureCube(cuv1),\n               textureCube(cuv1+vec2(8.,0.)),fract(sp.y));\n}\n\nvec4 SampleMip4(vec3 sp) {\n    sp.y=sp.y-0.5;\n    vec2 cuv1=vec2(sp.x+floor(sp.y)*4.,sp.z+320.+56.);\n    return mix(textureCube(cuv1),\n               textureCube(cuv1+vec2(4.,0.)),fract(sp.y));\n}\n\nvec4 SampleMip5(vec3 sp) {\n    sp.y=sp.y-0.5;\n    vec2 cuv1=vec2(sp.x+floor(sp.y)*4.,sp.z+320.+60.);\n    return mix(textureCube(cuv1),\n               textureCube(cuv1+vec2(2.,0.)),fract(sp.y));\n}\n\nvec4 VoxelFetch60NC(vec3 p, float Lod) {\n    if (Lod<0.5)\n        return SampleMip0(clamp(p,vec3(0.5),vec3(63.5,44.5,63.5)));\n    else if (Lod<1.5)\n        return SampleMip1(clamp(p*0.5,vec3(0.5),vec3(31.5,44.5,31.5)));\n    else if (Lod<2.5)\n        return SampleMip2(clamp(p*0.25,vec3(0.5),vec3(15.5,44.5,15.5)));\n    else if (Lod<3.5)\n        return SampleMip3(clamp(p*0.125,vec3(0.5),vec3(7.5,44.5,7.5)));\n    else if (Lod<4.5)\n        return SampleMip4(clamp(p*I16,vec3(0.5),vec3(3.5,44.5,3.5)));\n    else\n        return SampleMip5(clamp(p*I32,vec3(0.5),vec3(1.5,44.5,1.5)));\n}\n\nvec4 VoxelFetch60(vec3 p, float Lod) {\n    if (Lod<0.5)\n        return SampleMip0(clamp(p,vec3(0.5),vec3(63.5,44.5,63.5)))\n        \t*(clamp(2.-Box(p-vec3(0.5),vec3(63.5,44.5,63.5))*2.,0.,1.));\n    else if (Lod<1.5)\n        return SampleMip1(clamp(p*0.5,vec3(0.5),vec3(31.5,44.5,31.5)))\n        \t*(clamp(2.-Box(p*0.5-vec3(0.5),vec3(31.5,44.5,31.5))*2.,0.,1.));\n    else if (Lod<2.5)\n        return SampleMip2(clamp(p*0.25,vec3(0.5),vec3(15.5,44.5,15.5)))\n        \t*(clamp(2.-Box(p*0.25-vec3(0.5),vec3(15.5,44.5,15.5))*2.,0.,1.));\n    else if (Lod<3.5)\n        return SampleMip3(clamp(p*0.125,vec3(0.5),vec3(7.5,44.5,7.5)))\n        \t*(clamp(2.-Box(p*0.125-vec3(0.5),vec3(7.5,44.5,7.5))*2.,0.,1.));\n    else if (Lod<4.5)\n        return SampleMip4(clamp(p*I16,vec3(0.5),vec3(3.5,44.5,3.5)))\n    \t\t*(clamp(2.-Box(p*I16-vec3(0.5),vec3(3.5,44.5,3.5))*2.,0.,1.));\n    else\n        return SampleMip5(clamp(p*I32,vec3(0.5),vec3(1.5,44.5,1.5)))\n    \t\t*(clamp(2.-Box(p*I32-vec3(0.5),vec3(1.5,44.5,1.5))*2.,0.,1.));\n}\n\nvec4 VoxelFetch(vec3 p, float Lod) {\n    if (Lod<1.) return mix(VoxelFetch60(p,0.),VoxelFetch60(p,1.),Lod);\n    else if (Lod<2.) return mix(VoxelFetch60(p,1.),VoxelFetch60(p,2.),Lod-1.);\n    else if (Lod<3.) return mix(VoxelFetch60(p,2.),VoxelFetch60(p,3.),Lod-2.);\n    else if (Lod<4.) return mix(VoxelFetch60(p,3.),VoxelFetch60(p,4.),Lod-3.);\n    else if (Lod<5.) return mix(VoxelFetch60(p,4.),VoxelFetch60(p,5.),Lod-4.);\n    else return VoxelFetch60(p,5.);\n}\n\nvec4 Cone(vec3 p, vec3 d, float CR, float Start) {\n    vec4 Light=vec4(0.);\n    vec3 sp; float t=Start;\n    float sD,Lod; vec4 sC;\n    for (int i=0; i<58; i++) {\n        sp=p+d*t;\n        sD=max(1.,t*CR); Lod=log2(sD);\n        sC=VoxelFetch(sp,Lod);\n        Light+=sC*(1.-Light.w);\n        t+=sD;\n    }\n    return Light+vec4(vec3(0.1,0.3,0.5)*((d.y*0.5+0.5)*(1.-Light.w))*0.5,0.);\n}\n\nvec4 Cone60(vec3 p, vec3 d) {\n    vec4 Light=vec4(0.);\n    vec3 sp; float t=1.; float sD=1.; float Lod=0.;\n    for (int i=0; i<7; i++) {\n        sp=p+d*t;\n        Light+=VoxelFetch60(sp,Lod)*(1.-Light.w);\n        t+=sD; sD*=2.; Lod+=1.;\n    }\n    return Light+vec4(vec3(0.1,0.3,0.5)*((d.y*0.5+0.5)*(1.-Light.w))*0.25,0.);\n}\n\n\n//####\n//\t50 voxlar i höjd för mipmap0\n//\t\tmipmap1 har 20*2=40 voxlar i höjd\n//####\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Camera\n    vec2 uv=fragCoord.xy*IRES;\n    vec3 SunDir=texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n    float Rot=-(iMouse.x*IRES.x)*3.14*3.*0.1;\n\tvec3 Pos=texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n    mat3 MM=TBN(texture(iChannel0,vec2(2.5,0.5)*IRES).xyz);\n    vec3 Dir=normalize(vec3((uv*2.-1.)*(ASPECT*CFOV),1.)*MM);\n\t//Trace\n    vec3 Color=vec3(0.);\n    HIT Pixel;\n    if (TraceRay(Pos,Dir,Pixel,iTime)) {\n        if (Pixel.Mat==2.) {\n            //Emissive\n            Color=Pixel.C;\n        } else if (Pixel.Mat<1.) {\n            //Specular\n            Color=Cone(Pixel.P*8.+Pixel.N,reflect(Dir,Pixel.N),Pixel.Mat,\n                       texture(iChannel2,uv).x).xyz;\n            Color=Color*Pixel.C;\n        } else {\n            //Diffuse\n            vec3 HP=Pixel.P*8.+Pixel.N*0.5;\n            mat3 MM=TBN(Pixel.N);\n            Color+=(Cone60(HP,Pixel.N).xyz\n                    +Cone60(HP,vec3(0.707,0.,0.707)*MM).xyz*0.7\n                    +Cone60(HP,vec3(-0.707,0.,0.707)*MM).xyz*0.7\n                    +Cone60(HP,vec3(0.,0.707,0.707)*MM).xyz*0.7\n                    +Cone60(HP,vec3(0.,-0.707,0.707)*MM).xyz*0.7)*0.2;\n            Color=Color*Pixel.C;\n        }\n    } else {\n        Color=(1.-Dir.y*0.5)*vec3(0.1,0.3,0.5)*0.5;\n    }\n    //Exp color space\n    Color=acesFilm(Color);\n    //Return\n    fragColor=vec4(pow(Color,vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float FOV=0.9; //In radians\nconst float VoxelSize=0.125;\n//Constants\nconst float I16=1./16.;\nconst float I32=1./32.;\nconst float I64=1./64.;\nconst float I512=1./512.;\nconst float PI=3.14159265;\nconst vec2 eps=vec2(0.001,0.);\nconst float CFOV=tan(FOV);\n#define IRES 1./iResolution.xy\n#define ASPECT vec2(iResolution.x/iResolution.y,1.)\n//Structs\nstruct DF { float D; vec3 C; float Mat; }; //Mat 0-1 Mirror-Diffuse, 2=Emissive\nstruct HIT { float D; vec3 P; vec3 N; vec3 C; float Mat; };\nvec3 ConeDirections[16]=vec3[16](\n vec3(0.5773502691896258,0.5773502691896258,0.5773502691896258)\n,vec3(0.5773502691896258,-0.5773502691896258,-0.5773502691896258)\n,vec3(-0.5773502691896258,0.5773502691896258,-0.5773502691896258)\n,vec3(-0.5773502691896258,-0.5773502691896258,0.5773502691896258)\n,vec3(-0.9030073291598593,-0.1826964031330545,-0.3888441690006706)\n,vec3(-0.9030073291598593,0.1826964031330545,0.3888441690006706)\n,vec3(0.9030073291598593,-0.1826964031330545,0.3888441690006706)\n,vec3(0.9030073291598593,0.1826964031330545,-0.3888441690006706)\n,vec3(-0.3888441690006706,-0.9030073291598593,-0.1826964031330545)\n,vec3(0.3888441690006706,-0.9030073291598593,0.1826964031330545)\n,vec3(0.3888441690006706,0.9030073291598593,-0.1826964031330545)\n,vec3(-0.3888441690006706,0.9030073291598593,0.1826964031330545)\n,vec3(-0.1826964031330545,-0.3888441690006706,-0.9030073291598593)\n,vec3(0.1826964031330545,0.3888441690006706,-0.9030073291598593)\n,vec3(-0.1826964031330545,0.3888441690006706,0.9030073291598593)\n,vec3(0.1826964031330545,-0.3888441690006706,0.9030073291598593));\n\n  \nfloat Box(vec3 p, vec3 b) {\n    vec3 d=abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat BoxC(vec3 p, vec3 b) {\n    vec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c=cos(ang), s=sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nfloat RotatedBox(vec3 p, vec3 b, float rz, float rx) {\n    vec3 pp=p;\n    pp.xy=Rotate(p.xy,rz);\n    pp.yz=Rotate(pp.yz,rx);\n    return BoxC(pp,b);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang=2.*3.14159/n;\n    float sector=floor(atan(p.x,p.y)/ang+0.5);\n    p=Rotate(p,sector*ang);\n    return p;\n}\n\nfloat Plane(vec3 p, vec3 n, float offs) {\n\treturn dot(p,n)-offs;\n}\n\nfloat Line(vec3 p, vec3 a, vec3 b) {\n    vec3 ba=b-a;\n    float k=dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat SMIN(float a, float b, float k) {\n    float h=clamp(0.5+0.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvoid MIN(inout DF df, DF a) {\n    if (a.D<=df.D) df=a;\n}\n\nDF SDF(vec3 p, float Time) {\n    DF df=DF(p.y-0.25,vec3(1.),1.);\n    //Emissive plane\n    vec3 ep=p; ep.yz=Rotate(ep.yz,Time*0.78*0.+0.78);\n    MIN(df,DF(Box(p,vec3(0.125,5.,8.)),vec3(1.+mod(floor(ep.y)+floor(ep.z),2.)*2.)*vec3(0.4,1.,0.4)*1.5\n              ,mod(floor(ep.y)+floor(ep.z),2.)+1.));\n    \n    //Diffuse plane\n    MIN(df,DF(Box(p-vec3(0.,0.,7.75),vec3(8.,5.,0.25)),vec3(1.),1.));\n    \tMIN(df,DF(Box(p-vec3(2.5,2.,6.),vec3(2.,2.,2.)),vec3(1.),1.)); //Box på vägg\n    //Låg roterande emissive object\n    vec3 rp=p; rp.xz=Rotate(rp.xz-vec2(4.,4.),Time*0.75);\n    MIN(df,DF(max(BoxC(rp,vec3(2.,1.,2.)),-BoxC(rp,vec3(1.5,8.,1.5))),vec3(1.,0.25,0.2)*4.,2.));\n    \n    //Modulation\n    vec3 mp=p*12.;\n    df.D+=(sin(mp.x)*sin(mp.y)*sin(mp.z))*0.015;\n    \n    //Spheres\n    MIN(df,DF(length(vec3(fract(p.x)-0.5,p.y-0.55,fract(p.z)-0.5))-0.3,vec3(1.),\n             ((mod(floor(p.x)+floor(p.z),2.)==1.)?1.:0.2)));\n    //Glossy plane\n    MIN(df,DF(Box(p,vec3(8.,5.,0.25)),vec3(1.),((mod(floor(p.y*1.)+floor(p.x*1.),2.)==1.)?0.1:0.25)));\n    \n    //Return\n\treturn df;\n}\n\nvec3 Gradient(vec3 p, float t) {\n    return normalize(vec3(\n        SDF(p+eps.xyy,t).D-SDF(p-eps.xyy,t).D,\n        SDF(p+eps.yxy,t).D-SDF(p-eps.yxy,t).D,\n        SDF(p+eps.yyx,t).D-SDF(p-eps.yyx,t).D));\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O=normalize(cross(N,vec3(0.,1.,0.)));\n    return normalize(cross(O,N));\n}\n\nfloat boxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t2=max(tMin,tMax);\n    return min(min(t2.x,t2.y),t2.z);\n}\n\nvec2 box(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t1=min(tMin,tMax);\n    vec3 t2=max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nfloat boxfar2(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin=(bmin-origin)*dir;\n    vec2 tMax=(bmax-origin)*dir;\n    vec2 t2=max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nbool TraceRay(vec3 pos, vec3 dir, out HIT R, float Time) {\n    DF t; float dist=0.; R.P=pos;\n    float FAR;\n    if (pos.x>0. && pos.x<8. && pos.z>0. && pos.z<8.) {\n    \tFAR=boxfar(pos,1./dir,vec3(0.),vec3(8.));\n    } else {\n        vec2 BB=box(pos,1./dir,vec3(0.),vec3(8.));\n        if (BB.x>0. && BB.y>BB.x) {\n            FAR=BB.y;\n            dist=BB.x;\n        } else\n            return false;\n    }\n    for (int i=0; i<128; i++) {\n        if (dist>FAR) break;\n        R.P=pos+dir*dist;\n        t=SDF(R.P,Time);\n        if (t.D<eps.x) {\n\t\t\tR.D=dist;\n            R.N=Gradient(R.P,Time);\n            R.C=t.C;\n            R.Mat=t.Mat;\n            return true;\n        }\n        dist=dist+t.D;\n    }\n\treturn false;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 Color=texture(iChannel0,fragCoord.xy/iResolution.xy);\n    vec2 fragFloor=floor(fragCoord);\n    if (iFrame==0) { //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Color=vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Color=vec4(-0.5,-1.5,-0.5,-1.5); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Color=vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Color=vec4(7.9,4.,3.9,1.); //Player Pos\n            else if (fragCoord.x<5.) Color=vec4(0.7,0.,0.,1.); //Sun angles\n            else if (fragCoord.x<6.) Color=vec4(0.,0.,0.,1.); //Sun vector\n        }\n    } else { //Update\n\t\tif (fragCoord.x<10. && fragCoord.y<1.) { //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) { //Börjat klicka\n                    if (Color.w==0.) {\n                    \tColor.w=1.;\n                    \tColor.xy=iMouse.zw;\n                    }\n                } else Color.w=0.;\n            } else if (fragCoord.x<2.) { //Player Eye (Angles)\n                vec4 LMouse=texture(iChannel0,vec2(0.5,0.5)*IRES);\n                if (LMouse.w==0.)  Color.zw=Color.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tColor.x=Color.z+(iMouse.y-LMouse.y)*0.01;\n                \tColor.x=clamp(Color.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tColor.y=Color.w-(iMouse.x-LMouse.x)*0.02;\n               \t\tColor.y=mod(Color.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) { //Player Eye (Vector)\n                vec3 Angles=texture(iChannel0,vec2(1.5,0.5)*IRES).xyz;\n                Color.xyz=normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) { //Player Pos\n                float Speed=iTimeDelta;\n                \tif (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed=8.*iTimeDelta;\n                vec3 Eye=texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Color.xyz+=Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Color.xyz-=Eye*Speed; //S\n                vec3 Tan=normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Color.xyz-=Tan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Color.xyz+=Tan*Speed; //D\n            } else if (fragCoord.x<5.) { //Sun angle\n                if (texelFetch(iChannel1,ivec2(188,0),0).x>0.) Color.y+=0.02;\n                if (texelFetch(iChannel1,ivec2(190,0),0).x>0.) Color.y-=0.02;\n            } else if (fragCoord.x<6.) { //Sun direction\n                vec2 Angles=texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n                Color=vec4(normalize(vec3(cos(Angles.y)*cos(Angles.x)\n                \t,sin(Angles.x),sin(Angles.y)*cos(Angles.x))),1.);\n            }\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//Voxels\n\nconst float YLimit2=32.+16.+8.+4.+2.+1.;\nconst float YOffset[5]=float[5](0.,32.,48.,56.,60.);\nconst float FetchSize[5]=float[5](16.,8.,4.,2.,1.);\n\nbool SS(vec3 sp) { //Sample Scene\n    return SDF(sp*(I64*8.),iTime).D<I16;\n}\n\nfloat VTrace(vec3 p, vec3 d) {\n    vec3 sp;\n    for (float i=0.; i<46.; i++) {\n        sp=p+d*i;\n        if (sp.x<0.5 || sp.x>63.5 || sp.z<0.5 || sp.z>63.5 || sp.y<0.5 || sp.y>31.5) break;\n        if (SS(sp)) return 0.;\n    }\n    return 1.;\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output=vec4(0.);\n    vec2 UV; vec3 aDir=abs(rayDir);\n    if (aDir.z>max(aDir.x,aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.z>0.) {\n            //Positive z-side\n            if (UV.y<320.) {\n                //LOD 0\n                vec2 fragFloor=floor(UV);\n                vec3 Pos=vec3(mod(fragFloor.x,64.),\n                            floor(fragFloor.y*I64)+floor(fragFloor.x*I64)*5.,\n                            mod(fragFloor.y,64.))+0.5;\n                DF Sample=SDF(Pos*(I64*8.),iTime);\n                if (Sample.D<I16) {\n                    //Voxel exists\n                    float Weight=min(0.9999,(1.-Sample.D/I16));\n                    if (Sample.Mat>1.5) {\n                        //Emissive\n                        Output.xyz=Sample.C;\n                    } else {\n                        //Diffuse or glossy\n                    }\n                    Output=vec4(Output.xyz*Weight,Weight);\n                }\n            }\n            if (UV.y>320. && UV.y<384.) {\n                vec2 fragFloor=floor(vec2(UV.x,UV.y-320.));\n                if (fragFloor.y<32.) {\n                    //MipMap1 samplar MipMap0 direkt\n                    float lody=floor(fragFloor.x*I32)*2.;\n                    vec2 Offset1=vec2(floor(lody*0.2)*64.,mod(lody,5.)*64.);\n                    vec2 Offset2=vec2(floor((lody+1.)*0.2)*64.,mod(lody+1.,5.)*64.);\n                    vec2 fuv=mod(fragFloor,32.);\n                    Output=(texture(iChannel3,vec3((fuv*2.+1.+Offset1)*I512-1.,1.))+\n                           texture(iChannel3,vec3((fuv*2.+1.+Offset2)*I512-1.,1.)))*0.5;\n                } else if (fragFloor.y<YLimit2) {\n                    //Temporal, samplar denna buffer\n                    int Index=int(4.-floor(log2(YLimit2-fragFloor.y)));\n                    float Size=FetchSize[Index];\n                    float ISize=1./Size;\n                    vec2 Offset=vec2(floor(fragFloor.x*ISize)*2.*(Size*2.),\n                                     320.+YOffset[Index]);\n                    vec2 fuv=mod(fragFloor,Size);\n                    Output=(texture(iChannel3,vec3((fuv*2.+1.+Offset)*I512-1.,1.))+\n                           texture(iChannel3,vec3((fuv*2.+1.+Offset+vec2(Size*2.,0.))*I512-1.,1.)))*0.5;\n                }\n            }\n        }\n    }\n    fragColor=Output;\n}","name":"Cube A","description":"","type":"cubemap"}]}