{"ver":"0.1","info":{"id":"MttSz2","date":"1480705142","viewed":206,"name":"#Devember 2016 - day 01","username":"theGiallo","description":"Experimenting on textures, animation and cylinders.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learning","cylinder","devember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = vec4(0);\n    \n    vec2 cp;\n  #if 0\n    cp = p / pow( length( p ), 2.0 );\n  #else\n    float ap;\n    ap = iTime * 0.1 * ( 1.0 + 0.01 * length( p ) );\n    vec2 dp = p + vec2(cos(ap),sin(ap))* 0.1;\n    float a = atan(dp.y, dp.x );\n    cp = vec2(cos(a), sin(a))/length(dp);\n    a -= iTime;\n    a = mod(a, TAU) * 4.0;\n    float l = length( dp * ( 0.7 + 0.5 + 0.5 * sin ( iTime * 0.1 ) ) );\n    cp.y = 1.0 / l + iTime * 0.1;\n    cp.x = a / TAU - ( cp.y * 0.3 );\n    //cp.y *= 0.1 + 0.9 * ( 0.5 + 0.5 * sin( iTime * 0.03 ) );\n  #endif\n    \n    col = texture( iChannel1, cp ) * clamp(log(1.0+l)*0.7/(l*l),0.0,1.0);\n    float b = 8.0;\n    vec4 fog_color = vec4(1.0,0.9,0.7,1.0);\n    col = col*(1.0-exp(-l*b)) + fog_color*exp(-l*b);\n    \n    vec4 c;\n  #if 0\n    c = square_tex( vec4(0.1,0.4,0.7,1.0), vec2(-0.75,0.5), 0.15, 0.01, iTime * 0.1, p, iChannel0 );\n    blend_pma( col, c );\n    \n    c = square( vec4(0.1,0.4,0.7,1.0), vec2(0.75 + 0.3 * SQRT2 * sin( iTime ),0.5), 0.15, 0.01, 0.0, p );\n    blend_pma( col, c );\n    \n    c = circle( vec4(0.1,0.6,0.0,0.5 + 0.5 * sin( 3.0 * iTime )), vec2(0.75,0.5), 0.15, 0.1, p );\n    blend_pma( col, c );\n    \n    \n    vec2 distorted_p = p;\n    float sx = 0.5 + 0.5 * sin( 4.0 * TAU * p.x );\n    distorted_p.x *= 1.0 + sx * 0.2;\n    float sy = 0.5 + 0.5 * sin( 4.0 * TAU * p.y );\n    distorted_p.y *= 1.0 + sy * 0.2;\n    float s = length( vec2(sx, sy) ) / SQRT2;\n    c = square_tex(\n       vec4(0.4,0.7,1.0, pow(0.4+0.6*s,2.0)),\n       vec2(0.0 + 0.5 * sin( iTime * 0.5 * QPI ),-0.2),\n       0.4, 0.01, iTime * QPI, distorted_p, iChannel0 );\n    blend_pma( col, c );\n  #endif\n    \n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"}]}