{"ver":"0.1","info":{"id":"tt2XRh","date":"1724138107","viewed":15,"name":"ray marching sine terrain","username":"mrwen33","description":"ray marching learning","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nvec3 getCameraRay(vec2 uv, vec3 pos, vec3 front, vec3 right, vec3 up){\n\tfloat angle = 90.0;\n    float halfArc = angle/360.0*PI;\n    float portWidth = tan(halfArc);\n    vec3 rayDir = normalize(front+right*uv.x*portWidth+up*uv.y*portWidth);\n    return rayDir;\n}\n\nfloat height(vec2 p){\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat height(float x, float z){\n\treturn height(vec2(x,z));\n}\n\nvec3 rotateY(vec3 direction, float angle){\n\tfloat cosx = cos(angle);\n    float sinx = sin(angle);\n    mat3x3 rotateMat = mat3x3(\n    \tvec3(cosx,0.0,-sinx),\n        vec3(0.0,1.0,0.0),\n        vec3(sinx, 0.0, cosx)\n    );\n    return rotateMat*direction;\n} \n\nfloat castLight(vec3 ro, vec3 rd,float minDist, float maxDist){\n\tfloat stepDist = 0.01;\n    vec3 rayStep = stepDist*rd;\n    vec3 curPos = ro+minDist*rd;\n    vec3 lastPos = curPos;\n    for(float dist=minDist;dist<maxDist;dist+=stepDist){\n    \tcurPos=ro+dist*rd;\n        float y = curPos.y;\n        float h = height(curPos.xz);\n        if(y<h){\n            //interplot\n            float lasty = lastPos.y;\n            float lasth = height(lastPos.xz);\n            float intDist = dist-stepDist+stepDist*(lasty-lasth)/(lasty-lasth+h-y);\n        \treturn intDist;\n        }\n        stepDist = 0.01*(maxDist-dist+0.01);\n        lastPos = curPos;\n    }\n    return maxDist;\n}\n\nfloat castRay(vec3 ro, vec3 rd,float minDist, float maxDist){\n\tfloat stepDist = 0.01;\n    vec3 rayStep = stepDist*rd;\n    vec3 curPos = ro+minDist*rd;\n    vec3 lastPos = curPos;\n    for(float dist=minDist;dist<maxDist;dist+=stepDist){\n    \tcurPos=ro+dist*rd;\n        float y = curPos.y;\n        float h = height(curPos.xz);\n        if(y<h){\n            float lasty = lastPos.y;\n            float lasth = height(lastPos.xz);\n            float intDist = dist-stepDist+stepDist*(lasty-lasth)/(lasty-lasth+h-y);\n        \treturn intDist;\n        }\n        stepDist = 0.01*dist;\n        lastPos = curPos;\n    }\n    return maxDist;\n}\n\nfloat castShadow(vec3 lightPos, vec3 worldPos){\n\tfloat dt = 0.01;\n    vec3 ldir = normalize(worldPos-lightPos);\n    float maxDist = length(worldPos-lightPos);\n    float d = castRay(lightPos, ldir, 0.01, maxDist+0.1);\n    float distToPoint = maxDist-d;\n    if(d==100.0)return 0.0;\n    return smoothstep(0.2, 1.0, distToPoint);\n}\n\nvec3 getAlbedo(vec3 p){\n\treturn vec3(1.0);\n}\n\nvec3 getSpecularColor(vec3 p){\n\treturn vec3(0.3);\n}\n\nvec3 getLightPos(){\n\treturn vec3(10.0,7.0,10.0);\n}\n\nfloat getShadow(vec3 worldPos){\n    \n\tfloat shadowVal = castShadow(getLightPos(), worldPos);\n    return 1.0-shadowVal*0.95;\n}\n\nvec3 getNormal(vec3 p){\n\tfloat eps = 0.001;\n    return normalize(vec3(height(p.x-eps,p.z)-height(p.x+eps,p.z), 2.0*eps, height(p.x, p.z-eps)-height(p.x, p.z+eps)));\n}\n\nfloat getDiffuse(vec3 p, vec3 n, vec3 ld){\n   \treturn max(0.0, dot(ld, n));\n}\n\nfloat getSpecular(vec3 p, vec3 n, vec3 ld, vec3 vd, float shininess){\n\tvec3 halfDir = normalize(ld+vd);\n    return pow(max(0.0, dot(halfDir, n)), shininess);\n}\n\nfloat getAmbient(){\n\treturn 0.05;\n}\n\nvec3 getColor(vec3 p, vec3 camPos){\n\tvec3 normal = getNormal(p);\n    vec3 lightPos = getLightPos();\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 viewDir = normalize(camPos - p);\n    return (getAmbient()+getDiffuse(p, normal, lightDir))*getAlbedo(p)+getSpecular(p, normal, lightDir, viewDir, 32.0)*getSpecularColor(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = 2.0*(uv - vec2(0.5, 0.5));\n    vec3 ro = vec3(0.0,8.0,0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 front = normalize(vec3(0.0, -0.8, -1.0));\n    front = rotateY(front, iTime*0.1);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    float maxDist = 100.0;\n    float minDist = 0.01;\n    \n    vec3 rayDir = getCameraRay(uv, ro, front, right, up);\n    float d = castRay(ro, rayDir, minDist, maxDist);\n    vec3 point = ro+rayDir*d;\n    vec3 c = vec3(0);\n    if(d < maxDist){\n    \tc = getColor(point, ro)*getShadow(point);\n    }\n    //gamma\n    c = pow(c, vec3(0.4545));\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}