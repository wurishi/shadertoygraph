{"ver":"0.1","info":{"id":"mstyDf","date":"1695623592","viewed":56,"name":"a sphere from the underground","username":"Efim","description":"in this shader for smooth intersection sphere and plane using torus","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","torus","intersection","plane","analyticall","shpere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TAU 6.28318530718\n#define nn 60.0\nconst float  eps = 2.9;\nconst float dist_infin = 1000.0;\nconst float ngrid = 60.0;\nconst float rr = 3.;\nconst float dt = 3.;\n#define AA 2\n\n\nstruct HIT\n{\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\n\nconst HIT hit_inf = HIT(dist_infin, vec3(0.0), vec3(dist_infin));\n\n\nvec3 ccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light1, vec3 light2, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    nor *= -sign(d);\n    float difu1 = dot(nor, light1);\n    float difu2 = dot(nor, light2);\n    float difu = max(difu1, difu2);\n        col *= clamp(difu, 0.4, 1.0);\n    return col;   \n}\n\n\n//===================https://www.shadertoy.com/view/wsXGWS======================\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = vec2(x1,x2);\n  return 2;\n}\n\nint quadratic(vec3 coeffs, out vec2 res) {\n  return quadratic(coeffs[0],coeffs[1],coeffs[2],res);\n}\n\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint cubic(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      for (int i = 0; i < 6; i++) {\n        X = x0;\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        x0 -= (q/dq);\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\nint cubic(vec4 coeffs, out vec3 res) {\n  float A = coeffs[0], B = coeffs[1], C = coeffs[2], D = coeffs[3];\n  return cubic(A,B,C,D,res);\n}\n\n\nfloat qcubic(float a, float b, float c) {\n  if (c == 0.0) return 0.0;\n  \n  vec3 res;\n  int nroots = cubic(1.0,a,b,c,res);\n  if (nroots == 1) return res.x;\n  else return max(res.x,max(res.y,res.z));\n}\n\nint quartic(vec4 coeffs, out vec4 res) {\n  float c1 = coeffs[0];\n  float c2 = coeffs[1];\n  float c3 = coeffs[2];\n  float c4 = coeffs[3];\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int resn = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    resn += 2;\n  }\n  return resn;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  vec4 coeffs = vec4(B,C,D,E)/A;\n  nroots = quartic(coeffs,roots);\n  return nroots;\n}\n//https://www.shadertoy.com/view/wsXGWS\n\n\nmat3 rotateX(float f)\n{\n    return mat3(vec3(1.0,    0.0,      0.0), vec3(0.0,\t cos(f),  -sin(f)), \tvec3(.0, sin(f), cos(f)));\n}\n\nmat3 rotateY(float f)\n{\n    return mat3(vec3(cos(f), 0.0,  sin(f)),vec3(0.0,\t 1.0,  0.0),vec3(-sin(f), 0.0, cos(f)));\n}\n\nmat3 rotateZ(float f)\n{\n    return mat3(vec3(cos(f),    -sin(f),  0.0),vec3(sin(f),\t cos(f),  0.0), \tvec3(0.0, 0.0, 1.0));\n}\n\n\n\nHIT plane(vec3 ro, vec3 rd, vec3 po, vec3 nor)\n{\n    float t = dot(nor, (po - ro)) / dot(nor, rd);\n    if (t < 0.0)\n        return hit_inf;\n    vec3 pos = ro + t*rd;\n    return HIT(t, nor, pos);    \n    \n}\n\n// df(x)/dx\n//analitic function https://www.shadertoy.com/view/4sBGDy\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n\n\nHIT tor(vec3 ro, vec3 rd, float x0, float y0, float r, float R, float w, float h, float sh)\n{\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n\n    float dist = dist_infin;\n    float a = ro.x-x0;\n    float b = rd.x;\n    float c = ro.y-y0;\n    float d = rd.y;\n    float e = ro.z-r;\n    float f = rd.z;\n    float a22 = a*a;\n    float b22 = b*b;\n    float c22 = c*c;\n    float d22 = d*d;\n    float e22 = e*e;\n    float f22 = f*f;\n    float a44 = a22*a22;\n    float R22 = R*R;\n    float r22 = r*r;\n\n    float a0 = a44 + 2.*a22*c22 + 2.*a22*e22-2.*R22*a22-2.*a22*r22 + c22*c22 + 2.*c22*e22-2.*R22*c22-2.*c22*r22 + e22*e22 + 2.*R22*e22-2.*e22*r22 + R22*R22-2.*R22*r22 + r22*r22;\n    float a1 = 4.*a22*a*b + 4.*a22*c*d + 4.*a22*e*f + 4.*a*b*c22 + 4.*c*c22*d + 4.*c22*e*f + 4.*a*b*e22 + 4.*c*d*e22 + 4.*e*e22*f-4.*R22*a*b-4.*R22*c*d + 4.*R22*e*f-4.*a*b*r22-4.*c*d*r22-4.*e*f*r22;\n    float a2 = 6.*a22*b22 + 2.*a22*d22 + 2.*a22*f22 + 2.*b22*c22 + 6.*c22*d22 + 2.*c22*f22 + 2.*b22*e22 + 2.*d22*e22 + 6.*e22*f22-2.*R22*b22-2.*R22*d22 + 2.*R22*f22-2.*b22*r22-2.*d22*r22-2.*f22*r22 + 8.*a*b*c*d + 8.*a*b*e*f + 8.*c*d*e*f;\n    float a3 = 4.*a*b*b22 + 4.*a*b*d22 + 4.*a*b*f22 + 4.*b22*c*d + 4.*c*d*d22 + 4.*c*d*f22 + 4.*b22*e*f + 4.*d22*e*f + 4.*e*f*f22;\n    float a4 = 1.*b22*b22 + 2.*b22*d22 + 2.*b22*f22 + d22*d22 + 2.*d22*f22 + f22*f22;\n    vec4 roots = vec4(dist_infin);\n    int nroots = quartic(a4, a3, a2, a1, a0, roots);  // quartic(a4, a3, a2, a1, a0, roots);\n    \n    for (int i = 0; i < 4; i++)\n    {\n        if (i >= nroots)\n            break;\n        if (roots[i] < 0.0)\n            continue;\n            \n        vec3 p = vec3(a, c, e) + roots[i]*rd;\n        if (abs(p.x + x0) > w || abs(p.y + y0) > h)\n            continue;\n        if (length(p.xy) > R)\n          continue;        \n        if (p.z > sh)  \n          continue;\n        if (roots[i] < dist)    \n        {\n            dist = roots[i];\n            pos = p;\n        }\n\n    }\n    if (dist < dist_infin)\n    {\n        nor = nTorus(pos, vec2(R, r));\n        nor = normalize(nor);\n        pos.x += x0;\n        pos.y += y0;\n        pos.z += r;\n        return HIT(dist , nor, pos);\n    }\n    return hit_inf;\n}\n\nHIT sphere(vec3 ro, vec3 rd, float x0, float y0, float t, float dlt, float w, float h)\n{\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n\n    float dist = dist_infin;\n    float a = ro.x-x0;\n    float b = rd.x;\n    float c = ro.y-y0;\n    float d = rd.y;\n    float e = ro.z + dlt;\n    float f = rd.z;\n\n    float a0 = 1.*a*a + 1.*c*c + 1.*e*e-1.*t*t;\n    float a1 = 2.*a*b + 2.*c*d + 2.*e*f;\n    float a2 = 1.*b*b + 1.*d*d + 1.*f*f;\n    vec2 roots = vec2(dist_infin);\n    int nroots = quadratic(a2, a1, a0, roots);  // quartic(a4, a3, a2, a1, a0, roots);\n    \n    for (int i = 0; i < 2; i++)\n    {\n        if (i >= nroots)\n            break;\n        if (roots[i] < 0.0)\n            continue;\n            \n        vec3 p = vec3(a, c, e) + roots[i]*rd;\n        if (p.z - dlt < 0.) \n            continue;\n        if (abs(p.x + x0) > w || abs(p.y + y0) > h)\n            continue;\n        \n            \n\n        if (roots[i] < dist)    \n        {\n            dist = roots[i];\n            pos = p;\n        }\n\n    }\n    if (dist < dist_infin)\n    {\n        nor = vec3(0.+2.*pos.x, 0.+2.*pos.y, 0.+2.*pos.z);\n        nor = normalize(nor);\n        pos.x += x0;\n        pos.y += y0;\n        pos.z -= dlt;\n        return HIT(dist , nor, pos);\n    }\n    return hit_inf;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n//=============================2D pic=========================\nvec3 grid_plane(vec2 uv, float n)\n{\n        vec3 col = texture(iChannel0, uv).rgb;\n        return col;\n}\n//=============================2D pic=========================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float t = iTime;\n    float w = 20.;\n    float h = 12.;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n       m = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;\n       //t = 0.;\n    }\n    \n    \n    \n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n    //ro = rotateY(-m.x*TAU)*rotateX(-m.y*PI)*ro; //camera rotation\n    mat3 rota  = rotateZ(PI/6.0);\n    mat3 rota_1  = rotateZ(-PI/6.0);\n    \n\n    vec3 ro = vec3(0.0, -10., 4.); // camera\n    vec3 light = normalize(vec3(0.0, 0., 1.0)); //light\n    //vec3 light2 = normalize(vec3(0.0, 0.0, 1.0)); //light\n    vec3 light2 = -light;\n\n    vec3 rdm = GetRayDir(m, ro, vec3(0,0.,0), fl); //ray direction mouse\n    HIT gr = plane(rota*ro, rota*rdm, vec3(0.), vec3(0., 0.0, 1.0));\n    float x0 = gr.pos.x;\n    float y0 = gr.pos.y;\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    float dlt = dt*cos(t);\n    float rseg = sqrt(rr*rr - dlt*dlt);\n    float Rtor = rseg * eps;\n    float rtor = (rr*rr - Rtor*Rtor - dlt*dlt)/(dlt - rr)/2.0;\n    float sh = -(dlt + rtor)/(rr + rtor)*rtor;\n\n    //r = (h^2 - R^2 - d^2)/(d-h)\n    \n    //antiblick\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        dist = dist_infin;\n        vec3 col = vec3(0.7, 0.7, 0.9); // background    \n        vec3 pos = vec3(0.);\n        vec3 nor = vec3(0.0);\n            // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec3 rd = GetRayDir(p, ro, vec3(0,0.,0), fl); //ray direction\n       \n        \n        HIT gr = plane(rota*ro, rota*rd, vec3(0.), vec3(0., 0.0, 1.0));\n        if (gr.dist < dist)\n        {\n            if (abs(gr.pos.x) <= w && abs(gr.pos.y) <= h)\n            if (length(gr.pos.xy - vec2(x0, y0)) > rseg)    \n            {\n                dist = gr.dist;\n                nor = gr.nor;\n            }\n        }\n        \n            \n        gr =  sphere(rota*ro, rota*rd, x0, y0, rr, dlt, w, h);\n        if (gr.dist < dist) \n        {\n            nor = gr.nor;\n            dist = gr.dist;\n        }\n        \n        gr =  tor(rota*ro, rota*rd, x0, y0, rtor, Rtor, w, h, sh);\n        if (gr.dist < dist) \n        {\n            nor = gr.nor;\n            dist = gr.dist;\n        }\n        \n        if (dist < dist_infin)\n        {\n            pos = rota*ro + rota*rd*dist;\n            col = grid_plane(0.5 + pos.xy/vec2(2.*w, 2.*h), ngrid);\n            \n            //col = mix(col, vec3(1.0, 0.0, 0.0), pst);\n            vec3 backcol = vec3(1.0, 0.0, 0.);\n\n            vec3 nor = rota_1*nor;\n            col = ccolor(col, col, -rd, light, light2, nor);\n        }\n        \n        tot += col;\n    }\n\n    //antiblick\n    tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}