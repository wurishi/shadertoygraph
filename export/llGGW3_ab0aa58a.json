{"ver":"0.1","info":{"id":"llGGW3","date":"1477040909","viewed":111,"name":"smooth blending with raymarching","username":"jcolicchio","description":"i made kind of a wonky bridge but it doesn't rotate properly","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","primitives","blending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (3.14159)\n#define FOV (75.0)\n\n#define THRESH (0.01)\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p,n.xyz)+n.w;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotateVector(vec3 vector, vec3 axis, float angle) {\n    return (vec4(vector,1)*rotationMatrix(axis, angle)).xyz;\n}\n\nvec3 cameraTransform(vec3 vector) {\n    return rotateVector(rotateVector(vector, vec3(1,0,0), PI/6.0*0.5), vec3(0,1,0), PI/8.0*iTime*1.0) + 1.0*vec3(0, cos(iTime)*80.0+100.0, -200);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nconst int sphere1 = 0;\nconst int sphere2 = 1;\nconst int sphere3 = 2;\nconst int rect1 = 3;\n\nvec2 dist(vec3 pos, out vec3 fuckyPos, out float minBox, out float minSphere, out vec3 adjusted) {\n    \n    mat4 mat = rotationMatrix(vec3(-0.3,1,0),PI/2.0*iTime);\n    \n    fuckyPos = pos;\n        \n    //rotatedPos += vec3(0,650,0);\n    //rotatedPos += vec3(0,0,-200);\n\n    vec3 spherePos = fuckyPos - vec3(300,0,400);\n    minSphere = sdSphere(spherePos,140.0);\n    float per = 0.04;\n    minSphere += sin(per*spherePos.x)*sin(per*spherePos.y)*sin(per*spherePos.z)*40.0*cos(iTime*8.0);\n    float minPlane = sdPlane(fuckyPos-vec3(0,-180,0), normalize(vec4(0,1,0,0)));\n\n\n    adjusted = (vec4(fuckyPos-vec3(140,0,250),1) * mat).rgb;\n    minBox = sdBox(adjusted, vec3(40, 40, 60));\n    adjusted = (vec4(fuckyPos-vec3(140,-50,250),1) * mat).rgb;\n    float minSphere2 = sdSphere(adjusted, 50.0);\n    minBox = opS(minSphere2, minBox);\n\n    float minBoxSphere = smin(minBox, minSphere, 64.0);\n\n    mat4 matt = rotationMatrix(vec3(0,1,0),fuckyPos.y*(0.02 + cos(iTime/1.0)*0.02));\n    adjusted = (vec4(fuckyPos-vec3(-300,-80,100),1) * matt).rgb;\n    float minTower = sdBox(adjusted, vec3(40,300,40));\n    minTower += sin(0.01*adjusted.x)*cos(0.2*adjusted.y)*cos(0.0005*adjusted.y*adjusted.x)*30.0;\n    float minDist = min(min(minTower, minBoxSphere), minPlane);\n    \n    int check = 0;\n    if(minPlane < THRESH) {\n        check = 1;\n    }\n    else if(minBoxSphere < THRESH) {\n        check = 2;\n    }\n    else if(minTower < THRESH) {\n        check = 3;\n    }\n    \n    return vec2(minDist,check);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 fuckyPos;\n    float minBox, minSphere;\n    vec3 adjusted;\n    \n\tvec3 nor = vec3(\n\t    dist(pos+eps.xyy, fuckyPos, minBox, minSphere, adjusted).x - dist(pos-eps.xyy, fuckyPos, minBox, minSphere, adjusted).x,\n\t    dist(pos+eps.yxy, fuckyPos, minBox, minSphere, adjusted).x - dist(pos-eps.yxy, fuckyPos, minBox, minSphere, adjusted).x,\n\t    dist(pos+eps.yyx, fuckyPos, minBox, minSphere, adjusted).x - dist(pos-eps.yyx, fuckyPos, minBox, minSphere, adjusted).x );\n\treturn normalize(nor);\n}\n\nvoid render(in vec3 pixel, in vec3 viewer, in vec3 viewerRay, out vec4 fragColor, out int iterCount) {\n    //pixel = rotateVector(pixel, vec3(0,1,0), PI/4.0*iTime*1.0);\n    //viewer = rotateVector(viewer, vec3(0,1,0), PI/4.0*iTime*1.0);\n    \n    //float len = length(pixel);\n    pixel = cameraTransform(pixel);\n    viewer = cameraTransform(viewer);\n    viewerRay = normalize(cameraTransform(viewerRay)-vec3(0, cos(iTime)*80.0+100.0, -200));\n    //pixel = ray*len;\n    vec3 ray = normalize(pixel-viewer);\n    vec3 pos = viewer;\n    \n    \n    //mat4 camTwist = rotationMatrix(ray, PI/64.0);\n\n    for(float i=0.0;i<150.0;i++) {\n        // to rotate a point around a ray rather than just an axis, we need to change up some stuff\n        \n        //vec3 adjPos = pos - viewer;\n        //vec3 fuckyPos = rotateVector(adjPos, viewerRay,0.001*length(pos-viewer)*0.0);\n        //fuckyPos = fuckyPos + viewer;\n        \n        vec3 fuckyPos;\n        float minBox, minSphere;\n        vec3 adjusted;\n        vec2 minDist = dist(pos, fuckyPos, minBox, minSphere, adjusted);\n        \n        pos += ray*minDist.x;\n        \n        if(minDist.x < THRESH) {\n            if(minDist.y == 1.0) {\n                vec3 texColor = texture(iChannel0, fuckyPos.xz/500.0).rgb;\n                \n                vec3 norm = calcNormal(fuckyPos);\n                \n                fragColor = vec4(texColor*(dot(norm, vec3(0,1,0))*0.5+0.5),1);\n            }\n            else if(minDist.y == 2.0) {\n                vec3 sphereColor = vec3(1,0,0);\n                vec3 bridgeColor = vec3(1,0,1);\n                vec3 blendedColor = mix(sphereColor, bridgeColor, 1.0-minBox/(minSphere+minBox));\n                \n                vec3 norm = calcNormal(fuckyPos);\n                //norm = normalize(fuckyPos - vec3(300,0,400));\n                \n                fragColor = vec4(blendedColor*(dot(norm, vec3(0,1,0))*0.5+0.5),1);\n                \n                if(minBox < minSphere) {\n                \t//fragColor = vec4(vec3(1,0.5,1)*(1.0-pos.z/550.0),1);\n                }\n                else {\n                \t//fragColor = vec4(vec3(1,1,0)*(1.0-pos.z/550.0),1);\n                }\n            }\n            else if(minDist.y == 3.0) {// we want the tower's color to have r value based on x location\n                \n                vec3 norm = calcNormal(fuckyPos);\n                \n                vec3 posRelativeToBox = adjusted;\n                fragColor = vec4(vec3(abs(posRelativeToBox.x/40.0),abs(posRelativeToBox.z/40.0),1)*(dot(norm, vec3(0,1,0))*0.5+0.5),1);\n            }\n            //fragColor = vec4(vec3(1)*dot(pos-viewer, ray)/6000.0,1);\n            break;\n        }\n    \titerCount = int(i);\n    }\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 pixel = vec3((uv-0.5)*iResolution.xy,0);\n    vec3 viewer = vec3(0,0,-tan(FOV/2.0*PI/180.0)*iResolution.x/2.0);\n    vec3 viewerRay = vec3(0,0,0)-viewer;\n    \n    int iterCount = 0;\n    render(pixel, viewer, viewerRay, fragColor, iterCount);\n    \n    bool aa = false;\n    if(aa && iterCount > 20 && iterCount < 149) {\n        // AA?\n        vec4 average = fragColor/5.0;\n    \trender(pixel-vec3(0.25,0.25,0), viewer, viewerRay, fragColor, iterCount);\n        average += fragColor/5.0;\n        \n    \trender(pixel-vec3(0.25,-0.25,0), viewer, viewerRay, fragColor, iterCount);\n        average += fragColor/5.0;\n        \n    \trender(pixel-vec3(-0.25,0.25,0), viewer, viewerRay, fragColor, iterCount);\n        average += fragColor/5.0;\n        \n    \trender(pixel-vec3(-0.25,-0.25,0), viewer, viewerRay, fragColor, iterCount);\n        average += fragColor/5.0;\n    \tfragColor = average;\n    }\n    \n    \n}","name":"Image","description":"","type":"image"}]}