{"ver":"0.1","info":{"id":"Mfy3Dz","date":"1714328994","viewed":65,"name":"2D Aurora","username":"Chromaney","description":"A simple-ish 2D imitation of an aurora visuals.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["2d","noise","palette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader \"2D Aurora\" by Chromaney.\n// Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A simple-ish 2D imitation of an aurora visuals.\n\n// --------------------------------\n\n// Main image buffer.\n\nvec3 palette(float t){\n    t = 3.5 * t - 1.0;\n    vec3 amps = vec3(0.3, 0.9, 0.2);\n    vec3 centers = vec3(1.0, 0.3, 0.7);\n    vec3 widths = vec3(0.35, 0.20, 0.35);\n    vec3 color = amps * exp(- pow((t - centers) / widths, vec3(2.0)) / 2.0);\n    color.b += color.g * 0.1;\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    float minRes = 1.0 / max(iResolution.x, iResolution.y);\n    \n    vec2 inData = texture(iChannel0, uv).xy;\n    vec3 color = palette(pow(1.0 - inData.x, (1.0 + 1.5 * (inData.y - 0.5))));\n    \n    vec2 grad = vec2(dFdx(inData.x), dFdy(inData.x)) * (0.0013 / minRes);\n    float corrCoeff = smoothstep(-0.05, 0.0, -grad.y) * smoothstep(-0.01, 0.0, -length(grad));\n    fragColor = vec4(color * corrCoeff, 1.0);\n    \n    fragColor = vec4(pow(fragColor.xyz, vec3(1.0 / 2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.1415926536\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 3D Perlin noise buffer.\n\nvec3 hash3to3(vec3 coord){\n    uint k = 835171995U;\n    uvec3 res = uvec3(coord) + k;\n    \n    res = (res.zxy * k + res.yzx) ^ res.z;\n    res = (res.zxy * k + res.yzx) ^ res.y;\n    res = (res.zxy * k + res.yzx) ^ res.x;\n    \n    return (vec3(res.xyz) / float(0xffffffffU));\n}\n\nvec3 blendFcn3(vec3 t){\n    return (t * t * t * (t * (t * 6.0 - 15.0) + 10.0));\n}\n\nfloat perlinNoise3(vec3 coord, float scale){\n    vec3 intCoord = floor(coord / scale);\n    vec3 fracCoord = mod(coord, vec3(scale)) / scale;\n    vec3 blendVals = blendFcn3(fracCoord);\n    \n    vec2 r000 = hash3to3(intCoord + vec3(0.0, 0.0, 0.0)).xy;\n    vec2 r001 = hash3to3(intCoord + vec3(0.0, 0.0, 1.0)).xy;\n    vec2 r010 = hash3to3(intCoord + vec3(0.0, 1.0, 0.0)).xy;\n    vec2 r011 = hash3to3(intCoord + vec3(0.0, 1.0, 1.0)).xy;\n    vec2 r100 = hash3to3(intCoord + vec3(1.0, 0.0, 0.0)).xy;\n    vec2 r101 = hash3to3(intCoord + vec3(1.0, 0.0, 1.0)).xy;\n    vec2 r110 = hash3to3(intCoord + vec3(1.0, 1.0, 0.0)).xy;\n    vec2 r111 = hash3to3(intCoord + vec3(1.0, 1.0, 1.0)).xy;\n    \n    r000 = vec2((r000.x - 0.5) * M_PI, r000.y * 2.0 * M_PI);\n    r001 = vec2((r001.x - 0.5) * M_PI, r001.y * 2.0 * M_PI);\n    r010 = vec2((r010.x - 0.5) * M_PI, r010.y * 2.0 * M_PI);\n    r011 = vec2((r011.x - 0.5) * M_PI, r011.y * 2.0 * M_PI);\n    r100 = vec2((r100.x - 0.5) * M_PI, r100.y * 2.0 * M_PI);\n    r101 = vec2((r101.x - 0.5) * M_PI, r101.y * 2.0 * M_PI);\n    r110 = vec2((r110.x - 0.5) * M_PI, r110.y * 2.0 * M_PI);\n    r111 = vec2((r111.x - 0.5) * M_PI, r111.y * 2.0 * M_PI);\n    \n    vec3 grad000 = vec3(cos(r000.x) * cos(r000.y), sin(r000.x), cos(r000.x) * sin(r000.y));\n    vec3 grad001 = vec3(cos(r001.x) * cos(r001.y), sin(r001.x), cos(r001.x) * sin(r001.y));\n    vec3 grad010 = vec3(cos(r010.x) * cos(r010.y), sin(r010.x), cos(r010.x) * sin(r010.y));\n    vec3 grad011 = vec3(cos(r011.x) * cos(r011.y), sin(r011.x), cos(r011.x) * sin(r011.y));\n    vec3 grad100 = vec3(cos(r100.x) * cos(r100.y), sin(r100.x), cos(r100.x) * sin(r100.y));\n    vec3 grad101 = vec3(cos(r101.x) * cos(r101.y), sin(r101.x), cos(r101.x) * sin(r101.y));\n    vec3 grad110 = vec3(cos(r110.x) * cos(r110.y), sin(r110.x), cos(r110.x) * sin(r110.y));\n    vec3 grad111 = vec3(cos(r111.x) * cos(r111.y), sin(r111.x), cos(r111.x) * sin(r111.y));\n    \n    vec3 dir000 = fracCoord - vec3(0.0, 0.0, 0.0);\n    vec3 dir001 = fracCoord - vec3(0.0, 0.0, 1.0);\n    vec3 dir010 = fracCoord - vec3(0.0, 1.0, 0.0);\n    vec3 dir011 = fracCoord - vec3(0.0, 1.0, 1.0);\n    vec3 dir100 = fracCoord - vec3(1.0, 0.0, 0.0);\n    vec3 dir101 = fracCoord - vec3(1.0, 0.0, 1.0);\n    vec3 dir110 = fracCoord - vec3(1.0, 1.0, 0.0);\n    vec3 dir111 = fracCoord - vec3(1.0, 1.0, 1.0);\n    \n    float val000 = dot(grad000, dir000);\n    float val001 = dot(grad001, dir001);\n    float val010 = dot(grad010, dir010);\n    float val011 = dot(grad011, dir011);\n    float val100 = dot(grad100, dir100);\n    float val101 = dot(grad101, dir101);\n    float val110 = dot(grad110, dir110);\n    float val111 = dot(grad111, dir111);\n    \n    float k_1 = val000;\n    float k_x = val100 - val000;\n    float k_y = val010 - val000;\n    float k_z = val001 - val000;\n    float k_xy = val110 - val100 - val010 + val000;\n    float k_xz = val101 - val100 - val001 + val000;\n    float k_yz = val011 - val010 - val001 + val000;\n    float k_xyz = val111 - val110 - val101 - val011 + val100 + val010 + val001 - val000;\n    \n    float val = 1.0 * k_1 + blendVals.x * k_x + blendVals.y * k_y + blendVals.z * k_z + \n        blendVals.x * blendVals.y * k_xy + blendVals.x * blendVals.z * k_xz + \n            blendVals.y * blendVals.z * k_yz + \n        blendVals.x * blendVals.y * blendVals.z * k_xyz;\n    \n    return val;\n}\n\nfloat perlinNoise3Val(vec3 sampleCoord){\n    float col = 0.0;\n    float amplScale = 1.0;\n    for (int i = 0; i < 6; i ++){\n        float curNoise = perlinNoise3(sampleCoord, 1.0);\n        col += amplScale * curNoise;\n        sampleCoord = 2.0 * sampleCoord;\n        amplScale /= 2.0;\n    }\n    col = 0.5 + 0.5 * col;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 noiseCoord = vec3(uv, iTime * 0.03);\n    fragColor = vec4(perlinNoise3Val(noiseCoord));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// \"Memory\" buffer.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv0 = uv - 0.5 / iResolution.xy;\n    \n    float minRes = 1.0 / max(iResolution.x, iResolution.y);\n    \n    if (iFrame == 0){\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        float rand1 = texture(iChannel1, uv).x;\n        float rand2 = texture(iChannel1, fract(0.5 + (uv - 0.5) * rand1)).x;\n        \n        float limLo = 0.45;\n        float limHi = 0.55;\n        float spawnVal = rand1;\n        spawnVal = smoothstep(limLo, limHi, spawnVal) * smoothstep(limHi, limLo, spawnVal) * 4.0;\n        \n        float dY = 1.0 * minRes;\n        vec2 prevVal = vec2(0.0);\n        if (uv0.y >= dY){\n            prevVal = texture(iChannel0, vec2(uv.x + 5.0 * minRes * (rand2 - 0.5), uv0.y - dY)).xy;\n        }\n        \n        vec2 curVal = prevVal - vec2(3.0 * minRes, 0.0);\n        float blendCoeff = max((spawnVal - curVal.x) * 0.25, 0.0);\n        \n        fragColor = vec4(mix(curVal.x, spawnVal * (1.0 - 0.5 * uv.y), blendCoeff), rand2, 0.0, 1.0);\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}