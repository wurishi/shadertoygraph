{"ver":"0.1","info":{"id":"dslSRn","date":"1668510573","viewed":159,"name":"The Lone and Level sands","username":"LoganOracio","description":"Two vast and trunkless legs of stone stand in the desert","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat lerp(float x, float y, float v)\n{\n    if(v<=0.0) return x;\n    else if(v>=1.0) return y;\n    else\n    { \n        return (y - x) * (((v * 6.0 - 15.0) * v + 10.0) * v * v * v) + x;\n    }\n}\nvec2 random_gradient(vec2 uv)\n{\n    float angle = hash12(uv)*2.0*3.14159265358979;\n    return vec2(cos(angle),sin(angle));\n}\nfloat dot_gradient(vec2 i, vec2 uv)\n{\n    vec2 d = uv - i;\n    vec2 grad = random_gradient(vec2(i.x,i.y));\n    return d.x*grad.x + d.y*grad.y;\n}\nfloat pnoise(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    \n    float n0 = dot_gradient(fl,uv);\n    float n1 = dot_gradient(fl+vec2(1.0,0.0),uv);\n    float o0 = lerp(n0,n1,uv.x-fl.x);\n    \n    n0 = dot_gradient(fl+vec2(0.0,1.0),uv);\n    n1 = dot_gradient(fl+vec2(1.0,1.0),uv);\n    float o1 = lerp(n0,n1,uv.x-fl.x);\n    \n    return lerp(o0,o1,uv.y-fl.y);\n}\n// Some of the Ray Marching stuff taken from mrange:\n\n// CC0: Wednesday messing around\n#define MAX_RAY_LENGTH  1000.0\n#define MAX_RAY_MARCHES 500\n#define TOLERANCE       0.001\n#define NORM_OFF        0.001\n\nint g_hit     = 0;\n\nconst float raymarchFactor = 1.001;\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\nfloat smin(float a, float b, float k)\n{\n    return -log(exp(k*-a)+exp(k*-b))/k;\n}\n\nfloat df(vec3 p) {\n    //p.y -= exp(length(vec2(p.x-iTime*10.0,p.z))/50.0);\n    float n = pnoise(0.15*p.xz);\n    n = pow(smax(n,-n,40.0),0.8);\n    vec3 m = vec3(mod(p.x,50.0)-25.0,p.y,mod(p.z,50.0)-25.0);\n    return p.y+2.0+2.0*pnoise(0.06*p.xz)+3.0*pnoise(0.12*p.xz)*n+0.001*sin(n*100.0);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float ti) {\n  float t = ti;\n  int i = 0;\n  vec2 dti = vec2(1e10,0.0);\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t + pow(t,2.0)*vec3(0.0,-0.001,0.0));\n    if (d < TOLERANCE) g_hit = 1;\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    if (d<dti.x) { dti=vec2(d,t); }\n    t += raymarchFactor*d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; }\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec4 render(vec2 p) {\n  \n  vec3 ro = vec3(iTime*10.0,0.0,0.0);\n  vec3 la = ro+vec3(1.0,0.0,0.0);\n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 1.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n  \n  g_hit = -1;\n  float t = rayMarch(ro, rd, 1.0);\n  int hit = g_hit;\n  \n  vec3 sky = mix(vec3(0.9,1.0,1.2),vec3(0.5,0.8,1.0),rd.y);\n  \n  vec4 col = vec4(sky,1.0);\n  if (hit==1) {\n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    vec3 r = reflect(rd, n);\n    \n    col.xyz = vec3(clamp(dot(n,vec3(0.0,0.6,-0.3)),0.0,1.0));\n    col.xyz = clamp(dot(n,vec3(0.3,0.7,0.1)),0.0,1.0)*vec3(1.4,1.1,0.4);\n    col.xyz = mix(sky,col.xyz,1.0/(1.0+pow(t/160.0,2.0)));\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}