{"ver":"0.1","info":{"id":"wssXDM","date":"1551482762","viewed":413,"name":"Glass Distortion Ball","username":"kubiak","description":"Magnifying and distorting to give a weird glass effect.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["magnification","distorition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 calcNormal(vec2 center, vec2 pos, float radius) {\n    vec2 rpos = pos - center;\n    rpos = rpos / radius;\n    float z = sqrt(1.0 - rpos.x*rpos.x + rpos.y*rpos.y);\n    \n    return -vec3(rpos.x, rpos.y, z);\n}\n\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nvec4 quatForAxisAngle(float angle, vec3 axis) {\n    vec4 q;\n    \n    float half_angle = angle/2.0;\n    q.x = axis.x * sin(half_angle);\n    q.y = axis.y * sin(half_angle);\n    q.z = axis.z * sin(half_angle);\n    q.w = cos(half_angle);\n    return q;\n}\n\nbool intersectsBall(vec2 p2, vec2 center, float radius, out float edginess) {\n    float n = noise(p2 * 5.0 + iTime) * 0.015;\n    radius += n;\n    vec2 to = p2 - center;\n    float l = length(to);\n    edginess = 0.0;\n    \n    float edgeWidth = 0.05;\n    if(l < radius && l > (radius - edgeWidth)) {\n        edginess = 1.0 - (radius - l) / edgeWidth;\n    }\n    return l < radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tp = p;\n    \n    vec2 p2 = p * 1.0;\n    float aspect = iResolution.x / iResolution.y;\n\tp2.x *= aspect;\n    p2.y = 1.0 - p2.y;\n    \n    float s = sin(iTime)*0.5 + 0.5 * aspect;\n    //s = 1.0;\n    \n    vec2 center = vec2(s, 0.5);\n    float radius = 0.25;\n    \n    vec4 col;\n    \n    vec3 normal = calcNormal(center, p2, radius);\n    \n    // Rotation\n    vec4 q = quatForAxisAngle(0.0, vec3(0.0, 1.0, 0.0));\n    vec3 temp = cross(q.xyz, normal) + q.w * normal;\n    normal = normal + 2.0*cross(q.xyz, temp);\n    \n    float edginess = 0.0;\n    if(!intersectsBall(p2, center, radius, edginess)) {\n     \n        col = vec4(0.0);\n        col = texture(iChannel0, p);\n    }\n    else \n    {\n        vec3 r = reflect(vec3(0.0, 0.0, 1.0), normalize(normal));\n        //r = normal;\n        vec3 t = (r * 0.5 + 0.5) * 0.5;\n        \n        t += noise(t.xy * 10.0 + iTime) * 0.05;\n        t.x -= s;\n        col = texture(iChannel0, t.xy);\n        \n        // Brighten\n        col = col * (1.5) + vec4(edginess * edginess);\n        //col = vec4(vec3(t.x), 1.0);\n\t\t//col = vec4(normal, 1.0);\n    }\n\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}