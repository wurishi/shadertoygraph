{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float fov = 3.1415 / 4.0;\nconst float EP = 0.05;\nconst float box_r = 1.5;\nconst mat4 mT = mat4(\t2.0,0.0,\n                     \t2.0,1.0,\n                     \t2.0,2.0,\n                     \t2.0,3.0,\n                    \t0.0,3.0,\n                     \t1.0,3.0,\n                    \t3.0,3.0,\n                     \t4.0,3.0);\n\nconst mat4 mG = mat4(\t0.0,1.0,\n                     \t0.0,2.0,\n                     \t1.0,0.0,\n                     \t1.0,3.0,\n                    \t2.0,0.0,\n                     \t2.0,3.0,\n                    \t3.0,0.0,\n                     \t3.0,1.0);\n\nconst mat4 mC = mat4(\t0.0,1.0,\n                     \t0.0,2.0,\n                     \t1.0,0.0,\n                     \t1.0,3.0,\n                    \t2.0,0.0,\n                     \t2.0,3.0,\n                    \t3.0,0.0,\n                     \t3.0,3.0);\n    \n    \n    \nfloat rand(vec3 x)\n{\n\tfloat n = dot(x , vec3(1.0,113.0,257.0) );\n    return fract(sin(n)*43758.5453) - 0.5;\n}\n\nbool ray_aabb(vec3 org,vec3 dir,vec3 lb, vec3 rt,out float dist)\n{\n    bool rta = false;\n    vec3 dirfrac = 1.0 / dir;\n    vec3 A = (lb-org)*dirfrac;\n    vec3 B = (rt-org)*dirfrac;\n    float tmin = max(max(min(A.x, B.x), min(A.y, B.y)), min(A.z, B.z));\n    float tmax = min(min(max(A.x, B.x), max(A.y, B.y)), max(A.z, B.z));\n    if (tmin<=tmax && tmin>0.0)\n    {\n        rta = true;\n        dist = tmin;\n    }\n\treturn rta;\n}\n\n\nbool ray_edge(vec3 org,vec3 dir,vec3 lb, vec3 rt)\n{\n    bool rta = false;\n    vec3 dirfrac = 1.0 / dir;\n    vec3 A = (lb-org)*dirfrac;\n    vec3 B = (rt-org)*dirfrac;\n    float tmin = max(max(min(A.x, B.x), min(A.y, B.y)), min(A.z, B.z));\n    float tmax = min(min(max(A.x, B.x), max(A.y, B.y)), max(A.z, B.z));\n    if (tmin<=tmax && tmin>0.0)\n    {\n        int cant = 0;\n\t\tvec3 Ip = org + dir*tmin;\n        vec3 Ta = abs(Ip - lb);\n        vec3 Tb = abs(Ip - rt);\n        if( Ta.x < EP)\n            cant++;\n        if( Ta.y < EP)\n            cant++;\n        if( Ta.z < EP)\n            cant++;\n        \n        if( Tb.x < EP)\n            cant++;\n        if( Tb.y < EP)\n            cant++;\n        if( Tb.z < EP)\n            cant++;\n        \n        rta = cant>=2 ? true : false;\n    }\n\treturn rta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat x = 2.0*uv.x-1.0;\n    float y = 2.0*uv.y-1.0;\n\tfloat time = iTime*2.0;\n    vec3 vLookFrom = vec3(30.0*sin(time),10.0*cos(time),30.0*cos(time));\n    vec3 vLookAt = vec3(0.0,0.0,0.0);\n    vec3 N = normalize(vLookAt-vLookFrom);\n    vec3 V = normalize(cross( N , vec3(0.0,1.0,0.0)));\n    vec3 U = cross(V , N);\n    float k = 2.0*tan(fov/2.0);\n\tvec3 Dy = U*(k*iResolution.y/iResolution.x*0.8);\n\tvec3 Dx = V*k;\n    \n\t// direccion de cada rayo\n\tvec3 D = normalize(N + Dx*x + Dy*y);\n    vec3 box_dim = vec3(box_r,box_r,box_r);\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    float min_dist = 1000000.0;\n    for(float s=0.0;s<3.0;++s)\n    for(int i=0;i<4;++i)\n    for(int j=0;j<2;++j)\n    {\n        float rnd = rand(vec3(uv,time));\n\t\tfloat dist;\n        vec3 box_or;\n        if(s==0.0)\n        \tbox_or = vec3(mT[i][j*2],mT[i][j*2+1],0.0) * box_dim*1.5; \n       \telse\n        if(s==1.0)\n        \tbox_or = vec3(mG[i][j*2],mG[i][j*2+1],0.0) * box_dim*1.5;\n        else\n        \tbox_or = vec3(mC[i][j*2],mC[i][j*2+1],0.0) * box_dim*1.5;\n            \n \t\tbox_or += vec3(box_r*8.0 * (s-1.0) , -box_r , 0.0);            \n        box_or +=  rnd*box_dim;\n        bool hit_edge = ray_edge(vLookFrom,D , box_or-box_dim, box_or+box_dim);\n        \n        if(hit_edge)\n        {\n            fragColor = vec4(0.75,0.8,1.0,1.0);            \n        }\n        else\n        {\n        \tbox_or +=  rnd*box_dim*3.0;\n            bool hit = ray_aabb(vLookFrom,D , box_or-box_dim, box_or+box_dim, dist);\n\n            if(hit && dist<min_dist)\n            {\n                min_dist = dist;\n                vec3 Ip = vLookFrom + D*dist;\n                float d = length(Ip-box_or) / (2.0 * box_r);\n                d = pow(d,3.0);\n                fragColor = vec4(d,d,0,1.0);            \n            }\n        }\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlX3RN","date":"1419122268","viewed":238,"name":"tgc_test","username":"mbanquiero","description":"test de raytracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracingcharacters"],"hasliked":0,"parentid":"","parentname":""}}