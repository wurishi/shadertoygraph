{"ver":"0.1","info":{"id":"43fyWH","date":"1726075473","viewed":17,"name":"Hierarchical Wang Tiles 2 ","username":"chronos","description":"Hierarchical Wang Tiles. Click to show subdivision / quadtree.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["multiscale","tiles","wang","quadtree","hierarchical"],"hasliked":0,"parentid":"lXlyR7","parentname":"Hierarchical Wang Tiles"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    \"Hierarchical Wang Tiles 2\" by chronos\n    ---------------------------------------------------\n    \n    Changed tile visualization, made the loop body 'branchless'.\n    Added dots to indicate 'connectivity'. Always assumes finest level, since we don't want to query the neighbor subdiv level.\n    \n    ---------------------------------------------------\n    Forked shader desciption\n    ---------------------------------------------------\n        Figured out how to do hierarchical Wang tiles!\n        There's probably other examples of this here already, but I haven't seen it before I think.\n        In any case I wanted to work it out for myself :)\n\n        The tile edges are binary in this case, but it can be generalized\n        Binary edge constraints give 16 possible tiles\n\n        You can tell that no edge constraints are violated, since there are no vertical or horizontal edges,\n        except for the outermost ones, of course.\n\n        Using this connectivity info it is possible to draw shapes in the cells \n        with boundary conditions that will match that of neighboring cells.\n\n        In this simple demonstration I only draw simple tiles in classical Wang tile fashion\n        with triangle colors corresponding to edge value.\n    \n    -------------------------------------------------------\n    \n    Self link: https://www.shadertoy.com/view/43fyWH\n*/\n\n// grid_id = \n// 0,0 -> bottom left    -> inherit bottom and left from parent, and top from new left, right from new bot\n// 1,0 -> bottom right   -> inherit bottom and right from parent, and top from new right, left from new bot\n// 0,1 -> top left       -> inherit top and left from parent, and bot from new left, right from new top\n// 1,1 -> top right      -> inherit top and right from parent, and left from new top, bot from new right\n\n#define ss(D) smoothstep(ps, -ps, D)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (.5+(fragCoord - .5*iResolution.xy) / iResolution.y);\n    float ps   = 1. / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 cell_uv = fract(uv);\n    vec2 child_id = floor(uv);\n    vec2 cell_id = child_id;\n\n    int num_levels = 5;\n    \n    float gridsize = pow(2., float(num_levels));\n    vec2 grid_id = floor(uv * gridsize);\n    vec2 grid_uv = fract(uv * gridsize);\n\n    float T = mod(floor(iTime), 16.);\n\n    // x:bottom, y:right, z:top, w:left\n    vec4 boundaries = \n        vec4(ivec4(T/8., T/4., T/2., T) % 2); // Animated by stepping through all 16 possible types.\n\n    int level = 0; // Make this accessible after the loop as well\n    for(; level < num_levels; level++)\n    {\n        // draw four random values to place on the new interior edges:\n        vec4 rnd = step(.5, texelFetch(iChannel0, ivec2(cell_id)%1024, 0));\n        \n        // Subdivide grid:\n        child_id = floor(2. * cell_uv);\n        cell_uv = fract(2. * cell_uv);\n        cell_id = cell_id * 2. + child_id;\n        \n        boundaries.yz = mix(boundaries.yz, rnd.xw, (1.-child_id.x) * (1.-child_id.y)); // bot left child       // top from new left, right from new bot\n        boundaries.zw = mix(boundaries.zw, rnd.yx, child_id.x * (1.-child_id.y)); // bot right child     // top from new right, left from new bot\n        boundaries.xy = mix(boundaries.xy, rnd.wz, (1.-child_id.x) * child_id.y); // top left child      // bot from new left, right from new top\n        boundaries.xw = mix(boundaries.xw, rnd.yz, child_id.x * child_id.y); // top right child      // left from new top, bot from new right\n    \n        // Use 'russian-roulette' termination condition for subdivision. \n        int id = (int(cell_id.y) << level) + int(cell_id.x);\n        \n        id += int(T); // animate\n        if(texelFetch(iChannel1, ivec2(id, id/256)%256, 0).r < .5) break;\n    }\n\n    // Unused for now, but the cell id can be useful in other shaders extending this method.\n    // int id = (int(cell_id.y) << num_levels) + int(cell_id.x);\n    // color = pow(texelFetch(iChannel0, ivec2(id/1024, id%1024), 0).rgb, vec3(3.));\n\n    ps = pow(2., float(level)) / iResolution.y; // Pixel size in grid/cell UV coordinates\n\n    vec2 diag = sqrt(2.)/2. * mat2(1,1,-1,1)*(cell_uv - .5); // Diagonals for triangle pattern, with center at (0,0)\n\n    float alpha = 0.;\n    alpha += ss(-diag.x) * ss( diag.y) * boundaries.x; // bot\n    alpha += ss(-diag.x) * ss(-diag.y) * boundaries.y; // right\n    alpha += ss( diag.x) * ss(-diag.y) * boundaries.z; // top\n    alpha += ss( diag.x) * ss( diag.y) * boundaries.w; // left\n\n    color = mix(vec3(.5,2,.5), vec3(0,1,2), alpha); \n    color *= mix(\n        sqrt(2. * abs(diag.x * diag.y)),\n        .5,\n         2.*max(abs(cell_uv.x - .5), abs(cell_uv.y - .5)));\n    \n    if(iMouse.z > .5)\n    {\n        alpha = 0.;\n        alpha += smoothstep(3.*ps, 2.*ps, cell_uv.y) * boundaries.x; // bot\n        alpha += smoothstep(1.-3.*ps, 1.-2.*ps, cell_uv.x) * boundaries.y; // right\n        alpha += smoothstep(1.-3.*ps, 1.-2.*ps, cell_uv.y) * boundaries.z; // top\n        alpha += smoothstep(3.*ps, 2.*ps, cell_uv.x) * boundaries.w; // left\n        color = vec3(alpha);\n    }\n    \n    alpha = (\n          ss(length(grid_uv - vec2(0, .5)) - .225) * boundaries.w // left\n        + ss(length(grid_uv - vec2(.5, 0)) - .225)* boundaries.x // bot\n        + ss(length(grid_uv - vec2(1, .5)) - .225)* boundaries.y // right\n        + ss(length(grid_uv - vec2(.5, 1)) - .225)* boundaries.z // top\n    )\n    * ss((.5-.5/pow(2., float(num_levels - level))) - max(abs(cell_uv.x-.5), abs(cell_uv.y-.5)))\n    ;\n    \n    color = mix(color, vec3(3,2,1)/3., alpha); // Draw dots\n    \n    color *= (1.-step(1., uv.x)) * step(0., uv.x);\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}