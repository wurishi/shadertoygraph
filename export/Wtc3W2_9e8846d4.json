{"ver":"0.1","info":{"id":"Wtc3W2","date":"1578233883","viewed":9683,"name":"Campfire at night","username":"Maurogik","description":"An animated fire scene. The fire burns out over time, so stick around (take around 80 seconds)!\nFeatures: Area lights (well, close enough anyway), volumetric medium, TAA, bloom.\nDrag the mouse to sping the camera.","likes":241,"published":1,"flags":32,"usePreview":1,"tags":["sdf","fire","volumetric","night"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n////////////////////////// Campfire scene /////////////////////////////\n/////////////////////////// by Maurogik ///////////////////////////////\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n\n//\n// Animated fire scene\n// If ran on a laptop, automatically turns it into a nice hand warmer ;)\n// The whole fire burns out in about 80 seconds\n//\n// The fire itself is a deformed SDF rendered as an emissive volumetric effect.\n// Several area lights are used for lighting the scene.\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n      \n\tvec4 colour = textureLod(iChannel0, uv, 0.0);\n    \n    //Shadertoy very conveniently provides us with Mips of the input buffers !\n    //Let's do bloom !\n    \n    float totalWeight = 0.0;\n    \n    vec3 bloom = oz.yyy;\n    \n    vec2 subPixelJitter = fract(hash22(fragCoord)\n                                + float(iFrame%256) * kGoldenRatio * oz.xx) - 0.5*oz.xx;\n    \n    float range = 1.0;\n    //Super sample low mips to get less blocky bloom\n    for(float xo = -range; xo < range + 0.1; xo += 0.5)\n    {\n        for(float yo = -range; yo < range + 0.1; yo += 0.5)\n        {\n            vec2 vo = vec2(xo, yo);\n            float weight = (range*range*2.0) - dot(vo, vo);\n            vo += 0.5 * (subPixelJitter);\n            vec2 off = vo*(0.5/range)/iResolution.xy;\n            \n            if(weight > 0.0)\n            {\n                bloom += 0.4  * weight * textureLod(iChannel0, uv + off*exp2(4.0), 4.0).rgb;\n                bloom += 0.4  * weight * textureLod(iChannel0, uv + off*exp2(5.0), 5.0).rgb;\n                bloom += 0.4  * weight * textureLod(iChannel0, uv + off*exp2(6.0), 6.0).rgb;\n            }\n            totalWeight += weight;\n        }\n    }\n\n    bloom.rgb /= totalWeight;\n    \n    colour.rgb += 0.025 * pow(bloom, oz.xxx*2.0);\n    \n    //Vignette\n    colour.rgb *= linearstep(0.8, 0.3, length(uv - 0.5*oz.xx));\n        \n    colour.rgb = tonemap(colour.rgb);\n    \n    colour = pow(colour, vec4(1.0/2.2));\n    \n    //Colour banding removal\n    float dithering = hash12(fragCoord) - 0.5;\n    fragColor = colour + oz.xxxx * dithering / 255.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n//////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n// SDF functions from mercury : http://mercury.sexy/hg_sdf/ //\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\n\nfloat vmax(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b)\n{  // cheap box\n    return vmax(abs(p) - b);\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height)\n{\n    float d = length(p.xz) - r;\n    d       = max(d, abs(p.y) - height);\n    return d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3  ab = b - a;\n    float t  = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab * t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    return fLineSegment(p, a, b) - r;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a)\n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n    float angle = 2.0 * PI / repetitions;\n    float a     = atan(p.y, p.x) + angle / 2.;\n    float r     = length(p);\n    float c     = floor(a / angle);\n    a           = mod(a, angle) - angle / 2.;\n    p           = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if(abs(c) >= (repetitions / 2.0))\n        c = abs(c);\n    return c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size)\n{\n    vec2 c = floor((p + size * 0.5) / size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n    vec3 c = floor((p + size * 0.5) / size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n\n////////////////////////////////////////////////////////////\n//////////////// Intersectors/SDFs from IQ /////////////////\n\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    return (length( p/r.xyx ) - 1.0) * r.x;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\n////////////////////////////////////////////////////////////////////////\n////////////////// Hashes from Dave Hoskins ////////////////////////////\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\n//Black body radiation function from Fabrice Neyret\n//https://www.shadertoy.com/view/4tdGWM\nvec3 blackBodyToRGB(float temp, float brightness)\n{\n    vec3 res;\n    \n    for (float i = 0.0; i < 3.0; i++) // +=.1 if you want to better sample the spectrum.\n    {\n        float f = 1.0 + 0.5 * i; \n        res[int(i)] += brightness * (f*f*f) / (exp((19E3 * f / temp)) - 1.0);  // Planck law\n    }\n    \n    return res;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n\n////////////////////////// Shared Code //////////////////////////////\n\n/////////////////////////////////////////////////////////////////////\n\n\n\n#define NON_CONST_ZERO (min(iFrame,0)) \n#define NON_CONST_ZERO_U uint(min(iFrame,0)) \n\nconst vec2 oz = vec2(1.0, 0.0);\n\nconst float kGoldenRatio = 1.618;\nconst float kGoldenRatioConjugate = 0.618;\n\nconst float kPI         = 3.14159265359;\nconst float kTwoPI      = 2.0 * kPI;\n\n\nconst float kMaxDist = 200.;\nconst float kTimeScale = 1.0;\n\nvec3 roughFresnel(vec3 f0, float cosA, float roughness)\n{\n    // Schlick approximation\n    return f0 + (oz.xxx - f0) * (pow(1.0 - cosA, 5.0)) * (1.0 - roughness);\n}\n\nvec3 fresnel(vec3 f0, float cosA)\n{\n    return roughFresnel(f0, cosA, 0.0);\n}\n\nfloat linearstep(float start, float end, float x)\n{\n    float range = end - start;\n    return saturate((x - start) / range);\n}\n\nfloat luminance(vec3 rgb)\n{\n    return (rgb.r * 0.3) + (rgb.g * 0.59) + (rgb.b * 0.11);\n}\n\nvec3 fixNormalBackFacingness(vec3 rayDirWS, vec3 normalWS)\n{\n    normalWS -= max(0.0, dot(normalWS, rayDirWS)) * rayDirWS;\n    return normalWS;\n}\n\nvec2 computeParaboloidUv(vec3 dir)\n{\n    dir.xz /= abs(dir.y) + 1.0;\n    dir.xz = dir.xz * 0.5 + 0.5 * oz.xx;\n    \n    return dir.xz;\n}\n\nfloat tonemapOp(float v)\n{\n    v = pow(v, 2.0);\n    v = v / (1.0 + v);\n    return pow(v, 1.0/2.0) * 1.02;\n}\n\nvec3 tonemap(vec3 colour)\n{\n    float luminance = max(0.0001, luminance(colour));\n    vec3 normalisedColour = colour / luminance;\n    \n    vec3 tonemapColour;\n    tonemapColour.r = tonemapOp(colour.r);\n    tonemapColour.g = tonemapOp(colour.g);\n    tonemapColour.b = tonemapOp(colour.b);\n    float tonemappedLuminance = tonemapOp(luminance);\n    \n    return mix(tonemappedLuminance * normalisedColour, tonemapColour, min(1.0, 0.5*luminance));\n}\n\n///////////////////////////////////////////////////////\n//////////Lighting and scene specific thing////////////\n///////////////////////////////////////////////////////\n\n\n//Ugly globals.\nfloat s_globalFireLife = 1.0;\nfloat s_time = 0.0;\nfloat s_pixelRand = 0.0;\n\nstruct CampireLog\n{\n    vec3 centerWS;\n    vec3 burnDirWS;\n    \n    float rotationY;\n    float rotationZ;\n    \n    float logRadius;\n    float logLength;\n};\n\nconst uint kNumLogs = 7u;\nCampireLog s_campfireLogs[kNumLogs];\n\nconst vec3 kCampfireCenterWS = vec3(0.05, 0.0, 0.02);\n\nconst vec4 kFireStartSphere = vec4(0.15, 0.25, 0.15, 0.2);\nconst vec4 kFireEndSphere = vec4(0.1, 0.8, 0.1, 0.05);\nconst vec3 kFireLightColour = vec3(1.0, 0.18, 0.035) * 0.5 \n    / (kFireStartSphere.a*kFireStartSphere.a * 0.5);\n\nconst vec3 kSkyColour = vec3(0.2, 0.5, 1.0) * (0.005);\n\n\n\n// Area lights\n// Definitively not correct, but convincing enough.\nfloat diskLight(vec3 coneDirWS, vec3 dirToLightWS,\n           float cosAngularRadius, float roughness)\n{\n    float brdfDiskSolidAngle = 2.0*kPI*(1.0 - (cosAngularRadius-roughness*1.0));\n    float diskSolidAngle = 2.0*kPI*(1.0 - cosAngularRadius);\n    float brightness = (max(0.00001, diskSolidAngle)/max(0.00001, brdfDiskSolidAngle));\n    \n    float sharpness = 1.0 - roughness;\n\n    float vDotL = dot(coneDirWS, dirToLightWS);\n\n    float brdfPower = 7.0 - 6.0*sqrt(roughness);\n    \n    //Angle space visibility instead of cosine space\n    //Not sure if this is more correct, the nDotL term is lost\n    //But would it even apply to area lighting ?\n    brdfDiskSolidAngle = 2.0*kPI*(1.0 - cos(acos(cosAngularRadius)+roughness*0.5*kPI));\n    diskSolidAngle = 2.0*kPI*(1.0 - cosAngularRadius);\n    brightness = (max(0.00001, diskSolidAngle)/max(0.00001, brdfDiskSolidAngle));\n    \n    float diskVisibility = max(0.0, linearstep(\n        acos(cosAngularRadius) + 0.01 + roughness*kPI*0.5, \n        acos(cosAngularRadius) - 0.01 - roughness*kPI*0.5,\n    \tacos(vDotL)))*2.0;\n\n    brdfPower = 7.0 - 6.0*(roughness);\n\n    diskVisibility = pow(diskVisibility, brdfPower);\n\n    //Integral S = (x^n dx) is F = x^(n+1) * 1/(n+1)\n    //Integral over range [A, B] is F(B) - F(A)\n    float powIntegral = 1.0/(brdfPower + 1.0);\n\tfloat normalisationFactor = powIntegral;\n    //Renormalize\n    diskVisibility /= max(0.00001, normalisationFactor);\n    diskVisibility = min(1.0, diskVisibility * brightness);\n\n    return diskVisibility;\n}\n\nvec3 computeSphereLighting(vec3 posWS, vec3 coneDirWS, float roughness, vec4 lightSphere, vec3 colour,\n                      out float visibility)\n{\n    vec3 posToSphereWS = lightSphere.xyz - posWS;\n    float distToSphereCenter = length(posToSphereWS);\n    float sqDistToSphere = distToSphereCenter * distToSphereCenter;\n    float sqSphereRadius = lightSphere.a * lightSphere.a;\n    \n    float distToDisk = (1.0/max(0.001, distToSphereCenter)) * max(0.001, sqDistToSphere - sqSphereRadius);\n    float diskRadius = (lightSphere.a/distToSphereCenter)*sqrt(max(0.001, sqDistToSphere - sqSphereRadius));\n    \n    float cosSphereAngularRadius = clamp(distToDisk/sqrt(distToDisk*distToDisk + \n                                        diskRadius*diskRadius), -1.0, 1.0);\n    vec3 posToSphereDirWS = posToSphereWS/distToSphereCenter;\n    \n    float sphereLighting = diskLight(coneDirWS, posToSphereDirWS, \n                                     cosSphereAngularRadius, roughness);\n    \n    //The point to light can be inside the sphere, blend to 1.0 at the center\n    if(distToSphereCenter < lightSphere.a)\n    {\n        sphereLighting = mix(1.0, sphereLighting, distToSphereCenter/lightSphere.a);\n    }\n    \n\tvisibility = sphereLighting;\n    \n    return colour * sphereLighting;\n}\n\nvec3 computeTubeLighting(vec3 posWS, vec3 coneDirWS, float roughness, \n                     vec4 startSphere, vec4 endSphere, vec3 colour,\n                     out float visibility)\n{\n    \n    vec3 startToEnd = endSphere.xyz - startSphere.xyz;\n\n    vec3 startToEndDir = normalize(startToEnd);\n    //Construct a plane going through the line and perpenticular with coneDirWS\n    vec3 planeTangent = normalize(cross(startToEndDir, -coneDirWS));\n    vec3 planeNormal = normalize(cross(planeTangent, startToEndDir));\n    vec4 plane = vec4(-planeNormal, dot(startSphere.xyz, planeNormal));\n    //Intersect the direction with that plane\n    float closestPointDistAlongRay = plaIntersect(posWS, coneDirWS, plane);\n    vec3 closesPointToTube = posWS + coneDirWS * closestPointDistAlongRay;\n    //Project the closest point on the tube to find the progress\n    vec3 startToClosest = closesPointToTube - startSphere.xyz;\n    \n    float closestDirProgress = saturate(dot(startToClosest, startToEnd)/dot(startToEnd, startToEnd));\n\n    //Closest pos on tube to lighting pos\n\tvec3 startToPos = posWS - startSphere.xyz;\n    float closestPointProgress = saturate(dot(startToPos, startToEnd) / dot(startToEnd, startToEnd));\n    \n    float progress = mix(closestDirProgress, closestPointProgress, roughness*roughness);\n\n    return computeSphereLighting(posWS, coneDirWS, roughness, \n                             mix(startSphere, endSphere, progress), colour, visibility);\n}\n\n\nvec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness, float ambientVis, float shadow)\n{\n    vec3 coneDirWS = normalize(mix(rayDirWS, normalWS, roughness*roughness*0.75));\n    \n    vec3 coalsDiskCenter = kCampfireCenterWS - oz.yxy * 0.1;\n    \n    vec3 coneIntersectedWithGround = posWS + coneDirWS * \n        -(posWS.y - coalsDiskCenter.y)/(coneDirWS.y == 0.0 ? 0.0001 : coneDirWS.y);\n    \n    float coalsDiskRadiusWS = 0.73;\n    \n    vec3 campfireToGroundPosWS = coneIntersectedWithGround - coalsDiskCenter;\n    vec3 campfireToConeGroundDirWS = normalize(campfireToGroundPosWS);\n    vec3 farDiskPointOnGroundWS = coalsDiskCenter + campfireToConeGroundDirWS * coalsDiskRadiusWS;\n\n    vec3 posToCoalsDiskCenterDirWS =  normalize(coalsDiskCenter - posWS);\n    float coalsDiskAngularRadius = (dot(normalize(farDiskPointOnGroundWS - posWS), \n                                       posToCoalsDiskCenterDirWS));\n    \n    vec3 sky = kSkyColour / (1.0 + 0.03*dot(posWS, posWS));\n\n    vec3 ambient = sky;\n    //Bounced light from the fire\n    vec3 groundAlbedo = vec3(0.2, 0.15, 0.05);\n    vec3 groundColour = groundAlbedo * (saturate(s_globalFireLife + 0.05)) * 0.05 *\n        ((kFireLightColour)/(roughness + 1.0 + dot(campfireToGroundPosWS, campfireToGroundPosWS)));\n    \n    ambient = mix(ambient, groundColour, \n                  smoothstep(0.001+roughness*1.5, -0.001-roughness*1.5, coneDirWS.y));\n\t\n    //Glow from the coals\n    ambient += shadow * 0.1 * vec3(1.0, 0.075, 0.01) * saturate(10.0 * (s_globalFireLife*0.75 + 0.25)) * \n        diskLight(coneDirWS, posToCoalsDiskCenterDirWS, coalsDiskAngularRadius, roughness);\n    \n    \n    ambient *= ambientVis;\n    \n    for(uint i = 0u; i < kNumLogs; ++i)\n    {\n\t\tfloat logLength = s_campfireLogs[i].logLength;\n        float logRadius = s_campfireLogs[i].logLength;\n        vec3 logCenterWS = s_campfireLogs[i].centerWS;\n        vec3 burnDirWS = s_campfireLogs[i].burnDirWS;\n        \n        float rand = kGoldenRatio * float(i);\n        float fireLife = s_globalFireLife - hash11(rand * 657.9759)*0.2;\n        \n        vec3 flameCenterWS = logCenterWS + burnDirWS*(saturate(fireLife)*2.0 - 1.0)*logLength;\n        \n        float sqrtFireLife = sqrt(max(0.0001, fireLife));\n        float flameHeight = max(0.15, 0.2 + fireLife*1.2);\n        flameHeight *= 0.65;\n        float flameRadius = (0.1 + sqrtFireLife)*0.2;\n        flameRadius *= 0.75;\n        //Prevent the light from going through the ground\n        flameCenterWS.y = max(flameCenterWS.y, flameRadius + 0.05);\n\n        vec4 fireBottomLight = vec4(flameCenterWS, max(0.075, flameRadius));\n        vec4 fireTopLight = vec4(flameCenterWS + oz.yxy * flameHeight, 0.01);\n        \n        float lightVisibility;\n        vec3 fireLight = computeTubeLighting(posWS, coneDirWS, roughness, fireBottomLight, fireTopLight, \n                                             kFireLightColour, lightVisibility);\n        \n        float lightIntensity = sqrt(saturate(fireLife + 0.1));\n        ambient += shadow * fireLight * lightIntensity\n            *(1.0 + sin(rand*2.0 - 10.0*s_time) * 0.35 + sin(rand*4.0 - 15.0*s_time)*0.25);\n        \n    }\n    \n    return ambient;\n}\n\nvec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness)\n{\n    return computeLighting(posWS, rayDirWS, normalWS, roughness, 1.0, 1.0);\n}\n\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n//////////////////////////// Cameras ////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\nconst float kCameraPlaneDist = 4.0;\n\nfloat kPixelConeWithAtUnitLength = 0.00;\n\nvec2 getScreenspaceUvFromRayDirectionWS(\n    vec3 rayDirectionWS,\n\tvec3 cameraForwardWS,\n\tvec3 cameraUpWS,\n\tvec3 cameraRightWS,\n\tfloat aspectRatio)\n{\n    vec3 eyeToCameraPlaneCenterWS = cameraForwardWS * kCameraPlaneDist;\n    // project rayDirectionWs onto camera forward\n    float projDist                 = dot(rayDirectionWS, cameraForwardWS);\n    vec3  eyeToPosOnCameraPlaneWS = (rayDirectionWS / projDist) * kCameraPlaneDist;\n    vec3  vecFromPlaneCenterWS       = eyeToPosOnCameraPlaneWS - eyeToCameraPlaneCenterWS;\n\n    float xDist = dot(vecFromPlaneCenterWS, cameraRightWS);\n    float yDist = dot(vecFromPlaneCenterWS, cameraUpWS);\n    \n    xDist /= aspectRatio;\n    xDist = xDist * 0.5 + 0.5;\n    yDist = yDist * 0.5 + 0.5;\n\n    return vec2(xDist, yDist);\n}\n\nvoid computeCamera(float time, vec2 mouseSNorm, vec4 iMouse, vec2 iResolution,\n                   out vec3 rayOriginWS,\n                   out vec3 cameraForwardWS,\n                   out vec3 cameraUpWS,\n                   out vec3 cameraRightWS\n                  )\n{\n    \n\tkPixelConeWithAtUnitLength = (1.0 / iResolution.y) / kCameraPlaneDist;\n    \n    //Reset to 'neutral' position if the iMouse position is 0.0\n\tif(length(iMouse.xy) < 30.0 && iMouse.z < 1.0) \n    {\n        mouseSNorm = oz.yy;\n    }\n    \n    float camMove = 0.0;\n    \n    float rotation = mouseSNorm.x * kPI * 2.;\n    rotation += time * 2.0 * kPI * 0.01;   \n    \n    rayOriginWS = vec3(-sin(rotation), 0.0, -cos(rotation))*1.;\n    rayOriginWS.y = max(0.45, 0.45 + (mouseSNorm.y + 1.0) * 0.35 + sin(time * 2.0 * kPI * 0.015)*0.1);\n    \n\tvec3 target = vec3( 0.0, 0.5, 0.0);\n    \n    cameraForwardWS = normalize(target - rayOriginWS);\n\n    cameraRightWS = normalize(cross(oz.yxy, cameraForwardWS));\n    cameraUpWS = normalize(cross(cameraForwardWS, cameraRightWS));\n    \n    rayOriginWS -= cameraForwardWS*kCameraPlaneDist;    \n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/////////////////////////////////////////////////////\n\n//Material Ids\nconst float kMatDefault = 0.0;\nconst float kMatFire = 1.0;\nconst float kMatWoodLog = 2.0;\nconst float kMatRock = 3.0;\nconst float kMatGround = 4.0;\nconst float kMatCoals = 5.0;\n\n\nvoid fFireLog(vec3 centerToPosLS, vec3 posWS, vec3 flameCenterWS, vec3 burnDirWS,\n              float logRadius, float logLength, float logRand, float fireLife,\n              bool doVolumetric,\n              out float logD, out float fireD,\n              out vec4 logMaterial, out vec4 fireMaterial)\n{    \n    float logProgress = (centerToPosLS.y/logLength)*0.5 + 0.5;\n    \n    logD = fCylinder(centerToPosLS, logRadius, logLength);\n    \n    //Log material setup\n    logMaterial.x = kMatWoodLog;\n    vec2 uv = vec2(0.5 + atan(centerToPosLS.x/centerToPosLS.z)/(kPI), logLength + centerToPosLS.y);\n    logMaterial.yz = uv + abs(logRand)*oz.xx;\n    if(abs(centerToPosLS.y / logLength) > 0.99) //End caps\n    {\n        //Compute a different UV for the end caps to get rings in the log\n        logMaterial.y = length(centerToPosLS.xz)/logRadius;\n        logMaterial.z = -1.0; //-1.0 is used to tag this as an end cap\n    }\n    \n    //Burn progress at this point on the log\n    logMaterial.w = logProgress - fireLife;\n    \n    if(!doVolumetric)\n    {\n        fireD = kMaxDist;\n        return;\n    }\n    \n    //Move the flame along the log as it burns\n    flameCenterWS += burnDirWS*(max(0.0, fireLife)*2.0 - 1.0)*logLength;\n    //Push the flame below the ground once the log is done burning\n    flameCenterWS -= oz.yxy * max(0.0, -fireLife);\n    vec3 flameToPosWS = posWS - flameCenterWS;\n    \n    //Make the flame ellipsoid wave in the wind (but less so at the bottom)\n    float flameRot = logRand*kPI + flameToPosWS.y * kPI * 2.0 - (10.0 + 3.0*hash11(logRand))*s_time;\n    float flameRotSin = sin(flameRot);\n\tflameToPosWS.x += flameToPosWS.y * 0.1 * flameRotSin;\n    flameToPosWS.z += flameToPosWS.y * 0.1 * cos(flameRot);\n    \n    float sqrtFireLife = sqrt(max(0.0, fireLife));\n    float flameHeight = max(0.001, 0.2 + fireLife*1.2);\n    float flameRadius = max(0.0001, 0.1 + sqrtFireLife)*0.2;\n    fireD = sdEllipsoidY(flameToPosWS - oz.yxy * flameHeight * 0.5, vec2(flameRadius, flameHeight));\n    \n    //Remove flame beneath the logs\n    fireD = smax(fireD, -centerToPosLS.x - logRadius, 0.2);\n    \n    float isAboveLog = (centerToPosLS.x/logRadius)*0.5 + 0.5;\n    \n    //Add some small flames around the burning log\n    float localFlame = (1.0 - saturate(abs(fireLife - logProgress)*3.0))*max(0.0, 0.3 + fireLife*0.7);\n    localFlame *= (max(0.0, isAboveLog) + 1.0);\n    float localFlameD = logD - min(0.15, localFlame*(0.1 + flameRotSin*0.02));\n    fireD = smin(fireD, localFlameD, 0.15);\n    \n    fireMaterial.y = isAboveLog;\n}\n\nvoid InitLogs(float time)\n{\n    float duration = 60.0;\n    float endTime = 80.0;\n    float normEnd = endTime/duration;\n    float normTime = mod(time/duration, normEnd*1.05);\n    float fireLife = min(1.0, 1.0 - normTime + max(0.0, (normTime - normEnd) * 30.0));\n    s_globalFireLife = fireLife;\n    \n    \n    vec3 burnDirWS;\n    float rotY, rotZ;\n    \n    //0\n    rotY = kGoldenRatio*kPI;\n    rotZ = 0.5*kPI;\n    \n    burnDirWS = oz.yxy;\n    pR(burnDirWS.xy, -rotZ);\n    pR(burnDirWS.xz, -rotY);\n    \n    s_campfireLogs[0] = CampireLog(\n        vec3(0.2, 0.1, 0.0), burnDirWS,\n        rotY, rotZ,\n        0.1/*radius*/, 0.4/*length*/\n    );\n    \n    //1\n    rotY = 2.0*kGoldenRatio*kPI;\n    rotZ = 0.41*kPI;\n    \n    burnDirWS = oz.yxy;\n    pR(burnDirWS.xy, -rotZ);\n    pR(burnDirWS.xz, -rotY);\n    \n    s_campfireLogs[1] = CampireLog(\n        vec3(0.0, 0.23, 0.0), burnDirWS,\n        rotY, rotZ,\n        0.08, 0.6\n    );\n    \n    //2\n    rotY = -kGoldenRatio*kPI;\n    rotZ = 0.28*kPI;\n    \n    burnDirWS = oz.yxy;\n    pR(burnDirWS.xy, -rotZ);\n    pR(burnDirWS.xz, -rotY);\n    \n    s_campfireLogs[2] = CampireLog(\n        vec3(0.25, 0.21, 0.1), burnDirWS,\n        rotY, rotZ,\n        0.07, 0.25\n    );\n    \n    //3\n    rotY = -4.05*kGoldenRatio*kPI;\n    rotZ = 0.325*kPI;\n    \n    burnDirWS = oz.yxy;\n    pR(burnDirWS.xy, -rotZ);\n    pR(burnDirWS.xz, -rotY);\n    \n    s_campfireLogs[3] = CampireLog(\n        vec3(0.0, 0.33, -0.1), burnDirWS,\n        rotY, rotZ,\n        0.06, 0.55\n    );\n    \n    //4\n    rotY = 0.0*kPI;\n    rotZ = 0.2*kPI;\n    \n    burnDirWS = oz.yxy;\n    pR(burnDirWS.xy, -rotZ);\n    pR(burnDirWS.xz, -rotY);\n    \n    s_campfireLogs[4] = CampireLog(\n        vec3(0.23, 0.43, 0.12), burnDirWS,\n        rotY, rotZ,\n        0.06, 0.5\n    );      \n    \n    //5\n    rotY = 0.5*kPI;\n    rotZ = 0.2*kPI;\n    \n    burnDirWS = oz.yxy;\n    pR(burnDirWS.xy, -rotZ);\n    pR(burnDirWS.xz, -rotY);\n    \n    s_campfireLogs[5] = CampireLog(\n        vec3(0.19, 0.43, 0.35), burnDirWS,\n        rotY, rotZ,\n        0.08, 0.49\n    ); \n    \n    //6\n    rotY = 0.8*kPI;\n    rotZ = 0.15*kPI;\n    \n    burnDirWS = oz.yxy;\n    pR(burnDirWS.xy, -rotZ);\n    pR(burnDirWS.xz, -rotY);\n    \n    s_campfireLogs[6] = CampireLog(\n        vec3(-0.05, 0.55, 0.26), burnDirWS,\n        rotY, rotZ,\n        0.05, 0.61\n    );     \n    \n}\n\n\n//Carve some ellipsoid shaped holes in the fire SDF\nfloat displacementFire(vec3 positionWs, float minDist, \n                       float displacementScale, float amount)\n{\n    float softenRadius = displacementScale * 0.5;\n\n    //Repeat space and carve\n    vec3 repSize = vec3(2.0, 4.0, 2.0) * displacementScale;\n    vec3 dPos = positionWs;\n    pMod3(dPos, repSize);\n    float radius = 1.0 * displacementScale * abs(amount);\n    float sphereDist = sdEllipsoidY(dPos, vec2(radius, radius*5.0));\n\n    //Do the same again but offset by half the repetition step \n    dPos = positionWs;\n    dPos += repSize * 0.5;\n    pMod3(dPos, repSize);\n    sphereDist = min(sphereDist, sdEllipsoidY(dPos, vec2(radius, radius*4.0)));\n\n    return smax(minDist, sign(amount)*sphereDist, \n                         softenRadius);\n}\n\nfloat fCampfireLogs(vec3 posWS, bool doVolumetric, out vec4 material, out float minFireD)\n{\n    float minLogD = kMaxDist;\n    minFireD = kMaxDist;\n    \n    vec4 minLogMaterial = oz.yyyy;\n\tvec4 minFireMaterial = oz.yyyy;\n    \n    //Early out of the whole thing (which is quite expensive)\n    //based on the distance to the campfire\n    vec3 campfireCenterToPosWS = posWS - kCampfireCenterWS;\n    float distToCampfireXZ = length(campfireCenterToPosWS.xz) - 0.65;\n    if(distToCampfireXZ > 0.25)\n    {\n        minLogD = distToCampfireXZ;\n        minFireD = minLogD;\n    }\n    else\n    {  \n        for(uint i = 0u; i < kNumLogs; ++i)\n        {\n            vec3 logCenterWS = s_campfireLogs[i].centerWS;\n            vec3 centerToPosLS = posWS - logCenterWS;\n            pR(centerToPosLS.xz, s_campfireLogs[i].rotationY);\n            pR(centerToPosLS.xy, s_campfireLogs[i].rotationZ);\n            vec3 burnDirWS = s_campfireLogs[i].burnDirWS;\n\n            float rand = kGoldenRatio * float(i);\n            float fireLife = s_globalFireLife - hash11(rand * 657.9759)*0.2;\n\n            vec4 logMaterial, fireMaterial;\n            float logD, fireD;\n            fFireLog(centerToPosLS, posWS, logCenterWS, burnDirWS, \n                     s_campfireLogs[i].logRadius, s_campfireLogs[i].logLength,\n                     rand, fireLife,\n                     doVolumetric, \n                     logD, fireD,\n                     logMaterial, fireMaterial);\n\n            if(logD < minLogD)\n            {\n                minLogD = logD;\n                minLogMaterial = logMaterial;\n            }\n\n            if(fireD < minFireD)\n            {\n                minFireD = fireD;\n                minFireMaterial = fireMaterial;\n            }\n        }\n    }\n    \n    float logDispScale = 0.025;\n    float logDispSoften = 0.15;\n    \n    \n    //Sticks on the ground\n    float stickScale = 0.25;\n    \n    vec3 stickPos = posWS + oz.xyx * 1.5;\n    vec2 stickId = pMod2(stickPos.xz, oz.xx * 7.0 * stickScale);\n    float stickRand = hash12(stickId * 39.6897);\n    pR(stickPos.xz, stickRand * kPI);\n    \n    float stickRadius = (0.04 + stickRand * 0.015) * stickScale;\n    float stickLength = (0.75 + stickRand * 0.4) * stickScale;\n    stickPos.y -= stickRadius + min(0.0, dot(posWS, posWS) * 0.01 - 0.02);\n    \n    stickPos.xz += stickRand * oz.xx * 2.0 * stickScale;\n    \n    float stickD = fCylinder(stickPos.xzy, stickRadius, stickLength);\n    if(stickD < minLogD)\n    {\n        minLogD = stickD;\n        \n        minLogMaterial.x = kMatWoodLog;\n        vec2 uv = vec2(0.5 + atan(stickPos.x/stickPos.y)/(kPI), stickPos.z);\n        minLogMaterial.yz = uv + stickRand*oz.xx;\n        minLogMaterial.w = -1.0;\n        \n        logDispScale = 0.015;\n        logDispSoften = 0.05;\n    }\n    \n    //Logs & sticks displacement\n    vec3 dispPos = posWS;\n    pMod3(dispPos, oz.xxx * logDispScale * 11.0);\n    float dispD = fSphere(dispPos, logDispScale);\n    minLogD = smin(minLogD, smax(minLogD-logDispScale, dispD, logDispSoften), logDispSoften);\n    \n    if(doVolumetric)\n    {\n        minFireMaterial.x = kMatFire;\n        \n        //Fire displacement (only do it when we're close enough for it to matter)\n        if(minFireD < 0.25)\n        {\n            float displacedFireD = minFireD;\n            float dispAmount = min(1.0, 0.2 + (max(0.001, posWS.y))*0.45);\n            vec3 windDisp = vec3(0.03, 1.0, -0.02) * 3.0 * s_time;\n            vec3 dispPosWS = posWS - windDisp;\n\n            float isUnderLog = minFireMaterial.y;\n\n            displacedFireD = displacementFire(dispPosWS, displacedFireD, 0.2, -dispAmount);\n\n            dispPosWS = posWS + oz.xxx * 16.6798 - windDisp * 0.5;\n\n            displacedFireD = displacementFire(\n                dispPosWS, displacedFireD, 0.07, \n                -(0.0001 + saturate(isUnderLog*1.0))*linearstep(-0.1, 0.0, minFireD));\n\n            \n            minFireMaterial.y = saturate(linearstep(0.05, 0.0, minLogD*minLogD)\n                                         * (linearstep(-0.00, -0.05, displacedFireD)));\n\n            minFireD = displacedFireD;\n        }\n        \n        //Sparks\n        if(s_globalFireLife > 0.0)\n        { \n            vec3 posSparks = posWS - kCampfireCenterWS - oz.yxy * (0.3 * s_globalFireLife + 0.1);\n\n            float sparkId = pModPolar(posSparks.xz, 5.0);\n            pR(posSparks.xy, kPI * 0.15);\n\n            float sparkRand = hash11(sparkId*937.959);\n            float sparksAnimDuration = 5.0;\n            float sparkAnim = fract(s_time / sparksAnimDuration + sparkRand);\n            float sparksSpeed = sparksAnimDuration * 4.0 * max(0.7, 2.0*s_globalFireLife);\n            float sparkTravel = sparkAnim*sparksSpeed;\n\n            //Compute start and end  pos and draw a capsule in between (for motion blur effect)\n            vec3 posSparksStart = oz.xyy * sparkTravel;\n            vec3 posSparksEnd = oz.xyy * sparkTravel;\n\n            float rotationT = (sparkRand + sparkAnim)*sparksSpeed*2.5;\n            posSparksStart.xz += vec2(sin(rotationT), cos(rotationT)) * \n                (0.15 + sparkAnim * 0.5);\n            posSparksStart.y += cos(rotationT * 0.5) * (sparkAnim*0.3 + 0.2);\n\n            float sparkAnimDelta = min(0.033, iTimeDelta*kTimeScale) / sparksAnimDuration;\n            sparkAnim -= sparkAnimDelta;\n            \n            rotationT = (sparkRand + sparkAnim)*sparksSpeed*2.5;\n\n            posSparksEnd.x -= sparkAnimDelta*sparksSpeed;\n\t\t\tposSparksEnd.xz += vec2(sin(rotationT), cos(rotationT)) * \n                (0.15 + sparkAnim * 0.5);\n            posSparksEnd.y += cos(rotationT * 0.5) * (sparkAnim*0.3 + 0.2);\n\n            float sparksD = fCapsule(posSparks, posSparksStart, posSparksEnd, 0.01);\n            if(sparksD < minFireD)\n            {\n                minFireD = sparksD;\n                float sparkStrength = 0.5 + sparkRand * 2.0;\n                minFireMaterial.y = max(0.0, sparkStrength - 15.0*sparkAnim) * \n                    linearstep(0.0, -0.01, sparksD);\n                //Make the sparks dimmer as the fire dies out\n                minFireMaterial.y *= saturate(2.0*s_globalFireLife);\n            }\n        }\n    }\n    \n    if(minLogD > 0.01 && minFireD < minLogD)\n    {\n        material = minFireMaterial;\n        return minFireD;\n    }\n    else\n    {\n        material = minLogMaterial;\n        return minLogD;\n    }\n}\n\n//10 Rocks in a circle\nfloat fCampfireRocks(vec3 posWS, out vec4 material)\n{\n    float minDist = kMaxDist;\n    \n    material.x = kMatRock;\n    material.yzw = oz.yyy;\n    \n    //When far away, use a cheaper disk slab SDF\n    vec3 campfireCenterToPosWS = posWS - kCampfireCenterWS;\n    float distToCampfireXZ = length(campfireCenterToPosWS.xz) - 1.0;\n    float distToCampfire = max(distToCampfireXZ, campfireCenterToPosWS.y - 0.25);\n    if(distToCampfire > 0.25)\n    {\n        return distToCampfire;\n    }\n    vec3 campfireToPos = posWS - kCampfireCenterWS;\n    \n    //First 5 rocks\n    vec3 rockToPos = campfireToPos;\n    float id = pModPolar(rockToPos.xz, 5.0);\n    float modRand = hash11(id * 97.5887);\n    float modRandSNorm = modRand*2.0 - 1.0;\n    \n    vec3 rockDims = vec3(0.22 + modRandSNorm*0.05, \n                         0.13 - modRandSNorm*0.04, \n                         0.27);\n    \n    rockToPos.x -= 0.88;\n    rockToPos.y -= rockDims.y*0.5;\n    \n    material.yz = 4.0 * computeParaboloidUv(normalize(rockToPos)) + modRand*oz.xx;\n    minDist = sdEllipsoid(rockToPos, rockDims);\n\n    //Another set of 5 rocks\n    rockToPos = campfireToPos;\n    pR(rockToPos.xz, 0.2 * kPI);\n    id = pModPolar(rockToPos.xz, 5.0);\n    modRand = hash11((2.0 + id) * 97.5887);\n    modRandSNorm = modRand*2.0 - 1.0;\n    \n\trockDims = vec3(0.2 + modRandSNorm*0.05, \n                    0.14 - modRandSNorm*0.03, \n                    0.26 + modRandSNorm*0.03);\n    \n    rockToPos.x -= 0.75;\n    rockToPos.y -= rockDims.y*0.5;\n    \n    float rockD = sdEllipsoid(rockToPos, rockDims);\n    if(rockD < minDist)\n    {\n        material.yz = 4.0 * computeParaboloidUv(normalize(rockToPos)) + modRand*oz.xx;\n        minDist = rockD;\n    }\n    \n    //Rocks displacement\n    vec3 dispPos = posWS;\n    float dispScale = 0.1;\n    pMod3(dispPos, oz.xxx * dispScale * 3.0);\n    float dispD = fSphere(dispPos, dispScale);\n    \n    dispPos = posWS;\n    dispScale = 0.125;\n    pMod3(dispPos, oz.xxx * dispScale * 3.5);\n    dispD = min(dispD, fBoxCheap(dispPos, oz.xxx*dispScale));\n    \n    minDist = smin(minDist+dispScale*0.5, smax(minDist - dispScale*0.25, -dispD, 0.15), 0.05);     \n        \n \treturn minDist;   \n}\n\nfloat fCoals(vec3 posWS, out vec4 material)\n{\n    material.x = kMatCoals;\n    material.yzw = oz.yyy;\n    \n    vec3 campfireToPosWS = posWS - kCampfireCenterWS;\n    \n    //When far away, use a cheaper disk slab SDF\n    float distToCampfireXZ = length(campfireToPosWS.xz) - 0.65;\n    float distToCampfire = max(distToCampfireXZ, campfireToPosWS.y - 0.1);\n    if(distToCampfire > 0.25)\n    {\n        return distToCampfire;\n    }\n    \n    //First set of coals\n    vec3 pCoal = campfireToPosWS;\n    //Push them underground as they get away from the center of the campfire\n    pCoal.y += dot(campfireToPosWS, campfireToPosWS)*0.2 - 0.035;\n    vec2 id = pMod2(pCoal.xz, oz.xx * 0.15) * 967.045;\n    float coalRand = hash12(id);\n    pR(pCoal.xz, coalRand * 2.0 * kPI);\n    float coalD = fCapsule(pCoal.xzy, 0.03, 0.05);\n    \n    material.y = coalRand;\n    material.zw = computeParaboloidUv(normalize(pCoal)) + coalRand*oz.xx;\n    \n    //Second set of coals, slightly smaller\n    pCoal = campfireToPosWS;\n    pCoal.y += dot(campfireToPosWS, campfireToPosWS)*0.25 - 0.035;\n    pCoal.xz += oz.xx*0.16895;\n    id = pMod2(pCoal.xz, oz.xx * 0.12) *  739.2397;\n    coalRand = hash12(id);\n    pR(pCoal.xz, coalRand * 1.0 * kPI);\n    float coalAltD = fCapsule(pCoal.xzy, 0.025, 0.04);\n    \n    if(coalAltD < coalD)\n    {\n        coalD = coalAltD;\n        material.y = coalRand;\n        material.zw = computeParaboloidUv(normalize(pCoal)) + coalRand*oz.xx;\n    }\n    \n    return coalD;\n}\n\nfloat fSDF(vec3 posWS, bool doVolumetric, out vec4 material)\n{\n    float minDist = kMaxDist;\n    \n    vec2 groundUv = posWS.xz + oz.xx*3.0;\n    float groundNormalisedDisp = 0.0;\n    if(posWS.y < 0.3)\n    {\n        groundNormalisedDisp = textureLod(iChannel2, groundUv * 0.05, 0.0).r;\n    }\n    \n    float fireD;\n    vec4 campfireLogsMaterial;\n    float campfireLogsD = fCampfireLogs(posWS, doVolumetric, campfireLogsMaterial, fireD);\n    if(campfireLogsD < minDist)\n    {\n        minDist = campfireLogsD;\n        material = campfireLogsMaterial;\n    }\n    \n    \n    vec4 campfireRocksMaterial;\n    float campfireRocksD = fCampfireRocks(posWS, campfireRocksMaterial);\n    //Add some extra noise to the rocks distance\n    campfireRocksD -= groundNormalisedDisp * 0.02;\n    if(campfireRocksD < minDist)\n    {\n        minDist = campfireRocksD;\n        material = campfireRocksMaterial;\n    }\n    \n    vec4 coalsMaterial;\n    float coalsD = fCoals(posWS, coalsMaterial);\n    //Fatten the coals using the ground displacement texture to randomize their shape\n    coalsD -= groundNormalisedDisp * 0.035; \n   \tif(coalsD < minDist)\n    {\n        minDist = coalsD;\n        material = coalsMaterial;\n        material.y = fireD + (material.y  - 0.5)*0.5;\n    }\n    \n    //Ground plane\n    float groundDisp = groundNormalisedDisp * 0.05;\n    float groundD = posWS.y - groundDisp;\n\n    if(groundD < minDist)\n    {\n\t    material.x = kMatGround;\n    \tmaterial.yz = groundUv;\n    \tfloat ambientVis = 0.99 * linearstep(0.0, 0.1, campfireRocksD);\n        \n    \tvec2 uv = material.yz;\n        material.w = groundNormalisedDisp;\n        \n        //Pack the ambient and the material in W\n        material.w = floor(material.w * 256.0) + ambientVis;\n        minDist = groundD;\n    }    \n    \n    return minDist;\n}\n\nfloat fSDF(vec3 posWS)\n{\n    vec4 mat;\n    return fSDF(posWS, true, mat);\n}\n\n\n//Extra SDF 'Update' pass only call when we compute the normal to add additional details\nfloat fMaterialSDF(float dist, vec4 material)\n{\n    if(abs(material.x - kMatWoodLog) < 0.1)\n    {\n        vec2 uv = material.yz;\n        float bark = textureLod(iChannel1, uv * 0.05, 0.0).r;\n        bark += 0.5 * textureLod(iChannel1, uv * 0.1, 0.0).r;\n        float isBark = step(-0.5, uv.y);\n        dist -= bark*(0.025*isBark + 0.005);\n    }\n    else if(abs(material.x - kMatRock) < 0.1)\n    {\n        vec2 uv = material.yz;\n        float rock = textureLod(iChannel1, uv * 0.04, 0.0).r;\n        dist -= rock*0.02;\n    }\n    else if(abs(material.x - kMatCoals) < 0.1)\n    {\n        vec2 uv = material.zw;\n        float disp = textureLod(iChannel1, uv * 0.04, 0.0).r;\n        dist -= disp*0.05;\n    }\n    else if(abs(material.x - kMatGround) < 0.1)\n    {\n        float groundMat = floor(material.w)/256.0;\n    \tvec2 uv = material.yz;\n        float disp = 0.0;\n        disp += 0.25*textureLod(iChannel2, uv * 0.25, 0.0).r;\n        disp += 0.15*textureLod(iChannel2, uv * 0.45, 0.0).r;\n        dist -= disp * 0.1 * (1.0 - groundMat);\n        \n        float rock = textureLod(iChannel1, uv * vec2(0.25, 0.1), 0.0).r;\n        dist -= rock*0.025*groundMat;\n    }\n    \n    return dist;\n}\n\nvec3 getNormalWS(vec3 p, float dt)\n{\n    vec3 normalWS = oz.yyy;\n    for( int i = NON_CONST_ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec4 mat;\n        float dist = fSDF(p + e * dt, false, mat);\n        normalWS += e*fMaterialSDF(dist, mat);\n    }\n    return normalize(normalWS);    \n}\n\nfloat computeVolumetricTransmittance(vec4 material, float mediumD, float stepD)\n{\n    float density = max(0.001, -mediumD*40.0);\n    return exp(-stepD * density * 1.0);\n}\n\nvec4 computeVolumetricLighting(vec4 material, float mediumD, float stepD, vec4 insTrans)\n{\n    vec3 emissiveColour = blackBodyToRGB(2500.0 + material.y * 2500.0, 3000.0);\n    float stepTransmittance = computeVolumetricTransmittance(material, mediumD, stepD);\n    insTrans.rgb += insTrans.a *\n        (1.0 - stepTransmittance) * emissiveColour;\n    insTrans.a *= stepTransmittance;\n    \n    return insTrans;\n}\n\n#define ITER 128\nfloat march(vec3 ro, vec3 rd, out vec4 outMaterial, out vec4 outInscatterTransmittance)\n{\n    float t = 0.001;\n \tfloat d = 0.0;\n    \n    outInscatterTransmittance = oz.yyyx;\n    \n    for(int i = NON_CONST_ZERO; i < ITER; ++i)\n    {\n        float coneWidth = kPixelConeWithAtUnitLength * t;\n        \n        vec3 posWS = ro + rd*t;\n        d = fSDF(posWS, true, outMaterial);\n        \n        if(outMaterial.x == kMatFire && d < coneWidth)\n        {\n            float mediumD = d;\n            d = max(0.01, abs(d))*(s_pixelRand*0.5 + 0.75) + coneWidth;\n            \n            outInscatterTransmittance = \n                computeVolumetricLighting(outMaterial, mediumD, d, outInscatterTransmittance);\n        }\n        \n        t += d;\n        \n        if(i >= ITER - 1)\n        {\n            t = kMaxDist;\n        }              \n        \n\n        if(d < coneWidth || t >= kMaxDist)\n        {\n            break;\n        }\n    }\n      \n    return t;\n}\n\n#define ITER_SHADOW 8\n\nfloat marchShadow(vec3 ro, vec3 rd, float t, float mt, float tanSourceRadius)\n{\n \tfloat d;\n    float minVisibility = 1.0;\n    \n    vec4 material;\n    \n    for(int i = NON_CONST_ZERO; i < ITER_SHADOW && t < mt; ++i)\n    {\n        float coneWidth = max(0.0001, tanSourceRadius * t);\n        \n        vec3 posWS = ro + rd*t;\n        d = fSDF(posWS, false, material) + coneWidth*0.5;\n        \n        minVisibility = min(minVisibility, (d) / max(0.0001, coneWidth*1.0));\n        t += d;\n        \n        if(i >= ITER_SHADOW - 1)\n        {\n            t = mt;\n        }              \n        \n        if(minVisibility < 0.01)\n        {\n            minVisibility = 0.0;\n        }\n    }\n      \n    return smoothstep(0.0, 1.0, minVisibility);\n}\n\nfloat getFireShadow(vec3 posWS)\n{\n    float fireLife = max(0.0, s_globalFireLife);\n    vec3 fireLightPosWS = vec3(0.0, 0.05 + fireLife*0.35, 0.0);\n    \n    float lightAnim = s_time * 15.0;\n    float lightAnimAmpl = 0.02;\n    fireLightPosWS.x += lightAnimAmpl * sin(lightAnim);\n    fireLightPosWS.z += lightAnimAmpl * cos(lightAnim);\n    \n    float fireLightRadius = 0.7 - fireLife * 0.25;\n    \n    vec3 posToFireWS = fireLightPosWS - posWS;\n    float posToFireLength = length(fireLightPosWS - posWS);\n    vec3 posToFireDirWS = posToFireWS / max(0.0001, posToFireLength);\n    \n    float distToLight = posToFireLength-fireLightRadius;\n    \n    if(distToLight < 0.0)\n    {\n        return 1.0;\n    }\n    \n    float lightTanAngularRadius = fireLightRadius / max(0.0001, posToFireLength);\n    \n    return marchShadow(posWS, posToFireDirWS, 0.001, \n                       max(0.0, posToFireLength-fireLightRadius), lightTanAngularRadius);\n}\n\nvec3 computeLighting(\n    vec3 posWS,\n    vec3 rayDirWS,\n    vec3 normalWS,\n    vec3 albedo,\n    vec3 f0Reflectance,\n    float roughness,\n    vec4 emissive,\n    float ambient\n)\n{\n    if(emissive.a > 0.999)\n    {\n        return emissive.rgb;\n    }\n    \n    float shadow = getFireShadow(posWS + normalWS * 0.02);\n    vec3 reflectedRayDirWS = reflect(rayDirWS, normalWS);\n    float rDotN = max(0.0001, dot(reflectedRayDirWS, normalWS));\n    vec3 fresnelReflectance = roughFresnel(f0Reflectance, rDotN, roughness);\n\n    vec3 diffuse = albedo * computeLighting(posWS, normalWS, normalWS, 1.0, ambient, shadow);\n    vec3 specular = computeLighting(posWS, reflectedRayDirWS, normalWS, roughness, ambient, shadow);\n    vec3 surfaceLighting = mix(diffuse, specular, fresnelReflectance);\n    return surfaceLighting * (1.0 - emissive.a) + emissive.rgb;\n}\n\nvec3 computeSceneColour(vec3 endPointWS, vec3 rayDirectionWS, float marchedDist,\n                       vec4 material)\n{\n    float normalDt = 0.001 + kPixelConeWithAtUnitLength * marchedDist;\n    vec3 normalWS = getNormalWS(endPointWS, normalDt);\n    normalWS = fixNormalBackFacingness(rayDirectionWS, normalWS);\n\n    vec3 albedo = oz.xyx;\n    vec3 f0Reflectance = oz.xxx * 0.04;\n    float roughness = 0.6;\n    vec4 emissive = oz.yyyy;\n    float ambient = 1.0;\n\n    const vec3 woodAlbedo = vec3(0.15, 0.07, 0.02);\n\n    if(abs(material.x - kMatDefault) < 0.1)\n    {\n        roughness = material.y;\n        float metallicness = material.z;\n\n        albedo = 0.5 * oz.xxx;\n\n        f0Reflectance = mix(0.04*oz.xxx, oz.xxx, metallicness);\n        albedo *= 1.0 - metallicness;\n    }\n    else if(abs(material.x - kMatWoodLog) < 0.1)\n    {\n        vec2 matUv = material.yz;\n        vec3 woodTex = textureLod(iChannel1, matUv * 0.05, 0.0).rgb;\n        albedo = woodAlbedo;\n        albedo *= woodTex;\n\n        float barkNoise = textureLod(iChannel1, matUv * vec2(0.05, 0.25), 0.0).r;\n        float cracks = linearstep(0.5, 0.75, barkNoise);\n        float ash = linearstep(0.45, 0.55, 1.0 - barkNoise);\n        float isOuterLayer = material.z < -0.999 ? material.y : 1.0;\n\n        material.w += (woodTex.r - cracks*2.0) * 0.2;\n        float burnFactor = saturate(material.w*5.0);\n        float burntFactor = saturate(material.w*5.0 - 0.2);\n        float emissiveStrength = (linearstep(1.0, 0.5, woodTex.r)) * \n            max(0.0, s_globalFireLife*0.75 + 0.25) * linearstep(0.3, 0.8, isOuterLayer);\n        emissive = mix(oz.yyyy, vec4(vec3(1.5, 0.07, 0.005)*emissiveStrength, 1.0), burnFactor);\n\n        emissive = mix(emissive, oz.yyyy, burntFactor);\n        vec3 burntAlbedo = mix(oz.yyy, oz.xxx * 0.5, ash);\n        albedo = mix(albedo, burntAlbedo, burnFactor);\n\n        roughness = mix(0.8, 0.975, burnFactor);\n    }\n    else if(abs(material.x - kMatRock) < 0.1)\n    {\n        //Where the rock normal points down will be the contact with the ground\n        //We're likely to get shadows/AO there, do reduce the ambient (sky and ground bounce)\n        ambient = linearstep(-0.6, -0.0, normalWS.y);\n        vec2 matUv = material.yz;\n        vec3 rockTex = textureLod(iChannel2, matUv * 0.1, 0.0).rgb;\n        albedo = rockTex*0.25;\n\n        float soot = smoothstep(0.5, -0.1, dot(normalWS, normalize(oz.yxy*0.5 - endPointWS)));\n        albedo *= (0.05 + 0.95*soot);\n        roughness = 0.6 + soot*0.35;\n    }\n    else if (abs(material.x - kMatGround) < 0.1)\n    {\n        float groundMat = floor(material.w)/256.0;\n        ambient = fract(material.w);\n\n        vec2 matUv = material.yz;\n        vec3 albedoTex = textureLod(iChannel1, matUv * 0.5, 0.0).rgb;\n        float grass = linearstep(0.4, 0.7, albedoTex.r);\n        albedo = mix(vec3(0.07, 0.035, 0.005), vec3(0.01, 0.05, 0.0005), grass);\n\n        float rockBlend = linearstep(0.45, 0.5, groundMat);\n        albedo = mix(albedo, albedoTex.rrr*oz.xxx*0.2, rockBlend);\n        roughness = mix(0.85, 0.775, grass);\n        roughness = mix(roughness, 0.6, rockBlend);\n    }\n    else if (abs(material.x - kMatCoals) < 0.1)\n    {\n        float noise = textureLod(iChannel1, endPointWS.xz, 0.0).r;\n        noise *= noise;\n        albedo = oz.yyy;\n        roughness = 0.95;\n        \n        float randBurnStrength = material.y;\n        //material W is the distance to the fire logs\n        float isBurning = linearstep(0.075, -0.05, randBurnStrength);\n        isBurning *= noise * linearstep(0.3, 0.8, normalWS.y);\n        isBurning *= max(0.0, 1.0 - s_globalFireLife*dot(endPointWS, endPointWS)*8.0);\n        float emissiveStrength = 1.5 * max(0.0, s_globalFireLife*0.75 + 0.25);\n        emissive = vec4(vec3(1.5, 0.05, 0.005) * emissiveStrength, 1.0) * isBurning;\n    }\n\n    vec3 sceneColour = computeLighting(endPointWS, rayDirectionWS, normalWS, albedo, \n                                  f0Reflectance, roughness, emissive, ambient);\n    \n    return sceneColour;\n}\n\n#define TAA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float framerateBasedTaaStrength = 1.0 - saturate((iTimeDelta - 0.066) / 0.033);\n    \n    vec2 subPixelJitter = fract(hash22(fragCoord)\n                                + float(iFrame%256) * kGoldenRatio * oz.xx) - 0.5*oz.xx;\n    s_time = iTime * kTimeScale;\n    s_pixelRand = subPixelJitter.x;\n    \n    InitLogs(s_time);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float jitterAmount = float(TAA) * (iMouse.z > 0.1 ? 0.0 : 1.0) * framerateBasedTaaStrength;\n\tvec2 uvJittered = (fragCoord.xy + jitterAmount * subPixelJitter) / iResolution.xy;\n    \n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 uvNorm = uvJittered * 2.0 - vec2(1.0);\n    uvNorm.x *= aspectRatio;\n    \n    vec2 mouseUNorm = iMouse.xy/iResolution.xy;\n    vec2 mouseNorm = mouseUNorm*2.0 - vec2(1.0);\n    \n    vec3 rayOriginWS;\n    \n    // ---- Camera setup ---- //\n    vec3 cameraForwardWS, cameraUpWS, cameraRightWS;\n    computeCamera(s_time, mouseNorm, iMouse, iResolution.xy, \n                  /*outs*/rayOriginWS, cameraForwardWS, cameraUpWS, cameraRightWS);\n    vec3  rayDirectionWS = normalize(uvNorm.x*cameraRightWS + uvNorm.y*cameraUpWS + \n                                     kCameraPlaneDist*cameraForwardWS);\n    \n    vec4 inscTrans;\n    vec4 material;\n    float marchedDist = march(rayOriginWS, rayDirectionWS, material, inscTrans);\n    \n    vec3 endPointWS = rayOriginWS + rayDirectionWS * marchedDist;\n\n    vec3 cubemap = textureLod(iChannel3, rayDirectionWS, 0.0).rgb;\n    vec3 skyColour = max(0.0, rayDirectionWS.y) * cubemap * kSkyColour;\n    vec3 sceneColour = skyColour;\n    \n    if(marchedDist < kMaxDist)\n    {\n        sceneColour = computeSceneColour(endPointWS, rayDirectionWS, marchedDist, material);\n    }\n    \n    sceneColour = sceneColour * inscTrans.a + inscTrans.rgb;\n    \n    //Enable this to see how the lighting works\n#if 0\n    if(uv.x > 0.5 && iMouse.z > 0.1)\n    {\n        vec3 p = rayOriginWS;// + rayDirectionWS * marchedDist;\n        sceneColour = computeLighting(p, rayDirectionWS, rayDirectionWS, sin(iTime)*0.5 + 0.5, 1.0, 1.0);\n    }\n#endif    \n\n    // ---- TAA part ---- //\n    float taaStrength = 1.0 - min(1.0, inscTrans.r*100.0);\n    taaStrength *= framerateBasedTaaStrength;\n    \n    //Compuute the previous frame camera\n    float prevTime = s_time - iTimeDelta*kTimeScale;\n    vec3 prevCameraPosWS, prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS;\n    computeCamera(prevTime, mouseNorm, iMouse, iResolution.xy, prevCameraPosWS, \n                  prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS);\n    \n    vec3 currentRefPosWS = endPointWS;\n    vec3 prevCameraRayDirWS = normalize(currentRefPosWS - prevCameraPosWS);\n    \n    //Work back to get the previous frame uv\n    vec2 prevFrameUv = getScreenspaceUvFromRayDirectionWS(prevCameraRayDirWS,\n    \tprevCameraForwardWS, prevCameraUpWS, prevCameraRightWS, aspectRatio);\n\tprevFrameUv = (prevFrameUv * iResolution.xy - jitterAmount * subPixelJitter) / iResolution.xy;\n    \n    \n    if(any(greaterThan(abs(prevFrameUv - 0.5*oz.xx), 0.5*oz.xx)))\n    {\n        taaStrength = 0.0;;\n    }\n    \n    if(iMouse.z > 0.01)\n    {\n        taaStrength = 0.25;\n        prevFrameUv = uv;\n    }\n    \n    vec4 prevData = textureLod(iChannel0, prevFrameUv, 0.0);\n    \n    float prevTaaStrength = fract(prevData.a);\n    float prevQuantisedMarchedDist = (prevData.a);\n    //Reduce the amount of TAA of the current and previous marched distances are significantly different\n    //This prevents 'dissoclusion' trails\n    taaStrength *= 1.0 - saturate(abs(marchedDist - prevQuantisedMarchedDist) - 1.0);\n    \n    float blendToCurrent = mix(1.0, 1.0/8.0, taaStrength);\n    taaStrength = mix(prevTaaStrength, taaStrength, blendToCurrent);\n    blendToCurrent = mix(1.0, 1.0/8.0, taaStrength);\n    \n    \n#if !TAA    \n    blendToCurrent = 1.0;\n#endif\n    \n    \n    sceneColour = max(oz.yyy, mix(prevData.rgb, sceneColour, blendToCurrent));\n    //Prevent super bright highlights\n    sceneColour = min(oz.xxx * 6.0, sceneColour);\n    \n    float quantisedDist = floor(marchedDist);\n    \n    fragColor = vec4(sceneColour, quantisedDist + 0.999*taaStrength);\n}","name":"Buffer A","description":"","type":"buffer"}]}