{"ver":"0.1","info":{"id":"ldtGWB","date":"1452065560","viewed":262,"name":"Spiral Ring","username":"gaz","description":"3d","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spiral","de"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define PI\t3.14159265359\n\nmat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat deQuad(vec2 p) {\n\tp = abs(p);\n\treturn max(p.x, p.y);\n}\n\nfloat deHex(vec2 p) {\n\tp = abs(p);\n\treturn max((2.0/sqrt(3.0))*p.x, (1.0/sqrt(3.0))*p.x + p.y);\n}\n\nfloat deTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat deQuadTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return deQuad(q)-t.y;\n}\n\nfloat deHexTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return 0.8 * (deHex(q)-t.y);\n}\n\nfloat deSliceTorus(in vec2 p, in vec2 t, in float a)\n{\n    vec3 pos = vec3(p, 0.0).xzy;\n    pos.yz *= rotate(a);\n    return deTorus(pos, t);\n}\n\nfloat deQuadSliceTorus(in vec2 p, in vec2 t, in float a)\n{\n    vec3 pos = vec3(p, 0.0).xzy;\n    pos.yz *= rotate(a);\n    return deQuadTorus(pos, t);\n}\nfloat deHexSliceTorus(in vec2 p, in vec2 t, in float a)\n{\n    vec3 pos = vec3(p, 0.0).xzy;\n    pos.yz *= rotate(a);\n    return deHexTorus(pos, t);\n}\n\nvec3 opTorusTwist(in vec3 p, in float r, in float t)\n{     \n    float a = atan(p.z, p.x);\n    p.xz *= rotate(a);\n    p.x -= r;\n    p.xy *= rotate(a * t);\n    return p;\n}\n\nfloat de1(in vec3 p)\n{\n    p.yx *= rotate(PI/2.0);   \n    p.zx *= rotate(iTime * -0.02); \n    p  = opTorusTwist(p, 3.0, 10.0);\n    return deQuadSliceTorus(p.xy, vec2(0.8, 0.1), 0.35);  \n}\n\nfloat de2(in vec3 p)\n{\n    p.yz *= rotate(iTime * 0.15); \n    p.z += 20.0;\n    p.xy *= rotate(sin(iTime * 0.15)); \n    p  = opTorusTwist(p, 20.0, 20.0);\n    return deHexSliceTorus(p.xy, vec2(0.8, 0.2), 0.7);    \n}\n\nfloat de3(in vec3 p)\n{\n    p.z -= 3.2;\n \treturn length(p) - 0.35;   \n}\n\nfloat map(in vec3 p)\n{    \n    return min(min(de1(p), de2(p)),de3(p));\n}\n\nvec3 doColor(in vec3 p)\n{\n    float d1 = de1(p);\n    float d2 = de2(p);\n    float d3 = de3(p);\n    if (d1 < d2 && d1 < d3) \n    {\n        p.y -= iTime * 0.07;\n        return mix(texture(iChannel0, p.xy * 10.0).rgb ,\n         vec3(0.9, 0.5, 0.2),0.5);        \n    } else if (d2 < d3){\n    \treturn mix(texture(iChannel0, p.xy).rgb ,\n    \t\tvec3(0.5, 0.6, 0.2),0.5);\n    } else {\n    \tp.x -= iTime * 0.1;\n        p.y -= iTime * -0.05;\n        return mix(texture(iChannel0, p.xy).rgb ,\n    \t\tvec3(0.5, 0.6, 0.5),0.8);\n    }\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) +   \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 50.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis || t > maxd) break;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvec3 bg(in vec2 p , in vec2 fragCoord)\n{   \n    vec3 col = 0.2* texture(iChannel0, \n    \t3.0 * vec2(inversesqrt(length(p)), atan(p.x, p.y) * 0.2 -iTime*0.005)).rgb;\n    col = clamp(col, 0.0, 0.6);  \t\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = bg(p, fragCoord);\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(p, -2.0));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(2.0, 2.0, 3.0));\n    \tcol = doColor(pos);\n        col *= max(dot(li, nor), 0.2);\n        col *= exp(-0.001 * pos.z * pos.z);\n        float sh = clamp(softshadow(pos, li), 0.4, 1.0);\n        col *= sh;\n        if (sh > 0.8) col += pow(max(dot(vec3(0.0, 0.0, 1.0), reflect(-li, nor)), 0.0), 60.0);\n        col = pow(col, vec3(0.8)); \n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}