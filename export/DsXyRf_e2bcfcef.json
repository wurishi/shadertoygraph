{"ver":"0.1","info":{"id":"DsXyRf","date":"1687053926","viewed":75,"name":"anxiety about time","username":"kindlion","description":"I figured making digits in Shadertoy would be a nice challenge.\n\nI also want to evoke the anxiety that comes from an over awareness of time.\nThe digits transition in 0.8 seconds, slightly faster than what we're accustomed to from normal timers.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["clock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Line {\n  vec2 a;\n  vec2 b;\n};\n\n\nconst float SEGMENT_LENGTH = 0.2;\n\n// Draws an elongated hexagon.\nfloat hexagon(vec2 point, Line line) {\n\n    // Project `point` onto `line`.\n    vec2 pa = point - line.a;\n    vec2 ba = line.b - line.a;\n    \n    // `percent` is the percent along the line the projection is.\n    float percent = dot(pa, ba) / dot(ba, ba);\n    vec2 projection = percent * ba + line.a;\n    float dist = length(point - projection);\n    \n    const float TAPER = 0.1;\n    const float WIDTH = TAPER * SEGMENT_LENGTH;\n\n    // Make the actual hexagon. As `percent` increases, `width` starts at 0,\n    // increases linearly until percent=TAPER, when width = WIDTH, and stays there until\n    // `percent = 1 - TAPER`, then it decreases linearly until 0.\n    float width = WIDTH * clamp(min(percent/TAPER, (1.-percent)/(TAPER)), 0., 1.);\n \n    //return smoothstep(0., WIDTH, width - dist);\n    return dist > width ? 0. : 1.;\n    \n}\n\n\nLine horizontal_segment(vec2 left) {\n  return Line(left, left + vec2(SEGMENT_LENGTH, 0.));\n}\n\nLine vertical_segment(vec2 bottom) {\n  return Line(bottom, bottom + vec2(0., SEGMENT_LENGTH));\n}\n\n\nfloat draw_digit(vec2 root, vec2 xy, int digit) {\n  const float LENGTH = 0.4;\n  const float GAP = 0.005;\n  // We want to draw a digital clock digit, like\n  // the following \"8\", made of hexagonal segments.\n  // Next to the \"8\" are the segment's names.\n  //  -    6    Observe we need a few coordinates;\n  // | |  4 5   x0 = x3 = x6, x1 = x4, x2 = x5; and\n  //  -    3    y0, y1 = y2, y3, y4 = y5, y6.\n  // | |  1 2\n  //  -    0\n  \n  float x0 = root.x;\n  float x1 = x0 - GAP;\n  float x2 = x0 + SEGMENT_LENGTH + GAP;\n  float y0 = root.y;\n  float y1 = y0 + GAP;\n  float y3 = y1 + SEGMENT_LENGTH + GAP;\n  float y4 = y3 + GAP;\n  float y6 = y4 + SEGMENT_LENGTH + GAP;\n  \n  // Make segments.\n  // TODO: There's probably a way to exploit symmetry and call\n  // `hexagon` fewer times.\n  Line[7] segment;\n  segment[0] = horizontal_segment(vec2(x0, y0));\n  segment[1] = vertical_segment(vec2(x1,y1));\n  segment[2] = vertical_segment(vec2(x2,y1));\n  segment[3] = horizontal_segment(vec2(x0,y3));\n  segment[4] = vertical_segment(vec2(x1,y4));\n  segment[5] = vertical_segment(vec2(x2,y4));\n  segment[6] = horizontal_segment(vec2(x0, y6));\n  \n  // if segment j is on when displaying digit i, then  \n  // segment_on[i * 7 + j] = 1\n  const int SEGMENT_ON[70] = int[70](\n      1, 1, 1, 0, 1, 1, 1,  // 0\n      0, 0, 1, 0, 0, 1, 0,  // 1\n      1, 1, 0, 1, 0, 1, 1,  // 2\n      1, 0, 1, 1, 0, 1, 1,  // 3\n      0, 0, 1, 1, 1, 1, 0,  // 4\n      1, 0, 1, 1, 1, 0, 1,  // 5\n      1, 1, 1, 1, 1, 0, 1,  // 6\n      0, 0, 1, 0, 0, 1, 1,  // 7\n      1, 1, 1, 1, 1, 1, 1,  // 8\n      1, 0, 1, 1, 1, 1, 1   // 9\n  );\n  \n  // Draw segments.\n  float result = 0.0;\n  for (int i = 0; i < 7; i++) {\n    float on = float(SEGMENT_ON[i + digit * 7]);\n    result += on * hexagon(xy, segment[i]);\n  }\n  return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv.x *= aspect_ratio;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Move the canvas\n    vec2 velocity = vec2(-0.5, 0.1);\n    uv += iTime * velocity;\n\n    // Decide on the digit.\n    float digit_pattern = 1.25 * iTime;\n    int digit = 9 - int(digit_pattern) % 10;\n    \n    // Make digits repeat.\n    const vec2 PERIOD = vec2(.4, .6);\n    uv = mod(uv, PERIOD);\n    \n    // Draw the digit.\n    vec2 digit_root = vec2(0.1, 0.05);\n    col *= clamp(draw_digit(digit_root, uv, digit), 0., 1.);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}