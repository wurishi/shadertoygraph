{"ver":"0.1","info":{"id":"4syfWd","date":"1531080956","viewed":381,"name":"GP - Memories of Nagrand","username":"Quinchilion","description":"SDF raymarched terrains forming a layer of floating islands, with water reflections, soft shadows, ambient occlusion, atmospheric scattering and clouds.","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","terrain","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Quinchilion (aka Dolkar) for the purposes of the Graphics Programming first shader contest\n// on 8.7.2018\n// MIT License, do whatever with it\n\n// Featuring a terrain built solely with SDF blobs. Not the best thing for making terrains with,\n// as can be seen from the sphere grid artifacts. A larger radius of influence would help\n// at the cost of performance.\n// Floating islands made as a difference of two terrain objects.\n// With the entire scene built with SDF, soft shadows and AO approximations\n// are fast to calculate.\n\n// Uncomment this line if shader compilation crashes your driver or if it's too slow\n//#define NO_WATER_SHADING\n\nconst float CAMERA_TRAVEL_SPEED = 1.0;\nconst int RAYMARCH_MAX_ITER = 200;\nconst int SHADOW_MAX_ITER = 50;\nconst int REFLECTION_MAX_ITER = 100;\nconst int AMBIENT_MAX_ITER = 10;\nconst float RAYMARCH_PRECISION = 0.001;\nconst float RAYMARCH_STEP_FACTOR = 1.0;\nconst vec3 SUN_DIRECTION = normalize(vec3(0.5, 1.0, 2.0));\nconst vec3 SUNLIGHT_COLOR = vec3(1.0, 0.9, 0.8) * 1.5;\nconst float AMBIENT_LIGHT_INTENSITY = 1.0;\n\n// Ray sphere intersection assuming ray origin lies within the sphere\nfloat innerRaySphere(vec3 rayOrig, vec3 rayDir, vec3 spherePos, float radius) {\n    rayOrig -= spherePos;\n    float b = 2.0 * dot(rayOrig, rayDir);\n    float c = dot(rayOrig, rayOrig) - radius * radius;\n    float dsc2 = b * b - 4.0 * c;\n\n    float dsc = sqrt(abs(dsc2));\n    return dsc - b;\n}\n\n// Hash function from https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Simple fractal noise used for terrain texturing and clouds\nfloat fbm(vec2 pos) {\n\tfloat noise = 0.5;\n    noise += (texture(iChannel0, pos * 1.0).x - 0.5) * 0.75;\n    noise += (texture(iChannel0, pos * 2.0).x - 0.5) * 0.75 * 0.5;\n    noise += (texture(iChannel0, pos * 4.0).x - 0.5) * 0.75 * 0.25;\n    noise += (texture(iChannel0, pos * 8.0).x - 0.5) * 0.75 * 0.125;\n    return noise;\n}\n\nfloat sdfSphere(vec3 pos, float radius) {\n\treturn length(pos) - radius;\n}\n\n// from that MediaMolecule talk\nfloat sdfSoftUnion(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.0);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\nstruct SdfObj {\n\tfloat dist;\n    int material; // -1: sky, 0: ground, 1: water\n};\n    \n// Value from noise controls height of the sdf sphere.\n// Shape is a tradeoff between sphere radius and soft union radius\nfloat sdfTerrainCell(vec3 pos, float height, float shape) {\n    pos.y -= (height - 1.0) * (1.0 - shape);\n\treturn sdfSphere(pos, (1.0 - shape));\n}\n    \n// Returns the signed distance to a terrain object\nfloat sdfTerrain(vec3 globalPos, float scale, float lacunarity,\n                 float shape, int levels, float seed) {\n    float dist = globalPos.y; // Initialize to ground plane\n    \n    float heightMult = 1.0;\n    vec4 cellDisp = vec4(0.0);\n    \n    // Iteratively refine the distance field at increasing levels of detail\n    for (int level = 0; level < levels; level++) {\n        if (abs(dist) > scale) break; // Early-out, no need to refine further\n    \tvec3 pos = globalPos / scale;\n\n        vec3 baseCellPos = vec3(fract(pos.x), pos.y, fract(pos.z));\n        vec3 baseCellIndex = vec3(floor(pos.x), seed + float(level), floor(pos.z));\n\t\t\n        // Considers only 4 nearest grid aligned blobs at each level of detail\n        float h00 = hash13(baseCellIndex + vec3(0, 0, 0)) * heightMult;\n        float h01 = hash13(baseCellIndex + vec3(0, 0, 1)) * heightMult;\n        float h10 = hash13(baseCellIndex + vec3(1, 0, 0)) * heightMult;\n        float h11 = hash13(baseCellIndex + vec3(1, 0, 1)) * heightMult;\n        \n        float cell00 = sdfTerrainCell(baseCellPos - vec3(0, cellDisp.x, 0), h00, shape);\n        float cell01 = sdfTerrainCell(baseCellPos - vec3(0, cellDisp.y, 1), h01, shape);\n        float cell10 = sdfTerrainCell(baseCellPos - vec3(1, cellDisp.z, 0), h10, shape);\n        float cell11 = sdfTerrainCell(baseCellPos - vec3(1, cellDisp.w, 1), h11, shape);\n         \n        dist = sdfSoftUnion(dist, cell00 * scale, shape * scale);\n        dist = sdfSoftUnion(dist, cell10 * scale, shape * scale);\n        dist = sdfSoftUnion(dist, cell01 * scale, shape * scale);\n        dist = sdfSoftUnion(dist, cell11 * scale, shape * scale);\n        \n        scale *= 0.5;\n        heightMult *= lacunarity;\n        \n        // Interpolate cell displacement on downscale\n        // Not an exact solution, but makes interesting patterns regardless\n        cellDisp = (cellDisp + vec4(h00, h01, h10, h11) * 0.5) * 2.0;\n        if (baseCellPos.x <= 0.5) {\n        \tcellDisp.zw = (cellDisp.xy + cellDisp.zw) * 0.5;\n        } else {\n        \tcellDisp.xy = (cellDisp.xy + cellDisp.zw) * 0.5;\n        }\n        \n        if (baseCellPos.z <= 0.5) {\n        \tcellDisp.yw = (cellDisp.xz + cellDisp.yw) * 0.5;\n        } else {\n        \tcellDisp.xz = (cellDisp.xz + cellDisp.yw) * 0.5;\n        }\n    }\n    \n    return dist;\n}\n\n// Returns the signed distance to the entire scene\nSdfObj sdf(vec3 pos, int levelOfDetail, vec3 cameraPos) {\n\t// Add curvature\n    vec2 relPos = pos.xz - cameraPos.xz;\n    pos.y += dot(relPos, relPos) * 0.002;\n    \n    // Base ground terrain\n    float groundDist = sdfTerrain(pos, 20.0, 0.8, 0.4, 6 - levelOfDetail, 0.0);\n    \n    // Upside down terrain for the bottom of the islands\n    vec3 islandPos = vec3(pos.x, 24.0 - pos.y, pos.z);\n    float islandDist = sdfTerrain(islandPos, 15.0, 0.95, 0.4, 6 - levelOfDetail, 4625.9);\n    \n    // Cutoff terrain forming the top of the islands\n    vec3 cutoffPos = vec3(pos.x, 25.0 - pos.y, pos.z);\n    float cutoffDist = sdfTerrain(cutoffPos, 30.0, 1.0, 0.3, 2, 1967.3);\n    \n    // Combine terrains\n    islandDist = -sdfSoftUnion(-islandDist, cutoffDist, 1.0);\n    float terrainDist = sdfSoftUnion(groundDist, islandDist, 1.0);\n    \n    SdfObj terrain;\n    terrain.dist = terrainDist;\n    \n    // Wavey water\n    SdfObj water;\n    float wavex = sin(pos.x);\n    float wavey = sin(pos.z + wavex * 1.0 + iTime);\n    float waves = wavex * wavey * 0.05;\n    water.dist = pos.y - 7.5 + waves;\n    water.material = 1;\n    \n    SdfObj result;\n    result.dist = min(terrain.dist, water.dist);\n    result.material = result.dist == terrain.dist ? terrain.material : water.material;\n    return result;\n}\n\nstruct SurfaceHit {\n\tfloat depth;\n    float minSurfDistance;\n    float iterCount;\n    int material;\n};\n\nSurfaceHit raymarch(vec3 rayOrig, vec3 rayDir, int maxIterations,\n                    int levelOfDetail, float maxDepth, vec3 cameraPos) {\n\tSurfaceHit sHit;\n    sHit.depth = 0.01;\n    sHit.minSurfDistance = 1000.0;\n    sHit.iterCount = 0.0;\n    sHit.material = 0;\n    \n    for (int iter = 0; iter < maxIterations; iter++) {\n    \tSdfObj obj = sdf(rayOrig + rayDir * sHit.depth, levelOfDetail, cameraPos);\n        \n        sHit.minSurfDistance = min(sHit.minSurfDistance, obj.dist);\n        if (abs(obj.dist) < sHit.depth * RAYMARCH_PRECISION) {\n            sHit.material = obj.material;\n            break;\n        } else if (sHit.depth > maxDepth) {\n            sHit.material = -1;\n        \tbreak;\n        }\n        \n        sHit.depth += obj.dist * RAYMARCH_STEP_FACTOR;\n        sHit.iterCount += 1.0;\n    }\n    \n    return sHit;\n}\n\nvec3 sdfGradient(vec3 point, vec3 cameraPos) {\n    float dx = sdf(point + vec3(0.001, 0.0, 0.0), 0, cameraPos).dist -\n        \t   sdf(point - vec3(0.001, 0.0, 0.0), 0, cameraPos).dist;\n    \n    float dy = sdf(point + vec3(0.0, 0.001, 0.0), 0, cameraPos).dist -\n        \t   sdf(point - vec3(0.0, 0.001, 0.0), 0, cameraPos).dist;\n \n    float dz = sdf(point + vec3(0.0, 0.0, 0.001), 0, cameraPos).dist -\n        \t   sdf(point - vec3(0.0, 0.0, 0.001), 0, cameraPos).dist;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 skyColor(float theta) {\n    float f = min((1.0 - theta) * 0.7, 1.0);\n\treturn (vec3(0.3, 0.5, 2.0) + vec3(1.5, 1.4, 1.1)*f*f*f) * 1.5;\n}\n\n// Ambient lighting defined as a function of the vertical angle and upwards occlusion\nvec3 ambientColor(float theta, float shadow) {\n\tfloat f1 = max(theta, 0.0);\n    f1 = f1 * f1 * min(shadow * 1.5, 1.0);\n    float f2 = min(1.0 + theta, 1.0);\n    \n    vec3 sky = mix(vec3(0.25) * 0.5, vec3(0.45, 0.55, 1.5), f1);\n    return mix(vec3(0.15, 0.15, 0.1) * 0.5, sky, f2);\n}\n\n// Ground texture\nvec3 groundColor(vec3 position, vec3 normal) {\n    float slope = normal.y * 0.5 + 0.5;\n    slope -= fbm(position.xz * 0.01) * 0.5;\n    slope = smoothstep(0.0, 1.0, max(slope, 0.0));\n    \n    return mix(vec3(0.5, 0.4, 0.2), vec3(0.5, 0.8, 0.1), slope);\n}\n\n// Exponential fog\nvec3 fog(vec3 color, float theta, float depth) {\n\tvec3 sky = skyColor(theta);\n    float d = exp2(-depth * 0.004);\n    return mix(sky, color, d);\n}\n\n// Adds a cloud sphere\nvec3 skyWithClouds(vec3 rayOrig, vec3 rayDir, vec3 cameraPos) {\n    const float CS_RADIUS = 300.0;\n    const float CS_HEIGHT = 20.0;\n    \n    vec3 spherePos = vec3(cameraPos.x, CS_HEIGHT - CS_RADIUS, cameraPos.z);\n\tfloat t = innerRaySphere(rayOrig, rayDir, spherePos, CS_RADIUS);\n    vec3 cloudPos = rayOrig + rayDir * t;\n    \n    float cloudDensity = max(fbm(cloudPos.xz / 10000.0) - 0.25, 0.0) / 0.75;\n    cloudDensity = smoothstep(0.0, 1.0, cloudDensity * cloudDensity);\n    \n    vec3 sky = skyColor(rayDir.y);\n    float d = exp2(-t * 0.004);\n    return mix(sky, vec3(1.6, 1.8, 2.0), d * cloudDensity);\n}\n\nvec3 shadeSurface(SurfaceHit sHit, vec3 rayOrig, vec3 rayDir, vec3 cameraPos) {\n    if (sHit.material < 0) {\n        return skyWithClouds(rayOrig, rayDir, cameraPos);\n    }\n    \n    vec3 position = rayOrig + rayDir * sHit.depth;\n    vec3 normal = sdfGradient(position, cameraPos);\n    \n    // Shade sunlight with soft shadows\n    float sun = max(dot(normal, SUN_DIRECTION), 0.0);\n    \n    SurfaceHit shadowHit = raymarch(\n        position + SUN_DIRECTION * 1.5, SUN_DIRECTION, SHADOW_MAX_ITER, 2,\n        50.0, cameraPos);\n    float minSurfDistance = max(shadowHit.minSurfDistance + 0.1, 0.0);\n    float shadow = min(minSurfDistance * 1.5, 1.0);\n    shadow = smoothstep(0.0, 1.0, shadow);\n    sun *= shadow;\n    \n    vec3 light = SUNLIGHT_COLOR * sun;\n    \n    // Add ambient lighting\n    SurfaceHit aoHit = raymarch( // Cast a very soft shadow query upwards\n        position + vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), AMBIENT_MAX_ITER, 4,\n        10.0, cameraPos);\n    minSurfDistance = max(aoHit.minSurfDistance, 0.0);\n    float aoShadow = min(minSurfDistance * 0.25, 1.0);\n    light += ambientColor(normal.y, aoShadow) * AMBIENT_LIGHT_INTENSITY; \n    \n    // Combine and apply fog\n    vec3 diffuse = groundColor(position, normal);\n    return fog(diffuse * light, rayDir.y, sHit.depth);\n}\n\nvec3 shade(SurfaceHit sHit, vec3 rayOrig, vec3 rayDir) {\n    // Choose surface to shade\n    SurfaceHit shadedHit = sHit;\n    vec3 shadeRayOrig = rayOrig;\n    vec3 shadeRayDir = rayDir;\n    \n#ifndef NO_WATER_SHADING\n    if (sHit.material == 1) {\n        // Water reflection, shade the reflected surface instead\n        vec3 position = rayOrig + rayDir * sHit.depth;\n    \tvec3 normal = sdfGradient(position, rayOrig);\n        \n    \tvec3 reflDir = reflect(rayDir, normal);\n        vec3 reflOrig = position + reflDir * 0.5;\n        \n        shadedHit = raymarch(\n            reflOrig, reflDir, REFLECTION_MAX_ITER, 1, 100.0, rayOrig);\n        shadeRayOrig = reflOrig;\n        shadeRayDir = reflDir;\n    }\n#endif\n    \n    vec3 color = shadeSurface(shadedHit, shadeRayOrig, shadeRayDir, rayOrig);\n    \n    if (sHit.material == 1) {\n        // Apply water color and camera -> water surface fog\n        color = fog(color * vec3(0.8, 0.9, 1.0), rayDir.y, sHit.depth);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n    // Shamelessly stole camera setup from https://www.shadertoy.com/view/Xs3GRB\n    float ang, si, co;\n    ang = -(iMouse.x / iResolution.x - 0.5) * 6.0 - 1.0;\n    si = sin(ang); co = cos(ang);\n    mat4 cam_mat = mat4(\n        co, 0., si, 0.,\n        0., 1., 0., 0.,\n        -si, 0., co, 0.,\n        0., 0., 0., 1.);\n    ang = -(iMouse.y / iResolution.y - 0.5) * 1.5;\n    si = sin(ang); co = cos(ang);\n    cam_mat = cam_mat * mat4(\n        1., 0., 0., 0.,\n        0., co, si, 0.,\n        0.,-si, co, 0.,\n        0., 0., 0., 1.);\n    \n    vec3 rayOrig = vec3(0.0, 12.0, 0.0) + vec3(3.0, 0.0, 2.0) * iTime * CAMERA_TRAVEL_SPEED;\n    vec3 rayDir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n    \n    // Attempt to move camera out of the way of terrain\n    SdfObj scene = sdf(rayOrig, 4, rayOrig);\n    float displ = min(2.0 - scene.dist, 5.0);\n    displ = (sqrt(displ * displ + 1.0) + displ) * 0.5;\n    rayOrig.y += displ;\n\t\n    // This is where your GPU starts weeping\n    SurfaceHit sHit = raymarch(rayOrig, rayDir, RAYMARCH_MAX_ITER, 0, 200.0, rayOrig);\n    vec3 color = shade(sHit, rayOrig, rayDir);\n    \n\t// Tonemapping, vignette and gamma correction\n    color *= 2.0;\n    color = color / (color + 1.0);\n    color *= 1.0 - smoothstep(0.0, 1.0, max(length(uv) * 1.3 - 0.75, 0.0)) * 0.5;\n    color = pow(color, vec3(1.0/2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}