{"ver":"0.1","info":{"id":"XfdfzH","date":"1732722326","viewed":32,"name":"Galactic Noise Gallery","username":"kallaballa","description":"A demonstration of different noises I wrote or collected. Most of them can sample entropy from other noises like galaxy noise does in this example.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","volumetric","3dfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Â© shadertoys@viel-zu.org \n// License: AGPL\n\nconst int AA = 1;\n\nvec3 galaxyNoiseVec3(vec3 uv) {\n    vec3 uvs = uv * 0.5 + 0.5;\n    vec3 p = vec3(uv / 4.) + vec3(1., -1.3, 0.);\n    vec3 n;\n    int selectNoise = int(mod(floor(iTime / 3.0), 4.));\n    switch(selectNoise) {\n        case 0:\n            n = vec3(randVec3(uv).x);\n        break;\n    \n        case 1:\n            n = vec3(penroseNoiseVec3(uv).x);\n        break;\n\n        case 2:\n            n = vec3(worley(uv / 10.0).x);\n        break;\n\n        case 3:\n            n = vec3(smokeNoiseVec3(uv).x);\n        break;\n    };\n    float t = fractal(p + (n.x / 100.0));\n    float t1 = fractal(p + (n.y / 100.0));\n    float t2 = fractal(p + (n.z / 100.0));\n    vec3 color = vec3(t, t1, t2);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color;\n    for(int i = 0; i < AA; ++i) {\n        for(int j = 0; j < AA; ++j) {\n            int selectNoise = int(mod(floor(iTime / 3.0), 8.));\n            vec3 n;\n            vec3 pos = vec3(uv, mod(iTime / 100.0, 1.0));\n            switch(1) {\n                case 0:\n                    n = randVec3(pos);\n                break;\n\n                case 1:\n                    n = penroseNoiseVec3(pos);\n                break;\n\n                case 2:\n                    n = worley(pos);\n                break;\n\n                case 3:\n                    n = smokeNoiseVec3(pos);\n                break;\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                    n = galaxyNoiseVec3(pos);\n                break;\n\n            };\n\n            color += normalize(n);\n        }\n    }\n    \n    fragColor = vec4(color / float(AA*AA), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PATTERN 1\n  // 0 = textured Penrose tiles\n  // 1 = colored Robinson tiles with wiggly pattern\n\nconst float pi = radians(180.0);\nconst int base_levels = 25; // base substitution levels\n\nmat2 getTile(out int type, inout vec2 q, int levels)\n{\n  const float sc = 1.6180339887498947; // = 2.0/(sqrt(5.0)-1.0) (inflation scale)\n  const float pi = 3.1415926535897931;\n\n  // Transformations constants:\n\n  const float d1 = 1.3763819204711734; // = tan(54*pi/180)\n  const float d2 = 0.32491969623290629; // = tan(18*pi/180)\n  const float a1 = 0.61803398874989479; // = .5/cos(36*pi/180)\n  const float a2 = 0.80901699437494745; // = (1+a1)*.5\n  const float a3 = 0.5877852522924728; // = tan(36*pi/180)*a2\n  const float cos1 = -0.8090169943749475; // = cos(144*PI/180)*sc\n  const float sin1 = 0.5877852522924732; // = sin(144*PI/180)*sc\n  const float cos2 = -0.30901699437494734; // = cos(108*PI/180)*sc\n  const float sin2 = 0.9510565162951536; // = sin(108*PI/180)*sc\n\n  mat2 m, final_m = mat2(1);\n\n  type = (q.y < 0.) ? 1 : 0; // starting prototile\n  if (q.y < 0.) {\n     // flip rotation matrix as well\n     final_m[0].y = -final_m[0].y;\n     final_m[1].y = -final_m[1].y;\n     q.y = -q.y;\n  }\n\n  for (int k=0; k<base_levels; k++)  // iterate all subsitutions\n  {\n     if (k >= levels) break;\n     if (type < 2) \n     {\n        // We substitute triangle type 0/1\n        // with three triangles.\n        // We detect in which of those three\n        // our current q = (x,y) lies\n        // by checking line equations separating them:\n\n        if (1.0 - d1*q.y - q.x > 0.0) // left triangle\n        {         \n           // translate:\n           q.x -= 1.;\n\n           // mirror:\n           m = mat2(-1.,0.,0.,1.);\n\n           type = 1 - type; // tile type changes here!\n        } \n        else if (1.0 - d2*q.y - q.x > 0.0) // middle triangle\n        {\n           // translate:\n           q -= vec2(a2,a3);\n\n           // rotate:\n           m = mat2(cos1,sin1,-sin1,cos1);\n\n           type = 3 - type; // tile type changes here!\n        } \n        else // right triangle\n        {      \n           // translate (x only):\n           q.x -= a1 + 1.;\n\n           // rotate:\n           m = mat2(cos1,-sin1,sin1,cos1);\n        }      \n     } \n     else \n     {\n        // We substitute triangle type 2/3\n        // with two triangles (analogically).\n\n        if (d1*q.y - q.x > 0.0) { // upper triangle\n\n           // rotate only\n           m = mat2(-cos2,sin2,sin2,cos2);\n\n           type -= 2; // tile type changes here!\n\n        } else { // lower triangle\n\n           // translate (x only):\n           q.x -= a1;\n\n           // rotate:\n           m = mat2(cos2,-sin2,sin2,cos2);\n        }\n     }  \n\n     // final rotate:\n     q = m * q; \n     final_m = m * final_m;\n\n     // inflaction scale:\n     q *= sc;\n  }\n\n  // return final rotate (e.g. to rotate normal later):\n  return final_m;\n}\n\nfloat getEdgeDist(int type, vec2 q)\n{\n  const float inv_sc = 0.6180339887498949; // = (sqrt(5.0)-1.0)/2.0\n  const float d1 = 1.3763819204711734; // = tan(54*pi/180)\n  const float d2 = 0.32491969623290629; // = tan(18*pi/180)\n  float dist = 0.;\n  if (type < 2) {\n     dist = 1.-(d1*q.y+q.x)*inv_sc;\n     dist = min(dist, (-d1*q.y+q.x)*inv_sc);\n  } else {\n     dist = (-d2*q.y+q.x);\n     dist = min(dist, (inv_sc-d2*q.y-q.x));\n  }\n  return dist;\n}\n\nfloat getDist(int type, vec2 q)\n{\n  float dist = getEdgeDist(type,q);\n  return min(dist,.05)*2.+min(dist,.15)*1.;\n}\n\nvec3 getNorm(int type, vec2 q, mat2 m)\n{\n  const vec2 eps = vec2(.001,0.);\n  vec3 norm = vec3(\n     getDist(type,q+eps.xy) - getDist(type,q-eps.xy),\n     getDist(type,q+eps.yx) - getDist(type,q-eps.yx),\n     eps.x*2.\n   );\n  norm.xy *= m;\n  return normalize( norm );\n}\n\nvec3 getColor(int type, vec2 q)\n{\n  const float r = 1.;\n  vec3 base;\n  if (type >= 2) {\n     float f = (type == 2) ? q.y : -q.y;\n     f = smoothstep(-r,r,f);\n     base = mix(\n        vec3(0.,1.,0.),\n        vec3(1.,0.,1.),f);\n  } else {\n     float f = (type == 0) ? q.y  * q.x : -q.y * q.x ;\n     f = smoothstep(-r,r,f);\n     base = mix(\n        vec3(0.,0.25,0.5),\n        vec3(0.5,0.75,1.),f);\n  }\n  return base-.1;\n}\n\n\nvec3 penrose(mat2 rot, vec2 q0, float sample_size, int levels) {\n    int type;\n    vec2 q = q0;\n    rot = getTile(type, q, levels) * rot;\n    vec3 norm = getNorm(type, q, rot);\n    float dist = getDist(type, q);\n    vec3 base = getColor(type, q);\n    return base;\n}\n\nvec3 penroseNoiseVec3(vec3 p) {\n//    p.z /= 100.;\n    int type;\n    float co, si;\n    vec2 q;\n    type = 0;\n    q = ((p.xy + vec2(1.0 + (sin(p.z * 2. * pi) * 0.5 + 0.5), -1.0 + (cos(p.z * 2. * pi) * 0.5 + 0.5) )) * 0.001);\n\n    float sample_size = 1.;//scale/iResolution.y;\n    float scale = 1.0;\n\n    mat2 rot = mat2(co,-si,si,co) / (1./scale);\n\n    vec3 base, base1, base2;\n    float blend = 0.; //(iMouse.z > 0.) ? smoothstep(-.2,.2,iMouse.y/iResolution.y-.5) : 0.;\n    base1 = (blend < 1.) ? penrose(rot, q, sample_size, base_levels) : vec3(0);\n    base2 = (blend > 0.) ? penrose(rot, q, sample_size, base_levels-1) : base1;\n    base = mix(base1, base2, blend);\n\n    base = pow(base,vec3(.6));\n\n    return base;\n}\n\nvec3 randVec3(vec3 co) {\n    return vec3(\n        fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.164))) * 43758.5453),\n        fract(sin(dot(co.xyz, vec3(60.3496, 300.112, 160.565))) * 43758.5453),\n        fract(sin(dot(co.xyz, vec3(200.6345, 1000.987, 500.621))) * 43758.5453)\n    );\n}\n\n\n\nvec3 fbm(vec3 p) {\n    vec3 value = vec3(0.0);\n    float amplitude = 0.5;\n    for (int i = 0; i < 6; i++) {\n        value += amplitude * randVec3(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvec3 worley(vec3 uv) {\n    uv *= 12.0;\n    vec3 p = floor(uv);\n    vec3 f = fract(uv);\n    vec3 res = vec3(8.0);\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            for (int k = -1; k <= 1; k++) {\n                vec3 b = vec3(i, j, k);\n                vec3 r = b - f + randVec3(p + b);\n                res = min(res, dot(r, r));\n            }\n        }\n    }\n    float v = normalize(vec2((res).x, 1)).x;\n    return vec3(v, 1.0 - v, v / 2.0 + 0.5);\n}\n\nfloat smokeBaseNoise( vec3 x )\n{\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(0.37,0.17)*p.z) + f.xy;\n\tvec2 rg = worley(vec3((uv+ 0.5), p.z) / 10.0).yx * 2.0 - 1.0;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec3 smokeNoiseVec3(vec3 p)\n{\n\tfloat den;\n\n    // smoke\t\n\tfloat f;\n\tvec3 q = p                          - vec3(0.0,1.0,0.0)*p.z;\n    f  = 0.50000*smokeBaseNoise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*p.z;\n    f += 0.25000*smokeBaseNoise( q ); q = q*2.03 - vec3(0.0,1.0,0.0)*p.z;\n    f += 0.12500*smokeBaseNoise( q ); q = q*2.01 - vec3(0.0,1.0,0.0)*p.z;\n    f += 0.06250*smokeBaseNoise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*p.z;\n    f += 0.03125*smokeBaseNoise( q );\n\n    den = f;\n\n    float angle = den * pi * 2.;\n\tvec3 col = vec3(sin(angle), cos(angle), cos(pi * 0.5 + angle)) * vec3(0.5) + vec3(0.5);\n\treturn col;\n}\n\nfloat fractal(in vec3 p) {\n    float accum = 0.;\n    float prev = 0.;\n    float tw = 0.;\n\n    for (int i = 0; i < 32; ++i) {\n        float mag = dot(p, p);\n        p = abs(p) / mag + vec3(-.5, -.4, -1.5);\n        float w = -float(i) / 32.;\n        accum += w * (1.0 - (abs(mag - prev)));\n        tw += w;\n        prev = mag;\n    }\n    return max(0., accum / tw);\n}\n\n","name":"Common","description":"","type":"common"}]}