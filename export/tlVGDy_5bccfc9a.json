{"ver":"0.1","info":{"id":"tlVGDy","date":"1583811695","viewed":90,"name":"InifiniteBlobby","username":"antoinefortin","description":"dddd","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingtemplate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float WEIGHT = .9;\nconst float MULT = 0.75;\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat heightShape(vec3 pos)\n{\n    \n\treturn ((sin(pos.x) / 1.5) + (cos(pos.z) / 2.));\n}\n\nfloat noise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n    float spark = 600.;\n    \n\tvec4 r = vec4(v, v+1.0, v+1000., v+1001.);\n\tr = fract(10000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 3.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat terrain2( vec2 p, int freq ) {\t\n\tfloat h =  1.; // height, start at higher than zero so there's not too much snow/ice\n\tfloat w = WEIGHT; \t// weight\n\tfloat m = MULT; \t// multiplier\n    \n    int peakyMount = 2;\n    \n\tfor (int i = 0; i < peakyMount; i++) {\n\t\th += w * noise((p * m)); // adjust height based on noise algorithm\n\t\tw *= 0.45;\n\t\tm *= 2.2;\n\t}\n\treturn h;\n}\n\n/*\n\n\nfloat sdPlane(vec3 pos)\n{\n\treturn pos.y + .25;\n}\n*/\n\n// Distance Field\nfloat map(vec3 pos)\n{\n\n    vec3 q = pos; // Copier nouvelle pos en Q\n\n    // Distances...\n\tfloat d = sdBox(q, vec3(0.25)); // Boite\n\n    \n\t// rocky terrain - MTN\n\t\n    float h = terrain2(pos.xz, 1);\n\tfloat d2  = (q.y + .5) - h;\n    \n    return min(d, d2);\n}\n\n/* \n\tFonction qui prend un origin et une direction\n\tPuis tente de caster un point sur le RAY.\n*/\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0; // Distance sur le ray\n    for(int i = 0; i < 120; i++)\n    {\n    \tvec3 pos = ro + t * rd; // Position sur le ray une fois la distance\n        \n        float h = map(pos); // On map pour savoir si il y a un \"hit\"\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 20.0) break;\n        \n    }\n    \n    if(t > 20.0) t = -1.0;\n    \n    return t;\n}\n\n// Fonction qui sert a calculer la normale a un point. \n/*\n\tBrute force de différentiel.\n*/\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.001, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord- iResolution.xy) / iResolution.y;    \n    // Camera Look at\n    \n    float an = iTime;\n    \n    /*\n\t  Code pour la camera\n\t*/\n    // Origin de la camera\n    vec3 ro = vec3(1., 3.75, 1.0 + iTime);\n\t\n    // Zoom de la camera\n    float cameraZoom = 1.;\n    \n    // LookAt (endroit ou regarde la camera)\n\tvec3 target = vec3(0.5, 0.5, 0.5);// lookat \n    \n    // Définition des nouveaux axes de camera\n\tvec3 ww = normalize(target - ro);\n\tvec3 uu = normalize(cross(ww, vec3(0.,1.,0.)));\n\tvec3 vv = normalize(cross(uu, ww));\n    \n    // Direction des rayons que l'on envoie\n\tvec3 rd = normalize(p.x * uu + p.y * vv + cameraZoom * ww);\n\n    /*\n\n\t\tRendering part\n\t*/\n    // Couleur de base \n    vec3 col = vec3(0.12, 0.22,.5);\n    \n    float t = castRay(ro, rd);\n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n       \tvec3 sundir = normalize(vec3(0.8, 0.4, 0.2));\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        \n        float sun_sha = smoothstep(castRay( pos + nor * 0.001, sundir), 0.0, 1.0);\n        float sky_dif = clamp(dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n            \n            \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha;\n        col += vec3(0.0, 0.2, 0.4) * sky_dif * 2.0;\n    }\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}