{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// \n// HSVToRGB based on the implementation at http://wiki.beyondunreal.com/HSV-RGB_Conversion\n//\n\nvec4 HSVToRGB(float h, float s, float v)\n{\n\tfloat min;\n\tfloat chroma;\n\tfloat hPrime;\n\tfloat x;\n\tvec4 rgbColor;\n\t \n\tchroma = s * v;\n\thPrime = h / 60.0;\n\tx = chroma * (1.0 - abs((mod(hPrime, 2.0) - 1.0)));\n\t \n\tif(hPrime < 1.0) {\n\t\trgbColor.r = chroma;\n\t\trgbColor.g = x;\n\t} else if(hPrime < 2.0) {\n\t\trgbColor.r = x;\n\t\trgbColor.g = chroma;\n\t} else if(hPrime < 3.0) {\n\t\trgbColor.g = chroma;\n\t\trgbColor.b = x;\n\t} else if(hPrime < 4.0) {\n\t\trgbColor.g = x;\n\t\trgbColor.b = chroma;\n\t} else if(hPrime < 5.0) {\n\t\trgbColor.r = x;\n\t\trgbColor.b = chroma;\n\t} else if(hPrime <= 6.0) {\n\t\trgbColor.r = chroma;\n\t\trgbColor.b = x;\n\t}\n \n\tmin = v - chroma;\n\t \n\trgbColor.r += min;\n\trgbColor.g += min;\n\trgbColor.b += min;\n\trgbColor.a  = 1.0;\n\t \n\treturn rgbColor;\n}\n\nfloat noise(float t)\n{\n\treturn fract(sin(t) * 45673.1234);\n}\n\nfloat smoothNoise(float t)\n{\n\treturn (noise(t) / 2.0) + (noise(t-1.) / 4.0) + (noise(t+1.) / 4.0);\n}\n\nfloat interpolateNoise(float t)\n{\n\tfloat fractT = fract(t);\n\tfloat intT0  = t - fractT;\n\tfloat intT1  = intT0 + 1.0;\n\t\n\treturn mix(smoothNoise(intT0), smoothNoise(intT1), fractT);\n}\n\nfloat fbm(float t)\n{\n\tfloat p;\n\tp  = 0.500 * interpolateNoise(t); t = t * 2.;\n\tp += 0.250 * interpolateNoise(t); t = t * 2.;\n\tp += 0.125 * interpolateNoise(t); t = t * 2.;\n\tp += 0.062 * interpolateNoise(t);\n\t\n\tp -= 0.2;\n\t\n\treturn p;\n}\n\n#define PI 3.14159\nvec4 pointColor(float angle)\n{\n\tfloat t = mod(angle, PI) / PI;\n\t\n\tfloat h = 360.0 * t;\n\tfloat s = 0.9;\n\tfloat v = 0.9;\n\treturn HSVToRGB(h, s, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec2 center = vec2(0.0, 0.0);\n\t\n\tfloat time = iTime;\n\ttime *= 1.8;\n\t\n\tfloat R = mod(time, 4.0) * (1.25);\n\t\n\tvec2 point  = uv - center;\n\tfloat angle = atan(point.y, point.x);\n\tfloat len   = length(point);\n\t\n\tR -= fbm(angle * 20.);\n\t\n\tfloat d = abs(len - R);\n\tfloat t = smoothstep(0.0, 0.5, d);\n\t\n\tfragColor = mix(pointColor(angle), vec4(0.6, 0.8, 0.9, 1.0), t);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mds3zM","date":"1368475331","viewed":379,"name":"Sonic Rainboom","username":"phytoporg","description":"A procedural sonic rainboom to get acquainted with noise!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","fbm","pone","rainboom","hsv"],"hasliked":0,"parentid":"","parentname":""}}