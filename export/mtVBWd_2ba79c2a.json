{"ver":"0.1","info":{"id":"mtVBWd","date":"1702667928","viewed":38,"name":"Rect Rotates to Cursor %scouttea","username":"scouttea","description":"A simple shader which draws a square which orients itself to the cursor,\nThe implementation provides most of the details about the mathematics involved.\nI also wrote a bit on the end to calculate UV coordinates\nThis is mainly intended as a building block","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["basic","math","template","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // Coordinate Mapping\n    // ============================\n\n    // uv alternative where the coordinate grid is not stretched i.e. a square is square\n    // and (-1,-1) to (1,1) is on screen\n    vec2 ab = (2.*fragCoord - iResolution.xy )/min(iResolution.x,iResolution.y);\n    // Same but for mouse pos\n    vec2 mn = (2.*iMouse.xy - iResolution.xy )/min(iResolution.x,iResolution.y);\n    \n    // Rotation\n    // ============================\n    \n    // See https://www.desmos.com/3d/3743fa9787\n    // alpha = the amount of rotation\n    float alpha = -length( mn );\n    // D = the direction in the XY plane onto which we want to rotate the z vector to\n    vec3 D = vec3( normalize(mn), 0. );\n    // v1 = ortogonal to D and inside the xy plane\n    vec3 v1 = vec3( -D.y, D.x, 0. );\n    // v2 = z vector\n    vec3 v2 = vec3( 0.,0.,1. );\n    \n    //rX rotated X vector\n    vec3 rX = v1 * v1.x + v1.y * ( D * cos( alpha ) - v2 * sin( alpha ) );\n    //rY rotated Y vector\n    vec3 rY = v1 * v1.y + v1.x * ( v2 * sin( alpha ) - D * cos( alpha ) );\n    //rZ rotated Z vector\n    vec3 rZ = D * sin( alpha ) + v2 * cos( alpha );\n    \n    // Plane intersection\n    // ============================\n    // https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\n    \n    // Plane offset\n    vec3 p0 = vec3(0.,0.,2.);\n    // Plane Normal\n    vec3 n = rZ;\n    \n    //Ray Start\n    vec3 l0 = vec3( ab, 0. );\n    // Ray direction\n    // Perspective\n    vec3 l = l0 + vec3( 0.,0.,1. );\n    // Orthogonal\n    //vec3 l = + vec3( 0.,0.,1. );\n    \n    //intersection point\n    float t = dot( p0 - l0, n ) / dot( l, n );\n    vec3 p = l0 + l * t;\n    \n    // Plane Mapping\n    // ============================\n    // Map plane to plane local coordinates\n    \n    // local x\n    float lx = dot( p - p0, rX );\n    // local y\n    float ly = dot( p - p0, rY );\n    \n    // Showing the result\n    // ============================\n    \n    fragColor = vec4(vec3(0.), 1.);\n    \n    vec2 uv = vec2( (lx + 1.) / 2., (ly + 1.) / 2. );\n\n    if( lx < 1. && -1. < lx )\n    if( ly < 1. && -1. < ly )\n    fragColor.xy = uv;\n    \n    \n}\n","name":"Image","description":"","type":"image"}]}