{"ver":"0.1","info":{"id":"wllSzN","date":"1562320416","viewed":472,"name":" GPU hacks #12 - DX11 Pixel Sh.","username":"PrzemyslawZaworski","description":"Comment contains DirectX 11 framework for vertex and pixel shaders - with working example, visually equivalent to visible shader.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["framework","lighting","code","science","directx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCode tested with Windows 10 and RTX 2070.\nSave file as lights.c and compile with Visual Studio command line:\ncl.exe lights.c d3d11.lib dxguid.lib user32.lib kernel32.lib gdi32.lib d3dcompiler.lib\n*/\n\n/*\n#include <Windows.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n\n#define WIDTH 1280 \n#define HEIGHT 720\n\nconst unsigned char VertexShader[] =\n{\n\t\"static const float3 vertices[6] = {float3(1,-1,0),float3(-1,-1,0),float3(1,1,0), float3(-1,-1,0),float3(-1,1,0),float3(1,1,0)};\"\n\t\"static const float2 uvs[6] = {float2(1,0),float2(0,0),float2(1,1), float2(0,0),float2(0,1),float2(1,1)};\"\n\t\"void VSMain(out float4 vertex:SV_POSITION, out float2 uv:TEXCOORD0, in uint id:SV_VertexID)\"\n\t\"{\"\t\n\t\t\"uv = uvs[id];\"\n\t\t\"vertex = float4(vertices[id], 1);\"\n\t\"}\"\n};\n\nconst unsigned char PixelShader[] =\n{\n\t\"cbuffer Constants : register(b0)\"\n\t\"{\"\n\t\t\"float iTime;\"\n\t\"};\"\n\t\"float3 surface (float2 uv)\"\n\t\"{\"\n\t\t\"float2 k = 0;\"\n\t\t\"for (float i=0.0;i<64.0;i++)\"\n\t\t\"{\"\n\t\t\t\"float2 q = float2(i*127.1+i*311.7,i*269.5+i*183.3);\"\n\t\t\t\"float2 h = frac(sin(q)*43758.5453);\"\n\t\t\t\"float2 p = cos(h*iTime);\"\n\t\t\t\"float d = length(uv-p);\"\n\t\t\t\"k+=(1.0-step(0.06,d))*h;\"\n\t\t\"}\"\n\t\t\"return float3(0.0,k);\"\n\t\"}\"\t\n\t\"float4 PSMain(float4 vertex:SV_POSITION, float2 uv:TEXCOORD0) : SV_TARGET\"\n\t\"{\"\t\n\t\t\"float2 p = float2(2.0*uv-1.0)/(1.0-uv.y);\"\n\t\t\"float3 c = 0;\"\n\t\t\"float2 d = (float2(0.0,-1.0)-p)/float(80);\"\n\t\t\"float w = 1.0;\"\n\t\t\"float2 s = p;\"\n\t\t\"for( int i=0; i<80; i++ )\"\n\t\t\"{\"\n\t\t\t\"float3 res = surface(s);\"\n\t\t\t\"c += w*smoothstep(0.0, 1.0, res);\"\n\t\t\t\"w *= 0.97;\"\n\t\t\t\"s += d;\"\n\t\t\"}\"\n\t\t\"c = c * 8.0 / float(80);\"\n\t\t\"return float4(c, 1.0);\"\n\t\"}\"\n};\n\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tif ((uMsg == WM_KEYUP && wParam == VK_ESCAPE) || uMsg==WM_CLOSE || uMsg==WM_DESTROY)\n\t{\n\t\tPostQuitMessage(0); return 0;\n\t}\n\telse\n\t{\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\n\t}\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\tint exit = 0;\n\tMSG msg;\n\tWNDCLASS win = {CS_OWNDC|CS_HREDRAW|CS_VREDRAW, WindowProc, 0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, \"DirectX 11\"};\n\tRegisterClass(&win);\n\tHWND hwnd = CreateWindowEx(0, win.lpszClassName, \"DirectX 11\", WS_VISIBLE|WS_OVERLAPPEDWINDOW, 0, 0, WIDTH, HEIGHT, 0, 0, 0, 0);\t\n\tID3D11Device *device;\n\tIDXGISwapChain *surface;\n\tID3D11DeviceContext *context;     \n\tID3D11Resource *image;\t\n\tID3D11RenderTargetView *target;\n\tID3D11VertexShader *vs;\n\tID3D11PixelShader *ps;\n\tID3DBlob* VSblob;\n\tID3DBlob* PSblob;\t\n\tID3D11Buffer *buffer; \n\tD3D11_MAPPED_SUBRESOURCE resource;\n\tDXGI_SWAP_CHAIN_DESC sd = {{WIDTH, HEIGHT, 0, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, 0 }, {1, 0}, (1L << (1 + 4)) | (1L << (6 + 4)) | (1L << (0 + 4)), 1, hwnd, 1, 1, 0};\n\tD3D11CreateDeviceAndSwapChain(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, 0, 0, D3D11_SDK_VERSION, &sd, &surface, &device, 0, &context); \t\n\tsurface->lpVtbl->GetBuffer(surface, 0, (REFIID) &IID_ID3D11Resource, ( LPVOID* )&image );\n\tD3D11_BUFFER_DESC desc = {16, D3D11_USAGE_DYNAMIC, D3D11_BIND_CONSTANT_BUFFER, D3D11_CPU_ACCESS_WRITE, 0, 0};\t\n\tdevice->lpVtbl->CreateBuffer(device, &desc, 0, &buffer);\n\tdevice->lpVtbl->CreateRenderTargetView(device, image, 0, &target);\n\tcontext->lpVtbl->OMSetRenderTargets(context,1, &target, 0);\n\tD3D11_VIEWPORT vp = {0,0,WIDTH,HEIGHT,0.0f,1.0f};\n\tcontext->lpVtbl->RSSetViewports(context,1, &vp);\n\tD3DCompile(&VertexShader, sizeof VertexShader, 0, 0, 0, \"VSMain\", \"vs_5_0\", 1 << 15, 0, &VSblob, 0);\t\t\n\tdevice->lpVtbl->CreateVertexShader(device, VSblob->lpVtbl->GetBufferPointer(VSblob), VSblob->lpVtbl->GetBufferSize(VSblob), 0, &vs);\n\tD3DCompile(&PixelShader, sizeof PixelShader, 0, 0, 0, \"PSMain\", \"ps_5_0\", 1 << 15, 0, &PSblob, 0);\t\t\n\tdevice->lpVtbl->CreatePixelShader(device, PSblob->lpVtbl->GetBufferPointer(PSblob), PSblob->lpVtbl->GetBufferSize(PSblob), 0, &ps);\t\n\tcontext->lpVtbl->IASetPrimitiveTopology(context,D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);\n\twhile (!exit)\n\t{\n\t\twhile (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tif (msg.message == WM_QUIT) exit = 1;\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\n\t\tcontext->lpVtbl->Map(context,(ID3D11Resource*)buffer, 0, D3D11_MAP_WRITE_DISCARD, 0,  &resource);\n\t\tfloat time[] = {GetTickCount() * 0.001f};\n\t\tmemcpy(resource.pData, time, sizeof(float));\t\t\n\t\tcontext->lpVtbl->Unmap(context, (ID3D11Resource *)buffer, 0);\t\t\t\n\t\tcontext->lpVtbl->VSSetShader(context, vs, 0, 0 );\n\t\tcontext->lpVtbl->PSSetShader(context, ps, 0, 0 );\n\t\tcontext->lpVtbl->PSSetConstantBuffers(context, 0, 1, &buffer );\t\n\t\tcontext->lpVtbl->Draw(context, 6, 0);\t\t\n\t\tsurface->lpVtbl->Present(surface, 0, 0 );\n\t}\n\treturn 0;\n}\n*/\n\nvec3 surface (vec2 uv)\n{\n    vec2 k = vec2(0.0,0.0); \n\tfor (float i=0.0;i<64.0;i++)\n\t{\n\t\tvec2 q = vec2(i*127.1+i*311.7,i*269.5+i*183.3);\n\t\tvec2 h = fract(sin(q)*43758.5453);\n\t\tvec2 p = cos(h*iTime+1.0);\n\t\tfloat d = length(uv-p);\n\t\tk+=(1.0-step(0.06,d))*h;\n\t}\n\treturn vec3(0.0,k.x,k.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * uv-1.0) / (1.0-uv.y) ;  \n    vec3 c = vec3(0.0,0.0,0.0);\n    vec2 d = (vec2(0.0,-1.0)-p)/float(80);\n    float w = 1.0;\n    vec2 s = p;\n    for( int i=0; i<80; i++ )\n    {\n        vec3 res = surface(s);\n        c += w*smoothstep( 0.0, 1.0, res );\n        w *= .97;\n        s += d;\n    }\n    c = c * 0.12;\n\tfragColor = vec4( c,1.0 );\n}","name":"Image","description":"","type":"image"}]}