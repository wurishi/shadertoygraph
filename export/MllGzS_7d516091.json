{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//\tThis shader takes random 2D slices through the 4D Julia set space.\n\n//\tThe Mandelbrot set and Julia set generative formulas can be generalized as:\n//\tZ(0) = a + b*i\n//\tZ(n+1) = Z(n)^2 + c + d*i\n//\tStarting a and b at zero generates the Mandelbrot set.\n//\tForcing c and d to remain constant generates a Julia set.\n//\tTogether, these parameters (a, b, c, d) form a four dimensional space.\n//\tThis shader randomly takes a two dimensional slice through this space.\n\n//\tFractal iteration and supersampling adapted from iq:\n//\thttps://www.shadertoy.com/view/4df3Rn\n\n//\tHash function adapted from David Hoskins:\n//\thttps://www.shadertoy.com/view/4djSRW\n\n\n//\tSupersampling factor\n#define AA 3\n\n//\tMaximum fractal iteration\n#define ITER 256\n\n//\t4D Fractal Brownian Motion used for sampling\nvec4 fbm41(float p);\n\n//\tSpecify the 4D sample position as a function of time and screen position\nvec4 getPos(vec2 screenPos, float time) {\n    \n    //\t4D center of image\n    vec4 center = vec4(0.0, 0.0, -0.75, 0.0) + 0.7 * fbm41(0.3 * time);\n\n    //\t4D x and y unit vectors\n    vec4 x = normalize(fbm41(0.2 * time));\n    vec4 y = fbm41(0.2 * time + 9.33);\n    y = normalize(y - x * dot(x, y));\n\n    //\tZoom factor\n    screenPos *= 1.2;\n\n    return center + screenPos.x * x + screenPos.y * y;\n}\n\nvec4 hash41(float p) {\n\tvec4 p2 = fract(p * vec4(5.3983, 5.4427, 6.9371, 5.8815));\n    p2 += dot(p2.zwxy, p2.xyzw + vec4(21.5351, 14.3137, 15.3219, 19.6285));\n\treturn fract(vec4(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.w * 93.8365, p2.w * p2.x * 91.7612));\n}\n\nvec4 noise41(float p) {\n    float i = floor(p);\n    float f = fract(p);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(hash41(i), hash41(i + 1.0), u);\n}\n\nvec4 fbm41(float p) {\n    vec4 f = noise41(p); p *= 2.01;\n    f += 0.4 * noise41(p); p *= 2.01;\n    f += 0.16 * noise41(p); p *= 2.01;\n    f += 0.064 * noise41(p);\n    return f / 1.624;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = vec3(0.0);\n#if AA > 1\n    for (int m = 0; m < AA; m++)\n    for (int n = 0; n < AA; n++) {\n        vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + vec2(float(m), float(n)) / float(AA))) / iResolution.y;\n        float w = float(AA * m + n);\n        float time = iTime + 0.02 * w / float(AA * AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n        float time = iTime;\n#endif\n\t\tvec4 pos = getPos(p, time);\n\n        float outside = 0.0;\n        float count = 0.0;\n        vec2 z = pos.xy;\n        vec2 c = pos.zw;\n        for (int i = 0; i < ITER; i++) {\n            z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n\n            if (dot(z, z) > 40.0) {\n                outside = 1.0;\n                break;\n            }\n            count += 1.0;\n        }\n\n        float grad = count - log2(log2(dot(z, z)));\n        color += outside * (0.5 + 0.5 * cos(0.25 * grad + vec3(3.0, 4.0, 5.0)));\n#if AA > 1\n    }\n    color /= float(AA * AA);\n#endif\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MllGzS","date":"1423123083","viewed":333,"name":"Julia Slice","username":"mhnewman","description":"Random 2D slice through 4D Julia set space","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","julia","mandelbrot","4d"],"hasliked":0,"parentid":"","parentname":""}}