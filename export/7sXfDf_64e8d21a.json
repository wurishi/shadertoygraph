{"ver":"0.1","info":{"id":"7sXfDf","date":"1645616508","viewed":396,"name":"Tileable, Seedable Cell Noise","username":"leoxshn","description":"Tileable 3D Cell Noise with seed","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","worley","tileable","cell"],"hasliked":0,"parentid":"wlfyDs","parentname":"Tileable Cell Noise"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat random(in vec2 xy, in float seed) {\n    const float PHI = 1.61803398874989484820459;\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n// I sure this is not the propper way to do it, but i wanna maximize performance\nvec3 _cell_noise_hash(in vec3 p, in vec3 limit, in float seed) {\n    p = mod(p, limit);\n    float x = random(p.xy + p.zz, seed);\n    float y = random(x - p.yx, seed + 1.0);\n    return vec3(x, y, 1.0 - x);\n}\n\n// Zagura's modded cell/voronoi noise\n// returns vec3 of\n//   x: dist to closest neighbour [0, 1]\n//   y: avg of ids                [0, 1]\n//   z: id                        [0, 1]\nvec3 cell_noise(in vec3 p, in vec3 frequency, in vec3 limit, in float seed) {\n    p *= frequency;\n    vec3 n = floor(p);\n    float d = 1.0e10;\n    vec2 avg_id = vec2(0.0);\n    float id = 0.0;\n    for (int xo = -1; xo <= 1; xo++) {\n        for (int yo = -1; yo <= 1; yo++) {\n            for (int zo = -1; zo <= 1; zo++) {\n                vec3 tp = n + vec3(xo, yo, zo);\n                vec3 o = _cell_noise_hash(tp, limit * frequency, seed);\n                tp = p - tp - o;\n                float dtp = min(dot(tp, tp),1.0);\n                if (dtp < d) {\n                    d = dtp;\n                    id = o.y;\n                }\n                float w = pow(1.0-dtp,4.0);\n                avg_id += vec2(o.y*w, w);\n            }\n        }\n    }\n    return vec3(d, sqrt(avg_id.x/avg_id.y), id);\n}\n\n//----------------------------------------------------------------------------------------\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n//#define SHOW_2D_VERSION 1\n#ifdef SHOW_2D_VERSION\n    // uv should be within 0-1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // debug for tiling\n    \n    float c = cell_noise(vec3(uv * 10.0, iTime * 0.08), vec3(1.0, 2.0, 1.0), vec3(5.0), 2.0).y * 0.5 + 0.5;\n    c = c * c;\n    fragColor = vec4(c, c, c , 1.0);\n#else\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif(h>0.0) {\n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot(rd, ce);\n\tfloat c = dot(ce, ce) - 1.0;\n\th = b*b - c;\n\tif(h>0.0) {\n\t\th = -b - sqrt(h);\n\t\tif(h<tmin) { \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif(tmin<100.0) {\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n\t\tf = cell_noise(pos + vec3(0.0, 0.2 * iTime, 0.0), vec3(4.0), vec3(7.0), round(iTime)).y;\n\t\tcol = vec3(f);\n\t}\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n    \n#endif\n}","name":"Image","description":"","type":"image"}]}