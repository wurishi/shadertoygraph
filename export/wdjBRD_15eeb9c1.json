{"ver":"0.1","info":{"id":"wdjBRD","date":"1729310075","viewed":252,"name":"Sound Reverb Simulation v2","username":"Kushulain","description":"Configurable reverb simulation using planes to reflect sound.\nIt processes the reverb by adding many small delays together (blue graph displays the reverb shape)\nProcesses up to 2 bounces.\n","likes":6,"published":3,"flags":40,"usePreview":0,"tags":["sound","simulation","reverb","acoustic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 Get(float varID)\n{\n    vec2 varSamplePos = vec2(0.,0.);\n    varSamplePos.x = mod((varID+0.5), bufferedVariableX);\n    varSamplePos.y = floor((varID+0.5) / bufferedVariableX);\n    \n    varSamplePos.y += 0.5;\n    varSamplePos.x /= bufferedVariableX;\n    varSamplePos.y /= bufferedVariableY;\n    \n    \n    return texture(iChannel0,varSamplePos).rgba;\n}\n\nvec4 GetReverbShapeInBuffer(float reverbID)\n{\n    return Get(reverbShapePosInBuffer + reverbID);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvNormalized = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    float time = Get(V_TIME).x;\n    \n    //time -= 0.2;\n    \n    time *= timeMul;\n    \n\tuv.y -= 0.5;\n\tuv.x -= 0.5 * iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));\n    col *= 0.;\n    \n    \n    if (length(listenerPos-uv) < 0.02)\n        col = vec3(0.7,0.2,0.1);\n    \n    if (length(audioPos-uv) < 0.02)\n        col = vec3(0.5,0.8,0.2);\n    \n    \n    float sampleSegmentPerWall_f = float(sampleSegmentPerWall);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    vec2 leftChannelSpace = uvNormalized;\n    leftChannelSpace.x *= 2.0;\n    leftChannelSpace.x = 1.0 - leftChannelSpace.x;\n    \n    float listenerDelayTime = ListenerDelayTime();\n    \n    float listenerDelayedTime = time - listenerDelayTime;\n    int curReverbShapeID = int(TimeToReverbShape(listenerDelayedTime));\n    \n    \n    float reverbShapeResolution_f = float(reverbShapeResolution);\n    for (int i=0; i<reverbShapeResolution; i++)\n    {\n        float i_f_a = float(i) / reverbShapeResolution_f;\n        float i_f_b = i_f_a + 1.0 / reverbShapeResolution_f;\n        \n        if (leftChannelSpace.x > i_f_a && leftChannelSpace.x < i_f_b)\n        {\n            float intensity = GetReverbShapeInBuffer(float(i)).x * 1.0;\n            \n            if (leftChannelSpace.y < intensity)\n            {\n               fragColor.gb += vec2(0.4) ;\n            }\n            \n            if (i == curReverbShapeID && leftChannelSpace.y < 0.2)\n            {\n               fragColor.r += 0.4 ;\n            }\n        }\n    }\n    \n    vec2 rightChannelSpace = uvNormalized;\n    rightChannelSpace.x *= 2.0;\n    rightChannelSpace.x -= 1.;\n    for (int i=0; i<reverbShapeResolution; i++)\n    {\n        float i_f_a = float(i) / reverbShapeResolution_f;\n        float i_f_b = i_f_a + 1.0 / reverbShapeResolution_f;\n        \n        if (rightChannelSpace.x > i_f_a && rightChannelSpace.x < i_f_b)\n        {\n            float intensity = GetReverbShapeInBuffer(float(i)).y * 1.0;\n            \n            if (rightChannelSpace.y < intensity)\n            {\n               fragColor.gb += vec2(0.4) ;\n            }\n            \n            if (i == curReverbShapeID && leftChannelSpace.y < 0.2)\n            {\n               fragColor.r += 0.4 ;\n            }\n        }\n    }\n    \n    listenerPos = uv;\n    float globalTotalIntensity = 0.0;\n    \n    for (int i=0; i<wallCount; i++)\n    {\n        vec2 wallSpace = World2WallSpace(uv, i);\n        \n        wallFirstBouncess = GetWallBounce(i);\n        \n        vec2 wallStart = WallSpace2World(vec2(0.,-1.0), i);\n        vec2 wallEnd = WallSpace2World(vec2(0.,1.0), i);\n        \n        if (abs(wallSpace.x) < 1.0 && abs(wallSpace.y) < 1.0)\n        {\n            fragColor.rgb = vec3(0.6);\n        }\n        \n        \n        for (int k=0; k<samplePerWall; k++)\n        {\n            vec2 dist_Intensity = ListenToSoundVec(wallFirstBouncess[k], -wallFirstBouncess[k].direction);\n            \n            float timeToAudio = dist_Intensity.x / speedOfSound;\n            \n            float radius = max(0.0,((time-timeToAudio)*speedOfSound));\n            \n            globalTotalIntensity += (dist_Intensity.y * DistanceAttenFactor(dist_Intensity.x));\n            \n           \n            if (radius > 0.0)\n            {\n                float colIntensity = 0.02 / (0.02+radius);\n                //colIntensity = min(0.3, colIntensity*colIntensity);\n                //colIntensity /= sampleSegmentPerWall_f;\n            \tfragColor.rgb = mix(fragColor.rgb, vec3(2.0, 1.1, 0.0), colIntensity * dist_Intensity.y);\n            \t//col += 0.1 * colIntensity * colIntensity / timeToAudio;\n                \n               // fragColor += 0.5;\n            }\n        }\n        \n        \n    }\n    globalTotalIntensity += DistanceAttenFactor(length(audioPos-uv)) * 0.5;\n    fragColor.rg = mix(fragColor.rg, vec2(1.0), globalTotalIntensity * 0.3);\n    \n    if (length(audioPos-uv) < (time*speedOfSound))\n    {\n        float radius = (time*speedOfSound) - length(audioPos-uv);\n        float colIntensity = 0.02 / (0.02+radius);\n        fragColor.rgb += vec3(0.0,colIntensity * 0.2,0.0);\n    }\n    \n    \n    \n    //fragColor += texture(iChannel0,uvNormalized).r * 10.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Design a level and then hear & visualize reverb (left & right channels)\n//why would you make reverb sim in shadertoy ? well, you might be lost on the internet for sure.\n\n// ================== BASICS :\n\n//Green dot : the audio source position\n//Red dot : the player position\n//grey lines : reverbering walls\n\n//Blue plot : reverb shape (center is direct sound, left side is left ear indirect delays)\n//Red line : a red head is sliding along the reverbshape to show current reverb time (for the audio sample at 0s)\n\n//green blast : direct sound emitted from the audio\n//orange blasts : sound reflected from the wall ('s sampling positions)\n\n//You can comment/uncomment scenes to browse different scenes.\n\n// ================== How it works :\n\n//It processes the reverb by adding many small delays together.\n\n//It reflects N sound vectors 'GetWallBounce()' on each walls from the audio to the listener. (N = samplePerWall)\n//Then the total travel distance (listener->bounce->audio) of the N bounces is used as offset in the ReverbShape. (horizontal axis of the blue plot)\n//For each wall, it interpolates results of the N bounces, to spread results in the ReverbShape.\n//For second it kind of use the same logic, instead of bouncing the audio source sound vector, it bounces previous bounces, and interpolates.\n//Walls  don't obstruct sound.\n\n\n// ================== PARAMETERS DESCRIPTION :\n\n//speedOfSound : slowing down speed of sound is same than making the scene size bigger.\n//(with no extra attenuation because of longer distances)  half of the screen = 1meter (float)\n\n//reverbShapeResolution : total sample for the reverb shape (int)\n\n//reverbMaxTime : max time after a sample can't be broadcasted again by reverb (float, seconds)\n\n//secondBounce : (true/false) enable/disable second bounce between wall (can be expensive, better to turn it off if you are making your own level)\n\n//sampleSegmentPerWall : this controls the amount of bounce sample to process on a wall, the more the better reverb quality.\n\n//wallsPosRotSize : arrat that express wall position / rotation (degree) / length.\n\n\n//=================== ABOUT PERFORMANCE :\n\n//You can save compile time by using \"#define secondBounce false\" or lowering \"sampleSegmentPerWall\"\n//shader compile time can be processed like this : reverbShapeResolution * ((samplePerWall*wallCount) + (secondBounce ? wallCount*(wallCount-1)*samplePerWall : 0.0))\n//but at some point when having more than 10 walls, compiler seems to give up optimizing and compile time goes quicker, but shader execute time takes a little longer.\n\n\n\n//==================== SCENES :\n\n//========= city : ~2.5s\n\n#define reverbShapeResolution 80\n#define speedOfSound 3.0\n#define sampleSegmentPerWall 2\n#define secondBounce true\n#define reverbMaxTime 1.0\nvec2 listenerPos = vec2(0,-0.1);\nvec2 audioPos = vec2(0.0,0.1);\n#define wallCount 12\nvec4 wallsPosRotSize[wallCount] = vec4[](\tvec4(0.1,0.7,95., 0.1),\n                                 \t\t\tvec4(0.1,-0.2,-8., 0.1),\n                                 \t\t\tvec4(0.35,-0.894,91., 0.1),\n                                 \t\t\tvec4(1.15,-0.567,-13., 0.1),\n                                 \t\t\tvec4(1.0,0.342,25., 0.1),\n                                 \t\t\tvec4(0.667,0.134,5., 0.05),\n                                 \t\t\tvec4(-0.167,0.37,86., 0.1),\n                                 \t\t\tvec4(-0.48,-0.12,-2.2, 0.1),\n                                 \t\t\tvec4(-0.67,-0.673,93., 0.1),\n                                 \t\t\tvec4(-0.967,-0.464,-1., 0.1),\n                                 \t\t\tvec4(-1.0,0.34,6., 0.1),\n                                 \t\t\tvec4(-0.38,-0.05,7., 0.051));\n\n\n\n//========= harbour ~5.5s\n/*\n#define reverbShapeResolution 201\n#define speedOfSound 35.0\n#define sampleSegmentPerWall 2\n#define secondBounce true\n#define reverbMaxTime 0.1\nvec2 listenerPos = vec2(0,-0.1);\nvec2 audioPos = vec2(0.0,0.1);\n#define wallCount 3\nvec4 wallsPosRotSize[wallCount] = vec4[](\tvec4(0.6,0.,25., 0.4),\n                                  \t\t\tvec4(-0.1,-0.2,0.0, 0.15),\n                                        \tvec4(-0.5,0.8,45., 0.15));\n*/\n\n\n//========= tunnel ~6.5s\n/*\n#define reverbShapeResolution 300\n#define speedOfSound 2.0\n#define sampleSegmentPerWall 10\n#define secondBounce true\n#define reverbMaxTime 0.05\nvec2 listenerPos = vec2(0,-0.5);\nvec2 audioPos = vec2(0.0,0.5);\n#define wallCount 2\nvec4 wallsPosRotSize[wallCount] = vec4[](\tvec4(0.1,0.0,0.0, 0.5),\n                                  \t\t\tvec4(-0.1,-0.0,-0., 0.5));\n*/\n\n//========= left right test ~8s\n/*\n#define reverbShapeResolution 150\n#define speedOfSound 1.0\n#define sampleSegmentPerWall 4\n#define secondBounce true\n#define reverbMaxTime 1.5\nvec2 listenerPos = vec2(0,-0.1);\nvec2 audioPos = vec2(0.0,0.1);\n#define wallCount 2\nvec4 wallsPosRotSize[wallCount] = vec4[](\tvec4(0.2,0.0,0.0, 0.1),\n                                \t\t\tvec4(-0.4,-0.0,-0., 0.5));\n*/\n\n\n\n\n\n\n#define timeMul 1.0\n#define distanceLowpass 2.0\n#define reflectFactor 2.0\n\n\n\n#define bufferedVariableX 100.0\n#define bufferedVariableY 100.0\n#define reverbShapePosInBuffer 50.0\n\n#define samplePerWall (sampleSegmentPerWall + 1)\n\n\n\n#define V_TIME 1.\n#define L_ear_dir vec2(-0.866, 0.5)\n#define R_ear_dir vec2(0.866, 0.5)\n#define deg2Rad 0.0174527\n\n//float firstBounceData[wallCount][samplePerWall];\n\nfloat intensityStart;\nfloat gTime;\n\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nfloat t(float startA, float startB, float endA, float endB)\n{\n    startA += intensityStart;\n    startB += intensityStart;\n    endA += intensityStart;\n    endB += intensityStart;\n    return clamp(smoothstep(startA,startB,gTime),0.,1.) * clamp(smoothstep(endB,endA,gTime),0.,1.);\n}\n\nvec2 World2WallSpace(vec2 wPos, int k)\n{\n    wPos -= wallsPosRotSize[k].xy;\n    \n    wPos = rot(wPos, wallsPosRotSize[k].z * deg2Rad);\n               \n    wPos.y /= wallsPosRotSize[k].w;\n    \n    wPos.x /= 0.02;\n    \n    return wPos;\n}\n\nvec2 WallSpace2World(vec2 wPos, int k)\n{\n    wPos.x *= 0.02;\n    wPos.y *= wallsPosRotSize[k].w;\n    \n    wPos = rot(wPos, - wallsPosRotSize[k].z * deg2Rad);\n    \n    wPos += wallsPosRotSize[k].xy;\n    \n    \n    return wPos;\n}\n\nvec2 GetWallNormal(int k, vec2 wPos_Side)\n{\n    vec2 normal = vec2(-1, 0.);\n    \n    \n    normal = rot(normal, - wallsPosRotSize[k].z * deg2Rad);\n    \n    if (dot(normal, wPos_Side-wallsPosRotSize[k].xy) < 0.0)\n        normal = -normal;\n        \n    return normal;\n}\n\nfloat GetGainFromEarsDirection(vec2 relativePos, vec2 earDir)\n{\n    float dist = length(relativePos);\n    float attenDir = smoothstep(-1.0,1.0,dot(earDir,relativePos/dist));\n    attenDir = 0.2 + 0.8 * attenDir;\n    \n    float attenDist = 1.0 / (1.0 + dist);\n    \n    return attenDir * attenDist;\n}\n\nvec2 uvTest;\n\n\n\n\n\nstruct SoundVector\n{\n    vec2 wPos;\n    vec2 direction; //must always be length = 1\n    float distanceFromOriginalAudio;\n    float intensity;\n};\n\nfloat ProcessAngleLossEar(vec2 soundDir, vec2 targetDir)\n{\n    float loss = smoothstep(-1.0,1.0,dot(soundDir,targetDir));\n    loss = 0.2 + 0.8 * loss;\n    \n    return loss;\n}\n\nfloat ProcessAngleLossWall(vec2 soundDir, vec2 targetDir)\n{\n    float loss = smoothstep(-1.0,1.0,dot(soundDir,targetDir));\n    loss = 0.2 + 0.8 * loss;\n    \n    //float loss = max(0.0, dot(soundDir,targetDir));\n    \n    \n    return loss;\n}\n\nfloat DistanceAttenFactor(float dist)\n{\n    return 1.0 / (1.0 + dist);\n}\n\nvec2 ListenToSoundVec(SoundVector soundVec, vec2 earDir)\n{\n    float finalDistance = soundVec.distanceFromOriginalAudio + length(soundVec.wPos-listenerPos);\n    \n    vec2 relpos = listenerPos - soundVec.wPos;\n    vec2 relposNorm = normalize(relpos);\n    \n    float attenDirPos = ProcessAngleLossWall(soundVec.direction, relposNorm);\n    float attenEarDir = ProcessAngleLossEar(earDir,-relposNorm);\n    float distanceAttenFactor = DistanceAttenFactor(finalDistance);\n    \n    float finalIntensity = soundVec.intensity * attenEarDir * attenDirPos * distanceAttenFactor;\n    \n    return vec2(finalDistance, finalIntensity);\n}\n\nSoundVector Bounce(SoundVector soundVec, vec2 bounceWpos, vec2 bounceNormal, float loss)\n{\n    SoundVector newSoundVec = soundVec;\n    \n    vec2 bounceRelPos = bounceWpos-soundVec.wPos;\n    float bounceRelPosLength = length(bounceRelPos);\n    vec2 bounceRelPosNorm = bounceRelPos/bounceRelPosLength;\n    \n    if (dot(bounceNormal,bounceRelPos) > 0.0)\n        bounceNormal = -bounceNormal;\n    \n    newSoundVec.wPos = bounceWpos;\n    newSoundVec.direction = reflect(bounceRelPosNorm, bounceNormal);\n    newSoundVec.distanceFromOriginalAudio += bounceRelPosLength;\n    \n    newSoundVec.intensity *= loss;\n    newSoundVec.intensity *= ProcessAngleLossWall(soundVec.direction, bounceRelPosNorm);\n    \n    return newSoundVec;\n}\n\nfloat ListenerDelayTime()\n{\n    return length(listenerPos-audioPos) / speedOfSound;\n}\n\nfloat TimeToReverbShape(float listenerDelayedTime)\n{\n    return float(reverbShapeResolution)*(listenerDelayedTime/reverbMaxTime);\n}\n\nvec2[reverbShapeResolution] reverbShape;\n\nvec3 listen_Dist_LRIntensity[samplePerWall];\n#define test\nvoid AddSampleToReverbShape()\n{\n    \n    float reverbShapeCoord[samplePerWall];\n    float listenerDelay = ListenerDelayTime();\n        \n    for (int i=0; i<samplePerWall; i++)\n    {\n        reverbShapeCoord[i] = TimeToReverbShape(listen_Dist_LRIntensity[i].x / speedOfSound - listenerDelay);\n        \n        if (i > 0)\n        {\n            if (reverbShapeCoord[i] > reverbShapeCoord[i-1])\n                reverbShapeCoord[i] = max(reverbShapeCoord[i], reverbShapeCoord[i-1] + 1.0);\n            else\n                reverbShapeCoord[i] = min(reverbShapeCoord[i], reverbShapeCoord[i-1] - 1.0);\n        }\n    }\n        \n    float reverbShapeCoordWeight[samplePerWall];\n    \n    if (samplePerWall > 2)\n    {\n        for (int i=0; i<samplePerWall; i++)\n        {\n            if (i == 0)\n                reverbShapeCoordWeight[i] = 1.0 / abs(reverbShapeCoord[i]-reverbShapeCoord[i+1]);\n            else if (i == (samplePerWall-1))\n                reverbShapeCoordWeight[i] = 1.0 / abs(reverbShapeCoord[i]-reverbShapeCoord[i-1]);\n            else\n                reverbShapeCoordWeight[i] = 1.0 / mix(abs(reverbShapeCoord[i]-reverbShapeCoord[i-1]),abs(reverbShapeCoord[i+1]-reverbShapeCoord[i]),0.5);\n        }\n    }\n    else\n    {\n        reverbShapeCoordWeight[0] = 1.0 / abs(reverbShapeCoord[0]-reverbShapeCoord[1]);\n        reverbShapeCoordWeight[1] = 1.0 / abs(reverbShapeCoord[1]-reverbShapeCoord[0]);\n    }\n    \n    \n    float reverbShapeResolution_f = float(reverbShapeResolution);\n    \n    for (int i=0; i<sampleSegmentPerWall; i++)\n    {\n            \n        vec3 start_d_LRf = listen_Dist_LRIntensity[i];\n        vec3 end_d_LRf = listen_Dist_LRIntensity[i+1];\n        \n        \n        float a = reverbShapeCoord[i];\n        float b = reverbShapeCoord[i+1];\n        \n        \n        float reverbStart = min(a,b);\n        float reverbEnd = max(a,b);\n        \n        start_d_LRf.yz *= reverbShapeCoordWeight[i];\n        end_d_LRf.yz *= reverbShapeCoordWeight[i+1];\n        \n        bool reversed = reverbStart != a;\n        \n        if (reversed) //swap\n        {\n            vec3 temp = start_d_LRf;\n            start_d_LRf = end_d_LRf;\n            end_d_LRf = temp;\n        }\n        \n        \n        float count = reverbEnd - reverbStart;\n        \n        \n        float progress = 0.0;\n        \n        int reverbID = int(reverbStart);\n        reverbEnd = min(reverbShapeResolution_f - 1.0, reverbEnd);\n            \n        for (float i=reverbStart ; i<ceil(reverbEnd); i += 1.0)\n        {\n            float tipFactor = 1.0;\n            \n            if (i == reverbStart)\n            {\n                tipFactor = ceil(reverbStart) - reverbStart;\n            }\n            else if (i >= floor(reverbEnd))\n            {\n                tipFactor = reverbEnd - floor(reverbEnd);\n            }\n            \n            reverbShape[reverbID] += tipFactor * mix(start_d_LRf.yz, end_d_LRf.yz, progress/count);\n            \n            progress += tipFactor;\n            \n            reverbID++;\n        }\n        \n        /*for (int p=0; p<sampleSegmentPerWall; p++)\n        {\n        \treverbShape[p] += 0.01 * ( start_d_LRf.yz + end_d_LRf.yz);\n        }*/\n        \n    }\n}\n\nSoundVector[samplePerWall] GetWallBounce(int wallID)\n{\n    //int samplePerWall = sampleSegmentPerWall + 1;\n    \n    float samplePerWall_f = float(samplePerWall);\n    float sampleSegmentPerWall_f = float(sampleSegmentPerWall);\n    \n    //vec2 dist_factor_L[samplePerWall];\n    //vec2 dist_factor_R[samplePerWall];\n    \n    \n    SoundVector soundVecs[samplePerWall];\n    \n    vec2 wallStart = WallSpace2World(vec2(0.,-1.0), wallID);\n    vec2 wallEnd = WallSpace2World(vec2(0.,1.0), wallID);\n    vec2 wallNormalFromListener = GetWallNormal(wallID, listenerPos);\n    vec2 wallNormalFromSource = -GetWallNormal(wallID, audioPos);\n    \n    SoundVector audioEmit;\n    audioEmit.wPos = audioPos;\n    audioEmit.distanceFromOriginalAudio = 0.;\n    audioEmit.intensity = 1.;\n    \n    for (int i=0; i<samplePerWall; i++)\n    {\n        float progress = float(i) / sampleSegmentPerWall_f;\n        vec2 wallSamplePos = mix(wallStart, wallEnd, progress);\n        \n        audioEmit.direction = normalize(wallSamplePos-audioPos);\n        \n        soundVecs[i] = Bounce(audioEmit, wallSamplePos, wallNormalFromSource, reflectFactor * atan(wallsPosRotSize[wallID].w) / sampleSegmentPerWall_f );\n    }\n    \n    \n    return soundVecs;\n    \n}\n\n\n\nvoid Get_Listener_Dist_Intensity()\n{\n    for (int i=0; i<samplePerWall; i++)\n    {\n    }\n    \n}\n\n    \nSoundVector wallFirstBouncess[samplePerWall];\nSoundVector wallSecondBounces[samplePerWall];\n\nvoid Get_Listener_Dist_LRIntensity_FIRST()\n{\n    for (int i=0; i<samplePerWall; i++)\n    {\n        listen_Dist_LRIntensity[i].xy = ListenToSoundVec(wallFirstBouncess[i], L_ear_dir);\n        listen_Dist_LRIntensity[i].z = ListenToSoundVec(wallFirstBouncess[i], R_ear_dir).y;\n    }\n    \n}\n\nvoid Get_Listener_Dist_LRIntensity_SEC()\n{\n    for (int i=0; i<samplePerWall; i++)\n    {\n        listen_Dist_LRIntensity[i].xy = ListenToSoundVec(wallSecondBounces[i], L_ear_dir);\n        listen_Dist_LRIntensity[i].z = ListenToSoundVec(wallSecondBounces[i], R_ear_dir).y;\n    }\n    \n}\n\n#define ArrdCpy(arr, destination, startID, count) for (int o=0; o<count; o++) destination[startID+o] = arr[o];\n\n#define GetdfArr(arr, destination, startID, count) for (int o=0; o<count; o++) arr[o] = destination[startID+o];\n\nvoid GetReverbShape()\n{\n    \n    \n    /*\n    for (int i=0; i<reverbShapeResolution; i++)\n    {\n        results[i] = vec2(0.,0.);\n        float weight = 0.2 * (1.-float(i)/float(reverbShapeResolution));\n        \n        weight *= abs(sin(float(i)*0.1));\n        if (i==0)\n            weight = 1.;\n        \n        \n            results[i].x = GetGainFromEarsDirection(listenerPos-audioPos, vec2(-0.951,0.309)) * weight;\n            results[i].y = GetGainFromEarsDirection(listenerPos-audioPos, vec2(0.951,0.309)) * weight;\n        \n        //results[i].x = float(i)/float(reverbShapeResolution);\n    }*/\n    \n    reverbShape[0].x = GetGainFromEarsDirection(listenerPos-audioPos, L_ear_dir);\n    reverbShape[0].y = GetGainFromEarsDirection(listenerPos-audioPos, R_ear_dir);\n    \n    //test(results[12].x*10.0, results[50].y*100.0, results);\n    \n    \n    //for (int i=0; i<wallCount; i++)\n    /*for (int i=0; i<wallCount; i++)\n    {\n    \tListenWall(i, results);\n    }*/\n    \n    //ListenWall(0, results);\n    //ListenWall(1, results);\n    \n    \n    float sampleSegmentPerWall_f = float(sampleSegmentPerWall);\n    \n    for (int i=0; i<wallCount; i++)\n    {\n        wallFirstBouncess = GetWallBounce(i);\n\n        /*listen_Dist_LRIntensity = */Get_Listener_Dist_LRIntensity_FIRST();\n\n        AddSampleToReverbShape(/*listen_Dist_LRIntensity*/);\n        \n        if (secondBounce)\n        {\n            //for (int k=i+1; k<(i+wallCount); k++)\n            for (int k=0; k<(wallCount-1); k++)\n            {\n                int wallID = (i+1) % wallCount;\n\n                vec2 wallStart = WallSpace2World(vec2(0.,-1.0), wallID);\n                vec2 wallEnd = WallSpace2World(vec2(0.,1.0), wallID);\n                vec2 wallNormalFromSource = -GetWallNormal(wallID, audioPos);\n\n                for (int a=0; a<samplePerWall; a++)\n                {\n                    float progress = float(a) / sampleSegmentPerWall_f;\n                    vec2 wallSamplePos = mix(wallStart, wallEnd, progress);\n                    \n                    for (int b=0; b<samplePerWall; b++)\n                    {\n                        wallSecondBounces[b] = Bounce(wallFirstBouncess[b], wallSamplePos, wallNormalFromSource, reflectFactor * atan(wallsPosRotSize[wallID].w) / sampleSegmentPerWall_f );\n\n                    }\n\n                    /*listen_Dist_LRIntensity = */ Get_Listener_Dist_LRIntensity_SEC();\n                    AddSampleToReverbShape(/*listen_Dist_LRIntensity*/);\n                }\n            }\n        }\n    }\n    \n    /*\n    SoundVector wallFirstBounces[samplePerWall*wallCount];\n    \n    for (int i=0; i<wallCount; i++)\n    {\n        SoundVector wallBounces[samplePerWall] = GetWallBounce(i);\n        \n        ArrlCpy(wallBounces,wallFirstBounces, i * samplePerWall, samplePerWall);\n\n    }\n    \n    for (int i=0; i<wallCount; i++)\n    {\n        SoundVector wallBouncesss[samplePerWall];\n        \n        GetlArr(wallBouncesss, wallFirstBounces, i * samplePerWall, samplePerWall);\n        \n        vec3 listen_Dist_LRIntensity[samplePerWall] = Get_Listener_Dist_LRIntensity(wallBouncesss);\n\n        AddSampleToReverbShape(listen_Dist_LRIntensity, results);\n        \n        /*for (int k=i+1; k<(i+wallCount); k++)\n        {\n            int l = mod(k,wallCount);\n        }\n    }*/\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//used to store intial reverbshape\n\n\nvec4 Get(float varID)\n{\n    vec2 varSamplePos = vec2(0.,0.);\n    varSamplePos.x = mod((varID+0.5), bufferedVariableX);\n    varSamplePos.y = floor((varID+0.5) / bufferedVariableY);\n    \n    varSamplePos.x /= bufferedVariableX;\n    varSamplePos.y /= bufferedVariableY;\n    \n    \n    return texture(iChannel0,varSamplePos).rgba;\n}\n\nvec4 GetBuffer(float reverbID)\n{\n    return Get(reverbShapePosInBuffer + reverbID);\n}\n\nfloat GetProcessedValue(vec2 posOnScreen)\n{\n    float varID = 0.;\n    posOnScreen.x *= bufferedVariableX;\n    posOnScreen.y *= bufferedVariableY;\n    \n    varID = floor(posOnScreen.x) + floor(posOnScreen.y) * bufferedVariableX;\n    \n    varID = floor(varID+0.5); //unsure float precision doesn't screw up things ?\n        \n    return varID;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 normalizedUV = fragCoord / iResolution.xy;\n    float curVarID = GetProcessedValue(normalizedUV);\n    \n    uvTest = normalizedUV;\n    \n    float time = Get(V_TIME).x;\n    float deltaT = min(0.1,iTimeDelta);\n    time += deltaT;\n    \n    if (iFrame == 0)\n    {\n             \n        GetReverbShape();\n\n        for (int i=0; i<reverbShapeResolution; i++)\n        {\n            if (curVarID == (reverbShapePosInBuffer + float(i)))\n            {\n                fragColor.xy = reverbShape[i];\n            }\n        }\n    }\n    else\n    {\n        if (GetProcessedValue(normalizedUV) == V_TIME)\n        \tfragColor = vec4(time);\n        else\n        \tfragColor = texture(iChannel0,normalizedUV);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//formants :\nvec4 A = vec4(740.,1100.,2300.,3100.);\nvec4 E = vec4(471.,1300.,2900.,4300.);\nvec4 I = vec4(200.,2400.,3000.,3900.);\nvec4 O = vec4(382.,915.,2900.,4200.);\nvec4 U = vec4(200.,1200.,1800.,3100.);\nvec4 ON = vec4(160.,600.,2800.,4000.);\nvec4 OO = vec4(200.,800.,1900.,3900.);\nvec4 AE = vec4(560.,1700.,3000.,4300.);\nvec4 AEE = vec4(620.,1832.,3000.,4300.);\nvec4 S = vec4(4000.,4100.,3200.,3200.);\nvec4 T = vec4(50.,80.,3500.,3200.);\nvec4 SH = vec4(1600.,2100.,3200.,4400.);\nvec4 F = vec4(0.,1500.,3300.,4000.);\nvec4 C = vec4(4800.,4080.,2700.,4080.);\nvec4 R = vec4(720.,570.,2300.,3100.);\nvec4 R2 = vec4(450.,1000.,0.,0.);\n\nfloat gfreq;\nfloat TAU = 6.2831;\n\n\nvec4 currentVowelFormants;\nfloat currentVowelAmount;\nvec4 currentNoiseFormants;\nfloat currentNoiseAmount;\n\nvec4 formantsLowPass = vec4(1.0);\n\nfloat Sing(float v)\n{\n    return pow(sin(gfreq*TAU*(gTime)*v)*0.5+0.5,5.0);\n}\n\n//vowel, fundamental, 4 formant, bit of noise\nfloat Vowel(vec4 formants)\n{\n    float result;\n\n    float base;\n    \n    \n    ///machine voice\n    base = Sing(1.);\n    base = 0.3*base + base*Sing(0.5);\n    \n    //loat t = mod(offsetTime,1.0/gfreq);\n    result += base*0.4;\n\n\n    result += dot(vec4(.2),base*formantsLowPass*(sin(gTime*(formants)*TAU)));\n    \n    //result += 0.1*(0.2+base)*BandNoiseOpti(formants.x,gTime)1.01;\n    //result += 0.1*(0.2+base)*BandNoiseOpti(formants.y,gTime)1.01;\n    \n   \n    return result*1.0;\n}\n\n\nvoid V(vec4 formants,float amount)\n{\n    if (amount > 0.)\n    \tcurrentVowelFormants = formants;\n    currentVowelAmount += amount;\n}\n\nfloat rnd11(float t) { return fract(sin(t*274.577)*352.841);}\n\nfloat GetSampleAt(float _time, float freqmultiplier)\n{\n    currentVowelAmount = 0.;\n    currentVowelFormants = vec4(0.);\n    float voiceOutput = 0.0;\n    \n    gTime = _time;\n    gfreq= 98.;\n    \n    vec4 dist_modulated_AEE = AEE;// * (1.0 - vec4(0.1,0.2,0.5,0.6) * freqmultiplier);\n    vec4 dist_modulated_O = O;// * (1.0 - vec4(0.1,0.2,0.5,0.6) * freqmultiplier);\n    \n    formantsLowPass = (1.0 - vec4(0.1,0.2,0.5,0.6) * freqmultiplier * (distanceLowpass / reverbMaxTime));\n    \n    formantsLowPass = max(vec4(0.0),formantsLowPass);\n    \n    intensityStart = 0.;\n    V(AEE,t(0.0,0.05,0.1,0.15));\n/*\n    intensityStart = 1.5;\n    V(AE,t(0.0,0.01,0.1,0.11));\n\n    intensityStart = 2.;\n    V(I,t(0.0,0.01,0.1,0.11));\n*/\n    \n    intensityStart = 1.5;\n    //voiceOutput += rnd11(gTime * 50.0) * t(0.0,0.01,0.01,0.02);\n    V(O,t(0.0,0.01,0.1,0.11));\n    \n    intensityStart = 3.;\n    V(AEE,t(0.0,0.01,0.03,0.06));\n    \n    intensityStart = 4.;\n    V(O,t(0.0,0.01,0.03,0.06));\n    \n    \n    voiceOutput += Vowel(currentVowelFormants) * currentVowelAmount;\n    //voiceOutput += Noise(currentNoiseFormants) * currentNoiseAmount;\n    return voiceOutput;\n}\n\nfloat Noise( float x )\n{\n    return fract( sin( 123523.9898 * x ) * 43758.5453 );\n}\n\nvec2 mainSound( in int samp, float _time )\n{\n    \n    GetReverbShape();\n    _time *= timeMul;\n    vec2 sOutput = vec2(0.,0.);\n    \n    float timeOffset = 0.;\n    float timeOffsetStep = reverbMaxTime / float(reverbShapeResolution);\n    uvTest = vec2(_time);\n    \n    _time -= ListenerDelayTime();\n    \n    for (int i=0; i<reverbShapeResolution; i++)\n    {\n        //float randomness = 0.1 * sin(0.01*_time + Noise(float(i))*TAU);\n        float totalDelay = (timeOffset);\n        float randomness = rnd11(float(i)) / float(reverbShapeResolution);\n        sOutput += GetSampleAt((_time - timeOffset) - abs(randomness), totalDelay) * reverbShape[i];\n        \n        \n        \n        timeOffset += timeOffsetStep;\n    }\n    \n    \n    //sOutput += GetSampleAt(_time);\n    //sOutput += GetSampleAt(_time - 0.25);\n    \n    //vec2 sOutput = vec2(GetSampleAt(_time));\n    \n    return sOutput;\n}","name":"Sound","description":"","type":"sound"}]}