{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// **************************************************************************\r\n// CONSTANTS\r\n\r\n#define PI 3.14159\r\n#define TWO_PI 6.28318\r\n\r\n// **************************************************************************\r\n// TWEAK PARAMS for fun\r\n\r\n// Increasing number of lights requires more compute power\r\n#define NUM_LIGHTS 3.\r\n\r\n// Decreasing min cellsize requires more compute power and you\r\n// will also need to increase the number of march iterations, \r\n// don't pick a min cell size less than 1. \r\n\r\n#define MIN_CELLSIZE 2.\r\n#define CELLSIZE_RANGE 1.\r\n#define NUM_MARCH_ITERS 120\r\n\r\n\r\n// **************************************************************************\r\n// GLOBALS\r\n\r\nfloat g_time         = 0.;\r\n\r\nvec3  g_camPointAt   = vec3(0.);\r\nvec3  g_camOrigin    = vec3(0.);\r\n\r\nmat2  g_rotateVortex = mat2(1.);\r\n\r\n// **************************************************************************\r\n// UTILITIES\r\n\r\n// Rotate the input point around the y-axis by the angle given as a  cos(angle)\r\n// and sin(angle) argument.  There are many times where  I want to reuse the\r\n// same angle on different points, so why do the  heavy trig twice. Range of\r\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\r\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\r\n{\r\n    return vec3(point.x * cosangle  + point.z * sinangle,\r\n                point.y,\r\n                point.x * -sinangle + point.z * cosangle);\r\n}\r\n\r\n// Returns the vector that is the shortest path from the 3D point to the  line\r\n// that passes through a and b. Also returns the parameter t that represents the\r\n// paramterized position along the line that p is closest to.\r\n\r\n// Returned result is:\r\n\r\n// result.xyz := vector of the path from p to q where q is defined as the point\r\n// on the line segment that is closest to p.\r\n// result.w   := the t parameter such that a + (b-a) * t = q \r\n\r\nvec4 lineToPointDistance( vec3 a, vec3 b, vec3 p)\r\n{\r\n    \r\n    vec3 ba = b - a;    \r\n    float t = dot(ba, (p - a)) / dot(ba, ba);\r\n    vec4 result = vec4(ba * t + a - p, t);\r\n    return result;\r\n}\r\n\r\n// **************************************************************************\r\n// SHADING\r\n\r\nvec2 light_swirl( float py, float idx )\r\n{\r\n    float t = smoothstep(50., 0., abs(py));\r\n    float rad = mix(10., 30., t * t);\r\n    float off = TWO_PI * idx/NUM_LIGHTS;\r\n    float rot = .05 + .05 * (smoothstep(0., 1., mod(g_time, 40.)) - smoothstep(20., 21., mod(g_time, 40.)));\r\n\r\n    float ang = rot * py - 1. * g_time + off;\r\n    return rad * vec2(sin(ang), cos(ang));\r\n}\r\n\r\nfloat light_offset( float idx )\r\n{\r\n    return mod(.19 * g_time, 1.);\r\n}    \r\n\r\nvec3 light_pos( float idx )\r\n{\r\n\r\n    float lposy = 80. - 160. * light_offset(idx);\r\n    vec3 warpp = vec3(0., lposy, 0.);\r\n    warpp.xz -= light_swirl(lposy, idx);\r\n\r\n    return warpp ;  \r\n}\r\n\r\nvec4 light_col( float py )\r\n{\r\n    float pitfade = smoothstep(80., 50., abs(py));\r\n    return pitfade * vec4(.6,.8,1.,1.);\r\n}\r\n\r\nfloat wave_pulses(vec3 pos)\r\n{\r\n    float lookup = mod(.001 * length(pos.xz) - sign(pos.y) * .009*g_time, 1.);\r\n    return texture(iChannel0, vec2(lookup, .5)).g;\r\n}\r\n\r\nvec3 shade_surface(vec3 vdir, vec3 pos, vec3 norm, vec2 uv, float alpha)\r\n{\r\n    \r\n    //vec3 basecol = mix(vec3(1., .3, .3),vec3(.3, .8, 1.), s);\r\n    vec3 basecol = mix(vec3(.9, 1., 1.2), vec3(.4, .7, 1.), alpha);\r\n\r\n    float wav = wave_pulses( pos );\r\n    vec3 scol = vec3(.3 + .7 * wav);\r\n    scol *= 1. - .5 * length(uv - .5);\r\n    scol += vec3(pow(length(uv - .5), 3.)); \r\n    scol *= basecol;\r\n    \r\n    // would expect reflect to return a normalized vector if the\r\n    // 2 vectors provided are normalized.  That's not the case at\r\n    // extreme angles, so I have to normalize again.\r\n    vec3 refldir = normalize(reflect(vdir, norm));\r\n\r\n    vec3 icol = vec3(0.);\r\n    for (float lidx = 0.; lidx < NUM_LIGHTS; lidx += 1.) \r\n    {\r\n        vec3 lpos = light_pos(lidx);\r\n        vec3 lcol = light_col(lpos.y).rgb;\r\n        \r\n        vec3 ldir = lpos - pos; float llen = length(ldir); \r\n        ldir = normalize(ldir);\r\n        float ndl = max(0., dot(ldir, norm));            \r\n\r\n        float diff = 600. * ndl * (1./(llen*llen));\r\n        float spec = 5. * (1./llen) * pow(max(0., dot(refldir , ldir)), 5.);\r\n\r\n        icol += lcol * (diff + spec);\r\n    }\r\n\r\n    icol += vec3(.02); // ambient\r\n    icol += .1 * wav; // glow\r\n\r\n    return icol * scol;\r\n}\r\n\r\nvec4 shade_light(vec3 pos, vec2 uv, vec4 l2pres, float idx)\r\n{    \r\n    float lt = light_offset(idx);\r\n    \r\n    vec2 lspace = vec2(length(l2pres.xyz), l2pres.w);\r\n    vec4 rgba = vec4(0.);         \r\n    float lpres = smoothstep(lt-.15, lt, lspace.y) - smoothstep(lt, lt+.04, lspace.y);\r\n    lpres *= smoothstep(-1., 4., lspace.x);\r\n    \r\n    float lposy = 80. - 160. * lt;\r\n\r\n    rgba.rgb = 2. * lpres * light_col(lposy).rgb;    \r\n    rgba.rgb *= vec3(1. - length(uv - .5));\r\n\r\n    rgba.a = lpres;\r\n    \r\n    return rgba;\r\n}\r\n\r\n// **************************************************************************\r\n// MARCHING\r\n\r\n// References for DDA marching:\r\n// original tutorial:  http://lodev.org/cgtutor/raycasting.html\r\n// initial shadertoy reference by fb39ca4: https://www.shadertoy.com/view/4dX3zl\r\n// optimization by iq: https://www.shadertoy.com/view/4dfGzs\r\n\r\nfloat vortex_map(vec3 p)\r\n{   \r\n    vec3 ap = abs(p);\r\n    float cellmap = 0.;\r\n\r\n    // pits\r\n    float lxz = length(ap.xz);  \r\n    float plxz = pow(lxz, .65);\r\n    \r\n    // make sure for the region of log that's undefined (plxz < 8.),\r\n    // we use a constant. cap the pit.\r\n\r\n    float threshold = mix(100., -log( plxz - 8.), step(8., plxz));\r\n    threshold += 3. * (1. - wave_pulses(p));\r\n    cellmap = smoothstep(threshold-1., threshold+2., .25 * (ap.y-12.));\r\n    \r\n    // walls    \r\n    cellmap = max(cellmap, mix(smoothstep(0., 20., lxz - 80. + .05 * ap.y * ap.y), 0., step(lxz,50.)));\r\n\r\n    return cellmap;\r\n}\r\n\r\n\r\nvoid dda_march( vec3 ro, vec3 rd,\r\n                out vec4 hitrgba)\r\n{\r\n    float cellsize = MIN_CELLSIZE + step(20., iTime) * CELLSIZE_RANGE * (smoothstep(0., 2., mod(iTime, 20.)) - \r\n                                                                               smoothstep(10., 12., mod(iTime, 20.)));\r\n\r\n    vec3 rro = ro; rro.xz *= g_rotateVortex;\r\n    vec3 rrd = rd; rrd.xz *= g_rotateVortex;\r\n\r\n    vec3 cellpos = cellsize * floor(rro * (1./cellsize));    \r\n    vec3 rs = sign(rrd);\r\n    vec3 deltaDist = cellsize/rrd; \r\n    vec3 sideDist = ((cellpos-rro)/cellsize + 0.5 + rs * 0.5) * deltaDist;    \r\n    \r\n    hitrgba = vec4(0.);\r\n\r\n    float t = 1e10;\r\n\r\n    vec3 murkcol = vec3(0.01, 0.01, 0.015);\r\n    for( int iter=0; iter<NUM_MARCH_ITERS; iter += 1 ) \r\n    {\r\n        // optimize out of loop if we've already accumulated enough surface info\r\n        if (hitrgba.a > .95) { continue; }\r\n\r\n        // increment dda marching mm := march mask\r\n        vec3 mm = step(sideDist.xyz, sideDist.yxy) * step(sideDist.xyz, sideDist.zzx);        \r\n        vec3 norm = -mm * rs;\r\n        cellpos += cellsize * mm * rs;  \r\n\r\n        // VORTEX chamber \r\n        float mapres = vortex_map( cellpos );\r\n                  \r\n        float valpha = smoothstep(0., 1., mapres);\r\n\r\n        if (valpha > 0.) {\r\n            // intersect the cube            \r\n            vec3 mini = ((cellpos-rro)/cellsize + 0.5 - 0.5*vec3(rs))*deltaDist;\r\n            t = max ( mini.x, max ( mini.y, mini.z ) );\r\n\r\n            vec3 pos = rro + rrd*t;\r\n            vec3 uvw = pos - cellpos;\r\n            vec2 uv = vec2( dot(mm.yzx, uvw), dot(mm.zxy, uvw) )/cellsize;\r\n            vec3 vdir = normalize(pos - rro);\r\n            vec3 surfcol = shade_surface(vdir, cellpos, norm, uv, valpha);\r\n            \r\n            float dfog = .1 + .9 * smoothstep(140., 80., t);            \r\n            float pitmurk = smoothstep(50., 80., abs(pos.y));\r\n\r\n            hitrgba.rgb += mix(dfog * surfcol, murkcol, pitmurk) * (1. - hitrgba.a) * valpha;\r\n            hitrgba.a += (1. - hitrgba.a) * valpha;\r\n\r\n        }\r\n\r\n        // optimize out of loop\r\n        if (hitrgba.a > .95) { continue; }\r\n\r\n        // XXX: Frustrating ANGLE lesson.  I had a version with the map\r\n        // function that calculated the cell walls and the lights together\r\n        // then I used a material id to inform the final shading (so I didn't\r\n        // have to duplicate code).  Map returned a vec2 with the alpha of\r\n        // the current cell and the id.  Worked great on Mac, but ANGLE could\r\n        // only spew black, so I had to unroll the code here. \r\n        // Lesson learned, code duplicated.\r\n\r\n        // LIGHTS\r\n        float lightalpha = 0.;\r\n        float lightidx = 0.;\r\n        vec4  lightl2pres = vec4(0.);\r\n        \r\n        for (float lidx = 0.; lidx < NUM_LIGHTS; lidx += 1.)\r\n        {\r\n\r\n            vec3 warpcellp = vec3( cellpos );\r\n            warpcellp.xz += light_swirl( cellpos.y, lidx );\r\n            vec4 l2pres = lineToPointDistance(vec3(0., 80., 0.), vec3(0., -80.0, 0.), warpcellp);\r\n            float lalpha = smoothstep(0., 8., 8. - length(l2pres.xyz));\r\n\r\n            if (lalpha >= lightalpha)\r\n            {\r\n                lightalpha = lalpha;\r\n                lightidx = lidx;\r\n                lightl2pres = l2pres;\r\n            }\r\n    \r\n        }\r\n        \r\n        if (lightalpha > 0.)\r\n        {\r\n            // intersect the cube        \r\n            vec3 mini = ((cellpos-rro)/cellsize + 0.5 - 0.5*vec3(rs))*deltaDist;\r\n            t = max ( mini.x, max ( mini.y, mini.z ) );\r\n            \r\n            vec3 pos = rro + rrd*t;\r\n            vec3 uvw = pos - cellpos;\r\n            vec2 uv = vec2( dot(mm.yzx, uvw), dot(mm.zxy, uvw) )/cellsize;\r\n    \r\n            float pitmurk = smoothstep(50., 80., abs(pos.y));\r\n            vec4 lcol = shade_light(cellpos, uv, lightl2pres, lightidx);\r\n            hitrgba += mix(lcol, vec4(murkcol, 1.), pitmurk) * (1. - hitrgba.a) * lightalpha;\r\n        }\r\n    \r\n        sideDist += mm * rs * deltaDist;  \r\n\r\n    }    \r\n\r\n}\r\n\r\n// **************************************************************************\r\n// CAMERA & GLOBALS\r\n\r\nvoid animate_globals()\r\n{\r\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\r\n    vec2 click = iMouse.xy / iResolution.xx;    \r\n    click = 2.0 * click - 1.0;  \r\n    \r\n    g_time = iTime;\r\n\r\n    // camera position\r\n    g_camOrigin = vec3(0., 0., 65.);    \r\n    float rotateYAngle    =  1. * TWO_PI * click.x;\r\n    float cosRotateYAngle = cos(rotateYAngle);\r\n    float sinRotateYAngle = sin(rotateYAngle);\r\n\r\n    g_camPointAt   = vec3(0., 15. * sin(.2 * g_time + PI - PI * click.y), 0.);\r\n\r\n    // truck the camera towards and away from vortex center\r\n    g_camOrigin.z  -= 55. * (.5 * sin(.1 * g_time + PI) + .5);\r\n\r\n    // Rotate the camera around the origin\r\n    g_camOrigin    = rotateAroundYAxis(g_camOrigin, cosRotateYAngle, sinRotateYAngle);\r\n    \r\n    float vt = -.2 * g_time;\r\n    g_rotateVortex = mat2(cos(vt), sin(vt), -sin(vt), cos(vt));\r\n    \r\n}\r\n\r\nstruct CameraData\r\n{\r\n    vec3 origin;\r\n    vec3 dir;\r\n    vec2 st;\r\n    float vignet;\r\n};\r\n\r\nCameraData setup_camera( in vec2 fragCoord )\r\n{\r\n\r\n    // aspect ratio\r\n    float invar = iResolution.y / iResolution.x;\r\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\r\n    st.y *= invar;\r\n\r\n    // calculate the ray origin and ray direction that represents\r\n    // mapping the image plane towards the scene\r\n    vec3 iu = vec3(0., 1., 0.);\r\n\r\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\r\n    vec3 ix = normalize( cross(iz, iu) );\r\n    vec3 iy = cross(ix, iz);\r\n\r\n    vec2 uv = st*0.5+0.5;\r\n    float vignet = pow(10.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),1.8);\r\n    \r\n    vec3 dir = normalize( st.x*ix + st.y*iy + vignet * iz );\r\n\r\n    return CameraData(g_camOrigin, dir, st, vignet);\r\n\r\n}\r\n\r\n// **************************************************************************\r\n// MAIN\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{   \r\n    \r\n    // ----------------------------------\r\n    // Animate globals\r\n\r\n    animate_globals();\r\n\r\n    // ----------------------------------\r\n    // Setup Camera\r\n\r\n    CameraData cam = setup_camera( fragCoord );\r\n\r\n    // ----------------------------------\r\n    // SCENE MARCHING\r\n    vec3 scenecol = vec3(0.);\r\n\r\n    vec4 hitrgba;\r\n    dda_march( cam.origin, cam.dir, hitrgba);\r\n\r\n    scenecol = hitrgba.rgb * hitrgba.a;\r\n    // ----------------------------------\r\n    // POST PROCESSING    \r\n\r\n    // Brighten\r\n    scenecol *= 1.3;\r\n    \r\n    // Gamma correct\r\n    scenecol = pow(scenecol, vec3(0.45));\r\n        \r\n\t// increase saturation\r\n\tscenecol = mix( scenecol, vec3(dot(scenecol,vec3(0.333))), -.3 );\r\n\r\n\t\r\n    fragColor.rgb = scenecol;\r\n    fragColor.a = 1.;\r\n}\r\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dS3RG","date":"1392698977","viewed":2420,"name":"Alias Vortex","username":"mplanck","description":"Continued tinkering of my Blended DDA Marching shadertoy.  Blends between smaller and larger cell sizes every 10 seconds.  Set the MIN_CELLSIZE to 1 if you have a fast-ish machine.","likes":48,"published":1,"flags":0,"usePreview":0,"tags":["ddamarch"],"hasliked":0,"parentid":"","parentname":""}}