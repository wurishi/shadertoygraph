{"ver":"0.1","info":{"id":"mtlBDf","date":"1694027064","viewed":21,"name":"waving ring","username":"tomcat7479","description":"使用sdf函数结合周期函数实现的波动效果的圆环效果","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdfCircle(vec2 p, vec2 center, float r) {\n    return length(p - center) - r;\n}\n\n\n// 平滑函数 e^(-6*|x|) x >= 0, e^(-6|x|) = e^(-6.0x),   x < 0, e^(-6|x|) = e^(6x)\n// 经过测试发现，一阶多项式即可，这里采用二阶就已经出现边界模糊不清\nvoid draw_alernate_ring(out vec4 fragColor, in vec2 fragCoord) {\n    float radius = 0.5;\n    float smooth_cofficient = -6.0;\n    vec3 background_color = 1.0 - vec3(0.41, 0.64, 0.91);\n    vec3 circle_color = vec3(0.31, 0.11, 0.48);\n    \n    vec2 center = vec2(0.0);\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float d = sdfCircle(uv, center, radius);\n\n    vec3 color = d < 0.0 ? circle_color : background_color;\n    color *= 1.0 - exp(smooth_cofficient * sqrt(abs(d)));\n    color *= 0.8 + 0.2 * cos(300.0 * d * (0.5 * sin(iTime) + 0.5));\n\n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\tdraw_alernate_ring(fragColor, fragCoord);\n}","name":"Image","description":"","type":"image"}]}