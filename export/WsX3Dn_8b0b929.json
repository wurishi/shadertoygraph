{"ver":"0.1","info":{"id":"WsX3Dn","date":"1545615903","viewed":161,"name":"Gooey metaballs","username":"Richarmeleon","description":"Metaballs with back-buffer physics. They bounce around the display area as well as eachother. Sometimes they stick together due to physics calculations that don't force them apart. The mouse controls a growing and shrinking rainbow ball with no collision.","likes":5,"published":1,"flags":32,"usePreview":1,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 loadValue(in ivec2 record)\n{\n    return texelFetch(iChannel0, record, 0);\n}\n\n// nothing interesting happens here, all the physics are done on the backbuffer\n// this just makes a running total of all balls' light that adds to a given pixel\n// if for some reason you delete all the balls, it shows a rainbow instead\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat total = 0.0, current;\n    vec4 result = vec4(0.0);\n    vec2 dv;\n    int count = int(loadValue(r_circleCount).x);\n    if (count == 0)\n    {\n        // something to look at indicating no balls\n        fragColor = hueGradient(iTime * 0.25);\n        return;\n    }\n\tfor (int i = 0; i < count; i++)\n\t{\n        dv = fragCoord - loadValue(r_circlePV(i)).xy;\n\t\tcurrent = pow(loadValue(r_circleRadius(i)).x, 2.0) / dot(dv, dv);\n        total += current;\n        if (current > 0.0)\n            result += loadValue(r_circleColor(i)) * current;\n\t}\n\tfragColor = smoothstep(total, total - 0.01, 1.0) * result;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// the r_ identifiers are for record names in the backbuffer as pixel coordinates\nconst ivec2 r_mouseP = ivec2(0, 0);\nconst ivec2 r_mouseRadius = ivec2(0, 1);\nconst ivec2 r_mouseColor = ivec2(0, 2);\nconst ivec2 r_circleCount = ivec2(0, 3);\n\nivec2 r_circlePV(in int index)\n{\n    return ivec2(index, 0);\n}\n\nivec2 r_circleRadius(in int index)\n{\n    return ivec2(index, 1);\n}\n\nivec2 r_circleColor(in int index)\n{\n    return ivec2(index, 2);\n}\n\nvec4 hueGradient(in float t)\n{\n    vec3 p = abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\n\treturn vec4((clamp(p - 1.0, 0.0, 1.0)), 1.0);\n}\n\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st, vec2(12.9898,78.233))) * iDate.w);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct circle\n{\n    vec4 pv;\n    float radius;\n    vec4 color;\n};\n\n// original locations, radiuses, and colors of the balls (velocity is set by random in first frame)\nconst circle[] sourceCircles = circle[]\n    (\n        circle(vec4( 50.0,  50.0, 0.0, 0.0), 20.0, vec4(0.0, 0.0, 0.0, 1.0)),\n        circle(vec4(100.0,  50.0, 0.0, 0.0), 20.0, vec4(0.0, 0.0, 0.5, 1.0)),\n        circle(vec4(150.0,  50.0, 0.0, 0.0), 20.0, vec4(0.0, 0.0, 1.0, 1.0)),\n        circle(vec4(200.0,  50.0, 0.0, 0.0), 20.0, vec4(0.0, 0.5, 0.0, 1.0)),\n        circle(vec4(250.0,  50.0, 0.0, 0.0), 20.0, vec4(0.0, 0.5, 0.5, 1.0)),\n        circle(vec4(300.0,  50.0, 0.0, 0.0), 20.0, vec4(0.0, 0.5, 1.0, 1.0)),\n        circle(vec4( 50.0, 100.0, 0.0, 0.0), 20.0, vec4(0.0, 1.0, 0.0, 1.0)),\n        circle(vec4(100.0, 100.0, 0.0, 0.0), 20.0, vec4(0.0, 1.0, 0.5, 1.0)),\n        circle(vec4(150.0, 100.0, 0.0, 0.0), 20.0, vec4(0.0, 1.0, 1.0, 1.0)),\n        circle(vec4(200.0, 100.0, 0.0, 0.0), 20.0, vec4(0.5, 0.0, 0.0, 1.0)),\n        circle(vec4(250.0, 100.0, 0.0, 0.0), 20.0, vec4(0.5, 0.0, 0.5, 1.0)),\n        circle(vec4(300.0, 100.0, 0.0, 0.0), 20.0, vec4(0.5, 0.0, 1.0, 1.0)),\n        circle(vec4( 50.0, 150.0, 0.0, 0.0), 20.0, vec4(0.5, 0.5, 0.0, 1.0)),\n        circle(vec4(100.0, 150.0, 0.0, 0.0), 20.0, vec4(0.5, 0.5, 0.5, 1.0)),\n        circle(vec4(150.0, 150.0, 0.0, 0.0), 20.0, vec4(0.5, 0.5, 1.0, 1.0)),\n        circle(vec4(200.0, 150.0, 0.0, 0.0), 20.0, vec4(0.5, 1.0, 0.0, 1.0)),\n        circle(vec4(250.0, 150.0, 0.0, 0.0), 20.0, vec4(0.5, 1.0, 0.5, 1.0)),\n        circle(vec4(300.0, 150.0, 0.0, 0.0), 20.0, vec4(0.5, 1.0, 1.0, 1.0)),\n        circle(vec4( 50.0, 200.0, 0.0, 0.0), 20.0, vec4(1.0, 0.0, 0.0, 1.0)),\n        circle(vec4(100.0, 200.0, 0.0, 0.0), 20.0, vec4(1.0, 0.0, 0.5, 1.0)),\n        circle(vec4(150.0, 200.0, 0.0, 0.0), 20.0, vec4(1.0, 0.0, 1.0, 1.0)),\n        circle(vec4(200.0, 200.0, 0.0, 0.0), 20.0, vec4(1.0, 0.5, 0.0, 1.0)),\n        circle(vec4(250.0, 200.0, 0.0, 0.0), 20.0, vec4(1.0, 0.5, 0.5, 1.0)),\n        circle(vec4(300.0, 200.0, 0.0, 0.0), 20.0, vec4(1.0, 0.5, 1.0, 1.0)),\n        circle(vec4( 50.0, 250.0, 0.0, 0.0), 20.0, vec4(1.0, 1.0, 0.0, 1.0)),\n        circle(vec4(100.0, 250.0, 0.0, 0.0), 20.0, vec4(1.0, 1.0, 0.5, 1.0)),\n        circle(vec4(150.0, 250.0, 0.0, 0.0), 20.0, vec4(1.0, 1.0, 1.0, 1.0))\n    );\n\nfloat mouseRadius()\n{\n    return sin(iTime * 1.0) * 50.0 + 75.0;\n}\n\nvec4 mouseP()\n{\n    return iMouse.z >= 0.0 ? iMouse : vec4(-1000.0, -1000.0, 0.0, 0.0);\n}\n\nvec4 mouseColor()\n{\n    return hueGradient(iTime * 0.25);\n}\n\nvec4 loadValue(in ivec2 record)\n{\n    return texelFetch(iChannel0, record, 0);\n}\n\nvoid storeValue(in ivec2 ipx, in ivec2 record, in vec4 value, inout vec4 fragColor)\n{\n    fragColor = (record == ipx) ? value : fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 ipx = ivec2(fragCoord - 0.5);\n    int i, j, count = sourceCircles.length();\n    float angle, velocity;\n    vec2 cv;\n    if (ipx.x > count || ipx.y > 3)\n        discard;\n    circle circles[sourceCircles.length()];\n    if (iFrame == 0)\n        for (i = 0; i < count; i++)\n        {\n            circles[i] = sourceCircles[i];\n            angle = random(circles[i].pv.xy);\n            velocity = random(circles[i].pv.xy + 1.0);\n            circles[i].pv.z = (velocity * 100.0 + 100.0) * cos(angle * 6.28318530718);\n            circles[i].pv.w = (velocity * 100.0 + 100.0) * sin(angle * 6.28318530718);\n        }\n    else\n        for (i = 0; i < count; i++)\n            circles[i] = circle(loadValue(r_circlePV(i + 1)), loadValue(r_circleRadius(i + 1)).x, loadValue(r_circleColor(i + 1)));\n    if (ipx.x == 0)\n    {\n        storeValue(ipx, r_circleCount, vec4(float(count + 1), 0.0, 0.0, 0.0), fragColor);\n        storeValue(ipx, r_mouseRadius, vec4(mouseRadius(), 0.0, 0.0, 0.0), fragColor);\n        storeValue(ipx, r_mouseP, mouseP(), fragColor);\n        storeValue(ipx, r_mouseColor, mouseColor(), fragColor);\n    }\n    else\n    {\n        // circle collisions\n        for (i = 0; i < count; i++)\n            for (j = i + 1; j < count; j++)\n                if (distance(circles[i].pv.xy, circles[j].pv.xy) < circles[i].radius + circles[j].radius)\n                {\n                    // this causes them to bounce but doesn't separate them\n                    // they may continue to overlap and repeately bounce\n                    cv = circles[i].pv.xy - circles[j].pv.xy;\n                    cv = normalize(cv);\n                    circles[i].pv.zw = reflect(circles[i].pv.zw, cv);\n                    circles[j].pv.zw = reflect(circles[j].pv.zw, -cv);\n                }\n        // wall collisions\n        for (i = 0; i < count; i++)\n        {\n            // these wall collision formulas always force the balls back into the display\n            // if they are off the left side, force them to have positive X movement, etc\n            if (circles[i].pv.x < circles[i].radius)\n                circles[i].pv.z = abs(circles[i].pv.z);\n            else if (circles[i].pv.x > iResolution.x - circles[i].radius)\n                circles[i].pv.z = -abs(circles[i].pv.z);\n            if (circles[i].pv.y < circles[i].radius)\n                circles[i].pv.w = abs(circles[i].pv.w);\n            else if (circles[i].pv.y > iResolution.y - circles[i].radius)\n                circles[i].pv.w = -abs(circles[i].pv.w);\n        }\n        // move them\n        for (i = 0; i < count; i++)\n            circles[i].pv.xy += circles[i].pv.zw * iTimeDelta;\n        storeValue(ipx, r_circlePV(ipx.x), circles[ipx.x - 1].pv, fragColor);\n        storeValue(ipx, r_circleRadius(ipx.x), vec4(circles[ipx.x - 1].radius, vec3(0.0)), fragColor);\n        storeValue(ipx, r_circleColor(ipx.x), circles[ipx.x - 1].color, fragColor);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}