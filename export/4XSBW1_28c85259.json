{"ver":"0.1","info":{"id":"4XSBW1","date":"1729364206","viewed":105,"name":"shining star","username":"nayk","description":"source https://www.shadertoy.com/view/4tyfWy and fractal 62","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["star","cosmos","shine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat Union(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n// 球の距離関数\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(1.);\n    else return vec2((+b + sqrt(h)), (+b + sqrt(h)));\n}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sceneSDF(vec3 p) {\n    float time = iTime;\n    float d = 100.0;\n    \n    // 球の数を定義\n    int numSpheres = 1;\n    \n    // 複数の球を生成して結合するためのループ\n    for (int i = 0; i < numSpheres; i++) {\n        float angle = float(i) * 1.3 + time; \n        vec3 spherePos = vec3(sin(angle), cos(angle * 0.5), sin(angle * 0.7));\n        \n        // 半径を変える\n        float radius = 1.02 + 0.03 * float(i % 4);  // 球の半径を少し変化させる\n        \n        // 結合\n        float dSphere = sphereSDF(p - spherePos, radius);\n        d = smin(d, dSphere, 0.5);\n    }\n    \n    return d;  // 最終的なSDFを返す\n}\n\n\n\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n\n#define time iTIme\n#define resolution iResolution.xy\n// Emulate some GLSL ES 3.x\n\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define pi 3.14159\n\nfloat func(float a, float b) {\n    return tanh(a * b) / tanh(a);\n}\n\nfloat crv(float a, float b) {\n    float tr = 2. * max(fract(b), fract(-b)) - 1.;\n    tr *= tr * (3. - 2. * tr);\n    return func(a, 1. - func(a, tr));\n}\n\nvec3 crv(float a, vec3 v) {\n    return vec3(crv(a,v.x), crv(a, v.y), crv(a, v.z));\n}\n\nfloat thc(float a, float b) {\n    return func(a, cos(b));\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * crv(4., 6.28318*(c*t+d) ); // dont think 2pi is needed \n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\n  #define n1Q(p) p *= 2.*ri(round(atan(p.x, p.y) * 4.) / 4.)\n#define ri(a) mat2(cos(a + asin(vec4(0,1,-1,0))))\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    \n     \tvec2 p3 = C/iResolution.xy;\n\tvec3 ro = vec3(0.0, 0.0, 2.0 );\n\tvec3 rd = normalize( vec3(p3,-5.0) );\n\t vec2 uv = (C - 0.5 * iResolution.xy)/iResolution.y;\n    uv *= 0.8;\n     vec2 uv2 = (C - 0.5 * iResolution.xy)/iResolution.y;\n   \n    float a = 3. * atan(uv.y, uv.x);\n    float r = (1. + 0.5 * crv(1., (2./3.) * 0.5 * a / pi - 0.2 * iTime)) * length(uv);\n    //r = log(10. * r +crv(0.1, 0.5 * a /pi + 0. * r));\n    r = log(r + 0.58* cos(r));\n     \n    float b0 = 0.5 + (1. + thc(2., 4. * a + 10. * r + thc(4., 24. * r - iTime) + iTime));\n    float b01 = thc(4., 3. * a + 10. * cos(iTime) * r - iTime);\n    float b = b0 * b01 * (1. + cos(a + 10. * r - iTime));\n    float b2 = 10. * cos(3.5 * a + 10. * cos(a - 1. * iTime) +  10. * r - iTime);\n\n    float d = crv(b2 * b, 0.5 * a / pi + 2. * r - iTime);\n    float k = 480. - 40. * b0 * b01 * b; // 0.5 * b;\n    k = clamp(k, -1., 1.);\n    float s = smoothstep(-k, k, -d + 0.8 * b);\n    \n   // s = sqrt(s);\n    s *= 0.95 + 0.1 * h21(vec2(s));\n   //s = s * s * (3. - 2. * s);\n   // s *= 2. * s;\n\n  //  float s2 = clamp(2. * r * crv(10., 0.5 * a / pi + 3. * r + iTime),0.,1.);\n    \n    vec3 e = vec3(1.);\n    vec3 col = s * pal(s + 0.1 * iTime, e, e, e, vec3(0.,0.33,0.66));\n    \n    \n    vec3 p,q,r2=iResolution,\n    d3=normalize(vec3((C*2.-r2.xy)/r2.y,1));\n   \n   vec2 p4 = (C - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // カメラの設定\n    vec3 target = vec3(0.0, 0.0, 0.0);      // カメラが注目するターゲット位置\n    vec3 cp = vec3(0.0, -7.0, -15.0);       // カメラの位置\n    vec3 cd = normalize(target - cp);       // カメラの視線方向\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n    vec3 cu = normalize(cross(cd, cs));     // 上方向\n    \n    //最初は真っ黒にする\n    vec3 col3 = vec3(0.0);\n    \n    float fov = 2.5; // 視野角\n    vec3 rd2 = normalize(cs * p4.x + cu * p4.y + cd * fov); // レイの方向\n\n    // レイマーチングのループ\n    float t = 0.0;\n    int maxSteps = 100;\n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = cp + t * rd2;\n        float d = sceneSDF(p);\n        if (d < 0.001) break;\n        t += d;\n        if (t > 20.0) break;\n    }\n\n    // ヒットしたかどうかで色を決定\n    // ヒットしたかどうかで色を決定\n    vec3 color;\n    if (t < 20.0) {\n        // オブジェクトがヒットしたらランダムな色にする\n        float r = 0.5 + 0.5 * sin(iTime + t);\n        float g = 0.5 + 0.5 * cos(iTime + t * 1.3);\n        float b = 0.5 + 0.5 * sin(iTime + t * 2.0);\n        color = vec3(r, g, b); // カラフルなオブジェクト\n    } else {\n        color = vec3(0.0) ;\n     \n    }\n   \n          \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*10./e/8e3\n    )\n    {\n        p=g*d3+col;\n       \n        vec2 c24= iSphere2(rd,rd);\n         p.xy*=c24;\n         p.z+=iTime*10.;\n       float c23=sdTorus(ro,vec2(+2.*0.5+cos(iTime*.05),2.*2.5+sin(iTime*.05)));\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        \n       n1Q(p.xy);\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.x<p.z?p=p.yyx:p;\n            p.z<=p.y?p=p.xyz:p;\n            s*=e=1.7+sin(iTime*.01)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 );\n         }\n         g+=e=length(p.yzxx)/s;\n    }\n    float c23=sdTorus(ro,vec2(+2.*0.5+cos(iTime*.05),2.*2.5+sin(iTime*.05)));\n      float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n        ;\n      O*= vec4(happy_star(uv2, anim) * vec3(0.50,0.5,0.55)*3.52+c23, 1.0);\n}","name":"Image","description":"","type":"image"}]}