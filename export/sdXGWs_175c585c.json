{"ver":"0.1","info":{"id":"sdXGWs","date":"1617659399","viewed":105,"name":"Momo The Monster (vllll)","username":"valalalalala","description":"Inverse kinetics are super cool and useful for all sorts of animation, this is a \"quick\" implementation of FABRIK.\n\nThis will hose older cards.. If you have a modern card, uncomment the define for I_AINT_AFRAID_OF_NO_SHADER\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fabrik","iksolve","inversekinematics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        //////////////////////////////////////////////////////////////////////\n       //                                                                  ///  \n      //  \"Momo The Monster\"                                              ////   \n     //                                                                  // //   \n    //  Inverse kinetics are super cool and useful for all sorts        //  //  \n   //  of animation, this is a \"quick\" implementation of FABRIK        //   // \n  //  http://www.andreasaristidou.com/publications/papers/FABRIK.pdf  //    // \n //                                                                  //    //\n//////////////////////////////////////////////////////////////////////    // \n//                                                                 //    //\n// CC0 1.0 Universal                                               //   //\n// https://creativecommons.org/publicdomain/zero/1.0/              //  //\n//                                                                 // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                               ////\n//                                                                 ///\n/////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////\n//\n// The original paper:\n// \n// http://www.andreasaristidou.com/publications/papers/FABRIK.pdf\n//\n// My (fixed) 2d js version:\n// \n// https://editor.p5js.org/luckybit4755/sketches/Pu8BCdPfm\n//\n// Related shaders:\n//\n// FABRIK demo #1 (mplanck) <-- wish I'd seed this earlier on :-P\n// https://www.shadertoy.com/view/MtdSzn\n//\n// Robotic Arm Hunting Lights (reinder)\n// https://www.shadertoy.com/view/tlSSDV\n//\n// IK Solver (iq) MIT\n// https://www.shadertoy.com/view/ldlGR7\n//\n// The Popular Shader\n// https://www.shadertoy.com/view/XdB3Dw\n//\n// Insect (iq) can't be c/p'd\n// https://www.shadertoy.com/view/Mss3zM\n//\n// Fk and IK (mxr233)\n// https://www.shadertoy.com/view/3tfGz4\n//\n// The Momo I knew was a yellow version of something like:\n//\n// https://www.youtube.com/watch?v=57uZNmIu45g\n//\n/////////////////////////////////////////////////////////////////////\n\n// #define I_AINT_AFRAID_OF_NO_SHADER\n\n#ifdef I_AINT_AFRAID_OF_NO_SHADER\n    // good times...\n    const int JOINT_COUNT  = 7;\n    const int ARM_COUNT    = 7;\n    const int FABRIK_STEPS = 17;\n#else\n    // trying to protect old cards...\n    const int JOINT_COUNT  = 3;\n    const int ARM_COUNT    = 1;\n    const int FABRIK_STEPS = 3;\n#endif\n\n#define DRAW_MISS_\n#define STOP_EARLY\n\n/////////////////////////////////////////////////////////////////////\n// implementation of the FABRIK heuristic\n\nfloat fabrik( vec3 goal, inout vec3[JOINT_COUNT] joints ) {\n    // save the lengths (could be precomputed)\n    \n    const int jointCount = joints.length();\n    \n    float total = .0;\n    float[ jointCount -1 ] lengths;\n    \n    for (int i = 0; i < lengths.length() ; i++) {\n        float d = distance( joints[ i ], joints[ i + 1 ] );\n        total += ( lengths[ i ] = d );\n    }\n    \n    // put distance goals within reach. yes, I am the nice one.\n\n    float toGoal = length( goal );\n\n    if (total < toGoal) {\n        goal = total * normalize( goal ); // note: not reflect in the render\n    }\n    \n    // forward reach: figure 1 (a-d)\n    \n    vec3[ jointCount ] forward;\n\n    forward[ jointCount - 1 ] = goal; // set last joint to to goal (figure 1.b)\n    \n    // figure 1.c and 1.d\n    for ( int i = jointCount - 2 ; i >= 0; i-- ) {\n        vec3 from = joints[ i ];    // eg, p3\n        vec3 to = forward[ i + 1 ]; // eg, p4'\n        float len = lengths[ i ];   // eg, distance from p3 to p4\n        forward[ i ] = to + len * normalize( from - to ); // eg, p3'\n    }\n\n    // backwards reach: figure 1 (e,f)\n    \n    for (int i = 1; i < jointCount ; i++ ) {\n        vec3 from = joints[ i - 1 ];  // eg, p1\"\n        vec3 to = forward[ i ];       // eg, p2'\n        float len = lengths[ i - 1 ]; // eg, distance from p1 to p2\n        joints[ i ] = from + len * normalize( to - from ); // eg, p2\"\n    }\n\n    return distance( joints[ jointCount - 1 ], goal );\n}\n\n/////////////////////////////////////////////////////////////////////\n// ik solving and drawing for each arm trying to reach its goal\n\nvec2 jointed( in vec3 p, in vec3 goal, inout vec3[JOINT_COUNT] joints ) {\n\n    // run fabrik for the current goal on with the current joints\n    \n    float old = 1e33;\n    for ( int i = 0 ; i < FABRIK_STEPS ; i++ ) {\n        float d = fabrik( goal, joints );\n        \n        #ifdef STOP_EARLY\n            if ( old < d ) break;\n            old = d;\n        #endif\n    }\n    \n    // show the goal\n\n    const int jointCount = joints.length();\n    float r = .003;\n     \n    vec2 value = vec2( sdBall( p - goal, 4. * r ), colorIndex( jointCount ) );\n    \n    // draw each joint\n    \n    for ( int i = 0 ; i < jointCount -1 ; i++, r *= .1331 ) {\n        float d = sdCapsule( p, joints[ i ], joints[ i + 1 ], r );\n        if ( d < value.x ) {\n            value.x = d;\n            value.y = float( i );\n        }\n    }\n    \n    // shouldn't miss... but...\n    \n    #ifdef DRAW_MISS\n        float d = sdCapsule( p, joints[ jointCount - 1 ], goal, r * .2 );\n        if ( d < value.x ) {\n            value.x = d;\n            value.y = colorIndex( jointCount + 1 ); \n        }\n    #endif\n    \n    return value;\n}\n\n/////////////////////////////////////////////////////////////////////\n// less and less interesting from here...\n\nvec2 map( vec3 p, float time, inout vec3[JOINT_COUNT] joints ) {\n    time *= .2;\n    vec2 t = trig( time );\n    float d = .11 + abs( t.x * .22 );\n    d *= 1.33;\n    \n    vec3 goal = d  * t.xyx;\n    goal.z = d * sin( time + 1. );\n    return jointed( p, goal,  joints );\n}\n\n\n// maybe this is a little interesting... idk...\n\nvec3[JOINT_COUNT] makeJoints() {\n    vec3[ JOINT_COUNT] joints;\n\n    float x = .0;\n    float q = .11;\n    for (int i = 0; i < JOINT_COUNT ; i++, x += q, q *= .88 ) {\n        joints[ i ] = vec3( x );\n    }\n    \n    return joints;\n}\n\nvec2 map( vec3 p ) {\n    vec3[JOINT_COUNT] joints = makeJoints();\n    \n    vec2 value = vec2( 1e33, -1. );\n    \n    for ( int i = 0 ; i < ARM_COUNT ; i++ ) {\n        vec2 j = map( p, iTime + float( i ), joints );\n        if( j.x < value.x ) value = j;\n        #ifdef JUST_ONE\n            break;\n        #endif\n    }\n    \n    return value;\n}\n\n/////////////////////////////////////////////////////////////////////\n// yeah...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fromScreen( fragCoord, iResolution );\n    vec3 color = uv.xyx * .0;\n    \n    float d = 4.;\n    \n    vec3 eye = vec3( .0, .0, -4. );\n    eye = cameraEye( d, iMouse, iResolution, iTime );\n\n    vec3 towards = vec3( .0 );\n    vec3 direction = normalize( camera( eye, towards ) * vec3( uv, d ) );\n    \n    vec2 hit = march( eye,  direction);\n    if ( hit.y  < .0 ) {\n        fragColor *= .0;\n        return;\n    }\n     \n    vec3 p = eye + hit.x * direction;\n    vec3 n = mapNormal( p, hit.x );\n    \n    color = COLORS[ int( hit.y ) ] * ( n.y * .5 + .5 );\n\n    fragColor = vec4( color, 1. );\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#ifndef HW_PERFORMANCE\n#define _SHADERTOY_TAB_COMMON // https://www.shadertoy.com/view/WldSRj\n#endif\n\nconst float FAR  = 55.;\nconst float NEAR = .01;\nconst float TAU  = 6.283185307179586;\n\nconst vec2 HILO = vec2(.1,.9);\nconst vec3[7] COLORS = vec3[] ( HILO.xxy, HILO.xyx, HILO.yxx, HILO.yxy, HILO.xyy, HILO.yyx, HILO.yyy );\n\nfloat colorIndex( int n ) {\n    return mod( float( n ), float( COLORS.length() ) );\n}\n\nvec2 map( vec3 p );\n#ifdef _SHADERTOY_TAB_COMMON\nvec2 map( vec3 p ) { return vec2( .33, 44. ); }\n#endif\n\nvec2 fromScreen( in vec2 fragCoord, in vec3 resolution ) {\n    return ( fragCoord - resolution.xy * .5 ) / resolution.y;\n}\n\n// zxy:ab,zup,xz\nmat3 camera( vec3 eye, vec3 towards ) {\n    vec3 up = vec3( .0, 1., .0 );\n    vec3 z = normalize( towards - eye );\n    vec3 x = normalize( cross( z, up ) );\n    vec3 y = normalize( cross( x, z ) );\n    return mat3( x, y, z );\n}\n\nvec2 march( vec3 eye, vec3 direction ) {\n    vec2 total = vec2( .0, -1. );\n    vec3 p = eye;\n    for ( float i = .0 ; i < FAR ; i++ ) {\n        vec2 current = map( p );\n        total.x += current.x;\n        total.y = current.y;\n        if ( total.x > FAR || abs( current.x ) < NEAR ) break;\n        p += current.x * direction;\n    }\n    total.y = mix( -1., total.y, step( total.x, FAR ) );\n    return total;\n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 mapNormal(vec3 p,float d) {\n    mat3 k = mat3( p, p, p ) - mat3( NEAR );// * d );\n    return normalize(map(p).x - vec3(map(k[0]).x,map(k[1]).x,map(k[2]).x) );\n}\n\n// lol, it's fun to go nuts\n\nvec2 trig( float a ) {\n    //return trug2( a );\n    return vec2( cos( a  * TAU ), sin( a * TAU ) );\n}\n\nvec3 cameraEye( float viewDistance, vec4 mouse, vec3 resolution, float time ) {\n    vec2 ms = mouse.z > -999999.0 ? mouse.xy / resolution.xy : vec2( time *.1, .0 );\n    vec2 t = viewDistance * trig( ms.x );\n    float ey = viewDistance * sin( (ms.y*2.-1.) * TAU * .5 );\n    return vec3( t.x, ey, t.y );\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdBall( vec3 p, float r ) {\n    return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}","name":"Common","description":"","type":"common"}]}