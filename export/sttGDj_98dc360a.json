{"ver":"0.1","info":{"id":"sttGDj","date":"1636763029","viewed":108,"name":"xorshift Random Number Generator","username":"ejosiah","description":"A fast and popular shader-based random number generator based on xorshift","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["randomnumberpathtracingraytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uint rngState = initRNG(fragCoord, iResolution.xy, uint(iFrame));\n    float v = rand(rngState);\n    \n    // Time varying pixel color\n\n    // Output to screen\n    fragColor = vec4(vec3(v),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Random Number Generator sourced from Ray Tracing Gems II\n// chapter 14 - The Reference Path Tracer\n// section 14.3.4 - Random Number Generation\n\n#define USE_PCG 0\n\n#if USE_PCG\n\t#define RngStateType uvec4\n#else\n\t#define RngStateType uint\n#endif\n\nuvec4 pcg4d(uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n\n\tv.x += v.y * v.w; \n\tv.y += v.z * v.x; \n\tv.z += v.x * v.y; \n\tv.w += v.y * v.z;\n\n\tv = v ^ (v >> 16u);\n\n\tv.x += v.y * v.w; \n\tv.y += v.z * v.x; \n\tv.z += v.x * v.y; \n\tv.w += v.y * v.z;\n\n\treturn v;\n}\n\nuint xorshift(inout uint rngState)\n{\n\trngState ^= rngState << 13;\n\trngState ^= rngState >> 17;\n\trngState ^= rngState << 5;\n\treturn rngState;\n}\n\n// Jenkins's \"one at a time\" hash function\nuint jenkinsHash(uint x) {\n\tx += x << 10;\n\tx ^= x >> 6;\n\tx += x << 3;\n\tx ^= x >> 11;\n\tx += x << 15;\n\treturn x;\n}\n\n// Converts unsigned integer into float int range <0; 1) by using 23 most significant bits for mantissa\nfloat uintToFloat(uint x) {\n\treturn uintBitsToFloat(0x3f800000u | (x >> 9)) - 1.0f;\n}\n\n#if USE_PCG\n\nRngStateType initRNG(vec2 pixelCoords, vec2 resolution, uint frameNumber) {\n\treturn RngStateType(uvec2(pixelCoords), frameNumber, 0); //< Seed for PCG uses a sequential sample number in 4th channel, which increments on every RNG call and starts from 0\n}\n\nfloat rand(inout RngStateType rngState) {\n\trngState.w++; //< Increment sample index\n\treturn uintToFloat(pcg4d(rngState).x);\n}\n\n# else\n\nRngStateType initRNG(vec2 pixelCoords, vec2 resolution, uint frameNumber) {\n\tRngStateType seed = uint(dot(pixelCoords, vec2(1, resolution.x))) ^ jenkinsHash(frameNumber);\n\treturn jenkinsHash(seed);\n}\n\n// Return random float in <0; 1) range (Xorshift-based version)\nfloat rand(inout RngStateType rngState) {\n\treturn uintToFloat(xorshift(rngState));\n}\n\n#endif\n","name":"Common","description":"","type":"common"}]}