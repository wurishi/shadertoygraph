{"ver":"0.1","info":{"id":"MsByW1","date":"1491898882","viewed":475,"name":"Hequalizer","username":"liamboone","description":"Hexagon based audio visualizer","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","audio","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159;\nconst float cos60 = cos(PI / 3.);\nconst float sin60 = sin(PI / 3.);\nconst float root3 = sqrt(3.);\nconst float root3_3 = sqrt(3.) / 3.;\n\n\n// Hexagon coordinate funcs from http://www.redblobgames.com/grids/hexagons/\nvec2 cube_to_hex(vec3 h)\n{\n    return h.xz;\n}\n\nvec3 hex_to_cube(vec2 h)\n{\n    return vec3(h.x, -h.x - h.y, h.y);\n}\n\nvec3 cube_round(vec3 h)\n{\n    float rx = round(h.x);\n    float ry = round(h.y);\n    float rz = round(h.z);\n\n    float x_diff = abs(rx - h.x);\n    float y_diff = abs(ry - h.y);\n    float z_diff = abs(rz - h.z);\n\n    if (x_diff > y_diff && x_diff > z_diff)\n    {\n        rx = -ry-rz;\n    }\n    else if (y_diff > z_diff)\n    {\n        ry = -rx-rz;\n    }\n    else\n    {\n        rz = -rx-ry;\n    }\n\n    return vec3(rx, ry, rz);\n}\n\nvec2 hex_round(vec2 h)\n{\n    return cube_to_hex(cube_round(hex_to_cube(h)));\n}\n\nfloat hex_distance(vec2 a, vec2 b)\n{\n    return (abs(a.x - b.x) \n          + abs(a.x + a.y - b.x - b.y)\n          + abs(a.y - b.y)) / 2.;\n}\n\n\n// Hexagon SDF from IQ: https://iquilezles.org/articles/distfunctions\nfloat hexagon( vec2 p, float h )\n{\n    vec2 q = abs(p);\n    return max((q.y*0.866025+q.x*0.5),q.x)-h;\n}\n\nfloat scene(vec2 p)\n{\n    float width = 60.;\n    \n    mat2 T = mat2(root3_3, 0., -1./3., 2./3.);\n    mat2 invT = mat2(root3, 0., root3 * 0.5, 3./2.);\n    \n    vec2 h = hex_round(T * p / width);\n    \n    vec2 center = width * invT * h;\n    \n    float d_hex = (hex_distance(h, vec2(0.))) / (iResolution.x / (2. * width));\n    float d_true = length(p) / (iResolution.x / (2.));\n\tfloat fft_hex  = texture(iChannel0, vec2(d_hex, 0.25)).x;\n\tfloat fft_true  = texture(iChannel0, vec2(d_true, 0.25)).x;\n    \n    return clamp(1. - float(hexagon(p - center, ((fft_hex + fft_true*0.3) * (width + 2.) - 1.) * sin60)), 0., 1.);\n}\n\n\n// Palette code from IQ: https://iquilezles.org/articles/palettes\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - (iResolution.xy * 0.5));\n    \n    mat2 R = mat2(cos60, sin60, -sin60, cos60);\n    \n\tfloat r = (length(uv) / iResolution.x) + 0.15;\n\n\tfloat fft  = texture( iChannel0, vec2(0,0.25) ).x;\n    \n    vec2 radius = vec2(pow(fft, 6.) * 8., 0.);\n    \n    vec2 off0 = radius;\n    vec2 off1 = off0 * R * R;\n    vec2 off2 = off1 * R * R;\n    \n    vec3 color = vec3(scene(uv + off0),\n                      scene(uv + off1), \n                      scene(uv + off2));\n    \n    vec3 vignette = palette(0.75 + r, vec3(0.5), vec3(0.5), vec3(1.), vec3(0.0, 0.1, 0.2)) + 0.1;\n    \n\tfragColor = vec4(pow(color * vignette, vec3(0.5)), 1.);\n}","name":"Image","description":"","type":"image"}]}