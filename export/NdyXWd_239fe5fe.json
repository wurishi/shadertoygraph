{"ver":"0.1","info":{"id":"NdyXWd","date":"1635470429","viewed":179,"name":"jneen - 3d sprixels again","username":"jneen","description":"using sprites as pixels to render a 3d scene","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sprixel","jneen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define I (1.)\n#define O (0.)\n#define time (iTime*.5)\n\nvec2 uv;\n\nfloat[16] T1 = float[16](\n  I,O,O,O,\n  O,O,O,O,\n  O,O,I,O,\n  O,O,O,O\n);\n\nfloat[16] T2 = float[16](\n  O,O,I,O,\n  O,I,O,O,\n  I,O,O,O,\n  O,I,O,O\n);\n\nfloat[16] T3 = float[16](\n  O,I,I,O,\n  I,O,I,I,\n  O,I,O,I,\n  O,O,I,O\n);\n\nfloat[16] T4 = float[16](\n  I,I,I,I,\n  I,O,I,I,\n  I,I,I,I,\n  I,I,O,I\n);\n\nfloat px(float[16] arr, vec2 p) {\n  p = fract(p);//mod(p, 1.);\n  int x = int(p.x*4.);\n  int y = int((1.-p.y)*4.);\n  return arr[4*y+x];\n}\n\nmat2 rot(float x) { float s=sin(x),c=cos(x); return mat2(c,s,-s,c); }\n\n\n#define nsin(x) (.5+.5*sin(x))\n#define pmod(x,j) (mod(x,j)-.5*(j))\n\n#define MISS(x) (x>1000.)\n\n\nfloat sphere(vec3 p, float r) { return length(p)-r; }\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q, 0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat boxle(vec3 p, float r, float q) {\n  return max(box(p, vec3(r)),-sphere(p,q*r));\n}\n\nfloat S(vec3 p) {\n  //p+=vec3(.2,.2,2);\n  float rad = fract(time);\n  float S = 1001.;\n  \n  float ft=1.;\n  \n  for (float i=0.;i<=2.;i+=1.){\n    float r=rad+i;\n    p.xz *= rot(r*.35);\n    p.xy *= rot(r*.1);\n    p.xy *= rot(r*.05);\n\n    S = min(S, boxle(p, r, 1.+.07*r*r*r));\n  }\n \n\n\n  return S;\n}\n\nfloat ray(vec3 p, vec3 dir) {\n  float d=0.;\n  for(int i=0;i<50;i++){\n    float c=S(p+d*dir);\n    d+=c;\n    if (c<.1) return d;\n    if (MISS(d)) return d;\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(1e-3);\n  return normalize(S(p)-vec3(S(k[0]), S(k[1]),S(k[2])));\n}\n\nfloat light(vec3 o, vec3 dir, float dist) {\n  vec3 hit = o+dir*dist;\n  vec3 n = normal(hit);\n  \n  float diff = dot(dir,-n);\n  \n  return diff;\n}\nvec3 HUE = vec3(0);\n\n\nfloat pxsel(float x, vec2 p) {\n  x *= 3.5;\n  x-=.1;\n  \n  if (x<1.) { HUE=vec3(0, p); return px(T1,p); }\n  if (x<2.) { HUE=vec3(p,0); return px(T2,p); }\n  if (x<3.) { HUE=vec3(p.y,0,p.x);return px(T3,p); }\n  return px(T4,p);\n}\n\n#define tri(x) (2.*abs(.5-fract(x)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 C;\n    \n    float RES=mix(4., 64., tri(.1*time+.3));\n    \n    \n    vec2 px_aln = uv;\n    px_aln *= RES;\n    px_aln = floor(px_aln);\n    px_aln /= RES;\n    \n    vec3 o = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(px_aln,1));\n    \n    float dist = ray(o,dir);\n    float l = light(o,dir,dist);\n\n    if (MISS(dist)) {\n      C=pxsel(.5, uv*RES)+HUE*.02;\n      C*=.5;\n    }\n    else {\n      float pix = pxsel(light(o,dir,dist),RES*(uv-px_aln));\n      C = vec3(rot(time)*uv+1.,0)*pix;\n    }\n    \n    C = C.zxy;\n    \n    // Output to screen\n    fragColor = vec4(sqrt(C),1.0);\n}","name":"Image","description":"","type":"image"}]}