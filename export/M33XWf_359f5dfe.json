{"ver":"0.1","info":{"id":"M33XWf","date":"1719673583","viewed":46,"name":"Wrong voxel dda","username":"Teluri","description":"\nrecreated previous iteration of https://www.shadertoy.com/view/MXdSRB\n(before it was cool)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voxel","dda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\nconst int RENDER_DISTANCE = 64*8;\nconst float offset=1.4;\n\nmat3 getXRotMat(float angle){\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat3( 1, 0, 0,\n                 0, c, s,\n                 0,-s, c);\n}\n\nmat3 getYRotMat(float angle){\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat3( c, 0,-s,\n                 0, 1, 0,\n                 s, 0, c);\n}\n\nmat3 getZRotMat(float angle){\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat3( c, s, 0,\n                -s, c, 0,\n                 0, 0, 1);\n}\n\nbool getVoxel(ivec3 pos){\n    //mock data\n    bool e=abs((pos.x-7)%100)<10 && abs(pos.y+54)<10;\n    bool ee=(abs(pos.x)>10 || abs(pos.y)>10)&& pos.z<-1;\n    bool eee=pos.x+pos.y+pos.z==50;\n    return pos.z<-3||e||ee||eee;\n}\n\n// z is upward\n// x is the view horizontal rotation axis\n// y is the vertical cam rotation axis and view rotation axis\n// z is the horizontal cam rotation axis\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalizing screen size to -0.5 to 0.5 being the biggest centered square that fit on screen\n    float screenRatio=min(iResolution.x,iResolution.y);\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    //input\n    vec3 camRot= vec3(0.,clamp(-iMouse.y/screenRatio,-1.,1.),2.*-iMouse.x/iResolution.x)*PI;\n    vec3 camPos= vec3(sin(iTime*0.2)*10.-15.,cos(iTime*0.2)*10.-15.,3.);\n    \n    vec3 cameraPlaneU = vec3(0, -offset, 0);\n\tvec3 cameraPlaneV = vec3(offset, 0, 0) * iResolution.y / iResolution.x;\n    vec3 ray= vec3(0,0,1);\n\tray = ray + uv.x * cameraPlaneU + uv.y * cameraPlaneV;\n    \n    ray= getXRotMat(camRot.x)*ray;\n    ray= getYRotMat(camRot.y)*ray;\n    ray= getZRotMat(camRot.z)*ray;\n    \n    \n    \n    vec3 raySign= sign(ray);\n    ivec3 iRaySign = ivec3(raySign);\n\n    /////// doing the voxel traversal from here /////////\n    \n    \n    ray = abs(ray);                             // abstracting sign away for simplicity                       \n    \n    ray = ray/max(max(ray.x,ray.y),ray.z);\n    \n    \n    bvec3 move;\n    bool  hit= false;\n    \n    vec3 itr = fract(camPos*raySign+0.5)-1.;         \n                                                \n    ivec3 pos= ivec3(round(camPos));            // pos start on camera position\n    for(int step = 0; step < RENDER_DISTANCE; step++){\n        itr+=ray*float(all(lessThan(itr,vec3(0)))); \n        \n        bvec3 pon=greaterThan(itr.xyz,itr.yzx);    \n        move.x=pon.x&& !pon.z;                  \n        move.y=pon.y&& !pon.x;\n        move.z=!(move.x||move.y);               \n        \n        itr-=vec3(move);                 \n        pos+=ivec3(move)*iRaySign;              \n        \n        hit=getVoxel(pos);\n        if(hit){                                // stop if opaque\n           break;\n        }\n    }\n    vec3 col=vec3(0);\n    if(hit){\n        col=1.0-fract(vec3(pos)*0.05);          // applying cube test color\n        \n        vec3 facevec= vec3(move);               // adding face normal vector\n        col= col-facevec*0.05;\n    }\n    \n    // output to screen\n    fragColor = vec4(col, 1.);\n    \n}","name":"Image","description":"","type":"image"}]}