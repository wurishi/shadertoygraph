{"ver":"0.1","info":{"id":"WsGGRD","date":"1569774965","viewed":166,"name":"perlin noises","username":"remotion","description":"perlin noise ported from c++ to glsl\nhttps://github.com/nothings/stb/blob/master/stb_perlin.h","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","c"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\n// based on \n// https://github.com/nothings/stb/blob/master/stb_perlin.h\n\n\n//-----------------------------------------------------------------------------\nint _perlin_fastfloor(float a) {\n    return int(floor(a)); // nearest integer less than or equal to x\n}\n\n#define uchar int //TODO: find a bettrer way\n\n//-----------------------------------------------------------------------------\n// different grad function from Perlin's, but easy to modify to match reference\nfloat _perlin_grad(int hash, float x, float y, float z) {\n   const vec3 basis[12] = vec3[12](\n      vec3(  1, 1, 0 ),\n      vec3( -1, 1, 0 ),\n      vec3(  1,-1, 0 ),\n      vec3( -1,-1, 0 ),\n      vec3(  1, 0, 1 ),\n      vec3( -1, 0, 1 ),\n      vec3(  1, 0,-1 ),\n      vec3( -1, 0,-1 ),\n      vec3(  0, 1, 1 ),\n      vec3(  0,-1, 1 ),\n      vec3(  0, 1,-1 ),\n      vec3(  0,-1,-1 )\n   );\n\n   // perlin's gradient has 12 cases so some get used 1/16th of the time\n   // and some 2/16ths. We reduce bias by changing those fractions\n   // to 5/64ths and 6/64ths, and the same 4 cases get the extra weight.\n   const uchar indices[64] = uchar[64](\n      0,1,2,3,4,5,6,7,8,9,10,11,\n      0,9,1,11,\n      0,1,2,3,4,5,6,7,8,9,10,11,\n      0,1,2,3,4,5,6,7,8,9,10,11,\n      0,1,2,3,4,5,6,7,8,9,10,11,\n      0,1,2,3,4,5,6,7,8,9,10,11\n   );\n\n   // if you use reference permutation table, change 63 below to 15 to match reference\n   // (this is why the ordering of the table above is funky)\n   vec3 grad = basis[indices[hash & 63]];\n   return grad[0]*x + grad[1]*y + grad[2]*z;\n}\n\n//-----------------------------------------------------------------------------\nfloat _perlin_noise3(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap)\n{\n    // not same permutation table as Perlin's reference to avoid copyright issues;\n    // Perlin's table can be found at http://mrl.nyu.edu/~perlin/noise/\n    // @OPTIMIZE: should this be unsigned char instead of int for cache?\n    const uchar _perlin_randtab[512] = uchar[512](\n    23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123,\n    152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72,\n    175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240,\n    8, 50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57,\n    225, 160, 58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233,\n    94, 200, 88, 9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172,\n    165, 218, 55, 222, 46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243,\n    65, 79, 166, 248, 25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122,\n    26, 212, 105, 43, 179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76,\n    250, 47, 24, 251, 140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246,\n    132, 48, 119, 144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3,\n    91, 241, 149, 85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231,\n    38, 71, 185, 174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221,\n    131, 11, 163, 99, 234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62,\n    27, 255, 0, 194, 59, 116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135,\n    61, 40, 167, 237, 102, 223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5,\n\n    // and a second copy so we don't need an extra mask or static initializer\n    23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123,\n    152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72,\n    175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240,\n    8, 50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57,\n    225, 160, 58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233,\n    94, 200, 88, 9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172,\n    165, 218, 55, 222, 46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243,\n    65, 79, 166, 248, 25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122,\n    26, 212, 105, 43, 179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76,\n    250, 47, 24, 251, 140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246,\n    132, 48, 119, 144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3,\n    91, 241, 149, 85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231,\n    38, 71, 185, 174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221,\n    131, 11, 163, 99, 234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62,\n    27, 255, 0, 194, 59, 116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135,\n    61, 40, 167, 237, 102, 223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5\n    );\n\n   float u,v,w;\n   float n000,n001,n010,n011,n100,n101,n110,n111;\n   float n00,n01,n10,n11;\n   float n0,n1;\n\n   int x_mask = (x_wrap-1) & 255;\n   int y_mask = (y_wrap-1) & 255;\n   int z_mask = (z_wrap-1) & 255;\n   int px = _perlin_fastfloor(x);\n   int py = _perlin_fastfloor(y);\n   int pz = _perlin_fastfloor(z);\n   int x0 = px & x_mask, x1 = (px+1) & x_mask;\n   int y0 = py & y_mask, y1 = (py+1) & y_mask;\n   int z0 = pz & z_mask, z1 = (pz+1) & z_mask;\n   int r0,r1, r00,r01,r10,r11;\n\n   // Quintic interpolation curve  y = x*x*x*(x*(x*6.-15.)+10.);\n   #define _perlin_ease(a)   (((a*6.0-15.0)*a + 10.0) * a * a * a)\n\n   x -= float(px); u = _perlin_ease(x);\n   y -= float(py); v = _perlin_ease(y);\n   z -= float(pz); w = _perlin_ease(z);\n\n   r0 = _perlin_randtab[x0];\n   r1 = _perlin_randtab[x1];\n\n   r00 = _perlin_randtab[r0+y0];\n   r01 = _perlin_randtab[r0+y1];\n   r10 = _perlin_randtab[r1+y0];\n   r11 = _perlin_randtab[r1+y1];\n\n   n000 = _perlin_grad(_perlin_randtab[r00+z0], x  , y  , z   );\n   n001 = _perlin_grad(_perlin_randtab[r00+z1], x  , y  , z-1.0 );\n   n010 = _perlin_grad(_perlin_randtab[r01+z0], x  , y-1.0, z   );\n   n011 = _perlin_grad(_perlin_randtab[r01+z1], x  , y-1.0, z-1.0 );\n   n100 = _perlin_grad(_perlin_randtab[r10+z0], x-1.0, y  , z   );\n   n101 = _perlin_grad(_perlin_randtab[r10+z1], x-1.0, y  , z-1.0 );\n   n110 = _perlin_grad(_perlin_randtab[r11+z0], x-1.0, y-1.0, z   );\n   n111 = _perlin_grad(_perlin_randtab[r11+z1], x-1.0, y-1.0, z-1.0 );\n\n   n00 = mix(n000,n001,w);\n   n01 = mix(n010,n011,w);\n   n10 = mix(n100,n101,w);\n   n11 = mix(n110,n111,w);\n\n   n0 = mix(n00,n01,v);\n   n1 = mix(n10,n11,v);\n\n   return mix(n0,n1,u);\n}\n\n#undef uchar\n//-----------------------------------------------------------------------------\nfloat _perlin_ridge_noise3(float x, float y, float z,float lacunarity, float gain, float offset, int octaves,int x_wrap, int y_wrap, int z_wrap)\n{\n   int i;\n   float frequency = 1.0f;\n   float prev = 1.0f;\n   float amplitude = 0.5f;\n   float sum = 0.0f;\n\n   for (i = 0; i < octaves; i++) {\n      float r = float(_perlin_noise3(x*frequency,y*frequency,z*frequency,x_wrap,y_wrap,z_wrap));\n      r = r<0.0 ? -r : r; // fabs()\n      r = offset - r;\n      r = r*r;\n      sum += r*amplitude*prev;\n      prev = r;\n      frequency *= lacunarity;\n      amplitude *= gain;\n   }\n   return sum;\n}\n//-----------------------------------------------------------------------------\nfloat _perlin_fbm_noise3(float x, float y, float z,float lacunarity, float gain, int octaves,int x_wrap, int y_wrap, int z_wrap)\n{\n   int i;\n   float frequency = 1.0f;\n   float amplitude = 1.0f;\n   float sum = 0.0f;\n\n   for (i = 0; i < octaves; i++) {\n      sum += _perlin_noise3(x*frequency,y*frequency,z*frequency,x_wrap,y_wrap,z_wrap)*amplitude;\n      frequency *= lacunarity;\n      amplitude *= gain;\n   }\n   return sum;\n}\n//-----------------------------------------------------------------------------\nfloat _perlin_turbulence_noise3(float x, float y, float z, float lacunarity, float gain, int octaves,int x_wrap, int y_wrap, int z_wrap)\n{\n   int i;\n   float frequency = 1.0f;\n   float amplitude = 1.0f;\n   float sum = 0.0f;\n\n   for (i = 0; i < octaves; i++) {\n      float r = _perlin_noise3(x*frequency,y*frequency,z*frequency,x_wrap,y_wrap,z_wrap)*amplitude;\n      r = r<0.0 ? -r : r; // fabs()\n      sum += r;\n      frequency *= lacunarity;\n      amplitude *= gain;\n   }\n   return sum;\n}\n\n//-----------------------------------------------------------------------------\n// This function computes a random value at the coordinate (x,y,z).\n// Adjacent random values are continuous but the noise fluctuates\n// its randomness with period 1, i.e. takes on wholly unrelated values\n// at integer points. Specifically, this implements Ken Perlin's\n// revised noise function from 2002.\n// The \"wrap\" parameters can be used to create wraparound noise that\n// wraps at powers of two. The numbers MUST be powers of two. Specify\n// 0 to mean \"don't care\". (The noise always wraps every 256 due\n// details of the implementation, even if you ask for larger or no\n// wrapping.)\nfloat perlin_noise(const in vec3 p,const in ivec3 wrap) {\n  return _perlin_noise3(p.x, p.y, p.z, wrap.x, wrap.y, wrap.z);\n}\n\n//-----------------------------------------------------------------------------\n// Fractal Noise:\n//\n// Three common fractal noise functions are included, which produce \n// a wide variety of nice effects depending on the parameters \n// provided. Note that each function will call perlin_noise3 \n// 'octaves' times, so this parameter will affect runtime.\n\n// Typical values to start playing with:\n//     octaves    =   6     -- number of \"octaves\" of noise3() to sum\n//     lacunarity = ~ 2.0   -- spacing between successive octaves (use exactly 2.0 for wrapping output)\n//     gain       =   0.5   -- relative weighting applied to each successive octave\n//     offset     =   1.0?  -- used to invert the ridges, may need to be larger, not sure\n\n//-----------------------------------------------------------------------------\nfloat perlin_ridge(const in vec3 p, float lacunarity, float gain,\n    int octaves, float offset, const in ivec3 wrap) {\n  return _perlin_ridge_noise3(\n      p.x, p.y, p.z, lacunarity, gain, offset, octaves, wrap.x, wrap.y, wrap.z);\n}\n\n//-----------------------------------------------------------------------------\nfloat perlin_fbm(const in vec3 p, float lacunarity, float gain,\n    int octaves, const in ivec3 wrap) {\n  return _perlin_fbm_noise3(\n      p.x, p.y, p.z, lacunarity, gain, octaves, wrap.x, wrap.y, wrap.z);\n}\n\n//-----------------------------------------------------------------------------\nfloat perlin_turbulence(const in vec3 p, float lacunarity, float gain,\n    int octaves, const in ivec3 wrap) {\n  return _perlin_turbulence_noise3(\n      p.x, p.y, p.z, lacunarity, gain, octaves, wrap.x, wrap.y, wrap.z);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   \tvec3 col = vec3(0.0);\n\n    const float lacunarity = 2.0;\n    const float gain = 0.7;\n    const int octaves = 5;\n    const float offset = 0.8;\n\n    const ivec3 wrap = ivec3(0);\n\tconst vec3 scale = vec3(5.0,3.0,3.0);\n\n\tfloat time = iTime*0.25 + 1.0;\n    \n    float f = 0.0;\n    f = perlin_turbulence(vec3(uv*scale.xy,time*0.7)     , lacunarity,gain,octaves,wrap);\n    f = perlin_turbulence(vec3(uv*scale.xy,time*0.5) + f, lacunarity,gain,octaves,wrap);\n    // f = perlin_turbulence(vec3(uv*scale.xy,time*0.3) + f, lacunarity,gain,octaves,wrap);\n    f  = perlin_turbulence(vec3(uv*scale.xy,time*1.0) + f, lacunarity,gain,octaves,wrap);\n    \n    // col = vec3(0.2,0.07,0.01) / (f*f); /// red\n    // col = vec3(0.0,0.24,0.03) / (f*f); /// green\n    col = vec3(0.1, 1.1*f, pow(f, 0.5-f)); /// blue\n\n    \n    fragColor = vec4(col,1.0); // Output to screen\n}","name":"Image","description":"","type":"image"}]}