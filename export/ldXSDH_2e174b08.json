{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Mon shader\n\nstruct sphere_t{\n\tvec3 position;\n\tfloat radius;\n\tvec3 normal;\n\tvec3 color;\n\tfloat ka;\n};\n\t\nstruct surface_t{\n\tvec3 position;\n\tfloat identify;\n\tvec3 normal;\n\tvec2 uv;\n\tvec3 color;\n\tvec3 collisionpoint;\n};\n\t\nstruct ray_t{\n\tvec3 origin;\n\tvec3 direction;\n\t\n};\n\t\nstruct light_t{\n\tvec3 direction;\n\tfloat intensity;\n\tvec3 position;\n};\t\n\t\nstruct plane_t{\n\tfloat a, b, c, d;\n\tvec3 color;\n\tfloat ka;\n};\n\nvec3 mult(float t, vec3 v){\n\treturn vec3(v.x*t, v.y*t, v.z*t);\n}\n\nfloat magnitude(vec3 v){\n\treturn sqrt(v.x*v.x + v.y*v.y + v.z*v.z);\n}\n\t\nfloat fAttenuation(float d){\n\tfloat attenuation = 1./(0.1 + 5e-5*d + 7e-5*d*d);\n\treturn min(attenuation, 1.);\n}\n\nvec3 reflectedVec(vec3 normal, vec3 ray){\n\treturn normalize(mult(2.* dot(normal, -ray), normal) + ray);\n}\n\nfloat intersectSphere( in ray_t ray, inout sphere_t sphere){\n\tfloat c=pow(ray.origin.x-sphere.position.x,2.0)+pow(ray.origin.y-sphere.position.y,2.0)+pow(ray.origin.z-sphere.position.z,2.0)-pow(sphere.radius,2.0);\n\tfloat b=2.0*(ray.direction.x * (ray.origin.x-sphere.position.x) + ray.direction.y * (ray.origin.y-sphere.position.y) + ray.direction.z*(ray.origin.z-sphere.position.z));\n\tfloat a = pow(ray.direction.x,2.0) + pow(ray.direction.y,2.0) + pow(ray.direction.z,2.0);\n\tfloat delta = pow(b,2.0) -4.0 * a * c;\n\t\n\tfloat t =min((-b-sqrt(delta))/(2.0*a), (-b+sqrt(delta))/(2.0*a));\n\tif(delta>=0.0){\n\t\tsphere.normal= vec3( ray.origin.x + t * ray.direction.x - sphere.position.x, ray.origin.y + t* ray.direction.y - sphere.position.y, ray.origin.z + t* ray.direction.z - sphere.position.z)  ;\n\t\treturn t;\n\t}\n\telse{\n\t\t sphere.normal=vec3(0.0, 0.0, 0.0);\n\t\t return 1e5;\n\t}\n}\n\nvec3 collisionPoint(ray_t ray, float t){\n\treturn vec3(ray.origin.x + ray.direction.x*t, ray.origin.y + ray.direction.y*t, ray.origin.z + ray.direction.z*t);\n}\n\nfloat intersectPlane(const in ray_t ray, const in plane_t plane){\n\tfloat numerateur= -(ray.origin.x * plane.a + ray.origin.y * plane.b + ray.origin.z * plane.c + plane.d);\n\tfloat denominateur= plane.a * ray.direction.x + plane.b * ray.direction.y + plane.c * ray.direction.z;\n\tfloat t= numerateur/denominateur;\n\tif(t<0.0)\n\t\treturn 1e5;\n\telse \n\t\treturn t;\n}\n\nvec3 illumination(light_t directional_light, ray_t ray, in surface_t surface, in light_t light, sphere_t sphere, plane_t plane, vec3 color, int type){\n\tvec3  firstColor, L, R, L_directional;\n\tL= light.position - surface.collisionpoint;\n\tfloat attenuation=fAttenuation(magnitude(L));\n\tL = normalize(L);\n\tR = reflectedVec(surface.normal, ray.direction);\n\tfloat kAttenuationCubeMap = pow(1.0-dot(surface.normal, -ray.direction),2.);\n\tvec3 diffuse;\n\tfloat speculaire;\n\t\n\tvec3 cubemapColor = texture(iChannel2,R).xyz;\n\t\n\tray_t lumRay, transRay, refRay;\n\tlumRay.direction = L;\n\tlumRay.origin = surface.collisionpoint;\n\t\n\t\n\t\n\tL_directional= normalize(directional_light.position - surface.collisionpoint);\n\tfloat sourceDirectionnal = pow(dot(-L_directional, normalize(directional_light.direction)), 6.);\n\tvec3 ambiante;\n\tfloat intensiteAmbiante = 1.5;\n\t\n\tif(type==0){\n\t\t\n\t\tcolor = texture( iChannel1, surface.uv ).xyz;\n\t\t\n\t\tambiante.x = color.x * plane.ka * intensiteAmbiante;\n\t\tambiante.y = color.y * plane.ka * intensiteAmbiante;\n\t\tambiante.z = color.z * plane.ka * intensiteAmbiante;\n\t\t\n\t\tif(intersectSphere(lumRay, sphere)==1e5){\n\t\t\tdiffuse.x = color.x*dot(surface.normal, L);\n\t\t\tdiffuse.y = color.y*dot(surface.normal, L);\n\t\t\tdiffuse.z = color.z*dot(surface.normal, L);\n\t\t\t\n\t\t\tspeculaire =  pow(dot(L, R), 10.)*0.4;\n\n\t\t}\t\t\n\t}\n\tif(type==1){\n\t\t\n\t\tcolor = texture( iChannel0, surface.uv ).xyz;\n\t\tambiante.x = color.x * plane.ka * intensiteAmbiante;\n\t\tambiante.y = color.y * plane.ka * intensiteAmbiante;\n\t\tambiante.z = color.z * plane.ka * intensiteAmbiante;\n\t\t\n\t\tif(intersectPlane(lumRay, plane)==1e5){\n\t\t\tdiffuse.x = color.x*dot(surface.normal, L);\n\t\t\tdiffuse.y = color.y*dot(surface.normal, L);\n\t\t\tdiffuse.z = color.z*dot(surface.normal, L);\n\t\t\t\n\t\t\tspeculaire =  pow(dot(L, R), 10.)*0.4;\n\t\t\t\n\t\t}\n\t}\n\t\n\tfirstColor.x = kAttenuationCubeMap*cubemapColor.x * ambiante.x + attenuation * light.intensity* sourceDirectionnal * (diffuse.x + speculaire);\n\tfirstColor.y = kAttenuationCubeMap*cubemapColor.y * ambiante.y + attenuation * light.intensity* sourceDirectionnal * (diffuse.y + speculaire);\n\tfirstColor.z = kAttenuationCubeMap*cubemapColor.z * ambiante.z + attenuation * light.intensity* sourceDirectionnal * (diffuse.z + speculaire);\n\n\treturn firstColor;\n}\n\n\nvec2 setUV(vec3 p, float radius){\n\tvec2 uv;\n\tfloat x,y,z;\n\tx = p.z;\n\ty = p.x;\n\tz = p.y;\n\tradius = sqrt(x*x + y*y +z*z);\n\tuv.y = acos(z/radius)/3.14;\n\t\n\tif(y>=0.)\n\t\tuv.x = acos(x/sqrt(x * x + y * y))/(2.*3.14);\n\telse\n\t\tuv.x = (2.*3.14 - acos(x/sqrt(x * x + y * y)))/(2.*3.14);\n\t\n\treturn uv;\n}\n\nvec3 sendRay(inout surface_t surface, ray_t ray, inout sphere_t sphere, plane_t plane, light_t light, light_t directional_light, vec2 fragCoord){\n\tfloat max_distance =100.;\n\t\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 normal;\n\t\n\tfloat distance_from_origin_plane= intersectPlane(ray, plane);\n\tfloat distance_from_origin_sphere = intersectSphere(ray, sphere);\n\n\tif( distance_from_origin_sphere < distance_from_origin_plane )\n\t{\n\t\t\tsurface.identify=1.0;\n\t\t\tsurface.collisionpoint = collisionPoint(ray, distance_from_origin_sphere);\n\t\t\tsurface.normal=normalize(surface.collisionpoint - sphere.position);\n\t\t\tsurface.uv = setUV(surface.collisionpoint , sphere.radius);\n\t\t\t\n\t\t\tvec3 sphere_color = illumination(directional_light, ray, surface,light, sphere, plane, sphere.color, 1);\n\t\t\treturn sphere_color;\n\t\t\t\n\t}\n\telse if( distance_from_origin_plane < max_distance )\n\t{\n\t\t\tsurface.identify=0.0;\t\t\t\n\t\t\tnormal=vec3(plane.a, plane.b, plane.c);\t\t\t\n\t\t\tsurface.normal=normalize(normal);\n\t\t\tsurface.collisionpoint = collisionPoint(ray, distance_from_origin_plane);\n\t\t\tsurface.uv.x = surface.collisionpoint.x;\n\t\t\tsurface.uv.y = -surface.collisionpoint.z;\n\t\t\t\n\t\t\tvec3 plane_color = illumination(directional_light, ray, surface,light, sphere, plane, plane.color, 0);\n\t\t\tsurface.color = plane.color;\n\t\t\treturn plane_color;\n\t}\n\telse\n\t{\n\t\tsurface.identify = -1.;\n\t\tvec3 L = reflectedVec(surface.normal, ray.direction);\n\t\treturn texture(iChannel2, L).xyz;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat max_distance=100.0;\n\tvec2 screen_coordonate = fragCoord.xy / iResolution.xy;\n\tvec2 screen_coordonate_centered = 2.0 * screen_coordonate -1.0;\n\tsurface_t surface;\n\t\t\n\tray_t primary_ray;\n\tprimary_ray.origin =vec3(0.0, 0.0, mix( 3.0, 5.0, 0.5 *sin(iTime)+0.5));\n\tprimary_ray.direction =normalize(vec3(screen_coordonate_centered.x, screen_coordonate_centered.y * iResolution.y/iResolution.x, -1));\n\t\n\tlight_t light;\n\tlight.intensity=2.;\n\tlight.position = vec3(0., 10., 0.);\n\t\n\tlight_t directional_light;\n\tdirectional_light.intensity=.9;\n\tdirectional_light.direction = vec3(0., -1., 0.);\n\tdirectional_light.position = vec3(0., 10., 0.);\n\t\n\tsphere_t sphere;\n\tsphere.position =vec3(0.0,2.0,-5.0);\n\tsphere.radius=2.0;\n\tsphere.color = vec3(0., 0.9, 0.);\n\tsphere.ka =0.6;\n\t\n\tplane_t plane;\n\tplane.a=0.0;\n\tplane.b=0.9;\n\tplane.c=0.04;\n\tplane.d=0.8;\n\tplane.color = vec3(0.9, 0., 0.);\n\tplane.ka = 0.5;\t\n\n\tfragColor = vec4(sendRay(surface, primary_ray, sphere, plane, light,  directional_light, fragCoord), 1);\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXSDH","date":"1400024686","viewed":161,"name":"exercice 2","username":"moustache","description":"plane + sphere 2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""}}