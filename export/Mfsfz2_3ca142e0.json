{"ver":"0.1","info":{"id":"Mfsfz2","date":"1724086005","viewed":15,"name":"Barycentric Interp Simplex Noise","username":"pprovins","description":"Simplex noise using barycentrics.\nBecause barycentrics are used, there is a discontinuity within the connected cells.\nLower the number of iterations to observe.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DIMS 3.\n#define IDIMS 3\n#define NUM_FREQS 8\n\nfloat hash( ivec3 p )    \n{   // this hash implementation stolen from iquillez, based on Hugo Elias'\n    // method0 of https://www.shadertoy.com/view/4sfGzS\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nconst float kF = (sqrt(DIMS + 1.) - 1.) / DIMS;\n\nvec3 skew(vec3 p)\n{\n    return p + dot(p, vec3(kF));\n}\n\n// Bubble sort\nivec3 sort_indices(vec3 p)\n{\n    ivec3 keys = ivec3(0, 1, 2);\n    \n    for (int ii = 0; ii < IDIMS - 1; ++ii)\n    {\n        for (int jj = 0; jj < IDIMS - ii - 1; ++jj)\n        {\n            int cur = keys[jj];\n            int next = keys[jj + 1];\n            \n            if (p[next] > p[cur])\n            {\n                keys[jj] = next;\n                keys[jj + 1] = cur;\n            }\n        }\n    }\n    \n    return keys;\n}\n\nvec3 simplex_noise(vec3 p)\n{\n    // Skew the position,\n    // Floor (for finding containing cell points)\n    // Determine where in the cell the current position\n    // is relative to the base coordinate\n    vec3 s_p = skew(p);\n    vec3 fs_p = floor(s_p);\n    vec3 inside = s_p - fs_p; \n    \n    // Sort to find neighbors\n    ivec3 sorted_idxs = sort_indices(inside);\n    \n    // Create surrounding cell from sorted neighbors\n    vec3 verts[IDIMS + 1];\n    verts[0] = vec3(0.0);   \n    \n    vec3 cur = verts[0];\n    for (int ii = 0; ii < IDIMS; ++ii)\n    {\n        cur[sorted_idxs[ii]] += 1.;\n        verts[ii + 1] = cur;\n    }\n    \n    // Construct barycentric weights\n    vec4 w;\n    \n    w[0] = 1. - inside[sorted_idxs[0]];\n    for (int ii = 1; ii < IDIMS; ++ii)\n    {\n        w[ii] = inside[sorted_idxs[ii - 1]] - inside[sorted_idxs[ii]];\n    }\n    w[IDIMS] = inside[sorted_idxs[IDIMS - 1]];\n    \n    // Create a value at each cell corner\n    float f0 = hash(ivec3(verts[0]) + ivec3(fs_p));\n    float f1 = hash(ivec3(verts[1]) + ivec3(fs_p));\n    float f2 = hash(ivec3(verts[2]) + ivec3(fs_p));\n    float f3 = hash(ivec3(verts[3]) + ivec3(fs_p));\n    \n    // Interpolate within the cell\n    float r = w.x * f0 + w.y * f1 + w.z * f2 + w.w * f3;\n    \n    return vec3(r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Accumulator\n    vec3 result = vec3(0.0);\n    \n    // Each level a higher frequency\n    for (int fi = 0; fi < NUM_FREQS; ++fi)\n    {\n        float f_fi = float(fi);\n        vec2 offset = vec2(f_fi * 20.);\n        vec3 tmp_p = vec3(vec2(uv * (f_fi + 1.) * 8.0 + offset), iTime * 0.75);\n        result += simplex_noise(tmp_p);\n    }\n    \n    result /= float(NUM_FREQS);\n    \n    // Output to screen\n    fragColor = vec4(result, 1.);\n}","name":"Image","description":"","type":"image"}]}