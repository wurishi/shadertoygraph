{"ver":"0.1","info":{"id":"cd2fD1","date":"1689764386","viewed":76,"name":"learning-triangle","username":"bazylevnik0","description":"https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float p = 3.14159265359;    // pi constant\n\nvec3 build(float x, float y, float r)\n{\n    float red   = 0.0; //circle   output\n    float green = 0.0; //vertices output\n    float blue  = 0.0; //lines    output\n    \n    //build first triangle\n    //draw circle\n    //if small difference between point and radius(near) \n    if(abs(length(vec2(x,y))-r)<0.001) red = 1.0;\n    //draw vertices\n    //if near to radius and to angle\n    if(abs(length(vec2(x,y))-r)<0.01) {\n        //a) to angle 90  - top\n        if(abs(atan(y,x)-p/2.0)<0.025)green = 1.0;\n        //b) to angle 210 - left\n        if(abs(-1.0*atan(y,x)-(5.0*p/6.0))<0.025)green = 1.0;\n        //c) to angle 330 - right\n        if(abs(-1.0*atan(y,x)-(1.0*p/6.0))<0.025)green = 1.0;\n    }\n    //draw lines\n    //kx+b, k =sqrt(3.0) for angle 60, -1* for change direction,with shift b=r\n    //and in circle: length of point less then radius\n    if((abs(y-sqrt(3.0)*x-r)<0.002)&&length(vec2(x,y))<r)blue=1.0;        //ca\n    if((abs(y-(-1.0)*sqrt(3.0)*x-r)<0.002)&&length(vec2(x,y))<r)blue=1.0; //ab\n    //y=x+b, parallel to axis x, with shift b=r/2. and in circle\n    if(abs(y+r/2.0)<0.001&&length(vec2(x,y))<r)blue=1.0;                  //bc\n    \n    //build others\n    for(float i = 0.0; i < 7.0; i+=1.0){\n        float t_x = x; //temporary in this iteration\n        float t_y = y; //temporary in this iteration\n        if(i==0.0){\n            r/=2.0;\n        }else if(i==1.0||mod(i,4.0)==0.0){\n            r/=2.0;\n            t_x=x+1.75*r;\n            t_y=y+1.0*r;\n            if(mod(i,4.0)==0.0){\n                t_x+=r*3.5;\n                t_y+=r*2.0;\n            }\n        }else if(i==2.0||mod(i,4.0+1.0)==0.0){\n            t_y=y-2.0*r;\n            if(mod(i,5.0)==0.0){\n                t_x+=r*3.5;\n                t_y+=r*2.0;\n            }\n        }else if(i==3.0||mod(i,4.0+2.0)==0.0){\n            t_x=x-1.75*r;\n            t_y=y+r;\n            if(mod(i,6.0)==0.0){\n                t_x+=r*3.5;\n                t_y+=r*2.0;\n            }\n        }\n        //draw circle\n        //if small difference between point and radius(near) \n        if(abs(length(vec2(t_x,t_y))-r)<0.001) red = 1.0;\n        //draw vertices\n        //if near to radius and to angle\n        if(abs(length(vec2(t_x,t_y))-r)<0.01) {\n            //a) to angle 90  - top\n            if(abs(-1.0*atan(t_y,t_x)-p/2.0)<0.025)green = 1.0;\n            //b) to angle 210 - left\n            if(abs(1.0*atan(t_y,t_x)-(5.0*p/6.0))<0.025)green = 1.0;\n            //c) to angle 330 - right\n            if(abs(1.0*atan(t_y,t_x)-(1.0*p/6.0))<0.025)green = 1.0;\n        }\n        //draw lines\n        //kx+b, k =sqrt(3.0) for angle 60, -1* for change direction,with shift b=r\n        //and in circle: length of point less then radius\n        if((abs(t_y-(-1.0)*sqrt(3.0)*t_x+r)<0.002)&&length(vec2(t_x,t_y))<r)blue=1.0;        //ca\n        if((abs(t_y-sqrt(3.0)*t_x+r)<0.002)&&length(vec2(t_x,t_y))<r)blue=1.0; //ab\n        //y=x+b, parallel to axis x, with shift b=r/2. and in circle\n        if(abs(t_y-r/2.0)<0.001&&length(vec2(t_x,t_y))<r)blue=1.0;                  //bc\n    }\n    \n    return vec3(red,green,blue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*2.0;\n    uv.x*=iResolution.x/iResolution.y; //normalize x\n    \n    float r = 0.45;\n    // Output to screen\n    fragColor = vec4(build(uv.x/2.0,uv.y/2.0,r),1.0);\n}","name":"Image","description":"","type":"image"}]}