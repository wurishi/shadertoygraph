{"ver":"0.1","info":{"id":"Nd3yRB","date":"1653587434","viewed":90,"name":"Esferas ray marching","username":"trellas","description":"Ejemplo de esferas \"fractales\" con raymarching. Se puede mover con wasd en un plano horizontal. Saltando con space. Si se activa modo volar con f se moverá también en el eje vertical. Se puede mover explicitamente en este con u y j si esta el modo volar. ","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["marchingspheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define r 0.4;\n#define N 3000.\n#define Eps 0.001\n#define rep 2.0\n\nvec3 mod1(vec3 p)\n{\n\n    p.x = mod(p.x,rep);\n\n    p.y = mod(p.y,rep);\n\n    p.z = mod(p.z,rep);\n\n    return p;\n}\n\nfloat sphere(vec3 p)\n{\n    return length(mod1(p)-rep/2.0)-r;\n}\n\n\nvec3 march(vec3 p, vec3 dir)\n{\n    float dist = 0.0;\n    for(int i=0; i<int(N); i++){\n        dist = sphere(p)-Eps;\n        if(dist<Eps){\n            return vec3(1.0,1.0,1.0)/log(float(i+1)+1.0);\n        }\n        p = p + dist*dir;\n    }\n    return vec3(0.0,0.0,0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n    vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 )*6.28318530718;\n\n    // cast a ray from the camera\n    \n    vec3 ray = normalize( vec3( (fragCoord.xy-iResolution.xy*.5)/iResolution.x, 1.0 ) );\n    \n    ray.zy = ray.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ray.yz;\n    ray.xz = ray.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ray.zx;\n\n    vec3 p = camPos.xyz;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.5;\n    // Càmera position\n    vec3 obs = camPos.xyz;//ec3(0.0,0.0,-5.0);\n    \n    vec3 rayL = vec3(uv-vec2(0.5,0.5),-2.0);\n    \n    // Direction\n    vec3 dir = normalize(rayL-obs);\n    \n    vec3 col = march(p,ray);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Hazel Quantock 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define INVERT_Y 1\n\nconst float accel = .01;\nconst float decay = .95; // how much velocity is preserved per frame (proportionally)\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\n\n\n// keys are javascript keycode\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n            vec4 camVel = textureLod( iChannel0, vec2(3.5,.5)/iResolution.xy, 0.0 );\n            \n            fragColor = camPos + camVel;\n\n            // fly\n            fragColor.w = ReadKeyToggle(Key_F);\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = textureLod( iChannel0, vec2(2.5,.5)/iResolution.xy, 0.0 );\n            vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 );\n\n            vec2 mouseRot = (iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( int(fragCoord.x) == 1 )\n            {\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n        else if ( int(fragCoord.x) == 3 )\n        {\n            vec4 camPos = texture( iChannel0, vec2(.5,.5)/iResolution.xy, -100.0 );\n            vec4 camVel = texture( iChannel0, vec2(3.5,.5)/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 )*6.28318530718;\n            \n            bool fly = (camPos.w > .0);\n            \n            vec3 forward = vec3(0,0,1)*accel;\n            vec3 up = vec3(0,1,0)*accel;\n            vec3 right = vec3(1,0,0)*accel;\n\n            if ( fly ) // allow flying\n            {\n                forward.zy = forward.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*forward.yz;\n                right.zy = right.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*right.yz;\n            }\n                \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            camVel.xyz += (ReadKey(Key_W)-ReadKey(Key_S)) * forward;\n            camVel.xyz += (ReadKey(Key_D)-ReadKey(Key_A)) * right;\n            camVel.xyz += (ReadKey(Key_U)-ReadKey(Key_J)) * up;\n            camVel *= decay; // exponential decay\n            \n            if ( !fly )\n            {\n            \tcamVel.y -= .01;\n            \n            \tif ( camPos.y <= .0 )\n            \t{\n                \tcamVel.y = (ReadKey(Key_Space) != .0) ? .3 : 0.0;\n            \t}\n            }\n            \n            fragColor = camVel;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}