{"ver":"0.1","info":{"id":"4f23zc","date":"1704483063","viewed":34,"name":"cosmos square","username":"nayk","description":"square, stars, cosmos","likes":0,"published":1,"flags":1,"usePreview":0,"tags":["square","stars","cosmos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals https://www.shadertoy.com/view/DtGyWh https://www.shadertoy.com/view/MfBGz3 /*original https://www.shadertoy.com/view/lslyRn, /* original https://www.shadertoy.com/view/lsyXDK https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/DlycWR and other*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.0000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(153,33,31))*.5+.5)\n\n#define rot(a)    mat2(cos((a)+vec4(0,11,33,0)))              // rotation\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=rot(iTime*0.04);// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\nvec4 O = fragColor;\nvec2 C = fragCoord;\n\t O=vec4(0);\n     vec4 O2 = O;\n   vec2  U  = C;\n   \n    float t=95., l, i, r;\n    vec3  R = iResolution, a,\n          D = normalize(vec3(U+U, -4.*R.y) - R),              // ray direction\n          p = vec3(0,2,15), q,                                // marching point along ray \n          C2 = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)); // demo mode\n    vec2 v;\n    for ( O2=vec4(1); O2.x > 0. && t > .01; O2-=.01 ) {          // march scene\n        q = p, \n        q.y-=1.5;\n         q.z+=80.5+-1.*cos(iTime);\n        q.yz *= rot(90.);                                    // camer\n          q.yz *= rot(iTime);              \n        for (r =5.; r > .25; r -= 0.25 )                        // for each ring\n            q.xz = vec2(-q.z,q), \n             q.zx = vec2(-q.z+5.2*cos(iTime),-q), \n            q.zx *= rot(clamp( mod(iTime*0.2,5.) * 3.14*r, 1.,3.14)),\n  q.xy *= rot(clamp( mod(iTime*0.2,2.) * 3.14*r, 1.,3.14)),\n   q.zy *= rot(clamp( mod(iTime*0.2,7.) - 3.14*r, 1.,3.14)),\n             a = abs(q), t = min(t,  max( abs( max(a.x,a.z) - r+.25 ) -.523  , a.y - .5 ) ); // draw frame\n\n        p += 0.7*t*D;                                          // step forward = dist to obj    \n    }\n    O2 *= O2*1.*O2;   \n    \n    \n     vec4 O3 = O;\n   vec2  U2  = C;\n   \n    float t2=9., l2, i2, r2;\n    vec3  R2 = iResolution, a2,\n          D2 = normalize(vec3(U2+U2, -4.*R2.y) - R2),              // ray direction\n          p2 = vec3(0,2,15), q2,                                // marching point along ray \n          C3 = iMouse.z > 0. ? 8.*iMouse.xyz/R2 -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)); // demo mode\n    vec2 v2;\n    for ( O3=vec4(1); O3.x > 0. && t2 > .01; O3-=.01 ) {          // march scene\n        q2 = p2, \n        q2.yz *= -rot(-C3.y),                                    // camera\n        q2.xz *= -rot(-C3.x);\n        for (r2 = 4.; r2 > .5+cos(iTime); r2 -= 0.25 )                        // for each ring\n            q2.xz = vec2(-q2.z+cos(iTime),q2),                              // swap axis by PI/2\n            q2.yz *= rot(clamp( mod(iTime,3.) * 3.14*r2, 0.,3.14)), // rotate the ring/ rotate the ring\n            a2 = abs(q2), t2 = min(t2,  max( abs( max(a2.x,a2.z) - r2+.25 ) -.523  , a2.y - .2 ) ); // draw frame\n\n        p2 += 0.7*t2*D2;                                          // step forward = dist to obj    \n    }\n    O3 *= O3*O3*1.;  \n    \n    \n    vec3 naturals,r3=iResolution,\n    d=normalize(vec3((C*2.-r3.xy)/r3.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        naturals=g*d;\n        naturals.z+=iTime*0.0;\n        a=30.;\n        naturals=mod(naturals-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            naturals=.3-abs(naturals);\n            \n            naturals.x<naturals.z?naturals=naturals.zyx:naturals;\n            naturals.z<naturals.y?naturals=naturals.xzy:naturals;\n            naturals.y<naturals.x?naturals=naturals.zyx:naturals;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            naturals=abs(naturals)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                    70,\n                    3.+cos(iTime*.5)*5.\n                 )*O2.xyz;\n         }\n         g+=e=length(naturals.yz)/s;\n        \n    }\n    \n    \n    \n\tvec3 from=vec3(1.,.5,0.5)*O2.xyz;\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor*=O;\n}\n","name":"Image","description":"","type":"image"}]}