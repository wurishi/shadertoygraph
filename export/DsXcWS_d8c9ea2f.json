{"ver":"0.1","info":{"id":"DsXcWS","date":"1688846671","viewed":61,"name":"Mandelbrot (zoomable)","username":"gmessow","description":"Mandelbrot set calculation with zoom on click. Zoom out by clicking the red rectangle.\n\nThis uses various techniques from other shaders, e.g. stateful buffer and arbitrary precision mandelbrot calculation.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 comp_mult( vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec3 palette(  float t ){\n    vec3 a = vec3(.4,.5,.5);\n    vec3 b = vec3(.6,.5,.5);\n    vec3 c = vec3(8.,1.,1.);\n    vec3 d = vec3(.74,.2434,.529);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n#define MAX_ITER 200.\n\nfloat mandelbrot(int[n_int] c_r, int[n_int] c_i)\n{\n    int z_r[n_int], z_i[n_int], pz_r[n_int], pz_i[n_int];\n    result = loadFloat(0.0);\n    z_r = result;\n    z_i = result;\n    pz_r = result;\n    pz_i = result;\n\n    for(float i = 0.; i < MAX_ITER; i++)\n    {\n        mul(pz_r, pz_r);\n        int orbitSize[n_int];\n        orbitSize = result;\n        mul(pz_i, pz_i);\n        add(orbitSize, result);\n        orbitSize = result;\n        int bailoutRadius[n_int] = loadFloat(4.0);\n        negate(bailoutRadius);\n        add(orbitSize, bailoutRadius);\n        if(signp(result))\n        {\n            return i/MAX_ITER;\n            // return 0.5*sin(4.0*pi*t)+0.5;\n        }\n\n        mul(pz_r, pz_r);\n        z_r = result;\n        mul(pz_i, pz_i);\n        negate(result);\n        add(z_r, result);\n        z_r = result;\n\n        mul(pz_r, pz_i);\n        z_i = result;\n        mul(z_i, loadFloat(2.0));\n        z_i = result;\n\n        add(z_r, c_r);\n        z_r = result;\n        add(z_i, c_i);\n        z_i = result;\n\n        pz_r = z_r;\n        pz_i = z_i;\n    }\n\n    return 0.0;\n}\n\nvoid sub(int[n_int] a, int[n_int] b) {\n    int[n_int] tmp = b;\n    negate(tmp);\n    add(a, tmp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    uv.x /= iResolution.x;\n    uv.y /= iResolution.y;\n    \n    vec4 window = fetchData(iChannel0, WINDOW_ADDR);\n    int[n_int] wx = loadFloat(window.x);\n    int[n_int] wy = loadFloat(window.y);\n    int[n_int] wz = loadFloat(window.z);\n    int[n_int] ww = loadFloat(window.w);\n    sub(wz, wx);\n    int[n_int] dx = result;\n    sub(ww, wy);\n    int[n_int] dy = result;\n    int[n_int] uv_x = loadFloat(uv.x);\n    int[n_int] uv_y = loadFloat(uv.y);\n    \n    //vec4 C;\n    mul(dx, uv_x);\n    add(wx, result);\n    int[n_int] C_r = result;\n    mul(dy, uv_y);\n    add(wy, result);\n    int[n_int] C_i = result;\n\n\n    float M = mandelbrot(C_r, C_i);\n    if (M > .0) {\n        fragColor.rgb = palette(M);\n    } else {\n        fragColor.rgb = vec3(.0);\n    }\n    fragColor.a = 1.;\n\n    if (fragCoord.x <= 20. && fragCoord.y <= 20.) {\n        // TODO: mix colors\n        fragColor = vec4(.7, .2, .2, 1.);\n    }\n    // Output to screen\n    //fragColor = vec4(.0,.0,.0,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (storeData(fragCoord, WINDOW_ADDR)) {\n        fragColor = vec4(-iResolution.xy / (.8*iResolution.y),iResolution.xy / (.8*iResolution.y));\n        fragColor.xz -= .5;\n            //vec4(-1.0,-1.0,1.0,1.0);\n    }\n    \n    if (iFrame > 0) {\n        if (storeData(fragCoord, WINDOW_ADDR)) {\n            fragColor = fetchData(iChannel0, WINDOW_ADDR);\n            \n            if (iMouse.w > 0.) {\n                vec2 mouse = iMouse.xy;\n                bool zoomout = (mouse.x <= 20. && mouse.y <= 20.);\n                mouse.x /= iResolution.x;\n                mouse.y /= iResolution.y;\n                float dx = fragColor.z - fragColor.x;\n                float dy = fragColor.w - fragColor.y;\n                vec2 d = vec2(dx,dy);\n                if (zoomout) {\n                    vec2 center = fragColor.xy + d * vec2(.5);\n                    fragColor = vec4(center - d*.6, center + d*.6);\n                } else {\n                    vec2 center = fragColor.xy + d * mouse;\n                    fragColor = vec4(center - d*.4, center + d*.4);\n                }\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Addresses:\n// These should be ivec2s containing the pixel coordinates of where certain data\n// should go. The coordinates are not normalize but can range from (0, 0) to\n// (iResolution.x, iResolution.y).\nconst ivec2 WINDOW_ADDR = ivec2(0,0);\n\n// Unfortunately, the only way to define functions that sample iChannels in Common\n// is with #define :(\n\n// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\n\n// GLSL Arbitrary Precision (modified a little bit)\n// https://github.com/alexozer/glsl-arb-prec\n\n// Number of Integers used to store an Arbitrary-Precision Number\n//const int n_int = 3;\n#define n_int 8\n\n// Power of 10 one larger than the maximum value per int\n//const int limit = 10000;\n#define limit 32768\n\nconst float limitFlt = float(limit);\n\nint result[n_int];\n\n#define zero(x, len) for(int i=0;i<len;i++){x[i]=0;}\n#define assign(x, y) for(int i=0;i<n_int;i++){x[i]=y[i];}\n#define negate(x) for(int i=0;i<n_int;i++){x[i]=-x[i];}\n\nbool signp(int[n_int] a)\n{\n    return a[n_int-1] >= 0;\n}\n\nint keepVal, carry;\n\nvoid roundOff(int x)\n{\n    carry = x/limit;\n    keepVal = x-carry*limit;\n}\n\nvoid add(int[n_int] a, int[n_int] b) {\n    bool s1 = signp(a), s2 = signp(b);\n\n    carry = 0;\n\n    for(int i = 0; i < n_int-1; i++) {\n        roundOff(a[i] + b[i] + carry);\n\n        if(keepVal < 0) {\n            keepVal += limit;\n            carry--;\n        }\n\n        result[i] = keepVal;\n    }\n    roundOff(a[n_int-1] + b[n_int-1] + carry);\n    result[n_int-1] = keepVal;\n    \n    if(s1 != s2 && !signp(result)) {\n        negate(result);\n\n        carry = 0;\n\n        for(int i = 0; i < n_int; i++) {\n            roundOff(result[i] + carry);\n\n            if(keepVal < 0) {\n                keepVal += limit;\n                carry--;\n            }\n\n            result[i] = keepVal;\n        }\n\n        negate(result);\n    }\n}\n\nvoid mul(int[n_int] a, int[n_int] b) {\n    bool toNegate = false;\n\n    if(!signp(a)) {\n        negate(a);\n        toNegate = !toNegate;\n    }\n    if(!signp(b)) {\n        negate(b);\n        toNegate = !toNegate;\n    }\n\n    const int lenProd = (n_int-1)*2+1;\n    int prod[lenProd];\n    zero(prod, lenProd);\n\n    for(int i = 0; i < n_int; i++) {\n        for(int j = 0; j < n_int; j++) {\n            prod[i+j] += a[i] * b[j];\n        }\n    }\n\n    carry = 0;\n    const int clip = lenProd - n_int;\n    for(int i = 0; i < clip; i++) {\n        roundOff(prod[i] + carry);\n        prod[i] = keepVal;\n    }\n\n    if(prod[clip-1] >= limit/2) {\n        carry++;\n    }\n\n    for(int i = clip; i < lenProd; i++) {\n        roundOff(prod[i] + carry);\n        prod[i] = keepVal;\n    }\n\n    for(int i = 0; i < lenProd - clip; i++) {\n        result[i] = prod[i+clip];\n    }\n\n    if(toNegate) {\n        negate(result);\n    }\n}\n\nint[n_int] loadFloat(float f)\n{\n    int x[n_int];\n\n    for(int i = n_int-1; i >= 0; i--)\n    {\n        int fCurr = int(f);\n        x[i] = fCurr;\n        f -= float(fCurr);\n        f *= limitFlt;\n    }\n\n    return x;\n}","name":"Common","description":"","type":"common"}]}