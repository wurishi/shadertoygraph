{"ver":"0.1","info":{"id":"sdGXWt","date":"1635480772","viewed":38,"name":"eindacor_bezierwave","username":"Eindacor_DS","description":"it's a shader, you dolt!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TIME_SCALE .5\n#define SEGMENT_COUNT 25\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat circleSmoothStep(vec2 center, float radius, float thickness, vec2 p, float antiAlias) {\n    float distFromCenter = distance(center, p);\n    float halfThickness = thickness / 2.f;\n    if (distFromCenter < radius) {\n        return smoothstep(radius - halfThickness - antiAlias, radius - halfThickness + antiAlias, distFromCenter);\n    } else {\n        return 1.f - smoothstep(radius + halfThickness - antiAlias, radius + halfThickness + antiAlias, distFromCenter);\n    }\n}\n\n/*\n\treturns smoothstep value for line segment\n\texample usage:\n\t\toutColor = mix(outColor, lineColor, lineSegmentSmoothStep(start, end, uv, thickness, AA, true));\n*/\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nfloat getQuadraticBezierSmoothStep(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv, int segmentCount, float lineThickness, float aa, bool deriv) {\n    vec2 previousPoint = p0;\n    \n    float val = 0.f;\n    \n    for (int i=0; i<segmentCount; i++) {\n        if (i==0) {\n            continue; // ignore the first segment\n        }\n\n        float t = float(i) / float(segmentCount);\n\n        float tSquared = pow(t, 2.);\n        float tCubed = pow(t, 3.);\n        float p0Val = -tCubed + 3.*tSquared - 3.*t + 1.;\n        float p1Val = 3.*tCubed - 6.*tSquared + 3.*t;\n        float p2Val = -3.*tCubed + 3.*tSquared;\n        float p3Val = tCubed;\n        \n        float p0Deriv = -3.*tSquared + 6.*t - 3.;\n        float p1Deriv = 9.*tSquared - 12.*t + 3.;\n        float p2Deriv = -9.*tSquared + 6.*t;\n        float p3Deriv = 3.*tSquared;\n        \n        vec2 pDeriv = p0 * p0Deriv + p1 * p1Deriv + p2 * p2Deriv + p3 * p3Deriv;\n        \n        vec2 p = p0 * p0Val + p1 * p1Val + p2 * p2Val + p3 * p3Val;\n\n        val = mix(val, 1.0, lineSegmentSmoothStep(previousPoint, p, uv, lineThickness, aa, true));\n\n        previousPoint = deriv ? pDeriv : p;\n    }\n    val = mix(val, 1.0, lineSegmentSmoothStep(previousPoint, p3, uv, lineThickness, aa, true));\n    \n    return val;\n}\n\nfloat getPointSmoothStep(vec2 p, vec2 uv, float radius, float antiAlias) {\n    float pDist = distance(uv, p);\n    return smoothstep(radius + antiAlias, radius - antiAlias, pDist);\n}\n\nfloat normalSin(float sinVal) {\n    return (sinVal + 1.f) / 2.f;\n}\n\nfloat getXVal(float x, float time) {\n    return (time * TIME_SCALE + x) * 2.f;\n}\n\nvec2 getPointFromXVal(float xVal, float time) {\n    float adjustedXVal = getXVal(xVal, time);\n    float hashVal = hash(vec2(floor(adjustedXVal))); \n    return vec2((xVal / 2.) - time, hashVal);\n}\n\nvec2 getPointFromXIndex(float xIndex, float time) {\n    float hashVal = hash(vec2(xIndex)); \n    return vec2((xIndex / 2.) - time, hashVal);\n}\n\nfloat getScreenCoordsFromXVal(float xVal, float time) {\n    return (xVal / 2.) - time * TIME_SCALE;\n}\n\nfloat getYFromXAndTwoPoints(float x, vec2 p0, vec2 p1) {\n    vec2 rightmost = p0.x > p1.x ?  p0 : p1;\n    vec2 leftmost =  p0.x > p1.x ?  p1 : p0;\n    \n    float slope = (rightmost.y - leftmost.y) / (rightmost.x - leftmost.x);\n\n    float deltaX = x - leftmost.x;\n    return slope * deltaX + leftmost.y;\n}\n\nfloat getYFromBezierCurve(float x, vec2 p0, vec2 p1, vec2 p2, vec2 p3, int segmentCount) {\n    vec2 previousPoint = p0;\n    \n    float val = 0.f;\n    \n    for (int i=0; i<segmentCount; i++) {\n        if (i==0) {\n            continue; // ignore the first segment\n        }\n\n        float t = float(i) / float(segmentCount);\n\n        float tSquared = pow(t, 2.);\n        float tCubed = pow(t, 3.);\n        float p0Val = -tCubed + 3.*tSquared - 3.*t + 1.;\n        float p1Val = 3.*tCubed - 6.*tSquared + 3.*t;\n        float p2Val = -3.*tCubed + 3.*tSquared;\n        float p3Val = tCubed;\n        \n        vec2 p = p0 * p0Val + p1 * p1Val + p2 * p2Val + p3 * p3Val;\n        \n        vec2 rightmost = p.x > previousPoint.x ?  p : previousPoint;\n        vec2 leftmost =  p.x > previousPoint.x ?  previousPoint : p;\n        \n        if (x > leftmost.x && x < rightmost.x) {\n            return getYFromXAndTwoPoints(x, p, previousPoint);\n        }\n\n        previousPoint = p;\n    }\n    \n    vec2 rightmost = p3.x > previousPoint.x ?  p3 : previousPoint;\n    vec2 leftmost =  p3.x > previousPoint.x ?  previousPoint : p3;\n\n    if (x > leftmost.x && x < rightmost.x) {\n        return getYFromXAndTwoPoints(x, p3, previousPoint);\n    }\n    \n    // this is prone to bugs but can't pass by ref in shaders so meh\n    return -1.;\n}\n\nfloat getUndulatingVal(float time, float seed) {  \n    float randVal1 = (sin(time * TIME_SCALE + hash(vec2(seed))) + 1.) / 2.;\n    float randVal2 = (sin(time * TIME_SCALE + hash(vec2(seed * -1.))) + 1.) / 2.;\n    float xVal = (time * TIME_SCALE * 2.f) + hash(vec2(seed, 1.));\n    float hashVal = hash(vec2(floor(xVal)));   \n    \n    float nextXValFloor = floor(xVal) + 1.;\n    float nextHashVal = hash(vec2(nextXValFloor));\n    vec2 nextPoint = vec2((nextXValFloor / 2.) - time, nextHashVal);\n    \n    float interpVal = xVal - floor(xVal);\n    \n    float xIndex = floor(xVal);\n    vec2 thisPoint = vec2((xIndex / 2.) - time, hashVal);\n    \n    float indexVal = mod(xIndex, 2.f);\n    \n    float zeroVal = xIndex - floor(indexVal);\n    \n    vec2 p0 = getPointFromXVal(thisPoint.x, time);\n    vec2 p1 = getPointFromXVal(floor(indexVal) + 2., time);\n    vec2 p2 = getPointFromXVal(floor(indexVal) + 2., time);\n    vec2 p3 = getPointFromXVal(floor(indexVal) + 3., time);\n\n    vec2 pn2, pn1;\n    \n    float xIndexAdjustment = indexVal < .99 ? -2. : -3.;\n\n    pn2 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment, time), hash(vec2(xIndex + xIndexAdjustment)));\n    pn1 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 1., time), hash(vec2(xIndex + xIndexAdjustment + 1.)));\n    p0 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 2., time), hash(vec2(xIndex + xIndexAdjustment + 2.)));\n    p1 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 3., time), hash(vec2(xIndex + xIndexAdjustment + 3.)));\n    p2 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 4., time), hash(vec2(xIndex + xIndexAdjustment + 4.)));\n    p3 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 5., time), hash(vec2(xIndex + xIndexAdjustment + 5.)));\n    \n    vec2 p05 = mix(p0, p1, .5f);\n    vec2 p25 = mix(p2, p3, .5f);\n    \n    vec2 pn15 = mix(pn2, pn1, .5f);\n    \n    p1.x = mix(p05.x, p25.x, .333f);\n    p2.x = mix(p05.x, p25.x, .666f);\n    \n    pn1.x = mix(pn15.x, p05.x, .333f);\n    p0.x = mix(pn15.x, p05.x, .666f);\n    float x = hash(vec2(seed)) * .2;\n    float midY = getYFromBezierCurve(x, p05, p1, p2, p25, SEGMENT_COUNT);\n    \n    if (midY < 0.) {\n        midY = getYFromBezierCurve(x, pn15, pn1, p0, p05, SEGMENT_COUNT);\n    }\n    \n    return midY;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;  \n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(vec3(0.),1.0);\n    \n    float xVal = getXVal(uv.x, iTime);\n    float hashVal = hash(vec2(floor(xVal)));   \n    \n    float nextXValFloor = floor(xVal) + 1.;\n    float nextHashVal = hash(vec2(nextXValFloor));\n    vec2 nextPoint = vec2((nextXValFloor / 2.) - iTime, nextHashVal);\n    \n    float interpVal = xVal - floor(xVal);\n    \n    //fragColor = vec4(vec3(interpVal), 1.f);\n    \n    float xIndex = floor(xVal);\n    vec2 thisPoint = vec2((xIndex / 2.) - iTime, hashVal);\n    \n    float indexVal = mod(xIndex, 2.f);\n    \n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 0.f, 1.f), lineSegmentSmoothStep(thisPoint, nextPoint, uv, .01, .002, true));\n    //fragColor = vec4(vec3(hashVal), 1.f);\n    \n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 0.f, 1.f), getPointSmoothStep(thisPoint, uv, .1, .002));\n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 0.f, 1.f), getPointSmoothStep(nextPoint, uv, .1, .002));\n    \n    //fragColor = mix(fragColor, vec4(1.f, 1.f, 0.f, 1.f), lineSegmentSmoothStep(thisPoint, nextPoint, uv, .01, .002, true));\n    //fragColor = vec4(vec3(hashVal), 1.f);\n    \n    // indexVal is val between 0 and 4\n    // what the indexVal is determines which p point below is p0\n    \n    float zeroVal = xIndex - floor(indexVal);\n    \n    vec2 p0 = getPointFromXVal(thisPoint.x, iTime);\n    vec2 p1 = getPointFromXVal(floor(indexVal) + 2., iTime);\n    vec2 p2 = getPointFromXVal(floor(indexVal) + 2., iTime);\n    vec2 p3 = getPointFromXVal(floor(indexVal) + 3., iTime);\n\n    vec2 pn2, pn1;\n    \n    float xIndexAdjustment = indexVal < .99 ? -2. : -3.;\n    \n    //fragColor = vec4(vec3(indexVal / 2.), 1.f);\n    \n    pn2 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment, iTime), hash(vec2(xIndex + xIndexAdjustment)));\n    pn1 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 1., iTime), hash(vec2(xIndex + xIndexAdjustment + 1.)));\n    p0 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 2., iTime), hash(vec2(xIndex + xIndexAdjustment + 2.)));\n    p1 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 3., iTime), hash(vec2(xIndex + xIndexAdjustment + 3.)));\n    p2 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 4., iTime), hash(vec2(xIndex + xIndexAdjustment + 4.)));\n    p3 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 5., iTime), hash(vec2(xIndex + xIndexAdjustment + 5.)));\n    \n    vec2 p05 = mix(p0, p1, .5f);\n    vec2 p25 = mix(p2, p3, .5f);\n    \n    vec2 pn15 = mix(pn2, pn1, .5f);\n    \n    p1.x = mix(p05.x, p25.x, .333f);\n    p2.x = mix(p05.x, p25.x, .666f);\n    \n    pn1.x = mix(pn15.x, p05.x, .333f);\n    p0.x = mix(pn15.x, p05.x, .666f);\n    \n    fragColor = mix(fragColor, vec4(vec3(p05.y), 1.f), lineSegmentSmoothStep(vec2(p05.x, 0.), vec2(p05.x, 1.), uv, .005, .002, true));\n    fragColor = mix(fragColor, vec4(vec3(p1.y), 1.f), lineSegmentSmoothStep(vec2(p1.x, 0.), vec2(p1.x, 1.), uv, .005, .002, true));\n    fragColor = mix(fragColor, vec4(vec3(p2.y), 1.f), lineSegmentSmoothStep(vec2(p2.x, 0.), vec2(p2.x, 1.), uv, .005, .002, true));\n    \n    fragColor = mix(fragColor, vec4(1.f, 0.f, 1.f, 1.f), getQuadraticBezierSmoothStep(p05, p1, p2, p25, uv, SEGMENT_COUNT, .02, .002, false));\n    fragColor = mix(fragColor, vec4(1.f, 0.f, 1.f, 1.f), getQuadraticBezierSmoothStep(pn15, pn1, p0, p05, uv, SEGMENT_COUNT, .02, .002, false));\n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 1.f, 1.f), getQuadraticBezierSmoothStep(p05, p1, p2, p25, uv, 15, .002, .002, true));\n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 1.f, 1.f), getQuadraticBezierSmoothStep(pn15, pn1, p0, p05, uv, 15, .002, .002, true));\n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 0.f, 1.f), getPointSmoothStep(p1, uv, .03, .002));\n    //fragColor = mix(fragColor, vec4(0.f, 1.f, 0.f, 1.f), getPointSmoothStep(p2, uv, .03, .002));\n    //fragColor = mix(fragColor, vec4(0.f, 0.f, 1.f, 1.f), getPointSmoothStep(p05, uv, .03, .002));\n    \n    float screenmid = .5 * aspectRatio;\n    float midY = getYFromBezierCurve(screenmid, p05, p1, p2, p25, SEGMENT_COUNT);\n    \n    if (midY < 0.) {\n        midY = getYFromBezierCurve(screenmid, pn15, pn1, p0, p05, SEGMENT_COUNT);\n    }\n    \n    vec2 pBez = vec2(screenmid, midY);\n    fragColor = mix(fragColor, vec4(vec3(midY), 1.f), getPointSmoothStep(pBez, uv, .03, .002));\n    \n    float undulatingX = getUndulatingVal(iTime, .5);\n    float undulatingY = getUndulatingVal(iTime, 200.25);\n    \n    vec2 randPoint = vec2(undulatingX * aspectRatio, undulatingY);\n    \n    fragColor = mix(fragColor, vec4(1.f, 0.2f, .8f, 1.f), getPointSmoothStep(randPoint, uv, .03, .002));\n\n    //fragColor = vec4(vec3(getUndulatingVal(iTime)), 1.);\n}","name":"Image","description":"","type":"image"}]}