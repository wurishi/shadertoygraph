{"ver":"0.1","info":{"id":"wdffW2","date":"1589082526","viewed":103,"name":"(A-B) / (A+B)","username":"bcourter","description":"An example of the two-body field (A-B) / (A+B), where A and B are SDFs.  Uses Sampson distance (normalization by gradient magnitude) to produce approximate constant thickness bands.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float padding = iResolution.x * (0.25 + cos(iTime) * 0.06);\n    float size = iResolution.x * 0.05 + sin(iTime) * 10.0;\n     \n    Implicit A = RectangleCenterRotated(fragCoord, vec2(padding, iResolution.y / 2.0), vec2(size * 2.0), iTime * 0.1, vec4(0.2, 0.6, 0.2, 1));\n    Implicit B = Circle(fragCoord, vec2(iResolution.x - padding, iResolution.y / 2.0), size, vec4(0, 0.4, 0.6, 1));\n    \n    Implicit merged = Min(A, B);\n    if (merged.Distance < 0.0) {\n    \tfragColor = merged.Color * -0.02 * merged.Distance + merged.Color * 0.3;\n    \treturn;\n    }\n    \n    Implicit interp = Divide(Subtract(A, B), Add(A, B));\n    \n    float numBands = 20.0;\n    Implicit wave = TriangleWaveEvenPositive(interp, 2.0 / numBands, mix(A.Color, B.Color, (interp.Distance + 1.0) * 0.5));    \n    float normalized = wave.Distance / length(wave.Gradient);\n\n    if (normalized < 2.0) {\n        float f = length(interp.Gradient) * iResolution.x * 0.1;\n        float squeeze = mix(1.0, 0.0, f*f);\n        fragColor = vec4(0.4, squeeze * 0.75, squeeze, 1);\n    \treturn;\n    }\n\n    fragColor = wave.Color;   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Implicit\n{\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance < b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Add(Implicit a, Implicit b)\n{\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b) \n{\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Multiply(Implicit a, Implicit b)\n{\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Divide(Implicit a, Implicit b)\n{\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(-centered / len, 0.0), color);\n}\n \nmat2 Rotate(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}","name":"Common","description":"","type":"common"}]}