{"ver":"0.1","info":{"id":"wtycWR","date":"1610783428","viewed":102,"name":"sdQuad","username":"DjinnKahn","description":"Small modification of iq's udQuad function to work in 2d and return a *signed* distance.\n\nNote: the quad must be convex.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["quad","signeddistancefunction","sdquad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat min4( float a, float b, float c, float d ) { return min(min(a,b),min(c,d)); }\nfloat max4( float a, float b, float c, float d ) { return max(max(a,b),max(c,d)); }\n\n//// signed distance from p to quad (a,b,c,d) -- this also works, but isn't quite as nice\n//float sdQuad( vec2 p, vec2 a, vec2 b, vec2 c, vec2 d )\n//{    \n//    vec2 ab = a - b; vec2 pa = p - a;\n//    vec2 bc = b - c; vec2 pb = p - b;\n//    vec2 cd = c - d; vec2 pc = p - c;\n//    vec2 da = d - a; vec2 pd = p - d;\n//        \n//    float distAB = dot( pb, normalize( vec2( ab.y, -ab.x ) ) );\n//    float distBC = dot( pc, normalize( vec2( bc.y, -bc.x ) ) );\n//    float distCD = dot( pd, normalize( vec2( cd.y, -cd.x ) ) );\n//    float distDA = dot( pa, normalize( vec2( da.y, -da.x ) ) );\n//    \n//    if ( dot(ab,pb) >= 0. && dot(ab,pb) <= dot(ab,ab) && distAB >= 0. ) return distAB;\n//    if ( dot(bc,pc) >= 0. && dot(bc,pc) <= dot(bc,bc) && distBC >= 0. ) return distBC;\n//    if ( dot(cd,pd) >= 0. && dot(cd,pd) <= dot(cd,cd) && distCD >= 0. ) return distCD;\n//    if ( dot(da,pa) >= 0. && dot(da,pa) <= dot(da,da) && distDA >= 0. ) return distDA;\n//    if ( distAB <= 0. && distBC <= 0. && distCD <= 0. && distDA <= 0. ) return max4( distAB, distBC, distCD, distDA );\n//    return min4(length(pa),length(pb),length(pc),length(pd));\n//}\n\n// signed distance from p to quad (a,b,c,d)\nfloat sdQuad( vec2 p, vec2 a, vec2 b, vec2 c, vec2 d )\n{    \n    vec2 ba = b - a; vec2 pa = p - a;\n    vec2 cb = c - b; vec2 pb = p - b;\n    vec2 dc = d - c; vec2 pc = p - c;\n    vec2 ad = a - d; vec2 pd = p - d;\n    \n    return sign( 3. - sign(ba.y*pa.x-ba.x*pa.y)\n                    - sign(cb.y*pb.x-cb.x*pb.y)\n                    - sign(dc.y*pc.x-dc.x*pc.y)\n                    - sign(ad.y*pd.x-ad.x*pd.y) )\n         * sqrt(min4(dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.,1.)-pa)\n                    ,dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.,1.)-pb)\n                    ,dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.,1.)-pc)\n                    ,dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.,1.)-pd)));\n}\n\n//// from udQuad is from iq\n//float udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n//{\n//  vec3 ba = b - a; vec3 pa = p - a;\n//  vec3 cb = c - b; vec3 pb = p - b;\n//  vec3 dc = d - c; vec3 pc = p - c;\n//  vec3 ad = a - d; vec3 pd = p - d;\n//  vec3 nor = cross( ba, ad );\n//\n//  return sqrt(\n//    (sign(dot(cross(ba,nor),pa)) +\n//     sign(dot(cross(cb,nor),pb)) +\n//     sign(dot(cross(dc,nor),pc)) +\n//     sign(dot(cross(ad,nor),pd))<3.0) // check if it's an interior point\n//     ?\n//     min( min( min(\n//     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),  // find nearest point on each line segment\n//     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n//     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n//     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n//     :\n//     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dist = sdQuad( fragCoord, vec2( 140, 50 ), vec2( 120, 230 ), vec2( 300, 330 ), vec2( 400, 50 ) );\n    //float dist = udQuad( vec3( fragCoord, 0. ), vec3( 140, 50, 0 ), vec3( 120, 230, 0 ), vec3( 300, 330, 0 ), vec3( 400, 50, 0 ) );\n    \n    fragColor = vec4( dist > 0. ? .3 : 0., 0., mod(dist/20., 1.), 1.0);\n}","name":"Image","description":"","type":"image"}]}