{"ver":"0.1","info":{"id":"fsV3WG","date":"1632149773","viewed":56,"name":"SDF PBR","username":"helgust","description":"nice","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 eye = vec3(0,0,10);\nconst vec3 light = vec3(0.0,5.0,10.0);\nconst int maxSteps = 100;\nconst float eps = 0.01;\n\n\nfloat smin (float a, float b, float k)\n{\n    float res = exp(-k*a)+exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat dCone ( vec3 p, vec2 c )\n{\n    float q = length( p.yz );\n    return dot ( c, vec2 ( q, p.x ) );\n}\n\nfloat dCyl ( vec3 p, vec3 c )\n{\nreturn length ( p.xz - c.xy ) - c.z+0.03* cos(5.0*p.y + iTime)+0.02 * sin(20.0*p.z + iTime) ;\n}\n\nfloat dSphere (vec3 p, vec3 c)\n{\n    return length(p - c) - 1.0 +0.03 * sin(20.0*p.y + iTime);\n}\n\nfloat dEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat length8 (in vec2 p)\n{\n    return pow(pow(p.x,8.0) + pow (p.y,8.0),1.0/8.0);\n}\n\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus (vec3 p, vec3 t)\n{\n    vec2  q=vec2(length8 (p.xz) - t.x,p.y);\n    return length8(q) - t.y;\n}\n\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(1,0,0),\n            vec3(0,c,-s),\n            vec3(0,s,c));\n}\n\nmat3 rotateZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c,-s,0),\n            vec3(s,c,0),\n            vec3(0,0,1));\n}\n\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c,0,s),\n            vec3(0,1,0),\n            vec3(-s,0,c));\n}\n\nfloat sdf (in vec3 p,in mat3 m)\n{\n    vec3 q = m*p;\n    vec3 o = q*rotateX(90.0);\n    \n    return smin(smin(dEllipsoid(q,vec3(1,5,1)),dCyl(rotateX(-90.0)*q,vec3(0,0,1)),7.0),smin(dSphere(q,vec3(0,5,0)),dSphere(q,vec3(0,-5,0)),8.0),9.0);\n}  \nvec3 generateNormal (vec3 z, float d,in mat3 m)\n{\n    float e  = max(d * 0.5,eps);\n    float dx1 = sdf(z+ vec3(e,0,0),m);\n    float dx2 = sdf(z- vec3(e,0,0),m);\n    float dy1 = sdf(z+ vec3(0,e,0),m);\n    float dy2 = sdf(z- vec3(0,e,0),m);\n    float dz1 = sdf(z+ vec3(0,0,e),m);\n    float dz2 = sdf(z- vec3(0,0,e),m);\n    \n    return normalize (vec3 (dx1 - dx2,dy1-dy2,dz1-dz2));\n}\n\n\n\nconst float roughness = 0.4;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst vec3  clr  = vec3 ( 0.8, 0.4, 0.0 );\nconst float gamma = 2.2;\nconst float pi    = 3.1415926;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n    float metallness = 1.0;\n    vec3  base  = pow ( clr, vec3 ( gamma ) );\n    vec3  F0    = mix ( vec3(FDiel), clr, metallness );\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( F0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.25 * d * g / nv);\n\tvec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );\n}\n\n\nvec3 trace(in vec3 from, in vec3 dir, out bool hit, in mat3 m)\n{\n    vec3 p = from;\n    float totalDist = 0.0;\n    \n    hit =false;\n    \n    for (int steps = 0; steps < maxSteps; steps++)\n    {\n        float dist = sdf(p,m);\n        \n        if(dist < 0.001)\n        {\n            hit = true;\n        }\n        totalDist+=dist;\n        \n        if(totalDist > 20.0)\n            break;\n           p+=dist*dir;\n    }\n    \n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z - 0.5);\n    mat3 m = rotateX(6.0*mouse.y) * rotateY(6.0*mouse.x);\n    vec2 scale = 12.0 * iResolution.xy / max(iResolution.x,iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2 (0.5));\n    vec3 dir = normalize (vec3 (uv,0) - eye);\n    vec4 color = vec4(0,0,0,1);\n    vec3 p = trace(eye,dir,hit,m);\n    \n    if(hit)\n    {\n     vec3 l = normalize(light - p);\n     vec3 v = normalize(eye - p);\n     vec3 n = generateNormal(p,0.001,m);\n     vec3 r = l-2.0*max(0.0,dot(l,n))*n;\n     float nl = max(0.0,dot(n,l));\n     vec3 h = normalize(l+v);\n     float hn = max(0.0,dot(-v,r));\n     float sp = pow (hn,90.0);\n     \n     \n     color = 0.5*vec4(nl) + sp*vec4(1,0,0,1);\n     color = cookTorrance ( p, n, l, v );\n    }\n\n    // Output   to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}