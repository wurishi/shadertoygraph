{"ver":"0.1","info":{"id":"3lSyzW","date":"1605712376","viewed":284,"name":"simple path tracer (tutorial)","username":"justvg","description":"following demofox path tracer tutorial","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float Exposure = 0.5f;\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord)\n{\n    vec3 Color = texture(iChannel0, FragCoord / iResolution.xy).rgb;\n    \n    Color *= Exposure;\n    Color = ACESFilm(Color);\n    Color = LinearToSRGB(Color);\n    \n    FragColor = vec4(Color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float MinRayHitTime = 0.01f;\nconst float MaxRayHitTime = 10000.0f;\n\nconst int NumBounces = 8;\nconst float NormalNudge = 0.01f;\n\nconst float FoVDegrees = 90.0f;\nconst float PI = 3.14159265359f;\nconst float TwoPI = 2.0f*PI;\n\nuint WangHash(inout uint Seed)\n{\n    Seed = uint(Seed ^ uint(61)) ^ uint(Seed >> uint(16));\n    Seed *= uint(9);\n    Seed = Seed ^ (Seed >> 4);\n    Seed *= uint(0x27d4eb2d);\n    Seed = Seed ^ (Seed >> 15);\n    return Seed;\n}\n\nfloat RandomFloat01(inout uint State)\n{\n    float Result = float(WangHash(State)) / 4294967296.0;\n    return(Result);\n}\n\nvec3 RandomUnitVector(inout uint State)\n{\n    float Z = 2.0f*RandomFloat01(State) - 1.0f;\n    float Angle = TwoPI*RandomFloat01(State);\n    float Radius = sqrt(1.0f - Z*Z);\n    float X = Radius * cos(Angle);\n    float Y = Radius * sin(Angle);\n\t\n    vec3 Result = vec3(X, Y, Z);\n    return(Result);\n}\n\nstruct material_info\n{\n    vec3 Albedo;\n    vec3 Emissive;\n    float SpecularChance;\n    float SpecularRoughness;\n    vec3 SpecularColor;\n    float IOR;\n \tfloat RefractionChance;\n    float RefractionRoughness;\n    vec3 RefractionColor;\n};\n    \nmaterial_info GetZeroedMaterial()\n{\n    material_info Result;\n    \n    Result.Albedo = vec3(0.0f, 0.0f, 0.0f);\n    Result.Emissive = vec3(0.0f, 0.0f, 0.0f);\n    Result.SpecularChance = 0.0f;\n    Result.SpecularRoughness = 0.0f;\n    Result.SpecularColor = vec3(0.0f, 0.0f, 0.0f);\n    Result.IOR = 1.0f;\n \tResult.RefractionChance = 0.0f;\n    Result.RefractionRoughness = 0.0f;\n    Result.RefractionColor = vec3(0.0f, 0.0f, 0.0f);\n    \n    return(Result);\n}\n\nstruct ray_hit_info\n{\n    bool FromInside;\n    float t;\n    vec3 Normal;\n    material_info Material;\n};\n    \nfloat ScalarTriple(vec3 A, vec3 B, vec3 C)\n{\n    float Result = dot(cross(A, B), C);\n    return(Result);\n}\n    \nbool TestQuadRay(in vec3 RayPosition, in vec3 RayDir, inout ray_hit_info HitInfo, in vec3 A, in vec3 B, in vec3 C, in vec3 D)\n{\n \tvec3 Normal = normalize(cross(C-A, C-B));\n    if(dot(RayDir, Normal) > 0.0f)\n    {\n        Normal *= -1.0f;\n        \n        vec3 Temp = A;\n        A = D;\n        D = Temp;\n        \n        Temp = B;\n        B = C;\n        C = Temp;\n    }\n    \n    vec3 P = RayPosition;\n    vec3 PQ = RayDir;\n    vec3 PA = A - P;\n    vec3 PB = B - P;\n    vec3 PC = C - P;\n    vec3 PD = D - P;\n    \n    vec3 IntersectionP;\n    \n    float V = ScalarTriple(PQ, PA, PC);\n\tif(V >= 0.0f)\n    {\n        // Test intersection against triangle ABC\n        float U = ScalarTriple(PQ, PC, PB);\n        if(U < 0.0f) return(false);\n        float W = ScalarTriple(PQ, PB, PA);\n    \tif(W < 0.0f) return(false);\n        \n        float Denom = 1.0f / (U + V + W);\n        U *= Denom;\n        V *= Denom;\n        W = 1.0f - U - V;\n\n        IntersectionP = A*U + B*V + C*W;\n    }\n    else\n    {\n        // Test intersection against triangle DAC\n        float U = ScalarTriple(PQ, PD, PC);\n        if(U < 0.0f) return(false);\n        float W = ScalarTriple(PQ, PA, PD);\n    \tif(W < 0.0f) return(false);\n        V = -V;\n        \n        float Denom = 1.0f / (U + V + W);\n        U *= Denom;\n        V *= Denom;\n        W = 1.0f - U - V;\n\n        IntersectionP = A*U + D*V + C*W;\n    }\n    \n    float t;\n    if (abs(RayDir.x) > 0.1f)\n    {\n        t = (IntersectionP.x - RayPosition.x) / RayDir.x;\n    }\n    else if (abs(RayDir.y) > 0.1f)\n    {\n        t = (IntersectionP.y - RayPosition.y) / RayDir.y;\n    }\n    else\n    {\n        t = (IntersectionP.z - RayPosition.z) / RayDir.z;\n    }\n    \n    if((t > MinRayHitTime) && (t < HitInfo.t))\n    {\n        HitInfo.FromInside = false;\n        HitInfo.t = t;\n        HitInfo.Normal = Normal;\n        return(true);\n    }\n    \n    return(false);\n}\n    \nbool TestSphereRay(in vec3 RayPosition, in vec3 RayDir, inout ray_hit_info HitInfo, in vec4 Sphere)\n{\n    vec3 M = RayPosition - Sphere.xyz;\n    float B = dot(M, RayDir);\n    float C = dot(M, M) - Sphere.w*Sphere.w;\n    \n    if((C > 0.0f) && (B > 0.0f))\n    {\n        return(false);\n    }\n    \n    float Discr = B*B - C;\n    if(Discr < 0.0f)\n    {\n        return(false);\n    }\n    \n    bool FromInside = false;\n    float t = -B - sqrt(Discr);\n    if(t < 0.0f)\n    {\n        FromInside = true;\n        t = -B + sqrt(Discr);\n    }\n    \n    if((t > MinRayHitTime) && (t < HitInfo.t))\n    {\n        HitInfo.FromInside = FromInside;\n        HitInfo.t = t;\n        HitInfo.Normal = normalize((RayPosition + t*RayDir) - Sphere.xyz) * (FromInside ? -1.0f : 1.0f);\n        return(true);\n    }\n    \n    return(false);\n}\n\nvoid TestSceneTrace(in vec3 RayPosition, in vec3 RayDir, inout ray_hit_info HitInfo)\n{\n    vec3 SceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 SceneTranslation4 = vec4(SceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + SceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + SceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + SceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + SceneTranslation;\n        if(TestQuadRay(RayPosition, RayDir, HitInfo, A, B, C, D))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(0.7f, 0.7f, 0.7f);\n        }\n\t}    \n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + SceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + SceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + SceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + SceneTranslation;\n        if(TestQuadRay(RayPosition, RayDir, HitInfo, A, B, C, D))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(0.7f, 0.7f, 0.7f);\n        }        \n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + SceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + SceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + SceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + SceneTranslation;\n        if(TestQuadRay(RayPosition, RayDir, HitInfo, A, B, C, D))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(0.7f, 0.7f, 0.7f);\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + SceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + SceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + SceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + SceneTranslation;\n        if(TestQuadRay(RayPosition, RayDir, HitInfo, A, B, C, D))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(0.7f, 0.1f, 0.1f);\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + SceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + SceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + SceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + SceneTranslation;\n        if(TestQuadRay(RayPosition, RayDir, HitInfo, A, B, C, D))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(0.1f, 0.7f, 0.1f);\n        }        \n    }    \n    \n    // light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + SceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + SceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + SceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + SceneTranslation;\n        if(TestQuadRay(RayPosition, RayDir, HitInfo, A, B, C, D))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n        }        \n    }\n    \n\tif(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+SceneTranslation4))\n    {\n        HitInfo.Material = GetZeroedMaterial();\n        HitInfo.Material.Albedo = vec3(0.9f, 0.9f, 0.5f);\n        HitInfo.Material.SpecularChance = 0.1f;\n        HitInfo.Material.SpecularRoughness = 0.2f;\n        HitInfo.Material.SpecularColor = vec3(0.9f, 0.9f, 0.9f);     \n    } \n    \n\tif(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)+SceneTranslation4))\n    {\n        HitInfo.Material = GetZeroedMaterial();\n        HitInfo.Material.Albedo = vec3(0.9f, 0.5f, 0.9f);\n        HitInfo.Material.SpecularChance = 0.3f;\n        HitInfo.Material.SpecularRoughness = 0.2;\n        HitInfo.Material.SpecularColor = vec3(0.9f, 0.9f, 0.9f);  \n    }    \n    \n\tif(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+SceneTranslation4))\n    {\n        HitInfo.Material = GetZeroedMaterial();\n        HitInfo.Material.Albedo = vec3(0.9f, 0.25f, 0.25f);\n        HitInfo.Material.SpecularChance = 0.02f;\n        HitInfo.Material.SpecularRoughness = 0.3f;\n        HitInfo.Material.SpecularColor = vec3(0.8f, 0.8f, 0.8f);\n        HitInfo.Material.IOR = 1.1f;\n        HitInfo.Material.RefractionChance = 1.0f;\n        HitInfo.Material.RefractionRoughness = 0.3f;\n        HitInfo.Material.RefractionColor = vec3(0.0f, 0.5f, 1.0f);\n    }  \n    \n    {\n        if(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(-10.0f, 0.0f, 23.0f, 1.75f)+SceneTranslation4))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(1.0f, 1.0f, 1.0f);\n            HitInfo.Material.SpecularChance = 1.0f;\n            HitInfo.Material.SpecularColor = vec3(0.3f, 1.0f, 0.3f);       \n        }     \n        \n        if(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(-5.0f, 0.0f, 23.0f, 1.75f)+SceneTranslation4))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(1.0f, 1.0f, 1.0f);\n            HitInfo.Material.SpecularChance = 1.0f;\n            HitInfo.Material.SpecularRoughness = 0.25f;\n            HitInfo.Material.SpecularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)+SceneTranslation4))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(1.0f, 1.0f, 1.0f);\n            HitInfo.Material.Emissive = vec3(0.0f, 0.0f, 0.0f);        \n            HitInfo.Material.SpecularChance = 1.0f;\n            HitInfo.Material.SpecularRoughness = 0.5f;\n            HitInfo.Material.SpecularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)+SceneTranslation4))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(1.0f, 1.0f, 1.0f);\n            HitInfo.Material.SpecularChance = 1.0f;\n            HitInfo.Material.SpecularRoughness = 0.75f;\n            HitInfo.Material.SpecularColor = vec3(0.3f, 1.0f, 0.3f);\n        }        \n        \n        if(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)+SceneTranslation4))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(1.0f, 1.0f, 1.0f);\n            HitInfo.Material.SpecularChance = 1.0f;\n            HitInfo.Material.SpecularRoughness = 1.0f;\n            HitInfo.Material.SpecularColor = vec3(0.3f, 1.0f, 0.3f);\n        }           \n    }\n    \n    {\n        if(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(-8.0f, 6.0f, 20.0f, 2.5f)+SceneTranslation4))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(0.9f, 0.25f, 0.25f);\n            HitInfo.Material.SpecularChance = 0.02f;\n            HitInfo.Material.SpecularColor = vec3(0.8f, 0.8f, 0.8f);  \n            HitInfo.Material.IOR = 1.1f;\n            HitInfo.Material.RefractionChance = 1.0f;\n            HitInfo.Material.RefractionColor = vec3(0.0f, 0.2f, 0.6f);\n        } \n        \n        if(TestSphereRay(RayPosition, RayDir, HitInfo, vec4(3.0f, 1.5f, 14.0f, 2.0f)+SceneTranslation4))\n        {\n            HitInfo.Material = GetZeroedMaterial();\n            HitInfo.Material.Albedo = vec3(0.9f, 0.25f, 0.25f);\n            HitInfo.Material.SpecularChance = 0.02f;\n            HitInfo.Material.SpecularColor = vec3(0.8f, 0.8f, 0.8f);  \n            HitInfo.Material.IOR = 1.3f;\n            HitInfo.Material.RefractionChance = 1.0f;\n        }\n    }\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 Normal, vec3 Incident, float f0, float f90)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(Normal, Incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return f90;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    return mix(f0, f90, ret);\n}\n\nvec3 GetColorForRay(in vec3 StartRayPosition, in vec3 StartRayDir, inout uint RNGState)\n{\n    vec3 ResultColor = vec3(0.0f, 0.0f, 0.0f);\n    vec3 ThroughputColor = vec3(1.0f, 1.0f, 1.0f);\n    vec3 RayPosition = StartRayPosition;\n    vec3 RayDir = StartRayDir;\n    \n    for(int BounceIndex = 0; BounceIndex < NumBounces; BounceIndex++)\n    {\n        ray_hit_info HitInfo;\n        HitInfo.Material = GetZeroedMaterial();\n        HitInfo.t = MaxRayHitTime;\n        HitInfo.FromInside = false;\n\t\tTestSceneTrace(RayPosition, RayDir, HitInfo);\n        \n        if(HitInfo.t == MaxRayHitTime)\n        {\n         \tResultColor += 0.5f*SRGBToLinear(texture(iChannel1, RayDir).rgb) * ThroughputColor;\n            break;\n        }\n        \n        if(HitInfo.FromInside)\n        {\n            ThroughputColor *= exp(-HitInfo.Material.RefractionColor * HitInfo.t);\n        }\n                \n        float SpecularChance = HitInfo.Material.SpecularChance;\n        float RefractionChance = HitInfo.Material.RefractionChance;\n        \n        float RayProbability = 1.0f;\n        if(SpecularChance > 0.0f)\n        {\n            SpecularChance = FresnelReflectAmount(HitInfo.FromInside ? HitInfo.Material.IOR : 1.0,\n                                                  !HitInfo.FromInside ? HitInfo.Material.IOR : 1.0,\n                                                  RayDir, HitInfo.Normal,\n                                                  HitInfo.Material.SpecularChance, 1.0f);\n            \n            float ChanceMultiplier = (1.0f - SpecularChance) / (1.0f - HitInfo.Material.SpecularChance);\n\t\t\tRefractionChance *= ChanceMultiplier;\n        }\n        \n        float DoSpecular = 0.0f;\n        float DoRefraction = 0.0f;\n        float RaySelectRoll = RandomFloat01(RNGState);\n        if((SpecularChance > 0.0f) && (RaySelectRoll < SpecularChance))\n        {\n            DoSpecular = 1.0f;\n            RayProbability = SpecularChance;\n        }\n        else if((RefractionChance > 0.0f) && (RaySelectRoll < (SpecularChance + RefractionChance)))\n        {\n            DoRefraction = 1.0f;\n            RayProbability = RefractionChance;\n        }\n        else\n        {\n            RayProbability = 1.0f - (SpecularChance + RefractionChance);\n        }\n        \n\t\tRayProbability = max(RayProbability, 0.001f);\n        \n        if(DoRefraction == 1.0f)\n        {\n            RayPosition = (RayPosition + HitInfo.t*RayDir) - HitInfo.Normal*NormalNudge;\n        }\n        else\n        {\n            RayPosition = (RayPosition + HitInfo.t*RayDir) + HitInfo.Normal*NormalNudge;\n        }\n        \n        vec3 DiffuseRayDir = normalize(HitInfo.Normal + RandomUnitVector(RNGState));\n        \n        vec3 SpecularRayDir = reflect(RayDir, HitInfo.Normal);\n        SpecularRayDir = normalize(mix(SpecularRayDir, DiffuseRayDir, HitInfo.Material.SpecularRoughness*HitInfo.Material.SpecularRoughness));\n        \n        vec3 RefractionRayDir = refract(RayDir, HitInfo.Normal, HitInfo.FromInside ? HitInfo.Material.IOR : 1.0f / HitInfo.Material.IOR);\n        RefractionRayDir = normalize(mix(RefractionRayDir, normalize(-HitInfo.Normal + RandomUnitVector(RNGState)), HitInfo.Material.RefractionRoughness*HitInfo.Material.RefractionRoughness));\n        \n        RayDir = mix(DiffuseRayDir, SpecularRayDir, DoSpecular);\n        RayDir = mix(RayDir, RefractionRayDir, DoRefraction);\n        \n        ResultColor += HitInfo.Material.Emissive * ThroughputColor;\n        \n        if(DoRefraction == 0.0f)\n        \tThroughputColor *= mix(HitInfo.Material.Albedo, HitInfo.Material.SpecularColor, DoSpecular);\n        \n        ThroughputColor /= RayProbability;\n        {\n            float P = max(ThroughputColor.r, max(ThroughputColor.g, ThroughputColor.b));\n            if(RandomFloat01(RNGState) > P)\n                break;\n            \n            ThroughputColor *= 1.0f / P;\n        }\n    }\n    \n    return(ResultColor);\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord)\n{\n    uint RNGState = uint(uint(FragCoord.x) * uint(1973) + uint(FragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec3 RayPosition = vec3(0.0f, 0.0f, 0.0f);\n    float CameraDistance = 1.0f / tan(0.5f*FoVDegrees * PI / 180.0f);\n    \n    vec2 Jitter = vec2(RandomFloat01(RNGState), RandomFloat01(RNGState)) - vec2(0.5f, 0.5f);\n    vec3 RayTarget = vec3(2.0f*((FragCoord+Jitter)/iResolution.xy) - 1.0f, CameraDistance);\n    float AspectRatio = iResolution.x / iResolution.y;\n    RayTarget.y /= AspectRatio;\n    \n\tvec3 RayDir = normalize(RayTarget - RayPosition);\n    \n    // Raytrace for this pixel\n    vec3 Color = vec3(0.0f, 0.0f, 0.0f);\n\tfor(int Index = 0; Index < 3; Index++)\n    {\n     \tColor += GetColorForRay(RayPosition, RayDir, RNGState);   \n    }\n\tColor /= 3.0;    \n    \n    \n    vec3 LastFrameColor = texture(iChannel0, FragCoord / iResolution.xy).rgb;\n    Color = mix(LastFrameColor, Color, 1.0f / float(iFrame + 1));\n    \n    // Output to screen\n    FragColor = vec4(Color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 LessThan(vec3 V, float Value)\n{\n    vec3 Result = vec3((V.x < Value) ? 1.0f : 0.0f,\n                       (V.y < Value) ? 1.0f : 0.0f,\n                       (V.z < Value) ? 1.0f : 0.0f);\n   \treturn(Result);\n}\n\nvec3 LinearToSRGB(vec3 RGB)\n{\n    RGB = clamp(RGB, 0.0f, 1.0f);\n    \n    vec3 Result = mix(pow(RGB, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n                      RGB * 12.92f,\n                      LessThan(RGB, 0.0031308f));\n    return(Result);\n}\n\nvec3 SRGBToLinear(vec3 RGB)\n{\n    RGB = clamp(RGB, 0.0f, 1.0f);\n    \n    vec3 Result = mix(pow((RGB + 0.055f) / 1.055f, vec3(2.4f)),\n                      RGB / 12.92f,\n                      LessThan(RGB, 0.04045f));\n    return(Result);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 X)\n{\n    float A = 2.51f;\n    float B = 0.03f;\n    float C = 2.43f;\n    float D = 0.59f;\n    float E = 0.14f;\n    \n    vec3 Result = clamp((X*(A*X + B)) / (X*(C*X + D) + E), 0.0f, 1.0f);\n    return(Result);\n}","name":"Common","description":"","type":"common"}]}