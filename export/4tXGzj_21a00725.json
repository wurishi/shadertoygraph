{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// \"Planet K\" by Kali\n\nconst float Saturation= .9;\nconst float ColorDensity= 1.4;\nconst float ColorOffset= 0.1;\nconst vec3 Color1= vec3(1.,0.9,0.8);\nconst vec3 Color2= vec3(1.0,0.85,0.65)*.5;\nconst vec3 Color3= vec3(1.0,0.8,.7)*.4;\n\n#define PI  3.141592\n\nconst vec3 lightdir=-vec3(0.0,0.0,1.0);\n\nfloat colindex;\n\n// Fragmentarium's rotation matrix\nmat3 rotmat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n// Random number implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Formulas used for texture, coloring and stars\n// more info here:\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n\nfloat KalisetTexture(vec3 p) {\n\tvec3 pos=p;\n\tfloat l=1.;\n\tfloat ln=0.;\n\tfloat lnprev=0.;\n\tfloat expsmooth=0.;\n\tfor (int i=0; i<13; i++) {\n\t\tp.xyz=abs(p.xyz);\n\t\tp=p/dot(p,p);\n\t\tp=p*2.-vec3(1.);\n\t\tif (mod(float(i),2.)>0.) {\n\t\t\tlnprev=ln;\n\t\t\tln=length(p);\n\t\t\texpsmooth+=exp(-1./abs(lnprev-ln));\n\t\t}\n\t}\n\treturn expsmooth;\n}\n\nfloat KalisetStars(vec3 p) {\n\tvec3 pos=p;\n\tfloat l=1.;\n\tfloat ln=0.;\n\tfloat lnprev=0.;\n\tfloat expsmooth=0.;\n\tp+=vec3(1.35,1.54,1.23);\n\tp*=.3;\n\tfor (int i=0; i<18; i++) {\n\t\tp.xyz=abs(p.xyz);\n\t\tp=p/dot(p,p);\n\t\tp=p*1.-vec3(.9);\n\t}\n\treturn pow(length(p),1.5)*.04;\n}\n\n\n// Distance estimation for sphere with texture displacement\nfloat dsph (in vec4 sph, in vec3 p)\n{\n\t//p*=rotmat(normalize(vec3(0.,1.,0.)),iTime*.05);\n\tvec3 p2=p-sph.xyz;\n\tfloat d=length(p2)-sph.w;\n\tfloat tex=KalisetTexture(p2*.4+vec3(.14,.31,.51));\n\tcolindex=tex;\n\treturn d+tex*.006+.25;\n}\n\n// Intersection with sphere\nfloat isph (in vec4 sph, in vec3 p, in vec3 rd)\n{\n\tfloat t=999.,tnow,b,disc;\n    vec3 sd=sph.xyz-p;    \n    b = dot ( rd,sd );\n    disc = b*b + (sph.w*sph.w) - dot ( sd,sd );\n    if (disc>0.0) t = b - sqrt(disc);\n\treturn t;\n}\n\n// Finite difference normal\nvec3 normal(vec4 sph, vec3 p) {\n\tvec3 e = vec3(0.0,0.01,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tdsph(sph,p+e.yxx)-dsph(sph,p-e.yxx),\n\t\t\tdsph(sph,p+e.xyx)-dsph(sph,p-e.xyx),\n\t\t\tdsph(sph,p+e.xxy)-dsph(sph,p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\n// AO\nfloat AO(in vec4 sph, in vec3 p, in vec3 n) {\n\tfloat ao = 0.0;\n\tfloat de = dsph(sph,p);\n\tfloat wSum = 0.0;\n\tfloat w = 1.0;\n    float d = 1.0;\n\tfloat aodetail=.02;\n\tfor (float i =1.0; i <6.0; i++) {\n\t\tfloat D = (dsph(sph,p+ d*n*i*i*aodetail) -de)/(d*i*i*aodetail);\n\t\tw *= 0.6;\n\t\tao += w*clamp(1.0-D,0.0,1.0);\n\t\twSum += w;\n\t}\n\treturn clamp(.9*ao/wSum, 0.0, 1.0);\n}\n\n// Shadows\nfloat shadow(in vec4 sph, in vec3 p) \n{\n\tvec3 ldir=-normalize(lightdir);\n\tfloat totdist=0., detail=0.01;\n\tfloat sh=1.;\n\tfor (int i=0; i<50; i++){;\n\t\tfloat d=dsph(sph,p+totdist*ldir);\n\t\tif (d<detail) {sh=0.;continue;}\n\t\tif (totdist>sph.w) {sh=1.;continue;}\n\t\ttotdist+=d*.5;\t\n\t}\n\treturn clamp(sh,0.,1.);\n}\n\n\n// Get gradient from 3-color palette using a coloring index \nvec3 getcolor(float index) {\n\tfloat cx=index*ColorDensity+ColorOffset*PI*3.;\n\tvec3 col;\n\tfloat ps=PI/1.5;\n\tfloat f1=max(0.,sin(cx));\n\tfloat f2=max(0.,sin(cx+ps));\n\tfloat f3=max(0.,sin(cx+ps*2.));\n\tcol=mix(Color1,Color2,f1);\n\tcol=mix(col,mix(Color3,Color1,f3),f2);\n\tcol=mix(vec3(length(col)),col,Saturation);\n\treturn col;\n}\n\n// Ligthing - diffusse+specular+ambient\nvec3 light(in vec4 sph, in vec3 p, in vec3 dir) {\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(sph,p);\n\tfloat sh=shadow(sph,p);\n\tfloat diff=max(0.,dot(ldir,-n))*sh+.12;\n\t//diff*=(1.-AO(sph,p,n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r))*sh;\n\treturn vec3(diff*.7+pow(spec,6.)*0.6);\t\n\t\t}\n\n// Raymarching inside the planet's atmosphere :)\nvec3 march(in vec4 sph, in vec3 from, in vec3 dir) \n{\n\tfloat totdist=0., detail=0.01;\n\tvec3 col, p;\n\tfloat d;\n\tfor (int i=0; i<200; i++) {\n\t\tp=from+totdist*dir;\n\t\td=dsph(sph,p)*.4;\n\t\tif (d<detail || totdist>sph.w) break;\n\t\ttotdist+=d; \n\t}\n\tvec3 back=vec3(1.)*0.5;\n\tif (d<detail) {\n\t\tfloat cindex=colindex;\n\t\tcol=getcolor(cindex)*light(sph, p-detail*dir*10., dir); \n\t} else { \n\t\tcol=vec3(0.);\n\t}\n\treturn col;\n}\n\n// Main code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mouse=iMouse.xy/iResolution.xy-vec2(.5);\n\tmat3 camrot1;\n\tmat3 camrot2;\n\tfloat ang=iTime*.15+4.5;\n\tcamrot1=rotmat(vec3(0.,1.,0.),1.+mouse.x*PI*1.5+ang);\n\tcamrot2=rotmat(vec3(1.,0.,0.),1.-mouse.y*PI*1.5);\n\tmat3 camrot=camrot1*camrot2; // camera rotation\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv=uv*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(0.,0.,-8.)*camrot;\n\tvec3 dir=normalize(vec3(uv*.7,1.))*camrot;\n\tvec3 col=vec3(0.);\n\tvec4 sph=vec4(0.,0.,0.,2.8); // sphere position and size \n\t\t\t\t\t\t\t\t // (I leave the coordinate part for future use)\n\tfloat t=isph(sph,from,dir); // intersect with sphere\n\tif (t<999.) {;\n\t\tcol=march(sph,from+t*dir,dir); // raymarch a bit from there for the texture\n\t\t}\n\tfloat dirlen=length(dir.xy);\n\tvec3 suncol=vec3(1.,.9,.85)*(sign(dir.z)+1.)*.5; //I used sign to eliminate the twin sun\n\tfloat occult=min(pow(max(0.,length(from.xy)-sph.w*.92),0.6),.6); // light occulting factor\n\tfloat sundisc=-sign(dirlen-.02); // plain sun disc\n\tfloat sunbody=pow(smoothstep(.1+occult*.1,0.,dirlen),3.)*1.3; // outside glow\n\tfloat rayrad=pow(max(0.,1.-dirlen),4.); // rays length\n\tfloat sunrays=0.;\n\tvec3 rdir=dir*rotmat(vec3(0.,0.,1.),-length(from.xy)*.3);\n\tfor (float s=0.; s<3.; s++){ // get the rays, randomize a bit\n\t\tmat3 rayrot=rotmat(vec3(0.,0.,1.),PI/6.+rand(vec2((s+1.)*5.2165485))*.1);\n\t\tsunrays+=pow(max(0.,1.-abs(rdir.x)*2.-abs(rdir.y)*.05),100.)\n\t\t\t    *pow(rayrad,.2+rand(vec2((s+1.)*12.215685))*1.5)*.4;\n\t\trdir*=rayrot;\n\t\tsunrays+=pow(max(0.,1.-abs(rdir.x)*3.-abs(rdir.y)*.05),150.)\n\t\t\t    *pow(rayrad,.5+rand(vec2((s+1.)*46.243685))*5.)*.3;\n\t\trdir*=rayrot;\n\t}\n\tif (col==vec3(0.)) {// hit nothing\n\t\tcol+=vec3(max(0.,.5*KalisetStars(dir*10.)))*max(0.,1.-sunbody*2.5); //stars\n\t\tcol+=vec3(.95,.93,1.)*exp(-38.*pow(length(uv),3.5))*3.7 //atmosphere backlight glow\n\t\t\t*pow(max(0.,dot(normalize(lightdir),-dir)),3.);\n\t\t//lower the glow and rays when sun is partially hidden\n\t\tfloat sun=min(1.1,sunbody+sunrays*(occult+.2)); \n\t\tsun*=.8+min(.2,occult);\n\t\tcol+=suncol*max(sundisc,sun); // make sundisk visible when partial hidden\n\t} else { //hit planet\n\t\t\tcol+=suncol*sunrays*occult*.8; // rays over planet, based on hide ammount\n\t\t\tcol+=suncol*sunbody*smoothstep(0.435,1.,length(uv))*20.; //tiny bloom effect\n\t}\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tXGzj","date":"1423183906","viewed":1056,"name":"K-moon","username":"Kali","description":"Mouse enabled","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["moon"],"hasliked":0,"parentid":"","parentname":""}}