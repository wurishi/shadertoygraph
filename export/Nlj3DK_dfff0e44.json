{"ver":"0.1","info":{"id":"Nlj3DK","date":"1624746940","viewed":76,"name":"sunset over Arizona of my dreams","username":"visy","description":"Live coded on 26.6.2021 - 27.6.2021","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["liveshader","glacier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float time;\n\n#define NEAR_CLIPPING_PLANE 0.001\n#define FAR_CLIPPING_PLANE 1000.0\n#define NUMBER_OF_MARCH_STEPS 600\n#define EPSILON 0.15\n#define DISTANCE_BIAS 0.2\n\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - (s);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\nconst float kHashScale1 = 443.8975;\n\nfloat hash11(float p) {\n  vec3 p3 = fract(vec3(p) * kHashScale1);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n \nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nvec2 scene1(vec3 pos)\n{\n    vec3 translate = vec3(atan(pos.x*pos.y)*1., cos(pos.x*1.0+time*1.)*0.1, cos(cos(pos.z*0.1+pos.z*1.)+pos.x)*pos.y*cos(sin(time*0.1)*pos.z*0.05)*2.);\n\n    vec3 tra2 = vec3(fract(pos.y)+cos(pos.y*1.+sin(time*1.))*0.1,sin(fract(pos.z*0.5)*1.)*0.5,cos(pos.y+fract(abs(cos(pos.z*0.5))*time*1.+pos.x*3.1+pos.y)*0.1)*1.);\n  \n    vec3 opos = pos - translate + tra2;\n\n    float finalDist = sdSphere(cos(opos*0.3*fract(pos.y*0.01)),1.2+sin(cos(time*1.+pos.z)+pos.z*0.1+cos(opos.z*0.5)*opos.z*0.001)*0.1)*5.91;\n    \t\n    return vec2(finalDist, 0.0);\n}\n\n\nvec2 scene(vec3 pos) {\n    float mat = 0.0;\n\tvec2 res1 = scene1(pos);\n    mat = res1.y;\n\treturn vec2(res1.x,mat);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat err(float dist){ return min(EPSILON, pow(dist*0.02, 2.0)); }\n\nvec3 discontinuity_reduction(vec3 origin, vec3 direction, vec3 position){ for(int i = 0; i < 3; i++)position = position + direction * (scene(position).x - err(distance(origin, position))); return position; }\n\n\nvec3 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    float acc = 0.0;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 pos = position + direction * total_distance;\n        //pos = discontinuity_reduction(position,direction,pos);\n        vec2 result = scene(pos);\n\n        if(result.x < EPSILON)\n        {\n            return vec3(total_distance, acc,result.y);\n        }\n        \n        total_distance += result.x * DISTANCE_BIAS;\n        \n        \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    return vec3(FAR_CLIPPING_PLANE, acc, 0.0);\n}\n\nvec3 normal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.1, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159;\n}\n\n\n\nvec4 plas( vec2 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n\treturn vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (-iResolution.xy + 2.0*(fragCoord.xy))/iResolution.y;\n\n  \n    time = fmod(iTime,120.0);\n\n    vec3 direction = normalize(vec3(uv, 0.0));\n    float cx = 0.0;\n    float cy = 0.0;\n    float cz = time*6.9;\n    \n    vec3 camera_origin = vec3(cx, cy, cz);\n    vec3 lookAt = vec3(cx,cy,cz+0.1);\n    \n    vec3 forward = normalize(lookAt-camera_origin);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n\n    float FOV = 1.;\n\n    vec3 ro = camera_origin;\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    vec3 result = raymarch(ro, rd);\n            \n    float fog = pow(1.0 / (1.0 + result.x), 0.2);\n    \n    vec3 materialColor = vec3(1.0-result.x*0.01, result.x*0.2*cos(uv.x*uv.y*3.), result.x*0.01);\n\t\t\n    if (uv.y > 0.0) {\n      materialColor.r -= 0.5;\n      materialColor.g -= 0.5;\n      materialColor.b -= 0.4;\n    }\n\n    vec3 intersection = ro + rd*result.x;\n    \n    vec3 nrml = normal(intersection);\n    float occ = calcAO( intersection, nrml );\n    vec3 light_dir = normalize(vec3(10.0,0.,-2));\n    vec3 ref = reflect( rd, nrml );\n    float dom = smoothstep( -0.1, 0.8, ref.y);\n    float spe = pow(clamp( dot( ref, light_dir ), 0.0, 0.3 ),32.0);\n\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,0.4,0.9);\n    \n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    vec3 ambient_color = vec3(1.0,1.0, 1.0);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    vec3 outColor = diffuseLit*occ*fog+dom*0.3+spe*0.3;\n    if (result.x >= FAR_CLIPPING_PLANE) outColor = vec3(1.0);\n    \n    fragColor = vec4(1.3-outColor.r*0.8,0.8-outColor.b*0.8,1.7-outColor.g*0.4, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}