{"ver":"0.1","info":{"id":"ws2SRz","date":"1553149869","viewed":94,"name":"Sea Turtle","username":"cx","description":"Creating a sea turtle","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["turtle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ray marching\n#define MAX_STEPS 1000\n#define SURFACE_DIST 0.01\n#define MAX_DIST 100.\n\n//math constants\n#define PI 3.14159\n\n//colors\nvec3 darkblue = vec3(0.18,0.43,.59);\nvec3 shellgreen = vec3(114./255.,132./255.,106./255.);\nvec3 shelldarkgreen = vec3(48./255.,63./255.,0.2);\nvec3 finngreen = vec3(.36, .37, .29);\nvec3 beige = vec3(0.79,0.78,0.62);\nvec3 lightyellow = vec3(0.94,0.89,0.69);\n\n//parts\nfloat ibody, ilegs, ihead, ieyes, ieyesockets, imouth;\n\n//helpers\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 align(vec3 fw, vec3 up) {\n  fw = normalize(fw);\n  vec3 rt = normalize(cross(fw, normalize(up)));\n  return mat3(rt, cross(rt, fw), fw);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h)-k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(a-b)/k, 0.0, 1.0);\n  return mix(b, a, h)-k*h*(1.0-h);\n}\n\n\n//primative distance functions\nfloat dCap(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    float t = dot(p-a, ab)/dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = t*(ab) + a;\n    return length(p-c) - r;\n}\n\nfloat dS(vec3 p, vec3 s, float r) {\n    return length(p - s) - r;\n}\n\nfloat dRCone( vec3 p, float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n//turtle distance functions\nfloat dShell(vec3 p) {\n    p.xy *= rot(2.);\n    float s = dS(p, vec3(-2.75, -3., 0), 4.);\n    float c = dCap(p, vec3(0, 0, 0), vec3(1, -0.5, 0), .75);\n    float shell = smax(s, c, 0.075);\n    return shell;\n}\n\nfloat dEyes(vec3 p) {\n    p += vec3(-1, -.55, 0.);\n    p.xy *= rot(-2.25);\n    p.xz *= rot(PI);\n    float es1 = dS(p, vec3(-0.1, 0.1, -0.2), .1);\n    float e1 = dS(p, vec3(-0.1, 0.1, -0.15), .05);\n    \n    float es2 = dS(p, vec3(-0.1, 0.1, 0.2), .1);\n    float e2 = dS(p, vec3(-0.1, 0.1, 0.15), .05);\n    \n    float eyesockets = min(es1, es2);\n    float eyes = min(e1, e2);\n    \n    float eyestot = max(-eyes, eyesockets);\n    \n    if (eyes < MAX_DIST/2.) {\n        ieyes = 1. - step(0.001, abs(eyestot+eyes));\n        ieyesockets = 1. - step(.0001, abs(eyestot-eyesockets));\n    }   \n    return eyestot;\n}\n\nfloat dHead(vec3 p) {\n    p += vec3(-1, -.55, 0.);\n    p.xy *= rot(-2.25);\n    p.xz *= rot(PI);\n    float s = dS(p, vec3(-3.75, -1.2, 0), 4.);\n    float c = dRCone(p, 0.25, 0.10, 1.);\n    float topHead = smax(s, c, .01);\n\n    p.xy *= rot(-.5);\n    p+= vec3(-0.075, -0.15, 0.);\n    float breathe = (sin(iTime*1.)/20.);\n    float belowHead = dRCone(p, 0.15+breathe, 0.10, .5);\n\n    float head = smin(topHead, belowHead, 0.2);\n    return head;\n}\n\nfloat dFinns(vec3 p) {\n    p += vec3(-0.5,-0.3,0);\n    p.xy *= rot(1.75);\n    vec3 lp = p;\n    vec3 rp = p;\n    lp.z += .4;\n    rp.z -= .4;\n    float move = (sin(iTime*1.)/10.-0.05);\n    float mover = (cos(iTime*1.)/10.-0.05);\n    lp.yz *= rot(1.+move*2.);\n    rp.yz *= rot(-1.-move*2.);\n    lp.xy *= rot(move*2.+.25);\n    rp.xy *= rot(mover*2.);\n    lp.xz *= rot(-1.);\n    rp.xz *= rot(1.);\n    \n    float lupper = dRCone(lp, 0.15, 0.15, .25);\n    float rupper = dRCone(rp, 0.15, 0.15, .25);\n\n    lp.y -= 0.3;\n    rp.y -= 0.3;\n    lp.yz *= rot(1.);\n    rp.yz *= rot(-1.);\n    lp.xy *= rot(move*3.-.25);\n    rp.xy *= rot(mover*3.-.25);\n    float llower = dRCone(lp, 0.15, 0.05, .6);\n    float rlower = dRCone(rp, 0.15, 0.05, .6);\n    \n    float lfinn = smin(lupper, llower, 0.1);\n    float rfinn = smin(rupper, rlower, 0.1);\n    \n    float upperfinns = min(lfinn, rfinn);\n    \n    p += vec3(-.85,1.5,0);\n    p.xy *= rot(2.);\n    lp = p;\n    rp = p;\n    lp.z += .4;\n    rp.z -= .4;\n    lp.yz *= rot(.5 + move);\n    rp.yz *= rot(-.5 -move);\n    lp.xy *= rot(-move*1.5);\n    rp.xy *= rot(-move);\n    \n    float lback = dRCone(lp, 0.075, 0.125, .3);\n    float rback = dRCone(rp, 0.075, 0.125, .3);\n    float lowerfinns = min(lback, rback);\n    \n    return min(upperfinns, lowerfinns);\n}\n\nfloat getDist(vec3 p) {\n    ibody = 0.;\n    ihead = 0.;\n    ilegs = 0.;\n    ieyes = 0.;\n    ieyesockets = 0.;\n    \n    //shapes\n    float shell = dShell(p);\n    float head = dHead(p);\n    float eyes = dEyes(p);\n    float finn = dFinns(p);\n    float res = min(head, shell);\n    res = smax(res, -eyes, 0.0);\n    res = smin(res, finn, 0.1);\n\n    //which turtle part is hit\n    if (res < MAX_DIST - 10.) {\n        ibody = 1. - step(0.02, abs(res-shell));\n        ihead = 1. - step(.001, abs(res-head));\n        ilegs = 1. - step(.15, abs(res-finn));\n    }\n\n    return res;\n}\n\n\n\n//generative patterns\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n        dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat voronoi(vec2 st) {\n    \n    float color = .0;\n\n    // Scale\n    st *= 3.5;\n\n    // Tile the space\n    vec2 i_st = mod(floor(st), 10.);\n    vec2 f_st = mod(fract(st), 10.);\n\n\n    float m_dist = 50.;  // minimun distance\n    vec2 m_point;        // minimum point\n\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = random2(i_st + neighbor);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n            if( dist < m_dist ) {\n                m_dist = dist;\n                m_point = point;\n            }\n        }\n    }\n\n    // Assign a color using the closest point position\n    color += dot(m_point,vec2(.9,.9));\n    return color;\n}\n\n//voronoi with boundaries\nvec3 bvoronoi(vec2 st) {\n    st *= 2.5;\n    vec2 n = floor(st);\n    vec2 f = fract(st);\n\n    // voronoi\n    vec2 mg, mr;\n    float md = 8.0;\n    for (int j= -1; j <= 1; j++) {\n        for (int i= -1; i <= 1; i++) {\n            vec2 g = vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin( 6.2831*o );\n            vec2 r = g + o - f;\n            float d = dot(r,r);\n            if( d<md ) {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n\n    // distance to borders\n    md = 8.0;\n    for (int j= -2; j <= 2; j++) {\n        for (int i= -2; i <= 2; i++) {\n            vec2 g = mg + vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin(6.2831*o );\n            vec2 r = g + o - f;\n            if (dot(mr-r,mr-r)>0.00001) {\n                md = min(md, dot( 0.5*(mr+r), normalize(r-mr) ));\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\n\nvec3 getColor(vec3 p, vec3 n) {\n    vec3 col = vec3(0);\n    if (ihead > 0.) {\n        col += beige;\n        if (n.x >0.15 && n.y>-0.1) {\n            col = lightyellow;\n        } else if (n.y >0.25 && n.x <0.) {\n            //top of head pattern\n            vec2 st = vec2(n.x+p.x, n.y+p.y);\n            vec3 c = bvoronoi(st);\n            col = mix( beige, finngreen*1.2, smoothstep( 0.07, 0.08, c.x ) );\n        }\n    } else if (ibody > 0.){\n        vec2 st = vec2(n.x+p.x, n.y+p.y);\n        if (n.y > 0.) {\n            //top of shell\n            col += mix( shelldarkgreen*0.5, lightyellow*shellgreen, voronoi(st));\n        } else {\n            //bottom of shell\n            col += mix( shellgreen, lightyellow, voronoi(st));\n        }\n    } else if (ieyes > 0.) {\n        col = vec3(0);\n    } else if (ilegs>0.) {\n        col += beige;\n        if (n.y >0.25) {\n            //top of legs\n            vec2 st = vec2(n.x/2.+p.x*3., n.y/2.+p.y*3.);\n            vec3 c = bvoronoi(st);\n            col = mix( lightyellow, finngreen*1.2, smoothstep( 0.05, 0.06, c.x ) );\n        }\n    } else if (ieyesockets > 0.) {\n        col += mix(shellgreen, beige, 0.3);\n    }  else {\n        //background water\n        col = darkblue*1.5;\n    }\n    return col;\n    \n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0.);\n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    return normalize(n);\n}\n\n\nfloat getLight(vec3 p, vec3 lightPos, vec3 n, float sh) {\n    float dif = clamp(dot(lightPos,n), 0.0, .50);\n    vec3 hal = normalize(lightPos - p);\n    float spe = pow(clamp(dot(hal,n), 0.0, 1.0 ), 50.);\n    return pow((dif+spe*.25)*sh, 2.);\n}\n\n\nfloat shadow(vec3 p, vec3 dir) {\n  float sh = 1.0;\n  float t = .001;\n  float d = 10.;\n  for (int i=0; i<10; i++) {\n      vec3 pos = p+t*dir;\n      d = getDist(pos);\n      sh = min(sh, 1.*d/t);\n      t += d;\n  }\n  return clamp(sh, 0.0, 1.0);\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + dO * rd;\n        float dS = getDist(p);\n        dO += dS;\n        if (dS<SURFACE_DIST || dO>MAX_DIST) break;\n    }\n    vec3 p = ro+rd*dO;\n    vec3 n = getNormal(p);\n    vec3 col = getColor(p, n);\n    vec3 light = vec3(0, 15, 0);\n    float sh = shadow(p, light);\n    col += getLight(p, light, n, sh);\n    return col/1.25;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -4);  \n    vec3 rd = normalize(vec3(uv.x , uv.y, 1));\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    mat2 mx = rot(m.x*8.5);\n    mat2 my = rot(m.y*7.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    ro.xz *= rot(sin(iTime/15.)); \n    rd.xz *= rot(sin(iTime/15.));\n    ro.xy *= rot(-sin(iTime/30.)); \n    rd.xy *= rot(-sin(iTime/30.));\n    \n    vec3 d = rayMarch(ro, rd);\n    vec3 col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}