{"ver":"0.1","info":{"id":"dtX3zl","date":"1672224856","viewed":1234,"name":"Magic forest","username":"Alpaga","description":"Change view with mouse.","likes":78,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow","forest","mushroom","fireflies"],"hasliked":0,"parentid":"clX3RX","parentname":"Dark forest"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* The lighting is only obtained using glow: mushrooms and fireflies colors\n * are accumulated along the ray, with intensity depending on the distance\n * of the ray point to the closest mushroom and firefly.\n * There is no light source, no diffuse or specular lighting, no normal calculation.\n *\n * This simple glow effect still allows tree barks to be visible. The barks are\n * obtained as often by adding some noise to the sdf. The usual way I know of \n * adding a 2d noise to the surface of a 3d object, or applying a 2d texture\n * to the surface of a 3d object, is to use triplanar or box mapping (see iq:\n * https://www.shadertoy.com/view/MtsGWH). However, here I naively apply a 2d noise\n * depending on the xy coordinates. It results in a constant noise along a z line,\n * producing interesting wood knots.\n *\n * The branches are obtained by thickening the intersection of two gyroidish surfaces.\n */\n\nconst float pi = 3.114159;\n\n//#define AA\n\n#define STEPS 1000\n#define FAR 50.0\n\nconst float fov = 35.0;\n\nconst int FLOOR = 0;\nconst int TREES = 1;\nconst int LEAVES = 2;\nconst int MUSHROOMS = 3;\nconst int FLIES = 4;\n\nfloat time;\n\n/*** TREES ***/\n// Closest tree coordinates in .xy channels, radius in .z channel\nvec3 closestTree(vec2 p) {\n    p.x = p.x > 0. ? max(p.x,2.5) : min(p.x,-2.5);\n    p = 2.*round(.5*p);\n    // Radius\n    float r = .1+.3*hash12(p);\n    p += hash22(p)-.5;\n    return vec3(p,r);\n}\n// Branches\n// Intersection of two gyroidish surfaces, thickened\nfloat sdBranches(vec3 p) {\n    p.y += .3;\n    float d = length(vec2(\n        abs(.1*dot(sin(4.*p),cos(4.*p.yzx))),\n        abs(.1*dot(sin(4.8*p),cos(4.*p)))));\n    d += .05*(2.-p.y)-.012;\n    return d;\n}\n\n// Trunks\nfloat sdTrees(vec3 p) {\n    vec3 c = closestTree(p.xz);\n    float r = c.z;\n    r += .01*(sin(5.*p.y+c.x)+cos(7.8*p.y+c.y));\n    r += .02*p.y*p.y*p.y;\n    c.xy += .05*(sin(3.*p.y+c.y)+cos(4.7*p.y-c.x));\n    float t = .5*min(length(p.xz-c.xy)-r+.03*noise12(vec2(60,20)*p.xy),.7);\n    return t;\n    float b = sdBranches(p);\n\n    return min(t,b);\n}\n\n/*** FIREFLIES ***/\n// Grid of fireflies, rotated, translated and randomly perturbed\n// j can take values 0 or 1, yielding two different grids\nfloat sdFlies(vec3 p, float j) {\n    vec3 c;\n    const mat2 m = mat2(.8,.6,-.6,.8);\n    vec2 shift = .3*mix(vec2(.5,-1.8),vec2(-.3,-.4),j)*time;\n    vec2 id = floor(m*(p.xz-shift)); \n    c.xz = mat2(.8,-.6,.6,.8)*(id+.5)+shift;\n    c.y = .5+hash12(id+123.4)+.2*noise12(id,time);\n    return length(p-c)-.01;\n}\nfloat sdFlies(vec3 p) {\n    // Two grids of fireflies moving in different directions\n    return min(sdFlies(.5*p,0.),sdFlies(.45*p,1.));\n}\n// The same functions, also providing the closst firefly's color\nfloat sdFlies(vec3 p, float j, out vec3 color) {\n    vec3 c;\n    const mat2 m = mat2(.8,.6,-.6,.8);\n    vec2 shift = .3*mix(vec2(.5,-1.8),vec2(-.3,-.4),j)*time;\n    vec2 id = floor(m*(p.xz-shift)); \n    color = vec3(1,.5,.2)+.4*hash32(id)-.2;\n    c.xz = mat2(.8,-.6,.6,.8)*(id+.5)+shift;\n    c.y = .5+hash12(id+123.4)+.2*noise12(id,time);\n    return length(p-c)-.01;\n}\nfloat sdFlies(vec3 p, out vec3 color) {\n    vec3 c1,c2;\n    float d1 = sdFlies(.5*p,0.,c1);\n    float d2 = sdFlies(.45*p,1.,c2);\n    color = d1<d2 ? c1 : c2;\n    return min(d1,d2);\n}\n\n/*** FLOOR ***/\nfloat floorHeight(vec2 p) {\n    vec3 c = closestTree(p);\n    p -= c.xy;\n    // Elevation at tree positions\n    return .3*exp(-.1*dot(p,p)/(c.z*c.z));\n}\nfloat sdFloor(vec3 p) {\n    return p.y-floorHeight(p.xz);\n}\n\n\n/*** MUSHROOMS ***/\nvec3 closestMushroom(vec3 p) {\n    vec3 c = p;\n    float shift = c.x > 0. ? 1.5 : -1.5;\n    c.x = c.x > 0. ? max(c.x-shift,0.) : min(c.x-shift,0.);\n    c.xz = 2.*round(.5*c.xz);\n    c.x += shift;\n    c.xz += hash22(c.xz)-.5;\n    c.y = floorHeight(p.xz);\n    return c;\n}\nfloat sdMushrooms(vec3 p) {\n    p -= closestMushroom(p);\n    p.y *= .5;\n    \n    float head = max(length(p)-.2,.1-p.y);\n    float r = .02+.02*sin(20.*p.y);\n    float foot = max(length(p.xz)-r,p.y-.11);\n    return min(foot,head);\n}\n\n// The same functions, also providing the closest mushroom's color\nvec3 closestMushroom(vec3 p, out vec3 color) {\n    vec3 c = p;\n    float shift = c.x > 0. ? 1.5 : -1.5;\n    c.x = c.x > 0. ? max(c.x-shift,0.) : min(c.x-shift,0.);\n    c.xz = 2.*round(.5*c.xz);\n    c.x += shift;\n    color = vec3(.7,.8,.9)+vec3(.1,.2,.1)*(2.*hash32(c.xz)-1.);\n    c.xz += hash22(c.xz)-.5;\n    c.y = floorHeight(p.xz);\n    return c;\n}\nfloat sdMushrooms(vec3 p, out vec3 color) {\n    p -= closestMushroom(p, color);\n    p.y *= .5;\n    \n    float head = max(length(p)-.2,.1-p.y);\n    float r = .02+.02*sin(20.*p.y);\n    float foot = max(length(p.xz)-r,p.y-.11);\n    return min(foot,head);\n}\n\n\n\nfloat sd(vec3 p, out int id) {\n    float d, minD = 1e6;\n    vec2 pos, dir;\n    \n    // Floor\n    d = sdFloor(p);\n    if(d<minD) {\n        id = FLOOR;\n        minD = d;\n    }\n\n    d = sdTrees(p);\n    if(d<minD) {\n        id = TREES;\n        minD = d;\n    }\n\n    d = sdBranches(p);\n    if(d<minD) {\n        id = LEAVES;\n        minD = d;\n    }\n    d = sdMushrooms(p);\n    if(d<minD) {\n        id = MUSHROOMS;\n        minD = d;\n    }\n    d = sdFlies(p);\n    if(d<minD) {\n        id = FLIES;\n        minD = d;\n    }\n    return minD;\n}\n\nfloat march(vec3 start, vec3 dir, out int id, out vec3 glow) {\n\tfloat total = 0., d;\n    float epsilon = 0.2/iResolution.y;\n    int i=0;\n    glow = vec3(0);\n    vec3 color;\n    for(; i<STEPS; i++) {\n        vec3 p = start + total*dir; \n        d = sd(p,id);\n        if(d<epsilon*total || total>FAR) break;\n        float dm = sdMushrooms(p,color);\n        glow += color*exp(-10.*dm);//1./(1.+500.*dm*dm);\n        dm = sdFlies(p,color);\n        glow += color*exp(-18.*dm);\n        total += d;\n    }\n    if(total>FAR || i==STEPS) id = -100;\n    return total;\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    int id;\n    vec3 glow;\n    \n    float d = march(start, dir, id, glow);\n    vec3 color = .1*glow;\n    \n    vec3 p = start + d * dir;\n    vec3 c;\n    \n    if(id==MUSHROOMS) {\n        closestMushroom(p,c);\n        color += c;\n    } else if(id==FLIES) {\n        sdFlies(p,c);\n       color += c;\n    }\n    return mix(vec3(.01,.1,.3),color,exp(-.05*d));\n}\n\nmat3 setupCamera(vec3 forward, vec3 up) {\n \tvec3 w = -normalize(forward);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = iTime;\n    vec3 forward = vec3(0,0,-1);\n    vec3 cam = vec3(0,1,-.5*time);\n    cam.y += .02*pow(abs(cos(4.*time)),3.);\n\n    if(iMouse.z>0.0) {\n        float a = pi*(2.*iMouse.x/iResolution.x-1.);\n        float b = .5*pi*(-.2+1.2*iMouse.y/iResolution.y);\n        forward = vec3(sin(a)*cos(b),sin(b),-cos(a)*cos(b));\n    }\n    \n    mat3 m = setupCamera(forward, vec3(0,1,0));\n    \n    vec3 color = vec3(0.0);\n\n    vec2 uv;\n    #ifdef AA\n    for(float i=-0.25; i<0.5; i+=0.5) {\n        for(float j=-0.25; j<0.5; j+=0.5) {\n            uv = 2.0*(fragCoord + vec2(i,j) - 0.5 * iResolution.xy)/iResolution.y;\n            vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    \n            vec3 dir = normalize(m*pix);\n            // To avoid banding artifacts\n            cam += .5*hash12(fragCoord)*dir;\n    \n            color += rayColor(cam, dir);\n        }\n    }\n    color /= 4.0;\n    #else\n    uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    // To avoid banding artifacts\n    cam += .5*hash12(fragCoord)*dir;\n    \n    color = rayColor(cam, dir);\n    #endif\n     \n    // Gamma\n    color = sqrt(color);\n    \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1. - uv.yx;\n    color *= pow(uv.x*uv.y * 15.0, 0.25);\n        \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash function from Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nfloat noise12(vec2 p) {\n    vec2 fl = floor(p);\n    vec2 fr = fract(p);\n    fr = fr*fr*(3.-2.*fr);\n    return mix(\n        mix(hash12(fl),hash12(fl+vec2(1,0)),fr.x),\n        mix(hash12(fl+vec2(0,1)),hash12(fl+vec2(1,1)),fr.x),fr.y);\n}\nfloat noise13(vec3 p) {\n    const vec2 u = vec2(1,0);\n    vec3 q = floor(p);\n    vec3 r = fract(p);\n    return mix(\n            mix(\n                mix(hash13(q+u.yyy),hash13(q+u.xyy),r.x),\n                mix(hash13(q+u.yxy),hash13(q+u.xxy),r.x),\n                r.y),\n            mix(mix(hash13(q+u.yyx),hash13(q+u.xyx),r.x),\n                mix(hash13(q+u.yxx),hash13(q+u.xxx),r.x),\n                r.y),r.z);\n}\n// Noise varying continuously with time\nfloat noise12(vec2 id, float t) {\n    vec2 h = hash22(id);\n    t = 3.*h.y*t+h.x;\n    \n    vec3 q = vec3(id,t);\n    return noise13(q);\n}","name":"Common","description":"","type":"common"}]}