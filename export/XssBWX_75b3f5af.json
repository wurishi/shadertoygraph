{"ver":"0.1","info":{"id":"XssBWX","date":"1498560410","viewed":478,"name":"Convergence","username":"kig","description":"Progressive path tracing with convergence heuristic to avoid retracing converged pixels and to spend more time on non-converged ones.\n\n","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","hack","progressive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nTrying to cast only rays that are important for the image.\nBecause hey realtime would be nice?\n\nQuadrants:\n+--------------+---------------+\n| convergence  | convergence   |\n| max 4 rays   | center ray    |\n| per pass     | importance++  |\n+--------------+---------------+\n| ground truth | \"real-time\"   |\n| max 16 rays  | max 2 rays    |\n| per pass     | per pass      |\n+--------------+---------------+\n\nThe purple haze is number of rays cast, it fades out at ray 1000\nor disappears when convergence heuristic is hit \n(3x3 neighborhood are all within 6/256 of center pixel).\n\nThe squares in the middle tell how many rays/px the image in \nthe quadrant took to render (based on a 100x100 sample grid). \nGreen is 0 rays, blue is 500, red is 1000.\n\nThis thing progressively renders for 60 frames, then waits for 240 frames.\nThe bottom-left is the highest quality image, but uses around 1000 rays per pixel. \nBottom-right is similarly uniform, uses 180 rays/px, worst quality.\nThe top two are around 180 rays/px, usually a bit less, sometimes a bit more.\nSimilar cost to bottom-right but hopefully closer to bottom-left in quality.\n*/\n\n#define VISUALIZE_CONVERGENCE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 accum = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float rayNumber = accum.a;\n    fragColor = accum / abs(accum.a);\n    fragColor.rgb = 1.0 - exp(-fragColor.rgb * 1.5);\n    #ifdef VISUALIZE_CONVERGENCE\n    if (rayNumber >= 0.0 && mod(floor(float(iFrame/300)), 2.0) == 1.0) {\n    \tfragColor += (1.0 - rayNumber / 1000.0) * vec4(0.5, 0.1, 0.8, 0.0);\n    }\n    #endif\n    vec2 uv = fragCoord - (iResolution.xy / 2.0);\n    if (all(lessThan(abs(uv), vec2(10.0)))) {\n        fragColor = texelFetch(iChannel1, ivec2(sign(uv)+1.0/2.0), 0);\n        float raySum = fragColor.r;\n        fragColor = vec4((fragColor.r-500.0) / 500.0, 1.0-(fragColor.r / 500.0), 1.0-abs((fragColor.r-500.0)/500.0), 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define THRESHOLD 0.003\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 800\n\n\n#define MAX_SAMPLES (fragCoord.x < iResolution.x/2.0 ? (fragCoord.y < iResolution.y/2.0 ? 16.0 : 4.0) : (fragCoord.y < iResolution.y/2.0 ? 2.0 : ((12.0*(max(0.17, 1.-length(uv))) + 0.3*sqrt(10.0-convergeCount)))))\n//(max(4.0, 8.0*maxDiffuseSum))\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat scene(vec3 p)\n{\n\tfloat cube = length(max(abs(p) - vec3(0.95), 0.0)) - 0.05;\n\tfloat s1 = length(p+vec3(-1.0, -0.5, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(1.15, 1.15, 1.15)) - 0.75;\n\tfloat s3 = length(max(abs(p+vec3(-2.5, 0.0, 0.2)) - vec3(0.05, 2.95, 2.25), 0.0));\n\tfloat s4 = length(max(abs(p+vec3(0.0, 0.0, 2.5)) - vec3(2.5, 2.95, 0.05), 0.0));\n\ts4 = min(s4, length(max(abs(p+vec3(-2.0, 2.0, 0.5)) - vec3(1.75, 0.05, 1.05), 0.0)));\n\treturn min( min( min( min(cube, s1), s2 ), s3 ), s4);\n}\n\nmat material(vec3 p)\n{\n\t//float cube = length(max(abs(p) - vec3(0.95), 0.0)) - 0.05;\n\tfloat s1 = length(p+vec3(-1.0, -0.5, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(1.15, 1.15, 1.15)) - 0.75;\n\tfloat s5 = length(max(abs(p+vec3(-1.0, 1.5, 1.2)) - vec3(1.0, 0.05, 1.65), 0.0));\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\n\tm.diffuse = 0.0;\n/*\tif (cube < s1 && cube < s2 && cube < s5) {\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.6;\n\t} else */\n\t\tif (s1 < s2 && s1 < s5) {\n\t\tm.transmit = vec3(0.9, 0.9, 0.9);\n\t\tm.diffuse = 0.15;\n\t} else if (s2 < s5) {\n\t\tm.transmit = vec3(0.1);\n\t\tm.diffuse = 0.8;\n\t} else {\n\t\tm.transmit = vec3(0.1, 0.9, 0.5);\n\t\tm.diffuse = 0.8;\n\t\tm.emit = vec3(0.2);\n\t}\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, float t)\n{\n    vec3 lightPos_ = vec3(\n        -cos(t)*-8.5, \n        sin(t)*3.0 - 4.0, \n        -(sin(t)*4.0)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\tvec3 bgCol = vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);\n\tbgCol += bgDiff*vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nfloat shade(inout ray r, vec3 nml, float d)\n{\n\tmat m = material(r.p);\n\tr.light += m.emit * r.transmit;\n\tr.transmit *= m.transmit;\n\treturn m.diffuse;\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvoid offset(inout vec3 nml, float k, float count, float diffuse) {\n\tvec3  uu  = normalize( cross( nml, vec3(0.01,1.0,1.0) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n\tvec2  aa = hash2( count );\n\tfloat ra = sqrt(aa.y);\n\tfloat rx = ra*cos(6.2831*aa.x); \n\tfloat ry = ra*sin(6.2831*aa.x);\n\tfloat rz = sqrt( sqrt(k)*(1.0-aa.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n\tnml = normalize(mix(nml, rr, diffuse));\n}\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nray setupRay(vec2 uv, float k, float t) {\n\n\tmat3 rot = rotationXY( vec2( t*0.503, t*0.602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(uv*-1.0, -7.0);\n\tr.d = rot * normalize(vec3(uv, 1.0));\n\n\treturn r;\n}\n\nvec3 trace(vec2 fragCoord, vec2 uv, vec2 uvD, inout float rayNumber, float convergeCount)\n{\t\n\tvec3 accum = vec3(0.0);\n    \n    float k = 0.0;\n\n    vec2 rc = fragCoord + (5.0+mod(iTime, 1.73728))*vec2(rayNumber*37.0, rayNumber*63.0);\n    vec4 rand = texelFetch(iChannel0, ivec2(mod(rc+k/4.0, vec2(256.0))), 0);\n\n    float time = 64.0 + floor(float(iFrame)/300.0);\n    float shutterSpeed = 1.0;\n    \n    float t = time + shutterSpeed*rand.x;\n\t\n\tray r = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k+rayNumber, t);\n    \n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (k > MAX_SAMPLES) break;\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n\t\t\tfloat diffuse = shade(r, nml, dist);\n\t\t\toffset(r.d, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), diffuse*0.5);\n\t\t\tr.d = reflect(r.d, nml);\n\t\t\tr.p += 4.0*THRESHOLD * r.d;\n            rand = rand.yzwx;\n\t\t\t\n\t\t\tif (dot(r.transmit, sun) < 1.0) {\n\t\t\t\t// if even the brightest light in the scene can't\n\t\t\t\t// make the ray brighter, let's bail.\n\t\t\t\taccum += r.light;\n\t\t\t\tk++;\n                if (mod(k, 4.0) == 0.0) {\n                    rand = texelFetch(iChannel0, ivec2(mod(rc+vec2(rayNumber*37.0, rayNumber*63.0)*k/4.0, vec2(256.0))), 0);\n                }\n\t\t\t    t = time + shutterSpeed*rand.x;\n\t\t\t\tr = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k, t);\n\t\t\t}\t\t\t\n\t\t} else if (dist > MAX_DISTANCE) {\n\t\t\tvec3 bg = shadeBg(-r.d, t);\n\t\t\taccum += r.light + r.transmit * bg;\n\t\t\tk++;\n            if (mod(k, 4.0) == 0.0) {\n                rand = texelFetch(iChannel0, ivec2(mod(rc+vec2(rayNumber*37.0, rayNumber*63.0)*k/4.0, vec2(256.0))), 0);\n            }\n            t = time + shutterSpeed*rand.x;\n\t\t\tr = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k, t);\t\t\t\n\t\t}\n\t}\n    if (k == 0.0) {\n        accum += r.light;\n        k++;\n    }\n\trayNumber += k;\n\treturn accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (mod(float(iFrame), 300.0) == 0.0) {\n    \tfragColor = vec4(0);\n        return;\n    }\n\n    vec4 color = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float rayNumber = color.a;\n\n    if (rayNumber < 0.0 || mod(float(iFrame), 300.0) > 60.0) {\n        fragColor = color;\n        return;\n    }\n    \n    vec3 c = color.rgb / abs(color.a);\n\n    bool converged = rayNumber > 4.0;\n    float convergeCount = 0.0;\n\n    if (fragCoord.y < iResolution.y/2.0) {\n    \tconverged = false;\n        convergeCount = 1.0;\n    } else {\n        for (int x=-1; x<=1; x++) {\n            for (int y=-1;y<=1; y++) {\n                vec4 t = texelFetch(iChannel1, ivec2(fragCoord+vec2(x,y)), 0);\n                bool tc = !any(greaterThan(abs((t.rgb/abs(t.a))-c), vec3(6.0/256.0)));\n                converged = converged && tc;\n                convergeCount += float(t.a < 0.0);\n            }\n        }\n    }\n\t\n\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (mod(4.0 * uv, 2.0) - 1.0) * aspect;\n    \n\n\tvec2 uvD = ((mod(4.0 * (fragCoord.xy+vec2(1.0, 1.0)) / iResolution.xy, 2.0) - 1.0) * aspect) - uv;\n\n    vec3 light = color.rgb + trace(fragCoord, uv, uvD, rayNumber, convergeCount);\n    \n    fragColor = vec4(light, ((converged || rayNumber >= 1000.0) ? -1.0 : 1.0) * rayNumber);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y < 2.0 && fragCoord.x < 2.0) {\n        ivec2 start = ivec2(2, 2);\n        if (fragCoord.x > 0.7) {\n            start.x += int(iResolution.x/2.0);\n        }\n        if (fragCoord.y > 0.7) {\n            start.y += int(iResolution.y/2.0);\n        }\n        ivec2 d = ivec2( (iResolution / 2.0 - 4.0) / 100.0 );\n        float raySum = 0.0;\n        for (int y = 0; y < 100; y++) {\n\t        for (int x = 0; x < 100; x++) {\n                vec4 p = texelFetch(iChannel0, start + d * ivec2(x, y), 0);\n                raySum += abs(p.a);\n            }\n        }\n        fragColor = vec4(raySum/10000.0, 0.0, 0.0, 0.0);\n    } else {\n        discard;\n    }\n}","name":"Buf B","description":"","type":"buffer"}]}