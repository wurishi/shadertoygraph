{"ver":"0.1","info":{"id":"MflXD2","date":"1707732450","viewed":22,"name":"[inspirnathan] 01 - circles&anim","username":"hrst4","description":"[inspirnathan] 01 - circles&anim","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci √† lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/48-shadertoy-tutorial-part-2\n\n#define PART 6\n\n\n// moiti√© de l'√©cran en blanc\n#if PART == 1 \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // range: <0,1>\n\n  vec3 col = vec3(.2); // start avec du noir\n  \n  if (uv.x > .5) col = vec3(1); // moiti√© droite en blanc\n\n  fragColor = vec4(col,1.0);\n}\n\n#elif PART == 2 // m√©thode step sur un float\n/*\nLa fonction step accepte deux entr√©es : le bord de la fonction step et une valeur \nutilis√©e pour g√©n√©rer la fonction step.\nSi le deuxi√®me param√®tre de l'argument de la fonction est sup√©rieur au premier, \nla fonction renvoie la valeur 1. Dans le cas contraire, elle renvoie la valeur z√©ro.\n\nVous pouvez √©galement ex√©cuter la fonction step sur chaque composant d'un vecteur :\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0,1>\n\n  vec3 col = vec3(0.); // start with black\n  \n  col = vec3(step(0.5, uv.x)); // make the right half of the canvas white\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n#elif PART == 3 // m√©thode step sur un vecteur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0,1>\n\n  vec3 col = vec3(0); // start with black\n  \n  col = vec3(step(0.5, uv), 0.); // perform step function across the x-component and y-component of uv\n\n  // Output to screen\n  /*\n  Puisque la fonction step op√®re √† la fois sur la composante X et la composante Y du canvas,\n  vous devriez voir le canevas se diviser en quatre couleurs.\n  */\n  fragColor = vec4(col,1.0);\n}\n\n#elif PART == 4 // dessiner des cercles\n/*\nL'√©quation d'un cercle est d√©finie par la formule suivante :\n\nx^2 + y^2 = r^2\n\nx = x-coordinate on graph\ny = y-coordinate on graph\nr = radius of circle\n\nNous pouvons r√©arranger les variables pour que l'√©quation soit √©gale √† z√©ro :\nx^2 + y^2 - r^2 = 0\n\nPour visualiser ce ph√©nom√®ne sur un graphique, \nvous pouvez utiliser la calculatrice Desmos pour tracer le graphique suivant :\n\nx^2 + y^2 - 4 = 0\n\nDans Shadertoy, nous pouvons utiliser le c√¥t√© gauche (LHS) de cette √©quation pour \ncr√©er un cercle.\nCr√©ons une fonction appel√©e sdfCircle qui renvoie la couleur blanche pour chaque pixel \n√† une coordonn√©e XY telle que l'√©quation est sup√©rieure √† z√©ro et la couleur bleue \ndans le cas contraire.\n\nLa partie sdf de la fonction fait r√©f√©rence √† un concept appel√© fonctions de distance \nsign√©es (SDF), √©galement appel√©es champs de distance sign√©s.\nIl est plus courant d'utiliser les SDF pour dessiner en 3D, \nmais j'utiliserai √©galement ce terme pour les formes en 2D.\n\nNous appellerons notre nouvelle fonction dans la fonction mainImage pour l'utiliser.\n*/\n\nvec3 sdfCircle(vec2 uv, float r) {\n    float x = uv.x;\n    float y = uv.y;\n    \n    float d = length(vec2(x, y)) - r;\n    \n    return d > 0. ? vec3(1.) : vec3(0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0,1>\n  \n  // d√©commenter pour obtenir la coordonn√©e (0,0) au centre\n  uv -= 0.5; // <-0.5, 0.5>\n  // aspect ratio\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  \n  vec3 col = sdfCircle(uv, .2); // Call this function on each pixel to check if the coordinate lies inside or outside of the circle\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nSi vous vous demandez pourquoi j'utilise 0. au lieu de 0 sans d√©cimale,\nc'est parce que l'ajout d'une d√©cimale √† la fin d'un nombre entier lui donne le \ntype float au lieu de int. Lorsque vous utilisez des fonctions qui requi√®rent \ndes nombres de type float, placer une d√©cimale √† la fin d'un entier est le moyen \nle plus simple de satisfaire le compilateur.\n\nNous utilisons un rayon de 0.2 parce que notre syst√®me de coordonn√©es est \nconfigur√© pour n'avoir que des valeurs UV comprises entre z√©ro et un. \nLorsque vous ex√©cutez le code, vous remarquez que quelque chose ne va pas.\n\nIl semble y avoir un quart de point bleu dans le coin inf√©rieur gauche de la toile.\nPourquoi ? Parce que notre syst√®me de coordonn√©es est actuellement configur√© de\ntelle sorte que l'origine se trouve dans le coin inf√©rieur gauche. \nNous devons d√©caler chaque valeur de 0,5 pour que l'origine du syst√®me\nde coordonn√©es soit au centre de la toile.\n\nSoustrayez 0,5 des coordonn√©es UV :\nvec2 uv = fragCoord/iResolution.xy; // <0,1>\nuv -= 0.5; // <-0.5, 0.5>\n\nLa plage est maintenant comprise entre -0,5 et 0,5 sur les axes x et y, \nce qui signifie que l'origine du syst√®me de coordonn√©es se trouve au centre de la toile.\nCependant, nous sommes confront√©s √† un autre probl√®me...\n\nNotre cercle est un peu √©tir√© et ressemble davantage √† une ellipse. \nCela est d√ª au rapport d'aspect du canvas.\nLorsque la largeur et la hauteur du canevas ne correspondent pas, \nle cercle appara√Æt √©tir√©. Nous pouvons r√©soudre ce probl√®me en multipliant \nla composante X des coordonn√©es UV par le rapport d'aspect de la toile.\n\nuv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\nCela signifie que la composante X n'est plus comprise entre -0,5 et 0,5.\nIl passera par des valeurs proportionnelles au rapport d'aspect de votre toile,\nqui sera d√©termin√© par la largeur de votre navigateur ou de votre page web \n(si vous utilisez quelque chose comme Chrome DevTools pour modifier la largeur).\n\n*/\n\n#elif PART == 5 // animer la couleur du cercle\n/*\nNous pouvons nous amuser avec cela ! \nNous pouvons utiliser la variable globale iTime pour changer de couleur au fil du temps.\nEn utilisant une fonction cosinus (cos),\nnous pouvons faire d√©filer le m√™me ensemble de couleurs √† plusieurs reprises. \nComme les fonctions cosinus oscillent entre les valeurs -1 et 1, \nnous devons ajuster cette plage √† des valeurs comprises entre z√©ro et un.\n\nN'oubliez pas que toutes les valeurs de couleur du fragment final qui sont inf√©rieures\n√† z√©ro seront automatiquement bloqu√©es √† z√©ro.\nDe m√™me, toute valeur de couleur sup√©rieure √† un sera limit√©e √† un.\nEn ajustant la plage, nous obtenons une plus large gamme de couleurs.\n\n*/\n\nvec3 sdfCircle(vec2 uv, float r) {\n  float x = uv.x;\n  float y = uv.y;\n  \n  float d = length(vec2(x, y)) - r;\n  \n  return d > 0. ? vec3(0.) : 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0,1>\n  uv -= 0.5;\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n  \n  vec3 col = sdfCircle(uv, .2);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nLa syntaxe de uv.xyx peut vous d√©concerter. \nC'est ce qu'on appelle le Swizzling. \nNous pouvons cr√©er de nouveaux vecteurs en utilisant les composantes d'une variable. \nPrenons un exemple.\n\nvec3 col = vec3(0.2, 0.4, 0.6);\nvec3 col2 = col.xyx;\nvec3 col3 = vec3(0.2, 0.4, 0.2);\n// col2 et col3 sont identiques\n\n*/\n\n#elif PART == 6 // faire bouger le cercle\n/*\nPour d√©placer le cercle, nous devons appliquer un d√©calage aux coordonn√©es XY \n√† l'int√©rieur de l'√©quation d'un cercle. \nPar cons√©quent, notre √©quation ressemblera √† ce qui suit :\n\n(x - offsetX)^2 + (y - offsetY)^2 - r^2 = 0\n\nx = x-coordinate on graph\ny = y-coordinate on graph\nr = radius of circle\noffsetX = how much to move the center of the circle in the x-axis\noffsetY = how much to move the center of the circle in the y-axis\n\nDans Desmos:\n(x - 2)^2 + (y - 2)^2 - 4 = 0\nDans Shadertoy, nous pouvons ajuster notre fonction sdfCircle \npour autoriser les d√©calages et d√©placer le centre du cercle de 0,2.\n\nVous pouvez √† nouveau utiliser la variable globale iTime √† certains \nendroits pour donner vie √† votre toile et animer votre cercle.\n*/\n\nvec3 sdfCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  \n  float d = length(vec2(x, y)) - r;\n  \n  return d > 0. ? vec3(1.) : vec3(0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0,1>\n  uv -= 0.5;\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n  \n  vec2 offset = vec2(sin(iTime*2.)*0.2, cos(iTime*2.)*0.2); // move the circle clockwise\n  \n  vec3 col = sdfCircle(uv, .2, offset);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n/*\nLe code ci-dessus d√©place le cercle le long d'une trajectoire circulaire\ndans le sens des aiguilles d'une montre, comme s'il tournait autour de l'origine.\nEn multipliant iTime par une valeur, vous pouvez acc√©l√©rer l'animation.\nEn multipliant la sortie de la fonction sinus ou cosinus par une valeur, \nvous pouvez contr√¥ler la distance entre le cercle et le centre de la toile. \nVous utiliserez beaucoup les fonctions sinus et cosinus avec iTime car elles\ncr√©ent une oscillation.\n*/\n\n/*\nConclusion:\nDans cette le√ßon, nous avons appris √† fixer le syst√®me de coordonn√©es du canvas,\n√† dessiner un cercle et √† animer le cercle le long d'une trajectoire circulaire. \nDes cercles, des cercles, des cercles ! üîµ\n\nDans la prochaine le√ßon, je vous montrerai comment dessiner un carr√© √† l'√©cran.\nEnsuite, nous apprendrons √† le faire pivoter !\n*/\n\n#endif\n","name":"Image","description":"","type":"image"}]}