{"ver":"0.1","info":{"id":"DdGXRh","date":"1680781550","viewed":22,"name":"Blobs and stuff rotating","username":"pipouille","description":"Blobs and rings\n3D web project","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Parameters to play with\n#define BLOBNUMBER 15  // number of spheres to create the blobby shape [5 - 20]\n#define RINGNUMBER 5  // number of rings [1 - 15]\n#define RINGTYPE 0     // type of ring to create [0 = ring, 1 = frame, 2 = cappedTorus, anything else = only the blobs]\n#define ROTATION 1     // type of rotation to apply to the rings [0 = no rotation, 1 = rotation on X axis, 2 = rotation on X,Y axis, 3 = rotation on X,Y,Z]\n\n// Define screen resolution\n#define R iResolution.xy\n\n// Define minimum and maximum distance to objects, number of steps for ray-marching, and precision for hit detection\n#define DIST_MIN 1.\n#define DIST_MAX 150.0\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.0001\n\n// Define Pi constant\n#define PI 3.14159265359\n\n// Define functions to rotate vectors on X, Y, and Z axes\nmat3 rotateX(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Define a struct to hold ray information\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\n// Define a struct to hold surface information\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n};\n\n// Define a function to compute a smooth union between two distances d1 and d2 with a factor k\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 2.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Define a function to perturb the shape of the blobs\nfloat perturb(float s) {\n    return s*cos(iTime*s)-sin(iTime*10.)/5.0;\n}\n\n// Define functions to create objects\nfloat sdFloor(vec3 p) {\n    return p.y + 1.;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s; \n}\n\nfloat sdTorus( vec3 p, vec2 t, mat3 transform)\n{\n    p = p*transform;\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, mat3 transform)\n{\n    p = p*transform;\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, mat3 transform, float e)\n{\n    p =p*transform;\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nfloat movementVariation() {\n    return cos(iTime*0.1)+sin(iTime*0.2);\n}\n\nmat3 rotationVariation(in int seletedRotation, in float i){\n    mat3 rota;\n    if (seletedRotation == 0) {\n        rota = rotateX(0.);\n    } else if (seletedRotation == 1){\n        rota = rotateX(0.1*iTime+i*movementVariation());\n    } else if (seletedRotation == 2) {\n        rota = rotateX(0.1*iTime+i*movementVariation())*rotateY(0.1*iTime+i*movementVariation());\n    } else if (seletedRotation == 3) {\n        rota = rotateX(0.1*iTime+i*movementVariation())*rotateY(0.1*iTime+i*movementVariation())*-rotateZ(0.1*iTime+i*movementVariation());\n    }\n\n    return rota;\n}\n\nfloat blob(vec3 p)\n{\n\tfloat d = 3.0;\n\tfor (int i = 0; i < BLOBNUMBER; i++) {\n\t\tfloat fi = float(i);\n        //Credits to a stranger\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 63.25)) * vec3(2.0-movementVariation(), 3.0-movementVariation(), 2.0-movementVariation()), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))), d, 0.8);\n\t}\n\treturn d;\n}\n\nfloat ring(vec3 p){\n    float d= 3.0;\n    float an = 2.5*(0.1+0.5*sin(1.1+3.0));\n    vec2 c = vec2(sin(an),cos(an));\n    for(int i = 1; i < RINGNUMBER; i++){\n        float fi = float(i);\n        if (RINGTYPE == 0) {\n            d = min(sdTorus(vec3(p.x, p.y, p.z), vec2(8., 0.1), rotationVariation(ROTATION, fi)), d);\n        } else if ( RINGTYPE == 1) {\n            d = min((sdBoxFrame(p, vec3(6.,6.,6.), rotationVariation(ROTATION, fi), 0.1)), d);\n        } else if (RINGTYPE == 2) {\n            d = min(sdCappedTorus(vec3(p.x, p.y, p.z), vec2(0.6, 0.8), 6., 0.3, rotationVariation(ROTATION, fi)), d);\n        }\n    }\n\n    return d;\n}\n\nSurface scene(in vec3 p) {\n    float blobs = blob(p);\n    float rings = ring(p);\n    float myfloor = sdFloor(vec3(p.x, p.y +15., p.z));\n    float wall1 = p.x + 50.0;\n    float wall2 = p.z + 50.;\n\n    float room = min(wall1, wall2);\n\n    float object = min(blobs, rings);\n    float enviro = min(room, myfloor);\n    float test = min(object, enviro);\n\n    vec3 col;\n\n    if (blobs == test) {\n        col = vec3(.5,1.,0.5);\n    } else if (wall1 == test){\n        col = vec3(0.5,.5,0.5);\n    } else if (wall2 == test) {\n        col = vec3(0.3, 0.3, 0.3);\n    } else if (myfloor == test) {\n        col = vec3(0.5, 0.7, 0.7);\n    }\n    else  {\n        col = vec3(1., 1., 0.5);\n    }\n\n    Surface mascene = Surface(min(object, enviro),col);\n\n\n    return mascene;\n}\n\n\n\nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0));\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nvec3 shade(in Surface s,in Ray r) {\n    vec3 n = normalAt(s,r);\n    vec3 l = normalize(vec3(0.,-2.,0.));\n    \n    \n    float d = dot(n,l)*0.5+0.7;\n    return d*s.c;\n}\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 80.;\n    //vec3 ro = vec3(d*cos(iTime*0.2+5.0*m.x),DP/5.0,d*cos(iTime*0.2+(PI/2.)+5.0*m.x) );\n    //vec3 ro = vec3(d*cos(5.0*m.x),DP/5.0,d*cos((PI/2.)+5.0*m.x));\n    vec3 ro = vec3(10.0, DP/5., 50.);\n\n    //vec3 ro = vec3(0.,0.,-7.);\n\n    // target point\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + zf*cw);\n\n    return Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n\n    Ray r = camRay(uv);\n    Surface s = march(r);\n    vec3 c = vec3(0.5);\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n    \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}