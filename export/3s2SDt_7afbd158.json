{"ver":"0.1","info":{"id":"3s2SDt","date":"1555350294","viewed":133,"name":"edge detection: gaussian","username":"hornet","description":"WSAD(QE)+mouse to move (shift to speed up)\n\ngaussian edge-detection","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["filter","edge","soft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//note: edge-detection\n\nfloat Gaussian( float x, float alpha )\n{\n\tfloat expv = exp(-alpha); //note: radius = 1.0\n    return max(0.0, (exp(-alpha * x * x) - expv) / (1.0-expv)); //note: normalisation-factor to always get f(0)=1\n}\n\nfloat remap( float v, float a, float b );\n\nfloat diff_rms( vec3 a, vec3 b )\n{\n    vec3 diff = a-b;\n    diff *= diff;\n    return sqrt( diff.x + diff.y + diff.z );\n}\n\nfloat diff_dp( vec3 v0, vec3 v1 )\n{\n    float dp = dot(v0, v1);\n    return max( 0.0, 1.0-dp );\n}\n\nfloat edgedetect_norm( vec3 s0, vec3 s1 )\n{\n    float diff = diff_rms( s0.rgb, s1.rgb ); //note: compare colors\n    //float diff = diff_dp( s0.rgb, s1.rgb ); //note: compare normal vectors\n    \n    //const float MAX_DIFF = 1.0;\n    //diff = min( diff, MAX_DIFF );\n    \n    diff = remap( diff, 0.1, 1.0 ); //note: tweak detection-values here\n    \n    return diff;\n}\n\nfloat edgedetect_depth( float z0, float z1, float dz )\n{\n    z0 = 1.0 / z0;\n    z1 = 1.0 / z1;\n    \n    float zd = abs(z0-z1);\n    zd = remap ( zd, 0.03, 0.05 ); //note: tweak detection-values here\n\t//zd *= dz; //note: scale z with expected diff from angle with camera-ray\n    \n    return zd;\n}\n\n//TODO: weights for edge/depth\nfloat edgedetect( vec2 p_px, vec2 ofs_px, float dz, bool do_depthdetect )\n{\n    vec2 rcp_res = 1.0 / vec2(textureSize(iChannel0, 0).xy);\n        \n    vec4 s0 = texture( iChannel0, (p_px + ofs_px)*rcp_res );\n\tvec4 s1 = texture( iChannel0, (p_px - ofs_px)*rcp_res );\n        \n    float n = edgedetect_norm( s0.xyz, s1.xyz );\n    \n    //if ( do_depthdetect == false ) return e;\n    \n    float d = edgedetect_depth( s0.w, s1.w, dz );\n    \n    //DEBUG\n    //return n;\n    //return d;\n    \n    //return n + d;\n    return max(n, d) / length(ofs_px);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    //vec2 cz = texture( iChannel1, 0.5*fragCoord.xy/iResolution.xy ).xy;\n    //vec2 cz = texture( iChannel2, 0.25*fragCoord.xy/iResolution.xy ).xy;\n    //fragColor = vec4(vec3(cz.y-cz.x), 1); return;\n    //fragColor = vec4( cz.xxx, 1 ); return;\n    //fragColor = vec4( 1.0 / cz.xxx, 1 ); return;\n    //fragColor = vec4( 1.0 / cz.yyy, 1 ); return;\n\n    //note: hierarchical z\n    //TODO: not conservative enough...\n    vec2 cz = texture( iChannel1, 0.5*fragCoord.xy/iResolution.xy ).xy;\n    //vec2 cz = texture( iChannel2, 0.25*fragCoord.xy/iResolution.xy ).xy;\n    bool do_depthdetect = cz.y-cz.x > 0.5;\n    \n    const int NUM_OFS = 12;\n    vec2 ofs[NUM_OFS];\n    ofs[0]  = vec2( 1, 0 ); //inner 3x3\n    ofs[1]  = vec2( 0, 1 );\n    ofs[2]  = vec2( 1, 1 );\n    ofs[3]  = vec2( 1,-1 );\n    \n    ofs[4]  = vec2( 2,-2 ); //outer 5x5\n\tofs[5]  = vec2( 2,-1 );\n    ofs[6]  = vec2( 2, 0 );\n    ofs[7]  = vec2( 2, 1 );\n    ofs[8]  = vec2( 2, 2 );\n    ofs[9]  = vec2( 1, 2 );\n    ofs[10] = vec2( 0, 2 );\n    ofs[11] = vec2(-1, 2 );\n    const float MAX_FILTER_DIST = 1.0+length(vec2(2,2));\n  \n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n    \n    vec4 nz = texture( iChannel0, ssuv );\n\n    vec2 thetaphi = texelFetch( iChannel3, ivec2(1,0),0).xy + texelFetch( iChannel3, ivec2(2,0),0).xy;\n    vec3 rd = calc_rd_ws( ssuv, thetaphi.x, thetaphi.y, iResolution.xy );\n    //fragColor = vec4( rd, 1 ); return;\n    \n    float dz = dot( -rd, nz.xyz ); //TODO: handle background?\n    //fragColor = vec4(vec3(dz), 1 ); return;\n    \n    const float GAUSS_ALPHA = 4.0; //note: higher is sharper\n    float sum = 0.0;\n    float sum_w = 0.0;\n    for ( int i=0; i<NUM_OFS; ++i )\n    {\n        vec2 o = ofs[i];\n        float d = length( o/MAX_FILTER_DIST ); //TODO: precalc per offset\n        float w = Gaussian( d, GAUSS_ALPHA ); //TODO: precalc per offset\n\n        float ed = edgedetect( fragCoord, o, dz, do_depthdetect );\n        sum += w * ed;\n        sum_w += w;\n    }\n    sum /= sum_w;\n        \n    fragColor = vec4( vec3(sum), 1 );\n\n    //TODO: use closest depth for distance-fading?\n    \n    //#define SHOW_DEBUG\n    #if defined( SHOW_DEBUG )\n    if ( iMouse.z > 0.5 )\n    {\n    \tvec4 s0 = texture( iChannel0, ssuv );\n        if ( iMouse.x/iResolution.x > 0.5 )\n    \t\tfragColor = vec4( s0.xyz, 1.0 );\n        else\n            fragColor = vec4( 1.0/s0.www, 1.0 );\n\n        return;\n    } \n    #endif //SHOW_DEBUG\n\n\n    #define SHOW_INPUT\n    #if defined( SHOW_INPUT )\n    if ( ssuv.x < 1.0/4.0 )\n    {\n        vec4 s = texture( iChannel0, ssuv );\n        vec3 norm = 0.5 + 0.5 * s.xyz;\n        fragColor = vec4( norm, 1 );\n        return;\n    }\n    if ( ssuv.x > 3.0/4.0 )\n    {\n        float z = texture(iChannel0,ssuv).w;\n        //z = 1.0/z;\n        z = fract(z);\n        fragColor = vec4( vec3(z), 1.0 );\n        return;\n    }\n    #endif\n\n\n    #define SHOW_CONVERVATIVE_Z\n    #if defined ( SHOW_CONVERVATIVE_Z )\n    if ( ssuv.x > 2.0/4.0 )\n        fragColor.r += do_depthdetect ? 0.5 : 0.0;\n    #endif\n}\n\n\n/*\n//note: smooth minium, soft-min\n//      https://www.shadertoy.com/view/ltf3W2\nfloat SAbs(float x, float k)\n{\n    return sqrt(x * x + k);\n}\n\nfloat SRamp1(float x, float k)\n{\n    return 0.5 * (x - SAbs(x, k));\n}\n\nfloat SMin1(float a, float b, float k)\n{\n    return a + SRamp1(b - a, k);\n}\nvec3 SMin1(vec3 a, vec3 b, float k)\n{\n    return vec3( SMin1( a.r, b.r, k ),\n\t\t\t     SMin1( a.g, b.g, k ),\n\t\t\t     SMin1( a.b, b.b, k ) );\n}\nvec3 SMax1( vec3 a, vec3 b, float k )\n{\n    return -SMin1( -a, -b, k );\n}\n*/\n\nfloat remap( float v, float a, float b )\n{\n    return clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n\n\n\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2019 Mikkel Gjoel\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//note: mouse /movement handling\n\n\nvec3 get_updated_position( float theta, float phi );\n\n//note: input management\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 thetaphi_prev  = texelFetch(iChannel0, ivec2(1,0),0 ).xy;\n    vec2 thetaphi_delta = texelFetch(iChannel0, ivec2(2,0),0 ).xy;\n    vec2 thetaphi_cur = thetaphi_prev + thetaphi_delta;\n    thetaphi_cur.x = clamp( thetaphi_cur.x, 0.01, 3.13 );\n\n    //note: position\n    if ( int(fragCoord.x) == 0 && int(fragCoord.y) == 0 )\n    {\n\t\tfragColor = vec4( get_updated_position(thetaphi_cur.x, thetaphi_cur.y), 1.0 );\n    }\n    \n    //note: mouse button\n    if ( int(fragCoord.x) == 1 && int(fragCoord.y) == 0 )\n    {\n        if ( iFrame == 0 )\n        {\n            fragColor = vec4( start_thetaphi, 0, 0 );\n            return;\n        }\n        \n        if ( iMouse.z < 0.0 )\n        {\n            fragColor = vec4( thetaphi_cur, 0, 0 );\n            return;\n        }\n        else\n        {\n            fragColor = vec4( thetaphi_prev, 0, 0 );\n            return;\n        }\n    }\n    \n    //note: mousedown-delta\n    if ( int(fragCoord.x) == 2 && int(fragCoord.y) == 0 )\n    {\n        if ( iFrame == 0 || iMouse.z < 0.0 )\n        {\n            fragColor = vec4( 0, 0, 0, 0 );\n            return;\n        }\n        vec2 mp_diff = (iMouse.z>0.0) ? (iMouse.xy-abs(iMouse.zw)) / iResolution.xy : vec2(0,0);\n        float dtheta = 3.14*mp_diff.y;\n        float dphi = 6.28*mp_diff.x;\n        \n        fragColor = vec4( dtheta, dphi, 0, 0 );\n    }\n}\n\n\nvec3 get_updated_position( float theta, float phi )\n{\n    if ( iFrame == 0 )\n    {\n        return start_campos_ws;\n    }\n\n    const int KEY_W=0, KEY_S=1, KEY_A=2, KEY_D=3, KEY_Q=4, KEY_E=5, KEY_SHIFT=6, NUM_KEYS=7;\n    int IDX[NUM_KEYS]; IDX[KEY_W]=87; IDX[KEY_S]=83; IDX[KEY_A]=65; IDX[KEY_D]=68; IDX[KEY_Q]=81; IDX[KEY_E]=69; IDX[KEY_SHIFT]=16;\n    float keys[NUM_KEYS];\n    for(int i=0;i<NUM_KEYS;++i)\n        keys[i] = texelFetch( iChannel1, ivec2(IDX[i],0), 0 ).x;\n\n    \n    float speed_units_per_second = ( keys[KEY_SHIFT] > 0.5 ) ? 10.0 : 1.0;\n\n    mat3x3 cs_to_ws = buildMat_cs2ws( theta, phi );\n\n    vec3 ofs = vec3( keys[KEY_D] - keys[KEY_A],\n                     keys[KEY_E] - keys[KEY_Q],\n                     keys[KEY_S] - keys[KEY_W]);\n    ofs = ofs * cs_to_ws;\n\n    vec3 p_prev = texelFetch( iChannel0, ivec2(0,0), 0 ).rgb;\n    vec3 p_new = p_prev + ofs * speed_units_per_second * iTimeDelta;\n\n    return p_new;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//note: raytracer\n\n\n// Fork of \"Basic Raytracer\" by jlyharia. https://shadertoy.com/view/4ds3zs\n// 2019-03-20 10:50:28\n\nconst float GAMMA_EXP = 2.4;\nvec3 lin2srgb( vec3 c )\n{\n    return pow( c, vec3(1.0/GAMMA_EXP) );\n}\n\n//note: uniform pdf rand [0;1[\nfloat hash11n(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3987, p * 5.4421));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4307);\n}\n//note: uniform pdf rand [0;1[\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n\nconst float FLT_MAX = 1000000.0f;\nconst float FLT_MIN = 0.000001f;\n\n\n//note: intersects [-1;1]-cube centered at origin\nbool isect_unitcube(vec3 ro, vec3 rd, out float near, out float far)\n{\n    vec3 p = -ro/rd;\n    vec3 q = 0.5/abs(rd);\n\tvec3 tmin = p - q;\n\tvec3 tmax = p + q;\n    near = max(tmin.x,max(tmin.y,tmin.z));\n\tfar = min(tmax.x,min(tmax.y,tmax.z));\n\treturn near < far && far > 0.0;\n}\n\n\nfloat isect_sphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    // a sphere centered at the origin has equation |xyz| = r\n    // meaning, |xyz|^2 = r^2, meaning <xyz, xyz> = r^2\n    // now, xyz = ro + t*rd, therefore |ro|^2+|t*rd|^2 + 2<ro, rd> t - r^2 = 0\n\t// |rd| = 1 (normalized) so equation reduce to |ro|^2+ t^2 + 2<ro, rd> t - r^2 = 0\n    // which is a quadratic equation, so\n\n    vec3 oc = ro - sph.xyz;\n    float b = 2.0 *dot(oc, rd);\n    float c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - 4.0 *c;\n    if(h < 0.0)\n        return FLT_MAX; //no intersection\n\n    //pick smaller one(i.e, close one)\n    //not (-b+sqrt(h)) /2\n    float t = (-b - sqrt(h))/ 2.0;\n    return t;\n}\nvec3 eval_normal_sphere(in vec3 pos, in vec4 sph)\n{\n    //sphere center at (l, m, n) radius r\n    //normal at intersect point N= ( (x-l)/r, (y-m)/r, (z-n)/r )\n    return (pos - sph.xyz)/sph.w;\n}\n\nvec3 eval_normal_box( in vec3 pos, in vec3 box_org )\n{\n    vec3 d0 = pos - box_org;\n    vec3 d = abs(d0);\n \treturn sign(d0)*step(d.yzx, d.xyz) * step(d.zxy, d.xyz);\n}\n\nfloat isect_plane(in vec3 ro, in vec3 rd)\n{\n    //equation of a plane, y=0 = ro.y+t*rd.y\n    return -ro.y/rd.y;\n}\nvec3 eval_normal_plane(in vec3 pos)\n{\n    return vec3(0.0, 1.0, 0.0); // normal of plane\n}\n\nvec3 lightDir = normalize(vec3(0.57703));\n\nconst int NUM_SPHERES = 8;\nvec4 spheres[NUM_SPHERES];\n\nconst int NUM_CUBES = 6;\nvec3 cube_org[NUM_CUBES];\n\nvoid update_scene()\n{\n    for ( int i=0,n=NUM_SPHERES; i<n; ++i )\n    {\n        float rnd = hash11n(float(i));\n        vec3 rnd3 = hash32n( vec2(float(i + 1337), rnd) );\n        float t = iTime*(1.0+rnd) + 16.0 * rnd;\n        vec3 p = vec3( -4.0 + 8.0 * rnd3.x,\n                       0.25 + 3.0*rnd3.y,\n                       -3.0 + 4.0 * rnd3.z);\n        spheres[i] = vec4( p, 0.5 + 0.5*rnd );\n        \n        //#if 0\n        spheres[i] = vec4( p.x + cos(t),\n                           p.y + 0.5 + 1.5 * cos( 0.2*t + 10.0*rnd ),\n\t\t\t\t\t\t   p.z + 0.5 * sin(t+4.1*rnd),\n                           1);\n        //#endif\n    }\n    \n    cube_org[0] = vec3( cos(iTime), 1.5, 0.0 );\n    cube_org[1] = vec3( 0.0, 1.0 + 0.5 * sin(iTime), -2.0 );\n    \n    cube_org[2] = vec3( cos(iTime), -0.45, -1.3 );\n    cube_org[3] = vec3( cos(iTime), -0.45, -0.2 );\n    cube_org[4] = vec3( cos(iTime), -0.45,  0.9 );\n    cube_org[5] = vec3( cos(iTime), -0.45,  2.0 );\n}\n\nstruct isect_t\n{\n    int id;\n    float t;\n};\n    \nisect_t isect_scene(in vec3 ro, in vec3 rd, float mindist)\n{\n    isect_t ret;\n    ret.id = -1;\n    ret.t = FLT_MAX;\n\n    ////////////////////////////////\n    \n    for ( int i=0,n=NUM_SPHERES; i<n; ++i )\n    {\n    \tfloat tsph = isect_sphere(ro, rd, spheres[i] );\n    \n        if ( tsph > mindist && tsph < FLT_MAX && tsph < ret.t )\n        {\n            //if intersect with sphere\n            ret.id  = i+1;\n            ret.t = tsph;\n        }\n    }\n \n    ////////////////////////////////\n    \n    for ( int i=0,n=NUM_CUBES; i<n; ++i )\n    {\n        vec3 o = ro - cube_org[i];\n        vec3 d = rd;\n        \n        float t0, t1;\n        bool hit = isect_unitcube( o, d, t0, t1 );\n        if ( hit && t0 < ret.t )\n        {\n            ret.id = NUM_SPHERES+1 + i;\n            ret.t = t0;\n        }\n    }\n    \n    ////////////////////////////////\n    \n    float tpla = isect_plane(ro, rd); \n    if ( tpla > mindist && tpla < ret.t)\n    {\n        //if intersect with plane and nearer than sphere, or -1\n        ret.id = 0;\n        ret.t = tpla;\n    }\n\n    \n    \n    return ret;\n}\n\nvec3 eval_normal_scene( int id, vec3 p)\n{\n    //return vec3( float(id) / 16.0 );\n    \n    if ( id < 0 )\n        return vec3(0, 0, -1);\n    \n    if (id == 0)\n        return eval_normal_plane( p );\n    \n    if ( id > 0 && id < NUM_SPHERES+1 )\n    \treturn eval_normal_sphere(p, spheres[id-1] );\n    \n    if ( id > NUM_SPHERES )\n        return eval_normal_box( p, cube_org[id-1-NUM_SPHERES] );\n    \n    return vec3( 1, 0, 0 );\n}\n\nvec3 eval_lighting( vec3 p, vec3 n, vec3 l )\n{\n    isect_t s = isect_scene( p, l, FLT_MIN );\n    //bool in_shadow = (s.id != isect.id) && (s.t < FLT_MAX );\n    bool in_shadow = s.t < FLT_MAX;\n\n    vec3 ambient = vec3(0.01, 0.02, 0.03);\n    \n    float diff = in_shadow ? 0.0 : clamp(dot(n,l), 0.0, 1.0); //use clamp restrict cos to[0, 1]\n    return vec3(ambient + diff);\n}\n\nvec3 eval_material( vec3 light, vec3 p, vec3 n, vec3 rd )\n{\n    //vec3 refvec = normalize(reflect(rd, n));\n    //isect_t r = isect_scene( p, refvec, FLT_MIN );\n    //vec3 refpos = p + r.t * refvec;\n    //vec3 refnor = eval_normal_scene( r.id, refpos );\n    //vec3 refcol = \n    \n    const vec3 diffcol = vec3(1,1,1);\n    return diffcol * light;\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 l, vec3 rd)\n{\n    vec3 light = eval_lighting(p,n,l);\n   \treturn eval_material(light, p, n, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n\n    vec2 thetaphi = texelFetch( iChannel0, ivec2(1,0),0).xy + texelFetch( iChannel0, ivec2(2,0),0).xy;\n    thetaphi.x = clamp( thetaphi.x, 0.01, 3.13 );\n   \n    vec3 ro = texelFetch( iChannel0, ivec2(0,0), 0 ).xyz;\n    vec3 rd = calc_rd_ws( ssuv, thetaphi.x, thetaphi.y, iResolution.xy );\n    \n    update_scene();\n\t    \n\t////////////////////////////////////////////////////\n    \n    isect_t isect = isect_scene(ro, rd, 0.0);\n    \n    vec3 pos = ro + isect.t * rd;\n    vec3 nor = eval_normal_scene( isect.id, pos );\n    \n    fragColor = vec4( nor, isect.t ); //note: ws_normal, linear vs_z\n    return;\n \n    \n    /*\n    vec3 col = shade( pos, nor, lightDir, rd );\n\n    ////////////////////////////////////////////////////\n    // DEBUG\n\n    //fragColor = vec4(vec3(step(isect.t,500.0)),1); return;\n    //fragColor = vec4(vec3(step(s.t,500.0)),1); return;\n    //fragColor = vec4(0.5+0.5*nor,1); return;\n\n    ////////////////////////////////////////////////////\n\n    vec3 outcol = lin2srgb( col ); //note: gamma\n    \n    //note: 8bit tpdf dithering\n    outcol += (hash32n(fragCoord.xy + fract(iTime)) + hash32n(fragCoord.xy+fract(iTime+0.1337)) - 1.0 )/ 255.0f;\n    \n\tfragColor = vec4(outcol, isect.t);\n\t*/\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const vec3 ws_up = vec3(0,1,0);\nconst vec3 start_campos_ws = vec3(0.0, 0.5, 3.0);\nconst vec2 start_thetaphi = vec2(1.67, 1.67);\n\nmat3x3 buildMat_cs2ws( float theta, float phi )\n{\n    vec3 cz = vec3( sin(theta)*cos(phi),\n                   cos(theta),\n                   sin(theta)*sin(phi) ); //note: fwd, implicitly normalized\n    vec3 cx = normalize(cross(ws_up, cz)); //note: right\n    vec3 cy = normalize(cross(cz,cx));     //note: up\n    mat3x3 ws_to_cs = mat3x3(cx,cy,cz);\n    mat3x3 cs_to_ws = transpose(ws_to_cs);\n\n    //rd = rd * cs_to_ws;\n\n    return cs_to_ws;\n}\n\n\nvec3 calc_rd_ws( vec2 ssuv, float theta, float phi, vec2 res )\n{\n    float aspect = res.x / res.y;\n    vec3 ss_rd = normalize( vec3( (2.0*ssuv - 1.0) * vec2(aspect, 1.0), -1.0) );\n\n    mat3x3 cs_to_ws = buildMat_cs2ws(theta, phi);\n\n    return ss_rd * cs_to_ws;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //note: half dimensions\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n    \n    if ( max(ssuv.x,ssuv.y)>0.5 ) { fragColor = vec4(0.25); return; }\n    \n    vec2 uv = 2.0 * ssuv - 0.5/iResolution.xy; //TODO\n    vec2 d_px = 1.0 / iResolution.xy / 2.0;\n    \n    float z0 = texture(iChannel0, uv + vec2( d_px.x,  d_px.y) ).w;\n    float z1 = texture(iChannel0, uv + vec2( d_px.x, -d_px.y) ).w;\n    float z2 = texture(iChannel0, uv + vec2(-d_px.x, -d_px.y) ).w;\n    float z3 = texture(iChannel0, uv + vec2(-d_px.x,  d_px.y) ).w;\n\n    float mn = min( z0, min(z1, min(z2, z3 ) ) );\n    float mx = max( z0, max(z1, max(z2, z3 ) ) );\n    \n    fragColor = vec4(mn, mx, 0, 1);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //note: quarter dimensions\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n    \n    if ( max(ssuv.x,ssuv.y)>0.25 ) { fragColor = vec4(0.5,0,0,0); return; }\n\n    vec2 uv = 2.0 * ssuv - 0.5/iResolution.xy; //TODO\n    vec2 d_px = 1.0 / iResolution.xy / 2.0;\n    \n    vec2 z0mnmx = texture(iChannel0, uv + vec2( d_px.x,  d_px.y) ).xy;\n    vec2 z1mnmx = texture(iChannel0, uv + vec2( d_px.x, -d_px.y) ).xy;\n    vec2 z2mnmx = texture(iChannel0, uv + vec2(-d_px.x, -d_px.y) ).xy;\n    vec2 z3mnmx = texture(iChannel0, uv + vec2(-d_px.x,  d_px.y) ).xy;\n    \n    float mn = min( z0mnmx.x, min(z1mnmx.x, min(z2mnmx.x, z3mnmx.x ) ) );\n    float mx = max( z0mnmx.y, max(z1mnmx.y, max(z2mnmx.y, z3mnmx.y ) ) );\n    \n    fragColor = vec4(mn, mx, 0, 1);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}