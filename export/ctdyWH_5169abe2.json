{"ver":"0.1","info":{"id":"ctdyWH","date":"1699143336","viewed":58,"name":"Projet Image","username":"beaujonalexandre","description":"University assignment.","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AO_SAMPLES 0\n#define SHADING_DEPTH 15\n\nstruct Transform\n{\n   vec3 translation;\n   vec3 scale;\n   vec3 rotation;\n};\n\n/* Objects */\nstruct Sphere {\n   float r; // Radius\n   int i; // Texture Id\n   Transform transform;\n};\n\nstruct Plane {\n   vec3 n; // Normal\n   int i; // Texture Id\n   Transform transform;\n};\n\nstruct Box\n{\n   vec3 dimensions; // Lengths of (x, y, z) edges\n   int i; // Texture id\n   Transform transform;\n};\n\nstruct Ellipsoid\n{\n   vec3 dimensions;\n   int i; // Texture id\n   Transform transform;\n};\n\n// Circle at origin with normal pointing upwards\nstruct Circle\n{\n    float radius;\n    float height;\n    int i; // Texture id\n    Transform transform;\n};\n\nstruct Cylinder\n{\n    float height;\n    float radius;\n    int i; // Texture id\n    Transform transform;\n};\n\n/* Ray tracing */\nstruct Hit {\n   float t; // Intersection depth\n   vec3 n; // Normal\n   int i; // Texture Id\n};\n\nstruct Ray {\n   vec3 o; // Origin\n   vec3 d; // Direction\n};\n\n/* Materials and lights */\nstruct Material\n{\n   vec3 d; // Diffuse\n};\n\nstruct LightAttribs\n{\n    vec3 ambiant;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct MaterialPhong\n{\n   LightAttribs attribs;\n   float shininess;\n\n   float reflectedFactor;\n};\n\nstruct DirectionalLight\n{\n   vec3 direction;\n   LightAttribs attribs;\n};\n\nstruct PointLight\n{\n   vec3 position;\n   LightAttribs attribs;\n   float attenuationFactor; // Attenuation of light with distance between light and object\n};\n\n#define IDENTITY_TRANSFORM Transform(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0))\n\n// Scene lights\n#define directionalLightsNumber 1\nDirectionalLight directionalLight[directionalLightsNumber];\n#define pointLightsNumber 1\nPointLight pointLight[pointLightsNumber];\n\n// Scene objects\n#define planesNb 1\nPlane planes[planesNb];\n#define spheresNb 4\nSphere spheres[spheresNb];\n#define ellipsoidsNb 1\nEllipsoid ellipsoids[ellipsoidsNb];\n#define boxesNb 1\nBox boxes[boxesNb];\n#define circlesNb 1\nCircle circles[circlesNb];\n#define cylindersNb 1\nCylinder cylinders[cylindersNb];\n\n// Camera\nvec3 viewDirection;\n\n// Materials\nMaterialPhong matPhongGround = MaterialPhong\n(\n   LightAttribs\n    (\n        vec3(24.0, 69.0, 74.0) / 255.0,\n        vec3(77.0, 155.0, 163.0) / 255.0,\n        vec3(197.0, 236.0, 240.0) / 255.0\n    ),\n   float(64.0),\n   0.05\n);\nMaterialPhong matPhongPurple = MaterialPhong\n(\n    LightAttribs\n    (\n        vec3(49, 27, 64) / 255.0,\n        vec3(121, 81, 148) / 255.0,\n        vec3(215, 185, 235) / 255.0\n    ),\n   float(4.0),\n   0.4\n);\nMaterialPhong matPhongOrange = MaterialPhong\n(\n    LightAttribs\n    (\n        vec3(79, 64, 31) / 255.0,\n        vec3(168, 133, 56) / 255.0,\n        vec3(212, 194, 155) / 255.0\n    ),\n   float(4.0),\n   0.01\n);\nMaterialPhong matPhongLime = MaterialPhong\n(\n    LightAttribs\n    (\n        vec3(37, 94, 44) / 255.0,\n        vec3(28, 199, 49) / 255.0,\n        vec3(138, 230, 150) / 255.0\n    ),\n   float(4.0),\n   0.01\n);\nMaterialPhong matPhongMirror = MaterialPhong\n(\n    LightAttribs\n    (\n        vec3(0, 0, 0) / 255.0,\n        vec3(0, 0, 0) / 255.0,\n        vec3(0, 0, 0) / 255.0\n    ),\n   float(4.0),\n   1.0\n);\n\nfloat Checkers(in vec2 p)\n{\n   // Filter kernel\n   vec2 w = fwidth(p) + .001;\n   // Box box filter\n   vec2 i = 2. * (abs(fract((p - .5 * w) * .5) - .5) - abs(fract((p + .5 * w) * .5) - .5)) / w;\n   // xor pattern\n   return .5 - .5 * i.x * i.y;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray, float t)\n{\n   return ray.o + t * ray.d;\n}\n\n// Compute color\n// p : Point\n// i : Texture index\nMaterial Texture(vec3 p, int i)\n{\n   if (i == 1)\n   {\n      return Material(vec3(.8, .5, .4));\n   }\n   else if (i == 0)\n   {\n      // compute checkboard\n      float f = Checkers(.5 * p.xy);\n      vec3 col = vec3(.4, .5, .7) + f * vec3(.1);\n      return Material(col);\n   }\n   return Material(vec3(0));\n}\n\n// Compute phong material\n// i : index of Phong material\nMaterialPhong PhongOfIndex(int i, vec3 point)\n{\n   switch (i)\n   {\n   case 0:\n        MaterialPhong mat = matPhongGround;\n        float diffuseDelta = 0.2;\n        float wavesLength = 2.f;\n        mat.attribs.diffuse += vec3(diffuseDelta * sin(2.0 * 3.1416 / wavesLength * sqrt(dot(point, point))));\n      return mat;\n      break;\n   case 1:\n        return matPhongPurple;\n      break;\n    case 2:\n        return matPhongMirror;\n        break;\n    case 3:\n        return matPhongOrange;\n        break;\n    case 4:\n        return matPhongLime;\n        break;\n   default:\n      return matPhongGround;\n      break;\n   }\n}\n\n// Sphere intersection\n// ray : The ray\n// sph : The sphere\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray, Sphere sph, out Hit x)\n{\n   float b = dot(ray.o, ray.d);\n   float c = dot(ray.o, ray.o) - sph.r * sph.r;\n   float d = b * b - c;\n   if (d > 0.)\n   {\n      float t = -b - sqrt(d);\n      if (t > 0.)\n      {\n         vec3 p = Point(ray, t);\n         x = Hit(t, normalize(p), sph.i);\n\n         return true;\n      }\n   }\n   return false;\n\n}\n\n// Plane intersection\n// ray : The ray\n//  pl : The plane\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray, Plane pl, out Hit x)\n{\n   float t = -dot(ray.o, pl.n) / dot(ray.d, pl.n);\n   if (t > 0.0)\n   {\n      x = Hit(t, vec3(0, 0, (ray.o.z > 0.0) ? 1 : -1), pl.i);\n      return true;\n   }\n   return false;\n}\n\n// Ellipsoid intersection\n// ray : The ray\n// ell : The ellipsoid\n//   x : Returned intersection information\nbool IntersectEllipsoid(Ray ray, Ellipsoid ell, out Hit x)\n{\n   float a = ell.dimensions.x, b = ell.dimensions.y, c = ell.dimensions.z;\n   float dx = ray.d.x, dy = ray.d.y, dz = ray.d.z;\n   float xop = ray.o.x, yop = ray.o.y, zop = ray.o.z;\n\n   float A = (dx * dx) / (a * a)\n            + (dy * dy) / (b * b)\n            + (dz * dz) / (c * c);\n   float B = 2. * ((dx * xop) / (a * a)\n            + (dy * yop) / (b * b)\n            + (dz * zop) / (c * c));\n   float C = (xop * xop) / (a * a)\n               + (yop * yop) / (b * b)\n               + (zop * zop) / (c * c)\n               - 1.;\n   float delta = B * B - 4. * A * C;\n\n   if (delta < 0.) return false;\n\n   float t1 = (-B - sqrt(delta)) / (2. * A);\n   float t2 = (-B + sqrt(delta)) / (2. * A);\n\n   if (t1 < 0. && t2 < 0.) return false;\n   float t = (t1 < t2 ? t1 : t2);\n\n   vec3 intersect = Point(ray, t);\n\n   x = Hit(t, normalize(intersect), ell.i);\n   return true;\n}\n\n// Box intersection\n// ray : The ray\n// box : The box\n//   x : Returned intersection information\nbool IntersectBox(Ray ray, Box box, out Hit x)\n{\n   // t1 is for first corner of the box, t2 is for the opposite corner\n   vec3 t1 = -ray.o / ray.d;\n   vec3 t2 = (box.dimensions - ray.o) / ray.d;\n   vec3 tm = min(t1, t2);\n   vec3 tp = max(t1, t2);\n   float maxm = max(max(tm.x, tm.y), tm.z);\n   float minp = min(min(tp.x, tp.y), tp.z);\n   if (maxm > minp || minp < 0.0) return false;\n\n   vec3 normal;\n   if (maxm == tm.x) normal = vec3((t1.x > t2.x ? 1.0 : -1.0), 0.0, 0.0);\n   else if (maxm == tm.y) normal = vec3(0.0, (t1.y > t2.y ? 1.0 : -1.0), 0.0);\n   else normal = vec3(0.0, 0.0, (t1.z > t2.z ? 1.0 : -1.0));\n\n   x = Hit(maxm, normal, box.i);\n   return true;\n}\n\n// Circle intersection\n//    ray : The ray\n// circle : The circle\n//      x : Returned intersection information\nbool IntersectCircle(Ray ray, Circle circle, out Hit x)\n{\n    if (ray.d.z == 0.0) return false;\n    \n    float t = (circle.height - ray.o.z) / ray.d.z;\n    \n    if (t > 0.0) // Intersection with plane at origin with normal = (0, 0, 1)\n    {\n        vec3 p = Point(ray, t);\n        if (p.x * p.x + p.y * p.y < circle.radius * circle.radius) // Intersection with circle\n        {\n            x = Hit(t, (ray.o.z > 0.0) ? vec3(0.0, 0.0, 1.0) : vec3(0.0, 0.0, -1.0), circle.i);\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n// Cylinder intersection\n//      ray : The ray\n// cylinder : The cylinder\n//        x : Returned intersection information\nbool IntersectCylinder(Ray ray, Cylinder cylinder, out Hit x)\n{\n    // We start with searching the intersection between ray and a cylinder of radius = cylinder.radius\n    // and length = infinity\n    float A = ray.d.x * ray.d.x + ray.d.y * ray.d.y;\n    float B = 2.0 * (ray.o.x * ray.d.x + ray.o.y * ray.d.y);\n    float C = ray.o.x * ray.o.x + ray.o.y * ray.o.y - cylinder.radius * cylinder.radius;\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0) return false;\n    \n    float tcm = (-B - sqrt(D)) / (2.0 * A); // \"t cylinder -\"\n    float tcp = (-B + sqrt(D)) / (2.0 * A); // \"t cylinder +\"\n    // tcm < tcp in all cases because A > 0 in all cases (sum of squares)\n    \n    if (tcm < 0.0 || tcp < 0.0) return false;\n    \n    float tpm = -ray.o.z / ray.d.z;                    // \"t plane -\"\n    float tpp = (cylinder.height - ray.o.z) / ray.d.z; // \"t plane +\"\n    if (tpm > tpp)\n    {\n        float temp = tpp;\n        tpp = tpm;\n        tpm = temp;\n    }\n    \n    float tm = max(tcm, tpm);\n    float tp = min(tcp, tpp);\n    \n    if (tm > tp) return false;\n    \n    float t = tm;\n    \n    // Computing normal\n    \n    vec3 impactPoint = Point(ray, t);\n\n    if (t == tcm) // Cylinder\n    {\n        vec3 normal = impactPoint;\n        normal.z = 0.0;\n        normal = normalize(normal);\n        x = Hit(t, normal, cylinder.i);\n        return true;\n    }\n    else // Top or bottom\n    {\n        vec3 normal;\n        \n        if (ray.o.z > 0.0)\n            normal = vec3(0.0, 0.0, 1.0);\n        else\n            normal = vec3(0.0, 0.0, -1.0);\n        \n        x = Hit(t, normal, cylinder.i);\n        return true;\n    }\n}\n\n// Converts a translation vector into a translation 4-matrix\n// translation : The translation vector\nmat4 TranslationMatrix(vec3 translation)\n{\n   mat4 result;\n\n   result[0] = vec4(1.0, 0.0, 0.0, 0.0);\n   result[1] = vec4(0.0, 1.0, 0.0, 0.0);\n   result[2] = vec4(0.0, 0.0, 1.0, 0.0);\n   result[3] = vec4(translation.x, translation.y, translation.z, 1.0);\n\n   return result;\n}\n\n// Converts a rotation(raw, pitch, yaw) vector into a rotation 4-matrix\n// rot : The rotation vector\nmat4 RotationMatrix(vec3 rot)\n{\n   mat4 xRot;\n   xRot[0] = vec4(cos(rot.x), sin(rot.x), 0.0, 0.0);\n   xRot[1] = vec4(-sin(rot.x), cos(rot.x), 0.0, 0.0);\n   xRot[2] = vec4(0.0, 0.0, 1.0, 0.0);\n   xRot[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n   mat4 yRot;\n   yRot[0] = vec4(cos(rot.y), 0.0, -sin(rot.y), 0.0);\n   yRot[1] = vec4(0.0, 1.0, 0.0, 0.0);\n   yRot[2] = vec4(sin(rot.y), 0.0, cos(rot.y), 0.0);\n   yRot[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n   mat4 zRot;\n   zRot[0] = vec4(1.0, 0.0, 0.0, 0.0);\n   zRot[1] = vec4(0.0, cos(rot.z), sin(rot.z), 0.0);\n   zRot[2] = vec4(0.0, -sin(rot.z), cos(rot.z), 0.0);\n   zRot[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n   return zRot * yRot * xRot;\n}\n\n// Converts a scale vector into a scale 4-matrix\n// scale : The scale vector\nmat4 ScaleMatrix(vec3 scale)\n{\n   mat4 result;\n\n   result[0] = vec4(scale.x, 0.0, 0.0, 0.0);\n   result[1] = vec4(0.0, scale.y, 0.0, 0.0);\n   result[2] = vec4(0.0, 0.0, scale.z, 0.0);\n   result[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n   return result;\n\n}\n\n// Converts a transform(translation, rotation, scale) struct into a transform 4-matrix\n// t : The transform struct\nmat4 TransformToMatrix(Transform t)\n{\n   return TranslationMatrix(t.translation) * RotationMatrix(t.rotation) * ScaleMatrix(t.scale);\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray, out Hit x)\n{\n   Ray transformedRay = ray;\n\n   x = Hit(1000., vec3(0), -1);\n   Hit current;\n   bool ret = false;\n\n   mat4 M;\n   Transform t;\n    \n    for (int i = 0; i < spheresNb; i++)\n    {\n        t = spheres[i].transform;\n        M = inverse(TransformToMatrix(t));\n        transformedRay.o = (M * vec4(ray.o, 1.0)).xyz;\n        transformedRay.d = (M * vec4(ray.d, 1.0) - M * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n        if (IntersectSphere(transformedRay, spheres[i], current) && current.t < x.t)\n        {\n            x = current;\n            mat4 invM = inverse(M);\n            x.n = normalize((invM * vec4(x.n, 1.0) - invM * vec4(0.0, 0.0, 0.0, 1.0)).xyz);\n            ret = true;\n        }\n    }\n    \n    for (int i = 0; i < boxesNb; i++)\n    {\n        t = boxes[i].transform;\n        M = inverse(TransformToMatrix(t));\n        transformedRay.o = (M * vec4(ray.o, 1.0)).xyz;\n        transformedRay.d = (M * vec4(ray.d, 1.0) - M * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n        if (IntersectBox(transformedRay, boxes[i], current) && current.t < x.t)\n        {\n            x = current;\n            mat4 invM = inverse(M);\n            x.n = normalize((invM * vec4(x.n, 1.0) - invM * vec4(0.0, 0.0, 0.0, 1.0)).xyz);\n            ret = true;\n        }\n    }\n    \n    for (int i = 0; i < ellipsoidsNb; i++)\n    {\n        t = ellipsoids[i].transform;\n        M = inverse(TransformToMatrix(t));\n        transformedRay.o = (M * vec4(ray.o, 1.0)).xyz;\n        transformedRay.d = (M * vec4(ray.d, 1.0) - M * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n        if (IntersectEllipsoid(transformedRay, ellipsoids[i], current) && current.t < x.t)\n        {\n            x = current;\n            mat4 invM = inverse(M);\n            x.n = normalize((invM * vec4(x.n, 1.0) - invM * vec4(0.0, 0.0, 0.0, 1.0)).xyz);\n            ret = true;\n        }\n    }\n    \n    for (int i = 0; i < planesNb; i++)\n    {\n        t = planes[i].transform;\n        M = inverse(TransformToMatrix(t));\n        transformedRay.o = (M * vec4(ray.o, 1.0)).xyz;\n        transformedRay.d = (M * vec4(ray.d, 1.0) - M * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n        if (IntersectPlane(transformedRay, planes[i], current) && current.t < x.t)\n        {\n            x = current;\n            mat4 invM = inverse(M);\n            x.n = normalize((invM * vec4(x.n, 1.0) - invM * vec4(0.0, 0.0, 0.0, 1.0)).xyz);\n            ret = true;\n        }\n    }\n    \n    for (int i = 0; i < circlesNb; i++)\n    {\n        t = circles[i].transform;\n        M = inverse(TransformToMatrix(t));\n        transformedRay.o = (M * vec4(ray.o, 1.0)).xyz;\n        transformedRay.d = (M * vec4(ray.d, 1.0) - M * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n        if (IntersectCircle(transformedRay, circles[i], current) && current.t < x.t)\n        {\n            x = current;\n            mat4 invM = inverse(M);\n            x.n = normalize((invM * vec4(x.n, 1.0) - invM * vec4(0.0, 0.0, 0.0, 1.0)).xyz);\n            ret = true;\n        }\n    }\n    \n    for (int i = 0; i < cylindersNb; i++)\n    {\n        t = cylinders[i].transform;\n        M = inverse(TransformToMatrix(t));\n        transformedRay.o = (M * vec4(ray.o, 1.0)).xyz;\n        transformedRay.d = (M * vec4(ray.d, 1.0) - M * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n        if (IntersectCylinder(transformedRay, cylinders[i], current) && current.t < x.t)\n        {\n            x = current;\n            mat4 invM = inverse(M);\n            x.n = normalize((invM * vec4(x.n, 1.0) - invM * vec4(0.0, 0.0, 0.0, 1.0)).xyz);\n            ret = true;\n        }\n    }\n\n   return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n   return mix(vec3(.8, .8, .9), vec3(.7, .7, .8), rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro, in vec3 ta)\n{\n   vec3 cw = normalize(ta - ro);\n   vec3 cp = vec3(0, 0, 1);\n   vec3 cu = -normalize(cross(cw, cp));\n   vec3 cv = -normalize(cross(cu, cw));\n   return mat3(cu, cv, cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m, vec3 n)\n{\n   vec3 light = normalize(vec3(-1, -1, 0));\n\n   float diff = clamp(dot(n, light), 0., 1.);\n   vec3 col = m.d * diff + vec3(.2, .2, .2);\n   return col;\n}\n\n// Get ambiant color with Phong model\n//   matAmbiant : Material ambiant component\n// lightAmbiant : Ligh ambiant component\nvec3 phongAmbiant(vec3 matAmbiant, vec3 lightAmbiant)\n{\n   return matAmbiant * lightAmbiant;\n}\n\n// Get diffuse color with Phong model\n//     matDiffuse : Material diffuse component\n//   lightDiffuse : Light diffuse component\n//         normal : Object impact normal vector\n// lightDirection : Direction vector of light (object -> light)\nvec3 phongDiffuse(vec3 matDiffuse, vec3 lightDiffuse, vec3 normal, vec3 lightDirection)\n{\n   return vec3(matDiffuse * lightDiffuse * max(dot(normal, lightDirection), 0.0));\n}\n\n// Get specular color with Phong model\n//    matSpecular : Material specular component\n//   matShininess : Material shininess component\n//  lightSpecular : Light specular component\n//         normal : Object impact normal vector\n// lightDirection : Direction vector of light (object -> light)\nvec3 phongSpecular(vec3 matSpecular, float matShininess, vec3 lightSpecular, vec3 normal, vec3 lightDirection)\n{\n   vec3 reflectedLight = reflect(lightDirection, normal);\n   float specularFactor = pow(max(dot(reflectedLight, viewDirection), 0.0), matShininess);\n   return vec3(matSpecular * lightSpecular * specularFactor);\n}\n\n// Get pixel color with Phong model, no shadow taken in account.\n//          mat : Object material\n// lightAttribs : Light attributes (ambiant, diffuse, specular)\n//       normal : Object impact normal vector\n//     lightDir : Direction vector of light ray (light -> object)\nvec3 Phong(MaterialPhong mat, LightAttribs lightAttribs, vec3 normal, vec3 lightDir)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    color += phongAmbiant(mat.attribs.ambiant, lightAttribs.ambiant);\n    color += phongDiffuse(mat.attribs.diffuse, lightAttribs.diffuse, normal, -lightDir);\n    color += phongSpecular(mat.attribs.specular, mat.shininess, lightAttribs.specular, normal, -lightDir);\n    \n    return color;\n}\n\n// Get pixel color with a directional light in Phong model, no shadow taken in account.\n//    mat : Object material\n//  light : Direction light to compute with\n// normal : Object impact normal vector\nvec3 phongDirectionalLight(MaterialPhong mat, DirectionalLight light, vec3 normal)\n{\n    return Phong(mat, light.attribs, normal, light.direction);\n}\n\n// Get pixel color with a point light in Phong model, no shadow taken in account.\n//           mat : Object material\n//         light : Direction light to compute with\n//        normal : Object impact normal vector\n// pointPosition : Object impact position vector\nvec3 phongPointLight(MaterialPhong mat, PointLight light, vec3 normal, vec3 pointPosition)\n{\n    vec3 lightToPoint = pointPosition - light.position;\n    vec3 lightDir = normalize(lightToPoint);\n    float attenuation = 1.0 / (light.attenuationFactor * dot(lightToPoint, lightToPoint));\n    LightAttribs attenuatedLightAttribs = light.attribs;\n    attenuatedLightAttribs.diffuse *= attenuation;\n    attenuatedLightAttribs.specular *= attenuation;\n    return Phong(mat, attenuatedLightAttribs, normal, lightDir);\n}\n\n// Hemisphere direction\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n\n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n\n    return normalize(d);\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// N : Number of samples\nfloat AmbientOcclusion(vec3 p,vec3 n,int N)\n{\n    if(N == 0) return 1.f;\n   \n    float ao=0.;\n    int freeRays = 0;\n   \n    for(int i=0;i<N;i++)\n    {\n        vec3 d= Hemisphere (i,n); // d dans la demi-sphere \n        Ray ray = Ray(p + d * 0.001, d); // Ray from point with direction in half-sphere\n        Hit dummyHit;\n        if (!Intersect(ray, dummyHit))\n            freeRays++;\n    }\n    \n    return float(freeRays) / float(N);\n}\n\n// Get pixel color with all lights in Phong model, with shadows taken in accout. No reflexion depth.\n// mat : Object material\n// ray : Ray\n// hit : Hit infos\nvec3 Color(MaterialPhong mat, Ray ray, Hit hit)\n{\n   vec3 color = vec3(0, 0, 0);\n    \n    vec3 impactPoint = Point(ray, hit.t);\n    Ray pointToLightRay;\n    pointToLightRay.o = impactPoint + hit.n * 0.001;\n        \n    for (int i = 0; i < directionalLightsNumber; i++)\n    {\n        pointToLightRay.d = -directionalLight[i].direction;\n        Hit dummyHit;\n        \n        if(Intersect(pointToLightRay, dummyHit))\n            color += phongAmbiant(mat.attribs.ambiant, directionalLight[i].attribs.ambiant);\n        else\n            color += phongDirectionalLight(mat, directionalLight[i], hit.n);\n    }\n\n    for (int i = 0; i < pointLightsNumber; i++)\n    {\n        pointToLightRay.d = normalize(pointLight[i].position - impactPoint);\n        Hit dummyHit;\n        \n        if(Intersect(pointToLightRay, dummyHit))\n            color += phongAmbiant(mat.attribs.ambiant, pointLight[i].attribs.ambiant);\n        else\n            color += phongPointLight(mat, pointLight[i], hit.n, impactPoint);\n    }\n    \n    float ao = AmbientOcclusion(impactPoint, hit.n, AO_SAMPLES);\n\n    return color * ao;\n}\n\n// Rendering\n//   ray : Ray\n// depth : Reflexion depth\nvec3 Shade(Ray ray, int depth)\n{\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    Ray incidentRay = ray;\n    Hit hit;\n    vec3 impactPoint;\n    float reflexionFactor = 1.0;\n    \n    bool atLeastOneHit = false;\n    \n    for (int i = 0 ; i < depth ; i++)\n    {\n        if(!Intersect(incidentRay, hit))\n        {\n            if (atLeastOneHit)\n                finalColor += Background(incidentRay.d) * reflexionFactor;\n            break;\n        }\n        \n        atLeastOneHit = true;\n        impactPoint = Point(incidentRay, hit.t);\n        MaterialPhong mat = PhongOfIndex(hit.i, impactPoint);\n        finalColor += Color(mat, incidentRay, hit) * reflexionFactor;\n        \n        reflexionFactor *= mat.reflectedFactor;\n        incidentRay.o = impactPoint + hit.n * 0.001;\n        incidentRay.d = reflect(incidentRay.d, hit.n);\n    }\n    \n    if (atLeastOneHit)\n        return finalColor;\n    else\n        return Background(ray.d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n   vec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n   // Mouse control\n   vec2 mouse = (vec2(1.0, 1.0) - iMouse.xy / iResolution.xy) * 2.;\n\n   // Ray origin\n   vec3 ro = 12. * normalize(vec3(sin(2. * 3.14 * mouse.x), cos(2. * 3.14 * mouse.x), 1.4 * (mouse.y - .1)));\n   vec3 ta = vec3(0., 0., 1.5);\n   mat3 ca = setCamera(ro, ta);\n\n   // Ray\n   vec3 rd = ca * normalize(vec3(uv.xy * tan(radians(22.5)), 1.));\n\n   // Lights\n   directionalLight[0] = DirectionalLight\n   (\n      normalize(vec3(-1.0, -1.0, -1.0)),\n        LightAttribs\n        (\n            vec3(1.0, 1.0, 1.0),\n            vec3(1.0, 1.0, 1.0),\n            vec3(1.0, 1.0, 1.0)\n        )\n   );\n   pointLight[0] = PointLight\n   (\n      vec3(2.0, 0.0, 10.0),\n        LightAttribs\n        (\n            vec3(1.0, 1.0, 1.0),\n            vec3(1.0, 1.0, 1.0),\n            vec3(1.0, 1.0, 1.0)\n        ),\n      float(0.03)\n   );\n    \n    planes[0] = Plane(vec3(0.0, 0.0, 1.0), 0,\n        Transform(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)));\n\n    spheres[0] = Sphere(1.0, 1,\n        Transform(vec3(2.0, -2.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)));\n    spheres[1] = Sphere(1.0, 3,\n        Transform(vec3(2.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)));\n    spheres[2] = Sphere(1.0, 4,\n        Transform(vec3(2.0, 2.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)));\n    spheres[3] = Sphere(2.0, 2,\n        Transform(vec3(-4.0, 0.0, 2.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)));\n\n    ellipsoids[0] = Ellipsoid(vec3(1.1, 1.0, 2.0), 3,\n        Transform(vec3(-2.0, -5.0, 2.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)));\n\n    boxes[0] = Box(vec3(2.0, 2.0, 2.0), 4,\n        Transform(vec3(-1.0, 3.0, 0.0), vec3(1.0, 1.5, 0.5), vec3(0.25 * 3.1415, 0.0, 0.0)));\n\n    circles[0] = Circle(1.0, -2.0, 1,\n        Transform(vec3(-2.0, -2.0, -3.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)));\n\n    cylinders[0] = Cylinder(4.0, 0.5, 1,\n        Transform(vec3(4.0, 3.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)));\n\n   // Render\n   viewDirection = normalize(rd); // View direction computation is important for Phong model shading\n   vec3 col = Shade(Ray(ro, rd), SHADING_DEPTH);\n\n   fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}