{"ver":"0.1","info":{"id":"4ssBzS","date":"1496739345","viewed":701,"name":"Infinite Zoom (tension)","username":"CriticalMammal","description":"A variation of a test, original code from Ebanflo's experiment: https://www.shadertoy.com/view/MdXBzS\n\nThe original effect was produced by sheepmaster, and contains a good overview for how all this works: https://www.shadertoy.com/view/4tcXDl","likes":21,"published":1,"flags":64,"usePreview":0,"tags":["fractal","quasicrystal","zoom","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldsSWH","filepath":"https://soundcloud.com/perera-elsewhere/karam-2","previewfilepath":"https://soundcloud.com/perera-elsewhere/karam-2","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int numWaves = 8;\nconst float numFreqs = 10.0;\nconst float meanFreq = 4.0;\nconst float stdDev = 1.5;\nconst float period = .32 * 4.;\nconst float ln2 = log(2.0);\nconst float mean = meanFreq * .69314718;\n\nfloat wavething(int n, float x){\n    float l = ln2 * float(n) + log(x);\n    l -= mean;\n    return exp(-l * l / stdDev) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 textureUV = fragCoord / iResolution.xy;\n    float pi = 4.0 * atan(1.0);\n\tfloat pi2 = 2.5 * pi;\n    \n    // oscillate numStripes based on time\n    float max = 1.;\n    float min = .23;\n    float oscilationRange = (max - min)/2.0;\n    float oscilationOffset = oscilationRange + min;\n    float numStripes = oscilationOffset + sin(iTime / period) * oscilationRange;\n    \n    // oscillate pi values for additional movement\n    max = 4.25 * atan(1.0);\n    min = 3.0 * atan(1.0);\n    oscilationRange = (max - min)/2.0;\n    oscilationOffset = oscilationRange + min;\n    pi = oscilationOffset + sin(iTime / period * 0.1) * oscilationRange;\n    pi2 = 2.5 * pi;\n    \n    \n    vec2 xy = pi2 * numStripes\n        * (2.0 * fragCoord.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0));\n    //xy -= pi2 * numStripes * (2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0));\n    \n    // oscillate position offset based on time (sloppy, can be done much cleaner)\n    vec2 xyCalc = pi2 * numStripes * (2.0 * vec2(0.0) / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0));\n    float xCalc = xyCalc.x;\n    float yCalc = xyCalc.y;\n    \n    max = xCalc * -0.025;\n    min = xCalc * 0.025;\n    oscilationRange = (max - min)/2.0;\n    oscilationOffset = oscilationRange + min;\n    float xVal = oscilationOffset + sin(iTime / 1.) * oscilationRange;\n    \n    max = yCalc * -0.025;\n    min = yCalc * 0.025;\n    oscilationRange = (max - min)/2.0;\n    oscilationOffset = oscilationRange + min;\n    float yVal = oscilationOffset + sin(iTime / .5) * oscilationRange;\n    \n    xy.x -= xVal;\n    xy.y -= yVal;\n    \n    // pattern calculations\n    float scale = exp2(-fract(iTime / period));\n    float sum1 = 0.0;\n    for(int n = 0; n < int(numFreqs); n++)\n    {\n        sum1 += wavething(n, scale);\n    }\n    float sum2 = 0.0;\n    for(int n = 0; n < numWaves; n++)\n    {\n        float theta = pi * float(n) / float(numWaves);\n        vec2 waveVec = vec2(cos(theta), sin(theta));\n        float phase = dot(xy, waveVec);\n        for(int k = 0; k < int(numFreqs); k++){\n            sum2 += cos(phase * scale * exp2(float(k))) * wavething(k, scale);\n        }\n    }\n    \n    // overal rgb tint\n    float rTint = 0.00;\n    float gTint = 0.75;\n    float bTint = 0.75;\n    fragColor = vec4(rTint, gTint, bTint, 1.0);\n    \n    // main zoom pattern rgb\n    float rVal = sum2 / sum1 * sin(iTime / period * .5);\n    float gVal = sum2 / sum1 * cos(iTime / period * .5);\n    float bVal = sum2 / sum1 * cos(iTime / period * .5);\n\tfragColor += vec4(rVal, gVal, bVal, 1.0);\n    \n    // the intensity of the rgb vals (just used to tone stuff down)\n    float rIntensity = 0.3;\n    float gIntensity = 0.3;\n    float bIntensity = 0.4;\n    fragColor = vec4(fragColor.r * rIntensity, fragColor.g * gIntensity, fragColor.b * bIntensity, 1.0);\n    \n    // apply texture to specific colors\n    float rTexAmt = 0.25;\n    float gTexAmt = 0.0;\n    float bTexAmt = 0.0;\n    vec3 col = texture(iChannel0, textureUV).rgb;\n    col.r *= fragColor.r * rTexAmt;\n    col.g *= fragColor.g * gTexAmt;\n    col.b *= fragColor.b * bTexAmt;\n    fragColor += vec4(col, 1.0);\n    \n    // apply vignette\n    float vignette = distance(textureUV, vec2(0.5));\n    vignette = mix(1.5, -0.5, vignette);\n    fragColor *= vignette;\n}","name":"Image","description":"","type":"image"}]}