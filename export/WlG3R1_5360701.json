{"ver":"0.1","info":{"id":"WlG3R1","date":"1578230987","viewed":192,"name":"20200105_heck","username":"FMS_Cat","description":"heck","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// (c) 2020 FMS_Cat, MIT License\n// The sequel of https://www.shadertoy.com/view/WtG3R1\n\n#define CELL_SIZE 0.02\n\n#define TWO_DIV_SQRT_THREE 1.15470053838\n#define SQRT_THREE_DIV_TWO 0.86602540378\n#define PI 3.14159265359\n#define saturate(i) clamp(i,0.,1.)\n#define linearstep(a,b,t) saturate(((t)-(a))/((b)-(a)))\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n//  _\n// / |\n// |_/\n\nvec2 uv2heck( in vec2 uv ) {\n    vec2 p = ( uv - 0.5 ) * iResolution.xy / iResolution.y / CELL_SIZE;\n    p.y *= SQRT_THREE_DIV_TWO;\n    p.y += 0.5 * p.x;\n    return p;\n}\n\nvec2 heck2uv( in vec2 p ) {\n    vec2 uv = p;\n    uv.y -= 0.5 * p.x;\n    uv.y *= TWO_DIV_SQRT_THREE;\n    uv = uv * CELL_SIZE * iResolution.y / iResolution.xy;\n    return uv + 0.5;\n}\n\nstruct Heck {\n    vec2 uv;\n    vec2 cellCoord;\n    float len;\n};\n\nHeck doHeck( in vec2 uv ) {\n    vec2 p = uv2heck( uv );\n    \n    vec2 nearestCell;\n    nearestCell.x = lofi( p.x, 1.0 );\n    nearestCell.y = lofi( p.y + nearestCell.x + 2.0, 3.0 ) - nearestCell.x - 2.0;\n    vec2 cellCoord = ( p - nearestCell ) - vec2( 0.0, 1.0 );\n    \n    bool isAboveCell = cellCoord.x < cellCoord.y; // above or right\n    nearestCell += isAboveCell ? vec2( 0.0, 2.0 ) : vec2( 1.0, 1.0 );\n    cellCoord += isAboveCell ? vec2( 0.0, -1.0 ) : vec2( -1.0, 0.0 );\n    \n    float len = max( abs( cellCoord.x ), max( abs( cellCoord.y ), abs( cellCoord.x - cellCoord.y ) ) );\n    \n    Heck heck;\n    heck.uv = heck2uv( nearestCell );\n    heck.cellCoord = cellCoord;\n    heck.len = len;\n    return heck;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    Heck heck = doHeck( uv );\n\n    float noise = texture( iChannel0, heck.uv ).x;\n    float wave = fract( 0.25 * ( iTime + heck.uv.y + 0.3 * noise ) );\n    float glow = sin( PI * exp( -12.0 * wave ) );\n    \n    float size = 0.7 * ( 1.0 - exp( -18.0 * wave ) );\n    \n    float border = linearstep(\n        0.0,\n        -2.0,\n        iResolution.y * CELL_SIZE * ( size - heck.len )\n    );\n    \n    vec3 col = mix( vec3( 0.0, 0.0, 0.0 ), vec3( 5.0, 0.3, 0.4 ), glow );\n    //col *= linearstep( 0.9, 0.7, heck.len );\n    \n    fragColor = vec4( mix( saturate( col ), vec3( 0.0 ), border ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}