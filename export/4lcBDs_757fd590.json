{"ver":"0.1","info":{"id":"4lcBDs","date":"1541447779","viewed":192,"name":"Zeta with reflection formula","username":"Justaway","description":"Zeta using alternating series approximation & reflection formula.  Large chunk of negative area is black because my gamma function doesn't extend far enough.  Would love if someone could provide me a better gamma function.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["zeta"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 20\n#define E 2.71828\n#define PI 3.14159\n\nconst float[20] ek = float[20](\n\t1048575.000000,1048555.000000,1048365.000000,\n    1047225.000000,1042380.000000,1026876.000000,\n    988116.000000,910596.000000,784626.000000,\n    616666.000000,431910.000000,263950.000000,\n    137980.000000,60460.000000,21700.001953,\n    6196.000488,1351.000122,211.000000,21.000000,1.000000);\n\nvec2 cpow(vec2 z1, vec2 z2)\n{\n\tfloat a2b2 = z1.x * z1.x + z1.y * z1.y;\n\tfloat t1 = pow(a2b2, z2.x / 2.0) * exp(-z2.y * atan(z1.y, z1.x));\n\tfloat t2 = z2.x * atan(z1.y, z1.x) + 0.5 * z2.y * log(a2b2);\n\treturn vec2(t1 * cos(t2), t1 * sin(t2));\n}\n\nvec2 cdiv(vec2 z1, vec2 z2)\n{\n\treturn z1 * mat2(z2, -z2.y, z2.x) / dot(z2, z2);\n}\n\nvec2 cprod(vec2 z1, vec2 z2)\n{\n\treturn vec2(\n\t\tz1.x * z2.x - z1.y * z2.y,\n\t\tz1.x * z2.y + z1.y * z2.x);\n}\n\nvec2 alt(int x)\n{\n\tfloat[2] tbl = float[2](1.0,-1.0);\n\treturn vec2(tbl[int(mod(float(x),2.0))],0.0);\n}\n\nvec2 cexp(vec2 z)\n{\n    return cpow(vec2(E,0.0),z);\n}\n\nvec2 csin(vec2 z)\n{\n    return cprod(vec2(0.0,0.5),cexp(cprod(vec2(0.0,-1.0),z))-cexp(cprod(vec2(0.0,1.0),z)));\n}\n\nvec2 ccos(vec2 z){\n    z += vec2(PI/2.0,0.0);\n    return cprod(vec2(0.0,0.5),cexp(cprod(vec2(0.0,-1.0),z))-cexp(cprod(vec2(0.0,1.0),z)));\n}\n\nconst float[8] p = float[8](\n  676.5203681218851,\n  -1259.1392167224028,\n  771.32342877765313,\n  -176.61502916214059,\n  12.507343278686905,\n  -0.13857109526572012,\n  9.9843695780195716e-6,\n  1.5056327351493116e-7\n);\n\nvec2 gammaR(vec2 z)\n{\n  z -= vec2(1.0,0.0);\n  vec2 x = vec2(0.99999999999980993,0.0);\n  vec2 pval;\n  for(int i = 0; i < 8; i++)\n  {\n    pval = vec2(p[i],0.0);\n    x += cdiv(pval,z+vec2(float(i)+1.0,0.0));\n  }\n  vec2 t = z + vec2(7.5,0.0);\n  vec2 y = cprod(cprod(cprod(vec2(sqrt(2.0*PI),0.0),cpow(t,z+vec2(0.5,0.0))),cexp(-t)),x);\n  return y;\n}\n\nvec2 gammaL(vec2 z)\n{\n  vec2 y = cdiv(vec2(PI,0.0),cprod(csin(cprod(vec2(PI,0.0),z)),gammaR(vec2(1.0,0.0)-z)));\n  return y;\n}\n\nvec2 gamma(vec2 z)\n{\n  if(z.x > 0.5)\n  {\n    return gammaR(z);\n  }\n  else\n  {\n    return gammaL(z);\n  }\n}\n    \nvec2 zeta(vec2 s)\n{\n\tvec2 sum1 = vec2(0.0);\n\tvec2 sum2 = vec2(0.0);\n\tvec2 k;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tk = vec2(float(i), 0.0);\n\t\tsum1 += cdiv(alt(i - 1), cpow(k , s));\n\t}\n\tfor(int i = N + 1; i <= 2 * N; i++)\n\t{\n\t\tk = vec2(float(i), 0.0);\n\t\tsum2 += cdiv(cprod(alt(i - 1), vec2(ek[i - N - 1],0.0)), cpow(k,s));\n\t}\n    sum2 = cdiv(sum2, vec2(pow(2.0, float(N)), 0.0));\n    return cdiv(sum1 + sum2,vec2(1.0, 0.0) - cpow(vec2(2.0 ,0.0), vec2(1.0, 0.0) - s));\n\treturn vec2(0.0);\n}\n\nvec4 gradient(float theta)\n{\n    vec4 color = vec4(0.0);\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec4 plotDomain(vec2 z)\n{\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    return gradient(theta) * (fract(log2(length(z))) / 2.0 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    vec2 z = uv * 15.0 + vec2(0.0, iTime * 2.0);\n    if(z.x > 0.0){\n    \tfragColor = plotDomain(zeta(z));\n    }else{\n        vec2 temp = zeta(vec2(1.0,0.0)-z);\n        temp = cdiv(temp,2.0*gamma(z));\n        temp = cprod(temp,cpow(vec2(2.0*PI,0.0),z));\n        temp = cdiv(temp,ccos(PI*z/2.0));\n        fragColor = plotDomain(temp);\n    }\n}","name":"Image","description":"","type":"image"}]}