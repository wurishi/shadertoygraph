{"ver":"0.1","info":{"id":"ctcyRS","date":"1699320729","viewed":67,"name":"Hot waves","username":"shiyuelai","description":"Hot waves","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hotwaves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 这里的center、r 你传进来\n\nvec2 center[10];       // = vec2(0.5);\nfloat radius[10];       // = 0.2; // 强调一下，传的是爆炸范围宽度与屏幕宽度比。\nfloat totalTime[10];    //\nfloat whRatio;          // 画布宽高比 \nfloat currentTime[10];  //\n\n\n\nfloat hash(ivec2 p)  \n{                        \n    int n = p.x * 3 + p.y * 113;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    float t = mod(float(n), 1000.0) * 0.001; \n    return -1.0+2.0 * t;\n}\n\nfloat noise(vec2 p)\n{\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n}\n\nvec2 getOffset(vec2 p, float time)\n{\n    vec2 result;\n    // 这里直接用你的uv\n    vec2 uv = p * vec2(whRatio, 1.0) + 0.4 * time;\n\tfloat f = 0.0;\n    uv *= 12.0;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\tf  = 0.5000 * noise(uv); uv = m*uv;\n\tf += 0.2500 * noise(uv); uv = m*uv;\n\tf += 0.1250 * noise(uv); uv = m*uv;\n\tf += 0.0625 * noise(uv); uv = m*uv;\n    result.x = 0.5 + 0.5 * f;\n    uv = p * vec2(whRatio,1.0) + 0.4 * time;\n    f = 0.0;\n    uv *= 12.0;\n\tf  = 0.5000 * noise(uv); uv = m*uv;\n\tf += 0.2500 * noise(uv); uv = m*uv;\n\tf += 0.1250 * noise(uv); uv = m*uv;\n\tf += 0.0625 * noise(uv); uv = m*uv;\n    result.y = 0.5 + 0.5*f;\n    return result;\n}\n\n\n//************** 这里设置波的参数 \nvoid init()\n{\n    for(int i = 0; i < 10; i++)\n    {\n       center[i] = vec2(0.0);\n       radius[i] = 0.0; \n       totalTime[i] = 0.0;\n       currentTime[i] = 0.0;\n    }\n    \n    center[0] = vec2(0.5);\n    radius[0] = 0.2;\n    totalTime[0] = 2.0;\n    currentTime[0] = 0.1;\n   \n    center[1] = vec2(0.2, 0.4);\n    radius[1] = 0.2;\n    totalTime[1] = 3.0;\n    currentTime[1] = 0.2;\n    \n    center[2] = vec2(0.7, 0.6);\n    radius[2] = 0.3;\n    totalTime[2] = 1.0;\n    currentTime[2] = 0.5;\n    \n    center[3] = vec2(0.8, 0.2);\n    radius[3] = 0.1;\n    totalTime[3] = 2.0;\n    currentTime[3] = 0.2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    /*\n       与cocos的参数适配\n    */\n    whRatio = iResolution.x / iResolution.y;\n    vec4 outColor = vec4(1.0);\n    init();\n    \n    /******\n       功能主体\n    *******/\n    vec2 v_uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = v_uv0;\n    for(int i = 0; i < 10; i++)\n    {\n        if(center[i].x < 0.001 && center[i].y < 0.001)\n        {\n           continue;\n        }\n        v_uv0 = uv;\n        currentTime[i] = iTime + currentTime[i];\n        float progress = mod(currentTime[i], totalTime[i]) / totalTime[i];  \n        vec2 r = radius[i] * vec2(1.0, whRatio);\n        // 波形参数计算\n        float speed = 0.2 * progress + 0.8 * sqrt(progress);\n        float wavePeakR = length(r) * 0.5 * speed;     // 波峰位置\n        float waveWidth = length(r) * 0.08;            // 波的宽度\n        float centerDis = length((v_uv0 - center[i]));    // 波心距离\n    \n        // 幅度计算\n        float degree = 0.0;\n        float peakOffset = abs(wavePeakR - centerDis);\n        if(peakOffset < waveWidth)\n        {\n           degree = (waveWidth - peakOffset) / waveWidth;\n        }\n    \n        float expend = 0.0;\n        if(speed < 0.3)\n        {\n           expend = 1.0 - abs(speed - 0.15) / 0.15;\n        }\n   \n        // barrel distortion\n        float runR = length(r) * 0.35;\n        float alpha = 1.0;\n        if(centerDis < runR)\n        {\n            expend = 1.0 - 0.4 * expend * expend * pow(centerDis / runR - 1.0, 2.0);\n        }\n        else\n        {\n            expend = 1.0;\n        }\n    \n        // waveDistorsion\n        vec2 waveOffset = (getOffset(v_uv0, currentTime[i])- 0.5) * 0.15 * sqrt(degree);  \n        if(centerDis < runR - 0.3)\n        {\n           waveOffset = vec2(0.0);\n        }\n        float waveLen = max(abs(v_uv0.x -  center[i].x) * 2.0 / r.x, abs(v_uv0.y -  center[i].y) * 2.0 / r.y); \n        waveLen = 1.0 - waveLen;\n        vec2 pos = center[i] + expend * (v_uv0 -  center[i]);\n        pos =  center[i] + expend * (v_uv0 -  center[i]);\n        waveLen = clamp(waveLen, 0.0, 1.0);\n        uv = clamp(pos + waveOffset * waveLen, 0.0, 1.0);\n    }\n    \n    outColor = texture(iChannel0, uv);\n    fragColor = outColor;\n}\n","name":"Image","description":"","type":"image"}]}