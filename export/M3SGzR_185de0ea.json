{"ver":"0.1","info":{"id":"M3SGzR","date":"1708098540","viewed":86,"name":"Star/Dust Texture Generation","username":"BearKirb","description":"Just experimenting.  If you find this useful for any special noise generation, feel free to take the code.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["procedural","texture","star","space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n fragColor.rgb=vec3(0);\n    // Output to screen\n    fragColor.rgb=vec3(texture(iChannel0,uv).b);\n    fragColor.b+=max(0.5-texture(iChannel0,uv+1.0).b,0.0)/10.0;\n    fragColor.b+=(0.1-texture(iChannel0,uv/3.0).b)/10.0;\n    fragColor.r+=(0.1-texture(iChannel0,uv/3.0).b)/10.0;\n    fragColor.a = 1.0;;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void Rotate( inout vec2 vector, float angle )\n{\n\tvector.x = cos(angle)*vector.x-sin(angle)*vector.y;\n    vector.y = sin(angle)*vector.x+cos(angle)*vector.y;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat PI=3.141592;\n  vec2 uv = fragCoord/iResolution.xy;\nfloat eps=10.0/iResolution.x;\nvec3 pix=vec3(texture(iChannel0,uv).r*2.0-1.0,texture(iChannel0,uv).g*2.0-1.0,texture(iChannel0,uv).b);\nvec3 prepix=vec3(texture(iChannel0,uv).r*2.0-1.0,texture(iChannel0,uv).g*2.0-1.0,texture(iChannel0,uv).b);\nvec3 n = texture(iChannel0,uv+vec2(0.0,eps)).rgb;\nvec3 e = texture(iChannel0,uv+vec2(eps,0.0)).rgb;\nvec3 s = texture(iChannel0,uv+vec2(0.0,-eps)).rgb;\nvec3 w = texture(iChannel0,uv+vec2(-eps,0.0)).rgb;\nvec2 dir= vec2(n.b,e.b);\nif(iFrame<140){\nif(iFrame==1){\nif(distance(vec2(0.5,0.5),uv)<0.01){\n pix = vec3(normalize(uv-vec2(0.5)).x,normalize(uv-vec2(0.5)).y,1.0);\n prepix = vec3(normalize(uv-vec2(0.5)).x,normalize(uv-vec2(0.5)).y,1.0);\n }else{\n vec2 ang=normalize(vec2(sin(uv.x*10.0),cos(uv.y*10.0)));\n pix=vec3(ang.x,ang.y,0.0);\n prepix=vec3(ang.x,ang.y,0.0);\n }\n}else{\nvec2 movAng=normalize(dir-pix.rg);\nvec2 movAng2=dir-pix.rg;\npix.b+=(n.b/1.0)*dot(normalize(prepix.rg),vec2(0,1));\n\npix.b+=(e.b/1.0)*dot(normalize(prepix.rg),vec2(1,0));\n\npix.b+=(s.b/1.0)*dot(normalize(prepix.rg),vec2(0,-1));\n\npix.b+=(w.b/1.0)*dot(normalize(prepix.rg),vec2(-1,0));\n\nRotate(pix.rg,(dot(normalize(pix.rg),normalize(movAng))/1.0));\nRotate(pix.gb,(length(dir-normalize(pix.rg))/1.0));\nRotate(pix.rb,length(dir-normalize(pix.rg))/1.0);\npix.b/=length(movAng2);\npix.rg*=0.3;\npix.b*=0.3;\n}\nfragColor.b = pix.b;\n   fragColor.rg = pix.rg/2.0+0.5;\n   fragColor.a=1.0;\n}else{\nfragColor.b = pix.b;\n   fragColor.rg = pix.rg/2.0+0.5;\n   fragColor.a=1.0;\n}\n   \n}","name":"Buffer A","description":"","type":"buffer"}]}