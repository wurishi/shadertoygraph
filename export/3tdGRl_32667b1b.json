{"ver":"0.1","info":{"id":"3tdGRl","date":"1577247753","viewed":107,"name":"Desert 3000","username":"onlinerocker","description":"Some fun terrain/stone structure generation using value noise.\n:)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","terrain","valuenoise","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define VIEW_DIST 50.0\n//change VIEW_DIST for farther or shorter render distance\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n    \n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n \n//https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n//https://www.shadertoy.com/view/4dS3Wd\n//slightly modified for octave spcification\nfloat fbm5(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat fbm3(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//iq\nfloat sdPlaneInf(vec3 pos, float y)\n{\n \treturn pos.y - y;   \n}\n\n//iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n//iq, modified color and made fog amount grow exponentially\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(distance*(0.001 / pow(clamp(VIEW_DIST / 70.0, 0.0, 1.0), 2.0))) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( \tvec3(0.8, 0.6, 0.2),\n        \t\t\t\t\tvec3(0.3, 0.6, 1.0),\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.specVal = 1.0;\n    o.specKs = 0.0;\n    o.dist = 1000.0;\n    o.normEps = 0.001;\n    o.color = vec3(0);\n    \n    vec3 planePos = pos;\n    float yVal = 3.0*fbm3(pos/4.0);\n    //float yVal = 6.0+5.0*sin(2.0*pos.x + pos.z);\n    planePos.y -= yVal;\n    float dPlane = sdPlaneInf(planePos, 0.0);\n    if(dPlane < o.dist)\n    {\n        o.dist = dPlane;\n        o.color = mix(vec3(194., 178., 128.)/255.0, vec3(133., 100., 50.)/255.0, fbm3(pos*100.0));\n    }\n    \n    vec3 bbPos = pos;\n    bbPos.x = mod(bbPos.x, -5.0);\n    bbPos.z = abs(bbPos.z);\n    \n   \tfloat bound = sdRoundBox(bbPos-vec3(-3.0,2.1,2.0), vec3(0.2, 3.0, 0.2), 0.1);\n    if(bound < o.dist)\n    {\n        vec3 pillPos = pos;\n        vec2 id = floor(pillPos.xz/5.0);\n        float h = sin(id.x) * 1337.0 * cos(id.y) * 420.69;\n        h = -0.5 + mod(h, 1.1);\n        \n        //pillPos.y += 0.15*fbm(pillPos*10.0) * smoothstep(0.7, 0.8, pillPos.y);\n        \n        pillPos.z -= sin(pillPos.y*2.0+2.0*iTime+id.x*id.y)*0.2*smoothstep(yVal, yVal+1.0, pillPos.y);\n        float dist = 0.1*fbm5(pillPos*5.0);\n        pillPos.z += dist;// * step(sin(pillPos.z) + cos(pillPos.x), 0.0);\n        pillPos.x += dist;// * step(sin(pillPos.z) + cos(pillPos.x), 0.0);\n\n        //red orbs to pillars?\n\n        pillPos.x = mod(pillPos.x, -5.0);\n        pillPos.z = abs(pillPos.z);\n        pillPos -= vec3(-3.0,1.1+h,2.0);\n        float dBox = sdRoundBox(pillPos, vec3(0.1, 3.0, 0.1), 0.1);\n        if(dBox < o.dist)\n        {\n            o.dist = dBox;\n            //o.dist = smin(o.dist, dBox, 0.2);      \n            o.difVal = 1.0;\n            o.color = mix(vec3(44,53,57)/255.0, vec3(194., 178., 128.)/255.0, fbm3(pos*200.0));\n            \n            o.specVal = 20.0;\n            o.specKs = 0.4;\n        }\n        \n    \n    }\n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n\n    for(int x=0; x<100; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        if(abs(o.dist) < 0.0001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nfloat marchSoftShadow(vec3 pos, Light l, float speed, float w)\n{\n \tMarchRes res;\n    Object o;\n    vec3 dir = normalize(l.pos);\n    float len = length(l.pos - pos);\n    float maxDist = len;\n    \n    res.totalDist = 0.001;\n\n    float sha = 1.0;\n    for(int x=0; x<200; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        sha = min( sha, 0.5*o.dist/(w*res.totalDist) );\n        if(sha < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist > maxDist) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\t\n    \n    sha = max(sha,0.0);\n    return sha*sha*(3.0-2.0*sha);\n}\n\nfloat calcShadowSoft(vec3 pos, Light l)\n{\n    //MarchRes res;\n    float val;\n    val = marchSoftShadow(pos, l, 1.0, 0.05); //march slower to prevent shadow artifacts\n\treturn val;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   \n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    //lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n      \n    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(-iTime,3.0,0.0);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float camAng = PI/2.0;//-iMouse.x/20.0;//\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamX = mat2( vec2(cos(camAng), sin(camAng)), vec2(-sin(camAng), cos(camAng)) );\n\n    //vec2 camXZ = rotCam * camEye.xz;\n    //camEye = vec3(camXZ.x, camEye.y, camXZ.y);\n    vec2 dirXZ = rotCam * dir.xz;\n    dir = vec3(dirXZ.x, dir.y, dirXZ.y);\n    \n    Light light;\n    light.intensity = 0.5;\n    light.pos = vec3(10, 3, 0.0);\n    light.color = vec3(1.0, 0.8, 0.65);\n    \n    Light lightSky;\n    lightSky.intensity = 3.1;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(0.1, 0.1, 0.1);\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    float y = uv.y + 1.0;\n    y = y / 1.62;\n    y = clamp(y, 0.7, 1.0);\n    \n    y = smoothstep(1.1, 0.5, y);\n    vec3 col = (vec3(0.8, 0.6, 0.2)*(y) + vec3(0.3, 0.6, 1.0)*(1.0-y));\n    col += vec3(0.8, 0.6, 0.2)*smoothstep(sqrt(length(uv)), sqrt(length(uv))+0.05, 0.3);\n\n    vec3 bg = col;\n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, vec3(0)) * calcShadowSoft(pos, light) + calcDiffuseLight(res.obj, lightSky, vec3(0,0,0));\n        col += calcSpecLight(res.obj, light,pos, camEye) * calcShadowSoft(pos, light);\n        col = applyFog(col, length(pos)-iTime, normalize(pos), normalize(light.pos - pos));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}