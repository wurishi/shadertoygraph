{"ver":"0.1","info":{"id":"3sd3Rl","date":"1609263360","viewed":385,"name":"Noise plasma 2","username":"jolle","description":"Noise plasma using multiple overlain gradient noise values.\n\nPretty costly, no tricks for hash / noise etc.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","plasma","gradient","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Simple but robust hash function\n// From https://stackoverflow.com/a/12996028\nuint hash(uint x)\n{\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = (x >> 16u) ^ x;\n    return x;\n}\n\n// Combine hash values\n// Based on Boost's hash_combine\n// Note: While this is decent for general hashing, it has visual artifacts in many graphical uses, but works well in this case\nuint combine(uint v, uint seed)\n{\n    return seed ^ (v + 0x9e3779b9u + (seed << 6) + (seed >> 2));\n}\n\n// Construct an uniform float in 0.0-1.0 range from bits given\n// Based on method described in https://stackoverflow.com/a/17479300\nfloat uniformFloat(uint h)\n{\n    return uintBitsToFloat(h & 0x007FFFFFu | 0x3F800000u) - 1.0;\n}\n\n// Construct \"random\" normal based on position and seed\nvec3 normal(vec3 p, uint seed)\n{\n    uvec3 u = floatBitsToUint(p);\n    seed = combine(hash(u.x), seed);\n    seed = combine(hash(u.y), seed);\n    seed = combine(hash(u.z), seed);\n\tfloat a = uniformFloat(seed);\n    seed = combine(0x6d04955du, seed);\n    float z = uniformFloat(seed) * 2.0 - 1.0;\n    float s = sqrt(1.0 - z * z);\n    return vec3(s * cos(a * 6.2831853 + vec2(0.0, -1.570796)), z);\n}\n\n// Regular smoothstep\nvec3 ss(vec3 x)\n{\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// Gradient noise from position and seed\nfloat gnoise(vec3 p, uint seed)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 a = ss(f);\n    float n000 = dot(normal(i, seed), f);\n    float n100 = dot(normal(i + vec3(1.0, 0.0, 0.0), seed), f - vec3(1.0, 0.0, 0.0));\n    float n010 = dot(normal(i + vec3(0.0, 1.0, 0.0), seed), f - vec3(0.0, 1.0, 0.0));\n    float n110 = dot(normal(i + vec3(1.0, 1.0, 0.0), seed), f - vec3(1.0, 1.0, 0.0));\n    float n001 = dot(normal(i + vec3(0.0, 0.0, 1.0), seed), f - vec3(0.0, 0.0, 1.0));\n    float n101 = dot(normal(i + vec3(1.0, 0.0, 1.0), seed), f - vec3(1.0, 0.0, 1.0));\n    float n011 = dot(normal(i + vec3(0.0, 1.0, 1.0), seed), f - vec3(0.0, 1.0, 1.0));\n    float n111 = dot(normal(i + vec3(1.0, 1.0, 1.0), seed), f - vec3(1.0, 1.0, 1.0));\n    return mix(\n        mix(mix(n000, n100, a.x), mix(n010, n110, a.x), a.y),\n        mix(mix(n001, n101, a.x), mix(n011, n111, a.x), a.y), a.z);\n}\n\n// 3 element (separate) gradient noise values from position and seeds\nvec3 gnoise3(vec3 p, uvec3 seed)\n{\n    return vec3(gnoise(p, seed.x), gnoise(p, seed.y), gnoise(p, seed.z));\n}\n\n// Modified noise value used\n// Peaks at 1.0 for 0.0 noise values and go down linearly by distance from it\nvec3 n(vec3 p, uvec3 seed)\n{ \n    return max(1.0 - abs(gnoise3(p, seed) * 1.5), vec3(0.0));\n}\n\n// Non-linear transforms used below\nvec3 q(vec3 v)\n{\n    return pow(v, vec3(1.0, 1.0, 3.5));\n}\n\nvec3 r(vec3 n)\n{\n    return pow(n, vec3(6.0, 9.0, 9.0));\n}\n\n// Typical complex noise, but non-linear, using values and transforms above,\n// as well as masking octaves by previous ones, and using different factors\nvec3 cnoise(vec3 p)\n{\n\tvec3 n0 = n(p * 1.0, uvec3(0xa7886e74u, 0x4433f369u, 0x5842edddu));\n    vec3 n1 = n(p * 2.0, uvec3(0x41a2b27au, 0x14dede03u, 0x509a02aau));\n    vec3 n2 = n(p * 4.0, uvec3(0xd5bf21b3u, 0x1d6adb70u, 0xc47ed64cu));\n    vec3 n3 = n(p * 8.0, uvec3(0x7279fef1u, 0x120a704eu, 0x845b7178u));\n    vec3 n4 = n(p * 16.0, uvec3(0xace62131u, 0x7e861b25u, 0x9f51d60cu));\n    return (\n        n1 * r(n0) * 0.25 +\n        q(n0) * r(n1) * vec3(0.25, 0.25, 0.5) +\n        q(n0 * n1) * r(n2) * vec3(0.125, 0.125, 0.5) +\n        q(n0 * n1 * n2) * r(n3) * vec3(0.0625, 0.0625, 0.5) +\n        q(n0 * n1 * n2 * n3) * r(n4) * vec3(0.03125, 0.03125, 0.5)\n    ) * 1.06667;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.25 * fragCoord / iResolution.y;\n    float t = 0.25 * iTime + 80.0;\n    vec3 n = cnoise(vec3(uv, t));\n\n    // Add the 3 complex noise values together with different colors\n    fragColor = vec4(\n        vec3(0.3, 0.0, 0.0) +\n        vec3(0.7, 0.2, 0.2) * n.x + \n        vec3(0.1, 0.2, 0.1) * n.y +\n        vec3(0.9, 0.9, 2.7) * n.z, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}