{"ver":"0.1","info":{"id":"7tsBDS","date":"1651450570","viewed":262,"name":"Pathtracing attempt","username":"Krafpy","description":"My attempt to the path tracing of spheres.\nInspired from : https://raytracing.github.io/books/RayTracingInOneWeekend.html","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["lighting","spheres","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Use the mouse to rotate around.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Calculate the average color of all samples\n    vec4 data = texture(iChannel0, uv);\n    vec3 col = data.rgb/data.w;\n    \n    // Gamma correction\n    col = pow(col, vec3(0.5));\n    col = clamp(col, 0., 1.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n#define TWO_PI 6.283185307\n#define HALF_PI 1.57079632675\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Hit {\n    int id;\n    vec3 p;\n    vec3 n;\n    float t;\n};\n\nstruct Material {\n    vec3 albedo;\n    bool is_metal;\n    float fuzz;\n    bool is_glass;\n    float ref_idx;\n    vec3 phong; // kd, ks, shinniness\n};\n\n// 2D rotation matrix\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// Ray / sphere intresection function\n// Returns the distance to the closest intersection point\n// Negative if no intersection\nfloat sphere_itsc(Ray ray, vec4 sph){\n    vec3 c = sph.xyz;\n    float r = sph.w;\n    vec3 co = ray.ro - c;\n    \n    float b = dot(co, ray.rd);\n    float d = b*b - dot(co, co) + r*r;\n    if(d < 0.){\n        return -1.;\n    }\n    \n    float sd = sqrt(d);\n    vec2 t = vec2(-b-sd,-b+sd);\n    if(t.x < 0.) return t.y;\n    return t.x;\n}\n\n// Ray / plane (centered at (0,0,0)) intersection\n// Returns the distance to the closest intersection point\n// Negative if no intersection\nfloat plane_itsc(Ray ray, vec3 n){\n    return -dot(ray.ro, n) / dot(ray.rd, n);\n}\n\n// Returns the normal vector at the point\nvec3 sphere_normal(vec3 p, vec4 sph){\n    return normalize(p - sph.xyz);\n}\n\n// Soft shadow casted by a sphere, from : https://iquilezles.org/articles/sphereshadow/\nfloat sphere_shadow(vec3 ro, vec3 rd, vec4 sph, float k){\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n\n    float d = -sph.w + sqrt( max(0.0,sph.w*sph.w-h));\n    float t = -b     - sqrt( max(0.0,h) );\n    return (t < 0.) ? 1. : smoothstep(0., 1., k*d/t );\n}\n\n// Computes the Fresnel coefficient at a hit point\nfloat fresnel(Ray ir, Hit hit, float eta){\n    float r0 = (1.-eta)/(1.+eta);\n    r0 *= r0;\n    float cos_t = dot(-ir.rd, hit.n);\n    cos_t = clamp(cos_t, 0., 1.);\n    return r0 + (1.-r0) * pow(1.-cos_t, 5.);\n}\n\n// Hash functions from : https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat hash31(vec3 p)\n{\n    p  = fract(p * .1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);\n}\n\nvec2 hash12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n// from : https://www.shadertoy.com/view/3sj3Rt\nvec3 random_on_sphere(vec3 p) {\n  float f = hash31(p);\n  \n  float theta = TWO_PI * hash21(vec2(f * 0.3482f, f * 2.18622f));\n  float phi = acos(1.0f - 2.f * hash21(vec2(f * 1.9013, f * 0.94312)));\n  float x = sin(phi) * cos(theta);\n  float y = sin(phi) * sin(theta);\n  float z = cos(phi);\n  return vec3(x,y,z);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 sun_dir = normalize(vec3(0.8, 0.5, -1.));\nconst vec3 sun_col = vec3(1., 1., 1.);\n\n// List of spheres in the scene (x, y, z, r)\nvec4 spheres[] = vec4[](\n    vec4(0, 0.5, 0, 0.5),         // Red sphere\n    vec4(1.5, 0.801, -0.5, 0.8),  // Glass sphere\n    vec4(-1.0, 0.7, -1.3, 0.7),   // Green sphere\n    vec4(0.8, 0.3, 1., 0.3),      // Sliver sphere\n    vec4(-1., 0.3, -0.2, 0.3),    // Blue sphere\n    vec4(-1., 0.5, 1., 0.5)       // Gold sphere\n);\n\n// materials[id] is the material of the object with this id\nconst Material materials[] = Material[](\n    // Ground\n    Material(vec3(0.7), true, 0.5, false, 0., vec3(1., 2., 10.)),\n    // Red sphere\n    Material(vec3(0.8, 0.3, 0.3), false, 0., false, 0., vec3(0.5, 0, 0)),\n    // Glass sphere\n    Material(vec3(1., 1., 1.), false, 0., true, 1.4, vec3(0.,1.,100.)),\n    // Green sphere\n    Material(vec3(0.4, 0.7, 0.3), true, 0.5, false, 0., vec3(1.,0.5,50.)),\n    // Sliver sphere\n    Material(vec3(0.8, 0.8, 0.8), true, 0.2, false, 0., vec3(1.,2.,72.)),\n    // Blue sphere\n    Material(vec3(0.3, 0.2, 0.9), false, 0., false, 0., vec3(1.,0.,0.)),\n    // Gold sphere\n    Material(vec3(0.8, 0.6, 0.1), true, 0.05, false, 0., vec3(1.,20.,1000.))\n);\n\n\n// Simply a contained if selection\nvoid choose_closest(float test_t, int test_id, inout float t, inout int id){\n    if(test_t > 0. && test_t < t){\n        t = test_t;\n        id = test_id;\n    }\n}\n\n// Returns true if the ray hits something in the scene\n// and stores the hit infos in the passed 'hit' argument\nbool world_itsc(Ray ray, inout Hit hit){\n    float t = 10000.;\n    int id = -1;\n    \n    vec3 gnd = vec3(0,1,0); // ground plane normal\n    \n    choose_closest(plane_itsc(ray, gnd), 0, t, id);\n    for(int i = 0; i < 6; i++){\n        vec4 sph = spheres[i];\n        choose_closest(sphere_itsc(ray, sph), i + 1, t, id);\n    }\n    \n    vec3 p = ray.ro + ray.rd * t;\n    vec3 n = gnd;\n    if(id > 0){\n        n = sphere_normal(p, spheres[id-1]);\n    }\n    hit = Hit(id, p, n, t);\n    \n    return id >= 0;\n}\n\n// Returns the background color for a given direction\nvec3 background(Ray ray){\n    vec3 ca = vec3(0.95, 0.85, 0.65);\n    vec3 cb = vec3(0.4, 0.7, 1.);\n    float f = dot(ray.rd, vec3(0,1,0));\n    f = max(0., f);\n    f = pow(f, 0.3);\n    vec3 col = mix(ca, cb, f);\n    \n    f = dot(ray.rd, sun_dir);\n    f = max(0., f);\n    float k = smoothstep(0.9, 0.999, f*f);\n    col += vec3(1.,0.8,0.4)*k*0.1;\n    col += step(0.9997, f);\n    \n    return clamp(col, 0., 1.);\n}\n\n// Soft shadows : 0 if light is fully blocked, 1 if no shadows\nfloat shadow(Hit hit){\n    Ray ray = Ray(hit.p + hit.n * 0.001, sun_dir);\n    float s = 1.;\n    for(int i = 0; i < 6; i++){\n         s *= sphere_shadow(ray.ro, ray.rd, spheres[i], 12.);\n    }\n    return s;\n}\n\nvec3 direct_lighting(Ray ir, Hit hit, Material mat, vec3 surf_col){\n    // Blinn Phong reflection model (omitting ambiant light)\n    \n    float kd = mat.phong.x;\n    float ks = mat.phong.y;\n    float sh = mat.phong.z;\n    \n    vec3 v = normalize(ir.ro - hit.p);\n    vec3 r = reflect(-sun_dir, hit.n);\n    vec3 h = normalize(sun_dir + v);\n    \n    float diff = kd * max(0., dot(sun_dir, hit.n));\n    float spec = ks * pow(max(0., dot(hit.n, h)), sh);\n    \n    float cos_t = dot(h, sun_dir);\n    vec3 r0 = mat.is_metal ? surf_col : vec3(0.1);\n    vec3 fre = r0 + (1. - r0)*pow(clamp(1.-cos_t, 0.,1.), 5.);\n    \n    float shad = shadow(hit);\n    \n    vec3 col = vec3(0.);\n    if(!mat.is_metal) col += surf_col * sun_col * diff * shad;\n    col += sun_col * diff * spec * shad * fre;\n    \n    return clamp(col, 0., 1.);\n}\n\n\nRay lambert_scatter(Ray ir, Hit hit, Material mat){\n    vec3 ro, rd; \n    rd = hit.n + random_on_sphere(hit.p + iTime);\n    if(dot(rd, rd) < 0.001){\n        rd = hit.n;\n    }\n    rd = normalize(rd);\n    ro = hit.p + hit.n * 0.001;\n    return Ray(ro, rd);\n}\n\n\nRay metal_scatter(Ray ir, Hit hit, Material mat){\n    vec3 rd = reflect(ir.rd, hit.n);\n    vec3 f = mat.fuzz * random_on_sphere(hit.p + iTime);\n    rd = normalize(rd + f);\n    vec3 ro = hit.p + hit.n * 0.001;\n    return Ray(ro, rd);\n}\n\nRay glass_scatter(Ray ir, Hit hit, Material mat){\n    vec3 rd, ro;\n    float eta = mat.ref_idx;\n    \n    if(dot(ir.rd, hit.n) < 0.) {\n        // outside the sphere\n        eta = 1. / eta;\n        if(fresnel(ir, hit, eta) > hash31(hit.p + iTime)){\n            rd = reflect(ir.rd, hit.n);\n            ro = hit.p + hit.n * 0.001;\n        } else {\n            rd = refract(ir.rd, hit.n, eta);\n            ro = hit.p - hit.n * 0.001;\n        }\n    } else {\n        // inside the sphere\n        rd = refract(ir.rd, -hit.n, eta);\n        ro = hit.p + hit.n * 0.001;\n    }\n    \n    return Ray(ro, rd);\n}\n\nvec3 surface_texture(Hit hit){\n    if(hit.id == 0){\n        // Checker texture\n        vec2 uv = mod(hit.p.xz, 1.);\n        float sx = step(0.5, uv.x);\n        float sy = step(0.5, uv.y);\n        float s = step(abs(sx-sy), 0.);\n        s = clamp(s, 0.25, 1.);\n        vec3 dark = vec3(0.5, 0.4, 0.4);\n        vec3 clea = vec3(1., 1., 1.);\n        return s*clea + (1.-s)*dark;\n    }\n    return vec3(1.);\n}\n\n// Calculates the color of one ray sample\nvec3 render(Ray ray){\n    const int depth = 12; // number of rays\n    \n    vec3 col_mask = vec3(1.);\n    vec3 acc_col = vec3(0.);\n    \n    for(int i = 0; i < depth; i++){\n        Hit hit;\n        if(world_itsc(ray, hit)){\n            Material mat = materials[hit.id];\n            \n            vec3 surf_col = mat.albedo * surface_texture(hit);\n            acc_col += direct_lighting(ray, hit, mat, surf_col * col_mask);\n            col_mask *= surf_col;\n            \n            if(mat.is_metal){\n                ray = metal_scatter(ray, hit, mat);\n            } else if(mat.is_glass) {\n                ray = glass_scatter(ray, hit, mat);\n            } else {\n                ray = lambert_scatter(ray, hit, mat);\n            }\n            \n        } else {\n            acc_col += col_mask * background(ray);\n            break;\n        }\n    }\n    \n    return acc_col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 data = texture(iChannel0, uv);\n    if(iFrame == 0 || iMouse.z > 0.) data = vec4(0.);\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    // Camera position\n    vec3 eye = vec3(0., 1., 4.5);\n    vec3 lookat = vec3(0., 0.5, 0.);\n    vec3 eyedir = eye - lookat;\n    \n    // Mouse rotation\n    vec2 mr = iMouse.xy/iResolution.xy;\n    mr -= 0.5;\n    mr.x *= iResolution.x / iResolution.y;\n    mr *= 3.141592;\n    mr.y = min(0., mr.y);\n    \n    eyedir.yz *= rot(mr.y);\n    eyedir.xz *= rot(mr.x);\n    \n    eye = lookat + eyedir;\n    \n    \n    // Antialias\n    float num_samples = 5.;\n    \n    for(float i = 0.; i < num_samples; i++){\n        vec3 ro = eye;\n        \n        // Randomize pixel sample direction\n        vec2 rnd = 0.001 * (-1. + 2.*hash12(i+iTime));\n        vec3 rd = normalize(vec3(uv + rnd, -1.));\n        \n        // Camera angle\n        rd.yz *= rot(mr.y);\n        rd.xz *= rot(mr.x);\n        \n        Ray ray = Ray(ro, rd);\n        col += render(ray);\n    }\n    \n    col /= num_samples;\n    col = clamp(col, 0., 1.);\n    \n    data += vec4(col, 1.);\n    \n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}