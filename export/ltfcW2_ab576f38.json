{"ver":"0.1","info":{"id":"ltfcW2","date":"1506572782","viewed":310,"name":"Temporal Jittering","username":"felixwang","description":"Temproal Jittering with halton sequence. Halton(2,3) on the left and Halton(5) on the right.\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["halton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TILE_SIZE 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 frac = vec2(int(fragCoord.x) % TILE_SIZE, int(fragCoord.y) % TILE_SIZE);\n    //if(frac.x == 0.0f || frac.y == 0.0f)\n        //fragColor = vec4(1, 1, 1, 1);\n    //else\n\t\tfragColor = texture(iChannel0, uv);// vec4(coord, 0,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TILE_SIZE 32.0f\n#define WEIGHT 0.95f\n\nint FaurePermutation[125] = int[125]( 0, 75, 50, 25, 100, 15, 90, 65, 40, 115, 10, 85, 60, 35, 110, 5, 80, 55,\n30, 105, 20, 95, 70, 45, 120, 3, 78, 53, 28, 103, 18, 93, 68, 43, 118, 13, 88, 63, 38, 113, 8, 83, 58, 33, 108,\n23, 98, 73, 48, 123, 2, 77, 52, 27, 102, 17, 92, 67, 42, 117, 12, 87, 62, 37, 112, 7, 82, 57, 32, 107, 22, 97,\n72, 47, 122, 1, 76, 51, 26, 101, 16, 91, 66, 41, 116, 11, 86, 61, 36, 111, 6, 81, 56, 31, 106, 21, 96, 71, 46,\n121, 4, 79, 54, 29, 104, 19, 94, 69, 44, 119, 14, 89, 64, 39, 114, 9, 84, 59, 34, 109, 24, 99, 74, 49, 124);\n\n\nfloat Halton5(const int Index)\n{\n\t// 依次提取0-2,3-5,6-8，9-11位的digits左右翻转并移到小数点右边\n\treturn float(FaurePermutation[Index % 125] * 1953125 + FaurePermutation[(Index / 125) % 125] * 15625 +\nFaurePermutation[(Index / 15625) % 125] * 125 +\nFaurePermutation[(Index / 1953125) % 125]) * ((1.0f - 1e-127f) / float(244140625));\n}\n\nfloat IntegerRadicalInverse(int Base, int i)\n{\n\tint numPoints, inverseB;\n\tnumPoints = 1;\n\t// 此循环将i在\"Base\"进制下的数字左右Flip\n\tfor(inverseB = 0; i > 0; i /= Base)\n\t{\n\t\tinverseB = inverseB * Base + (i % Base);\n\t\tnumPoints = numPoints * Base;\n\t}\n\n\t// 除以Digit将这个数镜像到小数点右边\n\treturn float(inverseB) / float(numPoints);\n}\n\nvec2 Halton5Coord(vec2 id, int seed)\n{\n    int indexY = seed % 25;\n    int indexX = indexY % 5;\n    indexY /= 5;\n    float coordX = Halton5(indexX) + 0.1;\n    float coordY = Halton5(indexY) + 0.1;\n    \n    return vec2(coordX, coordY);\n}\n\nvec2 Halton23Coord(vec2 id, int seed)\n{    \n    int indexX = (int(id.x) + seed) % 16 + 1;\n    int indexY = (int(id.y) + seed) % 16 + 1;\n    float coordX = IntegerRadicalInverse(2, indexX);\n    float coordY = IntegerRadicalInverse(3, indexY);\n    \n    return vec2(coordX, coordY);\n}\n\nvec2 Halton23CoordFull(vec2 id, int seed)\n{    \n    int indexX = (int(id.x) + seed) + 1;\n    int indexY = (int(id.y) + seed) + 1;\n    float coordX = IntegerRadicalInverse(2, indexX);\n    float coordY = IntegerRadicalInverse(3, indexY);\n    \n    return vec2(coordX, coordY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 id = floor(fragCoord.xy / TILE_SIZE);\n    vec2 gridSize = TILE_SIZE / iResolution.xy;\n    vec2 gridCount = ceil(iResolution.xy / TILE_SIZE);\n    \n    vec2 localCoord;\n    \n    float scale = 60.0;\n    \n    if(id.y == 0.0)\n    {\n        scale = 1.0;\n    }\n    \n    int seed = int(iTime * scale); \n    \n    float sliceWidth = floor(gridCount.x / 5.0f);\n    float sliceIndex = floor(id.x / sliceWidth); \n\tif(sliceIndex == 0.0f || sliceIndex == 1.0f)\n        localCoord =Halton23CoordFull(vec2(0, 0), seed);\n    else if(sliceIndex == 3.0f || sliceIndex == 4.0f)\n    \tlocalCoord =Halton5Coord(id, seed);\n    \n    vec2 coord =  localCoord / gridCount + id * gridSize;\n    vec2 dist = (coord - uv) * iResolution.xy;\n    \n    vec4 originalColor = texture(iChannel1, uv);\n    vec4 lastColor = texture(iChannel0, coord);\n    vec4 actualColor = texture(iChannel1, coord);  \n    \n    if(id.y == 0.0)\n    {           \n    \tif(length(dist) < 1.0f)\n    \t\tfragColor = texture(iChannel0, uv) + vec4(1, 1,1.0,1.0);\n    \telse\n        \tfragColor = texture(iChannel0, uv);  \n    }\n    else\n    {\n        if(sliceIndex == 2.0f)\n            fragColor = originalColor; //First slice - original color\n        if(sliceIndex == 0.0f)\n            fragColor = lastColor * WEIGHT + actualColor * (1.0f - WEIGHT);//actualColor; //First slice - original color\n        if(sliceIndex == 1.0f)\n        \tfragColor = lastColor * WEIGHT + actualColor * (1.0f - WEIGHT);\n        if(sliceIndex == 3.0f)\n            fragColor = lastColor * WEIGHT + actualColor * (1.0f - WEIGHT);//actualColor; //First slice - original color\n        if(sliceIndex == 4.0f)\n        \tfragColor = lastColor * WEIGHT + actualColor * (1.0f - WEIGHT);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define TILE_SIZE 32.0f\n#define HALF_SIZE TILE_SIZE/2.0f\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 id = floor(fragCoord.xy / TILE_SIZE);\n    vec2 gridSize = TILE_SIZE / iResolution.xy;\n    vec2 gridCount = ceil(iResolution.xy / TILE_SIZE);\n    vec2 localId = fragCoord - id * TILE_SIZE;\n    \n    vec4 color = vec4(0, 0, 0, 1);\n        \n    if(localId.x > HALF_SIZE )\n        color += vec4(1, 0, 0, 0);\n    \n    if(localId.y > HALF_SIZE)\n        color += vec4(0, 1, 0, 0);\n    \n    int count = int(fragCoord.y) % int(TILE_SIZE);\n    \n    float val = float(count);\n    if(int(id.y) % 2 == 0)\n        val = TILE_SIZE - float(count);\n    \n    val /= TILE_SIZE;\n    fragColor = vec4 (val, val, val, 1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}