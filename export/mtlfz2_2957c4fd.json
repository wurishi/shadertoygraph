{"ver":"0.1","info":{"id":"mtlfz2","date":"1693229640","viewed":74,"name":"Implicit SDF 1d slice","username":"Envy24","description":"See Image tab header.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["template","implicit","plotter","graphs","explicit"],"hasliked":0,"parentid":"ctlBz2","parentname":"Circle SDF 1d slice (compare)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    This shader shows implicit sdf approximation (blue).\n    Also this shader shows how comlicate sdf can be)\n    \n    Blue and green function equal to zero exactly where teal line intersects with shape.\n    \n    Drag teal line with mouse.\n*/\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 1.5 )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cell\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx);\n    return SMAA(abs(sdf) / dsdx);\n    //return SMAA(abs(sdf) / dsdx - 0.05); // thick\n                           \n}\nfloat draw_implicit_func(vec2 NDC, float fxy, vec2 grad) \n{ \n    float L2_norm_g = sqrt(grad.x*grad.x + grad.y*grad.y);\n    return SMAA(abs(fxy) / L2_norm_g); \n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n\n/* Some ugly test function */\nfloat dsm_rpow(float x, float y) {\n    if (x >= 0.0) return pow(x,y);\n    else {\n        float m = mod(y, 2.0);\n        if (m == 0.0) return pow(-x, y);\n        else if (m == 1.0) return -pow(-x, y);\n        else return pow(x, y);\n    }    \n}\nfloat glesmos_f0(float x, float y) { return (((((0.8)*(dsm_rpow((tanh(((1.4)*(sin(((5.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))))),(4.0))))+(dsm_rpow((sin(((atan(y,x))+((2.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))),(2.0))))-(0.7))+((0.1)/((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0))))));}\n/* Some ugly test function */\n\n// Implicit function definition.\nfloat implicit(float x, float y) \n{ \n    return glesmos_f0(x, y);\n    //return sin(x+y)-cos(x*y)+1.0;\n    //return x * y * (abs(x) + abs(y) - 1.);\n    //return pow(3.*x*x - y*y, 2.)*y*y - pow(x*x + y*y, 4.);\n    //return pow(x*x + y*y, 2.) - 2.*(x*x - y*y);\n    //return tan(x*y*sin(y*x)*cos(x*x)) ;\n    //return cos(x*x) + sin(y*x);\n    //return cos(x * y) + y * sin(x);\n    //return sin(y)+cos(x);\n    //return sin(x*4.) - y;\n}\nfloat delf_delx(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dx=0.001;\n    return ( implicit(x+dx, y)-implicit(x-dx, y) ) / (2.*dx);\n}\nfloat delf_dely(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dy=0.001;\n    return ( implicit(x, y+dy)-implicit(x, y-dy) ) / (2.*dy);\n}\nvec2 implicit_gradient(float x, float y) { return vec2(delf_delx(x, y), delf_dely(x, y)); }\n\nfloat y = 0.;\n// Explicit function definition.\nfloat explicit(float x) \n{  \n    vec2 g = implicit_gradient(x, y);\n    float f_xy = implicit(x, y),\n          L2_norm_g = sqrt(g.x*g.x + g.y*g.y),\n          approx = f_xy / L2_norm_g;\n\n    return approx;\n}\nfloat explicit_dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return ( explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n}    \n  \n    \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n         \n         y = MP.y;\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         //color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n\n    /* Explicit function y=f(x) */\n    color = mix(color, vec3(0,0,1), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n         \n    /* Implicit function f(x,y) */\n         color = mix(color, vec3(1,0,0), draw_implicit_func(NDC, implicit(NDC.x, NDC.y), implicit_gradient(NDC.x, NDC.y)));\n\n    /* */\n        color = mix(color, vec3(0,.5,.5), SMAA(horizontal_lineSDF(NDC, MP.y)));\n        \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}