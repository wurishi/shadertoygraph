{"ver":"0.1","info":{"id":"DsBcRD","date":"1687740689","viewed":35,"name":"Raytrace Practice","username":"devdeltek","description":"translated raytracer I wrote for a graphics programming class from js. Its not well optimized and very basic, but it's a start. I changed the shading to be discrete to fit in a more cartoony style suited for a simple approach.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Create a struct to define a ray, has an origin and direction\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n//create a struct to define a  light, has a color and direction\nstruct Light {\n    vec3 color;\n    vec3 position;\n};\n\n\n//defines material properties for objects, such as color, diffuse weight, and specular weight\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n};\n\n\n//defines a plane with a normal vector and valid point, as well as a material\nstruct Plane {\n    vec3 normal;\n    vec3 validPoint;\n    Material material;\n};\n\n//defines a sphere with a center point, radius, and material\nstruct Sphere {\n    vec3 center;\n    float radius;\n    Material material;\n};\n\n//struct to be returned by intersection methods, has a \n//bool hit for if it was hit or not\n//vec3 point to hold the location of the intersection\n//vec3 normal to hold a normal vector from object at the point of intersection\n//float distance to hold the distance from the camera\n//Material material to hold material information of the object hit\nstruct Raycast {\n    bool hit;\n    vec3 point;\n    vec3 normal;\n    float dist;\n    Material material;\n};\n\n\n//Was not able to get Intersection method from original javascript project to work, borrowed from Polytonic's project\nRaycast intersection(Ray r, Sphere s){\n    vec3 oc = s.center - r.origin;\n    float l = dot(r.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(s.radius, 2.0);\n    if (det < 0.0) return Raycast(false, vec3(0.0), vec3(0.0), 0.0, Material(vec3(1.0, 0.0, 0.0), 0.0, 0.0));\n\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return Raycast(false, vec3(0.0), vec3(0.0), 0.0, Material(vec3(1.0, 0.0, 0.0), 0.0, 0.0));\n    vec3 originOffset = r.direction * len;\n    return Raycast(true, r.origin + originOffset, normalize((r.origin + originOffset) - s.center), len, s.material); \n}\n\n//calculates the intersection between a ray and a plane\nRaycast intersection(Ray r, Plane p){\n    float numerator = -dot(r.origin, p.normal);\n    float denom = dot(r.direction, p.normal);\n    \n    float alpha = numerator / denom;\n    if(alpha >= 0.0){\n        return Raycast(true, (r.origin + (r.direction * alpha)), p.normal, alpha, p.material);\n    }\n    \n    return Raycast(false, vec3(0.0), vec3(0.0), 0.0, Material(vec3(0.0), 0.0, 0.0));\n    \n}\n\n//finds the nearest intersection for a ray, if it exists\nRaycast trace(Ray r) {\n    const int num_spheres = 2;\n    Sphere spheres[num_spheres];\n    \n    spheres[0] = Sphere(vec3(1.0, 3.0, 2.0), 2.0, Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\n    spheres[1] = Sphere(vec3( -2.0 + cos(iTime), 3.0, -2), 3.0,  Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\n    \n    Raycast intersect = Raycast(false, vec3(0.0), vec3(0.0), 0.0, Material(vec3(0.0), 0.0, 0.0));\n    \n    float shortestDist = -1.0;\n    \n    Raycast plane = intersection(r, Plane(vec3(0, 1, 0), vec3(1, 0, 0), Material(vec3(0.5, 0.8, 0.5), 1.0, 0.0)));\n    if (plane.hit && (shortestDist > plane.dist || shortestDist < 0.0) && plane.dist > 0.0) {\n        intersect = plane;\n        shortestDist = plane.dist;\n    }\n    for (int i = 0; i < num_spheres; i++) {\n        Raycast sphere = intersection(r, spheres[i]);\n        if (sphere.hit && (shortestDist > sphere.dist || shortestDist < 0.0) && sphere.dist > 0.0){\n            intersect = sphere;\n            shortestDist = sphere.dist;\n        }\n    }\n    return intersect;\n}\n\n\n//calculates the color to return for a given pixel based on lighting conditions\nvec3 radiance(Ray r) {\n    Light light = Light(vec3(1.0,1.0,1.0), vec3(cos(iTime)*5.0,7.0,sin(iTime)*5.0));\n\n    vec3 color = vec3(0.0);\n    Raycast hit = trace(r);\n\n    if(hit.hit){\n        vec3 shadowOrigin = hit.point + (hit.normal * 0.1);\n        vec3 shadowDirection = light.position-hit.point;\n        float shadowDistance = length(shadowDirection);\n        Ray shadowRay = Ray(shadowOrigin, normalize(shadowDirection));\n    \n        Raycast shadow = trace(shadowRay);\n        if(!shadow.hit){\n            float normalDotLight = dot(normalize(hit.normal), normalize(shadowDirection));\n            return hit.material.color * max(ceil(normalDotLight*4.0)/4.0, 0.1);\n        }\n    }\n    \n    \n    return hit.material.color * .1;\n}\n\n\n//creates a ray for each pixed to draw the scene\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\n    \n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n    fragColor = vec4(radiance(ray), 1.0);\n}","name":"Image","description":"","type":"image"}]}