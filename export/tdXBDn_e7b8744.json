{"ver":"0.1","info":{"id":"tdXBDn","date":"1708282186","viewed":51,"name":"NURBS --------<<<","username":"ArmanD","description":"Nurbs.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["n"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define mx        \tiMouse.x/iResolution.y\n#define my        \tiMouse.y/iResolution.y\n#define DEGREE 2\n#define MAX_DIST 2.\nvec3 point(vec2 uv ,vec2 pos){\nvec3 col = vec3(0.,0.,0.);\n    if(distance(uv,pos)<0.03 && distance (uv,pos)>0.025){\n    \n    col = vec3(1.,1.,1);\n    }\n    return col;\n}\nvec3 pointB(vec2 uv ,vec2 pos){\nvec3 col = vec3(0.,0.,0.);\n    if(distance(uv,pos)<0.035 && distance (uv,pos)>0.020){\n    \n    col = vec3(0.,0.,1);\n    }\n    return col;\n}\nvec3 pointV(vec2 uv ,vec2 pos){\nvec3 col = vec3(0.,0.,0.);\n    if(distance(uv,pos)<0.035 && distance (uv,pos)>0.020){\n    \n    col = vec3(0,1,0);\n    }\n    return col;\n}\nvec3 line (vec2 uv,vec2 p1,vec2 p2){\nvec3 col = vec3(0.,0.,0.);\n    vec2 v1 = uv - p1 ;\n    vec2 v2 = uv - p2 ;\n    vec2 v = v1 -v2;\n\t\tfloat a = acos(\t\tdot(v,v1) /dot(length(v),length(v1))\t);    \n    \n    float h = sin(a)*length(v1);\n    if( h<0.005&&dot(normalize(v1),normalize(v2))<0.9){\n        col = vec3(1.,0.,0.);\n    }\n    return col;\n}\nvec3 lineI (vec2 uv,vec2 p1,vec2 p2){\nvec3 col = vec3(0.,0.,0.);\n    vec2 v1 = uv - p1 ;\n    vec2 v2 = uv - p2 ;\n    vec2 v = v1 -v2;\n\t\tfloat a = acos(\t\tdot(v,v1) /dot(length(v),length(v1))\t);    \n    \n    float h = sin(a)*length(v1);\n    if( h<0.005/*&&dot(normalize(v1),normalize(v2))<0.9*/){\n        col = vec3(1.,0.,0.);\n    }\n    return col;\n}\n\n\n/*float N(int j,float t,float[Tsize] T){\n    \n    int D = n;\n float N = 0.;if(T[j]<=t&&t<T[j+1]){N=1.;}\n    float Nprev= N;\n    float Nprev2 = 0.;if(T[j+1]<=t&&t<T[j+1+1]){Nprev2=1.;}\n    \n    for(int i=0;i<D;i++){\t\t\t\t\t\t\t\t\t\t\t\n       \tfloat a = \t (t-T[j]);\t\n        float b = (T[j+D]-T[j]);  \n        float c = (T[j+D+1]-t);\n        float d = (T[j+D+1]-T[j+1]);\n       \t\t float A = a/b ; \t\t\t\tif( b==0.){A = a;}\n       \t\t float B = c/d ; \t\t\t\tif( d==0.){B = c;}\n        \n        N  = A * Nprev + B * Nprev2;\n        float a2 = \t (t-T[j+1]);\t\n        float b2 = T[j+1+D]-T[j+1];\n        float c2 = (T[j+1+D+1]-t);\n        float d2 = (T[j+1+D+1]-T[j+1+1]);\n      \t\t  \tfloat A2 = a2/b2;\t\t\t if( b2==0.){A2 = a2;}\n        \t\tfloat B2 =  c2/d2;\t\t\t if( d2==0.){B2 = c2;}\n        \n    \tNprev2 =  ( A2 ) * Nprev +( B2 ) * Nprev2;\n        Nprev = N;\n    }\nreturn N;\n}*/\nconst int CPcount =9;\nconst int n=DEGREE; //--------------------------------------------------------------------------------------n\nconst int Tsize = n+CPcount+1;\nvec3 getColor(float t , float[Tsize] T){\nvec3 col = vec3(0.25);\n    \n    for(int i=0;i<Tsize-1;i++){\n        float t1 = T[i]; float t2 = T[i+1];\n        float f = float(i),fm = float(Tsize);\n    if(t>= t1 && t< t2){col += vec3(  f/fm  );}\n    }\nreturn col;\n}\n////////////////////////////////---------------------------------------------------------------------\nfloat N0(int j,float t,float[Tsize] T){\n\tfloat N0 = 0.;\n    if(T[j]<=t && t<T[j+1]){N0 = 1.;}\n    \n    \nreturn   N0 ;\n\n}\nfloat N1(int j,float t,float[Tsize] T){\n    float a = (T[j+1]-T[j]);\t if(a == 0.){a =1.;}\n    float b = (T[j+1+1]-T[j+1]); if(b == 0.){b =1.;}\nreturn   ( (t-T[j]) / a ) * N0(j,t,T)    +   ( (T[j+1+1]-t) / b ) * N0(j+1,t,T) ;\n\n}\nfloat N2(int j,float t,float[Tsize] T){\n    float a = (T[j+2]-T[j]);\t if(a == 0.){a =1.;}\n    float b = (T[j+2+1]-T[j+1]); if(b == 0.){b =1.;}\n    return ( (t-T[j]) / a ) * N1(j,t,T)    +   ( (T[j+2+1]-t) / b ) * N1(j+1,t,T);\n    \n}\nfloat N2D(int j,float t,float[Tsize] T){\n\tfloat a = (T[j+2]-T[j]);\t if(a == 0.){a =1.;}\n    float b = (T[j+2+1]-T[j+1]); if(b == 0.){b =1.;}\n    return ( 2. / a ) * N1(j,t,T)   -   ( 2. / b ) * N1(j+1,t,T);\n}\nfloat N3(int j,float t,float[Tsize] T){\n    float a = (T[j+3]-T[j]);\t if(a == 0.){a =1.;}\n    float b = (T[j+3+1]-T[j+1]); if(b == 0.){b =1.;}\n    return ( (t-T[j]) / a ) * N2(j,t,T)    +   ( (T[j+3+1]-t) / b ) * N2(j+1,t,T);\n    \n}\n/*\nfloat N4(int j,float t,float[Tsize] T){\n    float a = (T[j+4]-T[j]);\t if(a == 0.){a =1.;}\n    float b = (T[j+4+1]-T[j+1]); if(b == 0.){b =1.;}\n    return ( (t-T[j]) / a ) * N3(j,t,T)    +   ( (T[j+4+1]-t) / b ) * N3(j+1,t,T);\n    \n}\nfloat N5(int j,float t,float[Tsize] T){\n    float a = (T[j+5]-T[j]);\t if(a == 0.){a =1.;}\n    float b = (T[j+5+1]-T[j+1]); if(b == 0.){b =1.;}\n    return ( (t-T[j]) / a ) * N4(j,t,T)    +   ( (T[j+5+1]-t) / b ) * N4(j+1,t,T);\n    \n}*/\n\n//Derviatives :\nvec2 NurbsDeriv(float t,float[CPcount] w,vec2 p[CPcount],float T[Tsize]){\n    \n    vec2 sumP = vec2(0.),sumNoP = vec2(0.),sumPDeriv = vec2(0.),sumNoPDeriv = vec2(0.);  \n    \n     for(int i=0;i<CPcount;i++){\n\t\tfloat N = N2(i,t,T);\n         float ND = N2D(i,t,T);\n        sumP += w[i]*p[i]*N;\n   \t\tsumNoP += w[i]*N;\n        sumPDeriv +=w[i]*p[i]*ND;\n        sumNoPDeriv += w[i]*ND;\n    }\n   \n  return  vec2 (  (sumPDeriv*sumNoP) / (sumNoP*sumNoP)  )  -  (  (sumP*sumNoPDeriv) / (sumNoP*sumNoP)   );\n    \n    \n}\nfloat sqrtd(float x ){ return 1./(2.*sqrt(x));}\n\n\n//-------------------------------\n\nvec2 Nurbs(float t, float[CPcount] w,vec2 p[CPcount],float T[Tsize]){\n    vec3 col = vec3(0.);\n    \n             vec2 sumP = vec2(0.),sumNoP = vec2(0.) ;  \n    \n     for(int i=0;i<CPcount;i++){\n\t\tfloat N = N2(i,t,T);\n        sumP += w[i]*p[i]*N;\t\n   \t\tsumNoP += w[i]* N;\n    }//*/\n   \n   \n    vec2 eq =  sumP/sumNoP ;\n    \n\n \n    return eq;\n\n}\n\n/*float d0(int j,float[CPcount] p){\n    \n    return d= p[j];\n     \n}\nfloat d1(int j,float[CPcount] p){\n    int D =1;\nfor(int i=j-D;i<j;i++){\n        for(int r=1;i<D++){\n        \ti+=r;\n            a= t-T[i]/\n        }\n    }  \n}//*/\n\nvec2[2] deBoorDeriv(int j,float t,float[CPcount] w,vec2[CPcount] p,float[Tsize] T){\n    \n    vec2[n+1] d,dDeriv; float[n+1] d2,d2Deriv;\n    for(int i=0;i<n+1;i++){\n        int idx = i+j-n;  \n        float w = w[idx];\n    d[i]= p[idx] * w;\n    d2[i]= w;\n    dDeriv[i] = d[i];\n    d2Deriv[i] = d2[i];\n    }//*/\n    for (int r=1;r<n+1;r++){\n        for(int i=n;i>r-1;i--){ \n            float left = T[i+j-n];\n            float u = (t - left), v = (T[i+1+j-r] - left);//--\n            float alpha = u / v;\n            d[i] = (1.0 - alpha) * d[i-1] + alpha * d[i];\n            d2[i] = (1.0 - alpha) * d2[i-1] + alpha * d2[i];\n             //--\n            float uP= 1.;\t\t\t  //,vP= 0.;         \n            float alphaD = ( uP * v  /* +   u * vP*/)  /  (v*v);\n            dDeriv[i] =  -alphaD * d[i-1]+  (1.0 -alpha)*dDeriv[i-1]\n                + (\talphaD * d[i] +  alpha * dDeriv[i]\t);\n    \t\td2Deriv[i] = -alphaD * d2[i-1]+  (1.0 -alpha)*d2Deriv[i-1]\n                + (\talphaD * d2[i] +  alpha * d2Deriv[i]\t);\n        }}\n    \t//float alphaD = -1./( T[n+1+j+n] - T[n+j-n] );\n   //*/\n    \n    vec2 u = d[n];\n    vec2 ud = dDeriv[n];\n    float v = d2[n];\n    float vd = d2Deriv[n];\n\n    vec2 deriv =  (ud*v - u * vd )/(v*v);//*/\n    return vec2[](u/v,deriv);\n}//*/\n\nvec2 deBoor(int j,float t,float[CPcount] w,vec2[CPcount] p,float[Tsize] T){\n    \n    vec2[n+1] d; float[n+1] d2;\n    for(int i=0;i<n+1;i++){\n        int idx = i+j-n;  \n        float w = w[idx];\n    d[i]= p[idx] * w;\n    d2[i]= w;\n    }\n    for (int r=1;r<n+1;r++){\n        for(int i=n;i>r-1;i--){ \n            float alpha = (t - T[i+j-n]) / (T[i+1+j-r] - T[i+j-n]);\n            d[i] = (1.0 - alpha) * d[i-1] + alpha * d[i];\n            d2[i] = (1.0 - alpha) * d2[i-1] + alpha * d2[i];\n        }}\n    \n    return d[n]/(d2[n]);\n    \n}\nvec2 NURBS(float t,float[CPcount] w,vec2[CPcount] p,float[Tsize] T){\n     int i = 0;\n    /*for(int k=0;k<CPcount+1;k++){\n            if(t>= T[k] && t<T[k+1]){\n               r = deBoor(k,t,w,p,T);\n            }\n     }//*/\n    for(i=0;i<CPcount+1;i++){\n            if(t>= T[i] && t<T[i+1]){\n             break;\n            } \n     } \nreturn deBoor(i,t,w,p,T);\n}\nvec2[2] NURBS_DERIV(float t,float[CPcount] w,vec2[CPcount] p,float[Tsize] T){\n    vec2[2] r;  \n\n        int i = 0;\n    for(i=0;i<CPcount+1;i++){\n            if(t>= T[i] && t<T[i+1]){\n             break;\n            } \n     } \nreturn deBoorDeriv(i,t,w,p,T);\n}\nvec2[3] getRootFactorExprF(float v1,float v2,float v3){\nfloat a = v1, b= v2, c= v3;\n    float D = b*b -4.*a*c;\n    \n    vec2[] roots = vec2[2](vec2(0.),vec2(0.));\n    if(D>0.){ \t\troots[0] = vec2(  (-b-sqrt(D)) /(2.*a) ,0.);\n        \t  \t\troots[1] = vec2(  (-b+sqrt(D)) /(2.*a) ,0.);     \n     }else if(D == 0.){\n    \t\t\t\troots[0] = vec2(  (-b) /(2.*a) ,0.);\n        \t  \t\troots[1] = roots[0];\n    }else{\n    \t\troots[0] = vec2( -b/(2.*a),  -sqrt(D)/2.*a ) ;\n        \troots[1] = vec2( -b/(2.*a),  sqrt(D)/2.*a ) ;\n    }\n    \n    \n    return vec2[](vec2(a,0.), roots[0],  roots[1] );\n}//*/\nvec4[3] getRootFactorExprV2(vec2 v1, vec2 v2,vec2 v3){\n\n    vec2[] X = getRootFactorExprF(v1.x,v2.x,v3.x);\n    vec2[] Y = getRootFactorExprF(v1.y,v2.y,v3.y);\n\t\n     \n    return vec4[](vec4(X[0].x,Y[0].y,X[0].y,Y[0].y),  vec4(X[1].x,Y[1].y,X[1].y,Y[1].y),\n                 vec4(X[2].x,Y[2].y,X[2].y,Y[2].y) );\n}//*/\nvec4[4] mul3x2Fact(vec4[3] v1, vec2[2] v2){\nreturn vec4[](\t v1[0]*vec4(v2[0],vec2(0.)),  v1[1],  v1[2],  vec4(v2[1],vec2(0.))\t); \n}\n/*vec4[4] sub(vec4[4],vec4[4]){\nreturn \n}//*/\nvec2[31] getDeBoorPolynomialD2(int k,float[CPcount] W,vec2[CPcount] p,float[Tsize] Tk){\n    int l=2,r=2;\t\t\t\t//l=i  k=j\n    \t\t\tfloat a1 = (1.) / (Tk[l+1+k-r] - Tk[l+k-n]);\n    \t\t\tfloat b1 = (Tk[l+k-n]) / (Tk[l+1+k-r] - Tk[l+k-n]);\n    l=1;  r=1;\n    \t\t\tfloat a2 = (1.) / (Tk[l+1+k-r] - Tk[l+k-n]);\n    \t\t\tfloat b2 = (Tk[l+k-n]) / (Tk[l+1+k-r] - Tk[l+k-n]);\n    l=2;  r=1;\n    \t\t\tfloat a3 = (1.) / (Tk[l+1+k-r] - Tk[l+k-n]);\t\t\n\t\t\t\tfloat b3 = (Tk[l+k-n]) / (Tk[l+1+k-r] - Tk[l+k-n]);\n\n    vec2[n+1] pw; vec2[n+1] w;\n    for(int i=0;i<n+1;i++){\n        int idx = i+k-n;  \n        float weight = W[idx];\n    pw[i]= p[idx] * weight;\n    w[i]= vec2(weight,weight);\n    }\n    \n    vec2 A = (a1*a2)*pw[0]+(-a1*a2)*pw[1]+(-a1*a3)*pw[1]+(a1*a3)*pw[2],\n\tB = (-a1*b2-a1-b1*a2-a2)*pw[0] + (a1*b2+b1*a2+a2 )*pw[1] + (a1*b3+a1+b1*a3 )*pw[1]+ (-a1*b3 - b1*a3 )*pw[2],\n    C = (b1*b2+b1+b2+1.)*pw[0] + (-b1*b2-b2)*pw[1]  + (-b1*b3-b1)*pw[1] + (b1*b3)*pw[2];\n    \n    vec2 D = (a1*a2)*w[0]+(-a1*a2)*w[1]+(-a1*a3)*w[1]+(a1*a3)*w[2],\n\tE = (-a1*b2-a1-b1*a2-a2)*w[0] + (a1*b2+b1*a2+a2 )*w[1] + (a1*b3+a1+b1*a3 )*w[1]+ (-a1*b3 - b1*a3 )*w[2],\n    F = (b1*b2+b1+b2+1.)*w[0] + (-b1*b2-b2)*w[1]  + (-b1*b3-b1)*w[1] + (b1*b3)*w[2];\n    \n    /*vec4[] U = getRootFactorExprV2(A,B,C);\n    vec4[] V = getRootFactorExprV2(D,E,F);\n    \n    //deriv\n    vec2 a = 2.*A ,b = B; \n    vec2[] UP = vec2[](a, -b/a);\n    a = 2.*D; b = E; \n    vec2[] VP = vec2[](a, -b/a);\n\n    \n   /* vec4[] VxUP = mul3x2Fact(V,UP);\n    vec4[] UxVP = mul3x2Fact(U,VP);\n    vec4[] VxUP_UxVP = sub(VxUP,UxVP);//*/\n    \n    vec2 ad = 2.*A, bd = B;\n    vec2 dd = 2.*D, ed = E;\n    \n    vec2 G =D*ad - A*dd;\n    vec2 H =(D*bd+E*ad) - (A*ed+B*dd);\n    vec2 I =(E*bd+F*ad) - (B*ed+C*dd);\n    vec2 J =(F*bd) - (C*ed);\n    //v*v \n    vec2 K = D*D;\n    vec2 L = 2.*D*E;\n    vec2 M = E*E + 2.*D*F;\n    vec2 N = 2.*E*F;\n    vec2 O = F*F;\n    \n    //second deriv \n    vec2 gd = 3.*G, hd = 2.*H, id = 2.*I;//u'\n    vec2 kd = 4.*K, ld = 3.*L, md = 2.*M, nd = N;//v'\n    //u'v - uv'\n    vec2 P = gd*K - G*kd,\n        Q = (gd*L+hd*K) - (G*ld+H*kd)\t,\n        R = (hd*L+gd*M+id*K) - (H*ld+G*md+I*kd),\n        S = (id*L+gd*N+hd*M) - (G*nd+I*ld+H*md+J*kd),\n        T = (id*M+gd*O+hd*N) - (J*ld+H*nd+I*md),        \n    \tU = (id*N+hd*O) - (I*nd+J*md),\n    \tV = (id*O) - J*nd;\n    //v*v\n    vec2 V1 = K*K,\n        V2 = 2.*K*L,\n    \tV3 = L*L + 2.*K*M,\n    \tV4 = 2.*K*N + 2.*L*M,\n        V5 = 2.*K*O + M*M + 2.*L*N,\n        V6 = 2.*L*O + 2.*M*N,\n        V7 = N*N + 2.*M*O,\n        V8 = 2.*N*O,\n        V9 = O*O;\n    \nreturn vec2[](A,B,C,   D,E,F, \t\t\t G,H,I,J,   K,L,M,N,O,     \t\tP,Q,R,S,T,U,V,  V1,V2,V3,V4,V5,V6,V7,V8,V9 );\n}//*/\n\nvec2 NURBS_POLY(float t,float[CPcount] w,vec2[CPcount] p,float[Tsize] T){\n\tint i=0;\n    for(i=0;i<CPcount+1;i++){\n            if(t>= T[i] && t<T[i+1]){\n             break;\n            } \n     } \n        vec2[] DBP = getDeBoorPolynomialD2(2,w,p,T);\n\n    return (DBP[0]*t*t+DBP[1]*t+DBP[2])\n        \t\t\t /\n        (DBP[3]*t*t + DBP[4]*t+DBP[5]);\n}\nvec2[2] NURBS_POLY_DERIV(float t,float[CPcount] w,vec2[CPcount] p,float[Tsize] T){\n\tint i=0;\n    for(i=0;i<CPcount+1;i++){\n            if(t>= T[i] && t<T[i+1]){\n             break;\n            } \n     } \n        vec2[] DBP = getDeBoorPolynomialD2(2,w,p,T);\n\n    return vec2[]((DBP[0]*t*t+DBP[1]*t+DBP[2]) / (DBP[3]*t*t + DBP[4]*t+DBP[5]),\n                  (DBP[6]*t*t*t+DBP[7]*t*t+DBP[8]*t+DBP[9])//*pow(float(i),6.) \n                  //(DBP[6]*t+DBP[7])\n                  /\n                  (DBP[10]*t*t*t*t+DBP[11]*t*t*t+DBP[12]*t*t+DBP[13]*t+DBP[14]));\n                  //(DBP[8]*t+DBP[9]));\n}\nvec2[3] NURBS_POLY_2ND_DERIV(float t,float[CPcount] w,vec2[CPcount] p,float[Tsize] T){\n\tint i=0;\n    for(i=0;i<CPcount+1;i++){\n            if(t>= T[i] && t<T[i+1]){\n             break;\n            } \n     } \n        vec2[] DBP = getDeBoorPolynomialD2(2,w,p,T);\n\n    return vec2[]((DBP[0]*t*t+DBP[1]*t+DBP[2]) / (DBP[3]*t*t + DBP[4]*t+DBP[5]),\n                  (DBP[6]*t*t*t+DBP[7]*t*t+DBP[8]*t+DBP[9])\n                  \t\t\t\t\t\t/\n                  (DBP[10]*t*t*t*t+DBP[11]*t*t*t+DBP[12]*t*t+DBP[13]*t+DBP[14]),\n                 \t(DBP[15]*pow(t,6.)+DBP[16]*pow(t,5.)+DBP[17]*t*t*t*t+DBP[18]*t*t*t+DBP[19]*t*t+DBP[20]*t+DBP[21])\n                 \t\t\t\t\t\t\t/\n(DBP[22]*pow(t,8.)+DBP[23]*pow(t,7.)+DBP[24]*pow(t,6.)+DBP[25]*pow(t,5.)+DBP[26]*t*t*t*t+DBP[27]*t*t*t+DBP[28]*t*t\n \t\t\t\t\t+DBP[29]*t+DBP[30]));\n}\n\nfloat[6] mul3x4(float[3] f3,float[4] f4){\nfloat a = f3[0],b = f3[1],c = f3[2],   \t\td = f4[0],e = f4[1],f = f4[2],g = f4[3];\n    \n    return float[]( a*d,  (a*e+b*d),  (a*f+b*e+c*d),  (a*g+b*f+c*e),  (b*g+c*f), c*g );\n}\nfloat[7] mul3x5(float[3] f3,float[5] f5){\nfloat a = f3[0],b = f3[1],c = f3[2],   \t\td = f5[0],e = f5[1],f = f5[2],g = f5[3], h= f5[4];\n    \n    return float[]( a*d,  (a*e+b*d),  (a*f+b*e+c*d),  (a*g+b*f+c*e),  (a*h+b*g+c*f), (b*h+c*g), c*g );\n}\nfloat[4] mul(float f,float[4] f4){\nreturn float[](  f4[0]*f,   f4[1]*f,   f4[2]*f,  f4[3]*f  );\n}\nfloat[1] getDistPoly(vec2 uv,float[CPcount] w,vec2[CPcount] p,float T[Tsize]){\n    int i =2;\n\t\t        vec2[] DBP = getDeBoorPolynomialD2(i,w,p,T);\n\tfloat[] ax= float[](DBP[0].x,DBP[1].x,DBP[2].x);\n    float[] bx= float[](DBP[3].x,DBP[4].x,DBP[5].x);\n    float[] adx= float[](DBP[6].x,DBP[7].x,DBP[8].x,DBP[9].x);\n    float[] bdx= float[](DBP[10].x,DBP[11].x,DBP[12].x,DBP[13].x,DBP[14].x);\n    \n    float[] ay= float[](DBP[0].y,DBP[1].y,DBP[2].y);\n    float[] by= float[](DBP[3].y,DBP[4].y,DBP[5].y);\n    float[] ady= float[](DBP[6].y,DBP[7].y,DBP[8].y,DBP[9].y);\n    float[] bdy= float[](DBP[10].y,DBP[11].y,DBP[12].y,DBP[13].y,DBP[14].y);\n    \n    //(ax/bx)-uv.x) * (adx/bdx) \t+\t  (ay/by)-uv.y) * (ady/bdy)\n    //=(ax*adx)/(bx*bdx) - (uv.x*adx)/bdx  + (\t(ay*ady)/(by*bdy) - (uv.y*ady)/bdy\t)\n    //   Ax^      Bx^         Cx^                  Ay^     By^          Cy^\n    float[] Ax = mul3x4(ax,adx);\n    float[] Bx = mul3x5(bx,bdx);\n    float[] Cx = mul(uv.x,adx);\n    \n    float[] Ay = mul3x4(ay,ady);\n    float[] By = mul3x5(by,bdy);\n    float[] Cy = mul(uv.y,ady);\n\t\n    //( Ax/Bx - Cx/bdx )  +  ( Ay/By - Cy/bdy )\n    //= (Ax*bdx - Cx*Bx)/(Bx*bdx)  +(  (Ay*bdy - Cy*By)/(By*bdy)   )\n    \n    \n    \n    \n\treturn float[](0.);\n}\nfloat getDistDeriv(vec2 uv,float[CPcount] w,vec2[CPcount] p,float t,float T[Tsize]){\n   /* \tvec2[] ND = NURBS_DERIV(t,w,p,T);\n   vec2 NURBS = ND[0];\n    vec2 NurbsDeriv = ND[1];\n    float Deriv = sqrtd(pow(NURBS.x - uv.x,2.)+pow(NURBS.y - uv.y,2.)) \n       *  (  2.*(\tNURBS.x - uv.x )*(NurbsDeriv.x - 0.)  \t\n                 +   2. *(\tNURBS.y - uv.y )*(NurbsDeriv.y - 0.)  \n                );\n\t\t\t\t\t//*/ \n   \n    vec2[] NP = NURBS_POLY_DERIV(t,w,p,T);\n    float nx = NP[0].x,\n    ny = NP[0].y,\n    ndx=NP[1].x,\n    ndy=NP[1].y;\n    \n    float Deriv = (\t(nx-uv.x)*(ndx) + (ny-uv.y)*(ndy) ) / sqrt((nx-uv.x)*(nx-uv.x)+(ny-uv.y)*(ny-uv.y));\n    \t\t\t/*sqrtd(pow(nx - uv.x,2.)+pow(ny - uv.y,2.)) \n       *  (  2.*(\tnx - uv.x )*(ndx - 0.)  \t\n                 +   2. *(\tny - uv.y )*(ndy - 0.)  \n                );*/\nreturn Deriv;\n\n}\nfloat getDist2ndDeriv(vec2 uv,float[CPcount] w,vec2[CPcount] p,float t,float T[Tsize]){\n\n   \n    vec2[] NP = NURBS_POLY_2ND_DERIV(t,w,p,T);\n    float nx = NP[0].x,\n    ny = NP[0].y,\n    ndx=NP[1].x,\n    ndy=NP[1].y,\n    nddx=NP[2].x,\n    nddy=NP[2].y;\n    \n    float U = (nx-uv.x)*(ndx) + (ny-uv.y)*(ndy),\n        V = sqrt((nx-uv.x)*(nx-uv.x)+(ny-uv.y)*(ny-uv.y)),\n        UP = ndx*ndx + (nx-uv.x)*nddx\t+\tndy*ndy + (ny-uv.y)*nddy,\n        VP = (\t(nx-uv.x)*(ndx) + (ny-uv.y)*(ndy) ) / sqrt((nx-uv.x)*(nx-uv.x)+(ny-uv.y)*(ny-uv.y));\n    \nreturn (UP*V-U*VP)/V*V;\n\n}\nfloat getDist(vec2 uv,float[CPcount] w,vec2[CPcount] p,float t,float T[Tsize]){\n\n    vec2 NP = NURBS_POLY(t,w,p,T);\n    \n     float Dist = distance(uv,NP); // =sqrt(pow(NURBS(w,p,t,T).x - uv.x,2.)+pow(NURBS(w,p,t,T).y - uv.y,2.))\n\treturn Dist;\n}\nfloat DerivTaylorSeries(float a,vec2 uv,float[CPcount] w,vec2[CPcount] p,float t,float T[Tsize]){////***********\n    \n    float X = t-a;\n    \n\t\treturn getDistDeriv(uv,w,p,a,T)+getDist2ndDeriv(uv,w,p,a,T)*X;\n}\nvec2 IterateMinDist(vec2 v,float[CPcount] w,vec2[CPcount] p,float T[Tsize]){\nfloat F =0., I =MAX_DIST;\n    \n   /* for(int i=0;i<Tsize;i++){\n        float d = getDist(v,w,p,T[i],T);\n        if(d < I){ I = d; F = T[i]; }\n    \n    }//*/\n    float iterations = 100.;\n    for(float i =0.;i<1.;i+=(1./iterations) ){\n    float d = getDist(v,w,p,i,T);\n        if(d < I){ I = d; F = i; }\n    \n    }\n    \nreturn vec2(F,I);\n}\n///////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mi = min(iResolution.x,iResolution.y);\n    float r = iResolution.y/iResolution.x;\n    vec2 uv = (fragCoord/mi);//-vec2(0.0*r,0.0);\n    float time =-sin(iTime/2.)/2.+0.5;\n\n    \n    vec2 p1 = vec2(0.50+0.25,0.25+0.25);\n    vec2 p2 = vec2(0.50+0.25,0.50+0.25);//vec2(mx,my);//\n    vec2 p3 = vec2(0.25+0.25,0.50+0.25);//vec2(mx,my);//\n    vec2 p4 = vec2(0.0 +0.25, 0.50+0.25);\n    vec2 p5 = vec2(0.0 +0.25, 0.25+0.25);\n    vec2 p6 = vec2(0.0+0.25,0.0+0.25);\n    vec2 p7 = vec2(0.25+0.25,0.0+0.25);\n    vec2 p8 = vec2(0.50+0.25,0.0+0.25);\n\tvec2 p9 = vec2(0.50+0.25,0.25+0.25);\n\n    float \tw1 = 1.5,\n        \tw2 = 1.,\n        \tw3 = 1.5,\n       \t\tw4 = 1.,\n        \tw5 = 1.5,\n        \tw6 = 1.,\n        \tw7 = 1.5,\n        \tw8 = 1.,\n        \tw9 = 1.5;\n    vec2 p[] = vec2[](p1,p2,p3,p4,p5,p6,p7,p8,p9);\n    vec2 pw[] = vec2[](p1*w1,p2*w2,p3*w3,p4*w4,p5*w5,p6*w6,p7*w7,p8*w8,p9*w9);\n        float w[] = float[](w1,w2,w3,w4,w5,w6,w7,w8,w9);\n\t\t\n    \n          \t\t\t\tfloat[Tsize] T;// = float[](0.,1./7.,2./7.,3./7.,4./7.,5./7.,6./7.,1.); \n    /*1*/\t//if(n==1){\t T = float[](0.,0.,1./8.,2./8.,3./8.,4./8.,5./8.,6./8.,7./8.,1.,1.); }\n    /*2*/  if(n==2){\t T = float[](0.,0.,0.,1./4.,1./4.,2./4.,2./4.,3./4.,3./4.,1.,1.,1.);\t}\n    /*2*/  // if(n==2){\t T = float[](0.,0.,0.,1./7.,2./7.,3./7.,4./7.,5./7.,6./7.,1.,1.,1.);\t}\n    /*3*/\t//\tif(n==3){\t T = float[](0.,0.,0.,0.,1./6.,2./6.,3./6.,4./6.,5./6.,1.,1.,1.,1.);\t}\n    \n   /* float t = iTime;\n   vec2 d1 = vec2(1.,0.);\n    vec2 d2 = vec2(-4.,-0.2);\n    vec2 d3 = vec2(6.,-0.72);\n p1 += vec2(sin(t),-cos(t))/10.;    \n p2 += vec2(-sin(t),cos(2.*t))/2.;\n p3 += vec2(cos(t),sin(t))/2.;\n//*/\n    vec2[] ND = NURBS_POLY_DERIV(sin(iTime/2.)/2.+0.5,w,p,T);\n    vec2 CurrPos = ND[0];\n    vec2 CurrDeriv = ND[1];//*/\n    vec3 col = vec3(0.,0.,0.)\n        /*+point(uv,p1)\n        +point(uv,p2)\n        +point(uv,p3)\n        +point(uv,p4)\n        +point(uv,p5)\n        +point(uv,p6)\n        +point(uv,p7)\n        +point(uv,p8)\n        +point(uv,p9)\n        +line(uv,p1,p2)\n    \t+line(uv,p2,p3)\n        +line(uv,p3,p4)\n        +line(uv,p4,p5)\n        +line(uv,p5,p6)\n        +line(uv,p6,p7)\n        +line(uv,p7,p8)\n        +line(uv,p8,p9)//*/\n\t\t//+lineI(uv,CurrPos,CurrPos+CurrDeriv)\n\t\t//+pointB(uv,CurrPos)\n       // +pointV(uv,CurrPos + CurrDeriv/10.)//*/\n       // +point(uv,IterateMinDist(vec2(mx,my),w,p,T)+vec2(0.,0.5))\n       //+point(uv,vec2(time , getDistDeriv(vec2(mx,my),w,p,time,T)/1.+0.5  ))\n        ;  \n   // float itterations = 100.,t = 0.;\n  \n   /* for(float k=0.;k<itterations;k++){\n    if(distance (uv,NURBS(w,p,t,T))<= 0.005){\n    col += getColor(t,T);\n    }\n   t+=1./(itterations-1.);\n   }//*/\n    \n    /*for( float t = 0.;t<1.;t+=(1./itterations)){       \n        if(distance (uv,(NURBS_POLY(t,w,p,T) ))<= 0.005){\n    \tcol += getColor(t,T);\n        }\n    }//*/\n    if(IterateMinDist(uv,w,p,T).y< 0.01){\n    col += vec3(1.,1.,0.);\n    }\n    /*for( float t = 0.;t<1.;t+=(1./itterations)){  \n         vec2[] ND = NURBS_DERIV(t,w,p,T);\n    vec2 CurrPos = ND[0];\n    vec2 CurrDeriv = ND[1];\n        if(distance (uv,CurrDeriv/5.+0.5)<= 0.005){\n    \tcol += getColor(t,T);\n        }\n    }//*/\n    \n   /* if( uv.x >= 1./7. -0.005 && uv.x <=1./7. +0.005\n       || uv.x >= 2./7. -0.005 && uv.x <=2./7. +0.005\n       || uv.x >= 3./7. -0.005 && uv.x <=3./7. +0.005\n       || uv.x >= 4./7. -0.005 && uv.x <=4./7. +0.005\n       || uv.x >= 5./7. -0.005 && uv.x <=5./7. +0.005\n       || uv.x >= 6./7. -0.005 && uv.x <=6./7. +0.005\n       || uv.x >= 7./7. -0.005 && uv.x <=7./7. +0.005\n      ){col = vec3(0.,0.,1.);}\n    \n    //for(int i =0;i<CPcount;i++){\n    int i  = int(iTime);\n        float f= N2(i,uv.x,T);//+N2(1,uv.x,T)+N2(2,uv.x,T)+N2(3,uv.x,T)+N2(4,uv.x,T)+N2(5,uv.x,T)+N2(6,uv.x,T)+N2(7,uv.x,T)+N2(8,uv.x,T);\n    \tf= f/1.;//+0.5;\n    if(uv.y >=  f && uv.y <= f+0.03){col=vec3(0.,1.,0.); }\n    //}//*/\n   /* float e = getDist(vec2(mx,my),w,p,uv.x,T);\n    \te =e/1.+0.5;\n     if(uv.y >=  e && uv.y <= e+0.01){col+=vec3(1.,0.,0.); }//*/\n    \n   /* float f = NURBS_POLY(uv.x,w,p,T).y;\n    \tf =f;\n     if(uv.y >=  f && uv.y <= f+0.01){col+=vec3(0.,1.,0.); }//*/\n    \n    /*float h = getDistDeriv(vec2(mx,my),w,p,uv.x,T);\n    \th =h/1.+0.5;\n     if(uv.y >=  h && uv.y <= h+0.01){col+=vec3(1.,0.,1.); }\n    \n    float l = getDist2ndDeriv(vec2(mx,my),w,p,uv.x,T);\n    \tl =l/1.+0.5;\n     if(uv.y >=  l && uv.y <= l+0.01){col+=vec3(1.,1.,1.); }//*/\n    \n    /*float m = DerivTaylorSeries(time,vec2(mx,my),w,p,uv.x,T);\n    \tm =m/1.+0.5;\n     if(uv.y >=  m && uv.y <= m+0.01){col+=vec3(1.,1.,0.); }//*/\n    \n    \n    /*float g = -0.0/10. +0.5;\n         if(uv.y >=  g-0.002 && uv.y <=g+0.002){col+=vec3(0.,0.,1.); }\n    \n\t\t\t\t\t//*/\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}