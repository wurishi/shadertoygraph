{"ver":"0.1","info":{"id":"mlGcDG","date":"1700588073","viewed":33,"name":"Ray march 0.3 with transparance","username":"francesco_vmk","description":"My first and really bad attempt at rendering transparent solids in raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Ray march 0.2 with transparance\" by francesco_vmk. https://shadertoy.com/view/cdtfD8\n// 2023-11-21 17:12:12\n\n//CONSTANTS\nconst float MAX_DIST = 15.0;\nconst float MIN_DIST = 0.01;\n//structs\n\nstruct Point{\n    float dist;\n    vec4 color;\n    int shapeId;\n};\n\n//random\n\n\nfloat rand(float i, float seed){return fract(sin(i) * seed);}\n\nvec4 colors[3]= vec4[3](\n    vec4(0.000,1.000,0.000,1.0), \n    vec4(1.000,0.000,0.000,1.0), \n    vec4(0.000,0.000,1.000,1.0)\n);\n    \nvec4 randomColor(float seed, float i)\n{\n    int arrayLength = colors.length();\n    int randomIndex = int(rand(i, seed) * float(arrayLength));\n    return colors[randomIndex];\n}\n\n\n\n//shapes\n\nPoint sdfSphere(vec3 p, vec3 center, float radius, vec4 color, int currentId)\n{\n    Point res;\n    res.color = color;\n    res.dist = length(p - center) - radius;\n    res.shapeId = currentId + 1;\n    return res;\n}\n\nPoint sdfPlane( vec3 p, vec3 n, float h, vec4 color, int currentId)\n{\n  // n must be normalized\n  return Point(dot(p,n) + h, color, currentId + 1);\n}\n\n\nPoint sdfBox( vec3 p, vec3 b, vec3 center, vec4 color, int currentId)\n{\n  vec3 q = abs(p - center) - b;\n  return Point(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), color, currentId + 1);\n}\n\n//functions\n\nPoint opSmoothUnion(Point d1, Point d2, float k){\n\n    float h = clamp(0.5 + 0.5 * (d2.dist - d1.dist) / k, 0.0, 1.0);\n    \n    vec4 color = vec4(mix(d2.color, d1.color, h));\n    \n    int shapeId = h > 0.5 ? d1.shapeId : d2.shapeId;\n    \n    return Point(mix(d2.dist, d1.dist, h) - k * h * (1.0-h), color, shapeId);\n}\n\n\nPoint map(vec3 p, int jumpShape, int jumpSize){\n    \n    int shapeIndex = 1;\n    int jumpIndex = 0;\n    \n    Point m = sdfPlane(p, \n        vec3(0.0, 1.0, 0.0), 0.8, vec4(1.0),\n        shapeIndex\n    );\n    \n    shapeIndex = m.shapeId;\n    \n    \n    Point obj = sdfBox(p, \n    vec3(0.5, 1.0, 0.5), \n    vec3(0.0, 0.0, 0.0),\n    vec4(0.000,0.000,1.000,0.8),\n    shapeIndex\n    );\n    \n    shapeIndex = obj.shapeId;\n    \n    if(shapeIndex != jumpShape){\n        m = opSmoothUnion(obj, m, 0.5);\n        jumpIndex++;\n    }\n\n    \n    \n    \n    \n    \n    obj = sdfSphere(p, \n    vec3(1.5, 2.0, 2.5), \n    0.5,\n    vec4(1.000,0.000,0.000,0.5),\n    shapeIndex\n    );\n    \n    shapeIndex = obj.shapeId;\n        if(shapeIndex != jumpShape){\n        m = opSmoothUnion(obj, m, 0.5);\n        jumpIndex++;\n    }\n\n    \n    \n    for(float i = 1.0; i < 15.0; i++){\n        obj = sdfSphere(p,\n        vec3(\n            sin(iTime * rand(i, 43758.5453)) * 1.5 + rand(rand(i, 43758.5453), 43758.5453), \n            sin(iTime * rand(i, 23758.5453)) * 1.0 + rand(rand(i, 23758.5453), 23758.5453), \n            sin(iTime * rand(i, 33758.5453)) * 1.5 + rand(rand(i, 33758.5453), 33758.5453)\n        ), \n        0.1, \n        randomColor(4358.5453, i),\n        shapeIndex\n        );\n        \n       shapeIndex = obj.shapeId;\n       if(shapeIndex != jumpShape){\n            m = opSmoothUnion(obj, m, 0.5);\n            jumpIndex++;\n       }\n        \n        \n    }\n   \n    \n   return m;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.002, -0.002);\n    int j;\n    int ji = 0;\n    return normalize(\n          e.xxx * map(p+e.xxx, j ,ji).dist\n        + e.xyy * map(p+e.xyy, j, ji).dist\n        + e.yxy * map(p+e.yxy, j, ji).dist\n        + e.yyx * map(p+e.yyx, j, ji).dist\n            );\n}\n\nPoint rayMarch(vec3 ro, vec3 rd, float maxDist){\n\n    \n    int jShapes;\n    int jShapesi = 0;\n    \n    Point p = map(ro, jShapes, jShapesi);\n    float dist = p.dist;\n    Point oldP = Point(MAX_DIST, vec4(0.706,0.992,0.996,1.0), -1);\n    \n    int i = 0;\n    \n    \n    while(dist < maxDist && i < 200){\n      i++;\n      p = map(ro + rd * dist, jShapes, jShapesi);\n      if(p.dist <= MIN_DIST){\n          if(p.color.w >= 1.0){\n              if(oldP.shapeId < 0){\n                  oldP.dist = dist;\n                  oldP.color = p.color;\n              }else{\n                  p.color = mix(p.color, oldP.color, oldP.color.w);\n                  oldP.color = p.color;\n              }\n              \n              break;\n          }else{\n              p.color = mix(oldP.color, p.color, p.color.w);\n              oldP.color = p.color;\n              if(oldP.dist >= MAX_DIST){\n                  oldP.dist = dist;\n                  \n                  oldP.shapeId = p.shapeId;\n              }\n              \n             jShapes = p.shapeId;\n             jShapesi++;\n          }\n\n      }\n      \n      dist += p.dist;\n    }\n    \n    \n    return oldP;\n\n\n}\n\n\n\nPoint rayMarchShadow(vec3 ro, vec3 rd, float maxDist){\n\n    int j;\n    int ji = 0;\n    \n    Point p = map(ro,  j, ji);\n    float dist = p.dist;\n    float oDist = p.dist;\n    \n    for(int i = 0; i < 200; i++){\n      p = map(ro + rd * dist, j, ji);\n      \n      if(p.dist < MIN_DIST && p.dist <= oDist){\n          p.dist = dist;\n          return p;\n      }\n      \n      oDist = p.dist;\n      \n      \n      dist += p.dist;\n      \n      if(dist >= maxDist){\n          break;\n      }\n      \n    }\n    \n    return Point(maxDist, vec4(0.706,0.992,0.996,0.0), -1);\n\n\n}\n\nvoid camera(vec2 uv,out vec3 ro, out vec3 rd){\n    //camera from https://www.shadertoy.com/view/XsXXDB\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    float hd = -m.x * 14.0 + 3.14159;\n    float elv = m.y * 3.14159 * 0.4 - 3.14159 * 0.25;\n    ro = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n    ro = ro * 8.0 + vec3(0.0, 6.0, 0.0);\n    \n\n    // camera tx\n    vec3 cw = normalize( ta-ro );\n    vec3 cp = vec3( 0.0, 1.0, 0.0 );\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    rd = normalize( uv.x*cu + uv.y*cv + 2.5*cw );\n}\n\nvec3 render(vec2 uv){\n    \n\n    vec3 ro;\n    vec3 rd;\n    vec3 color;\n    \n    camera(uv, ro, rd);\n    \n    Point p = rayMarch(ro, rd, MAX_DIST);\n    \n    \n    if (p.dist < MAX_DIST)\n    {\n        //color = vec3(1.0);\n        \n        //normals\n        vec3 pos = ro + rd * (p.dist); //get point wher you need to calculate the normals\n        vec4 baseColor = p.color;\n        vec3 normal = getNormal(pos);\n        \n        \n        //lighting\n        \n        //ambient\n        vec3 ambient = vec3(1.000,1.000,1.000);\n        \n        //diffuse\n        vec3 lightColor = vec3(1.000,1.000,1.000);\n        vec3 lightSource = vec3(2.0, 1.5, -1.5);\n        float diffuseStrength = max(0.0, dot(normalize(lightSource),normal));\n        \n        vec3 diffuse = lightColor * diffuseStrength;\n        \n        //specular\n        lightColor = vec3(1.000,1.000,1.000);\n        \n        vec3 viewSource = normalize(ro);\n        vec3 reflectSource = normalize(reflect(-lightSource,normal));\n        float specularStrength = max(0.0, dot(viewSource, reflectSource));\n        specularStrength = pow(specularStrength, 64.0);\n        vec3 specular = specularStrength * lightColor;\n        \n        vec3 lighting = ambient * 0.4 + diffuse * 0.90 + specular * 0.6;\n        \n        color = baseColor.rgb * lighting;\n        \n        //shadows\n        vec3 lightDirection = normalize(lightSource);\n        float distToLightSource = length(lightSource - pos);\n        ro = pos;\n        rd = lightDirection;\n        Point pointShadow = rayMarchShadow(ro, rd, distToLightSource);\n        \n        if(pointShadow.dist < distToLightSource){\n            pointShadow.color = baseColor * vec4(0.1);\n            color = pointShadow.color.rgb;\n        }\n        \n        \n        \n        \n        //gamma correction\n        color = pow(color, vec3(1.0 / 2.2));\n        \n        // Tone mapping\n        //color = 1.-exp(-2.*color);\n        \n    }\n    else{\n        color = p.color.rgb;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n\n    // Correct for aspect ratio\n    uv.x *= aspectRatio;\n\n    vec3 color = vec3(0.0);\n\n    color = render(uv);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}