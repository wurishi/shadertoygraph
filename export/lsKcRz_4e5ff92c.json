{"ver":"0.1","info":{"id":"lsKcRz","date":"1520903361","viewed":149,"name":"Mettalloy Rays","username":"audiopixel","description":"feeling like melting metal","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","rays","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'Mettalloy Rays'\n// Created by hepp maccoy March/2018 hepp@audiopixel.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Building on techniques by @iq, @alteredq, @mrkishi and others\n// Thanks to @cacheflowe & @reinder for advice on ray marching\n\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p) {\n    float s = ((-iTime) * 9.2) + sin(iTime * .27) * 9.2;\n    float d = 1.0; vec3 o = p;\n    float a=mod(o.y+5.0, (20.))-10.; a = abs(o.y);\n    p.yz *= r2d(sign(a)* -5.);\n    p.xz *= r2d(sign(a)*(s * .04));\n    p.xz = amod(p.xz, 3.7);\n    p.xz = max(abs(p.xz) + 0.0808, -3.3221);\n    p.z = mod(p.z, 5.)-2.5;\n    p.x = mod(p.x, 26.)-13.;\n    p.y = mod(p.y+s, 18.)-5.;\n    d = min(d, soc(max(abs(p)-.3999, .3565)));\n    return (length(p*-.0168)-.0097)* -3. - (d * -1.);\n}\n\nvec3 b(vec3 c1, vec3 c2){\n    return vec3((c1.r > 0.5) ? max(c2.r, 2.0 * (c1.r - 0.5)) : min(c2.r, 2.0 * c1.r), (c1.r > 0.5) ? max(c2.g, 2.0 * (c1.g - 0.5)) : min(c2.g, 2.0 * c1.g),(c1.b > 0.5) ? max(c2.b, 2.0 * (c1.b - 0.5)) : min(c2.b, 2.0 * c1.b));                                                                      { return c1 + c2; }                               // Add (default)\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.05;\n    return normalize( e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 l = vec3(-10);\n    vec2 st = (fragCoord.xy/iResolution.xy)*2.5-1.;\n    st.x *= 1.7;\n    vec3 ro = vec3(st, 5. + sin(iTime * .8) * 3.5);\n    vec3 rd = normalize(vec3(st+vec2(0.), .3662));\n    vec3 mp; mp = ro; float md;\n    for (int i=0; i<50; i++) { md = map(mp); if (md <.001) break; mp += rd*md; }\n    vec3 c1 = vec3(-0.3805 - (length(ro-mp) * (.035 + sin(iTime * .8) * .006)) * -1.8547), c2, c3;\n    vec3 p = ro + rd * (mp);\n    if (md > -0.7875) {\n        float dif = clamp(dot(calcNormal(p), normalize(l - p)), 0., 1.);\n        dif *= 5. / dot(l - p, l - p);\n        c2 = vec3(pow(dif, .053)); \n    } else {\n        c3 = vec3(p.x * .15);\n    }\n    c2 = b(c2, vec3((mp.z * 2.5) * (md * .05), 0, 0));\n    fragColor = vec4(abs((c2 + c3) - c1), 1.);\n}","name":"Image","description":"","type":"image"}]}