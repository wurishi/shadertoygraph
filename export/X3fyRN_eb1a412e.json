{"ver":"0.1","info":{"id":"X3fyRN","date":"1726041371","viewed":18,"name":"SphereMarching","username":"lvl3mage","description":"A smol shader","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["spheremarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 EmptyTransform(){\n    return mat4(\n        vec4(1,0,0,0),\n        vec4(0,1,0,0),\n        vec4(0,0,1,0),\n        vec4(0,0,0,1)\n    );\n}\nmat4 TransformWithPosition(mat4 transform, vec3 pos){\n    transform[3].xyz = pos;\n    transform[3].w = 1.0;\n    return transform;\n}\n\nmat4 CameraTransform(){\n    mat4 cameraMat = mat4(\n        vec4(1,0,0,0),\n        vec4(0,1,0,0),\n        vec4(0,0,1,0),\n        vec4(0,0,0,1)\n    );\n    //cameraMat[3].x = sin(iTime)*0.5;\n    return cameraMat;\n}\n\nvec3 GetLightPos(){\n    return vec3(0,0,0.2);\n}\nvec3 GetLightDir(){\n    return vec3(-3,-3,-10);\n}\nvec3 UvPosToWorldPos(vec2 uvPos){\n    mat4 cameraMat = CameraTransform();\n    uvPos-= vec2(0.5,0.5);\n    uvPos.y *= iResolution.y/iResolution.x;\n    vec3 offset = vec3(uvPos.xy,0);\n    offset = (cameraMat * vec4(offset,1)).xyz;\n    return offset;\n}\nvec3 UVToViewDir(vec2 uv){\n    float FOV = 90.0;\n    float radFOV = radians(FOV);\n    float aspect = iResolution.y/iResolution.x;\n    float angleX = mix(-radFOV*0.5,radFOV*0.5,uv.x);\n    float angleY = mix(-radFOV*aspect*0.5,radFOV*aspect*0.5,uv.y);\n    vec3 castDir = vec3(tan(angleX),tan(angleY),0.75);\n    mat4 transform = CameraTransform();\n    transform[3].xyz = vec3(0);\n    castDir = (transform*vec4(castDir,0)).xyz;\n    return normalize(castDir);\n    \n}\nstruct Material{\n    vec3 primaryColor;\n};\nstruct Sphere{\n    vec3 position;\n    mat4 transform;\n    float radius;\n};\nfloat SphereSdf(Sphere sphere, vec3 pos){\n    vec4 posV = vec4(pos.x,pos.y,pos.z,1);\n    posV.xyz -= sphere.position;\n    vec4 invPos = inverse(sphere.transform)*posV;\n    float dist = length(invPos.xyz);\n    dist -= sphere.radius;\n    return dist;\n}\nstruct Torus{\n    vec3 position;\n    mat4 transform;\n    vec2 dimensions;\n};\nTorus Torus1(){\n    mat4 transform = EmptyTransform();\n    float a = 3.14159 * sin(iTime*0.5f);\n    transform[1][1] = cos(a);\n    transform[1][2] = -sin(a);\n    transform[2][1] = sin(a);\n    transform[2][2] = cos(a);\n    \n    return Torus(vec3(0,0,0.2),transform,vec2(0.2,0.05));\n}\n\n\nSphere MouseSphere(){\n\n    vec2 mouseCoord = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n    vec3 pos = UvPosToWorldPos(mouseCoord);\n    pos += UVToViewDir(mouseCoord)*0.2;\n    mat4 transform = EmptyTransform();\n    return Sphere(pos,transform,0.1);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat TorusSdf(Torus torus, vec3 pos){\n    vec4 posV = vec4(pos.x,pos.y,pos.z,1);\n    posV.xyz -= torus.position;\n    vec4 invPos = inverse(torus.transform)*posV;\n    float dist = sdTorus(invPos.xyz, torus.dimensions);\n    return dist;\n    \n}\nfloat smin( float a, float b, float k )\n{\n    k *= 4.0;\n    float x = (b-a)/k;\n    float g = (x> 1.0) ? x :\n              (x<-1.0) ? 0.0 :\n              (x*(2.0+x)+1.0)/4.0;\n    return b - k * g;\n}\nfloat SceneSdf(vec3 pos){\n    float dist1 = SphereSdf(MouseSphere(), pos);\n    float dist2 = TorusSdf(Torus1(),pos);\n    return smin(dist1,dist2,0.04);\n}\nfloat LightSdf(vec3 pos){\n\n    float dist3 = length(pos - GetLightPos());\n    return dist3;\n}\nvec3 SceneNormalAtPoint(vec3 p){\n    const float h = 0.01; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*SceneSdf( p + k.xyy*h ) + \n                      k.yyx*SceneSdf( p + k.yyx*h ) + \n                      k.yxy*SceneSdf( p + k.yxy*h ) + \n                      k.xxx*SceneSdf( p + k.xxx*h ) );\n}\n\nstruct CollisionData{\n    bool collided;\n    vec3 point;\n    int stepAmount;\n    bool lit;\n};\nbool MarchPointLight(vec3 point, vec3 target){\n    int iter = 0;\n    vec3 dir = normalize(target - point);\n    while(true){\n        float lightDist = length(target - point);\n        if(lightDist < 0.1){\n            return true;\n        }\n        float sceneDist = SceneSdf(point);\n        float dist = min(sceneDist, lightDist);\n        float nextSceneDist = SceneSdf(point + dir*dist);\n        if(sceneDist < 0.1 && nextSceneDist < sceneDist){\n            return false;\n        }\n        \n        point += dir*dist;\n        if(iter > 255){\n            return false;\n        }\n        iter += 1;\n        \n    }\n    \n}\nCollisionData March(vec3 point, vec3 dir){\n    int iter = 0;\n    CollisionData col;\n    while(true){\n        float dist = SceneSdf(point);\n        if(dist < 0.001){\n            bool lit = MarchPointLight(point, GetLightPos());\n            col = CollisionData(true, point, iter,lit); \n            break;\n        }\n        if(dist > 1000.0){\n            col = CollisionData(false, point, iter,false); \n            break;\n        }\n        point += dir*dist;\n        if(iter > 255){\n            col = CollisionData(false, point, iter,false); \n            break;\n        }\n        iter += 1;\n        \n    }\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    //fragColor.xyz = abs(UVToViewDir(uv));\n    //fragColor.z = 0.0;\n    //fragColor.x = 0.1* ceil(fragColor.x*10.0);\n    //fragColor.y = 0.1* ceil(fragColor.y*10.0);\n    //return;\n    vec3 offset = UvPosToWorldPos(uv);\n    vec3 castPos = offset;\n    vec3 castDir = UVToViewDir(uv);\n    CollisionData data = March(castPos, castDir);\n    \n    fragColor = vec4(0.2,0.2,0.3,0);\n    float outline = float(data.stepAmount)/100.0;\n    \n    outline -= 0.3;\n    outline *= 2.0;\n    outline = clamp(outline,0.0,1.0);\n    if(data.collided){\n        outline = 0.0;\n        vec3 normal = SceneNormalAtPoint(data.point);\n        vec3 light = GetLightPos();\n        vec3 delta = light - data.point;\n        delta = normalize(delta);\n        float lit = dot(-delta,normal);\n        bool inShadow = !data.lit;\n        if(inShadow){\n            lit = 0.0;\n        }\n        //lit = clamp(lit,0.0,1.0);\n        if(isnan(lit)){\n            fragColor.x = 1.0;\n            \n            return;\n        }\n        fragColor.xyz = mix(vec3(0.6,0.8,0.8)*0.8, vec3(0.6,0.8,0.8)*0.5,lit);\n    }\n    fragColor.xyz = mix(fragColor.xyz,vec3(0.6,0.8,1.0),outline); \n    \n   \n    \n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// keys are javascript keycode\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}