{"ver":"0.1","info":{"id":"4cj3WD","date":"1714766231","viewed":236,"name":"Voxel planet explosion","username":"Famousghost","description":"Voxel calculations to show planet explosion","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["voxelraymarchingraycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 180\n\n#define PITCH 5.0\n#define YAW -10.0\n\n#define M_PI 3.141592653589793238462643383279502884197169399375105820974944\n\n\nvec3 voxelCast(vec3 ro, vec3 rd, vec3 voxel)\n{\n    float t1 = (voxel.x - ro.x) / rd.x;\n    float t2 = (voxel.y - ro.y) / rd.y;\n    float t3 = (voxel.z - ro.z) / rd.z;\n    vec3 steps = sign(rd);\n    if(t1 < t2 && t1 < t3)\n    {\n        return vec3(steps.x, 0.0f, 0.0f);\n    }\n    else if(t2 < t3)\n    {\n        return vec3(0.0f, steps.y, 0.0f);\n    }\n    \n    return vec3(0.0f, 0.0f, steps.z);\n}\n\nfloat sdTorus( vec3 p, vec3 position, vec2 t )\n{\n    vec2 q = vec2(length(p.xz - position.xz)-t.x,p.y - position.y);\n    return length(q)-t.y;\n}\n\n\nfloat sdSphere(vec3 p, vec3 position, float radius)\n{\n    return length(p - position) - radius;\n}\n\nfloat sdScene(vec3 p)\n{\n\n    float time = texture(iChannel0, vec2(0.0f)).r;\n    float sphere1 = sdSphere(p, vec3(0.8f, 0.4f, 0.0f), smoothstep(0.0f, 1.0f, time));\n    float sphere2 = sdSphere(p, vec3(0.0f, 0.0f, 0.0f), 1.0f);\n    float boxFrame = sdTorus(p, vec3(0.0f, 0.2f, 0.0f), vec2(1.5f, 0.1f));\n    return max(-sphere1, min(boxFrame, sphere2));\n}\n\nvec4 rayMarching(vec3 ro, vec3 rd, float voxelSize, out bool hit)\n{\n    float depth = 0.0f;\n    vec3 voxel = floor(ro * voxelSize);\n    vec3 voxelNormal = vec3(0.0f);\n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        float tmpDepth = sdScene(voxel / voxelSize);\n        if(tmpDepth <= 0.0f)\n        {\n            hit = true;\n            break;\n        }\n        depth += tmpDepth;\n        vec3 voxelToProperDirection = (voxel + vec3(step(0.0f, rd.x), step(0.0f, rd.y), step(0.0f, rd.z)));\n        voxelNormal = voxelCast(ro, rd, voxelToProperDirection / voxelSize);\n        voxel += voxelNormal;\n        \n    }\n    return vec4(depth, -voxelNormal);\n}\n\nfloat diffuse(vec3 lightDir, vec3 normal)\n{\n    return max(0.0f, dot(lightDir, normal));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5f * iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.0f, 1.0f, 0.0f);\n    vec3 rd = normalize(vec3(uv, -1.0f));\n    vec3 lp = vec3(0.0f, 0.0f, 0.0f);\n\n    \n    float cameraRadius = 3.0f;\n    vec2 mouse = (iMouse.xy - 0.5f * iResolution.xy) / iResolution.y;\n    ro.x = cameraRadius * sin(mouse.x * 2.0f * M_PI); // convert x-component to polar and add offset \n    ro.z = cameraRadius * cos(mouse.x * 2.0f * M_PI); // convert z-component to polar and add offset\n    \n    rd = camera(ro, lp) * rd;\n    \n    \n    float pitch = radians(PITCH);\n    float yaw = radians(YAW);\n    \n    vec3 lightDir = normalize(vec3(cos(pitch) * cos(yaw), sin(pitch), cos(pitch) * sin(yaw)));\n        bool hit = false;\n    vec4 result = rayMarching(ro, rd, 30.0f, hit);\n    \n    vec3 col = vec3(0.0f);\n        \n    if(hit)\n    {\n        vec3 p = ro + rd * result.x;\n        float diff = diffuse(lightDir, result.yzw);\n        col = vec3(result.yzw);\n        col = vec3(diff);\n    }\n\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EXPLOSION_SPEED 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float time = texture(iChannel0, uv).r;\n    if(iMouse.z >= 1.0f)\n    {\n        time = 0.0f;\n    }\n    time += iTimeDelta * EXPLOSION_SPEED;\n    fragColor = vec4(time,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}