{"ver":"0.1","info":{"id":"mlsXWr","date":"1674616292","viewed":175,"name":"Rain SDF","username":"Reyku","description":"Simple rain sdf for a game I made\ndidn't found a 3D rain sdf here so I felt forced to post this.\n\nMOVE =>    W A S D\nCamera =>  Mouse","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","ray","sdf","rain","raining","rainy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Infinite streched sdf repetition with random offset and fall speed... which seems like rain\nfloat rainsdf(vec3 p)\n{\n    float rainsize=.125;\t\n    float snapsize=.75;// rain droplets separation\n    vec3 m=modularsnap(p,snapsize);\n\n    float x=1.0-2.0*hash12((m.xz+.5)*1.31457453); //multiplying by a random offset\n    float z=1.0-2.0*hash12((m.xz+.2)*1.41569562);\n   \n    float yrandom=hash12(m.xz*1.4234123); //random y offset\n   \n    float rainspeed=4.5+.3*hash11(yrandom);//random rainfall speed\n   \n    //separating droplets in x,y,z dimension\n    vec3 randomoffset=vec3(x*snapsize*.25,-iTime*(rainspeed)+yrandom,z*snapsize*.25);\n    \n    //you can choose any sdf shape\n    \n    //BOX WATER DROPLET\n    //float r=sdBox(repeat(p-randomoffset,vec3(snapsize)),  vec3(.025,.5,.025)*rainsize);\n   \n    //ELONGATED SPHERE WATER DROPLET\n    p=repeat(p-randomoffset,vec3(snapsize));\n    p.y*=.05;//elongated sphere effect\n     \n    float r=sdSphere( p,rainsize*.025);\n  \n    return r;\n}\n\n//o = ray origin, d = ray direction\nvec3 raymarch(vec3 o, vec3 d)\n{\n\n float r=1.0;\n float plane=1.0;\n float maxdist=32.0;\n float t=0.5;\n \n //Marching\n //u don't need many steps, 64 steps because of plane\n //water droplets would work with 16 steps :)\n \n  vec3 raincolor=vec3(0.0,0.0,1.0);// default blue color for rain\n  vec3 planecolor= vec3(.25);\n  vec3 color=vec3(1.0);\n for(int i=0;i<64;i++)\n {\n   vec3 p=o+d*t;\n   r=rainsdf(p);\n   plane=sdPlane(p,vec3(0.0,1.0,0.0),1.0);//added a plane so you can percieve the rain in 3D\n   \n   float dist=min(r,plane);\n   t+=dist;\n   \n   if(dist<.0001||t>maxdist)//\n   {\n      if(r<plane)\n      {\n       color=raincolor;\n      }else\n   \n      {\n      float patternsize=1.f;\n      float total = floor(p.x * patternsize) +\n                  floor(p.z * patternsize);\n      float isEven = float(mod(total, 2.0) == 0.0)*.5;\n      color=vec3(isEven);\n     }\n   \n   break;\n   }\n }\n \n //FINAL COLORS\n float fade=1.0-clamp(t/5.5,0.0,1.0);//just to make it better;\n \n \n vec3 background=vec3(1.0);\n \n vec3 finalcolor= mix(background,color,fade);//mixing colors\n \n return finalcolor;\n}\n\nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 origin = texture(iChannel0, vec2(0.)).xyz;\n    vec3 dir=normalize(vec3(uv, 0.0) - vec3(0.0, 0.0, -1.0));\n    \n    vec2 m = ((iMouse.xy == vec2(0.) ? vec2(.5) : (iMouse.xy / iResolution.xy)) * 2. - 1.) * vec2(360.,90.);\n    dir.yz = rot2D(dir.yz, m.y);\n    dir.xz = rot2D(dir.xz, m.x);\n    \n    vec3 raincolor=raymarch(origin,dir);\n    \n    fragColor = vec4(raincolor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//FIRST PERSON CONTROLLER copied from here: https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 3.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.5 / 256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,-3.);\n    \n    float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n    float speed = MOVE_SPEED * iTimeDelta;\n    \n    speed *= 1. + 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n    \n    float forwardBackward =\n\ttexture(iChannel0, vec2(KEY_W, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_S, 0.)).r;\n\n\tfloat leftRight =\n\ttexture(iChannel0, vec2(KEY_A, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_D, 0.)).r;\n\n\tfloat s = sin(radians(mx));\n\tfloat c = cos(radians(mx));\n\n\tpos.x += speed * (forwardBackward * s - leftRight * c);\n\tpos.z += speed * (forwardBackward * c + leftRight * s);\n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//https://www.shadertoy.com/view/4djSRW  Hash random functions\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//had to make this to map positions to the infinite repetition sdf function\nvec3 modularsnap(in vec3 p,float size)//p = position, size can be vec3\n{\n     return floor((p+size*.5)/size) * size;\n}\n\nvec3 repeat( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n//https://www.shadertoy.com/view/Xds3zN   SDFS inigo quilez\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n","name":"Common","description":"","type":"common"}]}