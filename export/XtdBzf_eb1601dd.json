{"ver":"0.1","info":{"id":"XtdBzf","date":"1541286428","viewed":219,"name":"Fractal Exploration Template","username":"NAME_REDACTED","description":"Template functions for experimenting with fractals: Includes complex math funcs, basic iterative loop, and palette lookup functions.  Controls include Z: pan, X: zoom/rotate, C: modulate z-val, V: modulate ext val, P: rnd palette, +/-: zoom","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["fractal","julia","mandelbrot","zoom","rotate","template","orbittrap","complex","pan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//this shader is designed for experimenting with fractal formulas.\n//all the boiler plate code is here, just drop in your function as a macro\n//or put your code in the body of the mainImage function.\n//some example macros are provided.\n\n#define ENABLE_MOTION //adds time-based motion to user value -- suggest to turn this off before zooming\n#define DYNAMIC_ITS //enable to dynamincally increase iteration count as you zoom in\n#define DYNAMIC_ITS_MIN 20 //dynamic iteration count falls between DYNAMIC_ITS_MIN and MAX_ITS\n#define DYNAMIC_ITS_MULTIPLE 1.5 //dynamic iteration count increases by zoom level\n#define MAX_ITS 100 //maximum number of iterations \n#define BAILOUT_VALUE 20. //larger bailout value to assist normalized iteration count\n#define COLOR_DENSITY -4. //number of rotations through the palette.  Negative to flow in reverse.\n#define TIME_MULTIPLE .25 //iTime multiple for time-based cycles (like color flow)\n\n//controls: press a button to switch mode\n//x: zoom+rotate - click and drag up/down to zoom in or out, and left or right to rotate\n//z: pan - click and drag to pan\n//c: initial val - click and drag to move initial coords (need for Julia-type fractals)\n//v: user value - click and drag to modulate the user value - this can be used for whatever\n//p: randomize palette\n//see bottom of this page for complex function definitions\n\n//up to 5 colors for the inner palette.  These are interpolated by the palette() function.\n#define COLOR1 vec3(0,0,0) \n#define COLOR2 vec3(.66,0,1)\n#define COLOR3 vec3(1,1,1)\n#define COLOR4 vec3(0,0,1)\n#define COLOR5 vec3(1,.25,0)\n\n//set your fractal functions here.  It could be a macro or point to a function or another macro.\n//you can also forego these macros and just type your code directly into the mainImage function.\n//default function is a rational map because I don't see too many of those.\n#define FRACTAL_INIT RATIONALMAP_INIT\n#define FRACTAL_STEP RATIONALMAP_STEP\n#define BAILOUT_TEST ITERATIVE_BAILOUT_TEST\n#define INNER_FUNC TEXTURE\n#define OUTER_FUNC palette1dNormalized(i, float(maxIts), z); /*mandelTex(i, z, rotationZoom.y);*/\n\n//some well-known fractals\n#define MANDELBROT_INIT vec2 z = init;\n#define MANDELBROT_STEP z = c_sqr(z) + c;\n//use ITERATIVE_BAILOUT_TEST w/ Mandelbrot\n\n#define JULIA_INIT vec2 z = c;\n#define JULIA_STEP z = c_sqr(z) + init;\n//use ITERATIVE_BAILOUT_TEST w/ Julia\n\n#define RATIONALMAP_INIT vec2 z = c, lambda = vec2((user.x - .2) * .5, user.y + .1);\n#define RATIONALMAP_STEP vec2 zsquare = c_sqr(z); z = zsquare + init - c_div(lambda, zsquare);\n//use ITERATIVE_BAILOUT_TEST w/ rational map\n\n#define MANDELBROT_TRAP_INIT vec2 z = init; float d = 1e10;\n#define TRAP_CIRCLE_RADIUS 1.55\n#define MANDELBROT_TRAP_STEP z = c_sqr(z) + c; d = min(d, abs(c_abs_sqr(z - user) - TRAP_CIRCLE_RADIUS)); \n//user TRAP_BAILOUT_TEST w/ Mandelbrot Trap fractal\n\n//bailout test functions\n#define ITERATIVE_BAILOUT_TEST if (dot(z,z) > BAILOUT_VALUE * BAILOUT_VALUE) { break; }\n#define TRAP_THRESHOLD .1\n#define TRAP_BAILOUT_TEST if (d < TRAP_THRESHOLD) { break; }\n\n//inner functions\n#define BLACK vec4(COLOR1, 1);\n#define WOOBLY palette(COLOR1, COLOR2, COLOR3, COLOR4, woobly(z)); \n#define TEXTURE texture(iChannel1, c + vec2(sin((c.x + user.x) * PI), sin((c.x + c.y + user.y) * PI))) * .5;\n\nfloat normalizedIterationCount(float i, vec2 z)\n{\n    return i - log2( log( c_abs_sqr(z)) );\n}\n\n//---inner and outer texture coloring functions---\n//colors the function with a 2-dimensional texture\nvec4 mandelTex(int iterations, vec2 finalZ, float zoom)\n{\n    float y = normalizedIterationCount(float(iterations), finalZ);\n    float angle = c_arg(finalZ) / (PI * 2.);\n    float x = angle + float((iterations % 2) * 2 - 1) * iTime * TIME_MULTIPLE;\n    vec2 p = vec2(x, y);\n    vec2 delX = dFdx(p), delY = dFdy(p);\n    if (abs(delX.x) >= .5) delX.x = 0.001; //kill mipmap discontinuities\n    if (abs(delY.x) >= .5) delY.x = 0.001;\n    float lodBias = .5;\n\treturn textureGrad(iChannel1, p, delX * lodBias, delY * lodBias);\n}\n\n//regular basic coloring function\nvec4 palette1d(float i)\n{\n    float p = mod(i * COLOR_DENSITY + iTime * TIME_MULTIPLE, 1.);\n    return texelFetch(iChannel0, ivec2(p * PALETTE_WIDTH, 1), 0);\n}\n\nvec4 palette1dNormalized(int i, float maxIts, vec2 z)\n{\n    return palette1d(normalizedIterationCount(float(i), z) / maxIts);\n}\n\n//just some woobly colors\nfloat woobly(vec2 z)\n{\n    vec2 zi = sin(z * 15. + iTime); \n    zi = vec2(pow(zi.x, 3.), pow(zi.y, 4.)); \n    return zi.x + zi.y;\n}\n\n//---the main loop---\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 c = fragCoord / iResolution.y - vec2(ar * .5, .5);\n\n    vec2 pan = texelFetch(iChannel0, PAN, 0).xy;\n    vec2 rotationZoom = texelFetch(iChannel0, ZOOM_ROTATE, 0).xy;\n    vec2 init = texelFetch(iChannel0, INITIAL, 0).xy;\n    vec2 user = texelFetch(iChannel0, USER_VAL, 0).xy;\n\n    #ifdef ENABLE_MOTION\n    user += vec2(cos(iTime), sin(iTime)) * .15;\n    #endif\n    \n    c = rotate(c, rotationZoom.x) * rotationZoom.y + pan;\n    \n    #ifdef DYNAMIC_ITS\n    \tint maxIts = min(DYNAMIC_ITS_MIN + int(float(DYNAMIC_ITS_MULTIPLE) / rotationZoom.y), MAX_ITS);\n    #else\n    \t#define maxIts MAX_ITS\n    #endif\n    \n    //compute the fractal function\n    FRACTAL_INIT\n        \n    int i = 0;\n    for (; i < maxIts; i++)\n    {\n        FRACTAL_STEP\n        BAILOUT_TEST\n    }\n    \n    //draw result\n    if (i == maxIts) //inside\n    {\n        fragColor = INNER_FUNC\n    }\n    else //outside\n    { \t\n        fragColor = OUTER_FUNC\n    }\n}\n\n\n//complex number properties:\n//c_abs_sqr: the square of the magnitude of the complex number (equivalent to dot(z,z))\n//c_abs: equivalent to length(z)\n//c_arg: the argument of the complex number (equivalent to atan2(z.x,z.y))\n\n//complex functions (cartesian):\n//there is no c_add, c_sub - just use vector operations for addition and subtraction.\n//c_mul, c_div: multiply and divide two complex numbers.\n//Use the equivalent vector operations for multiplication and division by a float.\n//c_conj - conjugate\n//c_recip - fast reciprocal\n//c_sqr - fast square - faster than c_mul(c,c)\n//c_sqrt - square root.  branches depending on sign of imaginary.\n//c_sqrt_a - square root with no branching.  Always returns +imaginary result.\n//c_log - natural logarithm\n//c_exp - exponentiation\n//c_pow - complex power.  optimized override for real powers.\n//c_polar - convert to polar coordinates (x,y) -> (radius, angle)\n//c_cart - convert to cartesian coordinates (radius, angle) -> (x,y)\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SMOOTHSTEP_PALETTE //use smoothstep instead of linear interpolation for palette\n#define PALETTE_WIDTH 512. //this value should not exceed iResolution.x\n#define IM_DIM ivec2(512, 512); //dimensions for procedurally generated image.  Should not exceed iResolution\n\n//don't change these constants\n#define PX_MOUSE 1\n#define PX_PAN 0\n#define PX_ZOOM_ROTATE 2\n#define PX_INITIAL 3\n#define PX_USER 4\n\n#define MOUSE ivec2(PX_MOUSE, 0)\n#define PAN ivec2(PX_PAN, 0)\n#define ZOOM_ROTATE ivec2(PX_ZOOM_ROTATE, 0)\n#define INITIAL ivec2(PX_INITIAL, 0)\n#define USER_VAL ivec2(PX_USER, 0)\n\n#define PI 3.14159265358979\n#define HALF_PI 1.570796327\n#define TAU 6.28318530717958\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(vec2 vec, float angle)\n{\n    float sa = sin(angle);\n    float ca = cos(angle); //float ca = sqrt(1. - sa * sa); //<-- not sure if faster\n    return vec2(vec.x * ca - vec.y * sa,\n                vec.x * sa + vec.y * ca);\n}\n\n//complex number function macros\n#define c_pow4(value) c_sqr(c_sqr(value)) //power 4\n#define c_abs(value) length(value)\n\n//complex number properties\nfloat c_abs_sqr(in vec2 value) //magnitude squared.  should be inlined so no performance loss\n{\n    return dot(value, value);\n}\n\nfloat c_arg(in vec2 value)\n{\n    float a = atan(value.y / value.x);\n    if (value.x >= 0.)\n        return a;\n    else //if (value.x < 0.)\n    {\n        if (value.y > 0.)\n\t        return a + PI;\n        else\n            return a - PI;\n    }\n    /*\n    else //x == 0\n    {\n        return (value.y > 0.) ? HALF_PI : -HALF_PI;\n    }\n\t*/\n}\n\n//complex number functions\nvec2 c_conj(in vec2 value)\n{\n    return vec2(value.x, -value.y);\n}\n\nvec2 c_recip(in vec2 value)\n{\n    return c_conj(value) / dot(value, value);\n}\n\nvec2 c_mul(in vec2 left, in vec2 right)\n{\n    return left.xy * right.x + vec2(-left.y, left.x) * right.y;\n}\n\nvec2 c_div(in vec2 left, in vec2 right)\n{\n    float inv_denom = 1. / dot(right, right);\n    return (left.xy * right.x + vec2(left.y, -left.x) * right.y) * inv_denom;\n}\n\nvec2 c_sqr(in vec2 value) //square a number\n{\n    return vec2(value.x * value.x - value.y * value.y,\n                2. * value.x * value.y);\n}\n\nvec2 c_sqrt(in vec2 value)\n{\n    float lambda = length(value);\n    float halfx = value.x * .5;\n    return vec2(sqrt(lambda + halfx), \n                sqrt(lambda - halfx) *\n                (value.y >= 0. ? 1. : -1.));\n}\n\nvec2 c_sqrt_a(in vec2 value) //square root without branching\n{\n    float lambda = length(value);\n    float halfx = value.x * .5;\n    return vec2(sqrt(lambda + halfx), sqrt(lambda - halfx));\n}\n\nvec2 c_log(in vec2 value) //natural logarithm\n{\n   return vec2(.5 * log(dot(value, value)), c_arg(value)); \n}\n\nvec2 c_exp(in vec2 value) //e^z\n{\n    return vec2(cos(value.y), sin(value.y)) * exp(value.x);\n}\n\nvec2 c_pow(in vec2 left, in vec2 right)\n{\n    return c_exp(c_mul(c_log(left), right));\n}\n\nvec2 c_pow(in vec2 left, in float right)\n{\n    return c_exp(c_log(left) * right);\n}\n\n//transforms cartesian coordinates (x, y) to polar coordinates (magnitude, angle)\nvec2 c_polar(in vec2 coord)\n{\n    return vec2(length(coord), c_arg(coord));\n}\n\n//transforms polar coordinates (magnitude, angle) to cartesian coordinates (x, y)\nvec2 c_cart(in vec2 polar)\n{\n    return vec2(cos(polar.y), sin(polar.y)) * polar.x;\n}\n\n//RNG - thanks https://www.shadertoy.com/view/4djSRW (I think this is the original source)\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//palette functions\n#define repeat(p, m) mod(p * m, m)\n\n#ifdef SMOOTHSTEP_PALETTE\nvec4 palette(vec3 color0, vec3 color1, float p)\n{\n    p = mod(p, 1.);\n    return vec4(mix(color0, color1, smoothstep(0., 1., p)), 1);\n}\n                \nvec4 palette(vec3 color0, vec3 color1, vec3 color2, float p)\n{\n    return ((p = repeat(p, 3.)) <= 1.) ? vec4(mix(color0, color1, smoothstep(0., 1., p)), 1) :\n        (p <= 2.) ? vec4(mix(color1, color2, smoothstep(0., 1., p - 1.)), 1) :\n        vec4(mix(color2, color0, smoothstep(0., 1., p - 2.)), 1);\n}\n\nvec4 palette(vec3 color0, vec3 color1, vec3 color2, vec3 color3, float p)\n{\n    return ((p = repeat(p, 4.)) <= 1.) ? vec4(mix(color0, color1, smoothstep(0., 1., p)), 1) :\n        (p <= 2.) ? vec4(mix(color1, color2, smoothstep(0., 1., p - 1.)), 1) :\n    \t(p <= 3.) ? vec4(mix(color2, color3, smoothstep(0., 1., p - 2.)), 1) :\n        vec4(mix(color3, color0, smoothstep(0., 1., p - 3.)), 1);\n}\n\nvec4 palette(vec3 color0, vec3 color1, vec3 color2, vec3 color3, vec3 color4, float p)\n{\n    return ((p = repeat(p, 5.)) <= 1.) ? vec4(mix(color0, color1, smoothstep(0., 1., p)), 1) :\n        (p <= 2.) ? vec4(mix(color1, color2, smoothstep(0., 1., p - 1.)), 1) :\n    \t(p <= 3.) ? vec4(mix(color2, color3, smoothstep(0., 1., p - 2.)), 1) :\n    \t(p <= 4.) ? vec4(mix(color3, color4, smoothstep(0., 1., p - 3.)), 1) :\n        vec4(mix(color4, color0, smoothstep(0., 1., p - 4.)), 1);\n}\n\nvec4 palette(vec3 color0, vec3 color1, vec3 color2, vec3 color3, vec3 color4, vec3 color5, float p)\n{\n    return ((p = repeat(p, 6.)) <= 1.) ? vec4(mix(color0, color1, smoothstep(0., 1., p)), 1) :\n        (p <= 2.) ? vec4(mix(color1, color2, smoothstep(0., 1., p - 1.)), 1) :\n    \t(p <= 3.) ? vec4(mix(color2, color3, smoothstep(0., 1., p - 2.)), 1) :\n    \t(p <= 4.) ? vec4(mix(color3, color4, smoothstep(0., 1., p - 3.)), 1) :\n        (p <= 5.) ? vec4(mix(color4, color5, smoothstep(0., 1., p - 4.)), 1) :\n        vec4(mix(color5, color0, smoothstep(0., 1., p - 5.)), 1);\n}\n#else\nvec4 palette(vec3 color0, vec3 color1, float p)\n{\n    p = mod(p, 1.);\n    return vec4(mix(color0, color1, p), 1);\n}\n                \nvec4 palette(vec3 color0, vec3 color1, vec3 color2, float p)\n{\n    return ((p = repeat(p, 3.)) <= 1.) ? vec4(mix(color0, color1, p), 1) :\n        (p <= 2.) ? vec4(mix(color1, color2, p - 1.), 1) :\n        vec4(mix(color2, color0, p - 2.), 1);\n}\n\nvec4 palette(vec3 color0, vec3 color1, vec3 color2, vec3 color3, float p)\n{\n    return ((p = repeat(p, 4.)) <= 1.) ? vec4(mix(color0, color1, p), 1) :\n        (p <= 2.) ? vec4(mix(color1, color2, p - 1.), 1) :\n    \t(p <= 3.) ? vec4(mix(color2, color3, p - 2.), 1) :\n        vec4(mix(color3, color0, p - 3.), 1);\n}\n\nvec4 palette(vec3 color0, vec3 color1, vec3 color2, vec3 color3, vec3 color4, float p)\n{\n    return ((p = repeat(p, 5.)) <= 1.) ? vec4(mix(color0, color1, p), 1) :\n        (p <= 2.) ? vec4(mix(color1, color2, p - 1.), 1) :\n    \t(p <= 3.) ? vec4(mix(color2, color3, p - 2.), 1) :\n    \t(p <= 4.) ? vec4(mix(color3, color4, p - 3.), 1) :\n        vec4(mix(color4, color0, p - 4.), 1);\n}\n\nvec4 palette(vec3 color0, vec3 color1, vec3 color2, vec3 color3, vec3 color4, vec3 color5, float p)\n{\n    return ((p = repeat(p, 6.)) <= 1.) ? vec4(mix(color0, color1, p), 1) :\n        (p <= 2.) ? vec4(mix(color1, color2, p - 1.), 1) :\n    \t(p <= 3.) ? vec4(mix(color2, color3, p - 2.), 1) :\n    \t(p <= 4.) ? vec4(mix(color3, color4, p - 3.), 1) :\n        (p <= 5.) ? vec4(mix(color4, color5, p - 4.), 1) :\n        vec4(mix(color5, color0, p - 5.), 1);\n}\n#endif","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this buffer holds static values used for panning, etc\n//and also the palette\n#define ENABLE_KEYBOARD_CONTROLS //enables use of +,-,lrud\n\n#define KEY_Z 90 //Z = pan\n#define KEY_X 88 //X = rotate/zoom\n#define KEY_C 67 //C = inital value for Z\n#define KEY_V 86 //V = extra variable - depends on formula\n#define KEY_B 66\n#define KEY_P 80 \n#define KEY_K 75\n#define KEY_PLUS 107 //zoom in\n#define KEY_MINUS 109 //zoom out\n\n#define PX_MODE 10 \n#define PX_COLOR_COUNT 20\n\n#define MODE ivec2(PX_MODE, 0)\n#define UNDEFINED vec2(-1,-1)\n#define COLOR_COUNT ivec2(PX_COLOR_COUNT, 0)\n\n//initial colors: define up to 5 colors here.\n//Don't forget to update the call to palette() with the number of colors used,\n//and restart the animation to apply the new palette\n//spectrum colors\n//#define COLOR1 vec3(1,0,0) //red\n//#define COLOR2 vec3(1,1,0) //yel\n//#define COLOR3 vec3(0,1,0) //grn\n//#define COLOR4 vec3(0,0,1) //blu\n//#define COLOR5 vec3(.25,0,.5) //mag\n\n//blue/orange set\n#define COLOR1 vec3(0,0,0) \n#define COLOR2 vec3(0,0,1)\n#define COLOR3 vec3(1,1,1)\n#define COLOR4 vec3(1,.75,0)\n#define COLOR5 vec3(0,0,1) \n\n//layout of this texture: scanline 0\n//pixels 1 - 9 contain mouse variables, given by the PX_ constants in the Common file\n//pixel 10 contains the mode, set by keyboard press, determined by the KEY_ constants above\n//pixel 20 contains the the number of colors that will be used to form the palette\n//pixels 21 - 29 contain the colors that will form the palette, randomized when press 'p'\n//scanline 1 is the palette - computed on press 'p' - to be texelFetched in the main shader\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal > .5) ? true : false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.y > 1) return;\n    \n    if (coord.y == 0)\n    {\n        if (iMouse.z > 0.) //mouse down\n        {\n            if (coord.x == PX_MOUSE) {\n\t            fragColor = vec4(iMouse.xy, 0, 0); //set pixel to mouse pos\n                return;\n            }\n            int mode = int(texelFetch(iChannel0, MODE, 0).x);\n            vec2 zoomAngle;\n            if (mode != coord.x)\n            {\n                fragColor = texelFetch(iChannel0, coord, 0); //preserve pixels\n                return;\n            }\n\t\t\tvec2 lastMouse = texelFetch(iChannel0, MOUSE, 0).xy;\n            if (lastMouse == UNDEFINED)\n            {\n                fragColor = texelFetch(iChannel0, coord, 0); //preserve pixels\n                return;\n            }\n            switch (coord.x)\n            {\n            \tcase PX_PAN:\n                    vec2 pan = texelFetch(iChannel0, PAN, 0).xy;\n                    zoomAngle = texelFetch(iChannel0, ZOOM_ROTATE, 0).xy;\n                    fragColor = vec4(pan + rotate(lastMouse - iMouse.xy, zoomAngle.x) * zoomAngle.y / iResolution.y, 0, 0);\n                \tbreak;\n            \tcase PX_ZOOM_ROTATE:\n                    zoomAngle = texelFetch(iChannel0, ZOOM_ROTATE, 0).xy;\n                \tvec2 mouseDelta = lastMouse - iMouse.xy;\n                    fragColor = vec4(zoomAngle.x - mouseDelta.x * TAU / iResolution.x, \n                                     zoomAngle.y * (1. + mouseDelta.y * 4. / iResolution.y), 0, 0);\n                \tbreak;\n            \tcase PX_INITIAL:\n                    vec2 init = texelFetch(iChannel0, INITIAL, 0).xy;\n                    zoomAngle = texelFetch(iChannel0, ZOOM_ROTATE, 0).xy;\n                    fragColor = vec4(init + rotate(lastMouse - iMouse.xy, zoomAngle.x) * (zoomAngle.y) / iResolution.y, 0, 0);\n                \tbreak;\n\t\t\t\tcase PX_USER:\n                    vec2 user = texelFetch(iChannel0, USER_VAL, 0).xy;\n                    zoomAngle = texelFetch(iChannel0, ZOOM_ROTATE, 0).xy;\n                    fragColor = vec4(user - rotate(lastMouse - iMouse.xy, zoomAngle.x) * (zoomAngle.y) / iResolution.y, 0, 0);\n                \tbreak;\n            }\n        }\n        else //no mouse\n        {\n            if (coord == MOUSE) //reset mouse pos\n                fragColor = vec4(UNDEFINED,0,0); \n            else if (coord == ZOOM_ROTATE) //make sure zoom doesn't == 0\n            {\n                vec2 zoomAngle = texelFetch(iChannel0, coord, 0).xy;\n                if (zoomAngle.y == 0.) zoomAngle.y = 1.75;\n#ifdef ENABLE_KEYBOARD_CONTROLS\n                if (ReadKey(KEY_PLUS, false)) \n                    zoomAngle.y *= .97;\n                else if (ReadKey(KEY_MINUS, false))\n                    zoomAngle.y /= .97;\n#endif\n                fragColor = vec4(zoomAngle,0,0);\n            }\n            else if (coord == MODE) //check key presses\n            {\n                if (ReadKey(KEY_Z, false)) //z for pan\n                    fragColor = vec4(PX_PAN,0,0,0);\n                else if (ReadKey(KEY_X, false)) //x for zoom/rotate\n                    fragColor = vec4(PX_ZOOM_ROTATE,0,0,0);\n                else if (ReadKey(KEY_C, false)) //c for initial coords\n                    fragColor = vec4(PX_INITIAL,0,0,0);\n                else if (ReadKey(KEY_V, false)) //v for user value\n                \tfragColor = vec4(PX_USER,0,0,0);\n                else\n                    fragColor = texelFetch(iChannel0, coord, 0); //preserve pixels\n            } else if (ReadKey(KEY_P, false))\n            {\n                if (coord == COLOR_COUNT)//set color count with a random number of colors\n                {\n                    fragColor = vec4(int(abs(hash11(iTime)) * 12. + 3.), 0, 0, 0); //generate random # of colors 3-15\n                } else if (coord.x > PX_COLOR_COUNT && coord.x < PX_COLOR_COUNT + 20) //assign 20 random colors\n                {\n                    //make a color with random hue, usually high saturation, and slightly dark\n                    vec3 hsv = hash33(vec3(fragCoord.x, sin(iTime * 2.5663), iTime));\n                    vec3 color = hsv2rgb(vec3(hsv.x, 1. - hsv.y * hsv.y * hsv.y, 1. - hsv.z * hsv.z));\n                    fragColor = vec4(color, 1.);\n                }\n\t            else //unused coord\n    \t            fragColor = texelFetch(iChannel0, coord, 0); //preserve pixels\n            } \n            else //unused coord\n                fragColor = texelFetch(iChannel0, coord, 0); //preserve pixels\n        }\n    } else //if (coord.y == 1)\n    {\n        if (iFrame == 0) //generate initial palette\n        {\n            float px = fragCoord.x / PALETTE_WIDTH;\n            fragColor = palette(COLOR1, COLOR2, COLOR3, COLOR4, COLOR5, px);\n        } else if (ReadKey(KEY_P, false)) //no mouse, pressing P\n        {\n            float colorCount = texelFetch(iChannel0, COLOR_COUNT, 0).x;\n            float px = fragCoord.x / PALETTE_WIDTH * colorCount;\n            fragColor = mix(texelFetch(iChannel0, ivec2(float(PX_COLOR_COUNT + 1) + px, 0), 0),\n                            texelFetch(iChannel0, ivec2(float(PX_COLOR_COUNT + 1) + mod(px + 1., colorCount), 0), 0),\n                            fract(px));\n            //fragColor = texture(iChannel0, vec2(float(PX_COLOR_COUNT + 1) + px / iResolution.x, 0.)); //lerp the colors we created\n        } \n        else\n            fragColor = texelFetch(iChannel0, coord, 0); //preserve pixels\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}