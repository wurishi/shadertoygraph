{"ver":"0.1","info":{"id":"4styWN","date":"1518927586","viewed":114,"name":"Ball on a bowl","username":"RudyO","description":"After my first shader this is my second one (at least that I made public :-))\nI'm new and have to learn a lot, but I like what you can do with shaders.\nNow right away I have a question.\nBut that I will put in my comment.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["phong","ball","bowl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * This code is inspired by code from jlfwong and the tutorials.\n * Also I used code snippets from Inigo's website\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nbool bBall = false;\nbool bTable = false;\n\n// Torus - signed - exact\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n// Plane - signed - exact\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r;\n */\nfloat sphereSDF(vec3 samplePoint, float r) \n{\n    return length(samplePoint) - r;\n}\n\n/**\n * Signed distance function for a sphere centered at specific location (Loc) with radius r;\n */\nfloat sphereSDF(vec3 samplePoint, vec3 Loc, float r)\n{\n    \n    return length(Loc-samplePoint) - r;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint, bool shadow)\n{\n    vec3 flip = samplePoint.xzy;\n    \n    flip.x -= 0.4;\n    flip.z += 0.26;\n    \n    float ear = sdTorus(flip, vec2(0.08, 0.02));\n    float outside = sphereSDF(samplePoint, 0.4);\n    \n    float cutaway = sdPlane(samplePoint, normalize(vec4(0.0, 1.0, 0.0, 0.15)));\n    \n    float inside = sphereSDF(samplePoint, 0.35);\n    \n    outside = max(outside, cutaway);\n    \n    outside = max(-inside, outside);\n    \n    float ball = sphereSDF(samplePoint, vec3(cos(iTime)*0.35, -0.1, sin(iTime)*0.35), 0.05);\n    \n    float table = sdPlane(samplePoint, normalize(vec4(0.0, 1.0, 0.0, 0.5)));\n    \n    bBall = ball < outside && ball < ear;;\n    \n    bTable = table < outside && table < ball && table < ear;\n    \n    if (shadow)\n        return min(min(outside, ball), ear);\n    \n    return min(min(outside, ball), min(table, ear));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, bool shadow) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float dist = sceneSDF(eye + depth * marchingDirection, shadow);\n        \n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), false) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), false),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), false) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), false),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON),false) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), false)\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.75 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(12.0, 22.0, 2.0);\n    vec3 light1Intensity = vec3(0.4*sin(iTime), 0.64*sin(iTime), 0.4)*sin(iTime);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(-5.0, 12.0,5.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.84);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nfloat rot \t= 0.0;\nfloat dist \t= 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rot = (iMouse.x/iResolution.x)*2.0*3.14;\n    \n    dist = clamp((iMouse.y/iResolution.y)*3.0, 1.0, 3.0);\n    \n    vec2 uv = 2.*(fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    vec3 camO = vec3(sin(rot), 0.0, cos(rot))*dist;\n    vec3 camD = normalize(vec3(0.0, 0.0, 0.0)-camO);\n    vec3 camR = normalize(cross(camD,vec3(0,1,0)));\n    vec3 camU = cross(camR,camD);\n   \tvec3 dir =  normalize(uv.x*camR+uv.y*camU+camD);\n    \n    float dist = shortestDistanceToSurface(camO, dir, MIN_DIST, MAX_DIST, false);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = texture(iChannel1, dir).rgba;\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = camO + dist * dir;\n    \n    vec3 K_a = bBall ? vec3(0.14, 0.14, 0.14): vec3(0.82, 0.2, 0.2);\n    vec3 K_d = vec3(0.82, 0.2, 0.2);\n    vec3 K_s = vec3(0.82, 0.82, 0.82);\n    float shininess = 40.0;\n    \n    vec4 color;\n    \n    if (!bTable)\n   \t\tcolor = vec4(vec3(phongIllumination(K_a, K_d, K_s, shininess, p, camO)),1.0);\n    else\n        color = texture(iChannel0, p.xz);\n\n    // When we hit the table then create a shadow...\n    if (bTable)\n    {\n     \tdist = shortestDistanceToSurface(p, normalize(vec3(12.0, 22.0, 2.0)-p), MIN_DIST, MAX_DIST, true);\n        \n        if (dist < (MAX_DIST-EPSILON))\n        \tcolor *= 0.6;\n    }\n    \n    fragColor = vec4(color);\n}\n\n","name":"Image","description":"","type":"image"}]}