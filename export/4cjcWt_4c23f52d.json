{"ver":"0.1","info":{"id":"4cjcWt","date":"1723151091","viewed":49,"name":"common raytracer bug (ES only?)","username":"bitshifter","description":"exposes common bug where passing struct to function causes loss of precision","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 300 es\n\n#define ENABLE_BUG 1 // disable(0) enable(1)\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#if ENABLE_BUG\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n#endif\n\nfloat intersectSphere(\n#if ENABLE_BUG\n  Ray ray, // [BUG] loss of precision when passing struct\n#else\n  vec3 rayOrigin, vec3 rayDirection,\n#endif\n  vec3 sphereOrigin, float sphereRadius)\n{\n#if ENABLE_BUG\n  vec3 rayOrigin = ray.origin;\n  vec3 rayDirection = ray.direction;\n#endif\n  vec3 v = sphereOrigin - rayOrigin;\n\n  float b = dot(v,rayDirection);\n\n  float d = b * b - dot(v,v) + sphereRadius * sphereRadius;\n\n  return (d < 0.0) ? d : (b - sqrt(d)); //tmin (<0=nohit)\n}\n\nvec4 intersectScene (vec3 rayOrigin, vec3 rayDirection)\n{\n  vec3 finalColor = vec3(0.0, 0.0, 0.0);\n\n  float sphereRadius = 0.5;\n  vec3 sphereOrigin = vec3(0.0, 0.0, 0.0);\n\n#if ENABLE_BUG\n  Ray ray = Ray(rayOrigin, rayDirection);\n#endif\n\n  float intersectionDistance = intersectSphere(\n#if ENABLE_BUG\n    ray,\n#else\n    rayOrigin, rayDirection,\n#endif\n    sphereOrigin, sphereRadius);\n\n  if (intersectionDistance >= 0.0)\n  {\n    vec3 ambientColor = vec3(0.0, 0.0, 0.0);\n\n    vec3 diffuseColor = vec3(1.0, 1.0, 1.0);\n\n    vec3 intersectionPoint = rayOrigin + rayDirection * intersectionDistance;\n\n    vec3 surfaceNormal = normalize(intersectionPoint - sphereOrigin);\n\n    vec3 lightOrigin = vec3(-2.0, 2.0, 2.0);\n\n    vec3 shadowVec = normalize(lightOrigin - intersectionPoint);\n\n    float lambert = 1.0;//max(0.0, dot(surfaceNormal, shadowVec));\n\n    finalColor = max(ambientColor, diffuseColor * lambert);\n  }\n\n  return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n#if 1   // use half pixel border (+0.5)\n  float pixelCoordX = fragCoord.x;\n  float pixelCoordY = fragCoord.y;\n#else   // use integer pixel border (+0.0)\n  float pixelCoordX = fragCoord.x - 0.5;\n  float pixelCoordY = fragCoord.y - 0.5;\n#endif\n\n  float screenCenterX = iResolution.x * 0.5;\n  float screenCenterY = iResolution.y * 0.5;\n\n  float angleOfView = radians(90.0);\n  float focalLength = screenCenterX / tan(angleOfView * 0.5);\n\n  float projectionX = pixelCoordX - screenCenterX;\n  float projectionY = pixelCoordY - screenCenterY;\n  float projectionZ = focalLength;\n  float projectionW = 1.0;\n\n  vec3 lookAtOrigin = vec3(3.0, 2.0, 1.0); // get off zero to amplify artifacts\n  vec3 lookAtTarget = vec3(0.0, 0.0, 0.0);\n  vec3 lookAtUpDir = vec3(0.0, 1.0, 0.0);\n\n  vec3 cameraAxisZ = normalize(lookAtTarget - lookAtOrigin);\n  vec3 cameraAxisX = normalize(cross(lookAtUpDir, cameraAxisZ));\n  vec3 cameraAxisY = normalize(cross(cameraAxisZ, cameraAxisX));\n  vec3 cameraOrigin = lookAtOrigin;\n\n  vec3 projectionPoint =\n    cameraAxisX  * projectionX +\n    cameraAxisY  * projectionY +\n    cameraAxisZ  * projectionZ +\n    cameraOrigin * projectionW;\n\n  vec3 rayOrigin = cameraOrigin;\n  vec3 rayDirection = normalize(projectionPoint - rayOrigin);\n\n  fragColor = intersectScene(rayOrigin, rayDirection);\n}\n","name":"Image","description":"","type":"image"}]}