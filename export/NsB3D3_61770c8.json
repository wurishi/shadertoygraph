{"ver":"0.1","info":{"id":"NsB3D3","date":"1618006253","viewed":68,"name":"472_raymarch_wip1","username":"asneakyfatcat","description":"learning raymarching, thought it looked neat","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["peepeepoopoo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int max_steps=255;\nconst float min_dist=0.;\nconst float max_dist=100.;\nconst float epsilon=0.0001;\n\n\nfloat plane(vec3 p, vec3 n, float h){\n    return dot(p,normalize(n))+h;\n}\n\nfloat sphere(vec3 p,float r){\n    // point, radius\n    return length(p)-r;\n}\n\nfloat scene(vec3 p){\n    p.x=sin(p.x+5.*cos(iTime));\n    p.y=cos(p.y+5.*sin(iTime));\n    p.z=abs(p.z*sin(iTime))*.5+p.z-96.;\n    return sphere(p,1.);\n    //return plane(vec3(0,1,0),vec3(0,-1,0),1.);\n}\n\n// calculate normals using voodoo bullshit tetrahedron gradient approximation \n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p ){\n    const float h = epsilon;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ) + \n                      k.yyx*scene( p + k.yyx*h ) + \n                      k.yxy*scene( p + k.yxy*h ) + \n                      k.xxx*scene( p + k.xxx*h ) );\n}\n\n// return distance to surface\nfloat toSurface(vec3 eye, vec3 dir, float start, float end){\n    float depth = start;\n    for (int i=0; i<max_steps; i++){\n        float dist = scene(eye+depth*dir);\n        if(dist<epsilon){\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end){\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDir(vec2 fragCoord, vec2 res, float fov){\n    vec2 xy = fragCoord.xy - res.xy/2.0;\n    // calculate z\n    float z = (res.x/2.)/tan(radians(fov)/2.);\n    return normalize(vec3(xy,z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // setup coord system 0,1\n    // convert from 0,1 to -1,1 to play nice with sin/cos\n    // fix aspect ratio\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv = uv*2.0 - 1.0;\n    //uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(0.,0.,-1.);\n    vec3 dir = rayDir(fragCoord,iResolution.xy,90.);\n    float dist = toSurface(eye,dir,min_dist,max_dist);\n    vec3 pN = eye+dist*dir;\n    pN = normal(pN);\n    \n    if(dist > (max_dist - epsilon)){\n        fragColor = texture(iChannel0,dir);\n        return;\n    }\n    else{\n        //fragColor = vec4(0.,1.,1.,1.);\n        //fragColor = vec4(pN,1.);\n        fragColor = vec4(texture(iChannel1,uv).xyz*dot(pN,dir)*.5+.5,1.);\n    }\n}","name":"Image","description":"","type":"image"}]}