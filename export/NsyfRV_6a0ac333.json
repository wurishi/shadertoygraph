{"ver":"0.1","info":{"id":"NsyfRV","date":"1658457464","viewed":208,"name":"Electric vector field","username":"ria8651","description":"The electric field between a line of charge, and 2 electrons (https://www.shadertoy.com/view/4s23DG for the vector field)","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["field"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CONTOURS 0\n\nstruct Field {\n    vec2 vec;\n    float charge;\n};\n\nconst int parts = 30;\n\nField field(vec2 pos) {\n    vec2 uv = (pos / iResolution.y) * 2.0 - 1.0;\n    vec2 mouse = (iMouse.xy / iResolution.y) * 2.0 - 1.0;\n    if (iMouse.x < 5.0) {\n        mouse = vec2(0.6 * cos(iTime * 0.64), 0.6 * sin(iTime * 0.45));\n    }\n    \n    // xy: position, z: charge\n    // vec3 particles[3] = vec3[3](\n    //     vec3(0.0, 0.0, 0.2),\n    //     vec3(1.5, 0.0, -0.2),\n    //     vec3(mouse, -0.3)\n    // );\n    vec3 particles[parts + 2];\n    for (int i = 0; i < parts; i++) {\n        particles[i] = vec3(0.0, -0.5 + float(i) / float(parts), 0.2 / float(parts));\n    }\n    particles[parts - 1] = vec3(mouse, -0.3);\n    particles[parts] = vec3(2.0, 0.0, 0.2);\n    \n    vec2 el = vec2(0.0);\n    float ch = 0.0;\n    \n    for (int i = 0; i < parts + 2; i++) {\n        vec2 dir = uv - particles[i].xy;\n        float charge = particles[i].z / pow(length(dir), 2.0);\n        el += charge * normalize(dir);\n        ch += charge;\n    }\n\n\treturn Field(el, ch);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Field f = field(fragCoord.xy);\n    vec3 colour = mix(vec3(0.8, 1.0, 1.0), vec3(1.0, 1.0, 0.8), f.charge);\n    \n    if (CONTOURS != 0) {\n        float c = abs(f.charge * 5.0);\n        float contour = fract(c);\n        if (mod(c, 2.0) > 1.0) contour = 1.0 - contour;\n\n        contour = clamp(contour / fwidth(c), 0.0, 1.0);\n        colour *= contour;\n    }\n\n\tfragColor = (1.0 - arrow(fragCoord.xy, field(arrowTileCenterCoord(fragCoord.xy)).vec * ARROW_TILE_SIZE * 0.4)) * vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 2D vector field visualization by Morgan McGuire, @morgan3d, http://casual-effects.com\nconst float PI = 3.1415927;\nconst int   ARROW_LINE_STYLE = 1;\n\n// Choose your arrow head style\nconst int   ARROW_STYLE = 1;\nconst float ARROW_TILE_SIZE = 32.0;\n\n// How sharp should the arrow head be? Used\nconst float ARROW_HEAD_ANGLE = 30.0 * PI / 180.0;\n\n// Used for ARROW_LINE_STYLE\nconst float ARROW_HEAD_LENGTH = ARROW_TILE_SIZE / 6.0;\nconst float ARROW_SHAFT_THICKNESS = 1.0;\n\t\n\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n\n// v = field sampled at tileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns 1.0 where there is an arrow pixel.\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n    float mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_p = p / mag_p, dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE / 2.0);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\t\t\n\t\t// Define a 2D implicit surface so that the arrow is antialiased.\n\t\t// In each line, the left expression defines a shape and the right controls\n\t\t// how quickly it fades in or out.\n\n        // Signed distance from a line segment based on https://www.shadertoy.com/view/ls2GWG by \n        // Matthias Reitinger, @mreitinger\n\n        // Line arrow style\n        float dist = \n            max(\n                // Shaft\n                ARROW_SHAFT_THICKNESS / 4.0 - \n                    max(abs(dot(p, vec2(dir_v.y, -dir_v.x))), // Width\n                        abs(dot(p, dir_v)) - mag_v + ARROW_HEAD_LENGTH / 2.0), // Length\n\n                 // Arrow head\n                 min(0.0, dot(v - p, dir_v) - cos(ARROW_HEAD_ANGLE / 2.0) * length(v - p)) * 2.0 + // Front sides\n                 min(0.0, dot(p, dir_v) + ARROW_HEAD_LENGTH - mag_v)); // Back\n\t\t\n\t\treturn clamp(1.0 + dist, 0.0, 1.0);\n\t} else {\n\t\t// Center of the pixel is always on the arrow\n\t\treturn max(0.0, 1.2 - mag_p);\n\t}\n}","name":"Common","description":"","type":"common"}]}