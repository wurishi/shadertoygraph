{"ver":"0.1","info":{"id":"dtlXzB","date":"1675014809","viewed":202,"name":"Barth Decic (+ Halley's Method)","username":"fizzer","description":"The [url=https://mathworld.wolfram.com/BarthDecic.html]Barth Decic[/url], raytraced with root-finding algorithm. I added a 3rd-order root-finding algorithm but it doesn't do much better, possibly due to precision issues.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["geometry","surface","dual","real","algebraic","decic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://mathworld.wolfram.com/BarthDecic.html\n\n// The rendered image has far fewer artifacts with Halley's method than Newton's,\n// but is still not completely perfect.\n// The 3rd-order Householder's method doesn't improve things much in this implementation, but\n// it might be suffering from a lack of numerical precision.\n\n// https://en.wikipedia.org/wiki/Householder%27s_method\n\n// Related: https://www.shadertoy.com/view/DlfXzB\n\n#define AA              2\n#define USE_NEWTON      0\n#define USE_HALLEY      1\n#define USE_HOUSEHOLDER 0\n\nconst float circumradius = sqrt((5. + sqrt(5.)) / 2.);\n\n// Sphere intersection function from IQ\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    vec3 qc = oc - b*rd;\n    float h = ra*ra - dot( qc, qc );\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Extended dual number\nstruct Dual\n{\n   float  f; // f\n   vec3   d; // df/dt, d²f/dt², d³f/dt³\n};\n\nconst Dual w = Dual(1., vec3(0));\nconst Dual phi = Dual((1. + sqrt(5.)) / 2., vec3(0));\n\nDual dMul(Dual a, Dual b)\n{\n    Dual res;\n    res.f = a.f * b.f;\n    res.d = vec3(a.d.x * b.f + a.f * b.d.x, // 1st-order product rule\n                 a.f * b.d.y + a.d.y * b.f + 2. * a.d.x * b.d.x, // 2nd-order product rule\n                 a.f * b.d.z + a.d.z * b.f + 3. * (a.d.y * b.d.x + a.d.x * b.d.y) // 3rd-order product rule\n                 );\n    return res;\n}\n\nDual dSqr(Dual a)\n{\n    return dMul(a, a);\n}\n\nDual dAdd(Dual a, Dual b)\n{\n   return Dual(a.f + b.f, a.d + b.d);\n}\n\nDual dSub(Dual a, Dual b)\n{\n   return Dual(a.f - b.f, a.d - b.d);\n}\n\nDual dConst(float x)\n{\n    return Dual(x, vec3(0));\n}\n\nDual dLinear(float x)\n{\n    return Dual(0., vec3(x, 0., 0.));\n}\n\nDual dPow(Dual a, int n)\n{\n    Dual r = Dual(0., vec3(0));\n    Dual b = a;\n    for(int i = 0; i < 4; ++i)\n    {\n        if((n & (1 << i)) != 0)\n            r = dAdd(r, b);\n        b = dMul(b, a);\n    }\n    return r;\n}\n\nDual dNeg(Dual a)\n{\n    return Dual(-a.f, -a.d);\n}\n\n#define GENERATE_OVERLOADS(op) \\\n    Dual op(Dual a, Dual b, Dual c) { return op(op(a, b), c); } \\\n    Dual op(Dual a, Dual b, Dual c, Dual d) { return op(op(a, b, c), d); } \\\n    Dual op(Dual a, Dual b, Dual c, Dual d, Dual e) { return op(op(a, b, c, d), e); } \\\n    Dual op(Dual a, Dual b, Dual c, Dual d, Dual e, Dual f) { return op(op(a, b, c, d, e), f); }\n    \nGENERATE_OVERLOADS(dAdd)\nGENERATE_OVERLOADS(dSub)\nGENERATE_OVERLOADS(dMul)\n\nDual dBarthDecic(Dual x, Dual y, Dual z)\n{\n    // 8(x²-φ⁴y²)(y²-φ⁴z²)(z²-φ⁴x²)(x⁴+y⁴+z⁴-2x²y²-2x²z²-2y²z²)+(3+5φ)(x²+y²+z²-w²)[x²+y²+z²-(2-φ)w²]²w²\n\n    Dual x2 = dSqr(x);\n    Dual y2 = dSqr(y);\n    Dual z2 = dSqr(z);\n    Dual w2 = dSqr(w);\n    Dual phi2 = dSqr(phi);\n    \n    Dual x4 = dSqr(x2);\n    Dual y4 = dSqr(y2);\n    Dual z4 = dSqr(z2);\n    Dual phi4 = dSqr(phi2);\n    \n    Dual a = dMul(dConst(8.), dMul(dSub(x2, dMul(phi4, y2)), dSub(y2, dMul(phi4, z2)), dSub(z2, dMul(phi4, x2)),\n            dAdd(x4, y4, z4, dMul(dConst(-2.), dAdd(dMul(x2, y2), dMul(x2, z2), dMul(y2, z2))))));\n    \n    Dual b = dMul(dAdd(dConst(3.), dMul(dConst(5.), phi)), dSqr(dAdd(x2, y2, z2, dNeg(w2))),\n                dSqr(dAdd(x2, y2, z2, dMul(dConst(phi.f - 2.), w2))), w2);\n                \n    return dAdd(a, b);\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a),  0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nvec3 traceRay(vec2 fragCoord)\n{\n    // Set up ray.\n    vec3 ro = vec3(0., 0., circumradius * 2.);\n    vec3 rd = normalize(vec3((fragCoord.xy - iResolution.xy / 2.) / iResolution.y, -1.));\n\n    mat3 m = mat3(1.);        \n            \n    if(iMouse.z > 0.)\n        m = rotY((iMouse.x / iResolution.x * 2. - 1.) * 2.) *\n            rotX((iMouse.y / iResolution.y * 2. - 1.) * 2.);\n    else\n        m = rotY(-sin(iTime / 2.)) * rotX(-sin(iTime / 3.));\n\n    ro = m * ro;\n    rd = m * rd;\n\n    float t = 1e5;\n\n    // Use ray-bounding-sphere intersection test to find initial estimate for root-finding.\n    vec2 s = sphIntersect(ro, rd, vec3(0), circumradius);\n\n    bool hit = false;\n    \n    if(s.x > 0. && s.x < s.y)\n    {\n        t = s.x;\n        \n        for(int i = 0; i < 70; ++i)\n        {\n            vec3 rp = ro + rd * t;\n            // Instead of the usual \"divide by length of gradient\", here the gradient along\n            // the ray is computed directly.\n            Dual res = dBarthDecic(dAdd(dConst(rp.x), dLinear(rd.x)),\n                                   dAdd(dConst(rp.y), dLinear(rd.y)),\n                                   dAdd(dConst(rp.z), dLinear(rd.z)));\n            if(t >= s.y)\n                break;\n                \n            if(res.f < 1e-4)\n            {\n                hit = true;\n                break;\n            }\n#if USE_NEWTON\n            // Newton: x = x - f(x) / f'(x)\n            t += min(.125, abs((res.f) / (res.d.x)));\n#elif USE_HALLEY\n            // Halley: x = x - 2f(x)f'(x) / (2(f'(x)²) - f(x)f''(x))\n            t += min(.125, abs(2. * res.f * res.d.x / (2. * res.d.x * res.d.x - res.f * res.d.y)));\n#elif USE_HOUSEHOLDER\n            // 3rd-order Householder:\n            float num = 3. * (2. * res.f * pow(res.d.x, 2.) - pow(res.f, 2.) * res.d.y);\n            float den = 6. * (pow(res.d.x, 3.) - res.f * res.d.x * res.d.y) + pow(res.f, 2.) * res.d.z;\n            t += min(.125, abs(num / den));\n#endif\n        }\n    }\n    \n    vec3 col = vec3(.06);\n\n    if(hit)\n    {\n        vec3 rp = ro + rd * t;\n        \n        // Surface normal from gradient of scalar field.\n        Dual res_x = dBarthDecic(dAdd(dConst(rp.x), dLinear(1.)),\n                                 dAdd(dConst(rp.y), dLinear(0.)),\n                                 dAdd(dConst(rp.z), dLinear(0.)));\n        Dual res_y = dBarthDecic(dAdd(dConst(rp.x), dLinear(0.)),\n                                 dAdd(dConst(rp.y), dLinear(1.)),\n                                 dAdd(dConst(rp.z), dLinear(0.)));\n        Dual res_z = dBarthDecic(dAdd(dConst(rp.x), dLinear(0.)),\n                                 dAdd(dConst(rp.y), dLinear(0.)),\n                                 dAdd(dConst(rp.z), dLinear(1.)));\n        vec3 n = -normalize(vec3(res_x.d.x, res_y.d.x, res_z.d.x));\n\n        // Base surface colour\n        vec3 diff = mix(vec3(.4, 1., .7).brg, vec3(1., 1., .7), smoothstep(1., 2.2, length(rp)));\n        diff = mix(diff, diff * .75, mod(floor(rp.x * 3.) + floor(rp.y * 3.) + floor(rp.z * 3.), 2.));\n        \n        \n        // Basic lighting\n        \n        float fr = mix(.01, 1., pow(1. - clamp(dot(rd, n), 0., 1.), 2.));\n        vec3 r = reflect(-rd, n);\n\n        vec3 l = normalize(vec3(-2,1,1));\n        col = diff * (dot(l, -n) * .5 + .5) * (1. - fr) * vec3(1., 1., .9).brg;\n        col += diff * mix(.25, 1., (dot(vec3(0,-1,0), -n) * .5 + .5) * (1. - fr)) * vec3(.2,.2,.4).brg;\n        col += smoothstep(.5, 1., max(0., dot(-r, l))) * fr * 1.1;\n    }\n    \n    return clamp(col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            col += traceRay(fragCoord + vec2(x, y) / float(AA));\n        }\n\n    col /= float(AA) * float(AA);\n\n    fragColor = vec4(sqrt(col), 1.);\n}","name":"Image","description":"","type":"image"}]}