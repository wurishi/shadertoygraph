{"ver":"0.1","info":{"id":"Ml3fR8","date":"1538603327","viewed":255,"name":"Nonlinear isotropic diffusion","username":"vchizhov","description":"Nonlinear isotropic diffusion. LMB - to apply diffusion, WS - to control lambda (the higher, the stronger the diffusivity). AD - to change mode (diffusivity function)","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["filtering","diffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tBased on the lectures on \"Nonlinear Isotropic Diffusion\" from the course \n\t\"Differential Equations in Image Processing and Computer Vision\", \n\tWinter Term 2017 / 2018, Saarland University\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// computes the gradient and g(|conv(K_1,grad(u)))|^2)\n// uses the gaussian smoothed image from bufferD to compute the gradient\n\n#define G(X,Y) texture(iChannel1, scale*(fragCoord+vec2(X,Y))).xyz\n\n// computes the squared magnitude per-channel of the sobel gradient\n// the sobel derivatives have better behaviour with respect to rotational invariance of |grad(u)|\nvec3 gradSobelMagnitudeSqr(vec3 value[9])\n{\n    vec3 dGdx = 0.125 * (-value[0] + value[2] - 2.0*value[3] + 2.0*value[5] - value[6] + value[8]);\n    vec3 dGdy = 0.125 * (value[0] + 2.0*value[1] + value[2] - value[6] - 2.0*value[7] - value[8]);\n    return dGdx*dGdx + dGdy*dGdy;\n}\n\n\n\n\n\n// Perona/Malik 1990\nfloat gPeronaMalik1(float sSqr, float lambda)\n{\n    return 1.0 / (1.0 + sSqr/(lambda*lambda));\n}\n\n// Perona/Malik 1990\nfloat gPeronaMalik2(float sSqr, float lambda)\n{\n    return exp(-0.5*sSqr/(lambda*lambda));\n}\n\n// Weickert 1998\nfloat gWeickert(float sSqr, float lambda)\n{\n    return abs(sSqr) < 0.00001 ? 1.0 : 1.0 - exp(-3.31488/pow(sSqr/(lambda*lambda),4.0));\n}\n\n// a family of diffusivities\n// p = -1 -> PeronaMalik1, p=-0.5 -> Charbonnier\nfloat gGenericFamily(float sSqr, float lambda, float p)\n{\n    return pow(1.0+sSqr/(lambda*lambda), p);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scale = 1.0 / iResolution.xy;\n    vec3 values[9]= vec3[9](G(-1,1), G(0,1), G(1,1),\n                               G(-1,0), G(0,0), G(1,0),\n                               G(-1,-1), G(-1,-1), G(-1,-1));\n    vec3 gradMagnitudeSqr = gradSobelMagnitudeSqr(values);\n    float joinGradMagnitudeSqr = gradMagnitudeSqr.r + gradMagnitudeSqr.g + gradMagnitudeSqr.b;\n    \n    vec2 inputInfo = texelFetch(iChannel2, ivec2(fragCoord), 0).xy;\n    float lambda = inputInfo.x;\n    int mode = int(inputInfo.y);\n    float g;\n    if(mode==0)\n    {\n        g = gPeronaMalik1(joinGradMagnitudeSqr, lambda);\n    }\n    else if(mode==1)\n    {\n        g = gPeronaMalik2(joinGradMagnitudeSqr, lambda);\n    }\n    else if(mode==2)\n    {\n        g = gWeickert(joinGradMagnitudeSqr, lambda);\n    }\n    else if(mode==3)\n    {\n        // Charbonnier\n        g = gGenericFamily(joinGradMagnitudeSqr, lambda, -0.5);\n    }\n    else //if(mode==4)\n    {\n        // linear diffusion\n        g = 1.0;\n    }\n    vec3 col = vec3(g);\n    fragColor = vec4(col,texture(iChannel1, fragCoord).w);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define G(X,Y) texture(iChannel0, scale*(fragCoord+vec2(X,Y))).x\n#define T(X,Y) texture(iChannel3, scale*(fragCoord+vec2(X,Y))).xyz\n\n\n// Nonlinear isotropic diffusion\n/*\n\tdu/dt = div(g*grad(u)) = d[g*du/dx]/dx + d[g*du/dy]/dy ~\n\t~ [g*du/dx]_{i-1/2,j}^{i+1/2,j} + [g*du/dy]_{i,j-1/2}^{i,j+1/2} ~\n\t~ 1/h1*(g_{i+1/2,j} * du/dx_{i+1/2,j} - g_{i-1/2,j} * du/dx_{i-1/2,j}) + \n\t  1/h2*(g_{i,j+1/2} * du/dy_{i,j+1/2} - g_{i,j-1/2} * du/dy_{i,j-1/2}) ~\n\t~ 1/h1*[ (g_{i+1,j}+g_{i,j})/2 * (u_{i+1,j}-u_{i,j})/h1 -\n\t  (g_{i,j}+g_{i-1,j})/2 * (u_{i,j}-u_{i-1,j})/h1 ] +\n\t  1/h2*[ (g_{i,j+1}+g_{i,j})/2 * (u_{i,j+1}-u_{i,j})/h2 -\n\t  (g_{i,j}+g_{i,j-1})/2 * (u_{i,j}-u_{i,j-1})/h2 ]\n\n\t// Explicit scheme:\n\th1 = 1, h2 = 1, gxp = tau*(g_{i+1,j}+g_{i,j})/2, gxn = tau*(g_{i,j}+g_{i-1,j})/2\n\tgyp = tau*(g_{i,j+1}+g_{i,j})/2, gyn = tau*(g_{i,j}+g_{i,j-1})/2\n\tu'_{i,j} =  gxp * u_{i+1,j} + gxn * u_{i-1,j} + gyp * u_{i,j+1} + gyn * u_{i,j-1}  +\n\t\t\t   + (1-(gxp+gxn+gyp+gyn))*u_{i,j}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scale = 1.0 / iResolution.xy;\n    vec4 info = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    bool textureLoaded = iChannelResolution[1].x>0.0;\n    vec3 col;\n    if(textureLoaded && texture(iChannel0, fragCoord).w<1.0)\n    {\n        col = texture(iChannel1, uv).xyz;\n    }\n    else\n    {\n        if(iMouse.z>0.0)\n        {\n        float tau = 0.2;\n        float gc = G(0,0);\n        float gxp = 0.5 * tau * (G(1,0)+gc);\n        float gxn = 0.5 * tau * (gc+G(-1,0));\n        float gyp = 0.5 * tau * (G(0,1)+gc);\n        float gyn = 0.5 * tau * (gc+G(0,-1));\n        col = gxp * T(1.0,0.0) + gxn * T(-1.0,0.0) + gyp * T(0.0,1.0) + gyn * T(0.0,-1.0) + \n            (1.0-(gxp+gxn+gyp+gyn)) * T(0,0);\n        }\n        else\n        {\n            col = info.xyz;\n        }\n    }\n    \n    \n    fragColor = vec4(col,float(textureLoaded));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// input\n\nfloat keyDown(int ascii) {\n\treturn float(texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\n\nbool keyHit(int ascii) {\n\treturn texture(iChannel2,vec2((.5+float(ascii))/256.,1.5/3.)).x == 1.0;\n}\n\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 info = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    float lambdaSensitivity = 0.001;\n    float lambda = max(0.005, info.x + lambdaSensitivity*(keyDown(KEY_W) - keyDown(KEY_S)));\n    int temp = (int(info.y) + int(keyHit(KEY_D))-int(keyHit(KEY_A)));\n    int mode = temp<0 ? 5+temp : temp>4 ? temp-5 : temp;\n    fragColor = vec4(lambda,float(mode),1.0,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// performs gaussian blurring on the image in order to regularize the gradient (Catte)\n// takes the result of bufferB as input\n\n#define T(X,Y) texture(iChannel0, scale*(fragCoord+vec2(X,Y))).xyz\n\n// std dev = 1.0\nfloat gaussian[25] = float[25](\n0.003765,\t0.015019,\t0.023792,\t0.015019,\t0.003765,\n0.015019,\t0.059912,\t0.094907,\t0.059912,\t0.015019,\n0.023792,\t0.094907,\t0.150342,\t0.094907,\t0.023792,\n0.015019,\t0.059912,\t0.094907,\t0.059912,\t0.015019,\n0.003765,\t0.015019,\t0.023792,\t0.015019,\t0.003765\n    );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scale = 1.0 / iResolution.xy;\n    vec3 acc = vec3(0.0);\n    for(int y=0;y<5;++y)\n    {\n        for(int x=0;x<5;++x)\n        {\n            int index = x + y*5;\n\t\t\tacc += T(x-2,y-2) * gaussian[index];\n        }\n    }\n    fragColor = vec4(acc,texture(iChannel0, fragCoord).w);\n}","name":"Buffer D","description":"","type":"buffer"}]}