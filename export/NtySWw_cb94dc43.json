{"ver":"0.1","info":{"id":"NtySWw","date":"1640748922","viewed":254,"name":"Voxel grid hierarchy","username":"Permille","description":"This is a modified octree tracer that has 8x8x8 voxels in each tree node. In this example, the voxel scales go from 8^1 to 8^-2.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["voxel","octree","gridhierarchy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Voxel grid hierarchy implementation\n//Based on abje's octree tracer: https://www.shadertoy.com/view/4sVfWw\nconst float MAX_DISTANCE = 250.;\nconst int MAX_DETAIL = 1;\nconst int MIN_DETAIL = -2;\n\nconst float SCALE = 8.; //Only works for powers of 2, see line 54\nconst int POWER = int(log2(SCALE));\n\nfloat Random(vec4 v){\n    return fract(1223.34 * tan(dot(v,vec4(181.11, 132.52, 171.29, 188.42)))); \n}\n\nint GetVoxel(vec3 Position, float Size){\n    if(length(Position.xy) == 0.) return 0; //Keeps the tunnel in the middle clear\n    float Value = Random(vec4(Position, Size));\n    if(Value < .6) return 0;\n    if(Value < .9) return 1;\n    else return 2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n    vec3 RayOrigin = vec3(7.98, 8., iTime);\n    vec3 RayDirection = normalize(vec3(uv, .8));\n    vec3 RayDirectionSign = sign(RayDirection);\n    \n    vec3 Mask = vec3(0.);\n    bool ExitLevel = false;\n    int Level = MIN_DETAIL;\n    float Size = -float(MIN_DETAIL) * SCALE;\n    float Distance = 0.;\n    bool HitVoxel = false;\n    \n    vec3 RayPosFloor = floor(RayOrigin / Size) * Size; //Voxel coordinate\n    vec3 RayPosFract = RayOrigin - RayPosFloor; //Sub-voxel coordinate                                     \n    vec3 LastRayPosFloor = RayPosFloor;\n    vec3 Correction = 1./max(abs(RayDirection), 1e-4);\n    \n    for(int i = 0; i < 200 && Distance < MAX_DISTANCE && !HitVoxel; ++i){\n        while(ExitLevel){\n            Level--;\n            Size *= SCALE;\n            vec3 NewRayPosFloor = floor(RayPosFloor/Size) * Size;\n            RayPosFract += RayPosFloor - NewRayPosFloor;\n            RayPosFloor = NewRayPosFloor;\n            ExitLevel = Level > MIN_DETAIL && floor(RayPosFloor/Size/SCALE) != floor(LastRayPosFloor/Size/SCALE); //This is for when we go up by multiple levels at once (e.g. 2->0)\n        }\n        \n        switch(GetVoxel(RayPosFloor, Size)){ //Get random voxel at proper scale (Size)\n            case 1:{ //Subdivide\n                if(Level < MAX_DETAIL){\n                    Level++;\n                    for(int j = 0; j < POWER; ++j){ //Not sure how to unroll this loop without weird artefacts...\n                        Size /= 2.;\n                        vec3 Step = step(vec3(Size), RayPosFract) * Size;\n                        RayPosFloor += Step;\n                        RayPosFract -= Step;\n                    }\n                    break; //Only break switch if the level was less than the max detail. Otherwise, pretend as if the same level is kept.\n                }\n            }\n            case 0:{ //Empty\n                float HalfSize = Size / 2.;\n                vec3 Hit = -Correction * (RayDirectionSign * (RayPosFract - HalfSize) - HalfSize); //Trace ray to next voxel\n                Mask = vec3(lessThanEqual(Hit.xyz, min(Hit.yzx, Hit.zxy))); //Determine which side was hit\n                float NearestVoxelDistance = dot(Hit, Mask);\n                Distance += NearestVoxelDistance;\n                vec3 Step = Mask * RayDirectionSign * Size;\n                \n                RayPosFract += RayDirection * NearestVoxelDistance - Step;\n                \n                LastRayPosFloor = RayPosFloor;\n                RayPosFloor += Step;\n                \n                ExitLevel = Level > MIN_DETAIL && floor(RayPosFloor/Size/SCALE) != floor(LastRayPosFloor/Size/SCALE); //Check if the edge of the level has been reached\n                break;\n            }\n            case 2: HitVoxel = true;\n        }\n    }\n    \n    float fLevel = float(Level) + 5.;\n    vec3 Colour = normalize(vec3(sin(fLevel) * .5 + .5, cos(fLevel * 1.7) * .5 + .5, sin(fLevel + 1.) * .5 + .5));\n    fragColor = vec4(Colour * length(Mask * vec3(.9, 1., .8)), 1.);\n}","name":"Image","description":"","type":"image"}]}