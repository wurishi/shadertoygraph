{"ver":"0.1","info":{"id":"Xd3Bz7","date":"1524491243","viewed":104,"name":"Bouncing Blob","username":"nr4","description":"Visuals for the invitation intro to the Z10 Shader Coding Regular's Table by Team210.\nCODE/SFX :: QM\nCODE/GFX :: NR4","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","sdf","analytic","visuals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Bouncing Blob\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nvec2 c = vec2(1.,0.);\nfloat pi = acos(-1.);\n\nfloat iScale;\n\nfloat circle(vec2 x, float r)\n{\n    return length(x)-r;\n}\n\nvec2 cnormal(vec2 x, float r)\n{\n    return c.xx*(1.-length(x)/r);\n}\n\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat smoothstep_noise(float x)\n{\n    float r1 = -1.+2.*rand(floor(x)*c.xx), r2 = -1.+2.*rand(ceil(x)*c.xx);\n    return mix(r1, r2, smoothstep(.25, .75, fract(x)));\n}\n\nfloat mfsmoothstep_noise(float x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*smoothstep_noise(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nfloat smoothstep_noise2d(vec2 x)\n{\n    vec2 d = floor(x);\n    x = fract(x);\n    float x00 = -1.+2.*rand(d),\n        x01 = -1.+2.*rand(d+c.yx),\n        x10 = -1.+2.*rand(d+c.xy), \n        x11 = -1.+2.*rand(d+c.xx);\n    return mix(mix(x00, x01, x.y), mix(x10, x11, x.y), x.x);\n}\n\nfloat mfsmoothstep_noise2d(vec2 x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*smoothstep_noise2d(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nfloat branch(vec2 x, vec3 whbhs, float s)\n{\n    x += .03*c.xy*mfsmoothstep_noise(x.y+s, 1.e1, 1.e2, .2);\n    vec2 b = vec2(mix(whbhs.y, whbhs.z, clamp(x.y/whbhs.x, -1., 1.)), whbhs.x);\n    return length(max(abs(x)-b,0.));\n}\n\n\nvec2 bnormal(vec2 x, vec3 whbhs, float s)\n{\n    x += .03*c.xy*mfsmoothstep_noise(x.y+s, 1.e1, 1.e2, .2);\n    return c.xx*(1.-abs(2.*x.x)/mix(whbhs.y, whbhs.z,clamp(-x.y/whbhs.x, -1., 1.)));\n}\n\nvec2 rot(vec2 x, float p)\n{\n    vec2 d = vec2(cos(p), sin(p));\n    return mat2(d.x, d.y, -d.y, d.x)*x;\n}\n\nvec4 branch(vec2 x, vec2 f, vec2 t, float w1, float w2)\n{\n    return c.xxxx;\n}\n\nfloat func(vec2 x, float f)\n{\n    return x.y-f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy-.5-.4*c.xy;\n\n    iScale = 4.*mod(iTime, .2);\n    \n    //uv *= 1.+.03*iScale;\n    \n    float px = 100.;\n    uv = round(px*uv)/px;\n    \n    vec2 x = uv+2.e-1*iTime*c.xy, \n        y = vec2(mod(x.x, .4)-.2, x.y), \n        index = x-y;\n    \n    vec4 sdf = c.xyyy;\n    \n    //trees\n    //(a) leaves\n    vec2 z = y;\n    y += .35*c.yx - .1*mfsmoothstep_noise(x.x-y.x, 8.e0, 20., .6)*c.yx;\n    for(int i=0; i<22; ++i)\n    {\n        float leafsize = .05+.03*rand(float(i)*index);\n        vec2 leaf_offset = vec2(-.1+.2*rand(index+float(i)*21.), -.1+.3*rand(index+float(i)*22.));\n        vec2 n = cnormal(y-.2*c.yx-leaf_offset, leafsize);\n        vec4 sda = vec4(circle(y-.2*c.yx-leaf_offset, leafsize), max(n.x, n.y)*(c.yxy-2.*c.yyx*rand(float(i+10)*c.xx)+1.*c.xyy*rand(float(i+20)*c.xx))+.1*c.yxy*rand(float(i)*c.xx));\n        sdf = mix(sdf, sda, step(sda.x, sdf.x));\n    }\n    //(b) stem\n    vec3 stemc1 = vec3(31., 12., 2.)/255., stemc2 = vec3(145., 57., 9.)/255.;\n    vec2 n = bnormal(y, vec3(.5, .3, .4), index.x);\n    vec4 sda = vec4(branch(y, vec3(.3, .05, .02), index.x), stemc1+stemc2*max(n.x, n.y)-.2*c.xyy);\n    sdf = mix(sdf, sda, step(sda.x, sdf.x));\n    \n    //night sky\n    vec3 bgcol = mix(vec3(0., 96., 255.)/255., vec3(0., 25., 66.)/255., 1.-.5*uv.y);\n    //(a) clouds\n    bgcol = mix(bgcol, c.xxx, smoothstep(-.2,.2,uv.y)*clamp(1.7*mfsmoothstep_noise2d(uv-2.2e-2*iTime*c.xy, 5., 100., .45+.01*sin(1.3e1*iTime-2.)), 0., 1.));\n\tbgcol = mix(bgcol, c.xxx, smoothstep(-.2,.2,uv.y)*clamp(1.7*mfsmoothstep_noise2d(uv-.2-2.1e-2*iTime*c.yx, 7., 100., .45+.01*sin(1.5e1*iTime-3.)), 0., 1.));\n    bgcol = mix(bgcol, c.xxx, smoothstep(-.2,.2,uv.y)*clamp(1.*mfsmoothstep_noise2d(uv-.2-2.3e-2*iTime*c.xx, 6., 100., .45+.01*sin(1.7e1*iTime-4.)), 0., 1.));\n    //(b) mountains\n    for(int i=-2; i<2; ++i)\n    {\n        n = vec2(mfsmoothstep_noise2d((x.x-10.*float(i)+2.e-2*float(i)*iTime)*c.xy+1.2*x.y*c.yx+.2*float(i)*x.yx, 1., 190., .7),\n                 mfsmoothstep_noise2d((x.x-10.*float(i))*c.xy+1.2*x.y*c.yx+.2*float(i)*x.yx, 1., 190., .7)); \n        vec4 sdc = vec4(func(z+.1*float(i)*c.yx, -.3+.3*mfsmoothstep_noise(x.x-10.*float(i)+1.e-2*float(i)*iTime, 1., 19., .6)), mix(stemc1+.1,  .5*stemc2-.3, -.3+(2.*length(n))*c.xxx));\n    \tbgcol = mix(bgcol, sdc.gba, step(sdc.x, 0.));\n    }\n    fragColor = vec4(mix(bgcol, sdf.gba, step(sdf.x, 0.)),1.);\n    \n    //bouncing blob\n    vec2 xi = uv+.5*c.yx-.2*abs(sin(2.*pi*iScale/2.))*c.yx;\n    n = cnormal(xi, .1);\n    vec4 sdd = vec4(circle(xi, .1),  max(n.x, n.y)*c.xxy+.5*c.xyy);\n    fragColor = vec4(mix(fragColor.xyz,sdd.gba, step(sdd.x, 0.)),1.);\n    sdd = vec4(circle(xi-.025*c.xx, .02), c.xxx);\n    fragColor = vec4(mix(fragColor.xyz,sdd.gba, step(sdd.x, 0.)),1.);\n    sdd = vec4(circle(xi-.025*c.xx, .01), c.yyy);\n    fragColor = vec4(mix(fragColor.xyz,sdd.gba, step(sdd.x, 0.)),1.);\n    vec4 sdb = c.xyyy;\n    xi += .01*c.xy;\n    xi += .01*c.yx;\n    sdf = mix(sdd, sdb, step(sdb.x, sdd.x));\n    sdd = vec4(circle(xi-.02*c.xy+.02*c.yx,  .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.03*c.xy+.03*c.yx,  .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.035*c.xy+.035*c.yx,.01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.04*c.xy+.04*c.yx,  .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.045*c.xy+.04*c.yx, .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.055*c.xy+.04*c.yx, .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.06*c.xy+.045*c.yx, .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.065*c.xy+.05*c.yx, .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    fragColor = vec4(mix(fragColor.xyz,sdf.gba, step(sdf.x, 0.)),1.);\n    \n    //[add text here]\n}","name":"Image","description":"","type":"image"}]}