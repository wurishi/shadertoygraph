{"ver":"0.1","info":{"id":"XtcBRs","date":"1540609435","viewed":149,"name":"Environment Shader- Hallway","username":"tiff","description":"The monotone of the hallway is intentional to give it a dark and mysterious vibe, where the red highlights the path of the hallway, and the yellow signifies the light guiding down the hallway.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fancycorridor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n//=======================\n// Utility Functions\n//=======================\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n    \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n// ============================\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n//=======================\nShape Hallway(vec3 c){\n  Shape shape;\n  vec4 color = vec4(1., 1., 1., 1.);\n  \n  c.z = repeat(c.z, 2.);\n  c.x = abs(c.x)-0.5; //Mirror\n    \n  vec3 boxOffset = vec3(1., -1.2, 0.);\n  float b1 = fBox(c+ boxOffset, vec3(5., .3, 1.)); //c- vec3(x, y, z) how much to move the object\n  float b2 = fBox(c- boxOffset, vec3(5., .3, 1.)); //c- vec3(x, y, z) how much to move the object\n    \n  float floormat = fBox((c- boxOffset), vec3(1., .5, 1.));\n  vec4 floormatC = vec4(1., .2, .2, 1.);\n\n  float wall = fBox(c- vec3(1., -.3, 0.), vec3(.05, .5, .05));\n  float door = fBox(c- vec3(abs(sin(iTime))/1.5 +.5 , .5, .75), vec3(.3, 1.25, .03));\n  vec4 doorC = vec4(0., 0., 0., .5); \n    \n  float ball = sphere(c- vec3(1., .29, 0.), .1);\n  vec4 ballC = vec4(1., 1., .1, 1.);\n    \n  shape.dist = fOpUnionStairs(wall, b1, .3, 3.);  \n  shape.dist = fOpUnionStairs(shape.dist, b2, .3, 3.);\n  shape.dist = min(shape.dist, door);\n  shape.dist = min(shape.dist, ball);\n  shape.dist = fOpUnionStairs(shape.dist, floormat, .3, 2.);\n  // shape.dist = fOpUnionStairs(shape.dist, col2, .3, 3.); \n \n  shape.color = mix(color, floormatC, mixColors(b2, floormat, 0.));\n  shape.color = mix(shape.color, doorC, mixColors(door, shape.dist,.2));\n  shape.color = mix(shape.color, ballC, mixColors(ball, shape.dist, 0.05));\n    \n  return shape;\n}\n\nShape map(vec3 c){\n  Shape hall = Hallway(c);\n  return hall;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}