{"ver":"0.1","info":{"id":"XldBWj","date":"1541450738","viewed":119,"name":"Martin-RayMarching","username":"Martinsmihov","description":"Ray marching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat SDFUnion(float a, float b)\n{\n    return min(a,b);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n\tvec3 camUp = normalize(cross(camForward, camRight));\n\t\t\t\t\t\t\t  \n    float fPersp = 2.0;\n\tvec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n\n\treturn vDir;\n}\n\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdfBox (vec3 p, vec3 c, vec3 s)\n{\n    float x = max\n    (\n        p.x - c.x - (s.x / 2.0),\n        c.x - p.x - (s.x / 2.0)\n    );\n\n    float y = max\n    (   p.y - c.y - (s.y / 2.0),\n        c.y - p.y - (s.y / 2.0)\n    );\n    \n    float z = max\n    (   p.z - c.z - (s.z / 2.0),\n        c.z - p.z - (s.z / 2.0)\n    );\n\n    float d = x;\n    d = max(d,y);\n    d = max(d,z);\n    return d;\n}\n\nfloat SDF(vec3 pos)\n{\n    float box = sdfBox(pos, vec3(0,-25,-25), vec3(70,20,20));\n    float box2 = sdfBox(pos, vec3(-25,-30,-10), vec3(20,10,10));\n    float box3 = sdfBox(pos, vec3(-30,-30,0), vec3(10,10,10));\n    float box4 = sdfBox(pos, vec3(-30,-20,-10), vec3(10,10,10));\n    float centerSphere = sdSphere(pos-vec3(-25,-5,-25), 10.0);\n    float centerSphere2 = sdSphere(pos-vec3(-5,-7,-25), 8.0);\n    float centerSphere3 = sdSphere(pos-vec3(9,-9,-25), 6.0);\n    float groundPlane = sdPlane(pos, vec4(0,1,0,35));\n    float groundPlane2 = sdPlane(pos, vec4(0,-1,0,35));\n    float groundPlane3 = sdPlane(pos, vec4(-1,0,0,35));\n    float groundPlane4 = sdPlane(pos, vec4(1,0,0,35));\n    float groundPlane5 = sdPlane(pos, vec4(0,0,1,35));\n    float groundPlane6 = sdPlane(pos, vec4(0,0,-1,35));\n    float t = SDFUnion(box,centerSphere);\n    t = SDFUnion(t, box2);\n    t = SDFUnion(t, centerSphere2);\n    t = SDFUnion(t, centerSphere3);\n    t = SDFUnion(t, groundPlane);\n    t = SDFUnion(t, groundPlane2);\n    t = SDFUnion(t, box3);\n    t = SDFUnion(t, groundPlane4);\n    t = SDFUnion(t, groundPlane5);\n    t = SDFUnion(t, box4);\n    \n    return t;\n}\n\n\nfloat castRay(vec3 from, vec3 direction)\n{\n    float currentDistance = 0.0;\n    float t = 0.0; // Stores current distance along ray\n    \n    for(int i = 0; i < 512; ++i)\n    {\n        float closestPoint = SDF(from + direction * currentDistance);\n        \n        if(closestPoint < currentDistance * 0.0001)\n        {\n            return currentDistance;\n        }\n        \n        currentDistance += closestPoint;\n    }\n    \n    return -1.0;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\t// Center sample\n    float c = SDF(pos);\n\t// Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3(\n        SDF(pos + eps_zero.xyy),\n        SDF(pos + eps_zero.yxy),\n        SDF(pos + eps_zero.yyx)) - c);\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir, vec2 fragCoord)\n{\n    vec3 col;\n    float t = castRay(rayOrigin, rayDir);\n    \n    vec2 mouseCoord = (-iResolution.xy + 2.0 * iMouse.xy)/ iResolution.y;\n    \n    vec3 L = normalize(vec3(0.5, 0.5, 1));\n    //vec3 L = normalize(vec3(1, 1, -0.5));\n \n    float DisplaySpeed = 50.0;\n    float DisplayDistance = mod(iTime * DisplaySpeed, 150.0);\n    float DisplayWidth = 70.0;\n    \n    if (t == -1.0)\n    {\n        // Skybox colour\n        col = vec3(0.30, 0.36, 0.60) - (rayDir.y * 0.7);\n    }\n    else //if (t > DisplayDistance && t < DisplayDistance + DisplayWidth)\n    {\n        vec3 pos = rayOrigin + rayDir * t;\n        vec3 N = calcNormal(pos);\n\n        vec3 objectSurfaceColour = vec3(0.4, 0.8, 0.1);\n        // L is vector from surface point to light, N is surface normal. N and L must be normalized!\n        float NoL = max(dot(N, L), 0.0);\n        vec3 LDirectional = vec3(1.80,1.27,0.99) * NoL;\n        vec3 LAmbient = vec3(0.03, 0.04, 0.1);\n        vec3 diffuse = objectSurfaceColour * (LDirectional + LAmbient);\n\t\t\n        float scale = 0.0;\n        float distanceScale = ((DisplayDistance) - t) / DisplayWidth;\n        if(distanceScale >= 0.0 && distanceScale <= 1.0)\n        {\n            scale = pow(1.0 - distanceScale, 4.0);\n        }\n        \n        if(mod(fragCoord.x, 6.0) < 4.0 || mod(fragCoord.y, 6.0) < 4.0)\n        {\n            scale = 0.0;\n        }\n        \n        col = diffuse * scale;\n    }\n     \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouseCoord = (-iResolution.xy + 2.0 * iMouse.xy)/ iResolution.y;\n    \n    //vec3 camPos = vec3(20.0 * cos(iTime), 2.0 * sin(iTime / 3.0), 20.0 * sin(iTime));\n    vec3 camPos = vec3(45.0, 5.0, 0.0);\n    vec3 at = vec3(0, -5, -15);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord)/ iResolution.y;\n\n    vec3 rayDir = getCameraRayDir(uv, camPos, at);\n    \n    vec3 col = vec3(render(camPos, rayDir, fragCoord));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}