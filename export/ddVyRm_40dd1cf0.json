{"ver":"0.1","info":{"id":"ddVyRm","date":"1696426170","viewed":54,"name":"sqrt attenuation","username":"azavier","description":"someone criticize my code","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"cddyWf","parentname":"template - azavier"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void rectify(inout vec2 ci, in float nd, in float nm) {\n ci = mix(ci, vec2(nd, nm), step(nd, ci.x)); \n}\nvec2 scene_info(in vec3 p) {\n vec2 ci = vec2(FAR, -1.0);\n \n vec3 sp = p + vec3(0.08 + 0.16*sin(9.6*p.y + 3.1*iTime)\n                   ,0.03 + 0.07*cos(12.0*p.x*p.y*p.z + 8.412*iTime)\n                   ,0.20 + 0.15*sin(6.0*p.x + 6.31*iTime));\n float sd = length(sp) - 1.0;\n rectify(ci, sd*0.33, 1.0);\n \n return ci;\n}\n\n// i stole this from IQ without reading up on it, is it faster?\nvec3 surface_normal(in vec3 p) { // klems's trick to prevent the compiler from inlining map() 4 times\n vec3 n = vec3(0.0);\n for(int i = min(iFrame, 0); i < 4; i++) {\n  vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n  n += e*scene_info(p+HIT*e).x;\n }\n return normalize(n);\n}\n\nvec2 march_scene(in vec3 ro, in vec3 rd) { // fancy innit\n vec2 mi = vec2(0.0);\n for(vec3 msi = vec3(scene_info(ro), 0.0); step(FAR, mi.x)+step(msi.x, HIT)+step(TRACESTEPS, msi.z++) == 0.0; msi.xy = scene_info(ro + rd*mi.x))\n  mi = vec2(mi.x + msi.x, msi.y);\n return mi;\n}\n\nvec3 parse_material(in float m, in vec3[2] data) {\n switch(int(m)) {\n  case 0:\n   return vec3(0.5);\n  case 1:\n   return vec3(0.8, 0.4, 0.6)*(0.6+0.4*data[1]);\n }\n}\n\nvoid lighting(inout vec3 col, in vec3 hitp, in vec3 hitn) {\n // lighting calculations\n vec4 pointL = 2.0*vec4(1.0, 0.9, 0.6, 6.0);\n vec3 to = pointL.xyz - hitp;\n col *= smoothstep(-1.0, 1.0, dot(normalize(to), hitn)); // diffuse\n col *= sqrt(pointL.w/length(to)); // squirt attenuation\n col = sqrt(col); // gamma correction\n}\n\nvec3 PixelColor(in vec2 uv) {\n vec3 ro = vec3(0.0, 1.0, 3.0);\n ro.xz *= rot(iTime*0.72256);\n vec3 focus = vec3(0.0, 0.0, 0.0);\n vec3 rd = lookTo(uv, ro, focus);\n\n vec2 traceout = march_scene(ro, rd);\n vec3 hitp = ro+rd*traceout.x, hitn = surface_normal(hitp);\n float fcheck = step(traceout.x, FAR); // fcheck is 1.0 if we did not reach the far plane\n \n vec3 col = vec3(fcheck);\n col *= parse_material(traceout.y, vec3[](hitp, hitn));\n \n lighting(col, hitp, hitn);\n \n col += (1.0-fcheck)*vec3(0.2,0.6,0.3)*(0.65+0.35*rd.y); // far plane color\n return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n vec3 col = vec3(0.0);\n \n#if AA > 1\n const float AA_INCREMENT = 1.0/float(AA);\n  \n for(vec2 AAO = vec2(-0.5); AAO.x < 0.5; AAO.x += AA_INCREMENT)\n  for(AAO.y = -0.5; AAO.y < 0.5; AAO.y += AA_INCREMENT)\n   col += PixelColor(uv + AAO/iResolution.y);\n  \n col /= float(AA*AA);\n#else\n col += PixelColor(uv);\n#endif\n \n fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define AA 2\n\n#define HIT 0.001\n#define FAR 35.0\n#define TRACESTEPS 250.0\n\nmat2x2 rot(in float th) {\n return mat2x2(cos(th), -sin(th), sin(th), cos(th));\n}\n\nvec3 lookTo(in vec2 uv, in vec3 o, in vec3 f) {\n vec3 fwd = normalize(f-o);\n vec3 rgt = normalize(cross(fwd, vec3(0.0,1.0,0.0)));\n vec3 up = cross(rgt, fwd);\n \n return normalize(1.0*(uv.x*rgt + uv.y*up) + fwd);\n}","name":"Common","description":"","type":"common"}]}