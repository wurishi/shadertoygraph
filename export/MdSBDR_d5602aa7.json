{"ver":"0.1","info":{"id":"MdSBDR","date":"1500015407","viewed":857,"name":"Mandelbulb estimation tweak","username":"mmerchante","description":"A small tweak to iq's mandelbulb distance estimator, to consider Julia offsets. Right side is better, use the mouse to see the differences.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["julia","sdf","mandelbulb","fractals","estimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A small tweak to iq's mandelbulb distance estimator\n// that considers Julia offsets. Right side is better.\n\n// The main problem arises when the floating bulbs appear, \n// as there's an invisible sphere of overstepping that prevents rendering the outer bulbs.\n\n// The tweak is not perfect, and you can force more detail by increasing DERIVATIVE_BIAS to > 1.0\n// Beware that iteration count will increase.\n\n// In the left side, you should see different banding patterns, and some far bulbs disappearing.\n// In the right side, the banding disappears and bulbs are better estimated.\n\n// Note that this is not just biasing the result, because this \"sphere of death\" is also fractal-like,\n// and by modifying the derivative it properly adapts to the solution.\n\n// Color is iteration count; red is more.\n\n// I'll add more later, as I currently lack the time and coffee to rationalize this result.\n\n// More info on http://www.fractalforums.com/new-theories-and-research/error-estimation-of-distance-estimators/\n\n#define MAX_ITERATIONS 200\n#define EPSILON .0001\n#define DERIVATIVE_BIAS 1.0\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat evaluateMandelbulb(in vec3 p, in bool conservative)\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    float dz = 1.0;\n    vec3 J = vec3(.2);    \n       \n\tfor( int i=0; i < 5; i++ )\n    {\n        if(conservative)\n        \tdz = max(dz * DERIVATIVE_BIAS, 8.0*pow(m ,3.5)*dz + 1.0);\n        else\n        \tdz = 8.0*pow(m ,3.5)*dz + 1.0;\n\t\t\n        float r = length(w);\n        float b = 8.0*acos( clamp(w.y/r, -1.0, 1.0));\n        float a = 8.0*atan( w.x, w.z );\n        w = p + J + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n        \n        m = dot(w,w);\n\t\t\n        if( m > 4.0 )\n            break;\n    }\n       \n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nfloat trace(vec3 rayO, vec3 rayD, bool conservative)\n{    \n    float t = 0.0;\n    float steps = 0.0;\n    float it = 1.0 / float(MAX_ITERATIONS);\n    \n\tfor(int j = 0; j < MAX_ITERATIONS; j++)\n\t{\n        vec3 p = rayO + rayD * t;\n\t\tfloat d = evaluateMandelbulb(p, conservative);\n\n\t\tif(d < EPSILON)\n            break;\n\n\t\tt += d;\n        \n\t\tif(t >= .5)\n\t\t\tbreak;\n        \n        steps += it;\n\t}\n    \n    return steps;    \n}\n\n// Reference: https://iquilezles.org/articles/palettes\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return saturate(a + b * cos(6.28318 * ( c * t + d)));\n}\n\nvec3 debugIterations(float factor)\n{\n\tvec3 a = vec3(0.478, 0.500, 0.500);\n\tvec3 b = vec3(0.500);\n\tvec3 c = vec3(0.688, 0.748, 0.748);\n\tvec3 d = vec3(0.318, 0.588, 0.908);\n\n\treturn palette(factor, a, b, c, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    \n    float time = iTime * .2;    \n    vec3 target =  vec3(.9, 0.22, -0.10);\n    vec3 p = target + vec3(cos(time), 0.0, sin(time)) * .15;\n    \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n    \n    vec3 rayOrigin = p;\n    vec3 rayDirection = normalize(forward + left * uv.x - up * uv.y);\n    \n    bool conservative = false;    \n    float threshold = (-iResolution.x + 2.0*iMouse.x) / iResolution.y;\n    \n    if(iMouse.z < 0.01)\n        threshold = 0.5/ iResolution.y;\n    \n    if(uv.x > threshold)\n        conservative = true;\n\n    float steps = trace(rayOrigin, rayDirection, conservative);\n    \n    vec3 color = debugIterations(steps);\n    color = mix(vec3(0.0), color, smoothstep(0.002, .005, abs(uv.x - threshold)));\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}