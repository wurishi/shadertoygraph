{"ver":"0.1","info":{"id":"Wd3czM","date":"1600605488","viewed":173,"name":"indications","username":"sukupaper","description":"I don't even remember why I've done this weird thing ahah","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarch","patterns","abstract","sign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: paperu\n// Title: indications\n\nfloat t;\nfloat aa;\n#define P 6.283185307\n\nfloat cl(in float x, in float y) { return clamp(x,y - 1.,y) - (y - 1.); }\n\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat opEx(in vec3 p, in float sdf, in float h) { vec2 w = vec2( sdf, abs(p.z) - h ); return min(max(w.x,w.y),0.) + length(max(w,0.)); }\n\nfloat sq2d(in vec2 p, in vec2 s) { p = abs(p) - s; return max(p.x,p.y); }\nfloat line2d(in vec2 p, in float a) { return dot(p,normalize(vec2(1./tan(P*a),1.))); }\nfloat arr2d(in vec2 p) {\n    float arr = max(-p.x + .175,dot(vec2(p.x - .5,abs(p.y)),normalize(vec2(1.,1.25))));\n    return min(arr,max(sq2d(p,vec2(.5,.15)),-max(-p.x + .25,-arr)));\n}\nfloat arrL2d(in vec2 p) {\n    p = vec2(-p.x,p.y + .25);\n    float arr = max(-p.x + .175,dot(vec2(p.x - .5,abs(p.y)),normalize(vec2(1.,1.15))));\n    return min(min(arr,max(sq2d(p,vec2(.5,.15)),-max(-p.x + .25,-arr))),sq2d(p + vec2(.35,-.45),vec2(.15,.6))); \n}\nfloat los2d(in vec2 p) { return dot(abs(p) - .2,vec2(.7071)); }\nfloat tri2d(in vec2 p) { return max(line2d(vec2(abs(p.x),p.y) - .12,2.094395102),line2d(-p-.2,.25) - .1); }\nfloat invTri2d(in vec2 p) { p.y = -p.y; return tri2d(p); }\nfloat circle2d(in vec2 p) { return length(p) - .4; }\n\nstruct distAndMat { float d; int mat; };\ndistAndMat sd2dto3d(in vec3 p, in float sdf2d) {\n    float outer = opEx(p,abs(sdf2d) - .02,.02);\n    float d = min(opEx(p,sdf2d,.01),outer);\n    distAndMat dam;\n    dam.d = d;\n    dam.mat = d == outer ? 0 : 1;\n    return dam;\n}\n\nfloat anim1(in float x, in float s, in float s2) {\n  x = abs(mod(x - s2,s2*2.) - s2);\n  x -= .5 - s;\n  return smoothstep(-s,s,fract(x) - s) + floor(x);\n}\nfloat anim2(in float x, in float sm){\n  float xmd = mod(x,2.) - .5;\n  return smoothstep(-sm,sm,xmd) - smoothstep(-sm,sm,xmd - 1.);\n}\n\n#define NB_SIGN 8\nvec3 signP[NB_SIGN];\ndistAndMat signDAM[NB_SIGN];\nint signSel, matArrPart;\nvec3 signMap;\nvoid posType1(in vec3 p, inout vec3 signPP[NB_SIGN]) {\n    p.xz *= rot(t);\n    p.xy *= rot(t);\n    const float a = P/float(NB_SIGN);\n    for(int i = 0; i < NB_SIGN; i++) {\n        float angle = float(i)*a + t*.5;\n        signPP[i] = p - vec3(cos(angle),sin(angle),0.);\n        p.xz *= rot(P*.125);\n        p.xy *= rot(P*.125);\n    }\n}\nvoid posType2(in vec3 p, inout vec3 signPP[NB_SIGN]) {\n    const float a = P/float(NB_SIGN);\n    for(int i = 0; i < NB_SIGN; i++) {\n        float angle = float(i)*a + t*.5;\n        signPP[i] = p - vec3(cos(angle),sin(angle),0.)*1.75;\n    }\n}\nvoid posType3(in vec3 p, inout vec3 signPP[NB_SIGN]) {\n    for(int i = 0; i < NB_SIGN; i++) {\n        float fi = float(i)*.5 - 2.;\n        signPP[i] = p - vec3(cos(P*fi*.2 + t*2.)*1.5,sin(P*fi*.1 + t*2.)*1.5,fi);\n    }\n}\nvoid posType4(in vec3 p, inout vec3 signPP[NB_SIGN]) {\n    p.xy += t;\n    p.x = mod(p.x,2.) - 1. + 2.*floor(rand(floor(p.xy*.5))*float(NB_SIGN));\n    p.y = mod(p.y,2.) - 1.;\n    p.z -= .5;\n    for(int i = 0; i < NB_SIGN; i++) {\n        vec3 pp = p - vec3(float(i)*2.,0.,0.);\n        pp.xz *= rot(t);\n        pp.xy *= rot(t);\n        signPP[i] = pp;\n    }\n}\n\nfloat df(in vec3 p) {\n    p.xz *= rot(cos(t)*.2);\n    p.yz *= rot(cos(t)*.2);\n    vec3 signP1[NB_SIGN]; posType1(p,signP1);\n    vec3 signP2[NB_SIGN]; posType2(p,signP2);\n    vec3 signP3[NB_SIGN]; posType3(p,signP3);\n    vec3 signP4[NB_SIGN]; posType4(p,signP4);\n    float ctrl = anim1(t*.25,.2,3.);\n    for(int i = 0; i < NB_SIGN; i++) {\n        signP[i] = mix(\n            signP1[i],\n            mix(\n                signP2[i],\n                mix(\n                    signP3[i],\n                    signP4[i],\n                    cl(ctrl,3.)\n                ),\n                cl(ctrl,2.)\n            ),\n            cl(ctrl,1.)\n        );\n    }\n\n    signDAM[0] = sd2dto3d(signP[0],arr2d(signP[0].xy));\n    signDAM[1] = sd2dto3d(signP[1],arrL2d(signP[1].xy));\n    signDAM[2] = sd2dto3d(signP[2],los2d(signP[2].xy));\n    signDAM[3] = sd2dto3d(signP[3],invTri2d(signP[3].xy));\n    signDAM[4] = sd2dto3d(signP[4],circle2d(signP[4].xy));\n    signDAM[5] = sd2dto3d(signP[5],arrL2d(-signP[5].xy));\n    signDAM[6] = sd2dto3d(signP[6],tri2d(signP[6].xy));\n    signDAM[7] = sd2dto3d(signP[7],arr2d(-signP[7].yx));\n\n    float d = 10e9;\n    for(int i = 0; i < NB_SIGN; i++) {\n        float prevD = d;\n        d = min(d,signDAM[i].d);\n        if(d != prevD) {\n            signSel = i;\n            signMap = signP[i];\n            matArrPart = signDAM[i].mat;\n        }\n    }\n    return d;\n}\n\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,.001); return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d); }\n\n#define MAX_D 8.\n#define MIN_D 1.\n#define LIM .001\n#define MAX_IT 40\nstruct rmRes { vec3 pos; int it; bool hit; };\nrmRes rm(in vec3 c, in vec3 r) {\n    vec3 p = c + r*MIN_D;\n    int it;\n    bool hit = false;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(p);\n        if(d < LIM) { hit = true; break; }\n        if(distance(c,p) > MAX_D) break;\n        p += d*r;\n        it = i;\n    }\n    rmRes res;\n    res.pos = p;\n    res.it = it;\n    res.hit = hit;\n    return res;\n}\n\nfloat strip(in vec2 p, in float th) { return fract(dot(p,vec2(.7071))*th) - .5; }\nfloat zigzag(in vec2 p, in vec2 arg) { p *= arg.x; return fract(dot(vec2(abs(fract(p.x) - .5),p.y),vec2(.7071))*arg.y) - .5; }\nfloat carreauxA(in vec2 p, in float s) { p *= s; return cos(p.x) + cos(p.y); }\nfloat carreauxB(in vec2 p, in float s) { p *= s; return cos(p.x)*cos(p.y); }\nfloat waves(in vec2 p, in vec2 arg) { p *= arg.x; return fract((p.y + cos(p.x))*arg.y) - .5; }\nfloat movingPois(in vec2 p, in vec3 arg) { float d = p.x*arg.x; p *= arg.y; return d + cos(p.y) + cos(p.x + arg.z); }\nfloat spiral(in vec2 p, in vec4 arg) { return fract((atan(p.x,p.y)/P*arg.x) + length(p*arg.y) - arg.z*arg.w) - .5; }\nfloat spiral2(in vec2 p, in vec4 arg, in vec2 arg2) { return fract((atan(p.x,p.y)/P*arg.x) + cos(length(p*arg.y) + arg2.y)*arg2.x - arg.z*arg.w) - .5; }\nfloat concentric(in vec2 p, in vec2 arg) { return cos(length(p)*arg.x + arg.y); }\nfloat concentricLos(in vec2 p, in vec2 arg) { p *= arg.x; return fract(abs(p.x) + abs(p.y) + arg.y) - .5;}\nfloat keur(in vec2 p, in float s) { p *= s; return mix(dot(abs(p) - .11,normalize(vec2(1.))),length(vec2(abs(p.x) - .08,p.y)) - .1,step(-.05,p.y)); }\n\nvec2 anim1(in float x, in vec3 arg) {\n  float nbSteps = arg.x, s = arg.y, tSpeed = arg.z;\n  float a2 = 1. - fract(x)/(fract(x) + tSpeed), a1;\n  float xx = mod(x - s,nbSteps);\n  x = mod(x,nbSteps) - .5;\n  a1 = x > nbSteps - .5 - s || x < s - .5 ?\n    smoothstep(0.,-s*2.,xx - nbSteps)*(nbSteps - 1.)\n    : smoothstep(-s,s,fract(x) - .5) + floor(x);\n  return vec2(a1, a2);\n}\n\nvec3 hsv2rgb(in vec3 c) { vec3 rgb = clamp(abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0); return c.z*mix(vec3(1.0),rgb,c.y); }\nvec3 drawShape(in vec2 st, in float shapeSel, in float colSel, in float bandw) {\n    float sz = .75;\n    st *= sz;\n    vec2 p = st;\n\n    float div = 50./sz;\n    p = floor(p*div)/div;\n\n    vec2 anim = anim1(t*.25 + st.x*.15,vec3(4.,.075,.1));\n    float mode = anim.x;\n    p = mix(\n        p*(1. + .05*cos(t*8. + anim.y*10.)) - (fract(t*.1) - .5)*.25,\n        mix(\n            fract(p*5. + t*.2) - .5,\n            mix(\n                p*rot(.5 - t*5. + anim.y*2.)*1.5,\n                p + vec2(cos(p.y*10. + t*2.),cos(p.x*10. + t*2.))*.1,\n                cl(mode,3.)\n            ),\n            cl(mode,2.)\n        ),\n        cl(mode,1.)\n    );\n\n    shapeSel -= 1.;\n    const int listSz = 11;\n    float dList[listSz];\n    dList[0] = strip(p,7.);\n    dList[1] = zigzag(p,vec2(7.,1.5));\n    dList[2] = carreauxA(p,60.);\n    dList[3] = carreauxB(p,40.);\n    dList[4] = waves(p,vec2(30.,.2));\n    dList[5] = movingPois(p,vec3(10.,150.,t*15.));\n    dList[6] = spiral(p,vec4(5.,10.,t*.5,-1.));\n    dList[7] = spiral2(p,vec4(6.,60.,0.,1.),vec2(.02,-t*5.));\n    dList[8] = concentric(p,vec2(50.,-t));\n    dList[9] = concentricLos(p,vec2(10.,-t));\n    dList[10] = keur(p,.55);\n    float dA = mix(dList[listSz - 1],dList[listSz - 2],cl(shapeSel,float(listSz)));\n    for(int i = listSz - 3; i >= 0; i--)\n        dA = mix(dList[i],dA,cl(shapeSel,float(i)));\n    float d = dA;\n    \n    d = length(fract(st * div) - .5) - .5*smoothstep(0.,-.001,d)*.8 - .1;\n    d = step(0.,d);\n\n    return mix(\n        mix(hsv2rgb(vec3(colSel,.85,1.)),hsv2rgb(vec3(colSel + .15,.85,1.)),d),\n        mix(vec3(0.),vec3(1.),d),\n        bandw\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    aa = 1./max(iResolution.x,iResolution.y);\n    t = iTime + st.x*.5;\n    \n    vec3 c = vec3(0.,0.,-3.5);\n    vec3 r = normalize(vec3(st,.75));\n\n    rmRes res = rm(c,r);\n    \n    float colorVer = anim2(t/8. + 1.,.05);\n\n    vec3 color = vec3(colorVer);\n\n    if(res.hit) {\n        vec3 n = normal(res.pos);\n        float ac = dot(-n,r);\n        float ssel = float(signSel) + floor(t*.2 - length(signMap.xy)*.1);\n        float nbSign = float(NB_SIGN);\n        if(matArrPart == 0) {\n            color = drawShape(\n                signMap.xy,\n                mod(ssel,11.),\n                ssel/nbSign,\n                0.\n            )*step(0.5,1. - colorVer);\n        } else if(matArrPart == 1) {\n            color = drawShape(\n                signMap.xy,\n                mod(ssel,11.),\n                ssel/nbSign*2.,\n                1.\n            );\n        }\n        color /= pow(ac*1.,2.) + pow(float(res.it)*.05,2.);\n    }\n\n    float glow = pow(float(res.it)*.02,2.);\n    color += mix(glow,-glow,colorVer);\n    float vignet = pow(length(st),2.);\n    color += mix(vignet,-vignet,colorVer);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}