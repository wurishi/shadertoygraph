{"ver":"0.1","info":{"id":"M3y3Wd","date":"1718400893","viewed":77,"name":"Jewel","username":"Kenzodabarra","description":"Sketch \nfirst version the final version was minted as generative","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n\nconst int maxIterations = 10;\nconst float minDistance = 0.001;\nconst float maxDistance = 100.0;\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n        mix(mix(fract(sin(n) * 43758.5453), fract(sin(n + 1.0) * 43758.5453), f.x),\n            mix(fract(sin(n + 157.0) * 43758.5453), fract(sin(n + 158.0) * 43758.5453), f.x), f.y),\n        mix(mix(fract(sin(n + 113.0) * 43758.5453), fract(sin(n + 114.0) * 43758.5453), f.x),\n            mix(fract(sin(n + 270.0) * 43758.5453), fract(sin(n + 271.0) * 43758.5453), f.x), f.y), f.z);\n}\n\nfloat noise1(vec3 x) {\n    return fract(sin(dot(x, vec3(12.9898, 78.233, 98.422))) * 43758.5453);\n}\n\nfloat mandelbox(vec3 z) {\n    vec3 p = z;\n    float dr = 1.0, r = 0.0, scale = 1.0, foldingLimit = 100.0;\n    for (int i = 0; i < maxIterations; i++) {\n        r = length(p);\n        if (r < foldingLimit) {\n            float r2 = dot(p, p), s = scale / (1.0 - r2);\n            if (r2 < 1.0) { p *= s; dr *= s; } else { p = p * scale / r2; dr *= scale / r2; }\n        }\n        p += z;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat mandelbulb(vec3 z) {\n    vec3 p = z;\n    float dr = 1.0, r = 0.0, power = 8.0;\n    for (int i = 0; i < maxIterations; i++) {\n        r = length(p);\n        if (r > maxDistance) break;\n        float theta = acos(p.z / r), phi = atan(p.y, p.x), zr = pow(r, power);\n        theta *= power; phi *= power;\n        p = vec3(zr * sin(theta) * cos(phi), zr * sin(theta) * sin(phi), zr * cos(theta)) + z;\n        dr = power * pow(r, power - 1.0) * dr + 1.0;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for (int i = 0; i < maxIterations; i++) {\n        vec3 p = ro + rd * d;\n        float distance = mandelbulb(p);\n        d += distance;\n        if (distance < minDistance || d > maxDistance) break;\n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float tileWidth = 0.8, tileHeight = 0.8;\n    float isoX = (uv.x - uv.y) * tileWidth * 0.5, isoY = (uv.x + uv.y) * tileHeight * 0.5;\n    vec3 cameraPos = vec3(0.0, 0.0, -3.0), rayDir = normalize(vec3(isoX, isoY, 1.4));\n    float distance = rayMarch(cameraPos, rayDir);\n    vec3 color = vec3(0.0);\n\n    if (distance < maxDistance) {\n        vec3 p = cameraPos + rayDir * distance, normal = normalize(vec3(\n            mandelbulb(p + vec3(minDistance, 0.0, 0.0)) - mandelbulb(p - vec3(minDistance, 0.0, 0.0)),\n            mandelbulb(p + vec3(0.0, minDistance, 0.0)) - mandelbulb(p - vec3(0.0, minDistance, 0.0)),\n            mandelbulb(p + vec3(0.0, 0.0, minDistance)) - mandelbulb(p - vec3(0.0, 0.0, minDistance))\n        ));\n        vec3 oro = vec3(1.0, 0.843, 0.0), argento = vec3(0.8);\n        vec3 lightDir = normalize(vec3(sin(iTime), cos(iTime), 0.5 * sin(iTime)));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        vec3 diffuseColor = oro * diffuse;\n        vec3 viewDir = normalize(cameraPos - p), reflectionDir = reflect(-lightDir, normal);\n        float specular = pow(max(dot(viewDir, reflectionDir), 0.0), 32.0);\n        vec3 specularColor = argento * specular;\n        color = diffuseColor + specularColor + texture(iChannel0, reflectionDir).rgb * 0.5;\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}