{"ver":"0.1","info":{"id":"MfVGDm","date":"1712868768","viewed":133,"name":"Star in any color","username":"TimothyAlexisVass","description":"Pretty much explains itself","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["sun","star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simplex noise function\nfloat snoise(vec3 uv, float res) {\n    // Settings\n    float coronaShape1 = 1e-4;\n    float coronaShape2 = 1e5;\n    float coronaShape3 = 2.5; // Lower values gives less corona around sphere\n\n    const vec3 s = vec3(1e5, 1e6, 1e7);\n    uv *= res;\n    vec3 uv0 = floor(mod(uv, res)) * s;\n    vec3 uv1 = floor(mod(uv + vec3(1.0), res)) * s;\n    vec3 f = fract(uv);\n    f = f * f * (3.0 - 2.0 * f);\n    vec4 v = vec4(uv0.x + uv0.y + uv0.z, uv1.x + uv0.y + uv0.z, uv0.x + uv1.y + uv0.z, uv1.x + uv1.y + uv0.z);\n    vec4 r = fract(sin(v * coronaShape1) * coronaShape2);\n    float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n    r = fract(sin((v + uv1.z - uv0.z) * coronaShape1) * coronaShape2);\n    float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n    return mix(r0, r1, f.z) * coronaShape3 - 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Settings\n    float minGlowIntensity = 0.2;\n    float overlayGlowStrength = 3.9;\n    float brightness = 0.06;\n    float size = 0.243;\n    float radius = size + brightness * 0.2;\n    float outerGlowSize = 1.01; // Overlay in relation to Sphere\n    float coronaGlow = 0.49;\n    float coronaSpread = 1.8; // Lower values give more spread\n    float rayAmount = 1.2; // Higher value means more rayiness\n    float rotationSpeed = 1.2; // values < 0 reverses direction\n    float animationSpeed = iTime * 0.05;\n \n    float sphereRed = 0.9;\n    float sphereGreen = 0.65;\n    float sphereBlue = 0.4;\n\n    float overlayRed = 0.6;\n    float overlayGreen = 0.40;\n    float overlayBlue = 0.3;\n    \n    vec3 color1 = vec3(sphereRed, sphereGreen, sphereBlue);\n    vec3 color2 = vec3(overlayRed, overlayGreen, overlayBlue);\n    \n    float aspect = iResolution.x / iResolution.y; // To make it spherical\n    float invRadius = 0.95 / radius - 7.8;\n\n    // Normalize fragment coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -0.5 + uv;\n    p.x *= aspect;\n\n    // Calculate fade based on distance\n    float fade = pow(length(coronaSpread * p), coronaGlow);\n    float fVal1 = 1.0 - fade;\n    float fVal2 = 1.0 - fade;\n\n    // Calculate angle and distance from center\n    float PI = 3.14159;\n    float angle = atan(p.x, p.y) / PI * rayAmount;\n    float dist = length(p) * outerGlowSize;\n    vec3 coord = vec3(angle, dist, animationSpeed * 0.1);\n\n    // Calculate noise values for time variations\n    float newTime1 = abs(snoise(coord + vec3(0.0, -animationSpeed * (0.85 + brightness * 0.001), animationSpeed * 0.015), 15.0));\n    float newTime2 = abs(snoise(coord + vec3(0.0, -animationSpeed * (0.15 + brightness * 0.001), animationSpeed * 0.015), 45.0));\n\n    // Combine multiple noise layers\n    for (int i = 1; i <= 7; i++) {\n        float power = pow(2.0, float(i + 1));\n        fVal1 += (0.5 / power) * snoise(coord + vec3(0.0, -animationSpeed, animationSpeed * 0.2), (power * (10.0) * (newTime1 + 1.0)));\n        fVal2 += (0.5 / power) * snoise(coord + vec3(0.0, -animationSpeed, animationSpeed * 0.2), (power * (15.0) * (newTime2 + 1.0)));\n    }\n\n    // Calculate corona effect\n    float corona = pow(fVal1 * max(1.2 - fade * 1.2, 0.0), 2.0) * 30.0;\n    corona += pow(fVal2 * max(1.1 - fade, 0.0), 2.0) * 30.0;\n    corona *= 1.2 - newTime1;\n\n    // Initialize variables for star effects\n    vec3 starSphere = vec3(0.0);\n\n    // Calculate star glow\n    vec2 sp = -1.0 + 2.0 * uv; // Position\n    sp.x *= aspect;\n    sp *= (1.98 - brightness); // Size\n    float r = dot(sp, sp);\n    float f = (1.0 - sqrt(abs(1.0 - r))) / r + brightness * overlayGlowStrength;\n\n    // Apply effects within the radius\n    if (dist < radius) {\n        corona *= pow(dist * invRadius, 24.0);\n        vec2 newUv;\n        newUv.x = sp.x * f * 1.0; // Texture repetition x-axis\n        newUv.y = sp.y * f * 0.9; // Texture repetition y-axis\n        newUv += vec2(animationSpeed * rotationSpeed, 777.777);\n        \n        // Sample texture for star sphere\n        vec3 texSample = texture(iChannel0, newUv).rgb;\n        float uOff = (texSample.g * brightness * 4.5 + animationSpeed);\n        vec2 starUV = newUv + vec2(uOff, 0.0);\n        starSphere = texture(iChannel0, starUV).rgb;\n    }\n\n    // Calculate star glow intensity\n    float starGlow = min(max(1.0 - dist * (1.0 - brightness), 0.0), minGlowIntensity);\n\n    // Combine colors for final output\n    fragColor.rgb = vec3(f * (0.7 + brightness * 1.5) * color1) + starSphere + corona * color2 + starGlow * color2;\n    fragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}]}