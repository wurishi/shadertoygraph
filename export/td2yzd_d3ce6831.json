{"ver":"0.1","info":{"id":"td2yzd","date":"1588513214","viewed":306,"name":"Ground-up Greek Temple.","username":"dean_the_coder","description":"Ground-up ray-marcher written (mostly) using my brain and what I can remember from iq and BigWing's (aka The Art of Code) tutorials (Thanks guys!).\n\nLighting can definitely be improved I think, but I'm pushing my abilities here.  Suggestions welcome!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks to all the experts out there that spend their time\n// writing blogs, YouTube videos, and documenting their shader code!\n// Iq, BigWings, P_Malin, Shane, and many others. Thanks!\n//\n// The appearance of this scene is inspired by Iq's AWESOME temple (https://www.shadertoy.com/view/ldScDh),\n// but with the code written from scratch (as much as I can..)\n//\n//   -Dean\n\n#define MAX_DIST 1200.\n#define MAX_STEPS 200\n#define ZERO min(iFrame, 0)\n\n#define SUNCOL vec3(1.64, 1.27, .99)\n#define SKYCOL vec3(.6, .8, .9)\n\n#define SEA_LEVEL -100.\n\nfloat hash(vec2 p) {\n\treturn fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\n// Smooth noise generator.\nfloat noise(vec2 p) {\n\tvec2 i = floor(p),\n\t\t f = fract(p);\n\n\tfloat a = hash(i),\n\t\t  b = hash(i + vec2(1, 0)),\n\t\t  c = hash(i + vec2(0, 1)),\n\t\t  d = hash(i + vec2(1, 1));\n\tf = f * f * (3. - 2. * f); // smoothstep with no clamp.\n\n\treturn mix(a, b, f.x) +\n\t\t   (c - a) * f.y * (1. - f.x) +\n\t\t   (d - b) * f.x * f.y;\n}\n\nfloat fbm(vec2 p) {\n\tfloat s = 0.,\n\n\t\t  a = .498,\n\t\t  f = 1.012;\n\tfor (int i = 0; i < 8; i++) {\n\t\ts += a * noise(p * f);\n\t\ta *= .501;\n\t\tf *= 1.988;\n\t}\n\n\treturn s;\n}\n\nvec2 repeat(vec2 p, vec2 gap) {\n\treturn mod(p, gap) - gap / 2.;\n}\n\nfloat sdCube(vec3 p, vec3 r) {\n\tp = abs(p) - r;\n  \treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdColumn(vec3 p, float r) {\n\treturn length(p.xz) - r;\n}\n\nfloat sdTempleColumn(vec3 p) {\n\tfloat h = 8.,\n\t\t  r = .6,\n\t\t  baseHeight = .16;\n\n\t// Column.\n\tr -= .1 * (p.y / (h / 2.)); // Taper.\n\tr -= .05 * pow(.5 + .5 * sin(p.y * 4.5), 200.); // Segments.\n\tr -= .03 * pow(.5 + .5 * sin(15. * atan(p.z, p.x)), 4.); // Ridges.\n\tfloat d = sdColumn(p, r);\n\n\t// Top block.\n\t{\n\t\tvec3 q = p;\n\t\tq.y = q.y - h / 2. + baseHeight;\n\t\td = min(d, sdCube(q, vec3(.7, baseHeight, .7)) - .05);\n\t}\n\n\t// Base block.\n\t{\n\t\tvec3 q = p;\n\t\tq.y = q.y + h / 2. - baseHeight * 2.5;\n\t\td = min(d, sdCube(q, vec3(.7, baseHeight, .7)) - .05);\n\t}\n\n\treturn d;\n}\n\nfloat sdTemple(vec3 p) {\n\tfloat d = 1E10;\n\n\tvec3 q = p;\n\tq.xz = repeat(q.xz, vec2(2)); // x,z repeat for tiles.\n\n\t// All columns.\n\t{\n\t\td = sdTempleColumn(q);\n\t\td = max(d, -sdCube(p, vec3(4, 50, 6))); // Exclude inside.\n\t\td = max(d, sdCube(p, vec3(6, 4, 8))); // Exclude outside.\n\t}\n\n\t// Floor tiles.\n\t{\n\t\tq.y += 4.;\n\t\td = min(d, sdCube(q, vec3(.9, .16, .9)) - .05);\n\t\td = max(d, sdCube(p, vec3(8, 5, 8))); // Exclude outside.\n\t}\n\n\t// Foundation blocks.\n\t{\n\t\tvec3 qq = p;\n\t\tqq.xz -= vec2(1);\n\t\tqq.xz = repeat(qq.xz, vec2(2));\n\t\tqq.y += 5.3;\n\t\td = min(d, sdCube(qq, vec3(.9, 1, .9)) - .05);\n\t\td = max(d, sdCube(p, vec3(9, 6, 9))); // Exclude outside.\n\n\t\t// Roof blocks.\n\t\t{\n\t\t\tqq.y = p.y - 4.6;\n\n\t\t\tfloat dd = sdCube(qq, vec3(.9, .5, .85)) - .05;\n\t\t\tdd = max(dd, sdCube(p, vec3(6.5, 6, 9)) - .05); // Exclude outside.\n\t\t\td = min(d, dd);\n\t\t}\n\t}\n\n\t// Roof base.\n\td = min(d, sdCube(p - vec3(0, 5.3, 0), vec3(7, .2, 9.5) - .05));\n\n\td += fbm((p.xy + p.yz) * 1.2) * .1;\n\treturn d * .8;\n}\n\nfloat sdTerrain(vec3 p) {\n\tp.y -= SEA_LEVEL;\n\tfloat h = 70. * (pow(fbm(p.xz * vec2(.015)), 1.5) - .5),\n\n\t\t  t2 = .7 * fbm((p.xz + vec2(0, 140)) * vec2(.05)) - .538,\n\t\t  hAtTemple = -SEA_LEVEL + t2 * 20.;\n\n\th = mix(h, hAtTemple, clamp(smoothstep(10., 0., length(p.xz) / 15.), 0., 1.));\n\n\treturn p.y - h;\n}\n\nfloat sdSea(vec3 p) {\n\tfloat waveHeight = (.5 - fbm(p.xz * .04)) * 2.;\n\treturn p.y - SEA_LEVEL + waveHeight;\n}\n\nvec2 map(vec3 p) {\n\tfloat o1 = sdTemple(p - vec3(0, 2.35, 0)),\n\t\t  o2 = sdTerrain(p),\n\t\t  o3 = sdSea(p);\n\n\tvec2 hit = vec2(o1, 1); // Temple\n\tif (o2 < hit.r)\n\t\thit = vec2(o2, 2); // Terrain\n\tif (o3 < hit.r)\n\t\thit = vec2(o3, 3); // Sea\n\n\treturn hit;\n}\n\nvec3 calcNormal(vec3 p) {\n\t// Thanks community! I didn't fancy deriving this...\n\tvec3 n = vec3(0);\n\tfor (int i = ZERO; i < 4; i++)\n\t{\n\t\tvec3 e = .5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n\t\tn += e * map(p + .0005 * e).x;\n\t}\n\n\treturn normalize(n * .5773);\n}\n\nfloat calcShadow(vec3 origin, vec3 lightOrigin, float fuzziness) {\n\tfloat s = 1.;\n\n\tvec3 rayDir = normalize(lightOrigin - origin);\n\tfloat d = 1.;\n\twhile (d < 20. && s > 0.) {\n\t\tfloat distToObj = map(origin + rayDir * d).x;\n\t\ts = min(s, .5 + .5 * distToObj / (fuzziness * d));\n\t\td += clamp(distToObj, .2, 1.);\n\t}\n\n\treturn smoothstep(0., 1., s);\n}\n\nfloat calcOcclusion(vec3 origin, vec3 n) {\n\tfloat occ = 0.,\n\t\t  d = .01;\n\tfor (int i = 1; i < 5; i++) {\n\t\tfloat h = map(origin + n * d).x;\n\t\tocc += d - h;\n\t\td += .15;\n\t}\n\n\treturn 1. - clamp(occ * .5, 0., 1.);\n}\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n\tvec3 cam = vec3(7, 6.5, -25),\n\t\t lookAt = vec3(-13, -4, 0),\n\t\t forward = normalize(lookAt - cam),\n\t\t right = normalize(cross(vec3(0, 1, 0), forward)),\n\t\t up = cross(forward, right),\n\t\t rayDir = normalize(forward + uv.x * right + uv.y * up);\n\n\tvec3 sunPosUnit = normalize(vec3(.5, .8, .7)),\n\t\t sunPos = sunPosUnit * 100.,\n\t\t ambCol = vec3(.3, .3, .95);\n\n\tvec3 col = vec3(0);\n\tfloat d = 0.;\n\tvec2 hit = vec2(0);\n\tvec3 p;\n\tfor (int steps = ZERO; steps < MAX_STEPS; steps++) {\n\t\tp = cam + rayDir * d;\n\n\t\thit = map(p);\n\t\tfloat distToObj = hit.x;\n\t\tif (abs(distToObj) < d * .001) {\n\t\t\t// Ray Hit!\n\t\t\tbreak;\n\t\t}\n\n\t\tif (d > MAX_DIST) {\n\t\t\thit = vec2(0);\n\t\t\tbreak;\n\t\t}\n\n\t\td += distToObj;\n\t}\n\n\tif (hit.y < .5) {\n\t\t// ID0 Sky\n\t\tcol = SKYCOL;\n\t} else {\n\t\tvec3 mat,\n\t\t\t n = calcNormal(p);\n\t\tfloat occ = calcOcclusion(p, n),\n\t\t\t  sha;\n\n\t\tif (hit.y < 1.5) {\n\t\t\t// ID1 Temple\n\t\t\tsha = calcShadow(p, sunPos, .125);\n\t\t\tmat = vec3(.2, .18, .1);\n\t\t} else if (hit.y < 2.5) {\n\t\t\t// ID2 Terrain\n\t\t\tfloat grassy = smoothstep(.7, 1., n.y);\n\t\t\tvec3 rockCol = vec3(.04, .04, .03),\n\t\t\t\t grassCol = vec3(.025, .1, .03);\n\t\t\tmat = mix(rockCol, grassCol, grassy);\n\t\t\tsha = calcShadow(p, sunPos, 1.);\n\t\t} else if (hit.y < 3.5) {\n\t\t\t// ID3 Sea\n\t\t\tmat = vec3(.002, .02, .04);\n\t\t\tsha = calcShadow(p, sunPos, 1.);\n\t\t\tfloat terrainDist = sdTerrain(p);\n\t\t\tmat *= 1. * (1. + smoothstep(30., 0., terrainDist)); // Deep sea.\n\t\t\tmat *= 1. * (1. + smoothstep(5., 0., terrainDist)); // Shallow areas.\n\t\t}\n\n\t\tfloat sun = max(0., dot(sunPosUnit, n)) * 6.,\n\t\t\t  back = .2 * max(0., dot(sunPosUnit * vec3(-1, 0, -1), n)),\n\t\t\t  sky = (.6 + .5 * n.y) * .05;\n\n\t\tcol = mat * sun * SUNCOL * sha;\n\t\tcol += mat * back * SUNCOL * occ;\n\t\tcol += mat * sky * SKYCOL * occ;\n\n\t\tfloat fog = pow(length(p - cam) / MAX_DIST, 7.);\n\t\tcol = mix(col, SKYCOL, fog);\n\t}\n\n\t// Output to screen\n\tcol = pow(col, vec3(.4545)); // Gamma correction\n\tcol = vignette(col, fragCoord); // Fade screen corners\n\tfragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}