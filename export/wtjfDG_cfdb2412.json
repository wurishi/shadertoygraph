{"ver":"0.1","info":{"id":"wtjfDG","date":"1600724815","viewed":361,"name":"Mocap Dog","username":"shau","description":"small experiment with motion capture data. The loop is a bit dodgy, Using Fourier interpolation from IQ to reduce dataset ","likes":34,"published":1,"flags":32,"usePreview":1,"tags":["3d","fourier","mocap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/**\n * Motion capture of running dog\n * TRC file from https://motioncapturedata.com/category/animal-mocap/\n *\n * Fourier Interpolation code borrowed from IQ\n * https://www.shadertoy.com/view/4lGSDw\n *\n * Other nice examples of Motion Capture on Shadertoy\n *\n * Human Document by Reinder\n * https://www.shadertoy.com/view/XtcyW4\n *\n * Humanination by Pellicus\n * https://www.shadertoy.com/view/ltdcW7\n *\n * The Walking Raymarcher by xorxor\n * https://www.shadertoy.com/view/Mt3XWH\n **/\n\n#define FAR 100.\n#define EPS 0.005\n#define ZERO (min(iFrame,0))\n#define SCALE 0.005\n\n//distance functions IQ\n//https://iquilezles.org/www/index.htm\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;    \n}\n\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.yz) - t.x, p.x);\n    return length(q) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nfloat planeIntersect(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nvec4 cylIntersect(vec3 ro, vec3 rd, vec3 pa, vec3 pb, float ra)\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\nvec2 near(vec2 a, vec2 b)\n{\n    return mix(a,b,step(b.x, a.x));\n}\n\nvec2 dfFL(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    float t = min(sdRoundCone(p,a,b,0.2,0.14),\n                  sdRoundCone(p,b,c,0.14,0.1));     \n\tt = min(t, sdRoundCone(p,c,d,0.1,0.08)); \n    \n    vec3 f = p - d;\n    f.yz *= rot((-d.y) * -1.);\n    t = min(t, max(sdEllipsoid(f,vec3(0.2,0.1,0.5)),-f.z));\n    \n    float s = smin(sdSphere(p - a,0.24),\n                   sdCappedCylinder(p - a,0.1,0.3), 0.08);\n    s = min(s, sdSphere(p - b, 0.16));\n    s = smin(s,  sdCappedCylinder(p - b,0.1,0.2), 0.08);\n    s = min(s, sdSphere(p - c, 0.12));\n    s = smin(s,  sdCappedCylinder(p - c,0.08,0.14), 0.08);\n    s = min(s, sdSphere(p - d, 0.1));\n    s = smin(s,  sdCappedCylinder(p - d,0.06,0.12), 0.08);\n\n\tt = smax(t, -s, 0.06);\n\n    float r = min(sdCapsule(p,a,vec3(a.x+0.46*sign(a.x),a.yz),0.08), \n            \t  sdCapsule(p,b,vec3(b.x+0.32*sign(b.x),b.yz),0.08));\n    r = min(r, sdCapsule(p,c,vec3(c.x+0.26*sign(c.x),c.yz),0.06));\n    r = min(r, sdCapsule(p,d,vec3(d.x+0.22*sign(d.x),d.yz),0.06));\n\n    return near(vec2(t,1.), near(vec2(s,2.), vec2(r,3.)));\n}\n\nvec2 dfRL(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    float t = min(sdRoundCone(p,a,b,0.28,0.18), \n                  sdRoundCone(p,b,c,0.14,0.1));     \n\tt = min(t, sdRoundCone(p,c,d,0.1,0.08)); \n\n    vec3 f = p - d;\n    f.yz *= rot((-d.y) * -1.3);\n    t = min(t, max(sdEllipsoid(f,vec3(0.2,0.1,0.5)),-f.z));\n    \n    float s = smin(sdSphere(p - a, 0.28),\n             \t   sdCappedCylinder(p - a,0.1,0.36), 0.08);\n    s = min(s,sdSphere(p - b, 0.2));\n    s = smin(s,sdCappedCylinder(p - b,0.1,0.26), 0.08);\n    s = min(s,sdSphere(p - c, 0.14));\n    s = smin(s,sdCappedCylinder(p - c,0.08,0.2), 0.08);\n    s = min(s,sdSphere(p - d, 0.1));\n    \n\tt = smax(t, -s, 0.06);\n    \n    float r = min(sdCapsule(p,a,vec3(a.x+0.5*sign(a.x),a.yz),0.08),\n                  sdCapsule(p,b,vec3(b.x+0.32*sign(b.x),b.yz),0.08));\n    r = min(r, sdCapsule(p,c,vec3(c.x+0.26*sign(c.x),c.yz),0.06));\n    r = min(r, sdCapsule(p,d,vec3(d.x+0.15*sign(d.x),d.yz),0.06));\n\n    return near(vec2(t,1.), near(vec2(s,2.), vec2(r,3.)));\n}\n   \n\nvec3 map(vec3 p) {\n\n    //joints\n    vec3 nose =  texture(iChannel0,NOSE /R).xyz * SCALE,\n         head =  texture(iChannel0,HEAD /R).xyz * SCALE,\n         shou =  texture(iChannel0,SHOU /R).xyz * SCALE,\n         ltfl =  texture(iChannel0,LTFL /R).xyz * SCALE,\n         lmfl =  texture(iChannel0,LMFL /R).xyz * SCALE,\n         lbfl =  texture(iChannel0,LBFL /R).xyz * SCALE,\n         rtfl =  texture(iChannel0,RTFL /R).xyz * SCALE,\n         rmfl =  texture(iChannel0,RMFL /R).xyz * SCALE,\n         rbfl =  texture(iChannel0,RBFL /R).xyz * SCALE,\n         backf = texture(iChannel0,BACKF/R).xyz * SCALE,\n         backm = texture(iChannel0,BACKM/R).xyz * SCALE,\n         backb = texture(iChannel0,BACKB/R).xyz * SCALE,\n         ltrl =  texture(iChannel0,LTRL /R).xyz * SCALE,\n         lmrl =  texture(iChannel0,LMRL /R).xyz * SCALE,\n         lbrl =  texture(iChannel0,LBRL /R).xyz * SCALE,\n         rtrl =  texture(iChannel0,RTRL /R).xyz * SCALE,\n         rmrl =  texture(iChannel0,RMRL /R).xyz * SCALE,\n         rbrl =  texture(iChannel0,RBRL /R).xyz * SCALE;\n    \n    //head\n    vec3 hp = shou + normalize(head - shou) * length(head - shou) * 1.4; \n    vec3 qhp = p - hp;\n    qhp.x = abs(qhp.x);\n    qhp.zy *= rot(-sin((head.y - nose.y)/length(head.yz - nose.yz)));\n    \n    float l = sdEllipsoid(qhp - vec3(0,0.14,0.1),vec3(0.56,0.26,0.3));\n    l = min(l, sdTorus(p - shou, vec2(0.3,0.16)));\n    \n    float t = smin(sdEllipsoid(qhp - vec3(0,0,0.4),vec3(0.4,0.2,0.6)),\n                   sdEllipsoid(qhp - vec3(0,-0.1,0.2),vec3(0.2,0.2,0.5)),0.1);\n    t = smin(t,sdEllipsoid(qhp - vec3(0,0.14,0.1),vec3(0.6,0.3,0.34)),0.1);\n    t = smin(t, max(sdEllipsoid(qhp - vec3(0.3,0.36,0.0), vec3(0.1,0.3,0.1)),qhp.z),0.1 );\n    t = smin(t, sdBox(qhp - vec3(0,0.1,0.7), vec3(0.04,0.1,0.2)),0.06);\n    t = smax(t, -sdBox(qhp - vec3(0.5,0.24,0.36), vec3(0.3,0.06,0.3)),0.02);\n    t = smin(t, sdRoundCone(p,shou,hp,0.3,0.16), 0.2);\n    \n    \n    t = min(t, sdRoundCone(p,backm,backb,0.3,0.16));\n    \n    //tail\n    float tl = backb.z - p.z;\n    vec3 qt = p;\n    qt.y -= tl*tl*0.1*sin(iTime*6.0);\n    qt.x -= tl*tl*0.06*sin(iTime*7.0);\n    t = min(t, sdRoundCone(qt,backb,vec3(backb.xy,backb.z-2.2),0.16,0.02));\n   \n    t = smin(t, sdEllipsoid(p - backb,vec3(0.8,0.4,0.4)),0.1);\n    t = min(t, sdRoundCone(p,backf,backm,0.4,0.3));\n    \n    t = smin(t, sdRoundCone(p,shou,backf,0.5,0.4),0.1);\n    \n    \n    vec3 q = p;\n    q.x = abs(q.x);\n    \n    l = min(l, sdTorus(q - vec3(0.36,backb.yz), vec2(0.35,0.04)));\n    \n    t = smax(t, -sdSphere(q - vec3(0.5,backb.yz),0.32),0.04);\n    t = smax(t, -sdCappedCylinder(p - vec3(0.,shou.yz),0.38,1.8),0.1);\n        \n    float s = smin(sdSphere(p - backm, 0.34), \n                   sdCappedCylinder(p - backm,0.14,0.5),0.1);\n    s = min(s, sdSphere(p - backf, 0.44));\n    s = smin(s, sdCappedCylinder(p - backf,0.16,0.5),0.1);\n\n    s = min(s, sdSphere(qhp,0.32));\n    \n    t = smax(t,-s,0.04);\n    \n    float r = min(sdCapsule(p, vec3(0.7,backm.yz),vec3(-0.7,backm.yz),0.1),\n                  sdCapsule(p, vec3(0.7,backf.yz),vec3(-0.7,backf.yz),0.12 ));\n    //r = min(r, sdCapsule(q, vec3(0.7,backm.yz),vec3(1.,backb.yz),0.04 ));\n    //r = min(r, sdCapsule(q, vec3(0.7,backf.yz),vec3(0.7,backm.yz),0.04 ));\n    //r = min(r, sdCapsule(q, vec3(0.8,shou.yz),vec3(0.7,backf.yz),0.04 ));\n    \n    \n    vec2 n = near(vec2(t,1.),near(vec2(s,2.),vec2(r,3.)));\n    n = near(n, vec2(l,4.));\n    n = near(n, dfFL(p,vec3(0.4,shou.yz),ltfl,lmfl,lbfl));\n    n = near(n, dfFL(p,vec3(-0.4,shou.yz),rtfl,rmfl,rbfl));\n    n = near(n, dfRL(p,vec3(0.5,backb.yz),ltrl,lmrl,lbrl));\n    n = near(n, dfRL(p,vec3(-0.5,backb.yz),rtrl,rmrl,rbrl));\n\n    return vec3(n,l);\n}\n\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 8.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\nfloat bounds(vec3 ro, vec3 rd)\n{\n    float ci = cylIntersect(ro,rd,vec3(0,1.2,2.0),vec3(0,1.2,-2.8),2.).x;\n    float cit = cylIntersect(ro,rd,vec3(0,1.9,-2.6),vec3(0,1.9,-4.0),1.0).x;\n    if (ci>0.0) {\n        if (cit>0.0 && cit<ci) return cit;\n        return ci;\n    }\n    if (cit>0.0)\n    {\n      \tif (ci>0.0 && ci<cit) return ci;\n        return cit;\n    }\n    return -1.0;\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0, id = 0.0, mint = FAR;\n    vec3 pc = vec3(0),\n         gc = vec3(0),\n         lp = vec3(4,5,-3);\n    \n    \n    float fi = planeIntersect(ro, rd, vec3(0,1,0),vec3(0,-0.0,0));\n    if (fi > 0.0)\n    {\n    \tmint = fi;\n        vec3 p = ro + rd*fi;\n        vec3 ld = normalize(lp - p);\n        float ao = AO(p, vec3(0,1,0));\n        \n        p.z += T*6.0;\n        p.z = mod(p.z, 8.0) - 4.0;\n        vec2 uv = abs(p.xz); \n        vec2 fruv = fract(uv*6.);\n        float pt = min(sdBox(uv,vec2(0.5,1.4)),\n                       length(uv - vec2(0.4,1.3)) - 0.6);\n        pc = vec3(0,0,1) * S(0.4,0.3, length(fruv - vec2(0.5))) / (1. + pt*pt*20.);\n    }\n   \n    float b = bounds(ro,rd);\n    if (b>0.)\n    {\n        t = b;\n        for (int i=ZERO; i<100; i++)\n        {\n            vec3 p = ro + rd*t;\n            vec3 ns = map(p);\n            if (abs(ns.x)<EPS)\n            {\n                id = ns.y;\n                break;\n            }\n\n            gc += vec3(0,0,0.1)/(1.0 + ns.z*ns.z*800.);\n            t += ns.x;\n\n            if (t>FAR) \n            {\n                t = -1.;\n                break;\n            }\n        }\n\n        if (t>0.0 && t<mint)\n        {\n            vec3 p = ro + rd*t;\n            vec3 n = normal(p);\n            vec3 ld = normalize(lp - p);\n            float fres = pow(clamp(dot(n,rd) + 1.0,0.0,1.0),2.0);\n            float spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 2.0);\n            vec3 rc = texture(iChannel1,reflect(rd,n)).xyz;\n            float ao = AO(p, vec3(0,1,0));\n            float df = max(0.1, dot(ld,n));\n\n            vec3 sc = vec3(0);\n            if (id==1.)\n            {\n                sc = vec3(1) * df;\n                sc += rc *0.2 * (1.-fres);\n            }\n            else if (id==2.0)\n            {\n                sc = vec3(0.4)*df*spec;\n            }\n            else if (id==3.0)\n            {\n                sc = rc;\n            }\n            else if (id==4.0)\n            {\n                sc = vec3(0.2,0.2,1);\n            }\n\n            pc = sc * ao;\n        }        \n    }\n    \n    pc += gc;\n    \n    \n    return vec4(pc,t);\n}\n\n//IQ\nmat3 camera(vec3 la, vec3 ro, float cr)\n{\n\tvec3 cw = normalize(la - ro),\n\t     cp = vec3(sin(cr),cos(cr),0.0),\n\t     cu = normalize(cross(cw,cp)),\n\t     cv =          (cross(cu,cw));\n    return mat3(cu,cv,cw); \n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 la = vec3(0,1,0),\n         ro = vec3(3,3.+sin(T*0.1)*0.7,5);\n    \n    ro.xz *= rot(sin(iTime*-0.2)*1.6);\n    \n    float fl = 1.4;\n    mat3 cam = camera(la,ro,0.); \n    \n    vec2 uv = (2.0*(U) - R.xy)/R.y;\n    vec3 rd = cam*normalize(vec3(uv,fl));        \n\n    C = vec4(render(ro,rd).xyz,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define S(a, b, v) smoothstep(a, b, v)\n#define T iTime\n\n#define NOSE  vec2(0.5, 0.5)\n#define HEAD  vec2(1.5, 0.5)\n#define SHOU  vec2(2.5, 0.5)\n#define LTFL  vec2(3.5, 0.5)\n#define LMFL  vec2(4.5, 0.5)\n#define LBFL  vec2(5.5, 0.5)\n#define RTFL  vec2(6.5, 0.5)\n#define RMFL  vec2(7.5, 0.5)\n#define RBFL  vec2(8.5, 0.5)\n#define BACKF vec2(9.5, 0.5) \n#define BACKM vec2(10.5,0.5)\n#define BACKB vec2(11.5,0.5)\n#define LTRL  vec2(12.5,0.5)\n#define LMRL  vec2(13.5,0.5)\n#define LBRL  vec2(14.5,0.5)\n#define RTRL  vec2(15.5,0.5)\n#define RMRL  vec2(16.5,0.5)\n#define RBRL  vec2(17.5,0.5) \n   \n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n  Motion Capture Data\n  24 Frame fourier analysis performed on 37 frames of mocap data\n  2 * 16bit unsigned ints stored in each uint \n*/\n\n//fourier frames\n#define FFRAMES 24\n//original number of frames sampled\n#define OFS 38.0\n#define xOffs 15115.\n#define yOffs 1413.\n\nvec2 decode(uint d)\n{\n    return vec2(d >> 16U, d & 0x0000FFFFU);    \n}\n\nvec2 posD(uint[FFRAMES] eX, uint[FFRAMES] eY, float h, vec2 U)\n{\n    vec2 q = vec2(0.0);\n    for (int k=0; k<FFRAMES; k++)\n    {\n    \tfloat w = (k==0||k==(FFRAMES - 1)) ? 1.0 : 2.0;\n        float an = -6.283185*float(k)*h;\n        vec2 ex = vec2(cos(an), sin(an));\n        q.x += w*dot(decode(eX[k]) - xOffs,ex)/OFS;\n        q.y += w*dot(decode(eY[k]) - yOffs,ex)/OFS;\n    }\n    if (iFrame>0) {\n        q = mix(q,texelFetch(iChannel0, ivec2(U),0).zy,0.7);    \n    }\n    return q;\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float h = mod(floor(T*50.), 100.) /\n        \t\t\t\t100.;\n    \n    uint eX[FFRAMES],\n         eY[FFRAMES];\n    \n    vec3 p = vec3(0);\n    \n    if (U==NOSE) {\n        eX = uint[24] (0x5dbf3b0bU,0x3ae53b4dU,0x3909395dU,0x3adc3b26U,0x3af53b9aU,0x3b043b20U,0x3afa3b07U,0x3b083b1aU,0x3b083b0fU,0x3b063b14U,0x3b073b12U,0x3b063b10U,0x3b053b0fU,0x3b053b0eU,0x3b053b0eU,0x3b053b0dU,0x3b053b0cU,0x3b053b0cU,0x3b053b0bU,0x3b053b0bU,0x3b053b0bU,0x3b053b0aU,0x3b053b0aU,0x3b053b09U);\n        eY = uint[24] (0x3f1b0585U,0x5750656U,0x65801feU,0x57d0553U,0x5f3057eU,0x585055fU,0x598057bU,0x590056fU,0x5930572U,0x58f0578U,0x590057aU,0x590057cU,0x590057dU,0x590057fU,0x5900580U,0x5900581U,0x5900582U,0x5900583U,0x5900584U,0x5900585U,0x5900586U,0x5900587U,0x5900588U,0x5900589U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(0.,q,1.0);\n    } else if (U==HEAD) {\n        eX = uint[24] (0x52133b0bU,0x3afd3b23U,0x385c39dcU,0x3ad53b40U,0x3b133bd4U,0x3b1a3b27U,0x3b003b0fU,0x3b053b1fU,0x3b023b12U,0x3b023b16U,0x3b033b14U,0x3b033b12U,0x3b023b11U,0x3b033b10U,0x3b023b0fU,0x3b023b0eU,0x3b023b0dU,0x3b023b0cU,0x3b023b0bU,0x3b023b0bU,0x3b023b0bU,0x3b023b0aU,0x3b023b09U,0x3b023b08U);\n        eY = uint[24] (0x48770585U,0x5710629U,0x541029bU,0x571057bU,0x5db05ccU,0x58a0577U,0x5970589U,0x58c057cU,0x58e057dU,0x58b0581U,0x5890580U,0x58a0582U,0x58a0582U,0x5890583U,0x5890583U,0x5890584U,0x5890584U,0x5890585U,0x5890585U,0x5890585U,0x5890585U,0x5890585U,0x5890586U,0x5890586U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(0.,q.y,q.x,1.0);\n    } else if (U==SHOU) {\n        eX = uint[24] (0x43a73b0bU,0x3b0d3accU,0x398d38aeU,0x3ad93af5U,0x3ba53ae5U,0x3afc3b06U,0x3b1d3b11U,0x3b0f3b0cU,0x3b093b04U,0x3b0f3b0bU,0x3b0f3b08U,0x3b0e3b09U,0x3b0e3b09U,0x3b0e3b0aU,0x3b0e3b0aU,0x3b0e3b0aU,0x3b0e3b0bU,0x3b0e3b0bU,0x3b0e3b0bU,0x3b0e3b0bU,0x3b0e3b0bU,0x3b0e3b0bU,0x3b0e3b0bU,0x3b0e3b0cU);\n        eY = uint[24] (0x3ce90585U,0x54a05c6U,0x6b8025bU,0x55a058cU,0x5f005c1U,0x58a058eU,0x57e058eU,0x580058fU,0x585057fU,0x5830587U,0x5850585U,0x5850586U,0x5840585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(0.,q.y,q.x,1.0);\n    } else if (U==LTFL) {\n        eX = uint[24] (0x42fc3b0bU,0x3abd3b3eU,0x346633e2U,0x3ab43b25U,0x3d033b0aU,0x3b023ae2U,0x3ae03b5eU,0x3b1c3b13U,0x3b0d3b03U,0x3b063b0dU,0x3b0b3b0cU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU);\n        eY = uint[24] (0x25da0585U,0x5a005d9U,0x57b03aeU,0x5a3057cU,0x5910608U,0x57f05a3U,0x5400520U,0x5700586U,0x5a00573U,0x5850580U,0x5870589U,0x5850586U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(100.,q.y,q.x,1.0);\n    } else if (U==LMFL) {\n        eX = uint[24] (0x45643b0bU,0x3aa83b6bU,0x31bf2eb4U,0x3ab73b1bU,0x3d4f3ab4U,0x3b0b3b16U,0x3ac13b0bU,0x3b023b20U,0x3b0c3b10U,0x3b043b14U,0x3b063b15U,0x3b043b12U,0x3b033b11U,0x3b033b10U,0x3b033b0fU,0x3b033b0eU,0x3b033b0dU,0x3b033b0cU,0x3b033b0bU,0x3b033b0bU,0x3b033b0bU,0x3b033b0aU,0x3b033b09U,0x3b033b08U);\n        eY = uint[24] (0x1ac00585U,0x59805eaU,0x5c30194U,0x5ab0574U,0x48c06cbU,0x5740597U,0x5770526U,0x5810584U,0x58b0587U,0x5870584U,0x5870583U,0x5860585U,0x5860585U,0x5860585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(90.,q.y,q.x,1.0);\n    } else if (U==LBFL) {\n        eX = uint[24] (0x48a23b0bU,0x3ab23babU,0x2dae2c19U,0x3a943b58U,0x3bed3a70U,0x3af83b0bU,0x3afe3af8U,0x3b0e3b11U,0x3b0d3b0fU,0x3b0b3b15U,0x3b083b15U,0x3b063b14U,0x3b053b12U,0x3b043b11U,0x3b043b10U,0x3b033b0fU,0x3b033b0dU,0x3b033b0cU,0x3b033b0bU,0x3b033b0bU,0x3b033b0bU,0x3b033b0aU,0x3b033b09U,0x3b033b07U);\n        eY = uint[24] (0x13470585U,0x5910600U,0x48700d4U,0x5bb0578U,0x4ff06f4U,0x57e058fU,0x592057cU,0x5810583U,0x5820583U,0x5850582U,0x5850582U,0x5860583U,0x5860583U,0x5860584U,0x5860584U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(80.,q.y,q.x,1.0);\n    } else if (U==RTFL) {\n        eX = uint[24] (0x45c13b0bU,0x3ade3c11U,0x32d83b97U,0x3b0d3b6aU,0x3a0e39f4U,0x3ae53b2fU,0x3b523ad0U,0x3b053b0cU,0x3b103b0fU,0x3b063b11U,0x3b043b11U,0x3b053b0fU,0x3b043b0eU,0x3b053b0eU,0x3b043b0dU,0x3b043b0dU,0x3b043b0cU,0x3b043b0cU,0x3b043b0bU,0x3b043b0bU,0x3b043b0bU,0x3b043b0aU,0x3b043b0aU,0x3b043b09U);\n        eY = uint[24] (0x27ca0585U,0x5f40576U,0x44701eaU,0x55c0538U,0x5f305a9U,0x58c0575U,0x59705b3U,0x58c057eU,0x57c059cU,0x58c0582U,0x58a0582U,0x58a0581U,0x58a0582U,0x58a0582U,0x58a0583U,0x58a0583U,0x58a0584U,0x58b0584U,0x58b0585U,0x58b0585U,0x58b0585U,0x58b0586U,0x58a0586U,0x58a0587U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(-100.,q.y,q.x,1.0);    \n    } else if (U==RMFL) {    \t\n        eX = uint[24] (0x4a443b0bU,0x3afb3c23U,0x2d073bdaU,0x3af33b99U,0x392239fbU,0x3ad83b31U,0x3b363b1eU,0x3b043b14U,0x3afd3b21U,0x3b013b18U,0x3afe3b16U,0x3aff3b13U,0x3afe3b12U,0x3aff3b11U,0x3aff3b10U,0x3aff3b0fU,0x3aff3b0eU,0x3aff3b0dU,0x3aff3b0cU,0x3aff3b0bU,0x3aff3b0aU,0x3aff3b09U,0x3aff3b08U,0x3aff3b07U);\n        eY = uint[24] (0x1b3d0585U,0x6090581U,0x23301aaU,0x54d0548U,0x6d305e2U,0x5990562U,0x59f058dU,0x58c0576U,0x584057bU,0x58b057bU,0x58d057aU,0x58c057eU,0x58e057fU,0x58d0580U,0x58d0581U,0x58e0582U,0x58e0583U,0x58e0584U,0x58e0585U,0x58e0585U,0x58e0585U,0x58e0586U,0x58e0587U,0x58e0588U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(-90.,q.y,q.x,1.0);    \n    } else if (U==RBFL) {\n        eX = uint[24] (0x4b483b0bU,0x3b353c39U,0x28d63e50U,0x3b1d3bbeU,0x393f3ab9U,0x3af53b2fU,0x3b083b2fU,0x3b0b3b1bU,0x3ae73b29U,0x3b013b1dU,0x3af73b18U,0x3afd3b17U,0x3afa3b15U,0x3afb3b13U,0x3afb3b12U,0x3afb3b10U,0x3afb3b0fU,0x3afb3b0dU,0x3afa3b0cU,0x3afa3b0bU,0x3afa3b0aU,0x3afb3b09U,0x3afb3b07U,0x3afb3b06U);\n        eY = uint[24] (0x13bb0585U,0x5cd058aU,0x21802a9U,0x538055aU,0x71f0534U,0x57b055aU,0x5510584U,0x5770576U,0x58e056bU,0x5840575U,0x5900578U,0x58c0579U,0x58f057bU,0x58f057dU,0x590057eU,0x5900580U,0x5900581U,0x5900583U,0x5910584U,0x5910585U,0x5910586U,0x5900587U,0x5900589U,0x590058aU);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(-80.,q.y,q.x,1.0);    \n    } else if (U==BACKF) {\n        eX = uint[24] (0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU);\n        eY = uint[24] (0x47cb0585U,0x5b805a0U,0x6230405U,0x5700564U,0x5e40568U,0x58d057fU,0x57c058bU,0x585057eU,0x58d057aU,0x5880581U,0x5890581U,0x5890582U,0x5890582U,0x5890583U,0x5890583U,0x5890584U,0x5890584U,0x5890585U,0x5890585U,0x5890585U,0x5890585U,0x5890585U,0x5890586U,0x5890586U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(0.,q.y,q.x,1.0);    \n    } else if (U==BACKM) {    \t\n        eX = uint[24] (0x1f133b0bU,0x3a883b3bU,0x3a763b03U,0x3b5a3b70U,0x3a7a3b68U,0x3b5e3af3U,0x3afb3b1cU,0x3b073b00U,0x3b103b0eU,0x3b0b3b0cU,0x3b0c3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU,0x3b0b3b0bU);\n        eY = uint[24] (0x49a00585U,0x62c0521U,0x6f605feU,0x5320580U,0x604052cU,0x58c0574U,0x59b0584U,0x58f0574U,0x58e057bU,0x58e057dU,0x58d057eU,0x58d0580U,0x58d0581U,0x58c0582U,0x58c0582U,0x58c0583U,0x58c0584U,0x58c0584U,0x58c0585U,0x58c0585U,0x58c0585U,0x58c0586U,0x58c0586U,0x58c0587U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(0.,q.y,q.x,1.0);    \n    } else if (U==BACKB) {\n        eX = uint[24] (0x89c3b0bU,0x3afd3bb1U,0x3b173aa6U,0x3b163b14U,0x3a903adeU,0x3b0c3b0bU,0x3ae73b13U,0x3b013b10U,0x3b113b0eU,0x3b083b0fU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b093b0bU,0x3b093b0bU,0x3b093b0bU,0x3b093b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b0a3b0bU,0x3b093b0bU);\n        eY = uint[24] (0x40c00585U,0x5b104feU,0x3930941U,0x5b10578U,0x61a0608U,0x59d0585U,0x572054cU,0x58f0580U,0x581057dU,0x5890581U,0x5880584U,0x5880584U,0x5880584U,0x5880584U,0x5880585U,0x5880585U,0x5880585U,0x5880585U,0x5880585U,0x5880585U,0x5880585U,0x5880585U,0x5880585U,0x5880585U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(0.,q.y,q.x,1.0);    \n    } else if (U==LTRL) {    \t\n        eX = uint[24] (0x12113b0bU,0x3b023aeeU,0x41213632U,0x3af33aefU,0x3a9a3b09U,0x3b103af1U,0x3b2c3b36U,0x3b143b02U,0x3b1c3afdU,0x3b143b04U,0x3b113b07U,0x3b123b06U,0x3b123b07U,0x3b123b08U,0x3b123b09U,0x3b123b09U,0x3b123b0aU,0x3b123b0aU,0x3b123b0bU,0x3b123b0bU,0x3b123b0bU,0x3b123b0cU,0x3b123b0cU,0x3b123b0dU);\n        eY = uint[24] (0x29670585U,0x5ef051fU,0x6ff0758U,0x55b0552U,0x70104b0U,0x5810573U,0x57b055fU,0x589057bU,0x5970581U,0x58a0580U,0x58b057fU,0x58a0582U,0x58a0582U,0x58a0583U,0x58a0583U,0x58a0584U,0x58a0584U,0x58a0585U,0x58a0585U,0x58a0585U,0x58a0585U,0x58a0585U,0x58a0586U,0x58a0586U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(140.,q.y,q.x,1.0);    \n    } else if (U==LMRL) {    \t\n        eX = uint[24] (0x6063b0bU,0x3ad43af8U,0x44b130ffU,0x3acf3af7U,0x39b238b8U,0x3b023b01U,0x3a553aebU,0x3b123b05U,0x3b1d3b08U,0x3b153b00U,0x3b153b01U,0x3b153b03U,0x3b153b04U,0x3b153b05U,0x3b153b07U,0x3b153b08U,0x3b153b09U,0x3b153b0aU,0x3b153b0bU,0x3b153b0bU,0x3b153b0bU,0x3b153b0cU,0x3b153b0dU,0x3b153b0eU);\n        eY = uint[24] (0x1ea40585U,0x5f50515U,0x5720ce6U,0x5970569U,0x572052fU,0x589058cU,0x54b0554U,0x5860586U,0x5670598U,0x5870584U,0x58a0585U,0x5870584U,0x5870584U,0x5860584U,0x5860584U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U,0x5860585U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(160.,q.y,q.x,1.0);    \n    } else if (U==LBRL) {    \t\n        eX = uint[24] (0xa7c3b0bU,0x3ab23b16U,0x485b2cf2U,0x3ad73ae4U,0x39bb39d8U,0x3b0b3b00U,0x3a8a3ad3U,0x3b173b04U,0x3b063b0bU,0x3b153b01U,0x3b183b06U,0x3b153b04U,0x3b153b04U,0x3b153b06U,0x3b153b07U,0x3b153b08U,0x3b153b09U,0x3b153b0aU,0x3b153b0bU,0x3b153b0bU,0x3b153b0bU,0x3b153b0cU,0x3b153b0dU,0x3b153b0eU);\n        eY = uint[24] (0x15880585U,0x5cf0521U,0x7150b11U,0x5a80574U,0x562049aU,0x5890579U,0x5ca0587U,0x58b057dU,0x5720576U,0x589057eU,0x5890580U,0x58a057fU,0x58a0580U,0x58b0581U,0x58b0582U,0x58b0582U,0x58b0583U,0x58b0584U,0x58b0585U,0x58b0585U,0x58b0585U,0x58b0586U,0x58b0587U,0x58b0588U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(180.,q.y,q.x,1.0);    \n    } else if (U==RTRL) {\n        eX = uint[24] (0xf633b0bU,0x3ae33c16U,0x3f443ab6U,0x3afc3b26U,0x3b143acbU,0x3b193b11U,0x3acf3af6U,0x3b073b0cU,0x3b023b09U,0x3b073b0cU,0x3b073b0eU,0x3b083b0cU,0x3b083b0cU,0x3b083b0cU,0x3b083b0bU,0x3b083b0bU,0x3b083b0bU,0x3b093b0bU,0x3b093b0bU,0x3b093b0bU,0x3b093b0bU,0x3b093b0bU,0x3b083b0bU,0x3b083b0bU);\n        eY = uint[24] (0x2ebd0585U,0x57c0504U,0x4b707e3U,0x58f0590U,0x63d062cU,0x58a0584U,0x5a00577U,0x58b0585U,0x57c057fU,0x5860585U,0x5850586U,0x5860585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(-140.,q.y,q.x,1.0);    \n    } else if (U==RMRL) {\n        eX = uint[24] (0x3b0bU,0x3ac53bc8U,0x4607393cU,0x3b033af0U,0x3d933988U,0x3b143ae4U,0x3bad3a30U,0x3b2a3aeeU,0x3b1c3ad2U,0x3b233af7U,0x3b203afaU,0x3b203afeU,0x3b1e3b00U,0x3b1e3b03U,0x3b1d3b05U,0x3b1d3b06U,0x3b1d3b08U,0x3b1d3b09U,0x3b1d3b0aU,0x3b1d3b0bU,0x3b1d3b0cU,0x3b1d3b0dU,0x3b1d3b0eU,0x3b1d3b10U);\n        eY = uint[24] (0x1f620585U,0x59e04d9U,0xaecU,0x5ad05c1U,0x59e0541U,0x56f058fU,0x599057aU,0x57a0589U,0x59b056dU,0x5830585U,0x57f0580U,0x5830585U,0x5840585U,0x5830585U,0x5830585U,0x5830585U,0x5830585U,0x5830585U,0x5830585U,0x5830585U,0x5830585U,0x5830585U,0x5830585U,0x5830585U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(-160.,q.y,q.x,1.0);        \n    } else if (U==RBRL) {\n        eX = uint[24] (0x47c3b0bU,0x3acd3be7U,0x4bac392fU,0x3af73ac7U,0x3caa3932U,0x3b1e3ae1U,0x3b8c3a7cU,0x3b2b3aefU,0x3b363aebU,0x3b233afbU,0x3b1f3af7U,0x3b203b00U,0x3b1d3b02U,0x3b1d3b04U,0x3b1d3b05U,0x3b1c3b07U,0x3b1c3b08U,0x3b1c3b09U,0x3b1c3b0aU,0x3b1c3b0bU,0x3b1c3b0cU,0x3b1c3b0dU,0x3b1c3b0eU,0x3b1c3b0fU);\n        eY = uint[24] (0x14d20585U,0x5a704b9U,0x2450a64U,0x5b205b1U,0x64c050aU,0x57b0579U,0x53e0591U,0x5840586U,0x595058fU,0x5850585U,0x5850584U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U,0x5850585U);\n        vec2 q = posD(eX,eY,h,U);\n        C = vec4(-180.,q.y,q.x,1.0);\n    }      \n}\n","name":"Buffer A","description":"","type":"buffer"}]}