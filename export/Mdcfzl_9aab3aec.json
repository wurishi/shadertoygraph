{"ver":"0.1","info":{"id":"Mdcfzl","date":"1526320248","viewed":219,"name":"Wooden Parts","username":"tholzer","description":"Kali-inspired twisted sculpture parts.\n[url=https://www.shadertoy.com/view/lldSRM]Original[/url] coded by dila!\nPress mouse to view rounded distance function.\n","likes":8,"published":1,"flags":64,"usePreview":0,"tags":["3d","raymarching","texture","rotate","kali"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4d2SRV","filepath":"https://soundcloud.com/vynehall/movements-chapter-iii","previewfilepath":"https://soundcloud.com/vynehall/movements-chapter-iii","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//----------------------------------------------------------\n// Wooden_Parts.glsl\n// \n// Kali-inspired twisted sculpture parts.\n// Press mouse ti view rounded distance function.\n//\n// original: https://www.shadertoy.com/view/lldSRM by dila\n//\n//   v1.0  2018-05-14  initial release\n//   v1.1  2018-06-21  sdSphere added  \n//\n// tags: 3d, raymarching, texture, rotate, kali\n//----------------------------------------------------------\n\n#define pi 3.14159\n\n// return 2d rotation matrix for counter clockwise rotation\nmat2 rotate2d (float angle)    \n{ \n  float ca = cos(angle),  sa = sin(angle);    \n  return mat2(ca, sa, -sa, ca);\n}\n\n//----------------------------------------------------------\n// signed box: bs.xyz = box size\nfloat sdBox( vec3 pos, vec3 bs )\n{\n    vec3 d = abs(pos) - bs;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// signed sphere distance: pos = position  \nfloat sdSphere (vec3 pos, float radius)  \n{\n    return length(pos) - radius; \n}\n//----------------------------------------------------------\n\nvec3 mpos = vec3(0.0); // map position\nfloat mid = 0.0;\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    \n//  q.y += sin(q.z * 0.125) * 3.0;\n    \n//  q.x -= (sin(q.z * 0.25) * 0.5 + 0.5) * 3.0;\n    \n    q.xy *= rotate2d(iTime*0.3);\n    \n    float u = 5.125;\n    q.z = (fract(q.z / u) - 0.5) * u;\n    \n    vec3 s = vec3(1.0, 0.125, 0.25);\n    \n    const int n = 4;\n    for (int i = 0; i < n; ++i) {\n        q.y = abs(q.y) - 0.5;\n        q.xy *= rotate2d(pi * 0.125);\n        q = abs(q) - 0.125;\n        q.xy *= rotate2d(p.z * 0.5);\n    }\n    \n    mpos = p;\n    mid = 0.0;\n    float d = 28.0 - p.x;\n    \n    float k = sdBox(q, s);\n    if (iMouse.z > 0.)\n      k = sdSphere(q, s.y+s.z);\n\n    if (k < d) {\n    \td = k;\n        mpos = q * 10.0;\n        mid = 1.0;\n    }\n    \n    return d;\n}\n\n// return normalized normal vector\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    float d = map(p);\n    return normalize(vec3(d - map(p-o.xyy),\n                          d - map(p-o.yxy),\n                          d - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 40; ++i) \n    {   float d = map(o + r * t);\n\t\tif (d < 2.)\n             t += d * 0.6;\n\t\telse t += d * 0.9;\n    }\n    return t;\n}\n\nvec3 texture3d(sampler2D channel, vec3 p)\n{\n    vec3 ta = texture(channel, p.xy).xyz;\n    vec3 tb = texture(channel, p.xz).xyz;\n    vec3 tc = texture(channel, p.zy).xyz;\n    return (ta * ta + tb * tb + tc * tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(-5.0, 0.0, iTime * 1.0);\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    r.xy *= rotate2d(sin(iTime * 0.25) * 0.2);\n    r.xz *= rotate2d(pi * 0.5);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    float fd = map(w);\n    float ao = map(w + sn * 1.2);\n    \n    vec3 lcol1 = vec3(0.4, 0.3, 0.25) * 2.0;\n    vec3 lcol2 = vec3(0.5, 1.0, 1.0);\n    \n    vec3 tex = vec3(0.0);\n    if (mid == 0.0) {\n    \ttex = texture(iChannel0, mpos.yz * 0.03).xyz;\n        tex *= tex;\n    } else {\n        tex = texture3d(iChannel1, mpos * 0.05);\n        tex *= vec3(1.0, 0.5, 0.25);\n    }\n\n    vec3 lpos = o += vec3(-1.0, 8.0, -2.0);\n    vec3 ldel = w - lpos;\n    float ldist = length(ldel);\n    ldel /= ldist;\n    float lt = trace(lpos + sn * 0.5, ldel);\n    float lm = max(dot(ldel, -sn), 0.0);\n    lm /= (1.0 + ldist * ldist * 0.001);\n    if (lt < ldist) {\n        lm *= 0.25;\n    }\n    \n    if (mid == 1.0) {\n        vec3 ref = reflect(ldel, sn);\n    \tfloat spec = max(dot(r, -ref), 0.0);\n    \tspec = pow(spec, 4.0);\n        lcol1 *= 0.5 + spec;\n    \tlcol2 *= 0.5 + spec;\n    }\n    \n    vec3 lit = vec3(lm) * lcol2 + lcol1 * (sn.y * 0.5 + 0.5);\n    \n    float edge = 1.0 - 1.0 / (1.0 + fd * 100.0);\n    \n    vec3 fc = mix(lit * tex, lcol1, edge) * ao;\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}