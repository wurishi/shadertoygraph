{"ver":"0.1","info":{"id":"sssBRX","date":"1645156827","viewed":105,"name":"smooth abs test 2","username":"gaz","description":"test","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["smoothabs"],"hasliked":0,"parentid":"7dlBR2","parentname":"smooth abs test"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxd=80.0;\n\nvec3 rot(vec3 p, vec3 axis,float theta){\n\taxis=normalize(axis);\n\treturn mix(axis*dot(p,axis),p,cos(theta))+sin(theta)*cross(p,axis);\n}\n\n// reference https://corollary2525.hatenablog.com/entry/2020/07/25/221823\nfloat smoothAbs(float x, float k){\n    float a=exp(k*x);\n    return log(a+1./a)/k;\n}\n\n/*\n// reference https://twitter.com/Kinakomoti2357/status/1493967388760752131\nfloat smoothAbs(float x, float k){\n    k=exp(k*x);\n    return (x*k-x/k)/(k+1./k);\n}\n*/\n\nfloat smoothMin(float a, float b, float k){\n    return (a+b-smoothAbs(a-b,k))*.5;\n}\n\nfloat smoothMax(float a, float b, float k){\n    return (a+b+smoothAbs(a-b,k))*.5;\n}\n\n// Add in response to comments\nfloat smoothAbsStd(float x, float k){\n    return sqrt(x*x+k);\n}\n\nfloat smoothMinStd(float a, float b, float k){\n    return (a+b-smoothAbsStd(a-b,k))*.5;\n}\n\nfloat smoothMaxStd(float a, float b, float k){\n    return (a+b+smoothAbsStd(a-b,k))*.5;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(vec3 p)\n{\n    float de0=p.y+2.5;\n    p=rot(p,normalize(vec3(1,1,0)),iTime);\n    float de1=length(p)-1.;\n    float de2=sdRoundBox(p,vec3(2,.1,.1),.1);\n    float de3=sdRoundBox(p,vec3(2,.1,.1).yxz,.1);\n    float k=mix(1.,8.,fract(sin(iTime*.3)));\n    return min(de0,smoothMinStd(smoothMin(de1,de2,k),de3,.05));\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvec3 doColor(vec3 p)\n{\n     return vec3(0.8,0.5,0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(2.5);\n    vec3 ta = vec3(0);\n    vec3 rd = normalize(vec3(uv,2.0));\n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,vec3(0,1,0)));\n    vec3 v = cross(u,w);\n    rd = mat3(u,v,w) * rd;\n    vec3 col= vec3(0.05,0.05,0.1);\n    float t=march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n    \tvec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(5,5,1);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n    \tfloat sha = min(1.,calcShadow( lightPos, -li, len )+.8);\n        col *= max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn;\n    \tcol*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.3,.3,.3)*pow(clamp(dot(reflect(rd,n),li),0.,1.),80.);\n    }\n    fragColor.xyz = col;\n}\n\n     ","name":"Image","description":"","type":"image"}]}