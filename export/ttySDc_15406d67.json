{"ver":"0.1","info":{"id":"ttySDc","date":"1583737794","viewed":308,"name":"Tileable Rough Rocks 1","username":"elci","description":".","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","rocks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rock( vec2 f, float r ){\n    f -= (FractalGNoise(f)-0.5) * 0.2;\n\tfloat co = cos(r), si = sin(r);\n    f *= mat2(co,-si,si,co);\n\tfloat v = smoothstep(0.3, 0.00, length(max(vec2(0),abs(f)-0.1)));\n\treturn min( v, max(0.0, f.y+0.6) );\n}\nfloat rocks( vec2 p, float ts ){\n    float v = 0.0;\n\tfor( float i = 3.0, d = 1.0; i < 25.0; i++, d *= 0.9 ){\n\t\tvec2 f = p*i;\n\t\tvec2 r = Hash2( floor(f), i*ts );\n\t\tv = max(v, rock( fract(f)-0.5, r.x*6.2831853071 ) * (0.75 + d) * r.y );\n\t\tp += i*0.1;\n\t}\n    return v;\n}\nfloat cracks( vec2 p ){\n\tvec4 n = FractalVNoise4(p);\n\tp += n.xy*0.15;\n\tfloat v1 = VoronoiEdge_2x2(p) + pow(n.z, 7.0);\n\tfloat v2 = VoronoiEdge_2x2(p+3.3) + pow(n.w, 7.0);\n    return smoothstep(0.1, 0.01, 1.0 - pow(1.0-min(v1, v2), 9.0));\n}\nfloat specs( vec2 p, float ts ){\n    float v = 0.0;\n    for( float i = 0.0; i < 70.0; i += 1.0 ){\n\t\tfloat s = 10.0+i;\n    \tv = max(v, GNoise(p*s, s*ts) );\n\t}\n    return max(0.0, v-0.5);\n}\n\nvec3 color( vec2 p, float ts, vec4 n ){\n    //return vec3(1);\n    //return n.rgb;\n\tvec3 col;\n    col += vec3(0.3,0.4,0.4) * GNoise(p + n.xy*5.0, ts);\n    col += vec3(0.6,0.4,0.3) * GNoise(p + n.zw*5.0, ts);\n    return col;\n}\n\nvec3 surf( vec2 p, float ts ){\n\tfloat v;\n\tvec4 n = FractalVNoise4(p, ts); // some generic fractal noise\n\n    float r = rocks(p, ts);\n\tr = smoothstep(-0.5,0.8,r*0.45); // flatten rocks a bit\n\n\tfloat s = specs(p, ts);\n   \tv = mix(r, s, smoothstep(0.55,0.45,r)); // mix rock and pebble layers\n\tv -= 0.8 * pow(s*1.6*r, 4.0) * n.x; // add pebble contours\n\n\tfloat c = cracks(p*3.0); // edge fade\n\tc *= sqFade(mod(p,1.0), 0.05); // fade tile edges for cracks\n\tv -= c*0.08; // add cracks\n\n\tvec3 col = color(p*10.0, ts*10.0, n);\n    //return col;\n   \tcol = mix(vec3(1.0), col, r); // color the rock plates more than the pebbles\n\tcol *= pow(v, 1.4); // apply our final height value\n\treturn col*1.5;\n}\n\nvoid mainImage( out vec4 oFragColor, in vec2 fragCoord ){\n    vec2 uv = (gl_FragCoord.xy-iResolution.xy*0.5)/iResolution.x; // centered uv\n\tuv += iTime*0.05;\n\tfloat ts = 1.0;\n\tuv *= 2.0;\n\tuv = mod(uv,ts); // forced uv tiling, not required.\n\n\tvec3 col = surf(uv, ts);\n    \n\tcol -= smoothstep(1.0/iResolution.y, 0.0, min(abs(uv.x-0.5),abs(uv.y-0.5))) * max(0.0,sin(iTime)); // bars\n    oFragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 Hash2(vec2 p, float scale){\n\tp = mod(p, scale) + scale; // tiling + offsetting\n    return fract(sin(vec2(\n\t\tdot(p,vec2(132.832, 242.391)),\n\t\tdot(p,vec2(269.552, 183.309))\n\t)) * (132.5473453+scale));\n}\nvec2 Hash2(vec2 p){ return Hash2(p, 0.0); }\nvec2 Hash2N(vec2 p){ return Hash2(p) * 2.0 - 1.0; }\n\nvec4 Hash4(vec2 p){\n    return fract(sin(vec4(\n\t\tdot(p,vec2(188.328, 322.251)),\n\t\tdot(p,vec2(277.521, 187.133)),\n\t\tdot(p,vec2(122.810, 221.021)),\n\t\tdot(p,vec2(213.367, 268.311))\n\t)) * 132.5473453);\n}\nvec4 VNoise4(in vec2 p){\n\tvec2 f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\treturn mix(\tmix( Hash4(p+vec2(0.0, 0.0)), Hash4(p+vec2(1.0, 0.0)), f.x ),\n\t\t\t\tmix( Hash4(p+vec2(0.0, 1.0)), Hash4(p+vec2(1.0, 1.0)), f.x ), f.y);\n}\nvec4 FractalVNoise4( vec2 p ){\n\tfloat s = 1.0;\n\tvec4 n;\n\tfor( float i = 0.0; i < 10.0; i++ ){\n\t\tvec2 v = p*s + i*10.0;\n\t\tn += VNoise4(v);\n\t\ts *= 1.5;\n\t}\n\treturn n * 0.1;\n}\nfloat GNoise(vec2 p){\n    vec2 f = fract(p);\n    p = floor(p);\n\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( Hash2N(p + vec2(0.0,0.0)), f - vec2(0.0,0.0) ),\n                     dot( Hash2N(p + vec2(1.0,0.0)), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( Hash2N(p + vec2(0.0,1.0)), f - vec2(0.0,1.0) ),\n                     dot( Hash2N(p + vec2(1.0,1.0)), f - vec2(1.0,1.0) ), u.x), u.y) + 0.5;\n}\nfloat FractalGNoise( vec2 p ){\n\tfloat s = 1.0, n;\n\tfor( float i = 0.0; i < 10.0; i++ ){\n\t\tvec2 v = p*s + i*10.0;\n\t\tn += GNoise(v);\n\t\ts *= 1.5;\n\t}\n\treturn n * 0.1;\n}\n\n// fake edges, for real voronoi edges check out\n// https://iquilezles.org/articles/voronoilines\nfloat VoronoiEdge_2x2(in vec2 p){\n\tvec2 f = fract(p);\n    p = floor(p);\n\tvec2 r = vec2(4.0);\n\tfor( float xo = 0.0; xo <= 1.0; xo++ )\n\tfor( float yo = 0.0; yo <= 1.0; yo++ ){\n\t\tvec2 h = Hash2(p+vec2(xo,yo));\n\t\th *= 0.4; // limit point deviation\n\t\tfloat d = length( f - (vec2(xo,yo)+h) );\n\t\tif( d < r.x ) r = vec2( d, r.x );\n\t\telse if( d < r.y ) r.y = d;\n\t}\n\treturn r.y-r.x;\n}\n\nvec2 Hash2N(vec2 p, float s){ return Hash2(p, s) * 2.0 - 1.0; }\nfloat GNoise(vec2 p, float s){\n    vec2 f = fract(p);\n    p = floor(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( Hash2N(p + vec2(0.0,0.0), s), f - vec2(0.0,0.0) ),\n                     dot( Hash2N(p + vec2(1.0,0.0), s), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( Hash2N(p + vec2(0.0,1.0), s), f - vec2(0.0,1.0) ),\n                     dot( Hash2N(p + vec2(1.0,1.0), s), f - vec2(1.0,1.0) ), u.x), u.y) + 0.5;\n}\nvec4 Hash4(vec2 p, float s){ // scale aware 2x4 hash\n\tconst vec4 k = vec4(122.810, 188.328, 268.311, 322.251);\n\tp = mod(p, s) + s; // tiling + offsetting\n    return fract(sin(vec4(dot(p,k.xy), dot(p,k.zw), dot(p,k.yx), dot(p,k.wz)))\n\t\t* (132.5473453+s));\n}\nvec4 VNoise4(in vec2 p, float s){\n\tvec2 f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\treturn mix(\tmix( Hash4(p+vec2(0.0, 0.0), s), Hash4(p+vec2(1.0, 0.0), s), f.x ),\n\t\t\t\tmix( Hash4(p+vec2(0.0, 1.0), s), Hash4(p+vec2(1.0, 1.0), s), f.x ), f.y);\n}\nvec4 FractalVNoise4( vec2 p, float ts ){\n\tfloat s = 1.0;\n\tvec4 n;\n\tfor( float i = 0.0; i < 10.0; i++ ){\n\t\tvec4 v = VNoise4( p*s, s*ts );\n\t\tn += v;\n\t\ts *= 2.0;\n\t}\n\treturn n*0.1;\n}\n\nfloat sqFade( vec2 f, float v ){\n\tf = abs(f-0.5);\n\treturn smoothstep(0.5, 0.5-v, max(f.x,f.y));;\n}\n","name":"Common","description":"","type":"common"}]}