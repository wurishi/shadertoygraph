{"ver":"0.1","info":{"id":"ctfBRr","date":"1692706246","viewed":63,"name":"Path Biarc SDF","username":"TheTurk","description":"Distance function for a biarc, a smooth curve that is formed by two circular arcs, that can be used as a building block to create complex shapes.\nOther path distance functions:\n[url]https://www.shadertoy.com/playlist/scBBRD[/url]","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","bezier","beziercurve","spline","distance","curve","path","arc","shape","primitive","odd","even","biarc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float arc(vec2 position, vec2 start, vec2 startTangent, vec2 end) {\n    vec2 midpoint = (start + end) * 0.5;\n    vec2 bisector = start - end;\n    bisector = vec2(-bisector.y, bisector.x);\n    float t = dot(start - midpoint, startTangent) / dot(bisector, startTangent);\n    vec2 center = midpoint + bisector * t;\n    position -= center;\n    vec2 a = start - center;\n    vec2 b = end - center;\n    bool m = a.x * b.y < a.y * b.x;    \n    bool s1 = position.x * a.y < position.y * a.x;\n    bool s2 = position.x * b.y < position.y * b.x; \n    // even-odd rule\n    float s = 1.0;\n    float radius = length(start - center);\n    float c = radius * radius - position.y * position.y;\n    if (c > 0.0) {\n        c = sqrt(c);\n        bool s1 = -c * a.y < position.y * a.x;\n        bool s2 = -c * b.y < position.y * b.x;\n        bool s3 = c * a.y < position.y * a.x;\n        bool s4 = c * b.y < position.y * b.x;\n        if (position.x < -c && (s1 != m && s2 == m)) {\n            s = -s;\n        }\n        if (position.x < c && (s3 != m && s4 == m)) {\n            s = -s;\n        }\n    }\n    if (s1 != m && s2 == m) {\n       return abs(length(position) - radius) * s;\n    }\n    vec2 p1 = position - a;\n    vec2 p2 = position - b;\n    float d = sqrt(min(dot(p1, p1), dot(p2, p2)));\n    return d * s;\n}\n\n/*\nconstructs an biarc given 3 points of two intersecting lines, which will \nbe tangent to the biarc. the end point of the arc is set to currentPoint \nso that it can be used to continue the contour. the sign of the \ndistance field is computed using the even-odd rule and determines \nwhether a point lies inside (negative sign) or outside (positive \nsign) a given shape.\n*/\n\nfloat biarc(vec2 position, inout vec2 currentPoint, vec2 controlPoint, vec2 end) {\n    vec2 tangent1 = controlPoint - currentPoint;\n    vec2 tangent2 = controlPoint - end;\n    float a = length(end - controlPoint);\n    float b = length(currentPoint - end);\n    float c = length(controlPoint - currentPoint);\n    vec2 incenter = (currentPoint * a + controlPoint * b + end * c) / (a + b + c);\n    float d1 = arc(position, currentPoint, tangent1, incenter);\n    float d2 = arc(position, end, tangent2, incenter);\n    float d = min(abs(d1), abs(d2));\n    float s = sign(d1 * d2);\n    currentPoint = end;\n    return d * s;\n}\n\nfloat segment(vec2 position, vec2 start, vec2 end) {\n    position = position - start;\n    end = end - start;\n    float t = min(max(dot(position, end) / dot(end, end), 0.0), 1.0);\n    return length(position - end * t);\n}\n\n// example\nfloat egg(vec2 position, float halfWidth, float height1, float height2) {\n    position.y -= (height1 - height2) * 0.5;\n    vec2 currentPoint = vec2(0.0, -height1);\n    float d1 = biarc(position, currentPoint, vec2(-halfWidth, -height1), vec2(-halfWidth, 0.0));\n    float d2 = biarc(position, currentPoint, vec2(-halfWidth, height2), vec2(0.0, height2));\n    float d3 = biarc(position, currentPoint, vec2(halfWidth, height2), vec2(halfWidth, 0.0));\n    float d4 = biarc(position, currentPoint, vec2(halfWidth, -height1), vec2(0.0, -height1));\n    float d = min(min(min(abs(d1), abs(d2)), abs(d3)), abs(d4));\n    float s = sign(d1 * d2 * d3 * d4);\n    return d * s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 point1 = vec2(1.3, 0.9) * cos((iTime + 63.0) * 0.5 + vec2(0.0, 5.0));\n    vec2 point2 = vec2(1.3, 0.9) * cos((iTime + 63.0) * 0.6 + vec2(3.0, 4.0));\n    vec2 point3 = vec2(1.3, 0.9) * cos((iTime + 63.0) * 0.7 + vec2(2.0, 0.0));\n    vec2 currentPoint = point1;\n    float d = biarc(position, currentPoint, point2, point3);\n    // d = egg(position, 0.4, 0.4, 0.6); // example\n    \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n    color *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d);\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.003) * iResolution.y));\n    float d1 = min(segment(position, point1, point2), segment(position, point3, point2)) - (1.0 / iResolution.y);\n    float d2 = length(position - point1) - (12.0 / iResolution.y);\n    float d3 = length(position - point3) - (12.0 / iResolution.y);\n    float d4 = length(position - point2) - (12.0 / iResolution.y);\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d1 * iResolution.y));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d2 * iResolution.y));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d3 * iResolution.y));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d4 * iResolution.y));\n    if (iMouse.z > 0.0) {\n        vec2 mousePosition = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        vec2 currentPoint = point1;\n        float d = biarc(mousePosition, currentPoint, point2, point3);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 3.0, abs(length(position - mousePosition) - abs(d)) * iResolution.y - 1.0));\n    }\n    fragColor = vec4(color, 1.0);    \n}","name":"Image","description":"","type":"image"}]}