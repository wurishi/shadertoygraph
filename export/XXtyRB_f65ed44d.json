{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"mat3 rot(vec3 angles) {\n    float cx = cos(angles.x), sx = sin(angles.x);\n    float cy = cos(angles.y), sy = sin(angles.y);\n    float cz = cos(angles.z), sz = sin(angles.z);\n\n    // Rotation around X-axis\n    mat3 rotX = mat3(\n        1.0, 0.0,  0.0,\n        0.0, cx,  -sx,\n        0.0, sx,   cx\n    );\n\n    // Rotation around Y-axis\n    mat3 rotY = mat3(\n        cy,  0.0, sy,\n        0.0, 1.0, 0.0,\n       -sy,  0.0, cy\n    );\n\n    // Rotation around Z-axis\n    mat3 rotZ = mat3(\n        cz, -sz, 0.0,\n        sz,  cz, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    // Combined rotation: Z * Y * X\n    return rotZ * rotY * rotX;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p); // Reflect into the first octant\n    p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\n\n    vec2 d = vec2(\n        length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),\n        p.z - h.y\n    );\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat hollowHex(vec3 p, vec2 h) {\n    float outer = sdHexPrism(p, h);\n    float inner = sdHexPrism(p, vec2(h.x * 0.95, h.y));\n    return inner <= 0.001 ? 1000. : outer; // Return large value if inside hollow\n}\n\nfloat hollowHexes(vec3 p, vec2 h, out float hexID) {\n    float mn = 1000.; // Minimum distance\n    hexID = 0.;\n    for (int i = 0; i < 10; i++) {\n        float hexDist = hollowHex(p, vec2(mod(iTime + float(i) / 15.0, 0.9), h.y));\n        if (hexDist < mn) {\n            mn = hexDist;\n            hexID = float(i); // Use the hexagon index as ID\n        }\n    }\n    return mn;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out float hexID) {\n    float t = 0.0; // Ray parameter\n    hexID = -1.;\n    for (int i = 0; i < 64; i++) {\n        vec3 pos = ro + t * rd; // Current position along the ray\n        float d = hollowHexes(\n            rot(vec3(0.2 * sin(1.0 * iTime), 0.2 * sin(iTime), 2.0 * iTime)) * pos,\n            vec2(0.1, 0.00001),\n            hexID\n        ); // Transform position and scale\n\n        if (d < 0.001) return t; // Hit threshold\n        t += d;                  // Advance by step size\n        if (t > 10.0) return t;  // Stop if beyond max distance\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy - 0.5; // Normalize coordinates\n    uv.x *= iResolution.x / iResolution.y; // Adjust for aspect ratio\n\n    vec3 ro = vec3(0.0, 0.0, -1.0);  // Camera position\n    vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction\n\n    float hexID;\n    float dist = rayMarch(ro, rd, hexID);\n\n    // Color based on hex ID\n    vec3 color = vec3(0.0);\n    if (dist < 10.0) {\n        float hue = mod(hexID * 0.1, 1.0); // Hue based on hexID\n        color = vec3(hue, 0.2, 0.5);      // RGB based on hue\n    }\n\n\n    fragColor = vec4(color, 1.0); // Output final color\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XXtyRB","date":"1735279140","viewed":51,"name":"weird hexagon","username":"mrjonjonjon","description":"spinning hexagons","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hexagon"],"hasliked":0,"parentid":"","parentname":""}}