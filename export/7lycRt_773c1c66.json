{"ver":"0.1","info":{"id":"7lycRt","date":"1662320286","viewed":142,"name":"platonic_solids23","username":"edwardbraed","description":"Platonic solids, just for fun..","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["cube","tetrahedron","icosahedron","dodecahedron","octahedron","platonic","solids","geo","wire","hexahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BACK_COLOR vec3(0.0, 0.5, 0.8)\n\n#define gray(rgb) (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114)\n\nvec3 blur(sampler2D tex, vec2 uv, vec2 k)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    vec3 avg = vec3(0.0);\n    vec2 hk = k * 0.5;\n    for(float x = 0.0 - hk.x; x < hk.x; x += 1.0)\n    {\n        for(float y = 0.0 - hk.y; y < hk.y; y += 1.0)\n            avg += texture(tex, uv + s * vec2(x,y)).rgb;\n    }\n    return avg / (k.x * k.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float bc = mix(4.0, 6.0, sign(iResolution.x / 420.0 - 1.0));\n    \n    float cg = (1.0 - distance(uv, vec2(0.5, 0.2))) * 0.65;\n    vec3 rgb = blur(iChannel0, uv, vec2(bc)) * 12.0;\n    vec3 col = cg * mix(BACK_COLOR, rgb, sign(gray(rgb)));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS_MARCH 54\n#define WIRE_WIDTH 0.002\n#define ORBIT_DISABLE\n\n//thanks: https://www.shadertoy.com/view/ll33zS\nvec3 getCamera(vec3 z, vec3 p)\n{\n\tvec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    return mat3(x, cross(z, x), z) * p;\n}\n\n//sdLine, thanks: iq\nfloat sdl(vec3 p, vec3 a, vec3 b, float m)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return min(length( pa - ba*h ) - WIRE_WIDTH, m);\n}\n\n//-----------------------------------------------------------------\n\nbool tetra(vec3 p, float s, vec3 t, inout float sd) // Tetrahedron\n{\n    vec3 a = vec3( 0.000, -0.070,  0.175) * s - t;\n    vec3 b = vec3( 0.147, -0.070, -0.084) * s - t;\n    vec3 c = vec3(-0.147, -0.070, -0.084) * s - t;\n    vec3 d = vec3( 0.000,  0.119,  0.000) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, b, c, sd);\n    sd = sdl(p, c, d, sd); sd = sdl(p, d, a, sd);\n    sd = sdl(p, c, a, sd); sd = sdl(p, d, b, sd);\n    return sd < 0.001;\n}\n\nbool octa(vec3 p, float s, vec3 t, inout float sd) // Octahedron\n{\n    vec3 a = vec3( 0.10,  0.00,  0.10) * s - t;\n    vec3 b = vec3( 0.10,  0.00, -0.10) * s - t;\n    vec3 c = vec3(-0.10,  0.00, -0.10) * s - t;\n    vec3 d = vec3(-0.10,  0.00,  0.10) * s - t;\n    vec3 e = vec3( 0.00,  0.14,  0.00) * s - t;\n    vec3 f = vec3( 0.00, -0.14,  0.00) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, b, c, sd);\n    sd = sdl(p, c, d, sd); sd = sdl(p, d, a, sd);\n    sd = sdl(p, a, e, sd); sd = sdl(p, b, e, sd);\n    sd = sdl(p, c, e, sd); sd = sdl(p, d, e, sd);\n    sd = sdl(p, a, f, sd); sd = sdl(p, b, f, sd);\n    sd = sdl(p, c, f, sd); sd = sdl(p, d, f, sd);\n    return sd < 0.001;\n}\n\nbool hexa(vec3 p, float s, vec3 t, inout float sd) // Hexahedron (cube)\n{\n    vec3 a = vec3(-0.10,  0.10,  0.10) * s - t;\n    vec3 b = vec3(-0.10,  0.10, -0.10) * s - t;\n    vec3 c = vec3( 0.10,  0.10, -0.10) * s - t;\n    vec3 d = vec3( 0.10,  0.10,  0.10) * s - t;\n    vec3 e = vec3(-0.10, -0.10,  0.10) * s - t;\n    vec3 f = vec3(-0.10, -0.10, -0.10) * s - t;\n    vec3 g = vec3( 0.10, -0.10, -0.10) * s - t;\n    vec3 h = vec3( 0.10, -0.10,  0.10) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, b, c, sd);\n    sd = sdl(p, c, d, sd); sd = sdl(p, d, a, sd);\n    sd = sdl(p, e, f, sd); sd = sdl(p, f, g, sd);\n    sd = sdl(p, g, h, sd); sd = sdl(p, h, e, sd);\n    sd = sdl(p, a, e, sd); sd = sdl(p, b, f, sd);\n    sd = sdl(p, c, g, sd); sd = sdl(p, d, h, sd);\n    return sd < 0.001;\n}\n\nbool icos(vec3 p, float s, vec3 t, inout float sd) // Icosahedron\n{\n    vec3 a = vec3(-0.108,  0.066,  0.078) * s - t;\n    vec3 b = vec3( 0.040,  0.066,  0.127) * s - t;\n    vec3 c = vec3( 0.133,  0.066,  0.000) * s - t;\n    vec3 d = vec3( 0.040,  0.066, -0.127) * s - t;\n    vec3 e = vec3(-0.108,  0.066, -0.078) * s - t;\n    vec3 f = vec3(-0.133, -0.066,  0.000) * s - t;\n    vec3 g = vec3(-0.040, -0.066,  0.127) * s - t;\n    vec3 h = vec3( 0.108, -0.066,  0.078) * s - t;\n    vec3 i = vec3( 0.108, -0.066, -0.078) * s - t;\n    vec3 j = vec3(-0.040, -0.066, -0.127) * s - t;\n    vec3 k = vec3( 0.000,  0.150,  0.000) * s - t;\n    vec3 l = vec3( 0.000, -0.150,  0.000) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, b, c, sd);\n    sd = sdl(p, c, d, sd); sd = sdl(p, d, e, sd);\n    sd = sdl(p, e, a, sd); sd = sdl(p, f, g, sd);\n    sd = sdl(p, g, h, sd); sd = sdl(p, h, i, sd);\n    sd = sdl(p, i, j, sd); sd = sdl(p, j, f, sd);\n    sd = sdl(p, a, f, sd); sd = sdl(p, b, g, sd);\n    sd = sdl(p, c, h, sd); sd = sdl(p, d, i, sd);\n    sd = sdl(p, e, j, sd); sd = sdl(p, a, g, sd);\n    sd = sdl(p, b, h, sd); sd = sdl(p, c, i, sd);\n    sd = sdl(p, d, j, sd); sd = sdl(p, e, f, sd);\n    sd = sdl(p, a, k, sd); sd = sdl(p, b, k, sd);\n    sd = sdl(p, c, k, sd); sd = sdl(p, d, k, sd);\n    sd = sdl(p, e, k, sd); sd = sdl(p, f, l, sd);\n    sd = sdl(p, g, l, sd); sd = sdl(p, h, l, sd);\n    sd = sdl(p, i, l, sd); sd = sdl(p, j, l, sd);\n    return sd < 0.001;\n}\n\nbool dode(vec3 p, float s, vec3 t, inout float sd) // Dodecahedron\n{\n    vec3 a = vec3( 0.000,  0.052,  0.139) * s - t;\n    vec3 b = vec3( 0.085,  0.085,  0.085) * s - t;\n    vec3 c = vec3(-0.085,  0.085,  0.085) * s - t;\n    vec3 d = vec3( 0.000, -0.052,  0.139) * s - t;\n    vec3 e = vec3( 0.085, -0.085,  0.085) * s - t;\n    vec3 f = vec3(-0.085, -0.085,  0.085) * s - t;\n    vec3 g = vec3( 0.000,  0.052, -0.139) * s - t;\n    vec3 h = vec3( 0.085,  0.085, -0.085) * s - t;\n    vec3 i = vec3(-0.085,  0.085, -0.085) * s - t;\n    vec3 j = vec3( 0.000, -0.052, -0.139) * s - t;\n    vec3 k = vec3( 0.085, -0.085, -0.085) * s - t;\n    vec3 l = vec3(-0.085, -0.085, -0.085) * s - t;\n    vec3 m = vec3(-0.052,  0.139,  0.000) * s - t;\n    vec3 n = vec3( 0.052,  0.139,  0.000) * s - t;\n    vec3 o = vec3( 0.052, -0.139,  0.000) * s - t;\n    vec3 w = vec3(-0.052, -0.139,  0.000) * s - t;\n    vec3 q = vec3(-0.139,  0.000,  0.052) * s - t;\n    vec3 r = vec3(-0.139,  0.000, -0.052) * s - t;\n    vec3 u = vec3( 0.139,  0.000,  0.052) * s - t;\n    vec3 v = vec3( 0.139,  0.000, -0.052) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, a, c, sd);\n    sd = sdl(p, d, e, sd); sd = sdl(p, d, f, sd); \n    sd = sdl(p, a, d, sd); sd = sdl(p, g, h, sd); \n    sd = sdl(p, g, i, sd); sd = sdl(p, j, k, sd); \n    sd = sdl(p, j, l, sd); sd = sdl(p, g, j, sd);\n    sd = sdl(p, m, n, sd); sd = sdl(p, o, w, sd);\n    sd = sdl(p, m, c, sd); sd = sdl(p, n, b, sd);\n    sd = sdl(p, o, e, sd); sd = sdl(p, w, f, sd);\n    sd = sdl(p, m, i, sd); sd = sdl(p, n, h, sd);\n    sd = sdl(p, o, k, sd); sd = sdl(p, w, l, sd);\n    sd = sdl(p, m, i, sd); sd = sdl(p, n, h, sd);\n    sd = sdl(p, o, k, sd); sd = sdl(p, w, l, sd);\n    sd = sdl(p, b, u, sd); sd = sdl(p, c, q, sd);\n    sd = sdl(p, h, v, sd); sd = sdl(p, i, r, sd);\n    sd = sdl(p, e, u, sd); sd = sdl(p, f, q, sd);\n    sd = sdl(p, k, v, sd); sd = sdl(p, l, r, sd);\n    sd = sdl(p, q, r, sd); sd = sdl(p, u, v, sd);\n    return sd < 0.001;\n}\n\nfloat map(vec3 p, out vec3 color)\n{   \n    float sd = 10000.0;\n    #ifdef ORBIT_DISABLE\n        vec3 rp1 = vec3(1.0, 0.0, 0.0);\n        vec3 rp2 = vec3(1.0, 0.0, 0.0);\n    #else\n        vec3 rp1 = vec3(sin(iTime), 0.0, cos(iTime));\n        vec3 rp2 = vec3(sin(iTime * 1.2), 0.0, cos(iTime * 1.2));\n    #endif\n    if(tetra(p, 0.7, rp1 * 0.5, sd))\n        color = vec3(0.9, 0.4, 0.0);\n    else if(octa(p, 0.7, rp2 * 0.25, sd))\n        color = vec3(0.5, 0.5, 0.7);\n    else if(hexa(p, 0.7, vec3(0.0), sd))\n        color = vec3(0.2, 0.8, 0.2);\n    else if(icos(p, 0.7, rp2 * -0.25, sd))\n        color = vec3(0.0, 0.4, 1.0);\n    else if(dode(p, 0.7, rp1 * -0.5, sd))\n        color = vec3(0.6, 0.0, 0.6);\n    return sd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec3 rd = vec3(mix(mix(dBl, dBr, uv.x),\n                       mix(dTl, dTr, uv.x), uv.y),\n                   1.0) / 4.0;\n    rd.x *= iResolution.x / iResolution.y;\n    \n    // origin direction (or pseudo camera position)\n    float angl = iTime * 0.5;\n    if(iMouse.z > 0.9)\n    {\n        vec2 mPos = iMouse.xy / iResolution.xy;\n        angl = -mPos.x * 20.0 * (1.0 - min(mPos.y + 0.3, 1.0));\n    }\n    \n    vec3 ro = vec3(sin(angl), 0.6, cos(angl));\n    rd = getCamera(ro, vec3(rd.xy, -0.45));\n    \n    // raymarching\n    vec3 r = vec3(0.0);\n    float t = 0.0;\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos = ro + rd * t;\n        vec3 rgb = vec3(0.0);\n        float sd = map(pos, rgb);\n        if(sd < 0.001)\n        {    \n            r = rgb;\n            break;\n        }\n        t += sd;\n    }\n    \n    // Output to screen\n    fragColor = vec4(r, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}