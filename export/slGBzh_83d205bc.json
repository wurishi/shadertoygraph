{"ver":"0.1","info":{"id":"slGBzh","date":"1664019218","viewed":176,"name":"Haru86_Ray_PulseTest","username":"Haru86_","description":"Haru86_Ray_PulseTest","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define resolution iResolution\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n#define time iTime\n\n/*precision mediump float;\nuniform float time;\nuniform vec2 resolution;*/\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define PI 3.14159265\n\nstruct MapResult\n{\n  float d; // Distance\n  int mt; // MaterialType\n              // 0 : Debug\n              // 1 : PBR\n              // 2 : Unlit Emission\n  float r; // Roughtness\n  float m; // Metallic\n  float h; // HSVColor„ÅÆH\n  float e; // Emissive\n};\n\nvoid CompareMap(inout MapResult mr,float d,int mt,float r,float m,float h,float e,bool IsMin)\n{\n  if(IsMin)\n  {\n    if(d<mr.d) mr = MapResult(d,mt,r,m,h,e);\n  }\n  else\n  {\n    if(d>mr.d) mr = MapResult(d,mt,r,m,h,e);\n  }\n}\n//////////////////////////////\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// https://www.shadertoy.com/view/3dd3WB\n// https://www.shadertoy.com/view/fl3SRB\nfloat smoothPulse(float start, float end, float period, float smoothness, float t) {\n    float h = abs(end - start) * 0.5;\n    t = mod(t, period);\n    return smoothstep(start, start + h * smoothness, t)\n        - smoothstep(end - h * smoothness, end, t);\n}\n\nfloat cube(vec3 p,vec3 s)\n{\n    return length(max(vec3(0.0),abs(p)-s));\n}\n\nvec3 VecFold(vec3 p,vec3 n)\n{\n    p-=2.0*min(0.0,dot(p,n))*n;\n    return p;\n}\n\nvec2 pmod(vec2 p,float r)\n{\n  float a = PI/r - atan(p.x,p.y);\n  float n = 2.0*PI/r;\n  a = floor(a/n)*n;\n  p*=rot(a);\n  return p;\n}\n\nvec2 movepmod(vec2 p,float r,float t)\n{\n  float a = PI/r - atan(p.x,p.y);\n  float n = 2.0*PI/r;\n  a = floor(a/n)*n;\n  p*=rot(a+t);\n  return p;\n}\n\nvec3 SubCubeIFS(vec3 p,inout bool IsMin)\n{\n  vec3 pos = p;\n\n  pos = abs(p);\n  pos.xy=pmod(pos.xy,5.0);\n\n  for(float i=0.0;i<5.0;i++)\n  {\n    /*pos = VecFold(pos,\n      normalize(vec3(\n          rand(vec2(i,pos.x)),\n          rand(vec2(i,pos.y)),\n          rand(vec2(i,pos.z))\n      ))\n    );*/\n    pos.xz = abs(pos.xz) -0.5;\n    pos.xz*=rot(0.125);\n\n    pos.yz = abs(pos.yz) -0.15;\n    pos.yz*=rot(0.5);\n\n    pos.xy = abs(pos.xy) -0.15;\n    pos.xy*=rot(0.75);\n\n\n  }\n\n  //IsMin = true;\n  //IsMin = ( fract(pos.z*10.1) < 0.01 );\n\n  return pos;\n}\n\nfloat CalEmissive(vec3 p)\n{\n  // Emissive\n  vec3 ds = vec3(1.0); // DomainSize\n  vec3 di = floor(p.xyz*ds); // DomainID\n  vec3 np = vec3(1.0,1.0,1.0); // NumOfPulse\n  #ifndef PulseDebug\n  np=vec3(10.0);\n  #endif\n  float pz = smoothPulse(0.0, 0.6, 1.0, 0.5, 0.25 * p.z*np.z+sin(di.x*5.0) );\n  float py = smoothPulse(0.0, 0.6, 1.0, 0.5, 0.25 * p.y*np.y+sin(di.y*5.0) );\n  float px = smoothPulse(0.0, 0.6, 1.0, 0.5, 0.25 * p.x*np.x+sin(di.z*5.0) );\n  float emi = smoothPulse(0.2, 0.25, 1.0, 0.5, pz + py + px + p.x )\n      /**clamp(sin(time+p.z+(di.x+di.y)*10.0 ),0.0,1.0)*/;\n  //emi = px;\n  //emi = pz;\n\n  return emi;\n}\n\n#define ROTSPEED 3.0\n\nMapResult map(vec3 p)\n{\n  MapResult mr = MapResult(1000.0,0,0.0,1.0,0.0,0.0);\n\n  // BoxPlane\n  {\n    // Trsnsform\n//#define PulseDebug\n      //\n      vec3 lp = p;\n#ifdef PulseDebug\n      lp+=vec3(0.0,1.5,0.0);\n#else\n      //lp.xz*=rot(time);\n    /*  lp.xy*=rot(time);\n      lp.yz*=rot(time);\n      lp.xz*=rot(time);*/\n#endif\n\n#ifdef PulseDebug\n      CompareMap(mr,cube(lp,vec3(4.,0.1,10.0)),1,1.,1.,0.5,,true);\n#else\n      {\n        lp.z-=time*5.0;\n        float k = 2.85;\n        //float DomainZ = floor((lp.z-k*0.5)/k*0.5+0.5);\n        float DomainZ = floor((lp.z*2.0+k*0.5)/k*0.5+0.5);\n        float randD = rand(vec2(DomainZ*100.0,DomainZ))*2.0-1.0;\n\n        float rott =floor(time*ROTSPEED)+pow(fract(time*ROTSPEED),0.3);\n        lp.xy*=rot(sign(randD)*rott+ randD);\n        lp.xy=pmod(lp.xy,3.0);\n        lp = mod(lp,k)-k*0.5;\n        lp.xy=pmod(lp.xy,32.0);\n        lp.xz*=rot(PI/2.0);\n        //lp.xy*=rot(rott);\n\n        // Base Cube\n        {\n          float emi = CalEmissive(lp);\n          CompareMap(mr,cube(lp,vec3(1.0)),1,1.,1.,0.5,emi,true);\n          //CompareMap(mr,length(lp)-1.0 ,1,1.,1.,0.5,emi,true);\n        }\n\n        // SubCube\n        {\n          bool IsMin = false;\n          vec3 slp = SubCubeIFS(lp,IsMin);\n          float emi = CalEmissive(slp);\n          CompareMap(mr, cube(slp,vec3(0.25,2.0,0.25)),1,1.0,1.0,1.0,emi,IsMin);\n\n          //CompareMap(mr, cube(lp,vec3(0.25,0.25,1.1)),1,1.0,1.0,1.0,0.0,true);\n          //mr.d = max(-mr.d,cube(lp,vec3(0.25,0.25,1.1)));\n        }\n      }\n\n#endif\n  }\n\n  return mr;\n}\n\nvec3 gn(vec3 p)\n{\n  vec2 e = vec2(0.001,0.0);\n  return normalize(vec3(\n    map(p+e.xyy).d - map(p-e.xyy).d,\n    map(p+e.yxy).d - map(p-e.yxy).d,\n    map(p+e.yyx).d - map(p-e.yyx).d\n  ));\n}\n\n#define LOOPNUM 100.0\n#define DMIN 0.001\n#define TMAX 1000.0\n#define LightDir normalize(vec3(-1.0,-1.0,1.0))\n\nvec3 hsv2rgb2(vec3 c, float k) {\n    return smoothstep(0. + k, 1. - k,\n        .5 + .5 * cos((vec3(c.x, c.x, c.x) + vec3(3., 2., 1.) / 3.) * radians(360.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float r = 2.5;\n  vec2 st = (gl_FragCoord.xy*2.0-resolution.xy)/min(resolution.x,resolution.y);\n\n  float rott =floor(time*ROTSPEED)+pow(fract(time*ROTSPEED),0.3);\n  float rorrid = mod(rott,4.0);\n\n  vec3 ro = vec3(0.0,0.0,r);\n  if(rorrid>= 0.0&& rorrid<1.0)\n  {\n    ro = mix( vec3(0.0,0.0,r),vec3(0.5,-0.5,r),max(0.0,rorrid-0.0) ); // 0 - 1\n  }\n  else if(rorrid>= 1.0&& rorrid<2.0)\n  {\n    ro = mix( vec3(0.5,-0.5,-r),vec3(-0.5,0.5,r),max(0.0,rorrid-1.0) ); // 1 - 2\n  }\n  else if(rorrid>= 2.0&& rorrid<3.0)\n  {\n    ro = mix( vec3(-0.5,0.5,r),vec3(-0.5,0.5,0.0),max(0.0,rorrid-2.0) ); // 2 -3\n  }\n  else if(rorrid>= 3.0&& rorrid<4.0)\n  {\n    ro = mix( vec3(-0.5,0.5,0.0),vec3(0.0,0.0,r),max(0.0,rorrid-3.0) ); // 3 -1\n  }\n  \n  vec3 ta=vec3(0.0),cdir=normalize(ta-ro);\n  vec3 cside=normalize(cross(vec3(0.0,1.0,0.0),cdir));\n  vec3 cup=normalize(cross(cdir,cside));\n  vec3 rd=normalize(cside*st.x+cup*st.y+1.0*cdir);\n  vec3 col=hsv2rgb2(mod(rd,1.0),2.2);\n\n  MapResult mr;\n  float t=0.,d,pi,acc;\n  for(float i=0.0;i<LOOPNUM;i++)\n  {\n    mr = map(ro+rd*t);\n    pi = i;\n    float ld =abs(mr.d);\n    if( t>10.0 && (ld<DMIN || t>TMAX) )break;\n    t+=min(0.1,ld);\n    acc+=exp(-100.0*ld);\n  }\n\n  if(abs(mr.d)<DMIN)\n  {\n\n    if(mr.mt == 1)\n    {\n      vec3 p = ro+rd*t;\n      col = hsv2rgb2(mod(p*0.1,1.0),2.2)*acc*0.25* 5./pi+mr.e*vec3(1.0)* 5./pi;\n\n      vec3 n = gn(ro+rd*t);\n      ro = ro+rd*t;\n      rd = reflect(rd,n);\n      t = 0.1,acc=0.0;\n      for(float i=0.0;i<LOOPNUM*0.5;i++)\n      {\n        mr = map(ro+rd*t);\n        pi = i;\n        float ld =abs(mr.d);\n        if( t>10.0 && (ld<DMIN || t>TMAX) )break;\n        t+=min(0.1,ld*0.5);\n        acc+=exp(-100.0*ld);\n      }\n      p = ro+rd*t;\n      vec3 refcol =hsv2rgb2(mod(p*0.1,1.0),2.2)*acc*0.025;\n      col += ((refcol.r+refcol.g+refcol.b)*0.333>0.0)? refcol : vec3(0.0);\n\n    }\n    else\n    {\n      vec3 n = gn(ro+rd*t);\n      col = vec3(exp(-1.0*t))*(n*0.5+0.5);\n    }\n  }\n  \n  col.r = pow(col.r,2.2);\n  col.g = pow(col.g,2.2);\n  col.b = pow(col.b,2.2);\n  \n  gl_FragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":" #define BPM 175.0\n #define PI 3.14159265\n \n #define saturate(i) clamp(i,-1.0,1.0)\n #define lofi(i,j) floor((i)/j)*j\n #define b2t(i) ((i)/BPM*60.0)\n \n #define calscale(r) 440.0*pow(2.0,(r)/12.0)\n #define scale(octave,note) calscale(octave*12.0+note)\n\n #define A 0.0\n #define B 2.0\n #define C 3.0\n #define D 5.0\n #define E 7.0\n #define F 8.0\n #define G 10.0\n #define rest -10000.0\n\n float rand(float time)\n{\n    return fract(sin(time*1e3)*1e6)-0.5;\n}\n\nvec2 kick( float t ) {\n    float phase = 45.0 * t - 6.0 * exp( -40.0 * t ) - 3.0 * exp( -400.0 * t );\n    float decay = exp( -3.0 * t );\n    return vec2( decay * sin( 2.0*PI * phase ) );\n}\n\nvec2 hihat(float _seed,float _dec){\n    return rand(_seed)*exp(-_dec)*vec2(1.0);\n}\n\nvec2 mainSound( int samp, float time ) {\n  \n    float t=time;\n    float beat=t*(BPM/60.0);\n    \n    vec2 s = vec2(0.0);\n    s+=kick(mod(beat,1.0));\n    s+=hihat( b2t(beat),pow(4.0,-8.0*b2t(mod(beat,0.5))) )\n        *pow(4.0,-8.0*b2t(mod(beat,1.0)));\n    \n    return saturate(s);\n}\n","name":"Sound","description":"","type":"sound"}]}