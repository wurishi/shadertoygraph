{"ver":"0.1","info":{"id":"ld3czS","date":"1519314936","viewed":639,"name":"Moonlight Sillyness","username":"stellabialek","description":"having some fun","likes":42,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","clouds","sky","volumetric","moon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CLOUDS_ON\n\n\nconst float STEPS = 120.0;\nconst float STEPSIZE = 0.05;\nconst float DRAWDIST = STEPS * STEPSIZE;\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 2.0 * PI;\n\nconst int OCTAVES = 3;\n\nstruct ray\n{\n\tvec3 o; //origin\n\tvec3 d;\t//direction\n};\n\nvec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution) \n{\n\tfloat fx = tan(radians(fov) / 2.0) / resolution.x;\n\tvec2 d = fx * (fragCoord * 2.0 - resolution);\n\tvec3 rayDir = normalize(vec3(d, 1.0));\n\treturn rayDir;\n}\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099 + .1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat rand(float seed)\n{\n\treturn fract(sin(seed) * 1231534.9);\n}\n\nfloat rand(vec2 seed) \n{ \n    return rand(dot(seed, vec2(12.9898, 783.233)));\n}\n\nfloat noise( in vec3 x )\n{\n\tx *= 2.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 p)\n{\n\tp *= 1.4;\n\tfloat f = 0.0;\n\tfloat weight = 0.5;\n\tfor(int i = 0; i < OCTAVES; ++i)\n\t{\n\t\tf += weight * noise( p );\n\t\tp.z -= iTime * float(i) * 0.5;\n\t\tweight *= 0.5;\n\t\tp *= 2.0;\n\t}\n\treturn f;\n}\n\nfloat density(vec3 p)\n{\n    p.y += 1.2;\n\tp.y += cos(p.x*1.4) * 0.2;\n\tp.y += cos(p.z)*0.1;\n    p *= 1.2;\n\tp.z += iTime * 0.4;\n\tfloat noise = fbm(p);\n\tfloat clouds = noise*1.5 - p.y - 1.3;\n\treturn clamp(clouds, 0.0, 1.0);\n}\n\nvec3 clouds(vec3 p, float d, float l, vec3 bg)\n{\n\tvec3 lPos = vec3(0,0, DRAWDIST*1.75);\n\tvec3 lDir = lPos - p;\n\n\tfloat dL = density(p + normalize(lDir) * 0.2);\n\tfloat dG = clamp(d - dL, 0.0, 1.0);\n\tdG *= 1.0 - smoothstep(2.0,8.0, length(lDir));\n\tdG *= 70.0;\n\tvec3 cL = vec3(0, 0.1, 0.1) + vec3(1.0) * dG;\n\tvec3 cA = mix( vec3(1.0, 1.0, 1.0), vec3(1.0)*0.01, d);\n\t\n\tfloat a = 0.2;\n\tfloat t = exp(-a * l);\t\n\treturn mix(bg, cL * cA, t);\n}\n\nfloat stars(vec2 uv, float amount, float radius)\n{\n\tuv = uv * amount;\n\tvec2 gridID = floor(uv);\n\tvec2 starPos = vec2(rand(gridID),rand(gridID+1.0));\n\tstarPos = (starPos - 0.5) * 2.0;\n\tstarPos = vec2(0.5) + starPos * (0.5 - radius * 2.0);\n\tfloat stars = distance(fract(uv), starPos);\n\tfloat size = rand(gridID)*radius;\n\tstars = 1.0 - smoothstep(size, size + radius, stars);\n\treturn stars;\n}\n\nfloat gradient(vec2 uv)\n{\n\tuv.x *= 0.8;\n\tuv *= 1.0 + sin(iTime*10.0) * 0.01;\n\tfloat g = clamp(1.0 - length(uv), 0.0, 1.0);\n\treturn clamp(g, 0.0, 1.0);\n}\n\nfloat circle(vec2 uv, float r)\n{\n\treturn length(uv)-r;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rotate(vec2 p, float angle)\n{\n\tmat2 mat = mat2(cos(angle),-sin(angle),\n\t\t\t\t\tsin(angle),cos(angle));\n\treturn p * mat;\n}\n\nfloat t(float scale, float k)\n{\n\tfloat t = sin(iTime * scale);\n\tt = (t + 1.0)/2.0;\n\tt = mix(t,smoothstep(0.0, 1.0, t),k);\n\tt = (t - 0.5)*2.0;\n\treturn t;\n}\n\nfloat ghost1(vec2 uv)\n{\n\tfloat time = iTime * 6.0;\n\tfloat t = t(6.0, 0.5);\n\n\tuv.x += 0.5;\n\tuv = rotate(uv, t*max(0.0, uv.y)*0.2);\n\tuv.y -= 0.4 + sin(time * 2.0) * 0.1 * smoothstep(-0.5, 1.5, uv.y);\n\tvec2 originalUV = uv;\n\t\t\n\tuv.x *= 1.0 + uv.y;\n\tuv.y += max(0.0, -uv.y*0.8); \t\n\tfloat body = circle(uv, 0.2); \n\t\n\tuv = originalUV;\n\tuv += vec2(-0.2, 0.2);\n\tuv = rotate(uv, -PI/4.0 + t*0.8*uv.x);\n\tuv *= vec2(0.4, 2.0);\n\tfloat arms = circle(uv, 0.1);\n\t\n\tuv = originalUV;\n\tuv += vec2(0.2, 0.2);\n\tuv = rotate(uv, PI/4.0 + t*0.8*(-uv.x));\n\tuv *= vec2(0.4, 2.0);\n\tarms = min(arms, circle(uv, 0.1));\n\t\n\tuv = originalUV;\n\tuv.x -= 0.01;\n\tuv.y += 0.05;\n\tuv.y *= 1.0 + cos(time*2.0)*0.4;\n\tfloat mouth = circle(uv, 0.02);\n\t\n\tuv = originalUV;\n\tuv.x -= 0.11;\n\tfloat eyeR = circle(uv, 0.02);\n\tuv.x += 0.2;\n\tfloat eyeL = circle(uv, 0.04);\n\t\n\tfloat d = body;\n\td = smin(arms,body, 0.1);\n\td = max(d, -eyeR);\n\td = max(d, -eyeL);\n\td = max(d, -mouth);\n\tfloat threshold = mix(0.04, 0.06, (0.5 +sin(iTime)*0.5));\n\td = 1.0 - smoothstep(-threshold, threshold, d);\t\n\treturn d;\n}\n\nfloat ghost2(vec2 uv)\n{\n\tuv.x -= 0.4;\t\n\tuv.y += t(6.0, 0.5)*0.2* smoothstep(-1.0, 0.0, uv.y);\n\tvec2 originalUV = uv; \n\t\n\tuv.x *= 1.0 + uv.y*0.4;\n\tuv.y *= mix(0.0, 1.0, smoothstep(-0.1, 0.0, uv.y));\n\tfloat body = circle(uv, 0.15);\n\t\n\tuv = originalUV;\n\tuv.x -= 0.06;\n\tfloat eyeR = circle(uv, 0.03);\n\tuv.x += 0.14;\n\tfloat eyeL = circle(uv, 0.025);\n\t\n\tfloat d = max(body,-eyeR);\n\td = max(d, -eyeL);\n\t\n\tfloat threshold = mix(0.04, 0.06, (0.5 +sin(iTime)*0.5));\n\td = 1.0 - smoothstep(-threshold, threshold, d);\n\td *= 0.6;\n\treturn d;\n}\n\nfloat ghosts(vec2 uv)\n{\t\n\tfloat d = ghost1(uv) + ghost2(uv);\n\treturn clamp(d, 0.0, 1.0);\n}\n\nvec3 tonemapping(vec3 color, float exposure, float gamma)\n{\n\tcolor *= exposure/(1. + color / exposure);\n\tcolor = pow(color, vec3(1. / gamma));\n\tfloat lum = 0.3*color.r + 0.6*color.g + 0.1*color.b;\n\tcolor = mix(color, color*color, 1.0 - smoothstep(0.0,0.4,lum));\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 res = vec2(max(iResolution.x, iResolution.y));\n\tvec2 uv = fragCoord.xy / res;\n    uv = (uv-vec2(0.5))*2.0;\n    uv.y += 0.5;\n    uv *= 1.3;\n\n\t\t\t\n\tray r;\n\tr.o = vec3(0.0);\n\tr.d = calcCameraRayDir(60.0,  gl_FragCoord.xy, res);\n\t\t\n\tfloat gradient = gradient(uv);\n\tfloat moon = distance(uv, vec2(0.0,0.1));\n\tmoon = 1.0 - smoothstep(0.05, 0.08, moon);\n\t\n\tvec3 bg = mix(vec3(0.0, 0.1, 0.1),vec3(0.1, 0.3, 0.5), min(1.0, gradient*2.0));\n\tbg = mix(bg, vec3(0.6, 0.9, 1.0), (max(0.0, gradient - 0.5)) * 2.0);\n\tbg += vec3(0.8) * moon;\n\tbg += vec3(0.4) * stars(uv,5.0,0.01);\n\tbg += vec3(0.4) * stars(uv, 100.0, 0.04);\n\tbg += vec3(0.4) * ghosts(uv) * (uv.y+1.0)*0.5;\n\t\n\tvec4 sum = vec4(0);\t\n\tfloat t = 0.0;\n\t#ifdef CLOUDS_ON\n\tfor(int i = 0; i < int(STEPS); i++)\n\t{\n\t\tvec3 p = r.o + r.d * t;\n\t\tfloat d = density(p);\n\t\tif(d > 0.01)\n\t\t{\n\t\t\tfloat a = d * (1.0 - smoothstep(DRAWDIST / 2.0, DRAWDIST, t))*0.4;\n\t\t\tvec3 c = clouds(p, d, t, bg);\n\t\t\tsum += vec4(c * a, a) * ( 1.0 - sum.a );\t\t\n\t\t\tif(sum.a > 0.99) break;\n\t\t}\n\t\tt += STEPSIZE;\n\t}\t\n\t#endif\n\tvec4 c;\n\tc = vec4(bg, 1.0) * (1.0 - sum.a) + sum;\n\tc.rgb = tonemapping(c.rgb, 1.5,1.2);\n\tfragColor = c;\n}","name":"Image","description":"","type":"image"}]}