{"ver":"0.1","info":{"id":"DdjczR","date":"1687364644","viewed":94,"name":"Raymarchin 1bpp","username":"jean80it","description":"raymarching 1bpp","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"sstfDS","parentname":"Raymarching naive"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO (min(iFrame,0))\n#define MAXD 10000.0\n#define ZCLIP 1000.0\n#define NITER 200\n#define PI 3.14159265359\n#define DEG2RAD 2.0*PI/360.0\n#define HIT_DIST 0.01\n#define SHAD_BUMP 0.8\n#define EPS 0.01\n\nvec3 ambientCol = vec3(0.1, 0.1, 0.1);\nvec3 lightDir = normalize( vec3(-1.0, -1.0, 1.0) );\nvec4 objectCol[] = vec4[](vec4(0.0, 0.0, 0.0, 0.0), // 0\tbackground\n                          vec4(0.5, 0.0, 0.5, 0.0), // 1\tsphere\n                          vec4(0.2, 0.2, 0.4, 0.0), // 2\tchecker col 1\n                          vec4(0.1, 0.1, 0.2, 0.0), // 3\tchecker col 2\n                          vec4(0.8, 0.1, 0.2, 0.0)  // 4\tbox\n                          );\n\n\nstruct RayHit\n{\n  vec3 pos;\n  float dist;  // for clipping\n  float minDist;  // for penumbra\n  uint ID;\n};\n\nstruct surfDist\n{\n    float dist;\n    uint ID;\n};\n\n// PRIMITIVES\nsurfDist sdSphere(vec3 p, float radius)\n{\n    surfDist sd;\n    sd.dist = length(p) - radius;\n    sd.ID = uint(1);\n\n    return sd;\n}\n\nsurfDist sdBox( vec3 p, vec3 size )\n{\n    surfDist sd;\n  \tvec3 q = abs(p) - size;\n  \tsd.dist = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-0.05;\n    sd.ID = uint(4);\n\n    return sd;\n}\n\nsurfDist sdXZPlane(vec3 p, float height)\n{\n    surfDist sd;\n    sd.dist = p.y - height;\n    sd.ID = uint(2);\n\n    return sd;\n}\n\nsurfDist sdChecker(vec3 p, float height, vec2 size)\n{\n    surfDist sd;\n    sd.dist = p.y - height;\n\n    float total = floor(p.x*float(size.x)) +\n                  floor(p.z*float(size.y));\n    bool isEven = mod(total, 2.0)==0.0;\n\n    sd.ID = isEven ? uint(2) : uint(3);\n\n    return sd;\n}\n\n// TRANSFORMS\n// TODO: collapse these\nmat4 rotationX(float angle) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY(float angle) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ(float angle) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nmat4 rotation(vec3 rotations)\n{\n    return rotationX(rotations.x) * rotationY(rotations.y) * rotationZ(rotations.z);\n}\n\nvec3 rotate(vec3 p, vec3 rotations)\n{\n    vec3 rotDeg = rotations * vec3(DEG2RAD);\n    return (vec4(p, 1.0) * rotation(rotations)).xyz;\n}\n\n\n// COMBINATION MEANS\nsurfDist combine(surfDist h1, surfDist h2)\n{\n\t//return ((h1.dist < h2.dist) ? h1 : h2);\n    surfDist sd;\n    sd.dist = min(h1.dist, h2.dist);\n    sd.ID = (h1.dist<h2.dist) ? h1.ID : h2.ID;\n    return sd;\n}\n\nsurfDist softCombine(surfDist h1, surfDist h2, float k)\n{\n    surfDist res;\n    float h = clamp(0.5 + 0.5 * (h2.dist - h1.dist) / k, 0.0, 1.0);\n\n    // distance is soft combine, ID depends on closer surface\n    res.dist = mix(h2.dist, h1.dist, h) - k * h * (1.0 - h);\n    res.ID = (h1.dist<h2.dist) ? h1.ID : h2.ID;\n    return res;\n}\n\n\n// WORLD MAPPING\nsurfDist map(vec3 p)\n{\n    surfDist res;\n    res.dist = MAXD;\n    res.ID = uint(0);\n\n\tres = softCombine(res, sdSphere(p + vec3(1.0, 0.0, -1.0 - sin(iTime * 0.4)), 1.0), 0.5);\n    res = softCombine(res, sdBox(\n                                rotate(p + vec3(-1.0, 0.0, -1.0 - sin(iTime * 0.4)), vec3(45.0, iTime*0.4, 45.0)),\n                                vec3(1.0, 1.0, 1.0)\n    \t\t\t\t\t\t), 0.5);\n    res = combine(res, sdChecker(p, -1.7, vec2(1.0, 1.0)));\n    return res;\n}\n\n\n// NORMALS COMPUTATION\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(vec3 pos)\n{\n\n#if 0\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.001;\n    return normalize( e.xyy * map(pos + e.xyy).dist +\n\t\t\t\t\t  e.yyx * map(pos + e.yyx).dist +\n\t\t\t\t\t  e.yxy * map(pos + e.yxy).dist +\n\t\t\t\t\t  e.xxx * map(pos + e.xxx).dist );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).dist;\n    }\n    return normalize(n);\n#endif\n}\n\n\n// returns position of hit and last min distance\nRayHit trace(vec3 o, vec3 r, float accuracyFactor)\n{\n    RayHit resHit;\n    resHit.dist = 0.0;\n    resHit.pos = vec3(0.0);\n    resHit.minDist = MAXD;\n\n    for (int i = 0; i < NITER; ++i)\n    {\n        resHit.pos = o + r * resHit.dist ;\n        surfDist m = map(resHit.pos);\n        resHit.dist += m.dist * accuracyFactor;\n        resHit.minDist = min(resHit.minDist, m.dist);\n        resHit.ID = m.ID;\n    }\n    return resHit;\n}\n\nRayHit trace(vec3 o, vec3 r)\n{\n\treturn trace(o, r, 1.0);\n}\n\nvec3 render(vec3 o, vec3 r)\n{\n    // HIT\n    RayHit hit = trace(o, r, 1.0);\n    vec3 col;\n    vec3 reflCol = vec3(0.0);\n    float shadowK = 1.0;\n    float fog = 1.0;\n\n    if (hit.dist > ZCLIP)\n    {\n        hit.ID = uint(0);\n\n        col = texture(iChannel0, r).rgb;\n    }\n    else\n    {\n        vec3 nor = calcNormal(hit.pos);\n        col = objectCol[hit.ID].xyz * max(0.0, dot(-lightDir, nor));\n\n\n        // FIRST BOUNCE REFLECTION HIT\n        vec3 reflDir = reflect(r, nor);\n        vec3 reflPos = hit.pos + reflDir * 0.01;  // advance a bit in the new direction to avoid acne\n        RayHit reflHit = trace(reflPos, reflDir, 1.0);\n        if (reflHit.dist > ZCLIP)\n        {\n            reflHit.ID = uint(0);\n\t\t\treflCol = texture(iChannel0, reflDir).rgb;\n        }\n        else\n        {\n            vec3 reflNor = calcNormal(reflHit.pos);\n            reflCol = objectCol[reflHit.ID].xyz * max(0.0, dot(-lightDir, reflNor));\n        }\n\n\n        // UMBRA/PENUMBRA RAY (DIRECTIONAL LIGHT)\n        vec3 shadPos = hit.pos - lightDir * SHAD_BUMP + EPS;  // advance a bit in the new direction to avoid acne\n        RayHit shadHit = trace(shadPos, - lightDir, 1.0);\n\n        // we want shadowK SMALL when minDist is small\n        // we wanr shadowK SMALL when sl is small\n        float sl = length(shadHit.pos - hit.pos);\n\n        shadowK = smoothstep(0.0, SHAD_BUMP, shadHit.minDist);\n\n        // apply fog\n    \tfog = 1.0 / (1.0 + hit.dist * hit.dist * 0.02);\n    }\n\n    vec3 res = (col * shadowK + reflCol * 0.2) * fog + ambientCol;\n\n    // z-clip\n    //if (hit.dist>10.0) res = vec3(0.0);\n\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv_aspect = fragCoord/iResolution.x;\n    vec2 uv_orig = fragCoord/iResolution.xy;  // [width, height] -> [0, 1]\n\n    vec2 uv = uv_orig * 2.0 - 1.0;  // [0, 1] -> [-1, 1]\n\n    uv.x *= iResolution.x / iResolution.y;  // aspect ratio correction\n\n    vec3 r = normalize(vec3(uv, 1.0));  // direction of the ray for current pixel\n\n    vec3 o = vec3(0.0, 0.0, -3.0);\n\n    vec3 col = render(o, r);\n\n    // dithered render\n    float yGain = 2.0;\n    float yBias = 0.5;\n    float yGamma = 1.2;\n    \n    // tweaks scale to ~2 to look good in full screen\n    float ditherScale = (iResolution.x > 1500.)? 2.0 : 1.0;  \n    float y = yGain * pow(dot(vec3(0.3, 0.6, 0.1), col), yGamma);\n    float ditherComp = texture(iChannel1, uv_aspect * ditherScale).x;\n    float _1bppCol = float(y * yBias > ditherComp);\n\n    // moving split screen\n    float verticalLineXPos = sin(iTime * 0.5);\n    float outCol = (uv.x<verticalLineXPos)? y : _1bppCol;\n\n    fragColor = vec4(vec3(outCol), 1.0);  // out\n}","name":"Image","description":"","type":"image"}]}