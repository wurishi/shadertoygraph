{"ver":"0.1","info":{"id":"XXjBWG","date":"1729930321","viewed":109,"name":"GIMP Shadows-Highlights","username":"newpson","description":"My port of GIMP (Darktable) Shadows-Highlights correction algorithm to GLSL.\nControls:\ntop - adjust shadows to 1.0\nbottom - adjust shadows to -1.0\nright - adjust highlights to 1.0\nleft - adjust highlights to -1.0","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["edu"],"hasliked":0,"parentid":"lX2Bzc","parentname":"newpson's Shadows-Highlights"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float extremeLow = 0.000001;\n\n// Some input parameters that I can't adjust via mouse\nconst float lodLevel = 2.0; // level of detail for mipmap blurring\nconst float in_whitepoint = 0.0; // [-0.1, 0.1]\nconst float in_compress = 0.5; // [0.0, 1.0]\n\nconst float whitepoint = max(1.0 - in_whitepoint, extremeLow);\nconst float compress = min(in_compress, 1.0 - extremeLow);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Scale input parameters into [-2.0, 2.0]\n    // {if you don't multiply by 2.0, then this algorithm will simply compensate\n    // for the light and shadow (reduce the contrast), bringing them to the middle}\n    // p.s. Filter gain #1\n    float highlights = 2.0 * scale(iMouse.x/iResolution.x);\n    float shadows = 2.0 * scale(iMouse.y/iResolution.y);\n\n    // Scale coords into [0.0, 1.0]\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Get texure brightness as average of three channels\n    float gray = grayscale(texture(iChannel0, uv.xy));\n    \n    // Mipmap blurred image and inverted\n    float blurredGray = invert(grayscale(texture(iChannel0, uv.xy, lodLevel)));\n    \n    // You can use this parameter if brightness level if beyond [0.0, 1.0]\n    // to fit it into [0.0, 1.0].\n    // Or if you just want to impact exterme values.\n    gray /= whitepoint;\n    \n    // Adjust highlights\n    gray = adjust(gray, blurredGray, highlights, compress, -1.0);\n    \n    // Adjust shadows\n    gray = adjust(gray, blurredGray, shadows, compress, 1.0);\n\n    fragColor = vec4(gray, gray, gray, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float grayscale(vec4 color)\n{\n    return (color.r + color.g + color.b) / 3.0;\n}\n\n// [0.0, 1.0] -> [-1.0, 1.0]\nfloat scale(float value)\n{\n    return 2.0 * value - 1.0;\n}\n\n// [-1.0, 1.0] -> [0.0, 1.0]\nfloat rescale(float value)\n{\n    return (value + 1.0) / 2.0;\n}\n\n// [0.0, 1.0] -> [1.0, 0.0]\nfloat invert(float value)\n{\n    return 1.0 - value;\n}\n\n// Use general formula to calculate parameter impact\n// Both Darktable and GIMP split this function into two parts\n// (for shadows and highlights) but the difference for grayscale\n// is just one parameter so I decided to generalize adjustment algorithm\nfloat adjust(\n    float gray, float blurredGray, float delta,\n    float compress, float direction)\n{\n    // Calculate square of adjustment value (and remove its sign)\n    // IDK why to we need this #1\n    // p.s. Filter gain #2\n    float delta2 = delta * delta;\n    \n    // Higher compression => narrower range of values the filter works with.\n    // Literally compresses the interval\n    // (see https://www.desmos.com/calculator/r0uvqclrg1).\n    float impact = clamp(\n        invert((rescale(direction) - direction * blurredGray) / invert(compress)),\n        0.0, 1.0);\n    \n    // Again, IDK why the square is used\n    while (delta2 > 0.0)\n    {\n        // IDK how to describe this line\n        // it just does something with blurredGray depending on the sign of delta and gray \n        float lb = (blurredGray - 0.5) * sign(direction * delta) * sign(invert(gray)) + 0.5;\n        \n        // Gain divisor (works when abs(delta) < 1.0\n        // (condidering it fits into [-2.0, 2.0])\n        float chunk = delta2 > 1.0 ? 1.0 : delta2;\n        \n        // Blending factor\n        // p.s. Filter gain #3\n        float mixValue = chunk * impact;\n        \n        gray = mix(\n                gray,\n                gray > 0.5 // the middle of the full brightness range\n                    ? invert(2.0 * invert(gray) * invert(lb)) // inverted product of inverted products\n                    : 2.0 * gray * lb, // just product\n                mixValue\n            );\n\n        delta2 -= 1.0;\n    }\n    \n    return gray;\n}","name":"Common","description":"","type":"common"}]}