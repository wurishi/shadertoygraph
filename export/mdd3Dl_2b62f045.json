{"ver":"0.1","info":{"id":"mdd3Dl","date":"1678100872","viewed":94,"name":"Volumetric fire","username":"MaGetzUb","description":"Volumetric fire","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["volumetricfire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float Pi = 3.141592653589;\n    \n\n//Swap floats around\nvoid Swap(inout float a, inout float b);\n\n//Ray AABB intersection test, returns 2 on x-component if there was intersection\n//y-component represents the nearest depth on ray\n//z-component represents the furthest depth on ray\nvec3 RayAABB(vec3 o, vec3 d, vec3 bc, vec3 bhs);\n\n//Converts temperature to blackbody emission shade \nvec3 BlackBody(float tempK);\n\n//Tone mapping function, crushes the HDR range to SDR\nvec3 ACES(vec3 x);\n\n//Value noise...\nfloat n3(vec3 p);\n\n//Smooth noise...\nfloat snoise3(vec3 p);\n\n//Fractional brownian motion noise...\nfloat fbm5_3d(vec3 p);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized, aspect ratio corrected pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    //Calculate the xz orbit angle for the camera\n    float ang = (iMouse.x/iResolution.x)*2.*Pi;\n    \n    //Ray origin\n    vec3 pos = vec3(sin(ang)*2.5, 0.0, cos(ang)*2.5);\n    \n    //Initial ray direction\n    vec3 dir = normalize(vec3(uv, 1.));\n    \n    //This will be used to rotate the camera to point the center\n    vec3 rot = normalize(-pos);\n    \n    //Calculate camera rotation matrix\n    mat2 rotM = mat2(rot.z, -rot.x, rot.x, rot.z);\n    \n    //Rotate ray direction with the matrix\n    dir.xz = rotM * dir.xz;\n    \n    //Resulting color\n    vec3 col = vec3(0.);\n    \n    \n    //Fire bounding box' center\n    vec3 bc = vec3(0.0, 0.0, 0.);\n    \n    //Fire bounding box' size\n    vec3 bs = vec3(1., 1.0, 1.);\n    \n    //Shoot a ray, and test does it even land on the fire's bounding box\n    vec3 rc = RayAABB(pos, dir, bc, bs); \n    \n    //Approx. Black body radiation in 1500Kelvins (sRGB)\n    vec3 fireShade = pow(BlackBody(1500.0), vec3(2.2));\n    \n    float density = 0.;\n    //Ray hit the AABB side\n    if(rc.x > 0.0) {\n    \n        #define N 64.0\n        \n        //Calculate ray initial position\n        vec3 ray = pos+dir*rc.y;\n        \n        //The calculate the rays input output distance\n        //and divide it by a sample count to calculate the ray step size\n        float l = (rc.z - rc.y)/N;\n        \n        for(float n = 0.; n < N; n+=1.0) {\n            \n            //Calculate sampling displace offset\n            vec3 offset = vec3(fbm5_3d(ray*4.5-vec3(5., iTime*5., 0.0))*2.-1.)*.45;\n            \n            //Zero the x and z coordinate from the offset\n            offset.xz = vec2(0.);\n            \n            //Sample the volume\n            float vsample = smoothstep(0.6, 0.0, 1.25*length(ray*vec3(1., 0.35, 1.) - (bc+offset-vec3(0.0, 0.5, 0.0))));;\n            \n            //How much this sample contributes the result\n            float contribution = (1.0 - density);\n            \n            //Accumulate color by the shade multiplied by the sample and the contribution \n            col += fireShade*vsample*contribution;\n            \n            //Not sure how necessary this is\n            density += (vsample/max(n, 1.));\n            \n            //Step forwards within the volume\n            ray += dir*l; \n        }\n    \n    }\n    \n    //Color correct\n    col = ACES(col); // / (col + vec3(1.));\n    \n    //Gamma correct\n    col = pow(col, vec3(1./2.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n//This function approximates this gradient:\n//https://en.wikipedia.org/wiki/Black-body_radiation#/media/File:Color_temperature_black_body_800-12200K.svg\nvec3 BlackBody(float tempK) {\n\n    vec3 color = vec3(1.0);\n    color.x = 22e4 * pow(tempK, -1.5) + 0.580392156;\n    color.y = mix(0.392313725 * log(tempK) - 2.445490196, 127450.980392156 * pow(tempK, -1.5) + 0.721568627, step(6500.0, tempK));\n    color.z = 0.761490196 * log(tempK) - 5.6807843137;\n    color = clamp(color, vec3(0.0), vec3(1.0));\n    color = mix(color, color * tempK*1e-3, step(tempK, 1e3));\n    \n    return color;\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACES(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\n\n\n\nvoid Swap(inout float a, inout float b) {\n    float c = b;\n    b = a;\n    a = c;\n}\n\nvec3 RayAABB(vec3 o, vec3 d, vec3 bc, vec3 bhs) {\n\n    \n    vec3 cNear = ((bc - bhs) - o) / d;\n    vec3 cFar = ((bc + bhs) - o) / d;\n    \n    if(cNear[0] > cFar[0]) Swap(cNear[0], cFar[0]);\n    if(cNear[1] > cFar[1]) Swap(cNear[1], cFar[1]);\n    if(cNear[2] > cFar[2]) Swap(cNear[2], cFar[2]);\n    \n    float near = max(cNear[0], max(cNear[1], cNear[2]));\n    float far = min(cFar[0], min(cFar[1], cFar[2]));\n\n    if(near > far && far<0.) \n        return vec3(0.);\n    \n    return vec3(2, near, far);\n    \n}\n\nfloat n3(vec3 p) {\n    return fract(cos(p.x*321.2189+p.y*152.431+p.z*395.3291)*311.32176);\n}\n\nfloat snoise3(vec3 p) {\n    \n    vec3 sip = floor(p);\n    vec3 sfp = fract(p);\n    \n    float na = n3(sip+vec3(0.0, 0.0, 0.0));\n    float nb = n3(sip+vec3(1.0, 0.0, 0.0));\n    float nc = n3(sip+vec3(0.0, 1.0, 0.0));\n    float nd = n3(sip+vec3(1.0, 1.0, 0.0));\n    \n    float fa = n3(sip+vec3(0.0, 0.0, 1.0));\n    float fb = n3(sip+vec3(1.0, 0.0, 1.0));\n    float fc = n3(sip+vec3(0.0, 1.0, 1.0));\n    float fd = n3(sip+vec3(1.0, 1.0, 1.0));\n    \n    sfp = sfp*sfp*(3.-2.*sfp);\n    \n    float r0 = na + (nb - na) * sfp.x + (nc - na) * sfp.y * (1.0 - sfp.x) + (nd - nb) * sfp.x * sfp.y;\n    float r1 = fa + (fb - fa) * sfp.x + (fc - fa) * sfp.y * (1.0 - sfp.x) + (fd - fb) * sfp.x * sfp.y;\n    \n    return mix(r0, r1, sfp.z);\n    \n}\n\nfloat fbm5_3d(vec3 p) {\n    return \n        snoise3(p)*.5 + \n        snoise3(p*2.)*.25 + \n        snoise3(p*4.)*.125 + \n        snoise3(p*8.)*.0625 +\n        snoise3(p*16.)*.03125;\n}\n\n","name":"Image","description":"","type":"image"}]}