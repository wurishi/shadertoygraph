{"ver":"0.1","info":{"id":"mdVfDz","date":"1698155048","viewed":76,"name":"[ConcoursJFIG2023] Labyrinthe","username":"Romimap","description":"Goal : Find the cake !\n\nMove: WASD or ZQSD\nAim : Arrows\nJump : Space\n\n\nQ - I want more framerate !\nA - You can set the USE_CUSTOM_RENDER_RESOLUTION to true in the common tab. RENDER_RESOLUTION can then be tweaked.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["concoursjfig2023"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 fcol;\n    if (USE_CUSTOM_RENDER_RESOLUTION)\n        fcol = texture(iChannel0, uv / (iResolution.xy / RENDER_RESOLUTION)).rgb;\n    else\n        fcol = texture(iChannel0, uv).rgb;\n        \n    fragColor = vec4(fcol, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Returns 1 if key is pressed, else 0\nfloat get_input(int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).r;\n}\n\n\n//Map.\n//This function is used for collision detection.\n//It is a simpler map than the one displayed.\ns_cdata f(vec3 p) {\n    s_cdata cdata;\n    cdata.h = TMAX;\n    \n    \n   \n    cdata = U (\n        cdata,\n        plane_SDF(p, vec3(0, 1, 0), 1.0, WHITE)\n    );\n    \n    { // Cake\n        vec3 p1 = opT(p, vec3(2 * 13 - 3, sin(iTime) * 0.1, -4 * 13));\n        cdata = U (\n            cdata,\n            cylinder_SDF(opT(p1, vec3(0, 0, 0)), 0.3, 1.2, 0.1, WHITE)\n        );\n        cdata = U (\n            cdata,\n            cylinder_SDF(opT(p1, vec3(0, -0.5, 0)), 0.3, .7, 0.1, WHITE)\n        );\n    }\n\n    {//Walls_mid\n        float s = 26.00;\n        vec3 p1 = opRy(p, PI * 0.5);\n        p1 += vec3(13, -5.5, 13);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n      \n        cdata = U (\n            cdata,\n            box_SDF(opT(p1, vec3(0, 0, 0)), vec3(6.5), 0.0, GREY)\n        );\n    }\n    \n    {//Walls_a\n        float s = 26.00;\n        vec3 p1 = opRy(p, PI * 0.5);\n        p1 += vec3(0, -5.5, 13);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n        \n        int x = int(r.x) * 2;\n        int y = int(r.z) * 2 - 1;\n        \n        x += 5;\n        y += 5;\n        \n        x = clamp(x, 0, 10);\n        y = clamp(y, 0, 10);\n        \n        if (laby[x + y * 11] == 1)\n        cdata = U (\n            cdata,\n            box_SDF(opT(p1, vec3(0, 0, 0)), vec3(6.5), 0.0, WHITE)\n        );\n\n    }\n    {//Walls_b\n        float s = 26.00;\n        vec3 p1 = opRy(p, PI * 0.5);\n        p1 += vec3(13, -5.5, 0);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n        \n        int x = int(r.x) * 2 - 1;\n        int y = int(r.z) * 2;\n        \n        x += 5;\n        y += 5;\n         \n        x = clamp(x, 0, 10);\n        y = clamp(y, 0, 10);\n       \n        if (laby[x + y * 11] == 1)\n        cdata = U (\n            cdata,\n            box_SDF(opT(p1, vec3(0, 0, 0)), vec3(6.5), 0.0, WHITE)\n        );\n\n    }\n    \n    //Dilate the map to get a sphere - map collision\n    cdata.h -= 1.5;\n    \n    return cdata;\n}\n\n//Sphere cast\nfloat get_t(vec3 p, vec3 d) {\n    float t = 0.0;\n    for (int i = 0; i < 32 && t < THIT * 2.0; i++) {\n        float h = f(p + d * t).h;\n        t += h;\n        if (h <= THIT) {\n            return t;\n        }\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 normal(in vec3 p) {\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h).h + \n                      k.yyx*f( p + k.yyx*h).h + \n                      k.yxy*f( p + k.yxy*h).h + \n                      k.xxx*f( p + k.xxx*h).h);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    ivec2 vZ = ivec2(KEY_Z, 0);\n    ivec2 vQ = ivec2(KEY_Q, 0);\n    ivec2 vS = ivec2(KEY_S, 0);\n    ivec2 vD = ivec2(KEY_D, 0);\n    \n    vec4 outData = vec4(0);\n    \n    vec3 velocity;\n    vec3 position;\n    vec2 asimuth_elevation;\n    vec2 asimuth_elevation_vel;\n    \n    //We store variables in the buffer A.\n    //Each collumn is a variable.\n    switch(int(fragCoord.x)) {\n        case VEL: //Velocity\n        \tvelocity = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n            vec3 target_velocity = vec3(0);\n            target_velocity.x = get_input(KEY_D) - (get_input(KEY_Q) + get_input(KEY_A));\n            target_velocity.z = (get_input(KEY_Z) + get_input(KEY_W)) - get_input(KEY_S);\n            \n            if (length(target_velocity) > 1.0)\n                target_velocity = normalize(target_velocity);\n            \n            position = texelFetch(iChannel0, ivec2(POS), 0).rgb;\n\n            asimuth_elevation = texelFetch(iChannel0, ivec2(AZM), 0).rg + ae_offset;\n            target_velocity = opRy(target_velocity, asimuth_elevation.x) * SPEED;\n            \n            if (f(position + vec3(0, -0.2, 0)).h < 0.0 && dot(normal(position + vec3(0, -0.2, 0)), vec3(0, 1, 0)) > 0.5 && get_input(KEY_SPACE) > 0.5)\n                velocity.y = 8.0;\n            \n            float y = velocity.y - 0.3;\n            velocity = velocity * (1.0 - ACCEL) + target_velocity * ACCEL;\n            velocity.y = y;\n            \n            \n            vec3 d = normalize(velocity);\n            vec3 p = position;\n            float t = f(p).h;\n            if (t < 0.0) {\n                vec3 n = normal(p);\n                velocity -= n * t * 3.0;\n                if (velocity.y < 0.0)\n                    velocity.y *= 0.1;\n            }\n\n                        \n            outData = vec4(velocity, 1);\n        \tbreak;\n        case POS: //Position\n        \tvelocity = texelFetch(iChannel0, ivec2(VEL), 0).rgb;\n            position = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n            position += velocity * iTimeDelta;\n            \n            outData = vec4(position, 1);\n        \tbreak;\n       \n        case AZM: //Azimuth & Elevation     \n            asimuth_elevation = texelFetch(iChannel0, ivec2(fragCoord), 0).rg;\n            asimuth_elevation_vel = texelFetch(iChannel0, ivec2(AZM_VEL), 0).rg;\n            \n            asimuth_elevation += asimuth_elevation_vel * iTimeDelta * AIM_SPEED;\n            asimuth_elevation.y = clamp(asimuth_elevation.y, -PI / 2.2, PI / 2.2);\n            outData = vec4(asimuth_elevation, 1, 1);\n        \tbreak;\n\n       case AZM_VEL: //Azimuth & Elevation velocities\n            asimuth_elevation_vel = texelFetch(iChannel0, ivec2(fragCoord), 0).rg;\n            vec2 target_vel = vec2(0);\n            target_vel.x += (get_input(KEY_LEFT) - get_input(KEY_RIGHT)) * iTimeDelta * AIM_SPEED;\n            target_vel.y += (get_input(KEY_UP) - get_input(KEY_DOWN)) * iTimeDelta * AIM_SPEED;\n            asimuth_elevation_vel = asimuth_elevation_vel * 0.85 + target_vel * 0.15;\n                        \n            outData = vec4(asimuth_elevation_vel, 1, 1);\n            break;\n    }\n    \n    \n    fragColor = vec4(outData);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Setting this to true forces the shader to run at the specified RENDER_RESOLUTION.\nconst bool USE_CUSTOM_RENDER_RESOLUTION = false;\n\n//const vec2 RENDER_RESOLUTION = vec2(400, 225); //LOW\nconst vec2 RENDER_RESOLUTION = vec2(800, 450); //MEDIUM\n//const vec2 RENDER_RESOLUTION = vec2(1920, 1080); //HIGH\n\n/*\n   _____                _              _       \n  / ____|              | |            | |      \n | |     ___  _ __  ___| |_ __ _ _ __ | |_ ___ \n | |    / _ \\| '_ \\/ __| __/ _` | '_ \\| __/ __|\n | |___| (_) | | | \\__ \\ || (_| | | | | |_\\__ \\\n  \\_____\\___/|_| |_|___/\\__\\__,_|_| |_|\\__|___/\n  \n*/\n\nconst int laby[121] = int[121](\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1,\n    1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1,\n    1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1,\n    1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1,\n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, \n    1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n    1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1,\n    1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1,\n    1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, \n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 \n);\n\nconst float TMIN = 0.001;\nconst float TMAX = 100.0;\nconst float THIT = 0.0001;\n\nconst float PI = 3.141529;\n\nconst vec3 WHITE = vec3(0.9, 0.7, 0.7);\nconst vec3 GREY = vec3(0.5, 0.6, 0.7);\nconst vec3 RED = vec3(1.0, 0.1, 0.1);\nconst vec3 CANDY = vec3(1.5, 0.2, 0.3);\nconst vec3 GREEN = vec3(0.1, 0.5, 0.2);\nconst vec3 BLUE = vec3(0.1, 0.4, 1.0);\nconst vec3 FIRE = vec3(1.0, 0.6, 0.0);\n\nconst vec2 ae_offset = vec2(3.0 * PI * 0.25, 0.0);\n\nconst float SPEED = 10.0;\nconst float ACCEL = 0.2;\nconst float AIM_SPEED = 10.0;\n\nconst int KEY_W  = 87;\nconst int KEY_Z  = 90;\nconst int KEY_A  = 65;\nconst int KEY_Q  = 81;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_SPACE = 32;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int VEL = 0;\nconst int POS = 1;\nconst int AZM = 2;\nconst int AZM_VEL = 3;\n\n\n\n\nstruct s_cdata {\n    float h;\n    vec3 c;\n};\n\n\n/*\n  _______                   __                         \n |__   __|                 / _|                        \n    | |_ __ __ _ _ __  ___| |_ ___  _ __ _ __ ___  ___ \n    | | '__/ _` | '_ \\/ __|  _/ _ \\| '__| '_ ` _ \\/ __|\n    | | | | (_| | | | \\__ \\ || (_) | |  | | | | | \\__ \\\n    |_|_|  \\__,_|_| |_|___/_| \\___/|_|  |_| |_| |_|___/\n\n*/\n\n\nvec3 opRx(vec3 p, float theta) {\n    mat3 ry = mat3(\n    vec3(1, 0, 0),\n    vec3(0, cos(theta), -sin(theta)),\n    vec3(0, sin(theta), cos(theta)));\n    \n    return ry * p;\n}\n\n\nvec3 opRy(vec3 p, float theta) {\n    mat3 ry = mat3(\n    vec3(cos(theta), 0, sin(theta)),\n    vec3(0, 1, 0),\n    vec3(-sin(theta), 0, cos(theta)));\n    \n    return ry * p;\n}\n\n\nvec3 opT( in vec3 p, in vec3 t) {\n    return t-p;\n}\n\n\n/*\n  ____                        _ _               _                        \n |  _ \\                      | (_)             | |                       \n | |_) | ___  _   _ _ __   __| |_ _ __   __ _  | |__   _____  _____  ___ \n |  _ < / _ \\| | | | '_ \\ / _` | | '_ \\ / _` | | '_ \\ / _ \\ \\/ / _ \\/ __|\n | |_) | (_) | |_| | | | | (_| | | | | | (_| | | |_) | (_) >  <  __/\\__ \\\n |____/ \\___/ \\__,_|_| |_|\\__,_|_|_| |_|\\__, | |_.__/ \\___/_/\\_\\___||___/\n                                         __/ |                           \n                                        |___/                            \n*/\n\n\nbool hit_sphere(vec3 p, vec3 d, const vec3 center, float radius){\n    vec3 oc = p - center;\n    float b = 2.0 * dot(oc, d);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminant = b*b - 4.0*c;\n    return discriminant > 0.0;\n}\n\nbool hit_aabb(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return tFar > tNear;\n}\n\n\n/*\n   _____ _____  ______   \n  / ____|  __ \\|  ____|  \n | (___ | |  | | |__ ___ \n  \\___ \\| |  | |  __/ __|\n  ____) | |__| | |  \\__ \\\n |_____/|_____/|_|  |___/\n                         \n(See Inigo Quilez https://iquilezles.org/articles/distfunctions/)\n*/\n\n\ns_cdata sphere_SDF (vec3 p, vec3 o, float r, vec3 c) {\n    s_cdata cdata;\n    cdata.h = distance(p, o) - r;\n    cdata.c = c;\n    return cdata;\n}\n\ns_cdata plane_SDF ( vec3 p, vec3 n, float h, vec3 c) {\n    s_cdata cdata;\n    cdata.h = dot(p,n) + h;\n    cdata.c = c;\n    return cdata;\n}\n\ns_cdata box_SDF (vec3 p, vec3 b, float s, vec3 c) {\n    b -= s;\n    vec3 q = abs(p) - b;\n    s_cdata cdata;\n    cdata.h = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.00) - s;\n    cdata.c = c;\n    return cdata;\n}\n\ns_cdata torus_SDF (vec3 p, vec2 t, vec3 c) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    s_cdata cdata;\n    cdata.h = length(q)-t.y;\n    cdata.c = c;\n    return cdata;\n}\n\ns_cdata capped_torus_SDF (vec3 p, vec2 sc, float ra, float rb, vec3 c) {\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    s_cdata cdata;\n    cdata.h = sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n    cdata.c = c;\n    return cdata;\n}\n\ns_cdata cylinder_SDF (vec3 p, float h, float r, float s, vec3 c) {\n    r = r - s;\n    h = h - s;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    s_cdata cdata;\n    cdata.h = min(max(d.x,d.y),0.0) + length(max(d,0.0)) - s;\n    cdata.c = c;\n    return cdata;\n}\n\n\n//Union\ns_cdata U (s_cdata a, s_cdata b) {\n    if (a.h < b.h) \n        return a;\n    return b;\n}\n\n//Substract\ns_cdata S (s_cdata a, s_cdata b) {\n    b.h = -b.h;\n    if (b.h > a.h) \n        return b;\n    return a;\n}\n\n//Inter\ns_cdata I (s_cdata a, s_cdata b) {\n    if (a.h > b.h) \n        return a;\n    return b;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Map.\ns_cdata f(vec3 p, vec3 d) {\n    p += vec3(0, 1, 0);\n    s_cdata cdata;\n    cdata.h = TMAX;\n    \n    //Ground\n    cdata = U (\n        cdata,\n        plane_SDF(p, vec3(0, 1, 0), 1.0, WHITE)\n    );\n    \n    { // Cake\n    vec3 p1 = opT(p, vec3(2 * 13 - 3, sin(iTime) * 0.1, -4 * 13));\n    if (length(d) < 0.1 || hit_sphere(vec3(0, -0.7, 0), d, p1, 1.6)) { //Does the ray hits the bounding sphere ?\n        p1 = opRy(p1, iTime * 0.3);\n        cdata = U (\n            cdata,\n            cylinder_SDF(opT(p1, vec3(0, 0, 0)), 0.3, 1.2, 0.1, WHITE)\n        );\n        cdata = U (\n            cdata,\n            cylinder_SDF(opT(p1, vec3(0, -.19, 0)), 0.12, 1.21, 0.1, CANDY)\n        );\n        cdata = U (\n            cdata,\n            cylinder_SDF(opT(p1, vec3(0, 0, 0)), 0.05, 1.21, 0.05, CANDY)\n        );\n        cdata = U (\n            cdata,\n            cylinder_SDF(opT(p1, vec3(0, -0.5, 0)), 0.3, .7, 0.1, WHITE)\n        );\n        cdata = U (\n            cdata,\n            cylinder_SDF(opT(p1, vec3(0, -0.69, 0)), 0.12, .71, 0.1, CANDY)\n        );\n        cdata = U (\n            cdata,\n            cylinder_SDF(opT(p1, vec3(0, -0.5, 0)), 0.05, .71, 0.05, CANDY)\n        );\n        cdata = U (\n            cdata,\n            torus_SDF(opRx(opT(p1, vec3(0, -1.2, 0)), PI/2.0), vec2(0.3, 0.15), RED)\n        );\n        float t = 0.5;\n        cdata = U (\n            cdata,\n            capped_torus_SDF(opT(opRx(p1, PI), vec3(0, 3.1, 0)), vec2(sin(t),cos(t)), 1.3, 0.18, RED)\n        );\n        for (int i = 0; i < 30; i++) {\n            float theta = float(i) / 30.0 * PI * 2.0;\n            cdata = U (\n                cdata,\n                cylinder_SDF(opT(p1, vec3(cos(theta), -0.3, sin(theta)) * 1.0), 0.2, 0.02, 0.02, WHITE)\n            );\n            cdata = U (\n                cdata,\n                cylinder_SDF(opT(p1, vec3(cos(theta), -0.55, sin(theta)) * 1.0), sin(iTime * 32.0 + theta * 8.0) * 0.005 + 0.03, 0.02, 0.025, FIRE)\n            );\n        }\n    }\n    }\n    \n    { //Collumns\n        float s = 13.00;\n        highp vec3 p1 = p + vec3(s*0.5, -2.8, s*0.5);\n        highp vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n        if (length(d) < 0.1 || hit_aabb(vec3(0), d, p1 + vec3(-0.9, -4.5, -0.9), p1 + vec3(0.9, 4.5, 0.9))) //Does the ray hits the AABB ?\n        {\n            cdata = U (\n                cdata,\n                cylinder_SDF(p1, 3.0, 0.5, 0.0, GREY)\n            );\n            for (int i = 0; i < 9; i++) {\n                float theta = float(i) / 9.0 * PI * 2.0;\n                cdata = S (\n                    cdata,\n                    cylinder_SDF(opT(p1, vec3(cos(theta), 0.0, sin(theta)) * 0.75), 2.8, 0.3, 0.3, WHITE)\n                );\n            }\n            cdata = U (\n                cdata,\n                box_SDF(opT(p1, vec3(0, -3, 0)), vec3(0.6, 0.2, 0.6), 0.025, WHITE)\n            );\n            cdata = U (\n                cdata,\n                box_SDF(opT(p1, vec3(0, -3.5, 0)), vec3(0.7, 0.3, 0.7), 0.025, WHITE)\n            );\n            cdata = U (\n                cdata,\n                box_SDF(opT(p1, vec3(0, 3.3, 0)), vec3(0.7, 0.3, 0.7), 0.025, WHITE)\n            );\n            cdata = U (\n                cdata,\n                cylinder_SDF(opT(p1, vec3(0, 3.0, 0)), 0.2, 0.65, 0.2, WHITE)\n            );\n        }\n    }\n    { //Archs\n        float s = 13.00;\n        vec3 p1 = p + vec3(0, -6, s * 0.5);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n        \n        s_cdata cdata1;\n        cdata1.h = 9999.0;\n        \n        cdata1 = U (\n            cdata1,\n            cylinder_SDF(opT(opRx(p1, PI * 0.5), vec3(0, 0, 0)), 0.6, s * 0.5 + 0.7, 0.1, WHITE)\n        );\n        cdata1 = U (\n            cdata1,\n            box_SDF(opT(p1, vec3(0, 4, 0)), vec3(s, 4.0, 0.5), 0.0, GREY)\n        );\n        cdata1 = S (\n            cdata1,\n            cylinder_SDF(opT(opRx(p1, PI * 0.5), vec3(0, 0, 0)), 2.0, s * 0.5 - 0.7, 0.1, WHITE)\n        );\n        cdata1 = S (\n            cdata1,\n            box_SDF(opT(p1, vec3(0, -4, 0)), vec3(s, 4.0, 2.0), 0.0, WHITE)\n        );\n        \n        cdata = U (cdata, cdata1);\n    }\n    {//Archs\n        float s = 13.00;\n        vec3 p1 = opRy(p, PI * 0.5);\n        p1 += vec3(0, -6, s * 0.5);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n        \n        s_cdata cdata1;\n        cdata1.h = 9999.0;\n        \n        cdata1 = U (\n            cdata1,\n            cylinder_SDF(opT(opRx(p1, PI * 0.5), vec3(0, 0, 0)), 0.6, s * 0.5 + 0.7, 0.1, WHITE)\n        );\n        cdata1 = U (\n            cdata1,\n            box_SDF(opT(p1, vec3(0, 4, 0)), vec3(s, 4.0, 0.5), 0.0, GREY)\n        );\n        cdata1 = S (\n            cdata1,\n            cylinder_SDF(opT(opRx(p1, PI * 0.5), vec3(0, 0, 0)), 2.0, s * 0.5 - 0.7, 0.1, WHITE)\n        );\n        cdata1 = S (\n            cdata1,\n            box_SDF(opT(p1, vec3(0, -4, 0)), vec3(s, 4.0, 2.0), 0.0, WHITE)\n        );\n        \n        cdata = U (cdata, cdata1);\n    }\n    {//Walls_mid\n        float s = 26.00;\n        vec3 p1 = opRy(p, PI * 0.5);\n        p1 += vec3(13, -5.5, 13);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n      \n        cdata = U (\n            cdata,\n            box_SDF(opT(p1, vec3(0, 0, 0)), vec3(6.5), 0.0, WHITE)\n        );\n        cdata = S (\n            cdata,\n            cylinder_SDF(opRx(p1, PI * 0.5), s * 0.5, s * 0.25 - 2.0, 0.1, WHITE)\n        );\n        cdata = S (\n            cdata,\n            cylinder_SDF(opRx(opRy(p1, PI * 0.5), PI * 0.5), s * 0.5, s * 0.25 - 2.0, 0.1, WHITE)\n        );\n        cdata = U (\n            cdata,\n            box_SDF(opT(p1, vec3(0, 0, 0)), vec3(6), 0.0, GREY)\n        );\n\n    }\n    {//Roofs_a\n        float s = 26.00;\n        vec3 p1 = opRy(p, PI * 0.5);\n        p1 += vec3(0, -9.75, 13);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n      \n        s_cdata cdata1;\n        cdata1.h = 9999.0;\n        \n        cdata1 = U (\n            cdata1,\n            box_SDF(opT(p1, vec3(0, 0, 0)), vec3(6.5, 3.5, 6.5), 0.0, GREY)\n        );\n        p1 += vec3(0, 3.25, 0);\n        cdata1 = S (\n            cdata1,\n            cylinder_SDF(opRx(opRy(p1, PI * 0.5), PI * 0.5), s * 0.5, s * 0.25, 0.1, WHITE)\n        );\n        cdata1 = S (\n            cdata1,\n            cylinder_SDF(opRx(p1, PI * 0.5), s * 0.5, s * 0.25, 0.1, WHITE)\n        );\n        cdata = U(cdata, cdata1);\n    }\n    {//Roofs_b\n        float s = 26.00;\n        vec3 p1 = opRy(p, PI * 0.5);\n        p1 += vec3(13, -9.75, 0);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n      \n        s_cdata cdata1;\n        cdata1.h = 9999.0;\n        \n        cdata1 = U (\n            cdata1,\n            box_SDF(opT(p1, vec3(0, 0, 0)), vec3(6.5, 3.5, 6.5), 0.0, GREY)\n        );\n        p1 += vec3(0, 3.25, 0);\n        cdata1 = S (\n            cdata1,\n            cylinder_SDF(opRx(opRy(p1, PI * 0.5), PI * 0.5), s * 0.5, s * 0.25, 0.1, WHITE)\n        );\n        cdata1 = S (\n            cdata1,\n            cylinder_SDF(opRx(p1, PI * 0.5), s * 0.5, s * 0.25, 0.1, WHITE)\n        );\n        cdata = U(cdata, cdata1);\n    }\n    {//Walls_a\n        float s = 26.00;\n        vec3 p1 = opRy(p, PI * 0.5);\n        p1 += vec3(0, -5.5, 13);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n        \n        int x = int(r.x) * 2;\n        int y = int(r.z) * 2 - 1;\n        \n        x += 5;\n        y += 5;\n        \n        x = clamp(x, 0, 10);\n        y = clamp(y, 0, 10);\n        \n        if (laby[x + y * 11] == 1)\n        cdata = U (\n            cdata,\n            box_SDF(opT(p1, vec3(0, 0, 0)), vec3(6.5), 0.0, WHITE)\n        );\n\n    }\n    {//Walls_a\n        float s = 26.00;\n        vec3 p1 = opRy(p, PI * 0.5);\n        p1 += vec3(13, -5.5, 0);\n        vec3 r = round(vec3(p1 / s));\n        r.y = 0.0;\n        p1 = p1 - s * r;\n        \n        int x = int(r.x) * 2 - 1;\n        int y = int(r.z) * 2;\n        \n        x += 5;\n        y += 5;\n         \n        x = clamp(x, 0, 10);\n        y = clamp(y, 0, 10);\n       \n        if (laby[x + y * 11] == 1)\n        cdata = U (\n            cdata,\n            box_SDF(opT(p1, vec3(0, 0, 0)), vec3(6.5), 0.0, WHITE)\n        );\n\n    }\n    \n    return cdata;\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 p, in vec3 d, float k ) {\n    float res = 1.0;\n    float t = TMIN;\n    for( int i=0; i<512 && t < TMAX; i++ )\n    {\n        s_cdata cdata = f(p + d * t, d);\n        if(cdata.h < THIT)\n            return 0.0;\n        res = min( res, k*cdata.h/t );\n        t += cdata.h;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 normal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h, vec3(0)).h + \n                      k.yyx*f( p + k.yyx*h, vec3(0)).h + \n                      k.yxy*f( p + k.yxy*h, vec3(0)).h + \n                      k.xxx*f( p + k.xxx*h, vec3(0)).h );\n}\n\n//Apply a directional light source\nvec3 shade(vec3 p, vec3 light, vec3 light_color) {\n    vec3 n = normal(p);\n    float s = max(0.0, dot(n, light));\n    s = clamp(float(int(s * 2.0 + 0.5)) / 2.0, 0.0, 1.0); //Toon shading\n    if (s > 0.0) {\n        s *= softshadow(p + n * 0.01, light, 16.0);\n    }\n    return s * light_color;\n}\n\n//Apply ambient lighting\nvec3 ambient(vec3 p, vec3 light, vec3 light_color) {\n    vec3 n = normal(p);\n    float s = dot(n, light) * 0.25 + 0.75;\n    return s * light_color;\n}\n\n\n// https://iquilezles.org/articles/fog/\nvec3 apply_fog( in vec3  rgb,      // original color of the pixel\n               in float h, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp(-h * 0.03);\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,1.0,0.9), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv;\n    if (USE_CUSTOM_RENDER_RESOLUTION) {\n        if (fragCoord.x > 800.0 || fragCoord.y > 450.0) \n            return;\n        uv = fragCoord/RENDER_RESOLUTION;\n    } else {\n        uv = fragCoord/iResolution.xy;\n    }\n    \n    //Get the position and azimuth.\n    vec3 p = texelFetch(iChannel0, ivec2(POS), 0).rgb;;\n    vec2 asimuth_elevation = texelFetch(iChannel0, ivec2(AZM), 0).rg + ae_offset; \n    vec3 d = vec3(uv.x - 0.5, (uv.y - 0.5) * (iResolution.y / iResolution.x), 0.5);\n    d = opRx(d, asimuth_elevation.y);\n    d = opRy(d, asimuth_elevation.x);\n    d = normalize(d);\n    \n\n    //Defaut color\n    vec3 color = vec3(0);\n    float t = TMIN;\n    for (int i = 0; i < 512 && t < TMAX; i++) {\n        s_cdata cdata = f(p + d * t, d);\n        if (cdata.h <= THIT) { //Hit, return the current color.\n            color = cdata.c;\n            break;\n        }\n        t += cdata.h;\n    }\n    if (t > TMAX) t = TMAX;\n\n    // Output to screen\n    vec3 fcol;\n    vec3 light = normalize(vec3(1.0, 2., -0.5));\n    vec3 light_color = vec3(0.9, 0.7, 0.5) * 3.0;\n    vec3 ambient_color = vec3(0.2, 0.3, 0.3) * 2.0;\n    if (distance(color, FIRE) <= 0.01) { //Fire is not shaded.\n        fcol = FIRE;\n    } else {\n        fcol = \n            color * shade(p + d * t, light, light_color) + \n            color * ambient(p + d * t, light, ambient_color);\n        fcol = tanh(fcol); //Transforms the color so it fits [0, 1]\n    }\n    fcol = apply_fog(fcol, t, d, light);\n    \n    fragColor = vec4(fcol, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}