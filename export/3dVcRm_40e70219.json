{"ver":"0.1","info":{"id":"3dVcRm","date":"1603916926","viewed":328,"name":"Classical Waves","username":"t42","description":"Try playing around w/ the mouse and defining 'altint' in Common.\nI loved those programs that turned your wallpaper into a pool when I was little. So when I saw the coding train video I was hyped up to make one. That's the first time I heard about shaders.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["waves","mouse","water","fluid","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    \n    float center = texelFetch(iChannel0, coord, 0).r;\n    \n    //calculating normals\n    vec3 normal = vec3(- texelFetchOffset(iChannel0, ivec2(fragCoord), 0, ivec2( 1,  0)).r,\n                       - texelFetchOffset(iChannel0, ivec2(fragCoord), 0, ivec2( 0,  1)).r, 1.);\n    normal.xy += center;\n    normal = normalize(normal);\n    \n    //calculating refracted ray\n    vec3 refracted = refract(vec3(0., 0., -1.), normal, .75);\n    \n    //displaying the reflected ray's destination\n    fragColor = texture(iChannel3, (fragCoord + 2. * center * refracted.xy / refracted.z) / iResolution.xy);\n    \n    \n    //---For Debugging---\n    //fragColor = vec4(normal + .5, 1.);\n    //fragColor = texelFetch(iChannel0, coord, 0).rrra+.5;\n    //fragColor += vec4(vec3(texelFetch(iChannel0, coord, 0).r), 1.);\n    //fragColor = vec4(refracted + .5, .0);\n}\n\n/*\n\n\tBuffers A and B share the nearly the same code. I didn't know how wise it \nwould be to make a nextFrame() function on common and make them use that, so I\nleft them that way. So suggestions on optimization and more are welcome.\n\n----------------------------[So how does it work?]-----------------------------\n\n(I of course may have made mistakes and typos in the following section, so beware...)\n\nIf you look up classical wave equation, you'd see something like this:\n\nü = c^2 ∇^2 u\n\nLet's turn that into this:\n\nü(s,t) = c^2 ∇^2 u(s,t)\n\nwhere;\n\nu is a function that takes space(a vector of n dimentions) and time\n\nü is u's second derivative with respect to time\n\nc is a constant, it is the speed that the waves travel at\n\nand ∇^2 u(s,t) is laplacian of u (with respect to the vector s), \n\nif you don't know what that is:\n\nLaplacian is the \"second derivative\" but for functions that take in multiple variables.\nWhere there is a mountain, it returns a negative value; \nwhere there is a valley, it returns a positive value.\n\nSo basically it is a measure of a point's neighbours. If a point seems to \nbe higher than its neighbours' average, it's neighbors get a negative score;\nif the point is at the top of a very steep mountain, its laplacian may be a\nvery low negative number.\n\nSo what this differential equation says is that, each point accelarates towards\ntheir neighbours. If a point seems to be above its neighbours, it will accelarate\ndownward.\n\nYou know how when simulating a ball thrown in the air, one approach is to look at\nits state at the previous two frames to get information about its velocity, then\nsum the velocity and its accelaration(euler integration)?\nTo put this into code, we use an approach like that:\n\n- we determine a point's velocity by substracting its value at the second to last \n  frame from its value at the previous frame.\n\n- then we determine its accelaration by looking at its and its neighbours values\n  To do this I used something called a laplacian kernel, that is known to be used \n  in edge detection software (apperantly). Then we multiply that by c^2.\n\n- then we add the velocity and accelaration to the previous value.\n\nThe result so far:\n\n\t\t\t\t\t\t\t\t  | 0 | 1 | 0 |\n\t\t\t\t\t\t\t\t  -------------\nn_x = n_x-1 + ( n_x-1 - n_x-2 ) + | 1 |-4 | 1 |[x-1] * c^2\n\t\t\t\t\t\t\t\t  -------------\n\t\t\t\t\t\t\t\t  | 0 | 1 | 0 |\n\nwhere n_i is the pixel's value at the frame i. \nand the weird square thing is the kernel applied centering the pixel at the frame x-1.\n\n\nWhen we do c^2 = 0.5, some terms cancel to turn it into this:\n\n\n\t  | 0 |.5 | 0 |\n\t  -------------\nn_x = |.5 | 0 |.5 |[x-1] - n_x-2\n\t  -------------\n\t  | 0 |.5 | 0 |\n\nAnd than you multiply it with an attenuation constant like 0.998 of course. This deviates \nfrom the mentioned equation but makes it more realistic(I think), mimicking(or simulating?) \nfriction. Also this constant is called \"damping\" in my code.\n\nAnd this is what you actually see in my code.\n\n(Then in the end the program renders a surface which refracts light and an image beyond that\nand of course mouse interaction, which is trivial, but I won't explain those, as they\ndigress from our topic here.)\n\nA question remains: why is making c^2 equal to 1/2 a good choise?\n\nWell, one thing that seperates this simulation from the continuous case is that c has\na limit. Each pixel is affected only by its immediate neighbours and its own old values,\nso waves can't travel faster that 1 pixel per frame. And they can't travel 1 pixel per \nframe either because I tried that and saw that the program just freaks out.\n(there is a link below if you want to experiment with it.)\n\nTo tackle this I made the following assumption:\n\nLet's define a system where the code starts running on an infinite plane where at frame \n-2 all values are 0. And at frame -1 all values are configured to make a checkerboard \npattern like 0, 1, 0, 1, 0 and so on. The assumption is that if a chosen c and d(attenuation \nconstant) value pair have the potential to ruin our program at some configurations, this \nwould be one of them. So the assumption says that testing a pair on the mentioned system\nis sufficient for determining if the pair is problematic or not.\n\n(by the way c and d are both floats between 0 and 1 since only that would make sense.)\n\nI spent some time tackling this problem and found that:\n\nc^2 <= ( ( 1 / d ) + 3 ) / 8\n\nSorry but I won't prove this here.\n\nI ended up using c^2 = 0.5 because when d is close to one the maximum value is pretty \nclose to .5 anyway and the terms cancelling is nice for reasons like performance, right? \n\nAnd I ended up making it faster by running the algorithm twice \neach frame.\n\n\nYou can experiment with too high c values here:\n\nhttps://www.shadertoy.com/view/3dyyRm\n\n\n\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    \n    //calculation\n    fragColor.r = .5 * ( texelFetchOffset(iChannel1, coord, 0, ivec2( 1,  0)).r\n    \t\t\t\t   + texelFetchOffset(iChannel1, coord, 0, ivec2(-1,  0)).r\n    \t\t\t\t   + texelFetchOffset(iChannel1, coord, 0, ivec2( 0,  1)).r\n    \t\t\t\t   + texelFetchOffset(iChannel1, coord, 0, ivec2( 0, -1)).r);\n    \n    fragColor.r = damping * ( fragColor.r - texelFetch(iChannel0, coord, 0).r );\n    \n    //adding mouse interaction\n    #ifndef altint\n    fragColor.r -= iMouse.z > 0.0 ? 3. * smoothstep(.02, 0., distance(fragCoord, iMouse.xy)/500.) : 0.;\n    #else\n    fragColor.r += texelFetch(iChannel0, coord, 0).g;\n    fragColor.g  = iMouse.z > 0.0 ? 10. * smoothstep(.025, 0., distance(fragCoord, iMouse.xy)/500.) : 0.;\n    fragColor.r -= fragColor.g;\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    \n    //calculation\n    fragColor.r = .5 * ( texelFetchOffset(iChannel1, coord, 0, ivec2( 1,  0)).r\n    \t\t\t\t   + texelFetchOffset(iChannel1, coord, 0, ivec2(-1,  0)).r\n    \t\t\t\t   + texelFetchOffset(iChannel1, coord, 0, ivec2( 0,  1)).r\n    \t\t\t\t   + texelFetchOffset(iChannel1, coord, 0, ivec2( 0, -1)).r);\n    \n    fragColor.r = damping * ( fragColor.r - texelFetch(iChannel0, coord, 0).r );\n    \n    //adding mouse interaction\n    #ifndef altint\n    fragColor.r -= iMouse.z > 0.0 ? 3. * smoothstep(.02, 0., distance(fragCoord, iMouse.xy)/500.) : 0.;\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define damping 0.998\n\n//#define altint\n//uncomment ^this line to change mouse interaction slightly","name":"Common","description":"","type":"common"}]}