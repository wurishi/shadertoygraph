{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\nvec3 cam;\n\nint cnt = 0;\nvec2 z = vec2(0.0, 0.0);\nfloat inst_zoom;\n\nvec2 fragCoord;\nvec4 fragColor;\n\nvec2 project() {\n\t// deal with our scaling and zooming\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y; // this replaces the 3, 2 coeffs\n\tp = cam.xy + pow(cam.z, 5.0)*p;\n\treturn p;\n}\n\nvoid circ(vec2 center, float limit, float radius, float thickness) {\n\t// by far the easiest - not disjoint!\n\tvec2 p = project();\n\tvec3 c = vec3(center.x, center.y, radius*pow(cam.z, 4.0));\n\tif(cam.z < limit) c.z = (radius*pow(limit, 10.0))/pow(cam.z, 6.0);\n\tif((pow((p.x-c.x), 2.0) + pow((p.y - c.y), 2.0) > pow(c.z, 2.0)) && // collide a circle\n\t   (pow((p.x-c.x), 2.0) + pow((p.y - c.y), 2.0) < pow((c.z+thickness*c.z), 2.0))) { // and a slightly bigger one to grab the ring\n\t\tfragColor = vec4(.25, .8, .5, 1.0);\n\t}\n}\n\nvoid rect(vec4 desc, float limit, float stretch, float thickness) {\n\t// desc = center, w, h\n\tvec2 p = project();\n\n\tif(cam.z < limit)\n\t\tinst_zoom = (stretch*pow(limit, 10.0))/pow(cam.z, 6.0);\n\telse\n\t\tinst_zoom = stretch*pow(cam.z, 4.0);\n\t\n\tdesc.zw *= inst_zoom;\n\n\tif(p.x > (desc.x - desc.z/2.0) && p.x < (desc.x + desc.z/2.0) && // collide against a big rect\n\t   p.y > (desc.y - desc.w/2.0) && p.y < (desc.y + desc.w/2.0)) {\n\t\tdesc.zw *= (1.0-thickness); // scale it down\n\t\tif(!(p.x > (desc.x - desc.z/2.0) && p.x < (desc.x + desc.z/2.0) && // and try again so we catch the \"border\"\n\t\t\t p.y > (desc.y - desc.w/2.0) && p.y < (desc.y + desc.w/2.0))) {\n\t\t\tfragColor = vec4(.25, .8, .5, 1.0);\n\t\t}\n\t}\n}\n\nvoid diamond(vec4 desc, float limit, float stretch, float thickness) {\n\t// desc = center, w, h\n\tvec2 p = project();\n\tfloat theta = degrees(pow(cam.z, 1.0));  // don't be mislead, theta is actually radians\n\n\tvec2 tmp = p;\n\tp.x = (tmp.x-desc.x)*cos(theta) - (tmp.y-desc.y)*sin(theta) + desc.x;\n\tp.y = (tmp.x-desc.x)*sin(theta) + (tmp.y-desc.y)*cos(theta) + desc.y;\n\t\n\tif(cam.z < limit)\n\t\tinst_zoom = (stretch*pow(limit, 10.0))/pow(cam.z, 6.0);\n\telse\n\t\tinst_zoom = stretch*pow(cam.z, 4.0);\n\tdesc.zw *= inst_zoom;\n\tif(p.x > (desc.x - desc.z/2.0) && p.x < (desc.x + desc.z/2.0) && // collide with the bigger rect\n\t   p.y > (desc.y - desc.w/2.0) && p.y < (desc.y + desc.w/2.0)) {\n\t\tdesc.zw *= (1.0-thickness); // shrink the inner rect by this much\n\t\tif(!(p.x > (desc.x - desc.z/2.0) && p.x < (desc.x + desc.z/2.0) && p.y > (desc.y - desc.w/2.0) && p.y < (desc.y + desc.w/2.0))) {\n\t\t\t// and then color it if we're in the area between the two\n\t\t\t// note the negation!\n\t\t\tfragColor = vec4(.25, .8, .5, 1.0);\n\t\t}\n\t}\n}\n\nvoid mainImage( out vec4 oFragColor, in vec2 iFragCoord )\n{\n    cam = vec3(-0.08896, 0.65405, clamp(1.0/iTime, 0.0, 1.0));;\n        \n    fragCoord = iFragCoord;\n\tvec2 p = project();\n\n\t// 100 orbits, we hit floating point resolution before that anyways\n\tfor (int i = 0; i < 100; ++i){\n\t\tif (z.x*z.x + z.y*z.y <= 4.0) { // values greater than 2 proven to escape - optimization courtesy of the internet\n\t\t\tz = vec2(z.x*z.x - z.y*z.y + p.x, z.r*z.y+z.y*z.r + p.y);\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// 100 = still inside! Paint it black.\n    if(cnt==100) {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else { \n    \t// otherwise something cooler.\n\t\tfloat col = (mod(float(cnt)+iTime*9.0,10.0)/10.0);\n\t\tfloat col2 = (mod(float(cnt)+iTime*2.0,10.0)/10.0);\n\t\tfragColor = vec4((col2+col2)/2.0, (col+col2)/2.0, col+.2, 1.1);\n\t}\n\t\n\n\t// these calls are where things get interesting. They add a shape to mark a region of interest.\n\t// I developed these myself through trial and error with pen, paper, and time.\n\t// The most important part is how it changes scaling functions after a threshhold zoom level is reached so you fly through the shape.\n\t// For this to work, the two scaling functions have to match up at the point where they overlap.\n\t// originally, this was achieved like so:\n    \n\t//if(cam.z < limit) inst_zoom = (stretch*pow(limit, 4.0))/(pow(limit, 4.0-(acc*(1.0/limit))))*pow(cam.z, 4.0-(acc*(1.0/limit)));\n\t//else inst_zoom = stretch*pow(cam.z, 4.0);\n\t\n\t//, where acc is limit / .1\n\t// If I plug these eqations into a CAS, they're reduced to: scale*limit^10 / zoom^6\n\t// so, for everyone's sake, I'm going to put those into the code here, even though you lose the ability to set the ease-out acceleration on a per-shape basis.\n\t// This makes it /just/ scoot out before you see it stop\n\n\tvec2 center = vec2(-.745, 0.186);\n\tcirc(center, .25, .1, .08);\n\t\n\tcenter = vec2(-1.74981, 0.0);\n\tdiamond(vec4(center, 1.0, 1.0), .17, .2, .08);\n\t\n\tcenter = vec2(-0.08896, 0.65405);\n\trect(vec4(center, 1.0, 1.0), .2, .2, .08);\n\toFragColor = fragColor;\n\t}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dlGzM","date":"1366019568","viewed":173,"name":"triple shape","username":"wjkeller","description":"brot","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["brot"],"hasliked":0,"parentid":"","parentname":""}}