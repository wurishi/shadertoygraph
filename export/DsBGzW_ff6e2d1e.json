{"ver":"0.1","info":{"id":"DsBGzW","date":"1684165718","viewed":259,"name":"Mathieu Group M12","username":"mla","description":"Émile Léonard Mathieu, born May 15th 1835 in Metz, discovered the earliest known sporadic simple groups, including the 95040 element permutation group M12, shown here. [url]https://en.wikipedia.org/wiki/%C3%89mile_L%C3%A9onard_Mathieu[/url]","likes":9,"published":3,"flags":16,"usePreview":0,"tags":["group","permutation","m12","mathieu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Mathieu Group M12, mla, May 15th 2023.\n//\n// Running through the 95040 permutations of the second smallest sporadic simple\n// group, the Mathieu group M12. The smallest, M11 is just the stabilizer subgroup\n// of one element in M12 so is effectively shown here too.\n//\n// The group is represented by a Sims table, see eg. TAOCP, Vol 4. for details,\n// but basically allows incrementally constructing a permutation of the group\n// element by element. The table is very simple for M12, which is sharply\n// 5-transitive, ie. there is exactly one permutation mapping five given elements\n// to any other five (so the leftmost five elements in the bottom row determine\n// the rest of the pattern).\n//\n// I've written this in a \"functional\" style, returning arrays directly from\n// functions, rather than using inout parameters or globals, this seems have\n// no impact on efficiency on the platforms I've tested on.\n//\n// 'x': one permutation per second rather than one per frame\n// 'r': generate permutations in a random order\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// M12  is generated by three permutations:\n// (1,2,3,4,5,6,7,8,9,10,0,11)\n// (11,10,5,7,8,2,9,3,4,6,1,0)\n// (0,1,6,9,5,3,10,2,8,4,7,11)\n\nconst int M = 5, N = 12;\nconst int maxrank = 12*11*10*9*8; // 12C5\nconst int[(2*N-M+1)/2*M*N] sims =\n  int[] (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         //0, 1, 2, 3, 11, 8, 9, 5, 10, 4, 7, 6, // Alternative first entry\n         1, 0, 2, 3, 4, 8, 6, 10, 5, 11, 7, 9,\n         2, 0, 1, 3, 4, 9, 6, 5, 10, 7, 11, 8,\n         3, 0, 1, 2, 4, 11, 6, 7, 8, 5, 9, 10,\n         4, 0, 1, 2, 3, 5, 6, 10, 9, 11, 8, 7,\n         5, 0, 1, 2, 3, 6, 10, 4, 8, 7, 11, 9,\n         6, 0, 1, 2, 3, 10, 4, 5, 11, 9, 7, 8,\n         7, 0, 1, 2, 3, 11, 8, 9, 5, 10, 4, 6,\n         8, 0, 1, 2, 3, 9, 7, 11, 10, 5, 6, 4,\n         9, 0, 1, 2, 3, 7, 11, 8, 6, 4, 5, 10,\n         10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11,\n         11, 0, 1, 2, 3, 8, 9, 7, 4, 6, 10, 5,\n\n         0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         0, 2, 1, 3, 4, 10, 6, 11, 9, 8, 5, 7,\n         0, 3, 1, 2, 4, 8, 6, 9, 11, 10, 7, 5,\n         0, 4, 1, 2, 3, 9, 6, 8, 5, 7, 10, 11,\n         0, 5, 1, 2, 3, 8, 10, 11, 6, 9, 4, 7,\n         0, 6, 1, 2, 3, 11, 4, 7, 10, 8, 5, 9,\n         0, 7, 1, 2, 3, 5, 8, 4, 11, 6, 9, 10,\n         0, 8, 1, 2, 3, 10, 7, 6, 9, 4, 11, 5,\n         0, 9, 1, 2, 3, 6, 11, 5, 7, 10, 8, 4,\n         0, 10, 1, 2, 3, 7, 5, 9, 4, 11, 6, 8,\n         0, 11, 1, 2, 3, 4, 9, 10, 8, 5, 7, 6,\n\n         0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         0, 1, 3, 2, 4, 7, 6, 5, 10, 11, 8, 9,\n         0, 1, 4, 2, 3, 10, 6, 11, 7, 5, 9, 8,\n         0, 1, 5, 2, 3, 4, 10, 7, 9, 6, 8, 11,\n         0, 1, 6, 2, 3, 5, 4, 9, 8, 10, 11, 7,\n         0, 1, 7, 2, 3, 9, 8, 10, 6, 11, 5, 4,\n         0, 1, 8, 2, 3, 11, 7, 5, 4, 9, 10, 6,\n         0, 1, 9, 2, 3, 8, 11, 4, 10, 7, 6, 5,\n         0, 1, 10, 2, 3, 6, 5, 8, 11, 4, 7, 9,\n         0, 1, 11, 2, 3, 7, 9, 6, 5, 8, 4, 10,\n\n         0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         0, 1, 2, 4, 3, 11, 6, 10, 9, 8, 7, 5,\n         0, 1, 2, 5, 3, 7, 10, 4, 8, 11, 9, 6,\n         0, 1, 2, 6, 3, 9, 4, 5, 11, 7, 8, 10,\n         0, 1, 2, 7, 3, 10, 8, 9, 5, 4, 6, 11,\n         0, 1, 2, 8, 3, 5, 7, 11, 10, 6, 4, 9,\n         0, 1, 2, 9, 3, 4, 11, 8, 6, 5, 10, 7,\n         0, 1, 2, 10, 3, 8, 5, 6, 7, 9, 11, 4,\n         0, 1, 2, 11, 3, 6, 9, 7, 4, 10, 5, 8,\n\n         0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         0, 1, 2, 3, 5, 6, 10, 9, 11, 8, 4, 7,\n         0, 1, 2, 3, 6, 10, 4, 8, 7, 11, 5, 9,\n         0, 1, 2, 3, 7, 11, 8, 6, 4, 5, 9, 10,\n         0, 1, 2, 3, 8, 9, 7, 4, 6, 10, 11, 5,\n         0, 1, 2, 3, 9, 7, 11, 10, 5, 6, 8, 4,\n         0, 1, 2, 3, 10, 4, 5, 11, 9, 7, 6, 8,\n         0, 1, 2, 3, 11, 8, 9, 5, 10, 4, 7, 6);\n\n// Permutation (n,i) in table, for 0 <= n < 5, i >= n,\n// is the identity on elements 0..n-1, and puts element\n// i at position n.\nint simsindex(int n, int i) {\n  assert(i >= n);\n  assert(i < N);\n  return i + n*N-n*(n+1)/2;\n}\n\nint[N] get(int ix) {\n  int res[N], base = N*ix;\n  for (int i = 0; i < N; i++) res[i] = sims[base+i];\n  return res;\n}\n\nint[N] invert(int s[N]) {\n  int t[N];\n  for (int i = 0; i < N; i++) t[s[i]] = i;\n  return t;\n}\n\nint[M] apply(int s[N], int t[M]) {\n  for (int i = 0; i < M; i++) t[i] = s[t[i]];\n  return t;\n}\n\nint[N] apply(int s[N], int t[N]) {\n  for (int i = 0; i < N; i++) t[i] = s[t[i]];\n  return t;\n}\n\nconst int identity[] = int[](0,1,2,3,4,5,6,7,8,9,10,11);\n\nint[M] m12(int p[M]) {\n  int perms[M];\n  for (int i = 0; i < M; i++) {\n    int k = simsindex(i,p[i]);\n    perms[4-i] = k;\n    p = apply(invert(get(k)),p);\n  }\n  return perms;\n}\n\nint[M] unrank(int n) {\n  int p[M], s[N] = identity;\n  int k = maxrank;\n  for (int i = 0; i < M; i++) {\n    k /= N-i;\n    for (int j = n/k; j > 0; j--) {\n      swap(s[i+j],s[i+j-1]);\n    }\n    p[i] = s[i];\n    n %= k;\n  }\n  return p;\n}\n\nvec3 getcolor(int index) {\n  vec3 colors[N] =\n    vec3[](vec3(0.996078,0.152941,0.0705882),\n           vec3(0.988235,0.376471,0.0392157),\n           vec3(0.984314,0.6,0.00784314),\n           vec3(0.988235,0.8,0.101961),\n           vec3(0.996078,0.996078,0.2),\n           vec3(0.698039,0.843137,0.196078),\n\n           vec3(0.4,0.690196,0.196078),\n           vec3(0.203922,0.486275,0.596078),\n           vec3(0.00784314,0.278431,0.996078),\n           vec3(0.266667,0.141176,0.839216),\n           vec3(0.52549,0.00392157,0.686275),\n           vec3(0.760784,0.0784314,0.376471));\n\n  assert(index >= 0);\n  assert(index < N);\n  vec3 col = colors[index];\n  //col = h2rgb(float(index)/float(N));\n  return pow(col,vec3(2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float timestamp = floor(iTime);\n  if (!key(CHAR_X)) timestamp = float(iFrame);\n  if (timestamp + 1.0 == fragColor.a) return;\n  vec2 pos = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  pos *= 3.5*vec2(1,-1);\n  pos += vec2(5.5,2.5);\n\n  int rank = int(timestamp);\n  if (key(CHAR_R)) rank = randint(rank,maxrank);\n\n  int perms[M] = m12(unrank(rank%maxrank));\n\n  int col = int(round(pos.x));\n  int row = int(floor(pos.y));\n  vec3 color = vec3(0);\n  float px = 1.25*fwidth(pos.x);\n\n  if (row >= 0 && row < M) {\n    float d = 1e8;\n    int s[N] = identity, u[N] = identity, v[N], j;\n    for (j = 0; j < M; j++) {\n      s = apply(get(perms[j]),s);\n      v = invert(s);\n      if (j == row) break;\n      u = v;\n    }\n    for (int i = 0; i < N; i++) {\n      d = min(d,segment(pos,vec2(u[i],j),vec2(v[i],j+1)));\n    }\n    color = mix(vec3(1),color,smoothstep(0.0,px,d-0.01));\n  }\n\n  if (col >= 0 && col < N) {\n    int s[] = identity;\n    for (int j = 0; j <= M; j++) {\n      if (round(pos.y) == float(j)) {\n        float d = distance(pos,vec2(col,j));\n        color = mix(getcolor(s[col]),color,smoothstep(0.0,px,d-0.2));\n        break;\n      }\n      if (j == M) break;\n      s = apply(get(perms[j]),s);\n    }\n  }\n  color = pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  fragColor = vec4(color,timestamp+1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.1415927;\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return rgb;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nint randint(int seed, int mod) {\n  return int(ihash(uint(seed))%uint(mod));\n}\n\nint swap(inout int i, inout int j) {\n  int t = j; j = i; i = t;\n  return t;\n}\n","name":"Common","description":"","type":"common"}]}