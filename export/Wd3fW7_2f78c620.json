{"ver":"0.1","info":{"id":"Wd3fW7","date":"1605199388","viewed":80,"name":"Cellar periodic rules automata","username":"Qwer643","description":"What if instead of neighbors we use the coordinates calculated by the formula from the cell value?","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","automata","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* based on implementation of Conway's Game of Life\nhttps://www.shadertoy.com/view/MtdXRn \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    fragColor = vec4(color.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    float neighbors = 0.0;\n    \n    for(float i = -1.0; i <= 1.0; i += 1.0)\n    {\n        for( float j = -1.0; j <= 1.0; j += 1.0)\n        {\n        \tvec2 offset = vec2(i, j)*3. / iResolution.xy;\t\t// Scale the offset down\n        \tvec4 lookup = texture(iChannel0, uv + offset); \t// Apply offset and sample\n        \tneighbors += lookup.r;\t\t\t\t\t\t\t// Accumulate the result\n        }\n    }\n    \n    float cell = texture(iChannel0, uv).r;\n    /*\n\t\tТеперь нам нужно применить правила чтобы расчитать состояние клетки в этой итерации.\n\t\t\n\t\tТеперь будем не выставлять ровное значение, а прибавлять или отнимать от текущего.\n\t*/\n    if(cell > 0.0) {\n        if(neighbors >= 2.0 && neighbors <= 5.0) {\n            color = vec3( (sin(iTime)+1.5)*0.5, 0.0, 1.0 );// 0.3);\n        }\n    } else if(neighbors > 2.0 && neighbors < 4.0) {\n    \tcolor += vec3(0.2, 0., 0.1);\n    }\n    \n    // start position\n    if(iTime < 0.6) { \n        color = vec3(texture(iChannel1, fragCoord.xy / iResolution.xx).x*.5);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}