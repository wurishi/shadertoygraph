{"ver":"0.1","info":{"id":"4fsSWM","date":"1705453608","viewed":155,"name":"XYZ Chromaticity","username":"spalmer","description":"@[url=http://shadertoy.com/user/Tynach]Tynach[/url]'s tech is awesome and has the definitive toy for this, but I could not help :love: loving the way they parameterize the whole confusing mess, and trying to simplify it to the point where I can grok it.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["rgb","xyz","colorspace","colorspace","srgb","gamut","cie","horseshoe","cmf"],"hasliked":0,"parentid":"ssjSDc","parentname":"Bounded xy chromaticity diagram"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks, Tynach, I need some straightforward sensibility in my life.  This helps.\n// http://shadertoy.com/view/ssjSDc\n// perhaps I should have forked the older unbounded toy instead\n// http://shadertoy.com/view/lllcWX\n// LMS locus idea from nazlbit http://shadertoy.com/view/ctG3Rz\n// some of this got cross-pollinated over into http://shadertoy.com/view/7l2XDw\n\n// can't hurt to ask!\nprecision highp float;\n\n// Preprocessor 'functions' that help build colorspaces as constants\n#define uvw(u,v) \\\n    vec3((u), (v), 1. - (u) - (v))\n// XYZ mat3 from 3 pairs of chromaticity xy coordinates (z derived from xy)\n#define Primaries(rx,ry, gx,gy, bx,by) \\\n\tmat3(uvw(rx,ry), uvw(gx,gy), uvw(bx,by))\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define White(x, y) \\\n\tuvw(x,y) //vec3((x)/(y), 1, (1. - (x) - (y))/(y)) //\n/*\n// Calculates x coordinate for a white point on the daylight locus, given the\n// correlated color temperature 't'\n#define WhiteDx(t) \\\n\tdot(t <= 7000. \\\n\t       ? vec4(.244063, 99.11, 2967800, -4607000000) \\\n\t       : vec4(.23704, 247.48, 1901800, -2006400000), \\\n\t    1./vec4(1, (t), pow((t), 2.), pow((t), 3.)))\n\n// Calculates xy coordinates for a white point on the daylight locus, given the\n// correlated color temperature 't'\n#define WhiteD(t) \\\n\tWhite(WhiteDx(t), \\\n\t      -3.0*pow(WhiteDx(t), 2.0) + 2.87*WhiteDx(t) - 0.275)\n*/\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v) \\\n\tmat3( \\\n\t\t(v).x, 0., 0., \\\n\t\t0., (v).y, 0., \\\n\t\t0., 0., (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space) \\\n\t(space.primaries * diag((inverse(space.primaries)*space.white)))\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space) \\\n\tinverse(rgbToXyz(space))\n\n\n// not really an RGB color space at all, but you can treat like one, sort of\nconst mat3 primariesXYZ = mat3(1); /*Primaries(\n\t1., 0.,\n\t0., 1.,\n\t0., 0.\n);*/\n\n// Chromaticities for RGB primaries\n\n// Original CIE RGB primaries, formed from monochromatic (single-wavelength) colors:\n// R = 700nm, G = 546.1nm, B = 435.8nm\nconst mat3 primariesCie = Primaries(\n\t0.734690, 0.265310,\n\t0.273675, 0.717432,\n\t0.166536, 0.008881\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://cvrl.org/ciepr8dp.htm, and\n// http://cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\nconst mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);\n\n/*\n// TODO from nazlbit http://shadertoy.com/view/XcfSD7\nconst mat3 E_D50 = mat3( 0.9977545, -0.0041632, -0.0293713,\n                        -0.0097677,  1.0183168, -0.0085490,\n                        -0.0074169,  0.0134416,  0.8191853);\n\nconst mat3 XYZ_WGRGB = mat3( 1.4628067, -0.1840623, -0.2743606,\n                            -0.5217933,  1.4472381,  0.0677227,\n                             0.0349342, -0.0968930,  1.2884099);\n*/\n\n// Chromaticities for white points\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n// Standard illuminant ICC D65,  6504K whitepoint as used in both sRGB and Rec 709\nconst vec3 whiteD65S = White(0.3127, 0.3290);\n\n// Standard illuminant ICC D50,  5003 K  whitepoint recommended for Rec. 709 and sRGB, in float\nconst vec3 whiteD50I = White(3214.0/9297.0, 10000.0/27891.0);\n\n// White balance for LMS so that each channel's spectral sensitivities peak at\n// exactly 1.0, at least according to the 2006 cone fundamentals\n//const vec3 whiteLmsUnity = White(89766673.0/387074477.0, 103822461.0/387074477.0);\nconst vec3 whiteLmsUnity = vec3(0.89766673, 1.03822461, 1.93485343);\n\n// Linear (RGB) Colorspaces\n\n// Parameters for a colorspace\nstruct colorspace \n{\n\t// XYZ Chromaticity coordinates for Red, Green, and Blue primaries in [0], [1], [2] respectively\n\tmat3 primaries;\n\n\t// XYZ Chromaticity coordinates for white point\n\tvec3 white;\n};\n\n// Rec. 709 (HDTV)\nconst colorspace Rec709 = colorspace(primaries709, whiteD65S); //, gam170m);\n\n// Rec. 2020 (with linear gamma)\nconst colorspace Rec2020 = colorspace(primaries2020, whiteD65S); //, gam170m);\n\n// LMS RGB space\nconst colorspace LmsRgb = colorspace(primariesLms, whiteLmsUnity); //, gam10);\n\n// not really an RGB colorspace at all, really\nconst colorspace XYZ = colorspace(primariesXYZ, whiteD65S); //whiteD50I); //, gam10);\n\n// Change these to change what colorspace is being converted from/to\nconst colorspace from = XYZ; //Rec709; //\nconst colorspace to = Rec2020; //Rec709; //\n\nconst mat3 toLms = xyzToRgb(LmsRgb);\nconst mat3 frLms = rgbToXyz(LmsRgb);\n\n/*\nconst vec3 whiteCam = to.white;\nconst mat3 whiteBalFr = diag((toLms*whiteCam)/(toLms*from.white));\nconst mat3 whiteBalTo = diag((toLms*whiteCam)/(toLms*to.white));\n\nconst mat3 toRgb1 = xyzToRgb(from)*frLms*inverse(whiteBalFr)*toLms;\nconst mat3 frRgb1 = frLms*whiteBalFr*toLms*rgbToXyz(from);\nconst mat3 toRgb2 = xyzToRgb(to)*frLms*inverse(whiteBalTo)*toLms;\nconst mat3 frRgb2 = frLms*whiteBalTo*toLms*rgbToXyz(to);\n\nconst mat3 conv = toRgb2*frRgb1;\n*/\n\n// Conversion Functions\n/*\n// Converts RGB colors to a linear light scale\nvec3 toLinear(vec3 color, const transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off) / (1. + trc.off), vec3(trc.power));\n\tvec3 lower = color / trc.slope;\n\tvec3 neg = -pow((color - trc.off) / (-1. - trc.off), vec3(trc.power));\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec3 toGamma(vec3 color, const transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-trc.cutoffToGamma));\n\tvec3 higher = (1. + trc.off) * pow(color, vec3(1. / trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1. - trc.off) * pow(-color, vec3(1. / trc.power)) + trc.off;\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\treturn color;\n}\n*/\n// this I didn't understand or was getting too complex for me\n\n// Scales a color to the closest in-gamut representation of that color\n/*\nvec3 gamutScale(vec3 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.)));\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = (high - 1.)/(high - luma);\n\tfloat scale = max(lowScale, highScale);\n\tcolor.rgb += scale*(luma - color.rgb);\n\treturn color;\n}\n*/\n\n// Converts from xy to RGB\nvec3 convert(vec3 color)\n{\n    /*const mat3 \n        frRgb1 = mat3(1), //RgbToxyz(from),\n        toRgb1 = xyzToRgb(to),\n        toRgb2 = toRgb1,\n        conv = toRgb2*frRgb1;*/\n\tfloat luma = 1.000001;\n\nconst vec3 whiteCam = to.white;\nconst mat3 whiteBalFr = diag((toLms*whiteCam)/(toLms*from.white));\nconst mat3 whiteBalTo = diag((toLms*whiteCam)/(toLms*to.white));\n\nconst mat3 toRgb1 = xyzToRgb(from)*frLms*inverse(whiteBalFr)*toLms;\nconst mat3 frRgb1 = frLms*whiteBalFr*toLms*rgbToXyz(from);\nconst mat3 toRgb2 = xyzToRgb(to)*frLms*inverse(whiteBalTo)*toLms;\nconst mat3 frRgb2 = frLms*whiteBalTo*toLms*rgbToXyz(to);\n\nconst mat3 conv = toRgb2*frRgb1;\n\t// Convert from xyY to XYZ, then RGB\n\tcolor.xyz *= luma / color.y;\n\tcolor.rgb = toRgb1 * color.xyz;\n\n\t// Max normalization\n\t//color.rgb /= max(color.r, max(color.g, color.b));\n\n\t// Standard Euclidian normalization (equivalent to 'norm = 2.0' below)\n\t//color.rgb = normalize(color.rgb);\n\n\t// Custom normalization for brighter white point\n\t// Wikipedia's chart roughly uses 'norm = 5.0'\n\tconst float norm = 4.;\n\tcolor.rgb *= pow(dot(pow(abs(color.rgb), vec3(norm)), vec3(1)), -1./norm);\n\n\t// Wikipedia's description for one of their chromaticity diagrams claims\n\t// that the top left should have more cyan than most charts do. This\n\t// is solved by scaling out-of-gamut colors to be in-gamut\n\t//color = gamutScale(color, luma);\n   #if 0\n   // actually causes some out-of-range colors near red corner of my test RGB\n\t// Scale colors so that the highest RGB value for the white point or primaries\n\t// of the 'from' colorspace, is scaled to equal 1.0 in the 'to' colorspace\n\tconst vec3\n        newCyan    = conv * vec3(0, 1, 1),\n\t    newMagenta = conv * vec3(1, 0, 1),\n\t    newYellow  = conv * vec3(1, 1, 0),\n\t    newWhite   = conv * vec3(1),\n\t    maxColors =\n            max(conv[0], max(conv[1], max(conv[2],\n            max(newCyan, max(newMagenta, max(newYellow, newWhite))))));\n\n\tcolor.rgb /= max(maxColors.r, max(maxColors.g, maxColors.b));\n   #endif\n\t// Grab new luma values to emulate display brightness more accurately\n\tluma = (frRgb1*color.rgb).y;\n\n\t// Convert from one colorspace to another, to show how one display\n\t// might show the colorspace of another\n\tcolor.rgb = conv*color.rgb;\n\t//color = gamutScale(color, luma);\n\treturn color;\n}\n\n// optimized nazlbit http://shadertoy.com/view/XcfSD7 http://wikipedia.org/wiki/CIE_1931_color_space#Color_matching_functions\nfloat LobeC(float l, float lo, float hi)\n{\n    return exp2(-.5 / log(2.) * (l < 0. ? lo : hi) * l * l);\n}\n// spalmer2024C\nvec3 wl2XYZ(float l)\n{\n    return vec3(\n       #if 0\n          // matches the 2031 CIE XYZ data\n        1.056 * LobeC(l - 599.8, .00069618, .00104058) + \n         .362 * LobeC(l - 442. , .00390625, .00140274) -\n         .065 * LobeC(l - 501.1, .00240292, .00145679), \n         .821 * LobeC(l - 568.8, .00045463, .00060966) + \n         .286 * LobeC(l - 530.9, .00376378, .00103390),\n        1.217 * LobeC(l - 437. , .00718184, .00077160) +\n         .681 * LobeC(l - 459. , .00147929, .00525100));\n       #else\n          // matches the 2006 CIE XYZ data better?\n        1.110 * LobeC(l - 601. , .00071000, .00104058) + \n         .350 * LobeC(l - 442. , .00390625, .00140274) -\n         .065 * LobeC(l - 501. , .00240292, .00145679), \n         .82  * LobeC(l - 571. , .00045463, .00060966) + \n         .282 * LobeC(l - 532. , .00376378, .00103390),\n        1.17  * LobeC(l - 435. , .00718184, .00077160) +\n         .681 * LobeC(l - 459. , .00147929, .00525100))\n       #endif\n        ;\n}\nvec2 xyz_xy(vec3 xyz) \n{\n    return xyz.xy / (xyz.x + xyz.y + xyz.z);\n}\n// based on Nazlbit  http://shadertoy.com/view/ctG3Rz\n// Works!  now just needs antialiasing.  TODO\n// it's close now.  think it's measuring from the edge going the wrong way somehow.\nfloat horseshoeAlaNazlbit(vec3 xyz)\n{\n    const int num_samples = 48;\n    float visible_range_min = 440., visible_range_max = 645.,\n        w = visible_range_min;\n    vec2 uv = xyz.xy,\n        prev_xy = xyz_xy(wl2XYZ(w));\n    float d = -9e9;\n    for (int i = 1; i < num_samples + 2; ++i) {\n        w = mix(visible_range_min, visible_range_max,\n                float(i % (num_samples + 1)) / float(num_samples));\n        vec2 xy = xyz_xy(wl2XYZ(w)), h = mix(xy, prev_xy, .5);\n        float z = cross(vec3(xy - h, 0) / dot(uv - h, uv - h), vec3(uv - h, 0)).z;\n        if (z > .01) return 0.; // optimize\n        prev_xy = xy;\n        d = max(d, z);\n    }\n    return clamp(4e2 * sqrt(max(0., -d)), 0., 1.);\n}\n\n// For the 'horseshoe' boundary MLS locus diagram, would\n// rather try to invert the CMF than include some huge table!\n// I made a crude piecewise linear approximation to the horseshoe in LMS space.\nfloat horseshoePlanarApproxLMSSpalmer(vec3 xyz)\n{\n    vec3 lms = toLms * xyz;\n    return clamp(.5 + 300. * \n        min(lms.y-.02*lms.x - .014,\n        min(lms.x - .011,\n        min(lms.y-.02*lms.x - .014,\n        min(lms.x - .011,\n        min(lms.z - .0,\n        min(.13 - lms.y + 1.225 * lms.x,\n        min(.964 - lms.y,\n        min(.028 - lms.y + 1.5 * lms.x,\n        min(.264 - lms.y + lms.x,\n        min(.43 - lms.z,\n        min(.091 - lms.y + 1.3 * lms.x,\n            .738 - lms.x\n        ))))))))))), 0., 1.);\n}\n\nfloat Horseshoe(vec3 xyz)\n{\n    return horseshoeAlaNazlbit //horseshoePlanarApproxLMSSpalmer //\n        (xyz);\n}\n/*\n// Distance from line segment\nfloat segDist(vec2 pos, vec2 p1, vec2 p2)\n{\n\tvec2 ray = p2 - p1;\n\tfloat lenSq = dot(ray*ray, vec2(1));\n\tfloat perp = clamp(dot(pos - p1, ray) / lenSq, 0.0, 1.0);\n\tvec2 proj = p1 + perp*ray;\n\treturn distance(pos, proj);\n}\n*/\n// Neyret http://shadertoy.com/view/7sfXDn\nfloat bayer(vec2 u, float n)\n{\n    n = exp2(2.*n); float x = .5/n, z = 1.;\n    for (vec2 a = floor(u); z < n; z *= 4., a = floor(a *= .5))\n        x += fract(.5 * a.x + .75 * a.y * a.y) / z;\n    return x;\n}\n\n\n// FIXME at this point I have deconstructed it to the point\n// where I've totally botched the original colors.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\t// Maximum logical coordinates guaranteed to be shown\n\tconst vec2 bounds = vec2(.8, 1.);\n\tfloat aa = max(bounds.x/iResolution.x, bounds.y/iResolution.y);\n\t// center chart then scale to fit bounding size\n\tvec2 uv = aa * (fragCoord - .5 * (iResolution.xy - bounds / aa));\n\n    vec3 color = vec3(uv, 1. - uv.x - uv.y);\n\n    float horseshoe = Horseshoe(color);\n    // removed white balance for now\n    //float rgbDistFr = 9e9, rgbDistTo = 9e9;\n    //for (int i = 3; i-- > 0; ) \n    //    rgbDistFr = min(rgbDistFr, segDist(color.xy, from.primaries[ i    ].xy, from.primaries[(i+1)%3].xy)),\n    //    rgbDistTo = min(rgbDistTo, segDist(color.xy,   to.primaries[ i    ].xy,   to.primaries[(i+1)%3].xy));\n\n\t//float drgb = min(rgbDistFr, rgbDistTo) / aa;\n    // convert to XYZ if not already there\n    //color = convert(color);\n     // new, wrecks write point though FIXME\n\t// Convert to RGB\n    // hopefully I've at least gotten the matrix multiply correct\n    color = from.primaries * color;\n\tcolor /= from.white;\n    //color *= to.white / from.white; // simpler white point convert not using LMS space .. not working as expected\n    //color = xyzToRgb(to) * color;\n    //color *= 1.9; // HACK\n    color *= to.white;\n    color /= 1e-9 + max(color.r, max(color.g, color.b)); // divide by largest component to brighten \n    color = inverse(to.primaries) * color;\n    color /= 1e-9 + max(color.r, max(color.g, color.b)); // rebrighten again in RGB?! HACK\n    // so my white balance exhibits bands... maybe that's why they did theirs that way.\n    \n    // and turn imaginary colors black   FIXME needs antialiasing\n    if (any(   lessThan(color, vec3(0)))) color *= .5;\n    \n    // clip to approximation to horseshoe LMS curve boundary\n    color = mix(vec3(.7), color, horseshoe);\n    \n\t// triangles showing both RGB color spaces' gamuts\n\t//color = mix(vec3(.5), color, clamp(drgb - 1./4., 0., 1.));\n    // I get this now just by darkening imaginary colors above\n\n    // TODO read up on gamut clipping http://bottosson.github.io/posts/gamutclipping/\n    // implement something better than clamping RGB to 0,1\n    // original toy had some stuff, I just didn't want to deal with at the time\n    // Nazlbit has a relatively simple clipping here http://shadertoy.com/view/XcfSD7\n\tcolor = clamp(color, 0., 1.);\n    // since Shadertoy can't provide any guarantees about output gamma anyway, some hack OETF will do\n    color = sqrt(color);\n    // dither for expected 8 bpc output quantization\n    color += exp2(-8.) * (bayer(fragCoord, 8.) - .5);\n    \n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}