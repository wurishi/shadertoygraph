{"ver":"0.1","info":{"id":"ttlGzj","date":"1556974149","viewed":240,"name":"gridcube","username":"ukeyshima","description":"gridcube","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define ROW_SIZE 2.0\n#define GRID_SIZE 4.0\n\nvec3 cPos = vec3(0.0, 0.0, -20.0);\nconst vec3 cDir = vec3(0.0, 0.0, 1.0);\nconst vec3 cUp = vec3(0.0, 1.0, 0.0);\nconst float depth = 1.0;\nconst vec3 lPos = vec3(10.0,10.0,-10.0);\n\nfloat random1(vec3 p){\n    return fract(sin(dot(p.xyz,vec3(12.9898,46.2346,78.233)))*43758.5453123);\n}\nfloat random2(vec3 p){\n    return fract(sin(dot(p.xyz,vec3(73.6134,21.6712,51.5781)))*51941.3781931);\n}\nfloat random3(vec3 p){\n    return fract(sin(dot(p.xyz,vec3(39.1831,85.3813,16.2981)))*39183.4971731);\n}\nfloat perlinNoise(vec3 p){    \n  float t=iTime-mod(iTime,0.4);\n    p.z=p.z*t;\n    vec3 i1=floor(p);    \n    vec3 i2=i1+vec3(1.0,0.0,0.0);\n    vec3 i3=i1+vec3(0.0,1.0,0.0);\n    vec3 i4=i1+vec3(1.0,1.0,0.0);\n    vec3 i5=i1+vec3(0.0,0.0,1.0);\n    vec3 i6=i1+vec3(1.0,0.0,1.0);\n    vec3 i7=i1+vec3(0.0,1.0,1.0);\n    vec3 i8=i1+vec3(1.0,1.0,1.0);\n    vec3 f1=vec3(random1(i1),random2(i1),random3(i1));\n    vec3 f2=vec3(random1(i2),random2(i2),random3(i2));\n    vec3 f3=vec3(random1(i3),random2(i3),random3(i3));\n    vec3 f4=vec3(random1(i4),random2(i4),random3(i4));\n    vec3 f5=vec3(random1(i5),random2(i5),random3(i5));\n    vec3 f6=vec3(random1(i6),random2(i6),random3(i6));\n    vec3 f7=vec3(random1(i7),random2(i7),random3(i7));\n    vec3 f8=vec3(random1(i8),random2(i8),random3(i8));\n    vec3 k1=p-i1;\n    vec3 k2=p-i2;\n    vec3 k3=p-i3;\n    vec3 k4=p-i4;\n    vec3 k5=p-i5;\n    vec3 k6=p-i6;\n    vec3 k7=p-i7;\n    vec3 k8=p-i8;\n    vec3 j=fract(p);\n    j=j*j*(3.0-2.0*j);\n\treturn mix(mix(mix(dot(f1,k1),dot(f2,k2),j.x),mix(dot(f3,k3),dot(f4,k4),j.x),j.y),mix(mix(dot(f5,k5),dot(f6,k6),j.x),mix(dot(f7,k7),dot(f8,k8),j.x),j.y),j.z)*0.5+0.5;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat boxDistFunc(vec3 p,vec3 b){\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat distFunc(vec3 p,vec3 ray) {  \n  p=rotate(p,iTime,vec3(1.0,0.0,1.0));\n  ray=rotate(ray,iTime,vec3(1.0,0.0,1.0));\n  vec3 q=p;\n  float dist=0.0;\n  for(float i=0.0;i<ROW_SIZE+1.0;i++){    \n    p=abs(p);\n    p.xyz-=GRID_SIZE/2.0;\n  }    \n  dist=boxDistFunc(p, vec3(GRID_SIZE/2.0-0.3));   \n  if((q.x<GRID_SIZE*ROW_SIZE) && (q.x>-GRID_SIZE*ROW_SIZE) && (q.y<GRID_SIZE*ROW_SIZE) && (q.y>-GRID_SIZE*ROW_SIZE) && (q.z<GRID_SIZE*ROW_SIZE) && (q.z>-GRID_SIZE*ROW_SIZE)){        \n        vec3 c=mod(q,GRID_SIZE);\n        float coordinatesRandom=perlinNoise(q-c);\n        if(coordinatesRandom<0.5){\n          dist = (min(min((GRID_SIZE*step(0.0,ray.x)-c.x)/ray.x,(GRID_SIZE*step(0.0,ray.y)-c.y)/ray.y),(GRID_SIZE*step(0.0,ray.z)-c.z)/ray.z)+0.001);\n        }\n    }\n    return dist;\n}\n\nvec3 getNormal(vec3 p,vec3 ray) {\n  float d = 0.001;\n  return normalize(\n      vec3(distFunc(p + vec3(d, 0.0, 0.0),ray) - distFunc(p + vec3(-d, 0.0, 0.0),ray),\n           distFunc(p + vec3(0.0, d, 0.0),ray) - distFunc(p + vec3(0.0, -d, 0.0),ray),\n           distFunc(p + vec3(0.0, 0.0, d),ray) - distFunc(p + vec3(0.0, 0.0, -d),ray)));\n}\n\nvec3 rayMarching(vec3 color, vec2 p) {  \n  vec3 cSide = vec3(1.0,0.0,0.0);\n  vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * depth);\n  vec3 rPos = cPos;    \n  for (float i = 0.0; i < 30.0; i++) {           \n    float distance = distFunc(rPos,ray);\n    rPos += distance*ray;    \n    if (distance < 0.11) {\n      vec3 normal = getNormal(rPos,ray);\n      vec3 lVec = normalize(lPos - rPos);      \n      float diffuse = clamp(dot(normal, lVec), 0.1, 1.0) + 0.1;\n      float specular = pow(clamp(dot(normal, lVec), 0.0, 1.0), 50.0);            \n      vec3 rrp=rotate(rPos,iTime,vec3(1.0,0.0,1.0));\n      vec3 srp=rrp-mod(rrp,GRID_SIZE);\n      color=vec3(random1(srp),random2(srp),random3(srp))*1.9;\n      color = (color * diffuse + specular);\n      break;      \n    }                          \n    if(rPos.z>1000.0){\n      break;\n    }  \n  }\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p =\n      (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color = rayMarching(vec3(0.1), p);\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define A 0.2\nfloat kick(float time,float a) {\n    return sin(6.283*a*time-1.0*exp(-100.0*time))*exp(-time*10.6);\n}\nfloat sequence(int s,float time){\n  float n =mod(time,A);\n  for(int i=0;i<16;i++){\n    if((s>>(int(time/A)-i)%16&1)==1)break;\n    n+=A;\n  }\n  return n;\n}\nvec2 mainSound( in int samp, float time ){     \n    float t=time-mod(time,0.2);   \n \t  return vec2(\n       0.5*kick(sequence(0xAAAA,time),100.0)+\n       0.5*kick(sequence(0x5555,time),1000.0)\n     );\n}","name":"Sound","description":"","type":"sound"}]}