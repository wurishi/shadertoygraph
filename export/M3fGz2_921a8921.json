{"ver":"0.1","info":{"id":"M3fGz2","date":"1707685236","viewed":33,"name":"TEST_IFS_RENDERER","username":"janOluFue","description":"b","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_ITER 400.\n#define MAX_DIST 200.\n#define TOLERANCE 0.00001\n\n\nvoid rot(inout vec2 pos, in float a){\n    float c = cos(a);\n    float s = sin(a);\n    pos = vec2(pos.x*c+pos.y*s,-pos.x*s+pos.y*c);\n}\n\nvec2 rotvec(in vec2 pos, in float a){\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(pos.x*c+pos.y*s,-pos.x*s+pos.y*c);\n\n}\n\n\nfloat sdBox(in vec3 p, in float b){\n    vec3 q = abs(vec3(p.x,p.y,p.z)) - vec3(b,b,b);\n    return length(max(q,0.0));\n}\n\nfloat sdTorus(in vec3 pos, in vec2 r){\n    float x = length(pos.xz)-r.x;\n    return length(vec2(x,pos.y))-r.y;\n\n}\n\nfloat sdOctahedron(vec3 p, float s)\n\n{\n    s = 1.0;\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    \n#if 0\n    // filbs111's version (see comments)\n    vec3 o = min(r, 0.0);\n    o = max(r*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n#else\n    // my original version\n    vec3 q;\n         if( r.x < 0.0 ) q = p.xyz;\n    else if( r.y < 0.0 ) q = p.yzx;\n    else if( r.z < 0.0 ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n#endif    \n}\n\nfloat distanceEstimator(in vec3 p){\n    float s1 = sdOctahedron(p,0.9);\n    return s1;\n\n}\n\nvec3 inverse_contract(in vec3 pos, in float ratio, in vec3 center){\n    \n    return (pos-ratio*center)/ratio;\n   \n   }\n\n\nvec3 centrs[6] = vec3[6](vec3(0.,1.,0.),vec3(-1.,0.,0.),vec3(0.,0.,1.),vec3(0.,1.,0.),vec3(1.,0.,0.),vec3(0.,0.,-1.));\n\n\n\nconst int max_iters =7;\n\nfloat iDE(in vec3 p){\n    \n    int min_indexes[max_iters];\n    float ratio = 0.5;\n    vec3 composed_pos;\n    vec3 new_pos;\n    \n\n\n    for (int iteration = 0; iteration <= max_iters - 1; iteration++){ //main loop that runs N iterations\n        for (int k = 0; k <= iteration; k++){ // loop that finds the composition of the k-1 st inverse IFS of pos\n            if (k==0){ // if k=0 we can't access the array as it is empty still \n                composed_pos = p;\n                \n            } else {\n\n                composed_pos = inverse_contract(composed_pos,ratio,centrs[min_indexes[k-1]]);\n\n            }\n        }\n        // now we have found the new_position that we need to iterate in order to find the minimizing index\n        float min_dist = 1000.;\n        int min_index = 1;\n        for (int j = 0; j <= 5; j++){\n            vec3 new_pos = inverse_contract(composed_pos,ratio, centrs[j]);\n            if (distanceEstimator(new_pos)<min_dist){\n                min_dist = distanceEstimator(new_pos);\n                min_index = j;\n            } \n        }\n        // now we have found the minimizing index for the current iteration, we label it as such \n        // and populate the array\n        min_indexes[iteration] = min_index;\n\n    }\n    // compose all inverses and calculate final distance $x'=\\bigcirc_{i=1}^{max_iters}f_i^{-1}x$\n    vec3 final_position = p; \n    for (int i = 0; i<= max_iters - 1; i++){\n        final_position = inverse_contract(final_position, ratio, centrs[min_indexes[i]]); \n    }\n\n    return distanceEstimator(final_position)*pow(ratio,float(max_iters));\n}\n\n\n\nfloat final_dist(in vec3 pos){\n    return iDE(pos);\n    //return sdOctahedron(pos,0.);\n\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd){\n    \n    float t = 0.0;\n    float d;\n    float ratio = 1./2.;\n    \n    for (int i = 0; i<int(MAX_ITER);i++){\n        vec3 pos = ro + t*rd;\n        d = final_dist(pos);\n        if (d < TOLERANCE*pow(ratio,float(max_iters)) || d > MAX_DIST/pow(ratio,float(max_iters))){\n        \n            break;\n        }\n        else{\n            t+= d ;\n        }\n    }\n    return t;\n}\n\n\n\nfloat diffuse(in vec3 nor, in vec3 ld){\n    return max(dot(nor,ld),0.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 3.;\n    float t = mint;\n    for( int i=0; i<256*2 && t<maxt; i++ )\n    {\n        float h = final_dist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\n\n\n\nvec3 render(in vec3 ro, in vec3 rd){\n    \n    vec3 skyColor = mix(vec3(0.04,0.14,0.04),vec3(0.3,1.,0.),7.+5.*rd.y);\n    \n    float t = rayMarch(ro,rd);\n    vec3 pos = ro + t*rd;\n    vec3  lig = normalize( vec3(0.2, 0.8, 0.3) );\n    float dif = softshadow(pos,lig,0.01, 4.0, 0.1);\n    //vec3 color = -(0.87*normal(ro+t*rd))+vec3(0.2,0.2,0.2);\n    //vec3 color = vec3(.1);\n    float s = dif*10.;\n    if (t < MAX_DIST){\n    \n        return vec3(s*s,sqrt(s),0.5-s);\n    }else{\n        return vec3(1,1,1);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1. + 2.*fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 ro = (2.5/(1.+iTime))*vec3(1.2,3.1,0.);\n    rot(ro.xz,.6);\n    rot(ro.zy,0.3);\n    rot(ro.xy,0.10*sin(iTime/10.)); //0.6\n\n    \n    \n    \n\n    float f  = 1.4;\n    vec3 ww = f*normalize(vec3(0.0,0.0,0)-ro);\n    vec3 uu = normalize(cross(vec3(1.3,2,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize(uv.x*uu+uv.y*vv+4.8*ww);\n    vec3 col = render(0.92*ro-vec3(0.,0.1,0.33),rd);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}