{"ver":"0.1","info":{"id":"M3tXWS","date":"1719511670","viewed":32,"name":"some  music shit","username":"baggyPants666","description":"fdscas","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["music"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Music-Driven Visualizer - Harmonic Waves\n#define PI 3.14159265359\n\nfloat getAudio(float freq) {\n    return texture(iChannel1, vec2(freq, 0.25)).x;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat opRipple(vec3 p, float frequency, float amplitude) {\n    float dist = length(p.xz);\n    return sin(dist * frequency) * amplitude;\n}\n\nfloat map(vec3 p) {\n    float bassIntensity = getAudio(0.1);\n    float lowMidIntensity = getAudio(0.3);\n    float highMidIntensity = getAudio(0.6);\n    float trebleIntensity = getAudio(0.9);\n    \n    // Central sphere pulsating with bass\n    float sphere = sdSphere(p, 2.0 + bassIntensity * 1.0);\n    \n    // Rippling floor reacting to mid frequencies\n    float plane = sdPlane(p, vec3(0.0, 1.0, 0.0), 2.0);\n    plane += opRipple(p, 1.0 + lowMidIntensity * 10.0, highMidIntensity);\n    \n    // Floating orbs reacting to treble\n    vec3 q = mod(p + 8.0, 16.0) - 8.0;\n    float orbs = sdSphere(q, 0.5 + trebleIntensity);\n    \n    return min(min(sphere, plane), orbs);\n}\n\nvec3 calcNormal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(\n        k.xyy * map(p + k.xyy * h) +\n        k.yyx * map(p + k.yyx * h) +\n        k.yxy * map(p + k.yxy * h) +\n        k.xxx * map(p + k.xxx * h)\n    );\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if(d < 0.001) {\n            vec3 normal = calcNormal(p);\n            vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n            float diff = max(dot(normal, lightDir), 0.0);\n            \n            // Color based on audio frequencies\n            vec3 color = vec3(getAudio(0.2), getAudio(0.5), getAudio(0.8));\n            \n            return color * (diff * 0.5 + 0.5);\n        }\n        if(t > 20.0) break;\n        t += d;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera movement based on audio\n    float cameraSpeed = getAudio(0.05) * 2.0;\n    float angle = iTime * cameraSpeed;\n    float height = 3.0 + getAudio(0.15) * 5.0;\n    float distance = 8.0 + getAudio(0.4) * 4.0;\n    \n    vec3 ro = vec3(cos(angle) * distance, height, sin(angle) * distance);\n    vec3 lookAt = vec3(0.0, getAudio(0.2) * 2.0, 0.0);\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + right * uv.x + up * uv.y);\n    \n    vec3 color = render(ro, rd);\n    \n    // Apply a subtle vignette effect\n    float vignette = smoothstep(1.5, 0.5, length(uv));\n    color *= vignette;\n    \n    // Final color adjustment based on overall audio intensity\n    float overallIntensity = (getAudio(0.1) + getAudio(0.5) + getAudio(0.9)) / 3.0;\n    color *= 1.0 + overallIntensity * 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}