{"ver":"0.1","info":{"id":"3tcBz4","date":"1612390144","viewed":267,"name":"Nyan Flag","username":"kastorp","description":"mixing two of my favourite shaders by Archee and Michael0884\nperformance is good, rendering result uhmmm....","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","flag","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Large scale flocking\" by michael0884. https://shadertoy.com/view/tsScRG\n// mixed with  \"Curtain & Ball\" by Archee https://www.shadertoy.com/view/MldXWX\n//----------------------------------------------------------------------------\n// NYAN FLAG by Kastorp\n//\n// 2d projection of a 3d cloth simulation\n// each position  is rendered from  the 8 closest flag points \n//\n//  comment \"#define FULL\" in common tab to have doubled framerate\n//-----------------------------------------------------------------------------\n\nivec4[2] get(ivec2 p)\n{\n    \n    ivec4 v= floatBitsToInt(getCell(ch0, p));\n    return ivec4[2](v&65535, v>>16);\n}\n\n\nvec3 getParticle(int id)\n{\n    return getPos(ch1, i2xy(id)).xyz;\n}\n\nvec4 nyan(vec2 pos) {   \n    //if(pos.x < 0.0 || pos.x > 1.0 || pos.y < 0.0 || pos.y > 1.0) return vec4(0);    \n    return texture(iChannel3, pos*vec2(1./6.4,1));\n}\n\nvec3 getPPos(int pid)\n{\n    if(pid < 0 || pid >= NP ) return vec3(0); \n   \treturn  getParticle(pid).xyz;\n}\n\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec4 bary(vec2 p,vec2 a, vec2 b, vec2 c) \n{\n\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y)+1e-9;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    \n    vec3 k =  abs(vec3(u,v,w));\n    return k.x+k.y+k.z>1.001?vec4(0.):vec4(k,k.x+k.y+k.z);//vec3(1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\n   pos/=ZOOM;\n \n    \n    fragColor=vec4(0);\n    ivec4 nb[2] = get(ivec2(pos));\n    //DEBUG:\n    //fragColor=vec4(1.-distance(getParticle(nb[3]).xy,pos)/5.,(((nb[3] +nb[3]/N.x)&1 )==0?1.:0.   )-distance(getParticle(nb[0]).xy,pos)/5.,0,0);return;\n    \n    float z = -10000.;\n#ifdef FULL \n    for (int n=0; n<2;n++)\n#else\n    int n=0;\n#endif\n    for(int i = 0; i<4; i++)\n    {\n        if(nb[n][i]<0) continue;      \n        vec3 pos0 = getParticle(nb[n][i]);\n        \n                   \n            ivec2 p =i2xy(nb[n][i]);\n            const ivec2 dp[4] =ivec2[4](ivec2(0,1),ivec2(1,0),ivec2(0,-1),ivec2(-1,0));\n            vec3 npos[4] = vec3[4] (\n                getPPos(xy2i(p +dp[0])),\n                getPPos(xy2i(p +dp[1])),\n                getPPos(xy2i(p +dp[2])),\n                getPPos(xy2i(p +dp[3]))\n            );\n            if(p.x>0 && p.y>0 && p.x<N.x-1 && p.y<N.y-1 && ((p.x+p.y)%1 )==0  )\n            {              \n                for(int j=0;j<4;j++)\n                {\n                    vec4 b =bary(pos,pos0.xy,npos[j].xy,npos[(j+1)%4].xy);\n                    float tz= b.x*pos0.z+b.y*npos[j].z+b.z*npos[(j+1)%4].z;\n                    \n                    bool border=(p.x==1 && j>=2) || (p.y==1 && (j==1 || j==2)) || (p.y==N.y-2 && (j==0 ||j==3)) || (p.x==N.x-2 && j<=1);\n                    if(b.w>0.&& tz>z && !border)\n                    {\n                        z=max(tz,z);\n                        vec3 n=normalize(cross(pos0-npos[j],pos0-npos[(j+1)%4]));\n                        vec2 cc = (vec2(p) +vec2(dp[j])*b.y +vec2(dp[(j+1)%4])*b.z )/vec2(N.x,N.y)  ;                       \n                        if(dot(n,vec3(0,0,1))<=0.) fragColor=max(fragColor,nyan(cc )); else fragColor=vec4(.5);                 \n                        fragColor *= .8 +.2* dot(n,vec3(1,1,1));\n                    }\n                }\n            }       \n    }\n\n    if(fragColor==vec4(0.))fragColor=vec4(0.2,0.2,0.8,0);\n    fragColor+=step(pos.y,size.y*.95)*smoothstep(size.x*.29,pos.x,size.x*.30)*vec4(.8,.3,-.6,0);\n    \n\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define N ivec2(200,150)\n#define NP (N.x*N.y)\n#define size (vec3(N.x,N.y , 1000)*1.4)\n#define ZOOM (iResolution.y/size.y)\n#define ODD 10.\n\n//High quality using 8 flag points per position, instead of 4 (less holes, but slower)\n#define FULL\n\n//#define mouse (iMouse/ZOOM)\n#define getPos(a, p) texelFetch(a, ivec2(p), 0).xyz\n#define getCell(a, p) texelFetch(a, ivec2(p), 0)\n#define getVel(a, p) texelFetch(a, ivec2(p)+ivec2(N.x,0), 0).xyz\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n\nconst int k = 1664525;  \nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return  ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n\n    return( p.x<0 || p.x>=N.x || p.y<0 || p.y>=N.y)?-1:  p.x+ p.y*N.x;\n}\n\nfloat odd_dist(int id)\n{\n    return (((id +id/N.x)&1 )==1?ODD:0.);\n}\n\nivec4  getConn(int id) \n{  \n    if(((id +id/N.x)&1 )==0) return  ivec4(id-N.x+1,id-N.x-1,id+N.x+1,id+N.x-1);\n   else return  ivec4(id-1,id+1,id-N.x,id+N.x);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle buffer\n// from \"Curtain & Ball\" by Archee\n// https://www.shadertoy.com/view/MldXWX\n\n \nconst float gravity = 0.0022;\n\nvec3 pos,vel,ovel;\nivec2 c;\nint cid;\n\n\nvec3 getParticle(int id)\n{\n    return getPos(ch1, i2xy(id));\n}\n\nvec3 getParticleVel(int id)\n{\n    return getVel(ch1, i2xy(id));\n}\n\n\nvoid edge(ivec2 dif)\n{\n    if ( \n        (dif+c).x>=0 && (dif+c).x<N.x &&\n        (dif+c).y>=0 && (dif+c).y<N.y    )\n    {\n        float edgelen = length(vec2(dif));\n        vec3 posdif = getPos(ch1,dif+c)-pos;\n        vec3 veldif = getVel(ch1,dif+c)-ovel;\n        //https://gafferongames.com/post/spring_physics/\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.25); // spring\n        vel +=normalize(iFrame>10?veldif:posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n\n    }\n}\n\n\nvec3 findnormal(ivec2 c)\n{\n    return normalize(cross(  getPos(ch1,c-ivec2(1,0))-getPos(ch1,c+ivec2(1,0)) ,  getPos(ch1,c-ivec2(0,1))-getPos(ch1,c+ivec2(0,1)) ));\n}\n\nvec4 setParticle(vec3 pos, vec3 vel, vec2 U)\n{\n    return U.x>=float(N.x) ? vec4(vel,0.): vec4(pos,0.);\n}\n\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n     if(fragCoord.x>float(N.x)*2. || fragCoord.y>float(N.x)) return;\n     c = ivec2(fract(fragCoord/vec2(N))*vec2(N));\n\n\n     pos = getPos(ch1, c);\n     vel = getVel(ch1, c);\n\n    int id = xy2i(c);\n    cid = id;\n\n\n    if (iFrame<1 || (c.x<=1   )) // init\n    {\n        pos = vec3(float(c.x)*0.9+size.x*.3,size.y*.95 -float(N.y-c.y),float(c.y)*0.1);\n        vel = vec3(0.03,0.0,0.0);\n    }\n    else\n    {\n\n        ovel = vel;\n\n        edge(ivec2(0,1));\n        edge(ivec2(0,-1));\n        edge(ivec2(1,0));\n        edge(ivec2(-1,0));\n        edge(ivec2(1,1));\n        edge(ivec2(-1,-1));\n\n        //edge(ivec2(-1,1));\n        //edge(ivec2(1,-1));\n\n        edge(ivec2(0,2));\n        edge(ivec2(0,-2));\n        edge(ivec2(2,0));\n        edge(ivec2(-2,0));\n        edge(ivec2(2,-2));\n        edge(ivec2(-2,2));\n       // edge(ivec2(-2,-2));\n       // edge(ivec2(2,2));\n\n\n        pos += vel;\n        vel.y -= gravity; // gravity\n\n        // apply air friction\n        vec3 windvel = vec3(.5,0.,-0.05*cos(iTime));\n        vec3 norm = findnormal(c);\n        vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    }\n\n   U=setParticle(pos,vel,fragCoord);\n\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particle buffer\n// from \"Curtain & Ball\" by Archee\n// https://www.shadertoy.com/view/MldXWX\n\n \nconst float gravity = 0.0022;\n\nvec3 pos,vel,ovel;\nivec2 c;\nint cid;\n\n\nvec3 getParticle(int id)\n{\n    return getPos(ch1, i2xy(id));\n}\n\nvec3 getParticleVel(int id)\n{\n    return getVel(ch1, i2xy(id));\n}\n\n\nvoid edge(ivec2 dif)\n{\n    if ( \n        (dif+c).x>=0 && (dif+c).x<N.x &&\n        (dif+c).y>=0 && (dif+c).y<N.y    )\n    {\n        float edgelen = length(vec2(dif));\n        vec3 posdif = getPos(ch1,dif+c)-pos;\n        vec3 veldif = getVel(ch1,dif+c)-ovel;\n        //https://gafferongames.com/post/spring_physics/\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.25); // spring\n        vel +=normalize(iFrame>10?veldif:posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n\n    }\n}\n\n\nvec3 findnormal(ivec2 c)\n{\n    return normalize(cross(  getPos(ch1,c-ivec2(1,0))-getPos(ch1,c+ivec2(1,0)) ,  getPos(ch1,c-ivec2(0,1))-getPos(ch1,c+ivec2(0,1)) ));\n}\n\nvec4 setParticle(vec3 pos, vec3 vel, vec2 U)\n{\n    return U.x>=float(N.x) ? vec4(vel,0.): vec4(pos,0.);\n}\n\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n     if(fragCoord.x>float(N.x)*2. || fragCoord.y>float(N.x)) return;\n     c = ivec2(fract(fragCoord/vec2(N))*vec2(N));\n\n\n     pos = getPos(ch1, c);\n     vel = getVel(ch1, c);\n\n    int id = xy2i(c);\n    cid = id;\n\n\n    if (iFrame<1 || (c.x<=1   )) // init\n    {\n        pos = vec3(float(c.x)*0.9+size.x*.3,size.y*.95 -float(N.y-c.y),float(c.y)*0.1);\n        vel = vec3(0.03,0.0,0.0);\n    }\n    else\n    {\n\n        ovel = vel;\n\n        edge(ivec2(0,1));\n        edge(ivec2(0,-1));\n        edge(ivec2(1,0));\n        edge(ivec2(-1,0));\n        edge(ivec2(1,1));\n        edge(ivec2(-1,-1));\n\n        //edge(ivec2(-1,1));\n        //edge(ivec2(1,-1));\n\n        edge(ivec2(0,2));\n        edge(ivec2(0,-2));\n        edge(ivec2(2,0));\n        edge(ivec2(-2,0));\n        edge(ivec2(2,-2));\n        edge(ivec2(-2,2));\n       // edge(ivec2(-2,-2));\n       // edge(ivec2(2,2));\n\n        pos += vel;\n        vel.y -= gravity; // gravity\n\n        // apply air friction\n        vec3 windvel = vec3(.5,0.,-0.05*cos(iTime));\n        vec3 norm = findnormal(c);\n        vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    }\n\n   U=setParticle(pos,vel,fragCoord);\n\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//particle buffer\n// from \"Curtain & Ball\" by Archee\n// https://www.shadertoy.com/view/MldXWX\n\n \nconst float gravity = 0.0022;\n\nvec3 pos,vel,ovel;\nivec2 c;\nint cid;\n\n\nvec3 getParticle(int id)\n{\n    return getPos(ch1, i2xy(id));\n}\n\nvec3 getParticleVel(int id)\n{\n    return getVel(ch1, i2xy(id));\n}\n\n\nvoid edge(ivec2 dif)\n{\n    if ( \n        (dif+c).x>=0 && (dif+c).x<N.x &&\n        (dif+c).y>=0 && (dif+c).y<N.y    )\n    {\n        float edgelen = length(vec2(dif));\n        vec3 posdif = getPos(ch1,dif+c)-pos;\n        vec3 veldif = getVel(ch1,dif+c)-ovel;\n        //https://gafferongames.com/post/spring_physics/\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.25); // spring\n        vel +=normalize(iFrame>10?veldif:posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n\n    }\n}\n\n\nvec3 findnormal(ivec2 c)\n{\n    return normalize(cross(  getPos(ch1,c-ivec2(1,0))-getPos(ch1,c+ivec2(1,0)) ,  getPos(ch1,c-ivec2(0,1))-getPos(ch1,c+ivec2(0,1)) ));\n}\n\nvec4 setParticle(vec3 pos, vec3 vel, vec2 U)\n{\n    return U.x>=float(N.x) ? vec4(vel,0.): vec4(pos,0.);\n}\n\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n     if(fragCoord.x>float(N.x)*2. || fragCoord.y>float(N.x)) return;\n     c = ivec2(fract(fragCoord/vec2(N))*vec2(N));\n\n\n     pos = getPos(ch1, c);\n     vel = getVel(ch1, c);\n\n    int id = xy2i(c);\n    cid = id;\n\n\n    if (iFrame<1 || (c.x<=1   )) // init\n    {\n        pos = vec3(float(c.x)*0.9+size.x*.3,size.y*.95 -float(N.y-c.y),float(c.y)*0.1);\n        vel = vec3(0.03,0.0,0.0);\n    }\n    else\n    {\n\n        ovel = vel;\n\n        edge(ivec2(0,1));\n        edge(ivec2(0,-1));\n        edge(ivec2(1,0));\n        edge(ivec2(-1,0));\n        edge(ivec2(1,1));\n        edge(ivec2(-1,-1));\n\n        //edge(ivec2(-1,1));\n        //edge(ivec2(1,-1));\n\n        edge(ivec2(0,2));\n        edge(ivec2(0,-2));\n        edge(ivec2(2,0));\n        edge(ivec2(-2,0));\n        edge(ivec2(2,-2));\n        edge(ivec2(-2,2));\n       // edge(ivec2(-2,-2));\n       // edge(ivec2(2,2));\n\n        pos += vel;\n        vel.y -= gravity; // gravity\n\n        // apply air friction\n        vec3 windvel = vec3(.5,0.,-0.05*cos(iTime));\n        vec3 norm = findnormal(c);\n        vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    }\n\n   U=setParticle(pos,vel,fragCoord);\n\n\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//8th order voronoi particle tracking \n\nivec4[2] get(ivec2 p)\n{\n    \n    ivec4 v= floatBitsToInt(getCell(ch0, p));\n    return ivec4[2](v&65535, v>>16);\n}\n\n\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nivec4[2] u; //ids\nvec4[2] d; //distances\nvec2 pos; //pixel position\n\nvec2 getParticle(int id)\n{\n    return getPos(ch1, i2xy(id)).xy;\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id), p) +odd_dist(id);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n    \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d[0].x > dtemp )\n    {\n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= ivec4(u[0].w, u[1].xyz);\n        d[0] = vec4(dtemp, d[0].xyz);\n        u[0] = ivec4(utemp, u[0].xyz);\n    }\n    else if(d[0].y > dtemp && dtemp > d[0].x)\n    {\n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= ivec4(u[0].w, u[1].xyz);\n        d[0].yzw = vec3(dtemp, d[0].yz);\n        u[0].yzw = ivec3(utemp, u[0].yz);\n    }\n    else if(d[0].z > dtemp && dtemp > d[0].y)\n    {\n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= ivec4(u[0].w, u[1].xyz);\n        d[0].zw = vec2(dtemp, d[0].z);\n        u[0].zw = ivec2(utemp, u[0].z);\n    }\n    else if(d[0].w > dtemp && dtemp > d[0].z)\n    {\n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= ivec4(u[0].w, u[1].xyz);\n        d[0].w = dtemp;\n        u[0].w = utemp;\n    }\n#ifdef FULL     \n    else if(d[1].x > dtemp && dtemp > d[0].w)\n    {\n        d[1] = vec4(dtemp, d[1].xyz);\n        u[1] = ivec4(utemp, u[1].xyz);\n\n    }   \n    else if(d[1].y > dtemp && dtemp > d[1].x)\n    {\n        d[1].yzw = vec3(dtemp, d[1].yz);\n        u[1].yzw = ivec3(utemp, u[1].yz);\n    }\n    else if(d[1].z > dtemp && dtemp > d[1].y)\n    {\n        d[1].zw = vec2(dtemp, d[1].z);\n        u[1].zw = ivec2(utemp, u[1].z);\n    }\n    else if(d[1].w > dtemp && dtemp > d[1].z)\n    {\n        d[1].w = dtemp;\n        u[1].w = utemp;\n    }\n#endif    \n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4[2] nb= get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[0][j]);\n    }\n#ifdef FULL    \n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[1][j]);\n    }\n#endif    \n\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n\n    \n    ivec2 p = ivec2(pos);\n     \n    u = ivec4[2]( ivec4(65535), ivec4(65535)); d = vec4[2](vec4(1e10),vec4(1e10)); \n    sortpos(p); //resort this position\n    //jump flood sorting \n    for(int i = 0; i < 5; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    \n    for(int i = 0; i < 3; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%NP); //random sort    \n    }\n     \n\n    if(d[0].x < 2.*ZOOM)\n    for(int i = -2; i <=2; i++)for(int j = -2; j <=2; j++)\n    {\n        int idn= u[0].x+N.x*i+j;\n        if(((idn +idn/N.x)&1 )==0 ) sort(idn);\n    }\n    \n    \n    if(  any(greaterThan(u[0], ivec4(NP))) || any(lessThan(u[0], ivec4(0))))\n     \n    {\n        u[0] = ivec4(0);\n    }\n#ifdef FULL    \n    if(  any(greaterThan(u[1], ivec4(NP))) || any(lessThan(u[1], ivec4(0))))\n     \n    {\n        u[1] = ivec4(0);\n    }\n#endif\n    //u[1]=ivec4(0);\n    U = intBitsToFloat(u[0]+(u[1]*65536));\n}","name":"Buffer D","description":"","type":"buffer"}]}