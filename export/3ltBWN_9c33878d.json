{"ver":"0.1","info":{"id":"3ltBWN","date":"1613027775","viewed":516,"name":"Rasterized Nyan Flag 3D","username":"kastorp","description":"adapted from \"Curtain & Ball\", rendering using Voronoi insted of spatial tree","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["flag","rasterization","physics"],"hasliked":0,"parentid":"3tcBz4","parentname":"Nyan Flag"},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Large scale flocking\" by michael0884. https://shadertoy.com/view/tsScRG\n// mixed with  \"Curtain & Ball\" by Archee https://www.shadertoy.com/view/MldXWX\n//----------------------------------------------------------------------------\n// Rasterized NYAN FLAG 3D  by Kastorp\n//\n// 2d projection of a 3d cloth simulation\n// each position  is rendered from  the 8 closest flag points (with variable LOD)\n// the other objects are rasterized\n//-----------------------------------------------------------------------------\n\nivec4[2] get(vec2 p)\n{\n    \n    ivec4 v= floatBitsToInt(getCell(ch0, p));\n    return ivec4[2](v&65535, v>>16);\n}\n\n\nvec3 getParticle(int id)\n{\n    return getPos(ch1, i2xy(id)).xyz;\n}\n\nvec3 nyan(vec2 pos) {   \n    //if(pos.x < 0.0 || pos.x > 1.0 || pos.y < 0.0 || pos.y > 1.0) return vec4(0);    \n    vec3 c=  texture(iChannel3, pos*vec2(1./6.4,1)).xyz;\n    return (c==vec3(1.)?vec3(0.97,0.97,0.8):c+.01);\n}\n\nvec3 getPPos(int pid)\n{\n    if(pid < 0 || pid >= NP ) return vec3(0); \n   \treturn  getParticle(pid).xyz;\n}\n\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec4 bary(vec2 p,vec2 a, vec2 b, vec2 c) \n{\n\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y)+1e-9;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    \n    vec3 k =  abs(vec3(u,v,w));\n    return k.x+k.y+k.z>1.01?vec4(k,0.):vec4(k,k.x+k.y+k.z);//vec3(1);\n}\n\n\n\nvec4  getZTri(vec2 pos, vec3 v0, vec3 v1, vec3 v2)\n{\n        vec3 p0=prj(v0), p1=prj(v1), p2=prj(v2);\n        vec4 b =bary(pos,p0.xy,p1.xy,p2.xy);\n        \n        //get approximated z \n        return vec4(b.y,b.z, b.w<=0.?FAR:b.x*p0.z+b.y*p1.z+b.z*p2.z,b.w);\n}\nvec4 getZQuad(vec2 pos, vec3 v0, vec3 v1, vec3 v2)\n{\n    vec4 b1=getZTri(pos,v0,v1,v2);\n    vec4 b2=getZTri(pos,v2+v1-v0,v2,v1);\n   \n    //return vec4(mix(b1.x,1.-b2.x,(b1.y+1.-b2.y)/2.) ,mix(b1.y,1.-b2.y,(b1.x+1.-b2.x)/2.), max(b1.z,b2.z), max(b1.w,b2.w));\n    return vec4(b1.x+b1.y<1.? vec2( b1.x,b1.y):vec2( 1.- b2.x,1.- b2.y), max(b1.z,b2.z), max(b1.w,b2.w));\n}    \nvec4 getZQuad(vec2 pos, vec3 v0, vec3 v1, vec3 v2, vec3 v3)\n{\n    vec4 b1=getZTri(pos,v0,v1,v2);\n    vec4 b2=getZTri(pos,v3,v2,v1);\n    return vec4(b1.x,b1.y, max(b1.z,b2.z), max(b1.w,b2.w));\n}\n\nvec4 getZSphere(vec2 pos, vec3 v, float r)\n{\n    vec3 sp =prj(v);\n    float d = r*=(camdist+sp.z)/camdist *zz;\n    \n    float h = length(pos-sp.xy)/d;\n    if(h<=1.) return vec4(0.,0., sp.z + r* sqrt(1.-h*h),1.);\n    else   return vec4(0.,0.,0.,-1);\n}\n\nvec4 getZCube(vec2 pos, vec3 v, vec3 d)\n{\n    vec4 b =vec4(0,0,FAR,0);\n    for(int i=0;i<6;i++){\n        vec3 s= (i>=3)? vec3(1):vec3(-1),\n              v0= v+d*s,\n              v1= (i%3)==2 ? v+vec3(d.x,-d.y,d.z)*s:v+vec3(d.x,d.y,-d.z)*s,\n              v2= (i%3)==0 ? v+vec3(d.x,-d.y,d.z)*s:v+vec3(-d.x,d.y,d.z)*s,\n              v3= v1+v2-v0;\n        vec4 b1=getZTri(pos,v0,v1,v2);\n        vec4 b2=getZTri(pos,v3,v2,v1);\n        \n        vec4 tb= vec4(b1.x,b1.y, max(b1.z,b2.z),max(b1.w,b2.w) );\n        if(tb.w>0. && tb.z >b.z) b=tb;\n       \n    }\n    return b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    setTime(ch1);\n    setView(iMouse.xy,iResolution.xy);\n   pos/=LOD;\n   \n    \n    vec3 col=vec3(0);\n    ivec4 nb[2] = get(vec2(pos));\n   \n    float z = FAR;\n#ifdef FULL \n    for (int n=0; n<2;n++)\n#else\n    int n=0;\n#endif\n    for(int i = 0; i<4; i++)\n    {\n        if(nb[n][i]<0) continue;      \n        vec3 pos0 = getParticle(nb[n][i]);               \n        ivec2 p =i2xy(nb[n][i]);\n\n        const ivec2 dp[4] =ivec2[4](ivec2(0,1),ivec2(1,0),ivec2(0,-1),ivec2(-1,0));\n        vec3 npos[4] = vec3[4] (\n            getPPos(xy2i(p +dp[0])),\n            getPPos(xy2i(p +dp[1])),\n            getPPos(xy2i(p +dp[2])),\n            getPPos(xy2i(p +dp[3]))\n        );\n        if(p.x>0 && p.y>0 && p.x<N.x-1 && p.y<N.y-1 && ((p.x+p.y)%1 )==0  )\n        {   \n        \n \n              if(col==vec3(0) && length(prj(pos0).xy-pos)<1.5 *LOD.y&& prj(pos0).z >z+1. )\n              {\n                  //lowres... should not be needed theorically \n                  vec3 n=normalize(cross(npos[0]-npos[2]   ,npos[1]-npos[3]  ));\n                   col=max(col,nyan(vec2(p)/vec2(N.x,N.y) )*.9);//*vec3(1,0,0);\n                   col *= .8 +.2* dot(n,vec3(1,1,1));\n                   z= prj(pos0).z-1.;\n              }\n            for(int j=0;j<4;j++)\n            {\n                vec3 v0=pos0,v1=npos[j],v2=npos[(j+1)&3];\n                vec4 b=getZTri(pos, v0,v1,v2);\n\n                bool border=(p.x==1 && j>=2) || (p.y==1 && (j==1 || j==2)) || (p.y==N.y-2 && (j==0 ||j==3)) || (p.x==N.x-2 && j<=1);\n                //if(b.w>=0.&& !border && b.z>FAR &&  b.z>z-1.5) col=vec3(1,0,0);\n                if(b.w>=0.&& b.z>z && !border)\n                {                       \n                    vec3 n=normalize(cross(v0-v1,v0-v2));\n                    vec2 cc = (vec2(p) +vec2(dp[j])*b.x +vec2(dp[(j+1)%4])*b.y )/vec2(N.x,N.y)  ;                       \n                    //if(dot(n,vec3(0,0,1))<0.) {\n                        col=nyan(cc );                \n                        col *= .8 +.2* dot(n,vec3(1,1,1));\n                        z=max(b.z,z);\n                   // }\n                }\n            }\n        } \n        \n            \n    }\n\n    if(col==vec3(0.)) col=vec3(0.6,0.7,1.)*(.8+pos.y/size.y*.5);\n    \n    vec4 b=getZCube(pos,vec3(0,-size.y,0),vec3(2,size.y,2.));\n    if(b.w>=0. && b.z >z){   \n        col=vec3(.6,.4-b.x*.2-b.y*0.2,.1);\n        z=max(b.z,z);\n    }\n    b=getZQuad(pos,vec3(-size.x,-size.y*2.5,-size.x),vec3(-size.x,-size.y*2.5,+size.x),vec3(+size.x,-size.y*2.5,-size.x));\n    if(b.w>=0. && b.z >z){   \n        col=vec3(.2,.4-b.x*.2-b.y*0.2,.1);//+  step(fract(b.y*10.),.5)*.1+ step(fract(b.x*10.),.5)*.1,.1);\n        z=max(b.z,z);\n    }\n    b=getZCube(pos,vec3(0,-size.y*2.25,0),vec3(size.y*.25));\n    if(b.w>=0. && b.z >z){   \n        col=vec3(.6,.4-b.x*.2-b.y*0.2,.1);\n        z=max(b.z,z);\n    }\n    b=getZSphere(pos,ballpos(),ballradius);\n    if(b.w>=0. && b.z -5.>z){   \n        col=vec3(.8,.8,0);\n        z=max(b.z-5.,z);\n    }\n    fragColor=vec4(col,0);\n    //fragColor.xyz=vec3(z+50.)/200.;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define N ivec2(200,150)  // must be <iResolution.xy\n#define NP (N.x*N.y) //must be <32K \n#define RF 1.4  //iResolution.x/iResolution.y\n#define size (vec3(N.x,N.y , 1000)*vec3(RF,1,1))   \n#define ODD 10.\n#define FAR -10000.\n\n//High quality using 8 flag points per position, instead of 4 (less holes, but slower)\n#define FULL\n\n//#define mouse (iMouse/ZOOM)\n#define getPos(a, p) texelFetch(a, ivec2(p), 0).xyz\n#define getCell(a, p) texelFetch(a, ivec2(p), 0)\n#define getVel(a, p) texelFetch(a, ivec2(p)+ivec2(N.x,0), 0).xyz\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n\nconst int k = 1664525;  \nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return  ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n\n    return( p.x<0 || p.x>=N.x || p.y<0 || p.y>=N.y)?-1:  p.x+ p.y*N.x;\n}\n\n\n\nvec3  erot(vec3 p, vec3 ax,  float a) {\n    return mix(dot(p,ax)*ax,p,cos(a))+sin(a)*cross(ax,p);\n}\nvec3  ax=normalize(vec3(1,0,0)),az=normalize(vec3(0,1,0)) ;\nvec3  ro=vec3(0.);\nvec3  vo=vec3(0.);\nvec2  LOD=vec2(2.);\nfloat anx=0.;\nfloat anz=0.;\nfloat zz=1.;\nfloat camdist=100.;\nfloat ballradius = 64.0*0.3;\nfloat mytime=0.;\nvec3  prj(vec3 v)  \n{\n    v=(v-ro)*zz + vo;\n    \n    vec3 pj= erot(erot(v-vo,az,anz),ax,anx);\n    pj = vec3(pj.xy*(camdist+pj.z)/camdist,pj.z);\n    //v= (pj-vo)/zz + ro;\n    return pj+vo;\n}\n\nvoid setTime(sampler2D ch)\n{  \n mytime=texelFetch(ch,ivec2(0,N.y) ,0).x; \n}\nvoid  setView( vec2 m,vec2 R){\n   \n    \n    if(R.y<=450.) LOD=vec2(1.);\n    ro= vec3(0,-size.y*1.,0);\n    vo=vec3(R/2./LOD,0);\n    zz=.5/LOD.y * R.y/size.y;\n    camdist =1000.*zz;\n    if(m.x<=0.){anz=mytime/6.; anx= .8;} else{ anx= 1.57-m.y/R.y*1.57;anz=3.14 + m.x/R.x*3.14; }\n}\n\nvec3 ballpos()\n{\n    return vec3(N.x,-N.y,N.y)*vec3(.4,.7, cos(mytime/3.0)*0.8);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle buffer\n// from \"Curtain & Ball\" by Archee\n// https://www.shadertoy.com/view/MldXWX\n\n \nconst float gravity = 0.0022;\n\nvec3 pos,vel,ovel;\nivec2 c;\nint cid;\n\n\nvec3 getParticle(int id)\n{\n    return getPos(ch1, i2xy(id));\n}\n\nvec3 getParticleVel(int id)\n{\n    return getVel(ch1, i2xy(id));\n}\n\n\nvoid ballcollis()\n{\n    \n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid edge(ivec2 dif)\n{\n    if ( \n        (dif+c).x>=0 && (dif+c).x<N.x &&\n        (dif+c).y>=0 && (dif+c).y<N.y    )\n    {\n        float edgelen = length(vec2(dif));\n        vec3 posdif = getPos(ch1,dif+c)-pos;\n        vec3 veldif = getVel(ch1,dif+c)-ovel;\n        //https://gafferongames.com/post/spring_physics/\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.25); // spring\n        vel +=normalize(iFrame>10?veldif:posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n\n    }\n}\n\n\nvec3 findnormal(ivec2 c)\n{\n    return normalize(cross(  getPos(ch1,c-ivec2(1,0))-getPos(ch1,c+ivec2(1,0)) ,  getPos(ch1,c-ivec2(0,1))-getPos(ch1,c+ivec2(0,1)) ));\n}\n\nvec4 setParticle(vec3 pos, vec3 vel, vec2 U)\n{\n    return U.x>=float(N.x) ? vec4(vel,0.): vec4(pos,0.);\n}\n\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n     if(fragCoord.x>float(N.x)*2. || fragCoord.y>float(N.y)+1.) return;\n     c = ivec2(fract(fragCoord/vec2(N))*vec2(N));\n     if(iFrame>0) setTime(ch1); \n\n     pos = getPos(ch1, c);\n     vel = getVel(ch1, c);\n\n    int id = xy2i(c);\n    cid = id;\n\n\n    if (iFrame<1 || (c.x<=1   )) // init\n    {\n        pos = vec3(float(c.x)*0.9, -float(N.y-c.y),float(c.x)*0.1);\n        vel = vec3(0.03,0.0,0.0);\n    }\n    else\n    {\n\n        ovel = vel;\n\n        edge(ivec2(0,1));\n        edge(ivec2(0,-1));\n        edge(ivec2(1,0));\n        edge(ivec2(-1,0));\n        edge(ivec2(1,1));\n        edge(ivec2(-1,-1));\n\n        //edge(ivec2(-1,1));\n        //edge(ivec2(1,-1));\n\n        edge(ivec2(0,2));\n        edge(ivec2(0,-2));\n        edge(ivec2(2,0));\n        edge(ivec2(-2,0));\n        edge(ivec2(2,-2));\n        edge(ivec2(-2,2));\n       // edge(ivec2(-2,-2));\n       // edge(ivec2(2,2));\n        ballcollis();\n\n        pos += vel;\n        vel.y -= gravity; // gravity\n\n        // apply air friction\n        vec3 windvel = vec3(.5,0.,-0.05*cos(iTime));\n        vec3 norm = findnormal(c);\n        vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    }\n\n   U=setParticle(pos,vel,fragCoord);\n    if(fragCoord.y>=float(N.y))\n    {\n        U= vec4(mytime +1.0/4.0/60.0);\n    }\n\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particle buffer\n// from \"Curtain & Ball\" by Archee\n// https://www.shadertoy.com/view/MldXWX\n\n \nconst float gravity = 0.0022;\n\nvec3 pos,vel,ovel;\nivec2 c;\nint cid;\n\n\nvec3 getParticle(int id)\n{\n    return getPos(ch1, i2xy(id));\n}\n\nvec3 getParticleVel(int id)\n{\n    return getVel(ch1, i2xy(id));\n}\n\n\nvoid ballcollis()\n{\n    \n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid edge(ivec2 dif)\n{\n    if ( \n        (dif+c).x>=0 && (dif+c).x<N.x &&\n        (dif+c).y>=0 && (dif+c).y<N.y    )\n    {\n        float edgelen = length(vec2(dif));\n        vec3 posdif = getPos(ch1,dif+c)-pos;\n        vec3 veldif = getVel(ch1,dif+c)-ovel;\n        //https://gafferongames.com/post/spring_physics/\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.25); // spring\n        vel +=normalize(iFrame>10?veldif:posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n\n    }\n}\n\n\nvec3 findnormal(ivec2 c)\n{\n    return normalize(cross(  getPos(ch1,c-ivec2(1,0))-getPos(ch1,c+ivec2(1,0)) ,  getPos(ch1,c-ivec2(0,1))-getPos(ch1,c+ivec2(0,1)) ));\n}\n\nvec4 setParticle(vec3 pos, vec3 vel, vec2 U)\n{\n    return U.x>=float(N.x) ? vec4(vel,0.): vec4(pos,0.);\n}\n\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n     if(fragCoord.x>float(N.x)*2. || fragCoord.y>float(N.y)+1.) return;\n     c = ivec2(fract(fragCoord/vec2(N))*vec2(N));\n     if(iFrame>0) setTime(ch1); \n\n     pos = getPos(ch1, c);\n     vel = getVel(ch1, c);\n\n    int id = xy2i(c);\n    cid = id;\n\n\n    if (iFrame<1 || (c.x<=1   )) // init\n    {\n        pos = vec3(float(c.x)*0.9, -float(N.y-c.y),float(c.x)*0.1);\n        vel = vec3(0.03,0.0,0.0);\n    }\n    else\n    {\n\n        ovel = vel;\n\n        edge(ivec2(0,1));\n        edge(ivec2(0,-1));\n        edge(ivec2(1,0));\n        edge(ivec2(-1,0));\n        edge(ivec2(1,1));\n        edge(ivec2(-1,-1));\n\n        //edge(ivec2(-1,1));\n        //edge(ivec2(1,-1));\n\n        edge(ivec2(0,2));\n        edge(ivec2(0,-2));\n        edge(ivec2(2,0));\n        edge(ivec2(-2,0));\n        edge(ivec2(2,-2));\n        edge(ivec2(-2,2));\n       // edge(ivec2(-2,-2));\n       // edge(ivec2(2,2));\n        ballcollis();\n\n        pos += vel;\n        vel.y -= gravity; // gravity\n\n        // apply air friction\n        vec3 windvel = vec3(.5,0.,-0.05*cos(iTime));\n        vec3 norm = findnormal(c);\n        vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    }\n\n   U=setParticle(pos,vel,fragCoord);\n    if(fragCoord.y>=float(N.y))\n    {\n        U= vec4(mytime +1.0/4.0/60.0);\n    }\n\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//particle buffer\n// from \"Curtain & Ball\" by Archee\n// https://www.shadertoy.com/view/MldXWX\n\n \nconst float gravity = 0.0022;\n\nvec3 pos,vel,ovel;\nivec2 c;\nint cid;\n\n\nvec3 getParticle(int id)\n{\n    return getPos(ch1, i2xy(id));\n}\n\nvec3 getParticleVel(int id)\n{\n    return getVel(ch1, i2xy(id));\n}\n\n\nvoid ballcollis()\n{\n    \n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid edge(ivec2 dif)\n{\n    if ( \n        (dif+c).x>=0 && (dif+c).x<N.x &&\n        (dif+c).y>=0 && (dif+c).y<N.y    )\n    {\n        float edgelen = length(vec2(dif));\n        vec3 posdif = getPos(ch1,dif+c)-pos;\n        vec3 veldif = getVel(ch1,dif+c)-ovel;\n        //https://gafferongames.com/post/spring_physics/\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.25); // spring\n        vel +=normalize(iFrame>10?veldif:posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n\n    }\n}\n\n\nvec3 findnormal(ivec2 c)\n{\n    return normalize(cross(  getPos(ch1,c-ivec2(1,0))-getPos(ch1,c+ivec2(1,0)) ,  getPos(ch1,c-ivec2(0,1))-getPos(ch1,c+ivec2(0,1)) ));\n}\n\nvec4 setParticle(vec3 pos, vec3 vel, vec2 U)\n{\n    return U.x>=float(N.x) ? vec4(vel,0.): vec4(pos,0.);\n}\n\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n     if(fragCoord.x>float(N.x)*2. || fragCoord.y>float(N.y)+1.) return;\n     c = ivec2(fract(fragCoord/vec2(N))*vec2(N));\n     if(iFrame>0) setTime(ch1); \n\n     pos = getPos(ch1, c);\n     vel = getVel(ch1, c);\n\n    int id = xy2i(c);\n    cid = id;\n\n\n     if (iFrame<1 || (c.x<=1   )) // init\n    {\n        pos = vec3(float(c.x)*0.9, -float(N.y-c.y),float(c.x)*0.1);\n        vel = vec3(0.03,0.0,0.0);\n    }\n    else\n    {\n\n        ovel = vel;\n\n        edge(ivec2(0,1));\n        edge(ivec2(0,-1));\n        edge(ivec2(1,0));\n        edge(ivec2(-1,0));\n        edge(ivec2(1,1));\n        edge(ivec2(-1,-1));\n\n        //edge(ivec2(-1,1));\n        //edge(ivec2(1,-1));\n\n        edge(ivec2(0,2));\n        edge(ivec2(0,-2));\n        edge(ivec2(2,0));\n        edge(ivec2(-2,0));\n        edge(ivec2(2,-2));\n        edge(ivec2(-2,2));\n       // edge(ivec2(-2,-2));\n       // edge(ivec2(2,2));\n        ballcollis();\n\n        pos += vel;\n        vel.y -= gravity; // gravity\n\n        // apply air friction\n        vec3 windvel = vec3(.5,0.,-0.05*cos(iTime));\n        vec3 norm = findnormal(c);\n        vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    }\n\n   U=setParticle(pos,vel,fragCoord);\n    if(fragCoord.y>=float(N.y))\n    {\n        U= vec4(mytime +1.0/4.0/60.0);\n    }\n\n\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//8th order voronoi particle tracking \n\nivec4[2] get(ivec2 p)\n{\n    \n    ivec4 v= floatBitsToInt(getCell(ch0, p));\n    return ivec4[2](v&65535, v>>16);\n}\n\n\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nivec4[2] u; //ids\nvec4[2] d; //distances\nvec2 pos; //pixel position\n\nvec3 getParticle(int id)\n{\n    return prj(getPos(ch1, i2xy(id))).xyz;\n}\n\n\n\nfloat particleDistance(int id, vec2 p)\n{\n    vec3 p0=getParticle(id);\n    float d=  distance(p0.xy, p);\n    if(d<1.) d=FAR-p0.z-5.;\n    return d;\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n     if(  any(equal(u[0], ivec4(utemp))) ||  any(equal(u[1], ivec4(utemp)))) return;\n     \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d[0].x > dtemp )\n    {\n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= ivec4(u[0].w, u[1].xyz);\n        d[0] = vec4(dtemp, d[0].xyz);\n        u[0] = ivec4(utemp, u[0].xyz);\n    }\n    else if(d[0].y > dtemp && dtemp > d[0].x)\n    {\n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= ivec4(u[0].w, u[1].xyz);\n        d[0].yzw = vec3(dtemp, d[0].yz);\n        u[0].yzw = ivec3(utemp, u[0].yz);\n    }\n    else if(d[0].z > dtemp && dtemp > d[0].y)\n    {\n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= ivec4(u[0].w, u[1].xyz);\n        d[0].zw = vec2(dtemp, d[0].z);\n        u[0].zw = ivec2(utemp, u[0].z);\n    }\n    else if(d[0].w > dtemp && dtemp > d[0].z)\n    {\n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= ivec4(u[0].w, u[1].xyz);\n        d[0].w = dtemp;\n        u[0].w = utemp;\n    }\n#ifdef FULL     \n    else if(d[1].x > dtemp && dtemp > d[0].w)\n    {\n        d[1] = vec4(dtemp, d[1].xyz);\n        u[1] = ivec4(utemp, u[1].xyz);\n\n    }   \n    else if(d[1].y > dtemp && dtemp > d[1].x)\n    {\n        d[1].yzw = vec3(dtemp, d[1].yz);\n        u[1].yzw = ivec3(utemp, u[1].yz);\n    }\n    else if(d[1].z > dtemp && dtemp > d[1].y)\n    {\n        d[1].zw = vec2(dtemp, d[1].z);\n        u[1].zw = ivec2(utemp, u[1].z);\n    }\n    else if(d[1].w > dtemp && dtemp > d[1].z)\n    {\n        d[1].w = dtemp;\n        u[1].w = utemp;\n    }\n#endif    \n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4[2] nb= get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[0][j]);\n    }\n#ifdef FULL    \n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[1][j]);\n    }\n#endif    \n\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    setTime(ch1);\n    setView(iMouse.xy,iResolution.xy);\n    if(any(greaterThan(fragCoord*LOD, iResolution.xy))) return;\n    pos = fragCoord;\n   \n    \n    \n    ivec2 p = ivec2(pos);\n     \n    u = ivec4[2]( ivec4(65535), ivec4(65535)); d = vec4[2](vec4(1e10),vec4(1e10)); \n\n    sortpos(p); //resort this position\n    \n    //jump flood sorting \n    for(int i = 0; i < 8; i++)\n    {\n        ivec4[2] nb= get(p+cross_distribution(i)*ivec2(2));   \n        for(int j = 0; j < 2; j++) sort(nb[0][j]);\n        //sortpos(p+cross_distribution(i)*ivec2(2)); \n    }\n    \n    \n    for(int i = 0; i < 8; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%NP); //random sort    \n    }\n     \n    if(d[0].x < 2.*LOD.y)\n    for(int k=0;k<2;k++) for(int l=3, i = -l; i <=l; i++)for(int j = -l; j <=l; j++)\n    {\n        int idn= u[k].x+N.x*i+j;\n        if(((idn +idn/N.x)&1 )==0 ) sort(idn);\n    }\n     \n/*    \n    if(  any(greaterThan(u[0], ivec4(NP))) || any(lessThan(u[0], ivec4(0))))\n     \n    {\n        u[0] = ivec4(0);\n    }\n#ifdef FULL    \n    if(  any(greaterThan(u[1], ivec4(NP))) || any(lessThan(u[1], ivec4(0))))\n     \n    {\n        u[1] = ivec4(0);\n    }\n#endif\n*/\n    //u[1]=ivec4(0);\n    U = intBitsToFloat(u[0]+(u[1]*65536));\n}","name":"Buffer D","description":"","type":"buffer"}]}