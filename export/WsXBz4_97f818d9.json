{"ver":"0.1","info":{"id":"WsXBz4","date":"1587732952","viewed":89,"name":"B-day cake","username":"42yeah","description":"This is a fairly ugly cake. I just made it for fun! It's probably your birthday, and if so, happy birthday!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Comment this if topping is way too laggy for you.\n#define NICE_TOPPINGS\n\nfloat smin(float a, float b, float r) {\n    float h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n    return mix(b, a, h) - r * h * (1.0 - h);\n}\n\nvec2 rand2d(vec2 u) {\n    return fract(sin(\n        vec2(dot(u, vec2(12.345, 67.89)),\n            dot(u, vec2(512.215, 91.51)))\n    ) * 42123.45678) * 2.0 - 1.0;\n}\n\nvec3 rand3d(vec3 u) {\n    return fract(sin(\n        vec3(dot(u, vec3(12.345, 67.89, 1.56)),\n            dot(u, vec3(512.215, 91.51, 918.12)),\n            dot(u, vec3(12.567, 84.23, 92.5)))\n    ) * 42123.45678) * 2.0 - 1.0;\n}\n\nfloat ball(vec3 p, vec3 off, float r) {\n    return length(p - off) - r;\n}\n\nfloat sol(vec3 p) {\n    return p.y;\n}\n\nfloat cylinder(vec3 p, vec3 off, float ra, float rb, float h) {\n    p = p - off;\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat topping(vec3 p, vec3 off) {\n    float v = cylinder(p, off, 0.161, 0.1, -0.05);\n    vec3 currentOff = vec3(0.0, 0.0, 0.0);\n\n#ifdef NICE_TOPPINGS\n    for (int i = 0; i < 10; i++) {\n        vec2 deltaOff = vec2(sin(float(i)) * 0.29, cos(float(i)) * 0.3);\n        currentOff = vec3(deltaOff.x, -0.05, deltaOff.y);\n        v = smin(v, ball(p, off + currentOff, 0.015 + cos(float(i * 3)) * 0.01), \n            0.1 + (sin(float(i * 2)) * 0.005 + 0.001));\n    }\n#endif\n    return v;\n}\n\nfloat grapes(vec3 p, vec3 off) {\n    float v = ball(p, off + vec3(0.1, 0.0, 0.0), 0.03);\n    v = min(v, ball(p, off + vec3(0.03, 0.0, 0.0), 0.03));\n    v = min(v, ball(p, off + vec3(0.05, 0.0, -0.06), 0.03));\n    v = min(v, ball(p, off + vec3(0.06, 0.04, -0.025), 0.03));\n    \n    for (int i = 0; i < 5; i++) {\n        vec2 rnd = rand2d(vec2(float(i + 2), float(i))) * 0.2;\n        v = min(v, ball(p, off + vec3(rnd.x, 0.0, rnd.y), 0.03));\n    }\n    return v;\n}\n\nfloat line(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat candle(vec3 p, vec3 off) {\n    p = p - off;\n    return line(p, vec3(0.0, -0.02, 0.1), vec3(0.0, 0.08, 0.11), 0.02);\n}\n\n\n\n//float age(vec3 p, vec3 off) {\n//    p = p - (off + vec3(0.0, 0.1, 0.1));\n//    vec2 t = vec2(0.05, 0.01);\n//    vec2 q = vec2(length(p.xy) - t.x, p.z);\n//    float v = length(q) - t.y;\n//    v -= min(p.y, 0.0);\n//    v = smin(v, line(p, vec3(0.05, 0.0, 0.0), vec3(-0.04, -0.1, 0.0), 0.01), 0.01);\n//    v = smin(v, line(p, vec3(0.05, -0.1, 0.0), vec3(-0.04, -0.1, 0.0), 0.01), 0.01);\n//    v = smin(v, line(p, vec3(0.1, -0.1, 0.0), vec3(0.12, 0.05, 0.0), 0.01), 0.01);\n//    return v;\n//}\n\nvec2 map(vec3 p) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = sol(p);\n    if (dist < closest) { closest = dist; id = 0.5; }\n\n    dist = cylinder(p, vec3(0.0, 0.1, 0.0), 0.2, 0.1, 0.1);\n    if (dist < closest) { closest = dist; id = 1.5; }\n    \n    dist = cylinder(p, vec3(0.0, 0.36, 0.0), 0.16, 0.1, 0.09);\n    if (dist < closest) { closest = dist; id = 2.5; }\n    \n    dist = topping(p, vec3(0.0, 0.51, 0.0));\n    if (dist < closest) { closest = dist; id = 3.5; }\n    \n    dist = grapes(p, vec3(0.0, 0.585, 0.0));\n    if (dist < closest) { closest = dist; id = 4.5; }\n    \n    dist = candle(p, vec3(0.0, 0.585, 0.0));\n    if (dist < closest) { closest = dist; id = 5.5; }\n    \n//    dist = age(p, vec3(0.0, 0.6, 0.0));\n//    if (dist < closest) { closest = dist; id = 5.5; }\n    \n    return vec2(closest, id);\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    \n    for (int i = 0; i < 200; i++) {\n        vec2 result = map(ro + depth * rd);\n        if (result.x <= 0.001) {\n            id = result.y;\n            break;\n        }\n        depth += result.x;\n    }\n    return vec2(depth, id);\n}\n\n#define PI acos(-1.0)\nvec3 bottomCakeColor(vec3 p) {\n    vec3 baseColor = vec3(1.2, 1.2, 0.7);\n    vec3 toppingColor = vec3(1.0, 0.5, 0.01);\n    float dist = pow(max(p.y - 0.25, 0.0), 0.2);\n    vec3 color = mix(baseColor, toppingColor, clamp(dist, 0.0, 1.0));\n    \n    p = normalize(p);\n    float rad = atan(p.x / p.z) / (2.0 * PI);\n    float v = sin(rad) * 10.0;\n    float yDist = 1.0 - pow(max(abs(v - p.y), 0.0), 2.0);\n    yDist = 1.0 - clamp(pow(yDist, 0.2), 0.0, 1.0);\n    vec3 chocolat = vec3(0.82, 0.411, 0.117);\n    color = mix(color, chocolat, yDist);\n    return vec3(color);\n}\n\nvec3 topCakeColor(vec3 p) {\n    vec3 baseColor = vec3(1.2, 1.2, 1.0);\n    vec3 toppingColor = vec3(1.0, 0.5, 0.0);\n    \n    return vec3(p.y);\n}\n\nvec3 candleColor(vec3 p) {\n    p *= 5.0;\n    vec3 f = fract(p);\n    vec3 u = floor(p);\n    vec3 baseColor = vec3(1.0, 1.0, 1.0) * 1.2;\n    return vec3(rand3d(u.yyy) * baseColor);\n}\n\nvec3 getColor(float id, vec3 p) {\n    if (id < -0.5) { return vec3(0.0); }\n    if (id < 1.0) { return vec3(1.05, 1.0, 1.0); }\n    if (id < 2.0) { return bottomCakeColor(p); }\n    if (id < 3.0) { return topCakeColor(p); }\n    if (id < 4.0) { return vec3(0.82, 0.411, 0.117) * 0.4; }\n    if (id < 5.0) { return vec3(0.435, 0.176, 0.658); }\n    if (id < 6.0) { return candleColor(p); }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 getNormal(vec3 p, vec2 info) {\n    const float epsilon = 0.001;\n    vec3 n = normalize(vec3(\n        map(p).x - map(vec3(p.x - epsilon, p.yz)).x,\n        map(p).x - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        map(p).x - map(vec3(p.xy, p.z - epsilon)).x\n    ));\n    return n;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k) {\n    float depth = 0.01;\n    float res = 1.0;\n    vec2 dv = vec2(1.0, -1.0);\n    for (int i = 0; i < 30; i++) {\n        dv = map(ro + rd * depth);\n        res = min(res, smoothstep(0.0, 1.0, k * dv.x / depth));\n        if (res <= 0.0001) {\n            break;\n        }\n        depth += clamp(dv.x, 0.02, 2.0);\n    }\n    return res;\n}\n\nfloat directLighting(vec3 pos, vec3 n, vec3 lightPos, vec3 lightDir) {\n    float shadowIntensity = softShadow(pos + n * 0.001, lightDir, 5.0);\n    return shadowIntensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    float r = 1.0;\n    vec3 ro = vec3(sin(iTime * 0.1) * r, 1.0 + (sin(iTime * 0.05) * 0.5 + 0.5), cos(iTime * 0.1) * r);\n    vec3 center = vec3(sin(iTime * 0.5) * 0.1, 0.5 + (cos(iTime * 0.1) * 0.05), cos(iTime * 0.5) * 0.1);\n    \n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n\n    vec2 info = intersect(ro, rd);\n    vec3 pos = ro + info.x * rd;\n    vec3 n = getNormal(pos, info);\n    \n    vec3 lightPos = vec3(1.5, 2.0, 0.0);\n    vec3 lightDir = normalize(lightPos);\n    \n    float attenuation = 1.0 * smoothstep(0.9, 1.0, dot(normalize(lightPos - pos), lightDir));\n    float ambient = 1.0;\n    float diffuse = max(dot(n, pos), 0.0);\n    float back = max(dot(n, vec3(-lightDir.x, 0.0, -lightDir.z)), 0.0);\n    float top = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float fr = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 3.0);\n    float sol = clamp(-n.y * 0.8 + 0.2, 0.0, 1.0) * pow(clamp(1.0 - pos.y, 0.0, 1.0), 2.0);\n    float shadow = directLighting(pos, n, lightPos, lightDir);\n    float specular = 0.0;\n    if (info.y > 3.1 && info.y < 5.0) {\n        vec3 refl = reflect(-lightDir, n);\n        specular = pow(max(dot(-rd, refl), 0.0), 16.0);\n    }\n    \n    vec3 light = vec3(0.0);\n    light += ambient * vec3(0.2, 0.2, 0.2) * attenuation * shadow;\n    light += diffuse * vec3(0.73, 0.7, 0.7) * attenuation;\n    light += back * vec3(0.2, 0.1, 0.1) * attenuation;\n    light += top * vec3(0.3, 0.3, 0.3) * attenuation;\n    light += fr * vec3(0.98, 1.0, 0.86) * attenuation;\n    light += sol * vec3(0.1, 0.1, 0.1) * attenuation;\n    light += specular * vec3(5.0, 5.0, 5.0) * attenuation * shadow;\n    \n    vec3 color = light * getColor(info.y, pos);\n\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}