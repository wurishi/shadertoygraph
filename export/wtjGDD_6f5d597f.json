{"ver":"0.1","info":{"id":"wtjGDD","date":"1559683027","viewed":542,"name":"camera controls","username":"bernie_freidin","description":"pathtracer with lightmaps and camera controls:\nsee Common for more info","likes":15,"published":1,"flags":48,"usePreview":1,"tags":["3d","reflection","refraction","cornellbox","camera","globalillumination","pathtracing","montecarlo","lightmap","multipass","smallpt","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//$INPUT0=KEYBOARD\n//$INPUT1=BUFFER_A\n//$INPUT2=BUFFER_B\n//$INPUT3=BUFFER_C\n//$OUTPUT=IMAGE\n\nfloat LinearToSRGB(float value)\n{\n\tif (value <= 0.0031308)\n\t\treturn value*12.92;\n\telse\n\t\treturn 1.055*pow(value, 1.0/2.4) - 0.055;\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n\treturn vec3(LinearToSRGB(rgb.r), LinearToSRGB(rgb.g), LinearToSRGB(rgb.b));\n}\n\nfloat SRGBtoLinear(float value)\n{\n\tif (value <= 0.04045)\n\t\treturn value/12.92;\n\telse\n\t\treturn pow((value + 0.055)/1.055, 2.4);\n}\n\nvec3 SRGBtoLinear(vec3 rgb)\n{\n\treturn vec3(SRGBtoLinear(rgb.r), SRGBtoLinear(rgb.g), SRGBtoLinear(rgb.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col;\n#if LIGHTMAP\n    if (IS_KEY_TOGGLED(KEY_V)) // 'V' = visualize lightmap\n    \tcol = texelFetch(LIGHTMAP_SAMPLER, ivec2(fragCoord), 0).rgb;\n    else\n#endif // LIGHTMAP\n\t\tcol = texture(SCENE_SAMPLER, fragCoord/iResolution.xy).rgb;\n    //col = pow(col, vec3(1.0/2.2)); // gamma\n\tcol = LinearToSRGB(col);\n\n    if (IS_KEY_TOGGLED(KEY_Z)) {\n        float variance = texture(VARIANCE_SAMPLER, fragCoord/iResolution.xy).b;\n\t    //col = 500.0*variance*vec3(1,0,0);\n        if (variance > 0.0001)\n            col = vec3(1,0,0);\n    }\n    \n    // show some toggles ..\n    float r = 10.0;\n\tfloat x = 24.0;\n    if (IS_KEY_NOT_TOGGLED(KEY_H)) col = mix(col, vec3(1,0,0), max(0.0, 1.0 - length(fragCoord - iResolution.xy + vec2(x,24))/r)); x += 24.0;\n\tif (IS_KEY_NOT_TOGGLED(KEY_E)) col = mix(col, vec3(0,1,0), max(0.0, 1.0 - length(fragCoord - iResolution.xy + vec2(x,24))/r)); x += 24.0;\n\tif (IS_KEY_NOT_TOGGLED(KEY_U)) col = mix(col, vec3(0,0,1), max(0.0, 1.0 - length(fragCoord - iResolution.xy + vec2(x,24))/r)); x += 24.0;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//$INPUT0=KEYBOARD\n//$INPUT1=BUFFER_A\n//$INPUT2=BUFFER_B\n//$INPUT3=RGBA_NOISE_MEDIUM_TEXTURE\n//$INPUT4=PASSIONFLOWER_TEXTURE\n//$OUTPUT=BUFFER_A\n//$OUTPUT_RES_X=256\n//$OUTPUT_RES_Y=200\n//$OUTPUT_FILTER=ON\n\n// ==================================\n// Buffer A: renders lightmap texture\n// ==================================\n\n#if LIGHTMAP_SPHERE_ATLAS\nvec4 ColorizeSphereFace(int faceRow, int faceCol)\n{\n    vec4 colorize = vec4(0,0,0,1);\n    if (faceCol == 0)\n        colorize.r = 1.0;\n    else if (faceCol == 1)\n        colorize.g = 1.0;\n    else // faceCol == 2\n        colorize.b = 1.0;\n    if (faceRow == 1)\n        colorize.rgb = vec3(1) - colorize.rgb; // cyan,magenta,yellow\n    colorize.rgb += (vec3(1) - colorize.rgb)*0.2; // whiten\n    return colorize;\n}\n#endif // LIGHTMAP_SPHERE_ATLAS\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tINIT_SCENE();\n\n\tbvec2 frameReset = bvec2(false);\n\tframeReset.y = IS_KEY_DOWN(KEY_SPACE) || SLIDER_CHANGED;\n    if (IS_KEY_PRESSED(KEY_E) || IS_KEY_PRESSED(KEY_H) || IS_KEY_PRESSED(KEY_U))\n        frameReset.y = true;\n\tif (IS_KEY_PRESSED(KEY_I) || IS_KEY_PRESSED(KEY_O))\n\t\tframeReset.y = true;\n\tif (IS_KEY_PRESSED(KEY_P))\n\t\tframeReset.y = true;\n#if LIGHTMAP\n\tif (IS_KEY_PRESSED(KEY_L))\n\t\tframeReset.y = true;\n\tif (lightmapEnabled && IS_KEY_PRESSED(KEY_C))\n\t\tframeReset.y = true;\n\tif (lightmapEnabled && IS_KEY_PRESSED(KEY_F))\n\t\tframeReset.x = true;\n#endif // LIGHTMAP\n\n\tmat4 camera;\n\tvec2 frame;\n\tif (CAMERA_HANDLER(camera, KEYBOARD_SAMPLER, LIGHTMAP_SAMPLER, frame, frameReset, 1.0))\n\t{\n\t\tvec3 color = vec3(1,0,0); // lightmap atlas background\n\t#if LIGHTMAP\n\t\tif (lightmapEnabled) {\n\t\t\tvec2 offset = texelFetch(NOISE_SAMPLER, ivec2(fragCoord)&255, 0).xy;\n\t\t\tint objId = OBJ_ID_NONE;\n\t\t\tObject obj;\n\t\t\tfor (int i = 0; i < NO_UNROLL(NUM_OBJECTS); i++) {\n\t\t\t\tobj = objects[i];\n\t\t\t\tif (fragCoord.x >= obj.lightmapBounds.x &&\n\t\t\t\t\tfragCoord.y >= obj.lightmapBounds.y &&\n\t\t\t\t\tfragCoord.x <= obj.lightmapBounds.z &&\n\t\t\t\t\tfragCoord.y <= obj.lightmapBounds.w) {\n\t\t\t\t\tobjId = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objId != OBJ_ID_NONE && IsDiffuse(obj)) {\n\t\t\t\tvec4 colorize = vec4(0);\n\t\t\t\tvec3 P;\n\t\t\t\tif (IsQuad(obj)) {\n\t\t\t\t\tvec3 bx = GetQuadBasisX(obj);\n\t\t\t\t\tvec3 by = GetQuadBasisY(obj);\n\t\t\t\t\tvec4 bounds = obj.lightmapBounds;\n\t\t\t\t\tvec2 uv = (fragCoord.xy - bounds.xy)/(bounds.zw - bounds.xy);\n\t\t\t\t\tvec2 st = uv*2.0 - vec2(1);\n\t\t\t\t\tP = obj.pos + st.x*bx + st.y*by;\n\t\t\t\t} else { \n\t\t\t\t\tvec2 sphereAtlasUV = fragCoord.xy - obj.lightmapBounds.xy;\n\t\t\t\t\tfloat faceRes = GetLightmapSphereFaceRes(obj);\n\t\t\t\t\tint faceRow = int(floor(sphereAtlasUV.y/float(faceRes)));\n\t\t\t\t\tint faceCol = int(floor(sphereAtlasUV.x/float(faceRes)));\n\t\t\t\t\tvec2 faceBoundsMin = vec2(faceCol + 0, faceRow + 0)*faceRes + vec2(LIGHTMAP_SPHERE_FACE_INSET);\n\t\t\t\t\tvec2 faceBoundsMax = vec2(faceCol + 1, faceRow + 1)*faceRes - vec2(LIGHTMAP_SPHERE_FACE_INSET);\n\t\t\t\t\tvec2 faceUV = (sphereAtlasUV - faceBoundsMin)/(faceBoundsMax - faceBoundsMin);\n\t\t\t\t\tvec3 V = normalize(vec3((faceRow == 1) ? -1 : 1, faceUV*2.0 - vec2(1)));\n\t\t\t\t\tif (faceCol == 1)\n\t\t\t\t\t\tV = V.zxy;\n\t\t\t\t\telse if (faceCol == 2)\n\t\t\t\t\t\tV = V.yzx;\n\t\t\t\t\tP = obj.pos + V*obj.radius;\n\t\t\t\t\tif (IS_KEY_TOGGLED(KEY_C))\n\t\t\t\t\t\tcolorize = ColorizeSphereFace(faceRow, faceCol);\n\t\t\t\t}\n\t\t\t\tvec3 N = GetSurfaceNormal(P, obj);\n\t\t\t\tvec3 e = vec3(0);\n                uint wasSampled = 0U;\n\t\t\t\tif (directLightSampling && minDepth <= 1)\n\t\t\t\t\te = SampleLightsInScene(\n\t\t\t\t\t\tP,\n\t\t\t\t\t\tN,\n\t\t\t\t\t\thaltonEnabled,\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\tobjId,\n\t\t\t\t\t\tiFrame,\n\t\t\t\t\t\tNUM_DIRECT_LIGHT_SAMPLES,\n\t\t\t\t\t\twasSampled);\n\t\t\t\tcolor = vec3(0);\n\t\t\t\tfor (int i = 0; i < NO_UNROLL(NUM_PRIMARY_RAY_SAMPLES); i++) {\n\t\t\t\t\tvec2 s = haltonEnabled ? fract(offset + Halton23(i + iFrame*NUM_PRIMARY_RAY_SAMPLES)) : rand2(seed);\n\t\t\t\t\tvec3 rayDir; // diffuse only!\n\t\t\t\t\tfloat mask = 1.0;\n\t\t\t\t\tif (diffuseUniformSampling) {\n\t\t\t\t\t\trayDir = SampleHemisphereUniform(N, s);\n\t\t\t\t\t\tmask = dot(N, rayDir)*2.0; // why 2.0?\n\t\t\t\t\t} else\n\t\t\t\t\t\trayDir = SampleHemisphereCosineWeighted(N, s);\n\t\t\t\t\tcolor += mask*ComputeRadiance(\n\t\t\t\t\t\tRay(P, rayDir),\n\t\t\t\t\t\tobjId,\n\t\t\t\t\t\t1, // depth (starts at 1)\n\t\t\t\t\t\tminDepth,\n\t\t\t\t\t\tmaxDepth,\n\t\t\t\t\t\tdiffuseUniformSampling,\n\t\t\t\t\t#if LIGHTMAP\n\t\t\t\t\t\t-1, // lightmapDepth\n\t\t\t\t\t\tLIGHTMAP_SAMPLER,\n\t\t\t\t\t#endif // LIGHTMAP\n\t\t\t\t\t\tdirectLightSampling,\n\t\t\t\t\t\twasSampled);\n\t\t\t\t}\n\t\t\t\tcolor /= float(NUM_PRIMARY_RAY_SAMPLES);\n\t\t\t\tcolor += e;\n\t\t\t#if LIGHTMAP_SPHERE_ATLAS\n\t\t\t\tcolor += (colorize.rgb - color)*colorize.a;\n\t\t\t#endif // LIGHTMAP_SPHERE_ATLAS\n\t\t\t}\n\t\t}\n\t#endif // LIGHTMAP\n\n        float f = frame.y;\n        if (f > 0.0) {\n            float accum = 1.0/(f + 1.0);\n\t\t\tif (f >= float(LAST_FRAME))\n\t\t\t\taccum = 0.0;\n            color = color*accum + texelFetch(LIGHTMAP_SAMPLER, ivec2(fragCoord), 0).rgb*(1.0 - accum);\n        }\n\t\tfragColor = vec4(color, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// ===========================================\n// [Page 1] Common\n// \n// 2019/06/18 02:14PM\n// ===========================================\n\n//$BUFFER: name=lightmap, w=256,     h=200,     format=R32G32B32_FLOAT, filter=ON\n//$BUFFER: name=scene,    relw=0.25, relh=0.25, format=R32G32B32_FLOAT, filter=OFF\n//$BUFFER: name=variance, relw=0.25, relh=0.25, format=R32G32B32_FLOAT, filter=OFF\n\n/*\n=============================================================================\nBased on https://www.shadertoy.com/view/XdcfRr (fjavifabre)\nWhich was based on https://www.shadertoy.com/view/4sfGDB (Zavie)\nOriginal code http://www.kevinbeason.com/smallpt/\n\nNote: this project is NOT intended to look great, it is intended to resolve\ndiscrepancies with the ground truth path tracer (currently I'm using Mitsuba).\nAt this point I've resolved discrepancies with diffuse material only, but not\nspecular or refractive.\n\nCONTROLS:\n- mouse controls camera (hold 'T' for translation)\n- 'WASD' camera fly controls\n- 'E' toggle direct light sampling (next event estimation / importance sampling for lights)\n- 'H' toggle Halton sampling for first bounce (and first direct light sampling)\n- 'L' toggle lightmaps\n- 'V' toggle lightmap visualization\n- 'F' toggle lightmap filtering\n- 'I' toggle indirect illumination only\n- 'O' toggle direct illumination only\n- 'C' colorize lightmap sphere faces\n- 'Z' toggle variance display (non-lightmap only)\n\nTODO:\n- support textured quad lights\n- add GGX and metallic materials (low priority)\n- firefly suppression\n- support non-convex objects\n=============================================================================\n*/\n\n#define SLIDER_VAR_CONST(type,name,init,rangemin,rangemax) const type name = type(init)\n#ifndef SLIDER_VAR\n#define SLIDER_VAR SLIDER_VAR_CONST\n#define SLIDER_CHANGED false\n#endif\n\n// ================================================\n// === BEGIN CAMERA CODE ==========================\n// ================================================\n\n#define PI 3.14159265359\n\nmat3 CreateCameraBasis(vec3 camRot)\n{\n\tfloat sinYaw = sin(camRot.x);\n\tfloat cosYaw = cos(camRot.x);\n\tfloat sinPitch = sin(camRot.y);\n\tfloat cosPitch = cos(camRot.y);\n\tmat3 basis;\n\tbasis[0] = vec3(+cosYaw, 0, +sinYaw);\n\tbasis[1] = vec3(-sinYaw*sinPitch, cosPitch, +cosYaw*sinPitch);\n\tbasis[2] = vec3(+sinYaw*cosPitch, sinPitch, -cosYaw*cosPitch);\n\treturn basis;\n}\n\nvec3 CreateScreenRay(vec2 screenPos, float screenAspect)\n{\n    float VFOV = 80.0;\n\tfloat tanVFOV = tan(VFOV*0.5*PI/180.0); // could precompute this\n    return normalize(vec3(screenPos*vec2(screenAspect, 1)*tanVFOV, 1));\n}\n\n#define CAMERA_HANDLER(camera, keyboardSampler, controlSampler, frame, frameReset, translationScale) \\\n\tCameraHandler(camera, fragColor, fragCoord, keyboardSampler, controlSampler, iMouse, frame, iFrame, frameReset, iFrameRate, translationScale)\n\n// this is my current attempt at a \"generic\" camera controller for shadertoy ..\nbool CameraHandler(\n\tout mat4 camera,\n\tout vec4 fragColor,\n\tvec2 fragCoord,\n\tsampler2D keyboardSampler,\n\tsampler2D controlSampler,\n\tvec4 mouse, // <-- iMouse\n\tout vec2 frame,\n\tint frameIndex, // <-- iFrame\n\tbvec2 frameReset,\n\tfloat frameRate, // <-- iFrameRate\n\tfloat translationScale)\n{\n#define MOUSE_CONTROL_NONE      0\n#define MOUSE_CONTROL_ROTATE    1\n#define MOUSE_CONTROL_TRANSLATE 2\n#define MOUSE_CONTROL frameControl.z // i need xyz for translation mouse control, so mode needs to be stored elsewhere\n\n\tconst int key_A = 65; // KEY_A\n\tconst int key_D = 68; // KEY_D\n\tconst int key_S = 83; // KEY_S\n\tconst int key_T = 84; // KEY_T\n\tconst int key_W = 87; // KEY_W\n\n\tfloat camSpeedRotate = 0.003;\n\tfloat camSpeedTranslate = 0.25*translationScale;\n\tfloat camSpeedTranslateWASD = 60.0*translationScale/frameRate;\n\n\tivec2 controlSamplerRes = textureSize(controlSampler, 0);\n\tivec2 frameControlCoord = controlSamplerRes - ivec2(1,1);\n\tivec2 mouseControlCoord = controlSamplerRes - ivec2(2,1);\n\tivec2 camPosCoord       = controlSamplerRes - ivec2(3,1);\n\tivec2 camRotCoord       = controlSamplerRes - ivec2(4,1);\n\n\tvec3 frameControl = texelFetch(controlSampler, frameControlCoord, 0).xyz;\n\tvec3 mouseControl = texelFetch(controlSampler, mouseControlCoord, 0).xyz;\n\tvec3 camPos       = texelFetch(controlSampler, camPosCoord, 0).xyz;\n\tvec3 camRot       = texelFetch(controlSampler, camRotCoord, 0).xyz; // yaw,pitch,unused\n\tmat3 camBasis     = CreateCameraBasis(camRot);\n\n\tbool mouseDownPrev = MOUSE_CONTROL != float(MOUSE_CONTROL_NONE);\n\tbool mouseDownCurr = mouse.z > 0.0;\n\tif (mouseDownCurr) {\n\t\tif (!mouseDownPrev) {\n\t\t\tif (texelFetch(keyboardSampler, ivec2(key_T,0), 0).x > 0.0) {\n\t\t\t\tmouseControl = camBasis*camPos;\n\t\t\t\tMOUSE_CONTROL = float(MOUSE_CONTROL_TRANSLATE);\n\t\t\t} else {\n\t\t\t\tmouseControl.xy = camRot.xy;\n\t\t\t\tmouseControl.z = 0.0;\n\t\t\t\tMOUSE_CONTROL = float(MOUSE_CONTROL_ROTATE);\n\t\t\t}\n\t\t}\n\t\tif (MOUSE_CONTROL == float(MOUSE_CONTROL_TRANSLATE)) {\n\t\t\tvec3 delta = vec3((mouse.zw - mouse.xy)*camSpeedTranslate, 0);\n\t\t\tcamPos = camBasis*(mouseControl + delta);\n\t\t} else if (MOUSE_CONTROL == float(MOUSE_CONTROL_ROTATE))\n\t\t\tcamRot.xy = mod(mouseControl.xy + (mouse.zw - mouse.xy)*camSpeedRotate, 2.0*PI);\n\t\tframeReset.x = true;\n\t} else\n\t\tMOUSE_CONTROL = float(MOUSE_CONTROL_NONE);\n\n\t// WASD controls\n\tif (texelFetch(keyboardSampler, ivec2(key_A,0), 0).x > 0.0) { camPos += camBasis*vec3(-1,0,0)*camSpeedTranslateWASD; frameReset.x = true; }\n\tif (texelFetch(keyboardSampler, ivec2(key_D,0), 0).x > 0.0) { camPos += camBasis*vec3(+1,0,0)*camSpeedTranslateWASD; frameReset.x = true; }\n\tif (texelFetch(keyboardSampler, ivec2(key_S,0), 0).x > 0.0) { camPos += camBasis*vec3(0,0,-1)*camSpeedTranslateWASD; frameReset.x = true; }\n\tif (texelFetch(keyboardSampler, ivec2(key_W,0), 0).x > 0.0) { camPos += camBasis*vec3(0,0,+1)*camSpeedTranslateWASD; frameReset.x = true; }\n\n\tcamera = mat4(camBasis);\n\tcamera[3].xyz = camPos;\n\t\n\tframe = max(vec2(0), vec2(frameIndex) - frameControl.xy);\n\tif (frameReset.x) frame.x = 0.0; // resets scene only\n    if (frameReset.y) frame.xy = vec2(0); // resets both scene and lightmap accum\n\tif (frame.x == 0.0) frameControl.x = float(frameIndex);\n    if (frame.y == 0.0) frameControl.y = float(frameIndex);\n\tivec2 coord = ivec2(floor(fragCoord.xy));\n\tif      (coord == frameControlCoord) fragColor = vec4(frameControl, 1);\n\telse if (coord == mouseControlCoord) fragColor = vec4(mouseControl, 1);\n    else if (coord == camPosCoord) fragColor = vec4(camPos, 1);\n\telse if (coord == camRotCoord) fragColor = vec4(camRot, 1);\n\telse return true;\n\n\treturn false;\n}\n\n// ================================================\n// === END CAMERA CODE ============================\n// ================================================\n\n#define NUM_PRIMARY_RAY_SAMPLES  16 // set as high as you can for best quality\n#define NUM_DIRECT_LIGHT_SAMPLES 16\n#define MIN_DEPTH_INDIRECT       2 // normally 2 (or 3 for the third bounce, etc.)\n#define MAX_DEPTH                2 // 1=direct lighting only, normally 2 or 3\n#define LAST_FRAME               32768 // stop early if you want to ..\n\n#define OBJ_ID_NONE         -1\n#define OBJ_ID_LEFT_WALL     0\n#define OBJ_ID_RIGHT_WALL    1\n#define OBJ_ID_FLOOR         2\n#define OBJ_ID_CEILING       3\n#define OBJ_ID_FRONT_WALL    4\n#define OBJ_ID_BACK_WALL     5\n#define OBJ_ID_LEFT_SPHERE   6\n#define OBJ_ID_RIGHT_SPHERE  7\n#define OBJ_ID_CEILING_LIGHT 8\n#define NUM_OBJECTS          9\n\n#define LIGHT_IS_QUAD (1)\n#if __VERSION__ >= 400 && defined(_GPU_SHADER_5_) // not my laptop, and certainly not WebGL :/\n#define LIGHT_TEXTURED (1 && LIGHT_IS_QUAD) // currently requires bindless texture extension so that i can pass samplers around as uint64_t\n#else\n#define LIGHT_TEXTURED (0)\n#endif\n\n#define LIGHTMAP (1)\n#define LIGHTMAP_PADDING 1\n#define LIGHTMAP_DOWNSAMPLE 2 // <-- change to 1 if running full resolution\n#define LIGHTMAP_QUAD_INSET 0.0625\n#define LIGHTMAP_QUAD_RES_U (164/LIGHTMAP_DOWNSAMPLE)\n#define LIGHTMAP_QUAD_RES_V (96/LIGHTMAP_DOWNSAMPLE)\n#define LIGHTMAP_SPHERE_ATLAS (1 && LIGHTMAP)\n#define LIGHTMAP_SPHERE_FACE_RES_1 (64/LIGHTMAP_DOWNSAMPLE)\n#define LIGHTMAP_SPHERE_FACE_RES_2 (52/LIGHTMAP_DOWNSAMPLE)\n#define LIGHTMAP_SPHERE_FACE_INSET 0.5\n\n#define SCREEN_JITTER  (0) // simple and cheap antialiasing\n#define DIFFUSE_ONLY   (1) // make the whole scene diffuse, for easier reference comparison\n#define TEST_FIREFLIES (1) // note: lots of fireflies with next event estimation (but not without)\n\n#define MATERIAL_TYPE_DIFFUSE    0\n#define MATERIAL_TYPE_SPECULAR   1\n#define MATERIAL_TYPE_REFRACTIVE 2\n\n#define KEYBOARD_SAMPLER      iChannel0\n#define LIGHTMAP_SAMPLER      iChannel1\n#define SCENE_SAMPLER         iChannel2\n#define NOISE_SAMPLER         iChannel3 // TODO -- use blue noise?\n#define VARIANCE_SAMPLER      iChannel3\n#define LIGHT_TEXTURE_SAMPLER iChannel4 // custom\n\n#define CONTROL_SAMPLER LIGHTMAP_SAMPLER // topleft pixels are used for control\n\n#define KEY_SHIFT 16\n#define KEY_CNTRL 17\n#define KEY_ALT   18\n#define KEY_SPACE 32\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n#define KEY_0     48\n#define KEY_1     49\n#define KEY_2     50\n#define KEY_A     65\n#define KEY_B     66\n#define KEY_C     67\n#define KEY_D     68\n#define KEY_E     69\n#define KEY_F     70\n#define KEY_G     71\n#define KEY_H     72\n#define KEY_I     73\n#define KEY_J     74\n#define KEY_K     75\n#define KEY_L     76\n#define KEY_M     77\n#define KEY_N     78\n#define KEY_O     79\n#define KEY_P     80\n#define KEY_Q     81\n#define KEY_R     82\n#define KEY_S     83\n#define KEY_T     84\n#define KEY_U     85\n#define KEY_V     86\n#define KEY_W     87\n#define KEY_X     88\n#define KEY_Y     89\n#define KEY_Z     90\n\n#define IS_KEY_DOWN(key)        (texelFetch(KEYBOARD_SAMPLER, ivec2(key,0), 0).x > 0.0)\n#define IS_KEY_PRESSED(key)     (texelFetch(KEYBOARD_SAMPLER, ivec2(key,1), 0).x > 0.0)\n#define IS_KEY_TOGGLED(key)     (texelFetch(KEYBOARD_SAMPLER, ivec2(key,2), 0).x > 0.0)\n#define IS_KEY_NOT_TOGGLED(key) (texelFetch(KEYBOARD_SAMPLER, ivec2(key,2), 0).x == 0.0)\n\n#define NO_UNROLL_(x, int_which_cannot_be_negative) ((x) + min(0, (int_which_cannot_be_negative)))\n#define NO_UNROLL(x) NO_UNROLL_(x, iFrame)\n\n// TODO -- maybe try improving the random function\n// see https://www.shadertoy.com/view/4djSRW\n#define USE_XORSHIFT_RNG (1) // xorshift seems slightly better in some situations ..\n#if USE_XORSHIFT_RNG\n#define RAND_SEED_TYPE uint\nRAND_SEED_TYPE seed = 0U;\nRAND_SEED_TYPE InitRandom(vec2 fragCoord, vec2 resolution, int frame, float time)\n{\n\tuint pixelIndex = uint(dot(fragCoord - vec2(0.5), vec2(1, resolution.x))); // [0..w*h-1]\n\tuint seed = pixelIndex + uint(frame*frame);\n    seed *= seed; // improves a bit more\n    return seed;\n}\nfloat rand(inout RAND_SEED_TYPE seed)\n{\n\tseed ^= seed << 13;\n\tseed ^= seed >> 17;\n\tseed ^= seed << 5;\n\treturn float(seed)*(1.0/4294967295.0); // [0..1]\n}\n#else\n#define RAND_SEED_TYPE float\nRAND_SEED_TYPE seed = 0.0;\nRAND_SEED_TYPE InitRandom(vec2 fragCoord, vec2 resolution, int frame, float time)\n{\n    vec2 screenPos = 2.0*fragCoord.xy/resolution.xy - 1.0;\n    return resolution.y*screenPos.x + screenPos.y + fract(time);\n}\nfloat rand(inout RAND_SEED_TYPE seed)\n{\n    return fract(sin(seed++)*43758.5453123);\n}\n#endif\nvec2 rand2(inout RAND_SEED_TYPE seed) { return vec2(rand(seed), rand(seed)); }\nvec3 rand3(inout RAND_SEED_TYPE seed) { return vec3(rand2(seed), rand(seed)); }\nvec4 rand4(inout RAND_SEED_TYPE seed) { return vec4(rand3(seed), rand(seed)); }\n\nmat3 transpose3x3(mat3 v)\n{\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 dir;\n};\n\nstruct Object\n{\n\tvec3 pos;\n\tfloat radius; // if zero, then it is a quad\n\tvec3 quadNormal;\n\tvec3 quadBasisX; // divided by extent\n\tvec3 quadBasisY; // divided by extent\n#if LIGHT_TEXTURED\n\tuint64_t quadLightTexture;\n#endif // LIGHT_TEXTURED\n#if LIGHTMAP\n    vec4 lightmapBounds;\n#endif // LIGHTMAP\n\tvec3 albedo;\n\tvec3 emissive;\n\tint materialType;\n};\nObject objects[NUM_OBJECTS];\n\nObject MakeQuad(vec3 pos, vec3 normal, vec3 basisX, float extentX, vec3 basisY, float extentY, vec3 albedo, vec3 emissive, int materialType)\n{\n\tObject quad;\n\tquad.pos = pos;\n\tquad.radius = 0.0;\n\tquad.quadNormal = normal;\n\tquad.quadBasisX = basisX/extentX;\n\tquad.quadBasisY = basisY/extentY;\n#if LIGHT_TEXTURED\n\tquad.quadLightTexture = 0U;\n#endif // LIGHT_TEXTURED\n#if LIGHTMAP\n    quad.lightmapBounds = vec4(0);\n#endif // LIGHTMAP\n    quad.albedo = albedo;\n\tquad.emissive = emissive;\n\tquad.materialType = materialType;\n\treturn quad;\n}\n\nObject MakeSphere(vec3 pos, float radius, vec3 albedo, vec3 emissive, int materialType)\n{\n\tObject sphere;\n\tsphere.pos = pos;\n\tsphere.radius = radius;\n\tsphere.quadNormal = vec3(0);\n\tsphere.quadBasisX = vec3(0);\n\tsphere.quadBasisY = vec3(0);\n#if LIGHT_TEXTURED\n\tsphere.quadLightTexture = 0U;\n#endif // LIGHT_TEXTURED\n#if LIGHTMAP\n    sphere.lightmapBounds = vec4(0);\n#endif // LIGHTMAP\n    sphere.albedo = albedo;\n\tsphere.emissive = emissive;\n\tsphere.materialType = materialType;\n\treturn sphere;\n}\n\nbool IsDiffuse(Object obj)\n{\n#if DIFFUSE_ONLY\n    return true; // always!\n#else\n    return obj.materialType == MATERIAL_TYPE_DIFFUSE;\n#endif\n}\n\nbool IsLight(Object obj)\n{\n    return max(max(obj.emissive.x, obj.emissive.y), obj.emissive.z) > 0.0;\n}\n\nbool IsQuad(Object obj)\n{\n\treturn obj.radius == 0.0;\n}\n\nbool IsSphere(Object obj)\n{\n\treturn obj.radius > 0.0;\n}\n\n#if LIGHTMAP\nvec4 PackRect(inout vec2 p, vec2 dims, float atlasWidth, inout float heightMax, float padding, float inset)\n{\n    if (p.x + dims.x + padding > atlasWidth) {\n        p.y += heightMax + padding;\n        p.x = padding;\n        heightMax = 0.0;\n    } else\n\t\theightMax = max(dims.y, heightMax);\n    vec4 rect = vec4(p, p + dims) + vec4(1,1,-1,-1)*inset;\n    p.x += dims.x + padding;\n    return rect;\n}\n\n#if LIGHTMAP_SPHERE_ATLAS\nfloat GetLightmapSphereFaceRes(Object obj)\n{\n    // assume 3x2 grid ..\n\treturn (obj.lightmapBounds.w - obj.lightmapBounds.y)*0.5;\n}\n#endif // LIGHTMAP_SPHERE_ATLAS\n#endif // LIGHTMAP\n\nSLIDER_VAR(vec3,obj_0_offset,0,-100,100);\nSLIDER_VAR(vec3,obj_1_offset,0,-100,100);\nSLIDER_VAR(vec3,light_offset,0,-100,100);\n\nvoid InitObjects(float lightmapAtlasWidth)\n{\n\t// Cornell Box is (smallpt version):\n\t// x = 1 (left) to 99 (right)\n\t// y = 0 (bottom) to 81.6 (top)\n\t// z = 0 (front) to 170 (back)\n\t// light is centered at 50,81.6,81.6 with radius 20\n\n\tconst float lightRadiusScale = 1.0;\n\tconst float lightRadius = 20.0*lightRadiusScale;\n\tconst float lightIntensity = (bool(TEST_FIREFLIES) ? 1.0 : 12.0)/(lightRadiusScale*lightRadiusScale);\n    \n#if 1 // use quads for falls\n\tobjects[OBJ_ID_LEFT_WALL ] = MakeQuad(vec3( 1.0,40.8, 85.0), vec3(+1,0,0), vec3(0,0,1), 85.0, vec3(0,-1,0), 40.8, vec3(0.75,0.25,0.25), vec3(0), MATERIAL_TYPE_DIFFUSE);\n\tobjects[OBJ_ID_RIGHT_WALL] = MakeQuad(vec3(99.0,40.8, 85.0), vec3(-1,0,0), vec3(0,0,1), 85.0, vec3(0,+1,0), 40.8, vec3(0.25,0.25,0.75), vec3(0), MATERIAL_TYPE_DIFFUSE);\n    objects[OBJ_ID_FLOOR     ] = MakeQuad(vec3(50.0, 0.0, 85.0), vec3(0,+1,0), vec3(0,0,1), 85.0, vec3(+1,0,0), 49.0, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE);\n\tobjects[OBJ_ID_CEILING   ] = MakeQuad(vec3(50.0,81.6, 85.0), vec3(0,-1,0), vec3(0,0,1), 85.0, vec3(-1,0,0), 49.0, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE);\n\tobjects[OBJ_ID_FRONT_WALL] = MakeQuad(vec3(50.0,40.8,  0.0), vec3(0,0,+1), vec3(1,0,0), 49.0, vec3(0,+1,0), 40.8, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE);\n\tobjects[OBJ_ID_BACK_WALL ] = MakeQuad(vec3(50.0,40.8,170.0), vec3(0,0,-1), vec3(1,0,0), 49.0, vec3(0,-1,0), 40.8, vec3(0.00), vec3(0), MATERIAL_TYPE_DIFFUSE);\n#else // use spheres for walls (original)\n\tconst float r = 1e5;\n\tobjects[OBJ_ID_LEFT_WALL ] = MakeSphere(vec3( 1.0 - r, 40.8, 81.6),  r, vec3(0.75,0.25,0.25), vec3(0), MATERIAL_TYPE_DIFFUSE);\n\tobjects[OBJ_ID_RIGHT_WALL] = MakeSphere(vec3(99.0 + r, 40.8, 81.6),  r, vec3(0.25,0.25,0.75), vec3(0), MATERIAL_TYPE_DIFFUSE);\n\tobjects[OBJ_ID_FLOOR     ] = MakeSphere(vec3(50.0, -r, 81.6),        r, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE);\n\tobjects[OBJ_ID_CEILING   ] = MakeSphere(vec3(50.0, 81.6 + r, 81.6),  r, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE);\n\tobjects[OBJ_ID_FRONT_WALL] = MakeSphere(vec3(50.0, 40.8, -r),        r, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE);\n\tobjects[OBJ_ID_BACK_WALL ] = MakeSphere(vec3(50.0, 40.8, 170.0 + r), r, vec3(0.0), vec3(0), MATERIAL_TYPE_DIFFUSE);\n#endif\n\tobjects[OBJ_ID_LEFT_SPHERE ] = MakeSphere(vec3(27.0, 16.5, 47.0), 16.5, vec3(0.9),         vec3(0), bool(DIFFUSE_ONLY) ? MATERIAL_TYPE_DIFFUSE : MATERIAL_TYPE_SPECULAR);\n\tobjects[OBJ_ID_RIGHT_SPHERE] = MakeSphere(vec3(73.0, 16.5, 78.0), 16.5, vec3(0.7,0.9,0.9), vec3(0), bool(DIFFUSE_ONLY) ? MATERIAL_TYPE_DIFFUSE : MATERIAL_TYPE_REFRACTIVE);\n#if LIGHT_IS_QUAD\n\tconst float epsilon = 1e-3;\n#if TEST_FIREFLIES\n    //objects[OBJ_ID_CEILING_LIGHT] = MakeQuad(vec3(1.0 + epsilon, lightRadius - 37.0, lightRadius + 10.0), vec3(1,0,0), vec3(0,1,0), lightRadius, vec3(0,0,1), lightRadius, vec3(0.0), vec3(lightIntensity), MATERIAL_TYPE_DIFFUSE); // wall light\n\tobjects[OBJ_ID_CEILING_LIGHT] = MakeQuad(vec3(20.0, lightRadius, 78.0), vec3(1,0,0), vec3(0,0,-1), lightRadius*640.0/480.0, vec3(0,1,0), lightRadius, vec3(0.0), vec3(lightIntensity), MATERIAL_TYPE_DIFFUSE);\n#else\n\tobjects[OBJ_ID_CEILING_LIGHT] = MakeQuad(vec3(50.0, 81.6 - epsilon, 81.6), vec3(0,-1,0), vec3(1,0,0), lightRadius, vec3(0,0,1), lightRadius, vec3(0.0), vec3(lightIntensity), MATERIAL_TYPE_DIFFUSE);\n#endif\n#else\n\tobjects[OBJ_ID_CEILING_LIGHT] = MakeSphere(vec3(50.0, 81.6, 81.6), lightRadius, vec3(0.0), vec3(lightIntensity), MATERIAL_TYPE_DIFFUSE);\n#endif\n\n#if LIGHTMAP\n\tif (lightmapAtlasWidth > 0.0) {\n\t\tconst float padding = float(LIGHTMAP_PADDING);\n\t\tvec2 p = vec2(padding);\n\t\tfloat hmax = 0.0;\n\t\tconst float quadInset = float(LIGHTMAP_QUAD_INSET);\n\t\tvec2 quadSize = vec2(LIGHTMAP_QUAD_RES_U, LIGHTMAP_QUAD_RES_V);\n\t\tobjects[OBJ_ID_LEFT_WALL   ].lightmapBounds = PackRect(p, quadSize,    lightmapAtlasWidth, hmax, padding, quadInset);\n\t\tobjects[OBJ_ID_FLOOR       ].lightmapBounds = PackRect(p, quadSize,    lightmapAtlasWidth, hmax, padding, quadInset);\n\t\tobjects[OBJ_ID_FRONT_WALL  ].lightmapBounds = PackRect(p, quadSize.yy, lightmapAtlasWidth, hmax, padding, quadInset);\n\t\tobjects[OBJ_ID_RIGHT_WALL  ].lightmapBounds = PackRect(p, quadSize,    lightmapAtlasWidth, hmax, padding, quadInset);\n\t\tobjects[OBJ_ID_CEILING     ].lightmapBounds = PackRect(p, quadSize,    lightmapAtlasWidth, hmax, padding, quadInset);\n\t\tobjects[OBJ_ID_BACK_WALL   ].lightmapBounds = vec4(0);\n\t\tobjects[OBJ_ID_LEFT_SPHERE ].lightmapBounds = PackRect(p, vec2(3,2)*float(LIGHTMAP_SPHERE_FACE_RES_1), lightmapAtlasWidth, hmax, padding, 0.0);\n\t\tobjects[OBJ_ID_RIGHT_SPHERE].lightmapBounds = PackRect(p, vec2(3,2)*float(LIGHTMAP_SPHERE_FACE_RES_2), lightmapAtlasWidth, hmax, padding, 0.0);\n\t}\n#endif // LIGHTMAP\n\n\tobjects[OBJ_ID_LEFT_SPHERE].pos += obj_0_offset;\n\tobjects[OBJ_ID_RIGHT_SPHERE].pos += obj_1_offset;\n\tobjects[OBJ_ID_CEILING_LIGHT].pos += light_offset;\n\n#if LIGHT_TEXTURED\n\tobjects[OBJ_ID_CEILING_LIGHT].quadLightTexture = uint64_t(LIGHT_TEXTURE_SAMPLER);\n#endif // LIGHT_TEXTURED\n}\n\n#define INIT_SCENE() \\\n\tbool diffuseUniformSampling = IS_KEY_TOGGLED    (KEY_U);\\\n\tbool directLightSampling    = IS_KEY_NOT_TOGGLED(KEY_E);\\\n    bool lightmapEnabled        = IS_KEY_TOGGLED    (KEY_L);\\\n    int  lightmapDepth          = lightmapEnabled ? 0 : -1;\\\n\tint  minDepth               = IS_KEY_TOGGLED(KEY_I) ? MIN_DEPTH_INDIRECT : 0;\\\n\tint  maxDepth               = IS_KEY_TOGGLED(KEY_O) ? 1 : max(MAX_DEPTH, MIN_DEPTH_INDIRECT);\\\n\tbool haltonEnabled          = IS_KEY_NOT_TOGGLED(KEY_H); \\\n\tseed = InitRandom(fragCoord, iResolution.xy, iFrame, iTime);\\\n\tInitObjects(lightmapEnabled ? iChannelResolution[1].x : 0.0)\n\n// ============================================================================\n\nvec3 GetQuadBasisX(Object quad) { return quad.quadBasisX/dot(quad.quadBasisX, quad.quadBasisX); }\nvec3 GetQuadBasisY(Object quad) { return quad.quadBasisY/dot(quad.quadBasisY, quad.quadBasisY); }\n\nvec3 QuadLocalToWorld(vec2 P, Object quad) // P is [-1..1]\n{\n\treturn quad.pos + GetQuadBasisX(quad)*P.x + GetQuadBasisY(quad)*P.y;\n}\n\nfloat GetQuadArea(Object quad)\n{\n\tfloat x = dot(quad.quadBasisX, quad.quadBasisX);\n\tfloat y = dot(quad.quadBasisY, quad.quadBasisY);\n\treturn 4.0/sqrt(x*y); // could precompute this ..\n}\n\nfloat GetSphereArea(Object sphere)\n{\n\treturn 4.0*PI*sphere.radius*sphere.radius;\n}\n\n// ============================================================================\n\nfloat DistanceToQuadOrPlane(vec3 P, Object quad, bool isInfinitePlane)\n{\n\tvec3 V = P - quad.pos;\n\tfloat vz = abs(dot(V, quad.quadNormal));\n\tif (!isInfinitePlane) {\n\t\tfloat ex = 1.0/length(quad.quadBasisX);\n\t\tfloat ey = 1.0/length(quad.quadBasisY);\n\t\tfloat vx = ex*max(0.0, abs(dot(V, quad.quadBasisX)) - 1.0);\n\t\tfloat vy = ey*max(0.0, abs(dot(V, quad.quadBasisY)) - 1.0);\n\t\tvz = length(vec3(vx, vy, vz));\n\t}\n\treturn vz;\n}\n\nfloat DistanceToQuad(vec3 P, Object quad)\n{\n\treturn DistanceToQuadOrPlane(P, quad, false);\n}\n\nfloat DistanceToSphere(vec3 P, Object sphere)\n{\n\tvec3 V = P - sphere.pos;\n\treturn length(V) - sphere.radius;\n}\n\nfloat DistanceToObject(vec3 P, Object obj)\n{\n\tif (IsQuad(obj))\n\t\treturn DistanceToQuad(P, obj);\n\telse\n\t\treturn DistanceToSphere(P, obj);\n}\n\n// ============================================================================\n\nvec3 ClosestPointOnQuadOrPlane(vec3 P, Object quad, bool isInfinitePlane)\n{\n\tvec3 V = P - quad.pos;\n\tfloat vz = dot(V, quad.quadNormal);\n\tif (!isInfinitePlane) {\n\t\tfloat vx = dot(V, quad.quadBasisX); // note quadBasis is divided by extent\n\t\tfloat vy = dot(V, quad.quadBasisY);\n\t\tvx = clamp(vx, -1.0, 1.0);\n\t\tvy = clamp(vy, -1.0, 1.0);\n\t\treturn QuadLocalToWorld(vec2(vx, vy), quad);\n\t} else\n\t\treturn P - quad.quadNormal*vz;\n}\n\nvec3 ClosestPointOnQuad(vec3 P, Object quad)\n{\n\treturn ClosestPointOnQuadOrPlane(P, quad, false);\n}\n\nvec3 ClosestPointOnSphere(vec3 P, Object sphere)\n{\n\tvec3 V = P - sphere.pos;\n\treturn sphere.pos + normalize(V)*sphere.radius;\n}\n\nvec3 ClosestPointOnObject(vec3 P, Object obj)\n{\n\tif (IsQuad(obj))\n\t\treturn ClosestPointOnQuad(P, obj);\n\telse\n\t\treturn ClosestPointOnSphere(P, obj);\n}\n\n// ============================================================================\n\nfloat IntersectQuadOrPlane(Ray ray, Object quad, bool isInfinitePlane, bool twoSided)\n{\n\tvec3 V = quad.pos - ray.origin;\n\tfloat t = 0.0;\n\tfloat d = dot(ray.dir, quad.quadNormal);\n\tif (d < 0.0 || twoSided) {\n\t\tt = max(0.0, dot(V, quad.quadNormal)/d);\n\t\tif (t > 0.0 && !isInfinitePlane) {\n\t\t\tV -= t*ray.dir;\n\t\t\tfloat vx = dot(V, quad.quadBasisX); // note quadBasis is divided by extent\n\t\t\tfloat vy = dot(V, quad.quadBasisY);\n\t\t\tif (max(abs(vx), abs(vy)) > 1.0)\n\t\t\t\tt = 0.0;\n\t\t}\n\t}\n\treturn t;\n}\n\nfloat IntersectQuad(Ray ray, Object quad)\n{\n\treturn IntersectQuadOrPlane(ray, quad, false, IsLight(quad));\n}\n\nfloat IntersectSphere(Ray ray, Object sphere)\n{\n\tvec3 V = sphere.pos - ray.origin;\n    float r = sphere.radius;\n\tfloat b = dot(V, ray.dir);\n\tfloat det = b*b - dot(V, V) + r*r;\n\tif (det < 0.0)\n\t\treturn 0.0;\n\telse {\n\t\tdet = sqrt(det);\n\t\tfloat epsilon = 1e-3;\n\t\tfloat t;\n\t\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.0);\n\t}\n}\n\nfloat IntersectObject(Ray ray, Object obj)\n{\n\tif (IsQuad(obj))\n\t\treturn IntersectQuad(ray, obj);\n\telse\n\t\treturn IntersectSphere(ray, obj);\n}\n\nint IntersectScene(Ray ray, int ignoreObjId, out float out_t, out Object out_obj)\n{\n\tint id = OBJ_ID_NONE;\n\tout_t = 1e5;\n\tout_obj = objects[0]; // none\n\tfor (int i = 0; i < NUM_OBJECTS; i++) {\n\t\tObject obj = objects[i];\n\t\tfloat t = IntersectObject(ray, obj);\n\t\tif (i != ignoreObjId && t != 0.0 && t < out_t) {\n\t\t\tid = i;\n\t\t\tout_t = t;\n\t\t\tout_obj = obj;\n\t\t}\n\t}\n\treturn id;\n}\n\nint IntersectScene(Ray ray, int ignoreObjId)\n{\n\tfloat t_unused;\n\tObject obj_unused;\n\treturn IntersectScene(ray, ignoreObjId, t_unused, obj_unused);\n}\n\n// ============================================================================\n\nvec3 GetSurfaceNormal(vec3 hitPos, Object obj)\n{\n\tif (IsQuad(obj))\n\t\treturn obj.quadNormal;\n\telse\n\t\treturn normalize(hitPos - obj.pos);\n}\n\nvec2 Weyl(int i)\n{\n    // http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n    // https://www.shadertoy.com/view/4dtBWH\n    //return fract(float(n)*vec2(0.754877669, 0.569840296));\n    return fract(vec2(i*ivec2(12664745, 9560333))/exp2(24.0)); // integer mul to avoid round-off\n}\n\nfloat Halton(int b, int i)\n{\n    float r = 0.0;\n    float f = 1.0;\n    while (i > 0) {\n        f = f / float(b);\n        r = r + f * float(i % b);\n        i = int(floor(float(i) / float(b)));\n    }\n    return r;\n}\n\nfloat Halton2(int i)\n{\n#if __VERSION__ >= 400\n\treturn float(bitfieldReverse(uint(i)))/4294967296.0;\n#else\n\treturn Halton(2, i);\n#endif\n}\n\nvec2 Halton23(int i)\n{\n    return vec2(Halton2(i), Halton(3, i));\n}\n\nvec2 Hammersley(int i, int n)\n{\n\tfloat y = float(i)/float(n); // [0..1)\n    return vec2(Halton2(i), y);\n}\n\nmat3 MakeOrthoBasis(vec3 N)\n{\n\tvec3 basisX = normalize(cross(N.yzx, N));\n\tvec3 basisY = cross(N, basisX);\n\treturn mat3(basisX, basisY, N);\n}\n\nvec3 SampleSpherical(float sinTheta, float cosTheta, float phi)\n{\n\tfloat sinPhi = sin(phi);\n\tfloat cosPhi = cos(phi);\n\treturn vec3(vec2(cosPhi, sinPhi)*sinTheta, cosTheta);\n}\n\nvec3 SampleHemisphere(vec3 N, float sinTheta, float cosTheta, float s_x)\n{\n\tfloat phi = 2.0*PI*s_x;\n\treturn MakeOrthoBasis(N)*SampleSpherical(sinTheta, cosTheta, phi);\n}\n\nvec3 SampleHemisphereCosineWeighted(vec3 N, vec2 s)\n{\n    float sinThetaSqr = s.y;\n\tfloat sinTheta = sqrt(sinThetaSqr);\n\tfloat cosTheta = sqrt(1.0 - sinThetaSqr);\n\treturn SampleHemisphere(N, sinTheta, cosTheta, s.x);\n}\n\nvec3 SampleHemisphereUniformCone(vec3 N, vec2 s, float halfConeAngleInRadians)\n{\n\tfloat cosTheta = s.y;\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\tfloat phi = 2.0*PI*s.x;\n\tvec3 V = SampleSpherical(sinTheta, cosTheta, phi);\n\tfloat NdotV = dot(N, V);\n\tif (NdotV < 0.0) { // necessary if N != {0,0,1}\n\t\tV = -V;\n\t\tNdotV = -NdotV;\n\t}\n\tif (halfConeAngleInRadians != PI*0.5) {\n\t\tfloat c2 = cos(acos(NdotV)*halfConeAngleInRadians); c2 *= c2;\n\t\tfloat s2 = 1.0 - c2;\n\t\tfloat z = sqrt((c2/s2)*(1.0 - NdotV*NdotV)) - NdotV;\n\t\tV = normalize(V + N*z);\n\t}\n    return V;\n}\n\nvec3 SampleHemisphereUniform(vec3 N, vec2 s)\n{\n\treturn SampleHemisphereUniformCone(N, s, PI*0.5);\n}\n\nfloat LTC_IntegrateEdge(vec3 v1, vec3 v2)\n{\n\tfloat theta = acos(dot(v1, v2));\n#if 0 // from https://blog.selfshadow.com/sandbox/ltc.html\n\treturn (v1.x*v2.y - v1.y*v2.x)*((theta > 0.001) ? theta/sin(theta) : 1.0);\n#else // from http://jsfiddle.net/hh74z2ft -- appears to be the same\n    return normalize(cross(v1, v2)).z*theta;\n#endif\n}\n\nint LTC_ClipQuadToHorizonPlane(inout vec3 L[5], in float d[4])\n{\n\t// detect clipping config\n\tint config = 0;\n\tif (d[0] > 0.0) config += 1;\n\tif (d[1] > 0.0) config += 2;\n\tif (d[2] > 0.0) config += 4;\n\tif (d[3] > 0.0) config += 8;\n\n\tif (config == 1) { // L0 clip L1 L2 L3\n\t\tL[1] = -d[1] * L[0] + d[0] * L[1]; // L1 = clip(L1,L0)\n\t\tL[2] = -d[3] * L[0] + d[0] * L[3]; // L2 = clip(L3,L0)\n\t\treturn 3;\n\t} else if (config == 2) { // L1 clip L0 L2 L3\n\t\tL[0] = -d[0] * L[1] + d[1] * L[0]; // L0 = clip(L0,L1)\n\t\tL[2] = -d[2] * L[1] + d[1] * L[2]; // L2 = clip(L2,L1)\n\t\treturn 3;\n\t} else if (config == 3) { // L0 L1 clip L2 L3\n\t\tL[2] = -d[2] * L[1] + d[1] * L[2]; // L2 = clip(L2,L1)\n\t\tL[3] = -d[3] * L[0] + d[0] * L[3]; // L3 = clip(L3,L0)\n\t\treturn 4;\n\t} else if (config == 4) { // L2 clip L0 L1 L3\n\t\tL[0] = -d[3] * L[2] + d[2] * L[3]; // L0 = clip(L3,L2)\n\t\tL[1] = -d[1] * L[2] + d[2] * L[1]; // L1 = clip(L1,L2)\n\t\treturn 3;\n//  } else if (config == 5) { // L0 L2 clip L1 L3  (impossible)\n\t} else if (config == 6) { // L1 L2 clip L0 L3\n\t\tL[0] = -d[0] * L[1] + d[1] * L[0]; // L0 = clip(L0,L1)\n\t\tL[3] = -d[3] * L[2] + d[2] * L[3]; // L3 = clip(L3,L2)\n\t\treturn 4;\n\t} else if (config == 7) { // L0 L1 L2 clip L3\n\t\tL[4] = -d[3] * L[0] + d[0] * L[3]; // L4 = clip(L3,L0)\n\t\tL[3] = -d[3] * L[2] + d[2] * L[3]; // L3 = clip(L3,L2)\n\t\treturn 5;\n\t} else if (config == 8) { // L3 clip L0 L1 L2\n\t\tL[0] = -d[0] * L[3] + d[3] * L[0]; // L0 = clip(L0,L3)\n\t\tL[1] = -d[2] * L[3] + d[3] * L[2]; // L1 = clip(L2,L3)\n\t\tL[2] =  L[3];\n\t\treturn 3;\n\t} else if (config == 9) { // L0 L3 clip L1 L2\n\t\tL[1] = -d[1] * L[0] + d[0] * L[1]; // L1 = clip(L1,L0)\n\t\tL[2] = -d[2] * L[3] + d[3] * L[2]; // L2 = clip(L2,L3)\n\t\treturn 4;\n//\t} else if (config == 10) { // L1 L3 clip L0 L2 (impossible)\n\t} else if (config == 11) { // L0 L1 L3 clip L2\n\t\tL[4] =  L[3];\n\t\tL[3] = -d[2] * L[3] + d[3] * L[2]; // L3 = clip(L2,L3)\n\t\tL[2] = -d[2] * L[1] + d[1] * L[2]; // L2 = clip(L2,L1)\n\t\treturn 5;\n\t} else if (config == 12) { // L2 L3 clip L0 L1\n\t\tL[1] = -d[1] * L[2] + d[2] * L[1]; // L1 = clip(L1,L2)\n\t\tL[0] = -d[0] * L[3] + d[3] * L[0]; // L0 = clip(L0,L3)\n\t\treturn 4;\n\t} else if (config == 13) { // L0 L2 L3 clip L1\n\t\tL[4] =  L[3];\n\t\tL[3] =  L[2];\n\t\tL[2] = -d[1] * L[2] + d[2] * L[1]; // L2 = clip(L2,L1)\n\t\tL[1] = -d[1] * L[0] + d[0] * L[1]; // L1 = clip(L1,L0)\n\t\treturn 5;\n\t} else if (config == 14) { // L1 L2 L3 clip L0\n\t\tL[4] = -d[0] * L[3] + d[3] * L[0]; // L4 = clip(L0,L3)\n\t\tL[0] = -d[0] * L[1] + d[1] * L[0]; // L0 = clip(L0,L1)\n\t\treturn 5;\n\t} else if (config == 15) // L0 L1 L2 L3 (no clipping)\n\t\treturn 4;\n\telse\n\t\treturn 0; // all points clipped\n}\n\nfloat LTC_Evaluate(vec3 P, vec3 N, vec3 V, mat3 Minv, vec3 corners[4], bool clipToHorizon, bool twoSided)\n{\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize(V - N*dot(V, N));\n\tT2 = cross(N, T1);\n\t\n\t// rotate area light in (T1, T2, N) basis\n\tMinv = Minv*transpose3x3(mat3(T1, T2, N));\n\n\t// polygon (allocate 5 vertices for clipping)\n\tvec3 L[5];\n\tL[0] = Minv*(corners[0] - P);\n\tL[1] = Minv*(corners[1] - P);\n\tL[2] = Minv*(corners[2] - P);\n\tL[3] = Minv*(corners[3] - P);\n\tfloat d[4]; // distances to clipping plane\n\td[0] = L[0].z;\n\td[1] = L[1].z;\n\td[2] = L[2].z;\n\td[3] = L[3].z;\n\tint n = 4;\n\tif (clipToHorizon)\n\t\tn = LTC_ClipQuadToHorizonPlane(L, d);\n\n\t// integrate\n\tfloat sum = 0.0;\n\tif (n > 0) {\n\t\tL[0] = normalize(L[0]);\n\t\tL[1] = normalize(L[1]);\n\t\tL[2] = normalize(L[2]);\n\t\tsum += LTC_IntegrateEdge(L[0], L[1]);\n\t\tsum += LTC_IntegrateEdge(L[1], L[2]);\n\t#if 0 // generalized for N-sided polygon\n\t\tint i = 3;\n\t\twhile (i < n) {\n\t\t\tL[i] = normalize(L[i]);\n\t\t\tsum += LTC_IntegrateEdge(L[i - 1], L[i]);\n\t\t\ti++;\n\t\t}\n\t\tsum += LTC_IntegrateEdge(L[i - 1], L[0]);\n\t#else\n\t\tif (n == 3)\n\t\t\tsum += LTC_IntegrateEdge(L[2], L[0]);\n\t\telse { // n >= 4\n\t\t\tL[3] = normalize(L[3]);\n\t\t\tsum += LTC_IntegrateEdge(L[2], L[3]);\n\t\t\tif (n == 4)\n\t\t\t\tsum += LTC_IntegrateEdge(L[3], L[0]);\n\t\t\telse { // n >= 5\n\t\t\t\tL[4] = normalize(L[4]);\n\t\t\t\tsum += LTC_IntegrateEdge(L[3], L[4]);\n\t\t\t\tsum += LTC_IntegrateEdge(L[4], L[0]);\n\t\t\t}\n\t\t}\n\t#endif\n\t}\n\tsum *= 0.5/PI;\n\treturn twoSided ? abs(sum) : max(0.0, sum);\n}\n\nfloat LTC_EvaluateDiffuse(vec3 P, vec3 N, Object light)\n{\n\tif (IsQuad(light)) {\n\t\tvec3 V = light.pos - P;\n        vec3 bx = GetQuadBasisX(light);\n\t\tvec3 by = GetQuadBasisY(light);\n\t\tvec3 corners[4] = vec3[4](\n\t\t\tlight.pos - bx + by,\n\t\t\tlight.pos + bx + by,\n\t\t\tlight.pos + bx - by,\n\t\t\tlight.pos - bx - by\n\t\t);\n\t\tconst bool clipToHorizon = true;\n\t\tconst bool twoSided = false;\n\t\treturn LTC_Evaluate(P, N, V, mat3(1), corners, clipToHorizon, twoSided);\n\t} else\n\t\treturn 0.0; // not implemented for sphere\n}\n\nSLIDER_VAR(float,light_intensity,1.5,0,10);\n#if LIGHT_TEXTURED\nSLIDER_VAR(float,light_texture_LOD,1,0,10);\n#endif // LIGHT_TEXTURED\n\n// =============================================================\n// set MAX = 0 to always direct sample light\n// set MIN = MAX > 0 to direct sample light beyond this distance\n// set MIN < MAX to make it probabilistic\n// =============================================================\nSLIDER_VAR(bool,direct_light_dist_enabled,true,x,x);\nSLIDER_VAR(bool,direct_light_dist_dbg,false,x,x);\nSLIDER_VAR(float,direct_light_dist_min,0,0,100);\nSLIDER_VAR(float,direct_light_dist_max,0,0,100);\n\nSLIDER_VAR(bool,MIS_enabled,true,x,x);\nSLIDER_VAR(float,MIS_ratio_default,0.5,0,1);\n#define MIS_USE_POWER (0) // doesnt seem to make any difference\n#if MIS_USE_POWER\nSLIDER_VAR_CONST(float,MIS_power_b,2,1,16);\n#endif // MIS_USE_POWER\n\nSLIDER_VAR(bool,MIS_light_dist_enabled,true,x,x);  // these control the ratio of direct samples vs hemisphere samples for MIS based on distance\nSLIDER_VAR(bool,MIS_light_dist_dbg,false,x,x);\nSLIDER_VAR(float,MIS_light_dist_min,0,0,100);\nSLIDER_VAR(float,MIS_light_dist_max,0,0,100);\n\nbool ShouldSampleLight(vec3 P, vec3 N, Object light, inout vec3 dbg)\n{\n\tif (IsLight(light)) {\n\t\tif (direct_light_dist_enabled && direct_light_dist_max <= 0.0)\n\t\t\treturn true;\n\t\telse {\n\t\t\tfloat dmax = direct_light_dist_max;\n\t\t\tfloat dmin = min(dmax - 0.0001, direct_light_dist_min);\n\t\t\tfloat ds = 1.0/(dmin - dmax);\n\t\t\tfloat d0 = -ds*dmax;\n\t\t\tfloat q = clamp(DistanceToObject(P, light)*ds + d0, 0.0, 1.0); // q=1 @ min dist, q=0 @ max dist\n\t\t\tif (direct_light_dist_dbg) {\n\t\t\t\tdbg += vec3(q*q);\n\t\t\t\treturn true;\n\t\t\t} else if (q < rand(seed))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvec3 SampleLightColor(vec3 P, Object light)\n{\n\tvec3 color = light.emissive*light_intensity;\n#if LIGHT_TEXTURED\n\tif (light.quadLightTexture != 0U) {\n\t\tvec3 V = P - light.pos;\n\t\tfloat vx = dot(V, light.quadBasisX); // note quadBasis is divided by extent\n\t\tfloat vy = dot(V, light.quadBasisY);\n\t\tvec2 uv = vec2(vx, -vy)*0.5 + vec2(0.5); // [0..1]\n\t\tcolor *= textureLod(sampler2D(light.quadLightTexture), uv, light_texture_LOD).rgb;\n\t}\n#endif // LIGHT_TEXTURED\n\t//if (IsSphere(light)) {\n\t//\tvec3 V = normalize(P - light.pos);\n\t//\tvec3 A = abs(V);\n\t//\tcolor *= mix(vec3(0.1), V*0.5 + vec3(0.5), pow(max(max(A.x, A.y), A.z), 8.0));\n\t//}\n\treturn color;\n}\n\nvec3 SampleLight(Object light, int lightId, int ignoreObjId, vec3 P, vec3 N, vec2 s, bool sphericalLightIsTextured)\n{\n\tvec3 V;\n    vec3 L;\n    float inversePDF_d;\n    if (IsQuad(light)) {\n        V = QuadLocalToWorld(s*2.0 - vec2(1.0), light) - P;\n        L = normalize(V);\n\t\tfloat distSqr = dot(V, V);\n        inversePDF_d = GetQuadArea(light)*max(0.0, -dot(light.quadNormal, L))/distSqr;\n    } else {\n        // http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources.html\n        vec3 pointToLight = light.pos - P;\n\t\tfloat radiusSqr = light.radius*light.radius;\n        float sinThetaMaxSqr = radiusSqr/dot(pointToLight, pointToLight);\n        float cosThetaMax = sqrt(1.0 - sinThetaMaxSqr);\n        float cosTheta = cosThetaMax + (1.0 - cosThetaMax)*s.y;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\tif (sphericalLightIsTextured) {\n\t\t\tfloat dc = length(pointToLight);\n\t\t\tfloat ds = dc*cosTheta - sqrt(max(0.0, radiusSqr - dc*dc*sinTheta*sinTheta));\n\t\t\tfloat cosAlpha = (radiusSqr + dc*dc - ds*ds)/(2.0*dc*light.radius);\n\t\t\tfloat sinAlpha = sqrt(max(0.0, 1.0 - cosAlpha*cosAlpha));\n\t\t\tV = light.pos + light.radius*SampleHemisphere(-normalize(pointToLight), sinAlpha, cosAlpha, s.x) - P;\n\t\t\tL = normalize(V);\n\t\t} else {\n\t\t\tV = vec3(0);\n\t\t\tL = SampleHemisphere(normalize(pointToLight), sinTheta, cosTheta, s.x);\n\t\t}\n\t\tinversePDF_d = 2.0*PI*(1.0 - cosThetaMax);\n    }\n\tinversePDF_d *= max(0.0, dot(N, L))/PI;\n    if (inversePDF_d > 0.0 && IntersectScene(Ray(P, L), ignoreObjId) == lightId)\n\t\treturn SampleLightColor(P + V, light)*inversePDF_d;\n\telse\n\t\treturn vec3(0);\n}\n\n// sample MIS direct light distribution\nvec3 SampleLightMIS_d(Object light, int lightId, int ignoreObjId, vec3 P, vec3 N, vec2 s, float N_d, float N_h, bool sphericalLightIsTextured)\n{\n\tvec3 V;\n    vec3 L;\n    float inversePDF_d;\n    if (IsQuad(light)) {\n        V = QuadLocalToWorld(s*2.0 - vec2(1.0), light) - P;\n\t    L = normalize(V);\n\t\tfloat distSqr = dot(V, V);\n        inversePDF_d = GetQuadArea(light)*max(0.0, -dot(light.quadNormal, L))/distSqr;\n    } else {\n        // http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources.html\n        vec3 pointToLight = light.pos - P;\n\t\tfloat radiusSqr = light.radius*light.radius;\n        float sinThetaMaxSqr = radiusSqr/dot(pointToLight, pointToLight);\n        float cosThetaMax = sqrt(1.0 - sinThetaMaxSqr);\n        float cosTheta = cosThetaMax + (1.0 - cosThetaMax)*s.y;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\tif (sphericalLightIsTextured) {\n\t\t\tfloat dc = length(pointToLight);\n\t\t\tfloat ds = dc*cosTheta - sqrt(max(0.0, radiusSqr - dc*dc*sinTheta*sinTheta));\n\t\t\tfloat cosAlpha = (radiusSqr + dc*dc - ds*ds)/(2.0*dc*light.radius);\n\t\t\tfloat sinAlpha = sqrt(max(0.0, 1.0 - cosAlpha*cosAlpha));\n\t\t\tV = light.pos + light.radius*SampleHemisphere(-normalize(pointToLight), sinAlpha, cosAlpha, s.x) - P;\n\t\t\tL = normalize(V);\n\t\t} else {\n\t\t\tV = vec3(0);\n\t\t\tL = SampleHemisphere(normalize(pointToLight), sinTheta, cosTheta, s.x);\n\t\t}\n        inversePDF_d = 2.0*PI*(1.0 - cosThetaMax);\n\t}\n\tinversePDF_d *= max(0.0, dot(N, L))/PI;\n    if (inversePDF_d > 0.0 && IntersectScene(Ray(P, L), ignoreObjId) == lightId) {\n\t\tfloat PDF_d = 1.0/inversePDF_d;\n\t\tfloat PDF_h = 1.0;\n\t#if MIS_USE_POWER\n\t\tfloat b = MIS_power_b;\n\t\treturn SampleLightColor(P + V, light)*pow(N_d*PDF_d, b - 1.0)/(pow(N_d*PDF_d, b) + pow(N_h*PDF_h, b));\n\t#else\n\t\treturn SampleLightColor(P + V, light)/(N_d*PDF_d + N_h*PDF_h);\n\t#endif\n\t}\n\treturn vec3(0);\n}\n\n// sample MIS hemisphere distribution\nvec3 SampleLightMIS_h(Object light, int lightId, int ignoreObjId, vec3 P, vec3 N, vec2 s, float N_d, float N_h)\n{\n\tvec3 L = SampleHemisphereCosineWeighted(N, s);\n\tfloat t;\n\tObject unused;\n\tif (IntersectScene(Ray(P, L), ignoreObjId, t, unused) == lightId) {\n\t\tvec3 V = L*t;\n\t\tfloat inversePDF_d;\n\t\tif (IsQuad(light)) {\n\t\t\tfloat distSqr = t*t; // same as dot(V, V)\n\t\t\tinversePDF_d = GetQuadArea(light)*max(0.0, -dot(light.quadNormal, L))/distSqr;\n\t\t} else {\n\t\t\tvec3 pointToLight = light.pos - P;\n\t\t\tfloat radiusSqr = light.radius*light.radius;\n\t\t\tfloat sinThetaMaxSqr = radiusSqr/dot(pointToLight, pointToLight);\n\t\t\tfloat cosThetaMax = sqrt(1.0 - sinThetaMaxSqr);\n\t\t\tinversePDF_d = 2.0*PI*(1.0 - cosThetaMax);\n\t\t}\n\t\tinversePDF_d *= max(0.0, dot(N, L))/PI;\n\t\tif (inversePDF_d > 0.0) {\n\t\t\tfloat PDF_d = 1.0/inversePDF_d;\n\t\t\tfloat PDF_h = 1.0;\n\t\t#if MIS_USE_POWER\n\t\t\tfloat b = MIS_power_b;\n\t\t\treturn SampleLightColor(P + V, light)*pow(N_h*PDF_h, b - 1.0)/(pow(N_d*PDF_d, b) + pow(N_h*PDF_h, b));\n\t\t#else\n\t\t\treturn SampleLightColor(P + V, light)/(N_d*PDF_d + N_h*PDF_h);\n\t\t#endif\n\t\t}\n\t}\n\treturn vec3(0);\n}\n\nvec3 SampleLightsInScene(\n\tvec3 P,\n\tvec3 N,\n\tbool haltonEnabled,\n\tvec2 offset,\n\tint objId,\n\tint frameIndex, // iFrame\n\tint numLightSamples,\n\tinout uint wasSampled)\n{\n\tbool sphericalLightIsTextured = false; // enable this if SampleLightColor needs position for spherical lights\n\tvec3 e = vec3(0);\n\tfor (int lightId = 0; lightId < NO_UNROLL_(NUM_OBJECTS, objId); lightId++) {\n\t\tObject light = objects[lightId];\n\t\tif (IsQuad(light) && dot(light.pos - P, light.quadNormal) >= 0.0) { // facing away?\n\t\t\twasSampled |= (1U << lightId); // might as well mark this light as sampled, we won't hit it in the next bounce\n\t\t\tcontinue;\n\t\t}\n\t\tif (ShouldSampleLight(P, N, light, e)) {\n\t\t\tvec3 l = vec3(0);\n\t\t\tif (MIS_enabled) {\n\t\t\t\tfloat q = MIS_ratio_default; // controls ratio N_h / N_d (hemisphere samples to direct light samples)\n\t\t\t\tif (MIS_light_dist_enabled && MIS_light_dist_max > 0.0) {\n\t\t\t\t\tfloat dmax = MIS_light_dist_max;\n\t\t\t\t\tfloat dmin = min(dmax - 0.0001, MIS_light_dist_min);\n\t\t\t\t\tfloat ds = 1.0/(dmin - dmax);\n\t\t\t\t\tfloat d0 = -ds*dmax;\n\t\t\t\t\tq = clamp(DistanceToObject(P, light)*ds + d0, 0.0, 1.0);\n\t\t\t\t}\n\t\t\t\tif (MIS_light_dist_dbg)\n\t\t\t\t\te += vec3(q*q);\n\t\t\t\tint N_h = int(floor(0.5 + float(numLightSamples)*q)); // [0..numLightSamples]\n\t\t\t\tint N_d = numLightSamples - N_h; // [0..numLightSamples]\n\t\t\t\tfor (int i = 0; i < N_d; i++) {\n\t\t\t\t\tvec2 s = haltonEnabled ? fract(offset + Halton23(i + frameIndex*N_d)) : rand2(seed);\n\t\t\t\t\tl += SampleLightMIS_d(light, lightId, objId, P, N, s, float(N_d), float(N_h), sphericalLightIsTextured);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < N_h; i++) {\n\t\t\t\t\tvec2 s = haltonEnabled ? fract(offset + Halton23(i + frameIndex*N_h)) : rand2(seed);\n\t\t\t\t\tl += SampleLightMIS_h(light, lightId, objId, P, N, s, float(N_d), float(N_h));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < NO_UNROLL_(numLightSamples, objId); i++) {\n\t\t\t\t\tvec2 s = haltonEnabled ? fract(offset + Halton23(i + frameIndex*numLightSamples)) : rand2(seed);\n\t\t\t\t\tl += SampleLight(light, lightId, objId, P, N, s, sphericalLightIsTextured);\n\t\t\t\t}\n\t\t\t\tl /= float(numLightSamples);\n\t\t\t}\n\t\t\te += l;\n\t\t\twasSampled |= (1U << lightId);\n\t\t}\n\t}\n\treturn e;\n}\n\n#if LIGHTMAP\nvec2 ComputeLightmapUV(Object obj, vec3 V, sampler2D lightmapSampler)\n{\n    vec2 lightmapUV = vec2(-1);\n    vec2 lightmapResInv = 1.0/vec2(textureSize(lightmapSampler, 0)); // we could pass this in ..\n    if (IsQuad(obj)) {\n        vec2 st;\n        st.x = dot(V, obj.quadBasisX);\n        st.y = dot(V, obj.quadBasisY);\n        vec2 uv = st*0.5 + vec2(0.5); // [0..1]\n        vec4 atlasBounds = obj.lightmapBounds;\n        atlasBounds.zw -= atlasBounds.xy; // width, height\n        if (float(LIGHTMAP_QUAD_INSET) < 0.5) { // don't sample outside the lightmap bounds (if we are filtering)\n            vec2 uvmin = vec2(0.5)/atlasBounds.zw;\n            vec2 uvmax = vec2(1) - uvmin;\n            uv = clamp(uv, uvmin, uvmax);\n        }\n        atlasBounds *= lightmapResInv.xyxy;\n        lightmapUV = atlasBounds.xy + atlasBounds.zw*uv;\n    } else {\n        int faceRow;\n        int faceCol;\n        vec2 facePos;\n        vec3 Va = abs(V);\n        float Vamax = max(max(Va.x, Va.y), Va.z);\n        if (Vamax == Va.x) {\n            faceCol = 0;\n            faceRow = V.x < 0.0 ? 1 : 0;\n            facePos = V.yz/Va.x;\n        } else if (Vamax == Va.y) {\n            faceCol = 1;\n            faceRow = V.y < 0.0 ? 1 : 0;\n            facePos = V.zx/Va.y;\n        } else { // Vamax == Va.z\n            faceCol = 2;\n            faceRow = V.z < 0.0 ? 1 : 0;\n            facePos = V.xy/Va.z;\n        }\n        vec2 faceUV = facePos*0.5 + vec2(0.5); // [0..1]\n        float faceRes = GetLightmapSphereFaceRes(obj);\n        vec2 faceBoundsMin = vec2(faceCol + 0, faceRow + 0)*faceRes + vec2(LIGHTMAP_SPHERE_FACE_INSET);\n        vec2 faceBoundsMax = vec2(faceCol + 1, faceRow + 1)*faceRes - vec2(LIGHTMAP_SPHERE_FACE_INSET);\n        vec2 uv = obj.lightmapBounds.xy + faceBoundsMin + (faceBoundsMax - faceBoundsMin)*faceUV;\n        lightmapUV = uv*lightmapResInv;\n    }\n    return lightmapUV;\n}\n#endif // LIGHTMAP\n\nvec3 ComputeRadiance(\n    Ray ray,\n    int objId,\n    int depth,\n\tint depthMin,\n\tint depthMax,\n\tbool diffuseUniformSampling,\n#if LIGHTMAP\n    int lightmapDepth,\n    sampler2D lightmapSampler,\n#endif // LIGHTMAP\n    bool directLightSampling,\n    uint wasSampled)\n{\n\tvec3 acc = vec3(0);\n\tvec3 mask = vec3(1);\n\tfor (; depth <= NO_UNROLL_(depthMax, objId); depth++) {\n\t\tfloat t;\n\t\tObject obj;\n\t\tif ((objId = IntersectScene(ray, objId, t, obj)) < 0)\n\t\t\tbreak;\n\t\tvec3 P = ray.origin + t*ray.dir;\n    #if LIGHTMAP\n        if (depth == lightmapDepth && obj.lightmapBounds != vec4(0) && IsDiffuse(obj)) {\n            vec2 lightmapUV = ComputeLightmapUV(obj, P - obj.pos, lightmapSampler);\n            if (lightmapUV.x != -1.0) {\n                acc += mask*texture(lightmapSampler, lightmapUV).rgb;\n                break;\n            }\n        }\n    #endif // LIGHTMAP\n\t\tvec3 N = GetSurfaceNormal(P, obj);\n        if ((wasSampled & (1U << objId)) == 0U && depth >= depthMin && dot(N, ray.dir) < 0.0)\n\t\t\tacc += mask*SampleLightColor(P, obj);\n        wasSampled = 0U;\n\t\tif (IsDiffuse(obj)) {\n\t\t\tmask *= obj.albedo;\n\t\t\tint depthNext = depth + 1;\n\t\t\tif (directLightSampling && depthNext <= depthMax && depthNext >= depthMin)\n\t\t\t\tacc += mask*SampleLightsInScene(\n\t\t\t\t\tP,\n\t\t\t\t\tN,\n\t\t\t\t\tfalse, // haltonEnabled\n\t\t\t\t\tvec2(0), // offset\n\t\t\t\t\tobjId,\n\t\t\t\t\t0, // frameIndex\n\t\t\t\t\t1, // numLightSamples\n\t\t\t\t\twasSampled);\n\t\t\tvec3 rayDir;\n\t\t\tvec2 s = rand2(seed);\n\t\t\tif (diffuseUniformSampling) {\n\t\t\t\trayDir = SampleHemisphereUniform(N, s);\n\t\t\t\tmask *= dot(N, rayDir)*2.0; // why 2.0?\n\t\t\t} else\n\t\t\t\trayDir = SampleHemisphereCosineWeighted(N, s);\n    \t\tray = Ray(P, rayDir);\n\t\t}\n    #if !DIFFUSE_ONLY\n        else if (obj.materialType == MATERIAL_TYPE_SPECULAR) {\n\t\t\tmask *= obj.albedo;\n\t\t\tray = Ray(P, reflect(ray.dir, N));\n\t\t} else { // MATERIAL_TYPE_REFRACTIVE\n\t\t\tfloat a = dot(N, ray.dir);\n\t\t\tfloat ddn = abs(a);\n\t\t\tfloat nc = 1.0;\n\t\t\tfloat nt = 1.5;\n\t\t\tfloat nnt = mix(nc/nt, nt/nc, float(a > 0.0));\n\t\t\tfloat cos2t = 1.0 - nnt*nnt*(1.0 - ddn*ddn);\n\t\t\tray = Ray(P, reflect(ray.dir, N));\n\t\t\tif (cos2t > 0.0) {\n\t\t\t\tvec3 tdir = normalize(ray.dir*nnt + sign(a)*N*(ddn*nnt + sqrt(cos2t)));\n\t\t\t\tfloat R0 = (nt - nc)/(nt + nc);\n\t\t\t\tR0 *= R0;\n\t\t\t\tfloat c = 1.0 - mix(ddn, dot(tdir, N), float(a > 0.0));\n\t\t\t\tfloat Re = R0 + (1.0 - R0)*c*c*c*c*c;\n\t\t\t\tfloat _P = 0.25 + 0.5*Re;\n\t\t\t\tfloat RP = Re/_P;\n\t\t\t\tfloat TP = (1.0 - Re)/(1.0 - _P);\n\t\t\t\tif (rand(seed) < _P)\n\t\t\t\t\tmask *= RP;\n\t\t\t\telse {\n\t\t\t\t\tmask *= obj.albedo*TP;\n\t\t\t\t\tray = Ray(P, tdir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    #endif // !DIFFUSE_ONLY\n\t}\n\treturn acc;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//$INPUT0=KEYBOARD\n//$INPUT1=BUFFER_A\n//$INPUT2=BUFFER_B\n//$INPUT3=RGBA_NOISE_MEDIUM_TEXTURE\n//$INPUT4=PASSIONFLOWER_TEXTURE\n//$OUTPUT=BUFFER_B\n//$OUTPUT_RES_X=-0.25\n//$OUTPUT_RES_Y=-0.25\n//$OUTPUT_FILTER=OFF\n\n// =======================\n// Buffer B: renders scene\n// =======================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tINIT_SCENE();\n\n\tivec2 controlSamplerRes = textureSize(CONTROL_SAMPLER, 0);\n\tivec2 frameControlCoord = controlSamplerRes - ivec2(1,1);\n\tivec2 mouseControlCoord = controlSamplerRes - ivec2(2,1);\n\tivec2 camPosCoord       = controlSamplerRes - ivec2(3,1);\n\tivec2 camRotCoord       = controlSamplerRes - ivec2(4,1);\n\n\tvec3 frameControl = texelFetch(CONTROL_SAMPLER, frameControlCoord, 0).xyz;\n\tvec3 mouseControl = texelFetch(CONTROL_SAMPLER, mouseControlCoord, 0).xyz;\n\tvec3 camPos       = texelFetch(CONTROL_SAMPLER, camPosCoord, 0).xyz;\n\tvec3 camRot       = texelFetch(CONTROL_SAMPLER, camRotCoord, 0).xyz; // yaw,pitch,unused\n\tmat3 camBasis     = CreateCameraBasis(camRot);\n\t\n#if SCREEN_JITTER\n\tvec2 screenJitter = fract(iTime*vec2(23.75310853, 21.95340893)) - 0.5; // [-0.5..0.5], from https://www.shadertoy.com/view/MdKyRK\n#else\n    vec2 screenJitter = vec2(0);\n#endif\n\tvec2 sceneRes = iChannelResolution[2].xy; // resolution of this buffer\n\tvec2 screenPos = 2.0*(fragCoord + screenJitter)/sceneRes - 1.0; // [-1..1]\n    Ray cameraRay;\n\tcameraRay.origin = camPos + vec3(50.0, 40.8, 139.0);\n\tcameraRay.dir = camBasis*CreateScreenRay(screenPos, sceneRes.x/sceneRes.y);\n   \tvec3 color = vec3(0);\n\n#if LIGHTMAP\n    //if (IS_KEY_TOGGLED(KEY_0)) // TEST LIGHTMAP FINAL GATHER\n    //{\n    //    float t;\n    //    Object obj;\n    //    int objId = IntersectScene(cameraRay, -1, t, obj);\n    //    if (objId != -1) {\n    //        vec3 P = cameraRay.origin + t*cameraRay.dir;\n    //        vec3 N = GetSurfaceNormal(P, obj);\n    //        vec3 acc = vec3(0);\n    //        const int numFinalGatherRays = 16;\n    //        for (int i = 0; i < numFinalGatherRays; i++) {\n    //            Ray ray = Ray(P, SampleHemisphereCosineWeighted(N, rand2(seed)));\n    //            Object obj2;\n    //            int objId2 = IntersectScene(ray, objId, t, obj2);\n    //            if (objId2 != -1) {\n    //                if (obj2.lightmapBounds != vec4(0) && IsDiffuse(obj2)) {\n    //                    vec2 lightmapUV = ComputeLightmapUV(obj2, ray.origin + t*ray.dir - obj2.pos, LIGHTMAP_SAMPLER);\n    //                    if (lightmapUV.x != -1.0)\n    //                        acc += texture(LIGHTMAP_SAMPLER, lightmapUV).rgb*obj2.albedo;\n    //                }\n    //                //acc += obj2.emissive;\n    //            }\n    //        }\n    //        color = acc/float(numFinalGatherRays);\n    //    }\n    //}\n    //else // NOT FINAL GATHER\n#endif // LIGHTMAP\n    if (bool(DIFFUSE_ONLY))\n    {\n\t\tfloat t;\n        Object obj;\n        int objId = IntersectScene(cameraRay, -1, t, obj); // camera ray intersects scene only once\n        if (objId != -1) {\n\t\t\tvec2 offset = texelFetch(NOISE_SAMPLER, ivec2(fragCoord)&255, 0).xy;\n\t\t\tvec3 P = cameraRay.origin + t*cameraRay.dir;\n\t\t\tvec3 N = GetSurfaceNormal(P, obj);\n\t\t#if LIGHTMAP\n\t\t\tif (lightmapDepth == 0 && obj.lightmapBounds != vec4(0) && IsDiffuse(obj)) {\n\t\t\t\tvec2 lightmapUV = ComputeLightmapUV(obj, P - obj.pos, LIGHTMAP_SAMPLER);\n\t\t\t\tif (IS_KEY_TOGGLED(KEY_F)) {\n\t\t\t\t\tvec2 lightmapSize = vec2(textureSize(LIGHTMAP_SAMPLER, 0));\n\t\t\t\t\tlightmapUV = floor(lightmapUV*lightmapSize + vec2(0.5))/lightmapSize;\n\t\t\t\t}\n\t\t\t\tcolor = texture(LIGHTMAP_SAMPLER, lightmapUV).rgb;\n\t\t\t\tcolor *= obj.albedo;\n\t\t\t} else\n\t\t#endif // LIGHTMAP\n\t\t\tif (IS_KEY_TOGGLED(KEY_P)) { // for reference - analytic area light solution (direct light only, no shadows)\n\t\t\t\tvec3 e = vec3(0);\n\t\t\t\tfor (int lightId = 0; lightId < NO_UNROLL(NUM_OBJECTS); lightId++) {\n\t\t\t\t\tObject light = objects[lightId];\n\t\t\t\t\tif (IsLight(light))\n\t\t\t\t\t\te += light.emissive*LTC_EvaluateDiffuse(P, N, light);\n\t\t\t\t}\n\t\t\t\tcolor += e;\n\t\t\t\tcolor *= obj.albedo;\n\t\t\t} else {\n\t\t\t\tvec3 e = vec3(0);\n\t\t\t\tuint wasSampled = 0U;\n                if (directLightSampling && minDepth <= 1 && IsDiffuse(obj))\n\t\t\t\t\te = SampleLightsInScene(\n\t\t\t\t\t\tP,\n\t\t\t\t\t\tN,\n\t\t\t\t\t\thaltonEnabled,\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\tobjId,\n\t\t\t\t\t\tiFrame,\n\t\t\t\t\t\tNUM_DIRECT_LIGHT_SAMPLES,\n\t\t\t\t\t\twasSampled);\n\t\t\t\tfor (int i = 0; i < NO_UNROLL(NUM_PRIMARY_RAY_SAMPLES); i++) {\n\t\t\t\t\tvec3 rayDir;\n\t\t\t\t\tfloat mask = 1.0;\n\t\t\t\t\tif (IsDiffuse(obj)) {\n\t\t\t\t\t\tvec2 s = haltonEnabled ? fract(offset + Halton23(i + iFrame*NUM_PRIMARY_RAY_SAMPLES)) : rand2(seed);\n\t\t\t\t\t\tif (diffuseUniformSampling) {\n\t\t\t\t\t\t\trayDir = SampleHemisphereUniform(N, s);\n\t\t\t\t\t\t\tmask = dot(N, rayDir)*2.0; // why 2.0?\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\trayDir = SampleHemisphereCosineWeighted(N, s);\n\t\t\t\t\t}\n\t\t\t\t#if !DIFFUSE_ONLY\n\t\t\t\t\telse\n\t\t\t\t\t\trayDir = reflect(cameraRay.dir, N);\n\t\t\t\t#endif // !DIFFUSE_ONLY\n\t\t\t\t\tcolor += mask*ComputeRadiance(\n\t\t\t\t\t\tRay(P, rayDir),\n\t\t\t\t\t\tobjId,\n\t\t\t\t\t\t1, // depth\n\t\t\t\t\t\tminDepth,\n\t\t\t\t\t\tmaxDepth,\n\t\t\t\t\t\tdiffuseUniformSampling,\n\t\t\t\t\t#if LIGHTMAP\n\t\t\t\t\t\tlightmapDepth,\n\t\t\t\t\t\tLIGHTMAP_SAMPLER,\n\t\t\t\t\t#endif // LIGHTMAP\n\t\t\t\t\t\tdirectLightSampling,\n\t\t\t\t\t\twasSampled);\n\t\t\t\t}\n    \t\t\tcolor /= float(NUM_PRIMARY_RAY_SAMPLES);\n\t\t\t\tcolor += e;\n\t\t\t\tcolor *= obj.albedo;\n\t\t\t}\n\t\t\tif (minDepth == 0 && dot(N, cameraRay.dir) < 0.0)\n\t\t\t\tcolor += SampleLightColor(P, obj);\n        }\n    }\n    else\n    {\n\t\t// ==============================================================\n\t\t// less efficient codepath - keeping it around for comparison.\n\t\t// here we cast multiple rays from the camera in the *same*\n\t\t// direction, only diverging once we hit a surface and bounce.\n\t\t// the code above has been refactored so that it does one initial\n\t\t// scene trace from the camera and then multiple bounces on\n\t\t// the first hit.\n\t\t// ==============================================================\n        for (int i = 0; i < NUM_PRIMARY_RAY_SAMPLES; i++)\n            color += ComputeRadiance(\n                cameraRay,\n                OBJ_ID_NONE,\n                0, // depth\n\t\t\t\tminDepth,\n\t\t\t\tmaxDepth,\n\t\t\t\tdiffuseUniformSampling,\n            #if LIGHTMAP\n                lightmapDepth,\n                LIGHTMAP_SAMPLER,\n            #endif // LIGHTMAP\n                directLightSampling,\n                0U); // wasSampled\n        color /= float(NUM_PRIMARY_RAY_SAMPLES);\n    }\n    \n\tvec2 frame = max(vec2(0), vec2(iFrame) - frameControl.xy);\n    float f = frame.x;\n\tif (f > 0.0) {\n\t\tfloat accum = 1.0/(f + 1.0);\n\t\tif (f >= float(LAST_FRAME))\n\t\t\taccum = 0.0;\n\t\tcolor = color*accum + texelFetch(SCENE_SAMPLER, ivec2(fragCoord), 0).rgb*(1.0 - accum);\n\t}\n\tfragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//$INPUT0=KEYBOARD\n//$INPUT1=BUFFER_A\n//$INPUT2=BUFFER_B\n//$INPUT3=BUFFER_C\n//$OUTPUT=BUFFER_C\n//$OUTPUT_RES_X=-0.25\n//$OUTPUT_RES_Y=-0.25\n//$OUTPUT_FILTER=OFF\n\n// ===================================\n// Buffer C: computes running variance\n// ===================================\n\n// http://jonisalonen.com/2013/deriving-welfords-method-for-computing-variance/\n// variance(samples):\n//   M := 0\n//   S := 0\n//   for k from 1 to N:\n//     x := samples[k]\n//     oldM := M\n//     M := M + (x-M)/k\n//     S := S + (x-M)*(x-oldM)\n//   return S/(N-1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 state = vec3(0);\n\tif (IS_KEY_TOGGLED(KEY_Z)) {\n\t\tivec2 controlSamplerRes = textureSize(CONTROL_SAMPLER, 0);\n\t\tivec2 frameControlCoord = controlSamplerRes - ivec2(1,1);\n\t\tvec3 frameControl = texelFetch(CONTROL_SAMPLER, frameControlCoord, 0).xyz;\n\t\tvec2 frames = max(vec2(0), float(iFrame) - frameControl.xy);\n\t\tfloat frame;\n\t#if LIGHTMAP\n\t\tbool lightmapEnabled = IS_KEY_TOGGLED(KEY_L);\n\t\tif (lightmapEnabled)\n\t\t\tframe = frames.y;\n\t\telse\n\t#endif // LIGHTMAP\n\t\t\tframe = frames.x;\n\n\t\tif (frame > 0.0)\n\t\t\tstate = texelFetch(VARIANCE_SAMPLER, ivec2(fragCoord), 0).xyz;\n\t\tif (frame < float(LAST_FRAME)) {\n\t\t\tfloat M = state.x;\n\t\t\tfloat S = state.y;\n\t\t\tvec3 c;\n\t\t#if LIGHTMAP\n\t\t\tif (lightmapEnabled)\n\t\t\t\tc = texelFetch(LIGHTMAP_SAMPLER, ivec2(fragCoord), 0).rgb;\n\t\t\telse\n\t\t#endif // LIGHTMAP\n\t\t\t\tc = texelFetch(SCENE_SAMPLER, ivec2(fragCoord), 0).rgb;\n\t\t\tfloat x = dot(c, vec3(0.30,0.59,0.11));\n\t\t\tfloat oldM = M;\n\t\t\tM += (x - M)/(frame + 1.0);\n\t\t\tS += (x - M)*(x - oldM);\n\t\t\tfloat variance = S/max(1.0, frame);\n\t\t\tstate = vec3(M, S, variance);\n\t\t}\n\t}\n    fragColor = vec4(state, 0);\n}","name":"Buffer C","description":"","type":"buffer"}]}