{"ver":"0.1","info":{"id":"wljSzV","date":"1566492805","viewed":118,"name":"LiveSaveDirect","username":"foran","description":"LiveSaveDirect","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["livesavedirect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"  \n  #define PI 3.141592653589793\n  #define TAU 6.283185307179586\n  #define pow2(x) (x * x)\n  #define OCTAVES 8\n \n  const float bias = .092;//                  меньше пыли 0.2\n  const float scale = 10.;\n  const float power = 50.1;//                 четкость линий 10\n  \n  // blur constants\n  const float blurMultiplier = 0.95;\n  const float blurStrength = 4.98;//           blur 4.98\n  const int sampls = 6;//  8\n  const float sigma = float(sampls) * 0.25;//  четкость\n  \n\n  vec2 hash2(vec2 p)\n  {\n    vec2 o = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    return o;\n  }\n\n  float gaussian(vec2 i) {\n    return 1.0 / (2.0 * PI * pow2(sigma)) * exp(-((pow2(i.x) + pow2(i.y)) / (2.0 * pow2(sigma))));\n  }\n\n  vec3 hash33(vec3 p){ \n\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n  }\n\n  vec3 blur(sampler2D sp, vec2 uv, vec2 scale) {\n    vec3 col = vec3(0.0);\n    float accum = 0.0;\n    float weight;\n    vec2 offset;\n\n    for (int x = -sampls / 2; x < sampls / 2; ++x) {\n        for (int y = -sampls / 2; y < sampls / 2; ++y) {\n            offset = vec2(x, y);\n            weight = gaussian(offset);\n            col += texture(sp, uv + scale * offset).rgb * weight;\n            accum += weight;\n        }\n    }\n\n    return col / accum;\n  }\n  \n  vec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n  }\n  \n  vec3 domain(vec2 z){\n    return vec3(hsb2rgb(vec3(atan(z.y,z.x)/TAU,1.,1.)));\n  }\n  vec3 colour(vec2 z) {\n      return domain(z);\n  }\n  \n  const float delta = .005;\n  \n \n  //   Naive environment mapping. Pass the reflected vector and pull back the texture position for that ray.\n  vec3 envMap(vec3 rd, vec3 sn, float scale){\n\n    // rd.xy -= iTime*.2; // This just sort of compensates for the camera movement\n    // rd.xy -= movement;\n    rd *= 1.; // scale the whole thing down a but from the scaled UVs\n\n    vec3 col = texture(iChannel2, rd.xy - .5).rgb*2.;\n    col *= normalize(col);\n    // col *= vec3(1., 1., 1.2);\n    // col *= vec3(hash2(rd.xy).y * .5 + .5);\n\n    return col;\n\n  }\n  \n  float bumpMap(vec2 uv, float height, inout vec3 colourmap) {\n    \n    \n    vec3 shade;\n//---------------------\n    //vec2 aspect=vec2(iResolution.x/iResolution.y,.7);//      этот for little\n   // vec2 sampl=((gl_FragCoord.xy/iResolution.xy)/.7+.001)*aspect;\n    vec2 sampl = gl_FragCoord.xy / iResolution.xy;\n//----------------------\n    sampl += uv;\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    \n    shade = vec3(blur(iChannel1, sampl, ps*blurStrength));\n    // shade = texture(iChannel1, sampl).rgb;\n    // shade = vec3(shade.y * shade.y);\n    \n    return 1. - shade.x * height;\n  }\n  float bumpMap(vec2 uv, float height) {\n    vec3 colourmap;\n    return bumpMap(uv, height, colourmap);\n  }\n\n  vec4 renderPass(vec2 uv, inout float distortion) {\n    vec3 surfacePos = vec3(uv, 0.0);\n    vec3 ray = normalize(vec3(uv, 1.));\n    // vec3 lightPos = vec3(cos(iTime / 2.) * 2., sin(iTime / 2.) * 2., -3.);\n    vec3 lightPos = vec3(cos(iTime * .5 + 2.) * 2., 1. + sin(iTime * .5 + 2.) * 2., -3.);\n    vec3 normal = vec3(0., 0., -1);\n\n    vec2 samplDistance = vec2(.005, 0.);\n    \n    vec3 colourmap;\n    \n    float fx = bumpMap(samplDistance.xy, .2);\n    float fy = bumpMap(samplDistance.yx, .2);\n    float f = bumpMap(vec2(0.), .2, colourmap);\n    \n    distortion = f;\n    \n    fx = (fx-f)/samplDistance.x;\n    fy = (fy-f)/samplDistance.x;\n    normal = normalize( normal + vec3(fx, fy, 0) * 0.2 );\n    \n        // specular = max(0.0, min(1.0, bias + scale * (1.0 + length(camPos-sp * surfNormal)) * power));\n    float shade = bias + (scale * pow(1.0 + dot(normalize(surfacePos-vec3(uv, -3.0)), normal), power));\n\n    vec3 lightV = lightPos - surfacePos;\n    float lightDist = max(length(lightV), 0.001);\n    lightV /= lightDist;\n\n    vec3 lightColour = vec3(.8, .8, 1.);\n\n    float shininess = .8;\n    float brightness = 1.;\n\n    float falloff = 0.1;\n    float attenuation = 1./(1.0 + lightDist*lightDist*falloff);\n\n    float diffuse = max(dot(normal, lightV), 0.);\n    float specular = pow(max(dot( reflect(-lightV, normal), -ray), 0.), 52.) * shininess;\n    \n    // vec3 tex = texture2D(iChannel2, (reflect(vec3(uv, -1.), normal)).xy ).rgb;\n    vec3 reflect_ray = reflect(vec3(uv, 1.), normal * 1.);\n    // The reflect ray is the ray wwe use to determine the reflection.\n    // We use the UV less the movement (to account for \"environment\") to the surface normal\n    vec3 tex = envMap(reflect_ray, normal, 1.5) * (shade + .5); // Fake environment mapping.\n\n    vec3 texCol = (vec3(.4, .6, .9) + tex * brightness) * .5;\n    \n    float metalness = (1. - colourmap.x);\n    metalness *= metalness;\n\n    vec3 colour = (texCol * (diffuse*vec3(1, .97, .92)*2. + 0.5) + lightColour*specular * f * 2. * metalness)*attenuation*1.5;\n    // colour *= 1.5;\n\n    // return vec4(shade);\n    return vec4(colour, 1.);\n  }\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n  {\n    \n      vec4 fragcolour = vec4(0);\n   \n      vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n      vec2 sampl = fragCoord.xy / iResolution.xy;\n\n       uv.x += sin(iTime*.5);\n       sampl.x += sin(iTime*.05);\n      \n      float distortion;\n      vec4 reflections = renderPass(uv, distortion);\n\n     const float aMult = 12.293;//   волны 2.293 фон\n     const float bMult = 14.15;//    распыляет 4.15 фон\n     const float cMult = 3.2;//      стекло сглаживает 2.2 фон\n       \n     uv *= 8. + (distortion);\n     uv.x += iTime;\n     uv.y += sin(iTime);\n     uv += distortion*40.;\n     \n     float a=1.0;\n     float b=1.0;\n     float c=1.0;\n     float d=0.0;\n     for(int s=0;s<OCTAVES;s++) {\n      vec2 r;\n      r=vec2(cos(uv.y*a-d+iTime/b),sin(uv.x*a-d+iTime/b))/c;\n          r+=vec2(-r.y,r.x)*0.3;\n      uv.xy+=r;\n\n      a *= aMult;\n      b *= bMult;\n      c *= cMult;\n      d += 0.05+0.1*iTime*b;\n    }\n      fragcolour = vec4(\n      sin(uv.x)*0.5+0.5,\n      sin((uv.x+uv.y+sin(iTime*0.5))*0.5)*0.3+0.3,\n      sin(uv.y+iTime)*0.3+0.3,\n      1.0);\n      \n      \n       fragcolour += (texture(iChannel1, sampl+.03).x)*.1 - .1;//         контраст\n      fragcolour += reflections*reflections*.5;\n      // fragcolour = texture2D(iChannel1, sampl + fragcolour.rg * .005);//  уезжает\n       //fragcolour = vec4(fragcolour.x * fragcolour.x);//                   черно-белое_!\n   \n      fragColor = fragcolour ;\n  }","name":"Image","description":"","type":"image"}]}