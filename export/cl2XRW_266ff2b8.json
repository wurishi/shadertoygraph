{"ver":"0.1","info":{"id":"cl2XRW","date":"1708946043","viewed":67,"name":"SDF Propagation","username":"yetsun","description":"Signed Distance field generated by repeatedly applying eikonal equation on a grid.\n\nMore robust than https://www.shadertoy.com/view/ltGGRw","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sdf","eikonal"],"hasliked":0,"parentid":"ltGGRw","parentname":"Eikonal equation signed"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Enable to show error x100\n//#define VISUALIZE_ERROR\n//#define SHOW_ONLY_ERROR\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float val = texture(iChannel0, uv).r * 0.003;\n    float analytic = texture(iChannel0, uv).a * 0.003;\n    \n    // Colorization\n    vec3 outColor = vec3(val, val, val);\n\n#ifdef VISUALIZE_ERROR\n\t// Green-blue colorization    \n    if (val < 0.0) outColor = vec3(0.0, 1.0 + val * 4.0, 1.0 + val * 4.0);\n    else if (val < 0.5) outColor = vec3(0.0, val * 2.0, 0.0);\n    else if (val < 1.0) outColor = vec3(0.0, 0.0, (val - 0.5) * 2.0);\n    else outColor = vec3(0.0, (val - 1.0) * 2.0, (val - 1.0) * 2.0);\n    \n    // Red channel = error compared to analytical solution\n    outColor.r = abs(val - analytic) * 100.0;\n#else\n    // Full RGB colorization / no error visualization\n    if (val < 0.0) outColor = vec3(1.0 + val * 4.0, 1.0 + val * 4.0, 1.0 + val * 4.0);\n    else if (val < 0.25) outColor = vec3(val * 4.0, 0.0, 0.0);\n    else if (val < 0.5) outColor = vec3(0.0, (val - 0.25) * 4.0, 0.0);\n    else if (val < 0.75) outColor = vec3(0.0, 0.0, (val - 0.5) * 4.0);\n    else if (val < 1.0) outColor = vec3((val - 0.75) * 4.0, (val - 0.75) * 4.0, 0.0);\n    else outColor = vec3((val - 1.0) * 2.0, (val - 1.0) * 2.0, (val - 1.0) * 2.0);\n#endif\n    \n#ifdef SHOW_ONLY_ERROR\n    outColor.rgb *= vec3(1.0, 0.0, 0.0);\n#endif\n        \n    fragColor.rgb = outColor;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Split distance value to positive and negative, and apply eikonal equation on them independently.\n\n//#define START_FROM_ANALYTICAL_RESULT\n\nconst float narrowBand = 1.5;\t\t\t\t// sqrt(2) round up\nconst float maxValue = 1024.0 * 16.0;\n\nconst vec2 point0 = vec2(300.5, 30.5);\t\t// pixel center\nconst vec2 point1 = vec2(110.7, 430.2);\nconst vec2 point2 = vec2(200.3, 349.6);\nconst vec2 point3 = vec2(30.0, 123.0);\t\t// between pixels\n\nconst vec2 circle = vec2(732.4, 534.1);\nconst float circleRad = 129.3;\n\nconst vec2 rectPos = vec2(500.34, 500.34);\nconst vec2 rectExt = vec2(100, 100);\n\nfloat distFunc(vec2 p)\n{\n    float d = distance(point0, p);\n    d = min(d, distance(point1, p));\n    d = min(d, distance(point2, p));\n    d = min(d, distance(point3, p));\n    \n    vec2 q = abs(rectPos - p) - rectExt;\n    d = min(d, length(max(q, 0.0)) + min(max(q.x, q.y), 0.0));\n    \n    return d;\n}\n\n// https://en.wikipedia.org/wiki/Eikonal_equation\nfloat eikonal1d(float h, float v, float g)\n{\n    float hv = min(h, v);\n\treturn hv + g;\n}\n\nfloat eikonal2d(float h, float v, float g)\n{\n    float hv = h + v;\n    float d = hv*hv - 2.0 * (h*h + v*v - g*g);\n    if (d < g*g)\n        return eikonal1d(h, v, g);\n    else\n        return 0.5 * (hv + sqrt(d));\n}\n\nfloat neighborMin(vec2 coord, vec2 delta, float cur_sign)\n{\n    float a = texture(iChannel0, coord + delta).r;\n    a = a * cur_sign > 0.0 ? abs(a) : 0.0;\n    \n    float b = texture(iChannel0, coord - delta).r;\n    b = b * cur_sign > 0.0 ? abs(b) : 0.0;\n    \n    return min(a, b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int frame = iFrame;\n    vec2 pixel = fragCoord;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float distAnalytical = distFunc(pixel);\n    \n    float dist = 0.0;\n    if (frame == 0)\n    {\n        dist = distAnalytical;\n        \n        // Clamp non-seed values to max\n#ifndef START_FROM_ANALYTICAL_RESULT\n        if (abs(dist) > narrowBand) dist = dist > 0.0 ? maxValue : -maxValue;\n#endif\n    }\n    else\n    {    \n        float xd = 1.0 / iResolution.x;\n        float yd = 1.0 / iResolution.y;\n        \n        float cur = texture(iChannel0, uv).r;\n        float cur_sign = cur > 0.0 ? 1.0 : -1.0;\n\n        float h = neighborMin(uv, vec2(xd, 0.0), cur_sign);\n        float v = neighborMin(uv, vec2(0.0, yd), cur_sign);\n        \n        dist = min(abs(cur), eikonal2d(h, v, 1.0)) * cur_sign;\n    }\n    \n    fragColor = vec4(dist, dist, dist, distAnalytical);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}