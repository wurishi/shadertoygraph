{"ver":"0.1","info":{"id":"3sKSRw","date":"1573652605","viewed":1360,"name":"Tunnel of Disco lights","username":"bitless","description":"Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration","likes":44,"published":1,"flags":0,"usePreview":0,"tags":["2d","tunnel","atan","disco"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: Tunnel of Disco lights\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration \n\n#define SCALE_X 16.\n#define SCALE_Y 5.\n#define TIME_SCALE 0.1\n#define BORDER 1.2\n\nfloat hash1( float n ) { return fract(sin(n)*437518.56453)+0.1; }\n\nfloat box(vec2 st) {\n    vec2 s = vec2(0.001); // border size\n    vec2 w = vec2(0.05); // border smoothness\n    vec2 uv = smoothstep(s,s+w,st);\n    uv *= smoothstep(s,s+w,vec2(1.0)-st);\n    return uv.x*uv.y*(1.-length(0.5-st)*0.75);\n}\n\n// translate color from HSB space to RGB space\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nfloat fbm (in vec2 st) {\n\tfloat value = (sin(iTime*5.*hash1(st.x+hash1(st.y)))+4.0)*0.25;\n    return max(0.75,pow(value,3.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\t\n\tfloat a = atan(uv.x, uv.y);\n\tfloat r = length(uv);\n\t\n\tuv = vec2(a,r/dot(uv,uv));\n\n    vec3 color = vec3(0.);\n    float c = 1.;\n\n    float lt = mod(iTime*TIME_SCALE,1./SCALE_Y); //local time cycle\n    \n    \n    uv.x *= SCALE_X/3.1415926;\n    float i = floor(uv.x); // row\n    uv.x = fract(uv.x);\n\n    if (uv.y < BORDER-lt)\n    {\n        uv.y += iTime*TIME_SCALE;\n        uv.y *= SCALE_Y;\n        float j = floor(uv.y);\n\n        uv.y = fract(uv.y);\n        color = hsb2rgb(vec3((hash1(j+hash1(i))),0.7,fbm(vec2(i,j))))*box(uv);\n    }\n    else {\n        float fade = smoothstep (3.0,0.,sqrt(uv.y)); //fade to darkness\n        uv.y += lt - BORDER;\n        float j = floor ((BORDER-lt+iTime*TIME_SCALE)*SCALE_Y+floor(uv.y)); \n\t\tuv.y = fract(uv.y)*SCALE_Y + min(0., 1.-SCALE_Y+lt*(SCALE_Y/TIME_SCALE*SCALE_Y*hash1(i+hash1(j))+1.));\n    \tc *=  box (uv); //cell\n        c += smoothstep(3.0,1.0,sqrt(uv.y))*smoothstep(1.0,1.05,uv.y)*smoothstep(0.5,0.45,abs(uv.x-0.5))*0.25; //cell trail\n        c *= fade; //fade to darkness\n        color = mix (color,hsb2rgb(vec3((hash1(j+hash1(i))),0.7,fbm(vec2(i,j)))),c);\n\n    }\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}