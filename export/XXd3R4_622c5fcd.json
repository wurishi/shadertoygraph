{"ver":"0.1","info":{"id":"XXd3R4","date":"1716172729","viewed":72,"name":"RCU","username":"Cuprum","description":"Circle","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Random function to generate random RGB values\nvec3 rand(float seed) \n{\n    return vec3(\n        fract(sin(seed) * 43758.5453),\n        fract(sin(seed + 1.0) * 43758.5453),\n        fract(sin(seed + 2.0) * 43758.5453)\n    );\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) \n{\n    const float inner_radius = 0.3;\n    const float outer_radius = 1.0;\n    const int num_segments = 36;\n    const int num_rings = 6;\n    const float ring_border = 0.02;\n    const float segment_gap = 0.04;\n    const float offset = 0.02;\n\n    // Normalize coordinates to range [-1, 1]\n    vec2 uv = (frag_coord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Add an offset to the y coordinate based on whether the fragment is in the top or bottom half of the circle\n    if (uv.y > 0.0)\n        uv.y -= (offset / 2.0);\n    else\n        uv.y += (offset / 2.0);\n\n    // Calculate angle and radius\n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv) + (offset * 2.0);\n\n    // Normalize the angle to range [0, 2*PI]\n    if (angle < 0.0)\n        angle += 2.0 * 3.14159265359;\n\n    // Calculate the width of each ring\n    float ring_width = (outer_radius - inner_radius) / float(num_rings);\n\n    // Calculate the angle per segment\n    float segment_angle = 2.0 * 3.14159265359 / float(num_segments);\n\n    // Calculate the angular gap between segments\n    float gap_angle = segment_gap / 2.0; // Convert to radians\n\n    // Determine which ring the current fragment belongs to\n    int ring_index = int((radius - inner_radius) / ring_width);\n\n    // Calculate the distance to the border of the current ring\n    float distance_to_border = mod(radius - inner_radius, ring_width);\n\n    // Calculate the segment index\n    int segment_index = int((angle / (2.0 * 3.14159265359)) * float(num_segments));\n\n    // Calculate the start and end angles of the current segment, accounting for the gap\n    float segment_start_angle = float(segment_index) * segment_angle + gap_angle / 2.0;\n    float segment_end_angle = float(segment_index + 1) * segment_angle - gap_angle / 2.0;\n\n    // Calculate the center angle of the current segment\n    float segment_center_angle = (segment_start_angle + segment_end_angle) / 2.0;\n\n    // Check if the current fragment is within a gap from the center of the segment\n    bool in_gap;\n    if (segment_start_angle < segment_end_angle)\n        in_gap = angle < segment_start_angle || angle > segment_end_angle;\n    else // This handles the case where the segment crosses the X axis\n        in_gap = angle < segment_start_angle && angle > segment_end_angle;\n\n    // Choose a color based on the segment and ring indices\n    vec3 color;\n    if (!in_gap) \n    {\n        // Set a random color to each part \n        color = rand(float(segment_index) + float(ring_index) * 100.0);\n    } \n    else \n    {\n        color = vec3(0.0); // Black for gaps\n    }\n\n    // Circle boundary and ring border check\n    if (radius > outer_radius || radius < inner_radius || distance_to_border < ring_border) \n        frag_color = vec4(0.0, 0.0, 0.0, 1.0); // Outside the circle or inside the hollow center or on the ring border\n    // Else if its between the two halves of the circle\n    else if (uv.y > -offset && uv.y < offset) \n        frag_color = vec4(0.0, 0.0, 0.0, 1.0); // Between the two halves of the circle\n    else \n        frag_color = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}