{"ver":"0.1","info":{"id":"ftVSR1","date":"1640355770","viewed":262,"name":"My Keyboard","username":"Sobaya","description":"my new gear...","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rot(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    mat2 r = mat2(c, s, -s, c);\n    return r * p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    const int N = 10;\n    float weight = 0.;\n    for (int i = -N; i <= +N; i++) {\n        for (int j = -N; j <= +N; j++) {\n            vec2 offset = vec2(i,j);\n            vec2 uv = rot(offset / float(N), .5);\n            const float a = 1. / 3.;\n            float w = 1. / (1. + pow(pow(abs(uv.x), a) + pow(abs(uv.y), a), 1. / a) * 200.);\n            color += texture(iChannel0, (fragCoord + offset) / iResolution.xy).rgb * w;\n            weight += w;\n        }\n    }\n    fragColor = vec4(color / weight, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec4 init(vec2 fragCoord) {\n    ivec2 c = ivec2(fragCoord);\n    if (c == EYE_COORD) {\n        return vec4(0,0,20,0);\n    }\n    if (c == UP_COORD) {\n        return vec4(0,1,0,0);\n    }\n    if (c == MOUSE_COORD) {\n        return vec4(0);\n    }\n    return vec4(0);\n}\n\nvec3 rot(vec3 p) {\n    vec3 eye = texelFetch(iChannel0, EYE_COORD, 0).xyz;\n    vec3 up = texelFetch(iChannel0, UP_COORD, 0).xyz;\n    bool isPressing = texelFetch(iChannel0, MOUSE_COORD, 0).b > 0.;\n    vec2 beforeMousePos = texelFetch(iChannel0, MOUSE_COORD, 0).rg;\n    vec2 currentMousePos = iMouse.xy;\n\n    if (isPressing) {\n        const float speed = 0.01;\n        vec2 d = currentMousePos - beforeMousePos;\n        vec3 baseZ = normalize(eye);\n        vec3 baseX = normalize(cross(up, baseZ));\n        vec3 baseY = normalize(cross(baseZ, baseX));\n\n        Quaternion dx = axisAngleQ(baseY, d.x * speed);\n        Quaternion dy = axisAngleQ(baseX, -d.y * speed);\n        p = rotQ(dx, p);\n        p = rotQ(dy, p);\n    }\n    \n    return p;\n}\n\nvec3 zoom(vec3 p) {\n    bool isPressing = texelFetch(iChannel0, MOUSE_COORD, 0).b > 0.;\n    vec2 beforeMousePos = texelFetch(iChannel0, MOUSE_COORD, 0).rg;\n    vec2 currentMousePos = iMouse.xy;\n\n    if (isPressing) {\n        const float speed = .04;\n        vec2 d = currentMousePos - beforeMousePos;\n        float l = length(p);\n        l = clamp(l * (1. - sign(d.y) * speed), 1., 30.);\n        p = normalize(p) * l;\n    }\n    \n    return p;\n}\n\nvec4 update(vec2 fragCoord) {\n    ivec2 c = ivec2(fragCoord);\n    bool isCtrlPressing = texelFetch(iChannel1, ivec2(17, 0), 0).r > 0.;\n    \n    if (isCtrlPressing) {\n        if (c == EYE_COORD) {\n            vec3 eye = texelFetch(iChannel0, EYE_COORD, 0).xyz;\n            return vec4(zoom(eye),0);\n        }\n        if (c == UP_COORD) {\n            vec3 up = texelFetch(iChannel0, UP_COORD, 0).xyz;\n            return vec4(up,0);\n        }\n    } else {\n        if (c == EYE_COORD) {\n            vec3 eye = texelFetch(iChannel0, EYE_COORD, 0).xyz;\n            return vec4(rot(eye),0);\n        }\n        if (c == UP_COORD) {\n            vec3 up = texelFetch(iChannel0, UP_COORD, 0).xyz;\n            return vec4(rot(up),0);\n        }\n    }\n    if (c == MOUSE_COORD) {\n        if (iMouse.z > 0.) {\n            // being pressed\n            return vec4(iMouse.xy, 1, 0);\n        } else {\n            return vec4(0);\n        }\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 1) {\n        fragColor = init(fragCoord);\n    } else {\n        fragColor = update(fragCoord);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Quaternion {\n    vec4 q;\n};\n\nQuaternion mulQ(Quaternion a, Quaternion b) {\n    return Quaternion(vec4(\n        a.q.w * b.q.xyz + b.q.w * a.q.xyz + cross(a.q.xyz, b.q.xyz),\n        a.q.w * b.q.w - dot(a.q.xyz, b.q.xyz)\n    ));\n}\n\nQuaternion conjugateQ(Quaternion q) {\n    return Quaternion(vec4(-q.q.xyz, q.q.w));\n}\n\nvec3 rotQ(Quaternion q, vec3 v) {\n    return mulQ(\n        mulQ(\n            conjugateQ(q),\n            Quaternion(vec4(v,0))\n        ),\n        q\n    ).q.xyz;\n}\n\nQuaternion axisAngleQ(vec3 axis, float angle) {\n    float s = sin(angle * .5);\n    float c = cos(angle * .5);\n    return Quaternion(vec4(axis * s, c));\n}\n\nconst ivec2 EYE_COORD = ivec2(0);\nconst ivec2 UP_COORD = ivec2(1,0);\nconst ivec2 MOUSE_COORD = ivec2(2,0);\n\n#define PI 3.1415926535","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int BOARD = 0;\nconst int KEY = 1;\nconst int ENTER_KEY = 2;\n\nconst int KEY_ESC    =  0;\nconst int KEY_F1     =  1;\nconst int KEY_F2     =  2;\nconst int KEY_F3     =  3;\nconst int KEY_F4     =  4;\nconst int KEY_F5     =  5;\nconst int KEY_F6     =  6;\nconst int KEY_F7     =  7;\nconst int KEY_F8     =  8;\nconst int KEY_F9     =  9;\nconst int KEY_F10    = 10;\nconst int KEY_F11    = 11;\nconst int KEY_F12    = 12;\nconst int KEY_PAUSE  = 13;\nconst int KEY_SCROLL = 14;\nconst int KEY_PRINT  = 15;\nconst int KEY_HZ     = 16;\nconst int KEY_1      = 17;\nconst int KEY_2      = 18;\nconst int KEY_3      = 19;\nconst int KEY_4      = 20;\nconst int KEY_5      = 21;\nconst int KEY_6      = 22;\nconst int KEY_7      = 23;\nconst int KEY_8      = 24;\nconst int KEY_9      = 25;\nconst int KEY_0      = 26;\nconst int KEY_MINUS  = 27;\nconst int KEY_HAT    = 28;\nconst int KEY_YEN    = 29;\nconst int KEY_BSPACE = 30;\nconst int KEY_INSERT = 31;\nconst int KEY_HOME   = 32;\nconst int KEY_PAGEUP = 33;\nconst int KEY_TAB    = 34;\nconst int KEY_Q      = 35;\nconst int KEY_W      = 36;\nconst int KEY_E      = 37;\nconst int KEY_R      = 38;\nconst int KEY_T      = 39;\nconst int KEY_Y      = 40;\nconst int KEY_U      = 41;\nconst int KEY_I      = 42;\nconst int KEY_O      = 43;\nconst int KEY_P      = 44;\nconst int KEY_AT     = 45;\nconst int KEY_LBRAC  = 46;\nconst int KEY_DELETE = 48;\nconst int KEY_END    = 49;\nconst int KEY_PAGEDN = 50;\nconst int KEY_CAPS   = 51;\nconst int KEY_A      = 52;\nconst int KEY_S      = 53;\nconst int KEY_D      = 54;\nconst int KEY_F      = 55;\nconst int KEY_G      = 56;\nconst int KEY_H      = 57;\nconst int KEY_J      = 58;\nconst int KEY_K      = 59;\nconst int KEY_L      = 60;\nconst int KEY_SEMI   = 61;\nconst int KEY_COLON  = 62;\nconst int KEY_RBRAC  = 63;\nconst int KEY_LSHIFT = 64;\nconst int KEY_Z      = 65;\nconst int KEY_X      = 66;\nconst int KEY_C      = 67;\nconst int KEY_V      = 68;\nconst int KEY_B      = 69;\nconst int KEY_N      = 70;\nconst int KEY_M      = 71;\nconst int KEY_COMMA  = 72;\nconst int KEY_DOT    = 73;\nconst int KEY_SLASH  = 74;\nconst int KEY_BSLASH = 75;\nconst int KEY_RSHIFT = 76;\nconst int KEY_LCTRL  = 77;\nconst int KEY_SUPER  = 78;\nconst int KEY_ALT    = 79;\nconst int KEY_MHEN   = 80;\nconst int KEY_SPACE  = 81;\nconst int KEY_HEN    = 82;\nconst int KEY_KANA   = 83;\nconst int KEY_FN     = 84;\nconst int KEY_WTF    = 85;\nconst int KEY_RCTRL  = 86;\nconst int KEY_UP     = 87;\nconst int KEY_LEFT   = 88;\nconst int KEY_DOWN   = 89;\nconst int KEY_RIGHT  = 90;\nconst int KEY_EXC    = 91;\nconst int KEY_DQ     = 92;\nconst int KEY_SHARP  = 93;\nconst int KEY_DOLLER = 94;\nconst int KEY_PERC   = 95;\nconst int KEY_AND    = 96;\nconst int KEY_SQ     = 97;\nconst int KEY_LPAREN = 98;\nconst int KEY_RPAREN = 99;\nconst int KEY_EQ     = 100;\nconst int KEY_TILDA  = 101;\nconst int KEY_BAR    = 102;\nconst int KEY_BQ     = 103;\nconst int KEY_LBRCK  = 104;\nconst int KEY_PLUS   = 105;\nconst int KEY_STAR   = 106;\nconst int KEY_RBRCK  = 107;\nconst int KEY_LT     = 108;\nconst int KEY_GT     = 109;\nconst int KEY_QUEST  = 110;\nconst int KEY_US     = 111;\n\nconst vec2 COORD_LEFT   = vec2( 0, 14);\nconst vec2 COORD_UP     = vec2( 1, 14);\nconst vec2 COORD_RIGHT  = vec2( 2, 14);\nconst vec2 COORD_DOWN   = vec2( 3, 14);\nconst vec2 COORD_SPACE  = vec2( 0, 13);\nconst vec2 COORD_EXC    = vec2( 1, 13);\nconst vec2 COORD_DQ     = vec2( 2, 13);\nconst vec2 COORD_SHARP  = vec2( 3, 13);\nconst vec2 COORD_DOLLER = vec2( 4, 13);\nconst vec2 COORD_PERC   = vec2( 5, 13);\nconst vec2 COORD_AND    = vec2( 6, 13);\nconst vec2 COORD_SQ     = vec2( 7, 13);\nconst vec2 COORD_LPAREN = vec2( 8, 13);\nconst vec2 COORD_RPAREN = vec2( 9, 13);\nconst vec2 COORD_STAR   = vec2(10, 13);\nconst vec2 COORD_PLUS   = vec2(11, 13);\nconst vec2 COORD_COMMA  = vec2(12, 13);\nconst vec2 COORD_MINUS  = vec2(13, 13);\nconst vec2 COORD_DOT    = vec2(14, 13);\nconst vec2 COORD_SLASH  = vec2(15, 13);\nconst vec2 COORD_0 = vec2( 0, 12);\nconst vec2 COORD_1 = vec2( 1, 12);\nconst vec2 COORD_2 = vec2( 2, 12);\nconst vec2 COORD_3 = vec2( 3, 12);\nconst vec2 COORD_4 = vec2( 4, 12);\nconst vec2 COORD_5 = vec2( 5, 12);\nconst vec2 COORD_6 = vec2( 6, 12);\nconst vec2 COORD_7 = vec2( 7, 12);\nconst vec2 COORD_8 = vec2( 8, 12);\nconst vec2 COORD_9 = vec2( 9, 12);\nconst vec2 COORD_COLON = vec2(10, 12);\nconst vec2 COORD_SEMI  = vec2(11, 12);\nconst vec2 COORD_LT    = vec2(12, 12);\nconst vec2 COORD_EQ    = vec2(13, 12);\nconst vec2 COORD_GT    = vec2(14, 12);\nconst vec2 COORD_QUEST = vec2(15, 12);\nconst vec2 COORD_AT = vec2( 0, 11);\nconst vec2 COORD_A = vec2( 1, 11);\nconst vec2 COORD_B = vec2( 2, 11);\nconst vec2 COORD_C = vec2( 3, 11);\nconst vec2 COORD_D = vec2( 4, 11);\nconst vec2 COORD_E = vec2( 5, 11);\nconst vec2 COORD_F = vec2( 6, 11);\nconst vec2 COORD_G = vec2( 7, 11);\nconst vec2 COORD_H = vec2( 8, 11);\nconst vec2 COORD_I = vec2( 9, 11);\nconst vec2 COORD_J = vec2(10, 11);\nconst vec2 COORD_K = vec2(11, 11);\nconst vec2 COORD_L = vec2(12, 11);\nconst vec2 COORD_M = vec2(13, 11);\nconst vec2 COORD_N = vec2(14, 11);\nconst vec2 COORD_O = vec2(15, 11);\nconst vec2 COORD_P = vec2( 0, 10);\nconst vec2 COORD_Q = vec2( 1, 10);\nconst vec2 COORD_R = vec2( 2, 10);\nconst vec2 COORD_S = vec2( 3, 10);\nconst vec2 COORD_T = vec2( 4, 10);\nconst vec2 COORD_U = vec2( 5, 10);\nconst vec2 COORD_V = vec2( 6, 10);\nconst vec2 COORD_W = vec2( 7, 10);\nconst vec2 COORD_X = vec2( 8, 10);\nconst vec2 COORD_Y = vec2( 9, 10);\nconst vec2 COORD_Z = vec2(10, 10);\nconst vec2 COORD_LBRCK  = vec2(11, 10);\nconst vec2 COORD_BSLASH = vec2(12, 10);\nconst vec2 COORD_RBRCK  = vec2(13, 10);\nconst vec2 COORD_HAT    = vec2(14, 10);\nconst vec2 COORD_US     = vec2(15, 10);\nconst vec2 COORD_BQ     = vec2( 0,  9);\nconst vec2 COORD_LBRAC  = vec2(11,  8);\nconst vec2 COORD_BAR    = vec2(12,  8);\nconst vec2 COORD_RBRAC  = vec2(13,  8);\nconst vec2 COORD_TILDA  = vec2(14,  8);\nconst vec2 COORD_YEN    = vec2( 5,  5);\n\nstruct Ray {\n    vec3 start;\n    vec3 dir;\n    vec3 up;\n};\n\nstruct PerspectiveCamera {\n    vec3 pos;\n    vec3 dir;\n    vec3 up;\n    float fov;\n};\n\nstruct OrthoCamera {\n    vec3 pos;\n    vec3 dir;\n    vec3 up;\n    float size;\n};\n\nstruct Model {\n    float dist;\n    vec3 center;\n    int type;\n    int code;\n};\n\nstruct MarchResult {\n    bool hit;\n    vec3 pos;\n    Model model;\n};\n\nstruct Codes {\n    int[8] codes;\n    int n;\n};\n\nCodes initCodes() {\n    Codes codes;\n    for (int i = 0; i < 8; i++) {\n        codes.codes[i] = 0;\n    }\n    codes.n = 0;\n    return codes;\n}\n\nfloat box(vec3 p, vec3 b) {\n     vec3 q = abs(p) - b;\n     return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nModel board(vec3 p, vec3 t) {\n    return Model(\n        box(p - t + vec3(-1.0, 0.0, 1.5), vec3(13.5, 0.5, 5.5)) - 0.1,\n        t,\n        BOARD,\n        -1\n    );\n}\n\nModel key(vec3 p, vec3 t, vec2 l, float bend, int type, int code) {\n    const float b = .5;\n    const float r = .1;\n    const float a = 5.;\n    \n    p -= t;\n    \n    float x = dot(vec3(abs(p.x),p.yz) - vec3(b * l.x,0,0), normalize(vec3(a,1,0)));\n    float z = dot(vec3(p.xy,abs(p.z)) - vec3(0,0,b * l.y), normalize(vec3(0,1,a)));\n    float y = abs(p.y - pow(length(p.xz), 2.) * bend) - b;\n    \n    vec3 q = vec3(x,y,z);\n    return Model(\n        length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r,\n        t,\n        type,\n        code\n    );\n}\n\nModel baseKey(vec3 p, vec3 t, float l, int type, int code) {\n    return key(p, t, vec2(l, 1), 0.1, type, code);\n}\n\nModel keys(vec3 p, vec3 t, int type, int code, int n) {\n    float low = -ceil(float(n) * .5 - .5) - .5;\n    float high = floor(float(n) * .5 - .5) + .5;\n    const float interval = 1.4;\n    p -= t;\n    float newX = interval * (mod(clamp(p.x / interval, low, high) + .5, 1.) - .5);\n    float diffX = newX - p.x;\n    p.x += diffX;\n    \n    Model m = baseKey(p, vec3(0), 1., type, code);\n    m.center = t - vec3(diffX, 0, 0);\n    m.code += int(round(-diffX / interval) + floor(float(n) * .5));\n    return m;\n}\n\nModel unite(Model a, Model b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nModel model(vec3 p) {\n    Model r = Model(114514., vec3(0), -1, -1);\n    \n\n    r = unite(r, baseKey(p, -vec3(1.4 * 8.0, 0.0, 4.5), 1.0, KEY, KEY_ESC)); // ESC\n    r = unite(r, keys(p, -vec3( 1.4 * 4.5, 0.0, 4.5), KEY, KEY_F1, 4)); // F1-F4\n    r = unite(r, keys(p, -vec3(-1.4 * 0.25, 0.0, 4.5), KEY, KEY_F5, 4)); // F5-F8\n    r = unite(r, keys(p, -vec3(-1.4 * 5.0, 0.0, 4.5), KEY, KEY_F9, 4)); // F9-F12\n    r = unite(r, keys(p, -vec3(-1.4 * 8.5, 0.0, 4.5), KEY, KEY_PAUSE, 3)); // PAUSE-PRINTSCREEN\n    \n    r = unite(r, keys(p, -vec3(1.4, 0.0, 2.8), KEY, KEY_HZ, 15)); // hankaku/zenkaku - BS\n    r = unite(r, keys(p, -vec3(-1.4 * 8.5, 0.0, 2.8), KEY, KEY_INSERT, 3)); // INSERT-PAGEUP\n    \n    r = unite(r, baseKey(p, -vec3(1.4 * 7.75, 0.0, 1.4), 1.6, KEY, KEY_TAB)); // TAB\n    r = unite(r, keys(p, -vec3(0.7, 0.0, 1.4), KEY, KEY_Q, 12)); // Q-[\n    r = unite(r, keys(p, -vec3(-1.4 * 8.5, 0.0, 1.4), KEY, KEY_DELETE, 3)); // DELETE-PAGEDOWN\n    \n    r = unite(r, baseKey(p, -vec3(1.4 * 7.5, 0.0, 0.0), 2.3, KEY, KEY_CAPS)); // CAPS LOCK\n    r = unite(r, keys(p, vec3(0), KEY, KEY_A, 12)); // A-]\n    \n    r = unite(r, baseKey(p, -vec3(1.4 * 7.25, 0.0, -1.4), 3.0, KEY, KEY_LSHIFT)); // LSHIFT\n    r = unite(r, keys(p, -vec3(0.7, 0.0, -1.4), KEY, KEY_Z, 11)); // Z-\\ \n    r = unite(r, baseKey(p, -vec3(-1.4 * 5.75, 0.0, -1.4), 1.6, KEY, KEY_RSHIFT)); // RSHIFT\n    r = unite(r, keys(p, -vec3(-1.4 * 8.5, 0.0, -1.4), KEY, KEY_UP, 1)); // UP\n    \n    r = unite(r, baseKey(p, -vec3( 1.4 * 7.9, 0.0, -2.8), 1.2, KEY, KEY_LCTRL)); // LCTRL\n    r = unite(r, baseKey(p, -vec3( 1.4 * 6.75, 0.0, -2.8), 1.1, KEY, KEY_SUPER)); // Super\n    r = unite(r, baseKey(p, -vec3( 1.4 * 5.65, 0.0, -2.8), 1.1, KEY, KEY_ALT)); // ALT\n    r = unite(r, baseKey(p, -vec3( 1.4 * 4.65, 0.0, -2.8), 0.9, KEY, KEY_MHEN)); // muhenkan\n    r = unite(r, key(p, -vec3( 1.4 * 1.55, 0.0, -2.8), vec2(6.8, 1.0), 0.0, KEY, KEY_SPACE)); // SPACE\n    r = unite(r, baseKey(p, -vec3(-1.4 * 1.55, 0.0, -2.8), 0.9, KEY, KEY_HEN)); // muhenkan\n    r = unite(r, baseKey(p, -vec3(-1.4 * 2.55, 0.0, -2.8), 1.1, KEY, KEY_KANA)); // KANA\n    r = unite(r, baseKey(p, -vec3(-1.4 * 3.65, 0.0, -2.8), 1.1, KEY, KEY_FN)); // FN\n    r = unite(r, baseKey(p, -vec3(-1.4 * 4.75, 0.0, -2.8), 1.1, KEY, KEY_WTF)); // ???\n    r = unite(r, baseKey(p, -vec3(-1.4 * 5.9, 0.0, -2.8), 1.2, KEY, KEY_RCTRL)); // RCTRL\n    r = unite(r, keys(p, -vec3(-1.4 * 8.5, 0.0, -2.8), KEY, KEY_LEFT, 3)); // LEFT-RIGHT\n    \n    r = unite(r, key(p, -vec3(-1.4 * 5.8, 0.0, 1.4), vec2(1.6, 1.0), 0.0, ENTER_KEY, 0)); // ENTER\n    r = unite(r, key(p, -vec3(-1.4 * 6.0, 0., 0.5), vec2(1.0, 2.0), 0.0, ENTER_KEY, 0)); // ENTER\n\n    r = unite(r, board(p, -vec3(0.0, 1., 0.0)));\n    \n    return r;\n}\n\nfloat dist(vec3 p) {\n    return model(p).dist;\n}\n\nvec3 normal(vec3 p) {\n    const float e = 1e-5;\n    float d = dist(p);\n    return normalize(vec3(\n        dist(p + vec3(e,0,0)) - d,\n        dist(p + vec3(0,e,0)) - d,\n        dist(p + vec3(0,0,e)) - d\n    ));\n}\n\nMarchResult march(Ray ray) {\n    vec3 pos = ray.start;\n    for (int i = 0; i < 100; i++) {\n        Model m = model(pos);\n        if (abs(m.dist) < 1e-4) {\n            return MarchResult(true, pos, m);\n        }\n        pos += m.dist * ray.dir;\n    }\n    return MarchResult(false, vec3(0), Model(0.0,vec3(0),-1, -1));\n}\n\nRay generatePerspectiveRay(vec2 uv, PerspectiveCamera camera) {\n    float a = camera.fov * .5 * PI / 180.;\n    vec3 baseZ = -camera.dir;\n    vec3 baseX = normalize(cross(camera.up, baseZ));\n    vec3 baseY = normalize(cross(baseZ, baseX));\n    Ray ray;\n    ray.start = camera.pos;\n    ray.dir = normalize(tan(a) * (uv.x * baseX + uv.y * baseY) - baseZ);\n    return ray;\n}\n\nRay generateOrthoRay(vec2 uv, OrthoCamera camera) {\n    vec3 baseZ = -camera.dir;\n    vec3 baseX = normalize(cross(camera.up, baseZ));\n    vec3 baseY = normalize(cross(baseZ, baseX));\n    Ray ray;\n    ray.start = camera.pos + camera.size * (uv.x * baseX + uv.y * baseY);\n    ray.dir = camera.dir;\n    return ray;\n}\n\nRay generateRay(vec2 uv) {\n    vec3 pos = texelFetch(iChannel0, EYE_COORD, 0).xyz;\n    vec3 dir = normalize(vec3(0) - pos);\n    vec3 up = texelFetch(iChannel0, UP_COORD, 0).xyz;\n    \n    PerspectiveCamera pcamera;\n    pcamera.pos = pos;\n    pcamera.dir = dir;\n    pcamera.up = up;\n    pcamera.fov = 90.;\n        \n    OrthoCamera ocamera;\n    ocamera.pos = pos;\n    ocamera.dir = dir;\n    ocamera.up = up;\n    ocamera.size = 20.;\n    \n    return generatePerspectiveRay(uv, pcamera);\n    // return generateOrthoRay(uv, ocamera);\n}\n\nbool inChar(vec2 uv, vec2 charPos) {\n    if (max(abs(uv.x), abs(uv.y)) > .5) return false;\n    return texture(iChannel2, (uv + charPos + .5) / 16.).a < 0.51;\n}\n\nvec2 code2coord(int code) {\n    if (code == KEY_SPACE)  return COORD_SPACE;\n    if (code == KEY_EXC)    return COORD_EXC;\n    if (code == KEY_DQ)     return COORD_DQ;\n    if (code == KEY_SHARP)  return COORD_SHARP;\n    if (code == KEY_DOLLER) return COORD_DOLLER;\n    if (code == KEY_PERC)   return COORD_PERC;\n    if (code == KEY_AND)    return COORD_AND;\n    if (code == KEY_SQ)     return COORD_SQ;\n    if (code == KEY_LPAREN) return COORD_LPAREN;\n    if (code == KEY_RPAREN) return COORD_RPAREN;\n    if (code == KEY_STAR)   return COORD_STAR;\n    if (code == KEY_PLUS)   return COORD_PLUS;\n    if (code == KEY_COMMA)  return COORD_COMMA;\n    if (code == KEY_MINUS)  return COORD_MINUS;\n    if (code == KEY_DOT)    return COORD_DOT;\n    if (code == KEY_SLASH)  return COORD_SLASH;\n    if (code == KEY_YEN)  return COORD_YEN;\n    if (code == KEY_0) return COORD_0;\n    if (code == KEY_1) return COORD_1;\n    if (code == KEY_2) return COORD_2;\n    if (code == KEY_3) return COORD_3;\n    if (code == KEY_4) return COORD_4;\n    if (code == KEY_5) return COORD_5;\n    if (code == KEY_6) return COORD_6;\n    if (code == KEY_7) return COORD_7;\n    if (code == KEY_8) return COORD_8;\n    if (code == KEY_9) return COORD_9;\n    if (code == KEY_COLON) return COORD_COLON;\n    if (code == KEY_SEMI)  return COORD_SEMI;\n    if (code == KEY_LT)    return COORD_LT;\n    if (code == KEY_EQ)    return COORD_EQ;\n    if (code == KEY_GT)    return COORD_GT;\n    if (code == KEY_QUEST) return COORD_QUEST;\n    if (code == KEY_AT)    return COORD_AT;\n    if (code == KEY_A) return COORD_A;\n    if (code == KEY_B) return COORD_B;\n    if (code == KEY_C) return COORD_C;\n    if (code == KEY_D) return COORD_D;\n    if (code == KEY_E) return COORD_E;\n    if (code == KEY_F) return COORD_F;\n    if (code == KEY_G) return COORD_G;\n    if (code == KEY_H) return COORD_H;\n    if (code == KEY_I) return COORD_I;\n    if (code == KEY_J) return COORD_J;\n    if (code == KEY_K) return COORD_K;\n    if (code == KEY_L) return COORD_L;\n    if (code == KEY_M) return COORD_M;\n    if (code == KEY_N) return COORD_N;\n    if (code == KEY_O) return COORD_O;\n    if (code == KEY_P) return COORD_P;\n    if (code == KEY_Q) return COORD_Q;\n    if (code == KEY_R) return COORD_R;\n    if (code == KEY_S) return COORD_S;\n    if (code == KEY_T) return COORD_T;\n    if (code == KEY_U) return COORD_U;\n    if (code == KEY_V) return COORD_V;\n    if (code == KEY_W) return COORD_W;\n    if (code == KEY_X) return COORD_X;\n    if (code == KEY_Y) return COORD_Y;\n    if (code == KEY_Z) return COORD_Z;\n    if (code == KEY_LBRCK)  return COORD_LBRCK;\n    if (code == KEY_BSLASH) return COORD_BSLASH;\n    if (code == KEY_RBRCK)  return COORD_RBRCK;\n    if (code == KEY_HAT)    return COORD_HAT;\n    if (code == KEY_US)     return COORD_US;\n    if (code == KEY_BQ)     return COORD_BQ;\n    if (code == KEY_LBRAC)     return COORD_LBRAC;\n    if (code == KEY_BAR)       return COORD_BAR;\n    if (code == KEY_RBRAC)     return COORD_RBRAC;\n    if (code == KEY_TILDA)     return COORD_TILDA;\n    if (code == KEY_UP)        return COORD_UP;\n    if (code == KEY_LEFT)      return COORD_LEFT;\n    if (code == KEY_DOWN)      return COORD_DOWN;\n    if (code == KEY_RIGHT)     return COORD_RIGHT;\n}\n\nbool inText(vec2 uv, Codes codes, int w, int h) {\n    int n = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            vec2 offset = (vec2(x, y) - vec2(w-1, h-1) * .5) * vec2(.4, -.8);\n            int code = codes.codes[n++];\n            vec2 coord = code2coord(code);\n            if (inChar(uv - offset, coord)) return true;\n        }\n    }\n    return false;\n}\n\nbool text(vec2 uv, int code) {\n    Codes codes = initCodes();\n    codes.codes[0] = code;\n    int w = 1, h = 1;\n#define SH(k,k0) if (code == k) codes.codes[0] = k0;\n#define DH(k,k0,k1) if (code == k) { codes.codes[0] = k0; codes.codes[1] = k1; w = 2; }\n#define DV(k,k0,k1) if (code == k) { codes.codes[0] = k0; codes.codes[1] = k1; h = 2; }\n#define TH(k,k0,k1,k2) if (code == k) { codes.codes[0] = k0; codes.codes[1] = k1; codes.codes[2] = k2; w = 3; uv /= .8; }\n#define FS(k,k0,k1,k2,k3) if (code == k) { codes.codes[0] = k0; codes.codes[1] = k1; codes.codes[2] = k2; codes.codes[3] = k3; w = 2; h = 2; }\n#define FH(k,k0,k1,k2,k3) if (code == k) { codes.codes[0] = k0; codes.codes[1] = k1; codes.codes[2] = k2; codes.codes[3] = k3; w = 4; uv /= .6; }\n#define VH(k,k0,k1,k2,k3,k4) if (code == k) { codes.codes[0] = k0; codes.codes[1] = k1; codes.codes[2] = k2; codes.codes[3] = k3; codes.codes[4] = k4; w = 5; uv /= .6; }\n#define XH(k,k0,k1,k2,k3,k4,k5) if (code == k) { codes.codes[0] = k0; codes.codes[1] = k1; codes.codes[2] = k2; codes.codes[3] = k3; codes.codes[4] = k4; codes.codes[5] = k5; w = 6; uv /= .6; }\n#define ES(k,k0,k1,k2,k3,k4,k5,k6,k7) if (code == k) { codes.codes[0] = k0; codes.codes[1] = k1; codes.codes[2] = k2; codes.codes[3] = k3; codes.codes[4] = k4; codes.codes[5] = k5; codes.codes[6] = k6; codes.codes[7] = k7; w = 4; h = 2; uv /= .6; }\n    TH(KEY_ESC, KEY_E, KEY_S, KEY_C);\n    DH(KEY_F1, KEY_F, KEY_1);\n    DH(KEY_F2, KEY_F, KEY_2);\n    DH(KEY_F3, KEY_F, KEY_3);\n    DH(KEY_F4, KEY_F, KEY_4);\n    DH(KEY_F5, KEY_F, KEY_5);\n    DH(KEY_F6, KEY_F, KEY_6);\n    DH(KEY_F7, KEY_F, KEY_7);\n    DH(KEY_F8, KEY_F, KEY_8);\n    DH(KEY_F9, KEY_F, KEY_9);\n    TH(KEY_F10, KEY_F, KEY_1, KEY_0);\n    TH(KEY_F11, KEY_F, KEY_1, KEY_1);\n    TH(KEY_F12, KEY_F, KEY_1, KEY_2);\n    SH(KEY_HZ, KEY_SPACE);\n    DV(KEY_1, KEY_EXC,    KEY_1);\n    DV(KEY_2, KEY_DQ,     KEY_2);\n    DV(KEY_3, KEY_SHARP,  KEY_3);\n    DV(KEY_4, KEY_DOLLER, KEY_4);\n    DV(KEY_5, KEY_PERC,   KEY_5);\n    DV(KEY_6, KEY_DOLLER, KEY_6);\n    DV(KEY_7, KEY_SQ,     KEY_7);\n    DV(KEY_8, KEY_LPAREN, KEY_8);\n    DV(KEY_9, KEY_RPAREN, KEY_9);\n    DV(KEY_0, KEY_SPACE,  KEY_0);\n    DV(KEY_MINUS, KEY_EQ, KEY_MINUS);\n    DV(KEY_HAT, KEY_TILDA, KEY_HAT);\n    DV(KEY_YEN, KEY_BAR, KEY_YEN);\n    SH(KEY_BSPACE, KEY_LEFT);\n    TH(KEY_TAB, KEY_T, KEY_A, KEY_B);\n    FS(KEY_AT, KEY_BQ, KEY_SPACE, KEY_AT, KEY_SPACE);\n    FS(KEY_LBRAC, KEY_LBRAC, KEY_SPACE, KEY_LBRCK, KEY_SPACE);\n    ES(KEY_CAPS, KEY_C, KEY_A, KEY_P, KEY_S, KEY_L, KEY_O, KEY_C, KEY_K);\n    DV(KEY_SEMI, KEY_PLUS, KEY_SEMI);\n    DV(KEY_COLON, KEY_STAR, KEY_COLON);\n    FS(KEY_RBRAC, KEY_RBRAC, KEY_SPACE, KEY_RBRCK, KEY_SPACE);\n    VH(KEY_LSHIFT, KEY_S, KEY_H, KEY_I, KEY_F, KEY_T);\n    FS(KEY_COMMA, KEY_LT, KEY_SPACE, KEY_COMMA, KEY_SPACE);\n    FS(KEY_DOT, KEY_GT, KEY_SPACE, KEY_DOT, KEY_SPACE);\n    FS(KEY_SLASH, KEY_QUEST, KEY_SPACE, KEY_SLASH, KEY_SPACE);\n    DV(KEY_BSLASH, KEY_US, KEY_BSLASH);\n    VH(KEY_RSHIFT, KEY_S, KEY_H, KEY_I, KEY_F, KEY_T);\n    FH(KEY_LCTRL, KEY_C, KEY_T, KEY_R, KEY_L);\n    SH(KEY_SUPER, KEY_SPACE);\n    TH(KEY_ALT, KEY_A, KEY_L, KEY_T);\n    SH(KEY_MHEN, KEY_SPACE);\n    SH(KEY_SPACE, KEY_US);\n    SH(KEY_HEN, KEY_SPACE);\n    SH(KEY_KANA, KEY_SPACE);\n    DH(KEY_FN, KEY_F, KEY_N);\n    SH(KEY_WTF, KEY_SPACE);\n    FH(KEY_RCTRL, KEY_C, KEY_T, KEY_R, KEY_L);\n    XH(KEY_INSERT, KEY_I, KEY_N, KEY_S, KEY_E, KEY_R, KEY_T);\n    FH(KEY_HOME, KEY_H, KEY_O, KEY_M, KEY_E);\n    XH(KEY_DELETE, KEY_D, KEY_E, KEY_L, KEY_E, KEY_T, KEY_E);\n    TH(KEY_END, KEY_E, KEY_N, KEY_D);\n    ES(KEY_PAGEUP, KEY_P, KEY_A, KEY_G, KEY_E, KEY_SPACE, KEY_U, KEY_P, KEY_SPACE);\n    ES(KEY_PAGEDN, KEY_P, KEY_A, KEY_G, KEY_E, KEY_D, KEY_O, KEY_W, KEY_N);\n    SH(KEY_PAUSE,  KEY_SPACE); // boring\n    SH(KEY_SCROLL, KEY_SPACE); // boring\n    SH(KEY_PRINT,  KEY_SPACE); // boring\n    return inText(uv, codes, w, h);\n}\n\nvec3 getColor(Ray ray) {\n    MarchResult m = march(ray);\n    if (m.hit) {\n        const vec3 light = vec3(10.);\n        \n        vec3 l = normalize(m.pos - light);\n        vec3 n = normal(m.pos);\n        vec3 e = -ray.dir;\n        \n        vec3 color = vec3(0.1);\n        float ambient = 0.05;\n        float d = max(0.0, dot(n, -l));\n        float s = max(0.0, pow(dot(e, reflect(l, n)), 3.0));\n        vec2 uv = (m.model.center - m.pos).xz / (vec2(1, 0.6) * 0.5) * vec2(-1, 1);\n        if (m.model.type == KEY && text(uv, m.model.code)) {\n            // make it gaming\n            float phase = iTime * 6. - m.pos.x * .2;\n            color = vec3(\n                .5 + .5 * sin(phase),\n                .5 + .5 * sin(phase + PI * 2. / 3.),\n                .5 + .5 * sin(phase - PI * 2. / 3.)\n            ) * 10.;\n        }\n        if (m.model.type == BOARD && n.y > 0.) {\n            vec2 xz = (m.model.center - m.pos).xz - vec2(11.5,6.);\n            float r = length(xz);\n            if (xz.x > 0. && .38 < r && r < .7 ||\n                -.5 < xz.x && xz.x < 0. && abs(xz.y) < .15 ||\n                -.5 < xz.x && xz.x < -.25 && abs(xz.y + .15) < .3) {\n                return vec3(.1,.6,1) * 5.;\n            }\n        }\n        return (ambient * 0.5 + d + s) * color;\n    } else {\n        return texture(iChannel1, ray.dir).rgb;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    \n    Ray ray = generateRay(uv);\n    \n    fragColor = vec4(getColor(ray), 1);\n}","name":"Buffer B","description":"","type":"buffer"}]}