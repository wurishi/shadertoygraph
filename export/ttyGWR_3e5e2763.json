{"ver":"0.1","info":{"id":"ttyGWR","date":"1579061258","viewed":151,"name":"RayTracing Basics","username":"GrisWoldDiablo","description":"Translating a traytraycing compute shader I've  made in unity.\nCONTROL:\nHit Space to toggle rotating light.\nClick Mouse to move camera.","likes":5,"published":1,"flags":16,"usePreview":0,"tags":["raytracing","reflection","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\tAlexandre Lepage\n\t14 Jan 2020\n\tgitHub: https://github.com/GrisWoldDiablo\n*/\n#define REFLECTION_AMOUNT 4\n#define Inf 10000.\n\nstruct Sphere\n{\n\tvec3 position;\n\tfloat radius;\n\tvec3 albedo;\n\tvec3 specular;\n};\n \nSphere CreateSphere(vec4 it, vec3 alb, vec3 spec)\n{\n    Sphere sphere;\n    sphere.position = it.xyz;\n \tsphere.radius = it.w;\n\tsphere.albedo = alb;\n\tsphere.specular = spec;\n\treturn sphere;\n}\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 energy;\n};\n    \nRay CreateRay(vec3 origin, vec3 direction)\n{\n    Ray ray;\n    ray.origin = origin;\n    ray.direction = direction;\n    ray.energy = vec3(1);\n    return ray;\n}\n\nstruct RayHit\n{\n\tvec3 position;\n\tfloat distance;\n\tvec3 normal;\n\tvec3 albedo;\n\tvec3 specular;\n};\n\nRayHit CreateRayHit()\n{\n\tRayHit hit;\n\thit.position = vec3(0);\n\thit.distance = Inf;\n\thit.normal = vec3(0);\n\treturn hit;\n}\n\nvoid IntersectGroundPlane(Ray ray, inout RayHit bestHit)\n{\n    float t = -ray.origin.y / ray.direction.y;\n    if(t > 0. && t < bestHit.distance)\n    {\n        bestHit.distance = t;\n        bestHit.position = ray.origin + t * ray.direction;\n        bestHit.normal = vec3(0,1,0);\n        bestHit.albedo = vec3(.2);\n        bestHit.specular = vec3(.1);\n    }\n}\n\nvoid IntersectSphere(Ray ray, inout RayHit bestHit, Sphere sphere)\n{\n\t// Calculate distance along the ray where the sphere is intersected\n\tvec3 d = ray.origin - sphere.position;\n\tfloat p1 = -dot(ray.direction, d);\n\tfloat p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;\n\tif (p2sqr < 0.)\n\t{\n\t\treturn;\n\t}\n\n\tfloat p2 = sqrt(p2sqr);\n\tfloat t = p1 - p2 > 0. ? p1 - p2 : p1 + p2;\n\tif (t > 0. && t < bestHit.distance)\n\t{\n\t\tbestHit.distance = t;\n\t\tbestHit.position = ray.origin + t * ray.direction;\n\t\tbestHit.normal = normalize(bestHit.position - sphere.position);\n\t\tbestHit.albedo = sphere.albedo;\n\t\tbestHit.specular = sphere.specular;\n\t}\n\n}\n\nRay CreateCameraRay(vec2 uv, vec2 M)\n{\n    vec3 origin = vec3(20.*sin(M.x*5.),2.,-30.*cos(M.x*5.));\n    \n    vec3 lookat = vec3(0,2.*M.y*5.+10.,10.);\n    vec3 f = normalize(lookat-origin);\n    vec3 rg = normalize(cross(vec3(0,1,0),f));\n    vec3 u = normalize(cross(f,rg));\n    vec3 c = origin + f*1.;\n    vec3 i  = c + uv.x*rg + uv.y*u;\n\n    vec3 direction = normalize(i-origin);\n    return CreateRay(origin, direction);\n}\n\nRayHit Trace(Ray ray)\n{\n    RayHit bestHit = CreateRayHit();\n    IntersectGroundPlane(ray, bestHit);\n    \n    Sphere sphere = CreateSphere(vec4(0,2.+sin(iTime)/2.,5,1),vec3(1,0,0),vec3(0));\n    IntersectSphere(ray, bestHit, sphere);\n    Sphere sphere2 = CreateSphere(vec4(2,2,5.+cos(iTime),.5),vec3(0,1,0),vec3(1));\n    IntersectSphere(ray, bestHit, sphere2);\n    Sphere sphere3 = CreateSphere(vec4(-2,2,5.+cos(iTime),.5),vec3(0,1,1),vec3(1));\n    IntersectSphere(ray, bestHit, sphere3);\n    Sphere sphere4 = CreateSphere(vec4(0.+sin(iTime),4.,5.,.5),vec3(1,1,0),vec3(.5));\n    IntersectSphere(ray, bestHit, sphere4);\n    Sphere sphere5 = CreateSphere(vec4(0.,15,20,10),vec3(1),vec3(1));\n    IntersectSphere(ray, bestHit, sphere5);\n    return bestHit;\n}\nconst int KEY_SPACE = 32;\nvec3 Shade(inout Ray ray, RayHit hit)\n{\n    float newTime = iTime + 10.;\n\tif(hit.distance < Inf)\n    {\n    \tray.origin = hit.position + hit.normal * 0.001;\n        ray.direction = reflect(ray.direction, hit.normal);\n        ray.energy *= hit.specular;\n        \n        float rot = texelFetch( iChannel0, ivec2(KEY_SPACE,2),0 ).x;\n        vec3 lightPos;\n        if(rot == 0.){\n        \tlightPos = normalize(vec3(5.*sin(newTime),5.,-5.*cos(newTime)*2.));\n        }else{\n        \tlightPos = normalize(vec3(1.,2.,-5.));\n        }\n        \n        Ray shadowRay = CreateRay(hit.position + hit.normal * 0.001, lightPos);\n\t\tRayHit shadowHit = Trace(shadowRay);\n        if (shadowHit.distance != Inf)\n\t\t{\n\t\t\treturn vec3(0);\n\t\t}\n        return clamp(dot(hit.normal, lightPos) * 1.,0.,1.)* hit.albedo;\n    }\n    else\n    {\n        ray.energy = vec3(0);\n        return vec3(.2);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy/iResolution.xy)*2.-1.;\n    Ray ray = CreateCameraRay(uv, M);\n    \n    vec3 result = vec3(0);\n    for (int i = 0; i < REFLECTION_AMOUNT; i++)\n    {\n    \tRayHit hit = Trace(ray);\n    \tresult += ray.energy * Shade(ray, hit);\n        if(ray.energy.x == 0. || ray.energy.y == 0. || ray.energy.z == 0.) break;\n    }\n    \n    fragColor = vec4(result,1.0);\n}","name":"Image","description":"","type":"image"}]}