{"ver":"0.1","info":{"id":"ctfGWM","date":"1671809494","viewed":150,"name":"the spirit pond","username":"vivavolt","description":"yndx","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["yndx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"volna rk autum 2022\" by nrebrikov. https://shadertoy.com/view/NtcfDB\n// 2022-12-23 15:30:56\n\n// ---------- SHADERTOY_PARAMS ---------------\n\n// Device parameters, don't change\n\n#define vTime iTime*0.5\n#define vScreenSize iResolution.xy\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n\n// External input\n\n#define vLow 1.0\n#define vHigh 0.0\n#define vMid 0.0\n#define vReaction 0.0\n#define vReactionScale 2.\n#define vReactionPoint vec2(0.0, 0.0)\n#define vReactionColor vec3(1.0, 1.0, 1.0)\n\n#define maxTempo 174.\n#define bpm(tempo) tempo / maxTempo\n// vBpm = tempo / maxTempo (max of the song list)\n\n// song (118 active / 10 inactive)\n#define vBpm bpm(118.)\n#define vEnergy 0.9311161\n#define vHue 0.58\n\nvec3 hsl2rgb(vec3 c) {\n    return c.z + c.y * (c.z + c.y * ((c.z + c.y * (clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 )-0.5)*(1.0-abs(2.0*c.z-1.0)))-0.5)*(1.0-abs(2.0*c.z-1.0))-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n#define vColorBottom hsl2rgb(vec3(vHue, 1.2, 0.6))\n#define vColorTop hsl2rgb(vec3(vHue + 0.15, 1.2, 0.5))\n\n#define vBackgroundColor vec3(0.047,0.047,0.047)\n\n// ---------------- ANIMATION -----------------\n\n// Animation parameters\n\n#define YZ_ROTATION_MULTIPLIER 1.0\n#define XZ_ROTATION_MULTIPLIER 0.7\n#define XY_ROTATION_MULTIPLIER 0.5\n\n#define WAVE_MOVEMENT_MULTIPLIER 1.8\n\n#define SCENE_SCALE 0.9\n#define SCENE_ROTATION 3.1451 * 1.75\n\n#define HEAD_INTENSITY 0.15 * vHigh\n#define TAIL_INTENSITY 3.0 + 1.0 * vLow\n\n#define COLOR_MULTIPLIER 8.0\n\n#define PASS_COUNT 4 // Performance impact\n#define DISTANCE 3.5\n\n//#define Y_FREQUENCY 0.5\n//#define X_FREQUENCY 0.5\n//#define Z_FREQUENCY 0.5\n\n#define Y_FREQUENCY 1.2\n#define X_FREQUENCY 1.2\n#define Z_FREQUENCY 1.2\n\n#define MIN_FREQUENCY 0.5\n#define FREQUENCY_MID_MULTIPLIER 0.5\n#define FREQUENCY_REACTION_MULTIPLIER 1.5\n\n#define SCALE_REACTION_MULTIPLIER 1.5\n\n#define REACTION_POINT_SIZE 0.2\n\n// Helpers\n\nmat2 mRotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s,\n                s, c);\n}\n\n// Shader code\n\nfloat waves(vec3 point, float freq) {\n    // Rotate point\n    point.yz *= mRotate(vTime * YZ_ROTATION_MULTIPLIER);\n    point.xz *= mRotate(vTime * XZ_ROTATION_MULTIPLIER);\n    point.xy *= mRotate(vTime * XY_ROTATION_MULTIPLIER);\n\n    // Calculate waves\n    vec3 q = point * (1.0 + vBpm) + vTime * WAVE_MOVEMENT_MULTIPLIER;\n    float centeredCircle = length(point);\n    float centerCut = log(length(point) - 1.0);\n    float waves = freq * sin(X_FREQUENCY * q.x - sin(Y_FREQUENCY * q.y + sin(q.z * Z_FREQUENCY))) - 1.0;\n    return centeredCircle * centerCut + waves;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalize to [0; 1]\n    vec2 uvTrue = gl_FragCoord.xy / vScreenSize;\n\n    // Normalize to [-1; 1]\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n\n    // Make symmetric\n    float minSide = min(vScreenSize.x, vScreenSize.y);\n    vec2 minSquare = vec2(minSide, minSide);\n    vec2 aspectSides = vScreenSize / minSide;\n    uv *= aspectSides;\n\n    // Define reaction point\n    vec2 reactPoint = vReactionPoint * aspectSides;\n    float reactIntensity = clamp(length(uv - reactPoint) / 2.0 / REACTION_POINT_SIZE,\n                                 0.,\n                                 1.);\n\n    // Define frequency\n    float freq = MIN_FREQUENCY + vMid * FREQUENCY_MID_MULTIPLIER;\n    freq = mix(freq + vReaction * FREQUENCY_REACTION_MULTIPLIER,\n               freq,\n               reactIntensity);\n\n    // Rotate around origin\n    uv *= mRotate(SCENE_ROTATION);\n\n    // Scale around origin\n    uv *= 1.0 / SCENE_SCALE;\n\n    // Apply reaction scale\n    uv /= vReactionScale;\n\n    // Calculate color intensity\n    float opacity = 0.0;\n    float d = DISTANCE;\n    for(int i = 0; i < PASS_COUNT; i++) {\n        vec3 p = + vec3(0., 0, 5.5) + vec3(uv, -1.) * d*float(i)*0.8;\n        float result = waves(p, freq);\n        float f = result - waves(p + 0.04, freq);\n        float l = f * (COLOR_MULTIPLIER + vReaction * 2.0);\n        opacity = opacity * l + smoothstep(TAIL_INTENSITY, 1.0, result) * l;\n        d += min(result, 1.0);\n    }\n\n    // Mix top and bottom colors\n    vec3 gradColor = mix(vColorBottom, vColorTop, uvTrue.y);\n\n    // Mix with reaction color if needed\n    vec3 reactedColor = mix(gradColor, vReactionColor, vReaction * (1. - reactIntensity));\n\n    // Mix with background color\n    vec3 color = mix(vBackgroundColor, reactedColor, clamp(opacity, 0.0, 1.0));\n\n    // Set the result\n    gl_FragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}