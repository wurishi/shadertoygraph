{"ver":"0.1","info":{"id":"cslXWN","date":"1669037747","viewed":111,"name":"Noise sphere black","username":"calebxcaleb","description":"black noise sphere","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int SAMPLES = 1000;\nfloat seed = 0.0;\nfloat aa = 0.01;\nconst float PI = 3.141592653589793238462643383;\n\nstruct Sphere{\n    float radius;\n    vec3 center;\n    vec3 col;\n};\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\n\nvec2 random2(vec3 st){\n  vec2 S = vec2( dot(st,vec3(127.1,311.7,783.089)),\n             dot(st,vec3(269.5,183.3,173.542)) );\n  return fract(sin(S)*43758.5453123);\n}\n\nvec3 rand_dir( vec3 seed)\n{\n\tvec2 uv = random2(seed);\n\n\tfloat theta = 2.0 * PI * uv[0];\n\tfloat phi = acos(2.0 * uv[1] - 1.0);\n\n\treturn vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));\n}\n\nvec3 smoooth(vec3 f){\n    f[0] = 6.0 * pow(f[0], 5.0) - 15.0 * pow(f[0], 4.0) +  10.0 * pow(f[0], 3.0);\n    f[1] = 6.0 * pow(f[1], 5.0) - 15.0 * pow(f[1], 4.0) +  10.0 * pow(f[1], 3.0);\n    f[2] = 6.0 * pow(f[2], 5.0) - 15.0 * pow(f[2], 4.0) +  10.0 * pow(f[2], 3.0);\n    return fract(f);\n}\n\nfloat perlin_noise(vec3 seed){\n    vec3 p000 = rand_dir(floor(seed));\n    vec3 p001 = rand_dir(floor(seed) + vec3(0,0,1));\n    vec3 p010 = rand_dir(floor(seed) + vec3(0,1,0));\n    vec3 p011 = rand_dir(floor(seed) + vec3(0,1,1));\n    vec3 p100 = rand_dir(floor(seed) + vec3(1,0,0));\n    vec3 p101 = rand_dir(floor(seed) + vec3(1,0,1));\n    vec3 p110 = rand_dir(floor(seed) + vec3(1,1,0));\n    vec3 p111 = rand_dir(floor(seed) + vec3(1,1,1));\n    \n    vec3 d000 = floor(seed) - seed;\n    vec3 d001 = floor(seed) + vec3(0,0,1) - seed;\n    vec3 d010 = floor(seed) + vec3(0,1,0) - seed;\n    vec3 d011 = floor(seed) + vec3(0,1,1) - seed;\n    vec3 d100 = floor(seed) + vec3(1,0,0) - seed;\n    vec3 d101 = floor(seed) + vec3(1,0,1) - seed;\n    vec3 d110 = floor(seed) + vec3(1,1,0) - seed;\n    vec3 d111 = floor(seed) + vec3(1,1,1) - seed;\n    \n    vec3 smoothed = smoooth(fract(seed));\n\n    float x_mix_1 = mix(dot(p000, d000), dot(p100, d100), smoothed[0]);\n    float x_mix_2 = mix(dot(p001, d001), dot(p101, d101), smoothed[0]);\n    float x_mix_3 = mix(dot(p010, d010), dot(p110, d110), smoothed[0]);\n    float x_mix_4 = mix(dot(p011, d011), dot(p111, d111), smoothed[0]);\n    \n    float y_mix_1 = mix(x_mix_1, x_mix_3, smoothed[1]);\n    float y_mix_2 = mix(x_mix_2, x_mix_4, smoothed[1]);\n    \n    return mix(y_mix_1, y_mix_2, smoothed[2]);\n}\n\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\nfloat hit(Sphere s, Ray r){\n    vec3 dist = r.origin - s.center;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(dist, r.dir);\n    float c = dot(dist, dist) - s.radius * s.radius;\n    float discriminant = b*b - 4.0*a*c;\n    \n    if(discriminant >= 0.0){\n        return (-b - sqrt(discriminant) ) / (2.0*a);\n    } else {    \n        return 1.0;\n    }\n}\n\nvec3 display(Sphere s, Ray r){\n    float t = hit(s, r);\n        \n    if(t < 0.0){\n        return vec3(-1.0 * r.dir.x * t + 0.25, -1.0 * r.dir.y * t + 0.25, r.dir.z * t - 0.75);\n        // return vec3(normalize(r.origin + r.dir * t - s.center));\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2((fragCoord.x/iResolution.x), (fragCoord.y/iResolution.y)/aspect);\n    uv = fragCoord - iResolution.xy*0.5;\n    uv /= iResolution.y;\n\n    \n    Sphere s = Sphere(0.25, vec3(0.0, 0.0, 1.0), vec3(1.0, 0.5, 0.25));\n    Ray r;\n\n\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < SAMPLES; i++){\n        r = Ray(vec3(0.0, 0.0, 0.0), vec3(uv.x + random() * aa, uv.y + random() * aa, -1.0));\n        col += display(s, r);\n    }\n    \n    col /= float(SAMPLES);\n\n    vec3 point_1 = col * ((sin(iTime) + 1.0) * 15.0 + 1.0);\n    vec3 point_2 = col * ((cos(iTime) + 1.0) * 7.0 + 1.0);\n    vec3 point_3 = col * ((sin(iTime) + 1.0) * 3.0 + 1.0);\n    \n    vec3 point1 = vec3(point_1[0], point_1[1], point_1[2]);\n    vec3 point2 = vec3(point_2[1], point_2[2], point_2[0]);\n    vec3 point3 = vec3(point_3[2], point_3[0], point_3[1]);\n    \n    bool is_fract = false;\n    \n    float perlin1 = float(is_fract) * (fract(perlin_noise(point1)) + 1.0) * 0.5 + float(!is_fract) * (perlin_noise(point1) + 1.0) * 0.5;\n    float perlin2 = float(is_fract) * (fract(perlin_noise(point2)) + 1.0) * 0.5 + float(!is_fract) * (perlin_noise(point2) + 1.0) * 0.5;\n    float perlin3 = float(is_fract) * (fract(perlin_noise(point3)) + 1.0) * 0.5 + float(!is_fract) * (perlin_noise(point3) + 1.0) * 0.5;\n\n    vec3 Perlin = vec3(perlin1 * perlin2 * perlin3);\n\n    // Output to screen\n    fragColor = vec4(Perlin,1.0);\n}","name":"Image","description":"","type":"image"}]}