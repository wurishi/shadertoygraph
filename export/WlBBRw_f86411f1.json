{"ver":"0.1","info":{"id":"WlBBRw","date":"1598508304","viewed":613,"name":"Landscape Evolution Raymarching","username":"j91000","description":"w,a,s,d,shift,spacebar: move camera\nmouse drag: pan camera\nr: reset sim.\nRaymarching terrain algorithm lifted from: https://www.shadertoy.com/view/MtsSRf\nwith a similar erosion-deposition model to: https://www.shadertoy.com/view/wtffDX\n\n","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","fluid","landscape","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching code Created by Beautypi/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//  click and drag: pan camera\n//  wasd: move camera\n//  shift/spacebar: raise and lower camera\n//  f: toggle water heightmap mode\n//  t: toggle sediment load display\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//DAD\n#define MAXSTEPS 2000\n#define STEPFAC .1\nvec4 getTerrain(in vec3 pos){\n    vec2 q = pos.xz*0.1;\n    return texture(iChannel0,q);\n}\nfloat cosNoise( in vec2 p )\n{\n    return 0.5*( sin(p.x) + sin(p.y) );\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,\n                     1.2, 1.6);\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat terrainHeight(in vec3 pos){\n        float h = 0.0;\n    h=getTerrain(pos).x;\n    return h;\n}\nfloat map( in vec3 pos )\n{\n    \n    float d1 = pos.y-terrainHeight(pos)*2.;\n    return d1;//smin( d1, d2, 1.0 );\n}\n\nfloat mapH( in vec3 pos )\n{\n\n    float d1 = pos.y-terrainHeight(pos)*3.;\n    \n    \n    return d1;//smin( d1, d2, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0) * 0.01;\n    \n    return normalize( e.xyy*mapH( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapH( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapH( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapH( pos + e.xxx ) );\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        res = min( res, max(h,0.0)*164.0/t );\n        if( res<0.001 ) break;\n        t += h*0.5;\n    }\n    \n    return res;\n}\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\nmat3 fetchMouseRotation(){\n    float pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n    \n        \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(iMouse.xy == vec2(0,0))\n    {\n\t\tangles = vec3(vec2(.5) * pi, 0);\n        angles.xy *= vec2(1.6, 0.40);//STARTING ANGLE\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, tau / 4.0);\n    return Rotate(vec3(pi/2.,pi,0.))*Rotate(angles.yxz);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{float pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n    \n        \n    //Camera stuff   \n   \n    mat3 rotate = fetchMouseRotation();\n    \n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = (-iResolution.xy + 2.0* fragCoord.xy) / iResolution.y;\n    \n    float ani = -20.0 ;\n    \n    // ray\n    vec3 ro = vec3( 0.0, 4.0, -ani*0.5 )+vec3(texture(iChannel1,p).xzy);\n    \n    float roll =0.; 0.2*sin(0.1*ani);\n    q = mat2( cos(roll), -sin(roll), sin(roll), cos(roll) ) * q;\n    \n    vec3 rd = (normalize( vec3(q-vec2(-0.4,0.4),-2.0) )*rotate);\n    //rd*=Rotate(vec3(.5,-2.,0.));//DAD\n    vec3 col = vec3( 0.7, 0.8, 1.0 );\n    col *= 1.0 - 0.5*rd.y;\n\n    // raymarcher\n    float tmax = 120.0;\n    float t = 0.0;\n    for( int i=0; i<MAXSTEPS; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        if( h<0.001 || t>tmax ) break;\n        t += h*STEPFAC;\n    }\n\n    vec3 light = normalize( vec3( cos(iTime/20.), 0.5, sin(iTime/20.)) );//SUNANGLE\n    // hit\n    if( t<tmax )\n    {\n        // shade and light\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        float bak = clamp( dot(nor,normalize(-vec3(light.x,0.0,light.z))), 0.0, 1.0 );\n        float dif = clamp( dot(nor,light), 0.0, 1.0 );\n        float sha =softShadows( pos+nor*.01, light );\n        vec3 lig = vec3(2.0,1.5,1.0)*dif*1.5*sha;\n             lig += vec3(0.2,0.3,0.4)*max(nor.y,0.0)*0.9;\n             lig += vec3(0.1,0.1,0.1)*bak*0.5;\n        vec3 mate = vec3(0.3,0.3,0.3)*0.5;\n        vec3 tint=clamp(1.+5.*getTerrain(pos).yzw,0.,2.5);\n        mate = mix( mate*tint, tint*vec3(0.2,0.15,0.1)*0.73, smoothstep( 0.2,0.9,1.1*pow(nor.y,.8)));//nor.y) );\n        mate *=0.5 + texture( iChannel0, 0.5*pos.xz ).x*1.0;\n \n        col = mate * lig;\n\n        float fog = exp( -0.0015*t*t );\n        col *= fog;\n        col += (1.0-fog)*vec3(0.5,0.6,0.7);\n    }\n\n    float sun = clamp( dot(rd,light), 0.0, 1.0 );\n    col += vec3(1.0,0.8,0.6)*0.4*pow(sun,16.0);\n    col += vec3(1.0,0.8,0.6)*0.3*pow(sun,8.0);\n    \n    col = sqrt( col );\n    \n    col *= 0.5 + 0.5*pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y),0.2);\n    \n    col = smoothstep( 0.0, 1.0, col );\n\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.25 );\n    \n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////This buffer holds the model state and performs the landscape evolution\n\n///////////////////////////////////// LANDSCAPE EVOLUTION CONSTANTS\n\nconst float RAINFALL=0.000001;//0.000001;\nconst float EROSIONPOWER=.05;//.05\nconst float settlingVel=0.00000000001;//.00005\nconst float UPLIFT=0.;//.0001;\nconst float LUPLIFT=0.0000;//.0001;\nconst float NULLHEIGHT=0.0;\nbool CASTLE = false;\n//////////////////////////////////////\nconst int RCODE=82;\nbool noHYet(){\n     float iniCheck=texture(iChannel0,vec2(0.)).x;\n    return (iniCheck==NULLHEIGHT);   \n}\nfloat noise( in vec3 x )\n{\n    #if 1\n    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel2, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n    \n    #else\n    \n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = i.xy + ivec2(37,17)*i.z;\n\tvec2 rgA = texelFetch( iChannel3, (uv+ivec2(0,0))&255, 0 ).yx;\n    vec2 rgB = texelFetch( iChannel3, (uv+ivec2(1,0))&255, 0 ).yx;\n    vec2 rgC = texelFetch( iChannel3, (uv+ivec2(0,1))&255, 0 ).yx;\n    vec2 rgD = texelFetch( iChannel3, (uv+ivec2(1,1))&255, 0 ).yx;\n    vec2 rg = mix( mix( rgA, rgB, f.x ),\n                   mix( rgC, rgD, f.x ), f.y );\n    return mix( rg.x, rg.y, f.z );\n    \n    #endif\n}\nbool resetTime(){\n    bool loaded=iTime>.5&&texture(iChannel2,vec2(0.)).xy!=vec2(0.)&&texture(iChannel3,vec2(0.)).xy!=vec2(0.);\n\tbool noHYet=noHYet();\nbool result= ((texelFetch( iChannel1, ivec2(RCODE,0),0).x>0.)||(noHYet&&loaded));\nreturn result;\n}\nvec4 getState(in vec2 p){\n    return texture(iChannel0,p/iResolution.xy);\n}\nfloat getLevel(in vec2 p){\n    vec4 state=getState(p);\n    float level=state.x+state.y+state.z;\n    return level;\n}\n\nfloat getW(in vec2 p){\n    vec4 state=getState(p);\n    float water=state.y;\n    return water;\n}\nfloat getH(in vec2 p){\n    vec4 state=getState(p);\n    float height=state.x;\n    return height;\n}\nfloat getS(in vec2 p){\n    vec4 state=getState(p);\n    float sediment=state.z;\n    return sediment;\n}\nvec2[8] getONeighbs(vec2 p){\n    vec2 nw=vec2(-1.,-1.)+p;\n    vec2 n=vec2(0.,-1.)+p;\n    vec2 ne=vec2(1.,-1.)+p;\n    vec2 w=vec2(-1.,0.)+p;\n    vec2 e=vec2(1.,0.)+p;\n    vec2 sw=vec2(-1.,1.)+p;\n    vec2 s=vec2(0.,1.)+p;\n    vec2 se=vec2(1.,1.)+p;\n    return vec2[8](nw,n,ne,w,e,sw,s,se);\n}\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nint nextInt(vec2 pos,int low,int high){\n    float l=float(low);\n    float h=float(high);\n    return int(floor(rand(pos)*(h-l)+l));\n}\nvec2[8] randomNeighbs(vec2 p){\n    vec2 z=vec2(0.);\n    vec2[8] list=getONeighbs(p);\n    for(int i=0;i<7;i++){\n        vec2 seed=p+float(i);\n        int randomIndex=nextInt(seed,i,8);\n        vec2 vi=list[i];\n        vec2 vj=list[randomIndex];\n        list[i]=vj;\n        list[randomIndex]=vi;\n    }\n    return list;\n}\n\nvec2 getLowestNeighb(in vec2 p){\n    vec2[8] neighbs=randomNeighbs(p);\n    vec2 lowest=p;\n    for(int i=0;i<8;i++){\n        vec2 neighb=neighbs[i];\n        float neighbDif=(getLevel(p)-getLevel(neighb))/max(1.,length(p-neighb));\n        float lowDif=(getLevel(p)-getLevel(lowest))/max(1.,length(p-lowest));\n        if(neighbDif>lowDif){\n            lowest=neighb;\n        }   \n    }\n    return lowest;\n}\nvec2 Water_SedDrainage(vec2 p){\n    vec2 lowest=getLowestNeighb(p);\n    float dif=(getLevel(p)-getLevel(lowest))/max(1.,length(lowest-p));\n    if(p.x<3.||p.y<3.||p.x>iResolution.x-3.||p.y>iResolution.y-3.){dif=0.0000003;}\n    //if(p.x>iResolution.x-3.){dif=0.0001;}\n    float water=getW(p);\n    float sed=getS(p);\n    float massTransport=max(0.,min(water+sed,dif/2.));\n    float waterDrain=0.;\n    float sedDrain=0.;\n    if(massTransport>0.){\n        waterDrain=(water/(water+sed))*massTransport;\n        sedDrain=(sed/(water+sed))*massTransport;\n    }\n    return vec2(waterDrain,sedDrain);\n}\nvec2 Water_SedInFlow(vec2 p){\n    float waterIn=0.;\n    float sedIn=0.;\n    vec2[8] neighbs=randomNeighbs(p);//(nw,n,ne,w,e,sw,s,se) NW=== (-1 , -1)\n    for(int i=0;i<8;i++){\n        vec2 neighb=neighbs[i];\n        vec2 target=getLowestNeighb(neighb);\n        if(target==p){//if it points to p\n           vec2 wsDrain=Water_SedDrainage(neighb);\n            waterIn+=wsDrain.x;\n            sedIn+=wsDrain.y;\n            \n\n        }\n    }\n    return vec2(waterIn+RAINFALL,sedIn);\n}\nfloat getErosivity(vec2 p){\n    float h=getLevel(noise(vec3(p/10.,0.))/5.+p)+4.*texture(iChannel3,.6-p/2./iResolution.xy).x;\n    return 1.+.7*sin(h*8.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{//x coord is topo height. y coord is water height.\n     \n    vec2 pos=fragCoord;\n    vec2 lowest=getLowestNeighb(pos);\n    float dif=(getLevel(pos)-getLevel(lowest))/max(1.,length(pos-lowest));\n    if(pos.x<3.||pos.y<3.||pos.x>iResolution.x-3.||pos.y>iResolution.y-3.){dif=.0000003;}\n    //if(pos.x>iResolution.x-3.){dif=0.0001;}\n    vec2 inF=Water_SedInFlow(pos);\n    float inflow=inF.x;\n    float sedInflow=inF.y;\n    vec2 wsDrainage=Water_SedDrainage(pos);\n    \n        \n    vec4 finalC=getState(pos);//out state same as in state\n    float streamPower=inflow;\n    \n    float erosion=getErosivity(pos)*EROSIONPOWER*pow(streamPower,1./3.)*pow(dif,.666);//stream power law stuff\n    float deposition=0.;\n    float se=inF.y;\n    float wa=inF.x;\n    if((se+wa)>0.){\n        deposition=clamp(settlingVel/(streamPower/(getW(pos)))*getS(pos)/((streamPower)),0.,getS(pos)-wsDrainage.y+sedInflow);\n    }\n    else{deposition=getS(pos);}\n    //deposition=se;\n    ///////////////MASS BALANCE EQUATIONS.\n    finalC.x+=UPLIFT+deposition-erosion;//basement height changes by erosion, -deposition, and the constant uplift\n    finalC.y+=inflow-wsDrainage.x;//water level changes by +in -out.\n    finalC.z+=erosion-deposition+sedInflow-wsDrainage.y;//suspended sediment from inflow,outflow, deposition and erosion.\n    /////////////////////////\n    bool resetTime=resetTime();\n    if(resetTime){\n        finalC=1.*texture(iChannel3,pos/iResolution.xy,1.).xxxx+.1*pow(texture(iChannel2,fract(pos/iChannelResolution[2].xy)).x,.2);\n        finalC*=vec4(1.,0.,0.,0.);\n        finalC+=vec4(.3,.0,0.,.0);\n        finalC.x+=10.*texture(iChannel3,(pos)/7./iResolution.xy).x;\n        if(CASTLE){\n        finalC=vec4(.3,0.,0.,0.);\n        vec2 uv=pos/iResolution.xy-vec2(.5);\n        if(length(uv)<.2){finalC.x+=10.*pow(.2-length(uv),1./4.);}\n        }\n    }\n    if(pos.x<3.||pos.y<3.||pos.x>iResolution.x-3.||pos.y>iResolution.y-3.){finalC.y=0.;finalC.z=0.;}\n    //if(pos.x>iResolution.x-3.){finalC.y=0.;finalC.z=0.;}\n    if(pos.x<iResolution.x/2.){finalC.x+=LUPLIFT;}\n    if(noHYet()&&!resetTime){\n        fragColor=vec4(0.);\n    }\n    else{\n    fragColor=finalC*vec4(1.,1.,1.,1.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this buffer is just a translation between \n//\t\t-the raw LEM state in this form:\t[vec4(basementHeight,waterHeight,suspendedSedimentHeight,1.)]\n//\tand -the textured heightmap in this form:\t[vec4(tallness,\t[0.,sedimentFullness,wetness])]\n//[0.,sediment,wetness] is the rgb tint applied to this location.\n\n\nvec4 getState(in vec2 p){\n    return texture(iChannel0,p);\n}\nfloat getLevel(in vec2 p){\n    vec4 state=getState(p);\n    float level=state.x+state.y+state.z;\n    return level;\n}\nfloat getW(in vec2 p){\n    vec4 state=getState(p);\n    float water=state.y;\n    return water;\n}\nfloat getH(in vec2 p){\n    vec4 state=getState(p);\n    float height=state.x;\n    return height;\n}\nfloat getS(in vec2 p){\n    vec4 state=getState(p);\n    float sediment=state.z;\n    return sediment;\n}\nconst int TCODE=84;\nconst int FCODE=70;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool WATERMODE=false;\n    bool SEDMODE=true;\n    if(0.<texelFetch( iChannel1, ivec2(FCODE,2), 0 ).x){WATERMODE=true;}\n    if(0.<texelFetch( iChannel1, ivec2(TCODE,2), 0 ).x){SEDMODE=false;}\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float tallness=pow(getLevel(uv),1.)*.09+.7;\n    float wetness=pow(getW(uv),1.)*5.;\n    float fullness=pow(getS(uv),1.)*2.;\n    if(WATERMODE){tallness=wetness/5.*.09+.7;}//sqrt(1.1+log(.001+getW(uv))*.06);}\n    if(!SEDMODE){fullness=0.;};//tallness=sqrt(.8+pow(getS(uv),.5)/4.);}\n    if(fragCoord.x<4.||fragCoord.y<4.||fragCoord.y>iResolution.y-4.||fragCoord.x>iResolution.x-4.){tallness=.75;}\n \n    fragColor =vec4(tallness,0.-wetness/40.,fullness-wetness/40.,wetness);//.02*getState(uv).xxxx;\n    //fragColor=vec4(tallness+fullness,tallness+fullness,tallness+wetness,1.);\n    //fragColor=vec4(getLevel(uv))/.5-10.*iMouse.x/iResolution.x;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//this buffer stores the camera position, and applies keyboard inputs.\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPC =32 ;\nconst int KEY_SHIFT = 16;\nconst int KEY_A=65;\nconst int KEY_D=68;\nconst int KEY_W=87;\nconst int KEY_S=83;\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}    \nmat3 fetchMouseRotation(){\n    float pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n    \n        \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.5 / 8.0);\n        angles.x = iTime * 0.1;\n    }\n    else\n    {    \n    \tangles = vec3((1.-(iMouse.xy*vec2(1.,0.)+vec2(0.,iResolution.y)) / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    //angles.y = clamp(angles.y, 0.0, tau / 4.0);\n    return Rotate(vec3(0.,0.,-pi/2.))*Rotate(angles.yxz);\n}\n    \nvec3 keys(vec2 uv){\n    vec3 result=vec3(0.);\n if(0.<texelFetch( iChannel2, ivec2(KEY_SPC,0), 0 ).x){\n result+=vec3(-1.,0.,0.);\n }\n if(0.<texelFetch( iChannel2, ivec2(KEY_SHIFT,0), 0 ).x){\n result+=vec3(1.,0.,0.);\n }\n if(0.<texelFetch( iChannel2, ivec2(KEY_W,0), 0 ).x){\n     result+=vec3(0.,-1.,0.);\n }\n if(0.<texelFetch( iChannel2, ivec2(KEY_S,0), 0 ).x){\n     result+=vec3(0.,1.,0.);\n }\n    if(0.<texelFetch(iChannel2, ivec2(KEY_D,0),0).x){\n        result+=vec3(0.,0.,-1.);\n    }\n    if(0.<texelFetch( iChannel2, ivec2(KEY_A,0), 0 ).x){\n        result+=vec3(0.,0.,1.);\n    }\n    vec3 strt=normalize( vec3(0.-vec2(-0.4,0.4),-2.0));//vec3(1.,1.,-1.)\n    return (result/40.)*fetchMouseRotation();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{vec2 uv=fragCoord/iResolution.xy;\n    vec3 data=texture(iChannel0,uv).xyz;\n    fragColor = vec4(data.xyz+keys(uv).zxy,.0);\n if(iFrame<100){fragColor=vec4(7.,-3.,1.4,0.);}//STARTING CAMERAPOS\n}","name":"Buffer D","description":"","type":"buffer"}]}