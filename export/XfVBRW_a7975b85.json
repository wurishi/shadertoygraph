{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define STEPPED\n#define LIMIT 4.\n#define SPEED 8.\n#define COLOR_SPEED 16.\n#define COLOR_CYCLES 3.1415\n#define LINE_WIDTH 6.\n#define LINE_FADE 0.4\n\nfloat vsum(vec2 p) {\n    return p.x + p.y;\n}\n\nint vsum(ivec2 p) {\n    return p.x + p.y;\n}\n\nfloat vmul(vec2 p) {\n    return p.x * p.y;\n}\n\nint vmul(ivec2 p) {\n    return p.x * p.y;\n}\n\nbool in_region(ivec2 pos, ivec2 x1, ivec2 x2) {\n    ivec2 bl = ivec2(min(x1.x, x2.x), min(x1.y, x2.y));\n    ivec2 tr = ivec2(max(x1.x, x2.x), max(x1.y, x2.y));\n    \n    if (x2.x < x1.x) {\n        bl.x += 1;\n        tr.x += 1;\n    }\n    if (x2.y < x1.y) {\n        bl.y += 1;\n        tr.y += 1;\n    }\n    \n    return all(lessThanEqual(bl, pos)) && all(lessThan(pos, tr));\n}\n\n// algorithm from: https://github.com/jakubcerveny/gilbert\nfloat GilbertIndex( ivec2 canvas, ivec2 pos )\n{\n    float canvas_size = float(canvas.x * canvas.y) - 1.;\n    int start_ix = 0;\n    ivec2 p = ivec2(0);\n    ivec2 a = ivec2(canvas.x, 0);\n    ivec2 b = ivec2(0, canvas.y);\n    ivec2 da;\n    ivec2 db;\n    ivec2 wh;\n    ivec2 a2;\n    ivec2 b2;\n    ivec2 wh2;\n    \n    if (canvas.x < canvas.y) {\n        a = ivec2(0, canvas.y);\n        b = ivec2(canvas.x, 0);\n    }\n    \n    // limit the looping, just in case there's an infinite loop bug XD\n    int levels = 5 * int(log2(float(max(canvas.x, canvas.y)))) + 1;\n    for(int i = 0; i < levels; i++) {\n        if (false && p == ivec2(3,1)) {\n            return 2.;\n            start_ix = int(canvas_size);\n        }\n        \n        da = sign(a);\n        db = sign(b);\n\n        wh = abs(ivec2(vsum(a), vsum(b)));\n\n        if (wh.y <= 1) {\n            for (int i = 0; i < wh.x; i++) {\n                if (pos == p) {\n                    return float(start_ix) / canvas_size;\n                }\n                p += da;\n                start_ix += 1;\n                //return float(start_ix + abs(vsum(pos - p))) / canvas_size;\n            }\n            return -1.;\n        }\n\n        if (wh.x <= 1) {\n            for (int j = 0; j < wh.y; j++) {\n                if (pos == p) {\n                    return float(start_ix) / canvas_size;\n                }\n                p += db;\n                start_ix += 1;\n                //return float(start_ix + abs(vsum(pos - p))) / canvas_size;\n            }\n            return -1.;\n        }\n\n        a2 = a/2;\n        b2 = b/2;\n\n        wh2 = abs(ivec2(vsum(a2), vsum(b2)));\n\n        if (3*wh.y < 2*wh.x) {\n            if (((wh2.x & 1) != 0) && (wh.x > 2)) {\n                ivec2 q = sign(p + wh2 - canvas/2);\n                a2 += abs(da)*q;\n            }\n\n            // long case: split in two parts only\n            if (in_region(pos, p, p + a2 + b)) {\n                a = a2;\n            } else {\n                start_ix += abs(wh.y) * abs((a2.x + a2.y));\n                //start_ix += 1;\n                p += a2;\n                a -= a2;\n            }\n        } else {\n            if (((wh2.y & 1) != 0) && (wh.y > 2)) {\n                //ivec2 q = sign(p + wh2 - canvas/2);\n                //b2 += abs(db)*q;\n                b2 += db;\n            }\n\n            // standard case: one step up, one long horizontal, one step down\n            if (in_region(pos, p, p + a2 + b2)) {\n                //return 2.;\n                a = b2;\n                b = a2;\n            } else if (in_region(pos, p + b2, p + a + b)) {\n                start_ix += abs(vmul(a2 + b2));\n                //start_ix += 1;\n                p += b2;\n                b -= b2;\n            } else {\n                start_ix += abs(vmul(a2 + b2)) + abs(vmul(a + b - b2));\n                //start_ix += 1;\n                p += a - da + b2 - db;\n                b = a2 - a;\n                a = -b2;\n            }\n        }\n    }\n    \n    return -1.;\n}\n\n// color formula taken from: https://iquilezles.org/articles/palettes/\nvec3 color(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.30, 0.20, 0.20);\n    return a + b*cos( 6.283185*(c*t + d) );\n}\n\nfloat positiveSigmoid(float x) {\n    return 2. / (1. + exp(-x*3.)) - 1.;\n}\n\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 d = pa - ba*h;\n    return vec2(dot(d,d), h);\n}\n\nvec2 computeDistance(vec2 dist, ivec2 icanvas, ivec2 ipos, float index, float qindex, vec2 pos, ivec2 delta) {\n\n    float di = 1. / float(icanvas.x * icanvas.y);\n\n    ivec2 qpos = ipos + delta;\n    if (any(lessThan(qpos, ivec2(0))) || any(lessThanEqual(icanvas, qpos))) {\n        return dist;\n    }\n\n    if (abs(index - qindex) < .2*di || 1.8*di < abs(index - qindex)) {\n        return dist;\n    }\n    \n    vec2 newDist = sdSqLine(pos, vec2(ipos), vec2(qpos));\n    newDist.y = index + newDist.y * (qindex - index);\n    if (dist.x <= newDist.x) {\n        return dist;\n    } else {\n        return newDist;\n    }\n}\n\nfloat computeIndex(ivec2 icanvas, ivec2 ipos, ivec2 delta) {\n\n    ivec2 qpos = ipos + delta;\n    if (any(lessThan(qpos, ivec2(0))) || any(lessThanEqual(icanvas, qpos))) {\n        return -1.;\n    }\n\n    return GilbertIndex(icanvas, qpos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 xy = iResolution.xy;\n    float t = iTime;\n    \n    #ifdef STEPPED\n    int level = 1 + int(LIMIT * positiveSigmoid(fract(t * SPEED / 100.)));\n    //level = 2;\n    float scale = level >= int(LIMIT) ? pow(2., LIMIT) : float(1u << level);\n    #else\n    float level = 1. + LIMIT * positiveSigmoid(fract(t * SPEED / 200.));\n    //level = 4.6;\n    float scale = level >= LIMIT ? pow(2., LIMIT) : pow(2., level);\n    #endif\n    \n    // center the curve, since lower resolutions might not align with the screen\n    vec2 canvas = iResolution.xy / iResolution.y * scale;\n    vec2 pos = uv * scale;\n    pos -= fract(canvas)/2.;\n    ivec2 icanvas = ivec2(canvas);\n    ivec2 ipos = ivec2(pos);\n    \n    vec3 c = vec3(0., 8., 10.)/255.;\n    \n    // only display the curve in the integer canvas area\n    if (all(lessThanEqual(vec2(0.), pos)) && all(lessThan(ipos, icanvas))) {\n        \n        //float index = GilbertIndex(icanvas, ipos);\n        //if (0. <= index) {\n        //    //index += t * COLOR_SPEED / 100.;\n        //    //index = fract(index + .5) -.5;\n        //    //index = exp(-(10000. * index * index));\n        //    //c = vec3(index);\n        //    c = color(index * COLOR_CYCLES);\n        //}\n        \n        //c = vec3(.4, .6, 0.);\n        //c = vec3(length(pos - vec2(ipos)));\n        \n        mat3 indecies;\n        int rad = 1;\n        for (int i = -rad; i <= rad; i++) {\n            for (int j = -rad; j <= rad; j++) {\n                indecies[rad + i][rad + j] = computeIndex(icanvas, ipos, ivec2(i, j));\n            }\n        }\n        \n        pos -= .5;\n        vec2 dist = vec2(2., 2.);\n        for (int i = -rad; i <= rad; i++) {\n            for (int j = -rad; j <= rad; j++) {\n                dist = computeDistance(dist, icanvas, ipos, indecies[rad][rad], indecies[rad + i][rad + j], pos, ivec2(i, j));\n            }\n        }\n        \n        for (int i = -rad; i <= rad; i += 2) {\n            for (int j = -rad; j <= rad; j += 2) {\n                dist = computeDistance(dist, icanvas, ipos + ivec2(i, 0), indecies[rad + i][rad], indecies[rad][rad + j], pos, ivec2(-i, j));\n            }\n        }\n\n        float d = sqrt(dist.x);\n        \n        float e = scale/iResolution.y; // size of a pixel\n        //float f = 1. - step(.2, dist);\n        //float f = 1. - smoothstep(LINE_WIDTH,LINE_WIDTH + LINE_FADE,dist);\n        float f = 1. - smoothstep(0., LINE_WIDTH*e, d);\n        //f = exp((f - 1.) * 8.);\n        f *= 0.8 + 0.2*sqrt(clamp(d*8./e, 0.0, 1.0));\n        //c = f*color(smoothstep(0., .3, dist) / 4.);\n        c *= 1. - f;\n        c += f*color((dist.y + t*COLOR_SPEED/100.) * COLOR_CYCLES);\n        \n    }\n    \n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfVBRW","date":"1734139765","viewed":24,"name":"Gilbert Curve Demo 2","username":"notscared","description":"a demo of the gilbert curve -- the arbitrary rectangle variant of the hilbert curve as detailed on https://github.com/jakubcerveny/gilbert\n\ni based this shader on https://www.shadertoy.com/view/XtGBDW, initially","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","hilbert","short","hilbertcurve","gilbert","gilbertcurve"],"hasliked":0,"parentid":"lccfDs","parentname":"Gilbert Curve Demo"}}