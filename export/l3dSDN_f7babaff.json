{"ver":"0.1","info":{"id":"l3dSDN","date":"1719083968","viewed":153,"name":"020.3 - Cafe Floor 4x Sampling","username":"PiGIon","description":"This is the iteration 3. Check my study of the problem here:\nhttps://www.shadertoy.com/view/lX3XW8\n\nI discovered I can solve the issue by using super sampling, and as bonus, get some free antialiasing, this version is way better on the corners.","likes":8,"published":3,"flags":0,"usePreview":0,"tags":["sdf","supersampling","antialias","pattern","floor","beautiful"],"hasliked":0,"parentid":"l3cSz8","parentname":"020.1 - Cafe floor pattern"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024.06.16 rev 1\n// 2024.06.18 rev 2 fix tearing and add final noise output\n// 2024.06.18 rev 3 fix a bug related to tearing when iTime variable is too large\n// 2024.06.22 rev 4 see https://www.shadertoy.com/view/lXcXWN use texture instead of uv space rotation to avoid float precision errors\n// 2024.06.22 rev 5 see https://www.shadertoy.com/view/l3dSDN use supersampling to avoid imprecision patterns\n\n#define DEBUG 0\n#define AA 1\n#define NOISE 1\n#define SAMPLES 4\n#define time fract((iTime+iTimeDelta)/100.)\n\n// https://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define PI2 6.2831853071795864769252867665590057683943387987502116419498891846156328\n\n// Returns a range of vec2(-1) to vec2(1) based on mouse and screen size\n// Deals with first frame and returns vec2(0) if so\nvec2 uvMouse() {\n    if (length(iMouse.xy) == 0.) {\n        return vec2(0, 0);\n    }\n    return ((iMouse.xy / iResolution.xy) - 0.5) * 2.;\n}\n\n// From https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nmat2 rotateMat(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m;\n}\n\nvec2 rotate(vec2 v, float a) {\n\treturn rotateMat(v, a) * v;\n}\n\n// From https://gist.github.com/tylerdurrett/d492d8aa08f4c3968602a14a4cbe44c9\nmat2 skewUV(vec2 s) {\n    return mat2(1., tan(s.x),\n                tan(s.y), 1.);\n}\n\nfloat antiAlias = 1.5;\nfloat stepaa(float x, float y) {\n    #if AA\n    float w = antiAlias;\n    return smoothstep(x - w, x + w, y);\n    #endif\n    return step(x, y);\n}\n\n// (v.x, v.y) -> (v.y, v.x)\nvec2 swap(vec2 v) {\n    return vec2(v.y, v.x);\n}\n\n// Returns -size to size cycle\nfloat rangeCycle(float size, float perSec) {\n    return mod(iTime*perSec - size, size) - .5*size;\n}\n\n// Returns alpha value of a circle with antiAlias\nfloat circle(vec2 uv, vec2 origin, float size) {\n    return stepaa(length(uv - origin), size+antiAlias);\n}\n\n// Returns alpha value of a square with antiAlias\nfloat square(vec2 uv, vec2 origin, vec2 size) {\n    vec2 o = abs(uv - origin);\n    size += antiAlias;\n    return stepaa(o.x, size.x) * stepaa(o.y, size.y);\n}\n\n// Returns alpha value of a paralelogram with antiAlias\nfloat paralelogram(vec2 uv, vec2 origin, vec2 size, vec2 skew) {\n    vec2 o = uv - origin;\n    mat2 s = skewUV(skew);\n    o *= s;\n    size *= s;\n    float leftEdge = stepaa(o.x, size.x);\n    float rightEdge = stepaa(-o.x, size.x);\n    float topEdge = stepaa(o.y, size.y);\n    float bottomEdge = stepaa(-o.y, size.y);\n    return leftEdge * rightEdge * topEdge * bottomEdge;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = uvMouse();\n    antiAlias = (antiAlias + ((mouse.x + 1.) * 5.))/iResolution.y;\n    antiAlias /= float(SAMPLES);\n#if !AA\n    antiAlias *= 0.;\n#endif\n\n    vec3 finalColor = vec3(0, 0, 0);\n    vec3 color = vec3(1.);\n\n    for (int i = 0; i < SAMPLES; i++) {\n        // Generates an uv that is the divided by sample amount\n        vec2 off = vec2(float(i % 2) * .5 - .25, float(i / 2) * .5 - .25);\n        vec2 uv = (fragCoord + off) / iResolution.xy;\n        \n        // Normalize to [-1, 1] rotate and scale\n        // This enables zoom from the center\n        uv = uv * 2.0 - 1.0;\n        uv.x *= iResolution.x/iResolution.y;\n        uv = rotateMat(uv, PI2*time) * (2. * (mouse.x + 1.)) * uv;\n        // Go back to 0.0 to 1.0 coordinate\n        uv = uv * 0.5 + 0.5;\n\n        // 2 | 3\n        // - | -\n        // 0 | 1\n        float index = 0.0;\n        index += step(1., mod(uv.x, 2.));\n        index += step(1., mod(uv.y, 2.)) * 2.;\n        if (index == 1.) {\n            uv = rotate(uv, 0.5 * PI);\n        } else if (index == 2.) {\n            uv = rotate(uv, -0.5 * PI);\n        } else if (index == 0.) {\n            uv = rotate(uv, -PI);\n        }\n        uv = (fract(uv) - 0.5) * 2.;\n\n        // Colors\n        float noise = noise2D(uv * 200.) * 0.1; \n    #if !NOISE\n        noise = 0.;\n    #endif\n        vec3 white = mix(vec3(0.93), vec3(0.031), noise);\n        vec3 black = mix(vec3(0.02), vec3(0.98), noise);\n        vec3 grey = mix(vec3(0.51f, 0.47f, 0.44f), vec3(0.0444), noise);\n    #if !DEBUG\n        color = grey * 0.65;\n    #endif\n\n        // Size for circles\n        float s1 = 0.61;\n    #if DEBUG\n        s1 += abs(sin(iTime)) / 75.;\n    #endif\n        float s2 = s1 * 0.75;\n        // Size for grey background square\n        float thick = (s1 - s2);\n\n        // White background\n        color = mix(color, white, square(uv, vec2(0), vec2(1.)));\n\n        // Bottom left background square\n        color = mix(color, grey, square(uv, vec2(-thick/2.), vec2(1. - thick/2.)));\n\n        // Corners black semicircles\n        vec2 cbq = vec2(s2 * 0.65);\n        color = mix(color, black, square(uv, vec2(-1. + cbq.x, 1. - cbq.y), cbq));\n        color = mix(color, black, square(uv, vec2(1. - cbq.x, -1. + cbq.y), cbq));\n\n        // Corners pattern circles\n        vec2 cpc1 = vec2(-1. + s1, 1. - s1);\n        vec2 cpc2 = vec2(1. - s1, -1. + s1);\n        color = mix(color, white, circle(uv, cpc1, s1));\n        color = mix(color, white, circle(uv, cpc2, s1));\n\n        // Squares to mask circles\n        vec2 maskSize = vec2(1. - thick - s2/2., s2 * 0.7);\n        vec2 maskCoord = 1. - thick - maskSize;\n        color = mix(color, grey, square(uv, maskCoord, maskSize));\n        color = mix(color, grey, square(uv, swap(maskCoord), swap(maskSize)));\n\n        // Corners small circles\n        vec2 csc1 = vec2(-1. + s1, 1. - s1);\n        vec2 csc2 = vec2(1. - s1, -1. + s1);\n        color = mix(color, grey, circle(uv, csc1, s2));\n        color = mix(color, grey, circle(uv, csc2, s2));\n\n        // Small white square to mask circle discontinuity\n        vec2 cdist = cpc2 - cpc1;\n        vec2 sqp = (cpc1 + normalize(cdist) * length(cdist)/2.) + s2/3.;\n        color = mix(color, white, square(uv, sqp, vec2(thick)));\n\n        // Center leafs\n        float l1 = s2 * 0.4;\n        float l2 = l1 * 0.80;\n        float ang = radians(105.);\n        color = mix(color, white, circle(uv, csc1 + vec2(sin(ang), cos(ang))*s2, l2));\n        color = mix(color, white, circle(uv, csc2 + vec2(cos(ang), sin(ang))*s2, l2));\n        color = mix(color, white, circle(uv, sqp + thick, l1));\n\n        // Bottom left leafs\n        vec2 sbl = vec2(1.-(s1), (1. - s1)/2.);\n        float slbang = radians(45.);\n        color = mix(color, white, paralelogram(uv, vec2(-1.) + sbl, sbl, vec2(-slbang, 0.)));\n        color = mix(color, black, paralelogram(uv, vec2(-1.) + swap(sbl), swap(sbl), vec2(0., -slbang)));\n        \n        finalColor += color;\n    }\n\n    fragColor = vec4(finalColor/float(SAMPLES), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nfloat hash(float x)\n{\n    uint state = floatBitsToUint(x) * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    uint hashed_value = (word >> 22u) ^ word;\n    return float(hashed_value) / 4294967295.0; // 4294967295 is 2^32 - 1\n}\n\n// from https://www.shadertoy.com/view/4dS3Wd\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise2D(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n","name":"Common","description":"","type":"common"}]}