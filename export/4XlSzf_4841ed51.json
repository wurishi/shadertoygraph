{"ver":"0.1","info":{"id":"4XlSzf","date":"1709786113","viewed":103,"name":"SDF Primitives with Materials","username":"Nikio","description":"Each primitive returns a vec4, where the first field is the distance, the second and third fields are the UV coordinates, and the fourth field is the material index. I used these to design simple scenes for my game and they're very easy to use.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","primitive"],"hasliked":0,"parentid":"XfsGWH","parentname":"sdft primitives"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//===========================================================================================================//\n//\n// SDFT CHANNELS:\n// X -- dist\n// Y -- tex coord U\n// Z -- tex coord V\n// W -- sampler index\n//\n// SHAPES CHECKLIST:\n// - sphere       | ✓\n// - box          | ✓\n// - rounded box  | ✓\n// - sliced box   | ✓\n// - slanted box  | ✓\n// - torus        | ✓\n// - cone         | ✓\n// - plane        | ✓\n// - n-prism      | ✓\n// - capsule      | ✓\n// - cylinder     | ✓\n// - ellipsoid    | ✓\n//\n// OPERATIONS CHECKLIST:\n// - union        | ✓\n// - diff         | ✓\n// - sect         | ✓\n// - translation  | ✓\n// - rotation     | ✓\n// - scale        | ✓\n// - xor          | ✓\n// - smooth union |\n// - smooth diff  |\n// - smooth sect  |\n// - revolution   |\n// - extrusion    |\n// - elongation   |\n// - rounding     | ✓\n// - onioning     |\n// - basis change |\n// - symmetry     |\n// - grid tiling  |\n// - displacement | ✓\n// - twist        |\n// - bend         |\n//\n// UV PROJECTIONS CHECKLIST:\n// - sphere proj  | ✓\n// - cylinder proj| ✓\n// - cube proj    | ✓\n// - x-planar     | ✓\n// - y-planar     | ✓\n// - z-planar     | ✓\n// - tri-planar   | ✓\n// - planar       | ✓\n// - view proj    | ✓\n//\n// TODO:\n// - UV scaling parameters\n//\n//===========================================================================================================//\n\nconst int STEPS_LIMIT  = 320;\nconst float EYE_RADIUS = 0.0;\nconst float EYE_LIMIT  = 32.0;\nconst float EPSILON    = 0.0001;\nconst float PI         = 3.14159265;\nconst float DELTA      = 0.01;\nconst vec3 ZERO        = vec3(0.0,0.0,0.0);\nconst float TWO_PI     = 6.28318530;\nconst float ROCK       = 0.0;\nconst float DIRT       = 1.0;\nconst float SDF_CLEAR  = 999.0;\nconst vec4 SDFT_CLEAR  = vec4(999.0,0.0,0.0,0.0);\nconst int NUM_INSTANCES = 5;\nint Instance;\n\n// UTIL //\nfloat nearest(float a,float b,float t){\n    float da=abs(a-t);\n    float db=abs(b-t);\n    return (da<=db)?a:b;}\nfloat snap(float a,float b,float t){\n    float n=nearest(a,b,t);\n    if(n==a){return 0.0;}else{return 1.0;}}\nfloat vecAngle(vec2 Vec){\n\tVec = normalize(Vec);\n\tif(Vec.y>0.0){return acos(Vec.x);}else{return -acos(Vec.x);}}\nvec2 angleVec(float Angle){\n    return vec2(cos(Angle),sin(Angle));}\nfloat flat_step(float edge0,float edge1,float x){\n    return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}\nvec4 displayDist(float Dist,float Edge0,float Edge1){\n    Dist = flat_step(Edge0,Edge1,Dist);\n    return vec4(Dist,Dist,Dist,1.0);}\nvec4 displaySDF(float Dist,float Edge0,float Edge1){\n    Dist = flat_step(Edge0,Edge1,Dist);\n    vec4 Pos = vec4(0.0,0.0,1.0,1.0);\n    vec4 Neg = vec4(1.0,0.0,0.0,1.0);\n    vec4 Zer = vec4(0.0,0.0,0.0,1.0);\n    if(Dist>0.0) {\n        return mix(Zer,Pos,Dist);\n    }else{\n        return mix(Zer,Neg,-Dist);\n    }}\nvec3 tonemap(vec3 c){\n    return pow(c,vec3(2.0));}\nmat4 translate(vec3 Offset){\n\treturn mat4(\n\t\t1,0,0,0,\n\t\t0,1,0,0,\n\t\t0,0,1,0,\n\t\tOffset,1);}\nmat4 scale(vec3 Ratio){\n\treturn mat4(\n\t\t1.0/Ratio.x,0,0,0,\n\t\t0,1.0/Ratio.y,0,0,\n\t\t0,0,1.0/Ratio.z,0,\n\t\t0,0,0,1);}\nmat4 shear(float Angle){\n\treturn mat4(\n\t\t1,0,0,0,\n\t\ttan(Angle),1,0,0,\n\t\t0,0,1,0,\n\t\t0,0,0,1);}\nmat4 scaleP(vec3 Ratio,vec3 Point){\n\treturn mat4(\n\t\t1.0/Ratio.x,0,0,0,\n\t\t0,1.0/Ratio.y,0,0,\n\t\t0,0,1.0/Ratio.z,0,\n\t\tPoint.x*(1.0-1.0/Ratio.x),Point.y*(1.0-1.0/Ratio.y),Point.z*(1.0-1.0/Ratio.z),1);}\nmat4 rotateX(float A){\n\treturn mat4(\n\t\t1,0,0,0,\n\t\t0,cos(A),-sin(A),0,\n\t\t0,sin(A),cos(A),0,\n\t\t0,0,0,1);}\nmat4 rotateY(float A){\n\treturn mat4(\n\t\tcos(A),0,sin(A),0,\n\t\t0,1,0,0,\n\t\t-sin(A),0,cos(A),0,\n\t\t0,0,0,1);}\nmat4 rotateZ(float A){\n\treturn mat4(\n\t\tcos(A),-sin(A),0,0,\n\t\tsin(A),cos(A),0,0,\n\t\t0,0,1,0,\n\t\t0,0,0,1);}\nmat4 rotate(vec3 Center,float Ax,float Ay,float Az){\n\treturn translate(-Center)*rotateX(Ax)*rotateX(Ay)*rotateZ(Az)*translate(Center);}\n\n// SDF OPERATORS //\nfloat sectSDF(float SDFOne,float SDFTwo){return max(SDFOne,SDFTwo);}\nfloat unionSDF(float SDFOne,float SDFTwo){return min(SDFOne,SDFTwo);}\nfloat diffSDF(float SDFOne,float SDFTwo){return max(SDFOne,-SDFTwo);}\nfloat xorSDF(float SDFOne,float SDFTwo){return max(min(SDFOne,SDFTwo),-max(SDFOne,SDFTwo));}\nfloat roundSDF(float Dist,float Radius){return Dist-Radius;}\nfloat displaceSDF(float Dist,float W,vec2 UV,float Ratio){\n    float Height;\n    float Height0 = texture(iChannel2, UV).x;\n    float Height1 = texture(iChannel3, UV * 0.25).x;\n    Height = mix(Height0,Height1,W);\n    return Dist-Height*Ratio;\n}\nfloat extrudeZSDF(float Dist,vec3 SamplePoint,float Height){\n    vec2 Q = vec2(Dist,abs(SamplePoint.z)-Height);\n    return min(max(Q.x,Q.y),0.0)+length(max(Q,0.0));}\nfloat extrudeYSDF(float Dist,vec3 SamplePoint,float Height){\n    vec2 Q = vec2(Dist,abs(SamplePoint.y)-Height);\n    return min(max(Q.x,Q.y),0.0)+length(max(Q,0.0));}\nfloat extrudeSDF(float Dist,vec3 SamplePoint,vec3 Axis,float Height){\n    vec2 Q = vec2(Dist,abs(dot(SamplePoint,Axis))-Height);\n    vec3 Normal=cross(SamplePoint,Axis);\n    vec3 Binormal=cross(Axis,Normal);\n    return min(max(length(Normal),length(Binormal)),0.0)+length(max(Q,0.0));}\nfloat blendSDF(float SDFOne,float SDFTwo,float Ratio){return mix(SDFOne,SDFTwo,Ratio);}\n\n// SDFT OPERATORS //\nvec4 sectSDFT(vec4 SDFTOne,vec4 SDFTTwo){\n    float SDF = sectSDF(SDFTOne.x,SDFTTwo.x);\n    float Mask = 0.5*(sign(SDFTOne.x-SDFTTwo.x)+1.0);\n    vec2 UV = mix(SDFTTwo.yz,SDFTOne.yz,Mask);\n    float SampI = mix(SDFTTwo.w,SDFTOne.w,Mask);\n    return vec4(SDF,UV,SampI);}\nvec4 unionSDFT(vec4 SDFTOne,vec4 SDFTTwo){\n    float SDF = unionSDF(SDFTOne.x,SDFTTwo.x);\n    float Mask = 0.5*(sign(SDFTOne.x-SDFTTwo.x)+1.0);\n    vec2 UV = mix(SDFTOne.yz,SDFTTwo.yz,Mask);\n    float SampI = mix(SDFTOne.w,SDFTTwo.w,Mask);\n    return vec4(SDF,UV,SampI);}\nvec4 diffSDFT(vec4 SDFTOne,vec4 SDFTTwo){\n    float SDF = diffSDF(SDFTOne.x,SDFTTwo.x);\n    float Mask = 0.5*(sign(SDFTOne.x+SDFTTwo.x)+1.0);\n    vec2 UV = mix(SDFTTwo.yz,SDFTOne.yz,Mask);\n    float SampI = mix(SDFTTwo.w,SDFTOne.w,Mask);\n    return vec4(SDF,UV,SampI);}\nvec4 xorSDFT(vec4 SDFTOne,vec4 SDFTTwo){\n    float SDF = xorSDF(SDFTOne.x,SDFTTwo.x);\n    float Mask = 0.5*(sign(SDFTOne.x+SDFTTwo.x)+1.0);\n    vec2 UV = mix(SDFTTwo.yz,SDFTOne.yz,Mask);\n    float SampI = mix(SDFTTwo.w,SDFTOne.w,Mask);\n    return vec4(SDF,UV,SampI);}\nvec4 roundSDFT(vec4 SDFT,float Radius){\n    return vec4(roundSDF(SDFT.x,Radius),SDFT.yzw);}\nvec4 displaceSDFT(vec4 SDFT,float Ratio){\n    return vec4(displaceSDF(SDFT.x,SDFT.w,SDFT.yz,Ratio),SDFT.yzw);}\nvec4 blendSDFT(vec4 SDFTOne,vec4 SDFTTwo,float Ratio){\n    float B1 = 0.333;\n    float B2 = 0.666;\n    float MinD = -0.5;\n    float MaxD = 1.5;\n    float D1 = SDFTOne.x;\n    float D2 = SDFTTwo.x;\n    float Delta = Ratio-D1;\n    float Mask = 1.0-clamp(Delta/Ratio,0.0,1.0);\n    Mask = flat_step(MinD,MaxD,Delta);\n    Mask = snap(0.0,1.0,Mask);\n    //float Mask1 = sign(B1-(SDFTOne.x,SDFTTwo.x));\n    //return vec4(mix(SDFTOne.xyz,SDFTTwo.xyz,Ratio),SampI);\n    return vec4(mix(SDFTOne.xyz,SDFTTwo.xyz,Ratio),mix(SDFTOne.w,SDFTTwo.w,Mask));}\n\n// UV UNWRAPPING //\nvec2 sphereUV(vec3 SamplePoint){\n    return vec2(vecAngle(SamplePoint.xz)/TWO_PI,SamplePoint.y-0.5);}\nvec2 boxUV(vec3 SamplePoint,vec3 Center,vec3 Dim){\n    vec2 BaseUV = (SamplePoint.xz/Dim.xz)/2.0-vec2(0.5,0.5);\n    float Diam = length(vec2(Dim.xz));\n    vec2 SideUV = vec2(SamplePoint.x+SamplePoint.z,SamplePoint.y-0.5);\n    float SideMask = 0.5*(sign(SamplePoint.x-SamplePoint.z)+1.0);\n    SideUV.x = mix(SideUV.x,-SideUV.x,SideMask);\n    float Region = 0.5*(sign((Dim.y-DELTA)-abs(SamplePoint.y))+1.0);\n    return mix(BaseUV,SideUV,Region);}\nvec2 cylinderUV(vec3 SamplePoint,vec3 Center,float Height,float Radius){\n    float Circ = TWO_PI*Radius;\n    float Ratio = Circ/Height;\n    vec2 BaseUV = ((SamplePoint.xz)*0.5/Radius)-vec2(0.5,0.5);\n    vec2 SurfaceUV = vec2(vecAngle(SamplePoint.xz)/TWO_PI,\n                          0.5*(SamplePoint.y/Height)/Ratio-0.5);\n    float Region = 0.5*(sign((Height-DELTA)-SamplePoint.y)+1.0);\n    return mix(BaseUV,SurfaceUV,Region);}\nvec2 xUV(vec3 SamplePoint,float Scale){\n    return SamplePoint.yz/Scale;}\nvec2 yUV(vec3 SamplePoint,float Scale){\n    return SamplePoint.xz/Scale;}\nvec2 zUV(vec3 SamplePoint,float Scale){\n    return SamplePoint.xy/Scale;}\nvec2 triPlaneUV(vec3 SamplePoint,float Scale){\n    vec2 X = xUV(SamplePoint,Scale);\n    vec2 Y = yUV(SamplePoint,Scale);\n    vec2 Z = zUV(SamplePoint,Scale);\n    vec3 Mask = vec3(abs(dot(SamplePoint,vec3(1,0,0))),\n                     abs(dot(SamplePoint,vec3(0,1,0))),\n                     abs(dot(SamplePoint,vec3(0,0,1))));\n    float Max = max(max(Mask.x,Mask.y),Mask.z);\n    Mask = (vec3(sign(Mask.x-Max),sign(Mask.y-Max),sign(Mask.z-Max))+vec3(1.0,1.0,1.0));\n    return X*Mask.x+Y*Mask.y+Z*Mask.z;\n}\nvec2 normalTriPlaneUV(vec3 SamplePoint,vec3 Normal,float Scale){\n    vec2 X = xUV(SamplePoint,Scale);\n    vec2 Y = yUV(SamplePoint,Scale);\n    vec2 Z = zUV(SamplePoint,Scale);\n    vec3 Mask = vec3(abs(dot(Normal,vec3(1,0,0))),\n                     abs(dot(Normal,vec3(0,1,0))),\n                     abs(dot(Normal,vec3(0,0,1))));\n    float Max = max(max(Mask.x,Mask.y),Mask.z);\n    Mask = (vec3(sign(Mask.x-Max),sign(Mask.y-Max),sign(Mask.z-Max))+vec3(1.0,1.0,1.0));\n    return X*Mask.x+Y*Mask.y+Z*Mask.z;\n}\nvec2 planeUV(vec3 SamplePoint,vec3 AxU,vec3 AxV,float Scale){\n    return vec2(dot(SamplePoint,AxU)/Scale,dot(SamplePoint,AxV)/Scale);}\nvec2 viewUV(vec2 FragCoord){\n    return (FragCoord/iResolution.xy)*vec2(iResolution.x/iResolution.y,1.0);}\n\n// SDF PRIMITIVES //\nfloat sphereSDF(vec3 SamplePoint,vec3 Center,float Radius){\n    return length(Center-SamplePoint)-Radius;}\nfloat capsuleSDF(vec3 SamplePoint,vec3 Center,float Radius,float Length){\n    SamplePoint.y = sign(SamplePoint.y)*clamp(abs(SamplePoint.y)-Length,0.0,1.0);\n    return length(Center-SamplePoint)-Radius;}\nfloat boxSDF(vec3 SamplePoint,vec3 Center,vec3 Dim){\n    vec3 Dist = abs(SamplePoint-Center)-Dim;\n    return length(max(Dist,0.0));}\nfloat slicedBoxSDF(vec3 SamplePoint,vec3 Center,vec3 Dim,vec3 Normal,float Height){\n    vec3 Dist = abs(SamplePoint-Center)-Dim;\n    return max(dot(SamplePoint,normalize(Normal))-Height,length(max(Dist,0.0)));}\nfloat slantedBoxSDF(vec3 SamplePoint,vec3 Center,vec3 Dim,float Slant){\n    vec3 Offset = abs(SamplePoint-Center)-Dim;\n    vec3 Normal = normalize(vec3(sin(Slant),cos(Slant),0));\n    return max(dot(SamplePoint-Center+vec3(Dim.x,-Dim.y,0),Normal),length(max(Offset,0.0)));}\nfloat doublySlantedBoxSDF(vec3 SamplePoint,vec3 Center,vec3 Dim,float Slant){\n    vec3 Offset = abs(SamplePoint-Center)-Dim;\n    vec3 Normal1 = normalize(vec3(sin(Slant),cos(Slant),0));\n    vec3 Normal2 = normalize(vec3(sin(Slant),-cos(Slant),0));\n    return max(dot(SamplePoint-Center+vec3(Dim.x,-Dim.y,0),Normal1),\n               max(dot(SamplePoint-Center+vec3(Dim.x,Dim.y,0),Normal2),\n                   length(max(Offset,0.0))));}\nfloat roundedBoxSDF(vec3 SamplePoint,vec3 Center,vec3 Dim,float Rounding){\n    vec3 Dist = abs(SamplePoint-Center)-(Dim-vec3(Rounding));\n    return length(max(Dist,0.0))-Rounding;}\nfloat torusSDF(vec3 SamplePoint,vec2 Dim) {\n    vec2 Dist = vec2(length(SamplePoint.xz)-Dim.x,SamplePoint.y);\n    return length(Dist)-Dim.y;}\nfloat planeSDF(vec3 SamplePoint,vec3 Center,vec3 Normal,float Height){\n    return length(Center)+dot(SamplePoint,normalize(Normal))+Height;}\nfloat cylinderSDF(vec3 SamplePoint,vec3 Center,float Height,float Radius) {\n    vec2 Dist = abs(vec2(length(SamplePoint.xz),SamplePoint.y))-vec2(Radius,Height);\n    return min(max(Dist.x,Dist.y),0.0)+length(max(Dist,0.0));}\nfloat coneSDF(vec3 SamplePoint,vec2 Dim,float Height){\n    float HDist = length(SamplePoint.xz);\n    return max(dot(Dim.xy,vec2(HDist,SamplePoint.y)),-Height-SamplePoint.y);}\nfloat circleSDF(vec2 SamplePoint,vec2 Center,float Radius){\n    return length(SamplePoint-Center)-Radius;}\nfloat roundedBoxSDF(vec2 SamplePoint,vec2 Dim,vec4 Rounding){\n    Rounding.xy = (SamplePoint.x>0.0)?Rounding.xy:Rounding.zw;\n    Rounding.x  = (SamplePoint.y>0.0)?Rounding.x:Rounding.y;\n    vec2 Q = abs(SamplePoint)-Dim+Rounding.x;\n    return min(max(Q.x,Q.y),0.0)+length(max(Q,0.0))-Rounding.x;}\nfloat prismSDF(vec3 SamplePoint,vec3 Center,float Radius,float Height,int Order){\n    float Dist = SDF_CLEAR;\n    for(int n = 0;n<Order;n+=1){\n        float Angle = float(n)/float(Order)*TWO_PI;\n        vec3 Offset = vec3(angleVec(Angle),0.0);\n        Dist=unionSDF(Dist,planeSDF(SamplePoint,Center,Offset,Radius));\n    }\n    Dist = -Dist;\n    Dist = diffSDF(Dist,planeSDF(SamplePoint,Center,vec3(0.0,0.0,1.0),Height));\n    Dist = diffSDF(Dist,planeSDF(SamplePoint,Center,vec3(0.0,0.0,-1.0),Height));\n    return Dist;}\nfloat ellipsoidSDF(vec3 SamplePoint,vec3 Radius){\n    float Q = length(SamplePoint/Radius);\n    float Q2 = length(SamplePoint/(Radius*Radius));\n    return (Q*Q-Q)/Q2;}\n\n// SDFT PRIMITIVES //\nvec4 genericSDFT(vec3 SamplePoint,float Dist,float SampI){\n    return vec4(Dist,sphereUV(SamplePoint),SampI);}\nvec4 sphereSDFT(vec3 SamplePoint,vec3 Center,float Radius,float SampI){\n    return vec4(sphereSDF(SamplePoint,Center,Radius),sphereUV(SamplePoint),SampI);}\nvec4 capsuleSDFT(vec3 SamplePoint,vec3 Center,float Radius,float Length,float SampI){\n    return vec4(capsuleSDF(SamplePoint,Center,Radius,Length),sphereUV(SamplePoint),SampI);}\nvec4 boxSDFT(vec3 SamplePoint,vec3 Center,vec3 Dim,float SampI){\n    return vec4(boxSDF(SamplePoint,Center,Dim),boxUV(SamplePoint,Center,Dim),SampI);}\nvec4 slicedBoxSDFT(vec3 SamplePoint,vec3 Center,vec3 Dim,vec3 Normal,float Height,float SampI){\n    return vec4(slicedBoxSDF(SamplePoint,Center,Dim,Normal,Height),boxUV(SamplePoint,Center,Dim),SampI);}\nvec4 slantedBoxSDFT(vec3 SamplePoint,vec3 Center,vec3 Dim,float Slant,float SampI){\n    return vec4(slantedBoxSDF(SamplePoint,Center,Dim,Slant),boxUV(SamplePoint,Center,Dim),SampI);}\nvec4 doublySlantedBoxSDFT(vec3 SamplePoint,vec3 Center,vec3 Dim,float Slant,float SampI){\n    return vec4(doublySlantedBoxSDF(SamplePoint,Center,Dim,Slant),boxUV(SamplePoint,Center,Dim),SampI);}\nvec4 roundedBoxSDFT(vec3 SamplePoint,vec3 Center,vec3 Dim,float Rounding,float SampI){\n    return vec4(roundedBoxSDF(SamplePoint,Center,Dim,Rounding),boxUV(SamplePoint,Center,Dim),SampI);}\nvec4 torusSDFT(vec3 SamplePoint,vec2 Dim,float SampI){\n    return vec4(torusSDF(SamplePoint,Dim),sphereUV(SamplePoint),SampI);}\nvec4 cylinderSDFT(vec3 SamplePoint,vec3 Center,float Height,float Radius,float SampI){\n    float SDF = cylinderSDF(SamplePoint,Center,Height,Radius);\n    float Circ = TWO_PI*Radius;\n    float Ratio = Circ/Height;\n    vec2 BaseUV = ((SamplePoint.xz)*0.5/Radius)-vec2(0.5,0.5);\n    vec2 SurfaceUV = vec2(vecAngle(SamplePoint.xz)/TWO_PI,\n                          0.5*(SamplePoint.y/Height)/Ratio-0.5);\n    float Region = 0.5*(sign((Height-DELTA)-SamplePoint.y)+1.0);\n    vec2 UV = mix(BaseUV,SurfaceUV,Region);\n    return vec4(SDF,UV,SampI);}\nvec4 planeSDFT(vec3 SamplePoint,vec3 Center,vec3 Normal,float Height,float Scale,float SampI){\n    return vec4(planeSDF(SamplePoint,Center,Normal,Height),yUV(SamplePoint,Scale),SampI);}\nvec4 coneSDFT(vec3 SamplePoint,vec2 Dim,float Height,float SampI){\n    return vec4(coneSDF(SamplePoint,Dim,Height),yUV(SamplePoint,1.0),SampI);}\nvec4 prismSDFT(vec3 SamplePoint,vec3 Center,float Radius,float Height,int Order,float SampI){\n    vec4 SDFT = SDFT_CLEAR;\n    for(int n = 0;n<Order;n+=1){\n        float Angle = float(n)/float(Order)*TWO_PI;\n        vec3 Offset = vec3(angleVec(Angle),0.0);\n        SDFT=unionSDFT(SDFT,planeSDFT(SamplePoint,Center,Offset,Radius,1.0,SampI));\n    }\n    SDFT.x = -SDFT.x;\n    SDFT = diffSDFT(SDFT,planeSDFT(SamplePoint,Center,vec3(0.0,0.0,1.0),Height,1.0,SampI));\n    SDFT = diffSDFT(SDFT,planeSDFT(SamplePoint,Center,vec3(0.0,0.0,-1.0),Height,1.0,SampI));\n    return SDFT;}\n\n// SCENE //\nvec4 sceneSDFT(vec3 SamplePoint) {\n    vec4 SDFT;\n    float SampI;\n    vec4 Point = vec4(SamplePoint.xyz,1);\n    float Ratio = 0.5*(sin(iTime*1.)+1.0);\n    if(Instance == 0) {\n        SDFT = vec4(sphereSDF(SamplePoint,ZERO,0.3),planeUV(SamplePoint,vec3(2,0.,1.),vec3(0.,1.,1.),8.0),ROCK);\n    } else if(Instance == 1) {\n        SDFT = vec4(sphereSDF(SamplePoint,ZERO,0.3),planeUV(SamplePoint,vec3(2,0.,1.),vec3(0.,1.,1.),8.0),ROCK);\n        SDFT = diffSDFT(prismSDFT(SamplePoint,ZERO,0.4,0.1,3+int(fract(iTime * 0.4)*6.0),DIRT),SDFT);\n    } else if(Instance == 2) {\n        SDFT = slicedBoxSDFT(SamplePoint,ZERO,vec3(0.2,0.2,0.3),normalize(vec3(sin(iTime),cos(iTime),0)),0.0,ROCK);\n    } else if(Instance == 3) {\n        SDFT = planeSDFT(SamplePoint,ZERO,vec3(0.0,1.0,0.0),0.45,1.0,DIRT);\n        SDFT = unionSDFT(SDFT,coneSDFT(Point.xyz,vec2(0.1,0.1),0.4,ROCK));\n    } else if(Instance == 4) {\n        SDFT = planeSDFT(SamplePoint,ZERO,vec3(0.0,1.0,0.0),0.45,1.0,DIRT);\n        SDFT = blendSDFT(SDFT,capsuleSDFT(SamplePoint, ZERO, 0.25, 0.25, ROCK),Ratio);\n    }\n    SDFT = displaceSDFT(SDFT,0.05);\n    return SDFT;}\n\n// RAY //\nvec4 castRay(vec3 RayOrigin,vec3 RayDir,float EyeRadius,float EyeLimit){\n    float Length = EyeRadius;\n    for(int Step = 0;Step<STEPS_LIMIT;Step++){\n        vec4 SDFT = sceneSDFT(RayOrigin+Length*RayDir);\n        if(SDFT.x<EPSILON){\n\t\t\treturn vec4(Length,SDFT.yzw);\n        }\n        Length += SDFT.x;\n        if(Length>=EyeLimit){\n            return vec4(EyeLimit,0,0,0);\n        }\n    }\n    return vec4(EyeLimit,0,0,0);}\n\n// LIGHTING //\nvec3 estimateNormal(vec3 Point){\n    return normalize(vec3(\n        sceneSDFT(vec3(Point.x+EPSILON,Point.yz)).x-sceneSDFT(vec3(Point.x-EPSILON,Point.yz)).x,\n        sceneSDFT(vec3(Point.x,Point.y+EPSILON,Point.z)).x-sceneSDFT(vec3(Point.x,Point.y-EPSILON,Point.z)).x,\n        sceneSDFT(vec3(Point.xy,Point.z+EPSILON)).x-sceneSDFT(vec3(Point.xy,Point.z-EPSILON)).x));}\n\nvec3 phong(vec3 ColorAmbient,\n           vec3 ColorDiffuse,\n           vec3 ColorSpecular,\n           vec3 SunDir,\n           vec3 RaySource,\n           vec3 EyePos,\n           vec3 EyeNormal){\n    vec3 Ambient = vec3(ColorAmbient);\n    vec3 Normal = estimateNormal(RaySource);\n    vec3 Diffuse = ColorDiffuse*max(dot(Normal,SunDir),0.0);\n    vec3 Reflect = normalize(reflect(SunDir,Normal));\n    vec3 Ray = normalize(RaySource-EyePos);\n    vec3 Specular = ColorSpecular*pow(max(dot(Ray,Reflect),0.0),16.0)*1.0;\n    return mix(Ambient+Diffuse,ColorSpecular,Specular.x);}\n\n// CAMERA //\nmat3 cameraMatrix(vec3 Pos,vec3 Dir){\n    vec3 Normal = normalize(Dir-Pos);\n    vec3 Tangent = normalize(cross(Normal,vec3(0.0,1.0,0.0)));\n    vec3 Binormal = cross(Tangent,Normal);\n    return mat3(Tangent,Binormal,Normal);}\n\n// TEXTURING //\nvec3 textureSDFT(vec4 Sample) {\n    vec3 Color;\n    vec3 Color0 = texture(iChannel0, Sample.yz).xyz;\n    vec3 Color1 = texture(iChannel1, Sample.yz).xyz;\n    Color = mix(Color0,Color1,Sample.w);\n    return Color;\n}\n\n// MAIN //\nvoid mainImage(out vec4 fragColor,\n               in vec2 fragCoord) {\n    float ScrRatio = iResolution.x / iResolution.y;\n    vec2 ScrPoint = (fragCoord/iResolution.xy) * 2.0 - vec2(1.0, 1.0);\n    ScrPoint.x *= ScrRatio;\n    vec2 Mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    float CameraAngle = Mouse.x*PI+iTime*1.0;\n    vec3 EyePos = 2. * vec3(sin(CameraAngle), 0.5, cos(CameraAngle));\n    vec3 EyeTarget = vec3(0., 0., 0.);\n    mat3 Camera = cameraMatrix(EyePos, EyeTarget);\n    vec3 CameraPos = EyePos; // \n    vec3 CameraDir = Camera * normalize(vec3(ScrPoint, 3.0));\n    Instance = int(fract(iTime * 0.05) * float(NUM_INSTANCES));\n    vec4 Sample = castRay(CameraPos, CameraDir, EYE_RADIUS, EYE_LIMIT);\n    if (Sample.x > EYE_LIMIT - EPSILON) {\n        fragColor = vec4(0.35, 0.3, 0.4, 1.0) * 0.9;\n        fragColor.xyz = tonemap(fragColor.xyz);\n\t\treturn;\n    }\n    vec3 RaySource = CameraPos + Sample.x * CameraDir;\n    vec3 ColorAmbient = vec3(0.35, 0.3, 0.4);\n    vec3 ColorDiffuse = textureSDFT(Sample);\n    vec3 ColorSpecular = vec3(1,1,1);\n    vec3 SunDir = normalize(vec3(1,1,1));\n    vec3 Phong = phong(\n        ColorAmbient,\n        ColorDiffuse,\n        ColorSpecular,\n        SunDir,\n        RaySource,\n        CameraPos,\n        CameraDir);\n    fragColor = vec4(Phong, 1.0);\n    fragColor.xyz = tonemap(fragColor.xyz);}","name":"Image","description":"","type":"image"}]}