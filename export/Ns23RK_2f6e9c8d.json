{"ver":"0.1","info":{"id":"Ns23RK","date":"1617651058","viewed":568,"name":"Ray-Cast Cube","username":"jt","description":"Calculate ray-cast with cube, return distance & normals.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ray","raycast","cube","box","aabb","axis","cast","aligned","aab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray-Cast Cube, written 2021 by JT, license CC0 (public domain)\n// https://www.shadertoy.com/view/Ns23RK\n\n#define MAXDIST 1000.0\n//#define MAXDIST 1.0 / 0.0\n\nvec3 cubenormal(vec3 v) // position relative to cube center\n{\n    vec3 s = sign(v);\n    vec3 a = abs(v);\n\n    //vec3 n = (a.z > a.y)\n    // ?\n    // (a.z > a.x) ? vec3(0.0, 0.0, s.z) : vec3(s.x, 0.0, 0.0)\n    // :\n    // (a.y > a.x) ? vec3(0.0, s.y, 0.0) : vec3(s.x, 0.0, 0.0);\n\n    vec3 n = mix(\n        mix(vec3(0.0, 0.0, s.z), vec3(s.x, 0.0, 0.0), step(a.z, a.x)),\n        mix(vec3(0.0, s.y, 0.0), vec3(s.x, 0.0, 0.0), step(a.y, a.x)),\n        step(a.z, a.y));\n\n    return n;\n}\n\nstruct intersection\n{\n    float distance;\n    vec3 normal;\n};\n\n// source: https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms\nfloat rayboxintersect(vec3 raypos, vec3 raydir, vec3 boxmin, vec3 boxmax)\n{\n    float t1 = (boxmin.x - raypos.x) / raydir.x;\n    float t2 = (boxmax.x - raypos.x) / raydir.x;\n    float t3 = (boxmin.y - raypos.y) / raydir.y;\n    float t4 = (boxmax.y - raypos.y) / raydir.y;\n    float t5 = (boxmin.z - raypos.z) / raydir.z;\n    float t6 = (boxmax.z - raypos.z) / raydir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0.0) // box on ray but behind ray origin\n    {\n        return MAXDIST;\n    }\n\n    if (tmin > tmax) // ray doesn't intersect box\n    {\n        return MAXDIST;\n    }\n\n    return tmin;\n}\n\n/*\n// source: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\nfloat rayboxintersect(vec3 raypos, vec3 raydir, vec3 boxmin, vec3 boxmax)\n{\n    float tmin = (boxmin.x - raypos.x) / raydir.x;\n    float tmax = (boxmax.x - raypos.x) / raydir.x;\n\n    if (tmin > tmax)\n    {\n        // swap(tmin, tmax);\n        float tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n\n    float tymin = (boxmin.y - raypos.y) / raydir.y;\n    float tymax = (boxmax.y - raypos.y) / raydir.y;\n\n    if (tymin > tymax)\n    {\n        // swap(tymin, tymax);\n        float tmp = tymin;\n        tymin = tymax;\n        tymax = tmp;\n    }\n\n    if ((tmin > tymax) || (tymin > tmax))\n        return MAXDIST; // no intersection\n\n    if (tymin > tmin)\n        tmin = tymin;\n\n    if (tymax < tmax)\n        tmax = tymax;\n\n    float tzmin = (boxmin.z - raypos.z) / raydir.z;\n    float tzmax = (boxmax.z - raypos.z) / raydir.z;\n\n    if (tzmin > tzmax)\n    {\n        // swap(tzmin, tzmax);\n        float tmp = tzmin;\n        tzmin = tzmax;\n        tzmax = tmp;\n    }\n\n    if ((tmin > tzmax) || (tzmin > tmax))\n        return MAXDIST; // no intersection\n\n    if (tzmin > tmin)\n        tmin = tzmin;\n\n    if (tzmax < tmax)\n        tmax = tzmax;\n\n    return tmin;\n}\n*/\nintersection RAYBOXINTERSECT(vec3 raypos, vec3 raydir, vec3 boxmin, vec3 boxmax)\n{\n    intersection result;\n    result.distance = rayboxintersect(raypos, raydir, boxmin, boxmax);\n    //result.normal = -raydir; // sky-sphere\n    //if(result.distance < MAXDIST) result.normal = cubenormal(raypos + raydir * result.distance - (boxmin + boxmax) / 2.0);\n\n    result.normal = mix(-raydir, cubenormal(raypos + raydir * result.distance - (boxmin + boxmax) / 2.0), step(result.distance, MAXDIST));\n\n    return result;\n}\n\n\n#define PI 3.1415926\n#define TAU (2.0 * PI)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 NDC = 2.0 * fragCoord / iResolution.xy - 1.0;\n    NDC.x *= iResolution.x / iResolution.y; // aspect\n\n    float latitude = iTime / 10.0;\n    float longitude = iTime;\n    //mat2 R = mat2(cos(longitude), sin(longitude),-sin(longitude), cos(longitude));\n    mat3 R = mat3(cos(longitude), 0.0, sin(longitude), 0.0, 1.0, 0.0,-sin(longitude), 0.0, cos(longitude));\n    mat3 S = mat3(1.0, 0.0, 0.0, 0.0, cos(latitude), sin(latitude), 0.0,-sin(latitude), cos(latitude));\n\n    vec3 raydir = R * S * vec3(NDC, 1.0);\n    vec3 raypos = R * S * vec3(0.0, 0.0,-3.5);\n\n    intersection result = RAYBOXINTERSECT(raypos, raydir, vec3(-1.0), vec3(+1.0));\n\n    fragColor = vec4(vec3(0.5 + 0.5 * result.normal), 1.0);\n    //fragColor *= 0.5 + 0.5 * sin(5.0 * result.distance * TAU);\n    if(result.distance >= MAXDIST)\n        fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}