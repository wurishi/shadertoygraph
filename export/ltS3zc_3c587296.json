{"ver":"0.1","info":{"id":"ltS3zc","date":"1430875820","viewed":394,"name":"Manhattan Surface by Avi Levy","username":"avi","description":"Draws the first few iterations of the Manhattan surface. See comments in code for more information. (c) 2015 Avi Levy","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","surface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/* (c) 2015 Avi Levy\n *\n * This shader renders a Manhattan surface,\n *      aka the 3d Koch Cube\n *      aka the 3d quadratic Koch surface (Type 1)\n *\n * Motivation:\n *      The Manhattan surface is homeomorphic to\n *      a 2-sphere, yet has a fractal dimension of\n *      log(13)/log(3) = 2.33.\n *\n *      This surface is constructed by gluing together\n *      many small quadrilaterals. More generally, one\n *      may glue together quadrilaterals in a random\n *      manner to produce a random surface. Like the\n *      Manhattan surface, random surfaces are also\n *      homeomorphic to the 2-sphere yet are higher\n *      dimensional: they have dimension 4 almost surely.\n *\n *      Random surfaces constructed in such a manner\n *      have been studied in relation with quantum\n *      gravity. This topic is being studied in:\n *      \n *      Special Topics Course MATH 583 E\n *      University of Washington\n *      Instructors: Steffen Rohde and Brent Werness\n *      Course Webpage:\n *      http://www.math.washington.edu/~bwerness/teaching.html\n *\n * Changelog:\n *      ============ May 9\n *      Fixes due to Inigo Quilez:\n *          * missing a return value in the\n *              intersect() function under\n *              a certain codepath.\n *          * faster sort() function\n *      ============ May 6\n *      Complete rewrite of the mapping function.\n *      Performance boost from 3fps to 60fps on\n *      the iteration 2 of the fractal.\n *      Speedup acheived using tesselation and\n *      cubic symmetry.\n *      ============ May 5\n *      Incorporated Brent's observation that this\n *      was not a Manhattan surface due to not\n *      having enough cubies.\n *\n * Shader based on code by inigo quilez - iq/2013\n */\n\nfloat map(in vec3 p);\nvec4 colorize(float f);\n\n// raymarching algorithm\nfloat intersect(in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < 1000; i++) {\n        if(t >= 10.0) {\n            return -1.;\n        }\n        float h = map(ro + rd*t);\n        if(h < 0.01) {\n            return t;\n        }\n        t += h;\n    }\n    return -1.;\n}\n\nvec3 light = normalize(vec3(1., .9, .3));\n\nfloat blend(float t, float value) {\n    return max(0., t + (1. - t) * value);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float k) {\n    float res = 1.0;\n    float t = mint;\n    float h = 1.0;\n    for(int i = 0; i < 32; i++) {\n        h = map(ro + rd*t);\n        res = min(res, k*h/t);\n        t += clamp(h, 0.005, 0.1);\n    }\n    res = clamp(res, 0., 1.);\n    return blend(.1, res);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    // background color\n    vec3 color = mix(vec3(.3, .2, .1) * .5, vec3(.7, .9, 1.), blend(.5, rd.y));\n    \n    vec4 tmat = colorize(intersect(ro,rd));\n    if(tmat.x > 0.) {\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n        \n        float occlusion = tmat.y;\n        float incident = dot(nor, light);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00 * blend(.1, incident) * softshadow(pos, light, 0.01, 64.0) * vec3(1.1, .85, .6);\n        lin += 0.50 * blend(.5, nor.y) * occlusion * vec3(.1, .2, .4);\n        lin += 0.50 * blend(.4, -incident) * blend(.5, occlusion) * vec3(1);\n        lin += 0.25 * occlusion * vec3(.15, .17, .2);\n\n        vec3 matcol = vec3(\n            0.5+0.5*cos(0.0+2.0*tmat.z),\n            0.5+0.5*cos(1.0+2.0*tmat.z),\n            0.5+0.5*cos(2.0+2.0*tmat.z)\n        );\n        color = matcol * lin;\n    }\n\n    return pow(color, vec3(0.4545));\n}\n\nvec3 rotate(float t) {\n    vec3 p = vec3(0., 1., 0.);\n    vec3 q = vec3(2.5, 1.0, 2.5);\n    vec3 r = vec3(0.25, 0.13, 0.25);\n    return p + vec3(\n        q.x * sin(r.x * t),\n        q.y * cos(r.y * t),\n        q.z * cos(r.z * t)\n    );\n}\n\nvec4 colorize(float f) {\n    if(f == -1.) {\n        return vec4(-1., -1., -1., 1.);\n    } else {\n        // length, 0, material, 0\n        return vec4(abs(f), 0., .25, 0.);\n    }\n}\n\nvoid mainImage(out vec4 color, in vec2 position) {\n    vec2 p = -1.0 + 2.0 * position.xy / iResolution.xy;\n    p.x *= 1.33;\n\n    // camera\n    vec3 ro = 1.1 * rotate(iTime * 1.);\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n    \n    color = vec4(render(ro, rd), 1.);\n}\n\nfloat max(in vec3 p) {\n    return max(p.x,max(p.y,p.z));\n}\n\nfloat rect(vec3 p, vec3 center, vec3 radius) {\n    return length(max(abs(p - center) - radius, 0.));\n}\n\nvec3 tesselate(vec3 p, vec3 tile) {\n    return mod(p - .5 * tile, tile) - .5 * tile;\n}\n\nvec3 sort(in vec3 p) {\n    float mi = min(min(p.x, p.y), p.z);\n    float ma = max(max(p.x, p.y), p.z);\n    return vec3(mi, p.x + p.y + p.z - mi - ma, ma);\n}\n\nfloat scale = .7;\n\nfloat map(in vec3 p) {\n    p = abs(p)/scale;\n    p = sort(p);\n    \n    float s;\n\n    float r = rect(p, vec3(0), vec3(1));\n\n    s = rect(p, vec3(0.,0.,4./3.), vec3(1./3.));\n    r = min(r,s);\n\n    vec3 t;\n    t = tesselate(p, vec3(2./3.,2./3.,0.));\n    s = rect(t, vec3(0.,0.,10./9.), vec3(1./9.));\n    s = max(s, rect(p, vec3(0), vec3(1.,1.,2.)));\n    r = min(r,s);\n\n    s = rect(p, vec3(0.,4./9.,4./3.), vec3(1./9.));\n    r = min(r,s);\n\n    s = rect(p, vec3(0.,0.,16./9.), vec3(1./9.));\n    r = min(r,s);\n    return scale * r;\n}","name":"","description":"","type":"image"}]}