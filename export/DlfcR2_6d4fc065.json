{"ver":"0.1","info":{"id":"DlfcR2","date":"1690936492","viewed":120,"name":"ray marching TEST","username":"Swifter","description":"this is pretty bad but IDK!!! I did it completely from scratch besides look up rotation matrices 👍👍👍👍","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 cameraRotation = vec3(0.,0.,0.);\nconst float FOV = 60.;\nconst float maxDist = 1000.;\n\nconst vec3 sphereCenter = vec3(0.,0.,10.);\nconst float sphereRadius = 2.;\n\nconst vec3 sunDirection = normalize(vec3(1.,0.2,-0.3));\n\n#define DEG2RAD 0.01745329251\n\nfloat easeInOutQuint(float x) {\n    return x < 0.5 ? 16. * x * x * x * x * x : 1. - pow(-2. * x + 2., 5.) / 2.;\n}\n\nfloat easeInCubic(float x) {\n    return x * x * x;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rotateX(float angle, vec3 vector) {\n    return vec3(\n        vector[0] * cos(angle) - vector[1] * sin(angle),\n        vector[0] * sin(angle) + vector[1] * cos(angle),\n        vector[2]\n    );\n}\n\nvec3 rotateY(float angle, vec3 vector) {\n    return vec3(\n        vector[0] * cos(angle) + vector[2] * sin(angle),\n        vector[1],\n        -vector[0] * sin(angle) + vector[2] * cos(angle)\n    );\n}\n\nvec3 rotateZ(float angle, vec3 vector) {\n    return vec3(\n        vector[0],\n        vector[1] * cos(angle) - vector[2] * sin(angle),\n        vector[1] * sin(angle) + vector[2] * cos(angle)\n    );\n}\n\nvec3 rotateVector(vec3 vector, vec3 rotation) {\n    vector = rotateZ(rotation[0] * DEG2RAD, vector);\n    vector = rotateY(rotation[1] * DEG2RAD, vector);\n    vector = rotateX(rotation[2] * DEG2RAD, vector);\n    return vector;\n}\n\nfloat lerp(float a, float b, float t) {\n  return a + t * (b - a);\n}\n\nfloat sphereSDF(vec3 center, float radius, vec3 point) {\n    return length(center - point) - radius;\n}\n\nfloat sdBox( vec3 center, vec3 corner, vec3 point)\n{\n  vec3 p = point - center;\n  vec3 b = corner;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nconst vec3 FORWARD = vec3(0.,0.,1.);\n\nconst float outlineDist = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Calculate vector direction\n    float aspect = iResolution.x/iResolution.y;\n    float verticalFOV = FOV * aspect;\n    \n    float bottomXrot = -verticalFOV/2.;\n    float topXrot = verticalFOV/2.;\n    float leftYrot = -FOV/2.;\n    float rightYrot = FOV/2.;\n    \n    float Xrot = lerp(bottomXrot, topXrot, uv.x);\n    float Yrot = lerp(leftYrot, rightYrot, uv.y);\n    \n    // Raycast\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy * 0.5;\n    vec3 newRotation = cameraRotation + vec3(mouseUV.xy,0.) * 80.;\n    \n    vec3 cameraForward = rotateVector(FORWARD, newRotation);\n    vec3 ray = rotateVector(cameraForward, vec3(Xrot, Yrot, 0.));\n    \n    float distTravelled = 0.;\n    vec3 curPos = vec3(0,0,mouseUV.x * 20.);\n    \n    vec3 f = vec3(0.,0.,0.);\n    float lowestCol = outlineDist;\n    vec3 lowestPoint = vec3(0,0,0);\n    float lowestStrength = 0.;\n    \n    vec3 curSunDirection = normalize(sunDirection + vec3(0.,cos(iTime), sin(iTime)));\n    \n    while (distTravelled < maxDist) {\n        float radius = 3. + sin(iTime / 2.);\n        float sdf = length(curPos - sphereCenter) - radius;\n        // float sdf = sdBox(sphereCenter, vec3(1.,1.,1.) * radius, curPos);\n        \n        if (sdf < outlineDist && sdf < lowestCol) {\n            vec3 normal = normalize(curPos - sphereCenter);\n            lowestStrength = dot(normal, curSunDirection);\n            lowestCol = sdf;\n        }\n           \n        if (sdf < 0.02) {\n            vec3 normal = normalize(curPos - sphereCenter);\n            float sunStrength = dot(normal, curSunDirection);\n            float highlight = easeInCubic(sunStrength);\n            f = hsv2rgb(vec3(mod(sunStrength + 0.2, 1.), 0.3, highlight));\n            break;\n        }\n        \n        curPos += ray * sdf;\n        distTravelled += sdf;\n    }\n    \n    if (lowestCol >= outlineDist) {\n        lowestCol = 0.;\n    }\n    \n    lowestCol *= lowestStrength;\n    \n    // Export\n    vec3 col = f;\n    col += hsv2rgb(vec3((2. - lowestStrength) * 0.5, 1., lowestCol)) * lowestStrength;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}