{"ver":"0.1","info":{"id":"MXGGDD","date":"1719280277","viewed":15,"name":"ball+plane+ellipse+cone","username":"sophytoeat","description":"None","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cone","ball","plane","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n};\n\n// 各種パラメータ\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0; }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(0.0, 4.0, 3.0); }\nvec3 CameraTo() { return vec3(0.2, 0.7, 0.2); }\nvec3 CameraUp() { return vec3(0.0, 2.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\n\nvec3 sphereCenter = vec3(2.0, 0.0, 0.0);\nfloat sphereRadius = 1.0; // 球の半径\n\nvec3 planeNormal = vec3(0.0, 1.0, 0.0);\nfloat planeDistance = -1.0;\n\nvec3 ellipsoidCenter = vec3(-2.0, 1.0, 1.0);\nvec3 ellipsoidRadii = vec3(1.0, 1.0, 1.0); // 楕円の各軸の半径\n\nvec3 coneApex = vec3(6.0, 1.0, 3.0);\nvec3 coneAxis = normalize(vec3(0.0, -1.0, 0.0));\nfloat coneAngle = radians(20.0);\n\n// 正規直交基底を計算する関数の例\nvoid creatnormalize(vec3 from, vec3 to, vec3 up, out vec3 u, out vec3 v, out vec3 w, out vec3 e)\n{\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n}\n\n// ピクセル座標をカメラ座標系の座標で表現\nvec3 convertCamera(vec2 pixelCoordinate)\n{\n    float filmWidth = FilmWidth();\n    float filmHeight = FilmHeight();\n    float filmDistance = FilmDistance();\n\n    float x = filmWidth - 2.0 * ((pixelCoordinate.x + 0.5) / iResolution.x) * filmWidth;\n    float y = filmHeight - 2.0 * ((pixelCoordinate.y + 0.5) / iResolution.y) * filmHeight;\n    float z = filmDistance;\n\n    return vec3(x, y, z);\n}\n\n// カメラレイを生成する\nRay generateCameraRay(vec2 pixelCoordinate)\n{\n    vec3 cameraPos = CameraFrom();\n    vec3 targetPos = CameraTo();\n    vec3 upDir = CameraUp();\n\n    vec3 u, v, w, e;\n    creatnormalize(cameraPos, targetPos, upDir, u, v, w, e);\n\n    vec3 camera_pixel = convertCamera(pixelCoordinate);\n    vec3 world_pixel = camera_pixel.x * u + camera_pixel.y * v + camera_pixel.z * w;\n\n    Ray ray;\n    ray.org = e;\n    ray.dir = normalize(e - world_pixel);\n    return ray;\n}\n\n// レイと球の交差判定を行うプログラム\nbool intersectToSphere(vec3 center, float radius, Ray ray, out Hit hit)\n{\n    vec3 oc = ray.org - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(oc, ray.dir);\n    float c = dot(oc, oc) - radius * radius;\n    float discri = b * b - 4.0 * a * c;\n\n    if (discri < 0.0) return false;\n\n    float t1 = (-b - sqrt(discri)) / (2.0 * a);\n    float t2 = (-b + sqrt(discri)) / (2.0 * a);\n\n    if (t1 > 0.0 && t1 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t1;\n        hit.normal = normalize((ray.org + t1 * ray.dir) - center);\n        return true;\n    }\n\n    if (t2 > 0.0 && t2 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t2;\n        hit.normal = normalize((ray.org + t2 * ray.dir) - center);\n        return true;\n    }\n\n    return false;\n}\n\n// レイと平面の交差判定を行うプログラム\nbool intersectToPlane(vec3 planeNormal, float planeDistance, Ray ray, out Hit hit)\n{\n    float denom = dot(planeNormal, ray.dir);\n    if (-1.0 < denom && denom < 1.0)\n    {\n        float t = (planeDistance - dot(planeNormal, ray.org)) / denom;\n        if (t >= 0.0 && t < hit.distanceToHitpoint)\n        {\n            hit.distanceToHitpoint = t;\n            hit.normal = planeNormal;\n            return true;\n        }\n    }\n    return false;\n}\n\n// レイと楕円の交差判定を行うプログラム\nbool intersectToEllipsoid(vec3 center, vec3 radii, Ray ray, out Hit hit)\n{\n    vec3 oc = ray.org - center;\n    vec3 dir = ray.dir / radii;\n    vec3 ocScaled = oc / radii;\n\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(ocScaled, dir);\n    float c = dot(ocScaled, ocScaled) - 1.0;\n    float discri = b * b - 4.0 * a * c;\n\n    if (discri < 0.0) return false;\n\n    float t1 = (-b - sqrt(discri)) / (2.0 * a);\n    float t2 = (-b + sqrt(discri)) / (2.0 * a);\n\n    if (t1 > 0.0 && t1 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t1;\n        hit.normal = normalize((ray.org + t1 * ray.dir - center) / radii);\n        return true;\n    }\n\n    if (t2 > 0.0 && t2 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t2;\n        hit.normal = normalize((ray.org + t2 * ray.dir - center) / radii);\n        return true;\n    }\n\n    return false;\n}\n\n// レイと円錐の交差判定を行うプログラム\nbool intersectToCone(vec3 apex, vec3 axis, float angle, Ray ray, out Hit hit)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    vec3 v = ray.org - apex;\n    vec3 dir = normalize(ray.dir);\n\n    float cosAngle2 = cosAngle * cosAngle;\n    float sinAngle2 = sinAngle * sinAngle;\n\n    float vd = dot(v, axis);\n    float dd = dot(dir, axis);\n\n    vec3 v1 = v - vd * axis;\n    vec3 d1 = dir - dd * axis;\n\n    float A = cosAngle2 * dot(d1, d1) - sinAngle2 * dd * dd;\n    float B = 2.0 * cosAngle2 * dot(d1, v1) - 2.0 * sinAngle2 * vd * dd;\n    float C = cosAngle2 * dot(v1, v1) - sinAngle2 * vd * vd;\n\n    float discriminant = B * B - 4.0 * A * C;\n\n    if (discriminant < 0.0) return false;\n\n    float sqrtDiscriminant = sqrt(discriminant);\n    float t1 = (-B - sqrtDiscriminant) / (2.0 * A);\n    float t2 = (-B + sqrtDiscriminant) / (2.0 * A);\n\n    bool hitFound = false;\n\n    if (t1 > 0.0)\n    {\n        vec3 hitPoint = ray.org + t1 * ray.dir;\n        vec3 vHit = hitPoint - apex;\n        float vdHit = dot(vHit, axis);\n\n        // 交点が円錐の「前向きの部分」にあることを確認する\n        if (vdHit > 0.0 && t1 < hit.distanceToHitpoint)\n        {\n            vec3 normal = normalize(vHit - vdHit * axis);\n            if (dot(normal, dir) > 0.0) normal = -normal; // 交点の法線ベクトルがレイの進行方向とは反対を向いていることを確認\n            hit.distanceToHitpoint = t1;\n            hit.normal = normal;\n            hitFound = true;\n        }\n    }\n\n    if (t2 > 0.0)\n    {\n        vec3 hitPoint = ray.org + t2 * ray.dir;\n        vec3 vHit = hitPoint - apex;\n        float vdHit = dot(vHit, axis);\n\n        // 交点が円錐の「前向きの部分」にあることを確認する\n        if (vdHit > 0.0 && t2 < hit.distanceToHitpoint && !hitFound)\n        {\n            vec3 normal = normalize(vHit - vdHit * axis);\n            if (dot(normal, dir) > 0.0) normal = -normal; // 交点の法線ベクトルがレイの進行方向とは反寙を向いていることを確認\n            hit.distanceToHitpoint = t2;\n            hit.normal = normal;\n            hitFound = true;\n        }\n    }\n\n    return hitFound;\n}\n\n\n// レイの交点から光源への影のレイを生成し、そのレイが球と楕円と円錐と交差するかをチェック\nbool shadowRay(vec3 hitPoint, vec3 lightPos)\n{\n    Ray shadowRay;\n    shadowRay.org = hitPoint;\n    shadowRay.dir = normalize(lightPos - hitPoint);\n\n    Hit shadowHit;\n    shadowHit.distanceToHitpoint = length(lightPos - hitPoint);\n\n    // 球との交差判定\n    if (intersectToSphere(sphereCenter, sphereRadius, shadowRay, shadowHit))\n    {\n        return true;\n    }\n\n    // 楕円との交差判定\n    if (intersectToEllipsoid(ellipsoidCenter, ellipsoidRadii, shadowRay, shadowHit))\n    {\n        return true;\n    }\n\n    // 円錐との交差判定\n    if (intersectToCone(coneApex, coneAxis, coneAngle, shadowRay, shadowHit))\n    {\n        return true;\n    }\n\n    return false;\n}\n\n// 既存の球と平面と楕円と円錐との交差判定を行う\nbool intersect(Ray ray, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n\n    // 球との交差判定\n    bool hitSphere = intersectToSphere(sphereCenter, sphereRadius, ray, hit);\n\n    // 平面との交差判定\n    bool hitPlane = intersectToPlane(planeNormal, planeDistance, ray, hit);\n\n    // 楕円との交差判定\n    bool hitEllipsoid = intersectToEllipsoid(ellipsoidCenter, ellipsoidRadii, ray, hit);\n\n    // 円錐との交差判定\n    bool hitCone = intersectToCone(coneApex, coneAxis, coneAngle, ray, hit);\n\n    return hitSphere || hitPlane || hitEllipsoid || hitCone;\n}\n\n// 光源位置からの光の方向を計算し、影の有無をチェックします\nvec3 shade(Ray ray, Hit hit)\n{\n    vec3 lightPos = vec3(1.0, 8.0, -1.0);\n    vec3 lightDir = normalize(lightPos - (ray.org + hit.distanceToHitpoint * ray.dir));\n\n    // 影の有無をチェック\n    vec3 hitPoint = ray.org + hit.distanceToHitpoint * ray.dir;\n    vec3 offsetPoint = hitPoint + hit.normal * 1e-4; // 図形表面の模様発生防止のために影のレイの始点をオブジェクトの表面から少しだけ離す\n    bool inShadow = shadowRay(offsetPoint, lightPos);\n\n    float diffuse = max(dot(hit.normal, lightDir), 0.0);\n    if (inShadow)\n    {\n        diffuse *= 0.2; // 影の度合いを決定\n    }\n\n    return vec3(diffuse);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n\n    Hit hit;\n    if (intersect(ray, hit))\n    {\n        fragColor = vec4(shade(ray, hit), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.9, 0.8, 1.0, 1);\n    }\n}\n","name":"Image","description":"","type":"image"}]}