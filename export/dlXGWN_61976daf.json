{"ver":"0.1","info":{"id":"dlXGWN","date":"1671756336","viewed":33,"name":"selective saturation","username":"playersteve19","description":"A shader with a few hsv based effects. Part of a larger WIP.  ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tonemapping","selectivesaturation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rgb2hsv( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                 d / (q.x + e),\n                q.x);\n}\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n//boosts warmth. Function I discovered through trial and error\nfloat tonemap(in vec3 hsv){\n    float x = hsv.x;\n    x = -4.2*pow(x,4.)+7.2*pow(x,3.)-(167./60.)*pow(x,2.)+(47./60.)*x;\n    return x;\n}\n#define pi 3.141592653\nfloat select(in vec3 hsv, in float offset, in float width, in float curve){\n    float var = fract(hsv.x-offset); \n    float sat = hsv.y;\n    sat = smoothstep(0.,1.,sat);//boost vibrancy slightly\n    sat *= (-.5*width<= var && var<.5*width)?pow((2./pi)*asin(cos(pi*var/width)),exp2(curve)):0.;\n    return sat;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col=texture(iChannel0,uv).rgb;\n    vec2 rv = iMouse.xy/iResolution.xy;\n    vec3 hsv = rgb2hsv(col);\n    float offset = -.025;//select the color to keep saturated. \n    //offset +=iTime/24.;//animate a sweep through all the colors\n    hsv.x = tonemap(hsv);//warms up colors to better mimic how humans see hues\n    float width = 1.05/12.;\n    float curve = -5.;\n    col=hsv2rgb(vec3(hsv.x, select(hsv,offset,width,curve),hsv.z));\n    /*I find I like tonemapping enabled, offset at -.025, width at 1.05/12., and curve at -5\n    to get the \"classic\" red-selective saturation*/\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}