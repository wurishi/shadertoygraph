{"ver":"0.1","info":{"id":"4XfcWS","date":"1726590193","viewed":31,"name":"CMYK Dots","username":"eiraxxx","description":"Highly configurable shader emulating the CMYK dot look used in colour printing in old magazines. Created for promotional artwork for Bottomless Brunch - a party collective based in Berlin.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cmyk","media","screenprinting","magazine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Example Pixel Shader\n\n// uniform float exampleUniform;\n\nconst float Frequency = 60.0;\nconst float Size = 0.7;\nconst float Saturation = 5.;\nconst float Exponent = 0.3;\nconst float ReduceColor = 0.3;\nconst float Lightness = 0.306;\nconst float LumMul = 2.;\nconst float KDesat = 1.;\nconst float Noise = 0.3;\n\nfloat aastep(float threshold, float value) {\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nconst mat2 CROT = mat2(0.966, -0.259, 0.259, 0.966);\nconst mat2 MROT = mat2(0.966, 0.259, -0.259, 0.966);\nconst mat2 YROT = mat2(1, 0, 0, 1);\nconst mat2 KROT = mat2(0.707, -0.707, 0.707, 0.707);\nconst mat2 CINVROT = mat2(0.966, 0.259, -0.259, 0.966);\nconst mat2 MINVROT = mat2(0.966, -0.259, 0.259, 0.966);\nconst mat2 YINVROT = mat2(1, 0, 0, 1);\nconst mat2 KINVROT = mat2(0.707, 0.707, -0.707, 0.707);\n\nfloat getComponent(float aaThresh, float n, float val, float frequency, mat2 rot, vec2 st, vec2 center) {\n  // Distance to nearest point in a grid of\n  // (frequency x frequency) points over the unit square\n  // if (val <= 0.5) {\n  \treturn aastep(aaThresh, Size*pow(val * 2.0, Exponent)-(length(st - center) * frequency)+n);\n  // } else {\n    // return 1.0 - aastep(aaThresh, Size*pow((1.0 - val) * 2.0, EXPONENT)-(length(st - center) * frequency)+n);\n  // }\n}\n\nvec4 halftone(vec4 cmyk, vec2 st, vec2 center[4], float frequency) {\n  float n = 0.1*snoise(st*200.0); // Fractal noise\n  n += 0.05*snoise(st*400.0);\n  n += 0.025*snoise(st*800.0);\n  vec3 white = vec3(n*0.3 + 0.96);\n  vec3 black = vec3(max(n - 0.1, 0.));\n\n  float c = getComponent(ReduceColor, n * Noise, cmyk.r, frequency, CROT, st, center[0]);\n  float m = getComponent(ReduceColor, n * Noise, cmyk.g, frequency, MROT, st, center[1]);\n  float y = getComponent(ReduceColor, n * Noise, cmyk.b, frequency, YROT, st, center[2]);\n  float k = getComponent(Lightness, n * Noise, cmyk.a, frequency, KROT, st, center[3]);\n\n  return vec4(c, m, y, k);\n}\n\nvec2 textureCoords(float freq, mat2 invrot, mat2 rot, vec2 uv) {\n\treturn (invrot*floor(rot*(freq*uv)))/freq;\n}\n\nvoid textureCoords(float freq, mat2 invrot, mat2 rot, vec2 uv, vec2 aspect, out vec2 coords[9]) {\n\tvec2 base = floor(rot*(freq*uv*aspect));\n\tvec2 offsets[9];\n\t\n\toffsets[0] = vec2(-1, -1);\n\toffsets[1] = vec2(-1, 0);\n\toffsets[2] = vec2(-1, 1);\n\toffsets[3] = vec2(0, -1);\n\toffsets[4] = vec2(0, 0);\n\toffsets[5] = vec2(0, 1);\n\toffsets[6] = vec2(1, -1);\n\toffsets[7] = vec2(1, 0);\n\toffsets[8] = vec2(1, 1);\n\n\tfor (int i = 0; i < 9; i++) {\n\t\tcoords[i] = invrot * (base + offsets[i]) / freq / aspect;\n\t}\n}\n\nconst mat3 ToXYZMatrix = mat3(\n    0.4124564, 0.3575761, 0.1804375,\n    0.2126729, 0.7151522, 0.0721750,\n    0.0193339, 0.1191920, 0.9503041\n);\n\nconst float WHITE_START = 0.9;\n\nfloat luminance(vec3 color) {\n    return dot(color, ToXYZMatrix[1]);\n}\n\nvec3 crosstalk(vec3 tonemapped) {\n    float tonemappedMax = max(tonemapped.r, max(tonemapped.g, tonemapped.b));\n    vec3 ratio = tonemapped / tonemappedMax;\n    tonemappedMax = min(tonemappedMax, 1.0);\n\n    ratio = pow(ratio, vec3(1.1 / 2.0));\n    ratio = mix(ratio, vec3(1.0), pow(tonemappedMax, 2.0));\n    ratio = pow(ratio, vec3(2.0));\n\n    return ratio * tonemappedMax;\n}\n\nvec4 rgbToCmyk(vec3 rgb) {\n\tfloat lum = luminance(rgb);\n\tfloat maxrgb = max(rgb.r, max(rgb.g, rgb.b));\n\tfloat minrgb = min(rgb.r, max(rgb.g, rgb.b));\n\tvec3 cmy = (maxrgb - rgb) / maxrgb;\n\tfloat sat = (maxrgb - minrgb) / (1. - abs(2. * lum - 1.));\n\tsat = clamp(sat * Saturation, 0., 1.);\n\tsat = lum >= 1.0 ? 0. : sat;\n\t\n\tfloat k = 1.0 - clamp(lum * LumMul, 0., 1.);\n\tif (KDesat < 1.0) {\n\t\tcmy = cmy * (1. - clamp(k - KDesat, 0., 1. - KDesat) / (1. - KDesat));\n\t}\n\n\treturn vec4(cmy * sat, k);\n}\n\nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 vUV = fragCoord / iResolution.xy;\n\tvec2 aspect = vec2(iChannelResolution[0].x / iChannelResolution[0].y, 1.0);\n  \t\n  \tvec3 rgb = vec3(0.);\n  \tfloat a = 0.;\n  \tvec2 rcoords[9];\n  \tvec2 gcoords[9];\n  \tvec2 bcoords[9];\n  \tvec2 kcoords[9];\n  \ttextureCoords(Frequency, CINVROT, CROT, vUV.st, aspect, rcoords);\n  \ttextureCoords(Frequency, MINVROT, MROT, vUV.st, aspect, gcoords);\n  \ttextureCoords(Frequency, YINVROT, YROT, vUV.st, aspect, bcoords);\n  \ttextureCoords(Frequency, KINVROT, KROT, vUV.st, aspect, kcoords);\n  \t\n\tfor (int i = 0; i < 9; i++) {\n\t\tvec2 centers[4];\n\t\tcenters[0] = rcoords[i] * aspect;\n\t\tcenters[1] = gcoords[i] * aspect;\n\t\tcenters[2] = bcoords[i] * aspect;\n\t\tcenters[3] = kcoords[i] * aspect;\n\n\t\tvec4 rcolor = clamp(texture(iChannel0, rcoords[i]), 0., 1.);\n\t\tvec4 gcolor = clamp(texture(iChannel0, gcoords[i]), 0., 1.);\n\t\tvec4 bcolor = clamp(texture(iChannel0, bcoords[i]), 0., 1.);\n\t\tvec4 kcolor = clamp(texture(iChannel0, kcoords[i]), 0., 1.);\n\n\t\tfloat ci = clamp(rgbToCmyk(rcolor.rgb).r, 0., 1.);\n\t\tfloat mi = clamp(rgbToCmyk(gcolor.rgb).g, 0., 1.);\n\t\tfloat yi = clamp(rgbToCmyk(bcolor.rgb).b, 0., 1.);\n\t\tfloat ki = clamp(rgbToCmyk(kcolor.rgb).a, 0., 1.);\n\n\t\tvec4 halftoned = halftone(vec4(ci, mi, yi, ki), vUV.st * aspect, centers, Frequency);\n\t\trgb = rgb + halftoned.rgb;\n\t\ta = a + halftoned.a;\n\t}\n\t\n\trgb = clamp(rgb, 0., 1.);\n\ta = clamp(a, 0., 1.);\n\n\t// vec4 final = vec4((vec3(1.0) - vec3(halftoned.a)) * (vec3(1.0) - vec3(halftoned.r, halftoned.g, halftoned.b)), a * max(halftoned.r, max(halftoned.g, max(halftoned.b, halftoned.a))));\n\n\tfragColor = vec4((1.0 - rgb) * (1.0 - a), 1.0);\n    // fragColor = vec4(vUV.x, vUV.y, 0., 1.0);\n}\t\n","name":"Image","description":"","type":"image"}]}