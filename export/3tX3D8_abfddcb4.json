{"ver":"0.1","info":{"id":"3tX3D8","date":"1556139530","viewed":398,"name":"music_memo for Beginner","username":"Machia","description":"music shader memo","likes":8,"published":1,"flags":8,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tmessage: sound in #2 \n\thttps://www.shadertoy.com/view/MtyXRW\n*/\n\n// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n\t本気で自分でも覚えてなかったので、\n\t特徴や制約等をメモ代わりにまとめる。\n\t\n\tby machia/MachiaWorks\n\t\n\tGPUSoundのメモ（＋仕様っぽいの）：\n\t・GPUSoundは、通常CPUを使ってレンダリングする音を\n\t　GPUに計算をぶん投げて形作るものと定義する\n\t・Shadertoyでのレンダリング方式、自分での実装で演奏可能\n\t・1秒あたりのデータは44100byteとして、\n\t　音楽のデータをレンダリングする\n\t　（自分で実装する際はレート変更が可能）\n\t・GPUSoundでは、曲の全部を一気にレンダリングする\n\t・GPUSoundでは、レンダリング1byteあたりで\n\t　どのような波形を書くか・どんな音量かを記述する。\n\t　すなわち、ADSRなら特定位置での音量を式で計算する\n\n\t制約：\n\t・GPUSoundでは、前後のバッファを保存することができない。\n\t　すなわち、BiquadFilter（双2次フィルタ）は実装ができない。\n\t・GPUSoundでは、一時的な変数を次のフレームに保存ができない\n\t　よって、ADSRみたいに音量を変数で確保するのが不可能\n\n\t（あくまでSoundのソースコードだけでなんとかするときの制約。\n\t　iChannelや他のソースでデータ生成する場合は除く）\n\n\t2019/4/25\t公開\n\t2019/4/25\tコメント修正、記述の省略化\n\t2019/4/26\tひどいソースコードを直した\n*/\n\n//円周率\n#define PI 3.1415926535\n//BPM\n#define BPM 130.0\n//ゼロリセット\n#define V vec3(0.,1.,-1.)\n\n// ノイズ出力\n//入力・・・シード、出力・・・floatの乱数\nfloat noiz(float s){\n\treturn fract(sin(s*78.233)*43758.5453)*2.-1.;\n}\n\n//音階の周波数を返す\n//入力・・・譜面番号（0-88）、出力・・・floatで周波数\nfloat pitch(float p) {\n\treturn pow(1.059460646483, p) * 440.0;\n}\n\n/*\n\t周期計算：2.0*PI\n\t周波数：pitch(note)\n\t\n\tよって、周波数あたりの周期が求められる\n\tここからサイン波の位置を求めて、\n\t振動する波形を連続させて、音を形作ることになる。\n\t（他の計算でも使うため外出ししてる）\n*/\nfloat tone( float note ){\n\n\treturn 2.0*PI*pitch(note);\n}\n/*\n\t三角波\n\t仕組みはWikipediaみてもらうとして\n\tPHASEって書いてあるのはすなわち周波数。のはず。\n*/\nfloat saw(float phase) {\n\tfloat s = 0.0;\n\tfor (int k = 1; k <= 8; k++) {\n\t\ts += (sin(2.0*PI*float(k)*phase) / float(k));\n\t}\n\treturn (1.0/2.0) - (1.0/PI)*s - 0.5;\n}\n\n//ランダム数値（コピペのはず）\nvec4 random2H(vec2 _v) {\n\treturn vec4(fract(sin(dot(_v, vec2(12.9898, 78.233))) * 43758.5453));\n}\n\n//ランダム数値出力\nvec4 random(float _v) {\n\treturn random2H(_v * V.yy);\n}\n\n/*\n\tシーケンスの数値出力\n\t現在の時間とティック（１小節の刻みの単位）を入力すると\n\n\t・現在処理中のティック情報（ADSRの経過状態等を知ることができる）\n\t・所属ティック(16ティック中15鳴らしたところ、とか）\n\t・二分音符のカウント（曲中で何回二分音符が鳴ったか）\n\t・経過小節数\n\n\tを返す\n*/\nvec4 sqc( float time, float tick ){\n\n\t/*=========|=========|=========|=========*/\n\tvec4 s_t;\n\t\n\t//二分音符の拍数を返す\n    /*\n\t\tおそらく４分音符で反応させて計算することがないものと見て\n\t\t二分音符用に直したものと考えられる。\n\t*/\n\tfloat s = mod(floor(time/240.*BPM*2.),4.);\n\n\t//ティックごとの数値を返す(0.5拍目、みたいなの。ADSRの値を決めるときに使う）\n\tfloat t = fract(time/240.*BPM*float(tick));\n\t\n\t//現在演奏しているティック数を返す（ティックを１６で分けたら今５個目演奏してるよ、みたいなの）\n\tfloat u = mod( floor( time/240.*BPM*float(tick)),tick );\n\t\n\t//小節数を返す\n\tfloat v = floor(time/240.*BPM);\n\t\n\ts_t.x = s;\n\ts_t.y = t;\n\ts_t.z = u;\n\ts_t.w = v;\n\t\n\treturn s_t;\n}\n\n/*\n\tパッド音色\n*/\nfloat pad( float time,float semi){\n\t//和音。\n\tfloat s = 0.0;\n    \n    float[4] semitones = float[](0.,4.,7.,9.);\n    \n\tconst int VOICES = 4;\n\t\n\t/*\n\t\t譜面カウンタ\n\t\tt1：1小節内の二分音符のカウント\n\t\tt2：譜面いっこの経過時間）\n\t\tt3：2小節で一度ピッチ下げる→また戻す、を繰り返す\n\t*/\n\tfloat t1 = mod(floor(time/240.*BPM*float(2)),4.);\n\tfloat t2 = fract(time/240.*BPM*float(2));\n\tfloat t3 = (t1>= 2.)?1.:0.;\n\t\n\t/*\n\t\t演奏譜面。\n\t\t和音を演奏する形にしてる\n\t*/\n\tfloat main_seq[4];\n\tmain_seq[0]=-2.,main_seq[1]=-2.,main_seq[2]=1.,main_seq[3]=1.;\n\n\t//シーケンスの位置を計算\n\tvec4 sq = sqc(time, .5);\n\t\n\t//音色部分\n\tfor (int i=0 ; i<VOICES; i++) {\n\t\t\n\t\t//4小節ごとに0・1を返す\n\t\tfloat q = mod(sq.w,4.);\n\t\t\n\t \t//ピッチの定義。\n        \n\t\tfloat f = pitch(semi+main_seq[int(q)]+(semitones[i]));\n\t\t\n\t\t//ユニゾン。音を重ねる。\n\t\tconst int UNISON = 8;\n\t\t\n\t\t//パッドの音を出すために音を重ねてる\n\t\tfor (int u = 0; u < UNISON-1; u++) {\n\t\t\t\n\t\t\t/*\n\t\t\t\tnew_f：LFOと発音タイミングのズレを兼ねてる\n\t\t\t*/\n\t\t\tfloat fu = float(u);\n\t\t\tfloat new_f = f + fu * sin(fu);\n\t\t\n\t\t\t/*\n\t\t\t\tややこしい記述なので補記。\n\t\t\t\t\n\t\t\t\ts:1byteあたりの波形データ。\n\t\t\t\tsaw:三角波を特定周期で鳴らす命令\n\t\t\t\t\ttime*new_fで再生タイミングをズラしている\n\t\t\t\t1.0/float(UNISON)：\n\t\t\t\t\t音量を下げて、音を重ねたときに音割れが\n\t\t\t\t\t起きないようにする。\n\t\t\t\t\t一応加算合成の計算になる。\n\t\t\t\t1./float(VOICES)\n\t\t\t\t\t和音を演奏するボイスの分音量を下げる\n\t\t\t*/\n\t\t\t\n\t\t\ts += saw(time * new_f) * (1.0/float(UNISON))\n\t\t\t* (1./float(VOICES))\n\t\t\t*min(1., sq.y*6.)\t//アタック\n\t\t\t*max(0., 1.5-sq.y) //ディケイ\n\t\t\t;\t//音量\n\t\t}\n\t}\n\n\t//音の出力\n\treturn s;\n}\n\n/*\n\tキックの音。\n*/\nfloat kick(float time){\n\tfloat s = 0.;\n\t\n    //シーケンスを2個用意した。\n\tvec4 sq1 = sqc(time,4.);\n\tvec4 sq2 = sqc(time,8.);\n\t\n\t//ティックごとの大きさを返す\n\tfloat t2 = sq1.y;\n\tfloat t4 = sq2.y;\n\t\n\tfloat t_r = t2;\n    \n    //2小節目の最後にキックを2回打つようにした。\n    /*\n\t\t1小節目：4つ打ち\n\t\t2小節目：3/4までは4つ打ち、残りは8分音符\n\t*/\n\tt_r = ( sq2.z>=7. && mod(sq1.x,4.) == 3. )?t4:t2;\n\t\n    /*\n\t\tキックのピッチを調整。\n\t\tティックの経過時間に応じてピッチを下げる調整。\n\t*/\n\tfloat f = pitch(9.-t2*35.);\n    \n\t//t_r = ()?t4:t2;\n\t\n\t//最終的なピッチを決定\n    \n    /*\n\t\tサイン波＋ピッチを下げる\n\t\t＋アタックを短くする\n\t\t＋ディケイ（リリース）を急激にする\n\n\t\tことでキックを作る。\n\t*/\n\ts += sin(t_r*f)\n\t*min(1., t_r*6.)\t//アタック\n\t*exp(-t_r*8.7)//*max(0, 1-t2*5.5)\n\t//*max(0,1-t_r)\n\t;\n\t\n    //音を出力する。\n\treturn s;\n}\n\n/*\n\tスネア。\n*/\nfloat snare(float time,float flag) {\n    \n    /*\n\t\t16ティックと4ティックを刻むようにした。\n\t*/\n\tvec4 sq = sqc( time, 16.);\n\t\n    //乱数\n\tfloat _seed = sq.y,_dec = _seed*7.5;\n    \n    /*\n\t\t4小節目の最後あたりでスネアロールを鳴らすときの定義。\n\t\tシーケンスからすべて計算。\n\t*/\n\tflag = (mod(sq.w,16.) == 15.)?1.0:flag;\n\tflag = (mod(sq.w,8.) == 7. && mod(sq.z, 16.) > 7.)?1.0:flag;\n\tflag = (mod(sq.w,4.) ==3. && mod(sq.z, 16.) > 13.)?1.0:flag;\n\t\n    /*\n\t\t\n\t*/\n\tfloat s = 0.;\n\t//s += (sq2.x > 4. )?(random(_seed).x*1.5 ) * 1.5 * exp(-_dec/4.5) : 0;\n    \n    //2・4拍目でスネアを強引に入れた。\n\ts = (mod(sq.z,8.) != 4. )?0.:(random(_seed).x*1.5 ) * 1.3 * exp(-_dec/3.);\n\n    /*\n\t\tスネアロールフラグがオンになっていたとき、\n\t\tスネアロールを行う。（前述のmod羅列）\n\t*/\n\ts = (flag ==1.0) ? (random(_seed).x*1.5 ) * 1.5 * exp(-_dec/4.5): s;\n\t\n\t//音量調整の上、音を格納。\n\treturn s*0.7;\n}\n\n/*\n\tベース。\n*/\nfloat bassline(float time,float semi ){\n    \n    /*\n\t\tベースラインの定義。\n\t\t汚い書き方だったのを直した。\n\t*/\n    \n    float ptn[16] = float[](0.,0.,12.,0.,\n        0.,0.,0.,12.,\n        0.,0.,0.,0.,\n        12.,0.,0.,0.);\n\n    //シーケンスの定義。\n\tvec4 sq = sqc( time, 16.);\n\t\n\t\n\t//記述コンパクト化のため、ノートの定義を雑にしてる\n\tfloat bs_note = -21.+semi;\n    \n    //音運びは何ティックでどの音に移動するという指定をしてる\n    /*\n\t「２小節経過するごとに音程を変更している」状態。\n\t*/\n\tbs_note =(mod(sq.x,4.) ==2.)?bs_note-7.:bs_note;\n\tbs_note =(mod(sq.x,4.) ==3.)?bs_note-5.:bs_note;\n\t\n\tint tick = int(sq.z);\n\tfloat note = (ptn[tick] != 44.)?bs_note + ptn[tick]:0.;\n\t\n    //最終的な音色のレンダリング\n\tfloat t1 = (ptn[tick]==44.)? 0. :(sin(tone(note)*time) );\n\n\tt1 = t1*min(1., sq.y*1.)\t//アタック\n\t//*(exp(-sq.y*2.));\t//フェードアウト\n\t*max(0., 1.-sq.y) //ディケイ\n\t;\n\t\n\treturn t1;\n}\n\n\n/*\n\tハイハット。\n\tノイズ鳴らす実装をコピペで作ったらノイズが載りすぎたため、\n\t急遽別の方法で実装したもの。\n*/\nfloat hh( float time){\n    \n    /*\n\t\t16ビートを刻む形。\n\t\t1小節に16回ハイハットを刻む。\n\t*/\n\n\tfloat ptn =0.;\n\t\n    /*\n\t\t16分音符で刻んでる。\n\t*/\n\tvec4 sq = sqc( time, 16.);\n\tfloat bs_note = -3.;\n\t\n\tfloat note = (ptn != 44.)?bs_note + ptn:0.;\n\t\n    /*\n\t\tレンダリング部分。\n\n\t\tFM音源の応用で、モジュレーションを急激な値にした。\n\t\tこうするとただの高音域ノイズになるので、\n\t\tハイハットっぽく聞こえる。\n\t*/\n\tfloat t1 = (ptn==44.)? 0. :(saw(pitch(note)*(time+sin(time*pitch(note/2.))) ) );\n\tt1 *=(exp(-sq.y*8.));\t//リリース\n\n\treturn t1;\n}\n\n/*\n\tクラッシュシンバル。\n\tノイズ関数で作ったらノイズが載りすぎたため、\n\t急遽別の方法で実装したもの。\n*/\nfloat crash( float time){\n    \n    /*\n\t\tシーケンス変数。\n\t*/\n\tvec4 sq = sqc( time, 1.);\n\t\n\tfloat bs_note = -3.;\n\t\tfloat note =200.;\n\t\n    /*\n\t\tレンダリング部分。\n\n\t\tFM音源の応用で、モジュレーションを急激な値にした。\n\t\tこうするとただの高音域ノイズになるので、\n\t\tクラッシュシンバルっぽく聞こえる。\n\t\t（ハイハットと周波数がかぶらないように調整済み）\n\t*/\n\tfloat t1 =(saw(pitch(note)*(sin(pitch(note/2.)*sq.y)) ) );\n\n    //4小節ごとにクラッシュシンバルを鳴らすようにしてる（それ以外はミュートの形）\n    t1 = ( mod(sq.w,4.)==0.)?t1:0.;\n    t1 *= max(0., 1.-sq.y*2.); //ディケイ\n\treturn t1;\n}\n\n/*\n\tまとめ部分。\n*/\nvec2 mainSound( in int samp, float time ) {\n\t\n    /*\n\t\t音楽のレンダリング結果を格納する変数。\n\t*/\n    vec2 s=vec2(0.);\n\t\n    /*\n\t\t移調するときの音の差分。\n\t*/\n\tfloat semi = 0.;\n    \n    //経過小節数検出のためのカウント（sqc関数作ってなかったときの名残）\n\tfloat count = floor(time/240.*BPM);\n    \n    //経過小節数等を計算するためのシーケンス変数\n\tvec4 sq =sqc(time,2.);\n\t\n    /*\n\t\t音量。\n\t*/\n\tfloat tr[10];\n\tfor( int i=0;i<9;i++){\n\t\ttr[i] = 0.0;\n\t}\n    \n\t//通常シーケンス===================================================\n\t\n    /*\n\t\t初期設定。\n\t*/\n\tfloat cr = 1.;\n\tfloat s_roll = 0.;\n\tfloat smt=0.;\n    \n    /*\n\t\t音量調整開始。\n\t\t何小節でどのパートをミュートするか等を指定。\n\t*/\n\tsemi = (count>1.)?semi-3.:semi;\n\ttr[0]=(count>1.)?1.:0.;\n\ttr[1] = (count>1.)?1.:0.;\n\ttr[6] = (count>11.)?1.:0.;\n\ttr[7] = (count>15.)?1.:0.;\n\ttr[8] = (count>18.)?1.:0.;\n\ttr[2] = (count>19.)?1.:0.;\n\t//tr[3] = (count>23)?1.:0.;\n\t\n\t//転調パート\n    /*\n\t\t31小節で全体から2音下げ\n\t\t39小節で全体で1音（半音かな？）\n\t\t47小節で是体で2音上げ\n\t*/\n\tsemi = (count>31.)?semi-2.:semi;//\n\tsemi = (count>39.)?semi+1.:semi;//1:13\n\tsemi = (count>47.)?semi+2.:semi;//1:29\n\n    /*\n\t\tミュート。\n\t\tドラムをミュートしてる。\n\t*/\n\ttr[6] =(count>59.)?0.:tr[6];\n\ttr[7] =(count>59.)?0.:tr[7];\n\ttr[8] =(count>59.)?0.:tr[8];\n\ttr[2] =(count>60.)?0.:tr[2];\n\t\n    /*\n\t\t全部の楽器ミュートした。\n\t*/\n\ttr[0]=(count>67.)?0.:tr[0];\n\ttr[1] = (count>67.)?0.:tr[1];\n\t\n\n\t//通常シーケンス===================================================\n\t\n    //パッド音色。\n\ts += tr[0]*pad(time, semi)*vec2(.9,.4);\n\ts += tr[0]*pad(time+.24, semi)*vec2(.3,.8);\n\ts += tr[0]*pad(time+.48, semi)*vec2(.7,.7);\n\n    //ベースライン（２トラック分突っ込んでディレイさせてる）\n\ts += tr[1]*bassline(time, semi)*vec2(.55);\n\ts += tr[1]*bassline(time+.008, semi)*vec2(.28);\n\t\n    //ハイハット。\n\ts += tr[7]*hh(time)*vec2(.5);\n    \n    //クラッシュシンバル\n\ts += tr[2]*crash(time)*vec2(.2,.4);\n\t\n    //キック\n\ts += tr[6]*kick(time)*vec2(1.)*.85;\n    \n    //スネア\n\ts += tr[8]*snare(time,s_roll)*vec2(.2,.8)*.5;\n\n    //通常シーケンスおわり=============================================    \n    \n\t/*\n\t\tフェードイン・アウト。\n\t\t急遽実装したので全体を強引にフェードイン・アウトしている\n\n\t\t具体的には、\n\t\t「何小節目で音量をどのくらいにするか」を指定している。\n\n\t\tよって最終的な出力は、\n\t\t想定音量*fade_inの数値（0～1）*fade_outの数値（0～1）\n\t\tという形。\n\t*/\n\tfloat fade_in = time*.05;\n\tfade_in = (fade_in>.8)?.8:fade_in;\n\n\tfloat fade_out =1.;\n\tif(count==67.){\n\t\t\n\t\tfade_out = (sq.x==3.)?(1.-sq.y):fade_out;\n\t}\n\tfade_out = (count>67.)?0.:fade_out;\n\n    /*\n\t\t最終的な出力。\n\t*/\n\treturn vec2(s)* fade_in*fade_out*1.5;\n}\n","name":"Sound","description":"","type":"sound"}]}