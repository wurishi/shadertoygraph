{"ver":"0.1","info":{"id":"clSyD1","date":"1691779549","viewed":106,"name":"D8nut","username":"Burinir","description":"A raymarching based experiment\nInpired by [TUT] Twisted Toroid by BigWIngs","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","donut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sqr(float a){ return a*a; }\n\n//https://en.wikipedia.org/wiki/Lemniscate_of_Bernoulli\nvec3 figure8(float t){\n    float a = 1.5, st= sin(t), ct = cos(t);\n    return vec3(a*ct/(1.+sqr(st)),0,a*st*ct/(1.+sqr(st)));\n    //return vec3(2. * cos(t),0,sin(2.*t));\n}\n\nfloat sawtooth(float a){ return a*(1.-sqr(sqr(sqr(a))));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float pi = 3.14159265359;\n    \n    float t = 1.*iTime + 11.5;\n    float tC = t*2.*pi/20.;\n    vec3 rC = figure8(tC);\n    //vec3 rC = vec3(-2,0,0);\n    \n    vec3 lookat = figure8(tC + .5);\n    float zoom = .5;\n    \n    vec3 lookDir = normalize(lookat-rC),\n        //while we are at the ends of the 8, we want to tilt inwards\n        dX = normalize(cross(normalize(vec3(-cos(t/40.),1,0)), lookDir)),\n        dY = cross(lookDir, dX),\n        c = rC + lookDir * zoom,\n        i = c + uv.x * dX + uv.y * dY,\n        rd = normalize(i-rC);\n        \n    \n    // background\n    vec3 col = vec3(0);\n    \n    vec3 ro = rC;\n    float dist1 = 0.,dist2 = 0., bigR = 1., smolR = .9;;\n    for(int i = 0; i < 200; i++){\n        vec2 center1 = vec2(1,0);\n        vec2 center2 = vec2(-1,0);\n        dist1 = -sqrt(sqr(length(ro.xz - center1) - bigR) + sqr(ro.y)) + smolR;\n        dist2 = -sqrt(sqr(length(ro.xz - center2) - bigR) + sqr(ro.y)) + smolR;\n        if(max(dist1, dist2) <= .01){\n        float x1,y1,x2,y2,x,y;\n            float tG = t/5. ;\n            tG = sawtooth(mod(tG,2.)-1.)*3. + .8;\n            \n            //float tG = -t*2./pi + pi;\n            //tG = sin(tG) + 1./2. *sin(2.*tG) + 1./3. *sin(3.*tG) + 1./4. *sin(4.*tG) + 1./5. *sin(5.*tG) + 1./6. *sin(6.*tG) + 1./7. *sin(7.*tG) + 1./8. *sin(8.*tG) + 1./9. *sin(9.*tG);\n            //tG *= 2.;\n            \n            x1 = atan(ro.x+1., ro.z) + tG-pi/2.;\n            x2 = atan(ro.x-1., ro.z) - tG + pi/2.;\n            y1 = atan(length(ro.xz-center1)-1., ro.y);\n            y2 = atan(length(ro.xz-center1)-1., ro.y);\n            \n            x = mix(x1,x2, smoothstep(-.9,.9,ro.x));\n            y = mix(y1,y2, smoothstep(-1.,.1,ro.x));\n            \n            float px = cos(20.*x);\n            float py = cos(20.*y);\n            \n            \n            float bands = cos(y*10.+x*10.);\n            float bandwidth = .8*sin(t) - .3;\n            float innerBandwidth = .3 * sin(t/3.56) + .7;\n            float innerBands =  smoothstep(bandwidth + innerBandwidth,.2 + bandwidth + innerBandwidth,bands);\n            float bandlines = smoothstep(bandwidth,.2 + bandwidth,bands) - innerBands;\n            \n            vec3 bandCol = 0.5 + 0.5*cos((y*10.+x*10.)/10.+vec3(0,2,4));\n            \n            /*\n            float gliders = cos(-y*3. + x*3.);\n            gliders = smoothstep(.95,.99,gliders);\n            //want only gliders between bands\n            float gliderThinning = .8;\n            //gliders *= smoothstep(gliderThinning+innerBandwidth,.2 +  gliderThinning + innerBandwidth,bands);\n            gliders *= smoothstep(gliderThinning+bandwidth + innerBandwidth,.2 + gliderThinning+bandwidth + innerBandwidth,bands);;\n            */\n            col = bandlines * bandCol; \n            break;\n        }\n       \n        dist1 = max(dist1, dist2);\n        dist1 = max(0.005, dist1);\n        ro += rd*0.5 * dist1;\n    }\n    \n        \n\n   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}