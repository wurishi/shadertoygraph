{"ver":"0.1","info":{"id":"7lGyDz","date":"1691006535","viewed":117,"name":"NOOT NOOT","username":"Ayoub","description":"Raymarching Shader of the Noot Noot meme.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Main Raymarching loop params, max distance, hit distance, and max iterations\n#define MD 100.0\n#define HD 0.01\n#define MI 100\n#define pi 3.141592653589\n\n\nconst float focal = 3.0, fov = 1.0;\nstruct Material\n{\n    vec3 color; //Diffuse coolor\n    float metal; //controls how metallic is this material/ if this is an emissive material, we use this as the internsity\n};\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opTx( in vec3 p, in mat3 t)\n{\n    return ( inverse(t)*p );\n}\nmat3 rotX(float a)\n{ return mat3(vec3(1.0,0,0),vec3(0,cos(a),sin(a)),vec3(0, -sin(a), cos(a))); }\n\nmat3 rotY(float a)\n{ return mat3(vec3(cos(a),0,-sin(a)),vec3(0,1.0,0),vec3(sin(a),0, cos(a))); }\n\nmat3 rotZ(float a)\n{ return mat3(vec3(cos(a),sin(a),0),vec3(-sin(a), cos(a), 0), vec3(0,0,1.0)); }\n\n\nmat3 rot(float x, float y, float z) { return rotX(x)* rotY(y)* rotZ(z); }\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Uncomment this and recompile to control scene witht the mouse\n//#define control_scene 0\n\n\n\n//Materials\n#define num_materials 5\nconst Material[num_materials] materialut = Material[num_materials](\nMaterial(vec3(0.2), 0.03), // black diffuse\nMaterial(vec3(0.0), 0.9), // black \nMaterial(vec3(0.95), 0.1), // white\nMaterial(vec3(0.9, 0.2, 0.2), 0.03), //orange\nMaterial(vec3(0.1, 0.1, 0.8), 0.0) //blue\n\n);\n\n//Constants\nconst float LightIntensity = 4.0;\nconst vec3 LightColor = vec3(1.0,1.0,1.0);\nconst float tt = 4.5f; //Transition time\nconst float sd = 9.0f; //Sequence duration\n\n//Vars initialized once at the start\nuvec2 coord;\nbool cartoon = true;\nfloat time = 0.0;\n\nfloat sdfLight(vec3 p)\n{\n    //One plane as light source in the scene\n    p.x = abs(p.x);\n    p-= vec3(8.0, -4,4.0);\n    p*= rotY(-1.0);    \n    p*= rotX(-1.0);\n\n    float d = sdBox( p, vec3(2.2, 5.2,0.01));\n    return (d);\n}\n\n\nfloat scene(in vec3 p, out int mat)\n{\n    if (cartoon)\n        p.z -= 10.0f;\n    else\n        p.z+= 0.5 + mod(iTime, tt) / tt;\n    \n    p.z -= 7.0f;\n    \n#ifdef control_scene\n    vec2 mo = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;\n    vec2 xyrot = mo * 3.0*pi;  //Used in rotating the camera/light\n    //Rotate scene\n    mat3 crot = rotX(-0.05*xyrot.y) * rotY(0.05*xyrot.x);\n    p = opTx(p, crot);\n#else\n    p *= rotX(0.25*float(!cartoon))*rotY(0.25*float(cartoon));\n#endif\n    \n    //Head\n    float noi = 0.0015*noise( 95.0*p.xy);\n    vec3 q = p * vec3(0.8,1.0,1.0);\n    float d = sdSphere(q, 1.7) + noi;\n    mat = int(cartoon);\n    \n    //Body\n    vec3 c = vec3(0.0,-4.2,0.0);\n    q = p * vec3(1.0,0.8,1.0) - c;\n    float tmp = sdSphere(q,3.);\n    if(tmp < d)\n    {\n        d = tmp;\n    }\n    \n    //wings\n    if (cartoon)\n    {\n        c = vec3(3.2, -4.0, 0.0);\n        q = vec3(abs(p.x), p.yz)  - c;\n        q *= rotZ(-0.9);\n        q *= rotY(0.0);\n\n        tmp = sdEllipsoid(q, vec3(2.,0.15,1.0));\n        if(tmp < d)\n        {\n            d = tmp;\n            mat = 1;\n        }\n    \n       //belly\n        c = vec3(0.0,-4.0,-1.5);\n        q = p * vec3(1.0,0.8,1.0) - c;\n        tmp = sdSphere(q,2.);\n        if(tmp < d)\n        {\n            d = tmp;\n            mat = 2;\n        }\n    }\n\n    //animation: Too lazy to animate the full sequence\n    float t = time * step(time,2.2) * step(2.0, time);\n    float eb = mix(0.4, 0.04, abs(sin(t*17.0)));    \n    float es = mix(0.3, 0.03, abs(sin(t*17.0)));\n\n    //eyes\n    c = vec3(1.0, .0, -1.45);\n    q = vec3(abs(p.x), p.yz)  - c;\n    q *= rotY(-0.45);\n    tmp = sdEllipsoid(q, vec3(0.4,eb,0.1));\n    if(tmp < d)\n    {\n        d = tmp;\n        mat = 2;\n    }\n    \n    q.x += 0.02;\n    q.y += 0.02;\n    tmp = sdEllipsoid(q, vec3(0.3,es,0.15));\n    if(tmp < d)\n    {\n        d = tmp;\n        mat = 1;\n    }\n    \n    //beak\n    c = vec3(0.0, -0.7, -1.5);\n    q = p - c;\n    q*=rotY(0.3); //nince tilt\n    vec3 bu = vec3(0.7,0.3,0.7);\n    vec3 bl = vec3(0.75,0.2,0.7);\n    tmp = sdEllipsoid(q, bl);\n    q *= rotX(-0.4);\n    float tmp2 = sdEllipsoid(q - vec3(0, 0.2, 0.0), bu);\n    tmp = opSmoothUnion(tmp, tmp2, 0.2);\n\n    if(tmp < d)\n    {\n        d = tmp + noi;\n        mat = 3 - int(cartoon);\n\n    }\n\n    //bg\n    if (!cartoon)\n    {\n        q = p;\n        q.z += 7.0;\n        tmp = sdPlane(q, vec3(0.0,0.0,-1.0), 30.0);\n        if(abs(tmp) < abs(d))\n        {\n            d = tmp;\n            mat = 4;\n        }\n    }\n    else\n    {\n        float tnoi = noise( float(int(floor(iTime*2.0)) % 6) + p.zy);\n        d = d - 0.03*tnoi;\n    }\n\n    return d;\n}\n\nbool TraceLight(vec3 r, vec3 p)\n{\n    float d = 0.0;\n    float td = 0.0;\n    for(int i = 0; i <= MI; i++)\n    {\n        d = sdfLight(p);\n        \n        if(d <= HD)\n        {\n            return true;\n        }\n        \n        td+=d;\n        p += r*d;\n        \n        if(td > MD)\n        {\n            return false;\n        }\n    }\n    return false;\n}\n\n///////////// Lighting\n//Specular reflection: takes position, reflected dir and material as input, returns specular reflection color\nvec3 specular(vec3 p, vec3 ref)\n{\n    \n    if(TraceLight(ref, p))\n    {\n        return  LightIntensity*LightColor;\n    }\n    else\n    {\n        return vec3(0.0);\n    }\n}\n\n\n#define DIFF_SN 10u\n//Diffuse : takes position, normal and material as input, returns diffuse color\nvec3 diffuse(vec3 p,vec3 n, Material mat)\n{\n    \n    vec3 fcol = vec3(0.0); // final diffuse contribution\n    float d;\n    for(uint j = 0u; j < DIFF_SN; j++)\n    {\n        vec3 col = vec3(.0);\n        uint seed = uint(j) + uint(DIFF_SN)*uint(coord.x )+  uint(iResolution.x)*uint(DIFF_SN)*uint(coord.y);        \n\t\tvec3 rand =  (hash3( seed )  - vec3(0.5))*2.0;\n        vec3 r = normalize(n + 0.4*rand );\n        if(TraceLight(r, p))\n        {\n           col=  mat.color*LightIntensity*LightColor;\n        }\n        fcol = mix(fcol, col, 1.0 / (float(j) + 1.0));\n    }\n    return fcol;\n}\n\nfloat sceneGeo(vec3 p)\n{\n    int mat;\n    return scene(p, mat);\n}\n\n//Estimates normals from SDFs\nvec3 getNormal(vec3 p)\n{\n\tvec3 offset = vec3(0.001,.0,.0);\n\tfloat ox = sceneGeo(p + offset.xyy) - sceneGeo(p - offset.xyy) ;\n\tfloat oy = sceneGeo(p + offset.yxy) - sceneGeo(p - offset.yxy) ;\n\tfloat oz = sceneGeo(p + offset.yyx) - sceneGeo(p - offset.yyx) ;\n\t\n    return normalize(vec3(ox, oy, oz));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = mod(iTime, sd);\n    cartoon  = time <= tt;\n\n    //Initialization\n    coord = uvec2(fragCoord);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(0.0,0.0,1.0);\n    \n    //Camera setup\n    vec3 cc = vec3(0.0);\n    vec3 ro = vec3(fov*uv, focal);\n    \n    //Raymarching init\n    float d, td = 0.0;\n    vec3 p = ro;\n    vec3 ray = normalize(ro - cc);\n    int mat = 4;\n    bool edge = false;\n    \n    for(int i = 0; i <= MI; i++)\n    {\n        d = (scene(p, mat));\n        \n        if(d <= HD)\n        {\n            if (cartoon)\n                col = materialut[mat].color;\n            else\n            {\n                vec3 normal = getNormal(p);\n                vec3 amb = materialut[mat].color;\n                vec3 spec= specular(p, reflect(normalize(ray), normal));\n                vec3 diff = diffuse(p, normal, materialut[mat]);\n                col = mix(diff, spec, materialut[mat].metal) + 0.13*amb;\n            }\n            break;\n        }\n        else if(d <= (HD + 0.05))\n        {\n            edge = true;\n        }\n        \n        td+=d;\n        p += ray*d;\n        \n        if(td > MD)\n        {\n            if (cartoon)\n                col = edge ? vec3(0.0) : vec3(1.0);\n            break;\n        }\n    }\n\n    fragColor = vec4(col ,1.0);\n    return;\n\n}","name":"Buffer A","description":"","type":"buffer"}]}