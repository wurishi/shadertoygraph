{"ver":"0.1","info":{"id":"4Xf3Dn","date":"1711897210","viewed":20,"name":"red spheere in dark bg","username":"Samuix","description":"simple red sphere in dark bg without light sources or shadows","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["1sttp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Photorealistic rendering course - Step 01b\n// By Alan \"Latex\" Savary.\n//\n// Next lesson: \"[Step01c] Wrong disk 2D shape\"\n//\n\n//##############################################################################################\n\n// If we use the size of the screen in pixels to find its center and its height,\n// then we can easily display a disk of radius 1 that is at the center of the\n// screen and touching the up & bottom borders.\n//\n// To do that, we can compute the position of the center of the screen in pixels,\n// and half of the height of the screen in pixel, all that in order to be able to\n// draw the disk correctly.\n//\n// However, in such a case, the radius of the disk is not used, and is not really of value 1.\n\nconst vec3 cameraPos = vec3(6, 4, -5);\nconst vec3 cameraTarget = vec3(3, 1, -8);\nconst float cameraFovY = 80.0;\n\nconst vec3 offsetCam = vec3(0, 1, 2);\nconst vec3 spherePos = cameraTarget + offsetCam;\nconst float sphereRadius = 1.0;\nfloat ratio = 300.0;\nfloat depth = 1.0;\n\n//##############################################################################################\n\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    \n    //axes of the camera\n    vec3 cz = normalize(cameraPos - cameraTarget); // camera looking at, on the z axe so -> its the z axe for the rayDir\n    vec3 cx = normalize(cross(cz,vec3(0,1,0))); // X axe determined by a temporary axe and cross product\n    vec3 cy = normalize(cross(cz,cx)); // Y axe calculed by cross product\n    \n    // focal distance\n    float f = depth/(tan(cameraFovY/2.0));\n    \n    // rayPos -> where the ray start (from the cam)\n    rayPos = cameraPos; // from where the ray starts\n\n   // pixCoord = vec2(f*pixCoord.x/,f*pixCoord.y)\n    //rayDirpixCoord\n    vec3 PO = f*cz;\n    vec3 OS = pixCoord.x*cx - pixCoord.y*cy;\n    \n    rayDir = normalize(PO + OS);\n}\n\nbool raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius)\n{\n\n\n    vec3 CA = rayPos - spherePos;\n    vec3 AC = spherePos - rayPos;\n\n    // R² - ((AC.AC) - v²)\n    // v² = dot(CA,rayDir)*dot(CA,rayDir)\n       \n       \n    //bool res = (dot(rayDir,rayDir) + 2.0*dot(CA,rayDir)+dot(CA,CA) - sphereRadius) < 0.0 ;\n\n    //bool res = (sphereRadius * sphereRadius - dot(CA,CA) + dot(CA,rayDir)*dot(CA,rayDir)) > 0.0;\n    \n    float V = dot(AC,rayDir)*dot(AC,rayDir);\n    bool res = sphereRadius * sphereRadius - (dot(AC,AC) - V) > 0.0;\n    \n    return res;\n}\n\nvec2 apply_transform(vec2 point)\n{\n    //return vec2((iResolution.x/2.0 - point.x)/ratio, (iResolution.y/2.0 - point.y)/ratio);\n    return vec2((iResolution.x/2.0 - point.x)/iResolution.y, (iResolution.y/2.0 - point.y)/iResolution.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayPos, rayDir;\n    vec2 fragCoord_mid = apply_transform(fragCoord.xy);\n    \n    computeCameraRayFromPixel(fragCoord_mid, rayPos, rayDir);\n    \n    bool res = raySphere(rayPos, rayDir, spherePos, sphereRadius);\n    \n    fragColor = vec4((res ? 1.0 : 0.0), 0, 0, 1);\n}\n\n","name":"Image","description":"","type":"image"}]}