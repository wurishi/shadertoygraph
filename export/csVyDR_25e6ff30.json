{"ver":"0.1","info":{"id":"csVyDR","date":"1695988016","viewed":85,"name":"Q1 FEM v3","username":"athibaul","description":"Simulation of wave propagation in a bent tube. Make sure you wait until the wave reaches the bend...!","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["q1","finiteelements"],"hasliked":0,"parentid":"cddyDB","parentname":"Q1 FEM v2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Warped domain finite elements\n//\n\n// This technique, based on mass-lumped Q1 square finite elements \n// and the leap-frog scheme, allows to simulate wave propagation\n// in domains whose shape is a warped rectangle.\n//\n// Several examples of warped domains are shown (see Common tab).\n// For such a case, this method should be more accurate than na√Øve FDTD,\n// since the scheme correctly takes into account the curved boundary.\n//\n// However, like FDTD, the scheme has a stability condition, which becomes more and\n// more stringent as the deformation gets more extreme.\n// This makes it necessary to use a smaller time step, leading to\n// a slower simulation, if there is either \n// a highly compressed region, or strongly warped elements.\n// \n// Both traits are characterized by the diameter of the inscribed circle\n// in each cell, which in turn is related to the smallest eigenvalue of dfdx.\n// If any of the cells are \"thin\" in any direction, then we will have to slow down.\n// In other words, our deformation has to be as \"smooth\" as possible to be admissible.\n\n// You can change the resolution of the simulation in the \"Common\" tab.\n// Low resolution is faster, but less accurate (wave dispersion + spurious reflections)\n\n//#define SHOW_UNWARPED\n\n#define GRID_OVERLAY\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pq = ivec2(fragCoord);\n    \n    #ifdef SHOW_UNWARPED\n    fragColor = texelFetch(iChannel0, pq, 0) * 0.5 + 0.5;\n    return;\n    #endif\n    \n    //ivec2 pq = ivec2(fragCoord * 0.02 + 98.); // Zoom on pixel (100,100)\n    //pq.y = 99;\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    uv = 0.5+0.5*uv;\n    \n    // Look up the texture using the inverse mapping\n    //Enable SHOW_UNWARPED or comment out this line \n    // to see the rectangular domain\n    // in which the actual simulation takes place!\n    uv = calcFinv(uv);\n    // Of course, the result will look weird, since\n    // the wave propagation in that domain is anisotropic\n    // due to the change of variables.\n    \n    //uv *= step(1.,float(pq.x));\n    \n    //vec3 col = vec3(uv,0);\n    //fragColor = vec4(col, 0);\n    \n    //float v = texelFetch(iChannel0, pq, 0).g;\n    \n    //fragColor = vec4(step(uv.y, v));\n    \n    //ivec2 pq_scaled = ivec2(uv.x*NX + uv.y*NY);\n    //float v = texelFetch(iChannel0, pq_scaled, 0).g;\n    vec2 uv_small = uv * vec2(NX, NY) / iResolution.xy;\n    float v = texture(iChannel0, uv_small).g;\n    vec3 w = 6.28*v + vec3(-0.5,0.,0.5);\n    vec3 col = 0.5-0.5*(1.-.5*w*w);\n    \n    \n    // Overlay the grid of warped uv coordinates\n    #ifdef GRID_OVERLAY\n    float checker = mod(floor(uv.x*20.)+floor(uv.y*20.),2.);\n    col = mix(col, vec3(0,1,0), 0.1*checker);\n    #endif\n    \n    \n    if(uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) {\n        col = vec3(0.2);\n    }\n    \n    \n    \n    fragColor = vec4(sqrt(col),0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat isInGrid(float p, float q) {\n    return step(0., p) * step(p, NX-2.) \n         * step(0., q) * step(q, NY-2.);\n}\n\nfloat tau(float a, float b, float x, float y) {\n    x = (a < 0.5) ? 1.-x : x;\n    y = (b < 0.5) ? 1.-y : y;\n    return x*y;\n}\n\nvec2 dtau(float a, float b, float x, float y) {\n    vec2 v = vec2(1);\n    x   = (a < 0.5) ? 1.-x : x;\n    y   = (b < 0.5) ? 1.-y : y;\n    v.x = (a < 0.5) ?  -1. : 1.;\n    v.y = (b < 0.5) ?  -1. : 1.;\n    return v * vec2(y,x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 pq = ivec2(fragCoord);\n    float p = float(pq.x), q = float(pq.y);\n    if(p >= NX || q >= NY) {\n        fragColor = vec4(0.);\n        return;\n    }\n    ivec2 N = ivec2(NX, NY);\n    mat2 invN = mat2(1./float(N.x),0,0,1./float(N.y));\n    vec2 uv = invN * vec2(pq);\n    \n    \n    // Calculate transformation of the space\n    vec2 f = calcF(uv);\n    mat2 df = calcDf(uv);\n    mat2 dF = df * invN;\n    float detdf = determinant(dF);\n    mat2 invdF = inverse(dF);\n    // Calculate the lumped mass\n    float mass0 = detdf * 0.25;\n    float mass = 0.;\n    \n    for(float p_=p-1.; p_<=p; p_++) {\n        for(float q_=q-1.; q_<=q; q_++) {\n            mass += isInGrid(p_,q_) * mass0;\n        }\n    }\n    \n    float un = texelFetch(iChannel0, ivec2(p,q), 0).x;\n    float unm1 = texelFetch(iChannel0, ivec2(p,q), 0).y;\n    \n    // Calculate the negative Laplacian of the data with a finite element method\n    // For performance it would be preferable to pre-calculate the 3x3 stencil of\n    // each cell, and only perform a 3x3 convolution at each time step.\n    // I am not sure how to do that easily in Shadertoy, so I did not bother\n    // doing it.\n    float lapl = 0.;\n    for(float pj=p-1.; pj<=p+1.; pj++) {\n        for(float qj=q-1.; qj<=q+1.; qj++) {\n            // Data value at node j\n            float uj = texelFetch(iChannel0, ivec2(pj,qj), 0).x;\n            for(float pk=max(p-1.,pj-1.); pk<=min(p,pj); pk++) {\n                for(float qk=max(q-1.,qj-1.); qk<=min(q,qj); qk++) {\n                    // Calculate the contribution of each neighboring cell\n                    float lapl0 = 0.0;\n                    // Quadrature over the nodes\n                    for(float a=0.; a<=1.; a++) {\n                        for(float b=0.; b<=1.; b++) {\n                            mat2 df_ab = calcDf(vec2(pk+a,qk+b)/vec2(N)) * invN;\n                            float detdf_ab = determinant(df_ab);\n                            vec2 dtaui = dtau(p  - pk, q  - qk, a, b);\n                            vec2 dtauj = dtau(pj - pk, qj - qk, a, b);\n                            mat2 invD = inverse(df_ab);\n                            //lapl0 += dot(invD * dtaui, invD * dtauj) * detdf_ab;\n                            lapl0 += dot(dtaui * invD,dtauj*invD) * detdf_ab;\n                        }\n                    }\n                    lapl += 0.25 * isInGrid(pk,qk) * lapl0 * uj;\n                }\n             }\n        }\n    }\n    \n    float c0 = 1.0;\n    float c02 = c0*c0;\n    // If the simulation blows up, reduce the following number\n    float dt = 1.2/float(N.x);\n    float dt2 = dt*dt;\n    float unp1 = 2.*un - unm1 - dt2*c02*lapl/mass * 0.5;\n    \n    \n    // Initial impulse\n    if(iFrame == 0) {\n        float d0 = f.y < 0.5? f.x : 1.0;\n        unp1 = 5.*exp(-d0*d0 * 3000.);\n        //unp1 = step(length(vec2(pq)-100.),1.e-6);\n        un = unp1;\n    }\n    \n    // Oscillating source\n    /*\n    if(iFrame >= 0) {\n        #if WARP_TYPE<=2\n        vec2 d0 = f - vec2(0.2,0.5);\n        float amp = 10.;\n        #elif WARP_TYPE==3\n        // Line source\n        vec2 d0 = vec2(f.x,0.);\n        d0.y = f.y > 0.5 ? 1. : 0.;\n        float amp = 3.0;\n        #endif\n        float t = float(iFrame)*dt;\n        unp1 += amp*dt*exp(-dot(d0,d0) * 3000.) * cos(t*100.)\n        * smoothstep(1.,0.9,t);\n    }*/\n    \n    \n    //vec3 col = vec3(0.5 + lapl);\n    vec3 col = vec3(unp1, un, 0);\n    //vec3 col = vec3(un, 0.5 + 0.5 * lapl, 0);\n    \n    fragColor = vec4(col, 0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Different warpings\n// 0 : no warping\n// 1 : vertical scaling\n// 2 : complex mapping\n// 3 : U-bend\n\n// High resolution\n//#define NX 800.\n//#define NY 246.\n\n// Medium resolution\n#define NX 512.\n#define NY 158.\n\n// Low resolution\n//#define NX 256.\n//#define NY 79.\n\n\n#define WARP_TYPE 3\n\n\n\n\n\n#define PI 3.1415926535\n\n// Parameters for WARP_TYPE 1\n#define HA 0.25\n#define H0 (1.-(HA))\n#define HB (2.*PI)\n#define HC 1.0\n\n// Parameters for WARP_TYPE 3\n// Inner radius of the bend\n#if WARP_TYPE==3\n#define R_IN 0.1\nconst float a = 0.5/(1. + PI*R_IN);\n#endif\n\n\n\nvec2 cinv(vec2 z) {\n    return vec2(z.x, -z.y) / dot(z,z);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nvec2 calcF(vec2 uv) {\n    // Transform from the (0,1)^2 square to an arbitrary shape\n    \n    // Non-uniform compression of the vertical scale\n    #if WARP_TYPE==0\n    return uv;\n    #elif WARP_TYPE==1\n    float h = H0 + HA*sin(HB*uv.x+HC);\n    return vec2(uv.x, uv.y*h);\n    #elif WARP_TYPE==2\n    uv.x += 1.;\n    uv = vec2(uv.x, -uv.y) / dot(uv,uv);\n    uv *= 2.;\n    uv += vec2(-1,1);\n    return uv;\n    #elif WARP_TYPE==3\n    // U-bend domain\n    // Split the rectangle into three regions\n    if(uv.x < a) {\n        // First straight region\n        uv.x *= 0.5 / a;\n        uv.y *= 0.5 - R_IN;\n        uv.y += 0.5 + R_IN;\n        return uv;\n    } else if (uv.x > 1.0 - a) {\n        // Second straight region\n        uv.x -= 1.0-a;\n        uv.x /= a;\n        uv = 1.-uv;\n        uv.x *= 0.5;\n        uv.y *= 0.5-R_IN;\n        return uv;\n    } else {\n        // Bent region\n        uv.x -= a;\n        uv.x /= 1.-2.*a;\n        float r = R_IN + (0.5 - R_IN) * uv.y;\n        float theta = PI * (0.5 - uv.x);\n        return vec2(0.5,0.5) + vec2(cos(theta), sin(theta)) * r;\n    }\n    #endif\n}\n\nvec2 calcFinv(vec2 uv) {\n    // Inverse transform of f\n    #if WARP_TYPE==0\n    return uv;\n    #elif WARP_TYPE==1\n    float h = H0 + HA*sin(HB*uv.x+HC);\n    return vec2(uv.x, uv.y/h);\n    #elif WARP_TYPE==2\n    uv -= vec2(-1,1);\n    uv *= 0.5;\n    uv = vec2(uv.x, -uv.y) / dot(uv,uv);\n    uv.x -= 1.;\n    return uv;\n    #elif WARP_TYPE==3\n    // Inverse calculation of U-bend\n    if(uv.x < 0.5 && uv.y > 0.5) {\n        // First straight region\n        uv.y -= 0.5+R_IN; uv.y /= 0.5-R_IN; uv.x /= 0.5/a; return uv;\n    } else if(uv.x < 0.5 && uv.y < 0.5) {\n        uv.y/=0.5-R_IN;uv.x*=2.;uv=1.-uv;uv.x=a*uv.x+1.0-a;return uv;\n    } else {\n        uv-=vec2(0.5);\n        float r = length(uv);\n        float theta = atan(uv.y, uv.x);\n        uv.y = (r - R_IN) / (0.5 - R_IN);\n        uv.x = 0.5 - theta/PI;\n        uv.x *= 1.-2.*a; uv.x += a;\n        return uv;\n    }\n    #endif\n}\n\nmat2 calcDf(vec2 uv) {\n    #if WARP_TYPE==0\n    return mat2(1,0,0,1);\n    #elif WARP_TYPE==1\n    float h = H0 + HA*sin(HB*uv.x+HC);\n    float dhdx = HA*HB*cos(HB*uv.x+HC);\n    vec2 dfdx = vec2(1, uv.y*dhdx);\n    vec2 dfdy = vec2(0, h);\n    return mat2(dfdx, dfdy);\n    #elif WARP_TYPE==2\n    // TODO\n    //return mat2(1,0,0,1);\n    uv.x += 1.;\n    vec2 duv = -cinv(cmul(uv,uv));\n    duv *= 2.;\n    return mat2(duv.x,duv.y,-duv.y,duv.x);\n    #elif WARP_TYPE==3\n    // Calculate using finite differences\n    float eps = 0.5 / NX;\n    vec2 fxm = calcF(uv + vec2(-eps,0));\n    vec2 fxp = calcF(uv + vec2( eps,0));\n    vec2 fym = calcF(uv + vec2(0,-eps));\n    vec2 fyp = calcF(uv + vec2(0, eps));\n    return mat2(fxp-fxm, fyp-fym) / (2.*eps);\n    #endif\n}","name":"Common","description":"","type":"common"}]}