{"ver":"0.1","info":{"id":"7dfyRM","date":"1641845477","viewed":445,"name":"Quad precision Mandel explorer","username":"dahart","description":"MOVE: click to center a point     OR     arrow keys. \nZOOM in/out: z/x    OR     shift + up/down\ndec/Inc iterations: i/I       dec/Inc samples-per-pixel: s/S       \nRESET view: r       CYCLE preset views: v          toggle display of coordinate: d","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot","interactive","numbers","complex","precision","quad","progressive","ulam","binary128"],"hasliked":0,"parentid":"7sXyR8","parentname":"study mand q1"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThis shader is for studying precision, and interactively navigating the Mandelbrot set.\n\nBuffer A implements a \"quad\" precision (128-bit) floating point number.\nNot identical to IEEE binary128, but similar.\n\nThis certainly is not the best or fastest way to deep zoom into the Mandel.\nBetter strategies are fixed point & perturbation theory.\n\nMOUSE & KEYBOARD controls:\n\nMOVE: click to center a point  -OR-  arrow keys. \nZOOM: z/x                      -OR-  shift + up/down\n\nZoom factor is 2x, or the equivalent of 1 bit of precision. \nSo you can get a feel for the precision required for any given view\nby counting how many times you zoom out to get back to the \"home\" view outermost Big Mandel.\n\ndec/Inc iterations:             i/I   \ndec/Inc samples-per-pixel:      s/S   \ntoggle display of coordinates:  d\nRESET view:                     r    (also resets samples & iterations)\ncycle predefined views:         v\nmirror the view:                m\n\nThere is a small safe/dead click zone in the bottom left corner to be able to click without moving the view.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mandel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 hud = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    fragColor = comp(mandel, premult(hud));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec4 UI( in vec2 fragCoord, options opts )\n{    \n    vec4 color = vec4(0);\n\n    ivec2 ifc = ivec2(fragCoord);\n    color = texelFetch(iChannel0, ifc, 0);\n    \n    int nr = min(0, iFrame);\n\n    // (0,0)(1,0) = centerx (top bits of each channel mantissa to reconstruct 128 bits)\n    // (2,0)(3,0) = centery (top bits of each channel mantissa to reconstruct 128 bits)\n    // (4,0)      = size    (float) in the x channel\n    // (5,0)      = (iters (sign=hud), samples, date(secs), view) (int, stored as float)\n    // (6,0)      = (iResolution.x, iResolution.y, blockStart, blockEnd)\n    \n    bool restartRender = false;\n\n    // restart render if the resolution changes (fullscreen, etc.)\n    if (ivec2(opts.resolution) != ivec2(iResolution.xy)) restartRender = true;\n    \n    bool isLtKeyDown    = texelFetch(iChannel1, ivec2(LT_KEY, 1), 0).x > 0.;\n    bool isUpKeyDown    = texelFetch(iChannel1, ivec2(UP_KEY, 1), 0).x > 0.;\n    bool isRtKeyDown    = texelFetch(iChannel1, ivec2(RT_KEY, 1), 0).x > 0.;\n    bool isDnKeyDown    = texelFetch(iChannel1, ivec2(DN_KEY, 1), 0).x > 0.;\n    \n    bool isDKeyToggled  = texelFetch(iChannel1, ivec2(D_KEY, 2), 0).x > 0.;\n    bool isIKeyPressed  = texelFetch(iChannel1, ivec2(I_KEY, 1), 0).x > 0.;\n    bool isMKeyPressed  = texelFetch(iChannel1, ivec2(M_KEY, 1), 0).x > 0.;\n    bool isRKeyDown     = texelFetch(iChannel1, ivec2(R_KEY, 1), 0).x > 0.;\n    bool isSKeyPressed  = texelFetch(iChannel1, ivec2(S_KEY, 1), 0).x > 0.;\n    bool isVKeyPressed  = texelFetch(iChannel1, ivec2(V_KEY, 1), 0).x > 0.;\n    bool isXKeyDown     = texelFetch(iChannel1, ivec2(X_KEY, 1), 0).x > 0.;\n    bool isZKeyDown     = texelFetch(iChannel1, ivec2(Z_KEY, 1), 0).x > 0.;\n    bool isShiftKeyDown = texelFetch(iChannel1, ivec2(SHIFT_KEY, 0), 0).x > 0.;\n    \n    bool isMoveKeyDown  = isLtKeyDown || isUpKeyDown || isRtKeyDown || isDnKeyDown || isXKeyDown || isZKeyDown;\n    bool isZoomKeyDown  = isShiftKeyDown || isXKeyDown || isZKeyDown;\n\n    // uvec4[2] newCenter = uvec4[2]( center_x, center_y );\n    // float newVSize     = vsize;\n    \n    if (iFrame == 0 || isRKeyDown) {\n        opts.center[0] = float_to_quad(-0.5);\n        opts.center[1] = float_to_quad(0.);\n        opts.size      = 1.0;\n        opts.iters     = 256;\n        opts.samples   = 1;\n        opts.view      = -1;\n        restartRender  = true;\n    }\n            \n    if (isMoveKeyDown) {\n        if (isZoomKeyDown) {\n            float zoom   = 2.;\n            bool zoomin  = isUpKeyDown || isZKeyDown;\n            bool zoomout = isDnKeyDown || isXKeyDown;\n            if (zoomin || zoomout) {\n                if (zoomin) zoom = 1. / zoom;\n                opts.size *= zoom;\n            }\n            if (opts.size > 1.5) opts.size = 1.5;\n            restartRender = true;\n        } else {\n            float move = (isLtKeyDown || isDnKeyDown) ? -0.2 : 0.2;\n            bool horiz = isLtKeyDown || isRtKeyDown;\n            uvec4 a    = (horiz) ? opts.center[0] : opts.center[1];\n            uvec4 b    = add(a, float_to_quad(opts.size * move));\n            if (horiz) { opts.center[0] = b; } else { opts.center[1] = b; }\n            restartRender = true;\n        }\n    }\n\n    if (isIKeyPressed) {\n        if (isShiftKeyDown) opts.iters = max(int(float(opts.iters) * 1.1), opts.iters+1);\n        else                opts.iters = max(1, min(int(float(opts.iters) / 1.1), opts.iters-1));\n        restartRender = true;\n    }\n    \n    if (isMKeyPressed) {\n        opts.center[1] = neg(opts.center[1]);\n        restartRender = true;\n    }\n\n    if (isSKeyPressed) {\n        if (isShiftKeyDown) opts.samples++;\n        else                opts.samples = max(1, opts.samples-1);\n        restartRender = true;\n    }\n    \n    int newHud = isDKeyToggled ? 1 : -1;\n    //if (opts.hud != newHud) restartRender = true;\n    \n    if (isVKeyPressed) {\n\n      restartRender = true;\n      opts.view = opts.view + 1;\n\n      const int NUM_VIEWS = 10;\n      const int VIEW_STRIDE = 11;\n      const int NUM_DATA_ITEMS = NUM_VIEWS * VIEW_STRIDE + 1;\n\n      if (opts.view >= NUM_VIEWS) opts.view = 0;\n\n      uint[NUM_DATA_ITEMS] views = uint[NUM_DATA_ITEMS] (\n          // case 0:\n          0xBFC54A88u, 0x86094501u, 0xCB5917F2u, 0x08C2F858u,\n          0x3fc9cf26u, 0xae2c0563u, 0xf994ccccu, 0x86079bc8u,\n          0x09800000u, // view size\n          0x610u,      // iters\n          1u,          // samples\n\n          // case 1:\n          0xbfce274bu, 0x11f4b9afu, 0xef640890u, 0x6abec581u,\n          0x3fae9a7eu, 0xeff28596u, 0x1f1400bbu, 0xa5e9946fu,\n          0x0d800000u, // view size\n          0xfb3u,      // iters\n          1u,          // samples\n          \n          // case 2:\n          0x3fa4a30du, 0x1eaf2a10u, 0xb5240f96u, 0x75264f84u,\n          0x3f108933u, 0xf8cefe9eu, 0x0b9ce24cu, 0xd9d5e757u,\n          0x08800000u, // view size\n          0x48fu,      // iters\n          1u,          // samples\n\n          // case 3:\n          0xbff92a85u, 0x21d4f15du, 0xf85aa163u, 0xfd65c95cu,\n          0x3d08d2afu, 0x171321d2u, 0xf4904ed7u, 0xffbf8960u,\n          0x0d800000u, // view size\n          0x3b92u,     // iters\n          1u,          // samples\n\n          // case 4:\n          0x3faeb2e1u, 0x5a18b71bu, 0x8f54292du, 0xf1cdb7f3u,\n          0x3fc6020cu, 0x8af975cbu, 0x810c927eu, 0x572fb49fu,\n          0x38800000u, // view size\n          0x100u,      // iters\n          1u,          // samples\n          \n          // case 5:\n          0xbfd3f022u, 0x8a32379au, 0x00000000u, 0x00000000u,\n          0xbf9390d2u, 0xf86daba0u, 0x00000000u, 0x00000000u,\n          0x31800000u, // view size\n          0x425u,      // iters\n          1u,          // samples\n          \n          // case 6\n          0xbfd3f022u, 0x897d333fu, 0xe0a4e6cdu, 0x444c950fu,\n          0xbf9390d2u, 0xf73e4c6bu, 0xd2d5b186u, 0x1cdd7f78u,\n          0x0a800000u, // view size\n          0x8deu,      // iters\n          1u,          // samples\n          \n          // case 7\n          0xbfed8cc5u, 0x75141a89u, 0x5591db3eu, 0x5a7d7e20u,\n          0x3f880e2bu, 0xe60d4796u, 0xc48692b1u, 0x57677c60u,\n          0x0a800000u, // view size\n          0x2cbfu,     // iters\n          1u,          // samples\n          \n          // case 8\n          0xbfe818ccu, 0x2b4f280eu, 0x98490134u, 0xe38747a4u,\n          0x3f560975u, 0x96aa674cu, 0x2ac8c43fu, 0x9031b9a6u,\n          0x18800000u, // view size\n          0x4814u,     // iters\n          1u,          // samples\n          \n          // case 9\n          0xbfff88a1u, 0xc201544fu, 0xf5bfaf46u, 0x0da9cd7du,\n          0x3e1b7d32u, 0xbb3bb031u, 0x08a17d45u, 0xa54fa84du,\n          0x0c800000u, // view size\n          0x1e94u,     // iters\n          1u,          // samples\n\n          0u // dummy value with no trailing comma\n      );\n\n      int i = opts.view * VIEW_STRIDE;\n      opts.center[0] = uvec4(views[i+0], views[i+1], views[i+2], views[i+3]);\n      opts.center[1] = uvec4(views[i+4], views[i+5], views[i+6], views[i+7]);\n      opts.size      = uintBitsToFloat(views[i+8]);\n      opts.iters     = int(views[i+9]);\n      opts.samples   = int(views[i+10]);\n    }\n        \n    // Click to center the clicked point. \n    if (iMouse.w > 0.) {\n    // Safe zone in the bottom left corner so\n    // I can focus the window without moving the view\n    if (iMouse.z > 50. || iMouse.w > 50.) {\n        float aspect = iResolution.y / iResolution.x;\n        vec2 uv = iMouse.xy / iResolution.xy;\n\n        // map the mouse click to our complex number coordinate\n        // and store it as our new center\n\n        vec2 size = vec2( opts.size/aspect, opts.size );\n        vec2 wuv = 2. * uv - 1.;\n        for (int i = nr; i < 2; i++) {\n            // uvec4 u4in  = (i==0) ? opts.center[0] : opts.center[1];\n            uvec4 u4out = add( opts.center[i], float_to_quad(size[i] * wuv[i]) );\n            if (i==0) { opts.center[0] = u4out; } else { opts.center[1] = u4out; }\n        }\n\n        restartRender = true;\n    }\n    }\n    \n\n    if (restartRender) {\n        opts.blockId = vec2(0, MINBLOCKS);\n    } else {\n        float dt = iDate.w - opts.date; // seconds since last frame \n        \n        float prevNumBlocks = opts.blockId.y - opts.blockId.x;\n        float newNumBlocks;\n        \n        // adjust upward slowly, and adjust downward QUICKLY\n        if      (dt < 0.05) newNumBlocks = prevNumBlocks + float(BLOCKINC); \n        else if (dt > 0.20) newNumBlocks = float(MINBLOCKS);\n        else if (dt > 0.10) newNumBlocks = prevNumBlocks / 2.;\n        else                newNumBlocks = prevNumBlocks;\n        \n        newNumBlocks = clamp(newNumBlocks, float(MINBLOCKS), float(MAXBLOCKS));\n        \n        opts.blockId = vec2(opts.blockId.y, opts.blockId.y + newNumBlocks);\n    }\n\n    switch(ifc.x) {\n        case 0: color = u4_to_v8(opts.center[0])[0]; break;\n        case 1: color = u4_to_v8(opts.center[0])[1]; break;\n        case 2: color = u4_to_v8(opts.center[1])[0]; break;\n        case 3: color = u4_to_v8(opts.center[1])[1]; break;\n        case 4: color = vec4(opts.size,0,0,0); break;\n        case 5: color = vec4(newHud * opts.iters, opts.samples, iDate.w, opts.view); break;\n        case 6: color = vec4(iResolution.xy, opts.blockId); break;\n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (0,0)(1,0) = centerx (top bits of each channel mantissa to reconstruct 128 bits)\n    // (2,0)(3,0) = centery (top bits of each channel mantissa to reconstruct 128 bits)\n    // (4,0)      = size    (float) in the x channel\n    // (5,0)      = (iters (sign=hud), samples, date(secs), view) (int, stored as float)\n    // (6,0)      = (iResolution.x, iResolution.y, blockStart, blockEnd)\n\n    if (fragCoord.y > 1. || fragCoord.x > 7.) return; \n\n    vec4 ui[7];\n    for (int i = 0; i < 7; i++) ui[i] = texelFetch(iChannel0, ivec2(i, 0), 0);\n\n    options opts;\n    opts.center[0]  = v8_to_u4(ui[0], ui[1]);\n    opts.center[1]  = v8_to_u4(ui[2], ui[3]);\n    opts.size       = ui[4].x;\n    opts.hud        = (ui[5].x > 0.0) ? 1 : -1; // int(sign(ui[5].x));\n    opts.iters      = int(abs(ui[5].x));\n    opts.samples    = int(ui[5].y);\n    opts.date       = ui[5].z;\n    opts.view       = int(ui[5].w);\n    opts.resolution = ui[6].xy;\n    opts.blockId    = ui[6].zw;\n\n    fragColor = UI(fragCoord, opts);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define INCREMENTAL     // render one block at a time\n#define SHOW_NEXT_BLOCK // display active block\nconst int BLOCKSIZE = 16;\nconst int MINBLOCKS = 16; // min # of blocks to render at once. ideally minBlocks * BLOCKSIZE^2 == # GPU thread cores\nconst int MAXBLOCKS = MINBLOCKS * 8;\nconst int BLOCKINC  = 4; // # blocks to increase at a time based on framerate\n\nstruct options {\n  uvec4[2] center;\n  float    size;\n  int      hud;\n  int      iters;\n  int      samples;\n  float    date;\n  int      view;\n  vec2     resolution;\n  vec2     blockId;\n};\n\n// mouse/keyboard how-to:\n// https://shadertoyunofficial.wordpress.com/2019/01/26/classical-corner-cases/\n// https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n//\n// keymap: https://www.shadertoy.com/view/ldSBzd\n// text drawing: https://www.shadertoy.com/view/llySRh\n// kbd debug: https://www.shadertoy.com/view/4dGyDm\n\nconst int LT_KEY = 37;\nconst int UP_KEY = 38;\nconst int RT_KEY = 39;\nconst int DN_KEY = 40;\nconst int D_KEY = 68;\nconst int I_KEY = 73;\nconst int M_KEY = 77;\nconst int R_KEY = 82;\nconst int S_KEY = 83;\nconst int V_KEY = 86;\nconst int X_KEY = 88;\nconst int Z_KEY = 90;\nconst int SHIFT_KEY = 16;\n\n\n#define MASK(nbits) ((1u << (nbits)) - 1u)\nconst uint mask13 = MASK(13);\n\nconst int FLOAT_SIGN_BITS    = 1;\nconst int FLOAT_EXP_BITS     = 8;\nconst int FLOAT_SIGNEXP_BITS = FLOAT_SIGN_BITS + FLOAT_EXP_BITS;\nconst int FLOAT_BIAS         = int(MASK( FLOAT_EXP_BITS - 1 ));  // 127\nconst int FLOAT_MANT_BITS    = 23;\n\nconst int QUAD_BITS          = 128;\nconst int QUAD_SIGN_BITS     = 1;\nconst int QUAD_EXP_BITS      = 10;\nconst int QUAD_SIGNEXP_BITS  = QUAD_SIGN_BITS + QUAD_EXP_BITS;\nconst int QUAD_EXP_POS       = 32 - QUAD_SIGNEXP_BITS; // position of exp in the high order ==> 32 bit word Quad[0] <==\nconst int QUAD_HIMANT_BITS   = 32 - QUAD_SIGNEXP_BITS;\nconst int QUAD_FULLMANT_BITS = QUAD_BITS - QUAD_SIGNEXP_BITS; // 117 == 13*9\nconst int QUAD_BIAS          = int(MASK( QUAD_EXP_BITS - 1 )); // 511\n\nconst uint QUAD_SIGN_MASK = 1u << 31; // 0x80000000\nconst uint QUAD_EXP_MASK  = MASK(QUAD_EXP_BITS) << QUAD_EXP_POS; // 0x7fe00000\n\n\nvec4 premult(vec4 color) {\n    return vec4(color.rgb * color.a, color.a);\n}\n\nvec4 comp(vec4 bg, vec4 fg) {\n    return fg + bg * (1. - fg.a);\n}\n\n// https://stackoverflow.com/a/24748637\nint uint_log2(uint n)\n{\n  #define S(k) if (n >= (uint(1) << k)) { i += int(k); n >>= k; }\n  int i = -int(n == 0u); S(16u); S(8u); S(4u); S(2u); S(1u); return i;\n  #undef S\n}\n\nuvec4 add(uvec4 a, uvec4 b)\n{\n  // f.edcba98765.43210fedcba9876543210|fedcba9876543210fedcba9876543210|fedcba9876543210fedcba9876543210|fedcba9876543210fedcba9876543210\n  // s.eeeeeeeeee.mmmmmmmmmmmmmmmmmmmmm|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\n  //                  x[0]             |             x[1]               |             x[2]               |              x[3]\n\n  int aexp = int((a[0] & QUAD_EXP_MASK) >> QUAD_EXP_POS);\n  int bexp = int((b[0] & QUAD_EXP_MASK) >> QUAD_EXP_POS);\n  if (aexp == 0 && bexp == 0) return uvec4(0,0,0,0); // TODO: handle denormals\n  if (aexp == 0) return b;\n  if (bexp == 0) return a;\n\n  // sort so that a is the larger exponent\n  if (bexp > aexp) {\n    uvec4 utmp = a;\n    a = b;\n    b = utmp;\n\n    int itmp = aexp;\n    aexp = bexp;\n    bexp = itmp;\n  }\n\n  // remove bias, for a signed exponent value\n  aexp -= QUAD_BIAS;\n  bexp -= QUAD_BIAS;\n\n  int aexpDelta = aexp - bexp;\n  if (aexpDelta > QUAD_FULLMANT_BITS) return a;\n\n  uint asign = a[0] & QUAD_SIGN_MASK;\n  uint bsign = b[0] & QUAD_SIGN_MASK;\n\n  // fedcba98765.43210fedcba9876543210|fedcba.9876543210fedcba9876543210|fedc.ba9876543210fedcba9876543210|fe.dcba9876543210fedcba9876543210\n  // amant idx  .333333333333333333333|333333.22222222222222222222222222|2222.1111111111111111111111111111|11.000000000000000000000000000000\n  // shift                           0|    26.                         0|  28.                           0|30.                             0\n  //               a[0]             |             a[1]              |             a[2]              |            a[3]\n\n  // extract mantissa 30 bits at a time\n  // LSB to MSB order, so amant[0] is lo bits\n  // TODO maybe someday : guard / round / sticky\n  uint amant[4], bmant[4];\n  amant[0] = ((a[3] >> 0) & MASK(30));\n  amant[1] = ((a[2] << 2) & MASK(30)) | (a[3] >> 30);\n  amant[2] = ((a[1] << 4) & MASK(30)) | (a[2] >> 28);\n  amant[3] = ((a[0] << 6)           ) | (a[1] >> 26);\n  amant[3] = (amant[3] | (1u<<27)) & MASK(28); // insert the implicit high order '1' bit, and mask to 28 bits (not 30 like the rest)\n\n  bmant[0] = ((b[3] >> 0) & MASK(30));\n  bmant[1] = ((b[2] << 2) & MASK(30)) | (b[3] >> 30);\n  bmant[2] = ((b[1] << 4) & MASK(30)) | (b[2] >> 28);\n  bmant[3] = ((b[0] << 6)           ) | (b[1] >> 26);\n  bmant[3] = (bmant[3] | (1u<<27)) & MASK(28); // insert the implicit high order '1' bit, and mask to 28 bits (not 30 like the rest)\n\n  // shift b to the right, to match a's range\n  // 0amant idx  .333333333333333333333333333333.222222222222222222222222222222.111111111111111111111111111111.000000000000000000000000000000\n  //   1 ant idx .-33333333333333333333333333333.322222222222222222222222222222.211111111111111111111111111111.100000000000000000000000000000\n  //  29 ant idx .-----------------------------3.333333333333333333333333333332.222222222222222222222222222221.111111111111111111111111111110\n  //  31 ant idx .------------------------------.-33333333333333333333333333333.322222222222222222222222222222.211111111111111111111111111111\n  //  59 ant idx .------------------------------.-----------------------------3.333333333333333333333333333332.222222222222222222222222222221\n  //  61 ant idx .------------------------------.------------------------------.-33333333333333333333333333333.322222222222222222222222222222\n  //  89 ant idx .------------------------------.------------------------------.-----------------------------3.333333333333333333333333333332\n  //  91 ant idx .------------------------------.------------------------------.------------------------------.-33333333333333333333333333333\n  // 119 ant idx .------------------------------.------------------------------.------------------------------.-----------------------------3\n\n  if (aexpDelta > 0) {\n    if (aexpDelta >= 60) {\n      if (aexpDelta >= 90) {\n        // shift x[0] over to x[3]\n        bmant[0] = bmant[3] >> (aexpDelta - 90);\n        bmant[1] = bmant[2] = bmant[3] = 0u;\n      } else {\n        // shift x[0] over to x[2], between 60 and 89 bit shift\n        bmant[0] = ((bmant[3] << (90 - aexpDelta)) & MASK(30)) | (bmant[2] >> (aexpDelta - 60));\n        bmant[1] = ((bmant[3] >> (aexpDelta - 60)));\n        bmant[2] = bmant[3] = 0u;\n      }\n    } else {\n      if (aexpDelta >= 30) {\n        // shift x[0] over to x[1], between 30 and 59 bit shift\n        bmant[0] = ((bmant[2] << (60 - aexpDelta)) & MASK(30)) | (bmant[1] >> (aexpDelta - 30));\n        bmant[1] = ((bmant[3] << (60 - aexpDelta)) & MASK(30)) | (bmant[2] >> (aexpDelta - 30));\n        bmant[2] = ((bmant[3] >> (aexpDelta - 30)));\n        bmant[3] = 0u;\n      } else {\n        // shift x[0] to x[0]\n        bmant [0] = ((bmant[1] << (30 - aexpDelta)) & MASK(30)) | (bmant[0] >> (aexpDelta - 0));\n        bmant [1] = ((bmant[2] << (30 - aexpDelta)) & MASK(30)) | (bmant[1] >> (aexpDelta - 0));\n        bmant [2] = ((bmant[3] << (30 - aexpDelta)) & MASK(30)) | (bmant[2] >> (aexpDelta - 0));\n        bmant [3] = ((bmant[3] >> (aexpDelta - 0)));\n      }\n    }\n  }\n\n  if (asign != 0u) {\n    // negate via 2's complement\n    amant[3] = (~amant[3] /*& MASK(28)*/);\n    amant[2] = (~amant[2] & MASK(30));\n    amant[1] = (~amant[1] & MASK(30));\n    amant[0] = (~amant[0] & MASK(30))+1u;\n    // carry\n    if (amant[0] == (1u<<30)) { amant[1]++; amant[0] &= MASK(30); }\n    if (amant[1] == (1u<<30)) { amant[2]++; amant[1] &= MASK(30); }\n    if (amant[2] == (1u<<30)) { amant[3]++; amant[2] &= MASK(30); }\n    // amant[3] &= MASK(28);\n  }\n  if (bsign != 0u) {\n    // negate via 2's complement\n    bmant[3] = (~bmant[3] /*& MASK(28)*/);\n    bmant[2] = (~bmant[2] & MASK(30));\n    bmant[1] = (~bmant[1] & MASK(30));\n    bmant[0] = (~bmant[0] & MASK(30))+1u;\n    // carry\n    if (bmant[0] == (1u<<30)) { bmant[1]++; bmant[0] &= MASK(30); }\n    if (bmant[1] == (1u<<30)) { bmant[2]++; bmant[1] &= MASK(30); }\n    if (bmant[2] == (1u<<30)) { bmant[3]++; bmant[2] &= MASK(30); }\n    // bmant[3] &= MASK(28);\n  }\n\n  // add\n  uint[4] cmant;\n  cmant[3] = amant[3] + bmant[3];\n  cmant[2] = amant[2] + bmant[2];\n  cmant[1] = amant[1] + bmant[1];\n  cmant[0] = amant[0] + bmant[0];\n\n  cmant[1] += (cmant[0] >> 30);\n  cmant[0] &= MASK(30);\n\n  cmant[2] += (cmant[1] >> 30);\n  cmant[1] &= MASK(30);\n\n  cmant[3] += (cmant[2] >> 30);\n  cmant[2] &= MASK(30);\n\n  // cmant[3] &= MASK(28); // drop overflow bit\n\n  uint csign = (cmant[3] << 0) & QUAD_SIGN_MASK;\n\n  if (csign != 0u) {\n    // negate via 2's complement\n    cmant[3] = (~cmant[3] /*& MASK(28)*/);\n    cmant[2] = (~cmant[2] & MASK(30));\n    cmant[1] = (~cmant[1] & MASK(30));\n    cmant[0] = (~cmant[0] & MASK(30))+1u;\n    // carry\n    if (cmant[0] == (1u<<30)) { cmant[1]++; cmant[0] &= MASK(30); }\n    if (cmant[1] == (1u<<30)) { cmant[2]++; cmant[1] &= MASK(30); }\n    if (cmant[2] == (1u<<30)) { cmant[3]++; cmant[2] &= MASK(30); }\n    // cmant[3] &= MASK(28);\n  }\n\n  // find high bit set\n  int hibitPos;\n  //if      (cmant[3] != 0u) hibitPos = int(log2(float(cmant[3]))) + 90;\n  if      (cmant[3] != 0u) hibitPos = uint_log2(cmant[3]) + 90;\n  else if (cmant[2] != 0u) hibitPos = uint_log2(cmant[2]) + 60;\n  else if (cmant[1] != 0u) hibitPos = uint_log2(cmant[1]) + 30;\n  else if (cmant[0] != 0u) hibitPos = uint_log2(cmant[0]) +  0;\n  else return uvec4(0,0,0,0);\n\n  int cexpDelta = 117 - hibitPos;\n  int cexp = aexp - cexpDelta;\n\n  if (cexpDelta < 0) {\n    // shift right by one\n    cmant [0] = ((cmant[1] << (30 - 1)) & MASK(30)) | (cmant[0] >> (1 - 0));\n    cmant [1] = ((cmant[2] << (30 - 1)) & MASK(30)) | (cmant[1] >> (1 - 0));\n    cmant [2] = ((cmant[3] << (30 - 1)) & MASK(30)) | (cmant[2] >> (1 - 0));\n    cmant [3] =                                       (cmant[3] >> (1 - 0));\n  } else if (cexpDelta > 0) {\n    // shift c to the left by cexpDelta\n    // 1   amant idx .333333333333333333333333333332.222222222222222222222222222221.111111111111111111111111111110.00000000000000000000000000000-\n    // 29  amant idx .322222222222222222222222222222.211111111111111111111111111111.100000000000000000000000000000.0-----------------------------\n    // 31  amant idx .222222222222222222222222222221.111111111111111111111111111110.00000000000000000000000000000-.------------------------------\n    // 59  amant idx .211111111111111111111111111111.100000000000000000000000000000.0-----------------------------.------------------------------\n    // 61  amant idx .111111111111111111111111111110.00000000000000000000000000000-.------------------------------.------------------------------\n    // 89  amant idx .100000000000000000000000000000.0-----------------------------.------------------------------.------------------------------\n    // 91  amant idx .00000000000000000000000000000-.------------------------------.------------------------------.------------------------------\n    // 119 amant idx .0-----------------------------.------------------------------.------------------------------.------------------------------\n\n    if (cexpDelta < 60) {\n      if (cexpDelta < 30){\n        // shift x[0] to x[0]\n        cmant[3] = ((cmant[3] << (cexpDelta - 0)) & MASK(30)) | (cmant[2] >> (30 - cexpDelta));\n        cmant[2] = ((cmant[2] << (cexpDelta - 0)) & MASK(30)) | (cmant[1] >> (30 - cexpDelta));\n        cmant[1] = ((cmant[1] << (cexpDelta - 0)) & MASK(30)) | (cmant[0] >> (30 - cexpDelta));\n        cmant[0] = ((cmant[0] << (cexpDelta - 0)) & MASK(30));\n      } else /*if (cexpDelta >= 30)*/ {\n        // shift x[0] over to x[1], between 30 and 59 bit shift\n        cmant[3] = ((cmant[2] << (cexpDelta - 30)) & MASK(30)) | (cmant[1] >> (60 - cexpDelta));\n        cmant[2] = ((cmant[1] << (cexpDelta - 30)) & MASK(30)) | (cmant[0] >> (60 - cexpDelta));\n        cmant[1] = ((cmant[0] << (cexpDelta - 30)) & MASK(30));\n        cmant[0] = 0u;\n      }\n    } else {\n      if (cexpDelta < 90) {\n        // shift x[0] over to x[2], between 60 and 89 bit shift\n        cmant[3] = ((cmant[1] << (cexpDelta - 60)) & MASK(30)) | (cmant[0] >> (90 - cexpDelta));\n        cmant[2] = ((cmant[0] << (cexpDelta - 60)) & MASK(30));\n        cmant[1] = cmant[0] = 0u;\n      } else /* if (cexpDelta >= 90) */ {\n        // shift x[0] over to x[3], between\n        cmant[3] = ((cmant[0] << (cexpDelta - 90)) & MASK(30));\n        cmant[2] = cmant[1] = cmant[0] = 0u;\n      }\n    }\n  }\n\n  uvec4 c; // result\n\n  // fedcba98765.43210fedcba9876543210|fedcba.9876543210fedcba9876543210|fedc.ba9876543210fedcba9876543210|fe.dcba9876543210fedcba9876543210\n  // amant idx  .333333333333333333333|333333.22222222222222222222222222|2222.1111111111111111111111111111|11.000000000000000000000000000000\n  // shift                           0|    26.                         0|  28.                           0|30.                             0\n  //               a[0]             |             a[1]              |             a[2]              |            a[3]\n\n  c[0] = csign | (uint(cexp + QUAD_BIAS) << QUAD_EXP_POS) & QUAD_EXP_MASK;\n  c[0] |= ((cmant[3] >> 6) & 0x001FFFFFu); // this chops off the hi bit\n  c[1] = (cmant[3] << 26) | (cmant[2] >> 4);\n  c[2] = (cmant[2] << 28) | (cmant[1] >> 2);\n  c[3] = (cmant[1] << 30) | (cmant[0] >> 0);\n\n  return c;\n}\n\n\nuvec4 mul(uvec4 a, uvec4 b)\n{\n  uvec4 c = uvec4(0,0,0,0); // c = a * b\n\n  int aexp = int((a[0] & QUAD_EXP_MASK) >> QUAD_EXP_POS);\n  int bexp = int((b[0] & QUAD_EXP_MASK) >> QUAD_EXP_POS);\n  if (aexp == 0 || bexp == 0) return c; // TODO: handle denormals\n  aexp -= QUAD_BIAS;\n  bexp -= QUAD_BIAS;\n  int cexp = aexp + bexp; // TODO: check for overflow\n\n  uint asign = a[0] & QUAD_SIGN_MASK;\n  uint bsign = b[0] & QUAD_SIGN_MASK;\n  uint csign = asign ^ bsign;\n\n  // hibit==0\n  // fedcba98765.43210fedcba98.76543210|fedcb.a9876543210fe.dcba987654321.0|fedcba987654.3210fedcba987.6543210|fedcba.9876543210fed.cba9876543210\n  // amant idx  .8888888888888.77777777|77777.6666666666666.5555555555555.4|444444444444.3333333333333.2222222|222222.1111111111111.0000000000000\n  // shift                   8.       0|   27.           14.            1.0|          20.            7.      0|    26.           13.            0\n  //                a[0]             |           a[1]                  |           a[2]                 |            a[3]\n\n\n  // extract mantissa 13 bits at a time\n  // reverse the digit order; put internal mantissa in LSB to MSB order, so amant[0] is lo bits\n  const uint mask13 = MASK(13);\n\n  uint amant[9];\n  amant[0] = ((a[3]      ) & mask13);\n  amant[1] = ((a[3] >> 13) & mask13);\n  amant[2] = ((a[3] >> 26) & mask13) | ((a[2] <<  6) & mask13); // 13*2 = 26        32-6=26\n  amant[3] = ((a[2] >>  7) & mask13);                           // 13*3 % 32 = 7\n  amant[4] = ((a[2] >> 20) & mask13) | ((a[1] << 12) & mask13); // 13*4 % 32 = 20   32-20=12\n  amant[5] = ((a[1] >>  1) & mask13);                           // 13*5 % 32 = 1\n  amant[6] = ((a[1] >> 14) & mask13);                           // 13*6 % 32 = 14\n  amant[7] = ((a[1] >> 27) & mask13) | ((a[0] <<  5) & mask13); // 13*7 % 32 = 27   32-27=5\n  amant[8] = ((a[0] >>  8) & mask13) | (1u << 13);              // 13*8 % 32 = 8  insert the explicit high order bit\n\n  uint bmant[9];\n  bmant[0] = ((b[3]      ) & mask13);\n  bmant[1] = ((b[3] >> 13) & mask13);\n  bmant[2] = ((b[3] >> 26) & mask13) | ((b[2] <<  6) & mask13); // 13*2 = 26        32-6=26\n  bmant[3] = ((b[2] >>  7) & mask13);                           // 13*3 % 32 = 7\n  bmant[4] = ((b[2] >> 20) & mask13) | ((b[1] << 12) & mask13); // 13*4 % 32 = 20   32-20=12\n  bmant[5] = ((b[1] >>  1) & mask13);                           // 13*5 % 32 = 1\n  bmant[6] = ((b[1] >> 14) & mask13);                           // 13*6 % 32 = 14\n  bmant[7] = ((b[1] >> 27) & mask13) | ((b[0] <<  5) & mask13); // 13*7 % 32 = 27   32-27=5\n  bmant[8] = ((b[0] >>  8) & mask13) | (1u << 13);              // 13*8 % 32 = 8  insert the explicit high order bit\n\n  // multiply\n  // number of intermediate 13-bit digits needed in theory is 9+9+1\n  // but to save time without sacrificing too much accuracy, we'll drop the 8 lowest digits\n\n  // compute results from LSB to MSB\n  // TODO: pack bits & carry along the way, so we don't need such a long intermediate array?\n  uint cmant[11]; // cmant[0] is LSB\n\n  for (int dig = 0; dig <= 8; dig++) {\n    cmant[dig] = 0u;\n    for (int a = dig; a <= 8; a++) {\n        int b = dig + 8 - a;\n        cmant[dig] += amant[a] * bmant[b];\n    }\n  }\n\n  // carry\n  for (int dig = 1; dig < 11; dig++) {\n    cmant[dig] += (cmant[dig-1] >> 13);\n    cmant[dig-1] &= mask13;\n  }\n\n  // find high bit set\n  // best  case (1.0{117} * 1.0{117}) = 1.0{234}        -- 235 bits total\n  // worst case (1.1{117} * 1.1{117}) = 1.1{116}0{118}1 -- 236 bits total\n  // The high digit (cmant[18-8]) is pure overflow - it will only have either a 1 bit set in 1's column or the 2's column\n  int h = ((cmant[10] & 2u) != 0u) ? 1 : 0;\n\n  cexp += h;\n\n  // f.edcba98765.43210fedcba9876543210|fedcba9876543210fedcba9876543210|fedcba9876543210fedcba9876543210|fedcba9876543210fedcba9876543210\n  // s.eeeeeeeeee.mmmmmmmmmmmmmmmmmmmmm|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\n  //                  x[0]             |             x[1]               |             x[2]               |              x[3]\n\n  // hibit==0\n  // fedcba98765.43210fedcba98.76543210|fedcb.a9876543210fe.dcba987654321.0|fedcba987654.3210fedcba987.6543210|fedcba.9876543210fed.cba9876543210\n  // cmant idx   hhhhhhhhhhhhh.gggggggg|ggggg.fffffffffffff.eeeeeeeeeeeee.d|dddddddddddd.ccccccccccccc.bbbbbbb|bbbbbb.aaaaaaaaaaaaa.9999999999999\n  // shift                   8.       0|   27.           14.            1.0|          20.            7.      0|    26.           13.            0\n\n  // hibit==1\n  // seeeeeeeeeem.mmmmmmmmmmmmm.mmmmmmm|mmm....\n  // fedcba987654.3210fedcba987.6543210|fedcba.9876543210fed.cba9876543210|fedcba9876543.210fedcba9876.543210|fedcba9.876543210fedc.ba9876543210\n  // cmant idx  i.hhhhhhhhhhhhh.ggggggg|gggggg.fffffffffffff.eeeeeeeeeeeee|ddddddddddddd.ccccccccccccc.bbbbbb|bbbbbbb.aaaaaaaaaaaaa.999999999999\n  // shift     20.            7.      0|    26.           13.            0|           19.            6.     0|     25.           12.           0\n\n\n  // drop the high bit, so it's implicit again\n  // if there's a high bit in the 2's column of the hi digit result, we still need to capture the bit in the 1's column\n  if (h != 0) c[0] |= (cmant[10] & 1u) << (31 - QUAD_SIGNEXP_BITS);\n\n  // reverse the digit order again; put output mantissa in MSB to LSB order, so c[0] is hi bits\n\n  c[0] |= (cmant[9] << ( 8 - h)) | (cmant[8] >> ( 5 + h));\n  c[1] =  (cmant[8] << (27 - h)) | (cmant[7] << (14 - h)) | (cmant[6] << (1 - h)) | (cmant[5] >> (12 + h));\n  c[2] =  (cmant[5] << (20 - h)) | (cmant[4] << ( 7 - h)) | (cmant[3] >> (6 + h));\n  c[3] =  (cmant[3] << (26 - h)) | (cmant[2] << (13 - h)) | (cmant[1] >> (0 + h));\n\n  c[0] |= csign;\n  c[0] |= uint((cexp + QUAD_BIAS) << QUAD_EXP_POS) & QUAD_EXP_MASK;\n\n  return c;\n}\n\nuvec4 neg(uvec4 q) {\n    return uvec4(q[0] ^ QUAD_SIGN_MASK, q[1], q[2], q[3]);\n}\n\nfloat quad_to_float(uvec4 q) {\n    uint sign = q[0] & QUAD_SIGN_MASK;\n    int exp = int((q[0] & QUAD_EXP_MASK) >> QUAD_EXP_POS);\n    if (exp == 0) return 0.;\n    exp -= QUAD_BIAS;\n\n    uint mant = ((q[0] & MASK(QUAD_HIMANT_BITS)) << QUAD_SIGNEXP_BITS);\n    mant |= ((q[1] & ~MASK(QUAD_HIMANT_BITS)) >> QUAD_EXP_POS);\n\n    uint fbits = sign | (uint(exp + FLOAT_BIAS) << FLOAT_MANT_BITS) | (mant >> FLOAT_SIGNEXP_BITS);\n\n    return uintBitsToFloat(fbits);\n}\n\nuvec4 float_to_quad(float f) {\n    uint fbits = floatBitsToUint(f);\n    uint sign = fbits & 0x80000000u;\n    int exp = int((fbits & 0x7f800000u) >> FLOAT_MANT_BITS);\n    if (exp == 0) return uvec4(0, 0, 0, 0); // denormal // TODO: u2_add & u2_mul also need to handle special case zero\n    exp -= FLOAT_BIAS;\n    uint mant = fbits & MASK(FLOAT_MANT_BITS);\n\n    const int MANT_OFFSET = (QUAD_EXP_BITS - FLOAT_EXP_BITS);\n\n    uvec4 q;\n    q[0] = sign;\n    q[0] |= uint(exp + QUAD_BIAS) << QUAD_EXP_POS;\n    q[0] |= mant >> MANT_OFFSET;\n\n    q[1] = mant << (32 - MANT_OFFSET);\n\n    q[2] = 0u;\n    q[3] = 0u;\n    return q;\n}\n\n/*\n\nEncode a quad (uvec4) into our texture buffer\n\nUse the top 16 bits of the mantissa in each channel to capture our data\n\n4 channels * 16 bits = a 64 bit number per pixel\n\nMy idea here is an attempt to accurately capture all bits, \neven on devices with low precision textures. \n\nIt does seem to work on my desktop machine to store uints directly as full floats,\nbut that seems risky as I could occasionally end up with NaNs or denormals and they\nmight not decode accurately.\n\nNot sure if this encoding is misguided, because I don't know how webGL \nprecision really works. How many bits do the ShaderToy Buffers guarantee, \nand which bits are they?\n\n*/\n\nuint floatToUint16(float f) { return ((floatBitsToUint(f) >> (23-16)) & MASK(16)); }\nfloat uint16ToFloat(uint u) { return uintBitsToFloat(((u & MASK(16)) << (23-16)) | 0x3f000000u); }\n\nvec4[2] u4_to_v8(uvec4 q) {\n  vec4[2] v8;\n  v8[0].x = uint16ToFloat(q[0] >> 16);\n  v8[0].y = uint16ToFloat(q[0]);\n  v8[0].z = uint16ToFloat(q[1] >> 16);\n  v8[0].w = uint16ToFloat(q[1]);\n  v8[1].x = uint16ToFloat(q[2] >> 16);\n  v8[1].y = uint16ToFloat(q[2]);\n  v8[1].z = uint16ToFloat(q[3] >> 16);\n  v8[1].w = uint16ToFloat(q[3]);\n  return v8;\n}\n\n// Decode a v4 (pixel from the buffer) into a U2\nuvec4 v8_to_u4(vec4 a, vec4 b) {\n  uvec4 q;\n  q[0] = (floatToUint16(a[0]) << 16) | floatToUint16(a[1]);\n  q[1] = (floatToUint16(a[2]) << 16) | floatToUint16(a[3]);\n  q[2] = (floatToUint16(b[0]) << 16) | floatToUint16(b[1]);\n  q[3] = (floatToUint16(b[2]) << 16) | floatToUint16(b[3]);\n  return q;\n}\n\n// Get width of ring index\nint W(int i) { return i*2+1; }\n\n// Ulam indexing is from https://www.shadertoy.com/view/tlcyRj\nint ulamId(ivec2 block2d) {\n    int x = int(block2d.x);\n    int y = int(block2d.y);\n    int i = max(abs(x), abs(y)); // Ring index\n    int w0 = W(i-1); // Ring below width\n    int w1 = W(i); // Ring current width\n    int h = w1/2;\n    int A = w0*w0;\n    int v = sign(y) == -1 && y == -h && x > -h ? 3 : (sign(x) == 1 && x == h ? 0 : (sign(y) == 1 && y == h ? 1 : 2));  \n    int j;\n    switch (v) {\n        case 0: j =  y + (h+2); break;\n        case 1: j = -x + (h+1); break;\n        case 2: j = -y + (h  ); break;\n        case 3: j =  x + (h-1); break;\n    }\n    // Original is off by 2!\n    int n = A + v*w1 + j * int(i != 0) - 2;\n    return n;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"uvec4[2] CMUL(uvec4[2] a, uvec4[2] b) {\n    // (ax + ayi)(bx + byi) = (ax bx âˆ’ ay by) + (ax by + ay bx)i\n    //uvec4 real = add(mul(a.xy, b.xy), neg(mul(a.zw, b.zw)));\n    //uvec4 imag = add(mul(a.xy, b.zw), mul(a.zw, b.xy));\n\n    uvec4[4] mulout;\n\n    int nr = min(0,iFrame);\n\n    for (int i = nr; i < 2; i++) {\n    for (int j = nr; j < 2; j++) {\n        mulout[i*2+j] = mul(a[i], b[j]);\n    }\n    }\n\n    mulout[3] = neg(mulout[3]);\n\n    uvec4[2] ri;\n    for (int i = nr; i < 2; i++) ri[i] = add(mulout[i], mulout[3-i]);\n\n    return ri;\n}\n\nvec4 render( in vec2 fragCoord, options opts )\n{\n    vec4 color = vec4(0,0,0,1);\n    int nr = min(0, iFrame);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n\n    // let's render in blocks starting from the center and spiraling out\n    // This is useful for high samples per pixel, high iterations, and full-screen\n    #ifdef INCREMENTAL\n    ivec2 bid2 = ivec2(floor(((fragCoord - (iResolution.xy/2.) + (float(BLOCKSIZE)/2.)) / float(BLOCKSIZE))));\n    int uid = ulamId(bid2);\n    if (uid < int(opts.blockId.x) || uid >= int(opts.blockId.y)) {\n        color = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        // show the next block in the queue (indicate activity & progress, helpful when changing samples and in some regions)\n        #ifdef SHOW_NEXT_BLOCK\n        if (uid == int(opts.blockId.y)) { return mix(color, vec4(vec3(.5),1), 0.5); }\n        #endif // SHOW_NEXT_BLOCK\n        return color;\n    }\n    #endif // PROGRESSIVE\n\n    vec2 size = vec2(opts.size/aspect, opts.size);\n    \n    uvec4[2] c;\n    vec2 wuv = 2. * uv - 1.;\n    for (int i=nr;i<2;i++) \n      c[i] = add( (i==0) ? opts.center[0] : opts.center[1], float_to_quad(size[i] *  wuv[i]) );\n    \n    vec2 pxSz = 1.f / iResolution.xy;\n    vec2 sampSz = vec2(1.f / float(opts.samples));\n    \n    for (int AAX = nr; AAX < opts.samples; AAX++) {\n    for (int AAY = nr; AAY < opts.samples; AAY++) {\n    \n    vec2 puv = (fragCoord.xy + vec2(AAX, AAY)*sampSz) * pxSz;\n    vec2 wuv = 2. * puv - 1.;\n    for(int i=nr;i<2;i++) {\n        c[i] = add( (i==0) ? opts.center[0] : opts.center[1], float_to_quad( size[i] * wuv[i] ) );\n    }\n\n    uvec4[2] z = c;\n\n    int i;\n    float l;\n    \n    for (i = nr; i < opts.iters; i++) {\n        uvec4[2] ztmp = CMUL(z, z);\n        for(int j=nr;j<2;j++) z[j] = add(ztmp[j], c[j]);\n        for(int j=nr;j<2;j++) ztmp[j] = mul(z[j], z[j]);\n        uvec4 z_l_sqr = add(ztmp[0], ztmp[1]);\n        if (quad_to_float(z_l_sqr) > 4.) break;\n    }    \n\n    // Nice colormap from: https://www.shadertoy.com/view/XdsXWN\n    const vec3 colourPhase = vec3(5,7,11)/80.0;\n    vec3 colourPhaseStart = vec3(1);\n    \n    float mu = float(i);        \n    if (i < opts.iters) color.rgb += pow(sin(colourPhase.xyz * mu + colourPhaseStart)*.5+.5,vec3(1.5));\n    }\n    }\n    \n    color.rgb *= (1.0 / float(opts.samples * opts.samples));\n\n    color.rgb = vec3( pow(color.rgb, vec3(1./2.2)) );\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (0,0)(1,0) = centerx (top bits of each channel mantissa to reconstruct 128 bits)\n    // (2,0)(3,0) = centery (top bits of each channel mantissa to reconstruct 128 bits)\n    // (4,0)      = size    (float) in the x channel\n    // (5,0)      = (iters (sign=hud), samples, date(secs), view) (int, stored as float)\n    // (6,0)      = (iResolution.x, iResolution.y, blockStart, blockEnd)\n\n    vec4 ui[7];\n    for (int i = 0; i < 7; i++) ui[i] = texelFetch(iChannel0, ivec2(i, 0), 0);\n\n    options opts;\n    opts.center[0]  = v8_to_u4(ui[0], ui[1]);\n    opts.center[1]  = v8_to_u4(ui[2], ui[3]);\n    opts.size       = ui[4].x;\n    opts.hud        = (ui[5].x > 0.0) ? 1 : -1; // int(sign(ui[5].x));\n    opts.iters      = int(abs(ui[5].x));\n    opts.samples    = int(ui[5].y);\n    opts.date       = ui[5].z;\n    opts.view       = int(ui[5].w);\n    opts.resolution = ui[6].xy;\n    opts.blockId    = ui[6].zw;\n\n    fragColor = render(fragCoord, opts);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvec4 renderHUD( in vec2 fragCoord, options opts )\n{\n    int nr = min(0, iFrame);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n\n    vec2 size = vec2(opts.size/aspect, opts.size);\n    \n    uvec4[2] c;\n    vec2 wuv = 2. * uv - 1.;\n    for (int i=nr;i<2;i++) \n      c[i] = add( (i==0) ? opts.center[0] : opts.center[1], float_to_quad(size[i] *  wuv[i]) );\n    \n    vec4 textColor = vec4(0,0,0,0);\n    if (opts.hud > 0) {\n        // debug display of numbers\n        vec2 textSz = vec2(12,20);\n        vec2 textUV = fragCoord.xy / textSz;\n        vec2 charUV = fract(textUV) * vec2(0.5, 1) + vec2(0.25, 0);\n        vec2 charID = floor(textUV); // (col, row)\n        \n        int row = int(charID.y);\n        int col = int(charID.x);\n        // Show the stored state in our \"ui\" buffer: center x/y, size, and options\n        // 3 rows, 4 numbers, 8 characters each (hex). The 9s are to put a space between each number\n        if (row < 3 && col < 9*4) {\n            int whichNum   = col / 9;\n            uint num;\n            switch(row) {\n              case 2:\n              case 1: \n                num = opts.center[2-row][whichNum];\n                break;\n              case 0:\n                switch(whichNum) {\n                  case 0: num = floatBitsToUint(opts.size); break;\n                  case 1: num = uint(opts.iters); break;\n                  case 2: num = uint(opts.samples); break;\n                  case 3: num = uint(opts.view); break;\n                }\n                break;\n            }\n            int whichDigit = 8 - (col % 9);\n            int c          = int((num >> (4*whichDigit)) & 0xfu);\n            c              += (c > 9) ? (65 - 10) : 48;\n            vec2 texUV     = charUV / 16.;\n            if (whichDigit < 8) textColor = vec4(texture(iChannel1, texUV + fract( vec2(c, 15-c/16) / 16. ) ).xxx, .75);\n        }\n    } // hud\n    \n    return textColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (0,0)(1,0) = centerx (top bits of each channel mantissa to reconstruct 128 bits)\n    // (2,0)(3,0) = centery (top bits of each channel mantissa to reconstruct 128 bits)\n    // (4,0)      = size    (float) in the x channel\n    // (5,0)      = (iters (sign=hud), samples, date(secs), view) (int, stored as float)\n    // (6,0)      = (iResolution.x, iResolution.y, blockStart, blockEnd)\n\n    vec4 ui[7];\n    for (int i = 0; i < 7; i++) ui[i] = texelFetch(iChannel0, ivec2(i, 0), 0);\n\n    options opts;\n    opts.center[0]  = v8_to_u4(ui[0], ui[1]);\n    opts.center[1]  = v8_to_u4(ui[2], ui[3]);\n    opts.size       = ui[4].x;\n    opts.hud        = (ui[5].x > 0.0) ? 1 : -1; // int(sign(ui[5].x));\n    opts.iters      = int(abs(ui[5].x));\n    opts.samples    = int(ui[5].y);\n    opts.date       = ui[5].z;\n    opts.view       = int(ui[5].w);\n    opts.resolution = ui[6].xy;\n    opts.blockId    = ui[6].zw;\n\n    fragColor = renderHUD(fragCoord, opts);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}