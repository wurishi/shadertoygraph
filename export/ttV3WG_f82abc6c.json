{"ver":"0.1","info":{"id":"ttV3WG","date":"1579875678","viewed":64,"name":"Trace 2D Mini","username":"spalmer","description":"an experimental 2d ray tracer testbed","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see Common tab\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    V q = StoQ(p, R);\n    DrawSceneAA(c.rgb, q, R, iTime);\n    if (iMouse.z >= 0.)\n    \tDrawMouseRay(c.rgb, q, R, iMouse, iTime);\n    c.rgb = pow(c.rgb, vec3(1./2.2));\n    c.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// somewhat based on https://shadertoy.com/view/wtG3WW\n\n// system for ray tracing\n\n// the trick here is that the trace function is used for everything;\n// there is no SDF backing any of this up.  So it's an experiment\n// towards fleshing out this minimal style of tracing into\n// a full fledged raytracing renderer, 2d only, for now.\n// Thought about doing simple prism light path tracing, but not yet ready.\n// Still working on obtaining normals!\n\n// some defines so I don't have to specify dimensions and language-specific identifiers everywhere, a porting aid\n#define V vec2\n\n// \"light\" direction?\nvec2 L = normalize(vec2(.7));\n\n\nstruct Ray\n{\n    V o; // origin point\n    V d; // direction vector\n};\n\n    // if I ever get to formalizing that traces past a max distance limit\n    // equal a miss, I may want to consider leaving d unnormalized\n    // and treat it as the total vector delta to trace along, where then\n    // the result would be between 0 and length(d) if successful,\n    // or perhaps 0 to 1 so o + d * t would still work.\n    // either way, use length(d) as the max trace distance.\n    // it would allow arbitrary scaling on object transform, even non-uniform!  I think.\n\nstruct Trace\n{ // info maintained by TraceObject\n    float d; // closest hit distance (init to 3.4e38 or infinity or sky or even like 10 for very small scenes)\n    int i;   // closest object index (material, etc., init to sky, maybe -1)\n};\n\nvoid Object(inout Trace t, float d, int i)\n{\n\tif (0. <= d && d < t.d && !isnan(d)) {\n        t.d = d; t.i = i; \n    }\n}\n// TODO is there any way I can make this deal with two Trace's instead of loose args? would that even help?\n\n// a real generalized interface would maybe return the exit intersection time too\n// but since I'm shooting for a minimal interface, I just want the nearest intersection.\n// so the interface will be something like:\n//float tshape(Ray r, ...)\n// ideally the shape tracer would need no additional arguments\n// unit shapes keep things nice and implicit\n\nfloat Root(vec3 f) // first zero crossing of polynomial quadric function\n{ // f(t) = dot(f, vec3(1.,vec2(1.,t)*t)) == 0\n\tfloat d = sqrt(.25 * f.y * f.y - f.x * f.z);\n\tif (f.y * f.z < 0.) d = -d;\n\treturn (d - .5 * f.y) / f.z;\n} // see also The Quadratic Equation\n// actually I don't believe it actually works in the general case anymore\n// it only handles the inputs that tball gives it\n\n// trace sphere at origin with radius 1\n// doesn't handle camera inside sphere properly, doesn't handle negative radii, etc.\nfloat tball(Ray r)\n{\n    float x = dot(r.o, r.o);\n    return (x - 1. <= 0.) ? 0. : Root(vec3(x - 1., 2. * dot(r.o, r.d), 1.));\n}\n\n// TODO could just return the Trace? idk, interface needs work.\nfloat tscene(Ray r, out int i)\n{\n    Trace t;\n    t.d = 3.4e38; t.i = -1;\n    Object(t, tball(r), 0);\n    Ray r1 = r; r1.o.x--; // TODO rmove\n    Object(t, tball(r1), 1);\n    Ray r2 = r; r2.o.x++;\n    Object(t, tball(r2), 2);\n    // TODO tprism\n    if (t.i < 0) t.d = -1.;\n    i = t.i; return t.d;\n}\n\n\n\n\n// now, how to do a renderer using\n// only a ray tracer that returns\n// only distance and object id?\n\n// idk, think I'd be better off extending the\n// interface to include hit normal.\n// the shape function itself should have no trouble calculating the normal.\n// but generally we may not need the normal, and\n// when we do, it tends to be after we decide which object is closest etc.\n// so delayed, lazy eval.\n// my Object tracer function isn't that sophisticated, yet.\n// ideally there'd be a bounding shape also!\n\n// only way I have been able to do that lazily so far in GLSL is using a macro\n\nconst float pi = acos(-1.) //3.14\n    , tau = 2.*pi; //6.28;\n\n\n// can send several rays per pixel I guess, but still doesn't answer the question.\n// I guess if I just consider rays that hit within the pixel area... hmm.\n\n    // interesting... but inside the objects we seem to have lost all gradient info due to clip with 0.\n    // using dFd? of d itself seems problematic\n    // but perhaps I can arrange a bias so it works somehow.\n    // hell, it almost works now!\n    // just need valid gradients, not zeroes.\n    // so currently it only works where the ray can eventually hit the object\n    // perhaps if I shot several rays from different angles, and took the valid results?  idk.\n\n// compute per-object tint, doesn't matter but each should be unique\nvec3 Hue(int i)\n{\n\tconst float huef = (sqrt(5.)+1.)*pi; // tau*goldenratio or pi*phi or something completely irrational\n    return .5 + .5*cos(float(i)*huef+vec3(0,2,4));\n}\n\nconst float sceneScale = 2.; //1.; // sceneScale is driving me bonkers.  too complex rn.\n\n// f is 1./iResolution.y, used to limit trace distance\n// so I guess actually\n// f is the max trace distance limit\n// but it's also the bias backwards (by half)\n// so f defines the range to be measured.  somehow.\n// the query radius.\nvec3 DrawPixel(Ray r, float f)\n{    \n    r.o -= .5 * f * r.d;\n    int i;\n    float d = tscene(r, i);\n    if (!(d >= 0.) || !(d <= f)) { i = -1; d = -1.; } //} // setting d zeroes out the gradient away from surface\n    V g = -r.d; //V(0); //\n  #if 0\n    g = V(dFdx(d),dFdy(d)); // even MOAR HAXX\n    // it wouldn't be valid anywhere except aiming at the object anyway\n    // and the quality of the gradient won't be great using quad differentials\n   // g /= fwidth(d) + 1e-7;\n    g = -g;\n  #elif 0\n    // this didn't work well, idk if I can use auto derivatives, even in 2d\n    if (d >= 0.) {\n\t    V hp = r.o + r.d * d // point in scene where trace says it found object surface\n\t        , sd = sign(r.d);\n\t\t// construct some new trace for derivative measurement purposes\n\t    // these will be very near the hit point hp and aligned with either axis\n\t    int ix, iy; // dummy out args for unneeded results\n\t    float dy = tscene(Ray(hp - vec2(0, -.1*sd.y), vec2(0, -sd.y)), ix)\n\t        , dx = tscene(Ray(hp - vec2(-.1*sd.x, 0), vec2(-sd.x, 0)), iy);\n\t    g = V(dFdx(dx), dFdy(dy));\n    }\n  #elif 0\n    // trying similar idea but with manual derivatives, not quite working yet!  :(\n    if (d >= 0.) {\n\t    V hp = r.o + r.d * d // point in scene where trace says it found object surface\n\t        , sd = sign(r.d);\n        if (sd.x == 0.) sd.x = 1.;\n        if (sd.y == 0.) sd.y = 1.;\n\t    // construct some new trace for derivative measurement purposes\n\t    // these will be very near the hit point hp and aligned with either axis\n\t    int ix, iy; // dummy out args for unneeded results\n        float h = .5*f * 10.; \n        hp -= sd * h; //r.d * h;\n\t    float dy1 = tscene(Ray(hp - vec2( h, 0) * sd, vec2(0, sd.y)), ix)\n\t        , dx1 = tscene(Ray(hp - vec2( 0, h) * sd, vec2(sd.x, 0)), iy)\n\t        , dy0 = tscene(Ray(hp - vec2(-h, 0) * sd, vec2(0, sd.y)), ix)\n\t        , dx0 = tscene(Ray(hp - vec2( 0,-h) * sd, vec2(sd.x, 0)), iy);\n\t    g = V(dx1-dx0, dy1-dy0);// * -sd; // ? WIP\n    }\n  #endif\n    float l = .5;\n    // if we found a gradient, calculate some fake lighting\n  #if 1\n    if (dot(g, g) > 0.) g = normalize(g);\n    else g = r.d * 0.;    \n    float nl = max(0., dot(g, L)); //dot(r.d, L);// * dot(r.d, g); //dot(g, L); //0.; //    \n    l = mix(nl, 1., .2); //.5 + .5*nl; //1.; //.5 + .5*? // mega ambient\n  #else\n    //float hd = dscene(hp); // yeah but I don't have a dscene, because I'm trying to enforce lack of access to one so I'll be forced to work with what's available.\n    //g = (...)\n    // idk, I tried, I couldn't get any decent lighting out of it after all.\n    //l = .5;\n  #endif\n    l = clamp(l, 0., 1.); // just in case\n    vec3 h = Hue(i);\n    return h * l;\n}\n\n// TODO some kind of temporal jitter?\n\nV spin(float a) { return V(cos(a), sin(a)); }\n\nvoid DrawSceneAA(out vec3 c, vec2 q, vec2 res, float time)\n{\n    q *= sceneScale;\n    float f = 1. * sceneScale / res.y;\n    //float a = 1.8 * time; // which way the micro rays go - mimics light direction\n    Ray r; \n    //r.o = q;\n    //r.d = spin(a);\n    const float blur = 1.; //0.; //2.5; //1.5; //\n    int aa = 6; //24; //12; // subsample count\n    // At least it's fairly antialiased now\n    //float b0 = blur * f; //blur / res.y;\n    vec3 C = vec3(0);\n    for (int rep = aa; --rep >= 0; ) {\n        float s = float(rep) / float(aa-1);\n        V dir = spin(s * tau); // vogel would need * sqrt(s)? \n        //V v = b0 * dir;\n\t    r.o = q; // - v; // I thought the DrawPixel was going to do this though FIXME\n        r.d = dir;\n    \tC += DrawPixel(r, f); //b0); // f*blur?\n    }\n    C /= float(aa);\n    c.rgb = C;\n}\n\n\n// aspect-correct windowing\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (2. * s - r) / r.y;\n}\n\n//        r.o *= sceneScale; // scale whole scene \n//    f *= sceneScale;\n\n// iq's https://shadertoy.com/view/lsXGz8\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h);\n}\n// just so I can debug the rays\n\nvoid DrawMouseRay(inout vec3 c, vec2 q, vec2 res, vec4 m, float time)\n{\n    V la = StoQ(m.zw, res), lb = StoQ(m.xy, res);\n    q *= sceneScale; la *= sceneScale; lb *= sceneScale;\n    Ray r;\n    r.o = la;\n    r.d = normalize(lb-la);\n    int i;\n    float t = isnan(dot(r.d,vec2(1))) ? -1. :\n        tscene(r, i);\n    bool missed = i < 0\n        || !(t >= 0.)\n        || isnan(t);\n    // fix t by dividing sceneScale? TODO sort this out better\n    V lh = missed ? lb : r.o + r.d * t;\n    float ir = 1.5*sceneScale/res.y;\n    float d = sdLine(q, la, lh) - ir;\n    //d = \n    float cov = clamp(.5 - d/ir, 0., 1.);\n    vec3 cm = missed ? vec3(.8,.4,.0) : vec3(.7,.9,.5);\n    cm *= 1.-abs(sin(3.142*time)) * exp2(-.5*distance(la, q)/distance(lh, q));\n    c.rgb = mix(c.rgb, cm, cov);\n    if (missed)\n        c = mix(c, vec3(.5,.0,.0), .25);\n}\n\n#define R (iResolution.xy)\n\n#if 0\n// TODO more shapes!\n// trace intersections thru -1..1 unit slab and intersect the ranges incrementally\n// should initialize tmin to 0. and tmax to FLT_MAX or 3.4e38 or so\nvoid tslab(float no, float nd\n              , inout float tmin, inout float tmax)\n{\n    if (nd != 0.) {\n        float d0 = no / -nd; // d to central plane\n        nd = abs(1./nd); //nd *= sign(nd);\n        float d1 = d0 + nd;\n        d0 -= nd;\n        if (d0 > tmax\n           || d1 < tmin) {\n            tmin = tmax = -1.;\n        }\n        if (d0 > tmin) {\n            tmin = d0;\n        }\n        if (d1 < tmax) {\n            tmax = d1;\n        }\n        if (!(tmin < tmax)) {\n            tmin = tmax = -1.;\n        }\n    } else if (abs(no) <= 1.) {\n\t\t// leave unchanged\n    } else\n        tmin = tmax = -1.;\n}\n#endif\n\n    //    || length(r.d) < 1e-3 //distance(la, lb) < 1e-3 // HACK - idk, without this, when mouse is up, it looks like it had succeeded, all blue & green\n // why >= didn't fail on ball? why not fail on mouse up? agh!\n//    if (sd <= 0.) c.g += .2; // fine\n//    vec3 chit = missed ? vec3(.5,.0,.0) : vec3(0.,.5,.0);\n//    c.rgb, dline(q, la, lb) - .002, .6*chit);\n\n","name":"Common","description":"","type":"common"}]}