{"ver":"0.1","info":{"id":"mtK3Ry","date":"1684237321","viewed":48,"name":"two cups","username":"matheusfs2","description":"two c3d cups with a moving light","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDF\nfloat sdSphere(vec3 p, float r ) {\n    return length(p) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s){\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb, mat3 transform) {\n  p *= transform;\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n// Min and max functions\nvec4 minWithColor(vec4 obj1, vec4 obj2) {\n    if (obj2.a < obj1.a) return obj2;\n    return obj1;\n}\n\nvec4 maxWithColor(vec4 obj1, vec4 obj2) {\n    if (obj2.a > obj1.a) return obj2;\n    return obj1;\n}\n\n\n// Look at\nmat4 look_at(vec3 eye, vec3 at, vec3 up) {\n    vec3 w = normalize(at - eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    return mat4(\n        vec4(u, 0.0),\n        vec4(v, 0.0),\n        vec4(-w, 0.0),\n        vec4(vec3(0.0), 1.0)\n    );\n}\n\nvec4 sdScene(vec3 p) {\n    vec4 co;\n    \n    // Caneca esquerda\n    vec4 outerCylinderLeft = vec4(vec3(0.9, 0.1, 0.3), sdCappedCylinder(p - vec3(-4.5, 0, -2), 2.0, 2.0));\n    vec4 innerCylinderLeft = vec4(vec3(0.7, 0.5, 0.5), sdCappedCylinder(p - vec3(-4.5, 0., -2), 2.1, 1.7));\n    vec4 left = maxWithColor(outerCylinderLeft, innerCylinderLeft*vec4(1,1,1,-1));\n    \n    // Caneca direita\n    vec4 outerCylinderRight = vec4(vec3(0.1, 0.9, 0.3),  sdCappedCylinder(p - vec3(4.5, 0, -2), 2.0, 2.0));\n    vec4 innerCylinderRight = vec4(vec3(0.5, 0.9, 0.5), sdCappedCylinder(p - vec3(4.5, 0., -2), 2.1, 1.7));\n    vec4 right = maxWithColor(outerCylinderRight, innerCylinderRight*vec4(1,1,1,-1));\n    \n    // Juntando duas canecas na cena\n    co = minWithColor(left, right);\n    \n    // Alça esquerda\n    vec4 torusLeft = vec4(vec3(0.9, 0.1, 0.3), sdCappedTorus(p - vec3(-6.5, .0, -2.), vec2(.96, .01), 1.2, .3, rotateZ(-1.5)));\n    co = minWithColor(torusLeft, co);\n    \n    // Alça direita\n    vec4 torusRight = vec4(vec3(0.1, 0.9, 0.3), sdCappedTorus(p - vec3(2.5, 0., -2.), vec2(.96, .01), 1.2, .3, rotateZ(-1.5)));\n    co = minWithColor(torusRight, co);\n    \n    return co;\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    vec4 co;\n    for (int i = 0; i < 255; i++) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.a;\n        if (co.a < 0.001 || depth > end) break;\n    }\n    return vec4(co.rgb, depth);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // raio da esfera\n    return normalize(\n    e.xyy * sdScene(p + e.xyy).a +\n    e.yyx * sdScene(p + e.yyx).a +\n    e.yxy * sdScene(p + e.yxy).a +\n    e.xxx * sdScene(p + e.xxx).a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0.0, 4.0, 8.0);\n    mat4 view = look_at(ro, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 rd = normalize(vec3(uv, -1));\n    rd = normalize((view * vec4(rd, 1.0)).xyz);\n    \n    vec4 co = rayMarch(ro, rd, 0., 100.);\n    if (co.a > 100.0) col = vec3(0.6);\n    else {\n        vec3 p = ro + rd * co.a;\n        vec3 normal = calcNormal(p);\n        \n        vec3 lightPos = vec3(sin(iTime)*10., 2, 4);\n        vec3 lightDir = normalize(lightPos - p);\n        float ambient = 0.5;\n        float difuse = clamp(dot(normal, lightDir),ambient,1.);\n        col = difuse * co.rgb;\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}