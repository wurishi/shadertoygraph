{"ver":"0.1","info":{"id":"Nsj3Rz","date":"1616859853","viewed":541,"name":"WFC Map Hex","username":"kastorp","description":"hex version of https://www.shadertoy.com/view/sdlGzN\nwith 2 layers (terrain & buildings ->roads)","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["map","hex","tiles","generation","wfc"],"hasliked":0,"parentid":"sdlGzN","parentname":"Tiled Map (WFC)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// WFC MAP HEX by kastorp 2021\n/*\nRULES:\n    grass has higher probability\n    forest can be next to grass and has medium probability\n    water  can be next to grass and has medium probability\n    farms can be next to grass and has lower probability\n    houses can exist on grass\n    mines and mountains can exist on forest\n    roads connect houses or mines,  cannot cross water, can have sometime a junction, are more frequent in grass\n    buildings cannot have neighbour buildings\n     \nTODO: distance based rules\n*/\n\n\n#define DEBUG 0\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 i = floor(x), f = fract(x);\n    f = f*f*(3.0-2.0*f);\t\n    return mix(mix( hash(i+vec2(0,0)),hash(i+vec2(1,0)),f.x),mix( hash(i+vec2(0,1)),hash(i+vec2(1,1)),f.x),f.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 Q )\n{\n    \n    vec2 p=Q/Z +M.xy;\n    vec4 p0 = HexRep(p);\n    vec3 c= HexD(p0.xy);\n    vec2 d=p0.xy;\n    \n    uvec4 tx = TX(p0.zw);   \n    uint m =tx.x; \n    if(tx.a>1u || DEBUG==0){\n        float br1= noise(p*3.)*.2+.8,br2= noise(p*10.)*.1+.9,br3= noise(p*10.)*.4+.6,br4=mod(floor(d.x*4.)+floor(d.y*4.),2. )*.1+.9;\n\n\n        \n        //terrain\n        for(int i=0;i<6;i++) {\n            uint k= (m & (1u<<(2*i))*3u)>>(2*i);\n            if(int(c.y)==i) O = vec4(k==1u?vec3(.3,.5,0)*br1:k==2u?vec3(0,.5,.5)*br2:k==3u?vec3(.7,.6,0)*br4:vec3(0,.3,0)*br3,0);\n        }\n        \n        //building\n        uint b= (m & (1u<<24)*15u)>>24;\n        if(b==3u) {\n            //mine\n             O =mix(O,vec4(1.-br1),circle(d ,vec2(.3,0),.1));\n             O =mix(O,vec4(1.-br1),circle(d ,vec2(-.3,0),.1));\n             O =mix(O,vec4(1.-br1),circle(d ,vec2(.15,-.25),.1)); \n             O =mix(O,vec4(1.-br1),circle(d ,vec2(.15,.25),.1));\n             O =mix(O,vec4(1.-br1),circle(d ,vec2(-.15,.25),.1));\n             O =mix(O,vec4(1.-br1),circle(d ,vec2(-.15,-.25),.1));\n        }\n        if(b==2u) {\n            //mountain\n            O = mix(O,vec4(0.5,0.4,0.3,0)*br3,slice(6,(d/vec2(1,2)-vec2(0,.2))));\n            O = mix(O,vec4(0.5,0.4,0.3,0)*br3,slice(7,(d/vec2(1,2)-vec2(0,.2))));\n        }\n\n        //roads & rivers\n        float db=-1.;\n        for(int i=0;i<6;i++) { \n            \n            uint k= (m & (1u<<(2*i +12))*3u)>>(2*i+12);\n            if(k>0u) db=max(db,.06-abs(c.x));\n            if(k>0u && int(c.y)==i) db= max(db,.05-abs(c.z));\n            \n            O =mix(O, vec4(.6,.3,.1,0.),smoothstep(-TH1,0.,db));\n        }\n       \n        O =mix(O, O*.6, smoothstep(TH2,0.0,abs(db)));\n\n        if(b==1u) {\n            //house\n            O = mix(O,vec4(1,1,1,0),box((d-vec2(0,d.x)) ,vec2(.09,-.08),vec2(.05,.1)));\n            O = mix(O,vec4(0),box((d-vec2(0,d.x))       ,vec2(.09,-.08),vec2(.02,.02)));\n            O = mix(O,vec4(1,1,1,0),box(d               ,vec2(-.05,-.04),vec2(.1,.1)));\n            O = mix(O,vec4(0),box(d                     ,vec2(-.05,-.08),vec2(.02,.07)));\n            O = mix(O,vec4(.8,.6,0,0),box((d   -vec2(d.y,0))    ,vec2(-.11,.1),vec2(.1,.05)));\n        } \n\n\n        // border:\n        O =mix(O,vec4(.3,.3,.3,0),smoothstep(-TH1,0., -.52+abs(c.x)));        \n     \n    } \n    //check\n    #if (DEBUG>0)\n    if(tx.z>0u) O =mix(O,vec4(.8,.8,0,0),smoothstep(-TH1,0., -.4+abs(c.x)));          \n    if(tx.y>COLLAPSE-5u && tx.a==2u) O =mix(O,vec4(.5,.0,0,0),smoothstep(-TH1,0., -.45+abs(c.x)));\n    if(tx.y>COLLAPSE-5u && tx.a<2u) O =mix(O,vec4(1.,.0,0,0),smoothstep(-TH1,0., -.4+abs(c.x)));\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define T iTime\n#define MZ 3. \n#define Z (R.x<600.?16.: 32.) \n#define M (iMouse.x<=0.?R.xy/6.:iMouse.xy/Z*MZ)\n#define TX(p) floatBitsToUint(texelFetch(iChannel0, ivec2(p)%ivec2(R.xy),0))\n#define DIRS(d,d2) ivec2[4] (ivec2(-d,d2),ivec2(d2,d),ivec2(d,-d2),ivec2(-d2,-d)) \n#define NX(p,nb)  uvec4[6] (TX(p+ivec2(nb[0])),TX(p+ivec2(nb[1])),TX(p+ivec2(nb[2])),TX(p+ivec2(nb[3])),TX(p+ivec2(nb[4])),TX(p+ivec2(nb[5]))) \n#define B 16 //inizialition cell range \n#define COLLAPSE 25u\n#define RETRY 50\n#define RANGE 2\n\n#define TH1 0.05\n#define TH2 0.02\n\n#define slice(n,d) (smoothstep(-TH1,0.,(d.x-d.y)*(n>=4?1.:-1.)) *smoothstep(-TH1,0.,(d.x+d.y)*(n>=2 && n<=5?1.:-1.))*smoothstep(-TH1,0.,d.x*(n>=3&&n<=6?1.:-1.))*smoothstep(-TH1,0.,-d.y*(n>=5||n==0?1.:-1.)) ) \n#define box(d,c,b) smoothstep(-TH2,TH2,-max(abs(d.x-c.x) - b.x,abs(d.y-c.y) - b.y) )\n#define circle(d,c,b) smoothstep(-TH2,TH2,-length(d-c) + b )\n\n\n//-----HEX FUNCTIONS-------------\n\n//from https://www.shadertoy.com/view/Nss3Wl\n\n//output: xy= local position,zw=hex integer coordinates\nvec4 HexRep(vec2 U)\n{\n    float  d =sqrt(3.);\n    vec4 c1= vec4(U-vec2(floor(U.x-.5)+1.,floor(U.y/d)*d+d/2.),floor(U.x-.5),floor(U.y/d)*2.),\n         c2= vec4(U-vec2(floor(U.x)+.5,floor(U.y/d-.5)*d+d),floor(U.x),floor(U.y/d-.5)*2.+1.);\n    return dot(c1.xy,c1.xy) <dot(c2.xy,c2.xy) ?c1:c2;\n}\n\n//input: hex coordinates, output: neighbour relative coordinates\nivec2[6] HexNb(ivec2 n)\n{\n   int sh=n.y&1;\n   return  ivec2 [6](ivec2(-1,0),ivec2(-sh,1),ivec2(-sh+1,1),ivec2(1,0),ivec2(-sh+1,-1),ivec2(-sh,-1)); //6 neighbours  \n}\n\n//input: local position, output: x=hex distance, y=sector 0-5 , z=distance from sector center\nvec3 HexD(vec2 p)\n{ \n    float a= mod(floor(-atan(p.y,p.x)/6.283*6.+3.5),6.), aa=a/6.*6.283+1.57;\n    vec2 va=-vec2(sin(aa),cos(aa) );\n    return vec3( dot(p,va), a , p.x*va.y - p.y*va.x   );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nuint rotateMask(uint m, int r0){\n    uint mm =m;\n    int r=(r0%6);\n    \n  \n    uint terr= m & ((1u<<12)-1u),\n        conn = (m>>12)& ((1u<<12)-1u),\n        bui = (m>>24)& ((1u<<4)-1u);\n    terr = (terr>>(2*r))+ ((terr&((1u<<(2*r)) -1u   ))<<(12-2*r));\n    conn = (conn>>(2*r))+ ((conn&((1u<<(2*r)) -1u   ))<<(12-2*r));\n      \n    return terr+ (conn<<12) + (bui<<24);\n}\n\n\n\nfloat hash( in vec3 p ) {\n    p = fract( p * vec3( 19.191, 53.733, 73.761 ) );\n    p += dot( p, p + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( ( p.x +  p.y ) * p.z );\n}\n//get Random mask \nuint getTerrain(vec3 seed) {\n    \n    //road\n    uint rm=0x10000000u, //road cross\n        rm2=0x20000000u; //road start\n    \n    //terrain  5=grass,A=sea, F=farm,0=forest\n    int i=int(hash(seed)*1000.);\n    int k= int(hash(seed*2.)*100.);\n    if( i <40) return rotateMask(0x5AAu, i); //33% Grass - 66% sea\n    else if(i <80) return rotateMask(0x55Au, i); //66% Grass - 33% sea\n    else if(i <100) return rotateMask(0x559u, i); //87% Grass - 16% sea\n    \n    else if(i <160) return rotateMask(0x57Fu, i)+rm; //50% Grass - 50% farm    \n    else if(i <200) return rotateMask(0x55Fu, i)+rm; //66% Grass - 33% farm\n    else if(i <230) return rotateMask(0x557u, i)+rm; //83% Grass - 16% farm\n    else if(i <260) return rotateMask(0x5FFu, i)+rm; //33% Grass - 66% farm\n    \n    \n    else if(i <300) return rotateMask(0x540u, i)+rm; //50% Grass - 50% forest\n    else if(i <360) return rotateMask(0x550u, i)+rm; //66% Grass - 33% forest \n    else if(i <400) return rotateMask(0x500u, i)+rm; //33% Grass - 66% forest\n    else if(i <440) return rotateMask(0x554u, i)+rm; //83% Grass - 16% forest\n    else if(i <460) return rotateMask(0x41Au, i); //33% Grass - 33% forest -33% sea\n    \n\n    else if(i<580) return 0x000555u + (k<8? 0x1000000u +rm2 :rm  ); //grass\n    else if(i<770) return 0x000AAAu ; //sea\n    else if(i<910) return 0x0000000u+  (k<5?0x2000000u:k<20? 0x3000000u +rm2 : rm  ); //forest\n    else if(i<1000) return 0x000FFFu+  + (k<8? 0x1000000u +rm2 :rm  );  ; //farm\n    \n}\n\nuint getConnection(vec3 seed,uint rt) {\n    \n    if(rt==0u) return 0u;//no road\n       \n    int j=int(hash(seed*3.1)*100. );\n    if(rt>1u) return j>65? 0u:rotateMask(0x1000u, j); //start road\n    \n    //road\n    uint rm=0u;\n    if(j<5)       rm=rotateMask(0x110000u, j); //turn\n    else if(j<10) rm=rotateMask(0x101000u, j); //turn\n    else if(j<16) rm=rotateMask(0x111000u, j); //intersection\n    else if(j<18) rm=rotateMask(0x005000u, j); //narrow turn\n    else if(j<19) rm=rotateMask(0x150000u, j); //\n    else if(j<20) rm=rotateMask(0x510000u, j); //\n    else if(j<22) rm=rotateMask(0x501000u, j); //\n    else if(j<24) rm=rotateMask(0x105000u, j); //\n    else if(j<26) rm=rotateMask(0x105000u, j); //\n    else if(j<28) rm=rotateMask(0x504000u, j); //\n    else if(j<40) rm=rotateMask(0x104000u, j); //straight \n    return rm;\n    \n}\n//check if mask m is compatible (connection ad terrain) with n mask n on side i\nbvec2 check(uint m, uint n, int i){\n    uint \n        t1= (m & (1u<<(2*i))*3u)>>(2*i),        \n        c1= (m & (1u<<(2*i+12))*3u)>>(2*i+12),\n        b1 =(m & (1u<<(24))*15u)>>(24);\n    int    j=(3+i)%6;\n    uint    t2= (n & (1u<<(2*j))*3u)>>(2*j),     \n        c2= (n & (1u<<(2*j+12))*3u)>>(2*j+12),\n        b2 =(n & (1u<<(24))*15u)>>(24);\n    \n    return  bvec2( t1==t2  && (b1&b2)==0u,   c1==c2   );  \n}\n\nvoid mainImage( out vec4 O, in vec2 Q )\n{\n    ivec2 c = ivec2(Q);\n    uvec4 s=uvec4(0u);\n    uvec4 tx= TX(c);\n    if(any(greaterThan(Q,R.xy/MZ))) discard;\n    //initialize some cells (one every BxB block) with random value\n    if(iFrame==0 || tx.a==0u){\n       s= max(c.x% B,c.y %B)<1 ? uvec4(getTerrain(vec3(Q,T)),0u,0u,3u) :uvec4(0u,0u,0u,1u);\n    } \n    else\n    {       \n        uint m=tx.x, //current mask, -1= void \n            try=tx.y,//current number of failed tentatives\n            lv=tx.a;  //0=reset, 1=empty,2=terrain\n        uvec4[6] N = NX(c,HexNb(c)) ; //neighbours on 6 sides; order: Left Up Right Bottom     \n        float db=0.;\n        \n        if(lv<2u) //EMPTY\n        {\n            int b; //number of non void neighbours\n            bool ch; //=true if candidate matches neghbours\n           \n            uint mm; //candidate mask\n            for(int j=0;j<RETRY;j++){ //each frame, iterate candidate mask search\n                b=0; ch=true;\n                mm=  getTerrain(vec3(Q,T)+float(j)*3.111) ; //set candidate mask if void\n                for(int i = 0;i<6 ;i++) { \n                   if(N[i].a>1u) {\n                       b++;                   \n                       bvec2 chn = check(mm,N[i].x,i); //verify compatibility on current side\n                       ch= ch && chn.x ;//&& chn.y;\n\n                    }\n                }\n                if( ch ) break; // skip if succesfull mask search\n            }  \n            \n            if( b==0) try=0u;\n            else if(ch) { m=mm; lv=2u; try=0u; } //if compatible and connected, set candidate mask         \n            else try=(try+1u)&1023u; \n          \n        }\n        else if(lv<3u) //TERRAIN \n        {\n            \n            int b; //number of non void neighbours\n            \n            bool cht=true, chc=true;\n            uint mm; //candidate mask\n            \n            uint roadT= (m & (1u<<(28))*15u)>>(28);\n            \n            for(int j=0;j<RETRY;j++){ //each frame, iterate candidate mask search\n                b=0; cht=true;chc=true;\n                mm=  ( m & 0xFF000FFFu )+ getConnection(vec3(Q,T)+float(j)*3.111,roadT) ; //set candidate mask if void                \n                for(int i = 0;i<6 ;i++) { \n                   if(N[i].a>1u) {\n                                       \n                       bvec2 chn = check(mm,N[i].x,i); //verify compatibility on current side\n                       cht= cht && chn.x;\n                       if(N[i].a>2u //&&(N[i].x&0xFFF000u)>0u \n                           ) {b++; chc= chc && chn.x && chn.y;}\n                      \n                       \n                    }\n                    if(  N[i].y > COLLAPSE ) {if(N[i].a >1u)  chc=false; else cht=false;}\n                }\n                if( !cht ) break; // skip if succesfull mask search\n                 if( chc ) break;\n            }  \n            \n            \n            if(!cht   ) { \n                //invalidate if not compatible  \n                lv=1u; \n                try=0u; db=1.;\n            } \n            else if(chc) { m=mm; lv=3u; try=0u; } //if compatible and connected, set candidate mask         \n            else if(b==0) try=0u;\n            else try=(try+1u)&1023u; \n            \n            \n        }\n        else if(lv>=3u) // TERRAIN + ROAD\n        {\n                 \n            bool cht=true, chc=true;\n            for(int i = 0;i<6 ;i++) { \n               if(N[i].a>1u) {\n                                 \n                   bvec2 chn = check(m,N[i].x,i); //verify compatibility on current side\n                   cht= cht && chn.x;\n                   if(N[i].a>2u) chc= chc && chn.x && chn.y;\n\n                }\n                // if a neighbour as reached the try limit, invalidate current cell\n                if( N[i].y > COLLAPSE ) {if(N[i].a >1u)  chc=false; else cht=false;}\n            }               \n      \n            if(!chc || !cht ) { \n                if(((c.x+c.y+iFrame)%3)==0){\n\n                    // clean connection\n                    lv=2u; \n                    m = m & 0xFF000FFFu; \n                    try=0u; db=1.;\n                }\n            }\n            \n        }\n        \n        s=uvec4(m,try,db,lv);\n    }\n\n\n    O = uintBitsToFloat(s);\n} ","name":"Buffer A","description":"","type":"buffer"}]}