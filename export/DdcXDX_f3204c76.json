{"ver":"0.1","info":{"id":"DdcXDX","date":"1680499381","viewed":103,"name":"Pampa  glacial valleys","username":"DENFOR","description":"2023.04.03  test1  ","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lddGRr","filepath":"https://soundcloud.com/protomen/danger-zone","previewfilepath":"https://soundcloud.com/protomen/danger-zone","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  created by Kali       https://www.shadertoy.com/view/ddBSWR\n//  created by jarble     https://www.shadertoy.com/view/NdKXWm\n\n#define trail\n#define letterboxfullscreen\n//#define startinlake\n//#define noplane\n//#define onlymouse\n\n#define resolution iResolution\n#ifdef startinlake\n    #define time mod(iTime*.83+120.,200.)\n#else\n    #define time mod(iTime*.83,200.)\n#endif\n\nfloat hashseed=0.;\nfloat det=.01;\nfloat maxdist=40.;\nvec3 objcol;\nvec3 ldir;\nfloat id=0.,oc=1.,dcab=0.,t=0.,h=0.,speed=0.,baja=0.,ref=0.;\nvec3 pos, pfus, pmot, pcab, parm, pwin, ptim, ptai, tpos;\nvec3 ppos=vec3(0.),ppos2=vec3(0.);\nmat2 rotyz, rotxy, rotxz;\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat interhash(float seed, float t) {\n    t+=hash(seed+hashseed)*123.;\n    return mix(hash(floor(t)),hash(floor(t+1.)),smoothstep(.3,1.,fract(t)));\n}\n\nfloat path(float t) {\n    return sin(t+cos(t*.5687))*.5;\n}\n\n\nmat2 rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat ssub ( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat box( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat capsule( vec3 p, float h, float r )\n{\n  p.z -= clamp( p.z, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat elipse( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n//////////////////////////////////////////////// Glacial valleys v10 base Dta(1)\n#define SC (250.)  //  defa (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.); }\n\n#define OCTAVES  8   // 9\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    \n     float f = 2.15*0.9; //change this number to change the spacing of the mountains \n    //Another interesting variation: case  BB\n  //  float f = 2.15+(sin(uv.x/i1)+cos(uv.x/i1))*value1;\n    \n    float value = value1;      float amplitude = i1*value1;     float freq = i1/f;\n    float n1 = 0.;        vec2 noise2,noise1;\n    for (int i = 0; i < octaves; i++)\n    {      \n        noise2 = noise(noise1.yx+uv/freq);\n        noise1 = noise2-vec2(value)-noise1.yx*freq;\n        freq /= -f;\n        n1 = noise1.x+noise1.y;\n\n        value += n1*(amplitude-freq);\n\n        uv += noise2.yx*freq;      }     return value/3.5; }\n\nfloat fbmV(vec2 uv, int oct){    float result = 0.;\n    //uv /= 2.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;        result -= fbm1(uv,oct,i1,result/i1);    oct /= 2;\n    }\n    return result;  }\n\nfloat fbmValley(in vec2 uv){    return fbmV(uv,OCTAVES); } // => terrain(vec3 p)\n                                                              // line 272\n/*float f(in vec3 p,int iters)\n{    float h = fbm(p.xz,iters);      return h; }\n\nfloat f(in vec3 p)\n{   float h = fbm(p.xz,OCTAVES);     return h; }\n  \nvec3 getNormal(vec3 p, float t)\n{   vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),  2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n    return normalize(n);   }\n */\n\n////////////////////////////////////////      (1) END\n\nfloat cabina(vec3 p) {\n    p.z+=1.9;\n    p.y-=1.;\n    p.y+=pow(max(0.,-p.z+1.)*.31,2.);\n    p.y-=pow(max(0.,-p.z+3.5)*.3,1.5)*.1;\n    float d=elipse(p,vec3(.35,.5,2.9));\n    pcab=p;\n    dcab=d;\n    return d*.8;\n}\n\n\nfloat fuselaje(vec3 p, float cab) {\n    vec3 p2=p;\n    p.z+=5.5;\n    p.y-=smoothstep(2.,0.,p.z)*.2*abs(p.y);\n    p.y-=smoothstep(0.,4.,p.z)*.3;\n    p.y*=1.+smoothstep(4.,0.,p.z)*.2;\n    p.y-=smoothstep(2.,5.2,p.z)*.5*max(0.,p.y);\n    p.y-=min(.5,max(0.,p.z-5.2)*.06);\n    p.y*=1.+smoothstep(4.,13.,p.z)*.5;\n    p.y-=smoothstep(6.,9.,p.z)*.7*max(0.,-p.y+.3);\n    p.z*=1.+min(.2,max(0.,p.z-10.5-p.y)*.3);\n    vec3 t=vec3(.55,.7,5.5);\n    t.y*=1.-smoothstep(2.,11.,p.z)*.4;\n    p.x*=1.+smoothstep(8.,9.,p.z)*.25;\n    p.z-=5.5;\n    float d=elipse(p,t);\n    pfus=p;\n    p2.y+=.1;\n    d=max(d,-length(p2.xy)+.7*step(0.,p2.z));\n    oc*=step(0.,d+.2);\n    d=max(d,-cab);\n    return d*.5;\n}\n\nfloat motor(vec3 p) {\n    p*=1.05;\n    p.z-=.4;\n    p.y-=.25+exp(-5.*abs(p.x))*.1*smoothstep(2.,0.,p.z)+p.z*.03;\n    float h=length(pow(abs(p.xy),vec2(1.5))*vec2(1,3.))-.62+max(0.,p.z+1.);\n    h=min(h,length(p.xy)-.27);\n    float sc=1.+min(2.,pow(max(0.,p.z+2.3)*.23,3.));\n    p.x*=sc;\n    p.y*=1.+min(.5,pow(abs(p.z)*.37,6.));\n    p.y*=1.+min(1.,pow(max(0.,p.z+1.),2.)*.05);\n    p.x*=1.+min(1.,pow(abs(p.y),2.5));\n    float d=box(p,vec3(.65,.45,2.3),.2+max(0.,p.z)*.05);\n    oc*=max(0.,sign(d+.1));\n    d=ssub(h,d,.1*step(0.,-p.z));\n    pmot=p;\n    return d*.5/sc;\n}\n\nfloat alas(vec3 p) {\n    p.y-=1.2-abs(p.x)*.07;\n    p.z-=.3;\n    p.x+=smoothstep(0.,1.8,-p.z)*sign(p.x);\n    float w=abs(p.x)*.1;\n    p.y*=.7+min(1.5,pow(abs(p.z+.3),3.)+abs(p.x)*.3);\n    float d=box(p,vec3(4.5,-.1,.9-w),.2);\n    p.z+=w;\n    pwin=p;\n    return d*.4;\n}\n\nfloat cola(vec3 p) {\n    p.y-=1.-abs(p.x)*.15;\n    p.z-=4.;\n    p.z-=abs(p.x)*.3*smoothstep(-.2,0.2,-p.z);\n    float w=abs(p.x)*.1;\n    p.y*=.7+min(1.,pow(abs(p.z+.3),3.)+abs(p.x)*.5);\n    float d=box(p,vec3(1.7,-.13,.5),.2);\n    ptai=p;\n    return d*.5;\n}\n\nfloat timon(vec3 p) {\n    p.y-=1.;\n    p.z-=3.8;\n    p.z-=p.y*(step(p.z-.5,0.)+1.)*.4;;\n    float d=box(p,vec3(-.05-p.z*.02,1.5,.8),.1);\n    d=max(d,-p.y);\n    ptim=p;\n    return d*.5;\n\n}\n\nfloat arma1(vec3 p) {\n    p.y-=.3;\n    float b=box(p-vec3(0,0,p.y*.5),vec3(.0,.2,.35),0.05);\n    p.y+=.3;\n    p.z+=.9;\n    p.z-=length(p.xy)*.5;\n    float c=capsule(p,1.3,.23);\n    float d=min(b,c);\n    objcol+=max(0.,sign(.1-d))*vec3(1,0,0);\n    return d*.5;\n}\n\n\nfloat armas(vec3 p) {\n    vec3 p2=p;\n    p.x=abs(p.x)-1.5;\n    p.y-=.7;\n    p2.x=abs(p2.x)-2.;\n    p2.z-=.2;\n    p2.y-=.45;\n    float ar2=arma1(p2);\n    parm=p2;\n    return ar2;\n}\n\n/// Simple noise algorithm by Trisomie21\nfloat snoise( vec2 p ) {\n    p.y-=hashseed*100.;\n    p.xy=p.yx;\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1., v+1000.0, v+1001.);\n\tr = fract(12345.*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\n\nfloat terrain( vec2 p) {\n\tfloat h = 0.0; \n\tfloat w = .5; \n\tfloat m = .5; \n\tfor (int i=0; i<5; i++) {\n\t\th += w * snoise((p * m));\n\t\tw *= .25;\n\t\tm *= 4.;\n\t}\n    return h;\n}\n\nfloat terrain(vec3 p) {\n    if (p.y>2.) return p.y+2.;\n    p.z+=time*3.;\n    float ini=smoothstep(100.,70.,p.z);\n    p.x+=ini*4.5;\n    p.y+=.4+smoothstep(120.*3.,130.*3.,p.z)*.65;   // case default\n   //   p.y+=.4+smoothstep(230.,50.,p.z)*.65;      // case aaa\n      \n    p.x-=path(p.z);\n    \n//\th = terrain(p.xz*vec2(.5,1.)) * 1.2;         // default\n    h =     fbmValley(p.xz*vec2(1.,1.))  *1.2 ;  // Glacial valleys\n    \n\th += smoothstep(-0.3, 1.5, h);\n    h*=1.-ini*.7;\n\tfloat ap=.3+max(0.,sin(p.z*.05+cos(p.z*.123)*.0))*.5;\n       // case AA\n    h=mix(h*0.9,-1.*2.+1.3,exp(-ap*(abs(p.x-.5*snoise(p.zx*.5)))));\n    \n    //case BB\n // h=mix(h*0.9,-1.+1.3*0.,exp(-ap*(/*abs*/(p.x-.5*snoise(p.zz*.5)))));\n\n   // case CC  (like voronoy  (cut top of mountains)\n //     h=mix(h*0.9,-1.*2.+1.3,exp( 0.4*(abs(abs(p.x-.5*snoise(p.zx*.5) -p.x*2.) )   ) ));   \n    \n\tfloat d = p.y - h;\t\n    tpos=p;\n\treturn d*.5;\n}\n\nfloat pampa(vec3 p) {\n    p.z+=2.8;\n    p.y-=.8;\n    p.yz*=rotyz;\n    p.xz*=rotxz;\n    p.z-=2.8;\n    p.y+=.8;\n    p.xy*=rotxy;\n    float bound=box(p,vec3(5.,3.,6.),0.);\n#ifdef noplane\n    bound=box(p,vec3(1.,1.,2.3),0.);id=1.;return bound;\n#endif\n    if (bound>.65) return bound+.65;\n    objcol=vec3(1.);\n    p.z*=-1.05;\n    float cab=cabina(p);\n    float fus=fuselaje(p,cab);\n    float mot=motor(p);\n    float win=alas(p);\n    float tai=cola(p);\n    float tim=timon(p);\n    cab=abs(cab)-.02;\n    float arm=armas(p);\n    float d=smin(fus,cab,max(.001,.02*p.z));\n    d=min(d,mot);\n    d=min(d,win);\n    d=min(d,tai);\n    d=min(d,tim);\n    d=min(d,arm);\n    if (d==fus) id=0.;\n    if (d==mot) id=1.;\n    if (d==cab) id=2.;\n    if (d==win) id=3.;\n    if (d==tai) id=4.;\n    if (d==tim) id=5.;\n    if (d==arm) id=6.;\n    float t=step(abs(pcab.z+.3-pcab.y*.5),.07);\n    t=max(t,step(abs(pcab.z+1.4+pcab.y*.3),.05));\n    id-=step(1.,t);\n    id=max(0.,id);\n    pos=p;\n    return d*1.2;\n}\n\n\nfloat water(vec3 p) {\n    p.z+=time*3.*1.5;\n    p.x-=path(p.z);\n    p.x*=2.;\n    return (p.y+1.75+snoise(p.xz*20.+time*0.)*.0002)*.9;\n}\n\nvec2 contrail(vec3 p) {\n    vec3 pp=p-ppos;\n    float t2=(tpos.z/3.)*speed-2.+.04*speed;\n    float chx=(interhash(0.,t2)-.5)*4.5;\n    float chy=.8+(interhash(-10.,t2*.75)-.5)*1.5+.018-baja;\n    float w=.003+min(.05,-pp.z*.005)*2.;\n    w=min(.03,w);\n    float chorro=length(p.xy-vec2(chx,chy))-snoise(tpos.zz*15.)*w*.4;\n    chorro=max(.003,abs(chorro));\n    chorro=max(chorro,pp.z+.1);\n    chorro=max(chorro,-pp.z-14.);\n    return vec2(chorro,w);\n}\n\n\nfloat de(vec3 p) {\n    vec3 pos=p-ppos;\n    float pam=pampa(pos*20.)/20.;\n    float ter=terrain(p/1.5)*1.5;\n    float wat=water(p);\n    float d=min(wat,ter);\n    d=min(d,pam);\n    if (d==ter) id=-1.;\n    if (d==wat) id=-2.;\n    return d;\n}\n\n\nfloat ao(vec3 p, vec3 n) {\n    float st=.05;\n    float ao=0.;\n    for(float i=0.; i<8.; i++ ) {\n        float td=.02+st*i;\n        float d=de(p+n*td);\n        ao+=max(0.,(td-d)/td);\n    }\n    return clamp(1.-ao*.15,0.,1.);\n}\n\nfloat shadows(vec3 p, vec3 ldir) \n{\n    float td=.0,sh=1.,d=.01,dt;\n    for (int i=0; i<50; i++) {\n\t\tp+=ldir*d;\n        float map=de(p);\n        vec2 ctrail=contrail(p);\n        dt=ctrail.x-ctrail.y*1.5+.05;\n        d=min(map,dt);\n        td+=d;\n        if (dt<.05&&map>.01) {\n            sh=.6+ctrail.y*8.; break;\n        }\n\t\tif (d<.002) {\n            sh=.5;\n            break;\n        }\n        if (td>maxdist) break;\n    }\n    return clamp(sh,0.5,1.);\n}\n\n\nvec3 normal3(vec3 p) {\n    vec2 e=vec2(0.,det*.5);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\n/// normal hack by Shane to reduce compilation time\nvec3 normal(vec3 pos) {\n    vec2 e=vec2(0.,det*.5);\n    vec3[4] ev = vec3[4](e.yxx, e.xyx, e.xxy, e.xxx-.000001);\n    vec3 nn = vec3(0);\n    for(int i = 0; i<4; i++){\n        nn += sign(ev[i])*de(pos + ev[i]);\n        if(nn.x<-1e8) break; // Fake break.\n    } \n    return normalize(nn);\n}\n\nvec3 normal2(vec3 p) {\n    vec2 e=vec2(0.,det*.5);\n    return normalize(vec3(water(p+e.yxx),water(p+e.xyx),water(p+e.xxy))-water(p));\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\nfloat fbm(in vec3 q)\n{\n\tfloat f  = 0.5000*noise( q ); q = m3*q*2.01;\n\tf += 0.2500*noise( q ); q = m3*q*2.02;\n\tf += 0.1250*noise( q ); q = m3*q*2.03;\n\tf += 0.0625*noise( q ); q = m3*q*2.04;\n\treturn f;\n}\n\nvec3 pampaColors() {\n    vec3 base=vec3(117.,170.,219.)/255.;\n    vec3 sec=vec3(1.,.7,.3);\n    vec3 ter=mix(sec,base,(1.+cos(pos.z*3.))*.5);\n    ter=base;\n    vec3 col=mix(base,vec3(.9),smoothstep(.55,.6,max(noise(floor(pos*2.)),noise(floor(pos*4.)))));\n    col=mix(col,base,abs(pmot.x)*.25);\n    if (id==0.) {\n        col=mix(col,ter,step(abs(pfus.x+(noise(pos*5.+4.)-.5)*.0),.2));\n    }\n    if (id==2.) {\n        vec3 cab=vec3(.1);\n        float t=step(.07,abs(pcab.z+.3-pcab.y*.5));\n        t=min(t,step(.05,abs(pcab.z+1.4+pcab.y*.3)));\n        col=mix(ter,cab,t);\n    }\n    if (id==1.) {\n        col=mix(col,sec,step(2.1,-pmot.z)*step(0.,dcab-.1));\n        col=mix(col,sec,step(2.2,pmot.z));\n    }\n    if (id==3.) {\n        pwin.x=abs(pwin.x);\n        col=mix(col,sec,step(4.3,abs(pwin.x)));\n        col-=step(abs(pwin.z-.7),.03)*.2*step(pwin.x,4.3);\n        if (pwin.z>0.7) {\n            col-=step(abs(pwin.x-3.5),.03)*.2;\n            col-=step(abs(pwin.x-1.5),.03)*.2;\n        }\n    }\n    if (id==4.) {\n        ptai.x=abs(ptai.x);\n        col=mix(col,sec,step(1.6,ptai.x));\n        col-=step(abs(ptai.z-.35),.03)*.2*step(ptai.x,1.2);\n        col-=step(abs(ptai.x-1.2),.03)*.2;\n    }\n    if (id==5.) {\n        col=mix(col,sec,step(1.3,ptim.y));\n        col-=step(abs(ptim.z-.5),.03)*.2*step(ptim.y,1.3);\n    }\n    if (id==6.) {\n        col=mix(col,ter,step(length(parm.xy),.25));\n    }\n    \n    col*=.5+oc*.5;\n    col*=1.05-noise(pos*20.)*.1;\n    return col*vec3(1.,.95,.9);\n}\n\n/*                                             // default  case A\nvec3 terrainColors(vec3 p, vec3 n, float y) {\n //   vec3 col = mix( vec3(0.2, 0.18, 0.18)*.7, vec3(0.22, 0.19, 0.16)*.8, \n //                    smoothstep(0.7, 1.0, n.y) *.5) * 3.;\n //   float r=snoise(p.xy*vec2(7., 50.0)*2.)*.8;\n //   col = mix( r*vec3(.5, 0.4, 0.4), col, n.y);   // default\n    //////////////////////////////////////////////////// Glacial vallyey\n    vec3 col = mix( vec3(1.)*.7, vec3(1.2)*.8, \n                     smoothstep(0.7, 1.0, n.y) *.5) * 3.;\n    float r=snoise(p.xy*vec2(7., 50.0)*2.)*.8;\n    col = mix( r*vec3(0.9*1.2), col, n.y); \n    \n     \n    float clear=smoothstep(.0,.07,h+.75);\n//  vec3 veg=vec3(.9, .77, .6)*.4;\n    vec3 veg =vec3( 1.  )  *0.4  ;\n    \n    veg=mix(veg,vec3(1.1,.95,0.7)*.23,smoothstep(0.,.5,snoise(p.xz*.5)));\n    veg*=(1.+snoise(p.xz*90.)*.3);\n    col = mix( col, veg, clear*smoothstep(.8, .9, n.y) *smoothstep(1.,0.,snoise(p.xz+123.)));\n    col*=1.-smoothstep(-.3,-1.2,p.y)*.7;\n    return col*1.6;\n}\n  */\n//////////////////////////////////////case B     glacial valley lightning (3) ==terrainColors()\nvec3 terrainColors /*lighting*/(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1.5) ; //  def  vec3(1., .956, .839);\n    \n //   vec3 albedo = vec3(1.09);      // case AA Default    White glacial valleys\n     vec3 albedo =vec3(abs(cos(iTime*0.16 )),abs(sin(iTime*0.2)), \n                      1.+sin(iTime*0.2) ) ;  //case BB     Fantastic Valleys\n    \n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0.9, .96, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\n////////////////////////////////////////////                 (3) End\n\n\nvec3 shade(vec3 p, vec3 dir) {\n    float y=tpos.y-h;\n    float id2=id;\n    vec3 n = normal(p);   vec3 L =vec3(0.,1.,-1.) ;\n    vec3 col;\n    float oc=1.;                                        // case A    \n  //  if (id<0.) col=terrainColors(tpos,n,y ),oc=ao(p,n); else col=pampaColors();\n                                                        // case B\n    if (id<0.) col=terrainColors(tpos,n,L/*ldir*/,dir ),oc=ao(p,n); else col=pampaColors();\n                                                        \n                                                        \n    float amb=max(.5,dot(-dir,n))*.5*oc;\n    amb=.4*oc;\n    float sh=1.;\n    if (ref<.5) sh=shadows(p,ldir);\n    \n // float dif=max(0.,dot(ldir,n))*.6;  default\n    vec3 albd =vec3(1.5) ;\n    vec3 dif =max( vec3(0.),dot(ldir,n)*albd )*0.6 ;\n    \n    \n    vec3 refl=reflect(ldir,n);\n    float spe=pow(max(0.,dot(dir,refl)),50.);\n    if (id2!=2.) spe*=.3;\n    if (id2<0.) spe*=.4;\n    \n    return col*(amb+dif*sh)+spe*sh*vec3(1.1,1.,.9);\n}\n\nvec3 shadeRiver(vec3 p, vec3 dir) {\n    float sh=1.;\n    vec3 n = normal(p);\n    float tr=smoothstep(120.*3.,130.*3.,tpos.z);\n    vec3 col=mix(vec3(0.14,0.12,0.1)*2.,vec3(0.1,0.1,0.105)*3.3,tr);\n    col+=smoothstep(.05,.0,tpos.y-h)*.2;\n    vec3 refl=reflect(ldir,n);\n    float spe=pow(max(0.,dot(dir,refl)),30.)*.55;\n    return col*(.7+sh*.3)+spe;\n}\n\nvec3 shadeVid(vec3 p, vec3 dir) {\n    vec3 cab=vec3(.1);\n    float t=step(.07,abs(pcab.z+.3-pcab.y*.5));\n    t=min(t,step(.05,abs(pcab.z+1.4+pcab.y*.3)));\n    vec3 col=cab;\n    vec3 n = normal(p);\n    float amb=.4;\n    float dif=max(0.,dot(ldir,n))*.5;\n    vec3 refl=reflect(ldir,n);\n    float spe=pow(max(0.,dot(dir,refl)),30.)*1.5;\n    return col*(amb+dif)+spe*vec3(1.1,1.,.9);\n}\n\n\n\nvec3 march(vec3 from, vec3 dir, vec2 uv) \n{\n    ldir = normalize(vec3(1,1.,1.5));\n    float d, td=0., td2=0., vid=0., g=0.,aro=g, chorro=1.;\n    vec3 p=from, col=vec3(.0), colvid=col, shaderef=col, pp=p, pref=p, odir=dir;\n    float h=hash(uv*1000.)*.1;\n    for (int i=0; i<250; i++) {\n        p+=d*dir;\n        d=de(p)*(1.0-h);\n        det=id<0.?.003:.0002;\n        det*=1.0+pow(td,1.2)*.75;\n        if (id==2.&&d<det) {\n            if (vid<.5) colvid=shadeVid(p,dir);\n            vid=1.;\n            d=max(.01,abs(d));\n        };\n        if (id==-2.&&d<det&&ref<.5) {\n            ref=1.;\n            pref=p;\n            vec3 n=normal2(p);\n            dir=reflect(dir,n);\n            p+=dir*.05;\n            td2=td;\n            d=det;\n            //continue;\n        };\n        if (d<det || td>maxdist) break;\n        pp=p-ppos;\n        aro=max(abs(pp.y)-.005,abs(length(pp.xz)-.3));\n        if (time>1.5 && time < 8.) d=min(d,aro);\n#ifdef trail\n        if (pp.z<-.1&&p.z>-14.){\n            vec2 ctrail=contrail(p);\n            float chorro=ctrail.x;\n            float w=ctrail.y;\n            d=min(d,chorro*(.5+w*17.));\n            g=max(g,max(0.,w-chorro)/w*smoothstep(-14.,0.,pp.z)*(1.-ref*.5)\n                *smoothstep(-.07,-.35,pp.z));\n        }\n#endif        \n        td+=d;\n    }\n    float id2=id;\n    float clou=0.;\n    vec3 sky=mix(vec3(.75,.77,.85)*1.0,vec3(0.6,.7,.85)*.9,clamp(p.y*.07+.2,-.4,1.))*.8;\n    sky+=pow(max(0.,dot(dir,ldir)),70.)*vec3(1.4,1.,.6)*.5;\n    vec3 colref=vec3(0.);\n    if (d<det&&d!=aro) {\n        p-=det*dir*2.;\n        col=shade(p, dir);\n    } else {\n        td=maxdist;\n        p=dir*maxdist;\n        vec3 ps=dir*2.5;\n        ps.y*=4.;\n        ps.z+=time*.05;\n        clou=fbm(ps);\n        clou=smoothstep(.4,1.2,clou);\n        clou*=smoothstep(0.,5.,p.y);\n    }\n    if (ref>.5) {\n        shaderef=shadeRiver(pref,odir);\n        colref=mix(shaderef,sky,td2/maxdist);\n    }\n    sky+=clou*step(td-.5,maxdist)*.3*vec3(1.,.85,.6)*(1.+ref*.7);\n    col=mix(col,sky,pow(td/maxdist,1.5));\n    col=mix(col,colvid,vid*.5);\n    if (ref>.5) col=colref*.5+col*.5;\n    col=mix(col,col.ggg,smoothstep(1.,0.,t));\n    vec3 back = vec3(length(smoothstep(.8,1.,fract(uv*20.)))*.2);\n    float b=max(-1.,1.5-time);\n    float c=max(-1.,3.7-time);\n    float li=smoothstep(.01,.0,abs(uv.x+.5-b))*step(abs(uv.y+.025),.425*min(1.,time*2.));\n    back+=li*step(.5,fract(sqrt(time*13332.654)));\n    back+=hash(uv*1234.+time)*.2;\n    if (time>2.5) {\n        li=smoothstep(.01,.0,abs(uv.y+.5-c))*step(abs(uv.x+.025),.425*min(1.,time*2.));\n        back+=li*step(.5,fract(sqrt(time*13332.654)));\n    }\n    if (id2<0.||uv.x<b-.5||(time>2.5&&uv.y<c-.5)) col=mix(col,back,smoothstep(1.,0.,t));\n    if (fract(time*10.)*step(abs(time-8.5),.5)>.5) col=back;\n    col=mix(col,back,step(time,9.5)*step(aro,d)*step(.5,fract(time*2.+1.*atan(pp.x,pp.z))));\n    g*=smoothstep(0.5,1.,t);\n    col=mix(col,vec3(0.94,.85,0.15),g*.5);  // def vec3(0.85) white col\n    return col;\n}\n\nmat3 lookat(vec3 dir,vec3 up) {\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    hashseed=floor(iTime*.83/200.);\n    vec2 uv = gl_FragCoord.xy/resolution.xy-.5;\n    uv.x*=resolution.x/resolution.y;\n    float fov=1.1;\n    fragColor=vec4(0.);\n#ifdef letterboxfullscreen\n    if (resolution.x>1500.&&abs(uv.y)>.37) return;\n    if (resolution.x>1500.) fov=.8;\n#endif\n    speed=.25;\n    t=time*speed-2.;\n    float start=smoothstep(0.,.5,t);\n    float t1=t*start;\n    float t2=time*speed+.13-2.;\n    t2*=start;\n    float z=-.65-interhash(11.,t1)*1.8;\n    float xz=1.-interhash(22.,t1*.5)*5.;\n    float yz=.3-interhash(33.,t1*.5)*1.1;\n    ppos.x=(interhash(0.,t1)-.5)*4.5;\n    ppos2.x=(interhash(0.,t2)-.5)*4.5;\n    baja=smoothstep(125.,130.,time)*1.65;\n    ppos.y=.8+(interhash(-10.,t1*.75)-.5)*1.5-baja;\n    ppos2.y=.8+(interhash(-10.,t2*.75)-.5)*1.5-baja;\n    rotyz=rot((ppos.y-ppos2.y)*.5);\n    rotxy=rot((ppos.x-ppos2.x)*.8);\n    rotxz=rot((ppos.x-ppos2.x)*.3);\n    vec3 from=vec3(0.,0.3,z);\n    vec2 m=iMouse.xy/iResolution.xy;\n    bool mouseon=false;\n#ifndef onlymouse\n    if (iMouse.z<1.) {\n        from.yz*=rot(yz);\n        from.xz*=rot(xz);\n    } else {\n        from.yz*=rot(.5-(1.-m.y)*1.5);\n        from.xz*=rot(-m.x*6.);\n        mouseon=true;\n    }\n#endif\n#ifdef onlymouse\n    from.yz*=rot(.5-(1.-m.y)*1.5);\n    from.xz*=rot(-m.x*6.);\n    mouseon=true;\n#endif\n    from+=ppos;\n    if (!mouseon && mod(time,30.)>24.) from=vec3(.7,0.,mod(-time*4.,30.)-15.),fov*=1.3;\n    vec3 g=mix(vec3(0.5,1.,0.),vec3(1.),smoothstep(0.,1.,t));\n    if (t<0.) {\n        ppos=vec3(0.);\n        ppos2=ppos;\n        from=vec3(0.,.6,-0.1);\n        if (time>2.8) from=vec3(.5,.3,0.), from.xz*=rot(-time*.3);\n    }\n    vec3 dir=normalize(vec3(uv,fov));\n    float s=sin(time*.3);\n    dir.xz*=rot(s*s*s*.25*start);\n    dir=lookat(ppos-from,vec3(0.,1.,0.))*dir;\n    vec3 col=march(from,dir,uv*max(1.,2.-time*2.))*g;\n    col=pow(col,vec3(1.2))*1.15;\n    col*=smoothstep(200.,198.,mod(time,200.));\n    col*=smoothstep(0.,.5,mod(time,200.));\n    fragColor = vec4(col,1);\n}\n\n","name":"Image","description":"","type":"image"}]}