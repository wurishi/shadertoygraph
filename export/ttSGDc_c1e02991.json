{"ver":"0.1","info":{"id":"ttSGDc","date":"1561342576","viewed":125,"name":"Ray Tracing in a Weekend, Ch. 9","username":"fhecht","description":"This is a tutorial style implementation of classic ray tracing following the \"Ray Tracing in One Weekend\" course by Peter Shirley. This is the code up to chapter 9.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Read the Buffer A texel\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    // Apply gamma correction and write to main buffer\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// -------------------------------------------------------------------------\n// Struct definitions and scene setup\n// -------------------------------------------------------------------------\n\n// Camera parameters\nvec3 lower_left_corner = vec3(-1.0, -1.0, -1.0);\nvec3 horizontal = vec3(2, 0, 0);\nvec3 vertical = vec3(0, 2, 0);\nvec3 origin = vec3(0, 0, 0);\n\n// Ray struct\nstruct Ray {\n    vec3 o;\n    vec3 d;\n    float mint;\n    float maxt;\n};\n\n// Materials\n#define MAT_DIFFUSE\t\t0\n#define MAT_METAL \t\t1\n#define MAT_DIELECTRIC  2\nstruct Material {\n    int type;\n    vec3 albedo;\n    float roughness;\n};\n\nconst int NUM_MATERIALS = 5;\nconst Material materials[NUM_MATERIALS] = Material[NUM_MATERIALS](\n    Material(MAT_DIFFUSE, vec3(0.18), 0.0),\n    Material(MAT_DIFFUSE, vec3(0.18, 0.18, 0.0), 0.0),\n    Material(MAT_METAL, vec3(0.18, 0.0, 0.0), 0.0),\n    Material(MAT_METAL, vec3(0.18), 1.0),\n    Material(MAT_DIELECTRIC, vec3(1.0, 1.0, 1.0), 0.0)\n);\n\n// Geometry\nstruct Sphere {\n    vec3 c;\n    float r;\n    int materialId;\n};\n\nconst int NUM_SPHERES = 4;\nconst Sphere spheres[NUM_SPHERES] = Sphere[NUM_SPHERES](\n    Sphere(vec3(0.0, 0.0, -1.0), 0.5, 1),\n    Sphere(vec3(-1.0, 0.0, -1.0), 0.5, 4),\n    Sphere(vec3(1.0, 0.0, -1.0), 0.5, 3),\n    Sphere(vec3(0.0, -10000.5, -1.0), 10000.0, 0)\n);\n\n// Hit record information\nstruct HitRecord {\n    float t;\n    vec3 P;\n    vec3 N;\n    int materialId;\n};\n\n// -------------------------------------------------------------------------\n// Probabilistic math helper functions\n// -------------------------------------------------------------------------\n\n// commonly used randomizer function from shadertoy\nfloat nrand(vec2 n)\n{\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// randomizer function that changes from frame to frame\n// takes a seed to make individual draws different\nfloat trand(vec2 n, float seed)\n{\n    return nrand(n * seed * float(iFrame));\n}\n\nvec3 randomPointInUnitSphere(vec2 uv, float seed)\n{\n    // this is doing rejection sampling, which is simple but not super\n    // efficient\n    vec3 p;\n    do {\n        p = vec3(trand(uv, seed),\n                 trand(uv, 2.333*seed),\n                 trand(uv, -1.134*seed));\n        seed *= 1.312;\n    } while (dot(p, p) >= 1.0);\n    return p;\n}\n\n// -------------------------------------------------------------------------\n// Intersection code\n// -------------------------------------------------------------------------\n\n// intersect a ray with a single sphere\n// returns true if there was a valid intersection, which includes checks\n// against the mint and maxt range of the ray. In case of a valid\n// intersection the information in the HitRecord is filled in\nbool hitSphere(Ray r, Sphere s, out HitRecord hit)\n{\n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(oc, r.d);\n    float c = dot(oc, oc) - s.r * s.r;\n    float det = b*b - 4.0*a*c;\n    if (det < 0.0) {\n        return false;\n    }\n    \n    // first possible intersection\n    float t = (-b - sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.o + t * r.d;\n        hit.N = normalize(hit.P - s.c);\n        hit.materialId = s.materialId;\n        return true;\n    }\n\n    // second possible intersection\n    t = (-b + sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.o + t * r.d;\n        hit.N = normalize(hit.P - s.c);\n        hit.materialId = s.materialId;\n        return true;\n    }\n\n    return false;\n}\n\n// intersect against all spheres and return the first hit\nbool hitSpheres(Ray r, Sphere spheres[NUM_SPHERES], out HitRecord hit)\n{\n    bool hitSomething = false;\n    for (int i = 0; i < spheres.length(); ++i) {\n        if (hitSphere(r, spheres[i], hit)) {\n            hitSomething = true;\n            // if we hit a sphere we update maxt on the ray to only find\n            // intersections that are even closer\n            r.maxt = hit.t;\n        }\n    }\n    \n    return hitSomething;\n}\n\n// -------------------------------------------------------------------------\n// Materials\n// -------------------------------------------------------------------------\n\nbool DiffuseScatter(inout Ray r,\n                    vec2 uv,\n                    HitRecord hit,\n                    vec3 albedo,\n                    out vec3 attenuation)\n{\n    vec3 randomPoint = randomPointInUnitSphere(uv, 1.0);\n    vec3 target = hit.P + hit.N + randomPoint;\n    r = Ray(hit.P, target - hit.P, 0.001, 1e20);\n    attenuation = albedo;\n    return true;\n}\n\nbool MetalScatter(inout Ray r,\n                  vec2 uv,\n                  HitRecord hit,\n                  vec3 albedo,\n                  float roughness,\n                  out vec3 attenuation)\n{\n    // compute the reflection vector\n    vec3 reflected = reflect(normalize(r.d), hit.N);\n    // apply roughness sampling around the reflection vector\n    vec3 randomPoint = randomPointInUnitSphere(uv, 1.0);\n    reflected += roughness * randomPoint;\n\n    // note the small epsilon to avoid self intersection\n    r = Ray(hit.P, reflected, 0.001, 1e20);\n    attenuation = albedo;\n    \n    // it's possible we reflected inside of the object, we will\n    // absorb that ray\n    return dot(reflected, hit.N) > 0.0;\n}\n\n// Schlick's approximation to the Fresnel formula\nfloat schlickFresnel(float cosTheta, float refIdx)\n{\n    float r0 = (1.0 - refIdx) / (1.0 + refIdx);\n    r0 = r0*r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosTheta, 5.0);\n}\n\nbool DielectricScatter(inout Ray r,\n                       vec2 uv,\n                       HitRecord hit,\n                       vec3 albedo,\n                       float roughness,\n                       out vec3 attenuation)\n{\n    // hard coded index of refraction of the inside (~water)\n    // the outside is assumed to be air with an IOR = 1.0\n    const float refIdx = 1.3;   \n    // eta is Ni/No, in which N is the index of refraction\n    // of either the inside or outside\n    float eta; \n    vec3 outwardNormal;\n    float cosTheta;\n    \n    vec3 Dn = normalize(r.d);\n    \n    // based on whether the ray is entering or leaving the\n    // surface we compute things slightly differently\n    if (dot(r.d, hit.N) > 0.0) {\n        outwardNormal = -hit.N;\n        eta = refIdx;\n        cosTheta = refIdx * dot(Dn, hit.N);\n    } else {\n        outwardNormal = hit.N;\n        eta = 1.0f / refIdx;\n        cosTheta = -dot(Dn, hit.N);\n    }\n\n    attenuation = albedo;\n\n    vec3 reflected = reflect(Dn, hit.N);\n    vec3 refracted = refract(Dn, outwardNormal, eta);\n    \n    // check if refraction is possible (refract != vec3(0.0))\n    // and if so compute the probabilty to reflect or refract\n    float reflectProb = 1.0;\n    if (dot(refracted, refracted) > 0.001) {\n        reflectProb = schlickFresnel(cosTheta, refIdx);\n    }\n    \n    // draw a random number and based on the probability choose\n    // to reflect or refract\n    float u = trand(uv, 0.723);\n    if (u < reflectProb) {\n        r = Ray(hit.P, reflected, 0.001, 1e20);\n    } else {\n        r = Ray(hit.P, refracted, 0.001, 1e20);\n    }\n    \n    return true;\n}\n\nbool Scatter(inout Ray r, vec2 uv, HitRecord hit, out vec3 attenuation)\n{\n    // based on the material ID of the current hit, extract the right\n    // material parameters and call the specific scatter function\n    Material mat = materials[hit.materialId];\n    if (mat.type == MAT_DIFFUSE) {\n        return DiffuseScatter(r, uv, hit, mat.albedo, attenuation);\n    } else if (mat.type == MAT_METAL) {\n        return MetalScatter(r, uv, hit, mat.albedo, mat.roughness, attenuation);\n    } else if (mat.type == MAT_DIELECTRIC) {\n        return DielectricScatter(r, uv, hit, mat.albedo, mat.roughness, attenuation);\n    } else {\n        return false;\n    }\n}\n\n// -------------------------------------------------------------------------\n// Core integrator\n// -------------------------------------------------------------------------\n\nvec3 missedColor(vec3 rayDir)\n{\n    vec3 unitDir = normalize(rayDir);\n    float t = 0.5 * (unitDir.y + 1.0);\n    return mix(vec3(1.0,1.0,1.0), vec3(.5, .7, 1.0), t);\n}\n\nconst int MAX_DEPTH = 20;\nvec3 traceRay(Ray r, vec2 uv)\n{\n    vec3 result = vec3(1.0);\n    float seed = 1.0;\n\n    // GLSL can't do recursion, but we can emulate that easily with a loop\n    int i = 0;\n    for (; i < MAX_DEPTH; ++i) {\n        // trace the current ray and see if we hit something\n        HitRecord hit;\n        if (hitSpheres(r, spheres, hit)) {\n            // compute scattering and attenuation. This will update the ray\n            // with a new origin and direction for the next trace\n            vec3 attenuation;\n            if (Scatter(r, uv * seed * 0.897, hit, attenuation)) {\n                result *= attenuation;\n            } else {\n                // if we don't scatter we absorb the ray\n                result = vec3(0.0);\n                break;\n            }\n            seed *= 1.456;\n        } else {\n            // if we leave the scene (no hit) we look-up the sky color\n            result *= missedColor(r.d);\n            break;\n        }\n    }\n    \n    // if we did not leave the scene after MAX_DEPTH bounces we absorb the\n    // ray\n    if (i == MAX_DEPTH) {\n        result = vec3(0.0);\n    }\n\n    return result;\n}\n\n// -------------------------------------------------------------------------\n// Camera code\n// -------------------------------------------------------------------------\n\nRay computeCameraRay(vec2 uv)\n{\n    // compute two random numbers [0, 1) that are different each frame\n    float xi0 = trand(uv, 0.123);\n    float xi1 = trand(uv, 0.456);\n    // move the pixel position by a fraction of a pixel for anti-aliasing\n    uv += vec2(xi0, xi1) / iResolution.xy;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    Ray r;\n    r.o = origin;\n    r.d = lower_left_corner * vec3(aspectRatio, 1.0, 1.0) +\n          uv.x * horizontal * aspectRatio +\n          uv.y * vertical;\n    r.mint = 0.0;\n    r.maxt = 1e20;\n    return r;\n}\n\n// -------------------------------------------------------------------------\n// Frame accumulator\n// -------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0) {\n        // reset the color on the first frame\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        vec2 uv = fragCoord/iResolution.xy;\n\n        // compute ray for pixel\n    \tRay r = computeCameraRay(uv);\n    \n    \t// compute pixel color\n    \tvec3 current = traceRay(r, uv);\n        \n        // read the previous value from the frame buffer\n        vec3 prev = texture(iChannel0, uv).xyz;\n        \n        // running average\n        vec3 new = (float(iFrame-1) * prev + current) / float(iFrame);\n\n        // output to buffer A\n        fragColor = vec4(new, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}