{"ver":"0.1","info":{"id":"3tVfWc","date":"1616063447","viewed":503,"name":"2D Shadows With Ray Casting","username":"LilBensson","description":"(Hold down left mouse button to move the light's position)\n\n2D shadows using a DDA algorithm inspired by the old Wolfenstein game. This was a successful prototype for a school project. It ended up being both fast and precise!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","raycasting","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define MAP_LEN 16\n\nint[MAP_LEN*MAP_LEN] map = int[](\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,1,\n    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,\n    1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,1,\n    1,1,0,0,1,0,0,0,0,0,0,1,0,0,0,1,\n    1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,\n    1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,\n    1,1,1,0,0,0,0,0,0,1,1,0,0,0,1,1,\n    1,1,1,1,0,0,0,0,0,1,0,0,0,0,1,1,\n    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,\n    1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n    1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1,\n    1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,\n    1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,\n    1,1,1,0,1,1,1,1,1,0,1,1,1,0,0,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n);\n\n// Get wall type (only 0 or 1 for now)\nint getMap(int x, int y)\n{\n    if(x < 0 || x >= MAP_LEN || y < 0 || y >= MAP_LEN)\n    {\n        return 1;\n    }\n        \n    int index = x + y * 16;\n    return map[index];\n}\n\n// From normalized uvs to \"world space\"\nvoid translateCoordsToWorld(inout vec2 coords)\n{\n    coords.y = 1.0 - coords.y;\n    coords.x -= 0.25;\n    coords.x *= iResolution.x / iResolution.y;\n    coords *= float(MAP_LEN);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UVs\n    vec2 uv = fragCoord/iResolution.xy;\n    translateCoordsToWorld(uv);\n    \n    // Light position\n    vec2 lightPos = vec2(8.5, 8.5);\n    vec3 mousePos = iMouse.xyz / vec3(iResolution.xy, 1.0);\n    \n    if(mousePos.x > 0.0 && mousePos.y > 0.0)\n    {\n        translateCoordsToWorld(mousePos.xy);\n        lightPos = mousePos.xy;\n    }\n    \n    vec2 rayDir = uv - lightPos;\n    float directionAngle = atan(rayDir.y, rayDir.x);\n    \n    float d = 100.0;\n    vec3 col = vec3(0.0f);\n    \n    if(getMap(int(uv.x), int(uv.y)) == 0)\n    {\n        // Vertical\n        if(rayDir.y != 0.0)\n        {\n            // Step lengths\n            float stepX = sign(rayDir.y) / tan(directionAngle);\n            float stepY = sign(rayDir.y);\n\n            // Initial intersection\n            vec2 p = vec2(0.0, round(lightPos.y + sign(rayDir.y) * 0.5));\n            p.x = lightPos.x + -(lightPos.y - p.y) / tan(directionAngle);\n\n            // March\n            for(int i = 0; i < 16; i++)\n            {\n                // Test the tiles sharing an edge\n                int testX = int(p.x);\n                int testY1 = int(p.y + 0.5);\n                int testY2 = int(p.y - 0.5);\n                if(map[testX + testY1 * 16] + map[testX + testY2 * 16] <= 0)\n                {\n                    p += vec2(stepX, stepY);\n                }\n                else\n                    break;\n            }\n\n            d = min(length(lightPos - p), d);\n        }\n\n        // Horizontal\n        if(rayDir.x != 0.0)\n        {\n            // Step lengths\n            float stepX = sign(rayDir.x);\n            float stepY = sign(rayDir.x) * tan(directionAngle);\n\n            // Initial intersection\n            vec2 p = vec2(round(lightPos.x + sign(rayDir.x) * 0.5), 0.0);\n            p.y = lightPos.y + (p.x - lightPos.x) * tan(directionAngle);\n\n            // March\n            for(int i = 0; i < 16; i++)\n            {\n                // Test the tiles sharing an edge\n                int testX1 = int(p.x + 0.5);\n                int testX2 = int(p.x - 0.5);\n                int testY = int(p.y);\n                if(map[testX1 + testY * 16] + map[testX2 + testY * 16] <= 0)\n                {\n                    p += vec2(stepX, stepY);\n                }\n                else\n                    break;\n            }\n\n            d = min(length(lightPos - p), d);\n        }\n        \n        float lightToUvLen = length(uv - lightPos);\n        \n        // Is the pixel in view of the light?\n        if(d >= lightToUvLen - EPSILON)\n            col = 1.0f - vec3(lightToUvLen / 16.0f);\n        else\n            col = vec3(0.0f);\n    }\n    else // Wall\n        col = vec3(1.0);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}