{"ver":"0.1","info":{"id":"ttcfDX","date":"1613572428","viewed":159,"name":"Лёха","username":"Interruptor","description":"Поздравляю с днём рождения!!! Ты мой самый лучший братик.\nКаринка пока очень шумная, в будущем обещаю это исправить\ninspired by \"Deciphering The Postcard Sized Raytracer\" written by Fabien Sanglard. (http://fabiensanglard.net/postcard_pathtracer/)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author:\n// Title:\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define HIT_NONE   0\n#define HIT_LETTER 1\n#define HIT_WALL   2\n#define HIT_BOX2   4\n#define HIT_BOX3   5\n#define HIT_SUN    3\n//#define IS_DEBUG    0\n\nstruct Hit\n{\n    vec3 point;\n    vec3 normal;\n    int type;\n};\n\nfloat random (float x) {\n   return fract(sin(x)*1e4);\n}\n\nfloat SphereSDF(vec3 position, float radius){ // distance to sphere\n    return length(position) - radius;\n}\n\n// Rectangle CSG equation. Returns minimum signed distance from \n// space carved by lowerLeft vertex and opposite rectangle\n// vertex upperRight.\nfloat BoxTest(vec3 position, vec3 lowerLeft, vec3 upperRight) {\n  lowerLeft = position - lowerLeft;\n  upperRight = upperRight - position;\n  return -min(\n    min(\n    \tmin(lowerLeft.x, upperRight.x), \n    \tmin(lowerLeft.y, upperRight.y)\n    ), \n    min(lowerLeft.z, upperRight.z));\n}\n\nfloat roomDist(vec3 position){\n    return min(// min(A,B) = Union with Constructive solid geometry\n               \t   //-min carves an empty space\n                -min(// Lower room\n                     BoxTest(position, vec3(-30., -.5, -30.), vec3(30., 18., 30.)),\n                     // Upper room\n                     BoxTest(position, vec3(-25., 17., -25.), vec3(25, 20., 25.))\n                ),\n                BoxTest( // Ceiling \"planks\" spaced 8 units apart.\n                  vec3(mod(abs(position.x), 8.),\n                      position.y,\n                      position.z),\n                  vec3(1.5, 18.5, -25),\n                  vec3(6.5, 20, 25)\n                ));\n}\n\nfloat SceneSDF(vec3 position, out int hitType){\n    float rad = 0.94;\n    float distance = 1e9;\n    vec3 f = position; // Flattened position (z=0)\n    \n    f.z = 0.;\n    int offset = 5;\n    int letters[15*4] = int[60](\n      // (x0, y0), (x1, y1)\n      // Л (without curve)\n      55, 83, 57, 95,\n      63, 79, 63, 95,\n      57, 95, 62, 95,\n      // Ё\n      69, 79, 74, 79,\n      68, 79, 68, 95,\n      69, 95, 74, 95,\n      // X\n      78, 79, 86, 95,\n      78, 95, 86, 79,\n      // A\n      90, 79, 94, 95,\n      94, 95, 98, 79,\n      92, 86, 96, 86,\n      // R (without curve)\n      69, 87, 74, 87,\n      69, 98, 69, 98,\n      0 , 8, 3, 8,\n      73, 98, 73, 98\n    );\n//\n    for (int i = 0; i < 59; i += 4) {\n        vec3 begin = vec3(letters[i] - 79, letters[i + 1] - 79, 0.) * .5;\n        vec3 e = vec3(letters[i + 2] - 79, letters[i + 3] - 79, 0.) * .5 - begin;\n        vec3 o = f - (begin + e * min(-min(dot((begin + f * -1.), e) / dot(e, e), 0.), 1.));\n        distance = min(distance, dot(o, o)); // compare squared distance.\n    }\n    distance = sqrt(distance); // Get real distance, not square distance.\n//\n    // Two curves (for P and R in PixaR) with hard-coded locations.\n    vec3 curves[] = vec3[](vec3(-14., 5., 0.), vec3(11., 6., 0.));\n    for (int i = 1; --i >= 0; ) {\n        vec3 o = f - curves[i];\n        distance = min(distance,\n                       o.x > -0.6 ? abs(sqrt(dot(o, o)) - 2.)\n                               : (o.y += o.y < -2.5 ? 2.960 : 5.5, sqrt(dot(o, o)))\n                   );\n    }\n    \n    distance = pow(pow(distance, 8.) + pow(position.z, 8.), .125) - .5;\n    hitType = HIT_LETTER;\n\n    \n    float room = roomDist(position);\n  \tif (room < distance) distance = room, hitType = HIT_WALL;\n    \n    float sun = 19.9 - position.y ; // Everything above 19.9 is light source.\n  \tif (sun < distance)\n        distance = sun, hitType = HIT_SUN;\n    \n    return distance;//BoxTest(hitPoint, vec3(.0), vec3(2.,2,2.));\n}\n\nvec3 GetNormal(vec3 point)\n{\n    vec2 e = vec2(0.0, 0.01);\n    int plug;\n    return normalize(SceneSDF(point, plug) - vec3(\n        SceneSDF(point - e.yxx, plug),\n        SceneSDF(point - e.xyx, plug),\n        SceneSDF(point - e.xxy, plug)\n    ));\n}\n\nint RayMarching(vec3 origin, vec3 direction, out Hit result){\n  \tfloat d = 0.0; // distance from closest object in world.\n    //vec3 resultColor = vec3(.0);\n    float totalDistance = 1.0;\n    const float MAX_DISTANCE = 81.0;\n    const float MIN_DISTANCE = 0.1;\n    const int MAX_STEPS = 64;\n\n  \t// Signed distance marching\n  \tfor (int noHitCount = 0; noHitCount < MAX_STEPS; ++noHitCount){\n        vec3 rayHitPoint = origin + direction * totalDistance;\n        d = SceneSDF(rayHitPoint, result.type);\n        if (d < MIN_DISTANCE){\n            result.point = rayHitPoint;\n            result.normal = GetNormal(rayHitPoint);\n            \n            return result.type;\n        }\n        totalDistance += d;\n        if (totalDistance > MAX_DISTANCE) break;\n    }\n    \n    return result.type = HIT_NONE;\n}\n\nvec3 Trace(vec3 origin, vec3 direction, float samplesCount) {\n    vec3 color, attenuation = vec3(1.);\n    vec3 lightDirection = normalize(vec3(.6, .6, 1.)); // Directional light\n\tHit result = Hit(vec3(0.0), vec3(0.0), 0);\n\n    for (int bounceCount = 3; bounceCount > 0; bounceCount--) {\n        int hitType = RayMarching(origin, direction, result);\n        if (hitType == HIT_NONE) break; // No hit. This is over, return color.\n        if (hitType == HIT_LETTER) { // Specular bounce on a letter. No color acc.\n        \tdirection = direction + result.normal * (dot(result.normal, direction) * -2.);\n        \torigin = result.point + direction * 0.1;\n        \tattenuation = attenuation * 0.2; // Attenuation via distance traveled.\n        }\n        if (hitType == HIT_WALL) { // Wall hit uses color yellow?\n        \tfloat incidence = dot(result.normal, lightDirection);\n        \tfloat p = 6.283185 * random(result.point.y+samplesCount);\n        \tfloat c = random(result.point.x+samplesCount);\n        \tfloat s = sqrt(1. - c);\n        \tfloat g = result.normal.z < 0. ? -1. : 1.;\n        \tfloat u = -1. / (g + result.normal.z);\n        \tfloat v = result.normal.x * result.normal.y * u;\n        \tdirection = vec3(v,\n                        \t g + result.normal.y * result.normal.y * u,\n                        \t -result.normal.y) * (cos(p) * s)\n                    \t+\n                    \tvec3(1. + g * result.normal.x * result.normal.x * u,\n                        \t g * v,\n                        \t -g * result.normal.x) * (sin(p) * s) + result.normal * sqrt(c);\n        \torigin = result.point + direction * .1;\n        \tattenuation = attenuation * 0.2;\n        \tif (incidence > 0. &&\n            \tRayMarching(result.point + result.normal * .1,\n                        \tlightDirection,\n                        \tresult) == HIT_SUN)\n          \tcolor = color + attenuation * vec3(500, 400, 100) * incidence;\n        }\n        if (hitType == HIT_SUN) { //\n        \tcolor = color + attenuation * vec3(50, 80, 100); break; // Sun Color\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    //st.x *= u_resolution.x/u_resolution.y;\n    const float samplesCount = 6.;\n    vec3 cameraPos = vec3(-22.0, 5.0, 25.);\n    \n    vec3 goal = normalize(vec3(-3., 4., 0.) - cameraPos);\n\tvec3 left = normalize(vec3(goal.z, .0, -goal.x)) * 1. / iResolution.x;\n    vec3 up = cross(goal, left);\n    vec3 color;\n    for (float p = samplesCount; p > 0.; --p){\n        vec3 rayDirection = normalize(goal - left * (gl_FragCoord.x - iResolution.x / 2. + random(st.x+p))\n                                             + up * (gl_FragCoord.y - iResolution.y / 2. + random(st.y+p)));\n        color = color + Trace(cameraPos, rayDirection, p);\n    }\n    // Reinhard tone mapping\n    color = color * (1. / samplesCount) + 14. / 241.;\n    vec3 o = color + 1.;\n    color = vec3(color.x / o.x, color.y / o.y, color.z / o.z);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}