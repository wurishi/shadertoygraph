{"ver":"0.1","info":{"id":"Wtd3WB","date":"1577454800","viewed":425,"name":"Surgeryhead - 3D","username":"Tara","description":"The sound-based animation needs some work.\nThe soundcloud music doesn't work correctly on Firefox. Pause and then unpause the shader to fix it.\n\nInspired by:\nhttps://www.youtube.com/watch?v=t4TKn-R-We0\nhttps://www.youtube.com/watch?v=KyahNt7MKLI","likes":12,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","music","animated","psychedelic","visualizer","soundcloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adds bloom and/or motion blur and renders the image to the screen.    \n\n// TODO: Do a bilateral blur for the bloom!\n// TODO: PERFORMANCE: The post effects slow things down quite a bit.\n// TODO: Post on surgeryhead video.\n\nvec3 calculate_radial_blur(vec2 uv)\n{\n    vec3 sample_sum = vec3(0.0);\n\tfloat weight_sum = 0.0;\n    \n    const vec2 screen_center = vec2(0.5);\n    vec2 blur_vector = screen_center - uv;\n    \n    //const float step_size = blur_max_distance / float(blur_sample_count);\t// TODO: Importance sampling?\n    \n    const float step_size = blur_max_distance / float(blur_sample_count);\t// TODO: Importance sampling?\n    //step_size *= length(blur_vector);\n\n    for(int i=0; i<blur_sample_count; ++i)\n    {\n        float sample_weight = 1.0 / (10.0 + float(i) * 10.0);\n        //float sample_weight = 1.0 - 1.0 / float(blur_sample_count) * float(i);\n        //sample_weight = 1.0;\n        //sample_weight *= sample_weight;\t// Square the weight.\n        sample_weight = pow(sample_weight, 1.5);\n        \n        //sample_weight = 0.005;\n        //sample_weight = pow(length(blur_vector), 2.0);\n        \n        sample_weight = 1.0;\n        //sample_weight = pow(length(blur_vector), 2.0);\n\n        sample_weight = pow(1.0 - float(i) / float(blur_sample_count), 1.0);\n        \n        float offset_scale = abs(uv.x - 0.5) * 2.0;\t// TODO: Is this fine? Or should it be radial?       \n\n        vec2 sample_offset = blur_vector * step_size * float(i) * offset_scale;\n        \n        vec3 s = texture(iChannel0, uv + sample_offset).rgb;\n        //sample_weight = max(length(s) - 0.1, 0.0);\n            \n        sample_sum += s * sample_weight;\n        weight_sum += sample_weight;\n    }\n    \n    //bloom /= float((2 * radius + 1) * (2 * radius + 1));\n    sample_sum /= weight_sum;\n    \n    sample_sum += texture(iChannel1, uv).rgb * 0.5;\n    \n    return(sample_sum);\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Modified version of the above, that produces less harsh tone mapping.\nvec3 ACESFilmModified(vec3 x)\n{\n    float a = 1.5;\n    float b = 0.03;\n    float c = 0.45;\n    float d = 1.0;\n    float e = 0.1;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Mirror the left side of the screen to the right side:\n    uv.x = 0.5 - abs(uv.x - 0.5);\n    \n    vec3 scene_color = texture(iChannel0, uv).rgb;\n    \n    //fragColor.rgb = texture(iChannel1, uv).rgb;\n    //fragColor.rgb = calculate_bloom(uv);\t// TODO: Blur the bloom too? Or calculate the bloom of the blurred image?\n    //fragColor.rgb = scene_color;\n    //return;\n    \n    fragColor.rgb = scene_color;\n    \n#if defined(ENABLE_BLOOM) || defined(ENABLE_BLUR)\n    //fragColor.rgb *= 0.5;\n#endif\n        \n#ifdef ENABLE_BLUR\n    fragColor.rgb = calculate_radial_blur(uv);\n   // fragColor.rgb *= 0.75;\n#endif\n\n    const vec3 fog_color = vec3(180, 100, 200) / 255.0 * 1.2;\t// \"* 0.85\" is an adjustment factor for the bloom.\t// Tweaked fog.\n    //fragColor.rgb += fog_color * 0.1;\n    fragColor.rgb += fog_color * pow(uv.x * 2.0, 2.0) * 0.4;\n    \n    vec3 color_crushed = fragColor.rgb / (1.0 + fragColor.rgb);\n    //fragColor.rgb = mix(fragColor.rgb, color_crushed, 0.75);\n    fragColor.rgb = ACESFilmModified(fragColor.rgb * 0.85);\n    \n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xl23zz","filepath":"https://soundcloud.com/surgeryhead/threedee","previewfilepath":"https://soundcloud.com/surgeryhead/threedee","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// User settings: ////////////////////////////////\n//#define RENDER_DEPTH\n#define ENABLE_FOG\n#define CUBE_ANIMATION MUSIC_ANIMATION\n\n\n//////////////////////////////////////////////////\n#define NO_ANIMATION 0\n#define MUSIC_ANIMATION 1\n#define RANDOM_ANIMATION 2\n\n// Song: https://soundcloud.com/surgeryhead/threedee\n\nconst int max_ray_samples = 128;\nconst int max_ray_backwards_samples = 32;\nconst float max_view_distance = 15.0;\t// TODO: Adjust!\nconst float wall_distance = 0.12;\n\n//const vec3 fog_color = vec3(0.85, 0.3, 0.55);\n\n// Values taken from the video:\n//const vec3 fog_color = vec3(173, 75, 117) / 255.0 * 0.9;\t// \"* 0.85\" is an adjustment factor for the bloom.\t// Original fog based on video.\n//const vec3 fog_color = vec3(200, 100, 200) / 255.0 * 1.2;\t// \"* 0.85\" is an adjustment factor for the bloom.\t// Tweaked fog.\nconst vec3 fog_color = vec3(200, 60, 100) / 255.0;\t// \"* 0.85\" is an adjustment factor for the bloom.\t// Tweaked fog.\nconst vec3 wall_line_color_inside = vec3(80, 80, 194) / 255.0 * vec3(0.85, 0.85, 1.5) * 1.35 * 1.5;\n//const vec3 wall_line_color_outside = vec3(156, 71, 124) / 255.0 * 1.35;\nconst vec3 wall_line_color_outside = vec3(156, 50, 80) / 255.0 * 1.5 * 1.5;\n\n\n// Perlin noise:\nfloat mod289(float x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 mod289(vec4 x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 perm(vec4 x)\n{\n\treturn(mod289(((x * 34.0) + 1.0) * x));\n}\n\nfloat perlin_2d(vec2 p)\n{\n    vec2 a = floor(p);\n    vec2 d = p - a.xy;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = vec4(a.x, a.x + 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.yyyy;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.y + o1 * (1.0 - d.y);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return(o4.y * 0.0 + o4.x * 1.0);\n}\n\nfloat calculate_height(vec3 position)\n{\n    // TODO: Replicate the pattern from the video. It seems to align the blocks in \"stripes\".\n    \n    //position.y *= 10.0;\n    vec2 p = round(position.yz * 3.0) / 3.0;\t// Round the coordinates so we get a blocky heightmap.\n    //p.y *= 0.5;\n    //p.x *= 1000.0;\n    //p.x += p.y * 5.0;\n    \n\tfloat n = //perlin_2d(p) +\n              //0.5 * perlin_2d(p * 2.0) +\n                0.25 * perlin_2d(p * 4.0) +\n                0.125 * perlin_2d(p * 8.0) +\n                0.0625 * perlin_2d(p * 16.0);\t// TODO: PERFORMANCE: How detailed does the noise function need to be?\n                //0.03125 * perlin_2d(p * 32.0);\n              //+ 0.015625 * perlin_2d(p * 64.0);\n    \n \t/*\n\tn = perlin_2d(p * 8.0) * 0.5 +\n        perlin_2d(p * 4.0) * 0.25 +\n        perlin_2d(p * 2.0) * 0.125;\n   \t//return(n);\n    */\n    \n    // TODO: Instead of calculating an offset for the noise every frame,\n    //       how about simply transforming the ray instead?\n    \n#if CUBE_ANIMATION == NO_ANIMATION\n    float noise_value = wall_distance + n * 0.3;\n#endif\n    \n#if CUBE_ANIMATION == RANDOM_ANIMATION\n    float noise_value = wall_distance + max(n * sin(n * 31.42 + iTime * 2.0) * 0.5, 0.0);\n    \n    /*\n    float sound = textureLod(iChannel0, vec2(0.25, 0.0), 0.0).x;\n    //noise_value = sound;\n        \n    float average = 0.0;\n    for(int i=0; i<20; ++i)\n    {\n        average += textureLod(iChannel0, vec2(position.z + float(i) / 100.0, 0.0), 0.0).x;\n    }\n    average /= 20.0;\n    noise_value = average;\n    */\n#endif\n    \n#if CUBE_ANIMATION == MUSIC_ANIMATION\n    //noise_value = 0.3 + textureLod(iChannel0, vec2(mod(p.x, 1.0) * 1.0, 0.0), 0.0).x;\n    float noise_value = 2.0 * n * pow(textureLod(iChannel0, vec2((p.x * 0.1 + 0.35) * 1.0, 0.2), 0.0).x, 4.0);\n    //noise_value = 0.3;\n    noise_value *= 1.0 * pow(textureLod(iChannel0, vec2(mod(p.y * 0.1, 1.0) * 0.1, 0.0), 0.0).x, 2.0);\n    noise_value *= 0.5 + pow(textureLod(iChannel0, vec2(0.9, 0.0), 0.0).x, 2.0) * 1.0; // Bass\n    noise_value += pow(textureLod(iChannel0, vec2(0.9, 0.0), 0.0).x, 8.0) * 2.0; // Bass\n    //noise_value *= 1.0 + pow(textureLod(iChannel0, vec2(0.1, 0.5), 0.0).x, 1.0) * 2.0; // High pitched sounds\n    //noise_value = 1.0 * pow(textureLod(iChannel0, vec2(mod(p.y * 0.1, 1.0) * 0.1, 0.0), 0.0).x, 2.0);\n    noise_value += wall_distance;\n    \n    \n    float sound_value = textureLod(iChannel0, vec2(n*0.5, 0.0), 0.0).x;\n    //noise_value = sound_value;\n    noise_value = sound_value * 2.0 - 1.0;\n    //noise_value = 1.0 - sound_value;\n    noise_value = sound_value;\n    \n    //noise_value *= mix(500.0, 0.01, pow(n, 5.0));\t// Make higher tones stronger.\n    noise_value *= pow(1.0 - n, 2.0) * 10.0;\t// Make lower tones go inside.\n    //noise_value = pow(noise_value, 4.0);\n    //noise_value /= 10.0;\n    \n    if(n < 0.25)\t// High tones:\n    {\n        noise_value = sound_value * -2.0;\n    \tnoise_value = min(noise_value + 1.75, 0.0) * 6.0;\n    \t//noise_value = 0.0;\n    }\n    else\t// Low tones:\n    {\n        //noise_value = sound_value * 4.0;\n        noise_value = max(sound_value - 0.1, 0.0) * 4.0;\n    \t//noise_value = noise_value * 10.0;\n    \t//noise_value = 4.0;\n        //noise_value = 0.0;\n    }\n    \n    \n    noise_value = 1.0 - pow(1.0 - noise_value, 2.0) * 0.25;\t// Make lower tones go inside.\n    \n    noise_value += 2.0;\n    noise_value *= 0.1;\n    \n    //noise_value *= n * sound_value;\n    noise_value *= (1.0 - n * sound_value) * 10.0;\t// low tones on low-tone-boxes = 0.0. High tones on high tone boxes = 10.0\n    \n    noise_value *= 0.25;\n    /*\n    noise_value = 0.5 + -pow(max(sound_value - 0.25, 0.0), 8.0) * 50.0;\n    \n    // TODO: Make the high tones go out and the lower ones in?\n    // TODO: Make the high tones go out a lot?\n    \n    float strength = mix(10.0, -10.0, n);\n    \n    float shift = max(textureLod(iChannel0, vec2(n, 0.0), 0.0).x - 0.25, 0.1) * strength;\n    noise_value = 0.5 + shift * 0.1;\n    //noise_value = pow(clamp(shift, -0.5, 0.5), 2.0) * 0.2 * -mix(-1.0, 1.0, n);\n    //noise_value *= pow(max(textureLod(iChannel0, vec2(0.9, 0.0), 0.0).x , 0.0), 4.0) * 50.0;\n    */\n    noise_value += wall_distance;\n    noise_value -= 0.4;\n\n    \n    // Source: https://www.shadertoy.com/view/MsdGzn\n    if(true)\n    {\n        // create pixel coordinates\n        //vec2 uv = fragCoord.xy / iResolution.xy;\n        \n    \tvec3 p = round(position * 3.0) / 3.0;\t// Round the coordinates so we get a blocky heightmap.\n        \n        vec2 uv = p.yy + 3.0;\n        \n        uv /= 14.0;     \n        \n        \n        uv.x = sin(p.z * 10.0);\n        \n        //uv.x = n * 0.04;\n        uv.x = n;\n\n        // first texture row is frequency data\n        float fft  = texture( iChannel0, vec2(uv.x,0.25) ).x; \n\n        // second texture row is the sound wave\n        float wave = texture( iChannel0, vec2(uv.x,0.75) ).x;\n\n        // convert frequency to colors\n        vec3 col = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n        // add wave form on top\t\n        col += 1.0 -  smoothstep( 0.0, 0.15, abs(wave - uv.y) );\n        \n        //noise_value = 0.5 + 0.1 * (fft * 2.0 - 1.5);\n        //noise_value = fft * 2.0 - 1.5;\n        \n        /*\n        if(n > 0.1)\n        {\n            noise_value = 0.5;\n        }\n        */\n        \n        //noise_value = fft * 1.0 + 1.5;\n        \n        float block_frequency = n;\n        float frequency_strength = texture(iChannel0, vec2(block_frequency, 0.25)).x; \n        \n        const float leeway = 0.4;\n        //if(block_frequency < 0.35)\n        \n        //noise_value = leeway + wall_distance;\n        \n        noise_value = mix(noise_value, wall_distance + 0.1, 0.8);\n        //noise_value = wall_distance + 0.1;\n      \n        // Filter out low frequencies:\n        block_frequency = n * 0.1;\n        frequency_strength = texture(iChannel0, vec2(block_frequency, 0.25)).x; \n        \n        if((block_frequency > 0.0)&&(block_frequency < 0.025))\n        {\n        \t//noise_value += leeway + wall_distance - pow(frequency_strength, 8.0) * 4.0 * leeway;\n        \t//noise_value -= pow(frequency_strength, 8.0) * 0.5;\n            \n            // Reduce the influence of other frequencies on this block:\n            noise_value = mix(noise_value, wall_distance + 0.1, smoothstep(0.025, -0.05, block_frequency));\n            \n            // Add the desired frequency:\n        \tnoise_value -= smoothstep(0.025, 0.0, block_frequency) * pow(frequency_strength, 18.0) * 0.15;\n        }\n        \n        //noise_value = wall_distance + 0.1;\n\n        // Filter out high notes:\n        block_frequency = n * 0.8;\n        frequency_strength = texture(iChannel0, vec2(block_frequency, 0.25)).x; \n        \n        if((block_frequency > 0.05)&&(block_frequency < 0.15))\n        {\n        \t//noise_value = leeway + wall_distance - pow(frequency_strength, 8.0) * leeway*10.0;\n        \t//noise_value -= pow(frequency_strength, 8.0) * leeway*100.0;\n            \n            // Reduce the influence of other frequencies on this block:\n            noise_value = mix(noise_value, wall_distance + 0.1, smoothstep(0.015, 0.00, block_frequency));\n            \n        \tnoise_value -= smoothstep(0.015, 0.05, block_frequency) * pow(frequency_strength, 8.0) * 0.15;\n        }\n       \n        noise_value = max(noise_value, wall_distance);\n      \n        //float fft_high  = texture( iChannel0, vec2(n,0.25) ).x; \n        \n    \t//return(0.5 + fft);\n    \t//return(0.5 + abs(fft * fft * fft));\n    }    \n    \n    // TODO: PERFORMANCE: Ideally precalculate this in a buffer.   \n    // Make the (more or less) whole wall shake:\n    {\n        float average = 0.0;\n        const int samples = 20;\n        for(int i=0; i<samples; ++i)\n        {\n            float frequency = float(i) / float(samples)*0.25;\n          //  frequency += 1.0;\n            frequency += (abs(p.x*p.x * 0.1) - 0.1) * 0.25;\n            frequency += (n - 0.5) * 0.2;\t// Add a little variation per block, so they don't all move in sync.\n            //frequency *= frequency;\n            vec2 uv = vec2(frequency, 0.25);\n        \tfloat frequency_strength = texture(iChannel0, uv).x;\n            average += frequency_strength;\n        }\n        average /= float(samples);\n        average = clamp(pow(average, 0.5) * 0.5 - 0.2, 0.0, 0.3);\n        \n        float val = -min(0.5 - average * average * 15.0, 0.0);\n        val = val * val * 2.0;\n        \n        //noise_value = max(noise_value, 0.0);\n        noise_value += val * 0.2;\n        //return(wall_distance + val);\n    }\n    \n    noise_value = mix(noise_value, wall_distance, 0.25);\n    \n#endif\n    \n    return(noise_value);\n    \n    /*\n    float offset_y = step(mod(uv.y * 4.0, 7.0), 1.0);\n    offset_y += step(mod(uv.x * 40.0, 3.0), 1.0);\n    offset_y *= step(mod(uv.x * 40.0, 3.0), 1.0);\n\n\treturn(offset_y); \n\t*/\n}    \n\n/*\nvec3 calculate_texture(vec2 uv)\n{\n    //vec2 uv_tiled = mod(uv * 100.0, vec2(1.0));\n    vec2 uv_tiled = mod(uv * vec2(40.0, 4.0), vec2(1.0));\n    \n     //uv_tiled.y += abs(block_offset.x) * 0.1;\n    \n    vec3 texture_color;\n    texture_color.x = 0.5 + 0.5 * sin(uv_tiled.x * 10.0);\n    texture_color.y = 0.5 + 0.5 * sin(uv_tiled.y * 10.0 + cos(uv_tiled.x * 10.0));\n    texture_color.z = 0.5;\n    \n    texture_color = vec3(0.0);\n    \n    vec2 block_offset = vec2(sin(uv.x * 10.0 + cos(uv.y * 10.0) * 5.0));\n    \n    float offset = step(mod(uv.x * 40.0, 7.0), 1.0);\n    offset += step(mod(uv.x * 40.0, 3.0), 1.0);\n    offset += step(mod(uv.x * 40.0, 13.0), 1.0);\n    \n    float offset_y = step(mod(uv.y * 4.0, 7.0), 1.0);\n    offset_y += step(mod(uv.x * 40.0, 3.0), 1.0);\n    offset_y *= step(mod(uv.x * 40.0, 3.0), 1.0);\n    \n    float step_x = step(uv_tiled.x, 0.1 + 0.1 * offset); \t//\n    float step_y = step(uv_tiled.y, 0.1 + 0.1 * offset_y);\n    \n    texture_color *= 0.2;\n    \n    texture_color = mix(texture_color, vec3(0.8, 0.7, 1.0), step_x);\n    texture_color = mix(texture_color, vec3(0.8, 0.7, 1.0), step_y);\n    \n    \n    \n    float cube_corner_step_x = step(uv_tiled.x, 0.1);\n    float cube_corner_step_y = step(uv_tiled.y, 0.1);\n    \n    vec3 cube_corner_glow = vec3(0.0);\n    cube_corner_glow = mix(cube_corner_glow, vec3(0.5, 0.2, 0.2), cube_corner_step_x);\n    cube_corner_glow = mix(cube_corner_glow, vec3(0.5, 0.2, 0.2), cube_corner_step_y);\n    \n    // TODO: Trace a height field each!\n    texture_color = mix(cube_corner_glow, texture_color, 0.5);\n    \n    return(texture_color);\n}\n*/\n\n// Implemented according to \"http://geomalgorithms.com/a06-_intersect-2.html\".\nbool intersect_plane_with_ray(vec3 ray_origin, vec3 ray_direction,\n                             vec3 plane_normal, float plane_distance,\n                             inout float intersection_distance, float epsilon)\n{\n    vec3 plane_origin = plane_normal * plane_distance;\n\n    float plane_dot_ray_origin = dot(plane_normal, plane_origin - ray_origin);\n    float plane_dot_ray_direction = dot(plane_normal, ray_direction);\n\n    if((plane_dot_ray_direction > -epsilon)&&(plane_dot_ray_direction < epsilon))\t// The ray is (almost) parallel to the plane. No intersection is possible:\n    {\n        return(false);\n    }\n\n    /*\n    When the denominator n_dot_(P1-P0)=0, the line L is parallel to the plane P,\n    and thus either does not intersect it or else lies completely in the plane\n    (whenever either P0 or P1 is in P ).\n    Otherwise, when the denominator is nonzero and rI is a real number,\n    then the ray R intersects the plane P only when rI.ge.0.\n    A segment S intersects P only if rI.ge-0.le-1.\n    In all algorithms, the additional test rI.le.1 is the only difference for a segment instead of a ray.\n    */\n\n    float temp_distance = plane_dot_ray_origin / plane_dot_ray_direction;\n\n    if(temp_distance >= 0.0)\t// TODO: Remove?\n    {\n        intersection_distance = temp_distance;\t// Only change the value of \"distance\" if an intersection occured.\n        return(true);\n    }\n\n    return(false);\n}\n\nvec3 get_surface_color(vec3 point_of_intersection, float surface_height)\n{\n    \n    if(abs(point_of_intersection.x) - surface_height > 0.01)\n    {\n        return(wall_line_color_inside);\n    }\n    /*\n    else if(abs(point_of_intersection.x) - surface_height > 0.01)\n    {\n        return(wall_line_color_outside);\n    }\n    */\n\n    // TODO: Fix the coordinate offset!\n    float cube_corner_step_z = step(mod(point_of_intersection.z - 0.48, 1.0 / 3.0), 0.025);\n    float cube_corner_step_y = step(mod(point_of_intersection.y - 0.48, 1.0 / 3.0), 0.025);\n\n    vec3 cube_corner_glow = vec3(0.0);\n    cube_corner_glow = mix(cube_corner_glow, wall_line_color_outside, cube_corner_step_z);\n    cube_corner_glow = mix(cube_corner_glow, wall_line_color_outside, cube_corner_step_y);\n\n    return(cube_corner_glow);\n\n    return(vec3(0.0));\n    return(vec3(surface_height));\n}\n\nvec3 intersect_wall_bounding_plane(vec3 ray_origin, vec3 n_ray_direction, inout float intersection_distance)\n{\n    const float plane_distance = wall_distance;\n    vec3 plane_normal = vec3(-1.0, 0.0, 0.0);\t// TODO: Adjust sign based on ray x component.\n    //plane_normal.x = sign(n_ray_direction.x);\n    \n    // Set the plane normal depending on the sign of n_ray_direction.x.\n   \t//plane_normal.x = step(0.0, n_ray_direction.x) * 2.0 - 1.0;\t// Source: https://rauwendaal.net/2012/06/15/glsl-sign-function/\n    \n    intersection_distance = max_view_distance;\n    \n    bool intersects = intersect_plane_with_ray(ray_origin, n_ray_direction,\n                                               plane_normal, plane_distance,\n                                               intersection_distance, 0.001);\n    if(!intersects)\t// TODO: This must never happen!\n    {\n        return(vec3(1.0, 0.0, 0.0));\n    }\n    \n    //intersection_distance = abs(intersection_distance);\n    \n    return(ray_origin + n_ray_direction * intersection_distance);\n    \n    return(vec3(intersection_distance) * 0.25);\n    \n    /*\n    // TODO: Add this early exit:\n    if(intersection_distance >= max_view_distance)\n    {\n        return(0.0);\n    }\n    */\n        \n    return(vec3(0.0));\n}    \n\n// Parallax mapping basically:\nvec3 trace_ray(vec3 ray_origin, vec3 n_ray_direction, inout float depth)\n{\n    vec3 original_ray_origin = ray_origin;\n    \n    /*\n    // TODO: Use dot product between Z and X axis only!\n    //float dot_product = max(dot(n_ray_direction, vec3(0.0, 0.0, -1.0)), 0.0);\n    float dot_product = max(dot(normalize(n_ray_direction.xz), vec2(0.0, -1.0)), 0.0);\n    \n    \n    //dot_product = 1.0 - pow(1.0 - dot_product, 2.0);\t// Make the value go bigger towards the center of the screen.\n    dot_product = pow(dot_product, 10.0);\t// Make the value go bigger towards the center of the screen.\n    //return vec3(dot_product);\n    \n    dot_product *= 0.1;\n  \n    \n    // TODO: Do a binary search?\n    \n    float step_size = max(dot_product, 0.01);\n    */\n    \n    \n    float intersection_distance = max_view_distance;\n    vec3 bounding_plane_point_of_intersection = intersect_wall_bounding_plane(ray_origin, n_ray_direction, intersection_distance);\n    \n    if(intersection_distance >= max_view_distance)\n    {\n    \treturn(fog_color);\n    }\n            \n    \n    // Offset the ray to the intersection of the bounding plane to speed up the parallax mapping.\n    ray_origin = bounding_plane_point_of_intersection;\n    \n    \n    //float step_size = 0.001;\t// TODO: Base step size on something proper.\n    float step_size = 0.005;\t// TODO: Base step size on something proper.\n        \n    for(int i=0; i<max_ray_samples; ++i)\n    {\n        step_size = 0.01 + 0.01 * (original_ray_origin.z - ray_origin.z);\n              \n        // For sample count independent step size:\n        step_size = step_size / float(max_ray_samples) * 64.0;\n        step_size *= (original_ray_origin.z - ray_origin.z);\n        \n        //ray_origin += n_ray_direction * 0.01;\n        ray_origin += n_ray_direction * step_size;\n        \n        float surface_height = calculate_height(ray_origin);\n        //surface_height = 0.1;\n        if(abs(ray_origin.x) > surface_height)\t// TODO: Do the ABS before entering this loop!\n        {\n            // March backwards:\n            step_size /= float(max_ray_backwards_samples);\n            for(int i=0; i<max_ray_backwards_samples; ++i)\n            {                \n                ray_origin -= n_ray_direction * step_size;\n                if(abs(ray_origin.x) <= calculate_height(ray_origin))\t// TODO: Do the ABS before entering this loop!\n                {\n                    break;\n                }\n            }\n\n            //depth = distance(ray_origin, original_ray_origin);\t// TODO: Calculate this differently?\n            depth = original_ray_origin.z - ray_origin.z;\t// TODO: Calculate this differently?\n\t\t\t\n            if(depth >= max_view_distance)\n            {\n                depth = max_view_distance;\n                return(fog_color);\n            }\n            \n            return(get_surface_color(ray_origin, surface_height));\n\n            // Fade out the lines to fight the flickering:\n    \t\tfloat normalized_depth = 1.0 - depth / max_view_distance;\n            return(get_surface_color(ray_origin, surface_height) * pow(normalized_depth, 2.0));\n        }\n        \n        // TODO: Increase step size for faraway pixels!\n        //step_size += 0.005;\n    }\n    \n    return(fog_color);\n    return(vec3(0.0, 1.0, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 clean_uv = fragCoord / iResolution.xy;\n    \n    // Only render the left side of the screen,\n    // because we will mirror it later, to save performance..\n    if(clean_uv.x > 0.5)\n    {\n        fragColor = vec4(fog_color, 1.0);\n        return;\n    }\n    \n    //vec2 half_resolution = vec2(iResolution.x * 0.5, iResolution.y);\n    //vec2 half_resolution = iResolution.xy * 0.5;\n    //vec2 distance_to_screen_center = abs(fragCoord.xy - half_resolution);\n    \n    //float dist = 0.075 + 0.9 * (distance_to_screen_center.x / half_resolution.x);\n    /*\n\tvec2 uv;\n    uv.x = (distance_to_screen_center.x / dist) / iResolution.x;\n    uv.y = ((fragCoord.y - half_resolution.y) / dist) / iResolution.x;\n    \n    uv.x -= iTime * 0.1;\n    */\n    // TODO: Reset camera position so it loops (because we are getting precsion issues!).\n    \n    vec3 ray_origin = vec3(0.0, -1.0, 0.0);\n    ray_origin.z -= iTime * 4.0;\n    //vec3 n_ray_direction = normalize(vec3(clean_uv * 2.0 - vec2(1.0), -1.0));\t// OpenGL coordinate system. Z pointing outside the screen.\n    vec3 n_ray_direction = vec3(clean_uv * 0.8 - vec2(0.4), -1.0);\t// OpenGL coordinate system. Z pointing outside the screen.\n    // TODO: Don't use a spherical ray! Use one that is oriented with the near plane so we get less of those spherical artifacts on the lines!\n    \n    \n    // TODO: Use view plane depth or actual distance?\n    float depth = max_view_distance;\n    vec3 trace_result = trace_ray(ray_origin, n_ray_direction, depth);\n    \n    float normalized_depth = depth / max_view_distance;\n    \n    \n#ifdef RENDER_DEPTH\n    fragColor = 0.5 * vec4(normalized_depth, normalized_depth, normalized_depth, 1.0);\n    return;\n#endif\n    \n    \n\t///fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t//fragColor = vec4(uv.xy, 0.5, 1.0);\n    \n    \n    //fragColor.rgb = calculate_texture(uv);\n    \n    //fragColor.rgb =  trace_result * n_ray_direction;\n    fragColor = vec4(trace_result, 1.0);\n    \n    //fragColor = vec4(normalized_depth, normalized_depth, normalized_depth, 1.0);\n    //return;\n    \n\t//fragColor.rgb = mix(vec3(0.0), fog_color, clamp((1.0 - pow(1.0 - normalized_depth, 2.0)) * 1.0, 0.0, 1.0));\n    //return;\n    \n#ifdef ENABLE_FOG\n    //float inverse_depth = 1.0 - dist;\n    //inverse_depth = 1.0 - normalized_depth;\n\n    //fragColor.rgb = mix(fragColor.rgb, fog_color, clamp(pow(inverse_depth, 1.8) * 1.2, 0.0, 1.0));\n\t//fragColor.rgb = mix(fragColor.rgb, fog_color, clamp(pow(normalized_depth, 1.0) * 1.25, 0.0, 1.0));\n    \n    float mix_factor = 1.0 - pow(1.0 - normalized_depth, 2.0);\n    fragColor.rgb = mix(fragColor.rgb, fog_color, mix_factor);\n#endif    \n    \n    //fragColor.rgb = vec3(detailed_noise_flat(uv * 50.0));\n    \n    //fragColor.rgba = texture(iChannel0, vec2(0.0, 0.0));\n    \n    //fragColor.rgba = textureLod(iChannel0, clean_uv, 0.0).xxxx;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Blur horizontally\n\nvec3 calculate_bloom(vec2 uv)\t// TODO: Do a two pass bloom filter?\n{\n    vec3 sample_sum = vec3(0.0);\n\tfloat weight_sum = 0.0;\n\n    for(int x=-bloom_radius; x<=bloom_radius; ++x)\n    {\n        //for(int y=-bloom_radius; y<=bloom_radius; ++y)\n        {\n            vec2 offset = vec2(x, 0);\n            \n            //float sample_weight = 1.0 / (10.0 + length(offset));\n            //sample_weight *= sample_weight;\t// Square the weight.\n            \n            //sample_weight = 0.01 + 1.0 / (1.0 + dot(offset, offset));\n            float sample_weight = 1.0 / (20.0 + dot(offset, offset));\n            vec3 sample_color = texture(iChannel0, uv + offset / iResolution.xy).rgb;\n            \n            //sample_color *= length(sample_color);\n            sample_color = min(sample_color, vec3(1.8));\n            sample_color *= max(length(sample_color) - 0.3, 0.0) / (1.0 - 0.3);\n\n    \t\tsample_sum += sample_color * sample_weight;\n            weight_sum += sample_weight;\n        }\n    }\n    \n    \n    //sample_sum /= float((2 * bloom_radius + 1) * (2 * bloom_radius + 1));\n    sample_sum /= weight_sum;\n    \n    return(sample_sum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = vec4(0.0);\n    \n    // Only render the left side of the screen,\n    // because we will mirror it later, to save performance..\n    if(uv.x <= 0.5)\n    {\n#ifdef ENABLE_BLOOM\n        fragColor.rgb = calculate_bloom(uv);\n#endif\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define ENABLE_BLUR\n#define ENABLE_BLOOM\n\n// Bloom settings:\nconst int bloom_radius = 10;\n\n// Blur settings:\nconst int blur_sample_count = 16;\nconst float blur_max_distance = 0.25;\t// TODO: Specify in pixels?","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Adds bloom and/or motion blur and renders the image to the screen.    \n\n// TODO: Do a bilateral blur for the bloom!\n// TODO: PERFORMANCE: The post effects slow things down quite a bit.\n// TODO: Post on surgeryhead video.\n\nvec3 calculate_bloom(vec2 uv)\t// TODO: Do a two pass bloom filter?\n{\n    vec3 sample_sum = vec3(0.0);\n\tfloat weight_sum = 0.0;\n\n    //for(int x=-bloom_radius; x<=bloom_radius; ++x)\n    {\n        for(int y=-bloom_radius; y<=bloom_radius; ++y)\n        {\n            vec2 offset = vec2(0, y);\n            \n            //float sample_weight = 1.0 / (10.0 + length(offset));\n            //sample_weight *= sample_weight;\t// Square the weight.\n            \n            //sample_weight = 0.01 + 1.0 / (1.0 + dot(offset, offset));\n            float sample_weight = 1.0 / (20.0 + dot(offset, offset));\n            vec3 sample_color = texture(iChannel0, uv + offset / iResolution.xy).rgb;\n            \n            // Don't modify sample colors in 2nd pass.\n            //sample_color *= length(sample_color);\n            //sample_color = min(sample_color, vec3(1.8));\n            //sample_color *= max(length(sample_color) - 0.3, 0.0) / (1.0 - 0.3);\n\n    \t\tsample_sum += sample_color * sample_weight;\n            weight_sum += sample_weight;\n        }\n    }\n    \n    \n    //sample_sum /= float((2 * bloom_radius + 1) * (2 * bloom_radius + 1));\n    sample_sum /= weight_sum;\n    \n    return(sample_sum);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Only render the left side of the screen,\n    // because we will mirror it later, to save performance..\n    if(uv.x <= 0.5)\n    {\n#ifdef ENABLE_BLOOM\n    \tfragColor.rgb = calculate_bloom(uv);\t// TODO: Blur the bloom too? Or calculate the bloom of the blurred image?\n#endif\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}