{"ver":"0.1","info":{"id":"ftdcWf","date":"1660680275","viewed":137,"name":"Color pulse thingy","username":"bencbartlett","description":"this will look cool on the sheep","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["baaahs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec3 hsl2rgb(in vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/* Returns a value for time which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral(float x) {\n    float t = mod(x, 1.);\n    float POWER = 6.; // Adjusts sharpnett of the curve\n    float OFFSET = 0.05; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n    return 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\n/* Test function for ShaderToy */\nfloat beatIntegral_shadertoy() {\n    float bpm = 60.;\n    float t = mod(iTime * bpm / 60., 1.);\n    float POWER = 4.; // Adjusts sharpnett of the curve\n    float OFFSET = 0.05; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n    return 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\n/* Test function for ShaderToy */\nfloat getFakeIntensity_shadertoy() {\n    float bpm = 60.;\n    float t = mod(iTime * bpm / 60., 1.);\n    return smoothstep(1., 0., t / 0.25) + smoothstep(1., 0., (1. - t) / 0.1);\n}\n\n/* Returns a value which cycles from 0 to 1 over a beat, quickly but smoothly returning to 0 at the end */\nfloat beatIntegral_smooth() {\n    float t = iTime / 5.;\n    float POWER = 4.; // Adjusts sharpnett of the curve\n    float OFFSET = 0.05; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n    float RESET_PERIOD = 0.5; // The last part of the beat where the value resets\n    float adjustedTime = mod(t + OFFSET, 1.0);\n    if (adjustedTime > (1. - RESET_PERIOD)) {\n        return smoothstep(1., 0., (adjustedTime - (1. - RESET_PERIOD)) / RESET_PERIOD);\n    } else {\n        return 1. - pow(1. - adjustedTime / (1. - RESET_PERIOD), POWER);\n    }\n}\n\nfloat smoothstepPulse(float t) {\n    float riseTime = 0.3;\n    float peakTime = 0.2;\n    return smoothstep(0., 1., t / riseTime) - smoothstep(0., 1., (t - peakTime) / riseTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float pulse = smoothstepPulse(mod(beatIntegral_shadertoy() - uv.x / 2.5, 1.));\n    \n    float hueRange = 1. / 3.;   \n    float H = .2 * iTime + uv.x * hueRange;\n    float S = .5 + .5 * pulse;\n    float V = .2 + .6 * pulse;\n\n    fragColor = vec4(hsl2rgb(vec3(H,S,V)), 1.);\n}","name":"Image","description":"","type":"image"}]}