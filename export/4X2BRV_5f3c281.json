{"ver":"0.1","info":{"id":"4X2BRV","date":"1729699006","viewed":387,"name":"Fake \"Real\" Camera","username":"Nguyen2007","description":"Attempting to create a camera\nLens: Zeiss Biotar 50mm f1.4\nSupports spectral effects and lens simulations (minus bloom). Halation, bloom and film grain are added in post.\nSuggestions welcome!","likes":22,"published":3,"flags":48,"usePreview":1,"tags":["3d","raytracing","lens","camera","bloom","flare","lenses","halation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nRIOW:\n\nInspired by Reinder’s RIOW implementation (removed classes)\nand knightcrawler25’s GLSL-PathTracer: https://github.com/knightcrawler25/GLSL-PathTracer\nSky texture by fgarlin: https://www.shadertoy.com/view/msXXDS\n\nFake “Real” Camera:\n\nSpecial Thanks To:\n\n\t•\tchronos: for importance sampling, and creating the 2D simulation to debug\n\t•\t01000001\n\t•\tArmandB: lens cap idea, and for helping out with the lens intersection function\n\t•\tIgneus: for suggesting the use of LDS for wavelength selection\n\t•\tbeans_please: for bloom and halation\n    •\tand many others I’ve probably forgotten to mention…\n\nInspired by:\n\n\t•\tyoutube.com/watch?v=YE9rEQAGpLw\n\t•\tyoutube.com/watch?v=jT9LWq279OI\n    •\tyoutube.com/watch?v=2SsTk657Uw0\n\nBased on placeholderart.wordpress.com/2015/01/19/implementation-notes-physically-based-lens-flares/\nand https://www.ipol.im/pub/art/2017/192/?utm_source=doi\n\nModify settings in the \"Common\" tab\n\n*/\n\n// ACES Cinematic Tonemapping by afl_ext: https://www.shadertoy.com/view/XsGfWV\n\n#define sRGB(c) pow(c, vec3(1) / 2.2) // sorry ttg :))\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(0);\n    \n    if(1.5 * abs(I.x - .5 * R.x) > R.y) return;\n    \n    #ifdef FILM_GRAIN\n    O = texture(iChannel1, I / R.xy);\n    O /= O.w;\n    #else\n    O = texture(iChannel0, I / R.xy);\n    O.xyz = flimTransform(O.xyz / O.w);\n    #endif\n    O.xyz = sRGB(O.xyz);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SKYTYPE 2 // 0: No sky, 1: Sky used in RIOW, 2: Physically-based Sky\n#define USE_LENS\n#define DISPERSION\n//#define ANTI_REFLECTION_COATING\n#define FILM_GRAIN\n\n//#define RUSSIAN_ROULETE\n\n#define ZERO min(0, iFrame)\n\n#define R iResolution\n\nconst float TAU    = 6.28318530717958647693,\n            PI     = 3.14159265358979323846,\n            INVPI  =  .31830988618379067154,\n            INV4PI =  .07957747154594766788;\n\n#define sqr(x) (x) * (x)\n#define dot2(x) dot(x, x)\n\n// parameters\n\nconst float flim_pre_exposure = 3.5;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// flim's utility functions\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = flim_rgb_max(rgb);\n    cmin = flim_rgb_min(rgb);\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    s = cmax > 0. ? cdelta / cmax : 0.;\n\n    if (s > 0.)\n    {\n        c = (cmax - rgb) / cdelta;\n        \n        h = rgb.x == cmax ? c.z - c.y :\n            rgb.y == cmax ? c.x - c.z + 2. :\n                            c.y - c.x + 4.;\n\n        h /= 6.;\n\n        if (h < 0.) h++;\n    }\n    \n    else h = 0.;\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv.x;\n    s = hsv.y;\n    v = hsv.z;\n\n    if (s > 0.)\n    {\n        if (h == 1.) h = 0.;\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        p = v * (1. - s);\n        q = v * (1. - s * f);\n        t = v * (1. - s * (1. - f));\n\n        rgb = i == 0 ? vec3(v, t, p) :\n              i == 1 ? vec3(q, v, p) :\n              i == 2 ? vec3(p, v, t) :\n              i == 3 ? vec3(p, q, v) :\n              i == 4 ? vec3(t, p, v) :\n                       vec3(v, p, q);\n    }\n    else rgb = vec3(v);\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv.x = fract(hsv.x + hue + .5);\n    hsv.y = clamp(hsv.y * sat, 0., 1.);\n    hsv.z *= value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, .001 * black_point,\n        1. - .001 * white_point\n    );\n    return col * mono2 / mono;\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x) return toe_y * pow(v / toe_x, slope * toe_x / toe_y);\n\n    // straight line\n    if (v < shoulder_x) return slope * (v - toe_x) + toe_y;\n\n    // shoulder\n    float shoulder_pow = slope * (1. - shoulder_x) / (1. - shoulder_y);\n    return\n        (1. - pow((1. - v) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = exp2(flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density + mix factor\n    return exp2(-fac * max_density);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= exp2(exposure);\n    \n    // red, green, and blue-sensitive layer\n    return vec3(flim_dye_mix_factor(col.x, max_density),\n                flim_dye_mix_factor(col.y, max_density),\n                flim_dye_mix_factor(col.z, max_density));\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        fract(primary_hue + (rotate / 360.)),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flimTransform(vec3 col)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= exp2(flim_pre_exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    vec3 white_cap = negative_and_print(vec3(1e7), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1e3,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    return col;\n}\n\n#define translate(p) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, p, 1)\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nmat4 rotateX(float a)\n{\n    float s = sin(a), c = cos(a);\n\n    return mat4(1, 0,  0, 0,\n                0, c, -s, 0,\n                0, s,  c, 0,\n\t\t\t    0, 0,  0, 1);\n}\n\nmat4 rotateY(float a)\n{\n    float s = sin(a), c = cos(a);\n\n    return mat4( c, 0, s, 0,\n                 0, 1, 0, 0,\n                -s, 0, c, 0,\n\t\t\t     0, 0, 0, 1);\n}\n\nmat4 rotateZ(float a)\n{\n    float s = sin(a), c = cos(a);\n\n    return mat4(c, -s, 0, 0,\n                s,  c, 0, 0,\n                0,  0, 1, 0,\n\t\t\t    0,  0, 0, 1);\n}\n\nconst mat4 noTransform = mat4(1);\n\nfloat deNaN (float v)\n{\n    return v != v ? 0. : v;\n}\n\nvec3 deNaN(vec3 v)\n{\n    return vec3(deNaN(v.x), deNaN(v.y), deNaN(v.z));\n}\n\nstruct ray\n{\n    vec3 o, d;\n};\n\nstruct material\n{\n    vec3 baseColor, emission;\n    \n    float anisotropic,\n          metallic,\n          roughness,\n          subsurface,\n          specularTint,\n          sheen,\n          sheenTint,\n          clearcoat,\n          clearcoatRoughness,\n          specTrans,\n          IOR, ax, ay;\n};\n\nconst material initMat = material(vec3(0), vec3(0), 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0.);\n\nstruct hitRecord\n{\n    float eta, t;\n    vec3 p, n;\n    material mat;\n    bool isVolume;\n};\n\nstruct cam\n{\n    vec3 o, llc, hor, ver, u, v, w;\n    float rad;\n};\n\nuvec4 seed;\n\nvec4 PCG(inout uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    return vec4(v) / 4294967296.;\n}\n\n#define rand  rand4.x\n#define rand2 rand4.xy\n#define rand3 rand4.xyz\n#define rand4 PCG(seed)\n\n\nvec4 hash4(vec4 p)\n{\n\tuvec4 v = floatBitsToUint(p);\n    return PCG(v);\n}\n\nvec4 hash4(float v) {return hash4(vec4(v));}\nvec4 hash4(vec2 v)  {return hash4(v.xyxy);}\nvec4 hash4(vec3 v)  {return hash4(v.xyzx);}\n\n#define hash(v)  hash4(v).x\n#define hash2(v) hash4(v).xy\n#define hash3(v) hash4(v).xyz\n\n// Samples the radix-2 Halton sequence from seed value, i\nfloat halton(uint i)\n{    \n    i = ((i & 0xffffu) << 16u) | (i >> 16u);\n    i = ((i & 0x00ff00ffu) << 8u) | ((i & 0xff00ff00u) >> 8u);\n    i = ((i & 0x0f0f0f0fu) << 4u) | ((i & 0xf0f0f0f0u) >> 4u);\n    i = ((i & 0x33333333u) << 2u) | ((i & 0xccccccccu) >> 2u);\n    i = ((i & 0x55555555u) << 1u) | ((i & 0xaaaaaaaau) >> 1u);\n    \n    return float(i) / 4294967296.;\n}\n\n#define toWorld(x, y, z, v) mat3(x, y, z) * (v)\n#define toLocal(x, y, z, v) (v) * mat3(x, y, z)\n\nvec2 ranDir()\n{\n    float phi = TAU * rand;\n    return vec2(cos(phi), sin(phi));\n}\n\nfloat gaussian()\n{\n    return sqrt(-2. * log(rand)) * cos(TAU * rand);\n}\n\nvec2 gaussian2D()\n{\n    return sqrt(-2. * log(rand)) * ranDir();\n}\n\n#define ranDisk() sqrt(rand) * ranDir()\n\n// Sampling Functions\n\nfloat GTR1(float NoH, float a)\n{\n    if (a >= 1.) return INVPI;\n    float a2 = a * a;\n    return (a2 - 1.) / (PI * log(a2) * (1. + (a2 - 1.) * NoH * NoH));\n}\n\nvec3 sampleGTR1(float a)\n{\n    float a2 = a * a;\n\n    float cos2T = (1. - pow(a2, rand)) / (1. - a2);\n\n    return vec3(sqrt(1. - cos2T) * ranDir(), sqrt(cos2T));\n}\n\nvec3 sampleGGXVNDF(vec3 V, float ax, float ay)\n{\n    V = normalize(vec3(ax * V.x, ay * V.y, V.z));\n    \n    vec2 t   = ranDisk();\n         t.y = mix(sqrt(1. - t.x * t.x), t.y, .5 + .5 * V.z);\n    \n    float l2 = dot2(V.xy);\n    \n    vec3 T1 = l2 > 0. ? vec3(-V.y, V.x, 0) * inversesqrt(l2) : vec3(1, 0, 0),\n         T2 = cross(V, T1),\n         N  = mat3(T1, T2, V) * vec3(t, sqrt(1. - dot2(t)));\n\n    return normalize(vec3(ax * N.x, ay * N.y, max(0., N.z)));\n}\n\nfloat GTR2Aniso(float NoH, float HoX, float HoY, float ax, float ay)\n{\n    if(ax * ay == 0.) return 1.;\n    return INVPI / (ax * ay * sqr(dot2(vec3(HoX / ax, HoY / ay, NoH))));\n}\n\nfloat smithG(float NoV, float alphaG)\n{\n    float a = alphaG * alphaG,\n          b = NoV * NoV;\n    \n    return 2. * NoV / (NoV + sqrt(a + b - a * b));\n}\n\nfloat smithGAniso(float NoV, float VoX, float VoY, float ax, float ay)\n{\n    if(ax * ay == 0.) return 1.;\n    \n    float a = VoX * ax,\n          b = VoY * ay,\n          c = NoV;\n    \n    return 2. * NoV / (NoV + sqrt(a * a + b * b + c * c));\n}\n\nfloat schlickWeight(float u)\n{\n    float m = min(1. - u, 1.),\n          m2 = m * m;\n    \n    return m2 * m2 * m;\n}\n\nfloat dielectricFresnel(float cosI, float eta)\n{\n    float sin2T = eta * eta * (1. - cosI * cosI);\n\n    // Total internal reflection\n    \n    if (sin2T > 1.) return 1.;\n\n    float cosT = sqrt(1. - sin2T);\n\n    float rs = (eta * cosT - cosI) / (eta * cosT + cosI),\n          rp = (eta * cosI - cosT) / (eta * cosI + cosT);\n\n    return .5 * (rs * rs + rp * rp);\n}\n\nfloat ARC(float r1, float r2, float beta)\n{\n    beta *= 2.;\n    \n    float r12 = r1 * r1,\n          r22 = r2 * r2;\n    \n    return (r12 + r22 + 2. * r1 * r2 * cos(beta)) / (1. + r12 * r22 + 2. * r1 * r2 * cos(beta));\n}\n\n// lambda   - Wavelength of light being tested for reflectance\n// d        - Thickness of the anti-reflectance coating (lambda0 / 4.0f / n1) where\n//              lambda0 is the wavelenght of light the coating was designed for, typically\n//              a midrange wavelenght like green (550 nm)\n// theta1   - Angle of incidence at the edge of the coating\n// n1       - The Index of Refraction for the incoming material\n// n2       - The Index of Refraction for the coating, max(sqrt(n1 * n2), 1.38) where 1.38\n//              is the index of refraction for a common magnesium floride coating.\n// n3       - The Index of Refraction for the outgoing material\n\nfloat Reflectance(float lambda, float d, float theta1, float n1, float n2, float n3)\n{\n    // Apply Snell's law to get the other angles\n    float theta2 = asin(n1 * sin(theta1) / n2);\n    float theta3 = asin(n1 * sin(theta1) / n3);\n \n    float cos1 = cos(theta1);\n    float cos2 = cos(theta2);\n    float cos3 = cos(theta3);\n \n    float beta = TAU / lambda * n2 * d * cos2;\n \n    // Compute the fresnel terms for the first and second interfaces for both s and p polarized\n    // light\n    \n    float rp = ARC((n2 * cos1 - n1 * cos2) / (n2 * cos1 + n1 * cos2),\n                   (n3 * cos2 - n2 * cos3) / (n3 * cos2 + n2 * cos3), beta);\n \n    float rs = ARC((n1 * cos1 - n2 * cos2) / (n1 * cos1 + n2 * cos2),\n                   (n2 * cos2 - n3 * cos3) / (n2 * cos2 + n3 * cos3), beta);\n \n    return (rs + rp) * .5;\n}\n\nvec3 ranCos()\n{\n    float r = rand;\n    return vec3(sqrt(r) * ranDir(), sqrt(1. - r));\n}\n\nvec3 ranSph()\n{\n    float h = rand * 2. - 1.;\n\treturn vec3(sqrt(1. - h * h) * ranDir(), h);\n}\n\nvec3 ranHemi(vec3 n)\n{\n    vec3 d = ranSph();\n    return d * sign(dot(d, n));\n}\n\nvoid onb(vec3 N, out vec3 T, out vec3 B) \n{\n    float s = N.z > 0. ? 1. : -1.,\n          a = s + N.z,\n          b = -N.x * N.y / a;\n    \n    T = s * vec3(s - N.x * N.x / a, b, -N.x);\n    B =     vec3(b, s - N.y * N.y / a, -N.y);\n}\n\n// Disney BSDF\n\n#define luma(v) dot(v, vec3(.3, .6, .1))\n\nvoid tint(material mat, float eta, out float F0, out vec3 Csheen, out vec3 Cspec)\n{\n    float lum = luma(mat.baseColor);\n    vec3 tint = lum > 0. ? mat.baseColor / lum : vec3(1);\n\n    F0 = sqr((1. - eta) / (1. + eta));\n    \n    Cspec  = mix(vec3(1), tint, mat.specularTint) * F0;\n    Csheen = mix(vec3(1), tint, mat.sheenTint);\n}\n\nvec3 diffuse(material mat, vec3 Csheen, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    float LoH = dot(L, H),\n          Rr  = 2. * mat.roughness * LoH * LoH,\n\n    // Diffuse\n    \n    FL     = schlickWeight(L.z),\n    FV     = schlickWeight(V.z),\n    Fretro = Rr * (FL + FV + FL * FV * (Rr - 1.)),\n    Fd     = (1. - .5 * FL) * (1. - .5 * FV),\n\n    // Fake subsurface\n    \n    Fss90 = .5 * Rr,\n    Fss   = mix(1., Fss90, FL) * mix(1., Fss90, FV),\n    ss    = 1.25 * (Fss * (1. / (L.z + V.z) - .5) + .5);\n\n    // Sheen\n    \n    vec3 Fsheen = schlickWeight(LoH) * mat.sheen * Csheen;\n\n    pdf = L.z * INVPI;\n    \n    return INVPI * mat.baseColor * mix(Fd + Fretro, ss, mat.subsurface) + Fsheen;\n}\n\nvec3 reflection(material mat, vec3 V, vec3 L, vec3 H, vec3 F, out float pdf)\n{\n    float D  = GTR2Aniso(H.z, H.x, H.y, mat.ax, mat.ay),\n          G1 = smithGAniso(abs(V.z), V.x, V.y, mat.ax, mat.ay),\n          G2 = smithGAniso(abs(L.z), L.x, L.y, mat.ax, mat.ay) * G1;\n\n    pdf = .25 * G1 * D / V.z;\n    \n    return F * D * G2 / (4. * L.z * V.z);\n}\n\nvec3 refraction(material mat, float eta, vec3 V, vec3 L, vec3 H, vec3 F, out float pdf)\n{\n    float LoH = dot(L, H), VoH = dot(V, H),\n\n    D  = GTR2Aniso(H.z, H.x, H.y, mat.ax, mat.ay),\n    G1 = smithGAniso(abs(V.z), V.x, V.y, mat.ax, mat.ay),\n    G2 = smithGAniso(abs(L.z), L.x, L.y, mat.ax, mat.ay) * G1;\n    \n    float jacobian = abs(LoH) / sqr(LoH + VoH * eta);\n\n    pdf = G1 * max(0., VoH) * D * jacobian / V.z;\n    \n    return sqrt(mat.baseColor) * (1. - F) * D * G2 * abs(VoH) * jacobian * eta * eta / abs(L.z * V.z);\n}\n\nfloat clearcoat(material mat, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    float VoH = dot(V, H),\n\n    F = mix(.04, 1., schlickWeight(VoH)),\n    D = GTR1(H.z, mat.clearcoatRoughness),\n    G = smithG(L.z, .25) * smithG(V.z, .25);\n\n    pdf = .25 * D * H.z / VoH;\n    \n    return F * D * G;\n}\n\nvec3 DisneyBSDF(hitRecord rec, vec3 V, vec3 N, vec3 L, out float pdf)\n{\n    if(rec.isVolume)\n    {\n        pdf = INV4PI;\n        return rec.mat.baseColor * INV4PI;\n    }\n    \n    float aspect = sqrt(1. - rec.mat.anisotropic * .9);\n    rec.mat.ax = rec.mat.roughness / aspect;\n    rec.mat.ay = rec.mat.roughness * aspect;\n    \n    pdf = 0.;\n    vec3 f = vec3(0);\n\n    vec3 T, B;\n    onb(N, T, B);\n\n    V = toLocal(T, B, N, V);\n    L = toLocal(T, B, N, L);\n\n    vec3 H = normalize(L.z > 0. ? L + V : L + V * rec.eta);\n\n    if (H.z < 0.) H = -H;\n\n    // Tint colors\n    \n    vec3 Csheen, Cspec;\n    float F0;\n    tint(rec.mat, rec.eta, F0, Csheen, Cspec);\n\n    // Model weights\n    \n    float dielectricW = (1. - rec.mat.metallic) * (1. - rec.mat.specTrans);\n    float metalW      = rec.mat.metallic;\n    float glassW      = (1. - rec.mat.metallic) * rec.mat.specTrans;\n\n    // Lobe probabilities\n    \n    float schlickW = schlickWeight(V.z);\n\n    float diffP       = dielectricW * luma(rec.mat.baseColor);\n    float dielectricP = dielectricW * mix(luma(Cspec), 1., schlickW);\n    float metalP      = metalW * mix(luma(rec.mat.baseColor), 1., schlickW);\n    float glassP      = glassW;\n    float clearCoatP  = .25 * rec.mat.clearcoat;\n\n    // Normalize probabilities\n    \n    float norm = 1. / (diffP + dielectricP + metalP + glassP + clearCoatP);\n    \n    diffP       *= norm;\n    dielectricP *= norm;\n    metalP      *= norm;\n    glassP      *= norm;\n    clearCoatP  *= norm;\n\n    bool reflect = L.z > 0.;\n\n    float tmpPdf = 0.;\n    float VoH = abs(dot(V, H));\n\n    // Diffuse\n    if (diffP > 0. && reflect)\n    {\n        f += diffuse(rec.mat, Csheen, V, L, H, tmpPdf) * dielectricW;\n        pdf += tmpPdf * diffP;\n    }\n\n    // Dielectric Reflection\n    if (dielectricP > 0. && reflect)\n    {\n        float F = (dielectricFresnel(VoH, 1. / rec.eta) - F0) / (1. - F0);\n\n        f += reflection(rec.mat, V, L, H, mix(Cspec, vec3(1), F), tmpPdf) * dielectricW;\n        pdf += tmpPdf * dielectricP;\n    }\n\n    // Metallic Reflection\n    if (metalP > 0.0 && reflect)\n    {\n        // Tinted to base color\n        vec3 F = mix(rec.mat.baseColor, vec3(1), schlickWeight(VoH));\n\n        f += reflection(rec.mat, V, L, H, F, tmpPdf) * metalW;\n        pdf += tmpPdf * metalP;\n    }\n\n    // Glass/Specular BSDF\n    if (glassP > 0.0)\n    {\n        // Dielectric fresnel (achromatic)\n        float F = dielectricFresnel(VoH, rec.eta);\n\n        if (reflect)\n        {\n            f += reflection(rec.mat, V, L, H, vec3(F), tmpPdf) * glassW;\n            pdf += tmpPdf * glassP * F;\n        }\n        else\n        {\n            f += refraction(rec.mat, rec.eta, V, L, H, vec3(F), tmpPdf) * glassW;\n            pdf += tmpPdf * glassP * (1. - F);\n        }\n    }\n\n    // Clearcoat\n    if (clearCoatP > 0. && reflect)\n    {\n        f += clearcoat(rec.mat, V, L, H, tmpPdf) * .25 * rec.mat.clearcoat;\n        pdf += tmpPdf * clearCoatP;\n    }\n\n    return f * abs(L.z);\n}\n\nvec3 DisneySample(hitRecord rec, vec3 V, out vec3 L, out float pdf)\n{\n    if(rec.isVolume)\n    {\n        L = ranSph();\n        pdf = INV4PI;\n        return rec.mat.baseColor * INV4PI;\n    }\n    \n    float aspect = sqrt(1. - rec.mat.anisotropic * .9);\n    rec.mat.ax = rec.mat.roughness / aspect;\n    rec.mat.ay = rec.mat.roughness * aspect;\n    \n    pdf = 0.;\n\n    vec3 N = rec.n, T, B;\n    onb(N, T, B);\n\n    V = toLocal(T, B, N, V);\n\n    // Tint colors\n    vec3 Csheen, Cspec;\n    float F0;\n    tint(rec.mat, rec.eta, F0, Csheen, Cspec);\n\n    // Model weights\n    float dielectricW = (1. - rec.mat.metallic) * (1. - rec.mat.specTrans);\n    float metalW      = rec.mat.metallic;\n    float glassW      = (1. - rec.mat.metallic) * rec.mat.specTrans;\n\n    // Lobe probabilities\n    float schlick = schlickWeight(V.z);\n\n    float diffP       = dielectricW * luma(rec.mat.baseColor);\n    float dielectricP = dielectricW * mix(luma(Cspec), 1., schlick);\n    float metalP      = metalW * mix(luma(rec.mat.baseColor), 1., schlick);\n    float glassP      = glassW;\n    float clearCoatP  = .25 * rec.mat.clearcoat;\n\n    // Normalize probabilities\n    float norm = 1. / (diffP + dielectricP + metalP + glassP + clearCoatP);\n    diffP *= norm;\n    dielectricP *= norm;\n    metalP *= norm;\n    glassP *= norm;\n    clearCoatP *= norm;\n\n    // CDF of the sampling probabilities\n    vec3 cdf;\n    cdf.x = diffP;\n    cdf.y = cdf.x + dielectricP + metalP;\n    cdf.z = cdf.y + glassP;\n\n    // Sample a lobe based on its importance\n    float r = rand;\n    \n    if (r < cdf.x) // Diffuse\n    {\n        L = ranCos();\n    }\n    else if (r < cdf.y) // Dielectric + Metallic reflection\n    {\n        vec3 H = sampleGGXVNDF(V, rec.mat.ax, rec.mat.ay);\n        L = reflect(-V, H);\n    }\n    else if (r < cdf.z) // Glass\n    {\n        vec3 H = sampleGGXVNDF(V, rec.mat.ax, rec.mat.ay);\n        \n        float F = dielectricFresnel(abs(dot(V, H)), rec.eta);\n        \n        L = rand < F ? reflect(-V, H) : refract(-V, H, rec.eta);\n    }\n    else // Clearcoat\n    {\n        vec3 H = sampleGTR1(rec.mat.clearcoatRoughness);\n\n        L = reflect(-V, H);\n    }\n\n    L = toWorld(T, B, N, L);\n    V = toWorld(T, B, N, V);\n\n    return DisneyBSDF(rec, V, N, L, pdf);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x), f = smoothstep(0., 1., fract(x));\n\t\n    return mix(mix(mix(hash(p                ), \n                       hash(p + vec3(1, 0, 0)), f.x),\n                   mix(hash(p + vec3(0, 1, 0)), \n                       hash(p + vec3(1, 1, 0)), f.x), f.y),\n               mix(mix(hash(p + vec3(0, 0, 1)), \n                       hash(p + vec3(1, 0, 1)), f.x),\n                   mix(hash(p + vec3(0, 1, 1)), \n                       hash(p +            1.), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p, int o)\n{\n    float a = 0., w = 1.;\n     \n    for (int i = 0; i < o; i++)\n    {\n        w *= .5;\n        a += w * noise(p);\n        p *= 2.;\n    }\n    return a;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool iSphere(mat4 txx, float rad,  ray r, float tmin, float tmax, inout hitRecord rec)\n{\n    vec3 ro = (inverse(txx) * vec4(r.o, 1)).xyz,\n\t     rd = (inverse(txx) * vec4(r.d, 0)).xyz;\n    \n    float b = dot(ro, rd),\n          d = rad * rad - dot2(ro - b * rd);\n\n    if (d < 0.) return false;\n    \n    d = sqrt(d);\n    \n    float N = -b - d,\n          F = -b + d;\n    \n    float t = N < tmin ? F : N;\n    \n    if(t < tmin || t > tmax) return false;\n    \n    rec.t = t;\n    rec.p = r.o + r.d * t;\n    rec.n = (txx * vec4(ro + rd * t, 0) / rad).xyz;\n    \n    return true;\n}\n\nbool iBox(mat4 txx, vec3 rad, ray r, float tmin, float tmax, inout hitRecord rec)\n{\n    vec3 ro = (inverse(txx) * vec4(r.o, 1)).xyz,\n\t     rd = (inverse(txx) * vec4(r.d, 0)).xyz,\n         \n    k = rad * sign(rd),\n                  \n\tt1 = (-ro - k) / rd,\n\tt2 = (-ro + k) / rd;\n    \n    float N = max(max(t1.x, t1.y), t1.z),\n          F = min(min(t2.x, t2.y), t2.z);\n    \n    if(N > F) return false;\n    \n    vec4 res = N > tmin ? vec4(N,  step(vec3(N), t1))\n                        : vec4(F, -step(t2, vec3(F)));\n    \n    if(res.x < tmin || res.x > tmax) return false;\n    \n    rec.t = res.x;\n    rec.p = r.o + r.d * res.x;\n    rec.n = (txx * vec4(-sign(rd) * res.yzw, 0)).xyz;\n\t\n\treturn true;\n}\n\nbool sphere(mat4 txx, float rad, ray r, float tmin, float tmax, out float t)\n{\n    vec3 ro = (inverse(txx) * vec4(r.o, 1)).xyz,\n\t     rd = (inverse(txx) * vec4(r.d, 0)).xyz;\n    \n    float b = dot(ro, rd),\n          d = rad * rad - dot2(ro - b * rd);\n\n    if (d < 0.) return false;\n    \n    d = sqrt(d);\n    \n    float N = -b - d,\n          F = -b + d;\n    \n    t = N < tmin ? F : N;\n    \n    if(t < tmin || t > tmax) return false;\n    \n    return true;\n}\n\nbool box(mat4 txx, vec3 rad, ray r, float tmin, float tmax, out float t)\n{\n    vec3 ro = (inverse(txx) * vec4(r.o, 1)).xyz,\n\t     rd = (inverse(txx) * vec4(r.d, 0)).xyz,\n\n\tk = rad * sign(rd),\n                  \n\tt1 = (-ro - k) / rd,\n\tt2 = (-ro + k) / rd;\n    \n    float N = max(max(t1.x, t1.y), t1.z),\n          F = min(min(t2.x, t2.y), t2.z);\n    \n    if(N > F || F < tmin || N > tmax) return false;\n    \n    t = N > tmin ? N : F;\n\t\n\treturn true;\n}\n\nmaterial DIFFUSE(vec3 col, float roughness)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    mat.roughness = roughness;\n    \n    return mat;\n}\n\nmaterial METAL(vec3 col, float roughness)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    mat.metallic  = 1.;\n    mat.roughness = roughness;\n    \n    return mat;\n}\n\nmaterial GLASS(vec3 col, float IOR, float roughness)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    mat.roughness = roughness;\n    mat.specTrans = 1.;\n    mat.IOR       = IOR;\n    \n    return mat;\n}\n\nmaterial LIGHT(vec3 col)\n{\n    material mat = initMat;\n    mat.emission = col;\n    \n    return mat;\n}\n\nmaterial VOLUME(vec3 col)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    \n    return mat;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 res = vec2(1e20, 0);\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * abs(map(pos+0.0005*e).x);\n    }\n    return normalize(n);\n}\n\nbool marchHit(ray r, float tmin, float tmax, inout hitRecord rec)\n{\n    vec2 res = vec2(-1);\n\n    float t = tmin;\n    for(int i = 0; i < 256 && t < tmax; i++)\n    {\n        vec2 h = map(r.o + r.d * t);\n        if(abs(h.x) < .0001 * t)\n        { \n            rec.t = t;\n            rec.p = r.o + r.d * t;\n            rec.n = calcNormal(rec.p);\n            rec.mat = DIFFUSE(vec3(1), 1.);\n            return true;\n        }\n        t += h.x;\n    }\n    \n    return false;\n}\n\nbool worldHit(ray r, float tmin, float tmax, out hitRecord rec)\n{\n    rec.t = tmax;\n    \n    bool hit = false;\n    \n    if(iBox(noTransform, vec3(1e3, .01, 1e3), r, tmin, rec.t, rec))\n    \n        hit = true,\n        rec.mat = DIFFUSE(vec3(.5), 1.);\n    \n    if (iSphere(translate(vec3(0, 1, 0)), 1., r, tmin, rec.t, rec))\n    \n        hit = true,\n        rec.mat = GLASS(vec3(1), 1.5, 0.);\n    \n    if (iSphere(translate(vec3(-4, 1, 0)), 1., r, tmin, rec.t, rec))\n    \n        hit = true,\n        rec.mat = DIFFUSE(vec3(.4, .2, .1), 1.);\n    \n    if (iSphere(translate(vec3(4, 1, 0)), 1., r, tmin, rec.t, rec))\n    \n        hit = true, \n        rec.mat = METAL(vec3(.7, .6, .5), 0.);\n    \n    vec2 ro = r.o.xz, rd = r.d.xz, p = floor(ro), s = sign(rd), m,\n         d = (p - ro + .5 + s * .5) / rd, cen;\n    \n    bool bhit = false;\n    \n    float t;\n    if(box(translate(vec3(0, .2, 0)), vec3(12, .2, 12), r, tmin, rec.t, t))\n    for(int i = ZERO; i < 40; i++)\n    {\n        for(int j = ZERO; j < 4; j++)\n        {\n            cen = p - vec2(j / 2, j % 2);\n            \n            if (all(lessThan(abs(cen), vec2(12))))\n            {\n                cen += .2 + .9 * hash2(cen);\n\n                if (sqr(abs(abs(cen.x) - 2.) - 2.) + sqr(cen.y) > .8)\n                if (iSphere(translate(vec3(cen.x, .2, cen.y)), .2, r, tmin, rec.t, rec))\n                {\n                    bhit = true;\n                    \n                    vec4 ran = hash4(cen);\n\n                    if(ran.w < .8)\n                    {\n                        if      (ran.w < .3) rec.mat = DIFFUSE(ran.xyz * ran.xyz * .9 + .1, 1.);\n                        else if (ran.w < .5) rec.mat = METAL(.5 * ran.xyz + .5, .5 * hash(ran));\n                        else                 rec.mat = GLASS(.5 * ran.xyz + .5, 1.5, 0.);\n                    }\n\n                    else rec.mat = LIGHT(4. * ran.xyz);\n                }\n            }\n        }\n\n        if(bhit)\n        {\n            hit = true;\n            break;\n        }\n            \n        m = step(d, d.yx);\n        d += m / abs(rd);\n        p += m * s;\n    }\n    \n    //if(marchHit(r, tmin, rec.t, rec)) hit = true;\n    \n    return hit;\n}\n\nvec3 skyTexture(vec3 rd)\n{\n    if(SKYTYPE == 1) return (1. - vec3(.25, .15, 0) * (rd.y + 1.));\n    if(SKYTYPE == 2) return .7 * texture(iChannel0, rd).xyz;\n    \n    return vec3(0);\n}\n\nvec3 sphericalDirection(float sinTheta, float cosTheta, float sinPhi, float cosPhi) {\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\nvec3 uniformSampleCone(float cosThetaMax, vec3 X, vec3 Y, vec3 Z)\n{\n    float cosTheta = mix(cosThetaMax, 1., rand);\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = rand * TAU;\n    vec3 V = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));\n    return V.x * X + V.y * Y + V.z * Z;\n}\n\nconst float scale = 2.,\n\n            r1  =   0.836,\n            r2  =   3.210,\n            r3  =   0.448,\n            r4  = -11.500,\n            r5  =   0.283,\n            r6  = - 0.385,\n            r7  =   0.505,\n            r8  = - 0.532,\n            r9  =   1.060,\n            r10 = - 1.200,\n            \n            d1 = 0.1075,\n            d2 = 0.0165,\n            d3 = 0.1555,\n            d4 = 0.0505,\n            d5 = 0.1890,\n            d6 = 0.0505,\n            d7 = 0.2122,\n            d8 = 0.0097,\n            d9 = 0.1390,\n            \n            N1 = 1.64238,\n            N2 = 1.62306,\n            N3 = 1.57566,\n            N4 = 1.67270,\n            N5 = 1.64238,\n            N6 = 1.64238,\n            \n            V1 = 48.0,\n            V2 = 56.9,\n            V3 = 41.2,\n            V4 = 32.2,\n            V5 = 48.0,\n            V6 = 48.0,\n            \n            A  = .4444 * scale;\n            \nconst float N = 1.4, AD = .6308 / N * scale, ID = .864,\n            k1 = .19749, k2 = .61588, k3 = .20134;\nfloat I;\n\nstruct lens\n{\n    // Radius, Thickness, IOR, Abbe number, Semi-Diameter\n    float R, d, N, V, h;\n};\n\nconst int numLenses = 10;\nconst lens[] lenses = lens[](lens(r1,  d1, N1, V1, .36),\n                             lens(r2,  d2, 1., 0., .36),\n                             lens(r3,  d3, N2, V2, .32),\n                             lens(r4,  d4, N3, V3, .32),\n                             lens(r5,  d5, 1., 0., .22),\n                             lens(r6,  d6, N4, V1, .22),\n                             lens(r7,  d7, N5, V1, .29),\n                             lens(r8,  d8, 1., 0., .29),\n                             lens(r9,  d9, N6, V1, .29),\n                             lens(r10, 0., 1., 0., .29));\n\ncam c;\n\nbool iLens(float pos, float h, float R, ray r, float tmin, float tmax, inout hitRecord rec)\n{\n    vec3 oc = r.o - c.w * (R + pos) - c.o, p;\n    \n    float b = dot(oc, r.d),\n          d = R * R - dot2(oc - b * r.d);\n          \n    if(d < 0.) return false;\n    \n    d = sqrt(d);\n    \n    float t = -b - d, s = -sign(R),\n          zCap = sqrt(R * R - h * h);\n    \n    if(t > tmin && t < tmax && s * dot(p = oc + r.d * t, c.w) > zCap)\n    {\n        rec.t = t;\n        rec.p = r.o + r.d * t;\n        rec.n = p / abs(R);\n        return true;\n    }\n    \n    t = -b + d;\n    \n    if(t > tmin && t < tmax && s * dot(p = oc + r.d * t, c.w) > zCap)\n    {\n        rec.t = t;\n        rec.p = r.o + r.d * t;\n        rec.n = -p / abs(R);\n        return true;\n    }\n\t\n\treturn false;\n}\n\nvec3 color(ray r)\n{\n    vec3 col = vec3(1), emitted = vec3(0);\n    float pdf;\n\thitRecord rec;\n    \n    #ifdef USE_LENS\n    \n    float zMax = 0.;\n    float[numLenses] lensPos;\n    lens L, l;\n    \n    for(int i = ZERO; i < numLenses; i++)\n    {\n        l = lenses[i];\n        lensPos[i] = zMax;\n        zMax += l.d * scale;\n    }\n    \n    #ifdef DISPERSION\n    float waveMix = halton(seed.w);\n    #else\n    float waveMix = .5;\n    #endif\n    \n    l = lenses[numLenses - 1]; l.R *= scale; l.h *= scale;\n    \n    vec3 oc = c.o - c.w * (l.R - lensPos[numLenses - 1] - sign(l.R) * sqrt(l.R * l.R - l.h * l.h)) - r.o,\n         Z = normalize(oc), X, Y;\n    \n    onb(Z, X, Y);\n    \n    float cosThetaMax = sqrt(max(0., 1. - l.h * l.h / dot2(oc)));\n    \n    r.d = uniformSampleCone(cosThetaMax, X, Y, Z);\n    \n    col *= /* TAU * (1. - cosThetaMax) */ dot(r.d, -c.w) / PI;\n    \n    float tmin = 1e-3 * scale;\n    int lensID = numLenses;\n    \n    for (int i = ZERO; i < 20; i++)\n    {\n        lensID += int(sign(dot(r.d, c.w)));\n        \n        L = lenses[lensID];\n        \n        L.R *= scale;\n        L.h *= scale;\n        \n        if(iLens(lensPos[lensID], L.h, L.R, r, tmin, 1e5, rec))\n        {\n            vec3  o = r.o - c.o - A * c.w;\n            float t = -dot(c.w, o) / dot(r.d, c.w);\n            \n            if(t > 0. && t < rec.t)\n            if(4. * dot2(o + r.d * t) > AD) return vec3(0);\n            \n            if(lensID > 0) l = lenses[lensID - 1];\n            else           l = lens(0., 0., 1., 0., 0.);\n            \n            if(dot(r.d, c.w) < 0.)\n            {\n                lens temp = L;\n                L = l; l = temp;\n            }\n            \n            float n1 = L.N,\n                  n2 = l.N,\n                  IOR, F;\n            \n            float d = 550. / 4. / n1,\n                  nCoat = sqrt(n1 * n2);\n            \n            #ifdef DISPERSION\n            \n            if(n1 > 1.) n1 -= (waveMix - .5) * (n1 - 1.) / L.V;\n            if(n2 > 1.) n2 -= (waveMix - .5) * (n2 - 1.) / l.V;\n            \n            #endif\n            \n            IOR = n2 / n1;\n            \n            #ifdef ANTI_REFLECTION_COATING\n            \n            F = Reflectance(400. + 300. * waveMix, d, acos(dot(-r.d, rec.n)), n1, nCoat, n2);\n            \n            #else\n            \n            F = dielectricFresnel(abs(dot(r.d, rec.n)), IOR);\n            \n            #endif\n            \n            r = ray(rec.p, rand < F ? reflect(r.d, rec.n) : refract(r.d, rec.n, IOR));\n        }\n        else break;\n    }\n    \n    if(lensID > -1) return vec3(0);\n    #endif\n    \n    for (int i = ZERO; i < 10; i++)\n    {\n        if (worldHit(r, .01, 1e5, rec))\n        {\n            emitted += col * rec.mat.emission;\n            \n            if(luma(col) < 1e-6) break;\n            \n            ray scattered;\n            scattered.o = rec.p;\n            \n            rec.eta = rec.mat.IOR;\n            if(dot(rec.n, r.d) > 0.) rec.n = -rec.n;\n            else rec.eta = 1. / rec.eta;\n            vec3 BSDF = DisneySample(rec, -r.d, scattered.d, pdf);\n            if(pdf > 0.) col *= BSDF / pdf;\n            else break;\n            \n            r = scattered;\n            \n            #ifdef RUSSIAN_ROULETE\n            float p = 1. - 1. / luma(col + 1.);\n        \tif (rand > p) break;\n            col /= p;\n            #endif\n        }\n        \n        else\n        {\n            emitted += col * skyTexture(r.d);\n            break;\n    \t}\n    }\n    \n    #ifdef USE_LENS\n    \n        emitted *= 5. * N * N;\n        #ifdef DISPERSION\n        emitted *= 4. * max(1. - abs(4. * waveMix - vec3(3, 2, 1)), 0.);\n        #endif\n    \n    #endif\n\n    return emitted;\n}\n\ncam camera(vec3 ro, vec3 lp, vec3 vup, float vfov, float aperture, float d)\n{\n    cam c;\n    \n    float hh = tan(radians(vfov) / 2.) * d,\n          hw = R.x / R.y * hh;\n          \n    c.rad = aperture / 2.;\n    c.o = ro;\n    c.w = normalize(ro - lp);\n    c.u = normalize(cross(vup, c.w));\n    c.v = cross(c.w, c.u);\n    c.llc = c.o - hw * c.u - hh * c.v - d * c.w;\n    c.hor = 2. * hw * c.u;\n    c.ver = 2. * hh * c.v;\n    \n    d /= scale;\n    I = scale * (d + k1) / (k2 * d - k3);\n    \n    return c;\n}\n\nray getRay(cam c, vec2 uv)\n{\n    #ifdef USE_LENS\n    uv -= .5;\n    uv.x *= R.x / R.y;\n    uv   *= .6 * ID * scale;\n    \n    return ray(c.o - uv.x * c.u - uv.y * c.v + c.w * I, c.w);\n    \n    #else\n    vec2 rd = c.rad * ranDisk();\n    \n    c.o += c.u * rd.x + c.v * rd.y;\n    \n    return ray(c.o, normalize(c.llc + uv.x * c.hor + uv.y * c.ver - c.o));\n    #endif\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(0);\n    \n    if(iFrame < 2 && SKYTYPE > 1) return;\n    \n    seed = uvec4(I, iFrame, iTime);\n    \n    vec2 uv = (I + rand2 - .5) / R.xy;\n    \n    c = camera(vec3(13, 2, 3), vec3(0), vec3(0, 1, 0), 28., AD, 10.);\n    \n    vec3 col = deNaN(color(getRay(c, uv)));\n    \n    if(texelFetch(iChannel2, ivec2(32, 0), 0).x < .5) O = texelFetch(iChannel1, ivec2(I), 0);\n    \n    O += vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvec3 tex(vec2 p)\n{\n    vec4 O = texture(iChannel0, clamp(p, 0., 1.));\n    return O.xyz / O.w;\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(0);\n    \n    if(iFrame < 2 && SKYTYPE > 1) return;\n    \n    seed = uvec4(I, iFrame, iTime);\n    \n    // TO DO: Bloom and Halation\n    \n    if(texelFetch(iChannel2, ivec2(32, 0), 0).x < .5) O = texelFetch(iChannel1, ivec2(I), 0);\n    \n    O += vec4(tex(I / R.xy), 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"const vec4  groundAlbedo         = vec4(0.3);\n// Ray marching steps. More steps mean better accuracy but worse performance\nconst int TRANSMITTANCE_STEPS     = 128;\nconst int IN_SCATTERING_STEPS     = 128;\n\n//-----------------------------------------------------------------------------\n// Constants\n\n// All parameters that depend on wavelength (vec4) are sampled at\n// 630, 560, 490, 430 nanometers\n\nconst float g = 0.8;\n\nconst float groundRadius        = 6371.; // km\nconst float atmosphereThickness = 1e2;   // km\nconst float atmosphereRadius    = groundRadius + atmosphereThickness;\nconst vec3 viewPos = vec3(0, 6371.001, 0);\nconst vec3 sunDir = normalize(vec3(8, 0, -4));\n\nconst vec4 sun_spectral_irradiance = vec4(1.679, 1.828, 1.986, 1.307);\nconst vec4 molecular_scattering_coefficient_base = vec4(6.605e-3, 1.067e-2, 1.842e-2, 3.156e-2);\nconst vec4 ozone_absorption_cross_section = vec4(3.472e-25, 3.914e-25, 1.349e-25, 1.103e-26);\n\nconst float ozoneMean = 3e2;\n\nconst vec4 aerosol_absorption_cross_section = vec4(2.8722e-24, 4.6168e-24, 7.9706e-24, 1.3578e-23);\nconst vec4 aerosol_scattering_cross_section = vec4(1.5908e-22, 1.7711e-22, 2.0942e-22, 2.4033e-22);\nconst float aerosol_base_density = 1.3681e20;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.73;\n\n//-----------------------------------------------------------------------------\n\nfloat iSphere(vec3 ro, vec3 rd, float rad)\n{\n    float b = dot(ro, rd),\n          d = rad * rad - dot2(ro - b * rd);\n    \n    if (d < 0.) return -1.;\n    \n    d = sqrt(d);\n    \n    return d > -b ? -b + d : -b - d;\n}\n\n/*\n * Rayleigh phase function.\n */\nfloat molecular_phase_function(float cosTheta)\n{\n    return .0596831 * (1. + cosTheta * cosTheta);\n}\n\n/*\n * Henyey-Greenstrein phase function.\n */\nfloat aerosol_phase_function(float cosTheta)\n{\n    float gg  = g * g,\n          den = 1. + gg + 2. * g * cosTheta;\n    \n    return INV4PI * (1. - gg) / den / sqrt(den);\n}\n\n/*\n * Return the molecular volume scattering coefficient (km^-1) for a given altitude\n * in kilometers.\n */\nvec4 get_molecular_scattering_coefficient(float h)\n{\n    return molecular_scattering_coefficient_base * exp(-.07771971 * pow(h, 1.16364243));\n}\n\n/*\n * Return the molecular volume absorption coefficient (km^-1) for a given altitude\n * in kilometers.\n */\nvec4 get_molecular_absorption_coefficient(float h)\n{\n    h += 1e-4; // Avoid division by 0\n    float density = 3.78547397e20 / h * exp(-sqr(log(h) - 3.22261) * 5.55555555);\n    return ozone_absorption_cross_section * ozoneMean * density;\n}\n\nfloat get_aerosol_density(float h)\n{\n    return aerosol_base_density * exp(-h / aerosol_height_scale) + aerosol_background_density;\n}\n\n/*\n * Get the collision coefficients (scattering and absorption) of the\n * atmospheric medium for a given point at an altitude h.\n */\nvoid get_atmosphere_collision_coefficients(float h,\n                                           out vec4 aerosol_absorption,\n                                           out vec4 aerosol_scattering,\n                                           out vec4 molecular_absorption,\n                                           out vec4 molecular_scattering,\n                                           out vec4 extinction)\n{\n    h = max(h, 0.); // In case height is negative\n    \n    float aerosol_density = get_aerosol_density(h);\n    aerosol_absorption = aerosol_absorption_cross_section * aerosol_density;\n    aerosol_scattering = aerosol_scattering_cross_section * aerosol_density;\n    \n    molecular_absorption = get_molecular_absorption_coefficient(h);\n    molecular_scattering = get_molecular_scattering_coefficient(h);\n    extinction = aerosol_absorption + aerosol_scattering + molecular_absorption + molecular_scattering;\n}\n\nvec2 rd2uv(vec3 rd)\n{\n    vec2 uv;\n    \n    vec3 ard = abs(rd);\n\n    if(ard.x > ard.y && ard.x > ard.z)\n    {\n        uv = .5 * rd.yz / rd.x + .5;\n        if(rd.x > 0.) uv.y++;\n    }\n    else if(ard.y > ard.z)\n    {\n        uv = .5 * rd.zx / rd.y + .5;\n        uv.x += 1.;\n        if(rd.y > 0.) uv.y++;\n    }\n    else\n    {\n        uv = .5 * rd.xy / rd.z + .5;\n        uv.x += 2.;\n        if(rd.z > 0.) uv.y++;\n    }\n    \n    return uv / vec2(3, 2);\n}\n\nvec3 uv2rd(vec2 uv)\n{\n    uv *= vec2(3, 2);\n    ivec2 i = ivec2(uv);\n    \n    uv = fract(uv) - .5;\n    \n    vec3 rd = normalize(vec3(uv, .5));\n    \n    if(i.y < 1) rd = -rd;\n    \n    return i.x < 1 ? rd.zxy : i.x < 2 ? rd.yzx : rd;\n}\n\nvec4 LUT(float cosTheta, float normalized_altitude)\n{\n    return texture(iChannel0, uv2rd(vec2(cosTheta * .5 + .5, normalized_altitude)));\n}\n\nvoid mainCubemap(out vec4 O, vec2 I, vec3 ro, vec3 rd)\n{\n    if (SKYTYPE < 2) return;\n    \n    if (iFrame > 1) { O = texture(iChannel0, rd); return; }\n    \n    if (iFrame > 0)\n    {\n        ro = viewPos;\n\n        float tmax = iSphere(ro, rd, groundRadius);\n\n        if (tmax < 0.) tmax = iSphere(ro, rd, atmosphereRadius);\n\n        float cosTheta = dot(-rd, sunDir);\n\n        float molecular_phase = molecular_phase_function(cosTheta);\n        float aerosol_phase = aerosol_phase_function(cosTheta);\n\n        float dt = tmax / float(IN_SCATTERING_STEPS);\n\n        vec4 L = vec4(0),\n             transmittance = vec4(1);\n\n        vec3 pos = ro;\n\n        for (int i = 0; i < IN_SCATTERING_STEPS; ++i)\n        {\n            float d = length(pos);\n            vec3 zenith_dir = pos / d;\n            float altitude = d - groundRadius;\n            float normalized_altitude = altitude / atmosphereThickness;\n\n            cosTheta = dot(zenith_dir, sunDir);\n\n            vec4 aerosol_absorption, aerosol_scattering;\n            vec4 molecular_absorption, molecular_scattering;\n            vec4 extinction;\n            get_atmosphere_collision_coefficients(\n                altitude,\n                aerosol_absorption, aerosol_scattering,\n                molecular_absorption, molecular_scattering,\n                extinction);\n\n            vec4 transmittance_to_sun = LUT(cosTheta, normalized_altitude);\n\n            // Solid angle subtended by the planet from a point at d distance\n            // from the planet center.\n            // 2nd order scattering from the ground\n            vec4 L_ground = .5 * (1. - sqrt(max(1. - sqr(groundRadius / d), 0.))) * groundAlbedo * INVPI * LUT(cosTheta, 0.) * LUT(1., 0.) / LUT(1., normalized_altitude) * cosTheta;\n\n            // Fit of Earth's multiple scattering coming from other points in the atmosphere\n            vec4 L_ms = vec4(.00434, .00694, .01188, .02) / (1. + 5. * exp(-17.92 * cosTheta));\n\n            vec4 ms = L_ms + L_ground;\n\n            vec4 S = sun_spectral_irradiance *\n                (molecular_scattering * (molecular_phase * transmittance_to_sun + ms) +\n                 aerosol_scattering   * (aerosol_phase   * transmittance_to_sun + ms));\n\n            vec4 step_transmittance = exp(-dt * extinction);\n\n            // Energy-conserving analytical integration\n            // \"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\"\n            // by Sébastien Hillaire\n\n            L += transmittance * S * (1. - step_transmittance) / extinction;\n            transmittance *= step_transmittance;\n\n            pos += rd * dt;\n        }\n\n        O.xyz = mat4x3(137.672389239975, -8.632904716299537, -1.7181567391931372,\n                       32.549094028629234, 91.29801417199785, -12.005406444382531,\n                       -38.91428392614275, 34.31665471469816, 29.89044807197628,\n                       8.572844237945445, -11.103384660054624, 117.47585277566478) * L;\n        return;\n    }\n    \n    I = rd2uv(rd);\n    \n    float cosTheta = I.x * 2. - 1.;\n\n    ro = vec3(0, 0, groundRadius + atmosphereThickness * I.y);\n    rd = vec3(-sqrt(1. - cosTheta * cosTheta), 0, cosTheta);\n\n    float tmax = iSphere(ro, rd, groundRadius);\n    if (tmax < 0.) tmax = iSphere(ro, rd, atmosphereRadius);\n    \n    float dt = tmax / float(TRANSMITTANCE_STEPS);\n\n    O = vec4(0);\n    \n    for (int i = 0; i < TRANSMITTANCE_STEPS; i++)\n    {\n        vec4 aerosol_absorption, aerosol_scattering,\n             molecular_absorption, molecular_scattering,\n             extinction;\n        \n        get_atmosphere_collision_coefficients(\n            length(ro) - groundRadius,\n            aerosol_absorption, aerosol_scattering,\n            molecular_absorption, molecular_scattering,\n            extinction);\n\n        O += extinction;\n        \n        ro += rd * dt;\n    }\n\n    O = exp(-O * dt);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec3 tex(vec2 p)\n{\n    vec4 O = texture(iChannel0, p / R.xy);\n    return flimTransform(O.xyz / O.w);\n}\n\nint poisson(float expMean)\n{\n    float p = 1.;\n    int i = -1;\n    while (p > expMean && i++ < 20) p *= rand;\n    return i;\n}\n\nconst float radius = .06,\n            sigmaR = .024,\n            blur   = .2;\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(0);\n    \n    if(iFrame < 2 && SKYTYPE > 1) return;\n    \n    seed = uvec4(I, iFrame, iTime);\n    \n    if(texelFetch(iChannel2, ivec2(32, 0), 0).x < .5) O = texelFetch(iChannel1, ivec2(I), 0);\n    \n    float maxRadius = radius, mu, sigma;\n    \n    float ag = 1. / ceil(1. / radius);\n    \n    if (sigmaR > 0.)\n    {\n        sigma = log(sqr(sigmaR / radius) + 1.);\n        mu = log(radius) - .5 * sigma;\n        sigma = sqrt(sigma);\n        maxRadius = exp(mu + 2. * sigma);\n    }\n    \n    vec2 p = I + blur * gaussian2D() + rand2 - .5;\n    \n    vec3 col = vec3(0);\n    \n    ivec4 bound = ivec4((p - maxRadius) / ag, (p + maxRadius) / ag);\n    \n    bool covered = false;\n    \n    for (int x = bound.x; x <= bound.z && !covered; x++)\n    for (int y = bound.y; y <= bound.w && !covered; y++)\n    {\n        vec2 pos = ag * vec2(x, y);\n        \n        vec3 expMean = exp(INVPI / (1. + sqr(sigmaR / radius)) * log(1. - tex(pos)));\n        \n        pos -= p;\n        \n        for (int i = 0; i < 3; i++)\n        {\n            if(col[i] > .5) continue;\n            \n            seed = uvec4(x, y, i, i);\n            \n            int nGrain = poisson(expMean[i]);\n            \n            for (int j = 0; j < nGrain; j++)\n            {\n                if (dot2(pos + ag * rand2) < sqr(sigmaR > 0. ? min(exp(mu + sigma * gaussian()), maxRadius) : radius))\n                {\n                    col[i]++;\n                    break;\n                }\n            }\n        }\n        \n        if (col == vec3(1)) covered = true;\n    }\n    \n    if(texelFetch(iChannel2, ivec2(32, 0), 0).x < .5) O = texelFetch(iChannel1, ivec2(I), 0);\n    \n    O += vec4(col, 1);\n}","name":"Buffer C","description":"","type":"buffer"}]}