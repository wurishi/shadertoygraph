{"ver":"0.1","info":{"id":"3l3yW7","date":"1609180237","viewed":98,"name":"Day 3: Rotating rings","username":"Gratemate","description":"Getting started with raymarching and 3d shaders, took a while for me to get the basics but here you go, this is the result of that :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Made using functions from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#signed-distance-functions\n//and https://iquilezles.org/articles/distfunctions\n\nconst int MAX_MARCHING_STEPS=255;\nconst float MIN_DIST=0.;\nconst float MAX_DIST=100.;\nconst float EPSILON=.0001;\n\n//GENERAL FUNCTIONS//\n\nfloat smin(float a,float b,float k){\n    float res=exp(-k*a)+exp(-k*b);\n    return-log(res)/k;\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\n//GENERAL FUNCTIONS end//--\n\n//SDFs//\n\nfloat sdSphere(vec3 p,float r){\n    return length(p)-r;\n}\n\n//SDFs end//--\n\n//SCENE COMPOSITION//\n\nfloat sceneSDF(vec3 p){\n    //outside ring 1\n    float rotSpeed1_y = iTime * 0.25;\n    float rotSpeed1_z = cos(iTime*0.5)*13.0;\n    vec3 rotP1 = (rotateZ(rotSpeed1_z) * rotateY(rotSpeed1_y) * vec4(p,1.0)).xyz;\n\n    float s1 = sdSphere(rotP1,1.0);\n    float s2 = sdSphere(rotP1+vec3(-1.0,0.0,0.0),1.2);\n    float s = max(s1,-s2);\n    float s3 = sdSphere(rotP1+vec3(1.0,0.0,0.0),1.2);\n    s = max(s,-s3);\n    \n    //outside ring 2\n    float rotSpeed2_y = sin(iTime*0.24)*13.0;\n    float rotSpeed2_z = cos(iTime*0.24+0.6)*13.0;\n    vec3 rotP2 = (rotateZ(rotSpeed2_z) * rotateY(rotSpeed2_y) * vec4(p,1.0)).xyz;\n\n    float s4 = sdSphere(rotP2,1.5);\n    float s5 = sdSphere(rotP2+vec3(-1.0,0.0,0.0),1.6);\n    s4 = max(s4,-s5);\n    float s6 = sdSphere(rotP2+vec3(1.0,0.0,0.0),1.6);\n    s4 = max(s4,-s6);\n    s = min(s,s4);\n    \n    //middle sphere\n    float sMid = sdSphere(p,0.5);\n    float sMid_1 = sdSphere(p+vec3(-0.5,0.0,0.0),0.5);\n    sMid = max(sMid,-sMid_1);\n    s = min(s,sMid);\n\n\n    return s;\n}\n\n//SCENE COMPOSITION end//--\n\n//RAYMARCHING FUNCTIONS//\n\nfloat shortestDist(vec3 eye,vec3 marchDir,float start,float end){\n    float t=start;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        float dist=sceneSDF(eye+t*marchDir);\n        if(dist<EPSILON){\n            return t;//hits object\n        }\n        t+=dist;\n        if(t>=end){\n            return end;//hits sky (gives up)\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView,vec2 size,vec2 fragCoor){\n    vec2 xy=fragCoor-size/2.;\n    float z=size.y/tan(radians(fieldOfView)/2.);\n    return normalize(vec3(xy,-z));\n}\n\nvec3 normal(vec3 p){\n    return normalize(vec3(\n        sceneSDF(vec3(p.x+EPSILON,p.y,p.z))-sceneSDF(vec3(p.x-EPSILON,p.y,p.z)),\n        sceneSDF(vec3(p.x,p.y+EPSILON,p.z))-sceneSDF(vec3(p.x,p.y-EPSILON,p.z)),\n        sceneSDF(vec3(p.x,p.y,p.z+EPSILON))-sceneSDF(vec3(p.x,p.y,p.z-EPSILON))\n    ));\n}\n\nvec3 phongContrib(vec3 k_diffuse, vec3 k_specular, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntes){\n    vec3 N = normal(p);\n    vec3 LightDir = normalize(lightPos-p);\n    vec3 RayDir = normalize(eye-p);\n    vec3 ReflectDir = normalize(reflect(-LightDir,N));\n\n    float dotLightNorm = dot(lightPos,N);\n    float dotRefRay = dot(ReflectDir,RayDir);\n\n    if(dotLightNorm < 0.0){\n        //light not vissable if dot less than 0\n        return vec3(0.0);\n    }\n\n    if(dotRefRay < 0.0){\n        //apply only diffuse\n        return lightIntes * (k_diffuse*dotLightNorm);\n    }\n    return lightIntes * (k_diffuse * dotLightNorm + k_specular * pow(dotRefRay, alpha));\n}\n\nvec3 phongIllum(vec3 k_ambient, vec3 k_diffuse, vec3 k_specular, float alpha, vec3 p, vec3 eye){\n    const vec3 ambientLight = 0.5 * vec3(1.0);\n    vec3 color = ambientLight * k_ambient;\n\n    vec3 lightPos1 = vec3(3.0,2.0,4.0);\n    vec3 lightIntes1 = vec3(0.2);\n    color += phongContrib(k_diffuse, k_specular, alpha, p, eye, lightPos1, lightIntes1);\n\n    return color;\n}\n\nmat4 vMatrix(vec3 eye, vec3 center, vec3 up){\n    vec3 f = normalize(center-eye);\n    vec3 s = normalize(cross(f,up));\n    vec3 u = cross(s,f);\n    return mat4(    \n        vec4(s,0.0),\n        vec4(u,0.0),\n        vec4(-f,0.0),\n        vec4(0.0,0.0,0.0,1.0)\n    );\n}\n\n//RAYMARCHING FUNCTIONS end//--\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    //CAMERA SETTINGS\n    float fieldOfView = 30.0;\n    vec3 eyePos = vec3(10.0,2.0,0.0);\n    float rotationSpeed = 0.25;\n    vec4 bgColor = vec4(0.0118, 0.0078, 0.0667, 1.0);\n\n    vec3 viewDir=rayDirection(fieldOfView,iResolution.xy,fragCoord);\n    vec3 eye=(vec4(eyePos,1.0) * rotateY(iTime*rotationSpeed)).xyz;\n    mat4 viewToWorld = vMatrix(eye, vec3(0.0), vec3(0.0,1.0,0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir,0.0)).xyz;\n    float dist=shortestDist(eye,worldDir,MIN_DIST,MAX_DIST);\n    if(dist>MAX_DIST-EPSILON){fragColor=bgColor;return;}\n    \n    vec3 p = eye + dist * worldDir;//hit position\n\n    //COLOR SETTINGS\n    vec3 ambientCol = (normal(p)+2.0)*0.3;\n    vec3 diffuseCol = vec3(0.9647, 0.3098, 0.0471);\n    vec3 specularCol = vec3(1.0, 0.9098, 0.9098);\n    float gloss = 50.0;\n\n    vec3 color = phongIllum(ambientCol, diffuseCol, specularCol, gloss, p, eye);\n\n    fragColor=vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}