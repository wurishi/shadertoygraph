{"ver":"0.1","info":{"id":"3syfDG","date":"1607882081","viewed":75,"name":"a few shapes (vlllll)","username":"valalalalala","description":"While working on making a cartoon-ish star for a scene, stumbled onto a few other useful shapes. The ufo is pretty weird, and a good example of a \"happy accident\" for my space scene.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","star","ufo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"a few shapes \" \n//\n// by Val \"valalalalala\" GvM - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// see my https://www.shadertoy.com/view/tsyfDw for acknowledgements.\n\n#define RAY_MARCH_STEPS    133\n#define RAY_MARCH_TOO_FAR  float( RAY_MARCH_STEPS )\n#define RAY_MARCH_CLOSE    0.01\n\n#define PI2  6.283185307179586\n\nmat3 makeCamera( vec3 origin, vec3 target, float roll ) {\n\tvec3 up = vec3(sin(roll), cos(roll), 0.0);\n\tvec3 zz = normalize(target - origin);\n\tvec3 xx = normalize(cross(zz, up));\n\tvec3 yy = normalize(cross(xx, zz));\n\treturn mat3( xx, yy, zz );\n}\n\nfloat boxSDF( vec3 point, vec3 center, vec3 size ) {\n    vec3 diff = abs( point - center ) - size;\n    return max( diff.x, max( diff.y, diff.z ) );\n}\n\nfloat projectVector( vec3 a, vec3 b, vec3 p ) {  \n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float numerator   = dot( ap, ab );\n    float denomenator = dot( ab, ab );\n\n    return clamp( numerator / denomenator, 0., 1. );\n}\n\nfloat conoSDF( vec3 point, vec3 center, float len, float thickness, float angle ) {\n    vec2 o = len * vec2( cos( angle ), sin( angle ) );\n    vec3 a = vec3( center.xy + o, center.z );\n        \n    float h = projectVector( a, center, point );  \n    vec3 q = a + ( center -a ) * h;\n       \n    h = pow( h, 0.7 ); // fatten up a bit...\n    h *= 0.8; // little smaller...\n\n    return length( point - q ) - thickness * h;\n}\n\nfloat starSDF( vec3 point, vec3 center, float len, float thickness ) {    \n    float b = PI2 / 5.0;\n    float angle = b * .25;\n\n    float s1 = conoSDF( point, center, len, thickness, angle + b * 0. );\n    float s2 = conoSDF( point, center, len, thickness, angle + b * 1. );\n    float s3 = conoSDF( point, center, len, thickness, angle + b * 2. );\n    float s4 = conoSDF( point, center, len, thickness, angle + b * 3. );\n    float s5 = conoSDF( point, center, len, thickness, angle + b * 4. );\n  \n    return min( s1, min( s2, min( s3, min( s4, s5 ) ) ) ) ;\n}\n\nfloat ufoSDF( vec3 point, vec3 center, float angle, float len ) {\n    vec2 o = vec2( cos( angle ), sin( angle ) );    \n    vec3 p = vec3( center.xy + len * o, center.z );\n    \n    float h = projectVector( p, center, point ) ;\n    vec3 q = p + .45 * h * normalize( point -  p );\n    \n    return ( length( point - q ) - len );\n}\n\nfloat sceneDistance( vec3 point ) {\n    float len = 0.77;\n    \n    float count = 4.;\n    vec3 o = vec3( -1.4 * count * 0.5, 0., 0. );\n    vec3 x = vec3( 7. / count, 0., 0. );\n    \n    float ufoA = 1.57 + 0.4 * cos( iTime * 2. );\n\n    float star = starSDF( point, o + 0. * x, len, len * .35 );\n    float cono = conoSDF( point, o + 1. * x, len, len * .5, iTime );\n    float box  = boxSDF(  point, o + 2. * x, vec3( len * .5 ) );\n    float ufo  = ufoSDF(  point, o + 3. * x, ufoA, len * .3 );\n\n    return min( star, min( cono, min( box, ufo ) )  );\n}\n\nfloat rayMarch( in vec3 origin, in vec3 direction ) {\n    float total = .0;\n    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {\n        vec3 point = origin + direction * total;\n                \n        float current = sceneDistance( point );\n        total += current;\n        if ( total > RAY_MARCH_TOO_FAR || current < RAY_MARCH_CLOSE ) {\n            break;\n        }\n    }\n    return total;\n}\n\nvec3 sceneNormal(vec3 p) {\n\tfloat d = sceneDistance(p);\n    vec2 e = vec2(RAY_MARCH_CLOSE, .0);\n    return normalize( d - vec3(\n        sceneDistance(p-e.xyy),\n        sceneDistance(p-e.yxy),\n        sceneDistance(p-e.yyx))\n    );\n}\n\nfloat pointLight( vec3 point, vec4 light ) {\n    vec3 normal = sceneNormal( point );\n    \n    vec3 towardLight = light.xyz - point;\n    float toLight = length( towardLight );\n    towardLight = normalize( light.xyz - point );\n\n    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );\n    \n    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    float d = rayMarch( lightStart, towardLight );\n    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );\n\n    float lightStrength = .7 + .3 * light.w / dot( toLight, toLight );  \n    return diffuse * lightStrength;\n}\n\nvec3 colorPoint( vec3 point ) {\n    vec4 light    = vec4( .0, 7., 2., 3. );\n    float ambient = 0.07;\n    float gamma   = 1.33;\n    \n    float lighting = pointLight( point, light );\n    lighting = ( 1. -  ambient ) * gamma * lighting;\n\n    // make the color\n    \n    vec3 red = vec3( 1., .0, .0 );\n\treturn vec3( red * ambient + red * lighting );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( 2. * gl_FragCoord.xy - iResolution.xy ) / iResolution.y; \n    \n    // camera settings\n    float t = 1.57 + 0.3 * iTime *0.;\n\tvec3 eye  = vec3( 4. * cos( t ), cos( t ) + sin( t ), 4. * sin( t ) );\n\tvec3 look = vec3( .0 );\n\tfloat roll = 0.;\n    float zoom = 2.;\n\n    // setup and use the camera\n    \n\tmat3 camera = makeCamera( eye, look, roll );\n    \n    vec3 direction = vec3( uv.xy, zoom );\n    direction = normalize( camera * direction );\n    \n    // do the ray marching (sphere tracing)\n\n    float distance_ = rayMarch( eye, direction );\n    float tooFar = step( RAY_MARCH_TOO_FAR, distance_ );   \n    vec3 point = eye + direction * distance_;\n    \n\t// the end\n    \n    vec3 background = vec3( .0, .0, .8 );\n    fragColor = vec4( mix( colorPoint( point ), background, tooFar ), 1. );\n}","name":"Image","description":"","type":"image"}]}