{"ver":"0.1","info":{"id":"3lt3DS","date":"1577629517","viewed":253,"name":"Art : Trammel of Archimedes","username":"Gijs","description":"Still kinda WIP. Basically a copy of a gif I saw which I am to lazy to dig up right now.","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","archimedes","trammel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GAMMA = 2.2;\nconst float EXPOSURE = 0.8;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 buf = texture(iChannel0,fragCoord.xy / iResolution.xy);\n    \n    vec3 col = buf.xyz*EXPOSURE;\n    col = pow(col,vec3(1./GAMMA)); \n    \n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat2 getRotation(float a){  \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(\n         c, s,\n        -s, c\n    ); \n}\n\nvec3 getSky(vec3 dir){\n    vec3 d = dir-SUN_VECTOR;\n    return SKY_COLOR + SUN_COLOR*min(SUN_SIZE/dot(d,d),1.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nconst vec3 n1 = normalize(vec3(1,0,-1));\nconst vec3 n2 = vec3(0.38268343236,0,-0.92387953251);\nconst vec3 n3 = vec3(0.19509032201,0,-0.9807852804);\n\nfloat distanceSpinny(vec3 p){\n    float dis = MAX_MARCH;\n    mat2 R1 = getRotation(iTime*SPEED);\n    mat2 R2 = getRotation(-iTime*SPEED*2.);\n    \n    p.xz *= R1; \n    p.x -= OFFSET;  \n    p.xz *= R2;\n    \n    float main = sdCappedCylinder(p-vec3(0,RADIUS*2.+3.,0),THICK,3.);\n    dis = min(dis,main);\n    \n    p.xz = abs(p.xz);\n    p -= 2.*min(0.,dot(p, n1)) * n1;\n    p -= 2.*min(0.,dot(p, n2)) * n2;\n    \n    p.x -= OFFSET;\n    \n    float ball = length(p)-RADIUS;\n    dis = min(dis,ball);\n    \n    float stick = sdCappedCylinder(p-vec3(0,1.5*RADIUS,0),THICK,RADIUS*.5);\n    dis = min(dis,stick);\n    \n    float joint = length(p-vec3(0,RADIUS*2.,0))-THICK;\n    dis = min(dis,joint);\n    \n    p.x += OFFSET*.5;\n    p.y -= RADIUS*2.;\n    float spoke = sdCappedCylinder(p.yxz,THICK,OFFSET*.5); \n    dis = min(dis,spoke);\n    \n    return dis;\n}\n\nfloat distanceCylinders(vec3 p){\n    float dis = MAX_MARCH;\n\n    p.xz = abs(p.xz);\n    p -= 2.*min(0.,dot(p, n1)) * n1;\n    p -= 2.*min(0.,dot(p, n2)) * n2;\n    p -= 2.*min(0.,dot(p, n3)) * n3;\n    \n    p.x -= OFFSET;\n\n    p = p.yxz;\n    dis = min(dis,sdCappedCylinder(p,RADIUS,OFFSET*2.+RADIUS));\n    \n    return dis;\n}\n\nfloat distanceBase(vec3 p){\n    float base = sdCappedCylinder(p+vec3(0,RADIUS*(1.-BASEH),0), BASEW , RADIUS*BASEH);\n    float cyl = distanceCylinders(p);\n    return max(base,-cyl);\n}\n\nfloat getDistance(vec3 p){\n    float dis = MAX_MARCH;\n    \n    dis = min(dis,p.y+1.);\n    dis = min(dis,distanceSpinny(p));\n    dis = min(dis,distanceBase(p));\n    \n\treturn dis;   \n    \n}\n\nvec3 getColor(vec3 p){\n    return vec3(.75);\n}\n\nvec3 getNormal(vec3 p, float eps){\n    eps = max(eps,1e-7);\n    vec2 k = vec2(1,-1);\n    vec2 d = k*eps;\n    return normalize( k.xyy*getDistance( p + d.xyy ) + \n                      k.yyx*getDistance( p + d.yyx ) + \n                      k.yxy*getDistance( p + d.yxy ) + \n                      k.xxx*getDistance( p + d.xxx ) );\n}\n\n\nvoid raymarch(in vec3 p, in vec3 d, float eps, inout int steps, inout float dis, inout float meps, inout float t){\n\tfor (;steps<MAX_STEPS;steps++){\n\t\tdis = getDistance(p + d*t);     \n        t += dis;\n        meps = abs(t)*eps;\n\n\t\tif(dis<=meps){\n            t -= (meps-dis);\n            break;\n        }\n        \n        if(t>=MAX_MARCH){\n            t = MAX_MARCH;\n            break;\n        }\n\t}\n}\n\nfloat softshadow(vec3 p, vec3 d, float k, float eps){\n    float res = 1.0;\n    float ph  = 1e20;\n    float t   = 2.*eps;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        float h = getDistance(p + d*t);\n        \n        if( h < eps ) return 0.0;\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        \n        if(t>MAX_MARCH) break;\n    }\n    \n    return res;\n}\n\nfloat occlusion(vec3 p, vec3 n, float t){\n    float o = 1.0;\n    float s = OCCLUSION_SPREAD*t;               \n    float k = OCCLUSION_INTENSITY/s;  \n    float d = 2.0*s;           \n    \n    for (int i = 0; i < OCCLUSION_SAMPLES; ++i) {\n        o -= (d - getDistance(p + n * d)) * k;\n        d += s;\n        k *= 0.5;\n    }\n    \n    return clamp(o, 0.0, 1.0);\n}\n\n\nvec3 raymarcher(vec3 p, vec3 d, float eps){ \n    int   steps = 0;\n    float dis = 0.;\n    float meps = 0.;\n    float t = 0.;\n    raymarch(p,d,eps,steps,dis,meps,t);\n    vec3 hitPos    = p + d*t;\n\n    if(dis<meps){\n\n        vec3 hitColor  = getColor(hitPos);\n        vec3 hitNormal = getNormal(hitPos,meps);\n        vec3 reflectDir = reflect(d,hitNormal);\n\n        float diffuse   = max(dot(hitNormal,SUN_VECTOR),0.);\n        float shadow    = diffuse>0. ? softshadow(hitPos + hitNormal*meps*2.,SUN_VECTOR,.1/SUN_SIZE,meps) : 0.;\n        float specular  = diffuse>0. && shadow>0. ? pow(max(dot(reflectDir,SUN_VECTOR),0.),32.) : 0.;\n        float occlusion = occlusion(hitPos,hitNormal,t);\n\n        vec3 c = hitColor*SUN_COLOR*diffuse*shadow + hitColor*SKY_COLOR*occlusion + SUN_COLOR*specular*shadow*.3;\n\n        return c;\n        \n    }else{\n\n        return getSky(d); \n\n    }   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float minResolution = min(iResolution.x,iResolution.y);\n    float eps = ZOOM*DETAIL/minResolution;\n    \n    vec3 col = vec3(0);\n    \n    for(int i=1; i<=AA; i++)\n    for(int j=1; j<=AA; j++){\n\t\tvec2 p = fragCoord.xy + vec2(i,j)/float(AA);\n        \n        vec2 uv = (p*2.-iResolution.xy)/minResolution*ZOOM;\n    \n        vec3 ori = cameraPosition;\n        vec3 dir = normalize(cameraDirection+uv.x*cameraRight+uv.y*cameraUp);\n\n        col += raymarcher(ori,dir,eps);\n    }\n    \n    col /= float(AA*AA);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float DETAIL    = 1.;\nconst int   MAX_STEPS = 128;\nconst float MAX_MARCH = 20.;\n\nconst vec3 cameraPosition = vec3(-3,3,2)*1.7;\nconst vec3 cameraLook = vec3(0,-.8,0);\nconst vec3 cameraDirection = normalize(cameraLook-cameraPosition);\nconst vec3 cameraRight = normalize(cross(cameraDirection,vec3(0,1,0)));\nconst vec3 cameraUp = -cross(cameraDirection,cameraRight);\n\nconst float ZOOM = .33;\n\nconst vec3  SKY_COLOR  = vec3(.45,.56,1.);\nconst vec3  SUN_VECTOR = normalize(vec3(1,1.2,.8));\nconst vec3  SUN_COLOR  = vec3(1.);\nconst float SUN_SIZE   = 0.0001;\n\nconst float OCCLUSION_SPREAD    = 0.01;\nconst float OCCLUSION_INTENSITY = .1;\nconst int   OCCLUSION_SAMPLES   = 3;\n\nconst float RADIUS = .35;\nconst float OFFSET = 1.5;\nconst float BASEW = (OFFSET*2.+RADIUS)*.8;\nconst float BASEH = 0.4; //percentage\nconst float THICK = .02;\nconst float SPEED = .7;\n\nconst int AA = 1;//sqaure root of the samples per pixel for anti-aliasing","name":"Common","description":"","type":"common"}]}