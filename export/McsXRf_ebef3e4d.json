{"ver":"0.1","info":{"id":"McsXRf","date":"1705539645","viewed":78,"name":"Spinning Pill","username":"killn","description":"simple sdf example","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","tweening","plll"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// rotating pill via ray march\n// based on https://www.shadertoy.com/view/fdjGRD \n// and      https://iquilezles.org/articles/distfunctions/\n#define PI 3.14159265\n#define MAX_MARCHING_STEPS 50\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n\nconst vec2 EPSILON = vec2(1.0, -1.0) * 0.0005;\n\n// colors for upper and lower half of pill\nconst vec3 diffuse_upper = vec3 (0.129, 0.729, 0.698);\nconst vec3 diffuse_lower = vec3 (0.9, 0.9, 0.9);\n\nstruct Surface {\n    float sd; // distance value\n    vec3 col; // material color at position\n};\n\n// rotation matrix around Y axis\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// cubic tweening (same as ease-in-out in CSS)\nfloat easeInOutCubic(float x) {\n    return x < 0.5 ? 4.0 * x * x * x : 1.0 - pow(-2.0 * x + 2.0, 3.0) / 2.0;\n}\n\nSurface sdfCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset, mat3 transform )\n{\n  p = (p - offset) * transform;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  \n  \n  float interpolator = smoothstep(-0.004, 0.004, h - 0.5);\n  vec3 diff_col = mix(diffuse_lower, diffuse_upper, interpolator);\n  \n  return Surface(length( pa - ba*h ) - r, diff_col );\n}\n\nSurface sdScene(vec3 p) {\n  return sdfCapsule(p, vec3(-0.15, -0.5, -0.15), vec3(0.15, 0.5, 0.15), 0.41, vec3(0, 0., -3), \n  // tick is repeated with float mod, then clamped to add a little delay between spins\n  // lastly, the rotation is transformed with tween to generate ease-in-out effect\n  rotateY(easeInOutCubic(clamp(mod(1.15 * iTime, 1.5), 0.0, 1.0)) * 2.0 * PI));\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface step;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    step = sdScene(p);\n    depth += step.sd;\n    if (step.sd < PRECISION || depth > end) break;\n  }\n  \n  step.sd = depth;\n \n  return step;\n}\n\nvec3 estimateNormal(in vec3 p) {\n    \n    return normalize(\n      EPSILON.xyy * sdScene(p + EPSILON.xyy).sd +\n      EPSILON.yyx * sdScene(p + EPSILON.yyx).sd +\n      EPSILON.yxy * sdScene(p + EPSILON.yxy).sd +\n      EPSILON.xxx * sdScene(p + EPSILON.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.95, 0.95, 0.95);\n\n  vec3 col = backgroundColor;\n  vec3 ray_origin = vec3(0, 0, 0); // ray origin == camera position\n  vec3 ray_direction = normalize(vec3(uv, -1)); // view direction\n\n  Surface hit = rayMarch(ray_origin, ray_direction, MIN_DIST, MAX_DIST);\n\n  if (hit.sd <= MAX_DIST) {\n    vec3 p = ray_origin + ray_direction * hit.sd;\n    vec3 normal = estimateNormal(p);\n    vec3 lightPosition = vec3(3, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // blinn-phong lighting model (no energy conservation)\n    vec3 halfVec = normalize(lightDirection - p);\n    float diffuse = clamp(dot(normal, lightDirection), 0.3, 1.);\n    float specular = pow( max(dot(halfVec, normal), 0.0), 30.0);\n\n    col = diffuse * hit.col + 0.2 * specular * vec3(1.0, 1.0, 1.0) + backgroundColor * .1; // compose shading color\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}