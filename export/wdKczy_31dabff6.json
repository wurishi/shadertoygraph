{"ver":"0.1","info":{"id":"wdKczy","date":"1603664335","viewed":667,"name":"[inktober20]Steel Dogs","username":"iY0Yi","description":"A shader drawing for inktober 2020 day18.\n#inktober2020day18","likes":30,"published":3,"flags":32,"usePreview":1,"tags":["trap","comic","inktober2020"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////////////\n//  .--. .-----. .--.  .--. .-.     .---.  .--.  .--.  .--.                             //\n// : .--'`-. .-': .--': .--': :     : .  :: ,. :: .--': .--'                            //\n// `. `.   : :  : `;  : `;  : :     : :: :: :: :: : _ `. `.                             //\n//  _`, :  : :  : :__ : :__ : :__   : :; :: :; :: :; : _`, :                            //\n// `.__.'  :_;  `.__.'`.__.':___.'  :___.'`.__.'`.__.'`.__.'                            //\n//                                                                                      //\n//                                                                                      //\n//  [inktober20]Steel Dogs by iY0Yi                                                     //\n//  https://www.shadertoy.com/view/wdKczy                                               //\n//                                                                                      //\n//  Created by Atsushi Hashimoto 2020                                                   //\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n\n//#define DEBUG\n\nvec3 readAlbedo(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack(data.y);\n}\n\nvec3 readNormal(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).xyz*2.-1.;\n}\nvec3 readSharpenNormal(in vec2 fragCoord, float strength)\n{\n    vec3 res =\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).x).xyz*2.-1.) *   9. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).x).xyz*2.-1.) *  -1.\n    ;\n    return mix((unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).x).xyz*2.-1.), res , strength);\n}\n\nfloat readSpecular(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.x;\n}\nfloat readSharpenSpecular(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).x *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).x *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).x, res , strength);\n}\n\nfloat readDiffuse(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.y;\n}\nfloat readSharpenDiffuse(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).y *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).y *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).y, res , strength);\n}\n\nfloat readAO(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z);\n    return spec_diffuse_ao.z;\n}\n\nfloat readShadow(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).w;\n}\n\nfloat readDepth(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return data.w;\n}\n\nfloat palettize(float v)\n{\n    return saturate(floor(v*6.)/5.);\n}\n\nfloat dithering(float v, vec2 fragCoord)\n{\n    v=pow(v, 4.);\n\n    float stride = .1;\n    vec2 p = fragCoord;\n\n    p = mod(p.xx + vec2(p.y, -p.y), vec2(stride));\n    float res=0.;\n    vec2 coords = fragCoord;\n\n    float angle = dot(readSharpenNormal(fragCoord, 1.), vec3(0,0,1));\n\n    coords.xy*= mat2(cos(angle*PI+vec4(0,11,33,0)));\n    coords.y *= .75+.25*hash12(p);\n    float rand_ditherVal = fbm(coords*.75, 2);\n    const float paletteDist = 1.15;\n    res=v + (rand_ditherVal - .5) * paletteDist;\n    res=smoothstep(0.1,1.,res);\n    res=palettize(res);\n\n    return res;\n}\n\nfloat checkEdge(vec3 norz1, vec3 norz2)\n{\n    vec2 diffNor = abs(norz1.xy - norz2.xy);\n    float diffZ = pow(abs(norz1.z - norz2.z), 8.5) * 1.8;\n    float a = 1.-smoothstep(.5, .91, diffNor.x + diffNor.y);\n    float b = 1.-smoothstep(.5, .95, diffZ);\n    return smoothstep(0., .01, a*b);\n}\nfloat getEdge(vec2 fragCoord)\n{\n    vec2 coord = fragCoord;\n    if(all(lessThan(coord, iResolution.xy-2.)))\n    coord += u2s(noise(coord*.05))*1.;\n    float radius = .6;\n    \n    vec3 offset = vec3(1, -1, 0) * radius;\n    float edge = 1.0;\n    edge *= checkEdge(readNormal(coord+offset.xx), readNormal(coord+offset.yy));\n    edge *= checkEdge(readNormal(coord+offset.xy), readNormal(coord+offset.yx));\n    edge *= checkEdge(readNormal(coord+offset.zy), readNormal(coord+offset.zx));\n    edge *= checkEdge(readNormal(coord+offset.yz), readNormal(coord+offset.xz));\n    return edge;\n}\n\nfloat getShadowEdge( vec2 fragCoord )\n{\n    vec2 coord = fragCoord;\n    float sha = readShadow(coord);\n    sha -= .5;\n    sha = abs(sha);\n    sha = smoothstep(.1,.2,sha);\n    return sha;\n}\n\n// https://www.shadertoy.com/view/3ssSz2\nfloat originalSigmoidContrast(float color, float contrast, float mid)\n{\n    // rescaling contrast to more easily compare with optimized version:\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n\n    // original version:\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\n\n// https://www.shadertoy.com/view/MdjBRy\nvec3 saturation( vec3 color, float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n\n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n\n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n\n    return mat3( red, green, blue) * color;\n}\n\nfloat getDottedShadow(vec2 fragCoord)\n{\n    vec2 uv = fragCoord;\n    uv *= mat2(cos(.8+vec4(0, 11, 33, 0)));\n    uv = mod(uv*.225, 1.);\n    float res = 0.;\n    float shadow = readShadow(fragCoord);\n    shadow = max(.65,shadow*.85) + .35*readAO(fragCoord);\n    shadow = 1. - shadow;\n    res = smoothstep(shadow, shadow+1., pow(length(uv-.5), 4.));\n    res = smoothstep(.0, .2, pow(res, .05));\n    return res;\n}\n\n\nfloat hatching(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n\n    vec3 n = readNormal(fragCoord);\n    if(length(n)<.1)\n        return 1.;\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSharpenDiffuse(fragCoord, 2.);\n    shading = mix(shading, (1.-shading)*.3+.7*readAO(fragCoord), 1.-readShadow(fragCoord));\n    shading *= 1.35;\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n\n    shading = originalSigmoidContrast(shading*.95+.05*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\n\nfloat getHatching(vec2 fragCoord)\n{\n    float ln = 1.;\n        ln*= pow(hatching(fragCoord, 4., .6, .6, .8, true), 10.);\n        ln*= pow(hatching(fragCoord, 3.5, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatching(fragCoord, 3.5, .4, -1.4, 1.4, false), 50.5);\n    return ln;\n}\n\nfloat hatchingSpecular(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n\n    vec3 n = readNormal(fragCoord);\n    if(length(n)<.1)\n        return -1.;\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSpecular(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading *= 1.5;\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n    \n    shading = originalSigmoidContrast(shading*.98+.03*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    shading = 1.-saturate(shading*.55);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\nfloat getHatchingSpecular(vec2 fragCoord)\n{\n    float ln = 1.;\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, .4, -1.4, 1.4, false), 50.5);\n    return 1.-ln;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(.8, .77, .7);\n\n    float shading = readDiffuse(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading = shading*.9+.1*readAO(fragCoord);\n\n    float contrast = 8.8;\n    float midpoint = .5;\n    shading = originalSigmoidContrast(shading, contrast, midpoint);\n    shading = saturate(shading);\n    if(readDepth(fragCoord)<.5)\n    {\n        col*=saturate(dithering(shading, fragCoord));\n        col*=.2+.8*shading;\n    }\n\n    col+=fbm(fragCoord*.5, 3)*.15;\n    col*= getHatching(fragCoord);\n    col *= getEdge(fragCoord);\n    col *= getShadowEdge(fragCoord);\n    col *= getDottedShadow(fragCoord);\n    if(readShadow(fragCoord)<.2)\n    col += (1.-getEdge(fragCoord))*.1;\n    col+=.05*dithering((smoothstep(.95,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.97,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.99,1.,shading)), fragCoord);\n\n    col *= .4 + .6*(readShadow(fragCoord)*.8+.2*readAO(fragCoord));\n    col *= .2 + .8*shading;\n\tcol += (1.-dithering(pow(abs(dot(vec3(0,0,1), readNormal(fragCoord))), 2.)*.5, fragCoord))*.25;\n    \n    //st_assert( pow(abs(dot(vec3(0,0,1), readNormal(fragCoord))), 1.5) > 0.5, 0 );\n    \n    col *= dithering(pow(saturate(readAO(fragCoord)), 1.5), fragCoord*2.);\n\n    vec3 albedo = readAlbedo(fragCoord);\n    \n    if(!(distance(albedo,AMB_COL)<.01))\n        col*=albedo;\n\n    float spec = readSharpenSpecular(fragCoord, 1.5)*readShadow(fragCoord);\n    if(spec>.1)\n    col+=dithering(spec, fragCoord);\n    col+=saturate(getHatchingSpecular(fragCoord));\n    if(distance(albedo,AMB_COL)<.1)\n        col = saturation(albedo, 2.5)*.075;\n    col *= (readShadow(fragCoord))*(getEdge(fragCoord));\n    \n    if(distance(albedo,MAT_GROUND)>.1)\n    col += (1.-readShadow(fragCoord))*(1.-getEdge(fragCoord))*.0001;\n    col*= dithering(noise(fragCoord*.095)+noise(fragCoord*.07)+.7, fragCoord);\n    col+= (1.-dithering((1.-noise(fragCoord*.08)*noise(fragCoord*.06))+.8, fragCoord));\n\tcol = saturation(col, 5.5);\n    col = pow(col, vec3(.25));\n    fragColor = vec4(col, 1);\n\n#ifdef DEBUG\n    if(iFrame==2)\n    fragColor.xyz = vec3(readDiffuse(fragCoord));\n    if(iFrame==3)\n    fragColor.xyz = vec3(readShadow(fragCoord));\n    if(iFrame==4)\n    fragColor.xyz = vec3(readSharpenSpecular(fragCoord, 1.5));\n    if(iFrame==5)\n    fragColor.xyz = vec3(readDepth(fragCoord));\n    if(iFrame==6)\n    fragColor.xyz = vec3(readAO(fragCoord));\n    if(iFrame==7)\n    fragColor.xyz = readAlbedo(fragCoord);\n    if(iFrame==8)\n    fragColor.xyz = readNormal(fragCoord)*.5+.5;\n    if(iFrame==9)\n    fragColor.xyz = vec3(getEdge(fragCoord));\n    if(iFrame==10)\n    fragColor.xyz = vec3(getShadowEdge(fragCoord));\n    if(iFrame==11)\n    fragColor.xyz = vec3(getDottedShadow(fragCoord));\n    if(iFrame==12)\n    fragColor.xyz = vec3(getHatching(fragCoord));\n    if(iFrame==13)\n    fragColor.xyz = vec3(getHatchingSpecular(fragCoord));\n#endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// BLU_GUI\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nuniform float blu1f0;\nuniform float blu1f1;\nuniform float blu1f2;\nuniform float blu1f3;\nuniform float blu1f4;\nuniform float blu1f5;\n\n// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24\n#define ZERO min(0,iFrame)\n#define CHARM min(0,iFrame) /* faster compilation... */\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash / Noise by Anonymous:\n// I forgot where I found this...\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n            mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n            mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f = 0.5000 * noise(p);\n    p *= 2.01;\n    f += 0.2500 * noise(p);\n    p *= 2.02;\n    f += 0.1250 * noise(p);\n\n    return f;\n}\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define SDF_RENDER_SCALE float(1)\n#define INV_SDF_RENDER_SCALE (1./SDF_RENDER_SCALE)\n#define MIN_DIST 0.0010000000474974513\n#define MAX_DIST 30.0\n#define ITERATION 300\n#define MAT_VOID vec3(-1)\n#define MAT_METAL vec3(0.8514)\n#define MAT_GROUND vec3(0.0021, 0.0025, 0.0014)*.1\n#define MAT_BLADE vec3(0.0585, 0.0628, 0.0671)\n\n#define AMB_COL vec3(0.0470, 0.0465, 0.0445)*5.\n#define AMB_STRENGTH 0.2000\n#define FOG_COL vec3(0.0000, 0.0000, 0.0000)\n#define FOG_START 1.0000\n\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\n\n//Animation\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ID_Camera 0\n#define ID_sdLight001 1\n#define ID_sdLight002 2\n\n\n\n// Read vec3(10bit/float) from a float...\nconst float THRESHOLD = .92;\n// Read vec3(10bit/float) from a float. Although can't say so smart...\nvec3 unpackSnorm3x10(uint x)\n{\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(1), vec3(-1), greaterThanEqual(sig,uvec3(1)));\n    vec3 fmag = vec3(mag);\n    return fsig * fmag / 511.0/THRESHOLD;\n}\nfloat packSnorm3x10(vec3 x) {\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(vec3(0),sign(x))));\n    x = clamp(x*THRESHOLD,-THRESHOLD, THRESHOLD) * 511.0;\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig << 9 | mag;\n    return float((r.x << 22) | (r.y << 12) | (r.z << 2));\n}\n\nuint packSnorm3x10_2(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10_2(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\n#define pack(x) uintBitsToFloat(packSnorm3x10_2(x))\n#define unpack(x) unpackSnorm3x10_2(floatBitsToUint(x))\n\nuint packSnorm4x8(vec4 x) {\n    x = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackSnorm4x8(uint x) {\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n#define pack4(x) uintBitsToFloat(packSnorm4x8(x))\n#define unpack4(x) unpackSnorm4x8(floatBitsToUint(x))\n\n#define pack_bl(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_bl(x) unpackSnorm3x10(floatBitsToUint(x))\nvoid readFrameTexCamera3x10(sampler2D tex, int id, int f, inout vec3 pos, inout vec4 quat, inout float fov, in vec3 tra_scl, in vec4 quat_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    pos = unpack_bl(anm.x) * tra_scl;\n\n    quat = vec4(0);\n    quat.xyz = unpack_bl(anm.y)*quat_scl.xyz;\n    vec3 qw_fov_zero = unpack_bl(anm.z);\n    quat.w = qw_fov_zero.x*quat_scl.w;\n\n    fov = qw_fov_zero.y;\n}\n\nvoid readFrameTex3x10(sampler2D tex, int id, int f, inout vec3 pos, inout vec3 rot, in vec3 tra_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    pos = unpack_bl(anm.x) * tra_scl;\n    rot = unpack_bl(anm.y).xyz * PI;\n}\n\nvoid readFrameTexLight3x10(sampler2D tex, int id, int f, inout vec3 dir, inout vec3 col, inout float clip_start, inout float clip_end, inout float softness, in vec3 shadow_props_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    dir = unpack_bl(anm.x).xzy;\n    col = unpack_bl(anm.y);\n    vec3 shadow = unpack_bl(anm.z);\n    clip_start = shadow.x*shadow_props_scl.x;\n    clip_end = shadow.y*shadow_props_scl.y;\n    softness = shadow.z*shadow_props_scl.z;\n}\n\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 ro = vec3(0), rd = vec3(0);\nvec3 gp;\nvec3 col = vec3(0);\nvec2 uv=vec2(0);\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3  Cam_pos;\nvec4  Cam_quat;\nfloat Cam_fov;\nvec3  L0_dir;\nvec3  L0_col;\nfloat L0_str;\nfloat L0_end;\nfloat L0_sft;\n\nvoid init()\n{\n\tCam_pos = vec3(-4.3957,0.2853,0.5985);\n\tCam_quat = vec4(0.4832,-0.5162,-0.5162,0.4832);\n\tCam_fov = 0.19;\n    L0_dir = normalize(vec3(-0.5666,0.0000,0.8240));\n\tL0_col = vec3(1.0000,1.0000,1.0000);\n\tL0_str = 0.0500;\n\tL0_end = 30.0000;\n\tL0_sft = 50.0000;\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid camera(vec2 uv)\n{\n    vec3 dir = quat_rotate(Cam_quat, vec3(0,0,-1)).xzy;\n    vec3 up = quat_rotate(Cam_quat, vec3(0,1,0)).xzy;\n    vec3 pos = Cam_pos.xzy;\n    float fov = Cam_fov;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\n\nfloat sdPlane(in vec3 p){\n    return p.y;\n}\n\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\n\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n\n    // iq:\n    //float h = max(r-abs(a-b),0.0);\n    //return min(a, b) - h*h*0.25/r;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\n\nfloat fOpSubstraction(in float a,in float b)\n{\n    return max(-a, b);\n}\n\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b)\n{\n    float res = max(-a.x, b.x);\n    return (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\n\nfloat fOpIntersectionLinear(float a, float b, float r)\n{\n    return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n\nfloat fOpSubstractionLinear (float a, float b, float r)\n{\n    return fOpIntersectionLinear(b, -a, r);\n}\n\n\nfloat fOpIntersection(in float a,in float b)\n{\n    return max(a, b);\n}\n\n\nfloat pMirror(float x, float k){\n    return sqrt(x * x + k);\n}\n\n\nvoid pElongate(inout float p, in float h )\n{\n    p = p-clamp(p,-h,h);\n}\n\n\n//Based on \"bend\" by las:\n//https://www.pouet.net/topic.php?which=7931&page=5\nvec2 pBend(vec2 p, float k)\n{\n    //float r = 1.0/max(abs(k),1e-3);\n    //vec2 d= vec2(p.x, r-p.y*(step(0.0,k)*2.0-1.0));\n    //return vec2(atan(d.x,d.y)*r,length(d)-r);\n    if(k==0.) return p;\n    float r = 1./k;\n    float sgn = sign(k);\n    vec2 d = vec2(p.x, (r-p.y)*sgn);\n\n    float a = -atan(d.x, d.y);\n    vec2 b = vec2(sin(a), cos(a));\n    return sgn*vec2(-b.y*d.x-b.x*d.y, b.x*d.x-b.y*d.y)+vec2(a*r,r);\n}\n\n\n// Based on \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions )\n{\n#if 0\n    float r = round(p_el/s);\n    float half_num = (repetitions-1.)/2.;\n    r = clamp(r, -half_num, repetitions-half_num);\n    p_el-=s*r;\n#else\n    repetitions -= 1.;\n    float offset = 1.-step(.5, mod(repetitions, 2.));\n    p_el += s*.5*offset;\n    float r = round(p_el/s);\n    float half_rep = ceil(repetitions/2.);\n    r = clamp(r, -half_rep, repetitions-half_rep);\n    p_el-=s*r;\n#endif\n}\n\n\n// map: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sdSpring(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.5000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp001_002 = p;\n\tcp001_002.xyz += vec3(-0.0000, -0.2653, -0.0000);\n\tcp001_002.xyz = rot(cp001_002, vec3(-0.0000, 0.0000, -0.0000));\n\t{\n\t\tvec3 q = cp001_002;\n\t\tR(q.xz, PI*.5);\n\t\tq.y+= (atan(q.x, q.z)/PI)*.0125*(.3/.25);\n\t\tcp001_002 = q;\n\t}\n\tpRepLimited(cp001_002.y, 0.0300, 23.);\n\n\td = fOpUnion(sdTorus(rot(cp001_002+vec3(-0.0000, -0.0000, -0.0000), vec3(0.0000, 0.0000, -0.0000)), vec2(0.0385, 0.0115)), d);\n\td = fOpUnion(sdCappedCylinder(rot(p+vec3(-0.0379, -0.5945, -0.0953), vec3(-1.5708, 0.0000, 1.5708)), vec2(0.0117, 0.0965))-0.0000, d);\n\td = fOpUnion(sdConeSection(rot(p+vec3(-0.0373, -0.5949, -0.2156), vec3(-1.5708, 0.0000, -0.0000)), 0.0235, 0.0120, 0.0000)-0.0000, d);\n\tres = v4OpUnion(vec4(d,MAT_METAL), res);\n\treturn res;\n}\n\nvec4 sdBolt(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.05000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    p.x+=.005;\n\t{\n        vec3 tp = p+vec3(-0.0129, -0.0000, 0.0000);\n        vec3 trp = rot(p+vec3(-0.0129, -0.0000, 0.0000), vec3(0.0000, 1.5708, -0.0000));\n        vec3 dim = vec3(0.0273, 0.0273, 0.0123);\n        float td = MAX_DIST;  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        vec2 h = dim.xz;\n        trp = abs(trp);\n        trp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n        vec2 d2 = vec2(length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x), trp.z-h.y );\n        td = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n        d=fOpUnion(td, d);\n\t}\n\t{\n        vec3 tp = p+vec3(-0.0312, -0.0000, 0.0000);\n        vec3 trp = rot(p+vec3(-0.0312, -0.0000, 0.0000), vec3(0.0000, 1.5708, -0.0000));\n        vec3 dim = vec3(0.0247, 0.0247, 0.0111);\n        float td = MAX_DIST;  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        vec2 h = dim.xz;\n        trp = abs(trp);\n        trp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n        vec2 d2 = vec2(length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x),trp.z-h.y );\n        td = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n\t\td=fOpSubstraction(td, d);\n\t}\n    \n\td = fOpSubstraction(sdBox(rot(p+vec3(-0.0681, -0.0000, -0.0000), vec3(0.0000, 0.7854, 0.0000)), vec3(0.0463, 0.0049, 0.0463))-0.0000, d);\n    d = fOpSubstraction(sdBox(rot(p+vec3(-0.0681, -0.0000, -0.0000), vec3(1.5708, 0.0000, -0.7854)), vec3(0.0463, 0.0049, 0.0463))-0.0000, d);\n\td = fOpUnionSmooth(sdCappedCylinder(rot(p+vec3(-0.0035, -0.0000, -0.0000), vec3(-0.0000, 0.0000, 1.5708)), vec2(0.0306, 0.0031))-0.0000, d, 0.0025);\n\t\n\td = fOpIntersection(sdEllipsoid(rot(p+vec3(-0.0076, -0.0000, -0.0000), vec3(-0.0000, 0.0000, -0.0000)), vec3(0.0295, 0.0347, 0.0347)), d);\n\tres = v4OpUnion(vec4(d,MAT_BLADE), res);\n\treturn res;\n}\n\nfloat bladeOffset = 0.;\n\nvec4 sdTBlade(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, -0.2500)), bsr=0.3000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp002_003 = p;\n\tcp002_003.xyz += vec3(0.0000, -0.0000, -0.0000);\n\tcp002_003.xyz = rot(cp002_003, vec3(-0.0000, 0.0000, -0.0000));\n\tvec3 cp002_003_mir0_Pos = max(vec3(0), sign(cp002_003));\n\tvec3 cp002_003_mir0_Neg = max(vec3(0),-sign(cp002_003));\n\tcp002_003.x = pMirror(cp002_003.x, 0.0000);\n\n\tvec3 cp002_001 = cp002_003;\n\tcp002_001.xyz += vec3(0.0000, -0.0000, -0.5381);\n\tcp002_001.xyz = rot(cp002_001, vec3(0.0000, 3.1416, -0.0000));\n\t{\n\t\tvec2 q = cp002_001.xz;\n\t\tfloat k = 112.601*.025;\n\t\tfloat s0=0., sb=-44.5854*.025, se=22.3006*.025;\n\t\tfloat r = 1./k, ak = abs(k), sk = sign(k);\n\t\tvec2 d = vec2(q.x - s0, (r - q.y) * sk);\n\t\tfloat a = -atan(d.x, d.y);\n\t\tfloat b = clamp(a, ak*(sb-s0), ak*(se-s0));\n\t\tfloat s = b*r+s0;\n\t\tvec2 c = vec2(sin(b), cos(b));\n\t\tq.xy = mix(vec2(s, length(d) - abs(r)), sk*(c.yx*d.xx*vec2(-1.,1) - c.xy*d.yy) + vec2(s, r), abs(sign(a-b)));\n\t    cp002_001.xz = q;\n\t}\n\tvec3 cp001_003 = cp002_001;\n\tcp001_003.xyz += vec3(-0.0453, -0.0000, 0.0000);\n\tcp001_003.xyz = rot(cp001_003, vec3(0.0000, 0.0000, -0.0000));\n\t{\n\t\tvec3 q = cp001_003;\n\t\tq.x-=bladeOffset;\n\t\tcp001_003 = q;\n\t}\n\tpRepLimited(cp001_003.x, 0.1500, 7.);\n\tres = v4OpUnion(sdBolt(rot(cp002_003+vec3(-0.4282, -0.0000, -0.0000), vec3(0.0000, 0.0000, -0.0000))), res);\n\td = fOpUnion(sdBox(rot(cp001_003+vec3(-0.0000, 0.0321, -0.0000), vec3(0.0000, 0.0000, -0.0000)), vec3(0.1974, 0.0624, 0.0100))-0.0000, d);\n\td = fOpSubstraction(sdBox(rot(cp002_001+vec3(-0.7382, 0.1619, -0.0616), vec3(0.0000, 3.1416, -0.0000)), vec3(0.1000, 0.1000, 0.1000))-0.0000, d);\n\td = fOpUnion(sdBox(rot(cp002_003+vec3(-0.3544, 0.0177, -0.0892), vec3(0.0000, 1.5708, 0.0000)), vec3(0.0891, 0.0483, 0.0100))-0.0000, d);\n\td = fOpUnion(sdBox(rot(cp001_003+vec3(0.0000, -0.0046, 0.0000), vec3(0.0000, 0.0000, 0.7854)), vec3(0.0702, 0.0702, 0.0100))-0.0000, d);\n\td = fOpUnion(sdBox(rot(p+vec3(-0.3307, 0.0164, -0.1383), vec3(-0.0000, 0.0000, 1.5708)), vec3(0.0077, 0.0313, 0.0661))-0.0000, d);\n\td = fOpUnion(sdCappedCylinder(rot(cp002_003+vec3(-0.0000, -0.0000, -0.0000), vec3(-0.0000, 0.0000, 1.5708)), vec2(0.0153, 0.4240))-0.0000, d);\n\td = fOpUnion(sdBox(rot(p+vec3(-0.3071, 0.0380, -0.1383), vec3(-0.0000, 0.0000, -0.0000)), vec3(0.0077, 0.0204, 0.0661))-0.0000, d);\n\td = fOpUnion(sdCappedCylinder(rot(cp002_003+vec3(-0.3561, -0.0000, -0.0000), vec3(-0.0000, 0.0000, 1.5708)), vec2(0.0630, 0.0100))-0.0000, d);\n\tres = v4OpUnion(vec4(d,MAT_BLADE), res);\n    \n    res.x += smoothstep(.5,.6,fbm(cp002_001.xy*70., 3))*.00075;\n    res = v4OpUnion(sdSpring(rot(p+vec3(0.2645, -0.0000, -0.0000), vec3(-0.0000, 0.0000, 1.5708))), res);\n\treturn res;\n}\n\n\nvec4 sdChainRing(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.0500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp003 = p;\n\tpElongate(cp003.z, 0.0300);\n\n\td = fOpUnion(sdTorus(cp003, vec2(0.0281, 0.0113)), d);\n\tres = v4OpUnion(vec4(d,MAT_BLADE), res);\n\treturn res;\n}\n\n\nvec4 sdGround(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.5000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp001_001 = p;\n\tcp001_001.xyz += vec3(-0.0000, -0.0733, -0.0000);\n\tcp001_001.xyz = rot(cp001_001, vec3(-0.0000, 0.0000, -0.0000));\n\t{\n\t\tvec3 q = cp001_001;\n\t\tfloat dist = smoothstep(.5,0.,length(q.xz));\n\t\tq.y+=fbm(p.xz*5., 4)*.1;\n\t\tcp001_001 = q;\n\t}\n\td = fOpUnion(sdPlane(rot(cp001_001+vec3(-0.0000, -0.0000, -0.0000), vec3(0.0000, 0.0000, -0.0000))), d);\n\tres = v4OpUnion(vec4(d,MAT_GROUND), res);\n\treturn res;\n}\n\n\nvec4 sdTrap(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.3750;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp002_002 = p;\n\tcp002_002.xyz += vec3(-0.0000, -0.1073, -0.0000);\n\tcp002_002.xyz = rot(cp002_002, vec3(0.0000, 1.5708, -0.0000));\n\tpElongate(cp002_002.x, 0.1000);\n\tcp002_002.xy = pBend(cp002_002.xy, -2.0000);\n\n\tvec3 cp004 = p;\n\tcp004.xyz += vec3(-0.0000, -0.0000, -0.0000);\n\tcp004.xyz = rot(cp004, vec3(-0.0000, 0.0000, -0.0000));\n\tvec3 cp004_mir0_Pos = max(vec3(0), sign(cp004));\n\tvec3 cp004_mir0_Neg = max(vec3(0),-sign(cp004));\n\tcp004.z = pMirror(cp004.z, 0.0000);\n\tvec3 cp004_mir1_Pos = max(vec3(0), sign(cp004));\n\tvec3 cp004_mir1_Neg = max(vec3(0),-sign(cp004));\n\tcp004.x = pMirror(cp004.x, 0.0000);\n\n\td = fOpUnion(sdBox(rot(cp004+vec3(-0.3973, -0.0110, -0.0000), vec3(0.0000, 0.0000, -0.0000)), vec3(0.0150, 0.0837, 0.1564))-0.0000, d)+smoothstep(.5,.6,fbm(cp004.yz*70., 3))*.00075;\n\td = fOpUnion(sdBox(rot(cp004+vec3(-0.1806, 0.0611, -0.0454), vec3(-1.5708, -1.5708, 0.0000)), vec3(0.1109, 0.2186, 0.0122))-0.0000, d);\n    float disp = smoothstep(.5,.6,fbm(cp002_002.xy*70., 3))*.00075;\n\td = fOpUnion(sdCappedCylinder(rot(cp002_002+vec3(-0.0000, -0.0000, -0.0000), vec3(0.0000, 0.0000, -0.0000)), vec2(0.1872, 0.0050))-disp, d);\n\tres = v4OpUnion(vec4(d,MAT_BLADE), res);\n\td = MAX_DIST;\n\n    const vec3 bloc[2] = vec3[](\n\t\tvec3(-0.0000, -0.0226, -0.0700),\n\t\tvec3(-0.0000, -0.0226, 0.0700)\n\t\t);\n\tconst vec3 brot[2] = vec3[](\n\t\tvec3(1.1461, 0.0000, -0.0000),\n\t\tvec3(1.1461, 3.1416, 0.0000)\n\t\t);\n\tconst float offsets[2] = float[](4.1346*0.025, 1.13058 *0.025);\n\tfor(int i = ZERO; i < 2+CHARM; i++){\n        bladeOffset = offsets[i];\n\t\tres = v4OpUnion(sdTBlade(rot(p+bloc[i], brot[i])), res);\n\t}\n    \n\td = fOpUnion(sdBox(rot(cp004+vec3(-0.3973, -0.0931, -0.1759), vec3(-0.7854, 0.0000, -0.0000)), vec3(0.0198, 0.0500, 0.1564))-0.0000, d);\n    \n\tres = v4OpSubstraction(vec4(d,MAT_BLADE), res);\n    \n    \n    \n\treturn res;\n}\n\n\nvec4 sdChain(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=0.5000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\n\tconst vec3 cloc[8] = vec3[](\n\t\tvec3(0.0551, -0.0006, 0.0188),\n\t\tvec3(-0.0127, 0.0058, 0.0683),\n\t\tvec3(-0.0997, 0.0091, 0.0683),\n\t\tvec3(-0.2047, 0.0155, 0.0683),\n\t\tvec3(-0.2816, -0.0147, 0.0683),\n\t\tvec3(-0.3866, -0.0082, 0.0683),\n\t\tvec3(-0.4667, -0.0047, 0.0683),\n\t\tvec3(-0.5632, 0.0021, 0.0683)\n\t\t);\n\tconst vec3 crot[8] = vec3[](\n\t\tvec3(0.8681, -0.0836, -1.4726),\n\t\tvec3(3.0044, -1.5708, -0.0000),\n\t\tvec3(1.5708, 0.0000, -1.6083),\n\t\tvec3(3.0044, -1.5708, -0.0000),\n\t\tvec3(1.5708, 0.6626, -1.6083),\n\t\tvec3(1.4310, -0.2474, -1.5783),\n\t\tvec3(1.5708, 0.6626, -1.6083),\n\t\tvec3(1.3961, -1.3752, -1.6083)\n\t\t);\n\n\tfor(int i = ZERO; i < 8+CHARM; i++)\n\tres = v4OpUnion(sdChainRing(rot(p+cloc[i], crot[i])), res);\n\n\treturn res;\n}\n\n\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n\tconst vec3 cloc[2] = vec3[](\n\t\tvec3(0.3252, -0.4480, 0.7412),\n\t\tvec3(-0.6978, -0.5313, -0.8275)\n\t\t);\n\tconst vec3 crot[2] = vec3[](\n\t\tvec3(0.2092, -1.4354, 0.2111),\n\t\tvec3(-2.9959, 0.4528, -0.0728)\n\t\t);\n\tconst vec3 tloc[2] = vec3[](\n\t\tvec3(0.0371, -0.4715, -0.5216),\n\t\tvec3(0.0188, -0.5819, 0.4570)\n\t\t);\n\tconst vec3 trot[2] = vec3[](\n\t\tvec3(1.4634, -0.4793, 0.3623),\n\t\tvec3(-1.3017, 0.5585, -0.2646)\n\t\t);\n\n\tfor(int i = ZERO; i < 2+CHARM; i++){\n\t\tres = v4OpUnion(sdTrap(rot(p+tloc[i], trot[i])), res);\n\t\tres = v4OpUnion(sdChain(rot(p+cloc[i], crot[i])), res);\n\t}\n\tres = v4OpUnion(sdGround(rot(p+vec3(-0.0000, -0.1335, -0.0000), vec3(-0.0000, 0.0000, -0.0000))), res);\n\n    return res;\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = MIN_DIST;\n    vec3  m = MAT_VOID;\n\n    for (int i = ZERO; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        gp = p;\n        vec4 res = sdScene(p);\n        res.x*=.5;\n        m = res.yzw;\n        if (abs(res.x) < MIN_DIST)break;\n        d += res.x;\n        if (d >= MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    }\n    if(d>MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+CHARM; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nvec3 ldir = normalize(vec3(-.5, 1.,-.95));\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o)\n{\n    float mint=L0_str;\n    float maxt=L0_end;\n    float k = L0_sft*2.;\n    float res = 1.;\n    float ph = 1e20;\n    float t=mint;\n    for( int i=ZERO; i < 64+CHARM; i++)\n    {\n        float h = sdScene(o + ldir*t).x;\n        if(abs(h)<MIN_DIST) return 0.;\n\n        res = min( res, k*h/t);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y));\n        ph = h;\n        t += h;\n\n        if(t >= maxt) break;\n    }\n    return smoothstep(.5, .51, res);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=ZERO; i<nbIte+CHARM; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\nfloat fakeReflection(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, -n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 nml = vec3(0);\nvec3 albedo = vec3(0);\nfloat spec = 0.;\nfloat depth = 0.;\nfloat ao = 1.;\nfloat shdw = 1.;\n\nvec3 render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    vec3 base_col = hit.yzw;\n\n    vec3 n = normal(p);\n\n    vec3 offset = n * .0005;\n    float vol = 1.0;\n    shdw=ao=1.;\n\n    vec3 res_col = vec3(1);\n\n    if (hit.x>=MAX_DIST)\n    {\n        nml = vec3(0);\n        res_col=vec3(1);\n        albedo = AMB_COL;\n        spec = 0.;\n        depth = 1.;\n        return AMB_COL;\n    }\n    else\n    {\n\n        ldir=L0_dir.xzy;\n\n        // Camera localized normal\n        vec3 up = quat_rotate(Cam_quat, vec3(0,1,0)).xzy;\n        vec3 side = cross(rd, up);\n        nml.x = dot(n+offset,  side);\n        nml.y = dot(n+offset,  up);\n        nml.z = dot(n+offset,  -rd);\n\n        float light1 = dot(n+offset,  ldir)*.5+.5; // Half-Lanbert model\n        float light2 = dot(n+offset, -ldir)*.5+.5;\n        shdw = shadow(p+offset);\n        float shade = 0.;\n        shade = 1.;\n\n        ao = ambientOcclusion(p+n*0.01, n, .1, 2.);\n        ao += ambientOcclusion(p+n*0.01, n, .01, .2);\n        ao += ambientOcclusion(p+n*0.01, n, .5, 2.);\n        ao += ambientOcclusion(p+n*0.01, n, 1., 2.);\n        ao = smoothstep(0., 4., ao);\n\n        const float thresh = .01;\n        if(distance(base_col, MAT_BLADE) < thresh)\n        {\n            // STeel\n            n.y += u2s(fbm(p.xz*30., 1))*.25*smoothstep(.1, .25, abs(p.z));\n            spec = specular(p+offset, n, ldir, 10.);\n            //n.z += u2s(fbm(p.xz*10., 1))*.5*smoothstep(.1, .25, abs(p.z));\n            // base_col = vec3(.005);\n            shade *= smoothstep(.4, .6, s2u(fbm(reflect(rd,n).xyz*vec3(5, 1.2, 5))));\n            shade *= 1.-fakeReflection(p+offset, n, ldir, 1.);\n        }\n        if(distance(base_col, MAT_METAL) < thresh)\n        {\n            // Spring\n            n.y += u2s(fbm(p.xz*30., 1))*.5*smoothstep(.1, .25, abs(p.z));\n            spec = specular(p+offset, n, ldir, 15.);\n            shade *= 1.-fakeReflection(p+offset, n, ldir, 1.);\n        }\n        albedo = base_col;\n        res_col=vec3(shade);\n        depth = distance(ro, p)/MAX_DIST;\n    }\n    return res_col;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(iFrame>1){fragColor = texture(iChannel0, fragCoord/iResolution.xy); return;}\n    \n    // Setup UV...\n    uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.)*iResolution.y/iResolution.x;\n    uv.x *= iResolution.x / iResolution.y;\n\n\n    // Rendering...\n    init();\n    camera(uv);\n\n    col=render();\n\n    vec3 spec_diffuse_ao = vec3(spec, col.x, ao)*2.-1.;\n    fragColor = vec4(pack4(vec4(nml*.5+.5, shdw)), pack(albedo), pack(spec_diffuse_ao*.998), depth);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}