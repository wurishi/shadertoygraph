{"ver":"0.1","info":{"id":"7lBfWz","date":"1652020416","viewed":276,"name":"Bloody Jos Leys ","username":"IgorZdrowowicz","description":"This is just a modified color and specularity settings version of https://www.shadertoy.com/view/XlVXzh by Jos Leys\nTrying to learn GLSL while translating this shader to blender shader nodes.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","kleinian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//By Jos Leys & Knighty, modified by Igor Zdrowowicz\n\n\nvec3  background1Color=vec3(0.,.0,.0);\n\nvec3  background2Color=vec3(1.0,1.0,0.5);\n\nvec2  ambientColor=vec2(0.,0.);\n\nvec3  color2=vec3(1.,0.,.1);\n\nfloat specularExponent=9.;\n\nfloat specularity=3.;\n\nvec3 from=vec3(0.0,0.975,-5.0);\n\n\n\nfloat box_size_x=-0.40445*2.;\nfloat box_size_z=0.34*2.;\nfloat slice_start=-11.;\nfloat slice_end=11.;\nfloat fudge_factor=0.09;\nvec3 light=vec3(1,1,-50);\n\n//sphere inversion\n\nvec3 InvCenter=vec3(1,.95,0.);\nfloat rad=0.8;\n\nvec2 wrap(vec2 x, vec2 a, vec2 s){\n\tx -= s; \n\treturn (x-a*floor(x/a)) + s;\n}\n\nvoid TransA(inout vec3 z, inout float DF, float a, float b){\n\tfloat iR = 1. / dot(z,z);\n\tz *= -iR;\n\tz.x = -b - z.x; z.y = a + z.y; \n\tDF *= iR;//max(1.,iR);\n}\n\nfloat  JosKleinian(vec3 z)\n{\n    float KleinR = 1.5 + .39;\n   float KleinI = (.55 * 2. - 1.);\n\tvec3 lz=z+vec3(1.), llz=z+vec3(-1.);\n    float d=0.; float d2=0.;\n    \n   \n        z=z-InvCenter;\n\t\td=length(z);\n\t\td2=d*d;\n\t\tz=(rad*rad/d2)*z+InvCenter;\n            \n\n\tfloat DE=1.;\n\tfloat DF = 1.0;\n\tfloat a = KleinR;\n    float b = KleinI;\n\tfloat f = sign(b)*1. ;     \n\tfor (int i = 0; i < 50 ; i++) \n\t{\n\t\tz.x=z.x+b/a*z.y;\n\t\tz.xz = wrap(z.xz, vec2(2. * box_size_x, 2. * box_size_z), vec2(- box_size_x, - box_size_z));\n\t\tz.x=z.x-b/a*z.y;\n               \n\t\t//If above the separation line, rotate by 180° about (-b/2, a/2)\n        if  (z.y >= a * 0.5 + f *(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5))))\t\n        {z = vec3(-b, a, 0.) - z;}\n        \n\t\t//Apply transformation a\n\t\tTransA(z, DF, a, b);\n\t\t\n\t\t//If the iterated points enters a 2-cycle , bail out.\n        if(dot(z-llz,z-llz) < 1e-5) {break;}\n\t\t\n\t\t//Store prévious iterates\n\t\tllz=lz; lz=z;\n\t}\n\t\n\t\n\tfloat y =  min(z.y, a-z.y) ;\n\tDE=min(DE,min(y,0.3)/max(DF,2.));\n      DE=DE*d2/(rad+d*DE);\n\treturn DE;\n}\n\n\n\nfloat trace(vec3 ro, vec3 rd, float start,inout bool hit) {\n    float dist=100.0;\n    float t =start;\n    for (int i = 0;  i < 200  ;i++) {\n        if (t>(-ro.z+slice_end)/rd.z) {hit=false; break;}\n        dist = JosKleinian(ro+t*rd);\n        if (dist<1./pow(10.,3.5)) {break;}\n        t += fudge_factor*dist;\n    }\n    return t;\n}\n\nvec3 blinnPhong(vec3 color, vec3 p, vec3 n)\n{\n\t// Ambient colour based on background gradient\n      float HALFPI=3.14159/2.;\n\tvec3 ambColor = clamp(mix(background2Color, background1Color, (sin(n.y * HALFPI) + 1.0) * 0.5), 0.0, 1.0);\n\tambColor = mix(vec3(ambientColor.x), ambColor, ambientColor.y);\n\tvec3  halfLV = normalize(light - p);\n\tfloat diffuse = max(dot(n, halfLV), 0.0);\n\tfloat specular = pow(diffuse, specularExponent);\n\t\n\treturn ambColor * color + color * diffuse + specular * specularity;\n}\n\n\nvec3 generateNormal(float afst,vec3 rd, vec3 from)\n{\n\tfloat eps =0.001; bool hit=true;\n   \tvec3 ray=  from+rd*afst;\n\t\n\tfloat start=afst-.1;\n\t\n    vec3 ray1=from+vec3(eps,0,0)+ rd*trace(from+vec3(eps,0,0), rd,start,hit );\n\tvec3 ray2=from+vec3(0,eps,0)+ rd*trace(from+vec3(0,eps,0), rd,start,hit );\n\tvec3 ray3=from+vec3(-eps,0,0)+ rd*trace(from+vec3(-eps,0,0), rd,start,hit );\n\t\n\tvec3 n1=normalize(-cross(ray1-ray,ray2-ray));\n\tvec3 n2=normalize(-cross(ray2-ray,ray3-ray));\n\t\n\tvec3 n=(n1+n2)/2.;\n\treturn n;\n}\n\nvec3  detcol( vec3  ray_direction)   \n{\n\tbool hit=true;\n    float start=(-from.z+slice_start)/ray_direction.z;\n\tfloat afst= trace(from, ray_direction,start,hit);\n\tvec3 ray=from+afst* ray_direction;\n      \n\nif ( !hit) {return background1Color;\t }  \n\nelse {\t\n    vec4  color;\n\tvec3 normal = generateNormal(afst,ray_direction,from);\n\tcolor.rgb = blinnPhong(clamp(color2, 0.0, 1.0), ray, normal);\n\t\n\t// Shadows\n\t\tvec3 light_direction=normalize(ray-light);\n\t\tfloat startlight=(-light.z+slice_start)/light_direction.z;\n\t\tfloat afstlight= trace(light,light_direction,startlight,hit);\n\t\tif (abs(afstlight-length(light-ray))>0.001) {color.rgb *=0.8;}\n\t\n\t\n\treturn color.xyz;}\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (1.1)*uv-vec2(-0.2,-1.);\n    uv.x *= iResolution.x/iResolution.y;\n    \n   \n    vec3 rd = normalize(vec3(uv,0.)-from);\n\n    float start=(-from.z-1.)/rd.z;\n\n    \n    vec3 c =detcol(rd);\n\tfragColor = vec4(c, .0);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}