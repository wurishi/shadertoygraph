{"ver":"0.1","info":{"id":"4c2fRK","date":"1725205650","viewed":38,"name":"Rainbow Ring Ride","username":"Peregrine","description":"2024-06-21, my first path-based ride!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","neon","ride"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t   iTime\n#define PI  3.1415926535897932384626\n#define TAU (2. * PI)\n#define PHI 1.6180339887498948482045\n#define EPSILON 0.01\n\n#define pos(x) ((x) * .5 + .5)\n#define rep(p, r) mod((p) + .5 * (r), r) - .5 * (r)\n#define repid(p, r) floor(((p) + .5 * (r))/(r))\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define sat(x) clamp(x, 0., 1.)\n\n#define TR_MAX_STEPS   128\n#define TR_MAX_DIST    20.\n#define GLOW_RADIUS    .1\n#define GLOW_INTENSITY .05\n#define GLOW_THRESHOLD 1\n#define PATH_AMP       4.\n#define PATH_GAP       2.5\n\nvec3 cos_palette(vec3 a, vec3 b, vec3 c, vec3 d, float x) {\n  return a + b * cos(TAU * (c * x + d));\n}\n\nvec3 rainbow(float x) {\n  return cos_palette(vec3(.5), vec3(.5), vec3(1.), vec3(0., .33, .67), x);\n}\n\nvec2 path(float x) {\n  float a = sin(.1 * x + 1.5),\n        b = sin(.06 * x);\n  return PATH_AMP * vec2(a, b); \n}\n\nfloat sdf_torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}  \n\nfloat sdf(vec3 p) {\n  float d = TR_MAX_DIST;\n  vec3 pp = p;\n  p.xy -= path(p.z);\n  p.xy *= rot(p.z * PI);\n  float id = repid(p.z, PATH_GAP);\n  p.z = rep(p.z, PATH_GAP);\n  p.yz *= rot(PI/2.);\n  d = min(d, sdf_torus(p, vec2(1., .05)));\n  return d;\n}\n\nvec3 glow;\nfloat trace(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  float td = 0.;\n  \n  glow = vec3(0.);\n  for (int i = 0; i < TR_MAX_STEPS && td < TR_MAX_DIST; i++) {\n    float d = sdf(p);\n    if (d < EPSILON)\n      return td;\n    if (i > GLOW_THRESHOLD)\n      glow += rainbow(p.z * PATH_GAP) * (1. - sat(d/GLOW_RADIUS)) * GLOW_INTENSITY;\n    p += d * rd;\n    td = distance(ro, p);\n  }\n  \n  return -1.;\n}\n\nvec3 get_normal(vec3 p) {\n  vec2 e = EPSILON * vec2(1., -1.);\n  return normalize(\n    e.xyy * sdf(p + e.xyy) +\n    e.yxy * sdf(p + e.yxy) +\n    e.yyx * sdf(p + e.yyx) +\n    e.xxx * sdf(p + e.xxx)\n  );\n}\n\nvec3 get_raydir(vec2 uv, vec3 ro, vec3 ta) {\n  vec3 rd = normalize(ta - ro),\n       r = normalize(cross(vec3(0., 1., 0.), rd)),\n       u = normalize(cross(rd, r));\n  return normalize(rd + r * uv.x + u * uv.y);\n}\n\nvec3 render(vec2 uv) {\n  vec3 ro = vec3(0., 0., -5. + 2. * t),\n       ta = vec3(0., 0., 2. * t);\n  \n  ro.xy += path(ro.z);\n  ta.xy += path(ta.z);\n  vec3 rd = get_raydir(uv, ro, ta);\n  \n  float td = trace(ro, rd);\n  if (td > 0.) {\n    vec3 p = ro + td * rd;\n    return rainbow(p.z * PATH_GAP) + glow;\n  } else return vec3(0.) + glow;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  vec3 c = render(uv);\n  \n  c = pow(sat(c), vec3(1./2.2)); // gamma correction\n  fragColor = vec4(c, 1.);\n}\n","name":"Image","description":"","type":"image"}]}