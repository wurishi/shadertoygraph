{"ver":"0.1","info":{"id":"ssjBzG","date":"1646578538","viewed":125,"name":"Sonar in tunnel","username":"johnao","description":"Conceptual visualization of sonar image for submarines.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO: add glitter effect?\n\nfloat light(float x) {\n    float y = fract(x) * 0.8;\n    return y < 1. ? ((y < .007 ? 1. : 0.) + (y < .2 ? 1. : exp((-y + .2) * 10.)) * .7) : 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    uv.y *= .3;\n    vec3 o = camPath(iTime * .7);\n    vec3 d = camera(o, lookat(o)) * normalize(vec3(uv, 1.97));\n    float col;\n    float r = march(o, d);\n    col = (1. - r * .1) * light(-r * .05 + iTime * .12);\n    col += pow(max(0., (8. - length(uv - vec2(0., -8.)))), 1.5) * 3.;\n    fragColor = vec4(vec3(0.9882, 0.8392, 0.0) * min(.9, col), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// The following code is gratefully copied from\n// https://www.shadertoy.com/view/4sKSzR\n\nfloat hash(float n) {\n    return fract(sin(n) * 43578.4545);\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0 + p.z * 113.0;\n    return mix(\n        mix(\n            mix(hash(n + 000.0), hash(n + 001.0), f.x),\n            mix(hash(n + 057.0), hash(n + 058.0), f.x),\n            f.y),\n        mix(\n            mix(hash(n + 113.0), hash(n + 114.0), f.x),\n            mix(hash(n + 170.0), hash(n + 171.0), f.x),\n            f.y),\n        f.z);\n}\n\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f += 0.500 * noise(p);\n    p *= 2.01;\n    f += 0.250 * noise(p);\n    p *= 2.04;\n    f += 0.125 * noise(p);\n    f /= 0.875;\n    return f;\n}\n\nvec2 path(float z) {\n    return vec2(sin(0.5 * z), 2.0 * cos(0.12 * z));\n}\n\nvec3 camPath(float t) {\n    return vec3(path(t), t);\n}\n\nvec3 lookat(vec3 o) {\n    vec3 la = o + vec3(0, 0, 1);\n    la.xy = path(la.z);\n    return la;\n}\n\nfloat map(vec3 p) {\n    float r = 0.6 * smoothstep(0.3, 1.0, noise(1.5 * p));\n    float f = 0.1 * smoothstep(0.0, 1.0, fbm(6.0 * p));\n    vec2 tun = abs(p.xy - path(p.z)) * vec2(.6, 3);\n    float t = 1.0 - max(tun.x, tun.y);\n    return t - (r + f);\n}\n\nfloat march(vec3 o, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 150; i++) {\n        float h = map(o + rd * t);\n        if (abs(h) < 0.0001 || t >= 30.0) break;\n        t += h * 0.5;\n    }\n    return t;\n}\n\nmat3 camera(vec3 e, vec3 l) {\n    vec3 f = normalize(l - e);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = normalize(cross(f, r));\n    return mat3(r, u, f);\n}","name":"Common","description":"","type":"common"}]}