{"ver":"0.1","info":{"id":"mtcXWN","date":"1685400440","viewed":74,"name":"Simple Ray Marcher - sjarod","username":"SJarod","description":"Simple ray marcher to simulate lighting with participating media (volumetric lighting)","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple Ray Marcher - sjarod\n// 2023\n// demo to illustrate ray marching rendering with volumetric lighting\n\n// controls\n// mouse : move arround scene\n// shift + mouse : move light\n// d : toggle camera auto movement\n// f : toggle light auto movement\n\n\n\n\n\n// ray marching constants\n\n// minimal distance between ray and hit\n#define PRECISION 0.01\n// maximal ray length\n#define MAX_RAY_LENGTH 99.0\n// maximum ray step number\n#define SAMPLES 99\n// epsilon used for normals\n#define EPSILON 0.01\n\n// lighting constants\n\n// maximum virtual shadow volumes step number\n#define VSV_SAMPLES 50\n// participating media density\n#define VARIABLE_DENSITY 1\n// directional light or point light\n#define DIRECTIONAL 0\n\n\n\n\n\n\n\n// constant variables\n\n\n// general variables\n\n\n// division by 0 will return infinity\n// 1.0 / 0.0 = +infinity\n// -1.0 / 0.0 = -infinity\n// may be undefined behaviour in older versions of OpenGL\n\nfloat pinf = 1.0 / 0.0;\nfloat ninf = -1.0 / 0.0;\n\n// pi with 50 digit\nfloat pi = 3.1415926535897932384626433832795028841971693993751;\n\n\n\n// volumetric lighting constants\n\n\n// media's absorption coefficient\nfloat ka = 0.01;\n// media's scattering coefficient\nfloat ks = 0.01;\n\n// light's emitted radiance (intensity)\nfloat i0 = 999.0;\n\n\n\n\n\n\n\n// structures\n\nstruct RayHit\n{\n    // distance from eye to surface\n    float ds;\n    // pixel world position (fragment 3D position)\n    vec3 pp;\n    // normal\n    vec3 n;\n    // hit object id\n    int id;\n};\n\n\n\n\n\n\n// signed distance functions\n// https://iquilezles.org/articles/distfunctions/\n\nfloat sdfSphere(vec3 v, float r)\n{\n    return length(v) - r;\n}\n\nfloat sdfBox(vec3 v, vec3 d)\n{\n    vec3 q = abs(v) - d;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdfTorus(vec3 v, vec2 t)\n{\n    vec2 q = vec2(length(v.xz) - t.x, v.y);\n    return length(q) - t.y;\n}\n\nfloat sdfPlane(vec3 v, vec3 n, float h)\n{\n    return dot(v, normalize(n)) + h;\n}\n\nfloat sdfBoxFrame(vec3 v, vec3 b, float e)\n{\n    v = abs(v) - b;\n    vec3 q = abs(v + e) - e;\n    return min(min(\n    length(max(vec3(v.x, q.y, q.z),0.0)) + min(max(v.x, max(q.y, q.z)), 0.0),\n    length(max(vec3(q.x, v.y, q.z),0.0)) + min(max(q.x, max(v.y, q.z)), 0.0)),\n    length(max(vec3(q.x, q.y, v.z),0.0)) + min(max(q.x, max(q.y, v.z)), 0.0));\n}\n\n\n\n\n\n\n\n\n\n// mathematics\n\nmat3 lookAt(in vec3 eye, in vec3 at, in vec3 up)\n{\n    vec3 z = normalize(at - eye);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = cross(x, z);\n    \n    return mat3(x, y, z);\n}\n\n// integration from 2 points\n// https://stackoverflow.com/a/2982197\nfloat integration(float x0, float y0, float x1, float y1)\n{\n    return (y0 + y1) / 2.0 * (x1 - x0);\n}\n\n\n\n\n\n\n\n\n\n\n// lighting\n\n// get light position\nvec3 light0()\n{\n    float lightRotationSpeed = 2.0 * (1.0 - texelFetch(iChannel0, ivec2(70, 2), 0).x);\n    vec3 lightPos;\n    if (iMouse.z > 0.0 && texelFetch(iChannel0, ivec2(16, 0), 0).x == 1.0)\n        lightPos = vec3(sin(iMouse.x * 0.01) * 5.0, 5.0, cos(iMouse.x * 0.01) * 5.0);\n    else\n        lightPos = vec3(sin(iTime * lightRotationSpeed) * 4.0,\n                        cos(iTime * lightRotationSpeed) * 4.0,\n                        cos(iTime * lightRotationSpeed) * 4.0);\n                        \n    return lightPos;\n}\n\n// light direction (for calculations)\n// xyz : vec3, w : vector length\nvec4 l(vec3 lightPos, vec3 pp)\n{\n#if DIRECTIONAL\n    return vec4(normalize(lightPos), length(lightPos - pp));\n#else\n    return vec4(normalize(lightPos - pp), length(lightPos - pp));\n#endif\n}\n\n// ds : distance from eye to surface\nvec3 attenuation(vec3 Ls, float ds)\n{    \n    return Ls * exp(-(ka + ks) * ds);\n}\n\n// phase functions\n\n// https://www.researchgate.net/publication/229643454_A_scattering_phase_function_for_ice_cloud_Tests_of_applicability_using_aircraft_and_satellite_multi-angle_multi-wavelength_radiance_measurements_of_cirrus\nfloat p1(float theta, float g)\n{\n    return (1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * cos(theta), 1.5);\n}\n\nfloat p2(float theta)\n{\n    return 1.0 - cos(theta) * cos(theta);\n}\n\n// simplification of phase function\nfloat f(float u, float v)\n{\n    float x0 = 0.0;\n    float y0 = exp(-u * tan(x0));\n    float x1 = v;\n    float y1 = exp(-u * tan(x1));\n    return integration(x0, y0, x1, y1);\n}\n\n// https://cwyman.org/papers/irt08_volShadows.pdf\n// ds : distance from eye to surface\nfloat scatteringVariableDensity(vec3 camPos, vec3 rayDir, float ds)\n{\n    vec4 L = l(light0(), camPos);\n    vec3 eyeToLight = L.xyz;\n    float dl = L.w;\n    // angle between the view ray and the vector from eye to light\n    float gamma = acos(dot(rayDir, normalize(eyeToLight)));\n    \n    \n    float A0 = (ks * exp(-ks * dl * cos(gamma))) / (2.0 * pi * dl * sin(gamma));\n    float A1 = ks * dl * sin(gamma);\n    float A2 = (pi / 4.0) + (0.5 * atan((ds - dl * cos(gamma)) / (dl * sin(gamma))));\n    \n    return i0 * A0 * (f(A1, A2) - f(A1, gamma / 2.0));\n}\n\n// https://fvcaputo.github.io/2017/05/02/ray-marching.html\n// https://github.com/fvcaputo/raytracer/blob/master/world.h#L395\nfloat scatteringConstantDensity(int delta)\n{\n    float theta = 1.0;\n    float g = 1.0;\n    float l = 0.0;\n    for (int i = 0; i < delta; ++i)\n    {\n        l += (p1(theta, g) + p2(theta)) / (ka + ks) * i0 * (1.0 - exp(-(ka + ks) * float(i)));\n    }\n    \n    return l / float(delta);\n}\n\nRayHit rayMarch(in vec3 camPos, in vec3 rayDir);\n\nfloat shadow(vec3 pp, vec3 n, vec3 lightDir)\n{\n    // ray marching for shadow check\n    // https://inspirnathan.com/posts/59-shadertoy-tutorial-part-13/\n    RayHit shadowHit = rayMarch(pp + n * PRECISION * 2.0, lightDir);\n#if DIRECTIONAL\n    return shadowHit.ds <= length(light0() - pp) || shadowHit.id >= 0 ? 0.0 : 1.0;\n#else\n    return shadowHit.ds <= length(light0() - pp) && shadowHit.id >= 0 ? 0.0 : 1.0;\n#endif\n}\n\nfloat scatteringShadowVolume(vec3 camPos, vec3 rayDir, vec3 pp, vec3 n)\n{\n    vec3 p = camPos;\n    float march = min(length(pp - p) / float(VSV_SAMPLES), 1.0); // minimum step is 1.0\n    // scattering delta\n    float delta = 1.0 / float(VSV_SAMPLES);\n    float Ssctr = 1.0; // scattering inside shadows (\"virtual shadow volumes\")\n    // TODO : optimize\n    for (int i = 0; i < VSV_SAMPLES - 1; ++i) // double ray marching, do not iterate to last sample (collision with object)\n    {\n        p += rayDir * march;\n        Ssctr -= delta * (1.0 - shadow(p, n, l(light0(), p).xyz));\n    }\n    \n    return Ssctr;\n}\n\n\n\n\n\n\n\n\n\n// scene\n\n// overwrites a sdf and an ID if relevant\n// TODO : upgrade\nvoid minSDF(out float sdf1, out int id1, in float sdf2, in int id2)\n{\n    if (sdf1 < sdf2)\n    {\n        return;\n    }\n    else\n    {\n        sdf1 = sdf2;\n        id1 = id2;\n    }\n}\n\nfloat sceneSDF(out int hitID, in vec3 rayPos)\n{\n    // SDFs\n    \n    hitID = -1;\n    \n    float sdf = pinf;\n    minSDF(sdf, hitID, sdfSphere(rayPos - vec3(-2.5, 0.0, 0.0), 1.0), 0);\n    minSDF(sdf, hitID, sdfBox(rayPos - vec3(0.0), vec3(0.7)), 1);\n    minSDF(sdf, hitID, sdfTorus(rayPos - vec3(2.5, 0.0, 0.0), vec2(0.7, 0.3)), 2);\n    // TODO : add checker texture on plane\n    minSDF(sdf, hitID, sdfPlane(rayPos - vec3(0.0), vec3(0.0, 1.0, 0.0), 5.0), 3);\n    minSDF(sdf, hitID, sdfBoxFrame(rayPos - vec3(0.0, 2, 0.0), vec3(0.7), 0.1), 4);\n    \n    return sdf;\n}\n\nvec3 sceneNormal(vec3 rayPos)\n{\n    int discardable;\n    \n    vec2 k = vec2(1.0, -1.0);\n    vec3 a = k.xyy * sceneSDF(discardable, rayPos + k.xyy * EPSILON);\n    vec3 b = k.yxy * sceneSDF(discardable, rayPos + k.yxy * EPSILON);\n    vec3 c = k.yyx * sceneSDF(discardable, rayPos + k.yyx * EPSILON);\n    vec3 d = k.xxx * sceneSDF(discardable, rayPos + k.xxx * EPSILON);\n    \n    return normalize(a + b + c + d);\n}\n\nvec3 sceneColor(RayHit hitResult, vec3 camPos, vec3 rayDir)\n{\n    vec3 color = vec3(0.2);\n    vec3 emissive = vec3(0.0);\n    switch (hitResult.id)\n    {\n    case 0:\n        color = vec3(1.0, 0.0, 0.0);\n        break;\n    case 1:\n        color = vec3(0.0, 1.0, 0.0);\n        break;\n    case 2:\n        color = vec3(0.0, 0.0, 1.0);\n        break;\n    case 3:\n        color = vec3(1.0);\n        break;\n    case 4:\n        color = vec3(1.0, 0.0, 1.0);\n        break;\n    default:\n        emissive = vec3(1.0);\n        break;\n    }\n    \n    \n    \n    vec3 L = l(light0(), hitResult.pp).xyz;\n    vec3 V = normalize(camPos - hitResult.pp);\n    vec3 N = hitResult.n;\n    //vec3 H = normalize(L + V);\n    vec3 R = reflect(-L, N);\n    \n    \n    float shininess = 99.0;\n    \n    vec3 ambient = color * 0.1;\n    vec3 diffuse = color * max(dot(L, N), 0.0);\n    vec3 specular = color * pow(max(dot(R, V), 0.0), shininess / 4.0);\n    \n    vec3 Ls = ambient + (diffuse + specular) * shadow(hitResult.pp, N, L) + emissive;\n    \n    \n    vec3 Lattn = attenuation(Ls, hitResult.ds);\n#if VARIABLE_DENSITY\n    float Lsctr = scatteringVariableDensity(camPos, rayDir, hitResult.ds);\n#else\n    float Lsctr = scatteringConstantDensity(3);\n#endif\n    \n    float Ssctr = scatteringShadowVolume(camPos, rayDir, hitResult.pp, N);\n    \n    return Lattn + Lsctr * Ssctr;\n}\n\n\n\n\n\n\n\n\n\n\n// ray marching\n\nRayHit rayMarch(in vec3 camPos, in vec3 rayDir)\n{\n    // closest distance to surface\n    float closest = pinf;\n    // distance traveled by the ray\n    float d = 0.0;\n    \n    \n    // ds default value is max\n    RayHit result = RayHit(MAX_RAY_LENGTH, vec3(0.0), vec3(0.0), -1);\n    \n    for (int i = 0; i < SAMPLES; ++i)\n    {\n        if (closest <= PRECISION || d >= MAX_RAY_LENGTH)\n            break;\n            \n        result.pp = camPos + rayDir * d;\n        \n        closest = sceneSDF(result.id, result.pp);\n        d += closest;\n    }\n    \n    if (d < MAX_RAY_LENGTH)\n    {\n        result.ds = d;\n        result.n = sceneNormal(result.pp);\n    }\n    else\n    {\n        result.id = -1;\n    }\n    \n    return result;\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixels\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    \n    \n    // view transform\n    // camera\n    float rotationSpeed = 0.5 * (1.0 - texelFetch(iChannel0, ivec2(68, 2), 0).x);\n    float offset = 9.0; // offset to scene\n    vec3 camPos;\n    if (iMouse.z > 0.0 && texelFetch(iChannel0, ivec2(16, 0), 0).x == 0.0)\n    {\n        float xaxis = cos(iMouse.x * 0.01);\n        float zaxis = sin(iMouse.x * 0.01);\n        float yaxis = iMouse.y * 0.01;\n        camPos = vec3(xaxis * sin(yaxis) * offset,\n                    cos(yaxis) * offset,\n                    zaxis * sin(yaxis) * offset);\n    }\n    else\n    {\n        camPos = vec3(-sin(iTime * rotationSpeed) * offset, 3.0, cos(iTime * rotationSpeed) * offset);\n    }\n    // look at matrix\n    mat3 lookat = lookAt(camPos, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    \n    \n    // ray\n    float fov = 2.0;\n    vec3 ray = normalize(lookat * vec3(uv, fov));\n    RayHit hitResult = rayMarch(camPos, ray);\n    \n    fragColor = vec4(sceneColor(hitResult, camPos, ray), 1.0);\n}\n\n\n\n\n\n\n\n\n// inspirations\n\n// https://shadertoy.com/view/Xl2XWt\n// https://shadertoy.com/view/Xds3zN\n// https://shadertoy.com/view/XsdGDM\n// https://shadertoy.com/view/3sKSWz\n// keyboard input\n// https://www.shadertoy.com/view/sdf3RS\n// https://www.shadertoy.com/view/lsXGzf","name":"Image","description":"","type":"image"}]}