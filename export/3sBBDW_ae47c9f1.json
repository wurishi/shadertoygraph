{"ver":"0.1","info":{"id":"3sBBDW","date":"1590448619","viewed":117,"name":"Ray Marching Sphere :P","username":"hopeliz","description":"First time ray marching with code! Followed a tutorial by The Art of Code: https://youtu.be/PGtv-dBi2wE\nCreated for Day 10 of a 100 Days of Shaders and Textures project","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.01\n\nfloat sphereSize = 1.0;\nvec2 sphereLocation = vec2(0, 6);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\nfloat GetDist(vec3 point) {\n    // Set sphere location\n    vec4 spherePos = vec4(sphereLocation.x, sphereSize, sphereLocation.y, sphereSize);\n    \n    // Calculate sphere distance\n    float sphereDist = length(point - spherePos.xyz) - spherePos.w;\n    \n    // Calculate plane distance\n    float planeDist = point.y;\n    \n    // Calculate total distance\n    float dist = min(sphereDist, planeDist);\n    \n    return dist;\n}\n\nfloat RayMarch(vec3 rOrigin, vec3 rDirection) {\n    float distFromOrigin = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 hitPoint = rOrigin + distFromOrigin * rDirection;\n        float dist = GetDist(hitPoint);\n        distFromOrigin += dist;\n        \n        if (dist < SURFACE_DIST || distFromOrigin > MAX_DIST) { break; }\n    }\n    \n    return distFromOrigin;\n}\n\nvec3 GetNormal(vec3 point) {\n    float dist = GetDist(point);\n    vec2 e = vec2(0.01, 0.0);\n    vec3 normal = dist - vec3(\n        GetDist(point - e.xyy),\n        GetDist(point - e.yxy),\n        GetDist(point - e.yyx)\n        );\n    \n    return normalize(normal);\n}\n\nfloat GetLight(vec3 point) {\n    vec3 lightPos = vec3(0, 5, 6);\n    \n    // Make light move in a circle around\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 3.0;\n    \n    vec3 light = normalize(lightPos - point);\n    vec3 normal = GetNormal(point);\n    \n    float difLight = clamp(dot(normal, light), 0.0, 1.0);\n    \n    // For shadows\n    float dist = RayMarch(point + normal * SURFACE_DIST * 2.0, light);\n    if (dist < length(lightPos - point)) {\n        difLight *= 0.1;\n    }\n    return difLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates (from 0 to 1) and set origin to center\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    // Set camera position\n    vec3 rayOrigin = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 lightPoint = rayOrigin + rayDirection * dist;\n    \n    // Get diffuse lighting\n    float difLight = GetLight(lightPoint);\n    \n    color = vec3(difLight) * lightColor;\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}