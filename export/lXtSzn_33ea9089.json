{"ver":"0.1","info":{"id":"lXtSzn","date":"1722968936","viewed":51,"name":"Alien Pustules","username":"WebSeed","description":"Adapted from https://iquilezles.org/articles/smin/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","materials","blending","smooth","smin","union"],"hasliked":0,"parentid":"MctXzf","parentname":"Balls 001"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cubic Polynomial Smooth-minimum\nvec2 smin(float a, float b, float k) {\n  k *= 6.0;\n  float h = max(k - abs(a - b), 0.0) / k;\n  float m = h * h * h * 0.5;\n  float s = m * k * (1.0 / 3.0);\n  return (a < b) ? vec2(a - s, m) : vec2(b - s, 1.0 - m);\n}\n\nfloat hash1(float n) {\n  return fract(sin(n) * 43758.5453123);\n}\n\nvec3 forwardSF(float i, float n) {\n  const float PI = 3.1415926535897932384626433832795;\n  const float PHI = 1.6180339887498948482045868343656;\n  float phi = 2.0 * PI * fract(i / PHI);\n  float zi = 1.0 - (2.0 * i + 1.0) / n;\n  float sinTheta = sqrt(1.0 - zi * zi);\n  return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, zi);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 q = vec3(p);\n  \n  const float s = 2.;\n  vec2 id = round(q.xz / s);\n  q.xz = q.xz - s * id;\n\n  float wave = .2 * sin(p.x + iTime) + .2 * cos(p.z);\n  float waveId = .2 * sin((id.x * s) + iTime) + .2 * cos(id.y * s);\n\n  // plane\n  float floorDist = p.y - wave;\n  \n  vec3 spherePos = vec3(0., waveId, 0.);\n  // sphere\n  float sphereDist = length(\n    q - spherePos\n  ) - 0.2;\n\n  // smooth union\n  return smin(floorDist, sphereDist, 0.1);\n}\n\nvec2 intersect(in vec3 ro, in vec3 rd)\n{\n  const float maxd = 300.0;\n\n  vec2 res = vec2(0.0);\n  float t = 0.0;\n  for (int i = 0; i < 512; i++)\n  {\n    vec2 h = map(ro + rd * t);\n    if ((h.x < 0.005) || (t > maxd))\n      break;\n    t += h.x;\n    res = vec2(t, h.y);\n  }\n\n  if (t > maxd)\n    res = vec2(-1.0);\n  return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.005;\n  return normalize(\n    e.xyy * map(pos + e.xyy).x +\n    e.yyx * map(pos + e.yyx).x +\n    e.yxy * map(pos + e.yxy).x +\n    e.xxx * map(pos + e.xxx).x\n  );\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO(in vec3 pos, in vec3 nor, float ran) {\n  float ao = 0.0;\n  const int num = 32;\n  for (int i = 0; i < num; i++) {\n    vec3 kk;\n    vec3 ap = forwardSF(float(i) + ran, float(num));\n    ap *= sign(dot(ap, nor)) * hash1(float(i));\n    ao += clamp(map(pos + nor * 0.01 + ap * 0.2).x * 20.0, 0.0, 1.0);\n  }\n  ao /= float(num);\n\n  return clamp(ao, 0.0, 1.0);\n}\n\nvec3 render(in vec2 p, vec4 ran) {\n  //-----------------------------------------------------\n  // camera\n  //-----------------------------------------------------\n  float an = 0.1 * iTime;\n  /*\n  vec3 ro = vec3(\n      0.4 * sin(an) - iTime * 0.5,\n      1. * (sin(iTime) * 0.5 + 0.5) + 2.0,\n      0.4 * cos(an) - iTime\n  );*/\n  vec3 ro = vec3(0., 2., -1.);\n  vec3 ta = vec3(0.0, 2., 0.);\n  // camera matrix\n  vec3 ww = -normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n  // create view ray\n  float aspect = 1.8;\n  vec3 rd = normalize(p.x * uu + p.y * vv + aspect * ww);\n\n  //-----------------------------------------------------\n  // render\n  //-----------------------------------------------------\n\n  vec3 col = vec3(0.03, 0.0, 0.05);\n  //vec3 col = vec3(0.05, 0.05, 0.05);\n  vec3 amb = vec3(col);\n  vec3 c1 = normalize(amb + vec3(0.3, 0.0, 0.7));\n  vec3 c2 = normalize(amb + vec3(0.3, 0.0, 0.0));\n  //vec3 c2 = vec3(1.0, 0.0, 0.0);\n\n  // raymarch\n  vec3 uvw;\n  vec2 res = intersect(ro, rd);\n  float t = res.x;\n  if (t > 0.0) {\n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor);\n    float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0);\n    float occ = 1.0; // calcAO(pos, nor, ran.y); occ = occ * occ;\n\n    \n    //col = /*vec3(fre) +*/ nor;\n    \n    // blend materials\n    col = mix(c1, c2, res.y);\n\n    col = col * 0.72 + 0.05 * fre * vec3(1.0, 1.0, 1.0);\n\n    vec3 lin = 4.0 * vec3(0.7, 0.8, 1.0) * (0.5 + 0.5 * nor.y) * occ;\n    lin += 0.8 * vec3(1.0, 1.0, 1.0) * fre * (0.6 + 0.4 * occ);\n\n    const float falloff = -0.01;\n    col = col * lin;\n    col += 2.0 * vec3(0.8, 0.9, 1.00) * smoothstep(0.0, 0.4, ref.y) * (0.06 + 0.94 * pow(fre, 5.0)) * occ;\n    col = mix(col, amb, 1.0 - exp(falloff * t * t));\n\n \n  }\n\n  // gamma and postpro\n  col = pow(col, vec3(0.4545));\n  col *= 0.9;\n  col = clamp(col, 0.0, 1.0);\n  col = col * col * (3.0 - 2.0 * col);\n\n  // dithering\n  col += (ran.x - 0.5) / 255.0;\n\n  return col;\n}\n\n#define AA 1\n\nvec3 bg(in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy - 0.5;\n\n  vec4 k = vec4(0.0, 0.0, 0.0, 1.0);\n\n  float passes = 100.0;\n  float t = iTime * 0.012;\n\n  for (float i = 0.0; i < passes; ++i) {\n    float offset = i / passes;\n    vec2 s = uv * offset + vec2(sin(t), cos(t));\n\n    k += texture(iChannel1, s) / passes * (1.0 - offset) * 5.0;\n  }\n\n  vec3 c = vec3(\n    pow(k.x, 3.0) + 0.5,\n    /* pow(k.y, 2.0) */ pow(k.x, 2.0) * 0.5,\n    k.z\n  );\n  \n  return c * c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 px = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  vec4 ran = texelFetch(iChannel0, ivec2(fragCoord) & 1023, 0);\n  vec3 col = render(px, ran);\n  \n  vec3 bg = vec3(0.); // (sin(iTime * 0.5) * 0.4 + 0.5) * 0.8 * bg(fragCoord);\n\n  fragColor = vec4(bg + col, 1.0);\n}","name":"Image","description":"","type":"image"}]}