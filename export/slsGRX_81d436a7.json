{"ver":"0.1","info":{"id":"slsGRX","date":"1622630229","viewed":163,"name":"RaycastSphere","username":"Famousghost","description":"Ray cast to sphere algorithm connected with ray cast to plane and diffuse and specular light from Phong light model.\n(Fix different ground uv coords)\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raycastingphongspheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Plane\n{\n    float dist;\n    vec3 normal;\n};\n\nvec3 lightPosition = vec3(0.0f, 0.0f, 9.0f);\n\nfloat rayCastSphere(Ray ray, vec3 sphereOrigin, float radius)\n{\n    vec3 e = sphereOrigin - ray.origin;\n   \n    float a = dot(ray.direction, e);\n    float eSq = length(e) * length(e);\n   \n    float bSq = eSq - a * a;\n    float radiusSq = radius * radius;\n    float f = sqrt(radiusSq - bSq);\n    float t = a - f;\n   \n    if(eSq < radiusSq)\n    {\n        t = a + f;\n    }\n   \n    if(radiusSq - bSq < 0.0f)\n    {\n        return 0.0f;\n    }\n   \n    return t;\n}\n\nfloat rayCastPlane(Ray ray, Plane plane)\n{\n    float rayDirectionPlaneNormalDot = dot(ray.direction, plane.normal);\n    if(rayDirectionPlaneNormalDot  >= 0.0f)\n    {\n        return 0.0f;\n    }\n    float t = -(plane.dist + dot(ray.origin, plane.normal)) / rayDirectionPlaneNormalDot;\n    return t >= 0.0f ? t : 0.0f;\n}\n\nvec3 getNormal(vec3 point, vec3 sphereCenter)\n{\n    return point != vec3(0.0f) ? normalize(point - sphereCenter) : vec3(0.0f);\n}\n\nfloat diffuse(vec3 lightPos, vec3 normal, vec3 point)\n{\n    vec3 lightDir = normalize(point - lightPos);\n    float d = max(dot(-lightDir, normal), 0.0f);\n    return d;\n}\n\nfloat specular(vec3 cameraPos, vec3 lightPos, vec3 point, vec3 normal)\n{\n    vec3 lightDir = normalize(point - lightPos);\n    vec3 reflLightDir = reflect(-lightDir, normal);\n    vec3 camDir = normalize(point - cameraPos);\n   \n    float s = pow(max(dot(camDir, reflLightDir), 0.0f), 32.0f);\n   \n    return s;\n}\n\nvec3 createSpheres(Ray ray,\n                  vec3 spheresCenter[4],\n                  vec3 spheresColors[4],\n                  float radius[4],\n                  Plane plane,\n                  vec2 uv)\n{\n    float tSphere1 =  rayCastSphere(ray, spheresCenter[0], radius[0]);\n    float tSphere2 =  rayCastSphere(ray, spheresCenter[1], radius[1]);\n    float tSphere3 =  rayCastSphere(ray, spheresCenter[2], radius[2]);\n    float tSphere4 =  rayCastSphere(ray, spheresCenter[3], radius[3]);\n    float tPlane = rayCastPlane(ray, plane);\n    float minSphere = 10000.0f;\n    vec3 currentSphereCenter = vec3(0.0f);\n    vec3 color = vec3(0.0f);\n    \n    if(tSphere1 > 0.0f && minSphere > tSphere1)\n    {\n        minSphere = tSphere1;\n        currentSphereCenter = spheresCenter[0];\n        color = spheresColors[0];\n    }\n    if(tSphere2 > 0.0f && minSphere > tSphere2)\n    {\n        minSphere = tSphere2;\n        currentSphereCenter = spheresCenter[1];\n        color = spheresColors[1];\n    }\n    if(tSphere3 > 0.0f && minSphere > tSphere3)\n    {\n        minSphere = tSphere3;\n        currentSphereCenter = spheresCenter[2];\n        color = spheresColors[2];\n    }\n    if(tSphere4 > 0.0f && minSphere > tSphere4)\n    {\n        minSphere = tSphere4;\n        currentSphereCenter = spheresCenter[3];\n        color = spheresColors[3];\n        return vec3(1.0f);\n    }\n    vec3 normal = plane.normal;\n    vec3 point;\n    if((minSphere < tPlane && minSphere != 0.0f) || tPlane == 0.0f)\n    {\n        point = ray.origin + ray.direction * minSphere;\n        normal = getNormal(point, currentSphereCenter);\n    }\n    else\n    {\n        point = ray.origin + ray.direction * tPlane;\n        color = texture(iChannel0, point.xz / 8.0f).rgb;\n        normal = texture(iChannel1, point.xz / 8.0f).rgb;\n        normal.z *= 2.5f;\n\n    }\n    vec3 col = color * vec3(diffuse(lightPosition, normal, point)\n                            + specular(ray.origin, lightPosition, point, normal));\n                   \n    return col;\n}\n\nPlane createPlane(vec3 normal, float dist)\n{\n    Plane plane;\n    plane.dist = dist;\n    plane.normal = normal;\n    \n    return plane;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5f * iResolution.xy)/iResolution.y;\n    \n    Ray ray;\n   \n    ray.origin = vec3(0.0f, 0.0f, 0.0f);\n   \n    ray.direction = normalize(vec3(uv.x, uv.y, 1.0f));\n   \n    lightPosition = vec3(cos(iTime) * lightPosition.x + sin(iTime) * lightPosition.z,\n                         lightPosition.y + 2.0f,\n                         7.0f + (-sin(iTime) * lightPosition.x + cos(iTime) * lightPosition.z));\n               \n   \n    vec3 ambient = vec3(1.0f, 1.0f, 1.0f);  \n    vec3 sphere1Color = vec3(1.0f, 0.0f, 0.0f);\n    vec3 sphere2Color = vec3(0.0f, 1.0f, 0.0f);\n    vec3 sphere3Color = vec3(0.0f, 0.0f, 1.0f);\n    \n    Plane plane = createPlane(vec3(0.0f, 1.0f, 0.0f), 2.0f);\n    vec3 spheresCenter[4];\n    spheresCenter[0] = vec3(-3.0f, 3.0f + sin(iTime) * 0.5f - 0.5f, 11.0f);\n    spheresCenter[1] = vec3(0.5f, 0.0f, 3.0f);\n    spheresCenter[2] = vec3(0.0f, 1.0f, 4.0f);\n    spheresCenter[3] = lightPosition;\n    \n    vec3 spheresColors[4];\n    \n    spheresColors[0] = vec3(1.0f, 0.0f, 0.0f);\n    spheresColors[1] = vec3(0.0f, 1.0f, 0.0f);\n    spheresColors[2] = vec3(0.0f, 0.0f, 1.0f);\n    spheresColors[3] = vec3(1.0f, 1.0f, 1.0f);\n    \n    float radius[4];\n    radius[0] = 2.0f;\n    radius[1] = 0.5f;\n    radius[2] = 1.0f;\n    radius[3] = 1.0f;\n    vec3 col = ambient * createSpheres(ray, \n                                       spheresCenter,\n                                       spheresColors,\n                                       radius, \n                                       plane, \n                                       uv);\n    // Output to screen\n    \n    vec3 value = 10.0f * texture(iChannel1, fragCoord/iResolution.xy).rbg;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u1 = (fragCoord + vec2(1.0f, 0.0f)) / iResolution.xy;\n    vec2 u2 = (fragCoord - vec2(1.0f, 0.0f)) / iResolution.xy;\n    vec2 v1 = (fragCoord + vec2(0.0f, 1.0f)) / iResolution.xy;\n    vec2 v2 = (fragCoord - vec2(0.0f, 1.0f)) / iResolution.xy;\n    \n    float x1 = texture(iChannel0, u1).r;\n    float x2 = texture(iChannel0, u2).r;\n    float y1 = texture(iChannel0, v1).r;\n    float y2 = texture(iChannel0, v2).r;\n    \n    vec3 tu = vec3(1.0f, x2 - x1, 0.0f);\n    vec3 tv = vec3(0.0f, y2 - y1, 1.0f);\n    \n    vec3 normal = normalize(cross(tv, tu));\n\n    fragColor = vec4(normal,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}