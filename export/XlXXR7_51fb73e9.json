{"ver":"0.1","info":{"id":"XlXXR7","date":"1435134444","viewed":256,"name":"Walking spider","username":"cedric","description":"2015: i coded this a year ago on linux and it was causing the world to crash. I am now on windows and it seems to run smooth so i give it a new try here.\n2018: on a visit here to correct others shaders, new try to publish this one :-)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["perlin","walk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//\n//\n// Spider by cedric voisin 2014\n//\n//\n\n#define PI 3.14\n#define maxH 1.5\n\nstruct leg {\n\tvec3 pHip, pKnee, pAnkle, pFoot;\n\tvec2 rp; // (cosp, sinp)\n};\nleg legs[8];\n\n// perlin\n\nfloat r(vec2 c){\n\treturn fract(sin(dot(c ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat pn (vec2 p){\n\tp/=2.;\n    vec2 i = floor(p), w = fract(p), j = vec2(1.,0.);\n    w = w*w*(3.-2.*w);\n    return mix(mix(r(i), r(i+j), w.x), mix(r(i+j.yx), r(i+1.), w.x), w.y);\n}\n\nfloat an (vec2 p){\n\tconst int n=7;\n\tfloat m = 0., f = 1.;\n\tfor ( int i=0; i<n; i++ ){ m += pn(f*p)/f; f*=2.; }\n\treturn m/(2.-pow(.5,float(n)));\n}\n\n// primitive (from iq's website)\nfloat deC(vec3 p, vec3 a, vec3 b, float r){\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// leg\nfloat deLeg(vec3 p){\n\tfloat sil = 1000.;\n\tfor (int i=0;i<8;i++){\n    \tsil = min(sil, deC(p, legs[i].pHip, legs[i].pKnee, .03));\n    \tsil = min(sil, deC(p, legs[i].pKnee, legs[i].pAnkle, .02));\n    \tsil = min(sil, deC(p, legs[i].pAnkle, legs[i].pFoot, .01));\n\t}\n\treturn sil;\n}\n\nvec3 norLeg(vec3 p){\n\tvec3 dp = vec3(.0001,0.,0.);\n\tvec3 n=normalize(vec3(deLeg(p+dp.xyy),deLeg(p+dp.yxy),deLeg(p+dp.yyx))); \n\treturn n;\n}\n\nfloat field(vec2 f){return maxH*pn(f);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// global\n\tvec2 xy = -2.5 + 5.*fragCoord.xy / iResolution.xy;\n\txy.y *= iResolution.y/iResolution.x;\n\t\n\t// time\t\n\tfloat camTime = .03*iTime;\n\tfloat spiTime = (iTime+cos(.5*iTime)+cos(.4*iTime));\n\t\n\t// spider main\n\tvec3 pSpi, pAbdo;\n\tfloat rBody, rAbdo, rf;\n\trBody = .2;\n\tpSpi = vec3(spiTime,0.,0.);;\n\tpSpi.z = .2+rBody+field(pSpi.xy);\n\t\t\n\t// sun\n\tvec3 pSun = pSpi+vec3(100.*sin(.2*camTime),100.*cos(.2*camTime),100.);\n\t\n\t// cam\n\tfloat xCam, yCam, zCam;\n\tvec3 pCam, nCam, uCam, rCam, pEye;\n\txCam = pSpi.x + 5. * sin(6.*camTime);\n\tyCam = pSpi.y - 5. * cos(6.*camTime);\n\tzCam = max(7. + 2.*cos(camTime-5.), .2+field(vec2(xCam, yCam)) );\n\t//zCam = 4.;\n\t\n\tpEye = vec3(xCam, yCam, zCam);\n\tnCam = normalize(pSpi-pEye);\n\trCam = normalize(vec3(nCam.y,-nCam.x,0.));\n\tuCam = cross(rCam,nCam);\n\tpCam = pEye + 5.*nCam;\n\t\n\t// spider parts\n\t// abdomen\n\trAbdo = 1.7*rBody;\n\tvec3 oldPos = vec3(spiTime-.05,0.,0.);\n\toldPos.z = .22+rBody+field(oldPos.xy);\n\tpAbdo = pSpi-(rBody+rAbdo)*normalize(pSpi - oldPos);\n\t\n\t// directions\n\tvec3 spiF, spiL, spiU;\n\tspiF = normalize(pSpi - pAbdo);\n\tspiL = normalize(vec3(-spiF.y,spiF.x,0.));\n\tspiU = cross(spiF, spiL);\n\t\n\t// eyes co(-pi/32), sin(-pi/32), sin(pi/5)\n\tvec3 pOcelli[2];\n\tpOcelli[0] = pSpi + .7*rBody*spiF + rBody*.1*spiL + rBody*.8*spiU;\n\tpOcelli[1] = pSpi + .7*rBody*spiF - rBody*.1*spiL + rBody*.8*spiU;\n\t\n\t//legs a=hip->knee, b=knee->ankle, c=ankle->foot\n\trf = rBody + 1.35; // 1.35 = leg span\n\tfloat a=.9, b=1., f=.35;\n\n\tfloat rcosp, rsinp, cosa, dt, tf, tc, to, tPct, c;\n\tvec2 pf;\n\tvec3 base, up;\n\t\n\t//defined manually to get them out of the loop and avoid cos/sin calls\n\tlegs[0].rp =  vec2(-.588,-.809); // vec2(cos(-PI/5.-3.*PI/6.),sin(-PI/5.-3.*PI/6.));\n\tlegs[1].rp =  vec2(-.105,-.995); // vec2(cos(-PI/5.-2.*PI/6.),sin(-PI/5.-2.*PI/6.));\n\tlegs[2].rp =  vec2(.407,-.914); // vec2(cos(-PI/5.-PI/6.),sin(-PI/5.-PI/6.));\n\tlegs[3].rp =  vec2(.809, -.588); // vec2(cos(-PI/5.),sin(-PI/5.));\n\tlegs[4].rp =  vec2(.809,.588); // vec2(cos(PI/5.),sin(PI/5.));\n\tlegs[5].rp =  vec2(.407,.914); // vec2(cos(PI/5.+PI/6.),sin(PI/5.+PI/6.));\n\tlegs[6].rp =  vec2(-.105,.995); // vec2(cos(PI/5.+2.*PI/6.),sin(PI/5.+2.*PI/6.));\n\tlegs[7].rp =  vec2(-.588,.809); // vec2(cos(PI/5.+3.*PI/6.),sin(PI/5.+3.*PI/6.));\n\t\n\tfor (int i=0;i<8;i++){\n\t\t\n\t\t// hip\t\n\t\tlegs[i].pHip = pSpi + rBody*legs[i].rp.x*spiF + rBody*legs[i].rp.y*spiL;\n\n\t\t// foot\n\t\tdt = mod(float (i),2.)*.5;\n\t\ttf = spiTime+dt+.3; // .3 = how much foot precedes body (tuning)\n\t\ttc = fract(tf);\n\t\tto = floor(tf);\n\t\trcosp = rf*legs[i].rp.x;\n\t\trsinp = rf*legs[i].rp.y;\n\t\t\n\t\t// cycle: .67s on the ground, .33s to catch up\n\t\tif (tc < .67){\n\t\t\tpf = vec2(to-dt+rcosp,rsinp);\n\t\t\tlegs[i].pFoot = vec3(pf, field(pf));\n\t\t} else {\n\t\t\ttPct = (tc-.67)/.33;\n\t\t\tpf = vec2(to-dt+tPct*tc+rcosp,rsinp);\n\t\t\tlegs[i].pFoot = vec3(pf, field(pf.xy)+2.5*tPct*(1.-tPct)); // parabola 2.5~step height\n\t\t}\n\t\t\n\t\t// ankle: cos(foot angle) ~ distance from the hip\n\t\tbase = legs[i].pHip-legs[i].pFoot;\n\t\tup = normalize(cross(vec3(base.y,-base.x,0.),base));\n\t\tcosa = cos( 2.8*(1.-length(base)/(a+b+f)) ); // amax+base*(amin-amax)/(a+b+f), amin = 0, amax=2.8\n\t\tlegs[i].pAnkle = legs[i].pFoot + cosa*f*normalize(base) + sqrt(1.-cosa*cosa)*f*up; \n\n\t\t// knee\t(triangle)\n\t\tbase = legs[i].pAnkle - legs[i].pHip;\n\t\tup = normalize(cross(vec3(base.y,-base.x,0.),base));\n\t\tc = length(base);\n\t\tcosa = (a*a+c*c-b*b)/(2.*a*c);\n\t\tlegs[i].pKnee = legs[i].pHip + cosa*a*normalize(base) + sqrt(1.-cosa*cosa)*a*up;\n\t}\n\t\n\t// virtual screen\n\tvec3 pStart = pCam+xy.x*rCam+xy.y*uCam;\n\tvec3 dir = normalize(pStart-pEye);\n\t\n\t// ray march\n\tint idI = 0; //Background 0, Terrain 1, Body 2, Abdo 3, Leg 4, eyes 5\n\tfloat eps = .001, fov = 30., de = fov, si = 10.*fov, shad = 1., s = 0., h = 1.;\n\tvec3 npi = -dir, pi = pEye, dp = vec3(.0001,0.,0.);\n\tfloat dpx, dpy;\n\t\n\tfor (int i=0; i<150; i++){\n\t\t\t\n\t\t// body\n\t\tde = min(de, clamp(length(pi-pSpi)-rBody,eps,fov));\n\t\tif (de == eps) {si = s; idI = 2; break;}\n\t\t// abdomen\n\t\tde = min(de, clamp(length(pi-pAbdo)-rAbdo,eps,fov));\n\t\tif (de == eps) {si = s; idI = 3; break;}\n\t\t// eyes\n\t\tde = min(de, clamp(length(pi-pOcelli[0])-.1*rBody,eps,fov));\n\t\tif (de == eps) {si = s; idI = 5; break;}\n\t\tde = min(de, clamp(length(pi-pOcelli[1])-.1*rBody,eps,fov));\n\t\tif (de == eps) {si = s; idI = 5; break;}\n\t\t// legs\t\n\t\tde = min(de, clamp(deLeg(pi),eps,fov));\n\t\tif (de == eps) {si = s; idI = 4; break;}\n\t\t// terrain\n\t\th = pi.z - field(pi.xy);\n\t\tif (h<.01) {si = s; idI = 1; break;}\n\t\t\n\t\ts += min(de,.5*h);\n\t\tif (s > fov) break;\n\t\tpi = pEye + dir*s;\n\n\t}\t\n\t\n\t// common colors\n\tvec3 col, co, li;\n\tvec3 colSky = vec3(.8,.7,.6);\n\tvec3 colSun = vec3 (1.,1.,.7);\n\t\n\t// illuminations\n\tif (idI == 0){ // background\n\t\t\n\t\t//base\n\t\tco = vec3(0.,0.,0.);\n\t\tfloat vGrad=clamp(1.5-fragCoord.y / iResolution.y,0.,1.);\n\t\tco += vGrad*colSky;\n\t\t\n\t\t// lightning\n\t\tli = vec3(0.,0.,0.);\n\t\tfloat sunGrad = 1.+dot(normalize(pSun-pEye), normalize(pi-pEye) );\n\t\tli += (1.+sunGrad)*colSun;\n\t\t\n\t\tcol = co*li;\n\t}\n\t\n\tif (idI == 1){ // terrain\n\t\tdpx = maxH * (an(pi.xy+dp.xy)-an(pi.xy-dp.xy)) / (2.*dp.x);\t\t\t\t\t\t\t  \n\t\tdpy = maxH * (an(pi.xy+dp.yx)-an(pi.xy-dp.yx)) / (2.*dp.x);\n\t\tnpi = normalize( vec3(-dpx, -dpy, 1.) );\t\n\t\tpi = pEye + dir*si;\n\t\t\n\t\t// base\n\t\tco = vec3(0.,0.,0.);\n\t\tvec3 colField = vec3(.62,.6,.6);\n\t\tco += colField;\n\t\t\n\t\t// occlusion\n\t\tfloat iOcc = npi.z;\n\t\t\n\t\t// spider occlusion\n\t\tfloat sOcc = smoothstep(0., .8, length(pi-.5*pSpi-.5*pAbdo)/rf );\n\t\t\n\t\t// lightning\n\t\t// spider shadows\n\t\tfloat sShad = 1., tShad = 1.;\n\t\tdir = normalize(pSun-pi);\n\t\tde = fov;\n\t\tvec3 ps = pi;\n\t\ts = 0.;\n\t\tfor (int i=0; i<50; i++){\n\t\t\ttShad = 1.;\n\t\t\t// body\n\t\t\tde = min(de, clamp(length(ps-pSpi)-rBody,eps,fov));\n\t\t\tde = min(de, clamp(length(ps-pAbdo)-rAbdo,eps,fov));\n\t\t\tde = min(de, clamp(deLeg(ps),eps,fov));\n\t\t\t\n\t\t\ts += de;\n\t\t\tif (ps.z > pSpi.z+5.) break;\n\t\t\tps = pi + dir*s;\n\t\t\ttShad = min(tShad, 60.*de/s);\n\t\t\tsShad *= tShad;\n\t\t}\t\n\t\t\n\t\tfloat iDif = dot(npi,normalize(pSun-pi));\n\n\t\tli = vec3(0.,0.,0.);\n\t\tli += iDif*colSun;\n\t\tli *= sShad;\n\t\tli *= sOcc;\n\t\tli += .8*iOcc*colSky;\n\t\t\n\t\tcol = co*li;\n\t}\n\t\n\tif (idI == 2){ // body\n\t\tnpi = normalize(pi-pSpi);\n\n\t\t// base\n\t\tco = vec3(0.,0.,0.);\n\t\tvec3 colBase = vec3 (.9,.6,.2);\n\t\tco += colBase;\n\t\t\t\n\t\t// dark below\n\t\tco = mix(.4*colBase, co,smoothstep(-.4,1.,dot(npi,spiU)) );\n\t\t\n\t\t// occlusion\n\t\tfloat iOcc = .5 + .5*dot(npi,spiF);\n\t\t\n\t\t// lightning\n\t\tfloat iAmb = .5+.5*npi.z;\n\t\tfloat iDif = .5+.5*dot(npi,normalize(pSun-pi));\n\t\t\n\t\tli = vec3(0.,0.,0.);\n\t\tli += iDif*colSun;\n\t\tli += .2*iAmb*colSky;\n\t\tli *= iOcc;\n\n\t\tcol = 2.*co*li;\n\t}\n\t\n\tif (idI == 3){ // abdomen\n\t\tvec3 piInA = vec3(dot(pi-pAbdo,spiF), dot(pi-pAbdo,spiL), dot(pi-pAbdo,spiU));\n\t\tnpi = normalize(pi-pAbdo);\n\n\t\t// base\n\t\tco = vec3(0.,0.,0.);\n\t\tvec3 colBase = vec3 (.9,.5,.1);\n\t\tco += colBase;\n\t\t\n\t\t// decoration (black)\n\t\tfloat theta = acos(piInA.x/length(piInA));\n\t\tfloat phi = .2+abs(atan(piInA.y, piInA.z)); // abs for symmetry\n\t\tco *= 1.05-smoothstep(.5,.5,an(4.*vec2(theta, phi)));\n\t\tco = mix(.9*colBase, co,smoothstep(-.4,1.,dot(npi,spiU)) );\n\t\t\n\t\t// occlusion\n\t\tfloat iOcc = .5-.5*dot(npi,spiF);\n\t\t\n\t\t// lightning\n\t\tfloat iAmb = .5+.5*npi.z;\n\t\tfloat iDif = dot(npi,normalize(pSun-pi));\n\t\t\n\t\tli = vec3(0.,0.,0.);\n\t\tli += .07*iDif*colSun;\n\t\tli += .2*iAmb*colSky;\n\t\tli *= iOcc;\n\n\t\tcol = 12.*co*li;\n\t}\n\t\n\tif (idI == 4){ // legs\n\t\tnpi = norLeg(pi);\n\t\t\n\t\t// base\n\t\tco = vec3(0.,0.,0.);\n\t\tvec3 colBase = vec3 (.6,.4,.1);\n\t\tco += colBase;\n\t\t\t\n\t\t// black articulations\n\t\tfloat iArt = 2.*rf;\n\t\tfor (int i=0;i<8;i++){\n\t\t\tiArt = min(iArt, length(pi-legs[i].pKnee));\n\t\t\tiArt = min(iArt, length(pi-legs[i].pAnkle));\n\t\t}\n\t\tco *= 10.*iArt*iArt*iArt;\n\t\t\n\t\t// occlusion\n\t\tfloat iOcc = length(pi-pSpi)/rf;\t\n\t\t\n\t\t// lightning\n\t\tfloat iAmb = .5+.5*npi.z;\n\t\tfloat iDif = dot(npi,normalize(pSun-pi));\n\t\t\n\t\tli = vec3(0.,0.,0.);\n\t\tli += iDif*colSun;\n\t\tli += iAmb*colSky;\n\t\tli *= 2.*iOcc;\n\n\t\tcol = co*li;\n\t}\n\t\n\tif (idI == 5){ // eyes\n\t\tcol = vec3(0.,0.,0.);\n\t}\n\t\n\t// fog\n\tvec3 colFog = vec3(.5,.6,.7);\n\tfloat cFog = 1.-smoothstep(.3*fov, fov, length(dir*si))+smoothstep(fov, 1.1*fov,length(dir*si));\n    col = mix(colFog, col, cFog );\n\n\tcol = clamp(col,0.,1.);\n\tfragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}