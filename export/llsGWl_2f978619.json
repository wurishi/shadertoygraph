{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\n\n#define PI 3.14159265358979\n\nint windows = 0;\nvec2 m = vec2(.7,.8);\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*5.78) * 43758.236237153);\n}\n\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 hash2b( vec2 p )\n{\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(q)*43758.5453)-.5;\n}\n\n\nmat2 m2= mat2(.8,.6,-.6,.8);\n\n// Gabor/Voronoi mix 3x3 kernel (some artifacts for v=1.)\nfloat gavoronoi3(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float f = 2.*PI;//frequency\n    float v = .8;//cell variability <1.\n    float dv = .4;//direction variability <1.\n    vec2 dir = m;//vec2(.7,.7);\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j)-.5;\n        vec2 h = hash2(ip - o);\n        vec2 pp = fp +o  -h;\n        float d = dot(pp, pp);\n        float w = exp(-d*4.);\n        wt +=w;\n        h = dv*h+dir;//h=normalize(h+dir);\n        va += cos(dot(pp,h)*f/v)*w;\n\t}    \n    return va/wt;\n}\n\n\n// Gabor/Voronoi mix 4x4 kernel (clean but slower)\nfloat gavoronoi4(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    vec2 dir = m;// vec2(.9,.7);\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\n    float v = 1.;//cell variability <1.\n    float dv = .7;//direction variability <1.\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-2; i<=1; i++) \n\tfor (int j=-2; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j);\n        vec2 h = hash2(ip - o);\n        vec2 pp = fp +o  -v*h;\n        float d = dot(pp, pp);\n        float w = exp(-d*2.);\n        wt +=w;\n      \th= dv*h+dir;//h=normalize(h+dir);\n        va +=cos(dot(pp,h)*f)*w;\n\t}    \n    return va/wt;\n}\n\n// Gabor/Voronoi mix 5x5 kernel (even slower but suitable for large wavelets)\nfloat gavoronoi5(in vec2 p) \n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float f = 2.*PI;//frequency\n    float v = .8;//cell variability <1.\n    float dv = .8;//direction variability <1.\n    vec2 dir = m;//vec2(.7,.7);\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-2; i<=2; i++) \n\tfor (int j=-2; j<=2; j++) \n\t{\t\t\n        vec2 o = vec2(i, j)-.5;\n        vec2 h = hash2(ip - o);\n        vec2 pp = fp +o  -h;\n        float d = dot(pp, pp);\n        float w = exp(-d*1.);\n        wt +=w;\n        h = dv*h+dir;//h=normalize(h+dir);\n        va += cos(dot(pp,h)*f/v)*w;\n\t}    \n    return va/wt;\n}\n\n  \n\n//concentric waves variant\nfloat gavoronoi3b(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float f = 5.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\n    float v = 1.;//cell variability <1.\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j)-.5;       \t\t\n        vec2 pp = fp +o  - v*hash2(ip - o);\n        float d = dot(pp, pp);\n        float w = exp(-d*4.);\n        wt +=w;\n        va +=cos(sqrt(d)*f)*w;\n\t}    \n    return va/wt;\n}\n\n\n\nfloat noise( vec2 p)\n{   \n    return gavoronoi4(p);\n}\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<6;i++){\t\n\t\tr += abs(noise( p*f ))/f;       \n\t    f *=2.2;\n        p+=vec2(-.01,.07)*r+.2*m*iTime/(.1-f);\n\t}\n\treturn r;\n}\n\nfloat fbm( vec2 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += noise( p*f )/f;       \n\t    f *=2.;\n        p+=vec2(.01,-.05)*r+.2*m*iTime/(.1-f);\n\t}\n\treturn r;\n}\n\nfloat map(vec2 p){\n\n    if(windows==0)return noise(p*10.);\n    if(windows==1)return 2.*abs( noise(p*10.));\n\tif(windows==2)return fbm(p)+1.;\n    return 1.-fbmabs(p);\n}\n\nvec3 nor(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn -normalize(vec3(\n\t\tmap(p + e.xy) - map(p - e.xy),\n\t\tmap(p + e.yx) - map(p - e.yx),\n\t\t.15));\n}\n\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p = 2.*fragCoord.xy /iResolution.xy-1.;\n    \n\tif(p.y>0.){\n    \tif(p.x>0.)windows =1;\n    \telse    windows =0;}\n    else{\n    \tif(p.x>0.)windows =3;\n        else windows =2;}\n    //comment the following line to see windows\n    windows =3;\n    \n      \n    if(iMouse.z>0.)m = 2.*iMouse.xy/iResolution.xy-1.;\n   \tp += .2*m*iTime;\n    vec3 light = normalize(vec3(3., 2., -1.));\n\tfloat r;\n    r = max(dot(nor(p), light),0.25);\n    float k=map(p)*.8+.15;\n    fragColor = clamp(vec4(r, r, r, 1.0),0.,1.);\n\tfragColor = clamp(vec4(r*k*k, r*k, r*sqrt(k), 1.0),0.,1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llsGWl","date":"1426253841","viewed":2692,"name":"Gavoronoise","username":"guil","description":"Inspired by Gabor 4: normalized (https://www.shadertoy.com/view/XlsGDs) and\nVoronoise (https://www.shadertoy.com/view/Xd23Dh)\nAn attempt to mix them. Use mouse to change wave direction","likes":89,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","gabor"],"hasliked":0,"parentid":"","parentname":""}}