{"ver":"0.1","info":{"id":"lcj3Rt","date":"1704557336","viewed":51,"name":"Text storage in buffer vs array","username":"MV10","description":"foodini's Font Rendering library, but content is stored in Buffer A to avoid all the annoying OpenGL limitations on arrays. To demonstrate arbitrary rendering of individual text blocks, the current time is shown then hidden at 5-second intervals.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["tools","fonts"],"hasliked":0,"parentid":"cdtBWl","parentname":"000Tools: Font Rendering"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nPlease refer to foodini's original for comments and details about\nthe core functionality: https://www.shadertoy.com/view/cdtBWl\n\nHe has also deprecated that one, although I haven't looked at what functional\nchanges might be in the new one: https://www.shadertoy.com/view/XlGfzt\n\nWith this revision, the content setup work occurs in Buffer A, and there are\nsome new defines and a new function in Common. Refer to the comments in those\ntabs for more details.\n\nThe revision only requires initializing the output location, then calling the\nparse function pointing to the starting cell of the text block to be rendered.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Square pixel space. uv.x -> [-1.0..1.0]\n    vec2 uv = 2.0*fragCoord/iResolution.xy-1.0;\n    uv.y *= iResolution.y/iResolution.x;\n\n    // Default pixel is Ghost of Britney\n    fragColor = texture(iChannel2, fragCoord/iResolution.xy).xxxx * 0.15;\n\n    /* Original foodini program:\n    \n    init_printing(vec2(-0.8, -0.2), 0.08);\n    \n    int[] Strings = int[](_INTEGRAL, _PLUS, _REGISTERED, _GNAB, _pi, _SIGMA, _CONTOUR_INTEGRAL);\n    int[] iTime_str = int[](_i, _T, _i, _m, _e, _COLON);\n    int[] iFrame_str = int[](_i, _F, _r, _a, _m, _e, _COLON);\n    fragColor += print(iChannel0, iTime_str, uv).xxxx;\n    fragColor += print(iChannel0, iTime, uv, 3).xxxx;\n    newline();\n    fragColor += print(iChannel0, iFrame_str, uv).xxxx;\n    fragColor += print(iChannel0, iFrame, uv).xxxx;\n    newline();\n    fragColor += print(iChannel0, Strings, uv).xxxx;\n    \n    */\n\n    // Reproduce foodini's original output\n    init_printing(vec2(-0.8, -0.2), 0.08);\n    fragColor += parse_buffer(0, 0, uv, iChannel0, iChannel1).xxxx;\n    \n    // Every other five-second interval, show the text block containing the current time\n    if(mod(iTime, 10.) < 5.0)\n    {\n        init_printing(vec2(-0.8, 0.45), 0.08);\n        fragColor += parse_buffer(0, 10, uv, iChannel0, iChannel1).xxxx;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nPlease refer to foodini's original for comments and details about\nthe core functionality: https://www.shadertoy.com/view/cdtBWl\n\nBased on his Version 1.0, 2023.10.23\n\nAll comments in this version are new (mine).\n*/\n\n#define DC(name, val) const int name = val\n\nDC(_NULL,127);\n\nDC(_SPACE,32); DC(_BANG,33); DC(_QUOTE,34); DC(_HASH,35); \nDC(_DOLLAR,36); DC(_PERCENT,37); DC(_AMPERSAND,38); DC(_APOSTROPHE,39); \nDC(_PREN,40); DC(_NERP,41); DC(_STAR,42); DC(_PLUS,43); \nDC(_COMMA,44); DC(_MINUS,45); DC(_PERIOD,46); DC(_SLASH,47);\n\nDC(_0,48); DC(_1,49); DC(_2,50); DC(_3,51);\nDC(_4,52); DC(_5,53); DC(_6,54); DC(_7,55);\nDC(_8,56); DC(_9,57); DC(_COLON,58); DC(_SEMICOLON,59);\nDC(_LFTANGL,60); DC(_EQUAL,61); DC(_RGTANGL,62); DC(_QUESTION,63);\n\nDC(_AT,64); DC(_A,65); DC(_B,66); DC(_C,67); \nDC(_D,68); DC(_E,69); DC(_F,70); DC(_G,71); \nDC(_H,72); DC(_I,73); DC(_J,74); DC(_K,75); \nDC(_L,76); DC(_M,77); DC(_N,78); DC(_O,79); \n\nDC(_P,80); DC(_Q,81); DC(_R,82); DC(_S,83); \nDC(_T,84); DC(_U,85); DC(_V,86); DC(_W,87); \nDC(_X,88); DC(_Y,89); DC(_Z,90); DC(_LFTSQR,91); \nDC(_BACKSLASH,92); DC(_RGTSQR,93); DC(_CARET,94); DC(_UNDERSCORE,95); \n\nDC(_GRAVE,96); DC(_a,97); DC(_b,98); DC(_c,99); \nDC(_d,100); DC(_e,101); DC(_f,102); DC(_g,103); \nDC(_h,104); DC(_i,105); DC(_j,106); DC(_k,107); \nDC(_l,108); DC(_m,109); DC(_n,110); DC(_o,111); \n\nDC(_p,112); DC(_q,113); DC(_r,114); DC(_s,115); \nDC(_t,116); DC(_u,117); DC(_v,118); DC(_w,119); \nDC(_x,120); DC(_y,121); DC(_z,122); DC(_LFTSQUIG,123); \nDC(_PIPE,124); DC(_RGTSQUIG,125); DC(_TILDE,126);\n\nDC(_alpha,128); DC(_beta,129); DC(_gamma,130); DC(_delta,131); \nDC(_epsilon,132); DC(_theta,133); DC(_lambda,134); DC(_mu,135); \nDC(_xi,136); DC(_pi,137); DC(_rho, 138); DC(_sigma,139); \nDC(_tau,140); DC(_phi,141); DC(_psi,142); DC(_omega,143); \n\nDC(_GAMMA,144); DC(_DELTA,145); DC(_THETA,146); DC(_LAMBDA,147); \nDC(_PI,148); DC(_SIGMA,149); DC(_PHI,150); DC(_PSI,151); \nDC(_OMEGA,152); DC(_INFINITY,153); DC(_FORTE,154); DC(_degrees,155); \nDC(_INTEGRAL, 156); DC(_PARTIAL_DIFF, 157); DC(_NABLA,158); DC(_SQRT, 159); \n\n                     DC(_GNAB,161); DC(_CENT,162); DC(_POUND,163); \nDC(_VECTOR_OUT,164); DC(_YEN,165); DC(_BROKEN_PIPE,166); DC(_CONTOUR_INTEGRAL,167); \n                     DC(_COPYRIGHT,169); DC(_superscript_a,170); DC(_LEFT_SHIFT,171); \n                                         DC(_REGISTERED,174); DC(_OVERBAR,175); \n                                         \nDC(_DEGREES, 176); DC(_PLUSMINUS,177); DC(_superscript2,178); DC(_superscript3,179); \nDC(_ACCENT, 180); DC(_MU,181); DC(_PARAGRAPH,182); DC(_DOT,183);\n                  DC(_superscript_1,185); DC(_superscript_0,186); DC(_RIGHT_SHIFT,187); \nDC(_QUARTER,188); DC(_HALF,189); DC(_THREE_QUARTERS,190); DC(_NOITSEUQ,191); \n\n// Control characters\nDC(_EOF, -1);\nDC(_TAB, -8);\nDC(_EOL, -10);\nDC(_DATA_INT, -101);\nDC(_DATA_FLOAT, -102);\n\n// These are internal functions ... \"public\" functions begin at init_printing\n\nvec4 print_char(sampler2D font_channel, int c, float size, vec2 char_pos, vec2 uv) {\n    vec2 font_uv_offset = (uv - char_pos) / size;\n    \n    if(font_uv_offset.x < -1.0 ||\n       font_uv_offset.x >  1.0 ||\n       font_uv_offset.y < -1.0 ||\n       font_uv_offset.y >  1.0) {\n        return vec4(0.0);\n    }\n    \n    float row = float(15 - c/16);\n    float col = float(c%16);\n    \n    const float half_char_width = 1.0/32.0;\n    const float char_width = 1.0/16.0;\n    \n    vec2 font_uv = \n        vec2(half_char_width + char_width * col, half_char_width + char_width * row); \n    font_uv += font_uv_offset * half_char_width;\n    \n    return texture(font_channel, font_uv);\n}\n\nconst float log10 = log(10.0);\n\nint digits(int i) {\n    i = abs(i);\n    int retval = 0;\n    do {\n        retval++;\n        i /= 10;\n    } while(i > 0);\n    return retval;\n}\n\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, bool right, out int count) {\n    vec4 retval = vec4(0.0);\n    bool neg = i<0;\n    i = abs(i);\n    \n    if(!right) {\n        pos.x += size * (float(digits(i) - 1));\n        if(neg) {\n            pos.x += size;\n        }\n    }\n\n    count = 0;\n    do {\n        int c = 48 + i%10;\n        i /= 10;\n        retval += print_char(font_channel, c, size, pos, uv);\n        pos.x -= size;\n        count ++;\n    } while(i > 0);\n\n    if(neg) {\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count++;\n    }\n    return retval;\n}\n\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, bool right) {\n    int _count;\n    return print_int(font_channel, i, size, pos, uv, right, _count);\n}\n\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, bool right, int frac_digits, out int count) {\n    vec4 retval = vec4(0.0);\n    count = 0;\n    bool neg = false;\n\n    if(f < 0.0) {\n        neg = true;\n        f = abs(f);\n    }\n    \n    int frac_int = int(0.001 + fract(f) * pow(10.0, float(frac_digits)));\n    int mant_int = int(f);\n    \n    if(!right) {\n        int width = (neg?1:0) + digits(mant_int);\n        if(frac_digits > 0) {\n            width += 1 + frac_digits;\n        }\n        pos.x += size * float(width-1);\n    }\n    \n    if(frac_digits > 0) {\n        retval += print_int(font_channel, frac_int, size, pos, uv, true, count);\n        pos.x -= size * float(count);\n        while(count < frac_digits) {\n            retval += print_char(font_channel, 48, size, pos, uv);\n            pos.x -= size;\n            count ++;\n        }\n        retval += print_char(font_channel, 46, size, pos, uv);\n        pos.x -= size;\n    }\n    int printed;\n    retval += print_int(font_channel, mant_int, size, pos, uv, true, printed);\n    count += printed;\n    if(neg) {\n        pos.x -= size * float(printed);\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count ++;\n    }\n   \n    return retval;\n}\n\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, bool right, int frac_digits) {\n    int _count;\n    return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n}\n\n// These become internal functions with my revisions\n\nfloat accumulating_left;\nvec2 accumulating_pos;\nfloat accumulating_size;\n\nvoid newline() {\n    accumulating_pos.x = accumulating_left;\n    accumulating_pos.y -= accumulating_size*1.5;\n}\n\nconst float tab_width = 8.0;\n\nvoid tab() {\n    float x = accumulating_pos.x;\n    float printed = (x-accumulating_left)/accumulating_size;\n    float dx = tab_width - mod(printed, tab_width);\n    accumulating_pos.x += accumulating_size * dx;\n}\n\nvec4 print(sampler2D font_channel, int i, vec2 uv) {\n    int printed;\n    vec4 retval;\n    retval = print_int(font_channel, i, accumulating_size, accumulating_pos, uv, false, printed);\n    accumulating_pos.x += float(printed) * accumulating_size;\n    \n    return retval;\n}\n\nvec4 print(sampler2D font_channel, float f, vec2 uv, int frac_digits) {\n    int printed;\n    vec4 retval;\n    retval = print_float(font_channel, f, accumulating_size, accumulating_pos, uv, false, frac_digits, printed);\n    accumulating_pos.x += float(printed+1) * accumulating_size;\n    \n    return retval;\n}\n\n// Begin public functions for use by other buffers\n\nvoid init_printing(vec2 pos, float size) {\n    accumulating_pos = pos;\n    accumulating_left = pos.x;\n    accumulating_size = size;\n}\n\n// Where the magic happens\nvec4 parse_buffer(int textX, int textY, vec2 uv, sampler2D font_channel, sampler2D text_channel)\n{\n    vec4 color = vec4(0);\n    ivec2 cell = ivec2(textX, textY);\n    ivec2 size = textureSize(text_channel, 0) - ivec2(1); // max X,Y\n\n    while(true) {\n    \n        // don't overrun the buffer\n        if(cell.x > size.x)\n        {\n            cell.x = 0;\n            cell.y++;\n        }\n        if(cell.y > size.y) break;\n    \n        // read the cell\n        vec4 data = texelFetch(text_channel, cell, 0);\n        int code = int(data.x);\n        \n        // EOF means the block is finished\n        if(code == _EOF) break;\n        \n        // EOL starts a new line; technically this doesn't have\n        // to start a literal new row in the texture, but using a\n        // 1:1 relationship simplifies things like modifying the\n        // content during the process of buffering the text\n        if(code == _EOL)\n        {\n            newline();\n            cell.x = 0;\n            cell.y++;\n            continue;\n        }\n\n        // read the next column on the next pass\n        cell.x++;\n\n        // fancy!\n        if(code == _TAB)\n        {\n            tab();\n            continue;\n        }\n\n        // this cell has an integer encoded\n        if(code == _DATA_INT)\n        {\n            int i = int(data.y);\n            color += print(font_channel, i, uv);\n            continue;\n        }\n        \n        // this cell has a float encoded\n        if(code == _DATA_FLOAT)\n        {\n            float f = data.y;\n            int d = int(data.z);\n            color += print(font_channel, f, uv, d);\n            continue;\n        }\n        \n        // the cell is a printable character (or should be...)\n        color += print_char(font_channel, code, accumulating_size, accumulating_pos, uv);\n        accumulating_pos.x += accumulating_size;\n    }\n    \n    return color;\n}\n\n/* \nThe hard-coded array-size functions are no longer necessary.\n\n#define DECL_PRINT_STRING(len) \\\nvec4 print(sampler2D font_channel, int c[len], vec2 uv) { \\\n    vec4 retval; \\\n    for(int i=0; i<len; i++) { \\\n        retval += print_char(font_channel, c[i], accumulating_size, accumulating_pos, uv); \\\n        accumulating_pos.x += accumulating_size; \\\n    } \\\n    return retval; \\\n}\n\nDECL_PRINT_STRING(7)\nDECL_PRINT_STRING(6)\nDECL_PRINT_STRING(8)\n*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nOpenGL arrays are limited, to say the least. While foodini's original used a\nclever #define to create entire functions with hard-coded array sizes, that\nwasn't initially obvious to me and it feels clumsy (which is entirely GLSL's\nfault). My stand-alone music visualizer uses a chunk of foodini's code to\nrender text, and because of these array hassles, the text content is passed\nas a 1D texture. I figured I'd kill some time by back-porting a similar setup\nhere on Shadertoy.\n\nBufferA encodes blocks of text data. In theory that's risky since Shadertoy\nbuffer sizes are some arbitrary percentage of the browser window size, or\nwhatever the user's full-screen size happens to be, but realistically (and\nespecially for this demo) the tiny amounts of text never approach the limits.\n\nCharacters and control codes are stored in the X channel. Since the font texture\nhas a \"media skip-to-start\" symbol at position 0, the default is to encode the\n_SPACE character into every cell, rather than vec4(0) as you might expect.\n\nTechnically you could encode this data anywhere in the texture, of course. Here,\nmultiple blocks of text are demonstrated. In this demo there are two blocks. One\nreproduces foodini's original content (iTime, iFrame, and some special characters),\nand the other outputs the hour, minutes, and seconds for five second intervals. The\ncontent is generated here, but the Image tab controls what is actually rendered.\n\nAlthough it would be trivial to just output all of the content on every pass, to\nmake things interesting, frame 0 generates the static content. Only dynamic data\nlike iTime is generated on each render pass. The only hassle here is having to track\nwhere the dynamic output goes in the text grids, but that's true of any console-like\nrow/column text output.\n\nNegative values act as control characters. The end of a text block is vec4(-1).\nEnd of line is vec4(-10) and tab is vec4(-8) because I'm old and that's how Bell\nLabs Teletype Model 33 said it should be (ASCII FTMFW).\n\nOriginally I was going to modify the Common library functions to output character\ndata into this buffer, but instead this encodes integer and float data into the\nbuffers, too. Those are flagged with control codes in the X channel and the value\nis stored in the Y channel. For floats, the decimal precision is in the Z channel.\n\nThe defines could be moved to the Common tab, too, but I thought it was a little\neasier to follow what I've done by putting them here. To use a Common as a library\nin other Shadertoy programs, you'd probably want to move them.\n\nLots of other tricks could be added, but this is complicated enough. I thought\nabout adding styling to the W channel, such as a flag for italics. Since the\nstatic content is preserved from frame-to-frame, other console-like functions\ncould be designed, like a _clearscreen or _clearblock. Maybe some other rainy day.\n*/\n\n// where to begin outputting character data\n#define _buffer_text_at(x,y) cell = ivec2(x,y);\n\n// output a character and increment the column; we could return here when\n// the coords match, but that would prevent later code from modifying the\n// content, as demonstrated by the combination of static and dynamic output\n#define _(code) if(coord == cell) { fragColor = vec4(code, 0, 0, 1); } cell.x++;\n\n// output an EOL and increment the row\n#define _newline _(_EOL) cell.x = 0; cell.y++;\n\n// like a newline, but when additional content is expected (no EOL is stored)\n#define _break cell.x = 0; cell.y++;\n\n// store an integer\n#define _int(value) if(coord == cell) { fragColor = vec4(_DATA_INT, value, 0, 1); } cell.x++;\n\n// store a float\n#define _float(value, decimals) if(coord == cell) { fragColor = vec4(_DATA_FLOAT, value, decimals, 1); }; cell.x++;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 cell = ivec2(0);\n    ivec2 coord = ivec2(fragCoord);\n\n    // Clear buffer on frame 0, subsequent frames default to copying content\n    fragColor = (iFrame == 0) ? vec4(_SPACE, 0, 0, 1) : texelFetch(iChannel0, coord, 0);\n    \n    //-------------------------------------------------------------\n    // Generate static content first frame only\n    \n    if(iFrame == 0)\n    {\n        // Block 1 is the same content in foodini's program\n        // iTime:__#.###\n        // iFrame:_#\n        _buffer_text_at(0, 0)\n        _(_i) _(_T) _(_i) _(_m) _(_e) _(_COLON) _break\n        _(_i) _(_F) _(_r) _(_a) _(_m) _(_e) _(_COLON) _break\n        _(_INTEGRAL) _(_PLUS) _(_REGISTERED) _(_GNAB) _(_pi) _(_SIGMA) _(_CONTOUR_INTEGRAL)\n        _(_EOF)\n        \n        // Block 2 is shown at every other 5 second interval\n        // Hours:___#\n        // Minutes:_#\n        // Seconds:_#.###\n        _buffer_text_at(0, 10)\n        _(_H) _(_o) _(_u) _(_r) _(_s) _(_COLON) _break\n        _(_M) _(_i) _(_n) _(_u) _(_t) _(_e) _(_s) _(_COLON) _break\n        _(_S) _(_e) _(_c) _(_o) _(_n) _(_d) _(_s) _(_COLON) _break\n        _(_EOF)\n    }\n    \n    //-------------------------------------------------------------\n    // Generate dynamic data on all frames\n    \n    // Same as foodini's program\n    _buffer_text_at(8, 0) \n    _float(iTime, 3) _(_EOL)\n    \n    _buffer_text_at(8, 1) \n    _int(iFrame) _(_EOL)\n    \n    // Every other five-second period, show the current time (leading-zero\n    // padding would be nice for hours / minutes, but not important for this demo)\n    int hour = int(iDate.w / 3600.0);\n    int mins = int(mod(iDate.w / 60.0, 60.0));\n    float secs = mod(iDate.w, 60.0);\n    \n    _buffer_text_at(9, 10)\n    _int(hour) _(_EOL)\n\n    _buffer_text_at(9, 11)\n    _int(mins) _(_EOL)\n    \n    _buffer_text_at(9, 12)\n    _float(secs, 3) _(_EOL)\n    \n}\n","name":"Buffer A","description":"","type":"buffer"}]}