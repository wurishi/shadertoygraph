{"ver":"0.1","info":{"id":"MXK3Rd","date":"1718144226","viewed":118,"name":"Slime Mold 0 - DJ","username":"DjBlueBear","description":"A simulation of slime mold inspired by Sebastian Lague's video on slime mold and ant colony simulation","likes":9,"published":3,"flags":32,"usePreview":0,"tags":["simulation","slimemold","slimemold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float red =  texelFetch(iChannel3, ivec2(KEY_1,0.0), 0).x > 0.5 ? 0.0 : 1.0;\n    //float green = texelFetch(iChannel3, ivec2(KEY_2,0.0), 0).x > 0.5 ? 0.0 : 1.0;\n    //float blue = texelFetch(iChannel3, ivec2(KEY_3,0.0), 0).x > 0.5 ? 0.0 : 1.0;\n    vec4 bufferA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //vec4 bufferB = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    //vec4 bufferC = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    \n    //fragColor = vec4(bufferA.w * red, bufferB.w * green,bufferC.w * blue,0.0);\n    fragColor = vec4(bufferA.w * red,0.0,0.0,0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct agent{\n    vec2 pos;\n    float angle;\n};\n\nconst float pi = 3.141592653;\nconst float deg2Rad = pi / 180.0;\n\nuint hash(inout uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat rand(inout uint seed)\n{\n    return fract(float(hash(seed))/ 4294967296.0);//4294967296 2 ^ 32 / 32 bit unsigned integer limit\n}\n\nfloat randNorm(inout uint seed)\n{   \n    float theta = 2.0 * pi * rand(seed);\n    float rho = sqrt( -2.0 * log(rand(seed)));\n    return rho * cos(theta);\n}\n\nvec3 randVec3(inout uint seed)\n{\n    float rand0 = rand(seed);\n    float rand1 = rand(seed);\n    float rand2 = rand(seed);\n\n    return vec3(rand0, rand1, rand2);\n}\n\nvec3 randVec3Norm(inout uint seed)\n{\n    float rand0 = randNorm(seed);\n    float rand1 = randNorm(seed);\n    float rand2 = randNorm(seed);\n\n    return normalize(vec3(rand0, rand1, rand2));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float seedOffset = 0.0;\n\nconst uint agentNum = 4000u;\n\nconst float decayRate = 1.01;//keep above 1, 1.03 is good\n\nconst float agentTrailWeight = 4.0;\n\nconst float sensorSize = 0.1;//keep low for good preformance\n\nconst float sensorForwardBias = 1.0;\n\nconst float sensorDistance = 2.0;//keep same or some factor of sensorSize\n\nconst float sensorGap = 2.0;\n\nconst float randomWalk = 0.01;\n\nconst float angleLimit = 3.0;//this is not in degrees or radians, it is not a measure of angle, check the code to see what it is\n//the higher this number is the narrower the angle the agents can move ( keep at 16.0)\nconst vec2 startingPos = vec2(0.5,0.5);\n\nconst float startingRad = 64.0;\n\nconst float maxInfluence = 1.0;\n\n//Paramaters ^^^^^^^^^^^^^^^^^^^^\n\nvec2 loopCheck(in vec2 p)\n{\n    return mod(p, iResolution.xy);\n}\n// xy agent pos, z agent angle, w trail,\nvoid updateAgent(inout agent current, inout uint seed)\n{\n    float angle = current.angle;\n\n    vec2 forward = vec2(cos(angle), sin(angle));\n\n    vec2 right = vec2(forward.y, -forward.x);\n\n    current.pos += forward;\n    \n    current.pos = mod(current.pos, iResolution.xy);\n    \n    vec2 pos = current.pos;\n    \n    vec2 forwardOffset = forward * (sensorDistance + sensorForwardBias);\n    vec2 rightOffset = right * sensorGap + forward * sensorDistance;\n    vec2 leftOffset = -right * sensorGap + forward * sensorDistance;\n\n    float forwardSample = 0.0;\n    float rightSample = 0.0;\n    float leftSample = 0.0;\n\n    float sensorCount = 0.0;\n    for(float x = -sensorSize / 2.0; x < sensorSize / 2.0; x+= max(1.0, sensorSize / 8.0))\n    {\n        for(float y = -sensorSize / 2.0; y < sensorSize / 2.0; y+= max(1.0, sensorSize / 8.0))\n        {\n            sensorCount += 1.0;\n            forwardSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + forwardOffset + vec2(x,y)))), 0).w;\n            rightSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + rightOffset + vec2(x,y)))), 0).w;\n            leftSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + leftOffset + vec2(x,y)))), 0).w;\n        }\n    }\n\n    forwardSample /= sensorCount;\n    rightSample /= sensorCount;\n    leftSample /= sensorCount;\n    \n    float forwardWeight = 1.0 + max(forwardSample, maxInfluence); \n\n    float rightWeight = max(rightSample, maxInfluence) - max(leftSample, maxInfluence);\n\n    float randomAngle = (rand(seed) * 2.0 - 1.0) * pi * randomWalk;\n\n    current.angle -= clamp(rightWeight / forwardWeight, -pi / (1.0 + angleLimit), pi / (1.0 + angleLimit)) + randomAngle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float safeFrame = mod(float(iFrame + 1) + iDate.w, 1000.0);//(to avoid overflow of the seed)\n    uint seed = uint((fragCoord.x * iResolution.y + fragCoord.y) * safeFrame + seedOffset);\n    \n    uint id = uint(floor(fragCoord.y) * iResolution.x + floor(fragCoord.x));\n\n    vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    float trail = buffer.w / decayRate;\n\n    for(uint i = 0u; i < agentNum; i++)\n    {\n        float x = mod(float(i), iResolution.x);\n        float y = floor(float(i) / iResolution.x);\n        vec2 pos = texelFetch(iChannel0, ivec2(x,y), 0).xy;\n        \n        if(floor(pos) == floor(fragCoord))\n        {\n            trail += agentTrailWeight;\n        }\n    }\n\n    if(id > agentNum)\n    {\n        fragColor = vec4(0.0,0.0,0.0,trail);\n        return;\n    }\n\n    if(iFrame == 1)\n    {\n        float angle = rand(seed) * pi * 2.0;\n        float dist = sqrt(rand(seed)) * startingRad;\n        vec2 pos = vec2(dist * cos(angle),dist * sin(angle)) + startingPos * iResolution.xy;\n        fragColor = vec4(pos,rand(seed) * 2.0 * pi,0.0);\n        return;\n    }\n    \n    agent current = agent(buffer.xy, buffer.z);\n\n    updateAgent(current, seed);\n\n    fragColor = vec4(current.pos,current.angle,trail);\n}","name":"Buffer A","description":"","type":"buffer"}]}