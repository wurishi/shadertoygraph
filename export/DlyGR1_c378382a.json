{"ver":"0.1","info":{"id":"DlyGR1","date":"1683523625","viewed":88,"name":"Multi Level Halftone Shading","username":"xionchannel","description":"Shading with halftone.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["halftoneshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//HSV include begin\n//https://www.shadertoy.com/view/wt23Rt\n//Hue to RGB (red, green, blue).\n//Source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\n//HSV (hue, saturation, value) to RGB.\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\n//RGB to HSV.\n//Source: https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 rgb2hsv(vec3 c) {\n\tfloat cMax=max(max(c.r,c.g),c.b),\n\t      cMin=min(min(c.r,c.g),c.b),\n\t      delta=cMax-cMin;\n\tvec3 hsv=vec3(0.,0.,cMax);\n\tif(cMax>cMin){\n\t\thsv.y=delta/cMax;\n\t\tif(c.r==cMax){\n\t\t\thsv.x=(c.g-c.b)/delta;\n\t\t}else if(c.g==cMax){\n\t\t\thsv.x=2.+(c.b-c.r)/delta;\n\t\t}else{\n\t\t\thsv.x=4.+(c.r-c.g)/delta;\n\t\t}\n\t\thsv.x=fract(hsv.x/6.);\n\t}\n\treturn hsv;\n}\n//Source: https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 rgb2hsv_2(vec3 c){\n\tvec4 K=vec4(0.,-1./3.,2./3.,-1.),\n\t     p=mix(vec4(c.bg ,K.wz),vec4(c.gb,K.xy ),step(c.b,c.g)),\n\t     q=mix(vec4(p.xyw,c.r ),vec4(c.r ,p.yzx),step(p.x,c.r));\n\tfloat d=q.x-min(q.w,q.y),\n\t      e=1e-10;\n\treturn vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\n//HSV include end\n\n//Multi Level Halftone Shading\n#define PI 3.1415\n#define PI2 (PI * 2.0)\n#define DEG2RAD  (PI / 180.0)\n#define DOT_SCALE 300.0\n#define UV_ROT 60.0\n#define SHADING_LEVELS 2.0\n#define DEBUG_GRAD 0\n#define CONTRAST_BOOST 0.0\n#define USE_SDF 0\n//#define USE_AMITEN_SIZE 1\n#define USE_LINE_SHADING 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool useAmitenSize = (iMouse.z < 0.5); // Mouse Click for change shading mode (NoClicking=HalftoneSizeForShading, Clicking=HalftoneFadingForShading)\n\n    // Luminance for shading\n    vec2 screenUV = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, screenUV);\n    #if DEBUG_GRAD\n    float lum = sin((fragCoord.x*10.0)/iResolution.x) * 0.5 + 0.5;\n    col.rgb = vec3(lum);\n    #else\n    float lum = dot(col.rgb, vec3(0.299, 0.587, 0.114));\n    #endif\n    \n    float rot = UV_ROT * DEG2RAD;\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y) * DOT_SCALE;\n    \n    // UV rotation\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2x2 rotMatrix = mat2x2(c, -s, s, c);\n    uv *= rotMatrix;\n\n    // Shading with dot\n    #if !USE_SDF\n    vec2 f = sin(uv) * 0.75;\n    #endif\n    #if USE_LINE_SHADING\n    float ami = f.x * 0.25 + 0.5;\n    #else\n    #if USE_SDF\n    vec2 f = fract(uv / PI2 + 0.5);\n    vec2 f2 = fract(uv / PI2);\n    float d = distance(f, vec2(.5,.5));\n    float d2 = 1.0 - distance(f2, vec2(.5,.5));\n    //float ami = d * 1.414;//smoothstep(d,1.,.5);\n    float ami = mix(d, d2, d);\n    #else\n    float ami = (f.x + f.y + 2.0) * 0.25;\n    #endif\n    #endif\n    \n    // Multi Level Shading\n    float shadingBrightness = 0.0;\n    float shadingLevels = useAmitenSize ? SHADING_LEVELS : 1.0;\n    lum *= shadingLevels;\n    for (float i=0.0; i<shadingLevels; i++)\n    {\n        float shadingColor = 1.0 / shadingLevels * (i + 1.0);\n        float l = clamp(lum - i, 0.0, 1.0);\n\n        float d;\n        if (useAmitenSize)\n        {\n            //d = (l > -0.001) ? step(ami, l) : step(l, ami); // Shading with halftone size\n\n            // anti-alias from below PDF\n            // OpeStefan Gustavson. 2012. “Procedural Textures in GLSL”. Linköping University Electronic PressnGL Insights, Chapter 7\n            // https://www.diva-portal.org/smash/get/diva2:618262/FULLTEXT02.pdf\n            float w = length(vec2(dFdx(ami), dFdy(ami)));\n            d = smoothstep(ami-w, ami+w, l);\n        }\n        else\n        {\n            l = 1.0 - abs(l * 2.0 - 1.0);\n            d = l * step(ami, 0.3); // Shading with halftone fading\n        }\n\n        shadingBrightness = max(shadingBrightness, shadingColor * d);\n    }\n    \n    // HSV brightness from Halftone\n    vec3 hsv = rgb2hsv(col.rgb);\n    //hsv.g = 0.0; // for debug\n    if (useAmitenSize)\n    {\n        float a = mix(hsv.b * 1.1, shadingBrightness, 0.5);\n        float b = clamp(hsv.b * 0.6 + shadingBrightness * 0.6, 0.0, 1.0);\n        hsv.b = mix(a, b, CONTRAST_BOOST);\n    }\n    else\n    {\n        float a = clamp(hsv.b * 0.85 + shadingBrightness * 0.25, 0.0, 1.0);\n        float b = clamp(hsv.b + shadingBrightness * 0.4, 0.0, 1.0);\n        hsv.b = mix(a, b, CONTRAST_BOOST);\n    }\n    fragColor.rgb = hsv2rgb(hsv);\n    fragColor.a = 1.0;\n    \n    // Dual View\n    if (screenUV.x * iResolution.x < iMouse.x)\n    {\n        fragColor.rgb = col.rgb;\n    }\n}\n","name":"Image","description":"","type":"image"}]}