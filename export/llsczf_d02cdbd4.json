{"ver":"0.1","info":{"id":"llsczf","date":"1506042681","viewed":334,"name":"Domain Warp Planet","username":"dmemes","description":"planet with domain warped noise for heights, and an inscattering atmosphere.","likes":9,"published":1,"flags":1,"usePreview":0,"tags":["noise","planet","domainwarp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 lightDirection = normalize(vec3(-.5, -.1, 0.0));\nconst vec3 betaR = vec3(.38, 1.35, 3.31);\nconst vec3 betaM = vec3(2.1);\n\n#define ATMOSPHERE 1\n\n#define innerRadius 1.0\n#define atmoRadius 1.175\n#define waterLevel .45\n\n#define Hr .1332333\n#define Hm .02\n#define g .76\n\n#define PI 3.14159265359\n#define gamma 2.2\n#define invgamma 1.0 / gamma\n\n#define hash(a) fract(sin(a)*12345.0) \nfloat noise(vec3 x, float c1, float c2) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*c2+ c1*p.z;\n    return mix(\n        mix(\n            mix(hash(n+0.0),hash(n+1.0),f.x),\n            mix(hash(n+c2),hash(n+c2+1.0),f.x),\n            f.y),\n        mix(\n            mix(hash(n+c1),hash(n+c1+1.0),f.x),\n            mix(hash(n+c1+c2),hash(n+c1+c2+1.0),f.x),\n            f.y),\n        f.z);\n}\nfloat noise(vec3 p){\n\n\tfloat a = noise(p, 883.0, 971.0);\n\tfloat b = noise(p + 0.5, 113.0, 157.0);\n\treturn (a + b) * 0.5;\n}\nfloat map4( in vec3 p ) {\n\tfloat f;\n    f  = 0.50000*noise( p ); p = p*2.02;\n    f += 0.25000*noise( p ); p = p*2.03;\n    f += 0.12500*noise( p ); p = p*2.01;\n    f += 0.06250*noise( p );\n\treturn clamp(f, 0.0, 1.0);\n}\n\nfloat height(vec3 dir){\n    float h;\n    \n    if (abs(dir.y) > innerRadius * .9){\n        dir += 10.0;\n        h = map4(dir * 3.0+ map4(dir * 5.0) * (sin(iTime)*.5+.5)*1.5);\n        h = clamp(h + waterLevel * .2, 0.0, 1.0);\n    }else\n        h = map4(dir * 3.0+ map4(dir * 5.0) * (sin(iTime)*.5+.5)*1.5);\n    \n\treturn h;\n}\n\nvec2 map(vec3 pos){\n    float l = length(pos);\n    float h = height(pos / l);\n    float rh = max(.45, h);\n\treturn vec2(l - (1.0 + .2 * rh), h);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 getGroundColor(vec3 pos, float h){\n    vec3 normal = calcNormal(pos);\n    float light = clamp(dot(-lightDirection, normal), 0.0, 1.0);\n    \n    float n = dot(normal, normalize(pos));\n    \n    light += pow(normal.y * .5 + .5, 2.0) * .01; // ambient\n    \n    vec3 col = vec3(0.0);\n    \n    float l = h - waterLevel;\n    if (l < 0.0)\n        // water\n    \tcol = mix(vec3(0.3, 0.6, 1.0), vec3(0.0, 0.0, 1.0), clamp(pow(-l*25.0, 3.0), 0.0, 1.0));\n    else{\n        // land\n        \n        // poles\n        if (abs(pos.y) > innerRadius * .9)\n            col = vec3(1.0);\n        else{\n            if (l < 0.02)\n                col = vec3(0.9, 0.85, 0.8); // sand\n            else if (l < .2){\n                if (n < .95)\n                    col = vec3(.2, .2, .2); // rock\n                else\n                    col = vec3(0.0, 0.55, 0.02); // grass\n            } else{\n                if (n < .95)\n                    col = vec3(.2); // rock\n                else\n                    col = vec3(1.0); // snow\n            }\n        }\n    }\n    \n    return col * light;\n}\n\nvec2 raySphere(in vec3 ro, in vec3 rd, in float rad) {\n\tfloat b = 2.0 * dot(ro, rd);\n    float c = dot(ro,ro) - rad*rad;\n    float det = b*b - 4.0 * c;\n    if (det > 0.0){\n        det = sqrt(det);\n    \treturn vec2(0.5 * (-b - det), 0.5 * (-b + det));\n    }\n    return vec2(-1.0, -1.0);\n}\n\nvec3 sampleAtmosphere(vec3 ro, vec3 rd, float start, float end){\n\tfloat scale = 1.0 / (atmoRadius - innerRadius);\n    \n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float odr = 0.0;\n    float odm = 0.0;\n    \n\tfloat mu = dot(rd, -lightDirection);\n\tfloat phaseM = 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + mu * mu)) / ((2.0 + g*g) * pow(1.0f + g*g - 2.0 * g * mu, 1.5));\n\tfloat phaseR = 3.0 / (16.0 * PI) * (1.0 + mu * mu);\n    \n    float t = start;\n    float slength = (end - start) * (1.0 / 6.0);\n    float scaledLength = (end - start) * scale;\n    vec3 pos;\n    for (int i = 0; i < 6; i++){\n        pos = ro + rd * t;\n        \n        float h = (length(pos) - innerRadius) * scale;\n        \n        float r = exp(-h / Hr) * scaledLength;\n        float m = exp(-h / Hm) * scaledLength;\n        odr += r;\n        odm += m;\n        \n        float lodr = 0.0;\n        float lodm = 0.0;\n        float lt = 0.0;\n        vec2 li = raySphere(pos, -lightDirection, atmoRadius);\n        float llength = max(li.x, li.y) * .25;\n        float scaledllength = llength * scale;\n        bool f = true;\n        \n        for (int i = 0; i < 4; i++){\n            vec3 lpos = pos + -lightDirection * lt;\n            if (map(lpos).x < 0.0) { f = false; break; }\n            \n            float lh = (length(lpos) - innerRadius) * scale;\n            float lr = exp(-lh / Hr) * scaledllength;\n            float lm = exp(-lh / Hm) * scaledllength;\n            lodr += lr;\n            lodm += lm;\n            lt += llength;\n        }\n        if (f) {\n        \tvec3 tau = betaR * (odr + lodr) + betaM * 1.1 * (odm + lodm);\n            vec3 atten = exp(-tau);\n            sumR += atten * r;\n            sumM += atten * m;\n        }\n        \n        t += slength;\n    }\n    \n    return 20.0 * (sumR * betaR * phaseR + sumM * betaM * phaseM);\n}\n\nvec3 march(vec3 ro, vec3 rd){\n    vec2 ray = raySphere(ro, rd, atmoRadius);\n    if (ray.x < 0.0 && ray.y < 0.0) return vec3(0.0);\n    \n    float start = min(ray.x, ray.y);\n    float end = max(ray.x, ray.y);\n    \n    vec3 color = vec3(0.0);\n    \n    float t = start;\n    vec2 d;\n    vec3 pos;\n  \tvec2 ld = vec2(1000.0, 1.0);\n    for (int i = 0; i < 100; i++){\n        pos = ro + rd * t;\n        d = map(pos);\n        \n        if (d.x > ld.x && d.x > atmoRadius){\n            // getting farther away, and outside the planet, exit early\n            break;\n        }\n        \n        if (d.x < 0.0){\n            // hit the ground, sample ground color, blend atmo color\n            color = getGroundColor(pos, d.y);\n            end = t;\n            break;\n        }\n        \n        ld = d;\n        t += max(d.x * .5, .01);\n    }\n    \n    vec3 atmo = vec3(0.0);\n    #if ATMOSPHERE\n    atmo = sampleAtmosphere(ro, rd, start, end);\n    #endif\n    return color * (vec3(1.0) - atmo) + atmo;\n}\n\nvec3 tonemap(vec3 color)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = (1. + luma / (white*white)) / (1. + luma);\n\treturn pow(color * toneMappedLuma, vec3(invgamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 dir = vec3((uv.x - .5), (uv.y - .5) * iResolution.y / iResolution.x, 1.0);\n    \n    dir = normalize(dir);\n    \n    float t = -PI * 2.0 * iMouse.x / iResolution.x + PI;\n    \n    vec3 campos = vec3(sin(t), 0.0, cos(t)) * (4.0 * (1.0 - (iMouse.y / iResolution.y)) + atmoRadius*1.1);\n    vec3 right = vec3(sin(t + PI * .5), 0.0, cos(t + PI * .5));\n    vec3 fwd = normalize(-campos);\n    \n    vec3 color = march(campos, normalize(right * dir.x + fwd * dir.z + vec3(0.0, dir.y, 0.0)));\n    \n    color = tonemap(color);\n    \n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    vec3 color = march(fragRayOri, fragRayDir);\n    \n    color = tonemap(color);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}