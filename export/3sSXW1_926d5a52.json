{"ver":"0.1","info":{"id":"3sSXW1","date":"1553600720","viewed":316,"name":"Dart-Throwing with Gap-Search","username":"fizzer","description":"This is a re-implementation of Fabrice's method based on MIP-mapping ([url]https://www.shadertoy.com/view/llVBRt[/url]) to understand how it works. I added extra code to also traverse the MIP pyramid top-down to search for available gaps.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["packing","filling","darts"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor.a = 1.;\n    \n    if(abs(uv.x) < 1.)\n    {\n    \tfragColor.rgb = mix(vec3(1), vec3(.125,.125,1), textureLod(iChannel0, vec3(1., -uv.yx), 0.).r);\n    }\n    else\n    {\n        fragColor.rgb = vec3(.3);\n    }\n\n    // Gamma correction.\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\nfloat polyDist(vec2 p, int sides, float size)\n{\n    float a = 2. * pi / float(sides);\n    float r = cos(a / 2.) * size;\n    float sideLength = sin(a / 2.) * size * 2.;\n\tfloat d = 1e4, e = -1e9;\n    for(int i = 0; i < sides; ++i)\n    {\n        float t0 = a * float(i + 0);\n        float t1 = a * float(i + 1);\n\n        vec2 p0 = vec2(cos(t0), sin(t0)) * size;\n        vec2 p1 = vec2(cos(t1), sin(t1)) * size;\n\n        e = max(e, dot(p, normalize(vec2(p1.y - p0.y, p0.x - p1.x))) - r);\n        d = min(d, distance(p, mix(p0, p1, clamp(dot(p - p0, normalize(p1 - p0)) / sideLength, 0., 1.))));\n    }\n    return min(e, d);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Project ray direction on to the unit cube.\n    vec3 absRayDir = abs(rayDir);\n    rayDir /= max(absRayDir.x, max(absRayDir.y, absRayDir.z));\n\n    \n    // Get the index of the current face being rendered.\n    \n    int faceIndex = 0;\n\n    if(absRayDir.y > absRayDir.x && absRayDir.y > absRayDir.z)\n    {\n        faceIndex = 2;\n    }\n    else if(absRayDir.z > absRayDir.x && absRayDir.z > absRayDir.y)\n    {\n        faceIndex = 4;\n    }\n\n    if(rayDir[faceIndex / 2] > 0.)\n        faceIndex |= 1;\n\n    fragColor = vec4(0);\n    \n    \n    // Reset on first frames or unused cubemap faces.\n    if(iFrame < 2 || faceIndex != 1)\n    {\n        fragColor = vec4(0, 2, 2, 2);\n        return;\n    }\n\n    vec2 uv = fragCoord.xy / 1024.;\n    vec4 prev = textureLod(iChannel0, vec3(1., -(uv.yx * 2. - 1.)), 0.);\n\n    fragColor = prev;\n\n    vec2 c = vec2(0);\n\n    int seed = iFrame + (int(iDate.z * 6000. + iDate.w * 100.) % 199);\n\n    // Traverse the MIP quadtree stochastically, effectively importance-sampling\n    // the distance field so available space is found more efficiently.\n    for(int i = 0; i < 10; ++i)\n    {\n        float s = exp2(-float(i) - 1.);\n        float lod = 9. - float(i);\n\n        float v0 = textureLod(iChannel0, vec3(1., -((c + s * vec2(-1, -1)).yx)), lod).a;\n        float v1 = textureLod(iChannel0, vec3(1., -((c + s * vec2(+1, -1)).yx)), lod).a;\n        float v2 = textureLod(iChannel0, vec3(1., -((c + s * vec2(-1, +1)).yx)), lod).a;\n        float v3 = textureLod(iChannel0, vec3(1., -((c + s * vec2(+1, +1)).yx)), lod).a;\n\n        float x = hash21(float(seed * 10 + i)).x * (v0 + v1 + v2 + v3);\n\n        if(x < v0)\n            c += s * vec2(-1, -1);\n        else if(x < (v0 + v1))\n            c += s * vec2(+1, -1);\n        else if(x < (v0 + v1 + v2))\n            c += s * vec2(-1, +1);\n        else\n            c += s * vec2(+1, +1);\n    }\n\n    c = c * .5 + .5;\n\n    vec2 p = uv;\n\n    float coverage = 1. - textureLod(iChannel0, vec3(1., 0., 0.), 10.).r;\n    \n    float scale = pow(float(iFrame), -.5);\n\n    // Get the distance of the candidate new shape to be added.\n    float ang = hash21(float(seed * 2)).y * pi * 2.;\n    vec2 o = (p - c) * mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    float d = polyDist(o,int(3. + 2.999 * hash21(float(seed * 2 + 1)).y), .2 * scale) - .01;\n\n    if(iFrame < 20)\n    \td = abs(d - .05 * scale) - .05 * scale;\n    \n    // The MIP-map generation (performed by Shadertoy itself) effectively propagates\n    // the intersection mask up to a single value at the coarsest LOD. This can be used as an intersection test.\n    if(textureLod(iChannel0, vec3(1., 0., 0.), 10.).b == 0.)\n    {\n        // Update the SDF.\n        fragColor.a = min(fragColor.a, max(0., prev.g));\n        \n        // Update the pretty generated texture result.\n        fragColor.r = mix(fragColor.r, pow(scale,.25), 1. - smoothstep(.0, .001, prev.g));\n    }\n\n    // Store the SDF of the candidate new shape.\n    fragColor.g = d;\n    \n    // Store an intersection mask, which will be used in the next frame to determine whether the new\n    // shape should be added or not.\n    fragColor.b = step(d, 0.) * step(fragColor.a, 2. / 1024.);                \n\n}\n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"float pi = 3.1415926535898797323;\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n","name":"Common","description":"","type":"common"}]}