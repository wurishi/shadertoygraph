{"ver":"0.1","info":{"id":"st3fDH","date":"1663017510","viewed":127,"name":"staticky news screen","username":"dkollmar","description":"attempting to create a vintage TV feel","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["firsttry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s){\n    return length(p) - s;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat3 rotateY(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// https://www.shadertoy.com/view/XlfyRr\n// modified by David Kollmar\nvoid WriteChar(vec2 screenCoord, vec2 pos, float charValue, float fontSize, vec4 fontColor, inout vec4 pixel)\n{\n  if (screenCoord.x >=pos.x && screenCoord.x <=pos.x+fontSize && screenCoord.y >=pos.y && screenCoord.y <=pos.y+fontSize)\n  {\n      // calculate texture grab position of character\n      float col = mod(charValue,16.0);\n      vec2 charPos = vec2(col,(charValue-col)/16.0);\n      charPos *= 64.0;\n      \n      vec2 dist = screenCoord-pos;\n\n      vec2 steps = (vec2(-1.0,1.0) / iChannelResolution[0].xy);\n      vec2 startOffset = charPos *steps;\n      \n      // scale texture uv step by fontSize\n      steps*=(-1.0/(fontSize/64.0));\n      dist *=steps;\n      vec4 c = texture(iChannel0,startOffset+dist);\n\n      // Check if texture is a part of the character\n      if(c.r>0.6)\n      {\n        pixel=mix(pixel,fontColor, fontColor.w);\n      }      \n  }\n}\n\nbool testScenePos(vec3 eye, vec3 dir, vec2 fragCoord, out vec3 outPos) {\n    float t = 0.0;\n    \n    for( int i = 0; i < 50; i++){\n        //calc positions from view rays\n        vec3 pos = eye + dir * t;\n       \n        \n        //get distance from positions to spheres\n        float dist = min(opSmoothUnion(sdSphere(pos-vec3(0.0,1.0,0.0), 5.0f), sdTorus(pos-vec3(0.0,0.7,0.0), vec2(7.0, 1.0)), 4.0), sdBoxFrame(rotateY(iTime)*pos-vec3(0.0,-5.0,0.0), vec3(9.0,1.0,9.0), 0.3));\n      \n        if(dist < 0.01){\n            \n            outPos = pos;\n            return true;\n            \n        }\n        \n        t += dist;\n    }\n    \n    return false;\n}\n\n//https://www.shadertoy.com/view/Mls3RS\n// modified by David Kollmar\nfloat noise(float x,float y)\n{   \n\n    return 2.0 * fract(sin(dot(vec2(x, y) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    //set background color\n    float v = fragCoord.y/10.0+fract(iTime*5.0)/5.0;\n    float v2 = fragCoord.y/10.0+iTime*7.0;\n    float v3 = fragCoord.y/100.0+(fract(iTime)+iTime*6.3)/2.0;\n    float v4 = -fragCoord.y/10.0+iTime*0.1;\n    ///////////////////////\n    vec3 col = vec3(abs(sin(v)*fract(sin(v))*cos(v2)*sin(v2)*fract(sin(v3)*fract(sin(v3)+0.6))*-cos(v4)))+\n    ///////////////////////\n    0.6*vec3(noise(fragCoord.x/(20.4+ iTime/200.0), fragCoord.y/(100.4+ iTime/5000.0)));\n    \n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n    \n    vec3 pos, posdy, posdx;\n    \n    vec3 dir = normalize(vec3(uv.x, uv.y, 5));\n    vec3 dirdx = normalize(vec3(uv.x+0.01, uv.y, 5));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.01, 5));\n    vec3 eye = vec3(0, 3.0, -100);\n   \n    if(testScenePos(eye, dir, fragCoord, pos) && testScenePos(eye, dirdx, fragCoord, posdx) && testScenePos(eye, dirdy, fragCoord, posdy)) {\n        \n        vec3 normal = vec3 (0.0, 1.0, 0.0);\n        //find vector direction slightly downward on surface\n        vec3 CA = normalize(posdy - pos);\n\n        //find vector direction slightly to the right on the surface\n        vec3 BA = normalize(posdx - pos);\n\n        normal = cross(CA, BA);\n\n        //a fixed light from the direction of the camera\n        //vec3 lightDir = vec3(0,0,1);\n\n        //a light direction determined by mouse position\n        vec3 lightDir = normalize(vec3(0.1, 2, 2));\n\n        col = vec3(sin(iTime))*dot(-lightDir,normal)+normal;\n    }\n    \n    \n    float offset = ((iResolution.x-50.0)/10.0)-12.0;\n    float fontSize = 75.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    WriteChar(fragCoord, vec2(offset * 2.0,iResolution.y/2.0), 93.0, fontSize, vec4(1.0), fragColor);\n    WriteChar(fragCoord, vec2(offset * 3.0,iResolution.y/2.0), 88.0, fontSize, vec4(1.0), fragColor);\n    WriteChar(fragCoord, vec2(offset * 4.0,iResolution.y/2.0), 95.0, fontSize, vec4(1.0), fragColor);\n    WriteChar(fragCoord, vec2(offset * 5.0,iResolution.y/2.0), 82.0, fontSize, vec4(1.0), fragColor);\n    WriteChar(fragCoord, vec2(offset * 6.0,iResolution.y/2.0), 82.0, fontSize, vec4(1.0), fragColor);\n    WriteChar(fragCoord, vec2(offset * 7.0,iResolution.y/2.0), 91.0, fontSize, vec4(1.0), fragColor);\n    WriteChar(fragCoord, vec2(offset * 8.0,iResolution.y/2.0), 84.0, fontSize, vec4(1.0), fragColor);\n    WriteChar(fragCoord, vec2(offset * 10.0,iResolution.y/2.0), 75.0, fontSize, vec4(1.0), fragColor);\n\n\n    //average with noise\n    fragColor = (fragColor + vec4(noise(fragCoord.x/(sin(float(iFrame))+200.0),fragCoord.y/(sin(float(iFrame))+204.0)), noise(fragCoord.x/(sin(float(iFrame))+220.0),fragCoord.y/(sin(float(iFrame))+1090.0)), noise(fragCoord.x/(sin(float(iFrame))+1900.0),fragCoord.y/(sin(float(iFrame))+400.0)), 1.0)/2.0);\n}","name":"Image","description":"","type":"image"}]}