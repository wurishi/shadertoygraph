{"ver":"0.1","info":{"id":"stGczw","date":"1663773805","viewed":328,"name":"PHBV Test #3 Finale","username":"Yusef28","description":"A pathtraced height based voxel shader based on one by Shane!","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["voxels","voxel","pathtracer","heightbased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nListening To: https://www.youtube.com/watch?v=-ZqRK8DX7FY\nFinished initial typing around 17 min\nbut I had 2 erros that took till 38min \nto find: \n1) I had *1e-4 instead of +1e-4 in mint\n2) I had (height-ro.y)/abs(rd) in cst\nwhich should be no abs, that's the only\nway the logic of negative makes sense\n3) the shadows had a bit of blocky distortion.\nI swapped the hash22 out for an older one\nof mine and it solved the issue.\nIn total it was about an hour but could have\nbeen 17min if I made no mistakes\n17 min! Although that is just for a template\nstill!\n4) Big issue for getUV is we need\nto do n = abs(n)  all uvs are positive!\n5) second getUV issue is we need\np.y = abs(p.y-height), abs so all uvs positive!\n6) had some last minute confusion with \ncreating the squares for the lights and outlines\nfor them.\n7) last minute confusion checking for \"first\"\n*/\n\n#define S smoothstep\nfloat height;\nfloat hit;\nvec2 seed = vec2(0.24,0.62);\nvec3 normal;\n\n\n\nvec2 hash220(){\n    seed ++;\n    seed += fract(vec2(455.24,257.63)+seed);\n    float d1 = dot(seed, vec2(62.45,84.56));\n    float d2 = dot(seed, vec2(95.62,45.15));\n    return fract(sin(vec2(d1,d2)*vec2(25.52,62.))*24.24);\n}\nvec2 hash22(){\n    seed++;\n    seed = fract((seed+vec2(31.24,13.65)));\n    float d1 = dot(seed, vec2(86.36,68.35));\n    float d2 = dot(seed, vec2(92.52,24.31));\n    return fract(sin(vec2(d1,d2))*vec2(43758.5453, 23421.6361));    \n}\nvec3 cosDir(vec3 n){\n    vec2 xy = hash22();\n    float th = xy.x*acos(-1.)*2.;\n    float sinP = xy.y*2.-1.;\n    float cosP = sqrt(1.-sinP*sinP);\n    vec3 b = vec3(cosP*vec2(cos(th),sin(th)),sinP);\n    return normalize(b+n);\n}\n\nvec3 getCell(vec3 p){\n    return ceil(p)-0.5;\n}\n\nfloat getHeight(vec2 uv){\n    return -texture(iChannel0,uv*0.01).x*9.;\n}\nvec2 getUV(vec3 p, vec3 n){\n    p.y = abs(p.y-height);\n    p.xz = fract(p.xz);\n    n = abs(n);\n    return n.x*p.zy + n.y*p.xz + n.z*p.xy;\n}\n\nfloat mint(vec3 ro, vec3 rd){\n    vec3 t = (fract(-ro*sign(rd))+1e-4)/abs(rd);\n    normal = t.x < t.z ?\n             vec3(1.,0.,0.)*-sign(rd.x) :\n             vec3(0.,0.,1.)*-sign(rd.z) ;\n    return min(t.x,t.z);\n}\n\nvec3 cst(vec3 ro, vec3 rd){\n    float tx = 1e8, ty = 1e8;\n    for(float i = 0.;  i< 40.; i++){\n        height = getHeight(getCell(ro).xz);\n        if(ro.y<height){return ro;}\n        tx = mint(ro,rd);\n        ty = (height-ro.y)/rd.y;\n        if(ty < tx && ty > 0.){\n            normal = vec3(0.,1.,0.);\n            return ro + rd*ty;\n        }\n        ro += rd*tx;\n    }\n    hit = 0.;\n    return ro;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = vec3(0.),\n          ro = vec3(0.,1.,iTime);\n          vec3 first = vec3(1e8);\n    float sNum = 6., bNum = 3.;\n    for(float i = 0.; i < sNum; i++){\n        seed += uv + fract(sin(\n                vec2(iTime/126.45,iTime/286.25)\n                *43.62)*74.63);\n        vec2 jit = hash22()-0.5;\n        vec3 rd = normalize(vec3(uv+jit/iResolution.y,1.));\n        rd.yz *= mat2(cos(-0.4 + vec4(0,11,33,0)));\n       \n        rd.xz *= mat2(cos(iTime*0.2 + vec4(0,11,33,0)));\n        \n        vec3 p = ro;\n        vec3 A = vec3(0.), B = vec3(1.);\n        for(float j = 0.; j < bNum; j++){\n            \n            hit = 1.;\n            vec3 p1 = cst(p,rd);\n            //if(length(ro-p1) > 30.) {col += 0.005;break;}\n             if(first.z > 1e7){first = p1;}\n\n            vec3 cell = getCell(p1);\n            vec2 uv = getUV(p1,normal);\n            vec3 C = texture(iChannel1,uv).rgb;\n            vec2 st = abs(uv-0.5);\n            float sq = max(st.x*0.345,st.y);\n            \n            float outline = 1., outline2 = 1.;\n            outline *= S(0.48,0.47,abs(uv.x-0.5) );\n            outline2 *= S(0.46,0.45,abs(uv.x-0.5) );\n            if(abs(normal.y) > 0.9){\n                outline *= S(0.48,0.47,abs(uv.y-0.5) );\n                outline2 *= S(0.46,0.45,abs(uv.y-0.5) ); \n            }     \n            else{\n                outline *= S(0.02,0.04,uv.y);\n                //outline *= smoothstep(0.18,0.2,sq);\n                outline2 *= S(0.03,0.06,uv.y);\n                outline2 *= smoothstep(0.17,0.18,sq);\n            }\n            /*\n            if(abs(normal.x) + abs(normal.z )> 0.9){\n                outline *= S(0.47,0.45,abs(uv.x-0.5) );\n                outline *= S(0.,0.05,uv.y);\n            }     \n            else{\n                outline *= S(0.47,0.45,abs(uv.x-0.5) );\n                outline *= S(0.47,0.45,abs(uv.y-0.5) );  \n            }*/\n            /*\n            if(abs(normal.x) > 0.9){\n                outline *= S(0.47,0.45,abs(uv.x-0.5) );\n                outline *= S(0.,0.05,uv.y);\n            \n            }     \n            else if(abs(normal.z) > 0.5){\n                outline *= S(0.47,0.45,abs(uv.x-0.5) );\n                outline *= S(0.,0.05,uv.y);\n                \n            }\n            else{\n                outline *= S(0.47,0.45,abs(uv.x-0.5) );\n                outline *= S(0.47,0.45,abs(uv.y-0.5) );\n                \n            }\n            */\n\n           // C *= clamp(outline+0.6,0.,1.);\n            C = mix(C,vec3(0.),max(0.,1.-outline2)*0.9);\n            \n            C = mix(C,vec3(0.9,0.6,0.2),max(0.,1.-outline)*0.5);\n            float eid = step(0.8,fract(sin(cell.x*cell.z)*49.22));\n            vec3 E = vec3(eid);\n            sq = smoothstep(0.15,0.16,sq);\n            vec3 liCol = 0.5+0.5*cos(vec3(0,2,4)+\n                 uv.xyx+cell.x+cell.z+iTime*2.);\n            E = liCol*(1.-sq)*(1.-normal.y);//mix(E,vec3(1.2),);\n            //E = mix(E,vec3(1.),step(0.05,-(p1.y-height))*step(-(p1.y-height),0.3));\n            if(p1.y > 0.){\n                normal = vec3(0.,-1.,0.);\n                E = vec3(.9);\n            }\n            \n            A += E*B;\n            B *= C;\n            rd = mix(reflect(rd,normal),cosDir(normal),(0.3+outline)*0.3);\n            p = p1+rd*0.05;\n            \n            //if(hit<0.5){col += vec3(0.1,0.1,0.2)*0.02;break;}\n        }\n        col += A;\n    }\n    col /= sNum;\n    col = clamp(col,0.,1.);\n    col = pow(col,vec3(0.4545));\n    // Output to screen\n    float fog = S(0.,1.,pow(length(ro-first)/30.,2.));\n    col = mix(col, vec3(0.85),fog);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}