{"ver":"0.1","info":{"id":"XXjGWy","date":"1708816200","viewed":84,"name":"truch cross eye - params","username":"davidmachadosf","description":"truchet 3d -basic v2\nimplemented ajustable paralax (SHIFT+ and SHIFT-)","likes":2,"published":1,"flags":48,"usePreview":1,"tags":["truchet3dbasicv2"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// gohu font start\n#define _EXCLAM TXT(p,uvec3(         0,    458240,         0)); // '!'\n#define _QUOTE  TXT(p,uvec3( 939524096,         0,       224)); // '\"'\n#define _SHARP  TXT(p,uvec3(4161339428,4286615583,  37751041)); // '#'\n#define _DOLLAR TXT(p,uvec3( 272908430, 287309585, 236995649)); // '$'\n#define _PRCENT TXT(p,uvec3(1354842114,2349123596, 268476610)); // '%'\n#define _AMP    TXT(p,uvec3(2956722176, 344207888, 285227201)); // '&'\n#define _TICK   TXT(p,uvec3(         0,      7680,         0)); // '''\n#define _LPAREN TXT(p,uvec3(1612578816,   8913944,         4)); // '('\n#define _RPAREN TXT(p,uvec3( 134217728,2248672320,      7681)); // ')'\n#define _TIMES  TXT(p,uvec3(    655428, 268695553,  71305728)); // '*'\n#define _PLUS   TXT(p,uvec3(    262160, 268695553,  16778240)); // '+'\n#define _COMMA  TXT(p,uvec3(         0,    917592,         0)); // ','\n#define _MINUS  TXT(p,uvec3(    262144, 268451841,  16778240)); // '-'\n#define _PERIOD TXT(p,uvec3(         0,    393240,         0)); // '.'\n#define _FSLASH TXT(p,uvec3(  12582912, 201375756,    786624)); // '/'\n#define _0      TXT(p,uvec3( 272596992, 151274514, 266355009)); // '0'\n#define _1      TXT(p,uvec3(1073872896,4278192128,         1)); // '1'\n#define _2      TXT(p,uvec3( 274825216, 285508628, 274743873)); // '2'\n#define _3      TXT(p,uvec3( 270565376, 285492240, 249578561)); // '3'\n#define _4      TXT(p,uvec3(2148270080, 570462210,  33587136)); // '4'\n#define _5      TXT(p,uvec3(2418262016, 151266320, 252723777)); // '5'\n#define _6      TXT(p,uvec3(2420080640, 151266320, 251675201)); // '6'\n#define _7      TXT(p,uvec3( 268451840, 822543360,   3146560)); // '7'\n#define _8      TXT(p,uvec3( 272334848, 285492241, 249578561)); // '8'\n#define _9      TXT(p,uvec3( 268664832, 285492241, 132129857)); // '9'\n#define _COLON  TXT(p,uvec3(         0,2349215744,         1)); // ':'\n#define _SCOLON TXT(p,uvec3(3221225472,    929880,         0)); // ';'\n#define _LT     TXT(p,uvec3(    524288,  67248133,     32897)); // '<'\n#define _EQ     TXT(p,uvec3(1074855936,1140920324,  71307520)); // '='\n#define _GT     TXT(p,uvec3(1082163200,1342316560,      2048)); // '>'\n#define _QMARK  TXT(p,uvec3( 134234112, 277250560,   7340576)); // '?'\n#define _AT     TXT(p,uvec3(3359645951,1116015123, 401623201)); // '@'\n#define _A      TXT(p,uvec3( 276791296, 285230081, 534774848)); // 'A'\n#define _B      TXT(p,uvec3( 276807680, 285492241, 249578561)); // 'B'\n#define _C      TXT(p,uvec3( 272596992,  17040400, 136331329)); // 'C'\n#define _D      TXT(p,uvec3( 276807680,  17040400, 130031745)); // 'D'\n#define _E      TXT(p,uvec3( 276807680, 285492241, 269500481)); // 'E'\n#define _F      TXT(p,uvec3( 276807680, 285230081,   1048640)); // 'F'\n#define _G      TXT(p,uvec3( 272596992, 285475856, 253772865)); // 'G'\n#define _H      TXT(p,uvec3(   8372224, 268451841, 535823360)); // 'H'\n#define _I      TXT(p,uvec3( 268435456,  17300496,         1)); // 'I'\n#define _J      TXT(p,uvec3(   3145728,    262160, 267403265)); // 'J'\n#define _K      TXT(p,uvec3(   8372224,1140891649, 269492352)); // 'K'\n#define _L      TXT(p,uvec3(   8372224,    262160, 268451841)); // 'L'\n#define _M      TXT(p,uvec3(1073775103,  67133440, 535822464)); // 'M'\n#define _N      TXT(p,uvec3(1618984960,1610637312, 535846912)); // 'N'\n#define _O      TXT(p,uvec3( 272596992,  17040400, 266354753)); // 'O'\n#define _P      TXT(p,uvec3( 276807680, 285230081,  14681152)); // 'P'\n#define _Q      TXT(p,uvec3( 272596992,1627653136, 937435201)); // 'Q'\n#define _R      TXT(p,uvec3( 276807680, 822100993, 417338432)); // 'R'\n#define _S      TXT(p,uvec3( 270761984, 285492241, 236995649)); // 'S'\n#define _T      TXT(p,uvec3( 268451841,  17300480,   1048640)); // 'T'\n#define _U      TXT(p,uvec3(   4177920,    262160, 267403265)); // 'U'\n#define _V      TXT(p,uvec3(    245760,2147876871,  15735809)); // 'V'\n#define _W      TXT(p,uvec3(   7340095, 536899586,  66088960)); // 'W'\n#define _X      TXT(p,uvec3(3227566080, 268451846, 405805824)); // 'X'\n#define _Y      TXT(p,uvec3(    196611, 268926977,   3146496)); // 'Y'\n#define _Z      TXT(p,uvec3( 275791872, 151274514, 271597889)); // 'Z'\n#define _LBRKET TXT(p,uvec3(         0,   9436672,     32802)); // '['\n#define _BSLASH TXT(p,uvec3( 805318656, 805318656, 805318656)); // '\\'\n#define _RBRKET TXT(p,uvec3( 134217728,4287103520,         3)); // ']'\n#define _CARET  TXT(p,uvec3( 268468224,  16777728,       128)); // '^'\n#define _UNDER  TXT(p,uvec3(   8389120,    524320, 536903682)); // '_'\n#define _BTICK  TXT(p,uvec3( 268443648,      2048,         0)); // '`'\n#define _a      TXT(p,uvec3(1077411840, 335826961, 528491777)); // 'a'\n#define _b      TXT(p,uvec3(2155864064,  67375120, 260063489)); // 'b'\n#define _c      TXT(p,uvec3(1077805056,  67375120, 142622977)); // 'c'\n#define _d      TXT(p,uvec3(1077805056,  67375120, 536355073)); // 'd'\n#define _e      TXT(p,uvec3(1077805056, 604278802, 327174401)); // 'e'\n#define _f      TXT(p,uvec3(4026531840, 142615071,       544)); // 'f'\n#define _g      TXT(p,uvec3(1077805056,  69472400,2143428873)); // 'g'\n#define _h      TXT(p,uvec3(2155864064,  67112960, 528482560)); // 'h'\n#define _i      TXT(p,uvec3(1073807360,    521728,     16385)); // 'i'\n#define _j      TXT(p,uvec3(  33554432,4255125632,         7)); // 'j'\n#define _k      TXT(p,uvec3(   8380416,1342210050, 268444160)); // 'k'\n#define _l      TXT(p,uvec3( 134217728,    261632, 268451841)); // 'l'\n#define _m      TXT(p,uvec3(1073807868,  67629056, 528482560)); // 'm'\n#define _n      TXT(p,uvec3(1082064896,  67112960, 528482560)); // 'n'\n#define _o      TXT(p,uvec3(1077805056,  67375120, 260063489)); // 'o'\n#define _p      TXT(p,uvec3(2214526976,  67375120, 260063489)); // 'p'\n#define _q      TXT(p,uvec3(1077805056,  67375120,4290781441)); // 'q'\n#define _r      TXT(p,uvec3(2155806720,  67112960,   8388864)); // 'r'\n#define _s      TXT(p,uvec3(1078329344, 604278802, 201345281)); // 's'\n#define _t      TXT(p,uvec3(1073741824,  67370496,     16641)); // 't'\n#define _u      TXT(p,uvec3(   4128768,    262160, 532684801)); // 'u'\n#define _v      TXT(p,uvec3(    458752,2147876870,  29366273)); // 'v'\n#define _w      TXT(p,uvec3(   6291580,1073790980, 130048000)); // 'w'\n#define _x      TXT(p,uvec3(   6488064, 536903685, 415241216)); // 'x'\n#define _y      TXT(p,uvec3(   4128768,   2359440,2143428617)); // 'y'\n#define _z      TXT(p,uvec3(1080098816, 335843348, 272646913)); // 'z'\n#define _LCURL  TXT(p,uvec3(    524320,   9403394,1074331684)); // '{'\n#define _PIPE   TXT(p,uvec3(         0,   2096640,         0)); // '|'\n#define _RCURL  TXT(p,uvec3( 151003136,3742368320,  33556483)); // '}'\n#define _TILDE  TXT(p,uvec3(2147614768, 536887296,  25167872)); // '~'\n#define _        CURSOR.x+=8;\n#define _NEWLINE CURSOR=ivec2(CURSOR_START.x, CURSOR.y-14);\n#define NUM(value) _NUM(p,value, -1);\n#define FNUM(value) _NUM(p,value*10000., 3);\nvec3 TXT_COL=vec3(0.0); ivec2 CURSOR_START = ivec2(0), CURSOR = ivec2(0);\nvoid TXT(vec2 p, uvec3 g){\n    _ int x=int(p.x)-CURSOR.x,\n          y=CURSOR.y-int(p.y),\n          b=x*14+y-16;\n          \n    if( x>0 && x<8 && y>=0 && y<14 && b>=0) \n        TXT_COL+=vec3((g[b/32]>>(b&31))&1u); \n}\n\nvoid _NUM(vec2 p, float n,int point){\n\n    if(n<0.){_MINUS n=-n;}\n    \n    for (int i=6,k=100000000,m=int(round(n*100.0));i>-3;i--,k/=10){\n        int d=m>=k||i<=0?int(m/k)%10:-1;\n        if(i==point)_PERIOD \n        if(d==0)_0 \n        if(d==1)_1 \n        if(d==2)_2 \n        if(d==3)_3 \n        if(d==4)_4 \n        if(d==5)_5 \n        if(d==6)_6 \n        if(d==7)_7 \n        if(d==8)_8 \n        if(d==9)_9 \n        \n        if(i==0&&(m%100)==0)break;\n    }\n}\n// gohu font end\n\n\n\n\n//por jorge2017a1=jorge2017a2 :)\n#define MAX_STEPS 110\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat Hash21(vec2 p)\n{   p=fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.26);\n    return fract(p.x*p.y);\n}\n\nvec4 truchet( in vec2 uv )\n{   uv= rotatev2(uv, radians(45.0));\n    vec3 col=vec3(0.0);\n    vec2 gv=fract(uv)-0.5;\n    vec2 id=floor(uv);\n    float n=Hash21(id); //rango 0.0 a 1.0\n    float width=0.1;\n\n    if(n<0.5) gv.x*=-1.0;\n\n    //----------\n    /// Tip Shane....9/jun/2021\n    float d=abs(gv.x + gv.y)*.7071; // Diagonal line.\n    gv = abs(gv) - .5; // Corners.\n    d = min(d, abs(gv.x + gv.y)*.7071); \n    //----------\n    float  mask= d-width;\n    float r = pow(1.0-sqrt( d),1.5 );\n    float g = pow(1.0-sqrt( d),1.5 );\n    float b = 1.0*(r+g);\n    col+=vec3(r,g-0.8,b-0.8)*mask;\n    return vec4(col,mask);\n}\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n\n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    vec3 pp=p;\n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n    p.y= opRep1D(p.y,40.0) ;\n   vec4 t1= truchet(p.xy*0.65);\n    float  d1=sdBox( p, vec3(20.0,20.0,1.0) ); \n    float d2= sdBox( p-vec3(0.0,0.0,3.0), vec3(20.0,20.0,2.0)  );\n    float inter1= intersectSDF( d1,t1.w);\n    float uni=unionSDF(d2, inter1);\n    res =opU3(res, vec3(uni,1.0,-1.0));\n   return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    \n   \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n         vec3 r = reflect(rd, norm);\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh+=occlusion(hit,r);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}    \n    \n        \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    \n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   bool esq = (fragCoord.x/iResolution.x)<.5;\n    \n   if(!esq){\n       fragCoord.x -= iResolution.x/2.;\n   }\n   fragCoord.x *= 2.; \n   \n   //vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   vec2 uv = fragCoord/iResolution.xy;\n   mObj.uv=uv;\n   \n   \n   \n   \n   // get parameters\n    float xi   = get(paramXi );\n    float xf   = get(paramXf );\n    float yi   = get(paramYi );\n    float yf   = get(paramYf );\n    float vel  = get(paramVel);\n    \n    float fFunc = get(paramFunc);\n    int func = int(fFunc);\n    \n    bool      cicle = get(paramCicle)>0.;\n    float  velCicle = get(paramVelCicle);\n    float timeCicle = get(paramTimeCicle);\n    float timeBase  = get(paramTimeBase);    \n    float cpow      = get(paramCpow);\n    \n    \n    \n    float fPall = get(paramPall);\n    int pall = int(fPall);\n    \n    float fCoord = get(paramCoord);\n    int coord = int(fCoord);\n    \n    \n    float fReverse = get(paramReverse);\n    float fUrev = get(paramUrev);\n    bool reverse = fReverse>0.;\n    bool urev = fUrev>0.;\n    \n    bool params =  get(paramParams)>0.;\n   \n   \n   float paralax = get(paramParalax);\n   \n   \n   \n   float x = (xi+(xf-xi)*uv.x);\n   float y = (yi+(yf-yi)*uv.y);\n   \n  \n   \n    float t;\n    t=mod(iTime*3.0,360.0);\n    itime=t;\n    \n    //float t = timeCicle;\n\n    if(cicle){\n      float dt = (1.*iTime - timeBase)*velCicle;\n      t += dt;        \n    }\t\n\t\n    //timeCicle = t;\n    \n    //mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 20.0, -5.0 ); light_color1=vec3( 0.5 );\n \tlight_pos2= vec3( -20.0, 10.0, 30.0 ); light_color2 =vec3(1.0,1.0,1.0); \n \n   vec3 ro=vec3(paralax*(esq?-1.:+1.),5.0+t,-7.0);\n   vec3 rd=normalize( vec3(x,y,1.0));\n   rd= rotate_x(rd, radians(-30.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n    \n    if(params){\n          CURSOR_START = CURSOR = ivec2(4, int(iResolution.y)/2 - 14);\n          vec2 p = fragCoord * 0.5;\n          \n    // basic text\n    //      _H _e _l _l _o _ _W _o _r _l _d _EXCLAM _NEWLINE _NEWLINE\n    //      _T _h _e _ _q _u _i _c _k _ _b _r _o _w _n _ _f _o _x _ _j _u _m _\n    //      _s _\n    //      _o _v _e _r _ _t _h _e _ _l _a _z _y _ _d _o _g _PERIOD _NEWLINE\n    //      _NEWLINE\n    \n    // display all glyphs\n    //      _A _B _C _D _E _F _G _H _I _J _K _L _M _N _O _P _Q _R _S _T _U _V _W _X _Y _Z _NEWLINE\n    //      _a _b _c _d _e _f _g _h _i _j _k _l _m _n _o _p _q _r _s _t _u _v _w _x _y _z _NEWLINE\n    //      _BTICK _1 _2 _3 _4 _5 _6 _7 _8 _9 _0 _MINUS _EQ _LBRKET _RBRKET _BSLASH _SCOLON _TICK\n    //      _COMMA _PERIOD _FSLASH _NEWLINE\n    //      _TILDE _EXCLAM _AT _SHARP _DOLLAR _PRCENT _CARET _AMP _TIMES _LPAREN _RPAREN _UNDER _PLUS _LCURL _RCURL _PIPE\n     //     _COLON _QUOTE _LT _GT _QMARK _NEWLINE\n     //     _NEWLINE _NEWLINE\n    \n    // example of drawing dynamic content\n    \n    \n   \n    \n    \n          _x _i _EQ FNUM(xi) _COMMA _ \n          _x _f _EQ FNUM(xf) _COMMA _ \n          _y _i _EQ FNUM(yi) _COMMA _ \n          _y _i _EQ FNUM(yf) \n          _NEWLINE\n          \n          _f _u _n _c _EQ NUM(fFunc) _NEWLINE\n          _c _p _o _w _EQ FNUM(cpow) _NEWLINE     \n          _p _a _l _l _EQ NUM(fPall) _NEWLINE\n          _c _o _o _r _d _EQ NUM(fCoord) _NEWLINE\n          \n          _r _e _v _e _r _s _e _EQ NUM(fReverse) _COMMA _ \n          _u _r _e _v _EQ NUM(fUrev) _NEWLINE\n          \n          \n          _i _T _i _m _e _ _EQ _ NUM(iTime) _NEWLINE          \n          _t _EQ _ NUM(t) _NEWLINE\n          _i _R _e _s _o _l _u _t _i _o _n _ _EQ _ NUM(iResolution.x) _ _x _ NUM(iResolution.y)\n    \n    // output to screen  \n          \n          vec4 textColor = vec4(mix(vec3(.2,.2,.2),vec3(.1,.8,.1),TXT_COL),1.0);\n          \n          if(textColor[1]>.5){\n              fragColor=vec4(.999,.999,.999,1.)-fragColor;\n          }\n    \n    }\n    \n   \n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// parameters (coordinates on texture buffer)\nconst ivec2 paramXi = ivec2(0,0);\nconst ivec2 paramXf = ivec2(0,1);\nconst ivec2 paramYi = ivec2(0,2);\nconst ivec2 paramYf = ivec2(0,3);\n\nconst ivec2 paramVel   = ivec2(1,0);\nconst ivec2 paramFunc  = ivec2(2,0);\n\n\nconst ivec2 paramCicle     = ivec2(3,0);\nconst ivec2 paramVelCicle  = ivec2(3,1);\nconst ivec2 paramTimeCicle = ivec2(3,2);\nconst ivec2 paramTimeBase  = ivec2(3,3);\nconst ivec2 paramParams    = ivec2(3,4);\n\nconst ivec2 paramCpow      = ivec2(4,0);\nconst ivec2 paramPall      = ivec2(4,1);\nconst ivec2 paramCoord     = ivec2(4,2);\nconst ivec2 paramReverse   = ivec2(4,3);\nconst ivec2 paramUrev      = ivec2(4,4);\nconst ivec2 paramParalax   = ivec2(4,5);\n\n\n\n// read and store values as x value on texture pixels\n#define get(var) texelFetch(iChannel0, var, 0).x\n#define set(var, value, fragColor, fragCoord) fragColor=(ivec2(fragCoord)==var?vec4(value,0.,0.,1.):fragColor)\n\n\n// reset to initial parameters\nconst int keyReset = 192; // the \"' key, below Esc\n\n// change image functions\nconst int keyPrev = 33; // PgUp\nconst int keyNext = 34; // PgDown\n\n\n// change position (arrow keys)\nconst int keyNorth = 38;\nconst int keySouth = 40;\nconst int keyEast  = 37;\nconst int keyWest  = 39;\nconst int keyOrig  = 12;\n\n\n// keycodes below are from numeric keyboard\n\n// change scale\nconst int keyZoomOut = 111; // /\nconst int keyZoomIn  = 106; // *\n\n// change scale velocity\nconst int keySlow = 109; // -\nconst int keyFast = 107; // +\n\n// cicle palete over time\nconst int keyCicle = 110; // .\n\n// change cicle velocity\nconst int keyCicleSlow = 36; // Home\nconst int keyCicleFast = 35; // End\n\n\n// change palete pow\nconst int keyPowDec  = 81; // q\nconst int keyPowInc  = 65; // a\nconst int keyPowZero = 90; // z\n\n\n// change palete type\nconst int keyPallInc  = 80; // p\nconst int keyPallDec  = 79; // o\nconst int keyPallZero = 73; // i\n\n// toglr polar/cartesian coordinates\n//const int keyPolar = 45; // insert, 0 on keypad\nconst int keyCoord = 45; // insert, 0 on keypad\n\n// toglr polar/cartesian coordinates\nconst int keyReverse = 82; // r\nconst int keyUrev    = 85; // u\n\n// zero time\nconst int keyZeroTime = 84; // t\n\n// show parameter values\nconst int keyParams = 86; // v\n\n\n\n#define keyToggle(code)  ( texelFetch(iChannel1,ivec2(code,2),0).x > 0.)\n#define keyClick(code)   ( texelFetch(iChannel1,ivec2(code,1),0).x > 0.)\n#define keyDown(code)    ( texelFetch(iChannel1,ivec2(code,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel1,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel1,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel1,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n\n\n\n//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};   \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// initial parameter values\nfloat iniXi       =  -1. ;\nfloat iniXf       =   1. ;\nfloat iniYi       =  -1. ;\nfloat iniYf       =   1. ;\nfloat iniVel      =   .01 ;\nfloat iniFunc     =    0. ;\nfloat iniCoord    =    0. ; \n\nfloat iniCicle     =  1.  ; // -1.: FALSE 1.:TRUE\nfloat iniVelCicle  =  1.  ;\nfloat iniTimeCicle =  0.  ;\nfloat iniTimeBase  =  0.  ;\nfloat iniParams    =  1.  ; // -1.: FALSE 1.:TRUE\n\nfloat iniCpow = 1. ; \nfloat iniPall = 0. ; \nfloat iniParalax = .06 ; \n\n\nfloat iniReverse = -1.; // -1.: normal colors 1.:reversed colors\nfloat iniUrev    = -1.; // -1.: uniform 0-1 colors: 1. reversed 1-0 uniform scale\n\n\n\nvoid initParameters(inout vec4 fragColor, in vec2 fragCoord){\n    set(paramXi,       iniXi,       fragColor, fragCoord);   \n    set(paramXf,       iniXf,       fragColor, fragCoord);   \n    set(paramYi,       iniYi,       fragColor, fragCoord);   \n    set(paramYf,       iniYf,       fragColor, fragCoord);   \n    set(paramVel,      iniVel,      fragColor, fragCoord);   \n    set(paramFunc,     iniFunc,     fragColor, fragCoord);   \n    \n    set(paramCicle,     iniCicle,     fragColor, fragCoord);   \n    set(paramVelCicle,  iniVelCicle,  fragColor, fragCoord);   \n    set(paramTimeCicle, iniTimeCicle, fragColor, fragCoord);   \n    set(paramTimeBase,  iniTimeBase,  fragColor, fragCoord); \n    set(paramParams,    iniParams,    fragColor, fragCoord); \n    \n    \n    set(paramCpow,  iniCpow,  fragColor, fragCoord); \n    set(paramPall,  iniPall,  fragColor, fragCoord); \n    set(paramCoord, iniCoord, fragColor, fragCoord); \n    \n    set(paramParalax,  iniParalax,  fragColor, fragCoord); \n    \n    set(paramReverse, iniReverse, fragColor, fragCoord); \n    set(paramUrev,    iniUrev,    fragColor, fragCoord); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // initialize values\n    if (iFrame==0) {\n        initParameters(fragColor, fragCoord);    \n    }\n\n    else { \n    \n        // get current values\n        float xi       = get(paramXi);   \n        float xf       = get(paramXf);   \n        float yi       = get(paramYi);   \n        float yf       = get(paramYf);   \n        float vel      = get(paramVel);   \n        float func     = get(paramFunc); \n        \n        float cicle     = get(paramCicle);  \n        float velCicle  = get(paramVelCicle);  \n        float timeCicle = get(paramTimeCicle);  \n        \n        float timeBase  = get(paramTimeBase);\n        float params    = get(paramParams);\n        \n        float cpow      = get(paramCpow);\n        float pall      = get(paramPall);\n        float coord     = get(paramCoord);\n        float reverse   = get(paramReverse);\n        float urev      = get(paramUrev);\n        \n        float paralax   = get(paramParalax);\n        \n        \n        \n        // current visible window size\n        float dx = xf-xi;\n        float dy = yf-yi;\n        \n        \n       \n        \n        // move image\n        if(keyDown(keyNorth)){\n            yi+=dy/100.;\n            yf+=dy/100.;\n        }\n        if(keyDown(keySouth)){\n            yi-=dy/100.;\n            yf-=dy/100.;\n        }\n        if(keyDown(keyEast)){\n            xi-=dx/100.;\n            xf-=dx/100.;\n        }\n        if(keyDown(keyWest)){\n            xi+=dx/100.;\n            xf+=dx/100.;\n        }\n        \n        // return to 0,0 (dont change scale)\n        if(keyDown(keyOrig)){\n            xi=-dx/2.;\n            xf=+dx/2.;\n            yi=-dy/2.;\n            yf=+dy/2.;\n        }\n        \n        // zoom controls\n        if(keyDown(keyZoomOut)){\n            xi-=dx*vel;\n            xf+=dx*vel;\n            if(!shift){\n                yi-=dy*vel;\n                yf+=dy*vel;\n            }\n        }        \n        if(keyDown(keyZoomIn)){\n            xi+=dx*vel;\n            xf-=dx*vel;\n            if(!shift){\n                yi+=dy*vel;\n                yf-=dy*vel;\n            }\n        }\n        \n        // zoom velocity change\n        if(keyClick(keySlow)){\n            if(!shift){\n                vel/=2.;\n            }\n            else{\n                paralax /=1.1;\n            }\n        }        \n        if(keyClick(keyFast)){\n            if(!shift){\n                vel*=2.;\n            }\n            else{\n                paralax *= 1.1;\n            }\n            \n        }\n                \n        \n        \n        // restart to initial status\n        if(keyClick(keyReset)){            \n            xi    = iniXi;\n            xf    = iniXf;\n            yi    = iniYi;\n            yf    = iniYf;\n            vel   = iniVel;\n            func  = iniFunc;\n            \n            cicle     = iniCicle;\n            velCicle  = iniVelCicle;  \n            timeCicle = 0.; \n            timeBase  = 1.*iTime;\n        }\n        \n        \n        \n        \n        // cicle fase and colors by iTime\n        if(keyClick(keyCicle)){\n            // its a bool, but I must store as float... \n            \n            float fTime = 1.*iTime;\n            \n            if(cicle < 0.){\n                // estava parado                \n                timeBase = fTime;\n            }\n            else{\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = timeCicle;        \n            }\n                        \n            cicle*=-1.;\n        }\n        \n        // cicle velocity change\n        if(keyDown(keyCicleSlow)){\n        \n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n        \n            velCicle/=1.01;            \n        }        \n        if(keyDown(keyCicleFast)){\n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n            \n            velCicle*=1.01;            \n        }\n        \n        \n        // change palete power\n        if(keyDown(keyPowDec)){\n            cpow /=1.01;\n        }        \n        if(keyDown(keyPowInc)){\n            cpow *=1.01;\n        }\n        if(keyClick(keyPowZero)){\n            cpow = iniCpow;\n        }      \n        \n       \n        \n       \n        \n        // change color normal/reversed\n        if(keyClick(keyReverse)){\n            // its a bool, but I must store as float... \n            reverse*=-1.;\n        }\n        \n        \n        // change pallete mapping 0-1  1-0\n        if(keyClick(keyUrev)){\n            // its a bool, but I must store as float... \n            urev*=-1.;\n        }\n        \n        // zero time\n        if(keyClick(keyZeroTime)){\n            \n           timeCicle = 0.; \n           timeBase  = 1.*iTime;    \n            \n        }\n        \n        \n        // change showParams\n        if(keyClick(keyParams)){\n            // its a bool, but I must store as float... \n            params*=-1.;\n        }\n        \n        \n        \n        \n        // update parameters\n        set(paramXi,       xi,       fragColor, fragCoord);   \n        set(paramXf,       xf,       fragColor, fragCoord);   \n        set(paramYi,       yi,       fragColor, fragCoord);   \n        set(paramYf,       yf,       fragColor, fragCoord);   \n        set(paramVel,      vel,      fragColor, fragCoord);   \n        set(paramFunc,     func,     fragColor, fragCoord);   \n        \n        set(paramCicle,     cicle,     fragColor, fragCoord); \n        set(paramVelCicle,  velCicle,  fragColor, fragCoord); \n        set(paramTimeCicle, timeCicle, fragColor, fragCoord); \n        set(paramTimeBase,  timeBase,  fragColor, fragCoord); \n        set(paramParams,    params,    fragColor, fragCoord); \n        \n        set(paramCpow,  cpow,  fragColor, fragCoord); \n        set(paramPall,  pall,  fragColor, fragCoord); \n        set(paramCoord, coord, fragColor, fragCoord); \n        \n        set(paramParalax,  paralax,  fragColor, fragCoord); \n        \n        set(paramReverse, reverse, fragColor, fragCoord); \n        set(paramUrev,    urev,    fragColor, fragCoord); \n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}