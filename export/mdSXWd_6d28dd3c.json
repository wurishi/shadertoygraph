{"ver":"0.1","info":{"id":"mdSXWd","date":"1671094725","viewed":98,"name":"Hue Preserving Clamp","username":"4LT","description":"Preserve hue on blown-out colors (does not preserve saturation or luminosity in all cases: you have to pick your battles!).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float gammaPwr = 0.4545;\nconst float invGammaPwr = 1.0/gammaPwr;\nconst float tau = 2.0 * acos(-1.0);\nconst float speed = 0.1;\nconst float barHeight = 0.3;\n\nvec3 huePreservingClamp(vec3 color) {\n    int maxChan, minChan, midChan;\n    \n    color = max(color, vec3(0.0));\n    \n    // Find the highest, lowest, and middle channels\n    if (color.x > color.y) {\n        if (color.x > color.z) {\n            maxChan = 0;\n            if (color.y > color.z) {\n                minChan = 2;\n                midChan = 1;\n            } else {\n                minChan = 1;\n                midChan = 2;\n            }\n        } else {\n            maxChan = 2;\n            minChan = 1;\n            midChan = 0;\n        }\n    } else {\n        if (color.y > color.z) {\n            maxChan = 1;\n            if (color.x > color.z) {\n                minChan = 2;\n                midChan = 0;\n            } else {\n                minChan = 0;\n                midChan = 2;\n            }\n        } else {\n            maxChan = 2;\n            minChan = 0;\n            midChan = 1;\n        }\n    }\n    \n    // Ignore if color isn't above limit in any channel\n    if (color[maxChan] > 1.0) {\n        // Find saturation of color if we weren't using a hue-preserving method\n        vec3 naiveLimited = min(color, vec3(1.0));\n        float naiveSat = naiveLimited[maxChan] - naiveLimited[minChan];\n        \n        // Avoid div by zero\n        if (naiveSat == 0.0) {\n            color = vec3(1.0);\n        } else {\n            // Find relative value between min channel value and max channel value of the middle channel\n            float midScale = (color[midChan] - color[minChan]) / (color[maxChan] - color[minChan]);\n        \n            color[maxChan] = 1.0;\n            color[minChan] = 1.0 - naiveSat;\n            color[midChan] = midScale * naiveSat + naiveLimited[minChan];\n        }\n    }\n    \n    return color;\n}\n\nfloat saw(float x) {\n    return abs(mod(x*2.0, 2.0) - 1.0);\n}\n\nvec3 hueToColor(float hue) {\n    float red = saw(hue);\n    float green = saw(hue - 0.3333);\n    float blue = saw(hue - 0.6667);\n    return clamp(vec3(red, green, blue) * 3.0 - 1.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 samp = texture(iChannel0, uv);\n    float halfW = floor(iResolution.x / 2.0);\n    \n    vec3 color = pow(samp.xyz, vec3(invGammaPwr));\n    \n    if (uv.y <= barHeight) {\n        color = hueToColor(uv.x*2.0);\n        if (uv.y <= barHeight/2.0) {\n            color = mix(vec3(0.0), color, uv.y / (barHeight/2.0));\n        } else {\n            color = mix(vec3(1.0), color, (barHeight - uv.y) / (barHeight/2.0));\n        }\n    }\n    \n    float mult = cos(iTime * speed * tau) * 7.5 + 8.5;\n    \n    color*= mult;\n    if (fragCoord.x >= halfW-1.0 && fragCoord.x <= halfW+1.0) {\n        color = vec3(0.0);\n    } else if (fragCoord.x > halfW) {\n        color = huePreservingClamp(color);\n    }\n    \n    color = pow(color, vec3(gammaPwr));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}