{"ver":"0.1","info":{"id":"4fSBDw","date":"1725151930","viewed":26,"name":"infinitesmiley","username":"fiiisssh","description":"fractal","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE_FAC (0.3)\n#define X_SPACING (1.4)\n\nfloat circleSDF(in vec2 p) {\n    return 1.0 - length(p);\n}\n\nfloat circleFill(in vec2 p, float s, float e) {\n    return smoothstep(s, e, circleSDF(p));\n}\n\nfloat circleOutline(in vec2 p, float w) {\n    float pixelwidth = fwidth(length(p));\n    return smoothstep(pixelwidth, -pixelwidth, abs(circleSDF(p)) - w);\n}\n\nfloat semicircleOutline(in vec2 p, float w, float s, float e) {\n    return max(0.0, -p.y) * smoothstep(e, s, abs(circleSDF(p)) - w);\n}\n\nfloat dirFromBitmask(uint mask, uint bit) {\n    uint val = (mask >> bit) & 1u;\n    return float(val) * 2.0 - 1.0;\n}\n\nfloat smiley2(in vec2 p, uint n) {\n    // gotta fake recursion\n    float res = 0.0;\n    \n    for (uint depth = 0u, ncols = 1u; depth < n; depth += 1u, ncols *= 2u) {\n        // this probably depends on endianness\n        for (uint col = 1u; col <= ncols; col += 2u) {\n            // gotta be an analytical way to do this?\n            // feel like i am missing something inherent about binary -- bc offset scale exponented by bits but that's how numbers work,\n            // something about how each binary digit shifts value on number line\n            // - the main difference is the change in direction but if u know the depth then pretend ur starting in the middle\n            // - basically a huffman coding\n            // - https://static.mikail-khan.com/huffman_line.png\n            // - but the resulting points we want aren't equally spaced??\n            // - probably because the \"base\" (exponent) is fractional, but we're still using binary?\n            //     - https://en.wikipedia.org/wiki/Non-integer_base_of_numeration\n            //     - so we are converting from our binary non int base to float ?\n            //     - but why are the points not equally spaced?\n            //         - i guess they would be with infinite digits\n            //         - so we are discovering the points of a non integer base with a certain length\n            //     - so is there a loop-free way to decode non int base? probably not?\n            // might be a cool way with modular arith\n            \n            uint posBitmask = col;\n\n            vec2 p = p;\n            float smileY = p.y;\n            float scaleFac = SCALE_FAC;\n            //for (uint i = 0u; i < depth; i += 1u, scaleFac *= SCALE_FAC) {\n            for (uint i = 0u; i < depth; i += 1u, scaleFac *= SCALE_FAC) {\n                float dir = dirFromBitmask(posBitmask, i);\n                float xshift = dir * scaleFac * X_SPACING;\n                \n                p += vec2(xshift, -0.65 * scaleFac);\n                \n                // could calculate analytically but might not be faster\n                // https://www.wolframalpha.com/input?i=sum+a*b%5Ex%2C+x+from+0+to+n\n                // https://stackoverflow.com/questions/39446306/glsl-pow-vs-multiplication-for-integer-exponent\n                smileY -= 0.65 * scaleFac;\n            }\n            \n            scaleFac /= SCALE_FAC;\n            \n            vec2 smileP = vec2(p.x, smileY + 0.275 * scaleFac);\n            smileP /= scaleFac * 0.5;\n            smileP.x /= 1.3;\n            \n            p /= scaleFac; // have to run scaling after offset bc the offsets are scaled individually\n            res += circleOutline(p, 0.01);\n            \n            res += semicircleOutline(smileP, 0.01, 0.0, 0.01);\n        }\n    }\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0)/iResolution.y/0.5;\n    float t = fract(iTime * 0.5);\n    //float t = 1.0;\n    float zoom = log2(t + 1.0); // idk why it's not smooth\n    \n    vec3 col = vec3(0.0);\n    \n    // 1. set goal_uv to position of eye\n    // 2. lerp towards goal_uv\n    // 3. maybe not linear, prob gotta exp time by scaling factor or smth?\n    // vec2 goal_uv = vec2(uv.x + 0.35 * 1.25, uv.y - 0.65 * 0.35) / 0.35; // we acc want the inv transform of this ig\n    vec2 l1_uv = (uv + vec2(-X_SPACING, 0.65)) * SCALE_FAC;\n    vec2 l2_uv = (l1_uv + vec2(-X_SPACING, 0.65)) * SCALE_FAC;\n    //col += vec3(0.0, 1.0, 0.0) * circleFill(goal_uv, 0.0, 0.01);\n\n    vec2 circle_uv = mix(l1_uv, l2_uv, zoom);\n    col += vec3(1.0, 1.0, 1.0) * smiley2(circle_uv, 8u);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}