{"ver":"0.1","info":{"id":"XfKSzz","date":"1714728029","viewed":54,"name":"Basic Audio Sphere","username":"aplysiida","description":"First time importing to ShaderToy and working with audio.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["audioreactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 128;\nconst float EPSILON = 0.001; //small amt\n\n//SDFs\nfloat sphereSDF(vec3 p, float s) {\n  return length(p) - s;\n}\n\nfloat displacement(vec3 p, float a) {\n  float angle = iTime;\n  float fp_dist = 8.0;\n  vec3 fp = vec3(fp_dist*sin(angle),fp_dist*cos(angle),0.0); //focus point\n  float diff = length(p-fp);\n  diff *= 0.1;\n  \n  float d = (a*0.7)*(diff*sin(p.x) + diff*sin(p.y) + diff*0.4*sin(p.z));\n  return d;\n}\n\nfloat sceneSDF(vec3 p, float freq) {\n  float s = sphereSDF(p,8.0);\n  \n  float d = displacement(p, freq);\n  return s+d;\n}\n\n//Ray marching + Lighting\nvec3 calcNorm(vec3 p, float freq) {\n  return normalize(\n    vec3(\n      sceneSDF(vec3(p.x+EPSILON,p.y,p.z), freq)-sceneSDF(vec3(p.x-EPSILON,p.y,p.z), freq),\n      sceneSDF(vec3(p.x,p.y+EPSILON,p.z), freq)-sceneSDF(vec3(p.x,p.y-EPSILON,p.z), freq),\n      sceneSDF(vec3(p.x,p.y,p.z+EPSILON), freq)-sceneSDF(vec3(p.z,p.y,p.z-EPSILON), freq)\n    )\n  );\n}\n\nfloat raymarch(in vec3 eye, in vec3 dir, in float freq, in float start, in float end) {\n  float t = start;\n\n  for(int i=0; i<MAX_MARCHING_STEPS; i++) {\n    float d = sceneSDF(eye+t*dir, freq);\n    if(d<EPSILON) {\n      return t; //inside sdf\n    }\n    t += d;\n    if(t>=end){\n      return end;\n    }\n  }\n      return end;\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 pixelCoord) {\n  vec2 xy = pixelCoord - size*0.5;     //map to -1,1\n  float z = size.y * 0.5 * tan(radians(fov)*0.5);\n  return normalize(vec3(xy, -z));\n}\n\nvec3 lighting(in vec3 p, in vec3 normal, in vec3 lightp) {\n  vec3 lightDir = normalize(lightp - p);\n  float intensity = max(0.0, dot(lightDir,normalize(normal)));\n  \n  vec3 colour = vec3(1.0,0.0,1.0);\n  int steps = 2;\n  colour *= max(ceil(intensity*float(steps))/(float(steps)),0.0);\n  return colour;\n}\n\nvec3 background_rings(vec2 st, float freq) {\n  vec3 colour = vec3(0.0);\n  float r = 0.5;\n  float dist = length(st) - r;\n  dist += 1.5*(sin(0.1*freq*st.x)+sin(0.1*freq*st.y));\n\n\n  float speed = iTime+(15.0*freq);\n  colour.b += step(cos(dist*0.2-speed)+1.2, 0.5); \n  return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {//main\n  vec2 st = fragCoord;\n  vec3 dir = rayDirection(45.0, iResolution.xy, st);\n  vec3 eye = vec3(0.0,0.0,12.0);\n  float low_freq = texture(iChannel0, vec2(0.0, 0.1)).r;\n  \n  float dist = raymarch(eye, dir, low_freq, 0.0, 100.0);\n  vec3 p = eye + dist*dir;\n  vec3 n = calcNorm(p, low_freq);\n  float angle = 0.7*iTime;\n  vec3 light_p = vec3(12.0*cos(angle),12.0*sin(angle),0.1); //focus point\n\n  vec3 c1 = background_rings(st, low_freq);\n\n  vec3 colour = c1; //bg\n  if(dist < (100.0-EPSILON)) {\n    colour = lighting(p,n,light_p);\n  }\n  fragColor = vec4(colour,1.0);\n}\n","name":"Image","description":"","type":"image"}]}