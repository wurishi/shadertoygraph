{"ver":"0.1","info":{"id":"MXVGW3","date":"1718390254","viewed":207,"name":"2D path-tracing test - Mouse","username":"berelium","description":"\"Made for the willstall challenge - 1 shader a week keeps the depression meek\n2D path-tracer for circles - press space to reset the progressive rendering\nThank you to Nameless#1608 on discord for all his help, IOU\"\nMade a few modifications for fun.","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["2d","mouse","interactive","circle","pathtracing"],"hasliked":0,"parentid":"4sfGRn","parentname":"Radial Blur"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"2D path-tracing test\" by clepirelli. https://shadertoy.com/view/sdBGWD\n// 2024-06-14 05:40:23\n\n// Modifications made:\n//   Added mouse movement with a vec3 to float conversion, storing the mouse position in the alpha channel of BufferB.\n//   Added an option to use ACES with Gamma correction instead of the original.\n//   The rest of the credit is due to clepirelli!\n\n#define ACES_TONEMAP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 textureColor = texture(iChannel0, uv).rgb;\n    \n    vec3 retColor;\n#ifndef ACES_TONEMAP\n    //from: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    textureColor *= 12.0;\n    vec3 f = max(vec3(.0), textureColor-.004);\n    retColor = (f*(6.2*f+.5))/(f*(6.2*f+1.7)+0.06);\n#else\n    retColor = textureColor * 10.0;\n    retColor = (retColor*(2.51*retColor+0.03))/(retColor*(2.43*retColor+0.59)+0.14);\n    retColor = pow(retColor, vec3(0.4545)); // Gamma / sRGB approximation\n#endif\n    fragColor = vec4(min(retColor, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ---- structs ----\nstruct Ray\n{\n    vec2 origin;\n    vec2 direction;\n};\n\nconst int lambertian = 0; //color is attenuation\nconst int light = 1; //color is emission\nconst int dielectric = 2; //color is attenuation, other is refraction index\n\nstruct Material\n{\n    int type;\n    vec3 color;\n    float other;\n};\n\nstruct Circle\n{\n    vec2 origin;\n    float radius;\n    Material material;\n};\n\nstruct IntersectionQuery\n{\n    bool result;\n    bool inside;\n    float nearest;\n    vec2 normal;\n    vec2 hit;\n    Material material;\n};\n\n// ---- materials ----\n\nvec3 applyMaterial(vec3 color, Material material)\n{\n    switch(material.type)\n    {\n        case dielectric:\n        case lambertian:\n            return color * material.color;\n        case light:\n            return material.color;   \n    }\n    return vec3(.0);\n}\n\n\n// ---- intersection queries ----\n\nvec2 pointOnRay(Ray ray, float dist)\n{\n    return ray.origin + ray.direction * dist;\n}\n\nconst IntersectionQuery miss = IntersectionQuery(false, false, -1000.0, vec2(.0), vec2(.0), Material(0, vec3(.0), .0));\n\nIntersectionQuery circleIntersection(Ray ray, Circle circle)\n{\n    float radius2 = circle.radius*circle.radius;\n    vec2 L = circle.origin - ray.origin; \n    float tca = dot(L, ray.direction); \n    float d2 = dot(L,L) - tca * tca; \n    if (d2 > radius2) return miss;\n    float thc = sqrt(radius2 - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    float nearest = min(t0, t1);\n    float nextNearest = max(t0, t1);\n    \n    bool inside = nearest < .0 && nextNearest > .0;\n    if(nearest < .0) \n    {\n        nearest = nextNearest;\n    }\n    \n    vec2 hit = pointOnRay(ray, nearest);\n    vec2 normal = (circle.origin - hit)/circle.radius;\n    return IntersectionQuery(nextNearest > .0, inside, nearest, normal, hit, circle.material);\n}\n\n// ---- randomness and ray generation ----\n\nvec2 angleToDirection(float angle)\n{\n    return vec2(sin(angle), cos(angle));\n}\n\nfloat pseudorandScalar(vec2 randseed, vec2 uv,  sampler2D tex, int channel)\n{\n    //blue noise with toroidal shifting\n\treturn fract(texture(tex, uv)[channel] + fract(sin(dot(randseed, vec2(1.0,113.0)))*43758.5453123));\n}\n\nfloat randomRadians(vec2 randseed, vec2 uv,  sampler2D tex)\n{\n    return (pseudorandScalar(randseed, uv, tex, 0)-.5)*2.0*3.14;\n}\n\nvec2 randomDirectionInHemicircle(vec2 direction, vec2 randseed , vec2 uv,  sampler2D tex, int channel) \n{\n    float randomOffset = (pseudorandScalar(randseed, uv, tex, channel))*2.0*3.14;\n    vec2 randomDirection = vec2(sin(randomOffset), cos(randomOffset));\n    return normalize(randomDirection+direction);\n}\n\n\n// ==== Additions ====  >  Credit - msure1200q_1UWE130 : https://www.shadertoy.com/view/wt23Wh\n#define pre    256.0\n#define pre2   pre*pre\n#define pre3   pre*pre2\n#define pre3d2 pre3/2.\nfloat vec3ToFloat(in vec3 c) {\n    c *= pre-1.;\n    c = floor(c);\n    return c.r*pre2 + c.g*pre + c.b - pre3d2;\n}\n\n// values out of <-8388608;8388608> are stored as min/max values\nvec3 floatToVec3(in float val) {\n    val += pre3d2; // this makes values signed\n    if(val > pre3)  return vec3(1.);\n    \n    vec3 c = vec3(0.);\n    c.b = mod(val, pre);\n    val = floor(val/pre); c.g = mod(val, pre);\n    val = floor(val/pre); c.r = mod(val, pre);\n    \n    return c/(pre-1.);\n}\n// ===================\n\n//---- boilerplate ----\n\n#define spacePressed(sampler) texelFetch(sampler,ivec2(32, 0), 0).x > 0.0\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    /*MSAA*/\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \t/*offset the uv for MSAA*/\\\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n    \tvec2 tempUV = uv;\\\n        total += function(tempUV, fragCoord);\\\n    }\\\n    total /= float(aa*aa);\\\n    /*Capture mouse*/\\\n    vec2 mo = abs(iMouse.xy / iResolution.xy);\\\n    /*Output to screen*/\\\n    fragColor = vec4( total, iMouse.z > 0. ? vec3ToFloat(vec3(mo, 0.0)) : vec3ToFloat(floatToVec3(texelFetch(iChannel0, ivec2(0), 0).w)) );\\\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //from: https://www.shadertoy.com/view/wlGcD1\n    uint frameCount = floatBitsToUint(texelFetch(iChannel0, ivec2(0,0), 0).x);\n    if(iFrame == 0 || spacePressed(iChannel1) || iMouse.z > 0.)\n    {\n        frameCount = 0u;\n    } else \n    {\n        frameCount = frameCount + 1u;\n    }\n\n    fragColor = vec4(uintBitsToFloat(frameCount));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int aa = 3;\nconst int maxBounces = 7;\n\nconst int circleAmount = 5;\nCircle circles[circleAmount] = Circle[circleAmount]\n(\n\tCircle(vec2(-.4,  .1),  .2, Material(light, vec3(.1), .0)),\n    Circle(vec2( .2,  .1),  .05, Material(dielectric, vec3(1.0, .47,.0), .25)),\n\tCircle(vec2( .2, -.1),  .10, Material(dielectric, vec3(1.0, 1.0, .9), .9)),\n    Circle(vec2( .5, -.2),  .05, Material(dielectric, vec3(1.0, 0.4, .4), .2)),\n    Circle(vec2( -.1, -.2),  .08, Material(dielectric, vec3(1.0, .0, .0), .2))\n);\n\nIntersectionQuery traceScene(Ray currentRay)\n{\n    IntersectionQuery finalQuery = miss;\n    \n    // Addition - Move the light\n    vec2 mo = floatToVec3(texelFetch(iChannel0, ivec2(0), 0).w).xy;\n    mo -= 0.5;\n    mo.x *= iResolution.x/iResolution.y;\n    if(iMouse.x == 0. && iMouse.y == 0.) mo = vec2(-0.4, 0.1); // default position\n    circles[0].origin = mo;\n    // =========================\n    \n    for(int i = 0; i < circleAmount; i++)\n    {\n        IntersectionQuery currentQuery = circleIntersection(currentRay, circles[i]);\n        if(!finalQuery.result || (currentQuery.result && currentQuery.nearest < finalQuery.nearest))\n        {\n            finalQuery = currentQuery;\n        }\n    }\n\n    return finalQuery;\n}\n\nRay scatter(IntersectionQuery query, Ray ray, vec2 uv, vec2 seed, int channel)\n{\n    vec2 direction, origin;\n    vec2 normal = query.inside ? -query.normal : query.normal;\n    switch(query.material.type)\n    {\n        case dielectric:\n            float refractionIndex = query.material.other;\n            direction = refract(ray.direction, -normal, refractionIndex);\n            origin = query.hit+normal*.1; //technically should be less but it looks cool\n            break;\n        case lambertian:\n            direction = randomDirectionInHemicircle(query.normal, seed, uv, iChannel1, channel);\n            origin = query.hit+normal*.001;\n            break;\n    }\n    return Ray(origin, direction);\n}\n\nvec3 trace(vec2 uv)\n{\n    float currentRayAngle = randomRadians(uv+iTime, uv, iChannel1);\n    Ray currentRay = Ray(uv, angleToDirection(currentRayAngle));\n    \n    IntersectionQuery queries[maxBounces];\n    int queryCount = 0;\n        \n    for(int i = 0; i < maxBounces; i++)\n    {\n        IntersectionQuery query = traceScene(currentRay);\n        queries[queryCount] = query;\n        queryCount++;\n        \n        if(query.result && query.material.type != light)\n        {\n            vec2 seed = uv+iTime+float(i)*4.1323; //this kinda works, pretty wonky though\n            int channel = int(mod(float(i+1), 3.0));\n            currentRay = scatter(query, currentRay, uv, seed, channel);\n        } else break;\n    }\n    \n    vec3 col = vec3(.0); \n    for(int i = queryCount; i >= 0; i--)\n    {     \n        if(!queries[i].result)\n        {\n            col = vec3(.98, .48, .38)*.01; //ambient color, dawn-ish\n        } else\n        {\n            col = applyMaterial(col, queries[i].material);\n        }\n    }\n    return col;\n}\n\nvec3 outputCol(vec3 thisCol, vec2 fragCoord)\n{\n    uint frame = floatBitsToUint(texelFetch(iChannel2, ivec2(0,0), 0).x);\n    vec3 previousCol = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    return float(frame)/float(frame+1u)*previousCol + 1.0/float(frame+1u)*thisCol;\n}\n\nvec3 BufferB(vec2 uv, vec2 fragCoord)\n{\n    if(iFrame == 0)\n    {\n        return vec3(.0);\n    }\n    return outputCol(trace(uv), fragCoord);\n}\n\nMAIN_FUNCTION(BufferB)","name":"Buffer B","description":"","type":"buffer"}]}