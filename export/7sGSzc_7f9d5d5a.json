{"ver":"0.1","info":{"id":"7sGSzc","date":"1639089210","viewed":158,"name":"Game of life w/ smooth time","username":"muph","description":"Cellular automaton with continuous time\nControls: E: enable simulation, S: step, R: randomize, B: toggle brush. Click anywhere to paint.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["gameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define COLOR_COUNT 5\n\nvec3 cramp_data[COLOR_COUNT] = vec3[COLOR_COUNT](\n    vec3(0.0,  0.00, 0.00),\n    vec3(.226, 0.00, 0.6),\n    vec3(0.90, 0.25, 0.25),\n    vec3(0.90, 0.75, 0.00),\n    vec3(1.5, 1.0, 1.0)\n);\n\nvec3 cramp(float amount) {\n\n    if (amount >= 0.0 && amount <= 1.0) {\n    \n        float step_n = float(COLOR_COUNT - 1) * amount;\n\n        vec3 color1 = cramp_data[int(floor(step_n))];\n        vec3 color2 = cramp_data[int(ceil(step_n))];\n\n        vec3 result = mix(color1,color2,fract(step_n));\n\n        return result;\n    }    \n    if (amount >= -1.0 && amount < 0.0) {\n        return mix(vec3(1.0, 0.0, 0.0), vec3(0.,0.,0.), pow(amount+1., 1.5));\n    }\n    if (amount >= 1.0) {\n        return mix(vec3(1.0, 1.0, 1.0), vec3(0.5,0.8,1.0), amount - 1.0);\n    }\n    \n    \n    return vec3(1.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = screenToWorld(fragCoord.xy);\n\n    float cell = texelFetch( iChannel0, px, 0 ).x;\n    float noise = texelFetch( iChannel0, px, 0 ).y;\n\n    fragColor = vec4( cramp(cell + noise), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_E 69\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n\nbool keyDown(int keyCode, sampler2D tex) {\n    return texelFetch( tex, ivec2(keyCode, 0), 0 ).x > .5;\n}\n\nbool keyPress(int keyCode, sampler2D tex) {\n    return texelFetch( tex, ivec2(keyCode, 1), 0 ).x > .5;\n}\n\nbool keyToggle(int keyCode, sampler2D tex) {\n    return texelFetch( tex, ivec2(keyCode, 2), 0 ).x > .5;\n}\n\nconst float scale = 3.;\n\nivec2 screenToWorld(vec2 fragPos) {\n    return ivec2(fragPos / scale);\n}\nvec2 worldToScreen(ivec2 cellPos) {\n    return vec2(cellPos) * scale;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define KEY_STEP KEY_S\n#define KEY_ENABLE KEY_E\n#define KEY_RANDOM KEY_R\n#define KEY_CLEAR KEY_Q\n#define KEY_BRUSH KEY_B\n\nvec4 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nconst float rules[9] = float[9]( -.5, -.5, -.5, 0.95, -1., -1., -1., -1., -1. );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dt = 0.15;\n    ivec2 ms = screenToWorld( iMouse.xy );\n    ivec2 px = ivec2( fragCoord );\n    \n    float posHash = hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    float rawNoise = hash1(iTime * posHash);\n    \n\tfloat sum = Cell(px+ivec2(-1,-1)).x + Cell(px+ivec2(0,-1)).x + Cell(px+ivec2(1,-1)).x\n              + Cell(px+ivec2(-1, 0)).x                          + Cell(px+ivec2(1, 0)).x\n              + Cell(px+ivec2(-1, 1)).x + Cell(px+ivec2(0, 1)).x + Cell(px+ivec2(1, 1)).x;\n        \n    float next = Cell(px).x;\n    float nextNoise = Cell(px).y;\n    \n    sum += nextNoise + .5;\n        \n    if (!keyToggle(KEY_ENABLE, iChannel1) || keyPress(KEY_STEP, iChannel1)) {\n        // simulation is running\n    \n        next += rules[int(clamp(sum, 0.0, 8.9))]*dt;\n        nextNoise = 0.0 * sign(rawNoise) * pow(abs(rawNoise), 99.0);\n        next = clamp(next, 0.0, 1.0);\n    }\n\n    // user interaction\n    if ( iFrame==0 || keyPress(KEY_RANDOM, iChannel1) ) next = abs(rawNoise);\n    if ( keyPress(KEY_CLEAR, iChannel1) ) next = 0.0;\n    if ( length(vec2(ms - px)) <= 50.0 && iMouse.z > .5 ) next = keyToggle(KEY_BRUSH, iChannel1) \n        ? abs(rawNoise) \n        : 0.;\n    \n    fragColor = vec4( next, nextNoise, 0.0, 0.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}