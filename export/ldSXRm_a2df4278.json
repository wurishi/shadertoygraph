{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Constants\nconst float M_PI    = 3.14159265358979323846;\nconst float M_SQRT2 = 1.41421356237309504880;\n\n\n\n// -------------------------------------------------\n// Hammer forward transform\n// ------------------------\nvec2 transform_forward(vec2 P)\n{\n    const float B = 2.0;\n    float longitude = P.x;\n    float latitude  = P.y;\n    float cos_lat = cos(latitude);\n    float sin_lat = sin(latitude);\n    float cos_lon = cos(longitude/B);\n    float sin_lon = sin(longitude/B);\n    float d = sqrt(1.0 + cos_lat * cos_lon);\n    float x = (B * M_SQRT2 * cos_lat * sin_lon) / d;\n    float y =     (M_SQRT2 * sin_lat) / d;\n    return vec2(x,y);\n}\n\n// Hammer Inverse transform\n// ------------------------\nvec2 transform_inverse(vec2 P)\n{\n    const float B = 2.0;\n    float x = P.x;\n    float y = P.y;\n    float z = 1.0 - (x*x/16.0) - (y*y/4.0);\n    if (z < 0.0)\n        discard;\n    z = sqrt(z);\n    float lon = 2.0*atan( (z*x),(2.0*(2.0*z*z - 1.0)));\n    float lat = asin(z*y);\n    return vec2(lon,lat);\n}\n// -------------------------------------------------\n\n\n\n\n// [-0.5,-0.5]x[0.5,0.5] -> [xmin,xmax]x[ymin,ymax]\n// ------------------------------------------------\nvec2 scale_forward(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P += vec2(.5,.5);\n    P *= vec2(limits[1] - limits[0], limits[3]-limits[2]);\n    P += vec2(limits[0], limits[2]);\n    return P;\n}\n\n// [xmin,xmax]x[ymin,ymax] -> [-0.5,-0.5]x[0.5,0.5]\n// ------------------------------------------------\nvec2 scale_inverse(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P -= vec2(limits[0], limits[2]);\n    P /= vec2(limits[1]-limits[0], limits[3]-limits[2]);\n    return P - vec2(.5,.5);\n}\n\n// Antialias stroke alpha coeff\nfloat stroke_alpha(float distance, float linewidth, float antialias)\n{\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n    if( border_distance > (linewidth/2.0 + antialias) )\n        return 0.0;\n    else if( border_distance < 0.0 )\n        return 1.0;\n    else\n        return alpha;\n}\n\n// Compute the nearest tick from a (normalized) t value\nfloat get_tick(float t, float vmin, float vmax, float step)\n{\n    float first_tick = floor((vmin + step/2.0)/step) * step;\n    float last_tick = floor((vmax + step/2.0)/step) * step;\n    float tick = vmin + t*(vmax-vmin);\n    if (tick < (vmin + (first_tick-vmin)/2.0))\n        return vmin;\n    if (tick > (last_tick + (vmax-last_tick)/2.0))\n        return vmax;\n    tick += step/2.0;\n    tick = floor(tick/step)*step;\n    return min(max(vmin,tick),vmax);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t// Cartesian limits\n\tvec4 u_limits1 = vec4(-3., +3., -1.5, +1.5);\n\n\t// Projected limits\n\tvec4 u_limits2 = vec4(-M_PI, M_PI- M_PI*(1.+cos(iTime))/2.0,\n                           -M_PI/2. + (1.+cos(iTime))/2.*M_PI/4.,\n                           +M_PI/2. - (1.+cos(iTime/2.))/2.*M_PI/4.);\n\n                          \n    const float u_antialias = 1.0;\n\tvec2 u_major_grid_step = vec2(M_PI/4.0,  M_PI/6.0);\n\tvec2 u_minor_grid_step = vec2(M_PI/40.0, M_PI/60.0);\n\tfloat u_major_grid_width = 2.00;\n\tfloat u_minor_grid_width = 1.00;\n\tvec4  u_major_grid_color = vec4(0,0,0,1);\n\tvec4  u_minor_grid_color = vec4(0,0,0,1);\n\n    \n    \n    \n    vec2 v_texcoord = fragCoord.xy / iResolution.xy - 0.5;\n    vec2 v_size = iResolution.xy;    \n\n    \n    vec2 NP1 = v_texcoord;\n    vec2 P1 = scale_forward(NP1, u_limits1);\n    vec2 P2 = transform_inverse(P1);\n\n    // Test if we are within limits but we do not discard yet because we want\n    // to draw border. Discarding would mean half of the exterior not drawn.\n    bvec2 outside = bvec2(false);\n    if( P2.x < u_limits2[0] ) outside.x = true;\n    if( P2.x > u_limits2[1] ) outside.x = true;\n    if( P2.y < u_limits2[2] ) outside.y = true;\n    if( P2.y > u_limits2[3] ) outside.y = true;\n\n    vec2 NP2 = scale_inverse(P2,u_limits2);\n    vec2 P;\n    float tick;\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_major_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float Mx = length(v_size * (NP1 - P));\n    // float Mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_minor_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float mx = length(v_size * (NP1 - P));\n    // float mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_major_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float My = length(v_size * (NP1 - P));\n    // float My = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_minor_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float my = length(v_size * (NP1 - P));\n    // float my = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    float M = min(Mx,My);\n    float m = min(mx,my);\n\n    // Here we take care of \"finishing\" the border lines\n    if( outside.x && outside.y ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = max(Mx,My);\n        }\n    } else if( outside.x ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = Mx;\n        }\n    } else if( outside.y ) {\n        if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = My;\n        }\n    }\n\n    // Mix major/minor colors to get dominant color\n    vec4 color = u_major_grid_color;\n    float alpha1 = stroke_alpha( M, u_major_grid_width, u_antialias);\n    float alpha2 = stroke_alpha( m, u_minor_grid_width, u_antialias);\n    float alpha  = alpha1;\n    if( alpha2 > alpha1*1.5 )\n    {\n        alpha = alpha2;\n        color = u_minor_grid_color;\n    }\n\n    // At no extra cost we can also project a texture\n    if( outside.x || outside.y ) {\n        fragColor = mix(vec4(1,1,1,1), color, alpha);\n    } else {\n        vec4 texcolor = texture(iChannel0, vec2(NP2.x+0.5, NP2.y+0.5));\n        fragColor = mix(texcolor, color, color.a*alpha);\n    }\n    // fragColor = mix(vec4(1,1,1,1), color, alpha);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldSXRm","date":"1410253389","viewed":446,"name":"Hammer grid","username":"rougier","description":"Hammer projection (see http://en.wikipedia.org/wiki/Hammer_projection)\nBetter in full screen.\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["grid","antialias","projection","distance","polar","hammer","mercator","cartesian"],"hasliked":0,"parentid":"","parentname":""}}