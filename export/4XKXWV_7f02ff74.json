{"ver":"0.1","info":{"id":"4XKXWV","date":"1720511938","viewed":45,"name":"Pythagorean Sage Fractal","username":"robfast","description":"tessellations of a strange function ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","pythagorean","sage","fastaro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nvec2 complexMul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = b.x*b.x + b.y*b.y;\n    return vec2(\n        (a.x*b.x + a.y*b.y) / denom,\n        (a.y*b.x - a.x*b.y) / denom\n    );\n}\nfloat customIterationFunction(float x, float log_p, float log_q) {\n    float term1 = (-1.0 + floor((x * log_p) / log_q)) * floor((x * log_p) / log_q) * log_q;\n    float term2 = (2.0 * log_p);\n    float term3 = floor((x * log_p) / log_q) * (x - (log_q / log_p) * floor((x * log_p) / log_q));\n    return (term1 / term2) + term3;\n}\n\nfloat complexFloor(vec2 z) {\n    return sqrt(floor(z.x)*floor(z.x)+floor(z.y)*floor(z.y));\n}\n\nvec2 transform(vec2 z) {\n    float p = 3.0;\n    float q = 2.0;\n\n    float logp = log(p);\n    float logq = log(q);\n    q =customIterationFunction(length(z),logp,logq)+q;\n    p =customIterationFunction(length(z),logp,logq)+p;\n    \n    vec2 zLogpOverLogq = complexDiv(complexMul(z, vec2(logp, 0.0)), vec2(logq, 0.0));\n    float floorTerm = complexFloor(zLogpOverLogq);\n    \n    vec2 term1 = vec2((-1.0 + floorTerm) * floorTerm * logq / (2.0 * logp), 0.0);\n    vec2 term2 = complexMul(vec2(floorTerm, 0.0), z - complexMul(vec2(logq / logp, 0.0), vec2(floorTerm, 0.0)));\n    \n    return term1 + term2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= 77.0; // Adjust scale\n     float zoom = sin(iTime/3.0)+(iTime/35.0);\n    // Create grid\n    vec2 gridSize = vec2(222.0, 222.0);\n    vec2 cell = fract(uv * gridSize) - 0.5;\n    vec2 cellIndex = floor(uv * gridSize);\n    \n    // Apply transformation\n    float xRange = 2.0 * log(2.0) / log(3.0);\n    float yRange = log(2.0) / log(3.0);\n    vec2 z = vec2(\n        mix(-xRange, xRange, (cellIndex.x / gridSize.x + 0.5)),\n        mix(-yRange, yRange, (cellIndex.y / gridSize.y + 0.5))\n    );\n    vec2 transformed = transform(z+zoom);\n    \n    // Draw grid lines\n    float lineWidth = 0.0005;\n    float line = smoothstep(lineWidth, 0.0, abs(cell.x)) + smoothstep(lineWidth, 0.0, abs(cell.y));\n    \n    // Color based on transformed position\n    vec3 col = 0.5 - cos(transformed.xyx * 0.5 + vec3(0, 2, 4));\n    \n    // Combine grid and color\n    col = mix(col, vec3(1.0), line);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}