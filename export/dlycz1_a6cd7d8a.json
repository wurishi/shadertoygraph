{"ver":"0.1","info":{"id":"dlycz1","date":"1699983706","viewed":39,"name":"Torus Shenanigans","username":"Arathain","description":"don ut  rotat e","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","simple","torus","camera"],"hasliked":0,"parentid":"csKBWG","parentname":"Sphere shenanigans"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Torus {\n    vec3 center;\n    float radius;\n    float ringRadius;\n};\n\nbool rayIntersection(vec3 dir, vec3 targetDiff, float radius) {\n        vec3 oc = targetDiff;\n        float l = dot(dir, oc);\n        float det = pow(l, 2.0) - dot(oc, oc) + pow(radius, 2.0);\n        if (det < 0.0) \n            return false;\n\n        float len = l - sqrt(det);\n        \n        if (len < 0.0) \n            len = l + sqrt(det);\n        if (len < 0.0) \n            return false;\n        \n        return true;\n}\n\nbool rayIntersectionMath(vec3 dir, vec3 targetDiff, float radius) {\n        float a = length(dir)*length(dir);\n        float b = dot(2.*dir, targetDiff);\n        float c = length(targetDiff)*length(targetDiff)-radius*radius;\n        \n        return b*b-4.*a*c > 0.;\n}\n\n\nvec3 torusRayIntersectionMath(vec3 dir, vec3 targetDiff, float radius, float ring) {\n\n    float a = 1.;\n    \n    float b = 2.*dot(dir, targetDiff);\n    \n    float c = length(targetDiff)*length(targetDiff) + (radius*radius - ring*ring);\n    \n    float d = 4. * radius*radius * (dir.x*dir.x + dir.y*dir.y);\n    \n    float e = 8. * radius*radius * (dir.x*targetDiff.x + dir.y*targetDiff.y);\n    \n    float f = 4. * radius*radius * (targetDiff.x*targetDiff.x + targetDiff.y*targetDiff.y);\n    \n    \n    float g = 1.;\n    \n    float h = 2.*b;\n    \n    float i = 2.*c + b*b - d;\n    \n    float j = 2.*b*c - e;\n    \n    float k = c*c - f;\n    \n    float P = 8.*i - 3.*h*h;\n    float R = h*h*h + 8.*j - 4.*h*i;\n    float T = 64.*k - 16.*i*i + 16.*h*h*i - 16.*h*j - 3.*h*h*h*h;\n    \n    float deltaZero = i*i - 3. * h * j + 12. * k;\n    \n    float DISC = \n    256.*k*k*k \n    - 192.*h*j*k*k \n    - 128.*i*i*k*k \n    + 144.*i*j*j*k \n    - 27.*j*j*j*j \n    + 144.*h*h*i*k*k \n    - 6.*h*h*j*j*k \n    - 80.*h*i*i*j*k \n    + 18.*h*i*j*j*j \n    + 16.*i*i*i*i*k \n    - 4.*i*i*i*j*j \n    - 27.*h*h*h*h*k*k \n    + 18.*h*h*h*i*j*k \n    - 4.*h*h*h*j*j*j \n    - 4.*h*h*i*i*i*k \n    + h*h*i*i*j*j;\n\n    if(DISC > 0. && (P > 0. || T > 0.))\n        return vec3(0.);\n    \n    if(DISC == 0. && T == 0. && R == 0. && P > 0.)\n        return vec3(0.);\n     \n   \n    return vec3(0.6, 0.8, 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float scale = 0.9;\n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*scale*cos(an), 1.0, 2.5*scale*sin(an) );\n    vec3 ta = vec3( 0.0, 0.1, 0.0 );\n\n   // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraPos = ro;\n    \n    vec3 rayDirection = normalize(uv.x*uu + uv.y*vv +  1.*ww);\n    Sphere sp = Sphere(vec3(cos(iTime)*scale, 0.0, sin(iTime)*scale), 0.3*scale);\n    vec3 col = rayIntersectionMath(rayDirection, sp.center-cameraPos, sp.radius) ? vec3(0.9, 0.8, 0.6) : vec3(0.0);\n    Torus t = Torus(vec3(0., 0.2, 0.)*scale, 1.8*scale, 0.2*scale);\n    vec3 torus = torusRayIntersectionMath(rayDirection, cameraPos-t.center, t.radius, t.ringRadius);\n    col += torus;\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}