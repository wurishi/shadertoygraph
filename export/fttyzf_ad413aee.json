{"ver":"0.1","info":{"id":"fttyzf","date":"1660253400","viewed":132,"name":"Adaptive Integration","username":"Envy24","description":"Adaptive Integration described in book: \"Numerical Methods for Engineers\", Steven S. Chapra, Raymond P. Canale.\n\nGreen - f(x), Red - definite integral of f(x), Purple - subdivision points, Blue - integral value corresponding to purple points.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["numerical","integral","integration","adaptive","method","definite"],"hasliked":0,"parentid":"sl3yRf","parentname":"Romberg-Richardson Integration"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n// Redefine this macroses for your function.\n#define integ(x)         ( -cos(x) + 1. )  // analytic definite integral form a to b of func(x) (by default a = 0 = const).\n#define func(x)          ( sin(x) )\n#define deriv(x)         ( cos(x) )\n\n#define RULE(a, b, data) adaptive_integration((a), (b), (data))\n\n/*\n    [a, b] - closed interval,\n    n - number of subintervals.\n*/\nfloat integrate_trapezoid(float a, float b, float n)\n{\n    float dx = (b-a)/n, sum = 0.5*(func(a) + func(b));   \n    \n    for (float i = 1.0; i < n; i+=1.) { sum += func(a + i * dx); }   \n    \n    return sum * dx;\n}\n\nstruct ext\n{\n    vec3 color;\n    vec2 NDC;\n    bool draw;\n};\n\nfloat recursive_call_lvl4(float a, float b, float tolerance, float fa, float fc, float fb, inout ext data)\n{\n    float h1 = b - a, h2 = (b - a) * 0.5, c = (a + b) * 0.5,\n          fd = func((a + c) * 0.5), fe = func((c + b) * 0.5),\n          I1 = h1 / 6.0 * (fa + 4. * fc + fb),\n          I2 = h2 / 6.0 * (fa + 4. * fd + 2. * fc + 4. * fe + fb);\n\n    /* Just for drawing */\n    if (data.draw == true) \n    { \n        data.color = mix(data.color, vec3(1, 0, 1), SM(diskSDF_L2(data.NDC, vec2(c, fc), UNIT*1.2)));\n    }\n    /* */\n\n    if (abs(I2 - I1) < tolerance)\n    {\n        return I2 + (I2 - I1) / 15.;\n    }\n\n    //float Ia = recursive_call_lvl5(a, c, tolerance, fa, fd, fc);\n    //float Ib = recursive_call_lvl5(c, b, tolerance, fc, fe, fb);\n\n    return I2;\n}\n\nfloat recursive_call_lvl3(float a, float b, float tolerance, float fa, float fc, float fb, inout ext data)\n{\n    float h1 = b - a, h2 = (b - a) * 0.5, c = (a + b) * 0.5,\n          fd = func((a + c) * 0.5), fe = func((c + b) * 0.5),\n          I1 = h1 / 6.0 * (fa + 4. * fc + fb),\n          I2 = h2 / 6.0 * (fa + 4. * fd + 2. * fc + 4. * fe + fb);\n\n    /* Just for drawing */\n    if (data.draw == true) \n    { \n        data.color = mix(data.color, vec3(1, 0, 1), SM(diskSDF_L2(data.NDC, vec2(c, fc), UNIT*1.2)));\n    }\n    /* */\n\n    if (abs(I2 - I1) < tolerance)\n    {\n        return I2 + (I2 - I1) / 15.;\n    }\n\n    float Ia = recursive_call_lvl4(a, c, tolerance, fa, fd, fc, data);\n    float Ib = recursive_call_lvl4(c, b, tolerance, fc, fe, fb, data);\n\n    return Ia + Ib;\n}\n\nfloat recursive_call_lvl2(float a, float b, float tolerance, float fa, float fc, float fb, inout ext data)\n{\n    float h1 = b - a, h2 = (b - a) * 0.5, c = (a + b) * 0.5,\n          fd = func((a + c) * 0.5), fe = func((c + b) * 0.5),\n          I1 = h1 / 6.0 * (fa + 4. * fc + fb),\n          I2 = h2 / 6.0 * (fa + 4. * fd + 2. * fc + 4. * fe + fb);\n\n    /* Just for drawing */\n    if (data.draw == true) \n    { \n        data.color = mix(data.color, vec3(1, 0, 1), SM(diskSDF_L2(data.NDC, vec2(c, fc), UNIT*1.2)));\n    }\n    /* */\n\n    if (abs(I2 - I1) < tolerance)\n    {\n        return I2 + (I2 - I1) / 15.;\n    }\n\n    float Ia = recursive_call_lvl3(a, c, tolerance, fa, fd, fc, data);\n    float Ib = recursive_call_lvl3(c, b, tolerance, fc, fe, fb, data);\n\n    return Ia + Ib;\n}\n\nfloat recursive_call_lvl1(float a, float b, float tolerance, float fa, float fc, float fb, inout ext data)\n{\n    float h1 = b - a, h2 = (b - a) * 0.5, c = (a + b) * 0.5,\n          fd = func((a + c) * 0.5), fe = func((c + b) * 0.5),\n          I1 = h1 / 6.0 * (fa + 4. * fc + fb),\n          I2 = h2 / 6.0 * (fa + 4. * fd + 2. * fc + 4. * fe + fb);\n\n    /* Just for drawing */\n    if (data.draw == true) \n    { \n        data.color = mix(data.color, vec3(1, 0, 1), SM(diskSDF_L2(data.NDC, vec2(c, fc), UNIT*1.2)));\n    }\n    /* */\n\n    if (abs(I2 - I1) < tolerance)\n    {\n        return I2 + (I2 - I1) / 15.;\n    }\n\n    float Ia = recursive_call_lvl2(a, c, tolerance, fa, fd, fc, data);\n    float Ib = recursive_call_lvl2(c, b, tolerance, fc, fe, fb, data);\n\n    return Ia + Ib;\n}\n\nfloat recursive_call_lvl0(float a, float b, float tolerance, float fa, float fc, float fb, inout ext data)\n{\n    float h1 = b - a, h2 = (b - a) * 0.5, c = (a + b) * 0.5,\n          fd = func((a + c) * 0.5), fe = func((c + b) * 0.5),\n          I1 = h1 / 6.0 * (fa + 4. * fc + fb),\n          I2 = h2 / 6.0 * (fa + 4. * fd + 2. * fc + 4. * fe + fb);\n\n    /* Just for drawing */\n    if (data.draw == true) \n    { \n        data.color = mix(data.color, vec3(1, 0, 1), SM(diskSDF_L2(data.NDC, vec2(c, fc), UNIT*1.2)));\n    }\n    /* */\n\n    if (abs(I2 - I1) < tolerance)\n    {\n        return I2 + (I2 - I1) / 15.;\n    }\n\n    float Ia = recursive_call_lvl1(a, c, tolerance, fa, fd, fc, data);\n    float Ib = recursive_call_lvl1(c, b, tolerance, fc, fe, fb, data);\n\n    return Ia + Ib;\n}\n\nfloat adaptive_integration(float a, float b, inout ext data)\n{\n    const float tolerance = 1e-5;\n    float c = (a + b) * 0.5, fa = func(a), fc = func(c), fb = func(b);\n\n    /* Just for drawing */\n    if (data.draw == true) \n    { \n        data.color = mix(data.color, vec3(1, 0, 1), SM(diskSDF_L2(data.NDC, vec2(a, fa), UNIT*1.2)));\n        data.color = mix(data.color, vec3(1, 0, 1), SM(diskSDF_L2(data.NDC, vec2(b, fb), UNIT*1.2)));\n    }\n    /* */\n\n    return recursive_call_lvl0(a, b, tolerance, fa, fc, fb, data);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 2.0\n#define YSCALE 1.0\n#define OFFSET vec2(1.5, 0.25)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n            \n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*deriv(NDC.x));\n         //color.rg -= draw_func(NDC, YSCALE*integ(NDC.x), YSCALE*func(NDC.x));\n         \n         /* \"All\" values of definite integral */\n         ext data; data.draw = false;\n         float n = 1., a = 0.,  b = NDC.x,\n               y = RULE(a, b, data);\n         color.gb -= draw_func(NDC, YSCALE*y, YSCALE*func(NDC.x));\n    \n    /* One value of definite integral (trapezoid rule). */\n    a= 0., b=sinOSC(0.0, 4.5, iTime*0.5);\n    float dx = (b-a)/n, radius = UNIT;\n\n    data.color = color; data.NDC = NDC; data.draw = true; y = RULE(a, b, data);\n    color = mix(data.color, vec3(0, 0, 1), SM(diskSDF_L2(NDC, vec2(b, YSCALE*y), radius*1.2)));\n    /**/\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}