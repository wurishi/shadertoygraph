{"ver":"0.1","info":{"id":"WlV3Ry","date":"1582353765","viewed":87,"name":"thebookofshaders-shapes","username":"enigmawxy","description":"the Shapes for the Book of Shaders","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TUTORIAL 8\n\n#if TUTORIAL == 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    // Each result will return 1.0 (white) or 0.0 (black).\n    //float left = step(.1, uv.x);   // Similar to ( X greater than 0.1 )\n    //float bottom = step(.1, uv.y); // Similar to ( Y greater than 0.1 )\n    // The multiplication of left*bottom will be similar to the logical AND.\n    //color = vec3(left * bottom);\n    //color = vec3(left * bottom);\n    // 简化写法，利用step定义\n    vec2 pct = step(vec2(.1), uv);\n    color = vec3(pct.x*pct.y);\n\n    fragColor = vec4(color,1.0);\n}\n#elif TUTORIAL == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.);\n    \n    vec2 bl = step(vec2(.1), uv);\n    float pct = bl.x * bl.y;\n    \n    // top-right\n    vec2 tr = step(vec2(0.1),1.0-uv);\n    pct *= tr.x * tr.y;\n    \n    color = vec3(pct);\n    \n    fragColor = vec4(color,1.0);\n}\n#elif TUTORIAL == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    vec2 bl = smoothstep(vec2(.1),vec2(.12), uv);\n    float pct = bl.x * bl.y;\n    \n    // top-right\n    vec2 tr = smoothstep(vec2(0.1),vec2(.12),1.0-uv);\n    pct *= tr.x * tr.y;\n    \n    color = vec3(pct);\n    \n    fragColor = vec4(color,1.0);\n}\n#elif TUTORIAL == 3\nvec2 plotY(in vec2 st, in vec2 pct, in float blur) {\n    return smoothstep(pct-blur, pct, vec2(st.y))\n           -smoothstep(pct, pct+blur, vec2(st.y));\n}\n\nvec2 plotX(in vec2 st, in vec2 pct, in float blur) {\n    return smoothstep(pct-blur, pct, vec2(st.x))\n           -smoothstep(pct, pct+blur, vec2(st.x));\n}\n\nvec3 cube(in vec2 uv, vec2 lb, float width, float height, float blur ) {\n    vec3 color;\n    vec2 ub = plotY(uv, vec2(lb.y, height),blur);\n    color += vec3(ub.x);\n    color += vec3(ub.y);\n    \n    float a = step(lb.x, uv.x)-step(width, uv.x);\n    color *= vec3(a);\n    \n    vec2 lr = plotX(uv, vec2(lb.x, width),blur);\n    color +=vec3(lr.x);\n    color +=vec3(lr.y);\n    \n    a = step(lb.y, uv.y)-step(height, uv.y);\n    color *= vec3(a);\n    \n    return color;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0.149,0.141,0.912);\n    /*\n    // 绘制坐标轴\n    vec2 ub, lr;\n    float yd= 0.1;\n    for(int i=0;i<5;i++) {\n        ub = plotY(uv, vec2(yd,1.-yd),.01);\n        color += vec3(ub.x);\n    \tcolor += vec3(ub.y);\n        lr = plotX(uv, vec2(yd,1.-yd),.005);\n    \tcolor +=vec3(lr.x);\n    \tcolor +=vec3(lr.y);\n        yd+=.1;\n    }*/\n    \n    // 画长方形  \n    vec3 pct = cube(uv, vec2(.1,.3), .6, .5, .01);\n    \n    // 改变长方形颜色\n    color = mix(color, vec3(1.,0.,0.), pct.x);\n                \n    fragColor = vec4(color,1.0);\n}\n#elif TUTORIAL == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    float pct = 0.;\n    //pct = smoothstep(.3,.4, st.y);\n    //pct = distance(st,vec2(0.4)) + distance(st,vec2(0.6));\n    //pct = distance(st,vec2(0.4)) * distance(st,vec2(0.6));\n    //pct = min(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    //pct = max(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    pct = pow(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n\tvec3 color =mix(vec3(1.000,0.833,0.224),vec3(0.149,0.141,0.912), vec3(pct));\n    \n\tfragColor = vec4( color, 1.0 );\n}\n#elif TUTORIAL == 5\n// 绘制圆形\nfloat circle(in vec2 _st, in float _radius, in float blur){\n    vec2 dist = _st;\n\treturn 1.-smoothstep(_radius-(_radius*blur),\n                         _radius+(_radius*blur),\n                         dot(dist,dist)*4.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st -= .5;\n\tst.x *= iResolution.x/iResolution.y;\n    \n    // 背景色\n    vec3 color = vec3(0.);\n    // 画圆\n\tvec3 pct = vec3(circle(st,0.9, 0.05));\n    // 改变圆的颜色\n\tcolor = mix(color, vec3(1.000,0.833,0.224), pct.x);\n    \n\tfragColor = vec4( color, 1.0 );\n}\n#elif TUTORIAL == 6\n#define PI 3.1415926\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = (2.*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y); \n    \n  \tvec3 color = vec3(0.0);\n  \tfloat d = 0.0;\n\t\n  \t// Make the distance field\n    //d = length(st);\n  \t//d = length( abs(st)-.3);\n  \td = length( min(abs(st)-.3,0.2) );\n  \t//d = length( max(abs(st)-.3,0.05) );\n\n  \t// Visualize the distance field\n    //fragColor = vec4(vec3(d),1.0);\n  \tfragColor = vec4(vec3(fract(d*5.)),1.0);\n\n  \t// Drawing with the distance field\n  \t//fragColor = vec4(vec3( step(.3,d) ),1.0);\n  \t//fragColor = vec4(vec3( step(.3,d) * step(d,.4)),1.0);\n    //fragColor = vec4(vec3( smoothstep(.3,.4,d)* smoothstep(.6,.5,d)) ,1.0);\n}\n#elif TUTORIAL == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-st;\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n\n    float f = cos(a*3.);\n    //float f = abs(cos(a*3.));\n    //float f = abs(cos(a*2.5))*.5+.3;\n    //float f = abs(cos(a*12.)*sin(a*3.))*.8+.1;\n    //float f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;\n\n    color = vec3( 1.-smoothstep(f,f+0.02,r) );\n\n    fragColor = vec4(color, 1.0);\n}\n#elif TUTORIAL == 8\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n// 绘制多边形\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (2.*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y); \n    vec3 color = vec3(0.0);\n    float d = 0.0;\n\n    // Number of sides of your shape\n    float N = 8.;\n\n    // Angle and radius from the current pixel\n    float a = atan(st.x,st.y)+PI;\n    float r = TWO_PI/N;\n\n    // Shaping function that modulate the distance\n    d = cos(floor(.5+a/r)*r-a)*length(st);\n\n    color = vec3(1.0-smoothstep(.4,.41,d));\n\n    fragColor = vec4(color,1.0);\n}\n#endif\n","name":"Image","description":"","type":"image"}]}