{"ver":"0.1","info":{"id":"ttfSWH","date":"1562707328","viewed":398,"name":"Plant based ","username":"TLC123","description":"simple plant sdf some variation possible","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["sdf","plant","foliage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat TTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\nfloat sdPlane(vec3 p, vec4 n) {\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opOnion( in float sdf, in float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\n\nfloat plant( in vec3 pos, vec4 type) {\n    float l =  length(pos.xz)*max(1.,abs( 4.* pos.y-1.)) ;\n    pos=pos\n        +vec3(l,0,l)*(0.2+sin(pos.x+pos.y+iTime*0.6)*0.2)\n        +vec3(0,l,0)*(0.1+sin(pos.y+iTime*1.6)*0.1)\n                     ;\n    float d, di, plane, lay;\n    d = l;\n    if ((l - type.w) < 0.) {\n\n        for (float i = 0.3; i < 0.28+type.w*0.5; i += +(.101*1./3.)) {\n\n            di = sdTorus(pos + vec3(0, -i * type.z*0.6, 0), vec2(0.18 * type.w + i * type.y, i * 1.5*type.z * type.w));\n\n            di = opOnion(di, type.x * 0.125 * type.w);\n            lay = i * (23.416 * 1.7);\n            plane = sdPlane(vec3(pos.x, pos.y, pos.z), vec4(sin(lay), 0, cos(lay), (-0.5+fract(lay*10.))*0.5*type.x));\n            di = opIntersection(di,\n\n                abs(plane)   -  ( sin(clamp( (min(l,type.w)/type.w )*7.28,.3,6.28) ))*type.x);\n\n            d = min(d, di);\n            if(d<0.01)break;\n\n        }\n        d = opIntersection(d, sdSphere(pos + vec3(0, -type.w * 0.9, 0), type.w));\n\n    }\n\n    return d;\n}\n//-------------------------------------------\nvec2 map( in vec3 pos) {\n    float Strand, Spread, Lift, Size;\n    float sqr = 1.;\n    float d = length(pos.xz)+1.;\n    vec3 pfract = fract(pos / sqr) * sqr;\n    vec3 pround = round(pos / sqr) * sqr + vec3(sqr * 0.5, 0, sqr * 0.5);\n    vec3 mos = vec3(pfract.x, pos.y, pfract.z);\n\n    float i = (pos - pfract).x;\n    float j = (pos - pfract).z;\n\n    Strand = 0.01 + fract( sin(i * 12. + j*9.9) * 9.219869) * 0.0325;\n    Spread = 0. + fract( sin (i * 12. + j*9.9) * 99.24927) * .3;\n    Lift = .2 + fract(  sin(i * 42. + j*32.9) * 199.210930) * .5;\n    Size = .2 + fract( sin (i * 2. + j) * 99.) * .7;\n\n    d = min(d, plant(mos - vec3(sqr * 0.5, 0., sqr * 0.5), vec4(Strand, Spread * 1.1, Lift, Size)));\n\n    float plane = sdPlane(vec3(pos.x, pos.y, pos.z), vec4(0, 1, 0, 0));\n    d = min(d, plane);\n    d = max(d, -(length(pfract.xz - vec3(sqr * 0.5, 0., sqr * 0.5).xz) -0.01));\n\n    return vec2(d, 3);\n\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd) {\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    /*#if 0\n    float tp1 = (0.0 - ro.y) / rd.y;\n    if (tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y;\n    if (tp2 > 0.0) {\n        if (ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2);\n    }#endif*/\n\n    float precis = 0.0002;\n    float t = tmin;\n    float m = -1.0;\n    for (int i = -0; i < 250; i++) {\n        vec2 res = map(ro + rd * t);\n        if (res.x < precis || t > tmax) break;\n        t += res.x * 0.2;\n        m = res.y;\n    }\n\n    if (t > tmax) m = -1.0;\n    return vec2(t, m);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if (h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n\n}\n\nvec3 calcNormal( in vec3 pos) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n        map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n        map(pos + eps.yyx).x - map(pos - eps.yyx).x);\n    return normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = map(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.3, 0.6, 0.0) + rd.y * 0.8;\n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float m = res.y;\n    if (m > -0.5) {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        // material        \n        col = 0.45 + 0.3 * sin(vec3(0.15, 0.8, 0.00) * (m - 1.0));\n\n        if (m < 1.5) {\n\n            float f = mod(floor(5.0 * pos.z) + floor(5.0 * pos.x), 2.0);\n            col = 0.4 + 0.1 * f * vec3(0., 1., 0.);\n        }\n\n        // lighitng   .//     \n        float occ =  calcAO(pos, nor);\n        vec3 lig = normalize(vec3(-0.6, .7, -0.5));\n        float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n        float dom = smoothstep(-0.1, 0.1, ref.y);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0);\n\n         dif *= softshadow(pos, lig, 0.02, 1.5);\n        // dom *= softshadow(pos, ref, 0.02, 2.5);\n\n        vec3 lin = vec3(0.0);\n        lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n        lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n        lin += 0.30 * amb * vec3(0.250, 0.70, 0.255) * occ;\n        lin += 0.30 * dom * vec3(0.50, 0.70, 0.55) * occ;\n        lin += 0.30 * bac * vec3(0.25, 0.5, 0.25) * occ;\n        lin += 0.40 * fre * vec3(1.00, 1.00, 0.55) * occ;\n        col = col * lin;\n\n        //col = mix( col, vec3(0.8,0.9,0.05), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n    vec3 fly = vec3(sin(time * 0.0001936), 0, cos(time * 0.0001345)) * 3000.;\n    fly += vec3(sin(time * 0.001563), 0, cos(time * 0.001175)) * 300.;\n    // camera\t\n    vec3 ro = fly + 1.4 * vec3(  1.6  * cos(0.16 * time + 6.0 * mo.x), 1.5 + 1.0 * mo.y,   1.6  * sin(0.16 * time + 6.0 * mo.x));\n    vec3 ta = fly + vec3(-0.0, -0.0, 0.);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\t\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}