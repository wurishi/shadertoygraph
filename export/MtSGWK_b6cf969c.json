{"ver":"0.1","info":{"id":"MtSGWK","date":"1432430933","viewed":569,"name":"Triangle fractal bump +mouse","username":"104","description":"a bump-map based on a triangle fractal. Use mouse to move light around. Basically I subdivide triangles in two using the longest edge. Makes rock-looking textures. See also https://www.shadertoy.com/view/MlB3WV for a similar experiment with Worley noise","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mouse","texture","bump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// -------------------------------------------------------\n// parameters...\n\n// 0 = random triangle color\n// 1 = stylized, based on distance to triangle\n// 2 = reveal raw distance to triangle\n// 3 = no color, only bump map\n#define COLOR_MODE 1\n\nconst int iterationCount = 14;\n\nconst float iterationColorInfluenceFactor = 0.75;// how much do we attenuate color every iteration\n\n// exponent. higher=tries to keep triangles equal sized. more regular-looking.\n// 0 = turbulent and chaotic\n// 5 starts to look quite \"regular\"\nconst float regularity = 2.2;\n\n#define initialVertexHeight (iResolution.x * 0.05);// basically, how much height variation. how bumpy.\nconst float iterationNormalInfluenceFactor = 0.7;\nconst float heightRandomness = 1.;// 0 = don't randomize heights; make them look uniform by just adding the same every iteration. 1=completely random.\n\n\n// -------------------------------------------------------\n// utilities\nfloat saturate(float n) { return clamp(n,0.,1.); }\n\n// c64 palette because why not.\nvec3 color0 = vec3(0,0,0);// black\nvec3 color1 = vec3(1,1,1);// white\nvec3 color2 = vec3(0.41,0.22,0.17);// red\nvec3 color3 = vec3(0.44,0.64,0.70);// cyan\nvec3 color4 = vec3(0.44,0.24,0.53);// violet\nvec3 color5 = vec3(0.35,0.55,0.26);// green\nvec3 color6 = vec3(0.21,0.16,0.47);// blue\nvec3 color7 = vec3(0.72,0.78,0.44);// yellow\nvec3 color8 = vec3(0.44,0.31,0.15);// orange\nvec3 color9 = vec3(0.26,0.22,0);// brown\nvec3 colorA = vec3(0.60,0.40,0.35);// light red\nvec3 colorB = vec3(0.27,0.27,0.27);// grey1\nvec3 colorC = vec3(0.42,0.42,0.42);// grey2\nvec3 colorD = vec3(0.60,0.82,0.52);// light green\nvec3 colorE = vec3(0.42,0.37,0.71);// light blue\nvec3 colorF = vec3(0.58,0.58,0.58);// grey3\nvec3 getPalette(int i)\n{\n    if(i == 0) return color6;\n    if(i == 1) return color3;\n    if(i == 2) return color5;\n    if(i == 3) return color9;\n    if(i == 4) return color7;\n    return color8;\n}\n\n\n\n\nfloat rand(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 rand(vec2 n)\n{\n \treturn vec2(rand(n.x*23.62-300.0+n.y*34.35),rand(n.x*45.13+256.0+n.y*38.89)); \n}\nvec3 rand(vec3 n)\n{\n \treturn vec3(rand(n.xy), rand(n.z));\n}\nfloat rand1(vec2 n) {\n\t\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nfloat rand1(vec3 n) {\n\treturn rand1(vec2(rand1(n.xy), n.z));\n}\nfloat nsin(float a)\n{\n    return (sin(a)+1.)/2.;\n}\nvec4 applyLighting(vec4 inpColor, vec2 uv, vec3 normal, vec3 LightPos, vec4 LightColor, vec4 AmbientColor)\n{\n    if(distance(uv.xy, LightPos.xy) < 0.01) return vec4(1.,0.,0.,1.);\n    vec3 LightDir = vec3(LightPos.xy - uv, LightPos.z);\n    float D = length(LightDir);// distance for attenuation\n    vec3 N = normalize(normal);\n    vec3 L = normalize(LightDir);\n    vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);\n    vec3 Ambient = AmbientColor.rgb * AmbientColor.a;\n    vec3 Intensity = Ambient + Diffuse;\n    vec3 FinalColor = inpColor.rgb * Intensity;\n    return vec4(FinalColor, inpColor.a);\n}\nvec3 calcNormalForTriangle(vec3 a, vec3 b, vec3 c)\n{\n    vec3 dir = cross(b - a, c - a);\n\tvec3 normal = normalize(dir);\n    return normal;\n}\nfloat sgn(vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nbool IsPointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n{\n    bool b1, b2, b3;\n    b1 = sgn(pt, v1, v2) < 0.0;\n    b2 = sgn(pt, v2, v3) < 0.0;\n    b3 = sgn(pt, v3, v1) < 0.0;\n    return ((b1 == b2) && (b2 == b3));\n}\n\n// THANK YOU IQ / https://www.shadertoy.com/view/XsXSz4\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// -------------------------------------------------------\n// the algorithm\n\n// calculates the normal & coloring within the given triangle. iteration is done inside here.\n// only call this if you know that uv is within the specified triangle.\nvec4 doStuffForThisTriangle(vec3 a, vec3 b, vec3 c, vec2 uv, out vec3 normal)\n{\n    // points come in with no height info, so generate them.\n    a.z = rand1(a.xy) * initialVertexHeight;\n    b.z = rand1(b.xy) * initialVertexHeight;\n    c.z = rand1(c.xy) * initialVertexHeight;\n    vec4 fragColor = vec4(vec3(0.5),1.0);\n    \n    float colorMix = 1.0;\n    float heightAffect = initialVertexHeight;\n    for(int i = 0; i < iterationCount; ++ i)\n    {\n        // the idea: split this triangle in 2, by finding the longest segment\n        // and splitting it. To do this, first find the longest segment,\n        // then rotate the triangle vertices so AB is the longest segment.\n        float ab = distance(a.xy,b.xy);\n        float bc = distance(b.xy,c.xy);\n        float ca = distance(c.xy,a.xy);\n\t    vec3 temp = c;\n        if(ca > ab && ca > bc)\n        {\n            // ca is longest; rotate to CAB\n            c = b;\n            b = a;\n            a = temp;\n        }\n        else if(bc > ab)\n        {\n            // bc is longest; rotate to BCA\n            c = a;\n            a = b;\n            b = temp;\n        }\n\n        // find a random point between A and B to split at, creating 2 new sub-triangles\n        float pos = rand1(a.xy + b.xy) - 0.5;// from -0.5 to 0.5\n        // this pushes the point towards 0 (the center of the segment).\n        float sgn = sign(pos);// workaround for negative values in pow() - thanks for FabriceNeyret2 for pointing out this bug.\n        // thus, the higher the exponent, the more things look like a regular triangle grid.\n        pos = pow(abs(pos), regularity) * 2.0 * sgn;\n        pos = (pos + 1.) / 2.0;// pos is now 0-1, favoring 0.5\n        vec3 d = mix(a, b, pos);\n        \n        // perturb the new point's height. one way to make this look really accurate\n        // would be to consider the xy position and the angle it will form with other vertices.\n        float randomHeight = (rand1(a.xy + b.xy + pos) * 2.0) - 1.0;// -1 to 1.\n        randomHeight *= heightAffect;\n        d.z += mix(heightAffect, randomHeight, heightRandomness);// find random height for the new point\n        \n        float distToEdge = sdTriangle(a.xy, d.xy, c.xy, uv);// distance from uv to the triangle\n        if(distToEdge < 0.)// triangle 1: ADC\n            b = d;\n        else\n        {\n            // triangle 2: DBC\n            a = d;\n\t\t\tdistToEdge = sdTriangle(a.xy, b.xy, c.xy, uv);\n        }\n\n        // colorize this pixel...\n#if COLOR_MODE == 0\n        float tintAmt = rand1(a.xy+b.xy+c.xy);// pow(dist, 0.2);\n        fragColor = vec4(mix(fragColor.rgb, getPalette(i), tintAmt * colorMix), 1.0);\n#endif\n#if COLOR_MODE == 1 || COLOR_MODE == 2\n        // we know the distance to the edge.\n        // using the center of the triangle we can get a gradient from 0-1 from edge to center\n        vec2 center = (a.xy + b.xy + c.xy) / 3.0;\n        float distToCenter = distance(uv, center);\n        distToEdge = -distToEdge;\n        float tintAmt = distToEdge / (distToCenter + distToEdge);\n        tintAmt = pow(tintAmt, 1.2);\n        tintAmt = 1.0 - tintAmt;\n#if COLOR_MODE == 1\n        fragColor = vec4(mix(fragColor.rgb, getPalette(i), tintAmt * colorMix), 1.0);\n#endif\n#if COLOR_MODE == 2\n        fragColor = vec4(vec3(tintAmt),1.);\n#endif\n#endif\n        // honestly i would expect 0.5 to work here but it really is way too subtle. i don't really understand why.\n\t\theightAffect *= iterationNormalInfluenceFactor;\n        colorMix *= iterationColorInfluenceFactor;\n    }\n\n    // i thought i kept everything clockwise, not sure why i need to flip this.\n    normal = -calcNormalForTriangle(a,b,c);\n    return fragColor;\n}\n\n\n\n\n// -------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scrollOffset = vec2(iTime * iResolution.x / 17., 0.0);\n    vec2 uv = fragCoord.xy + scrollOffset;\n    \n    vec2 lightPosXY = vec2(nsin(iTime * 1.66), nsin(iTime * 1.99));\n    lightPosXY = (lightPosXY * 0.75) + 0.125;// not so big movement\n    lightPosXY *= iResolution.xy;\n    lightPosXY += scrollOffset;\n    if(iMouse.z > 0.)\n\t    lightPosXY = iMouse.xy + scrollOffset;\n    \n    fragColor = vec4(vec3(0.5), 1.0);// background\n\n    vec3 normal = vec3(0.);\n    vec3 a, b, c;// triangle points\n\n    // top-level rectangle size. we will manually divide the rect into 2 triangles.\n    vec2 tileSize = iResolution.xy / 1.0;\n    vec2 tilePosition = floor(uv / tileSize) * tileSize;// snap to grid of size\n\n    // the goal of everything here is to compute the normal of this fragment.\n    // make sure these are clockwise for normal calculation\n    a = vec3(0., tileSize.y, 0.0);\n    b = vec3(tileSize.x, tileSize.y, 0.0);\n    c = vec3(0., 0., 0.0);\n    a.xy += tilePosition;\n    b.xy += tilePosition;\n    c.xy += tilePosition;\n    if(IsPointInTriangle(uv, a.xy, b.xy, c.xy))\n    {\n    \tfragColor = doStuffForThisTriangle(a, b, c, uv, normal);\n    }\n    else\n    {\n        a = vec3(0.,0., 0.0);\n        b = vec3(tileSize.x, tileSize.y, 0.0);\n        c = vec3(tileSize.x, 0., 0.0);\n        a.xy += tilePosition;\n        b.xy += tilePosition;\n        c.xy += tilePosition;\n       \tfragColor = doStuffForThisTriangle(a, b, c, uv, normal);\n    }\n    \n    // lighting\n#if COLOR_MODE != 2\n    vec3 lightPos = vec3(lightPosXY, iResolution.x / 2.);\n    vec4 lightColor = vec4(0.95,0.9,0.9,1.);\n    vec4 ambientColor = vec4(0.5,0.5,0.9,1.);\n\tfragColor = applyLighting(fragColor, uv, normal, lightPos, lightColor, ambientColor);\n    \n    // show light position.\n    if(distance(uv, lightPosXY) < iResolution.x / 75.)\n        fragColor = vec4(1.0,1.0,0.,1.0);\n#endif\n}\n\n","name":"Image","description":"","type":"image"}]}