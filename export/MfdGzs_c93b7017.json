{"ver":"0.1","info":{"id":"MfdGzs","date":"1712048564","viewed":41,"name":"augub_sdf7","username":"augub","description":"smoothmin\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rotation2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat dist_to_circle(vec2 p, float r){\n    return length(p) - r;\n}\n\nfloat dist_to_circle_at(vec2 p, vec2 c, float r){\n    return length(p-c) - r;\n}\n\nfloat dist_to_square(vec2 p, float b){\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat dist_to_rotated_square(vec2 p, float theta, float b){\n    mat2 rotation = rotation2D(theta);\n    p = inverse(rotation)*p;\n    return dist_to_square(p, b);\n}\n\nfloat smoothmax(float a, float b, float l){\n    return log2(exp2(a*l)+exp2(b*l))/l;\n}\n\nfloat smoothmin(float a, float b, float l){\n    return -smoothmax(-a, -b, l);\n}\n\nfloat dist_to_circle_and_square(vec2 p){\n    float d_square = dist_to_square(p, 0.5);\n    vec2 translate = vec2(1.2*sin(iTime/2.), 0.0);\n    float d_circle = dist_to_circle_at(p,translate, 0.5);\n    return smoothmin(d_square, d_circle, 20.);\n}\n\nfloat dist(vec2 p){\n    //float dist_to_box = sdBox(p+vec2(1.0,0.0), vec2(0.5, 0.5));\n    //float d_circle = dist_to_circle(p - vec2(sin(iTime),0.0), 0.4);\n    //return min(dist_to_box, d_circle);\n    //float d_circle_at = dist_to_circle_at(p, vec2(1.0,0.0), 0.5);\n    //float d_rotated_square = dist_to_rotated_square(p, 1.0, 0.5);\n    float d_both = dist_to_circle_and_square(p);\n    return d_both;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2. -1.;\n    \n    float maxDim = iResolution.x/iResolution.y;\n    if (maxDim < 1.){\n        maxDim /= 1./maxDim;\n    }\n    // Make the grid isotropic\n    uv.x *= iResolution.x/iResolution.y;\n\n   \n    // get the distance\n    float d = dist(uv);\n    \n    // Draw a black line at the edges\n    if (abs(d) < 0.01 || (mod(d, 0.1) < 0.005)){\n        fragColor = vec4(0.0);\n    }\n    else\n    {\n        if (d < 0.){\n            d = -mod(-d, 0.1)*10.;\n\n            fragColor = vec4(1.+0.5*d/maxDim,0.0,0.0,0.0);\n        }else{\n            d = mod(d, 0.1)*10.;\n\n            fragColor = vec4(0.0,1.-0.5*d/maxDim,0.0,0.0);\n\n        }\n    }\n    // Output to screen\n    \n}","name":"Image","description":"","type":"image"}]}