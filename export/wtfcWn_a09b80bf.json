{"ver":"0.1","info":{"id":"wtfcWn","date":"1591797509","viewed":113,"name":"fork-XY Oscilloscope-Triangulo","username":"jorge2017a1","description":"fork-XY Oscilloscope-Triangulo","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["vectorgrafics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///XY Oscilloscope Cube (Loud)\n//Creado por Flyguy en 2016-10-23\n//https://www.shadertoy.com/view/lly3DG\n\n//Modificado por: jorge2017a1  \n//fecha 07/jun/2020\n\n\n\n//Preview of the shape being drawn. (may fall out of sync with the sound when paused)\n\nfloat tau = atan(1.0)*8.0;\n\nfloat gShapeTime = 0.0;\nmat4 gModel = mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);\n\nvec2 cossin(float x)\n{\n\treturn vec2(cos(x), sin(x));   \n}\n\n//Single point projection\nvec2 Project(vec3 p0)\n{\n    \n    vec3 vanish = vec3(0.0,-2.0,0.5);\n    \n    p0 -= vanish;\n    \n\treturn length(vanish) * p0.xz / p0.y;\n\t\n    \n   \n}\n\n//Transformation functions\nmat4 Translate(vec3 v)\n{\n    return mat4(vec4(1,0,0,v.x), vec4(0,1,0,v.y), vec4(0,0,1,v.z), vec4(0,0,0,1));\n}\n\n//Angle-axis rotation\nmat4 Rotate(vec3 u,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    u = normalize(u);\n    \n    vec3 c0 = vec3(c + (u.x*u.x) * (1.0-c), (u.y*u.x) * (1.0-c) + (u.z*s), (u.z*u.x) * (1.0-c) - (u.y*s));    \n    vec3 c1 = vec3((u.x*u.y) * (1.0-c) - (u.z*s), c + (u.y*u.y) * (1.0-c), (u.z*u.y) * (1.0-c) + (u.x*s)); \n    vec3 c2 = vec3((u.x*u.z) * (1.0-c) + (u.y*s), (u.y*u.z) * (1.0-c) - (u.x*s), c + (u.z*u.z) * (1.0-c));\n    \n    return mat4(mat3(c0,c1,c2));\n}\n\nmat4 Scale(vec3 v)\n{\n    return mat4(vec4(v.x,0,0,0), vec4(0,v.y,0,0), vec4(0,0,v.z,0), vec4(0,0,0,1));\n}\n\n//Projected line\nfloat Line3d(vec3 p0,vec3 p1,vec2 uv)\n{\n    p0 = (vec4(p0,1.0) * gModel).xyz;\n    p1 = (vec4(p1,1.0) * gModel).xyz;\n    \n\tp0.xy = Project(p0);\n\tp1.xy = Project(p1);\n    \n\tvec2 dir = normalize(p1.xy - p0.xy);\t\n\tuv = (uv - p0.xy) * mat2(dir.x, dir.y, -dir.y, dir.x);\t\n    \n    float d = distance(uv, clamp(uv, vec2(0.0), vec2(distance(p0.xy, p1.xy), 0.0)));\n    \n\treturn smoothstep(4.0/iResolution.y, 0.0, d);\n}\n\n\n//----------------------\nvec3 hacerNuevoTriangulos(vec2 uv, vec3 pos, float ancho , float alto, float largo)\n{   \n float x, y ,z;\n float w; //ancho\n float h;  //alto\n float d;  //profundo\n vec3 cout;\n    \n \tw=ancho;\n    h=alto; \n    d=largo;  \n  \n  x=pos.x;\n  y=pos.y;\n  z=pos.z;\n    \n   vec3 pt[5];\n    \n   int i=0;\n    \n      //'cuadro inferior base\n    pt[i].x = x;            pt[i].y = y;     pt[i].z = z;            i = i + 1; //0\n    pt[i].x = x + w;        pt[i].y = y;     pt[i].z = z;            i = i + 1; //1\n    pt[i].x = x + w;        pt[i].y = y;     pt[i].z = z + d;        i = i + 1; //2\n    pt[i].x = x;            pt[i].y = y;     pt[i].z = z + d;        i = i + 1; //3\n    //'punta superior pico\n    pt[i].x = x + w / 2.0;  pt[i].y = y + h; pt[i].z = z + d / 2.0;  i = i + 1; //4\n    \n    \n        \n    //base inferior\n    cout += Line3d(pt[0],pt[1], uv);\n    cout += Line3d(pt[1],pt[2], uv);\n    cout += Line3d(pt[2],pt[3], uv);\n    cout += Line3d(pt[3],pt[0], uv);\n    \n    //triangulo 1\n    cout += Line3d(pt[0],pt[4], uv);\n    //cout += Line3d(pt[1],pt[4], uv);\n    //cout += Line3d(pt[0],pt[1], uv);\n    \n    \n    //triangulo 2\n    cout += Line3d(pt[1],pt[4], uv);\n    //cout += Line3d(pt[2],pt[4], uv);\n    //cout += Line3d(pt[1],pt[2], uv);\n    \n    \n    \n    //triangulo 3\n    cout += Line3d(pt[2],pt[4], uv);\n    //cout += Line3d(pt[3],pt[4], uv);\n    //cout += Line3d(pt[2],pt[3], uv);\n    \n    //triangulo 4\n    cout += Line3d(pt[3],pt[4], uv);\n    //cout += Line3d(pt[0],pt[4], uv);\n    //cout += Line3d(pt[0],pt[3], uv);\n    \n    \n    \n    \n    return cout;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.y) - (res / 2.0);\n    uv *= 2.0;\n    \n    float time = iTime*0.5+4.0;\n    \n    \n    gModel *= Scale(vec3(0.051525));\n    \n    gModel *= Rotate(vec3(0, 0, 1), time);\n    gModel *= Rotate(vec3(0, 1, 0), time);\n    gModel *= Rotate(vec3(1, 0, 0), time);\n    //gModel *= Translate(vec3(0.4 * cossin(1.0 * time), 0.4 * sin(0.6 * time)));\n    \n    vec3 cout=vec3(0.0);\n    vec3 pos;\n    \n    pos=vec3(0.0);\n    cout=cout+ hacerNuevoTriangulos(uv, pos, 2.5 , 3.0, 2.0);\n    \n    \n    pos=vec3(-5.0,0.0,0.0);\n    cout=cout+ hacerNuevoTriangulos(uv, pos, 4.0 , 8.0, 6.0);\n    \n    pos=vec3(-10.0,0.0,0.0);\n    cout=cout+ hacerNuevoTriangulos(uv, pos, 4.0 , 15.0, 6.0);\n    \n    \n    pos=vec3(-5.0,0.0,8.0);\n    cout=cout+ hacerNuevoTriangulos(uv, pos, 4.0 , 8.0, 6.0);\n   \n    \n    pos=vec3(10.0,0.0,-5.0);\n    cout=cout+ hacerNuevoTriangulos(uv, pos, 20.0 , 20.0, 10.0);\n    \n    \n    //falla con otro mas\n    //pos=vec3(4.0,0.0,0.0);\n    //cout=cout+ hacerNuevoTriangulos(uv, pos, 4.0 , 8.0, 2.0);\n    \n\n    cout *= vec3(0.1,0.8,0.1);\n    \n    fragColor = vec4(cout, 1.0);\n}","name":"Image","description":"","type":"image"}]}