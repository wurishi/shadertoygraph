{"ver":"0.1","info":{"id":"3llXRs","date":"1563943965","viewed":133,"name":"Ray Tracing in a Weekend, Ch 6.1","username":"fhecht","description":"This is a tutorial style implementation of classic ray tracing following the \"Ray Tracing in One Weekend\" course by Peter Shirley. This is the code up to chapter 6. Anti-aliasing not via an infinitely running average, but a fixed sample approach.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -------------------------------------------------------------------------\n// Struct definitions and scene setup\n// -------------------------------------------------------------------------\n\n// Camera parameters\nvec3 lower_left_corner = vec3(-1.0, -1.0, -1.0);\nvec3 horizontal = vec3(2, 0, 0);\nvec3 vertical = vec3(0, 2, 0);\nvec3 origin = vec3(0, 0, 0);\n\n// Ray struct\nstruct Ray {\n    vec3 o;\n    vec3 d;\n    float mint;\n    float maxt;\n};\n\n// Scene\nstruct Sphere {\n    vec3 c;\n    float r;\n};\nSphere sphere = Sphere(vec3(0.0, 0.0, -1.0), 0.5);\n\nconst int NUM_SPHERES = 2;\nconst Sphere spheres[NUM_SPHERES] = Sphere[NUM_SPHERES](\n    Sphere(vec3(0.0, 0.0, -1.0), 0.5),\n    Sphere(vec3(0.0, -100.5, -1.0), 100.)\n);\n\n// Hit record information\nstruct HitRecord {\n    float t;\n    vec3 P;\n    vec3 N;\n};\n\n// -------------------------------------------------------------------------\n// Intersection code\n// -------------------------------------------------------------------------\n\n// intersect a ray with a single sphere\n// returns true if there was a valid intersection, which includes checks\n// against the mint and maxt range of the ray. In case of a valid\n// intersection the information in the HitRecord is filled in\nbool hitSphere(Ray r, Sphere s, out HitRecord hit)\n{\n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(oc, r.d);\n    float c = dot(oc, oc) - s.r * s.r;\n    float det = b*b - 4.0*a*c;\n    if (det < 0.0) {\n        return false;\n    }\n   \n    // first possible intersection\n    float t = (-b - sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) {\n        hit.t = t;\n        hit.P = r.o + t * r.d;\n        hit.N = normalize(hit.P - s.c);\n        return true;\n    }\n\n    // second possible intersection\n    t = (-b + sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) {\n        hit.t = t;\n        hit.P = r.o + t * r.d;\n        hit.N = normalize(hit.P - s.c);\n        return true;\n    }\n\n    return false;\n}\n\n// intersect against all spheres and return the first hit\nbool hitSpheres(Ray r, Sphere spheres[NUM_SPHERES], out HitRecord hit)\n{\n    bool hitSomething = false;\n    for (int i = 0; i < spheres.length(); ++i) {\n        if (hitSphere(r, spheres[i], hit)) {\n            hitSomething = true;\n            // if we hit a sphere we update maxt on the ray to only find\n            // intersections that are even closer\n            r.maxt = hit.t;\n        }\n    }\n   \n    return hitSomething;\n}\n\n// -------------------------------------------------------------------------\n// Core integrator\n// -------------------------------------------------------------------------\n\nvec3 missedColor(vec3 rayDir)\n{\n    vec3 unitDir = normalize(rayDir);\n    float t = 0.5 * (unitDir.y + 1.0);\n    return mix(vec3(1.0,1.0,1.0), vec3(.5, .7, 1.0), t);\n}\n\nvec3 traceRay(Ray r)\n{\n    HitRecord hit;\n    //if (hitSphere(r, sphere, hit)) {\n    if (hitSpheres(r, spheres, hit)) {\n        return 0.5 * (hit.N + 1.0);\n    }\n    return missedColor(r.d);\n}\n\n// -------------------------------------------------------------------------\n// Camera code\n// -------------------------------------------------------------------------\n\nRay computeCameraRay(vec2 uv)\n{\n    // Coarsen up the resolution\n    float factor = 1.0;\n    float c = iResolution.x / factor;\n    uv = round(c*uv) / c;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 llc = lower_left_corner;\n    // Move the camera left and right a bit\n    llc.x += 0.5*sin(0.1*iTime);\n\n    Ray r;\n    r.o = origin;\n    r.d = llc * vec3(aspectRatio, 1.0, 1.0) +\n          uv.x * horizontal * aspectRatio +\n          uv.y * vertical;\n    r.mint = 0.0;\n    r.maxt = 1e20;\n    return r;\n}\n\n// -------------------------------------------------------------------------\n// Main image computation\n// -------------------------------------------------------------------------\n\nfloat nrand(vec2 n)\n{\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 traceSample(vec2 uv)\n{\n    // Compute ray for pixel\n    Ray r = computeCameraRay(uv);\n\n    // Compute pixel color\n    return traceRay(r);\n}\n\n// Anti-aliasing sample distribution strategy\n#define CENTER \t\t0\n#define RANDOM \t\t1\n#define GRID   \t\t2\n#define STRATIFIED\t3\n\nvec2 computeSamplePosition(vec2 fragCoord, int i, int j, int N, int mode)\n{\n    vec2 origUV = fragCoord / iResolution.xy;\n\n    // sample index is different for each sample and also for each iteration\n    int sampleIdx = N*N*iFrame + N*i + j;\n    vec2 rand = vec2(nrand(origUV * 0.123 * float(sampleIdx)),\n                     nrand(origUV * 2.345 * float(sampleIdx)));\n\n    // Compute the offset within the pixel\n    vec2 offset;\n    if (mode == CENTER) {\n        // Always the center point\n        offset = vec2(0.5);\n    } else if (mode == RANDOM) {\n        // Random point within the pixel\n        offset = rand;\n    } else if (mode == GRID) {\n        // Center of grid cells\n        offset = (vec2(i, j) + 0.5) / float(N);\n    } else if (mode == STRATIFIED) {\n        // Random point within each cell\n        offset = (vec2(i, j) + rand) / float(N);\n    }\n\n    // Normalized pixel coordinates (from 0 to 1)\n    return (fragCoord + offset) / iResolution.xy;\n}\n\nvec3 integratePixel(int N, int samplingMode, vec2 fragCoord)\n{\n    vec3 avg = vec3(0.0);\n   \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            // Compute a sample position in normalized screen space\n            vec2 uv = computeSamplePosition(fragCoord, i, j, N, samplingMode);\n           \n            // Compute the color for this sample and add it to the average\n            avg += traceSample(uv);\n        }\n    }\n    avg /= float(N * N);\n    \n    return avg;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Compute the color of a pixel as an integral computed via sampling\n    const int numSamplesSqrt = 4;\n    const int samplingMode = GRID;\n    vec3 col = integratePixel(numSamplesSqrt, samplingMode, fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}