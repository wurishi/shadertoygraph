{"ver":"0.1","info":{"id":"dsXfWH","date":"1690214949","viewed":49,"name":"0. Raymarcher (base)","username":"Envy24","description":"Base for raymarcher build-up.\nHold LMB to see normals.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distance","field","base"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MISS_DIST    ( 1e4 )\n#define MIN_HIT_DIST     ( 1e-4 )\n#define MAX_NUM_OF_STEPS ( 300. )\n\n// Data structures.\nstruct RAY\n{\n    vec3 origin;\n    vec3 direction;\n};\nstruct HIT\n{\n    float hit_dist;\n    bool hit_something;\n};\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// SDFs\nfloat sphereSDF_L2(in vec3 P, in vec3 C, in float r) { return length(C - P)-r; }\n\n/* SCENE */\n#define SPHERE_POS ( vec3(0, 0, 4) )\n#define SPHERE_R   ( 0.9 ) \nfloat find_closest_scene_object(in vec3 marching_point)\n{\n    return sphereSDF_L2(marching_point, SPHERE_POS, SPHERE_R);\n}\n/* SCENE */\n\nHIT ray_march(\n    RAY ray,\n    float max_num_of_steps,\n    float max_distance,\n    float surface_distance) \n{\n    float marched_distance = 0.0; // Distance marched from ray origin.\n    float minimal_distance = 0.0; // Current distance to closest object.\n\n    bool quit = false, hit = false;\n\n    for (float step = 0.; (step < max_num_of_steps) && (quit == false) && (hit == false); step += 1.)\n    {\n        // Calculate current coordinates at ray.\n        vec3 marching_point = ray.origin + ray.direction * marched_distance;\n\n        // Find distance to closest object to point.\n        minimal_distance = find_closest_scene_object(marching_point);\n\n        // March.\n        marched_distance += minimal_distance;\n\n        hit = minimal_distance < surface_distance; // Hit some object?\n        quit = marched_distance > max_distance;    // Marched into infinity?\n    }\n\n    return HIT(marched_distance, hit);  \n}\n\n/* You can see how this works in 2d here:\n   https://www.shadertoy.com/view/slyBRc */\nvec3 approximate_normal(in vec3 P)\n{\n    const float delta = .01;          \n    // Sample distance function at hit point and three nearby points.\n    float s0 = find_closest_scene_object(P),\n          s1 = find_closest_scene_object(P + vec3(delta, 0, 0)),\n          s2 = find_closest_scene_object(P + vec3(0, delta, 0)),\n          s3 = find_closest_scene_object(P + vec3(0, 0, delta));\n    // Calculate finite differencies.    \n    float dfdx = s1 - s0,\n          dfdy = s2 - s0,\n          dfdz = s3 - s0;\n    // Approximate gradient/normal direction.\n    return normalize(vec3(dfdx, dfdy, dfdz));\n}\n\nvec3 lambert(RAY ray, HIT hit)\n{\n    vec3 color = vec3(1,0,0),\n         light_pos = vec3(10,10,-10),\n         hp = ray.origin + ray.direction * hit.hit_dist,\n         normal = approximate_normal(hp),\n         light_dir = normalize(light_pos - hp);\n    return \n        hit.hit_something == true ?\n            color * max(dot(light_dir, normal), 0.) :\n            (normalize(hp) + vec3(1)) * 0.5;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), false);\n\n    RAY ray;\n    /* Axis-aligned orthographic camera *\n    ray.origin = vec3(NDC, -4.0),\n    ray.direction = normalize(vec3(0., 0., 1.0));         \n    /* Axis-aligned perspective camera */\n    ray.origin = vec3(0.0, 0.0, -4.0),\n    ray.direction = normalize(vec3(NDC*0.125, 1.0));\n    /**/\n         \n    // March through scene.\n    HIT hit = ray_march(ray, MAX_NUM_OF_STEPS, MAX_MISS_DIST, MIN_HIT_DIST);                     \n    O = vec4(lambert(ray, hit), 1);\n \n    if (hit.hit_something == true && iMouse.z > 0.)\n    {\n        vec3 hp = ray.origin + ray.direction * hit.hit_dist,\n             normal = approximate_normal(hp);\n        // All.\n        O = vec4(      // How much?\n            normal.x,  // Facing right direction.\n            normal.y,  // Facing up direction.\n            -normal.z, // Facing to camera (backward) direction.\n            1.);\n    }\n}","name":"Image","description":"","type":"image"}]}