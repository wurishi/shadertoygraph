{"ver":"0.1","info":{"id":"dtfSD8","date":"1674658287","viewed":117,"name":"Noisy cube","username":"ianertson","description":"noisy cube","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 86\n#define NEAR 0.003\n#define FAR 200.0\n#define ZERO (min(0, int(iTime)))\n\n#define LIGHT_COLOR (vec3(255.0, 234.0, 167.0) / 255.0)\n\n#define M_PI (3.1416)\n#define TAU (M_PI*2.0)\n#define T (iTime)\n#define R iResolution.xy\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nvec3 mouseControl(vec3 p) {\n    vec2 m = iMouse.xy / R;\n    if (iMouse.z > 0.01) {\n        p.zy *= rot((m.y*TAU)+M_PI);\n        p.zy *= rot((m.y*TAU)+M_PI);\n        \n        p.xz *= rot(-(m.x*TAU)+M_PI);\n        p.xz *= rot(-(m.x*TAU)+M_PI);\n    }\n    \n\n    return p;\n}\n\nvec3 mouseControlInv(vec3 p) {\n    vec2 m = iMouse.xy / R;\n    if (iMouse.z > 0.01) {\n        p.xz *= inverse(rot((-m.x*TAU)+M_PI));\n        p.xz *= inverse(rot((-m.x*TAU)+M_PI));\n        \n        p.yz *= inverse(rot(-(m.y*TAU)+M_PI));\n        p.yz *= inverse(rot(-(m.y*TAU)+M_PI));\n    }\n    return p;\n}\n\n\nfloat hash21(vec2 uv) {\n    float x = fract(9.2818*sin(uv.x + fract(uv.y*3.2918) * 9.29184));\n    float y = fract(9.9831*cos(uv.y + fract(uv.x*3.9281) * 8.28721));\n    uv += cos(88.2818*vec2(x, y));\n    float rx = fract(cos(uv.x*8.281745)*10.29184) * 10.9291;\n    float ry = fract(sin(uv.y*9.281822)*10.92814) * 10.8271;\n    float rz = fract(cos(atan(rx, ry)*9.921512)*10.82814) * 10.28910;\n    return fract(8.218829 * cos(rz * M_PI) * dot(uv, vec2(rx, ry)));\n}\n\nfloat noise(vec2 uv) {\n    float x = textureLod(iChannel2, uv*0.5, 2.).r;\n    float y = textureLod(iChannel2, ((uv*0.5)*x) / M_PI, 2.).r;\n    float z = textureLod(iChannel2, ((uv*0.5) * vec2(x, y)) / M_PI, 2.).r;\n    return (x + y + z) / 3.0;\n}\n\nvec3 noise3(vec3 p) {\n    float x = noise(p.xz);\n    float y = noise(p.yz);\n    float z = noise(p.xy);\n    float w = noise(vec2(x, z)*2.);\n    \n    vec3 s = mix(vec3(-1.0), vec3(1.0), fract(10.291*vec3(x,y,z)*w+0.2918));\n\n    \n    return vec3(x,y,z)*s;\n}\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    float near;\n    vec3 entPos;\n    mat2 rotation;\n    int entity;\n    int skip;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n};\n\nfloat getDistCube(vec3 p, inout Data data) {\n    data.rotation = rot(T);\n    p.xz *= data.rotation;\n    vec3 boxPos = vec3(0.0, (0.5+(0.5*cos(T))), 0.0);\n    p -= boxPos;\n    data.entPos = boxPos;\n    vec3 boxSize = vec3(1.0);\n    p = abs(p) - boxSize;\n    return (length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.));\n}\n\nfloat getDistPlane(vec3 p) {\n    return p.y+1.0;\n}\n\nfloat getDist(vec3 p, inout Data data) {\n   \n    float cube = data.skip == 0 ? FAR: getDistCube(p, data);\n    float plane = data.skip == 1 ? FAR : getDistPlane(p);\n    \n    data.entity = 0;\n    if (plane < cube) { data.entity = 1; data.rotation = mat2(1.);};\n\n    return min(cube, plane);\n}\n\nvec3 getNormal(vec3 p, inout Data data) {\n    vec2 e = vec2(0.001, 0.0);\n    vec3 pos = vec3(0.);\n    return normalize(getDist(p, data) - vec3(\n        getDist(p + e.xyy, data),\n        getDist(p + e.yxy, data),\n        getDist(p + e.yyx, data)\n    ));\n}\n\nvec3 rotate(vec3 p, mat2 rotation) {\n    p.xz *= rotation;\n    return p;\n}\n\nvec2 getUv(vec3 p, vec3 n, mat2 rotation) {\n    p.xz *= rotation;\n    n.xz *= rotation;\n    float up = abs(dot(n, vec3(0.0, 1.0, 0.0)));\n    float left = abs(dot(n, vec3(1.0, 0.0, 0.0)));\n    float front = abs(dot(n, vec3(0.0, 0.0, 1.0)));\n    \n    int idx = 0;\n    float maxDist = -100.;\n    if (up > maxDist) { maxDist = up; idx = 0; }\n    if (left > maxDist) { maxDist = left; idx = 1; }\n    if (front > maxDist) { maxDist = front; idx = 2; }\n    \n   \n    switch (idx) {\n        case 0: return p.xz; break;\n        case 1: return p.zy; break;\n        case 2: return p.xy; break;\n    }\n    \n    return p.xz;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n\n    data.point = vec3(0.);\n    data.normal = vec3(0.);\n    data.uv = vec2(0.);\n    data.dist = FAR;\n    data.entPos = vec3(0.);\n    data.rotation = mat2(1.);\n    float dist = 0.0;\n    vec3 pos = vec3(0.);\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;    \n        float next = getDist(p, data);     \n        dist += next;   \n        if (next <= NEAR || next >= FAR) break;\n    }\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    data.normal = getNormal(p, data);\n    data.uv = getUv(p - data.entPos, data.normal, data.rotation);\n    data.dist = dist;\n    \n    return dist < FAR;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvec3 render(vec2 uv, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.);\n    \n    Light light = Light(vec3(3.0, 4.0, -2.0), LIGHT_COLOR, 6.0);\n    vec3 viewLight = normalize(ro - light.pos);\n    \n    Light ambient = Light(vec3(1.0, -1.0, 3.0), LIGHT_COLOR, 2.0);\n    \n    float dp = pow(abs(dot(rd, viewLight)), 16.);\n    \n    float viewLightDist = distance(ro, light.pos);\n    float viewLightAtt = dp * (pow(light.strength, 2.0) / max(0.0001, pow(viewLightDist, 2.0)));\n    \n    \n    \n    col += viewLightAtt * light.color;\n    \n    \n    \n    Data data;\n    data.near = FAR;\n    data.skip = -1;\n    if (march(ro, rd, data)) {\n        vec3 L = normalize(data.point - light.pos);\n     //   L = mouseControl(L);\n        float NdotL = max(0.0, dot(data.normal, L));\n        float lightDist = distance(data.point, light.pos);\n        float NdotLAmbient = max(0.0, dot(data.normal, normalize(ambient.pos)));\n        float att = NdotL * (pow(light.strength, 2.0) / max(0.0001, pow(lightDist, 2.0)));\n        \n        float attAmbient = (ambient.strength*NdotLAmbient);\n        \n        vec3 albedo = data.entity == 1 ? texture(iChannel0, data.uv*0.25).rgb : vec3(texture(iChannel2, data.uv*0.5).r);\n        vec3 baseColor = data.entity == 1 ? vec3(1.) : vec3(0.,0.502,0.075);\n        albedo *= baseColor;\n        vec3 diffuse = albedo / M_PI;\n        \n        float occlusion = 0.0;\n        Data oc;\n        oc.near = data.dist;\n        oc.skip = data.entity;\n        if (\n            march(data.point, -L, oc) &&\n            oc.dist < data.dist\n        ) {\n            occlusion = distance(light.pos, oc.point) / max(0.001, lightDist);\n            \n        }\n        \n        col += diffuse * (light.color * att);\n        col += diffuse * (ambient.color * attAmbient);\n        col *= max(0.0, 1.0-(occlusion));\n    } else {\n        vec3 env = texture(iChannel1, rd).rgb / M_PI;\n        col += env;\n    }\n    \n    col *= M_PI;\n    return col;\n}\n\n\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = iMouse.xy / R;\n    vec3 ro = vec3(0.0, 3.0, -5.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    rd.zy *= rot(-0.5);\n    \n    ro = mouseControl(ro);\n    rd = mouseControl(rd);\n    \n    ro.y = max(0.0, ro.y);\n    \n    rd = normalize(rd);\n    \n    col += render(uv, ro, rd);\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 1.6));\n    \n\n\n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}