{"ver":"0.1","info":{"id":"wlccRX","date":"1609601388","viewed":138,"name":"\"Blue\" hash-based TPDF dither","username":"mystran","description":"Pseudo-blue noise from a hash, with piece-wise inverting of the distribution to get a true TPDF at the end.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dither"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThis is a modified version of https://www.shadertoy.com/view/ldcfDH\n\nLike the original, this tries to approximate blue noise by sampling a hash at 5 points.\n\nUnlike the original, here we sample the points to the left and right, add them together\nto get a TPDF, which we then invert back into an RPDF by evaluating the CDF.\n\nThen we do the same for points above and below, then add the horizontal and vertical\nRPDF variables to get yet another TPDF that we invert once more.\n\nFinally, we sample the actual point, add with the RPDF computed from the 4 surrounding points\nand this time we keep the result as TPDF.\n\n*/\nconst float levels = 6.; // number of quantisation levels, must be at least 2 (preferably 4)\nconst float animFPS = 120.; // max framerate for temporal dither, set 0 to disable\nconst bool separateRGB = false; // use different random values for different channels?\nconst bool antiCompress = false; // expand near black and white to counter compression\n\nuint hash(uint x)\n{\n    x ^= x >> 16; x *= 0x7feb352du; \n    x ^= x >> 15; x *= 0x846ca68bu; \n    x ^= x >> 16;\n    return x;\n}\n\n// fetch random values for RGB channels\nvec3 hash2v(uint x, uint y)\n{\n    // take a hash, split it into components\n    uint h = hash(uint(x)+(uint(y)<<16));\n    vec3 v;\n    v.x = float(h&0xffu); if(separateRGB) h >>= 8;\n    v.y = float(h&0xffu); if(separateRGB) h >>= 8;\n    v.z = float(h&0xffu);\n    \n    return v / float(0xffu);\n}\n\nvec3 triCDF(vec3 x)\n{\n    vec3 y = sqrt(2.)*min(x, 1.-x); y *= y;\n    return mix(y, 1.-y, round(x));\n}\n\nvec3 dither(vec3 c, uvec2 xy)\n{\n    \n    // temporal dither\n    xy.x += uint(floor(animFPS*iTime)*12345.);\n    \n    // compute noise\n    vec3 xx = triCDF(.5 * (hash2v(xy.x-1u, xy.y) + hash2v(xy.x+1u, xy.y)));\n    vec3 yy = triCDF(.5 * (hash2v(xy.x, xy.y-1u) + hash2v(xy.x, xy.y+1u)));\n    vec3 mm = triCDF(.5 * (xx + yy));\n    \n    vec3 h = mm - hash2v(xy.x, xy.y);\n    float g = levels-1.;\n    \n    if(antiCompress)\n    {\n        // expand near black to counter compression\n        vec3 f0 = max(.5-c*g, 0.); c -= .5*f0*f0;\n        // expand near white to counter compression\n        vec3 f1 = max(.5-(1.-c)*g, 0.); c += .5*f1*f1;    \n    }\n    return round(c*g + h) / g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 c = texture(iChannel0,uv.xy).xyz;\n    if(fragCoord.y < 0.05*iResolution.y) c = vec3(fragCoord.x / iResolution.x);\n    \n    if(abs(iMouse.x - fragCoord.x) < iResolution.x*.25) \n    {\n        c = dither(c, uvec2(fragCoord.xy));\n    }\n\telse if(iMouse.y < .5*iResolution.y) c = round(c*(levels-1.)) / (levels-1.);\n    \n    \n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}