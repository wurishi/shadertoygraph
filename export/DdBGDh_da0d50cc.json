{"ver":"0.1","info":{"id":"DdBGDh","date":"1667597005","viewed":1385,"name":"GM Shaders: Noise Example","username":"Xor","description":"Top: Hash, Value, Perlin\nBottom: Worley, Voronoi, Fractal\n\nThis was written as a guide for my newest tutorial on noise functions","likes":84,"published":1,"flags":0,"usePreview":0,"tags":["example","tutorial","gmshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Noise Example\" by @XorDev\n\n    Top:    | Hash   | Value   | Perlin  |\n    Bottom: | Worley | Voronoi | Fractal |\n\n    This was written as a guide for my newest tutorial on noise functions:\n    \n    https://mini.gmshaders.com/p/gm-shaders-mini-noise-1437243\n\n*/\n\n//Typical pseudo-random hash (white noise)\nfloat hash1(vec2 p)\n{\n    //Generate a pseudo random number from 'p'.\n    return fract(sin(p.x*0.129898 + p.y*0.78233) * 43758.5453);\n}\n//vec2 version of the hash function\nvec2 hash2(vec2 p)\n{\n    //Generate a pseudo random vec2 from 'p'\n    return fract(sin(p * mat2(0.129898, 0.81314, 0.78233,  0.15926)) * 43758.5453);\n}\n//vec2 unit-vector version of the hash function\nvec2 hash2_norm(vec2 p)\n{\n    //Returns a random normalized direction vector\n    return normalize(hash2(p) - 0.5);\n}\n//Standard value noise\nfloat value_noise(vec2 p)\n{\n    //Cell (whole number) coordinates\n    vec2 cell = floor(p);\n    //Sub-cell (fractional) coordinates\n    vec2 sub = p - cell;\n    //Cubic interpolation (use sub for linear interpolation)\n    vec2 cube = sub*sub*(3.-2.*sub);\n    //Offset vector\n    const vec2 off = vec2(0,1); \n\n    //Sample cell corners and interpolate between them.\n    return mix( mix(hash1(cell+off.xx), hash1(cell+off.yx), cube.x),\n                mix(hash1(cell+off.xy), hash1(cell+off.yy), cube.x), cube.y);\n}\n//Standard Perlin noise\nfloat perlin_noise(vec2 p)\n{\n    //Cell (whole number) coordinates\n    vec2 cell = floor(p);\n    //Sub-cell (fractional) coordinates\n    vec2 sub = p - cell; \n    //Quintic interpolation\n    vec2 quint = sub*sub*sub*(10.0 + sub*(-15.0 + 6.0*sub));\n    //Offset vector\n    const vec2 off = vec2(0,1); \n    \n    //Compute corner hashes and gradients\n    float grad_corner00 = dot(hash2_norm(cell+off.xx), off.xx-sub);\n    float grad_corner10 = dot(hash2_norm(cell+off.yx), off.yx-sub);\n    float grad_corner01 = dot(hash2_norm(cell+off.xy), off.xy-sub);\n    float grad_corner11 = dot(hash2_norm(cell+off.yy), off.yy-sub);\n\n    //Interpolate between the gradient values them and map to 0 - 1 range\n    return mix(mix(grad_corner00, grad_corner10, quint.x),\n               mix(grad_corner01, grad_corner11, quint.x), quint.y) * 0.7 + 0.5;\n}\n//Standard Worley noise function\nfloat worley_noise(vec2 p)\n{\n    //Cell (whole number) coordinates\n    vec2 cell = floor(p);\n    //Initialize distance at a high-number\n    float dist = 9.0;\n    \n    //Iterate through [3,3] neighbor cells\n    for(int x = -1; x<=1; x++)\n    for(int y = -1; y<=1; y++)\n    {\n        //Get sample cell coordinates\n        vec2 sample_cell = cell + vec2(x,y);\n        //Compute difference from pixel to worley cell\n        vec2 worley_dif = hash2(sample_cell) + sample_cell - p;\n        //Save the nearest distance\n        dist = min(dist, length(worley_dif));\n    }\n    return dist;\n}\n//Standard Voronoi noise function\nfloat voronoi_noise(vec2 p)\n{\n    //Cell (whole number) coordinates\n    vec2 cell = floor(p);\n    //Initialize distance at a high-number\n    float dist = 9.0;\n    //Store the nearest voronoi cell\n    vec2 voronoi_cell = cell;\n    \n    //Iterate through [3,3] neighbor cells\n    for(int x = -1; x<=1; x++)\n    for(int y = -1; y<=1; y++)\n    {\n        //Get sample cell coordintaes\n        vec2 sample_cell = cell+vec2(x,y);\n        //Compute difference from pixel to worley cell\n        vec2 worley_dif = hash2(sample_cell) + sample_cell - p;\n        //Compute the worley distance        \n        float new_dist = length(worley_dif);\n        //If the new distance is the nearest\n        if (dist > new_dist)\n        {\n            //Store the new distance and cell coordinates\n            dist = new_dist;\n            voronoi_cell = sample_cell;\n        }\n    }\n    //Get a random value using cell coordinates\n    return hash1(voronoi_cell);\n}\n//Generate fractal value noise from multiple octaves\n//oct - The number of octave passes\n//per - Octave persistence value (should be between 0 and 1)\nfloat fractal_noise(vec2 p, int oct, float per)\n{\n    float noise_sum = 0.0; //Noise total\n    float weight_sum = 0.0; //Weight total\n    float weight = 1.0; //Octave weight\n\n    for(int i = 0; i < oct; i++) //Iterate through octaves\n    {\n        //Add noise octave to total\n        noise_sum += value_noise(p) * weight; \n        //Add octave weight to total\n        weight_sum += weight;\n        //Reduce octave amplitude with persistence value\n        weight *= per;\n        //Rotate and scale for next octave\n        p *= mat2(1.6,1.2,-1.2,1.6); \n    }\n    //Compute weighted average\n    return noise_sum / weight_sum; \n}\n\n//Function demo\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Compute 3x2 uv cells\n    vec2 uv = fragCoord / iResolution.xy * vec2(3,2);\n    \n    //Use scaled coordinates\n    vec2 coord = fragCoord/iResolution.y*10.0;\n    //Scroll horizontally\n    coord.x += iTime;\n    \n    //Initialize noise value\n    float noise = 0.0;\n    //Top-side\n    if (uv.y>1.0)\n    {\n        //Hash noise\n        if (uv.x<1.0) noise = hash1(mod(coord,7.31)*1e2);\n        //Value noise\n        else if (uv.x<2.0) noise = value_noise(coord);\n        //Perlin noise\n        else if (uv.x<3.0) noise = perlin_noise(coord);\n    }\n    //Bottom-side\n    else\n    {\n        //Worley\n        if (uv.x<1.0) noise = worley_noise(coord);\n        //Voronoi\n        else if (uv.x<2.0) noise = voronoi_noise(coord);\n        //Fractal value noise\n        else if (uv.x<3.0) noise = fractal_noise(coord, 6, 0.7);\n    }\n    //Compute shaded divider bars\n    vec2 bars = pow(smoothstep(0.5,0.4,abs(fract(uv)-0.5)), vec2(0.1));\n    \n    //Output noise + divider bars\n    fragColor = vec4(noise * bars.x * bars.y);\n}","name":"Image","description":"","type":"image"}]}