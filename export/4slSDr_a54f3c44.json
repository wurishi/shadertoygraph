{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const float PI=3.14159;\n\nfloat hash(float x){ return fract(sin(x)*43758.5453);}\nfloat hash(vec2 x){ return hash(hash(x.x)+x.y); }\nfloat hash(vec3 x){ return hash(hash(x.xy)*x.z); }\n\nfloat hashsquare(vec2 x){\n\tx.y-=iTime/2.;\n\tx.x+=sin(iTime/4.)*2.;\n\tvec2 ix = floor(x);\n\tvec2 dx = smoothstep(0.,1.,fract(x));\n\t\n\tfloat v1=hash(ix+vec2(0.,0.)),\n\t\t  v2=hash(ix+vec2(1.,0.)),\n\t\t  v3=hash(ix+vec2(0.,1.)),\n\t\t  v4=hash(ix+vec2(1.,1.));\n\t\n\tfloat h = mix(mix(v1,v2,dx.x),mix(v3,v4,dx.x),dx.y);\t\n\t\n\treturn h;\n}\n\nfloat spherize(vec2 uv){\n\treturn dot(uv,uv)/300.;\n}\n\nfloat heightmap(vec2 x){\n\t\n\tconst float scale=1.;\n\t\n\tx/=scale;\n\tfloat h=0.;\n\t\n\tmat3 p=mat3(vec3(4. ,0.03 ,0.),\n\t\t\t\tvec3(8. ,0.01 ,0.),\n\t\t\t\tvec3(68.,0.003,0.));\n\t\n\n\th=hashsquare(x/4.+iTime*0.0)*2.;\n\th=mix(h,hashsquare(x*p[0].x+iTime*p[0].z),p[0].y);\n\th=mix(h,hashsquare(x*p[1].x+iTime*p[1].z),p[1].y);\n\th=mix(h,hashsquare(x*p[2].x+iTime*p[2].z),p[2].y);\n\t//h=mix(h,hashsquare(x*2.),0.01);\n\n\treturn h*scale-spherize(x*scale);\t\n}\n\nvec3 tex(vec3 p, float mat){\n\tvec3 color;\n\t\n\tif(mat==1.){\n\t\tfloat b=1.-smoothstep(-0.,1.5,p.y+2.-spherize(p.xz));\n\t\tcolor=mix(vec3(0.7,0.5,0.2),vec3(0.5,0.5,0.3),b);\n\t}\n\t\n\t\n\treturn clamp(color,0.,1.);\n}\n\nvec2 map(vec3 p){\n\tvec2 t1=vec2(p.y+heightmap(p.xz),1.);\n\treturn t1;\n}\n\nvec3 normal(vec3 p){\n\tvec3 e=vec3(0.005,0.,0.);\n\tvec3 n=vec3(\n\t\tmap(p+e.xyy).x-map(p-e.xyy).x,\n\t\tmap(p+e.yxy).x-map(p-e.yxy).x,\n\t\tmap(p+e.yyx).x-map(p-e.yyx).x);\n\treturn normalize(n);\n}\n\nvec2 intersect(vec3 ro, vec3 rd){\n\tconst int iter=200;\n\tconst float mint=0.01;\n\tfloat t=0.;\n\tfor(int i=0 ; i<iter ; i++){\n\t\tvec2 h = map(ro+t*rd);\n\t\tif(h.x<0.001) return vec2(t,h.y);\n\t\tt+=max(mint*t,h.x);\n\t}\n\treturn vec2(0.);\n}\n\nvec3 shade(vec2 uv){\n\t\n\tvec3 ro=vec3(0.,0.,0.),\n\t\t rd;//=normalize(vec3(uv,-1.1));\n\t\n\tfloat h=map(ro).x;\n\tvec3 nor=normal(ro-vec3(0.,1.,0.)*h);\n\t\n\tvec3 lookat=vec3(0.,0.,-1.5)-nor/2.;\n\tvec3 cdir=normalize(lookat-ro);\n\tvec3 r  = normalize(cross(cdir,vec3(0.,1.,0.)));\n\tvec3 u  = normalize(cross(r,cdir));\n\t\n\t\n\trd = normalize(uv.x*r+uv.y*u+cdir);\n\t\n\t//rd=normalize(vec3(uv.x,-1.2,uv.y+0.1));\n\t\n\tro.yz-=map(ro)-vec2(0.5);\n\t\n\tvec2 t = intersect(ro,rd);\n\tvec3 color=vec3(0.);\n\t\n\tif(t.y>0.){\n\t\tvec3 p = ro+t.x*rd;\n\t\tvec3 n = normal(p);\n\t\tvec2 rot = vec2(cos(iTime/3.),sin(iTime/3.)*3.);\n\t\tvec3 l = normalize(vec3(rot.x,rot.y,rot.x));\n\t\t\n\t\tfloat amb=1.*n.y-p.y/100.;\n\t\tfloat dif=max(0.,dot(n,l));\n\t\tfloat spc=max(0.,dot((dot(rd,n)*n*-2.+rd),l));\n\t\tspc=smoothstep(0.85,1.,spc);\n\t\t\n\t\tcolor = vec3(0.3,0.15,0.7)*amb;\n\t\tcolor +=vec3(1.,1.,0.9)*dif;\n\t\tcolor +=spc;\n\t\t\n\t\tcolor *= tex(p,t.y);\n\t}\n\t\n\treturn vec3(color);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(shade(uv),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4slSDr","date":"1399406167","viewed":186,"name":"WetDunes","username":"cafe","description":"One of my first raymarching tests, it looks pretty awful :D","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["randomraymarchingtests"],"hasliked":0,"parentid":"","parentname":""}}