{"ver":"0.1","info":{"id":"MX3SWS","date":"1719574531","viewed":172,"name":"Visualizing Mouse Events #2","username":"hasenpfote","description":"Based on the previous work, this shader has been completely reworked.\n\nVisualizing Mouse Events: https://www.shadertoy.com/view/mtSBRV","likes":13,"published":1,"flags":32,"usePreview":1,"tags":["mouse","mouseevents"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Visualizing Mouse Events #2:\n *\n * Bar width: Specifies the width of a bar representing 1 frame [in pixels]\n * DblClick delay: Specifies the interval between releasing the mouse and the\n *     next click [in milliseconds]\n * Grid interval: Specifies the interval between grid lines [in frames]\n *\n * ===\n * Visualizing Mouse Events\n * https://www.shadertoy.com/view/mtSBRV\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define FONT_SAMPLER iChannel3\n\nconst float BASE_SIZE = 1024.;\n\n//==============================================================================\n// I/O\n//==============================================================================\n\n//const float DBLCLICK_DELAY = 300.;\n\nfloat load_state(in int id){\n    return load_state(iChannel0, id).w;\n}\n\nbool is_mouse_down(){\n    return iMouse.z > 0.;\n}\n\nbool is_mouse_up(){\n    return iMouse.z < 0.;\n}\n\nbool is_mouse_pressed(){\n    return iMouse.w > 0.;\n}\n\nbool is_mouse_released(){\n    return iMouse.z < 0. && load_state(SID_MOUSE_PREV_Z) > 0.;\n}\n\nbool is_mouse_dblclick(){\n    return iMouse.w > 0. && iTime - load_state(SID_MOUSE_PREV_EVENT_TIME) <= 0.001 * load_state(SID_SLIDER_2);\n}\n\n//==============================================================================\n// SDF\n//==============================================================================\n\nfloat sd_circle(in vec2 p, in float r){\n    return length(p) - r;\n}\n\nfloat sd_box(vec2 p, vec4 b, float radius){\n    vec2 size = b.zw * 0.5 - vec2(radius);\n    vec2 d = abs(p - b.xy - 0.5 * b.zw) - size;\n\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - radius;\n}\n\n//==============================================================================\n// UI - Label\n//==============================================================================\n\n#define _EOD 0xFF\n\n#define MAKE_LABEL_STRING(n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, cA, cB, cC, cD, cE, cF) \\\n    ENCODE_STRING_HEADER(n, n, 1, 0), ENCODE_CHARS(c0, c1, c2, c3), ENCODE_CHARS(c4, c5, c6, c7), ENCODE_CHARS(c8, c9, cA, cB), ENCODE_CHARS(cC, cD, cE, cF)\n\nstruct Label{\n    int header, s0, s1, s2, s3;\n};\n\nvoid text_string(in sampler2D sampler, inout TextState ts, in Label label){\n    int[] string = int[](label.header, label.s0, label.s1, label.s2, label.s3);\n    text_string(sampler, ts, string);\n}\n\nint text_length(in Label label){\n    return label.header >> 24;\n}\n\n//==============================================================================\n// UI - Slider\n//==============================================================================\n\nstruct Slider{\n    vec2 origin;\n    vec2 size;\n    float corner_radius;\n    float lo, hi, step_size, default_value;\n    int min_digits;\n    int sid;\n};\n\nconst vec3 SLIDER_ACTIVE_TRACK_COLOR = vec3(1.);\nconst vec3 SLIDER_INACTIVE_TRACK_COLOR = vec3(0.5);\n\nfloat slider_normalize_value(in Slider s, in float x){\n    return (x - s.lo) / (s.hi - s.lo);\n}\n\nfloat slider_value_horizontal(in Slider s, in float pos){\n    float u = clamp(pos - s.origin.x, 0., s.size.x) / s.size.x;\n\n    return floor(mix(s.lo, s.hi, u) / s.step_size) * s.step_size;\n}\n\nbool slider_contains(in Slider s, in vec2 pos){\n    vec2 p = pos - s.origin;\n\n    return all(greaterThanEqual(p, vec2(0.))) && all(lessThan(p, s.size));\n}\n\nvec3 slider_horizontal(in Slider s, in vec2 pos, in float value, in vec3 color){\n    float u = slider_normalize_value(s, value);\n    vec2 thumb_pos = vec2(u, 0.5) * s.size;\n    float dist;\n\n    dist = sd_box(pos, vec4(s.origin, s.size), s.corner_radius);\n    color = mix(SLIDER_INACTIVE_TRACK_COLOR, color, smoothstep(-2., 2., dist));\n\n    dist = sd_box(pos, vec4(s.origin, thumb_pos.x, s.size.y), s.corner_radius);\n    color = mix(SLIDER_ACTIVE_TRACK_COLOR, color, smoothstep(-2., 2., dist));\n\n    return color;\n}\n\n/**\n * Normalizes the slider scale for consistency across different resolutions.\n */\nSlider slider_normalize_scale(in Slider s, in float base_dim){\n    float factor = base_dim / BASE_SIZE;\n\n    Slider res = s;\n\n    res.origin *= factor;\n    res.size *= factor;\n    res.corner_radius *= factor;\n\n    return res;\n}\n\n//==============================================================================\n// Event\n//==============================================================================\n\nconst float LEFT_MARGIN = 300.;\nconst float BOTTOM_MARGIN = 300.;\n//const float BAR_WIDTH = 5.;\n\nconst vec3 MARGIN_COLOR = vec3(0.);\nconst vec3 EVEN_BG_COLOR = vec3(86) / 255.;\nconst vec3 ODD_BG_COLOR = vec3(65) / 255.;\nconst vec3 GRID_COLOR = vec3(16) / 255.;\n\nconst int MAX_EVENTS = 6;\n\nconst vec3[] BAR_COLORS = vec3[](\n    vec3(132,  94, 194) / 255.,\n    vec3(214,  93, 177) / 255.,\n    vec3(255, 111, 145) / 255.,\n    vec3(255, 150, 113) / 255.,\n    vec3(255, 199,  95) / 255.,\n    vec3(249, 248, 113) / 255.\n);\n\nbool is_on(in int index){\n    switch(index){\n    case 0: return is_mouse_pressed();\n    case 1: return is_mouse_down();\n    case 2: return is_mouse_released();\n    case 3: return is_mouse_up();\n    case 4: return is_mouse_dblclick();\n    case 5: return bool(iMouse.w < 0.);\n    default: return false;\n    }\n}\n\nDEF_STRING8(STRING_X,        _STRING_X,        int[](_i,_M,_o,_u,_s,_e,_PERIOD,_x))\nDEF_STRING8(STRING_Y,        _STRING_Y,        int[](_i,_M,_o,_u,_s,_e,_PERIOD,_y))\nDEF_STRING8(STRING_Z,        _STRING_Z,        int[](_i,_M,_o,_u,_s,_e,_PERIOD,_z))\nDEF_STRING8(STRING_W,        _STRING_W,        int[](_i,_M,_o,_u,_s,_e,_PERIOD,_w))\nDEF_STRING8(STRING_LT_0,     _STRING_LT_0,     int[](_LT,_0))\nDEF_STRING8(STRING_GT_0,     _STRING_GT_0,     int[](_GT,_0))\nDEF_STRING8(STRING_SEP,      _STRING_SEP,      int[](_COLON,_SP))\nDEF_STRING8(STRING_RESERVED, _STRING_RESERVED, int[](_R,_e,_s,_e,_r,_v,_e,_d))\nDEF_STRING8(STRING_PRESSED,  _STRING_PRESSED,  int[](_P,_r,_e,_s,_s,_e,_d))\nDEF_STRING8(STRING_RELEASED, _STRING_RELEASED, int[](_R,_e,_l,_e,_a,_s,_e,_d))\nDEF_STRING8(STRING_DOWN,     _STRING_DOWN,     int[](_D,_o,_w,_n))\nDEF_STRING8(STRING_UP,       _STRING_UP,       int[](_U,_p))\nDEF_STRING8(STRING_DBLCLICK, _STRING_DBLCLICK, int[](_D,_b,_l,_C,_l,_i,_c,_k))\n\nconst vec3 ACTIVE_TEXT_COLOR = vec3(132, 201, 139) / 255.;\nconst vec3 INACTIVE_TEXT_COLOR = vec3(0.5);\nconst float TEXT_ACTIVE_DURATION = 0.1;\n\nvec3 text(in vec2 pos, in vec3 color){\n    vec2 uv = pos / iResolution.y;\n    vec2 raw_char_size, char_size;\n    TextState ts;\n\n    text_init(ts, iResolution.y);\n    raw_char_size = text_raw_char_size(ts);\n\n    vec2 margin = vec2(LEFT_MARGIN, BOTTOM_MARGIN) * iResolution.y / BASE_SIZE;\n    float bar_height = (iResolution.y - margin.y) / float(MAX_EVENTS);\n    float u = (pos.y - margin.y) / (iResolution.y - margin.y);\n    int index = (MAX_EVENTS - 1) - int(floor(float(MAX_EVENTS) * u));\n    vec2 origin = vec2(0., iResolution.y);\n    vec2 label_pos;\n    vec3 text_color;\n    float prev_t;\n\n    text_begin(ts, 0.75);\n    char_size = raw_char_size * ts.scale * iResolution.y;\n    label_pos = origin + 0.5 * vec2(char_size.x, - char_size.y);\n    text_set_pos(ts, uv, label_pos / iResolution.y);\n    text_string(FONT_SAMPLER, ts, STRING_PRESSED); text_newline(ts);\n    text_string(FONT_SAMPLER, ts, STRING_W);\n    text_string(FONT_SAMPLER, ts, STRING_GT_0);\n    origin.y -= bar_height;\n    prev_t = load_state(SID_MOUSE_EVENT_TIME_1);\n    text_color = mix(INACTIVE_TEXT_COLOR, ACTIVE_TEXT_COLOR, float(iTime - prev_t <= TEXT_ACTIVE_DURATION));\n    text_end(ts, text_color, TEXT_OUTLINE_COLOR_DEFAULT, color);\n\n    text_begin(ts, 0.75);\n    char_size = raw_char_size * ts.scale * iResolution.y;\n    label_pos = origin + 0.5 * vec2(char_size.x, - char_size.y);\n    text_set_pos(ts, uv, label_pos / iResolution.y);\n    text_string(FONT_SAMPLER, ts, STRING_DOWN); text_newline(ts);\n    text_string(FONT_SAMPLER, ts, STRING_Z);\n    text_string(FONT_SAMPLER, ts, STRING_GT_0);\n    origin.y -= bar_height;\n    prev_t = load_state(SID_MOUSE_EVENT_TIME_2);\n    text_color = mix(INACTIVE_TEXT_COLOR, ACTIVE_TEXT_COLOR, float(iTime - prev_t <= TEXT_ACTIVE_DURATION));\n    text_end(ts, text_color, TEXT_OUTLINE_COLOR_DEFAULT, color);\n\n    text_begin(ts, 0.75);\n    char_size = raw_char_size * ts.scale * iResolution.y;\n    label_pos = origin + 0.5 * vec2(char_size.x, - char_size.y);\n    text_set_pos(ts, uv, label_pos / iResolution.y);\n    text_string(FONT_SAMPLER, ts, STRING_RELEASED);\n    origin.y -= bar_height;\n    prev_t = load_state(SID_MOUSE_EVENT_TIME_3);\n    text_color = mix(INACTIVE_TEXT_COLOR, ACTIVE_TEXT_COLOR, float(iTime - prev_t <= TEXT_ACTIVE_DURATION));\n    text_end(ts, text_color, TEXT_OUTLINE_COLOR_DEFAULT, color);\n\n    text_begin(ts, 0.75);\n    char_size = raw_char_size * ts.scale * iResolution.y;\n    label_pos = origin + 0.5 * vec2(char_size.x, - char_size.y);\n    text_set_pos(ts, uv, label_pos / iResolution.y);\n    text_string(FONT_SAMPLER, ts, STRING_UP); text_newline(ts);\n    text_string(FONT_SAMPLER, ts, STRING_Z);\n    text_string(FONT_SAMPLER, ts, STRING_LT_0);\n    origin.y -= bar_height;\n    prev_t = load_state(SID_MOUSE_EVENT_TIME_4);\n    text_color = mix(INACTIVE_TEXT_COLOR, ACTIVE_TEXT_COLOR, float(iTime - prev_t <= TEXT_ACTIVE_DURATION));\n    text_end(ts, text_color, TEXT_OUTLINE_COLOR_DEFAULT, color);\n\n    text_begin(ts, 0.75);\n    char_size = raw_char_size * ts.scale * iResolution.y;\n    label_pos = origin + 0.5 * vec2(char_size.x, - char_size.y);\n    text_set_pos(ts, uv, label_pos / iResolution.y);\n    text_string(FONT_SAMPLER, ts, STRING_DBLCLICK);\n    origin.y -= bar_height;\n    prev_t = load_state(SID_MOUSE_EVENT_TIME_5);\n    text_color = mix(INACTIVE_TEXT_COLOR, ACTIVE_TEXT_COLOR, float(iTime - prev_t <= TEXT_ACTIVE_DURATION));\n    text_end(ts, text_color, TEXT_OUTLINE_COLOR_DEFAULT, color);\n\n    text_begin(ts, 0.75);\n    char_size = raw_char_size * ts.scale * iResolution.y;\n    label_pos = origin + 0.5 * vec2(char_size.x, - char_size.y);\n    text_set_pos(ts, uv, label_pos / iResolution.y);\n    text_newline(ts);\n    text_string(FONT_SAMPLER, ts, STRING_W);\n    text_string(FONT_SAMPLER, ts, STRING_LT_0);\n    origin.y -= bar_height;\n    prev_t = load_state(SID_MOUSE_EVENT_TIME_6);\n    text_color = mix(INACTIVE_TEXT_COLOR, ACTIVE_TEXT_COLOR, float(iTime - prev_t <= TEXT_ACTIVE_DURATION));\n    text_end(ts, text_color, TEXT_OUTLINE_COLOR_DEFAULT, color);\n\n    text_begin(ts, 0.75);\n    char_size = raw_char_size * ts.scale * iResolution.y;\n    label_pos = margin + vec2(3. * char_size.x, - char_size.y);\n    text_set_pos(ts, uv, label_pos / iResolution.y);\n    text_string(FONT_SAMPLER, ts, STRING_X);\n    text_string(FONT_SAMPLER, ts, STRING_SEP, iMouse.x);\n    text_newline(ts);\n    text_string(FONT_SAMPLER, ts, STRING_Y);\n    text_string(FONT_SAMPLER, ts, STRING_SEP, iMouse.y);\n    text_newline(ts);\n    text_string(FONT_SAMPLER, ts, STRING_Z);\n    text_string(FONT_SAMPLER, ts, STRING_SEP, iMouse.z);\n    text_newline(ts);\n    text_string(FONT_SAMPLER, ts, STRING_W);\n    text_string(FONT_SAMPLER, ts, STRING_SEP, iMouse.w);\n    text_newline(ts);\n    text_end(ts, color);\n\n    return color;\n}\n\nvec3 draw(in vec2 pos, in vec3 color){\n    vec2 margin = vec2(LEFT_MARGIN, BOTTOM_MARGIN) * iResolution.y / BASE_SIZE;\n\n    if(pos.x < margin.x || pos.y < margin.y){\n        color = MARGIN_COLOR;\n        color = text(pos, color);\n    }else{\n        float u = (pos.y - margin.y) / (iResolution.y - margin.y);\n        float bar_width = load_state(SID_SLIDER_1);\n\n        if(pos.x < margin.x + bar_width){\n            int index = (MAX_EVENTS - 1) - int(floor(float(MAX_EVENTS) * u));\n            int grid_interval = int(load_state(SID_SLIDER_3));\n\n            color = mix(EVEN_BG_COLOR, ODD_BG_COLOR, mod(float(iFrame), 2.));\n            color = mix(color, GRID_COLOR, float(iFrame % grid_interval == 0));\n            color = mix(color, BAR_COLORS[index], float(is_on(index)));\n        }else{\n            color = texture(iChannel0, (pos - vec2(bar_width, 0.)) / iResolution.xy).rgb;\n            color *= smoothstep(0.005, 0.01, abs(fract(float(MAX_EVENTS) * u + 0.5) - 0.5));\n        }\n    }\n\n    return color;\n}\n\n//==============================================================================\n\nconst Label[] SLIDER_LABELS = Label[](\n    Label(MAKE_LABEL_STRING( 9,_B,_a,_r,_SP,_w,_i,_d,_t,_h,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD)),\n    Label(MAKE_LABEL_STRING(14,_D,_b,_l,_C,_l,_i,_c,_k,_SP,_d,_e,_l,_a,_y,_EOD,_EOD)),\n    Label(MAKE_LABEL_STRING(13,_G,_r,_i,_d,_SP,_i,_n,_t,_e,_r,_v,_a,_l,_EOD,_EOD,_EOD))\n);\n\nconst Slider[] SLIDERS = Slider[](\n    Slider(vec2(20., 220.), vec2(250., 20.), 8.,   1.,  10.,  1.,   5., 0, SID_SLIDER_1), // BAR_WIDTH\n    Slider(vec2(20., 140.), vec2(250., 20.), 8., 100., 900., 10., 300., 0, SID_SLIDER_2), // DBLCLICK_DELAY\n    Slider(vec2(20.,  60.), vec2(250., 20.), 8.,  10., 100., 10., 100., 0, SID_SLIDER_3)\n);\n\nint find_ui_sid(in vec2 pos){\n    // sliders\n    for(int i = 0; i < SLIDERS.length(); i++){\n        Slider s = slider_normalize_scale(SLIDERS[i], iResolution.y);\n\n        if(slider_contains(s, pos))\n            return s.sid;\n    }\n\n    return -1;\n}\n\nbool is_focus_locked(in int active_ui, in vec2 pos){\n    // sliders\n    for(int i = 0; i < SLIDERS.length(); i++){\n        if(SLIDERS[i].sid == active_ui)\n            return true;\n    }\n\n    return false;\n}\n\nfloat handle_active_ui_state(in int active_ui, in int hud_visibility){\n    if(iFrame > 0){\n        if(iMouse.w > 0.){\n            active_ui = find_ui_sid(iMouse.xy);\n        }else if(iMouse.w < 0. && iMouse.z > 0.){\n            active_ui = is_focus_locked(active_ui, iMouse.xy) ? active_ui : -1;\n        }else if(iMouse.z < 0.){\n            active_ui = -1;\n        }\n    }else{\n        active_ui = -1;\n    }\n\n    return float(active_ui);\n}\n\nfloat handle_slider_state(in int sid){\n    int i = sid - SID_SLIDER_1;\n\n    if(iFrame > 0){\n        int active_ui = int(load_state(SID_ACTIVE_UI));\n\n        if(SLIDERS[i].sid == active_ui){\n            Slider s = slider_normalize_scale(SLIDERS[i], iResolution.y);\n\n            return slider_value_horizontal(s, iMouse.x);\n        }else{\n            return load_state(SLIDERS[i].sid);\n        }\n    }else{\n        return SLIDERS[i].default_value;\n    }\n}\n\nvec3 draw_hud(in vec2 pos, in vec3 color){\n    for(int i = 0; i < SLIDERS.length(); i++){\n        Slider s = slider_normalize_scale(SLIDERS[i], iResolution.y);\n        float value = load_state(s.sid);\n\n        color = slider_horizontal(s, pos, value, color);\n    }\n\n    //\n\n    vec2 uv = pos / iResolution.y;\n    TextState ts;\n\n    text_init(ts, iResolution.y);\n\n    vec2 raw_char_size = text_raw_char_size(ts);\n\n    text_begin(ts, 0.5);\n\n    vec2 char_size = raw_char_size * ts.scale * iResolution.y;\n\n    for(int i = 0; i < SLIDER_LABELS.length(); i++){\n        Slider s = slider_normalize_scale(SLIDERS[i], iResolution.y);\n        float value = load_state(s.sid);\n        vec2 label_pos = s.origin + vec2(0., s.size.y + char_size.y);\n        vec2 value_pos = s.origin + vec2(s.size.x + char_size.x, 0.5 * (s.size.y + char_size.y));\n\n        text_set_pos(ts, uv, label_pos / iResolution.y);\n        text_string(FONT_SAMPLER, ts, SLIDER_LABELS[i]);\n        text_set_pos(ts, uv, value_pos / iResolution.y);\n        text_value(FONT_SAMPLER, ts, value, s.min_digits);\n    }\n\n    text_end(ts, vec3(1.), vec3(0.3), color);\n\n    return color;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 color = vec4(0.);\n    int sid = pos_to_sid(ivec2(fragCoord));\n\n    switch(sid){\n    case SID_MOUSE_PREV_Z:\n        color.a = iMouse.z;\n        break;\n    case SID_MOUSE_PREV_EVENT_TIME:\n        float prev_z = load_state(SID_MOUSE_PREV_Z);\n        float prev_t = load_state(SID_MOUSE_PREV_EVENT_TIME);\n        color.a = prev_z > 0. ? iTime : prev_t;\n        break;\n    case SID_MOUSE_EVENT_TIME_1:\n    case SID_MOUSE_EVENT_TIME_2:\n    case SID_MOUSE_EVENT_TIME_3:\n    case SID_MOUSE_EVENT_TIME_4:\n    case SID_MOUSE_EVENT_TIME_5:\n    case SID_MOUSE_EVENT_TIME_6:\n        color.a = is_on(sid - SID_MOUSE_EVENT_TIME_1) ? iTime : load_state(sid);\n        break;\n    case SID_ACTIVE_UI:\n        int active_ui = int(load_state(SID_ACTIVE_UI));\n        color.a = handle_active_ui_state(active_ui, 1);\n        break;\n    case SID_SLIDER_1:\n    case SID_SLIDER_2:\n    case SID_SLIDER_3:\n        color.a = handle_slider_state(sid);\n        break;\n    default:\n        break;\n    }\n\n    color.rgb = draw(fragCoord, color.rgb);\n    color.rgb = draw_hud(fragCoord, color.rgb);\n\n    fragColor = color;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define SID_MOUSE_PREV_Z           0\n#define SID_MOUSE_PREV_EVENT_TIME  1\n#define SID_MOUSE_EVENT_TIME_1     2\n#define SID_MOUSE_EVENT_TIME_2     3\n#define SID_MOUSE_EVENT_TIME_3     4\n#define SID_MOUSE_EVENT_TIME_4     5\n#define SID_MOUSE_EVENT_TIME_5     6\n#define SID_MOUSE_EVENT_TIME_6     7\n#define SID_ACTIVE_UI              8\n#define SID_SLIDER_1               9\n#define SID_SLIDER_2              10\n#define SID_SLIDER_3              11\n\n//==============================================================================\n\nvec3 srgb_to_linear(in vec3 color){\n    vec3 lo = vec3(color / 12.92);\n    vec3 hi = pow((color + 0.055) / 1.055, vec3(2.4));\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.04045)));\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    vec3 lo = 12.92 * color;\n    vec3 hi = 1.055 * pow(color, vec3(1./2.4)) - 0.055;\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.0031308)));\n}\n\n//==============================================================================\n// State buffer\n//==============================================================================\n\nconst ivec2 STATE_BUFFER_SIZE = ivec2(128);\n\nvec4 load_state(in sampler2D sampler, in int id){\n    ivec2 pos = ivec2(id % STATE_BUFFER_SIZE.x, id / STATE_BUFFER_SIZE.y);\n    return texelFetch(sampler, pos, 0);\n}\n\nint pos_to_sid(in ivec2 pos){\n    int factor = 1 - 2 * int(any(greaterThanEqual(pos, STATE_BUFFER_SIZE)));\n    return (pos.y * STATE_BUFFER_SIZE.x + pos.x) * factor;\n}\n\nbool can_store_state(in int id, in ivec2 pos){\n    return id == pos_to_sid(pos);\n}\n\n//==============================================================================\n\n#define ENABLE_STRING\n\n// https://dev.w3.org/html5/spec-LC/named-character-references.html\n\n#define _SP     0x20 // ' '\n#define _EXCL   0x21 // '!'\n#define _QUOT   0x22 // '\"'\n#define _NUM    0x23 // '#'\n#define _DOLLAR 0x24 // '$'\n#define _PERCNT 0x25 // '%'\n#define _AMP    0x26 // '&'\n#define _APOS   0x27 // '''\n#define _LPAR   0x28 // '('\n#define _RPAR   0x29 // ')'\n#define _AST    0x2A // '*'\n#define _PLUS   0x2B // '+'\n#define _COMMA  0x2C // ','\n#define _HYPHEN 0x2D // '-'\n#define _PERIOD 0x2E // '.'\n#define _SOL    0x2F // '/'\n#define _0      0x30 // '0'\n#define _1      0x31 // '1'\n#define _2      0x32 // '2'\n#define _3      0x33 // '3'\n#define _4      0x34 // '4'\n#define _5      0x35 // '5'\n#define _6      0x36 // '6'\n#define _7      0x37 // '7'\n#define _8      0x38 // '8'\n#define _9      0x39 // '9'\n#define _COLON  0x3A // ':'\n#define _SEMI   0x3B // ';'\n#define _LT     0x3C // '<'\n#define _EQUALS 0x3D // '='\n#define _GT     0x3E // '>'\n#define _QUEST  0x3F // '?'\n#define _COMMAT 0x40 // '@'\n#define _A      0x41 // 'A'\n#define _B      0x42 // 'B'\n#define _C      0x43 // 'C'\n#define _D      0x44 // 'D'\n#define _E      0x45 // 'E'\n#define _F      0x46 // 'F'\n#define _G      0x47 // 'G'\n#define _H      0x48 // 'H'\n#define _I      0x49 // 'I'\n#define _J      0x4A // 'J'\n#define _K      0x4B // 'K'\n#define _L      0x4C // 'L'\n#define _M      0x4D // 'M'\n#define _N      0x4E // 'N'\n#define _O      0x4F // 'O'\n#define _P      0x50 // 'P'\n#define _Q      0x51 // 'Q'\n#define _R      0x52 // 'R'\n#define _S      0x53 // 'S'\n#define _T      0x54 // 'T'\n#define _U      0x55 // 'U'\n#define _V      0x56 // 'V'\n#define _W      0x57 // 'W'\n#define _X      0x58 // 'X'\n#define _Y      0x59 // 'Y'\n#define _Z      0x5A // 'Z'\n#define _LSQB   0x5B // '['\n#define _BSOL   0x5C // '\\'\n#define _RSQB   0x5D // ']'\n#define _HAT    0x5E // '^'\n#define _LOWBAR 0x5F // '_'\n#define _GRAVE  0x60 // '`'\n#define _a      0x61 // 'a'\n#define _b      0x62 // 'b'\n#define _c      0x63 // 'c'\n#define _d      0x64 // 'd'\n#define _e      0x65 // 'e'\n#define _f      0x66 // 'f'\n#define _g      0x67 // 'g'\n#define _h      0x68 // 'h'\n#define _i      0x69 // 'i'\n#define _j      0x6A // 'j'\n#define _k      0x6B // 'k'\n#define _l      0x6C // 'l'\n#define _m      0x6D // 'm'\n#define _n      0x6E // 'n'\n#define _o      0x6F // 'o'\n#define _p      0x70 // 'p'\n#define _q      0x71 // 'q'\n#define _r      0x72 // 'r'\n#define _s      0x73 // 's'\n#define _t      0x74 // 't'\n#define _u      0x75 // 'u'\n#define _v      0x76 // 'v'\n#define _w      0x77 // 'w'\n#define _x      0x78 // 'x'\n#define _y      0x79 // 'y'\n#define _z      0x7A // 'z'\n#define _LCUB   0x7B // '{'\n#define _VERBAR 0x7C // '|'\n#define _RCUB   0x7D // '}'\n#define _TILDE  0x7E // '~'\n\n/*\n * horizontal\n *\n *   | ML | LSB | Width | RSB | MR |\n *        |<<    Advance    >>|\n *\n *   Advance = LSB + Width + RSB\n *   ML = (CharSize - Width) / 2 - LSB\n *   MR = CharSize - (ML + LSB + Width + RSB)\n *\n * vertical\n *\n *   | LG/2 | MT | Height | MB | LG/2 |\n *\n *   Height = Ascent + Descent\n *   MT = CharSize - (Baseline + Ascent)\n *   MB = CharSize - (MT + Height)\n *\n */\nstruct FontMetrics{\n    // horizontal\n    float advance;\n    float margin_left;\n    float margin_right;\n    // vertical\n    float height;\n    float margin_top;\n    float margin_bottom;\n    float line_gap;\n};\n\nstruct TextState{\n    vec2 hori_offset;\n    vec2 vert_offset;\n    vec2 org;\n    vec2 pos;\n    float dist;\n    float scale;\n    float res_scale;\n};\n\nconst float FONT_TEXTURE_SIZE = 1024.;\nconst float FONT_CHAR_SIZE = 64.;\nconst float FONT_GRID_SIZE = 16.;\n\nconst FontMetrics FONT_METRICS_DEFAULT = FontMetrics(36., 14., 14., 58., 4., 2., 10.);\n\nconst float FONT_SDF_INITIAL_DISTANCE = 1e1;\n\nconst int TEXT_MAX_INT_DIGITS = 4;\nconst int[] TEXT_POW10_TABLE = int[TEXT_MAX_INT_DIGITS + 1](1, 10, 100, 1000, 10000);\nconst int TEXT_MAX_INT_PLACE = TEXT_POW10_TABLE[TEXT_MAX_INT_DIGITS - 1];\n\nconst vec3 TEXT_COLOR_DEFAULT = vec3(1.);\nconst vec3 TEXT_OUTLINE_COLOR_DEFAULT = vec3(0.);\n\nint pop(in uint x){\n    x = (x & 0x55555555u) + ((x >> 1) & 0x55555555u);\n    x = (x & 0x33333333u) + ((x >> 2) & 0x33333333u);\n    x = (x & 0x0F0F0F0Fu) + ((x >> 4) & 0x0F0F0F0Fu);\n    x = (x & 0x00FF00FFu) + ((x >> 8) & 0x00FF00FFu);\n    x = (x & 0x0000FFFFu) + ((x >> 16) & 0x0000FFFFu);\n\n    return int(x);\n}\n\nint nlz(in uint x){\n    x = x | (x >> 1);\n    x = x | (x >> 2);\n    x = x | (x >> 4);\n    x = x | (x >> 8);\n    x = x | (x >> 16);\n\n    return pop(~x);\n}\n\nint log2i(in uint x){\n    return 31 - nlz(x);\n}\n\nfloat font_sdf_char(in sampler2D sampler, in int code, in vec2 char_uv){\n    if(char_uv.x < 0. || char_uv.x > 1. || char_uv.y < 0. || char_uv.y > 1.)\n        return FONT_SDF_INITIAL_DISTANCE;\n\n    const float reciprocal = 1. / FONT_GRID_SIZE;\n\n    /*\n     * (char_uv + vec2(code % 16, 15 - code / 16)) / 16.;\n     */\n    float c = float(code);\n    vec2 uv = char_uv * reciprocal\n                + fract(vec2(c, FONT_GRID_SIZE - 1. - floor(c * reciprocal)) * reciprocal);\n\n    /*\n     *                 boundary\n     *   -0.5 ========== 0.0 ========= +0.5 (distance)\n     *     |<--  Int.  -->|<--  Ext.  -->|\n     */\n    return textureLod(sampler, uv, 0.).a - 0.5;\n}\n\nvoid text_init(out TextState ts, in float base_dim){\n    float ml = FONT_METRICS_DEFAULT.margin_left / FONT_TEXTURE_SIZE;\n    float mt = (FONT_METRICS_DEFAULT.margin_top - 0.5 * FONT_METRICS_DEFAULT.line_gap) / FONT_TEXTURE_SIZE;\n    ts.hori_offset = vec2(ml, -(ml + floor(FONT_METRICS_DEFAULT.advance / FONT_TEXTURE_SIZE * base_dim) / base_dim));\n    ts.vert_offset = vec2(-mt, mt + floor((FONT_METRICS_DEFAULT.height + FONT_METRICS_DEFAULT.line_gap) / FONT_TEXTURE_SIZE * base_dim) / base_dim);\n\n    ts.dist = FONT_SDF_INITIAL_DISTANCE;\n    ts.res_scale = base_dim / FONT_TEXTURE_SIZE;\n}\n\nvec2 text_raw_char_size(in TextState ts){\n    return vec2(abs(ts.hori_offset.x + ts.hori_offset.y),\n                ts.vert_offset.x + ts.vert_offset.y);\n}\n\nvec2 text_char_size(in TextState ts){\n    return text_raw_char_size(ts) * ts.scale;\n}\n\nvoid text_begin(inout TextState ts, in float scale){\n    ts.dist = FONT_SDF_INITIAL_DISTANCE;\n    ts.scale = scale;\n}\n\nvoid text_end(inout TextState ts,\n              in vec3 text_color, in vec3 outline_color, inout vec3 color){\n    // Inversely proportional to the font scale.\n    float scale = ts.res_scale * ts.scale;\n    float f = 1. - exp2(- 1. / (scale * scale));\n\n    /*\n     *        1.5*MID  MID  0.5*MID   0   0.5*MED  MED  1.5*MED\n     * --~-------+------+------+------+------+------+------+------+--~-->\n     *      Font |<<   MIX   >>| OTL. | OTL. |<<   MIX   >>| BG.  |\n     */\n    float max_interior_dist = mix(0.004, 0.010, f);\n    float max_exterior_dist = mix(0.020, 0.050, f);\n\n    vec3 mixed_color = mix(text_color, color, step(0., ts.dist));\n\n    vec3 interior_color = mix(outline_color, mixed_color, smoothstep(0., max_interior_dist, abs(ts.dist) - 0.5 * max_interior_dist));\n    vec3 exterior_color = mix(outline_color, mixed_color, smoothstep(0., max_exterior_dist, ts.dist - 0.5 * max_exterior_dist));\n\n    mixed_color = mix(interior_color, exterior_color, step(0., ts.dist));\n    color = mix(mixed_color, color, step(FONT_SDF_INITIAL_DISTANCE, ts.dist));\n}\n\nvoid text_end(inout TextState ts, inout vec3 color){\n    text_end(ts, TEXT_COLOR_DEFAULT, TEXT_OUTLINE_COLOR_DEFAULT, color);\n}\n\nvoid text_set_pos(inout TextState ts, in vec2 uv, in vec2 x){\n    ts.pos = ts.org = uv - (x - vec2(0., 1.));\n}\n\nvoid text_advance_pos(inout vec2 p, in vec2 offset, in float scale, in int num_chars){\n    p.x += float(num_chars) * (offset.x + offset.y) * scale;\n}\n\nvoid text_newline(inout vec2 p, in vec2 offset, in float scale, in float left){\n    p.x = left;\n    p.y += (offset.x + offset.y) * scale;\n}\n\nvoid text_newline(inout TextState ts){\n    text_newline(ts.pos, ts.vert_offset, ts.scale, ts.org.x);\n}\n\nivec2 text_map_to_index(in vec2 p, in vec2 hori_offset, in vec2 vert_offset, in float scale){\n    return ivec2(floor(p.x / (abs(hori_offset.x + hori_offset.y) * scale)),\n                 floor((1. - p.y) / ((vert_offset.x + vert_offset.y) * scale)));\n}\n\nint text_count_digits(in uint x){\n    x = min(x, uint(TEXT_POW10_TABLE[TEXT_MAX_INT_DIGITS] - 1));\n\n    int y = (9 * log2i(x | 1u)) >> 5;\n\n    return y + int(x > uint(TEXT_POW10_TABLE[y + 1] - 1)) + 1;\n}\n\nint text_count_digits(in uint x, in int min_digits){\n    return max(text_count_digits(x), min_digits);\n}\n\nvoid text_char_internal(in sampler2D sampler, in int code,\n                        inout vec2 p, in vec2 hori_offset, in vec2 vert_offset, in float scale, inout float dist){\n    vec2 q = p + vec2(hori_offset.x, vert_offset.x) * scale;\n\n    float gs = FONT_GRID_SIZE / scale;\n    vec2 char_uv = q * gs;\n    char_uv.y -= gs - 1.;\n\n    dist = min(dist, font_sdf_char(sampler, code, char_uv));\n\n    p.x = q.x + hori_offset.y * scale;\n}\n\nvoid text_char(in sampler2D sampler, inout TextState ts, in int code){\n    ivec2 index = text_map_to_index(ts.pos, ts.hori_offset, ts.vert_offset, ts.scale);\n\n    if(index.x >= 1 || index.y >= 1){\n        text_advance_pos(ts.pos, ts.hori_offset, ts.scale, 1);\n        return;\n    }\n\n    if(index.x < 0 || index.y < 0){\n        return;\n    }\n\n    text_char_internal(sampler, code, ts.pos, ts.hori_offset, ts.vert_offset, ts.scale, ts.dist);\n}\n\nvoid text_value_common(in sampler2D sampler, inout TextState ts,\n                       in int signum, in int i, in int f, in int i_len, in int f_len){\n    int signed_int_len = int(signum < 0) + i_len;\n    int len = signed_int_len + f_len + int(f_len > 0);\n    ivec2 index = text_map_to_index(ts.pos, ts.hori_offset, ts.vert_offset, ts.scale);\n\n    if(index.x >= len || index.y >= 1){\n        text_advance_pos(ts.pos, ts.hori_offset, ts.scale, len);\n        return;\n    }\n\n    if(index.x < 0 || index.y < 0){\n        return;\n    }\n\n    int code;\n\n    if(index.x == 0 && signum < 0){\n        code = 45;\n    }else if(index.x == signed_int_len){\n        code = 46;\n    }else if(index.x < signed_int_len){\n        int place = TEXT_POW10_TABLE[signed_int_len - 1 - index.x];\n        code = 48 + ((i / place) % 10);\n    }else{\n        int place = TEXT_POW10_TABLE[len - 1 - index.x];\n        code = 48 + ((f / place) % 10);\n    }\n\n    text_advance_pos(ts.pos, ts.hori_offset, ts.scale, index.x);\n    text_char_internal(sampler, code, ts.pos, ts.hori_offset, ts.vert_offset, ts.scale, ts.dist);\n}\n\nvoid text_decompose_value(in uint x, in int min_digits,\n                          out int signum, out int i, out int f, out int i_len, out int f_len){\n    signum = int(x > 0u);\n    i = int(x);\n    f = 0;\n    i_len = text_count_digits(x, min_digits);\n    f_len = 0;\n}\n\nvoid text_decompose_value(in int x, in int min_digits,\n                          out int signum, out int i, out int f, out int i_len, out int f_len){\n    signum = sign(x);\n    i = abs(x);\n    f = 0;\n    i_len = text_count_digits(uint(i), min_digits);\n    f_len = 0;\n}\n\nvoid text_decompose_value(in float x, in int min_digits,\n                          out int signum, out int i, out int f, out int i_len, out int f_len){\n    float fx, ix;\n    fx = modf(abs(x), ix);\n    fx = float(TEXT_POW10_TABLE[min_digits]) * fx;\n\n    signum = sign(int(x));\n    i = int(ix);\n    f = int(fx);\n    i_len = text_count_digits(uint(i), 1);\n    f_len = text_count_digits(uint(f), min_digits) * int(min_digits > 0);\n}\n\n#define DEF_TEXT_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out int signum, out int i, out int f, out int i_len, out int f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x, min_digits, signum, i, f, i_len, f_len); \\\n        return int(signum < 0) + i_len + f_len + int(f_len > 0); \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        int signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits){ \\\n        int signum, i, f, i_len, f_len; \\\n        text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        text_value_common(sampler, ts, signum, i, f, i_len, f_len); \\\n    }\n\nDEF_TEXT_VALUE(uint)\nDEF_TEXT_VALUE(int)\nDEF_TEXT_VALUE(float)\n\n/*\n * This macro defines text_value functions for vector types.\n * It separates definitions by dimension, such as 2D, 3D, and 4D, to reduce\n * compile time.\n *\n * Usage example:\n *\n *   DEF_TEXT_VEC2_VALUE(uvec2)\n *\n *   void text_value(in sampler2D sampler, inout TextState ts,\n *                   in uvec2 x, in int min_digits){\n *       text_vec_value(sampler, x, min_digits, _COMMA, ts);\n *   }\n *\n *   DEF_TEXT_VEC2_VALUE(ivec2)\n *\n *   void text_value(in sampler2D sampler, inout TextState ts,\n *                   in ivec2 x, in int min_digits){\n *       text_vec_value(sampler, x, min_digits, _COMMA, ts);\n *   }\n *\n *   DEF_TEXT_VEC2_VALUE(vec2)\n *\n *   void text_value(in sampler2D sampler, inout TextState ts,\n *                   in vec2 x, in int min_digits){\n *       text_vec_value(sampler, x, min_digits, _COMMA, ts);\n *   }\n *\n */\n#define DEF_TEXT_VEC2_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out ivec2 signum, out ivec2 i, out ivec2 f, out ivec2 i_len, out ivec2 f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x.x, min_digits, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_decompose_value(x.y, min_digits, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        ivec2 len = ivec2(lessThan(signum, ivec2(0))) + i_len + ivec2(lessThan(ivec2(0), f_len)) + f_len; \\\n        return 2 - 1 + len.x + len.y; \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        ivec2 signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_vec_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits, in int sep){ \\\n        ivec2 signum, i, f, i_len, f_len; \\\n        int total_len = text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        vec2 size = text_char_size(ts); \\\n        size.x *= float(total_len); \\\n        vec2 p = ts.pos; \\\n        if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){ \\\n            text_advance_pos(p, ts.hori_offset, ts.scale, total_len); \\\n            ts.pos = p; \\\n            return; \\\n        } \\\n        text_value_common(sampler, ts, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n    }\n\n#define DEF_TEXT_VEC3_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out ivec3 signum, out ivec3 i, out ivec3 f, out ivec3 i_len, out ivec3 f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x.x, min_digits, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_decompose_value(x.y, min_digits, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_decompose_value(x.z, min_digits, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n        ivec3 len = ivec3(lessThan(signum, ivec3(0))) + i_len + ivec3(lessThan(ivec3(0), f_len)) + f_len; \\\n        return 3 - 1 + len.x + len.y + len.z; \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        ivec3 signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_vec_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits, in int sep){ \\\n        ivec3 signum, i, f, i_len, f_len; \\\n        int total_len = text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        vec2 size = text_char_size(ts); \\\n        size.x *= float(total_len); \\\n        vec2 p = ts.pos; \\\n        if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){ \\\n            text_advance_pos(p, ts.hori_offset, ts.scale, total_len); \\\n            ts.pos = p; \\\n            return; \\\n        } \\\n        text_value_common(sampler, ts, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n    }\n\n#define DEF_TEXT_VEC4_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out ivec4 signum, out ivec4 i, out ivec4 f, out ivec4 i_len, out ivec4 f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x.x, min_digits, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_decompose_value(x.y, min_digits, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_decompose_value(x.z, min_digits, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n        text_decompose_value(x.w, min_digits, signum.w, i.w, f.w, i_len.w, f_len.w); \\\n        ivec4 len = ivec4(lessThan(signum, ivec4(0))) + i_len + ivec4(lessThan(ivec4(0), f_len)) + f_len; \\\n        return 4 - 1 + len.x + len.y + len.z + len.w; \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        ivec4 signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_vec_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits, in int sep){ \\\n        ivec4 signum, i, f, i_len, f_len; \\\n        int total_len = text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        vec2 size = text_char_size(ts); \\\n        size.x *= float(total_len); \\\n        vec2 p = ts.pos; \\\n        if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){ \\\n            text_advance_pos(p, ts.hori_offset, ts.scale, total_len); \\\n            ts.pos = p; \\\n            return; \\\n        } \\\n        text_value_common(sampler, ts, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.w, i.w, f.w, i_len.w, f_len.w); \\\n    }\n\n#ifdef ENABLE_STRING\n/*\n * String\n *\n * Inspired by the following work:\n * Mostly-readable text in source - ttg\n * https://www.shadertoy.com/view/Wd2SDt\n */\n\n#define ENCODE_CHARS(a, b, c, d) \\\n    (((a) << 24) | (((b) & 0xFF) << 16) | (((c) & 0xFF) << 8) | ((d) & 0xFF))\n\n#define DECODE_CHARS(x) \\\n    int[4](((x) >> 24) & 0xFF,((x) >> 16) & 0xFF,((x) >> 8) & 0xFF, (x) & 0xFF)\n\n#define ENCODE_STRING_HEADER(f0, f1, f2, f3) \\\n    ENCODE_CHARS(f0, f1, f2, f3)\n\n#define DECODE_STRING_HEADER(header) \\\n    DECODE_CHARS(header)\n\n#define STRING_AT(arr, i) arr[clamp((i), 0, arr.length() - 1)]\n\n#define STRING_ENCODE_CHARS(arr, offs) \\\n    ENCODE_CHARS(STRING_AT(arr, offs + 0), STRING_AT(arr, offs + 1), STRING_AT(arr, offs + 2), STRING_AT(arr, offs + 3))\n\n/*\n * DEF_STRING:\n *   WebGL does not support the token-pasting operator (##), so a temporary\n *   variable must be manually specified.\n *   Let's hope the compiler optimizes away the temporary variable.\n */\n\n// STRING8\n\n#define _DEF_STRING8(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[3](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                             STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04));\n\n#define DEF_STRING8_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING8(var, tmp, min(tmp.length(), 8), p, d, 0, arr)\n\n#define DEF_STRING8_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING8_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING8_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING8_WITH_VALUE(var, tmp, min(tmp.length(), 8), d, arr)\n\n#define DEF_STRING8(var, tmp, arr) \\\n    DEF_STRING8_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING16\n\n#define _DEF_STRING16(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[5](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                             STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04), \\\n                             STRING_ENCODE_CHARS(tmp, 0x08), STRING_ENCODE_CHARS(tmp, 0x0C));\n\n#define DEF_STRING16_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING16(var, tmp, min(tmp.length(), 16), p, d, 0, arr)\n\n#define DEF_STRING16_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING16_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING16_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING16_WITH_VALUE(var, tmp, min(tmp.length(), 16), d, arr)\n\n#define DEF_STRING16(var, tmp, arr) \\\n    DEF_STRING16_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING32\n\n#define _DEF_STRING32(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[9](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                             STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04), \\\n                             STRING_ENCODE_CHARS(tmp, 0x08), STRING_ENCODE_CHARS(tmp, 0x0C), \\\n                             STRING_ENCODE_CHARS(tmp, 0x10), STRING_ENCODE_CHARS(tmp, 0x14), \\\n                             STRING_ENCODE_CHARS(tmp, 0x18), STRING_ENCODE_CHARS(tmp, 0x1C));\n\n#define DEF_STRING32_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING32(var, tmp, min(tmp.length(), 32), p, d, 0, arr)\n\n#define DEF_STRING32_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING32_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING32_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING32_WITH_VALUE(var, tmp, min(tmp.length(), 32), d, arr)\n\n#define DEF_STRING32(var, tmp, arr) \\\n    DEF_STRING32_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING64\n\n#define _DEF_STRING64(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[17](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                              STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04), \\\n                              STRING_ENCODE_CHARS(tmp, 0x08), STRING_ENCODE_CHARS(tmp, 0x0C), \\\n                              STRING_ENCODE_CHARS(tmp, 0x10), STRING_ENCODE_CHARS(tmp, 0x14), \\\n                              STRING_ENCODE_CHARS(tmp, 0x18), STRING_ENCODE_CHARS(tmp, 0x1C), \\\n                              STRING_ENCODE_CHARS(tmp, 0x20), STRING_ENCODE_CHARS(tmp, 0x24), \\\n                              STRING_ENCODE_CHARS(tmp, 0x28), STRING_ENCODE_CHARS(tmp, 0x2C), \\\n                              STRING_ENCODE_CHARS(tmp, 0x30), STRING_ENCODE_CHARS(tmp, 0x34), \\\n                              STRING_ENCODE_CHARS(tmp, 0x38), STRING_ENCODE_CHARS(tmp, 0x3C));\n\n#define DEF_STRING64_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING64(var, tmp, min(tmp.length(), 64), p, d, 0, arr)\n\n#define DEF_STRING64_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING64_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING64_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING64_WITH_VALUE(var, tmp, min(tmp.length(), 64), d, arr)\n\n#define DEF_STRING64(var, tmp, arr) \\\n    DEF_STRING64_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING functions\n\n#define DEF_TEXT_STRING_WITH_VALUE(N, T) \\\n    int text_length(in int[N] string, in T x){ \\\n        return (string[0] >> 24) + text_length(x, (string[0] >> 8) & 0xFF); \\\n    } \\\n    void text_string(in sampler2D sampler, inout TextState ts, in int[N] string, in T x){ \\\n        int[] header = DECODE_STRING_HEADER(string[0]); \\\n        int s_len = header[0]; \\\n        int x_pos = header[1]; \\\n        int min_digits = header[2]; \\\n        if(x_pos == 0){ \\\n            text_value(sampler, ts, x, min_digits); \\\n            text_string(sampler, ts, string); \\\n        }else if(x_pos == s_len){ \\\n            text_string(sampler, ts, string); \\\n            text_value(sampler, ts, x, min_digits); \\\n        }else{ \\\n            text_substring(sampler, ts, string, 0, x_pos); \\\n            text_value(sampler, ts, x, min_digits); \\\n            text_substring(sampler, ts, string, x_pos, s_len - x_pos); \\\n        } \\\n    }\n\n#define DEF_TEXT_STRING(N) \\\n    int text_length(in int[N] string){ \\\n        return string[0] >> 24; \\\n    } \\\n    void text_substring(in sampler2D sampler, inout TextState ts, in int[N] string, in int offset, in int len){ \\\n        ivec2 index = text_map_to_index(ts.pos, ts.hori_offset, ts.vert_offset, ts.scale); \\\n        if(index.x >= len || index.y >= 1){ \\\n            text_advance_pos(ts.pos, ts.hori_offset, ts.scale, len); \\\n            return; \\\n        } \\\n        if(index.x < 0 || index.y < 0){ \\\n            return; \\\n        } \\\n        int offset_index = index.x + offset; \\\n        int code = DECODE_CHARS(string[(offset_index / 4) + 1])[offset_index % 4]; \\\n        text_advance_pos(ts.pos, ts.hori_offset, ts.scale, index.x); \\\n        text_char_internal(sampler, code, ts.pos, ts.hori_offset, ts.vert_offset, ts.scale, ts.dist); \\\n    } \\\n    void text_string(in sampler2D sampler, inout TextState ts, in int[N] string){ \\\n        int[] header = DECODE_STRING_HEADER(string[0]); \\\n        text_substring(sampler, ts, string, 0, header[0]); \\\n    } \\\n    DEF_TEXT_STRING_WITH_VALUE(N, int) \\\n    DEF_TEXT_STRING_WITH_VALUE(N, uint) \\\n    DEF_TEXT_STRING_WITH_VALUE(N, float)\n\nDEF_TEXT_STRING(3)\nDEF_TEXT_STRING(5)\nDEF_TEXT_STRING(9)\nDEF_TEXT_STRING(17)\n\n#endif // ENABLE_STRING\n","name":"Common","description":"","type":"common"}]}