{"ver":"0.1","info":{"id":"4l2fRW","date":"1515178911","viewed":109,"name":"graydrago_raytracer","username":"graydrago","description":"My first ray tracer =)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* My first raytracer =)\n * \n * TODO\n * - add shadows\n * - add anti-aliasing\n * - add good sky\n * - add good ground\n */\nprecision mediump int;\nprecision mediump float;\nprecision lowp sampler2D;\nprecision lowp samplerCube;\n\nconst float EPS = 0.000001;\nconst vec3 LIGHT_POS = vec3(1000, 1000, 1000);\nconst vec3 LIGHT_COLOR = vec3(1, 1, 1);\nconst float gamma = 2.2;\nvec3 nearest_hit;\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n    \n    \nstruct Plane {\n    vec3 p;\n    vec3 n;\n};\n    \n\nstruct Sphere {\n    vec3 c;\n    float r;\n};\n    \n\nstruct Light {\n    vec3 Ka;\n    vec3 Kd;\n    vec3 Ks;\n};\n    \n\nmat4 look_at(vec3 pos, vec3 target) {\n    vec3 tmp_up = vec3(0, 1, 0);\n    vec3 forward = normalize(pos - target);\n    vec3 right = normalize(cross(tmp_up, forward));\n    vec3 up = normalize(cross(forward, right));\n    return mat4(vec4(right, 0.0), vec4(up, 0.0), vec4(forward, 0.0), vec4(pos, 1.0));\n}\n\nmat3 normal_matrix(mat4 eye) {\n    mat3 normal_m = mat3(eye);\n    normal_m = inverse(normal_m);\n    normal_m = transpose(normal_m);\n    return normal_m;\n}\n\nbool quadratic(float a, float b, float c, out float x0, out float x1) {\n    float d = b*b - 4.0 * a * c;\n    if (d < 0.0) return false;\n    if (d >= 0.0 && d < EPS) {\n        x0 = x1 = -b / (2.0 * a);\n    } else {\n        float den = 2.0 * a;\n        x0 = (-b + sqrt(d)) / den;\n        x1 = (-b - sqrt(d)) / den;\n    }\n    return true;\n}\n    \n    \nbool hit_ray_plane(Ray r, Plane p, out vec3 hit) {\n    float denom = dot(p.n, r.d);\n    if (abs(denom) > EPS) {\n        float t = dot(p.p - r.o, p.n) / denom;\n        if (t >= EPS) {\n            hit = r.o + r.d * t;\n            return true;\n        }\n    }\n    return false;\n}\n\n\nbool hit_ray_plane(Ray r, Plane p) {\n    vec3 hit;\n    return hit_ray_plane(r, p, hit);\n}\n\n\nbool hit_sphere(Ray r, Sphere s, out vec3 hit, out vec3 n) {\n    vec3 L = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(r.d, L);\n    float c = dot(L, L) - s.r * s.r;\n    float t0;\n    float t1;\n    if (quadratic(a, b, c, t0, t1)) {\n        if (t1 < t0) t0 = t1;\n        \n        if (t0 > 0.0) {\n            hit = r.o + t0 * r.d;\n            n = normalize(hit - s.c);\n            return true;\n        }\n    }\n    return false;\n}\n\n\nvec3 ads_lighting(Light l, Ray r, vec3 hit, vec3 normal) {\n\tfloat d = max(dot(normalize(LIGHT_POS - hit), normal), 0.0);\n\tfloat s = 0.0;\n\tif (d > 0.0) {\n\t\tvec3 refl = reflect(normalize(LIGHT_POS - hit), normal);\n\t\ts = pow(max(dot(refl, normalize(hit - r.o)), 0.0), 32.0);\n\t}\n\treturn l.Ka + d*l.Kd + s*l.Ks;\n}\n\n\nvoid save_nearest_hit(Ray r, vec3 hit) {\n    if (distance(r.o, hit) < distance(r.o, nearest_hit)) {\n        nearest_hit = hit;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init\n    // I should add relative coordinates support, but I like absolute coordinates for this scene.\n    const float cam_speed = 100.0;\n    float cam_offset = iTime * cam_speed;\n    float screen_x = fragCoord.x - iResolution.x * 0.5;\n    float screen_y = fragCoord.y - iResolution.y * 0.5;\n    vec3 ray_o = vec3(0, 300, -700);\n    vec3 ray_d = normalize(vec3(screen_x, screen_y + 250.0, 0) - ray_o);\n    mat4 eye = look_at(vec3(cos(iTime * 0.2), 0.0, sin(iTime * 0.2)), vec3(0.0, 0.0, 0.0));\n    mat3 normal_m = normal_matrix(eye);\n    \n    // Ray\n    Ray r = Ray(ray_o, ray_d);\n    r.o = vec3(eye * vec4(r.o, 1.0));\n    r.d = normalize(normal_m * r.d);\n    \n    // Ground\n    Plane p = Plane(vec3(0, 0, 0), normalize(vec3(0, 1, 0)));\n    vec2 t_size = vec2(textureSize(iChannel0, 0));\n    vec3 hit;\n    if (hit_ray_plane(r, p, hit)) {\n        save_nearest_hit(r, hit);\n        fragColor = vec4(pow(\n            texture(\n            \tiChannel0,\n            \tvec2(hit.x/float(t_size.x), hit.z/float(t_size.y))\n        \t).rgb,\n        \tvec3(gamma)\n        ), 1.0);\n    }\n    \n    // Sky\n    p = Plane(vec3(0, 1000, 0), normalize(vec3(0, -1, 0)));\n    t_size = vec2(textureSize(iChannel1, 0));\n    if (hit_ray_plane(r, p, hit)) {\n\t\tsave_nearest_hit(r, hit);\n        fragColor = vec4(pow(\n            texture(\n                iChannel1,\n                vec2(hit.x/(t_size.x*500.0), hit.z/(t_size.y*500.0))\n            ).rgb,\n            vec3(gamma)\n        ), 1.0);\n        fragColor = vec4(fragColor.xxx + 1.0, 1.0) * vec4(0.5, 0.5, 1, 1);\n    }\n    \n    // Spheres\n    Sphere s;\n    vec3 normal;\n    float dist = 2000.0;\n    Light l = Light(\n\t\tvec3(0.01, 0.0, 0.0),\n\t\tvec3(0.7, 0.0, 0.0),\n\t\tvec3(1.0, 1.0, 1.0)\n    );\n    for (int i = -2; i <= 2; i++) {\n\t\tfor (int j = -2; j <= 2; j++) {\n        \ts = Sphere(vec3(float(i) * 250.0, 250.0, float(j) * 250.0), 40.0);\n    \t\tif (hit_sphere(r, s, hit, normal)) {\n            \tfloat tmp_dist = distance(r.o, hit);\n            \tif (tmp_dist > dist) continue;\n            \tdist = tmp_dist;\n        \t\tfragColor = vec4(ads_lighting(l, r, hit, normal) , 1);\n\t\t\t\tsave_nearest_hit(r, hit);\n    \t\t}\n    \t}\n    }\n    \n    // Fog (a try to implement aerial perspective)\n    //if (fragCoord.x > iResolution.x/2.0) {\n    \tfloat fog_factor = (900.0 - distance(nearest_hit, r.o)) / 200.0;\n    \tfog_factor = clamp(fog_factor, 0.0, 1.0);\n        vec3 color = mix(vec3(0.2, 0.2, 0.3), fragColor.rgb, fog_factor);\n    \tfragColor = vec4(pow(color, vec3(1.0/gamma)), 1.0);\n    //}\n}","name":"Image","description":"","type":"image"}]}