{"ver":"0.1","info":{"id":"4tGXWd","date":"1486354354","viewed":978,"name":"The Mandelgrim","username":"marciot","description":"Combined a Mandelbulb shader with Inigo Quilez's eye tutorial to make a creepy monster. Someday I'll have to make a game based on this! :)","likes":45,"published":1,"flags":1,"usePreview":0,"tags":["procedural","3d","fractal","interactive","mandelbulb","eye","character","vr","creepy","nightmare","bloodshot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADER_TOY\n\n#ifdef SHADER_TOY\n#define CAMERA_Z 2.5\nconst vec3 cameraStart       = vec3(0.0,  0.7, -CAMERA_Z);\nconst vec3 cameraLookat      = vec3(0.0,  0.0, 0.0);\nconst vec3 lightDir          = vec3(2.0,  2.4, -1.0);\nconst vec3 lightColour       = vec3(1.6,  1.8,  2.2);\nconst float specular         = 64.0;\nconst float specularHardness = 512.0;\nconst vec3  diffuse          = vec3(0.25, 0.25, 0.25);\nconst float ambientFactor    = 0.65;\nconst bool ao                = true;\nconst bool shadows           = true;\nconst bool rotateWorld       = true;\nconst bool antialias         = false;\nconst float distanceMin      = 0.003;\n#else\nuniform vec2 iResolution;\nuniform float iTime;\nuniform vec3 cameraPos;\nuniform vec3 cameraLookat;\nuniform vec3 lightDir;\nuniform vec3 lightColour;\nuniform float specular;\nuniform float specularHardness;\nuniform vec3 diffuse;\nuniform float ambientFactor;\nuniform bool ao;\nuniform bool shadows;\nuniform bool rotateWorld;\nuniform bool antialias;\nuniform float distanceMin;\n#endif\n\n/* ****************** Eyeball Texture *********************** */\n\n// Based on tutorial by Inigo Quilez:\n//  https://www.youtube.com/watch?v=emjuqqyq_qc\n\n//alternative noise implementation\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nmat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\nfloat fbm(in vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise(p); p*=m*2.02;\n    f += 0.2500*noise(p); p*=m*2.03;\n    f += 0.1250*noise(p); p*=m*2.01;\n    f += 0.0625*noise(p); p*=m*2.04;\n    f /= 0.9375;\n    return f;\n}\n\nvec3 EyeUVMap( in vec2 uv )\n{\n    float pi            = 3.1415;\n    float irisCoverage  = 0.20;\n    \n    float r = uv.y*1.0/irisCoverage;\n    float a = uv.x * pi * 2.0;\n    vec2 p = vec2(r*cos(a), r*sin(a));\n\n    //change this to whatever you want the background\n    //color to be\n    vec3 bg_col = vec3(1.0);\n\n    vec3 col = bg_col;\n\n    //float ss = 0.5 + 0.25*sin(iTime);\n    float ss = 0.75;\n    float anim = 1.0 + 0.5*ss*clamp(1.0-r, 0.0, 1.0);\n    r *= anim;\n\n    if (r < 0.8) {\n        // Outer iris, color variation\n        col = vec3(0.0, 0.3, 0.4);\n\n        float f = fbm(5.0*p);\n        col = mix(col, vec3(0.2, 0.5, 0.4), f);\n\n        // Central iris\n        f = 1.0 - smoothstep(0.2, 0.5, r);\n        col = mix(col, vec3(0.9, 0.6, 0.2), f);\n\n        a += 0.05*fbm(20.0*p);\n\n        // Iris, white striations\n        f = smoothstep(0.3, 1.0, fbm(vec2((6.0+ss*0.25)*r, 20.0*a)));\n        col = mix(col, vec3(1.0), f);\n\n        // Iris, black striations\n        f = smoothstep(0.4, 0.9, fbm(vec2(10.0*r, 15.0*a)));\n        col *= 1.0 - 0.5*f;\n\n        // Iris, outer shadow\n        f = smoothstep(0.6, 0.8, r);\n        col *= 1.0 - 0.5*f;\n\n        // Pupil\n        f = smoothstep(0.2, 0.25, r);\n        col *= f;\n\n        // Blend iris into sclera\n        f = smoothstep(0.75, 0.8, r);\n        col = mix(col, bg_col, f);\n    } else {\n        // Veins\n        a += 0.15*fbm(10.0*p);\n        \n        float f = smoothstep(0.35, 1.0, fbm(vec2(0.5*r, 30.0*a)));\n        col -= vec3(0.0,1.0,1.0) * (1.0 - uv.y) * f;\n    }\n\n    return col;\n}\n\n/* ****************** Mandelbulb Scene *********************** */\n\n// Source code adapted from:\n// https://github.com/kevinroast/webglshaders/blob/master/mandelbulb.html\n\n#define AO_SAMPLES 5\n#define RAY_DEPTH 256\n#define MAX_DEPTH 20.0\n#define PI 3.14159265\n\n#define FLOOR_YPOS -2.0\n#define EYE_ZPOS   -0.82\n\nvec2 delta = vec2(distanceMin, 0.);\n\nvec3 RotateY(vec3 p, float a)\n{\n    float c,s;\n    vec3 q=p;\n    c = cos(a);\n    s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n    return p;\n}\n\nvec3 RotateX(vec3 p, float a) {\n    return RotateY(p.yxz, a).yxz;\n}\n\n#ifdef SHADER_TOY\nfloat FlatPeakFunc(float t) {\n    // http://math.stackexchange.com/questions/100655/cosine-esque-function-with-flat-peaks-and-valleys\n    return sin(0.5*PI*cos(t));\n    /* Alternative:\n        const float b = 2.;\n        return sqrt((1.+b*b)/(1.+pow(b*cos(t),2.)))*cos(t);\n     */    \n}\n\nfloat CameraOrbitAngle() {\n    return PI - FlatPeakFunc(iTime*0.5) * PI * 1.1;\n}\n\nvec3 CameraOrbit() {\n    vec3 pos = cameraStart - cameraLookat;\n    if (rotateWorld) pos = RotateY(pos, CameraOrbitAngle());\n    return pos + cameraLookat;\n}\n\nvec3 CameraInvariant(vec3 pos) {\n    if (rotateWorld) pos = RotateY(pos, -CameraOrbitAngle());\n    return pos;\n}\n#endif\n\nfloat Plane(vec3 p, vec3 n)\n{\n   return dot(p, n);\n}\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Added by marciot, to render an eye.\nfloat EyeBall(vec3 p) {\n    return Sphere(p-vec3(0.,0.,EYE_ZPOS), 0.37);\n}\n\n// Formula for original MandelBulb from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat MandelBulb(vec3 pos, const int limitIterations)\n{\n    const int Iterations = 12;\n    const float Bailout = 8.0;\n    //float Power = 5.0 + cos(iTime*0.0125)*4.0;\n    //float Power = 5.0 + sin(0.5)*4.0;\n    float Power = 9.0;\n\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < Iterations; i++)\n    {\n        r = length(z);\n        if (r > Bailout || i == limitIterations) break;   // TODO: test if better to continue loop and if() rather than break?\n\n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr = pow(r, Power-1.0)*Power*dr + 1.0;\n\n        // scale and rotate the point\n        float zr = pow(r,Power);\n        theta = theta*Power;\n        phi = phi*Power;\n\n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z += pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nfloat MandelBulb(vec3 pos) {\n    return MandelBulb(pos, 12);\n}\n\n// This should return continuous positive values when outside and negative values inside,\n// which roughly indicate the distance of the nearest surface.\nfloat Dist(vec3 pos)\n{\n    return min(\n        // Floor is at y=-2.0\n        min(\n            Plane(pos-vec3(0.,FLOOR_YPOS,0.), vec3(0.,1.,0.)),\n            MandelBulb(pos)\n        ),\n        EyeBall(pos)\n    );\n}\n\n// Based on original by IQ - optimized to remove a divide\nfloat CalcAO(vec3 p, vec3 n)\n{\n    float r = 0.0;\n    float w = 1.0;\n    for (int i=1; i<=AO_SAMPLES; i++)\n    {\n        float d0 = float(i) * 0.3;\n        r += w * (d0 - Dist(p + n * d0));\n        w *= 0.5;\n    }\n    return 1.0 - clamp(r,0.0,1.0);\n}\n\n// Based on original code by IQ\nfloat SelfShadow(vec3 ro, vec3 rd)\n{\n    float k = 32.0;\n    float res = 1.0;\n    float t = 0.1;          // min-t see https://iquilezles.org/articles/rmshadows\n    for (int i=0; i<16; i++)\n    {\n        float h = Dist(ro + rd * t);\n        res = min(res, k*h/t);\n        t += h;\n        if (t > 4.0) break; // max-t\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat SoftShadow(vec3 ro, vec3 rd)\n{\n    float k = 16.0;\n    float res = 1.0;\n    float t = 0.1;          // min-t see https://iquilezles.org/articles/rmshadows\n    for (int i=0; i<48; i++)\n    {\n        float h = Dist(ro + rd * t);\n        res = min(res, k*h/t);\n        t += h;\n        if (t > 8.0) break; // max-t\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 GetNormal(vec3 pos)\n{\n    if (pos.y < FLOOR_YPOS + distanceMin)\n    {\n        return vec3(0.0,1.0,0.0);\n    }\n    else\n    {\n        vec3 n;\n        n.x = Dist( pos + delta.xyy ) - Dist( pos - delta.xyy );\n        n.y = Dist( pos + delta.yxy ) - Dist( pos - delta.yxy );\n        n.z = Dist( pos + delta.yyx ) - Dist( pos - delta.yyx );\n\n        return normalize(n);\n    }\n}\n\n// Added by marciot, for creepy eye\nvec3 EyeBallColor(vec3 p) {\n    vec3 eyeCenter = vec3(0.,0.,EYE_ZPOS);\n    vec3 p0 = p-eyeCenter;\n\n#ifdef SHADER_TOY\n    // TODO: This is kind of spaghetti code, probably better way to do this\n    const float eyeRollMax = PI/4.;\n    vec3 mouseVector = vec3(\n        (iMouse.x/iResolution.x - 0.5) * 2.,\n        (iMouse.y/iResolution.y - 0.5) * 2.,\n        CAMERA_Z\n    );\n    mouseVector = CameraInvariant(mouseVector);\n    vec3  cameraPointDir = cameraLookat - cameraStart;\n    float cameraElevation = atan(cameraPointDir.y/cameraPointDir.z);\n    float eyeRollLateral  = atan(mouseVector.x/mouseVector.z);\n    float eyeRollVertical = atan(mouseVector.y/mouseVector.z)-cameraElevation;\n    p0 = RotateY(p0, clamp(eyeRollLateral, -eyeRollMax, eyeRollMax));\n    p0 = RotateX(p0, clamp(eyeRollVertical,-eyeRollMax, eyeRollMax));\n#endif\n    vec2 uv = vec2(\n        atan(p0.y,p0.x)/(2.*PI), \n        acos(-p0.z/length(p0))/PI\n    );\n    return EyeUVMap(uv);\n}\n\n// Added by marciot, colorize the mandelbulb.\nvec3 MandelBulbColor(vec3 pos) {\n    float d1  = MandelBulb(pos, 1);\n    float d6  = MandelBulb(pos, 6);\n    float d9  = MandelBulb(pos, 9);\n    float g = clamp( 0.5  + abs((d6-d1)*50.) ,0.,1.);\n    float b = clamp( 0.25 + abs((d9-d1)*25.) ,0.,5.);\n    return vec3(1., g, b);\n}\n\n// Based on a shading method by Ben Weston. Added AO and SoftShadows to original.\nconst vec3 sssColour = vec3(0.5,0.5,1.0);\nvec4 Shading(vec3 pos, vec3 rd, vec3 norm)\n{\n    vec3 light;\n    bool isEye   = EyeBall(pos) < distanceMin;\n    bool isFloor = pos.y < FLOOR_YPOS+distanceMin;\n    bool isBulb  = !isEye && !isFloor;\n\n    // simple pos test on pos.y for floor (see Dist() above) - different colour and no spec for floor\n    if(isFloor) {\n        light = vec3(0.1,0.66,0.2) * max(0.0, dot(norm, lightDir));\n        if (shadows) light *= SoftShadow(pos, lightDir);   // softer edged shadows on floor\n        if (ao) light += CalcAO(pos, norm) * max(ambientFactor-0.25, 0.0);\n    }\n    else\n    {\n        light = lightColour * max(0.0, dot(norm, lightDir));\n        vec3 heading = normalize(-rd + lightDir);\n        float spec = pow(max(0.0, dot(heading, norm)), specularHardness);\n        light = (diffuse * light) + (spec * specular * lightColour);\n        if (shadows) light *= SelfShadow(pos, lightDir);   // harder edged shadows on object\n        if (ao) light += CalcAO(pos, norm) * ambientFactor;\n    }\n\n    if(isBulb) light     *= MandelBulbColor(pos);\n    if(isEye)  light.rgb *= EyeBallColor(pos);\n    \n    return vec4(light, 1.0);\n}\n\n// Original method by David Hoskins\nvec3 Sky(in vec3 rd)\n{\n    rd = CameraInvariant(rd);\n    float sunAmount = max(dot(rd, lightDir), 0.0);\n    float v = pow(1.0 - max(rd.y,0.0),6.);\n    vec3 sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n    sky += lightColour * sunAmount * sunAmount * .25 + lightColour * min(pow(sunAmount, 800.0)*1.5, .3);\n\n    return clamp(sky, 0.0, 1.0);\n}\n\n// Camera function by TekF\n// Compute ray from camera parameters\nvec3 GetRay(vec3 dir, vec2 pos)\n{\n    pos = pos - 0.5;\n    pos.x *= iResolution.x/iResolution.y;\n\n    dir = normalize(dir);\n    vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n    vec3 up = normalize(cross(dir,right));\n\n    return dir + right*pos.x + up*pos.y;\n}\n\nvec4 March(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i=0; i<RAY_DEPTH; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = Dist(p);\n        if (abs(d) < distanceMin)\n        {\n            return vec4(p, 1.0);\n        }\n        t += d;\n        if (t >= MAX_DEPTH) break;\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int ANTIALIAS_SAMPLES = 4;\n    const int DOF_SAMPLES = 16;\n\n    const bool dof = false;\n\n    vec4 res = vec4(0.0);\n    \n#ifdef SHADER_TOY\n    vec3 cameraPos = CameraOrbit();\n#endif\n\n    if (antialias)\n    {\n        vec2 p;\n        float d_ang = 2.*PI / float(ANTIALIAS_SAMPLES);\n        float ang = d_ang * 0.33333;\n        float r = 0.3;\n        for (int i = 0; i < ANTIALIAS_SAMPLES; i++)\n        {\n            p = vec2((fragCoord.x + cos(ang)*r) / iResolution.x, (fragCoord.y + sin(ang)*r) / iResolution.y);\n            vec3 ro = cameraPos;\n            vec3 rd = normalize(GetRay(cameraLookat-cameraPos, p));\n            vec4 _res = March(ro, rd);\n            if (_res.a == 1.0) res.xyz += clamp(Shading(_res.xyz, rd, GetNormal(_res.xyz)).xyz, 0.0, 1.0);\n            else res.xyz += Sky(rd);\n            ang += d_ang;\n        }\n        res.xyz /= float(ANTIALIAS_SAMPLES);\n    }\n    else if (dof)\n    {\n        vec2 p = fragCoord.xy / iResolution.xy;\n        vec3 ro = cameraPos;\n        vec3 rd = normalize(GetRay(cameraLookat-cameraPos, p));\n        vec4 _res = March(ro, rd);\n\n        float d_ang = 2.*PI / float(DOF_SAMPLES);\n        float ang = d_ang * 0.33333;\n        // cheap DOF! - offset by camera zdiff (as cam/lookat are quite far apart)\n        float r = max(0.3, abs(cameraLookat.z - _res.z + 0.0) * .2);\n        for (int i = 0; i < DOF_SAMPLES; i++)\n        {\n            p = vec2((fragCoord.x + cos(ang)*r) / iResolution.x, (fragCoord.y + sin(ang)*r) / iResolution.y);\n            ro = cameraPos;\n            rd = normalize(GetRay(cameraLookat-cameraPos, p));\n            _res = March(ro, rd);\n            if (_res.a == 1.0) res.xyz += clamp(Shading(_res.xyz, rd, GetNormal(_res.xyz)).xyz, 0.0, 1.0);\n            else res.xyz += Sky(rd);\n            ang += d_ang;\n        }\n        res.xyz /= float(DOF_SAMPLES);\n    }\n    else\n    {\n        vec2 p = fragCoord.xy / iResolution.xy;\n        vec3 ro = cameraPos;\n        vec3 rd = normalize(GetRay(cameraLookat-cameraPos, p));\n        vec4 intersect = March(ro, rd);\n        if (intersect.a == 1.0) {\n            res.xyz = clamp(Shading(intersect.xyz, rd, GetNormal(intersect.xyz)).xyz, 0.0, 1.0);\n        } else {\n            res.xyz = Sky(rd);\n        }\n    }\n\n    fragColor = vec4(res.rgb, 1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(0.0);\n    \n    ro += vec3(0., 0., -.5);\n    \n    float scale = 0.15;\n    ro /= scale;\n    \n    vec4 intersect = March(ro, rd);\n    if (intersect.a == 1.0) {\n        res.xyz = clamp(Shading(intersect.xyz, rd, GetNormal(intersect.xyz)).xyz, 0.0, 1.0);\n    } else {\n        res.xyz = Sky(rd);\n    }\n    fragColor = vec4(res.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}