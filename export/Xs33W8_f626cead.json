{"ver":"0.1","info":{"id":"Xs33W8","date":"1449167433","viewed":310,"name":"C64 raster bar glitching","username":"104","description":"More C64 simulations. I swear all this has some kind of purpose.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["c64","rasterbars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\n\nSimulation of a glitchy C64 raster-based palette cycler. The simulated algorithm\ndoesn't care about raster sync, so color changes happen mid-scanline, causing\nglitches. Since there is no sync correllation at all, the ideal simulation would\nassign random length to each color change throughout the whole screen's scan trip.\n\nBut that's impractical to compute for every pixel, so I just have a fixed-width\nper color change, and perturb the last one (current one).\n\nProblem with this method is that you must enough glitch to hide the evenness\nof the spans. To see this problem, #define SHOW_WEAKNESS and see\nhow even artifacting is.\n*/\n\n//#define SHOW_WEAKNESS\n\n\n#ifdef SHOW_WEAKNESS\nconst float pixelSize = 2.;\nconst float idealColorChangeWidth = .99;// % of scan width\nconst float animatedPerturbanceAmt = 0.0;// % of scan width\nconst float fixedPerturbanceAmt = 0.0;// % of scan width\n\nconst float animationSpeed = 0.;\n#else\n\n\n\nconst float pixelSize = 2.;\nconst float idealColorChangeWidth = .82;// % of scan width\nconst float animatedPerturbanceAmt = 0.04;// % of scan width\nconst float fixedPerturbanceAmt = 0.04;// % of scan width\n\nconst float animationSpeed = 15.0;\n#endif\n\n\n//----------------------------------------------------------------------\n// c64 palette\nvec3 color0 = vec3(0,0,0);// black\nvec3 color1 = vec3(1,1,1);// white\nvec3 color2 = vec3(0.41,0.22,0.17);// red\nvec3 color3 = vec3(0.44,0.64,0.70);// cyan\nvec3 color4 = vec3(0.44,0.24,0.53);// violet\nvec3 color5 = vec3(0.35,0.55,0.26);// green\nvec3 color6 = vec3(0.21,0.16,0.47);// blue\nvec3 color7 = vec3(0.72,0.78,0.44);// yellow\nvec3 color8 = vec3(0.44,0.31,0.15);// orange\nvec3 color9 = vec3(0.26,0.22,0);// brown\nvec3 colorA = vec3(0.60,0.40,0.35);// light red\nvec3 colorB = vec3(0.27,0.27,0.27);// grey1\nvec3 colorC = vec3(0.42,0.42,0.42);// grey2\nvec3 colorD = vec3(0.60,0.82,0.52);// light green\nvec3 colorE = vec3(0.42,0.37,0.71);// light blue\nvec3 colorF = vec3(0.58,0.58,0.58);// grey3\n\nfloat quantize(float x, float s) { return floor(x/s)*s; }\nvec2 quantize(vec2 x, float s) { return floor(x/s)*s; }\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec3 tenfourGradient(float x)\n{\n\tconst float colCount = 16.;\n    x = floor(fract(x) * colCount);\n    float i = 0.;\n    if(x == i++) return color0;// black\n    if(x == i++) return colorB;// grey1\n    if(x == i++) return colorC;// grey2\n    if(x == i++) return colorF;// grey3\n    if(x == i++) return color1;// white\n\n    if(x == i++) return color7;// yellow\n    if(x == i++) return colorD;// light green\n    if(x == i++) return color3;// cyan\n    if(x == i++) return color5;// green\n\n    if(x == i++) return colorE;// light blue\n    if(x == i++) return color4;// violet\n    if(x == i++) return color6;// blue\n\n    if(x == i++) return color9;// brown\n    if(x == i++) return color2;// red\n    if(x == i++) return color8;// orange\n    if(x == i++) return colorA;// light red\n    return vec3(0);\n}\n\nvec3 dumbGradient(float x)\n{\n\tconst float colCount = 16.;\n    x = floor(fract(x) * colCount);\n    float i = 0.;\n    if(x == i++) return color0;// black\n    if(x == i++) return color1;// white\n    if(x == i++) return color2;// red\n    if(x == i++) return color3;// cyan\n    if(x == i++) return color4;// violet\n    if(x == i++) return color5;// green\n    if(x == i++) return color6;// blue\n    if(x == i++) return color7;// yellow\n    if(x == i++) return color8;// orange\n    if(x == i++) return color9;// brown\n    if(x == i++) return colorA;// light red\n    if(x == i++) return colorB;// grey1\n    if(x == i++) return colorC;// grey2\n    if(x == i++) return colorD;// light green\n    if(x == i++) return colorE;// light blue\n    if(x == i++) return colorF;// grey3\n    return vec3(0);\n}\n\nvec3 greenBlueGradient(float x)\n{\n\tconst float colCount = 19.;\n    x = floor(fract(x) * colCount);\n    float i = 0.;\n    \n    if(x == i++) return color0;// black\n    if(x == i++) return colorB;// grey1\n    if(x == i++) return colorC;// grey2\n    if(x == i++) return colorF;// grey3\n    if(x == i++) return color1;// white\n\n    if(x == i++) return colorD;// light green\n    if(x == i++) return color5;// green\n    if(x == i++) return colorD;// light green\n    if(x == i++) return color1;// white\n\n    if(x == i++) return color3;// cyan\n    if(x == i++) return colorE;// light blue\n    if(x == i++) return color4;// violet\n    if(x == i++) return color6;// blue\n\n    if(x == i++) return color4;// violet\n    if(x == i++) return colorE;// light blue\n    if(x == i++) return color3;// cyan\n\n    if(x == i++) return color1;// white\n    if(x == i++) return colorF;// grey3\n    if(x == i++) return colorC;// grey2\n    if(x == i++) return colorB;// grey1\n    return vec3(0);\n}\n\n//----------------------------------------------------------------------\n\nvoid mainImage( out vec4 o, in vec2 i)\n{\n    vec2 pVirt = floor(i / pixelSize);// pixel coords in simulated screen space.\n    vec2 virtRes = floor(iResolution.xy / pixelSize);\n    vec2 uv = pVirt / virtRes;\n\n    float linPixel = pVirt.x + (pVirt.y * virtRes.x);\n    float bandWidth = virtRes.x * idealColorChangeWidth;// with no glitches, color bands span X% of the screen.\n    linPixel -= (hash(pVirt.y)*2.-1.)*virtRes.x*fixedPerturbanceAmt;// perturb by Y up to X% of screen width\n    linPixel -= (hash(iDate.w)*2.-1.)*virtRes.x*animatedPerturbanceAmt;// perturb by time up to X% of screen width\n    linPixel += virtRes.x *floor(iTime*animationSpeed);// animate by shifting whole scan lines\n    float band = linPixel / bandWidth;\n\n    \n    // select which gradient to show\n    if(mod(iTime, 3.) < 2.)\n    {\n        float p = fract(band / 100.);\n        if(p < 0.5)\n            o = vec4(tenfourGradient(band/16.),1.);\n        else\n            o = vec4(greenBlueGradient(band/19.),1.);\n    }\n    else\n    {\n    \to = vec4(dumbGradient(band/16.),1.);\n    }\n\n\t// C-64 background color.\n    if(iMouse.z < 0.1)\n    {\n    \tif(uv.y < .9 && uv.y > 0.1 && uv.x > 0.1 && uv.x < 0.9)\n        \to.rgb = colorE;\n    }\n\n    // post\n\tvec2 uvn = i/iResolution.xy-.5;\n    o.rgb *= 1.1;\n    o.rgb = clamp(o.rgb,0.,1.);\n    o.rgb *= 1.-dot(uvn*1.2,uvn*1.2);\n    //o.rgb = clamp(o.rgb,0.,1.);\n}\n\n\n","name":"","description":"","type":"image"}]}