{"ver":"0.1","info":{"id":"7lKcDK","date":"1663355257","viewed":219,"name":"3d Circuit","username":"kastorp","description":".","likes":31,"published":1,"flags":32,"usePreview":0,"tags":["voxel","circuit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//3d Circuit by Kastorp\n//-------------------------\n\n//#define CAPSULE\n#define GLASS\n#define BALLSZ .04\n#define AO\n\nvoid getDirs(int i, int j, out vec3 n, out  vec3 dr){    \n     n=vec3(1,0,0)*((i%2)>0?1.:-1.);\n    if(i>3)n=n.yzx;\n    else if(i>1) n=n.zxy;\n     dr= n.yzx;\n    if(j>1) dr=cross(n,dr);\n    if((j%2)>0) dr*=-1.;\n}\n\nfloat corner(vec3 v) {return length(max(vec3(v.x,v.y,v.z),0.0))+min(max(v.x,max(v.y,v.z)),0.0);}\nfloat capsule(vec3 p,vec3 a,vec3 b) { return distance(p, mix(a, b, clamp(dot(p - a, normalize(b - a)) / length(b - a), 0., 1.)));}\nfloat torus( vec3 p, vec2 t ) { return length(vec2(length(p.xz)-t.x,p.y))-t.y; }\nfloat qtorus( vec3 p, vec2 t ) { return max(torus(p+vec3(t.x,0,t.x),t), corner(-p-vec3(t.x))); }\nfloat sdBox(vec3 p, vec3 s) {return corner(abs(p)-s);}\n\nvoid connector(inout vec3 d,vec3 p, vec3 face, vec3 dir,float ts,bool cor,bool str, bool intCor){\n    vec3 cro=cross(dir,face);\n    float sz= (cor?0.:str?0.07:0.14);\n    float pos=(!cor && intCor)? .43:0.;\n    \n#ifndef CAPSULE  \n    \n    vec3 v=abs(p- face*.43 -dir*(.21+sz+pos))-abs(face)*.05-abs(dir)*(.26+sz) - abs(cro)*.05;\n    d.x=min(d.x,corner(v));\n#else\n    d.x= min(d.x, capsule(p,face*(.43)+dir*pos,(face*.43+dir *(.43+sz)))-.05);  \n#endif\n    float t=fract(iTime*sign(ts-.5));// (abs(fract(iTime+ts*.5)-.5)*2.;\n    vec3 bp=face*.43+dir*(t*(.43+sz));\n    if(intCor) bp= (face + dir)*.43 + dir*0.57*(1.-t);\n    d.y=min(d.y,length(p-bp)-BALLSZ );\n}\n\nstruct Hit{\n    float d;\n    float obj;\n    vec3 c;\n};\n\nivec2 bm;\nivec4 bma;\nvec3 mp;\n\nHit GetDist(vec3 pp,int type) {\n\n    vec3 d=vec3(1000.); //x=glass y=ball z=solid\n    \n    float obj=-0.;\n    vec3 c=  vec3(0);\n     vec3 n,dr;\n     \n     // optimization, calculate once per voxel\n     vec3 mp_=floor(pp.xyz+.5);\n     if(dot(mp_-mp,mp_-mp)>0.) {\n         mp=mp_;\n         \n        if(  max(max(abs(mp.x),abs(mp.y)),abs(mp.z))>=3.) {\n             bm =ivec2(-1);bma =ivec4(0);\n        }\n        else{\n            int id=int(mp.z)*25-int(mp.y)*5+int(mp.x)+62;\n            bm=  floatBitsToInt(texelFetch(iChannel0,ivec2(id,0),0)).xy;\n            bma= floatBitsToInt(texelFetch(iChannel0,ivec2(id,1),0));\n       }\n     }\n  \n    // circuit & balls       \n     if(bm.x!=-1){\n         vec3 p=fract(pp.xyz+.5)-.5;\n         for(int i=0;i<6;i++){\n            getDirs(i,0,n,dr);            \n            // face culling           \n            if( dot(sign(p),n)<.5) continue;\n            for(int j=0;j<4;j++)\n            {\n                int m=(1<<(i*4+j));\n                bool isEdge=  (bm.x & m)>0 ;                \n                bool isIntCorner = ( bma.w & m)>0;\n                if(isEdge || isIntCorner){\n                    getDirs(i,j,n,dr);\n                    \n                    bool isCorner = ( bma.x & m)>0;\n                    bool Balldir=  (bma.y & m)>0 ;\n                    bool isStraight = ( bma.z & m)>0;\n                    connector(d,p,n,dr,Balldir?0.:1.,isCorner,isStraight,isIntCorner);\n                }\n            }\n        }\n\n       //external cube\n       d.z=min(d.z, sdBox(p,vec3(.48))-.0199);\n       d.z=max(d.z,-d.x+.05); //subtract circuit\n       \n       \n#ifndef GLASS       \n       d.x=1000.;\n#else\n       d.x= abs(d.x-.01)-.01; //empty circuit\n#endif\n     if(type!=0) d.x=1000.; \n       \n        //combine solid\n        if(d.z<d.x)  {\n            obj=1.;\n            c=  vec3(0.6,0.5,0.5);\n            vec3 ap=abs(p);\n            if(max(ap.z,max(ap.x,ap.y))<.49) {\n                obj=1.;c=vec3(1.000,0.9,0.1);\n            }\n            /*\n            else{\n               vec3 m= step(ap.zxy,ap)*step(ap.yzx,ap);//*sign(p);\n               if(m.y>.5) c=vec3(0,.5,0);\n               else if(m.z>.5) c=vec3(0,0,.5);\n            }*/\n        }\n        d.x=min(d.z,d.x);\n\n        //combine balls\n        if(d.y<d.x) {obj=1.;c=vec3(0.7,0.000,0.000);}\n        d.x=min(d.y,d.x);\n    } \n    else{\n        vec3 p=fract(pp.xyz+.5)-.5;\n        for(int i=0;i<6;i++){\n           \n            if(type==2  && (bma.x & (1<<(i+24)))>0\n            ){\n                 getDirs(i,0,n,dr);\n                d.z= min(d.z,.501 - dot(p,n));\n            }\n\n       }\n       if(d.z<d.x)  {\n            obj=1.;\n            d.x=d.z;\n       }\n    }    \n    \n    //plane\n    float pl=pp.y+3.;\n    if(pl<d.x) obj=2.;    \n    d.x=min(d.x,pl);    \n    \n    return Hit(d.x,obj,c);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nHit RayMarch(vec3 ro, vec3 rd,float direction,bool sh) {\n\tfloat dO=0.;\n    float obj=0.;\n    vec3 col;\n    for(int i=0; i<150; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec3 mp =floor(p+.5);\n         Hit h=Hit(.5,0.,vec3(0.));\n       \n        h=GetDist(p,sh?1:0);\n        obj=h.obj;\n        col=h.c;\n        \n        //voxel traversal as limit\n        //if(  max(max(abs(mp.x),abs(mp.y)),abs(mp.z))<10.){\n            vec3 sd = -1./rd*(p-mp) + abs(1./rd)*.5;\n            float t=min( min( sd.x, sd.y ), sd.z )+0.0001;\n            if(t<h.d) obj=2.;\n            h.d=min(t,h.d);\n        //}\n        float dS = h.d*direction;\n        dO += dS;\n        if(dO>12. || abs(dS)<.0001) break;\n    }    \n    return Hit(dO,obj,col);\n}\n\nvec3 GetNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    vec3 e =vec3(0.0001,0,0);\n    for(int i=0;i<=2+min(iFrame,0);i++){       \n        for(float j=-1.;j<=1. ;j+=2. ) n+= j*e* GetDist(p + j* e,0).d ;\n        e=e.zxy; //TdHopper trick\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=min(iFrame,0); aoi<5; aoi++ ) {\n        hr = .001 + .05*float(aoi);\n        aopos = nor * hr + pos;\n        totao += -(GetDist(aopos,2).d-hr)*sca;\n        sca *= .6;\n    }\n    return clamp(1. - 4.*totao, 0.4, 1.);\n}\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3., -6);\n    if(dot(m.xy,m.xy)>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831 +3.14  );\n       }else{\n           ro.xz *= Rot(+iTime/4.);       \n       }\n    ro.y=min(max(ro.y,-2.9),4.5);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 bcolor=vec3(0.325,0.529,0.792);\n    vec3 col = vec3(1);\n    float fresnel=1.;\n    bool issecond=false;\n    bool isShadow=false;\n    bool isInside=false;\n    vec3 ld=normalize(vec3(3,5,1));\n    \n    vec3 p;\n    mp=vec3(10.);\n    for(float i=0.;i<12.;i++){\n        if(max(max(col.x,col.y),col.z)<.05) break;\n        Hit h=RayMarch(ro, rd,isInside?-1.:1.,isShadow);\n\n        if(h.d<10.){\n            p = ro + rd * h.d;\n            vec3 n = GetNormal(p);\n            if(isShadow){               \n                 \n                col*=.7;\n                break;\n                \n            } \n            else if(h.obj==0.){ //DIELECTRIC                \n                const float IOR=1.35;  \n                vec3 nIn=isInside?-n:n;\n                \n                vec3 rOut =refract(rd,nIn,isInside?IOR: 1./IOR); \n                if(dot(rOut,rOut)==0.) rOut=reflect(-rd,nIn);\n                else col*=pow( vec3(.2,.9,1.),vec3(pow(1.-abs(dot(rd,n)),2.)));\n                \n                rd=rOut;\n                ro=p-nIn*.003;\n                isInside=!isInside;\n            }\n            else if(h.obj==1.){ //LAMBERTIAN\n                \n                float dif = dot(n, ld)*.5+.5;\n                col*= (+h.c*fresnel)*.7;\n                col *= vec3(dif);\n#ifdef AO\n                float  ao = calcAO(p, n);\n                col *= mix(ao,1.,.0);\n#endif\n                ro=p+n*.001;\n                rd=ld;\n                isShadow=true;\n                isInside=false;\n                if(dot(n,ld)<0.)  { col*=.7; break;}\n            }\n            else if(h.obj==2.){ //METAL         \n                ro=p+n*.001;\n                rd=reflect(rd,n);\n                if(!issecond) fresnel=pow(1.-dot(rd,n),2.);                  \n                issecond=true;\n                isInside=false;\n            }           \n        }\n        else{  //NO HIT \n            if(!isShadow){\n                if(i==0. )col=bcolor;\n                else col=mix((col+.2)/i*fresnel,bcolor,1.-smoothstep(12.,0.,length(p)));\n            }\n            break;\n        }\n    }         \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//CIRCUIT CONFIGURATION for the 5x5x5 GRID\nconst ivec2 bmm[125]= ivec2[125]( \n    // x= 0 off / 1 on, y= 0 in / 1 out, z=todo    \n    // mask=0xBFUDRL where each digit is the hexadecimal value for the face B=back/F=front/U=up/D=down/R=right/L=left \n    // mask for each face:\n    // Back = 8 right + 4 left + 2 down + 1 up\n    // Front= 8 right + 4 left + 2 up + 1 down\n    // Up   = 8 back + 4 front + 2 left + 1 right\n    // Down = 8 back + 4 front + 2 right + 1 left\n    // Right= 8 up + 4 down + 2 front + 1 back\n    // Left = 8 up + 4 down + 2 back + 1 front\n    //------SLICE 1\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(-1)               ,ivec2(-1)               ,ivec2(-1),\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(0x0C90A5,0x088081),ivec2(-1)               ,ivec2(-1),\n    ivec2(-1)                ,ivec2(0x0A5000,0x021000),ivec2(0x050000,0x040000),ivec2(0x03CC00,0x014800),ivec2(-1),\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(0x060003,0x020001),ivec2(-1)               ,ivec2(-1),\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(-1)               ,ivec2(-1)               ,ivec2(-1),\n    //------SLICE 2\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(0x09A06C,0x082044),ivec2(-1)               ,ivec2(-1),\n    ivec2(-1)                ,ivec2(0x00300C,0x002004),ivec2(0)                ,ivec2(0x036000,0x014000),ivec2(-1),\n    ivec2(0x035C00,0x014800) ,ivec2(0)                ,ivec2(0)                ,ivec2(0)                ,ivec2(0x03CC00,0x028400),\n    ivec2(-1)                ,ivec2(0x0C0003,0x080001),ivec2(0)                ,ivec2(0x030C00,0x010800),ivec2(-1),\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(0x0C0033,0x040022),ivec2(-1)               ,ivec2(-1),\n    //------SLICE 3\n    ivec2(-1)                ,ivec2(0xA0300C,0x201008),ivec2(0x006000,0x004000),ivec2(0)                ,ivec2(-1),\n    ivec2(0xA0300C,0x201008) ,ivec2(0),               ivec2(0)                ,ivec2(0)                ,ivec2(0x0350C0,0x021040),\n    ivec2(0x00000C,0x000008) ,ivec2(0)                ,ivec2(0)                ,ivec2(0)                ,ivec2(0x0000C0,0x000040),\n    ivec2(0xCA000A,0x480008) ,ivec2(0)                ,ivec2(0)                ,ivec2(0)                ,ivec2(0xC30590,0x420410),\n    ivec2(-1)                ,ivec2(0xCC0003,0x840002),ivec2(0)                ,ivec2(0xC60090,0x840080),ivec2(-1),\n    //------SLICE 4\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(0xA03099,0x802081),ivec2(-1)               ,ivec2(-1),\n    ivec2(-1)                ,ivec2(0x50C003,0x408001),ivec2(0)                ,ivec2(0x5090C0,0x408080),ivec2(-1),\n    ivec2(0xC0600A,0x802002),ivec2(0)                ,ivec2(0)                ,ivec2(0)                ,ivec2(0x0033C0,0x002280),\n    ivec2(-1)                ,ivec2(0xC00003,0x400001),ivec2(0)                ,ivec2(0x0000A0,0x000080),ivec2(-1),\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(0xC00033,0x800022),ivec2(-1)               ,ivec2(-1),\n    //------SLICE 5               \n    ivec2(-1)                ,ivec2(-1)               ,ivec2(-1)               ,ivec2(-1)               ,ivec2(-1),\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(0xC0603A,0x404018),ivec2(-1)               ,ivec2(-1),\n    ivec2(-1)                ,ivec2(0xC00003,0x800002),ivec2(0xC00000,0x800000),ivec2(0x5093C0,0x101140),ivec2(-1),\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(0xC00093,0x400011),ivec2(-1)               ,ivec2(-1),\n    ivec2(-1)                ,ivec2(-1)               ,ivec2(-1)               ,ivec2(-1)               ,ivec2(-1)\n);\n  \n//LF,LB,LD,LU,RB,RF,RD,RU,DL,DR,DF,DB,UR,UL,UF,UB,FD,DU,FL,FR,BU,BD,BL,BR\n//id of the connector on the same edge\nint[24] corn = int[24] (18, 22,8 ,13,23,19,9 ,12,2 ,6 ,16,21,7 ,3 ,17,20,10,14,0 ,5 ,15,11,1 ,4 );\n\nivec2 getData(int id,vec3 d){\n    vec3 mp=vec3(id%5,(id%25)/5,id/25)-vec3(2.) +d*vec3(1,-1,1);\n    if(  max(max(abs(mp.x),abs(mp.y)),abs(mp.z))>2.) return ivec2(-1);\n    \n     id+=int(d.z)*25-int(d.y)*5+int(d.x);\n    \n    return bmm[id];\n}\n\nvoid getDirs(int i, int j, out vec3 n, out  vec3 dr){\n    \n     n=vec3(1,0,0)*((i%2)>0?1.:-1.);\n    if(i>3)n=n.yzx;\n    else if(i>1) n=n.zxy;\n     dr= n.yzx;\n    if(j>1) dr=cross(n,dr);\n    if((j%2)>0) dr*=-1.;\n}\n\n// y=0: isConn, isInDir\n// y=1: isCorner(+isNb), BallDir,isStraight,isIntCorner\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    ivec2 c = ivec2(fc);\n    if(c.x>125 || c.y>1) discard;\n    if(c.y<1) O=intBitsToFloat(bmm[c.x].xyxx);\n    else{\n        ivec2 bm=bmm[c.x].xy;\n        ivec4 bma =ivec4(0);\n    \n        for(int i=0;i<6;i++){\n            vec3 n,dr;\n            getDirs(i,0,n,dr);\n            ivec2 bm3 =getData(c.x, n);\n            int m3=(1<<(i+24));\n            if(bm3.x!=-1)  bma.x+=m3; //bit 24-29= isNb\n            \n            for(int j=0;j<4;j++)\n            {                  \n                getDirs(i,j,n,dr);\n                int m=(1<<(i*4+j));\n                \n                ivec2 bm2 =getData(c.x, dr);\n                int m2=( 1<< ((i*4+(j&30) + (1- (j&1)))));\n                bool isConn=  (bm.x & m)>0 ;\n                bool isStraight = (bm2.x & m2)>0 && bm2.x!=-1;\n                bool isIntCorner = ( bm.x & m)==0 && isStraight;\n                bool BallDir = isConn? ( bm.y & m )>0 : ( bm2.y & m2 )>0 ;\n                bool isCorner =  (bm.x & ( 1<< corn[(i*4+j)]))>0; \n\n                if(isCorner) bma.x += m;\n                if(BallDir) bma.y += m;\n                if(isStraight) bma.z += m;\n                if(isIntCorner) bma.w += m;\n            }\n         }\n         O=intBitsToFloat(bma);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}