{"ver":"0.1","info":{"id":"Xf3yDr","date":"1730465535","viewed":18,"name":"Beadandó - Vajda Fábiusz","username":"Moncola","description":"beadando","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["beadando"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2(fragCoord);\n    vec3 col = texelFetch(iChannel0,px,0).rgb;\n    fragColor=vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Handles camera only\n\nconst int KeyLeft  = 65; //'A'\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\nconst int KeyE     = 69;\nconst int KeyQ     = 81;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nvec4 UpdateCamera(vec2 fragCoord)\n{\n    \n    /*  We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (cameraX, cameraY, cameraZ, U)\n            pixel1 = (wX, wY, wZ, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n            wX, wY, wZ is the forward vector\n\t*/\n    \n    vec4 data1 = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data2 = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec3 eye = data1.xyz+EyeStartPosition;\n    vec2 uv\t= abs(vec2(data1.w,data2.w));\n    \n   \tif(!isKeyHeld(KeyQ ) && (iMouse.z>0. || data1.w >= 0.))\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    if (isKeyHeld(KeyE    )) eye.y += speed;\n    //if (isKeyHeld(KeyQ    )) eye.y -= speed;\n    \n    vec2 outdata = vec2(data1.w,data2.w);\n    if(iMouse.z>=0.)        outdata = abs(vec2(outdata)); //mouse held\n\telse if(data1.w >= 0.)  outdata = -mod(uv,2.*pi); //mouse released\n        \n    vec4 fragColor;\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor = vec4(eye-EyeStartPosition,outdata.x);\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor = vec4(w,outdata.y);\n\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    if(fragCoord.x > 1.5 || fragCoord.y > 0.5)\n        discard;\n    fragColor = UpdateCamera(fragCoord); \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int KeyQ     = 81;\n\n#define isKeyHeld(k)  (texelFetch(iChannel2, ivec2(k,0), 0).x > 0.)\n\n\n// SDF Primitives (more on https://iquilezles.org/articles/distfunctions/)\n\nfloat sdSphere(vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))\n         + min(max3(d.x,d.y,d.z),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// SDF Operations\n\nvec3 opRepLim(vec3 p, float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\nvec3 opRep( in vec3 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nfloat intersectPlane(Ray ray, vec3 q, vec3 n)\n{\n    return dot(q-ray.P,n)/dot(ray.V,n);\n}\n\n//CSG functions\n\nfloat Unite(float a,float b){ // union on the original sdf representation\n    return min(a,b);\n}\nValue Unite(Value a,Value b){     // same union but also carrying mat id\n    Value result;\n    result.sdf = Unite(a.sdf,b.sdf);\n    result.id = result.sdf == a.sdf ? a.id : b.id;\n    return result;\n}\nValue Unite(Value a,float b_f,int b_id){ // creates a Value from the (float,int) \n    Value b;\n    b.sdf = b_f;\n    b.id = b_id;\n    return Unite(a,b);\n}\nValue Unite(float a_f,Value b,int a_id){ // pairs and calls Unite(Value,Value)\n    Value a;\n    a.sdf = a_f;\n    a.id = a_id;\n    return Unite(a,b);\n}\n\nfloat Subtract(float a,float b){ // subtract on the original sdf representation\n    return max(a,-b);\n}\nValue Subtract(Value a,Value b){     // same subtraction but also carrying mat id\n    Value result;\n    result.sdf = Subtract(a.sdf,b.sdf);\n    result.id = result.sdf == a.sdf ? a.id : b.id;\n    return result;\n}\nValue Subtract(Value a,float b_f,int b_id){ // creates a Value from the (float,int) \n    Value b;\n    b.sdf = b_f;\n    b.id = b_id;\n    return Subtract(a,b);\n}\nValue Subtract(float a_f,Value b,int a_id){ // pairs and calls Subtract(Value,Value)\n    Value a;\n    a.sdf = a_f;\n    a.id = a_id;\n    return Subtract(a,b);\n}\n\nfloat Intersect(float a,float b){ // intersect on the original sdf representation\n    return max(a,b);\n}\nValue Intersect(Value a,Value b){     // same intersection but also carrying mat id\n    Value result;\n    result.sdf = Intersect(a.sdf,b.sdf);\n    result.id = result.sdf == a.sdf ? a.id : b.id;\n    return result;\n}\nValue Intersect(Value a,float b_f,int b_id){ // creates a Value from the (float,int) \n    Value b;\n    b.sdf = b_f;\n    b.id = b_id;\n    return Intersect(a,b);\n}\nValue Intersect(float a_f,Value b,int a_id){ // pairs and calls Intersect(Value,Value)\n    Value a;\n    a.sdf = a_f;\n    a.id = a_id;\n    return Intersect(a,b);\n}\nValue extra_spheres_d=Value(10000.,0);\n\n// Signed Distance Function\nValue sdf(vec3 p, bool draw)\n{\n    Value d = Value(10000.,0);\n    d =Unite(d,sdBox(p,vec3(1.)),1);\n    d =Unite(d,sdSphere(p+vec3(5.,0.,0.),1.),2);\n    d =Unite(d,sdTorus(p+vec3(-7.+2.*sin(iTime),0.,0.),vec2(1.3,1)),3);\n    d =Unite(d,sdHexPrism(p+vec3(0.,0.,5.),vec2(1.,1.5)),4);\n    d =Unite(d,sdOctahedron(p+vec3(0.,-2.+2.*sin(1.1*iTime),-5.),1.),5);\n    d =Unite(d,sdPlane(p+vec3(0.,1.,0.),vec3(0.,1.,0.),0.),0);\n    d =Unite(d,Subtract(sdOctahedron(p+vec3(-5.,0.,-5.),1.),sdTorus(p+vec3(-5.,0.,-5.),vec2(1.3,1.))),1);\n    d =Unite(d,Intersect(sdHexPrism(p+vec3(-5.,0.,5.),vec2(1.,1.5)),sdTorus(p+vec3(-5.,0.,5.),vec2(1.3,1.))),2);\n    d =Unite(d,Unite(sdSphere(p+vec3(5.,-1.,5.),1.),sdHexPrism(p+vec3(5.,0.,5.),vec2(1.,1.5))),3);\n    d =Unite(d,Subtract(sdSphere(p+vec3(5.,0.,-5.),1.),sdOctahedron(p+vec3(5.,-1.,-5.),1.)),4);\n    if(!draw) d =Unite(d,extra_spheres_d);\n    return d;\n}\n//Materials\nvoid InitMaterials(){\n    materials[0].color = vec3(0.8,0.2,0.2);\n    materials[0].roughness = 0.;\n    materials[0].emission = vec3(0.);\n    materials[0].metalness = 0.045;\n    \n    materials[1].color = vec3(0.,1.,0.);\n    materials[1].roughness = 1.;\n    materials[1].emission = vec3(0.);\n    materials[1].metalness = 0.75;\n    \n    materials[2].color = vec3(0.,0.,1.);\n    materials[2].roughness = 2.;\n    materials[2].emission = vec3(0.);\n    materials[2].metalness = 0.9;\n    \n    materials[3].color = vec3(1,1,0.);\n    materials[3].roughness = 3.;\n    materials[3].emission = vec3(1.,1.,0.);\n    materials[3].metalness = 0.02;\n    \n    materials[4].color = vec3(.4,0.4,0.4);\n    materials[4].roughness = 4.;\n    materials[4].emission = vec3(0.);\n    materials[4].metalness = 0.6;\n    \n    materials[5].color = vec3(1,1,1);\n    materials[5].roughness = 5.;\n    materials[5].emission = vec3(1.,1.,1.);\n    materials[5].metalness = 0.05;\n    \n}\n\n// symmetric differential\nvec3 normal(const in vec3 p)\n{\n    const vec2 eps0 = vec2(0.01,0);\n    vec3 m0 = vec3(sdf(p-eps0.xyy,false).sdf, sdf(p-eps0.yxy,false).sdf, sdf(p-eps0.yyx,false).sdf);\n    vec3 m1 = vec3(sdf(p+eps0.xyy,false).sdf, sdf(p+eps0.yxy,false).sdf, sdf(p+eps0.yyx,false).sdf);\n    return normalize(m1-m0);\n}\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0,0,0);\n    Value val;\n    float d;\n    do {\n        val = sdf(ray.P+ret.T*ray.V,false);\n        d = abs(val.sdf);\n        ret.T += d;\n        ++ret.steps;\n    } while ( ret.T     < ray.Tmax &&       \t  // Stay within bound box\n              d\t        > params.epsilon*ret.T && // Stop if cone is close to surface\n              ret.steps < params.maxiters\t      // Stop if too many iterations\n\t);\n    ret.flags =  int(ret.T     >= ray.Tmax)\n              | (int(d         <= params.epsilon*ret.T)  << 1)\n              | (int(ret.steps >= params.maxiters) << 2);\n    ret.id = val.id;\n    return ret;\n}\n\nTraceResult DrawSphereTrace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0,0,0);\n    Value val;\n    float d;\n    do {\n        val = sdf(ray.P+ret.T*ray.V, true);\n        d = abs(val.sdf);\n        extra_spheres_d = Unite(extra_spheres_d,sdSphere(ray.P+ret.T*ray.V,d),3);\n        ret.T += d;\n        ++ret.steps;\n    } while ( ret.T     < ray.Tmax &&       \t  // Stay within bound box\n              d\t        > params.epsilon*ret.T && // Stop if cone is close to surface\n              ret.steps < params.maxiters\t      // Stop if too many iterations\n\t);\n    ret.flags =  int(ret.T     >= ray.Tmax)\n              | (int(d         <= params.epsilon*ret.T)  << 1)\n              | (int(ret.steps >= params.maxiters) << 2);\n    ret.id = val.id;\n    return ret;\n}\n\n// Buffer A handels camera movement. Here we only read it\nRay ReadCamera(vec2 fragCoord, out float diagInv)\n{\n    vec4 data1 = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data2 = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec3 eye = data1.xyz+EyeStartPosition;\n        \n    vec3 w = data2.xyz;\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    //vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    diagInv = 1./length(iResolution.xy);\n    vec2 px = (2.*fragCoord-iResolution.xy)*diagInv*1.;\n        \n    return Ray(eye,\t0.0, normalize(w+px.x*u+px.y*v), 10000.);\n}\n\nvec3 iqcolor(float d)\n{   //https://www.shadertoy.com/view/3ltSW2\n    d/=1.;\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitMaterials();\n    float tanPix;\n    Ray ray = ReadCamera(fragCoord,tanPix);\n    TraceResult drawret;\n    if(isKeyHeld(KeyQ) && iMouse.z>0.){\n        drawSpheres = true;\n        mouseRayStart = iMouse.xy;\n        float mouseTanPix;\n    }\n    if(drawSpheres){\n        float mouseTanPix;\n        Ray mouseray = Ray(EyeStartPosition,\t0.0, normalize(vec3(1,0,0)), 10000.);\n        SphereTraceDesc params = SphereTraceDesc(mouseTanPix, 1064);\n        drawret = DrawSphereTrace(mouseray, params);\n    }\n    SphereTraceDesc params = SphereTraceDesc(tanPix, 1064);\n    TraceResult ret = sphere_trace(ray, params);\n    \n    vec3 n_plane = normalize(vec3(1,1,0));\n    //float t_plane = intersectPlane(ray,vec3(sin(iTime)*2.),n_plane);\n    \n      \n    if(bool(ret.flags & 1)){\n        fragColor = vec4(.2,.5,1,1);\n    }   \n    else if(bool(ret.flags&2)){\n        vec3 p = ray.P + ray.V*ret.T;\n        vec3 n = normal(p);\n        vec3 l = normalize(vec3(1.,5.+3.*sin(iTime),3));\n        //vec3 col = vec3(max(dot(n,l),0.));\n        vec3 col = materials[ret.id].color;\n        col = col*pow(max(dot(n,l),0.), sqrt(30.*materials[ret.id].metalness));\n        fragColor = vec4(col,1);\n    }\n    else if(bool(ret.flags&4)){\n        fragColor = vec4(1,0,0,1);\n    }\n    \n    //if(20.>length(fragCoord-vec2(300,300))){\n    //    fragColor = vec4(ray.V,1);\n    //}\n    //\n    //if(0.< t_plane && t_plane < ret.T)\n    //{\n    //    vec3 p = ray.P + ray.V*t_plane;\n    //    vec3 n = n_plane;\n    //    vec3 l = normalize(vec3(1,2,3));\n    //    vec3 c = iqcolor(sdf(p));\n    //    //c = vec3(sdf(p));\n    //    vec3 col = c;\n    //    fragColor = mix(fragColor,vec4(col,1),0.8);\n    //}\n    fragColor.w = ret.T;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// A common shader included (as is) in all Buffers\n\nstruct Ray {\n\tvec3 P;\tfloat Tmin;\n\tvec3 V;\tfloat Tmax;\n};\n\nstruct SphereTraceDesc {\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nstruct TraceResult {\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// flags bit 0:   distance condition: true if travelled to far t > t_max\n    int steps;      // flags bit 1:   surface condition:  true if distance to surface is small < error threshold\n    int id;\n};  // flags bit 2:   max. iter. condition:  true if none of the above, exited the loop because i > maxsteps\n\nstruct Material {\n    vec3  color;        // [0,1/pi]\n    float roughness;    // [0,~7]\n    vec3  emission;\t    // [0, inf]\n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n};\n\nstruct Value {\n    float sdf;\n    int id;\n};\n\nMaterial materials[6];\n\n\nvec2 mouseRayStart = vec2(300,300);\nbool drawSpheres = false;\n \n\nconst float pi = 3.1415926535897932384626433832795;\n\nconst vec3 EyeStartPosition = vec3(2);\n\n// common useful functions\nfloat min3(float a,float b,float c){return min(min(a,b),c);}\nfloat max3(float a,float b,float c){return max(max(a,b),c);}\nfloat max3(vec3 a){return max(max(a.x,a.y),a.z);}\nfloat min3(vec3 a){return min(min(a.x,a.y),a.z);}\nfloat dot2(vec3 a){return dot(a,a);}","name":"Common","description":"","type":"common"}]}