{"ver":"0.1","info":{"id":"l3SfzR","date":"1729191802","viewed":85,"name":"Raytraced random bilinear patch","username":"stduhpf","description":"Intersection between a ray and an arbitrary bilinear patch (hyperbolic paraboloid obtained by interpolating bilinearly between four points)\nCould be useful to handle non-flat quads in a raytracer for example?\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","quad","bilinearpatch","hyperbolicparaboloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.sci.utah.edu/~kpotter/publications/ramsey-2004-RBPI.pdf\n\n//#define stereo .1 // -.1 for cross-eyed (defaults to parallel view)\n\nfloat wedge(vec2 a, vec2 b){\n    return dot(a,vec2(b.y,-b.x));\n}\n\nmat2x3 traceBPfull(mat4x3 ABCD, vec3 ro, vec3 rd){\n    vec3 rr = rd*rd;\n    int rmax = (rr.x>rr.y && rr.x>rr.z)?0:(rr.y>rr.z?1:2);\n    mat4x3 abcd = mat4x3(ABCD[3] + ABCD[0] - ABCD[1] - ABCD[2],\n                         ABCD[1] - ABCD[0],\n                         ABCD[2] - ABCD[0],\n                         ABCD[0]-ro);\n    // ro+dr*rd = uv*a+u*b+v*c+(d+ro) => dr*rd = uv*a+u*b+v*c+d (true for x y and z)\n    // dr*rd.x = (uv*a.x+u*b.x+v*c.x+d.x) (1)\n    // dr*rd.y = (uv*a.y+u*b.y+v*c.y+d.y) (2)\n    // dr*rd.z = (uv*a.z+u*b.z+v*c.z+d.z) (3)\n    // (3) in (1) =>  (uv*a.z+u*b.z+v*c.z+d.z)*rd.x = (uv*a.x+u*b.x+v*c.x+d.x)*rd.z\n    //            =>  v(u*(a.z*rd.x-a.x*rd.z) + (c.z*rd.x-c.x*rd.z)) =  u*(b.x*rd.z-b.z*rd.x) + d.x*rd.z-d.z*rd.x (4)\n    // (3) in (2) =>  u(v*(a.z*rd.y-a.y*rd.z) + (b.z*rd.y-b.y*rd.z)) =  v*(c.y*rd.z-c.z*rd.y) + d.y*rd.z-d.z*rd.y\n    //            =>  u =(v*(c.y*rd.z-c.z*rd.y) + (d.y*rd.z-d.z*rd.y))/(v*(a.z*rd.y-a.y*rd.z) + (b.z*rd.y-b.y*rd.z)) (5)\n    // group things together\n    //                u = (v*cX.y + dX.y)/(v*aX.y + bX.y) (5')\n    //                v = (u*bX.x + dX.x)/(u*aX.x + cX.x) (4')\n    // (4') in (5') => v((v*cX.y + dX.y)/(v*aX.y + bX.y)*aX.x + cX.x) = ((v*cX.y + dX.y)/(v*aX.y + bX.y)*bX.x + dX.x)\n    //              => v((v*cX.y + dX.y)*aX.x + cX.x*(v*aX.y + bX.y)) = ((v*cX.y + dX.y)*bX.x + dX.x*(v*aX.y + bX.y))\n    //              => v²(cX.y*aX.x + cX.x*aX.y) + v(dX.y*aX.x + cX.x*bX.y) = v(cX.y*bX.x + dX.x*aX.y) + (dX.y*bX.x + dX.x*bX.y)\n    //              => v²(cX.y*aX.x + cX.x*aX.y) + v((dX.y*aX.x-dX.x*aX.y) + (cX.x*bX.y-cX.y*bX.x)) - (dX.y*bX.x + dX.x*bX.y) = 0\n    //              => v²qa + vqb + qc = 0 \n\n    vec3 aX = cross(abcd[0],rd);//vec2(wedge(abcd[0].xz,rd.xz),wedge(abcd[0].yz,rd.yz));\n    vec3 bX = cross(abcd[1],rd);//vec2(wedge(abcd[1].xz,rd.xz),wedge(abcd[1].yz,rd.yz));\n    vec3 cX = cross(abcd[2],rd);//vec2(wedge(abcd[2].xz,rd.xz),wedge(abcd[2].yz,rd.yz));\n    vec3 dX = cross(abcd[3],rd);//vec2(wedge(abcd[3].xz,rd.xz),wedge(abcd[3].yz,rd.yz));\n\n    vec3 qa = cross(aX,cX);\n    vec3 qb = cross(aX,dX) + cross(bX,cX);\n    vec3 qc = cross(bX,dX);\n    \n    vec3 bXu = cX;\n    vec3 cXu = bX;\n    vec3 qau = cross(aX,cXu);\n    \n    vec3 qabs = qa*qa;\n    int qamax = (qabs.x>qabs.y&&qabs.x>qabs.z)?0:(qabs.y>qabs.z)?1:2;\n    \n    vec3 qaubs = qau*qau;\n    int qaumax = (qaubs.x>qaubs.y&&qaubs.x>qaubs.z)?0:(qaubs.y>qaubs.z)?1:2;\n\n    \n    bool swap = qaubs[qaumax]>qabs[qamax];\n\n    if(swap){\n        // solve for u instead of v for better preecision  \n        bX = bXu;\n        cX = cXu;\n\n        qa = qau;\n        qb = cross(aX,dX) + cross(bXu,cXu);\n        qc = cross(bXu,dX);\n\n        qabs = qaubs;\n        qamax = qaumax;\n    }\n\n    vec3 delta = (qb*qb-4.*qa*qc);\n\n    if(delta.x<0.) return mat2x3(vec3(-10),vec3(-10));    // no hit\n    \n    vec3 deltasq = sqrt(delta);\n    \n\n    bool isntflat = qabs[qamax]>1e-9; // if qa is 0, it means the surface is very close to be flat in the direction of v (and to u thanks to the swap) : vqb+qc=0 \n    \n    \n    vec3 s = sign(rd);\n    \n    \n    float v0 = (isntflat?(s*deltasq - qb)/(qa+qa):-qc/qb)[qamax];\n    vec3 den0 = (v0 * aX + bX);\n    vec3 us0 = -(v0 * cX + dX)/den0;\n    den0*=den0;\n    float u0 = den0.x>den0.y && den0.x>den0.z?us0.x:den0.y>den0.z?us0.y:us0.z;\n\n\n\n    float v1 =  (isntflat?(-s*deltasq - qb)/(qa+qa):-qc/qb)[qamax];\n    vec3 den1 = (v1 * aX + bX);\n    vec3 us1 = -(v1 * cX + dX)/den1;\n    den1*=den1;\n    float u1 = den1.x>den1.y && den1.x>den1.z?us1.x:den1.y>den1.z?us1.y:us1.z;\n    \n    if(swap){\n        float u =u0,v=v0;\n        u0=v1,v0=u1;\n        u1=v,v1=u;\n    }\n    \n    \n    float uv0 = u0*v0;\n    vec3 ds0 = (uv0*abcd[0] + u0*abcd[1] + v0*abcd[2] + abcd[3])/rd;\n    float d0 = ds0[rmax];\n    \n    float uv1 = u1*v1;\n    vec3 ds1 = (uv1*abcd[0] + u1*abcd[1] + v1*abcd[2] + abcd[3])/rd;\n    float d1 = ds1[rmax];\n\n    if(!isntflat){\n        //fix backface\n        vec3 n012 = cross(ABCD[1]-ABCD[0],ABCD[2]-ABCD[0]);\n        if(dot(rd,n012)>0.){\n            d1=-1.;\n        }else{\n            d0=-1.;\n        }\n    }\n    \n\n    return mat2x3(vec3(u0,v0,d0),vec3(u1,v1,d1));\n\n}\n\nfloat is(vec3 o, vec3 rd, vec3 s, float r)\n{\n\n    vec3 p = o-s;\n    float b = dot(rd,p);\n    \n    float c = dot(p,p)-r*r;\n    float d = (b*b-c);\n    if(d<0.)\n        return -1.;\n    return -b-sqrt(d); \n}\n\nvec2 t(vec2 uv){\n    // set o>0 for bigger patch (extrapolating) (0>o>-.5 for small patch)\n    float o = 0.;\n    return (uv+o)/(1.+2.*o);\n}\n\nvec4 getInnerPatch(mat2x3 surfaceHits){\n    vec3 uvd0 = surfaceHits[0];\n    vec3 uvd1 = surfaceHits[1];\n    bool nearest1 = (uvd1.z<=uvd0.z|| uvd0.z<0.) && uvd1.z>=0. ;\n\n    bool face0valid = t(uvd0.xy) == fract(t(uvd0.xy));\n    bool face1valid = t(uvd1.xy) == fract(t(uvd1.xy));\n\n\n    bool choseFace1 = !face0valid ||(face1valid && nearest1);\n\n\n    return vec4(choseFace1?uvd1:uvd0,choseFace1);\n}\n\nvec4 traceBP(mat4x3 ABCD, vec3 ro, vec3 rd){\n    return getInnerPatch(traceBPfull(ABCD, ro, rd));\n}\n\nvec3 normapBP(mat4x3 ABCD, vec2 uv, bool backface){\n    vec3 P00 = mix(ABCD[0],ABCD[1],uv.x);\n    vec3 P01 = mix(ABCD[2],ABCD[3],uv.x);\n    \n    vec3 P10 = mix(ABCD[0],ABCD[2],uv.y);\n    vec3 P11 = mix(ABCD[1],ABCD[3],uv.y);\n    \n    // these 4 points should all be coplanar (with the intersection point too)\n    \n    vec3 n = normalize(cross(P00-P01,P10-P11));\n    if(backface) n*=-1.;\n    \n    return n;\n}\n\nvec3 randomPath(int id, float time){\n    return texture(iChannel2,vec2(.5+float(id)/iChannelResolution[2].x,float(id)*.618033 + time*.5/iChannelResolution[2].y)).rgb-.5;\n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Schlick(float f0, float cosTheta){\n    return f0+(1.-f0)*pow(1.-cosTheta,5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 xy = 2.*fragCoord - iResolution.xy;\n    \n    vec2 m = iMouse.x>0.?iMouse.xy/iResolution.xy:vec2(.5);\n    mat2 r1 = rot(-acos(-1.)*(m.y-.5));\n    mat2 r2 = rot(-2.*acos(-1.)*(m.x-.5));\n\n    vec3 ro = vec3(0,0,-3);\n    \n    #ifdef stereo\n        ro+=stereo*vec3(.2*(float(xy.x>0.)-.5),0.,0.); \n        const float de = .9;\n        xy.x=xy.x+.5*(xy.x>0.?-de:de)*iResolution.x;\n        xy*=2.;\n    #endif\n    ro.yz*=r1;\n    ro.xz*=r2;\n\n    \n    vec3 rd = normalize(vec3(xy,1.5*iResolution.x));\n    \n    rd.yz*=r1;\n    rd.xz*=r2;\n\n\n    vec3 A = randomPath(0,iTime)*4.+.5*vec3(-1,0,-1);\n    vec3 B = randomPath(1,iTime)*4.+.5*vec3(1,-0,-1);\n    vec3 C = randomPath(2,iTime)*4.+.5*vec3(-1,0,1);\n    vec3 D = randomPath(3,iTime)*4.+.5*vec3(1,1,1);\n\n    vec4 uvdf = traceBP(mat4x3(A,B,C,D),ro,rd);\n    \n    vec2 uv = uvdf.xy; \n    fragColor = texture(iChannel3,rd);\n    if(uvdf.z>0.001 && t(uv) == fract(t(uv))){\n        vec3 n = normapBP(mat4x3(A,B,C,D),uv,uvdf.w>.5);\n\n        vec3 lp = normalize(vec3(-.15,1.,0));\n        {// hard shadow\n            vec3 p = ro + uvdf.z*rd;//mix(mix(A,B,uv.x),mix(C,D,uv.x),uv.y);\n            vec4 suvd = traceBP(mat4x3(A,B,C,D),p+1e-4*n,lp);\n            if(suvd.z>.001 && t(suvd.xy) == fract(t(suvd.xy))) lp*=0.;\n        }\n        float light = sqrt(.05+.95*max(0.,dot(n,lp)));\n        //vec4 specular = texture(iChannel3,reflect(rd,n));\n        fragColor = (uvdf.w>.5?texture(iChannel1,uv):texture(iChannel0,uv))*light;//*sqrt(exp2(-uvdf.z));\n\n        //fragColor = mix(fragColor,specular,Schlick(.001,dot(n,-rd))); //looks wrong without proper gamma\n\n    }\n\n    float s;\n    if((s = is(ro,rd,A,.02))>0. && (uvdf.z<0. || s<uvdf.z || t(uv) != fract(t(uv)))) fragColor = vec4(1,0,0,0);\n    if((s = is(ro,rd,B,.02))>0. && (uvdf.z<0. || s<uvdf.z || t(uv) != fract(t(uv)))) fragColor = vec4(0,1,0,0);\n    if((s = is(ro,rd,C,.02))>0. && (uvdf.z<0. || s<uvdf.z || t(uv) != fract(t(uv)))) fragColor = vec4(0,1,1,0);\n    if((s = is(ro,rd,D,.02))>0. && (uvdf.z<0. || s<uvdf.z || t(uv) != fract(t(uv)))) fragColor = vec4(1,0,1,0);\n\n}","name":"Image","description":"","type":"image"}]}