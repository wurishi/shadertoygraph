{"ver":"0.1","info":{"id":"XdcGD4","date":"1449534812","viewed":445,"name":"Matrix88","username":"trashrabbit","description":".","likes":5,"published":1,"flags":2,"usePreview":0,"tags":["matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// inputs:\n//  iChannel0: webcam image\n//  iChannel1: matrix characters image.\n//             should be a small b&w image with a row of pixelated matrix-font characters.\n//             for example, a 64 x 16 image with a row of 8 x 16 characters.\n\n\n#define N_CHARS 8.0   // how many characters are in the character image\n#define Y_PIXELS 18.0 // reduce input image to this many mega-pixels across\n#define DROP_SPEED 0.15\n#define ASPECT 2.7    // aspect ratio of input webcam image\n                      // can play with this to get non-square matrix characters\n#define MIN_DROP_SPEED 0.2 // range 0-1.  is added to column speeds to avoid stopped columns.\n#define STATIC_STRENGTH 0.1 // range 0-1.  how intense is the tv static\n#define SCANLINE_STRENGTH 0.4 // range 0-1.  how dark are the tv scanlines\n#define NUM_SCANLINES 70.0 // how many scanlines\n\n// random functions adapted from https://www.shadertoy.com/view/lsXSDn                  \nfloat rand2d(vec2 v){\n    return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float x) {\n    return fract(sin(x) * 3928.2413);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // pixelate webcam image into mega-pixels\n    float xPix = floor(uv.x * Y_PIXELS * ASPECT) / Y_PIXELS / ASPECT;\n    float yOffs = mod(iTime * DROP_SPEED * (rand(xPix) + MIN_DROP_SPEED), 1.0);\n    float yPix = floor((uv.y + yOffs) * Y_PIXELS) / Y_PIXELS - yOffs;\n    vec2 uvPix = vec2(xPix, yPix);\n    // ideally we should blur the input image to reduce flickering\n    vec4 pixelColor = texture(iChannel0, uvPix);\n\n    // compute uv within each mega-pixel\n    vec2 uvInPix = vec2(\n    \tmod(uv.x * Y_PIXELS, 1.0),\n    \tmod((uv.y + yOffs) * Y_PIXELS, 1.0)\n    );\n\n    // offset char image to appropriate char\n    float charOffset = floor(pixelColor.r * N_CHARS) / N_CHARS;\n    uvInPix.x = uvInPix.x / N_CHARS + charOffset;\n    vec4 charColor = texture(iChannel1, uvInPix);\n    \n    // multiply char images and webcam mega-pixels\n    float result = charColor.r * pixelColor.r;\n\n    // add scanlines\n    result *= 1.0 - SCANLINE_STRENGTH * (sin(uv.y * NUM_SCANLINES*3.14159*2.0)/2.0+0.5);\n    \n\t// and map to a black->green->white gradient\n    vec4 outColor = vec4(\n        max(0.0, result*3.0-1.2),\n        result*1.6,\n        max(0.0, result*3.0-1.5),\n        1.0\n    );\n    \n    // add tv static\n    //float stat = rand(uv.x * uv.y * 0.12798 + iTime * 0.1) * STATIC_STRENGTH;\n    float stat = rand2d(uv * vec2(0.0005,1.0) + iTime * 0.1) * STATIC_STRENGTH;\n    outColor += stat;\n    \n    fragColor = outColor;\n}","name":"","description":"","type":"image"}]}