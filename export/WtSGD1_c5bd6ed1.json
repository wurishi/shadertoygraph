{"ver":"0.1","info":{"id":"WtSGD1","date":"1625620640","viewed":270,"name":"Trilinear Filtering","username":"mileslacey","description":"Attempting to lookup individual tiles in a texture.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tiled","filtering","sampling","trilinear","tile","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// The convert_3d_to_2d() function accepts UVW coordinates usually used by a cubemap and\n// converts them into standard UV coordinates, suitable for use in a 2D texture atlas.\nvec2 convert_3d_to_2d(in vec3 uvw, in vec2 numTilesXY)\n{\n    // ensure we have an index which refers to the tile index, not UV indices between (0, 1)\n    float numTiles = numTilesXY.x * numTilesXY.y;\n    float index = uvw.z * numTiles;\n    \n    // used later, multiplication is faster than division\n    vec2 invNumTilesXY = vec2(1.0) / numTilesXY;\n    \n    // Determine the x-tile and y-tile offsets. I'm using the floor() function to\n    // ensure the UV offset doesn't stride into the next tile within the texture atlas.\n    vec2 uvOffset = floor(vec2(mod(index, numTilesXY.x), index * invNumTilesXY.y));\n    \n    // normalize to UV-coordinates\n    vec2 normalized = vec2(uvOffset.x, uvOffset.y) * invNumTilesXY;\n    \n    // offset the final UV coordinates into their proper place within a texture atlas.\n    return (uvw.xy * invNumTilesXY) + normalized;\n}\n\n\n\n// My sample implementation of a \"tex3D()\" function.\n// Manual implementation of trilinear filtering. Use of this function assumes that linear\n// filtering is currently enabled without mipmaps.\nvec4 tex3D_trilinear(in sampler2D texAtlas, in vec3 uvw, in vec2 numTilesXY)\n{\n    // calculate the number of tiles to be accessed. This is required within the following\n    // \"numSamples\" variable.\n    float numTiles = numTilesXY.x * numTilesXY.y;\n    \n    // \"tileIncrement\" controls how much we need to increment the current Z value to reach\n    // the next tile.\n    float tileIncrement = 1.0 / numTiles;\n    \n    // X & Y would normally be incremented by an offset to filter pixels in the horizontal\n    // and vertical directions, but we're only filtering in the Z direction for now.\n    float z = uvw.z;\n    vec3 sampleCoord0 = vec3(uvw.xy, z);\n    vec3 sampleCoord1 = vec3(uvw.xy, max(z+tileIncrement, 0.0));\n\n    // convert 3D texture coordinates to 2D.\n    vec2 uv0 = convert_3d_to_2d(sampleCoord0, numTilesXY);\n    vec2 uv1 = convert_3d_to_2d(sampleCoord1, numTilesXY);\n\n    // Perform the texture lookups.\n    // NOTE: This code only two texture-lookups because we're filtering tiles in the\n    // z-direction (bilinear filtering is assumed to be applied already. One tile is needed\n    // for the current tile, and another is needed to filter against the next closest tile.\n    // coordinates.\n    vec4 cz0 = texture(texAtlas, uv0);\n    vec4 cz1 = texture(texAtlas, uv1);\n\n    // Calculate the texel weights along the texture's z-axis. The weights of the final\n    // output color must sum to 1.\n    z = z * numTiles;\n    float weight0 = fract(z);\n    float weight1 = 1.0 - weight0;\n\n    // Blend the textures together using the weighted values from the textures.\n    return cz1*weight1 + cz0*weight0; // may compile into one MUL and one FMA\n}\n\n\n\n// Change to \"0\" to view the texture atlas being tested. Keep at \"1\" to view the\n// interpolation between tiles within the texture atlas.\n#if 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Variables to hold the number of tiles in the texture atlas. In a real example, the\n    // \"numTilesXY\" variable should be passed in as a GLSL uniform value.\n    vec2 numTilesXY = vec2(16.0, 16.0);\n    float numTotalTiles = numTilesXY.x * numTilesXY.y;\n    \n    // \"desiredTile\" can be altered to view a single tile, trilinearly interpolated into\n    // the next. \"uvw\" contains the UV coordinates of the whole texture and is later modified\n    // in the \"filter_trilinear()\" function to view a single tile.\n    // In a real-world situation, this variable should be based off of an actual mesh's UV\n    // coordinate to determine which texel to lookup.\n    float desiredTile = floor(mod(iTime, numTotalTiles));\n    vec3 uvw = vec3(fragCoord/iResolution.xy, (desiredTile-mod(iTime, 1.0)) / numTotalTiles);\n\n    // Output a trilinearly filtered texel to the screen\n    fragColor = tex3D_trilinear(iChannel0, uvw, numTilesXY);\n}\n\n#else\n\n// Debug \"main()\" function.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n\n#endif\n","name":"Image","description":"","type":"image"}]}