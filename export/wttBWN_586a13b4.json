{"ver":"0.1","info":{"id":"wttBWN","date":"1612791240","viewed":275,"name":"MC Laplace","username":"argent1024","description":"Lu = 0 with a line segment as the boundary condition","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["mc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb/col.w, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct ClosePoint {\n    float d;\n    vec2 p;\n    vec3 c;\n};\n\nClosePoint sdLine(vec2 p, vec2 a, vec2 b, vec3 ca, vec3 cb) { \n    vec2 ab = normalize(a - b);\n    vec2 pb = p - b;\n    vec2 pa = p - a;\n    \n    float l = dot(pb, ab);\n    float l_ab = length(a-b);\n    ClosePoint ans;\n    if(l >= 0. && l <l_ab) { \n        ans.p = b + l * ab;\n    } else if (length(pa) < length(pb)) {\n        ans.p = a;\n    } else {\n        ans.p = b;\n    }\n    ans.d = length(p - ans.p);\n    ans.c = vec3(0.0);\n    if(ans.d < 0.1) // on boundry\n    {\n        if(length(pb) < length(pa)) {ans.c = cb;}\n        else {ans.c = ca;}\n    }\n    return ans;\n}\n\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(iTime+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nconst float PI = 3.1415926;\n\nvec2 sampleSphere(vec2 p, float r) {\n    float theta = 2.0 * PI * rand(p);\n    vec2 d = vec2(cos(theta), sin(theta));\n    return p + d * r;\n}\n\nvec4 wos(vec2 pos) {\n    float eplision = 0.01f;\n    ClosePoint cp;\n    int max_iter = 10;\n    for(int i = 0; i < max_iter; i++) {\n        cp = sdLine(pos, vec2(0.6,0.6), vec2(-0.6,-0.6), vec3(0.9, 0.0, 0.0), vec3(0.0, 0.0, 0.9));\n        if(cp.d < eplision) { break; }\n        pos = sampleSphere(pos, cp.d);\n    }\n    return vec4(cp.c, 1.0);\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord){\n    vec2 position = 2.0 * (( gl_FragCoord.xy / iResolution.xy ) - vec2(0.5,0.5));\n    position.x *= iResolution.x / iResolution.y;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + wos(position);\n}","name":"Buffer A","description":"","type":"buffer"}]}