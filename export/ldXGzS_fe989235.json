{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*  https://www.shadertoy.com/view/ldXGzS\n\n\tArea light sampling from \"Importance Sampling Techniques for Path Tracing\n\tin Participating Media\" by Kulla and Fajardo.\n\t\n\t2013 @sjb3d\n\n\tImage is split as follows:\n\t\n\t+----------------------------------------+----------------------------------------+\n\t|                                        |                                        |\n\t| Sample scattering function in media.   |  Equi-angular sampling in media.       |\n\t|                                        |                                        |\n\t| Explicit light connections only.       |  Explicit light connections only.      |\n\t|                                        |                                        |\n\t|                                        |                                        |\n\t+----------------------------------------+----------------------------------------+\n\t|                                        |                                        |\n\t| Sample scattering function in media.   |  Equi-angular sampling in media.       |\n\t|                                        |                                        |\t\n\t| Light source connections and           |  Light source connections and          |\n\t| light source hits combined with MIS.   |  light source hits combined with MIS.  |\n\t|                                        |                                        |\n\t+----------------------------------------+----------------------------------------+\n\n\tIf your shader compiler is having a good day, top-left should look noisiest\n\tand bottom-right should look smoothest.\n\n\tUse the mouse to move the split locations.\n\n    In order to see the effect of MIS, it is recommended to leave\n    SHOW_LIGHT at the default of 0.\n*/\n\n// set to 1 to show light, 0 to hide light\n#define SHOW_LIGHT\t\t0\n\n#define PI\t\t\t\t3.1415926535\n#define SIGMA\t\t\t0.3\n\n#define STEP_COUNT\t\t32\n#define DIST_MAX\t\t10.0\n#define LIGHT_POWER\t\t200.0\n\n// Chrom[e|ium] seems to allow while loops, Firefox not so much!\n//#define USING_CHROME\n\n// shamelessly stolen from iq!\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat getDimensionHash(int dim, vec2 fragCoord)\n{\n\treturn hash(fragCoord.y*iResolution.x + fragCoord.x + iTime + float(dim));\n}\n\nvoid sampleCamera(vec2 fragCoord, vec2 u, out vec3 rayOrigin, out vec3 rayDir)\n{\n\tvec2 filmUv = (fragCoord.xy + u)/iResolution.xy;\n\n\tfloat tx = (2.0*filmUv.x - 1.0)*(iResolution.x/iResolution.y);\n\tfloat ty = (1.0 - 2.0*filmUv.y);\n\tfloat tz = 0.0;\n\n\trayOrigin = vec3(0.0, 0.0, 5.0);\n\trayDir = normalize(vec3(tx, ty, tz) - rayOrigin);\n}\n\nvoid intersectLight(\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tvec3 planeNormal,\n\tinout float rayT,\n\tinout vec2 uv)\n{\n\tvec3 planeTangent = normalize(cross(planeNormal, vec3(0.0, 1.0, 0.0)));\n\tvec3 planeBitangent = normalize(cross(planeNormal, planeTangent));\n\t\n\t// get coord of plane intersection\n\tfloat t = -dot(rayOrigin, planeNormal)/dot(rayDir, planeNormal);\n\tif (0.0 < t && t < rayT) {\n\t\t// check coord on plane is within light quad\n\t\tvec3 hitPos = rayOrigin + t*rayDir;\n\t\tfloat x = dot(hitPos, planeTangent);\n\t\tfloat y = dot(hitPos, planeBitangent);\n\t\tif (-0.5 < x && x < 0.5 && -0.5 < y && y < 0.5) {\n\t\t\trayT = t;\n\t\t\tuv = vec2(0.5 - x, y + 0.5);\n\t\t}\n\t}\n}\n\nvec3 evaluateLight(vec2 uv, out float areaPdf)\n{\n\tvec3 srgb = texture(iChannel0, uv).xyz;\n\tareaPdf = 1.0;\n\treturn LIGHT_POWER*pow(srgb, vec3(2.2));\n}\n\nvec3 sampleLight(\n\tvec2 uv,\n\tvec3 planeNormal,\n\tout vec3 lightPos,\n\tout float areaPdf)\n{\n\tvec3 planeTangent = normalize(cross(planeNormal, vec3(0.0, 1.0, 0.0)));\n\tvec3 planeBitangent = normalize(cross(planeNormal, planeTangent));\n\tfloat x = 0.5 - uv.x;\n\tfloat y = uv.y - 0.5;\n\tlightPos = x*planeTangent + y*planeBitangent;\n\treturn evaluateLight(uv, areaPdf);\n}\n\nvec3 unitVecFromPhiCosTheta(float phi, float cosTheta)\n{\n\tfloat sinPhi = sin(phi);\n\tfloat cosPhi = cos(phi);\n\tfloat sinTheta = sqrt(max(0.0, 1.0 - cosTheta*cosTheta));\n\treturn vec3(cosPhi*sinTheta, sinPhi*sinTheta, cosTheta);\n}\n\nvec3 sampleSphereUniform(vec2 uv)\n{\n\tfloat cosTheta = 2.0*uv.x - 1.0;\n\tfloat phi = 2.0*PI*uv.y;\n\treturn unitVecFromPhiCosTheta(phi, cosTheta);\n}\n\nfloat getSphereUniformPdf()\n{\n\treturn 1.0/(4.0*PI);\n}\n\nvoid sampleScattering(\n\tfloat u,\n\tfloat maxDistance,\n\tout float dist,\n\tout float pdf)\n{\n\t// remap u to account for finite max distance\n\tfloat minU = exp(-SIGMA*maxDistance);\n\tfloat a = u*(1.0 - minU) + minU;\n\n\t// sample with pdf proportional to exp(-sig*d)\n\tdist = -log(a)/SIGMA;\n\tpdf = SIGMA*a/(1.0 - minU);\n}\n\nvoid sampleEquiAngular(\n\tfloat u,\n\tfloat maxDistance,\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tvec3 lightPos,\n\tout float dist,\n\tout float pdf)\n{\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(lightPos - rayOrigin, rayDir);\n\n\t// get distance this point is from light\n\tfloat D = length(rayOrigin + delta*rayDir - lightPos);\n\n\t// get angle of endpoints\n\tfloat thetaA = atan(0.0 - delta, D);\n\tfloat thetaB = atan(maxDistance - delta, D);\n\n\t// take sample\n\tfloat t = D*tan(mix(thetaA, thetaB, u));\n\tdist = delta + t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\n\n// QMC in GLSL is painful!\nfloat radicalInverse(int index, int base)\n{\n\tfloat invBase = 1.0/float(base);\n\tfloat invBi = invBase;\n\tint n = index;\n\tfloat val = 0.0;\n\t// workaround for Firefox not liking while loops\n#ifdef USING_CHROME\n\twhile (n > 0) {\n#else\n\tfor (int i = 0; i < 8; ++i) { // log_base(STEP_COUNT) is enough\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfloat di = mod(float(n), float(base));\n\t\tval += di*invBi;\n\t\tn = n/base;\n\t\tinvBi *= invBase;\n\t}\n\treturn val;\n}\nfloat getSampleDim0(int sampleIndex,vec2 fragCoord)\n{\n\treturn fract(getDimensionHash(0,fragCoord) + radicalInverse(sampleIndex, 2));\n}\nfloat getSampleDim1(int sampleIndex,vec2 fragCoord)\n{\n\treturn fract(getDimensionHash(1,fragCoord) + radicalInverse(sampleIndex, 3));\n}\nfloat getSampleDim2(int sampleIndex,vec2 fragCoord)\n{\n\treturn fract(getDimensionHash(2,fragCoord) + radicalInverse(sampleIndex, 5));\n}\nfloat getSampleDim3(int sampleIndex,vec2 fragCoord)\n{\n\treturn fract(getDimensionHash(3,fragCoord) + radicalInverse(sampleIndex, 7));\n}\nfloat getSampleDim4(int sampleIndex,vec2 fragCoord)\n{\n\treturn fract(getDimensionHash(4,fragCoord) + radicalInverse(sampleIndex, 11));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 particleIntensity = vec3(1.0/(4.0*PI));\n\tvec3 lightNormal = normalize(vec3(2.0*sin(iTime), 0.5, 1.0));\n\t\n\tvec3 rayOrigin, rayDir;\n\tsampleCamera(fragCoord, vec2(0.5, 0.5), rayOrigin, rayDir);\n\t\n\tfloat sampleSplitCoord = (iMouse.x == 0.0) ? iResolution.x/2.0 : iMouse.x;\n\tfloat misSplitCoord = (iMouse.y == 0.0) ? iResolution.y/2.0 : iMouse.y;\n\n\tfloat t = DIST_MAX;\n\tvec3 col = vec3(0.0);\n\t\n#if SHOW_LIGHT\t\t\n\tvec2 uv;\n\tintersectLight(rayOrigin, rayDir, lightNormal, t, uv);\n\tif (t < DIST_MAX) {\n\t\tfloat areaPdfUnused;\n\t\tvec3 lightIntensity = evaluateLight(uv, areaPdfUnused);\n\t\tfloat trans = exp(-SIGMA*t);\n\t\tcol += lightIntensity*trans;\n\t}\n#endif\n\t\n\t// max single scatter distance is light plane\n\tt = min(t, -dot(rayOrigin, lightNormal)/dot(rayDir, lightNormal));\n\tif (t > 0.0) {\n\t\tfor (int stepIndex = 0; stepIndex < STEP_COUNT; ++stepIndex) {\n\t\t\tfloat u0 = getSampleDim0(stepIndex,fragCoord);\n\t\t\tfloat u1 = getSampleDim1(stepIndex,fragCoord);\n\t\t\tfloat u2 = getSampleDim2(stepIndex,fragCoord);\n\t\t\tfloat u3 = getSampleDim3(stepIndex,fragCoord);\n\t\t\tfloat u4 = getSampleDim4(stepIndex,fragCoord);\n\t\t\t\n\t\t\t// sample media along ray\n\t\t\tfloat x;\n\t\t\tfloat distPdf;\n\t\t\tvec3 particlePos;\n\t\t\n\t\t\t{\n\t\t\t\t// sample light source\n\t\t\t\tvec3 lightPos;\n\t\t\t\tfloat areaPdf;\n\t\t\t\tvec3 lightIntensity = sampleLight(vec2(u0, u1), lightNormal, lightPos, areaPdf);\n\t\t\t\t\n\t\t\t\t// sample particle pos\n\t\t\t\tif (fragCoord.x < sampleSplitCoord) {\n\t\t\t\t\tsampleScattering(u4, t, x, distPdf);\n\t\t\t\t} else {\n\t\t\t\t\tsampleEquiAngular(u4, t, rayOrigin, rayDir, lightPos, x, distPdf);\n\t\t\t\t}\n\t\t\t\tparticlePos = rayOrigin + x*rayDir;\n\t\t\t\t\n\t\t\t\t// compute info\n\t\t\t\tvec3 lightVec = lightPos - particlePos;\n\t\t\t\tvec3 lightDir = normalize(lightVec);\n\t\t\t\tfloat d = length(lightVec);\n\t\t\t\tfloat geomTerm = abs(dot(lightDir, lightNormal))/dot(lightVec, lightVec);\n\t\t\t\t\n\t\t\t\t// compute MIS weight (and adjust for sample count)\n\t\t\t\tfloat phasePdf = getSphereUniformPdf();\n\t\t\t\tfloat weight;\n\t\t\t\tif (fragCoord.y > misSplitCoord) {\n\t\t\t\t\tweight = 1.0;\n\t\t\t\t} else {\n\t\t\t\t\tfloat ratio = (geomTerm*phasePdf)/areaPdf;\n\t\t\t\t\tweight = 1.0/(1.0 + ratio);\n\t\t\t\t}\n\t\t\t\tweight /= float(STEP_COUNT);\n\t\t\t\t\n\t\t\t\t// accumulate sample\n\t\t\t\tfloat trans = exp(-SIGMA*(d + x));\n\t\t\t\tcol += weight*SIGMA*lightIntensity*particleIntensity*geomTerm*trans/(areaPdf*distPdf);\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\t// sample phase function\n\t\t\t\tvec3 phaseDir = sampleSphereUniform(vec2(u2, u3));\n\t\t\t\tfloat phasePdf = getSphereUniformPdf();\n\t\t\t\t\n\t\t\t\t// check for light intersection\n\t\t\t\tfloat d = DIST_MAX;\n\t\t\t\tvec2 uv;\n\t\t\t\tintersectLight(particlePos, phaseDir, lightNormal, d, uv);\n\t\t\t\tif (d < DIST_MAX) {\n\t\t\t\t\t// evaluate light\n\t\t\t\t\tfloat areaPdf;\n\t\t\t\t\tvec3 lightIntensity = evaluateLight(uv, areaPdf);\n\t\t\t\t\t\n\t\t\t\t\t// compute info\n\t\t\t\t\tfloat geomTerm = abs(dot(phaseDir, lightNormal))/(d*d);\n\t\t\t\t\t\n\t\t\t\t\t// compute MIS weight (and adjust for sample count)\n\t\t\t\t\tfloat weight;\n\t\t\t\t\tif (fragCoord.y > misSplitCoord) {\n\t\t\t\t\t\tweight = 0.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfloat ratio = areaPdf/(geomTerm*phasePdf);\n\t\t\t\t\t\tweight = 1.0/(1.0 + ratio);\n\t\t\t\t\t}\n\t\t\t\t\tweight /= float(STEP_COUNT);\n\t\t\t\t\t\n\t\t\t\t\t// accumulate sample\n\t\t\t\t\tfloat trans = exp(-SIGMA*(d + x));\n\t\t\t\t\tcol += weight*SIGMA*lightIntensity*particleIntensity*trans/(phasePdf*distPdf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// show slider position\n\tif (abs(fragCoord.x - sampleSplitCoord) < 1.0) {\n\t\tcol.x = 1.0;\n\t}\n\tif (abs(fragCoord.y - misSplitCoord) < 1.0) {\n\t\tcol.z = 1.0;\n\t}\n\tcol = pow(col, vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXGzS","date":"1373033831","viewed":2009,"name":"Area Light Equi-Angular Sampling","username":"sjb","description":"Area light sampling from \"Importance Sampling Techniques for Path Tracing in Participating Media\" by Kulla and Fajardo.\n\nVideo texture in channel 0 currently works best in Chrome!","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","scattering","equiangular","area","mis"],"hasliked":0,"parentid":"","parentname":""}}