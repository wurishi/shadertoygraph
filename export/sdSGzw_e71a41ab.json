{"ver":"0.1","info":{"id":"sdSGzw","date":"1617120808","viewed":119,"name":"raymarching 123435","username":"csgradle","description":"lol. don't know what i'm doing here.\nmap function from inigo quilez","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"7sXGD2","parentname":"raymarching 213s1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 30.\n#define MIN_HIT 0.0001\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nvec3 rotation(vec3 point, vec3 axis, float angle){ // https://www.shadertoy.com/view/Wtl3zN\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n// https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise3(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n// fog by inigo quilez\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float b = 0.02;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor  = vec3(0.2);\n    return mix( rgb, fogColor, fogAmount );\n}\nfloat getDist(vec3 p) {\n    float dist = MAX_DIST; \n    float node = sdOctahedron( opRep( p-vec3(0., 0., 0.), vec3(10.)), 2.5 );\n    dist = min( dist, node);\n    \n   \n    \n    vec3 pXpos = opRep( (p-vec3(5.,0.,0.)), vec3(10.));\n    vec3 pYpos = opRep( (p-vec3(0.,5.,0.)), vec3(10.));\n    vec3 pZpos = opRep( (p-vec3(0.,0.,5.)), vec3(10.));\n    \n    pXpos.yz *= rotate2d(p.x*0.5);\n    pYpos.xz *= rotate2d(p.y*0.5);\n    pZpos.xy *= rotate2d(p.z*0.5);\n    \n    float pipeX = sdBox( pXpos , vec3(4,0.5,0.5) );\n    dist = min( dist, pipeX );\n    float pipeY = sdBox( pYpos, vec3(0.5,4.,0.5) );\n    dist = min( dist, pipeY );\n    float pipeZ = sdBox( pZpos, vec3(0.5,0.5,4.) );\n    dist = min( dist, pipeZ );\n    \n    return dist;\n}\nfloat map1(vec3 pOriginal){\n  vec4 p = vec4(pOriginal, 1); // w coordinate is our \"space scale\"\n  for(int i = 0; i < 5; i++){\n    if (p.x > p.y) p.xy = p.yx; // reflection\n    if (p.z > p.y) p.zy = p.yz; // reflection\n    p.xyz = abs(p.xyz) - 0.1; // reflection and movement\n    p *= 1.7;   // scaling\n    p.xyz = mod(p.xyz - 0.5,1.) - 0.5;   // simple space repetition\n  \n    p /= dot(p.xyz,p.xyz); // kleinian/sphere inversion\n  }\n  \n  p.xyz /= p.w; // VERY IMPORTANT, unscale/untransform back space\n\n  float distance = length(p.xyz); // INSERT ANY SDF HERE\n  return distance;\n}\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n\tvec4 orb = vec4(1000.0); \n\t\n\tfor( int i=0; i<7;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = getDist(p);\n    vec3 n = d-vec3(getDist(p-e.xyy), getDist(p-e.yxy), getDist(p-e.yyx));\n    return normalize(n);\n}\nvec2 rayMarchAll(vec3 ro, vec3 rd) {\n    float rayDist = 0.;\n    float steps = 0.;\n    for(int step = 0; step < MAX_STEPS; step++) {\n        vec3 pos = ro + rd*rayDist;\n        float distanceHit = map(pos, 1.3);\n        rayDist += distanceHit;\n        steps = float(step);\n        if(distanceHit < MIN_HIT || abs(rayDist) > MAX_DIST) break;   \n    }\n    return vec2(rayDist,steps);\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n    return rayMarchAll(ro, rd).x;\n    \n}\n\nvec3 getLight(vec3 p, vec3 sun) {\n    \n    vec3 n = getNormal(p);\n    float lighting = dot(n, normalize(sun-p));\n    lighting = clamp(lighting, 0., 1.);\n    \n    vec2 d = rayMarchAll(p+n*MIN_HIT*1.1, normalize(sun-p));\n    float baseCol = d.y/float(MAX_STEPS);\n    if(d.x < length(sun- p)) {\n       //lighting = lighting * 0.5;\n    }\n    \n\n    vec3 col = vec3(baseCol,1.-baseCol,step(baseCol, 0.9));\n    //col = vec3(baseCol);\n    return lighting*col;\n}\nvec3 cameraPath(float t) {\n    float x = sin(t*1.)*5.;\n    float y = cos(t*1.)*5.;\n    float z = t/3.1415926*20.+5.;\n    return vec3(x,y,z);\n}\n// https://www.shadertoy.com/view/WlKBDw thank you!!\nmat3 lookAt(in vec3 pos, in vec3 target) {\n    vec3 f = normalize(target - pos);         // Forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Right\n    vec3 u = cross(r, f);                     // Up\n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = map(iMouse.y/iResolution.y,0.,1.,1.7, 30.);\n    vec2 uv =  ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    \n    vec3 rayOrigin = vec3(-3.,-2.93,95.-iTime);\n    \n    vec3 cameraPx = vec3(uv.x, uv.y, 1.);\n    vec3 rayDir = normalize(cameraPx * lookAt(cameraPath(iTime), cameraPath(iTime+.5)*0.9));\n    rayDir.y *= -1.;\n    vec3 sun = vec3(0., 0., 0.);\n    sun = rayOrigin+vec3(0.,-1.8,0.);\n    \n    \n    float d = rayMarch(rayOrigin, rayDir);\n    if(d < MAX_DIST) {\n        vec3 p = rayOrigin+rayDir*d;\n\n        vec3 l = getLight(p, sun);\n        col = l;\n    }\n    col = applyFog(col, d);\n    // gamma correction\n    col = vec3(col.x*col.x, col.y*col.y, col.z*col.z);\n    fragColor = vec4(col*5.,1.);\n} \n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}