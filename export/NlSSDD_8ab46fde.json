{"ver":"0.1","info":{"id":"NlSSDD","date":"1627652933","viewed":105,"name":"Hexagon Rainbow","username":"ifurkend","description":"test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float depth = abs(1.0 - uv.y - 0.25) * 35.5 * (sin(iTime * 0.2) * 0.8 + 0.85);\n    uv -= 0.5;\n    uv *= 6.5;\n    uv.x *= max(iResolution.x, iResolution.y) / min(iResolution.x, iResolution.y);\n    uv /= depth;\n    //uv.x *= sin10(iTime * 0.2135, 0.25);\n    //uv.y *= sin1(iTime * 0.2135, 0.8);\n   \n    vec3 bgRainbow = \n        //Rainbow(fract(uv.x / (uv.y - 35.5) * 10.3 + iTime * 0.4));// + \n        Rainbow(fract(uv.x * (uv.y + 35.) * 0.00103 - iTime * 0.33)) ;\n    bgRainbow *= 0.175;\n    \n    const float pi = 3.141592653589793;\n    const float tau = 6.283185307179586;\n    const float sides = 6.0;\n    const float angDiv = tau / sides;\n    \n        \n    uv *= RotationMatrix(pi + iTime * 0.3);\n    uv += iTime * 0.333;\n    \n    float squash = 0.877;\n    uv.y /= squash;\n    vec2 gv = floor(uv);\n    float shift = fract(gv.y * 0.5) == 0.0 ? 0.5 : 0.0;\n    uv.x += shift;\n    uv = fract(uv) - 0.5;\n    uv.y *= squash;\n    \n    float angle = atan(uv.x/uv.y);\n    angle += uv.y < 0.0 ? pi : 0.0;\n    angle += angle < 0.0 ? tau : 0.0;\n    float angFrac = fract(angle * sides / tau) * angDiv;\n    \n    float beta = (pi - angDiv) * 0.5;\n    float phi = pi - angFrac - beta;\n    \n    float radius = length(uv.xy);\n    //radius = 1.0 - radius;\n    \n    //No idea why sin(phi) and sin(beta) shouldn't be inverted (according to the law of sines) to make this work:\n    float dist = radius * sin(phi) / sin(beta);\n    \n    float dir = shift * 4.0 - 1.0;\n    dist = cos01(dist * 10.78 * pow(3.0, 1.0) + iTime * 2.0 * dir);\n    //dist = sin01(dist * 8.1 * pow(3.0, 2.0) + iTime * 2.0 * dir);\n    float line = 1.;\n    //line = ((dist < 1.1) && (dist > 0.97) ? 1.0 : 0.0);//grainy\n    line = mixShift(1. - dist, 10., 7.);\n    line *= 1. - mixShift(1. - dist, 10., 0.);\n    //float aaf = 3./iResolution.x;\n    //aaf = fwidth(line * 2.5);\n    //line = smoothstep(0., aaf, line);\n    //dist = pow(dist, 0.5) * 0.13 - 0.1 + line;\n    vec3 col = Rainbow(cos01(dist * 0.745 - iTime * 2.0));\n    col = col * smoothstep(0.0, 1.0, pow(dist, 0.3) * 0.4) + line * 0.4;\n    \n    float ring = clamp(radius / squash * 2.0, 0.0, 1.0);\n    ring = smoothstep(0.0, 1.0, 1.0 - abs(ring * 2.0 - 1.0));\n    \n    vec3 radialRainbow = Rainbow(fract(angle/tau + iTime * dir * 0.23)) * ring;\n    radialRainbow *= 0.5;\n    col += radialRainbow;\n    col *= clamp(depth - 0.05, 0.0, 1.0);\n    col += bgRainbow * clamp(depth + 0.0, 0.0, 1.0);\n    \n    // Output to screen\n    fragColor = vec4(dist,dist,dist, 1.0);\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(radialRainbow, 1.0);\n    //fragColor = vec4(uv, dist, 1.0);\n    //fragColor = vec4(depth - 0.5, 0., 0., 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Simple rainbow gradient with entirely linear interpolation.\n//It is totally unrealistic compared to visible spectrum in reality. \nvec3 Rainbow(float t) {\n\tvec3 c = vec3(1.0,0.0,0.0);//red\n\t\n\tt *= 6.0;\n\tc.g = mix(0.0, 1.0, clamp(t, 0.0, 1.0));//red to yellow\n\t\n\tt -= 1.0;\n\tc.r = mix(1.0, 0.0, clamp(t, 0.0, 1.0));//yellow to green\n\t\n\tt -= 1.0;\n\tc.b = mix(0.0, 1.0, clamp(t, 0.0, 1.0));//green to cyan\n\t\n\tt -= 1.0;\n\tc.g *= mix(1.0, 0.0, clamp(t, 0.0, 1.0));//cyan to blue\n\t\n\tt -= 1.0;\n\tc.r += mix(c.r, 1.0, clamp(t, 0.0, 1.0));//blue to purple\n\t\n\tt -= 1.0;\n\tc.b *= mix(1.0, 0.0, clamp(t, 0.0, 1.0));//purple to red\n\t\n\treturn clamp(c, 0.0, 1.0);\n}\n\nmat2 RotationMatrix(float rotAng) {\n    vec2 rot = vec2(cos(rotAng), sin(rotAng));\n    return mat2(rot.x, rot.y, -rot.y, rot.x);\n}\n\nfloat mixShift(float x, float t, float o) {\n    return clamp(x * t + o, 0., 1.);\n}\n\n//sin and cos return the value between -1 to +1,\n//so I normalize them to the range of 0 to +1 to save me few codes:\nfloat sin01(float x) {\n    return sin(x) * 0.5 + 0.5;\n}\n\nfloat cos01(float x) {\n    return cos(x) * 0.5 + 0.5;\n}\n\nfloat sin10(float t, float a) {\n    return 1.0 - sin(t) * a - a;\n}\n\nfloat cos10(float t, float a) {\n    return 1.0 - cos(t) * a - a;\n}\n\nfloat sin1(float t, float a) {\n    return sin(t) * a + a + 1.0;\n}\n\nfloat cos1(float t, float a) {\n    return cos(t) * a + a + 1.0;\n}\n","name":"Common","description":"","type":"common"}]}