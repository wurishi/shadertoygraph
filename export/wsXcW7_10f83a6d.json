{"ver":"0.1","info":{"id":"wsXcW7","date":"1634472775","viewed":105,"name":"Eikonal Voronoise 1D","username":"spalmer","description":"extending concept of [url]https://shadertoy.com/view/wlt3z8[/url] and [url]https://shadertoy.com/view/Ws3XWl[/url] to 1D then probably back up to 2D and 3D my way","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// idk why I never public'd this.\n// Guess I never got around to cleaning it up?\n// Got used in Biker 2D  https://shadertoy.com/view/tdjBzW\n\nconst int LEVELS = 4;\nconst float SCALE = 12.;//10.; //8.; //12.; //16.; //256.; //64.; //\n// FIXME I get the feeling if I did this unsigned\n// it wouldn't be nearly so complicated to sum up.\nfloat tent1(float x)\n{\n    return max(0., 1.-abs(x)); //fract(x); //\n}\n// FIXME if had some y coordinate available, could estimate some point distance at vertex, better than nothing!\n// but seems only viable for 2+ dimensions?  unsure what is proper for 1D.\n\nfloat noise1(float x)\n{\n//    return sin(1.5*x);\n    float o = x;\n    x = mod(x - 1., 2.) - 1.;\n    float y = sin(3.1415927*(sqrt(5.)+1.)*floor((o-1.)/2.)); // some pseudorandom hash\n    //if (x < 0.) x += 2.;\n\tfloat v = tent1(x); // - y);\n    v *= sqrt(.5); // fix sheared 'distance' measurements - but this is 1D so unsure it's even a good thing to try\n    if (y < 0.) v = -v; //v *= sign(y);\n    return v;\n    // TODO 1D voronoise stuff\n}\n// basically want to integrate a bunch of step function derivatives or something\n// Eikonal is trivial in 1D, doesn't even involve square roots,\n// but extending it back to 2D and above is trickier.\nfloat fbm1(float x)\n{\n    float d = -1. //1. //0. //\n    , s = 1.;\n    for (int i = LEVELS; --i >= 0; s *= .5, x *= 2.) {\n        //d += noise1(x);\n        float n = s * noise1(x);\n        //d += n;\n        //if (n < d)\n        //d = min(d, n);\n        //else\n        d = max(d, n);\n        //d = n; //\n    }\n    //d *= .5 / (1.-s); // 'normalize' after adding\n    //d /= float(LEVELS);\n    return d;\n}\n\nfloat lodshape(float dshape, float dlod, float fade)\n{\n    float b = abs(dlod);\n    if (b >= fade) return dlod;\n    if (b <= 0.) return dshape;\n    float a = abs(dshape);\n    return mix(dshape, dlod, b / fade); //pow(b / fade, .7)); //clamp(b / fade, 0., 1.));\n}\n\nconst float fade = 9., slab = 1.;\n\n// lod blend to a linear eikonal slab function if outside -1..1 range\n// seems like it's cheating, kinda; technique could be used on\n// any noisy pseudo-SDF that approximates a slab, such as sin or cos.\n// But even in 1D I don't want steps far away to have to deal with the\n// fluctuations from the details.  From a far distance, every shape\n// appears to fill its entire volume even if up close the details\n// make that volume full of small gaps.  Plus LOD is important to\n// prevent evaluating expensive functions unnecessarily when far away from them.\n// so this is basically just an LOD bounding slab shape for the noise.\n// but it seems if I did the noise eikonally, I wouldn't need this?\n// and it still doesn't fix sdf problems near the shape surface.\nfloat lnoise1(float x, float y)\n{\n    float n = fbm1(x);\n    float d0 = y - n, d1 = sign(y) * max(0., abs(y) - slab); //abs(y) < slab ? 0. : sign(y) * (abs(y) - slab)\n    return lodshape(d0, d1, fade);\n    float a = abs(y);\n    if (a > fade + slab) return sign(y) * max(0., a - slab);\n    float d = y - n;\n    if (abs(y) > slab) {\n        float dlod = sign(y) * (a - slab);\n        d = mix(d, dlod, clamp((a - slab) / fade, 0., 1.));\n    }\n    return d;\n}\n        \t//mix(dlod, d, exp2(-3.*(abs(y) - 1.)));\n\n\n// \"standard\" sdf gradient debugging by iq   \nvec3 DebugSDFa(float d)\n{\n    vec3 col = vec3(1) - sign(d)*vec3(.1,.5,.9);\n\tcol *= 1. - exp(-2.*abs(d));\n\tcol *= .8 + .2*cos(120.*d);\n    return mix(col, vec3(1), 1.-smoothstep(.0,.02,abs(d))); // white at zero\n}\n// some other thing, different colors\nvec3 DebugSDFb(float d)\n{\n    vec2 R = iResolution.xy;\n    float g = .5-.5*cos(d * R.y * .5);\n\tvec3 c = vec3(g);\n    if (d < 0.) c.rb *= 0.; else c.rg *= 0.2; //c.rg = 1.-c.rg; else c.gb = 1.-c.gb;\n    c += exp2(-.5*iResolution.y * abs(d));\n//    if (abs(abs(q.y) - 1./SCALE) <= 2./R.y) c.r += .3; // verify vertical range\n//    if (abs(abs(q.y) - (fade + slab)/SCALE) <= 2./R.y) c.bg += vec2(.3); // verify vertical range of fade\n    return c;\n}\n\nvec3 DebugSDF(float d)\n{\n    return \n        DebugSDFa //DebugSDFb //\n        (d);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 R = iResolution.xy, q = (p+p-R)/R.y;\n    q.x += .02 * iTime; if (iMouse.z >= 0.) q *= .6; // scroll, click to zoom\n    float d = lnoise1(q.x * SCALE, q.y * SCALE) / SCALE;\n    vec3 c = DebugSDF(d);\n\tc = pow(c, vec3(.4545));\n    o = vec4(c, 1);\n}\n\n    //vec3 c = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n","name":"Image","description":"","type":"image"}]}