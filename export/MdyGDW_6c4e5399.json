{"ver":"0.1","info":{"id":"MdyGDW","date":"1454554819","viewed":1273,"name":"Monte Carlo Test","username":"Swax97","description":"An attempt at Monte Carlo rendering","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raycast","montecarlo","buffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Display the buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Hash functions (randomized by frame #)\nfloat hash(float n) {\n    n+=0.1*float(iFrame);\n    return fract(sin(n * 12.9898)*43758.5453);\n}\nfloat hash2(vec2 n){\n    n+=0.1*float(iFrame);\n    return fract(sin(dot(n, vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat hash3(vec3 n) {\n    n+=0.1*float(iFrame);\n    return fract(sin(dot(n, vec3(12.9898,78.233,471.17))) * 43758.5453);\n}\n\n//Generate a random ray in a rotated unit hemisphere\n/*vec3 hemi(vec3 d, float n){\n    float a = hash(n) * 6.283 * 2.0;\n    vec3 p = hash(-n) * vec3(sin(a), cos(a), 0.0);\n    \n    p.z = sqrt(1.0 - p.x*p.x - p.y*p.y);\n    \n    if (a < 6.283)\n        p.z = -p.z;\n    \n    \n    //if on wrong side of reflection plane\n    if (dot(p, d) < 0.0) \n        return p - 2.0 * dot(p, d) / dot(d, d) * d;\n    return p;\n}*/\nvec3 hemi(vec3 d, float n){\n    float a = hash(n) * 6.283 * 2.0;\n    float b = hash(-n) * 6.283 * 2.0;\n    \n    vec3 p = vec3(sin(a)*cos(b), sin(a)*sin(b), cos(a));\n    \n    //if on wrong side of reflection plane\n    if (dot(p, d) < 0.0) \n        return p - 2.0 * dot(p, d) / dot(d, d) * d;\n    return p;\n}\n//Generate a (non-uniform) random ray in a rotated unit hemisphere\nvec3 hemi_spec(vec3 d, float n){\n    float a = hash(n) * 6.283 * 2.0;\n    vec3 p = pow(hash(-n), 4.0) * vec3(sin(a), cos(a), 0.0);\n    \n    p.z = sqrt(1.0 - p.x*p.x - p.y*p.y);\n    \n    if (a < 6.283)\n        p.z = -p.z;\n    \n    \n    //if on wrong side of reflection plane\n    if (dot(p, d) < 0.0) \n        return p - 2.0 * dot(p, d) / dot(d, d) * d;\n    return p;\n}\n\n//Analytical sphere\nfloat sphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 o = ro - sph.xyz;\n    float b = dot(o, rd);\n    float c = dot(o, o) - sph.w * sph.w;\n    float h = b*b - c;\n    if (h > 0.0)\n        return - sqrt(h) - b;\n    return -1.0;\n}\nvec3 sphereNormal(vec4 sph, vec3 p) {\n    return (p - sph.xyz) / sph.w;\n}\n\n//Scene function (cannot vary with time)\nvec4 intersect(vec3 ro, vec3 rd, out vec3 col) {\n    vec4 sph1 = vec4(+0.8, 0, 1.0, 1);\n    vec4 sph2 = vec4(-1.2, -0.6, 1.5, 1);\n    \n    float t = 1000.0, i;\n    vec3 n = vec3(0.0);\n   \n    \n    //Intersect with spheres\n    i = sphere(ro, rd, sph1);\n    if (i > 0.0){\n        t=i;\n        n = sphereNormal(sph1, ro + rd * t);\n        col = vec3(1.0, 0.75, 0.3);\n    }\n    \n    i = sphere(ro, rd, sph2);\n    if (i > 0.0 && i < t){\n        t=i;\n        n = sphereNormal(sph2, ro + rd * t);\n        col = vec3(0.3, 0.9, 0.8);\n    }\n    \n    //Ground\n    i = -(ro.y - 1.0) / rd.y;\n    if (i > 0.0 && i < t){\n        t=i;\n \t\tn = vec3(0.0, -1.0, 0.0);\n        col = vec3(0.5, 0.8, 0.5);\n    }\n    \n    //Wall\n    /*i = -(ro.z - 2.0) / rd.z;\n    if (i > 0.0 && i < t){\n        t=i;\n \t\tn = vec3(0.0, -1.0, 0.0);\n        col = vec3(1.0, 1.0, 1.0);\n    }*/\n    \n    i = -(ro.x - 2.0) / rd.x;\n    if (i > 0.0 && i < t){\n        t=i;\n \t\tn = vec3(1.0, 0.0, 0.0);\n        col = vec3(0.1, 0.1, 1.0);\n    }\n    \n    i = -(ro.x + 2.0) / rd.x;\n    if (i > 0.0 && i < t){\n        t=i;\n \t\tn = vec3(-1.0, 0.0, 0.0);\n        col = vec3(1.0, 0.1, 0.1);\n    }\n    \n    return vec4(n, t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (iResolution.xy - fragCoord * 2.0) / iResolution.y;\n    vec2 mp = (iResolution.xy - iMouse.xy * 2.0) / iResolution.y;\n    \n    float rnd = 10.0 * hash2(uv);\n    \n    \n    vec3 light = vec3(0.0, -.701, -.701);\n    \n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 0.9));\n    \n    vec4 s = vec4(rd, 0);\n    \n    float rc = 1.0;\n    \n    vec3 col = vec3(0.0);\n    vec3 mcol = vec3(0.0);\n    vec3 scol = vec3(0.0);\n    \n    //trace\n    for (int i = 0; i < 40; i++){\n        s = intersect(ro, rd, mcol);\n        if (s.w > 999.) break;\n        \n        \n\t\t\n        ro += s.w * rd;\n        rd = normalize(reflect(rd, s.xyz)*0.7+0.3*hemi(s.xyz, rnd + float(i)));\n        ro += rd * 0.0001;\n        \n        \n        if (intersect(ro, \n                      light, \n                      scol).w > 999.) {\n            float d = max(0.0, dot(rd, light));\n            d = 0.4 * d + 0.4 * d*d*d*d*d*d + 0.4;\n        \tcol += rc * mcol * d / (1.0 + dot(ro, ro) * 0.03);\n        }\n        \n        rc *= 0.45;\n    }\n    \n    \n    //accumulate image\n    vec4 new = vec4(vec3(col), 1.0);\n    vec4 old = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    float frame = float(iFrame);\n    if (frame > 0.5)\n    \tfragColor = ((frame - 1.0) * old + new) / frame;\n    else \n        fragColor = new;\n}\n\n\n\n","name":"Buf A","description":"","type":"buffer"}]}