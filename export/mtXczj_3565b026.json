{"ver":"0.1","info":{"id":"mtXczj","date":"1690938587","viewed":59,"name":"Angled Pixel Stretch","username":"mehow_one","description":"Exploring this effect i've been trying to figure out for a while.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["displacement","pixel","stretch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = 0.5 * (1.0 + sin(iTime));\n    vec2 center = vec2(0.5,0.5); // Center at (0.5, 0.5) in normalized coordinates\n    float angleDegrees =time*180.;\n    float angleRadians = radians(angleDegrees);\n    vec2 direction = vec2(cos(angleRadians), sin(angleRadians));\n    float maxDistance = length(center - vec2(0.5));\n    float distanceToLine = dot(uv - center, direction);\n    vec2 closestPoint = center + direction * distanceToLine;\n    float distanceToClosestPoint = length(uv - closestPoint);\n    \n    \n    float lineWidthMax = 0.25;\n    float lineWidthAnimation = lineWidthMax; // * time;\n\n    vec3 finalColor = vec3(0.);\n    float side = sign(dot(uv - center, vec2(-direction.y, direction.x)));\n    if (side > 0.0) {\n        // If the fragment is on the positive side, move the iChannel0 image in the perpendicular direction\n        vec2 perpendicularDirection = normalize(vec2(-direction.y, direction.x));\n        vec2 displacedCoord = perpendicularDirection * lineWidthAnimation;\n        vec4 channel0Color = texture(iChannel0, (uv - displacedCoord));\n        finalColor = channel0Color.rgb;\n    } else if (side < 0.0) {\n        vec2 perpendicularDirection = normalize(vec2(-direction.y, direction.x));\n        vec2 displacedCoord = perpendicularDirection * lineWidthAnimation;\n        vec4 channel0Color = texture(iChannel0, (uv + displacedCoord));\n        finalColor = channel0Color.rgb;\n    }\n    // Sample the pixel color from iChannel0 image for the pixels along the line\n    if (distanceToClosestPoint <= lineWidthAnimation) {\n        vec4 channel0Color = texture(iChannel0, closestPoint);\n        finalColor = channel0Color.rgb;\n        //finalColor = mix(finalColor, channel0Color.rgb, channel0Color.a);\n    }\n    // small fix to hide ugly aliasing at the seam\n    fragColor = lineWidthAnimation < 0.001 ? texture(iChannel0, (uv)) : vec4(finalColor, 1.0);\n}\n\n\n\n\n//float gradient = (1.0 + side) * 0.5; // Map [-1, 1] to [0, 1]","name":"Image","description":"","type":"image"}]}