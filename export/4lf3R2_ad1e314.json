{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float sdSphere(vec3 p,float s)\n{\n    return length(p) - s;\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 map(in vec3 pos)\n{\n    //return vec2(sdSphere( pos - vec3(0.,0.25,0.),0.25),46.9);\n    //vec2 res = opU(vec2( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),43.5 ) ,\n\t                //vec2( sdSphere(    pos-vec3( -2.0,0.25, 1.0), 0.25 ), 46.9 ) );\n    vec2 res = vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) ;\n    res = opU(res,vec2(sdPlane( pos - vec3(0.0, -2.0,1.0)),1.0));\n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    \n    for(int i = 0;i<50;i++)\n    {\n        vec2 res = map(ro+rd*t);\n        if(res.x < precis || res.x > tmax)break;\n        t += res.x;\n        m = res.y;\n    }\n    if (t>tmax)\n        m = -1.0;\n    return vec2(t,m);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n    return normalize(nor);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.8,0.9,1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n    float m = res.y;\n    if( m > -0.5)\n    {\n    \tvec3 pos = ro + t*rd;\n    \tvec3 nor = calcNormal( pos );\n   \t\tvec3 lig = normalize(vec3(-0.6,0.7,-0.5));\n    \tvec3 ref = reflect(rd,nor);\n    \tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n    \n    \tvec3 brdf = vec3(0.0);\n    \tbrdf += 1.20*dif*vec3(1.0,0.9,0.6);\n    \tbrdf += 0.02;\n        col = col*brdf;\n        \n        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n    }\n    \n    return vec3(clamp(col,0.0,1.0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n     vec3 col = render( ro, rd );\n     col = pow( col, vec3(0.4545) );\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4lf3R2","date":"1423232411","viewed":193,"name":"IQ's distance function test","username":"thu_yumeng","description":"thanks iq introduce me the world of computer graphics,and all my friends who help me :) this is just test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["iq"],"hasliked":0,"parentid":"","parentname":""}}