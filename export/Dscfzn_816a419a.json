{"ver":"0.1","info":{"id":"Dscfzn","date":"1696784875","viewed":57,"name":"_Raymarching Line Space","username":"hyrofumi","description":"_Raymarching Line Space","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchinglinespace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define S(a, b, t) smoothstep(a, b, t)\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    const vec3 up = normalize(vec3(0, 1, 0));\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nfloat map(vec3 p)\n{\n    // Ping Pong on 0.5\n    vec3 q = abs(p);\n    q = abs(q - round(q));\n    \n    mat2 rm = Rotate(sin(iTime * 0.1));\n    q.xy *= rm;\n    q.xz *= rm;\n    \n    float l1 = length(q.xy);\n    float l2 = length(q.yz);\n    float l3 = length(q.xz);\n    \n    float d = min(min(l1, l2), l3);\n    // d = min(roundBoxSDF(p, vec3(0.5), 0.5), min(min(length(l1), length(l2)), length(l3)) + .01);\n    \n    // d = smoothUnionSDF(smoothUnionSDF(l1, l2, 0.1), l3, 0.1);\n    // d = smoothUnionSDF(d, roundBoxSDF(p, vec3(1.5), 0.5), 0.5);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - R.xy) / R.y;\n    vec2 uv2 = (2. * (fragCoord.xy) - iResolution.xy) / iResolution.x;  //現在の画素位置を0.0-1.0に正規化\n\n    vec2 mouse = (2.0 * (iMouse.xy / R.xy) - 1.0) * 5.0 + 0.1;\n    vec3 ro = vec3(mouse, iTime * 0.5);\n    vec3 ta = vec3(0.0, sin(iTime), iTime * 0.5 + 1.5);\n    \n    ro = vec3(uv2.xy, Time * 0.5);\n    ta = vec3(0.);\n    \n    vec3 ray = camera(ro, ta) * normalize(vec3(uv2, 1.5));\n    \n    float d = 0.0;\n    \n    float dist = 0.0;\n    float i = 24. * (1. - exp(-.2 * Time - .1));\n    for(;i-->0.;)\n    {\n        dist = map(ro + ray * d) / 2.;\n                \n        if (dist < 0.01)\n        {\n            // break;\n        }\n                \n        d += dist;\n    }\n    \n    vec3 col = vec3(0.0);\n    \n    if (dist < 0.01)\n    {\n        float r = 1.0 - d;\n        float g = exp(-d * 0.30) * 2.0;\n        float b = exp(-d * 0.50) * 2.0;\n        col = vec3(r, g, b);\n    }\n    \n    fragColor = vec4(vec3(1.0 - d, exp(-d), exp(-d/2.)), 1.0);\n    \n    // fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////\n// Constants\n/////////////////////////////\n#define Time iTime\n#define PI 3.1415925359\n#define PI2 PI*2.\n#define TAU PI*2.\n#define MAX_STEPS 100// Mar Raymarching steps\n#define MAX_DIST 100.// Max Raymarching distance\n#define SURF_DIST .001// Surface Distance\n\n\n/////////////////////////////\n// struct\n/////////////////////////////\nstruct Dist {\n    float d;\n    float ds;\n    float t;\n};\n\n/////////////////////////////\n// primitives\n/////////////////////////////\n// Round Box\nfloat roundBoxSDF( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Box\nfloat boxSDF( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\n\n// Sphere\nfloat sphereSDF(vec3 p,float r){\n    return length(p) - r;\n}\n\n/////////////////////////////\n// transform\n/////////////////////////////\n\n// Rotate\nmat2 Rotate(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n/////////////////////////////\n// Smooth blending operators\n/////////////////////////////\n \nfloat smoothIntersectSDF(float distA, float distB, float k ) {\n  float h = clamp(0.5 - 0.5*(distA-distB)/k, 0., 1.);\n  return mix(distA, distB, h ) + k*h*(1.-h); \n}\n \nfloat smoothUnionSDF(float distA, float distB, float k ) {\n  float h = clamp(0.5 + 0.5*(distA-distB)/k, 0., 1.);\n  return mix(distA, distB, h) - k*h*(1.-h); \n}\n \nfloat smoothDifferenceSDF(float distA, float distB, float k) {\n  float h = clamp(0.5 - 0.5*(distA+distB)/k, 0., 1.);\n  return mix(distA, -distB, h ) + k*h*(1.-h); \n}","name":"Common","description":"","type":"common"}]}