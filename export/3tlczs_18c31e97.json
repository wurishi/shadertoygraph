{"ver":"0.1","info":{"id":"3tlczs","date":"1592836128","viewed":113,"name":"Noise DFT Analysis","username":"spalmer","description":"Copy of [url=https://shadertoy.com/view/XtScWt]toy by FabriceNeyret2[/url] but customized to perform analysis of noise.\nTop left=A=noise to analyze, bottom left=B=DFT of A, bottom right=C=frequency to analyze, top right=D=InvDFT of C.\n\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["noise","frequency","fourier","bluenoise","whitenoise","dft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// customized FabriceNeyret2 http://shadertoy.com/view/XtScWt to show noises comparisons\n\nfloat showDFT(vec2 v)\n{\n    return length(v); //log2(max(1e-9, .1/SIZE * dot(v,v)));\n}\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    vec2 r = iResolution.xy;\n    vec2 pixel = q - .5*r,\n        tile = floor(pixel / SIZE);\n    q = fract(pixel / SIZE) * SIZE;\n\n    float n = .5;                                // default gray background\n    if (tile == vec2(-1,0)) // top left\n        n = T(iChannel0, q.x, q.y).x;            // initial texture\n    else if (tile == vec2(-1,-1)) // bottom left\n        n = showDFT(T(iChannel1, q.x, q.y).xy);  // initial spectrum\n    else if (tile == vec2(0,-1)) // bottom right\n        n = showDFT(T(iChannel2, q.x, q.y).xy);  // transformed spectrum\n    else if (tile == vec2(0,0)) // top right\n        n = T(iChannel3, q.x, q.y).x;            // transformed texture\n\n    o = vec4(n);\n    o.rb *= clamp((.5-abs(q-.5*SIZE)/SIZE)*.5*SIZE, 0., 1.); // gridlines\n//  o.rgb = pow(o.rgb, 1./2.2); // srgb gamut - idk\n}\n// the left half shows the \"before operator\" image & spectrum\n// (the source in BufferA and its frequency domain equivalent in BufferB)\n// and right half shows the \"after operator\" image & spectrum\n// where the operator is applied in frequency domain in BufferC\n// prior to reconvolution back to spatial domain over in BufferD\n\n// We don't even need the right half, here;\n// I only keep it just to prove I can still\n// inverse DFT back to the original signal.","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// DFT can only handle square images\n// In this case we only capture data \n// for the size of the final displayed output\n// and all the analysis is done in that resolution\n// Size shared between tabs.\n#define SIZE 256.\n// HACK hard-coded here\n// helps force 1:1 texel:pixel ratio\n// though TODO should be a way to do that\n// more elegantly that actually supports\n// variable viewport sizes better.\n\n//#define T(ch,x,y) texture(ch, vec2(x,y)/iResolution.xy )\n#define T(ch,x,y)  texelFetch(ch, ivec2(x,y), 0)\n// size of texture channel\n#define Tsize(ch) textureSize(ch, 0)\n// e^(i*pi*t) * v, unsure what to call it, but certainly not cmul\n// (although it involves a complex multiplication, here done using a matrix)\nvec2 ACC(vec2 v, float t) { vec2 s = vec2(cos(t),sin(t)); return mat2(s,-s.y,s.x) * v; }\n// I had this going the other way for a while, on accident,\n// apparently the sign makes no difference here, in this toy at least.\n\nconst float tau = 2.*acos(-1.); //6.2831853","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// source signal\n\n// choose channel for input source\nconst int method = 2; // HACK hard coded, just switch & recompile \n\nfloat bluenoisetex (vec2 p); // 0\nfloat bluenoise    (vec2 p); // 1\nfloat bluenoise5   (vec2 p); // 2\nfloat bluefabrice  (vec2 p); // 3\nfloat bluefabrice5 (vec2 p); // 4\nfloat violetnoise  (vec2 p); // 5\nfloat whitenoise   (vec2 p); // 6\n\nfloat makeNoise(vec2 p)\n{\n    float n;\n    switch (method) {\n        case 0: n = bluenoisetex(p); break; // shows some artifacts probably from texture sampling or quantization but has characteristic frequency distribution\n        default:\n        case 1: n =    bluenoise(p); break; // good\n        case 2: n =   bluenoise5(p); break; // not so good\n        case 3: n =  bluefabrice(p); break; // looks much like the blue noise texture, some minor clumping artifacts maybe?\n        case 4: n = bluefabrice5(p); break; // slightly worse\n        case 5: n =  violetnoise(p); break; // seems vaguely like the texture blue noise, just not so much, as expected!\n        case 6: n =   whitenoise(p); break; // looks random, well-distributed in frequency domain\n    }\n    return n;\n}\n\n// Wellons lowbias32 from http://nullprogram.com/blog/2018/07/31\n// perhaps the best ever devised for this op count, great distribution and cycle\nuint hashWellons2(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352du;\n    x ^= x >> 15;\n    x *= 0x846ca68bu;\n    x ^= x >> 16;\n    return x;\n}\n// minimal bias version bit hash, near perfect, bit more expensive.\n// http://nullprogram.com/blog/2018/07/31\nuint hashWellons3(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbu;\n    x ^= x >> 11;\n    x *= 0xac4c1b51u;\n    x ^= x >> 15;\n    x *= 0x31848babu;\n    x ^= x >> 14;\n    return x;\n}\n// http://pcg-random.org\nuint hashPCG(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\n// selector wrapper\nuint hash(uint x)\n{\n    return\n        hashWellons2 //hashPCG //hashWellons3 //\n        (x);\n}\n\n// hashes uint seed to single precision fraction\nfloat fhash(uint u)\n{\n    return float(hash(u) >> 9) * exp2(-23.);\n}\n\nfloat hashfbits(float x)\n{\n    return fhash(floatBitsToUint(x));\n}\n\nfloat hashBits(vec2 p)\n{\n    return hashfbits(p.x + (p.y-.5) * iResolution.x);\n}\n\n// or can work on the floats directly (or try)\n#if 0\n// Hoskins hash without sine from http://shadertoy.com/view/4djSRW\nfloat hashHoskins(vec2 p)\n{\n\tvec3 q = fract(vec3(p.xyx) * .1031);\n    q += dot(q, q.yzx + 19.19);\n    return fract((q.x + q.y) * q.z);\n}\n// Jorge Jimenez Interleaved Gradient Noise\n// http://iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat hashIGN(vec2 uv) \n{\n    return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))));\n}\n// http://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat hashSinus(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n#endif\n\nfloat hash21(vec2 p)\n{\n\treturn\n        hashBits //hashHoskins //hashIGN //hashSinus //\n        (p);\n}\n\n// 1st derivative in direction, central difference\n// f'(x) = (f(x+y) - f(x-y)) / (2|y|)\n#define diff2(f, x, y) (((f((x) + (y))) - (f((x) - (y)))) / (2.*length(y)))\n\n// 2nd derivative\n// f''(x) = ((f'(x+y) - f'(x)) / (|y|) \n//         - (f'(x) - f'(x-y)) / (|y|)) / (|y|)\n#define diff3(f, x, y) (((f((x) + (y))) + (f((x) - (y))) - 2.*(f((x)))) / dot(y,y))\n\nfloat whitenoise(vec2 p)\n{\n    return hash21(p);\n}\n\n// In a pinch, violet noise has most of the good properties\n// of blue noise (halfway blue-ish spectrum) and may be \n// computed with only 3 taps of white noise, good enough\n// for some purposes anyway, if blue is too expensive \n// and texture not available for some reason.  This uses 4 taps.\nfloat violetnoise(vec2 p)\n{\n    p *= 2.;\n    return .5 \n        + diff2(hash21, p, vec2(1,0))\n        + diff2(hash21, p, vec2(0,1));\n}\n\n// just writing it out mostly longhand, inlined version of bluenoise, though, basically\nfloat bluenoise5(vec2 p)\n{\n    return hash21(p)\n        - 1./4. * (\n\t\t\thash21(p + vec2( 1,0))\n\t\t+\thash21(p + vec2(-1,0))\n\t\t+\thash21(p + vec2(0, 1))\n\t\t+\thash21(p + vec2(0,-1))\n        ) + .5;\n}\n// compiler should optimize the 6 taps down to 5\nfloat bluenoise(vec2 p)\n{\n    return 1./4. * (\n          diff3(hash21, p, vec2(1,0)) \n        + diff3(hash21, p, vec2(0,1))\n        ) + .5;\n}\n\n#if 1\n// Fabrice cheap bluenoise from http://shadertoy.com/view/tllcR2\n// choose stencil arrangement\nfloat bluefabrice(vec2 u) \n{\n    float v = 0.;\n    for (int k = 0; k < 9; ++k)\n        v += hash21(u + vec2(k%3 - 1, k/3 - 1)); \n    // accounts for duplicated center sample\n    return .9/8. *(9. * hash21(u) - v) + .5;\n}\n// 5-tap version \nfloat bluefabrice5(vec2 u) \n{\n    float v =  hash21(u + vec2(-1, 0))\n             + hash21(u + vec2( 1, 0))\n             + hash21(u + vec2( 0, 1))\n             + hash21(u + vec2( 0,-1)); \n    return  hash21(u) - v/4.  + .5;\n}\n\n#endif\n\nfloat bluenoisetex(vec2 p)\n{\n    #define BNCH iChannel1\n    float g = texelFetch(BNCH, ivec2(p) % Tsize(BNCH), 0).x;\n    return g; //pow(g, 2.2); //\n}\n\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    float n = .5;\n    if (max(q.x,q.y) < SIZE)\n        n = makeNoise(q);\n    vec2 v = vec2(n,0); // real component in x, leave imaginary in y at zero\n    o = vec4(v,0,0); // output to xy components\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Fourier transform of the input\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// of the input spatial domain data to frequency domain\n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// adapted from Flyguy's http://shadertoy.com/view/MscGWS\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    o = vec4(0);\n    \n    if (q.x > SIZE || q.y > SIZE) return;\n\n    for (float n = 0.; n < SIZE; ++n) {\n        float m = n + .5;\n        vec2 xn = T(iChannel0, m, q.y).xy,\n             yn = T(iChannel1, q.x, m).zw,\n             a = -tau * (q-.5 - .5*SIZE) * n / SIZE;\n\n        o.zw += ACC(xn, a.x);\n        o.xy += ACC(yn, a.y);\n    }\n    o *= 2.*log2(SIZE)/SIZE;\n}\n\n// due to the fourier conversion pipelining,\n// takes 2 frames for data to flow through properly","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// no operation in spectral domain\n// just copies from BufferB currently\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    vec2 r = iResolution.xy;\n    vec2 t = T(iChannel0, q.x,q.y).xy;\n    q -= .5;  // freq 0 must exist\n    vec2 X = 2./SIZE * q - 1.;\n    float l = length(X);\n    //l += 1e-7; //l = max(l, 1e-7); //\n    //T = vec2(1.-exp2(-1.4*l*l), 0);\n    //T = vec2(2.*l, 0);\n    o = vec4(t,0,0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// invFourier transform\n// Horizontal + Vertical Discrete Inverse Fourier Transform\n// of the processed freq domain data back to spatial domain\n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// adapted from Flyguy's http://shadertoy.com/view/MscGWS\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    o = vec4(0);\n    \n    if (q.x > SIZE || q.y > SIZE) return;\n\n    for (float n = 0.; n < SIZE; ++n) {\n        float m = mod(n+SIZE/2.,SIZE) + .5;       // wrap [-1/2,1/2] to [0,1] to warp 0,0 to mid-window.\n        vec2 xn = T(iChannel0, m, q.y).xy,\n             yn = T(iChannel1, q.x, m).zw,\n             a =  tau * (q-.5          ) * n / SIZE;\n\n        o.zw += ACC(xn, a.x);\n        o.xy += ACC(yn, a.y);\n    }\n    o /= 2.*log2(SIZE);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}