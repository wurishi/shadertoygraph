{"ver":"0.1","info":{"id":"MtlfRs","date":"1513021684","viewed":1269,"name":"Simple Reflection","username":"zackpudil","description":"Nothing new in technique or optimizations.  Was just messing around on and thought it looked nice.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec2 n) {\n\treturn fract(dot(vec2(sin(n.x*2343.34), cos(n.y*30934.0)), vec2(sin(n.y*309392.34), cos(n.x*3991.0))));\n}\n\n// Minkowski operators, can be seen at http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.803&rep=rep1&type=pdf\n// It's a paper on generalized distance functions, but it intros on minkowski operators (generalizing them).\nfloat len(vec3 p, float l) {\n\tp = pow(abs(p), vec3(l));\n\treturn pow(p.x + p.y + p.z, 1.0/l);\n}\n\nfloat de(vec3 p) {\n\tvec3 q = p;\n\tvec2 c = floor((p.xz + 3.0)/6.0);\n\t\n\tq.xz = mod(q.xz + 3.0, 6.0) - 3.0;\n\tq.y -= 0.5;\n    // use random value to produce different shape.\n\treturn min(len(q, 1.5 + 9.0*hash(c)) - 1.5, p.y + 1.0);\n}\n\n// basic trace, with some LOD\nfloat trace(vec3 o, vec3 d, float m) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 200; i++) {\n\t\tfloat d = de(o + d*t);\n\t\tif(d < (0.001 + 0.0001*t) || t >= m) break;\n\t\tt += d*0.67;\n\t}\n\treturn t;\n}\n\n// basic normal.\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\n// slowish ao\nfloat ao(vec3 p, vec3 n) {\n\tfloat o = 0.0, s = 0.005, w = 1.0;\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tfloat d = de(p + n*s);\n\t\to += (s - d)*w;\n\t\tw *= 0.98;\n\t\ts += s/float(i + 1);\n\t}\n\t\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\n//euclidean cameras.\nmat3 camera(vec3 o, vec3 l) {\n\tvec3 w = normalize(l - o);\n\tvec3 u = normalize(cross(vec3(0, 1, 0), w));\n\tvec3 v = normalize(cross(w, u));\n\t\n\treturn mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\n\tvec3 ro = vec3(2.7 + cos(iTime*0.3), 0, iTime);\n\tvec3 rd = camera(ro, vec3(2.5 + 0.9*cos(iTime*0.3 + 0.3), 0, iTime + 0.2))*normalize(vec3(p, 1.97));\n\t\n\tvec3 col = vec3(0.45, 0.8, 1.0);\n\tvec3 lig = normalize(vec3(0.8, 0.7, -0.6));\n\t\n\tfor(int i = 0; i < 3; i++) {\n\t\tfloat t = trace(ro, rd, 50.0);\n\t\tif(t < 50.0) {\n\t\t\tvec3 rcol = vec3(0);\n\t\t\t\n            // geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro + rd*t;\n\t\t\tvec3 nor = normal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n\t\t\t\n            // occlusion and shadows\n\t\t\tfloat occ = ao(pos, nor);\n\t\t\tfloat sha = step(5.0, trace(pos + nor*0.001, lig, 5.0));\n\t\t\t\n            // lighting ambient + diffuse + fresnel + specular\n\t\t\trcol += 0.2*occ;\n\t\t\trcol += clamp(dot(lig, nor), 0.0, 1.0)*occ*sha;\n\t\t\trcol += pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0)*occ;\n\t\t\trcol += 2.0*pow(clamp(dot(ref, lig), 0.0, 1.0), 30.0)*occ;\n\t\t\t\n            // simple material.\n\t\t\tif(pos.y > -0.99)\n\t\t\t\trcol *= vec3(2.2, 0.7, 0.7);\n\t\t\telse\n\t\t\t\trcol *= 0.3 + 0.7*mod(floor(pos.x) + floor(pos.z), 2.0);\n\t\t\t\n            // set up the ray orgin and direction for reflection.\n\t\t\tro = pos + nor*0.001;\n\t\t\trd = ref;\n\t\t\t\n            // sky fog.\n\t\t\trcol = mix(rcol, vec3(0.45, 0.8, 1.0), 1.0 - exp(-0.1*t));\n\t\t\t\n            // lighten intensity on each successive reflect.\n\t\t\tif(i == 0) col = rcol;            \n\t\t\telse col *= mix(rcol, vec3(1), 1.0 - exp(-0.8*float(i)));\n\t\t}\n\t}\n\t\n    // tone mapping and gamma correction.\n\tcol = 1.0 - exp(-0.5*col);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}