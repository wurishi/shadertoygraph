{"ver":"0.1","info":{"id":"ctXyDl","date":"1691299326","viewed":684,"name":"bottle water (interactive)","username":"MonterMan","description":"drag your mouse to interact with bottle.\n\ncredit of basic idea to MinionArt: https://www.patreon.com/posts/18245226","likes":38,"published":1,"flags":32,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, float h, float r)\n{\n    return length(vec3(p.x, max(0.0, abs(p.y) - 0.5*h), p.z)) - r;\n}\n\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nstruct Scene\n{\n    vec2 rot;\n    vec2 stre;\n};\n\nmat2 rot2(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nvec3 apply_rot(vec3 p, vec2 rot)\n{\n    p.xy *= rot2(rot.x);\n    p.yz *= rot2(rot.y);\n    return p;\n}\n\nfloat smax(float a, float b, float k)\n{\n    float dist = abs(a - b);\n    float res = max(a, b);\n    if (dist < k)\n    {\n        res += (1.0/(4.0*k))*(k-dist)*(k-dist);\n    }\n    return res;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float dist = abs(a - b);\n    float res = min(a, b);\n    if (dist < k)\n    {\n        res -= (1.0/(4.0*k))*(k-dist)*(k-dist);\n    }\n    return res;\n}\n\nfloat map_shell(Scene scene, vec3 p)\n{\n    p = apply_rot(p, scene.rot);\n    float dist = sdCapsule(p-vec3(0,-0.4,0), 1.3, 0.43);\n    dist = smin(dist, sdCylinder(p-vec3(0,0.6,0), 0.6, 0.12), 0.03);\n    dist = smax(dist, -p.y-1.1, 0.02);\n    return dist;\n}\n\nvec3 calc_normal_shell(Scene scene, vec3 p)\n{\n    vec2 e = vec2(0, 0.0001);\n    return normalize(vec3(map_shell(scene, p+e.yxx),\n                          map_shell(scene, p+e.xyx),\n                          map_shell(scene, p+e.xxy)) - \n                          vec3(map_shell(scene, p)));\n}\n\nfloat map_body(Scene scene, vec3 p)\n{\n    float dist = map_shell(scene, p)+0.04;\n    \n    vec3 surfaceN = vec3(0,1,0);\n    // surface wobble\n    surfaceN.yz *= rot2(scene.stre.y*sin(10.0*iTime));\n    surfaceN.xy *= rot2(scene.stre.x*sin(10.0*iTime));\n    // travelling waves\n    float perturb = 0.1*(scene.stre.x*sin(4.0*(p.x+sign(scene.stre.x)*5.0*iTime)) + \n                         scene.stre.y*sin(4.0*(p.z+sign(scene.stre.y)*5.0*iTime)));\n    // TODO: SDF is completely ruined if I remove the *0.1 here, why?\n    //       does this screw up the SDF that badly?\n    dist = 0.1*max(dist, dot(p,surfaceN)-(0.0+perturb));\n    return dist;\n}\n\nvec3 calc_normal_body(Scene scene, vec3 p)\n{\n    vec2 e = vec2(0, 0.0001);\n    return normalize(vec3(map_body(scene,p+e.yxx),\n                          map_body(scene,p+e.xyx),\n                          map_body(scene,p+e.xxy)) - \n                          vec3(map_body(scene,p)));\n}\n\nvec3 render(Scene scene, vec2 uv)\n{\n    float cam_angle = 0.0 * 6.28;\n    vec3 ro = 2.0*vec3(sin(cam_angle), 0.2, -cos(cam_angle));\n    vec3 at = vec3(0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.3 * cam_z);\n    \n    bool hit = false;\n    float t = 0.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float dist = 0.1*map_shell(scene, p);\n        if (dist < 0.001)\n        {\n            hit = true;\n            break;\n        }\n        t += dist;\n    }\n    \n    bool hit_inner = false;\n    float t_inner = 0.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        vec3 p = ro + t_inner * rd;\n        float dist = map_body(scene, p);\n        if (dist < 0.001)\n        {\n            hit_inner = true;\n            break;\n        }\n        t_inner += dist;\n    }\n\n    vec3 glass_f0 = vec3(0.5);\n    vec3 water_f0 = vec3(0.3);\n    vec3 keyLightCol = 1.5*vec3(1);//vec3(0.3, 0.5, 1.1);\n    vec3 keyLightDir = normalize(vec3(0.0,0.9,0.5));\n    vec3 waterDifCol = 1.3*vec3(0.3,0.6,0.8);\n    \n    vec3 bgCol = texture(iChannel0, rd).rgb;\n    bgCol = bgCol * bgCol; // gamma -> linear\n  \n    vec3 col = bgCol;\n    vec3 glass_fre = vec3(1);\n    if (hit)\n    {\n        vec3 p = ro + t * rd;\n        vec3 n = calc_normal_shell(scene, p);\n        vec3 l = rd - 2.0 * dot(rd, n) * n;\n        glass_fre = glass_f0 + (vec3(1) - glass_f0) * pow(1.0 - dot(n, l), 5.0);\n        \n        {\n            float keyLightCos = dot(keyLightDir, l);\n\n            vec3 keyLight = texture(iChannel1, l).rgb;\n            vec3 spe = keyLight * glass_fre;\n            col = spe;\n        }\n    }\n    \n    if (hit_inner)\n    {\n        vec3 p = ro + t_inner * rd;\n        vec3 n = calc_normal_body(scene, p);\n        vec3 l = rd - 2.0 * dot(rd, n) * n;\n        vec3 fre = water_f0 + (vec3(1) - water_f0) * pow(1.0 - dot(n, l), 5.0);\n        \n        {\n            float keyLightCos = dot(keyLightDir, l);\n\n            vec3 keyLight = texture(iChannel1, l).rgb;\n            vec3 spe = keyLight * fre;\n            vec3 dif = waterDifCol * keyLightCol * (0.05 + 0.3 * (0.5 + 0.5 * keyLightCos));\n            col = mix(col, spe + dif, 1.0-glass_fre);\n        }\n    }\n    else\n    {\n        col = mix(col, bgCol,1.0-glass_fre);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n#define SIM1_DATA_IDX 0\n#define SIM2_DATA_IDX 1\n#define DATA_STRIDE 2\n    // simulation data stored in double-buffered packs of floats for persistent storage\n    int currPackIdx = iFrame & 1;\n    int nextPackIdx = (iFrame + 1) & 1;\n    vec4 sim1Data = texelFetch(iChannel2, ivec2(DATA_STRIDE*currPackIdx + SIM1_DATA_IDX, 0), 0);\n    vec4 sim2Data = texelFetch(iChannel2, ivec2(DATA_STRIDE*currPackIdx + SIM2_DATA_IDX, 0), 0);\n\n    vec2 prevMouseCoord = sim1Data.xy;\n    vec2 prevRot = sim1Data.zw;\n    vec2 prevStre = sim2Data.xy;\n    \n    // reference: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n    bool mouseDown = iMouse.z > 0. && iMouse.w < 0.;\n        \n    // compute current rotation\n    vec2 deltaRot = vec2(0);\n    if (iMouse.x > 0. && mouseDown)\n        deltaRot.x = (iMouse.x - prevMouseCoord.x) / 800.0 * 6.28;\n    if (iMouse.y > 0. && mouseDown)\n        deltaRot.y -= (iMouse.y - prevMouseCoord.y) / 450.0 * 6.28;\n    vec2 currRot = prevRot + deltaRot;\n    // dampening oscillation\n    vec2 stre = 0.3*abs(deltaRot) + 0.987*prevStre;\n    stre = min(vec2(0.5), stre);\n\n    // special routine for data pixels (not color pixels)\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int nextPackBegin = nextPackIdx * DATA_STRIDE;\n    int nextPackEnd = nextPackBegin + DATA_STRIDE;\n    if (iFragCoord.x >= nextPackBegin && iFragCoord.y < nextPackEnd && iFragCoord.y == 0)\n    {\n        int dataIdx = iFragCoord.x - nextPackBegin;\n        if (dataIdx == SIM1_DATA_IDX)\n            fragColor = vec4(iMouse.xy, currRot);\n        if (dataIdx == SIM2_DATA_IDX)\n            fragColor = vec4(stre, 0, 0);\n        return;\n    }\n    \n    Scene scene;\n    scene.rot = currRot;\n    scene.stre = stre;\n\n    vec3 col = render(scene, uv);\n\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}