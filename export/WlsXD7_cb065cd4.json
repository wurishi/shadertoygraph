{"ver":"0.1","info":{"id":"WlsXD7","date":"1563231131","viewed":319,"name":"Backflow Version B","username":"pi","description":"Made this while trying to extract normals from a heightmap.\nBackflow Version A: [url]https://www.shadertoy.com/view/3lsXD7[/url]","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","normals","normalmap","glow","flowing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }\n\n// iq's texture repitition function variant 1\n//https://iquilezles.org/articles/texturerepetition\nvec4 texTile( sampler2D samp, in vec2 uv )\n{\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n\t\n    // derivatives (for correct mipmapping)\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n    // voronoi contribution\n    vec4 va = vec4( 0.0 );\n    float wt = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i), float(j) );\n        vec4 o = hash4( p + g );\n        vec2 r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec4 c = textureGrad( samp, uv + o.zw, ddx, ddy );\n        va += w*c;\n        wt += w;\n    }\n\t\n    // normalization\n    return va/wt;\n}\n\n\nfloat heightMap(vec2 uv)\n{\n\tvec2 px = 1./iChannelResolution[0].xy;\n    px.x*=iChannelResolution[0].x/iChannelResolution[0].y;\n    \n/*    \n    float tl = texTile(iChannel0,floor(uv/px)*px).r;\n    float tr = texTile(iChannel0, floor(uv/px)*px + px * vec2(1,0)).r;\n    float bl = texTile(iChannel0, floor(uv/px)*px + px * vec2(0,1)).r;\n    float br = texTile(iChannel0, floor(uv/px)*px + px).r;\n\n    vec2 f = fract(uv/px);\n    f=-cos(f*3.14)/2.+.5;\n    \n\treturn mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y); */\n    float backflow = pow((texture(iChannel1, uv/50.+iTime/100.).r + texture(iChannel1, uv/50.+iTime/60.).r)/2.,4.);\n    return mix(texTile(iChannel0,uv+iTime/10.).r, texTile(iChannel0,uv+iTime/6.).r, backflow * 5.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mx = iMouse.xy/iResolution.xy*2.-1.;    \n    //mx.x*=iResolution.x/iResolution.y;\n\n    \n\tvec2 px = 1./iResolution.xy;\n    px.x*=iResolution.x/iResolution.y;\n    vec2 mid = uv;\n    vec2 top = uv+px*vec2(0,1);\n    vec2 bot = uv+px*vec2(0,-1);\n    vec2 lft = uv+px*vec2(-1,0);\n    vec2 rht = uv+px*vec2(1,0);\n    \n    float hm = heightMap( mid);\n    float ht = heightMap( top);\n    float hb = heightMap( bot);\n    float hl = heightMap( lft);\n    float hr = heightMap( rht);\n    \n    vec3 md = vec3(mid,hm).xzy;\n    vec3 tp = vec3(top,ht).xzy;\n    vec3 bt = vec3(bot,hb).xzy;\n    vec3 lt = vec3(lft,hl).xzy;\n    vec3 rt = vec3(rht,hr).xzy;\n    \n    vec3 dt = tp-md;\n    vec3 dr = rt-md;\n    vec3 dl = lt-md;\n    vec3 db = bt-md;\n    \n    vec3 n = cross(normalize(dt),normalize(dr)) + \n         \t cross(normalize(dr),normalize(db)) + \n        \t cross(normalize(db),normalize(dl)) + \n        \t cross(normalize(dl),normalize(dt));\n    n/=4.;\n    n=normalize(n);\n    \n    vec3 col = vec3(0);\n\t//n.xy = n.xy / 2. + 0.5;\n    \n    vec3 pixcord = vec3(uv.x,-1.,uv.y);\n    \n    vec3 light = vec3(0.);\n    light.x*=iResolution.x/iResolution.y;\n\tcol = vec3(heightMap(uv)/pow(length(light-pixcord),2.)) * max(dot(n,normalize(light-pixcord)),0.4)*2.;\n    col *= 1. +  2. * pow(heightMap(uv),3.) * vec3(1,.7,.3) * (sin( texture(iChannel1,vec2(iTime/50.) + uv / 5. ).r * 7. )+1.+.9*texture(iChannel1,vec2(iTime/10.) + uv / 10.).r);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}