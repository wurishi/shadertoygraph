{"ver":"0.1","info":{"id":"MdVSD3","date":"1467171403","viewed":236,"name":"bumped brick texture","username":"KukaTails","description":"use procedural method to generate brick texture","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","placementmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRICK_WIDTH  0.25\n#define BRICK_HEIGHT 0.08\n#define MORTAR_THICKNESS 0.01\n#define BM_WIDTH  (BRICK_WIDTH + MORTAR_THICKNESS)\n#define BM_HEIGHT (BRICK_HEIGHT + MORTAR_THICKNESS)\n#define MWF (MORTAR_THICKNESS * 0.5 / BM_WIDTH)\n#define MHF (MORTAR_THICKNESS * 0.5 / BM_HEIGHT)\n#define BRICK_COLOR vec3(0.5, 0.15, 0.14)\n#define MORTAR_COLOR vec3(0.5, 0.5, 0.5)\n#define PI 3.141592654\n\n\nvec3 LIGHT_POS = vec3(0.0, 0.0, -100.0);\nconst vec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);\nconst vec3 AMBIENT_COLOR = vec3(0.15, 0.0, 0.0);\n\nvec3 CalculatePos(vec3 pos, vec3 normal, vec2 uv);\nvec3 CalculateNormal(vec3 pos, vec3 normal);\nvec3 Shader(vec3 pos, vec3 normal, vec3 diffuse_color);\nfloat Hash(vec2 p);\nfloat Noise(vec2 p);\nfloat FractalSum(vec2 uv);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos_xy = fragCoord.xy / 1.0;\n    vec3 pos = vec3(pos_xy , 0.0);\n    vec3 normal = vec3(0.0, 0.0, -1.0);\n    \n    float light_x = sin(mod(iTime, 10.0) / 10.0 * PI) * iResolution.x;\n    float light_y = sin(mod(iTime, 10.0) / 10.0 * PI) * iResolution.y;\n    LIGHT_POS += vec3(light_x, light_y, 0.0);\n        \n    \n    float brick_u = uv.x / BM_WIDTH;\n    float brick_v = uv.y / BM_HEIGHT;\n    \n    if (mod(brick_v, 2.0) > 1.0)\n        brick_u += 0.5;\n    \n    brick_u -= floor(brick_u);\n    brick_v -= floor(brick_v);\n    brick_u += FractalSum(uv) * 0.005;\n    brick_v += FractalSum(vec2(brick_u, brick_v)) * 0.005;\n\n    float w = step(MWF, brick_u) - step(1.0-MWF, brick_u);\n    float th = step(MHF, brick_v) - step(1.0-MHF, brick_v);\n    vec3 color = mix(MORTAR_COLOR, BRICK_COLOR, w * th);\n    \n    vec3 replacement_pos = CalculatePos(pos, normal, vec2(brick_u, brick_v));\n    vec3 replacement_normal = CalculateNormal(replacement_pos, normal);\n    //fragColor = vec4(Shader(pos, normal, color), 1.0);\n    fragColor = vec4(Shader(replacement_pos, replacement_normal, color), 1.0);\n}\n\nvec3 CalculatePos(vec3 pos, vec3 normal, vec2 uv)\n{\n    float s = uv.x;\n    float t = uv.y;\n    float sbump = smoothstep(0.0, MWF, s) - smoothstep(1.0-MWF, 1.0, s);\n    float tbump = smoothstep(0.0, MHF, t) - smoothstep(1.0-MHF, 1.0, t);\n    float stbump = sbump * tbump;\n    return pos + normal * stbump + stbump * normal * FractalSum(uv) * 0.25;\n}\n\n\nvec3 CalculateNormal(vec3 pos, vec3 normal)\n{\n    vec3 dx = dFdx(pos);\n    vec3 dy = dFdy(pos);\n    return normalize(cross(dx, dy));\n}\n\nvec3 Shader(vec3 pos, vec3 normal, vec3 diffuse_color)\n{\n    vec3 dir = normalize(LIGHT_POS - pos);\n    vec3 diffuse = abs(dot(dir, normal)) * LIGHT_COLOR * diffuse_color;\n    vec3 color = AMBIENT_COLOR + diffuse;\n    return color * 1.5;\n}\n\nfloat Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return -1.0 + 2.0 * fract(sin(h) * 4358.5453);\n}\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\nfloat FractalSum(vec2 uv)\n{\n    const int octaves = 1;\n    float amplitude = 1.0;\n    float f = 0.0;\n    \n    uv *= 25.0;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    for (int i = 0; i < octaves; ++ i) {\n        f += abs(amplitude * Noise(uv));\n        uv = m * uv;\n        amplitude *= 0.5;\n    }\n    return f;\n}\n","name":"Image","description":"","type":"image"}]}