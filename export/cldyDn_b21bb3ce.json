{"ver":"0.1","info":{"id":"cldyDn","date":"1699063545","viewed":103,"name":"Octree Ray Tracer","username":"cboltjes","description":"This is an octree traversal ray-tracing algorithm I am developing for a VR voxel game. Distance based LOD is implemented, but I need to work on a chunk based LOD. It gets a little choppy on lower end GPUs.","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","experimental"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime*0.1\n#define MAX_DIST 20.0\n//adjust this so rays take less steps\n#define MAX_STEPS 300\n\n//If you adjust the ray levels,\n//Add/remove from lines 122 and 164 \n//RAY_LEVELS = #inner levels + 1\n#define RAY_LEVELS 8\n\n// Using macros is the easiest work around I found to get something\n// similar to recursion.\n\n//                ray, macro\n#define march_start(r, inner)                             \\\n{                                                         \\\n    r.loc[0] = r.origin;                                  \\\n    while(r.dist[0] < MAX_DIST && r.steps++ < MAX_STEPS) {\\\n        r.nStep[0] = nextVoxDist(r, 0);                   \\\n        n = noise(r, 0);                                  \\\n        if(n.a > 0.8) {                                   \\\n            inner                                         \\\n            if(r.hit)                                     \\\n                break;                                    \\\n        }                                                 \\\n        r.dist[0] += r.nStep[0];                          \\\n        r.loc[0] += r.nStep[0]*r.dir;                     \\\n        r.norm = r.tNorm;                                 \\\n    }                                                     \\\n    /* Total all distances*/                              \\\n    for(int i = 1; i < RAY_LEVELS; i++)                   \\\n        r.dist[0] += r.dist[i] * pow(0.5, float(i));      \\\n}\n\n#define march_inner(r, i, inner)                                                  \\\n{                                                                                 \\\n    r.dist[i] = 0.0;                                                              \\\n    r.loc[i] = fract(r.loc[i-1]) * 2.0;                                           \\\n    while(r.dist[i] < r.nStep[i-1]*2.0 && r.steps++ < MAX_STEPS) {                \\\n        r.nStep[i] = nextVoxDist(r, i);                                           \\\n        n = noise(r, i);                                                          \\\n        if(n.a > 0.2) {                                                           \\\n            if(r.dist[0] < 0.95 * float(RAY_LEVELS - i) * float(RAY_LEVELS - i)) {\\\n                inner                                                             \\\n            }                                                                     \\\n            else {                                                                \\\n                END                                                               \\\n            }                                                                     \\\n            if(r.hit) {                                                           \\\n                break;                                                            \\\n            }                                                                     \\\n        }                                                                         \\\n        r.dist[i] += r.nStep[i];                                                  \\\n        r.loc[i] += r.nStep[i]*r.dir;                                             \\\n        r.norm = r.tNorm;                                                         \\\n    }                                                                             \\\n}\n\n#define march_end(r, i, end)                                      \\\n{                                                                 \\\n    r.dist[i] = 0.0;                                              \\\n    r.loc[i] = fract(r.loc[i-1]) * 2.0;                           \\\n    while(r.dist[i] < r.nStep[i-1]*2.0 && r.steps++ < MAX_STEPS) {\\\n        n = noise(r, i);                                          \\\n        if(n.a > 0.5) {                                           \\\n            end                                                   \\\n        }                                                         \\\n        r.nStep[i] = nextVoxDist(r, i);                           \\\n        r.dist[i] += r.nStep[i];                                  \\\n        r.loc[i] += r.nStep[i]*r.dir;                             \\\n        r.norm = r.tNorm;                                         \\\n    }                                                             \\\n}\n\n#define END {       \\\n    r.color = n.rgb;\\\n    r.hit = true;   \\\n    break;          \\\n}\n\nstruct ray {\n    vec3 origin;\n    vec3 dir;\n    vec3 sDir; //Simple direction, i.e. step(0.0, dir);\n    \n    vec3 color;\n    vec3 norm;\n    vec3 tNorm; //Temp norm\n    \n    bool hit;\n    int steps;\n    vec3 loc[RAY_LEVELS];   //Location at each level\n    float dist[RAY_LEVELS]; //Distance at each level\n    float nStep[RAY_LEVELS];//Next step at each level\n};\n\nstruct camera {\n    vec3 origin;\n    vec3 dir;\n};\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nray initRay(vec2 uv, vec3 origin, vec3 dir) {\n    vec3 d = normalize(vec3(uv,1.0));\n    d.yz *= Rot(dir.y);\n    d.xz *= Rot(dir.x);\n    return ray(\n        origin,\n        d,\n        step(0.0, d),\n        \n        vec3(1.0),\n        vec3(1.0),\n        vec3(1.0),\n        \n        false,\n        0,\n        //Add/remove elements to these 3 arrays if you change RAY_LEVELS\n        vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0)),\n        float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n        float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n    );\n}\n\ncamera initCamera(vec3 origin, vec3 dir){\n    return camera(\n        origin,\n        dir\n    );\n}\n\nvec4 noise(ray r, int level) {\n    vec3 p = floor(r.loc[level] + float(level*2)) + floor(r.loc[0]) + 0.5;\n    vec3 q = p / iChannelResolution[0].xyz;\n    vec4 result = texture(iChannel0, q).rgba;\n    return result;\n}\n\nfloat nextVoxDist(inout ray r, int i) {\n    vec3 dist = fract(r.loc[i]);\n    dist = (1.0-r.sDir)*dist + (1.0-dist)*r.sDir;\n    dist /= abs(r.dir);\n    float level = float(i+1);\n    if (dist.x < dist.y && dist.x < dist.z) {\n        r.tNorm = vec3(0.8); // Not actual norm right now, just darkens some faces\n        return dist.x + 0.00006 * pow(2.007, level);\n    }\n    else if(dist.y < dist.z) {\n        r.tNorm = vec3(0.6) + 0.4*r.sDir.y;\n        return dist.y + 0.00006 * pow(2.007, level);\n    }\n    r.tNorm = vec3(0.7) + 0.2*r.sDir.z;\n    return dist.z + 0.00006 * pow(2.007, level);\n}\n\nvoid marchRay(inout ray r){\n    vec4 n;\n    //Add/remove the march_inner macros and trailing ')'s and\n    //adjust the numbers to count up if you change RAY_LEVELS\n    march_start(r, \n    march_inner(r, 1, \n    march_inner(r, 2, \n    march_inner(r, 3, \n    march_inner(r, 4, \n    march_inner(r, 5, \n    march_inner(r, 6, \n    march_end(r, 7, \n    END))))))))\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    camera cam = initCamera(vec3(0.5, 0.2, 1.1+T), vec3(-m.x*5.0 + 2.4, 2.9-m.y*5.0, 0.0));\n    vec3 light = normalize(vec3(-0.5, -0.9, -0.7));\n    \n    ray r = initRay(uv, cam.origin, cam.dir);\n    marchRay(r);\n    //r.color *= dot(light, r.norm);\n    if(r.steps >= MAX_STEPS || r.dist[0] >= MAX_DIST)\n        r.color = vec3(0.0);\n    else {\n        r.color *= r.norm;\n        r.color *= (((MAX_DIST - r.dist[0]*1.2) / MAX_DIST)) * 0.5 + 0.5;\n    }\n    \n    fragColor = vec4(r.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}