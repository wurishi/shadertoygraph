{"ver":"0.1","info":{"id":"4ddXD4","date":"1459486761","viewed":200,"name":"Voxel Worldline","username":"akohdr","description":"Test rendering of map with terse voxel viewer\nClick on viewport to watch animation of 2D backing map of voxel world slices (Buf A)\nSome issues with 2D/3D projection functions, negative coordinates don't work and scaling shears in fullscreen.\n\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Since this is a map lookup feel free to amp speed to something crazy\n//#define SPD_R 3.\n#define SPD_R .65\n\n//#define SHOW_AXIS\n\n// Choose either XY or XZ plane world slices\n//#define prj3Dto2D prj3Dto2D_XZ\n//#define prj3Dto2D prj3Dto2D_XY\n#define prj3Dto2D prj3Dto2D_timed\n\n\n// Cut/Paste begin ------------------------------------------------------------\n#define BOB_H 15.\n#define EYE_D 125.\n#define B0 vec4(.0,.0,.0,1.)\n#define B1 vec4(.6,.6,.6,1.)\n#define B2 vec4(.3,.3,.3,1.)\n\n// goal is fast voxel based abstraction returning existence and colour(c) in spacetime(P)\nbool cVoxel(out vec4 c, in vec4 P );\n\nbool VxViewer(out vec4 fc,        // fragColor\n         const in vec2 P,         // fragCoord\n         const in vec3 R,         // iResolution\n         const in float T ) {     // timebase\n\n    vec2 t = vec2(sin(T), cos(T)),\n         l = P.xx / R.xx - .5;         // vec ops faster than single scalar\n    vec3 r = vec3(l.y*t.y - .8*t.x, \n                  (P.y/R.y - .5)*R.y/R.x, \n                  .8*t.y + l.x*t.x),\n         o = t.xxy * vec3(EYE_D, BOB_H, -EYE_D),\n         h = length(r)/r,\n         q = sign(r),\n         f = floor(o),\n         d = abs(h),\n         s = d*(q*(f-o) + (.5*q) + .5),\n         m;\n    \n    for(int i=400;i>0;i--) {\n        \n        if(cVoxel(fc,vec4(f,T))){ // move to top of loop for edgeless non-spin voxels\n            fc += m.x>0. ? B0 : m.y>0. ? B1 : B2;\n            return true; // early exit\n        }\n        \n        vec3 s1 = s.yzx,\n             s2 = s.zxy;\n        bvec3 a = lessThan(s,s1),\n              b = lessThanEqual(s,s2);\n              m = vec3(a.x && b.x, a.y && b.y, a.z && b.z);  //a && b\n        \n        f += m*q;\n        s += m*d;\n    }\n    return false;\n}\n// Cut/Paste end ------------------------------------------------------------\n\n// Pallette defs / constants\n#define RED vec4(.9,.0,.0,1.)\n#define GRN vec4(.0,.9,.0,1.)\n#define BLU vec4(.0,.0,.9,1.)\n#define PRP vec4(.3,0.,.5,1.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if(iMouse.z>0.)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else        \n    if(!VxViewer(fragColor, \n             vec2(fragCoord.x, iResolution.y-fragCoord.y),\n             iResolution,\n             SPD_R*iTime))          // timebase\n    // we didn't hit voxel\n        fragColor = 5.*vec4(.4,.7,2.,1.)*texture(iChannel1,fragCoord/iResolution.xy);\n}\n\nvec3 vDim = vec3(int(iResolution.x/8.));\n    \nvec2 prj3Dto2D_XZ(const in vec4 P) {\n    float fpl = floor(iResolution.x/vDim.x);\n    vec2 fOrigin;\n    \tfOrigin.x = mod(P.y , fpl);\n    \tfOrigin.y = (P.y-fOrigin.x) / fpl;\n    return P.xz + floor(fOrigin) * vDim.xy;\n}\n\nvec2 prj3Dto2D_XY(const in vec4 P) {\n    float fpl = floor(iResolution.x/vDim.x);\n    vec2 fOrigin;\n    \tfOrigin.x = mod(P.z , fpl);\n    \tfOrigin.y = (P.z-fOrigin.x) / fpl;\n    return P.xy + floor(fOrigin) * vDim.xy;\n}\n\nvec2 prj3Dto2D_timed(const in vec4 P) {\n    if(fract(iTime/10.)>.5)\n        return prj3Dto2D_XY(P);\n    else\n        return prj3Dto2D_XZ(P);\n}\n\n// AXIS support ----------------------------------------------\n#define SPHERE(p,c,r) length(p.xyz-c.xyz)<r\n#define ARX(p,c,r) length(p.xy-c.xy)<r-length(1.23*p.xz-c.xz)\n#define ARY(p,c,r) length(p.xy-c.xy)<r-length(1.23*p.yz-c.yz)\n#define ARZ(p,c,r) length(p.yz-c.yz)<r-length(1.23*p.xz-c.xz)\n\n#define Q(q) if(q) return true;\n#define QC(C,q) {c=C;Q(q)}\n#define QS(C,p,c,r) QC(C,SPHERE(p,c,r))\n#define QX(C,p,c,r,X) QC(C,X(p,c,r))\n#define vO vec3(0.)\n#define vX(r) vec3(r,0.,0.)\n#define vY(r) vec3(0.,r,0.)\n#define vZ(r) vec3(0.,0.,r)\n\n// painful to use but macros can save couple fps, multi line macros would be nice\n#ifdef SHOW_AXIS\n\t#define AXIS(s,r) {QX(cRED,P,vX(s),r,ARX) QX(cGRN,P,vY(s),r,ARY) QX(cBLU,P,vZ(s),r,ARZ) QS(cPRP,P,vO,r/2.)}\n#else\n\t#define AXIS(s,r)\n#endif\n// -----------------------------------------------------------\n\nbool cVoxel(out vec4 c,\n             in vec4 P ) {\n    AXIS(33.,7.5)\n\n    // pull voxel state from 2D map of world slices generated in BufA\n    c = texture(iChannel0, prj3Dto2D(P)/iResolution.xy);\n \treturn c.x>.0;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SPD_O 2.4\n#define SHOW_ORBIT\n//#define SHOW_BOUNDS\n\n// Choose either XY or XZ plane world slices\n#define prj2Dto3D prj2Dto3D_XZ\n//#define prj2Dto3D prj2Dto3D_XY\n\n#define SPHERE(p,c,r) length(p-c)<r\n#define Q(q) if(q) return;\n#define QC(C,q) {c = C;Q(q)}\n\n// Pallette defs / constants\n#define RED vec4(.9,.0,.0,1.)\n#define GRN vec4(.0,.9,.0,1.)\n#define BLU vec4(.0,.0,.9,1.)\n#define YEL vec4(1.,1.5,.5,1.)\n#define NULL vec4(-1)\n\nvec3 vDim = vec3(int(iResolution.x/8.));\n \nvec3 prj2Dto3D_XZ(const in vec2 P) {\n\tfloat fpl = floor(iResolution.x/vDim.x);\n    vec2 fOrigin = floor(P / vDim.xz) * vDim.xz;\n    \n    vec3 v;\n\t    v.xz = P - fOrigin;\n    \tv.y = (P.x/vDim.x) + (P.y/vDim.z)*fpl;\n    return v;\n}\n\nvec3 prj2Dto3D_XY(const in vec2 P) {\n\tfloat fpl = floor(iResolution.x/vDim.x);\n    vec2 fOrigin = floor(P / vDim.xy) * vDim.xy;\n    \n    vec3 v;\n\t    v.xy = P - fOrigin;\n    \tv.z = (P.x/vDim.x) + (P.y/vDim.y)*fpl;\n    return v;\n}\n\nvoid mainImage( out vec4 c, in vec2 P ){\n    // <FIX>: black stripe boundary on map to prevent 'beam forming'\n    //      There is a sampler setting I think that could help here.\n\tvec3 rl = iResolution-1.;\n    if(P.x<1.||P.y<1.) {c = NULL; return;}\n    if(P.x>rl.x||P.y>rl.y)  {c = NULL; return;}\n    // </FIX>\n    \n    float T = SPD_O*iTime;\n    vec2 fqs = T * vec2(2,3),\n         t  = vec2(-sin(T), cos(T)),\n         t2 = vec2(-sin(fqs.x), cos(fqs.x)),\n         t3 = vec2(-sin(fqs.y), -cos(fqs.y));\n    vec3 p3 = prj2Dto3D(P),\n         pPlanet = vec3(18.),\n         pMoonR = pPlanet,\n         pMoonG = pPlanet,\n         pMoonB = pPlanet;\n    vec4 sc = vec4(p3/99.,1.);\n\n#ifdef SHOW_ORBIT\n    pMoonR += 12.* t.yxx;\n    pMoonG +=  8.* t2.yxy *vec3(1,1,-1);\n    pMoonB += 10.* t3.yxy;\n#endif\n\n#ifdef SHOW_BOUNDS    \n    QC(cYEL,SPHERE(p3, vec3(2), 1.1))\n    QC(cYEL,SPHERE(p3, vDim/1.1, 1.1))\n#endif\n        \n    QC(sc,SPHERE(p3, pPlanet, 4.3))\n  \tQC(sc+RED,SPHERE(p3, pMoonR, 2.7))\n  \tQC(sc+GRN,SPHERE(p3, pMoonG, 1.8))\n  \tQC(sc+BLU,SPHERE(p3, pMoonB, 2.3))\n               \n\tc = texture(iChannel1, P/iResolution.xy)-.55;\n}","name":"Buf A","description":"","type":"buffer"}]}