{"ver":"0.1","info":{"id":"WtySWh","date":"1582562861","viewed":142,"name":"Black","username":"tono","description":"three in the black","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["glsldarts"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//i poseted it shadertoy and neort\n#define AA 1\n#define MAXSTEPS 99\n\nstruct data\n{\n    float d;\n    float m;\n    vec2 p;\n    float mask;\n    float bull;\n};\n\nconst float pi = acos(-1.);\nconst float pi2 = pi * 2.;\n\nmat2 rot(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 Polar(vec2 i)\n{\n    vec2 pl = vec2(0.);\n    pl.y = sqrt(i.x*i.x+i.y*i.y)*2.+1.;\n    pl.x = atan(i.y,i.x)/acos(-1.);\n    return pl;\n}\n\nfloat wave(float l)\n{\n    \n    float wv = 1.0 - abs(sin(l));\n    float swv = abs(cos(l));    \n    wv = mix(wv, swv, wv);\n    wv = clamp(wv,0.9,1.);\n    return wv;\n}\n\ndata board(vec3 p)\n{\n    p.xy *= rot(pi/2.);\n    vec2 pp = Polar(p.xy);\n    float l = pp.y * 1.5;\n    float wvmask = step(0.,sin(pp.y * 7.5) - .5 + step(length(pp.y),1.5) );\n    float wv = clamp(sin(pp.y * 52.5) - .5,0.,1.);\n    wv *= wvmask;\n    float ve = clamp(wave(pp.x*(31.4  )),0.,.9 + step(1.23,length(pp.y))/10. ) ;\n    \n    float wve = wv + ve * (1. - wv);\n    p.z += clamp(wve,0.,1.);\n    float b = sdCappedCylinder(p.xzy,.9,.02);\n    data o;\n    o.d = b * .09;\n    o.m = (wve > .9)?0.:1.;\n    o.mask = step(0.,sin(pp.y * 7.5) - .85);\n    o.p = pp;\n    o.bull = length(pp.y);\n    return o;\n}\n\ndata boardC(vec3 p)\n{\n    p.xy *= rot(pi/2.);\n    p.xy *= rot(sin(.35 * iTime + length(p.xy) * 2. ) + iTime * .35 );\n    vec2 pp = Polar(p.xy);\n    float l = pp.y * 1.5;\n    float wvmask = step(0.,sin(pp.y * 7.5) - .5 + step(length(pp.y),1.5) );\n    float wv = clamp(sin(pp.y * 52.5) - .5,0.,1.);\n    wv *= wvmask;\n    float ve = clamp(wave(pp.x*(31.4  )),0.,.9 + step(1.23,length(pp.y))/10. ) ;\n    \n    float wve = wv + ve * (1. - wv);\n    p.z += clamp(wve,0.,1.);\n    float b = sdCappedCylinder(p.xzy,.9,.02);\n    data o;\n    o.d = b * .09;\n    o.m = (wve > .9)?0.:1.;\n    o.mask = step(0.,sin(pp.y * 7.5) - .85);\n    o.p = pp;\n    o.bull = length(pp.y);\n    return o;\n}\n\nvec3 rep(vec3 p,vec3 s)\n{\n    return mod(p,s) - s/2.;\n}\n\nvec2 rep(vec2 p,vec2 s)\n{\n    return mod(p,s) - s/2.;\n}\n\nfloat rep(float p,float s)\n{\n    return mod(p,s) - s/2.;\n}\n\ndata map(vec3 p)\n{\n    data o ;\n    \n    p.xy *= rot(sin(iTime + length(p.xy)));\n    vec3 shift = vec3(0.01,0.06,0.) * sign(mod(floor(p.z/3.),2.)-.5);\n    p = rep(p - 1.5,vec3(3.,3.,3.) + shift);\n    o = boardC(p);\n    return o;\n}\n\ndata march(vec3 cp,vec3 rd)\n{\n    float depth = 0.;\n    data d;\n    for(int i = 0;i< MAXSTEPS;i++)\n    {\n        vec3 rp = cp  + rd * depth;\n        d = map(rp);\n        if(abs(d.d) < 0.01)\n        {\n            d.d = depth;\n            return d;\n        }\n        if(depth > 20.){break;}\n        depth += d.d;\n    }\n    d.d *= -1.;\n    return d;\n}\n\nvec3 gn(vec3 p)\n{\n    vec2 e = vec2(0.,0.0001);\n    return -normalize(map(p).d - vec3(map(p - e.xyy).d,map(p - e.yxy).d,map(p - e.yyx).d));\n}\n\nfloat fr(data d,vec3 cp,vec3 rd,vec3 normal,vec3 light,float frp)\n{\n    vec3 p = d.d * rd + cp;\n    vec3 cd = normalize(cp - p);\n    vec3 hlf = normalize(light + cd);\n    float sp = max(0.,dot(hlf,normal));\n\tfloat f = pow(sp,frp);\n    return f;\n}\n\nvec3 setColor(data d,vec3 cp, vec3 rd)\n{\n    vec3 color = vec3(0.);\n    vec3 sun = normalize(vec3(1.9,.8,6.9));\n    sun.xz *= rot(iTime);\n    sun.yz *= rot(iTime);\n    vec3 n = gn(cp + rd * d.d);\n    float diff = mix(max(0.,dot(n,sun)),1. ,.2);\n    \n    float area = step(0.,sin(d.p.x * 31.4));\n    vec3 areacolor = mix(vec3(1.,0.,0.),vec3(0.,0.,0.5),area);\n    vec3 bull = mix(vec3(1.,0.,0.),vec3(0.),step(d.bull ,1.1));\n    color = mix(vec3(.0),vec3(1.2), area );\n    \n    vec3 bar = vec3(1.,1.,1.);\n    color = mix(color,bar,1.- d.m);\n    color = mix(color,areacolor,d.mask * d.m);\n    color = mix(color,bull,step(d.bull,1.21) );\n    \n    float frp = mix(3.,100.,d.m);\n    float f = fr(d,cp,rd,n,sun,frp);\n    color /= 3.;\n    color += f * (color* 3.,0.,1.);\n    color *= diff;\n    color = clamp(color,0.,1.);\n    return color;\n}\n\nvoid render(in vec2 fragCoord,in vec2 resolution,out vec3 Color) {\n    vec2 p = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 f = vec3(0.);\n    float t = iTime/2.7;\n    f.z = t + sin(t*pi/1.5 -.3);\n\tvec3 target = vec3(0.) + f;\n    vec3 cp = vec3(0.,0.,-5.) + f;\n   \n    vec3 cd = normalize(target - cp);\n    vec3 cu = vec3(0.,1.,0.);\n    vec3 cs = normalize(cross(cd,cu));\n    cu = normalize(cross(cd,cs));\n    \n    float fov = 2.6;\n    vec3 rd = normalize(p.x * cs + p.y * cu + cd * fov);\n    data d = march(cp,rd);\n    if(d.d > 0.)\n    {\n        Color += setColor(d,cp,rd);\n    }\n    else\n    {\n        Color += ( (d.d * d.d) /(float(MAXSTEPS )*1.1));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.1);\n    for(int i = 0;i < AA;i++ )\n    {\n        for(int j = 0; j < AA;j++)\n        {\n            vec2 d = vec2(float(i),float(j)) - vec2(float(i),float(j))/2.;\n            d /= float(AA);\n            render(fragCoord + d,iResolution.xy,col);\n        }\n    }\n    col /= float(AA * AA);\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}