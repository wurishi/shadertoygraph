{"ver":"0.1","info":{"id":"X3GGzD","date":"1729013944","viewed":29,"name":"Ray march base v3","username":"francesco_vmk","description":"my very un-optimized ray march base, \nwhit very bad transparent object implementation and blurred shadows\n\nit supports trasparent objecst, rotations, and deformations of the sdf box object.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Color loop\" by francesco_vmk. https://shadertoy.com/view/4Xc3Wj\n// 2024-06-01 17:16:22\n\n// Fork of \"Ray march 0.2 with transparance\" by francesco_vmk. https://shadertoy.com/view/cdtfD8\n// 2023-11-21 17:12:12\n\n//CONSTANTS\nconst float MAX_DIST = 25.0;\nconst float MIN_DIST = 0.001;\nconst float pi = 3.141592653589793;\n//structs\n\nstruct Point{\n    float dist;\n    vec4 color;\n    int shapeId;\n};\n\n//random\n\n\nfloat rand(float i, float seed){return fract(sin(i) * seed);}\n\nvec4 colors[3]= vec4[3](\n    vec4(0.000,1.000,0.000,1.0), \n    vec4(1.000,0.000,0.000,1.0), \n    vec4(0.000,0.000,1.000,1.0)\n);\n    \nvec4 randomColor(float seed, float i){\n    int arrayLength = colors.length();\n    int randomIndex = int(rand(i, seed) * float(arrayLength));\n    return colors[randomIndex];\n}\n\n\n\n//shapes\n\nPoint sdfSphere(vec3 p, vec3 center, float radius, vec4 color, vec3 rotation, vec3 pivot, int currentId){\n\n\n    // n must be normalized\n  \n    p = p - center;//center\n\n\n      //rotation matrix\n    mat2 rotX = mat2(cos(rotation.x), -sin(rotation.x),\n                         sin(rotation.x),  cos(rotation.x));\n    vec2 yz = rotX * p.yz;\n    p.y = yz.x;\n    p.z = yz.y;\n\n    mat2 rotY = mat2(cos(rotation.y), sin(rotation.y),\n                        -sin(rotation.y), cos(rotation.y));\n    vec2 xz = rotY * p.xz;\n    p.x = xz.x;\n    p.z = xz.y;\n\n    mat2 rotZ = mat2(cos(rotation.z), -sin(rotation.z),\n                         sin(rotation.z),  cos(rotation.z));\n    vec2 xy = rotZ * p.xy;\n    p.x = xy.x;\n    p.y = xy.y;\n\n\n\n    p += pivot;//apply pivot\n    \n   \n\n    Point res = Point(length(p - center) - radius - cos(length(p * 0.1) * 3.0), color, currentId);\n\n    return res;\n}\n\nPoint sdfPlane( vec3 p, vec3 n, float h, vec4 color, int currentId){\n  // n must be normalized\n  \n  \n  return Point(n.x * p.x + n.y * p.y + n.z * p.z - h, color, currentId);\n}\n\n\nPoint sdfBox( vec3 p, vec3 b, vec3 center, vec4 color, vec3 base1, vec3 base2, vec3 base3, vec3 rotation, vec3 pivot, vec3 deform1, vec3 deform2, vec3 deform3, vec3 deformPivot, int currentId){\n  \n  \n  p = p - center;//center\n  \n    \n  //change base\n  p = p[0] * base1 + p[1] * base2 + p[2] * base3;\n  \n  //rotation matrix\n    mat2 rotX = mat2(cos(rotation.x), -sin(rotation.x),\n                     sin(rotation.x),  cos(rotation.x));\n    vec2 yz = rotX * p.yz;\n    p.y = yz.x;\n    p.z = yz.y;\n\n    mat2 rotY = mat2(cos(rotation.y), sin(rotation.y),\n                    -sin(rotation.y), cos(rotation.y));\n    vec2 xz = rotY * p.xz;\n    p.x = xz.x;\n    p.z = xz.y;\n\n    mat2 rotZ = mat2(cos(rotation.z), -sin(rotation.z),\n                     sin(rotation.z),  cos(rotation.z));\n    vec2 xy = rotZ * p.xy;\n    p.x = xy.x;\n    p.y = xy.y;\n  \n  \n  \n\n  \n  p += pivot;//apply pivot\n  \n  \n  vec3 q = abs(p) - b;\n  q = q[0] * deform1 + q[1] * deform2 + q[2] * deform3;\n  q += deformPivot;\n  \n  return Point(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), color, currentId);\n}\n\n//functions\n\nPoint opSmoothUnion(Point d1, Point d2, float k){\n\n    float h = clamp(0.5 + 0.5 * (d2.dist - d1.dist) / k, 0.0, 1.0);\n    \n    vec4 color = mix(d2.color, d1.color, h);\n    \n    int shapeId = h > 0.5 ? d1.shapeId : d2.shapeId;\n    \n    return Point(mix(d2.dist, d1.dist, h) - k * h * (1.0-h), color, shapeId);\n}\n\n\nconst float radius = 1.;\nconst float elementsN = 3.;\nconst float waves = 1.;\n\nPoint map(vec3 p, int jumpShape){\n\nint shapeIndex = 1;\n    \n    Point m = sdfPlane(p, \n        vec3(0.0, 1.0, 0.0), -0.8, vec4(1.0),\n        shapeIndex\n    );\n    \n    shapeIndex++;\n    \n    Point obj;\n    \n    \n     if(shapeIndex != jumpShape){\n    \n\n        obj = sdfSphere(p,\n        vec3(0.0, 0.0, 0.0),\n        1.,\n        vec4(1.000,0.000,0.000,0.58),\n         //rotate\n        vec3(1.55, 1.,  1.6), //rotation\n        vec3(0., 0., 0.), //pivot\n\n        shapeIndex\n        );\n    \n        m = opSmoothUnion(obj, m, 0.3);\n    }\n    shapeIndex++;\n    \n    if(shapeIndex != jumpShape){\n   \n        obj = sdfBox(p, \n        vec3(0.5, 0.5, 0.5), \n        vec3(0.0, 1.0, 2.0),\n        vec4(0.000,1.000,0.000,1.0),\n\n        //base\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.0, 1.0),\n\n        //rotate\n        vec3(iTime, 0., 0.), //rotation\n        vec3(0., 0., 0.), //pivot\n\n        //deform\n        vec3(0.1, 0.5, -0.5),\n        vec3(0.5, -0.1, 0.5),\n        vec3(-0.5, 0.5, 0.1),\n\n        vec3(-0.01, -0.01, -0.01), //deformPivot\n\n        shapeIndex\n        );\n\n        shapeIndex = obj.shapeId;\n    \n        m = opSmoothUnion(obj, m, 0.5);\n       \n    }\n    \n    shapeIndex++;\n\n    if(shapeIndex != jumpShape){\n    \n        obj = sdfBox(p, \n        vec3(0.5, 0.5, 0.5), \n        vec3(cos(iTime * 0.5) * 3.0, 1.0, sin(iTime * 0.5) * 3.0),\n        vec4(1.000,0.533,0.000,1.0),\n\n        //base\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.0, 1.0),\n\n        //rotate\n        vec3(iTime, 0., iTime), //rotation\n        vec3(0., 0., 0.), //pivot\n\n        //deform\n        vec3(0.5, 0.0, 0.0),\n        vec3(0.0, 0.5, 0.0),\n        vec3(0.0, 0.0, 0.5),\n\n        vec3(-0.01, -0.01, -0.01), //deformPivot\n\n        shapeIndex\n        );\n\n        shapeIndex = obj.shapeId;\n    \n   \n        m = opSmoothUnion(obj, m, 0.5);\n       \n    }\n     shapeIndex++;\n    \n    \n    \n\n    \n    return m;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.0001, -0.0001);\n    int j = -1;\n    return normalize(\n          e.xxx * map(p+e.xxx, j ).dist\n        + e.xyy * map(p+e.xyy, j).dist\n        + e.yxy * map(p+e.yxy, j).dist\n        + e.yyx * map(p+e.yyx, j).dist\n            );\n}\n\nPoint rayMarch(vec3 ro, vec3 rd, float maxDist){\n\n    \n    int jShapes = -1;\n    \n    Point p = map(ro, jShapes);\n    float dist = p.dist;\n    Point oldP = Point(MAX_DIST, vec4(0.706,0.992,0.996,1.0), -1);\n    \n    int i = 0;\n    \n    \n    while(dist < maxDist && i < 200){\n      i++;\n      p = map(ro + rd * dist, jShapes);\n      if(p.dist <= MIN_DIST){\n          if(p.color.w >= 1.0){\n              if(oldP.shapeId < 0){\n                  oldP.dist = dist;\n                  oldP.color = p.color;\n                  oldP.shapeId = p.shapeId;\n              }else{\n                  p.color = mix(p.color, oldP.color, oldP.color.w);\n                  oldP.color = p.color;\n              }\n              \n              break;\n          }else{\n              p.color = mix(oldP.color, p.color, p.color.w);\n              oldP.color = p.color;\n              if(oldP.dist >= MAX_DIST){\n                  oldP.dist = dist;\n                  \n                  oldP.shapeId = p.shapeId;\n              }\n              \n             jShapes = p.shapeId;\n          }\n\n      }\n      \n      dist += p.dist;\n    }\n    \n    \n    return oldP;\n\n\n}\n\n\n\nPoint rayMarchShadow(vec3 ro, vec3 rd, float maxDist, int currentShapeId){\n\n    float t = 0.1;\n    Point minDistP = Point(maxDist, vec4(0.706,0.992,0.996,1.0), -1);;\n    for( int i=0; i<256 && t<maxDist; i++ )\n    {\n        Point h = map(ro + rd*t, currentShapeId);\n\n        \n        if(h.dist < MIN_DIST)\n            return Point(0.01, h.color, h.shapeId);\n             \n            \n        if(!(i < 25 && h.shapeId == currentShapeId) && h.dist < minDistP.dist && h.dist < 0.1)\n            minDistP = h;\n            \n        \n        t += h.dist;\n    }\n    \n    if(minDistP.dist != maxDist){\n        minDistP.dist = minDistP.dist * 25.0;\n    }\n    \n    return minDistP;\n\n\n}\n\nvoid camera(vec2 uv,out vec3 ro, out vec3 rd){\n    //camera from https://www.shadertoy.com/view/XsXXDB\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    float hd = -m.x * 14.0 + 3.14159;\n    float elv = m.y * 3.14159 * 0.4 - 3.14159 * 0.25;\n    ro = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n    ro = ro * 8.0 + vec3(0.0, 6.0, 0.0);\n    \n\n    // camera tx\n    vec3 cw = normalize( ta-ro );\n    vec3 cp = vec3( 0.0, 1.0, 0.0 );\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    rd = normalize( uv.x*cu + uv.y*cv + 2.5*cw );\n}\n\nvec3 render(vec2 uv){\n    \n\n    vec3 ro;\n    vec3 rd;\n    vec3 color;\n    \n    camera(uv, ro, rd);\n    \n    Point p = rayMarch(ro, rd, MAX_DIST);\n    \n    \n    if (p.dist < MAX_DIST)\n    {\n        //color = vec3(1.0);\n        \n        //normals\n        vec3 pos = ro + rd * (p.dist); //get point wher you need to calculate the normals\n        vec4 baseColor = p.color;\n        vec3 normal = getNormal(pos);\n        \n        \n        //lighting\n        \n        //ambient\n        vec3 ambient = vec3(1.000,1.000,1.000);\n        \n        //diffuse\n        vec3 lightColor = vec3(1.000,1.000,1.000);\n    \n        \n        float angle = (iTime * 0.05) * pi * 2.;\n        vec3 lightSource = vec3(sin(angle) * 10., 9., cos(angle) * 10.);\n        \n        \n        float diffuseStrength = max(0.0, dot(normalize(lightSource),normal));\n        \n        vec3 diffuse = lightColor * diffuseStrength;\n        \n        //specular\n        lightColor = vec3(1.000,1.000,1.000);\n        \n        vec3 viewSource = normalize(ro);\n        vec3 reflectSource = normalize(reflect(-lightSource,normal));\n        float specularStrength = max(0.0, dot(viewSource, reflectSource));\n        specularStrength = pow(specularStrength, 64.0);\n        vec3 specular = specularStrength * lightColor;\n        \n        vec3 lighting = ambient * 0.4 + diffuse * 1.00 + specular * 0.6;\n        \n        color = baseColor.rgb * lighting;\n        \n        if(diffuseStrength > 0.4){\n        //shadows\n            vec3 lightDirection = normalize(lightSource);\n            float distToLightSource = distance(lightSource, pos);\n            ro = pos;\n            rd = lightDirection;\n            Point pointShadow = rayMarchShadow(ro, rd, distToLightSource, p.shapeId);\n\n\n            if(pointShadow.dist < 1.){\n\n                 color = mix(pointShadow.color.rgb * pointShadow.color[3], color * pointShadow.dist,  pointShadow.color[3]).rgb;\n\n             }   \n        }\n    \n        \n        //gamma correction\n        color = pow(color, vec3(1.0 / 2.2));\n        \n        // Tone mapping\n        //color = 1.-exp(-2.*color);\n        \n    }\n    else{\n        color = p.color.rgb;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n\n    // Correct for aspect ratio\n    uv.x *= aspectRatio;\n\n    vec3 color = vec3(0.0);\n\n    color = render(uv);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}