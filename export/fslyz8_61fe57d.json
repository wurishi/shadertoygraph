{"ver":"0.1","info":{"id":"fslyz8","date":"1641747536","viewed":228,"name":"Snell's Law and Fresnel Calculat","username":"fancyzero","description":"Snell's Law and Fresnel with IOR = 1.33","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["snellfresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nfloat FresnelRef(float b, float c) \n{\n    return .5 * (pow(tan(b - c) / tan(b + c), 2.) + sqrt(sin(b - c)) / sqrt(sin(b + c))); \n}\n\nvec2 Snell( float n1, float n2, float t1) \n{ \n\n    float t2 = asin(n1 / n2 * sin(t1)); \n    \n    float R = FresnelRef(abs(t1), abs(t2)); \n    return vec2(t2, 1.-saturate(R));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //build coordinate\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uv2 = fragCoord/iResolution.xy;\n    vec2 center = iResolution.xy / 2. /iResolution.y;\n    fragColor = mix( vec4(0.1,0.1,0.1,1.0),vec4(0.4,0.4,0.5,0.),step(uv.y, 0.5) );\n    \n    //input\n    vec2 mousePos = iMouse.xy/iResolution.y;\n    if (mousePos.y < 0.501)\n        mousePos.y = 0.501;\n    vec2 incidentDir =  mousePos -center ;\n    float incidentAngle = (atan(incidentDir.x, incidentDir.y));\n    \n    //snell's law to get refraction and refraction angle\n    vec2 snell = Snell( 1., 1.33,incidentAngle);\n    vec2 refractedDir = normalize( vec2(tan(-snell.x),-1.)); \n    float v = step( snell.y, uv.y);\n     \n\n\n    \n    vec3 bound = vec3(1.,0.2,0.4)*Segment(uv, vec2(0.,0.5),vec2(10.,0.5)).a;\n    vec3 incident = vec3(0.2,0.4,0.7)*Segment(uv, incidentDir*10.+center, center).a;\n    vec3 refracted = vec3(0.92,0.2,0.9)*Segment(uv, center, refractedDir+center).a *snell.y;\n    vec3 reflected = vec3(0.92,0.9,0.2)*Segment(uv, center, incidentDir*vec2(-1,1)*10.+center).a*(1.- snell.y);\n    fragColor.xyz += incident+refracted+reflected;\n \n    fragColor = mix( fragColor,texture(iChannel0, uv2),texture(iChannel0, uv2).a);\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//buffer for drawing text and angles\n\n//this is text & UI layer\n//texts\n#define T_sp (256-48)\n#define T_a  (177-32)\n#define T_b  (178-32)\n#define T_c  (179-32)\n#define T_d  (180-32)\n#define T_e  (181-32)\n#define T_f  (182-32)\n#define T_g  (183-32)\n#define T_h  (184-32)\n#define T_i  (185-32)\n#define T_j  (186-32)\n#define T_k  (187-32)\n#define T_l  (188-32)\n#define T_m  (189-32)\n#define T_n  (190-32)\n#define T_o  (191-32)\n#define T_p\t (160-32)\n#define T_q  (161-32)\n#define T_r  (162-32)\n#define T_s  (163-32)\n#define T_t  (164-32)\n#define T_u  (165-32)\n#define T_v  (166-32)\n#define T_w  (167-32)\n#define T_x  (168-32)\n#define T_y  (169-32)\n#define T_z  (170-32)\n#define T_A  177\n#define T_B  178\n#define T_C  179\n#define T_D  180\n#define T_E  181\n#define T_F  182\n#define T_G  183\n#define T_H  184\n#define T_I  185\n#define T_J  186\n#define T_K  187\n#define T_L  188\n#define T_M  189\n#define T_N  190\n#define T_O  191\n#define T_P\t160\n#define T_Q 161\n#define T_R 162\n#define T_S 163\n#define T_T 164\n#define T_U 165\n#define T_V 166\n#define T_W 167\n#define T_X 168\n#define T_Y 169\n#define T_Z 170\n#define T_qq 210\n\nfloat textSize = 1.4;\nfloat textSPace = 20.;\nvec4 textColor = vec4(1.,1.,1.,0.3);\nfloat flatText = 1.;\n#define endl line--; cp=0;\n#define txt(c)   fragColor += DrawText(iChannel0, textSize, uv, vec2(xStart + 0.03+float(cp)/textSPace,float(line)/15.),c,textColor, flatText); cp++;\n\nvec4 CheckBox(vec2 uv, vec2 pos, float size, float checked)\n{\n    float dotSize = size*0.95;\n    float d = length(uv-pos)/size;\n    float c2 = smoothstep(dotSize,dotSize*0.9,d);\n\n   \n    float c = smoothstep(size,size*1.3,d)*smoothstep(size*1.6,size,d);\n    if (checked>0.0)\n        c += c2;\n    return  vec4(1.,1.,1.,c*0.8);\n}\n\nvec2 Rotate(float angle, vec2 coord, vec2 pivot )\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 r;\n    r.x = dot(coord-pivot,vec2(c,-s));\n    r.y = dot(coord-pivot,vec2(s,c));\n    \n    return r+pivot;\n}\nvec3 BoxMask( vec2 uv, vec2 pos, vec2 size)\n{\n    vec2 diff = abs(uv - pos);\n    vec2 mm = (uv - pos);\n    if ( diff.x <size.x && diff.y < size.y)\n        return vec3(vec2(mm+size)/size,1.);\n    else\n        return vec3(0.,0.,0.);\n}\n\n\nvec4 DrawText( sampler2D sampler,float textSize, vec2 uv, vec2 pos, int idx, vec4 color, float flatText)\n{\n    float halfTextSize = textSize/2.0;\n    vec3 mask = BoxMask(uv, pos, vec2(halfTextSize/16.,halfTextSize/16.));\n    int x = idx % 16;\n    int y = idx / 16;\n\n    vec4 txtValue = texture(sampler,mask.xy/32.+vec2(float(x),float(y))/16.);\n    float d = txtValue.w;\n    d = smoothstep(0.49,0.5,1.-d);\n    float outline =txtValue.w;\n    outline = smoothstep(0.47,0.48,1.-txtValue.w);\n    \n    return vec4(outline*color);\n}\n\nvec4 DrawMarks(in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*1.5;\n    vec2 uv2 = fragCoord/iResolution.xy;\n    vec2 center = iResolution.xy / 2. /iResolution.y*1.5;\n\n    uv -= center;\n    float h = -6./180.*PI;\n    uv = Rotate(h, uv, vec2(0));\n\tuv *= 10.5;\n    //fragColor = fract(uv.xyxy);\n\n    float angle = atan( uv.y, uv.x);\n    angle +=PI;\n\n    angle /= PI*2.;\n    float slices = 36.;\n    angle = floor(angle * slices)/slices;\n    float angleFade = angle;\n    angle *= PI*2.;\n    \n    uv = Rotate( -angle+PI, uv, vec2(0));\n    uv = Rotate( PI+angle-h, uv, vec2(7.5,0.5));\n    float displayAngle = 360.-angle*180./PI;\n    displayAngle -= 10.;\n    displayAngle -= 90.;\n    displayAngle = abs(displayAngle);\n    if ( displayAngle > 90. )\n        displayAngle -=180.;\n        \n     displayAngle = abs(displayAngle);\n    //displayAngle = mod(displayAngle,90.);\n    return Debug(iChannel0,displayAngle,2.,2.,vec4(0.1,0.1,0.9,0.9)+vec2(7.,0.).xyxy,uv);      \n\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = vec4(0.,0.,0.,0.);\n    \n    fragColor += DrawMarks(fragCoord);    \n    vec2 uv = fragCoord/iResolution.y*1.5;\n    vec2 uv2 = fragCoord/iResolution.xy;\n    vec2 center = iResolution.xy / 2. /iResolution.y*1.5;\n\t\n    int digits = 0;\n    float asp = iResolution.x/iResolution.y;\n\n   \n    float xStart = 0.06 * asp;\n    int line = 5;\n    int cp = 0;    \n    vec2 dirToCenter = (uv - center);\n    float l = length(dirToCenter);\n    dirToCenter= normalize(dirToCenter);\n    vec2 uvXAxis = vec2(dirToCenter.y, -dirToCenter.x);\n    float angle = acos(abs(dirToCenter.y));\n   // angle = (floor(angle/(PI/2.)*10.)/10.*PI*0.5);\n\nfloat angleDeg = angle*180.0/3.1415926;\n    float mark = fract((angleDeg+5.)*0.1);\n    \n    \n\n    \n   \n    \n    mark = mix(smoothstep(0.48,0.5,mark),smoothstep(0.52,0.5,mark), 1.0-step(mark, 0.5))* smoothstep(0.62,0.6,l)* smoothstep(0.58,0.6,l);\n    fragColor += vec4(mark*2.);\n    \n   \n    textColor = vec4(0.2,0.4,0.7,1.);\n    txt(T_I)txt(T_n)txt(T_c)txt(T_i)txt(T_d)txt(T_e)txt(T_n)txt(T_t)txt(T_sp)endl\n    textColor = vec4(0.92,0.9,0.2,1.);\n    txt(T_R)txt(T_e)txt(T_f)txt(T_l)txt(T_e)txt(T_c)txt(T_t)endl\n    textColor = vec4(0.92,0.2,0.9,1.);\n    txt(T_R)txt(T_e)txt(T_f)txt(T_r)txt(T_a)txt(T_c)txt(T_t)endl\n\n\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n\n#define saturate(x) clamp(x,0.,1.)\nvec2 DistToLine( vec2 uv, vec2 o, vec2 d )\n{\n    float t = dot(uv-o, d);\n    d = d.yx*vec2(-1.,1.);\n    float dist = dot(uv-o,d);\n    return vec2(abs(dist), t);\n}\n\n\nvec4 Segment(vec2 uv,vec2 a, vec2 b)\n{\n    if (dot(a-b,a-b) < 0.0001)\n        return vec4(0.,0.,0.,0.);\n\tvec2 o = (a+b)/2.;\n    vec2 d = normalize(a-b);\n        \n    vec2 dist = DistToLine(uv, o, d);\n\n    \n    float brightness = smoothstep(0.996,1.,1.-dist.x)*11.;\n    return  saturate(vec4(1.,1.,1., brightness*saturate(ceil(1.-abs((dist.y)/length(a-b)*2.)))));    \n}\n\n\nfloat rectMask(vec2 uv, vec4 rect)\n{\n    uv = (uv-rect.xy)/(rect.zw-rect.xy);\n    vec2 z = step(-1.,-uv)*step(0.,uv);\n    \n    return dot(z,z.yx);\n}\n\nfloat getFloatDigit(float v, float d)\n{\n       float i = 0.;\n       float m = 1.;\n       float m2 = 10.;\n       if ( d < 0. )\n       {    \n           d = d*-1.;\n           m2 = 0.1;\n       }\n       while( i < d)\n       {\n           m *= m2;\n           i+=1.;\n       }\n           //*pow(10.0,d)\n    //float mm = pow(10.0,d);\n    return floor(mod(v*m,10.));\n}\n\nvec4 Debug(sampler2D tex, float n, float digits, float intDigits,vec4 rect,vec2 uv)\n{\n    bool isNagetive = false;\n    if (n < 0.)\n    {\n        n *= -1.;\n        isNagetive = true;\n    }\n    \n    float dWidth = (rect.z-rect.x)/digits;\n    float dPos = floor((uv.x-rect.x)/(rect.z-rect.x)*digits);\n    float d = 0.;\n    if (dPos-intDigits < 0. )\n        d = getFloatDigit(n, (dPos+1.)-intDigits);\n    else\n        d = getFloatDigit(n, dPos-intDigits);\n    \n    \n    \n    float mask = rectMask(uv,rect);\n    float rows= 16.;\n    float cols = 16.;\n    \n    float char = 12.*16.+d;\n    if (dPos-intDigits == 0.)\n        char = 14.*16.-2.;\n    if (dPos == 0. && isNagetive)\n        char = 14.*16.-3.;\n    float x = mod(char,rows);\n    float y = floor(char/cols);\n    \n    vec4 subRect = vec4(rect.x +dPos*dWidth, rect.y,rect.x+(dPos+1.)*dWidth, rect.w );\n    vec4 charRect = vec4(x/cols, y/rows,(x+1.)/cols, (y+1.)/rows);\n    vec2 scale = 1./16./(subRect.zw-subRect.xy) ;\n    vec4 c = textureLod(tex,(uv-subRect.xy)*scale+charRect.xy,0.);\n    return smoothstep(0.558,0.45,c.wwww)*mask;\n}\n","name":"Common","description":"","type":"common"}]}