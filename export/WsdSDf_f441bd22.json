{"ver":"0.1","info":{"id":"WsdSDf","date":"1573037532","viewed":152,"name":"Rehabilitation 1","username":"liliilli","description":"I wrote shader in about 3~4 months as i thought.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 kC0 \t\t\t= vec3(0, 50, 10);\nconst vec3 kC1 \t\t\t= normalize(vec3(0, 0, 50)) * length(kC0);\nconst vec3 kCameraFocus = vec3(0, 0, 0);\nconst vec3 kRotAxis \t= vec3(0, 1, 0);\nconst vec3 kSandAlbedo \t= vec3(237, 201, 175) / 255.0f;\n\nconst vec3 kLightDir \t= normalize(vec3(2, 4, 2));\nconst vec3 kAmbient \t= vec3(0.f, 0.05, 0.1f);\nconst int  kLimit       = 256;\nconst float kThre \t\t= 1e-3;\n\nDSphere kSp1 = DSphere(vec3(0, 5, 0), 10.f, \n                       material_t(vec3(1., .2, .0), vec3(0.5f), 0.2f, .5f) );\nDSphere kSp2 = DSphere(vec3(0, 5, 0), 7.5f, \n                       material_t(vec3(.0, .2, 1.), vec3(0.5f), 0.2f, .5f) );\nDSphere kSp3 = DSphere(vec3(0, 5, 0), 5.f, \n                       material_t(vec3(.0, 1., .2), vec3(0.5f), 0.2f, .5f) );\nDSphere kSky = DSphere(vec3(0), 150.f, \n                       material_t(vec3(0), vec3(0), 0.f, .0f) );\n\nDBox kBx1 = DBox(vec3(0, -6, 0), vec3(2.5, .125, 2.5),\n                 material_t(vec3(0.6), vec3(0.5f), 0.2f, .3f));\nDBox kBx2 = DBox(vec3(0, -6.25, 0), vec3(5, .125, 5),\n                 material_t(vec3(0.8), vec3(0.5f), 0.1f, .3f));\n\nDBox kBx3 = DBox(vec3(5, -6, 5), vec3(2.5, .125, 2.5),\n                 material_t(vec3(0.5), vec3(0.5f), 0.0f, .6f));\nDBox kBx4 = DBox(vec3(5, -6, -5), vec3(2.5, .125, 2.5),\n                 material_t(vec3(0.5), vec3(0.5f), 0.0f, .6f));\nDBox kBx5 = DBox(vec3(-5, -6, -5), vec3(2.5, .125, 2.5),\n                 material_t(vec3(0.5), vec3(0.5f), 0.0f, .6f));\n\nvec3 get_sky_color(vec3 n)\n{\n    float skyT = 0.5f * (n.y + 1.0f); // [0, 1]\n  \treturn mix(vec3(1.0f), vec3(0.2f, 0.5f, 1.0f), skyT);\n}\n\nvec3 get_specular_gtrsms(vec3 n, vec3 ld, vec3 fwd, in material_t mat, vec3 hfw)\n{\n\tfloat th = AngleBetween(n, hfw);\n\tfloat td = AngleBetween(ld, hfw);\n\tfloat tv = AngleBetween(n, -fwd);\n\tfloat tl = AngleBetween(n, ld);\n\tfloat cn = 4.f * max(.25f, dot(n, ld)) * max(.25f, dot(n, -fwd));\n\t\n\tfloat d = GTR(9e-3, mat.m_rough, th, 2.f);\n\tfloat f = Schlick(mat.m_r0, td);\n\tfloat g = SeparableMaskingShadowing(tl, td, mat.m_rough);\n    \n    return mat.m_spec * d * f * g / cn;\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord / iResolution.xy) * 2.0f - 1.0f;\n    \n    vec3 cam;\n    cam = Slerp(\n        kC1, kC0, vec3(0), \n        smoothstep(0.f, 1.f, ToVShaped(iTime, 8.f, 0.f, 1.f)) * 0.375f);\n    cam = RotateWithVec3(cam, kRotAxis, iTime * 12.5f);\n    \n    vec3 pos = GetRayPoint(\n        cam, kCameraFocus, iResolution.xy,\n        60.f, 1.f, uv\n    );\n    \n    vec3 fwd = normalize(pos - cam);\n    vec3 ld  = RotateWithVec3(kLightDir, kRotAxis, iTime * 37.5f);\n    vec3 hfw = normalize(ld - fwd);\n    \n    kSp2.mPos.x += sin(iTime * 1.3f) * 20.0f;\n    \n    // Color Variables\n    vec3 dif;\n    vec3 spc;\n    float traveled_len = 0.f;\n\n    for (int i = 0; i < kLimit; ++i) \n    {\n        const float sf = 5.f;\n        float v = 1e+5f;\n        vec3 xz_intv_vec3;\n\n        xz_intv_vec3 = vec3(75.f, 0.f, 75.f);\n        vec3 adj_pos = sdf_ref_pos(pos, xz_intv_vec3);\n        v = SdfSphereSU(adj_pos, kSp1, kSp2, sf);\n        if (v <= kThre)\n        {\n            // Diffuse\n            float h = SdfSmoothFactor(SdfSphere(adj_pos, kSp1), SdfSphere(adj_pos, kSp2), sf);\n            vec3 in_albedo \t= mix(kSp1.m_mat.m_diff, kSp2.m_mat.m_diff, h);\n            vec3 n \t\t\t= SdfSphereNormalSU(adj_pos, kSp1, kSp2, sf);\n            \n            dif = DiffuseOrenNayar(ld, n, in_albedo, kAmbient, -fwd, kSp1.m_mat.m_rough);\n            // Specular\n            spc = get_specular_gtrsms(n, ld, fwd, kSp1.m_mat, hfw);\n            break;\n        }\n        \n        xz_intv_vec3 = vec3(10.f, 0, 10.f);\n        v = min(sdf_ref_box(pos, xz_intv_vec3, kBx1), v);\n        if (v <= kThre)\n        {\n            // Diffuse\n            vec3 n = sdf_ref_box_normal(pos, xz_intv_vec3, kBx1);\n            dif = DiffuseOrenNayar(ld, n, kBx1.m_mat.m_diff, kAmbient, -fwd, kBx1.m_mat.m_rough);\n            // Specular\n            spc = get_specular_gtrsms(n, ld, fwd, kBx1.m_mat, hfw);\n            break;\n        }\n        \n        v = min(sdf_ref_box(pos, xz_intv_vec3, kBx2), v);\n        if (v <= kThre)\n        {\n            // Diffuse\n            vec3 n = sdf_ref_box_normal(pos, xz_intv_vec3, kBx2);\n            dif = DiffuseOrenNayar(ld, n, kBx2.m_mat.m_diff, kAmbient, -fwd, kBx2.m_mat.m_rough);\n            // Specular\n            spc = get_specular_gtrsms(n, ld, fwd, kBx2.m_mat, hfw);\n            break;\n        }\n\n        xz_intv_vec3 = vec3(20.f, 0, 20.f);\n        v = min(sdf_ref_box(pos, xz_intv_vec3, kBx3), v);\n        if (v <= kThre)\n        {\n            // Diffuse\n            vec3 n = sdf_ref_box_normal(pos, xz_intv_vec3, kBx3);\n            dif = DiffuseOrenNayar(ld, n, kBx3.m_mat.m_diff, kAmbient, -fwd, kBx3.m_mat.m_rough);\n            // Specular\n            spc = get_specular_gtrsms(n, ld, fwd, kBx3.m_mat, hfw);\n            break;\n        }\n        \n        v = min(sdf_ref_box(pos, xz_intv_vec3, kBx4), v);\n        if (v <= kThre)\n        {\n            // Diffuse\n            vec3 n = sdf_ref_box_normal(pos, xz_intv_vec3, kBx4);\n            dif = DiffuseOrenNayar(ld, n, kBx4.m_mat.m_diff, kAmbient, -fwd, kBx4.m_mat.m_rough);\n            // Specular\n            spc = get_specular_gtrsms(n, ld, fwd, kBx4.m_mat, hfw);\n            break;\n        }\n        \n        v = min(sdf_ref_box(pos, xz_intv_vec3, kBx5), v);\n        if (v <= kThre)\n        {\n            // Diffuse\n            vec3 n = sdf_ref_box_normal(pos, xz_intv_vec3, kBx5);\n            dif = DiffuseOrenNayar(ld, n, kBx5.m_mat.m_diff, kAmbient, -fwd, kBx5.m_mat.m_rough);\n            // Specular\n            spc = get_specular_gtrsms(n, ld, fwd, kBx5.m_mat, hfw);\n            break;\n        }\n        \n        v = min(SdfInvSphere(pos, kSky), v);\n        if (v <= kThre)\n        {\n            vec3 n = SdfInvSphereNormal(pos, kSky);\n            dif = get_sky_color(-n);\n            break;\n        }        \n        \n        pos = pos + (fwd * v);\n        traveled_len += v;\n    }\n    \n    vec3 col_wo_fog = dif + spc;\n    float mix_factor = pow(clamp(traveled_len, 0.f, 200.f) / 200.f, 2.f);\n    vec3 sky_col = get_sky_color(-SdfInvSphereNormal(pos, kSky));\n    vec3 fin_col = mix(col_wo_fog, sky_col, mix_factor);\n    \n    fragColor = vec4(fin_col, 1);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define FULL_OR\n#define FULL_OR2\n//#define OPTI_OR // https://mimosa-pudica.net/improved-oren-nayar.html\n\nconst float ep = 1e-2;\nconst float pi = 3.1415926535f;\nconst float rt = .45f;\nconst vec3 \tkWorldY\t= vec3(0, 1, 0);\n\nfloat Rand(in float n) \n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nvec3 Project(in vec3 vec, in vec3 proj)\n{\n    return\n        \tdot(vec, proj) * proj\n    / //-------------------------------\n        \t   dot(proj, proj);\n}\n\nvec3 Reject(in vec3 vec, in vec3 proj)\n{\n\treturn vec - Project(vec, proj);\n}\n\nvec3 RotateWithVec3(in vec3 vec, in vec3 axis, in float deg) \n{\n    // https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation\n    float rad = radians(deg);\n    return \n        Project(vec, axis) \n    + \tcos(rad) * Reject(vec, axis)\n    + \tsin(rad) * cross(axis, vec);\n}\n\nfloat ToVShaped(in float i, in float p, in float mn, in float mx)\n{\n    float si = (mod(i, p) / p * 2.f) - 1.f; // [-1, +1)\n    return mix(mn, mx, 1.f - abs(si));\n}\n\nvec3 Lerp(in vec3 p0, in vec3 p1, in float t)\n{\n    return mix(p0, p1, t);\n}\n\nvec3 Slerp(in vec3 p0, in vec3 p1, in vec3 o, in float t)\n{\n    vec3 _p0 = p0 - o;\n    vec3 _p1 = p1 - o;\n   \tfloat co = dot(normalize(_p0), normalize(_p1));\n    float an = acos(co);\n    \n    return p0 * (\n        sin((1. - t) * an)\n    / //-----------------\n        \tsin(an)\n    ) + p1 * (\n          sin(t * an)\n    / //-----------------\n        \tsin(an)\n\t);\n}\n\nstruct DPolar \n{\n    float theta;\n    float phi;\n};\n\nDPolar PolarAngleBetween(in vec3 a, in vec3 b)\n{\n    vec3 na = normalize(a);\n    vec3 nb = normalize(b);\n    \n    float at = acos(na.z); // cos-1(z) = theta\n    float ap = atan(na.y, na.x);\n    \n    float bt = acos(nb.z);\n    float bp = atan(nb.y, nb.x);\n    \n    return DPolar ( distance(at, bt), distance(ap, bp) );\n}\n\nfloat AngleBetween(in vec3 na, in vec3 nb)\n{\n    float cosAngle = dot(na, nb);\n    return acos(cosAngle);\n}\n\n//!\n//! Matrix\n//!\n\nmat4 MakeViewMat(in vec3 orig, in vec3 dest)\n{\n    vec3 colZ = normalize(dest - orig);\n    vec3 colX = normalize(cross(colZ, vec3(0, 1, 0)));\n    vec3 colY = normalize(cross(colX, colZ));\n   \tvec3 colW = -orig;\n    \n    return mat4(\n        vec4(colX, 0),\n        vec4(colY, 0),\n        vec4(colZ, 0),\n        vec4(colW, 1)\n    );\n}\n\nmat4 MakeProjMat(in vec2 screen, in float n, in float f)\n{\n   \tfloat _00 = 2.0f * n / screen.x;\n    float _02 = 0.0f;\n    float _11 = 2.0f * n / screen.y;\n    float _12 = 0.0f;\n    float _22 = - ( f + n ) / ( f - n );\n    float _23 = -2.0f * f * n / ( f - n );\n    \n    return mat4(\n        vec4(_00, vec3(0)),\n        vec4(0, _11, vec2(0)),\n        vec4(_02, _12, _22, -1),\n        vec4(vec2(0), _23, 0)\n    );\n}\n\nvec3 GetRayPoint(\n    in vec3 pos, in vec3 dest, in vec2 res, \n    in float fovY, in float n, in vec2 uv)\n{\n    float halfFovY \t= fovY / 2.0f;\n\tmat4 viewMat \t= MakeViewMat(pos, dest);\n    \n    vec3 scrCenter \t= pos + (n * viewMat[2].xyz);\n    vec3 scrDirX \t= viewMat[0].xyz;\n    vec3 scrDirY \t= viewMat[1].xyz;\n    \n    vec3 scrHalfY   = tan(radians(halfFovY)) * scrDirY;\n    vec3 scrHalfX \t= res.x / res.y * length(scrHalfY) * scrDirX;\n    \n    return\n        scrCenter \n    + \tuv.x * scrHalfX\n    +   uv.y * scrHalfY;\n}\n\n//!\n//! SDF Utilities\n//!\n\nfloat SdfSmoothFactor(in float d1, in float d2, in float k)\n{\n    return clamp( 0.5f + 0.5f * (d2-d1) / k, 0.0f, 1.0f );\n}\n\nfloat sdf_u( float d1, float d2 ) { return min(d1,d2); }\n\nfloat SdfSmoothU(in float d1, in float d2, in float k ) \n{\n    float h = SdfSmoothFactor(d1, d2, k);\n    return mix( d2, d1, h ) - k * h * (1.0f - h);\n}\n\n//!\n//! SDF models\n//!\n\nstruct material_t \n{\n    vec3  m_diff;\n    vec3  m_spec;\n    float m_rough;\n    float m_r0;\n};\n\nstruct DSphere\n{\n    vec3  mPos;\n    float mScale;\n    \n    material_t m_mat;\n};\n    \nfloat SdfSphere(in vec3 p, in DSphere s)\n{\n    return distance(p, s.mPos) - s.mScale;\n}\n\nfloat SdfSphereSU(in vec3 p, in DSphere s1, in DSphere s2, in float k)\n{\n    float v1 = SdfSphere(p, s1);\n    float v2 = SdfSphere(p, s2);\n    return SdfSmoothU(v1, v2, k);\n}\n\nfloat SdfSphereSU(in vec3 p, in DSphere s1, in DSphere s2, in DSphere s3, in float k)\n{\n    float v1 = SdfSphere(p, s1);\n    float v2 = SdfSphere(p, s2);\n    float v3 = SdfSphere(p, s2);\n    \n    float sm1 = SdfSmoothU(v1, v2, k);\n    float sm2 = SdfSmoothU(v1, v3, k);\n    return SdfSmoothU(sm1, sm2, k);\n}\n\nvec3 SdfSphereNormal(in vec3 p, in DSphere s)\n{\n \treturn normalize(vec3(        \n        SdfSphere(p + vec3(ep, 0, 0), s) - SdfSphere(p - vec3(ep, 0, 0), s),\n        SdfSphere(p + vec3(0, ep, 0), s) - SdfSphere(p - vec3(0, ep, 0), s),\n        SdfSphere(p + vec3(0, 0, ep), s) - SdfSphere(p - vec3(0, 0, ep), s)\n    ));\n}\n\nvec3 SdfSphereNormalSU(in vec3 p, in DSphere s1, in DSphere s2, in float k)\n{\n    vec3 xp = p + vec3(ep, 0, 0);\n    vec3 xm = p - vec3(ep, 0, 0);\n    vec3 yp = p + vec3(0, ep, 0);\n    vec3 ym = p - vec3(0, ep, 0);\n    vec3 zp = p + vec3(0, 0, ep);\n    vec3 zm = p - vec3(0, 0, ep);\n    \n \treturn normalize(vec3(        \n        SdfSphereSU(xp, s1, s2, k) - SdfSphereSU(xm, s1, s2, k),\n        SdfSphereSU(yp, s1, s2, k) - SdfSphereSU(ym, s1, s2, k),\n        SdfSphereSU(zp, s1, s2, k) - SdfSphereSU(zm, s1, s2, k)\n    ));\n}\n\nfloat SdfInvSphere(in vec3 p, in DSphere s)\n{\n    return -SdfSphere(p, s);\n}\n\nvec3 SdfInvSphereNormal(in vec3 p, in DSphere s)\n{\n \treturn normalize(vec3(        \n        SdfInvSphere(p + vec3(ep, 0, 0), s) - SdfInvSphere(p - vec3(ep, 0, 0), s),\n        SdfInvSphere(p + vec3(0, ep, 0), s) - SdfInvSphere(p - vec3(0, ep, 0), s),\n        SdfInvSphere(p + vec3(0, 0, ep), s) - SdfInvSphere(p - vec3(0, 0, ep), s)\n    ));\n}\n\nstruct DBox\n{\n    vec3 mPos;\n    vec3 mScale;\n    \n    material_t m_mat;\n};\n\nfloat SdfBox(in vec3 p, in DBox b)\n{\n    vec3 rp = p - b.mPos;\n    vec3 q = abs(rp) - b.mScale;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec3 SdfBoxNormal(in vec3 p, in DBox b)\n{\n \treturn normalize(vec3(        \n        SdfBox(p + vec3(ep, 0, 0), b) - SdfBox(p - vec3(ep, 0, 0), b),\n        SdfBox(p + vec3(0, ep, 0), b) - SdfBox(p - vec3(0, ep, 0), b),\n        SdfBox(p + vec3(0, 0, ep), b) - SdfBox(p - vec3(0, 0, ep), b)\n    ));\n}\n\nfloat SdfPlane(in vec3 p, in vec3 o, in vec3 n)\n{\n    float d = -dot(o, n);\n    vec4 f = vec4(n, d);\n    \n    return dot(f, vec4(p, 1));\n}\n\nvec3 SdfPlaneNormal(in vec3 n)\n{\n    return n;\n}\n\nfloat sdf_onion( in float sdf, in float thickness )\n{\n    return abs(sdf) - thickness;\n}\n\nfloat sdf_smooth_sub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdf_smooth_inter( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec3 sdf_ref_pos(in vec3 p, in vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat sdf_ref_box( in vec3 p, in vec3 c, in DBox b )\n{\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    return SdfBox( q, b );\n}\n\nvec3 sdf_ref_box_normal( in vec3 p, in vec3 c, in DBox b )\n{\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    return SdfBoxNormal(q, b);\n}\n\n//!\n//! Diffuse reflectance Model\n//!\n\nfloat FactorDiffLambertian(in vec3 l, in vec3 n) \n{\n\treturn max(0.0f, dot(l, n)) / pi;\n}\n\nvec3 DiffuseLambertian(in vec3 l, in vec3 n, \n                       in vec3 diffuse, in vec3 ambient) \n{\n    return mix(ambient, diffuse, FactorDiffLambertian(l, n) * pi);\n}\n\n\nfloat OrenNayarAlpha(in vec3 l, in vec3 n, in vec3 v)\n{\n#ifdef FULL_OR\n    DPolar ln = PolarAngleBetween(l, n);\n    DPolar vn = PolarAngleBetween(v, n);\n    \n    return max(ln.theta, vn.theta);\n#else\n    return dot(l, v) - dot(n, l) * dot(n, v);\n#endif\n}\n\nfloat OrenNayarBeta(in vec3 l, in vec3 n, in vec3 v)\n{\n#ifdef FULL_OR\n    DPolar ln = PolarAngleBetween(l, n);\n    DPolar vn = PolarAngleBetween(v, n);\n    \n    return min(ln.theta, vn.theta);\n#else\n   \treturn mix(\n        1.f,\n        max(dot(n, l), dot(n, v)),\n        step(1e-5, OrenNayarAlpha(l, n, v))\n    );\n#endif\n}\n\nfloat OrenNayarA(in float r)\n{\n#ifdef FULL_OR\n    return 1.0f - 0.5f * (\n        \t\t(r * r)\n    / // ----------------------\n        \t(r * r + 0.33f)\n    );\n#elif defined(FULL_OR2)\n    return 1.0f - 0.5f * (\n         \t\t(r * r)\n    / // ----------------------\n        \t(r * r + 0.33f)           \n    )\n    + 0.17f * (\n        \t\t(r * r)\n    / // ----------------------\n        \t(r * r + 0.13f)\n    );\n#elif defined(OPTI_OR)\n    return \n        \t\t\t   1.f\n    / // -----------------------------\n        (pi + (pi / 2.f - 0.667f) * rt);\n#endif\n}\n\nfloat OrenNayarB(in float r)\n{\n#if defined(FULL_OR) || defined(FULL_OR2)\n    return 0.45f * (\n         \t\t(r * r)\n    / // ----------------------\n        \t(r * r + 0.09f)\n    );\n#elif defined(OPTI_OR)\n\treturn\n        \t\t\t rt\n    / // ----------------------------\n        (pi + (pi / 2.f - 0.667f) * rt);\n#endif\n}\n\nfloat FactorDiffOrenNayar(in vec3 l, in vec3 n, in vec3 v, in float r)\n{\n    float A  \t= OrenNayarA(r);\n    float B \t= OrenNayarB(r);\n    float _a \t= OrenNayarAlpha(l, n, v);\n    float _b \t= OrenNayarBeta(l, n, v);\n    \n#ifdef FULL_OR\n    DPolar ln \t= PolarAngleBetween(l, n);\n    DPolar vn \t= PolarAngleBetween(v, n);\n    \n    return\n        FactorDiffLambertian(l, n)\n    * \t(A + (B * max(0.0f, cos(ln.phi - vn.phi)) * sin(_a) * tan(_b)));\n#elif defined(FULL_OR2)\n    return FactorDiffLambertian(l, n) * (A + B * (_a / _b));\n#elif defined(OPTI_OR)\n    return FactorDiffLambertian(l, n) * (A + B * (_a / _b)) * pi * 0.9f;\n#endif\n}\n\nvec3 DiffuseOrenNayar(in vec3 l, in vec3 n, \n                      in vec3 diffuse, in vec3 ambient, \n                      in vec3 v, in float r) \n{\n    return mix(ambient, diffuse, FactorDiffOrenNayar(l, n, v, r) * pi);\n}\n\n//!\n//! Specular Reflectance Models & Helper functions\n//!\n\nfloat Schlick(in float r0, in vec3 n, in vec3 v) \n{\n    return r0 + (1. - r0) * pow(1. - max(0.f, dot(n, v)), 5.f);\n}\n\nfloat Schlick(in float r0, in float td) \n{\n    return r0 + (1. - r0) * pow(1. - max(0.f, cos(td)), 5.f);\n}\n\nfloat GTR(in float c, in float r, in float dh, in float delta)\n{\n    return \n        \t\t\t\t\t\t c\n    / //--------------------------------------------------------\n        pow(r * r * cos(dh) * cos(dh) + sin(dh) * sin(dh), delta);\n}\n\nfloat Lambda(in float rad, in float r)\n{\n    return \n        (-1.f + sqrt(1.f + r * r * (1.f / cos(rad) * cos(rad) - 1.f))) * .5f;\n}\n\nfloat SmithMasking(in float rad, in float r)\n{\n    return\n        \t\t1.f\n    / //-----------------------\n        (1.f + Lambda(rad, r));\n}\n\nfloat SeparableMaskingShadowing(in float tl, in float tv, in float r)\n{\n    return SmithMasking(tl, r) * SmithMasking(tv, r);\n}\n","name":"Common","description":"","type":"common"}]}