{"ver":"0.1","info":{"id":"7dB3DW","date":"1617399926","viewed":130,"name":"C64 Dithering","username":"winden","description":"c64 noised quantization + tuning of brigthness & colours via YUV-inspired separations.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","c64","quantization","yuv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\n\n#define PALETTE_SIZE 16\n\n\nvec3 palette[PALETTE_SIZE];\n\n\n//Initalizes the color palette.\nvoid InitPalette()\n{\n    //16-Color C64 color palette.\n\tpalette = vec3[](\n        RGB(  0,  0,  0),\n        RGB(255,255,255),\n        RGB(152, 75, 67),\n        RGB(121,193,200),\t\n        RGB(155, 81,165),\n        RGB(104,174, 92),\n        RGB( 62, 49,162),\n        RGB(201,214,132),\t\n        RGB(155,103, 57),\n        RGB(106, 84,  0),\n        RGB(195,123,117),\n        RGB( 85, 85, 85),\t\n        RGB(138,138,138),\n        RGB(163,229,153),\n        RGB(138,123,206),\n        RGB(173,173,173)\n\t);\n}\n\nfloat rgb2y(in vec3 src) {\n  return (77.0 * src.r + 150.0 * src.g + 25.0 * src.b) / 255.0;\n}\n\nvec3 nearestColor( in vec3 src, in vec2 pos )\n{\n  float src_br = rgb2y(src);\n  vec3 src_grey = vec3(src_br);\n  vec3 src_col = src - src_grey;\n\n  float amount = 0.45;\n\n  vec3 noise = texture( iChannel0 , pos / 64.0 , 1.5).xyz;\n  noise -= vec3(0.5);\n\n  vec3 dither = vec3(0.0);\n\n  int px = int(mod(pos.x + pos.y, 6.0) / 3.0);\n  int py = int(mod(pos.y - pos.x, 6.0) / 3.0);\n  int pxy = (px << 1) + py;\n  if (pxy == 0) {\n    dither.g += 0.5;\n  } else if (pxy == 1) {\n    dither.r += 0.5;\n    dither.b -= 0.5;\n  } else if (pxy == 2) {\n    dither.r -= 0.5;\n    dither.b += 0.5;\n  } else if (pxy == 3) {\n    dither.g -= 0.5;\n  }\n  vec3 col = src + (2.5 * noise - 0.5 * dither) * amount;\n\n\n  vec3 nearest_delta;\n  int nearest = -1;\n  float nearest_dist = 100000.0;\n  for (int i = 0 ; i < PALETTE_SIZE ; i++) {\n     vec3 delta = col - palette[i];\n     float dist = length(delta);\n     if (dist < nearest_dist) {\n       nearest = i;\n       nearest_delta = delta;\n       nearest_dist = dist;\n     }\n  }\n  vec3 dst = palette[nearest];\n  float k = 0.75 * clamp(pow(nearest_dist, 3.1), 0.0, 0.25);\n  dst = dst - normalize(nearest_delta) * 0.85 * k;\n\n  float dst_br = rgb2y(dst);\n  \n  \n  vec3 dst_grey = vec3(dst_br);\n  vec3 dst_col = dst - dst_grey;\n  \n  return mix(dst, dst_grey, 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitPalette();\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime*.75+4.0*uv.xyx*vec3(2,1,3));\n\n    // Remap to C64.\n    col = nearestColor(col, fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}