{"ver":"0.1","info":{"id":"7tjXWd","date":"1629793699","viewed":306,"name":"Day 60smth WIP","username":"jeyko","description":"poto","likes":8,"published":3,"flags":32,"usePreview":0,"tags":["pathtracing","monochrome","mdtmjvm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// box intersection from IQ\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C= T(U);\n    C = pow(C,vec4(0.4545));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define T(u) texture(iChannel0,(u)/R)\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat r11(float g){return fract(sin(g*12.5)*4.5);}\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n#define pmod(p,a) mod(p,a) - 0.5*a\nvec3 gp;\nvec3 get(vec3 p){\np.xz *=rot(0.25);\n    p.x += iTime + sin(iTime);\n    vec3 c = vec3(0);\n    p*=1.16;\n    gp = p;\n    float md = 0.2;\n    //p.x += iTime + sin(iTime);\n    vec3 id = floor(p/md);\n    //p.x = pmod(p.x,md);\n    c += mod(id.x,2.);\n    c = vec3(dot(c,c));\n    c = clamp(c*20.,0.06,1.);\n    return c;\n}\nvec3 n;\nvec2 intersect(vec3 ro, vec3 rd){\n    return boxIntersection(ro,rd,vec3(1),n);\n\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C -= C;\n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv,0.2));\n    float t = iTime + sin(iTime + 3.);\n    rd.xz *= rot((t)*0.4);\n    rd.xy *= rot((t)*0.4);\n    vec3 p = ro;\n    vec3 att = vec3(1);\n    \n    for(float bnc = 0.; bnc < 1.; bnc++){\n        vec2 box = intersect(p,rd);\n        p = p + rd*box.y;\n        vec3 c = get(p);\n        //C.xyz += c*att;\n        att *= c;\n        float bncSubCnt = 40.;\n        float ratio = 0.2 + 0.9*floor(mod(gp.y*2.,2.));;\n        \n        p += n*0.001;\n        for(float bncSub = 0.; bncSub < bncSubCnt; bncSub++){\n            vec3 diff = hash33(vec3(uv*16.,bncSub + float(iFrame)*0.6));\n            diff = normalize(diff);\n            if(dot(diff,n)<0.)\n                diff = -diff;\n            \n            vec3 brd = reflect(rd,n);\n            brd = mix(-brd,diff,ratio);\n            brd = normalize(brd);\n            vec2 scene = intersect(p,brd);\n            vec3 pp = p + brd * scene.y;\n            vec3 c = get(pp);\n            C.xyz += c*att/bncSubCnt;\n            //att *= c;\n        \n            //vec2 \n        }\n    }\n    //C += box.y*0.1;\n    \n    \n    \n    \n    \n    if(iFrame == 0){\n        C = vec4(0,0,0,1);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}