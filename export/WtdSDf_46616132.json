{"ver":"0.1","info":{"id":"WtdSDf","date":"1581881459","viewed":553,"name":"Apollonian Gasket Möbius","username":"fizzer","description":"Another apollonian gasket for shadertoy, but this one renders the limit circles directly. This is done by composing the inverse Möbius transformations applied during iteration. The final transformation maps the base limit circles back to screenspace.","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["mobius","inversion","apollonian","gasket"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = acos(-1.);\nconst int numCircles = 6; // Set this to 4, for the classic gasket.\n\n// See https://en.wikipedia.org/wiki/M%C3%B6bius_transformation\n\nconst mat4x2 minv = mat4x2(vec2(0, 0),\n                           vec2(1, 0),\n                           vec2(1, 0),\n                           vec2(0, 0));\n\nconst mat4x2 midentity = mat4x2(vec2(1, 0),\n                                vec2(0, 0),\n                                vec2(0, 0),\n                                vec2(1, 0));\n\nvec2 cMul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, \n                a.x * b.y + a.y * b.x);\n}\n\nvec2 cConj(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nvec2 cInverse(vec2 a)\n{\n    return vec2(a.x, -a.y) / dot(a.xy, a.xy);\n}\n\nvec2 cDiv( vec2 a, vec2 b)\n{\n    return cMul(a, cInverse(b));\n}\n\nvec2 cMobius(vec2 x, mat4x2 m)\n{\n    return cDiv(cMul(x, m[0]) + m[1], cMul(x, m[2]) + m[3]);\n}\n\nmat4x2 cMobiusConcat(mat4x2 ma, mat4x2 mb)\n{\n    return mat4x2(cMul(ma[0], mb[0]) + cMul(ma[1], mb[2]),\n                  cMul(ma[0], mb[1]) + cMul(ma[1], mb[3]),\n                  cMul(ma[2], mb[0]) + cMul(ma[3], mb[2]),\n                  cMul(ma[2], mb[1]) + cMul(ma[3], mb[3]));\n}\n\nmat4x2 cMobiusInverse(mat4x2 m)\n{\n    return mat4x2(m[3], -m[1], -m[2], m[0]);\n}\n\nvec3 cMobiusOnCircle(mat4x2 T, vec3 C)\n{\n    vec3 D;\n    vec2 z;\n\n    // There is a +1e9 here to handle a divide-by-zero when T is the identity.\n    z = C.xy - cDiv(vec2(C.z * C.z, 0), cConj(cDiv(T[3], T[2] + 1e-9) + C.xy));\n    D.xy = cMobius(z, T).xy;\n    D.z = length(D.xy - cMobius(C.xy + vec2(C.z, 0), T));\n    return D;\n}\n\n// These are the N inversion circles necessary to produce the fractal which is the limit\n// set of a Kleinian group. The Möbius transformations which represent inversions in these circles\n// are the generators of the Kleinian group.\nvec3 getInversionCircle(int i)\n{\n    float theta = pi / float(numCircles - 1);\n    float r0 = tan(theta);\n    float r1 = 1. / cos(theta);\n    if(i == (numCircles - 1))\n        return vec3(0., 0., r1 - r0);\n    return vec3(cos(float(i) * theta * 2.) * r1, sin(float(i) * theta * 2.) * r1, r0);\n}\n\n// These are the N circles which are the minimum set of circles which all of the other circles\n// in the limit set are images of. There are N-1 circles in a circular chain of tangency, and\n// one circle surrounding the gasket with radius 1.\nvec3 getLimitCircle(int i)\n{\n    float theta = pi / float(numCircles - 1);\n    float r0 = tan(theta);\n    float r1 = 1. / cos(theta);\n    float r = (r1 - r0) * tan(theta);\n    float r2 = (r1 - r0) / cos(theta);\n    if(i == (numCircles - 1))\n        return vec3(0., 0., 1.);\n    return vec3(-cos((float(i)) * theta * 2.) * r2, sin((float(i)) * theta * 2.) * r2, r);\n}\n\nvec3 getInnerLimitCircle()\n{\n    float theta = pi / float(numCircles - 1);\n    float r0 = tan(theta);\n    float r1 = 1. / cos(theta);\n    float r = (r1 - r0) * tan(theta);\n    float r2 = (r1 - r0) / cos(theta);\n    return vec3(0., 0., r2 - r);\n}\n\nmat4x2 makeMobiusForInversionInCircle(vec3 ic)\n{\n    mat4x2 ma = mat4x2(vec2(1. / ic.z, 0),\n                       vec2(-ic.x / ic.z, ic.y / ic.z),\n                       vec2(0, 0),\n                       vec2(1, 0));\n\n    mat4x2 mb = mat4x2(vec2(ic.z, 0),\n                       vec2(ic.x, ic.y),\n                       vec2(0, 0),\n                       vec2(1, 0));\n\n    return cMobiusConcat(cMobiusConcat(mb, minv), ma);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n\n    float scale = 1.;\n\n    fragColor = vec4(0, 0, 0, 1);\n\n\n    vec2 z = vec2(p.x, p.y);\n\n    mat4x2 mi = midentity;\n\n    if(iMouse.z > .5)\n    {\n        // This mouse interaction is based on mla's shader: https://www.shadertoy.com/view/MlVfzy\n        \n        mat4x2 m = midentity;\n\n        vec2 mo = (2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0)) * vec2(1, -1);\n\n        if(length(mo) < 0.999)\n        {\n            vec2 c = mo * (1.0 / dot(mo, mo));\n            vec3 ic = vec3(c, sqrt(dot(c, c) - 1.));\n\n            m = makeMobiusForInversionInCircle(ic);\n        }\n\n\n        mi = cMobiusConcat(mi, cMobiusInverse(m));\n\n        z = cMobius( z, m );\n    }\n\n    // Rotate the gasket *after* the mouse position inversion.\n\n    float t = iTime * .4;\n    mat4x2 mrotation = mat4x2(vec2(cos(t), sin(t)),\n                              vec2(0, 0),\n                              vec2(0, 0),\n                              vec2(1, 0));\n\n    mi = cMobiusConcat(mi, cMobiusInverse(mrotation));\n\n    z = cMobius( z, mrotation );\n\n\n\n    for(int i = 0; i < 64; ++i)\n    {\n        int k = -1;\n\n        mat4x2 m;\n        vec3 ic;\n\n        for(int j = 0; j < numCircles; ++j)\n        {\n            vec3 c = getInversionCircle(j);\n            \n            if(distance(z.xy, c.xy * vec2(1, -1)) < c.z)\n            {\n                k = j;\n                ic = c;\n                break;\n            }\n        }\n\n        if(k == -1)\n            break;\n\n        ic.x += 1e-9;\n\n        m = makeMobiusForInversionInCircle(ic);\n\n        mi = cMobiusConcat(mi, cMobiusInverse(m));\n\n        z = cMobius( z, m );\n    }\n\n    vec3 col = vec3( 0 );\n    float d = 0.;\n\n    for(int i = 0; i < numCircles; ++i)\n    {\n        vec3 C = getLimitCircle(i);\n        vec3 D = cMobiusOnCircle(mi, C);\n\n        if(D.z > 1e-9 && D.z < 1. && abs(D.z - 1.) > .01)\n        {\n            vec2 v = p.xy - D.xy;\n\n            if(length(v) < D.z)\n            {\n                vec3 e = vec3(0, 0, -1);\n                vec3 n = vec3(v / D.z, sqrt(1. - dot(v, v) / (D.z * D.z)));\n                vec3 r = reflect(e, n);\n                float fr = mix(.05, 1., pow(clamp(1. - dot(n, -e), 0., 1.), 2.));\n\n                float dx = scale / n.z / D.z;\n                float mip = log2(dx);\n\n                vec3 col2 = vec3(0);\n\n                col2 += 1.5 * (1. - fr) * (n.y * .5 + .5) * textureLod(iChannel2, v.yx / n.z / D.z / 2.,mip).rgb;\n                col2 += textureLod(iChannel0,r,mip).rgb * fr;\n\n                col2 = mix(vec3(.25), col2, 1. - smoothstep(D.z - 2. / iResolution.x * scale, D.z, length(v)));\n                \n                d = 1.;\n                col += col2;\n                break;\n            }\n        }\n    }\n\n    if(d < .5)\n        col = vec3(.2);\n\n\n    fragColor.rgb = pow(clamp(col, 0., 1.), vec3(1. / 2.2));\n    fragColor.a = 1.;\n}","name":"Image","description":"","type":"image"}]}