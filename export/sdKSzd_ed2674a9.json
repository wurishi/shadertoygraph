{"ver":"0.1","info":{"id":"sdKSzd","date":"1635168967","viewed":137,"name":"Schwarzschild Grav Lensing","username":"brosefine","description":"Visualization of grav lensing by a schwarzschild black hole\nRaytracing based on \"Short-cut method of solution of geodesic equations for Schwarzchild black hole\" by J.Marck and http://rantonels.github.io/starless/\ncamera's sky is projected equirectangular","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// turn on/of effects here\n\n//#define CHECKEREDHOR\n//#define DISK\n#define SPHERE\n#define BACKGROUND\n#define ROTATE\n//#define NODISTORT\n\n#define PI 3.14159265359\n#define STP 0.2\n#define MAXSTP 200\n\n// units are chosen s.t. c = G = 1\n// black hole mass\n#define M 1.0 \n// event horizon radius\nfloat rs = 2.0 * M;\n\n#ifdef DISK\nfloat minRad = 4.0;\nfloat maxRad = 9.0;\n#endif\n\n#ifdef ROTATE\n// negative values rotates camera to the left\nfloat rotationSpeed = -0.1;\n#endif\n\n// view disk from slightly above\n#ifdef DISK\nvec3 camPos = vec3(0, 1, 10);\n#else\nvec3 camPos = vec3(0, 0, 10);\n#endif\n\n// x = radius, y = distance to black hole\nvec2 sphere = vec2(1.0, 6.0);\n\n\n// functions for rotation using quaternions\n// from https://gist.github.com/nkint/7449c893fb7d6b5fa83118b8474d7dcb\nvec4 setAxisAngle (vec3 axis, float rad) {\n  rad = rad * 0.5;\n  float s = sin(rad);\n  return vec4(s * axis.x, s * axis.y, s * axis.z, cos(rad));\n}\n\nvec4 multQuat(vec4 q1, vec4 q2) {\n  return vec4(\n    q1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n    q1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n    q1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n    q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n  );\n}\n\nvec3 rotateVector( vec4 quat, vec3 vec ) {\n  // https://twistedpairdevelopment.wordpress.com/2013/02/11/rotating-a-vector-by-a-quaternion-in-glsl/\n  vec4 qv = multQuat( quat, vec4(vec, 0.0) );\n  return multQuat( qv, vec4(-quat.x, -quat.y, -quat.z, quat.w) ).xyz;\n}\n\n\nvec3 dv(vec3 pos, float h2){\n    return -3.0 * h2 * M * pos / pow(dot(pos, pos), 2.5);\n}\n\n#ifdef DISK\nbool diskIntersect (vec3 pos, vec3 vel, inout vec4 col) {\n    if(abs(pos.y) > abs(vel.y) || sign(pos.y) == sign(vel.y)) return false;\n    if(vel.y == 0.0) return false;\n\n    vec3 diskHit = pos - pos.y * vel / vel.y;\n    if(length(diskHit) > minRad && length(diskHit) < maxRad) {\n\n        float heat = 1.0 - (length(diskHit) - minRad)/(maxRad-minRad);\n        col = vec4(2.0 * vec3(1.0, heat, pow(heat,2.0)), 0.5);\n\n        return true;\n    }\n\n    return false;\n}\n#endif //DISK\n\nbool horizonIntersect (vec3 pos, vec3 vel, float r, inout vec4 col) {\n    // ray-sphere intersection from scratch-a-pixel\n    // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n    float x0, x1;\n    float a = dot(vel, vel);\n    float b = 2.0 * dot(pos, vel);\n    float c = dot(pos, pos) - r*r;\n    float discr = b * b - 4.0 * a * c; \n    if (discr < 0.0) {\n        col = vec4(1,1,1,1);\n        return false; \n    } else if (discr == 0.0) {\n        x0 = x1 = - 0.5 * b / a; \n    } else { \n        float q = (b > 0.0) ? \n            -0.5 * (b + sqrt(discr)) : \n            -0.5 * (b - sqrt(discr)); \n        x0 = q / a; \n        x1 = c / q; \n    } \n\n    if(( min(x0,x1) >= 1.0 || max(x0,x1) <= 0.0) )\n    {\n        col = vec4(1,1,1,1);\n        return false; \n    }\n\n    vec3 horHit = pos + max(x0, x1) * vel;\n\n    float phi = max(0.0,(atan(horHit.x, horHit.z) + PI) / (2.0*PI));\n    float theta = max(0.0,(atan(length(horHit.xz), (horHit.y)) + PI) / (2.0*PI));\n    float phiWeight = mod(round(18.0*phi),2.0);\n    float thetaWeight = mod(round(18.0*theta),2.0);\n    col = vec4(phi, vec2(1.0) * round(mod(thetaWeight + phiWeight,2.0)), 1);\n    //col = vec4(abs(normalize(horHit)), 1);\n    return true;\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 fragCoord )\n{\n    \n    vec4 horizonColor;\n    vec4 diskColor;\n    FragColor = vec4(0);\n    \n    // Normalized pixel coordinates (from 0 to 1, aspect ratio 1:2)\n    vec2 uv;\n    uv.x = fragCoord.x/iResolution.x;\n    uv.y = (fragCoord.y - 0.5*iResolution.y)/(iResolution.x*0.5) + 0.5;\n    if(uv.y < 0.0 || uv.y > 1.0) return;\n\n    \n    float phi = (1.0-uv.x) * 2.0 * PI;\n    float theta = (1.0-uv.y) * PI;\n    \n    \n    vec3 raydir;\n    raydir.x = sin(phi) * sin(theta);\n    raydir.y = cos(theta);\n    raydir.z = cos(phi) * sin(theta);\n    \n    vec3 spherePos = sphere.y * vec3(cos(iTime), 0, sin(iTime));\n    \n    raydir = normalize(raydir);\n    vec3 raypos = camPos;\n    vec3 up = cross(camPos, raydir);\n    float h2 = dot(up, up);\n    \n    float step = STP;\n    for(int i = 0; i < MAXSTP; ++i) {\n        \n        // step size depends on distance to black hole\n        step = max(0.0001, STP * (length(raypos) - rs));\n\n        vec3 acc = dv(raypos, h2);\n        \n        #ifndef NODISTORT\n        raydir += acc * step;\n        #endif\n        raypos += raydir * step;\n         \n        // check if ray has passed event horizon\n        #ifdef CHECKEREDHOR\n        if(horizonIntersect (raypos, -raydir*step, rs, horizonColor)){\n            FragColor.rgb += (1.0 - FragColor.a) * horizonColor.rgb;\n        #else \n        if(length(raypos) <= rs){\n        #endif //CHECKEREDHOR\n            return;\n        }\n        \n        // check if ray crosses accretion disk\n        #ifdef DISK\n        if (diskIntersect(raypos, -step*raydir, diskColor)) {\n            FragColor.rgb += (1.0 - FragColor.a) * diskColor.rgb * diskColor.a;\n            FragColor.a += diskColor.a;\n            if(FragColor.a > 0.99) return;\n        }\n        #endif //DISK\n        \n        // terminate ray if \n        // - already passed black hole (distance is growing again)\n        // - and if change in direction is samll\n        if (dot(raypos, raydir) > 0.0 && \n            length(acc*step) <= length(raydir) * 0.001) {\n            break;\n        }\n\n\n        #ifdef SPHERE\n        if (horizonIntersect (raypos - spherePos, -raydir*step, sphere.x, horizonColor))\n        {\n            FragColor.rgb += (1.0 - FragColor.a) * horizonColor.bgr;\n            return;\n        }\n        #endif //SPHERE\n    }\n    \n    #ifdef ROTATE\n    float rotation = iTime * rotationSpeed;\n    vec4 rotQuat = (setAxisAngle(vec3(0, 1, 0), -rotation));\n    raydir = normalize(rotateVector(rotQuat, raydir));\n    #endif\n    #ifdef BACKGROUND\n    FragColor.rgb += (1.0-FragColor.a) * texture(iChannel0, normalize(raydir)).rgb;\n    #else\n    // Background color is final ray direction as color (x,y,z)->(r,g,b)\n    FragColor.rgb += (1.0-FragColor.a) * normalize(abs(raydir));\n    #endif\n    FragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}