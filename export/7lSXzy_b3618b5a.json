{"ver":"0.1","info":{"id":"7lSXzy","date":"1627929715","viewed":92,"name":"Proc. terrain weird rivers","username":"Epromee","description":"I made a custom isotropically-looking deterministic noise\nThen added a Perlin-like gradient wrapper on it\nThen added a few layers of prevoius, altered a little bit to make it mutable\nSum everything and add some weird rivers - success! :P","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","terrain"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n/* Custom isotropically-looking noise */\nfloat randDetAt(int x, int y, int seed) {\n\n    int discr = 256;\n    \n    // what am I doing?\n    // idk\n    // who knows?\n    // nb\n    // what the hell then?\n    // nvm\n    \n    y ^= seed;  \n    \n    x += 255 ^ (y * y + 1);\n    \n    x += seed;\n    \n    y += x\n            ^ (x * 3 >> 1)\n            ^ (x * 5 >> 2)\n            ^ (x * 7 >> 3)\n            ^ (x * 11 >> 4)\n            ^ (x * 13 >> 5)\n            ^ (x * 17 >> 6)\n            ^ (x * 19 >> 7);\n            \n    y += 255 ^ (x * x + 1);\n    \n    y ^= seed;\n    \n    x += y\n            ^ (y * 3 >> 1)\n            ^ (y * 5 >> 2)\n            ^ (y * 7 >> 3)\n            ^ (y * 11 >> 4)\n            ^ (y * 13 >> 5)\n            ^ (y * 17 >> 6)\n            ^ (y * 19 >> 7);\n    \n    y -= 255 ^ (x * x + 1);\n    \n    x -= 255 ^ (y * y + 1);\n    \n    x -= seed;    \n    \n    int levels = abs(x ^ y ^ (x + y)) % discr;\n\n    return float(levels) / float(discr);\n}\n\n\n/* Custom perlin-like noise */\nfloat gradNoiseAt(int x, int y, int seed, int size) {\n\n    int xs = (size + x % size) % size;\n    int ys = (size + y % size) % size;\n    \n    int px = (x - xs) / size;\n    int py = (y - ys) / size;\n\n    float tmpAngle;\n    \n    tmpAngle = randDetAt(px, py, seed);\n    vec2 leftTop = vec2(sin(tmpAngle * 2. * PI), cos(tmpAngle * 2. * PI));\n    \n    tmpAngle = randDetAt(px + 1, py, seed);\n    vec2 rightTop = vec2(sin(tmpAngle * 2. * PI), cos(tmpAngle * 2. * PI));\n    \n    tmpAngle = randDetAt(px, py + 1, seed);\n    vec2 leftBottom = vec2(sin(tmpAngle * 2. * PI), cos(tmpAngle * 2. * PI));\n    \n    tmpAngle = randDetAt(px + 1, py + 1, seed);\n    vec2 rightBottom = vec2(sin(tmpAngle * 2. * PI), cos(tmpAngle * 2. * PI));\n    \n    \n    vec2 posVector = vec2(float(xs) / float(size), float(ys) / float(size));\n    \n    float lt = dot(posVector - vec2(0., 0.), leftTop);\n    float rt = dot(posVector - vec2(1., 0.), rightTop);\n    float lb = dot(posVector - vec2(0., 1.), leftBottom);\n    float rb = dot(posVector - vec2(1., 1.), rightBottom);\n    \n    float l = sinSmooth(posVector.x);\n    float r = sinSmooth(posVector.y);\n    \n    float vl = sel(l, sel(r, lt, lb), sel(r, rt, rb));\n    \n    return (vl + 1.) / 2.;\n    \n}\n\n\n/* Custom perlin-like layered noise */\nfloat deepPerlin(int x, int y, int seed, int size, int octaves, float fade, float mut) {\n    \n    float accum = 0.;\n    \n    float weightAccum = 0.;\n    float weight = 1.;\n    \n    for (int i = 0; i < octaves; ++i) {\n    \n        accum = accum +\n            + gradNoiseAt(x + int(mut), y, seed, size) * weight * 0.5\n            + gradNoiseAt(x, y + int(mut), -seed, size) * weight * 0.5;\n        size = size / 2;\n        weightAccum += weight;\n        weight /= fade;\n        \n        mut *= -1.2; // todo: make variable\n    }\n    \n    return accum / weightAccum;\n    \n}\n\nvec4 beautifulPixel(int x, int y) {\n\n    int seed = 772234778;\n    \n    float mut = iTime * 1.5;\n    \n    //mut = 0.0;\n\n    float height = deepPerlin(x, y, seed, 500, 8, 1.4, mut);\n    \n    float temp = 0.0;\n    \n    float l = gradNoiseAt(x + int(mut * 4.0), y, seed, 60) + gradNoiseAt(x - int(mut * 4.0), y, seed, 60) - 0.8;\n    float r = gradNoiseAt(x, y + int(mut * 4.0), seed - seed, 40) + gradNoiseAt(x, y - int(mut * 4.0), seed - seed, 40) - 1.2;\n    float d = sqrt(abs(l * r));\n\n    float dc = 0.02 * (1.0 - (clamp(height, 0.5, 0.7) - 0.5) * 20.0) - d;\n\n    if ((dc > 0.)\n        && (height > 0.5 && height <= 0.575)) {\n        \n        float col = 0.05 + 0.4 * (clamp(height - 0.3, 0.0, 1.0) / 0.2);\n        \n        if (height > 0.5 && height < 0.504 && dc < 0.0025)\n            return vec4(0.7, 0.7, 0.4, 1);\n        \n        col = clamp(col, 0.0, 0.505);\n        \n        return vec4(0, col * col, col, 1);\n    }\n    \n    \n    if (height < 0.5) {\n        \n        float col = 0.05 + 0.4 * (clamp(height - 0.3, 0.0, 1.0) / 0.2);\n        \n        col = clamp(col, 0.0, 0.505);\n        \n        return vec4(0, col * col, col, 1);\n    }\n    \n    if (height <= 0.5035) return vec4(0.7, 0.7, 0.4, 1);\n    \n    if (height <= 0.575) {\n\n        float col = 0.17 + 0.1 * (height - 0.5035) / (0.575 - 0.5035);\n        return vec4(col * 0.4, col, 0, 1);\n    }\n    \n    if (height <= 1.0) {\n        float col = (height - 0.575) / (1.0 - 0.575);\n        \n        col = sigmaClamp(0.05 + (0.5 - col * 8.0), 0.1, 0.7);\n        \n        return vec4(col, col, col, 1.0);\n    }\n\n    return vec4(1, 1, 1, 1);\n\n}\n\nint sgn(int x) {\n    if (x < 0) return 1;\n    return 0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float speed = iTime * 20.;\n    //speed = 1200.;\n    \n    float tmpx = fragCoord.x - iResolution.x / 2. + speed;\n    \n    int x = int(tmpx);\n    \n    float tmpy = fragCoord.y - iResolution.y / 2.;\n    \n    int y = int(tmpy);\n    \n    \n    fragColor = beautifulPixel(x, y);\n    //fragColor = vec4(randDetAt(x / 3 - sgn(x), y / 3 - sgn(y), 0), 0, 0, 1);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/** My custom shadertoy glsl library **/\n\n#define PI 3.1415926535897932384626433832795\n\n/** Sigmoid function which clamps X between -1 and 1, with f(x)~x at x->0 point **/\nfloat sigmaSquareRoot(float x) {\n    return (x / sqrt(x * x + 1.));\n}\n\n/** Clamps x between low and high values in a soft way using a square root sigmoid function **/\nfloat sigmaClamp(float x, float low, float high )\n{\n\n    float width = (high - low) / 2.0;\n    float midPoint = (high + low) / 2.0;\n\n    x = (x - midPoint) / width; //transpose\n    \n    x = sigmaSquareRoot(x); //squash [works on -1 to 1 span that's why we transpose]\n    \n    x = x * width + midPoint; // transpose back\n\n    return x;\n}\n\n/** Like the previous, but returns value from 0 to 1 instead of from low to high **/\nfloat sigmaBooleanSpan(float x, float low, float high ) {\n\n    float width = (high - low) / 2.0;\n    float midPoint = (high + low) / 2.0;\n\n    x = (x - midPoint) / width; //transpose\n    \n    x = sigmaSquareRoot(x); //squash [works on -1 to 1 span that's why we transpose]\n    \n    x = x * 0.5 + 0.5; // transpose back but to 0 vs 1 span\n\n    return x;\n}\n\n/** Sign aware pow - pows the abs of x and then attaches it's sign back **/\nfloat saPow(float x, float order) {\n\n    float rx = (x < 0. ? -x : x);\n    \n    rx = pow(rx, order);\n    \n    return (x < 0. ? -rx : rx);\n}\n\n/* Drags x around a pivot point */\nfloat dragAround(float x, float pivot, float mul) {\n\n    x -= pivot;\n    x *= mul;\n    x += pivot;\n    \n    return x;\n}\n\n/* Selects between left and right linearly, using a zero to one knob */\nfloat sel(float knob, float l, float r) {\n    return l + knob * (r - l);\n}\n\n/* Smoothes 0 to 1 line to a 0 to 1 sinewave */\nfloat sinSmooth(float x) {\n    x = x * 2. - 1.;\n    x = sin(x * PI / 2.);\n    x = (x + 1.) / 2.;\n    return x;\n}\n","name":"Common","description":"","type":"common"}]}