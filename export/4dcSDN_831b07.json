{"ver":"0.1","info":{"id":"4dcSDN","date":"1459279078","viewed":595,"name":"falling by TAZADUM","username":"bysse","description":"Released at Revision 2016\nPlaced 5th in the PC 4k intro compo\n\nhttp://www.pouet.net/prod.php?which=67174","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","4k"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzX","filepath":"https://soundcloud.com/druttis/falling","previewfilepath":"https://soundcloud.com/druttis/falling","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\t\"falling\" by TAZADUM\n\n\tReleased at Revision 2016\n\tPlaced 5th in the PC 4k intro compo\n\n\t.gfx    klovman\n\t.synth  druttis\n\t.music  druttis\n\n\tAdjusted the shader for WebGL. It's optimized for size, so it's a bit obfuscated...\n\tI've moved the camera a bit closer to the water in this version which shows\n\tof the water a bit more otherwise it's straight from the intro.\n\tAs you can see I stand on the shoulders of giants :)\n\n\tBig thanks to iq for all resources on raymarching and to everyone who publishes \n\tshaders on this site!\n**/\n\nconst float i_MAXD = 15000.0;\n\n#if 1\n\t// low-end gfx\n\t#define CLOUD_STEPS 60\n\t#define RAYMARCH_STEPS 60\n#else\n\t// high-end gfx\n\t#define CLOUD_STEPS 100\n\t#define RAYMARCH_STEPS 100\n#endif\n\nvec3 eps = vec3(.02, 0., 0.);\n\nvec3 waterColor_2 = vec3(0.01, 0.1, 0.15);\nvec3 sunColor = vec3(.99, .94, .9);\nvec3 attenuation = vec3(.3, .03, .01);\nvec3 sun = vec3(0.38, 0.531, -0.758);\nvec2 cloud = vec2(2501., 3400.);\n\nfloat globalDistance = 0.;\nvec3 sunAmount = vec3(0.);\nbool above;\n\nfloat sdTriPrism( vec3 p, vec2 h ) {\n\tvec3 q = abs(p);\n\treturn max(q.y-h.y,max(0.866025*q.x + 0.5*p.z,-p.z)-.5*h.x);\n}\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec3 x ) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + 57.0*p.y + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat3 m = mat3( 0.0,  0.8,  0.6,\n              -0.8,  0.3, -0.4,\n              -0.6, -0.4,  0.6 );\n\nfloat fbm(vec3 p, float d) {\n\tfloat v  = 0.500*noise( p ); p = m*p*2.1 + d;\n          v += 0.210*noise( p ); p = m*p*2.2 + d;\n    \t  v += 0.120*noise( p ); p = m*p*2.3 + d;\n    \t  v += 0.063*noise( p );\n\treturn v;\n}\n\nvec4 cloudField(vec3 p) {\n\treturn vec4(1, 1, 1, smoothstep(0., 1., pow(fbm(.001 * p + vec3(2, 4.2, 0), 0.),2.) - .3));\n}\n\nfloat waterHeight(vec3 q) {\n\tfloat d = .2*iTime;\n\tvec3 p = .15*q + d;\n\tp.y = 0.;\n\treturn .5*fbm(p, d) + 0.0025*noise( 32.*p ) \n\t\t+ .5*sin(.1*q.z + 5.*d + 0.01*q.x) + .05*sin(.44*q.z + d);\n}\n\nvec4 traceClouds(vec3 rp, vec3 rd) {\n\tvec4 color = vec4(0.);\n\tvec2 interval = (cloud - rp.y) / rd.y;\n\tfloat inc = (interval.y - interval.x) / float(CLOUD_STEPS);\n\tfloat aa = clamp(20000./(interval.x + globalDistance), 0., 1.);\n\t\n\tfor(int i=0;i<CLOUD_STEPS;i++) {\n\t\tif (color.w < 1.) {\n\t\t\tvec3 p = rp + interval.x*rd;\n\t\t\tvec4 c = cloudField(p);\n\t\n\t\t\tvec4 shade = cloudField(p + 400.*sun);\n\t\t\tc.xyz *= 1. - .25*smoothstep(0., 1., 10. * shade.w); \n\t\t\tc.xyz *= 1. - .0001*(cloud.y-p.y);\n\t\t\t\n\t\t\tc.w *= aa;\n\t\t\tc.xyz *= c.w;\n\t\t\tcolor += c * (1.-color.w);\n\t\t\t\n\t\t\tinterval.x += inc;\n\t\t}\n\t}\n\tvec3 sky = mix(vec3(0.8, 0.9, 1.2), vec3(0.08, 0.25, 0.5), .45+rd.y);\n\tcolor.xyz = mix(sky, color.xyz/(0.01+color.w), color.a*aa);\n\treturn color;\n}\n\nvec2 field(vec3 q, float d, int nowater) {\n\tvec2 h = vec2(i_MAXD * float(nowater));\n\n\tif (nowater < 1) {\n\t\tfloat k = smoothstep(0., 1., 200. / d);\n\t\th.x = q.y \n\t\t\t+ noise( 0.01*vec3(q.x, 0., q.z) + iTime )\n\t\t\t+ (1. - k)*.1*noise( 0.1*vec3(q.x, 0., q.z))\t\t// FLICKERY\n\t\t\t;\n\n\t\th.x = abs(h.x + (k>0.01?k*waterHeight(q):0.));\n\t\th.y = .5;\n\t}\n\n\n\tfloat y = 8. + .5*sin(iTime);\n\tif (dot(q,q) < 4e6) {\n\t\tfloat a = noise(20.*floor((vec3(q.x, 0., q.z))/128.));\n\t\ty += 200. * smoothstep(0., 1., a) - 3.;\n\t\tq.xz = mod(q.xz, vec2(128.)) - 64.;\n\t}\n\n\tfloat e = min(\n\t\tmax(sdTriPrism(q + vec3(0, y, 0), vec2(20, 11)), -sdTriPrism(q + vec3(5, y, -5), vec2(10, 12))),\n\t\tsdTriPrism(q + vec3(5.5, y+.5*sin(4.+iTime), -5.5), vec2(5, 11))\n\t\t);\t\t\t\n\t\n\treturn e<h.x?vec2(e, 1.5):h; \n}\n\nvec3 normal(vec3 p, float d, float f) {\n\treturn normalize(vec3(\n\t\tfield(p+f*eps.xyz, d, 0).x - field(p-f*eps.xyz, d, 0).x,\n\t\tfield(p+f*eps.yxz, d, 0).x - field(p-f*eps.yzx, d, 0).x,\n\t\tfield(p+f*eps.yzx, d, 0).x - field(p-f*eps.yzx, d, 0).x\n\t\t));\n}\n\n\nvec3 intersect(vec3 ro, vec3 rd, int nowater) {\n\tvec3 hit = vec3(0., .1, 0.);\n\t// hit.x = position\n\t// hit.y = step size\n\t// hit.z = material\n\tfor( int i=0; i<RAYMARCH_STEPS; i++ ) { // Lower for speed\n\t\tif (abs(hit.y) > eps.x && hit.x < i_MAXD) {\n\t\t\thit.x += hit.y;\n\t\t\thit.yz = field(ro + rd * hit.x, hit.x, nowater);\n\t\t}\n\t}\t\n\tif (nowater < 1 && (hit.x > i_MAXD || hit.y > 1.)) {\n\t\thit.x = -ro.y / rd.y;\n\t\thit.y = 10.;\n\t\thit.z = .5;\n\t}\n    return hit;\n}\n\nvec3 colorOfObject(float d) {\n\treturn vec3(2., 2., .8)*(.1 + d); // INLINE?\n}\n\nvec3 colorOfWater(vec3 h, vec3 ro, vec3 rd) {\n\tvec4 traceResults = vec4(0);\n\n\tvec3 hit = ro + (h.x - 0.05) * rd;\n\tvec3 n = normal(hit, h.x, 1.);\n\n\tfloat side = above ? 1. : -1.;\n\tfloat D = max(0.,dot(sun, n)*side);\n\tglobalDistance += h.x;\n\n\t// Material in h.z \n\tif (h.z > 1.) {\n\t\treturn mix(waterColor_2, colorOfObject(D), above?1.:exp(-0.0002*pow(h.x,1.6)));\n\t} \n\n\tvec3 R = reflect(rd, n);\n\tvec3 H = normalize(sun - rd);\n\n\t// reflective indices\n\tfloat index = above ? .75 : 1.33;\n\tfloat d = abs(dot(rd, n));\n\tfloat det = 1. - index * index * (1. - d*d); // if this is < 0, then it's total reflection \n\n\tvec3 reflection = waterColor_2 * (1. - max(0.,-R.y)), // Add 'diffuse' lightning under water if schlick > 0.01\n\t\ttransmission = waterColor_2; // total reflection\n\n\tif (det > 0.) {\n\t\t// calculate transmission\n\t\tvec3 T = normalize(index*rd + (index*d - sqrt(det))*side*n);\n\n\t\tvec3 tHit = intersect(hit, T, 1);\n\t\tif (tHit.z > 1. && tHit.x < i_MAXD) {\n\t\t\tvec3 uwhit = hit + T*tHit.x;\n\t\t\ttransmission = colorOfObject(max(0., dot(sun, normal(uwhit, tHit.x, 1.)))) * exp(0.5*attenuation*uwhit.y); // reduce attenuation because it looks good\n\t\t} else {\n\t\t\ttransmission = vec3(0.0, 0.01, 0.05);\n\t\t\tif (!above) {\n\t\t\t\ttraceResults = traceClouds(hit, T);\n\t\t\t\ttransmission = traceResults.xyz + (1. - traceResults.a) * sunAmount;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate Schlick's approximation to the Fresnel factor\n\t// this is the same no matter on which side of the surface you are\n\tfloat schlick = 0.02 + (1. - 0.02) * pow(1. - d, 2.);\n\t\n\tif (schlick > 0.01) {\n\t\t// calculatee reflection\n\t\tvec3 rHit = intersect(hit, R, 1); // raymarch without the water function\n\t\tif (rHit.z > .1 && rHit.x < i_MAXD && dot(R, vec3(0,1,0)) > 0.05) {\n\t\t\treflection = mix(\n\t\t\t\t\t\twaterColor_2, \n\t\t\t\t\t\tcolorOfObject(max(0., dot(sun, normal(hit + R*rHit.x, rHit.x, 1.)))), \n\t\t\t\t\t\tabove ? 1. : exp(-0.0002*pow(h.x + rHit.x,1.6))\n\t\t\t\t\t\t);\n\t\t} else if (above) {\n\t\t\ttraceResults = traceClouds(hit, R);\n\t\t\treflection = .75 * traceResults.xyz\n\t\t\t\t+ (1.-traceResults.w)\n\t\t\t\t\t* (sunColor + (1.0 - sunColor)\n\t\t\t\t\t\t* pow(1.0 - max(0., dot(sun, H)), 5.))\n\t\t\t\t\t* pow(max(0., dot(n, H)), 64.)\n\t\t\t\t\t* D\n\t\t\t\t\t* (12. - 0.008*ro.y);\n\t\t}\n\t}\n\n\treturn schlick * reflection + (1. - schlick) * transmission;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1. + 2. * fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y; \t\n\n\tfloat s0  = 2. * smoothstep(0., 1., (iTime -  0.)*.04);\n\tfloat s25 = smoothstep(0., 1., (iTime - 25.)*.08);\n\tfloat s40 = smoothstep(0., 1., (iTime - 35.)*.06);\n\tfloat s45 = smoothstep(0., 1., (iTime - 45.)*.12);\n\t\n\tfloat h1 = clamp(iTime - 25., 0., 10.);\n\t\n\tvec2 look = vec2(\n\t\t// left-right\n\t\t1.20 + s0\n\t\t- .35 * sin(3.14*s40)\n\t\t,\n\t\t// up-down\n\t\t0.75 - .30*s0\n\t\t-.30*(smoothstep(0., 1., (iTime - 20.)*.10) - s25)\n\t\t+ .25 * sin(3.14*smoothstep(0., 1., (iTime - 35.)*.20))\n\t\t- .3 * s40 + .3 * s45*s45\n\t\t+ .5 * smoothstep(0., 1., (iTime - 55.) * .1)\n\t);\n\t\n\tvec3 cp = vec3(\n\t\t// x\n\t\t440.*s40 -128.\n\t\t , \n\t\t// y\n\t\t111. \n\t\t- 125.*s25\n\t\t+ 5. * clamp(iTime-35., 0., 5.)\n\t\t+   80.*s40\n\t\t-   80.*s45\t\n\t\t- 100. * clamp(iTime - 54.8, 0., .3) - 10. * clamp(iTime - 55.1, 0., 15.)\n\t\t, \n\t\t// z\n\t\t5178.\n\t\t- 500.*h1 + 10.*h1*h1\n\t\t- 1038.*s40\n\t\t);\n\n\tvec3 cd = normalize(vec3(sin(look.x), look.y, cos(look.x)));\n\tvec3 side = cross(cd, vec3(0, -1., 0.));\n\tvec3 rd = normalize(cd + .5*(uv.x*side + uv.y*cross(cd, side)));\n\n\tfloat wh = waterHeight(cp);\n\tvec3 color = waterColor_2;\n\tvec3 result = intersect(cp, rd, 0);\n\tvec4 tr = vec4(0);\n\n\tabove = cp.y >= wh;\n\n\tfloat sunSpecular = max(0.,dot(sun, rd));\n\tsunAmount = sunColor * min(4.0 * pow(sunSpecular, 2048.0) + pow(sunSpecular, 32.0), 1.0);\n\n\tif (result.x > 0.) {\n\t\tcolor = colorOfWater(result, cp, rd);\n\t} else if (above) {\n\t\ttr = traceClouds(cp, rd);\n\t\tcolor = tr.xyz;\n\t}\n\n\tif (above && sunSpecular > 0.0) {\n\t\tvec2 sunPos = vec2(dot(sun, side), sun.y);\n\t\tvec2 pos = uv - sunPos;\n\t\tpos = pos * length(pos);\n\t\tsunColor *= .1 * pow(sunSpecular, 6.0);\n\t\tcolor += sunColor * 25.0 * pow(max(0., 1.0-2.0*length(sunPos*2.0 + pos)), 10.0) * vec3(1.0, .4, .2);\n\t\tcolor += sunColor * 10.0 * pow(max(0., 1.0-length(sunPos*5.0 + mix(pos, uv, -2.1))), 4.0);\n\t}\n\n\tcolor = above ? color + sunAmount * (1.-tr.a) : color * exp(-attenuation*(wh - cp.y)) * min(1.+ rd.y, 1.);\n\t\n\tcolor +=    smoothstep(0., 1., 1.-.1*iTime);\t\t// FADE IN\n\tcolor *= 1.-smoothstep(0., 1., .2*iTime-12.3);\t// FADE OUT\n\t\t\n\t// gamma + contrast\n\tcolor = pow( min(color, 1.), vec3(0.44) );\n\tfragColor = vec4(color*color*(3.0-2.0*color), 0.);\n}\n","name":"Image","description":"","type":"image"}]}