{"ver":"0.1","info":{"id":"clByRW","date":"1691504257","viewed":47,"name":"Fork Trying to smooth the shadow","username":"jurimimi","description":"Trying to smooth the shadows closer to its edges with a mask. It doesn't work :( \n\nForked from https://www.shadertoy.com/view/dlXczs","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","learning"],"hasliked":0,"parentid":"dlXczs","parentname":"Learning RayTracing FoCG"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INFINITY 20.\n#define SPHERECOUNT 5\n#define LIGHTSCOUNT 3\n#define BOUNCES 8\n\nstruct Ray{\n    vec3 o; //origin \n    vec3 d; //direction\n};\n\nstruct PointLight{\n\n    vec3 c; //color\n    vec3 p; //point in space\n};\n\n\nstruct Sphere{\n\n    vec3 c; // centre\n    float r; // radius\n};\n\nstruct Triangle{ //TODO\n    vec3 a,b,c;\n};\n\n\n//reference: https://www.shadertoy.com/view/MtcXWr\nstruct Plane\n{\n    float d;\t// solution to dot(n,p)+d=0\n    vec3 n;\t\t// normal\n};\n\nfloat intersectPlane(Plane p, Ray r)\n{\n    float dotnd = dot(p.n, r.d);\n    if (dotnd > 0.) return INFINITY;\n    float t = -(dot(r.o, p.n) + p.d) / dotnd;\n    return t;\n}\n/////////////////////////////////////////////////\n\nconst Sphere spheres[SPHERECOUNT]= Sphere[SPHERECOUNT](\n    Sphere(vec3( 0.0, .5,  3.0),0.135),\n    Sphere(vec3( 1.75, 0.0, 3.0),0.5), \n    Sphere(vec3(-1.5, 0.0,  3.0),.75),\n    Sphere(vec3(.0, -.5, 1.), 0.25),\n    Sphere(vec3(.0, -.5, 1.), 0.25)\n    \n);\n\n\nconst PointLight lights[LIGHTSCOUNT] = PointLight[LIGHTSCOUNT]\n(\n    PointLight(vec3(0.9, 0.0, 0.2)*.5,\n               vec3(0., 7., 0.) ),           \n                                           \n    PointLight(vec3(3.9, 0.9,0.0)*.3,\n               vec3(0., 7., 80.) ),\n               \n    PointLight(vec3(0.0, 0.8, 2.9)*.7,\n               vec3(0., 7., 40.) )\n);\n\n\n\nstruct HitRecord{\n    \n    float t;  // distance of hit along the ray\n    vec3 n;   // surface normal at the hit point\n};\n\nvec3 P(float t, Ray ray){//Returns a point P that lays in the distance t distance along the ray direction. \n    return ray.o + t * (ray.d);\n}\n\n\nfloat SphRayInt(Ray r, Sphere sp) // Sphere-Ray Intersection\n{\n    vec3 r0_spC = r.o - sp.c; // direction from ray origin to sphere center\n\n    //using the quadratic formula:\n    \n    float a = dot(r.d, r.d); \n    float b = 2.*dot(r.d, r0_spC);\n    float c = dot(r0_spC, r0_spC) - (sp.r * sp.r);\n    \n    float d = (b*b) - 4.0 * a * c;   //discriminant to know if the eq has solutions\n    \n    if(d < 0.){\n        return INFINITY;\n    }\n    \n    //Final calculation\n    //Most of the time, the only solution that we care about is the lowest one (first hit), \n    //so we will forget about the other one.\n    \n    if (true)return (-b - sqrt(d*tan(3.14*0.3)))/(1.985*a);\n    return (-b - sqrt(d))/(1.985*a);\n}\n\nbool TriRayInt(Ray r, Triangle tri){\n    \n    //TODO: Compute t,g,b\n    \n    float t;\n    \n    if(t < .0 || t >= INFINITY) return false;\n    \n    float g;\n    \n    if(g < 0. || g >= 1.) return false;\n    \n    float b;\n    \n    if(b < 0. || b > 1. - g) return  false;\n    \n    return true;\n}\n\nHitRecord RayTest(Ray ray){ // find the closest ray hit with the spheres per window/screen pixel\n\n    HitRecord hR;\n    hR.t = INFINITY;   // default t value (max vision range / far plane)\n    \n    for(int i = 0; i < SPHERECOUNT; i++){ //loop through our spheres to find the closest hit\n    \n        Sphere s = Sphere(spheres[i].c, spheres[i].r);\n        \n        //Simple animation\n        if(i == 0) s.c = vec3(s.c.x,s.c.y,s.c.z + cos(iTime)*5.);\n        else if(i == 1)  s.c = vec3(s.c.x,s.c.y + sin(iTime)*.25,s.c.z);\n        \n        if(i == 3) s.c = vec3(s.c.x + cos(iTime)*.25, s.c.y + -sin(iTime)*.25,s.c.z);\n        else if(i == 4) s.c = vec3(s.c.x + -cos(iTime)*.25, s.c.y + sin(iTime)*.25,s.c.z);\n        else if(i != 2)\n        s.c = vec3(s.c.x +cos(iTime)*.2, s.c.y + sin(iTime)*.2, s.c.z);\n        \n        ///////////////////\n        \n        ray.o += ray.d * .0001;\n        \n        float t = SphRayInt(ray, s); //calcualte hit distance\n        \n        \n        if(t < hR.t && t > .0001) //if is less than our current one, replace\n        {\n            hR.t = t;\n            vec3 hitPoint = P(t, ray);\n            hR.n = (hitPoint - s.c)/s.r;\n        }\n    }\n    \n    Plane pl = Plane(1., vec3(0.,1.,0.));\n    float pT = intersectPlane(pl, ray);\n       \n    if(pT < hR.t){        \n        hR.t = pT;\n        hR.n = pl.n;\n    }\n    \n    return hR;\n}\n\nstruct Color {\n  vec3 value;\n  bool type; // true -- actual color; false -- a mask (b&w)\n};\n\nColor Illuminate(PointLight light, Ray ray, HitRecord hrec){\n\n    vec3 x = P(hrec.t, ray); //shading point \n    float r = length(light.p - x); //distance from light to shading point\n    vec3 l = (light.p - x)/r; // unit light direction, from light point to shading point\n    \n    HitRecord hR = RayTest(Ray(x,l));\n    \n    if(hR.t >= INFINITY){ //this should be in reverse, but it doesnt work, something is off...\n    \n        vec3 n = hrec.n; //unit normal vector\n        \n        vec3 e;\n        \n        // calculate color\n        if (false) e = max(.0, dot(n,l) ) * (light.c/sqrt(r*r)*10.); \n        else e = abs(dot(n,l) ) * (light.c/sqrt(r*r)*3.85); \n        \n        float red_result_color;\n        \n        if (e.r > .009) {e /= 1.795; red_result_color = e.r;}\n        if (e.b > .002) {e = e/.2 - (red_result_color/2.7);}\n        if (e.b > .002) {e = e/1.2 - (red_result_color/2.7);}\n\n        // dot(n,l) returns positive values when vectors aim in similar directions,\n        // and negative values when they are opposite \n        // then multiply the value by the normalized light color\n\n        // return actual color\n        Color out_color;\n        out_color.value = e;\n        out_color.type = true;\n        \n        return out_color;\n    \n    } else {\n        // Trying to make a mask to smooth the shadow closer to its edge.\n    \n        float sh_color = 1.;\n        sh_color *= hR.t;\n        \n        Color out_color;\n        out_color.value = vec3(sh_color);\n        //out_color.value = vec3(0.);\n        out_color.type = false;\n        \n        return out_color;\n    }\n}\n\nvec4 ShadeRay(Ray camera){\n\n    Color color;\n    color.value = vec3(0.);\n    color.type = true;\n    \n    float transparency = 1.;\n    \n    float lightPower = 1.3;\n    Ray ray = Ray(camera.o, camera.d);\n    HitRecord hR;\n    hR.t = INFINITY;\n    \n    for (int i = 0; i < BOUNCES; i++){\n        \n        if (true) ray.o = ray.o + ray.d*tan(3.14*.02);\n        else ray.o = ray.o + ray.d * .0001;\n        \n        hR = RayTest(ray);\n        \n        // \n        if(hR.t >= INFINITY) return vec4(color.value, 1.0);\n        // \n        else {\n        \n            for (int i = 0; i < LIGHTSCOUNT; i++){\n\n                PointLight l = lights[i];\n\n                // moving the lights a little bit :)\n                l.p = vec3(cos(iTime) * 3., l.p.y + sin(iTime) * 2., l.p.z); \n    \n                Color new_color = Illuminate(l, ray, hR);\n                color.type = new_color.type;\n                \n                \n                // Is color\n                if (color.type) {\n                    color.value += new_color.value * lightPower;\n                // Is mask\n                } else {                    \n                    //transparency -= new_color.value.r;\n                    transparency += new_color.value.b * lightPower;;\n                    color.value /= transparency;\n                }\n            }\n        \n            // doing something with lights :3 \n            if (false) lightPower *= .575;\n            else { lightPower = cos(lightPower/**1.05*/); lightPower = sin(lightPower * .645); }\n            \n\n            ray.o = P(hR.t, ray);\n            \n            //Both ray.d work, wich is better? idk\n            ray.d = (ray.d - 2.*dot(ray.d, hR.n)*hR.n);\n            //ray.d = normalize(reflect(ray.d, hR.n));          \n        }\n    }\n    \n    //some ambient color\n    \n    color.value += vec3(.055, .0, .075);\n    \n    return vec4(color.value, transparency);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv * 2.0 - 1.0;//transform from [0,1] to [-1,1]\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    Ray cam; // our camera ray\n    vec3 wnd = vec3(uv, -1.); // window/screen position in 3D space\n\n    //cam.o = vec3(.0, cos(iTime) *.35, -5.); // camera position in 3D space\n    cam.o = vec3(.0, .65, -10.);\n    \n    cam.d = normalize(wnd - cam.o); // camera direction (look through the window)\n        \n    vec4 color;;\n    \n    //color += ShadeRay(cam).rgb;\n    //fragColor = vec4(color, 1.0);\n    \n    fragColor = ShadeRay(cam);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*REFERENCES: \n\n\n    Fundamentals of Computer Graphics (Chapter 4: Ray Tracing):\n    https://www.amazon.com/Fundamentals-Computer-Graphics-Steve-Marschner/dp/1482229390\n    \n    -GLSL ray tracing test:\n    https://www.shadertoy.com/view/3sc3z4\n    \n    -Ray tracing a cone:\n    https://www.shadertoy.com/view/MtcXWr\n\n\n\n//Notes:\n\n    Im still figuring things out.\n    \n    The reason the reflections are perfect is because the spheres have no material,\n    so the light is preserved with each ray reflection (may change this later).\n    \n    The scene has 3 point lights and some ambient color\n    (may add a directional light later).\n    \n    If you have better learning resources/references please let me know.\n    \n    May add triangles later.\n    \n    Im figuring out how to add proper shadows (something is off)\n    \n    Any advice/optimization is welcome.\n\nBasic:\n\n    basis vectors\n    u/x = (1., .0, .0);  // left/right\n    v/y = (.0, 1., 0.);  // up\n    w/z = (.0, .0, -1.); // dept\n    window/screen dimensions\n    l and r are the positions of the left and right edges\n    of the image,\n    b and t are the positions of the bottom and top edges\n    of the image:\n\n           u = l                u = r \n    v          ___________________\n    |    rd   |     _             | v = t       /¯¯\\ (sphere)\n    w—e——————————————|s̲|-- --  --   |--     --  -|p|  |--\n     \\        |                   |             \\__/\n      u       |___________________| v = b\n\n    e is the view point (camera origin)\n    s is the intersection point between \n    our camera ray and the window/screen \n\n    rd is the ray direction (camera direction/ray)\n    rd = s - e;\n\n    Generally:\n\n    l < 0 < r and b < 0 < t\n\n    in this particular case\n\n    l = -1, r = 1\n    b = -0.5, t = 0.5\n\n    Before calculating Intersections, we need to be able to get a point at any given travel distance\n    along the ray direction of our camera, to do that, we will simply use the following function:\n\n    P(t) = e + t*(rd);\n\n    this function returns a point in 3D space that lays in 't' distance from 'e' along the ray direction 'rd'.\n    in this case, 't' is the travel distance along the ray direction.\n    remember not to be confuse it with our other variable 't'(top of the window)\n    \n\n    Intersection with Sphere:\n      \n        in order to compute the intersection with a sphere, we need a point uvw (xyz)\n        and a sphere with center:\n\n        c = (xc, yc, zc) \n        and radius R \n\n        wich can be represented by the\n        implicit equation:\n\n        ((x-xc)^2) + ((y - yc)^2) + ((z - zc)^2) - ((R)^2) = 0\n\n        written in vector form:\n\n        dot((p - c), (p - c)) - ((R)^2) = 0 \n\n        substituting p by our P function:\n\n        dot( (e + (t * (rd-c)) ), (e + (t * (rd-c))) ) - ((R)^2) = 0\n\n        rearranging and solving for t yields:\n\n        (( dot(rd, rd) )*(t)^2) + (2*( dot(rd, e - c) )*t) + dot(e-c, e-c) - ((R)^2) = 0\n\n        which is a classic quadratic eq. meaning it has the form:\n\n        (A*(t)^2) + (B * t) + C = 0\n\n        thus we can solve for t with the quadratic formula\n\n        (-B +-sqrt((B*B) - 4*A*C))/ 2*A\n\n        so, given a sphere(center and radius) we now can find at wich t(travel distance) our ray direction collides\n        with it.\n\n        Remember to always compute the discriminant firts. \n\n        If the discriminant is negative,\n        its square root is imaginary and the line and sphere do not intersect. If the dis-\n        criminant is positive, there are two solutions: one solution where the ray enters\n        the sphere and one where it leaves. If the discriminant is zero, the ray grazes\n        the sphere, touching it at exactly one point.\n        \n    Intersection with Plane:\n    //TODO:\n    \n    Intersection with Triangle:\n    //TODO:\n      \n    Lighting the scene:\n      \n        In order to shade the scene we need 4 vectors:\n\n        The shading point 'x': \n        Wich can be computed evaluating the viewing ray at the 't' value of the sphere intersection.\n\n        The surface normal 'n':\n        The normal vector at the point where a ray intersects it.\n\n        The light direction 'l':\n        Can be computed from the point of the current light source to the current intersection point\n\n        The viewing direction 'v':\n        is simply the opposite direction of the viewing ray (v = −rd/‖rd‖).\n       \n       //TODO:\n*/","name":"Common","description":"","type":"common"}]}