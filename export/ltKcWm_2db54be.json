{"ver":"0.1","info":{"id":"ltKcWm","date":"1536668658","viewed":296,"name":"Raymarching Torus test","username":"uynet","description":"tanoC","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Trus{\n    vec3 dir;\n    vec3 pos;\n    float r;\n    float s;\n};\n struct Sphere{\n     vec3 pos;\n     float r;\n };\nstruct Ray{\n    vec3 orig;\n    vec3 dist;\n};\n    \n    \nvec3 L = normalize(vec3(1,0,-1));\nconst float EPS = 0.001;\nTrus trus;\n\n//trus distancefield\nfloat dist(vec3 p,Trus trus){\n  float d;\n   p -= trus.pos;\n   vec3 p_proj = p-trus.dir*(dot(p,trus.dir));\n   p_proj = trus.r * normalize(p_proj);\n   d = length(p_proj - p)-trus.s;\n   return d;\n}\n\nfloat dist_s(vec3 p,Sphere sphere){\n   return length(p-sphere.pos)-sphere.r;\n}\n\nRay march(Ray ray, float dist){\n                        //distance / distination\n    Ray r = ray;\n    r.orig = ray.orig + dist*ray.dist;\n    return r;\n}\n\nvec3 rotX(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x,\n\t\tv.y * c - v.z * s,\n\t\tv.z * c + v.y * s\n\t);\n}\nvec3 rotY(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x * c + v.z * s,\n\t\tv.y,\n\t\tv.z * c - v.x * s\n\t);\n}\nvec3 rotZ(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x * c - v.y * s,\n\t\tv.y * c + v.x * s,\n\t\tv.z\n\t);\n}\n\n// 法線の計算\nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n    dist(p + vec3(EPS, 0.0, 0.0),trus) - dist(p + vec3(-EPS,  0.0,  0.0),trus),\n    dist(p + vec3(0.0, EPS, 0.0),trus) - dist(p + vec3( 0.0, -EPS,  0.0),trus),\n    dist(p + vec3(0.0, 0.0, EPS),trus) - dist(p + vec3( 0.0,  0.0, -EPS),trus)\n  ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    trus.dir = normalize(vec3(1));\n    trus.dir = rotX(trus.dir,iTime*111.0);\n    trus.dir = rotY(trus.dir,iTime*83.0);\n    trus.dir = rotZ(trus.dir,iTime*93.0);\n    trus.pos = vec3(0,0,0);\n    trus.r = 0.1;\n    trus.s = trus.r/4.0;\n   \n    \n    Sphere sphere;\n    sphere.pos = vec3(sin(iTime)*0.1,0,0);\n    sphere.r = 0.1;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    uv-=0.5;\n    uv.y*=asp;\n    \n    Ray ray;\n    ray.orig = vec3(0,0,-1);\n    ray.dist = vec3(uv,1);\n    \n    //float d = dist_s(ray.orig,sphere);\n    float d2 = dist(ray.orig,trus);\n    int t = 0;\n    vec3 col = vec3(0);\n    \n    while(d2 > EPS){\n    \tray = march(ray,d2);\n        //d = dist_s(ray.orig,sphere);\n        d2 = dist(ray.orig,trus);\n        if(t++>10)break;\n    }\n    if(d2<=0.01){\n        L = rotX(L,iTime*171.0);\n        vec3 norm =  getNormal(ray.orig);\n        //col = norm;\n        //col = .6-col*0.5;\n        float dif = max(0.0,dot(norm,L));\n        dif*=0.5;\n        float spe = max(0.0,dot(reflect(ray.dist,norm),L));\n        spe*=spe;\n        spe*=0.1;\n        float amb = 0.3;\n        \n        float b = dif+spe+amb;\n     \n        //col.x += dif*7.0+norm.y*norm.x;\n        //col.y += spe*2.0;\n        //col.z += spe*2.0+norm.x*norm.z;\n        //col = 1.0-col;\n         col = vec3(b)*vec3(dif*8.0 ,0.6+spe*5.0,1.0-dif*9.0);\n\t\t        \n    }\n\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}