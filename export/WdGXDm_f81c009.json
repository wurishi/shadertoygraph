{"ver":"0.1","info":{"id":"WdGXDm","date":"1574226525","viewed":201,"name":"don - Revolver SDF 2D","username":"koktszfung","description":"I tried to make an SDF for a revolver in 2D.\nThe code is very messy but the result is pretty cool XD.\nRay marching code written by hughsk (https://www.shadertoy.com/view/XsyGRW).","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n*\tray marching tools adapted from hughsk's 2D SDF Toy https://www.shadertoy.com/view/XsyGRW\n*/\n\n#define TRACE_STEPS 20\n#define TRACE_RAY\n\n// 0 = Distance Field Display\n// 1 = Raymarched Edges\n// 2 = Resulting Solid\n// 3 = Distance Field Polarity\n#define DISPLAY 0\n\n// 0 = Angle controlled By iTime\n// 1 = Angle controlled By iMouse\n#define MOUSE 0\nconst float PI = 3.14159265359;\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n    vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n    position.x *= screenSize.x / screenSize.y;\n    return position;\n}\n\n// translational symmetry\nvec2 tsym(vec2 p, float m) {\n    return mod(p + m*.5, m) - m*.5;\n}\n\nfloat tsym(float p, float m) {\n    return mod(p + m*.5, m) - m*.5;\n}\n\n// rotational symmetry\nvec2 rsym(vec2 p, float n){\n\tfloat pr = length(p);\n    float pa = atan(p.y, p.x);\n    pa = tsym(pa, 2.*PI/n);\n    p = vec2(pr*cos(pa), pr*sin(pa));\n    return p;\n}\n\nvec2 rotate(vec2 p, float a) {\n    return vec2(p.x*cos(a) - p.y*sin(a),\n                p.x*sin(a) + p.y*cos(a));   \n}\n\nfloat add(float a, float b) {\n    return min(a, b);\n}\n\nfloat sub(float a, float b) {\n\treturn max(a, -b);\n}\n\n\n\nfloat shape_circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat shape_rect(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) +  min(max(d.x, d.y), 0.0);  // out + in\n}\n\nfloat shape_line(vec2 p, vec2 a, vec2 b) {\n    vec2 dir = b - a;\n    return abs(dot(normalize(vec2(dir.y, -dir.x)), a - p));\n}\n\nfloat shape_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//https://iquilezles.org/articles/distfunctions2d\nfloat shape_trapezoid(vec2 p, float r1, float r2, float he ) {\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot(k2, k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\n\n\n\nfloat shape_revolver_base(vec2 p) {\n    return shape_trapezoid(p + vec2(0, .5), .15, .1, .8) - .05;\n}\n\nfloat shape_revolver_cylinder_fill(vec2 p) {\n    vec2 p1 = rotate(p, iTime);\n    return shape_circle(p1, .4);\n}\n\nfloat shape_revolver_cylinder_cut(vec2 p) {\n    float cbig = shape_circle(p, .4);\n    float cmid  = shape_circle(p, .03);\n    \n    vec2 p11 = abs(rsym(rotate(p, PI/6.), 6.)) - vec2(.25, 0);\n    float cin  = shape_circle(p11, .075);\n    \n    vec2 p12 = abs(rsym(p, 6.)) - vec2(.4, 0);\n    float cout = shape_circle(p12, .075);\n\t\n    return sub(add(add(cmid, cin), cout), -cbig-.03);\n}\n\nfloat shape_revolver_barrel(vec2 p) {\n    p.x = abs(p.x);\n    float rect1 = shape_rect(p - vec2(0, .45), vec2(.04, .06)) - .01;\n    float rect2 = shape_rect(p - vec2(.08, .42), vec2(.04, .04)) - .01;\n\tfloat circle = abs(shape_circle(p - vec2(0, 0.25), 0.15)) - .025;\n    return add(sub(add(rect1, rect2), circle), circle);\n}\n\nfloat shape_revolver_frame(vec2 p) {\n    float rect = shape_rect(p+vec2(0, .25), vec2(.06, .2));\n    float circle = shape_circle(p, .1);\n\treturn add(rect, circle) - .025;\n}\n\nfloat shape_revolver_trigger(vec2 p) {\n    float rect1 = shape_rect(p+vec2(0, .55), vec2(.06, .05));\n    float trap = shape_trapezoid(p+vec2(0, .7), .03, .06, .08);\n    return add(trap, rect1) - .025;\n}\n\nfloat SAMPLER(vec2 p) {\n    float scale = .8;\n    p.y -= .25;\n    \n    p /= scale;\n    \n    vec2 p1, p2;\n    float time = mod(iTime/PI, 2.);\n    if (time > 1.){\n        p1 = rotate(p + vec2(0, .4), abs(sin(iTime))*PI*.25) - vec2(0, .4);\n        p2 = rotate(p1, iTime);\n    }else{\n        if (time > .11 && time < .2 && length(p - vec2(0, .25)) < pow(time, 2.)*120.) return 0.;\n        p.y -= (time > .1)? exp(-time*5.)*.75 : 0.;\n        p1 = p;\n        p2 = p;\n    }\n    \n    float cylinder_back = shape_circle(p, .425);\n    float cylinder_cut = shape_revolver_cylinder_cut(p2);\n    float cylinder_fill = shape_revolver_cylinder_fill(p2);\n    float base = shape_revolver_base(p);\n    float s1 = sub(add(add(cylinder_fill, cylinder_back), base), cylinder_cut);\n    \n    float trigger = shape_revolver_trigger(p);\n    float s2 = add(sub(s1, trigger - .025), trigger);\n    \n    float frame_still = shape_revolver_frame(p);\n    float frame_move = shape_revolver_frame(p1/.9)*.9;\n    float s3 = add(sub(s2, frame_move - .025), frame_move);\n    float s4 = add(sub(s3, frame_still - .025), frame_still);\n\n    \n    float barrel = shape_revolver_barrel(p);\n    float s5 = add(sub(s4, barrel - .025), barrel);\n    \n\n    return s5*scale;\n}\n\n\nvec3 draw_line(float d, float thickness) {\n    const float aa = 3.0;\n    return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n    return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n    return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_polarity(float d, vec2 p) {\n    p += iTime * -0.1 * sign(d) * vec2(0, 1);\n    p = mod(p + 0.06125, 0.125) - 0.06125;\n    float s = sign(d) * 0.5 + 0.5;\n    float base = draw_solid(d);\n    float neg = shape_rect(p, vec2(0.045, 0.0085) * 0.5);\n    float pos = shape_rect(p, vec2(0.0085, 0.045) * 0.5);\n    pos = min(pos, neg);\n    float pol = mix(neg, pos, s);\n\n    float amp = abs(base - draw_solid(pol)) - 0.9 * s;\n\n    return vec3(1.0 - amp);\n}\n\nvec3 draw_distance(float d, vec2 p) {\n    float t = clamp(d * 0.85, 0.0, 1.0);\n    vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n    float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n    float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n    float d2 = abs(1.0 - draw_line(d).x);\n    vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n    grad -= rim;\n    grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n    return grad;\n}\n\nvec3 draw_trace(float d, vec2 p, vec2 ro, vec2 rd) {\n    vec3 col = vec3(0);\n    vec3 line = vec3(1, 1, 1);\n    vec2 _ro = ro;\n\n    for (int i = 0; i < TRACE_STEPS; i++) {\n        float t = SAMPLER(ro);\n        col += 0.8 * line * (1.0 - draw_line(length(p.xy - ro) - abs(t), 0.));\n        col += 0.2 * line * (1.0 - draw_solid(length(p.xy - ro) - abs(t) + 0.02));\n        col += line * (1.0 - draw_solid(length(p.xy - ro) - 0.015));\n        ro += rd * t;\n        if (t < 0.01) break;\n    }\n\n    #ifdef TRACE_RAY\n    col += 1.0 - line * draw_line(shape_segment(p, _ro, ro), 0.);\n    #endif\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime * 0.5;\n    vec2 uv = squareFrame(iResolution.xy, fragCoord);\n    float d;\n    vec3 col;\n    vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n    vec2 rd = normalize(-ro);\n\n    d = SAMPLER(uv);\n\n    #if DISPLAY == 0\n    col = vec3(draw_distance(d, uv.xy));\n    #if MOUSE == 0\n    col -= (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(draw_trace(d, uv.xy, ro, rd));\n    #endif\n    #endif\n    #if DISPLAY == 1\n    col = vec3(0) + 1.0 - vec3(draw_line(d));\n    #if MOUSE == 0\n    col += (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(1, 0.25, 0) * vec3(draw_trace(d, uv.xy, ro, rd));\n    #endif\n    col = 1. - col;\n    #endif\n    #if DISPLAY == 2\n    col = vec3(draw_solid(d));\n    #endif\n    #if DISPLAY == 3\n    col = vec3(draw_polarity(d, uv.xy));\n    #endif\n\n    fragColor.rgb = col;\n    fragColor.a   = 1.0;\n}","name":"Image","description":"","type":"image"}]}