{"ver":"0.1","info":{"id":"McSBzd","date":"1725357361","viewed":26,"name":"Monster Hunt Wilds: Health Bar","username":"knighty33","description":"Inspired by the health bar from the new game. Just playing around really. Would likely look a lot better with perlin noise instead of layered sine waves","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["healthbar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getPos(in float x, in float time) {\n    float r = sin(x + time) \n    + sin(x * 2.0 - time * 1.7f + 0.8f) * 1.2f\n    + sin(x * 4.0 + time * 3.8f + 0.8f) * 0.6f\n    + sin(x * 8.0 - time * 7.8f + 0.8f) * 0.8f\n    + sin(x * 12.0 - time * 10.8f + 0.8f) * 0.2f\n    + sin(x * 17.0 + time * 15.8f + 0.8f) * 0.1f;\n    return sign(r) * pow(abs(r), 1.5f);\n}\n\nfloat saturate(in float x) {\n    return min(1.0, max(0.0, x));\n}\n\nfloat distFromLine(in float y, in float line, in float strength) {\n    return pow(smoothstep(0.5f * (strength * 2.0f + 0.5f), 0.0f, abs(y - line) * 50.0f), 2.2f);\n}\n\nfloat distFromLine2(in float y, in float line, in float strength) {\n    return pow(smoothstep(0.2f, 0.0f, abs(y - line) * 1.0f), 2.2f);\n}\n\nvec4 comp(in vec4 source, in vec4 dest) {\n    return vec4(source.rgb * source.a + dest.rgb * (1.0 - source.a), 1.0f);\n}\n\nconst float PI = 3.14159265359;\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec4 cubemap(in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -0.5));\n  \n  vec3 col = texture(iChannel0, rd).rgb;\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //float barLength = iMouse.x / iResolution.x;\n    float barLength = 0.75f + smoothstep(0.4f,0.7f, sin(iTime)) * 0.25f;\n    \n    float x = (uv.x * 2.0f - 0.1f);\n    float y = uv.y * 2.0f - 1.0f - 0.8f;\n    \n    float magScale = saturate(x * 3.0f / barLength) * saturate(8.0f - (x * 1.0f / barLength) * 8.0f);\n    \n    //uv.y += sin(iTime) * 0.02f * (1.0f - magScale);\n    \n    bool mouseDown = false;//sign(iMouse.z) > 0.0f;\n    float mag = 0.008f * (0.2 + 0.8f * magScale) * (mouseDown ? 2.0f : 1.0f);\n    \n    float time = mod(iTime, 100.0f);\n    float scale = 4.0f;\n    float timeScale = mouseDown ? 1.61f : 0.6f;\n    float spread = 0.0f;\n    float top = (getPos(x * scale, time * timeScale) - spread) * mag;\n    float bottom = (getPos(x * scale + 30.0f, time * timeScale) + spread) * mag;\n    float strengthTop = smoothstep(-3.0f, 3.0f, getPos(x * 10.0 + 60.0f, - time * 1.0f));\n    float strengthBottom = smoothstep(-3.0f, 3.0f, getPos(x * 7.0 + 120.0f, - time * 1.0f));\n    float mid = (bottom + top) / 2.0f;\n    top = mix(mid, top, magScale);\n    bottom = mix(mid, bottom, magScale);\n    float width = max(0.001f, abs(bottom - top)) / 2.0f;    \n    float dist = abs(y - mid) / width;\n    float alpha = abs(y - mid) / width;\n    float innerAlpha = pow(max(0.0f, 0.5f + 1.2f * (pow(alpha, 2.0f) - 0.4f * pow(alpha, 5.0f))), 2.2f);\n    alpha = innerAlpha;\n    alpha = pow(alpha, 2.2f) * 0.5f;\n    alpha = max(alpha, distFromLine(y, top, strengthTop) + distFromLine(y, bottom, strengthBottom));\n    alpha = clamp(alpha, 0.0, 1.0);\n    alpha = alpha * (x > barLength ? 0.0f : 1.0f);\n    // Time varying pixel color\n    vec3 col = vec3(0.25, 0.5f, 0.18);\n    //col = mix(vec3(0.0f), col, pow(alpha, 0.5f));\n    //col = pow(col, vec3(2.2f));\n    //col = pow(col, vec3(2.2f));\n    float bloom = max(distFromLine2(y, top, 1.0), distFromLine2(y, bottom, 1.0));\n    \n    vec3 sky = cubemap(fragCoord).rgb;// texture(iChannel0, uv).rgb;// vec3(0.3f, 0.6f, 0.9f);\n    \n    float barMask = smoothstep(-0.01f, 0.0f, x) * smoothstep(1.0f, 0.99f, x);\n    \n    \n    vec4 background = vec4(vec3(0.2, 0.8f, 0.1) * 0.5f, saturate(8.0f - dist * 8.0f) * 0.4f * barMask);\n    vec4 line = vec4(vec3(0.0f), pow(smoothstep(0.013, 0.01f, abs(0.0f - y)), 0.45f) * 0.7f * barMask);\n    alpha *= barMask;\n    \n    vec4 r = vec4(sky, 1);\n    r = r + vec4(vec3(bloom) * smoothstep(barLength * 1.1f, barLength, x) * smoothstep(-0.1f, 0.0f, x) * vec3(0.4, 0.8f, 0.1) * 0.2f, 0.0);\n    r = comp(line, r);\n    r = vec4(background.rgb * background.a + r.rgb * (1.0 - background.a), 1.0f);\n    //r = comp(vec4(col, alpha), r);\n\n    // Output to screen\n    //fragColor = vec4(vec3(alpha),1.0);\n    //alpha = pow(alpha, 2.2f);\n    fragColor = vec4(r.rgb + col * alpha * barMask * 3.0,1.0);\n}","name":"Image","description":"","type":"image"}]}