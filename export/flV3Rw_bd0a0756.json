{"ver":"0.1","info":{"id":"flV3Rw","date":"1637366080","viewed":70,"name":"raycasting101","username":"bigjey","description":"learning raycasting\n\ninspired by https://www.youtube.com/watch?v=TTqLX0OHZzI","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat MAX_DISTANCE = 200.0;\nfloat gamma = 2.2; \n\n\nvec3 rotateX(vec3 a, float angle)\n{\n    vec3 b = a;\n    b.z = a.z * cos(angle) - a.y * sin(angle);\n    b.y = a.z * sin(angle) + a.y * cos(angle);\n    return b;\n}\n\nvec3 rotateY(vec3 a, float angle)\n{\n    vec3 b = a;\n    b.x = a.x * cos(angle) - a.z * sin(angle);\n    b.z = a.x * sin(angle) + a.z * cos(angle);\n    return b;\n}\n\nvec3 rotateZ(vec3 a, float angle)\n{\n    vec3 b = a;\n    b.x = a.x * cos(angle) - a.y * sin(angle);\n    b.y = a.x * sin(angle) + a.y * cos(angle);\n    return b;\n}\n\n\nvec3 castRay(inout vec3 ro, inout vec3 rd) {\n\n    vec2 minIt = vec2(MAX_DISTANCE);\n    vec3 n = vec3(0);\n    vec3 col;\n    \n    vec3 spherePos = vec3(-3.0, 0, -1.0);\n    vec2 it = sphIntersect(ro, rd, spherePos, 1.0);\n    if (it.x > 0.0 && it.x < minIt.x) {\n        col = vec3(1.0, 0, 0);\n        n = normalize(ro + rd * it.x - spherePos);\n        minIt = it;\n    }\n    \n    spherePos = vec3(4.0, 3.0, 3.0);\n    it = sphIntersect(ro, rd, spherePos, 3.0);\n    if (it.x > 0.0 && it.x < minIt.x) {\n        col = vec3(1.0, 0, 1.0);\n        n = normalize(ro + rd * it.x - spherePos);\n        minIt = it;\n    }\n    \n    vec3 boxSize = vec3(1);\n    vec3 boxN;\n    it = boxIntersection(ro, rd, boxSize, boxN);\n    if (it.x > 0.0 && it.x < minIt.x) {\n        col = vec3(0.1, 0.8, 0.2);\n        n = boxN;\n        minIt = it;\n    }\n    \n    vec4 planeN = vec4(0, -1, 0, -1);\n    it = vec2(plaIntersect(ro, rd, planeN));\n    if (it.x > 0.0 && it.x < minIt.x) {\n        col = vec3(1.0, 1.0, 1.0);\n        n = planeN.xyz;\n        minIt = it;\n    }\n    \n    if (minIt.x == MAX_DISTANCE) {\n        return vec3(-1.0);\n    }\n    \n    vec3 light = normalize(vec3(sin(iTime), 1, cos(iTime)/5.0));\n    // vec light = normalize(vec3(1, 1, 0));\n    \n    float ambient = 0.1;\n    float diffuse = max(0.0, dot(n, light)) * 0.4 + 0.4;\n    float specular = pow(max(0.0, dot(reflect(rd, n), light)), 64.0);\n        \n    ro += rd * (minIt.x - 0.001);\n    rd = n;\n    \n    return (ambient + diffuse) * col + specular;\n}\n\nvec3 traceRay(vec3 ro, vec3 rd) {\n    vec3 col = castRay(ro, rd);\n\n    if (col.x == -1.0) {\n        return vec3(0.1,0.5,0.8);\n    }\n    \n    vec3 light = normalize(vec3(sin(iTime), 1, cos(iTime)/5.0));\n    \n    ro -= rd * 0.01;\n        \n    vec3 hitColor = castRay(ro, light);    \n    if (hitColor.x != -1.0) {\n        col *= 0.5;\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * iResolution.xy/iResolution.y;    \n    \n    vec3 ro = vec3(0, 2, -10);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    ro = rotateZ(ro, 0.25);    \n    ro = rotateY(ro, iTime * 0.4);\n    \n    rd = rotateX(rd, -0.15);\n    rd = rotateY(rd, iTime * 0.4);\n   \n    vec3 col = traceRay(ro, rd);\n            \n    col = pow(col, vec3(1.0/gamma));\n        \n    fragColor = vec4(col, 1.0);    \n}\n\n\n","name":"Image","description":"","type":"image"}]}