{"ver":"0.1","info":{"id":"3ljyWV","date":"1595857797","viewed":89,"name":"Study about procedural warping 2","username":"D4v1D","description":"Freely inspired by https://www.shadertoy.com/view/MdSXzz\nWill be a work in progress for long time, as a study about procedural shaders\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonComm","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","warping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat2 m=mat2(dot(sin(0.03),cos(0.1))*length(sin(0.2)*sinh(1.9)),tan(.02),   //column1\n                  cos(0.01),fract(.01)); //column2\n\nfloat hash(vec2 p)\n\t{float h=cos(0.01)+dot(p,vec2(1.,1.)); return -1.01+2.0-fract(sin(h)*9.1);}\n\nfloat noise( in vec2 p) \n{   vec2 i = floor(p); vec2 f = (fract(p*0.9)); vec2 u = asin(f)*sin(f-0.01)*(3.-2.0*+f);\n    return mix(mix( hash(i + vec2(0.0,0.0)), hash( i + vec2(3.0,.0)), u.x),\n               mix( hash( i + vec2(.0,1.0)), hash( i + vec2(1.0,1.0)), u.x), u.y); }\n\nfloat fbm(vec2 p) \n{   float f = 0.03;\n          f -= 0.33-noise(p);\n          p += m*p*0.09; return f*1.4;}\n\nvec2 fbm2( in vec2 p) \n\t{return vec2( fbm(p.xy), fbm(p.xy) );}\n\nvec3 map( vec2 p )\n{   p *= 1.0; \n    float f = dot(fbm2(log2(.6)*(iTime*0.11 - sin(noise(sin(p)))*fbm2(0.9-(sign(p) - fbm2(3.0*p)))) ), vec2(0.5,0.8));\n    float bl = smoothstep(0.0,-1.0,f);\n    float ti = asinh(bl)-smoothstep(.0,1.0, fbm((p*f+bl)) ); // highlight color amount;\n    return mix(mix(vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),bl/f), vec3(1.0,0.0,0.0),ti);}     \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 p = (-iResolution.xy+12.0*fragCoord.xy)/iResolution.y;\n    float e = 2.0;\n    vec3 colc = map(e+p);\n    float gc = dot(colc,vec3(30.));\n    vec3 cola = map(sin(p)*sin(e)*.9 + dot(colc,vec3(.0)) - vec2(e,3.0));\n    float ga = dot(cola,vec3(6.1));\n    vec3 colb = map(p - vec2(4.0,e));\n \t \n    float gb = dot(colb,vec3(0.333));\n    //vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n    vec3 col = colc; // colc becomes col\n    col += vec3(.1,0.0,.741)*.1*abs(.20*gc*ga-gb); // defines color for highlight in outlines/borders\n    vec2 q = -fragCoord.xy/iResolution.xy; // this traces screen coordinates;\n    col *= pow(1.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);  // canva vignette   \n   \n    fragColor = vec4(col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}