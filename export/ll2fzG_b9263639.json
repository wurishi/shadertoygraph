{"ver":"0.1","info":{"id":"ll2fzG","date":"1516361775","viewed":279,"name":"Cyan bubbles","username":"skaplun","description":"Tryin to reproduce Dave Whyte's animation.\nOriginal: https://dribbble.com/shots/1728616-Bubbles\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","circles","animation","bubbles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROWS 9\n#define COLS 20\n#define TAU 6.28318530718\n#define es .01\n#define initialRad .125\n#define rMat(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define dotRad(x) TAU*x/float(COLS)*.4\n#define CLR vec3(.388, .843, .976)\n\nfloat remap(float value, float min, float max) {\n    return clamp((value - min) / (max - min), 0., 1.);\n}\n\nfloat calcRowRad(int rowNum){\n\tfloat rad = initialRad;\n\t//FIXME codeblock below could be replaced with non conditional expression,\n    //\t\t\tbut in some reason it don't work. Any ideas?\n    //rad += step(0., sin(iTime * 3.)) * step(0., cos(iTime * 3.)) * .0705;\n    {\n        float s = sin(iTime * 3.);\n        float c = cos(iTime * 3.);\n        if(s > 0. && c > 0.)\n            rad += s * .0705;\n    }\n    for(int i=0; i<rowNum; i++)\n\t\trad += dotRad(rad) * 2.;\n\treturn rad;\n}\n\n//Any ideas how to implement smthn like this without loops?\nfloat clr(vec2 st){\n    float clr = 0.;\n    float colStep = TAU/float(COLS);\n    for(int j = 0; j < ROWS; j++){\n        float rowRad = calcRowRad(j);\n        for(int i = 0; i < COLS; i++){\n            vec2 dotCenter = vec2(rowRad, 0.) * rMat(float(i) * colStep + (colStep * .5 * mod(float(j), 2.)));\n            float dotRad = dotRad(rowRad);\n            float dotClr = 1. - smoothstep(dotRad - es, dotRad, length(st - dotCenter));\n            float waveCenter = .41;\n            float thickness = remap(abs(length(dotCenter) - waveCenter), 0., 0.2);\n            dotClr *= smoothstep(dotRad * thickness - es, dotRad * thickness, length(st - dotCenter));\n\t\t\tdotClr *= step(es, 1. - thickness);\n            clr += dotClr;\n        }\n    }\n    \n    return clr;\n}\n\n//FIXME: looks different than original. Too many circles per row\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy/iResolution.xy*2.-1.;\n    st.x *= iResolution.x/iResolution.y;\n    fragColor = vec4(clr(st) * CLR, 1.);\n}","name":"Image","description":"","type":"image"}]}