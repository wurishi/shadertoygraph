{"ver":"0.1","info":{"id":"dtf3WN","date":"1671754387","viewed":95,"name":"BEES BEES BEES","username":"4LT","description":"Result of misunderstanding multivariable vector calculus","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["swarm","accident"],"hasliked":0,"parentid":"DlsGWH","parentname":"Snow Sweep"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tau = 2. * acos(-1.);\n\nconst vec3 forward = vec3(0., 0., 1.);\nconst vec3 up = vec3(0., 1., 0.);\nconst vec3 right = vec3(-1., 0., 0.);\nconst vec3 cam = vec3(0., 0., -2.0);\nconst vec3 sph = vec3(0., 0., 0.);\n\nconst float ptCt = 200.;\nconst float speed = 1.;\n\nfloat t;\n\nfloat dist(vec3 rayDir) {\n    float minDist = 99999.;\n    for (float i = 0.; i < ptCt; i++) {\n        float iNorm = i / ptCt;\n        \n        vec4 denoms = vec4(0.243453, 0.4234345, 0.2357797, 0.165777341);\n        vec2 rand = mod(iNorm * vec2(1.3236574234, 0.934556756345), denoms.xy) / denoms.xy;\n        rand = mod(rand.yx, denoms.zw)/denoms.zw;\n        rand = mod(rand, denoms.xz)/denoms.xz;\n        rand = mod(rand.yx, denoms.yw)/denoms.yw;\n        \n        float phi = acos(1. - fract(rand.x + t/4.) * 2.);\n        float theta = rand.y * tau + t * (rand.x + iNorm + 2.)/4.;\n        \n        float horz = sin(phi);\n        vec3 sph2i = vec3(horz * cos(theta), cos(phi), horz * sin(theta));\n        vec3 iPos = sph2i + sph;\n        vec3 sph2cam = cam - sph;\n        \n        float rayDist = dot(-sph2cam, rayDir);\n        float segFrac = dot(sph2cam, sph2i) + dot(rayDir, sph2i)*rayDist;\n        vec3 rayPos = cam + rayDir * rayDist;\n                \n        float iDist = length(rayPos - mix(sph, iPos, segFrac));\n        minDist = min(min(iDist, minDist), min(length(rayPos - sph), length(rayPos - iPos)));\n    }\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime * speed;\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.);\n    uv.x*= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(uv.x * right + uv.y * up + forward);\n    \n    float d = dist(rayDir);\n    if (d < 0.01) {\n        fragColor = vec4(1., 1., 0.7, 1.);\n    } else {\n        fragColor = vec4(sqrt(d), d, 0., 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}