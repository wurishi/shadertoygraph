{"ver":"0.1","info":{"id":"cddXW4","date":"1679826869","viewed":98,"name":"Carousel","username":"gest","description":"Divide space into sectors","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n    #define texture2D texture\n    #define textureCube texture\n#endif\n\n\n\n#define ID_SHAPE 1.\n#define ID_STARS 2.\n\nfloat glow = 0.;\nfloat calcGlow = 1.;\n\nfloat map(vec3 p, inout Object object) {\n\tvec3 q, qq;\n\tfloat d1,d2, scale, sectors;\n\t\n\tobject = Object(1e6, -1.0);\n\t\n\tObject shape = Object(1e6, ID_SHAPE);\n\tscale = 1.0;\n\tq = p;\n\tq /= scale;\n\trotateX90(q); //rotateX(q, PI/2.);\n\tsectors = 16.;\n\treplicaAngle(q.xy, sectors, u_time);\n\trotateX90(q); //rotateX(q, PI/2.);\n\tfloat radius = abs(sin(u_time*0.5)*cos(u_time*0.25)*0.2+0.2);\n\ttranslate(q.x, radius);\n\tsectors = 3.+floor(mod(u_time*0.5, 15.));\n\treplicaAngle(q.xy, sectors, 0.);\n\td1 = dfBefore(q.x, 0.22);\n\ttranslate(q.x, 0.2);\n\td2 = dfCyl(q.xz, 0.03);\n\tfloat mixing = abs(sin(u_time*0.1)*0.1);\n\tshape.distance = AND(d1, d2, mixing)*scale;\n\n\tobject = OR(object, shape); //Помещаем на сцену\n\n\tObject stars = Object(1e6, ID_STARS);\n\tscale = 1.5;\n\tq = p;\n\tq /= scale;\n\trotateX90(q); //rotateX(q, PI/2.);\n\tsectors = 8.;\n\tfloat star_id = replicaAngle(q.xy, sectors, u_time + 2.*PI/16.*0.5);\n\ttranslate(q.x,  0.3);\n\tsectors = 5.;\n\treplicaAngle(q.xy, sectors, star_id * u_time);\n\td1 = dfBefore(q.x, 0.05);\n\td2 = dfCyl(q.yz, 0.005);\n\tstars.distance = AND(d1, d2)*scale;\n\t\n\tobject = OR(object, stars); //Помещаем на сцену\n\t\n\tglow += 0.006/(stars.distance*stars.distance);\n\t\n\treturn object.distance;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal(vec3 p, float eps) {\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\nfloat rayMarch(inout Ray ray) {\t\n\tray.distance = ray.near;\n\tfloat steps = 1.;\n\tfor(int i = 0;i < 100;i++) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif(ray.hit) break;\n\t\tray.distance += ray.object.distance * ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\nvec3 lighting(Ray ray, vec3 lightDir, vec3 mColor) {\n\tfloat atten = 1. / pow(ray.distance,2.0);\n\tfloat ambient = 0.1;\n\tfloat diffuse = max(0.0, dot(ray.normal,  lightDir));\n\tfloat specular = pow(max(0.0, dot(reflect(ray.direction, ray.normal), lightDir)),8.0);\n\treturn mColor * (ambient + (diffuse*1.5 + 1.5*specular) * atten);\n}\n\nvoid main()  {\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy/u_canvas.xy;\n\tuv = uv - 0.5;\n\t\n\tvec2 mouse = u_mouse.xy/u_canvas.xy;\n\tif (mouse==vec2(0)) mouse = vec2(0.5);\n\n\tvec3 angle = vec3(\n\t\t-mix(-90., 90., mouse.y),\n\t\t mix(-180.,180., mouse.x),\n\t\t 0\n\t);\n\t\n\tCamera cam;\n\t{\n\t\tcam.fov     = 45.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = vec3( 0, 1, -1.5);\n\t\trotateOrigin(cam.origin, radians(angle));\n\t\tcam.target  = vec3( 0, 0, 0 );\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= 12.;\n\t\tray.epsilon = 0.001;\n\t\tray.swing\t= 1.0;\n\t\tray.steps \t= 96.;\n\n\t}\n\tfloat steps = rayMarch(ray);\n\n\tvec3 color = 0.045* glow * vec3(0.2,0.1,1.0);\n\n\tvec3 lightDir = -ray.direction;\n\t\n\tif (ray.hit) {\n\t\tcalcGlow = 0.;\n\t\tray.normal = mapNormal(ray.position, ray.epsilon*10.);\n\t\t\n\t\tvec3 mColor = vec3(1);\n\t\tif (ray.object.id == ID_SHAPE) {\n\t\t\tmColor = vec3(1.0,0.2,0.2);\n\t\t\tcolor += lighting(ray, lightDir, mColor);\n\t\t} else if (ray.object.id == ID_STARS) {\n\t\t\tmColor = vec3(0.2,0.1,1.0)*3.;\n\t\t\tcolor = lighting(ray, lightDir, mColor);\n\t\t}\n\t\t\n\t\tfloat atten = 1.0 - steps/ray.steps;\n\t\tcolor *= atten;\n\t}\n\t\n\tgl_FragColor = vec4( color, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n//-------------------Функции позиционирования объектов сцены\nvoid translate(inout vec3 p, vec3 dist) {\n\tp = p - dist;\n}\nvoid translate(inout vec2 p, vec2 dist) {\n\tp = p - dist;\n}\nvoid translate(inout float p, float dist) {\n\tp = p - dist;\n}\n\n//Вращение вокруг осей\nmat3 rotate(vec3 r) {\n\tvec3 s = sin(r), c = cos(r);\n\tmat3 mx = mat3(1.0, 0.0, 0.0,    0.0, c.x, -s.x,   \t0.0, s.x, c.x);\n\tmat3 my = mat3(c.y, 0.0, -s.y,   0.0, 1.0, 0.0,   \ts.y, 0.0, c.y);\n\tmat3 mz = mat3(c.z, -s.z, 0.0,   s.z, c.z, 0.0,   \t0.0, 0.0, 1.0);\n   \treturn mx * my * mz;\n}\nvoid rotate(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = tMat * p;\n}\nvoid rotateOrigin(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = p * tMat;\n}\nvoid rotateX(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(r,0,0));\n\tp = tMat * p;\n}\nvoid rotateY(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(0,r,0));\n\tp = tMat * p;\n}\nvoid rotateZ(inout vec3 p, float r) {\n\tmat3 tMat = rotate(vec3(0,0,r));\n\tp = tMat * p;\n}\nvoid rotateX90(inout vec3 p) {\n\tp.xyz = p.xzy;\n}\nvoid rotateY90(inout vec3 p) {\n\tp.xyz = p.zyx;\n}\nvoid rotateZ90(inout vec3 p) {\n\tp.xyz = p.yxz;\n}\n\n//Отражение / Дублирование\nvoid mirror(inout vec3 p, vec3 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout vec2 p, vec2 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout float p, float dist) {\n\tp = abs(p) - dist;\n}\n//Размножение. Возвращает центр ячейки с id=0.\nfloat replica(inout float p, float d) {\n    float id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\n\nvec2 replica(inout vec2 p, vec2 d) {\n    vec2 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nvec3 replica(inout vec3 p, vec3 d) {\n    vec3 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nfloat replicaLimit(inout float p, float d, float ida, float idb) {\n\tfloat id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec2 replicaLimit(inout vec2 p, vec2 d, vec2 ida, vec2 idb) {\n\tvec2 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec3 replicaLimit(inout vec3 p, vec3 d, vec3 ida, vec3 idb) {\n\tvec3 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nfloat replicaAngle(inout vec2 p, float n, float offset) {\n\tfloat a = 2.* PI /n;\n\t//polar\n\tp = vec2(atan(p.y, p.x), length(p.xy));\n\tfloat id = floor(mod(p.x + 0.5*a + offset, 2.*PI)/a);\n    p.x = mod(p.x + 0.5*a + offset, a) - 0.5*a;\n\tp = p.y * vec2(cos(p.x),sin(p.x));\n\treturn id;\n}\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n//Мягкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR(float distA, float distB, float k) {\n\tfloat h = clamp( 0.5 - 0.5*(distA-distB)/k, 0., 1. );\n\treturn mix(distA, distB, 1.-h) - k*h*(1.-h);\n}\n//Мягкое умножение / Пересечение / И (k==0 без)\nfloat AND(float distA, float distB, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(distA-distB)/k, 0., 1. );\n\treturn mix(distA, distB, 1.-h) + k*h*(1.-h);\n}\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n\n//Умножение / Пересечение / И\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n//-------------------функции расстояний до объектов\n\nfloat dfBox(vec3 p, vec3 s) {\n\tp = abs(p) - s / 2.0;\n\treturn max(max(p.x,p.y),p.z);\n}\n\nfloat dfBall(vec3 p, float R) {\n\treturn length(p)-R;\n}\nfloat dfBefore(float p, float h) {\n\treturn p - h;\n}\nfloat dfAfter(float p, float h) {\n\treturn -p - h;\n}\nfloat dfPlane(vec3 p, vec3 n, float h) {\n  \treturn dot(p, normalize(n)) + h;\n}\nfloat dfCyl(vec2 p, float R) {\n\treturn length(p) - R;\n}","name":"Common","description":"","type":"common"}]}