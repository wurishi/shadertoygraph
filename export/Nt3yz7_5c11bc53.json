{"ver":"0.1","info":{"id":"Nt3yz7","date":"1659447604","viewed":134,"name":"AutoDiff (f(x), f'(x), f''(x))","username":"Envy24","description":"Forward mode automatic differential via extended dual numbers.\nWith this numbers call y=f(x) converts to vec3(f(x), f'(x), f''(x)) = f(vec3(x, 1, 0)).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["numbers","derivative","first","dual","second","mode","automatic","forward","differenciation","algorithmic"],"hasliked":0,"parentid":"7dVfD1","parentname":"Plotter template_"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  5.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SMAA(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n/* Examples */\nvec3 f0(vec3 x)\n{\n    // f(x) = a * x^5\n    float a = sinOSC(-2., 2., iTime * 0.5);\n    return mul(a, ipower(x, 5));\n}\n\nvec3 f1(vec3 x)\n{\n    // f(x) = tan(cos(x/a))\n    float a = sinOSC(0.8, 2., iTime * 0.5);\n    return tangens(cosine(div(x, a)));\n}\n\nvec3 f2(vec3 x)\n{\n    // f(x) = sineh(x)/cosineh(x) - tangensh(a);\n    float a = sinOSC(-2., 2., iTime * 0.5);\n    return sub(div(sineh(x), cosineh(x)), tangensh(vec3(a, 0., 0.)));\n}\n\nvec3 f3(vec3 x)\n{\n    // f(x) = x^a;\n    float a = sinOSC(-2., 2., iTime * 0.5);\n    \n    //return power(x, vec3(a, 0., 0.));\n    return power(x, a);\n}\n\nvec3 f4(vec3 x)\n{\n    // f(x) = a^x;\n    float a = sinOSC(0.1, 2., iTime * 0.5);\n    \n    return power(a, x);\n}\n\nvec3 f5(vec3 x)\n{ \n    float a = sinOSC(-2., 2., iTime * 0.5);\n    return div(a, x);\n}\n\nvec3 f6(vec3 x)\n{ \n    // f(x) = |sin(x*a)|\n    float a = sinOSC(-2., 2., iTime * 0.5);\n    return absolute(sine(x * a));\n}\n\nvec3 F(vec3 x)\n{\n    int c = int(iTime * 0.125) % 7;\n\n    switch(c)\n    {\n    case 0: return f0(x);\n    case 1: return f1(x);\n    case 2: return f2(x);\n    case 3: return f3(x);\n    case 4: return f4(x);\n    case 5: return f5(x);\n    default: return f6(x);\n    }\n}\n\n#define f F\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 2.0\n#define YSCALE 1.0\n#define OFFSET vec2(0., 0.)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\nfloat dx = 0.01;\n\n/* Analytic f(x), f'(x), f''(x). *\nfloat a = sinOSC(0.1, 2., iTime * 0.5);\n#define func(x)   ( pow(a, x) )\n#define fderiv(x) ( pow(a, x)*log(a) )\n#define sderiv(x) ( pow(a, x)*log(a)*log(a) )\n\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*fderiv(NDC.x));\n         color.gb -= draw_func(NDC, YSCALE*fderiv(NDC.x), YSCALE*sderiv(NDC.x));\n         color.rg -= draw_func(NDC, YSCALE*sderiv(NDC.x), YSCALE*(sderiv(NDC.x+dx)-sderiv(NDC.x))/dx);\n         \n/* AutoDiff f(x), f'(x), f''(x). */   \n    vec3 v = f(vec3(NDC.x, 1., 0.));\n    vec3 w = f(vec3(NDC.x+dx, 1., 0.));\n    \n        color.rb -= draw_func(NDC, YSCALE*v.x, YSCALE*v.y); // f(x)\n        color.gb -= draw_func(NDC, YSCALE*v.y, YSCALE*v.z); // f'(x)\n        color.rg -= draw_func(NDC, YSCALE*v.z, YSCALE*((w.z - v.z)/dx)); // f''(x)\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}\n\n/* \n    This shader helps you to understand how to extend AD to multiple input, for calculating of auto gradient and laplacian:\n    https://www.shadertoy.com/view/3tGcRt\n    \n    Other implementations:\n        https://www.shadertoy.com/view/4dVGzw\n        https://www.shadertoy.com/view/stSXzD\n        https://www.shadertoy.com/view/Xd2GzR\n        https://www.shadertoy.com/view/Mdl3Ws\n        https://www.shadertoy.com/view/ttfGRB\n*/\n\n/* Basic arithmetic rules */\nvec3 mul(vec3 L, vec3 R)\n{\n    return vec3(\n        L.x * R.x,\n        L.x * R.y + L.y * R.x,\n        L.x * R.z + R.x * L.z + 2. * L.y * R.y);\n}\nvec3 mul(float L, vec3 R) { return vec3(L * R.x, L * R.y, L * R.z); }\nvec3 mul(vec3 L, float R) { return vec3(L.x * R, L.y * R, L.z * R); }\n\nvec3 div(vec3 L, vec3 R)\n{\n    float RR = R.x * R.x;\n\n    return vec3(\n        L.x / R.x,\n        (L.y * R.x - L.x * R.y) / RR,\n        (L.z * RR - R.x * (2. * L.y * R.y + L.x * R.z) + 2. * L.x * R.y * R.y) / (RR * R.x));\n}\nvec3 div(vec3 L, float R)\n{\n    float inv = 1. / R;\n    return vec3(L.x * inv, L.y * inv, L.z * inv);\n}\nvec3 div(float L, vec3 R)\n{\n    float RR = R.x * R.x;\n    return vec3(\n        L / R.x,\n        -(L*R.y) / RR,\n        (2.*L*R.y*R.y)/(RR*R.x) - (L*R.z)/RR);\n}\n\nvec3 add(vec3 L, vec3 R) { return vec3( L.x + R.x, L.y + R.y, L.z + R.z); }\nvec3 add(float L, vec3 R) { return vec3( L + R.x, R.y, R.z); }\nvec3 add(vec3 L, float R) { return vec3( L.x + R, L.y, L.z); }\n\nvec3 sub(vec3 L, vec3 R) { return vec3(L.x - R.x, L.y - R.y, L.z - R.z); }\nvec3 sub(float L, vec3 R) { return vec3(L - R.x, -R.y, -R.z); }\nvec3 sub(vec3 L, float R) { return vec3(L.x - R, L.y, L.z); }\n\n/* Elementary runctions in order:\n    sin,   cos,   tan,\n    sinh,  cosh,  tanh,\n    asin,  acos,  atan,\n    asinh, acosh, atanh,\n    exp,   ln,    ipow,\n    pow,   abs,   sqrt.\n    \n   All functions return vec3(f(x), f'(x), f''(x)).\n*/\nvec3 sine(vec3 rad)\n{\n    float s = sin(rad.x), c = cos(rad.x);\n\n    return vec3(\n        s,\n        rad.y * c,\n        c * rad.z - s * rad.y * rad.y);\n}\n\nvec3 cosine(vec3 rad)\n{\n    float s = sin(rad.x), c = cos(rad.x);\n\n    return vec3(\n        c,\n        -rad.y * s,\n        -(c*rad.y * rad.y + s * rad.z));\n}\n\nvec3 tangens(vec3 rad)\n{\n    float t = tan(rad.x), invc = 1.0 / cos(rad.x);\n\n    return vec3(\n        t,\n        rad.y * invc * invc,\n        (2.* t * rad.y * rad.y + rad.z) * invc * invc);\n}\n\nvec3 sineh(vec3 rad)\n{\n    float s = sinh(rad.x), c = cosh(rad.x);\n\n    return vec3(\n        s,\n        rad.y * c,\n        s * rad.y * rad.y + c * rad.z);\n}\n\nvec3 cosineh(vec3 rad)\n{\n    float s = sinh(rad.x), c = cosh(rad.x);\n\n    return vec3(\n        c,\n        rad.y * s,\n        c * rad.y * rad.y + s * rad.z);\n}\n\nvec3 tangensh(vec3 rad)\n{\n    float t = tanh(rad.x), invc = 1.0 / cosh(rad.x);\n\n    return vec3(\n        t,\n        rad.y * invc * invc,\n        (2. * t * rad.y * rad.y + rad.z) * invc * invc);\n}\n\nvec3 asine(vec3 sine)\n{\n    float t = 1. - sine.x * sine.x, inv = 1. / sqrt(t);\n\n    return vec3(\n        asin(sine.x),\n        sine.y * inv,\n        (sine.x * sine.y * sine.y) / sqrt(t*t*t) + sine.z * inv);\n}\n\nvec3 acosine(vec3 cosine)\n{\n    float t = 1. - cosine.x * cosine.x, inv = 1. / sqrt(t);\n\n    return vec3(\n        acos(cosine.x),\n        -cosine.y * inv,\n        -((cosine.x * cosine.y * cosine.y) / sqrt(t*t*t) + cosine.z * inv));\n}\n\nvec3 atangens(vec3 tangens)\n{\n    float t = tangens.x * tangens.x + 1., inv = 1. / t;\n\n    return vec3(\n        atan(tangens.x),\n        tangens.y * inv,\n        inv * (tangens.z - 2. * tangens.x * tangens.y * tangens.y * inv));\n}\n\nvec3 asineh(vec3 hsine)\n{\n    float t = hsine.x * hsine.x + 1., inv = 1. / sqrt(t);\n\n    return vec3(\n        asinh(hsine.x),\n        hsine.y * inv,\n        hsine.z * inv - (hsine.x * hsine.y * hsine.y) / sqrt(t*t*t));\n}\n\nvec3 acosineh(vec3 hcosine)\n{\n    float t = hcosine.x * hcosine.x - 1., inv = 1. / sqrt(t);\n\n    return vec3(\n        acosh(hcosine.x),\n        hcosine.y * inv,\n        hcosine.z * inv - (hcosine.x * hcosine.y * hcosine.y) / sqrt(t*t*t));\n}\n\nvec3 atangensh(vec3 htangens)\n{\n    float t = 1. - htangens.x * htangens.x, inv = 1. / t;\n\n    return vec3(\n        atanh(htangens.x),\n        htangens.y * inv,\n        inv * (2.* htangens.x * htangens.y * htangens.y * inv + htangens.z));\n}\n\nvec3 expf(vec3 exponent)\n{\n    float f = exp(exponent.x);\n\n    return vec3(f, exponent.y * f, f * (exponent.y * exponent.y + exponent.z));\n}\n\nvec3 ln(vec3 power)\n{\n    float ratio = power.y / power.x;\n\n    return vec3(\n        log(power.x),\n        ratio,\n        ratio * (power.z - ratio * power.y * power.y));\n}\n\nvec3 ipower(vec3 base, int exponent)\n{\n    vec3 R = base;\n    for (int i = 1; i < exponent; ++i) { R = mul(R, base); }\n    return R;\n}\n\nvec3 power(float base, vec3 exponent)\n{\n    float power = pow(base, exponent.x), ln = log(base);\n\n    return vec3(\n        power,\n        power * ln * exponent.y,\n        power * ln * (ln * exponent.y * exponent.y + exponent.z));\n}\nvec3 power(vec3 base, vec3 exponent)\n{\n    return expf(mul(exponent, ln(base)));\n    //return base.x >= 0. ? expf(mul(exponent, ln(base))) : expf(mul(exponent, ln(-base)));\n}\n\nvec3 power(vec3 base, float a)\n{\n    float power = pow(base.x, a - 1.);\n\n    return vec3(\n        pow(base.x, a),\n        a * power * base.y,\n        (a - 1.) * a * pow(base.x, a - 2.) * base.y * base.y + a * power * base.z);\n}\n\nvec3 absolute(vec3 number)\n{\n    float ratio = number.x / abs(number.x);\n\n    return vec3(\n        abs(number.x),\n        number.y * ratio,\n        number.z * ratio);\n}\n\nvec3 square_root(vec3 square)\n{\n    float sqrt_ = sqrt(square.x), inv = 1. / (2. * sqrt_);\n\n    return vec3(\n        sqrt_,\n        square.y * inv,\n        square.z * inv - (square.y * square.y) / (4. * sqrt(square.x * square.x * square.x)));\n}","name":"Common","description":"","type":"common"}]}