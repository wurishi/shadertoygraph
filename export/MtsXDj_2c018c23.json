{"ver":"0.1","info":{"id":"MtsXDj","date":"1439933388","viewed":482,"name":"Relativistic lattice","username":"makc","description":"In case you wanted to know how does the space look like when you move really fast...","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["rocket","relativity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Shadertoy version of http://makc.github.io/misc/relativity-1.html\n\n// What you are looking at here is the giant cubic lattice with the\n// side of ten light seconds. Click or hold the mouse button to pick\n// rocket velocity (0 at the bottom, 0.95c at the top) and the camera\n// direction. The result is what the rocket pilot would actually see\n// in his(her) window - also known as relativistic aberration. Funny\n// shit happens at high velocities, e g you begin to see objects' far\n// side - for visual explanation, see 2nd video here:\n// http://people.physics.anu.edu.au/~cms130/TEE/site/tee/learning/aberration/aberration.html\n\n// Ok, to the code...\n\n// butt first - the rocket from https://www.shadertoy.com/view/ltjGD1\n\nfloat pi = 3.14159265359;\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nvoid angularRepeat(const float a, const float offset, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    an+=offset;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nfloat mBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\nvec2 frot(const float a, in vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n    return v;\n}\n\nvoid rotate(const float a, inout vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n}\n\nfloat dfRocketBody(vec3 p)\n{\n    vec3 p2 = p;\n    vec3 pWindow = p;\n    \n    angularRepeat(pi*.25,p2.zy);\n    float d = p2.z;\n    d = max(d, frot(pi*-.125, p2.xz+vec2(-.7,0)).y);\n    d = max(d, frot(pi*-.25*.75, p2.xz+vec2(-0.95,0)).y);\n    d = max(d, frot(pi*-.125*.5, p2.xz+vec2(-0.4,0)).y);\n    d = max(d, frot(pi*.125*.25, p2.xz+vec2(+0.2,0)).y);\n    d = max(d, frot(pi*.125*.8, p2.xz+vec2(.55,0)).y);\n    d = max(d,-.8-p.x);\n    d -= .5;\n    \n    pWindow -= vec3(.1,.0,.0);\n    angularRepeat(pi*.25,pWindow.xy);\n    pWindow -= vec3(.17,.0,.0);\n    d = min(d,mBox(pWindow,vec3(.03,.2,.55)));\n    \n  \treturn d;\n}\n\nfloat dfRocketFins(vec3 p)\n{\n    vec3 pFins = p;\n    angularRepeat(pi*.5,pFins.zy);\n    pFins -= vec3(-1.0+cos(p.x+.2)*.5,.0,.0);\n    rotate(pi*.25,pFins.xz);\n    float scale = 1.0-pFins.z*.5;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    return d;\n}\n\nfloat df(vec3 p)\n{\n    float proxy = mBox(p,vec3(2.5,.8,.8));\n    if (proxy>1.0)\n    \treturn proxy;\n    return min(dfRocketBody(p),dfRocketFins(p));\n}\n\nvec3 nf(vec3 p)\n{\n    vec2 e = vec2(0,0.005);\n    return normalize(vec3(df(p+e.yxx),df(p+e.xyx),df(p+e.xxy)));\n}\n\n\nvoid rocket (inout vec3 color, in vec3 pos, in vec3 dir) {\n    \n    float dist,tdist = .0;\n    \n    for (int i=0; i<100; i++)\n    {\n     \tdist = df(pos);\n       \tpos += dist*dir;\n        tdist+=dist;\n        if (dist<0.000001||dist>20.0)break;\n    }\n\n    vec3 materialColor = vec3(.0);\n    vec3 orangeColor = vec3(1.5,.9,.0);\n    \n    float dRocketBody = dfRocketBody(pos);\n    float dRocketFins = dfRocketFins(pos);\n    float dRocket = min(dRocketBody, dRocketFins);\n    \n    \n    float r = pow (length(pos.yz), 1.5);\n\n    vec3 normal = nf(pos);\n    \n    if (dfRocketBody(pos)<dfRocketFins(pos))\n    {\n        if (pos.x<-.85)\n            if (pos.x<-1.30)\n                materialColor = orangeColor + vec3(0.03 / r);\n            else\n                materialColor = vec3(.9,.1,.1);\n            else\n            {\n                if (pos.x>1.0)\n                    materialColor = vec3 (.6,.1,.1);\n                else\n                    materialColor = vec3(.6);\n            }\n    }\n    else\n    {\n        materialColor = vec3(.9,.1,.1);\n        if (length (pos - 0.1 * vec3(0.0, normal.yz)) > length (pos)) { \n\n            materialColor -= vec3(1.5,.9,.0) * min(0.0, pos.x + 1.3) / r;\n        }\n    }\n    \n    float ao = df(pos+normal*.125)*8.0 +\n        df(pos+normal*.5)*2.0 +\n    \tdf(pos+normal*.25)*4.0 +\n    \tdf(pos+normal*.06125)*16.0;\n    \n    ao=ao*.125+.5;\n    \n    if (dist<1.0) color = ao * materialColor;\n}\n\n// second, the beams from https://www.shadertoy.com/view/MllXDB\n\nconst float beam_half_side = 0.1, cell_side = 10.0, beam_side = beam_half_side * 2.0;\n\nvoid beams (inout vec3 color, in vec3 p, in vec3 d) {\n    p = mod (p + cell_side * 0.5, cell_side);\n    vec3 ad = abs(d), sd = sign(d), normal = vec3(0.0);\n    vec3 offsets = (0.5 * cell_side - beam_half_side) * (sd + 1.0) + beam_half_side;\n    vec2 test;\n    float closest_hit_distance = 1e2 * cell_side, ray_distance, step = cell_side / max (ad.x, max (ad.y, ad.z));\n    vec3 p1 = p, p2, dist;\n    float p1_to_p_distance = 0.0;\n    for (int i = 0; i < 10; i++) {\n        dist = (offsets - mod (p1, cell_side)) / d;\n        dist += 0.5 * (1.0 - sign (dist)) * cell_side / ad;\n\n        p2 = p1 + d * dist.x;\n        ray_distance = p1_to_p_distance + dist.x;\n        if (closest_hit_distance > ray_distance) {\n            test = mod (p2.yz + beam_half_side, cell_side);\n            if ((test.x < beam_side) || (test.y < beam_side)) {\n                closest_hit_distance = ray_distance;\n                normal = vec3 (-sd.x, 0.0, 0.0);\n            }\n        }\n\n        p2 = p1 + d * dist.y;\n        ray_distance = p1_to_p_distance + dist.y;\n        if (closest_hit_distance > ray_distance) {\n            test = mod (p2.xz + beam_half_side, cell_side);\n            if ((test.x < beam_side) || (test.y < beam_side)) {\n                closest_hit_distance = ray_distance;\n                normal = vec3 (0.0, -sd.y, 0.0);\n            }\n        }\n\n        p2 = p1 + d * dist.z;\n        ray_distance = p1_to_p_distance + dist.z;\n        if (closest_hit_distance > ray_distance) {\n            test = mod (p2.xy + beam_half_side, cell_side);\n            if ((test.x < beam_side) || (test.y < beam_side)) {\n                closest_hit_distance = ray_distance;\n                normal = vec3 (0.0, 0.0, -sd.z);\n            }\n        }\n\n        p1 += d * step;\n        p1_to_p_distance += step;\n    }\n\n    color = (vec3 (dot (normal, vec3(0.1, 0.2, 0.3))) * 0.5 + 0.5) * (cell_side / closest_hit_distance);\n\n    p1 = p + closest_hit_distance * d;\n    color *= mod (floor ((p1.x + p1.y + p1.z) * 4.0), 2.0) * 0.5 + 0.5;\n}\n\n// third, camera utility - this calculates ray direction in spaceship frame\n\nvec3 ray_dir (float fov, vec2 size, vec2 pos, float angle) {\n    vec2 xy = pos - 0.5 * size;\n\n    float cot_half_fov = tan ((90.0 - 0.5 * fov) * 0.01745329252);\t\n    float z = size.y * 0.5 * cot_half_fov;\n\n    vec3 dir = vec3 (xy, -z);\n    mat3 rot = mat3 (\n        vec3 (cos (angle), 0.0, -sin (angle)),\n        vec3 (        0.0, 1.0,          0.0),\n        vec3 (sin (angle), 0.0,  cos (angle))\n    );\n\n    dir = rot * dir;\n\n    #ifdef tilted\n    dir = vec3 (0.7071*(dir.x + dir.y), 0.7071*(dir.x - dir.y), dir.z);\n    #endif\n\n    return normalize (dir);\n}\n\n// stuff to show the speed (by unknown author at glslsandbox.com)\n\nfloat extract_bit(float n, float b);\nfloat sprite(float n, float w, float h, vec2 p);\nfloat digit(float num, vec2 p);\n\n// combining the shit together...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = 2.0 * pi * iMouse.x / iResolution.x;\n\n    // map 0 .. 1 to 0 .. ~0.95 with more detail in upper end\n    float velocity = (1.0 - exp (-pow (iMouse.y / iResolution.y, 0.7))) / 0.665;\n    \n    if (length (iMouse) == 0.0) {\n        float t = iTime;\n        if (iResolution.y < 200.0) t-= 10.0;\n        angle = -0.2 * t;\n        velocity = 0.85;\n    }\n    \n    // 1st, calculate how much distance did the spaceship travel in lattice frame\n    // in units where c = 1 we have:\n    // spaceship time ^2 - 0 ^2 = distant time ^2 - covered distance ^2\n    // and\n    // covered distance = velocity * distant time\n    // ergo...\n    float inverse_root = inversesqrt (1.0 - velocity * velocity);\n    float covered_dist = inverse_root * velocity * iTime;\n\n    // 2nd, pick the ray in spaceship frame\n    vec3 ray = ray_dir (75.0, iResolution.xy, fragCoord.xy, angle);\n\n    // 3rd, transform the ray to distant observer frame (aka Lorentz transformation)\n    // since the ray is normalized, its length divided by c is 1\n    vec3 transformed_ray = vec3 (ray.xy,\n         inverse_root * (ray.z + velocity));\n    \n    vec3 pos = vec3 (0.0, 0.0, -covered_dist);\n    transformed_ray = normalize (transformed_ray);\n\n    beams (fragColor.xyz, pos, transformed_ray);\n\n    // now let's add the rocket on top of it\n    pos.x = -5.0 * cos (angle);\n    pos.y =  2.1;\n    pos.z =  5.0 * sin (angle);\n    rotate (.5 * pi, ray.zx);\n    \n    vec3 r_color = vec3 (0.0);\n    rocket (r_color, pos, ray);\n    \n    if (length (r_color) > 0.0) {\n        fragColor.xyz = r_color;\n    }\n    \n    // finally, display the speed\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor.xyz += vec3 (\n\t\tsprite(2., 3., 5., floor (uv * vec2(64.0, 32.0) + vec2( 11.0 -64.0, -1.0))) +\n\t\tdigit(velocity * 10.0, floor (uv * vec2(64.0, 32.0) + vec2( 8.0 -64.0, -1.0))) +\n\t\tdigit(velocity * 100.0, floor (uv * vec2(64.0, 32.0) + vec2( 4.0 -64.0, -1.0)))\n    );\n}\n\n//returns 0/1 based on the state of the given bit in the given number\nfloat extract_bit(float n, float b)\n{\n\tn = floor(n);\n\tb = floor(b);\n\tb = floor(n/pow(2.,b));\n\treturn float(mod(b,2.) == 1.);\n}\n\nfloat sprite(float n, float w, float h, vec2 p)\n{\n\tfloat bounds = float(all(lessThan(p,vec2(w,h))) && all(greaterThanEqual(p,vec2(0,0))));\n\treturn extract_bit(n,(2.0 - p.x) + 3.0 * p.y) * bounds;\n}\n\n//3x5 digit sprites stored in \"15 bit\" numbers\n/*\nâ–ˆâ–ˆâ–ˆ     111\n  â–ˆ     001\nâ–ˆâ–ˆâ–ˆ  -> 111  -> 111001111100111 -> 29671\nâ–ˆ       100\nâ–ˆâ–ˆâ–ˆ     111\n*/\n\nfloat c_0 = 31599.0;\nfloat c_1 = 9362.0;\nfloat c_2 = 29671.0;\nfloat c_3 = 29391.0;\nfloat c_4 = 23497.0;\nfloat c_5 = 31183.0;\nfloat c_6 = 31215.0;\nfloat c_7 = 29257.0;\nfloat c_8 = 31727.0;\nfloat c_9 = 31695.0;\n\nfloat digit(float num, vec2 p)\n{\n\tnum = mod(floor(num),10.0);\n\t\n\tif(num == 0.0) return sprite(c_0, 3., 5., p);\n\tif(num == 1.0) return sprite(c_1, 3., 5., p);\n\tif(num == 2.0) return sprite(c_2, 3., 5., p);\n\tif(num == 3.0) return sprite(c_3, 3., 5., p);\n\tif(num == 4.0) return sprite(c_4, 3., 5., p);\n\tif(num == 5.0) return sprite(c_5, 3., 5., p);\n\tif(num == 6.0) return sprite(c_6, 3., 5., p);\n\tif(num == 7.0) return sprite(c_7, 3., 5., p);\n\tif(num == 8.0) return sprite(c_8, 3., 5., p);\n\tif(num == 9.0) return sprite(c_9, 3., 5., p);\n\t\n\treturn 0.0;\n}","name":"","description":"","type":"image"}]}