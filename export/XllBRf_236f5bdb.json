{"ver":"0.1","info":{"id":"XllBRf","date":"1512723971","viewed":584,"name":"shiny. spheres.","username":"dahart","description":"Spheres, shiny spheres, and even more and shinier spheres! A stack based recursive ray tracer. Scrub time with mouse.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["ray","spheres","recursive","tracing","shiny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// crank this up until your GPU chokes\nconst int nSpheres = 10; \n\n\nconst float sphereRadius = 3.0 / log2(float(nSpheres));\n\nconst float tau = 6.28318;\nconst float inf = 999.0;\n\nstruct Hit { \n    float t; \n    vec3 p; \n    vec3 n;\n    int id;\n};\n\nHit noHit;\n\nHit sphereHit(vec3 center, float radius, vec3 rayOrigin, vec3 rayDirection, int id) {\n    float a = dot(rayDirection, rayDirection);\n    vec3 L = rayOrigin - center;\n    float b = 2.0 * dot(rayDirection, L);\n    float c = dot(L, L) - radius*radius;\n    float discrim = b*b - 4.0*a*c;\n    if (discrim < 0.0) return noHit;\n    float t = (-b - sqrt(discrim)) / (2.0 * a);\n    if (t < 0.0) return noHit;\n    vec3 p = rayOrigin + t*rayDirection;\n    return Hit(t, p, normalize(p-center), id);\n}\n\nHit hitSomething(vec3 rayOrigin, vec3 rayDirection, float time) {\n    const float fns = float(nSpheres);\n\n    Hit minHit = noHit;\n\n    for (int i = 0; i < nSpheres; i++) {\n        float fi = float(i);\n        float fni = fi / fns;\n        float d = 3.0 * sin(time * fni + fi);\n        vec3 center = vec3(d*cos(tau*fni+time*10.0*fni)+sin(time*10.0), \n                       d*sin(tau*fni+time*10.0*fni), \n                       d*sin(0.5*tau*fni+time*fni*1.4142)+cos(time*10.0));\n        \n        Hit hit = sphereHit(center, sphereRadius + sphereRadius*2.0*pow(float(i%10)/10.0, 5.0), rayOrigin, rayDirection, 0);\n        if (hit.t <= 0.0 || hit.t > minHit.t) continue;\n        minHit = hit;\n    }\n\n    Hit hit = sphereHit(vec3(0.0, -41.5, 2.0), 40.0, rayOrigin, rayDirection, 1);\n    if (hit.t > 0.0 && hit.t < minHit.t) minHit = hit;\n\n    return minHit;\n}\n\nvec3 colorSomething(Hit hit, float time, vec3 rayOrigin, vec3 rayDirection, mat3x3 cam) {\n    if (hit.t > inf - 0.5) return vec3(0.0, 0.75+0.25*sin(time), 1.0);\n\n    vec3 color;\n\n    // diffuse\n    if (hit.id == 0) {\n        float dup    = 1.0 * dot(hit.n, cam[1]) + 0.0;\n        float dright = 1.0 * dot(hit.n, cam[0]) + 0.0;\n        float dfwd   = 1.0 * dot(hit.n, -cam[2] ) + 0.0;\n        color = vec3(dright, dup, dfwd);\n    } else if (hit.id == 1) {\n        float check = 0.4 + 0.6 * float(int(mod(hit.p.x, 2.0)) ^ int(mod(hit.p.z, 2.0)));\n        color = vec3(check, check, 0.1);\n    }\n\n    // specular\n    vec3 refl = reflect(rayDirection, hit.n);\n    float spec = pow(dot(refl, cam[1]), 20.0);\n    if (spec > 0.0) color += vec3(spec, spec, spec);\n\n    return color;\n}\n\nconst int maxDepth = 4;\nvec3 trace( mat3x3 cam, vec3 rayOrigin, vec3 rayDirection, float time )\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float ref = 1.0;\n    for (int i = 0; i < maxDepth; i++) {\n        Hit minHit = hitSomething(rayOrigin, rayDirection, time);\n        color += ref * colorSomething(minHit, time, rayOrigin, rayDirection, cam);\n        if (minHit.id < 0) break;\n        ref *= 0.6;\n        rayOrigin = minHit.p;\n        rayDirection = reflect(rayDirection, minHit.n);\n    }\n    color = color * 0.8;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 zero = vec3(0.0, 0.0, 0.0);\n    noHit = Hit(inf, zero, zero, -1);\n    \n    // make time optionally srubbable\n    float time = (iMouse.z > 0.0) ? iMouse.x / iResolution.x :  iTime / 20.0;\n\n    float camDist = 8.0;\n    vec3 rayOrigin = vec3(1.1*camDist*sin(tau * time * 0.5), 0.0, 0.9*camDist*cos(tau * time * 0.5));\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0, 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 fwd   = normalize(lookat - rayOrigin);\n    vec3 right = normalize(cross(fwd, up));\n    vec3 camup = normalize(cross(right, fwd));\n    vec3 rayDirection = normalize(fwd + 0.5 * (uv.x*right + uv.y*up));\n    \n    fragColor = vec4(trace(mat3x3(right, camup, fwd), rayOrigin, rayDirection, time), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}