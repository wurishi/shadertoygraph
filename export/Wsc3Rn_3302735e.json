{"ver":"0.1","info":{"id":"Wsc3Rn","date":"1567567769","viewed":293,"name":"Forest Tour","username":"Pyrolykos","description":"Demo of 3D fractal tree raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","demo","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mapping function approach:\n// We dynamically construct the closest branch of each tree, starting with\n// an initial root node, and then finding what \"quadrant\" of the world\n// we're in based on splitting planes, proceeding iteratively from there.\n// Assumes symmetry across splitting planes, or else could have weird\n// \"discontinuities\" along them.\n\n// 7 looks cool, but is pretty slow. Can change to 5 for slower computers.\n#define NUM_ITERS 6\n\n// Turns on mirror-water effect and shadows. Can disable for slower computers.\n#define SECOND_RAY\n\n// Little spheres for leaf-nodes. Positioning not right yet.\n// #define LEAF_SPHERES\n\n// Test if point is above or below the infinite plane defined by a planeCenter\n// (any point on plane) and the normal to the plane (pointing \"up\"/\"above\")\nbool abovePlane(vec3 point, vec3 planeCenter, vec3 normalDir) {\n    vec3 ray = point - planeCenter;\n    return dot(ray, normalDir) >= 0.0;\n}\n\n// Rotation fcn: rotAxis assumed to be normalized and origin-rooted\nvec3 rotateVec(vec3 v, vec3 rotAxis, float sinAngle, float cosAngle) {\n    return cosAngle*v + sinAngle*cross(rotAxis, v) + (1.0 - cosAngle)*dot(rotAxis, v)*rotAxis;\n}\n\nfloat sphereDist(vec3 pos, float r) {\n    return length(pos) - r;\n}\n\n// From iq's raymarching primitives website:\n// https://iquilezles.org/articles/distfunctions\nfloat ellipsoidDist(vec3 pos, float rad, float stretch) {\n    vec3 r = vec3(rad, stretch, rad);\n\tfloat k0 = length(pos/r);\n    float k1 = length(pos/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat groundDist(vec3 pos) {\n    // TODO: Add some soft hills\n    return pos.y + 1.3;\n}\n\n// Size of grid; initially was 5.0\n#define G 7.0\n\n// Fractal backtrace\nfloat backTrace(vec3 pos) {\n    // Assign unique id's to our GxG gridspaces\n    vec2 id = floor(pos.xz/G);\n    float fullId = 131.1*id.x+173.7*id.y;\n\n    // Spin the trees\n    vec3 boxRight = vec3(sin(fullId+iTime), 0.0, cos(fullId+iTime));\n    \n    // Repeat our trees every GxG\n    pos = vec3(mod(pos.x, G)/1.5-1.5, pos.y, mod(pos.z, G)/1.5-1.0);\n    \n    // Randomize our trees a bit\n    float offsetDelta = 0.40+.12*sin(fullId);\n    float ellipseSizeA = 0.09+.06*cos(fullId);\n    \n    // Didn't bother calculating; just eyeballed\n    float ellipseSizeB = 30.0*ellipseSizeA;\n    vec3 boxCenter = vec3(0.0, -offsetDelta-0.7-ellipseSizeA/3.0, 0.0);\n    \n    // Direction of box movement; starts pointing up\n    vec3 boxUp = vec3(0.0, 1.0, 0.0);\n    \n    float theta = 0.6+0.6*cos(iTime+fullId);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    const float scaleFactor = 0.70;\n    \n    float currScale = 1.0;\n    \n    float closestBoxDist = 1000.0;  // +inf\n    \n    vec3 relativePos;\n    for (int iters = 0; iters < NUM_ITERS; iters++) {\n        // Second splitting plane calculated\n        vec3 boxForwards = normalize(cross(boxUp, boxRight));\n\n        relativePos = pos - boxCenter;\n        mat3 m;\n        m[0] = boxRight;\n        m[1] = boxUp;\n        m[2] = boxForwards;\n        // Ortho, so transpose=inverse\n        m = transpose(m);\n        relativePos = m*relativePos;\n\n        // New node along our branch\n        closestBoxDist = min(closestBoxDist, ellipsoidDist(relativePos, ellipseSizeA*currScale, ellipseSizeB*offsetDelta));\n        \n\t\t// Current branch splits the world into quadrants; find our quadrant\n        bool upSplit = abovePlane(pos, boxCenter, boxRight);\n        bool rightSplit = abovePlane(pos, boxCenter, boxForwards);\n        \n        vec3 rotAxis;\n        // Find rotation axis based on quadrant splitting\n        if (upSplit) {\n            rotAxis = boxForwards;\n        } else {\n            rotAxis = -boxForwards;\n        }\n        if (rightSplit) {\n            rotAxis -= boxRight;\n        } else {\n            rotAxis += boxRight;\n        }\n        \n        rotAxis = normalize(rotAxis);\n        \n        // First move forwards in old direction\n        boxCenter += offsetDelta * boxUp;\n        \n        // Rotate\n        boxUp = rotateVec(boxUp, rotAxis, sinTheta, cosTheta);\n    \tboxRight = rotateVec(boxRight, rotAxis, sinTheta, cosTheta);\n\n        // And shrink\n        currScale *= scaleFactor;\n\n        offsetDelta *= scaleFactor;\n        // Move forwards after scaling in the new direction\n        boxCenter += offsetDelta * boxUp;\n    }\n    \n    // For little leaf-spheres\n#ifdef LEAF_SPHERES\n    closestBoxDist = min(closestBoxDist, sphereDist(relativePos-vec3(0.0,ellipseSizeA*1.5,0.0), ellipseSizeA*1.5*currScale));\n#endif\n    return closestBoxDist;\n}\n\nvec3 normal(vec3 pos) {\n    const vec2 e = vec2(0.0, 0.00001);\n    return normalize(vec3(backTrace(pos + e.yxx) - backTrace(pos - e.yxx),\n                          backTrace(pos + e.xyx) - backTrace(pos - e.xyx),\n                          backTrace(pos + e.xxy) - backTrace(pos - e.xxy)));\n}\n\nvec2 wavify(vec2 uv) {\n    uv = uv + 0.2*vec2(sin(5.0*(uv.y+iTime/5.0)), 0.0);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 sun_dir = normalize(vec3(0.5, 0.8, -0.5));\n    \n    // normalized pixel coords --> pixel ray\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(vec3(uv.xy, -1.5));\n    \n    // construct camera path\n    float zPos = 2.0-100.0*sin(iTime*6.0/100.0);\n    vec3 ro = vec3(2.0*cos(1.1*iTime), 1.0+1.5*sin(1.3*iTime), zPos);\n \n    // Raymarch\n    float t = 0.0;\n    vec3 pos;\n    for (int i = 0; i < 100; i++) {\n        pos = ro + t*rd;\n        float h = backTrace(pos);\n        \n        // Ground check\n        h = min(h, groundDist(pos));\n        \n        t += h;\n        \n        if (t > 25.0) break;\n    }\n\n    vec3 col;\n    if (t < 25.0) {\n        if (pos.y > -1.27) {\n\t\t\t// Hit a tree; rainbow color\n            vec2 id = floor(pos.xz/G);\n    \t\tfloat fullId = 11.1*id.x-17.3*id.y;\n        \tcol = vec3(sin(iTime+id.xy+1.5*pos.xy)/3.0+0.6, cos(iTime+id.x+id.y+1.5*pos.z)/3.0+0.6);\n\t\t\n        \t// Simple sunlight\n        \tfloat light = 0.7+0.7*clamp(dot(sun_dir, normal(pos)), 0.0, 1.0);\n        \tcol *= light;\n        } else {\n            // Ground\n            col = texture(iChannel0, vec2(pos.x, pos.z)/10.0).xyz+vec3(0.0,0.1,0.0);\n#ifdef SECOND_RAY\n            // March ray again, either back to sun for shadows (grass)\n            // or else forwards until it hits something for mirror (water)\n            vec3 spos;\n            t = 0.01;\n            vec3 ref_dir = sun_dir;\n            bool isWater = (sin(pos.z/2.0)+cos(pos.x/2.0)) >= 0.8;\n            if (isWater) {\n                ref_dir = vec3(rd.x, -rd.y, rd.z);\n               \t\n                // Cheap bumpy mirror; just use texture\n\t\t    \tref_dir += 0.2*col;\n                ref_dir = normalize(ref_dir);\n            }\n            for (int i = 0; i < 100; i++) {\n                spos = pos + t*ref_dir;\n                float h = backTrace(spos);\n                t += 0.9*h;  // for finer shadow details mid-expansion\n                if (t > 20.0) break;\n            }\n            if (!isWater) {\n            \tif (spos.y < 1.2) {\n                \t// shadow\n                \tcol *= 0.75;\n                }\n            } else {\n                // mirrored tree\n                if (spos.y < 1.2) {\n                    // just use spos color!\n                    vec2 id = floor(spos.xz/G);\n\t\t    \t\tfloat fullId = 11.1*id.x-17.3*id.y;\n        \t\t\tcol = vec3(sin(iTime+id.xy+1.5*spos.xy)/3.0+0.6, cos(iTime+id.x+id.y+1.5*spos.z)/3.0+0.6);\n        \n\t\t        \t// sunlight\n\t\t        \tfloat light = 0.7+0.7*clamp(dot(sun_dir, normal(spos)), 0.0, 1.0);\n\t\t        \tcol *= light;\n                    col *= 0.7;\n                } else {\n                    // mirrored sky\n                    uv = wavify(uv);\n                    col = vec3(0.13,0.13,0.2)+vec3(0.1, 0.1, 0.2) * texture(iChannel1, vec2(uv.x, uv.y)/3.0).rgb;\n                }\n            }\n#endif\n        }\n        // Hacky distance fog\n    \tcol *= 1.0-(ro.z-pos.z)*(ro.z-pos.z)/500.0;\n    } else {\n    \t// Sky\n        uv = wavify(uv);\n\t\tcol = vec3(0.2, 0.2, 0.4) * texture(iChannel1, vec2(uv.x, uv.y)/3.0).rgb;\n    }\n        \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}