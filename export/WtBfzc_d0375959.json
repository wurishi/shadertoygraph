{"ver":"0.1","info":{"id":"WtBfzc","date":"1599774338","viewed":143,"name":"Marching Spines","username":"j91000","description":"An infinite ocean of.. somethings. Click and drag to move the camera around.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//render settings\n#define STEPSHRINK 5.0 //increase this value to deal with distance field domain distortion artifacts\n#define MAXSTEPS 5000\n#define CAMDIST 150.\n#define TARGET vec3(0,0.,0);\n#define CAMSTRT vec2(-pi/4.,0.)\n\n#define HITDIST 1.e-1\n#define MAXDIST 1000.\n\n//misc\n#define pi atan(1.0) * 4.0\n#define ZERO min(iFrame,0)\n#define PLANEH -0.\n\n//light and shadow\n#define AMBIENT 0.15 \n#define SUNLIGHT vec3(.7,.6,.5)*.61\n#define FOGDIST .1e-2\n#define FOGCOL vec3(.7,.7,.85)\n\n#define SHADQUAL .8\n#define SHADSMOOTH 20.\n#define SPECULARPOWER 5.\n//ambient occlusion\n#define AO 1. //comment this line to disable ambient occlusion\n#define AODIST 1.8\n#define AOSTEPS 5\n#define AOPOW 2.\n\n\nstruct CastResult\n{\n    vec3 ori;\n    vec3 pos; //hit location\n    vec3 norm; //surface normal\n    vec3 surf; //surface material/albedo\n};\n    \nstruct DirLight\n{\n  \tvec3 dir; //light direction vector\n    vec3 col; //light color*intensity\n};\nstruct MapResult\n{\n    float dist;//distance to scene\n    vec3 color;//surface material color\n    bool volume;//false for the floor, controls coloration in primaryRay()\n};\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a3));   \n}\n//generates a rotation matrix that rotates (0,0,1) to face in the same\n//direction as dir.\nmat3 camRotation(vec3 dir){\n    dir=normalize(dir);\n    float xRot=atan(dir.z,dir.x)-pi/2.;\n    float yRot=atan(dir.y,length(dir.xz));\n    return Rotate(vec3(xRot,yRot,0));\n}\n//-------------------------------------------------\n\nvec4 elongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\nMapResult sdUnion(MapResult a,MapResult b){\n    if(a.dist<b.dist){return a;}\n    return b;\n}\nMapResult sdSub(MapResult a,MapResult b){\n    b.dist*=-1.;\n    if(a.dist>b.dist){return a;}\n    return b;\n}\n//signed distance/material for the floor\nMapResult sdPlane(vec3 pos){\n    return MapResult(pos.y-PLANEH,vec3(.05,.05,.05),false);\n}\n//signed distance/material for the repeated capsule.\n#define RECURSION 0\nMapResult sdVBall(vec3 pos){\n    \n    vec3 c=vec3(3.2,0.,45.);//this is the repetition period in each axis\n    pos.z+=10.*sin(sin(pos.z/100.)*10.+pos.x/10.);//add some warpage to the z dimension\n    vec2 op=pos.xz;//record the world xz location\n    pos= mod(pos+0.5*c,c)-0.5*c;//fold space a bunch\n    op=op-pos.xz;//this makes op into just the cell location, it stays constant inside each cell\n    //pos.xyz=pos.xyz*Rotate(0.,0.,.4*sin(length(op)/4.+iTime/5.));//rotate the cells relative each other\n    pos.y-=sin(length(op)/1.);//make sure the forms jut up, not up+down.\n    float fac=1.+2.*sin(iTime+length(op)/4.);\n    pos.y-=fac;\n    vec4 ePos=elongate(pos,vec3(0.,fac,fac/3.));\n    \n    float size=1.;\n    MapResult result=MapResult(ePos.w+length(ePos.xyz)-size,vec3(.2,.05,.05),true);\n    return result;\n}\n\n\n//calculate the distance to scene/ material properties of closest object\nMapResult map(vec3 pos){\n    MapResult plane=sdPlane(pos);\n    MapResult result=sdVBall(pos);\n    result=sdUnion(result,plane);\n    return result;\n}\n//same as map, but throw away everything but distance\nfloat distToScene(vec3 pos){\n return map(pos).dist;   \n}\n//calculate the norm by sampling the distance field around pos\n//lifted from an iq raymarcher\nvec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*distToScene(pos+0.005*e);\n    }\n    return normalize(n);\n}\n\n//clever ambient occlusion trick described here:\n//https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 pos,vec3 normal,float sampleDist,float aoPower){\n    #ifdef AO\n    float occlusion=0.;\n    float itC=0.;\n    for(int i=1;i<AOSTEPS;i++){\n     itC++;\n     float term=itC*sampleDist-distToScene(pos+normal*sampleDist*itC);\n        occlusion+=1./pow(2.,itC)*term;\n    }\n    return 1.-clamp(aoPower*occlusion/sampleDist,0.,1.);\n    #else\n    return 1.;\n    #endif\n}\nfloat ambientOcclusion(vec3 pos,vec3 normal,float sampleDist){\n    return ambientOcclusion(pos,normal,sampleDist,AOPOW);\n}\n\n//cast a new ray from surface.pos and see if you hit anything \n//on your way to sun\nfloat occlusion(CastResult surface,DirLight sun){\n    vec3 rayOri=surface.pos+surface.norm*HITDIST*2.;//the ray starts from just above the surface of the hit.\n    vec3 rayPos=rayOri;\n    bool hit=false;\n    float result=1.;\n    for(int steps=ZERO;steps<MAXSTEPS&&(!hit)&&length(rayPos-rayOri)<MAXDIST;steps++){\n        MapResult localState=map(rayPos);\n        float dts=localState.dist;\t//calculate distance to scene\n        hit=dts<HITDIST;\n        result=min(result,SHADSMOOTH*dts/length(rayPos-rayOri));//if close to a surfce, cast a penumbra\n        rayPos-=sun.dir*dts/STEPSHRINK*SHADQUAL;//march\n    }\n    result=hit ? 0.:result; //if you registered a hit, then no light for you!\n    return result; //otherwise return the darkest penumbra you encountered\n}\n\nCastResult primaryRay(vec3 rayOri,vec3 rayVec){\n    \n    bool hit=false;\n    vec3 rayPos=rayOri;\n    MapResult localState;\n    //the conditions here signal to break out of the loop whenever:\n    //\t\tsteps taken exceeds MAXSTEPS; nothing was hit\n    //or\tthe ray's length exceeds MAXDIST; nothing was hit\n    //or\tthe hit flag signals a collision\n    for(int steps=ZERO;steps<MAXSTEPS&&length(rayPos-rayOri)<MAXDIST&&hit==false;steps++){\n        localState=map(rayPos);//get local conditions at rayPos\n        float dts=localState.dist;//extract scene distance\n        hit=dts<HITDIST;\t\t\t  //register a hit, if the distance is small\n        rayPos+=hit ? vec3(0.):rayVec*dts/STEPSHRINK;//march the ray unless theres a hit\n    }\n    vec3 norm=calcNorm(rayPos);\n    vec3 surfCol=localState.color;\n\n    //return a CastResult struct\n    return CastResult(rayOri,rayPos,norm,surfCol);\n}\n\n\n//calculate the light hitting this castResult from sun and ambient light\nvec3 lightOn(CastResult hit,DirLight sun){\n    float difLight=max(0.,(-dot(hit.norm,sun.dir)));\n    #ifdef SPECULARPOWER //if SPECULARPOWER is commented out, lighting is diffuse only\n    float specLight=SPECULARPOWER*\n        pow(max(0.,dot(reflect(sun.dir,hit.norm),normalize(hit.ori-hit.pos))),100.);\n    vec3 sunLight=(difLight+specLight)*sun.col*occlusion(hit,sun);\n    #else\n    vec3 sunLight=(difLight)*sun.col*occlusion(hit,sun);\n    #endif\n    vec3 ambientLight=vec3(AMBIENT*ambientOcclusion(hit.pos,hit.norm,AODIST));\n    return (sunLight+ambientLight);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Set up the camera\n    vec2 mousePos=(length(iMouse.xy)>0.)? iMouse.xy/iResolution.xy-.5:CAMSTRT;\n    float mouseTheta=mousePos.x*2.*pi;\n    float mouseH=mousePos.y*130.+19.;\n    vec3 camPos=vec3(cos(mouseTheta)*CAMDIST,mouseH,CAMDIST*sin(mouseTheta));\n    vec3 camTarget=TARGET;\n    vec3 camOff=vec3(iTime*3.+1000.,1.,1000.);\n    camPos+=camOff;\n    camTarget+=camOff;\n//set up lighting\n    DirLight sun;\n    sun.dir=normalize(vec3(1,-.2,0.))*Rotate(vec3(10./5.,0,0));\n    sun.col=SUNLIGHT;\n    \n//set up camera ray\n//\n//in the middle of the screen, uv.xy ==(0,0),\n//so the rotation matrix that rotates (0,0,1) to normalize(camTarget-camPos)\n//will point our rays towards camTarget\n    mat3 rayRotation=camRotation(camTarget-camPos);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 rayVec=normalize(vec3(uv.x,uv.y,1.)*rayRotation);\n    \n    \n    \n    vec3 rayOri=camPos;\n\n    CastResult cRay=primaryRay(rayOri,rayVec);\n    float fog=1.-exp(-length(cRay.pos-cRay.ori)*FOGDIST);\n    vec3 finalC;\n    vec3 fogColor=FOGCOL;\n    fogColor+=sun.col*pow(max(0.,dot(-sun.dir,rayVec)),6.);\n    if(fog<.99){\n    bool inBounds=length(cRay.pos-rayOri)<MAXDIST*.999;\n    finalC=inBounds?lightOn(cRay,sun)*cRay.surf:fogColor;\n    finalC=mix(finalC,fogColor,fog);//FOG APPLICATION\n    }\n    else{finalC=vec3(fogColor);}\n    finalC=pow(finalC,vec3(1./2.2));//GAMMA CORRECT\n    fragColor = vec4(finalC,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}