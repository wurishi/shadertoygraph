{"ver":"0.1","info":{"id":"ls2fRV","date":"1501285786","viewed":385,"name":"escape from cyberspace","username":"SudoNhim","description":"I made this by mistake but thought it looked kinda neat","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["voxels","accident"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Some code swiped and mangled from fb39ca4 :)\n\nconst int MAX_RAY_STEPS = 17;\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    screenPos.y += 0.01;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n    rayDir = normalize(rayDir);\n\tvec3 rayPos = vec3(0.5*sin(iTime * 0.17), 0.5 * sin(iTime * 0.23), 0.5 * sin(iTime * 0.3));\n    rayPos += 1.5;\n    rayPos.z += iTime*5.0;\n\trayDir.xz = rotate2d(rayDir.xz, 0.5+0.3*sin(iTime*0.2));\n    \t\n    // This is just the basic voxel marching setup used throughout shadertoy, developed by fb39ca4 and others\n\tvec3 mapPos = vec3(floor(rayPos));\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\tvec3 rayStep = sign(rayDir);\n\tvec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\tvec3 mask;\n    \n    // Additionally, keep track of...\n    int spacefilling=0; // How many empty voxels were marched through\n    bool filled=false;  // Was the final voxel filled\n    float dist = 0.0; float ddist = 1.0;\n    \n    // This is the only loop\n    // The steps taken will be some mix of:\n    //    a] Step forwards into an empty voxel\n    // and\n    //    b] Move down the hierarchy of the menger\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n        mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n        \n        // This checks the current map position to see if it intersects the menger\n        ivec3 relPos = ((ivec3(mapPos)+3333) % 3)-1;\n        bvec3 bb= bvec3(relPos);\n        bool b2 = false; //(int(mapPos.z) + int(mapPos.x) % 17) % 21 == 0;\n        bool isHit = (!bb.x && !bb.y) || (!bb.y && !bb.z) || (!bb.x && !bb.z) || b2;\n        \n        if (!isHit) { // No intersect - march forward one voxel\n            sideDist += mask * deltaDist;\n            mapPos += mask * rayStep;\n            \n            spacefilling++;\n            filled=true;\n            dist += ddist;\n            \n            ivec3 esc = ivec3(mask*sign(rayDir))*relPos;\n            if (esc.x + esc.y + esc.z > 0) {\n\n                // Set the new ray origin just slightly back of where the voxel would have been hit\n                rayPos = dot(mask, sideDist-sign(rayPos)*0.001)*rayDir + rayPos;\n\n                    // Scale ray origin up by 3x. This is equivalent to moving down-hierarchy\n                rayPos /= 3.;\n\n\n                // Reset the voxel marching\n                mapPos = vec3(floor(rayPos));\n                sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n                \n                ddist *= 2.0;\n            }\n            \n    \t} else {// Intersect - move down-hierarchy instead of marching forward\n\t\t\t\n            // Set the new ray origin just slightly back of where the voxel would have been hit\n            rayPos = dot(mask, sideDist-sign(rayPos)*0.001)*rayDir + rayPos;\n            \n            // Scale ray origin up by 3x. This is equivalent to moving down-hierarchy\n            rayPos *= 3.;\n            \n            // Reset the voxel marching\n            mapPos = vec3(floor(rayPos));\n            sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n            \n            filled = false;\n            ddist *= 0.5;\n        } \n\t}\n\t\n    if (!filled) spacefilling++;\n    float f = float(spacefilling)/float(MAX_RAY_STEPS); \n\tfloat brightness = pow(0.85, dist);\n    vec3 color = vec3(sin(float(f)*2.33), 1.0, cos(float(f)*4.0));\n    color.r = 0.5 + 0.5*sin(f*20.0);\n    color.g = 0.5 + 0.5*cos(f*20.0);\n    color.b = 5.0*dist/float(MAX_RAY_STEPS);\n\n\tfragColor.rgb = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb*0.8 + 0.25*color*brightness;\n}","name":"Buf A","description":"","type":"buffer"}]}