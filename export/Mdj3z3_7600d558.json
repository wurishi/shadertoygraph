{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct sphere_t\n{\n    vec3 position;\n    float radius;   \n};\n\n\nstruct ray_t\n{\n    vec3 origin;\n    vec3 direction;   \n};\n\t\n\nstruct plane_t\n{\n    vec3 normal;\n\tvec3 orientation;\n    float offset;   \n};\n\t\nstruct light_t{\n\tvec3 direction;\n\tfloat contribution;\t\n};\n\nstruct surface_t{\n\tint identifier;\n\tvec3 normal;\t\n};\n   \nconst float max_distance = 1e5;\n\n\nfloat intersect_sphere(const in ray_t ray,const in sphere_t sphere)\n{\n   \n    float a = (ray.direction.x * ray.direction.x)\n            +(ray.direction.y * ray.direction.y)\n            +(ray.direction.z* ray.direction.z);\n   \n    float b = ((ray.origin.x-sphere.position.x)*ray.direction.x)\n            +((ray.origin.y-sphere.position.y)*ray.direction.y)\n            +((ray.origin.z-sphere.position.z)*ray.direction.z);\n   \n    b *= 2.0;\n\n    float c = ((ray.origin.x-sphere.position.x) * (ray.origin.x-sphere.position.x))\n            +((ray.origin.y-sphere.position.y) * (ray.origin.y-sphere.position.y))\n            +((ray.origin.z-sphere.position.z) * (ray.origin.z-sphere.position.z)) - (sphere.radius*sphere.radius);\n   \n    float delta = b*b - (4.0*a*c);\n   \n    if(!(delta < 0.0)){\n        float dist = (-b + sqrt(delta))/(2.0*a);\n        float dist2 = (-b - sqrt(delta))/(2.0*a);\n        return    min(dist,dist2);\n    }\n    else\n    {   \n        return max_distance;\n    }\n   \n}\n\nfloat intersect_plane(const in ray_t ray,const in plane_t plane)\n{\t\n\tfloat a = plane.normal.x;\n\tfloat b = plane.normal.y;\n\tfloat c = plane.normal.z;\n    float result = -(plane.offset+ a*ray.origin.x + b*ray.origin.y+c*ray.origin.z)/(a*ray.direction.x+b*ray.direction.y+c*ray.direction.z);\n    if(result > 0.0){\n\t\treturn   result;\n\t}\n    else\n    {   \n        return max_distance;\n    }\n   \n}\n\nfloat intersect(const in ray_t ray, out surface_t surface){\n\tsphere_t sphere;\n    sphere.position = vec3(0.0,0.5,0.0);\n    sphere.radius = 0.5;  \n\t\n\tplane_t plane;\n\tplane.normal =vec3(0.0, 0.9, 0.04);\n\tplane.offset= 0.1;\n\t\n\tfloat minGlobal = min( intersect_plane(ray, plane), intersect_sphere(ray, sphere));\n\t\n\tif(minGlobal == max_distance){\n\t\tsurface.identifier =0;\n\t\tsurface.normal= vec3(0.0, 0.0, 0.0);\n\t}else if(minGlobal == intersect_plane(ray, plane)){\n\t\tsurface.identifier =1;\n\t\tsurface.normal =plane.normal;\n\t}else if(minGlobal == intersect_sphere(ray, sphere)){\n\t\tsurface.identifier =2;\n\t\tvec3 position_surface = ray.origin+ minGlobal*ray.direction;\n\t\tsurface.normal =position_surface - sphere.position;\n\t}\t\n\treturn minGlobal;\n\t\t\n}\n\nvoid light_information(out light_t light){\n\tlight.direction = vec3(2.0,4.0, 0.0);\n\tlight.contribution = 1.0;\t\n}\n\nfloat illumination(ray_t ray, const in surface_t surface, const in light_t light){\n\tfloat diffuse = max(0.0, dot(surface.normal, light.direction));\n\tvec3 reflected =normalize(reflect(ray.direction, surface.normal));\n\tfloat specular = max(0.0, dot(reflected,surface.normal)); \n\treturn\tdiffuse;//*light.contribution + pow(specular, 1.5);\n}\n\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coordonate = fragCoord.xy/iResolution.xy;\n    vec2 screen_coordonate_centered = 2.0 * screen_coordonate -1.0;\n\t\n\tfloat aspect_ratio = iResolution.x/iResolution.y;\n\tvec2  screen_coordonate_cor = vec2(aspect_ratio, 1.0)*screen_coordonate_centered;\n   \n    ray_t primary_ray;\n    primary_ray.origin = vec3(0.0, 0.0,mix(1.5,3.0,0.5+0.5*sin(iTime)));\n    primary_ray.direction = normalize(vec3(screen_coordonate_cor,-1.5));\n   \n    surface_t surface;\n    float distance_from_origin = intersect(primary_ray, surface);\n\t//*\n    if(distance_from_origin < max_distance && surface.identifier!=0)\n    {\n\t\tlight_t light;\n\t\tlight_information(light);\n\t\tfloat res =  illumination(primary_ray, surface, light);\n        vec3 color =vec3(res,res,res);\n\t\tfragColor = vec4(color,1.0);\n    }\n    else\n    {\n        const vec3 background_color = vec3(0.0,0.0,0.0);\n        fragColor = vec4(background_color,1.0);       \n    }//*/\n       \n       \n       \n   \n    //fragColor = vec4( abs(primary_ray.direction),1.0);\n   \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdj3z3","date":"1391870835","viewed":162,"name":"ray tracing I3","username":"Gilles","description":"plan and sphere and light with ray tracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}