{"ver":"0.1","info":{"id":"wlf3Dn","date":"1556082375","viewed":153,"name":"Opposite Mirror: FBM Pattern","username":"takumifukasawa","description":"Opposite Mirror: FBM Pattern","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fbm","mirror","oppositemirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//-----------------------------------------------------------\n// fbm ref.\n// https://thebookofshaders.com/13/?lan=jp\n// https://iquilezles.org/articles/warp\n//-----------------------------------------------------------\n\n#define EPS 0.0001\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n#define DBL_MAX 1.7976931348623158e+308\n#define DBL_MIN 2.2250738585072014e-308\n\nprecision highp float;\n\nconst int num = 16;\nvec2 textureScale = vec2(1.);\nvec2 textureOffset = vec2(0.);\nvec2 parallaxScale = vec2(0.); // if use parallax with mouse, set value rather than 0.\nfloat speed = 1.2;\nfloat scaleStep = .66;\n\nfloat bs = 0.; // border size\n\nvec3 oppositeMirror(vec2 coord, vec2 mouse) {\n\tvec3 st = vec3(0.); // dist uv\n\n    vec3 np = vec3(0.);\n\tvec3 nn = vec3(0.);\n\tvec3 nf = normalize(vec3(mouse, 0.));\n\tvec3 center = vec3(0.);\n\tvec3 v = nn - (-nf);\n    // v = normalize(v);\n    // vec3 v = vec3(0.);\n\n\tfloat ts = iTime * speed;\n\tfloat t = mod(ts, 1.f); // 0 - 1\n\n\t// highp int n = int(num);\n    int n = num;\n\n\tfor(int i=0; i<n; i++) {\n\t\tfloat si = mix(float(i) - 2., float(i) - 3., t); // margin for parallax\n        \n\t\tvec3 po = v;\n\t\tpo.z *= -1.;\n        \n\t\tvec2 m = po.xy * parallaxScale * (1.f - si / float(n));\n  \t\t//vec2 m = vec2(-0.); // debug: off parallax\n  \t\tvec2 rd = 1. / textureScale;\n\n\t\tvec2 uv = coord - textureOffset;\n\n\t\tuv *= 1. / pow(scaleStep, si);\n\t\t// centering offset \n\t\tfloat sc = pow(1. / scaleStep, si) - 1.;\n\t\tuv += rd * -.5 * sc + rd * m * - .5;\n  \t\tif(\n    \t\t0. <= uv.x\n    \t\t&& rd.x >= uv.x\n    \t\t&& 0. <= uv.y\n   \t\t \t&& rd.y >= uv.y\n  \t\t) {\n    \t\tst.xy = uv;\n            st.z = si;\n            // flip\n    \t\tfloat ft = mod(floor(ts), 2.);\n    \t\tint fi = int(step(.5, ft));\n            if(mod(float(i), 2.) == float(fi)) {\n                st.x = rd.x - st.x;\n            }\n        } else {\n            break;\n        }\n\t}\n\n\treturn st; \n}\n\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm(in vec2 st) {\n  float value = 0.;\n  float amp = .44;\n      \n  for(int i = 0; i < OCTAVES; i++) {\n    value += amp * noise(st);\n    st *= 2.3;\n    amp *= .44;\n  }\n  return value;\n}\n\nfloat pattern(in vec2 p) {\n  float f = 0.;\n  vec2 q = vec2(\n    fbm(p + iTime * .15 + vec2(0.)),\n    fbm(p + iTime * .05 + vec2(2.4, 4.8))\n  );\n  vec2 r = vec2(\n    fbm(q + iTime * .1 + 4. * q + vec2(3., 9.)),\n    fbm(q + iTime * .2 + 8. * q + vec2(2.4, 8.4))\n  );\n  f = fbm(p + r * 2. + iTime * .1);\n  return clamp(f, 0., 1.);\n}\n\nvec3 gradient(float v, float i) {\n\t//v += i * .1;\n    //vec3 r = vec3(random(vec2(i, i)), random(vec2(i, i)), random(vec2(i, i)));\n    float steps = 4.;\n\tfloat s = 1. / steps;\n    vec3 col = vec3(0.);\n\n    // base colors\n    vec3 c1 = vec3(255. / 255.,  255. / 255.,  255. / 255.);\n\tvec3 c2 = vec3(53. / 255.,  185. / 255.,  208. / 255.);\n    vec3 c3 = vec3(0. / 255.,  128. / 255.,  209. / 255.);\n\tvec3 c4 = vec3(233. / 255., 233. / 255., 215. / 255.);\n    vec3 c5 = vec3(230. / 255.,  244. / 255.,  241. / 255.);\n\n\tif(v >= 0. && v < s) {\n  \t\tcol = mix(c1, c2, v * steps);\n\t} else if (v >= s && v < s * 2.) {\n  \t\tcol = mix(c2, c3, (v - s) * steps);\n\t} else if (v >= s * 2. && v < s * 3.) {\n    \tcol = mix(c3, c4, (v - s * 2.) * steps);\n    } else {\n        col = mix(c4, c5, (v - s * 3.) * steps);\n\t}\n    col += sin((iTime * .95) * vec3(\n        sin(iTime * .03 + .2) * .5 + .5,\n        sin(iTime * .03 + .8) * .5 + .5,\n        sin(iTime * .03 + 1.4) * .5 + .5\n    )) * .2;\n    \n    float n = float(num);\n  \treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n\tvec3 om = oppositeMirror(uv, mouse);\n\t\n    uv.xy = om.xy;\n    \n\tvec3 color = gradient(pattern(uv), om.z);\n    \n    float border = 0.;\n    border += 1. - step(bs, uv.x) * (1. - step(1. - bs, uv.x));\n    border += 1. - step(bs * aspect, uv.y) * (1. - step(1. - bs * aspect, uv.y));\n    border =  clamp(border, 0., 1.);\n    \n    color = mix(color, vec3(1.), border);\n\n    //color = vec3(border);\n    \n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}