{"ver":"0.1","info":{"id":"fdcczn","date":"1666921860","viewed":170,"name":"Weird Pixellation stuff","username":"WhiteWalrus518","description":"uhhh","likes":3,"published":1,"flags":2,"usePreview":0,"tags":["pixels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int range = 3;\nfloat animateScale;\nfloat animateSpeed;\n\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nvec2 randomSpin(vec2 p){\n    return animateScale * vec2(\n    cos( animateSpeed * (iTime * 3.14159 * sign(random2(p).y - 0.5) + random2(p).x * 3.14159) * random2(p + random2(p).x).x), \n    sin( animateSpeed * (iTime * 3.14159 * sign(random2(p).x - 0.5) + random2(p).y * 3.14159) * random2(p + random2(p).y).y));\n}\n\nvec4 SimplePix(vec2 uv, float pixH ){\n    vec2 pixInt = fract(uv * pixH);\n    vec2 pixExt = floor(uv * pixH);\n    pixExt += vec2(0.5);\n    pixExt = pixExt / pixH;\n    pixExt.x = pixExt.x * iResolution.y / iResolution.x ;\n    \n    return texture(iChannel0, pixExt);\n}\n\nvec4 CirclePix(vec2 uv, float pixH ){\n    vec4 textPix = SimplePix(uv, pixH);\n    vec2 pixInt = fract(uv * pixH);\n    \n    float distToC = length(pixInt - 0.5);\n    \n    if(distToC < 0.5){return textPix;}\n    return vec4(0.0);\n}\n\nvec4 InvCirclePix(vec2 uv, float pixH ){\n    vec4 textPix = SimplePix(uv, pixH);\n    vec2 pixInt = fract(uv * pixH);\n    \n    float distToC = length(pixInt - 0.5);\n    \n    if(distToC < 0.25){return vec4(0.0);}\n    return textPix;\n}\n\nvec4 WeirdLightingThing(vec2 uv, float pixH ){\n    vec4 textPix = SimplePix(uv, pixH);\n    vec2 pixInt = fract(uv * pixH);\n    \n    vec3 color = normalize(textPix.xyz) * 0.5;\n    float br = length(textPix.xyz) * 0.5;\n    \n    float distToC = length(pixInt - 0.5);\n    \n    if(distToC < 0.3){return vec4(br);}\n    return vec4(color, 0);\n}\n\nvec4 VoronoiPixelation(vec2 uv, float pixH ){\n    vec2 pixInt = fract(uv * pixH);\n    vec2 pixExt = floor(uv * pixH);\n    float m_dist = 10.0;\n    vec2 relClos = vec2(0.0);\n    vec2 relRot;\n\n    for (int y= -range; y <= range; y++) {\n        for (int x= -range; x <= range; x++) {\n            vec2 neighbor = vec2(float(x),float(y));\n\n            vec2 point = random2(pixExt + neighbor);\n            relRot = randomSpin(pixExt + neighbor)* animateScale;\n            vec2 diff = neighbor + relRot + point - pixInt;\n            float dist = length(diff);\n            if(dist < m_dist){\n                m_dist = dist;\n                relClos = neighbor;\n            }\n        }\n    }\n    vec2 nPoint = pixExt + relClos + randomSpin(pixExt + relClos) + random2(pixExt + relClos);\n    nPoint = nPoint / pixH;\n    nPoint.x = nPoint.x * iResolution.y / iResolution.x ;\n    \n    vec2 st;\n    st.x = uv.x *iResolution.y / iResolution.x;\n    st.y = uv.y;\n    //if(length(nPoint - st) < 0.001){return vec4(0.9, 0.69, 0.72, 1.0);}\n    return texture(iChannel0, nPoint);\n}\n\nvec4 VoronoiPixelation2(vec2 uv, float pixH ){\n    vec2 pixInt = fract(uv * pixH);\n    vec2 pixExt = floor(uv * pixH);\n    float m_dist = 10.0;\n    vec2 relClos = vec2(0.0);\n    vec2 relRot;\n\n    for (int y= -range; y <= range; y++) {\n        for (int x= -range; x <= range; x++) {\n            vec2 neighbor = vec2(float(x),float(y));\n\n            vec2 point = random2(pixExt + neighbor);\n            vec2 relRot = randomSpin(pixExt + neighbor) * animateScale;\n            vec2 diff = neighbor + relRot + point - pixInt;\n            float dist = length(diff);\n            if(dist < m_dist){\n                m_dist = dist;\n                relClos = neighbor;\n            }\n        }\n    }\n    vec2 nPoint = pixExt + relClos + random2(pixExt + relClos);\n    nPoint = nPoint / pixH;\n    nPoint.x = nPoint.x * iResolution.y / iResolution.x ;\n    \n    return texture(iChannel0, nPoint);\n}\n\nvec4 TrianglePix(vec2 uv, float pixH){\n    float trih = 0.8660; // triangle height\n    vec2 tric; // tri coordinates\n    vec2 local;\n    \n    local = vec2(fract(uv.x * pixH), fract(uv.y * pixH / trih * 0.5));\n    \n    tric.y = 2.0 * floor(uv.y * pixH / trih * 0.5);\n    \n    tric.x = 2.0 * floor(uv.x * pixH);\n    \n    \n    if(0.5 < local.y ){\n        tric.y += 1.0;\n    }\n    if(local.y < local.x ){\n        tric.x += 1.0;\n    }\n    if(1.0 - local.x < local.y){\n        tric.x += 1.0;\n    }\n    \n    vec2 samplePos;\n    \n    samplePos.x = tric.x * 0.5* iResolution.y / iResolution.x;\n    samplePos.y = tric.y * trih;\n    \n    samplePos = samplePos / pixH;\n    \n    \n    vec4 modcam = texture(iChannel0, samplePos);\n    \n    float rand = random2(samplePos).x;\n    rand = 1.0 - animateScale + animateScale*sin(iTime * rand  + random2(samplePos).y) * rand;\n    \n    //if(length(uv - samplePos) < 0.001){return vec4(0.9, 0.5, 0.2, 0.0);}\n    \n    return modcam * rand;\n}\n\nvec4 QuantizedRotate(vec2 uv, float pixH ){\n    vec2 st;\n    vec2 newPI;\n    vec2 pixInt = fract(uv * pixH);\n    vec2 pixExt = floor(uv * pixH);\n    newPI = pixInt;\n    newPI = 1.0 - newPI;\n    \n    st = pixExt + newPI;\n    \n    st = st / pixH;\n    st.x = st.x * iResolution.y / iResolution.x ;\n    \n    return texture(iChannel0, st);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    animateScale = 0.5;\n    animateSpeed = 2.0;\n    \n    vec2 uv = fragCoord / iResolution.y;\n    uv.x = iResolution.x/ iResolution.y - uv.x;\n    \n    \n    float pixH = 100.0;\n    \n    vec3 col = VoronoiPixelation2(uv,pixH).xyz;\n    \n    //if(sin(iTime * 0.5) > 0.0){col = texture(iChannel0, vec2(uv.x * iResolution.y / iResolution.x, uv.y)).xyz;}\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}