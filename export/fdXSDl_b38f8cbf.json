{"ver":"0.1","info":{"id":"fdXSDl","date":"1619403460","viewed":96,"name":"Sphere raymarching","username":"ddpms","description":"basic raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\nconst float EPS = 0.001;\nconst float MAX = 100.;\n\n// rotate\nmat2 rot(float a){\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\n// Sphere SDF\nfloat sphere(vec3 pos){\n    vec3 loc = vec3(0.);\n    float rad = 1.5;\n    return length(pos-loc) - rad;\n}\n\n// BOX SDF\nfloat box(vec3 p, vec3 r){\n    vec3 ap = abs(p) - r;\n    return length(max(vec3(0), ap)) + \n           min(0., max(ap.x, max(ap.y,ap.z)));\n}\n\nfloat SDF(vec3 p){\n    float t1 = iTime;\n    p.xy *= rot(t1*0.7);\n    p.yz *= rot(t1);\n    \n    //return box(p, vec3(1.));\n    return sphere(p);\n}\n\nfloat rayMarch(vec3 cam, vec3 dir){\n    float md = 0.;\n    \n    vec3 pos;\n    \n    // raymarching loop\n    for(int i=0; i<100; ++i){\n        pos = cam + dir*md;\n        \n        float dist = SDF(pos);\n        if(dist<EPS){\n            return md;\n        }\n        md += dist;\n        if(md>MAX){\n          return MAX;\n        }\n    }\n    return MAX;\n}\n\n//normal\nvec3 getN(vec3 p){ \n    vec2 e = vec2(EPS, 0.);\n    float dx, dy, dz;\n    dx = SDF(p)-SDF(p-e.xyy);\n    dy = SDF(p)-SDF(p-e.yxy);\n    dz = SDF(p)-SDF(p-e.yyx);\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 fresnel(in vec3 f0, in float product){\n    return mix(f0, vec3(1.0), pow(1.0 - product, 5.0));\n}\n\nvec3 lightCal(vec3 d, vec3 s, float alpha, vec3 p, vec3 cam, vec3 li){\n    vec3 N = getN(p); // normal\n    vec3 L = normalize(li-p); // light\n    vec3 R = normalize(reflect(-L, N)); // reflect vector\n    vec3 C = normalize(cam-p); // view vector\n    \n    float NdL = clamp(dot(N, L), 0., 1.);\n    float RdC = clamp(dot(R, C), 0., 1.);\n    \n    vec3 diffuse = NdL * d;\n    vec3 specular = pow(RdC, alpha) * s; \n    \n    vec3 H = normalize(L+C);\n    float HdC = dot(H, C);\n    vec3 temp = vec3(0.2); \n    vec3 f = fresnel(temp, HdC); \n    diffuse = NdL * d * (1.-f);\n    specular = pow(RdC, alpha) * s*f;\n    \n\treturn diffuse + specular;\n}\n\nvec3 lights(vec3 a, vec3 d, vec3 s, float alpha, vec3 p, vec3 cam){\n    vec3 col = a*0.2;\n    vec3 lpos = vec3(10.);\n    col += lightCal(d,s,alpha,p,cam,lpos);\n    return col;\n}\n\nvoid camRot(inout vec3 p){\n    float t1 = iTime;\n    p.xy *= rot(t1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 coord = fragCoord/iResolution.xy;\n    coord = coord * 2. - 1.;\n    coord.x *= iResolution.x/iResolution.y;\n    \n    vec3 cam = vec3(0., 0., 3.);\n    vec3 dir = normalize(vec3(coord, -1.));\n    camRot(cam);\n    camRot(dir);\n    \n    \n    float dist = rayMarch(cam, dir);\n    vec3 col;\n    vec3 bgCol = vec3(0.250,0.250,0.25);\n    \n    // ray matching no\n    if(dist>MAX-EPS){\n        col = bgCol;\n        //col = mix(vec3(1.), bgCol, pow(dot(dir,vec3(0.,0., -1.)), 10.));\n        fragColor = vec4(col, 1.);\n        return;\n    }\n    // ray matching ok\n    vec3 a = bgCol; // ambient light\n    vec3 d = vec3(1.); // diffuse light\n    vec3 s = vec3(1.); // specular light\n    float alpha = 100.;\n    vec3 p = cam + dir*dist; // position\n    \n    col = lights(a,d,s,alpha,p,cam);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}