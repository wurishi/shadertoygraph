{"ver":"0.1","info":{"id":"4lKSRW","date":"1483410300","viewed":446,"name":"Polar Grid Test","username":"ptrgags","description":"Test of making a polar grid with radials of a constant width. Also a test of using structs in a shader, even if it was a little overkill. \n\nThis is just an intermediate step in something I'm planning.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","tutorial","polarcoordinates","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CENTER (iResolution.xy / 2.0)\n#define PI 3.1415\n#define TAU (2.0 * PI)\n//10 cells in the radial direction, \n//24 around the circle\n#define GRID_DIMS vec2(10.0, 24.0)\n\n//------------------------------------------------------\n\n/**\n * Keep track of the grid cell ID number\n * and the UV coordinates within that cell.\n * \n * Overkill? probably. I just wanted to try struct\n * syntax in GLSL.\n */\nstruct GridCoords {\n    vec2 cell_id;\n    vec2 cell_uv;\n};\n    \n/**\n * Take UV coordinates, scale up and divide into boxes.\n */\nGridCoords grid_coords(vec2 uv, vec2 grid_dims) {\n    vec2 scaled = uv * grid_dims;\n    GridCoords gridded;\n    gridded.cell_id = floor(scaled);\n    gridded.cell_uv = fract(scaled);\n    return gridded;\n}\n\n//---------------------------------------------\n\n//Convert rectangular to polar coordinates\nvec2 rect_to_polar(vec2 rect) {\n    float r = length(rect);\n    float theta = atan(rect.y, rect.x);\n    \n    //Fix the coordinates so they go from 0 to 2PI\n    //instead of -PI to PI. These two lines are optional\n    if (theta < 0.0)\n        theta += TAU;\n    \n    return vec2(r, theta);\n}\n\n/*\n * Convert screen coordinates to \n * normalized polar coordinates with the origin in the center\n * of the screen. angle is measured from 0.0 to 1.0 counterclockwise\n * around the circle.\n */\nvec2 normalized_polar(vec2 coord) {\n    //Centered UV coordinates accounting for aspect ratio\n    vec2 uv = (coord - CENTER) / iResolution.y;\n    \n    //Convert to polar. Normalize the angle component by\n    //dividing by a full circle.\n    vec2 polar = rect_to_polar(uv);\n    polar.y /= TAU;\n    \n    return polar;\n}\n\n\n//max component of 2-vector.\nfloat max_vec2(vec2 p) {\n    return max(p.x, p.y);\n}\n\n\n/**\n * Draw grid lines like on polar graph paper.\n * polar -- r and theta (normalized)\n * grid -- polar grid coords\n * circle_weight -- weight of the circle lines from 0.0 to 1.0\n * radial_weight -- weight of the radial lines from 0.0 to 1.0\n */\nfloat polar_grid_lines(vec2 polar, \n                       GridCoords grid, \n                       float circle_weight, \n                       float radial_weight) {\n    vec2 lines;\n    //Draw concentric circles\n    lines.x = smoothstep(1.0 - circle_weight, 1.0, grid.cell_uv.x);\n    \n    //To get radials to be a constant width, we need to scale using\n    //the radius from the center of the screen.\n    float scaled_line_width = radial_weight / polar.x;\n    lines.y = smoothstep(1.0 - scaled_line_width, 1.0, grid.cell_uv.y);\n    \n    //convert to greyscale\n    return max_vec2(lines);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get the screen coords in polar coordinates as well\n    //as grid coordinates\n    vec2 polar = normalized_polar(fragCoord);\n    GridCoords polar_grid = grid_coords(polar, GRID_DIMS);\n    \n    //Do the same for the mouse\n    vec2 mouse_polar = normalized_polar(iMouse.xy);\n    GridCoords mouse_grid = grid_coords(mouse_polar, GRID_DIMS);\n    \n    //Calculate grid lines\n    float circle_weight = 0.2;\n    float grid_lines = polar_grid_lines(\n        polar, polar_grid, circle_weight, circle_weight / 2.0);\n    \n    //Draw the grid inverted so the lines are dark and the cells are light.\n    fragColor = (1.0 - grid_lines) * vec4(1.0, 1.0, 0.0, 1.0);\n    \n    //Fill in the cell under the mouse. the (1.0 - grid_lines) makes sure\n    //we color in between the lines.\n    if (mouse_grid.cell_id == polar_grid.cell_id)\n        fragColor = (1.0 - grid_lines) * vec4(1.0, 0.0, 0.0, 1.0);\n\t\n}","name":"Image","description":"","type":"image"}]}