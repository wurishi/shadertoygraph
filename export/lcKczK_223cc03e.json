{"ver":"0.1","info":{"id":"lcKczK","date":"1732118166","viewed":393,"name":"spherical fractalic moving","username":"nayk","description":"source fractal 62 by gaz","likes":16,"published":3,"flags":0,"usePreview":0,"tags":["fractal","color","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define PI 3.1415926\n#define CELLS iTime.\nfloat rand(vec2 pos) {\n    return \n        fract(sin(dot(pos, vec2(23.2342, 82.29561))) * 82931.1857193);\n    \n}\n\n/* color palette:\n76, 149, 156\n33, 96, 198\n85, 184, 130\n74, 160, 115\n47, 112, 168\n*/\n\nmat2 rotate2d(float angle) {\n    return mat2(\n            sin(angle), -cos(angle),\n            cos(angle), sin(angle)\n        );\n}\n\nvec3 pattern(vec2 pos, float size, float frequency, float angle, vec3 color, float transparency) {\n    pos *= rotate2d(angle);\n    return vec3(floor(rand(floor(pos*size+vec2(0.+iTime, 0.)))+frequency)\n                + .4*floor(rand(floor(pos*size+vec2(-1.+iTime, 0.)))+frequency)\n                + .1*floor(rand(floor(pos*size+vec2(-2.+iTime, 0.)))+frequency)\n                + .15*floor(rand(floor(pos*size+vec2(0., -1.+iTime)))+frequency)\n                + .15*floor(rand(floor(pos*size+vec2(0., 1.+iTime)))+frequency)\n                + .15*floor(rand(floor(pos*size+vec2(1.+iTime, 0.)))+frequency)\n        )*color*transparency*(1.-.5*rand(floor(pos*size+vec2(-1.+iTime, 0.))));\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n      vec2 uv = (C/iResolution.xy - .5);\n    uv.x *= iResolution.x/iResolution.y;\n\n\tvec2 xy = C.xy / iResolution.xy - vec2(0.5,0.5);\n\txy.y *= -iResolution.y / iResolution.x;\nxy*=rotate2d(iTime);\n\tfloat time = iTime*0.5;\n\tvec3 ro = 5.5*normalize(vec3(cos(time),cos(time)*1.2,sin(time)));\n    vec3 eyed = normalize(vec3(0.0) - ro);\n    vec3 ud = normalize(cross(vec3(0.0,1.0,0.0), eyed));\n    vec3 vd = normalize(cross(eyed,ud));\nfloat fov = 3.14 * 0.8 + sin(time*1.334)*1.45;\n\tfloat f = fov * length(xy);\n\tvec3 rd = normalize(normalize(xy.x*ud + xy.y*vd) + (1.0/tan(f))*eyed);\n\n\tvec2 interp = C.xy / iResolution.xy;\n    //Mouse coordinates in [-1, 1] range\n    vec2 mp = iMouse.xy / iResolution.xy * vec2(2.0) + vec2(1.0);    \n    \n    interp.y = 1.0 - interp.y;\n    mp.y = 1.0 - mp.y;\n    \n    //360 degrees around the x-axis, 180 degrees on the y-axis\n    //The frustum can be split into several parts:\n    //The very top is +y, the north pole, and the very bottom\n    //is -y, i.e the south pole.\n    //The middle consists of +z, -z, +x and -x, where -z\n    //is the center of the frustum, and the left and right\n    //frustum edges show +z, i.e what is behind you\n    \n\n    float hOffset = (2.0*PI - 1.)*0.5;\n    float vOffset = (PI - 1.)*0.5;\n    float hAngle = hOffset + interp.x * 1.;\n    float vAngle = vOffset + interp.y * 1.;\n    vec3 n;    \n    n.x = sin(vAngle) * sin(hAngle);\n    n.y = cos(vAngle);\n    n.z = sin(vAngle) * cos(hAngle);\n    \n    //Normal pitch-yaw camera controlled with the mouse\n   \n vec3 r2 = normalize(vec3(uv, 1.1 - dot(uv, uv) * 15.002*cos(iTime)));\n\t vec3 r3 = normalize(vec3(uv, 1.0 - dot(uv, uv) * 1.2*sin(iTime)));\n\n    vec3 col = vec3(pattern(uv, 500., 0.009, PI, vec3(76, 149, 156)/255., .9)\n            + pattern(uv, 250., 0.004, PI/3., vec3(33, 96, 198)/255., 0.8)\n            + pattern(uv, 125., 0.008, 3.*PI/4., vec3(85, 184, 130)/255., .8)\n            + pattern(uv, 60., 0.010, 5.*PI/4., vec3(47, 112, 168)/255., .8)\n            + pattern(uv, 30., 0.018, PI, vec3(76, 149, 156)/255., .8)\n        );\n    vec3 n1,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.1,0.2,2.),H(g*.1),.8)*10./e/8e3\n    )\n    {\n        n1=g*d+r2*5.+r3*rd*n ;\n        n1.xz*=rotate2d(iTime);\n        n1.yz*=rotate2d(iTime);\n       n1.z+=iTime*10.;\n     \n        a=20.;\n        n1=mod(n1-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n         n1.xz*=rotate2d(iTime*0.01);\n        n1.yz*=rotate2d(iTime*0.01);\n            n1=.3-abs(n1+r2);\n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            s*=e=1.7+sin(iTime*.01)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 )+r3;\n         }\n         g+=e=length(n1.yzzz)/s;\n    }\n}","name":"Image","description":"","type":"image"}]}