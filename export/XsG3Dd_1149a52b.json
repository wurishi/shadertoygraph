{"ver":"0.1","info":{"id":"XsG3Dd","date":"1456961358","viewed":372,"name":"Morphing Liquid","username":"jackdavenport","description":"A raymarched liquid thing. I wanted to play around with mixing between two distance fields, but I ended up adding a smooth minimum.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher","liquid","smooth","morphing","minimum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHT_DIR normalize(vec3(45.,30.,-45.))\n#define LIGHT_COL vec3(.9,1.,1.)\n\nstruct Ray { vec3 ori; vec3 dir; };\nstruct Hit { vec3 p; bool h; \t };\n\nvec2 rot2D(vec2 p, float angle) {\n\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n\n}\n\n// Thanks iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nfloat dstScene(vec3 p) {\n    \n    vec3 pos = vec3(0.,.25,0.);\n   \tvec3 r = pos - p;\n    float a = length(r) - 1.;\n    \n    r.yz = rot2D(r.yz, 45.);\n    vec2 t = vec2(.75,.2);\n    vec2 q  = vec2(length(r.xz) - t.x, r.y);\n    float b = length(q) - t.y;\n    \n    float d = abs(sin(iTime * .75));\n    if(iMouse.z > 0.) d = iMouse.y/iResolution.y;\n    float f = mix(a, b, d);\n    \n    float tm = iTime;\n    if(iMouse.z > 0.) tm = (iMouse.x/iResolution.x)*5.;\n    \n    pos = vec3(sin(tm), cos(tm * .5) * .5, 0.);\n    f = smin(f, length(max(abs(pos - p) - vec3(.3),0.)) - .25, .8);\n    f = min(f, p.y + 1.);\n    \n    return f;\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    bool b = false;\n    \n    for(int i = 0; i < 128; i++) {\n     \n        float dst = dstScene(p);\n        p += ray.dir * dst * .75;\n        \n        if(dst < .001) {\n         \n            b = true;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,b);\n    \n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(.001,0.);\n    vec3   n = vec3(dstScene(p + eps.xyy) - dstScene(p - eps.xyy),\n                    dstScene(p + eps.yxy) - dstScene(p - eps.yxy),\n                    dstScene(p + eps.yyx) - dstScene(p - eps.yyx));\n    return normalize(n);\n    \n}\n\n// iq's shadows, again\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = dstScene( ro + rd*t );\n        res = min( res, 32.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcLighting(Hit scn, vec3 n) {\n \n    float d = max(dot(LIGHT_DIR,n), 0.);\n    d *= softshadow(scn.p + LIGHT_DIR * .001, LIGHT_DIR, 0.2, 16.);\n    \n    return LIGHT_COL * d;\n    \n}\n\nvec3 shadeObjectFlat(Ray ray, Hit scn, vec3 n) {\n    \n    vec3 l = calcLighting(scn, n);\n    vec3 s = vec3(max(pow(dot(reflect(ray.dir,n),LIGHT_DIR), 60.), 0.));\n    s *= l;\n    \n    return l + s;\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scn  = raymarch(ray);\n    vec3 col = texture(iChannel0, ray.dir).xyz;\n\n    if(scn.h) {\n        \n        vec3 n  = calcNormal(scn.p);\n        vec3 r  = normalize(reflect(ray.dir, n));\n        \n        Ray rr  = Ray(scn.p + r * .01, r);\n        Hit rh  = raymarch(rr);\n        vec3 rc = texture(iChannel0,r).xyz;\n        if(rh.h) rc = shadeObjectFlat(rr,rh,calcNormal(rh.p));\n        \n        float fresnel = 1. - mix(.1, .9, max(pow(-dot(ray.dir,n), .4),0.));\n        col = mix(shadeObjectFlat(ray,scn,n), rc, fresnel);\n        \n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,-3.);\n    vec3 dir = vec3(uv, 1.);\n    \n    vec3 col = shade(Ray(ori,normalize(dir)));\n\tfragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}