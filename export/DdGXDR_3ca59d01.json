{"ver":"0.1","info":{"id":"DdGXDR","date":"1681148605","viewed":59,"name":"just some rayMarching stuff","username":"SupSy","description":"you can move with arrow keys and look around with mouse (couldn't make it nice). Also I am very new to all of this so if anyone could explain how reflexions actually work I would be very grateful (no success searching by myself)","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nray makeRay(vec3 origin, vec3 direction) {\n    ray r;\n    r.direction = direction;\n    r.origin = origin;\n    return r;\n}\n\nvec3 rotX(vec3 pos, float angle) {\n    float cosA = cos(angle); float sinA = sin(angle);\n    float y = cosA * pos.y + sinA * pos.z;\n    float z = - sinA * pos.y + cosA * pos.z;\n    return vec3(pos.x, y, z);\n}\n\nvec3 rotY(vec3 pos, float angle) {\n    float cosA = cos(angle); float sinA = sin(angle);\n    float x = cosA * pos.x + sinA * pos.z;\n    float z = - sinA * pos.x + cosA * pos.z;\n    return vec3(x, pos.y, z);\n}\n\nvec3 rotZ(vec3 pos, float angle) {\n    float cosA = cos(angle); float sinA = sin(angle);\n    float x = cosA * pos.x + sinA * pos.y;\n    float y = - sinA * pos.x + cosA * pos.y;\n    return vec3(x, y, pos.z);\n}\n\nvec3 rotXYZ(vec3 pos, vec3 rotation) {\n    return rotZ(rotY(rotX(pos, rotation.x), rotation.y), rotation.z);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius) {\n    return length(pos - center) - radius;\n}\n\nfloat sdBoxR(vec3 pos, vec3 origin, vec3 rotated, vec3 radius, float corner) {\n    vec3 c = rotXYZ(pos - origin, rotated);\n    c.x = max(abs(c.x) - radius.x, 0.0);\n    c.y = max(abs(c.y) - radius.y, 0.0);\n    c.z = max(abs(c.z) - radius.z, 0.0);\n    //return length(max(c, 0.0)) + min(0.0, max(c.x, max(c.y, c.z))) - corner;\n    return length(c) - corner;\n}\n\n#define K 0.0\nfloat sdScene(vec3 pos, int except) {\n    float s1 = sdSphere(pos, vec3(2.1, -0.8 + cos(1.5 * iTime) * 0.2, 5), 1.0);\n    float s2 = sdSphere(pos, vec3(-4, 3.0 + cos(iTime + 0.2) * 0.3, 10), 1.0);\n    float b1 = sdBoxR(pos, \n        //vec3((iMouse.x - iResolution.x * 0.5) / iResolution.y, iMouse.y / iResolution.y - 0.5, 1),\n        vec3(-0.4, -0.4 + cos(1.2 * iTime + 0.7) * 0.1, 1.0),\n        vec3(iTime/10.0, iTime/6.8 + 18.0, iTime/4.0 + 19.0),\n        vec3(.5, .5, .5), 0.1);\n    float b2 = sdBoxR(pos,\n        vec3(2, 1.0 + cos(0.9 * iTime + 2.0) * 0.3, 3.0),\n        vec3(iTime/10.0 + 56.0, iTime/6.8 + 78.0, iTime/4.0 + 29.0),\n        vec3(.5, .5, .5), 0.1);\n    float b3 = sdBoxR(pos,\n        vec3(0, -3, 8),\n        vec3(0, -2, 0),\n        vec3(5, 0, 5), 1.0);\n    return smin(b3, smin(b2, smin(b1, smin(s2, s1, K), K), K), K);\n}\n\n#define MIN_DIST 0.0001\n#define MAX_DIST 100.0\nfloat march(ray camRay) {\n    float traveledDist = 0.0;\n    float minDist = MAX_DIST;\n    for (int i = 0; i < 100000 && traveledDist < MAX_DIST; i++) {\n        minDist = sdScene(camRay.direction * traveledDist + camRay.origin, -1);\n        traveledDist += minDist;\n        if (minDist < MIN_DIST) return traveledDist;\n    }\n    return MAX_DIST;// > MAX_DIST ? 0.0 : 1.0;\n}\n\nvec3 normal(vec3 pos)\n{\n    const float h = 0.0001;\n    float corner1 = sdScene(pos + vec3(h, -h, -h), -1);\n    float corner2 = sdScene(pos + vec3(-h, h, -h), -1);\n    float corner3 = sdScene(pos + vec3(-h, -h, h), -1);\n    float corner4 = sdScene(pos + vec3(h, h, h), -1);\n    vec3 normalDirection = vec3(corner1 - corner2 - corner3 + corner4, - corner1 + corner2 - corner3 + corner4, - corner1 - corner2 + corner3 + corner4);\n    return normalize(normalDirection);\n}\n\nfloat shadow(vec3 pos, vec3 light_dir) {\n    ray normRay = makeRay(pos+light_dir * MIN_DIST * 200.0, light_dir);\n    return march(normRay) >= MAX_DIST ? 1.0 : 0.0;\n}\n\n#define FOV 80\n#define PI 3.141592\n\nvec3 makeDirection(vec3 origin, int x, int y) {\n    return vec3(\n        (float(x) - float(iResolution.x) / 2.0f) / (float(iResolution.y) / 2.0f),\n        (float(y) - float(iResolution.y) / 2.0f) / (float(iResolution.y) / 2.0f),\n        0) - origin;\n}\n\nvec3 refl(vec3 a, vec3 b) {\n    float facteur = 2.0 * (a.x*b.x + a.y*b.y + a.z*b.z) / (a.x * a.x + a.y * a.y + a.z * a.z);\n    return -vec3(facteur * b.x - a.x, facteur * b.y - a.y, facteur * b.z - a.z);\n}\n\n#define SUN normalize(vec3(1, 1, -1))\n#define SUN_POWER 10.0\n#define SHINYNESS 1.0\n#define AMBIANT 0.1\nfloat getValue(inout ray camRay) {\n    float dist = march(camRay);\n    if (dist == MAX_DIST) return - 1.0;\n    vec3 hitPos = dist * camRay.direction + camRay.origin;\n    vec3 normals = normal(hitPos);\n    hitPos = hitPos + normals * MIN_DIST * 20.0;\n    float shadows = shadow(hitPos, SUN);\n    float diffuse = max(dot(normals, SUN * SUN_POWER), 0.0);\n    float specular = pow(max(dot(refl(SUN, normals), camRay.direction), 0.0), SHINYNESS * 100.0) * SUN_POWER;\n    \n    vec3 proj = normals * dot(-camRay.direction, normals);\n    vec3 diff = camRay.direction + proj;\n    vec3 newDir = - camRay.direction + 2.0 * diff;\n    \n    camRay.origin = hitPos;\n    camRay.direction = newDir;\n    \n    return (diffuse * shadows + specular * shadows + AMBIANT);\n}\n\nvec2 sphereUV(vec3 coords) {\n    vec3 vecY = vec3(0.0, 1.0, 0.0);\n    float cosAlpha = dot(coords.xz, vecY.yx) / length (coords.xz);\n    float signAlpha = sign(dot(coords.xz, vecY.xy));\n    \n    float alpha = acos(cosAlpha) * signAlpha;\n    \n    float beta = acos(dot(coords, vecY));\n                \n    return vec2((alpha + PI) / (2.0 * PI), -beta / PI);\n}\n\nvec2 getCoord() {\n    return vec2(\n    \ttexelFetch(iChannel1, ivec2(0, 0), 0).r,\n        texelFetch(iChannel1, ivec2(1, 0), 0).r\n    );\n}\n\nvec3 ajust(vec3 t) {\n    return t / (1.0 + length(t));\n}\n\n#define MAX_BOUNCE 0\n#define METALLIC 0.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 mouseRot = vec3(-texelFetch(iChannel1, ivec2(3, 0), 0).r, texelFetch(iChannel1, ivec2(2, 0), 0).r, 0);\n    \n    vec3 origin = vec3(0, 0, float(iResolution.x) / float(iResolution.y * tan(float(FOV) / 360.0 * PI)));\n    vec3 direction = rotXYZ(makeDirection(origin, int(fragCoord.x), int(fragCoord.y)), mouseRot);\n    origin += vec3(getCoord().x, 0, getCoord().y);\n    ray camRay = makeRay(origin + direction * 0.1, normalize(direction));\n    \n    \n    float temp = getValue(camRay);\n    vec3 value = vec3(temp);\n    if (temp > -1.0) {\n        for (int i = 1; i < MAX_BOUNCE + 1; i++) {\n            temp = getValue(camRay);\n            vec3 val = vec3(temp);\n            if (temp == -1.0) {\n                vec2 coords = sphereUV(normalize(camRay.direction));\n                val = texture(iChannel0, coords).xyz * 0.2;\n            }\n            \n            value = val * (value + 1.0 * SHINYNESS) * METALLIC + (value + value * val * SHINYNESS) * (1.0 - METALLIC);\n            value *= 1.0 + METALLIC * SHINYNESS;\n        }\n    }\n    fragColor = vec4(ajust(value), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float speed = 10.0;\n\nvec2 rot2D(vec2 pos, float angle) {\n    float cosA = cos(angle); float sinA = sin(angle);\n    float x = cosA * pos.x + sinA * pos.y;\n    float y = - sinA * pos.x + cosA * pos.y;\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float outData = 0.0;\n    float rotationX = -(iMouse.x / iResolution.x) * 3.141592 * 2.0;\n    float rotationY = (iMouse.y / iResolution.x - iResolution.y/iResolution.x * 0.5) * 3.141592 * 2.0;\n    vec2 add = rot2D(vec2(\n        (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r,\n        (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r -\n        \t\t(iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r\n    ), rotationX);\n    \n    switch(int(fragCoord.x)) {\n        case 0:\n        \toutData = texelFetch(iChannel0, ivec2(0), 0).r + add.x;\n        \tbreak;\n        case 1:\n        \toutData = texelFetch(iChannel0, ivec2(1, 0), 0).r + add.y;\n        \tbreak;\n        case 2:\n            outData = rotationX;\n            break;\n        case 3:\n            outData = rotationY;\n            break;\n    }\n    \n    fragColor = vec4(outData, 0.0, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}