{"ver":"0.1","info":{"id":"mdBcDc","date":"1688261464","viewed":102,"name":"Baby's First Raymarcher","username":"martysh12","description":"This is my first time ever using raymarching in a shader. Yay, I guess?\nThe code is verbose on purpose!\n\n(p.s, it's the light that's rotating, not the camera)","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100 // Maximum raymarching steps (if we haven't hit a surface)\n\n#define MAX_DIST 100.0 // Maximum ray distance so our raymarcher doesn't wander off into the void\n#define SURF_DIST 0.01 // How close the ray needs to be to the scene for the raymarcher to think it hit a surface\n\nfloat smoothmin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) - k * h * (1.0 - h);\n}\n\n// 'sd' = signed distance\nfloat sd_sphere(vec3 p, float r, vec3 pos)\n{\n    return length(p - pos.xyz) - r;\n}\n\nfloat sd_groundplane(vec3 p, float h)\n{\n    return p.y - h;\n}\n\n// Signed distance function for the entire scene\nfloat sd_scene(vec3 p)\n{\n    float ground_plane = sd_groundplane(p, 0.);\n    float sphere = sd_sphere(p, 1., vec3(0., 1.5, 6.));\n    \n    return smoothmin(ground_plane, sphere, sin(iTime / 4.) * 2. + 2.); // Blend between the sphere and the plane\n}\n\nfloat do_ray_march(vec3 ray_origin, vec3 ray_direction)\n{\n    float distance_from_origin = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        // Advance our ray\n        vec3 point = ray_origin + (ray_direction * distance_from_origin);\n        float distance_from_scene = sd_scene(point);\n        distance_from_origin += distance_from_scene;\n        \n        // If the distance exceeds a maximum,\n        // or the distance becomes extremely small (we've hit something),\n        // then stop.\n        if (distance_from_origin > MAX_DIST || distance_from_scene < SURF_DIST)\n        {\n            break;\n        }\n    }\n    \n    return distance_from_origin;\n}\n\nvec3 find_normal(vec3 p)\n{\n    float dist = sd_scene(p);\n    vec2 epsilon = vec2(.1, 0);\n    \n    vec3 n = dist - vec3(\n        sd_scene(p - epsilon.xyy), // Find the distance from the point{x + epsilon, y, z} (offset right)\n        sd_scene(p - epsilon.yxy), // Find the distance from the point{x, y + epsilon, z} (offset up)\n        sd_scene(p - epsilon.yyx)  // Find the distance from the point{x, y, z + epsilon} (offset forward)\n    );\n    \n    return normalize(n);\n}\n\nfloat calculate_light(vec3 p, vec3 light_position)\n{\n    vec3 light_vector = normalize(light_position - p);\n    vec3 normal = find_normal(p);\n    \n    float diffuse = clamp(\n        dot(normal, light_vector),\n        0.,\n        1.\n    );\n    \n    // Calculate shadows by performing another march towards the light\n    float d = do_ray_march(p + normal * SURF_DIST * 2., light_vector);\n    \n    // If the distance we stopped at is smaller than the distance between the light and where\n    // we started at, then we're in shadow.\n    // If we weren't in shadow, the distance would be greater,\n    // because the ray will continue marching until it reaches the maximum amount of steps.\n    if (d < length(light_position - p))\n    {\n        diffuse *= 0.;\n    }\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ray_origin = vec3(0., 1., 0.);\n    // Offset ray direction by the UV coordinates (from the center)\n    // to create perspective; if we are on the left side of the screen, then look to the left.\n    vec3 ray_direction = normalize(vec3(uv, 1.));\n    \n    float dist = do_ray_march(ray_origin, ray_direction);\n    vec3 hit_point = ray_origin + (ray_direction * dist);\n    \n    vec3 light_source_pos = vec3(sin(iTime) * 5., 5., cos(iTime) * 5.);\n    vec3 final_colour = vec3(calculate_light(hit_point, light_source_pos));\n\n    fragColor = vec4(sqrt(final_colour), 1.);\n}\n","name":"Image","description":"","type":"image"}]}