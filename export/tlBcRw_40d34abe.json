{"ver":"0.1","info":{"id":"tlBcRw","date":"1593950377","viewed":285,"name":"Analytic rasterizatio of an edge","username":"Schrompf","description":"Analytic Rasterization: determines how much of a (square) pixel area is covered by an arbitrary triangle. An attempt to recreate the UnrealEngine5 micro triangle rasterizer. Click and drag somewhere. \nThis is one edge only, going for real triangles later","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GridSize = 16.0f;\n\nfloat edgeIntegral( vec2 pa, vec2 pb, vec2 rectMin, vec2 rectMax)\n{\n    vec2 dir = normalize( pb - pa);\n    vec2 dirSign = mix( vec2( 1.0f), vec2( -1.0f), lessThan( dir, vec2( 0.0f)));\n\tfloat len = length( pb - pa);\n\n    vec2 areaMin = max( rectMin, min( pa, pb));\n    vec2 areaMax = min( rectMax, max( pa, pb));\n    \n    vec2 rectCenter = 0.5f * (rectMin + rectMax);\n    vec2 rectSize = rectMax - rectMin;\n    \n    vec2 middleIntersecPos = mix( (rectCenter - pa) / dir, vec2( 10000.0f), equal( dir, vec2( 0.0f)));\n    vec2 intersecSize = dirSign * mix( rectSize / dir, vec2( 10000.0f), equal( dir, vec2( 0.0f)));\n \n    vec2 entryDist = middleIntersecPos - 0.5f * intersecSize;\n    vec2 exitDist = middleIntersecPos + 0.5f * intersecSize;\n\n    float latestEntry = max( 0.0f, max( entryDist.x, entryDist.y));\n    float earliestExit = min( len, min( exitDist.x, exitDist.y));\n    \n    // line segment inside the integration area\n    vec2 areaEntryPos = pa + latestEntry * dir;\n    vec2 areaExitPos = pa + earliestExit * dir;\n    \n    areaEntryPos = max( areaMin, min( areaMax, areaEntryPos));\n    areaExitPos = max( areaMin, min( areaMax, areaExitPos));\n    \n    // XY: base +X vector, ZW: base +Y vector. Might turn out we only need the absolute\n    vec4 rotMatrix = ((dirSign.x * dirSign.y) < 0.0f ? vec4( 0, 1, -1, 0) : vec4( 1, 0, 0, 1)) * (dirSign.y < 0.0f ? -1.0f : 1.0f);\n    vec4 rotAbsMatrix = abs( rotMatrix);\n    \n    vec2 innerDir = areaExitPos - areaEntryPos;\n    float diagonalArea = abs( 0.5f * innerDir.x * innerDir.y);\n\n    float lowerBorder = dot( rotAbsMatrix.zw, dot( rotMatrix.zw, vec2( 1)) < 0.0f ? areaMax : areaMin);\n\tfloat areaBelow = abs(dot( rotAbsMatrix.zw, areaEntryPos) - lowerBorder) * dot( rotMatrix.xy, innerDir);\n    \n    float rightBorder = dot( rotAbsMatrix.xy, dot( rotMatrix.xy, vec2( 1)) < 0.0f ? areaMin : areaMax);\n    float areaRight = max( 0.0f, (dirSign.y < 0.0f ? -1.0f : 1.0f) * (rightBorder - dot( rotAbsMatrix.xy, areaExitPos))) \n        \t\t\t* max( 0.0f, dot( rotAbsMatrix.zw, areaMax - areaMin));\n\n    return (diagonalArea + areaBelow + areaRight) / (rectSize.x * rectSize.y);\n}\n\nvec3 triangleIntegral( vec2 pa, vec2 pb, vec2 pc, vec2 rectMin, vec2 rectMax)\n{\n    float edge1 = edgeIntegral( pa, pb, rectMin, rectMax);\n//    float edge2 = edgeIntegral( pc, pa, rectMin, rectMax);\n    \n    vec3 demoColour = edge1 * vec3( 0.0f, 1.0f, 0.0f);\n    return demoColour;\n}\n\nfloat drawEdge( in vec2 fragCoord, in vec2 pa, in vec2 pb)\n{\n    vec2 edgeMin = min( pa, pb), edgeMax = max( pa, pb);\n    vec2 dirToPb = normalize( pb - pa);\n    vec2 orthoToPb = vec2( 1, -1) * dirToPb.yx;\n    \n    float dist = dot(fragCoord.xy - pa, orthoToPb);\n    \n\tdist = (fragCoord.x >= edgeMin.x && fragCoord.y >= edgeMin.y && fragCoord.x <= edgeMax.x && fragCoord.y <= edgeMax.y) ? dist : 0.0f;\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // construct an edge from some point at the left and some angle\n    vec2 pa = vec2( iMouse.x, iMouse.y);\n    float angleToPb = 8.0f * (iMouse.x / iResolution.x - 0.5f);\n    vec2 dirToPb = vec2( cos( angleToPb), -sin( angleToPb));\n    vec2 pb = pa + 0.6f * iResolution.x * dirToPb;\n\n    float angleToPc = angleToPb + 0.6f;\n    vec2 dirToPc = vec2( cos( angleToPc), -sin( angleToPc));\n    vec2 pc = pa + 0.4f * iResolution.x * dirToPc;\n    \n    // a grid of rectangles\n    ivec2 gridpos = ivec2(fragCoord.xy / GridSize);\n    vec2 rectMin = vec2( gridpos) * GridSize;\n    vec2 rectMax = rectMin + vec2( GridSize, GridSize);   \n    vec3 tri = triangleIntegral( pa, pb, pc, rectMin, rectMax);\n    \n    float edge1 = clamp( 0.0f, 1.0f, drawEdge( fragCoord, pa, pb));\n    float allEdges = edge1;\n    vec3 gridColour = tri + vec3( 0, 0, clamp( 0.0f, 1.0f, allEdges));\n    \n    fragColor = vec4( gridColour, 1.0);\n}","name":"Image","description":"","type":"image"}]}