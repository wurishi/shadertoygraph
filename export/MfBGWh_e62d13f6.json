{"ver":"0.1","info":{"id":"MfBGWh","date":"1704444749","viewed":38,"name":"# 4 - Raymarching demo","username":"SardineMilk","description":"Basic raymarching example with tiled spheres.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b*cos( 6.28318*(c*t*d) );\n    }\n\n\nfloat map(vec3 p) {\n\tfloat s1 = length(mod(p.xy + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.5), 2.) - 1.0) - 0.2;\n\tfloat s2 = length(mod(0.5+p.yz + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.3), 2.) - 1.0) - 0.2;\n    return min(s1, s2);\n}\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n\nfloat sDSphere(vec3 point, vec3 centre, float radius) {\n    return length(point - centre) - radius;\n}\n\nfloat sDTiledSphere(vec3 point, vec3 centre, float radius) {\n    vec3 tiledPoint = mod(point - centre + 0.5, 1.) - 0.5;\n    return length(tiledPoint) - radius;\n}\n\n\nvec3 spherePosition = vec3(0., 0., 0.5);\nfloat sphereRadius = 0.25;\n\n\nconst float FOV = 90.;\nint maxMarchingSteps = 2555;  // Maximum number of times ray is marched until loop breaks\nfloat maxDistance = 1000.0;  // Maximum distance to object for a miss\nfloat minDistance = 0.00005;  // Minimum distance to object for a hit\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spherePosition.x = sin(iTime / 1.5);\n    spherePosition.y = cos(iTime / 1.5);\n    //spherePosition.z = -iTime * 2.;\n    //spherePosition.x = cos(iTime) / 2. + 2.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    // Shifted so (0, 0) is the centre rather than bottom-left\n    vec2 shiftedCoord = fragCoord - (iResolution.xy / 2.0);\n    vec2 uv = shiftedCoord / iResolution.y;   \n    \n    vec3 rayPosition = vec3(uv.x, uv.y, 0.0);\n    \n    vec3 rayDirection = vec3(0.0, 0.0, 1.0);\n    rayDirection.xy = uv.xy * atan(radians(FOV / 2.));\n    rayDirection = normalize(rayDirection);\n    \n    // Default colour for a miss\n    vec3 col = vec3(0., 0., 0.);\n    for (int i = 0; i < maxMarchingSteps; i++)  // March the ray forwards  \n    {        \n        // Distance to nearest object\n        float signedDistance = sDTiledSphere(rayPosition, spherePosition, sphereRadius);\n        float signedDistance2 = sDTiledSphere(rayPosition, spherePosition + vec3(0.4, 0., 0.) + vec3(iTime/5., iTime/5., 0.), 0.25);\n        signedDistance = smin(signedDistance, signedDistance2, 0.125);  \n        // signedDistance = map(rayPosition - spherePosition);\n        \n        if (signedDistance < minDistance) {\n            // If the ray touches something\n            \n            //col = vec3(1., 1., 1.);\n            //col = palette((float(i) * 0.04) - (rayPosition.z * 0.25) - (signedDistance * 1. + 1.));\n            //col = palette(rayPosition.z * 0.25);\n            //col = palette(signedDistance * 3500. + 1.);\n            col = palette(float(i) * 0.008 + 0.6);\n            col /= length(rayPosition) / 1.;  \n            break;\n        } \n        else if (signedDistance > maxDistance) { \n            break;  // If the ray misses\n        } \n        else {\n            rayPosition += rayDirection * signedDistance;  // Move the ray\n            \n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}