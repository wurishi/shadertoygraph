{"ver":"0.1","info":{"id":"Nty3Rc","date":"1638043582","viewed":159,"name":"Domain Repetition Tests","username":"Hyeve","description":"I've been messing with bounded domain repetition lately, and decided to see how far I could take it.\nThis entire scene is made from a single cuboid evaluation (ignoring the bound evaluations)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","domainrepetition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a)) \n\nfloat bx(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return min(max(q.x,max(q.y,q.z)),0.) + length(max(q,0.));\n}\n\nfloat mp(vec3 p)\n{\n\n    float xID1 = p.x; //Calculate ID for rotation direction\n    float xR1 = xID1 > 0. ? 1. : -1.;\n    \n    p.x = abs(p.x) - 8.5; //Domain repeat\n    \n    float b4 = bx(p, vec3(8.3,14,14)); //Bound 4 (32-cuboid sets)\n    b4 = abs(b4) + 0.1;\n    \n    p.yz *= rot(iTime * xR1); //Rotate\n\n    //--------\n\n    float zID0 = p.z; //Calculate ID for rotation direction\n    float zR0 = zID0 > 0. ? 1. : -1.;\n    \n    p.z = abs(p.z) - 6.5; //Domain repeat\n    \n    float b3 = bx(p, vec3(9,9,6.3));  //Bound 3 (16-cuboid sets)\n    b3 = abs(b3) + 0.1;\n    \n    p.xy *= rot(iTime * zR0); //Rotate\n\n    //--------\n\n    float yID1 = p.y; //Calculate ID for rotation direction\n    float yR1 = yID1 > 0. ? 1. : -1.;\n    \n    p.y = abs(p.y) - 3.5; //Domain repeat\n    \n    float b2 = bx(p, vec3(7,3.3,7)); //Bound 2 (8-cuboid sets)\n    b2 = abs(b2) + 0.1;\n    \n    p.xz *= rot(iTime * yR1); //Rotate\n    \n    //--------\n    \n    float xID0 = p.x; //Calculate ID for rotation direction\n    float xR0 = xID0 > 0. ? 1. : -1.;\n    \n    p.x = abs(p.x) - 3.5; //Domain repeat\n    \n    float b1 = bx(p, vec3(3.3,5,5)); //Bound 1 (4-cuboid sets)\n    b1 = abs(b1) + 0.1;\n    \n    p.yz *= rot(iTime * xR0); //Rotate\n\n    //--------\n    \n    float yID0 = p.y; //Calculate ID for rotation direction.\n    float yR0 = yID0 > 0. ? 1. : -1.;\n    \n    p.y = abs(p.y) - 1.5; //Domain repeat.\n    \n    float b0 = bx(p, vec3(3,1.3,3)); //Bound 0 (2-cuboid pairs)\n    b0 = abs(b0) + 0.1;\n    \n    p.xz *= rot(iTime * yR0); //Rotate\n    \n    //--------\n    \n    float c0 = bx(p, vec3(2,1,1)); //Actual cuboid that's being rendered\n    c0 = min(b0, c0); //bound it..\n    c0 = min(b1, c0); //bound it...\n    c0 = min(b2, c0); //bound it again..\n    c0 = min(b3, c0); //and again...\n    c0 = min(b4, c0); //and again....\n\n    return c0; //return cube distance\n}\n\nfloat tr(vec3 ro, vec3 rd) //ultra basic raymarcher\n{\n    float d = 0.;\n    for(int i = 0; i < 512; i++)\n    {\n        float s = mp(ro + rd * d);\n        d += s;\n        if(s < 0.01 || d > 64.) break;\n    }\n    return d;\n}\n\nvec3 nm(vec3 p) //standard 3-tap normal calculation, inlined\n{\n    vec2 e = vec2(0.001,0); return normalize(mp(p) - vec3(mp(p - e.xyy),mp(p - e.yxy),mp(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n   \n    vec3 ro = vec3(0,0,-25);\n    ro.xz *= rot(iTime/2.);\n    \n    //some camera look direction code i grabbed real quick so I can easily move the camera around\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.99)+uv.x*r+uv.y*cross(f,r));    \n    \n    float h = tr(ro,rd); //distance\n    vec3 p = ro + rd * h; //position\n    \n    if(h < 64.) //lighting\n    {\n        vec3 n = nm(p);\n        vec3 l = vec3(0.5, 0.6, 0.7);\n        \n        float diff = length(n*l); //ultra basic tri-planer-axis-lighting-stuff idk but it works well\n\n        fragColor = vec4(diff);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}