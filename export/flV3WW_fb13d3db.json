{"ver":"0.1","info":{"id":"flV3WW","date":"1637709198","viewed":53,"name":"Prime Radiant","username":"marcelliino","description":"Crystal Cubeoctahedron","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---------- math consts ----------//\n\nconst float Pi = 3.1415926535;\nconst float e = 2.7182818284;\nconst float Gr = 1.6180339887;\n\n\n//---------- math equations ----------//\n\n#define nsin(n) (sin(n)*0.5+0.5)\n#define ncos(n) (cos(n)*0.5+0.5)\n#define ntan(n) (tan(n)*0.5+0.5)\n#define rad(deg) (deg*Pi/180.0)\n\n\n//---------- math functions ----------//\n\nfloat ndot(vec2 a, vec2 b){\n    return a.x*b.x-a.y*b.y;\n}\n\nvec2 scale(vec2 position, vec2 scale){\n    scale = vec2(scale.x == 0.0 ? 1.0 : scale.x, scale.y == 0.0 ? 1.0 : scale.y);\n    return position*mat2x2(1.0/scale.x, 0.0, 0.0, 1.0/scale.y);\n}\n\nvec2 texScale(vec2 position, vec2 reso, bool vertical){\n    float ratio = vertical ? reso.x/reso.y : reso.y/reso.x;\n    return position*mat2x2(ratio, 0.0, 0.0, -1.0)+0.5;\n}\n\nvec2 rotate(vec2 position, float angle){\n    return position*mat2x2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 stare(vec2 position, vec2 origin, vec2 target){\n    float angle = atan(target.y-origin.y, target.x-origin.x);\n    return rotate((position-origin), -angle);\n}\n\n//vec4 multiMix(vec4 item[], const int n, float m){\n//    vec4 items = item[0];\n//    for(int i = n-1; i >= 0; i--){\n//        items = mix(item[i], items, smoothstep(float(i), float(i)+1.0, m*(n-1)));\n//    }\n//    return items;\n//}\n\nfloat factorial(float n){\n    float f = n;\n    for(float i = 1.0; i < n-1.0; i+=1.0){\n        f = f*(n-i);\n    }\n    return f;\n}\n\n#define facto(n) factorial(n)\n\nfloat binomialCoefficient(float n, float k){\n    if(k < 1.0 || k == n){\n        return 1.0;\n    } else {\n        return facto(n)/(facto(k)*facto(n-k));\n    }\n}\n\n#define binoCo(n, k) binomialCoefficient(n, k)\n\n//vec2 bezier(vec2 p[], const int n, float t){\n//    vec2 B = 0.0;\n//    for(int i = 0; i < n; i++){\n//        B += binoCo(n, i)*pow(1.0-t, n-i)*pow(t, i)*p[i];\n//    }\n//    B += pow(t, n)*p[n-1];\n//    return B;\n//}\n\nvec2 cubicBezier(vec2 a, vec2 b, vec2 c, vec2 d, float t){\n    return pow(1.0-t, 3.0)*a+pow(1.0-t, 2.0)*3.0*t*b+(1.0-t)*3.0*pow(t, 2.0)*c+pow(t, 3.0)*d;\n}\n\nfloat hash21(vec2 n){\n    n = fract(n*vec2(278.91, 530.46));\n    n += dot(n, n+(Gr*e));\n    return fract(n.x*n.y);\n}\n\n\n//---------- 2D primitives -----------//\n\nfloat circle(vec2 position, float radius){\n    return step(radius, length(position));\n}\n\nfloat vesica(vec2 position, float radius, float dist){\n    position = abs(position);\n    dist = clamp((1.0-dist)*radius, 0.0, 1.0);\n    float b = sqrt(radius*radius-dist*dist);\n    return (position.y-b)*dist > position.x*b\n        ? step(0.0,length(position-vec2(0.0,b)))\n        : step(0.0,length(position-vec2(-dist,0.0))-radius);\n}\n\nfloat line(vec2 position, vec2 a, vec2 b, float w){\n    float t = clamp(dot(position-a, b-a)/dot(b-a, b-a), 0.0, 1.0);\n    float d = length((position-a) - (b-a)*t);\n    return step(w/10.0, d);\n}\n\nfloat rect(vec2 position, vec2 scale){\n    position = abs(position);\n    vec2 shape = vec2(step(scale.x, position.x), step(scale.y, position.y));\n    return max(shape.x, shape.y);\n}\n\n//---------- old method to create rounded corner rectangle ----------//\n//float rect(vec2 position, vec2 scale, float radius){\n//    radius = clamp(radius, 0.0, 1.0)*min(scale.x, scale.y);\n//    float shape = rect(position, scale);\n//    for(float i=-1.0;i<=1.0;i+=2.0){\n//        for(float j=-1.0;j<=1.0;j+=2.0){\n//            float pcorner = rect(rotate((position+vec2(scale.x*i,scale.y*j)), rad(45.0)), radius*0.75);\n//            float rcorner = circle(position+vec2((scale.x-radius)*i,(scale.y-radius)*j),radius);\n//            shape = min(max(shape, 1.0-pcorner), rcorner);\n//        }\n//    }\n//    return shape;\n//}\n\nfloat rect(vec2 pos, vec2 scale, float radius){\n    vec2 d = abs(pos)-vec2(scale-radius*min(scale.x, scale.y));\n    float shape = length(max(d,vec2(0.0)))+min(max(d.x, d.y), 0.0);\n    return step(radius*min(scale.x, scale.y), shape);\n}\n\nfloat rhombus(vec2 position, vec2 scale){\n    vec2 q = abs(position);\n    float h = clamp((-2.0*ndot(q, scale)+ndot(scale, scale))/dot(scale, scale), -1.0, 1.0);\n    float d = length(q-0.5*scale*vec2(1.0-h, 1.0+h));\n    return step(0.0, d*sign(q.x*scale.y + q.y*scale.x - scale.x*scale.y));\n}\n\nfloat poly(vec2 position, float apothem, float sides){\n    position = rotate(position, Pi);\n    float angle = atan(position.x, position.y);\n    float slice = Pi * 2.0 / sides;\n    return step(apothem, cos(floor(0.5 + angle / slice) * slice - angle) * length(position));\n}\n\nfloat poly(vec2 position, float apothem, float sides, float round){\n    sides = clamp(floor(sides+0.5), 3.0, 15.0);\n    round = clamp(round, 0.0, 1.0);\n    float shape = poly(position, apothem, sides);\n    float radius = apothem/cos(Pi/sides);\n    float offset = cos(Pi/sides)*(round*apothem);\n    float cutter = poly(rotate(position, Pi/sides), radius*(1.0-round)+offset, sides);\n    shape = max(shape, cutter);\n    if(int(sides) % 2 == 0) position = rotate(position, Pi/sides);\n    for(int i = 0; i < int(sides); i++){\n        position = rotate(position, 2.0*Pi/sides);\n        shape = min(shape, max(circle(position-vec2(0.0, radius*(1.0-round)), round*apothem), 1.0-cutter));\n    }\n    return shape;\n}\n\n\n//---------- other 2D shapes ----------//\n\nfloat wave(vec2 position, float f, float a){\n    return step(position.y+cos(position.x*f)*a, 0.0);\n}\n\n\n//---------- procedural patterns ------//\n\nfloat hypno(vec2 position, float size){\n    size *= 10.0;\n    float shape = circle(position, size/10.0);\n    for(float i = size-1.0 ; i > 0.0 ; i--){\n        if(int(size) % 2 != 0){\n            if(int(i) % 2 == 0){\n                shape = max(shape, 1.0-circle(position, i/10.0));\n            }else{\n                shape = min(shape, circle(position, i/10.0));\n            }\n        }else{\n            if(int(i) % 2 != 0){\n                shape = max(shape, 1.0-circle(position, i/10.0));\n            }else{\n                shape = min(shape, circle(position, i/10.0));\n            }\n        }\n    }\n    return shape;\n}\n\nfloat hypno(vec2 position, float size, float side){\n    size *= 10.0;\n    float shape = poly(position, size/10.0, side);\n    for(float i = size-1.0 ; i > 0.0 ; i--){\n        if(int(size) % 2 != 0){\n            if(int(i) % 2 == 0){\n                shape = max(shape, 1.0-poly(position, i/10.0, side));\n            }else{\n                shape = min(shape, poly(position, i/10.0, side));\n            }\n        }else{\n            if(int(i) % 2 != 0){\n                shape = max(shape, 1.0-poly(position, i/10.0, side));\n            }else{\n                shape = min(shape, poly(position, i/10.0, side));\n            }\n        }\n    }\n    return shape;\n}\n\nfloat maze(vec2 pos, float thck){\n    pos = rotate(pos, rad(45.0));\n    vec2 blck = fract(pos)-0.5;\n    blck.x *= hash21(floor(pos)) > 0.5 ? -1.0 : 1.0;\n    float wall = step(mix(0.05, 0.45, thck), abs(abs(blck.x-blck.y)-0.5));\n    return wall;\n}\n\nfloat houndstooth(vec2 pos){\n    vec2 id = abs(floor(pos+0.5));\n    float pattern = sign(sin((pos.x-pos.y)/0.5*Pi)-mod(id.x+id.y, 2.0)/0.5)*(mod(id.x, 2.0)/0.5-1.0);\n    return pattern;\n}\n\n\n//---------- color formulas ----------//\n\n#define uRGB(r, g, b) vec3(r, g, b)/255.0\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z+(q.w-q.y)/(6.0 * d+e)), d/(q.x+e), q.x);\n}\n\n#define uHSB(h, s, b) vec3(h/360.0, s/100.0, b/100.0)\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx+K.xyz) * 6.0-K.www);\n    return c.z * mix(K.xxx, clamp(p-K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//---------- color definitions -------//\n\n#define grey vec3(0.5)\n#define red vec3(1.0, 0.0, 0.0)\n#define green vec3(0.0, 1.0, 0.0)\n#define blue vec3(0.0, 0.0, 1.0)\n\n\n//---------- blend modes -------------//\n\nvec4 normal(vec4 a, vec4 b){\n    a.rgb = max(a.rgb, 1.0-b.a);\n    return min(a, b);\n}\nvec4 multiply(vec4 a, vec4 b){\n    return vec4((a*b).rgb, b.a);\n}\nvec4 linearBurn(vec4 a, vec4 b){\n    return vec4(((a+b)-1.0).rgb, b.a);\n }\nvec4 colorBurn(vec4 a, vec4 b){\n    return vec4((1.0-(1.0-a)/b).rgb, b.a);\n}\nvec4 darken(vec4 a, vec4  b){\n    return vec4(min(a, b).rgb, b.a);\n}\nvec4 lighten(vec4 a, vec4  b){\n    return vec4(max(a, b).rgb, b.a);\n}\nvec4 screen(vec4 a, vec4 b){\n    return vec4((1.0-(1.0-a)*(1.0-b)).rgb, b.a);\n}\nvec4 add(vec4 a, vec4 b){\n    return vec4((a+b).rgb, b.a);\n}\nvec4 colorDodge(vec4 a, vec4 b){\n    return vec4((a/(1.0-b)).rgb, b.a);\n}\nvec4 overlay(vec4 a, vec4 b){\n    vec4 c = vec4(0.0);\n    c.r = a.r < 0.5 ? multiply(a, 2.0*b).r : screen(a, 2.0*(b-0.5)).r;\n    c.g = a.g < 0.5 ? multiply(a, 2.0*b).g : screen(a, 2.0*(b-0.5)).g;\n    c.b = a.b < 0.5 ? multiply(a, 2.0*b).b : screen(a, 2.0*(b-0.5)).b;\n    c.a = b.a;\n    return normal(a, c);\n}\nvec4 hardLight(vec4 a, vec4 b){\n    vec4 c = vec4(0.0);\n    c.r = b.r < 0.5 ? multiply(a, 2.0*b).r : screen(a, 2.0*(b-0.5)).r;\n    c.g = b.g < 0.5 ? multiply(a, 2.0*b).g : screen(a, 2.0*(b-0.5)).g;\n    c.b = b.b < 0.5 ? multiply(a, 2.0*b).b : screen(a, 2.0*(b-0.5)).b;\n    c.a = b.a;\n    return normal(a, c);\n}\n\nvec4 softLight(vec4 a, vec4 b){\n    return normal(a, vec4(((1.0-2.0*b)*a*a+2.0*b*a).rgb, b.a));\n}\nvec4 vividLight(vec4 a, vec4 b){\n    vec4 c = vec4(0.0);\n    c.r = b.r < 0.5 ? colorBurn(a, 2.0*b).r : colorDodge(a, 2.0*(b-0.5)).r;\n    c.g = b.g < 0.5 ? colorBurn(a, 2.0*b).g : colorDodge(a, 2.0*(b-0.5)).g;\n    c.b = b.b < 0.5 ? colorBurn(a, 2.0*b).b : colorDodge(a, 2.0*(b-0.5)).b;\n    c.a = b.a;\n    return normal(a, c);\n}\nvec4 linearLight(vec4 a, vec4 b){\n    vec4 c = vec4(0.0);\n    c.r = b.r < 0.5 ? linearBurn(a, 2.0*b).r : add(a, 2.0*(b-0.5)).r;\n    c.g = b.g < 0.5 ? linearBurn(a, 2.0*b).g : add(a, 2.0*(b-0.5)).g;\n    c.b = b.b < 0.5 ? linearBurn(a, 2.0*b).b : add(a, 2.0*(b-0.5)).b;\n    c.a = b.a;\n    return c;\n}\nvec4 pinLight(vec4 a, vec4 b){\n    vec4 c = vec4(0.0);\n    c.r = b.r < 0.5 ? darken(a, 2.0*b).r : lighten(a, 2.0*(b-0.5)).r;\n    c.g = b.g < 0.5 ? darken(a, 2.0*b).g : lighten(a, 2.0*(b-0.5)).g;\n    c.b = b.b < 0.5 ? darken(a, 2.0*b).b : lighten(a, 2.0*(b-0.5)).b;\n    c.a = b.a;\n    return normal(a, c);\n}\nvec4 hardMix(vec4 a, vec4 b){\n    return normal(a, vec4(ceil(linearLight(a, b)).rgb, b.a));\n}\nvec4 exclusion(vec4 a, vec4 b){\n    return normal(a, vec4(max(a+b-2.0*a*b, b.a).rgb, b.a));\n}\nvec4 difference(vec4 a, vec4 b){\n    return normal(a, vec4(max(abs(a-b), b.a).rgb, b.a));\n}\nvec4 subtract(vec4 a, vec4 b){\n    return normal(a, vec4(((a+max(1.0-b, b.a))-1.0).rgb, b.a));\n}\nvec4 divide(vec4 a, vec4 b){\n    return normal(a, vec4((a/b).rgb, b.a));\n}\n\n#define multiply(a, b) normal(a, multiply(a, b))\n#define linearBurn(a, b) normal(a, linearBurn(a, b))\n#define colorBurn(a, b) normal(a, colorBurn(a, b))\n#define darken(a, b) normal(a, darken(a, b))\n#define lighten(a, b) normal(a, lighten(a, b))\n#define screen(a, b) normal(a, screen(a, b))\n#define add(a, b) normal(a, add(a, b))\n#define colorDodge(a, b) normal(a, colorDodge(a, b))\n#define linearLight(a, b) normal(a, linearLight(a, b))\n\n\n//---------- filters -----------------//\n\nvec3 pixelate(vec2 position, float resolution){\n    resolution *= 50.0;\n    float dots = circle(fract(position*resolution-0.5)-0.5, 0.45);\n    return vec3(floor(position*resolution+0.5)/resolution, dots);\n}\n\n\n//---------- effects -----------------//\n\nvec3 liquid(vec2 position, float mult, vec2 time){\n    float len;\n    for(int i = 0; i < int(mult); i++){\n    len = length(position);\n    position.x = position.x + sin(position.y + cos(len-pow(ncos(len), mult/2.0))) + cos(time.x);\n    position.y = position.y - cos(position.x + sin(len-pow(nsin(len), mult/2.0))) + sin(time.y);\n    }\n    return vec3(position, len);\n}\n\nvec2 kaleid(vec2 position, int k){\n    float angle = Pi;\n    for(int i = 1; i < k; i++){\n        vec2 N = vec2(sin(angle), cos(angle));\n        if(dot(position, N) > 0.0) position = reflect(position, N);\n        angle /= 2.0;\n    }\n    return position;\n}\n\n\n//--------------------------------------------------//\n\n\n#define MAX_STEPS 200.0\n#define MAX_DIST 100.0\n#define SURF_DIST 0.03125\n\n//---------- math functions ----------//\n\nvec3 rotate(vec3 p, vec3 a){\n    p.yz = rotate(p.yz, a.x);\n    p.xz = rotate(p.xz, a.y);\n    p.xy = rotate(p.xy, a.z);\n    return p;\n}\n\nfloat suni( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h); }\n\nfloat sint( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \n    \nfloat extrude( in vec3 p, in float primitive, in float h ) {\n    float d = primitive;\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n//---------- 3D primitives -----------//\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat cylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat capsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat box(vec3 p, vec3 s){\n    p = abs(p)-s;\n    return length(max(p, 0.0))+min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat boxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat torus(vec3 p, vec2 r){\n    vec2 q = vec2(length(p.xz)-r.x, p.y);   \n    return length(q)-r.y;\n}\n\nfloat cone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat octahedron( vec3 p, float s){\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n\n  float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n  return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\n//---------- ray marcher ----------//\n\n\nfloat colorIntensity = 1.0;\nvec3 difColor = vec3(1.0);\n\n//3Dsketch//\n\nvec4 getDist(vec3 p){\n    \n    vec4 obj = vec4(1.0);\n    \n    p = rotate(p, vec3(Pi/8.0 * cos(iTime/8.0), -iTime/4.0, 0.0));\n    \n    float gem = octahedron(p, 8.0);\n    gem = max(box(p, vec3(4.0)), gem);\n    \n    float n = octahedron(p, 6.0);\n    n = max(n, box(p, vec3(3.0)));\n    n = max(n, -box(rotate(p, vec3(Pi/4.0, 0.0, 0.0)), vec3(3.6, 1.8, 1.8)));\n    n = max(n, -box(rotate(p, vec3(0.0, Pi/4.0, 0.0)), vec3(1.8, 3.6, 1.8)));\n    n = max(n, -box(rotate(p, vec3(0.0, 0.0, Pi/4.0)), vec3(1.8, 1.8, 3.6)));\n    n = max(n, -box(p, vec3(2.8)));\n    \n    n = min(n, boxFrame(rotate(p, vec3(0.0, Pi/1.0, 0.0)), vec3(2.5), 0.125));\n    \n    p.xz = rotate(p.xz, Pi/4.0);\n    n = min(n, max(box(rotate(p, vec3(0.0, Pi/4.0, 0.0)), vec3(1.5)), sphere(p, 2.0)));\n    \n    p.xz = rotate(p.xz, Pi/4.0);\n    for(float a = 0.0 ; a < 3.0 ; a += 1.0){\n        if(a > 0.0) p.xy = rotate(p.xy, Pi/2.0);\n        if(a > 1.0) p.yz = rotate(p.yz, Pi/2.0);\n        n = max(n, -cylinder(p, 1.0, 3.0));\n    }\n    n = max(n, -sphere(p, 1.5));\n    \n//    n = min(n, torus(rotate(abs(p)-vec3(vec2(1.5), 0.0), vec3(Pi/2.0, vec2(0.0))), vec2(1.0, 0.0)+0.125));\n    \n    gem = max(gem, -n);\n    \n    obj.a = gem + 1.0/64.0;\n    \n    return obj;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, inout vec3 dColor, float side){\n    float dO = 0.0;\n    \n    for(int i=0; i<int(MAX_STEPS); i++){\n        \n        if(dO > MAX_DIST) break;\n        vec3 p = ro+rd * dO;\n        vec4 dS = getDist(p) * side;\n        if(dS.a < SURF_DIST){ dColor = dS.rgb; break; }\n        dO += dS.a;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p){\n    float d = getDist(p).a;\n    vec2 e = vec2(0.001, 0.0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).a,\n        getDist(p-e.yxy).a,\n        getDist(p-e.yyx).a\n    );\n    \n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 l, vec3 c, float luminos){\n    \n    vec3 color = c.rgb * colorIntensity;\n    \n    luminos = clamp(luminos, 0.0, 1.0);\n    l = normalize(l-p) * luminos;\n    vec3 n = getNormal(p);\n    \n    float\n    dif = clamp(dot(n, l) , 0.0, 1.0),\n    d = rayMarch(p+n * SURF_DIST * 2.0, l, difColor, 1.0);\n    \n    if(d<length(l-p)) dif *= 0.1;\n    \n    return color * dif/luminos;\n}\n\nvec3 Bg(vec3 rd){\n    float k = rd.y * 0.5+0.5;\n    vec3 col = vec3(mix(0.25, 0.125, k));\n    return col;\n}\n\n\n//--------------------------------------------------//\n\n\nfloat chromaKey(vec4 image, vec4 colorKey, float threshold, float S){\n    \n    float maskY = 0.2989 * colorKey.r + 0.5866 * colorKey.g + 0.1145 * colorKey.b;\n    float maskCr = 0.7132 * (colorKey.r - maskY);\n    float maskCb = 0.5647 * (colorKey.b - maskY);\n    \n    float Y = 0.2989 * image.r + 0.5866 * image.g + 0.1145 * image.b;\n    float Cr = 0.7132 * (image.r - Y);\n    float Cb = 0.5647 * (image.b - Y);\n    \n    threshold = pow(threshold, 6.0);\n    return smoothstep(threshold, threshold+pow(S, 8.0), distance(vec2(Cr, Cb), vec2(maskCr, maskCb)));\n    \n}\n\n\n//--------------------------------------------------//\n\n#define res iResolution\n#define mouse iMouse\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-1.0 + 2.0 * fragCoord/res.xy) * vec2(res.x/res.y, 1.0);\n    vec4 col = vec4(vec3(1.0), 1.0);\n    \n    vec2 m = mouse.xy/res.xy;\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    \n    float\n        zoom = -2.0,\n        fov = 4.0\n    ;\n    \n    ro.z = zoom-(fov-1.0)/0.125;\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, fov));\n    \n    \n    ro = rotate(ro, vec3(1.0-m.y * Pi, -m.x * 2.0 * Pi, 0.0));\n    rd = rotate(rd, vec3(1.0-m.y * Pi, -m.x * 2.0 * Pi, 0.0));\n    \n    float d = rayMarch(ro, rd, difColor, 1.0);\n    \n    float lumin = 1.0;\n    \n    vec3 bg = texture(iChannel0, rd).rgb;\n    \n    vec4 canvas = vec4(bg, 0.0);\n    \n    float mask = 0.0;\n    if(d < MAX_DIST) {\n        vec3 p = ro+rd * d;\n        vec3 n = getNormal(p);\n        \n        vec3 rfl = reflect(rd, n);\n        vec3 rfc = refract(rd, n, 1.0/1.25);\n        \n        vec3 dif = getLight(p, ro, difColor, lumin);\n        dif = clamp(dif, 0.0, 1.0);\n        \n        mask = 1.0-step(0.0, length(dif));\n        \n        canvas.rgb = dif;\n        \n        \n        vec4 ref = vec4(1.0);\n        \n        \n        //--\n        \n        vec3 rdIn = refract(rd, n, 1.0/1.2);\n        \n        vec3 pEnter = p - n * SURF_DIST * 6.0;\n        float dIn = rayMarch(pEnter, rdIn, difColor, -1.0);\n        \n        vec3 pExit = pEnter + rdIn * dIn;\n        vec3 nExit = -getNormal(pExit); \n        \n        vec3 rdOut = refract(rdIn, nExit, 1.2 - 1.0/512.0);\n        \n        if(dot(rdOut, rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n        \n        \n        ref.r = texture(iChannel0, rdOut).r;\n        \n        rdOut = refract(rdIn, nExit, 1.2);\n        if(dot(rdOut, rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n        \n        ref.g = texture(iChannel0, rdOut).g;\n        \n        rdOut = refract(rdIn, nExit, 1.2 + 1.0/512.0);\n        if(dot(rdOut, rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n        \n        ref.b = texture(iChannel0, rdOut).b;\n        \n        //--\n        \n        canvas.rgb = ref.rgb;\n        canvas = softLight(canvas, vec4(dif, 0.0));\n        \n        canvas = max(clamp(canvas, 0.0, 1.0), mask);\n    }\n    \n    col.rgb = normal(col, canvas).rgb;\n    \n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n    \n    col = texture(iChannel0, rayDir).rgb;\n    col = mix(col, smoothstep(0.25, 0.75, vec3(col.r+col.g+col.b)/3.0), 0.25);\n    \n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}