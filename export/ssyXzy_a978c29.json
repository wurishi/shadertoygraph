{"ver":"0.1","info":{"id":"ssyXzy","date":"1634832688","viewed":157,"name":"AngularSeg","username":"spalmer","description":"optimized my angular pill function, now using dot products, even faster!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cross","segment","pill","capsule","golf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// computes a perspective-corrected form of distance\n// to a 3d line segment or capsule, but, uh, angularly?\n\n// if you want to understand the theory behind this,\n// first grok Angular Distance http://shadertoy.com/view/sdGXzK\n\n// another simple example of use is\n// Angular Tetrahedra at http://shadertoy.com/view/7sGXRV\n\n// view/query vector d assumed unit length throughout\n\n// I figure it's good for simple line drawings\n// or for use as a bounding capsule intersection test\n\nfloat sqr(float v) { return v*v; }\nfloat sqr(vec2 v) { return dot(v,v); }\nfloat sqr(vec3 v) { return dot(v,v); }\nfloat ssqr(float v) { return v*abs(v); }\nfloat ssqrt(float v) { return sqrt(abs(v)) * sign(v); }\n\n// this is a really old HACK of mine\n// just cleaned up and golfed a bit.\n// calculated \"angularly\" with cross products.  Bizarre.\n// it's weird and midpoint-y and I'm unsure even I\n// understand how it works, completely. \n// But it's equivalent to angularSeg2!\n// I think it projects the vectors flat perpendicular to d vector\n// and works from there.  Same approach works for splines etc.\nfloat angularSeg(vec3 d, vec3 a, vec3 b)\n{\n    vec3 x = cross(d, (b + a) * .5)\n\t, m = (cross(d, a) - cross(d, b)) * .5;\n    return sqr(x - m * clamp(dot(x, m) / dot(m, m), -1., 1.));\n}\n\n// d is the ray direction vector, relative to origin\n// a and b are the segment end points, relative to origin\n// some day I must document the other 1 letter local variable identifiers!\n\n// the perspective is still fake as heck,\n// well actually it's, like, accurate,\n// based on what I tested over in Angular Distance.\n// and there seems to be some sort of visual\n// bend or kink in the shape near where\n// I approx the center distance.  But I think that\n// is simply bad gamma correction on the linear ramp!\n// cross followed by length takes perpendicular distances\n// which is basically what we're after, so\n// seems what I have done is implement a screwball form\n// of 3d segment distance, but in this cross-d space.\n\n// want to hear something really bizarre?\n// I get the same image using angularSeg\n// as I do using angularSeg2!  which both\n// validates that this \"works\", I guess, but\n// also that angularSeg was in fact computing the actual distance somehow?\n// because this is computing distance.\n// it's been so long since I made the original I forgot\n// precisely how it worked in the first place,\n// but that must have been how I got there originally.\n// just via different construction...\n// moved the segment calculation into the cross-d space relative origin.\n// iirc I started with a simple angularly-computed disc\n// then noticed \"hey, I can make this perspective corrected\n// by removing a sqrt\" and wound up with Angular Distance\n// then later was fiddling with 3d line vs. line stuff\n// and merged the techniques together.  I did\n// infinite \"rods\" first then later learned how to make\n// segments, then I shifted to the midpoint parameterization\n// to make \"swept dots\" for like fake motion blur.\n// Anyway I think I sorted it back out now to simple segments.\n\nfloat angularSeg2(vec3 d, vec3 a, vec3 b)\n{\n    // a completely different idea, simpler even.\n    // project the 2 points to 2d along the infinite line d\n    // looking down d, the 2d coordinate system is the distances we want\n    // must transform everything d relative\n    // all this transformation will wind up making algo too big though.\n    // transform into a 2d segment problem with d as the origin\n    // it seems it would be far easier to construct an\n    // orthogonal basis to d first, then the transformation would be simple.\n    // there's various ways could do that, simpler is better\n    // if d is +Z, unit length, we need +X and +Y\n    vec3 u = d.yzx; u.z = -u.z; //vec3 u = d.zxy; u.x = -u.x; //\n    vec3 v = normalize(cross(u, d)); u = cross(d, v); // being more careful than I usually am here\n    //vec3 v = normalize(cross(d, u)); // because usually I would assume u is already unit length and perpendicular to d - doesn't work though\n    \n    vec2 a2 = vec2(dot(a, u), dot(a, v)), b2 = vec2(dot(b, u), dot(b, v));\n    // now it's a 2d segment problem, can use iq's traditional segment distance formula\n    // one problem is that's usually posed relative to a; I have relative to q\n    //argh, just go back to that way\n    vec2 q2 = -a2; b2 -= a2;\n    // do 2d segment calculation iq way to find nearest point on segment to origin\n    return sqr(q2 - b2 * clamp(dot(b2, q2) / dot(b2, b2), 0., 1.));\n    // now perspective project that distance by the distance along the view ray\n    // wait!! already done somehow by the above.  I mean, it looks correct already!\n    // before I proceed, I should somehow determine how the heck I\n    // managed to get the perspective effect, without any division by distance.\n}\n    // or I can keep going or try different ways\n\n// SURELY that can be simplified!\n// in fact I'm sure if I simply fed it all into Maxima,\n// that it would just spit out the reduced equation.\n\n// tried this morning when I had coffee and still failed!\n\n// BUT I had a breakthrough and now\n// one of the 0.5 kludges has been removed\n\nfloat angularSeg3(vec3 d, vec3 a, vec3 b)\n{\n    vec3 x = cross(d, (b + a) * .5)\n\t, m = cross(d, a) - cross(d, b); // removing .5 here doubles length of segment! don't want that.  So must cancel out some other way\n    return sqr(x - m * clamp(dot(x, m) / dot(m, m), -.5, .5)); // oh, DUH!  how easy is that!\n}\n\n// my main goal is to simply\n// remove the midpoint stuff from angularSeg\n// and bias it such that the clamp works 0..1 instead of -1..1\n// that should eliminate some work and simplify things\n// so that it only involves the endpoints\n\nfloat angularSeg4(vec3 d, vec3 a, vec3 b)\n{\n    vec3 x = cross(d, a), m = x - cross(d, b);\n    return sqr(x - m * clamp(dot(x, m) / dot(m, m), .0, 1.));\n}\n\n// oh, come on!  It can't be that easy.  Surely someone has done this before!\n\nfloat angularSeg5(vec3 d, vec3 a, vec3 b)\n{\n    a = cross(d, a), b = cross(d, b);\n    vec3 m = b - a;\n    m = mix(b, a, clamp(dot(b, m) / dot(m, m), .0, 1.)); \n    return sqr(m);\n}\n\n\n\n#if 1\n// BTW turns out, iq has been doing this for a long time,\n// his approach seems VERY similar to what I wound up with here.\n// that's a good sign, means I am on the right track!\n\n// extreme cleaning of iq http://shadertoy.com/view/4slGz4\nfloat angularSegIq(vec3 d, vec3 a, vec3 b)\n{\n    vec3 f = d*dot(a,d) - a, // reject a from d, dot product style, is the same as cross(d,a) I think...\n         e = d*dot(b,d) - b - f; // reject b also, relative to a\n    return sqr(f + e*clamp(-dot(f,e) / dot(e,e), 0., 1.));\n}\n// cleans up real nice, seems like perpendicular projections may still not be optimal and some signs could use cancelling\n// it has potential, I just don't really understand it yet.\nfloat angularSegIq2(vec3 d, vec3 a, vec3 b)\n{\n    vec3 f = d*dot(a,d) - a, //cross(d,a), // same!\n         e = d*dot(b,d) - b - f; //cross(d,b) - f; // same!\n    return sqr(f - e*clamp(dot(f,e) / dot(e,e), -1., 0.)); // TODO eliminate minus sign\n}\n// I hope Inigo appreciates my efforts here.\n#endif\n// iq prefers to also return the useful index parameter along segment nearest ray.\n// SO!  it turns out iq's, while quite clever, actually is\n// still based on the cross vectors somehow, just computes them more efficiently.\n// Hrmm.  all the minus signs get confusing and surely at least one of them can be eliminated.\n// TODO I am extremely curious to see just how close this is to iq's uneven capsule calculation.\n\n// trying bloxard's idea from http://shadertoy.com/view/tslXRj\n#if 1\n// Copyright Per Bloksgaard, 2019 - http://perbloksgaard.dk\n// shortest distance between a ray and a line segment in 3D\nfloat RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)\n{\n\tfloat bL = length(lE-lS);\n\tvec3 bD = (lE-lS)/bL;\n\tvec3 tD = lS-rP;\n\tfloat aDb = dot(rD,bD);\n\tfloat aDt = dot(rD,tD);\n\tfloat bDt = dot(bD,tD);\n\tfloat u = (aDt-bDt*aDb)/(1.-aDb*aDb);\n\tfloat v = max(min(u*aDb-bDt,bL),0.);\n\tu = max(min(v*aDb+aDt,1e6),0.);\n\treturn sqr((rP+rD*u)-(lS+bD*v));\n}\n// sometimes I wonder if keeping the ray origin as a parameter\n// is the better interface.  But for this toy it's pre-subtracted.\nfloat angularSegBlox0(vec3 d, vec3 a, vec3 b)\n{\n    return RayLineSegmentDistance(vec3(0), d, a, b);\n}\n#endif\n// nice!  it's exactly same result as mine.  Good comparison!\n// since does not use any cross products.  I wonder if it handles behind camera?  It does!! very nice.\n#if 1 \n// Xor from comment\n// Source: http://shadertoy.com/view/tslXRj\nfloat RayLineSegmentDistanceXor(vec3 rP, vec3 rD, vec3 lS, vec3 lE)\n{\n\tfloat bL = length(lE-lS);\n\tvec3 bD = (lE-lS)/bL;\n\tvec3 tD = lS-rP;\n\tfloat aDb = dot(rD,bD);\n\tfloat aDt = dot(rD,tD);\n\tfloat bDt = dot(bD,tD);\n\tfloat d = 1.-aDb*aDb;\n\tfloat u = (aDt-bDt*aDb)/d;\n\tfloat v = clamp(u*aDb-bDt,0.0,bL);\n\tu = max(v*aDb+aDt,0.);\n\tfloat l = length((rP+rD*u)-(lS+bD*v));\n\t\n\tvec3 p = rD;\n\tvec3 a = lS-rP;\n\tvec3 b = lE-rP;\n\tl = min(l,length(p*length(a)-a));\n\tl = min(l,length(p*length(a)-a));\n\t\n\treturn  l;\n}\nfloat angularSegXor(vec3 d, vec3 a, vec3 b)\n{\n    return RayLineSegmentDistanceXor(vec3(0), d, a, b);\n}\n#endif\n\n// just cleaning up bloxard's so I can grok it easier\nfloat angularSegBlox1(vec3 d, vec3 a, vec3 b)\n{\n    vec3 w = b - a;\n\tfloat l = length(w);\n\tvec3 n = w / l;\n\tfloat dn = dot(d, n),\n\t  da = dot(d, a),\n\t  na = dot(n, a),\n\t  u = (da - na * dn) / (1. - dn * dn),\n\t  v = clamp(u * dn - na, 0., l);\n\tu = v * dn + da; // re-solve projection after clamping other\n    //u = max(u, 0.); // optionally guard against segment going behind camera ray;\n    // should not be optional, but in this toy the other methods don't do it,\n    // so I disabled this quite useful feature just for fair comparison.\n\treturn sqr(a + v * n - u * d);\n}\n// so far so good\n\n// redid Bloxaard's identifiers -- again?!\nfloat angularSegBlox2(vec3 d, vec3 a, vec3 b)\n{\n    vec3 ab = b - a;\n\tfloat L = length(ab);\n\tvec3 c = ab / L;\n\tfloat dc = dot(d, c),\n\t  da = dot(d, a),\n\t  ca = dot(c, a),\n\t  u = (da - ca * dc) / (1. - dc * dc),\n\t  v = max(min(u * dc - ca, L), 0.);\n\tu = min(v * dc + da, 1e6);\n\t//u = max(u, 0.); // guard vs segment behind camera\n    return sqr(d * u - a - c * v);\n}\n\nfloat angularSeg9(vec3 d, vec3 a, vec3 b)\n{\n    vec3 w = b - a;\n\tfloat l = length(w);\n\tvec3 n = w / l;\n\tfloat m = dot(d, n),\n\t  e = dot(d, a),\n\t  f = dot(n, a),\n\t  u = (e - f*m) / (1. - m*m),\n\t  v = clamp(u*m - f, 0., l);\n\tu = v*m + e;\n    //u = max(u, 0.); // guard vs segment behind camera\n\treturn sqr(a + v*n - u*d);\n}\n\nfloat angularSeg10(vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n\tfloat l = length(n);\n\tfloat m = dot(d, n) / l,\n\t  e = dot(d, a),\n\t  f = dot(n, a) / l,\n\t  u = (e - f*m) / (1. - m*m),\n\t  v = clamp(u*m - f, 0., l);\n\tu = v*m + e;\n    //u = max(u, 0.); // guard vs segment behind camera\n\treturn sqr(a + v / l*n - u*d);\n}\n\n// start with the pre-clamped computation of v:\n//  u*m - f\n// now substitute and expand\n//  (dot(d, a) - dot(n, a) / l*m) / (1. - m*m)*m - dot(n, a) / l\n// get rid of l too\n//  (dot(d, a) - dot(n, a) / sqrt(n . n)*m) / (1. - m*m)*m - dot(n, a) / sqrt(n . n)\n// substitute m also which is dot(d, n) / sqrt(dot(n, n))\n// (((d . a) - (n . a) / sqrt(n . n) * (d . n) / sqrt(n . n)) / (1 - (d . n) / sqrt(n . n) * (d . n) / sqrt(n . n)))* (d . n) / sqrt(n . n) - (n . a) / sqrt(n . n);\n//  ((d . a) - (n . a) / sqrt(n . n) * (d . n) / sqrt(n . n)) / (1 - (d . n) / sqrt(n . n) * (d . n) / sqrt(n . n)) * (d . n) / sqrt(n . n) - (n . a) / sqrt(n . n)\n// WOW Maxima did a number on that:\n//    -->\n// |n| * ((d . a)*(d . n) - (n . a)) / ((n . n) - (d . n)^2)\n\nfloat angularSeg11(vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float nn = dot(n, n),\n\t  m = dot(d, n),\n\t  e = dot(d, a),\n\t  f = dot(n, a),\n      v = clamp((e * m - f) / (nn - m * m), 0., 1.),\n\t  u = v * m + e;\n\t//u = max(u, 0.); // guard vs segment behind camera\n\treturn sqr(a + v * n - u * d);\n}\n// YES!  getting there!\n\n#if 1\n// ollj from comments, factored out v, doesn't handle seg behind ray, no macros\nfloat angularSegOllj(vec3 d, vec3 a, vec3 b)\n{\n    vec3 n=b-a; float m=dot(d,n),e=dot(d,a);\n    return sqr(clamp((e*m-dot(n,a))/(sqr(n)-m*m),0.,1.)*(n-m*d)-e*d+a);\n}\n\n#endif\n// idk about factoring out v though.  We need to possibly return it anyway.\n// rename (m,v) --> (f,t)\nfloat angularSeg12(vec3 d, vec3 a, vec3 b)\n{\n    b -= a;\n    float f = dot(d, b),\n\t  e = dot(d, a),\n      t = clamp((e * f - dot(b, a)) / (sqr(b) - f * f), 0., 1.);\n\treturn sqr(a + t * b - d * max(t * f + e, 0.));\n}\n\nfloat angularSeg13(vec3 d, vec3 a, vec3 b)\n{\n    b -= a;\n    float f = dot(d, b),\n\t  e = dot(d, a),\n      t = (e * f - dot(b, a)) / (sqr(b) - f * f);\n    t = clamp(t, 0., 1.);\n    vec3 x = a + t * b; float l = length(x);\n    x = a + t * b;\n    return sqr(x - d * l);\n}\n\n// idk what I'm doing anymore, trying to break this down so I can \"fix\" it\nfloat angularSeg14(vec3 d, vec3 a, vec3 b)\n{\n    b -= a;\n    float f = dot(d, b),\n\t  e = dot(d, a),\n      denom = (sqr(b) - f * f),\n      t = (e * f - dot(b, a)) / denom; // index of closest point on infinite line ab to ray d\n    t = clamp(t, 0., 1.); // index of closest point on segment to ray\n    vec3 x = a + t * b; // closest point on segment\n    float y = sqr(x);\n    float g = dot(d, x);\n    return y - g * g; // AngularDistanceSquaredDotted\n//    const float tau = acos(-1.)*2.;\n//    float sine = 1. - g * g / y;\n//    return asin(sine) \n//        * sqr(tau) // true angle without distance? \n//        // * y // then mix distance back in\n//         ;\n\n    //float l = length(x); // how far from eye is that?\n    //float q = sqr(x - d*l); // sq distance to point on d at distance l\n    //return q;\n    //q = sqrt(q);\n    // could poof here but we don't\n    //return ssqr(q);\n}\n\n// I pulled this out, it might be handy:\n// index of closest point on infinite line ab to line cd\n// with 0 at a and 1 at b\nfloat indexLineLine(vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    b -= a; d -= c; a -= c;\n    float e = dot(d, a),\n      f = dot(d, b),\n\t  w = sqr(b) - f * f; // w = denom\n    return abs(w) < 1e-7 ? .5 : (e * f - dot(b, a)) / w;\n}\n\nfloat angularSeg15(vec3 d, vec3 a, vec3 b)\n{\n    float t = indexLineLine(a, b, vec3(0), d);\n    t = clamp(t, 0., 1.);\n    vec3 x = a + t * (b - a); // closest point on segment\n    float s;\n    //s = indexLineLine(vec3(0), d, a, b);\n    //if (true || s < 0.) // didn't need it after all\n        s = dot(d, x);\n    // map behind camera to infinity; works here, idk if correct generally\n    if (s < 0.) return 3e38; //s = 1e7; //3e38; //bignum\n    s = max(s, 0.);\n    vec3 y = d * s; // closest point on ray\n    return sqr(x - y); //AngularDistanceSquaredDotted(d, x); //\n    //float h = sqr(x);\n    //float g = dot(d, x);\n    //return h - g * g; // AngularDistanceSquaredDotted\n}\n// apparently the vector between the closest points will be perpendicular to both the segment and the ray\n// unless it's at an end cap\n\n// let's clean that up and inline it again\nfloat angularSeg16(vec3 d, vec3 a, vec3 b)\n{\n    b -= a;\n    float e = dot(d, a),\n      f = dot(d, b),\n\t  w = dot(b, b) - f * f;\n    vec3 x = a + b * (abs(w) < 1e-7 ? .5 : clamp((e * f - dot(b, a)) / w, 0., 1.)); // closest point on segment\n    float s = dot(d, x);\n    return s < 0. ? 3e38 // behind camera -> infinity\n        : dot(x, x) - s * s; // AngularDistanceSquaredDotted\n}\n// there, that's pretty nice\n\n// AngularSeg is not necessarily a perfect ray-segment3d distance function!!\n// it can be compared with one, it's pretty similar.  Maybe someday.\n// until then, we're still trying to return \"angular distance\" or ... basically,\n// angle in radians times distance, which works out I guess to true distance?  \n// and squared, too, anyway. even the sine is squared.  \n// avoiding sqrts was sort of the beauty of it.\n// but it certainly seems possible to go ahead and take it the rest of the way there.\n// we had squared sine of angle times squared distance, before, and if we have enough information still,\n// can obtain true angle to an arbitrary isolevel fairly easily (see block in mainImage)\n\n\n// finally let's reformulate so can obtain the true angle in radians.\n// yet also retain enough information that we can project back out to the nearest point on segment.\n// may as well calculate squared distance between ray and segment also.\nfloat angleToSeg(vec3 d, vec3 a, vec3 b, out float range, out float dd)\n{\n    float t = indexLineLine(a, b, vec3(0), d);\n    t = clamp(t, 0., 1.);\n    vec3 x = a + t * (b - a); // closest point on segment\n    float s = dot(d, x);\n    if (s < 0.) return 3e38; //1e7; // behind camera -> infinity\n    range = s;\n    float xx = sqr(x);\n    dd = xx - s * s; // AngularDistanceSquaredDotted is the clever way to obtain perp sq distance\n    return asin(sqrt(dd / xx)); // in radians\n}\n    //vec3 y = d * s; // closest point on ray\n    //dd = sqr(x - y); // another way to obtain the same perpendicular squared distance\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy;    \n    bool m = iMouse.z > 0.;    \n    vec3\n      d = normalize(vec3(p - .5*r, r.y) \n            * mat3(1,0,0, 0,.866,-.5, 0.,.5,.866))\n    //, e = vec3(0,1.7,-4) // eye\n    //, a = vec3(2.*sin(vec2(0,11) + .3*iTime), 0).xzy\n    //, b = -a\n    //a -= e+sin(iTime); //b -= e-sin(iTime*sqrt(2.)*2.-1.);\n    // ollj added mouse controls\n    , e = vec3(0,mix(1.7,4.-3.*iMouse.y/r.y,float(m)),-4) // eye \n    , a = vec3(2.*sin(vec2(0,11) + (m ? 8.*iMouse.x/r.x : .3*iTime)), 0).xzy\n    , b = -a - .5*sin(iTime-1.) * float(!m)\n    ;\n    a.z = sin(.3+.7*iTime) * 3. + 1.; // new: stress Z dimension too\n    b.z = sin(.6+1.1*iTime) * 3. + 1.;\n   #if 0\n    a = vec3(1,-1,4)*1e1; // Xor stress test\n    b = vec3(-1,1,-4)*1e1;\n   #endif\n    a -= e; b -= e;\n    float g =\n\t//    angularSeg \n    //    angularSeg2\n    //    angularSeg3\n    //    angularSeg4\n    //    angularSeg5\n    //    angularSegIq\n    //    angularSegIq2\n    //    angularSegBlox0\n    //    angularSegXor\n    //    angularSegBlox1\n    //    angularSegBlox2\n    //    angularSeg9\n    //    angularSeg10\n    //    angularSeg11\n    //    angularSegOllj\n    //    angularSeg12\n    //    angularSeg13\n    //    angularSeg14\n    //    angularSeg15\n        angularSeg16\n        (d, a, b);\n//    o = vec4(sqrt(vec2(dFdx(g),dFdy(g)) * r.y / 8. + .5),.2,1); return; // screen gradients\n    float poof = .5; //2. * (1.001+sin(.2*iTime));\n    g = sqrt(g); // un-square squared signed distance\n  #if 0\n    // correct back to angle.  almost works!\n    // seems something breaks down when angle gets too large\n    float z, ang;\n    ang = angleToSeg(d, a, b, z, g);\n    //g = sqrt(g); g -= poof; // show d^2 still works; vis scaled by distance\n    g = (ang - poof / z) * 6.28; // show angle\n    // you may notice that this produces almost the same shape as a 2D uneven capsule\n    // see also Drop Distance where I optimized iq's uneven capsule http://shadertoy.com/view/mdBcDw\n  #elif 0\n    // I had it this way at first but now it seems fairly useless and hides bunch of problems\n    g /= poof; // exhibit linear gradient center to poof radius\n    //g -= 1.;\n  #elif 1\n    g -= poof; // exhibit outline\n  #endif\n    bool inside = g < 0.;\n  #if 1\n    g = cos(.1 * r.y * g) * .15 + .5; // xor isoline vis\n  #elif 0\n    // alternate display: antialiasing mask\n    //g = .5 + .4 * r.y * g;\n    g *= r.y;\n  #endif\n    //g = clamp(g, 0., 1.);\n    o = vec4(sqrt(g)); // gamma\n    if (inside) o.rb *= .5;    \n    // show end balls    \n    //if (sqr(d * dot(d,a) - a) < poof*poof) o.gb *= .3;\n    //if (sqr(d * dot(d,b) - b) < poof*poof) o.rg *= .3;\n}","name":"Image","description":"","type":"image"}]}