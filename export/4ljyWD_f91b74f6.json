{"ver":"0.1","info":{"id":"4ljyWD","date":"1508640255","viewed":79,"name":"âˆžspheres","username":"brackss1","description":"There are only infinite spheres.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float radius = .1, EPS = .001;\n\nfloat getNLP(float x){\n    \n    return (fract(x)<.1)? floor(x) : ceil(x);\n}\n\nvec3 getNLP(vec3 p){\n    \n    return vec3(getNLP(p.x), getNLP(p.y), getNLP(p.z));\n}\n\nfloat sphereDist(vec3 p){\n    \n    return length(p - getNLP(p)) - radius;\n}\n\nfloat distFunc(vec3 p){\n    \n    return sphereDist(p);\n}\n\nvec3 normal(vec3 p){\n    \n    return normalize(vec3(\n        distFunc(p + vec3(EPS, 0., 0.)) - distFunc(p),\n        distFunc(p + vec3(0., EPS, 0.)) - distFunc(p),\n        distFunc(p + vec3(0., 0., EPS)) - distFunc(p)\n    ));\n}\n\nvec3 trace(vec3 origin, vec3 ray){\n    \n    ray = normalize(ray);\n    \n    vec3 p = origin;\n    \n    for(int i = 0; i < 32; ++i)\n         p += distFunc(p) * ray;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime/10.+10.;\n    \n    vec3 origin = vec3(t, 0., .1);\n    vec3 ray = vec3(uv, 5.);\n    vec3 light = normalize(vec3(-1., -1., 1.));\n    \n    vec3 p = trace(origin, ray);\n    \n    if(distFunc(p) < EPS){\n        float d = dot(normal(p), -light);\n        fragColor = vec4(1., vec3(d));\n    }\n    else\n        fragColor =  vec4(0., 0., 0., 1.);\n}","name":"Image","description":"","type":"image"}]}