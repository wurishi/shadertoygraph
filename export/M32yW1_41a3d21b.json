{"ver":"0.1","info":{"id":"M32yW1","date":"1727235322","viewed":14,"name":"HEC-canux-emma-zhihui","username":"zhihui","description":"santi","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["santi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#iChannel0 \"file://data/home.png\"\n//#iChannel1 \"file://data/end.png\"\n//#iChannel2 \"file://data/canon.mp3\"\n//#iChannel3 \"file://data/JudgmentDay.wav\"\n//#iChannel4 \"file://data/words.png\"\n\n// shared functions.\nvec3 drawMoon(vec3 ro, vec3 rd, vec3 position, float radius) {\n    vec3 oc = ro - position;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return vec3(0.0);\n    h = sqrt(h);\n    float t = -b - h;\n    vec3 p = ro + t * rd;\n    vec3 n = normalize(p - position);\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    float diff = max(dot(n, lightDir), 0.0);\n\n    // 计算反射向量\n    vec3 reflectDir = reflect(-lightDir, n);\n    // 计算观察向量\n    vec3 viewDir = normalize(-p);\n    // 计算镜面反射强度\n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), 32.0);\n\n    // 添加镜面反射\n    vec3 specular = vec3(1.0) * spec;\n\n    // 添加环境光\n    vec3 ambient = vec3(0.2);\n\n    // 计算最终颜色\n    vec3 color = vec3(1.0, 1.0, 0.0) * diff + specular + ambient;\n\n    return color;\n}\n\nvec2 avoidOverlap(vec2 pos1, vec2 pos2, float minDistance) {\n    vec2 direction = normalize(pos2 - pos1);\n    float distance = length(pos2 - pos1);\n    if (distance < minDistance) {\n        pos2 += direction * (minDistance - distance);\n    }\n    return pos2;\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// bad moon\nvec3 badMoon(vec2 uv) {\n    vec3 ro = vec3(0.0, 0.0, 2.0); // 观察者位置\n    vec3 rd = normalize(vec3(uv, -1.0)); // 光线方向\n\n    // 随机生成三个位置\n    float time = iTime;\n    float speed = 0.1;\n    vec2 pos1 = vec2(rand(vec2(1.0, 2.0)) * 1.6 - 0.8, rand(vec2(3.0, 4.0)) * 1.6 - 0.8);\n    vec2 pos2 = vec2(rand(vec2(5.0, 6.0)) * 1.6 - 0.8, rand(vec2(7.0, 8.0)) * 1.6 - 0.8);\n    vec2 pos3 = vec2(rand(vec2(9.0, 10.0)) * 1.6 - 0.8, rand(vec2(11.0, 12.0)) * 1.6 - 0.8);\n\n    // 计算月亮的移动轨迹\n    float radius = 0.8 * 1.5; // 修改月亮大小为现在的1.5倍\n    float angle1 = time * speed;\n    float angle2 = time * speed * 2.0;\n    float angle3 = time * speed * 3.0;\n    pos1 = vec2(cos(angle1), sin(angle1)) * radius;\n    pos2 = vec2(cos(angle2), sin(angle2)) * radius;\n    pos3 = vec2(cos(angle3), sin(angle3)) * radius;\n\n    // 确保月亮在屏幕内完整显示且不重叠\n    float moonRadius = 0.2 * 1.5; // 修改月亮大小为现在的1.5倍\n    float minDistance = 2.0 * moonRadius;\n    pos1 = clamp(pos1, vec2(-0.8), vec2(0.8));\n    pos2 = clamp(pos2, vec2(-0.8), vec2(0.8));\n    pos3 = clamp(pos3, vec2(-0.8), vec2(0.8));\n    pos2 = avoidOverlap(pos1, pos2, minDistance);\n    pos3 = avoidOverlap(pos1, pos3, minDistance);\n    pos3 = avoidOverlap(pos2, pos3, minDistance);\n\n\n    // 绘制三个月亮\n    vec3 color = drawMoon(ro, rd, vec3(pos1, 0.0), moonRadius);\n    color += drawMoon(ro, rd, vec3(pos2, 0.0), moonRadius);\n    color += drawMoon(ro, rd, vec3(pos3, 0.0), moonRadius);\n\n    return color;\n}\n\n// draw moon for good situation\nvec3 goodMoon(vec2 uv)  {\n    vec3 ro = vec3(0.0, 0.0, 2.0); // 观察者位置\n    vec3 rd = normalize(vec3(uv, -1.0)); // 光线方向\n\n    // 随机生成两个位置\n    float time = iTime;\n    float speed = 0.1;\n    vec2 pos1 = vec2(0.0, 0.0); // 月亮1始终在屏幕中间\n    vec2 pos2 = vec2(rand(vec2(5.0, 6.0)) * 1.6 - 0.8, rand(vec2(7.0, 8.0)) * 1.6 - 0.8);\n    vec2 pos3 = vec2(rand(vec2(9.0, 10.0)) * 1.6 - 0.8, rand(vec2(11.0, 12.0)) * 1.6 - 0.8);\n\n    // 计算月亮的移动轨迹\n    float radius = 0.8 * 1.5; // 修改月亮大小为1.5倍\n    float angle1 = time * speed;\n    float angle2 = time * speed * 2.0;\n    float angle3 = time * speed * 3.0;\n    pos2 = vec2(cos(angle2), sin(angle2)) * radius;\n    pos3 = vec2(cos(angle3), sin(angle3)) * radius;\n\n    // 确保月亮在屏幕内完整显示且不重叠\n    float moonRadius = 0.2 * 1.5; // 修改月亮大小为1.5倍\n    float minDistance = 2.0 * moonRadius;\n    pos2 = avoidOverlap(pos1, pos2, minDistance);\n    pos3 = avoidOverlap(pos1, pos3, minDistance);\n    pos3 = avoidOverlap(pos2, pos3, minDistance);\n\n    // 绘制背景\n    vec3 background = vec3(0.0, 0.0, 0.0); // 星空黑背景\n    vec3 color = background;\n\n    // 绘制三个月亮\n    color += drawMoon(ro, rd, vec3(pos1, 0.0), moonRadius);\n    color += vec3(0.9, 0.5, 0.5) * drawMoon(ro, rd, vec3(pos2, 0.0), moonRadius); // 月亮2的颜色为银灰色\n    color += vec3(0.9, 0.5, 0.5) * drawMoon(ro, rd, vec3(pos3, 0.0), moonRadius); // 月亮3的颜色为银灰色\n\n    return color;\n}\n\n/* #define R iResolution.xy\n#define M iMouse\n#define circle(cl,cn,r)  col=mix(col,cl, smoothstep(.001,0.00,length((uv-cn))-r));\n#define cc(cl,FUNC)  col=mix(col,cl, smoothstep(.001,0.00,FUNC));\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat shape(vec2 uv, float k, vec2 c1,float r1, vec2 c2, float r2,vec2 c3, float r3){\n    return smin(length(uv-c1)-r1, smin(length(uv-c2)-r2,length(uv-c3)-r3,k),k);    \n}\n\nvec4 drawrabit(out vec4 O,vec2 U)\n{\n \n    vec2 uv = (U-R*.5)/R.y, m = (M.xy-R*.5)/R.y,m2 = (M.xy-R*.5)/R.y;    \n    float a =  iTime*12.,  k=cos(a-.3)*.9+1.7,  k2=cos(a-1.3)*1.+2.4,  z=1.8;\n    vec2 v=  iMouse.z>0.? -m.xy*vec2(.15,.4) : vec2(cos(a)*.6,-sin(a)*.7)*.1,\n         w = -v,   r=vec2(cos(k),sin(k)),  ra=vec2(cos(k2),sin(k2));\n    \n    uv*=z;\n    //background\n    vec3 col =uv.y <-.3 ? vec3(.3,.6,0):vec3(0,.5,.8);\n    //movement\n    uv+=z*vec2(1.2,.3) + z*vec2(-2.4,0)*fract(a*.053)-vec2(0,abs(k)*.1);\n    \n    //tail\n    circle(vec3(1),vec2(-.15,-.02)+w*.8-v*.1,.05);\n    \n    //body\n    cc( vec3(1), shape(uv,.06,  vec2(.0)-w*.8,.16,  vec2(.12,.05)-w*.5-v*.5,.12,  vec2(.22,.05)-w*.1-v*.8,.11));\n  \n    //face\n    cc(vec3(1),shape(uv,.02,   vec2(.4,.11)-v,.05,  vec2(.33,.12)-v,.1,  vec2(.43,.11)-v,.03));\n    circle(vec3(.0),vec2(.35,.16)+v,.01);   \n     \n    //ears\n    cc(vec3(0.8,0.7,0.7),shape(uv,.05,  vec2(.27,.35)-v,.04,   vec2(.28,.28)-v,.03,  vec2(.29,.23)-v,.02));    \n    cc(vec3(0.9,0.8,0.9),shape(uv,.05,  vec2(.23,.33)-v,.04,   vec2(.25,.26)-v,.03,   vec2(.27,.21)-v,.02));  \n        \n    //legs\n    cc(vec3(1,.9,.9),shape(uv,.05,   vec2(-.02,-.07)-w,.12,   vec2(-.02,-.07)-w-r*.14,.05,  vec2(-.02,-.07)-w-r*.19,.03));\n    \n    //arm\n    cc(vec3(1,.9,.9),shape(uv,.04,   vec2(.22,-.01)-v,.07,   vec2(.22,-.01)-v-ra*.07,.04,   vec2(.22,-.01)-v-ra*.12,.03));    \n\n    O = vec4(col,1.0);\n\n    //vignette\n    O *=  pow((1. - U.y / R.y) *U.x / R.x*(1. - U.x / R.x) *U.y / R.y * 10.0, 0.15)* vec4(1.,.7,.5,0); \n    return O;\n}\n\n*/\n\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define PI 3.1415926\n\nfloat Hash21(vec2 p) {\n    p = fract(p * vec2(123.45, 234.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n\n}\nmat2 Rot(float a) {\n    a = a / 180. * PI;\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 withInBox(vec2 uv, vec4 rect) {\n    return (uv - rect.xy) / (rect.zw - rect.xy);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    float proj = clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0);\n    return length(ap - proj * ab);\n}\n\nvec4 Head(vec2 uv, float time) {\n    vec4 col = vec4(vec3(1.0, 0.976, 0.96), 0.);\n\n    float y = uv.y + (uv.x * uv.x) * 0.5;\n    vec2 nuv = vec2(uv.x, y);\n    float d = length(nuv);\n    float blur = 0.005;\n    float m = S(0.2, 0.2 - blur, d);\n    float size = 0.;\n\n    float side = sign(uv.x);\n    uv.x = abs(uv.x);\n    float t = fract(time * 0.3);\n    float rt = smoothstep(0.1, 0.22, t) * smoothstep(0.25, 0.22, t);\n    float rt2 = smoothstep(0.22, 0.34, t) * smoothstep(0.46, 0.34, t);\n    rt += rt2;\n    float rotation = mix(-13., -15., rt);\n    vec2 ruv = uv * Rot(rotation);\n    vec4 rect = vec4(0.0, 0.0, 0.5, 0.5);\n    nuv = withInBox(ruv - vec2(0.08, 0.2), rect);\n    nuv = vec2(nuv.x, nuv.y - (nuv.x * nuv.x) * 20.);\n    nuv *= vec2(4.0, 1.0);\n    d = length(nuv);\n\n    size = 0.4;\n    blur = 0.01;\n    m += S(size, size - blur, d);\n\n    // ear\n    m = clamp(m, 0., 1.);\n    col.a = max(col.a, m);\n    vec3 pink = vec3(255, 182, 195) / 255.;\n    blur = 0.05;\n    nuv = withInBox(ruv * vec2(2.) - vec2(0.15, 0.55), rect);\n    nuv = vec2(nuv.x, nuv.y - (nuv.x * nuv.x) * 10.);\n    nuv *= vec2(4.0, 1.0);\n\n    d = length(nuv);\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, pink, m);\n\n    // eye\n    blur = 0.05;\n    size = 0.37;\n    rect = vec4(0.0, 0.0, 0.1, 0.1);\n    vec2 offs = vec2(0.12, -0.03);\n    rect.xy += offs;\n    rect.zw += offs;\n    nuv = withInBox(uv, rect);\n    d = length(nuv);\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, vec3(0.2), m);\n\n    // eye highlights\n    blur = 0.05;\n    size = 0.15;\n    rect = vec4(0.0, 0.0, 0.1, 0.1);\n    offs = vec2(0.12, -0.03);\n    rect.xy += offs;\n    rect.zw += offs;\n    nuv = withInBox(uv, rect);\n\n    t = smoothstep(0.5, 0.6, fract(time * 0.5)) * 3.14159 * 2.;\n    float xx = 0.1 * cos(t + 1.);\n    float yy = 0.1 * sin(t + 1.);\n    d = length(nuv - vec2(xx * side, yy));\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, vec3(1.0), m);\n\n    // blush\n    blur = 0.5;\n    size = 0.68;\n    rect = vec4(0.0, 0.0, 0.1, 0.1);\n    offs = vec2(0.12, -0.03);\n    rect.xy += offs;\n    rect.zw += offs;\n    nuv = withInBox(uv, rect);\n    d = length(nuv - vec2(0.2, -0.9));\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, pink * 1.2, m);\n\n    blur = 0.01;\n    size = 0.015;\n    rect = vec4(0.0, 0.0, 0.5, 0.5);\n    offs = vec2(0.0, -0.0);\n    rect.xy += offs;\n    rect.zw += offs;\n    nuv = withInBox(uv, rect);\n    nuv.y += -6. * ((nuv.x - 0.05) * (nuv.x - 0.05));\n    nuv.y -= -0.18;\n    d = line(nuv, vec2(0.), vec2(0.08, 0.0));\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, vec3(0.), m);\n\n    return col;\n}\n\nvec4 draw(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    float gradient = smoothstep(-0.5, 0.2, uv.y);\n    vec3 col = mix(vec3(0, 0, 0), vec3(0, 0, 0), gradient);\n    vec4 head = Head(uv, iTime);\n\n    uv *= 5.;\n    vec2 id = floor(uv);\n    float n = Hash21(id);\n    vec2 st = fract(uv) - 0.5;\n    float vn = smoothstep(0.2, 0.8, n) * 0.5 + 0.1;\n    st *= Rot(fract(iTime * vn) * 360. + n * 123.4);\n\n    vec4 fractHead = Head(st, 0.);\n    col = mix(col, fractHead.rgb, fractHead.a);\n\n    fragColor = vec4(col, 1.0);\n    return fragColor;\n}\n// main function\n// 1. homepage\n// 2. click to moon\n// 存储左键点击状态的变量\nint clickFrame = -1;\nint displayState = 0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float time = mod(iTime, 20.0);\n\n    if (time < 7.0) {\n        if (iMouse.z > 0.0) {\n            displayState = 1; // display words\n        } else {\n            displayState = 0;\n        }\n    } else if (time >= 7.0 && time < 11.0) {\n        displayState = 2;\n    } else if (time >= 11.0 && time < 17.0) {\n        displayState = 3;\n    }  else if (time >= 17.0 && time < 20.0) {\n        displayState = 4;\n    }\n\n    // Determine the current and next images based on the display state\n    switch (displayState) {\n        case 0:\n            fragColor = texture(iChannel0, uv);\n            break;\n        case 1:\n            //fragColor = words(uv);\n            fragColor = texture(iChannel1, uv);\n            break;\n        case 2:\n            // good\n            vec2 uv2 = uv * 2.0 - 1.0;\n            uv2.x *= iResolution.x / iResolution.y;\n            float audioLeft = texture(iChannel2, vec2(uv.x, 0.25)).r;\n            float audioRight = texture(iChannel2, vec2(uv.x, 0.75)).g;\n            float audio2 = (audioLeft + audioRight) * 0.5;\n            fragColor = vec4(goodMoon(uv2), 1.0);\n            break;\n        case 3:\n            vec2 uv3 = uv * 2.0 - 1.0;\n            uv3.x *= iResolution.x / iResolution.y;\n            float audioLeft3 = texture(iChannel3, vec2(uv.x, 0.25)).r;\n            float audioRight3 = texture(iChannel3, vec2(uv.x, 0.75)).g;\n            float audio3 = (audioLeft3 + audioRight3) * 0.5;\n            fragColor = vec4(badMoon(uv3), 1.0);\n            break;\n        case 4:\n            fragColor = draw(fragColor,fragCoord);\n            break;\n        default:\n            fragColor = texture(iChannel0, uv);\n            break;\n    }\n}","name":"Image","description":"","type":"image"}]}