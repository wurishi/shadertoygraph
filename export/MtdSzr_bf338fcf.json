{"ver":"0.1","info":{"id":"MtdSzr","date":"1477914057","viewed":234,"name":"Calabaza","username":"Draedrus","description":"Halloween stuff there","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["halloween","calabaza"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    \n    float eps = 0.4/iResolution.y;\n    \n    fragColor = texture(iChannel0, uv+vec2(-eps, -eps));\n    fragColor += texture(iChannel0, uv+vec2(eps, -eps));\n    fragColor += texture(iChannel0, uv+vec2(-eps, eps));\n    fragColor += texture(iChannel0, uv+vec2(eps, eps));\n    fragColor/=4.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n/**\n * CAMERA BEHAVIOUR RELATED CONSTANTS\n **/\n#define NEAR 0.01\n#define FAR 100.0\n\n#define RAYMARCHING_NUM_STEPS 80\n\n//\n\n#define CAMPOS vec3(0.0, 3.0, 5.0)\n#define TARGETPOS vec3(0.0, 0.0, 0.0)\n\n#define CALABAZA_SIZE 1.8\n\n#define TYPE_FLOOR 0.0\n#define TYPE_CALABAZA 1.0\n#define TYPE_CALABAZA_INSIDE 2.0\n\n#define NOISEFUNC(x) noise3D(x*6.0)\n//#define NOISEFUNC(x) voronoi3D(x*3.0)\n\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(0.4955, 490.4294, 0.40594))*13.4959451);    \n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n        \tf.z);\n}\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdPlainTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    float dmax = max(-d1.x, d2.x);\n\treturn abs(d1.x-dmax)<0.01?d1:d2;\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\n\n/*******************\n * DEPTH MAP + TYPE\n *******************/\n\nfloat mapEye(vec3 p, vec2 h) {\n    return sdPlainTriPrism(p, h);\n}\n\nfloat mapCalabaza(vec3 p, float size) {\n    float d = -1.0;\n    \n    d = sdSphere(p, size);\n    d += (cos(p.x*2.0)+sin(p.z*2.0))*0.1;\n    \n    float cosAngle = dot(normalize(p.xz), vec2(1.0, 0.0));\n    float radialAngle = acos(cosAngle);\n    d += cos(radialAngle*12.0)*0.05;\n    \n    return d;\n}\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(sdPlane(p-vec3(0.0, -CALABAZA_SIZE*0.3, 0.0)), TYPE_FLOOR);\n    \n    vec2 dCal = vec2(-1.0, -1.0);\n    dCal = vec2(mapCalabaza(p, CALABAZA_SIZE), TYPE_CALABAZA);\n    \n    vec2 dCalInside = vec2(-1.0, -1.0);\n    dCalInside = vec2(mapCalabaza(p, CALABAZA_SIZE*0.8), TYPE_CALABAZA_INSIDE);\n    \n    dCal = opU(dCalInside, dCal);\n    \n    // eyes\n    vec2 el = vec2(\n        mapEye(p-vec3(-0.8,1.0,2.0), vec2(0.2, 1.5)),\n        TYPE_CALABAZA_INSIDE);\n    vec2 er = vec2(\n        mapEye(p-vec3(0.8,1.0,2.0), vec2(0.2, 1.5)),\n        TYPE_CALABAZA_INSIDE);\n    if(el.x<-dCal.x) dCal = dCalInside;\n    if(er.x<-dCal.x) dCal = dCalInside;\n    /*dCal = opS(,\n    dCal);\n    dCal = opS(,\n    dCal);*/\n    \n    // mouth\n    float mouthY = 0.2;\n    for(float x = 1.0;x>-1.1;x-=0.2)\n    {\n        vec2 teeth = vec2(\n            mapEye(p-vec3(x,mouthY,2.0), vec2(0.2, 1.5)),\n            TYPE_CALABAZA_INSIDE);\n    \tif(teeth.x<-dCal.x) dCal = dCalInside;\n    }\n    #ifdef NOISEFUNC\n    dCal.x+=NOISEFUNC(p)*0.1;\n    #endif\n    //d = vec2(sdSphere(p-TARGETPOS, CALABAZA_SIZE), 0.0);\n    d = opU(d, dCal);\n    return d;\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n\n    vec2 rm = vec2(FAR, -1.0);\n    rm = raymarch(ro, rd, NEAR, FAR);\n    float normalized = (FAR-rm.x)/(FAR-NEAR);\n    fragColor = vec4(rm.x, rm.y, normalized, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n// Buf B is for debug\n\n/**\n * CAMERA BEHAVIOUR RELATED CONSTANTS\n **/\n#define NEAR 0.01\n#define FAR 100.0\n\n#define RAYMARCHING_NUM_STEPS 80\n\n//\n\n#define CAMPOS vec3(0.0, 3.0, 5.0)\n#define TARGETPOS vec3(0.0, 0.0, 0.0)\n#define LIGHTPOS vec3(0.0, -1.0, 0.0)\n\n#define CALABAZA_SIZE 1.8\n\n#define TYPE_FLOOR 0.0\n#define TYPE_CALABAZA 1.0\n#define TYPE_CALABAZA_INSIDE 2.0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n\nLight _light = Light(\n    LIGHTPOS,\n    vec3(0.0, 0.0, 0.0),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    16.0,\n    1.0);\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    float dmax = max(-d1.x, d2.x);\n\treturn abs(d1.x-dmax)<0.03?d1:d2;\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\n\n/*******************\n * DEPTH MAP + TYPE\n *******************/\n\nfloat mapEye(vec3 p, vec2 h) {\n    return sdTriPrism(p, h);\n}\n\nfloat mapCalabaza(vec3 p, float size) {\n    float d = -1.0;\n    \n    d = sdSphere(p, size);\n    d += (cos(p.x*2.0)+sin(p.z*2.0))*0.1;\n    \n    float cosAngle = dot(normalize(p.xz), vec2(1.0, 0.0));\n    float radialAngle = acos(cosAngle);\n    d += cos(radialAngle*12.0)*0.05;\n    \n    return d;\n}\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(sdPlane(p-vec3(0.0, -CALABAZA_SIZE*0.3, 0.0)), TYPE_FLOOR);\n    \n    vec2 dCal = vec2(-1.0, -1.0);\n    dCal = vec2(mapCalabaza(p, CALABAZA_SIZE), TYPE_CALABAZA);\n    \n    vec2 dCalInside = vec2(-1.0, -1.0);\n    dCalInside = vec2(mapCalabaza(p, CALABAZA_SIZE*0.8), TYPE_CALABAZA_INSIDE);\n    \n    dCal = opU(dCalInside, dCal);\n    \n    // eyes\n    dCal = opS(vec2(\n        mapEye(p-vec3(-0.8,1.0,2.0), vec2(0.2, 1.5)),\n        TYPE_CALABAZA_INSIDE),\n    dCal);\n    dCal = opS(vec2(\n        mapEye(p-vec3(0.8,1.0,2.0), vec2(0.2, 1.5)),\n        TYPE_CALABAZA_INSIDE),\n    dCal);\n    \n    // mouth\n    float mouthY = 0.2;\n    for(float x = 1.0;x>-1.1;x-=0.2)\n    {\n        dCal = opS(vec2(\n            mapEye(p-vec3(x,mouthY,2.0), vec2(0.2, 1.5)),\n            TYPE_CALABAZA_INSIDE),\n        dCal);\n    }\n    //d = vec2(sdSphere(p-TARGETPOS, CALABAZA_SIZE), 0.0);\n    d = opU(d, dCal);\n    return d;\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;\n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / ( 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\nreturn fresnel;\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(roughness, NdotH);\n\n  //Fresnel term\n  float F = pow(max(0.0, 1.0 - VdotN), fresnel);\n\n  //Multiply terms and done\n  return  fresnel;//G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    float F = 0.0;\n    if(NdotV>0.0)\n    {\n        F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)+Ks*specularColor*spec) * Oi;\n}\n\nfloat lighting(vec3 ro, vec3 rd, in float tmin, in float tmax)\n{\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    float shadow = 1.0;\n    for(int i=0;i<20;i++)\n    {\n        m = map(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n    }\n    return (res.x-tmin)/(tmax-tmin);\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = abs(color);\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nvec3 rendering(vec3 rm, vec3 ro, vec3 rd)\n{\n\tvec3 color = vec3(0.0);\n    vec3 p = ro+rd*rm.x;\n    vec3 n = mapNormal(p, 0.001);\n    //n.z = -abs(n.z);\n    n = normalize(n);\n    if(rm.y==TYPE_FLOOR)\n    {\n        color = brdf(\n            1.0, // Kd\n            1.0, // Ks\n            1.0, // roughness\n            1.0, // opacity\n            vec3(0.0, 0.0, 0.0), //vec3 specularColor,\n            vec3(1.0, 1.0, 1.0), //vec3 diffuseColor,\n            rd,\n            n,\n            _light.d);\n    }else\n    if(rm.y==TYPE_CALABAZA)\n    {\n        color = brdf(\n            1.0, // Kd\n            1.0, // Ks\n            0.2, // roughness\n            1.0, // opacity\n            vec3(1.0, 1.0, 1.0), //vec3 specularColor,\n            vec3(1.0, 0.2, 0.0), //vec3 diffuseColor,\n            rd,\n            n,\n            _light.d);\n    }else\n    if(rm.y==TYPE_CALABAZA_INSIDE)\n    {\n        color = brdf(\n            1.0, // Kd\n            1.0, // Ks\n            0.2, // roughness\n            1.0, // opacity\n            vec3(0.0, 0.0, 0.0), //vec3 specularColor,\n            vec3(1.0, 0.5, 0.0), //vec3 diffuseColor,\n            rd,\n            n,\n            _light.d);\n    }\n\tcolor *= vec3(lighting(p-vec3(0.0, 2.0, 0.0), normalize(_light.d), NEAR, FAR));\n    color *= max(0.0,\n                 dot(\n                     -normalize(_light.d),\n                     normalize(p)\n                 ))+0.4+pow(0.5*(sin(fract(iTime)*3.14*0.9)+1.0)*0.6, length(p-TARGETPOS));\n    //color = vec3(shadowing(p-vec3(0.0, 2.0, 0.0), normalize(_light.d), NEAR, FAR));\n    //color = vec3(rm.y/4.0);\n    //color = n;\n    return tonemapping(color);\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = vec3(0.0, 0.0, 0.0);\n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = normalize(ca*normalize(vec3(pixel.xy, 2.0)));\n    \n    vec3 rm = texture(iChannel0, uv).rgb;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    _light.d = (ro+rd*rm.x)-_light.o;\n    color = rendering(rm, ro, rd);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}