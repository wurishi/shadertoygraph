{"ver":"0.1","info":{"id":"3dyXz3","date":"1574541658","viewed":88,"name":"dual-number-julia","username":"marmakoide","description":"A Julia fractal analog, using dual numbers instead of imaginary numbers. Far less interesting things happen with dual numbers, aesthetically speaking, compared to complex numbers. Animation is used to try to hide that poverty somewhat.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","dualnumbers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid\nmainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Parameters\n    int max_iteration_count = 64;\n    float cx_min = -3.;\n    float cx_max = -1.8;\n    vec2 c = vec2((cx_max - cx_min) * .5 * (cos(iTime) + 1.) + cx_min, .25 * sin(.5 * iTime));\n    float theta = .01 * 2. * 3.141592 * iTime;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\t\n    // Julia iterations\n    vec2 z = 5. * vec2(1., iResolution.y / iResolution.x) * (uv - .5);\n    z = rotate(z, theta);\n    \n    int iteration_count;\n    for(iteration_count = 0; iteration_count < max_iteration_count; ++iteration_count) {\n       // Orbit escape condition\n       float norm_sqr = z.x * z.x + z.y * z.y;\n       if (norm_sqr > 16.)\n           break;\n        \n       // Update Z(n)\n       z = vec2(z.x * z.x, 2. * z.x * z.y) + c; \n    }\n    \n    // Time varying pixel color\n    vec3 col = vec3(1. - (float(iteration_count) / float(max_iteration_count)));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}