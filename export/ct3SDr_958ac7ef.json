{"ver":"0.1","info":{"id":"ct3SDr","date":"1703536859","viewed":28,"name":"flow 44444444444","username":"suwqymncwec","description":"buffer","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","automata"],"hasliked":0,"parentid":"mlVGW1","parentname":"simplest traffic simulator"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0).xyz;\n}\n\nvec3 cm(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel1, 0));\n    p = (p/2+r) % r;\n    return texelFetch(iChannel1, p, 0).xyz;\n}\n\nivec2 lookup(in ivec2 p) {\n    ivec2 l = p - ivec2(-1,0);\n    ivec2 r = p - ivec2(1,0);\n    ivec2 t = p - ivec2(0,1);\n    ivec2 d = p - ivec2(0,-1);\n    ivec2 tr = p - ivec2(1,1);\n    ivec2 tl = p - ivec2(-1,1);\n    ivec2 dr = p - ivec2(1,-1);\n    ivec2 dl = p - ivec2(-1,-1);\n    \n    float _l = cm(l).r;\n    float _r = cm(r).r;\n    float _t = cm(t).r;\n    float _d = cm(d).r;\n    float _tr = cm(tr).r;\n    float _tl = cm(tl).r;\n    float _dr = cm(dr).r;\n    float _dl = cm(dl).r;\n\n\n    ivec2 res = l;\n    float m = 0.;\n    if (_l > m) { res = l; m = _l; }\n    if (_r > m) { res = r; m = _r; }\n    if (_t > m) { res = t; m = _t; }\n    if (_d > m) { res = d; m = _d; }\n    if (_tr > m) { res = tr; m = _tr; }\n    if (_tl > m) { res = tl; m = _tl; }\n    if (_dr > m) { res = dr; m = _dr; }\n    if (_dl > m) { res = dl; m = _dl; }\n\n    return res;\n}\n\nivec2 lookupM(in ivec2 p) {\n    ivec2 l = p - ivec2(-1,0);\n    ivec2 r = p - ivec2(1,0);\n    ivec2 t = p - ivec2(0,1);\n    ivec2 d = p - ivec2(0,-1);\n    ivec2 tr = p - ivec2(1,1);\n    ivec2 tl = p - ivec2(-1,1);\n    ivec2 dr = p - ivec2(1,-1);\n    ivec2 dl = p - ivec2(-1,-1);\n    \n    float _l = cell(l).r;\n    float _r = cell(r).r;\n    float _t = cell(t).r;\n    float _d = cell(d).r;\n    float _tr = cell(tr).r;\n    float _tl = cell(tl).r;\n    float _dr = cell(dr).r;\n    float _dl = cell(dl).r;\n\n\n    ivec2 res = l;\n    float m = 0.;\n    if (_l > m) { res = l; m = _l; }\n    if (_r > m) { res = r; m = _r; }\n    if (_t > m) { res = t; m = _t; }\n    if (_d > m) { res = d; m = _d; }\n    if (_tr > m) { res = tr; m = _tr; }\n    if (_tl > m) { res = tl; m = _tl; }\n    if (_dr > m) { res = dr; m = _dr; }\n    if (_dl > m) { res = dl; m = _dl; }\n\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 px = ivec2(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = cell(px);\n    vec3 col = c;\n    \n    //float f = perlin(uv, 5.635);\n    //col = cm(px);\n    \n    if (iFrame % 100 == 0) {\n        if (cell(px).r < .99) {\n            ivec2 j = lookupM(px);\n            //if (cell(j).r > .5) col = vec3(1.);\n            \n            ivec2 k = lookup(j);\n            if (k == px) col = vec3(1.);\n        } else {\n            ivec2 j = lookup(px);\n            if (cell(j).r < .5) col = vec3(0.);\n        }\n    }\n    \n    if (iFrame == 0) {\n        //col = vec3(rand(fragCoord-.5));\n        float x = rand(fragCoord-.5) > .998 ? 1. : 0.;\n        col = vec3(x);\n    }\n    \n    //col = mix(col, c, .25);\n    \n\tfragColor = vec4(col, 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R vec3(1., 0., 0.)\n#define B vec3(0., 0., 1.)\n#define D vec3(0.)\n\n\n//float rand(vec2 px){\n//    float f = fract(sin(dot(px, vec2(12.9898, 78.233))) * 43758.5453);\n//    return f > .5 ? 1. : 0.;\n//}\n\nbool empty(vec3 c) { return c.x == 0. && c.z == 0.; }\n\n#define M_PI 3.14159265358979323846\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nfloat rand (vec2 co, float l) {return rand(vec2(rand(co), l));}\nfloat rand (vec2 co, float l, float t) {return rand(vec2(rand(co, l), t));}\n\nfloat perlin(vec2 p, float dim, float time) {\n\tvec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\tfloat c = rand(pos, dim, time);\n\tfloat cx = rand(posx, dim, time);\n\tfloat cy = rand(posy, dim, time);\n\tfloat cxy = rand(posxy, dim, time);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;\n}\n\n// p must be normalized!\nfloat perlin(vec2 p, float dim) {\n\t\n\t/*vec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\t// For exclusively black/white noise\n\t/*float c = step(rand(pos, dim), 0.5);\n\tfloat cx = step(rand(posx, dim), 0.5);\n\tfloat cy = step(rand(posy, dim), 0.5);\n\tfloat cxy = step(rand(posxy, dim), 0.5);*/\n\t\n\t/*float c = rand(pos, dim);\n\tfloat cx = rand(posx, dim);\n\tfloat cy = rand(posy, dim);\n\tfloat cxy = rand(posxy, dim);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;*/\n\treturn perlin(p, dim, 0.0);\n}","name":"Common","description":"","type":"common"}]}