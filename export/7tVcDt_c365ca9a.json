{"ver":"0.1","info":{"id":"7tVcDt","date":"1662553065","viewed":425,"name":"Monte Carlo Diffusion w/ Source","username":"Ultraviolet","description":"Extension of [url=https://www.shadertoy.com/view/7tVcWt]Monte Carlo diffusion[/url]  to a Poisson equation : same, but with a non-null right hand term (source).\n\nClick to control the source, press space to enable/disable boundary conditions.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["montecarlo","poissonequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 p )\n{\n    O = texture(iChannel0, p/R.xy);\n        \n    //O = vec4(O.r, 0., -O.r, 0.);\n    \n    //O /= 10.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float epsilon = 2.;\n\nconst float NB_SAMPLES = 20.;\nconst float MAX_ITER = 10.;\nconst float MAX_FRAMES = 10.;\n\n\nfloat boundaryDist(vec2 p) {\n    return min(min(p.x, p.y), min(R.x-p.x, R.y-p.y) -1.);\n}\n\nfloat sin2(float t) {\n    return sin(t)*sin(t); \n}\n\nvec4 boundaryValue(vec2 p) {\n    vec2 xy = p/(R.x+R.y)*PI*2.;\n    return vec4(sin2(xy.x*1.35485136), sin2((xy.y+xy.x)*1.0123456), sin2(xy.y*0.98453715), 0.);\n}\n\nvec4 sourceValue(vec2 p) {\n    vec2 xy = p;\n    vec2 pr = vec2(0.4*R.x,0.5*R.y);\n    vec2 pg = vec2(0.5*R.x,0.5*R.y);\n    vec2 pb = vec2(0.6*R.x,0.5*R.y);\n    \n    if(iMouse.z>0.5) {\n        pr = iMouse.xy;\n        pg = pr;\n        pb = pr;\n    }\n    \n    \n    \n    float radius = 0.1*R.x;\n    float dr = clamp(radius-length(xy-pr), 0., 1.);\n    float dg = clamp(radius-length(xy-pg), 0., 1.);\n    float db = clamp(radius-length(xy-pb), 0., 1.);\n    \n    float volume = radius*radius*PI;\n    \n    return 2.*vec4(dr, dg, db, 0.) / volume;\n}\n\nvec4 value(vec2 p) {\n    if(iFrame == 0)\n        return vec4(0.);\n\n    return texture(iChannel0, p/R.xy);\n}\n\nvec2 sampleOnCircle(vec2 center, float radius, float id) {\n    float alpha = 2.*PI*hash14(vec4(center, iFrame, id));\n    return center + radius*vec2(cos(alpha), sin(alpha));\n}\n\nvec2 sampleInDisk(vec2 center, float radius, float id) {\n    float alpha = 2.*PI*hash14(vec4(center, iFrame, id));\n    float rho = hash14(vec4(center, iFrame, id+123456.));\n    \n    rho = sqrt(rho);\n    rho *= radius;\n    return center + rho*vec2(cos(alpha), sin(alpha));\n}\n\n\nfloat G(float R, float r) {\n    if(r<1. || R < 1.)\n        return 1.;\n    return log(R/r)/2./PI;\n}\n\nfloat green_function(vec2 x, vec2 y, float r) {\n    if(r<1. || length(x-y) < 1.)\n        return 1.;\n    return log(r/length(y-x))/2./PI;\n}\n\nfloat green_function_int(float r) {\n    return r*r/4.;\n}\n\n\nvec2 sampleInDiskGreen(vec2 center, float radius, float id) {\n    float alpha = 2.*PI*hash14(vec4(center, iFrame, id));\n    float rho;\n    \n    // rejection sampling: BAD !\n    for(float i = 0.; i<10.; ++i){\n        rho = radius*hash14(vec4(center, iFrame, id+123456.+i));\n        if(G(radius, rho)/rho < hash14(vec4(center, iFrame, id+78910.+i)))\n            break;\n    }\n    \n    \n    return center + rho*vec2(cos(alpha), sin(alpha));\n}\n\n\nvoid mainImage( out vec4 O, in vec2 p )\n{\n    float b_dist = boundaryDist(p);\n    \n    // debug stuff\n    #if 0\n        //O = boundaryValue(p);\n        //O = sourceValue(p)*5000.;\n\n        //O = vec4(green_function(R.xy/2., p, iMouse.y/2.));\n        //O = vec4(green_function(iMouse.xy, p, R.y/4.));\n\n        //*\n        float val_ = 0.;\n        for(float i = 0.; i<MAX_ITER*NB_SAMPLES*10.; ++i) {\n            float d;\n            float w = 1.;\n            \n            //d = length(sampleInDisk(iMouse.xy, R.y/4., i) - p);\n            d = length(sampleInDiskGreen(iMouse.xy, R.y/4., i) - p);\n            w = green_function(iMouse.xy, p, R.y/4.);\n            \n            d = clamp(1.-d, 0., 1.);\n            val_ += d*w;\n        }\n        \n        O = value(p);\n        O *= 0.9;\n        O += vec4(val_);\n        //*/\n        return;\n    #endif\n    \n    vec4 val = vec4(0.);\n    \n    for(float j=0.; j<NB_SAMPLES; ++j) {\n        vec2 cur_p = p;\n        for(float i=0.; i<MAX_ITER; ++i) {\n        \n            b_dist = boundaryDist(cur_p);\n            vec2 y = sampleInDisk(cur_p, b_dist, j);\n            float ball_area = PI*b_dist*b_dist;\n            \n            //*\n            val += ball_area*green_function(cur_p, y, b_dist)*sourceValue(y);\n            /*/\n            y = sampleInDiskGreen(cur_p, b_dist, j);\n            float prob = green_function(cur_p, y, b_dist) / green_function_int(b_dist);\n            val += ball_area*green_function(cur_p, y, b_dist)*sourceValue(y)/prob;\n            //*/\n            \n            \n            if(b_dist < epsilon) {\n                break;\n            }\n            cur_p = sampleOnCircle(cur_p, b_dist, i*NB_SAMPLES+j);\n        }\n\n        if(texelFetch(iChannel1, ivec2(32,2), 0).x>0.5)\n            val += boundaryValue(cur_p);\n    }\n    \n    val /= NB_SAMPLES;\n    \n    float t = min(MAX_FRAMES, float(iFrame));\n    \n    O = (value(p)*t + val)/(t+1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define PI 3.1415\n\n\nfloat hash14(vec4 p4)\n{\n\tp4  = fract(p4 * .1031);\n    p4 += dot(p4, p4.wzyx + 31.32);\n    return fract((p4.x + p4.y) * p4.z + p4.w);\n}\n","name":"Common","description":"","type":"common"}]}