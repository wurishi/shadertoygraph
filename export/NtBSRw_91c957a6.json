{"ver":"0.1","info":{"id":"NtBSRw","date":"1628372298","viewed":1375,"name":"Beating blob","username":"felipetovarhenao","description":"Using cellular noise and shaping functions to create a pulsing blob.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","drawing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Author: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n    Description: Beating blob, using cellular noise and shaping functions.\n*/\n\n#define u_resolution iResolution\n#define u_time iTime\n#define TWO_PI 6.28318530718\n\nvec3 random3D(in vec3 vUV, in int seed) {\n    return fract(abs(sin(vec3(dot(vUV, vec3(11.13, 57.05, 41.87) + float(seed)), dot(vUV, vec3(43.17, 85.39, 38.97)), dot(vUV, vec3(56.91, 39.59, 81.33)))) * 48240.41));\n}\n\nfloat worley_noise3D(in vec3 vUV, in int seed) {\n    vec3 xyz = floor(vUV);\n    vec3 f = fract(vUV);\n    float mindist = 90000.0;\n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            for (float z = -1.0; z <= 1.0; z++) {\n                vec3 node = random3D(xyz + vec3(x,y,z), seed) + vec3(x,y,z);\n                mindist = min(mindist, distance(node,f));\n            }\n        }\n    }\n    return mindist;\n}\n\nvec2 rotate2D(in vec2 vUV, in float theta) {\n    vec2 r = vec2(cos(theta), sin(theta));\n    return vUV * mat2(r.x, -r.y, r.y, r.x);\n}\n\nfloat fold(in float x) {\n    return abs(mod(x+1.0,2.0)-1.0);\n}\n\nfloat cosine_ramp(in float x, in float s) {\n    float y = cos(fract(x)*3.14159265359);\n    return floor(x) + 0.5 - (0.5*pow(abs(y), 1.0/s)*sign(y));\n}\n\nfloat sine_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = 0.5 - (0.5/(s*s));\n    return floor(x) + y + h*sin(6.28318530718*y);\n}\n\nfloat seat_ramp(in float x, in float s) {\n    float y = (2.0*fract(x))-1.0;\n    return floor(x) + 0.5 + 0.5*pow(abs(y), 1.0/s)*sign(y);\n}\n\nfloat N_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = max(0.3, s);\n    return floor(x) + length(vec2(y,0.0)-vec2(pow(y,1.0/h),pow(y,h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / u_resolution.xy;\n    vUV -= 0.5;\n    vUV *= 3.0;\n    vUV.x *= u_resolution.x / u_resolution.y;\n\n    vec3 color = vec3(0.0);\n    float t = sine_ramp(u_time * 0.09, 9.0);\n    float theta = worley_noise3D(vec3(vUV*length(vUV), seat_ramp(t, 2.0)), 4) * pow(length(vUV)*TWO_PI, 0.8);\n    theta = sine_ramp(theta, 1.0);\n    vUV = rotate2D(vUV, fold(theta + u_time*0.2) + N_ramp(t*0.23, 2.0));\n    vUV = clamp(vUV, 0.0, 1.0);\n    vUV.x = fold(vUV.x*3.0);\n    vUV.y = fold(vUV.y*2.0);\n\n    vUV.x = cosine_ramp(vUV.x, 2.5 + sin(u_time*0.17)*0.25);\n    vUV.y = cosine_ramp(vUV.y, 2.5 + cos(u_time*0.03)*0.25);\n\n    vec3 c1a = vUV.x * vec3(0.8039, 0.6196, 0.4824);\n    vec3 c2a = vUV.y * vec3(0.2118, 0.3922, 0.549);\n    vec3 c1b = vUV.x*vUV.y * vec3(0.6353, 0.4667, 0.4392);\n    vec3 c2b = abs(vUV.x-vUV.y) * 0.5 * vec3(0.3922, 0.7373, 1.0);\n\n    color += mix(c1a, c1b, fold(u_time*0.015)) + mix(c2a, c2b, fold(t*0.013));\n    color = clamp(color, 0.0, 1.0);\n\n    float shade = 1.0 - (color.r * color.b * color.g);\n    vec3 sh1 = shade * vec3(0.1255, 0.1373, 0.149);\n    vec3 sh2 = shade * vec3(0.2039, 0.1843, 0.1725);\n\n    color += mix(sh1, sh2, fold(t*0.007));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}