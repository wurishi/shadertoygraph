{"ver":"0.1","info":{"id":"3dcfDr","date":"1604762628","viewed":727,"name":"Simple SDF Raycast Scene","username":"0xAA55","description":"The GLSL implemention of this: https://github.com/0xAA55/NASMCompileTimeRayTracing","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raycast","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int RayStepCount = 320;\nconst int SampleDepth = 12;\n\nconst vec3 CamPos = vec3(0.0, 2.0, 7.0);\nconst vec4 Sphere1 = vec4(0.0, 2.0, 0.0, 2.0);\nconst vec4 Sphere2 = vec4(1.0, 1.0, 2.0, 1.0);\nconst vec4 Sphere3 = vec4(-3.0, 1.0, 0.0, 1.0);\nconst vec3 LightDir = vec3(1.0, -1.0, 1.0);\nconst float LightPow = 20.0;\nconst vec3 LightColor = vec3(1.0, 0.8, 0.6);\nconst vec3 FogColor = vec3(0.8, 0.9, 1.0);\nconst vec3 SkyColor = vec3(0.2, 0.5, 0.8);\nconst float FogDistance = 100.0;\nconst vec3 BoundBoxNeg = vec3(-5.0, -1.0, -3.0);\nconst vec3 BoundBoxPos = vec3(3.0, 5.0, 4.0);\n\nconst float Epsilon = 0.00001;\nconst float CastEpsilon = 0.005;\nconst float CastEpsilon2 = 0.01;\n\nbool IsAwayFromBB(in vec3 RayOrg, in vec3 RayDir)\n{\n    return\n        (RayOrg.x < BoundBoxNeg.x && RayDir.x <= 0.0) ||\n        (RayOrg.x > BoundBoxPos.x && RayDir.x >= 0.0) ||\n        (RayOrg.y < BoundBoxNeg.y && RayDir.y <= 0.0) ||\n        (RayOrg.y > BoundBoxPos.y && RayDir.y >= 0.0) ||\n        (RayOrg.z < BoundBoxNeg.z && RayDir.z <= 0.0) ||\n        (RayOrg.z > BoundBoxPos.z && RayDir.z >= 0.0);\n}\n\nvec3 GetSkyColor(in vec3 Dir)\n{\n    float SunLum = pow(max(dot(normalize(LightDir), -Dir), 0.0), LightPow);\n    float Foggy = 1.0 - abs(Dir.y);\n    return mix(SkyColor, FogColor, Foggy) + SunLum * LightColor;\n}\n\nvec2 MapDist(in vec3 Pos)\n{\n    float ResultDist = 9999999.0;\n    float ResultIndex = 0.0;\n    float Dist1 = Pos.y;\n    float Dist2 = distance(Pos, Sphere1.xyz) - Sphere1.w;\n    float Dist3 = distance(Pos, Sphere2.xyz) - Sphere2.w;\n    float Dist4 = distance(Pos, Sphere3.xyz) - Sphere3.w;\n    if(Dist1 < ResultDist)\n    {\n        ResultDist = Dist1;\n        ResultIndex = int(mod(Pos.x * 2.0, 2.0)) != int(mod(Pos.z * 2.0, 2.0)) ? 1.0 : 5.0;\n    }\n    if(Dist2 < ResultDist)\n    {\n        ResultDist = Dist2;\n        ResultIndex = 2.0;\n    }\n    if(Dist3 < ResultDist)\n    {\n        ResultDist = Dist3;\n        ResultIndex = 3.0;\n    }\n    if(Dist4 < ResultDist)\n    {\n        ResultDist = Dist4;\n        ResultIndex = 4.0;\n    }\n    return vec2(ResultDist, ResultIndex);\n}\n\nvec3 MapNormal(in vec3 Pos)\n{\n    vec2 Nearest = MapDist(Pos);\n    int Index = int(Nearest.y);\n    if (Index == 1 || Index == 5)\n        return vec3(0, 1, 0);\n    if (Index == 2)\n        return normalize(Pos - Sphere1.xyz);\n    if (Index == 3)\n        return normalize(Pos - Sphere2.xyz);\n    if (Index == 4)\n        return normalize(Pos - Sphere3.xyz);\n}\n\nvec3 MapColor(in vec3 Pos)\n{\n    vec2 Nearest = MapDist(Pos);\n    int Index = int(Nearest.y);\n    if (Index == 1)\n        return vec3(1.0, 1.0, 1.0);\n    if (Index == 2)\n        return vec3(0.7, 0.9, 0.1);\n    if (Index == 3)\n        return vec3(0.1, 0.7, 0.9);\n    if (Index == 4)\n        return vec3(0.9, 0.1, 0.7);\n    if (Index == 5)\n        return vec3(0.5, 0.5, 0.5);\n}\n\nfloat GroundCast(in vec3 RayOrg, in vec3 RayDir)\n{\n    if(abs(RayDir.y) <= Epsilon)\n    {\n        return -1.0;\n    }\n    else\n    {\n        return RayOrg.y / -RayDir.y;\n    }\n}\n\nfloat MapCast(in vec3 RayOrg, in vec3 RayDir)\n{\n    float Dist = 0.0;\n    for(int i = 0; i < RayStepCount; i++)\n    {\n        if(IsAwayFromBB(RayOrg, RayDir))\n        {\n            if(RayDir.y < 0.0)\n            {\n                float GroundDist = GroundCast(RayOrg, RayDir);\n                if(GroundDist >= 0.0)\n                \treturn Dist + GroundDist;\n            }\n            else return -1.0;\n        }\n        else\n        {\n            vec2 Nearest = MapDist(RayOrg + RayDir * Dist);\n            Dist += Nearest.x;\n            if(Nearest.x <= CastEpsilon) return Dist;\n        }\n    }\n    return -1.0;\n}\n\nvec3 RenderScene(in vec3 RayOrg, in vec3 RayDir)\n{\n    vec3 CurRayOrg = RayOrg;\n    vec3 CurRayDir = RayDir;\n    vec3 Mask = vec3(1.0, 1.0, 1.0);\n    for(int i = 0; i < SampleDepth; i++)\n    {\n       \tfloat CastDist = MapCast(CurRayOrg, CurRayDir);\n        if(CastDist < 0.0) break;\n        vec3 CastPos = CurRayOrg + CurRayDir * CastDist;\n        float Foggy = CastDist / FogDistance;\n        vec3 CastNormal = MapNormal(CastPos);\n        Mask *= mix(MapColor(CastPos), FogColor, min(Foggy, 1.0));\n        CurRayOrg = CastPos;\n        CurRayDir = normalize(reflect(CurRayDir, CastNormal));\n        CurRayOrg += CurRayDir * CastEpsilon2;\n    }\n    return GetSkyColor(CurRayDir) * Mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 RayOrg = CamPos + vec3(cos(iTime * 0.5), sin(iTime * 0.5), sin(iTime * 0.25) * 4.0) * 0.5;\n    vec3 RayDir = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.yy, -1.75));\n    fragColor = vec4(RenderScene(RayOrg, RayDir), 1.0);\n}","name":"Image","description":"","type":"image"}]}