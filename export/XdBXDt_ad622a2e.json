{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Created by Vinicius Graciano Santos - vgs/2014\n// This shader renders an approximation of a cubic Bezier using the de Casteljau's algorithm.\n// It splits the bezier into multiple smaller ones and renders their control points connected with line segments.\n\nstruct Bezier {\n    vec2 a, b, c, d;\n};\n\n// splits a bezier B (t = 0.5) into beziers L and R.\nvoid decasteljau(in Bezier B, out Bezier L, out Bezier R) {\n\tL.a = B.a;          R.d = B.d;\n    L.b = .5*(B.a+B.b); R.c = .5*(B.c+B.d); \n    vec2 tmp = .5*(B.b+B.c);\n    L.c = .5*(L.b+tmp); R.b = .5*(R.c+tmp);\n    L.d = R.a = .5*(L.c+R.b);\n}\n\n// distance to the control points.\nfloat distCP(vec2 p, Bezier B) {\n    return min(min(length(p - B.a), length(p - B.b)),\n               min(length(p - B.c), length(p - B.d)));\n}\n\n// distance to a line segment.\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a, ab = b - a;\n    float k = clamp(dot(ap, ab)/dot(ab,ab), 0.0, 1.0);\n    return length(ap - k*ab);\n}\n\n// distance to the linear approximation.\nfloat distLinear(vec2 p, Bezier B) {\n    return min(min(segment(p, B.a, B.b), segment(p, B.b, B.c)), segment(p, B.c, B.d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float c = cos(iTime), s = sin(iTime);\n    \n    // Control points (change these to play with the curve).\n\tvec2 PA = vec2(-1.5*c, .8*s);\n\tvec2 PB = iMouse.z > 0.0 ? (-iResolution.xy + 2.0*iMouse.xy) / iResolution.y : vec2(.5);\n\tvec2 PC = vec2(-c*s, -.8*c);\n\tvec2 PD = vec2(1.5*s, 0.);\n    \n    Bezier bezier[16]; \n    bezier[0] = Bezier(PA, PB, PC, PD);\n    float dCP  = distCP(uv, bezier[0]), dLCP = distLinear(uv, bezier[0]);\n                    \n    // just an unrolled recursion, yey! :D\n    decasteljau(bezier[0], bezier[0], bezier[8]);    decasteljau(bezier[0], bezier[0], bezier[4]);\n    decasteljau(bezier[8], bezier[8], bezier[12]);   decasteljau(bezier[0], bezier[0], bezier[2]);\n    decasteljau(bezier[4], bezier[4], bezier[6]);    decasteljau(bezier[8], bezier[8], bezier[10]);\n    decasteljau(bezier[12], bezier[12], bezier[14]); decasteljau(bezier[0], bezier[0], bezier[1]);\n    decasteljau(bezier[2], bezier[2], bezier[3]);    decasteljau(bezier[4], bezier[4], bezier[5]);\n    decasteljau(bezier[6], bezier[6], bezier[7]);    decasteljau(bezier[8], bezier[8], bezier[9]);\n    decasteljau(bezier[10], bezier[10], bezier[11]); decasteljau(bezier[12], bezier[12], bezier[13]);\n    decasteljau(bezier[14], bezier[14], bezier[15]);\n    \n\tfloat dLA = 100.0;\n    for (int i = 0; i < 16; ++i)\n        dLA = min(dLA, distLinear(uv, bezier[i]));\n    \n    // shading.\n    vec3 blue   = pow(vec3(189., 199., 255.)/255., vec3(2.2));\n    vec3 green  = pow(vec3(194., 255., 148.)/255., vec3(2.2));\n    vec3 dgreen = pow(vec3(125., 178., 86. )/255., vec3(2.2));\n    \n    vec3 col = mix(green, dgreen, smoothstep(0.005, 0.01, dLCP));\n    col = mix(blue, col, smoothstep(0.01, 0.015, dLA));\n    col = mix(green, col, smoothstep(0.05, 0.06, dCP));\n    col = mix(col, green, pow(st.x*st.y*(1.0-st.x)*(1.0-st.y), .3));\n    col = smoothstep(0.0, 1.0, col);\n    \n\tfragColor = vec4(pow(col, vec3(1.0/2.2)),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdBXDt","date":"1416952561","viewed":833,"name":"de Casteljau","username":"vgs","description":"Approximating a cubic BÃ©zier Curve by 15 line segments using the de Casteljau's algorithm.\nClick to move the third control point.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["bezier","approximation","casteljau","decasteljau"],"hasliked":0,"parentid":"","parentname":""}}