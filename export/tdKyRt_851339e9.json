{"ver":"0.1","info":{"id":"tdKyRt","date":"1603754976","viewed":61,"name":"Waves JLM 1","username":"vtgco","description":"waves & stuff","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//FBM implementation from https://www.shadertoy.com/view/3sVczG\n\nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// -----------------------------------------------\n\nfloat fbm( in vec2 uv )\n{\n \tuv *= 2.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f = 0.;\n    f  = abs(sin(0.5000*noise( uv ))); uv = m*uv;\n\tf += abs(sin(0.2500*noise( uv ))); uv = m*uv;\n\tf += abs(sin(0.1250*noise( uv ))); uv = m*uv;\n\tf += abs(sin(0.0625*noise( uv ))); uv = m*uv;\n\t//f  = 0.5 + 0.5*f;\n    return f;\n}\n\n\nvec3 DARK = vec3(29., 53., 87.)/255.;\nvec3 LIGHT = vec3(69., 123., 157.)/255.;\n\nvec3 DARK_SAND = vec3(224., 159., 62.)/255.;\nvec3 LIGHT_SAND = vec3(255., 243., 176.)/255.;\n\nfloat WATER_EDGE = 0.75;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    \n    vec2 timeDisplaceA = vec2(iTime*0.05,0.);\n    \n    vec2 warped_point_og =  uv + vec2(fbm(uv)*0.3, 0.);\n\n    vec2 warped_point_water = uv + vec2(fbm(uv + timeDisplaceA)*0.3, 0.);\n\twarped_point_water.x -= cos(iTime)*.1;\n    \n    if (warped_point_water.x >= WATER_EDGE) { \n        vec2 warped_point_sand = warped_point_og;\n    \n        color = mix(DARK_SAND, LIGHT_SAND, smoothstep(0.,1.,fract(warped_point_sand.x * 8.))); //* (warped_point_sand.x+1.));\n    \tif (mod(fbm(warped_point_og), 0.01) <= 0.001)\n        \tcolor -= vec3(fbm(warped_point_og)) * 0.5;\n    \n    } else {\n    \tcolor = mix(DARK, LIGHT, smoothstep(0.,0.8,fract(warped_point_water.x * 8.)) * (warped_point_water.x+1.));\n        color +=  vec3(1.) * max(0., smoothstep(0.8,1.,fract(warped_point_water.x * 8.)) * smoothstep(WATER_EDGE-1.,WATER_EDGE,warped_point_water.x) * cos(iTime));\n    \n    \tcolor += vec3(fbm(warped_point_water))*0.5*cos(iTime);\n        \n        if (mod(fbm(warped_point_water), 0.01) <= 0.001)\n        \tcolor += vec3(fbm(warped_point_water)) * 0.5;\n    }\n\n   \n    \n    //if (abs(mod(warped_point.x, 0.1)) < 0.01 || abs(mod(warped_point.y, 0.1)) < 0.01)\n        //color -= vec3(0.1);\n    \n    \n        \n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}