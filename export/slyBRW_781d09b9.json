{"ver":"0.1","info":{"id":"slyBRW","date":"1664138553","viewed":163,"name":"solving  labyrinth","username":"jt","description":"Solving [url=https://www.shadertoy.com/view/Xtffzf]labyrinth[/url] by [url=https://www.shadertoy.com/user/FabriceNeyret2]FabriceNeyret2[/url], using floodfill.","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["maze","path","way","floodfill","labyrinth","finder","find","pathfinder","wayfinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415926\n\nvec3 palette(float t)\n{\n    return 0.5 + 0.5 * cos(2.0 * pi * t + vec3(0,1,2)/3.0); // some arbitrary color palette\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 c = texture(iChannel0, uv);\n\n    fragColor = c.a > 0.5 ? vec4(vec3(0.5), 1) : vec4(palette(c.g * 100.0), 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/slyBRW solving labyrinth by jt\n\n// Solving https://www.shadertoy.com/view/Xtffzf labyrinth by FabriceNeyret2, using floodfill.\n\n\n// --- Reproducing ref image https://upload.wikimedia.org/wikipedia/commons/8/82/Duomo_Lucca_cathedrale_Lucques_labyrinthe.jpg\n\n#define W(n1,n2)   v += (1.-v) * B(n1,n2,0.)   * S( U.y, e )             // draw Wall section \n#define C(n1,n2,s) v *=  1.-     B(n1,n2,e+p ) * S( U.y-s.5, .5-e-p )    // draw Corridor section\n#define WC(n1,n2)  W(n1,n2); C(n1,n2,+); C(n1,n2,-)                      // wall + side corridors\n#define B(n1,n2,e) step( abs(U.x-(n1+n2)/2.) , abs(n1-n2)/2. -(e) )      // section (infinite width)\n#define S(v,e) smoothstep( p, 0., abs(v) -(e) )                          // thickness e, smoothness p\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if(iFrame == 0)\n    {\n\t    vec2 R = iResolution.xy,\n             U = ( u+u - R ) / R.y * 15.;\n        float  p = .3, // 2./R.y * 15.,       // was pixel size, now used for blur size\n               e = 0., // .1,                 // was wall thickness, now done by blur\n               r = length(U),\n        \n        v =  S( max(abs(U.x),abs(U.y)) - 13.4 , e );                         // Frame\n        if ( r>1.8 && r<13.3 ) v += S( fract(r+.5)-.5, e );                  // Circular walls\n\n        WC( -13., -11. ); WC( -10., -8. ); WC( -6.9, -5. ); WC( -3.9, -2. ); // West corrections\n        W( 13.4, 2.  );                                                      // East corrections\n        C( 13., 7., +); C( 6.9, 1., +);                                      //   entrance line\n        C( 14., 8., -); C( 7.9, 2., -);\n        U.y -= 1.; WC( 11.85, 10. ); WC( 9.85, 8.  ); W( 5.9, 1.7 );         //   line above entrance\n                    C( 5.5, 4.,  +);  C( 3.5, 2., +); \n        U.y += 2.;  W( 13.4, 9.   );  W( 6.9, 2.7  );                        //   line below entrance\n                    C( 12.8, 11.,-);  C( 10.8, 9.,-);\n                    C( 6.5, 5.,  -);  C( 4.5, 3., -);\n        U.y--; \n        U = U.yx;\n        WC( 11., 9. );     WC(  8., 6.  ); WC( 5., 3. );                     // North corrections\n        WC( -12., -10. );  WC( -9., -7. ); WC( -5.9, -4. );\n\n        if(v < 0.5)\n            O = vec4(0, step(length(U/26.0), 0.5), 0, v);\n        else\n            O = vec4(1);\n        \n        //if(distance(u, iResolution.xy / 2.0) < 2.0)\n        //    O = vec4(0,0,0,1);\n    }\n    else\n    {\n        vec4 C = texelFetch(iChannel0, ivec2(u), 0);\n        if(C.a >= 0.5)\n        {\n            O = C;\n        }\n        else\n        {    \n            vec4 W = texelFetch(iChannel0, ivec2(u)+ivec2(-1,0), 0); if(W.a >= 0.5) W = vec4(1);\n            vec4 E = texelFetch(iChannel0, ivec2(u)+ivec2(+1,0), 0); if(E.a >= 0.5) E = vec4(1);\n            vec4 S = texelFetch(iChannel0, ivec2(u)+ivec2(0,-1), 0); if(S.a >= 0.5) S = vec4(1);\n            vec4 N = texelFetch(iChannel0, ivec2(u)+ivec2(0,+1), 0); if(N.a >= 0.5) N = vec4(1);\n\n            float d = min(min(W.g, E.g), min(S.g, N.g));\n            //d += 1.0/256.0;\n            d += 1.0/65536.0; // let's hope the buffers are float on all systems (not e.g. byte) otherwise this will break\n            if(C.g > d)\n                C.g = d;\n\n            O = C;\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}