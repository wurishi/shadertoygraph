{"ver":"0.1","info":{"id":"sdlSD7","date":"1618730686","viewed":56,"name":"Bathyscaphe","username":"gorgh","description":"My first pseudo-intro","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat getCube(vec3 p){\nfloat hash=Hash21(floor(p.xz));\nfloat shrink=p.y*.01+0.01;\n vec3 cube=vec3(.04-shrink,1.-hash*.4,.04-shrink);\n p.y+=1.;\n p.x+=sin(p.y+iTime+hash*2.)*.16;\n float displacement=hash*.5-.25;\n p.z=fract(p.z)-.5-displacement;\n p.x=fract(p.x)-.5-displacement;\n p.xz*=Rot(p.y);\n p.xy+=sin(iTime+hash)*.01;\n    return length(max(abs(p)-cube,0.0));//+min(max(p.x, max(p.y, p.z)), 0.);\n    \n}\n\nfloat getCylinder(vec3 p,vec3 cyl1,vec3 cyl2){\n\n   \n    float cyl_rad=.2;\n    \n    vec3 ab=cyl2-cyl1;\n    vec3 ap=p-cyl1;\n    \n    float t=dot(ap,ab)/dot(ab,ab);\n    \n    t=clamp(t,0.,1.);\n    \n    vec3 norm=normalize(cyl2-cyl1);\n    norm=norm.zxy;\n    ab=cyl2-cyl1-norm*sin(t*5.+iTime*2.)*.6;\n    ap=p-cyl1;\n    \n    t=dot(ap,ab)/dot(ab,ab);\n    \n    t=clamp(t,0.,1.);    \n    \n    vec3 point_cyl=cyl1+t*ab;\n    \n    return length(p-point_cyl)-cyl_rad;\n}\n\nfloat getPoints(vec3 p){\nvec3 p2=fract(p);\nvec3 p3=vec3(.5+.3*Hash21(floor(p.xy)),.5+.3*Hash21(floor(p.xz)),.5);\n   p3.y+=sin(iTime)*.1;\n return min(length(p2-p3)-.01*Hash21(p2.xz),.18);\n\n}\nfloat getSphereFish(vec3 p,float r){\n\nreturn length(p)-r;\n}\n\nfloat getCubeFish(vec3 p,vec3 cube){\n    \n\n  vec3 q = abs(p) - cube;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat getTail(vec3 p,vec3 cube){\n    cube.z+=p.x;\n  cube.z=clamp(cube.z,.1,1.);\n  vec3 q = abs(p) - cube;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nfloat getFish(vec3 p){\np.x-=p.x/3.;\nfloat box=getCubeFish(p,vec3(.2,.003,.2));\nfloat sph=getSphereFish(p,.125);\nfloat factor=.5;\nfloat dist=factor*box+(1.-factor)*sph;\ndist=min(dist,getTail(p+vec3(-.125,0,0),vec3(.1,.01,.1)));\n return dist*.5;\n}\n\n\nfloat GetDist(vec3 p) {\n\n    float d=p.y+Hash21(p.xz)-.5;\n    if(iTime<5.2){\n\n    float cylinder=getCylinder(p,vec3(1,1,3.+iTime*.4),vec3(1,2,4.+iTime*.4));\n    d=min(d,cylinder);\n    }\n    d=min(d,getPoints(p));\n    d=min(d,getCube(p-vec3(0,2,6)));\n    \n    if(iTime>1. && iTime<4.){\n vec3 p2=p-vec3(1,2.,6.);    \n\n p2.yz*=Rot(3.1416*.5);\n p2.y-=cos(iTime*2.-p2.x)*.4; \n p2.x+=iTime;\n d= min(d,getFish(p2)); \n }\n if(iTime>3.5 && iTime<10.){\n vec3 p3=p-vec3(1,1.,9);    \n vec3 p4=p-vec3(3.5,2,9.5);\n p3.yz*=Rot(3.1416*.5);\n p3.y-=cos(iTime*2.-p3.x)*.4; \n p3.x+=iTime-3.5;\n \n p4.yz*=Rot(3.1416*.5);\n p4.y-=cos(iTime*2.-p4.x+1.7)*.4; \n p4.x+=iTime-3.5; \n d= min(d,getFish(p3));  \n d= min(d,getFish(p4)); \n }\n \n if(iTime>6.5 && iTime<13.){\n vec3 p3=p-vec3(1,1.,12);    \n vec3 p4=p-vec3(3.5,2,12.5);\n p3.yz*=Rot(3.1416*.5);\n p3.y-=cos(iTime*2.-p3.x)*.4; \n p3.x+=iTime-6.5;\n \n p4.yz*=Rot(3.1416*.5);\n p4.y-=cos(iTime*2.-p4.x+1.7)*.4; \n p4.x+=iTime-6.5; \n d= min(d,getFish(p3));  \n d= min(d,getFish(p4)); \n } \n \n if(iTime>10. && iTime <17.){\n    float cylinder=getCylinder(p,vec3(-4.+(iTime-10.)*.6,1.5,16.),\n    vec3(-2.+(iTime-10.)*.6,1.5,15.5));\n    d=min(d,cylinder);\n \n \n }\n \n if(iTime>20.){\n   vec3 p5=p-vec3(0,2,26.);\n   p5.xz*=Rot(iTime);\n   p5.xy*=Rot(iTime);   \n   d=min(d,getCubeFish(p5,vec3(.5)));\n }\n \n    return d;\n}\n\nfloat RayMarch(vec3 rayOrig, vec3 rayDir){\nfloat dist=0.;  \n    \n    for(int i=0; i<MAX_STEPS; i++){\n     vec3 currentPoin= rayOrig+dist*rayDir;\n        float currentDis= GetDist(currentPoin);\n        dist+=currentDis;\n        if(currentDis<SURF_DIST || dist> (MAX_DIST+iTime))break;\n    }\n    return dist;\n}\n//get average value of the surface direction \nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n//get distance to the light source\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    dif=clamp(dif,0.,1.);\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n\n    vec3 ro=vec3(0,2.2,22.);\n    if(iTime<22.){\n    ro = vec3(0, 2.2, 0.+iTime);\n    }\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.2, 1));\n\n\n    if(iTime>25.)\n    {\n    rd.xy*=Rot(-3.1416*.25);\n    }\n\n\n    float dif=0.;\n    float time=ro.z;\n    vec3 ro2=ro;\n\n    float d = RayMarch(ro2, rd);\n    vec3 p = ro2 + rd * d;\n    \n    if(length(p)<10.+iTime)\n    dif=1.-(length(p)*.19-time*.19);//GetLight(p);\n    vec3 col = vec3(dif);\n    if(iTime>23. && Hash21(vec2(iTime,iTime))<.6)\n    {\n    col=vec3(0);\n    }\n    col-=.4*dot(uv,uv);\n    fragColor=vec4(col,1);\n    \n    \n}","name":"Image","description":"","type":"image"}]}