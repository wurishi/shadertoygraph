{"ver":"0.1","info":{"id":"7sKcRm","date":"1654633967","viewed":250,"name":"Broken Ocean Arches","username":"Hyeve","description":"Broken semi-intentionally, that is. (At least in terms of the raymarching).\nI seem to just keep making more and more of these.. dark, futuristic, fantasy-like things lately. Perhaps there's a reason for that.\nRegardless, they look pretty cool!","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","transparency","water","ocean","glass","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//See the common tab for fps control.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DTR 0.01745329\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 uv=vec2(0);\nvec3 cp,cn,cr,ss,oc,gl=vec3(0),vb,ro,rd,so,ld;\nvec4 fc=vec4(0),cc=vec4(0);\nfloat tt,cd,sd,md,io,oa,td=0.;\nint es=0,ec=0,fi=1;\n\n\nfloat bx(vec3 p,vec3 s){vec3 q=abs(p)-s;return min(max(q.x,max(q.y,q.z)),0.)+length(max(q,0.));}\nfloat tor(vec3 p,vec2 t){return length(vec2(length(p.xz)-t.x,p.y))-t.y;}\n\nfloat h11 (float a){return fract(sin((a)*12.9898)*43758.5453123);}\n\nfloat space(vec3 p, float f)\n{\n\t\tp.y *= 2.;\n\t\tfloat v = length(sin(p*vec3(1.-(cos(p.x-tt+p.z*0.3)*0.1+0.1),1.,1.-(cos(p.z-tt+p.x*0.3)*0.1+0.1)))) - 0.5;\n\t\tv += length((p.y+5.)*0.3);\n\t\tv += p.y * f;\n\t\n\t\treturn v * 0.3;\n}\n\nfloat mp(vec3 p)\n{\n\t\tvec3 pp = p;\n\t\n\t\t\n\t\n\t\tsd = space(p,1.);\n\t\n\t\n\t\tp.z -= tt;\n\t\tp.x = abs(p.x) - (sin(p.z)+4.);\n\t\tp.z = mod(p.z,14.)-7.;\n\t\tfloat scl = h11(sign(p.x)+floor(p.z-7.));\n\t\n\t\tfloat bxs =  bx(p,vec3(scl,5,1))-0.05;\n\t\tp.yz *= rot(DTR*90.);\n\t\tfloat arch =  tor(p+vec3(3,0,0),vec2((sin(p.z)+4.),0.5));\n\t\tbxs = min(bxs,arch);\n\t\t\n\t\tgl += exp(-length(p+vec3(3,7,0))) * vec3(0.5,0.5,1.) * 0.01;\n\t\n\t\tsd = min(sd,bxs);\n\t\t\n\t\tp = pp;\n\t\n\t\tsd = max(sd, -bx(p+vec3(0,2.2,0),vec3(100,1,100)));\n\t\n\t\tfloat under = space(p+vec3(1,0.6,2), 1.);\n\t\n\t\tsd = min(sd, under);\n\t\n\t\t//p.xz *= rot(tt);\n\t\n\t\t\n\t\n\t\tsd=abs(sd)-0.001;\n\t\n\t\tif(sd<0.01)\n\t\t{\t\n\t\t\tio=under<sd+0.01?-1.:1.;\n\t\t\toc=vec3(0.3,0.6,1);\n\t\t\toa=0.4;\n\t\t\tss=vec3(0);\n\t\t\tec=2;\t\n\n\t\t}\n\t\treturn sd;\n}\n\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3(.001);cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));cn=normalize(cn);}\nvoid shtr(){so=cp+cn*0.05;md=64.;for(cd=0.;cd<64.;cd+=mp(cp=ro+cn*0.05-ld*cd)){if(sd<md&&sd<cd)md=sd;if(sd<0.0001)break;}}\nvoid tr(){for(cd=0.;cd<64.;){cd+=mp(cp=ro+rd*cd);td+=sd;if(sd<0.0001)break;}nm();}\n\n\nvoid px(vec3 rd)\n{\n  vec3 bg=cc.rgb=vec3(0.3,0.5,0.8)-length(uv)*0.3+gl;\n\tif(cd<64.)\n\t{cc.a=oa;ld=normalize(cp-vec3(0, 3, 15));\n\tfloat df=max(dot(cn,-ld),0.),sp=max(1.-length(cross(rd+ld,cn)*0.8),0.)*(1.2-oa)*0.2,\n\tfo=exp(-pow(0.03*td,2.)),ao=1.-clamp(mp(cp+cn*.1)/.1,0.,1.);\n\tvec3 fr=pow(1.-abs(dot(rd,-cn)),3.)*mix(cc.rgb,oc,0.);\n  cc.rgb=(oc*df+fr+sp+ss)-ao*0.;\n\tshtr();cc.rgb-=(1.-clamp(md/0.05,0.,1.))*0.3;\n\tcc.rgb = mix(bg, cc.rgb, fo);}\n\telse cc.a=1.;cc.rgb+=gl;\n\tcc.rgb*=max(max(cc.r,max(cc.g,cc.b)),1.);\n}\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col)\n{\n  uv=vec2(frag.x/res.x,frag.y/res.y);\n  uv-=0.5;uv/=vec2(res.y/res.x,1);\n\ttt=mod(time+10.,100.);\n\t\n  ro=vec3(0,0,-15);\n\trd=normalize(vec3(uv,1.));\n\t\n\tfor(int i=0;i<10;i++)\n  {\n\t\ttr();ro=cp-cn*(io<0.?-0.01:0.01);\n\t\tcr=refract(rd,cn,i%2==0?1./io:io);\n    if((length(cr)==0.&&es<=0)||io<0.)\n\t\t{i++;cr=reflect(rd,cn);es=(io<0.?es:ec);}\n\t\tpx(rd);if(max(es,0)%3==0) rd=cr;\n\t\tes--;fc=fc+vec4(cc.rgb*cc.a,cc.a)*(1.-fc.a);\n\t\tif(fc.a>=1.)break;\n  }\n  col=fc/fc.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(mod(float(iFrame), 60./FPS) < 1. || iFrame < 5) render(fragCoord.xy,iResolution.xy,iTime,fragColor);\n    else fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//fps control for performance. Assumes the refresh rate of your monitor is 60hz\n//(120hz monitor set to 30 here will actually run at 60fps)\n#define FPS 30.","name":"Common","description":"","type":"common"}]}