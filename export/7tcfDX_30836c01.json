{"ver":"0.1","info":{"id":"7tcfDX","date":"1663717216","viewed":63,"name":"More cool glitch art","username":"PrenexNormalForm","description":"Stuff looks cool between copy-paste and modifying the pasted code!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["glitchart"],"hasliked":0,"parentid":"ftcfWX","parentname":"Flight of Marched Voxels!"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    Marches a ray one space at a time in a voxel grid while testing\n    for intersections, rather than using a signed distance field\n    \n    returns the distance to intersection\n*/\nvec3[2] voxelMarch(vec3 startPos, vec3 ray);\nbool isVoxel(vec3 pos);\n\nconst float MAX_DISTANCE = 100.;\n\n//helpers\nfloat lenSq(vec3 vec) {return dot(vec,vec);}\nfloat lenSq(vec2 vec) {return dot(vec,vec);}\nfloat lenSq(float vec) {return vec*vec;}\n\n\n//the normal of the face at pos (if exists) given the ray leading to it\nvec3 faceNormal(vec3 pos, vec3 ray)\n{\n    vec3 faceDists = min(fract(pos), fract(vec3(1) - pos));\n    float minDist = min(faceDists.x, min(faceDists.y, faceDists.z));\n    \n    vec3 normal = vec3(0.);\n    \n    if (minDist == faceDists.x) normal.x -= sign(ray.x);\n    else if (minDist == faceDists.y) normal.y -= sign(ray.y);\n    else normal.z -= sign(ray.z);\n    \n    return normal;\n}\n\n//ray must be normalized\n//returns newPos.xyz, distance traveled\nvec4 stepVoxel(vec3 pos, vec3 ray)\n{\n    //distance to next voxel\n    float scale;\n    \n    scale = (float(ray.x >= 0.) - fract(pos.x) - float(fract(pos.z) == 0. && ray.z < 0.)) / ray.x;\n    scale = min(scale, (float(ray.y >= 0.) - fract(pos.y) - float(fract(pos.z) == 0. && ray.z < 0.)) / ray.y);\n    scale = min(scale, (float(ray.z >= 0.) - fract(pos.z) - float(fract(pos.z) == 0. && ray.z < 0.)) / ray.z);\n    \n    return vec4(pos + ray * scale, scale);\n}\n\n//returns pos, normal\nvec3[2] voxelMarch(vec3 startPos, vec3 ray)\n{\n    vec3 pos = startPos;\n    float dist = 0.;\n    vec3 normal = vec3(0);\n    \n    for (int i = 0; i < int(2. * MAX_DISTANCE); i++)\n    {\n        vec4 stepped = stepVoxel(pos, ray);\n        pos = stepped.xyz;\n        dist = stepped.w;\n        normal = faceNormal(pos, ray);\n        if (dist > MAX_DISTANCE || isVoxel(pos - normal / 2.)) break;\n    }\n    \n    return vec3[] (pos, normal);\n}\n\n// rand function https://www.shadertoy.com/view/Xt23Ry\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nbool isVoxel(vec3 pos)\n{\n    bool voxel = false;\n    \n    voxel = voxel || floor(pos.xy) != vec2(0) && rand(floor(pos)) < 0.0015; \n    return voxel;\n}\n\nvec3 fragCoordToRay(float fov, vec2 fragCoord)\n{\n    float halfFOV = radians(fov) / 2.0;\n    float viewPlaneScale = tan(halfFOV);\n    vec2 centeredFragCoord = fragCoord - iResolution.xy * 0.5;\n    vec2 viewPlaneCoord = centeredFragCoord / iResolution.xx * 2.0;\n    vec3 ray = vec3(viewPlaneCoord * viewPlaneScale, -1.0);\n    return normalize(ray);\n}\n\n//from https://www.shadertoy.com/view/lscSzl\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0.1, 0.1, iTime);\n    vec3 cameraRay = fragCoordToRay(80., fragCoord);\n    //cameraRay.z *= -1.;\n    vec3[] march = voxelMarch(cameraPos, cameraRay);\n    vec3 pos = march[0];\n    vec3 normal = march[1];\n    bool vox = isVoxel(pos - normal / 2.);\n    \n    float dist = length(pos - cameraPos);\n\n    // Time varying pixel color\n    vec3 col = vec3(1) - vec3(dist / MAX_DISTANCE);\n\n    // Output to screen\n    fragColor = vec4(encodeSRGB(col),1.0);\n}","name":"Image","description":"","type":"image"}]}