{"ver":"0.1","info":{"id":"NdVSD1","date":"1634580988","viewed":180,"name":"Hex Template","username":"mgrant8164","description":"Template for hexagonal texture sampling.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535;\n\n//how many hexagons will fit into the frame\nconst float scale = 64.0;\n//hexagon shape geometric definitions\nconst float r = 0.5;\nconst float w = 2.0 * r;\nconst float h = sqrt(3.0) * r;\n//hexagon coordinate translation matrices\nconst mat2 hc2sc = mat2(\n    w * 0.75, -h / 2.0,\n    w * 0.75, h / 2.0\n);\nconst mat2 sc2hc = inverse(hc2sc);\n\nvec2 sc2hc_nearest(vec2 sc) {\n    //hexagon coordinates\n    vec2 hc;\n    \n    //calculate hexagon coordinates\n    hc = sc2hc * sc.xy;\n    \n    //get the four neighboring closest hexagon centers\n    vec2 hcf = floor(hc);\n    vec2 hcc = ceil(hc);\n    vec2 hva = hc2sc * vec2(hcc.x, hcc.y);\n    vec2 hvb = hc2sc * vec2(hcc.x, hcf.y);\n    vec2 hvc = hc2sc * vec2(hcf.x, hcc.y);\n    vec2 hvd = hc2sc * vec2(hcf.x, hcf.y);\n    //find the closest hexagon center in screen coordinates\n    float md = min(min(distance(sc, hva), distance(sc, hvb)), min(distance(sc, hvc), distance(sc, hvd)));\n    vec2 scm;\n    if(distance(sc, hva) == md)\n        scm = vec2(hcc.x, hcc.y);\n    else if(distance(sc, hvb) == md)\n        scm = vec2(hcc.x, hcf.y);\n    else if(distance(sc, hvc) == md)\n        scm = vec2(hcf.x, hcc.y);\n    else\n        scm = vec2(hcf.x, hcf.y);\n    \n    if(iMouse.z > 0.0) {\n        vec2 scm2 = round(hc);\n        scm = hc - round(hc);\n        scm = scm * 2.0;\n        \n        vec2 m = sc2hc * vec2(-1.0, sqrt(3.0));\n        float mm = m.y / m.x;\n        vec2 b = vec2(0.5);\n        \n        if(((abs(scm.x) > 0.5) || (abs(scm.y) > 0.5)) && (sign(scm.x) == sign(scm.y))) {\n            if(sign(scm.x) > 0.0) {\n                if((mm * fract(scm.x) + 1. < fract(scm.y) || (mm * fract(scm.y) + 1. < fract(scm.x)))) {\n                    if(scm.x > scm.y) scm2.x += 1.0;\n                    else scm2.y += 1.0;\n                }\n            }\n            if(sign(scm.x) < 0.0) {\n                if((mm * fract(-scm.x) + 1. < fract(-scm.y) || (mm * fract(-scm.y) + 1. < fract(-scm.x)))) {\n                    if(-scm.x > -scm.y) scm2.x -= 1.0;\n                    else scm2.y -= 1.0;\n                }\n            }\n        }\n        scm = scm2.xy;\n    }\n    return scm;\n}\n\nvec4 run(vec2 sc) {\n    return texture(iChannel0, (sc.xy) / (vec2(4.) * scale * iChannelResolution[0].xy / iChannelResolution[0].x) + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    //screen coordinates\n    vec2 sc = 2.0 * (fragCoord - (iResolution.xy*0.5)) / min(iResolution.x, iResolution.y) * scale;\n    //hexagon coordinates\n    vec2 hc = sc2hc_nearest(sc);\n    vec2 sc2 = hc2sc * hc;\n    \n    //hexagon shape geometric definitions\n    float r = 0.5;\n    float w = 2.0 * r;\n    float h = sqrt(3.0) * r;\n    \n    vec4 final_color = vec4(0.);\n    const int SS_LVL = 1;\n    const float step_size = 1.0/float(2*SS_LVL+1);\n    vec2 wh = vec2(w, h) * 0.5;\n    \n    final_color += run(sc2);\n    if(SS_LVL > 0) {\n        for(float r = 0.0; r < 2.0*PI; r += PI/3.0) {\n            for(float x = step_size/float(SS_LVL); x < 0.5; x += step_size/float(SS_LVL)) {\n                for(float y = 0.0; y <= x; y += step_size/float(SS_LVL)) {\n                    vec2 ss_cord = (hc2sc * vec2(x,y));\n                    ss_cord = sc2 + mat2(cos(r), sin(r), -sin(r), cos(r)) * ss_cord;\n                    final_color += run(ss_cord);\n                }\n            }\n        }\n    }\n    \n    final_color /= final_color.a;\n    \n    //final_color = mix(final_color, run(sc), 0.5);\n    //final_color = run(sc);\n    \n    //fragColor = texture(iChannel0, hc.xy / (vec2(4.) * scale * iChannelResolution[0].xy / iChannelResolution[0].x) + 0.5);\n    //fragColor = vec4(0.5 + 0.5*cos(iTime + scm.xyx/scale + vec3(0,2,4)), 1.0);\n    fragColor = final_color;\n}","name":"Image","description":"","type":"image"}]}