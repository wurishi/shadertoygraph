{"ver":"0.1","info":{"id":"WlyfDc","date":"1615158417","viewed":69,"name":"kifs 2d _4 (interactive)","username":"sus1357","description":"just look at that sweet boi\npause to play with non-strobo version, or don't pause (unless u have epilepsy maybe)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","interactive","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"    // ekrannaya konstanta - RAZMER OBLASTI CHISEL(a chto esli NE konstanta?...)\nvec2 DOMAIN_XY = vec2(8., 5.);\n\n    // KIFS-konstanti\nconst int N = 2;// N - kol-vo vektorov simmetrii\nconst int N_but_fancy = 2; // esli hochu uzaty tol'ko chasty vektorov\nconst int ITER = 3;// WHYYY IT MUST BE CONSTANT, STUPID GLSL LOOPS\n\n    //colors constants\nvec3 white = vec3(1.,1.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 red   = vec3(1.,0.,0.);\nvec3 blue  = vec3(0.,0.,1.);\nvec3 green = vec3(0.,1.,0.);\n\nfloat gauss(in vec2 p, in float s) {return exp( -(p.x*p.x+p.y*p.y)/(2.*s*s) );}\n    //tupoy 2d gauss s centrom v (0,0)\nfloat gauss_1d(float x, float m, float s) {return exp( -((x-m)*(x-m))/(2.*s*s) );}\n    //1d gauss\n    // ne delil na sigmu (s), no pohuy ( return (1/.s)*exp(...) )\nvec2 a2v(in float a){return vec2(cos(radians(a)), sin(radians(a)));}\n    //gradus -> vektor simmetrii\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n // sozdal prostranstvo (uv) razmerom v DOMAIN s tsentrom v (0,0)\n    vec2 uv = fragCoord*DOMAIN_XY/iResolution.xy - .5*DOMAIN_XY;\n \n                         //  | | |\n // KIFS KIFS KIFS KIFS KIFS v v v\n    // initialization\n    float scale = 2.;\n    \n    vec2 symm[N];// // = (, );\n    //symm[0] = a2v(60. + iTime*6.); symm[1] = a2v(-60.);\n    symm[0] = a2v(60. + iMouse.x); symm[1] = a2v(-60. + iMouse.y);\n    \n    vec2 offset = vec2(.0, .0);\n    vec2 dist = vec2(-1.,-1.);\n    \n    \n    \n    // algoritm\n    for(int i=0; i<ITER; i++) {\n        for(int n=0; n<N_but_fancy; n++) {\n            float len = dot(uv, symm[n]);\n            if( len < dist[n] ) {\n                uv -= 2.0*(len - dist[n])*symm[n];\n                //uv -= 2.0*(len - dist[i])*symm[i]\n            }\n            uv*=scale;\n            uv -= (scale - 1.) * offset;\n        }\n        if(float(i) > mod(30.*iTime, float(ITER))) break;\n    }\n\n // Time varying pixel color\n    vec3 col = 0.5 + 0.1*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 koltso  = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime) , 1. ) * red;\n    vec3 koltso2 = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime)+1.5*sin(.6*iTime)+3. , 1.5 )\n                        *\n                   (.9*green + .2*blue); // monstr\n    vec3 col_g = gauss(uv, .1)*white;\n\n // Output to screen\n\n    vec2 norm = fragCoord/iResolution.xy;\n   // vec3 col_ex = 0.5 + 0.5*cos(iTime+norm.xyx+vec3(0,2,4));\n   // col_ex *= .75*sin(iTime)+.5;\n    //fragColor = vec4(col+col_g+koltso,1.0);\n   // fragColor = vec4(col_g+koltso+koltso2+col_ex,1.0);\n    fragColor = vec4(col_g+koltso+koltso2,1.0);\n}","name":"Image","description":"","type":"image"}]}