{"ver":"0.1","info":{"id":"fd3yRr","date":"1653405041","viewed":64,"name":"Fork Fork Quest bpaw22 167","username":"bpaw22","description":"Answer for Question 1 of D4 graphics assessment","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["texture"],"hasliked":0,"parentid":"7tjfzc","parentname":"Fork Question 1 bpaw22 668"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///Hey there! Here is my implementation for the first skills assessment prompt.\n///This is pretty straightforward and not super free-form, so it doesn't appear that there\n///is much for me to provide in terms of explanation.\n\nfloat pi = 3.142;\nfloat findAngle2DAtans(vec2 a, vec2 b)\n{\n    float twoPi = 2.0 * pi;\n    float atan1 = atan(a.y, a.x);\n    float atan2 = atan(b.y, b.x);\n    \n    float theta = (atan1 - atan2);\n    \n    return theta + iTime;\n}\n\nfloat findAngle2DCross(vec2 a, vec2 b)\n{\n \n    float theta = acos(dot(a, b) / (length(a)*length(b)));\n    \n    vec3 cProd = cross(vec3(a, 0.0), vec3(b,0.0));\n    \n    if(cProd.z > 0.0f)\n    {\n        theta = (theta * -1.0);\n        \n    }\n    \n    return theta - 2.0*iTime;\n}\n\n///\nfloat findRotatedTexCoord(vec2 a, vec2 b)\n{\n    float twoPi = 2.0 * pi;\n    float theta = findAngle2DAtans(a, b);\n    \n    float thetaOverTwoPi = theta / twoPi;\n    \n    return mod(thetaOverTwoPi, 1.0);\n}\n\n//for this assessment, I conceptualized the \"radius text coord\" as the V texture coordinate. \n// from eyeballing the given desired solution image, it looked like this is what was happening, so I did that.\nfloat findRadiusTexCoord(vec2 a, vec2 b)\n{\n    //get max length for calculating v.\n    float maxLength = distance(vec2(1.0,1.0), vec2(.5,.5));\n    float rad = distance(a, b) / maxLength;\n\n    return rad;\n}\n\n//twisted texSpin answer to match example texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // limit rendering to the lower left of the screen\n    const float size = 258.0;    \n    if (fragCoord.x > size || fragCoord.y > size)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n\tvec2 uv = fragCoord/size;\n    vec2 center = vec2(0.5, 0.5);\n    vec2 upVec = vec2(0.0, 1.0);\n    vec2 centeredUV = uv - center; //centered UV captures the location of the current fragment with respect to the center of\n                                   //our \"texture vortex\" \n    \n    \n    float newV = findRadiusTexCoord(uv, center);\n    float newU = findRotatedTexCoord(centeredUV, normalize(upVec));\n    \n    vec2 newSample = vec2(newU, newV);\n    \n    fragColor = texture(iChannel0,newSample);\n\n}","name":"Image","description":"","type":"image"}]}