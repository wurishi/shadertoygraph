{"ver":"0.1","info":{"id":"3sfSWj","date":"1552149523","viewed":141,"name":"Задание 1. Трассировка лучей","username":"anna_antipina_321","description":"Задание 1. Трассировка лучей","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 100\n\nstruct Material {\n    vec4 ambient;\n\tvec4 diffuse;\n\tvec4 specular;\n\tfloat shininess;\n};\n    \nstruct Light{\n    vec3 pos;\n    vec4 color;\n    float ambientIntensity;\n    float diffuseIntensity;\n    float specularIntensity;\n    float range;\n};     \n    \nstruct Object{\n    int index;\n    float sd;\n    Material material;\n    vec4 color;\n    vec3 posOffset;\n};\n    \nMaterial planeMat = Material (vec4(0.2125,0.1275,0.054,1),\n                               vec4(0.714,0.4284,0.18144,1),\n                               vec4(0.0,0.0,0.0,1),\n                               5.6);   \nMaterial planeMat1 = Material (vec4(0.2125,0.1275,0.054,1),\n                               vec4(0.2,0.1,0.1,1),\n                               vec4(0.1,0.05,0.08,1),\n                               8.6);   \nMaterial bronze = Material(vec4(0.2125,0.1275,0.054,1),\n                               vec4(0.714,0.4284,0.18144,1),\n                               vec4(0.393548,0.271906,0.166721,1),\n                               12.6);\nMaterial brass = Material(vec4(0.329412,0.223529,0.027451,1),\n                              vec4(0.780392,0.568627,0.113725,1),\n                              vec4(0.492157,0.241176,0.407843,1),\n                              15.8974);\nObject objects[6];\n    \nLight lights[2];\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nObject Minimum(Object obj1, Object obj2){\n    if (obj1.sd < obj2.sd)\n        return obj1;\n    else\n        return obj2;\n}\n\nObject GetMinObj(vec3 p) \n{\n    vec3 currP = p;\n    currP.xz *= Rot(iTime);\n    objects[0].sd = sdPlane(p-objects[0].posOffset, vec4(0.,1.,0.,0.));\n    objects[1].sd = sdSphere(currP-objects[1].posOffset, .7);\n    objects[2].sd = sdBox(currP - objects[2].posOffset, vec3(0.5, 0.5, 0.5));\n    objects[3].sd = sdCapsule(currP - objects[3].posOffset, vec3(0,0.2,4), vec3(1,0.2,4), .3);\n    objects[4].sd = sdTorus(currP - objects[4].posOffset, vec2(0.4, 0.2));\n\tcurrP.yz *= Rot(1.6);\n    objects[5].sd = sdTriPrism(currP - objects[5].posOffset, vec2(0.3, 0.6));\n    Object result = Minimum(objects[0], objects[1]);\n    result = Minimum(result,objects[2]);\n    result = Minimum(result,objects[3]);\n    result = Minimum(result,objects[4]);\n    result = Minimum(result,objects[5]);\n    return result;\n}\n\nstruct RayMarchResult{\n\tObject obj;\n    float dist;\n    vec3 normal;\n};\n\nvec3 Normal (vec3 p)\n{\n    Object obj = GetMinObj(p);\n    float dist = obj.sd;\n    vec2 e = vec2(.01,0);\n    Object obj1,obj2,obj3;\n    obj1 = GetMinObj(p - e.xyy);\n    obj2 = GetMinObj(p - e.yxy);\n    obj3 = GetMinObj(p - e.yyx);\n    vec3 normal = dist - vec3(obj1.sd, obj2.sd, obj3.sd);\n    return normalize(normal);                    \n}    \n    \nRayMarchResult RayMarch (vec3 rayOrigin, vec3 rayDirection) \n{\n    float distFromOrigin = .0;\n    RayMarchResult result;\n    for (int i = 0; i < MAX_STEP; i++)\n    {\n        vec3 p = rayOrigin + distFromOrigin*rayDirection;\n        result.normal = Normal(p);\n        Object obj = GetMinObj(p);\n        result.obj = obj;\n        float currDist = obj.sd;\n        distFromOrigin += currDist;   \n        result.dist = distFromOrigin;\n        if ((currDist < 0.001) || (distFromOrigin > 500.))\n            break;\n    }\n    return result;\n}\n\nfloat shadow(vec3 p, vec3 rayToLight, float mint, float maxt){\n\tfloat t = mint;\n    for (int i = 0; i < 128; ++i) {\n        Object obj = GetMinObj(p + rayToLight * t);\n        float dist = obj.sd;\n        if (dist < 0.001)\n            return 0.0;\n        t += dist;\n\t\t\n\t\tif (t > maxt)\n\t\t\tbreak;\n    }\n    return 1.0;\n}\n\nfloat shadowSoft(vec3 p, vec3 rayToLight, float mint, float maxt, float k){\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for (int i = 0; i < 128; ++i) {\n        Object obj = GetMinObj(p + rayToLight * t);\n        float dist = obj.sd;\n        if (dist < 0.001)\n            return 0.0;\n\t\tres = min(res, k*dist/t);\n        t += dist;\n\t\t\n\t\tif (t > maxt)\n\t\t\tbreak;\n    }\n    return res;\n}\n\nvec4 Shade(vec3 p, vec3 normal) {\n   \tfloat comb = 0.1;\n    vec4 res = vec4(vec3(comb), 1.0);\n    for (int i = 0; i<2; i++) {\n\t\tvec3 rayToLight = lights[i].pos - p;\n\t\tfloat dist = length(rayToLight);\n\t\trayToLight = normalize(rayToLight);\n\t\tfloat shade;\n\t\tif (i == 0) \n            shade = shadow(p, rayToLight, 0.01, dist);\n\t\telse\n            shade = shadowSoft(p, rayToLight, 0.0625, dist, 8.0);\n\t\n\t\tif (shade > 0.0){\n\t\t\tfloat diffuse = 2.0 * max(0.0, dot(normal, rayToLight));\n\t\t\tfloat attenuation = 1.0 - pow(min(1.0, dist/lights[i].range), 2.0);\n\t\t\tres += diffuse * attenuation * shade * lights[i].color;\n        }\n    }\n\treturn res;\n}\n\nvec4 LightRay (vec3 p)\n{\n    Object obj = GetMinObj(p);\n    vec4 result = vec4(0.0,0.0,0.0,0.0);\n    for (int i = 0; i<2; i++) {\n  \n    \tvec4 ambient = lights[i].ambientIntensity * lights[i].color;\n        \n        vec3 lightRay = normalize(p-lights[i].pos);\n    \tvec3 normal = Normal(p);\n        float diffuseFactor = clamp(dot(normal,-lightRay), 0.0, 1.0);\n        vec4 diffuse = diffuseFactor * lights[i].color;\n        \n        vec3 lightReflect = normalize(reflect(lightRay, normal));\n        float specularFactor = pow(max(0.0, dot(p, lightReflect)),obj.material.shininess);\n        vec4 specular = lights[i].specularIntensity * lights[i].color * obj.material.specular * specularFactor;\n        float distance = length(p - lights[i].pos);\n  \t\tfloat pointFactor = 1.0 / pow(distance, 2.);\n        result += pointFactor * obj.color * (ambient + diffuse + specular);\n    }\n   \n    return result;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Object plane;\n    plane.index = 0;\n    plane.color = vec4(0.0,0.1,0.3,1.0);\n    plane.material = planeMat;\n    plane.posOffset = vec3(0., 0.0, .0);\n    objects[0] = plane;\n    \n    Object sphere;\n    sphere.index = 1;\n    sphere.color = vec4(0.2,0.5,0.7,1.0);\n    sphere.material = brass;\n    sphere.posOffset = vec3(1., 1.7, -.1);\n    objects[1] = sphere;\n    \n    Object box;\n    box.index = 2;\n    box.color = vec4(0.3,0.3,0.,1.);\n    box.material = bronze;\n    box.posOffset = vec3(2, .0, .0);\n    objects[2] = box;\n    \n    Object capsule;\n    capsule.index = 3;\n    capsule.color = vec4(0.7,0.0,0.1,1.);\n    capsule.material = planeMat1;\n    capsule.posOffset = vec3(0.0, 0.1, -3.0);\n    objects[3] = capsule;\n    \n    Object torus;\n    torus.index = 4;\n    torus.color = vec4(0.2,0.2,0.6,1.);\n    torus.material = bronze;\n    torus.posOffset = vec3(0.3, .2, -1.);\n    objects[4] = torus;\n    \n    Object triPrism;\n    triPrism.index = 5;\n    triPrism.color = vec4(0.0,0.6,0.6,1.);\n    triPrism.material = brass;\n    triPrism.posOffset = vec3(1.0, 0.0, 0.4);\n    objects[5] = triPrism;\n    \n    lights[0] = Light(vec3(1.0, 3.2,2.0), vec4(0.6,0.0,0.0, 1.0), 35.8, 35.8,0.6, 5.0);\n    lights[1] = Light(vec3(-3.0,1.7,3.0), vec4(0.0,0.8,1.0, 1.0), 16.2,16.2,0.1, 6.0);\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 rayOrigin = vec3(1., 2.0, -5.0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y-.2, 1.0));\n    \n    RayMarchResult result = RayMarch(rayOrigin, rayDirection);\n    vec3 fragmentPos = rayOrigin + result.dist*rayDirection;\n    vec4 shade = Shade(fragmentPos, result.normal);\n    vec4 pointLight = LightRay(fragmentPos) + shade;\n\n    fragColor = vec4(pointLight);\n}","name":"Image","description":"","type":"image"}]}