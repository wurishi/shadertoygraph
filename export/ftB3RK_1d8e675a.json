{"ver":"0.1","info":{"id":"ftB3RK","date":"1624206793","viewed":149,"name":"One Thousand Suns","username":"DrNoob","description":"Animated reproduction of \"One Thousand Suns\" by Ben Kovach:\nhttps://www.benkovach.art/portfolio#/forgetting-the-tide/","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Hommage Ã  Ben Kovach 1 (\"One Thousand Suns\", 2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Animated reproduction of \"One Thousand Suns\" by Ben Kovach:\n// https://www.benkovach.art/portfolio#/forgetting-the-tide/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float PI  = 3.141592653589793;\nconst float TAU = 6.283185307179586;\nconst vec3 BG     = vec3(240, 236, 238) / 255.0;\nconst vec3 BLACK  = vec3( 35,  46,  37) / 255.0;\nconst vec3 RED_HSV    = vec3( 4.0 / 360.0, 0.23, 1.0);\nconst vec3 YELLOW_HSV = vec3(61.0 / 360.0, 0.72, 1.0);\n\n// 1D hash for 3D input\nfloat hash13(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D hash for 2D input\nvec2 hash22(in vec2 p) {\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return fract(sin(p)*43758.5453);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash12(i);\n    float b = hash12(i + vec2(1.0, 0.0));\n    float c = hash12(i + vec2(0.0, 1.0));\n    float d = hash12(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(in vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int NOCTAVES = 5;\n    for (int i = 0; i < NOCTAVES; ++i) {\n        v += a * vnoise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D rotation matrix\nmat2 rotMat2(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Hatching method is a derivative of\n// https://www.shadertoy.com/view/4lfXDM\nfloat hatch(in vec2 p, in float str) {\n    float rz = 1.0;\n\n    const int MAXITER = 10;\n    for (int i = 0; i < MAXITER; ++i)\n    {\n        float n = vnoise(vec2(25.0, 500.0) * p);\n        n = smoothstep(-0.1 * str, 2.3 - 0.1 * str, n);\n        rz = min(1.0 - n, rz);\n        //p.xy = p.yx;\n        p += 0.07;\n        p *= 1.2;\n        if (float(i) > str) {\n            break;\n        }\n    }\n\n    return rz;\n}\n\n// SDF for a regular star by iq\n// https://www.shadertoy.com/view/3tSGDy\nfloat sdStar(in vec2 p, in float r, in int n, in float m) {\n    // next 4 lines can be precomputed for a given shape\n    float an = PI / float(n);\n    float en = PI / m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n// Smooth HSV to RGB conversion by iq\nvec3 smoothHsvToRgb(in vec3 c) {\n    vec3 rgb = abs(mod(c.x*6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0;\n    rgb = clamp(rgb, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0 - 2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat sin01(float x) {\n    return 0.5 + 0.5 * sin(x);\n}\n\nfloat time() {\n    return 0.5 * iTime;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized screen coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Grid\n    const float GW = 18.0;               // Grid width\n    const float GH = 10.0;               // Grid height\n    vec2 grid = vec2(GW, GH);            // Grid resolution\n    vec2 st = uv * grid;                 // Grid coordinates\n    vec2 gv = fract(st);                 // Grid cell coordinates\n    vec2 id = floor(st);                 // Grid cell integer coordinates\n    int idx = int(id.x + id.y * grid.x); // Grid cell index\n\n    // Determine background\n    const float MAXINTEN = 0.7;\n    float hash = hash13(vec3(fragCoord.xy, fract(0.0005 * iTime)));\n    float ramp = max(1.0 - (uv.x + uv.y), 0.0);\n    vec3 col = BG + MAXINTEN * ramp * vec3(hash - 0.5);\n    \n    // Do not draw outer cells\n    bool isInnerCell = (int(id.x) > 0 && int(id.x) < int(grid.x) - 1 &&\n                        int(id.y) > 0 && int(id.y) < int(grid.y) - 1);\n\n    // Do not draw cell boundaries\n    const float BW = 0.04;\n    float n = -0.01 + 0.02 * vfbm(10.0 * gv - 0.25 * iTime);\n    float db = min(min(abs(gv.x), abs(gv.y)), min(abs(1.0 - gv.x), abs(1.0 - gv.y)));\n    bool notBoundary = abs(db + n) > BW;\n    \n    if (isInnerCell && notBoundary) {\n        // Cell-dependent random numbers\n        float r1 = hash12(id);\n        float r2 = hash12(id + vec2(13.0, 37.0));\n        float r3 = hash12(id + vec2(37.0, 73.0));\n        float r4 = hash12(id + vec2(73.0, 137.0));\n        \n        // Animated offset\n        vec2 animOff = vec2(sin01(time()), sin01(2.0 * time()));\n        \n        // Weighted randomization of cell orientation\n        // Weights change with distance from the top left grid cell\n        float w = 0.5 + 0.5 * sin(0.29 * length(vec2(id.x, grid.y - id.y)) - 3.0);\n        float w4 = floor(4.0 * w);\n        float angle1 = 0.25 * w4 * TAU;\n        float angle2 = angle1 + 1.5 * PI;\n        \n        // Wiggle orientation a litte bit per cell\n        const float WIGGLE = 0.2;\n        angle1 += -0.5 * WIGGLE + WIGGLE * r1;\n        angle2 += -0.5 * WIGGLE + WIGGLE * r2;\n        \n        // Create two sets of orientations\n        vec2 p = rotMat2(angle1) * (gv - vec2(0.5));\n        vec2 q = rotMat2(angle2) * (gv - vec2(0.5));\n        \n        // Common hatching parameters for both sets\n        vec2 hoff = -0.01 + 0.02 * animOff;\n        \n        // Cell-dependent background hatching\n        const float BSCALE = 0.4;\n        float hstr = pow(2.0 - p.x - p.y, 1.5); // Reduce hatch strength diagonally\n        float bh = hatch(BSCALE * (p + id + hoff), hstr);\n        \n        // Cell-dependent star shape hatching\n        const float SSCALE = 0.2;\n        const float RADIUS = 0.8;\n        const float HSTR = 5.5;\n        int npeaks = 5 + int(6.0 * r3);\n        float m = 2.0 + 3.0 * r4;\n        float sd = sdStar(q + vec2(0.5), RADIUS, npeaks, m);\n        float sh = smoothstep(0.15, 0.0, sd) * hatch(SSCALE * (q + id + hoff), HSTR);\n        \n        // Animated lighting\n        vec2 lpos = animOff * grid;\n        float l = clamp(pow(length(st - lpos) / grid.y, 1.2), 0.0, 1.0);\n        vec3 light = smoothHsvToRgb(mix(RED_HSV, YELLOW_HSV, l));\n        float wl = 0.5 * smoothstep(1.25, 0.0, l);\n        \n        // Compose cell color\n        col = vec3(bh);\n        col = mix(col, BLACK, sh);\n        col += wl * light;\n    }\n\n    // Tweak contrast\n    col = pow(col, vec3(1.4));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}