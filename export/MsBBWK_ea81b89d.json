{"ver":"0.1","info":{"id":"MsBBWK","date":"1502215233","viewed":251,"name":"Marble Balls","username":"yumcyawiz","description":"marble texture generated by fbm noise + domain warping\nhttp://iquilezles.org/articles/warp/warp.htm","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat fbm2(vec2 p) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        r += amp * noise(freq*p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return r;\n}\n\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\nfloat fbm3(vec3 p) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        r += amp * noise(freq*p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return r;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\n\nvec2 dmin(vec2 d1, vec2 d2) {\n    if(d1.x < d2.x) {\n        return d1;\n    }\n    else {\n        return d2;\n    }\n}\n\n\nvec2 DF(vec3 p) {\n    vec3 q = p;\n    q.xz = mod(q.xz, 4.0) - 2.0;\n    vec2 s1 = vec2(sdSphere(q, 1.0), 1);\n    vec2 s2 = vec2(sdPlane(p, vec4(0, 1, 0, 1)), 2);\n    return dmin(s1, s2);\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        DF(p + vec3(eps, 0, 0)).x - DF(p + vec3(-eps, 0, 0)).x,\n        DF(p + vec3(0, eps, 0)).x - DF(p + vec3(0, -eps, 0)).x,\n        DF(p + vec3(0, 0, eps)).x - DF(p + vec3(0, 0, -eps)).x\n    ));\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    vec3 hitNormal;\n    int steps;\n    float t;\n    int hitObj;\n};\nconst int maxSteps = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    vec3 hitNormal = vec3(0);\n    int steps = 0;\n    float t = 0.0;\n    int hitObj = 0;\n    for(int i = 0; i < maxSteps; i++) {\n        vec3 p = from + t*rayDir;\n        float d = DF(p).x;\n        if(d < 0.001) {\n            hit = true;\n            hitPos = p;\n            hitNormal = calcNormal(p);\n            steps = i;\n            hitObj = int(DF(p).y);\n            break;\n        }\n        t += d;\n    }\n    return Ray(hit, hitPos, hitNormal, steps, t, hitObj);\n}\n\n\nfloat detailedAO(vec3 hitPos, vec3 hitNormal, float k) {\n    float ao = 0.0;\n    for(int i = 1; i <= 5; i++) {\n        float d1 = float(i)/float(5) * k;\n        vec3 p = hitPos + d1*hitNormal;\n        ao += 1.0/pow(2.0, float(i)) * (d1 - DF(p).x);\n    }\n    return 1.0 - clamp(ao, 0.0, 1.0);\n}\n\n\nfloat softShadow(vec3 hitPos, vec3 lightPos, float k) {\n    vec3 lightDir = normalize(lightPos - hitPos);\n    float ss = 1.0;\n    float t = 0.1;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = hitPos + lightDir*t;\n        float d = DF(p).x;\n        if(d < 0.001) {\n            return 0.0;\n        }\n        ss = min(ss, k * d/t);\n        t += d;\n    }\n    return ss;\n}\n\n\n\nvec3 phong(vec3 hitPos, vec3 hitNormal, vec3 rayDir, vec3 lightPos, vec3 dc, vec3 sc) {\n    vec3 lightDir = normalize(lightPos - hitPos);\n    float diffuse = max(dot(lightDir, hitNormal), 0.0);\n    float specular = pow(max(dot(reflect(-lightDir, hitNormal), -rayDir), 0.0), 8.0);\n    return 0.5*diffuse*dc + 0.5*specular*sc;\n}\n\n\nvec3 marble(float u, float v) {\n    vec2 p = vec2(u, v);\n    vec2 q = vec2(0);\n    vec2 r = vec2(0);\n    q.x = fbm2(p + vec2(1, 1));\n    q.y = fbm2(p + vec2(2, 2));\n    r.x = fbm2(p + 2.0*q + vec2(1, 1));\n    r.y = fbm2(p + 2.0*q + vec2(2, 2));\n    return fbm2(p + 4.0*r) * vec3(0, q.x + r.x, q.y + r.y);\n}\nvec3 checkerboard(float u, float v, float interval) {\n    u = floor(u/interval*2.0);\n    v = floor(v/interval*2.0);\n    float p = mod(u + v, 2.0);\n    return vec3(0.1 + 0.9*p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    float t = 0.4*iTime;\n    vec3 camPos = 3.0 * vec3(sin(t), 0.5, cos(t));\n    vec3 camFront = -normalize(camPos);\n    vec3 camRight = cross(camFront, vec3(0, 1, 0));\n    vec3 camUp = cross(camRight, camFront);\n    vec3 rayDir = normalize(1.5*camFront + uv.x*camRight + uv.y*camUp);\n    \n    vec3 lightPos = vec3(2, 5, 0);\n    \n    Ray tr = trace(camPos, rayDir);\n    vec3 color = vec3(0);\n    if(tr.hit) {\n        float sAO = 1.0 - float(tr.steps)/float(maxSteps);\n        float dAO = detailedAO(tr.hitPos, tr.hitNormal, 1.2);\n        float fog = exp(-0.2*tr.t);\n        \n        float ss = softShadow(tr.hitPos, lightPos, 12.0);\n        \n        vec3 mat = vec3(1);\n        vec3 brdf = vec3(1);\n        if(tr.hitObj == 1) {\n        \tfloat u = atan(tr.hitNormal.y, length(tr.hitNormal.xz)) + 3.14;\n        \tfloat v = atan(tr.hitNormal.z, tr.hitNormal.x) + 3.14;\n            mat = marble(u, v);\n            brdf = phong(tr.hitPos, tr.hitNormal, rayDir, lightPos, mat, vec3(1));\n        }\n        else if(tr.hitObj == 2) {\n            mat = checkerboard(tr.hitPos.x, tr.hitPos.z, 1.0);\n            brdf = phong(tr.hitPos, tr.hitNormal, rayDir, lightPos, mat, vec3(1));\n        }\n        \n        float geo = 100.0/pow(distance(tr.hitPos, lightPos), 2.0);\n        \n        color = 0.7 * ss * geo * brdf + 0.3*dAO*mat;\n        color *= fog;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}