{"ver":"0.1","info":{"id":"7t2GR3","date":"1625616459","viewed":71,"name":"Nested Cell Maze (Multipass)","username":"MazeMason","description":"Nested Cell Maze keeping previous maze in buffer (multi pass approach). 8 x 8 cells are stored in buffer's fragColor as in 4 components x 16 bits. On each pass, each 2 x 2 mini-maze is expanded to a 4 x 4 perfect maze with same outside connections.    ","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["recursive","maze"],"hasliked":0,"parentid":"7lS3RV","parentname":"Nested Cell Maze Multipass"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// reads a block from the maze as mapped on the buffer on channel 0\nbool getBit(sampler2D channel, ivec2 mazeCoord) {\n\n    mazeCoord -= 1;\n    ivec2  colorCoord = ((mazeCoord % 8) >> 2 ); \n\n    vec4 color = texelFetch(channel, mazeCoord / ivec2(8), 0);\n    \n    uint word = floatBitsToUint(color[colorCoord.y * 2 + colorCoord.x]);\n    \n    // x0y0 x1y0 x2y0 x3y0 x0y1 x0y1 x2y1 x3y1 x0y2 x1y2 x2y2 x3y2 ....\n    return bool(word & (1u << ((mazeCoord.x % 4) + ((mazeCoord.y % 4) << 2))));\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zoom in if in not expand mode\n    int zoom = (1 << (levels - level) * int(!expand) )* size;\n    \n    // gray out outside the maze\n    float outside = float(2 << level)+ 2.0;\n    \n    // map fragment on screen to maze block on buffer\n    ivec2 mazeCoord = ivec2((fragCoord  - (iResolution.xy - outside * float(zoom))/2.0)) / (zoom );\n    \n    fragColor = (all(lessThan(mazeCoord, ivec2(1.0+ outside * (1.0 - 1.0 / (outside))))) &&\n                    all(greaterThan(mazeCoord, ivec2(0)))) ?\n                        vec4(getBit(iChannel0, mazeCoord)) :\n                        vec4(vec3(.5),1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define blank 0x40000000u\n#define rooms 0x4000A0A0u\n\n#define nestedInner bottomDoor[(rand & 8u) >> 3] * uint(bottom) + leftDoor[(rand & 4u) >> 2] * uint(left)  + innerDoor[rand & 3u]\n#define inset 0x8u * uint(bottom) + 0x1000u * uint(left)  + 0x4800u + (0x2u << (3u * (rand & 1u)))\n\n// https://www.shadertoy.com/embed/ttc3zr\nuint murmurHash14(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n\nuint hash12(uint src) {\n    return murmurHash14(uvec4(iFrame, \n                                int(iDate.y * 32.0 + iDate.z),\n                                int(iDate.w),\n                                int(src)));\n}\n\n\n\nconst uint[] innerDoor = uint[](0x4A00u, 0x4240u, 0x4840u, 0x0A40u);\nconst uint[] bottomDoor = uint[](0x2u, 0x8u);\nconst uint[] leftDoor = uint[](0x1000u, 0x010u);\nconst uvec2[] nested = uvec2[](uvec2(0x10u, 0x2u),\n                                uvec2(0x40u, 0x8u),\n                                uvec2(0x1000u, 0x200u),\n                                uvec2(0x4000u, 0x800u));\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    uvec2 coord = uvec2(fragCoord - 0.5);\n    int inside = ((2 <<level) - 1) >> 3;\n\n    \n    \n    if(iFrame % delay == 0) {\n\n        if(all(lessThanEqual(coord, uvec2(inside)))) {\n            if(level == 0) {\n\n                // Initial maze\n                fragColor = vec4(uintBitsToFloat(blank | (0x020u * uint(coord == uvec2(0)))),\n                                    vec3(uintBitsToFloat(blank)));\n\n            } else {\n\n\n                uvec4 col = uvec4(rooms, uvec3(blank|(rooms * uint(level !=1))));\n\n                uvec2 parentCoord = coord / 2u ;\n                vec4 parentBlock = texelFetch(iChannel0, ivec2(parentCoord),0);\n                uvec2 parentIndex = (coord % 2u); \n                uint parentCell = floatBitsToUint(parentBlock[(parentIndex.y << 1) + parentIndex.x]);\n\n\n\n                uint rand = hash12(coord.x + coord.y * uint(inside));\n\n                // each component of buffer now is a new 4 x 4 maze \n                for(int i = 0; i < 4 && !(level == 1 && i !=0); ++i) {\n                    bool left = bool(parentCell &  nested[i].x);\n                    bool bottom = bool(parentCell &  nested[i].y);\n                    \n                    col[i] |= (coord.x == 0u || coord.y == 0u ||\n                                ((rand & 0xF0u) >> 4) > 8u ) ?\n                                (nestedInner) : \n                                (inset);\n                    rand >>= 8;\n                }\n\n\n                fragColor = vec4(uintBitsToFloat(col.x),\n                                    uintBitsToFloat(col.y),\n                                    uintBitsToFloat(col.z),\n                                    uintBitsToFloat(col.w));\n            }\n        } else {\n            // outside there are no maze\n            fragColor = vec4(uintBitsToFloat(blank));\n        }\n    } else {\n        // pass A buffer directly between iterations\n        fragColor = texelFetch(iChannel0, ivec2(coord), 0);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define level  ((iFrame / delay) % levels)\n\n\nconst int levels = 8;    // levels of iteration\nconst int delay = 60;    // frames within iterations\nconst int size = 4;      // size of the blocks in pixels \n                         // for all iterations for expand == true\n                         // or final iteration for expand == false\n\n\n\nconst bool expand = true; // expand on each iteration \n                          // or start big and subdivide on each iteration\n","name":"Common","description":"","type":"common"}]}