{"ver":"0.1","info":{"id":"wtfXWB","date":"1564140448","viewed":4929,"name":"Tetrahedral Voxel Traversal","username":"fizzer","description":"I adapted my single-sample-per-step terrain mesh ray traversal invention to 3D. In the end I decided to use something similar to the Hexakis cubic honeycomb, with each of the 6 square pyramids split into 4 tetrahedra making 24 tetrahedra per cubical cell.","likes":92,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","voxel","tetrahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2019 Edd Biddulph\n\n// I adapted my single-sample-per-step terrain mesh ray traversal invention to 3D.\n// In the end I decided to use something similar to the Hexakis cubic honeycomb,\n// but with each of the 6 square pyramids split into 4 tetrahedra, making\n// 24 tetrahedra per cubical cell.\n//\n// This gives a honeycomb with the appropriate symmetry to allow the ray traversal to\n// take only one sample of the 3D scalar field per visited tetrahedron along the ray.\n// The other three samples are re-used from the previous step by relying on the fact that\n// the next tetrahedral cell in the traversal is a mirror-image of the previous and shares one\n// face with the previous tetrahedral cell.\n//\n// Thanks to Shane for some interesting discussion on this.\n//\n\n// The shaders of this series:\n//\n//   Triangulated Heightfield Trick 1 - https://www.shadertoy.com/view/XlcBRX (Rigid, right-triangle)\n//   Triangulated Heightfield Trick 2 - https://www.shadertoy.com/view/tlXSzB (Rigid, equilateral)\n//   Triangulated Heightfield Trick 3 - https://www.shadertoy.com/view/ttsSzX (Deforming, equilateral)\n//   Tetrahedral Voxel Traversal      - https://www.shadertoy.com/view/wtfXWB (Rigid, tetrahedron)\n//\n\n// The isofunction. The surface to approximate is the set of points for which this function equals zero.\nfloat field(vec3 p)\n{\n    return max(textureLod(iChannel1, (p + p.zxy / 2.) / 70. - .4, 0.).r - .4, -(length(p.xy) - .5));\n}\n\n// Written by Shane, taken from https://www.shadertoy.com/view/MdSBRc\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n){\n\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n\n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// Distance to a set of planes constructed to be perpendicular to the surface approximation\n// plane and the intersecting sides of the tetrahedron.\n// This is only used for getting a nice wireframe for the shading.\nfloat tetrahedronPlaneDistance(vec3 p, vec3 pa, vec3 pb, vec3 pc, vec3 pd, vec4 plane)\n{\n    vec3 tn0 = cross(pb - pa, pc - pa);\n    vec3 tn1 = cross(pb - pd, pa - pd);\n    vec3 tn2 = cross(pc - pd, pb - pd);\n    vec3 tn3 = cross(pa - pd, pc - pd);\n    \n    vec3 n = normalize(plane.xyz);\n\n    vec3 b0 = normalize(cross(n, cross(n, tn0)));\n    vec3 b1 = normalize(cross(n, cross(n, tn1)));\n    vec3 b2 = normalize(cross(n, cross(n, tn2)));\n    vec3 b3 = normalize(cross(n, cross(n, tn3)));\n    \n    vec3 c0 = p + b0 * dot(pa - p, tn0) / dot(b0, tn0);\n    vec3 c1 = p + b1 * dot(pd - p, tn1) / dot(b1, tn1);\n    vec3 c2 = p + b2 * dot(pd - p, tn2) / dot(b2, tn2);\n    vec3 c3 = p + b3 * dot(pd - p, tn3) / dot(b3, tn3);\n    \n    float td0 = dot(p - c0, b0);\n    float td1 = dot(p - c1, b1);\n    float td2 = dot(p - c2, b2);\n    float td3 = dot(p - c3, b3);\n\t\n    return min(abs(td0), min(abs(td1), min(abs(td2), abs(td3))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime + texelFetch(iChannel3, ivec2(fragCoord) & 1023, 0).r / 70.;\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Setup camera ray.\n    \n    vec3 ro = vec3(0.01, -.1, 7.0);\n\n    ro.z += -time;\n\n    vec3 rd = normalize(vec3(uv.xy, -1.2));\n\n    // This time the \"Bresenham\"-style stepping requires a whopping 9 planes,\n    // so they need to be stored in an array and can't be processed together as a single vector.\n    \n    const int numplanes = 9;\n\n    vec3 ns[numplanes] = vec3[numplanes](\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1),\n        normalize(vec3(+1, +1,  0)),\n        normalize(vec3(-1, +1,  0)),\n        normalize(vec3(+1,  0, +1)),\n        normalize(vec3(-1,  0, +1)),\n        normalize(vec3( 0, +1, +1)),\n        normalize(vec3( 0, -1, +1)));\n\n    fragColor.rgb = vec3(0);\n    \n    float hsq2 = sqrt(2.) / 2.;\n\n    // Distances between planes.\n    \n    float slabWidths[numplanes] = float[numplanes](1., 1., 1.,\n                                                   hsq2, hsq2, hsq2, hsq2, hsq2, hsq2);\n    \n    // Find the starting tetrahedron by reflecting a base tetrahedron\n    // until it encloses the ray start point.\n    \n    vec3 c = floor(ro), f = ro - c;\n    \n    // The corners of the base tetrahedron.\n    vec3 pa = vec3(0, 1, 0);\n    vec3 pb = vec3(0, 0, 0);\n    vec3 pc = vec3(.5, .5, 0);\n    vec3 pd = vec3(.5, .5, .5);\n\n    float s0 = abs(dot(pd, ns[2]));\n    float s1 = abs(dot(pa, ns[4]));\n\n    vec3 pcenter = (pa + pb + pc + pd) / 4.0;\n\n    // Perform the reflections.\n    for(int k = 0; k < 2; ++k)\n        for(int j = 3; j < numplanes; ++j)\n        {\n            float dtet = dot(pcenter - .5, ns[j]);\n            float d = dot(f - .5, ns[j]);\n\n            if(sign(dtet) * sign(d) < 0.)\n            {\n                // The ray start point and the tetrahedron are on\n                // opposite sides of this plane, so reflect the tetrahedron.\n                pa -= ns[j] * dot(pa - .5, ns[j]) * 2.;\n                pb -= ns[j] * dot(pb - .5, ns[j]) * 2.;\n                pc -= ns[j] * dot(pc - .5, ns[j]) * 2.;\n                \n                // Swap one of the edges to maintain face winding orders.\n                swap(pa, pb);\n                \n                pcenter = (pa + pb + pc + pd) / 4.0;\n            }\n        }\n\n    pa += c;\n    pb += c;\n    pc += c;\n    pd += c;\n\n    // Ray geometry.\n    \n    float rod[numplanes];\n    float rdd[numplanes];\n    float inv[numplanes];\n    float is[numplanes];\n\n    for(int i = 0; i < numplanes; ++i)\n        rod[i] = dot(ro, ns[i]);\n\n    for(int i = 0; i < numplanes; ++i)\n        rdd[i] = dot(rd, ns[i]);\n\n    for(int i = 0; i < numplanes; ++i)\n        inv[i] = slabWidths[i] / rdd[i];\n\n    for(int i = 0; i < numplanes; ++i)\n        is[i] = (floor(rod[i] / slabWidths[i]) + step(0., rdd[i]) - rod[i] / slabWidths[i]) * inv[i];\n\n    for(int i = 0; i < numplanes; ++i)\n        inv[i] = abs(inv[i]);\n\n    float t0 = 0.;\n\n    vec3 ps[4] = vec3[4](pa, pb, pc, pd);\n    float fs[4] = float[4](field(pa), field(pb), field(pc), field(pd));\n\n    vec4 resultPlane = vec4(0);\n    float planet = 50.;\n\n    float steps[4] = float[4](s1, s1, hsq2 / 2., s0);\n    \n\t// Voxel traversal loop\n    for(int i = min(iFrame, 0); i < 250; ++i)\n    {       \n        int idx = numplanes - 1;\n        float t1 = is[numplanes - 1];\n\n        // Find the next voxel step intersection distance.\n        for(int j = 0; j < numplanes - 1; ++j)\n        {\n            if(is[j] < t1)\n            {\n                t1 = is[j];\n                idx = j;\n            }\n        }\n\n        if(fs[0] < 0. || fs[1] < 0. || fs[2] < 0. || fs[3] < 0.)\n        {\n            // The current tetrahedron has negative field values at it's corners, so\n            // test the ray against the isosurface, approximated by a plane.\n\n            // Solve the plane defined by the 4 isovalues at the corner of the tetrahedron, which\n            // can be done by inverting a linear system.\n            mat4 system = mat4(vec4(ps[0], 1), vec4(ps[1], 1), vec4(ps[2], 1), vec4(ps[3], 1));\n            vec4 plane = vec4(fs[0], fs[1], fs[2], fs[3]) * inverse(system);\n            \n            // Intersect ray with plane.\n            float t = -(dot(ro, plane.xyz) + plane.w) / dot(rd, plane.xyz);\n\n            if(t > t0 && t < t1)\n            {\n                // The ray intersects the plane, and the intersection point is inside\n                // the current (tetrahedral) voxel.\n                resultPlane = plane;\n    \t\t\tplanet = t;\n                break;\n            }\n        }\n\n        // Step to the next voxel\n        is[idx] += inv[idx];\n\n        vec3 rp = ro + rd * t1;\n\n        // Figure out which vertex of the tetrahedron needs to be reflected.\n        // This vertex will be the one furthest from the plane of reflection.\n        \n        int pidx;\n        float md = 0.;\n        for(int j = 0; j < 4; ++j)\n        {\n            float d = dot(ps[j] - rp, ns[idx]);\n            if(abs(d) > abs(md))\n            {\n                md = d;\n                pidx = j;\n            }\n        }\n        \n        // The vertex movement distance can only be one of 4 values, so snap\n        // it to the expected value, to help improve numerical precision a bit.\n        md = steps[pidx] * sign(md);\n\n        ps[pidx] -= ns[idx] * md * 2.;\n\n        // Take a single sample of the isofunction.\n        fs[pidx] = field(ps[pidx]);\n\n        // Undo the winding reversal caused by the vertex reflection.\n        swap(ps[0], ps[1]);\n        swap(fs[0], fs[1]);\n\n        t0 = t1;\n    }\n\n    vec3 planep = ro + rd * planet;\n    vec3 planen = normalize(resultPlane.xyz);\n\n    // Shading\n\n    float tetd = tetrahedronPlaneDistance(planep, ps[0], ps[1], ps[2], ps[3], resultPlane);\n    \n    vec3 col = vec3(0);\n        \n    if(planet < 50.)\n    {\n        vec3 diff = tex3D(iChannel0, planep * .5, planen) / 2.;\n        \n        float glow = pow(textureLod(iChannel1, (planep + time * 5.) / 100., 0.).r, 8.) / 2.;\n        float edge = (1. - smoothstep(.0, .01, tetd));\n        \n        \n        col += diff * 2. * pow(textureLod(iChannel1, (planep + time * 5.) / 40., 0.).r, 4.) * max(0., -planen.y);\n        \n    \tcol += diff * (dot(planen, normalize(vec3(1,-10,1))) * .4 + .5);\n        \n        vec3 r = reflect(rd, planen);\n        \n        float fr = pow(diff.b * 3., 4.) * 32. * pow(clamp(1. - dot(-rd, planen), 0., 1.), 3.);\n        \n        col = mix(col, textureLod(iChannel2, r, 4.).rgb, fr);\n    \tcol *= 1. - edge * .5;\n        col += max(1. / (tetd * 8. + .02) * vec3(1, .7, .1) / 5. * glow * 2., 0.);\n    }\n    \n    col = mix(vec3(1.), col, exp(-planet / 100.));\n\n    col = (col - .48) * 1.1 + .5;\n    col *= 1.5;\n    \n    fragColor.rgb = col;\n\n    // Gamma\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\nvoid swap(inout vec3 a, inout vec3 b)\n{\n    vec3 temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid swap(inout float a, inout float b)\n{\n    float temp = a;\n    a = b;\n    b = temp;\n}\n","name":"Common","description":"","type":"common"}]}