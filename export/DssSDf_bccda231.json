{"ver":"0.1","info":{"id":"DssSDf","date":"1669666287","viewed":180,"name":"Fork of nimitz's Ether ðŸ”Š","username":"blurryroots","description":"Explored ways on how to texture map the distance field, separate the 'flame' and 'core' more clearly and mix the 'inverse rendering' of the field with the original foreground; for an even more organic / liquid look. And of course, music ðŸ”Š","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["3d","music","fast","cheap","psychodelic","liquid","short"],"hasliked":0,"parentid":"MsjSW3","parentname":"Ether"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4l2XDw","filepath":"https://soundcloud.com/blurryroots/this-is-how-it-ends","previewfilepath":"https://soundcloud.com/blurryroots/this-is-how-it-ends","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'Biology dances in the Ether' by blurryroots\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Based on 'Ether' by nimitz 2014 (twitter: @stormoid)\n// https://www.shadertoy.com/view/MsjSW3\n\nconst float phi = (1.0 + sqrt (5.0)) / 2.0;\nconst float phi0 = phi - 1.0;\n\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n\nmat2 m(float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}\nfloat map(vec3 p, float t){\n    p.xz *= m(t * 0.4);\n    p.xy *= m(t * 0.9);\n    vec3 q = (p * 1.1) + t;\n    \n    float stretchiness = 0.5;\n    vec3 poff = vec3(sin(t * stretchiness));\n    float plen = length(p+poff);\n    float sphere_shrinkage = 0.4;\n    float plog = log(length(p) + sphere_shrinkage);\n    float flamification = 2.0;\n    float sin3 = sin(q.x + sin(q.z + sin(q.y))) * flamification;\n    return plen * plog + sin3 - 1.0;\n}\n\nfloat psin (float t) { return (1.0 + sin (t)) / 2.0; }\nfloat pcos (float t) { return (1.0 + cos (t)) / 2.0; }\nvec3 desatA (vec3 c) {\n    return vec3 (0.4 * c.r + 0.6 * c.g + 0.4 * c.b);\n}\nvec3 desatB (vec3 c) {\n    return vec3 (1.0 * c.r + 0.2 * c.g + 0.8 * c.b);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}  \n\n\t// vec2 p = fragCoord.xy/iResolution.y; // - vec2(1.0, 0.6);\n    vec2 p = fragCoord.xy / iResolution.xy;\n    p = p * 2.0 - vec2 (1.0);\n    \n    vec3 color_core = vec3(0.2, 0.5, 0.2);\n    vec3 color_flame = vec3(1.0, 0.2, 0.8);\n    \n    vec3 cl = vec3(0.0, 0.0, 0.0);\n    float d = mix (0.5, 4.5, psin (iTime));\n    float substance = mix (0.3, 1.0, pcos (iTime));\n    vec2 border_steepness = vec2 (-10.1, 0.3);\n    float flame_solidity = mix (0.07, 0.13, psin (iTime/phi + phi));\n    int iterations = 5;\n    for(int i = 0; i <= iterations; ++i) {\n        vec3 viewdir = vec3(0.0, 0.0, 1.0) * (2.0 + 4.0 * pcos (iTime));\n        float focal = mix (-0.5, -1.0, psin (iTime));\n        vec3 viewfoc = normalize(vec3(p, focal));\n\t\tvec3 pp = viewdir + viewfoc * d;\n        \n        float rz = map(pp, iTime);\n\t\td += min(rz, 1.);\n        \n\t\tfloat f =  clamp((rz - map(pp + flame_solidity, iTime)) * 0.5, \n            border_steepness.x, \n            border_steepness.y\n        );        \n        vec3 flame = 5.0 * f * color_flame;\n        vec3 l = color_core + flame;\n        float thickness = smoothstep(2.5, 0.0, rz) * substance;\n        \n        // high frequency blending? why not \n        float thickness_blend = mix (-2.0, 2.0, pcos (iTime*1000000.0));\n        vec3 cutout = cl\n            + mix (thickness * thickness_blend, \n                   thickness, \n                   texture (iChannel1, vec2 (0.5, 0.00)).x\n              )\n            ;\n        float dispersion =  phi * texture (iChannel1, vec2 (0.1, 0.00)).x;\n        cl = mix (l, l * cutout, dispersion);//pcos (iTime));\n\t}\n    \n    vec4 tx = texture (iChannel0, p * cl.xy * 2.0);\n    fragColor = vec4( (cl) * tx.rgb, 1.0);\n    // fragColor = tx;\n}","name":"Image","description":"","type":"image"}]}