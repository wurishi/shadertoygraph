{"ver":"0.1","info":{"id":"wsSczw","date":"1586371914","viewed":1786,"name":"Odd-even horizontal pixel sort","username":"ciphered","description":"This shader is an illustration for an article I wrote about Pixel sorting using a vector field:\nhttps://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/","likes":24,"published":1,"flags":32,"usePreview":1,"tags":["pixel","sort","sorting","odd","even"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @author ciphrd <https://instagram.com/ciphrd>\n//\n// This shader is used as an illustration for an article I wrote about \n// Pixel sorting using a vector field:\n// https://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/\n//\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n// \n// This shader is used as an example for an article I wrote about \"Pixel sorting using a well-crafted vector field\".\n// Everything is explained in the article if you're looking for explanations.\n//\n// https://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/\n//\n\n#define THRESHOLD 0.2\n\n\n\n// grayscale average of the colors\nfloat gscale (vec3 c) { return (c.r+c.g+c.b)/3.; }\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// uvs\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tif (iFrame < 10) {\n\t\tfragColor = texture(iChannel0, uv);\n\t\treturn;\n\t}\n\t\n\t\n\t// the frame number parity, -1 is odd 1 is even\n\tfloat fParity = mod(float(iFrame), 2.) * 2. - 1.;\n    \n    // we differentiate every 1/2 pixel on the horizontal axis, will be -1 or 1\n    float vp = mod(floor(uv.x * iResolution.x), 2.0) * 2. - 1.;\n    \n    \n\tvec2 dir = vec2(1, 0);\n    dir*= fParity * vp;\n\tdir/= iResolution.xy;\n\n\t// we sort\n\tvec4 curr = texture(iChannel1, uv);\n\tvec4 comp = texture(iChannel1, uv + dir);\n\t\n\tfloat gCurr = gscale(curr.rgb);\n\tfloat gComp = gscale(comp.rgb);\n\t\n\t\n\t// we prevent the sort from happening on the borders\n\tif (uv.x + dir.x < 0.0 || uv.x + dir.x > 1.0) {\n\t\tfragColor = curr;\n\t\treturn;\n\t}\n\t\n\t// the direction of the displacement defines the order of the comparaison \n\tif (dir.x < 0.0) {\n\t\tif (gCurr > THRESHOLD && gComp > gCurr) {\n\t\t\tfragColor = comp;\n\t\t} else {\n\t\t\tfragColor = curr;\n\t\t}\n\t} \n\telse {\n\t\tif (gComp > THRESHOLD && gCurr >= gComp) {\n\t\t\tfragColor = comp;\n\t\t} else {\n\t\t\tfragColor = curr;\n\t\t}\n\t}\n}\n","name":"Buffer A","description":"","type":"buffer"}]}