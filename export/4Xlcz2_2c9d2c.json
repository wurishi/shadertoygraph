{"ver":"0.1","info":{"id":"4Xlcz2","date":"1726452025","viewed":29,"name":"asdfasdflskf","username":"BearKirb","description":"asdfasdfasdf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["asdfasdfasdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 circleData[1]=vec4[](vec4(400.0,300.0,180.0,20.0));\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat smin( float a, float b, float k )\n{\n    k *= 2.0;\n    float x = b-a;\n    return 0.5*( a+b-sqrt(x*x+k*k) );\n}\nfloat scene(vec2 p){\nvec2 im=iMouse.xy;\nim.y=iResolution.y-im.y;\nfloat di=sdCircle(p-im,120.0);\n\nfor(int i=0;i<circleData.length();i++){\nvec4 dat=circleData[i];\ndi=smin(di,sdCircle(p-dat.xy,dat.z),dat.w);\n}\nreturn di;\n}\nvec2 hash2(vec2 p ) {\n   return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);   \n}\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(43.232, 75.876)))*4526.3257);   \n}\n\n//Based off of iq's described here: https://iquilezles.org/articles/voronoilines\nfloat voronoi(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float md = 5.0;\n    vec2 m = vec2(0.0);\n    for (int i = -1;i<=1;i++) {\n        for (int j = -1;j<=1;j++) {\n            vec2 g = vec2(i, j);\n            vec2 o = hash2(n+g);\n            o = 0.5+0.5*sin(iTime+5.038*o);\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            if (d<md) {\n              md = d;\n              m = n+g+o;\n            }\n        }\n    }\n    return md;\n}\n\nfloat ov(vec2 p) {\n    float v = 0.0;\n    float a = 0.4;\n    for (int i = 0;i<3;i++) {\n        v+= voronoi(p)*a;\n        p*=2.0;\n        a*=0.5;\n    }\n    return v;\n}\nfloat fbm(vec2 p){\nfloat ou=0.0;\nfloat mult=1.0;\nfor(int i=0;i<3;i++){\nou+=ov(p*mult)/mult;\nmult*=2.0;\n}\nreturn ou;\n}\nvec3 stone(vec2 uv,float d){\nvec3 col=vec3(0.0);\n float scale = .4;\n   \n    vec2 coord = scale*(uv);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n \n    vec3 col_prev;\n    for(int i = 0; i < 7; i++){\n        col_prev = col;\n        coord.y += (2.0+result)/2.0;\n        coord += coord.yy/4.0;\n        coord = coord.yx/(2.0);\n        result = ((result + float(val = ((int(coord.x) | int(coord.y)) % (3+val))))/(2.0));\n        col.x = (result+col.z)/2.0;\n        col = (fract((col.yzx))+col_prev)/2.0;\n    }\n    // Output.\n    col = vec3(mix(col*vec3(0.6,0.7,1.0),vec3(length(col)),0.5)/(8.0+clamp(d/1.0+5.0,-5.0,0.0)))+0.1;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy;\nuv.y=iResolution.y-uv.y;\n    // Time varying pixel color\n    vec3 col=texture(iChannel0,uv/iResolution.xy).rgb/2.0;\n    float sd=scene(uv);\n    if(uv.y>400.0){\n    \t\n    vec3 a = vec3(0.05, 0.25, 0.3);\n    vec3 b = vec3(0.85, 0.9, 1.0);\n    float fb=fbm(uv/125.0);\n    vec2 off=vec2(cos(fb*3.14),sin(fb*3.14));\n\tcol = mix(texture(iChannel0,uv/iResolution.xy+off/40.0).rgb/2.0,mix(a, b, smoothstep(0.0, 0.5, fb/4.0+clamp(clamp(-(uv.y-425.0)/100.0,0.0,1.0)+(2.0/(sd+8.0)),0.0,1.0))),0.6);\n    }\n    if(sd<0.0){\n    vec3 colc=stone(uv,sd);\n    float c=10.0/(scene(uv));\n    vec3 colx=stone(uv+vec2(2.0,0.0),sd);\n    float nx=10.0/(scene(uv+vec2(1.0,0.0)));\n    vec3 coly=stone(uv+vec2(0.0,2.0),sd);\n    float ny=10.0/(scene(uv+vec2(0.0,1.0)));\n    vec3 norm=vec3(colc.x-colx.x,colc.x-coly.x,0.75);\n    vec3 norm2=vec3(-(c-nx),-(c-ny),0.005);\n    vec3 scree=vec3(uv/iResolution.xy-0.5,1.0);\n    float li=dot(normalize(scree),normalize(norm))*(dot(normalize(scree),normalize(norm2))*0.5+0.5);\n    float light=dot(normalize(scree),normalize(norm));\n    light*=light;\n    light*=light;\n    light*=light;\n    light*=light;\n    light*=light;\n    light*=light;\n    light*=light;\n    light*=light;\n    \n    col=colc*li+light/2.0;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}