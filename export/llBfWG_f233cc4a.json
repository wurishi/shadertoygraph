{"ver":"0.1","info":{"id":"llBfWG","date":"1517013442","viewed":1012,"name":"Another terrible pathtracer","username":"slerpy","description":"Added DoF (Depth of Field) and different light temperatures.\n\nSpace to reset.","likes":40,"published":1,"flags":48,"usePreview":0,"tags":["procedural","3d","basic","dof","shadows","reflections","pathtracer","tracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    // This part feels like cheating\n    col += texelFetch(iChannel0, ivec2(iResolution.xy-fragCoord.xy), 0).bgra;\n    fragCoord.y = iResolution.y - fragCoord.y;\n    col += texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    col += texelFetch(iChannel0, ivec2(iResolution.xy-fragCoord.xy), 0).bgra;\n    \n    //col = pow(1.0 - col, vec4(1.5));\n    //col = pow(1.0 - col, vec4(1.2));\n    \n    fragColor = pow(max(2.0 * col / col.w, 0.), vec4(1) / 2.2);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TAU 6.28318530718\n#define PI (TAU/2.0)\n\n#define AA 1.\n#define DOF 24.\n\n#define FAR 70.\n#define ITER 90\n#define NORK 5e-4\n\n#define RITER 8\n#define RRFB .001\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hashHs( vec3 n, uint seed )\n{\n    float a=(float((seed*0x73493U)&0xfffffU)/float(0x100000))*2.-1.;\n    float b=6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n    float c=sqrt(1.-a*a);\n    vec3 r=vec3(c*cos(b),a,c*sin(b));\n    return dot(r,n)>0.?r:-r;\n}\n\nmat3 rx(float a){ float s=sin(a), c=cos(a); return mat3(1,0,0,0,c,s,0,-s,c); }\nmat3 ry(float a){ float s=sin(a), c=cos(a); return mat3(c,0,s,0,1,0,-s,0,c); }\nmat3 rz(float a){ float s=sin(a), c=cos(a); return mat3(c,s,0,-s,c,0,0,0,1); }\n\nfloat box(vec3 p){ p=abs(p); return max(max(p.x, p.y), p.z); }\nfloat box(vec2 p){ p=abs(p); return max(p.x, p.y); }\n\nvec2 amod(vec2 p, float m)\n{\n    float a=mod(atan(p.x, p.y), m) - m/2.;\n    return vec2(cos(a),sin(a)) * length(p);\n}\n\nvoid dmin(inout vec3 d, in float x, in float y, in float z)\n{\n    if(x < d.x) d = vec3(x,y,z);\n}\n\nvec3 map(vec3 p)\n{\n    vec3 d = vec2(0, 1e+31).yxx;\n    \n    dmin(d, .75-abs(p.y), 1., 0.);\n    dmin(d, length(p)-.5, 0., 0.);\n    \n    if(length(p.xz) > 10.)return d;\n    \n    vec3 q = abs(p-round(p-.5)-.5);\n    float g = min(min(box(q.xy), box(q.xz)),box(q.yz))-.05;\n    float c = min(.6-abs(p.x+p.z), .45-abs(p.y));\n    dmin(d, max(g, c), .1, 0.);\n    \n    dmin(d, box(p.xz-2.)-.5, 8., -.5);\n    dmin(d, box(p.xz+2.)-.5, 8., +.5);\n    \n\treturn d;\n}\n\nvec3 normal(vec3 p, float k)\n{\n    float m = map(p).x;\n\tvec2 e = vec2(0,k);\n\treturn normalize(m-vec3(\n\t\tmap(p - e.yxx).x,\n\t\tmap(p - e.xyx).x,\n\t\tmap(p - e.xxy).x\n\t));\n}\n\nvec3 tracer(vec3 ro, vec3 rd)\n{    \n    vec3 m;\n    float t=RRFB;\n    for(int i=0; i < ITER; i++)\n    {\n        m = map(ro + rd*t);\n        if(t > FAR)break;\n        t += m.x; \n    }\n    return vec3(t, m.yz);\n}\n\nvoid camera(out vec3 ro, out vec3 rd, in vec2 p)\n{\n    p.xy += AA * (hash23(vec3(p.xy, iFrame)) - .5);\n\tvec2 uv = (2.*p.xy-iResolution.xy)/iResolution.x;\n    vec2 blur = DOF * (hash23(vec3(iFrame, p.xy))-.5) / iResolution.x;\n    mat3 rm = ry(TAU/8. + blur.x) * rx(blur.y);\n\tro = rm * vec2(0, -3).xxy;\n    rd = rm * normalize(vec3(uv, 1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    if(iFrame > 0 && texelFetch(iChannel1, ivec2(0x20, 0), 0).r < .5)\n\t\tfragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    uvec2 temp = uvec2(fragCoord + 12345.);\n    uint seed = temp.x * temp.y;\n    \n    float absorb = 1.0;\n    vec3 emit = vec3(0), ro, rd, t, sp, sn;\n    camera(ro, rd, fragCoord);\n    \n    for(int i=0; i<RITER; i++)\n    {\n        t = tracer(ro, rd);\n        if(t.x > FAR)break;\n        \n\t\tsp = ro + rd*t.x;\n\t\tsn = normal(sp,NORK);\n        \n        if(t.y > 1.)emit += absorb * 0.5 * t.y * vec3(1.+t.z, 1, 1.-t.z);\n        absorb /= PI;\n        \n        seed ^= uint(iFrame) / uint(i+1);\n        rd = mix(reflect(rd, sn), hashHs(sn, seed), t.y);\n        ro = sp;\n    }\n    \n    //emit = 10. * emit / (box(emit)+1.);\n    //emit = pow(emit, vec3(.4545));\n    \n    fragColor += vec4(emit, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}