{"ver":"0.1","info":{"id":"cttfD4","date":"1701268761","viewed":69,"name":"Cubes and the mouse halo","username":"Miolith","description":"Cubes that rotate slowly","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mouse","cube","halo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float draw_line(vec2 uv, vec2 startPoint, vec2 endPoint)\n{\n    // Calculate the direction vector of the line\n    vec2 line_direction = normalize(endPoint - startPoint);\n    vec2 start_vec = uv - startPoint;\n    vec2 end_vec = uv - endPoint;\n\n    // Calculate the alignment between start_to_uv and start_to_end vectors\n    float distanceToLine = abs(cross(vec3(line_direction, 0.0), vec3(start_vec, 0.0)).z);\n    \n    float behind_start = dot(line_direction, start_vec);\n    float behind_end = dot(-line_direction, end_vec);\n    \n    if (behind_start < 0.0 || behind_end < 0.0)\n        return 0.0;\n    \n    float lineThickness = 0.005;\n\n    return smoothstep(lineThickness, 0.0, distanceToLine);\n}\n\nfloat draw3D_line(vec2 uv, vec3 point1, vec3 point2)\n{\n    return draw_line(uv, point1.xy / point1.z, point2.xy / point2.z);\n}\n\nfloat render_cube(vec2 uv, vec3 position, float side_length, vec3 orient)\n{\n    vec3 up_left_in = position;\n    float in_edge = 0.0;\n    \n    mat3 rot_z = mat3(\n        cos(orient.z), -sin(orient.z), 0.0,\n        sin(orient.z), cos(orient.z),  0.0,\n        0.0,           0.0,            1.0\n    );\n    \n    mat3 rot_y = mat3(\n        cos(orient.y),  0.0, sin(orient.y),\n        0.0,            1.0, 0.0,\n        -sin(orient.y), 0.0, cos(orient.y)\n    );\n    \n    mat3 rot_x = mat3(\n        1.0, 0.0,           0.0,\n        0.0, cos(orient.x), -sin(orient.x),\n        0.0, sin(orient.x), cos(orient.x)\n    );\n    \n    mat3 rot = rot_z * rot_y * rot_x;\n    \n    vec3 dist = position + vec3(side_length/2.0, -side_length/2.0, side_length/2.0);\n    \n    // face UP\n        vec3 a = up_left_in;\n        vec3 b = a + vec3(0.0, 0.0, side_length);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n        a = b;\n        b = a + vec3(side_length, 0.0, 0.0);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n        a = b;\n        b = a + vec3(0.0, 0.0, -side_length);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n        a = b;\n        b = a + vec3(-side_length, 0.0, 0.0);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n    // face DOWN\n        a = up_left_in + vec3(0.0, -side_length, 0.0);\n        b = a + vec3(0.0, 0.0, side_length);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n        a = b;\n        b = a + vec3(side_length, 0.0, 0.0);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n        a = b;\n        b = a + vec3(0.0, 0.0, -side_length);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n        a = b;\n        b = a + vec3(-side_length, 0.0, 0.0);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n    // face LEFT\n        a = up_left_in;\n        b = a + vec3(0.0, -side_length, 0.0);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n        a = up_left_in + vec3(0.0, 0.0, side_length);\n        b = a + vec3(0.0, -side_length, 0.0);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n    // face RIGHT\n        a = up_left_in + vec3(side_length, 0.0, 0.0);\n        b = a + vec3(0.0, -side_length, 0.0);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n        \n        a = up_left_in + vec3(side_length, 0.0, side_length);\n        b = a + vec3(0.0, -side_length, 0.0);\n        in_edge += draw3D_line(uv, rot * (a - dist) + dist, rot * (b - dist) + dist);\n    \n    return in_edge;\n}\n\nfloat mouse_halo(vec2 uv, vec2 m)\n{\n    return 0.1/distance(m, vec2(uv.x, uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n        m = vec2(0.0, 0.0);\n\n    vec3 col = vec3(0.0);\n    \n    vec3 cube_color = vec3(1.0);\n    \n    col = mix(col, cube_color, render_cube(uv, vec3(1.0,1.0,2.0), 0.5, vec3(.0, .05, -.05) *iTime));\n    col = mix(col, cube_color, render_cube(uv, vec3(-5.0,1.0,3.0), 0.8, vec3(-.01, .05, .0)*iTime));\n    col = mix(col, cube_color, render_cube(uv, vec3(-4.0,1.0,5.0), 0.8, vec3(.05, .05, .05)*iTime));\n    col = mix(col, cube_color, render_cube(uv, vec3(-2.0,-3.0,10.0), 0.8, vec3(.1, .1, .0)*iTime));\n    col = mix(col, cube_color, render_cube(uv, vec3(2.0,-3.0,5.0), 0.8, vec3(.0, .05, .0)*iTime));\n    col = mix(col, cube_color, render_cube(uv, vec3(5.0,0.0,5.0), 0.8, vec3(.0, .05, .0)*iTime));\n    col = mix(col, cube_color, render_cube(uv, vec3(-5.0,-5.0,8.0), 0.8, vec3(.05, .05, .0)*iTime));\n    col = mix(col, cube_color, render_cube(uv, vec3(0.0,4.0,4.0), 0.8, vec3(.0, .05, .0)*iTime));\n    col = mix(col, cube_color, render_cube(uv, vec3(5.0,4.0,4.0), 0.8, vec3(.05, .0, .0)*iTime));\n    \n    col = mix(col, cube_color, mouse_halo(uv, m));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}