{"ver":"0.1","info":{"id":"4tVcWR","date":"1535757335","viewed":2036,"name":"Ohanami Stipple","username":"fizzer","description":"This is a port of the code from the \"Ohanami\" 4kb demo: https://www.pouet.net/prod.php?which=71888\nThe code has been left in the minified state, mostly because I don't have the un-minified version of the code anymore. :)\nUse mouse Y to change camera tilt.","likes":116,"published":1,"flags":32,"usePreview":0,"tags":["tree","paint","pointilism","blossom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float time;\nfloat seed;\nfloat rand() { return fract(sin(seed++)*43758.545); }\n\nvec4 samp(vec2 p)\n{\n    p.y*=1280./720.;\n    return texture(iChannel0,p/2.+.5)*1.05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    time=iTime;\n    vec2 t=(uv*2.-1.)*.55;\n    t.x*=iResolution.x/iResolution.y;\n\n    fragColor = texture(iChannel0, uv);\n\n    // Sample the input image to pick locations to splat circular shapes from.\n    vec3 c=vec3(.8,.8,1)/6.;\n    vec2 p=t;\n    for(int n=0;n<2;++n)\n    {\n        float maxr=mix(1./22.,1./4.,1.-float(n))*.4;\n\n        ivec2 uo=ivec2(floor(p/maxr));\n        for(int i=-1;i<2;++i)\n            for(int j0=-1;j0<2;++j0)\n            {\n                vec2 u=vec2(uo)+vec2(i,((uo.x+i)&1)==1?-j0:j0);\n                seed=u.x*881.+u.y*927.+float(n)*1801.;\n                for(int k=0;k<11;++k)\n                {\n                    vec2 o=(u+vec2(rand(),rand()))*maxr;\n                    vec2 p2=p-o;\n                    vec3 cc=samp(o).rgb;\n                    float a=dot(cc,vec3(1./3.));\n                    float r=mix(.25,.99,pow(rand(),4.))*maxr;\n                    float ang=rand()*acos(-1.)*2.; // This angle is used for the 'stroke lines' in the circles.\n                    float d=length(p2);\n                    p2*=mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n                    cc=mix(cc,vec3(a)*1.5,pow(rand(),16.));\n                    if(rand()>-floor(time*2.)/2./10.)\n                    {\n                        // Shade in the circle, and an outline of the circle.\n                        c=mix(c,cc,mix(.1,.4,rand())*3.*pow(a,.8)*mix(.8,1.,cos(p2.x*1200.)*.5+.5)*clamp((r-d)/mix(.001,.004,rand()),0.,1.));\n                        c=mix(c,cc/2.,mix(.14,.3,pow(rand(),16.))/4.*clamp(1.-abs(r-d)/.002,0.,1.));\n                    }\n                }\n            }\n\n    }\n\n    // Apply some darkening based on edge detection, for something like a pencil sketch.\n    vec2 e=vec2(1e-3,0.);\n    vec2 p2=p+(valnoise(p*18.)-.5)*.01;\n    float c0=dot(vec3(1./3.),samp(p2).rgb);\n    float c1=dot(vec3(1./3.),samp(p2+e.xy).rgb);\n    float c2=dot(vec3(1./3.),samp(p2+e.yx*1.8).rgb);\n\n    c*=vec3(mix(.1,1.,1.-clamp(max(abs(c2-c0),abs(c1-c0))*4.,0.,.13)));\n\n    // Final output.\n    c=(c-.5)*1.1+.5;\n    fragColor.rgb=sqrt(c*mix(.9,1.,valnoise(t.xy*400.)))*1.28;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float time;\n\nvec2 t;\n\nfloat ti;\nfloat col=1e3,col2=1e3,col3=1e3;\n\n// Signed distance field function.\nfloat f(vec3 p)\n{\n    col3=p.y-(.5+.5*cos(p.x*2.))*.1;\n\n    float d=max(col3,length(p.xz)-5.5);\n    float s=1.,ss=1.6;\n    \n    // Tangent vectors for the branch local coordinate system.\n    vec3 w=normalize(vec3(-.8+cos(iTime/30.)*.01,1.2,-1.));\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n\n    int j=int(min(floor(ti-1.),7.));\n\n    float scale=min(.3+ti/6.,1.);\n    p/=scale;\n\n    // Evaluate the tree branches, which are just space-folded cylinders.\n    for(int i=0;\n        d=min(d,scale*max(p.y-1.,max(-p.y,length(p.xz)-.1/(p.y+.7)))/s),\n        p.xz=abs(p.xz),\n        p.y-=1.,\n        i<j;\n        p*=mat3(u,normalize(cross(u,w)),w), // Rotate in to the local space of a branch.\n        p*=ss,\n        s*=ss,\n        ++i);\n\n    return min(d,col=max(0.,length(p)-.25)/s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    t=(uv*2.-1.)*.5;\n    t.x*=iResolution.x/iResolution.y;\n\n    time=140.;\n\n    // Timing value used in the original demo.\n    ti=max(0.,time)/3.;\n    ti=noise(floor(gl_FragCoord.xy))+(floor(ti)+clamp(fract(ti)*2.,0.,1.));\n    ti=floor(ti);\n\n    float zoom=1.5;\n    vec2 filmoffset=vec2(0);\n\n    // Set up camera and primary ray.\n    vec3 ro=vec3(-2.5+cos(iTime/4.),.1+cos(ti*17.)*.1+iMouse.y/iResolution.y*2.,3.5);\n    vec3 rd=normalize(vec3(t.xy+filmoffset,zoom));\n    if(ti==10.)ro.y+=2.;\n    vec3 camtarget=vec3(0,1.3,0);\n\n    vec3 w=normalize(camtarget-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=normalize(cross(w,-u));\n\n    rd=mat3(u,v,w)*rd;\n\n    fragColor.rgb=vec3(.8,.8,1.)/6.;\n    float s=20.;\n\n    // Signed distance field raymarch.\n    float t=0.,d=0.;\n    for(int i=0;i<100;++i)\n    {\n        d=f(ro+rd*t);\n        if(d<1e-3)break;\n        t+=d;\n        if(t>10.)return;\n    }\n\n    // Colourise ground, branch/trunk, or cherry blossom.\n    {\n        vec3 rp=ro+rd*t;\n        fragColor.rgb=vec3(.75,.6,.4)/1.5;\n        if(col<2e-3)fragColor.rgb=vec3(1.,.7,.8);\n        if(col3<2e-2&&(ti<17.||ti>22.))fragColor.rgb=vec3(.5,1.,.6)/3.;\n    }\n\n    // Lighting.\n    vec3 ld=normalize(vec3(1.,3.+cos(ti)/2.,1.+sin(ti*3.)/2.));\n    float e=1e-2;\n    float d2=f(ro+rd*t+ld*e);\n    float l=max(0.,(d2-d)/e);\n\n    float d3=f(ro+rd*t+vec3(0,1,0)*e);\n    float l2=max(0.,.5+.5*(d3-d)/e);\n\n    {\n        vec3 rp=ro+rd*t;\n        if(ti>12.&&ti<22.)\n            if(col2<1e-2||d3+d2/7.>0.0017&&pow(valnoise(rp.xz*8.),2.)>abs(ti-18.)/5.)fragColor.rgb=vec3(.65);\n    }\n\n    {\n        vec3 rp=ro+rd*t;\n        if(ti>12.&&ti<17.)\n            if(col2<1e-2||d3+d2/7.>0.0017&&valnoise(rp.xz*8.)<(ti-12.)/3.)fragColor.rgb=vec3(.65);\n    }\n\n    vec3 rp=ro+rd*(t-1e-3);\n\n    // Directional shadow.\n    t=0.1;\n    float sh=1.;\n    for(int i=0;i<30;++i)\n    {\n        d=f(rp+ld*t)+.01;\n        sh=min(sh,d*50.+0.3);\n        if(d<1e-4)break;\n        t+=d;\n    }\n\n    fragColor.rgb*=1.*sh*(.2+.8*l)*vec3(1.,1.,.9)*.7+l2*vec3(.85,.85,1.)*.4;\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat valnoise(vec2 p)\n{\n    vec2 c=floor(p);\n    vec2 f=smoothstep(0.,1.,fract(p));\n    return mix (mix(noise(c+vec2(0,0)), noise(c+vec2(1,0)), f.x),\n                mix(noise(c+vec2(0,1)), noise(c+vec2(1,1)), f.x), f.y);\n}","name":"Common","description":"","type":"common"}]}