{"ver":"0.1","info":{"id":"MllfW2","date":"1519608630","viewed":219,"name":"snow mountain2","username":"ruolan","description":"raymarch, noise\nlearned from tutorial:http://blog.csdn.net/candycat1992/article/details/50603529","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE 0\n#define TERRAIN 1\n#define SEALEVEL 3\n#define NO_INTERSECT 2\n#define HELIX 5\n\n#define LOD_NORM 10\n#define LOD_RAY 4\n\n#define SEALEVEL_HEIGHT 4.0\n\n#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n#define WIND vec2(0.2, 0.1)\n\nvec3 c_l;\n\nvec3 sundir = normalize(vec3(1.2,0.45,0.5));\n\nvec3 sun(vec3 dir) //makes that bright spot on the sky\n{\n\tfloat sun = dot(dir,c_l);\n\tsun+=1.0; sun*=0.5; sun= pow(sun,127.0);\n\treturn vec3(sun);\n}\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, TERRAIN, or NO_INTERSECT\n};\n\nfloat hash21(vec2 p) {\n    float h = dot(vec2(p),vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123) * 2.0 - 1.0;\n}\n\nfloat hash31(vec3 p) {\n    p = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat valueNoise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n    vec2 u = pf*pf*pf*(6.0*pf*pf - 15.0*pf + 10.0);\n\n    float va = hash21(pi + vec2(0.0, 0.0));\n    float vb = hash21(pi + vec2(1.0, 0.0));\n    float vc = hash21(pi + vec2(0.0, 1.0));\n    float vd = hash21(pi + vec2(1.0, 1.0));\n\n    return mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y);\n}\n\n//iq hash\nfloat hash( float n )\n{\n    return fract(sin(n)*54321.98761234);  // value has no meaning that I could find\n}\n\n//iq  noise function\nfloat noise(vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    f= (10.0+(-15.0+6.0*f)*f)*f*f*f; // smooth\n    \n    float n = p.x + p.y*57.0;\n    \n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    \n    return res;\n}\n\nfloat valueNoise(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n    vec3 u = pf*pf*pf*(6.0*pf*pf - 15.0*pf + 10.0);\n\n    float va = hash31(pi + vec3(0.0, 0.0, 0.0));\n    float vb = hash31(pi + vec3(1.0, 0.0, 0.0));\n    float vc = hash31(pi + vec3(0.0, 1.0, 0.0));\n    float vd = hash31(pi + vec3(1.0, 1.0, 0.0));\n    float ve = hash31(pi + vec3(0.0, 0.0, 1.0));\n    float vf = hash31(pi + vec3(1.0, 0.0, 1.0));\n    float vg = hash31(pi + vec3(0.0, 1.0, 1.0));\n    float vh = hash31(pi + vec3(1.0, 1.0, 1.0));\n\n    return mix(mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y),\n               mix(mix(ve, vf, u.x), mix(vg, vh, u.x), u.y), u.z);\n}\n\nfloat fbmTerrain(vec2 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    sum = pow(sum, 2.0);\n    return sum * 45.0;\n}\n\nfloat fbmSealevel(vec3 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    //sum = pow(sum, 2.0);\n    return sin(sum * 10.);\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 2.0, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat mapTerrain(vec3 p, int level) {\n    return p.y - (fbmTerrain(p.xz, level) * 1.0 - 10. / (pow(p.x*p.x + p.z*p.z, .1) + 1.));\n}\n\nfloat mapSealevel(vec3 p, int level) {\n    return p.y - SEALEVEL_HEIGHT - fbmSealevel(vec3(p.xz * .1, iTime * .5) * 5., level);\n}\n\nconst float theta = 3.14 * 2. / 16.;\nconst mat2 rotate2D = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n\nfloat mapHelix(vec3 p) {\n    p.y = mod(p.y, 22.2);\n    vec3 offset = vec3(7., 3., 0.);\n    float dh = 1.2;\n    vec3 dimen = vec3(2.5, .1, 1.);\n    float res = 100000.0;\n    for (int i=0; i<0; i++) {\n        res = min(res, udBox(p - offset, dimen)); p.xz = rotate2D * p.xz; p.y -= dh;\n    }\n\treturn res;\n}\n\nPrimitiveDist map(vec3 p) {\n    float terrainDist = mapTerrain(p, LOD_RAY);\n    float sealevelDist = mapSealevel(p, LOD_RAY - 1);\n    float helixDist = mapHelix(p);\n    PrimitiveDist res = PrimitiveDist(terrainDist, TERRAIN);\n\n    //if (sealevelDist < res.dist) res = PrimitiveDist(sealevelDist, SEALEVEL);\n    if (helixDist < res.dist) res = PrimitiveDist(helixDist, HELIX);\n    \n    return res;\n}\n\nPrimitiveDist mapUnderSea(vec3 p) {\n    float terrainDist = mapTerrain(p, LOD_RAY);\n    float helixDist = mapHelix(p);\n    \n    PrimitiveDist res = PrimitiveDist(terrainDist, TERRAIN);\n\n    if (helixDist < res.dist) res = PrimitiveDist(helixDist, HELIX);\n\n    return res;\n}\n\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p, int which) {\n    vec3 norm = vec3(0.);\n    if (which == TERRAIN) {\n        norm.x = mapTerrain(p + e.xyy, LOD_NORM) - mapTerrain(p - e.xyy, LOD_NORM);\n        norm.y = mapTerrain(p + e.yxy, LOD_NORM) - mapTerrain(p - e.yxy, LOD_NORM);\n        norm.z = mapTerrain(p + e.yyx, LOD_NORM) - mapTerrain(p - e.yyx, LOD_NORM);\n    } else if (which == SEALEVEL){\n    \tnorm.x = mapSealevel(p + e.xyy, LOD_NORM) - mapSealevel(p - e.xyy, LOD_NORM);\n        norm.y = mapSealevel(p + e.yxy, LOD_NORM) - mapSealevel(p - e.yxy, LOD_NORM);\n        norm.z = mapSealevel(p + e.yyx, LOD_NORM) - mapSealevel(p - e.yyx, LOD_NORM);\n    } else {\n        norm.x = map(p + e.xyy).dist - map(p - e.xyy).dist;\n        norm.y = map(p + e.yxy).dist - map(p - e.yxy).dist;\n        norm.z = map(p + e.yyx).dist - map(p - e.yyx).dist;\n    }\n\n    return normalize(norm);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 35.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n\n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        darkness = min(darkness, k * h / marchDist);\n        marchDist += h * 0.7;\n    }\n\n    return darkness;\n}\n\nPrimitiveDist raymarchUnderSea(vec3 ro, vec3 rd, float maxDist, float marchSpeed) {\n    float marchDist = 0.001;\n    float boundingDist = maxDist;\n    float threshold = 0.1;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 100; i++) {\n        // Fill in loop body\n        vec3 pos = ro + rd * marchDist;\n        PrimitiveDist near = mapUnderSea(pos);\n        if (near.dist < threshold)\n            return PrimitiveDist(marchDist, near.primitive);\n        marchDist += near.dist * marchSpeed;\n        if (marchDist > boundingDist) break;\n    }\n\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd, float maxDist, float marchSpeed) {\n    float marchDist = 0.001;\n    float boundingDist = maxDist;\n    float threshold = 0.1;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 500; i++) {\n        // Fill in loop body\n        vec3 pos = ro + rd * marchDist;\n        PrimitiveDist near = map(pos);\n        if (near.dist < threshold)\n            return PrimitiveDist(marchDist, near.primitive);\n        marchDist += near.dist * marchSpeed;\n        if (marchDist > boundingDist) break;\n    }\n\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 generateTerrainColor(float t, vec3 pos, vec3 norm, vec3 lig) {\n    vec3 col = vec3(0.0);\n\n    vec3 lightGreen = vec3(0.564, 0.833, 0.564);\n    vec3 lawnGreen = vec3(0.498, 0.99, 0);\n    vec3 springGreen = vec3(0.0, 1.0, 0.5);\n    vec3 greenYellow = vec3(.678, 0.99, .184);\n    vec3 olive = vec3(0.5, 0.5, 0.0);\n    float z = pos.y;\n    z += noise( pos.xz * 47.0 )* 0.2;\n\n    //vec3 grass1 = vec3(.125, .365, .0);\n    //vec3 grass2 = vec3(.16, .274, .141);\n    vec3 grass3 = vec3(.0, .2, .0);\n    vec3 grass4 = vec3(.45, .6, .0);\n    \n    vec3 grass2 = vec3 (.19, .335, .14);\n    vec3 grass1 = vec3 (.478, .451, .14);\n    vec3 snow1 = vec3 ( .78,.78,.78);\n    vec3 snow2 = vec3 ( .9,.9,.9);\n\n    vec3 earth      = vec3(.824, .706, .549);\n    vec3 calcaire   = vec3(.624, .412, .118);\n    vec3 rocks      = vec3(.412, .388, .422);\n    vec3 beach      = vec3( 1.0, .894, .710);\n\n    float posNoise = valueNoise(pos.xz) + 1.0 * 0.5;\n      \n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n\n    // base color\n    col = mix (        beach,    earth, smoothstep(0.0 , 0.08 , pos.y) );\n    col = mix ( col, calcaire, smoothstep(0.08, 0.3 , pos.y) );\n    col = mix ( col,    rocks, smoothstep(0.3, 10.0  , pos.y) );\n\n    if (norm.y > 0.5) {\n        col = mix(snow1, snow2, smoothstep(0.0, 10.0, posNoise * 10.0));\n    }\n\n    \n    if (pos.y <=0.) {\n        //col = vec3(0.0, 0.0, 0.8);\n    }\n    \n    float fo = 1.0 - exp( -t*0.001 );\n   \n    vec3 fco = vec3(0.4,0.65,1.0);// + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n    col = mix( col, fco, fo );\n    \n    return ambient + diffuse * col;\n}\n\nvec3 generateHelixColor(vec3 pos, vec3 norm, vec3 lig) {\n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    vec3 col = vec3(1.0, .2, .2);\n    return ambient + col * diffuse;\n}\n\nvec3 generateSeaColor(float t, vec3 ro, vec3 rd, vec3 norm, vec3 lig) {\n    float ndotr = dot(norm, rd);\n    float r0 = .6;\n    float fresnel = r0 + (1. - r0) * pow(1.0 - abs(ndotr), 5.);\n    vec3 col = vec3(.292, .434, .729), reflCol, refrCol;\n    \n    //rd = reflect(rd, vec3(0., 1., 0.));\n    vec3 reflD = reflect(rd, normalize(norm + vec3(.0, .3, .0)));\n    PrimitiveDist res = raymarch(ro, reflD, 100., .5);\n    vec3 reflPos = ro + res.dist * reflD;\n    if (res.primitive == TERRAIN) {\n    \t//col = mix(col, vec3(.3, .3, .3), .5);\n        //col = vec3(0., 0., 0.);\n        reflCol = generateTerrainColor(t, reflPos, calcNormal(reflPos, TERRAIN), lig);\n    }\n    \n    //vec3 refrD = refract(rd, normalize(norm + vec3(.0, .5, .0)), .8);\n    vec3 refrD = refract(rd, vec3(0., 1., 0.), .8);\n    res = raymarchUnderSea(ro, refrD, 20., .8);\n    vec3 refrPos = ro + res.dist * refrD;\n    //refrCol = texture(iChannel1, refrPos.xz * 2.).xyz;\n    if (res.primitive == TERRAIN) {\n        refrCol = generateTerrainColor(t, refrPos, calcNormal(refrPos, TERRAIN), lig);\n    } else if (res.primitive == HELIX) {\n    \trefrCol = generateHelixColor(refrPos, calcNormal(refrPos, HELIX), lig);\n    }\n    \n    col = mix(col, fresnel * reflCol + (1. - fresnel) * refrCol, .8);\n    //col = reflCol * .4;\n    //col *= fresnel;\n    \n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    // Specular \n    float specular = pow(clamp(dot(rd, reflect(lig, norm)), 0.0, 1.0), 32.);\n    \n    return ambient + col * (diffuse + specular);\n}\n\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n\n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(0.2,0.9,0.3));\n    vec3 lightCol = vec3(1., 1., 1.);\n    float shiness = 32.;\n    float gloss = 1.;\n\n\n    // Normal vector\n    vec3 nor = calcNormal(pos, which);\n\n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == TERRAIN) {\n        //material = texCube(iChannel0, pos, nor);\n        col = generateTerrainColor(t, pos, nor, lig);    \n    } else if (which == HELIX) {\n        col = generateHelixColor(pos, nor, lig);\n    } else if (which == SEALEVEL){\n      \tcol = generateSeaColor(t,pos - rd * .05, rd, nor, lig);\n    } \n    \n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), shiness) * gloss;\n\n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    //col += vec3(((ambient + diffuse + specular) * darkness));\n    //col += vec3(ambient + diffuse + specular);\n\n    // Blend the material color with the original color.\n    //col = mix(col, material, 0.4);\n    //col = ambient + lightCol * material * (diffuse + specular);\n\n    return col;\n}\n\n\n//calculate single noise\nfloat c_noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x); \n    f = f * f * (3.0 - 2.0 * f);\n    \n    p.xz += WIND * iTime;\n    vec2 uv = (p.xz + vec2(1.0, 10.0) * p.y) + f.xz;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.y);\n}\n\n//calculate fractcal noise\nfloat c_fractal_noise(vec3 p)\n{\n    float fbm = 0.0;\n\n    p = p * 3.0;\n    fbm += 0.50000 * c_noise(p); p = 3.0 * p;\n\tfbm += 0.25000 * c_noise(p); p = 3.0 * p;\n\tfbm += 0.12500 * c_noise(p); p = 3.0 * p;\n\tfbm += 0.06250 * c_noise(p); p = 3.0 * p;\n    \n    return fbm;\n}\n\nfloat c_density(vec3 pos)\n{    \n    return 3.5 * c_fractal_noise(pos * 0.1) - 0.5 + (pos.y - MIN_HEIGHT);    \n}\n\nvec3 c_raymarching(vec3 ro, vec3 rd, float t, vec3 backCol)\n{   \n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 40; i++) {\n        if (sum.a > 0.99 || \n            pos.y < (MIN_HEIGHT-1.0) || \n            pos.y > (MAX_HEIGHT+1.0)) break;\n        \n        float den = c_density(pos);\n        \n        if (den > 0.01) {\n            float dif = clamp((den - c_density(pos+0.3*sundir))/0.6, 0.0, 1.0);\n\n            vec3 lin = vec3(0.65,0.7,0.75)*1.5 + vec3(1.0, 0.6, 0.3)*dif;        \n            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*0.7, vec3(0.35,0.4,0.45), den), den);\n            col.rgb *= lin;\n\n            // front to back blending    \n            col.a *= 0.5;\n            col.rgb *= col.a;\n\n            sum = sum + col*(1.0 - sum.a); \n        }\n        \n        t += max(0.05, 0.02 * t);\n        pos = ro + rd * t;\n    }\n    \n    sum = clamp(sum, 0.0, 1.0);\n    \n    float h = rd.y;\n    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );\n    \n    return mix(backCol, sum.xyz, sum.a);\n}\n\nfloat planeIntersect( vec3 ro, vec3 rd, float plane)\n{\n    float h = plane - ro.y;\n    return h/rd.y;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    c_l =normalize(vec3(sin(iTime*0.41),sin(iTime*0.1)*0.27+0.30,cos(iTime*0.512)));\n    float height = 0.;\n    \n    vec3 rayOrigin = vec3(30.0 * sin(iTime * .3), 15., 30.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0, 12., 0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // Construct the ray direction vector\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    vec3 rayDirection = vec3(uv, focalLength);\n    rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + focalLength * cameraForward);\n      \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection, 500., .3);\n    float dist = planeIntersect(rayOrigin, rayDirection, MIN_HEIGHT);\n    //sky color\n    vec3 col = vec3(0.78,0.78,0.7);\n    \n    float sun = clamp(dot(sundir, rayDirection), 0.0, 1.0);\n    \n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n      \n    }\n    else\n        col = c_raymarching(rayOrigin, rayDirection, dist, col);\n    \t//col=vec3(0.);\n    col +=0.55*vec3(0.9,0.3,0.1)*pow(sun, 30.0);\n     \n    float fo = 1.0 - exp( -rayMarchResult.dist*0.006 );\n    vec3 fco = vec3(0.78,0.78,0.7);\n    col = mix( col, fco, fo );\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}