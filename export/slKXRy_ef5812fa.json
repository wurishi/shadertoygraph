{"ver":"0.1","info":{"id":"slKXRy","date":"1641160131","viewed":232,"name":"Hypocycloid","username":"sadf","description":"Inspired by Mathologer video: https://www.youtube.com/watch?v=oEN0o9ZGmOM\n\nA, S, D toggle collections of segments.\n\nUp and down change numerator. Left and right change denominator.\n\nPoints orbit around hypocycloid, hence the title.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["hypocycloid","mathologer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793;\n\nconst int c_key_a = 65;\nconst int c_key_s = 83;\nconst int c_key_d = 68;\n\n\nconst vec3 materials[3] = vec3[3](\n    vec3(1.),\n    vec3(.8, 0.5, 0.),\n    vec3(0.2, 0.3, 1.)\n);\n\n\n/* Toggles between 0. and 1. when key is pressed.\n */\nfloat get_togglestate(int keycode) {\n    return texelFetch(iChannel0, ivec2(keycode, 2), 0).x;\n}\n\n\n\n/* Compute square device coordinates from pixel coordinates. Square coordinates\n * have (0, 0) at the center and the larger axis goes from -1 to 1. The smaller axis\n * goes through a smaller range, depending on aspect ratio.\n */\nvec2 to_squarecoord(vec2 uv, vec3 res) {\n    float resMax = max(res.x, res.y);\n    return (2.*uv - res.xy) / resMax;\n}\n\n\n\nfloat dCirc(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat dSeg(vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nmat2 rot(float theta)\n{\n    return mat2(\n        cos(theta), -sin(theta),\n        sin(theta), cos(theta)\n    );\n}\n\n\n// https://en.wikipedia.org/wiki/Hypocycloid\nvec2 hypothrochoid(float theta, float R, float r)\n{\n    float d = R - r;\n\n    return vec2(\n        d*cos(theta) + r*cos(d*theta/r),\n        d*sin(theta) - r*sin(d*theta/r)\n    );\n}\n\n\nvec2 point(float x)\n{\n    float theta = 2.*PI * x;\n    \n    return vec2(cos(theta), sin(theta));\n}\n\n\nfloat scene(vec2 xy, float num, float denom, out int m)\n{\n    const float s = 0.5;\n    float rnum = 1./num;\n    float npoints = denom*(num-denom);\n\n    float hlen = 2.*PI*denom;\n    float hstep = 2.*PI*denom/npoints;\n    float r = 0.2*rnum*hlen;\n\n    float d = 1e6;\n    float d_;\n    int m_ = 0;\n\n    if (0. < get_togglestate(c_key_a)) {\n\n        for (float n=0.; n<num; n+=1.) {\n            vec2 f = s*point(rnum*n);\n            vec2 t = s*point(fract(rnum*(n+denom)));\n\n            d = min(d, dSeg(xy, f, t));\n        }\n    }\n    for (float n=0.; n<npoints; n+=1.) {\n        vec2 p1 = rnum*s*hypothrochoid(r*iTime + n*hstep, num, denom);\n        vec2 p2 = rnum*s*hypothrochoid(r*iTime + mod(n+(num-denom), npoints)*hstep, num, denom);\n        vec2 p3 = rnum*s*hypothrochoid(r*iTime + mod(n+denom, npoints)*hstep, num, denom);\n\n        d_ = dCirc(xy - p1, 0.03);\n        if (d_ < d) { d = d_; m_ = 0; }\n\n        if (0. < get_togglestate(c_key_s)) {\n            \n            d_ = dSeg(xy, p1, p2);\n            if (d_ < d) { d = d_; m_ = 1; }\n        }\n        if (0. < get_togglestate(c_key_d)) {\n            d_ = dSeg(xy, p1, p3);\n            if (d_ < d) { d = d_; m_ = 2; }\n        }\n    }\n    m = m_;\n    return d;\n}\n\n\n// from https://www.shadertoy.com/view/3ltSW2\nvec3 dist2col(float d, int m)\n{\n    vec3 mat = materials[m];\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, mat, 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    return col;\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec4 char(vec2 p, int c)\n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n\nvec3 renderText(vec2 uv, vec2 star)\n{\n    // https://www.shadertoy.com/view/4sBfRd\n    const float FontSize = 11.;\n    const vec2 pos = vec2(0.3, 0.36);\n    vec2 U = ( uv - pos)*64.0/FontSize;\n    vec3 col = vec3(0.);\n\n    col -= char(U, 123).rrr;\n    U.x -= 0.5;\n    col -= char(U, 48+int(mod(0.1*star.x, 10.))).rrr;\n    U.x -= 0.5;\n    col -= char(U, 48+int(mod(star.x, 10.))).rrr;\n    U.x -= 0.5;\n    col -= char(U, 47).rrr;\n    U.x -= 0.5;\n    col -= char(U, 48+int(mod(0.1*star.y, 10.))).rrr;\n    U.x -= 0.5;\n    col -= char(U, 48+int(mod(star.y, 10.))).rrr;\n    U.x -= 0.5;\n    col -= char(U, 125).rrr;\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float r = 0.07;\n    vec2 star = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n\n    vec2 uv = 1.*to_squarecoord(fragCoord, iResolution);\n\n    int m;\n    float d = scene(rot(r*iTime)*uv, star.x, star.y, m);\n    vec3 col = dist2col(-2. * d, m);\n    col += renderText(uv, star);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int c_key_left = 37;\nconst int c_key_up = 38;\nconst int c_key_right = 39;\nconst int c_key_down = 40;\n\nconst float cooldown = 0.15;\n\n\n/* Returns 0. or 1. depending or whether key is currently pressed.\n */\nfloat get_pressed(int keycode) {\n    return texelFetch(iChannel0, ivec2(keycode, 0), 0).x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Run this computation only in the relevant area\n    if (fragCoord.x < 2. && fragCoord.y < 2.) {\n\n        vec4 state = texelFetch(iChannel1, ivec2(0, 0), 0);\n        vec2 star = state.xy;\n        float press_time = state.z;\n        float time_since = iTime - press_time;\n        bool cooled_down = cooldown < time_since;\n\n\n        // (re)set to sane default.\n        if (star.x == 0. || star.y == 0.) {\n            star = vec2(7., 3.);\n        }\n        if (cooldown < time_since) {\n            if (0. < get_pressed(c_key_left)) {\n                star.y -= 1.;\n                press_time = iTime;            \n            }\n            if (0. < get_pressed(c_key_right)) {\n                star.y += 1.;\n                press_time = iTime;\n            }\n            if (0. < get_pressed(c_key_down)) {\n                star.x -= 1.;\n                press_time = iTime;\n            }\n            if (0. < get_pressed(c_key_up)) {\n                star.x += 1.;\n                press_time = iTime;\n            }\n        }\n\n        fragColor = vec4(star, press_time, 1.0); \n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}