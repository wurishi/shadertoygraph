{"ver":"0.1","info":{"id":"3sGBW1","date":"1681759935","viewed":34,"name":"HRay-marchingKlein","username":"qinw","description":"raymarching in hyperbolic space","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["h"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 50\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nbool print( in vec2 _coord, float _in ) {\n  vec2 coord = _coord;\n\n  // vertical restriction\n  if ( coord.y <= 0.0 || 5.0 <= coord.y ) { return false; }\n  \n  // dot\n  if ( 0.0 < coord.x && coord.x < 2.0 ) {\n    return coord.x < 1.0 && coord.y < 1.0;\n  }\n\n  // padded by dot\n  if ( 2.0 < coord.x ) { coord.x -= 2.0; }\n  \n  // determine digit\n  float ci = floor( coord.x / 5.0 ) + 1.0;\n\n  // too low / too high\n  if ( 4.0 < ci ) { return false; }\n  if ( ci < -4.0 ) { return false; }\n\n  // x of char\n  float cfx = floor( mod( coord.x, 5.0 ) );\n\n  // width is 4\n  if ( 4.0 == cfx ) { return false; }\n\n  // y of char\n  float cfy = floor( coord.y );\n\n  // bit of char\n  float cf = cfx + 4.0 * cfy;\n\n  // determine char  \n  float num = 0.0;\n  if ( 0.0 < ci ) {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( ci < float( i ) ) { break; }\n      \n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n *= 10.0;\n    }\n  } else {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( -ci < float( i ) ) { break; }\n      \n      if ( ci != 0.0 && n < 1.0 ) {\n        // minus\n        return float( i ) == -ci && _in < 0.0 && cfy == 2.0 && 0.0 < cfx;\n      }\n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n /= 10.0;\n    }\n  }\n\n  bool a;\n  a = 1.0 == mod( floor( (\n    num == 0.0 ? 432534.0 :\n    num == 1.0 ? 410692.0 :\n    num == 2.0 ? 493087.0 :\n    num == 3.0 ? 493191.0 :\n    num == 4.0 ? 630408.0 :\n    num == 5.0 ? 989063.0 :\n    num == 6.0 ? 399254.0 :\n    num == 7.0 ? 1016898.0 :\n    num == 8.0 ? 431766.0 :\n    433798.0\n  ) / pow( 2.0, cf ) ), 2.0 );\n  \n  return a ? true : false;\n}\n\n\n\n/* Some unitility functions before we start*/\n\nfloat HDot(vec4 v1, vec4 v2){\n    /* H inner product*/\n\treturn -v1.x *v2.x-v1.y *v2.y-v1.z *v2.z+v1.w *v2.w;\n}\n\n\nvec4 HNormalize(vec4 v){\n    /* Normalize to +-1*/\n\tfloat norm = sqrt(abs(HDot(v,v)));\n    return v/norm;\n}\n\n\n\nvec4 HMove(vec4 p, vec4 tangent, float t){\n/*\nMove along the geodesics at p in the tangent direction for distance t. \nImportant: tangent is normalized. \n*/\n    \n    return p*cosh(t)+tangent*sinh(t);\n}\n\n\n\nvec4 FindTangent(vec4 p ,vec4 q){\n/*\nTakes two points p and q, and returns the tangent vector at p\n*/\n    float d = HDot(p,q);\n    // CHECK THIS!!!!!!!!!!!!!!!!!!\n    return (q-d*p)/sqrt(pow(d,2.)-1.);\n    \n}\n\n\nfloat HLength(vec4 p,vec4 q){\n/*\nCompute distance between two points\n*/\n\treturn abs(acosh(HDot(p,q)));\n}\n\nfloat GetDist(vec4 p) {\n    /* Get the minimum  distance of p with ANY object in the world*/\n    // First object: sphere with center s\n\tvec4 s = vec4(10.,10.,5.,sqrt(226.));\n    float r = 2.;\n    float sphereDist1 = HLength(p,s)-r;\n    \n    vec4 s2 = vec4(10.,0.,0.,sqrt(101.));\n    float r2 = 2.;\n    float sphereDist2 = HLength(p,s2)-r2;\n    \n    // Second object: floor with height h\n    //float h = -0.;\n    //float planeDist = p.y-h;\n    \n    // Compute min distance\n    float d = min(sphereDist1,sphereDist2);\n    return d;\n} \n\n\nfloat RayMarch(vec4 ro, vec4 rd){\n   \t/*Take a ray origin and a normalized(important!) ray direction. \n\t  Return the total ray marching distance from origin to the closest intersection point in the world.\n    */ \n    \n\tfloat dO = 0.;\n    \n    // marching loop\n    for(int i = 0; i<MAX_STEPS;i++){\n        // move our current point along the ray (safely)\n    \tvec4 p = ro*cosh(dO)+rd*sinh(dO);\n        float dS = GetDist(p);\n        dO+= dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    \n    return dO;\n }\n\nvec4 GetNormal(vec4 p ){\n    /* Get the normal vector at point p*/ \n    \n\tfloat d = GetDist(p);\n    \n    // Get three (independent) tangent vectors at p\n    vec4 basisx = HNormalize(vec4(p.w,0.0,0.0,p.x));\n    vec4 basisy = vec4(0.0,p.w,0.0,p.y);\n    vec4 basisz = vec4(0.0,0.0,p.w,p.z);  \n    \n    // Use Gram Schmidt \n    basisy = HNormalize(basisy - HDot(basisy, basisx)*basisx); \n    basisz = HNormalize(basisz - HDot(basisz, basisx)*basisx - HDot(basisz, basisy)*basisy); \n    \n    float dx = GetDist(HMove(p,basisx,5.*SURF_DIST))-GetDist(HMove(p,basisx,-5.*SURF_DIST));\n    float dy = GetDist(HMove(p,basisy,5.*SURF_DIST))-GetDist(HMove(p,basisy,-5.*SURF_DIST));\n    float dz = GetDist(HMove(p,basisz,5.*SURF_DIST))-GetDist(HMove(p,basisz,-5.*SURF_DIST));\n    //Approximate the gradient of SDF at p\n    vec4 n = basisx *dx+basisy *dy+basisz *dz;\n\t\n    \n    return HNormalize(n);\n}\n\n\n\nfloat GetLight(vec4 p, vec4 ro){\n    // Light Position\n\tvec4 lightPos = vec4(10,20.*cos(iTime),20.*sin(iTime),sqrt(501.));\n    float lightIntensity = 1.;\n    \n    // The light vector with respect to p\n    vec4 l = FindTangent(p,lightPos);\n    \n    // The normal vector at p\n\tvec4 n = GetNormal(p);\n    \n    // The view vector with respect to p\n    vec4 v = FindTangent(p,ro);\n    \n    // The mid-vector between l and v\n    vec4 h = HNormalize(v+l);\n  \n    // kd = diffuse coefficient, ks  = specular coefficient \n    float kd = 1.;\n    float ks = .2;\n    float dif = -kd*lightIntensity*HDot(n,l);\n    float spec = -ks*lightIntensity*HDot(n,h);\n    \n    // add diffuse and specular\n    float light = dif+spec;\n    \n    //Cast Shadow by shooting another marching to light source. \n    float d = RayMarch(HMove(p,n,40.*SURF_DIST),l);\n    if(d<HLength(p,lightPos)-1.*SURF_DIST) light = 0.;\n\treturn light;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get Global Time\n    float time = iTime;\n    \n   \t// initalize output color\n\tvec3 col = vec3(0);\n    \n    // adjusted uv \n    vec2 uv = 2.*(fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    // initiate center of screen in H3 \n    vec4 ro =  vec4(0.,0.,0.,1.);\n\n\t\n  \tfloat fov = 0.28;\n    vec4 screenpoint = HNormalize(vec4(fov,uv,1.));\n    \n\n    vec4 rd = FindTangent(ro,screenpoint);\n\n\n    \n    // Get the closest intersection point from ro at rd direction\n    float d = RayMarch(ro,rd);\n    vec4  p = HMove(ro,rd,d);\n \n    // Get the lighting info at that point\n    float light = GetLight(p,ro);\n    \n    /*if ( print( ( fragCoord - vec2( 100.0, 100.0 ) )  / 2.0, light) ) {\n        fragColor = vec4( 1.0, 1.0, 1.0, 1.0 );\n    }\n    else{\n    \tfragColor = vec4(light,0.,0.,1.);\n    }*/\n    fragColor = vec4(light,0.,0.,1.);    \n}","name":"Image","description":"","type":"image"}]}