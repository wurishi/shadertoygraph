{"ver":"0.1","info":{"id":"Xl3fzH","date":"1538555127","viewed":278,"name":"Mean value opt dithering","username":"vchizhov","description":"Gradient descent based dithering. The objective function is the MSE between R and P. R and P are the 3x3 box filtered reference (greyscale) and dithered images respectively. The convex objective function guarantees a global minimizer.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["dithering","gradientdescent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = step(0.5, texture(iChannel0,uv).xyz);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 luminance = vec3(0.2126, 0.7152, 0.0722);\n\n// r(x,y) \\in [0,1] - the greyscale value of pixel (x,y) from the reference image\n// p(x,y) \\in {0,1} - the value of pixel (x,y) from the dithered image\n// R(x,y) = 1/9 * \\sum_{i=-1,j=-1}^{1,1}{r(x+i,y+j)} - average reference value in a 3x3 windiow\n// P(x,y) = 1/9 * \\sum_{i=-1,j=-1}^{1,1}{p(x+i,y+j)} - average ditheredm value in a 3x3 window\n// objective function: G(p1,...,pn) = \\sum_{x=0,y=0}^{w,h}{(R(x,y)-P(x,y))^2}\n\n// dG/dp_{x,y} = 2/9  * <Vec[K],Vec[N_p(x,y)-N_r(x,y)]>\n// where:\n//             [ h(x-2,y-2)  h(x-1,y-2)  h(x,y-2)  h(x+1,y-2)  h(x+2,y-2) ]\n//             [     .................................................    ]\n//\tN_h(x,y) = [     .................................................    ]\n//             [     .................................................    ]\n//\t\t\t   [ h(x-2,y+2)  h(x-1,y+2)  h(x,y+2)  h(x+1,y+2)  h(x+2,y+2) ]\n// basically the 5x5 stencil around (x,y) from the image h\n\n//     [ 1  2  3  2  1 ]\n//     [ 2  4  6  4  2 ]\n// K = [ 3  6  9  6  3 ]\n//     [ 2  4  6  4  2 ]\n//     [ 1  2  3  2  1 ]\n\nfloat K[25] = float[25](1.0,  2.0,  3.0,  2.0,  1.0, \n                       2.0,  4.0,  6.0,  4.0,  2.0,\n                       3.0,  6.0,  9.0,  6.0,  3.0,\n                       2.0,  4.0,  6.0,  4.0,  2.0,\n                       1.0,  2.0,  3.0,  2.0,  1.0);\n\nfloat minimize(sampler2D ref, sampler2D dit, vec2 uv)\n{\n    vec2 scale = 1.0/iResolution.xy;\n    float dGdp = 0.0;\n    for(int x=0;x<5;++x)\n    {\n        for(int y=0;y<5;++y)\n        {\n            int index = x + 5*y;\n            vec2 offset = vec2(float(x)-2.0, float(y)-2.0);\n            float refC = dot(luminance, texture(ref, uv + offset*scale).xyz);\n            float ditC = texture(dit, uv + offset*scale).x;\n            dGdp += K[index] * (ditC-refC);\n        }\n    }\n    float stepSize =  0.1;\n    return stepSize * 2.0/9.0 * dGdp;\n}\n\nfloat solve(sampler2D ref, sampler2D dit, vec2 uv)\n{\n    vec2 scale = 1.0/iResolution.xy;\n    float dGdp = 0.0;\n    for(int x=0;x<5;++x)\n    {\n        for(int y=0;y<5;++y)\n        {\n            int index = x + 5*y;\n            vec2 offset = vec2(float(x)-2.0, float(y)-2.0);\n            float refC = dot(luminance, texture(ref, uv + offset*scale).xyz);\n            float ditC = texture(dit, uv + offset*scale).x;\n            dGdp += K[index] * (ditC-refC);\n        }\n    }\n    \n    float a1 = texture(dit,uv).x;\n    // [0,1] -> [1,-1]\n    float dc = 1.0-2.0*a1;\n    \n    \n    float dGdp2 = K[12]*dc;\n    \n    \n    //float stepSize = 0.1;\n    //return stepSize * 2.0/9.0 * dGdp;\n    \n    return dGdp2>dGdp ? a1 : 1.0-a1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec3 col = texture(iChannel0, uv).xyz;\n    //float g = dot(col, luminance);\n    bool textureLoaded = iChannelResolution[0].x>0.0;\n    bool initDone = texelFetch(iChannel3, ivec2(fragCoord), 0).w>0.0;\n    float col;\n    if(textureLoaded)\n    {\n        col = initDone ? texelFetch(iChannel3, ivec2(fragCoord.xy), 0).x : step(0.5,dot(texture(iChannel0, uv).xyz, luminance));\n        //col = solve(iChannel0, iChannel3, uv);\n        col -= minimize(iChannel0, iChannel3, uv);\n    }\n    else\n    {\n        col = 0.0;\n    }\n    \n    \n    \n    fragColor = vec4(vec3(step(0.5,col)),float(textureLoaded));\n}","name":"Buffer A","description":"","type":"buffer"}]}