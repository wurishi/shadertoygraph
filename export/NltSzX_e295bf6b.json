{"ver":"0.1","info":{"id":"NltSzX","date":"1639936394","viewed":271,"name":"Option Paralysis","username":"shau","description":"3d","likes":28,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec2 uv = U / R;\n\tvec3 pc = vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.).xyz;\n    C = vec4(pc, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 sz = U/R.x*30.0,\n         uv = fract(sz);\n    \n    float lt = abs(length(uv-vec2(0.0))-0.5);\n    lt = min(lt,abs(length(uv-vec2(1.0))-0.5));\n    \n    float h = hash12(floor(sz))-0.5;\n    if (h>0.0)\n    {\n        lt = abs(length(uv-vec2(0.0,1.0))-0.5);\n        lt = min(lt,abs(length(uv-vec2(1.0,0.0))-0.5));\n    }\n    \n    vec3 col = vec3(1.0)*smoothstep(0.4,0.0,lt);\n    \n    C = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n#define R iResolution.xy\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins hash without sin\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n#define ZERO (min(iFrame,0))\n#define EPS .004\n#define FAR 100.\n#define T iTime\n#define PI 3.14159\n\n\nfloat saturate(float x) {return clamp(x, 0.0, 1.0);}\nvec3 saturate(vec3 x) {return clamp(x, vec3(0.0), vec3(1.0));}\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat wall(vec2 p)\n{\n    float lt = abs(fract((length(p- vec2( 5.0, 5.7))+fract(T*-0.1)*4.0)*0.25) - 0.5);\n    lt = max(lt,abs(fract((length(p-vec2(-5.0, 5.7))+fract(T*-0.1)*4.0)*0.25) - 0.5));\n    lt = max(lt,abs(fract((length(p-vec2(-5.0,-5.7))+fract(T*-0.1)*4.0)*0.25) - 0.5));\n    lt = max(lt,abs(fract((length(p-vec2( 5.0,-5.7))+fract(T*-0.1)*4.0)*0.25) - 0.5));\n    return lt;\n}\n\n//distance functions from IQ\n//https://iquilezles.org/articles/distfunctions\n//https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n    float angle = 6.283185/repetitions,\n          a = atan(p.y, p.x) + angle / 2.0,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nvec2 near(vec2 a, vec2 b)\n{\n    float s = step(a.x,b.x);\n    return s*a + (1.0-s)*b;\n}\n\nvec2 dfBrain(vec3 p)\n{\n    //brain\n    vec3 q = p - vec3(0.0,2.0,0.5);\n    q.x = abs(q.x);\n    float txz = mix(texture(iChannel0,(q.xz+vec2(4.0))*0.09).x,\n                    texture(iChannel0,(q.xy+vec2(4.0))*0.09).x,\n                    smoothstep(1.0,0.0,abs(q.y)));\n    txz = mix(txz,\n              texture(iChannel0,(q.yz+vec2(4.0))*0.09).x,\n              smoothstep(1.0,2.0,q.x));    \n    float brain = max(sdEllipsoid(q-vec3(0.3,0.0,0.0),vec3(2.0,1.8,3.4)),q.z);\n    brain = min(brain,sdEllipsoid(q-vec3(0.3,0.0,0.0),vec3(2.0,1.8,2.0)));\n    brain = smax(brain,-length(q.yz-vec2(-6.0,-3.0))+6.0,0.3);\n    brain = smax(brain,-q.y-0.8,0.3);\n    brain -= n3D(q*2.0)*0.1;\n    brain -= txz*0.06;\n    float nz = n3D(q*6.0)*0.06;\n    brain = smin(brain,sdEllipsoid(q-vec3(0.0,-0.5,0.0),vec3(1.6,1.4,1.3)+nz),0.6);\n    brain = smax(brain,-(abs(q.x)-0.02),0.3);\n    brain = smin(brain,sdEllipsoid(q-vec3(0.0,-1.8,-0.2),vec3(0.5,1.0,0.7)+nz),0.2);\n    q.z += sin(q.y*1.4)*0.3;\n    brain = smin(brain,sdCapsule(q,vec3(0.0,-2.0,0.0),vec3(0.0,-7.0,0.0),0.4+nz*0.4+q.y*0.04),0.2);\n    vec3 c1 = vec3(0.0,fract(T*0.2)*-5.0-2.0,0.0);\n    brain = smin(brain,length(q-c1)-(0.6+q.y*0.07),0.3);\n    return vec2(brain,length(q-c1));\n}\n\nfloat dfTap(vec3 p, float r)\n{\n    p.xy *= rot(r);\n    float t = min(sdTorus(p,vec2(0.8,0.1)),sdCapsule(p,vec3(-1.1,0.0,0.0),vec3(1.1,0.0,0.0),0.1));\n    t = min(t,sdCapsule(p,vec3(0.0,-1.1,0.0),vec3(0.0,1.1,0.0),0.1));\n    return min(t,sdCapsule(p,vec3(0.0,0.0,-0.1),vec3(0.0,0.0,1.0),0.25));\n}\n\nvec2 dfVessel(vec3 p)\n{\n    float t = sdCappedCylinder(p,3.4,6.5);\n    vec3 q = p;\n    pModPolar(q.xz,8.0);\n    //portholes\n    float r = max(sdBox(q-vec3(3.4,0.0,0.0),vec3(0.4,5.0,1.0))-0.2,\n                     sdCappedCylinder(q,3.5,10.0));\n    r = min(r,sdBox(q-vec3(3.4,0.0,0.0),vec3(0.1,4.8,1.0))-0.1);\n    r = max(r,p.z+1.5);\n    r = max(r,-max(sdBox(q-vec3(3.4,0.0,0.0),vec3(0.3,4.7,0.9)),p.z+1.5));    \n    t = max(t,-max(sdBox(q-vec3(3.4,0.0,0.0),vec3(0.3,4.71,0.91)),p.z+1.5));\n    q = p;\n    q.y = abs(q.y);\n    t = min(t,sdCapsule(q,vec3(-100.0,1.5,0.0),vec3(100.0,1.5,0.0),0.6));\n    t = min(t,sdCapsule(q,vec3(-5.0,5.7,-2.0),vec3(5.0,5.7,-2.0),0.3));\n    r = min(r,sdCappedCylinder(q-vec3(0.0,6.5,0.0),3.8,0.2));\n    float z = min(sdCapsule(q,vec3(-10.0,1.5,0.0),vec3(10.0,1.5,0.0),0.8),\n                  sdCapsule(q,vec3(-3.0,5.7,-2.0),vec3(3.0,5.7,-2.0),0.6));\n    z = max(z,sdCappedCylinder(q,3.5,10.0));\n    t = min(t,z);\n    t = max(t,-sdCappedCylinder(q,3.3,6.5));\n    q.x = abs(q.x);\n    t = min(t,sdCapsule(q,vec3(5.0,5.7,-2.0),vec3(5.0,5.7,10.0),0.3));\n    t = min(t,sdCappedCylinder(q.yxz-vec3(1.5,10.0,0.0),0.7,1.0));    \n    r = min(r,dfTap(q-vec3(10.0,1.5,-1.0),0.5));\n    return near(vec2(t,2.0),vec2(r,4.0));\n}\n\nvec2 dfGlass(vec3 p)\n{\n    return vec2(sdCappedCylinder(p,3.3,6.5),3.0);\n}\n\nvec2 map(vec3 p) \n{\n    vec2 nr = near(dfVessel(p),dfGlass(p));\n    float w = sdBox(p-vec3(0.0,0.0,6.0),vec3(100.0,100.0,1.0));\n    w -= smoothstep(0.3,0.45,wall(p.xy))*0.2;\n    return near(nr,vec2(w,1.0));\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//reminds me of Abby Normal joke in Young Frankenstein \nvec3 normalBrain(vec3 p)\n{\n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = dfBrain(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) \n{\n    float ra = 0., w = 1., d = 0.;\n    for (int i=ZERO; i<5; i++){\n        d = float(i) / 5.;\n        ra += w * (d - map(p + n*d).x);\n        if (ra>1.) break;\n        w *= .5;\n    }\n    return 1. - clamp(ra,0.,1.);\n}\n\n//IQ\n//https://www.shadertoy.com/view/lsKcDD\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=ZERO; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<EPS || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec2 march(vec3 ro, vec3 rd) \n{\n    float t = 0.0, id = 0.0;   \n    for (int i=ZERO; i<100; i++)\n    {\n        vec2 ns = map(ro + rd*t);\n        if (abs(ns.x)<EPS)\n        {\n            id = ns.y;\n            break;\n        }\n        t += ns.x;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n        \n    }\n    return vec2(t,id);\n}\n\nvec4 vMarch(vec3 ro, vec3 rd)\n{\n    vec3 pc = vec3(0.0),\n         gc = vec3(0.0),\n         lp = vec3(0.0,6.0,0.0);\n         \n    float t = EPS, id = 0.0;\n    vec2 ns;\n    for (int i=ZERO; i<100; i++) \n    {\n        vec3 p = ro + rd*t;\n        if (dfGlass(p).x>0.0)\n        {\n            //outside glass\n            break;\n        }\n        ns = dfBrain(p);\n        if (ns.x<EPS)\n        {\n            //hit brain\n            id = 1.0;\n            break;\n        }\n        \n        float nz = n3D(p*vec3(6.0,2.3,7.7)+vec3(sin(T*0.3),T*-5.0,sin(1.1+T*0.9)));\n        \n        float lt = length(lp-p);\n        pc += vec3(1.0,0.8,0.4)/(1.0+lt*lt*50.0)*nz;\n        pc += vec3(0.2,0.4,1.0)*0.01*nz;\n        pc += vec3(1.0,1.0,0.0)/(1.0+pow(ns.y,3.0)*60.0)*nz;\n        \n        t += ns.x*0.25;\n    }\n    \n    if (id>0.0) \n    {\n        vec3 p = ro + rd*t;\n        vec3 n = normalBrain(p);\n        vec3 ld = normalize(lp-p);\n        float spec = pow(max(dot(reflect(-ld,n),-rd),0.0),16.0);\n        vec3 sc = mix(vec3(1.0,0.7,0.7),\n              vec3(0.8,0.6,1.0),n3D(p*3.7))*max(0.01,dot(ld,n));\n        sc = mix(sc,\n                 vec3(2.0,2.0,0.0)*smoothstep(1.0,-1.0,p.y),\n                 1.0/(1.0+ns.y*ns.y*ns.y*1.0));  \n        sc += vec3(1.0)*spec;\n        pc = sc;\n    }\n    \n    return vec4(pc,0.0);\n}\n\n//verbatim from shane\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n//Knarkowicz\n//https://www.shadertoy.com/view/4sSfzK\nvec3 fresnelSchlick(float vdoth, vec3 specularColour) {\n    return specularColour + (1.0 - specularColour) * pow(1.0 - vdoth, 5.0);\n} \n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat geometrySchlickGGX(float ndot, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n    float nom = ndot;\n    float denom = ndot * (1.0 - k) + k;\n    return nom / denom;\n}\n\nfloat geometrySmith(float roughness, float ndotv, float ndotl) {\n    float ggx2  = geometrySchlickGGX(ndotv, roughness);\n    float ggx1  = geometrySchlickGGX(ndotl, roughness);\n    return ggx1 * ggx2;\n}\n\nvec3 envBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return specularColor * AB.x + AB.y;  \n}\n\nvec3 envRemap(vec3 c) {\n    return pow(2.0 * c, vec3(2.2));\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 pc = vec3(0.0),\n         la = vec3(0.0),\n         lp = vec3(3.0,12.0,-8.0),\n         ro = vec3(0.0,sin(T*0.07)*6.0,-12.0+sin(T*0.13));\n    \n    ro.xz *= rot(sin(1.3-T*-0.1)*0.3);\n    vec3 rd = camera(U,ro,la,1.4);\n\n    float dof = 0.0;\n    vec2 s = march(ro,rd);\n    if (s.x>0.0)\n    {\n        \n        vec3 p = ro + rd*s.x;\n        vec3 n = normal(p);\n        dof = length(p)/FAR*0.5;\n        \n        float rG = 0.0,\n              metal = 0.0; \n              \n        vec3 sc = vec3(0.0);\n        if (s.y==1.0)\n        {\n            //wall\n            float lt = smoothstep(0.46,0.47,wall(p.xy));\n            rG = 0.7;\n            if (lt>0.0)\n            {\n                metal = 1.0;\n                rG = 0.2;\n                sc = vec3(1.0,0.5,0.3);\n            }\n        }\n        if (s.y==2.0)\n        {\n            //vessel\n            n = doBumpMap(iChannel1, p*0.25, n, 0.03);\n            vec3 c = smoothstep(0., 1., tex3D(iChannel1, p*0.25, n));\n            rG = 0.2 + c.r;\n            sc = c*0.02;\n        }\n        if (s.y==3.0)\n        {\n            //glass\n            sc = vMarch(p-n*EPS,refract(rd,n,0.9)).xyz;\n        }\n        if (s.y==4.0)\n        {\n            //metal\n            metal = 1.0;\n            rG = 0.2;\n            sc = vec3(0.2,0.03,0.0);\n        }\n\n        vec3 ld = normalize(lp-p),\n             rrd = reflect(rd, n);\n        float ao = AO(p,n); \n        float sh = shadow(p+n*EPS*2.0,ld,EPS,30.0);\n\n        vec3 h = normalize(-rd + ld);\n        float rL = max(.01, rG*rG), //linear roughness\n              vdoth = clamp(dot(-rd, h), 0., 1.),\n              ndoth\t= clamp(dot(n, h), 0., 1.),\n              ndotv = clamp(dot(n, -rd), 0., 1.),\n              ndotl = clamp(dot(n, ld), 0., 1.);\n        \n        vec3 diffuseColour = metal == 1.0 ? vec3(0) : sc,\n             specularColour = metal == 1.0 ? sc : vec3(0.04),\n             diffuse = diffuseColour;\n        diffuse += diffuseColour * saturate(dot(n, ld));\n        //diffuse *= ao;\n        \n        vec3 envSpecularColour = envBRDFApprox(specularColour, rG*rG, ndotv),\n             env1 = envRemap(texture(iChannel2, rrd).xyz),\n             env2 = envRemap(texture(iChannel3, rrd).xyz),       \n             env  = mix(env1, env2, saturate(rG*rG * 4.0));\n        \n        vec3 specular = envSpecularColour * env;\n        vec3 lightF = fresnelSchlick(vdoth, specularColour);\n        float lightD = distributionTerm(rL, ndoth);\n        float lightV = geometrySmith(rL, ndotv, ndotl);\n        specular += vec3(1.) * lightF * (lightD * lightV * PI * ndotl);\n        specular *= saturate(pow(ndotv + ao, rG*rG) - 1.0 + ao);\n        \n        pc = (diffuse + specular) * sh;\n        //if(s)\n        if (s.y==3.0) {\n            pc = sc + specular;\n            pc *= 2.;\n        }\n        if (s.y==1.0) {\n            pc *= 0.15;\n        }\n        if (s.y==4.0) {\n            pc *= 0.7;\n        }\n        #define AObruh(p,n,a) smoothstep(0.,1.,map(p + n*a).x/a)\n        ao = AObruh(p,n,0.2)*AObruh(p,n,0.4)*AObruh(p,n,0.05)*(AObruh(p,n,3.65)+0.3);\n        ao = mix(ao,1.,0.05);\n        pc *= exp(-0.2*s.x*0.6)*ao;\n    }\n    \n    pc = pow(pc*2.0,vec3(0.3545));\n\n    C = vec4(pc,dof);\n}","name":"Buffer B","description":"","type":"buffer"}]}