{"ver":"0.1","info":{"id":"WllfW2","date":"1597846918","viewed":191,"name":"Art : Copy","username":"Gijs","description":"Fly around with WASDQE+Shift+Space+Mouse. I found this gif and thought it was perfect to recreate for fun :).\n\nhttps://nl.reddit.com/r/oddlysatisfying/comments/i0lja6/motion_singularity/\nhttps://www.instagram.com/p/CDREW25H7Aq/","likes":25,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 buf = texture(iChannel0,uv);\n    \n    vec3 col = buf.rgb;\n    \n    //gamma correction\n    col = pow(col, vec3(1./GAMMA));\n    \n    //vignette\n    vec2 s = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    col *= smoothstep(VIGNETTE_END, VIGNETTE_START, length(s));\n    \n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//constants\n    #define PI  3.14159\n    #define TAU 6.28318\n\n//Render\nconst float DETAIL    = 1.;\nconst int   MAX_STEPS = 128;\nconst float MAX_MARCH = 10.;\n\n//Lighting\nconst vec3  SKY_COLOR     = vec3(.45,.56,1.);\nconst vec3  SUN_VECTOR    = vec3(0.57735026919);\nconst vec3  SUN_COLOR     = vec3(1.);\nconst float SUN_SIZE      = 0.0002;\nconst float SUN_INTENSITY = 1.;\n\n//Camera\nconst float ZOOM                    = 0.25;\nconst float MOVEMENT_SPEED          = 10.;\nconst vec3  CAMERA_LOOK             = vec3(1.,0.,0);\nconst vec3  CAMERA_POSITION         = vec3(3,1.5,-2);\nconst float CAMERA_SENSITIVITY      = 0.003;\nconst float CAMERA_ROLL_SENSITIVITY = 1.;\n\n//Occlusion\nconst float OCCLUSION_SPREAD    = .5;\nconst float OCCLUSION_INTENSITY = .2;\nconst int   OCCLUSION_SAMPLES   = 3;\n\n//AA\nconst int  AA  = 1;\n\n//Post\nconst float GAMMA          = 2.2;\nconst float VIGNETTE_START = 1.;\nconst float VIGNETTE_END   = 3.;\n\n//rotates vector around another\nvec3 rotate(vec3 p, float angle, vec3 v){\n\tfloat c = cos(angle);\n\tvec3 s = sin(angle) * v;\n\tvec3 d =  (1.0 - c) * v;\n    return dot(p,d)*v + p*mat3(c,-s.z,s.y, s.z,c,-s.x, -s.y,s.x,c);\n}\n\n//Palette Creator\nvec3 getPaletteColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(TAU*(c*t+d) );\n}\n\n\n//hashing\nvoid hash( inout uint n ) {\n    \n    n += ( n << 10u );\n    n ^= ( n >>  6u );\n    n += ( n <<  3u );\n    n ^= ( n >> 11u );\n    n += ( n << 15u );\n}\n\n//gives a random float in range [0,1]\nfloat rand( inout uint n ){\n    hash(n);\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat distanceDonut(vec3 p, float r1, float r2){\n    return distance(vec2(length(p.xz),p.y),vec2(r1,0))-r2;\n}\n\nvoid rotate(inout vec2 p, float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nstruct info {\n\tfloat d;\n    vec3  c;\n};\n    \ninfo unionInfo(info a, info b){\n    if(a.d<b.d) return a;\n    return b;\n}\n\ninfo intersectionInfo(info a, info b){\n    if(a.d<b.d) return b;\n    return a;\n}\n\ninfo complementInfo(info a){\n    a.d *= -1.;\n    return a;\n}\n\ninfo subtractInfo(info a, info b){\n    return intersectionInfo(a, complementInfo(b));\n}\n\ninfo floor1(vec3 p){\n    float d = p.y;\n    vec3 c = vec3(.4);\n    d += dot(cos(p.xz*100.), vec2(.002));\n\treturn info(d, c);   \n}\n\ninfo floor2(vec3 p){\n    return info(p.y+cos(p.z*100.)*0.002, vec3(.9,.9,.5));\n}\n\ninfo track(vec3 p){\n    float d = 1e20;\n    \n    if(p.z + p.x < 0.) p.xz *= -1.;\n    d = min(d, distanceDonut(p-vec3(.5, 0, .5), .5, .11));\n\n  \treturn info(d, vec3(.2));\n}\n\ninfo plate(vec3 p){\n    \n    info I = subtractInfo(floor1(p), track(p));\n    I.d = max(I.d, length(p)-.5);\n    \n\treturn I;\n}\n\ninfo fill(vec3 p){\n    info I = floor2(p);\n    I.d = max(I.d, .52 - length(p));\n    \n    return I;\n}\n\ninfo ball(vec3 p){\n    float d = length(p)-.1;\n    vec3 c = vec3(.6, .3, .3);\n    c.r += cos(p.x*150.)*.2;\n    return info(d, c);\n}\n\ninfo ball1(vec3 p, float a){\n    p.xz -= .5;\n    rotate(p.xz, a + PI*.5);\n    p.z += .5;\n    rotate(p.xy, -a*4.);\n    return ball(p);;\n}\n\ninfo ball2(vec3 p, float a){ \n    p.xz -= .5;\n    rotate(p.xz, -a);\n    p.z += .5;\n    rotate(p.xy, a*4.);\n    \n    return ball(p);\n}\n\ninfo balls(vec3 p, float a){\n    if(p.z + p.x < 0.) p.xz *= -1.;\n    info I = unionInfo(ball1(p,a), ball2(p,a));\n    I.d = max(I.d, length(p)-.6);\n    return I;\n}\n\ninfo base(vec3 p){\n    vec2 i = floor(p.xz);\n    bool b = mod(i.x + i.y,2.) == 0.;\n    \n    float t = iTime*.05;\n    t = mod(t,1.);\n    \n    p.xz = fract(p.xz)-.5;\n    \n    info I = fill(p);\n\n    if(b){\n        rotate(p.xz, (clamp(t, 0.00, 0.10)-0.00)/0.10*TAU*.25 );\n        rotate(p.xz, (clamp(t, 0.50, 0.60)-0.50)/0.10*TAU*.25 );\n    }else{\n        rotate(p.xz, (clamp(t, 0.25, 0.35)-0.25)/0.10*TAU*.25 );\n        rotate(p.xz, (clamp(t, 0.75, 0.85)-0.75)/0.10*TAU*.25 );\n    }    \n    \n    I = unionInfo(I, plate(p));\n \n    float a = (t+0.1)*TAU;\n    if(b) a*= -1.;\n    \n    \n    I = unionInfo(I, balls(p, a));\n    \n    return I;\n}\n\nconst float SCALE = 2.25;\ninfo hypno(vec3 p){\n\n    //log polar transformation\n    float r = length(p.xz);\n    p.xz = vec2(log(r), atan(p.z, p.x) / TAU * 6.22);\n    p.y /= r;\n    \n    p *= SCALE;\n    \n    //zoom and rotate animation\n    p.xz += iTime*vec2(-.2, -.1);\n    \n    //small rotate so the grid ligns up in a specific way.\n    //rotate(p.xz, PI*.25);\n    \n    info I = base(p);\n   \n    I.d *= r / SCALE * .8;\n    \n    return I;\n}\n\ninfo scene(vec3 p){\n    info I = info(MAX_MARCH, vec3(1,0,0));\n\n    I = unionInfo(I, hypno(p));\n    \n    return I;\n}\n\nvec3 getSkyColor(vec3 dir){\n    vec3 d = dir-SUN_VECTOR;\n    return SKY_COLOR + SUN_COLOR*min(SUN_SIZE/dot(d,d),SUN_INTENSITY);\n}\n\n\nstruct marchInfo{\n\tint hit; // -1 is no hit, 1 is a hit, 0 if indeterminate\n    int  steps; //steps taken\n    float t; //distance travelled\n    float mdis; //minimum distance recorded\n    float mangle; //minimum \"angle\" recorded, actual angle is asin(mangle)  \n};\n\nmarchInfo raymarch(vec3  ori, vec3  dir, float eps){\n    int hit = 0;\n    int  steps = 0;\n    float t = 0.;\n    float mdis = MAX_MARCH;\n    float mangle = 1e20;\n    \n    for(;steps<MAX_STEPS; steps++){\n        if(t > MAX_MARCH){hit = -1; break;}\n        float dis = scene(ori + dir*t).d;\n        mdis = min(mdis, dis);\n        mangle = min(mangle, dis/t);\n        if(dis<t*eps){hit = 1; break;} \n        t += dis;\n    } \n    \n    return marchInfo(hit, steps, t, mdis, mangle);\n}\n\nvec3 sceneNormal(vec3 p, float eps){\n    eps = max(eps, 1e-8);\n    vec2 k = vec2(1,-1);\n    vec2 d = k*eps;\n    return normalize( k.xyy*scene( p + d.xyy ).d + \n                      k.yyx*scene( p + d.yyx ).d + \n                      k.yxy*scene( p + d.yxy ).d + \n                      k.xxx*scene( p + d.xxx ).d );\n}\n\nfloat sceneShadow(vec3 p, float eps){\n    marchInfo info = raymarch(p, SUN_VECTOR, eps); \n    return float(info.hit == -1) * clamp(info.mangle/SUN_SIZE*.01, 0., 1.) ;\n}\n\nfloat sceneOcclusion(vec3 p, vec3 n){\n    float o = 1.;\n    float s = OCCLUSION_SPREAD;               \n    float k = OCCLUSION_INTENSITY;  \n    float d = s;           \n\n    for (int i = 0; i < OCCLUSION_SAMPLES; ++i) {\n        o -= (d - scene(p + n * d).d) * k;\n        d += s;\n        k *= 0.5;\n    }\n    \n    return o;\n}\n\nvec3 raymarcher(vec3 ori, vec3 dir, float eps){ \n    marchInfo info = raymarch(ori, dir, eps);\n\n    vec3 col = vec3(1,0,0);//Full red for debugging\n    if(info.hit == 1){\n        vec3 hitPos = ori + dir*info.t;\n        vec3 hitColor = scene(hitPos).c;\n        vec3 hitNormal = sceneNormal(hitPos, info.t*eps);\n        vec3 reflectDir = reflect(dir, hitNormal);\n\n        float diffuse = max(dot(hitNormal,SUN_VECTOR),0.);\n        float shadow = diffuse>0. ? sceneShadow(hitPos, eps) : 0.;\n        float occlusion = sceneOcclusion(hitPos, hitNormal);\n        float specular = pow(max(dot(reflectDir,SUN_VECTOR),0.),32.)*.3;\n\n        \n        col = hitColor*occlusion*SKY_COLOR + hitColor*diffuse*shadow*SUN_COLOR + specular*shadow*SUN_COLOR;\n\n    }else{\n        col = getSkyColor(dir);\n\n    }\n    \n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    float minResolution = min(iResolution.x,iResolution.y);\n    float eps = DETAIL*ZOOM/minResolution;\n    \n    //camera\n    vec3 cameraPosition = texelFetch(iChannel1,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel1,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel1,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel1,ivec2(3,0),0).rgb;\n    \n    for(int dx=0; dx<AA; dx++){\n        for(int dy=0; dy<AA; dy++){\n            //Scaling\n            vec2 p = fragCoord + vec2(dx, dy)/float(AA);\n            vec2 sp  = (p*2.-iResolution.xy)/minResolution*ZOOM;\n\n            //Pixel Ray\n            vec3 direction = normalize(cameraForward+sp.x*cameraRight+sp.y*cameraUpward);\n\n            //Final\n            vec3 newSample = raymarcher(\n                cameraPosition,\n                direction,\n                eps\n            );  \n\n            fragColor += vec4(newSample, 1.);\n        }\n    }\n\n    fragColor /= float(AA*AA);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This buffer handles the Camera\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\n//makes sure that three 3 dimensional vectors are orthonormal\nvoid GramSchmidt33(inout vec3 a, inout vec3 b, inout vec3 c){\n    a = normalize(a);\n    b = b - dot(b,a)*a;\n    b = normalize(b);\n    c = c - dot(c,a)*a - dot(c,b)*b;\n    c = normalize(c);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 na =  c*a + s*b;\n    vec3 nb = -s*a + c*b;\n    a = na;\n    b = nb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>4 || p.y > 0) return;\n    \n    vec3 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    vec3 mouseOld       = texelFetch(iChannel0,ivec2(4,0),0).rgb;\n    \n    if(iFrame==0){\n        cameraPosition  = CAMERA_POSITION;\n        cameraForward   = normalize(CAMERA_LOOK-cameraPosition);\n        cameraRight     = normalize(cross(vec3( 0, 1, 0),cameraForward));\n        cameraUpward    = normalize(cross(cameraForward,cameraRight));\n        mouseOld        = vec3(iMouse.xy, 0);\n    } \t\t\n    \n    bool forward     = texelFetch(iChannel1,ivec2(87,0),0).x + texelFetch(iChannel1,ivec2(38,0),0).x >0.;\n    bool left        = texelFetch(iChannel1,ivec2(65,0),0).x + texelFetch(iChannel1,ivec2(37,0),0).x >0.;\n    bool backward    = texelFetch(iChannel1,ivec2(83,0),0).x + texelFetch(iChannel1,ivec2(40,0),0).x >0.;\n    bool right       = texelFetch(iChannel1,ivec2(68,0),0).x + texelFetch(iChannel1,ivec2(39,0),0).x >0.;\n    bool rollleft    = texelFetch(iChannel1,ivec2(81,0),0).x > 0.;\n    bool rollright   = texelFetch(iChannel1,ivec2(69,0),0).x > 0.;\n    bool down        = texelFetch(iChannel1,ivec2(16,0),0).x + texelFetch(iChannel1,ivec2(34,0),0).x > 0.;\n    bool up          = texelFetch(iChannel1,ivec2(32,0),0).x + texelFetch(iChannel1,ivec2(33,0),0).x > 0.;\n    bool mouseLeft   = iMouse.z>0.;\n    bool interaction = forward||left||backward||right||rollleft||rollright||down||up||mouseLeft;\n    \n    float stepSize = MOVEMENT_SPEED*iTimeDelta*ZOOM;\n    \n    //Translation\n    cameraPosition += (cameraForward*(float(forward) - float(backward)) +\n        \t\t       cameraRight  *(float(right)   - float(left)    ) +\n        \t           cameraUpward *(float(up)      - float(down)    )\n                      )*stepSize;\n    \n    //Roll\n    float r = (float(rollleft)-float(rollright))*iTimeDelta*CAMERA_ROLL_SENSITIVITY;\n    rot(cameraRight, cameraUpward , r);\n    \n    //Pitch & Yaw\n    if(mouseLeft){\n        if(mouseOld.z==0.){\n            mouseOld.xy = iMouse.zw;\n            mouseOld.z = 1.;\n        }\n\t\tvec2 s = iMouse.xy-mouseOld.xy;\n        rot(cameraForward, cameraUpward, s.y*CAMERA_SENSITIVITY);\n        rot(cameraForward, cameraRight , s.x*CAMERA_SENSITIVITY);\n    }else{\n    \tmouseOld.z = 0.;   \n    }\n    \n    GramSchmidt33(cameraForward, cameraUpward, cameraRight);\n    \n    if(p.x==0){\n    \tfragColor.rgb = cameraPosition;\n    }else if(p.x==1){\n        fragColor.rgb = cameraForward;\n    }else if(p.x==2){\n        fragColor.rgb = cameraRight;\n    }else if(p.x==3){\n        fragColor.rgb = cameraUpward;\n    }else if(p.x==4){\n        fragColor.rgb = vec3(iMouse.xy, mouseOld.z);\n    }\n    \n    fragColor.w = float(interaction);\n}","name":"Buffer B","description":"","type":"buffer"}]}