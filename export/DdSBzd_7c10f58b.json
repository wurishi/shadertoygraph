{"ver":"0.1","info":{"id":"DdSBzd","date":"1691638949","viewed":77,"name":"Ball over checkered field","username":"WalrusesAreAwesome","description":"Classic shader image","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["basic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct HitInfo {\n    bool didHit;\n    float dst;\n    vec3 hitPoint;\n    vec3 normal;\n};\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    vec3 color;\n    float reflectivity;\n    float specularity;\n};\n\nHitInfo RaySphere(Ray ray, Sphere sphere) {\n    HitInfo hitInfo;\n    // Thank you to Sebastian Lague for replacing linear algebra (for now) https://www.youtube.com/watch?v=Qz0KTGYJtUk\n    vec3 offsetPos = ray.pos - sphere.pos;\n    \n    float b = dot(offsetPos, ray.dir);\n    float c = dot(offsetPos, offsetPos) - sphere.radius * sphere.radius;\n\n    float discriminant = b * b - c;\n\n    if (discriminant >= 0.0) {\n        float dst = -b - sqrt(discriminant);\n        \n        if (dst > 0.0) {\n            hitInfo.didHit = true;\n            hitInfo.dst = dst;\n            hitInfo.hitPoint = ray.pos + ray.dir*dst;\n            hitInfo.normal = normalize(hitInfo.hitPoint - sphere.pos);\n        }\n    }\n    return hitInfo;\n}\n\nvec2 getFloorPoint(vec3 pos, vec3 ray) {\n    ray *= pos.y/ray.y; // get the ray to travel the height of the cam\n    return vec2(pos.xz - ray.xz); // subtract it from the height\n}\n\nfloat customLength(vec3 A) {\n    return sqrt(A.x + A.y + A.z); // manhatten distance\n}\n\nvec3 getTileColor(vec2 point) {\n    vec2 tileCoord = floor(point / 5.0);\n    float tileParity = mod(tileCoord.x + tileCoord.y, 2.0);\n    vec3 color = vec3(0.0);\n    \n    if (tileParity == 1.0) {\n        //return vec3(1.0);\n        color = vec3(0.75, 0.75, 0.0);\n    } else {\n        color = vec3(0.75, 0.0, 0.0);\n    }\n    \n    vec3 sunPos = vec3(-100.0, 200.0, -10.0);\n    \n    vec3 floorPos = vec3(point.x, 0.0, point.y);\n    vec3 toSunRay = sunPos - floorPos;\n    toSunRay /= length(toSunRay);\n    vec3 spherePos = vec3(0.0, 6.0 + sin(iTime) - sin(iTime), 20.0);\n    float sphereRadius = 2.0;\n    HitInfo hitInfo = RaySphere( Ray(floorPos, toSunRay), Sphere(spherePos, sphereRadius, vec3(0.0), 0.0, 0.0) );\n    \n    if (hitInfo.didHit) {\n        color /= 2.0;\n    }\n    \n    return color;\n}\n\nvec3 sphereColor(Ray ray, Sphere sphere, HitInfo hitInfo) {\n    vec3 color;\n    vec3 skyColor = vec3(0.5, 0.5, 1.0);\n    vec3 sunPos = vec3(-100.0, 200.0, -10.0);\n    \n    vec3 sphereRay = ray.dir - (dot(hitInfo.normal, ray.dir) * 2.0 * hitInfo.normal); // already normalized\n\n    color += sphere.color * (1.0 - sphere.reflectivity); // add sphere color\n\n    if (sphereRay.y > -0.1) { // if hit sky\n        color += skyColor * sphere.reflectivity; // half color sky\n    } else { // if hit floor\n        vec2 floorPoint = getFloorPoint(hitInfo.hitPoint, sphereRay);\n        color += getTileColor(floorPoint) * sphere.reflectivity; // half color floor\n    }\n\n    vec3 sphereToSun = sunPos - hitInfo.hitPoint; // calculate sun vector\n    sphereToSun /= length(sphereToSun);\n\n    // diffuse lighting\n    float light = smoothstep(-1.0, 1.0, dot(hitInfo.normal, sphereToSun) / 2.0 + 0.5);\n    color *= vec3(light);\n\n    // specular lighting\n    vec3 sphereToView = -ray.dir;\n    vec3 halfRay = sphereToSun + sphereToView;\n    halfRay /= length(halfRay);\n    float specular = max(dot(halfRay, hitInfo.normal), 0.0);\n    color += vec3(pow(specular, sphere.specularity)); // make sure negative doesn't add after squaring\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.141592;\n    float FOV_X = 135.0 / 2.0 / 3.0;\n    float FOV_Y = 135.0 / 2.0 / 3.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // square shader only yippee\n    if (abs(uv.x) < 1.0) {\n        vec3 fragColor3 = vec3(0.0);\n        \n        vec3 skyColor = vec3(0.5, 0.5, 1.0);\n        vec3 sunPos = vec3(-100.0, 200.0, -10.0);\n        vec3 white = vec3(1.0);\n        vec3 black = vec3(0.0);\n        bool hitSphere = false;\n        \n        Sphere ball = Sphere( vec3(0.0, 6.0, 20.0), 2.0, vec3(0.95, 0.3, 0.75), 0.5, 20.0 );\n        Ray ray;\n        \n        float pitch = 0.0;\n        float yaw = 0.0;\n        \n        vec3 X = vec3(1.0, 0.0, 0.0);\n        vec3 Y = vec3(0.0, 1.0, 0.0);\n        vec3 Z = vec3(0.0, 0.0, 1.0);\n        \n        float boxSize = 20.0;\n        \n        vec3 vrb = vec3(boxSize*uv, 40.0); // viewRayBasis\n        vrb /= length(vrb);\n        \n        pitch *= PI/180.0;\n        yaw *= PI/180.0;\n        vec3 viewRay = vec3( vrb.x*cos(yaw)+vrb.z*sin(yaw), 0.0, vrb.x*-sin(yaw)+vrb.z*cos(yaw)*cos(pitch) ); // do the math it works\n        viewRay += vec3( 0.0, vrb.y*cos(pitch)+vrb.z*sin(pitch), vrb.y*-sin(pitch) );\n        viewRay /= length(viewRay);\n        \n        vec3 viewPos = vec3(20.0 * sin(iTime / 2.0), 6.0, -20.0 * cos(iTime / 2.0) + 20.0);\n        \n\t\tviewPos = vec3(0.0, 6.0, 0.0); // comment out these lines for spin     \n        \n        ray.dir = viewRay;\n        ray.pos = viewPos;\n        \n        HitInfo hitInfo = RaySphere(ray, ball);\n        \n        if (hitInfo.didHit) {\n            fragColor3 = sphereColor(ray, ball, hitInfo);\n        } else {\n            if ( (viewRay.y >= -0.03) ) {\n                fragColor3 += skyColor;\n            } else {\n\n                vec2 floorPoint = getFloorPoint(viewPos, viewRay);\n                fragColor3 += getTileColor(floorPoint);\n\n            }\n        }\n        \n        fragColor = vec4(fragColor3, 1.0);\n        \n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}