{"ver":"0.1","info":{"id":"3lXcRB","date":"1592390063","viewed":51,"name":"Satellite Round","username":"winsons","description":"simulate satellite round master star","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["practise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera\n{\n\tvec3 origin;\n    vec3 target;\n    vec3 up;\n    float vfov;\n    float aspect_ratio;\n    float focal_length;\n};\n\nmat4 getViewMatrix(Camera cam)\n{\n    vec3 forward = normalize(cam.target - cam.origin);\n    vec3 right = normalize(cross(forward, cam.up));\n    vec3 up = normalize(cross(right, forward));\n    return mat4(\n        vec4(right, .0),\n        vec4(up, .0),\n        vec4(forward, .0),\n        vec4(cam.origin.x, cam.origin.y, cam.origin.z, 1.0)\n    );\n}\n\nvec3 getRay(vec2 uv, Camera cam)\n{\n    float half_height = cam.focal_length * tan(radians(cam.vfov / 2.0));\n    float half_width = half_height * cam.aspect_ratio;\n    vec3 left_bottom = vec3(-half_width, -half_height, cam.focal_length);\n    vec4 point = vec4(left_bottom + vec3(2.0 * half_width, .0, .0) * uv.x + vec3(.0, 2.0 * half_height, .0) * uv.y, 1.0);\n    point = getViewMatrix(cam) * point;\n    return normalize(point.xyz - cam.origin);\n}\n\nfloat sphereSDF(vec3 point, vec3 center, float radius, vec3 round_dir, vec3 round_radius)\n{\n    return length(point - center - round_radius * round_dir) - radius;\n}\n\nfloat mainStarSDF(vec3 point)\n{\n    return sphereSDF(point, vec3(.0, .0, 1.0), 1.0, vec3(.0), vec3(.0));\n}\n\nfloat roundStarSDF(vec3 point)\n{\n    return sphereSDF(point, vec3(.0, .0, 1.0), .3, vec3(sin(iTime), cos(iTime), cos(iTime)), vec3(1.5, 1.0, 1.5));\n}\n\nint getStarType(vec3 point)\n{\n    if (roundStarSDF(point) < mainStarSDF(point))\n    {\n        return 1;\n    }\n    return 2;\n}\n\nvec3 getMainStarColor(vec3 point)\n{\n    float distance = point.y + .3;\n    float bar_count = 7.0;\n    float bar_height = .3 / bar_count;\n    if ( mod(distance / bar_height, 2.0) < 1.0 )\n    {\n        return vec3(.8, .6, .6);\n    }\n    return vec3(.8, .8, .8);\n}\n\nfloat sceneSDF(vec3 point)\n{\n    return min(mainStarSDF(point), roundStarSDF(point));\n}\n\nvec3 getNormal(vec3 p)\n{\n\treturn normalize(vec3(sceneSDF(vec3(p.x+0.0001,p.y,p.z)) -sceneSDF(vec3(p.x-0.0001,p.y,p.z)),\n                               sceneSDF(vec3(p.x,p.y+0.0001,p.z)) -sceneSDF(vec3(p.x,p.y-0.0001,p.z)),\n                               sceneSDF(vec3(p.x,p.y,p.z+0.0001)) -sceneSDF(vec3(p.x,p.y,p.z-0.0001))                 \n                              ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // render sky\n    //fragColor.xyz = mix(vec3(55.0,87.0,99.0)/225.0,vec3(121.0,249.0,255.0)/225.0,uv.y );\n    fragColor.xyz = mix(vec3(14.0,11.0,23.0)/225.0,vec3(74.0,71.0,73.0)/225.0,uv.y );\n    \n    Camera cam;\n    cam.origin = vec3(.0, .0, -5.0);\n    cam.target = vec3(.0, .0, .0);\n    cam.up = vec3(.0, 1.0, .0);\n    cam.vfov = 45.0;\n    cam.aspect_ratio = iResolution.x / iResolution.y;\n    cam.focal_length = 1.0;\n    \n    vec3 point = cam.origin;\n    vec3 ray = getRay(uv, cam);\n    for (int i = 0; i < 250; ++i)\n    {\n        float distance_to_sphere = sceneSDF(point);\n        if (distance_to_sphere < 0.00001)\n        {\n            vec3 light_pos = vec3(4.0, 5.0, -5.0);\n            \n            vec3 light_color = vec3(1.0, 1.0, 1.0);\n            vec3 ambient_color = vec3(.0, .0, .0);\n            vec3 albedo_color;\n            vec3 specular_color = vec3(.0, .8, .0);\n            float specular_gloss = 100.0;\n            \n            if (getStarType(point) == 1)\n            {\n                albedo_color = vec3(.9, .9, .9);\n            }\n            else\n            {\n                albedo_color = getMainStarColor(point);\n            }\n            \n            vec3 world_normal = getNormal(point);\n            vec3 world_light_dir = normalize(light_pos);\n            vec3 world_view_dir = normalize(cam.origin - point);\n            vec3 specular_h_dir = normalize(world_light_dir + world_view_dir);\n            \n            vec3 ambient = ambient_color;\n            vec3 diffuse = light_color * albedo_color * max(dot(world_normal, world_light_dir), 0.0);\n            vec3 specular = light_color * specular_color * pow(max(dot(world_normal, specular_h_dir), .0), specular_gloss);\n            fragColor = vec4(ambient + diffuse + specular, 1.0);\n            return;\n        }\n        point = point + ray * distance_to_sphere;\n    }\n    \n    // Output to screen\n    \n}","name":"Image","description":"","type":"image"}]}