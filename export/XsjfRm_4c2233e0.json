{"ver":"0.1","info":{"id":"XsjfRm","date":"1499925861","viewed":303,"name":"2D vector field 1","username":"etale_cohomology","description":"Fork of https://www.shadertoy.com/view/XlfSRj by nmz (twitter: @stormoid)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["math","visualization","field","vector","equation","arrow","differential","manifold","calculus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/XlfSRj by nmz (twitter: @stormoid)\n// A visualizer for 2D vector fields, originally by nmz\n// Default field: a gentle vortex vector field  https://en.wikipedia.org/wiki/One-form#Differential\n// The color is the norm field of the vector field, using iq's cosine palette function, although\n// the length of each arrow is also intended to represent the norm of the vector at that point!\n\n#define arrow_density  8.\n#define arrow_length   .3\n#define arrow_thinness 100.\n#define arrow_head .5\n#define arrow_openness .2\n#define time -.1 * iTime\n\n//---------------Field to visualize defined here-----------------\nvec2 field(in vec2 p){\n  return vec2(-p.y, p.x);\n  //return vec2(-p.y / dot(p,p), p.x / dot(p,p));  // THIS is the true vortex vector field!\n}\n\n//-------------------------------------------------------------\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){  // from iq\n  return a + b*cos( 6.28318 * (c*t + d));\n}\n\nfloat segm(in vec2 p, in vec2 a, in vec2 b){  // from iq\n  vec2 ap = p - a;\n  vec2 ab = b - a;\n  float projection_factor = clamp(dot(ap,ab) / dot(ab,ab), 0., 1.);\n  vec2 ap_proj_ab = ab * projection_factor;\n  return length(ap - ap_proj_ab) * arrow_thinness;\n}\n\nfloat draw_arrows(in vec2 p){\n  vec2 ip = floor(p * arrow_density) / arrow_density + .5 / arrow_density;   \n  vec2 field_image = field(ip);\n  float norm = length(field_image) * (arrow_length / arrow_density);\n\n  vec2 b = normalize(field_image) * norm;\n  vec2 prp = vec2(-b.y, b.x);\n\n  float rz = segm(p, ip, ip+b);\n  rz = min(rz, segm(p, ip + b, ip + b * arrow_head + prp * arrow_openness));\n  rz = min(rz, segm(p, ip + b, ip + b * arrow_head - prp * arrow_openness));\n  return rz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  //vec2 p = fragCoord.xy / iResolution.xy;\n  //p = 2. * (p + -.5);\n  //p.x *= iResolution.x / iResolution.y;\n  vec2 p = 2. * (fragCoord + -.5*iResolution.xy) / iResolution.y;  // The Fabrice map!\n\n  p = vec2(cos(time)*p.x - sin(time)*p.y, sin(time)*p.x + cos(time)*p.y);  // Rotation: multiplication of `p` by a unit complex number (cos(time), sin(time))\n\n  vec2 field_image = field(p);\n  vec3 norm_field = palette(.4 * length(field_image), vec3(.5, .5, .5), vec3(.5, .5, .5), vec3(1., 1., 1.), vec3(.00, .33, .67));  // iq's palette function <3\n  float arrow = draw_arrows(p);\n  vec3 rgb = max(1. - norm_field, 1. - arrow);\n  \n  fragColor.rgb = rgb;\n}\n","name":"Image","description":"","type":"image"}]}