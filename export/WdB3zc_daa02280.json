{"ver":"0.1","info":{"id":"WdB3zc","date":"1549475864","viewed":285,"name":"Voronoi Island","username":"willstall","description":"I absolute adore topography and procedural generation. This is my very first attempt at an island by breaking down voronoi spaces.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","voronoi","sdf","topography"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tWill Stallwood\n\thttps://www.instagram.com/willstall/\n\n*/\n\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random( in vec2 st )\n{\n\treturn fract( sin( dot(st.xy, vec2(-30.950,-10.810) )) * 43758.5453123  );\t    \n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rotate(float angle)\n{\n    return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );\n}\n\nvec2 center(vec2 st)\n{\n    float aspect = iResolution.x/iResolution.y;\n    st.x = st.x * aspect - aspect * 0.5 + 0.5;\n    return st;\n}\n\nfloat sdf_iso_lines(float sdf,float amt,float size, float ratio)\n{\n    // float amt = 0.02;\n    // float size = 0.01;\n    float half_amt = amt * .5;\n\n    float minor = abs(fract(sdf/amt + 0.5)-0.5)*1.0;\n    float major = abs(fract(sdf/(amt*ratio) + 0.5)-0.5)*1.0;\n\n    minor = smoothstep(half_amt-size,half_amt+size,minor);\n    major = smoothstep(half_amt-size,half_amt+size,major);\n\n    float t = major*minor;\n    return t;    \n}\n\n// iq\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // config\n    float scale = 3.0;\n    float t = iTime/30.0 * 5.0;        // code works but is off by 1.0, this is a 6 second animation\n\n    //vec2 st = gl_FragCoord.xy / u_resolution.xy;\n    vec2 st = fragCoord/iResolution.xy;\n    st = center( st );\n\n    vec2 origin_st = st;\n\n    // modulate\n    float r = noise(vec2(st.x+t, st.y));\n\n    float offset = 0.07;\n    vec2 pos = vec2(0.5);\n        pos.x += offset * sin(TWO_PI*t);\n        pos.y += offset * cos(TWO_PI*t);\n\n    st.x += offset * sin(TWO_PI*t);\n    st.y += offset * cos(TWO_PI*t);\n\n    \n    \n    // sdf\n    float c = 1.0 - length(origin_st-pos);\n    c -= .70;\n\n    float d = 1.0;\n    d = c;\n\n    // voronoi\n    vec2 sSt = st * scale * scale;\n    vec2 iSt = floor(sSt);\n    vec2 fSt = fract(sSt);\n    vec2 seed = vec2(31.00,1.0);    \n    vec2 p;\n\n    // get sdf based on neighbors\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            vec2 offset = vec2(x,y);            \n            vec2 point = random2(iSt+offset+seed);\n            float diff = length(fSt-point-offset)*d;\n\n            if(d > diff)\n            {\n                d = diff;\n                p = point;\n            }\n        }\n    }\n\n    // shade island\n    float outside =  smoothstep(0.062,0.063,d+.04);\n    float z = 1.0;\n    \n    z = sdf_iso_lines(d,pow(d,1.3),0.4,0.25);  // get isolines\n    z = smoothstep(0.50,0.56,z);    // refine islines\n    z = outside * smoothstep(0.0,1.0,z);   // remove outside\n    z += 1.0-outside;   // remove holes\n\n    float shade = max(c,1.0-outside);\n\n    // color\n    vec3 color = vec3(0.04);\n    color = mix( color, vec3(1.0),1.0-z);\n\n    // vignette\n    c = length(origin_st-0.5);\n    color += (vec3(-0.18)*c*random(origin_st)*.5+.1);\n\t\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}