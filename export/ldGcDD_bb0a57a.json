{"ver":"0.1","info":{"id":"ldGcDD","date":"1522019588","viewed":118,"name":" One To Rule Them All altered","username":"chrisjj","description":"\"One To Rule Them All\" by revers https://www.shadertoy.com/view/4tlSz4 with texture 1 changed for greater rune legibility.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Created by Kamil Kolaczynski (revers) - 2015\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader uses code written by: \n * - iq (intersection routines, raymarching)\n * - otaviogood (runes, https://www.shadertoy.com/view/MsXSRn)\n * - Dave_Hoskins (postprocessing, https://www.shadertoy.com/view/XsfGzH)\n * Thanks for sharing it guys!\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n *\n * Changelog:\n *   2015-08-09 - added glow\n *\n */\n\n#define ANTI_ALIASING\n\nconst float MarchDumping = 1.0;\nconst float Far = 30.0;\nconst int MaxSteps = 84;\nconst float FOV = 0.4;\nconst vec2 TorusSize = vec2(0.35254, 0.03376);\nconst float TorusHeightFactor = 0.505;\nconst float Contrast = 1.0009999;\nconst float Saturation = 1.2815001;\nconst float Brightness = 1.03;\n\n#define MAT_NONE -1.0\n#define MAT_GOLD 1.0\n\nfloat GlowFactor = 0.0;\n\nfloat sdTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nvec2 map(vec3 p) {\n\tp.y *= TorusHeightFactor;\n\n\treturn vec2(sdTorus(p, TorusSize), MAT_GOLD);\n}\n\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.1;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.0005;\n\tfloat t = tmin;\n\tfloat m = MAT_NONE;\n\n\tfloat dither = 0.5;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\n\t\tif (i == 0) {\n\t\t\tres.x *= (dither * rand(rd.xy)) + (1.0 - dither);\n\t\t}\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\n\t\tif (m == MAT_GOLD && res.x < 0.5) {\n\t\t\tGlowFactor += 0.005;\n\t\t}\n\t}\n\n\tif (t > tmax) {\n\t\tm = MAT_NONE;\n\t}\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nvec3 getBackground(vec3 ro, vec3 rd) {\n\treturn texture(iChannel1, rd).rgb;\n}\n\n/**\n * Makes a thick line and passes back gray in x and derivates for lighting in yz.\n * @author Otavio Good\n */\nvec3 ThickLine(vec2 uv, vec2 posA, vec2 posB, float radiusInv) {\n\tvec2 dir = posA - posB;\n\tfloat dirLen = length(dir);\n\tvec2 dirN = dir / dirLen;\n\n\tfloat dotTemp = clamp(dot(uv - posB, dirN), 0.0, dirLen);\n\tvec2 proj = dotTemp * dirN + posB;\n\tfloat d1 = distance(uv, proj);\n\tvec2 derivative = (uv - proj);\n\n\tfloat finalGray = clamp(1.0 - d1 * radiusInv, 0.0, 1.0);\n\t// multiply derivative by gray so it smoothly fades out at the edges.\n\treturn vec3(finalGray, derivative * finalGray);\n}\n\n/**\n * Makes a rune in the 0..1 uv space. Seed is which rune to draw.\n * Passes back gray in x and derivates for lighting in yz\n * @author Otavio Good\n */\nvec3 Rune(vec2 uv, vec2 seed) {\n\tvec3 finalLine = vec3(0.0, 0.0, 0.0);\n\n\t// number of strokes\n\tfor (int i = 0; i < 4; i++) {\n\t\t// generate seeded random line endPoints - just about any texture_ should work.\n\t\tvec2 posA = texture(iChannel0,\n\t\t\t\tfloor(seed + 0.5) / iChannelResolution[0].xy).xy;\n\t\tvec2 posB = texture(iChannel0,\n\t\t\t\tfloor(seed + 1.5) / iChannelResolution[0].xy).xy;\n\n\t\tseed += 2.0;\n\t\t// expand the range and mod it to get a nicely distributed random number - hopefully. :)\n\t\tposA = fract(posA * 128.0);\n\t\tposB = fract(posB * 128.0);\n\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) {\n\t\t\tposA.y = 0.0;\n\t\t} else if (i == 1) {\n\t\t\tposA.x = 0.999;\n\t\t} else if (i == 2) {\n\t\t\tposA.x = 0.0;\n\t\t} else if (i == 3) {\n\t\t\tposA.y = 0.999;\n\t\t}\n\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec2 snaps = vec2(2.0, 3.0);\n\t\tposA = (floor(posA * snaps) + 0.5) / snaps + 0.1;\t// + 0.5 to center it in a grid cell\n\t\tposB = (floor(posB * snaps) + 0.5) / snaps;\n\t\t//if (distance(posA, posB) < 0.0001) continue;\t// eliminate dots.\n\n\t\t// Dots (degenerate lines) are not cross-GPU safe without adding 0.001 - divide by 0 error.\n\t\tvec3 tl = ThickLine(uv, posA, posB + 0.001, 10.0);\n\t\tif (tl.x > finalLine.x) {\n\t\t\tfinalLine = tl;\n\t\t}\n\t}\n\treturn finalLine.xyz;\n}\n\nvec3 getObjectColor(vec3 pos, vec3 n, float m) {\n\tvec3 col = vec3(1.0);\n\n\tvec2 uv = vec2(atan(pos.z, pos.x), pos.y);\n\n\tuv *= 16.0;\n\tuv.x *= 0.9;\n\tuv.y *= 0.85;\n\tuv.y += 1.55;\n\n\tvec2 newSeed = floor(uv);\n\tvec3 finalLine = Rune(fract(uv), newSeed - 0.41) * mod(newSeed.y, 2.0);\n\n\tfloat time = mod(iTime + 2.0, 14.0);\n\tfloat t = smoothstep(0.0, 2.0, time) * (1.0 - smoothstep(10.0, 12.0, time));\n\tfloat k = smoothstep(0.0, 6.0, time) * (1.0 - smoothstep(6.0, 12.0, time));\n\n\tvec3 runeColor = mix(vec3(0.0), vec3(1.9), k);\n\tcol = mix(col, runeColor, pow(finalLine.x, 0.55) * 0.97);\n\tcol *= (1.0 + clamp(-finalLine.z, 0.0, 1.0) * 128.0);\n\n\treturn mix(vec3(1.0), col, t);\n}\n\nvec3 fresnelSchlick(float cosT, vec3 F0) {\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosT, 5.0);\n}\n\nvec3 getBRDF(vec3 viewDir, vec3 hitNormal, vec3 hitPoint,\n\t\tfloat materialID) {\n\tvec3 refl = reflect(-viewDir, hitNormal);\n\tfloat cosT = max(dot(viewDir, hitNormal), 0.0);\n\tvec3 F0 = vec3(1.00, 0.71, 0.29);\n\tvec3 fresnel = fresnelSchlick(cosT, F0);\n\n\tvec3 tex = getObjectColor(hitPoint, hitNormal, materialID);\n\tvec3 bg = texture(iChannel1, refl).rgb;\n\treturn tex * bg * fresnel;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec2 res = raymarch(ro, rd);\n\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tif (m == MAT_NONE) {\n\t\tfloat time = mod(iTime + 2.0, 14.0);\n\t\tfloat tim = smoothstep(0.0, 6.0, time) * (1.0 - smoothstep(6.0, 12.0, time));\n\n\t\tvec3 glow = tim * pow(GlowFactor, 0.9) * vec3(1.0, 1.0, 0.549);\n\t\treturn getBackground(ro, rd) + glow;\n\t}\n\tvec3 p = ro + t * rd;\n\tvec3 normal = calcNormal(p);\n\n\tvec3 col = getBRDF(-rd, normal, p, m);\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\n/**\n * Postprocessing by Dave_Hoskins [https://www.shadertoy.com/view/XsfGzH]\n */\nvec3 doPostprocessing(vec3 col) {\n\tvec3 a = vec3(dot(vec3(0.2125, 0.7154, 0.0721), col * Brightness));\n\tcol = mix(vec3(0.5), mix(a, col * Brightness, Saturation), Contrast);\n\treturn col;\n}\n\nmat3 rotateY(float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn mat3(ca, 0.0, sa, 0.0, 1.0, 0.0, -sa, 0.0, ca);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 coord = 2.0 * q - 1.0;\n\tcoord.x *= iResolution.x / iResolution.y;\n\tcoord *= FOV;\n\n\tfloat t = iTime * 0.25;\n\tfloat st = sin(t);\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tfloat m = mouse.y;\n    if (m != 0.0) {\n    \tm = m * 2.0 - 1.0;\n    }\n\n    mat3 rot = rotateY(iTime * 3.141592 * 0.08);\n\tvec3 ro = vec3(0.0, 0.4 * st - m, 1.0) * rot;\n\n\tvec3 dir = normalize(-ro);\n\tvec3 up = normalize(vec3(0.2 * st, 1.0, 0.2 * cos(t)));\n\tvec3 upOrtho = normalize(up - dot(dir, up) * dir);\n\tvec3 right = normalize(cross(dir, upOrtho));\n\n#ifdef ANTI_ALIASING\n\tvec2 hps = vec2(1.0) / (iResolution.xy * 2.0);\n\tvec3 rd0 = normalize(dir + (coord.x - hps.x) * right + coord.y * upOrtho);\n\tvec3 rd1 = normalize(dir + (coord.x + hps.x) * right + coord.y * upOrtho);\n\tvec3 rd2 = normalize(dir + coord.x * right + (coord.y - hps.y) * upOrtho);\n\tvec3 rd3 = normalize(dir + coord.x * right + (coord.y + hps.y) * upOrtho);\n\n\tvec3 col = (render(ro, rd0) + render(ro, rd1) + render(ro, rd2) + render(ro, rd3)) / 4.0;\n#else\n\tvec3 rd = normalize(dir + coord.x * right + coord.y * upOrtho);\n\tvec3 col = render(ro, rd);\n#endif\n\n\tcol = doPostprocessing(col);\n\n\tcol = pow(col, vec3(0.4545));\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}