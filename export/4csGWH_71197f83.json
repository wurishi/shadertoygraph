{"ver":"0.1","info":{"id":"4csGWH","date":"1703015143","viewed":31,"name":"Lines/Circles/Rings/Halos","username":"KaleyGoode","description":"2D Geometry drawing method examples","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["line","circle","ring","goo","halo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A collection of simple rendering techniques from my head (so there are probably more formal methods)!\n\n#define    pi 3.14159265359\n#define   tau (2.*pi)\n#define  gold vec3(.9,.8,.4)\n#define black vec3(0)\n#define white vec3(1)\n\nfloat   Signed(float x)          {return 2.* x-1. ;} // Unsigned Unit Interval [ 0,1] to   Signed UI [-1,1]\nfloat Unsigned(float x)          {return .5*(x+1.);} //   Signed Unit Interval [-1,1] to Unsigned UI [ 0,1]\nfloat Lower   (float n, float t) {return clamp(n* t       ,0.,1.);} // if n=5, returns the lower fifth spread out to [0,1]\nfloat Upper   (float n, float t) {return clamp(n*(t-1.)+1.,0.,1.);} // t-(n-1)/n; if n=5, returns the upper fifth spread out to [0,1]\n\nfloat GetGreen(float t) {\n  t -= floor(t); // Use the fractional part of parameters that may infinitely cycle (like sine).\n       if(t<1./6.) return    6.*t; //        1 __\n  else if(t<3./6.) return 1.;      // Green: |/  \\__\n  else if(t<4./6.) return 4.-6.*t; //        0--t---1\n                   return 0.;\n}\nvec3 FromHue(float hue) { // hue [0,1] where 0=red\n  return vec3(GetGreen(hue+1./3.),\n              GetGreen(hue      ),\n              GetGreen(hue-1./3.));\n}\n\n// Values are unit intervals (relative to uv)\n// px is the current pixel coord (fragCoord)\n// p0,p1 are the start and end points of the line\nvoid line(inout vec3 color, in vec3 lineColor, in float alpha, in float blur,\n          in    vec2 p0   , in vec2 p1       , in vec2  px   , in float width, in bool goo) {\n  vec2  h = px-p0, // Vector from current pixel to line start point (hypotenuse)\n        a = p1-p0; // Direction vector along line (adjacent)\n  float t = clamp(dot(h,a)/dot(a,a), 0.,1.), // Parametric t along line segment [0,1]\n        d = length(h - t*a),         // Distance from current pixel to line (length of opposite)\n       dw = fwidth(d)*(1.+10.*blur); // Antialiasing width\n  if(goo && (length(a)>3.*width)) width *= 1.-2.*t*(1.-t);\n  color = mix(color, lineColor, alpha*(1.-smoothstep(width-dw, width+dw, d)));\n}\n\n//###################################################################################################################\nvoid mainImage(out vec4 o, in vec2 fragCoord) {\n  float rPx = .5*min(iResolution.x, iResolution.y); // Radius in pixels\n  vec2   uv = (fragCoord.xy-.5*iResolution.xy)/rPx,\n   position = vec2(.2);\n  float r = length(uv),\n        d = distance(uv,position);\n  vec3  color = black;\n\n// Objects are drawn back to front.\n\n//__Gold outer circle_________________________________________________________________________________________________\n// (note that it's lighter than the other gold objects because the halo drawn over the top lightens it)\n  float rOuter  = .9,\n     outerBlur  = 4.,\n     outerWidth = 1.,\n         tOuter = abs(d - abs(rOuter)) - outerWidth/rPx;\n  color = mix(gold, color, smoothstep(0., outerBlur/rPx, tOuter));\n\n//__White Halo________________________________________________________________________________________________________\n  float rHalo = .5,\n    haloWidth = 2.,\n        tHalo = abs(d - abs(rHalo)) - haloWidth/rPx;\n  color = mix(white, color, tHalo);\n\n/*__Cybertruck Wiper__________________________________________________________________________________________________\nThin line colour-changing line:\nWipe using p0,p1 for .5*pi\nAltering the x and y component signs for each corner could be done with a 2-bit count/state,\nhowever, the sin and cos signs coincide usefully with the x and y signs\n # binary corner:\n 0   00 = -x -y Bottom Left\n 1   01 = +x -y Bottom Right\n 2   10 = +x +y    Top Right\n 3   11 = -y +y    Top Left */\n  float a = 2.*iTime,\n        s = sin(a),\n        c = cos(a);\n  vec2 p0 = (vec2(10,10)-.5*iResolution.xy)/rPx, // mapping the pixel coord (10,10) to uv for the Line function\n       p1 = p0 + .98*iResolution.xy * vec2(abs(sin(a)),abs(cos(a)))/rPx; // Quarter circle wipe\n  bool dx = (c<0.), // Flags to select which corner to wipe from:\n       dy = (s<0.);\n  line(color,FromHue(s), 1.,.5, vec2((dx ? p0.x : -p0.x),(dy ? p0.y : -p0.y)),\n                                vec2((dx ? p1.x : -p1.x),(dy ? p1.y : -p1.y)), uv, .01, false);\n\n//__Gooey line animated using two Lissajous figures___________________________________________________________________\n  float t0 = .13*iTime,\n        t1 = .17*iTime, // Each is out of synch with the other points\n        t2 = .19*iTime;\n        p0 = .8*vec2(2.*sin(3.*tau*t0), sin(.5*pi+tau*t0)); // Lissajous figure parametric equations animate the gooey ends\n        p1 = .8*vec2(2.*cos(3.*tau*t1), sin(      tau*t1));\n  vec2  p2 = .8*vec2(   sin(   tau*t2), cos(.5*pi+tau*t2));\n  float rGoo = .1*(.5+abs(sin(pi*(t1+t2))));\n  line(color,gold, .9,.0, p0,p1, uv, rGoo , true); // Thick goo\n\n//__White inner circle closest to the viewer (on top):________________________________________________________________\n  float rInner = .7,\n    innerWidth = 4.,\n        tInner = abs(d - abs(rInner)) - innerWidth/rPx,\n     antialias = fwidth(tInner);\n  color = mix(white, color, smoothstep(-antialias, antialias, tInner));\n\n//__Spinning ribbon___________________________________________________________________________________________________\n  position = .5*(p0+p1); // Mid-point of the gooey line\n  line(color,gold, .9,.5, position,p2, uv, rGoo , true); // Another thick goo line attached at the mid-point to the last\n  float  m = distance(uv,position);\n  if((.5*rGoo<m)&&(m<rGoo)) {\n    float a = 30.*iTime;\n    vec2  c = vec2(sin(a),cos(a)); // To reverse direction, use c.yx instead of c in the dot product:\n    float t = Unsigned(r==0. ? .5 : dot((uv-position)/m, c)); // use dot product shading around the circle\n    t  = Upper(3.,t); // Leave only the top third of the circle values visible\n    color = mix(color,1.1*gold, t);\n  }\n\n//____________________________________________________________________________________________________________________\n  o = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}