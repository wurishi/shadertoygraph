{"ver":"0.1","info":{"id":"ct2GRz","date":"1672844780","viewed":192,"name":"Line Integral Convolution","username":"stbf","description":"Implementation of the line integral convolution","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["viz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ARC_LENGTH 50\n#define TAU 6.283185307\n\n// this function is a replacement for the vector field input\nvec2 vec_field(vec2 uv) {\n    float a = fract(uv.x * 2.) * TAU;\n    float b = fract(uv.y * 1.) * TAU;\n    return vec2(cos(a), cos(b));// * (sin(iTime*2.) / 2. + 1.);\n}\n\n\n// read a noice from a texture channel. we probably want to\n// sample this with a 3D simplex noise with the vertex coords\n// in mind.\nfloat noise(vec2 uv) {\n    float v = texture(iChannel0, uv).r < .5 ? 0. : 1.;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )                                                       \n{                                                                                                             \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 d = .5 / iResolution.xy; // half pixel step\n    float col = noise(uv);\n    \n    int n = 0;\n    \n    // forward streamline integration\n    vec2 s0 = uv;\n    for (int i = 0; i < ARC_LENGTH / 2; ++i) {\n        vec2 delta = vec_field(s0) * d;\n        if (length(delta) < 0.00001) break;\n        s0 += delta;\n        \n        /*\n         * The following checks are for the domain but they generate artifacts\n         * on the edges. I'm not sure how to handle this, yet\n         */\n        //if (s0.x < 0. || s0.x > 1.) break;\n        //if (s0.y < 0. || s0.y > 1.) break;\n        col += noise(s0);\n        n++;\n    }\n    \n    // backward streamline integration\n    vec2 s1 = uv;\n    for (int i = 0; i < ARC_LENGTH / 2; ++i) {\n        vec2 delta = vec_field(s1) * d;\n        if (length(delta) < 0.00001) break;\n        s1 -= delta;\n        \n        /*\n         * Same here ...\n         */\n        //if (s0.x < 0. || s0.x > 1.) break;\n        //if (s0.y < 0. || s0.y > 1.) break;\n        col += noise(s1);\n        n++;\n    }\n    \n    col /= float(n);\n    fragColor = vec4(vec3(col),1.);\n}                                                                                                             \n","name":"Image","description":"","type":"image"}]}