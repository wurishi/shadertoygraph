{"ver":"0.1","info":{"id":"NddGzs","date":"1630502984","viewed":108,"name":"Pseudo Hyper Hexagonest","username":"pdkl95","description":"A shader in the style of the \"Hyper Hexagonest\" level from Terry Cavanagh's wonderful game Super Hexagon.\n\n(the screen spinning is unfortunately a not-very-accurate hack :(  ~sigh~ )","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","superhexagon","hyperhexagonest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*****************************************\n * Pseudo-Super-Hexagon (ver: 1.1, 2020) *\n *    shader by PDKL95                   *\n *                                       *\n * (with apologies to Terry Cavanagh)    *\n *****************************************/\n\n\n#define TAU 6.283185307179586\n\n#define NSEC 6*\n#define SPINRATE 3.0\n#define DEPTHRATE 10.0\n#define DEPTHSCALE 10.0\n#define INNERWALLSIZE 0.01\n#define INNERRADIUS 0.2\n#define INNERBEATSIZE 0.01\n#define INNERBEATRATE 6.0\n\n#define COLORSPEED 1.8\n\n#define COLOR_1_FG  vec3(0.96, 0.96, 0.96)\n#define COLOR_1_BG1 vec3(0.67, 0.67, 0.67)\n#define COLOR_1_BG2 vec3(0.53, 0.53, 0.53)\n#define COLOR_2_FG  vec3(0.93, 0.93, 0.93)\n#define COLOR_2_BG1 vec3(0.44, 0.44, 0.44)\n#define COLOR_2_BG2 vec3(0.35, 0.35, 0.35)\n\n#define nsin(x) ((sin(x) + 1.0) / 2.0)\n\n#define NUMWALLS 128\n\nconst int BIT_COUNT = 8;\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a = a / 2;\n        b = b / 2;\n        n = n * 2;\n\n        if(!(a > 0 && b > 0)) {\n            break;\n        }\n    }\n    return result;\n}\n\nvec3 rgb2hsv(in vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(in vec2 point, in float rads)\n{\n    float cs = cos(rads);\n    float sn = sin(rads);\n    return point * mat2(cs, -sn, sn, cs);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float px = 1.0/iResolution.y;\n    float aspect = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 position = (uv * 2.0) - 1.0;\n\n    if (aspect < 1.0) {\n        aspect = 1.0/aspect;\n        position.x *= aspect;\n    } else {\n        position.y *= aspect;\n    }\n\n    float spintime = iTime * SPINRATE;\n    spintime = (0.4 * spintime) + sin(0.7 * spintime) + sin(0.2 * spintime);\n    float spin = mod(spintime, TAU);\n\n    float realdepth = iTime * DEPTHRATE;\n\n    vec2 rposition = rotate(position, spin);\n\n#if 0\n    const mat3 proj_matrix = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(    0.0, 3.0/4.0, 0.0),\n        vec3(    0.0, 0.0, 0.5)\n    );\n\n    float r3d_theta_x = (TAU/12.0) * sin(iTime * 2.0);\n    float r3d_sintx = sin(r3d_theta_x);\n    float r3d_costx = cos(r3d_theta_x);\n    mat3 rotx_matrix = mat3(\n        vec3(1.0,        0.0,       0.0),\n        vec3(0.0,  r3d_costx, r3d_sintx),\n        vec3(0.0, -r3d_sintx, r3d_costx)\n    );\n\n    float r3d_theta_y = (TAU/16.0) * sin(iTime * 0.4);\n    float r3d_sinty = sin(r3d_theta_y);\n    float r3d_costy = cos(r3d_theta_y);\n    mat3 roty_matrix = mat3(\n        vec3( r3d_costy, 0.0, r3d_sinty),\n        vec3(       0.0, 1.0,       0.0),\n        vec3(-r3d_sinty, 0.0, r3d_costy)\n    );\n\n    vec3 pos3 = vec3(rposition.xy, 0.0);\n    vec3 proj_pos = proj_matrix * pos3;\n    float perspective_factor = proj_pos.z * 0.5 + 1.0;\n    rposition = proj_pos.xy/perspective_factor;\n#endif\n\n    float r = length(rposition);\n    float theta = atan(rposition.y, rposition.x);\n    theta += TAU/2.0;\n    float section = 6.0 * (theta/TAU);\n    float zone = floor(section);\n    float zonefrag = mod(section, 1.0);\n    float odd  = mod(zone, 2.0);\n\n    float color_fade = nsin(iTime * COLORSPEED);\n    vec3 color_fg  = mix(COLOR_1_FG,  COLOR_2_FG,  color_fade);\n    vec3 color_bg1 = mix(COLOR_1_BG1, COLOR_2_BG1, color_fade);\n    vec3 color_bg2 = mix(COLOR_1_BG2, COLOR_2_BG2, color_fade);\n\n    vec3 color = mix(color_bg1, color_bg2, odd);\n\n    float dist_to_edge = abs(zonefrag - 0.5) * 2.0;\n    float angle_to_edge = dist_to_edge * (TAU / 12.0);\n\n    float hexradius = cos(TAU - angle_to_edge) * r;\n    float depth = (hexradius * DEPTHSCALE) + realdepth;\n\n    float ib = INNERBEATRATE * iTime;\n    float ir = 2.1 +\n        (3.0 * sin(ib)) +\n        (4.0 * cos(ib)) -\n        (      sin(ib * 2.0)) -\n        (2.1 * cos(ib * 2.0));\n    ir = INNERRADIUS - (INNERBEATSIZE * abs(ir));\n\n    if (hexradius < ir) {\n        if ((ir - hexradius) < INNERWALLSIZE) {\n            color = color_fg;\n        }\n    } else {\n        // float row = floor(depth);\n        // float oddrow = mod(row, 2.0);\n        // color = mix(color_fg, color, oddrow);\n\n        float moddepth = floor(mod(depth, 128.0));\n        int wallidx = int(moddepth);\n\n#define wall(idx, val) if (wallidx == (idx)) { curwall = (val); } else\n\n#define MAXWALL 126\n\tint curwall = 0;\n        if (wallidx < MAXWALL) {\n\t    if (wallidx < 37) {\n\t\tif (wallidx < 19) {\n\t\t    wall( 1, 0x2a)\n        \t    wall( 4, 0x15)\n        \t    wall( 7, 0x2a)\n        \t    wall(10, 0x15)\n        \t    wall(13, 0x2a)\n        \t    wall(16, 0x1b)\n\t\t    {}\n\t\t} else {\n        \t    wall(19, 0x2d)\n        \t    wall(22, 0x36)\n\t\t    wall(25, 0x2d)\n        \t    wall(28, 0x1b)\n        \t    wall(31, 0x36)\n        \t    wall(34, 0x2f)\n\t\t    {}\n\t\t}\n\t    } else if (wallidx < 67) {\n\t\tif (wallidx < 53) {\n\t\t    wall(37, 0x1b)\n        \t    wall(38, 0x09)\n        \t    wall(39, 0x24)\n        \t    wall(40, 0x12)\n        \t    wall(41, 0x09)\n        \t    wall(42, 0x24)\n        \t    wall(43, 0x12)\n        \t    wall(44, 0x09)\n        \t    wall(45, 0x2d)\n        \t    wall(50, 0x3e)\n\t\t    {}\n\t        } else {\n\t\t    wall(53, 0x1b)\n        \t    wall(54, 0x12)\n        \t    wall(55, 0x24)\n        \t    wall(56, 0x09)\n        \t    wall(57, 0x12)\n        \t    wall(58, 0x24)\n        \t    wall(59, 0x09)\n        \t    wall(60, 0x12)\n        \t    wall(61, 0x36)\n\t\t    {}\n\t\t}\n\t    } else {\n\t\tif (wallidx < 104) {\n\t\t    wall(67, 0x1f)\n        \t    wall(72, 0x3b)\n        \t    wall(77, 0x1f)\n        \t    wall(83, 0x1f)\n        \t    wall(88, 0x3b)\n        \t    wall(93, 0x2f)\n        \t    wall(99, 0x1f)\n\t\t    {}\n\t\t} else {\n\t\t    wall(104, 0x3b)\n        \t    wall(109, 0x3e)\n        \t    wall(114, 0x2a)\n        \t    wall(116, 0x2a)\n        \t    wall(120, 0x1f)\n        \t    wall(125, 0x2f)\n\t\t    {}\n\t\t}\n\t    }\n        }\n\n\t\n\tint mask = 1;\n\tint izone = int(zone);\n#define zmask(z,m) if (izone == z) {mask = m; } else\n\tzmask(1, 2)\n\tzmask(2, 4)\n\tzmask(3, 8)\n\tzmask(4, 16)\n\tzmask(5, 32)\n\t{}\n\n\tcurwall = and(curwall, mask);\n        if (curwall > 0) {\n            color = color_fg;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}