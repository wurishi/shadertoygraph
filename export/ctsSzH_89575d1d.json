{"ver":"0.1","info":{"id":"ctsSzH","date":"1675349466","viewed":445,"name":"Mountain Structures","username":"Poisson","description":"A pathtraced menger sponge with global illumination, indirect lighting, direct lighting, bokeh depth of field, and bloom.","likes":28,"published":1,"flags":32,"usePreview":1,"tags":["3d","raymarching","fractal","ray","volume","gi","blur","antialiasing","dof","volumetric","fog","raymarcher","menger","pathtracing","pathtracer","snow","haze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Another fractal art, I love the frozen style of this one, and the fog looks\n// really good. This is just a rotated manger sponge with pathtracing\n// a sun light and global illumination.\n\n// ACES tonemapper\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// bloom function\nvec4 bloom(sampler2D tex, vec2 p) {    \n    vec4 col = vec4(0); // accumulated color\n    const int N = 8; // quality\n    \n    for (int i=-N; i<=N; i++)\n    for (int j=-N; j<=N; j++)  {\n        vec2 off = vec2(i,j) / float(N); // blur offset\n        if (dot(off, off)<1.) { // inside disk\n            // blurred texture\n            col += textureLod(tex, p+.05*off, 4.);\n        }\n    }\n    // output\n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n    \n    // base color\n    vec4 data = texture(iChannel0, p);\n    vec3 col = data.rgb/data.w;\n    \n    // post processing\n    col = pow(col, vec3(.4545)); // gamma correction\n    col = col*1.1-.1; // darkening\n    \n    // bloom\n    vec3 bloom = bloom(iChannel0, p).rgb;\n    col += .4*bloom;\n    col = clamp(col,0.,1.);\n    \n    col = col*col*(3.-2.*col); // constrast\n    col = ACES(col); // tonemapping\n    \n    // black bars\n    col *= step(abs(p.y-.5),.425);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float seed; // randoms seed\n\n// hash functions by me\nfloat hash1() {return fract(sin(seed+=.1)*4561.7564);}\n\nvec2 hash2() {return fract(sin(seed+=.1)*vec2(8472.5636,9854.4213));}\n\nvec3 hash3() {return fract(sin(seed+=.1)*vec3(7653.1285,6912.8512,5914.7134));}\n\n// normalized random 3d vector\nvec3 uniformVector() {\n    vec3 v = hash3()*2.-1.;\n    return normalize(v);\n}\n\n// 2d rotation\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a); // sine, cosine\n    return mat2(c, -s, s, c);\n}\n\n// scene sdf (menger sponge)\nfloat map(vec3 p) {\n    vec3 q = abs(p);\n    float d = p.y; // distance\n    \n    float s = .6; // scale\n    for (int i=0; i<6; i++) { // 6 iteration\n        // transformation\n        p.yz *= rot(float(i)*2.);\n        p.xz *= rot(float(i));\n        vec3 a = mod(p*s, 2.) - 1.;\n        s *= 3.;\n        vec3 r = 1. - 3.*abs(a);\n                \n        r = abs(r);        \n        \n        // cross distance\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n    \n        float c = min(da,min(db,dc)) - 1.;\n        \n        d = max(d, c/s);\n    }\n    \n    // return the distance\n    return min(d,12.);\n}\n\n// raymarching function\nfloat intersect(vec3 ro, vec3 rd) {\n    float t = 0.; // distance travelled\n    \n    for (int i=0; i<256; i++) { // marching loop\n        vec3 p = ro + rd*t; // current point\n        \n        float h = map(p); // distance to the scene\n        if (h<.001) break; // we hit the surface\n        t += h; // march\n        if (t>12.) return -1.;\n    }\n    // return the distance\n    return t;\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p);\n    vec2 e = vec2(h,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy),\n                              map(p-e.yxy),\n                              map(p-e.yyx)));\n}\n\n// shadow function\nfloat shadow(vec3 ro, vec3 rd) {\n    for (float t=0.; t<4.;) {\n        vec3 p = ro + rd*t;\n        float h = map(p);\n        if (h<.001) return 0.;\n        t += h;\n    }\n    return 1.;\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    // light (sun) direction\n    vec3 lig = normalize(vec3(2,1,1)+.1*uniformVector());\n    vec3 bgCol = vec3(.6,.8,1); // background color\n    \n    float fdis = 0.; // final distance\n    vec3 frd; // final ray direction\n    \n    vec3 col = vec3(0); // accumulated color\n    vec3 emit = vec3(1); // color mask\n    \n    for (int i=0; i<5; i++) { // 5 bounces of gi\n        float t = intersect(ro, rd);\n        if (i==0) {fdis = t; frd = rd;}\n        \n        if (t<0.) { // we don't hit the surface\n            if (i==0) col = bgCol;\n            break;\n        }\n        \n        vec3 p = ro + rd*t; // hit point\n        vec3 n = calcNormal(p); // surface normal\n        \n        ro = p+n*.002; // new ray origin\n        rd = normalize(n+uniformVector()); // new ray direction, cheap diffuse BRDF\n        emit *= vec3(.8,.9,1)*.9; // color the object\n                \n        float dif = clamp(dot(n,lig), 0., 1.); // diffuse light\n        float sha = shadow(ro, lig); // shadow\n        \n        // lighting\n        col += emit*dif*sha;\n        \n    }\n    col = mix(col, bgCol, 1.-exp(-fdis*fdis*fdis*.001)); // fog\n    col += 3.*pow(clamp(dot(frd,lig),0.,1.),3.5); // sun glare\n    \n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init randoms seed\n    seed = iTime+dot(sin(fragCoord),vec2(453.712,983.234));\n    \n    vec2 off = hash2()-.5; // AA offset\n    // // pixel coordinates centered at the origin\n    vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(-1,.9,1.6); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n    \n    // depth of field\n    float t = intersect(ro, ca[2]); // focus distance\n    vec3 fp = ro + rd*t; // focus plane\n    ro += uniformVector()*.05;\n    rd = normalize(fp-ro);\n    \n    // render\n    vec3 col = render(ro, rd);    \n\n    // blend the color with the previous frame color\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(col,1.0) + data*step(iMouse.z,0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}