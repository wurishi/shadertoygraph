{"ver":"0.1","info":{"id":"XffBzM","date":"1723488734","viewed":49,"name":"Icosaedron map study","username":"Elsio","description":"Isolando o map do @flockaroo para estudar esse poliedro","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["truchet","copper","atomium","sodering","tin"],"hasliked":0,"parentid":"MlffDX","parentname":"soldering fun"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define normal(p) normalize(map(p)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)))\n#define t iTime * .5\n#define far 60.\n#define pi acos(-1.)\n#define PI2 2.*pi\n\nvec3 gD;\nvec4 cor;\n\nfloat h31(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// by flockaroo\nfloat distTruchet(\n        vec3 pos, \n        vec3 p1, vec3 p2, vec3 p3, \n        float r) {\n        \n    float d, rnd = h31(p1 + p2 + p3);\n    vec3 q, q1, q2, p4, p5, p6;\n    \n    if(rnd > .333) \n        q = p1, p1 = p2, p2 = p3, p3 = q;\n        \n    else if(rnd > .666) \n        q = p1, p1 = p3, p3 = p2, p2 = q;\n    \n    p4 = pos - normalize(p1 + p2);\n    p5 = pos - normalize(p2 + p3);\n    p6 = pos - normalize(p3 + p1);\n    \n    q1 = p5 - p4;\n    q2 = p6 - p4;\n    \n    d = length(p4 - q1 * (dot(p4, q1) / dot(q1, q1))) - r;\n    d = min(d, length(p4 - q2 * (dot(p4, q2) / dot(q2, q2))) - r);\n    \n    r += r;\n    d = min(d, length(p4) - r);\n    d = min(d, length(p5) - r);\n    d = min(d, length(p6) - r);\n    \n    return d;\n}\n\n// by flockaroo\nvoid getTriSubDiv(vec3 pos, inout vec3 p1, inout vec3 p2, inout vec3 p3) {\n    vec3 p4 = normalize(p1 + p2);\n    vec3 p5 = normalize(p2 + p3);\n    vec3 p6 = normalize(p3 + p1);\n    \n    if(dot(pos, cross(p4, p5)) < 0.) \n        p1 = p4, p2 = p2, p3 = p5;\n    \n    else if(dot(pos, cross(p5, p6)) < 0.) \n        p1 = p6, p2 = p5, p3 = p3;\n    \n    else if(dot(pos, cross(p6, p4)) < 0.) \n        p1 = p1, p2 = p4, p3 = p6;\n\n    else p1 = p4, p2 = p5, p3 = p6;\n}\n\n// by flockaroo\n// calcula os vértices de um triângulo em um icosaedro\nvoid getIcosaTri(vec3 pos, out vec3 p1, out vec3 p2, out vec3 p3) {\n    mat2 rot = mat2(\n                   .809016994374947, .587785252292473, \n                   - .587785252292473, .809016994374947);\n    \n    //rot = mat2(cos(PI2 / 10. + vec4(0, 11, 33, 0))); // deveria funcionar\n    \n    float dang = PI2 / 5.;\n    float seg = atan(pos.y, pos.x) / dang;\n    float fseg = floor(seg);\n    \n    vec3 p1t = vec3(0, 0, 1);\n    vec3 p2t = vec3(\n                   cos(fseg * dang - vec2(0, PI2 / 4.)) * .894427190999916, \n                   .447213595499958\n               );\n    \n    vec3 p4t = vec3(rot * p2t.xy, -p2t.z);\n    vec3 p3t = vec3(rot * p4t.xy, p2t.z);\n    \n    if( dot(pos, cross(p2t, p4t)) < 0. || \n        dot(pos, cross(p4t, p3t)) < 0.) {\n        \n        p1t = vec3(0, 0, -1);\n        p3t = vec3(\n                    seg - fseg < .5\n                               ? p2t.xy * rot\n                               : rot * p2t.xy, \n                    - p2t.z\n              );\n        p4t = vec3(rot * p3t.xy, - p3t.z);\n        p2t = vec3(rot * p4t.xy, p3t.z);\n    }\n    \n    bool top = dot(pos, cross(p2t, p3t)) > 0.;\n    \n    p1 = top ? p1t : p4t;\n    p2 = top ? p2t : p3t;\n    p3 = top ? p3t : p2t;\n}\n\n\nfloat dist(vec3 p) {\n    \n    float d = length(p) - .9;\n    //d = 1.;\n    \n    vec3 p1, p2, p3;\n    getIcosaTri(p, p1, p2, p3);\n    \n    \n    float r0 = .02, sc = 1.;\n    \n    getTriSubDiv(p, p1, p2, p3);\n    d = min(d, distTruchet(p, p1, p2, p3, r0));\n    \n    getTriSubDiv(p, p1, p2, p3);\n    sc = 1. / .97;\n    d = min(d, distTruchet(p * sc, p1, p2, p3, r0 / 2.) / sc);\n    \n    getTriSubDiv(p, p1, p2, p3);\n    sc = 1. / .96;\n    d = min(d, distTruchet(p * sc, p1, p2, p3, r0 / 4.) / sc);\n    \n    return d;\n}\n\n\nfloat map(vec3 p) {\n    p.xy *= rot(t * .3);\n    p.yz *= rot(t * .2);\n    return dist(p);\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy, \n         e = vec2(.001, 0); \n    \n    u = vec2(u - r / 2.) / r.y;\n    \n    float i, d, s;\n    vec3 N, L,\n         p = vec3(0, 0, -1.5), \n         D = normalize(vec3(u, 1));\n    \n    s = 1.;\n    while(i++ < 64. && s > .001 && d < far) \n        s = map(p),\n        p += s * D,\n        d += s;\n\n    o = vec4(3, 5, 8, 0) / 64.;\n    \n    if(d < far)\n        N = normal(p), \n        L = normalize(vec3(cos(t) * 5., 3, -3) - D), \n        \n        o = cor,\n        o *= (.8 * max(0., dot(L, N)) + .5) * .6,  // diff\n        o += pow(max(0., dot(L, N)), 10.) * .3;    // spec\n    \n    o =  pow(o, vec4(.4));                         // gama  \n}","name":"Image","description":"","type":"image"}]}