{"ver":"0.1","info":{"id":"7t3fRN","date":"1662732740","viewed":73,"name":"Hw 1+2","username":"El1za","description":"First and second homework for my classes at MIPT","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 (0, 0, 4);\nconst vec3  light    = vec3  ( 5.0, 5.0, 5.0 );\nconst int   maxSteps = 150;\nconst float eps      = 0.01;\nconst float maxDist  = 70.0;\nconst float pi       = 3.1415926;\n\nconst int MAT_DRUM     = 1;\nconst int METALL_BALLS = 2;\nconst int MAT_PLANE    = 3;\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, in vec3 c, in float r )\n{\n\treturn length ( p - c ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n    return dot(p, n) + h;\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\n\nfloat smoothUnion ( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0 );\n\n    return mix( d2, d1, h ) - k*h * (1.0 - h); \n}\n\nfloat minUnion ( float d1, float d2 )\n{\n    return min( d1, d2 );\n}\n\nfloat sdfBalls ( vec3 q )\n{\n    vec3 qSL = q + vec3(  abs(cos(iTime)), 2.6*abs(sin(2. * iTime)), 0.0);\n    vec3 qSR = q + vec3( -abs(cos(iTime)), 1.3*abs(sin(2. * iTime)), 0.0);\n    \n    float sphL = dSphere ( qSL, vec3 (  0.5, 0, 0 ), 0.35 );\n    float sphR = dSphere ( qSR, vec3 ( -0.5, 0, 0 ), 0.35 );\n    \n    return minUnion(sphL, sphR);\n}\n\nfloat sdfDrum ( vec3 q )\n{\n    float torL = sdTorus ( q - vec3(0.5, 0.0, 0.0), vec2 (0.5, 0.1 - 0.025*cos(4.*iTime)) );\n    float torR = sdTorus ( q + vec3(0.5, 0.0, 0.0), vec2 (0.5, 0.1 - 0.025*cos(4.*iTime)) );\n    \n    float coneL = sdCappedCone( q - vec3(0.5,  0.75, 0.0), 0.5, 0.55, 0.4);\n    float coneR = sdCappedCone( q + vec3(0.5, -0.75, 0.0), 0.5, 0.55, 0.4);\n    \n    float minL  = smoothUnion(torL, coneL, 0.65);\n    float minR  = smoothUnion(torR, coneR, 0.65);\n    \n    return smoothUnion(minL, minR, 0.1);\n}\n\nfloat sdfPlane ( vec3 q )\n{\n    return sdPlane(q, vec3(0., -1., 0.), 4.1);\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n    vec3 q = p * m;\n    \n    return minUnion(sdfPlane(q), minUnion( sdfDrum(q), sdfBalls(q) ));\n}\n\nint getMaterial ( vec3 p, mat3 m) \n{\n    vec3 q = p * m;\n    \n    float drumDist  = sdfDrum(q);    \n    float ballsDist = sdfBalls(q);\n    float planeDist = sdfPlane(q);\n    float dist = min(planeDist, min(drumDist, ballsDist));\n    \n    int material = 0;   \n    \n    if (dist == drumDist)\n        material = MAT_DRUM;\n        \n    else if (dist == ballsDist)\n        material = METALL_BALLS; \n        \n    else if (dist == planeDist)\n        material = MAT_PLANE;\n    \n    return material;\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat dist = abs(sdf ( p, m ));\n        \n\t\tif ( dist < eps )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n        totalDist += dist;\n        if ( totalDist > maxDist )\n            break;\n\t\t\t\n        p += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec4 sky ( in vec2 fragCoord) \n{\n    float h = fragCoord.y / iResolution.y;\n\n    return ( vec4(180, 218, 231, 1) * (1.0 - h) + vec4(1, 114, 184, 1) * h ) / 255.;\n}\n\n\nfloat shadow ( vec3 p, vec3 light, float hardness, mat3 m) \n{\n    float min_dist = maxDist;\n    float prev_t = 0.0;\n    float dist_left = length(light - p);\n    \n    vec3 dir = (light - p) / dist_left;\n    p += dir * 0.1;\n    \n    for (int i = 0; i < maxSteps; i++) \n    {\n        float t = sdf(p, m);\n        if (t < prev_t && t < min_dist) \n        {\n            min_dist = t;\n        }\n        prev_t = t;\n        p += t * dir;\n        dist_left -= t;\n        if (dist_left <= 0.0)\n            break;\n    }\n    \n    return 1.0 / (1.0 + exp( -hardness * min_dist));\n}\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n    product = clamp ( product, 0.0, 1.0 ); // saturate\n    return mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float NdH2 = NdH * NdH;\n    float d = (m2 - 1.0) * NdH2 + 1.0;\n    return m2 / (pi * d * d);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n    return nl * nv / max ( nl, nv );\n}\n\nvec3 cookTorrance ( in float nl, in float nv, in float nh, in float vh, in vec3 f0, in float roughness )\n{\n    float D = D_GGX ( roughness, nh );\n    float G = G_neumann ( nl, nv );\n    return f0 * D * G;\n}\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = abs(n);\n    \n\treturn triW / (triW.x + triW.y + triW.z);\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max(d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy * 1.8 - 0.5, iMouse.z * 1.8 - 0.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 1, 1, 1, 1 );\n    vec3 base  = vec3(0.9, 0.9, 0.9);\n    vec3 p     = trace ( eye, dir, hit, m );\n    vec3 q     = p * m;\n\n    if ( !hit )\n    {\n        fragColor = sky(fragCoord);\n        return;\n    }\n\n\tif ( hit )\n\t{\n        vec3  n  = generateNormal ( p, 0.001, m );\n        vec3  l  = normalize      ( light - p );\n        vec3  v  = normalize      ( eye - p );\n        vec3  h  = normalize      ( l + v );\n        \n        float nv = max ( 0.0, dot ( n, v ) );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        float nh = max ( 0.0, dot ( n, h ) );\n        float hl = max ( 0.0, dot ( h, l ));\n        float vh = max ( 0.0, dot ( h, v ));\n        float sp = pow ( nh, 11.0 );\n                \n        float gamma = 2.2;\n        float metallness = 0.0;\n        float roughness = 0.0;\n        float fDiel = 0.04;\n        vec3  lightColor = vec3 ( 1.0 );\n        \n        int material = getMaterial(p, m);\n        \n        if (material == MAT_DRUM)\n        {\n            metallness = 0.1;\n            roughness = texture ( iChannel0, q.xz * 1.95).x;\n            \n            base = texture(iChannel0, q.xz * 1.95).rgb * vec3(1.5);\n        }\n        else if (material == METALL_BALLS)\n        {\n            metallness = 0.21;\n            roughness = 0.2;\n            \n            vec3 tx = getTriplanarWeights( n );\n            vec4 cx = texture ( iChannel2, q.yz );\n            vec4 cy = texture ( iChannel2, q.zz );\n            vec4 cz = texture ( iChannel2, q.xy );\n            color *=  tx.x * cx + tx.y * cy + tx.z * cz;\n            \n            //base = vec3(0.17, 0.9, 0.9);\n        }\n        else if (material == MAT_PLANE)\n        {            \n            metallness = 0.21;\n            roughness = texture ( iChannel1, q.xz * 0.15).x;\n       \n            base = texture(iChannel1, q.xz * 0.15).rgb * vec3(1.5);\n        }\n        \n        base = pow(base, vec3(gamma));\n        \n        vec3 F0 = mix ( vec3 ( fDiel ), base, metallness );\n        vec3 specFresnel = fresnel ( F0, nv );\n        vec3 spec = cookTorrance(nl, nv, nh, vh, specFresnel, roughness) * nl / max(0.001, 4.0 * nl * nv);\n        vec3 diff = (vec3(1.0) - specFresnel) * nl / pi;\n                \n        color *= vec4((diff * mix(base, vec3(0.0), metallness) + spec) * lightColor, 1.0);\n        color = pow(color, vec4(1.0 / gamma));\n\t\t\n\t\t//color += 0.5 * vec4 (nl) + 0.4 * vec4 (0.2, 0, 0.4, 1) + 0.7 * sp * vec4 (0.8, 0.8, 0, 1);\n\t} \n    \n    fragColor = shadow(p, light, 100.0, m) * color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.17, sin(iTime), cos(iTime), 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}