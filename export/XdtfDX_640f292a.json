{"ver":"0.1","info":{"id":"XdtfDX","date":"1531048704","viewed":102,"name":"Complex function plot","username":"olympus223","description":"Shader which plots a complex function.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["color","number","function","plot","complex","imaginary","phase","real"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592;\nconst float TWOPI = 6.283184;\n\nvec2 cexp(float r, float phi) {\n\treturn vec2(r * cos(phi), r * sin(phi));\n}\n\nfloat map(float x, float in_min, float in_max, float out_min, float out_max) {\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n    \nvec2 add(vec2 c1, vec2 c2) {\n    return vec2(c1.x + c2.x, c1.y + c2.y);\n}\n\nvec2 sub(vec2 c1,vec2 c2) {\n    return vec2(c1.x - c2.x, c1.y - c2.y);\n}\n\nvec2 mul(vec2 c1, vec2 c2) {\n    return vec2(c1.x * c2.x - c1.y * c2.y, c1.x * c2.y + c1.y * c2.x);\n}\n\nvec2 div(vec2 c1, vec2 c2) {\n    return 1.0 / (c2.x * c2.x + c2.y  * c2.y) * vec2(c1.x * c2.x + c1.y * c2.y, -c1.x * c2.y + c1.y * c2.x);\n}\n\nfloat arg(vec2 c) {\n    float arg = atan(c.y, c.x);\n    if(arg < 0.0) {\n        arg = 6.28 + arg;\n    }\n    return arg;\n}\n\nvec2 cpow(vec2 c, float n) {\n    float arg = arg(c);\n    return pow(length(c), n) * vec2(cos(n * arg), sin(n * arg));\n}\n\n\nvec2 func(vec2 c) {\n    float w = c.x;\n    vec2 r = div(mul(sub(cexp(1.0, w), vec2(-1, 0)), sub(cexp(1.0, w), vec2(1, 0))), mul(sub(cexp(1.0, w), cexp(0.9, PI / 2.0)), sub(cexp(1.0, w), cexp(0.9, -PI / 2.0))));\n\t//vec2 r = div(mul(sub(cexp(1.0, w), cexp(1.0, PI / 4.0)), sub(cexp(1.0, w), cexp(1.0, -PI / 4.0))), mul(sub(cexp(1.0, w), cexp(0.95, PI / 4.0)), sub(cexp(1.0, w), cexp(0.95, -PI / 4.0))));\n    return vec2(0.0, length(r));\n    //vec2 r = add(cpow(add(c,vec2(iTime,0.0)),2.0),vec2(16.0,iTime));\n    //return add(vec2(iTime,0.0), mul(c, r));\n    //return sub(div(vec2(-iTime, -1), c), vec2(1.0, iTime));\n    //return div(cpow(c, iTime/2.0) + vec2(-1, 0), cpow(c, 2.0) + vec2(1, 1));\n    //return div(vec2(1.0, 0.0), cpow(c, length(c) - iTime));\n}\n    \nvec3 hsl_rgb(vec3 color) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);\n    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);\n}\n\nbool eq(float v, float e, float eps) {\n    return v > e - eps && v < e + eps;\n}\n\nvec3 monoShader(vec2 z) {\n    float hue;\n    float saturation;\n    float brightness;\n    \n    hue = map(arg(z), 0.0, TWOPI, 0.0, 2.0);\n    saturation = 0.0;\n    brightness = map(arg(z), 0.0, TWOPI, 0.0, 1.0);\n    \n    if (eq(length(z), 1.0, 0.2)) {\n        saturation = map(abs(1.0 - length(z)), 0.0, 0.2, 0.5, 1.0);\n    }\n    \n    return hsl_rgb(vec3(hue, saturation, brightness));\n    \n}\n\nvec3 hueShader(vec2 z) {\n    float hue;\n    float saturation;\n    float brightness;\n      \t\n    hue = map(arg(z), 0.0, TWOPI, 0.0, 2.0);\n    saturation = 1.0;\n    brightness = 1.0 - pow(2.0, -length(z));\n    \n    if (eq(length(z), 1.0, 0.2)) {\n    \tsaturation = map(abs(1.0 - length(z)), 0.0, 0.2, 0.5, 1.0);\n    }\n    \n    return hsl_rgb(vec3(hue, saturation, brightness));\n}\n\nvec3 testShader(vec2 z) {\n    float hue;\n    float saturation;\n    float brightness;\n      \t\n    hue = map(arg(z), 0.0, TWOPI, 0.0, 2.0);\n    saturation = 1.0;\n    brightness = 1.0 - pow(2.0, -length(z));\n    \n    hue = mix(saturation, brightness, hue);\n    \n    return hsl_rgb(vec3(hue, saturation, brightness));\n}\n\nvec3 test2Shader(vec2 z) {\n    float hue;\n    float saturation;\n    float brightness;\n      \t\n    hue = map(arg(z), 0.0, TWOPI, 0.0, 2.0);\n    saturation = 1.0;\n    brightness = 1.0 - pow(2.0, -length(z));\n    \n    hue = mix(0.0, 1.0, map(length(z), 0.0, 3.0, 0.0, 1.0));\n    \n    return hsl_rgb(vec3(hue, saturation, brightness));\n}\n\nvec3 test3Shader(vec2 z) {\n    float hue;\n    float saturation;\n    float brightness;\n    \n    hue = map(arg(z), 0.0, TWOPI, 0.0, 2.0);\n    saturation = 0.0;\n    brightness = map(arg(z), 0.0, TWOPI, 0.0, 1.0);\n    \n    if (eq(arg(z), PI, 0.2)) {\n        saturation = map(abs(1.0 - length(z)), 0.0, 0.2, 0.5, 1.0);\n    }\n    \n    return hsl_rgb(vec3(hue, saturation, brightness));\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n   \tfloat aspect = iResolution.x / iResolution.y;\n    \n    float scale = 5.0;\n    float speed = 5.0;\n\n    \n    float x = (uv.x - 0.5) * scale * aspect;\n    float y = (uv.y - 0.5) * scale;\n    x = map(x, 0.0, scale * aspect,  -PI,PI);\n    \n    vec2 z_in = vec2(x, y);\n    vec2 z_out = func(z_in);\n    \n    // Test the different shaders! monoShader, hueShader, testShader, see the functions above!\n    fragColor = vec4(testShader(z_out), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}