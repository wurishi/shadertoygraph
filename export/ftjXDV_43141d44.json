{"ver":"0.1","info":{"id":"ftjXDV","date":"1628757786","viewed":152,"name":"Perlin Ball 2","username":"denosya","description":"chall4","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float zNear = 1.0;\nconst float zFar  = 400.0;\n\nconst float TEXTURE_ANIM = 0.01;\nconst float MATERIAL_SCALE = 4.0;\n\nconst float GLASS = 1.95;\nconst float WATER = 1.33;\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\n\nfloat hash21(vec2 p) { //shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float f) {\n    return f*f*f*(f*(f*6.-15.)+10.);    \n}\n\nfloat randAngle(vec2 v) {\n    return hash21(v)*6.2832;\n}\n\nvec2 grad(float rand) {\n    return vec2(cos(rand), sin(rand)) * 1.4142;\n}\n\nfloat perlin(vec2 uv) {\n\n    vec2 index0 = floor(uv);\n    vec2 index1 = index0 + vec2(1,0);\n    vec2 index2 = index0 + vec2(1,1);\n    vec2 index3 = index0 + vec2(0,1);\n    \n    float rand0 = hash21(index0)*6.2832;\n    float rand1 = hash21(index1)*6.2832;\n    float rand2 = hash21(index2)*6.2832;\n    float rand3 = hash21(index3)*6.2832;\n    \n    vec2 localCoords = fract(uv);\n\n    float d0 = dot(uv - index0, grad(rand0));\n    float d1 = dot(uv - index1, grad(rand1));\n    float d2 = dot(uv - index2, grad(rand2));\n    float d3 = dot(uv - index3, grad(rand3));\n    \n    vec2 lerp = vec2(fade(localCoords.x), fade(localCoords.y));\n\n    float hlerp1 = mix(d0, d1, lerp.x);\n    float hlerp2 = mix(d3, d2, lerp.x);    \n    \n    return mix(hlerp1, hlerp2, lerp.y);\n}\n\n\n\nfloat bounceAnim(float amplitude, float amorti, float shift, float duration) {\n\n    float sequenceTime = mod(iTime*4.0 + shift, duration) / duration;\n    \n    float a = 3.1415 *(amorti*sequenceTime-1.0);\n    return sin(a)/a * amplitude;\n}\n\nfloat map(in vec3 m) {\n\n \tvec3 sphereCenter = vec3(0.0, 0.0, 8.);\n    float innerRadius = 1.;\n\n    vec3 normal = normalize(m - sphereCenter);\n    \n    float animateScale = 2.0 + sin(iTime*0.25);\n    \n    \n    vec2 UV = ((normal.xy + 1.0) * 0.5) * animateScale + vec2(iTime*TEXTURE_ANIM, 0.0);\n    \n    float h = perlin(UV)*0.5;// * emboss;\n   \n    return length(m - sphereCenter) - innerRadius - h; \n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<500; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist1 = map(m);\n        \n        if(dist1 < 0.01) {\n            return true;\n        }\n\n\t\tif(dist1 < 0.1) {\n            float eps = 0.005;\n            float dist2 = map(m + ray * eps);    \n            float gradient = (dist2 - dist1) / eps;\n\n            if(gradient > 0.0) {\n                marchingDist += dist1;\n            }\n            else {\n                marchingDist += min(-(dist1 / gradient), 0.1);\n            }\n        }\n        else {\n            marchingDist += dist1;\n\n            if(marchingDist >= zFar) {\n                break;\n            }            \n        }\n    }\n    \n\treturn false;    \n}\n\n// IQ's func <3\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.033, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nvec4 computeInnerColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n    \n    vec3 n = normalize(m-vec3(0.0, 0.0, 10.));\n    vec2 UV = ((n.xy + 1.0) * 0.5) * MATERIAL_SCALE + vec2(iTime*TEXTURE_ANIM, 0.0);\n    vec3 pixel = vec3(1);\n    \n    vec3 light1 = normalize(vec3(1,-1,1));//normalize(m - light);\n    vec3 light2 = normalize(vec3(-1,0,1));//normalize(m - light);    \n    \n    float diffuse1 = max(0.0, dot(normal, -light1));\n    float diffuse2 = max(0.0, dot(normal, -light2));    \n    \n    vec3 reflectedLight  = reflect(light1, normal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.0), 10.0);\n    \n    float ambiant = 0.2;       \n    \n    vec3 render1 = vec3(1,0,0) * (diffuse1+ambiant);\n    vec3 render2 = vec3(0,0,1) * (diffuse2+ambiant);\n    \n    vec3 render = mix(render1, render2, 1.);\n    \n    render = render1 + render2 + hilight * 0.5;\n    \n    \n    return vec4(render, 1.0);\n}\n\nvec3 animate(vec3 ray);\nbool intersectSphere(in vec3 origin, in vec3 ray, in Sphere sphere, out vec3 col1, out vec3 col2);\n\nvec4 render(in Sphere sphere, in vec3 p, in vec3 origin, in vec3 ray, in vec3 lightSource, vec4 innerColor) {\n\n    vec3 normal = normalize(p - sphere.center);\n    vec3 reflection = reflect(ray, normal);\n    vec4 reflection_pixel = texture(iChannel0, animate(reflection));\n    \n    vec3 refraction = refract(ray, normal, 1.0/GLASS);\n    \n    vec3 p2 = p + 2.0 * refraction * dot(sphere.center - p, refraction);\n    vec3 normal2 = normalize(sphere.center - p2);\n\tvec3 ray2 = refract(refraction, normal2, GLASS);                  \n    \n    vec4 refraction_pixel = texture(iChannel0, animate(ray2));    \n    \n    refraction_pixel = innerColor;\n    \n    \n    float fresnel = -dot(ray, normal);\n    \n    return mix(reflection_pixel, refraction_pixel, fresnel);\n}\n\nbool intersectSphere(in vec3 origin, in vec3 ray, in Sphere sphere, out vec3 col1, out vec3 col2) {\n\n    vec3 p1 = origin + ray * dot(ray, sphere.center - origin);\n\n    float H = length(p1-sphere.center);    \n    float h = sqrt(sphere.radius*sphere.radius - H*H);\n    \n    col1 = p1 - ray * h;\n    col2 = p1 + ray * h;    \n    \n    return H<sphere.radius;\n}\n\nvec3 animate(vec3 ray) {\n\n    float animSpeed = 0.05;\n\n    float c = cos(iTime*animSpeed);\n    float s = sin(iTime*animSpeed);\n\n    mat3 rotation = mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));\n\n    return ray * rotation;\n}\n\nvec4 run(in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 eye = vec3(0);\n    vec3 ray = normalize(vec3(uv, 1.0));    \n    vec3 light = vec3(5.0*cos(iTime*0.5), 3.0, 0.0);\n    vec3 p1, p2;\n\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 8.0), 2.0);\n    \n    if(intersectSphere(eye, ray, sphere, p1, p2)) {\n    \n        vec3 m = p1;\n    \n        vec4 innerColor = vec4(0);\n        \n        vec3 normal = normalize(p1 - sphere.center);\n        vec3 refraction = refract(ray, normal, 1.0/GLASS);\n    \n        if(rayMarching(p1, refraction, m)) {\n            vec3 normal = computeNormal(m);\n            innerColor = computeInnerColor(refraction, m, normal, light, eye);\n        }\n        else {\n            innerColor = texture(iChannel0, animate(ray));\n        }\n     \n       return render(sphere, p1, eye, ray, light, innerColor);\n    }\n    else {\n        return texture(iChannel0, animate(ray));//vec4(0.75);//\n    }\n}\n    \n#define SUPERSeAMPLING\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    #ifdef SUPERSAMPLING\n    // 3x3 supersampling\n    for(float dx=-0.5; dx<=0.5; dx+=0.5) {\n    \tfor(float dy=-0.5; dy<=0.5; dy+=0.5) {\n            fragColor += run(fragCoord + vec2(dx, dy));\n        }\n    }\n    \n    fragColor /= 9.0;\n    \n    #else\n    fragColor = run(fragCoord);\n    #endif\n} \n    \n\n    \n","name":"Image","description":"","type":"image"}]}