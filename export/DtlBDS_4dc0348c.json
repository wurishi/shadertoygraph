{"ver":"0.1","info":{"id":"DtlBDS","date":"1693409881","viewed":153,"name":"Goldbear Family","username":"denosya","description":"Exercice for a still image contest. ","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["jelly","goldbear","haribo"],"hasliked":0,"parentid":"clfBWB","parentname":"Goldbear v0.09 (noise)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CAMERA_DIST = 40.;\nconst float ZFAR = 100.0;\nconst float BACKGROUND_Z = 12.;\nconst float GUM_REFRACTION = 1.05;\nconst float SHADOW_INTENSITY = 0.75;\nconst float SHADOW_COLOR_INTENSITY = 0.66;\nconst vec3  frontlight = vec3(-5,5,-48);\n\nconst vec3 BEAR_COLOR0 = vec3(252., 128., 12.)/255.;\nconst vec3 BEAR_COLOR1 = vec3(249., 230., 30.)/255. * 0.9;\nconst vec3 BEAR_COLOR2 = vec3(146., 205., 47.)/255.;\n\n#define SUB(a,b) max(a,-b)\n#define ADD(a,b) min(a,b)\n#define INTER(a,b) max(a,b)\n\n\n\nmat3 rotX(float angle) { float cosa = cos(angle); float sina = sin(angle); return mat3(vec3(1., 0., 0.), vec3(0., cosa, sina), vec3(0., -sina, cosa));}\nmat3 rotY(float angle) { float cosa = cos(angle); float sina = sin(angle); return mat3(vec3(cosa, 0., sina), vec3(0., 1., 0.), vec3(-sina, 0., cosa));}\nmat3 rotZ(float angle) { float cosa = cos(angle); float sina = sin(angle); return mat3(vec3(cosa, sina, 0.), vec3(-sina, cosa, 0.), vec3(0., 0., 1.));}\n\nvec2 angularSymmetry(vec2 m, float slice, float phase) {\n  float angle = atan(m.y, m.x);\n  angle = mod(angle-phase, slice) + phase;\n  return length(m) * vec2(cos(angle), sin(angle));\n}\n\nfloat sdEllipsoid(vec3 m, vec3 r) {\n    float k = length(m/r);\n    return (k-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdRoundedCone(vec3 m, float r1, float r2, float h) {\n\n  // test side first\n  vec2 A = vec2(r1, 0.);\n  vec2 B = vec2(r2, h);\n\n  vec2 AB = B-A;\n\n  vec2 P = vec2(length(m.xz), m.y);  \n\n  if(dot(B-A, P-A) < 0.) {\n\n    // cap2\n    float truncated = r2*h/(r1-r2);\n    float alpha = atan(r2, truncated);    \n  \n    float L2 = (h + truncated) / cos(alpha);\n    float H2 = L2 / cos(alpha);\n    float R2 = sqrt(H2*H2-L2*L2);\n\n    float cap2 = length(m - vec3(0., -(H2 - h - truncated), 0.)) - R2;\n\n      return cap2;     \n  }\n\n  if(dot(A-B, P-B) < 0.) {\n  \n      // cap1\n      float truncated = r2*h/(r1-r2);\n      float alpha = atan(r2, truncated);\n\n      float L1 = length(vec2(truncated, r2));\n\n      float H1 = L1 / cos(alpha);\n      float R1 = sqrt(H1*H1-L1*L1);\n\n      return length(m - vec3(0., h + truncated - H1, 0.)) - R1;\n  };\n  \n  vec2 ext = P-A;   \n  vec2 normal = normalize(vec2(AB.y, -AB.x));\n  \n  return dot(normal, ext);\n}\n\n\n#define DIST_TO_CORNER(a, r) sqrt(r/sin((a)*0.5)*r/sin((a)*0.5) - r*r) \n\n\nvec3 transfo(vec3 m, float rx, float ry, float rz, float x, float y, float z) {\n    \n    mat3 rotation = rotX(rx) * rotY(ry) * rotZ(rz);\n    vec3 translation = vec3(x, y, z);\n    \n    return transpose(rotation) * (m - translation);\n}\n\nconst float Y_OFFSET = -10.;\nconst float PAW_SPACING = 5.;\nconst float PAW_HEIGHT = 12.;\nconst float HEAD_Y = 22.;\nconst float HEAD_Z = 2.;\nconst vec3  EYE_POS = vec3(-2.5, 12.5, -4.1);\nconst vec3  EAR_POS = vec3(6.0, 16., 1.);\nconst float DETAIL_K = 3.0;\nconst float MASS_K = 1.0;\n \nfloat smin( float a, float b, float k) {\n\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res)/k  ;\n}\n\nfloat intermittentSignal(float duration, float pause, float shift) {\n    float t = mod(iTime+shift, duration+pause);\n    return max(0., (t - pause) / duration);\n}\n\nfloat eyeAnim(int id) {\n\n    float t1 = intermittentSignal(0.5, 3.,0.);\n    float t2 = intermittentSignal(0.25, 7.,0.);    \n    \n    float t = max(t1, t2);\n    \n    return t;\n}\n\n\nfloat earAnim(int id) {\n    switch(id) {\n        case 0: return sin(intermittentSignal(0.5, 5.,0.)*6.28*1.)*0.2;\n        case 2: return sin(intermittentSignal(0.5, 5.,3.)*6.28*1.)*0.2;\n        case 1: return sin(intermittentSignal(2., 10.,0.)*6.28*3.)*0.2;\n    }\n}\n\nfloat pawAnim(int id) {\n    switch(id) {\n        case 1: return sin(intermittentSignal(2., 3.,0.)*6.28*2.)*0.2;\n    }\n    \n    return 0.;\n}\n\nfloat headAnim(int id) {\n    switch(id) {\n        case 0: return cos(iTime * 0.25) * 0.4;\n        case 2: return sin(iTime * 0.25) * 0.3;\n        case 1: return cos(iTime) * 0.2;\n    }\n}\n\nfloat goldBear(vec3 m, int id) {\n\n    float paw1 = sdRoundedCone(transfo(m, -1.5, 0.0, 0., -PAW_SPACING*0.9, Y_OFFSET+3., 0.), 6., 4., 5.);\n    float paw2 = sdRoundedCone(transfo(m, -1.5, 0., 0.,  PAW_SPACING*0.9, Y_OFFSET+3., 0.), 6., 4., 5.);    \n    float paw3 = sdRoundedCone(transfo(m, -1.5, 0., 0., -PAW_SPACING, Y_OFFSET+PAW_HEIGHT, 0.), 5., 3., 4.);\n    float paw4 = sdRoundedCone(transfo(m, -1.5+pawAnim(id), 0., 0.,  PAW_SPACING, Y_OFFSET+PAW_HEIGHT, 0.), 5., 3., 4.);    \n\n    float paws = smin(smin(paw1, paw2, MASS_K), smin(paw3, paw4, MASS_K), MASS_K*0.8);\n\n    vec3 headm = transfo(m, 0.0, 0.0, headAnim(id), 0., HEAD_Y+Y_OFFSET, HEAD_Z);\n    float head = sdEllipsoid(headm, vec3(8.5, 8., 5.));\n    \n    float eye1 = sdEllipsoid(transfo(headm, 0., 0., 0., -EYE_POS.x, EYE_POS.y + Y_OFFSET, EYE_POS.z), 0.9*vec3(1.3, 1.3, 0.6));     \n    float eye2 = sdEllipsoid(transfo(headm, 0., 0., 0., +EYE_POS.x, EYE_POS.y + Y_OFFSET, EYE_POS.z), 0.9*vec3(1.3, 1.3, 0.6));         \n    float nose = sdEllipsoid(transfo(headm, 0., 0., 0., 0., EYE_POS.y - 2.2 + Y_OFFSET, EYE_POS.z), vec3(1., 1., 0.6));             \n\n    float headDetails = min(eye1, eye2);//min(min(eye1, eye2), nose);\n\n    head = smin(head, headDetails, 10.);    \n\n    float ear1 = sdEllipsoid(transfo(headm, earAnim(id), 0., 0., -EAR_POS.x, EAR_POS.y + Y_OFFSET, EAR_POS.z), vec3(2., 1.8, 1.));     \n    float ear2 = sdEllipsoid(transfo(headm, earAnim(id), 0., 0., +EAR_POS.x, EAR_POS.y + Y_OFFSET, EAR_POS.z), vec3(2., 1.8, 1.));         \n\n    float body = smin(head, paws, MASS_K);\n    float body_and_ears = min(smin(body, ear1, DETAIL_K), smin(body, ear2, DETAIL_K));\n    \n    return body_and_ears;\n}\n\nconst float MARCH_THR = 0.05;\nconst float MOTHER_SCALE = 0.85;\nconst float CUB_SCALE = 0.5;\n\n\nfloat map(vec3 m, int id) {\n\n    if(id == 0) {\n        vec3 m0 = transfo(m, -0.2, 0.5, 0., -12., 0., 0.);\n        return goldBear(m0, 0);    \n    }\n\n    if(id == 1) {\n        vec3 m1 = transfo(m, -0.2, -0.4, 0., 8., -5., -4.) / CUB_SCALE;\n        return min(goldBear(m1, 1) * CUB_SCALE, 30.);  // serious problem here > to fix\n    }\n    \n    vec3 m2 = transfo(m, -0.2, -0.6, 0., 15., 0., 0.) / MOTHER_SCALE;\n    return min(goldBear(m2, 2) * MOTHER_SCALE, 30.);    \n}\n\nfloat DEBUG;\n\n\nbool rayMarching(in vec3 ro, in vec3 rd, out vec3 m, int id) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<50; i++) {\n        \n        m = ro + rd * marchingDist;    \n        \n    \tfloat dist = map(m, id);\n        \n        if(dist < MARCH_THR) {\n        DEBUG = dist;\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= ZFAR) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\n\nvec3 hash33(vec3 p) {\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\n/*\nvec3 surfaceNoise(vec3 p) {\n\n    const float randomness = 0.85;\n    const float noiseScale = 20.;\n    const float noiseIntensity = 0.051;    \n    \n    float xrand = smoothstep(randomness, 1., perlin(p*noiseScale + 156.))*noiseIntensity;\n    float yrand = smoothstep(randomness, 1., perlin(p*noiseScale + 258.))*noiseIntensity;\n    float zrand = smoothstep(randomness, 1., perlin(p*noiseScale + 312.))*noiseIntensity;\n    \n    return vec3(xrand, yrand, zrand);\n}\n*/\n\nvec3 computeNormal(vec3 pos, int id) {\n\n    vec3 eps = vec3( 0.1, 0.0, 0.0 );\n    \n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy, id) - map(pos-eps.xyy, id),\n\t     map(pos+eps.yxy, id) - map(pos-eps.yxy, id),\n\t     map(pos+eps.yyx, id) - map(pos-eps.yyx, id));\n         \n  //  nor += surfaceNoise(pos);\n         \n\treturn normalize(nor);\n}\n\nfloat smoothedSquare() {\n    return 4.f * atan(sin(iTime*0.5f)/0.2f);\n}\n\nfloat shadowMarching(vec3 ro, vec3 rd, int id, float k) {\n\n    const float maxd = 100.0;\n    float marchingDist = 0.0;\n    \n    vec3 m;\n    \n    float shadow = 1.;\n    \n    for(int i = 0; i<80; i++) {\n    \n        m = ro + rd * marchingDist;    \n        \n    \tfloat dist = map(m, id);\n        \n        if(dist < 0.01) {\n            return 0.;\n        }\n        else {\n            marchingDist += dist;\n            \n            shadow = min(shadow, k*dist/marchingDist); \n            \n            if(marchingDist >= maxd) {\n                break;\n            }\n        }\n    }\n    \n\treturn shadow;    \n}\n\n\n\nfloat binaryRandom(vec2 v) {\n    return sign(sin(12345. * sin(12345. * length(floor(v)))));\n}\n\nvec3 _pattern(vec2 uv) {\n\n    // temporary, inspired by https://www.shadertoy.com/view/4td3D7\n    const float patternScale = 40.;\n    const float gradientSize = 1.25;\n    const vec3  baseColor = vec3(0.66,0.,0.);\n    const float lineThickness = 15.;\n    \n\tvec2 p = (uv + 1.) * patternScale; \n\tfloat direction = p.y + p.x * binaryRandom(p);\n\t\n\tfloat background = cos(uv.x*gradientSize)*cos(uv.y*gradientSize);\n\tfloat grove = 1. / (abs(cos(3.1415 * direction)) * lineThickness);\n\n    return clamp(vec3(background) - (vec3(1.) - baseColor) * grove, 0., 1.);\n}\n\nvec3 shadowColor(float shadow, vec3 baseColor) {\n    vec3 negativeColor = vec3(1.) - baseColor * SHADOW_COLOR_INTENSITY;\n    return negativeColor * SHADOW_INTENSITY * (1. - pow(shadow, 1.));\n}\n\nvec4 background(vec3 ro, vec3 rd, vec3 frontlight, bool blur) {\n\n    const float projectionScale = 0.01;\n\n    vec3 wall = ro + rd * ((BACKGROUND_Z-ro.z)/rd.z);\n    vec2 uv = vec2(wall.x, wall.y) * projectionScale;\n\n    float eps = 0.0015;\n\n    vec3 pattern = blur ? vec3(0) : _pattern(uv);\n\n    if(blur) {\n        for(float y=-2.; y<=2.; y=y+1.) {\n            for(float x=-2.; x<=2.; x=x+1.) {\n                 pattern += _pattern(uv + vec2(x*eps, y*eps));\n            }\n        }\n\n        pattern /= 25.;\n    }\n\n    vec3 light = normalize(frontlight - wall);\n\n    float shadow0  = shadowMarching(wall, light, 0, 20.);\n    vec3 penombra1 = shadowColor(shadow0, BEAR_COLOR0);\n\n    float shadow1 = shadowMarching(wall, light, 1, 20.);\n    vec3 penombra2 = shadowColor(shadow1, BEAR_COLOR1);\n\n    float shadow2 = shadowMarching(wall, light, 2, 20.);\n    vec3 penombra3 = shadowColor(shadow2, BEAR_COLOR2);\n\n    vec3 penombra = max(penombra1, max(penombra3, penombra2));\n\n    return vec4(pattern - penombra, 1);\n}\n\nvec3 candyRender(vec3 m, vec3 rd, vec3 frontlight, vec3 backlight, vec3 normal, vec3 color, float normalScattering) {\n\n    vec3 frontlightDir = normalize(m - frontlight);\n\n    float diffuse = max(0., dot(-frontlightDir, normal));\n    float distorsion = normalScattering;\n    vec3 outlight = normalize(backlight + normal * distorsion);\n    float scatter = clamp(dot(-rd, outlight), 0.0, 1.0) * 1.1;\n\n    vec3 H = normalize(frontlightDir+rd);\n    float highlight = pow(max(0.0,dot(-H, normal)), 100.) * 0.97;\n\n    float fakeShadow = 0.5 + smoothstep(0., 1., dot(rd, -normal)) * 0.5; \n\n    return color * (0.15 + scatter*1.25) * fakeShadow + highlight;\n}\n\nvec3 computeRefraction(vec3 rd, vec3 normal) {\n    vec3 refraction = refract(rd, normal, GUM_REFRACTION);\n    if(length(refraction) <= 0.) refraction = reflect(rd, normal);\n    \n    return refraction;\n}\n\nvec4 run(vec2 fragCoord) {\n\n    const bool HORIZONTAL_MODE = false;\n\n    vec3 m;\n    vec2 uv;\n    vec3 camera = vec3(0, 1., -CAMERA_DIST);\n    vec3 ro = camera;\n    vec3 rd;\n\n    if(HORIZONTAL_MODE) {\n        uv = (fragCoord.yx - iResolution.yx * 0.5) / iResolution.y;    \n        uv.x = -uv.x;        \n        rd = normalize(vec3(uv.xy, 0.65));\n    }\n    else {\n        uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n        rd\t= normalize(vec3(uv.xy, 0.85));\n    }\n\n    vec3 backlight = normalize(vec3(0,0,-1));\n\n    if(rayMarching(ro, rd, m, 0)) {\n    \n        vec3 normal = computeNormal(m, 0);\n        vec3 bear0Render = candyRender(m, rd, frontlight, backlight, normal, BEAR_COLOR0, -0.8) ;\n        vec3 refraction = computeRefraction(rd, normal);\n\n        return mix(vec4(bear0Render, 1.), background(m, refraction, frontlight, true), 0.2);\n    }\n    else {\n       if(rayMarching(ro, rd, m, 1)) {\n\n            vec3 normal = computeNormal(m, 1);\n            vec3 bear1Render = candyRender(m, rd, frontlight, backlight, normal, BEAR_COLOR1, -0.866) ;\n\n            vec3 m2;\n\n            if(rayMarching(ro, rd, m2, 2)) {\n                vec3 normal = computeNormal(m2, 2);\n                vec3 bear2Render = candyRender(m2, rd, frontlight, backlight, normal, BEAR_COLOR2, -0.8);\n\n                return vec4(mix(bear1Render, bear2Render, 0.15), 1.);\n            }\n            else {\n                vec3 refraction = computeRefraction(rd, normal);            \n                return mix(vec4(bear1Render, 1.), background(m, refraction, frontlight, true), 0.2);\n            }\n        }\n        else {\n            if(rayMarching(ro, rd, m, 2)) {\n\n                vec3 normal = computeNormal(m, 2);\n                vec3 bear2Render = candyRender(m, rd, frontlight, backlight, normal, BEAR_COLOR2, -0.8);\n\n                vec3 refraction = computeRefraction(rd, normal);            \n                return mix(vec4(bear2Render, 1.), background(m, refraction, frontlight, true), 0.2);\n            }\n        }\n    }\n\n    return background(ro, rd, frontlight, false);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    fragColor = run(fragCoord); return;\n\n    fragColor = vec4(0);\n    \n    // 3x3 supersampling\n    for(float dx=-0.5; dx<=0.5; dx+=0.5) {\n    \tfor(float dy=-0.5; dy<=0.5; dy+=0.5) {\n            fragColor += run(fragCoord + vec2(dx, dy));\n        }\n    }\n    \n    fragColor /= 9.0;\n} \n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float fade(float f) {\n    return f*f*f*(f*(f*6.-15.)+10.);    \n}\n\nint hash13(vec3 p3) { //shadertoy.com/view/4djSRW\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return int(fract((p3.x + p3.y) * p3.z)*8.);\n}\n\nconst vec3 normals[] = vec3[] (vec3(1,1,1), vec3(1,1,-1), vec3(1,-1,1), vec3(1,-1,-1), vec3(-1,1,1), vec3(-1,1,-1), vec3(-1,-1,1), vec3(-1,-1,-1));\n\nfloat perlin(vec3 uv) {\n\n    vec3 index0 = floor(uv);\n    vec3 index1 = index0 + vec3(1,0,0);\n    vec3 index2 = index0 + vec3(1,0,1);\n    vec3 index3 = index0 + vec3(0,0,1);\n    vec3 index4 = index0 + vec3(0,1,0);\n    vec3 index5 = index0 + vec3(1,1,0);\n    vec3 index6 = index0 + vec3(1,1,1);\n    vec3 index7 = index0 + vec3(0,1,1);\n\n    vec3 norm0 = normals[hash13(index0)];\n    vec3 norm1 = normals[hash13(index1)];\n    vec3 norm2 = normals[hash13(index2)];\n    vec3 norm3 = normals[hash13(index3)];\n    vec3 norm4 = normals[hash13(index4)];\n    vec3 norm5 = normals[hash13(index5)];\n    vec3 norm6 = normals[hash13(index6)];\n    vec3 norm7 = normals[hash13(index7)];\n    \n    vec3 localCoords = fract(uv);\n\n    float d0 = dot(uv - index0, norm0);\n    float d1 = dot(uv - index1, norm1);\n    float d2 = dot(uv - index2, norm2);\n    float d3 = dot(uv - index3, norm3);\n    float d4 = dot(uv - index4, norm4);\n    float d5 = dot(uv - index5, norm5);\n    float d6 = dot(uv - index6, norm6);\n    float d7 = dot(uv - index7, norm7);    \n    \n    vec3 lerp = vec3(fade(localCoords.x), fade(localCoords.y), fade(localCoords.z));    \n    \n    float l01 = mix(d0, d1, lerp.x);\n    float l32 = mix(d3, d2, lerp.x);    \n    float l45 = mix(d4, d5, lerp.x);        \n    float l76 = mix(d7, d6, lerp.x);            \n\n    float l0145 = mix(l01, l45, lerp.y);\n    float l3276 = mix(l32, l76, lerp.y);    \n\n    return mix(l0145, l3276, lerp.z);\n}\n\n\n","name":"Common","description":"","type":"common"}]}