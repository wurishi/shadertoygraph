{"ver":"0.1","info":{"id":"MXjXDh","date":"1710555558","viewed":130,"name":"fork-Smoke on the Water","username":"jorge2017a2","description":"Modificado por Jorge2017a2---jorgefp\nhttps://www.youtube.com/watch?v=Q05EbmfEWwY\nReferencia ollerich, reinder, Iq,gaz.\n","likes":11,"published":1,"flags":8,"usePreview":0,"tags":["piano","forks","smokeonthewater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---por jorge2017a1 ----jorgeFP.\n//---15-marzo-2024---\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),0.,d - (b) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat opSmoothMin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec3 guitarra(vec2 p, vec3 col)\n{\n    float r1=0.85;\n    vec2 pos=vec2(1.87,1.74);\n    float d1= sdCircle(p-pos,r1);\n    \n    float r2=0.55;\n    pos=vec2(2.98,2.35);\n    float d2= sdCircle(p-pos,r2);\n    \n    float dfin=opSmoothMin(d1,d2,0.4);\n    \n    //float dfin=min(d1,d2);\n    dfin=abs(dfin)-0.01;\n    col=  DrawFigDelgado(vec3(0.0), col, dfin);\n    \n    float r3=0.25;\n    pos=vec2(2.53,2.06);\n    float d3= sdCircle(p-pos,r3);\n    col=  DrawFigDelgado(vec3(0.0), col, d3);    \n    \n    pos=vec2(3.824,1.76);\n    vec2 med=vec2(0.17,1.765);\n    float ang;\n    ang = 63. * PI / 180.0;\n    vec2 pr = Rotate(p- pos, med/2.0, ang);\n    float d4 = sdBox(pr, med);\n    d4=abs(d4)-0.01;\n    col=  DrawFigDelgado(vec3(0.0), col, d4);\n\n\n     pos=vec2(1.4,1.34);\n     med=vec2(0.27,0.045);\n    ang = 63. * PI / 180.0;\n    pr = Rotate(p- pos, med/2.0, ang);\n    float d6 = sdBox(pr, med);\n    col = DrawFigDelgado(vec3(0.0), col, d6);\n\n\n\nvec2 A,B;\nA= vec2(1.66,1.534);\nB= vec2(4.75,3.1);\n\nfloat d7=sdSegment(p,B,A);\ncol = DrawFigDelgado(vec3(0.0,0.0,1.0),col,d7);\n\n\nA= vec2(1.67,1.63);\nB= vec2(4.77,3.2);\nfloat d8=sdSegment(p,A,B);\ncol = DrawFigDelgado(vec3(0.0,0.0,1.0),col,d8);\n\n\nA= vec2(1.7,1.7);\nB= vec2(4.83,3.3);\nfloat d9=sdSegment(p,A,B);\ncol = DrawFigDelgado(vec3(0.0,0.0,1.0),col,d9);\n\n\nfloat he;\nr1=0.3;\nr2=0.15;\nhe=0.41;\n pos=vec2(4.8,3.38);\nang = -120.0 * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\nfloat d10= sdTrapezoid(pr, r1, r2, he);\nd10=abs(d10)-0.01;\ncol = DrawFigBorde(vec3(1.0),col,d10);\n\n\n\nA= vec2(4.94,2.66);\nB= vec2(5.3,2.49);\nfloat d11=sdSegment(p,A,B);\ncol = DrawFigDelgado(vec3(0.0,0.0,1.0),col,d11);\n\n\nA= vec2(5.02,2.8);\nB= vec2(5.44,2.65);\nfloat d12=sdSegment(p,A,B);\ncol = DrawFigDelgado(vec3(0.0,0.0,1.0),col,d12);\n\n\nA= vec2(4.78,2.47);\nB= vec2(5.24,2.2);\nfloat d13=sdSegment(p,A,B);\ncol = DrawFigDelgado(vec3(0.0,0.0,1.0),col,d13);\n\n    return col;\n}\n\nfloat random(float pp) \n{\n    float p=pp;\n\tp = fract(p * 0.2031);\n\tp *= p + 66.66;\n\tp *= p + 33.33;\n\treturn fract(p*1.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(-0.15,-0.5);\n    float esc=4.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    \n    float t=iTime;\n    vec3 col=vec3(1.0);\n    float mul= random(uv.y*(0.5+0.5*sin(t*sin(t*0.5))) );\n    \n    vec3 colf=vec3(1.0)*mul;\n    \n    col= guitarra(uv,col);\n    col= guitarra(vec2(-uv.x, uv.y),col);\n    \n    col= guitarra(uv*sin(iTime)+vec2(-0.5,0.25),col );\n    \n    col= guitarra(uv*vec2(-sin(iTime),sin(iTime)-vec2(0.0,0.5))+vec2(0.5,-0.25),col );\n    col*=colf;\n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Modificado por Jorge2017a2---jorgefp\n//https://www.youtube.com/watch?v=Q05EbmfEWwY\n\n///Referencia ollerich, reinder, Iq,gaz.\n\n\nconst float ttotal=18.0;\n\n\n#define PI acos(-1.)\n#define PIH (PI*.5)\n#define TAU (PI*2.)\n#define TWO_PI 6.2831\n//const float PI = 3.1415926;\n\n#define DD(a,b) n=(s>=a)? vec2(a,b):n;\n//#define D3(a,b,c) n3=(s>=a && s<=c)? vec3(a,b,c):n3;\n//spalmer correccion\n#define D3(a,b,c) n3=(s>=(a) && s<=(a)+(c))? vec3(a,b,c):n3;  \n\n\nconst float pi = 3.1415927;\nconst float tau = 6.283185;\nconst float MIDIOFFSET = 69.0;\n#define PIH (PI*.5)\n\nstruct tsynth\n{\n float phase;\n float prev;\n float vibe;\n};\n\nstruct tditty\n{\n    float dt;\n    float bpm;\n};\n\nstruct tenv\n{\n    float value;\n};\n\nstruct tbass\n{ float phase; };\n\n\nstruct TNote\n{  vec2 note; float duration; };\n\n\nstruct Tstrat\n{  float t; float iom ; float mul; };\n\n\nstruct Tfilter\n{  vec2 hist0; vec2 hist1;float t; };\n\nTstrat strat;\nTfilter lowpass;\n\ntsynth thiss;\ntditty ditty;\ntenv envv;\ntbass thisb;\nfloat dt;\nTNote riff;\n\n\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat random(float pp) \n{\n    float p=pp;\n\tp = fract(p * 0.2031);\n\tp *= p + 66.66;\n\tp *= p + 33.33;\n\treturn fract(p*1.1);\n}\n\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn 440.0 * exp2((note - MIDIOFFSET) / 12.0);\n}\n\n// MIDI note to frequency formula\nfloat midi_to_hz(float note) {\n\treturn 440.0 * exp2((note - MIDIOFFSET) / 12.0);\n}\n\nTstrat inicStrat()\n{\n    Tstrat thiss;\n    thiss.t = 0.0;\n    thiss.iom = 13.37;\n    thiss.mul = 0.251;\n    return thiss;\n}\n\n\nTfilter inicFilter()\n{\n    Tfilter thiss;    \n    thiss.hist0 = vec2(0.0,0.0);\n    thiss.hist1 = vec2(0.0, 0.0);\n    thiss.t = 0.0;\n    return thiss;\n}\n\nfloat add_fm(float note ,tenv env, Tstrat thiss) \n{       // carrier frequency\n        float fc = midi_to_hz(note);\n        // modulator frequency\n        float fm = fc * thiss.mul;\n        return sin( TAU*thiss.t*fc + thiss.iom*sin(TAU*thiss.t*fm) ) * env.value;\n}\n\n\nvec2 processFm(float note,tenv env,float tick,Tstrat thiss) \n{   // forward time\n        thiss.t += ditty.dt;\n        // overdrive the oscillators\n        float gain = 5.0;\n\n        // create power-chord, i.e. perfect fifth \n        float osc = add_fm(note, env,thiss) * gain;\n        osc +=  add_fm(note+7.0, env,thiss) * gain;\n        \n        // clip\n        osc = osc < -1.0 ? -1.0 : osc > 1.0 ? 1.0 : osc;\n        return vec2(osc, osc); // left, right\n}\n    \n\nfloat envelope( float a,float d,float s,float r,float du,float t)\n{  float res;\n\n if( t < a)\n {   // From t=0 to t=a (attack period)\n    res= t / a; // the volume increases from 0.0 to 1.0\n }\n else if( t < a + d) // From t=a to t=d (decay period)\n {  res= 1.0 - ((t - a) / d) * (1.0 - s); // the volume decreases from 1.0 to s (sustain)  \n }  \n else if( t < du) // From t=d to t=du (sustain period)\n {    res=s; // the volume stays constant at s (sustain)  \n }\n else if( t < du + r) // From t=du to t=du+r (release period)\n {  res=(1.0 - (t - du)\n    / r) * s; // release\n }\n else\n {   res=0.0; // After that, the volume is 0.0.\n }\n  return res;\n} \n\n\nfloat tick_to_second(float t)\n{ return t * 60.0 / ditty.bpm; }\n\n\nfloat  second_to_tick(float t)\n{  return t * ditty.bpm / 60.0;}  \n\nfloat wave1( float time , float pnote, float pdur)\n{   ditty.bpm = 120.0;\n    strat=inicStrat();\n    //lowpass= inicFilter();\n    \n    riff.note=vec2(pnote,pdur);\n    \n    float duration=riff.duration;\n    float tick=0.5;\n    \n    float ds = 0.25 * duration;\n    float dt = second_to_tick(ds);\n    float attack;\n    float decay;\n    float sustain;\n    float release;\n    float amp;\n    \n    attack= 0.01;\n    decay= ds;\n     //duration= dt;\n    amp= 0.7;\n    \n    float note=pnote;\n    \n    ditty.dt=time;\n    envv.value= envelope(attack, decay,0.425, amp,duration,time );\n   vec2 res= processFm(note,envv,tick,strat);\n    \n   return res.x;  \n    \n}\n\n\nfloat SoundIq(float time)\n{ ///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal);\n  float tempo = 0.5; //0.5\n  float s = time*tempo;\n vec3 n3=vec3(0.0);\n \n /*\n D3(0.,50.,0.25) D3(0.,55.,0.25) D3(0.25,53.,0.5) D3(0.25,58.,0.5) D3(0.5,55.,0.75) D3(0.5,60.,0.75)\n D3(0.875,50.,1.) D3(0.875,55.,1.) D3(1.125,53.,1.375) D3(1.125,58.,1.375) D3(1.375,56.,1.5) D3(1.375,61.,1.5)\n D3(1.5,55.,2.) D3(1.5,60.,2.) D3(2.,50.,2.25) D3(2.,55.,2.25) D3(2.25,53.,2.5) D3(2.25,58.,2.5)\n D3(2.5,55.,2.875) D3(2.5,60.,2.875) D3(2.875,53.,3.125) D3(2.875,58.,3.125) D3(3.125,50.,3.875) D3(3.125,55.,3.875)\n D3(3.875,50.,4.125) D3(3.875,55.,4.125) D3(4.125,53.,4.375) D3(4.125,58.,4.375) D3(4.375,55.,4.625) D3(4.375,60.,4.625)\n D3(4.875,50.,5.) D3(4.875,55.,5.) D3(5.125,53.,5.375) D3(5.125,58.,5.375) D3(5.375,56.,5.625) D3(5.375,61.,5.625)\n D3(5.625,55.,6.125) D3(5.625,60.,6.125)\n */\n \n  D3(0.,50.,0.25) D3(0.,55.,0.25) D3(0.25,53.,0.5) D3(0.25,58.,0.5) D3(0.5,55.,0.75) D3(0.5,60.,0.75)\n D3(0.875,50.,1.) D3(0.875,55.,1.) D3(1.125,53.,1.375) D3(1.125,58.,1.375) D3(1.375,56.,1.5) D3(1.375,61.,1.5)\n D3(1.5,55.,2.) D3(1.5,60.,2.) D3(2.,50.,2.25) D3(2.,55.,2.25) D3(2.25,53.,2.5) D3(2.25,58.,2.5)\n D3(2.5,55.,2.875) D3(2.5,60.,2.875) D3(2.875,53.,3.125) D3(2.875,58.,3.125) D3(3.125,50.,3.875) D3(3.125,55.,3.875)\n D3(3.875,50.,4.125) D3(3.875,55.,4.125) D3(4.125,53.,4.375) D3(4.125,58.,4.375) D3(4.375,55.,4.625) D3(4.375,60.,4.625)\n D3(4.875,50.,5.) D3(4.875,55.,5.) D3(5.125,53.,5.375) D3(5.125,58.,5.375) D3(5.375,56.,5.625) D3(5.375,61.,5.625)\n D3(5.625,55.,6.125) D3(5.625,60.,6.125) D3(6.25,50.,6.375) D3(6.25,55.,6.375) D3(6.5,53.,6.75) D3(6.5,58.,6.75)\n D3(6.75,56.,6.875) D3(6.75,61.,6.875) D3(6.875,55.,7.375) D3(6.875,60.,7.375) D3(7.375,50.,7.625) D3(7.375,55.,7.625)\n D3(7.625,53.,7.875) D3(7.625,58.,7.875)\n \n \n  // lower one octave\n  //n3.y -=12.; //12 notas\n      \n  // compute note frequency and time  \n  float f = 440.0*pow( 2.0, float(n3.y-69.)/12.0 );\n  float t = time - float(n3.x)/tempo;\n  if( n3.x==0.0 ) return 0.0;\n\n  float f1;\n  f1=wave1(t,n3.y, n3.z);\n  \nreturn f1;\n}\n\nvec2 mainSound( in int samp, float time )\n{  float t1=mod(time, ttotal);\n    float y;    \n    y= SoundIq(t1)*0.125; \n  return vec2(y);\n}   \n","name":"Sound","description":"","type":"sound"}]}