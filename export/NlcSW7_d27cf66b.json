{"ver":"0.1","info":{"id":"NlcSW7","date":"1665710823","viewed":120,"name":"Julia Set Uniformization","username":"loveless_savage","description":"click and drag\nmouse corresponds to universal c value\n","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["2d","fractal","juliaset"],"hasliked":0,"parentid":"XldfDS","parentname":"Full Julia Set"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//resolution of each test\n#define RESOL 50\n\n//square a 2D vector as a complex value\nvec2 csq(vec2 z){\n        return vec2( z.x*z.x-z.y*z.y , 2.0*z.x*z.y );\n}\n\n// square root of a complex number\nvec2 csqrt(vec2 z){\n// for mathematical proof: https://math.stackexchange.com/questions/44406/how-do-i-get-the-square-root-of-a-complex-number\n    if(z.y == 0.0) return vec2(0.0,sqrt(length(z))); // doesn't work for negative numbers!\n    // square root of the complex number z takes the form:\n    // √z = (z+|z|) * √|z| / |z+|z||\n    vec2 rootz = vec2(z.x + length(z), z.y);\n    rootz *= sqrt(length(z)) / length(rootz);\n    return rootz;\n}\n\n//given the 4D Julia set coordinates, test for divergence with a certain resolution\nvec2 runTest(vec2 zi, vec2 c){\n    bool cutoff = true;\n    vec2 z = zi;\n\n    int n = 0;\n    while(n<RESOL){\n        if( cutoff && length(z)>2.0 ) break;\n        z = csq(z) + c;\n        n++;\n    }\n    \n    if( length(z)<=2.0 ) return vec2(0.0,0.0);\n    \n    for(int i = 0; i<n; i++){\n        z = csqrt(z);\n    }\n    \n    return z;\n}\n\n//calculate the color of the model given a depth\nvec4 modelColor(float dep){\n    if(length(dep) == 0.0) return vec4(0.0);\n\n    float temp[3] = float[3](0.0,0.0,0.0);\n    float depmod = mod(dep,0.2);\n    if(dep==1.0) {\n        return vec4(0.0);\n    }\n\n    int depnum = int((dep-depmod)*5.0);\n\n    if((depnum&1)>0) depmod = 0.2-depmod;\n\n    temp[(4-depnum) % 3]=5.0*depmod;\n\n    depnum += 1;\n    depnum >>= 1;\n\n    temp[depnum]=1.0;\n\n    return vec4(temp[0],temp[1],temp[2],1.0);\n}\n\n// checkerboard coloring\nvec4 checkerboard(vec2 uz, float width){\n    // eliminate the filled in set\n    if(length(uz) == 0.0) return vec4(0.0);\n    \n    // find checkerboard position using step function\n    vec2 check = floor(uz/width);\n    \n    if( mod(check.x + check.y, 2.0) == 0.0 ){\n        return vec4(0.8);\n    }else{\n        return vec4(0.3);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Adjusted pixel coordinates; transform to window of Mandelbrot Set\n    vec2 z = 2.0*fragCoord.xy-iResolution.xy;\n    vec2 c = 2.0*iMouse.xy-iResolution.xy;\n    z *= 2.0/min(iResolution.x,iResolution.y);\n    c *= 2.0/min(iResolution.x,iResolution.y);\n    \n    //Test for divergence\n    vec2 uVal = runTest(z,c);\n\n    // Output to screen\n    fragColor = checkerboard(uVal,0.1);\n}","name":"Image","description":"","type":"image"}]}