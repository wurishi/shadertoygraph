{"ver":"0.1","info":{"id":"NtlyD2","date":"1648731120","viewed":85,"name":"MCG: numerical intersections","username":"tale3d","description":"In this lecture we discuss intersections of geometric primitives.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_NUMERICAL\n\nconst int MAX_MARCHING_STEPS = 128;\nconst int MAX_DICHOTOMY_STEPS = 32;\nconst float EPSILON = 0.0001;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n\n    //Adding more to the common section:\n    //This example has a mouse as an input device.\n    //The mouse coordinates are taking in uv space, and then is modified in the same way\n    //  as the pixel coordinates (see above). \n    vec2 mouse = 2.0*(iMouse.xy / iResolution.xy) - vec2(1.0,1.0);\n    mouse.x *= aspect_ratio;\n\n\n    //Background colour (default)\n    vec3 colour = vec3(1.0,1.0,1.0);\n\n    //Here we define our triangle. \n    // It has three vertices, two with fixed position and third depends on the mouse\n    vec2 p2 = vec2(-0.6,0.5);\n    vec2 p1 = mouse;\n\n\n    //if we are close enough to the points defining the first line, we colour those green\n    if (dot(c-p1, c-p1) < 0.001) colour = vec3(0.0,1.0,0.0);\n    if (dot(c-p2, c-p2) < 0.001) colour = vec3(0.0,1.0,0.0);\n\n    //Direction for the first line\n    vec2 dp1 = p2-p1;\n    \n    //now the implicit equation: we use one of the equations from the lecture\n    float implicit1 = (c.x-p1.x)/dp1.x - (c.y-p1.y)/dp1.y;\n\n    //if it is equal to 0, then we are on our straight line, but as we work with pixels \n    //   which might be slightly off, we use proximity test once again.\n    if (abs(implicit1) < 0.01) colour = vec3(0.0,0.0,0.0);     //Colour the line black.     \n\n    //now draw the circle \n\tfloat circx = sin(iTime), circy = 0.5, circr2 = 0.2;\n    //uing implicit form\n    float circle = (c.x-circx)*(c.x-circx)/circr2 + (c.y-circy)*(c.y-circy)/circr2 - 1.0;\n    if (abs(circle) < 0.01) colour = vec3(0.0,0.0,0.0);     //Colour the line black.     \n        \n    //now line-circle intersection\n    \n#ifdef USE_NUMERICAL    \n    float t0 = 0.0, t1 = 1.0;\n    float dt = (t1-t0)/float(MAX_MARCHING_STEPS);\n    float tn = t0;\n    vec2 pn = p1 + tn*dp1;\n    float fn = (pn.x-circx)*(pn.x-circx)/circr2 + (pn.y-circy)*(pn.y-circy)/circr2 - 1.0;\n    \n    for (int i = 1; i < MAX_MARCHING_STEPS; i++)\n    {\n        float tn1 = tn+dt;\n        vec2 pn1 = p1 + tn1*dp1;\n        float fn1 = (pn1.x-circx)*(pn1.x-circx)/circr2 + (pn1.y-circy)*(pn1.y-circy)/circr2 - 1.0;\n\n        if (fn1*fn < 0.0)\n        {\n            pn1 = (pn+pn1)*0.5;\n            if (dot(c-pn1, c-pn1) < 0.001) colour = vec3(1.0,0.0,0.0);\n//            break;\n        }\n        tn = tn1;\n        pn = pn1;\n        fn = fn1;\n    }\n  \n#else\n    //see the lecture notes: we had quadratic equation as a result of substitution\n    //as*t^2 + bs*t + cs = 0\n    float as = dp1.x*dp1.x+dp1.y*dp1.y;\n    float bs = 2.0*dp1.x*(p1.x-circx)+2.0*dp1.y*(p1.y-circy);\n    float cs = (p1.x-circx)*(p1.x-circx) + (p1.y-circy)*(p1.y-circy) - circr2;\n    float disc = bs*bs-4.0*as*cs; //discriminant\n    if (disc >= 0.0) //if it is negative, no points of intersection\n    {\n        //otherwise we have two intersection points (which might coincide, but we do not care\n        float ts1 = (-bs-sqrt(disc))*0.5/as;\n        float ts2 = (-bs+sqrt(disc))*0.5/as;\n        //from parameters go back to coordinates\n        vec2 pi = p1+ts1*dp1;\n        //as previously, if we have intersection and the current pixel is close enough, paint it red\n        if (dot(c-pi, c-pi) < 0.001) colour = vec3(1.0,0.0,0.0);\n        //...and for the second point\n        pi = p1+ts2*dp1;        \n        if (dot(c-pi, c-pi) < 0.001) colour = vec3(1.0,0.0,0.0);\n    }\n#endif    \n    //That is it, assign the colour to the pixel.\n    fragColor = vec4(colour,1.0);\n\n\n}","name":"Image","description":"","type":"image"}]}