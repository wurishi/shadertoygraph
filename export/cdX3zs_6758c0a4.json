{"ver":"0.1","info":{"id":"cdX3zs","date":"1670871545","viewed":131,"name":"Tiling of hexagons unfolding","username":"Rutilius","description":"An animation of a tiling of hexagons that will unfold itself by opening the triangles of the hexagons.\nIn this shader you can layer a new animation by left click on the screen.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["2d","mouse","triangle","animation","hexagon","hexagon","tiling","memory","unfold","store"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------- {\n// An animation of a tiling of hexagons that will unfold itself by opening the triangles of the hexagons.\n// In this shader you can layer a new animation by left click on the screen.\n//\n// You can change the number of layer modifing MAX_FILLS define in the Common tab\n// You can disable the changing of the color over the life time of the layer by commenting the DECLINE define\n// You can disable the automatic generation of the new layer by commenting the AUTO_CLICK define in the Buffer A tab\n// ---------------------------------------- }\n\n// Define the number of elements visibile at same time\n// ----------------------------------------\n#define TILING 8.\n// Define the speed of the loading animation\n// ----------------------------------------\n#define SPEED 4.\n\n// Define the costants for the final color of the animation\n// ----------------------------------------\n#define COLOR_SATURATION 0.81\n#define COLOR_VALUE 0.71\n\n// Comment DECLINE define to remove the color gradient based on the life time of an unfold layer\n// ----------------------------------------\n#define DECLINE \n// if DECLINE is present define the speed in witch the layer become of the new color values\n// ----------------------------------------\n#define COLOR_DECLINE_SPEED 0.4\n// if DECLINE is present define the end cold values for the decline passage\n// ----------------------------------------\n#define COLOR_DECLINE_SATURATION 0.41\n#define COLOR_DECLINE_VALUE 0.31\n\n// Constans\n// ----------------------------------------\n#define PI 3.1415926535\n#define HEXAGON_TRIANGLE 6.\n#define DEG2RAD 0.0174532925\n// Useful macros\n// ----------------------------------------\n#define antialiasing(n) (n)/min(iResolution.x,iResolution.y)\n#define S(a, t) smoothstep(a, antialiasing(2.) + (a), t)\n#define deg2rad(degree) ((degree) * DEG2RAD)\n#define wrapDegree(degree) (mod(degree, 360.))\n#define rotateDegree(theta, p) (rotate2d(deg2rad(theta)) * (p))\n#define saturate(x) clamp(x, 0., 1.)\n#define inv(f) (1. - (f))\n\n// Common Rotate matrix 2d\n// ----------------------------------------\nmat2 rotate2d(float theta) { return mat2(cos(theta) , sin(theta), -sin(theta), cos(theta)); }\n\n// HSVtoRGB function credit: https://www.chilliant.com/rgb2hsv.html\n// These are functions that get an HSV input in [0, 1] and output a RGB in [0, 1] \n// ---------------------------------------- {\nvec3 HUEtoRGB(float H) {\n    float R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return saturate(vec3(R,G,B));\n}\nvec3 HSVtoRGB(vec3 HSV) {\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\n}\n// ---------------------------------------- }\n\n// Return a equilateral triangle signed distance center-bottom to triangle center-top and a pivot on left-bottom\n// The triangle will be:\n// In the position \"p\",\n// With a lenght of \"l\",\n// With a direction \"d\" where positive means to top and negative means to bottom and 0 will not draw anything\n// ----------------------------------------\nfloat sdOpenTriangle(vec2 p, float l, float d) {\n    float hl = l / 2.;\n    p.x -= hl;\n    p.x = abs(p.x);\n    p.x -= hl;\n    return (atan(sign(-d)*p.y, p.x)+PI)*(PI/3.333333333333);\n}\n\n// Create an parametric open hexagon\n// - Output: \n//     \"x\": a value of the open order in the position that will be [1, 6] values\n//     \"y\": a regular hexagon signed distance formed with triangles that will open in a rotation direction that will be in [0., 1.] values\n// - Intputs:\n//     \"p\" : position of the hexagon,\n//     \"r\" : radius of the hexagon,\n//     \"si\": open starting triangle, is the only one that will open from bottom the input should be inside [1, 6]\n//     \"d\" : direction where positive means counterclockwise and negative means clockwise and 0 will not draw anything\n// ----------------------------------------\nvec2 sdOpenHexagon(vec2 p, float r, int si, float d) {\n    // Initialization of useful values\n    si -= 1;\n    float sdf = 0.;\n    float offsetX = r * .5;\n    float offsetY = r * .867;\n    \n    vec2 offsets[6] = vec2[6](\n        vec2(-offsetX     ,  offsetY ),\n        vec2( offsetX     ,  offsetY ),\n        vec2( offsetX * 2.,       0. ),\n        vec2( offsetX     , -offsetY ),\n        vec2(-offsetX     , -offsetY ),\n        vec2(-offsetX * 2.,       0. )\n    );    \n    \n    vec2 initialOffset = float(d <= 0.) * offsets[si % 6] + float(d >  0.) * offsets[(si + 1) % 6]; \n    float startDegree = float(d <= 0.) * 60. + float(d >  0.) * 120.;\n    \n    float baseDegree = startDegree + float(si * 60);                     \n    float initialDegree = wrapDegree(baseDegree + (sign(d) * 60.));                             \n    \n    // Generate the initial triangle that will start from the extern and end at the center of the Hexagon \n    sdf += saturate(inv(sdOpenTriangle(-1. * rotateDegree(initialDegree, p + initialOffset), r, d)));\n    \n    // Generate the other triangles that will rotate around the hexagon\n    for(float i = 1.; i < HEXAGON_TRIANGLE; i++) {\n        float offsetDegree = sign(-d) * (60. * i); \n        float currentDegree = wrapDegree(baseDegree + offsetDegree);\n                              \n        sdf += saturate(inv(sdOpenTriangle(rotateDegree(currentDegree, p), r, d)));    \n    }\n    \n    // Generate triangle id based on the start triangle and the direction of the open animation\n    vec2 triP = rotateDegree((initialDegree + sign(d) * 30.), p);\n    triP.y *= sign(-d);\n    float at = (atan(triP.x, triP.y) + PI) * 3.;\n    float triIndex = ceil(at / PI);\n    \n    return vec2(triIndex, inv(sdf));\n}\n\n// Return the axes distinct signed distance of a regular hexagon in position \"p\"\n// ----------------------------------------\nvec2 sdHexagonAxes(vec2 p) {\n    p = abs(p);\n    return vec2(max(0., p.x - 0.577 * p.y), max(0., p.y * 1.155));   \n}\n// Return the signed distance of a regular hexagon in position \"p\"\n// ----------------------------------------\nfloat sdHexagon(vec2 p) { \n    vec2 had = sdHexagonAxes(p);\n    return had.x + had.y;\n}\n\n// Create a tiled regualr hexagon coordinate with open signed distance with hexagons rotation varing based on distance from center\n// Outputs: \n// x: id of the triangle of the hexagon [1, 6]\n// y: the open regular hexagon signed distance\n// zw: the id.xy of the current hexagon into the tiling\n// ----------------------------------------\nvec4 sdOpenHexagonsCoords(vec2 uv) {\n    // Generate hexagon coordinate and indeces\n    const vec2 r = vec2(1., 1.732);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n    \n    vec2 gv = dot(a, a) < dot(b, b) ? a : b;\n    vec2 id = uv - gv;\n    vec2 rid = round(id - antialiasing(1.));\n    \n    // Select alternate hexagon to change the rotation direction\n    bool pxpy = rid.x >= 0. && rid.y >= 0.;\n    bool pxny = rid.x >= 0. && rid.y <  0.;\n    bool nxpy = rid.x <  0. && rid.y >= 0.;\n    bool nxny = rid.x <  0. && rid.y <  0.;\n    \n    vec2 ha = sdHexagonAxes(id);\n    bool isXEven = mod(round(ha.x), 2.) == 0.;\n    bool isYEven = mod(round(ha.y), 2.) == 0.;\n    bool alternate = isXEven ^^ isYEven;\n    \n    float dir = float(pxpy ^^ alternate) * +1. +\n                float(pxny ^^ alternate) * -1. + \n                float(nxny ^^ alternate) * +1. + \n                float(nxpy ^^ alternate) * -1. ;\n    \n    // Select the starting triangle to start the open animation \n    float at = (atan(rid.x, rid.y) + PI) * 3.0;\n    float x = clamp(ceil((at / PI) + antialiasing(1.)), 1., HEXAGON_TRIANGLE);\n    int toOpen = int(clamp(mod(x - 2., HEXAGON_TRIANGLE) + 1., 1., HEXAGON_TRIANGLE)) ;\n        \n    vec2 oh = sdOpenHexagon(rotateDegree(-90., gv), r.x / r.y, toOpen, dir);\n    return vec4(oh, id);\n}\n\n// Create a tiled regular hexagon coorinate at position \"p\" and opened at time \"t\" where will fill an hexagon circle in 6 points of \"t\"\n// ----------------------------------------\nfloat fillHexagonsCoords(vec2 p, float t) {\n    vec4 hexCoords = sdOpenHexagonsCoords(p);\n    \n    // Timing\n    float hexCoordTime = t / HEXAGON_TRIANGLE - mod(t / HEXAGON_TRIANGLE, 1.);\n    float hexTime = mod(t, HEXAGON_TRIANGLE);\n    \n    // Data preparation\n    float distanceCoordHex = sdHexagon(hexCoords.zw);\n    float maxCoordHex = distanceCoordHex - hexCoordTime - 1.;\n    float minCoordHex = maxCoordHex + 1.;\n    float previusCoordHex = minCoordHex * -1.;\n    float currentCoordHex = maxCoordHex * -1.;    \n    \n    // Mask time\n    hexTime *= currentCoordHex;\n    hexTime += previusCoordHex * HEXAGON_TRIANGLE;\n    float hexTriTime = mod(hexTime, 1.);\n    \n    float hexOpeningDistance = hexCoords.y + hexCoords.x - 1.;\n    float triIndex = -abs(ceil(hexTime) - round(hexCoords.x)) + 1.;\n    \n    // Animation\n    float img = S(hexOpeningDistance, hexTime);\n    float opening = saturate(img * triIndex);\n    float openingShade = opening * mix(0.2, 1., hexTriTime);\n    \n    return saturate(img - opening + openingShade);\n}\n\n// Get the time passed from the moment of the click to the call time multiplied by the SPEED parameter \n// ----------------------------------------\nfloat getStateLifeTime(State state, float t) {\n    return (t - state.time) * SPEED; \n}\n\n// Get the time of the decline by the state life time, when the returned value is greater than 1. the state is completely black\n// ----------------------------------------\nfloat getStateDeclineTime(float stateLifeTime) {\n    return (stateLifeTime / (HEXAGON_TRIANGLE * TILING)) * COLOR_DECLINE_SPEED; \n}\n\n// Create a tiled regular hexagon coorinate at position \"p\" and opened at time \"t\" where will fill an hexagon circle in 6 points of \"t\"\n// This function will also modify the hexagon property based of the State \"state\"\n// ----------------------------------------\nvec3 storedFillHexagonsCoords(State state, vec2 p, float t) {\n    vec3 col = vec3(0.);\n    \n    // Position modification\n    vec2 pos = p - state.position;\n    pos *= TILING;\n    pos = rotateDegree(state.seed * 360., pos);\n\n    // Time start modification\n    float time = getStateLifeTime(state, t);\n\n    col += fillHexagonsCoords(pos, time);\n    \n    float saturation = COLOR_SATURATION;\n    float value = COLOR_VALUE;\n    \n    // Decline color modifications\n#ifdef DECLINE\n    \n    float declineTime = getStateDeclineTime(time);\n    float minSaturation = min(COLOR_SATURATION, COLOR_DECLINE_SATURATION);\n    float maxSaturation = max(COLOR_SATURATION, COLOR_DECLINE_SATURATION);\n    float minValue = min(COLOR_VALUE, COLOR_DECLINE_VALUE);\n    float maxValue = max(COLOR_VALUE, COLOR_DECLINE_VALUE);\n    \n    \n    saturation = clamp(mix(COLOR_SATURATION, COLOR_DECLINE_SATURATION, declineTime), minSaturation, maxSaturation);\n    value = clamp(mix(COLOR_VALUE, COLOR_DECLINE_VALUE, declineTime), minValue, maxValue);\n    \n#endif \n    \n    // Color modification\n    col *= HSVtoRGB(vec3(fract(state.seed - 0.25), saturation, value));\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates to [-1, 1]\n    vec2 uv = normCoords(fragCoord);\n    vec3 col = vec3(0.);\n    float t = iTime;\n        \n    // Draw each fill saved state\n    for(int i = 0; i < MAX_FILLS; i++) {\n        State state = getSortedState(i);\n        bool canDraw = state.time >= 0.;\n                \n        if(canDraw) {\n            vec3 fhc = storedFillHexagonsCoords(state, uv, t);\n            \n            // Select color to show on the screen\n            vec3 tCol = fhc + col;\n            bool isCol = dot(fhc, fhc) > 0. && dot(tCol, tCol) > 0.;\n            col = float(isCol) * fhc + float(!isCol) * col;  \n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---------------------------------------- {\n// Save position, time and seed on the click moment \n// ---------------------------------------- }\n\n// Comment AUTO_CLICK define to disable the automatic generation of new unfold layer\n// ----------------------------------------\n#define AUTO_CLICK\n// if AUTO_CLICK is present this indicate the time that should pass to generate a new unfold layer\n// ----------------------------------------\n#define AUTO_CLICK_SEC 8.\n\nfloat hash11(float seed) { return fract(sin(dot(vec2(seed), vec2(12.98, 78.23))) * 457.54); } \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int id = getIndexState(fragCoord);   \n    bool isIdLowerThanFills = id < MAX_FILLS;\n    bool isIdLowerThanSortedFills = id < MAX_FILLS * 2;\n    \n    \n    if(!isIdLowerThanSortedFills) {\n        // No data\n        discard;\n    } \n    \n     \n    State toStore; \n    toStore.position = vec2(0.);\n    toStore.time = float(id) * -1.; // varius starting value on the point\n    toStore.seed = 0.25;\n    \n    if(iFrame >= 1) {\n        if(isIdLowerThanFills) {\n            State loaded = getState(id);\n            \n            vec2 pos = iMouse.zw;\n            \n        #ifdef AUTO_CLICK\n            if(mod(iTime, AUTO_CLICK_SEC) <= iTimeDelta) {\n                pos = vec2(hash11(iTime + 2.1648621) * iResolution.x, hash11(iTime + 1.51324) * iResolution.y);\n            }\n        #endif\n\n            if(pos.y > 0.) {\n                float minTime = getSortedState(0).time;\n                bool isValidToApply = loaded.time == minTime;\n\n                if(isValidToApply) {\n                    loaded.position = normCoords(pos);\n                    loaded.time = iTime;\n                    loaded.seed = hash11(iTime);\n                }\n            }\n            // Mantain loaded state\n            toStore = loaded;\n\n        } else if (isIdLowerThanSortedFills){\n            State[MAX_FILLS] states;\n            // Gater states\n            for(int i = 0; i < MAX_FILLS; i++) {\n                states[i] = getState(i);\n            }\n            // Sort states in time decrescent scale\n            for(int i = 0; i < MAX_FILLS; i++) {\n                for(int j = 0; j < MAX_FILLS; j++) {\n                    if(states[i].time < states[j].time) {\n                        State t = states[j];\n                        states[j] = states[i];\n                        states[i] = t;\n                    }\n                }\n            }\n            // Get current sorted data to store\n            toStore = states[id - MAX_FILLS];\n        }\n    }\n    \n    fragColor = getStateVec(toStore);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// Define the maximum number of animation present at the same time\n// ----------------------------------------\n#define MAX_FILLS 20\n\n// Useful Macro to normalize pixel coordinate position to screen position\n// ----------------------------------------\n#define normCoords(coords) (((coords) - (.5 * iResolution.xy)) / (float(iResolution.x > iResolution.y) * iResolution.y + float(iResolution.x <= iResolution.y) * iResolution.x))\n\n\n// The load and save system function on a base that the maximum size of the memory is a single pixel\n\n// Obtain the pixel coordinates of the indexed cell of memory\n// ----------------------------------------\n#define getStateIndex(i) ivec2((i) % int(iResolution.x), (((i) / int(iResolution.x)) % int(iResolution.y)))\n// Obtain the index of the cell at the given pixel coordinates\n// ----------------------------------------\n#define getIndexState(fragCoord) int(mod(floor((fragCoord).x) + (floor((fragCoord).x) * floor((fragCoord).y)), iResolution.x * iResolution.y))\n\n// Load the cell of memory at the given index\n// ----------------------------------------\n#define getState(i) getStateInternal(iChannel0, getStateIndex(i))\n// Load the special ordered cell of memory at the given index\n// This is used to optimize the alogrithm to sort the memory only MAX_FILLS times instead of each pixel of the screen\n// This means that this algoritm will consume twice MAX_FILLS cells of the memory (Buffer A)\n// ----------------------------------------\n#define getSortedState(i) getState(((i) + MAX_FILLS))\n\n// Save and Load functions\n// ----------------------------------------\nstruct State {\n    vec2 position;\n    float time;\n    float seed;\n};\n\nState getStateInternal(sampler2D sampler, ivec2 index) {\n    vec4 data = texelFetch(sampler, index, 0);\n    State state;\n    state.position = data.xy;\n    state.time = data.z;\n    state.seed = data.w;\n    return state;\n}\n\nvec4 getStateVec(State state) {\n    return vec4(state.position.x, state.position.y, state.time, state.seed);\n}","name":"Common","description":"","type":"common"}]}