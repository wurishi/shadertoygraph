{"ver":"0.1","info":{"id":"llfcWr","date":"1504304658","viewed":343,"name":"The Ocean and the Sun","username":"blinry","description":"Experiments with fractal noise. Raymarched water surface.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sunset","ocean","fractalnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define EPSILON 0.0001\n#define MAX_DIST 100.0\n\nfloat rand2(vec2 co) {\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt = dot(co.xy ,vec2(a,b));\n    float sn = mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float h1 = rand2(i)*sin(iTime+100000.0*rand2(i));\n    float h2 = rand2(i + vec2(1.0, 0.0))*sin(iTime+100000.0*rand2(i + vec2(1.0, 0.0)));\n    float h3 = rand2(i + vec2(1.0, 1.0))*sin(iTime+100000.0*rand2(i + vec2(1.0, 1.0)));\n    float h4 = rand2(i + vec2(0.0, 1.0))*sin(iTime+100000.0*rand2(i + vec2(0.0, 1.0)));\n\n    vec2 u = smoothstep(0.0, 1.0, f);\n\n    return mix(mix(h1, h2, u.x), mix(h4, h3, u.x), u.y);\n}\n\nfloat fbm(vec2 st) {\n    float value = 0.0;\n    float amplitude = 1.2;\n    for (int i=0; i<6; i++) {\n        value += amplitude*noise(st);\n        st *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nfloat map(vec3 p) {\n    float h = fbm(p.zx*0.2);\n    return p.y-h;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.1;\n    for (int i = 0; i < 64 ; i++) {\n        vec3 p = o + r*t;\n        float d = map(p);\n        if (d < 0.001*t || d > MAX_DIST) {\n            return t;\n        }\n        t += d*0.9;\n    }\n    return t;\n}\n\nfloat shadow(vec3 o, vec3 r) {\n    float t = 0.0;\n    float k = 16.0;\n    float res = 1.0;\n    for (int i = 0; i < 32 ; i++) {\n        vec3 p = o + r*t;\n        float d = map(p);\n        if (d < 0.001*t) {\n            return 0.0;\n        }\n        t += d*0.9;\n        res = min(res, k*d/t);\n    }\n    return res;\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 textur(vec3 p) {\n    return vec3(0.4,0.4,1.0)*(1.5+p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    uv.x *= iResolution.x/iResolution.y;\n\n    float speed = 5.0;\n    float day = 0.5+0.5*sin(0.7*iTime);\n    float y = -1.0*cos(0.7*iTime);\n\n    vec3 light = vec3(100.0*y, 40.0*(day-0.5), 100.0+speed*iTime);\n\n    vec3 r = normalize(vec3(uv, 1.0));\n    vec3 o = vec3(0.0, 3.0, speed*iTime);\n    float t = trace(o, r);\n\n    vec3 c;\n\n    vec3 lightcolor = vec3(0.5-abs(0.5-day),0.5-(1.0-day),1.0-(1.0-day)*2.0);\n\n    if (t > MAX_DIST) {\n        c = lightcolor+vec3(0.7)*(0.5-r.y);\n        c *= 0.2+day;\n\n        float sun = 1.0-smoothstep(0.1, 0.3, length(uv - vec2(y, day-0.5)));\n        c += sun*0.8*vec3(1.0,1.0,1.0);\n\n        float star = 1.0-smoothstep(0.0, 0.1, length(fract(uv*10.0)+rand2(floor(uv*10.0))-uv*vec2(0.3,1.0)+vec2(-0.8,0.0)));\n        c += (1.0-smoothstep(0.0, 0.2, day))*star*vec3(1.0);\n    } else {\n        vec3 p = o+t*r;\n        vec3 n = normal(p);\n\n        vec3 r = r-2.0*dot(r,n)*n;\n\n        float specular = pow(dot(r,normalize(light-p)),40.0);\n\n        float s = shadow(p, normalize(light-p));\n\n        vec3 col = textur(p);\n\n        c = col*vec3(0.2*(0.5+day)+clamp((dot(n,normalize(light-p))),0.0,1.0)*s)+specular*lightcolor*(0.2+day);\n\n    }\n\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}