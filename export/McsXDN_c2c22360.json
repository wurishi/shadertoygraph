{"ver":"0.1","info":{"id":"McsXDN","date":"1705598647","viewed":69,"name":"Perlin Noise algorithm","username":"thomThalas","description":"Navigate with wasd.\nZoom in with the up and down arrow.\nChange detail with the left and right arrow.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["noise","perlinnoise","perlin","random","generation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define white vec3(1.);\n#define black vec3(0.);\n\n\n\n\n\nvec2 RandomVector2(vec2 uv, float w)\n{\n    float x = dot(uv, vec2(123.4, 234.5));\n    float y = dot(uv, vec2(234.5, 345.6));\n    \n    vec2 gradient = vec2(x, y);\n    gradient = sin(gradient + w);\n    gradient *= 143758.;\n    gradient = sin(gradient + w);\n    \n    return gradient;\n}\n\nfloat Fade(float t) {\n\treturn ((6.*t - 15.)*t + 10.)*t*t*t;\n}\n\n\nfloat Noise2D(vec2 uv, float w)\n{\n    vec2 gridId = floor(uv);\n    vec2 gridUv = fract(uv);\n    \n    \n    vec2 bl = gridId + vec2(0., 0.);\n    vec2 br = gridId + vec2(1., 0.);\n    vec2 tr = gridId + vec2(1., 1.);\n    vec2 tl = gridId + vec2(0., 1.);\n    \n    vec2 blVec = RandomVector2(bl, w);\n    vec2 brVec = RandomVector2(br, w);\n    vec2 trVec = RandomVector2(tr, w);\n    vec2 tlVec = RandomVector2(tl, w);\n    \n    \n    \n    vec2 distToBl = gridUv - vec2(0., 0.);\n    vec2 distToBr = gridUv - vec2(1., 0.);\n    vec2 distToTr = gridUv - vec2(1., 1.);\n    vec2 distToTl = gridUv - vec2(0., 1.);\n    \n    float dotBl = dot(blVec, distToBl);\n    float dotBr = dot(brVec, distToBr);\n    float dotTr = dot(trVec, distToTr);\n    float dotTl = dot(tlVec, distToTl);\n    \n    gridUv = vec2(Fade(gridUv.x), Fade(gridUv.y));\n    \n    float b = mix(dotBl, dotBr, gridUv.x);\n    float t = mix(dotTl, dotTr, gridUv.x);\n    float perlin = mix(b, t, gridUv.y);\n    \n    return perlin;\n}\n\nfloat Noise2DLayered(vec2 uv, float w, float layers, float stability, float lacunarity)\n{\n    float influence = 1.;\n    float scale = 1.;\n    \n    float perlin = 0.;\n    \n    for(int i = 0; i < int(floor(layers)); i++)\n    {\n        perlin += Noise2D(uv * scale + RandomVector2(vec2(scale), 0.), w) * influence;\n        influence /= stability;\n        scale *= lacunarity;\n    }\n    \n    if(distance(layers, floor(layers)) > 0.0001)\n    {\n        float lastLayerMul = layers - floor(layers);\n    \n        perlin += Noise2D(uv * scale + RandomVector2(vec2(scale), 0.), w) * influence * lastLayerMul;\n        \n        \n    }\n    \n    \n    \n    return perlin;\n}\n\nfloat Noise2DLayered(vec2 uv, float w, float layers, float stability)\n{\n    return Noise2DLayered(uv, w, layers, stability, 2.);\n}\n\nfloat Noise2DLayered(vec2 uv, float w, float layers)\n{\n    return Noise2DLayered(uv, w, layers, 2., 2.);\n}\n\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    \n    vec3 color = black;\n    \n    uv *= texelFetch(iChannel1, BUFF_A_ZOOM, 0).x;\n   \n    uv += texelFetch(iChannel1, BUFF_A_POS, 0).xy;\n    \n    \n    \n    \n    float perlin = Noise2DLayered(uv, 1., texelFetch(iChannel1, BUFF_A_LAYERS, 0).x, 1.15, 1.3);\n    //float perlin = Noise2D(uv, iTime);\n    \n    //perlin *= Noise2DLayered(uv * 1./10., 0., 5.) - 0.4;\n    \n    //perlin = abs(perlin);\n    \n    //perlin = perlin / 2. + 0.5;\n    \n    //perlin = pow(perlin, 2.);\n    \n    //perlin = perlin * 2.;\n    \n    //perlin = round(perlin);\n    \n    \n    color = vec3(perlin);\n    \n    //color = vec3(texelFetch(iChannel1, ivec2(fragCoord/270.), 0).xyz / 15.);\n    \n    //color = vec3(texelFetch(iChannel1, ivec2(fragCoord), 0));\n    \n    \n   \n    colOut = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//This is Buffer A memory locations\n\n#define BUFF_A_POS ivec2(0, 0)\n#define BUFF_A_ZOOM ivec2(1, 0)\n#define BUFF_A_LAYERS ivec2(2,0)\n\n///////////////////\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEYBOARD_INPUT iChannel1\n\n\n\nbool GetKeyTypeDef(int key, int type)\n{\n    return texelFetch( KEYBOARD_INPUT, ivec2(key, type), 0 ).x > 0.5;\n}\n\nbool GetKey(int key)\n{\n    return texelFetch( KEYBOARD_INPUT, ivec2(key, 0), 0 ).x > 0.5;\n}\n\n\nivec2 indexToBuffer(int index, int width)\n{\n    return ivec2(mod(float(index), float(width)), int(floor(float(index) / float(width))) );\n}\n\n\n\n\nvoid mainImage( out vec4 o, in vec2 coord )\n{\n    if(iFrame < 2)\n    {\n        o = vec4(0);\n        \n        if(ivec2(coord) == BUFF_A_LAYERS)\n        {\n            o = vec4(30.);\n        }\n        else if(ivec2(coord) == BUFF_A_ZOOM)\n        {\n            o = vec4(1.);\n        }\n        \n    }else\n    {\n        o = texelFetch(iChannel0, ivec2(coord), 0);\n    }\n    \n    if(ivec2(coord) == BUFF_A_POS)\n    {\n        float zoom = texelFetch(iChannel0, BUFF_A_ZOOM, 0).x;\n    \n        if(GetKey(KEY_D))\n        {\n            o.x += iTimeDelta * zoom * 0.25;\n        }\n        else if(GetKey(KEY_A))\n        {\n            o.x -= iTimeDelta * zoom * 0.25;\n        }\n        \n        if(GetKey(KEY_W))\n        {\n            o.y += iTimeDelta * zoom * 0.25;\n        }\n        else if(GetKey(KEY_S))\n        {\n            o.y -= iTimeDelta * zoom * 0.25;\n        }\n        \n    }\n    else if(ivec2(coord) == BUFF_A_ZOOM)\n    {\n        if(GetKey(KEY_UP))\n        {\n            o -= iTimeDelta * 0.5 * o;\n        }\n        else if(GetKey(KEY_DOWN))\n        {\n            o += iTimeDelta * 0.5 * o;\n        }\n        o = vec4(o.x);\n        o = max(vec4(0.001), o);\n    }\n    else if(ivec2(coord) == BUFF_A_LAYERS)\n    {\n        if(GetKey(KEY_LEFT))\n        {\n            o -= iTimeDelta * 3.;\n        }\n        else if(GetKey(KEY_RIGHT))\n        {\n            o += iTimeDelta * 3.;\n        }\n        o = max(o, 1.);\n        o = min(o, 30.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}