{"ver":"0.1","info":{"id":"XfjyRR","date":"1721931691","viewed":40,"name":"Antialiasing and ellipses","username":"avilapa","description":"Two methods for finding an ellipse's major and minor axes and their lengths (describing the projected pixel footprint in texture space) for anisotropic sampling (right).Trilinear (middle), Blilinear (left).\nBased on: https://www.shadertoy.com/view/4lXfzn\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["aliasing","filtering","ellipse","anisotropic","eigenvalues"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on: https://www.shadertoy.com/view/4lXfzn\n//\n// BUG: If you cannot see a cherckerboard, set iChannel0 Wrap mode to Clamp, then back to Repeat. It's \n// not being saved for some reason.\n//\n// I really wanted to understand the math in the shader linked above, so I went down the rabbit hole and\n// I thought I'd share my findings in a comprehensive way for anyone that is unaware of what eigenvalues\n// and eigenvectors have to do with anisotropic filtering, like I was a couple days ago.\n//\n// For a superb introduction to the concept of eigen-things, I highly recommend watching 3blue1brown's \n// video on the matter:\n// - Eigenvectors and eigenvalues | Chapter 14, Essence of linear algebra\n//   (https://youtu.be/PFDu9oVAE-g?si=ttDH8jjFKbZYrvY5)\n// \n// Unfortunately, my conclusion leaves me profoundly confused, thinking 'why would anyone bother with all\n// this math', since the QUICK_METHOD version of GetGradientEllipse() below is much faster and seems to\n// yield the same result? Please someone enlighten me :)\n//\n// #define QUICK_METHOD\n\n#define ANISOTROPY_X 16\n\n#if defined(QUICK_METHOD)\nvoid GetGradientEllipse(vec2 duvdx, vec2 duvdy, \n    out vec2 majorAxis, out vec2 minorAxis, out float majorAxisLength, out float minorAxisLength)\n{\n    majorAxis = duvdx;\n    minorAxis = duvdy;\n    majorAxisLength = length(majorAxis);\n    minorAxisLength = length(minorAxis);\n    \n    if (majorAxisLength < minorAxisLength)\n    {\n        vec2 tmp = majorAxis;\n        majorAxis = minorAxis;\n        minorAxis = tmp;\n        float tmpL = majorAxisLength;\n        majorAxisLength = minorAxisLength;\n        minorAxisLength = tmpL;\n    }\n}\n#else\nvoid GetGradientEllipse(vec2 duvdx, vec2 duvdy, \n    out vec2 majorAxis, out vec2 minorAxis, out float majorAxisLength, out float minorAxisLength)\n{\n    // Construct the Jacobian matrix that describes the inverse transformation of the UV coordinates \n\t// to screen-space.\n    mat2 J = mat2(duvdx, duvdy);\n    J = inverse(J);\n    J = transpose(J)*J;\n    float a = J[0][0];\n    float b = J[0][1];\n    float c = J[1][0];\n    float d = J[1][1];\n    \n    // Note: We compute the eigenvalues and eigenvectors of the matrix, which correspond to the major and \n\t// minor axis of the ellipse describing the projected pixel footprint in texture space. \n\t// For 2x2 matrices, we can use a neat trick to find the two roots of the quadratic formula corresponding\n\t// to its eigenvalues 'λ', by exploiting the fact that we can directly find out the mean 'm' and product\n    // 'p' of them. The trace of a matrix (sum of it's diagonals) is equal to the sum of its eigenvalues,\n    // therefore the half trace is their mean, while the determinant of the matrix (a * d - b * c) is equal\n    // to the product of its eigenvalues. Knowing these, the quadratic formula reduces to:\n    //\n\t//     λ = m ± √(m² - p)\n    //\n    // 3blue1brown 2021 - A quick trick for computing eigenvalues | Chapter 15, Essence of linear algebra\n\t// https://youtu.be/e50Bj7jn9IQ?si=ERvTvnY-Gxp04Pa3\n    float t = a + d;\n\t// Note: Reworked floating point precision fix discussed in https://www.shadertoy.com/view/4lXfzn.\n\tfloat m = t * 0.50000062500117187744141159058819;\n    float p = determinant(J);\n    float root = sqrt(m * m - p);\n    \n    // Eigenvalues\n    float L0 = m - root;\n    float L1 = m + root;\n    // Eigenvectors\n    // Note: We know the ellipse's axes are eigenvectors for our transformation. To find them, we use\n\t// a free choice of variable in one of our vector components to greatly simplify finding a matching \n\t// secondary component (generalized eigenvector).\n    vec2 A0 = vec2(L0 - d, c);\n    vec2 A1 = vec2(L1 - d, c);\n    \n  \t// Note: The eigenvalues are equivalent to the squared length of the ellipse's axes in screen space.\n    majorAxisLength = inversesqrt(L0);\n    minorAxisLength = inversesqrt(L1);\n    // Note: The unit eigenvectors scaled by the lengths give us the ellipse's axes.\n    majorAxis = normalize(A0) * majorAxisLength;\n    minorAxis = normalize(A1) * minorAxisLength;\n}\n#endif\n\nvec4 textureAniso(sampler2D tex, vec2 uv)\n{\n    // The projected footprint under an infinitesimal pixel represented as a circle is, in most cases, an \n    // ellipse (see https://www.shadertoy.com/view/ltXfRr for a neat demonstration of this). In order to\n    // find out how stretched or compressed the texture will be under a pixel, we analyze the ellipse's\n    // axes, and take ANISOTROPY_X many samples along the length of it's long axis to get an antialiased\n    // (filtered) result.\n    vec2 majorAxis, minorAxis;\n    float majorAxisLength, minorAxisLength;\n    GetGradientEllipse(dFdx(uv), dFdy(uv), majorAxis, minorAxis, majorAxisLength, minorAxisLength);\n    \n    float lod = log2(minorAxisLength * iResolution.y);\n    if ((majorAxisLength / minorAxisLength) > float(ANISOTROPY_X))\n    {\n        lod = log2(minorAxisLength / float(ANISOTROPY_X) * iResolution.y);\n    }\n    \n    // Sample across ellipse major axis\n    const float kStep = 1.0 / float(ANISOTROPY_X);\n    vec4 result = vec4(0);\n    for (int i = -ANISOTROPY_X / 2; i < ANISOTROPY_X / 2; ++i)\n    {\n        float step = (float(i) + 0.5) * kStep;\n        result += textureLod(tex, uv + majorAxis * step, lod);\n    }\n    \n    return result / float(ANISOTROPY_X);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 ray = vec3(uv * 2.0 - 1.0, 1.0);\n    vec2 p = ray.xz / ray.y + 0.1 * iTime;\n    p /= 4.0;\n    \n    if (ray.y > 0.0)\n    {\n        // Background\n        fragColor = vec4(0.5, 0.7, 0.9, 1);\n    }\n    else if (ray.x < (1.0 / 3.0 * 2.0 - 1.0))\n    {\n        // Bilinear Filtering\n        fragColor = vec4(textureLod(iChannel0, p, 0.).rgb, 1);\n    }\n    else if (ray.x < (2.0 / 3.0 * 2.0 - 1.0))\n    {\n        // Trilinear Filtering\n        fragColor = vec4(texture(iChannel0, p).rgb, 1);\n    }\n    else\n    {\n        // Anisotropic Filtering\n        fragColor = vec4(textureAniso(iChannel0, p).rgb, 1);\n    }\n    \n    fragColor = pow(fragColor, vec4(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Create checkerboard texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    ivec2 tiles = ivec2(uv * 8.0) % 2;\n    fragColor = vec4(vec3(tiles.x == tiles.y), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}