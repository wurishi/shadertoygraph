{"ver":"0.1","info":{"id":"MssSWj","date":"1484545407","viewed":151,"name":"Orbiting Raycast Spheres","username":"aadeon","description":"added specular","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycast","sphere","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define length2(x) (dot(x,x))\n\nstruct ray\n{\n   vec3 p;\n   vec3 dir;\n};\n    \nstruct sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n    \nstruct maybe_point\n{\n   int isPoint;\n   vec3 p;\n};  \n\nstruct light\n{\n   vec3 p;\n   vec3 color;\n};\n\n#define NUM_SPHERES 4\n#define NUM_LIGHTS 4\n\n    \nmaybe_point sphere_intersection_point( ray r, sphere s)\n{\n   float a = dot(r.dir, r.dir);\n   float b = (2.0 * dot((r.p - s.center), r.dir));\n   float c = (dot((r.p - s.center), (r.p - s.center)) - s.radius * s.radius );\n\n   float t1 = (-b + sqrt(b*b - 4.0*a*c))/(2.0*a);\n   float t2 = (-b - sqrt(b*b - 4.0*a*c))/(2.0*a);\n   \n   float t = 0.0;\n   \n   maybe_point point_a;\n\n   if (t1 >= 0.0 && t2 >= 0.0) //if both are positive, use the smaller one\n   {                       \n      if (t1 < t2)\n      {\n         t = t1;\n      }\n      else\n      {\n         t = t2;\n      }\n      point_a.isPoint = 1;\n      point_a.p = (r.p + r.dir*t);\n   }\n   else if(t1 < 0.0 && t2 < 0.0) //sphere is behind ray, return false\n   {\n      point_a.isPoint = 0;\n      point_a.p = vec3 (0, 0, 0); \n   }\n   else if((t1 < 0.0 && t2 > 0.0 )||(t1 > 0.0 && t2 <0.0)) //ray starts inside sphere \n   {\n      if (t1 > 0.0)\n      {\n         t = t1;\n      }\n      else\n      {\n         t = t2;\n      }\n      point_a.isPoint = 1;\n      point_a.p = (r.p + r.dir*t);\n   }\n   else if((t1 == t2) && (t1 > 0.0)) //ray intersects on surface\n   {\n      point_a.isPoint = 1;\n      point_a.p = (r.p + r.dir*t);\n   }\n   else if(abs(length((s.center - r.p))) == s.radius) \n   //ray begins on surface (this seems like a kludgy way to check)\n   {  \n      point_a.isPoint = 1;\n      point_a.p = (r.p + r.dir*t);\n   }\n   else\n   {\n      point_a.isPoint = 0;\n      point_a.p = vec3(0, 0, 0);\n   }\n   return point_a;\n}\n\nvoid find_intersection_points(sphere spheres[NUM_SPHERES],\n                              ray r,\n                              out vec3 intersection_points[NUM_SPHERES],\n                              out int intersection_valid[NUM_SPHERES] )\n{\n\tfor(int i = 0; i < NUM_SPHERES; i++)\n    {\n        maybe_point point_a = sphere_intersection_point(r, spheres[i]);\n        if(point_a.isPoint == 1)\n        {\n            intersection_points[i] = point_a.p;\n            intersection_valid[i] = point_a.isPoint;\n        }\n    }\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = 2.0*iMouse.xy / iResolution.xy;\n    int i;\n    \n    // camera\n    ray ray1;\n    ray1.p = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - ray1.p);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    ray1.dir = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\tsphere sphere1;\n    sphere1.center = vec3(0,1,0);\n    sphere1.radius = 1.0;\n    sphere1.color = vec3(1,1,1)*0.8;\n    sphere sphere2;\n    sphere2.center = vec3(4.0*sin(.67*iTime),4.0*cos(.67*iTime)+1.0,0.0);\n    sphere2.radius = .3;\n    sphere2.color = vec3(1,0,0)*0.8;\n    sphere sphere3;\n    sphere3.center = vec3(3.0*sin(iTime) ,1.0, 3.0*cos(iTime));\n    sphere3.radius = .3;\n    sphere3.color = vec3(0,1,0)*0.8;\n    sphere sphere4;\n    sphere4.center = vec3(0.0,2.0*sin(1.5*iTime)+1.0,2.0*cos(1.5*iTime));\n    sphere4.radius = .3;\n    sphere4.color = vec3(0,0,1)*0.8;\n    \n    sphere spheres[NUM_SPHERES];\n    spheres[0] = sphere1;\n    spheres[1] = sphere2;\n    spheres[2] = sphere3;\n    spheres[3] = sphere4;\n    int hit_spheres[NUM_SPHERES];\n    vec3 intersection_points[NUM_SPHERES];\n    int  intersection_valid[NUM_SPHERES];\n    \n    int valid = 0;\n    vec3 closest_point;\n    vec3 closest_color;\n    vec3 closest_normal;\n    \n    light lights[NUM_LIGHTS];\n    light light1;\n    light1.p = vec3(0,1,0);\n    light1.color = vec3(.5,.5,.5);\n    lights[0] = light1;\n    \n    light light2;\n    light2.p = vec3(4.0*sin(.67*iTime),4.0*cos(.67*iTime)+1.0,0.0);\n    light2.color = vec3(1.0,.1,.1);\n    lights[1] = light2;\n    \n    light light3;\n    light3.p = vec3(3.0*sin(iTime) ,1.0, 3.0*cos(iTime));\n    light3.color = vec3(.1,1.0,.1);\n    lights[2] = light3;\n    \n    light light4;\n    light4.p = vec3(0.0,2.0*sin(1.5*iTime)+1.0,2.0*cos(1.5*iTime));\n    light4.color = vec3(.1,.1,1.0);\n    lights[3] = light4;\n    \n    \n    closest_color = vec3(0,0,0);\t\t// background -black\n    \n    // compute hits between this ray and all the spheres\n    find_intersection_points(spheres, ray1, intersection_points, intersection_valid );\n    \n    // find which of the valid ray hits is closest to us\n    float shortest_dist = 1e20;\n    for(int i = 0; i < NUM_SPHERES; i++)\n    {\n        if ( intersection_valid[i] > 0 )\n        {\n\t        float dist = length2(intersection_points[i] - ray1.p);\n\t        if(dist < shortest_dist)\n\t        {\n\t            shortest_dist = dist;\n                closest_point = intersection_points[i];\n                closest_color = spheres[i].color;\n                closest_normal = normalize( closest_point - spheres[i].center );\n                valid = 1;\n    \t    }\n        }\n    }\n    \n    fragColor = vec4(0,0,0,0);\n    if ( valid > 0 )\t\t// if any valid hits happened, compute lighting there\n    {\n\n\t   \t //compute diffuse color component\n\t     vec3 diffuse_point_color;\n         float specular;\n         vec3 color;\n         for (int i = 0; i < NUM_LIGHTS; i++)\n         {\n       \t\t vec3 point_adj = (closest_point + (closest_normal * 0.01));\n       \t\t vec3 light_direction = normalize(lights[i].p - point_adj);\n        \n        \n       \t\t float LdotN = dot(closest_normal, light_direction);\n\n        \t if (LdotN > 0.0) //check if point is on correct side of sphere\n        \t {\n             \tdiffuse_point_color += closest_color*lights[i].color*(LdotN);\n        \t }\n           \t else\n        \t {\n                diffuse_point_color += vec3(0.0,0.0,0.0);\t\t// draw ambient\n        \t }\n\t\t\t fragColor = vec4(diffuse_point_color,1);\n        \n        \n        \t // compute specular color term\n        \t vec3 from_eye = normalize(closest_point - ray1.p);\t\t// ray to eye\n        \t vec3 reflected = reflect( from_eye, closest_normal );\t// reflected ray\n        \t specular = dot( reflected, light_direction );\t\t// factor\n        \t specular = clamp( specular, 0., 1. );\n        \t specular = pow( specular, 16.0 );\n            \n             color += mix(diffuse_point_color, lights[i].color, specular );\n        }\n//      specular_point_color = light1.color*specular;\n\n         \n    \tfragColor = vec4(color,1);\n\t}\n    \n}\n","name":"Image","description":"","type":"image"}]}