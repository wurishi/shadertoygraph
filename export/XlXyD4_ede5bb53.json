{"ver":"0.1","info":{"id":"XlXyD4","date":"1505161015","viewed":2709,"name":"SDF Ambient Occlusion ","username":"mhnewman","description":"Approximate ambient occlusion using signed distance functions in a ray marched scene.","likes":56,"published":1,"flags":0,"usePreview":0,"tags":["ray","distance","occlusion","ambient","functions","march","signed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Approximate ambient occlusion using signed distance functions in a ray marched scene.\n// My first attempt at SDF ray marching.\n// Thanks to Jamie Wong for the great tutorial:\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\nconst int marchIter = 256;\nconst float marchDist = 100.0;\nconst float epsilon = 0.0001;\n\nconst int aoIter = 8;\nconst float aoDist = 0.07;\nconst float aoPower = 2.0;\n\nconst vec3 aoDir[12] = vec3[12](\n\tvec3(0.357407, 0.357407, 0.862856),\n\tvec3(0.357407, 0.862856, 0.357407),\n\tvec3(0.862856, 0.357407, 0.357407),\n\tvec3(-0.357407, 0.357407, 0.862856),\n\tvec3(-0.357407, 0.862856, 0.357407),\n\tvec3(-0.862856, 0.357407, 0.357407),\n\tvec3(0.357407, -0.357407, 0.862856),\n\tvec3(0.357407, -0.862856, 0.357407),\n\tvec3(0.862856, -0.357407, 0.357407),\n\tvec3(-0.357407, -0.357407, 0.862856),\n\tvec3(-0.357407, -0.862856, 0.357407),\n\tvec3(-0.862856, -0.357407, 0.357407)\n);\n\nconst float tau = 6.283185;\n\nvec3 cubePos0;\nmat3 cubeDir0;\nvec3 cubePos1;\nmat3 cubeDir1;\nvec3 cubePos2;\nmat3 cubeDir2;\nvec3 cubePos3;\nmat3 cubeDir3;\nvec3 cubePos4;\nmat3 cubeDir4;\n\nfloat ground(vec3 p) {\n    return p.z;\n}\n\nfloat cube(vec3 p) {\n    return max(length(max(abs(p) - vec3(1.0), 0.0)), length(p) - 1.35);\n}\n\nvoid setCube(float index, out vec3 cubePos, out mat3 cubeDir) {\n    float t = tau * mod(index / 5.0 + 0.02 * iTime + 0.12, 1.0);\n    float a = 2.0 * t;\n    float b = 3.0 * t;\n    float c = 7.0 * t;\n    cubePos = vec3(1.8 * cos(b), 1.8 * cos(c), 1.0 + sin(a));\n    cubeDir = mat3(cos(a), -sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0);\n    cubeDir *= mat3(cos(b), 0.0, -sin(b), 0.0, 1.0, 0.0, sin(b), 0.0, cos(b));\n    cubeDir *= mat3(cos(c), -sin(c), 0.0, sin(c), cos(c), 0.0, 0.0, 0.0, 1.0);\n}\n\nvoid setScene() {\n\tsetCube(0.0, cubePos0, cubeDir0);\n\tsetCube(1.0, cubePos1, cubeDir1);\n\tsetCube(2.0, cubePos2, cubeDir2);\n\tsetCube(3.0, cubePos3, cubeDir3);\n\tsetCube(4.0, cubePos4, cubeDir4);\n}\n\nfloat scene(vec3 p) {\n    float s = ground(p);\n    s = min(s, cube(cubeDir0 * (p - cubePos0)));\n    s = min(s, cube(cubeDir1 * (p - cubePos1)));\n    s = min(s, cube(cubeDir2 * (p - cubePos2)));\n    s = min(s, cube(cubeDir3 * (p - cubePos3)));\n    s = min(s, cube(cubeDir4 * (p - cubePos4)));\n    return s;\n}\n\nfloat march(vec3 eye, vec3 dir) {\n    float depth = 0.0;\n    for (int i = 0; i < marchIter; ++i) {\n        float dist = scene(eye + depth * dir);\n        depth += dist;\n        if (dist < epsilon || depth >= marchDist)\n\t\t\tbreak;\n    }\n    return depth;\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float dist = aoDist;\n    float occ = 1.0;\n    for (int i = 0; i < aoIter; ++i) {\n        occ = min(occ, scene(p + dist * n) / dist);\n        dist *= aoPower;\n    }\n    occ = max(occ, 0.0);\n    return occ;\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + epsilon, p.y, p.z)) - scene(vec3(p.x - epsilon, p.y, p.z)),\n        scene(vec3(p.x, p.y + epsilon, p.z)) - scene(vec3(p.x, p.y - epsilon, p.z)),\n        scene(vec3(p.x, p.y, p.z + epsilon)) - scene(vec3(p.x, p.y, p.z - epsilon))\n    ));\n}\n\nvec3 ray(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = fieldOfView * size.y;\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 dir, vec3 up) {\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nmat3 alignMatrix(vec3 dir) {\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, vec3(0.48, 0.6, 0.64)));\n    vec3 u = cross(s, f);\n    return mat3(u, s, f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 dir = ray(2.5, iResolution.xy, fragCoord);\n    \n    vec2 m = vec2(0.5, 0.75);\n    if (iMouse.z > 0.0)\n        m = iMouse.xy / iResolution.xy;\n    m *= tau * vec2(1.0, 0.25);\n\n    float dist = 15.0;\n    vec3 center = vec3(0.0, 0.0, 1.0);\n    vec3 eye = center;\n    eye += vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    mat3 mat = viewMatrix(center - eye, vec3(0.0, 0.0, 1.0));\n    dir = mat * dir;\n    \n    setScene();\n    float depth = march(eye, dir);\n    if (depth >= marchDist - epsilon) {\n        fragColor = vec4(1.0);\n\t\treturn;\n    }\n    vec3 p = eye + depth * dir;\n    vec3 n = normal(p);\n \n    mat = alignMatrix(n);\n    float col = 0.0;\n    for (int i = 0; i < 12; ++i) {\n        vec3 m = mat * aoDir[i];\n        col += ao(p, m) * (0.5 + 0.5 * dot(m, vec3(0.0, 0.0, 1.0)));\n    }\n\n    fragColor = vec4(vec3(pow(0.2 * col, 0.7)), 1.0);\n}","name":"Image","description":"","type":"image"}]}