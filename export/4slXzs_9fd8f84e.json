{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// try running this through a kaleidoscope.\n\nconst float _Speed = 5.5 * 0.002; \t\t\nconst float _Scale = 0.2;\nconst float _Gamma = 0.15;\nconst float _Colour = 0.15;\t\t// 0.01..0.3\nconst float _Brightness = 2.0;\nconst float _Lacunarity = 1.6;\n\n//#define USE_PROCEDURAL\n\n#ifdef USE_PROCEDURAL\n\n//iq noise fns\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n#else\n\n// hq texture noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = texture( iChannel0, (uv+ vec2(0.5,0.5))/256.0, -100.0 ).yx;\n\tvec2 rg2 = texture( iChannel0, (uv+ vec2(1.5,0.5))/256.0, -100.0 ).yx;\n\tvec2 rg3 = texture( iChannel0, (uv+ vec2(0.5,1.5))/256.0, -100.0 ).yx;\n\tvec2 rg4 = texture( iChannel0, (uv+ vec2(1.5,1.5))/256.0, -100.0 ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n#endif\n\n//x3\nvec3 noise3( in vec3 x)\n{\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\n\t\t\t\tnoise(x) );\n}\n\nmat3 rotation(float angle, vec3 axis)\n{\n\tfloat s = sin(-angle);\n\tfloat c = cos(-angle);\n\tfloat oc = _Colour - c;\n\tvec3 sa = axis * s;\n\tvec3 oca = axis * oc;\n\treturn mat3(\t\n\t\toca.x * axis + vec3(\tc,\t-sa.z,\tsa.y),\n\t\toca.y * axis + vec3( sa.z,\tc,\t\t-sa.x),\t\t\n\t\toca.z * axis + vec3(-sa.y,\tsa.x,\tc));\t\n}\n\n// https://code.google.com/p/fractalterraingeneration/wiki/Fractional_Brownian_Motion\nvec3 fbm(vec3 x, float H, float L)\n{\n\tvec3 v = vec3(0);\n\tfloat f = 1.;\n\n\tfor (int i=0; i<7; i++)\n\t{\n\t\tfloat w = pow(f,-H);\n\t\tv += noise3(x)*w;\n\t\tx *= L;\n\t\tf *= L;\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tfloat time = iTime*_Speed;\n\n\tuv *= 1. + 0.25*sin(time*10.);\t// drift scale in and out a little\n\n\tvec3 p = vec3(uv*_Scale,time);\t\t\t\t\t//coordinate + slight change over time\n\n\tvec3 axis = 4. * fbm(p, 0.5, _Lacunarity);\t\t\t\t//random fbm axis of rotation\n\n\tvec3 colorVec = 0.5 * 5. * fbm(p*0.3,0.5,_Lacunarity);\t//random base color\n\n\tcolorVec = rotation(3.*length(axis),normalize(axis))*colorVec;\n\tcolorVec *= 0.05;\n\n\tcolorVec = pow(colorVec,vec3(_Gamma));\t\t\t//gamma\n\tfragColor = vec4(_Brightness * colorVec * colorVec,1.0);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4slXzs","date":"1405913777","viewed":1203,"name":"Edged plasma","username":"73v3","description":"Basically a straight up rip of Antonalog's \"GIT\" shader https://www.shadertoy.com/view/Mdj3RV with some code culling and the value tweaks\n","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","plasma"],"hasliked":0,"parentid":"","parentname":""}}