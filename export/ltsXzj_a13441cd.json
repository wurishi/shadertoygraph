{"ver":"0.1","info":{"id":"ltsXzj","date":"1438210971","viewed":180,"name":"arch","username":"rimina","description":"prototyping and testing stuff.\n\nAmbient occlusion method used is from here :  https://www.shadertoy.com/view/4sdGWN\nThe marcher in test is implemented according to this article : http://diglib.eg.org/handle/10.2312/stag.20141233.001-008","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","coordinates","prototyping","bendingspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 AMBIENT = vec3(0.6);\nconst vec3 DIFFUSE = vec3(0.6);\nconst vec3 SPECULAR = vec3(0.4, 0.35, 0.4);\n\n//Adjust for your screen\nconst vec3 GAMMA = vec3(2.2);\n\nconst float PI = 3.14159265359;\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\nvec3 rotateY(vec3 p, float a){\n  float c = cos(a);\n  float s = sin(a);\n  vec3 q = p;\n  q.x = c * p.x + s * p.z;\n  q.z = -s * p.x + c * p.z;\n  return q;\n}\n\nvec3 rotateZ(vec3 p, float a){\n  float c = cos(a);\n  float s = sin(a);\n  vec3 q = p;\n  q.x = c * p.x - s * p.y;\n  q.y = s * p.x + c * p.y;\n  return q;\n}\n\nfloat repeat(float p, float c){\n  return mod(p+(.5*c), c)-.5*c;\n}\n\nfloat distf(vec3 p){\n    \n  float r = length(p);\n  float theta = atan(p.y/p.x);\n  float phi = atan(p.x, p.y);\n  \n  vec3 pos = vec3(r, theta, phi);\n  pos.x = repeat(pos.x, 4.);\n  \n  float kaari = box(pos, vec3(1.0));\n  return kaari;\n}\n\nvec3 normals(vec3 p){\n  vec3 eps = vec3(1.0/iResolution.x, 0., 0.);\n  vec3 n = vec3(\n    distf(p+eps.xyy) - distf(p-eps.xyy),\n    distf(p+eps.yxy) - distf(p-eps.yxy),\n    distf(p+eps.yyx) - distf(p-eps.yyx));\n  return normalize(n);\n}\n\nfloat march(vec3 orig, vec3 dir, float far){  \n  float t = .0001;\n  float step = 0.;\n  \n  float omega = 1.;\n  float prev_radius = 0.;\n  \n  float candidate_t = t;\n  float candidate_error = 1000.;\n    \n   vec3 p = vec3(0.);\n  \n  float sg = sgn(distf(orig));\n  for(int i = 0; i < 64; ++i){\n    p = dir*t+orig;\n    float sg_radius = sg*distf(p);\n    float radius = abs(sg_radius);\n    \n    bool fail = omega > 1. && (radius+prev_radius) < step;\n    if(fail){\n      step -= omega * step;\n      omega = 1.;\n    }\n    else{\n      step = sg_radius*omega;\n    }\n    prev_radius = radius;\n    float error = radius/t;\n    \n    if(!fail && error < candidate_error){\n      candidate_t = t;\n      candidate_error = error;\n    }\n    if(!fail && error < (.5/iResolution.x) || t > far){\n      break;\n    }\n    t += step;\n  }\n    \n  float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*distf(p));\n        p = p + dir*(radius-er);\n        t = length(p-orig);\n        er = radius/t;\n        \n        if(er < candidate_error ){\n            candidate_t = t;\n            candidate_error = er;\n        }\n   }  \n    \n  if(t > far || candidate_error > (.5/iResolution.x)){\n    return t;\n  }\n  return candidate_t;\n}\n\nvec3 render(in vec3 orig, in vec3 dir, out vec3 n, out float t, in float far){\n  t = march(orig, dir, far);\n  vec3 p = t*dir+orig;\n  if(t < far){\n    n = normals(p);\n  }\n  return p;\n}\n\n//Testing the ambient occlusion method from here : https://www.shadertoy.com/view/4sdGWN\nfloat hash( float n )//->0:1\n{\n    return fract(sin(n)*3538.5453);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sgn(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - distf( p + rd )) / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nvec3 shading(vec3 n, vec3 p, vec3 ld, vec3 dir, vec3 orig){    \n    float nl = dot(n,ld);\n    float intensity = clamp(nl, 0. ,1.);\n    \n    vec3 refDir = reflect(-ld, n);\n\n    float angle = max(dot(refDir, dir), 0.);\n    float spec = pow(angle, 0.4);\n\n    float ao = ambientOcclusion(p, n, 5.0, 0.5);\n    vec3 color = vec3(ao*AMBIENT + intensity*DIFFUSE*0.4 + spec*SPECULAR*0.4);\n  \n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float FAR = 20.;\n  vec2 a = -1.0+2.0*(fragCoord.xy.xy/iResolution.xy);\n  a.x *= iResolution.x/iResolution.y;\n    \n    \n  vec3 target = vec3(0.0, 0.0, -1.0);\n  vec3 orig = vec3(0.0, 5.0, 100.0-1.8*iTime);\n  \n  vec3 cw = normalize(target-orig);\n  vec3 cu = normalize(cross(cw,vec3(0., 1.,0.)));\n  vec3 cv = normalize(cross(cu,cw));\n  mat3 camera = mat3(cu, cv, cw);\n  \n  vec3 dir = normalize(camera*vec3(a, 1.57));\n  vec3 n = vec3(0.);\n  float t = FAR;\n  vec3 p = render(orig, dir, n, t, FAR);\n\n  vec3 light = (target-orig)/distance(target, orig);\n    \n  vec3 col = vec3(0.);\n  if(t < FAR){\n    col = shading(n, p, light, dir, orig);\n    //Bit glow to the near parts\n  \tcol =  smoothstep(0., 1., col*(FAR/t*0.2));\n  }\n\n  float dist = length(p-orig);\n  float fogAmount = 1.0 - exp( -dist*.03);\n  col = mix(col, vec3(0.8), fogAmount);\n    \n  col = pow(col, 1.0/GAMMA);\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}