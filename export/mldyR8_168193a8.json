{"ver":"0.1","info":{"id":"mldyR8","date":"1698908897","viewed":51,"name":"FFT Issues Please Help!","username":"ndivuyo","description":"Please help with FFT! The values don't appear to be right. Using a sine wave as my source Buffer A (I intend 2 use for audio processing). I am visualizing here the magnitude of the FFT, which should be a single line at the fundamental.. it isn't..","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fft","dsp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nHere I pass the Buffer values of the 1 dimensional sine wave through the FFT. Then I get the\nmaginitudes of the complex number result of the FFT and visualize them. It should look like a single\nline forming around the bin(s) of the fundamental frequency of the sine tone. \nHowever the results I get are nothing like it and instead I just see a periodic window\nwhich is at the frequency of  fftSize/subtransformSize...\n*/\n\n\n#define BUFFER_IN iChannel0\nconst float TWO_PI = 6.2831853072;\nconst float FFT_SIZE = 1024.;\nfloat fftSizeHalf = FFT_SIZE * 0.5;\n\n// ****** NEED HELP HERE!!! ******\n/* This is the Subtransform size. I'm not sure exactly how it works,\nit will change the window oscillations you can see visualized (which shouldn't be..?)\nIt's hard to find info about it for some reason! I'm not sure what it should be! */\nconst float SUB_SIZE = 250.;\nfloat subSizeHalf = SUB_SIZE * 0.5;\n\n//\nvec2 multiplyComplex (vec2 a, vec2 b) {\n    return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\n}\n\n\n//GPU FFT using a Stockham formulation\nvec4 fft (\n    sampler2D src, \n    vec2 coord,\n    float transformSize, \n    float transformSizeHalf,\n    float subtransformSize,\n    float subtransformSizeHalf,\n    float horizontal\n) {\n    float index;\n    if (horizontal == 1.) {\n        index = gl_FragCoord.x - 0.5;//coord.x * transformSize - 0.5;\n    } else {\n        index = coord.y * transformSize - 0.5;\n    }\n\n    float evenIndex = 0.5 + floor(index / subtransformSize) * subtransformSizeHalf + mod(index, subtransformSizeHalf);\n\n    //transform two complex sequences simultaneously\n    vec4 even;\n    vec4 odd;\n    if (horizontal == 1.) {\n        even = texture(src, vec2(evenIndex, 0.) / transformSize).rgba;\n        //even = texture2D(src, vec2(evenIndex, 0.) / transformSize).rgba;\n        odd = texture(src, vec2(evenIndex + transformSizeHalf, 0) / transformSize).rgba;\n    } else {\n        even = texture(src, vec2(gl_FragCoord.x, evenIndex) / transformSize).rgba;\n        odd = texture(src, vec2(gl_FragCoord.x, evenIndex + transformSizeHalf) / transformSize).rgba;\n    }\n\n    float twiddleArgument1D = TWO_PI * -(index / subtransformSize);\n    vec2 twiddle1D = vec2(cos(twiddleArgument1D), sin(twiddleArgument1D));\n\n    vec2 outputA = even.xy + multiplyComplex(twiddle1D, odd.xy);  //even.xy\n    vec2 outputB = even.zw + multiplyComplex(twiddle1D, odd.zw); //even.zw\n    return vec4(outputA, outputB);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // Get FFT\n    vec4 fftRes = fft(BUFFER_IN, uv, FFT_SIZE, fftSizeHalf, SUB_SIZE, subSizeHalf, 1.);\n    // Get magnitude of bin\n    float mag = sqrt(fftRes.g*fftRes.g + fftRes.b*fftRes.b);   // output B\n    //float mag = sqrt(fftRes.a*fftRes.a + fftRes.r*fftRes.r); // output A\n    fragColor = vec4(mag,mag,mag,mag);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Filling the buffer with a 1D sine wave to represent audio\n\nconst float TWO_PI = 6.2831853072;\nconst float FFT_SIZE = 1024.;\nfloat freq = 10.; //about 430Hz depending on sr\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // Sine wave\n    float inputVal = sin( uv.x * TWO_PI * freq );\n    //inputVal = rand(vec2(iTime,iTime));\n    fragColor = vec4(inputVal,inputVal,inputVal,inputVal);\n}","name":"Buffer A","description":"","type":"buffer"}]}