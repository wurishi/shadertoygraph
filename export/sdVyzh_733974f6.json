{"ver":"0.1","info":{"id":"sdVyzh","date":"1654448800","viewed":180,"name":"Famous Optimization Functions","username":"texflip","description":"Basic RayMarching Setup with famous optimization benchmark functions which is possible to navigate around. The one currently showning is the Rastrigin function in 2 dimensions. Press 0,1,2,3,4,5,6,7,8,9,- to change function.","likes":4,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","optimizationfunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float color_range = 0.05;\nconst float zoom = 5.;\nconst float res = 0.5;\nvec3 camera_position = vec3(-10.0, 20.0, 10.0);\nvec3 camera_target = vec3(0.0, 0.0, 0.0);\n\nconst int NUMBER_OF_STEPS = 128;\nconst float SURF_DISTANCE = 0.01; // surface distance\nconst float MAX_DISTANCE = 1000.0;\nvec3 light_position = vec3(0, 15., 0);\nconst float pi = 3.1415926535897932384626433832795;\nconst float sqrt2 = 1.4142135623730950488016887242097;\n\nvec3 cm_viridis(float t) {\n    if (abs(t-0.5) > 0.5)\n        return vec3(1.);\n    \n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n// optimization functions!\n\nfloat sphere(vec2 c){\n    float x = c.x;\n    float y = c.y;\n    float f = x*x + y*y;\n    return f/1000.;\n}\n\nfloat rastrigin(vec2 c){\n    float x = c.x;\n    float y = c.y;\n\n    x = x*x - 10. * cos(2. * pi * x) + 10.;\n    y = y*y - 10. * cos(2. * pi * y) + 10.;\n\n    return (x + y)/50.;\n}\n\nfloat ackley(vec2 c){\n    float x = c.x;\n    float y = c.y;\n\n    float f = -20. * exp(-0.2 * sqrt(0.5 * (x * x + y * y))) - exp(0.5 * (cos(2. * pi * x) + cos(2. * pi * y))) + exp(1.) + 20.;\n\n    return f/2.;\n}\n\nfloat griewank(vec2 c){\n    float x = c.x;\n    float y = c.y;\n\n    float f = 1. + (x * x / 4000.) + (y * y / 4000.) - cos(x) * cos(y / sqrt2);\n\n    return f * 2.;\n}\n\nfloat rosenbrock(vec2 c){\n    c += 1.;  // center the optimial value to (0,0)\n    float x = c.x;\n    float y = c.y;\n\n    float f = 100. * (y - x * x) * (y - x * x) + (1. - x) * (1. - x);\n\n    return f/1000000.;\n}\n\nfloat schwefel(vec2 c){\n    c += 420.968746; // center the optimial value to (0,0)\n    float x = c.x;\n    float y = c.y;\n\n    float f = 418.9829 * 2. - x * sin(sqrt(abs(x))) - y * sin(sqrt(abs(y)));\n\n    return f/20.;\n}\n\nfloat bukin(vec2 c){\n    float x = c.x - 10.;\n    float y = c.y + 1.;\n\n    float f = 100. * sqrt(abs(y - 0.01 * x * x)) + 0.01 * abs(x + 10.);\n\n    return f/50.;\n}\n\nfloat drop_wave(vec2 c){\n    float x = c.x*0.5;\n    float y = c.y*0.5;\n\n    float f = -(1.+ cos(12. * sqrt(x * x + y * y))) / (0.5 * (x * x + y * y) + 2.);\n\n    return (f+5.);\n}\n\nfloat eggholder(vec2 c){\n    // usually evaluated on the square xi ∈ [-512, 512], so there are better minimas outside the square\n    // and the colors are not good\n    float x = c.x + 512.;\n    float y = c.y + 404.2319;\n\n    float f = -(y + 47.) * sin(sqrt(abs(x / 2. + y + 47.))) - x * sin(sqrt(abs(x - (y + 47.))));\n\n    return (f + 959.6407)/50.;\n}\n\nfloat holder_table(vec2 c){\n    // dont go outside xi ∈ [-10, 10] !!!\n    float x = c.x + 8.05502;\n    float y = c.y + 9.66459;\n\n    float f = -abs(sin(x) * cos(y) * exp(abs(1. - sqrt(x * x + y * y) / pi)));\n\n    return (f+19.2085)/50.;\n}\n\nfloat shaffer(vec2 c){\n    float x = c.x;\n    float y = c.y;\n\n    float f = 0.5 + (sin(x + y) + (x - y) * (x - y) - 0.5 * (x + y)) * (sin(x + y) + (x - y) * (x - y) - 0.5 * (x + y)) / (1. + 0.001 * (x + y) * (x + y));\n\n    return f/15000.;\n}\n\nfloat weierstrass(vec2 c){\n    c *= 0.0001;\n    float x = c.x+0.08;\n    float y = c.y;\n    const float inv_arr2k[12] = float[12](1.0,0.5,0.25,0.125,0.0625,0.03125,0.015625,0.0078125,0.00390625,0.001953125,0.0009765625,0.00048828125);\n    const float arr3k[12] = float[12](1.,3.,9.,27.,81.,243.,729.,2187.,6561.,19683.,59049.,177147.);\n\n    float x1 = 2. * pi * (x + .5);\n    float y1 = 2. * pi * (y + .5);\n\n    float x2 = 0., y2 = 0.;\n    for (int i = 0; i < 12; i++){\n        x2 += inv_arr2k[i] * cos(x1 * arr3k[i]);\n        y2 += inv_arr2k[i] * cos(y1 * arr3k[i]);\n    }\n\n    float f = ((x2 + y2) * 0.5 + 1.99951171875);\n    f = 10. * f*f*f;\n\n    return f * 4.;\n}\n\nfloat katsuura(vec2 c){\n    c *= 0.01;\n    float x = c.x;\n    float y = c.y;\n    const float arr2k[32] = float[32](2.,4.,8.,16.,32.,64.,128.,256.,512.,1024.,2048.,4096.,8192.,16384.,32768.,65536.,131072.,262144.,524288.,1048576.,2097152.,4194304.,8388608.,16777216.,33554432.,67108864.,134217728.,268435456.,536870912.,1073741824.,2147483648.,4294967296.);\n    const float inv_arr2k[32] = float[32](.5,.25,.125,.0625,.03125,.015625,.0078125,.00390625,.001953125,.0009765625,.00048828125,0.000244140625,0.0001220703125,0.00006103515625,0.000030517578125,0.0000152587890625,0.00000762939453125,0.000003814697265625,0.0000019073486328125,0.00000095367431640625,0.000000476837158203125,0.0000002384185791015625,0.00000011920928955078125,0.000000059604644775390625,0.0000000298023223876953125,0.00000001490116119384765625,0.000000007450580596923828125,0.0000000037252902984619140625,0.00000000186264514923095703125,0.000000000931322574615478515625,0.0000000004656612873077392578125,0.00000000023283064365386962890625);\n\n\n    float arr_x[32];\n    float arr_y[32];\n    \n    // the original katsuura uses max_a = 32\n    // but we use max_a = 8 for higher fps\n    int i = 0, max_a = 8; \n\n    for(i = 0; i < max_a; i++){\n        arr_x[i] = x * arr2k[i];\n        arr_y[i] = y * arr2k[i];\n    }\n\n    for(i = 0; i < max_a; i++){\n        arr_x[i] = abs(arr_x[i] - round(arr_x[i]));\n        arr_y[i] = abs(arr_y[i] - round(arr_y[i]));\n    }\n\n    float dot_x = 0., dot_y = 0.;\n    for(i = 0; i < max_a; i++){\n        dot_x += arr_x[i] * inv_arr2k[i];\n        dot_y += arr_y[i] * inv_arr2k[i];\n    }\n\n    float f = -2.5 + 2.5 * pow((dot_x + 1.) * (dot_y * 2. + 1.), 4.3527528164);\n\n    return f*0.25;\n}\n\nfloat fun_selection(vec2 c){\n    float f = 0.0;\n   \n\n    f = rastrigin(c);\n    if (texelFetch( iChannel0, ivec2(49,0), 0 ).x > 0.5){\n        f = ackley(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(50,0), 0 ).x > 0.5){\n        f = griewank(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(51,0), 0 ).x > 0.5){\n        f = rosenbrock(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(52,0), 0 ).x > 0.5){\n        f = schwefel(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(53,0), 0 ).x > 0.5){\n        f = bukin(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(54,0), 0 ).x > 0.5){\n        f = drop_wave(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(55,0), 0 ).x > 0.5){\n        f = eggholder(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(56,0), 0 ).x > 0.5){\n        f = holder_table(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(57,0), 0 ).x > 0.5){\n        f = shaffer(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(48,0), 0 ).x > 0.5){\n        f = weierstrass(c);\n    }\n    else if (texelFetch( iChannel0, ivec2(189,0), 0 ).x > 0.5){\n        f = katsuura(c);\n    }\n    \n    return f;\n}\n\n//___________________________Rendering Stuff___________________________________\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// map the world\nfloat map(in vec3 p)\n{\n    float plane = (dot(p, vec3(0.0, 1.0, 0.0)) - fun_selection(p.xz) * exp(zoom*0.1)) * res;\n    return plane;\n}\n\nvec3 get_normal(vec3 p){\n\t//sampling around the point\n\tvec2 e = vec2(0.01, 0.0);\n\tfloat d = map(p);\n\tvec3 n = d - vec3(\n\t\t\t\t\tmap(p-e.xyy),\n\t\t\t\t\tmap(p-e.yxy),\n\t\t\t\t\tmap(p-e.yyx));\n\treturn normalize(n);\n}\n\nvec2 shadow(in vec3 ro, in vec3 rd, float max_dist)\n{\n    float dist_origin = 0.0, min_dist = 1000000.;\n    float distance_to_closest = 0.;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 curr_pos = ro + dist_origin * rd;\n\n        distance_to_closest = map(curr_pos);\n\n        if (i>1 && min_dist > distance_to_closest){\n            min_dist = distance_to_closest;\n        }\n        dist_origin += distance_to_closest * res;\n\n\n        if(dist_origin > max_dist)\n            return vec2(1., min_dist); // no shadow\n\n        if (distance_to_closest < SURF_DISTANCE*0.1)\n            return vec2(0., 0.); // shadow\n            \n    }\n    \n    // this mostly happens when the light ray is almost parallel to a flat-ish function,\n    // so here the point is probably illuminated,\n    // but it's possible that far obstacles (w.r.t. the point) don't cast shadows.\n    // this can be solved with another march from the light, but it's expensive\n    return vec2(1., min_dist);\n}\n\n// ro is the ray origin\n// rd is the ray direction\nvec2 ray_march(in vec3 ro, in vec3 rd)\n{\n    float dist_origin = 0.0, min_dist = 10.; // distance origin\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 curr_pos = ro + dist_origin * rd;\n\n        float distance_to_closest = map(curr_pos);\n\n        dist_origin += distance_to_closest * res;\n\n        if (dist_origin < 5. && min_dist > distance_to_closest){\n            min_dist = distance_to_closest;\n        }\n\n        if (abs(distance_to_closest) < SURF_DISTANCE*0.1 || dist_origin > MAX_DISTANCE) break;\n    }\n\n    return vec2(dist_origin, min_dist);\n}\n\nfloat GetLight(vec3 p, vec3 n) {\n    vec3 l = normalize(light_position - p);\n    float max_dist = length(light_position - p);\n    \n    float dif = clamp(dot(n, l) * .5 + .5, 0., 1.);\n    \n    // compute shadows\n    const float shd_f = 0.5; //shadow force\n    vec2 rm_out = shadow(p + n * SURF_DISTANCE * 2.01, l, max_dist);\n    float shadow = rm_out.x;\n    float min_dist = rm_out.y;\n    if(shadow > 0.) { \n        // here there isn't a shadow, however, to slightly simulate an area light, if the light ray passes near\n        // an obstacle (min_dist is low), the light should be a bit weaker\n        dif *= shd_f + smoothstep(0.01, 0.04, min_dist) * (1. - shd_f);\n    }\n    else {\n        // here there is a shadow\n        dif *= shd_f;\n    }\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n\n    vec3 ro = camera_position; // ray origin a.k.a. camera position\n    ro.xz *= Rot(-iMouse.x*0.01+iTime*0.1);\n    camera_target.y = (iMouse.y - iResolution.y/4.)/iResolution.y * 50.;\n\n    vec3 col = vec3(0.); // background color\n\n    vec3 rd = R(uv*1.5, ro, camera_target, 1.);\n\n    float dist = ray_march(ro, rd).x;\n\n    if(dist < MAX_DISTANCE) {\n    \tvec3 p = ro + rd * dist;\n        float f = fun_selection(p.xz);\n        vec3 nor = get_normal(p);\n\n        // light computation\n    \tcol = vec3(GetLight(p, nor)) * cm_viridis(f * color_range);\n    }\n\n    col = pow(col, vec3(.4545)); // gamma correction (very important)\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}