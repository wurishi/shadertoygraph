{"ver":"0.1","info":{"id":"Dts3zl","date":"1672241799","viewed":117,"name":"Mister Potatoe","username":"mmartosdev","description":"Testing thingies","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(in vec3 p, in float s)\n{\n    return length(p) - s;\n}\n\nfloat sdYPlane(in vec3 p, in float h)\n{\n    return p.y - h;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opI(vec2 d1, vec2 d2)\n{\n\treturn (d1.x > d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n\treturn (d1.x > -d2.x) ? d1 : vec2(-d2.x,d2.y);\n}\n\nvec2 opSmoothUnion( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h),d1.y); \n}\n\nvec2 opSmoothSubtraction( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2.x+d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, -d1.x, h ) + k*h*(1.0-h), d1.y); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2( 10.0, 0.0 );\n    \n    // Body\n    res = opU(res, vec2(sdSphere(pos - vec3(0.0, 1.0, 0.0), 0.75), 1.0));\n    \n    // Head\n    res = opSmoothUnion(res, vec2(sdSphere(pos - vec3(0.0, 1.5, 0.0), 0.65), 1.0), 0.1);\n    \n    // Nose\n    vec3 sh = vec3(abs(pos.x),pos.yz);\n    float an = -0.28;\n    float cc = cos(an); \n    float ss = sin(an); \n    vec3 nose = vec3(sh.x, mat2(cc,-ss,ss,cc) * sh.yz) + vec3(0.0,-0.02 * abs(sin(3.0*iTime)),0.0);\n    res = opSmoothUnion(res, vec2(sdRoundCone(nose - vec3(0.0, 1.30, 1.05), 0.15, 0.02, 0.20), 1.0), 0.1);\n    res = opSmoothSubtraction(vec2(sdSphere(nose - vec3(0.09, 1.2, 1.0), 0.02), 0.01), res, 0.1);\n\n    // Mouth\n    vec3 mpos = vec3(0.0, 1.15, 0.8);\n    float mh = 0.08 * abs(sin(3.0*iTime));\n    res = opSmoothSubtraction(vec2(sdEllipsoid(pos - mpos, vec3(0.35,0.08 + mh,0.45)), 1.0), res, 0.1);\n    \n    // Eyes\n    res = opU(res, vec2(sdSphere(sh - vec3(0.25, 1.8, 0.45), 0.14), 2.0));\n    res = opU(res, vec2(sdSphere(sh - vec3(0.25, 1.82, 0.53), 0.08), 3.0));\n    \n    // Teeth\n    res = opU(res, vec2(sdRoundBox(sh - mpos - vec3(0.05, 0.045 + mh, -0.19), vec3(0.03, 0.04, -0.01), 0.02), 2.0));\n    res = opU(res, vec2(sdRoundBox(sh - mpos - vec3(0.15, 0.046 + mh, -0.2), vec3(0.03, 0.04, -0.01), 0.02), 2.0));\n    res = opU(res, vec2(sdRoundBox(sh - mpos - vec3(0.05, -0.065 - mh, -0.19), vec3(0.03, 0.04, -0.01), 0.02), 2.0));\n    res = opU(res, vec2(sdRoundBox(sh - mpos - vec3(0.15, -0.066 - mh, -0.2), vec3(0.03, 0.04, -0.01), 0.02), 2.0));\n    \n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n}\n\nvec2 rayCast(in vec3 ro, in vec3 rd)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.0;\n    float tmax = 50.0;\n\n    // raymarch primitives   \n    float t = tmin;\n    for (int i = 0; i < 100 && t < tmax; i++)\n    {\n        vec2 h = map(ro + rd * t);\n        if (abs(h.x) < (0.0001*t))\n        { \n            res = vec2(t,h.y); \n            break;\n        } \n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy)\n{\n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*1.3;\n    \n    vec2 res = rayCast(ro, rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m > -0.5)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(2.0);\n        if (m < 1.5) {\n            mate = vec3(1.0);\n        }\n        else if (m < 2.5) {\n            mate = vec3(2.0);\n        }\n        else if (m < 3.5) {\n            mate = vec3(0.0);\n        }\n        \n        vec3  sun_dir = normalize(vec3(0.45,0.27,0.35));\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n        float  sun_sha = step(rayCast(pos + nor * 0.001, sun_dir).x, 0.0);\n        vec3  sky_dir = vec3(0.0, 1.0, 0.0);\n        float sky_dif = clamp(0.5 + 0.5 * dot(nor, sky_dir), 0.0, 1.0);\n        float bou_dif = clamp(0.2 + 0.2 * dot(nor, vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n        col  = mate * vec3(1.0,0.7,0.5) * sun_dif * sun_sha;\n        col += mate * vec3(0.0,0.1,0.3) * sky_dif;\n        col += mate * vec3(0.7,0.3,0.2) * bou_dif;\n    }\n\treturn col;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = normalize(vec3(sin(cr), cos(cr), 0.0));\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup viewport coordinates: -0.5, -0.5 to 0.5, 0.5\n    float maxAxis = max(iResolution.x, iResolution.y);\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / maxAxis;\n    \n    // Define camera position\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ro = ta + vec3(6.0*sin(-8.0*iMouse.x/maxAxis), 1.6, 6.0*cos(-8.0*iMouse.x/maxAxis));\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    // Focal length\n    const float fl = 2.5;\n    \n    // Ray direction\n    vec3 rd = ca * normalize(vec3(p, fl));\n    \n    // Ray differentials\n    vec2 px = (2.0 * (fragCoord + vec2(1.0, 0.0)) - iResolution.xy) / maxAxis;\n    vec2 py = (2.0 * (fragCoord + vec2(0.0, 1.0)) - iResolution.xy) / maxAxis;\n    vec3 rdx = ca * normalize(vec3(px, fl));\n    vec3 rdy = ca * normalize(vec3(py, fl));\n    \n    vec3 col = render(ro, rd, rdx, rdy);\n    \n    // Gamma correction \n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}