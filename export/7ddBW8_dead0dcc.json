{"ver":"0.1","info":{"id":"7ddBW8","date":"1656441241","viewed":176,"name":"Progressive Renderer","username":"zitongwu","description":"Progressive Ray Tracing Renderer by Zitong Wu\nReference Textbook: Ray Tracing in One Weekend by Peter Shirley","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raytrace","progressiverender"],"hasliked":0,"parentid":"7tBfDK","parentname":"PA6 task10  zitongwu "},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Progressive Renderer \n// Reference: Ray Tracing in One Weekend by Peter Shirley\n// by Zitong Wu, 2022\n// Shadertoy: https://www.shadertoy.com/view/7ddBW8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy;\n    // get pixel color from buffer\n    vec3 color = texture(iChannel0, uv).rgb;\n    // gamma correction\n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color, 1.0);            \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Ray tracing in one weekend basecode for Dartmouth CS 77/177 \n// by Wojciech Jarosz, 2019\n\n#define EPSILON 1e-3 \n#define MAX_FLOAT 1e5\n#define MAX_RECURSION 5\n# define PI 3.14159265358979323846\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = rand2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = rand3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Progressive Renderer \n// Reference: Ray Tracing in One Weekend by Peter Shirley\n// by Zitong Wu, 2022\n// Shadertoy: https://www.shadertoy.com/view/7ddBW8\n\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\n//\n// Structs\n//\n\nstruct camera {  \n    vec3 lookfrom;\n    vec3 lookat;\n    vec3 vup;\n    float theta;\n    float h;\n    float aspect_ratio; \n    float aperture;\n    float focus_dist;\n    float lens_radius;\n    float viewport_height;             \n    float viewport_width;                 \n    vec3 origin;             \n    vec3 horizontal;             \n    vec3 vertical;             \n    vec3 lower_left_corner; \n    vec3 w;\n    vec3 u;\n    vec3 v;\n};\n\n\nstruct material {\n    vec3 albedo;\n    int type;\n    float var;   \n};\n\n\nstruct hit_record {     \n    vec3 p;     \n    vec3 normal;     \n    float t; \n    bool front_face;\n    material mat;\n};\n\nstruct ray { \n    vec3 origin;\n    vec3 direction;\n};\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    material mat;\n};\n\n\n//\n// Constant Scene: the globe and bid spheres\n//\n\n\nsphere[6] create_scene() {\n    // Materials\n    material material_ground = material(vec3(1.0, 0.5, 0.5), LAMBERTIAN, 0.);\n    material material_center = material(vec3(1., 1., 1.), LAMBERTIAN, 0.);\n    material material_left = material(vec3(1.0), DIELECTRIC, 1.5);\n    material material_light_gold = material(vec3(1.0, 1.0, 0.6), METAL, 0.2);\n    material material_gold = material(vec3(1.0, 1.0, 0.3), METAL, 0.0);\n    \n    \n    // Spheres\n    sphere spheres[6] = sphere[6](\n        sphere(vec3( 0.0, -1000.5, -1.0), 1000.0, material_ground),\n        sphere(vec3( -0.05,    0.1, -0.8),   0.7, material_center),\n        sphere(vec3(-1.15,    0.2, -1.0),   0.5, material_left),\n        sphere(vec3( 1.15,    -0.15, -1.0),   0.35, material_light_gold),\n        sphere(vec3( 0.34,    0.0, 0.2),   0.2, material_gold),\n        sphere(vec3( 0.05,    -0.1, 0.2),   0.1, material_left)\n    );\n    \n    return spheres;\n}\n\n\n//\n// Helper Functions\n//\n\nvoid set_face_normal(const ray r, const vec3 outward_normal, inout hit_record rec) {\n    rec.front_face = dot(r.direction, outward_normal) < 0.;\n    rec.normal = rec.front_face ? outward_normal : -outward_normal;\n}\n\nvec3 refract(const vec3 uv, const vec3 n, float etai_over_etat) {     \n    float cos_theta = min(dot(-uv, n), 1.0);     \n    vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*n);     \n    vec3 r_out_parallel = -sqrt(abs(1.0 - pow(length(r_out_perp), 2.))) * n;     \n    return r_out_perp + r_out_parallel; \n}\n\nfloat reflectance(float cosine, float ref_idx) {             \n    float r0 = (1.-ref_idx) / (1.+ref_idx);             \n    r0 = r0*r0;             \n    return r0 + (1.-r0)*pow((1. - cosine),5.);         \n}\n\nray get_ray(float s, float t, const camera cam) {\n    vec3 rd = cam.lens_radius * vec3(random_in_unit_disk(g_seed), 0.);             \n    vec3 offset = cam.u * rd.x + cam.v * rd.y;\n    return ray(cam.origin + offset, cam.lower_left_corner + s*cam.horizontal + t*cam.vertical - cam.origin - offset); \n}\n\nfloat degrees_to_radians(float degrees) {\n    return degrees * PI /180.;\n} \n\nvec3 average_color(vec3 summed_color, int samples_per_pixel) {\n    float r = summed_color.x;\n    float g = summed_color.g;\n    float b = summed_color.b;\n    \n    r = pow(r / float(samples_per_pixel), 1.0/2.2);\n    g = pow(g / float(samples_per_pixel), 1.0/2.2);\n    b = pow(b / float(samples_per_pixel), 1.0/2.2);\n    \n    r = clamp(r, 0., 1.);\n    g = clamp(g, 0., 1.);\n    b = clamp(b, 0., 1.);\n    \n    return vec3(r, g, b);\n}\n\n\n//\n// Major Functions\n//\n\n\n// Hit function for a single sphere\nbool sphere_hit(const ray r, float t_min, float t_max, inout hit_record rec, sphere s) {\n    vec3 center = s.center;\n    float radius = s.radius;\n    vec3 oc = r.origin - center;     \n    float a = pow(length(r.direction), 2.);     \n    float half_b = dot(oc, r.direction);     \n    float c = pow(length(oc), 2.) - radius*radius;\n    float discriminant = half_b*half_b - a*c;     \n    if (discriminant < 0.) return false; \n    float sqrtd = sqrt(discriminant);\n\n    // Find the nearest root that lies in the acceptable range.     \n    float root = (-half_b - sqrtd) / a;     \n    if (root < t_min || t_max < root) {         \n        root = (-half_b + sqrtd) / a;         \n        if (root < t_min || t_max < root) return false;     \n    }\n    \n    rec.t = root;\n    rec.p = r.origin + rec.t * r.direction;\n    vec3 outward_normal = (rec.p - s.center) / s.radius;     \n    set_face_normal(r, outward_normal, rec);\n    rec.mat = s.mat;\n   \n    return true;\n}\n\n// Hit function for the entire scene\nbool world_hit(const ray r, float t_min, float t_max, out hit_record rec, sphere[6] spheres) {\n    hit_record temp_rec;     \n    bool hit_anything = false;     \n    float closest_so_far = t_max;\n    \n    for (int i = 0; i < spheres.length(); i++) {         \n        if (sphere_hit(r, t_min, closest_so_far, temp_rec, spheres[i])) {             \n            hit_anything = true;             \n            closest_so_far = temp_rec.t;             \n            rec = temp_rec;         \n        }     \n    }\n    \n    float seed = 1.0;\n   \n    for (int a = -10; a < 10; a += 1) {         \n        for (int b = -10; b < 10; b += 1) {    \n            float choose_mat = rand1(seed);             \n            vec3 center = vec3(float(a) + 1.5*rand1(seed), -0.3, float(b) + 1.5*rand1(seed));\n            sphere s;\n            \n            if (length(center - vec3(4, 0.2, 0)) > 0.9) {     \n                material sphere_material;\n                if (choose_mat < 0.8) {\n                    // diffuse\n                    vec3 albedo = rand3(seed)  + 0.5;\n                    sphere_material = material(albedo, LAMBERTIAN, 0.);\n                    s = sphere(center, 0.2, sphere_material);;\n                } else if (choose_mat < 0.95) {\n                    // metal\n                    vec3 albedo = rand3(seed) / 2. + 0.5;\n                    float fuzz = rand1(seed)/2.;\n                    sphere_material = material(albedo, METAL, fuzz); \n                    s = sphere(center, 0.2, sphere_material);;\n                } else {\n                    // glass\n                    sphere_material = material(vec3(1.0), DIELECTRIC, 1.5);\n                    s = sphere(center, 0.2, sphere_material);;\n                }\n                \n                if (sphere_hit(r, t_min, closest_so_far, temp_rec, s)) {             \n                    hit_anything = true;             \n                    closest_so_far = temp_rec.t;             \n                    rec = temp_rec;         \n                } \n            }\n        }\n    }\n    return hit_anything;\n}\n\nbool scatter(ray r_in, hit_record rec, out vec3 attenuation, out ray scattered, material mat) {\n    if (mat.type == LAMBERTIAN) {\n        vec3 scatter_direction = normalize(rec.normal + random_in_unit_sphere(g_seed));       \n        scattered = ray(rec.p, scatter_direction);             \n        attenuation = mat.albedo;             \n        return true; \n    }\n    \n    if (mat.type == METAL) {\n        vec3 reflected = normalize(reflect(normalize(r_in.direction), rec.normal));             \n        scattered = ray(rec.p, normalize(reflected + mat.var * random_in_unit_sphere(g_seed)));             \n        attenuation = mat.albedo;             \n        return dot(scattered.direction, rec.normal) > 0.;  \n    }\n    \n    if (mat.type == DIELECTRIC) {             \n        attenuation = vec3(1.0, 1.0, 1.0); \n        float refraction_ratio = rec.front_face ? (1.0/mat.var) : mat.var;\n        vec3 unit_direction = normalize(r_in.direction);             \n        float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);             \n        float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;             \n        vec3 direction;\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > rand1(g_seed))                 \n            direction = reflect(unit_direction, rec.normal);             \n        else                 \n            direction = refract(unit_direction, rec.normal, refraction_ratio);\n        scattered = ray(rec.p, direction);             \n        return true ;\n    }\n}\n\n\nvec3 ray_color(const ray r, int max_depth) {\n    sphere spheres[6] = create_scene();\n    hit_record rec;  \n    int depth = max_depth;\n    ray current_r = r;\n    bool scatter_bool = true;\n    vec3 all_attenuation = vec3(1, 1, 1);\n    ray scattered;\n    vec3 attenuation;\n    float infinity = 3.402823466e+38;\n    \n      \n    while (depth > 0 && world_hit(current_r, 0.001, infinity, rec, spheres) == true) { \n        scatter_bool = scatter(current_r, rec, attenuation, scattered, rec.mat);\n        if (scatter_bool == true) {            \n            all_attenuation *= attenuation;\n            depth -= 1;    \n            current_r = scattered;\n        } else {\n            break;\n        }\n    }\n    \n    vec3 color;\n    if (depth <= 0 || scatter_bool == false) {\n        color = vec3(0, 0, 0);\n    } else {\n        vec3 unit_direction = normalize(current_r.direction);     \n        float t = 0.5*(unit_direction.y + 1.0);     \n        color = (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0); \n    }        \n    \n    return color * all_attenuation;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set\n    init_rand(fragCoord, iTime);\n    float aspect_ratio = float(iResolution.x / iResolution.y);     \n    int image_width = 400;     \n    int image_height = int(float(image_width) / aspect_ratio);\n    int samples_per_pixel = 100;\n    int max_depth = 50;\n    \n    // Camera   \n    vec3 lookfrom = vec3(-2.5,2,6);\n    vec3 lookat = vec3(0,0,-1);\n    vec3 vup = vec3(0,1,0);\n    float theta = degrees_to_radians(20.);             \n    float h = tan(theta/2.);             \n    float viewport_height = 2.0 * h; \n    float viewport_width = aspect_ratio * viewport_height; \n    vec3 origin = lookfrom;\n    \n    // defocus blur\n    float aperture = 0.2; ;\n    float focus_dist = length(lookfrom-lookat);    \n    vec3 w = normalize(lookfrom - lookat);             \n    vec3 u = normalize(cross(vup, w));             \n    vec3 v = cross(w, u);                 \n    vec3 horizontal = focus_dist * viewport_width * u;             \n    vec3 vertical = focus_dist * viewport_height * v;             \n    vec3 lower_left_corner = origin - horizontal/2. - vertical/2. - focus_dist*w;\n    float lens_radius = aperture / 2.;  \n    \n    camera cam = camera(lookfrom, lookat, vup, theta, h, aspect_ratio, aperture, focus_dist, lens_radius, viewport_height, viewport_width, origin, horizontal, vertical, lower_left_corner, w, u, v);\n    \n    // Render    \n    vec2 uv = fragCoord/iResolution.xy; \n    float s = uv.x + rand1(g_seed) / iResolution.x;             \n    float t = uv.y + rand1(g_seed) / iResolution.y; \n    ray r = get_ray(s, t, cam);             \n\n    // Average Frames\n    vec3 new = ray_color(r, max_depth); \n    vec3 old = texture(iChannel0, uv).rgb;\n    float frame = float(iFrame);\n    vec3 color;\n    if (frame > 0.5) \n    \tcolor = ((frame - 1.0) * old + new) / frame;  \n    else\n        color = new;\n    \n    fragColor = vec4(color, 1.0);            \n}\n","name":"Buffer A","description":"","type":"buffer"}]}