{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":2,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// RedSpace\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Thanks to iq, P_Malin and PauloFalcao for all the excellent code examples\n\n\n#define d_StartDist 0.0\n#define d_FarClip 400.0\n#define d_maxIterations 50\n\n#define dEpsilon 0.01\n// structures\nstruct Ray \n{\n\tvec3 origin;\n\tvec3 direction;\n\tfloat farPlane;\n};\n\nstruct Surface\n{\n\tvec3 normal;\n};\n\nstruct Shading\n{\n\tvec3 diffuse;\n\tvec3 specular;\t\n};\n\nstruct Directional_Light\n{\n\tvec3 dir;\n\tvec3 color;\n\tfloat intensity;\n};\n\t\nstruct HitInfo\n{\n\tvec3 pos;\n\tfloat dist;\n\tfloat id;\n};\n\t\n// scene description\nvec3 background(vec2 fragCoord)\n{\n\tfloat hort = 1.0 - clamp((fragCoord.x + 0.2)/iResolution.x, 0.1, 1.0);\n\tfloat vert = 1.0 - clamp((fragCoord.y + 0.2)/(iResolution.y), 0.1, 1.0);\n\treturn vec3(0.8*(hort/2.0 + vert/2.0));\n}\n\nvec2 distUnion(const in vec2 obj1, const in vec2 obj2)\n{\n\treturn mix(obj1, obj2, step(obj2.x, obj1.x)); \n}\n\nvec3 rotate(in vec3 pos, in float anglex, in float angley, in float anglez)\n{\n\tmat3 rotM;\n\trotM[0].x = cos(angley) * cos(anglez);\n\trotM[0].y = -cos(angley) * sin(anglez);\n\trotM[0].z = sin(angley);\n\trotM[1].x = cos(anglex)*sin(anglez) + sin(anglex)*sin(angley)*cos(anglez);\n\trotM[1].y = cos(anglex)*cos(anglez) - sin(anglex)*sin(angley)*sin(anglez);\n\trotM[1].z = -sin(anglex)*cos(angley);\n\trotM[2].x = sin(anglex)*sin(anglez) - cos(anglex)*sin(angley)*cos(anglez);\n\trotM[2].y = sin(anglex)*cos(anglez) + cos(anglex)*sin(angley)*sin(anglez);\n\trotM[2].z = cos(anglex)*cos(angley);\n\t\n\treturn rotM * pos;\n}\n\nvec3 rotsim2(vec3 p, float s)\n{\n\tvec3 result = p;\n\tfloat r1 = -3.1416/(s*(4.5));\n\tresult = rotate(p, 0.0, r1, 0.0);\n\tfloat r2 = floor(atan(result.x, result.z)/3.1416*s)*(3.1416/s);\n\tresult = rotate(p, 0.0, r2, 0.0);\n\t//result = rotate(p, 0.0, 3.1416, 0.0);\n\treturn result;\n}\n\nvec2 sceneDescription(const in vec3 pos)\n{\n\tvec2 result = vec2(1000.0, -1.0);\n\t\n\t// sphere\n\tvec3 translate = vec3(0.0, 0.0, 55.0);\n\tvec2 distSphere = vec2(length(pos + translate) - 2.0, 1.0); \n\tresult = distUnion(result, distSphere);\n\t\n\t//box\n\tvec3 pos2 = pos+translate;\n\tpos2 = rotate (pos2, -0.2, iTime*0.4, -0.2);\n\tpos2 = rotsim2(pos2,7.0);\n\tvec3 orbit = rotate(pos2, 0.0, 3.1416, 0.0);\n\tvec3 translate2 = vec3(-10.0, -1.0, 16.0);\n\tvec3 ot = orbit+translate2;\n\tot = vec3(mod(ot.x, 8.0) - 4.0, ot.yz);\n\tvec3 rpos = rotate(ot, iTime, -iTime, iTime*2.0);\n\tvec2 distBox = vec2(length(max(abs(rpos) - 0.8, 0.0)), 2.0);\n\t\n\tresult = distUnion(result, distBox);\n\t\n\treturn result;\n}\n\nDirectional_Light getDLight(const in int index)\n{\n\tDirectional_Light dl;\n\tif(index == 0){\n\t\tdl.dir = normalize(vec3(0.8, 0.3, -1.0));\n\t\tdl.color = vec3(1.0, 1.0, 1.0);\n\t\tdl.intensity = 1.0;\n\t}\n\telse if(index == 1) {\n\t\tdl.dir = normalize(vec3(-0.5, -0.5, 0.5));\n\t\tdl.color = vec3(1.0, 1.0, 1.0);\n\t\tdl.intensity = 1.0;\n\t}\n\treturn dl;\n}\n\n// raymarcher\nvec3 pointNormal(const in vec3 pos) \n{\n\tconst float delta = 0.025;\n\tvec3 offs1 = vec3(  delta, -delta, -delta );\n\tvec3 offs2 = vec3( -delta, -delta,  delta );\n\tvec3 offs3 = vec3( -delta,  delta, -delta );\n\tvec3 offs4 = vec3(  delta,  delta,  delta );\n\t\n\tfloat f1 = sceneDescription(pos + offs1).x;\n\tfloat f2 = sceneDescription(pos + offs2).x;\n\tfloat f3 = sceneDescription(pos + offs3).x;\n\tfloat f4 = sceneDescription(pos + offs4).x;\n\t\n\tvec3 normal = offs1 * f1 + offs2 * f2 + offs3 * f3 + offs4 * f4;\n\t\n\treturn normalize(normal);\n}\n\nRay ProjectRay( in vec3 lookfrom, in vec3 lookat, in float zf, in vec2 dof, in vec2 fragCoord )\n{\n\tRay newRay;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 view = uv * 2.0 - 1.0;\n\t\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\tview.y /= aspectRatio;\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\t\n\tnewRay.origin = lookfrom;\n\tvec3 n = normalize(lookat - lookfrom);\n\tvec3 u = normalize(cross(up, n));\n\tvec3 v = normalize(cross(u,n));\n\t\n\tRay dofRay;\n\tfloat Noise = (texture(iChannel2, vec2(uv.x+iTime*3.14, uv.y)).r + texture(iChannel2, vec2(uv.x, uv.y+iTime*-1.37)).r);\n\tdofRay.origin = lookfrom + vec3(Noise*dof*0.5, 0.0);\n\t\n\tnewRay.direction = normalize(zf * n + view.x * u + view.y * v);\n\t\n\tdofRay.direction = normalize(newRay.direction*40.0 - dofRay.origin);\n\tdofRay.farPlane = d_FarClip;\n\treturn dofRay;\n}\n\n\nHitInfo intersect( const in Ray r ) \n{\t\n\tHitInfo result = HitInfo(r.origin, 0.0, 0.0);\n\t\n\tfor(int i = 0; i < d_maxIterations; i++)\n\t{\n\t\tresult.pos = r.origin + r.direction * result.dist;\n\t\tvec2 sceneDist = sceneDescription(result.pos);\n\t\tif(sceneDist.x <= dEpsilon)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tresult.dist = result.dist + sceneDist.x;\n\t\tresult.id = sceneDist.y;\n\t}\n\tif(result.dist >= r.farPlane)\n\t{\n\t\tresult.pos = r.origin;\n\t\tresult.dist = r.farPlane;\n\t\tresult.id = 0.0;\n\t}\n\t\n\treturn result;\n}\n// light and shade\n\nShading applyDLight(in Directional_Light dL, in vec3 pos, in vec3 inDir, in vec3 norm)\n{\n\tShading shade;\n\tvec3 lightDir = -dL.dir;\n\t\n\tvec3 inL = dL.color * max(0.0, dot(lightDir, norm));\n\tshade.diffuse =  inL * dL.intensity;\n\t\n\tvec3 halfAngle = normalize(lightDir - inDir);\n\tfloat NH = max(0.0, dot(halfAngle, norm));\n\t\n\t\n\tshade.specular = (pow(NH, 300.0) * inL) * dL.intensity;\n\treturn shade;\n}\n\nvec3 shading(in vec3 pos, in vec3 inDir, in float objectID)\n{\n\t\n\tconst int numDLights = 1;\n\t\n\tvec3 n = pointNormal(pos);\n\t\n\tShading shade;\n\tshade.diffuse = vec3(0.0);\n\tshade.specular = vec3(0.0);\n\t\n\tshade.diffuse += vec3(0.1);\n\t\n\t\n\tDirectional_Light dL = getDLight(0);\n\tShading dLcontribution = applyDLight(dL, pos, inDir, n);\n\tshade.diffuse += abs(dLcontribution.diffuse);\n\tshade.specular += abs(dLcontribution.specular);\n\t\n\tdL = getDLight(1);\n\tdLcontribution = applyDLight(dL, pos, inDir, n);\n\tshade.diffuse += abs(dLcontribution.diffuse);\n\n\t\n\t//material\n\tshade.diffuse *= vec3(0.9, 0.1, 0.05);\n\tshade.specular *= vec3(1.0);\n\t\n\treturn vec3(shade.diffuse + shade.specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec3 eye = vec3(0.0,0.0,5.0);\n\tvec3 lookat = vec3(0.0, 0.0, 0.0);\n\t\n\tvec2 dof[4];\n\tdof[0] = vec2(0.5*texture(iChannel2, vec2(0.0, -iTime*1.61)).s, \n\t\t\t\t  -0.42*texture(iChannel2, vec2(iTime*1.07, 0.7)).t);\n\tdof[1] = vec2(0.1*texture(iChannel2, vec2(1.4, iTime*0.3)).s, \n\t\t\t\t  0.92*texture(iChannel2, vec2(-iTime*1.44, 0.3)).t);\n\tdof[2] = vec2(-0.58*texture(iChannel2, vec2(0.3, iTime*3.0)).s, \n\t\t\t\t  -0.81*texture(iChannel2, vec2(-iTime*4.2, 0.5)).t);\n\tdof[3] = vec2(0.95*texture(iChannel2, vec2(0.6, iTime*2.71)).s, \n\t\t\t\t  0.52*texture(iChannel2, vec2(iTime*0.88, 0.9)).t);\n\t\n\tvec3 totalColor = vec3(0.0);\n\tvec3 rayContrib[4]; \n\t\n\tfor(int i = 0; i < 3; i++)\n\t{\n\t\tRay fragRay = ProjectRay(eye, lookat, 3.0, dof[i],fragCoord);\n\t\tHitInfo obj = intersect(fragRay);\n\t\tvec3 color = background(fragCoord);\n\t\tif(obj.id > 0.5) {\n\t\t\tcolor = shading(obj.pos, fragRay.direction, obj.id);\t\n\t\t}\n\t\trayContrib[i] = color;\n\t}\n\t\n\ttotalColor = (rayContrib[0] + rayContrib[1] + rayContrib[2])/ 3.0;\n\t\n\tfragColor = vec4( totalColor, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdl3z8","date":"1364365320","viewed":444,"name":"RedSpace","username":"auxreturn","description":"My first raymarcher.\nFinished 3/31/13","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","dof"],"hasliked":0,"parentid":"","parentname":""}}