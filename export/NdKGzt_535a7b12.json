{"ver":"0.1","info":{"id":"NdKGzt","date":"1631963969","viewed":94,"name":"Retro sdf car with pbr","username":"SergeyVol","description":"Sdf car with pbr in retro style\nBackground:\nhttps://www.shadertoy.com/view/WdGSzz\nCredit: https://www.shadertoy.com/user/JennySchub","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["retro","sdf","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 10);\nconst vec3  light    = vec3  ( 0.0, 5.0, 10.0 );\nconst int   maxSteps = 100;\nconst float eps      = 0.01;\nconst float carDown  = 1.7;\nconst float pi    = 3.1415926;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0;\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length ( p.xz ) - t.x, p.y );\n\t\n\treturn length ( q ) - t.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n    vec3 q = m * p * rotateX(-pi / 2.3) * rotateY(pi) * rotateZ(pi / 10.0);\n    \n\treturn max(\n        smin(\n            max(\n                smin(\n                    min(\n                        smin(\n                            min(dTorus ( q + vec3( 2.0, -2.0, 0.0 - carDown), vec2 ( 0.5, 0.3 ) ), \n                                dTorus ( q + vec3( 2.0, 2.0, 0.0 - carDown), vec2 ( 0.5, 0.3 ) )),\n                            sdCappedCylinder( q + vec3( 2.0, 0.0, 0.0 - carDown), 0.02, 2.2 ), 8.0 ),\n                        smin(\n                            min(dTorus ( q + vec3( -2.0, -2.0, 0.0 - carDown), vec2 ( 0.5, 0.3 ) ), \n                                dTorus ( q + vec3( -2.0, 2.0, 0.0 - carDown), vec2 ( 0.5, 0.3 ) )),\n                            sdCappedCylinder( q + vec3( -2.0, 0.0, 0.0 - carDown), 0.02, 2.2 ), 8.0 )),\n                    sdEllipsoid(q + vec3( -0.75, 0.0, 0.4 - carDown), vec3( 4.0, 1.2, 1.0)), 3.0),\n                -sdEllipsoid(q + vec3( 0.0, 0.0, 1.3 - carDown), vec3( 1.5, 0.5, 0.5))),\n            sdEllipsoid(q + vec3( -1.5, 0.0, 1.3 - carDown), vec3( 0.6, 0.3, 0.6)), 5.0),\n        -sdEllipsoid(q + vec3( 3.2, 0.0, 0.4 - carDown), vec3( 0.4, 0.5, 0.25)));\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 20.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst float roughness = 0.3;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst vec3  clr  = vec3 ( 0.4, 0.0, 0.4 );\nconst float gamma = 90.0;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n    float metallness = 1.0;\n    vec3  base  = pow ( clr, vec3 ( gamma ) );\n    vec3  F0    = mix ( vec3(FDiel), clr, metallness );\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( F0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.25 * d * g / nv);\n\tvec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //retro wave\n    vec2 uvv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uvv);\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n        color = cookTorrance ( p, n, l, v );\n\t} \n\n        // Output to screen\n    \n    if (color != vec4 ( 0, 0, 0, 1 ))\n        fragColor = color;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision highp float;\n#endif\n\nuniform sampler2D backbuffer;\nuniform float time;\nuniform vec2 resolution;\n\n\n#define usePixelation false\n#define flickerFreq 1400.\n#define flickerSpeed 30.\n#define flickerIntensity .1\n#define motionblur .3\n\n#define iters 70\n#define minDst .001\n#define lineWidth .2\n#define lineCountX 35.\n#define lineCountY 50./3.\n#define speed -3.\n\n#define pixelsize .2\n\n#define gridColor vec3(.2,.05,1.)\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat noise(vec2 seed) {\n return fract(sin(dot(seed, vec2(12.9898,4.1414)))*43758.5453);\n}\nfloat getHeight(vec2 uv) {\n    float time = iTime;\n uv+=.5;\n uv.y-=time*speed;\n float y1 = floor(uv.y);\n float y2 = floor(uv.y+1.);\n float x1 = floor(uv.x) ;\n float x2 = floor(uv.x+1.);\n float iX1 =mix(noise(vec2(x1, y1)), noise(vec2(x2, y1)),fract(uv.x));\n float iX2 =mix(noise(vec2(x1, y2)), noise(vec2(x2, y2)),fract(uv.x));\n return mix(iX1, iX2, fract(uv.y) );\n}\n\nfloat getDistance(vec3 p) {\n return p.z-(1.-cos(p.x*15.))*.03*getHeight(vec2(p.x*lineCountX, p.y*lineCountY));\n}\n\nfloat getGridColor(vec2 uv){\n    float time = iTime;\n float zoom =1., col;\n  vec3  cam = vec3(0.,\n     1.,\n     .1),\n        lookat = vec3(0.),\n        fwd = normalize(lookat-cam),\n        //r = normalize(cross(fwd, vec3(0.,1.,0.))),\n       // u = cross(fwd, r),\n       u=normalize(cross(fwd, vec3(1.,0.,0.))),\n       r=cross(u,fwd),\n       c = cam + fwd*zoom,\n       i = c+r*uv.x+u*uv.y,\n       ray = normalize(i-cam);\n float distSur,\n        distOrigin=0.;\n\n vec3 p = cam;\n for(int i=0; i<iters; i++){\n    distSur = getDistance(p);\n    if(distOrigin>2.) break;\n    if(distSur<minDst) {\n     float lineW=lineWidth*distOrigin;\n     float xLines=smoothstep(lineW,0.,abs(fract(p.x*lineCountX)-.5));\n     float yLines=smoothstep(lineW*2.,0.,abs(fract(p.y*lineCountY-time*speed)-.5));\n     col+=max(xLines, yLines);\n     break;\n    }\n  p+=ray * distSur;\n  distOrigin+=distSur;\n }\n return max(0.,col-(distOrigin*.8));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec3 resolution = iResolution;\n  float val=0.;//(texture2D(backbuffer,vec2(0.)).r);\n    float sunHeight = sin(time*.1)*.1+.1;\n\n  //val=val<=0.?.5:val-.5;\n  vec3 last=texture(backbuffer,\n   vec2(floor(gl_FragCoord.xy*(usePixelation?pixelsize:1.))/resolution.xy/(usePixelation?pixelsize:1.))\n  ).rgb;\n  vec2 R = resolution.xy,\n  uv = ( gl_FragCoord.xy - .5* R ) / R.y + .5;\n\n  uv.y-=sunHeight;\n  uv.x+=val*.2;\n\n    // sun\n    float dist =2.5*length(uv-vec2(0.5,0.5));\n    float divisions = 50.0;\n\n\n    //float pattern = tri(fract(( uv.y + 0.5)* 20.0), 2.0/  divisions, divisionsShift)- (-uv.y + 0.26) * 0.85;\n    float pattern = (sin(uv.y*divisions*10. - time*2.)*1.2+uv.y*8.3)*uv.y-1.5+\n     sin(uv.x*20.+time*5.)*.01;\n    float sunOutline = smoothstep( 0.0,-0.0315, max( dist - 0.315, -pattern)) ;\n\n    vec3 c = sunOutline * mix(vec3( 4.0, 0.0, 0.2), vec3(1.0, 1.1, 0.0), uv.y);\n\n    // glow\n    float glow = max(0.0, 1.0 - dist * 1.25);\n    glow = min(glow * glow * glow, 0.325);\n    c += glow * vec3(1.5, 0.3, (.2+ 1.0)) * 1.1;\n\n    uv-=.5;\n\n    uv.y+=sunHeight;\n\n  uv.y+=.18;\n  if(uv.y<0.1)\n     c+=getGridColor(uv)*4.*gridColor;\n    float p=.1;\n     fragColor=1.0*(\n       1.3+sin(time*flickerSpeed+uv.y*flickerFreq)*flickerIntensity\n      )*vec4(\n\t   //vec3(mix(c, last,motionblur))\n\t   c\n      ,1.0);\n     float scanline=smoothstep(1.-.2/flickerFreq,1.,sin(time*flickerSpeed*.1+uv.y*4.));\n\t fragColor*=scanline*.2+1.;\n}","name":"Buffer A","description":"","type":"buffer"}]}