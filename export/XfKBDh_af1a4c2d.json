{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Change this to cellular2x2 for a 2x speedup,\n// at the cost of some AA ghosting artifacts.\n#define cellular cellular3x3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/max(iResolution.x, iResolution.y);\n\n    vec2 P1a, P1b, P1c, P1d, P1e;\n    float ID1a, ID1b, ID1c, ID1d, ID1e;\n\n    // Jaggedness for primary cracks\n    vec2 Fa = cellular(uv*32.0, 0.7, P1a, ID1a);\n    // Primary cracks: displace coordinates with Fa.xy\n    vec2 Fb = cellular(uv*16.0 + Fa*0.15, 0.7, P1b, ID1b);\n    // Variations in primary crack width\n    vec2 Fc = cellular(uv*24.0, 0.7, P1c, ID1c);\n    // Primary crack pattern: wobbly *and* with varying width\n    float cracks1 = aastep(0.1, Fb.y-Fb.x + (Fc.x-0.35)*0.18);\n\n    // Secondary cracks - cells have different scale and offset\n    vec2 Fd = cellular(uv*(32.0 + mod(ID1b,16.0)) + ID1b, 0.7, P1d, ID1d);\n    // Variations in secondary crack width\n    vec2 Fe = cellular(uv*64.0, 0.7, P1e, ID1e);\n    // Secondary crack pattern: different for each primary \"cell\"\n    float cracks2 = aastep(0.08, Fd.y-Fd.x + (Fe.x-0.2)*0.15);\n\n    // The AA of secondary cracks gets really wonky at primary\n    // cracks, but that's where cracks1 is zero, so no matter.\n    float craquelure = min(cracks1,cracks2);\n\n    // A variable amount of peeled-off flakes (0.1 means 10%)\n    float missing = step(0.1, ID1b/288.0); // ID1b is mod-289\n    craquelure = min(craquelure, missing);\n    \n    fragColor = vec4(vec3(craquelure), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// All code in this tab is hereby released into the\n// public domain by its original author, Stefan\n// Gustavson. Credit is appreciated but not required.\n\nfloat aastep(float a, float x) {\n    float fw = 0.5*fwidth(x-a);\n    return smoothstep(-fw, fw, x-a);\n}\n\nfloat aastep(float a, float x, float d) {\n    float fw = 0.5*fwidth(d);\n    return smoothstep(-fw, fw, x-a);\n}\n\nfloat permute289(float x) {\n  return mod((34.0 * x + 10.0) * x, 289.0);\n}\n\n// 2x2 search window, faster and often good enough for jitter<=0.5\nvec2 cellular2x2(vec2 P, float jitter, out vec2 P1, out float ID1) {\n    jitter = clamp(jitter,-1.0,1.0); // Negative jitter makes perfect sense\n    vec2 P0 = floor(P);\n\tvec2 Pi = mod(P0, 289.0);\n\tvec2 Pf = P0-P; // Vector from P to closest unjittered grid point P0\n\tfloat px, pxy, d, d1, d2, ox, oy, dx, dy;\n\td1 = d2 = 8.0; // Init to distances larger than any actual outcome\n\tfor(float ix = 0.0; ix <=1.0; ix++) {\n\t\tpx = permute289(Pi.x + ix);\n\t\tfor(float iy = 0.0; iy <= 1.0; iy++) {\n\t\t\tpxy = permute289(px + Pi.y + iy);\n            float psi = pxy*0.07482; // Scale the hash (and jumble it some more)\n            // Generate a displacement vector of maximum length\n            ox = cos(psi); // sin and cos are usually fast these days\n            oy = sin(psi);\n            float sqc = jitter * 0.5 / max(abs(ox), abs(oy));\n            ox = ox * sqc; // \"Square the circle\"\n\t\t\toy = oy * sqc;\n\t\t\tdx = Pf.x + ix + ox; // points are at grid crossings\n\t\t\tdy = Pf.y + iy + oy; // instead of at cell centers\n\t\t\td = dx*dx + dy*dy; // Distance from P to Pn, squared\n            // d could replace either d1 or d2, handle both cases\n\t\t\td2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));\n\t\t\tP1 = (d <= d1 ? vec2(dx,dy) : P1);\n\t\t\tID1 = (d <= d1 ? pxy : ID1);\n\t\t\td1 = (d <= d1 ? d : d1);\n\t\t}\n\t}\n\treturn(sqrt(vec2(d1, d2)));\n}\n\n// Classic 3x3 search window for better results with jitter>0.5\nvec2 cellular3x3(vec2 P, float jitter, out vec2 P1, out float ID1) {\n    jitter = clamp(jitter,-1.0,1.0); // Negative jitter makes perfect sense\n    vec2 P0 = floor(P);\n\tvec2 Pi = mod(P0, 289.0);\n\tvec2 Pf = P0-P + 0.5; // Vector from P to closest unjittered grid point P0\n\tfloat px, pxy, d, d1, d2, ox, oy, dx, dy;\n\td1 = d2 = 8.0; // Init to distances larger than any actual outcome\n\tfor(float ix = -1.0; ix <=1.0; ix++) {\n\t\tpx = permute289(Pi.x + ix);\n\t\tfor(float iy = -1.0; iy <= 1.0; iy++) {\n\t\t\tpxy = permute289(px + Pi.y + iy);\n            float psi = pxy*0.07482; // Scale the hash (and jumble it some more)\n            // Generate a displacement vector of maximum length\n            ox = cos(psi); // sin and cos are usually fast these days\n            oy = sin(psi);\n            float sqc = jitter * 0.5 / max(abs(ox), abs(oy));\n            ox = ox * sqc; // \"Square the circle\"\n\t\t\toy = oy * sqc;\n\t\t\tdx = Pf.x + ix + ox;\n\t\t\tdy = Pf.y + iy + oy;\n\t\t\td = dx*dx + dy*dy; // Distance from P to Pn, squared\n            // d could replace either d1 or d2, handle both cases\n\t\t\td2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));\n\t\t\tP1 = (d <= d1 ? vec2(dx,dy) : P1);\n\t\t\tID1 = (d <= d1 ? pxy : ID1);\n\t\t\td1 = (d <= d1 ? d : d1);\n\t\t}\n\t}\n\treturn(sqrt(vec2(d1, d2)));\n}\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfKBDh","date":"1734008690","viewed":105,"name":"Craquelure","username":"stegu","description":"Basic paint craquelure pattern in two levels (primary and secondary cracks), making heavy use of cellular \"Worley\" noise. The anti-aliasing has some defects, but this is just a quick demo of the principle.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["worley","paint","cellular","cracks","craquelure","flaking"],"hasliked":0,"parentid":"","parentname":""}}