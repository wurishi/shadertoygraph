{"ver":"0.1","info":{"id":"wlj3zV","date":"1561539545","viewed":3498,"name":"Torus Pipes","username":"iq","description":"A sequence of connected torus sections (not a truchet or any other cell based acceleration structure). It's really a tested for the torus section SDF in [url]https://www.shadertoy.com/view/tl23RK[/url]","likes":78,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","torus","pipes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Inigo Quilez, 2019 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n#define AA 1\n\n// https://www.shadertoy.com/view/tl23RK\nfloat sdSqCappedTorus(in vec3 p, in vec2 sc, in float ra)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return dot(p,p) + ra*ra - 2.0*ra*k;\n}\n\nvec3 hash( float n )\n{\n    vec3 m = n*vec3(23.0,41.0,17.0) + vec3(9.0,1.0,31.0);\n    return fract( m*fract( m*0.3183099 ) );\n}\n\nvec2 map( in vec3 pos )\n{\n    vec3 pp = vec3(0.0);\n    vec3 ww = vec3(0.0,1.0,0.0);\n    \n    float d = length(pos-pp);\n    \n    vec4 data = vec4(0.0);\n                   \n    for( int i=0; i<32; i++ )\n    {\n        // segment parameters        \n        vec3 ran = hash(float(i));\n        float ra = 0.13 + 0.08*ran.x; // radius\n        float ap = 1.10 + 0.80*ran.y; // aperture\n        vec3  up = normalize( sin(75.0*ran.z+vec3(0.0,1.0,4.0))); // orientation\n\n        // world to torus transformation\n        vec2 sc = vec2(sin(ap),cos(ap));\n        vec3 ou = normalize(cross(ww,up));\n        vec3 vv = cross(ou,ww);\n        vec3 uu =  sc.x*ou + sc.y*ww;\n             ww = -sc.y*ou + sc.x*ww;\n        vec3 cpos = (pos-pp)*mat3(uu,ww,vv) + ra*vec3(-sc.x,sc.y,0.0);\n        \n        // distance evaluation        \n        float tmp = sdSqCappedTorus(cpos, sc, ra );\n        if( tmp<d )\n        {\n            d = tmp;\n            data = vec4( float(i), cpos.xy, ap );\n        }\n        \n        // prepare next segment        \n        pp += 2.0*ra*sc.x*uu;\n        ww = sc.y*uu - sc.x*ww;\n    }\n    \n    return vec2(sqrt(d) - 0.035, // distance\n                data.x + 0.5+0.5*(atan(data.y,data.z))/data.w // u\n               );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).x );\n}\n\n#define ZERO min(iFrame,0)\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=ZERO; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.2).x*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*2.5, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.15*(iTime-8.0);\n    vec3 ta = vec3( 0.25, -0.06, -0.75 );\n\tvec3 ro = ta + vec3( 1.7*cos(an), 0.6, 1.7*sin(an) );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n\n        // raymarch\n        const float tmax = 3.5;\n        float t = 0.5;\n        float m = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 h = map(pos);\n            m = h.y;\n            if( h.x<0.001 || t>tmax ) break;\n            t += h.x;\n        }\n    \n        // shade/light\n        vec3 col = vec3(0.1 - 0.015*length(p) + 0.05*rd.y );\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n\t\t\tfloat occ = calcAO(pos, nor);\n            float amb = 0.5 + 0.5*nor.y;\n            // material\n            vec3 mat = 0.5 + 0.5*cos( m*0.06 + vec3(0.00,1.0,1.8) + 1.0 );\n            mat += 0.05*nor;\n            // lighting\n            col = mat*1.5*occ*vec3(amb+fre*fre*col*0.4);\n            //col *= 4.0*smoothstep( 0.9, 1.0, sin(1.0*m+iTime*3.0) );\n            col *= 1.0-smoothstep( 0.98, 1.0, sin(1.0*m+iTime*3.0) );\n            col += fre*occ*0.5*vec3(0.5,0.7,1.0)*smoothstep(0.0,0.1,reflect(rd,nor).y);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}