{"ver":"0.1","info":{"id":"MfsyDn","date":"1721032068","viewed":24,"name":"hw3_London Board Engraving Text","username":"mike2367","description":"a resubmission of hw3, the usage of textures","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["texture","normalmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// code ref: https://www.shadertoy.com/view/7lBBR3\n#define iSampleCount\t\t\t5\n#define SampleCount\t\t\t\t(float(iSampleCount))\n#define HeightScale\t\t\t\t1.5\n#define ShadowHardness\t\t\t2.0\n#define ShadowLength\t\t\t0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3\tlightposition = vec3(0.0, 0.0, 0.3);\n\tvec3\tplaneposition = vec3(fragCoord.xy / iResolution.y, 0.0);\n\n\tvec2\tcursorposition = iMouse.xy / iResolution.y;\n\tlightposition.xy = cursorposition;\n\tif (iMouse.z <= 0.0)\n\t{\n\t\tlightposition.x = (sin(iTime * 1.5) + 0.5);\n\t\tlightposition.y = (cos(iTime * 1.5) + 1.0);\n\t}\n\n\tfloat\tsamplecount = SampleCount;\n\tfloat\tinvsamplecount = .0 / samplecount;\n\n\tfloat\thardness = HeightScale * ShadowHardness;\n\n\tvec3\tlightdir = lightposition - planeposition;\n\n\tvec2\tdir = lightdir.xy * HeightScale;\n\n\tlightdir = normalize(lightdir.xyz);\n\n\tvec2\tuv = fragCoord.xy / iResolution.xy;\n\tvec3\tnormal = texture(iChannel0, uv).xyz;\n\tnormal = normal * 2.0 - 1.0;\n\n\t//lighting with flat normals (from vertex or depth generated)\n\tfloat\tlighting = clamp(dot(lightdir, normal), 0.0, 1.0);\n\n\tfloat\tstep = invsamplecount * ShadowLength;\n\n\t//randomization\n\tvec2\tnoise = fract(fragCoord.xy * 0.5);\n\tnoise.x = (noise.x*0.5 + noise.y)*(1.0/1.5 - 0.25);\n\n\tfloat\tpos = step * noise.x;\n\n\t//do not compute on back faces/pixels //disabled cause while() not supported in Shadertoy\n\t//pos = (-lighting >= 0.0) ? 1.001 : pos;\n\n\tfloat\tslope = -lighting;\n\tfloat\tmaxslope = 0.0;\n\tfloat\tshadow = 0.0;\n\n\tvec3\ttmpNormal = texture(iChannel0, uv + dir * pos).xyz;\n\ttmpNormal = tmpNormal * 1.5-1.0;\n\n\tfloat\ttmpLighting = dot(lightdir, tmpNormal);\n\n\tfloat\tshadowed = -tmpLighting;\n\n\t\t//for g-buffer normals of deferred render insert here depth comparison to occlude objects, abstract code example:\n\t\t//vec2\tcropminmax = clamp(1.0 - (depth - tmpDepth) * vec2(4000.0, -600.0), 0.0, 1.0);\n\t\t//cropminmax.x = cropminmax.x * cropminmax.y;\n\t\t//shadowed *= cropminmax.x;\n\n\tslope += shadowed;\n\n\t\t//if (slope > 0.0) //cheap, but not correct, suitable for hard shadow with early exit\n\tif (slope > maxslope) //more suitable for calculating soft shadows by distance or/and angle\n\t{\n\t\tshadow += hardness * (1.0-pos);\n\t}\n\tmaxslope = max(maxslope, slope);\n\tpos += step;\n\t\n\n\tshadow = clamp(1.0 - shadow * invsamplecount, 0.0, 1.0);\n\n\t//disable shadow on click\n\t//if (iMouse.w > 0.0) shadow = 1.0;\n\n\t//coloring\n\tvec3\tambientcolor = vec3(0.15, 0.4, 0.6);\n\tvec3\tlightcolor = vec3(.9, 0.6, 0.6) * 1.2;\n\tfloat\tao = clamp(normal.z, 0.0, 1.0);\n\tfragColor.xyz = shadow * lighting * lightcolor;\n\tfragColor.xyz+= ambientcolor;\n\tfragColor.xyz*= (clamp(normal.z, 0.0, 1.0) * 0.5 + 0.5); \n\tfragColor.w = 1.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define invNormalMapScale 15.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv;\n\tvec2\toffset;\n\tvec3\tnormal;\n\tvec3\theight;\n\toffset = 10.0 / iResolution.xy;\n\tuv = fragCoord.xy / iResolution.xy;\n\theight.x = texture(iChannel0, uv).x;\n\theight.y = texture(iChannel0, uv + vec2(offset.x, 0.0)).x + texture(iChannel1, uv*.6 + vec2(offset.x, 0.0)).x;\n\theight.z = texture(iChannel0, uv + vec2(0.0, offset.y)).x+ texture(iChannel1, uv*.6 + vec2(offset.x, 0.0)).x;\n\tnormal.xy = (height.x - height.yz);\n\tnormal.xy /= offset;\n\tnormal.z = invNormalMapScale;\n\tnormal = normalize(normal);\n\tnormal = normal * 0.7 + 0.5;\n\tfragColor = vec4(normal, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}