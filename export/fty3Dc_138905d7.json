{"ver":"0.1","info":{"id":"fty3Dc","date":"1638779690","viewed":214,"name":"Fake Dehaze Test","username":"amagitakayosi","description":"Tried to implement old-cheap dehaze shader. \nI don't know if it's working correctly...¯\\_(ツ)_/¯\n\nBased on these references:\nhttp://www.jiansun.org/papers/Dehaze_CVPR2009.pdf\nhttps://github.com/chibai/DeHaze-darkchannel-and-guided-filter-","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["posteffect","dehaze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RADIUS 5\n\n\n// MOUSE X: ROTATE CAMERA\n// MOUSE Y: DEHAZE INTENSITY\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 src = texture(iChannel0, uv);\n    \n    // Get guided filter\n    float inputGray = dot(gray, src.rgb);\n    \n    vec2 guide;\n    float ws;\n    float s = 3.;\n    for (int y = -RADIUS; y <= RADIUS; y++) {\n        for (int x = -RADIUS; x <= RADIUS; x++) {\n            vec2 p = vec2(fragCoord.x + float(x) * s, fragCoord.y + float(y) * s) / iResolution.xy;\n            float w = gaussian(vec2(x, y));   \n            guide += texture(iChannel3, p).rg * w;\n            ws += w;\n        }\n    }    \n    guide.rg /= ws;\n    \n    float guided = guide.x * inputGray + guide.y;\n    \n    vec4 atmos = texture(iChannel2, uv);\n    float globalAtmos = max(atmos.r, max(atmos.g, atmos.b));\n        \n    vec4 outColor = (src - globalAtmos) / max(src, 0.1) + globalAtmos;         \n    outColor = clamp(outColor, 0., 1.);    \n    \n\n    float intensity = iMouse.y / iResolution.y;\n    if (intensity < .05) { intensity = 0.85; }\n    fragColor = mix(src, outColor, intensity);    \n    fragColor.rgb = sqrt(fragColor.rgb);        \n    \n    \n    // for debug:  show matte (fake depth)\n    // fragColor = vec4(guided);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RADIUS 8\n\nmat2 rot(float t) {\n  return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvec4 draw3D(vec2 uv) {\n  vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(p * 0.7, 1));    \n    \n    float m = iMouse.x / iResolution.x;\n    if (m < 0.03) {\n        rd.xz = rot(iTime * 0.2) * rd.xz;\n    } else {\n        rd.xz = rot(m * 3.142) * rd.xz;\n    }\n\n    return texture(iChannel1, rd);\n}\n\n\n// Just render the input to buf A\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Use texture\n    //fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    // Use Cubemap\n    fragColor = draw3D(uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define RADIUS 8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make a dark channel\n    // TODO: use multipass method\n    vec3 dark = vec3(1.);\n    for (int y = -RADIUS; y <= RADIUS; y++) {        \n        for (int x = -RADIUS; x <= RADIUS; x++) {\n            vec2 p = vec2(fragCoord.x + float(x), fragCoord.y + float(y)) / iResolution.xy;\n            vec3 col = texture(iChannel0, p).rgb;\n            dark.r =  min(dark.r, col.r);\n            dark.g =  min(dark.g, col.g);\n            dark.b =  min(dark.b, col.b);\n        }\n    }\n    float darkChannel = min(dark.r, min(dark.g, dark.b));\n\n    fragColor = vec4(dark, darkChannel);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define eps 1e-3\n#define blur 5.\n\nconst vec3 gray = vec3(0.21, 0.72, 0.07);\n\nconst float pi = 3.141593;\nconst float sigma = 3.;\nconst float sigma2 = 2. * sigma * sigma;\nconst float pisigma2 = pi * sigma2;\n\nfloat gaussian(vec2 i) {\n    float top = exp(-((i.x * i.x) + (i.y * i.y)) / sigma2);\n    float bot = pisigma2;\n    return top / bot;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define SIZE 8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Cheap atmospheric light estimation\n    // Using mipmap\n   float d1, d2;\n   vec3 a1, a2;\n   for (int y = 0; y < SIZE; y++) {\n     for (int x = 0; x < SIZE; x++) {\n       vec2 uv1 =vec2(x, y) / float(SIZE - 1);\n       float d = texture(iChannel1, uv1, 7.).a;\n       vec3 a = texture(iChannel0, uv1, 7.).rgb;\n       if (d > d1) {\n         d2 = d1;\n         d1 = d;\n         a2 = a1;         \n         a1 = a;\n       }\n       else if (d > d2) {\n         d2 = d;\n         a2 = a;\n       }\n     }\n   }\n   vec3 atmos = a2;\n   \n   \n   // OVERRIDE ATMOSPHER COLOR\n   atmos = vec3(.8);   \n   \n    // Compute Rough T\n    vec3 inputMin = texture(iChannel1, uv).rgb;\n    vec3 norm = inputMin / atmos;\n    float minC = min(min(norm.r, norm.g), norm.b);\n    float t = max(0., 1. - 0.95 * minC);\n   \n    fragColor = vec4(atmos, t);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define RADIUS 4\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n\n    // Apply Guided Filter    \n    float meanI, meanP, meanIP, meanII;\n    float ws; // weight sum\n    \n    for (int y = -RADIUS; y <= RADIUS; y++) {\n        for (int x = -RADIUS; x <= RADIUS; x++) {\n        \n            vec2 p = vec2(fragCoord.x + float(x), fragCoord.y + float(y)) / iResolution.xy;\n            float inputGray = dot(gray, texture(iChannel0, p).rgb);               \n            float roughT = texture(iChannel1, p).a;\n            \n            float w = gaussian(vec2(x, y));           \n            \n            meanI += dot(gray, texture(iChannel0, p).rgb) * w;\n            meanP += roughT * w;\n            meanIP += roughT *inputGray * w; \n            meanII += pow(inputGray, 2.) * w;\n            \n            ws += w;\n        }\n    }\n    \n    meanI /= ws;\n    meanP /= ws;\n    meanIP /= ws;\n    meanII /= ws;    \n        \n\tfloat covIP = meanIP - meanI * meanP;       \n    float varI = meanII - meanI * meanI;\n\n\tfloat a = covIP / (varI + eps); // blur\n\tfloat b = meanP - a * meanI; // blur\n\n    fragColor = vec4(a, b, a, 0);\n}","name":"Buffer D","description":"","type":"buffer"}]}