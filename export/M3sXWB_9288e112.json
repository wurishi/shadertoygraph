{"ver":"0.1","info":{"id":"M3sXWB","date":"1710018171","viewed":162,"name":"Falling tree leaves","username":"mrEscen","description":"My first shader on shadertoy :) ...needed some falling tree leaves\n\nbased on Butterfly Flock: https://www.shadertoy.com/view/llfXW8\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","tree","falling","leaves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nconst float mouseRotateSpeed = 5.0;\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nstruct sdObject\n{\n    vec3 pos;\n    float rad;\n    int index;\n};\n    \n#define OBJECTS 40\n    \nsdObject sdObjects[OBJECTS];    \n\n#define CACHED 5\nsdObject cachedObjects[CACHED];\n\nint maxCacheIndex = 0;\n    \n// distance functions from https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n \n\nconst float LEAVE_SIZE = 0.5;   \n\nfloat getModel(in vec3 pos, int index, inout vec3 rot)\n{\n    float phase = float(index);\n    float l = length(pos);\n    \n    //leave shape\n    float wx = max(abs(l * 7. + .2) - .4, 0.0);\n    float sl = 1.5* abs(cos(wx)) + 0.05;\n\n    vec3 leave = vec3(LEAVE_SIZE * 0.5,LEAVE_SIZE * 0.01, LEAVE_SIZE * 0.25 * sl);\n\n    rot = rotz(-sin(iTime * 0.1 * phase))*rotx(-sin(iTime * .5 + phase))*roty((iTime * 5.5 + phase)) * pos;\n    float w1 = sdBox(rot, leave);\n    \n    return w1;           \n}\n\n\nfloat map(in vec3 rp, in sdObject[CACHED] objects, inout vec3 localPos, inout int index, inout vec3 rot)\n{\n    float m = 9999.0;\n    float ret = m;\n    \n    for (int i = 0; i < CACHED; ++i)\n    {\n        if ( i <= maxCacheIndex)\n        {\n            vec3 lp = rp - objects[i].pos;\n            float mat = getModel(lp, objects[i].index,rot);     \n            float a = min(mat, m);\n\n            if (a < m)\n            {\n                m = a;\n                ret = mat;\n                localPos = lp;\n                index = objects[i].index;\n            }\n        }\n    }\n    return ret;\n}\n\nfloat prestep(in vec3 ro, in vec3 rp, in vec3 rd, in vec3 rd90degXAxis, in vec3 rd90degYAxis)\n{\n    maxCacheIndex = -1;\n    float m = 99999.0;\n    for (int i = 0; i < OBJECTS; ++i)\n    {\n        vec3 sp = -ro + sdObjects[i].pos;\n        \n        float distToPlaneY = abs(dot(rd90degYAxis, sp));\n    \tfloat distToPlaneX = abs(dot(rd90degXAxis, sp));\n        \n        float distanceToPlanes = max(distToPlaneY, distToPlaneX);\n        distanceToPlanes = distanceToPlanes - sdObjects[i].rad;\n        vec3 rot;\n        float l = getModel(rp - sdObjects[i].pos * (1.0 + distanceToPlanes), sdObjects[i].index,rot);\n        m = min(m, l);\n        \n        if(distanceToPlanes <= 0.0 && ++maxCacheIndex < CACHED)\n        {\n            if (maxCacheIndex == 0) cachedObjects[0] = sdObjects[i];\n            else if (maxCacheIndex == 1) cachedObjects[1] = sdObjects[i];\n            else if (maxCacheIndex == 2) cachedObjects[2] = sdObjects[i];\n            else if (maxCacheIndex == 3) cachedObjects[3] = sdObjects[i];\n            else if (maxCacheIndex == 4) cachedObjects[4] = sdObjects[i];\n            else return m;    \n        }\n    }\n    \n    return m;\n}\n\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 ro = rp;\n    float travel = 0.0;\n    const int STEPS = 20;\n\n    vec3 tmp = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(rd, tmp));\n    vec3 right = cross(rd, up);\n    \n    travel = prestep(ro, rp, rd, right, up);\n    //rp += travel * rd; \n    \n    vec3 local = vec3(0.0);\n    int hitindex = 0;\n\n    for (int i = 0; i < STEPS; ++i)\n    {\n       vec3 rot = vec3(0,0,0);\n       float dist = map(rp, cachedObjects, local, hitindex,rot);\n        \n       if(dist <= 0.0 )\n       {\n           //leaf pattern\n           float a = atan(rot.x,rot.z)-0.7;\n           float h = length(local)*0.7;\n           h *= 1.0-0.5*(1.0-h)*smoothstep(0.95+0.05*h,1.0,sin(2.*a))*1.0;\n           float c1 = abs(fract((-0.03 + (rot.x) + abs(rot.z)*1.0)*6.0) - 0.5) * 0.1;\n           color = vec4(0.33+h+c1,0.4+c1+h,0.24+c1,1.0)*0.7;\n           color.a = 1.0;\n           return;\n       }\n       float dst = max(0.01, dist);\n       travel += dst;\n       rp += rd * dst;\n       if(travel > 30.0) return;\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= vec2(0.5);\n    \n    if(mouse.xy == vec2(-0.5))\n    {\n        mouse = vec2(0.0);\n    }\n    \n    mouse *= mouseRotateSpeed;\n    float fallDuration = 4.0;\n\n    \n    for (int i = 0; i < OBJECTS; ++i)\n    {\n        float leafRand = hash11(float(i+10) * 68.76);\n        float fallTime = fract(iTime / fallDuration*(leafRand+0.2));\n        vec3 p = (texture(iChannel0, sin(  0.001) + 0.21 * vec2(float(i))) - vec4(0.5)).rgb;\n\n        float phase = float(i);\n        vec3 rot = rotz(-sin(iTime * 0.1 * phase))*rotx(-sin(iTime * .2 + phase))*roty((iTime * 1.5 + phase)) * p + vec3(LEAVE_SIZE * 0.5, LEAVE_SIZE * 0., 0.0);\n        p.xz += rot.zx*0.4;\n        p.y += min(0.01,-rot.y*0.07)-(fallTime - 0.5) ;\n\n        sdObjects[i] = sdObject(p * 20.0, LEAVE_SIZE * 1. , i);\n    }\n    \n    vec3 rp = vec3(0.0, .0, 1.0);\n    vec3 rd = normalize(vec3(uv, 0.3));\n    \n    rd *= rotx(mouse.y);\n    rd *= roty(mouse.x);\n    \n    trace(rp, rd, fragColor);\n    fragColor = mix(fragColor, texture(iChannel1, rd * roty(3.14159 * 0.5)), 1.0 - fragColor.a);\n    \n    \n}","name":"Image","description":"","type":"image"}]}