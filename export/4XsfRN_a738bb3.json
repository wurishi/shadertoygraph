{"ver":"0.1","info":{"id":"4XsfRN","date":"1730109302","viewed":43,"name":"Billard Torus","username":"Arbethi","description":"Square billard trajectory is equivalent to torus geodesic.\nUpper left : square billard trajectory\nLower left : unfolded boundaries of square billard\nRight : Torus geodesics","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["torus","billard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Billard Torus - Mathematical Coincidence\n// This work is licensed under CC BY-SA 4.0 \n//////////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = U/R.xy;\n    float ratio=R.x/R.y;\n    vec4 col;\n    \n    if (uv.y >0.5 && uv.x < 0.5/ratio)\n    {\n        vec2 uv2=uv;\n        uv2.y=(uv2.y-0.5)*2.;\n        uv2.x/=0.5/ratio;\n        \n        col += texture(iChannel0,uv2).rgba;\n        col += abs(sdBox(uv2));\n        \n    }\n    \n    if (uv.y <0.5 && uv.x < 0.5/ratio)\n    {\n        vec2 uv2=uv;\n        uv2.y*=2.;\n        uv2.x/=0.5/ratio;\n        \n        col+= texture(iChannel1,uv2).rgba;\n        col+=abs(sdBox(uv2));\n    }\n    \n    if (uv.x>0.5/ratio)\n    {\n        vec2 uv2=uv;\n        uv2.x-=0.5/ratio/2.;\n        col+= texture(iChannel2,uv2);\n    }\n    \n    \n    // Output to screen\n    Q = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Square billard trajectory\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec2 uv = U/R.xy;\n    float ratio=R.x/R.y;\n    vec2 mouse=M.xy/R.xy;\n    vec4 A=texture(iChannel0,uv);\n    vec4 D=texture(iChannel1,uv);\n    float a=atan2(iFrame >0 ? D.xy :  vec2(0.1,0.28));//angle mouse\n    float r=D.w;//reset\n    float t=iTime-D.z*CT;//time stored\n    float h=texture(iChannel2,uv).a; //highlight area\n    \n    if ( r==1.)\n    {\n        Q = vec4(0.);\n        return;\n    }\n    \n    vec2 p1=trajectory(P_START, a, speed*t-time_step);\n    vec2 p2=trajectory(P_START, a, speed*t+time_step);\n\n    float sdf_value =sdSegment(uv, p1, p2, R_seg);\n    sdf_value=sdf_value<0.?1.:0.;\n    \n    if (sdf_value>0.)\n    {\n        if (h==1.)\n            Q = A+col1;\n        else\n            Q = A+col2;\n    }\n    else\n        Q=A;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xyz\n#define M iMouse.xyz\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n//11 : 3pi/2, 33 : pi/2, 23 : pi/3, 21 : 2pi/3\n\nconst float TAU=2.*3.1415926;\nconst vec2 P_START=vec2(0.5,0.5);\n\nfloat R_seg=0.01;\nfloat speed=.3;\nfloat time_step=.005;\nfloat R0 = 15., R1 = 7.;                                 // large and small radii\nfloat bg=0.6;\nfloat CT=1000.;//compress time\n\nvec4 col1=vec4(1.,0.,0.,1.);//line trajectory color\nvec4 col2=vec4(0.,1.,1.,1.);//highlights area color\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdBox( in vec2 p)\n{\n    float r=0.495;\n    vec2 b=vec2(0.5);\n    vec2 d=abs(p-b);\n    return step(r,max(d.x,d.y));\n}\n\nfloat sin_triangle(float t)\n{\n    return (-cos(t*TAU)+1.)/2.;\n}\nfloat triangle(float t)\n{\n    return 2.*abs(t-floor(t+0.5));\n}\n\nfloat unfold_triangle(float t)\n{\n    return 2.*abs(t-floor(t));\n}\n\nvec2 trajectory(in vec2 p_start, in float a_start, float t)\n{\n    // square trajectory billard solution\n    // https://www.desmos.com/calculator/yrqgqml8hm\n    // https://www.youtube.com/watch?v=nJWtSOxqyLo&t=480s\n    return vec2(triangle(t*cos(a_start)+p_start.x+0.25), triangle(t*sin(a_start)+p_start.y+0.25));\n}\n\n\nvec2 flat_torus_trajectory(in vec2 p_start, in float a_start, float t)\n{\n    // square torus shape \n    // https://www.desmos.com/calculator/mce4n9pyxo\n    vec2 res = vec2(unfold_triangle(t*cos(a_start)+p_start.x+0.25), unfold_triangle(t*sin(a_start)+p_start.y+0.25));\n    return (2.-res).yx;\n    //return vec2(2.-res.y,2.-res.x);\n}\n\nvec2 direction(float angle)\n{\n    return vec2(cos(angle),sin(angle));\n}\n\nfloat atan2(vec2 p)\n{\n    // atan for full angle [-pi,pi] and normalize to [0,2*pi]\n    if (p==vec2(0.))\n        return 0.;\n    return 2.*atan(p.y/(length(p)+p.x))+TAU/2.;\n}\n\nfloat atan2(float px, float py)\n{\n    // overload\n    return atan2(vec2(px, py));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Unfolded Square trajectory\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec2 uv = U/R.xy;\n    float ratio=R.x/R.y;\n    vec2 mouse=M.xy/R.xy;\n    vec4 B=texture(iChannel0,uv);\n    vec4 D=texture(iChannel1,uv);\n    float a=atan2(D.xy);//angle mouse\n    float r=D.w;//reset\n    float t=iTime-D.z*CT;//time stored\n    \n    uv*=2.;\n    \n      \n    if ( r==1.|| iFrame==0)\n    {\n        B=vec4(0.);\n            if (uv.x<1.&&uv.y>1.) // bottom left area\n                Q = B+col2*0.7;\n            if (uv.x>1.&&uv.y<1.) // upper right area\n                Q = B+col2*0.7;\n        return;\n    }\n    \n    vec2 p0=flat_torus_trajectory(P_START*2., TAU/4.-a, speed*t-2.*time_step);\n    vec2 p1=flat_torus_trajectory(P_START*2., TAU/4.-a, speed*t-time_step);\n    vec2 p2=flat_torus_trajectory(P_START*2., TAU/4.-a, speed*t+time_step);\n    \n    // draw segment only if point is close\n    // otherwise it goes means it goes beyond cyclic boundaries\n    // and should not be drawn\n    if (distance(p1,p2)>0.1)\n    {\n        p2=p1+2.*(p1-p0);\n    }\n    else if (distance(p0,p1)>0.1)\n    {\n        p1=p1-2.*(p2-p1);\n    }\n    \n    float sdf_value =sdSegment(uv, p1, p2, R_seg);\n    sdf_value=sdf_value<0.?1.:0.;\n     \n    if (sdf_value>=0.)\n    {\n        if ((p1.x<1. && p1.y>1.) || (p1.x>1. && p1.y<1.))\n        {\n            Q = B+sdf_value*col2;\n            Q.a=0.;\n        }\n        else\n        {\n            Q = B+sdf_value*col1;\n            Q.a=1.;\n        }   \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Torus https://www.shadertoy.com/view/sdd3R4\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,d,  k = .025; // .9                              // tile multiplier\n\n    vec2 uv = U/R.xy;\n    float ratio=R.x/R.y;\n    vec3  D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 90./R, q,                                       // marching point along ray \n          nM = M.xyz/R -.5;\n     \n    for ( O=vec4(0) ; O.x < 1. && t > .2 ; O+=.025 )\n    {\n        q = p;\n        q.yz *= rot(TAU/2.-4.*nM.y);                              // rotations\n        q.xz *= rot(TAU/8.+6.*nM.x);\n        t = min(100., length(vec2(d=length(q.xz)-R0,q.y)) - R1);// abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj        \n        }\n    O = O.x > 1. ? vec4(0.) : exp(-3.*O/2.);                  // luminance (depth + pseudo-shading )\n    \n    // Compute angle in [0,1] and non negative value for uv mapping\n    float a = atan2(q.x,q.z)/TAU, b = atan2(q.y,d)/TAU;\n    //b=mod(b+0.*iTime/10.,1.);\n    //O+=vec4(0.25);\n    O=O.x*texture(iChannel0,vec2(a,b).xy)+(1.-O.x)*(col2)/3.;//+vec4(0.25);\n    //O+=0.1;\n    }","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 Q, in vec2 U )\n{\n    vec2 uv = U/R.xy;\n    float ratio=R.x/R.y;\n    vec2 mouse=M.xy/R.xy;\n    vec4 tex=texture(iChannel0,uv);\n    if (iFrame==0)\n    {\n        Q = vec4( vec2(0.1,0.28),0., 1.);\n                return;\n    }\n    // upper left corner condition\n    if (M.z>0. && mouse.y >0.5 && mouse.x < 0.5/ratio)\n        {\n            //rescale to upperleft in [0,1]²\n            mouse.x=mouse.x*ratio*2.-0.5;\n            mouse.y=(mouse.y-0.5)*2.-0.5;\n            \n            mouse=floor(mouse*60.)/60.;// give more closing/looping trajectory\n\n            // reset condition\n            if (atan2(tex.xy)!=atan2(mouse))\n            {\n                Q = vec4( mouse.x, mouse.y,iTime/CT, 1.);\n                return;\n            }\n        }\n    Q = vec4(tex.xyz,0.);//+vec4(0.1,0.,0.,0.);\n}","name":"Buffer D","description":"","type":"buffer"}]}