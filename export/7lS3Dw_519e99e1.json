{"ver":"0.1","info":{"id":"7lS3Dw","date":"1624104823","viewed":287,"name":"Warp 3d","username":"munrocket","description":"3d generalization of https://www.shadertoy.com/view/ttlGDf\nI found it pretty useful. Inspired by Sean Zelmer.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License. Â© 2021 munrocket\n\n#define MAX_STEPS 150.\n#define MAX_DIST 15.\n#define DIFF_EPS 0.001\n\nfloat map(vec3 p) {\n    float b = length(p) - 1.;\n    return b;\n}\n\n//3d generalization of https://www.shadertoy.com/view/ttlGDf\nvec3 warp3d(vec3 pos, float t) {\n    float curv =.35, a = 1.2, b = 0.2;\n    pos *= 3.;\n    for(float k = 1.0; k < 4.0; k += 1.0){ \n        pos.x += curv * sin(t + k * a * pos.y) + t * b;\n        pos.y += curv * cos(t + k * a * pos.x);\n        pos.y += curv * sin(t + k * a * pos.z) + t * b;\n        pos.z += curv * cos(t + k * a * pos.y);\n        pos.z += curv * sin(t + k * a * pos.x) + t * b;\n        pos.x += curv * cos(t + k * a * pos.z);\n    }\n    return 0.5 + 0.5 * cos(pos.xyz + vec3(1,2,4));\n}\n\nfloat march(vec3 camera, vec3 dir, out float outer, out vec3 pos) {\n    float dt, t = 0.;\n    vec3 col;\n    for(float i = 0.; i < MAX_STEPS; i++) {\n        pos = camera + t * dir;\n        dt = map(pos);\n        t += dt;\n        if(dt < DIFF_EPS || t > MAX_DIST) break;\n    }\n    outer = step(MAX_DIST, t);\n    return outer;\n}\n\nvec3 normal(vec3 pos) {\n    const vec2 e = vec2(DIFF_EPS, 0.);\n    return normalize(vec3(  \tmap(pos + e.xyy) - map(pos - e.xyy),\n              \t\t\t\t  \tmap(pos + e.yxy) - map(pos - e.yxy),\n              \t\t\t\t\tmap(pos + e.yyx) - map(pos - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 camera = vec3(0., 0., 2.5);\n    \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.1);\n    dir = rotate(dir, mouse);\n    camera = rotate(camera, mouse);\n    \n    vec3 pos;\n    float outer, glow = .2 * march(camera, dir, outer, pos);\n    glow = .001 * pow(10. / (abs(length(uv*1.57)-1.) + .5), 2.);\n    float glow2 = 0.2 * (1. - pow(dot(normal(pos), -dir), 1.5));\n    vec3 col = warp3d(pos, iTime/2.0);\n    fragColor = vec4(sqrt(mix(col+vec3(glow2), vec3(glow), outer)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI   3.1415926\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * iTime, 0.2);\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - 2.*M_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI/2.);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}","name":"Common","description":"","type":"common"}]}