{"ver":"0.1","info":{"id":"lfyyRV","date":"1732094007","viewed":21,"name":"Rotating Slices of Bread Alpha","username":"vitasa","description":"Rotating slices of bread with an alpha. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["slice","rotation","alpha","bread"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy code to render multiple rotating bread slices moving from right to left at random speeds with varying transparency and even distribution\n\n// Hash function to generate pseudo-random numbers\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 2D hash function\nfloat hash(vec2 p) {\n    return fract(sin(dot(p ,vec2(127.1,311.7))) * 43758.5453123);\n}\n\n// 2D rotation function\nmat2 rotate2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Signed distance function for an ellipse (oval)\nfloat sdEllipse(vec2 p, vec2 r) {\n    vec2 k = abs(p) / r;\n    return (length(k) - 1.0) * min(r.x, r.y);\n}\n\n// Signed distance function for a square (box)\nfloat sdSquare(vec2 p, vec2 size) {\n    vec2 d = abs(p) - size / 2.0;\n    return max(d.x, d.y);\n}\n\n// Adjustable bread color parameter\nvec3 breadColor = vec3(0.95, 0.82, 0.63); // Color of the bread slices\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    // Adjust for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Number of slices\n    const int numSlices = 16; // Use a perfect square for simplicity (e.g., 4x4 grid)\n\n    // Background color\n    vec3 backgroundColor = vec3(0.25, 0.12, 0.13);\n\n    // Initialize accumulated color and alpha\n    vec3 accumColor = vec3(0.0);\n    float accumAlpha = 0.0;\n\n    // Grid dimensions\n    int gridSize = int(sqrt(float(numSlices)));\n    float cellSize = 2.0 / float(gridSize); // Since uv ranges from -1 to 1\n\n    // Loop over slices\n    for (int i = 0; i < numSlices; i++) {\n        // Compute grid coordinates\n        int xIndex = i % gridSize;\n        int yIndex = i / gridSize;\n\n        // Compute base position of the cell\n        float cellX = -1.0 + (float(xIndex) + 0.5) * cellSize;\n        float cellY = -1.0 + (float(yIndex) + 0.5) * cellSize;\n\n        // Generate a small random offset within the cell\n        vec2 cellPosition = vec2(cellX, cellY);\n        vec2 jitter = vec2(\n            (hash(vec2(i, 0.0)) - 0.5) * cellSize * 0.5,\n            (hash(vec2(i, 1.0)) - 0.5) * cellSize * 0.5\n        );\n        vec2 position = cellPosition + jitter;\n\n        // Random speed (from 0.1 to 0.3)\n        float speed = 0.1 + 0.2 * hash(float(i) * 99.123);\n\n        // Adjust position over time to move slices from right to left\n        float newX = position.x - speed * iTime;\n\n        // Wrap the x-coordinate when it goes off-screen\n        float aspect = iResolution.x / iResolution.y;\n        float bound = 1.0 + cellSize; // Bound depends on the cell size\n        newX = mod(newX + bound, 2.0 * bound) - bound;\n\n        // Apply aspect ratio adjustment\n        newX *= aspect;\n\n        // Random size\n        float sizeFactor = 0.3 + 0.2 * hash(float(i) * 93.433);\n        vec2 squareSize = vec2(sizeFactor, sizeFactor);\n        vec2 ovalRadii = vec2(sizeFactor * 0.6, sizeFactor * 0.3);\n\n        // Random initial rotation angle\n        float initialAngle = hash(float(i) * 45.352) * 6.2831; // 0 to 2*pi\n\n        // Random rotation speed (from -0.5 to 0.5 radians per second)\n        float rotationSpeed = -0.5 + hash(float(i) * 1238.456) * 1.0;\n\n        // Compute total rotation angle\n        float angle = initialAngle + rotationSpeed * iTime;\n\n        // Random transparency for each slice (e.g., between 0.3 and 0.7)\n        float sliceTransparency = 0.3 + 0.4 * hash(float(i) * 555.555);\n\n        // Use the adjusted position\n        vec2 p = uv - vec2(newX, position.y);\n\n        // Apply rotation\n        p = rotate2D(angle) * p;\n\n        // Square parameters (body of the bread)\n        vec2 squareCenter = vec2(0.0, -ovalRadii.y);\n        float dSquare = sdSquare(p - squareCenter, squareSize);\n\n        // Oval parameters (top of the bread)\n        vec2 ovalCenter = vec2(0.0, squareSize.y / 2.0 - ovalRadii.y);\n        float dOval = sdEllipse(p - ovalCenter, ovalRadii);\n\n        // Combine the square and oval using union operation\n        float dSlice = min(dSquare, dOval);\n\n        // Smooth edges for anti-aliasing\n        float thickness = 0.002;\n        float alpha = smoothstep(0.0, thickness, -dSlice);\n\n        // Compute final alpha for this slice\n        float sliceAlpha = alpha * sliceTransparency;\n\n        // Bread color\n        vec3 sliceColor = breadColor;\n\n        // Alpha compositing (over operator)\n        accumColor += sliceColor * sliceAlpha * (1.0 - accumAlpha);\n        accumAlpha += sliceAlpha * (1.0 - accumAlpha);\n    }\n\n    // Blend with background color\n    vec3 finalColor = accumColor + backgroundColor * (1.0 - accumAlpha);\n\n    // Output final color (alpha can be set to accumAlpha if transparency is needed)\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}