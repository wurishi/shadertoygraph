{"ver":"0.1","info":{"id":"sd2cDd","date":"1644359371","viewed":128,"name":"Noisy Waves","username":"mAmaro","description":"Practicing using simple noise and making waves and Fractional Brownian Motion","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noisemaskingwavetrancendentalfractgrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author:\n// Title:\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI32 3.1415926535897932384626433832\n\n// NOT USED BY SHADERTOY\n//uniform vec2 u_resolution;\n//uniform vec2 u_mouse;\n//uniform float u_time;\n\nmat2 Rotate(float Theta)\n{\n    return mat2(cos(Theta), -sin(Theta),\n                sin(Theta), cos(Theta));\n}\n\nfloat MapTo(float MapRange, float y)\n{\n    return (MapRange+y)*MapRange*0.5;\n}\n\nfloat Wave(float y, float Width, float MapRange, float Pos, vec2 st)\n{   \n   float Mapping = MapTo(MapRange, y);\n    \n    return smoothstep(Width, 0.0, abs(st.y - (Pos+Mapping)));\n}\n\nfloat curve(vec2 st)\n{\n    float u_time = iTime;\n    st -= 6.5;\n    float t = u_time * 0.1;\n    float xinput = st.x + t;\n    float thecrv = sin(xinput) + cos(st.x + t * 20.0);\n    float bdst = thecrv;\n\n    float bdsb = sin(xinput + PI32) + cos(st.x + t * 20.0 + PI32);\n    float aa = 0.5;\n\n    float a = smoothstep(bdst, bdst + aa, st.y);\n    a*= smoothstep(bdsb, bdsb + aa, 1.0 - st.y);\n    \n    return a;\n}\n\nfloat rect(vec2 st, vec2 pos, vec2 size)\n{\n    st -= pos - 0.5;\n    size = size - size * 0.5;\n    float aa = 0.00001;\n    vec2 bdsw = vec2(size);\n    vec2 bdsh = vec2(size);\n\n    vec2 a = smoothstep(bdsw, bdsw, st);\n    a*= smoothstep(bdsh, bdsh + aa, 1.0 - st);\n    \n    return a.x * a.y;\n}\n\nfloat rnd(vec2 v)\n{\n\treturn fract(sin(dot(v, vec2(12.0,70.0))) * 435093.38484);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rnd(i);\n    float b = rnd(i + vec2(1.0, 0.0));\n    float c = rnd(i + vec2(0.0, 1.0));\n    float d = rnd(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat Repeat(float Wave, float At, int Itr, float StepDist)\n{\n        \n    float Result = 0.0;\n    \n    for(int i=0; i<Itr; i++)\n    {\n        At += StepDist;\n        Result += Wave;\n    }\n    \n    return Result;\n}\n\n\nfloat FBM(float WaveY,\n          float Amp, float Freq,\n          float Lacunarity, float Gain,\n          vec2 uv)\n{\n    const int Octaves = 200;\n    float Result = 0.0;\n    \n    for (int i = 0; i < Octaves; i++)\n    {\n        WaveY += Amp * noise(Freq*uv);\n        Freq *= Lacunarity;\n        Amp *= Gain;\n    }\n    \n    Result = WaveY;\n    \n    return Result;\n}\n\nfloat UlatSin(float arg)\n{\n    return .5+.5*sin(arg);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u_time = iTime;\n    vec3  u_resolution = iResolution;\n    vec4  u_mouse = iMouse;\n\n    vec2 uv = fragCoord.xy / u_resolution.xy;\n    uv-=0.5;\n    vec3 Color = vec3(.05,.0,.09);\n    \n    vec2 st = uv;\n    float ap = u_resolution.x / u_resolution.y;\n    vec2 normtouch = u_mouse.xy/u_resolution.xy;\n    vec2 touchsize = vec2(0.5);\n    float maskcrv = curve(st);\n    float maskcrv1 = curve(uv);\n    st.x *= ap;\n    st *= 1.0;\n    vec2 ip = floor(st);\n    vec2 fp = fract(st);\n    vec2 uv1 = uv * 2.0;    \n    \n    vec2 ip1 = floor(uv1);\n\n    \n    //WAVES\n    float t = 0.01*(-u_time*120.0);\n    float Amp  = 2.0; //NOTE(): this is kind of like specular thing\n    float Freq = 20.0*UlatSin(t*uv.x); //NOTE(): The number coresponds to the number of shadows/speclualar area there are\n    float YShift = 2.0; //With polar coord radius gets bigger\n    \n    float w0 = 1.0;\n    //To Polar Coordinates\n    uv = vec2(atan(uv.x, uv.y), length(uv));\n    w0 = (sin(uv.y*Freq+t) * Amp) + YShift;\n    \n    \n    float FBMAmp  = 1000.0;\n    float FBMFreq = 0.1;\n    float wave   = FBM(w0, 1.0*UlatSin(t), FBMAmp, FBMFreq,1.0, uv);      \n    float Result = Wave(wave, 6.0, 1.999, -1.0, uv);\n    \n    \n    Color += vec3(Result);\n\n\tfragColor = vec4(Color , 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Lacunarity - Measure of how patterns(usually fractals) fill space.\n                 High lacunarity == bigger gaps\n                 Low  lucunarity == smaller gaps\n    Modulation - Process of varying one or more properties of a periodic waveform\n    \n    Perlin Noise - Sine with Fairly constant amplitude with narrow varience in frequecy\n                   around center frequency.\n    Octave - iterations of noise.\n*/","name":"Common","description":"","type":"common"}]}