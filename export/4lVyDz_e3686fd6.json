{"ver":"0.1","info":{"id":"4lVyDz","date":"1536192396","viewed":97,"name":"Assignment1 - CSC550","username":"richardMartin","description":"First assignment\n5 shapes, 2 need to be animated, 1 needs to be controlled by mouse ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shapes","school"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//c1 is coordinate 1, c2 is coordinate 2, p is pixel\nfloat rectangle(in vec2 c1, in vec2 c2, in vec2 p)\n{\n\tvec2 v1 = c2 - c1;\n    vec2 v2 = p - c1;\n    \n    return dot(v1, v2);\n}\n\n// a is point a, b is point b, c is point c, p is pixel\nbool triangle(in vec2 a, in vec2 b, in vec2 c, in vec2 p)\n{\n    //math thanks to\n    //http://blackpawn.com/texts/pointinpoly/\n    \n    // define edges of triangle\n\tvec2 vac = c - a;\n    vec2 vab = b - a;\n    vec2 vap = p - a;\n    \n    // define dotproducts we need\n    float dotVac = dot(vac, vac);\n    float dotVacab = dot(vac, vab);\n    float dotVacap = dot(vac, vap);\n    float dotVab = dot(vab, vab);\n    float dotVabap = dot(vab, vap);\n    \n    // compute missing variables u and v\n    float u = ((dotVab * dotVacap) - (dotVacab * dotVabap)) / \n        ((dotVac * dotVab) - (dotVacab * dotVacab));\n    \n    float v = ((dotVac * dotVabap) - (dotVacab * dotVacap)) / \n        ((dotVac * dotVab) - (dotVacab * dotVacab));\n    \n    // if u and v are greater than 0 but combined less than 1\n    // point is inside triangle\n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t\n    p*=2.0;\n    \n    // rectangle\n    // the pixel(P) will be in the square iff \n    // 0 < dot(ap, ab) < 1\n    // and\n    // 0 < dot(ap, ac) < 1\n    vec3 col = vec3(0.0);\n    vec2 a = cos(vec2 (0,0));// point a\n    vec2 b = cos(vec2 (0,1.5));// point b\n    vec2 c = cos(vec2 (1,0));// point c\n    \n    float r1 = rectangle(a, b, p);\n    float r2 = rectangle(a, c, p);\n    // checkered pattern from class thanks to Dr Landon\n    // my modifications in comments\n    vec3 checkCol = vec3(0.0);\n    \n    // checkersize scales with resolution\n    float checkerSize = float(0.025*iResolution);\n    \n    if(int(fragCoord.x/checkerSize) % 2 == 0)\n    {\n        if(int(fragCoord.y/checkerSize) % 2 == 0)\n        \tcheckCol = vec3(1.0);\n    }\n    else\n    \tif(int(fragCoord.y/checkerSize) % 2 == 1)\n       \tcheckCol = vec3(1.0);\n        \n    // if the pixel is inside the rectangle\n    // checkers come and go inside the rectangle\n    if( (r1 > 0.0 && r1 < 1.0) && (r2 > 0.0 && r2 < 1.0) ) \n       col = checkCol * cos(5.0*iTime+p.xxx);    \n        \n    // circle\n    float distFromCircle = distance(p,vec2(-2.0+(iMouse.x/iResolution.x), -1.5+(iMouse.y/iResolution.y)));\n    float radius = 0.5;\n    \n    if(distFromCircle < radius)\n        col = vec3(1.0,0,0);\n    \n    // rectangle2\n    a = cos(iTime + vec2 (2,2));// point a\n    b = cos(iTime + vec2 (0,1));// point b\n    c = cos(iTime + vec2 (3,0));// point c\n    \n    float r3 = rectangle(a, b, p);\n    float r4 = rectangle(a, c, p);\n    \n    if( (r3 > 0.0 && r3 < 1.0) && (r4 > 0.0 && r4 < 1.0) ) \n       col = vec3(0,1.0,0);\n    \n    // triangle \n    a = sin(vec2 (1,1)+3.0);// point a\n    b = sin(vec2 (0,1)+3.0);// point b\n    c = sin(vec2 (1,3)+3.0);// point c\n    bool Triangle = triangle(a,b,c,p);\n    \n    if(Triangle)\n        col = vec3(0,0,1.0);\n    // triangle \n    a = cos(vec2 (1,1)+1.0);// point a\n    b = cos(vec2 (0,-4)+3.0);// point b\n    c = cos(vec2 (2,0)+4.0);// point c\n    Triangle = triangle(a,b,c,p);\n    \n    if(Triangle)\n        col = vec3(0,1.0,1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}