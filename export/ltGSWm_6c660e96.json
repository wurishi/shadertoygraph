{"ver":"0.1","info":{"id":"ltGSWm","date":"1484577836","viewed":91,"name":"Rusty_Baller","username":"Jabberwock","description":"finally","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 blue=vec3(1.0,0.30,0.0);\nconst vec3 green =vec3(0.5,0.5,0.5);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)/*+floor(p.y)+floor(p.z)*/,2.0);\n    return mix(blue,green,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{ // Utiliser ces couleurs pour le métal rouillé.\n    //const vec3 blue=vec3(1.52,0.87,0.23);\n\t//const vec3 green=vec3(0.5,0.5,0.5);\n    \n    \n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    //t/=(0.6);//1.0+0.25+0.125+0.025\n    // Modifier 0.8 pour changer la fréquence des taches. réduire 0.8 augmente la fréquence\n    if(t>0.0 && t<= 0.5){\n        return 0.6*0.46;\n    }else{\n        return t*0.75;\n    }\n    return t;\n     \n   \n}\n\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(blue,green,t);\n}\n\n// Marble\n// p : Point\n// n : Normal\nvec3 marble(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence (10.0*p,n);\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    \n   \n    if(t <= 0.8 && t> 0.5){\n    \t return blue*0.8*t; \n    }\n    if(t<=0.5){\n       return blue*0.45;   \n    } \n    \n    \n    return mix(blue,green,t);\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    \n    vec3 o = vec3(0.0, 0.0, -2.0);\n    float t=turbulence (10.0*p,n);\n    // Point light\n    vec3 lightPos = rotate(o,0.5*iTime);\n    const vec3 lightColor = vec3(1.0, 1.0,1.0);\n    \n    const vec3 SpecC = vec3(0.35, 0.35, 0.35);\n  \n    vec3 l = normalize(lightPos - p);\n    vec3 reflet = reflect(-l,n);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = dot(n, l);\n    float specAngle;\n    float specular;\n    \n    if(diff <0.0){\n       diff = 0.0;\n    }else{\n       specAngle = max(dot(reflet, l), 0.0);\n       specular = pow(specAngle, 1.5);\n    }\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.1*background(n)+0.7*marble(p,n);//*diff*lightColor;\n\n    if(t > 0.6){\n    \tc+= SpecC*specular;    \n    }\n        \n    \n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}","name":"Image","description":"","type":"image"}]}