{"ver":"0.1","info":{"id":"lXc3RM","date":"1716231398","viewed":50,"name":"Seamless Tileable Dirt Patches","username":"iekdosha","description":"Tileable dirt patches ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tile","dirt","seamless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I took the repeatable noise from here: https://www.shadertoy.com/view/4tyyWh\n\n\nconst vec2 OFFSET = vec2(11, 21);\nconst int MODE = 1; \t\t//0: FBM, 1: RIDGED, 2: VORONOI\nconst int OCTAVES = 5;\nconst float SCALE = 5.0;\nconst int TILING = 3;\n\n//----------------------------------------------------\n//------NOISE-----------------------------------------\n//----------------------------------------------------\n\nint p[] = int[](151,160,137,91,90,15,\n 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n               \n 151,160,137,91,90,15,\n 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180);\n\nfloat currentTiling = SCALE;\n\nfloat hash(vec2 uv)\n{\n    uv = mod(uv, currentTiling);\n    uv += OFFSET + floor(iMouse.xy * .1);\n    \n    int ix = int(uv.x);\n    int iy = int(uv.y);\n    \n    ix &= 255;\n    iy &= 255;\n    \n    return float(p[ix + p[iy]]) / 255.0;\n}\n\nvec2 hash2(vec2 uv)\n{\n    uv = mod(uv, currentTiling);\n    uv += OFFSET + floor(iMouse.xy * .1);\n    \n    int ix = int(uv.x);\n    int iy = int(uv.y);\n    \n    ix &= 255;\n    iy &= 255;\n    \n\treturn vec2(p[ix + p[iy]], p[iy + p[ix]]) / 255.;\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1., 0.));\n    float c = hash(i + vec2(0., 1.));\n    float d = hash(i + vec2(1., 1.));\n    \n    float m1 = mix(a, b, f.x);\n    float m2 = mix(c, d, f.x);\n    return mix(m1, m2, f.y);\n}\n\nfloat fbm(vec2 p, int oct)\n{\n\tfloat amp = 1.;\n    float freq = 1.;\n    float sum = amp;\n    \n    float res = 0.;\n    for(int i=0; i<oct; i++){\n    \tres += noise(p * freq) * amp;\n        amp *= .5;\n        freq *= 2.;\n        currentTiling *= 2.;\n        sum += amp;\n    }\n    \n    return res / sum;\n}\n\nfloat ridged(vec2 p, int oct)\n{\n\tfloat amp = 1.;\n    float freq = 1.;\n    float sum = amp;\n    \n    float res = 0.;\n    for(int i=0; i<oct; i++){\n    \tres += abs(noise(p * freq) * 2.-1.) * amp;\n        amp *= .5;\n        freq *= 2.;\n        currentTiling *= 2.;\n        sum += amp;\n    }\n    \n    return pow(1.-(res / sum), 3.);\n}\n\nfloat voronoi(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    \n    float minDist = 8.0;\n    for(int j=-2; j<=2; j++)\n    {\n    \tfor(int i=-2; i<=2; i++)\n        {\n            vec2 id = vec2(float(i), float(j));\n            vec2 cellPoint = hash2(id + ip);\n            vec2 realPoint = id + cellPoint - fp;\n            \n            float d = dot(realPoint, realPoint);\n            minDist = min(minDist, d);\n            \n        }\n    }\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------\n\n/*\n    Creid for noise functions: by @XorDev\n    https://mini.gmshaders.com/p/gm-shaders-mini-noise-1437243\n    \n    Based on this youtube tutorial:\n    https://www.youtube.com/watch?v=f4s1h2YETNY\n    \n    This is my first shader ever so this code is pretty bad.\n\n*/\n#define fmod(x,y) mod(floor(x),y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= ((iResolution.x - iResolution.y) * .5) / iResolution.y;\n    if(uv.x > 1. || uv.x < 0.){\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    float timeStep = floor(iTime*0.3333);\n    \n    vec3 finalColor = vec3(0.38,0.3,0.15);\n    float noise = ridged(5.0*uv + timeStep, OCTAVES);\n    currentTiling = SCALE;\n    float noise2 = ridged(5.0*uv + 1.7 * timeStep, OCTAVES);\n    currentTiling = SCALE;\n    float noise3 = ridged(5.0*uv + 1.85 * timeStep, OCTAVES);\n    currentTiling = SCALE;\n    float general_noise = fbm(5.0*uv, OCTAVES);\n\n   \n    if (noise <0.12 ) {\n        finalColor += -vec3(0.06,0.03,0.03) + 0.1*noise - 0.02*general_noise;\n    }\n    else if (noise2 <0.25 ) {\n        finalColor += -vec3(0.02,0.03,0.02)  + 0.1*noise2 - 0.02*general_noise;\n    }\n    else if (noise3 <0.05 ) {\n        finalColor += -vec3(0.03,0.04,0.035)  + 0.1*noise3 - 0.02*general_noise;\n    }\n    finalColor += general_noise *0.04;\n\n    \n    fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}