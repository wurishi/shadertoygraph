{"ver":"0.1","info":{"id":"tsXyW4","date":"1584966538","viewed":99,"name":"Dark Toy Box","username":"takumifukasawa","description":"Dark Toy Box","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["csg","box","raymaching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS .0001\n#define NORMAL_EPS .0001\n#define PI 3.14159265359\n#define PI2 PI * 2.\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n\n#define MAT_BOX_1 1.\n#define MAT_BOX_2 2.\n#define MAT_BOX_3 3.\n#define MAT_BOX_4 4.\n#define MAT_BOX_5 5.\n#define MAT_PRISM 6.\n\n#define saturate(a) clamp(a, 0., 1.)\n#define repeat(a, b) mod(a, b) - b * .5 \n// #define repeat(a, b) mod(a + b * .5, b) - b * .5 \n\nconst float stopThreshold = .0001;\n\nprecision highp float;\n\nstruct Light {\n\tvec3 position;\n  \tfloat intensity;\n  \tvec3 color;\n  \tvec3 diffuse;\n  \tvec3 specular;\n  \tfloat attenuation;\n};\n    \nstruct Surface {\n  \tfloat depth;\n  \t// float dist;\n  \tvec3 position;\n  \tvec3 baseColor;\n    vec3 specularColor;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n  \tfloat material;\n};  \n\n//---------------------------------------------------------------------------------------------\n// utils\n//---------------------------------------------------------------------------------------------\n\n// ref: https://www.shadertoy.com/view/ldlcRf\nvec2 minMat(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nbool checkMat(float material, float check) {\n\treturn material < (check + .5);\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat2 rot2(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nmat3 rot3(float roll, float pitch, float yaw) {\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n    return mat3(\n    \tcp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n        cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n        -sp, sr * cp, cr * cp\n    );\n}\n\nfloat distanceToLine(vec3 origin, vec3 dir, vec3 point) {\n\tvec3 pointToOrigin = point - origin;\n    float pointToOriginLength = length(pointToOrigin);\n    vec3 pointToOriginNorm = normalize(pointToOrigin);\n    float theta = dot(dir, pointToOriginNorm);\n    return pointToOriginLength * sqrt(1. - theta * theta);\n}\n\nvec3 hash3(vec3 p) {\n\tvec3 q = vec3(\n        dot(p, vec3(127.1, 311.7, 114.5)),\n        dot(p, vec3(269.5, 183.3, 191.9)),\n        dot(p, vec3(419.2, 371.9, 514.1))\n    );\n    return fract(sin(q) * 43758.5433);\n}\n\nvec3 rgbColor(float r, float g, float b) {\n\treturn vec3(r / 255., g / 255., b / 255.);\n}\n\n//---------------------------------------------------------------------------------------------\n// sdf\n//---------------------------------------------------------------------------------------------\n\nfloat sdSphere(in vec3 pos, float rad) {\n\treturn length(pos) - rad;\n}\n\n// ra: radius\n// rb: round\n// h: height\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2. * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rb;\n}\n\n// a: begin pos\n// b: begin thin\n// ra: end pos\n// rb: end thin\nfloat sdStick(in vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tvec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float r = mix(ra, rb, h);\n\treturn length(pa - h * ba) - r;\n}\n\nfloat sdElipsoid(in vec3 pos, vec3 rad) {\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.) / k1;\n}\n\nfloat sdCylinder(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// d1 subtract to d2\nfloat opSub(float d1, float d2) {\n\treturn max(-d1, d2);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdWireBox(vec3 p, float s, float b) {\n    float d = 0.;\n    float o = s + .01;\n    float i = s - b;\n    d = opSub(\n        sdBox(p, vec3(o, i, i)),\n        sdBox(p, vec3(s))\n    );\n    d = opSub(\n        sdBox(p, vec3(i, o, i)),\n\t\td\n    );\n    d = opSub(\n        sdBox(p, vec3(i, i, o)),\n\t\td\n    );\n    return d;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat smin(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn min(a, b) - h * h / (k * 4.);\n}\n\nfloat smax(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn max(a, b) + h * h / (k * 4.);\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = atan(p.x, p.y) + PI / r;\n    float n = PI * 2. / r;\n    a = floor(a / n) * n;\n    return p * rot(-a);\n}\n\n//---------------------------------------------------------------------------------------------\n// raymarch\n//---------------------------------------------------------------------------------------------\n\nvec2 scene(vec3 p) {\n    float d = FLT_MAX;\n    float m = 0.;\n\n\tp.z += -iTime * 2.4;\n    \n\n        \n    // top\n    {        \n        vec3 _p = p;\n        float repeatNum = 2.1;\n        vec3 id = floor((_p + repeatNum * .5) / repeatNum);\n        vec3 rnd = hash3(id);\n        // _p.xz = repeat(_p.xz, repeatNum);\n        _p.xz = mod(_p.xz + repeatNum * .5, repeatNum) - repeatNum * .5;\n        //vec3 offset = vec3(0., sin(iTime + rnd.x + rnd.y) * .25, 0.) * 0.;\n\t\tvec3 offset = vec3(0., 3. + sin(iTime * 2.5 + rnd.x * 10.) * .1, 0.);\n\t\t\n        d = min(d, sdRoundBox(_p - offset, vec3(.8), .1));\n\n        if(rnd.x < .2) {\n\t        m = MAT_BOX_1;    \n        } else if(rnd.x < .4) {\n            m = MAT_BOX_2;    \n        } else if(rnd.x < .6) {\n            m = MAT_BOX_3;    \n        } else if(rnd.x < .8) {\n            m = MAT_BOX_4;    \n        } else {\n            m = MAT_BOX_5;    \n        }\n    }\n    \n\n    \n    // floor\n    {        \n        vec3 _p = p;\n        float repeatNum = 2.1;\n        vec3 id = floor((_p + repeatNum * .5) / repeatNum);\n        vec3 rnd = hash3(id);\n        // _p.xz = repeat(_p.xz, repeatNum);\n        _p.xz = mod(_p.xz + repeatNum * .5, repeatNum) - repeatNum * .5;\n        //vec3 offset = vec3(0., sin(iTime + rnd.x + rnd.y) * .25, 0.) * 0.;\n\t\tvec3 offset = vec3(0., sin(iTime * 2.5 + rnd.x * 10.) * .1, 0.);\n\t\t\n        d = min(d, sdRoundBox(_p - offset, vec3(.8), .1));\n\n        if(rnd.x < .2) {\n\t        m = MAT_BOX_1;    \n        } else if(rnd.x < .4) {\n            m = MAT_BOX_2;    \n        } else if(rnd.x < .6) {\n            m = MAT_BOX_3;    \n        } else if(rnd.x < .8) {\n            m = MAT_BOX_4;    \n        } else {\n            m = MAT_BOX_5;    \n        }\n    }\n    \n    // space\n    {\n        vec3 _p = p;\n        float repeatNum = 2.1;\n        vec3 id = floor((_p + repeatNum * .5) / repeatNum);\n        vec3 rnd = hash3(id);\n        // _p.xz = repeat(_p.xz, repeatNum);\n        _p.xz = mod(_p.xz + repeatNum * .5, repeatNum) - repeatNum * .5;               \n        d = opSub(sdRoundBox(_p, vec3(.3, 10., .3), .1), d);\n    }\n    \n    // octahedron\n    {\n        vec3 _p = p;\n        float repeatNum = 2.1;\n        vec3 id = floor((_p +repeatNum * .5) / repeatNum);\n        vec3 rnd = hash3(id);\n        // _p.xz = repeat(_p.xz, repeatNum);        \n        _p.xz = mod(_p.xz + repeatNum * .5, repeatNum) - repeatNum * .5;        \n\t\t_p.xz = rot2(iTime + rnd.x * 10.) * _p.xz;\n        _p = _p - vec3(0., 1.5 + sin(iTime * 2.5 + rnd.x * 20.) * .1, 0.);\n        _p.y *= .5;\n        //_p.xy = rot2(iTime) * _p.xy;\n        //_p.xy = pmod(_p.xy, 1. + floor(rnd.x * 11.));\n        //_p.y -= .05 + sin(iTime * 4.) * .1;\n        //_p.yz = rot2(iTime * 2.) * _p.yz;\n        //_p.xy = pmod(_p.xy, 1. + floor(rnd.x * 5.));\n        float objD = sdOctahedron(_p, .15);\n        m = minMat(vec2(d, m), vec2(objD, MAT_PRISM)).y;\n        d = min(objD, d);\n    }\n    \n    return vec2(d, m);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n\n    \n    // raymarching\n    float depth = 0.;\n    float dist = 0.;\n    vec2 result = vec2(0.);\n    for(int i = 0; i < 64; i++) {\n    \tresult = scene(ro + rd * depth);\n        dist = result.x;\n        if(dist < stopThreshold) {\n            break;\n        }\n        depth += result.x;\n    }    \n    \n    float tmax = 40.;\n    if(depth > tmax) result.y = -1.;\n    \n\treturn vec2(depth, result.y);\n}\n\n//---------------------------------------------------------------------------------------------\n// lightings\n//---------------------------------------------------------------------------------------------\n\nconst int maxShadowIterations = 32;\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float power) {\n  float res = 1.;\n  float t = mint;\n  float ph = 1e10;\n  for(int i = 0; i < maxShadowIterations; i++) {\n    float h = scene(ro + rd * t).x;\n\n    // pattern 1\n    // res = min(res, power * h / t);\n\n    // pattern 2\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, power * d / max(0., t - y));\n    ph = h;\n\n    t += h;\n\n    float e = EPS;\n    if(res < e || t > tmax) break;\n  }\n  return clamp(res, 0., 1.);\n}\n \n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  \tvec3 lightDir = light.position - position;\n  \tvec3 ref = reflect(-normalize(lightDir), normal);\n  \tfloat specular = 0.;\n  \tif(diffuse > 0.) {\n    \tspecular = max(0., dot(ref, normalize(cameraPos - normal)));\n    \tfloat specularPower = 64.;\n    \tspecular = pow(specular, specularPower);\n  \t}\n  \treturn specular;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));\n  \tvec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;\n  \t// specular\n  \tfloat specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  \n\n  \tlight.diffuse = diffuse/* * softShadow(surface.position, normalize(light.position), .1, 3., 5.)*/;\n    light.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \tfloat d = distance(light.position, surface.position);\n  \tvec3 k = vec3(.06, .08, .09);\n  \tlight.attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n\n  \t// point light\n  \tvec3 lightDir = light.position - surface.position;\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(lightDir)));\n  \tvec3 diffuse = diffuseCoef * light.color * light.intensity * light.attenuation;\n  \t// specular\n  \tfloat specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity); \n    \n  \tlight.diffuse = diffuse/* * softShadow(surface.position, normalize(light.position), .1, 3., 5.)*/;\n  \tlight.specular = specular;\n}\n\nfloat ambientOcculusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++) {\n    \tfloat h = .01 + .11 * float(i) / 4.;\n        vec3 opos = pos + h * nor;\n        float d = scene(opos).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2. * occ, 0., 1.);\n}\n\nvec3 fog(vec3 color, float dist, vec3 fogColor, float b) {\n  float fogAmount = 1. - exp(-dist * b);\n  return mix(color, fogColor, fogAmount);\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos) {\n  \tvec3 position = surface.position;\n\n  \tvec3 color = vec3(0.);\n  \tvec3 normal = surface.normal;\n\n  \tLight directionalLight;\n  \tdirectionalLight.position = vec3(0., .1, 1.);\n  \tdirectionalLight.intensity = .01;\n  \tdirectionalLight.color = vec3(1., 1., 1.);\n  \tdirectionalLight.attenuation = 1.;\n  \tcalcDirectionalLight(directionalLight, surface, cameraPos);\n    \n  \tLight pointLight;\n  \tpointLight.position = vec3(0., 0., 0.);\n  \tpointLight.intensity = .7;\n  \tpointLight.color = vec3(.4, .8, .5);\n  \t//pointLight.attenuation = 1.;\n  \tcalcPointLight(pointLight, surface, cameraPos);\n    \n  \tvec3 diffuse = directionalLight.diffuse + pointLight.diffuse;\n  \tvec3 specular = directionalLight.specular + pointLight.specular;\n    \n\tfloat occ = ambientOcculusion(surface.position, surface.normal);\n  \tfloat amb = clamp(.5 + .5 * surface.normal.y, 0., 1.);\n  \tvec3 ambient = surface.baseColor * amb * occ * vec3(0., .08, .1);        \n  \n  \tcolor =\n        surface.emissiveColor +\n        surface.baseColor * diffuse +\n        surface.specularColor * specular +\n        ambient;  \n  \n  \treturn color;\n}\n\n//---------------------------------------------------------------------------------------------\n// main\n//---------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n\tvec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(mouse * .5 + vec2(1.05, 1.5) + vec2(sin(iTime * .8), cos(iTime * 1.2)) * .15, 3.);\n    vec3 target = vec3(1.05, 1.5, 0.) + vec3(sin(iTime * .3), cos(iTime * .8), 0.) * .15;\n    float fov = .9;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n\tvec2 result = raymarch(ro, rd);\n\tvec3 color = vec3(0.);\n    \n    if(result.y > 0.) {\n\t    float depth = result.x;\n    \tfloat material = result.y;    \n   \n    \tvec3 position = ro + rd * depth;\n    \tvec3 normal = getNormal(position);\n        \n\t    Surface surface;\n    \tsurface.depth = depth;\n    \t// surface.dist = dist;\n    \tsurface.position = position;\n    \tsurface.normal = normal;\n    \tsurface.material = result.y;\n    \n    \tvec3 objColor = vec3(0.);\n\n        // pallete is:\n\t\t// https://www.color-hex.com/color-palette/88982\n        if(checkMat(material, MAT_BOX_1)) {\n            surface.baseColor = rgbColor(201., 72., 24.);\n        } else if(checkMat(material, MAT_BOX_2)) {\n            surface.baseColor = rgbColor(10., 48., 77.);\n        } else if(checkMat(material, MAT_BOX_3)) {\n            surface.baseColor = rgbColor(132., 163., 158.);\n        } else if(checkMat(material, MAT_BOX_4)) {\n            surface.baseColor = rgbColor(255., 193., 16.);\n        } else if(checkMat(material, MAT_BOX_5)) {\n            surface.baseColor = rgbColor(169., 101., 41.);\n        } else if(checkMat(material, MAT_PRISM)) {\n            surface.baseColor = rgbColor(140., 120., 40.);\n        }\n        surface.specularColor = vec3(1.);\n        \n        // surface.emissiveColor = surface.baseColor;\n        \n        color = lighting(surface, ro);\n    }\n\n    // fog\n    color = fog(color, result.x, vec3(.02, .02, .04), .12);\n    \n    // gamma\n    color = pow(color, vec3(.4545));\n    \n    fragColor = vec4(color, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}