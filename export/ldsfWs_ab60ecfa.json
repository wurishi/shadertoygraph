{"ver":"0.1","info":{"id":"ldsfWs","date":"1498937607","viewed":128,"name":"JCVD Kisrhombille","username":"ttoinou","description":"see https://www.shadertoy.com/view/4dsfWs\nusing fermat spiral to blur JCVD","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["triangle","tiling","kisrhombille","reptile","equerre"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#define PRECISION 0.2\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return clamp(pow(\n        abs(col)\n        , vec3(.6,.5,.4)\n      ),0.0,1.0\n    );\n    /*ivec2 ip = ivec2(\n        round(p.x / PRECISION) ,\n        round(p.y / PRECISION)\n    );\n    \n    return hash32(vec2(ip));*/\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( length(uv - colPoint)* scale )))\n    );\n}\n\n\nvoid mixColorLine(vec2 uv,inout vec3 col,vec2 lineA,vec2 lineB,float scale)\n{\n    col = mix(\n        col , \n        hash3point(lineA+lineB) ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv,vec2 base)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify + base/4.0;\n}\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    int nbIterations = 8;\n    \n\tint EquerreVersion = 1;\n    vec2 base = vec2(sqrt(3.0),1.0);\n    base *= 50000.0;\n    \n    \n    viewportMagnify = base.x / 4.0;\n\tvec2 uv = screenToViewport(fragCoord.xy,base);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy * 3.0;\n    int Colorization = int(floor(mouse.x));\n    \n    // Base Triangle\n    vec2 A = vec2(0.0);\n    vec2 B = A + vec2(base.x,0.0);\n    vec2 C = A + vec2(0.0,base.y);\n    \n    vec2 D,E,F;\n    #define SWAP(X,Y) F = X; X = Y; Y = F;\n    \n    #ifdef REPEAT_TILING\n   \t\t// Upper Triangle\n        if( !pointsOnSameSideOfLine(uv,\n                         A,B,C) )\n        {\n            A += vec2(base.x,base.y);\n            SWAP(B,C)\n        }\n    #endif\n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        D = (2.0 * A + B)/3.0;\n        E = (B + C)/2.0;\n        \n        if( pointsOnSameSideOfLine(uv,\n                                A,D,C) )\n        {\n            B = D;\n            SWAP(B,C)\n           \n        }\n        else if( pointsOnSameSideOfLine(uv,\n                                B,D,E) )\n        {\n            A = E;\n            C = D;\n        }\n        else \n        {\n            A = E;\n            B = C;\n            C = D;\n            fragColor.rgb = 1.0 - fragColor.rgb;\n        }\n                                   \n    }\n    \n    vec2 Center = viewportToScreen((A+B+C)/3.0,base)/iResolution.xy;\n    \n    // to validate function viewportToScreen\n    //vec2 Center = viewportToScreen(screenToViewport(fragCoord.xy,base),base)/iResolution.xy;\n    \n    vec3 video = texture(iChannel0,Center).rgb;\n    video = step(video,vec3(0.25));\n    video.g = 1.0 - video.g;\n    \n    //video = vec3(step(video.g-video.b/2.0,0.25));\n    //fragColor.rgb = video;\n    \n    fragColor.rgb *= video;\n    fragColor.rgb = 1.0 - fragColor.rgb;\n    \n    /*if( video.r > 0.2 )\n    {\n        fragColor.rgb = 1.0 - fragColor.rgb;\n    }*/\n    \n    float scale = float(nbIterations);\n    scale = pow(2.0,scale)/viewportMagnify/scale;\n    \n    #if SHOW_SEGMENTS==1\n        mixColorLine(uv,fragColor.rgb,A,B,scale);\n        mixColorLine(uv,fragColor.rgb,B,C,scale);\n        mixColorLine(uv,fragColor.rgb,C,A,scale);\n    #endif\n   \n    #if SHOW_POINTS==1\n        mixColorPoint(uv,fragColor.rgb,A,scale);\n        mixColorPoint(uv,fragColor.rgb,B,scale);\n        mixColorPoint(uv,fragColor.rgb,C,scale);\n    #endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"       \n#define DX          (iMouse.x/iResolution.x)\n#define DY          (iMouse.y/iResolution.y)\n#define DZ          (iMouse.z > 0.5)\n\n#define PI          (3.14159265359)\n#define BLENDCOEFF  (DZ ? (DY*6. - 3.) : -1.3) // (8.*DX-4.) // negative => cartoon effect\n#define RADIUS   \t(16) // if you tweak this u have to tweak two next values :(  \n#define NUMPOINTS   (51)\n#define GAMMA       (2.2)\n#define SPACESMOOTH (2./1.41)\n//#define INTENSITYSMOOTH (0.06) // the bigger the glower\n#define SPIRALANGLE ((3. - sqrt(5.))*PI)\n#define LUMWEIGHT   (vec3(0.2126,0.7152,0.0722))\n\n#define DIAMETER \t(2*RADIUS+1)\n#define UNMIX(t,a,b) ( clamp( (t-a)/(b-a) , 0. , 1.) )\n#define pow3(x,y)      (pow( max(x,0.) , vec3(y) ))\n\nvec3 spiral(int i){\n    vec2 R = vec2(\n        sqrt(float(i)/float(NUMPOINTS-1)) * 1.,\n        SPIRALANGLE* float(i)*-1.1\n    );\n    return vec3(R.x*cos(R.y),R.x*sin(R.y),R.x);\n}\n\nvec2 viewport(vec2 p)\n{   \n    return p/(iResolution.xy);\n}\n\nvec3 sampleImage(vec2 coord){\n    return pow3(texture(iChannel0,viewport(coord)).rgb,GAMMA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = viewport(fragCoord.xy);\n    vec2 uv_ = uv*vec2(1.,iResolution.y/iResolution.x);\n    vec3 pixelColor = sampleImage(fragCoord);\n    fragColor = vec4(0.);\n    float sum = 0.;\n    float coeff;\n    vec3 diff;\n    vec3 pos;\n    vec3 color = vec3(0.);\n    float nbPoints = float( NUMPOINTS  );\n    //float IntensitySmooth2 = INTENSITYSMOOTH*INTENSITYSMOOTH;\n    float SpaceSmooth2 = float(RADIUS*RADIUS)*SPACESMOOTH*SPACESMOOTH;\n    \n  \n    for( int i = 0; i < NUMPOINTS ; i++ ){\n        pos = spiral(i)*float(RADIUS);\n        \n        color = sampleImage(fragCoord.xy+pos.xy);\n\n        diff = color - pixelColor;\n        coeff = exp( -(\n            //dot(diff*diff,LUMWEIGHT)/IntensitySmooth2 + \n            (pos.z*pos.z)/SpaceSmooth2 ) );\n\n        if( i == 0 ){\n            fragColor.rgb = color*coeff;\n        } else {\n            fragColor.rgb += color*coeff;\n        }\n\n        sum += coeff;\n    }\n        \n\tfragColor = fragColor/sum;\n    \n}","name":"Buf A","description":"","type":"buffer"}]}