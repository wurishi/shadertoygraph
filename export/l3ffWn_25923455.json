{"ver":"0.1","info":{"id":"l3ffWn","date":"1728250273","viewed":60,"name":"Orbs by @kishimisu","username":"bardia323","description":"A shadertoy implementation","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["orbs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Smooth minimum function\nfloat smoothMin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Time variable\n    float time = iTime;\n\n    // Camera setup\n    vec3 cameraPosition = vec3(0.0, 0.0, -5.0);\n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n\n    // Initialize color accumulator\n    vec4 color = vec4(0.0);\n\n    // Initialize distance along the ray\n    float t = 0.0;\n\n    // Maximum distance to march\n    float maxDistance = 50.0;\n\n    // Number of steps\n    int maxSteps = 100;\n\n    // Epsilon for ray marching\n    float epsilon = 0.001;\n\n    // Ray marching loop\n    for(int i = 0; i < maxSteps; i++)\n    {\n        // Compute the current position along the ray\n        vec3 position = rayOrigin + t * rayDirection;\n\n        // Offset the z-coordinate by time\n        position.z += time;\n\n        // Initialize minimum distance to a large value\n        float minDistance = 1000.0;\n\n        // Color accumulation for this step\n        vec4 stepColor = vec4(0.0);\n\n        // Loop over layers along the z-axis to compute distances to orbs\n        for(float j = -2.0; j <= 2.0; j++)\n        {\n            // Copy the current position to modify for this layer\n            vec3 q = position;\n\n            // Adjust the z-coordinate to create repeating layers\n            q.z = fract(q.z) - 0.5 - j;\n\n            // Compute an index based on the z-position\n            float k = floor(position.z) + j;\n\n            // Rotate the x and y coordinates to create a spiral effect\n            float angle = k * 0.75;\n            mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n            q.xy = rotation * q.xy;\n\n            // Add a sine wave to the x-coordinate for animation\n            q.x += sin((k - time) * 0.5);\n\n            // Calculate the distance to a small sphere (orb) at this position\n            float distanceToOrb = length(q) - 0.07;\n\n            // Keep track of the minimum distance to any object\n            minDistance = min(minDistance, distanceToOrb);\n\n            // Accumulate the color contribution from this orb\n            vec4 orbColor = 8e-4 * (2.0 + cos(position.z / 4.0 + time + vec4(0, 1, 2, 0))) / distanceToOrb;\n            stepColor += orbColor;\n        }\n\n        // Compute a distance to a wavy plane for additional scene detail\n        float wave = sin(position.x) * cos(position.y) * cos(position.y + position.z);\n        float distanceToPlane = 1.0 + wave - length(position.xy);\n\n        // Smoothly blend the minimum distance with the plane's distance\n        minDistance = smoothMin(minDistance, distanceToPlane, 0.1);\n\n        // Accumulate the color\n        color += stepColor;\n\n        // Advance along the ray by the minimum distance found\n        t += minDistance;\n\n        // Break if the distance is small enough (hit something)\n        if(minDistance < epsilon || t > maxDistance) break;\n    }\n\n    // Tone mapping and gamma correction\n    color = pow(color, vec4(0.4545)); // gamma correction (1/2.2)\n\n    // Output the final color\n    fragColor = color;\n}\n\n\n","name":"Image","description":"","type":"image"}]}