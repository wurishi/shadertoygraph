{"ver":"0.1","info":{"id":"l3SSzR","date":"1710199922","viewed":85,"name":"interactive 2D hex worley noise","username":"IlyaBelyy","description":"An interactive exploration how does choice of offsets affect worley noise.\n\nUse mouse to set gradients.\nSee keyboard commands in the comments","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["2d","noise","worley"],"hasliked":0,"parentid":"MXXXWX","parentname":"interactive 2D worley noise"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nUse mouse to adjust offset vectros\n\nKeyboard:\n    r - reset all gradients to random\n    i - display value isolines\n    g - display grid\n    v - display offsets\n    c - colour\n    1..9, 0 - scale offset by 10-100%\n\nIf the offset is limited this could be used to produce an irregular hex grid\n\nAllowing offsets to get to any point in the hexes, however requires\nto check hexes further away and does not look any better than using squares\n\nSquare grid version https://www.shadertoy.com/view/MXXXWX\n*/\n\nvec2 load_offset(ivec2 p, float scale)\n{\n    vec2 v = texelFetch(iChannel0, p, 0).xy;\n    return scale * v;\n}\n\nvec3 worley_hex(vec2 p, float scale)\n{\n    vec3 nearest = vec3(1e3);\n\n    ivec2 c = pix2hex(p);\n    ivec2 ofs;\n    for (ofs.y = -1; ofs.y <= 1; ofs.y++) {\n        for (ofs.x = -1; ofs.x <= 1; ofs.x++) {\n            if (ofs.x == ofs.y && ofs.x != 0) continue;\n\n            vec2 o = load_offset(c + ofs, scale);\n            vec2 h = hex2pix(vec2(c + ofs));\n            float dist = length(h + o - p);\n            if (dist < nearest.x) nearest = vec3(dist, h);\n        }\n    }\n\n    nearest.x /= scale + 1.0;\n    //nearest.x *= 0.5;\n    return nearest;\n}\n\nfloat line(vec2 from, vec2 dir, vec2 p)\n{\n    if (dot(p - from, dir) < 0.0) return 0.0;\n\n    if (length(p - from) > length(dir)) return 0.0;\n\n    vec2 tangent = normalize(vec2(-dir.y, dir.x));\n    return smoothstep(2.0 * fwidth(p.x), 0.0, abs(dot(p - from, tangent)));\n}\n\nvec3 id2colour(ivec2 id)\n{\n    return hash(uvec3(id.xy + 123, id.x + id.y + 200));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdHexagon(vec2 p, float r)\n{\n    p = abs(p.yx);      // flat-top to point-top\n    r *= sqrt(3.) / 2.; // inner radius to outer radius\n\n    const vec3 k = vec3(-sqrt(3.0)/2.0,0.5,sqrt(3.0)/3.0);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = screen_to_pos(fragCoord, iResolution);\n    float scale = texelFetch(iChannel0, ivec2(0), 0).x;\n\n    vec3 n = worley_hex(p, scale);\n\n    // colour\n    if (texelFetch(iChannel1, ivec2(67,2), 0).x == 0.0) {\n        fragColor.rgb = vec3(1.0 - n.x) * id2colour(ivec2(n.yz));\n    } else {\n        fragColor.rgb = vec3(1.0 - n.x);\n    }\n\n    // isolines\n    if (texelFetch(iChannel1, ivec2(73,2), 0).x != 0.0) {\n        fragColor.rgb += vec3(smoothstep(fwidth(n.x), 0.0, abs(n.x)));\n        fragColor.b += smoothstep(fwidth(n.x), 0.0, abs(n.x - 0.25));        \n        fragColor.g += smoothstep(fwidth(n.x), 0.0, abs(n.x - 0.5));\n        fragColor.r += smoothstep(fwidth(n.x), 0.0, abs(n.x - 0.75));\n    }\n\n    ivec2 hex = pix2hex(p);\n    vec2 centre = hex2pix(vec2(hex));\n\n    // grid\n    if (texelFetch(iChannel1, ivec2(71,2), 0).x != 0.0) {\n        float sdf = -sdHexagon(p - centre, 1.0);\n        float w = smoothstep(sdf, 0.0, 2.5 * fwidth(fragCoord.x / iResolution.x));\n        fragColor.rgb += 1.0 - w;\n    }\n\n    // offset vector\n    if (texelFetch(iChannel1, ivec2(86,2), 0).x != 0.0) {\n        vec2 o = load_offset(hex, scale);\n        fragColor.rgb *= 1.0 - line(centre, o, p);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 screen_to_pos(vec2 p, vec3 resolution)\n{\n    return 8.4 * p / resolution.y + vec2(10.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n    const uint k = 1103515245U;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// https://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html#kenneth-shaw\nivec2 pix2hex(vec2 p)\n{\n    float x = p.x / sqrt(3.);\n    float y = p.y + 1.;\n    float t2 = floor(x + y);\n    int r = int(floor((floor(y - x) + t2) / 3.));\n    int q = int(floor((floor(2. * x + 1.) + t2) / 3.)) - r;\n    return ivec2(q, r);\n}\n\nvec2 hex2pix(vec2 h)\n{\n    return vec2(\n        sqrt(3.) * h.x + sqrt(3.) * 0.5 * h.y,\n        1.5 * h.y\n    );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ofs = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n\n    if (ivec2(fragCoord) == ivec2(0)) {\n        if (iFrame == 0 || texelFetch(iChannel1, ivec2(48,1), 0).x > 0.0) ofs.x = 1.0;\n        for (int i = 0; i < 10; i++) {\n            if (texelFetch(iChannel1, ivec2(49 + i,1), 0).x > 0.0) {\n                ofs.x = float(i + 1) / 10.0;\n                break;\n            }\n        }\n        fragColor = vec4(ofs.x);\n        return;\n    }\n\n    // set random offsets on start or if 'r' is pressed\n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(82,1), 0).x > 0.) {\n        //vec3 r = 2.0 * hash(uvec3(fragCoord, iFrame)) - 1.0;\n        vec3 r = hash(uvec3(fragCoord, iFrame));\n        vec2 v1, v2;\n        if (r.z < 0.33) {\n            v1 = vec2(-1.0, 0.5);\n            v2 = vec2(0.0, 0.5 * sqrt(3.0));\n        } else if (r.z < 0.67) {\n            v1 = vec2(0.5, 0.5);\n            v2 = vec2(0.5 * sqrt(3.0), -0.5 * sqrt(3.0));\n        } else {\n            v1 = vec2(0.5, -1.0);\n            v2 = vec2(-0.5 * sqrt(3.0), 0.0);\n        }\n        ofs.x = dot(v1, r.xy);\n        ofs.y = dot(v2, r.xy);\n    } else {\n        if (iMouse.z > 0.0) {\n            // set the closest value\n            vec2 mouse = screen_to_pos(iMouse.xy, iResolution);\n            ivec2 hex = pix2hex(mouse);\n            if (hex == ivec2(fragCoord)) {\n                ofs = mouse - hex2pix(vec2(hex));\n            }\n        }\n    }\n\n    fragColor = vec4(ofs, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}