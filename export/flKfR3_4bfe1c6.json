{"ver":"0.1","info":{"id":"flKfR3","date":"1664936066","viewed":243,"name":"Single Pass CFD 16-bit Velocity","username":"myth0genesis","description":"This version uses two 16-bit velocity values packed into the alpha channel so velocity no longer depends on color to carry from one frame to the next. This allows any color to travel in any direction.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["fluid","flow","dynamics","bit","16","pass","cfd","16bit","single","half"],"hasliked":0,"parentid":"MsGSRd","parentname":"spilled"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on \"spilled\" by florian berger (flockaroo) https://www.shadertoy.com/view/MsGSRd\n// Click and drag to inject color\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Based on \"spilled\" by florian berger (flockaroo) https://www.shadertoy.com/view/MsGSRd\n// Click and drag to inject color\n\n// RotNum has to be an odd integer\n#define RotNum 5\n\nconst float rotFloat = float(RotNum);\nconst float iRotFloat = 1.0 / rotFloat;\nconst float imf = 1.0 / float(0xFFFFFFFFU);\nconst float pi = uintBitsToFloat(0x40490FDBU);\nconst float twopi = 2.0 * pi;\nconst float ang = twopi / float(RotNum);\nconst float thirdprd = twopi / 3.0;\nconst float twothrdprd = 2.0 * thirdprd;\nmat2 m = mat2( cos(ang), sin(ang),\n              -sin(ang), cos(ang));\n\n// Lehman's branchless method for packing and unpacking floats \n// (about 40 cycles round trip according to author's benchmarks)\n// https://www.researchgate.net/publication/362275548_Accuracy_and_performance_of_the_lattice_Boltzmann_method_with_64-bit_32-bit_and_customized_16-bit_number_formats\nfloat packHalves(vec2 x) {\n    uvec2 b = floatBitsToUint(x) + 0x00001000U;\n    uvec2 e = (b & 0x7F800000U) >> 23;\n    uvec2 m = b & 0x007FFFFFU;\n    uvec2 r = (b & 0x80000000U) >> 16 |\n        uvec2(greaterThan(e, uvec2(0x00000070U))) * ((((e - 0x00000070U) << 10) & 0x00007C00U) | m >> 13) |\n        (uvec2(lessThan(e, uvec2(0x00000071U))) & uvec2(greaterThan(e, uvec2(0x00000065U)))) *\n            ((((0x007FF000U + m) >> (0x0000007DU - e)) + 0x00000001U) >> 1) |\n        uvec2(greaterThan(e, uvec2(0x0000008FU))) * 0x00007FFFU;\n    return uintBitsToFloat((r.x << 16) | (r.y & 0x0000FFFFU));\n}\n\nvec2 unpackHalves(float f) {\n    uint u = floatBitsToUint(f);\n    uvec2 x = uvec2(u >> 16, u & 0x0000FFFFU);\n    uvec2 e = (x & 0x00007C00U) >> 10;\n    uvec2 m = (x & 0x000003FFU) << 13;\n    uvec2 v = floatBitsToUint(vec2(m)) >> 23;\n    uvec2 r = (x & 0x00008000U) << 16 |\n        uvec2(notEqual(e, uvec2(0x00000000U))) * ((e + 0x00000070U) << 23 | m) |\n        (uvec2(equal(e, uvec2(0x00000000U))) & uvec2(notEqual(m, uvec2(0x00000000U)))) *\n        ((v - 0x00000025U) << 23 | ((m << (0x00000096U - v)) & 0x007FE000U));\n    return uintBitsToFloat(r);\n}\n\n// Chris Wellons' and TheIronBorn's best 32-bit two-round integer hash\n// https://github.com/skeeto/hash-prospector\nfloat hash32(int x) {\n    uint p = uint(x);\n    p ^= p >> 16;\n    p *= 0x21F0AAADU;\n    p ^= p >> 15;\n    p *= 0xD35A2D97U;\n    p ^= p >> 15;\n    \n    // normalize float and shift range to -0.5, 0.5 to cover whole period with ang\n    return float(p) * imf - 0.5;\n}\n\nfloat circleSDF(vec2 p, vec2 c, float r) {\n    return length(p + c) - r;\n}\n\nfloat getRot(vec2 invRes, vec2 pos, vec2 b, float idb) {\n    vec2 p = b;\n    float rot = 0.0;\n    for(int i = 0; i < RotNum; i++) {\n        vec2 v1 = unpackHalves(texture(iChannel0, fract((pos + p) * invRes)).w);\n        rot += dot(v1 - 0.5, vec2(p.y, -p.x));\n        p = m * p;\n    }\n    return rot * iRotFloat * idb;\n}\n\n// software bilinear filtering\n// also interpolating velocity between pixels\nvec4 biSW(sampler2D tex, vec2 pos, vec2 iuv) {\n    vec2 uv0 = iResolution.xy;\n\tvec2 p = pos * uv0 - 0.5;\n    vec2 f = fract(p);\n    \n    vec2 tlc = floor(p);\n    \n    vec4 tl = texture(tex, (tlc + vec2(0.5, 0.5)) * iuv);\n    vec4 tr = texture(tex, (tlc + vec2(1.5, 0.5)) * iuv);\n    vec4 bl = texture(tex, (tlc + vec2(0.5, 1.5)) * iuv);\n    vec4 br = texture(tex, (tlc + vec2(1.5, 1.5)) * iuv);\n    \n    vec2 tlw = unpackHalves(tl.w);\n    vec2 trw = unpackHalves(tr.w);\n    vec2 blw = unpackHalves(bl.w);\n    vec2 brw = unpackHalves(br.w);\n    \n    vec2 retw = mix(mix(tlw, trw, f.x), mix(blw, brw, f.x), f.y);\n    \n    return vec4(mix(mix(tl.xyz, tr.xyz, f.x), mix(bl.xyz, br.xyz, f.x), f.y), packHalves(retw));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 invRes = 1.0 / iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) * invRes.y;\n    \n    // randomize angles every frame\n    float rnd = hash32(iFrame);\n    float angrnd = ang * rnd;\n    vec2 b = vec2(cos(angrnd), sin(angrnd));\n    \n    float db = dot(b, b);\n    float idb = 1.0 / db;\n    vec2 v = vec2(0.0);\n    \n    float bbMax = 0.3 * iResolution.y;\n    bbMax *= bbMax;\n    \n    // vortices\n    for(int l = 0; l < 9; l++) {\n        if(db > bbMax) break;\n        vec2 p = b;\n        for(int i = 0; i < RotNum; i++) {\n            v += p.yx * getRot(invRes, fragCoord.xy + p, b, idb);\n            p = m * p;\n        }\n        b *= 2.0;\n        db *= 4.0;\n        idb *= 0.25;\n    }\n    \n    // software bilinear filtering (because hardware filtering messes up packed 16-bit values)\n    // sample in direction of velocity, which makes pixels move in the opposite direction\n    fragColor = biSW(iChannel0, fract((fragCoord.xy + vec2(-v.x, v.y)) * invRes), invRes);\n    \n    // velocity \"fountain\"\n    vec2 scr = fragCoord.xy * invRes - 0.5;\n    vec2 fgw = unpackHalves(fragColor.w);\n    fgw += (0.01 * scr.xy) / (dot(scr, scr) * 10.0 + 0.3);\n    fgw = clamp(fgw, -0.9, 0.9);\n    fragColor.w = packHalves(fgw);\n    \n    // fade colors over time\n    vec3 sg = clamp(fragColor.xyz - vec3(0.0005), 0.0, 1.0);\n    fragColor.xyz = sg;\n    \n    // branchless distance function for spawning circle\n    vec3 pcol0 = 0.5 * (sin(vec3(iTime, iTime + thirdprd, iTime + twothrdprd)) + 1.0);\n    float dist0 =- circleSDF(uv * 4.0, vec2(sin(iTime), cos(iTime)), 1.0);\n    bool tstcnd0 = (dist0 > 0.0) && ((iFrame % 144) == 1);\n    vec2 tstfac0 = vec2(float(tstcnd0), float(!tstcnd0));\n    fragColor.xyz = tstfac0.x * pcol0 + tstfac0.y * fragColor.xyz;\n    \n    // mouse interaction\n    if(iMouse.z > 0.0) {\n        vec2 ppos = -(iMouse.xy - 0.5 * iResolution.xy) * invRes.y;\n        vec3 pcol1 = 0.5 * (sin(vec3(iTime, iTime + thirdprd, iTime + twothrdprd) + pi) + 1.0);\n        float dist1 = circleSDF(uv, ppos, 0.25);\n        bool tstcnd1 = (dist1 < 0.0);\n        vec2 tstfac1 = vec2(float(tstcnd1), float(!tstcnd1));\n        fragColor.xyz = tstfac1.x * pcol1 + tstfac1.y * fragColor.xyz;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}