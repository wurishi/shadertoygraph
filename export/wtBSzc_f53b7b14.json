{"ver":"0.1","info":{"id":"wtBSzc","date":"1566577112","viewed":629,"name":"Intro to cone tracing pt.2","username":"edapx","description":"This is the same as \"Intro to cone tracing pt.1\" https://www.shadertoy.com/view/wlSSzc , just with depth of field bounded to the mouse.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["dof","antialias","conetracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 64;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 100.00;\nconst float PI = 3.14159265359;\n\nvec3 toGamma( vec3 col ){\n\treturn pow( col, vec3(1.0/2.2));\n}\n\nfloat clampeddot(vec3 a, vec3 b){\n    return max(0.,dot(a, b));\n}\n\nvec3 lightDirection = vec3(1.0, 1.0, 1.0);\n\nvec2 rotate(vec2 pos, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n} \n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nvec3 opRep( vec3 p, vec3 c ){\n    return mod(p,c)-0.5*c;\n}\n\nfloat map(vec3 pos){\n    pos.xy = rotate(pos.xy, sin(iTime) * PI/2. * 0.03);\n    float offset = 0.5;\n    //float sph = sphere(pos, 1.5);\n    // just a sphere\n    //return sph;\n\n    // domain repetition, more edges, antialias more visible\n    pos = opRep(pos, vec3(offset, offset, offset));\n\n    // test boxes\n    return sdBox(pos, vec3(0.1, 0.1, 0.1));\n\n    // test spheres\n    // /return sphere(pos, .2);\n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal){\n    return clampeddot(normal, lightDirection);\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 40.;\n    return pow(clampeddot(h, normal), specularityCoef);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getColor(vec3 eye, vec3 dir,float dist){\n    float ambient = 0.2;\n    vec3 red = vec3(1.0, 0.353, 0.208);\n    vec3 collision = (eye += (dist*0.995) * dir );\n    vec3 normal = computeNormal(collision);\n    float diffLight = diffuse(normal) * ambient + ambient;\n    float specLight = specular(normal, dir);\n\n    return (diffLight + specLight ) * red;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(3.5, 3.0, -1.0);\n    vec3 ta = vec3( -0.5, -0.9, 0.5 );\n    mat3 camera = setCamera( eye, ta, 1.0 );\n    float fov = 2.5;\n    vec3 dir = camera * normalize(vec3(uv, fov));\n\n    // bg color\n    vec3 finalColor = vec3(0.086, 0.19, 0.8);\n    // t is the position of the center of the sphere along the ray.\n    float t = NEAR_CLIP;\n    float dist = EPSILON;\n    float zoom = 1.5;\n\n    // this is the radius of the sphere that models the cone.\n    // formula from https://www.scratchapixel.com/lessons/advanced-rendering/rendering-distance-fields/basic-sphere-tracer\n    float vfov = 0.9; //vfov is the vertical camera field-of-view (in radians)\n    float radius = (2.0*tan(vfov/2.0)) /(iResolution.y*zoom);\n    // it can also be simplyfied using a constant, like in via https://www.shadertoy.com/view/MsBGWm\n    // float radius = .7071/(u_resolution.y*zoom);\n    \n    \n    //Depth of Field\n    float aperture = .03 * iMouse.x/iResolution.x;\n\tfloat focus = 5.1 * iMouse.y/iResolution.y;\n\n    // color accumulation variable. This is used to accumulate the colors sampled for all\n    // the intersection between the cone and the scene, and to accumulate the coverage\n    // on the alfa channel\n    vec4 acc = vec4(0, 0, 0, 1);\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float rad = t*radius + aperture*abs(t-focus);\n\n        // move the center of the sphere along the ray\n        dist = map(eye + t * dir);\n\n        // if the distance from the scene is smaller than the radius,\n        // it means that there is an intersection between the cone and the scene.\n        // we accumulate and blend the colors sampled for those intersections into the acc variable.\n        if (dist < rad) {\n            // how much of the surface of the projected pixel is covering the scene?\n            // this is what the coverage value stands for.\n\n            // This is the easiest coverage calculation that I have found:\n            // float alpha = smoothstep(rad, -rad, dist);\n            // https://www.shadertoy.com/view/4scBW8\n            float alpha = smoothstep(rad, -rad, dist);\n\n            // You can also estimate the coverage of the surface using it's distance\n            // over the projected aperture of the cone. \n            // coverage = dist / rad;\n            // of course the blending algorithm have to be adapted. see https://www.shadertoy.com/view/MsBGWm\n\n            // then sample the color at the given distance.\n            // I know, I could save the allocation of this variable, but, for the sake of clarity ...\n            vec3 sampleCol = getColor(eye, dir, t);\n\n            // the new color is calculated multiplying\n            // the previous alpha for the new color times the new alpha\n            acc.rgb += acc.a * (alpha*sampleCol.rgb);\n            // here we save the new alpha\n            acc.a *= (1.0 - alpha);\n\n            // when acc.a is really small, it means that we hit the object, brake the loop\n            if (acc.a < EPSILON ) break;   \n        }\n\n\n        // move the center of the sphere forward along the ray. The smaller\n        // the steps the higher the precision and the slower the computation.\n        t += max(abs(dist*0.85), 0.001); //https://www.shadertoy.com/view/4dlyWB\n        //t += max( dist, rad*.5 ); // https://www.shadertoy.com/view/MsBGWm\n\n        // brake if we are going too far away\n        if (t > FAR_CLIP) break;\n    }\n\n    finalColor = mix(acc.rgb, finalColor, acc.a);\n    fragColor = vec4(clamp(toGamma(finalColor),0.0,1.0),1.0);\n}","name":"Image","description":"","type":"image"}]}