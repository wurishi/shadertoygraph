{"ver":"0.1","info":{"id":"4lsXzs","date":"1439046609","viewed":881,"name":"[SIG15] I see the light","username":"casty","description":"Use the mouse. Camera has autofocus. \nHalos are single-sampled, I use a distribution function of the multisampled 't' to test drawing order.","likes":32,"published":1,"flags":64,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"ldl3zn","filepath":"https://soundcloud.com/jeliaedu/i-see-the-light-ost-disneys","previewfilepath":"https://soundcloud.com/jeliaedu/i-see-the-light-ost-disneys","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Eduardo Castineyra - casty/2015\n// Creative Commons Attribution 4.0 International License\n\nconst float PI=3.14159265358979323846;\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\nvec3  hash3( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0))+vec3(0.0,1.0,2.0))); }\nconst float TOOFAR = 99999.0;\n\nvec2 mouse;\n\nfloat time;\n\n#define NSAMPLES 15\n\n// See https://iquilezles.org/articles/palettes for more information\nvec3 pal( in float t){\n    \n    vec3 a, b ,c ,d; \n    \n    a = vec3(0.5,0.5,0.5); b = vec3(0.5,0.5,0.5); c = vec3(0.2,0.2,0.2); d = vec3(0.9,0.23,0.57);\n    return (a + b*cos( 6.28318*(c*t+d) ) + vec3(10.0) / 30.0); // desaturate\n\t}\n\n/// sRGB\nvec4 sTex2D(sampler2D s, vec2 coord){\n    vec4 color = texture(s, coord);\n    return pow(color, vec4(2.0));\n\t}\n\nfloat rayPlane(vec3 ro, vec3 rd, float y){\n    float t = (y-ro.y)/rd.y;\n  \treturn t;\n  \t}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n ){\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n\t}\n\nvec3 sun(vec2 uv){\n    vec2 uv1 = vec2(atan(uv.y,uv.x) / (2.0 * PI), length(uv));\n    uv1.x += step(uv.x, 0.0);\n    uv = uv1 + vec2(0.07, 0.0);\n    uv.x += sin(uv.y*30.0)/100.0;\n    uv1.x -= sin(uv.y*30.0 - 4.0)/100.0;\n    float col = 0.0;\n    col += step(fract(uv.x * 7.0), uv.y) + step(fract((7.0 - uv.x) * 7.0),uv.y);\n    col *= step(fract(uv1.x * 7.0), uv.y * 1.2) + step(fract((7.0 - uv1.x) * 7.0),uv.y * 1.2);\n    col += step(0.75 , 1.0 - uv.y);\n    col = clamp(col, 0.0, 1.0);\n    col -= step(0.78 , 1.0 - uv.y);\n    col = clamp(col, 0.0, 1.0);\n    return vec3(col);\n\t}\n\nvec3 rayHalo(vec3 ro, vec3 rd, vec3 o, float r){\n    o -= ro;\n    float t = dot(o, rd);\n//    float d = dot(rd * t - o, rd * t - o);\n    float d = length(rd * t - o);\n   \treturn vec3(t,d,d);\n\t}\n\nfloat LAMPR = 0.2;\nfloat LAMPBOTTOM = 1.1;\nfloat Ycoef = 0.15;    \n\n\nvec4 rayLamp(vec3 ro, vec3 d, vec3 ce, out float side, out vec3 n){\n    \n    vec4 res = vec4(TOOFAR);    \n    \n    vec3 bound = rayHalo(ro, d, ce, 0.0);\n    if (bound.y > LAMPR/Ycoef / 2.0)\n        return res;\n\t\n    vec3 o = ce - ro;\n\tfloat bottom = o.y - LAMPBOTTOM * LAMPR;\n    float top = o.y + LAMPBOTTOM * LAMPR;\n    side = 1.0;\n    n = vec3(0.0, 1.0, 0.0);\n    if (top < 0.0){\n        float t = rayPlane(vec3(0.0), d, top);\n        if (t > 0.0){\n            vec3 p = t * d - o;\n            if (dot(p, p) + (Ycoef -1.0) * p.y * p.y < LAMPR * LAMPR)\n\t            return vec4(p, t);\n        \t}\n    \t}\n    \n\tfloat c = dot(o,o) - LAMPR * LAMPR + (o.y *o.y * (Ycoef - 1.0));\n\tfloat b = -2.0 * (dot(d,o) +  d.y * o.y * (Ycoef - 1.0)); \n    float a = 1.0 + (Ycoef - 1.0) * d.y * d.y;\n\tfloat discriminant = b*b-4.0 * a * c;\n    if (discriminant > 0.0){\n        \n        float s = sqrt(discriminant);\n        float t = (-b -s)/ ( 2.0 * a); \n        side  = 1.0;\n        if (((t * d).y) > top){\n            return res;\n        \t}\n        if (((t * d).y) < bottom){\n            t = (-b + s)/ ( 2.0 * a);\n            side = -1.0;\n        \t}\n        if (((t * d).y) < bottom){\n            return res;\n        \t}\n        \n\n        vec3 p = ((t * d) - o);\n       \tvec3 n = normalize(p - o) * side;\n        vec2 uv = p.xy;        \n\t\treturn t > 0.0 ?  vec4(p, t) :res;\n    \t}\n    return res;\n\t}\n\n\n/// Magic numbers Here\nvoid Lantern(vec2 pos, out vec3 col, out vec3 ce, out float fire){\n   \tvec3 r = hash3(pos);\n    vec3 r2 = hash3(r.zy);\n    ce.y = 1.0 + sin((time * 0.02 + r2.x + r2.y * 10.0)) * (6.0 + r.z * 3.0) + 2.0;\n    ce =  vec3(pos.x + 0.5, ce.y, pos.y + 0.5);\n    ce.x += sin(time * (1.07 + r2.y / 2.0) + r2.z) * 0.1 ;\n    if (abs(pos.x) + abs(pos.y) < 2.0) /// FIXME Closest halos don't get well with the traverse\n        ce.y = TOOFAR;\n    fire = sin(time * (11.0 + r2.x)  + r2.z * 10.0) * 0.25 + 0.75 + cos(time * 23.0) * 0.25;\n    col = pal(r2.z);\n\t}\n\nvec4 rayCellPos(vec3 o, vec3 d, vec2 pos){\n    vec3 ce;\n    vec3 col;\n    float side;\n    float fire;\n    vec3 n;\n    Lantern(pos, col, ce, fire);\n    vec4 sph = rayLamp(o, d, ce, side, n);\n    if (sph.a >= TOOFAR)\n        return vec4(vec3(0.0), sph.a);\n    vec3 p = (o + sph.a*d - ce);\n    vec3 tex = (texcube( iChannel0, p, n).rgb + 1.0) / 5.0;\n    float star = (1.0 - sun(p.zy * 3.5 - vec2(0.0)).r) / (2.5 - side);\n    tex.r += star;\n    tex += (1.0 - tex.r) * fire * vec3(60.0, 60.0, 30.0) / (9.0 + side * 4.0);\n    tex *= clamp(0.2 - p.y / (LAMPR/Ycoef), 0.01, 1.0);\n    col *= tex;\n    return vec4(col, sph.a);\n\t}\n\nvec4 castRay( in vec3 ro, in vec3 rd){\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( 0.0, 0.0, 0.0, TOOFAR);\n\t\n    vec2 mm;\n    mm = step( dis.xy, dis.yx ); \n    dis += mm*ris;\n    pos += mm*rs;\n\n    // traverse regular grid (in 2D)\n\tfor( int i=0; i<18; i++ ) \n\t{\t\t\n        \n        vec4 cell = rayCellPos(ro, rd, pos);\n        if (cell.a != TOOFAR){\n            return cell;\n        \t}\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\treturn res;\n}\n\nvec4 rayHaloPos(vec3 o, vec3 d, vec2 pos){\n    vec3 ce;\n    vec3 col;\n    float fire;\n    Lantern(pos, col, ce, fire);\n   \tce.y -= LAMPBOTTOM * LAMPR;\n    \n    float ra = 1.5;\n    vec3 hal = rayHalo(o, d, ce, ra);\n    col *= 1.0 - pow(hal.y / ra, 0.1);\n    col = clamp(col * 0.3, vec3(0.0), vec3(0.1));\n    return  vec4(col.rgb * smoothstep(-40.0, 20.0, dot(ce, vec3(0.0, 1.0, 0.0))), hal.x);\n\t}\n\nvec4 rayFirePos(vec3 o, vec3 d, vec2 pos){\n    vec3 ce;\n    vec3 col;\n    float fire;\n    Lantern(pos, col, ce, fire);\n    \n   \tce.y -= LAMPBOTTOM * LAMPR;\n    \n    col = vec3(8.0, 8.0, 4.0) * fire;\n    \n    float ra = 0.2;\n    vec3 hal = rayHalo(o, d, ce, ra);\n    col *= 1.0 - pow(hal.y / ra, 0.05);\n    col = clamp(col, vec3(0.0), vec3(max(0.0, 1.0 - hal.x / 25.0)));\n    return vec4(col.rgb * smoothstep(-0.1, 0.2, dot(ce, vec3(0.0, 1.0, 0.0))), hal.x);\n\t}\n\nvec4 castRayHalos( in vec3 ro, in vec3 rd, vec2 tdf){\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n    vec2 side = sign(rd.xz).yx * vec2(-1.0, 1.0); /// 3 parallel lines traverse the grid\n\t\n    vec2 mm;\n\tfloat mint = 0.0;\n\tvec4 hal;    \n\tvec4 res = vec4( 0.0, 0.0, 0.0, TOOFAR);\n    \n    // traverse regular grid (in 2D)\n\tfor( int i=0; i<40; i++ ) \n\t{\t\t\n        float att = (40.0 - float(i))/40.0;\n        hal = rayHaloPos(ro, rd, pos);\n        res.rgb += hal.rgb * att;\n        hal = rayFirePos(ro, rd, pos);\n        /// What is the probability that the halo is behind something?\n        res.rgb += (1.0 - smoothstep(tdf.x - tdf.y, tdf.x + tdf.y, hal.a)) * hal.rgb * att;\n        hal = rayHaloPos(ro, rd, pos + side);\n        res.rgb += (1.0 - smoothstep(tdf.x - tdf.y, tdf.x + tdf.y, hal.a)) * hal.rgb * att;\n        hal = rayHaloPos(ro, rd, pos - side);\n        res.rgb += (1.0 - smoothstep(tdf.x - tdf.y, tdf.x + tdf.y, hal.a)) * hal.rgb * att;\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\treturn vec4(res.rgb, tdf.x + tdf.y);\n}\n\nvec2 hashmod = vec2(0.0);\nvoid dof(vec2 uv, inout vec3 co, inout vec3 rd, vec2 focus){\n    rd *= focus.x;\n    vec3 hash = hash3(uv + hashmod) / focus.y;\n    co += hash - 0.5 / focus.y;\n    rd = normalize(rd - hash + 0.5 / focus.y);\n    hashmod += hash.xz;\n\t}\n\nvec3 cam(vec2 uv, vec3 co, vec3 d){\n    d = normalize(d);\n    vec3 u = normalize(cross(d,vec3(0.0,1.0,0.0)));\n    vec3 v = normalize(cross(u,d));\n    vec2 p = uv - 0.5;\n\tvec3 rd = normalize(d + p.x*u + p.y*v);    \n    return rd;\n\t}\n\nvec4 rayTrace2(vec3 o, vec3 d){\n    vec4 cas = castRay(o, d);\n    float t = cas.a;\n    if (t < TOOFAR){\n        return vec4(cas);\n    \t}\n    vec3 sky = (1.0 - abs(d.y)) * vec3(0.01, 0.04, 0.1);\n    return vec4(sky, TOOFAR);\n\t}\n\nvec4 rayHalos(vec3 o, vec3 d, vec2 tdf){\n    vec4 cas = castRayHalos(o, d, tdf);\n    return cas;\n\t}\n\nvec4 center(vec2 uv){\n    return vec4(step(-0.001, -length(uv - 0.5)));\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy) * vec2(1.0, 0.56) + vec2(0.0, 0.22);\n    mouse = iMouse.xy / iResolution.xy;\n    time = iTime;\n    \n    \n    vec3 co = vec3(0.5, 0.0, 0.5);\n    \n   \tvec2 a = vec2(mouse.xy/vec2(1.0, 4.0) + vec2(0.0, -0.1) + vec2(0.0, 0.15) *(1.0 -step (0.01, mouse.y))) * 2.0 * PI;\n    vec3 dir = vec3(cos(a.x) * cos(a.y), sin(a.y), sin(a.x) * cos(a.y));\n\t    \n    vec3 rd = cam(uv, co, dir);\n\tvec2 focus = vec2(rayTrace2(co, dir).a, 20.0);\n\tvec4 c = vec4(0.0);\n    \n    vec4 color = vec4(0.0);\n    vec2 tdf = vec2(0.0); /// t distribution\n    \n    for (int i = 0 ; i < NSAMPLES; i++){\n        rd = cam(uv + hash2(float(i)) / iResolution.xy, co, dir);\n        vec3 cod = co;\n        vec3 rdd = rd;\n    \tif (focus.x <= 0.0) focus.x = 1000.0;\n    \tdof(uv, cod, rdd, focus);\n        vec4 c = rayTrace2(cod, rdd);\n\t\tcolor.xyz += c.xyz;\n        c.a = clamp(c.a, 0.0, 100.0);\n        tdf.x += c.a;  \t\t\t\t\t\t\t\t/// average\n        tdf.y += abs(c.a - tdf.x / float(i + 1));\t/// sd\n        \n        color.a = max(color.a, c.a);\n    \t}\n    \n    tdf.x /= float(NSAMPLES);\n    \n    rd = cam(uv, co, dir); \n    c = rayHalos(co, rd, tdf);\n    \n    color /= float(NSAMPLES) + center(uv);\n    color.xyz += c.xyz;\n    color = pow(color, vec4(0.5));\n    fragColor = vec4(color.xyz, 1.0) + center(uv);\n\n    \n\t}","name":"Image","description":"","type":"image"}]}