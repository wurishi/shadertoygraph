{"ver":"0.1","info":{"id":"ldc3WH","date":"1449271804","viewed":243,"name":"SierpinskiCarpet","username":"jt","description":"Good old Sierpinski Carpet - short version.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sierpinski","carpet","short"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Sierpinski Carpet (https://en.wikipedia.org/wiki/Sierpinski_carpet) - Shader 2015 by JT\n// shortest codegolfed 131char version by FabriceNeyret2\nvoid mainImage( out vec4 o, vec2 I )\n{\n    I /= iResolution.xy;\n    o -= o;\n    for(int i = 0; i < 5; i++)\n        I = 3.*fract(I),\n        abs(I.x-1.5)<.5&&abs(I.y-1.5)<.5? o++ : o;\n}\n\n// NOTE: using fuzzy-operators derived from probability-theory:\n//       0 == FALSE\n//       1 == TRUE\n//       1-a == NOT a\n//       a*b == a AND b\n//       1-(1-a)*(1-b) == a+b-ab == NOT ((NOT a) AND (NOT b)) == a OR b via deMorgan rule\n/*\nvoid mainImage( out vec4 o, in vec2 I ) // my original version (153char)\n{\n    I /= iResolution.xy;\n    o = vec4(1); // fuzzy-logic o := TRUE\n    for(int i = 0; i < 5; i++)\n    {\n        I = 3.*fract(I);\n        vec2 w = step(.5,abs(I - 1.5));\n        // following line does fuzzy-logic o := o AND ...\n        o *= 1.-(1.-w.x)*(1.-w.y); // fuzzy-logic x OR y == NOT ((NOT x) AND (NOT y)) via deMorgan rule\n    }\n}\n*/\n/*\nvoid mainImage( out vec4 o, in vec2 I ) // my attempt to code-golf it (137chars)\n{\n    I /= iResolution.xy;\n    o -= o;\n    for(int i = 0; i < 5; i++)\n    {\n        I = 3.*fract(I);\n        vec2 w = step(-.5,-abs(I - 1.5));\n        o += w.x*w.y;\n    }\n}\n*/\n","name":"","description":"","type":"image"}]}