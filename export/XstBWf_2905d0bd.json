{"ver":"0.1","info":{"id":"XstBWf","date":"1541164977","viewed":66,"name":"Moosichu: Experimenting with SDF","username":"Moosichu","description":"Fun","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["experimental"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Learning from https://iquilezles.org/\n\n// -- SYMBOL KEY --\n// p : position\n// r : radius\n// rp: ray position\n// pn: plane normal\n// sd: sphere distance\n// pd: plane distance\n// eps: epsilon, a small value\n\nconst float eps = 0.00001;\n\n    \nfloat sphere(vec3 rp, float r) {\n\treturn length(rp) - r;\n}\n\n// pn must be normalised\nfloat plane(vec3 rp, vec4 pn)\n{\n  return dot(rp, pn.xyz) + pn.w;\n}\n\nvec3 translate(vec3 rp, vec3 pos) {\n\treturn rp - pos;   \n}\nfloat distance_field(vec3 rp) {\n    float sd = sphere(translate(rp, vec3(1,1,15)), 10.0);\n    float sd2 = sphere(translate(rp, vec3(10.0 * sin(iTime),10,15)), 5.0);\n    float pd = plane(rp, normalize(vec4(0,1,0,1)));\n    sd = min(sd, sd2);\n    return min(pd,sd);\n}\n\nvec3 normal(vec3 rp) {\n \tfloat x = distance_field(rp + vec3(eps,0,0)) - distance_field(rp - vec3(eps,0,0));\n    float y = distance_field(rp + vec3(0,eps,0)) - distance_field(rp - vec3(0,eps,0));\n    float z = distance_field(rp + vec3(0,0,eps)) - distance_field(rp - vec3(0,0,eps));\n    return normalize(vec3(x,y,z));\n}\n\nvec4 get_color(vec3 rp, vec3 ray_direction, int iter_count) {\n    for(int i = 0; i < iter_count; i++) {\n        float d = distance_field(rp);\n        if(d < 0.1) {\n            // We hit a surface!\n            vec3 n = normal(rp);\n   \t\t\tvec3 r = reflect(ray_direction, normalize(n));\n            // TODO: PHONG\n            return vec4(texture(iChannel0, r).rgb, 1.0);\n            \n            return vec4(n,0);\n        }\n\n        rp = rp + (d * ray_direction);\n    }\n    return vec4(texture(iChannel0, ray_direction).rgb, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 camera_pos = vec3(5.0 - (iMouse.x * 0.01),(iMouse.y * 0.01),25);\n    float distance_behind_camera = 60.0;\n    vec3 camera_normal = normalize(vec3(0, .1, -1));\n    vec3 camera_orientation = normalize(vec3(0,1,1));\n    float camera_y = 50.0;\n    float camera_x = camera_y * (iResolution.x/iResolution.y);\n    vec2 camera_dimensions = vec2(camera_x, camera_y); // width, height\n    \n    vec2 camera_position = camera_dimensions * (uv - vec2(.5, .5));\n    \n    vec3 camera_right =  normalize(cross(camera_orientation, camera_normal));\n    vec3 camera_up = normalize(cross(camera_normal, camera_right));\n    \n    // assume camera is pointing down z axis (for now)\n    vec3 ray_starting_position = (camera_position.x * camera_right) +  (camera_position.y * camera_up);\n    ray_starting_position += camera_pos;\n    \n    // just assume rays fire down z axis now\n    vec3 ray_direction = normalize((distance_behind_camera * camera_normal) + ray_starting_position);\n\n    // Output to screen\n    fragColor = get_color(ray_starting_position, ray_direction, 35);\n}","name":"Image","description":"","type":"image"}]}