{"ver":"0.1","info":{"id":"stlfzM","date":"1650671839","viewed":78,"name":"Cel Shading temp","username":"Fanjia","description":"Cel Shading","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER\t1000\n#define MAX_DIST\t10.0\n#define EPSILON\t\t0.001\n\n\n//the link function comes from https://iquilezles.org/articles/distfunctions/\nfloat sdLink( in vec3 p, in float le, in float r1, in float r2 )\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat distance( in vec3 pos )\n{\n    // animate\n    pos.y += 0.5*iTime;\n\n    // paramteres\n    const float le = 0.13, r1 = 0.2, r2 = 0.09;\n    \n    // make a chain out of sdLink's\n    vec3 a = pos; a.y = fract(a.y    )-0.5;\n    vec3 b = pos; b.y = fract(b.y+0.5)-0.5;\n    \n    // evaluate two links\n    return min(sdLink(a.xyz,le,r1,r2),\n               sdLink(b.zyx,le,r1,r2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 camera_position = vec3(0.5);\n    vec3 camera_facing = vec3(0.0);\n    vec3 positive_y = vec3(0.0, 1.0, 0.0);\n    \n    vec3 camera_direction = normalize(camera_facing - camera_position);\n    vec3 camera_y = normalize(cross(positive_y, camera_position));\n    vec3 camera_up = cross(camera_direction, camera_y);\n    \n    //place origin at center of screen & correct aspect ratio\n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(camera_y * screenPos.x + camera_up * screenPos.y + camera_direction);\n    \n    //Raymarching the chain\n    float totalDist = 0.0;\n    vec3 pos = camera_position;\n    float dist = EPSILON;\n    \n    for (int i = 0; i < MAX_ITER; i++) {\n        if (dist < EPSILON || totalDist > MAX_DIST) {\n            break;\n        }\n        \n        dist = distance(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n        \n    }\n    if (dist < EPSILON) {\t\t\t\t//the ray hit the object\n    \tvec2 eps = vec2(0.0, EPSILON);\n    \tvec3 normal = normalize(vec3(\n       \t\t\tdistance(pos + eps.yxx) - distance(pos - eps.yxx),\n       \t\t\tdistance(pos + eps.xyx) - distance(pos - eps.xyx),\n       \t\t\tdistance(pos + eps.xxy) - distance(pos - eps.xxy)));\n    \n    \tfloat diffuse = max(0.0, dot(-rayDir, normal));\n    \tfloat specular = pow(diffuse, 1000.0);\n        float lighting = diffuse + specular;\n        float toonMap;\n        \n        //map lighting information to discrete values\n        if(lighting < 0.2){\n            toonMap = 0.2;\n        }else if(lighting < 0.5){\n            toonMap = 0.5;\n        }else{\n            toonMap = 0.900;\n        }\n        vec3 color = vec3(toonMap,0,0);\n        fragColor = vec4(color, 1.0);\n    } else {\t\t\t\t\t\t//the ray didn't hit anything\n        fragColor = vec4(1, 0.5, 0.5, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}