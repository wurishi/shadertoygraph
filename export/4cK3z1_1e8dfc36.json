{"ver":"0.1","info":{"id":"4cK3z1","date":"1712441328","viewed":65,"name":"Diffuse interpolation - 2D image","username":"mrboggieman","description":"Diffuse interpolation by sampling normalised 2d distributions. The alpha changes over time showing the transition between the two distributions. The sampling rate is pretty low as sampling textures is inefficient","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blending","diffuse","interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Diffuse (move pixels) between two 2D images\n// Demo inspired by Iterative-(de)Blending (see Figure 9 in https://arxiv.org/pdf/2305.03486.pdf)\n// Note: the approach in this demo is different - rather than randomising paths we use means which is equivalent with enough samples\n\n// increase for greater precision - this is O(n^2) :(\nconst int num_samples = 50; //this needs to be the resolution of the images really\n\nconst float framesPerTransition = 200.0; // the number of frames to use between each transition\n\n// image samples we will be interpolating\nvec3 from(in vec2 uv, in int stage) {\n    switch (stage) {\n        case 0: return texture(iChannel0, uv).rgb;\n        case 1: return texture(iChannel1, uv).rgb;\n        case 2: return texture(iChannel2, uv).rgb;\n    }\n    return vec3(0.0);\n}\n\nvec3 to(in vec2 uv, in int stage) {\n    switch (stage) {\n        case 0: return texture(iChannel1, uv).rgb;\n        case 1: return texture(iChannel2, uv).rgb;\n        case 2: return texture(iChannel0, uv).rgb;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float alpha = mod(float(iFrame) / framesPerTransition, 1.0);\n    int stage = int(float(iFrame) / framesPerTransition) % 3;\n\n    if (alpha < 0.00001) {\n        fragColor = vec4(from(uv, stage), 1.0);\n        return;\n    }\n    \n    // we need to normalise the distributions so just sum the samples for a division later\n    // note: could calculate this once per image in a buffer or something\n    vec3 from_total = vec3(0.0);\n    vec3 to_total = vec3(0.0);\n\n    for (int i=0; i<num_samples; i++) {\n        float sample_x = float(i) / float(num_samples);\n\n        for (int j=0; j<num_samples; j++) {\n            float sample_y = float(j) / float(num_samples);\n            vec2 sample_pos = vec2(sample_x, sample_y);\n\n            from_total += from(sample_pos, stage);\n            to_total += to(sample_pos, stage);\n        }\n    }\n\n    // only a subset of the inputs and outputs would cross our 3d coord, we can compute the ranges\n    // maths: https://www.desmos.com/3d/60b155c9e9\n    float from_alpha = -alpha/(1.0-alpha);\n    \n    vec2 from_start = clamp((1.0 - uv) * from_alpha + uv, vec2(0.0), vec2(1.0));\n    vec2 from_end = clamp(-uv * from_alpha + uv, vec2(0.0), vec2(1.0));\n    \n    float to_alpha = (1.0-alpha) / -alpha;\n\n    vec2 to_start = clamp(-uv * to_alpha + uv, vec2(0.0), vec2(1.0));\n    vec2 to_end = clamp((1.0 - uv) * to_alpha + uv, vec2(0.0), vec2(1.0));\n\n    //all we need to do is figure out how many points from the original distribution will go through this coord on their way to the target\n    vec3 sum = vec3(0.0);\n\n    for (int i=0; i<num_samples; i++) {\n        float sample_x = float(i) / float(num_samples);\n\n        for (int j=0; j<num_samples; j++) {\n            float sample_y = float(j) / float(num_samples);\n            vec2 sample_pos = vec2(sample_x, sample_y);\n\n            vec2 from_pos = mix(from_start, from_end, sample_pos);\n            vec2 to_pos = mix(to_start, to_end, sample_pos);\n\n            sum += from(from_pos, stage) * (to(to_pos, stage) / to_total);\n        }\n    }\n    \n    //the two distributions may have a different sum so scale to blend between the two\n    vec3 target_total = mix(from_total, to_total, alpha);\n    vec3 total_multiplier = target_total / from_total;\n\n    sum *= total_multiplier;\n\n    fragColor = vec4(sum,1.0);\n}\n","name":"Image","description":"","type":"image"}]}