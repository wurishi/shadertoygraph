{"ver":"0.1","info":{"id":"csdBDf","date":"1697815329","viewed":69,"name":"[ConcoursJFIG2023] birthday cake","username":"ChGrenier","description":"Concours shadertoy JFig 2023, thème : \"anniversaire des 30 ans de l'AFIG\"\nShadertoy contest for JFig 2023 (Journées Française d'informatique graphique), on the subject \"30th birthday of AFIG\" (Association Française d'Informatique Graphique)","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sdf","concoursjfig2023"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.\n#define MAX_DIST 100.\n#define EPSILON 0.0005\n#define PRECISION 0.001\n\n#define NUM_SPARKS 80\n#define NUM_FIREWORKS 4\n\n\n\n\n\n// ============================\nvec2 SDFfire(vec3 pos, float fire_size, vec3 fire_pos)\n{\n    float base = sdSphere(pos+fire_pos, fire_size);\n    \n    fire_pos.y -= 2.*fire_size;\n    fire_pos += 0.02*sin(vec3(10.*iTime, 12.*iTime, 9.*iTime+0.2));\n    \n    float top = sdRoundedCylinder(pos+fire_pos, fire_size/5., 2.*fire_size/5., fire_size*0.8);\n    \n    float dist = SmoothUnionSDF(base, top, fire_size*2.)+0.025*abs(noised(12.*pos));\n    \n    float MatId = 3.+sqrt(fract(pos.y/(4.5*fire_size)));\n\t\n    \n\treturn vec2(dist, MatId);\n}\n\n\n/*\n * description de la scène\n * \n * retourne un vec2 avec la distance et un id de matériaux\n */\nvec2 SDFscene(vec3 sampleCoords) \n{\n    float MatId = 1.;\n    \n    sampleCoords = rotateY(0.6*iTime)*sampleCoords;\n    \n    \n    // cake\n    vec3 init_pos   = vec3(0., 3., 0.);\n    float init_size = 1.;\n    vec2 cakeSDF1  = SDFcake(sampleCoords, init_pos, init_size, 15);\n    \n    init_pos      += vec3(0., -2.*init_size, 0.);\n    init_size     *= 0.8;\n    vec2 cakeSDF2 = SDFcake(sampleCoords, init_pos, init_size, 11);\n    \n    init_pos      += vec3(0., -2.*init_size, 0.);\n    init_size     *= 0.8;\n    vec2 cakeSDF3 = SDFcake(sampleCoords, init_pos, init_size, 12);\n    \n    \n    float cakeSDF = cakeSDF1.x;\n    MatId = cakeSDF1.y;\n    \n    if(cakeSDF2.x < cakeSDF)\n    {\n        cakeSDF = cakeSDF2.x;\n        MatId = cakeSDF2.y;\n    }\n    \n    if(cakeSDF3.x < cakeSDF)\n    {\n        cakeSDF = cakeSDF3.x;\n        MatId = cakeSDF3.y;\n    }\n    \n    // candle\n    vec3 candle_position = init_pos - vec3(0., 2.5, 0.);\n    vec2 candleSDF = SDFcandle(sampleCoords, candle_position);\n    \n    if(candleSDF.x < cakeSDF)\n    {\n        cakeSDF = candleSDF.x;\n        MatId = candleSDF.y;\n    }\n    \n    // flame\n    vec3 fire_pos = candle_position - vec3(0., .15, 0.);\n    float fire_size = 0.1;\n    vec2 fireSDF = SDFfire(sampleCoords, fire_size, fire_pos);\n    \n    if(fireSDF.x < cakeSDF)\n    {\n        cakeSDF = fireSDF.x;\n        MatId = fireSDF.y;\n    }\n    \n    // afig\n    vec3 afig_position = init_pos - vec3(0., 1.1, -0.65);\n    vec2 afigSDF = SDFafig(sampleCoords*rotateX(0.18), afig_position);\n    \n    if(afigSDF.x < cakeSDF)\n    {\n        cakeSDF = afigSDF.x;\n        MatId = afigSDF.y;\n    }\n    \n    // 30\n    float size_30 = 0.2;\n    vec3 position_30 = init_pos + vec3(2.*size_30, 0., -2.7*init_size);\n    vec2 sdf30 = SDF30(sampleCoords, position_30, size_30);\n    \n    \n    if(sdf30.x < cakeSDF)\n    {\n        cakeSDF = sdf30.x;\n        MatId = sdf30.y;\n    }\n    \n    \n    return vec2(cakeSDF, MatId);\n}\n\n\n\n\n\n\n\n// ============================\nmat3 TexturesScene(float MatId)\n{\n    vec3 K_a;\n    vec3 K_d;\n    float K_s;\n    float shininess;\n    \n    if(int(MatId) == 0) // cake\n    {\n        K_a = vec3(.1, .1, .1);\n        K_d = vec3(.3, .15, .05) + vec3(35.*fract(MatId));\n        K_s = .1;\n        shininess = 24.;\n    }\n    \n    if(int(MatId) == 1) // icing\n    {\n        K_a = normalize(vec3(.8, .7, .9));\n        K_d = vec3(.8, .7, .9) + vec3(20.*fract(MatId));\n        K_s = 1.;\n        shininess = 24.;\n    }\n    \n    if(int(MatId) == 2) // candle\n    {\n        K_a = vec3(.5, .5, .5);\n        K_d = vec3(1.-(MatId-2.), MatId-2.,  1.-(MatId-2.));\n        K_s = 1.;\n        shininess = 24.;\n    }\n    \n    if(int(MatId) == 3) // flame\n    {\n        K_a = normalize(fire(fract(MatId)));\n        K_d = fire(fract(MatId));\n        K_s = 1.;\n        shininess = 12.;\n    }\n    \n    if(int(MatId) == 4) // afig\n    {\n        K_a = vec3(.4);\n        K_d = vec3(0.8, 0.8+fract(MatId), 0.8-fract(MatId));\n        K_s = .6;\n        shininess = 24.;\n    }\n    \n    if(int(MatId) == 5) // 30\n    {\n        K_a = normalize(vec3(1., 1., 0.8));\n        K_d = vec3(1., 1., 0.8);\n        K_s = 1.;\n        shininess = 24.;\n    }\n    \n    return mat3(K_a, K_d, vec3(K_s, shininess, 0.));\n\n}\n\n\nvec3 fireworks(vec2 p) // inspired by https://www.shadertoy.com/view/4lfXRf\n{\n    vec3 color = vec3(0.);\n    \n    for(int fw = 0; fw < NUM_FIREWORKS; fw++)\n    {\n        float fw_id = float(fw);\n        \n        // position du centre de l'explosion\n        vec2 pos = hash22(fw_id*vec2(0.826, 0.117));\n        float time = mod(3.*iTime+1., float(NUM_FIREWORKS)*(1.+hash21(fw_id*vec2(0.123, 0.987))));\n        \n        for(int spark = 0; spark < NUM_SPARKS; spark++)\n    \t{\n            float spark_id = float(spark);\n            \n            // direction des étincelles\n        \tvec2 dir = hash22(spark_id*vec2(0.512, 0.133));\n            dir.y -= 0.24*time; \n            \n            float term = 1./(float(NUM_SPARKS)*length(p-pos-dir*time));\n            \n            color += pow3(term * vec3(0.4 * hash22(spark_id*vec2(0.431, 0.724)).y,\n                                      0.8 * hash22(spark_id*vec2(0.534, 0.421)).x,\n                                      0.6 * hash22(spark_id*vec2(0.717, 0.784)).y), 1.24);\n        }\n    }\n    return color;\n}\n\n\n\n\n\n\n// ============================\n\n/*\n * calcul de la distance la plus courte entre la caméra et la scene \n * en suivant une direction donnée.\n * si on ne trouve rien avant d'atteindre le fond de la scène on retourne \n * la distance max\n *\n * eye : position de la caméra, origine de la direction de marching\n * marchinigDirection : direction normalisée\n * start : distance de départ de la caméra\n * end : distance du fond de le scène\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    float depth = start;\n    vec2 surfaceInformation;\n    vec3 marchingPos;\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        marchingPos = eye + depth * marchingDirection;\n        surfaceInformation = SDFscene(marchingPos);\n        \n        depth += surfaceInformation.x;\n        \n        if(surfaceInformation.x < EPSILON || depth > end) break;\n    }\n    \n    surfaceInformation.x = depth;\n    \n    return surfaceInformation;\n}\n\n\n\n\n/*\n * calcul de la direction normalisée de marching\n * \n * fieldOfView : angle de vision verticale en degré\n * size : resolution de l'image de sortie\n * fragCoord : coordonnée x,y du pixel dans l'image de sortie\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView)/2.);\n    return normalize(vec3(xy,-z));\n}\n\n\n/* \n * estimation des normales à la surface avec le gradient de la SDF\n * (par différence finie)\n */\nvec3 estimateNormal(vec3 sampleCoords)\n{\n    float dSDFdx = SDFscene(vec3(sampleCoords.x + EPSILON, sampleCoords.y, sampleCoords.z)).x - SDFscene(vec3(sampleCoords.x - EPSILON, sampleCoords.y, sampleCoords.z)).x;\n    float dSDFdy = SDFscene(vec3(sampleCoords.x, sampleCoords.y + EPSILON, sampleCoords.z)).x - SDFscene(vec3(sampleCoords.x, sampleCoords.y - EPSILON, sampleCoords.z)).x;\n    float dSDFdz = SDFscene(vec3(sampleCoords.x, sampleCoords.y, sampleCoords.z + EPSILON)).x - SDFscene(vec3(sampleCoords.x, sampleCoords.y, sampleCoords.z - EPSILON)).x;\n    \n    return normalize(vec3(dSDFdx, dSDFdy, dSDFdz));\n}\n\n\n\n\n/*\n * calcul des ombres\n * https://iquilezles.org/articles/rmshadows/\n *\n * LightPos : position de la lampe\n * ScenePos : position à ombrager (ou non) sur la surface\n * start : distance minimum considérée\n * end : distance maximum considérée (au-delà l'objet ne fait pas d'ombre)\n * LightAngle : angle du rayon lumineux (sur 0, 1 ish)\n */\nfloat softshadow(vec3 LightPos, vec3 ScenePos, float start, float end, float LightAngle) \n{\n    float res = 1.;\n    float depth = start;\n\n    vec3 N = estimateNormal(ScenePos);\n    vec3 L = LightPos - ScenePos;\n\n    vec3 LightDirection = normalize(L);\n\n\n    for(int i = 0; i < MAX_MARCHING_STEPS ; i++)\n    {\n      float surfaceInformation = SDFscene(ScenePos + LightDirection * depth).x;\n\n      res = min(res, surfaceInformation/(LightAngle*depth));\n      \n      depth += clamp(surfaceInformation, 0.005, 0.5);\n\n      if(res < -1. || depth > end) break;\n    }\n\n    res = max(res,-1.);\n    return .25*(1.0 + res)*(1.0 + res)*(2.0 - res);\n}\n\n\n\n\n\n\n\n/*\n * contribution d'une lampe par le modèle d'illumination de Phong\n * \n * retourne la couleur correspondant à la contribution\n * k_a : couleur ambient\n * k_d : couleur partie diffuse\n * k_s : coefficient partie spéculaire\n * alpha : coefficient de spécularité\n * ScenePos : position du point  éclairer\n * EyePos : position de la caméra\n * LightPos : position de la lampe\n */\nvec3 LightContributionPhong(vec3 k_d, vec3 k_s, float alpha, vec3 LightPos, vec3 ScenePos, vec3 EyePos)\n{\n\tvec3 N = estimateNormal(ScenePos);\n\tvec3 L = normalize(LightPos - ScenePos);\n\tvec3 V = normalize(EyePos - ScenePos);\n\tvec3 H = normalize(L + V);\n\n    float shadows = softshadow(LightPos, ScenePos, 0.01, 3., 0.06);\n    \n    float dotLN = max(dot(N, L), 0.);\n    float dotHN = max(dot(H, N), 0.);\n    \n\tvec3 diffuse = k_d * dotLN;\n\tvec3 speculaire = k_s * pow(dotHN, alpha);\n\n\treturn shadows*(diffuse + speculaire);\n}\n\n\n\n\n/*\n * modèle d'illuminaiton de Phong\n * \n * retourne la couleur d'un point après éclairage (somme des contribution des sources de lumière)\n * k_a : couleur ambient\n * k_d : couleur partie diffuse\n * k_s : couleur partie spéculaire\n * alpha : coefficient de spécularité\n * pos : position du point  éclairer\n * eye : position de la caméra\n * ambiantLight : lumière ambiante (définie par le fond de la scène)\n */\nvec3 PhongIlluminationModel(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 ScenePos, vec3 EyePos, vec3 ambiantLight)\n{\n\tvec3 color = ambiantLight * k_a;\n\n    vec3 LightPos;\n\tvec3 LightIntensity;\n    \n    \n    // lampe 1\n\tLightPos = vec3(12., 1., 6.);\n\tLightIntensity = vec3(0.5);\n\n\tcolor += LightIntensity * LightContributionPhong(k_d, k_s, alpha, LightPos, ScenePos, EyePos);\n    \n    \n    // lampe 2 (bougie)\n\tLightPos = vec3(0., 3.5, 0.);\n\tLightIntensity = vec3(0.3);\n\n\tcolor += LightIntensity * LightContributionPhong(k_d, k_s, alpha, LightPos, ScenePos, EyePos);\n    \n    \n\n\treturn color;\n}\n\n\n\n/*\n * matrice de transformation \n * pour la position et l'orientation de la caméra\n * \n * retourne la matrice de transformation normalisée (mat4)\n */\nmat4 LookAt(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n\n\n\n// ================================================\n// ================== rendering ===================\n// ================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy - 1.;\n    vec3 background = fireworks(vec2(2.5, 2.)*uv);\n    \n    vec3 ViewDir = rayDirection(45., iResolution.xy, fragCoord);\n    \n    // camera\n    vec3 eye = vec3(6., 5., 18.); \n    vec3 center = vec3(0.);\n    vec3 up = vec3(0., 1., 0.); // y up\n    \n    mat4 ViewToScene = LookAt(eye, center, up);\n    \n    // ============================\n    vec3 SceneDir = (ViewToScene * vec4(ViewDir, 0.)).xyz; \n    \n    \n    vec2 SceneInfo = shortestDistanceToSurface(eye, SceneDir, MIN_DIST, MAX_DIST);\n    float dist = SceneInfo.x; \n    \n    // ============================\n    if(dist > MAX_DIST - EPSILON) \n    {\n        fragColor = vec4(background, 1.);\n        return;\n    }\n    \n    // ============================\n    vec3 pointPos = eye + dist * SceneDir;\n    \n    mat3 MatInfo = TexturesScene(SceneInfo.y); \n    vec3 K_a = MatInfo[0];\n    vec3 K_d = MatInfo[1];\n    vec3 K_s = vec3(MatInfo[2].x);\n    float shininess = MatInfo[2].y;\n    \n    vec3 color = PhongIlluminationModel(K_a, K_d, K_s, shininess, pointPos, eye, background);\n    \n    \n    // ============================\n    fragColor = vec4(color, 1.);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hash33( vec3 p ) // from iq (https://www.shadertoy.com/view/XlXcW4)\n{\n    uint k = 1347475813U;\n    uvec3 x = uvec3(256.*(p+24.));\n    \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    vec3 n = vec3(x)*(1.0/float(0xffffffffU));\n    \n    return 2.*n-1.;\n}\n\n\nvec2 hash22( vec2 p )\n{\n    uint k = 1996240412U;\n    uvec3 x = uvec3(256.*(p+24.), 0.);\n    \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    vec3 n = vec3(x)*(1.0/float(0xffffffffU));\n    \n    return 2.*n.xy-1.;\n}\n\n\nfloat hash21 (vec2 p) \n{\n    uint k = 2023102624U;\n    uvec3 x = uvec3(256.*(p+24.), 0.);\n    \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    vec3 n = vec3(x)*(1.0/float(0xffffffffU));\n    \n    return fract(length(n));\n}\n\n\n\nvec3 pow3(vec3 v, float p)\n{\n    return pow(abs(v), vec3(p));\n}\n\n\n\n\n\nfloat noised( in vec3 x ) // from iq (https://www.shadertoy.com/view/4dffRH)\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    \n    // cubic interpolant\n    vec3 u = f*f*(3.0-2.0*f);\n    vec3 du = 6.0*f*(1.0-f);\n    \n    // gradients\n    vec3 ga = hash33( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash33( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash33( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash33( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash33( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash33( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash33( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash33( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, f-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, f-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, f-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, f-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, f-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, f-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, f-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, f-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}\n\n\n\n\n\n// ============================\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\n// ============================\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat SmoothUnionSDF( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n\n// ============================\nvec4 OpCircRepY(int nb_rep, float radius, vec3 pos)\n{\n    float an = 6.2831/float(nb_rep+(1-nb_rep%2));\n    \n    float fa = (atan(pos.x,pos.z) + an*0.5) / an;\n    float ia = floor( fa );\n    float sym = an*ia;\n    \n    vec3 r = rotateY(sym)*pos;\n    \n    vec3 p = (r - vec3(0., 0., radius));\n    \n    return vec4(p, sym);\n}\n\n\n\n// ============================\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, float ra, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra, abs(p.y + h) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) \n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\n\n// ============================\nvec3 fire(float t)\n{\n    return mix( mix(vec3(1,1,1), vec3(1,1,0), t),\n                mix(vec3(1,1,0), vec3(1,0,0), t*t), t);\n}\n\n\n\n\n// ============================\nvec2 SDFcake(vec3 pos, vec3 cake_pos, float cake_factor, int drop_rep_nb)\n{\n    \n    // base\n    float cake_radius = cake_factor;\n    float cake_round  = cake_factor * 0.24;\n    float cake_height = cake_factor * 0.8;\n    float noise = 0.06*clamp(abs(noised(6.2*pos)), 0., 0.2);\n    \n    float cake = sdRoundedCylinder(pos + cake_pos, cake_radius+noise, cake_round, cake_height);\n    \n    \n    // icing\n    vec3 icing_pos     = cake_pos - vec3(0., cake_height, 0.);\n    float icing_radius = cake_radius * 1.12;\n    float icing_round  = icing_radius * .2;\n    float icing_height = sqrt(cake_height) * .2;\n    \n    float top = sdRoundedCylinder(pos + icing_pos, icing_radius, icing_round, icing_height);\n    \n    \n    // icing drop\n    vec3 drop_pos         = icing_pos + vec3(0., 2.*icing_height, 0.); // position en hauteur des goutte\n    float drop_rep_radius = 1.8*icing_radius; // écart au centre du gateau\n    \n    vec4 position = OpCircRepY(drop_rep_nb, drop_rep_radius, pos + drop_pos); // répétition circulaire\n    \n    float drop_height = hash21(vec2(position.w+0.12, cake_pos.y)) *(cake_height-icing_height) ; // longeur des cylindre des goutte\n    float drop_width  = 0.5*(icing_radius - cake_radius); // rayon des cylindre des gouttes\n    float drop_bottom = 2.4*drop_width; // taille de la sphère en bas de la goutte\n    \n    float cyl = sdCylinder(position.xyz, drop_width, drop_height); // cylindre des gouttes\n    \n    position  = OpCircRepY(drop_rep_nb, drop_rep_radius + 0.3*drop_bottom, pos + drop_pos); // répétition circulaire\n    float sph = sdSphere(position.xyz + vec3(0., 2.1*drop_height, 0.), drop_bottom); // sphère en bas des goutte\n    \n    \n    float drop  = SmoothUnionSDF(cyl, sph, .2);\n    float icing = SmoothUnionSDF(drop, top, 6.*drop_width);\n\n\n    // union\n    float dist = cake;\n    float MatID = 0. + noise;\n    \n    if(icing < dist)\n    {\n        dist = icing;\n        MatID = 1. + 0.5*noise;\n    }\n    \n    return vec2(dist, MatID);\n}\n\n\nvec2 SDFcandle(vec3 pos, vec3 candle_pos)\n{\n    pos = pos + candle_pos;\n    \n    float candle_width = .1; \n    float candle_height = 10. * candle_width;\n    \n    float stick = sdCylinder(pos, candle_width, candle_height);\n    float melt = sdTorus(pos, vec2(1.8*candle_width, 0.25*candle_width))\n                        + .1*candle_width * sin(7.*atan(pos.x, pos.z)) - 0.01;\n    float wick = sdCylinder(pos - vec3(0., candle_width*2., 0.), .12*candle_width, 1.*candle_width);\n    \n    float dist = SmoothUnionSDF(unionSDF(stick, wick), melt, 0.08);\n    \n    // raignures colorées sur la bougie\n    float strength = 4.;\n    float c = cos(strength * pos.y);\n    float s = sin(strength * pos.y);\n    mat2 Rtwist = mat2(c, -s, s, c);\n    pos.xz = Rtwist * pos.xz;\n    \n    float raignure = 0.45*sin(8.*atan(pos.x, pos.z))+2.5;\n    \n    \n    return vec2(dist, raignure);\n}\n\n\nvec2 SDFafig(vec3 pos, vec3 afig_pos)\n{\n    vec3 Pos = vec3(pos.x, pos.z, pos.y) + afig_pos;\n    \n    float cyExt = sdCylinder(Pos, .8, .12);\n    float cyInt = sdCylinder(Pos-vec3(0., 0.5, 0.), 0.5, 1.);\n    float ring = differenceSDF(cyExt, cyInt); \n    \n    // cuts\n    float cutH = sdBox(Pos*rotateY(3.14/4.)+vec3(0., 0.5, 0.95), vec3(2.5, 1., 1.05)); \n    float cutB = sdBox(Pos*rotateY(3.14/4.)+vec3(0., 0.5, -0.95), vec3(2.5, 1., 1.05)); \n    float cutP = sdBox(Pos*rotateY(3.14/4.)+vec3(0., 0.5, -0.95), vec3(0.1, 1., 1.05)); \n    \n    float afigH = differenceSDF(ring, cutH);\n    float afigB = differenceSDF(ring, cutB);\n    afigH = differenceSDF(afigH, cutP);\n    \n    \n    // dots\n    float cercleG = sdCylinder(Pos-vec3(1., .0, -1.), 0.25, .12); \n    float cercleC = sdCylinder(Pos-vec3(1., .2, -1.), 0.29, .5); \n    float cercleP = sdCylinder(Pos-vec3(1.5, .0, -1.5), 0.08, .12); \n    \n    afigB = differenceSDF(afigB, cercleC);\n    afigB = unionSDF(afigB, cercleG);\n    afigB = unionSDF(afigB, cercleP);\n    \n    \n    float dist = afigH;\n    float MatId = 4.;\n    \n    if(afigB < dist)\n    {\n        dist = afigB;\n        MatId += 0.5;\n    }\n    \n   \n    return vec2(dist, MatId);\n}\n\n\nvec2 SDF30(vec3 pos, vec3 pos_30, float size30)\n{\n    vec3 Pos = vec3(pos.x, pos.z, pos.y) + pos_30;\n    \n    // 3\n    float cyExt = sdCylinder(Pos, size30, .12);\n    float cyInt = sdCylinder(Pos - vec3(0., 0.5, 0.), size30/2., 1.);\n    \n    float ringU = differenceSDF(cyExt, cyInt); \n    \n    cyExt = sdCylinder(Pos - vec3(0., 0., size30*3.), size30, .12);\n    cyInt = sdCylinder(Pos - vec3(0., .5, size30*3.), size30/2., 1.);\n    \n    float ringD = differenceSDF(cyExt, cyInt);\n    \n    \n    float eight = unionSDF(ringU, ringD);\n    float cut = sdBox(Pos - vec3(-1.5*size30, 0., size30*1.5), vec3(1.5*size30, .5, 1.5*size30));\n    \n    float three = differenceSDF(eight, cut);\n    \n    \n    // 0\n    Pos.z *= 3.*size30;\n    cyExt = sdCylinder(Pos - vec3(4.*size30, 0., 1.5*size30*(3.*size30)), size30, .12);\n    cyInt = sdCylinder(Pos - vec3(4.*size30, 0.5, 1.5*size30*(3.*size30)), size30/2., 1.);\n    \n    float zero = differenceSDF(cyExt, cyInt);\n    \n    \n    // 30\n    float dist = unionSDF(three, zero)-0.03;\n    \n    \n    return vec2(dist, 5.);\n}","name":"Common","description":"","type":"common"}]}