{"ver":"0.1","info":{"id":"NsXyz4","date":"1642166955","viewed":464,"name":"SDF PathTracer with TAA (WIP)","username":"drcd1","description":"A simple test, with exponential weighted samples and TAA. The \"SDF\" is also not really correct.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["sdf","pathtracer","taa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float toSRGB(float d){\n\tif(d <=  0.0031308\t)\n        return d*12.92;\n    else\n        return pow(d, (1.0/2.4))*1.055-0.055;\n}\n\n#define M_PI 3.14159\n\nvec3 convertToACES(vec3 x){\n\t\n\tx.x = toSRGB(x.x);\n\tx.y = toSRGB(x.y);\n\tx.z = toSRGB(x.z);\n/*\n\tx = ACESInputMat*x;\n\tvec3 a = x * (x + 0.0245786f) - 0.000090537f;\n    vec3 b = x * (0.983729f * x + 0.4329510f) + 0.238081f;\n\tx =  a / b;\n\t\n\tx = ACESOutputMat*x;\n*/\treturn clamp(x,0.0f,1.0f);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n\n    // Output to screen\n    fragColor = vec4(convertToACES(col.rgb/*/col.a*/),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float toSRGB(float d){\n\tif(d <=  0.0031308\t)\n        return d*12.92;\n    else\n        return pow(d, (1.0/2.4))*1.055-0.055;\n}\n\n#define M_PI 3.14159\n\nvec3 convertToACES(vec3 x){\n\t\n\tx.x = toSRGB(x.x);\n\tx.y = toSRGB(x.y);\n\tx.z = toSRGB(x.z);\n/*\n\tx = ACESInputMat*x;\n\tvec3 a = x * (x + 0.0245786f) - 0.000090537f;\n    vec3 b = x * (0.983729f * x + 0.4329510f) + 0.238081f;\n\tx =  a / b;\n\t\n\tx = ACESOutputMat*x;\n*/\treturn clamp(x,0.0f,1.0f);\n\n}\n\nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nint t = 2;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 fragPos;\n\nfloat getRandom(){\n\tt++;\n\treturn random(fragPos.xy + vec2(t,mod(float(iFrame),400.0)));\t\n}\n\nstruct Ray{\nvec3 o;\nvec3 d;\nfloat t;\n};\n\nRay create_ray(vec3 o, vec3 d){\n    Ray tmp;\n  tmp.o = o;\n  tmp.d = d;\n  tmp.t= 1000.0; \n  return tmp;\n}\n\n\nstruct Camera{\n    vec3 origin;\n    mat3 rotation;\n\n};\n\nCamera create_camera(vec3 origin, vec3 lookAt, vec3 up){\n    vec3 z = normalize(-lookAt);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = normalize(cross(z,x));\n    \n    Camera c;\n    c.origin = origin;\n    c.rotation = transpose(mat3(x.x,y.x,z.x,\n                      x.y,y.y,z.y,\n                      x.z,y.z,z.z));\n    return c;\n\n}\nmat4 get_camera_matrix(Camera c){\n\n        return mat4(vec4(c.rotation[0],0.0),\n                    vec4(c.rotation[1],0.0), \n                    vec4(c.rotation[2], 0.0),\n                    vec4(c.origin,1.0));\n}\n\nRay generate_ray(vec2 uv, Camera c){\n    vec3 direction = vec3(uv.x,uv.y,-1.0);\n    vec3 origin = c.origin;\n    direction = normalize(c.rotation*direction);\n    return create_ray(origin,direction);\n}\n\n\nfloat sphere_sdf(vec3 p, vec3 center, float radius){\n    p+=cos(p.yzx*3.0 + iTime*0.2)*0.6+vec3(0.0,0.0,0.4);\n    return (length(p-center)-radius)*0.5;\n}\n\nfloat plane_sdf(vec3 p, vec3 center, vec3 normal){\n    vec3 n = normalize(normal);\n    return dot(p-center,n);\n}\n\nfloat sdf_cube(vec3 p, vec3 origin, vec3 bounds){\n    vec3 o2 = origin+bounds;\n    return max(max(max(max(max(plane_sdf(p,origin,vec3(0.0,0.0,-1.0)),\n            plane_sdf(p,origin,vec3(0.0,-1.0,0.0))),\n            plane_sdf(p,origin,vec3(-1.0,0.0,0.0))),\n            plane_sdf(p,o2,vec3(0.0,0.0,1.0))),\n            plane_sdf(p,o2,vec3(0.0,1.0,0.0))),\n            plane_sdf(p,o2,vec3(1.0,0.0,0.0)));\n            \n}\n\n\nfloat sdf_sponge(vec3 p, vec3 origin, vec3 bounds){\n    p+=sin(p.yxz*10.0 + iTime)*0.1;\n    vec3 b2 = bounds/3.0;\n   \n    float dist = 1000.0;\n    //p.xy = mod(p.xy,bounds.xy);\n    /*\n    p.x+=cos(p.y)*0.2;\n    p.y+=cos(p.z)*0.3;\n    p.z+=cos(p.x)*0.4;\n    */\n    \n    for(int i = 0; i<3; i++){\n        for(int j = 0; j<3; j++){\n            for(int k = 0; k<3; k++){\n                if(! (i==1 && j==1 || i==1 && k== 1 || k==1 && j==1)){\n                    dist = min(dist, sdf_cube(p, origin+b2*vec3(i,j,k),b2));\n                }\n            }\n        }\n    }\n    return dist;\n}\n\n\nfloat sdf(vec3 p){\n    return min(min(sphere_sdf(p,vec3(0.0,0.0,1.0),1.0), \n            plane_sdf(p,vec3(0.0,0.0,0.0),vec3(0.0,0.0,1.0))),\n            sdf_sponge(p,vec3(-5.0,-5.0,-3.3),vec3(10.0)));\n    \n}\n\n\n\n#define EPS 0.001\n#define STEPS 100\nbool sphere_march(vec3 o, vec3 d, inout vec3 p){\n        p = o;float dist = 1000.0;\n        for(int i = 0; i<STEPS; i++){\n            dist= sdf(p);\n            p+=d*dist;\n            if(dist<EPS){\n                break;\n            }\n            \n            if(dist<0.01){\n                p+=d*0.01;\n            }\n        }\n        if(dist<EPS){\n            return true;\n        } else {\n            return false;\n        }\n}\n\nvec3 compute_gradient(vec3 p){\n    float a = sdf(p);\n    float b = sdf(p+vec3(EPS,0.0,0.0));\n    float c = sdf(p+vec3(0.0,EPS,0.0));\n    float d = sdf(p+vec3(0.0,0.0,EPS));\n    return normalize(vec3(b-a,c-a,d-a));\n}\n\nvec3 sky(vec3 d){\n    vec3 top = vec3(0.4,0.6,0.9);\n    vec3 bottom = vec3(1.0,1.0,1.0);\n    float t = clamp(d.z,0.0,1.0);\n    t= pow(t,0.5);\n    return top*(t) + bottom*(1.0-t);\n}\n\n\n\nvec3 cosine_hemisphere(float u1, float u2, vec3 normal){\n\tvec3 tan = ortho(normal);\n\tvec3 cotan = cross(normal, tan);\n\tmat3 m;\n\tm[0] = tan;\n\tm[1] = cotan;\n\tm[2] = normal;\n\t\n\t\n\tfloat r = sqrt(u1);\n\tfloat theta = M_PI*2.0f*u2;\n\t\n\tvec3 ret = vec3(r*cos(theta),r*sin(theta), sqrt(1.0f-u1));\n\treturn m*ret;\n\t\n}\n\nvec3 solid_angle(float u1, float u2, vec3 normal, float angle){\nvec3 tan = ortho(normal);\n\tvec3 cotan = cross(normal, tan);\n\tmat3 m;\n\tm[0] = tan;\n\tm[1] = cotan;\n\tm[2] = normal;\n\t\n\t\n\tfloat phi = angle*u1;\n\tfloat theta = M_PI*2.0f*u2;\n    return m*vec3(sin(phi)*cos(theta), sin(phi)*sin(theta), cos(phi));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord + 0.0*vec2(getRandom(),getRandom()))/iResolution.xy;\n    fragPos.xy = uv;\n    uv= uv*2.0-1.0;\n    uv = uv*0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    \n    \n    vec3 orig = vec3(sin(iTime*0.3)*8.0,cos(iTime*0.3)*8.0,2.0);\n    vec3 old_orig = vec3(sin((iTime-iTimeDelta)*0.3)*8.0,cos((iTime-iTimeDelta)*0.3)*8.0,2.0);    \n    vec3 at = normalize(vec3(0.0,0.0,1.0)-orig);\n    vec3 old_at = normalize(vec3(0.0,0.0,1.0)-old_orig);\n    Camera c = create_camera(orig,at, vec3(0.0,0.0,1.0));\n    \n    \n    Camera old_c = create_camera(old_orig,old_at, vec3(0.0,0.0,1.0));\n    Ray r = generate_ray(uv, c);\n    Ray orig_ray = r;\n    vec3 p;\n    vec3 col = vec3(0.0);\n       \n    vec3 ld = solid_angle(getRandom(),getRandom(), normalize(vec3(-10.0,3.0,3.0)),0.05);\n    \n    vec3 mul = vec3(1.0);\n    float dist_hit = 1000.0;\n    vec3 hp = r.o + r.d*1000.0;\n    for(int k = 0; k<3; k++){\n    \n        if(sphere_march(r.o,r.d,p)){\n            if(k == 0) {\n                dist_hit = length(r.o-p);\n                hp = p;\n            }\n            vec3 albedo = vec3(0.8);\n            vec3 n = compute_gradient(p);\n            if(dot(n,r.d)>0.0){\n                n = -n;\n            }\n            Ray shadow_ray = create_ray(p+(ld)*0.05,(ld));\n            vec3 p2;\n            if(!sphere_march(shadow_ray.o,shadow_ray.d,p2)){\n                col += mul*vec3(albedo*clamp(dot(n,ld),0.0,1.0))*vec3(1.0,0.9,0.7)*2.0;\n            }\n            r = create_ray(p+n*0.05,cosine_hemisphere(getRandom(),getRandom(),n));\n            mul = mul*albedo;\n            mul = mul/(M_PI);\n        } else {\n            col += mul*sky(r.d);\n            break;\n        }\n    }\n\n    vec3 prev_point = orig_ray.o + orig_ray.d*dist_hit;\n    \n    mat4 camera_mat = get_camera_matrix(old_c);\n    \n    vec4 helper_tmp = inverse(camera_mat)*vec4(prev_point,1.0);\n    helper_tmp.xyz /= helper_tmp.w;\n    float new_dist = length(helper_tmp.xyz);\n    vec2 uv_t = helper_tmp.xy/helper_tmp.z;\n    uv_t.x/= iResolution.x/iResolution.y;\n    uv_t = uv_t*2.0;\n    uv_t = uv_t*0.5 +0.5;\n    uv_t = 1.0-uv_t;\n    \n    \n    \n    // Output to screen\n    \n    vec4 help = texture(iChannel0, uv_t);\n    bool cond =  uv_t.x<0.0 || uv_t.y<0.0 || \n                uv_t.x>1.0 || uv_t.y >1.0 ||\n                abs(new_dist- help.a) > 0.5;\n        \n   \n    if(iFrame ==0  || ( cond) )\n        fragColor = vec4(col,dist_hit);\n    else\n        fragColor = vec4(col*0.1+help.rgb*0.9 + vec3(0.0,0.0,0.0)*0.1,dist_hit);\n        \n   // fragColor = vec4(fract(uv_t.xy*50.0),0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}