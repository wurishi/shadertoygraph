{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// created by Vinicius Graciano Santos vgs/2013\n// most methods are from iq's website (https://iquilezles.org/)\n// pendulum equation (http://en.wikipedia.org/wiki/Pendulum_(mathematics))\n\n#define EPS       0.01\n#define MAX_STEPS 64\n#define PI 3.14159265\n\nfloat plane(vec3 p, vec3 n) {\n\treturn dot(p, n)/length(n);\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat box(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ap = p - a, ab = b - a;\n\tfloat h = clamp(dot(ap, ab)/dot(ab,ab), 0.0, 1.0);\n\treturn length(ap - ab*h) - r;\n}\n\nfloat beam(vec3 p) {\n\tvec4 q = vec4(-1.0, 0.0, 1.0, -2.0);\n\tfloat d = capsule(p, q.xyy, q.zyy, 0.06);\n\td = min(d, capsule(p, q.xwy, q.xyy, 0.06));\n\treturn min(d, capsule(p, q.zwy, q.zyy, 0.06));\n}\n\nfloat pendulum(vec3 p, float l) {\n\tvec4 q = vec4(0.0, l, -l, 2.0*l);\n\tvec3 r = p + q.xwx, c = vec3(0.0, 0.15, 0.0);\n\tfloat d = min(sphere(r, 0.15), capsule(r, c, q.xwy, 0.008));\n\treturn min(d, capsule(r, c, q.xwz, 0.005));\n}\n\nfloat cradle(vec3 p) {\n\tvec3 q = vec3(-0.7, 0.0, 0.7);\n\t\n\tfloat theta = 0.15*PI*cos(sqrt(9.81/1.35)*iTime);\n\tfloat period = 2.0*PI*sqrt(1.35/9.81);\n\tfloat c = cos(theta), s = sin(theta);\n\t\n\tmat3 m0 = mat3(1.0);\n\tmat3 m1 = mat3(vec3(c,s,0.0), vec3(-s,c,0.0), vec3(0.0,0.0,1.0));\n\tfloat k = step(0.5*period, mod(iTime+0.25*period, period));\n\t\n\tfloat d = min(beam(p+q.yyx), beam(p+q.yyz));\n\td = min(d, pendulum(p, q.z));\n\td = min(d, pendulum(p+0.45*q.zyy, q.z));\n\td = min(d, pendulum(p-0.45*q.zyy, q.z));\n\td = min(d, pendulum((m0*k+m1*(1.0-k))*(p+0.90*q.zyy), q.z));\n\td = min(d, pendulum((m1*k+m0*(1.0-k))*(p-0.90*q.zyy), q.z));\n\treturn min(d, box(p+vec3(0.0,2.0,0.0), vec3(1.1, 0.02, 0.8), 0.05));\n}\n\nfloat dist_field(vec3 p) {\n\tvec3 q = p-vec3(0.0, 2.1, 0.0);\n\treturn min(cradle(q), plane(p, vec3(0.0,1.0,0.0)));\n}\n\nvec3 grad(vec3 p, float d) {\n\tvec2 q = vec2(EPS, 0.0);\n\treturn vec3(dist_field(p+q.xyy)-d, \n\t\t\t\tdist_field(p+q.yxy)-d,\n\t\t\t\tdist_field(p+q.yyx)-d);\n}\n\nfloat ambocc(vec3 p, vec3 n) {\n\tfloat ao = 0.0, aux = 0.5, dt = 0.5;\n\tfor (float i = 1.0; i <= 5.0; ++i) {\n\t\tao += aux * (i*dt - dist_field(p + i*dt*n));\n\t\taux *= 0.5;\n\t}\n\treturn clamp(1.0 - 0.8*ao, 0.0, 1.0);\n}\n\nvec4 raycast(vec3 ro, vec3 rd) {\n\tfloat d = 0.0, h = 0.0, maxd = 10.0;\n\tvec3 p = ro;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n\t\td = dist_field(p);\n\t\tif (d < EPS || h > maxd)\n\t\t\tbreak;\n\t\th += d; p += d * rd;\n\t}\n\t\n\treturn vec4(p, d);\n}\n\nvec3 shade(vec3 p, float d, vec3 rd) {\n\tvec3 gamma = vec3(2.2);\n\tvec3 col = pow(texture(iChannel2, rd).xyz, gamma);\n\t\n\tif (d < EPS) {\n\t\tvec3 mat = vec3(1.0);\n\t\t\n\t\tvec3 n = normalize(grad(p, d));\n\t\tvec3 ref = reflect(rd, n);\n\t\t\n\t\tcol = pow(texture(iChannel1, n).xyz, gamma);\n\t\tif (p.y < 0.01)\n\t\t\tmat = pow(texture(iChannel0, 0.1*p.xz).xyz, gamma);\n\t\telse if (p.y < 0.18)\n\t\t\tmat = vec3(0.025);\n\t\t\t\n\t\n\t\tfloat ao = ambocc(p, n);\n\t\tfloat rim = pow(clamp(1.0+dot(n, rd), 0.0, 1.0), 4.0);\n\t\tcol += 2.0*rim*pow(ao, 3.0);\n\t\tcol *= ao*mat;\n\t\t\n\t\tvec4 res = raycast(p+EPS*n, ref);\n\t\tif (res.w > EPS) {\n\t\t\trim = 0.3 + 0.7*pow(clamp(1.0+dot(n, rd), 0.0, 1.0), 8.0);\n\t\t\tcol += 2.0*rim*pow(ao, 3.0);\n\t\t\tcol *= pow(texture(iChannel2, ref).xyz, gamma);\n\t\t}\n\t}\n\treturn col;\n}\n\nmat3 lookAt(vec3 p, vec3 t) {\n\tvec3 f = normalize(p - t);\n\tvec3 r = cross(vec3(0.0,1.0,0.0), f);\n\treturn mat3(r, cross(f, r), f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0+2.0*fragCoord.xy/iResolution.xy;\n\tuv.y *= iResolution.y/iResolution.x;\n\t\n\tfloat alpha = iMouse.x/iResolution.x;\n\tfloat height = -1.0+2.0*iMouse.y/iResolution.y + 1.0;\n\tfloat stime = sin(PI*alpha+1.0+PI);\n\tfloat ctime = cos(PI*alpha+1.0+PI);\n\t\n\tvec3 ro = vec3(4.0*ctime, 3.0+height, 4.0*stime);\n\tvec3 rd = normalize(lookAt(ro, vec3(0.0,0.6,0.0))*vec3(uv, -1.0));\n\t\n\tvec4 res = raycast(ro, rd);\n\tvec3 col = shade(res.xyz, res.w, rd);\n\t\n\tfragColor = vec4(pow(col, vec3(1.0/2.2)),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xd23DR","date":"1386259600","viewed":1179,"name":"Newton's Cradle","username":"vgs","description":"Click and drag to rotate. This is my first try at modeling with distfields. As I'm new to raytracing, expect to find aliasing and non-optimized code. Thanks iq for all the material in your website (https://iquilezles.org/). I am learning so much! :D","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["distancefields","modeling","spheretracing"],"hasliked":0,"parentid":"","parentname":""}}