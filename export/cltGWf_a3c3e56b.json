{"ver":"0.1","info":{"id":"cltGWf","date":"1683247922","viewed":61,"name":"hark, what hath mandel brought?!","username":"jakecariello","description":"trying this one with no tutorials\n\nupdate: ok, getting better at this -- this is a super na√Øve approach though","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandlebrot","set","rawdogginit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float zoom = pow(FACTOR, (2. * (-cos(iTime * SPEED) + 1.) / 2.));\n    // [-.5, .5]\n    vec2 uv = zoom  * ((fragCoord - iResolution.xy / 2.) / min(iResolution.x, iResolution.y));\n\n    vec3 m = mandelbrot(uv - vec2(pow(3.1415926535, 1.) / 2., 0.));\n    complex z = m.xy;\n    \n    vec2 dz = abs(normalize(g(z, zoom)));\n    \n    vec3 col = vec3(dz.x, dz.y, -log(m.z / THRESH));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define FACTOR 1. / 1000.\n#define E 2.718281828459\n#define MAX_ITER 200\n#define THRESH 200.\n#define complex vec2\n#define SPEED 0.75\n\n// REMEMBER!! \"complex\" is just an alias for \"vec2\" here, so we need to use toExp() in order to multiply\n\nstruct complexExp {\n    float mag;\n    float phase;\n};\n\ncomplexExp toExp(complex r) {\n    float phase = atan(r.y, r.x);\n    float mag = length(r);\n    return complexExp(mag, phase); \n}\n\ncomplex toRect(complexExp e) {\n    float real = e.mag * cos(e.phase);\n    float imag = e.mag * sin(e.phase);\n    return complex(real, imag);\n}\n\ncomplexExp squared(complexExp c) {\n    c.mag *= c.mag;\n    c.phase += c.phase;\n    return c;\n}\n\n// essential iterator for mandelbrot set\ncomplex f(complex z, complex c) {\n    return toRect(squared(toExp(z))) + c;\n}\n\n// perform N mandelbrot iterations, return z magnitude\n// returns a vec3: (complex/vec2, iterations)\nvec3 mandelbrot(complex c) {\n    complex z = c;\n    int i = 0;\n    for (; i < MAX_ITER; i += 1) {\n        z = f(z, c);\n        if (length(z) > THRESH) return vec3(z, i);\n    }\n    return vec3(z, i);\n}\n\n// compute normalized gradient\nvec2 g(complex at, float zoom) {\n    float value = length(mandelbrot(at).xy); \n    complex d = complex(0., .00001 / (zoom));\n    float dImag = length(mandelbrot(at + d.xy).xy) - value;\n    float dReal = length(mandelbrot(at + d.yx).xy) - value;\n    return complex(dReal, dImag);  \n}","name":"Common","description":"","type":"common"}]}