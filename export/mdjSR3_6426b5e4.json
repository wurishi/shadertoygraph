{"ver":"0.1","info":{"id":"mdjSR3","date":"1670652601","viewed":207,"name":"dodecahedron edges sdf","username":"ENDESGA","description":"derived from: https://www.shadertoy.com/view/Mly3R3","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["sdf","wireframe","dodecahedron","dodeca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 R0 = mat3(0.5,-0.809016994375,0.309016994375,0.809016994375,0.309016994375,-0.5,0.309016994375,0.5,0.809016994375);\nmat3 R1 = mat3(0.809016994375,0.309016994375,-0.5,0.309016994375,0.5,0.809016994375,0.5,-0.809016994375,0.309016994375);\nmat3 R2 = mat3(-0.309016994375,-0.5,0.809016994375,0.5,-0.809016994375,-0.309016994375,0.809016994375,0.309016994375,0.5);\nmat3 R4 = mat3(0.587785252292,-0.809016994375,0.,-0.425325404176,-0.309016994375,0.850650808352,0.688190960236,0.5,0.525731112119);\nvec3 O4 = vec3(0.3902734644166273,0.2835502694506667,0.63147573033330584);\n\nfloat sdf_dodeca_edge(vec3 p,float r,float cr){\n    p = R4 * abs(R2 * abs(R1 * abs(R0 * abs(p)))) - O4 * r;\n    return length(vec3(p.x, max(p.y, 0.0), p.z)) - cr;\n}\n\nbool is_bg = false;\nfloat map(vec3 pos){\n    float d = sdf_dodeca_edge(pos - vec3(0.0), 3.0, .2);\n    if(d >= 0.01) is_bg = true; else is_bg = false;\n    return d;\n}\n\nfloat map_approx(vec3 pos) {\n    float d = length(pos) - 3.;\n    if(d >= 0.01) is_bg = true; else is_bg = false;\n    return d;\n}\n\nvec3 norm( vec3 pos )\n{    \n    const float eps = 0.001;\n    float dist = map( pos );\n    return normalize( vec3( dist - map( pos + vec3(eps,0,0) )\n                          , dist - map( pos + vec3(0,eps,0) )\n                          , dist - map( pos + vec3(0,0,eps) ) ) );\n}\n\nvec3 norm_approx( vec3 pos )\n{    \n    const float eps = 0.001;\n    float dist = map_approx( pos );\n    return normalize( vec3( dist - map_approx( pos + vec3(eps,0,0) )\n                          , dist - map_approx( pos + vec3(0,eps,0) )\n                          , dist - map_approx( pos + vec3(0,0,eps) ) ) );\n}\n\nvec3 rotx(vec3 p,float a){\n    return vec3(p.x, p.y * cos(a) + p.z * sin(a), p.y * -sin(a) + p.z * cos(a));\n}\n\nvec3 roty(vec3 p,float a){\n    return vec3(p.x * cos(a) + p.z * sin(a), p.y, p.x * -sin(a) + p.z * cos(a));\n}\n\nvoid mainImage(out vec4 c, in vec2 fc){\n    vec2 sp=(fc * 2. - iResolution.xy) / iResolution.y;\n    vec3 r=normalize(vec3(sp, 1.5));\n    vec3 p=vec3(0, 0, -6.);\n\n    float t = sin(iTime) * 0.777;\n    p = roty(rotx(p, t), iTime * 2.);\n    r = roty(rotx(r, t), iTime * 2.);\n\n    float approx_d = map_approx(p), d = 0.;\n\n    for(int i=0; i<100; i++){\n        if (approx_d <= 0.01) {\n            d = map(p);\n        } else {\n            d = approx_d;\n        }\n\n        p += r * d;\n        if (d <= .01 || d > 100.) break;\n        approx_d = map_approx(p);\n    }\n\n    vec3 n = 1. - exp(-(norm(p) + norm_approx(p)) * .5);\n    c = vec4(n * 0.5 + 0.5, 1.0);\n    if(is_bg) c *= .25;\n    c = 1.-exp(-c * c * 4.);\n}","name":"Image","description":"","type":"image"}]}