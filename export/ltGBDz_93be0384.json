{"ver":"0.1","info":{"id":"ltGBDz","date":"1542261528","viewed":127,"name":"Taft Architecture Shader","username":"tiff","description":"Taft Architecture - https://drive.google.com/file/d/1Ynzt-e4LPH6xQOMK2-_X3P4IA2mp18Th/view?usp=sharing\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ttaf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\nconst float EPSILON = 0.001;\nconst vec3 deltax = vec3(EPSILON, 0., 0.);\nconst vec3 deltay = vec3(0., EPSILON, 0.);\nconst vec3 deltaz = vec3(0., 0., EPSILON);\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n//cone\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0.)));\n\t}\n\treturn d;\n}\n\n//pole\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\n//=======================\n\nShape Building(vec3 c){\n  Shape shape;\n  vec4 color = vec4(1., 1., 1., 1.); //white\n  vec4 black = vec4(-.5, -.5, -.5, 2.); //black\n    \n  vec3 w = c;\n  vec3 ar = c;//arch plane\n  ar.x = abs(ar.x); \n\n  vec3 g = c;//grass plane\n\n  c.x = abs(c.x)-0.5; //Mirror\n\n  vec3 d = c;//door plane\n  vec3 r = c;//rail plane\n  vec3 s = c;//stairs plane\n  vec3 l = c;//light plane\n  vec3 op = c; //outpole plane\n    \n  //Brick Wall\n  w.x = repeat(w.x, .45);\n  w.y = repeat(w.y,.5);\n  w.x = abs(w.x);\n  w.y = abs(w.y);\n       \n  float brick1 = fBox(w- vec3(0., 0., 0.), vec3(.21, .11, .2)); //brick\n  vec4 brickC1 = vec4(.65, .1, .1, 1.);\n  \n  float brick2 = fBox(w- vec3(.22, .25, 0.), vec3(.21, .11, .2)); //brick\n  vec4 brickC2 = vec4(.8, .1, .1, 1.);\n\n  \n  //door structure\n  float box = fBox(d- vec3(-.2, 0., -0.035), vec3(.55, .75, .4)); //otusidebox\n  float door = fBox(d- vec3(-.22, -0.15, -0.07), vec3(.25, .55, .4)); // door\n  float beam1 = fBox(d- vec3(-.5, -0., -0.12), vec3(.055, .75, .4)); // middle beam\n  float beam2 = fBox(d- vec3(0., -0., -0.12), vec3(.03, .75, .4)); // beam next to door  \n  float beam3 = fBox(d- vec3(0.3, -0., -0.12), vec3(.03, .75, .4)); // outside beam\n  float beam4 = fBox(d- vec3(-0.1, -0.72, -0.12), vec3(.4, .03, .4)); // bottom beam   \n  float beam5 = fBox(d- vec3(-0.1, 0.72, -0.12), vec3(.4, .03, .4)); // top beam \n  float beam6 = fBox(d- vec3(-0.1, 0.39, -0.12), vec3(.4, .03, .4)); // 2nd top beam \n  float beam7 = fBox(d- vec3(-0.1, -0.39, -0.12), vec3(.4, .03, .4)); // 2nd bottom beam \n  float beam8 = fBox(d- vec3(-0.1, -0.15, -0.12), vec3(.4, .03, .4)); // 3rd bottom beam \n  float beam9 = fBox(d- vec3(-0.1, 0.15, -0.12), vec3(.4, .03, .4)); // 3rd top beam \n  vec4 doorInsideC = vec4(2.5, 2.6, 2.9, 1.);\n    \n  float bdbackwall = fBox(d- vec3(-.2, 0.07,0.), vec3(.75, .85, .4)); // door backwall\n    \n  ar.xy *= rot(ar.x*radians(-12.));  \n  float topdbackwall = fBox(ar- vec3(0.10, 1., 0.), vec3(.73, .1, .4)); // door backwall\n  float dbackwall = min(bdbackwall, topdbackwall);\n \n  vec4 wallC = vec4(1.4, 1.3, 1.15, 1.);\n   \n  float across = fBox(d- vec3(2.5, 0.15, 0.), vec3(1.75, .15, .3)); // 3rd top beam \n\n    \n  //outer column\n  float column = fBox(d- vec3(.7, 0.2, -0.2), vec3(.1, 1., .35)); //column\n  float outarch = fBox(ar- vec3(0.1, 1.3, -0.2), vec3(.78, .13, .35));//outer arch\n  float outerWall = fOpUnionRound(column, outarch, 0.0);\n    \n  // Rail\n  float pole = fCylinder(r- vec3(.6, -.5, -.9), .02, .4); //pole\n  float hpole = fBox(r- vec3(1.9, -.1, -.9), vec3(1.31, .02, .02)); //horizontal pole\n   \n  op = op-1.13;\n  op.y = op.y+1.7;\n  op.z = op.z+.5;\n  op.yz *= rot(op.x*radians(-30.));  \n  float outpole = fBox(op- vec3(1., -.3, -2.2), vec3(1.7, .03, .03)); //out pole\n  \n  float poles = fOpUnionRound(pole, hpole, .03);\n\n  vec4 poleC = vec4(0., 0., 0., 1.);\n    \n  // ground + stairs\n  float floor = fBox(s- vec3(-.2, -.8, 1.), vec3(4., .05, 2.)); // floor\n  vec4 floorC = vec4(1., .5, .5, 1.);  \n    \n  float stair1 = fBox(s- vec3(-.2, -.85, 0.), vec3(.85, .1, 1.2)); // top stair\n  float stair2 = fBox(s- vec3(-.2, -1.05, 0.), vec3(1., .1, 1.5)); // 2nd stair\n  float stair3 = fBox(s- vec3(-.2, -1.25, 0.), vec3(1.15, .1, 1.8)); // 3rd stair\n\n  float stairs = min(stair1, stair2);\n  stairs = min(stairs, stair3);\n    \n  // light\n  float topRing = fCylinder(r- vec3(1.2, 1., -.5), .14, .03); //top ring light\n  float light = fCylinder(r- vec3(1.2, .8, -.5), .12, .2); //actual light\n  float bottomRing = fCylinder(r- vec3(1.2, .6, -.5), .14, .03); //bottom ring light\n  vec4 lightC = vec4(2.2, 2.2, 1.3, 1.);\n   \n  // Grass\n  g.x = abs(g.x)*1.5;\n  g.x = repeat(g.x,.1);\n  \n  float grass1 = fCone(g- vec3(.03, -1.25, -1.05), .05, .5); // 1st row\n  float grass2 = fCone(g- vec3(.06, -1.4, -1.1), .05, .5); // 2nd \n  float grass3 = fCone(g- vec3(.03, -1.55, -1.25), .05, .5); // 2nd \n  float grass4 = fCone(g- vec3(.06, -1.65, -1.35), .05, .5); // 2nd \n\n  float grass = min(grass1, grass2);\n  grass = min(grass, grass3);\n  grass = min(grass, grass4);\n    \n  vec4 grassC = vec4(.7, 1., .6, 1.);\n\n  // draw/add shapes to screen\n  shape.dist = fOpUnionStairs(box, door, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, beam1, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, beam2, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, beam3, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, beam4, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, beam5, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, beam6, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, beam7, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, beam8, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, beam9, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, dbackwall, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, across, 1., 1.);  \n    \n  shape.dist = fOpUnionStairs(shape.dist, floor, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, stairs, 1., 1.);\n      \n  shape.dist = fOpUnionStairs(shape.dist, poles, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, outpole, 1., 1.);\n    \n  shape.dist = fOpUnionStairs(shape.dist, brick1, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, brick2, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, outerWall, 1., 1.);\n    \n  shape.dist = fOpUnionStairs(shape.dist, topRing, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, light, 1., 1.);\n  shape.dist = fOpUnionStairs(shape.dist, bottomRing, 1., 1.);\n    \n  shape.dist = fOpUnionStairs(shape.dist, grass, 1., 1.);\n\n   \n  shape.color = mix(color, color, mixColors(door, stairs, 0.2));\n  shape.color = mix(shape.color, floorC, mixColors(floor, shape.dist, .01));\n  shape.color = mix(shape.color, brickC1, mixColors(brick1, shape.dist, .01));\n  shape.color = mix(shape.color, brickC2, mixColors(brick2, shape.dist, .01));\n  shape.color = mix(shape.color, grassC, mixColors(grass, shape.dist, .01));\n  shape.color = mix(shape.color, black, mixColors(poles, shape.dist, .002));\n  shape.color = mix(shape.color, black, mixColors(outpole, shape.dist, .002));\n  shape.color = mix(shape.color, color, mixColors(topRing, shape.dist, .01));\n  shape.color = mix(shape.color, color, mixColors(bottomRing, shape.dist, .01));\n  shape.color = mix(shape.color, lightC, mixColors(light, shape.dist, .01));\n  shape.color = mix(shape.color, doorInsideC, mixColors(door, shape.dist, .01));\n  shape.color = mix(shape.color, doorInsideC, mixColors(box, shape.dist, .01));\n  shape.color = mix(shape.color, wallC, mixColors(dbackwall, shape.dist, .01));\n  shape.color = mix(shape.color, wallC, mixColors(outerWall, shape.dist, .01));\n  shape.color = mix(shape.color, wallC, mixColors(across, shape.dist, .01));\n\n  //shape.color = color;\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape taft = Building(c);\n  return taft;\n}\n\nfloat mapDist(vec3 c){\n  Shape taft = Building(c);\n  return taft.dist;\n}\n\nvec4 mapColor(vec3 c){\n  Shape taft = Building(c);\n  return taft.color;\n}\n\n//============================== Lighting ===================================\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n  float farPlane = 1000.;\n    for (int i = 0; i < 64; ++i) {\n        float dist = mapDist(origin + r * t);\n        if(dist < EPSILON || t > farPlane) {\n          break;\n      }\n        t += dist;\n    }\n    return t;\n}\n// Function calculates the normals for a given point\n// Finds the nearest surface vector in x, y, and z\nvec3 computeSurfaceNormal(vec3 p){\n    float d = mapDist(p);\n    return normalize(vec3(\n            mapDist(vec3(p.x + EPSILON, p.y, p.z)) - d ,\n            mapDist(vec3(p.x, p.y + EPSILON, p.z)) - d ,\n            mapDist(vec3(p.x, p.y, p.z + EPSILON)) - d\n            ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l) {\n\n    return vec3(dot(normalize(l-p), n));\n}\n\n\n// Compute an ambient occlusion factor\n// p: point on surface\n// n: normal of the surface at p\n// returns: a value clamped to [0, 1], where 0 means there were no other surfaces around the point,\n// and 1 means that the point is occluded by other surfaces.\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n  float stepSize = 0.001;\n  float t = stepSize;\n  float oc = 0.0;\n  for(int i = 0; i < 10; ++i)\n  {\n    float d = mapDist(p + n * t);\n    oc += t - d; // Actual distance to surface - distance field value\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.);\n}\n//left light\nvec3 computeColor(vec3 origin, vec3 ray){\n  \n  float t = trace(origin, ray); \n  vec3 p = origin + ray * t; \n  float d = mapDist(p); \n  vec3 normal = computeSurfaceNormal(p);\n\n  vec3 light = vec3(1.75, 0.75,-.85);\n  vec3 mat = computeLambert(p, normal, light);\n  float ao = ambientOcclusion(p, normal);\n  mat = mat * (1.0 - ao);\n\n  return mat;\n}\n//right light\nvec3 computeColor2(vec3 origin, vec3 ray){\n  \n  float t = trace(origin, ray); \n  vec3 p = origin + ray * t; \n  float d = mapDist(p); \n  vec3 normal = computeSurfaceNormal(p);\n\n  vec3 light = vec3(-1.75, 0.75,-.85);\n  vec3 mat = computeLambert(p, normal, light);\n  float ao = ambientOcclusion(p, normal);\n  mat = mat * (1. - ao);\n\n  return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 cam = vec3(0., .3, -5.);\n\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n    \n  vec3 fc = computeColor(cam, f);\n  fc += computeColor2(cam, f);\n  fc *= vec3(mapColor(fc));\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      fragColor *= vec4(vec3(fc), 1.);\n      break;\n    }\n    scene += f * c.dist;\n  }\n\n}\n","name":"Image","description":"","type":"image"}]}