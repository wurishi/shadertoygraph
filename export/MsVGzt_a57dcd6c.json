{"ver":"0.1","info":{"id":"MsVGzt","date":"1456004487","viewed":465,"name":"Emissive light test","username":"dine909","description":"Trying out ideas for handling material's reflectiveness and emissivity.<br/>#defines to tweak performance and enviro.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["3d","shadow","light","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Check 'Buf A' for main shader.\n\n\n// FXAA from https://github.com/mattdesl/glsl-fxaa\n\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     2.5\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n          vec2 v_rgbNW, vec2 v_rgbNE, \n          vec2 v_rgbSW, vec2 v_rgbSE, \n          vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture(tex, v_rgbSE).xyz;\n    vec4 texColor = texture(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n    vec3 rgbA = 0.5 * (\n        texture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mediump vec2 v_rgbNW;\n    mediump vec2 v_rgbNE;\n    mediump vec2 v_rgbSW;\n    mediump vec2 v_rgbSE;\n    mediump vec2 v_rgbM;\n    texcoords(fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n    fragColor = fxaa( iChannel0, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);   \n//    fragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).xyz,1.);   \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SHADERTOY\n#ifndef SHADERTOY\nprecision highp float;\n#define iResolution resolution\n#define iTime time\n#define iMouse mouse\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n#endif\n\n//----8<----- SETTINGS ----8<-----//\n\n//#define LIGHT_AMOUNT .7\n//#define ANIMATE_TABLET // <<-- I get corruption with this enabled - hmm.\n#define AUTO_CAMERA\n#define MAX_REFLECT_BOUNCES 3\n#define ENABLE_SHADOWS\n#define ENABLE_FOG\n#define ENABLE_AO\n//#define SCREEN_POWER 1\n\n//----8<----- /SETTINGS ----8<----//\n\n\n#ifndef SCREEN_POWER\n#define SCREEN_POWER (iTime>4.8?1:0)\n#endif\n#ifndef LIGHT_AMOUNT\n#define LIGHT_AMOUNT (.2 + 0.5+0.5*sin(0.5+0.5*cos(iTime*0.5)*PI))\n#endif\n\n#define hz1 (.5+0.5*sin(iTime))\n#define SSW mod(iTime*0.5,1.)>0.5?1.:0.\n\nfloat remap(float value, float low1,float high1, float low2,float high2,bool c){float r=low2 + (value - low1) * (high2 - low2) / (high1 - low1);return c?clamp(r,min(low2,high2),max(low2,high2)):r;}\nfloat remap(float value, float low2,float high2,bool c){return remap(value,0.,1.,low2,high2,c);}\nfloat antiAlias(float x) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.0);}\nfloat blur(float x) {return pow(smoothstep(.945,1.0,x),10.);}\n\n#define PI 3.14159265359\n\nconst float KEY_A = 65.5/256.0;\nconst float KEY_B = 66.5/256.0;\n\n//float srat=iResolution.y/iResolution.x;\n\nfloat rand (in vec2 seed) {\n    seed = fract (seed * vec2 (5.3983, 5.4427));\n    seed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n    return fract (seed.x * seed.y * 95.4337);\n}\n\nfloat isKeyPressed(float key)\n{\n    #ifndef SHADERTOY\n    return 0.;\n    #else\n    return texture( iChannel0, vec2(key, 3.5) ).x;\n    #endif\n}\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat sdPlane( vec3 p ){ return p.y;}\nfloat udBox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\nfloat sdBox( vec3 p, vec3 b ){ vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));}\nfloat sdSphere( vec3 p, float s ){ return length(p)-s;}\n\nstruct Reflectivity{ float amount; float chromacity;}T_Reflectivity;\nstruct SDPrim{ int type; vec3 tra,rot,siz; float sca; vec3 utp;}T_SDPrim;\nstruct Material{ int type; vec3 col; Reflectivity ref; float trans; float emis;}T_Material;\nstruct SDObject{ SDPrim def; Material mat; float d,t; vec3 mpos,nor;}T_SDObject;\nstruct Ray{vec3 ro,rd;float tmin ,tmax;float a;}T_Ray;\n\nRay newRay(vec3 ro,vec3 rd){float tmin = .10;float tmax = 20.0;return Ray(ro,rd,tmin,tmax,0.);}\nconst SDObject NoSDObject = SDObject(SDPrim(0,vec3(0.),vec3(0.),vec3(1.),(1.),vec3(0.)),Material(0,vec3(.0),Reflectivity(0.,0.),0.,0.),-1.,0.,vec3(0.),vec3(0.));\nSDObject newSDObject(Material mat, SDPrim sdo){ return SDObject(sdo,mat,0.,0.,vec3(0.),vec3(0.));}\nSDObject SDUnion(SDObject oa ,SDObject ob){ if(oa.d<ob.d ) return oa; else return ob;}\n\nvoid rotp(inout vec3 rp,vec3 r)\n{\n    mat2 mx=mm2(r.x);\n    mat2 my=mm2(r.y);\n    mat2 mz=mm2(r.z);\n    rp.xy*=mz;\n    rp.xz*=my;\n    rp.zy*=mx;\n\n}\nvoid transform(inout vec3 rp,in SDPrim d)\n{\n\n    // rotp(rp,d.rot);\n    rotp(rp,d.rot);\n    rp-=d.tra;\n    rp/=(d.sca);\t\t\t\n}\n\n\nSDObject SDOMap(in SDObject o,vec3 p)\n{\n    // o.ray=ray;\n    // o.ray.ro+=o.pos;\n    //o.d=iSphere(o.ray.ro,o.ray.rd);\n    SDPrim d=o.def;\n\n    o.mpos=p;\n    vec3 rp=p;\n    transform(rp,d);\n    o.def.utp=rp;\n\n\n    if(d.type==1) o.d=sdPlane(rp);\n    if(d.type==2) o.d=sdSphere(rp,1.);\n    if(d.type==3) o.d=udBox(rp,d.siz);\n\n    o.d*=d.sca;\n    return o;\n}\nSDObject mapTablet(vec3 p,vec3 pos,vec3 ori,float tanim)\n{\n\n    SDObject body=newSDObject(Material(3,vec3(.04),Reflectivity(.60,0.45),0.,0.),\n                              SDPrim(3,vec3((1.-tanim)*-1.,.5,-1.)+pos-(1.-tanim)*2.,ori,vec3(1.6,.1,.9),(1.),vec3(0.)));\n\n    SDObject screen=newSDObject(Material(2,vec3(0.),Reflectivity(.60,0.95),0.,.94),\n                                SDPrim(3,vec3((1.-tanim)*-1.,.551,-1.)+pos+(1.-tanim),ori,vec3(1.6*0.9,.05,.9*0.85),(1.),vec3(0.)));\n\n    SDObject led=newSDObject(Material(3,SCREEN_POWER==1?vec3(0.1,0.1,2.2):vec3(0.2),Reflectivity(.0,0.05),0.,.94*float(SCREEN_POWER)),\n                             SDPrim(3,vec3(0.,.551,-1.+.9*0.92)+pos,ori,vec3(0.1,.05,0.025),(1.),vec3(0.)));\n\n    SDObject res= SDOMap(body,p);\n    res= SDUnion(res,SDOMap(screen,p));\n    res= SDUnion(res,SDOMap(led,p));\n    return res;\n}\nSDObject mapScene(vec3 p)\n{\n    vec3 testcol=vec3(1.,0.5,0.25);\n    SDObject gr=newSDObject(Material(1,testcol.bbg,Reflectivity(.001,0.5),0.,0.),SDPrim(1,vec3(0.,0.,0.),vec3(0.),vec3(1.),1.,vec3(0.)));\n    SDObject cu2=newSDObject(Material(3,testcol.gbb,Reflectivity(.70,.50),0.,0.),SDPrim(3, vec3(1.5,1.,2.6), vec3(0.,0.2,0.), vec3(1.), (1.),vec3(0.)));\n    SDObject cu=newSDObject(Material(3,testcol.bgb,Reflectivity(.70,.50),0.,0.),SDPrim(2,vec3(-2.,1.,2.6),vec3(0.,0.,0.),vec3(1.),(1.),vec3(0.)));\n\n\n    #ifdef ANIMATE_TABLET\n    float tanim=0.5-0.5*cos(remap(iTime,0.,1.,0.,1.,true)*PI);\n    #else\n    #define tanim 1.\n    #endif\n    SDObject tablet=mapTablet(p,\n                              mix(vec3(0.,1.,-1.),vec3(0.),tanim),\n                              mix(vec3(1.4,1.4*-2.,0),vec3(1.4,0.,0.),tanim),tanim);\n\n    SDObject res= SDOMap(gr,p);\n    res= SDUnion(res,SDOMap(tablet,p));\t\n    res= SDUnion(res,SDOMap(cu2,p));\n    res= SDUnion(res,SDOMap(cu,p));\n\n    return res;\n}\nSDObject render(in vec3 bcol,out vec3 ocol, Ray ray);\nSDObject castRay( in Ray ray )\n{\n    float precis =0.00001;//(state.y+1.<iTime)?0.0001:0.003;\n    float t = ray.tmin;\n    SDObject res;\n    vec3 p;\n    for( int i=0; i<200; i++ )\n    {\n        p=ray.ro+ray.rd*t;\n        res = mapScene( p );\n        if( res.d<precis || t>ray.tmax ) break;\n        t += res.d;\n    }\n    res.t=t;\n    if( t>ray.tmax ) return NoSDObject;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.004, 0.0, 0.0 );\n    vec3 nor = vec3(\n        mapScene(pos+eps.xyy).d - mapScene(pos-eps.xyy).d,\n        mapScene(pos+eps.yxy).d - mapScene(pos-eps.yxy).d,\n        mapScene(pos+eps.yyx).d - mapScene(pos-eps.yyx).d );\n    return normalize(nor);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    #ifndef ENABLE_AO\n    return 1.;\n    #endif\n\n    float occ = 0.20;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = mapScene( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ); \n}\nvec2 softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    vec2 res = vec2(1.,1.);\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        SDObject hit=mapScene( ro + rd*t );\n        float h = hit.d;\n        if(hit.mat.type>=0 && hit.mat.trans>0.)\n        {\n            res.y=min(res.y,hit.mat.trans);\n        }\n        res.x = min( res.x, (32.0*h/t) );\n        t += clamp( h, 0.00001, 0.99999 );\n        if( h<(0.00001) || t>tmax ) break;\n    }\n    return clamp( res,1.2-res.y, 1.0 );\n\n}\n\nvec3 render(vec3 incol,vec3 col,float d)\n{\n    float aares=smoothstep(((d)), .9740, .0);\n    return clamp(mix(incol,col,aares),0.,1.);\n}\n\n#define LINE(a,b) line(p,a,b)\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n\n    return (1.0 - d);\n}\n\n#define IFSi(_E,_V) (1.-abs(sign(float(_E-_V))))\n#define IFS(_E,_V) (1.-abs(sign((_E-_V))))\n\nvec3 hitColor(inout SDObject hit)\n{\n    Material m=hit.mat;\n    vec3 col=hit.mat.col;\n\n    {\n        #define SQSIZE 10.\n        vec2 texm=hit.mpos.zx*.2;\n        float f = mod( floor((5./SQSIZE)*(hit.mpos.z)) + floor((5./SQSIZE)*(hit.mpos.x)), 2.);\n        col += IFSi(m.type,1) * (0.4 + 0.1*f*vec3(1.0));\n    }\n    {\n        //video texture\n        vec2 ssres=hit.def.siz.xz;\n        vec2 texm=hit.def.utp.xz;\n        texm/=ssres;\n        texm/=2.;\n        texm.y=-texm.y;\n        texm+= .5;\n        #define fringe 0.015\n        col+=float(SCREEN_POWER)*IFSi(m.type,2)*clamp( texture(iChannel1,texm,0.).rgb ,0.,1.)\n            *smoothstep(0.0,fringe,texm.x)\n            *smoothstep(0.0,fringe,texm.y)\n            *smoothstep(1.,1.-fringe,texm.x)\n            *smoothstep(1.,1.-fringe,texm.y);\n    }\n    return col;\n}\n\nSDObject render(in vec3 bcol,out vec3 ocol, Ray ray)\n{\n    SDObject hit=castRay(ray);\n    vec3 col=ocol;\n\n    float tamnt=LIGHT_AMOUNT;\n    if (hit.mat.type >0)\n    {\n\n        Material m=hit.mat;\n        col=hitColor(hit);\n\n        vec3 nor = calcNormal( hit.mpos );\n        vec3 ref = reflect( ray.rd, nor );\n\n        hit.nor=nor;\n\n        float occ = calcAO( hit.mpos, nor );\n        vec3 lig = normalize( vec3(-0.0, 1., 1.) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig )*tamnt, m.emis, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-hit.mpos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y )*m.ref.amount;\n        float fre = pow( clamp(1.0+dot(nor,ray.rd),0.0,1.0), 2.0 )*m.ref.amount;\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0)*m.ref.amount;\n\n        //\tif (hit.mat.m >0)\n        // col+=rfm;\n        // shadows\n        vec3 lin = vec3(0.0);\n        #ifdef ENABLE_SHADOWS\n        {\n            vec2 difss=softshadow( hit.mpos, lig, 0.02, 2.5 );\n            dif *= mix(1.,difss.x,1.-m.emis);\n            vec2 domss=softshadow( hit.mpos, ref, 0.02, 2.5 );\n            dom *= domss.x;\n            // dom*=1.-domss.y;//1.-difss.y;\n        } \n        #endif\n        lin += 1.20*dif*mix(vec3(1.00,1.,0.75),vec3(1.),m.emis);\n        lin += 1.20*spe*vec3(1.00,1.,0.75)*dif;\n        lin += 0.20*amb*vec3(0.50,.70,1.00)*occ;\n        // lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n        // col*=1.+0.3*m.emis;\n        col = col*lin;\n\n        #ifdef ENABLE_FOG\n        col = mix( col, vec3(0.8,0.9,1.0)*0.3*tamnt, (0.9)-exp( -0.002*hit.t*hit.t ) );\n        #endif\n\n        ocol=mix(col,ocol,ray.a);\n    }else{\n        ocol=\tmix(bcol*tamnt,col,ray.a);\n\n    }\n    return hit;\n}\nRay getCamera(vec2 p,vec2 um)\n{\n    #ifdef AUTO_CAMERA\n    if(iMouse.z<0.5)\n    {\n        um=0.5+0.4*vec2(-1.25-0.5*sin(-2.8+iTime*0.6),cos(-1.18+iTime*0.3));\n    }\n    #endif\n    vec2 cr=um;\n    cr.x=cr.x+.45;\n    float flip=0.5-0.5*cos(remap(cr.y,0.3,0.7,0.,1.,true)*PI);\n\n\n    //camera\n    #define CENTER_CAM vec3(0.,1.95,2.45)\n    vec3 cam=vec3(0.,0.4*(1.-2.*flip),3.2);\n    vec3 ro = cam*2.5;//vec3(0.,.95,.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rdc= normalize(vec3(p ,-1.5));\n\n    mat2 mx = mm2(flip*\tPI); \n    mat2 mz = mm2(PI*2.*(-cr.x*(iResolution.y/iResolution.x))-PI*0.5);\n    mat2 my = mm2(PI*cr.y); \n\n    rd.xy*=mx;\n\n    ro.zy *= my;rd.zy *= my;\n    ro.zx *= mz;rd.zx *= mz;\n\n    rdc.zy*=my;\n    rdc.zx*=mz;\n\n    return newRay(ro,rd);\n\n}\nvec3 globalImage( in vec2 fragCoord )\n{\t\n    float srat=iResolution.y/iResolution.x;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 um = iMouse.xy / iResolution.xy;\n    um.x /= srat; p.x/=srat;\n\n    Ray ray=getCamera(p,um);\n\n    vec3 ocol,col=vec3(0.);\n    #define BACKGROUND ((vec3(0.1, 0.2, .30)+ray.rd.y*-0.8)*LIGHT_AMOUNT)    \n    vec3 bcol = BACKGROUND ;\n\n    SDObject o=render(bcol,col,ray);\n    ocol=col;\n    float refval=.70 ;//.25;\n    vec3 rcol=vec3(1.,1.,1.);\n    #ifdef MAX_REFLECT_BOUNCES\n    for(int i=0;i<MAX_REFLECT_BOUNCES;i++)\n    {\n        float cref=o.mat.ref.amount;\n        rcol*=mix(vec3(1.),o.mat.col*cref,o.mat.ref.chromacity);\n        if(cref==0.) break;\n        refval*=cref+0.12;\n        col=vec3(0.);\n        ray=newRay(o.mpos,reflect(ray.rd,o.nor*(1.+0.03*(1.-smoothstep(0.,.7,o.mat.ref.amount))*rand(o.mpos.xy*1000.))));\n        o=render(BACKGROUND,col,ray);\n\n        ocol+=clamp(((col/float(i+1))*(refval*(1.+.35*o.mat.emis)))*rcol,0.,1.);\n    }\n    #endif\n\n    return ocol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(globalImage(fragCoord),1.);\n}\n\n\n#ifndef SHADERTOY\nvoid main(){mainImage(gl_FragColor,gl_FragCoord.xy);}\n#endif\n","name":"Buf A","description":"","type":"buffer"}]}