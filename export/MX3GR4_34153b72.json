{"ver":"0.1","info":{"id":"MX3GR4","date":"1716145268","viewed":142,"name":"Liquid Portal","username":"iekdosha","description":"Cool liquid portal effect","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","water","caustic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Creid for noise functions: by @XorDev\n    https://mini.gmshaders.com/p/gm-shaders-mini-noise-1437243\n    \n    Based on this youtube tutorial:\n    https://www.youtube.com/watch?v=f4s1h2YETNY\n    \n    This is my first shader ever so this code is pretty bad.\n\n*/\n\n//Typical pseudo-random hash (white noise)\nfloat hash1(vec2 p)\n{\n    //Generate a pseudo random number from 'p'.\n    return fract(sin(p.x*0.129898 + p.y*0.78233) * 43758.5453);\n}\n//vec2 version of the hash function\nvec2 hash2(vec2 p)\n{\n    //Generate a pseudo random vec2 from 'p'\n    return fract(sin(p * mat2(0.129898, 0.81314, 0.78233,  0.15926)) * 43758.5453);\n}\n//vec2 unit-vector version of the hash function\nvec2 hash2_norm(vec2 p)\n{\n    //Returns a random normalized direction vector\n    return normalize(hash2(p) - 0.5);\n}\n\nfloat value_noise(vec2 p)\n{\n    //Cell (whole number) coordinates\n    vec2 cell = floor(p);\n    //Sub-cell (fractional) coordinates\n    vec2 sub = p - cell;\n    //Cubic interpolation (use sub for linear interpolation)\n    vec2 cube = sub*sub*(3.-2.*sub);\n    //Offset vector\n    const vec2 off = vec2(0,1); \n\n    //Sample cell corners and interpolate between them.\n    return mix( mix(hash1(cell+off.xx), hash1(cell+off.yx), cube.x),\n                mix(hash1(cell+off.xy), hash1(cell+off.yy), cube.x), cube.y);\n}\n\n//Standard Voronoi noise function\nfloat voronoi_noise(vec2 p)\n{\n    //Cell (whole number) coordinates\n    vec2 cell = floor(p);\n    //Initialize distance at a high-number\n    float dist = 9.0;\n    //Store the nearest voronoi cell\n    vec2 voronoi_cell = cell;\n    \n    //Iterate through [3,3] neighbor cells\n    for(int x = -1; x<=1; x++)\n    for(int y = -1; y<=1; y++)\n    {\n        //Get sample cell coordintaes\n        vec2 sample_cell = cell+vec2(x,y);\n        //Compute difference from pixel to worley cell\n        vec2 worley_dif = hash2(sample_cell) + sample_cell - p;\n        //Compute the worley distance        \n        float new_dist = length(worley_dif);\n        //If the new distance is the nearest\n        if (dist > new_dist)\n        {\n            //Store the new distance and cell coordinates\n            dist = new_dist;\n            voronoi_cell = sample_cell;\n        }\n    }\n    //Get a random value using cell coordinates\n    return hash1(voronoi_cell);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.6,0.4,0.4);\n    vec3 b = vec3(0.25,0.25,0.25);\n    vec3 c = vec3(0.4,0.8,0.7);\n    vec3 d = vec3(.263,.416,.557);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/ iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 2.0; i++) {\n        float len = length(uv0);\n        vec2 uv_noise = uv0.xy;\n        uv_noise.x += iTime *(0.8+ 0.2*cos(0.00015*iTime));\n        uv_noise.y += - iTime*(0.8+ 0.2*sin(0.0002*iTime));\n        float noise = value_noise(uv_noise);\n        uv.x += 0.1*sin(noise);\n        uv.y += 0.11*cos(noise);\n        uv = fract(len + uv * 1.5* sin(noise))-0.5 - len*0.1*cos(iTime+noise);\n    \n        float d = length(uv) * exp(-length(uv0));\n       \n        vec3 col = palette(0.1*len + noise);\n        d = sin(d*8.0)/8.;\n        d = abs(d);\n        d = 0.03/d;\n\n\n        finalColor += col * d;\n    \n    }\n    \n    \n    fragColor = vec4(finalColor ,1.0);\n}","name":"Image","description":"","type":"image"}]}