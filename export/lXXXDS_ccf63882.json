{"ver":"0.1","info":{"id":"lXXXDS","date":"1709900801","viewed":163,"name":"Realtime ray traced glass","username":"Nazlbit","description":"Realtime ray traced glass with dispersion.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","noise","reflection","ray","refraction","glass","tracing","hdr","realtime","tonemapping","dispersion","ior"],"hasliked":0,"parentid":"ddtyWX","parentname":"Ray traced glass with dispersion"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// You can rotate the camera with the mouse and change the focus distance by clicking on a surface.\n\n// https://www.desmos.com/calculator/vxmtgd7kvz\nvec3 tonemap(const vec3 x, const float a, const float b)\n{\n    return a != 0. ? x * (1. + 1. / a) / (x + 1. / (a * b)) : x * b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = read_buffer(iChannel0, ivec2(fragCoord));\n    fragColor.rgb = tonemap(fragColor.rgb, gamma, exposure);\n    fragColor.rgb = clamp(fragColor.rgb, vec3(0), vec3(1));\n    fragColor.rgb = linear2gamma_wgrgb(fragColor.rgb);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Scene parameters\nconst float middle_sphere_r = 1.0;\nconst float satellite_sphere_r = middle_sphere_r / 2.5;\nconst float sphere_offset = middle_sphere_r * 1.2 + satellite_sphere_r;\n\n// Materials parameters\nconst float air_ior = 1.0;\nconst float glass_ior = 1.522;\nconst float glass_ior_coeff = 0.00459;\nconst vec3 purple          = vec3(0.15, 0.01, 0.15);\nconst vec3 blue            = vec3(0.002, 0.02, 0.2);\nconst vec3 red             = vec3(0.15, 0.005, 0.005);\nconst vec3 green           = vec3(0.01, 0.11, 0.01);\nconst vec3 orange          = vec3(0.2, 0.03, 0.01);\nconst vec3 high_iron_glass = vec3(0.5, 0.55, 0.5);\nconst vec3 sphere_1_color = purple;\nconst vec3 sphere_2_color = blue;\nconst vec3 sphere_3_color = red;\nconst vec3 sphere_4_color = green;\nconst vec3 sphere_5_color = orange;\nconst vec3 icosahedron_color = high_iron_glass;\n\n// Light parameters\nconst float skybox_contrast = 4.;\nconst float skybox_intensity = 1.0;\nconst float skybox_saturation = 1.5;\n\n// Camera parameters\nconst float fov = radians(20.); // Horizontal field of view\nconst float camera_distance = middle_sphere_r * 7.0;\nconst vec2 camera_orientation_offset = radians(vec2(90., 0.));\nconst vec3 camera_pos_offset = vec3(0);\nconst float camera_rotation_speed_coeff = 3.0;\nconst float aperture_size = middle_sphere_r * 0.1; // The bigger the aperture, the bigger the DOF effect.\nconst float init_focus_distance = camera_distance * 1.1;\nconst float exposure = 1.5;\nconst float gamma = 150.;\n\n// Ray tracing parameters\nconst float distance_limit = 1e3;\nconst float surface_offset = 1e-4; // New ray surface offset.\nconst int num_passes_per_frame = 3;\nconst int rays_stack_size = 10;\nconst float ray_importance_threshold = 3e-4;\nconst int reflections_num_limit = 10;\nconst int refractions_num_limit = 10;\n// Noise added to rays to smooth out the result. Value in the range of [0:1] is within a pixel. Acts like antialiasing.\nconst float ray_noise_coeff = 1.0;\n\n// Result noise level detection parameters\nconst float noise_threshold = 1e-3;\nconst float noise_power = 2.;\nconst int noise_sample_r = 4;\nconst float noise_mix_coeff = 0.9;\nconst float dark_area_noise_coeff = 0.2;\n\n// Data storage locations\nconst ivec2 frame_num_uv = ivec2(0, 0);\nconst ivec2 mouse_uv = ivec2(1, 0);\nconst ivec2 orientation_uv = ivec2(2, 0);\nconst ivec2 resolution_uv = ivec2(3, 0);\nconst ivec2 focus_distance_uv = ivec2(4, 0);\n\nstruct sphere_t\n{\n    vec3 pos;\n    vec3 color;\n    float r;\n};\n\nconst float pentagon_angle = radians(72.);\nconst sphere_t spheres[] = sphere_t[](\n    sphere_t(vec3(cos(pentagon_angle * 0.5), 0, sin(pentagon_angle * 0.5)) * sphere_offset, sphere_1_color, satellite_sphere_r),\n    sphere_t(vec3(cos(pentagon_angle * 1.5), 0, sin(pentagon_angle * 1.5)) * sphere_offset, sphere_2_color,   satellite_sphere_r),\n    sphere_t(vec3(cos(pentagon_angle * 2.5), 0, sin(pentagon_angle * 2.5)) * sphere_offset, sphere_3_color,    satellite_sphere_r),\n    sphere_t(vec3(cos(pentagon_angle * 3.5), 0, sin(pentagon_angle * 3.5)) * sphere_offset, sphere_4_color,  satellite_sphere_r),\n    sphere_t(vec3(cos(pentagon_angle * 4.5), 0, sin(pentagon_angle * 4.5)) * sphere_offset, sphere_5_color, satellite_sphere_r)\n);\n\nconst sphere_t bounding_sphere = sphere_t(vec3(0), vec3(0), middle_sphere_r);\n\nconst vec3 ico_verts[12] = vec3[](\n    vec3(0.0, -1.0, 0.0) * middle_sphere_r,\n    vec3(0.7235999703407288, -0.4472149908542633, -0.5257200002670288) * middle_sphere_r,\n    vec3(-0.27638500928878784, -0.4472149908542633, -0.8506399989128113) * middle_sphere_r,\n    vec3(-0.8944249749183655, -0.4472149908542633, 0.0) * middle_sphere_r,\n    vec3(-0.27638500928878784, -0.4472149908542633, 0.8506399989128113) * middle_sphere_r,\n    vec3(0.7235999703407288, -0.4472149908542633, 0.5257200002670288) * middle_sphere_r,\n    vec3(0.27638500928878784, 0.4472149908542633, -0.8506399989128113) * middle_sphere_r,\n    vec3(-0.7235999703407288, 0.4472149908542633, -0.5257200002670288) * middle_sphere_r,\n    vec3(-0.7235999703407288, 0.4472149908542633, 0.5257200002670288) * middle_sphere_r,\n    vec3(0.27638500928878784, 0.4472149908542633, 0.8506399989128113) * middle_sphere_r,\n    vec3(0.8944249749183655, 0.4472149908542633, 0.0) * middle_sphere_r,\n    vec3(0.0, 1.0, 0.0) * middle_sphere_r\n);\n\nconst uvec3 ico_ind[20] = uvec3[](\n    uvec3(0, 1, 2),\n    uvec3(1, 0, 5),\n    uvec3(0, 2, 3),\n    uvec3(0, 3, 4),\n    uvec3(0, 4, 5),\n    uvec3(1, 5, 10),\n    uvec3(2, 1, 6),\n    uvec3(3, 2, 7),\n    uvec3(4, 3, 8),\n    uvec3(5, 4, 9),\n    uvec3(1, 10, 6),\n    uvec3(2, 6, 7),\n    uvec3(3, 7, 8),\n    uvec3(4, 8, 9),\n    uvec3(5, 9, 10),\n    uvec3(6, 10, 11),\n    uvec3(7, 6, 11),\n    uvec3(8, 7, 11),\n    uvec3(9, 8, 11),\n    uvec3(10, 9, 11)\n);\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    vec3 color;\n    int triangle_index;\n};\n\nstruct intersection_t\n{\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n    int triangle_index;\n    bool inside;\n    bool sphere;\n};\n\nstruct camera_t\n{\n    vec3 pos;\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    float fov_ctg;\n    float ratio;\n};\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( const uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( const uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( const uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( const float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( const vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( const vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( const vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nfloat noise(const vec2 uv, const int frame, inout int seed)\n{\n    return random(vec4(uv, vec2(frame + 1, ++seed)));\n}\n\nvec2 noise2(const vec2 uv, const int frame, inout int seed)\n{\n    return vec2(noise(uv, frame, seed), noise(uv, frame, seed));\n}\n\nfloat rgb2grayscale(const vec3 rgb)\n{\n    const vec3 rgb_weights = vec3(0.3, 0.59, 0.11);\n    return dot(rgb, rgb_weights);\n}\n\nvec3 saturation(const vec3 color, const float a)\n{\n    float avg = rgb2grayscale(color);\n    return max(mix(vec3(avg), color, a), 0.0);\n}\n\nvec3 linear2gamma_wgrgb(const vec3 x)\n{\n    return pow(x, vec3(1.0/2.2));\n}\n\nvec3 srgb_linear2gamma(const vec3 x)\n{\n    return mix(12.92 * x, 1.055 * pow(x, vec3(1./2.4)) - 0.055, greaterThan(x, vec3(0.0031308)));\n} \n\nvec3 srgb_gamma2linear(const vec3 x)\n{\n    return mix(x * 0.0774, pow((x + 0.055) * 0.9479, vec3(2.4)), greaterThan(x, vec3(0.04045)));\n}\n\n#define read_buffer(buffer, uv) texelFetch(buffer, uv, 0)\n\nint get_frame_index(const int iframe, const sampler2D buf_a)\n{\n    return iframe - int(read_buffer(buf_a, frame_num_uv).r);\n}\n\nbool sphere_hit(const vec2 t)\n{\n    return t[1] > surface_offset; // The sphere is not behind\n}\n\nvec2 sphere_intersection(const ray_t ray, const sphere_t sphere)\n{\n    vec3 r_min_o = ray.pos - sphere.pos;\n    float b = 2.0 * dot(r_min_o, ray.dir);\n    float c = dot(r_min_o, ray.pos) - dot(r_min_o, sphere.pos) - sphere.r * sphere.r;\n    float d = b * b - 4.0 * c;\n    if(d <= 0.0)\n    {\n        // The ray missed the sphere.\n        return vec2(-1.0);\n    }\n\n    // First intersection\n    float t0 = (-b - sqrt(d)) * 0.5;\n    // Second intersection\n    float t1 = (-b + sqrt(d)) * 0.5;\n\n    return vec2(t0, t1);\n}\n\nintersection_t build_intersection_s(const ray_t ray, const sphere_t sphere, const vec2 t)\n{\n    intersection_t intersection;\n    intersection.sphere = true;\n    intersection.inside = t[0] < surface_offset;\n\n    if(intersection.inside)\n    {\n        intersection.color = pow(sphere.color, vec3(t[1] - t[0]));\n        intersection.pos = ray.pos + ray.dir * t[1];\n        intersection.normal = normalize(sphere.pos - intersection.pos);\n    }\n    else\n    {\n        intersection.color = vec3(1.0);\n        intersection.pos = ray.pos + ray.dir * t[0];\n        intersection.normal = normalize(intersection.pos - sphere.pos);\n    }\n    return intersection;\n}\n\nbool triangle_hit(const vec4 b)\n{\n    return all(greaterThanEqual(b.xyz, vec3(0.))) && b.w > 0.;\n}\nvec4 triangle_intersection(const ray_t ray, const mat3 triangle)\n{\n    return inverse(mat4(vec4(triangle[0], 1.0),\n                        vec4(triangle[1], 1.0),\n                        vec4(triangle[2], 1.0),\n                        vec4(-ray.dir, 0))) * vec4(ray.pos, 1.0);\n}\n\nintersection_t build_intersection_t(const ray_t ray, const mat3 triangle, const float d)\n{\n    intersection_t intersection;\n    intersection.sphere = false;\n    intersection.pos = ray.pos + ray.dir * d;\n    intersection.normal = normalize(cross(triangle[2] - triangle[0],\n                                          triangle[1] - triangle[0]));\n    intersection.inside = dot(intersection.normal, ray.dir) > 0.0;\n    if(intersection.inside)\n    {\n        intersection.normal *= -1.0;\n        intersection.color = pow(icosahedron_color, vec3(d));\n    }\n    else\n    {\n        intersection.color = vec3(1.0);\n    }\n\n    return intersection;\n}\n\nbool find_closest_intersection(const ray_t ray, out intersection_t intersection)\n{\n    // Find the closest sphere the ray intersects by iterating through all spheres.\n    float sphere_distance = distance_limit;\n\n    int sphere_hit_index = -1;\n    vec2 t;\n    for(int i = 0; i < spheres.length(); ++i)\n    {\n        vec2 t_tmp = sphere_intersection(ray, spheres[i]);\n        if(sphere_hit(t_tmp))\n        {\n            if(sphere_distance > t_tmp[1])\n            {\n                // This sphere is closer to the ray origin.\n                sphere_hit_index = i;\n                sphere_distance = t_tmp[1];\n                t = t_tmp;\n            }\n        }\n    }\n    \n    float triangle_distance = sphere_distance;\n    vec2 bounding_sphere_t = sphere_intersection(ray, bounding_sphere);\n    int triangle_hit_index = -1;\n    if(sphere_hit(bounding_sphere_t) && bounding_sphere_t[0] < sphere_distance)\n    {\n        for(int i = 0; i < ico_ind.length(); ++i)\n        {\n            if(i == ray.triangle_index)\n            {\n                continue;\n            }\n            vec3 p0 = ico_verts[ico_ind[i][0]];\n            vec3 p1 = ico_verts[ico_ind[i][1]];\n            vec3 p2 = ico_verts[ico_ind[i][2]];\n            mat3 triangle = mat3(p0, p1, p2);\n            vec4 barycentric = triangle_intersection(ray, triangle);\n            if(triangle_hit(barycentric))\n            {\n                if(triangle_distance > barycentric.w)\n                {\n                    // This triangle is closer to the ray origin.\n                    triangle_hit_index = i;\n                    triangle_distance = barycentric.w;\n                }\n            }\n        }\n    }\n\n    bool ray_hit = triangle_hit_index > -1 || sphere_hit_index > -1;\n\n    if(ray_hit)\n    {\n        if(sphere_distance <= triangle_distance)\n        {\n            intersection = build_intersection_s(ray, spheres[sphere_hit_index], t);\n            intersection.triangle_index = -1;\n        }\n        else\n        {\n            vec3 p0 = ico_verts[ico_ind[triangle_hit_index][0]];\n            vec3 p1 = ico_verts[ico_ind[triangle_hit_index][1]];\n            vec3 p2 = ico_verts[ico_ind[triangle_hit_index][2]];\n            mat3 triangle = mat3(p0, p1, p2);\n            intersection = build_intersection_t(ray, triangle, triangle_distance);\n            intersection.triangle_index = triangle_hit_index;\n        }\n    }\n    return ray_hit;\n}\n\ncamera_t get_camera(const vec2 resolution, const sampler2D data_channel)\n{\n    camera_t cam;\n    cam.fov_ctg = 1.0 / tan(fov);\n    cam.ratio = resolution.x / resolution.y;\n\n    vec2 orientation = read_buffer(data_channel, orientation_uv).xy;\n\n    // Define and rotate basis vectors vertically.\n    cam.right = vec3(cos(orientation.x), 0, sin(orientation.x));\n    cam.forward = vec3(-sin(orientation.x), 0, cos(orientation.x));\n    cam.up = vec3(0, cos(orientation.y), 0) + cam.forward * sin(orientation.y);\n    cam.forward = cam.forward * cos(orientation.y) + vec3(0, -sin(orientation.y), 0);\n\n    // Camera is always looking at the first sphere.\n    cam.pos = camera_pos_offset - cam.forward * camera_distance;\n    return cam;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    bool mb = iMouse.z > 0.0;\n    vec4 prev_frame = read_buffer(iChannel0, coord);\n\n    if(coord == frame_num_uv)\n    {\n        vec2 prev_res = read_buffer(iChannel0, resolution_uv).xy;\n        if(mb || prev_res != iResolution.xy)\n        {\n            fragColor = vec4(iFrame);\n        }\n        else\n        {\n            fragColor = prev_frame;\n        }\n    }\n    else if(coord == mouse_uv)\n    {\n        fragColor = iMouse;\n    }\n    else if(coord == orientation_uv)\n    {\n        if(iFrame == 0)\n        {\n            fragColor = vec4(camera_orientation_offset, 0, 0);\n        }\n        else\n        {\n            vec4 prev_mouse = read_buffer(iChannel0, mouse_uv);\n            vec2 new_orientation = prev_frame.xy;\n            if(prev_mouse.z > 0.0 && iMouse.z > 0.0)\n            {\n                vec2 pos_delta = iMouse.xy - prev_mouse.xy;\n                new_orientation -= pos_delta / iResolution.y * camera_rotation_speed_coeff;\n            }\n            else\n            {\n                new_orientation -= vec2(0.0003, 0);\n            }\n\n            if(new_orientation.x > radians(360.))\n            {\n                new_orientation.x -= radians(360.);\n            }\n            else if(new_orientation.x < 0.0)\n            {\n                new_orientation.x += radians(360.);\n            }\n\n            new_orientation.y = clamp(new_orientation.y, radians(-90.), radians(90.));\n\n            fragColor = vec4(new_orientation, 0, 0);\n        }\n    }\n    else if(coord == resolution_uv)\n    {\n        fragColor = vec4(iResolution, 0);\n    }\n    else if(coord == focus_distance_uv)\n    {\n        if(iFrame == 0)\n        {\n            fragColor = vec4(init_focus_distance);\n        }\n        else\n        {\n            if(iMouse.z > 0.0)\n            {\n                camera_t cam = get_camera(iResolution.xy, iChannel0);\n\n                vec2 normalized_coords = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n                vec3 ray_dir = cam.forward * cam.fov_ctg +\n                               cam.right * normalized_coords.x +\n                               cam.up * normalized_coords.y / cam.ratio;\n\n                ray_t ray = ray_t(cam.pos, normalize(ray_dir), vec3(1.0), -1);\n                intersection_t intersection;\n                bool index = find_closest_intersection(ray, intersection);\n                if(index)\n                {\n                    float distance = dot(cam.forward, intersection.pos - cam.pos);\n                    fragColor = vec4(distance);\n                }\n                else\n                {\n                    fragColor = vec4(distance_limit);\n                }\n            }\n            else\n            {\n                fragColor = prev_frame;\n            }\n        }\n    }\n    else\n    {\n        fragColor = vec4(0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"int seed = 0;\n\n// Somehow using a static array makes it run slower than when using this.\nvec3 cie2006_2e_wgrgb(const int i)\n{\nswitch(i)\n{\ncase 0: return vec3(0.001359, 0.000000, 0.046828); \ncase 1: return vec3(0.003370, 0.000000, 0.121179); \ncase 2: return vec3(0.007537, 0.000000, 0.284219); \ncase 3: return vec3(0.014915, 0.000000, 0.581575); \ncase 4: return vec3(0.026359, 0.000000, 1.074936); \ncase 5: return vec3(0.038309, 0.000000, 1.738560); \ncase 6: return vec3(0.048570, 0.000000, 2.549796); \ncase 7: return vec3(0.050738, 0.000000, 3.457535); \ncase 8: return vec3(0.045509, 0.000000, 4.669191); \ncase 9: return vec3(0.018651, 0.000000, 6.407604); \ncase 10: return vec3(0.000000, 0.027049, 7.082777);\ncase 11: return vec3(0.000000, 0.079886, 6.263733);\ncase 12: return vec3(0.000000, 0.130891, 5.543511);\ncase 13: return vec3(0.000000, 0.186034, 4.729359);\ncase 14: return vec3(0.000000, 0.256751, 4.157737);\ncase 15: return vec3(0.000000, 0.354955, 3.868351);\ncase 16: return vec3(0.000000, 0.470084, 3.435670);\ncase 17: return vec3(0.000000, 0.588026, 2.855277);\ncase 18: return vec3(0.000000, 0.712732, 2.295134);\ncase 19: return vec3(0.000000, 0.844748, 1.846238);\ncase 20: return vec3(0.000000, 0.990664, 1.485130);\ncase 21: return vec3(0.000000, 1.201113, 1.256241);\ncase 22: return vec3(0.000000, 1.480076, 1.078565);\ncase 23: return vec3(0.000000, 1.829322, 0.884353);\ncase 24: return vec3(0.000000, 2.236861, 0.670272);\ncase 25: return vec3(0.000000, 2.676759, 0.443624);\ncase 26: return vec3(0.000000, 3.106306, 0.172615);\ncase 27: return vec3(0.114054, 3.397859, 0.000000);\ncase 28: return vec3(0.356830, 3.575226, 0.000000);\ncase 29: return vec3(0.598667, 3.694995, 0.000000);\ncase 30: return vec3(0.871013, 3.793163, 0.000000);\ncase 31: return vec3(1.147702, 3.801293, 0.000000);\ncase 32: return vec3(1.420354, 3.727261, 0.000001);\ncase 33: return vec3(1.727669, 3.651866, 0.000000);\ncase 34: return vec3(2.065388, 3.507676, 0.000000);\ncase 35: return vec3(2.416572, 3.341602, 0.000000);\ncase 36: return vec3(2.799786, 3.117576, 0.000000);\ncase 37: return vec3(3.164420, 2.841011, 0.000000);\ncase 38: return vec3(3.497776, 2.510476, 0.000000);\ncase 39: return vec3(3.865991, 2.202888, 0.000000);\ncase 40: return vec3(4.127088, 1.896216, 0.000000);\ncase 41: return vec3(4.295009, 1.582901, 0.000000);\ncase 42: return vec3(4.360643, 1.285841, 0.000000);\ncase 43: return vec3(4.332625, 1.015894, 0.000000);\ncase 44: return vec3(4.165482, 0.784162, 0.000000);\ncase 45: return vec3(3.892157, 0.593464, 0.000000);\ncase 46: return vec3(3.548914, 0.439628, 0.000000);\ncase 47: return vec3(3.170454, 0.319283, 0.000000);\ncase 48: return vec3(2.706342, 0.229206, 0.000000);\ncase 49: return vec3(2.254704, 0.162141, 0.000000);\ncase 50: return vec3(1.857463, 0.112797, 0.000000);\ncase 51: return vec3(1.512515, 0.076742, 0.000000);\ncase 52: return vec3(1.180353, 0.053627, 0.000000);\ncase 53: return vec3(0.897837, 0.036637, 0.000000);\ncase 54: return vec3(0.673822, 0.024546, 0.000000);\ncase 55: return vec3(0.498977, 0.016430, 0.000000);\ncase 56: return vec3(0.364371, 0.011220, 0.000000);\ncase 57: return vec3(0.262362, 0.007684, 0.000000);\ncase 58: return vec3(0.186170, 0.005257, 0.000000);\ncase 59: return vec3(0.130130, 0.003581, 0.000000);\ncase 60: return vec3(0.089432, 0.002423, 0.000000);\ncase 61: return vec3(0.062282, 0.001669, 0.000000);\ncase 62: return vec3(0.043360, 0.001160, 0.000000);\ncase 63: return vec3(0.030081, 0.000805, 0.000000);\ncase 64: return vec3(0.020615, 0.000554, 0.000000);\ncase 65: return vec3(0.014110, 0.000384, 0.000000);\ncase 66: return vec3(0.009743, 0.000269, 0.000000);\ncase 67: return vec3(0.006734, 0.000189, 0.000000);\ncase 68: return vec3(0.004688, 0.000134, 0.000000);\n}\n}\n\nconst float wl_min = 390.0;\nconst float wl_max = 730.0;\nconst int cie_sample_num = 69;\n\nvec3 wl2wgrgb_cie2006(const float wl)\n{\n    float x = clamp((wl - wl_min) / (wl_max - wl_min), 0., 1.) * float(cie_sample_num - 1);\n    int index1 = int(x);\n    int index2 = min(index1 + 1, cie_sample_num - 1);\n    x -= float(index1);\n    return mix(cie2006_2e_wgrgb(index1), cie2006_2e_wgrgb(index2), x);\n}\n\nfloat fresnel_schlick(const float cos_theta, const float ior1, const float ior2)\n{\n    float r0 = (ior1 - ior2) / (ior1 + ior2);\n    r0 = r0 * r0;\n    float a = 1.0 - cos_theta;\n    float a5 = a * a;\n    a5 *= a5 * a;\n    return r0 + (1.0 - r0) * a5;\n}\n\nvec3 reflect_ray(const vec3 v, const vec3 n)\n{\n    return normalize(reflect(v, n));\n}\n\nvec3 sky_box(const vec3 v)\n{\n    vec3 linear = srgb_gamma2linear(textureLod(iChannel0, v, 0.0).rgb);\n\n    // Apply fake hdr effect by increasing contrast and scaling the values.\n    vec3 hdr = pow(saturation(linear, skybox_saturation), vec3(skybox_contrast)) * skybox_intensity;\n    return hdr;\n}\n\n// https://en.wikipedia.org/wiki/Cauchy%27s_equation\nfloat wl2ior(const float w, const float a, const float b)\n{\n    return a + b / (w * w);\n}\n\nray_t init_ray(const camera_t cam, const vec3 color)\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    // Shape of the noise defines the bokeh shape. In this case it's a circle.\n    vec2 square_noise = noise2(uv, iFrame, seed);\n    vec2 dof_noise = vec2(sqrt(square_noise.x) * 0.5, square_noise.y * radians(360.));\n    vec3 dof = (cam.right * cos(dof_noise.y) + cam.up * sin(dof_noise.y)) * dof_noise.x * aperture_size;\n\n    vec2 pixel_noise = (noise2(uv, iFrame, seed) - 0.5) / iResolution.xy * ray_noise_coeff;\n    vec2 normalized_coords = (uv + pixel_noise) * 2.0 - 1.0;\n    // Initial ray direction based on the normalized fragment coordinates and camera orientation.\n    vec3 ray_dir = cam.forward +\n                   cam.right * normalized_coords.x / cam.fov_ctg +\n                   cam.up * normalized_coords.y / (cam.ratio * cam.fov_ctg);\n    ray_dir *= read_buffer(iChannel1, focus_distance_uv).x;\n    ray_dir += dof;\n\n    return ray_t(cam.pos - dof, normalize(ray_dir), color, -1);\n}\n\nvec4 get_prev_result()\n{\n    return read_buffer(iChannel2, ivec2(gl_FragCoord.xy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    int frame = get_frame_index(iFrame, iChannel1);\n\n    if(frame != 0)\n    {\n        frame = 5;\n    }\n\n    camera_t cam = get_camera(iResolution.xy, iChannel1);\n\n    ray_t rays_stack[rays_stack_size + 2];\n\n    // The final color is accumulated with rays interacting the scene.\n    vec3 result = vec3(0);\n\n    for(int pass = 0; pass < num_passes_per_frame; ++pass)\n    {\n        float wl = mix(wl_min, wl_max, noise(uv, iFrame, seed));\n        vec3 rgb = wl2wgrgb_cie2006(wl);\n\n        float ior = wl2ior(wl * 0.001, glass_ior, glass_ior_coeff);\n\n        int num_reflections = 0;\n        int num_refractions = 0;\n\n        rays_stack[0] = init_ray(cam, rgb);\n        int num_rays = 1;\n\n        while(num_rays > 0)\n        {\n            // Get the next ray.\n            --num_rays;\n            ray_t ray = rays_stack[num_rays];\n\n            intersection_t intersection;\n            if(!find_closest_intersection(ray, intersection))\n            {\n                // The ray doesn't intersect any surfaces, so it hits the skybox.\n                result += sky_box(ray.dir) * ray.color;\n            }\n            else if(num_rays > rays_stack_size)\n            {\n                // We can't emit new rays.\n                continue;\n            }\n            else\n            {\n                float transition_ior[2];\n                transition_ior[int(intersection.inside)] = air_ior;\n                transition_ior[int(!intersection.inside)] = ior;\n\n                vec3 next_color = ray.color * intersection.color;\n\n                vec3 refraction = refract(ray.dir, intersection.normal, transition_ior[0] / transition_ior[1]);\n                bool tir = vec3(0.0) == refraction;\n\n                if(!tir && num_refractions < refractions_num_limit)\n                {\n                    refraction = normalize(refraction);\n                    float fresnel_refraction = 1.0 - fresnel_schlick(dot(-intersection.normal, refraction), transition_ior[1], transition_ior[0]);\n                    vec3 next_color_refraction = next_color * fresnel_refraction;\n\n                    if(rgb2grayscale(next_color_refraction) >= ray_importance_threshold)\n                    {\n                        // Emit refraction ray (add it to the list).\n                        rays_stack[num_rays] = ray_t(intersection.pos, refraction, next_color_refraction, intersection.triangle_index);\n                        ++num_rays;\n                        ++num_refractions;\n                    }\n                }\n\n                bool skip_reflection = tir && intersection.sphere && intersection.inside;\n                if(!skip_reflection && num_reflections < reflections_num_limit)\n                {\n                    float fresnel_reflection = tir ? 1.0 : fresnel_schlick(dot(intersection.normal, -ray.dir), transition_ior[0], transition_ior[1]);\n                    vec3 next_color_reflection = next_color * fresnel_reflection;\n                    if(rgb2grayscale(next_color_reflection) >= ray_importance_threshold)\n                    {\n                        // Emit reflection ray (add it to the list).\n                        vec3 reflection = reflect_ray(ray.dir, intersection.normal);\n                        rays_stack[num_rays] = ray_t(intersection.pos, reflection, next_color_reflection, intersection.triangle_index);\n                        ++num_rays;\n                        ++num_reflections;\n                    }\n                }\n            }\n        }\n    }\n\n    result /= float(num_passes_per_frame);\n\n    // Mix with the previous frames to reduce noise.\n    result = (get_prev_result().rgb * float(frame) + result) / (float(frame) + 1.0);\n    fragColor = vec4(result, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}