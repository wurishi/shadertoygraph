{"ver":"0.1","info":{"id":"DtByWW","date":"1691749326","viewed":125,"name":"Choppy Waters","username":"kaffelon","description":"Ocean with fbm. Mouse to look around","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","waves","sea","sun","water","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (vec2 uv){\n    return fract(sin(dot(uv,vec2(95.3164,22.12366)))*9821.5412);\n}\n\nvec2 rvec2(float f){\n    return normalize(vec2(\n    cos(sin(f+790.30193) * 1480.4627754),\n    cos(sin(f-020.67850) * 6300.1678844)\n    ));\n}\n\nfloat ocean(vec3 p, vec3 rd, out vec3 normal){\n    float time_scale = iTime * 2.5;\n    float lacunarity = 1.25;\n    float frequency = .7;\n    float amp = .7;\n    float gain = .75;\n    float sum = 0.0;\n    vec2 derivative = vec2(0);\n    vec2 last_d = derivative;\n\n    for(int i = 0; i < 32; i++){\n\n        vec2 direction = rvec2(float(i));\n        float wave = amp *exp(sin(dot(direction,vec2(p.x,p.z) + last_d) * frequency + time_scale)-.8);\n        \n        last_d = frequency * amp * exp(sin(dot(direction,vec2(p.x,p.z) + last_d) * frequency + time_scale)-.8)\n        * direction *cos(dot(direction,vec2(p.x,p.z) + last_d)* frequency+time_scale);\n        derivative += last_d;\n        \n        frequency *= lacunarity;\n        amp *= gain;\n        sum += wave;\n    }\n    vec3 tangent = vec3(1.0,derivative.x,0.0);\n    vec3 binormal = vec3(0.0,derivative.y,1.0);\n    \n    tangent = normalize(tangent);\n    binormal = normalize(binormal);\n    \n    normal = cross(binormal,tangent);\n    return sum;\n}\n\nconst vec3 WATER_COL = vec3(.118,.175,.28) * 1.5;\nconst vec3 SKY_COL = vec3(.95,.985,1.0) * 1.03;\nconst vec3 SKY_COL_TOP = vec3(.7,.85,1.) * .85;\n\nconst vec3 SUN_COL = vec3(2.0,1.75,.92);\nconst vec3 SPEC_COL = SUN_COL;\nconst vec3 FRESNEL_COL = vec3(.9,.95,1.0) * .679;\nconst vec3 FOG_COL = SKY_COL;\n\n\n\n\nvec3 color_water(vec3 ro, vec3 rd, vec3 lp, vec3 n){\n    vec3 light_vector = normalize(lp-ro);\n    vec3 reflected = -light_vector - 2.0*dot(-light_vector,n)*n;\n    float specular = pow(dot(reflected,-normalize(rd)),1.0);\n    reflected = normalize(reflected);\n    \n    vec3 light_dir = normalize(lp-ro);\n    vec3 view_dir = normalize(-rd);\n    vec3 halfway_dir = normalize(light_dir + view_dir);\n    \n    float shininess =44.0;\n    float spec = pow(max(dot(n,halfway_dir),0.0),shininess);\n    \n    if (dot(reflected,-rd) < 0.0)\n    {\n        specular = 0.0;\n    }\n        vec3 color = vec3(0);\n        float bias = 1.0;\n        float scale = .015;\n        float power = 1.75;\n        float fresnel = max(0.0,min(1.0,bias+scale*1.0+dot(normalize(rd),n)*power));\n        color += fresnel * FRESNEL_COL;\n        color = mix(color, SPEC_COL, spec);\n        color += WATER_COL;\n        color = clamp(color,0.0,1.0);\n        return color;\n}\n\nvec3 rotate_y(float radian, vec3 v){\n    mat3 rot;\n    rot[0].xyz = vec3(cos(radian), 0, -sin(radian));\n    rot[1].xyz = vec3(0,1,0);\n    rot[2].xyz = vec3(sin(radian), 0, cos(radian));\n    return v * rot;\n}\n\nvec3 fragment(vec2 uv){\n    float h = 2.0;\n    vec3 light_pos = vec3(sin((iTime * .13)) * 10000.,2000.0,cos((iTime * .13)) * 10000.);\n    vec2 mouse = iMouse.xy/iResolution.xy;   \n    vec3 ro = vec3(sin(mouse.x),0,cos(mouse.x));\n    vec3 rd = normalize(vec3(uv.x-.5,uv.y-.5,-0.5));\n    rd = rotate_y(mouse.x * 6.28 + 9.,rd);\n    vec3 normal = vec3(0,1,0);\n    for(int i = 0; i < 64;i++){\n        float height = -4.0 + ocean(ro,rd,normal);\n        if (abs(ro.y - height) < .001)\n        {\n            return clamp(mix(color_water(ro,rd,light_pos,normal), FOG_COL, length(ro)*.008),0.0,1.0);\n            \n        }\n\n        if(length(ro) > 100.0)\n        {\n            vec3 col = mix(SKY_COL, SKY_COL_TOP, normalize(rd).y);\n            rd.x *= iResolution.x/iResolution.y;\n            rd.z *= iResolution.x/iResolution.y;\n            return mix(col, SUN_COL, pow(abs(dot(normalize(rd), normalize(light_pos))),250.0));\n            \n\n        }\n        ro += rd * (ro.y-height);\n    }\n    return clamp(mix(color_water(ro,rd,light_pos,normal), FOG_COL, length(ro)*.008),0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const float AA = 2.;\n    const int AA2 = int(AA*AA);\n    vec2 pix = 1./iResolution.yy/AA;\n    vec3 col = vec3(0);\n    for(int i = 0; i < AA2; i ++){\n        float k = float(i);\n        vec2 uvOffs = uv + vec2(floor(k/AA),mod(k,AA))*pix;\n        col += clamp(fragment(uvOffs),0.0,1.0);\n    \n    }\n    col /= (AA * AA);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}