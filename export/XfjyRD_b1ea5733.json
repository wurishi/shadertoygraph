{"ver":"0.1","info":{"id":"XfjyRD","date":"1722329563","viewed":18,"name":"三维相机研究","username":"langzai","description":"搞不懂根本搞不懂","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec2 opUnion(vec2 d1, vec2 d2)\n{ \n    return d1.x < d2.x ? d1 : d2; \n}\nvec2 RotateUV(vec2 uv,float angle)//uv旋转\n{\n    return vec2(uv.x * cos(angle) - uv.y * sin(angle),uv.x * sin(angle) + uv.y *cos(angle));\n}\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2(1e10, 0);\n    res = opUnion(res, vec2(sdSphere(pos-vec3(cos(iTime)*3.,0.9,sin(iTime)*3.+5.), 0.4), 1));\n    pos.xz = RotateUV(pos.xz - vec2(0.,5.),iTime);\n    res = opUnion(res, vec2(sdBox(pos - vec3(0.,0.9,0.), vec3(0.4)), 2));\n    return res;\n}\nvec2 raycast(in vec3 orign, in vec3 direction)\n{\n    vec2 depth = vec2(-1.);\n    float lenMin = 0.0;\n    float lenMax = 20.0;\n    float len = lenMin;\n    \n     //绘制平面\n    float len2plane = (0.0-orign.y)/direction.y;\n    if(len2plane > 0.0)\n    {\n        lenMax = min(lenMax, len2plane);\n        depth = vec2(len2plane, 3);\n    }\n    \n    for(int i = 0; i < 70 && len < lenMax; i++)\n    {\n        vec2 d = map(orign + direction * len);\n        if(abs(d.x) < (0.0001*len))\n            return vec2(len,d.y);\n        len += d.x;\n    }\n    return depth;\n}\n\nvec3 CalNormal(vec3 p)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy*map(p + e.xyy).x + \n                    e.yyx*map(p + e.yyx).x + \n                    e.yxy*map(p + e.yxy).x + \n                    e.xxx*map(p + e.xxx).x );\n}\nvec3 Render(vec3 orign,vec3 direction)\n{\n    vec2 len = raycast(orign,direction);\n    vec3 p = orign + direction * len.x;\n    vec3 n;\n    //vec3 l = normalize(vec3(sin(iTime),2.,-3.));\n    vec3 l = normalize(vec3(sin(iTime)*10.,5.,3.)-p);\n    vec3 v = normalize(orign-p);\n    vec3 cs = normalize(l+v);\n    vec3 h = cs/dot(cs,cs);\n    if(len.y>=1.) n = CalNormal(p);\n    if(len.y==3.) n = vec3(0.,1.,0.);\n    float ndotl = dot(n,l) *.5+.5;\n    \n    vec3 col = vec3(0.);\n    if(len.y == 1.) col += mix(vec3(0.266,0.157,0.816),vec3(0.537,0.968,0.996),ndotl);\n    if(len.y == 2.) col += mix(vec3(0.836,0.302,0.129),vec3(0.929,0.431,0.623),ndotl);\n    if(len.y == 3.) col += vec3(0.863,0.734,0.208);\n    col += clamp(pow(min(1.0, dot(h, n)), 30.0) * 0.08,0.,1.) ;\n        \n     \n    return  ndotl * col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 camera = vec3(0.0, 2., -3);\n    const float fl = 3.0;// focal length 焦距\n    vec3 p3 = vec3(p,fl);\n    vec3 direction = normalize(p3);//射线方向\n    vec3 orign = camera + p3; //射线起点\n    //vec2 len = camera(vec3(0.0, 2., -5.),3.0,p);\n    vec3 col = Render(orign,direction);\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}