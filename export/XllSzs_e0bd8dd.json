{"ver":"0.1","info":{"id":"XllSzs","date":"1439049407","viewed":1895,"name":"plants","username":"miloszmaki","description":"lifecycle of plants, made for competition on warsztat.gd\nthis is one of my first attempts on raymarching, any ideas on how to optimize it are welcome (or maybe my poor notebook is the problem)","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","warsztat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const int NUM_PLANTS_SQRT = 3;\nconst float LIFE_TIME = 10.0;\nconst vec2 DIMENSIONS = vec2(20);\n#define REPEAT\n\nconst int RAYMARCH_ITER = 50;\nconst float RAYMARCH_EPS = 0.01;\nconst float DITHERING = 2.0;\n\nconst float PI = 3.14159265;\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat rand(float x) { return fract(sin(x * 42.5723) * 12571.1385); }\nfloat rand(vec2 x) { return fract(sin(dot(x, vec2(13.3571,65.1495))) * 32718.2741); }\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = p - i;\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( rand( i + vec2(0,0) ), \n                     rand( i + vec2(1,0) ), u.x),\n                mix( rand( i + vec2(0,1) ), \n                     rand( i + vec2(1,1) ), u.x), u.y);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = x - p;\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( rand(n+  0.0), rand(n+  1.0),f.x),\n                   mix( rand(n+157.0), rand(n+158.0),f.x),f.y),\n               mix(mix( rand(n+113.0), rand(n+114.0),f.x),\n                   mix( rand(n+270.0), rand(n+271.0),f.x),f.y),f.z);\n}\n\nfloat fbm(vec2 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat dPlane(vec3 p) { return p.y; }\nfloat dSphere(vec3 p, float r) { return length(p) - r; }\nfloat dBox(vec3 p, vec3 s) { return length(max(abs(p) - s, 0.)); }\nfloat dRoundBox(vec3 p, vec3 s, float r) { return length(max(abs(p) - s, 0.)) - r; }\n\nvec2 dUnion(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nvec3 pMov(vec3 p, vec3 t) { return p - t; }\nvec3 pRep(vec3 p, vec3 s) { return mod(p+.5*s, s) - .5*s; }\nvec3 pRotY(vec3 p, float a) { float s=sin(a), c=cos(a); return vec3(mat2(c,-s,s,c)*p.xz, p.y).xzy; }\n\nvoid addLeaf(inout vec2 d, vec3 pos, vec3 ext, float skew, float mtl)\n{\n    pos.y -= ext.y;\n    float h1 = pos.y / ext.y;\n    float h2 = abs(h1);\n    h1 = h1 * .5 + .5;\n    ext.xz *= vec2(0.01, 0.1) + (1. - h2*h2);\n    pos.z += h1*h1 * skew;\n    d = dUnion(d, vec2(dRoundBox(pos, ext, 0.02), mtl));\n}\n\nfloat plantMtl(float age, float f)\n{\n    return age * (1. - f) + f;\n}\n\nvoid addPlant(inout vec2 d, vec3 pos, float age)\n{\n    vec4 h;\n    h.x = 1.09091-0.1/(age+0.1); h.y = h.x*h.x; h.z = h.y*h.x; h.w = 1.0;\n    float s = smoothstep(0.5, 1.0, age);\n    vec3 h2 = vec3(1., 1.-s, 1.);\n    \n    float th = 0.1;    \n    vec3 ls1 = vec3(1.5,3.2,th), ls2 = vec3(2.2,4.8,th),\n         ls3 = vec3(1.1,2.4,th), ls4 = vec3(0.5,5.6,th);\n    \n    vec4 sk = h.yzyx * vec4(2.5, 4.0, 2.0, 0.8);\n    sk = mix(sk, vec4(ls1.y,ls2.y,ls3.y,ls4.y), s);\n    \n    float mtl = age + 1.0;\n    \n    addLeaf(d, pMov(pos, vec3(0,0,-0.2)),\t\t\t\th2*h.zyw*ls1, sk.x, plantMtl(age,0.05));\n    addLeaf(d, pRotY(pMov(pos, vec3(0.0,0,0.3)), 2.5),\th2*h.yxw*ls2, sk.y, plantMtl(age,0.08));\n    addLeaf(d, pRotY(pos, -1.9),\t\t\t\t\t\th2*h.zxw*ls3, sk.z, plantMtl(age,0.1));\n    addLeaf(d, pRotY(pMov(pos, vec3(0.2,0,0.2)), -1.2),\th2*h.zzw*ls4, sk.w, plantMtl(age,0.0));\n}\n\nvec2 scene(vec3 pos)\n{\n    vec2 d = vec2(dPlane(pMov(pos, vec3(0,0.4,0))), 2.0);\n    \n    vec3 dim = vec3(DIMENSIONS.x, 1000, DIMENSIONS.y);\n    vec2 grid = dim.xz / float(NUM_PLANTS_SQRT);\n    \n    for (int i=0; i<NUM_PLANTS_SQRT; i++)\n        for (int j=0; j<NUM_PLANTS_SQRT; j++)\n    {\n        float t = rand(float(i*NUM_PLANTS_SQRT+j+1)) + iTime / LIFE_TIME;\n        float f = floor(t);\n        float age = t - f;\n        vec3 p = vec3(0);\n        p.xz = vec2(rand(f), rand(f+53.5421)) * 0.4 + 0.3;\n        p.xz += vec2(i,j);\n        p.xz *= grid;\n        p.xz -= 0.5 * dim.xz;\n        p = pMov(pos, p);\n        #ifdef REPEAT\n        p = pRep(p, dim);\n        #endif\n    \taddPlant(d, p, age);\n    }\n    return d;\n}\n\nfloat rayMarch(vec3 eye, vec3 dir, float zn, float zf, out float mtl)\n{\n    float z = zn;\n    mtl = -1.0;\n    \n    for (int i=0; i < RAYMARCH_ITER; i++)\n    {\n        vec2 d = scene(eye + z * dir);\n        mtl = d.y;\n        if (d.x < RAYMARCH_EPS || z > zf) break;\n        z += d.x * 0.5;\n    }\n    \n    if (z > zf) mtl = -1.0;\n    return z;\n}\n\nvec3 calcNormal(vec3 p)\n{\n\tvec3 e = vec3(0.001,0.,0.);\n\treturn normalize(vec3(\n        \tscene(p+e.xyy).x - scene(p-e.xyy).x,\n\t\t\tscene(p+e.yxy).x - scene(p-e.yxy).x,\n\t\t\tscene(p+e.yyx).x - scene(p-e.yyx).x ));\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat ao = 0.0;\n    float s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        float hr = 0.01 + 1.5*float(i)/4.0;\n        float dd = scene(n * hr + p).x;\n        ao += -(dd-hr)*s;\n        s *= 0.5;\n    }\n    return saturate(1.0 - 0.4 * ao);\n}\n\nfloat groundNoise(vec3 pos)\n{\n    return fbm(0.2*pos.xz);\n}\n\nvec3 groundNorm(vec3 pos)\n{\n    vec3 e = vec3(0.01,0.,0.);\n    float n = groundNoise(pos);\n    return normalize(vec3(groundNoise(pos+e.xyy) - n, 0.01,\n                          groundNoise(pos+e.yyx) - n));\n}\n\n\nvec3 render(vec3 eye, vec3 dir)\n{\n    float zn = 5., zf = 200.;\n    float mtl;\n    float dist = rayMarch(eye, dir, zn, zf, mtl);\n    vec3 pos = eye + dist * dir;\n    vec3 norm = calcNormal(pos);\n    vec3 light = normalize(vec3(0.7,1.,0.));\n\tvec3 refl = reflect(dir, norm);\n    \n    if (mtl > 1.0) norm = groundNorm(pos);\n    \n    float ndl = dot(norm, light);\n    float back = saturate(-ndl);\n    ndl = saturate(ndl);\n    \n    vec3 albedo = vec3(step(0.,mtl));\n    vec3 plant_alb = mix(vec3(0.3,0.9,0.1), vec3(0.6,0.4,0.15), saturate(mtl));\n    plant_alb *= fbm(0.8*pos) * 0.3 + 0.7;\n\tvec3 ground_alb = mix(vec3(0.36,0.23,0.17), 0.8*vec3(0.23,0.16,0.1), groundNoise(pos));\n    albedo *= mix(plant_alb, ground_alb, saturate(mtl - 1.0));\n    \n    vec3 scat = albedo * vec3(1.2, 1.4, 1.0);\n    scat *= back*back;\n    \n    float spec = pow(saturate(dot(refl, light)), 32.);\n    \n    float ao = calcAO(pos, norm);\n    vec3 ambient = 0.2 * albedo * ao;\n    spec *= ao;\n        \n\tvec3 color = ambient + albedo * (1. + 0.5 * spec) * ndl + scat;\n    float fog = dist / zf;\n    color = mix(color, vec3(0.7,0.8,1.0)*1.3, saturate(fog));\n                         \n    return saturate(color);\n}\n\nvec3 lookAtDir(vec2 uv, vec3 eye, vec3 at, vec3 up, float fov)\n{\n    vec3 f = normalize(at - eye);\n    vec3 r = normalize(cross(up, f));\n    vec3 u = normalize(cross(f, r));\n    return normalize(f + fov * (uv.x*r + uv.y*u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float angle = iTime * 0.1;\n    angle += iMouse.x / iResolution.x * 2. * PI;\n    vec3 eye = vec3(sin(angle), 1.0 + 0.2 * sin(angle * 4.5)*0.1, cos(angle));\n    eye *= 15.;\n    vec3 dir = lookAtDir(uv, eye, vec3(0, 0, 0), vec3(0, 1, 0), 1.0);\n\t\n    vec3 color;\n    eye += dir * rand(uv + angle) * DITHERING;\n    color = render(eye, dir);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}