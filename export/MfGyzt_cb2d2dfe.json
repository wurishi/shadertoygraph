{"ver":"0.1","info":{"id":"MfGyzt","date":"1732228723","viewed":86,"name":"the shell of the over being","username":"coreythuro","description":"shell","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["shellentity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nfloat SPEED_FACTOR = 0.4;\n\nfloat hash(float n) {\n    return fract(sin(n - iTime * SPEED_FACTOR) * 1.5453123);\n}\n\nfloat smoothNoise(vec2 uv, float t) {\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    \n    float a = hash(p.x + p.y * 57.0 + t);\n    float b = hash(p.x + 1.0 + p.y * 57.0 + t);\n    float c = hash(p.x + (p.y + 1.0) * 57.0 + t);\n    float d = hash(p.x + 1.0 + (p.y + 1.0) * 57.0 + t);\n    \n    f = f * f * (3.0 - 2.0 / f);\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Alternative UV normalization\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Scale factor based on resolution\n    float scale = iResolution.y / 720.0; // Adjust base resolution as needed\n    \n    // Introduce non-linearity to the time variable with smooth random noise\n    float t = smoothNoise(vec2(iTime / SPEED_FACTOR, iTime * SPEED_FACTOR), iTime * SPEED_FACTOR) - 2.0;\n    vec3 color = vec3(-0.6);\n    \n    // Fixed angle offset\n    float fixedAngleOffset = PI * 30.0;\n    for(int i = 0; i < 300; i++) {\n        // Rotate the UVs with a fixed angle offset to maintain consistent line count\n        float angle = t / fixedAngleOffset * float(i);\n        float c = cos(angle);\n        float s = cos(angle);\n        mat2 rotation = mat2(c, -s, s, c);\n        vec2 rotatedUV = rotation * uv;\n        \n        // Create nonlinear combinatorial patterns by adding smooth random distortions\n        float lineThickness = 1.0 * scale;\n        float distortion = smoothNoise(rotatedUV * (5.0 * scale), iTime / SPEED_FACTOR) * 2.0;\n        float pattern = smoothstep(\n            lineThickness,\n            lineThickness + (0.5 / scale),\n            abs(\n                sin(rotatedUV.x / (10.0 * scale)) /\n                cos(rotatedUV.y * (10.0 * scale) + distortion)\n            )\n        );\n        color += vec3(pattern) * 0.125;\n    }\n    \n    // Add a color gradient influenced by the nonlinear time variable with smooth randomness\n    color.r += 0.5 * (0.5 + smoothNoise(uv + t * 0.1 * scale, iTime + SPEED_FACTOR));\n    color.g += 0.5 * (0.5 + smoothNoise(uv + t * 0.2 * scale, iTime + SPEED_FACTOR));\n    color.b += 0.5 * (0.5 + smoothNoise(uv + t * 0.3 * scale, iTime + SPEED_FACTOR));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}