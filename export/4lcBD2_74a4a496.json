{"ver":"0.1","info":{"id":"4lcBD2","date":"1541011916","viewed":117,"name":"ComputerGraphics HomeWork 1","username":"AdamBalla","description":"ComputerGraphics HomeWork 1","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["cghw1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0.);\n    \n    vec4 color = texelFetch(iChannel0, ivec2(int(fragCoord.x), int(fragCoord.y)), 0);\n    \n    float focus = 5.;\n    int k = int(abs(min(color.w, 100.)/5. - focus));\n    for (int i = -k; i <= k; i++) {\n    \tfor (int j = -k; j <= k; j++) {\n    \t\tcol = col +\n                texelFetch(iChannel0,\n                           ivec2(clamp(int(fragCoord.x)+i, 1, int(iChannelResolution[0].x) - 1),\n                                 clamp(int(fragCoord.y)+j, 1, int(iChannelResolution[0].y) - 1)), 0);\n    \t}\n    }\n    col = col / float((2*k+1)*(2*k+1));\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyFront = 87;\nconst int KeyBack  = 83;\nconst int KeyUp    = 69;\nconst int KeyDown  = 81;\n\n/*\n\tA set of #define-s for camera and mouse handling\n\t\n\tWe will use the first 2 pixels of the buffer to store the information we need.\n\tEvery pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n\t\n\t\tpixel0 = (cameraX, cameraY, cameraZ)\n\t\tpixel1 = (U, V, mouseX, mouseY)\n\n\twhere \n\t\tcameraX, cameraY and cameraZ describe the position of the camera respectively\n\t\tU,V give the current rotation of the camera in spherical coordinates\n\t\t(mouseX, mouseY) is the position of the mouse while the left button is held\n*/\n\nvec4 px0, px1;\n\n#define loadPx0() px0 = texelFetch(iChannel0, ivec2(0,0), 0);\n#define loadPx1() px1 = texelFetch(iChannel0, ivec2(1,0), 0);\n\n#define pixel0 (fragCoord.x <1. && fragCoord.y <1.)\n#define pixel1 (fragCoord.x >=1.&& fragCoord.x <2. && fragCoord.y <1.)\n\n#define getCameraX() (px0.x)\n#define getCameraY() (px0.y)\n#define getCameraZ() (px0.z)\n\n#define setCameraX(p) if (pixel0) fragColor.x = p;\n#define setCameraY(p) if (pixel0) fragColor.y = p;\n#define setCameraZ(p) if (pixel0) fragColor.z = p;\n                   \n#define getU() (px1.x)\n#define getV() (px1.y)\n\n#define setU(p)       if (pixel1) fragColor.x = p;\n#define setV(p)       if (pixel1) fragColor.y = p;\n\n#define setMouseInit(p) if (pixel1) fragColor.zw = p;\n#define mouseInitPos()  (px1.zw)\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\n// Helper matrices\nmat3 ScaleXYZ(vec3 scale) {\n    return mat3(\n        vec3(scale.x, 0, 0),\n        vec3(0, scale.y, 0),\n        vec3(0, 0, scale.z)\n    );\n}\n\nmat3 RotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\n\nmat3 RotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 RotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Boolean helper functions\n// Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// Subtraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Signed Distance Functions\n// Plane - signed - exact\nfloat sdPlane( vec3 p, vec3 n, float d )\n{\n  return dot(p,normalize(n)) + d;\n}\n\n\n//Box - signed - exact\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Triangular Prism - signed - exact\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n// Ellipsoid - signed - bound\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Sphere - signed - exact\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Cone - signed - exact\nfloat sdCone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// Capped Cylinder - signed - exact\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct ray_t {\n    vec3 start;\n    vec3 direction;\n};\n\nconst float eps = 0.005;\nconst float pi = 3.1415926535897932384626433832795;\n\nfloat sdf(in vec3 p)\n{\n    float minDist = 1./0.;\n    \n    // Floor\n    minDist = opU(minDist, sdBox(vec3(p - vec3(0., -15., 0.)), vec3(100., 10., 100.)));\n    \n    for (int i=0; i<12; i++) {\n        float angle = float(i) * pi/6.;\n        vec3 ellPoint = (RotateZ(pi/4.) * RotateY(angle) * p);\n    \tminDist = opU(minDist, sdEllipsoid(vec3(ellPoint.x+5., ellPoint.yz), vec3(7.5,7.5,6.)));\n    }\n    float carvingPos;\n    minDist = opS(\n        sdEllipsoid(p + vec3(0.,-3., 0.),\n                    vec3(10.,6.,10.)),\n        minDist);\n    \n    vec3 pP;\n    \n    // Right Eye\n    carvingPos = -9.*pi/12.;\n    pP = (RotateZ(-pi/12.) * ScaleXYZ(vec3(0.75, 1.5, 1.)) * RotateY(carvingPos) * p);\n    minDist = opS(\n        sdTriPrism(\n            vec3(pP + vec3(0., -10, 7.)),\n            vec2(2.25, 5.)),\n        minDist);\n    \n    // Left Eye\n    carvingPos = -9.*pi/12.;\n    pP = (RotateZ(pi/12.) * ScaleXYZ(vec3(0.75, 1.5, 1.)) * RotateY(carvingPos) * p);\n    minDist = opS(\n        sdTriPrism(\n            vec3(pP + vec3(0., -10, 7.)),\n            vec2(2.25, 5.)),\n        minDist);\n    \n    // Nose\n    carvingPos = -9.*pi/12.;\n    pP = (RotateY(carvingPos) * p);\n    minDist = opS(\n        sdTriPrism(\n            vec3(pP + vec3(0., -5., 7.)),\n            vec2(1., 5.)),\n        minDist);\n    \n    // Mouth\n    // Bottom Lip\n    carvingPos = -3.*pi/12.;\n    pP = (RotateX(carvingPos) * RotateZ(pi/2.) * p);\n    float bottomLip =\n        sdCappedCylinder(\n            pP + vec3(5., -5., 0.),\n            vec2(5., 12.));\n    \n    // Top Lip\n    carvingPos = -3.*pi/12.;\n    pP = (RotateX(carvingPos) * RotateZ(pi/2.) * p);\n    float topLip =\n        sdCappedCylinder(\n            pP + vec3(9., -5., 0.),\n            vec2(7., 13.));\n    \n    minDist = opS(opS(topLip, bottomLip), minDist);\n    minDist = opI(minDist, sdSphere(p, 50.));\n    \n    \n    return minDist;\n}\n\nvec2 uv (vec3 p) {\n    return vec2(atan(p.x, p.z) / (2. * pi) + .5,\n                asin(p.y) / pi + .5);\n}\n\nfloat shadow(in vec3 p, in vec3 l, in vec3 n, out bool isShadow)\n{\n    isShadow = false;\n    float t = 0.1;\n    float lastd;\n    float res = 1.;\n    for(int i = 0; i < 64; i++)\n    {\n        lastd = sdf(p + t * l);\n    \tt += lastd;\n        if (lastd < eps)\n        {\n            res = 0.2;\n            isShadow = true;\n            break;\n        }\n    }\n    \n    res *= dot(n, l);\n    \n    return res;\n}\n\nfloat microfacet(in float alpha, in float m)\n{\n    return exp(-pow(tan(alpha), 2.) / pow(m, 2.)) /\n        (pi * pow(m, 2.) * pow(cos(alpha), 4.));\n}\n\nfloat fresnel(in float n1, in float n2, in vec3 V, in vec3 H)\n{\n    float R0 = pow((n1 - n2) / (n1 + n2), 2.);\n    return R0 + (1. - R0) * pow(1. - dot(V, H), 5.);\n}\n\nfloat geometric(in vec3 H, in vec3 N, in vec3 V, in vec3 L)\n{\n    return min(1.,\n               min((2. * dot(H, N) * dot(V, N)) / dot(V, H),\n                   (2. * dot(H, N) * dot(L, N)) / dot(V, H)));\n}\n\nvec3 normal(const in vec3 p)\n{\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)),sdf(p+vec3(0,eps,0)),sdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)),sdf(p-vec3(0,eps,0)),sdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec4 sphereTrace(const in ray_t ray)\n{\n    vec3 lightpos = vec3(cos(iTime) * 100., 100., sin(iTime) * 100.);\n    \n    vec3 center = vec3(0.);\n    vec4 col = vec4(0.);\n\tfloat t = 0.;\n    float lastd;\n    \n    int idx;\n    for (int i = 0; i < 64; i++) {\n        lastd = sdf(ray.start + t * ray.direction);\n    \tt += lastd;\n        if (lastd < eps) break;\n    }\n    \n    vec3 pos = ray.start + t * ray.direction;\n    vec3 nor = normal(pos);\n    vec3 tolight = normalize(lightpos - pos);\n    vec3 toeye = normalize(ray.start - pos);\n    vec3 halfangle = normalize(toeye + tolight);\n    \n    vec3 vec = normalize(pos - center);\n    \n    bool isShadow;\n    \n    float di = clamp(dot(tolight, nor), 0., 1.) * shadow(pos, tolight, nor, isShadow);\n    vec3 diffuse = texture(iChannel3, uv(normalize(vec))).xyz * di;\n    \n    vec3 specular = vec3(0.0);\n    float n1 = 1.5;\n    float n2 = 1.;\n    vec3 sColor = vec3(0., 1., 0.);\n        \n    // Cook Torrance\n    float alpha = acos(dot(nor, halfangle));\n        \n    float m = 0.1;\n    \n    if (dot(nor, tolight) > 0. && dot(nor, toeye) > 0. && !isShadow)\n    {\n        specular = sColor * (microfacet(alpha, m) *\n                    fresnel(n1, n2, toeye, halfangle) *\n                    geometric(halfangle, nor, toeye, tolight))\n            / (4. * (dot(toeye, nor) * dot(nor, tolight)));\n    }\n    \n    if (lastd < eps)\n        col = vec4(diffuse + specular, t);\n    else\n        col = vec4(texture(iChannel2, ray.direction).xyz, 1./0.);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Load the pixels(texels) in which we store camera information\n    loadPx0();\n    loadPx1();\n    \n    vec3 cameraPos = vec3(getCameraX(), getCameraY(), getCameraZ());\n    vec2 cameraRot = vec2(getU(), getV());\n    mat3 cameraRotMat = RotateY(cameraRot.y)*RotateX(cameraRot.x);\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2. + vec2(-1.,-1.);\n\n    float angleX = pi/2.;\n    float angleY = angleX * iResolution.y / iResolution.x;\n    float x = (uv.x) * angleX;\n    float y = (uv.y) * angleY;\n\n    ray_t ray;\n    ray.direction = normalize(cameraRotMat*vec3(x, y, 1));\n    ray.start = cameraPos;\n\n    fragColor = vec4(sphereTrace(ray));\n    \n    // Keyboard and mouse handling:  \n    const float v = 0.3;\n    vec3 rightDir = cameraRotMat*vec3(v, 0, 0);\n    vec3 upDir    = cameraRotMat*vec3(0, v, 0);\n    vec3 zoomDir  = cameraRotMat*vec3(0, 0, v);\n    if (isKeyHeld(KeyLeft )) cameraPos -= rightDir;\n    if (isKeyHeld(KeyRight)) cameraPos += rightDir;\n    if (isKeyHeld(KeyFront)) cameraPos += zoomDir;\n    if (isKeyHeld(KeyBack )) cameraPos -= zoomDir;\n    if (isKeyHeld(KeyUp   )) cameraPos += upDir;\n    if (isKeyHeld(KeyDown )) cameraPos -= upDir;\n    \n    setCameraX(cameraPos.x);\n    setCameraY(cameraPos.y);\n    setCameraZ(cameraPos.z);\n        \n    vec2 mouseInit = mouseInitPos();\n    if (mouseInit.x > 0.) {\n        const float camV = 0.03;\n        setU(cameraRot.x + sign(mouseInit.y-iMouse.y)*camV);\n        setV(cameraRot.y + sign(mouseInit.x-iMouse.x)*camV);\n        setMouseInit(iMouse.xy);\n    }\n    else {\n    \tsetU(cameraRot.x);\n        setV(cameraRot.y);\n    \tsetMouseInit(iMouse.zw);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define maxIter 1000.\n\nvec3 julia(vec2 z)\n{\n\tvec2 c = vec2(-0.55,0.55);\n\tfloat j = 0.0;\n\tfor(float i = 0.0; i < maxIter; i++)\n\t{\n\t\tz = vec2(z.x*z.x-z.y*z.y, z.x*z.y+z.x*z.y) + c;\n\t\tj = i;\n\t\tif(length(z) > 2.0) break;\n\t}\n\treturn vec3(j/16.0,j/32.0,j/64.0);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord/iResolution.xy/2.-0.25;\n\tvec3 col = julia(uv)/5.-0.55 + vec3(0.7, 0.3, 0.);\n\tfragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}