{"ver":"0.1","info":{"id":"dlSfWG","date":"1694465127","viewed":34,"name":"noise terrain w/ sun","username":"pugly","description":"noise terrain","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n    \n    col = texture(iChannel0, st).xyz;\n        \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Noise adapted from Inigo Quilez\nvec2 hash( in ivec2 p )  // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 2D -> 1D\n    ivec2 n = p.x*ivec2(3,37) + p.y*ivec2(311,113);\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*vec2( n & ivec2(0x0fffffff))/float(0x0fffffff);\n}\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0); \n    \n    vec2 ga = hash( i + ivec2(0,0) );\n    vec2 gb = hash( i + ivec2(1,0) );\n    vec2 gc = hash( i + ivec2(0,1) );\n    vec2 gd = hash( i + ivec2(1,1) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nvec3 fbm(vec2 x, mat2 rot) {\n\tvec3 v = vec3(0.);\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv += a * noised(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 GROUND_COL = vec3(0.73, 0.46, 0.29);\nconst vec3 SKY_COL = vec3(0.34, 0.96, 0.96);\n\nvec4 deriv(vec3 terr) {\n    return vec4( terr.x, normalize( vec3(-terr.y,1.0,-terr.z) ) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    mat2 rot = mat2(.8,.6,-.6,.8);\n    vec3 terr = vec3(fbm(fragCoord/100.+iTime/2., rot));\n    vec4 der = deriv(terr);\n    \n    float sky = dot(der.yzw, vec3(0.,1.,0.));\n    float sun = dot(der.yzw, normalize(vec3(mouse.x-.5,0.5,mouse.y-.5)));\n    \n    vec3 col = GROUND_COL*sun;\n    col += SKY_COL*sky*.1;\n    \n    fragColor = vec4(col,1);\n}","name":"Buffer A","description":"","type":"buffer"}]}