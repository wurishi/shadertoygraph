{"ver":"0.1","info":{"id":"fsjyWm","date":"1643629831","viewed":125,"name":"Yet Another Metaballs Experiment","username":"OldStarchy","description":"Learning how to make shaders, thought this would be fun.\n\nI wasn't planning on adding supersampling so it's done in a _really_ inefficient way.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n//https://www.shadertoy.com/view/XljGzV\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n// These functions should return >1 if the given position is inside the shape and <1 if its outside\n\nfloat circleDistance(in vec2 from, in vec2 center, in float size)\n{\n    return size / length(center - from);\n}\n\nfloat squareDistance(in vec2 from, in vec2 center, in float size, in float theta)\n{\n    vec2 posRelative = center - from;\n    \n    float s = sin(theta);\n    float c = cos(theta);\n    \n    posRelative = vec2(\n       c * posRelative.x - s * posRelative.y,\n       s * posRelative.x + c * posRelative.y\n    );\n    \n    vec2 d = abs(size / posRelative);\n    \n    // Flipping this turns the squares in to infinitely large + shapes\n    if (d.x < d.y)\n        return d.x;\n        \n    return d.y;\n}\n\n\nfloat pi2 = 3.141592654 * 2.0;\n\n\n\n\n// ****** CONFIG ******\nint circleCount = 50;\nfloat ballMinSize = 10.0;\nfloat ballMaxVariance = 30.0; // max size = minSize + variance\nfloat timeScale = 0.2;\nfloat glow = -1.0;\nfloat backlight = 0.0;\n\n\nvec3 samplePoint(vec2 fragCoord) {\n\nfloat infill = pow(5.0 * iMouse.x / iResolution.x, 2.0);\n\n    float circ = 0.0;\n    vec3 col = vec3(0,0,0);\n\n    float t = iTime * timeScale;\n    \n    for (int i = 0; i < circleCount; i++) {\n        highp float ran = rand(vec2(float(i), float(i)));\n        \n        float timeOffset = float(rand(\n            vec2(ran * 2.0, 1.0)\n        )) * 100.0;\n        \n        float xLoops = float(rand(\n            vec2(ran, 1.0)\n        ));\n        float yLoops = float(rand(\n            vec2(1.0, ran)\n        ));\n        float size = float(rand(\n            vec2(ran, ran)\n        )) * ballMaxVariance + ballMinSize;\n        \n        vec3 colour = hsl2rgb(vec3(\n            pi2 * float(rand(vec2(ran+1.0, ran))),\n            1.0,\n            0.6\n        ));\n        \n        vec2 position = size + (iResolution.xy-size*2.0) * vec2(\n            cos((timeOffset + t) * xLoops)/2.0+0.5,\n            sin((timeOffset + t) * yLoops)/2.0+0.5\n        );\n        \n        int type = int(rand(vec2(ran, ran+1.0))*2.0);\n        \n        float circl;\n\n        switch (type) {\n            case 0:\n                circl = pow(circleDistance(fragCoord.xy, position, size), 2.0);\n                break;\n            case 1:\n                float theta = float(rand(\n                    vec2(ran + 1.0, ran + 1.5)\n                )) + sin(t * 0.1) * 2.0 * pi2;\n                circl = pow(squareDistance(fragCoord.xy, position, size, theta), 2.0);\n                break;\n        }\n        circ += circl;\n        col += colour * circl;\n    }\n    \n    col = col / circ;\n    circ += glow;\n    \n    \n    if (circ < backlight)\n        circ = backlight;\n    // Black out the insides\n    if (circ > infill)\n        circ = 0.0;\n\n    vec3 finalCol = col * clamp(circ, 0.0, 1.0);\n\n    return finalCol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 4x Super sampling\n    vec3 col1 = samplePoint(fragCoord + vec2(0.2, 0.4));\n    vec3 col2 = samplePoint(fragCoord + vec2(-0.4, 0.2));\n    vec3 col3 = samplePoint(fragCoord + vec2(-0.2, -0.4));\n    vec3 col4 = samplePoint(fragCoord + vec2(0.4, -0.2));\n    \n    vec3 finalCol = (col1 + col2 + col3 + col4) * 0.25;\n    \n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}","name":"Image","description":"","type":"image"}]}