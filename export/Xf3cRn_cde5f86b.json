{"ver":"0.1","info":{"id":"Xf3cRn","date":"1730125434","viewed":233,"name":"How Toon Leaves Were Made","username":"SL0ANE","description":"虽然不是很复杂但是我想周三的时候和工友分享一下这个过程","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sdf","cartoon","anime"],"hasliked":0,"parentid":"l32fWV","parentname":"Toon Leaves"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LEAF_LENGTH 0.15\n#define LEAF_WIDTH 0.05\n#define LEAF_LENGTH_DELTA 0.02\n#define LEAF_WIDTH_DELTA 0.01\n\n#define BACKGROUND_COLOR vec4(0.9725, 0.9294, 0.8118, 1.0)\n#define DARK_COLOR vec4(0.12, 0.14, 0.18, 1.0)\n\n#define LEAF_COLOR_0 vec3(0.7686, 0.7882, 0.3176)\n#define LEAF_COLOR_1 vec3(0.3176, 0.3490, 0.2901)\n\n#define STAGE_TIME 2.0\n#define STAGE(x) smoothstep(STAGE_TIME * (float(x) + 0.5), STAGE_TIME * (float(x) + 1.0), iTime)\n#define LINEAR_STAGE(x) clamp((iTime - STAGE_TIME * (float(x) + 0.5)) / (STAGE_TIME / 2.0), 0.0, 1.0)\n#define MULTI_STAGE(x, y) smoothstep(STAGE_TIME * (float(x) + 0.5), STAGE_TIME * (float(y) + 1.0), iTime)\n\n#define LEAF_COLOR_3 vec3(0.8471, 0.4, 0.3725)\n#define LEAF_COLOR_4 vec3(0.3490, 0.2431, 0.3255)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y + vec2(iResolution.x / iResolution.y * -0.5, -0.5);\n    float col = 0.0;\n    float dis = 65535.0;\n    \n    float phi = 3.14159265359 * (3.0 - sqrt(5.0));\n    float numPoints = mix(0.0, 128.0, MULTI_STAGE(0, 4));\n    \n    float leafSpin = iTime * 0.1;\n    vec3 normal = vec3(1.0);\n    int id = -1;\n    \n    vec3 leafColor0 = mix(LEAF_COLOR_0, LEAF_COLOR_3, STAGE(11));\n    vec3 leafColor1 = mix(LEAF_COLOR_1, LEAF_COLOR_4, STAGE(11));\n    float isFruit = 0.0;\n    \n    for (float i = 0.0; i < numPoints; ++i) {\n    \n        float y = 1.0 - i / (numPoints - 1.0) * 2.0;\n        float r = sqrt(1.0 - y * y);\n        float theta = float(i) * phi;\n\n        vec3 originalCenter = vec3(cos(theta) * r, y, sin(theta) * r);\n        vec3 offset = mix(0.0, perlin(originalCenter, vec3(8.0), vec3(65535.0), vec3(0.0)), STAGE(7)) * originalCenter;\n        vec3 center = originalCenter + offset * 0.8;\n        center = center / 4.0f;\n        \n        float leaveLength = (hash13(originalCenter) - 0.5 * 2.0) * LEAF_LENGTH_DELTA + LEAF_LENGTH;\n        float leaveWidth = (hash13(originalCenter + vec3(0.2, 0.3, 0.7)) - 0.5 * 2.0) * LEAF_WIDTH_DELTA + LEAF_WIDTH;\n\n        float cosSpin = cos(leafSpin);\n        float sinSpin = sin(leafSpin);\n        float newX = center.x * cosSpin - center.z * sinSpin;\n        float newZ = center.x * sinSpin + center.z * cosSpin;\n        center.x = newX;\n        center.z = newZ;\n        \n        float leafVal = hash13(originalCenter + vec3(0.7, 0.2, 0.8));\n        bool fade = (leafVal < 0.1);\n        if(fade) center.xy += mix(vec2(0.0), vec2(-0.05, -0.4), STAGE(12));\n        \n        vec2 dir = normalize(mix(normalize(center.xy), vec2(0.0, -1.0), mix(0.0, 0.32, STAGE(6)))); \n        float sdf = mix(sdCircle(uv, center.xy, mix(0.0, 0.01, clamp(numPoints - i, 0.0, 1.0))),\n                        sdOrientedVesica(uv, center.xy + leaveLength / 2.0 * dir, center.xy - leaveLength / 2.0 * dir, leaveWidth),\n                        STAGE(5));\n                        \n        if(fade) sdf = mix(sdf, 0.0001, MULTI_STAGE(10.5, 12));\n        \n        float fruit = STAGE(14) * (leafVal > 0.9 ? 1.0 : 0.0);\n        sdf = mix(sdf, sdCircle(uv, center.xy, 0.05), fruit);\n        \n        if(sdf <= 0.0f && center.z < dis)\n        {\n            isFruit = fruit;\n            dis = center.z;\n            col = center.z * 2.0 + 0.5;\n            id = int(i);\n            normal = normalize(originalCenter);\n        }\n    }\n    \n    if(id == -1)\n    {\n        fragColor = mix(mix(vec4(0.0, 0.0, 0.0, 1.0), BACKGROUND_COLOR, STAGE(9)), DARK_COLOR, STAGE(11));\n        return;\n    }\n    \n    leafColor0 = mix(leafColor0, LEAF_COLOR_3.bgr * 1.618, isFruit);\n    leafColor1 = mix(leafColor1, LEAF_COLOR_4.bgr * 1.618, isFruit);\n    \n    float lightSpin = mix(0.0, max(iTime - 13.5 * STAGE_TIME, 0.0) * -1.5, STAGE(13));\n    vec3 lightDir = normalize(vec3(cos(lightSpin), -1, sin(lightSpin)));\n    \n    float ndotl = dot(-lightDir, normal);\n    ndotl *= smoothstep(0.8, 0.6, col);\n    ndotl = clamp(ndotl, 0.0, 1.0);\n    ndotl = pow(ndotl, 1.0 / 2.2);\n    ndotl += mix(0.0, hash13(normal + vec3(0.1, 0.2, 0.8)) / 4.0, STAGE(10));\n    ndotl = floor(ndotl * 4.0) / 4.0;\n    ndotl = clamp(ndotl, 0.0, 2.0);\n    \n    if(hash13(normal + vec3(0.7, 0.4, 0.1)) > 0.9) ndotl += mix(0.0, 1.0 / 4.0, STAGE(10));\n    \n    vec3 outputColor = mix(mix(vec3(1.0) * ((1.0 - col) * 0.5 + 0.5), normal * 0.5 + 0.5, STAGE(8)), mix(leafColor1, leafColor0, ndotl), STAGE(9));\n    \n    fragColor = vec4(outputColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"uint murmurHash13(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 3 inputs\nfloat hash13(vec3 src) {\n    uint h = murmurHash13(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 3 inputs\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat perlin(vec3 p, vec3 freq, vec3 rep, vec3 offset)\n{\n    p += offset / freq;\n    p *= freq;\n    vec3 gridSet = floor(p) + vec3(0.0, 0.0, 0.0);\n    vec3 dirSet = fract(p) - vec3(0.0, 0.0, 0.0);\n    // 必要时保证噪声在连接处连续\n    gridSet = mod(gridSet, rep * freq);\n    \n    vec3 gridLevel_000 = hash33(gridSet);\n    vec3 gridLevel_001 = hash33(gridSet + vec3(0.0, 0.0, 1.0));\n    vec3 gridLevel_010 = hash33(gridSet + vec3(0.0, 1.0, 0.0));\n    vec3 gridLevel_011 = hash33(gridSet + vec3(0.0, 1.0, 1.0));\n    vec3 gridLevel_100 = hash33(gridSet + vec3(1.0, 0.0, 0.0));\n    vec3 gridLevel_101 = hash33(gridSet + vec3(1.0, 0.0, 1.0));\n    vec3 gridLevel_110 = hash33(gridSet + vec3(1.0, 1.0, 0.0));\n    vec3 gridLevel_111 = hash33(gridSet + vec3(1.0, 1.0, 1.0));\n    \n    float product_000 = dot(gridLevel_000, dirSet);\n    float product_001 = dot(gridLevel_001, dirSet - vec3(0.0, 0.0, 1.0));\n    float product_010 = dot(gridLevel_010, dirSet - vec3(0.0, 1.0, 0.0));\n    float product_011 = dot(gridLevel_011, dirSet - vec3(0.0, 1.0, 1.0));\n    float product_100 = dot(gridLevel_100, dirSet - vec3(1.0, 0.0, 0.0));\n    float product_101 = dot(gridLevel_101, dirSet - vec3(1.0, 0.0, 1.0));\n    float product_110 = dot(gridLevel_110, dirSet - vec3(1.0, 1.0, 0.0));\n    float product_111 = dot(gridLevel_111, dirSet - vec3(1.0, 1.0, 1.0));\n    \n    float t_0 = pow(dirSet.x, 3.0) * (6.0 * pow(dirSet.x, 2.0) - 15.0 * dirSet.x + 10.0);\n    float t_1 = pow(dirSet.y, 3.0) * (6.0 * pow(dirSet.y, 2.0) - 15.0 * dirSet.y + 10.0);\n    float t_2 = pow(dirSet.z, 3.0) * (6.0 * pow(dirSet.z, 2.0) - 15.0 * dirSet.z + 10.0);\n    \n    float mix_x0 = mix(product_000, product_100, t_0);\n    float mix_x1 = mix(product_010, product_110, t_0);\n    float mix_y0 = mix(mix_x0, mix_x1, t_1);\n    \n    float mix_x2 = mix(product_001, product_101, t_0);\n    float mix_x3 = mix(product_011, product_111, t_0);\n    float mix_y1 = mix(mix_x2, mix_x3, t_1);\n    \n    return mix(mix_y0, mix_y1, t_2);\n}\n\nfloat sdOrientedVesica( vec2 p, vec2 a, vec2 b, float w )\n{\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n    return length( q-h.xy) - h.z;\n}\n\nfloat sdCircle( vec2 p, vec2 sdf_pos, float r )\n{\n    return length(p - sdf_pos) - r;\n}","name":"Common","description":"","type":"common"}]}