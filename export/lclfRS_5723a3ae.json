{"ver":"0.1","info":{"id":"lclfRS","date":"1723949381","viewed":47,"name":"experimental sound","username":"jorge2017a2","description":"experimental sound","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["experimentalsound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),0.,d - (b) )\n#define S3(d,b) smoothstep(0.25/antialiasing(0.5),0. , d - (b) )\n\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define HALFPI 1.5707\n\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\n\nfloat Sdf_I(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Sdf_U(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Sdf_D(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n\n\n\nvec3 DFB(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S3( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0),S3(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec3 DFS(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut;\n  return colOut;\n}\n\n// psuedo random noise foundation\nfloat randNoise(vec2 uv)\n{\n    // feel free to change these parameters, \n    // had them low for more floating point accuracy\n    return fract(sin(uv.x*63.+uv.y*59.+16.)*32672.93);\n}\n\n// grab a value of the randNoise function at each corner of squares set at a frequency\n// blending all those values together with smoothstep\nfloat valueNoise(vec2 uv, float frequency)\n{\n    vec2 localUV = smoothstep(0., 1., fract(uv*frequency));\n    vec2 id      = floor(uv*frequency);\n    \n    float bLeft  = randNoise(id);\n    float bRight = randNoise(id + vec2(1., 0.));\n    float tLeft  = randNoise(id + vec2(0., 1.));\n    float tRight = randNoise(id + vec2(1., 1.));\n    \n    float xLerp = mix(bLeft, bRight, localUV.x);\n    float yLerp = mix(tLeft, tRight, localUV.x);\n    \n    return mix(xLerp, yLerp, localUV.y);\n}\n\n// layering different frequencies of the smoother value noise at varying amplitudes \n// also called layered value noise\nfloat fractalNoise(vec2 uv, float depth)\n{\n    float addedNoise;\n    for (float i = 0.; i < depth; i++)\n    {\n        addedNoise += valueNoise(uv, pow(2., i))/pow(2., i);\n    }\n\n    // mapping all positive values [0,âˆž), to [0,1)\n    return atan(addedNoise)/HALFPI;\n}\n\n\nvec3 nubes(vec2 uv)\n{\n    float zoom = 4.0;\n    vec3 color = vec3(fractalNoise(uv*zoom+vec2(iTime,0.0), 10.));\n    return color;\n}\n\n\nvec3 nubesF(vec2 uv, float yp)\n{\n    float zoom = 5.0;\n    vec3 color = vec3(fractalNoise(uv*zoom+vec2(0.0, yp), 10.))*1.4;\n    return color;\n}\n\n\nvec3 nubes02(vec2 p, vec3 colout, float yp)\n{\n    \n    float d1= sdCircle(p-vec2(-0.55,0.0), 0.125 );\n    float d2= sdCircle(p-vec2(-0.4,-0.05), 0.075 );\n    float d3= sdCircle(p-vec2(-0.45,0.05), 0.0625 );\n    float d4= sdCircle(p-vec2(-0.65,-0.025), 0.075 );\n    float d5= sdCircle(p-vec2(-0.7,-0.05), 0.055 );\n    \n    float dt=Sdf_U(d1,d2);\n    dt=Sdf_U(dt,d3);\n    dt=Sdf_U(dt,d4);\n    dt=Sdf_U(dt,d5);\n    colout= DFB(vec3(1.0)*nubesF(p-vec2(0.5,1.0),yp), colout, dt);\n    \n    return colout;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n    uv-=vec2(0.0,0.5);\n    float esc=0.5;\n    uv*=esc;\n    vec2 q=uv;\n\n    vec3 col = vec3(0.3, 1.0, 0.1);\n    col = nubes(uv);\n    col= nubes02(q-vec2(-1.0+mod(iTime,2.5),-0.25), col,1.0);\n    \n    //draw stem--tronco poste\n    float r = 0.005;\n    //col *=1.0 - (1.0 - smoothstep(r, r+0.01, abs(q.x))) * (1.0-smoothstep(0.0, 0.01, q.y));\n    float d2=1.0 - (1.0 - smoothstep(r, r+0.01, abs(q.x))) * (1.0-smoothstep(0.0, 0.01, q.y));\n    col=mix(vec3(0.8,0.6,0.0),col,d2);\n    \n    //poste com diferencia\n    r = 0.005;\n    //col *=1.0 - (1.0 - smoothstep(r, r+0.01, abs(q.x))) * (1.0-smoothstep(0.0, 0.01, q.y));\n     d2=1.0 - (1.0 - smoothstep(r, r+0.01, abs(q.x))) * (1.0-smoothstep(0.0, 0.01, q.y));\n    //d2=abs(d2)-0.1;\n    col=mix(vec3(0.8,0.2,0.0),col,d2);\n    \n    \n    //rama\n     r = 0.2 + 0.1*cos(atan(q.x, q.y)*10.0 - 15.*q.x + 3.0);\n    //col *= smoothstep(r, r+0.01, length(q));\n    float d1= smoothstep(r, r+0.01, length(q));\n    //col=mix(vec3(0.0,1.0,0.0),vec3(0.0,0.3,1.0),d1);\n    col=mix(vec3(0.0,1.0,0.0),col,d1);\n    \n    \n    //ramas 2 chicos\n     r = 0.15 + 0.1*cos(atan(q.x, q.y)*10.0 - 15.*q.x + 3.0);\n     d1= smoothstep(r, r+0.01, length(q));\n    col=mix(vec3(0.1,0.8,0.1),col,d1);\n    \n        \n     //uv.y+=0.15;\n    if (uv.y<-0.6)\n        col=vec3(0.2,0.3,0.1);\n    \n    \n    col= nubes02(q, col,2.0);\n    col= nubes02(q-vec2(0.95,0.15), col,0.5);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Referencia de sonido \n//IQ,AeroShark333, Gaz ,etc. muchos :)\n//The Rhythm of the Night - Corona - Piano Tutorial\n//https://www.youtube.com/watch?v=Y397bOTV-ks\n\n#define PI acos(-1.)\n#define PIH (PI*.5)\n#define TAU (PI*2.)\n#define TWO_PI 6.2831\n\n\nconst float ttotal=35.0; \nconst float pi = 3.1415927;\nconst float tau = 6.283185;\nfloat ms;\nfloat mresp;\nfloat mtime;\nfloat mtempo;\n\n\n//https://www.shadertoy.com/view/ss3cDN\n// Created by AeroShark333\nfloat squareWave750( float f, float x)\n{ return (min(1.0, floor( 4.0 * floor( f * x ) - floor( 4.0 * f * x ) + 3.0 ))); }\n\nfloat squareWave500( float f, float x)\n{ return (floor( 2.0 * floor( f * x ) - floor( 2.0 * f * x ) + 1.0 )); }\n\nfloat squareWave250( float f, float x)\n{ return (max(0.0, floor( 4.0 * floor( f * x ) - floor( 4.0 * f * x ) + 1.0 ))); }\n\nvec2 squareWave250( vec2 f, float x)\n{ return (max(vec2(0.0), floor( 4.0 * floor( f * x ) - floor( 4.0 * f * x ) + 1.0 ))); }\n\nfloat triangleWave500( float q, float x)\n{ float f = 1.0-2.0*abs(0.5-mod(q*x,1.0));  return (f); }\n\nfloat triangleWave250( float q, float x)\n{ float f = max(0.0,1.0-2.0*abs(0.5-2.0*mod(q*x,1.0))); return (f); }\n\nfloat convertBassFreq (float f)\n{ return (f/2.0); }\n\nfloat  sawf(float t , float freq)\n{  return fract(t * freq) - 0.5; }\n\n\n\n\nfloat adsr( float a,float d,float s,float r,float du,float t)\n{  float res;\n\n if( t < a)\n {   // From t=0 to t=a (attack period)\n    res= t / a; // the volume increases from 0.0 to 1.0\n }\n else if( t < a + d) // From t=a to t=d (decay period)\n {  res= 1.0 - ((t - a) / d) * (1.0 - s); // the volume decreases from 1.0 to s (sustain)  \n }  \n else if( t < du) // From t=d to t=du (sustain period)\n {    res=s; // the volume stays constant at s (sustain)  \n }\n else if( t < (du + r) ) // From t=du to t=du+r (release period)\n {  res=(1.0 - (t - du)\n    / r) * s; // release\n }\n else\n {   res=0.0; // After that, the volume is 0.0.\n }\n  return res;\n} \n\n\n\nfloat wave1( float x, float dxdt, in vec2 v, float t , float w)\n{   float f2;\n    float sampleX=0.0;\n    float f=w;\n    \n     float a, d, s, r;\n    float du;\n    //a=0.2; d=0.2;s=0.4; r=0.2;\n    //a=0.3; d=0.1;s=0.4; r=0.2;\n    ///a=0.3; d=0.1;s=0.5; r=0.1;\n    //a=0.1; d=0.4;s=0.2; r=0.3;\n    a=0.1; d=0.4;s=0.4; r=0.1;\n    //a=0.1; d=0.1;s=0.4; r=0.4;\n    //a=0.4; d=0.2;s=0.1; r=0.3;\n    //a=0.5; d=0.1;s=0.1; r=0.3;\n    \n    \n    du=1.0;\n    float env= adsr( a, d,s,r,du,t);\n    sampleX =squareWave250(f,t)*triangleWave250(f,t)*env ;\n    \n    f2=(sampleX+sawf(t,f));\n    float fx=f2*1.5;\n    return fx;\n}\n\n\nfloat D3(float ton, float tid, float toff)\n{   vec3 n3;\n    float resp;\n    n3=vec3(ton,tid, toff);\n    \n    \n    if(ms>=ton && ms<=toff)\n    {      // lower one octave\n      n3.y -=12.; //12 notas\n      //n3.y +=12.; //12 notas\n\n      // compute note frequency and time  \n      float f = 440.0*pow( 2.0, float(n3.y-69.)/12.0 );\n      float t = mtime - float(n3.x)/mtempo;\n      if( n3.x==0.0 ) return 0.0;\n\n      // prepare wave parameters\n      float w = tau*f;\n      \n      float dwdt = w/iSampleRate; // derivative\n\n      // mix between bandlimited and raw saw waves  \n      vec2 v = smoothstep(-0.2,0.2,sin(t*vec2(1.0,0.5)) );\n      // build instrument\n\n      float f1,y;\n      f1=wave1(w*t,1.00*dwdt,v,t,w);\n      float wf  = 0.4*f1;\n      y=f1*wf;\n      float offset=n3.x;\n       y*=exp(-1.0/n3.z * (t -offset) );\n        \n       mresp+=y;\n    }\n    \n}\n\n\n\nfloat SoundIq(float time)\n{ ///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal);\n // tune\n  float tempo = 0.5;\n  float s = time*tempo;\n vec3 n3=vec3(0.0);\n \n //variables globales\n ms=s;\n mresp=0.0;\n mtime=time;\n mtempo=tempo;\n\n \n D3(0.000,56.0,0.125); D3(0.125,59.0,0.250); D3(0.250,23.0,1.250); D3(0.250,59.0,0.375); D3(0.375,57.0,0.500); D3(0.500,57.0,0.625);\n D3(0.625,56.0,0.688); D3(0.688,56.0,0.813); D3(0.813,54.0,1.000); D3(1.000,54.0,2.000); D3(1.250,23.0,2.250); D3(2.000,59.0,2.250);\n D3(2.250,23.0,3.250); D3(2.250,59.0,2.375); D3(2.375,57.0,2.500); D3(2.500,57.0,2.625); D3(2.625,56.0,2.750); D3(2.750,54.0,3.000);\n D3(3.000,56.0,3.125); D3(3.125,52.0,3.375); D3(3.250,21.0,4.250); D3(3.375,49.0,4.250); D3(4.250,21.0,4.875); D3(4.250,49.0,4.375);\n D3(4.375,52.0,4.500); D3(4.500,54.0,4.688); D3(4.688,56.0,4.750); D3(4.750,59.0,4.813); D3(4.813,56.0,5.000); D3(4.875,21.0,5.563);\n D3(5.000,49.0,5.063); D3(5.063,52.0,5.125); D3(5.125,49.0,5.188); D3(5.188,56.0,5.313); D3(5.313,49.0,5.438); D3(5.438,49.0,5.500);\n D3(5.500,47.0,5.563); D3(5.563,25.0,6.563); D3(5.563,49.0,6.563); D3(6.563,25.0,7.563); D3(6.688,56.0,6.813); D3(6.813,56.0,6.938);\n D3(6.938,56.0,7.063); D3(6.938,56.0,7.063); D3(7.063,61.0,7.188); D3(7.188,59.0,7.313); D3(7.313,56.0,7.438); D3(7.438,54.0,7.563);\n D3(7.563,21.0,8.563); D3(7.563,52.0,7.688); D3(7.688,49.0,8.313); D3(8.313,59.0,8.438); D3(8.438,58.0,8.563); D3(8.563,25.0,9.563);\n D3(8.563,59.0,8.688); D3(8.563,59.0,8.688); D3(8.688,56.0,9.313); D3(9.313,56.0,9.500); D3(9.500,54.0,10.500); D3(9.563,23.0,10.563);\n D3(10.500,56.0,10.563); D3(10.563,18.0,11.563); D3(10.563,61.0,10.688); D3(10.688,59.0,10.813); D3(10.813,56.0,10.938); D3(10.938,54.0,11.000);\n D3(11.000,52.0,11.188); D3(11.188,49.0,11.688); D3(11.563,18.0,12.563); D3(11.688,56.0,11.813); D3(11.813,56.0,11.938); D3(11.938,56.0,12.063);\n D3(12.063,61.0,12.188); D3(12.188,59.0,12.313); D3(12.313,56.0,12.438); D3(12.438,54.0,12.563); D3(12.563,21.0,13.563); D3(12.563,52.0,12.688);\n D3(12.688,49.0,13.313); D3(13.313,59.0,13.438); D3(13.438,56.0,13.563); D3(13.563,25.0,14.563); D3(13.563,59.0,13.688); D3(13.688,56.0,14.313);\n D3(14.313,56.0,14.500); D3(14.500,54.0,15.500); D3(14.563,23.0,15.563); D3(15.500,56.0,15.563); D3(15.563,18.0,16.563); D3(15.563,61.0,15.688);\n D3(15.688,59.0,15.813); D3(15.813,56.0,15.938); D3(15.938,54.0,16.000); D3(16.000,52.0,16.188); D3(16.188,49.0,17.188); D3(16.563,18.0,17.188);\n \n \n  return mresp;\n}\n\nvec2 mainSound( in int samp, float time )\n{ float t1=mod(time, ttotal);\n  float y= SoundIq(t1)*0.5;\n  return vec2(y);\n}   \n","name":"Sound","description":"","type":"sound"}]}