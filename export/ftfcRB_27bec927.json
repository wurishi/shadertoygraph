{"ver":"0.1","info":{"id":"ftfcRB","date":"1648160043","viewed":60,"name":"Zinedine","username":"zinedine","description":"un temple","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["zinedine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2022.02.06\n// Zinedine Zidane \n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Primitives \n\n// Sphere \n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p, vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n// Sphere \n// p : point\n// n : Normal of plane\n// o : Point on plane\nfloat Plane(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\nfloat Boite(vec3 p, vec3 c, vec3 d)\n{\n    float dxc = Plane(c, vec3(1, 0, 0), p);\n    float dxd = Plane(d, vec3(-1, 0, 0), p);\n    float x = max(dxc, dxd);\n    \n    float dyc = Plane(c, vec3(0, 1, 0), p);\n    float dyd = Plane(d, vec3(0, -1, 0), p);\n    float y = max(dyc, dyd);\n    \n    float dzc = Plane(c, vec3(0, 0, 1), p);\n    float dzd = Plane(d, vec3(0, 0, -1), p);\n    float z = max(dzc, dzd);\n    \n    float boite = max(max(x,y), z);\n    return boite;\n}\n\n\nfloat Tore( vec3 p, vec2 c )\n{\n  vec2 res = vec2(length(p.xz)-c.x,p.y);\n  return length(res)-c.y;\n}\n\n\nfloat Segment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    float l = dot(ap, normalize(ab));\n    if(l < 0.0)\n    {\n        return length(ap);\n    }\n    else if(dot(ab, (p-b)) > 0.0)\n    {\n        return length(p-b);\n    }\n    else\n    {\n        return sqrt(length(ap)*length(ap)-(l*l));\n    }\n}\n\n//Capsule\nfloat Capsule (vec3 p, vec3 c, vec3 d, float r)\n{\n     return Segment(p, c, d) - r;   \n}\n\nfloat Cylindre (vec3 p, vec3 c, vec3 d, float r)\n{\n      float capsule = Capsule(p, c, d, r);\n      float planeA = Plane(p, normalize(d-c), c);\n      float planeB = Plane(p, normalize(c-d), d);\n      capsule = max(capsule, -planeA);\n      capsule = max(capsule, -planeB);\n      return capsule; \n}\n\n\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union2(float a,float b)\n{\n    return min(a,b);\n}\n\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union4(float a,float b,float c,float d)\n{   float r = min(a,b);\n    float s = min(c,d);\n    return min(r,s);\n}\n\nfloat Union8(float a,float b,float c,float d,float e,float f,float g,float h)\n{   float r = min(a,b);\n    float s = min(c,d);\n    float t = min(e,f);\n    float u = min(g,h);\n    float v = min(r,s);\n    float w = min(t,u);\n    return min(v,w);\n}\n\n// Intersection\n// a,b : field function of left and right sub-trees\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\n\n//Difference\nfloat Difference(float a,float b)\n{\n    return max(a,-b);\n}\n\n// Translation\nvec3 Translate(vec3 p, vec3 t)\n{\n    return p-t;\n}\n\n#define PI 3.1415926538\n\nfloat Degtorad(float d)\n{\n    return d*PI/180.0;\n}\n\n// Rotations\nvec3 RotateX(vec3 p, float T)\n{\n    T = Degtorad(T);\n    float c = cos(-T);\n    float s = sin(-T);\n    mat3 m;\n    m[0] = vec3(1.0, 0.0, 0.0);\n    m[1] = vec3(0.0, c, s);\n    m[2] = vec3(0.0, -s, c);\n    return m*p;\n}\n\n//Colonne\nfloat Colonne(vec3 p, float hC, float hB, float r)\n{\n    float v = Union2(Cylindre(p, vec3(0.0, 0.0, hB), vec3(0.0, 0.0, hC+hB), r), Boite(p, vec3(-r, -r, 0.0), vec3(r, r, hB)));\n    v = Union2(v, Boite(p, vec3(-r, -r, hC+hB), vec3(r, r, (hC+hB+hB)))); \n    v = Union2(v, Tore(RotateX(Translate(p, vec3(0.0, 0.0, hB+hC)), 90.0), vec2(r, 0.4)));\n    v = Union2(v, Tore(RotateX(Translate(p, vec3(0.0, 0.0, hB)), 90.0), vec2(r, 0.4)));\n    return v;\n}\n\n//Escaliers\nfloat EscaliersAV(vec3 p, int quantite, float largeur, float longueur, float hauteur)\n{\n    float s = 1.0;//Box(p, vec3(0.0, 0.0, 0.0), vec3(largeur, longueur, hauteur));\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    quantite--;\n    for(i=0.0;i<=float(quantite);i++)\n    {\n        s = Union2(s, Boite(p, vec3(largeur*i, longueur, hauteur*i), vec3(largeur*(i+1.0), longueur*2.0, hauteur*(i+1.0))));\n        \n  \n    }\n    for(j=0.0;j<=float(quantite-1);j++)\n    {\n        s = Union2(s, Boite(p, vec3(largeur*j+largeur, longueur, hauteur*j), vec3(largeur*(j+1.0)+largeur, longueur*2.0, hauteur*(j+1.0))));\n        \n  \n    }\n    for(k=0.0;k<=float(quantite-2);k++)\n    {\n        s = Union2(s, Boite(p, vec3(largeur*k+(largeur+largeur), longueur, hauteur*k), vec3(largeur*(k+1.0)+largeur+largeur, longueur*2.0, hauteur*(k+1.0))));\n        \n  \n    }\n    \n    \n    return s;\n}\n\n//Escaliers\nfloat EscaliersAR(vec3 p, int quantite, float largeur, float longueur, float hauteur)\n{\n    float s = 1.0;//Box(p, vec3(0.0, 0.0, 0.0), vec3(largeur, longueur, hauteur));\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    quantite--;\n    for(i=0.0;i<=float(quantite);i++)\n    {\n        s = Union2(s, Boite(p, vec3(largeur, longueur, hauteur*i), vec3(largeur*2.0, longueur*2.0, hauteur*(i+1.0))));\n        \n  \n    }\n    for(j=0.0;j<=float(quantite-1);j++)\n    {\n        s = Union2(s, Boite(p, vec3(largeur+largeur, longueur, hauteur*j), vec3(largeur+(largeur*2.0), longueur*2.0, hauteur*(j+1.0))));\n        \n  \n    }\n    for(k=0.0;k<=float(quantite-2);k++)\n    {\n        s = Union2(s, Boite(p, vec3(largeur+(largeur+largeur), longueur, hauteur*k), vec3(largeur+(largeur*2.0)+largeur, longueur*2.0, hauteur*(k+1.0))));\n        \n  \n    }\n    \n    \n    return s;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  float v = 1.0; \n\n    v = Union2(v, Boite(p, vec3(0, -22.0, -6), vec3(43.0, 22.0, 0.0)));\n    v = Union2(v, EscaliersAV(Translate(p, vec3(-13.0, -30.0, -6.0)), 3, 4.33, 20.0, 2.0));\n    v = Union2(v, EscaliersAR(Translate(p, vec3(38.0, -30.0, -6.0)), 3, 4.33, 20.0, 2.0));\n    v = Union2(v, Colonne(Translate(p, vec3(1.5, 18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(1.5, -18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(6.5, 18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(6.5, -18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(11.5, 18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(11.5, -18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(16.5, 18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(16.5, -18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(21.5, 18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(21.5, -18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(26.5, 18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(26.5, -18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(31.5, 18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(31.5, -18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(36.5, 18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(36.5, -18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(41.5, 18.8, 0.0)), 5.9, 1.0, 1.5));\n    v = Union2(v, Colonne(Translate(p, vec3(41.5, -18.8, 0.0)), 5.9, 1.0, 1.5));\n  //  v = Union(v, Box(p, vec3(20, -22.0, -6), vec3(43, 22.0, 0.0)));\n    v = Union2(v, Boite(p, vec3(0, -22.0, 7.9), vec3(43.0, 22.0, 7.95)));\n   \n    return v;\n          \n          \n          \n          \n          \n          \n          \n         \n\n  return v;\n}\n\n// Analysis of the scalar field \n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n  // Start at the origin\n  float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v < 0.0)\n      {\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Lighting \n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// r : Radius for ambient occlusion\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n, float r, int a)\n{\n    if (a==0) { return 1.0; }\n    \n\tfloat ao=0.0; \n    \n    for (int i=0;i<a;i++)\n    {\n \t\tvec3 d = Cosine(581.123*float(i) , n);\n\n        int s;\n        bool h;\n        float t=SphereTrace(p,d,r,h,s);\n        if (!h) {ao+=1.0;}\n    }\n    \n    ao/=float(a);\n\treturn ao;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.45,0.55,0.99),vec3(0.65,0.69,0.99), d.z*0.5+0.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p+0.1*n,l,100.0,h,s);\n    if (!h)\n    {\n      return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    // Ambient color\n    vec3 ambient = 0.25+0.25*background(n);\n    \n    // Ambient occlusion\n    ambient += 0.15 * AmbientOcclusion(p+0.1*n,n,5.0,0) * vec3(1.0,1.0,1.0);\n    \n    // Shadow computation\n    float shadow = Shadow(p,n,l);\n    \n    // Phong diffuse\n    vec3 diffuse = 0.35  * clamp(dot(n, l),0.0,1.0) * vec3(1.0,1.0,1.0);\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = 0.15 * pow(clamp(dot(r,l),0.0,1.0),30.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + shadow * (diffuse + specular);\n    return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t = float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p = (-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip = true;\n    }\n       else\n       {\n           pip = false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Modeling\n// Eric Galin\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( float seed, vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m, vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.5;\n    \n    // Origin\n    ro=vec3(37.0,0.0,15.0);\n    ro*=Rz(a); \n\n    // Target\n    vec3 ta = vec3(0.0,0.0,1.0);\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n","name":"Common","description":"","type":"common"}]}