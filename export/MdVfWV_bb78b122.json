{"ver":"0.1","info":{"id":"MdVfWV","date":"1530648217","viewed":95,"name":"Dykstra's projection algorithm","username":"TinyTexel","description":"shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by TinyTexel\n\n/*\n\n*/\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat SqrLen(vec2 v) { return dot(v, v); }\nfloat SqrLen(vec3 v) { return dot(v, v); }\n\nvec2 CosSin(float ang) { return vec2(cos(ang), sin(ang)); }\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\nfloat Graph(float f)\n{\n    return clamp01(1.0 - (abs(rescale(f)))); \n}\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Line(vec2 sp, vec2 lp, vec2 ld, float lt)\n{\n    float v = abs(dot(sp - lp, vec2(-ld.y, ld.x))) - lt;\n        \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;    \n}\n\nfloat Line(vec2 sp, vec2 lp, vec2 ld, float ll, float lt)\n{\n\tfloat l0 = Line(sp, lp, ld, lt);\n\tfloat l1 = Line(sp, lp, vec2(-ld.y, ld.x), ll);\n    \n    return l0 * l1;    \n}\n\nfloat Line2(vec2 sp, vec2 lp0, vec2 lp1, float lt)\n{    \n    vec2 vec0 = sp - lp0;\n    \n    vec2 vec = lp1 - lp0;\n    \n    vec2 lp = lp0 + vec * clamp(dot(sp - lp0, vec / SqrLen(vec)), 0.0, 1.0);\n    \n    float v = length(sp - lp) - lt;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;  \n}\n\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}\n\nfloat Circle(vec2 sp, vec2 cp, float cr, float ct)\n{\n    float v = length(sp - cp) - cr;\n\n    v = abs(v) - ct;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v, 0.0, 1.0);\n    \n    return v;\n}\n\nvoid Setting0(inout vec3 col, vec2 tex)\n{\n    vec2 cp = vec2(1.0, 1.0);\n    float cr = 0.5;\n    \n\tcol = mix(col, vec3(1.0, 0.05, 0.0), Circle(tex.xy, cp, cr, 0.01));\n    \n    vec2 lp = vec2(1.0, 1.0);\n    vec2 ld = CosSin(0.75 * Pi);\n    \n\tcol = mix(col, vec3(0.1, 1.0, 0.0), Line(tex.xy, lp, ld, 0.005)); \n        \n\t//col = mix(col, vec3(0.1, 1.0, 0.0), Line2(tex.xy, vec2(1.0, 1.0), vec2(0.0, 0.5), 0.005)); \n    \n    vec2 pos = vec2(1.0, 0.25);\n    vec2 p = vec2(0.0);\n    vec2 q = vec2(0.0);\n    \n    for(float i = 0.0; i < 4.0; ++i)\n    {        \n    \tcol = mix(col, vec3(0.0, 0.05, 1.0), Dot(tex.xy, pos, 0.02));\n    \n        vec2 pos00 = pos;\n        pos += p;\n        \n    \tvec2 pos0 = pos;\n    \n        if(SqrLen(pos - cp) > cr * cr)\n        pos = cp + normalize(pos - cp) * cr;\n        \n        p = pos0 - pos;\n        \n        col = mix(col, vec3(0.0, 0.4, 1.0), Line2(tex.xy, pos00, pos, 0.002)); \n    \tcol = mix(col, vec3(0.0, 0.05, 1.0), Dot(tex.xy, pos, 0.02));\n        \n        pos00 = pos;\n       \n        pos += q;\n        \n        pos0 = pos;\n        pos = lp + ld * dot(pos - lp, ld);\n        \n        q = pos0 - pos;\n        \n        col = mix(col, vec3(0.0, 0.4, 1.0), Line2(tex.xy, pos00, pos, 0.002)); \n    }\n        \n}\n\nvoid Setting1(inout vec3 col, vec2 tex)\n{    \n    vec2 lp0 = vec2(1.0, 1.0);\n    vec2 ld0 = CosSin(0.75 * Pi);\n    \n\tcol = mix(col, vec3(0.1, 1.0, 0.0), Line(tex.xy, lp0, ld0, 0.005)); \n        \n\n    vec2 lp1 = vec2(0.0, 0.5);\n    vec2 ld1 = CosSin(0.125 * Pi);\n    \n\tcol = mix(col, vec3(0.1, 1.0, 0.0), Line(tex.xy, lp1, ld1, 0.005)); \n    \n    \n    vec2 lp2 = vec2(0.25, 0.5);\n    vec2 ld2 = CosSin(-0.05 * Pi);\n    \n\tcol = mix(col, vec3(0.1, 1.0, 0.0), Line(tex.xy, lp2, ld2, 0.005)); \n    \n    \n    vec2 pos = vec2(1.0, 0.25);\n    vec2 p = vec2(0.0);\n    vec2 q = vec2(0.0);\n    vec2 r = vec2(0.0);\n    \n    for(float i = 0.0; i < 4.0; ++i)\n    {        \n    \tcol = mix(col, vec3(0.0, 0.05, 1.0), Dot(tex.xy, pos, 0.02));\n    \n        vec2 pos00 = pos;\n        pos += p;\n        \n    \tvec2 pos0 = pos;\n    \n        pos = lp0 + ld0 * dot(pos - lp0, ld0);\n        \n        p = pos0 - pos;\n        \n        col = mix(col, vec3(0.0, 0.4, 1.0), Line2(tex.xy, pos00, pos, 0.002)); \n    \tcol = mix(col, vec3(0.0, 0.05, 1.0), Dot(tex.xy, pos, 0.02));\n        \n        pos00 = pos;\n       \n        pos += q;\n        \n        pos0 = pos;\n        pos = lp1 + ld1 * dot(pos - lp1, ld1);\n        \n        q = pos0 - pos;\n        \n        col = mix(col, vec3(0.0, 0.4, 1.0), Line2(tex.xy, pos00, pos, 0.002)); \n    \tcol = mix(col, vec3(0.0, 0.05, 1.0), Dot(tex.xy, pos, 0.02));\n                \n        pos00 = pos;\n       \n        pos += r;\n        \n        pos0 = pos;\n        pos = lp2 + ld2 * dot(pos - lp2, ld2);\n        \n        r = pos0 - pos;\n        \n        col = mix(col, vec3(0.0, 0.4, 1.0), Line2(tex.xy, pos00, pos, 0.002)); \n                \n    }       \n}\n\nvoid Setting1b(inout vec3 col, vec2 tex)\n{    \n    vec2 lp0 = vec2(1.0, 1.0);\n    vec2 ld0 = CosSin(0.75 * Pi);\n    \n\tcol = mix(col, vec3(0.1, 1.0, 0.0), Line(tex.xy, lp0, ld0, 0.005)); \n        \n\n    vec2 lp1 = vec2(0.0, 0.5);\n    vec2 ld1 = CosSin(0.125 * Pi);\n    \n\tcol = mix(col, vec3(0.1, 1.0, 0.0), Line(tex.xy, lp1, ld1, 0.005)); \n    \n    \n    vec2 lp2 = vec2(0.25, 0.5);\n    vec2 ld2 = CosSin(-0.05 * Pi);\n    \n\tcol = mix(col, vec3(0.1, 1.0, 0.0), Line(tex.xy, lp2, ld2, 0.005)); \n    \n    \n    vec2 pos = vec2(1.0, 0.25);\n    vec2 p = vec2(0.0);\n    vec2 q = vec2(0.0);\n    vec2 r = vec2(0.0);\n    \n    for(float i = 0.0; i < 3.0; ++i)\n    {        \n    \tcol = mix(col, vec3(0.0, 0.05, 1.0), Dot(tex.xy, pos, 0.01));\n    \n        vec2 posA = lp0 + ld0 * dot(pos - lp0, ld0);\n        vec2 posB = lp1 + ld1 * dot(pos - lp1, ld1);\n        vec2 posC = lp2 + ld2 * dot(pos - lp2, ld2);\n        \n        vec2 pos0 = pos;\n        \n        //pos = mix(pos, (posA + posB + posC) / 3.0, 1.26);  \n        pos = (posA + posB + posC) - min(posA, min(posB, posC)) - max(posA, max(posB, posC));\n        \n        col = mix(col, vec3(0.0, 0.4, 1.0), Line2(tex.xy, pos0, pos, 0.002));         \n    }  \n    \n    col = mix(col, vec3(1.0, 0.05, 0.0), Dot(tex.xy, pos, 0.005));\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += .0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.125;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.25+0.0375;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    Setting0(col, tex);\n\n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}","name":"Image","description":"","type":"image"}]}