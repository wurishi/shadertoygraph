{"ver":"0.1","info":{"id":"tddSRn","date":"1571399310","viewed":194,"name":"Voronoi diagram on sphere","username":"g2_xpf","description":"Click to place a new point.\nHave fun !!!","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PHONG\nconst float PI = 3.141592;\nvec3 getCameraPos(float t) {\n    float theta = t;\n    float phi = t/2.;\n    return 2. * vec3(\n    \tsin(PI/3. + PI/6. * cos(phi)) * cos(t),\n        cos(PI/3. + PI/6. * cos(phi)),\n        sin(PI/3. + PI/6. * cos(phi)) * sin(t)\n    );\n}\n\nconst ivec2 POINT_INFO_COORD = ivec2(0, 0);\nconst ivec2 POINT_INIT_COORD = ivec2(0, 1);\n\nconst float LIGHT_RANGE = 0.03;\nconst float SHADOW_RANGE = 0.02;\nconst float MAX_DARKNESS = 0.4;\n\nconst float DEPTH = 1.5;\nconst vec3 SPHERE_POS = vec3(0, 0, 0);\nconst float SPHERE_RADIUS = 1.;\nconst float EPS = 1e-3;\nconst vec3 LIGHT_DIR = vec3(-1, 1, 1);\n\nvec4 readi(ivec2 coord) {\n    return texelFetch(iChannel0, coord, 0);\n}\n\nfloat rand(vec2 uv){\n    return fract(sin(dot(uv ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nstruct Ray {\n    vec3 dir;\n    vec3 src;\n};\n\nvec3 getColor(in vec3 collisionPos, in ivec2 resolution) {    \n    int pointCnt = int(readi(POINT_INFO_COORD).x);\n    float minPrimDist = 1e9F-1.;\n    float minSecDist = 1e9F;\n    vec3 primNearest = vec3(1.);\n    vec3 secNearest = vec3(1.);\n    \n    for(int i = 0;i < pointCnt; i++) {\n        ivec2 cur = POINT_INIT_COORD + ivec2(i%resolution.x, i/resolution.y);\n        vec4 maybePoint = readi(cur);\n        // assert!(maybePoint.w > 0);\n        float dist = length(collisionPos - maybePoint.xyz);\n        if(minPrimDist > dist) {\n            // primary -> secondary\n            minSecDist = minPrimDist;\n            secNearest = primNearest;\n            // new -> primary\n            minPrimDist = dist;\n            primNearest = maybePoint.xyz;\n        } else if(minSecDist > dist) {\n            // new -> secondary\n            minSecDist = dist;\n            secNearest = maybePoint.xyz;\n        }\n    }\n    \n    float r = 0.7 * rand(primNearest.xy) + 0.3;\n    float g = 0.7 * rand(primNearest.yz) + 0.3;\n    float b = 0.7 * rand(primNearest.zx) + 0.3;\n    \n    if(minPrimDist < LIGHT_RANGE) {\n        // [f, 0] -> [v, 1] linear transformation M\n        //   where \n        //     M * f = v  M * 0 = v\n        //         1   1,     1   1\n     \n        r = (mat2(vec2((r-1.)/LIGHT_RANGE, 0), vec2(1.)) * vec2(minPrimDist, 1)).x;\n        g = (mat2(vec2((g-1.)/LIGHT_RANGE, 0), vec2(1.)) * vec2(minPrimDist, 1)).x;\n        b = (mat2(vec2((b-1.)/LIGHT_RANGE, 0), vec2(1.)) * vec2(minPrimDist, 1)).x;\n    }\n    \n    if(pointCnt >= 2) {\n    \tvec3 collNorm = normalize(collisionPos); // normal vector of the collision point\n    \tvec3 primToSec = normalize(secNearest - primNearest);\n    \tvec3 toNearestBorder = SPHERE_RADIUS * cross(cross(primToSec, collisionPos), primToSec) - SPHERE_RADIUS * collNorm;\n    \tfloat diff = length(toNearestBorder);\n    \t// [0 -> SHADOW_RANGE] -> [MAX_DARKNESS, 0]\n        //\n    \t// p q 0 = md q = md  p q sr = 0  p*sr + q = 0 p = -md/sr\n    \t// r s 1   1  s =  1  r s 1    1  r*sr + s = 1 r = 0\n    \tfloat darkness = clamp((mat2(vec2(-MAX_DARKNESS/SHADOW_RANGE, 0), vec2(MAX_DARKNESS, 1)) * vec2(diff, 1)).x, 0., MAX_DARKNESS);\n    \n    \tr -= darkness;\n    \tg -= darkness;\n    \tb -= darkness;\n    }\n    \n    return vec3(r, g, b);\n    // return vec3(.5);\n}\n\nfloat distFunc(vec3 raySrc){\n    return length(SPHERE_POS - raySrc) - SPHERE_RADIUS;\n}\n\nvec3 getNormal(vec3 raySrc) {\n    vec3 dx = vec3(EPS, 0, 0);\n    vec3 dy = vec3(0, EPS, 0);\n    vec3 dz = vec3(0, 0, EPS);\n\n    return normalize(vec3(\n                distFunc(raySrc + dx) - distFunc(raySrc - dx),\n                distFunc(raySrc + dy) - distFunc(raySrc - dy),\n                distFunc(raySrc + dz) - distFunc(raySrc - dz)\n                ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec3 CAMERA_POS = getCameraPos(iTime);\n    vec3 CAMERA_TARGET = vec3(0.);\n\n    vec3 tmp = vec3(0., 1., 0.);\n    vec3 cameraForward = normalize(CAMERA_POS - CAMERA_TARGET);\n    vec3 cameraRight = normalize(cross(tmp, cameraForward));\n    vec3 cameraUp = normalize(cross(cameraForward, cameraRight));\n    \n    mat4 rotate = mat4(\n        vec4(cameraRight,   0.),\n    \tvec4(cameraUp,      0.),\n    \tvec4(cameraForward, 0.),\n    \tvec4(vec3(0.),      1.));\n    mat4 translate = transpose(mat4(\n        vec4(1,0,0,0),\n        vec4(0,1,0,0), \n        vec4(0,0,1,0),\n        vec4(CAMERA_POS, 1)));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec4 rayDir = translate * rotate * vec4(uv, -DEPTH, 1.0);\n    // vec4 rayDir = vec4(vec3(uv, -DEPTH_WIDTH) * vec3(sin(FOV), sin(FOV), -cos(FOV)), 1.0);\n    Ray ray = Ray (\n            normalize(rayDir.xyz),\n            CAMERA_POS\n            );\n\n    float len;\n    for(int i = 0; i < 60; ++i) {\n        len = distFunc(ray.src);\n        if(len < EPS) {\n            break;\n        }\n        ray.src += len * ray.dir;\n    }\n\n    if(len < EPS) { // collide\n        vec3 normal = getNormal(ray.src);\n        vec3 color = getColor(ray.src, ivec2(iResolution));\n\n#ifdef PHONG\n        float specular = pow(clamp(dot(\n                        normalize(CAMERA_POS - ray.src) , // a vector from surface to the camera\n                        normalize(2. * dot(normal, LIGHT_DIR) * normal - LIGHT_DIR) // reflection vector\n                        ), 0., 1.), 30.);\n        float diffuse = 0.5 * dot(normalize(LIGHT_DIR), normal);\n        float ambient = 0.7;\n\n        fragColor = vec4(color * clamp(ambient + diffuse + specular, 0., 1.), 1.0);\n#else\n        fragColor = vec4(color, 0.);\n#endif\n    }else {\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.141592;\nvec3 getCameraPos(float t) {\n    float theta = t;\n    float phi = t/2.;\n    return 2. * vec3(\n    \tsin(PI/3. + PI/6. * cos(phi)) * cos(theta),\n        cos(PI/3. + PI/6. * cos(phi)),\n        sin(PI/3. + PI/6. * cos(phi)) * sin(theta)\n    );\n}\n\n// -- raytracing ----------------------------------------\nconst float DEPTH = 1.5;\nconst vec3 SPHERE_POS = vec3(0, 0, 0);\nconst float SPHERE_RADIUS = 1.;\nconst float EPS = 1e-3;\nconst vec3 LIGHT_DIR = vec3(-1, 1, 1);\n\nconst float ANGLE = 60.;\nconst float FOV = ANGLE * .5 * PI / 180.;\nconst float F = 1000.;\nconst float N = 2.0;\n\nstruct Ray {\n    vec3 dir;\n    vec3 src;\n};\n\nfloat distFunc(vec3 raySrc){\n    return length(SPHERE_POS - raySrc) - SPHERE_RADIUS;\n}\n\n// FragCoord -> Option<CollisionPoint>\n//\n// this function returns P where\n// P.w > 0   => Some(P.xyz) // collide\n// _         => None        // not collide\nvec4 tryCollide(in vec2 fragCoord){    \n    vec3 CAMERA_POS = getCameraPos(iTime);\n    vec3 CAMERA_TARGET = vec3(0.);\n\n    vec3 tmp = vec3(0., 1., 0.);\n    vec3 cameraForward = normalize(CAMERA_POS - CAMERA_TARGET);\n    vec3 cameraRight = normalize(cross(tmp, cameraForward));\n    vec3 cameraUp = normalize(cross(cameraForward, cameraRight));\n    \n    mat4 rotate = mat4(\n        vec4(cameraRight,   0.),\n    \tvec4(cameraUp,      0.),\n    \tvec4(cameraForward, 0.),\n    \tvec4(vec3(0.),      1.));\n    mat4 translate = transpose(mat4(\n        vec4(1,0,0,0),\n        vec4(0,1,0,0), \n        vec4(0,0,1,0),\n        vec4(CAMERA_POS, 1)));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec4 rayDir = translate * rotate * vec4(uv, -DEPTH, 1.0);\n\n    Ray ray = Ray (\n            normalize(rayDir.xyz),\n            CAMERA_POS\n            );\n\n    float len;\n    for(int i = 0; i < 60; ++i) {\n        len = distFunc(ray.src);\n        if(len < EPS) {\n            break;\n        }\n        ray.src += len * ray.dir;\n    }\n\n    if(len < EPS) { // collide\n        return vec4(ray.src, 1.);\n    }else {\n        return vec4(-1.);\n    }\n}\n\n// -- buffer management ---------------------------------\n// buffer layout\n// (0, 0): vec4(point count, _, vec2(previous click coord))\n// (0.., 1..): point vector(data structure)\t\t\n\nconst ivec2 POINT_INFO_COORD = ivec2(0, 0);\nconst ivec2 POINT_INIT_COORD = ivec2(0, 1);\n\n// frag coord -> texture value\nvec4 readf(vec2 coord) {\n    return texelFetch(iChannel0, ivec2(coord), 0);\n}\n\nvec4 readi(ivec2 coord) {\n    return texelFetch(iChannel0, coord, 0);\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // initialization\n    if(iFrame == 0) {\n        ivec2 coord = ivec2(fragCoord);\n        if(coord == POINT_INFO_COORD) {\n            fragColor = vec4(1., 0., vec2(-1.));\n        } else if(coord == POINT_INIT_COORD) {\n            fragColor = vec4(0., 0., 1., 1.);\n        } else {\n        \tfragColor = vec4(-1.);\n        }\n        return;\n    }\n\n    ivec4 pointInfo = ivec4(readi(POINT_INFO_COORD));\n\n    int cnt = pointInfo.x;\n    \n    ivec2 prevClicked = pointInfo.zw;\n    ivec2 resolution = ivec2(iResolution);\n    ivec2 fc = ivec2(fragCoord);\n\n    ivec2 pointEnd = POINT_INIT_COORD + ivec2(cnt % resolution.x, cnt / resolution.y);\n    \n    if(fc == POINT_INFO_COORD) { // click management\n        if(ivec2(iMouse.zw) != prevClicked) {\n        \tif(iMouse.z > 0. && tryCollide(iMouse.zw).w > 0.) {\n            \t// clicked and collide\n            \tfragColor.x = float(cnt + 1);\n        \t}else {  // released\n           \t\tfragColor.x = float(cnt);\n        \t}\n            fragColor.y = 0.;\n            fragColor.zw = iMouse.zw;\n        } else {\n        \tfragColor = vec4(cnt, 0, prevClicked);\n        }\n    }else if(fc == pointEnd){ // point stacking\n        if(ivec2(iMouse.zw) != prevClicked) {\n        \tvec4 maybeCollisionPoint = tryCollide(iMouse.zw);\n        \tif(maybeCollisionPoint.w > 0.) { // collide\n            \tfragColor = vec4(maybeCollisionPoint.xyz, 1.);\n            } else {\n                fragColor = readi(fc);\n            }\n        } else {\n            fragColor = readi(fc);\n        }\n    }else {\n        // use previous value\n    \tfragColor = readi(fc);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}