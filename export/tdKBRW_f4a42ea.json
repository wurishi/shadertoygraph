{"ver":"0.1","info":{"id":"tdKBRW","date":"1606723279","viewed":61,"name":"FirstToy","username":"newsham","description":"playing with this new toy","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["first"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 myreflect(in vec3 p, in vec3 n) {\n    return p - 2.0 * dot(p, n) * n;\n}\n\nfloat sdfSphere(in vec3 p, in vec3 c, in float r) {\n    return length(c - p) - r;\n}\n\nfloat sdfRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdfTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\nvec3 trans(vec3 p, vec3 off) {\n    return p - off;\n}\n\nvec3 tumble(vec3 p, float t) {\n    float ang = 6.28 * t / 3.0;\n    return vec3(p.x,\n                p.y * cos(ang) - p.z * sin(ang),\n                p.y * sin(ang) + p.z * cos(ang));\n}\n\nfloat warp(vec3 p, float t) {\n\treturn t + 0.02 * cos(29.0 * p.x) * cos(31.0 * p.y) * cos(37.0 * p.z);\n}\n\n// XXX this is probably inefficient.. can it be done better?\nvec4 minw(in vec4 x, in vec4 y) {\n    return (x.w < y.w) ? x : y;\n}\n\nvec4 map(in vec3 p, float time) {\n    vec4 sph = vec4(vec3(1,0,0), warp(p, sdfSphere(p, vec3(0.5, 0.5, 0.5), 0.5)));\n\n    vec3 p3 = trans(p, vec3(-0.3, 0, -0.3));\n    vec4 tor = vec4(vec3(0,1,0), sdfTorus(p3, vec2(0.4, 0.2)));\n\n    vec3 c = vec3(7.0, 5.0, 4.0);\n    vec3 q = p; //mod(p+0.5*c,c)-0.5*c;\n    vec3 p2 = tumble(trans(q, vec3(0.3, -0.5, 0.5)), time);\n    float tb = sdfSphere(p2, vec3(0, 0, 0), 0.3);\n    float ts = sdfRoundBox(p2, vec3(0.1, 0.2, 0.3), 0.1);\n    vec4 box = vec4(vec3(0,0,1), max(ts, -tb)-0.01);\n\n\n    vec4 best = vec4(0,0,0, 1000.0);\n\tbest = minw(best, sph);\n    best = minw(best, tor);\n    best = minw(best, box);\n    return best;\n}\n\nfloat mapw(in vec3 p, float time) {\n    return map(p, time).w;\n}\n\nvec3 calcNorm(in vec3 p, float time) {\n    float e = 0.0001;\n    float t0 = mapw(p, time);\n    return normalize(vec3(\n        mapw(p + vec3(e,0,0), time) - t0,\n        mapw(p + vec3(0,e,0), time) - t0,\n        mapw(p + vec3(0,0,e), time) - t0\n        ));\n}\n\nvec3 lighting(in vec3 p, float time, in vec3 rd, in vec3 col, float z) {\n    vec3 norm = calcNorm(p, time);\n    float up = max(norm.y + 0.2, 0.0);\n    float down = max(-norm.y, 0.0);\n    float right = max(norm.x, 0.0);\n    float ref = pow(max(myreflect(rd, norm).y, 0.0), 5.0); \n    z = 0.4 * (z + 0.5);\n    return ((0.9 * ref * vec3(1,1,1) +\n            up * col.rgb +\n            0.2*down * vec3(1,1,0) +\n            0.5*right * vec3(0,0,1) +\n            0.1 * vec3(1,0.9,0.9))) / z;\n}\n\nvec3 rotView(in vec3 p, float t) {\n    float ang = 6.28 * t / 5.0;\n    vec3 q = vec3(\n        p.x * cos(ang) - p.z * sin(ang),\n        p.y,\n        p.x * sin(ang) + p.z * cos(ang));\n    \n    ang = 6.28 * t / 29.0;\n    return vec3(\n        q.x,\n        q.y * cos(ang) - q.z * sin(ang),\n        q.y * sin(ang) + q.z * cos(ang));\n}\n\nvec3 march(vec3 r0, vec3 rd, float time) {\n    float t = 0.0;\n    for(int i = 0; i < 50; i++) {\n        vec3 p = r0 + t * rd;\n        vec4 best = map(p, time);\n        float d = best.w;\n        if(d < 0.0) {\n            return lighting(p, time, rd, best.rgb, t);\n        } else if(t > 20.0) {\n            break;\n        }\n        t += max(d, 0.01);\n    }\n    return vec3(0.2, 0.2, 0);\n}\n\nvec3 colorPixel(vec2 uv, float time) {\n    vec3 cam = vec3(0, 0, -3.8);\n    vec3 r0 = rotView(vec3(uv, -3.0), time);\n    vec3 rd = normalize(r0 - rotView(cam, time));\n    return march(r0, rd, time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n\n    // average three times near coord\n    vec2 d1 = 0.5 * vec2(cos(fragCoord.x * 5000.0 + fragCoord.y * 5001.0),\n                         cos(fragCoord.y * 5002.0 + fragCoord.y * 5003.0));\n    vec2 d2 = 0.5 * vec2(cos(fragCoord.y * 6000.0 + fragCoord.y * 6001.0),\n                         cos(fragCoord.x * 6002.0 + fragCoord.y * 6003.0));\n    vec3 col1 = 0.4 * colorPixel(uv, iTime) +\n                0.3 * colorPixel(uv + d1/iResolution.x, iTime) +\n                0.3 * colorPixel(uv + d2/iResolution.x, iTime);\n    \n    // motion blur\n    vec3 col2 = 0.6 * colorPixel(uv, iTime) +\n                0.25 * colorPixel(uv, iTime - 0.03) +\n                0.15 * colorPixel(uv, iTime - 0.06);\n    vec3 col = 0.5 * col1 + 0.5 * col2;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}