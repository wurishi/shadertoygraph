{"ver":"0.1","info":{"id":"sdjXWy","date":"1620970174","viewed":583,"name":"Wooden Structure","username":"FMS_Cat","description":"2K executable graphics for Outline Online 2021\n\nGitHub: https://github.com/FMS-Cat/wooden-structure\nPouet: https://www.pouet.net/prod.php?which=88973\n","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["3d","fractal","pathtracer","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec4 tex = texelFetch( iChannel0, ivec2( fragCoord.xy ), 0 );\n\n  // vec3 col = pow( tex.rgb / tex.a, vec3( 0.4545 ) );\n  vec3 col = sqrt( tex.rgb / tex.a );\n\n  fragColor = vec4(\n    smoothstep( 0.1, 0.8, col.x ),\n    smoothstep( 0.0, 1.0, col.y ),\n    smoothstep( -0.2, 1.3, col.z ),\n    1\n  );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Oh no\n// A lot of cringe size optimization there\n// Is intended to be compressed using shader minifier and crinkler\n\n#define L(i,j) (floor((i)/(j))*(j))\n#define F(i) (fract(sin((i)*111.)*111.))\n\n// const float PI = acos( -1. );\n\nfloat cellSize;\nfloat seed;\nvec2 cellPos;\nvec4 cellHash;\n\nfloat random() {\n  seed = F( seed );\n  return seed;\n}\n\nmat3 orthBas( vec3 d ) {\n  vec3 z = normalize( d );\n  vec3 x = normalize( cross(\n    abs( z.y ) < 0.999 ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 ),\n    z\n  ) );\n  return mat3( x, cross( z, x ), z );\n}\n\nfloat cyclicNoise( vec3 p, vec3 b, float pump ) {\n  mat3 bas = orthBas( b );\n  vec2 sum = vec2( 0.0 );\n\n  for ( int i = 0; i < 6; i ++ ) {\n    p *= bas * 2.0;\n    p += sin( p.yzx );\n    sum = pump * sum + vec2( dot( sin( p.zxy ), cos( p ) ), 1.0 );\n  }\n\n  return sum.x / sum.y;\n}\n\nfloat mapWater( vec3 p ) {\n  return p.z + 0.04 * cyclicNoise( p, vec3( 1 ), 2.0 );\n}\n\nvec3 importanceSampleGGX( float roughness, vec3 N ) {\n  float phi = 6.2832 * random();\n  float cosTheta = random();\n  cosTheta = roughness > 1.0 // use lambert ???\n    ? cos( asin( sqrt( cosTheta ) ) )\n    : sqrt( ( 1.0 - cosTheta ) / ( 1.0 + ( pow( roughness, 4.0 ) - 1.0 ) * cosTheta ) );\n  float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n  return orthBas( N ) * vec3(\n    cos( phi ) * sinTheta,\n    sin( phi ) * sinTheta,\n    cosTheta\n  );\n}\n\n// distance\nfloat sdbox( vec3 p, vec3 s ) {\n  vec3 d = abs( p ) - s;\n  return min( max( max( d.x, d.y ), d.z ), 0.0 ) + length( max( d, vec3( 0 ) ) );\n}\n\nfloat map( vec3 p ) {\n  p -= vec3(\n    cellPos,\n    (\n      0.4 * cellHash.x\n      + 0.2 * ( cellPos.x + cellPos.y ) - 8.2\n    )\n  );\n\n  return max(\n    sdbox( p, step( cellHash.y, 0.9 ) * vec2(\n      0.5 * cellSize - 1.0 / 64.0,\n      8\n    ).xxy ),\n    -sdbox( p, step( cellHash.y, 0.4 ) * vec2(\n      0.5 * cellSize - 3.0 / 64.0,\n      9\n    ).xxy )\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // seed = float( iFrame ) + hash21( gl_FragCoord.xy );\n  seed = float( iFrame );\n\n  vec2 p = ( gl_FragCoord.xy + vec2( random(), random() ) - 0.5 * iResolution.xy ) / iResolution.y;\n\n  fragColor = vec4( 0, 0, 0, 1 );\n\n  float medium = 1.0;\n  float rl = 2.5;\n  vec3 ro = vec3( 0, 0, rl );\n  vec3 rd = normalize( vec3( p, -1 ) );\n  vec3 rp = ro + rd * rl;\n\n  vec3 colRem = vec3( 1.0 - 0.2 * length( p ) );\n\n  ro.xy += 0.05 * vec2( random(), random() );\n\n  rp *= orthBas( vec3( 2, 2, 5 ) );\n  ro *= orthBas( vec3( 2, 2, 5 ) );\n  rp.xy *= mat2( 0.6, 0.7, -0.7, 0.6 );\n  ro.xy *= mat2( 0.6, 0.7, -0.7, 0.6 );\n\n  rd = normalize( rp - ro );\n\n  for ( int i = 0; i < 5; i ++ ) {\n    vec2 rdxy = normalize( rd.xy );\n    float dist;\n\n    // water??\n    rl = 0.01;\n    rp = ro + rd * rl;\n\n    for ( int i = 0; i < 20; i ++ ) {\n      // dist = mapWater( rp ) * medium;\n      rl += 0.9 * mapWater( rp ) * medium;\n      rp = ro + rd * rl;\n    }\n\n    // float rlWater = dist < 1E-2 ? rl : 1E2;\n    float rlWater = rl;\n    // water end\n\n    rl = 4E-3;\n    rp = ro + rd * rl;\n\n    for ( int i = 0; i < 50; i ++ ) {\n      // quadtree begin\n      // https://www.shadertoy.com/view/7d2Szc\n      cellSize = 1.0;\n\n      for ( int i = 0; i < 4; i ++ ) {\n        cellSize *= 0.5;\n        cellPos = L( rp.xy, cellSize ) + 0.5 * cellSize;\n        cellHash = F( F( F( cellPos.y ) + cellPos.x ) + vec4( 0, 1, 2, 3 ) );\n        if ( cellSize < 0.7 * cellHash.x ) break;\n      }\n      // quadtree end\n\n      // segment begin\n      // vec2 tow = sign( rdxy ) * cellSize * 0.5;\n      // vec2 v = ( tow - ( rp.xy - cellPos ) ) / rdxy;\n      vec2 v = ( ( sign( rdxy ) * cellSize * 0.5 ) - rp.xy + cellPos ) / rd.xy * length( rd );\n\n      // vec2 nextCell = tow * ( ( v.x < v.y ) ? vec2( 2, 0 ) : vec2( 0, 2 ) ),\n\n      // float seg = min( v.x, v.y );\n      // segment end\n\n      float rlNext = rl + min( v.x, v.y ) + 1E-3;\n\n      // march start\n      for ( int i = 0; i < 100; i ++ ) {\n        dist = map( rp );\n        rl += dist;\n        rp = ro + rd * rl;\n\n        if ( dist < 1E-3 ) break;\n        if ( rlNext < rl ) break;\n      }\n      // march end\n\n      if ( dist < 1E-2 ) break;\n\n      rl = rlNext;\n      rp = ro + rd * rl;\n    }\n\n    vec2 d = vec2( 0, 1E-3 );\n\n    if ( dist > 1E-2 ) {\n      fragColor = vec4(\n        colRem * pow( max( 0.0, rd.z + abs( rd.y ) ), 2.0 ),\n        1\n      );\n      break;\n    }\n\n    rl = max( min( rl, rlWater ), 0.0 );\n    colRem *= exp( 8.0 * ( medium - 1.0 ) * rl );\n\n    if ( rl == rlWater ) {\n      ro = ro + rd * rl;\n\n      vec3 N = normalize( vec3(\n        mapWater( ro + d.yxx ),\n        mapWater( ro + d.xyx ),\n        mapWater( ro + d.xxy )\n      ) - mapWater( ro ) );\n\n      // if ( random() < F ) {\n      // if ( random() < mix( 0.04, 1.0, pow( 1.0 - dot( -rd, N ), 5.0 ) ) ) {\n      if ( random() < 0.04 + pow( 1.0 - dot( -rd, N ), 5.0 ) ) {\n        rd = reflect( rd, N );\n      } else {\n        rd = refract( rd, N, 1.04 - 0.3 * medium );\n        medium = -medium;\n      }\n    } else {\n      vec3 N = normalize( vec3(\n        map( rp + d.yxx ),\n        map( rp + d.xyx ),\n        map( rp + d.xxy )\n      ) - map( rp ) );\n\n      ro = rp;\n\n      // Ref: https://www.shadertoy.com/view/ldscDM\n      float ring = 200.0 * ( dot( rp, 0.5 - cellHash.xyz ) + cyclicNoise( 0.5 * rp, cellHash.xyz, 3.0 ) );\n      ring = pow( sin( ring ) * 0.5 + 0.5, 9.0 ) + cos( ring ) * 0.7;\n\n      // float F = mix( 0.04, 1.0, pow( 1.0 - dot( -rd, N ), 5.0 ) );\n      // if ( random() < F / mix( 1.0 / PI, 1.0, F ) ) {\n      if ( random() < 0.12 + 2.0 * smoothstep( 0.7, -0.8, dot( -rd, N ) ) ) { // what the fuck\n        // weight should be F\n        rd = reflect(\n          rd,\n          importanceSampleGGX( (\n            0.5\n            - 0.3 * cyclicNoise( 8.0 * rp, cellHash.xyz, 1.0 )\n            - 0.1 * ring\n          ), N )\n        );\n      } else {\n        // weight should be (1.0 - F) / PI (albedo * (1.0 - F) / PI)\n        colRem *= pow(\n          0.5 + 0.3 * sin( cellPos.x + cellPos.y + cellHash.w + vec3( 0, 1.5, 2.5 ) ),\n          vec3( 2.0 - 0.2 * ring )\n        );        // colRem *= 0.0;\n        rd = importanceSampleGGX( 2.0, N );\n      }\n    }\n  }\n  \n  // shadertoy specific, accumulation\n  vec4 tex = texelFetch( iChannel0, ivec2( fragCoord.xy ), 0 );\n  fragColor += tex;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}