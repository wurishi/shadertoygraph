{"ver":"0.1","info":{"id":"M3f3z2","date":"1707685315","viewed":79,"name":"Polar Cubemap","username":"miomoto","description":"Demonstration of polar coordinates for a simple procedural cube map\nUse your mouse to navigate\n\nslight gradient noise to hide color banding","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n#define PI2 (2.0 * PI)\n#define PIh (PI / 2.0)\n#define PI2t (PI2 / 3.0)\n\n// how many pillars are there \n#define PILLARS 3.0\n\n// light example, set to 0 for dark example\n#if 1\n#define SKY_C vec3(99.0 / 255.0, 161.0 / 255.0, 196.0 / 255.0)\n#define SKY_ALT_C vec3(160.0 / 255.0, 187.0 / 255.0, 245.0 / 255.0)\n#define HORIZON_C vec3(161.0 / 255.0, 164.0 / 255.0, 132.0 / 255.0)\n#define HORIZON_ALT_C vec3(130.0 / 255.0, 184.0 / 255.0, 194.0 / 255.0)\n#define GROUND_C vec3(160.0 / 255.0, 126.0 / 255.0, 104.0 / 255.0)\n#define GROUND_ALT_C vec3(162.0 / 255.0, 95.0 / 255.0, 53.0 / 255.0)\n\n#else\n\n// how many pillars are there \n#define PILLARS 3.0\n#define SKY_C vec3(25.0 / 255.0, 25.0 / 255.0, 25.0 / 255.0)\n#define SKY_ALT_C vec3(35.0 / 255.0, 35.0 / 255.0, 35.0 / 255.0)\n#define HORIZON_C vec3(10.0 / 255.0, 10.0 / 255.0, 12.0 / 255.0)\n#define HORIZON_ALT_C vec3(66.0 / 255.0, 60.0 / 255.0, 66.0 / 255.0)\n#define GROUND_C vec3(0.0 / 255.0, 0.0 / 255.0, 0.0 / 255.0)\n#define GROUND_ALT_C vec3(10.0 / 255.0, 9.0 / 255.0, 11.0 / 255.0)\n#endif\n\n\n// this is trivial euler rotation transformation\nmat3 Rotation(vec3 euler){\n    // Deg to Rad\n    euler *= PI / 180.0;\n\n    // Rotation around X - pitch\n    float c = cos(euler.x);\n    float s = sin(euler.x);\n    mat3 Rx = mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n\n    // Rotation around Y - yaw\n    c = cos(euler.y);\n    s = sin(euler.y);\n    mat3 Ry = mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n\n    // Rotation around Z - roll\n    c = cos(euler.z);\n    s = sin(euler.z);\n    mat3 Rz = mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n    \n    return Rz*Ry*Rx;\n}\n\n\n// polar coordinates from\n// lat: 0...PI2\n// lon: 0...PI\nvec2 polarCoords(in vec3 xyz) {\n    // it may be necessary in your projection to either:\n    // a) rotate the projection by 90deg OR\n    // b) swap xyz until the projection makes sense:\n    xyz = xyz.xzy;\n    float theta = atan(xyz.y, xyz.x);\n    float rho = sqrt(pow(xyz.x, 2.0) + pow(xyz.y, 2.0) + pow(xyz.z, 2.0));\n    return vec2((theta + PIh) * 2.0, acos(xyz.z / rho));\n}\n\n// Gradient noise from Jorge Jimenez's presentation:\n// http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat gradientNoise(in vec2 uv)\n{\n    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(uv, magic.xy)));\n}\n\n\n\n// goes from 0...1:\n// - is 1 when forward along x axes\n// - is 0 when forward along y axes\n// (with multiples by the amount of color changing pillars)\nfloat latitude(float polar) {\n    return (sin(polar * PILLARS / 2.0) + 1.0) / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    \n    // Camera\n    vec3 cameraPos = vec3(0,1,-1);\n    vec3 dir = normalize(vec3(cameraPos.x+uv.x, cameraPos.y+uv.y, 0) - cameraPos);\n    // Rotate camera\n    vec3 rotAngles = vec3(10.*sin(iTime), iTime*10., 0);\n    mat3 R = Rotation(vec3((iMouse.yx + vec2(-iResolution.x / 12.0, 0.5)) * vec2(-0.5, 1.0), 0.0) + rotAngles);\n    // you can remove the rotation and direction from your code\n    // if you're passing the camera direction (or have a global bound)\n    dir = R * dir;\n    \n    // polar coordinates in lat/lon\n    vec2 polar = polarCoords(dir.xyz);\n     \n\n    // goes from 0...1 from bottom to up\n    // if the sphere is upside down:\n    // - do 1.0 - polar.y / PI\n    float upAmount = 1.0 - polar.y / PI;\n    \n    // interpolation values to move from one phase to another\n    // steeper transitions with higher powers\n    float ground = pow(smoothstep(0.1, 0.3, upAmount), 2.0);\n    float horizon = pow(smoothstep(0.3, 0.5, upAmount), 12.0);\n    float sky = pow(smoothstep(0.45, 0.6, upAmount), 2.0);\n    float highSky = pow(smoothstep(0.6, 0.85, upAmount), 3.0);\n    \n    // mixing the alternative colors to go through their alt version\n    // set the PI2t multication to vary the color phases\n    vec3 skyColor = mix(SKY_C, SKY_ALT_C, latitude(polar.x + 0.0 * PI2t));\n    vec3 groundColor = mix(GROUND_C, GROUND_ALT_C, latitude(polar.x + 1.0 * PI2t));\n    vec3 horizonColor = mix(HORIZON_C, HORIZON_ALT_C, latitude(polar.x + 2.0 * PI2t));\n    \n    vec3 lowGroundToGround = mix(GROUND_C, groundColor, ground);\n    vec3 groundToHorizon =  mix(lowGroundToGround, horizonColor, horizon);\n    vec3 horizonToSky = mix(groundToHorizon, skyColor, sky);\n    vec3 skyToHighSky = mix(horizonToSky, SKY_C, highSky);\n    \n    // add a minute amount of noise to hide color banding\n    vec3 color =  skyToHighSky + (1.0/255.0) * gradientNoise(fragCoord) - (0.5/255.0);\n        \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}