{"ver":"0.1","info":{"id":"4cjcWK","date":"1722996946","viewed":19,"name":"6-4-3 truchet","username":"Tivi","description":"Truchet in a wacky hex-rectangle-triangle grid","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"lfjyRV","parentname":"6-4-3 march"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Stole from iquilez\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    //#if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    //#else\n    //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    //vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    //#endif\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    int numOctaves=8;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(f*x).x;\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// hex-xy conversion stole from https://www.redblobgames.com/grids/hexagons/#rounding\n\nvec2 cube_to_axial(vec3 cube)\n{\n    float q = cube.x;\n    float r = cube.y;\n    return vec2(q, r);\n}\n\nvec3 axial_to_cube(vec2 hex)\n{\n    float q = hex.x;\n    float r = hex.y;\n    float s = -q-r;\n    return vec3(q, r, s);\n}\n    \nvec3 cube_round(vec3 frac)\n{\n    float q = round(frac.x);\n    float r = round(frac.y);\n    float s = round(frac.z);\n\n    float q_diff = abs(q - frac.x);\n    float r_diff = abs(r - frac.y);\n    float s_diff = abs(s - frac.z);\n\n    if (q_diff > r_diff && q_diff > s_diff)\n        q = -r-s;\n    else if (r_diff > s_diff)\n        r = -q-s;\n    else\n        s = -q-r;\n\n    return vec3(q, r, s);\n}\n\nvec2 axial_round(vec2 hex){\n    return cube_to_axial(cube_round(axial_to_cube(hex)));\n}\n\nvec2 xyToHex(vec2 point)\n{\n    float size = 1.;\n    float q = (sqrt(3.)/3. * point.x  -  1./3. * point.y) / size;\n    float r = (                          2./3. * point.y) / size;\n    return axial_round(vec2(q, r));\n}\n\n\nvec2 xyToHexSmooth(vec2 point)\n{\n    float size = 1.;\n    float q = (sqrt(3.)/3. * point.x  -  1./3. * point.y) / size;\n    float r = (                          2./3. * point.y) / size;\n    return vec2(q, r);\n}\n\nvec2 hexToXy(vec2 hex)\n{\n\n    float size = 1.;\n    float x = size * (sqrt(3.) * hex.x  +  sqrt(3.)/2. * hex.y);\n    float y = size * (                          3. /2. * hex.y);\n    return vec2(x, y);\n}\n\nvec3 xyToCell(vec2 point)\n{\n    vec2 hex = xyToHex(point);\n    vec2 newHex = hex;\n    vec3 local = vec3(xyToHexSmooth(point)-newHex,0.);\n    local.z=-local.x-local.y;\n    float step = 1./3.;\n    float kind = 0.;\n    if (int(hex.y)%2 == 0 && int(hex.x)%2 == 0)\n    {\n        if(local.z > -step && local.z < step) kind=3.;\n        else if(local.z <= -step)\n        {\n            newHex = (newHex*3. + vec2(1.,0.) + vec2(0.,1.)) / 3.; kind=4.;\n        }\n        else\n        {\n            newHex = (newHex*3. + vec2(-1.,0.) + vec2(0.,-1.)) / 3.; kind=5.;\n        }\n    }\n    else if (int(hex.y)%2 == 0)\n    {\n        if (local.x > -step && local.x < step) kind=2.;\n        else if(local.x <= -step)\n        {\n            newHex = (newHex*3. + vec2(-1.,0.) + vec2(-1.,1.)) / 3.; kind=4.;\n        }\n        else\n        {\n            newHex = (newHex*3. + vec2(1.,0.) + vec2(1.,-1.)) / 3.; kind=5.;\n        }\n    }\n    else if (int(hex.x)%2 == 0)\n    {\n        if(local.y > -step && local.y < step) kind=1.;\n        else if(local.y <= -step)\n        {\n            newHex = (newHex*3. + vec2(0.,-1.) + vec2(1.,-1.)) / 3.; kind=4.;\n        }\n        else //if(local.y >= step)\n        {\n            newHex = (newHex*3. + vec2(0.,1.) + vec2(-1.,1.)) / 3.; kind=5.;\n        }\n    }\n    return vec3(newHex, kind);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    //fragColor = vec4(xyToHex(uv*10.)/10.,0.,1.);\n    //fragColor = vec4(col,1.0);\n    //return;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    \n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\t//float time = 32.0 + iTime*1.5;\n\tfloat time = 32.0 + iTime*1.5;// + mo.x*200.;\n\n    // true => 2d traversal test\n    //if(false)\n    {\n    \n        vec2 p = 10.*((2.0*fragCoord-iResolution.xy)/iResolution.y);\n        //vec3 cell = floor(xyToCell(p));\n        //fragColor = vec4(normalize(vec3(hex, -hex.x-hex.y)),1.);\n        \n        vec2 target = 10.*((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n        vec3 targetCell = xyToCell(target);\n        \n        \n        vec3 cell = xyToCell(p);\n        \n                vec3 local = vec3(xyToHexSmooth(p)-cell.xy, 0.);\n                local.z = -local.x-local.y;\n                fragColor = vec4(local,1.);\n                fragColor = vec4(float(int(cell.x)&1)*0.2,float(int(cell.y)&1)*0.2,float(int(-cell.x-cell.y)&1)*0.2,1.);\n        if (cell == targetCell) fragColor=vec4(1.f);\n        \n       // float kind = targetCell.z;\n        //if(kind==0.)\n        \n        vec3 ro = vec3(1.,0.5,-2.);\n        vec3 rd = normalize(vec3(target-ro.xz,0.)).xzy;\n        \n        //if (length(p-ro.xz-dot(p-ro.xz,rd.xz)*rd.xz) < 0.1) fragColor = vec4(1.f);\n        \n        vec3 wipCell = xyToCell(vec2(ro.xz));\n        \n        \n        float kind = cell.z;\n        vec2 cellCenter = hexToXy(cell.xy);\n        float h = fbm(hexToXy(cell.xy+sin(time*0.01)),0.8)*6.;\n        //bool selected = (length(cell-targetCell)<0.01);\n        bool selected = (h-floor(h))<0.5;\n        if (length(cell-targetCell)<0.01) selected = !selected;\n        \n            float magicr = 0.5*(sqrt(3.)-1.); //2./4.;\n            \n            \n        float dist = 1000.f;\n            float r0 =  2./4.;\n            float r1 = r0;\n            float r2 = r0;\n            \n        vec2 p0, p1, p2;\n        if (kind == 0.f)\n        {\n            p0 = vec2(-sqrt(3.)/2., 1./2.);\n            p1 = vec2(sqrt(3.)/2., 1./2.);\n            p2 = vec2(0., -2./2.);\n            if (selected)\n            {\n                p0.y*=-1.;\n                p1.y*=-1.;\n                p2.y*=-1.;\n            }\n        }\n        if (kind == 1.f || kind == 2.f || kind == 3.f)\n        {\n            p0 = vec2(-sqrt(3.)/2., 1./2.);\n            p1 = vec2(sqrt(3.)/2., 1./2.);\n            p2 = vec2(0., -2./2.);\n            if (kind == 1.f)\n            {\n                p2 = vec2(0., -1./2.);\n                r2 = magicr;\n            }\n            if (kind == 2.f)\n            {\n                p0 =  normalize(vec2(-sqrt(3.)/2.,3./2.)).yx * -0.5;\n                r0 = magicr;\n            }\n            if (kind == 3.f)\n            {\n                p1 =  normalize(vec2(sqrt(3.)/2.,03./2.)).yx * 0.5;\n                r1 = magicr;\n            }\n            if (selected)\n            {\n                p0*=-1.;\n                p1*=-1.;\n                p2*=-1.;\n            }\n        }\n        if (kind == 4.f || kind == 5.f)\n        {\n            //float r =  2./4.;\n            p0 = vec2(-sqrt(3.)/2., 1./2.);\n            p1 = vec2(sqrt(3.)/2., 1./2.);\n            p2 = vec2(0., -2./2.);\n            if (selected)\n            {\n                p2 = vec2(0., 1./2.);\n                p0 =  normalize(vec2(-sqrt(3.)/2.,3./2.)).yx * 0.5;\n                p1 =  normalize(vec2(sqrt(3.)/2.,03./2.)).yx * -0.5;\n                r0 = r1 = r2 = magicr;\n            }\n            if (kind ==5.f)\n            {\n                p0.y*=-1.;\n                p1.y*=-1.;\n                p2.y*=-1.;\n            }\n        }\n        dist = min(dist, abs(length( p0 + cellCenter - p ) - r0));\n        dist = min(dist, abs(length( p1 + cellCenter - p ) - r1));\n        dist = min(dist, abs(length( p2 + cellCenter - p ) - r2));\n        float thick = 0.1;\n        vec4 col = vec4(0.9,0.3,0.1, 1.);\n        if (dist < thick) fragColor = col* (thick-dist)/thick;\n        \n        \n        \n        return;\n    }\n\n}","name":"Image","description":"","type":"image"}]}