{"ver":"0.1","info":{"id":"wtdGWn","date":"1576059018","viewed":87,"name":"Minumum Recursionless Fractal","username":"HyperChromatica","description":"I wanted to make a fractal but the obvious approach uses recursion and if statements. This doesn't. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","first","minimal","recusionless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t//vec3 col = vec3(.5f + (fragCoord.x - iResolution.x/2.0f )/float(iResolution.x),\n    //                .5f + (fragCoord.y-iResolution.y/2.0f)/float(iResolution.y) ,\n    //                .2f);\n    \n    float boundary = 1.0f;\n    float n = 0.0f;\n    float fract = 1.5f;\n    n =  ceil(-log2(uv.x)/log2(fract));\n    boundary = 1.0f;\n    for(int i = 0 ; i < int(n); i++)\n    {\n        boundary /= fract;\n    }\n    \n    float L = ((uv.x - boundary)*(.85f + .15 * sin(iTime) ))/(boundary-boundary/fract ) +.5f;\n    float r = float(int(n)%4) ;\n    float g = float(int(n+1.0f)%4);\n    float b = float(int(n+2.0f)%4);\n    vec3 col = vec3( r/4.0f, (g)/4.0f, (b)/4.0f)/L;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}