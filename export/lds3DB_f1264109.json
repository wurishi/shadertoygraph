{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Fast raymarch against non-concave analytic shapes (for example planes,\n// boxes, spheres, ..).\n\n// Works by fitting a plane to the implicit surface and then returning the distance from \n// the current ray position to the intersection of the ray with this plane. This distance is\n// not suitable for computing normals via finite differences.\n\n// Notes:\n//  Will need some additions to work with tiling folds, to avoid overstepping the tile boundary\n//  Not sure how well it will work with domain distortions as the ray is often no longer straight\n//  For (complex) concave distance fields, it might be useful to use this against bounding spheres etc\n\n#define FAST_RAYMARCH\n//#define VIS_ITERS\n\n// Can define implementation-dependent march counts to get equal-quality\n// step counts. I get something like 10:90 - 9X more steps needed for normal ray march\n// in this case\n#ifdef FAST_RAYMARCH\n#define MAX_ITERS 10\n#else\n#define MAX_ITERS 10\n#endif\n\n#define SMALL_FLOAT 0.0001\n#define LARGE_FLOAT 10000.0\n#define INTERSECT_DIST 0.001\n\n\n// typical sphere signed dist\nfloat sdSphere( vec3 p, vec4 sph )\n{\n\treturn length(p-sph.xyz) - sph.w;\n}\n// fast sphere signed dist\nfloat sdSphere_Fast( vec3 p, vec3 rd, vec4 sph )\n{\n\tvec3 n = sph.xyz - p;\n\t// dont normalize n - if the ray is heading away from the sphere then we can early out!\n\tfloat dotprod = dot(rd,n);\n\tif( dotprod <= SMALL_FLOAT )\n\t\treturn LARGE_FLOAT;\n\tfloat d = length(n);\n\tfloat sd = (d - sph.w);\n\t// dist to plane (d does normalisation of dotprod)\n\treturn d * sd / dotprod;\n}\n\n// naiive plane signed dist. assumes planeN is normalised.\nfloat sdPlane( vec3 p, vec3 planeP, vec3 planeN )\n{\n\treturn dot(p-planeP, planeN);\n}\n// fast plane signed dist\nfloat sdPlane_Fast( vec3 p, vec3 rd, vec3 planeP, vec3 planeN )\n{\n\tfloat dotprod = dot(rd, planeN);\n\tif( dotprod > -SMALL_FLOAT )\n\t\treturn LARGE_FLOAT;\n\tfloat dist = dot(planeP-p, planeN);\n\treturn dist / dotprod;\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 pp = -1.0 + 2.0*q;\n    pp.x *= iResolution.x / iResolution.y;\n    \n\tvec3 cameraPos;\n    vec3 rayDir = computePixelRay( pp, cameraPos );\n\t\n\t#ifdef VIS_ITERS\n\tfloat cnt = 0.;\n\t#endif\n\t\n\t// ray pos\n\tvec3 p = cameraPos;\n\t\n\tfor( int i = 0; i < MAX_ITERS; i++ )\n\t{\n\t\t#ifdef VIS_ITERS\n\t\t// for visualisation\n\t\tcnt++;\n\t\t#endif\n\t\t\n\t\t// get distances to objects\n\t\t#ifdef FAST_RAYMARCH\n\t\tfloat dSphere1 = sdSphere_Fast(p, rayDir, vec4(0., 0.,0.,1.));\n\t\tfloat dSphere2 = sdSphere_Fast(p, rayDir, vec4(1.,-1.,1.,1.));\n\t\tfloat dPlane   = sdPlane_Fast(p, rayDir, vec3(0.,-1.,0.), vec3(0.,1.,0.));\n\t\t#else\n\t\tfloat dSphere1 = sdSphere(p, vec4(0., 0.,0.,1.));\n\t\tfloat dSphere2 = sdSphere(p, vec4(1.,-1.,1.,1.));\n\t\tfloat dPlane   = sdPlane(p, vec3(0.,-1.,0.), vec3(0.,1.,0.));\n\t\t#endif\n\t\t\n\t\t// union\n\t\tfloat d = min( min( dSphere1, dSphere2), dPlane );\n\t\t\n\t\t// intersection\n\t\tif( d < INTERSECT_DIST )\n\t\t\tbreak;\n\t\t\n\t\t// advance ray\n\t\tp += rayDir * d;\n\t}\n\t\n\t#ifndef VIS_ITERS\n\t\n\t// texture (filters into fog at distance)\n\tfragColor.xyz = (texture(iChannel0,p.xz).xyz+texture(iChannel0,p.xy).xyz+texture(iChannel0,p.yz).xyz)/3.;\n\t\n\t// contrast and brightness\n\tfragColor.xyz = 1.4*(0.5*fragColor.xyz + 0.5*smoothstep(0.,1.,fragColor.xyz));\n\t\n\t// vignette (borrowed from donfabio's Blue Spiral)\n\tvec2 uv =  q.xy-0.5;\n\tfloat distSqr = dot(uv, uv);\n\tfragColor.xyz *= 1.0 - distSqr;\n\t\n\t#else\n\tfragColor.xyz = vec3(cnt/float(MAX_ITERS));\n\t#endif\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 3.8;\n\t// use mouse x coord\n\tfloat a = iTime*20.;\n\tif( iMouse.z > 0. )\n\t\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)/80.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,0.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lds3DB","date":"1378940822","viewed":499,"name":"Bounding planes","username":"huwb","description":"Fast raymarch against non-concave analytic shapes, by fitting bounding planes to the closest point on the shape. See comments and code for explanation.\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","boundingvolume","boundingplane"],"hasliked":0,"parentid":"","parentname":""}}