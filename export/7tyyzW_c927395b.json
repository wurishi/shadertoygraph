{"ver":"0.1","info":{"id":"7tyyzW","date":"1661049204","viewed":1146,"name":"Curve Inflation: Walk on Spheres","username":"ajx","description":"Uses the Walk on Spheres method https://en.wikipedia.org/wiki/Walk-on-spheres_method\nto solve for inflation of a 2D shape via \"Notes on Inflating Curves\" by Ilya Baran and Jaakko Lehtinen.\n\n∆ u = -4.0\nz = √u","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["2d","pde"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n  // take average\n  fragColor = vec4(data.xyz / data.w, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DEBUG_SDF 0\n#define DEBUG_SINGLE_FRAME 0\n\nconst int samples = 64;\nconst int walk_iterations = 10;\n\n// https://www.shadertoy.com/view/4llXD7\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for any given shape\n    p.x = abs(p.x);\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n    return (s<0.0) ? length(p)-r :\n           (p.x<w) ? h - p.y     :\n                     length(p-vec2(w,h));\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nvec3 colormap(in float d)\n{\n  vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    return col;\n}\n\nfloat get_t()\n{\n  return 20.*fract(float(iFrame)*0.005);\n}\n\n\nfloat dist(in vec2 xy)\n{\n // return -sdCircle( xy , 0.5);\n  //return -min(\n  //  sdCircle( xy , 0.25),\n  //  sdBox(xy,vec2(0.5,0.125)));\n  float d = sdCircle( xy+vec2(0.,0.02) , 0.4);\n  \n  float t = get_t();\n  \n  if(int(t)>3)\n  {\n    d = min(min(d,\n      max(sdCutDisk( xy , 0.48, 0.0),-sdCutDisk( xy , 0.42, 0.0))),\n      sdBox(xy+vec2(0.,-0.05),vec2(0.5,0.125)));\n  }\n  float x = xy.x;\n  switch(int(t))\n  {\n    default:\n    case 5:\n      float s = min(t-5.0,1.);\n      float th = mix(1.570796,0.2,3.*s*s-2.*s*s*s);\n      d = max(d, -sdArc( vec2(xy.x,-xy.y-0.07), vec2(cos(th),sin(th)), 0.2, 0.02));\n    case 4:\n    case 3:\n      x = abs(x);\n    case 2:\n      d = max(d, -sdCircle( vec2( x ,xy.y)-vec2(0.125,0.12) , 0.06));\n    case 1:\n    case 0: break;\n  }\n  return -d;\n  /*return -max(max(d, \n      -sdCircle( vec2(abs(xy.x),xy.y)-vec2(0.18,0.17) , 0.07)\n      ),\n      -sdArc( vec2(xy.x,-xy.y-0.07), vec2(cos(0.2),sin(0.2)), 0.2, 0.02)\n      );*/\n}\n// from https://www.shadertoy.com/view/wdffWj\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) {\n    seed = s;\n}\nint randi(void) {\n    seed = seed * 0x343fd + 0x269ec3;\n    return (seed >> 16) & 32767;\n}\nfloat rand(void) {\n    return float(randi())/32767.0;\n}\n// --------------------------------------\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n ) {\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// --------------------------------------\n\nvec2 randomOnCircle( void ) {\n    float theta = 6.28318530 * rand();\n    return vec2(cos(theta), sin(theta));\n}\n\nfloat G(in float r, in float R)\n{\n  return log(R/r)/6.28318530;\n}\n\nvec3 wos(in vec2 xy0)\n{\n  const float epsilon = 0.0001;\n  float u = 0.0;\n  float R1;\n  vec2 w1;\n  float r_y1;\n  vec2 xy = xy0;\n  // Puffiness factor (4.0 for circle → sphere)\n  const float f_y = 4.0;\n  \n  for(int i = 0;i<walk_iterations;i++)\n  {\n    float R = dist(xy);\n    if( R < epsilon && i > 0) break;\n    //float h = rand()+0.0001; \n    //u += -R*R*log(h);\n    //h = exp(-1);\n    u += R*R;\n    vec2 w = randomOnCircle();\n    xy += R*w;\n    if(i == 0)\n    {\n      R1 = R;\n      w1 = w;\n      //r_y1 = R*sqrt(h);\n    }\n  }\n  u *= 0.25*f_y;\n\n  //vec2 v1 = (xy1-xy0)/R1;\n  //float r_y = r_y1;\n  //float theta_y = rand()*6.28318530;\n  //vec2 ymxy = r_y*vec2(cos(theta_y),sin(theta_y));\n  //vec2 dG_y = ymxy/6.28318530*(1.0/r_y/r_y - 1./R1/R1);\n  //vec2 g = 2./R1*u*v1 + R1*R1*3.14159265*f_y*dG_y;\n  // For uniform f, I claim the expected value of the \n  // ∇ f-contribution is the 0 vector.\n  vec2 g = 2.*u*w1/R1;\n  return vec3(u,g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 xy = fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5);\n  ivec2 q = ivec2(fragCoord);\n  srand(hash(q.x + hash(q.y + hash(iFrame))));\n  float R = dist(xy);\n  vec4 fColor;\n#if DEBUG_SDF\n  fColor = vec4(colormap(2.0*r),1.0);\n#else\n\n  vec3 Kd = vec3(0.95,0.85,0.15);\n  vec3 Ks = vec3(1.,1.,1.);\n  vec3 Kf = 0.4*Ks;\n  vec3 Ka = 0.1*Kd;\n  if(R<0.0)\n  {\n    //fColor = vec4(colormap(2.0*R),1.0);\n    fColor = vec4(Ka,1.0);\n  }else\n  {\n    vec3 u_g = vec3(0.0,0.,0.);\n    for(int i = 0;i<samples;i++)\n    {\n      u_g += wos(xy);\n    }\n    u_g /= float(samples);\n    float z = sqrt(u_g.x);\n    vec3 n = normalize(vec3(-u_g.yz*0.5/z,1));\n    const int nlights = 2;\n    vec3 lights[nlights];\n    lights[0] = normalize(vec3(1.5,2.,1.));\n    lights[1] = normalize(vec3(-1.5,2.,1.));\n    vec3 Kl[nlights];\n    Kl[0] = vec3(1.,0.6,0.6);\n    Kl[1] = vec3(.6,0.6,1.0);\n    vec3 color = vec3(0.,0.,0.);\n    vec3 p = vec3(xy,z);\n    vec3 c = vec3(0.,0.,5.);\n    vec3 v = normalize(c-p);\n    for(int i = 0;i<2;i++)\n    {\n      vec3 l = lights[i];\n      float d = max(dot(n,l),0.);\n      vec3 h = normalize(l+v);\n      float s = pow(max(dot(n,h),0.),100.);\n      color += Kl[i]*(Kd*d+Ks*s);\n    }\n    float NE = dot(n,v);\n    float f = pow(max(sqrt(1. - NE*NE),0.0), 50.);\n    color += Kf*f+Ka;\n    \n    fColor = vec4(color,1.0);\n    //fColor = vec4(n*0.5+0.5,1.0);\n    //vec3 xyz = vec3(xy,z);\n    //fColor = vec4(2.0*z*vec3(1.0,0.0,0.0),1.0);\n    //fColor = vec4(0.5+sign(u)*vec3(0.5,0.5,0.5),1.0);\n  }\n#endif\n#if DEBUG_SINGLE_FRAME\n  fragColor = fColor;\n#else\n  vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n  if(get_t() < 0.3)\n  {\n    fragColor = fColor;\n  }else if( int(get_t()) < 6)\n  {\n    // A little bit of motion blur to reduce aliasing.\n    fragColor = vec4(mix(data.rgb/data.w,fColor.rgb, 0.3),1.0);\n  }else\n  {\n    // when the animation is static, just accumate (main shader takes average)\n    fragColor = data + fColor;\n  }\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}