{"ver":"0.1","info":{"id":"3ttBzn","date":"1612223627","viewed":154,"name":"Raymarching chrome spheres","username":"niels747","description":"I made this while learning to understand raymarching. ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","spheres","chrome","bouncing","metalballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightPos;\n\n\nstruct distID{\nfloat d;\nint ID;\n};\n\nstruct Sphere{\nvec3 pos;\nfloat r;\n};\n\n\n\nSphere sphere[numSpheres];\n\nfloat distToSphere(Sphere s, vec3 inPos)\n{\nreturn length(inPos - s.pos) - s.r;\n}\n\nfloat distToGround(vec3 inPos)\n{\nfloat y = -30.0; // ground height\n\nreturn inPos.y - y;\n}\n\nfloat distToClouds(vec3 inPos)\n{\nfloat y = 2000.0; // ceiling height\n\nreturn y - inPos.y;\n}\n\ndistID dist(vec3 inPos) // dist, ID\n{\nfloat minDist = 10e6; // start with high number\nint closestID;\n\nfor(int i = 0; i < numSpheres; i++){\nfloat curDist = distToSphere(sphere[i],inPos);\nif(curDist < minDist){\nminDist = curDist;\nclosestID = i;\n}\n}\n\nfloat gndDis = distToGround(inPos);\nfloat cloDis = distToClouds(inPos);\nfloat ligDis = length(inPos - lightPos)-2.;\n\nif(ligDis < minDist){\nminDist = ligDis;\nclosestID = -3;\n}\n\nif(gndDis < minDist){\nminDist = gndDis;\nclosestID = -2;\n}\n\nif(cloDis < minDist){\nminDist = cloDis;\nclosestID = -1;\n}\n\nreturn distID(minDist, closestID);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    vec2 uv = ((fragCoord - vec2(iResolution.x/2.0, iResolution.y/2.0)) / vec2(iResolution.x))*2.5;\n    vec3 col = vec3(0);\n    \n    float FOV = 1.0; // 1 = max = 90 degrees\n    \n    float shadowLight = 0.5;\n    float lightVal;\n    \n    lightPos = vec3(sin(iTime*0.5)*100.,20. + cos(iTime*0.5)*10.,cos(iTime*0.5)*100.);\n     \n   \n\nfor(int i = 0; i < numSpheres; i ++){\n    sphere[i].pos = texelFetch(iChannel2,ivec2(i,0),0).xyz;\n    sphere[i].r = sphereR;\n    }\n    \n    vec3 or = vec3(-50. + iTime,-9. ,iTime*0.); // cam position\n\n    vec3 ray = normalize(vec3(1.,uv.y*FOV,uv.x*FOV));\n    \n    float yR = -(iMouse.x-iResolution.x/2.)*0.005; // rotate camera\n    float zR = (iMouse.y-iResolution.y/2.)*0.005;\n    \n    // rotation matrices\n    mat3 rayRotZ = mat3(\n   cos(zR), sin(zR), 0., \n   -sin(zR), cos(zR), 0., \n   0., 0., 1.  \n);\n\nmat3 rayRotY = mat3(\n   cos(yR), 0., -sin(yR), \n   0., 1., 0., \n   sin(yR), 0., cos(yR)\n);\n    \n    ray = rayRotZ * ray;\n    ray = rayRotY * ray;\n    \n    \n    vec3 reflectCol = vec3(1);\n    \n    \n    bool light = false;\n    float closestPass = 10e6;\n    float closestLightPass = 10e6;\n    \n    \n    vec3 pos = or;\n    distID mindist = dist(pos);\n    \n    for(int cnt = 0; cnt < maxSteps; cnt++) // main rendering for loop\n    {\n    pos += ray*mindist.d; // extend ray as far as the nearest object\n    mindist = dist(pos); // get distance to nearest object\n    \n    if(mindist.d < hitDist){ // hit object\n    \n    if(mindist.ID == -2){ // ground plane\n    \n    // lighting\n    ray = normalize(lightPos - pos); // light vector\n    pos += ray; // move ray away from surface to prevent rebounce\n    light = true;\n    closestPass = 10e6;\n    \n    \n    col = texture(iChannel0, pos.xz*0.02).xyz * reflectCol;\n    \n    lightVal = dot(ray,vec3(0.,1.,0.))*6000.5; // proportional to light angle\n    \n    lightVal /= pow(length(lightPos - pos),2.); // inverse square law\n\n    }else if(mindist.ID == -1){ // cloud plane\n    \n    col = texture(iChannel1, pos.xz*0.0001).xxx * reflectCol;\n    lightVal = 0.8;\n    break;\n    }else if(mindist.ID == -3){ // light\n    \n    if(!light){ // direct hit\n    col = vec3(1.0);\n    lightVal = 1.;\n    }\n    \n    break;\n    }else{ // sphere\n    \n    if(light){ // full shadow\n    lightVal = 0.;\n    break;\n    }\n    \n    vec3 n = normalize(pos - sphere[mindist.ID].pos);\n    ray = ray - 2.*dot(ray,n)*n; // reflection\n\npos += ray; // move ray away from surface to prevent rebounce\n\nreflectCol = vec3(0.99,0.99,0.99);\ncol = vec3(0.0);\n    }\n    }\n    }\n    \n   col *= lightVal + shadowLight; // apply lighting\n    \n\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define maxSteps 1000 // max marching steps, reduce to improve fps\n#define sphereR 11.0\n#define numSpheres 5// the more Spheres there are, the more marching steps will need to be taken so the slower it will run\n#define hitDist 0.1 // distance at wich the ray hits an object","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nPhisics engine:\n\nonly vertical velocity for now\n\n\n\n[0] = x\n[1] = y\n[2] = z\n[3] = Vy\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec4 vals = texture(iChannel0,fragCoord/iResolution.xy);\n \n if(iTime < 2.){ // setup\n vals.y = float(int(fragCoord.x)%5)*13.; \n vals.z = cos(fragCoord.x*0.35) * 70.; // put spheres in cirle\n vals.x = sin(fragCoord.x*0.35) * 70.; // around center\n vals[3] = 0.;\n }\n \n float force = max(sphereR -30. - vals.y,0.);\n if(force > 0.){\n vals[3] += force*0.5; // bounce force\n vals[3] *= 0.98; // bounce losses\n }\n\n vals.y += vals[3]; // vertical motion\n \n vals[3] -= 0.04; // gravity\n \n\n\n  fragColor = vals;\n}","name":"Buffer A","description":"","type":"buffer"}]}