{"ver":"0.1","info":{"id":"NsS3Ww","date":"1617470809","viewed":123,"name":"Camera Movement Around an Object","username":"inspirnathan","description":"Example on how to move the camera completely around an object. The cube is colored according to its surface normals. Use the mouse to look around the cube (x-axis) or flip to the other side of the cube (y-axis). The \"glowy\" spot is the light position.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","camera","normal","inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n** Camera Movement Around An Object by inspirnathan (Nathan Vaughn)\n** \n** Use the mouse to look around the cube (x-axis) or flip to the other side of the cube (y-axis)\n** The \"glowy\" spot on the floor is the position of the light\n**\n** Resources/Credit:\n** Box SDF: https://iquilezles.org/articles/distfunctions\n** Fog: https://iquilezles.org/articles/fog\n*/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Object {\n    float sd; // signed distance\n    vec3 col; // color\n    int id; // id of object\n};\n\nObject sdFloor(vec3 p, vec3 col) {\n  return Object(p.y + 1., col, 1);\n}\n\nObject sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Object(d, col, 2);\n}\n\nObject minWithColor(Object obj1, Object obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nObject sdScene(vec3 p) {\n  vec3 b = vec3(0.75);\n  Object co = sdBox(p, b, vec3(0, 0, 0), vec3(1), identity());\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  co = minWithColor(co, sdFloor(p, floorColor));\n  return co;\n}\n\nvec3 calcSceneNormal(vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nObject rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Object closestObj;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    closestObj = sdScene(p);\n    depth += closestObj.sd;\n    if (closestObj.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  closestObj.sd = depth;\n  \n  return closestObj;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy / iResolution.xy;\n\n  vec3 ro = vec3(0, 0, 4);\n  ro *= rotateX(mouseUV.y * -PI) * rotateY(mix(-PI, PI, mouseUV.x));\n\n  vec3 la = vec3(0);\n  vec3 rd = camera(ro, la) * normalize(vec3(uv, -0.5));\n  \n  vec3 backgroundColor = vec3(0.835, 1, 1);\n  vec3 col = vec3(0);\n\n  Object closestObj = rayMarch(ro, rd);\n  if (closestObj.sd > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n    vec3 p = ro + rd * closestObj.sd;\n    vec3 normal = calcSceneNormal(p);\n\n    vec3 lightPosition = vec3(7, 0, 10);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    col = dif * closestObj.col + backgroundColor * .2;\n    col = mix(col, backgroundColor, .6 - exp(-0.1*closestObj.sd));\n    if (closestObj.id == 2) col = abs(normal) * dif * 2.; // color cube sides according to surface normals\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}