{"ver":"0.1","info":{"id":"NldfRM","date":"1662846398","viewed":82,"name":"Ice Cream w/ Colors","username":"zachtrybus","description":"Ice Cream with changing background.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["colors","icecream"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nmat3 rotateY(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n            c, 0.0, -s,\n            0.0, 1.0, 0.0,\n            s, 0.0, c);\n            }\n            \n\nvec3 conePos[3] = vec3[3](vec3(0,-8.5,0), vec3(10.5,-8.5,0), vec3(-10.5,-8.5,0));\n\n\nvec3 spherePos[6] = vec3[6](vec3(0,3.5,0),vec3(10.5,3.5,0),vec3(-10.5,3.5,0), vec3(0,0.5,0),vec3(10.5,0.5,0),vec3(-10.5,0.5,0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to .5)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= 1.7777;\n    \n    vec3 col = vec3(0);\n    vec3 eye = vec3(0,0,-100);\n    vec3 dir = normalize(vec3(uv.x,uv.y, 5.0));\n    vec3 dirdx = normalize(vec3(uv.x+.001f,uv.y, 5.0));\n    vec3 dirdy = normalize(vec3(uv.x,uv.y+.001f, 5.0));\n    vec3 dir2 = normalize(vec3(uv.x,uv.y, 5.0));\n    vec3 dirdx2 = normalize(vec3(uv.x+.001f,uv.y, 5.0));\n    vec3 dirdy2 = normalize(vec3(uv.x,uv.y+.001f, 5.0));\n    \n    for(int shape = 0; shape < 3; shape++){\n    float t, tdx, tdy = 0.0;\n    \n    for(int i = 0; i < 30; i++){\n        //sample point along view ray\n        vec3 pos = eye + dir * t;\n        vec3 posdx = eye + dirdx * tdx;\n        vec3 posdy = eye + dirdy * tdy;\n        //float dist = sdSphere(pos - spherePos[shape], 5.0f);\n        float dist = opSmoothUnion(sdSphere(pos - spherePos[shape], 2.2f), sdSphere(pos - spherePos[shape + 3], 2.6f), 0.5 );\n        float distdx = opSmoothUnion(sdSphere(posdx - spherePos[shape], 2.2f), sdSphere(posdx - spherePos[shape + 3], 2.6f), 0.5 );\n        float distdy = opSmoothUnion(sdSphere(posdy - spherePos[shape], 2.2f), sdSphere(posdy - spherePos[shape + 3], 2.6f), 0.5 );\n        \n        //check if position was close to sphere (e.g. small dist)\n        if(dist < 0.1f && distdx < 0.1f && distdy < 0.1f){\n            //I hit the shape!!!\n            col = vec3(0.95, 0.895, 0.668);//vanilla\n            vec3 BA = normalize(posdx - pos);\n            vec3 CA = normalize(posdy - pos);\n            vec3 normal = cross(CA, BA);\n            //col *= dot(normal, vec3(0,0,-1));\n            col *= dot(normal, normalize(vec3(/*iMouse.xy/iResolution.xy - */vec2(0.5),-1.0)));\n            col *= vec3(2.0*texture(iChannel1, uv).rrr);\n            \n            \n        }\n        else if(col == vec3(0.0f)){\n        col = vec3(sin(2.094395 + iTime/5.0), sin(4.188790 + iTime/5.0), sin(iTime/5.0));\n        col *= vec3((uv.x*25.0+(sin(iTime/3.0)*3.14)*uv.y*50.0+15.0*sin(iTime/7.5)));//+25.0*sin(iTime/7.0)\n        }\n        //dist = opSmoothUnion(sdSphere(pos, 5.0f), sdSphere(pos, 5.0f), 0.5 );\n        t += dist; //move forward on the ray for next check\n        tdx += distdx;\n        tdy += distdy;\n    }\n    }\n    \n    for(int shape = 0; shape < 3; shape++){\n    float t, tdx, tdy = 0.0;\n    \n    for(int i = 0; i < 30; i++){\n        //sample point along view ray\n        vec3 pos = eye + dir2 * t;\n        vec3 posdx = eye + dirdx2 * tdx;\n        vec3 posdy = eye + dirdy2 * tdy;\n        float dist = sdCone(-pos + conePos[shape], vec2(1.5, 4.5), 9.0f);\n        float distdx = sdCone(-posdx + conePos[shape], vec2(1.5, 4.5), 9.0f);\n        float distdy = sdCone(-posdy + conePos[shape], vec2(1.5, 4.5), 9.0f);\n        \n        //check if position was close to sphere (e.g. small dist)\n        if(dist < 0.1f && distdx < 0.1f && distdy < 0.1f){\n            //I hit the shape!!!\n            col = vec3(0.93, 0.797, 0.574);//waffle\n            vec3 BA = normalize(posdx - pos);\n            vec3 CA = normalize(posdy - pos);\n            vec3 normal = cross(CA, BA);\n            //col *= dot(normal, vec3(0,0,-1));\n            col *= dot(normal, normalize(vec3(/*iMouse.xy/iResolution.xy - */vec2(0.5),-1.0)));\n        float stripes = 100.0 * uv.x;\n        float rounded = floor(stripes);\n        float stripesy = 100.0 * uv.y;\n        float roundedy = floor(stripesy);\n    \n        if (mod(rounded, 2.0) == 0.0 && mod(roundedy, 2.0) == 0.0)\n        {\n            col *= vec3(0.6,0.6,0.6);   \n        }\n        }\n        t += dist; //move forward on the ray for next check\n        tdx += distdx;\n        tdy += distdy;\n    }\n    }\n        // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv3 = fragCoord/iResolution.xy;\n    \n    col *= vec3(3.0*sin(texture(iChannel0, uv+iTime/5.0)).rrr);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}