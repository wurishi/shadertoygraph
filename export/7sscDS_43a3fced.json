{"ver":"0.1","info":{"id":"7sscDS","date":"1644519051","viewed":69,"name":"Coffee Bean SDF","username":"Symmetries","description":"SDF of a coffee bean","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","spheremarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// use the mouse to rotate the coffee bean\n\n// material, light and background properties\n#define background rgb(0, 20, 20)\n#define ambientColor rgb(60, 60,  30)\n#define lightColor rgb(60, 60, 60)\n#define shininess 100.\n\n// semantic color notation\n#define rgb vec3\n\n// render parameters\n#define iters 20\n#define ep 0.01\n#define min_distance 0.1\n#define max_distance 3.\n#define max_length 5.\n#define AA\n\n// convenience constants\n#define e1 vec3(1, 0, 0)\n#define e2 vec3(0, 1, 0)\n#define e3 vec3(0, 0, 1)\n#define pi 3.14159265\n\n// polynomial smooth min \n// source https://iquilezles.org/articles/smin/\nfloat smoothMin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smoothMax(float x1, float x2, float alpha) {\n    return -smoothMin(-x1, -x2, alpha);\n}\n\n\nfloat sdf1(vec3 p) {\n    vec3 center = vec3(0., 0., 0);\n    vec3 q = vec3(1.2 * p.x, 0.75 * p.y, p.z);\n    float radius = 1.;\n    return distance(q, center) - radius;\n}\n\nfloat sdf2(vec3 p) {\n    return dot(p, normalize(vec3(1,0,0)));\n}\n\nfloat sdf3(vec3 p) {\n    vec2 center = vec2(0,0);\n    float radius = 0.1;\n    vec2 q = vec2(p.x , p.z + 1. * radius * cos(3. * p.y + pi/2.));\n    return distance(q, center) - radius;\n}\n\nfloat sdf(vec3 q) {\n    vec3 p = q - vec3(-0.25, 0, 0);\n    return smoothMax(smoothMax(sdf1(p), -sdf2(p), 0.2), -sdf3(p), 0.2);\n}\n\nvec3 pixel(vec2 coord) {\n    vec2 uv = coord / iResolution.yy;\n    vec3 col = vec3(0);\n\n    uv.x = (uv.x - 0.5) * 2.;\n    uv.y = (uv.y - 0.5) * 2.;\n    \n    float onScreen = float(uv.x <= 1.);\n    uv *= 0.3;\n    float theta = iTime * 2.;\n    vec3 light = normalize(vec3(sin(theta), cos(theta), 1));\n    \n    vec3 w = normalize(vec3(uv, 1.));\n    float phi = -2. * pi * (iMouse.x / iResolution.y - 0.5);\n    mat3 rot1 = mat3(cos(phi),  0, sin(phi),\n                    0,         1, 0,\n                    -sin(phi), 0, cos(phi));\n                    \n    float phi2 = -2. * pi * iMouse.y / iResolution.y;\n    mat3 rot2 = mat3(cos(phi2), sin(phi2), 0,\n                     -sin(phi2), cos(phi2), 0,\n                      0, 0, 1);\n    mat3 rot = rot1 * rot2;\n    light = rot * light;\n    w = rot * w;\n    vec3 p = rot * vec3(0, 0, -5);\n    for(int i = 0; i < iters; i++) {\n        p += max(min(sdf(p), max_distance), -max_distance) * w;\n        float isPLarge = float(length(p) >= max_length);\n        p += isPLarge * (max_length * normalize(p) - p);\n    }\n    \n    \n    \n    \n    float intersect = float(sdf(p) < min_distance);\n    \n   \n    \n    vec3 n = vec3(sdf(p - ep * e1) - sdf(p + ep * e1),\n                  sdf(p - ep * e2) - sdf(p + ep * e2),\n                  sdf(p - ep * e3) - sdf(p + ep * e3));\n    n = normalize(n);\n    \n    w += intersect * (reflect(w, n) - w);\n    \n    float lightHits = float(dot(n, light) >= 0.);\n    float reflection = float(dot(-w, light) >= 0.);\n    col += intersect * lightHits  * dot(n, light) *  lightColor/255.;\n    col += intersect * reflection * pow(abs(dot(-w, light)), shininess) * lightColor/255.;\n    col += intersect * ambientColor/255.;\n    \n    return onScreen * intersect * col\n            + onScreen * (1.-intersect) * background/255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    #ifdef AA\n    vec3 col = vec3(0);\n    for (float i = -1.; i <= 1.; i+=2.) {\n        for (float j = -1.; j <= 1.; j+=2.) {\n            col += pixel(fragCoord + vec2(i,j)/3.);\n        }\n    }\n    fragColor = vec4(col, 1) / 4.;\n    #else\n    fragColor = vec4(pixel(fragCoord), 1.);\n    #endif\n}\n\n","name":"Image","description":"","type":"image"}]}