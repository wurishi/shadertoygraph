{"ver":"0.1","info":{"id":"tt23zR","date":"1561952748","viewed":317,"name":"volumetric cloud","username":"takumifukasawa","description":"// ref\n// https://qiita.com/edo_m18/items/876f2857e67e26a053d6\n// https://qiita.com/edo_m18/items/cbba0cc4e33a5aa3be55","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cloud","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//-----------------------------------------------------------\n// ref\n// https://qiita.com/edo_m18/items/876f2857e67e26a053d6\n// https://qiita.com/edo_m18/items/cbba0cc4e33a5aa3be55\n//-----------------------------------------------------------\n\n#define saturate(a) clamp(a, 0., 1.);\n\n#define EPS 0.0001\n\n#define USE_DIRECTIONAL_LIGHT\n#define USE_AMBIENT_LIGHT\n\n#define SAMPLE_COUNT 48\n\n#define SHADOW_LENGTH 2.5\n#define SHADOW_ITERATIONS 4\n\n#define DENSITY_INTENSITY 0.5\n#define AMBIENT_INTENSITY 8.0\n\nvec3 ABSORPTION_INTENSITY = vec3(.5, .8, .7) * .5;\n\nvec3 sunDirection = normalize(vec3(.5, 1., .5));\nvec3 lightColor = vec3(1., 1., .8) * 1.;        \n    \nvec3 ambientLightDir = normalize(vec3(0., -1., 0.));\nvec3 ambientLightColor = vec3(.5, .7, 1.);\n\nvec3 cloudColor = vec3(.8, .9, 1.);    \n    \n//\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f;\n    p = m * p * 1.2;\n    f  = 0.5000 * noise(p);\n    p = m * p * 2.;\n    f += 0.2500 * noise(p);\n    p = m * p * 2.4;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat scene(vec3 p) {\n\t// return 1. - length(p) * .2 + fbm(p * .7 + iTime);\n    return 1. - sdTorus(p, vec2(8., .5)) + fbm(p * .7 + iTime) * 2.8;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy) - scene(p - e.xyy),\n            scene(p + e.yxy) - scene(p - e.yxy),\n            scene(p + e.yyx) - scene(p - e.yyx)\n        )\n    );\n    \n    /* cheap\n    const float h = EPS;\n    const vec2 k = vec2(1., -1.);\n    return normalize(\n    \tk.xyy * scene(p + k.xyy * h) +\n        k.yyx * scene(p + k.yyx * h) +\n        k.yxy * scene(p + k.yxy * h) +\n        k.xxx * scene(p + k.xxx * h)\n    );\n\t*/\n}\n\nmat3 camera(vec3 ro, vec3 ta) {\n    vec3 forward = normalize(ta - ro);\n    vec3 side = normalize(cross(forward, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(side, forward));\n    return mat3(side, up, forward);\n}\n\nvec4 rayMarchFog(vec3 p, vec3 dir) {    \n    float zStep = 16. / float(SAMPLE_COUNT);\n    \n    float transmittance = 1.;\n    \n    vec3 color = vec3(0.);    \n    \n    float densityScale = DENSITY_INTENSITY * zStep;\n    float shadowSize = SHADOW_LENGTH / float(SHADOW_ITERATIONS);\n    vec3 shadowScale = ABSORPTION_INTENSITY * shadowSize;\n    vec3 shadowStep = sunDirection * shadowSize;    \n    \n    for(int i = 0; i < SAMPLE_COUNT; i++) {\n    \tfloat density = scene(p);\n        \n        if(density > EPS) {\n        \t//float tmp = density / float(SAMPLE_COUNT);\n            density = saturate(density * densityScale);\n            \n            // directional light            \n\n            #ifdef USE_DIRECTIONAL_LIGHT\n            \n            {\n            vec3 shadowPosition = p;\n            float shadowDensity = 0.;\n            for(int si = 0; si < SHADOW_ITERATIONS; si++) {\n                float sp = scene(shadowPosition);\n                shadowDensity += sp;\n                shadowPosition += shadowStep;\n            }\n            vec3 attenuation = exp(-shadowDensity * shadowScale);\n            vec3 attenuatedLight = lightColor * attenuation;\n            color += cloudColor * attenuatedLight * transmittance * density;\n            }\n                \n            #endif\n            \n            // ambient light\n            \n            #ifdef USE_AMBIENT_LIGHT\n            \n            {\n            float shadowDensity = 0.;\n            vec3 shadowPosition = p + ambientLightDir * .05;\n            shadowDensity += scene(p) * .05;\n            shadowPosition = p + ambientLightDir * .1;\n            shadowDensity += scene(p) * .05;\n            shadowPosition = p + ambientLightDir * .2;\n            shadowDensity += scene(p) * .1;\n            float attenuation = exp(-shadowDensity * AMBIENT_INTENSITY);\n            vec3 attenuatedLight = vec3(ambientLightColor * attenuation);\n            color += cloudColor * attenuatedLight * transmittance * density;\n            }\n            \n            #endif\n            \n            transmittance *= 1. - density;            \n        }\n\n        if(transmittance < EPS) {\n        \tbreak;\n    \t}\n        \n        p += dir * zStep;\n        \n    }\n    \n    //return color;\n    return vec4(color, 1. - transmittance);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  \tvec2 uv = (fragCoord.xy / iResolution.xy - .5) * aspect;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy - .5;\n\n  \t// camera settings\n  \tfloat fov = 1.2;\n    vec3 lookAt = vec3(10. * mouse.x, 10. * mouse.y, 0.) * 0.;\n    vec3 cameraPos = vec3(\n    \t// cos(iTime * .6) * 20.,\n        // sin(iTime * .8) * 20.,\n        0.,\n        0.,\n        20.\n    );\n\n  \t// raymarch\n  \tvec3 rayOrigin = cameraPos;\n  \tvec3 rayDirection = camera(rayOrigin, lookAt) * normalize(vec3(uv, fov));\n\n    vec4 color = vec4(vec3(0.), 0.);\n    \n    vec4 res = rayMarchFog(rayOrigin, rayDirection);\n    color += res;\n    //return;\n    \n    vec3 bg = mix(\n        vec3(.2, .1, .8),\n        vec3(.7, .7, 1.),\n        1. - (uv.y + 1.) * .8\n    );\n    \n    color.rgb += bg;\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}