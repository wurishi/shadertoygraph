{"ver":"0.1","info":{"id":"3tjcDV","date":"1595416624","viewed":111,"name":"Varying Circle Tiles","username":"sauj123","description":"Trying to get something like this: https://www.khanacademy.org/computer-programming/circles/1073977688","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","circle","modulus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Instructions: Hold left mouse button and drag within the canvas\n// Credit for Ben Fry and Casey Reas: https://processing.org/examples/distance2d.html\n\n#define ROW_TILES 5.\n\n// Obtained from: https://www.shadertoy.com/view/Xt23Ry\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec2 transform(vec2 coord) {\n    vec2 uv = coord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;  // correct aspect ratio\n    uv *= ROW_TILES;\n    return uv;\n}\n\n// Given 0 <= t <= 1, f should follow this constraint: 0 <= f(t) <= 1\n// Ideally f(1) = 0\nfloat brightness(float t) {\n    return max(1.-pow(t, 4.),0.0);\n}\n\nfloat multiplier(vec2 center, float t) {\n    float a = 10., b = 1. + .1*rand(center*iTime), u = 0., s = 1.;\n    return a - (a - b) * (1. - exp( -pow(t-u,2.)/pow(s,2.) ));\n}\n\n// uv.x, uv.y in [0, 1]\n// center tells position of tile in canvas\nvec4 renderTile(vec2 uv, vec2 center) {\n    vec2 mouse = transform(iMouse.xy);\n    if (iMouse.z < 0.5)\n        mouse = transform(iResolution.xy/2.) + vec2(cos(iTime), sin(iTime));\n    uv -= .5;\n    uv *= multiplier(center, distance(mouse, center));\n    uv += .5;\n    vec3 col = vec3(0.,1.,1) * brightness(2.*distance(uv, vec2(.5,.5)));\n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = transform(fragCoord);\n\n    fragColor = renderTile(mod(uv, 1.), floor(uv)+.5);\n}","name":"Image","description":"","type":"image"}]}