{"ver":"0.1","info":{"id":"MdlyRf","date":"1489222696","viewed":265,"name":"Psychedelic Seashore","username":"sea","description":"Very relaxing.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["noise","perlin","buffers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hash (vec3 p)\n{\n    p = vec3(dot(p, vec3(189.0, 75.0, 121.0)), dot(p, vec3(122.0, 220.0, 62.0)), dot(p, vec3(34.0, 96.0, 162.0)));\n    return fract(sin(p) * 4328395.432885) * 2.0 - 1.0;\n}\n\nfloat perlin3 (vec3 p)\n{\n    vec3 lbb = floor(p); // Left, bottom, back corner of unit cube.\n    vec3 rtf = ceil(p); // Right, top, front corner of unit cube.\n    \n    vec3 ltb = vec3(lbb.x, rtf.y, lbb.z); \t// Left, top, back corner of unit cube.\n    vec3 rbb = vec3(rtf.x, lbb.y, lbb.z);\t// Right, bottom, back corner of unit cube.\n    vec3 rtb = vec3(rtf.x, rtf.y, lbb.z);\t// Right, top, back corner of unit cube.\n    vec3 rbf = vec3(rtf.x, lbb.y, rtf.z);\t// Right, bottom, front corner of unit cube.\n    vec3 lbf = vec3(lbb.x, lbb.y, rtf.z);\t// Left, bottom, front corner of unit cube.\n    vec3 ltf = vec3(lbb.x, rtf.y, rtf.z);\t// Left, top, front corner of unit cube.\n    \n    // Create a random vector from each corner of the unit cube, this random vector\n    // will not generate a unique vector if given the same vector.\n    vec3 glbb = hash(lbb);\n    vec3 gltb = hash(ltb);\n    vec3 grbb = hash(rbb);\n    vec3 grtb = hash(rtb);\n    vec3 grbf = hash(rbf);\n    vec3 grtf = hash(rtf);\n    vec3 glbf = hash(lbf);\n    vec3 gltf = hash(ltf);\n    \n    // Calculate a directional or relative vector from unit cube corner to point \n    // inside the unit cube.\n    vec3 dlbb = p - lbb;\n    vec3 dltb = p - ltb;\n    vec3 drbb = p - rbb;\n    vec3 drtb = p - rtb;\n    vec3 drbf = p - rbf;\n    vec3 drtf = p - rtf;\n    vec3 dlbf = p - lbf;\n    vec3 dltf = p - ltf;\n    \n    // Calculate the dot product between the point relative to each corner\n    // in the unit square and the random 3d vector generated from each\n    // corner of the unit square.\n    float d1 = dot(dlbb, glbb);\n    float d2 = dot(dltb, gltb);\n    float d3 = dot(drbb, grbb);\n    float d4 = dot(drtb, grtb);\n    float d5 = dot(drbf, grbf);\n    float d6 = dot(drtf, grtf);\n    float d7 = dot(dlbf, glbf);\n    float d8 = dot(dltf, gltf);\n    \n    p = mod(p, 1.0);\n    p = p * p * (3.0 - 2.0 * p);\n    \n    float x1 = mix(d1, d3, p.x); // Flatten unit cube back bottom edge from left to right.\n    float x2 = mix(d2, d4, p.x); // Flatten unit cube back top edge from left to right.\n    float x3 = mix(d7, d5, p.x); // Flatten unit cube front bottom edge from left to right.\n    float x4 = mix(d8, d6, p.x); // Flatten unit cube front top edge from left to right.\n    \n    float y1 = mix(x1, x2, p.y);\n    float y2 = mix(x3, x4, p.y);\n    \n    return mix(y1, y2, p.z);\n}\n\nvec2 normal (vec2 uv)\n{\n    return normalize(vec2(length(texture(iChannel0, uv + vec2(0.01, 0.0))) - length(texture(iChannel0, uv - vec2(0.01, 0.0))),\n                          length(texture(iChannel0, uv + vec2(0.0, 0.01))) - length(texture(iChannel0, uv - vec2(0.0, 0.01)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float depth = length(texture(iChannel0, uv));\n    vec2 n = normal(uv);\n    \n    float x = n.y;\n    float y = -n.x;\n    \n    n = vec2(x, y);\n    \n    vec3 tex = texture(iChannel0, uv).rgb;\n    vec3 color = tex;\n    vec2 uv1 = uv + n * perlin3(vec3(uv * 10.0, 0.0));\n    \n    if (length(uv1) - ((sin(iTime) * 0.5 + 0.5) + 0.25) < 0.0)\n    \tcolor = vec3(1.0 * length(uv1), 0.0, 1.0);\n    else color = vec3(1.0, 0.0, 1.0 * length(1.0 - uv1));\n    color -= color * length(tex) * 0.5;\n    \n    if (abs(length(uv1) - length(uv)) < 0.025)\n    \tcolor = (1.0 - color.bgr);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Hash function, this function will generate a non-unique random vector from\n// an input vector. When I say non-unique, I mean it will always generate the\n// same vector if the input vector is the same as the previous.\nvec3 hash (vec3 p)\n{\n    p = vec3(dot(p, vec3(189.0, 75.0, 121.0)), dot(p, vec3(122.0, 220.0, 62.0)), dot(p, vec3(34.0, 96.0, 162.0)));\n    return fract(sin(p) * 4328395.432885) * 2.0 - 1.0;\n}\n\nfloat perlin3 (vec3 p)\n{\n    vec3 lbb = floor(p); // Left, bottom, back corner of unit cube.\n    vec3 rtf = ceil(p); // Right, top, front corner of unit cube.\n    \n    vec3 ltb = vec3(lbb.x, rtf.y, lbb.z); \t// Left, top, back corner of unit cube.\n    vec3 rbb = vec3(rtf.x, lbb.y, lbb.z);\t// Right, bottom, back corner of unit cube.\n    vec3 rtb = vec3(rtf.x, rtf.y, lbb.z);\t// Right, top, back corner of unit cube.\n    vec3 rbf = vec3(rtf.x, lbb.y, rtf.z);\t// Right, bottom, front corner of unit cube.\n    vec3 lbf = vec3(lbb.x, lbb.y, rtf.z);\t// Left, bottom, front corner of unit cube.\n    vec3 ltf = vec3(lbb.x, rtf.y, rtf.z);\t// Left, top, front corner of unit cube.\n    \n    // Create a random vector from each corner of the unit cube, this random vector\n    // will not generate a unique vector if given the same vector.\n    vec3 glbb = hash(lbb);\n    vec3 gltb = hash(ltb);\n    vec3 grbb = hash(rbb);\n    vec3 grtb = hash(rtb);\n    vec3 grbf = hash(rbf);\n    vec3 grtf = hash(rtf);\n    vec3 glbf = hash(lbf);\n    vec3 gltf = hash(ltf);\n    \n    // Calculate a directional or relative vector from unit cube corner to point \n    // inside the unit cube.\n    vec3 dlbb = p - lbb;\n    vec3 dltb = p - ltb;\n    vec3 drbb = p - rbb;\n    vec3 drtb = p - rtb;\n    vec3 drbf = p - rbf;\n    vec3 drtf = p - rtf;\n    vec3 dlbf = p - lbf;\n    vec3 dltf = p - ltf;\n    \n    // Calculate the dot product between the point relative to each corner\n    // in the unit square and the random 3d vector generated from each\n    // corner of the unit square.\n    float d1 = dot(dlbb, glbb);\n    float d2 = dot(dltb, gltb);\n    float d3 = dot(drbb, grbb);\n    float d4 = dot(drtb, grtb);\n    float d5 = dot(drbf, grbf);\n    float d6 = dot(drtf, grtf);\n    float d7 = dot(dlbf, glbf);\n    float d8 = dot(dltf, gltf);\n    \n    p = mod(p, 1.0);\n    p = p * p * (3.0 - 2.0 * p);\n    \n    float x1 = mix(d1, d3, p.x); // Flatten unit cube back bottom edge from left to right.\n    float x2 = mix(d2, d4, p.x); // Flatten unit cube back top edge from left to right.\n    float x3 = mix(d7, d5, p.x); // Flatten unit cube front bottom edge from left to right.\n    float x4 = mix(d8, d6, p.x); // Flatten unit cube front top edge from left to right.\n    \n    float y1 = mix(x1, x2, p.y);\n    float y2 = mix(x3, x4, p.y);\n    \n    return mix(y1, y2, p.z);\n}\n\nvec2 rotate (vec2 uv, float r)\n{\n    r /= 180.0 * 3.1415926;\n    float x = uv.x * cos(r) - uv.y * sin(r);\n    float y = uv.x * sin(r) + uv.y * cos(r);\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ws = uv * 2.0 - 1.0;\n    \n    ws.x *= iResolution.x / iResolution.y;\n    ws *= 10.0;\n    \n    ws = rotate(ws, length(uv) * sin(iTime) * 45.0);\n    \n    float noise = abs(perlin3(vec3(ws.x - iTime, ws.y - iTime, iTime)));\n\tfragColor = vec4(noise, noise, noise, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}