{"ver":"0.1","info":{"id":"4tfSW7","date":"1436976484","viewed":191,"name":"The Pole is a Lie","username":"Vizual","description":"A simple shadow implementation used to reveal a hidden pole upon which the ball rests. The pole is modeled as an implicit cylinder that lies directly beneath the sphere.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadows","cylinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Light Intensities\nvec3 ia = vec3(0.4,0.4,0.4);\nvec3 id = vec3(1.0,0.9,0.5);\nvec3 is = vec3(1.0,0.9,0.5);\nfloat alpha = 8.0;\n\n// Viewport Resolution\nfloat aspect = iResolution.x / iResolution.y;\nfloat height = 1.0;\nfloat width = aspect;\n\n// Camera and Ground Positions\nvec3 eye = vec3(width/2.0,height/2.0,-3.0);\nfloat ground_z = 1.0;\n\n// Colors\nvec4 sphereColor = vec4(0.9,0.3,0.4,1.0);\n\nbool insideCircle(vec2 P, vec3 center, float rad) \n{\n    float d1 = (P.x - center.x) * (P.x - center.x);\n    float d2 = (P.y - center.y) * (P.y - center.y);\n    return d1 + d2 < rad*rad;\n}\n\nbool intersectsCylinder(vec3 center, float rad, vec3 origin, vec3 dir)\n{\n    vec2 center2D = vec2(center.x,center.y);\n    vec2 origin2D = vec2(origin.x,origin.y);\n    vec2 dir2D = vec2(dir.x,dir.y);\n    \n    vec2 oc = origin2D - center2D;\n    float a = dot(dir2D,dir2D);\n    float b = 2.0 * dot(dir2D,oc);\n    float c = dot(oc,oc) - rad*rad;\n    \n    float det = b*b - 4.0*a*c;\n    if (det < 0.0) {\n        return false;   \n    }\n    else {\n        float t1 = (-b - sqrt(det)) / (2.0*a);\n        float t2 = (-b + sqrt(det)) / (2.0*a);\n        float z1 = origin.z + dir.z*t1;\n        float z2 = origin.z + dir.z*t2;\n        if  (( (z1 < ground_z) && (z1 > 0.0) ) ||\n             ( (z2 < ground_z) && (z2 > 0.0) )) {\n            return true;        \n        }\n        return false;\n    }\n}\n\nbool intersectsSphere(vec3 center, float rad, vec3 origin, vec3 dir)\n{\n    vec3 oc = origin-center;\n    float a = dot(dir,dir);\n    float b = 2.0 * dot(dir,oc);\n    float c = dot(oc,oc) - rad*rad;\n    \n    float det = b*b - 4.0*a*c;\n    return (det >= 0.0) ? true : false;\n}\n\nvec3 getLightPos()\n{\n    float r = 5.0;\n    float t = iTime / 3.0;\n    float x = width/2.0 + 1.5*r*cos(t) / 2.0;\n    float y = height/2.0 + r*sin(t)/2.0;\n    float z = -r;\n    return vec3(x, y, z);\n}\n\nvec4 getSphereColor(vec3 P, vec3 center, float rad)\n{    \n    vec3 N = normalize(P - center);\n    vec3 L1 = normalize(getLightPos() - P);\n    vec3 V = normalize(eye - P);\n    vec3 R = 2.0 * dot(N,L1) * N - L1;\n    \n    vec3 ambient = ia*0.5;\n    vec3 diffuse = dot(N,L1) * id;\n    vec3 specular = pow(max(dot(R,V),0.0),alpha) * is;\n    \n    return vec4(ambient + diffuse + specular, 1.0) * sphereColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = uv.x * aspect;\n    \n    float rad = 0.15;\n    vec3 center = vec3(width/2.0,height/2.0,0.0);\n    \n    if ( insideCircle(uv, center, rad) )\n    {\n        float z = -sqrt(rad*rad - pow(uv.x - center.x,2.0) - pow(uv.y - center.y,2.0));\n        vec3 point = vec3(uv.x, uv.y, z);\n        fragColor = getSphereColor(point, center, rad);\n    }\n    else {\n        vec3 point = vec3(uv.x,uv.y,ground_z);\n        vec3 dir = normalize(getLightPos() - point);\n        if (    intersectsSphere(center, rad, point, dir) || \n                intersectsCylinder(center, rad/4.0, point, dir) ) {\n            fragColor = texture( iChannel0, uv ) * vec4(ia,1.0);\n        }\n        else {\n            fragColor = texture( iChannel0, uv ) * vec4(ia + id,1.0);\n        }\n    }\n}","name":"","description":"","type":"image"}]}