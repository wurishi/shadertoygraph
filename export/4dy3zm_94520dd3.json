{"ver":"0.1","info":{"id":"4dy3zm","date":"1453660778","viewed":477,"name":"sonic-whirl-flow","username":"mds2","description":"Colors flow through a fluid-like (incompressible) flow field which reacts to a piece of music from soundcloud","likes":16,"published":1,"flags":36,"usePreview":0,"tags":["sound","music","visualizer","flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// uncomment the following define to get pleasant, subdued,\n// \"earthy\" colors\n//\n// #define SUBDUED_COLORS\n//\n// leave it commented to let the scene look like a lava lamp\n\n// insightful comments on how everything \"works\" are to be found\n// in the code for \"Buf A\"\n// \"Buf B\" just allows me to re-use the sound texture in multiple shaders\n// without causing ShaderToy to play the same track over itself\n// at possibly-different time offsets.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n#ifdef SUBDUED_COLORS\n    fragColor = texture(iChannel2, texture(iChannel0, uv).xy);\n#else\n    fragColor = texture(iChannel0, uv);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This makes heavy use of the fact that the curl of a 2d scalar field\n// yields the vector field of an incompressible (and thus fluid-like)\n// flow.\n//\n// The same principle is used in so-called \"curl noise\", which is heavily\n// used in producing visually-convincing atmospheric effects.\n//\n// The \"flow\" here is comprised of a general left-to-right flow,\n// two meandering \"whorls\", and a time-dependent flow\n// induced by taking the curl of the 2d texture that ShaderToy\n// gives along with the soundcloud track, which is why the fine-grained\n// swirliness tends to \"pulse\" with the beat.\n//\n// The buffer corresponding to this texture is \"advected\" by the\n// aforementioned flow field, and the color of the results is\n// ever-so-slightly hue-rotated by the matrix \"colorShift\"\n// (generated by sandwhiching a small YZ rotation between the\n// RGB-> YUV matrix and its inverse)\n\nconst mat3 colorShift = mat3( 1.0016374 ,  0.00332076, -0.00495827,\n       -0.00327048,  1.00033642,  0.00293016,\n       0.01252787, -0.01043093,  0.99792338);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 flow = vec2(-0.5, 0.0);\n    \n    vec2 whorlLoc = 0.5 + 0.4 * vec2(sin(0.27 * iTime),\n                                     cos(0.37 * iTime));\n    // whorl is the curl of a gaussian centered around\n    // whorlLoc\n    // something like curl exp(-5.0 * dot ((uv - whorlLoc), (uv - whorlLoc)))\n    // or\n    // vec2(-10.0, 10.0) * (uv - whorlLoc).yx *\n    // exp (-5.0 * dot ((uv - whorlLoc), (uv - whorlLoc)));\n    vec2 whorlRel = uv - whorlLoc;\n    vec2 whorl = \n        vec2 (-10.0, 10.0) * whorlRel.yx *\n        exp(-50.0 * dot(whorlRel, whorlRel));\n    \n    flow = flow + whorl;\n    \n    // and now we add another curl-of-a-gaussian whorl centered\n    // around a different meandering loc.\n    //\n    // This one twists in the opposite direction of the first one.\n    //\n    // Nice property of incompressible flows :\n    // taking a linear combination of two of them gives another\n    // incompressible flow.\n    // (to prove to oneself, recall that the criteria for a flow to be\n    // \"incompressible\" is that its divergence is zero. Divergence\n    // is a linear operator, so the divergence of the sum of a bunch\n    // of flows with zero divergence is also zero)\n    \n    whorlLoc = 0.5 + 0.4 * vec2(cos(0.23 * iTime),\n                                      sin(0.31 * iTime));\n    whorlRel = uv - whorlLoc;\n    whorlRel.x = mix(whorlRel.x, whorlRel.x - 1.0, step(abs(whorlRel.x - 1.0),\n                                                        abs(whorlRel.x)));\n    whorlRel.x = mix(whorlRel.x, whorlRel.x + 1.0, step(abs(whorlRel.x + 1.0),\n                                                        abs(whorlRel.x)));\n    whorl = \n        vec2 (10.0, -10.0) * whorlRel.yx *\n        exp(-50.0 * dot(whorlRel, whorlRel));\n    \n    flow = flow + whorl;\n    \n    \n    \n    // Oh, and here we add the sound-reactive flow.\n    // please comment if you think of a better way to take the curl here.\n    //\n\t// Also note that I am not letting the flow wrap around in Y.\n    // and I am considering changing this.\n    vec2 soundFlow = vec2 (texture(iChannel1, uv + vec2(0.0, 0.01)).x -\n                           texture(iChannel1, uv).x,\n                           texture(iChannel1, uv).x -\n                           texture(iChannel1, uv + vec2(0.01, 0.0)).x); \n    \n    flow = flow + 50.0 * soundFlow;\n    vec2 nextsample = uv + 0.005 * flow;\n    nextsample.x = mod(nextsample.x, 1.0);\n    vec3 colorSample = texture(iChannel0, nextsample).xyz;\n    colorSample = colorShift * colorShift * colorShift * colorSample;\n    \n    float leftness = smoothstep(0.0, 0.15, length(uv - vec2(0.5)));\n    float brightness = texture(iChannel1, vec2(0.5, 0.5)).x + 0.1;\n    fragColor = vec4( mix (vec3(0.8, 0.3, 0.7) * brightness,\n                           colorSample, 0.9 + 0.1 * leftness), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}