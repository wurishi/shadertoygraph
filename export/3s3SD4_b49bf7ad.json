{"ver":"0.1","info":{"id":"3s3SD4","date":"1571935895","viewed":165,"name":"ShaderTober - Ancient","username":"Flopine","description":"A small doodle with inktober's theme \"Ancient\". \nA different version of this shader: https://www.shadertoy.com/view/td23zD ","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","chromaticaberation","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\t\n    float anim = fract(sin(iTime)*1248.4);\n    vec3 col = vec3(texture(iChannel0,uv+0.05*anim*0.2).r,\n                    texture(iChannel0,uv+0.06*anim*0.25).g,\n                    texture(iChannel0,uv+0.07*anim*0.35).b\n                   );\n        \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ITER 100.\n#define time iTime\n#define PI 3.141592\n\nvec2 moda (vec2 p, float per)\n{\n  float a = atan(p.y,p.x);\n  float l = length(p);\n  a = mod(a-per/2., per)-per/2.;\n  return vec2(cos(a), sin(a))*l; \n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a), -sin(a), cos(a));}\n\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 35.1571)))*5418.548416);}\n\n// iq function for signed hexagone\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n  float st = k/n;\n  float u = b-k;\n  return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat room (vec3 p)\n{\n  float ground = abs(p.y+5.)-0.1;\n  float hex = sdHexPrism(vec3(p.x, p.z, p.y+2.), vec2(50.));\n  return min(ground, -hex);\n}\n\nfloat column (vec3 p)\n{\n  float width = 3.;\n  float c1 = length(p.xz)-width;\n\n  p.xz *= rot(p.y*0.5);\n  p.xz *= rot(time);\n  p.xz = moda(p.xz, PI);\n  p.x -= width;\n  float c2 = length(p.xz)-1.2;\n  return min(c1,c2);\n}\n\nfloat g1 = 0.;\nfloat columns (vec3 p)\n{\n  p.xz = moda(p.xz, PI/3.);\n  p.x -= 25.;\n  float d =  column(p);\n  g1 += 0.1/(0.1+d*d);\n  return d;\n}\n\nfloat pedestral (vec3 p)\n{\n  vec3 new_p = vec3(p.x, p.z,p.y+4.5);\n  float width = 15.;\n  float thick = 0.2;\n  float st = 3.;\n  float hexs = sdHexPrism(new_p, vec2(width, thick));\n  for (float i=1.; i<7.; i++)\n  {\n      float ratio = i/7.;\n    thick += ratio*0.8;\n    width -= ratio*3.;\n    new_p.z -=ratio*3.;\n    hexs = stmin(hexs, sdHexPrism(new_p, vec2(width, thick)),1., st);\n  }\n  return hexs;\n}\n\nfloat g2 = 0.; \nfloat gem (vec3 p)\n{\n    p.xz *= rot(time);\n    p.y -= 14.;\n    float d = dot(p,normalize(sign(p)))-1.;\n    g2 += 0.5/(0.5+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n  float r = stmin(room(p),columns(p), 5., 3.);\n  return min(r, stmin(gem(p),pedestral(p),5.,4.));\n}\n\nvec3 get_cam (vec3 ro, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target-ro);\n  vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n  vec3 up = normalize(cross(forward, left));\n  return forward*fov + left*uv.x + up*uv.y;\n}\n\nvec3 get_normals (vec3 p)\n{\n  vec2 eps = vec2(0.01,0.);\n  return normalize(vec3(SDF(p+eps.xyy)- SDF(p-eps.xyy),\n                        SDF(p+eps.yxy)- SDF(p-eps.yxy),\n                        SDF(p+eps.yyx)- SDF(p-eps.yyx)   \n                        )\n                  ); \n}\n\nvec3 point_light (vec3 p, vec3 n)\n{\n  vec3 lpos = vec3(0.,5.,0.);\n  vec3 ldir = normalize(lpos-p);\n  float ldist = length(lpos-p);\n  float dotNL = dot(n , ldir)* 0.5 +0.5;\n  return (vec3(0.8,0.8,0.)*dotNL) / (0.01 * ldist * ldist);\n}\n\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float dither = random(uv);\n\n    \n    \n  vec3 ro = vec3(1., 19., -32);\n  vec3 p = ro;\n  vec3 target = vec3(0.,0.5,0.);\n  vec3 rd = normalize(get_cam(ro, target, uv, 1.));\n    \n  float shad = 0.;\n  vec3 col = vec3(0.);\n\n  for (float i=0.; i<ITER; i++)\n  {\n      float d = SDF(p);\n      if (d<0.001)\n      {\n        vec3 n = get_normals(p);\n        // hemisphere ligting\n        col = mix(vec3(0.4, 0.35, 0.), vec3(0.9,0.7,0.6), lighting (n, vec3(-5., 10., -3.)));\n        \n        // point light\n        col += point_light(p, n);\n      \n        // fake AO\n        shad = i/ITER;\n        col *= (1.-shad);\n        break;\n      }\n    d *= 0.9 + dither*0.1;\n    p += d*rd;\n  }\n\n  float t = length(ro-p);\n  col += g1 * vec3(0.5,0.2,0.);\n   col -= g2;\n  // fog\n  col = mix(col,vec3(0.8, 0.2, 0.2), 1.-exp(-0.0003*t*t));\n    \n  fragColor = vec4(pow(clamp(col,0.,1.),vec3(0.45)),1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}