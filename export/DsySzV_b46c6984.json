{"ver":"0.1","info":{"id":"DsySzV","date":"1681298071","viewed":48,"name":"Réflexion du lanceur de rayons","username":"xiongjian","description":"Réflexion du lanceur de rayons","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Constantes et structures\n\n/*\ncameraPos : position de la caméra.\ncameraTarget : la position de la cible d'observation de la caméra.\ncameraFovY : L'angle de vue de la caméra.\nspherePos : La position de la sphère, devant la position cible de la caméra.\nsphereRadius : Le rayon de la sphère.\nsphereCol : la couleur de la sphère.\nsphereMat : la propriété matérielle de la sphère.\nsphereId : ID de la sphère, utilisé pour identifier différents objets dans le lancer de rayons.\nambianteCol : couleur de la lumière ambiante.\nlightCol : La couleur de la source lumineuse.\nlightPos : La position de la source de lumière.\nskyCol : couleur du ciel.\nskyId : ID du ciel.\nplanePos : la position de l'avion.\nplaneNormal : le vecteur normal du plan.\nplaneCol1 : La première couleur du plan.\nplaneCol2 : la deuxième couleur du plan.\nplaneMat : la propriété matérielle du plan.\nplaneId : ID de l'avion.\n*/\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\nstruct ShadeInfo\n{\n    vec3 shadedCol;\n    float Ks;\n};\n    \nconst int MAX_NB_BOUNCES = 5;\n\n vec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; \n vec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1);\nvec3 lightPos = vec3(8,10,-12);\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_SIZE = 5;\n//transformer le système de coordonnées\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\n/*\nLorsqu'un rayon coupe une sphère,\nle point d'intersection du rayon et de la sphère et le vecteur normal au point d'intersection sont calculés, \net la distance entre le point d'intersection du rayon et de la sphère et le point de départ du rayon est renvoyée\n*/\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n/*intersection de la lumière et du plan*/\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\n/*La position et la direction du rayon émis depuis la position de la caméra aux coordonnées pixel pixCoord*/\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n//Ce code implémente le modèle d'éclairage Phong\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V)\n{\n    vec3 A = sphereMat.Ka * ambiantCol;\n    vec3 D = sphereMat.Kd * sphereCol * lightCol * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * lightCol * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n/*Calcule l'intersection la plus proche d'un rayon \nà partir de la position de la caméra avec tous les objets (sphères et plans) de la scène \net renvoie la distance de l'intersection la plus proche à la caméra\n*/\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n//définit la couleur de chaque boule\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n//Obtenez la couleur du point spécifié sur le plan et jugez de la couleur du point en fonction du fait que la ligne et la colonne où se trouve le point sont des nombres pairs.\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        \tbreak;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        \tbreak;\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n        \tbreak;\n    }\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\n\n\n\n\n/*\nFonction de lancer de rayons aux coordonnées de pixels. Il calcule d'abord l'origine et la direction du rayon de la caméra à l'aide des coordonnées en pixels, \npuis utilise la fonction computeNearestIntersection pour trouver l'intersection du rayon avec l'objet le plus proche dans la scène. \nUtilisez ensuite la fonction getObjectColorAtPoint pour obtenir les propriétés de couleur et de matériau du point d'intersection.\nCalcule la direction réfléchie du rayon en utilisant la position de la source lumineuse, la normale du point d'intersection et la direction de la caméra. \nAvant cela, utilisez la fonction getShadowFactorAtPoint pour déterminer si le point est dans l'ombre afin de calculer l'éclairage Phong pour ce point. \nEnsuite, il repositionne le rayon du côté de 0,001 fois la normale à partir de ce point et recalcule la direction du rayon en fonction de sa direction de réflexion.\nUtilisez le tableau infos pour enregistrer la couleur et la réflectance à chaque intersection jusqu'à ce que le nombre maximum de rebonds soit atteint. \nnfin, il compose la couleur par facteur de rebond pour obtenir la couleur finale du lancer de rayons.\n*/\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos,rayDir,objectId,intersecI,normalI);\n        \n        if(distI <= 0.0)\n        {\n            infos[nbBounces].shadedCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        \n        Material objMat;\n    \tvec3 col = getObjectColorAtPoint(objectId, intersecI, objMat);\n    \tvec3 L = normalize(lightPos - intersecI);\n    \tvec3 R = normalize(2.0*dot(normalI,L)*normalI - L);\n    \tvec3 V = -rayDir;\n        \n        float Ldist = distance(intersecI,lightPos);\n        \n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objMat, L, Ldist);\n        \n    \t//Phong shading to get the color of the surface point\n    \tvec3 c = computePhongShading(col, objMat, shadowFactor, normalI, L, R, V);\n        \n        infos[nbBounces].shadedCol = c;\n        infos[nbBounces].Ks = objMat.Ks;\n        \n        rayPos = intersecI + 0.001*normalI;\n        rayDir = normalize(2.0*dot(normalI,V)*normalI - V);\n        //objId = objectId;\n        \n        nbBounces++;\n        \n    }while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n   \tdo\n    {\n        resCol = infos[nbBounces].shadedCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    }while(nbBounces >= 0);\n    \n    return resCol;\n}\n\n//fonction pour générer du bruit 2D\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n//Une fonction d'animation de scène qui prend du temps comme paramètre d'entrée\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    lightPos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\n\n\n\n\n\n/*\nLa fonction mainImage reçoit un paramètre de type vec2 fragCoord, qui représente les coordonnées du pixel écran en cours de rendu. \nLa fonction génère également une valeur vec4 fragColor qui représente la couleur finale du pixel.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime;\n    \n    animateScene(time*1.0);\n    \n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    vec3 resCol = vec3(0);\n    \n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        for (int j=0; j<PIXEL_SAMPLING_SIZE; j++) \n        {\n            vec2 offset = vec2(float(i)/(float(PIXEL_SAMPLING_GRID_SIZE)*iResolution.x),float(j)/(float(PIXEL_SAMPLING_SIZE)*iResolution.y));\n           \n\t\t\tresCol += RaytraceAtPixelCoord(fragCoord + offset);\n      \t}\n    }\n    resCol /= float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_SIZE);\n    \n    fragColor = vec4(resCol,1);\n}","name":"Image","description":"","type":"image"}]}