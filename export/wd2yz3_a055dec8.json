{"ver":"0.1","info":{"id":"wd2yz3","date":"1587103212","viewed":111,"name":"Day3: Line Drawing + Transforms","username":"fluxatron","description":"Learning how to draw lines and some transformation fun","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["line","transform","segments"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Shape /////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 shapeCol = vec3(0.8,0.2,0.4);\nconst int numVerts = 5;\nvec2[] shape = vec2[] (\n    vec2( 0.0, 0.0), // bot left\n    vec2( 0.0, 1.0), // top left\n    vec2( 0.5, 0.5), // pivot\n    vec2( 1.0, 1.0), // top right\n    vec2( 1.0, 0.0)  // bot right\n);\n\n// Find the y values given an x along the line\nfloat findY(float x, vec2[numVerts] shape)\n{\n    // bsearch?? to find first value higher than x\n    // handle edge cases\n    // lerp between i and i-1's y values\n    return 0.0; \n}\n\n// Finds the distance of P from the line A to B\nfloat segment( in vec2 p, vec2 a, vec2 b )\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tfloat h = clamp(dot(ap,ab)/dot(ab,ab), 0.0, 1.0); // project ap onto ab\n\treturn length( ap - ab*h ); // finds length of vec from p to the projection of p onto ab\n}\n\nvec3 drawShape(vec2 p, mat3 tform, vec3 col)\n{\n    float thicc = 0.01;\n    \n    for(int i = 1; i < numVerts; i++)\n    {\n    \tvec3 a = tform * vec3(shape[i-1], 1);\n    \tvec3 b = tform * vec3(shape[i], 1);\n        \n        if (segment(p, a.xy, b.xy) < thicc)\n        \treturn shapeCol;\n    }\n     \n    return col;\n}\n\nvoid updateShape()\n{\n    shape[0] += vec2(0.2*sin(iTime), 0.1*cos(iTime));\n    shape[4] += vec2(0.2*-cos(iTime), 0.1*sin(iTime));\n}\n\n\n// Matrix transform helpers ////////////////////////////////////////////////////////////////////////////\nmat3 createTransMat(vec2 translation)\n{\n    return mat3(vec3(1,0,0), \n                vec3(0,1,0), \n                vec3(translation,1));\n}\nmat3 createScaleMat(vec2 scale)\n{\n    return mat3(scale.x, 0, 0,\n                0, scale.y, 0,\n                0, 0,       1);\n}\nmat3 createRotationMat(float rad)\n{\n    return mat3(cos(rad), sin(rad), 0,\n               -sin(rad), cos(rad), 0,\n                0,        0,        1);\n}\nmat3 createAffineMat(vec2 translation, float rotation, vec2 scale)\n{\n    mat3 S = mat3(createScaleMat(scale));\n    mat3 R = mat3(createRotationMat(rotation));\n    mat3 T = createTransMat(translation);\n    return S*R*T;\n}\n\n\n// Transformations ////////////////////////////////////////////////////////////////////////////////////\nmat3 matTranslate(mat3 m, vec2 translation)\n{\n    return createTransMat(translation) * m;\n}\nmat3 matRotate(mat3 m, float rad)\n{\n    return createRotationMat(rad) * m;\n}\nmat3 matScale(mat3 m, vec2 scale)\n{\n    return createScaleMat(scale) *  m;\n}\n/*\nmat3 matRotate(mat3 m, float rad, vec2 pivot)\n{\n    return createTransMat(-pivot) * matRotate(m, rad) * createTransMat(pivot);\n}\nmat3 matScale(mat3 m, vec2 scale, vec2 pivot)\n{\n    return createTransMat(-pivot) * matScale(m, scale) * createTransMat(pivot);\n}\n*/\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 uvNorm = fragCoord/iResolution.xy;\n\n    updateShape();\n    \n    // Shape mat - moves pivot to the middle of our shape\n    mat3 shapeMat = createTransMat(vec2(-.5,-.5));\n    \n    // Model mat - moves/rotates and squishes our model\n    mat3 modelMat = mat3(1);\n   \tmodelMat = matScale(modelMat, 0.5 + vec2(0.1*sin((iTime+3.0)*3.0), 0.1*cos(iTime*3.0)));\n    modelMat = matRotate(modelMat, sin(iTime*0.7)*0.7);\n    modelMat = matTranslate(modelMat, vec2(aspectRatio/2., 0.5));\n    \n    // View mat - pan the view about\n    mat3 viewMat = mat3(1);\n    viewMat = matTranslate(viewMat, 0.05 * vec2(2.0*sin(1.2*iTime+3.0), cos(iTime+5.0)) );\n    \n    vec3 col = viewMat*vec3(uvNorm,1) * 0.2; // Draw background\n    col = drawShape(uv, viewMat*modelMat*shapeMat, col);\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}