{"ver":"0.1","info":{"id":"XflGzs","date":"1703377639","viewed":65,"name":"Truchets (and domain rep) study","username":"Elsio","description":"Não é só mudar o código. É, primeiro, tentar entender o que o cara fez. E enquanto a gente refaz a gente entende alguma coisa. ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","refraction","truchet","aa"],"hasliked":0,"parentid":"fd2czG","parentname":"Year of Truchets #056"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define PI 3.14\n#define PI2 6.28\n#define t iTime\n#define SIZE vec3(1.5)\n#define HLF (SIZE / 2.)\n\nfloat lsp(float b, float e, float t) {\n    return clamp((t - b) / (e - b), 0., 1.);\n}\n\nfloat box(vec3 p, vec3 b) {\n    return length(max(b = abs(p) - b, 0.)) + min(max(b.x, max(b.y, b.z)), 0.);\n}\n\n\nfloat torus(vec3 p) {\n    vec2 q = vec2(length(p.zx) - HLF.x, p.y);\n    return length(q) - .1;\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1. - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\n\nfloat map(vec3 p) {\n    p *= 1. - dot(p, p) * .02;\n    \n    float tmod = mod(t * 1.6, 15.),\n          sn, t1, t2,\n          trh, trx, jre;\n    \n    p.yz *= rot(t * .075);\n    p.xz *= rot(t * .05);\n    \n    vec3 GRID = vec3(1, 1, 2),\n         id = floor((p + HLF) / SIZE) - GRID,\n         q = p - SIZE * clamp(round(p / SIZE), - GRID, GRID);\n    \n    t1 = lsp(sn     , sn +  2., tmod); \n    t2 = lsp(sn + 8., sn + 10., tmod); \n    \n    mod(id.y + mod(id.z + id.x, 2.), 2.) * 2. - 1. > .5\n        ? q.zx *= rot((t1 - t2) * 1.57)\n        : q.xy *= rot((t1 - t2) * 1.57);\n    \n    //q.zx *= rot(t); // bagunça\n    \n    trh = torus((vec3(0, HLF.x, -HLF.y) + q).yxz);\n    trx = torus(vec3(HLF.x, 0, HLF.z) + q);\n    jre = torus((q - vec3(HLF.xy, 0)).yzx);\n    \n    return max(\n               min(\n                   abs(\n                       min(trx, min(trh, jre))\n                   ) - .02, \n                   closestWall(q) + .02\n               ), \n               box(q, HLF * .98)\n           );\n}\n\n\nvec3 normal(vec3 p, float t) {\n    vec3 s = vec3(0, t, 0);\n    return normalize(\n                 vec3(\n                     map(p + s.yxx),\n                     map(p + s),\n                     map(p + s.xxy)\n                 ) - map(p));}\n\n\nvec3 shade(vec3 p, vec3 n) {\n    return vec3(.15) \n            * clamp(\n                  dot(n, normalize(vec3(2, 1, 6))),\n                 .01, 1.\n              );}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 R = iResolution.xy;    \n    u = (u + u - R.xy) / R.x;\n\n    vec3 ro = vec3(0, 0, 3.75), \n         rd = normalize(vec3(u, -2)),\n         p  = ro, col, n, rf;\n    \n    float b = 6., k = 1., iv = 1., d, \n          alpha = 1.;\n          \n    for(int i = 0; i < 180; i++) {\n        \n        d = map(p) * .8;\n        p += rd * d * k;\n        \n        if(d * d < 1e-7) {\n            n = normal(p, d);\n            col += shade(p, n);\n            col.b *= 1.05;\n            \n            b -= 1.; if(b < 1.) break;\n            \n            p += rd * .001;\n            k = sign(map(p));\n            rf = refract(rd, n, iv > 0. ? .8 : 1.5);\n            iv *= -1.;\n            \n            if(length(rf) == 0.) \n                rf = reflect(rd, n);\n            \n            rd = rf;\n            p += -n * .01;\n        }\n\n        if(distance(p, rd) > 5.) break;\n    }\n\n    o.rgb = col * 1.5;\n}","name":"Image","description":"","type":"image"}]}