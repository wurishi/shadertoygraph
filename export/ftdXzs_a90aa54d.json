{"ver":"0.1","info":{"id":"ftdXzs","date":"1639612274","viewed":234,"name":"music sequencer","username":"gaz","description":"This is the music sequencer I used at tokyodemofest2021.\nI rewrote it for clarity.","likes":21,"published":1,"flags":8,"usePreview":0,"tags":["music"],"hasliked":0,"parentid":"7t3XRl","parentname":"Sound Shaderの解説 3"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/MtyXRW\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nI wrote a commentary article in Japanese\n\nhttps://gaziya.hateblo.jp/entry/2021/12/14/191629\nhttps://gaziya.hateblo.jp/entry/2021/12/15/125448\nhttps://gaziya.hateblo.jp/entry/2021/12/15/222203\n\nI'm using a translation app to convert to English,\nso please don't get me started on the strange English.\n*/\n\n\n// sound source\n#define PI acos(-1.)\n#define PIH (PI * .5)\n#define TAU (PI * 2.)\n#define osc_sin(x) sin((x) * TAU)\n#define osc_saw(x) (1. - fract(x) * 2.)\n#define osc_sqr(x) sign(.5 - fract(x))\n#define osc_tri(x) (asin(sin((x) * PI)) / PIH)\n \nfloat noize(float t,  float a, float b){\n    float g = fract(cos(t * exp2(a)) * exp2(b)) + 6.;\n    return exp(-.08 * g * g) * 40. - 1.;\n}\n\nfloat kick(float t)\n{\n    return clamp(1.5 * asin(cos(320. * t -30.0 * exp(-40. * t))),\n                   -1.,\n                    1.\n                 ) * exp(-4. * t);\n}\n\nfloat snare(float t){\n    float n = noize(t, 10., 10.) * exp(-t * 10.);\n    float f = t * 160.;\n    float a = .3 * osc_tri(1.2 * f) * exp(-t * 3.);\n    float b = .05 * osc_sin(10. * f + a) * exp(-t * 3.);\n    float c = osc_sin(f + b) * exp(-t * 15.);\n    return n + c;\n}\n\nfloat hihat(float t){\n    return noize(t, 10., 18.) * exp(-t * 15.);\n}\n\nfloat piano(float t, float f){\n    float a;\n    float b = 0.;\n    float g = 0.;\n    f *= t;\n    for(float i = 1.; i < 5.; i++){\n        b += a = exp(-i * .5);\n        g += a * osc_sin(f * i) * exp(-t * 1.8 / (2. - i * .1));\n    }\n    g *= 1. + 1.2 * exp(-5. * t);\n    return g / b;\n}\n\nfloat lead(float t, float f){\n    f *= t;\n    return clamp(\n            (\n               8. * osc_saw(f) + \n               2. * osc_sin(f * 2.) + \n               osc_tri(f * 3.)\n            ) / 3.,\n            -1.,\n            1.\n        ) * exp(-3. * t);\n}\n\nfloat base(float t, float f){\n    f *= t;\n    return clamp(\n            (\n                8. * osc_sqr(f) + \n                3. * osc_saw(f * 2.) + \n                osc_sin(f*3.)\n             ) / 2.,\n             -1.,\n             1.\n         ) * exp(-4. * t);\n}\n\n// sequencer\n\n#define C3  60\n#define Cs3 61\n#define D3  62\n#define Ds3 63\n#define E3  64\n#define F3  65\n#define Fs3 66\n#define G3  67\n#define Gs3 68\n#define A3  69\n#define As3 70\n#define B3  71\n#define C4  72\n#define Cs4 73\n#define D4  74\n#define Ds4 75\n#define E4  76\n#define F4  77\n#define Fs4 78\n#define G4  79\n#define Gs4 80\n#define A4  81\n#define As4 82\n#define B4  83\n\nfloat OFFSET;\nint TMP, POS, IDX;\n#define EXTRACT(m, a)\\\n    {\\\n        TIME = mod(TIME, barTime);\\\n        IDX = -1;\\\n        float b, c;\\\n        for(int i = 0; i < m; i++){\\\n            b = barTime / float(m);\\\n            c = float(int[]a[i % int[]a.length()]);\\\n            if(c > 0.) OFFSET = 0.;\\\n            if(TIME < b) break;\\\n            IDX += int(c);\\\n            TIME -= b;\\\n            OFFSET += b / max(1., c);\\\n        }\\\n        if(c > 0.)IDX += int(TIME / b * c) + 1;\\\n        TIME = mod(TIME, b / max(1., c));\\\n        TIME += OFFSET;\\\n    }\n    \n// Rhythm( beat<Number of divisions per bar> , Array of beat divisions )\n// Arrays are enclosed in `()`\n// I'm using a trick on the macro to free the array size\n// If it is the same array, it will be repeated even if it is omitted.\n#define Rhythm(m, a)\\\n    TMP++;\\\n    if(POS == TMP) EXTRACT(m, a)\n// Info( Array of int information )\n// Arrays are enclosed in `()`\n// I'm using a trick on the macro to free the array size\n// If it is the same array, it will be repeated even if it is omitted.\n#define Info(a)\\\n    if(POS == TMP) INF = int[]a[IDX % int[]a.length()];\n\n// Reset every time you change the information.\n#define Reset \\\n    OFFSET = 100.;\\\n    TIME = time;\\\n    TMP = -1;\\\n    POS = int(time / barTime);\n// Loop( Number of measures to repeat )\n#define Loop(n)\\\n    TIME = mod(TIME, barTime * float(n));\\\n    POS %= n;\n\nfloat note2freq(int note){\n    return 440. * exp2(float(note - 69) / 12.);\n}\n\n// Set the pitch of the three chords to int\nint encodeChord(int pitch1, int pitch2, int pitch3){\n    return pitch1 +\n        (pitch2 << 7) +\n        (pitch3 << 14);\n}\n\n// Set the pitch of the four chords to int\nint encodeChord(int pitch1, int pitch2, int pitch3, int pitch4){\n    return pitch1 +\n        (pitch2 << 7) +\n        (pitch3 << 14) +\n        (pitch4 << 21) +\n        (1 << 28) ; // Flag to identify 4 chords\n}\n\n// Make int information into 4 chords\nivec4 decodeChord(int chord){\n    return ivec4(\n        chord & 127,\n        chord >> 7 & 127,\n        chord >> 14 & 127,\n        chord >> 21 & 127\n    );\n}\n\n// Get the number of notes in a chord\nint chordLength(int chord){\n    return 3 + (chord >> 28 & 1);\n}\n\nvec2 mainSound( int samp, float time ){\n    float bpm = 120.;\n    // One bar time\n    float barTime = 240. / bpm;\n    // Time to input to the sound source\n    float TIME;\n    // Current information\n    int INF;\n    float gain = 0.;\n\n    Reset;\n    Loop(1)\n    Rhythm(2, (1))\n    gain += .5 * kick(TIME);\n \n    Reset;\n    Loop(4)\n    for(int i = 0; i < 3; i++){\n        Rhythm(4, (0, 1))\n    }\n    Rhythm(4, (0, 1, 0, 2)) \n    gain += .6 * snare(TIME);\n      \n    Reset;\n    Loop(1)\n    Rhythm(8, (1)) Info((1, 1, 2, 1))\n    gain += .7 * hihat(TIME) * float(INF) * .5;\n    \n    Reset;\n    Loop(4)\n    Rhythm(1, (1)) Info((encodeChord(C3, E3, G3)))\n    Rhythm(1, (1)) Info((encodeChord(F3, A4, C4)))\n    Rhythm(1, (1)) Info((encodeChord(A3, C4, E4)))\n    Rhythm(2, (1)) Info((encodeChord(G3, B4, D4, F4), encodeChord(D3, F3, A3)))\n    \n    ivec4 chord = decodeChord(INF);\n    int itr = chordLength(INF);\n    \n    for(int i = 0; i < itr; i++){\n        gain += .6 * piano(TIME, note2freq(chord[i])) / float(itr);\n    }\n    \n    Reset;\n    Loop(1)\n    Rhythm(8, (1)) Info((chord[0] - 24, chord[0] - 12))\n    gain += .2 * base(TIME, note2freq(INF));\n      \n    Reset;\n    Loop(1)\n    Rhythm(4, (1, 1, 1, 0)) Info((C3, E3, G3))\n    gain += .2 * lead(TIME, note2freq(INF));\n    \n    return .5 * clamp(1.5 * vec2(gain), -1., 1.);\n}","name":"Sound","description":"","type":"sound"}]}