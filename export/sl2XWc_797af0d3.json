{"ver":"0.1","info":{"id":"sl2XWc","date":"1628810578","viewed":71,"name":"Skiera Labyrinth 1","username":"kesipyc","description":"Infinite labyrinth. \n!!!Stateless (as in each cell is calculated independently)\nNo loops. Each cell is accessible. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["labyrinth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n\nfloat PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   \nfloat goldNoise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n//0-down, 1-right, 2-left\nint _dir(int x, int y, float labSeed) {\n    labSeed = labSeed + 1.0; //zero would ruin it as mult by zero will be zero later\n    \n    float prob1 = 0.22;//0.34;\n    float prob2 = 0.78;//0.66;\n\n    float dir = random(vec2(x,y)*labSeed);//goldNoise(vec2(x, y), labSeed);\n    if (dir <= prob1) {\n        return 0;\n    }\n    else { \n        if (dir <= prob2) {\n            return 1;\n        }\n        \n        //if cross to the left of this is \"right\" than this one can't have left\n        //if (_dir2(x - 1, y, labSeed) == 1) {\n        float dir2 = random(vec2(x-1,y)*labSeed);//goldNoise(vec2(x - 1, y), labSeed);\n        if (dir2 > prob1 && dir2 <= prob2) {\n          return 0;\n        }\n        \n        return 2;\n    }\n}\n\nfloat blockedX(in ivec2 xy, float labSeed, float zoom) {\n    if (xy.x == 0) return 10.0;\n    if (xy.x == int(floor(zoom))) return 10.0;\n    \n    //up always false\n    \n    //down needs. to check prev y cross point down\n    if (xy.y == 0) return 1.0;\n    \n    if (_dir(xy.x, xy.y, labSeed) == 0) return 10.0;\n    \n    return 1.0;\n}\n\nfloat blockedY(in ivec2 xy, float labSeed, float zoom) {\n    if (xy.y == 0) return 10.0;\n    if (xy.y == int(floor(zoom))) return 10.0;\n    \n    //check right\n    bool right = false;\n    if (xy.x != 0) {\n      if (_dir(xy.x, xy.y, labSeed) == 1) right = true;\n    }\n    \n    //check left\n    bool left = false;\n    if (xy.x != int(floor(zoom)) - 1) {\n      if (_dir(xy.x + 1, xy.y, labSeed) == 2) left = true;    \n    }\n    \n    if (right || left) return 10.0;\n    \n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = floor(min(iResolution.x, iResolution.y) / 32.0);\n    float labSeed = floor(iTime); //or put const for 1 lab\n\n\n    zoom = 2.0 * zoom; //so it's even\n\n    float width = 10.0 / iResolution.x * zoom;\n\n    vec2 uv = ((fragCoord.xy /iResolution.xy) - 0.5) * zoom;\n    uv.y *= -1.;\n\n\n    float gridX = step(fract(uv.x), width*0.75)*.2 / 2.;\n    float gridY = step(fract(uv.y), width*0.75)*.2 / 2.;\n\n    int adj = int(floor(zoom / 2.));\n    if (gridX > 0.0) {\n        ivec2 xy = ivec2(floor(uv.xy)) + adj;\n        gridX *= blockedX(xy, labSeed, zoom); \n    }\n\n    if (gridY > 0.0) {\n        ivec2 xy = ivec2(floor(uv.xy)) + adj;\n        gridY *= blockedY(xy, labSeed, zoom); \n    }\n\n    float grid = max(gridX, gridY);\n\n    vec3 col = vec3(1.0, 1.0, 1.0) - grid;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}