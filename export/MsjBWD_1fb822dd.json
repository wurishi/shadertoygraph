{"ver":"0.1","info":{"id":"MsjBWD","date":"1500524357","viewed":255,"name":"Conway-Pinwheel Tiling (dual)","username":"ttoinou","description":"Modifying [url]https://www.shadertoy.com/view/XsBfzW[/url] with Conway - Pinwheel triangle (1 2 sqrt(5)) rep-tile tiling ! Here a weigthed center of each triangle is shown","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["triangle","tiling","conway","pinwheel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n#define SHOW_DUAL_POINTS 1\n#define SHOW_DUAL 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\n// pointA and pointB are on the same side of the half plane delimited by line (lineA,lineB)\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n} \n\nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nstruct Pinwheel\n{\n    vec2 A; // Right angle, divided into 1 acute and 1 obtuse\n    vec2 B; // Acute angle, stays acute\n    vec2 C; // Obtuse angle, stays obtuse\n    \n    vec2 D; // on GA\n    vec2 E; // on AB\n    vec2 F; // on BC, close to B\n    vec2 G; // on BC, close to C\n};\n   \nvec3 barycentricCoordinate(vec2 P,Pinwheel T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DEFG(T) \\\n\tT.E = (T.A + T.B)/2.0; \\\n\tT.F = (3.0 * T.B + 2.0 * T.C)/5.0; \\\n\tT.G = (T.B + 4.0 * T.C)/5.0; \\\n\tT.D = (T.G + T.A)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.B; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.G; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.G;\n\n#define EQUERRE_GET4(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.A;\n\n#define EQUERRE_GET5(T,Q) \\\n\tT.A = Q.G; \\\n    T.B = Q.A; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND_12_345(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.F,T.E,T.G)\n \n#define EQUERRE_COND_1_2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.E,T.F)\n\n#define EQUERRE_COND_34_5(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.E,T.A,T.G)\n        \n#define EQUERRE_COND_3_4(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.G,T.E,T.D)\n        \n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 1 + int(floor(pow((1.0 - sin(iTime*3.14/17.0))/2.0,0.5)*6.1));\n    \n    vec2 base = vec2(2.0,1.0);\n    \n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    viewportMagnify = 1.25;\n    uv *= viewportMagnify;\n    uv += base/2.25;\n    \n    // Base Triangle\n    Pinwheel Tri;\n    Pinwheel Tri_TMP;\n    Tri.A = Tri.B = Tri.C = vec2(0.0);\n    Tri.B.x += base.x;\n    Tri.C.y += base.y;\n    \n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        EQUERRE_COMPUTE_DEFG(Tri);\n        \n        if( EQUERRE_COND_12_345(uv,Tri) )\n        {\n            if( EQUERRE_COND_1_2(uv,Tri) )\n            {\n            \tEQUERRE_GET1(Tri_TMP,Tri);\n            }\n            else\n            {\n            \tEQUERRE_GET2(Tri_TMP,Tri);\n            }\n        }\n        else if( EQUERRE_COND_34_5(uv,Tri) )\n        {\n            if( EQUERRE_COND_3_4(uv,Tri) )\n            {\n            \tEQUERRE_GET3(Tri_TMP,Tri);\n            }\n            else\n            {\n            \tEQUERRE_GET4(Tri_TMP,Tri);\n            }\n        }\n        else \n        {\n            EQUERRE_GET5(Tri_TMP,Tri);\n        }\n        \n        EQUERRE_COPY(Tri,Tri_TMP);\n    }\n    \n    fragColor.rgb = vec3(1.0);\n    \n    float scale = float(nbIterations);\n    scale = pow(2.0,scale)/viewportMagnify/scale;\n    \n    vec3 EquerreCoeffs = barycentricCoordinate(uv,Tri);\n    vec3 EquerreColor =\n          EquerreCoeffs.x * hash3point(Tri.A)\n        + EquerreCoeffs.y * hash3point(Tri.B)\n        + EquerreCoeffs.z * hash3point(Tri.C)\n    ;\n    \n    vec3 EquerreDualColor = vec3(0.0,0.0,0.0);\n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    scale /= sqrt(float(nbIterations))/3.;\n   \n    #if SHOW_POINTS==1\n    \t#define OPERATION2(x) fragColor.rgb = mix( EquerreColor , fragColor.rgb , 1.0 - coeffDistPoint(uv,x,scale))\n    \n        OPERATION2(Tri.A);\n        OPERATION2(Tri.B);\n        OPERATION2(Tri.C);\n    \n    #endif\n    \n    float k = iTime/1.0*3.14;\n    vec2 mouse = iMouse.z > .5 ?\n          iMouse.xy / iResolution.xy\n        : vec2(1.0/3.0) + 0.15 * vec2(cos(k),sin(k));\n    vec3 coeffs;\n    coeffs.xy = mouse.xy;\n    coeffs.z = 1.0 - mouse.x - mouse.y;\n    if( coeffs.z < 0.0 )\n    {\n        coeffs.x = 2.0;\n        coeffs.y = 1.0;\n        coeffs.z = sqrt(3.0);\n        coeffs /= coeffs.x + coeffs.y + coeffs.z;\n    }\n    \n    #define EQUERRE_CENTER_MIX(T) (T.A * coeffs.x + T.B * coeffs.y + T.C * coeffs.z)\n    vec2 TriCenterMix = EQUERRE_CENTER_MIX(Tri);\n    \n    #if SHOW_DUAL_POINTS==1\n        fragColor.rgb = mix( EquerreDualColor , fragColor.rgb , 1.0 - coeffDistPoint(uv,TriCenterMix,scale));\n    #endif\n           \n    \n    fragColor.rgb = tanh(fragColor.rgb*2.5);\n}","name":"Image","description":"","type":"image"}]}