{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Somewhere in 1993 by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/Md2XDD\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define PALETTE 6.8\n\n//3 to 5 works best\n#define TERRAIN_COMPLEXITY 4.\n#define ITR 100\n#define FAR 700.\n#define time mod(iTime,500.)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat smoothfloor(const in float x, const in float w)\n{\n    return floor(x)+smoothstep(w, 1.-w,fract(x));\n}\n\nvec3 enpos()\n{\n    return vec3(sin(time)*100.+50.,sin(time)*30.+30.,300.+sin(time*.9+sin(time*0.88+0.2))*100.);\n}\n\n//--------------------------------------------------------\n//---------------------------HUD--------------------------\n//--------------------------------------------------------\n\nfloat square(in vec2 p){ return max(abs(p.x),abs(p.y));}\nfloat loz(in vec2 p){ return abs(p.x)+abs(p.y);}\n\n//from Dave (https://www.shadertoy.com/view/4djSRW)\nvec2 hash2(float p)\n{\n\tvec2 p2  = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat crosshair(in vec2 p , in float tk, in float rt)\n{\n    float d = abs(p.x)+abs(p.y);\n    float a = atan(p.y,p.x);\n    float rz = smoothstep(0.03*tk,.04*tk,abs(d-0.5));\n    d = sin(a*3.+1.59-time*3.5-rt);\n    rz += smoothstep(0.0,.07*tk,d);\n    return rz;\n}\n\n//inspired by otaviogood \"runes\" (https://www.shadertoy.com/view/MsXSRn)\nfloat text2(in vec2 p)\n{\n    p = (p+vec2(1.75,-.8))*7.;\n    p.x *= 1.5;\n    float sd = floor(time*8.);\n    vec2 p1 = vec2(0), p2 = hash2(sd);\n    float d= 1.;\n    vec2 fl = vec2(2.,2.);\n    for(float i=0.;i<7.;i++)\n    {\n    \tif(hash2(sd+i+10.).x<0.3)continue;\n        p1 = hash2(i+sd);\n    \tp2 = hash2(i+sd+1.);\n\t\tp1 = (floor(p1*fl) + .5)/fl;\n\t\tp2 = (floor(p2*fl) + .5)/fl;\n        if (p1 == p2) p2 = vec2(.5);\n    \td = min(line(p1, p2, p), d);        \n        p1 = p2;\n    \tp2 = hash2(i+sd+3.);\n\t\tp2 = (floor(p2*fl) + .5)/fl;\n    \td = min(line(p1, p2, p), d);\n        p1 = p2;\n    \tp2 = hash2(i+sd+5.);\n\t\tp2 = (floor(p2*fl) + .5)/fl;\n        if (p1 == p2)\n        {\n            p2 = hash2(i+sd+7.);\n\t\t\tp2 = (floor(p2*fl) + .5)/fl;\n        }\n    \td = min(line(p1,p2,p),d);\n        p.x -= .8;\n    }\n\n    d = smoothstep(0.03, .08,d);\n    return d;\n}\n\nvec3 makeHud(in vec2 p, in float seek)\n{\n    float sk1 = smoothstep(0.99, 1., seek);\n    float sk2 = step(1.-sk1, .5);\n    //lens deformation\n    float ll = abs(p.x)+abs(p.y)*0.25;\n    p *= ll * -.3+1.29;\n    p *= 2.;\n    vec3 col = vec3(0);\n    float d= 1.;\n    //crosshairs\n    float rz = crosshair(p*1.1, .9,1.+sk1);\n    rz = min(rz,crosshair(p*2.7,2., -time*6.5-1.1-sk1));\n    //minimap (top right)\n    float d2 = square(p+vec2(-1.45, -0.67))+0.02;\n    d = smoothstep(0.3,0.31,d2);\n    d = max(d,smoothstep(0.35,.55,min(sin(p.x*80.+1.9),sin(p.y*80.+time*15.))+1.4));\n    d = min(d,smoothstep(0.002,0.009,abs(d2-0.3)));\n    vec3 enp = enpos()/1000.;\n    enp.z = 1.-enp.z;\n    float en = smoothstep(0.025, 0.033, loz(enp.xz+p-vec2(1.47, 1.4))) ;\n    en += mod(floor(time*2.5), 2.);\n    d = min(d,en);\n    rz = min(d,rz);\n    //text (top left)\n    rz= min(rz,text2(p));\n    //altitude bars\n    d = min(rz,sin(p.y*100.+sin(time)*20.)*3.+3.);\n    d2 = max(d,(p.x+0.59)*200.);\n    d2 = max(d2,-(p.x+0.66)*200.);\n    float d3 = max(d,(p.x-0.66)*200.);\n    d3 = max(d3,-(p.x-.59)*200.);\n    d2 = min(d2,d3);\n    d2 += smoothstep(0.59, .6, -p.y);\n    d2 += smoothstep(0.59, .6, p.y);\n    rz = min(rz,d2);    \n    //bottom left \"status\"\n    float num = mod(floor(time*12.),12.);\n    vec2 p2 = p+vec2(-1.32,.94);\n    d = 1.;\n    for(float i=0.;i<5.;i++)\n    {\n        d = min(d,length(p2)+float(num==i));\n    \tp2.x -= 0.1;\n    }\n    d = smoothstep(0.023,.03,d);\n    rz = min(d,rz);\n    \n    vec3 hcol = (sin(vec3(0.35,0.4,0.48)*(3.35)*PALETTE)*0.5+.5);\n    hcol.gb -= sk2;\n    hcol.r += sk2;\n    return hcol*(1.-rz);\n}\n\n//--------------------------------------------------------\n//--------------------------------------------------------\n//--------------------------------------------------------\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-0.5);\n}\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat tnoise(in vec2 p)\n{\n    p*=.008;\n    float z=2.;\n\tfloat rz = 0.;\n\tfor (float i= 1.;i < TERRAIN_COMPLEXITY;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*1.))/z;\n\t\tz = z*2.;\n\t\tp = p*1.8;\n        p*= m2;\n\t}\n\treturn rz*9.;\n}\n\nfloat oct(in vec3 p){ return dot(vec3(0.5773),abs(p));}\nvec2 ou( vec2 d1, vec2 d2 ){return (d1.x<d2.x) ? d1 : d2;}\n\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec2 map(vec3 p)\n{   \n    //terrain\n    vec2 d = vec2(6.*tnoise(p.xz)+p.y+20.+(tri(p.z*0.001)-0.4)*22.,1.);\n    //xlog(x) seems to work nicely for a valley\n    d.x -= abs(p.x*0.5*log(abs(p.x)))*0.05-8.;\n    //flat water\n    d = ou(d,vec2(p.y+30., 2.));\n    //\"enemy\"\n    vec3 enp = enpos();\n    enp.z += time*50.;\n    d = ou(d,vec2((oct(roty(p-enp, time*2.5))-6.)*0.66,8.));\n    \n\treturn d;\n}\n\nvec2 march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = .1;\n    float h=precis*2.0;\n    float d = 0.;\n    float c = 1.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    vec2 res = map(ro+rd*d);\n        h = res.x*1.4;\n        c = res.y;\n    }\n\treturn vec2(d,c);\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*.1;\n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\n//(from eiffie, who thought it was from iq, dont know who actually wrote it)\nfloat segm(vec3 ro, vec3 rd, vec3 p1, vec3 p2)\n{\n\tvec3 p = p1-ro;\n\tvec3 di = p2-ro-p;\n\tfloat proj = dot(rd, di);\n\tfloat m = clamp((dot(rd,p)*proj-dot(p,di))/(dot(di,di)-proj*proj), 0., 1.);\n\tp += di*m;\n\tp = dot(p, rd)*rd-p;\n    return smoothstep(0.9985,.999,1.-dot(p,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 bp = p+0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = vec2(0);\n    um.x = 0.5+(smoothstep(-2.,2.,sin(time*.7-0.1))-0.5)*.1;\n    um.y = sin(time+1.)*0.02;\n\t\n    //camera\n    vec3 ro = vec3((smoothstep(-2., 2., sin(time*0.7+1.57))-0.5)*50., sin(time)*5.-1., time*50.);\n    um.x *= 3.;\n    vec3 eye = normalize(vec3(cos(um.x),um.y*5.,sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+1.5708),0.,sin(um.x+1.5708)));\n    mat2 ori = mm2( smoothstep(-.5,.5,sin(time*0.7+0.78))-.5 + smoothfloor(time*0.04,.45)*6.28 );\n    right.xy *= ori;\n    vec3 up = normalize(cross(right,eye));\n\tvec3 rd=normalize((p.x*right+p.y*up)*.75+eye);\n\t\n    vec3 bg = sin(vec3(0.35,0.4,0.48)*11.3*PALETTE)*0.5+.5;\n    vec3 col = bg*floor(-rd.y*50.+6.)*0.06;\n    \n    //march\n\tvec2 rz = march(ro,rd);\n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro+rz.x*rd;\n        vec3 nor = normal( pos );\n        vec3 ligt = normalize(vec3(-.7,0.2, 0.1));\n        float dif = clamp(dot(nor, ligt), 0., 1.);\n        float fre = pow(clamp(1. + dot(nor, rd), 0., 1.), 2.);\n        if (rz.y == 1.)\n        {\n            float mx = abs(pos.x*.1)-10.;\n            mx = smoothstep(-20.,10.,mx);\n            col = mix(vec3(0.,0.37,0),vec3(0.2,.17,0.15),mx);\n        }\n        else\n            col = sin(vec3(0.35,0.4,0.48)*rz.y*PALETTE)*0.5+.55;\n        col = col*dif + col*0.4 + .3*fre*col;\n    }\n    \n    //lasers\n    vec3 enp =enpos();\n    enp.z += time*50.;\n    vec3 rn = enp - ro;\n    float tgt = dot(eye, normalize(rn));\n    if (tgt > .997)\n    {\n        vec3 ray1 = vec3(0.7, 1., -1);\n        vec3 ray2 = vec3(-0.7, 1., -1);\n        ray1.xy *= ori; ray2.xy *= ori;\n        float lz = segm(ro,rd,ro-ray1,up*0.5+ro+(eye-ray1*0.01)*30.);\n        lz += segm(ro,rd,ro-ray2,up*.5+ro+(eye-ray2*0.01)*30.);\n        float sw = mod(floor(time*20.),2.);\n        lz *= sw;\n        col = col*(1.-smoothstep(0.0,1.,lz))+lz*vec3(1.,0.,0.);\n        //hit (cant really have explosions since I don't have a function for hit times)\n        if (tgt > .999)\n        {\n            vec2 d = hash2(time);\n            rd.xy += d*0.03;\n            rn.xy += d*10.;\n            float s = sw*smoothstep(0.9998, .9999,dot(rd,normalize(rn)));\n            col = col*(1.-smoothstep(0., 1., s))+s*vec3(1.-d.x, .0, 0.1);\n        }\n    }\n    \n    //hud\n    float lk = 0.;\n    if (tgt > .99)lk = 4.;\n    vec3 hud = makeHud(p,tgt);\n    col = col*(1.-smoothstep(0., 1., hud.y+hud.x+hud.z))+hud;   \n    //scanlines\n    col *= (sin(p.y*1.3*iResolution.x)*0.15)*(sin(p.y*10.+time*410.)*0.4)+1.;\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md2XDD","date":"1412910246","viewed":3491,"name":"Somewhere in 1993","username":"nimitz","description":"Experiments in making low poly terrain.","likes":95,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","terrain","lowpoly","mockup","hud"],"hasliked":0,"parentid":"","parentname":""}}