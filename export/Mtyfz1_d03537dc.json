{"ver":"0.1","info":{"id":"Mtyfz1","date":"1542238776","viewed":96,"name":"Taft Architecture- Lincoln Lobby","username":"rlarp","description":"Representation of Lincoln Lobby in the Taft School in Watertown CT. ","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["education","school","school","architecture","hall","lobby","taft","taftschool","boardingschool","boarding","lincoln","abraham","lincolnlobby"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Shape{\n  float dist;\n  vec4 color;\n};\n\nconst float EPSILON = 0.001;\nconst vec3 deltax = vec3(EPSILON, 0., 0.);\nconst vec3 deltay = vec3(0., EPSILON, 0.);\nconst vec3 deltaz = vec3(0., 0., EPSILON);    \n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0.))) + vmax(min(d, vec3(0.)));\n}\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.* s)) - s)));\n}\n\n//=======================\n\nShape LincolnLobby(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  // Main \n  vec3 w = c; // Wall\n  vec3 p = c; // Placeholder\n  vec3 aR = c; // Arch Bottom (Rect)\n  vec3 aS = c; // Arch Top (Sphere)\n  vec3 aD = c; // Arch Design\n  vec3 aD2 = c; // Arch Design 2\n  vec3 aD3 = c; // Arch Design 3 \n  vec3 s1 = c; // Stairs Level 1\n  vec3 s2 = c; // Stairs Level 2\n  vec3 s3 = c; // Stairs Level 3\n  vec3 sS = c; // Lincoln Statue Stand\n  vec3 sL = c; // Statue Level (Adds some Dimension)\n  vec3 sL2 = c; // Level 2\n  vec3 sSign = c; // Statue Sign\n  vec3 lB = c; // Lincoln Body\n  vec3 lN = c; // Lincoln Neck \n  vec3 lH = c; // Lincoln Head \n  vec3 lNo = c; // Lincoln Statue's Iconic Gold Nose \n  vec3 lE = c; // Lincoln's Eyes \n  vec3 lM = c; // Lincoln's Mouth \n  vec3 lbowM = c; // Bow Tie Middle\n  vec3 bow = c; // Bow Tie\n  vec3 bow2 = c; // Bow Tie\n    \n  // Right Back\n  vec3 sB1 = c; // Stairs Back Level 1 (Right) \n  vec3 sB2 = c; // Stairs Back Level 2\n  vec3 sB3 = c; // Stairs Back Level 3 \n  vec3 sB4 = c; // Stairs Back Level 4\n  vec3 sB5 = c; // Stairs Back Level 5\n  vec3 bW = c; // Back Wall (Right)\n  vec3 bFR = c; // Back Floor (Right)\n  vec3 clF = c; // Clock Frame\n  vec3 clM = c; // Clock Middle\n  vec3 clH1 = c; // Clock Hand 1\n  vec3 clH2 = c; // Clock Hand 2\n  vec3 bS = c; // Back Sign\n  vec3 brW = c; // Back Right Wall\n  vec3 sR = c; // Stair Rails \n  vec3 hR = c; // Hand Rails\n  vec3 rB = c; // Back Rail\n  vec3 srbe = c; // Stair Rail Back (Extension) \n    \n  // Left Back\n  vec3 bFL = c; // Back Floor (Left)\n  vec3 d = c; // Door \n  vec3 blW = c; // Back Left Wall\n  vec3 dO = c; // Outline of the Door \n  vec3 dkC = c; // Door Knob (Circle)\n  vec3 dkR = c; // Door Knob (Rect) \n  vec3 sL1 = c; // Stair 1 \n  vec3 sLe2 = c; // Stair 2\n  vec3 sL3 = c; // Stair 3 \n  vec3 sL4 = c; // Stair 4 \n  vec3 sL5 = c; // Stair 5 \n  vec3 win = c; // Windows in the Back\n  vec3 blwD = c; // Back Wall (Deep)\n  vec3 win2 = c; // Window\n  vec3 hea = c; // Heater\n  vec3 hea2 = c; // Heater 2 \n  vec3 hl1 = c; // Heater Line\n  vec3 hl2 = c; // Heater Line\n  vec3 hl3 = c; // Heater Line\n  vec3 hl4 = c; // Heater Line\n  vec3 pan = c; // Pane \n      \n  // Patterns\n  vec3 p1 = c; // \n  vec3 p2 = c; //\n  vec3 p3 = c; //\n  vec3 p4 = c; //\n  vec3 ph1 = c; //\n  vec3 ph2 = c; //\n  vec3 ph3 = c; //\n  vec3 ph4 = c; //\n  vec3 ph5 = c; //\n  vec3 ph6 = c; //\n  vec3 ph7 = c; //\n  vec3 ph8 = c; //\n   \n  // Wall \n  vec4 wColor = vec4(1.,1., 1., 0.); \n  float wall = fBox(w+vec3(0.,0.,0.), vec3(10., 3., 0.0));\n    \n  // Placeholder  \n  vec4 pColor = vec4(1., 1., 1., 0.); \n  float placeholder = fBox(p+vec3(15,0.5,0.), vec3(0.5,0.5,0.5)); \n    \n  // Arch Rectangle\n  aR.x = abs(aR.x) - 5.;\n  float archBottom = fBox(aR+vec3(2.5, 0.08, -0.3), vec3(1.75, 1.0, 0.5));\n    \n  // Arch Sphere\n  aS.x = abs(aS.x) - 2.59; \n  float archTop = fSphere(aS+vec3(0.1,-0.65,0.), 1.75);\n    \n  // Arch Design\n  vec4 adColor1 = vec4(1.,0.99,0.82,1.0); \n  vec4 adColor2 = vec4(1.,0.99,0.82,1.0); \n  vec4 adColor3 = vec4(1.,0.99,0.82,1.0);\n  float archDesign = fBox(aD+vec3(0.5,-0.20,-0.4), vec3(0.2, 1.25, 0.5)); \n  float archDesign2 = fBox(aD2+vec3(-0.5,-0.20,-0.4), vec3(0.2, 1.25, 0.5)); \n  float archDesign3 = fBox(aD3+vec3(0., -0.2, -0.4), vec3(0.5, 1., 0.5)); \n    \n  // Stairs Level 1 \n  vec4 s1Color = vec4(0., 0., 0.05, 0.); \n  s1.x = abs(s1.x) - 2.8;\n  float stair1 = fBox(s1+vec3(0.15, 1.20, 0.5), vec3(2., 0.4, 0.)); \n    \n  // Stairs Level 2\n  vec4 s2Color = vec4(0., 0., 0.05, 0.); \n  s2.x = abs(s2.x) - 2.8;\n  float stair2 = fBox(s2+vec3(0.25, 1.475, 1.25), vec3(2., 0.4, 0.)); \n    \n  // Stair Level 3\n  vec4 s3Color = vec4(0., 0., 0.05, 0.); \n  float stair3 = fBox(s3+vec3(0.2, 1.40, 2.), vec3(4., 0.2, 0.)); \n    \n  // Lincoln Statue Stand Main\n  vec4 ssColor = vec4(0.40,0.26,0.13,0.); \n  float statueStand = fBox(sS+vec3(0.,0.8,1.25), vec3(0.3, 0.7, 0.1)); \n    \n  // Lincoln Statue (Levels)\n  vec4 slColor = vec4(0.40,0.26,0.13,0.); \n  float statueLevels = fBox(sL+vec3(0., 0.,1.45), vec3(0.35, 0.1, 0.1)); \n // statueLevels = fOpUnionStairs(statueLevels, statueStand, 1., 1.); \n    \n  // Level 2 \n  vec4 sl2Color = vec4(0.40,0.26,0.13,0.); \n  float statueLevel2 = fBox(sL2+vec3(0., 1.32,1.45), vec3(0.35, 0.1, 0.1)); \n  statueLevel2 = fOpUnionStairs(stair3, statueLevel2, 1., 1.); \n    \n  // Lincoln Statue Sign \n  vec4 lssColor = vec4(0.,0.,0.,0.);\n  float statueSign = fBox(sSign+vec3(0., 0.32,1.45), vec3(0.15, 0.075, 0.01)); \n    \n  // Lincoln Body\n  vec4 lbColor = vec4(0.,0.,0.,0.);\n  float lincolnBody = fBox(lB+vec3(0., -.3, 1.45), vec3(0.25, 0.2, 0.02)); \n    \n  // Lincoln Neck\n  vec4 lneColor = vec4(0.,0.,0.,0.);\n  float lincolnNeck = fBox(lN+vec3(0., -.58, 1.45), vec3(0.1, 0.1, 0.02));\n    \n  // Lincoln Head \n  vec4 lhColor = vec4(0.6,0.7,0.7,0.); \n  float lincolnHead = fSphere(lH+vec3(0., -.775, 1.45), 0.2); \n    \n  // Lincoln Iconic Gold Nose\n  vec4 lnColor = vec4(1., 1. ,.01, 0.); \n  float lincolnNose = fCone(lNo+vec3(0.,-0.655,1.65), 0.06, 0.1);\n    \n  // Lincoln's Eyes\n  lE.x = abs(lE.x) - 0.17; \n  float lincolnEye = fSphere(lE+vec3(0.08,-0.785, 1.65), 0.04); \n    \n  // Lincoln's Mouth \n  float lincolnMouth = fBox(lM+vec3(0.,-0.55,1.5), vec3(0.07, 0.001, 0.5));\n    \n  // Lincoln's Bow Tie\n  vec4 bowTColor = vec4(0.,0.,0.,0.); \n  vec4 bowT2Color = vec4(0.,0.,0.,0.);\n  vec4 bowMColor = vec4(1., 1., .6, 0.); \n  float bowMiddle = fSphere(lbowM+vec3(0.0,-0.45,1.5), 0.06); \n  bow.xy *= rot(radians(90.)); \n  float bowT = sdTriPrism(bow+vec3(-0.45,0.12,1.45), vec2(0.075, 0.1)); \n  bow2.xy *= rot(radians(-90.)); \n  float bowT2 = sdTriPrism(bow2+vec3(0.45,0.12,1.45), vec2(0.075,0.1)); \n    \n  // Clock\n  vec4 cfColor = vec4(1.,1.,1.,0.); \n  vec4 cmColor = vec4(0.,0.,0.1,0.); \n  vec4 ch1Color = vec4(0.,0.0,0.0,0.); \n  vec4 ch2Color = vec4(0.,0.,0.,0.); \n  float clockFrame = fSphere(clF+vec3(-4.,-2.5,-5.6), 0.5); \n  float clockMiddle = fSphere(clM+vec3(-3.8,-2.375,-5.), 0.1); \n  clH1.yx *= rot(radians(-45.));\n  float clockHand1 = fBox(clH1+vec3(-4.2, 1.0, -5.), vec3(0.25, 0.02, 0.01)); \n  clH2.yx *= rot(radians(-80.)); \n  float clockHand2 = fBox(clH2+vec3(-3.2, 3.35, -5.), vec3(0.25, 0.02, 0.02)); \n    \n  // Back Wall Sign\n  vec4 backsignColor = vec4(1.,0.99,0.70,1.0); \n  float backSign = fBox(bS+vec3(-2.2,-1.2,-5.0), vec3(1.5, 0.4, 0.0)); \n    \n  // Back Wall \n  float backWall = fBox(bW+vec3(-4.5,-3.9,-6.), vec3(4.5, 4.5, 0.5)); \n    \n  // Back Floor (Right)\n  vec4 bFRColor = vec4(0., 0., 0.1,0.);\n  bFR.yz *= rot(radians(67.));\n  float backFloorR = fBox(bFR+vec3(-3.0,-0.5,-1.), vec3(2.5,1.,0.)); \n    \n  // Back Floor (Left)\n  vec4 bFLColor = vec4(0., 0., 0.1, 0.); \n  bFL.yz *= rot(radians(67.));\n  float backFloorL = fBox(bFL+vec3(4.,-0.5,-1.), vec3(3.5,1.,0.)); \n    \n  // Back Stairs (Right)\n  vec4 sb5Color = vec4(0., 0., 0.05, 0.);\n  float stairsBack1 = fBox(sB1+vec3(-5.5,0.3,-4.), vec3(0.2, 0.3, 1.)); \n  float stairsBack2 = fBox(sB2+vec3(-5.8,0.3,-4.), vec3(0.2, 0.7, 1.)); \n  float stairsBack3 = fBox(sB3+vec3(-6.1,0.3,-4.), vec3(0.2, 1.1, 1.));\n  float stairsBack4 = fBox(sB4+vec3(-6.4,0.3,-4.), vec3(0.2, 1.5, 1.)); \n  float stairsBack5 = fBox(sB5+vec3(-6.7,0.3,-4.), vec3(0.2, 1.9, 1.)); \n    \n  // Stair Railings (Right)\n  vec4 srColor = vec4(0.,0.,0.2,0.);\n  vec4 hrColor = vec4(0.,0.,0.2,0.);\n  vec4 srbColor = vec4(0.,0.,0.2,0.); \n  vec4 srbeColor = vec4(0.,0.,0.2,0.); \n  float stairRails = fBox(sR+vec3(-5.35,0.,-3.), vec3(0.05, 0.5, 0.1)); \n  hR.xy *= rot(radians(45.));\n  float handRail = fBox(hR+vec3(-4.6, 3.45, -3.), vec3(0.5, 0.05, 0.1));\n  rB.xy *= rot(radians(45.)); \n  float railBack = fBox(rB+vec3(-6.5,3.2,-5.5), vec3(2., 0.05, 0.1)); \n  float railbackExtension = fBox(srbe+vec3(-5.47,-0.77,0.-5.5), vec3(0.05, 0.18, 0.1)); \n   \n  // Back Left Wall\n  float backLeftWall = fBox(blW+vec3(4.75,0.7,-0.5), vec3(0.5,5.,1.275)); \n    \n  // Back Right Wall\n  float backRightWall = fBox(brW+vec3(-4.75, 0.7, -0.5), vec3(0.5, 5., .5)); \n    \n  // Door\n  vec4 doorColor = vec4(0.2, 0.,0.,0.); \n  vec4 knobColor = vec4(1.,1.,1.,0.);\n  vec4 knobrectColor = vec4(1.,1.,1.,0.); \n  float door = fBox(d+vec3(4.4,-0.3,-0.99), vec3(0.2, 1.35, .5)); \n  float doorOutline = fBox(dO+vec3(4.3, -0.3, -1.), vec3(0.2, 1.35, .5)); \n  float doorKnobCircle = fSphere(dkC+vec3(4.35, -0.2, -.9), 0.075); \n  float doorKnobRect = fBox(dkR+vec3(4.4, -0.2, -0.9), vec3(0.04,0.03,0.05));\n    \n  // Back Stairs Left\n  vec4 sl1Color = vec4(0., 0., 0.05, 0.);\n  vec4 sle2Color = vec4(0., 0., 0.05, 0.);\n  vec4 sl3Color = vec4(0., 0., 0.05, 0.);\n  vec4 sl4Color = vec4(0., 0., 0.05, 0.);\n  vec4 sl5Color= vec4(0.,0.,0.05, 0.); \n  float stairsLeft1 = fBox(sL1+vec3(2.2,0.25,-2.2), vec3(2., 0.1, 0.5)); \n  float stairsLeft2 = fBox(sLe2+vec3(2.2,0.05,-2.4), vec3(2.2, 0.2, 0.5)); \n  float stairsLeft3 = fBox(sL3+vec3(2.2,-0.15,-2.6), vec3(2.4, 0.3, 0.5)); \n  float stairsLeft4 = fBox(sL4+vec3(2.2,-0.35,-2.8), vec3(2.6, 0.4, 0.5));\n  float stairsLeft5 = fBox(sL5+vec3(2.2,-0.55,-3.1), vec3(2.8, 0.5, 0.5)); \n    \n  // Back Left Wall Deep\n  float backWallDeep = fBox(blwD+vec3(5.5, -2., -3.5), vec3(0.5, 5.5, 5.5)); \n   \n  // Back Left Windows\n  float window = fBox(win+vec3(4.8,-2., -4.5), vec3(0.5,5.5,1.)); \n  float window2 = fBox(win2+vec3(4.8,-2., -7.5), vec3(0.5,5.5,1.)); \n  float pane = fBox(pan+vec3(5.,-5.5,-4.5), vec3(0.5, 3., 0.5)); \n    \n  // Heaters \n  float heater = fBox(hea+vec3(5.25, -2., -4.5), vec3(0.1, 0.5, 0.5)); \n  float heater2 = fBox(hea2+vec3(5.25, -2.5, -8.5), vec3(0.1, 0.5, 0.5)); \n  float heaterLine = fBox(hl1+vec3(5.2,-2.3,-4.5), vec3(0.06, 0.03, 0.5)); \n  float heaterLine2 = fBox(hl2+vec3(5.2,-2.1,-4.5), vec3(0.06, 0.03, 0.5)); \n  float heaterLine3 = fBox(hl3+vec3(5.2,-1.9,-4.5), vec3(0.06, 0.03, 0.5)); \n  float heaterLine4 = fBox(hl4+vec3(5.2,-1.7,-4.5), vec3(0.06, 0.03, 0.5));\n    \n  // Patterns\n  float pattern1 = fBox(p1+vec3(2., 0.60, -1.), vec3(7., 0.2, 0.01));\n  float pattern2 = fBox(p2+vec3(2., 0.82, -0.7), vec3(7., 0.05, 0.01));\n  float pattern3 = fBox(p3+vec3(2., 0.94, -0.4), vec3(7., 0.05, 0.01));\n  float pattern4 = fBox(p4+vec3(2., 0.58, -1.3), vec3(7., 0.05, 0.01));\n  ph1.x = abs(ph1.x) -5.; \n  ph2.x = abs(ph2.x) -5.; \n  ph3.x = abs(ph3.x) -5.; \n  ph4.x = abs(ph4.x) -5.; \n  ph5.x = abs(ph5.x) -5.; \n  ph6.x = abs(ph6.x) -5.; \n  ph7.x = abs(ph7.x) -5.; \n  ph8.x = abs(ph8.x) -5.; \n  ph1.yz *= rot(radians(-20.)); \n  ph2.yz *= rot(radians(-20.));\n  ph3.yz *= rot(radians(-20.));\n  ph4.yz *= rot(radians(-20.));\n  ph5.yz *= rot(radians(-20.));\n  ph6.yz *= rot(radians(-20.));\n  ph7.yz *= rot(radians(-20.));\n  ph8.yz *= rot(radians(-20.));\n  float hozPattern1 = fBox(ph1+vec3(2.0,1.,-0.5), vec3(0.01,0.08,1.)); \n  float hozPattern2 = fBox(ph2+vec3(2.35,1.,-0.5), vec3(0.01,0.08,1.)); \n  float hozPattern3 = fBox(ph3+vec3(2.7,1.,-0.5), vec3(0.01,0.08,1.)); \n  float hozPattern4 = fBox(ph4+vec3(3.05,1.,-0.5), vec3(0.01,0.08,1.)); \n  float hozPattern5 = fBox(ph5+vec3(3.4,1.,-0.5), vec3(0.01,0.08,1.)); \n  float hozPattern6 = fBox(ph6+vec3(3.75,1.,-0.5), vec3(0.01,0.08,1.)); \n  float hozPattern7 = fBox(ph7+vec3(1.65,1.,-0.5), vec3(0.01,0.08,1.)); \n  float hozPattern8 = fBox(ph8+vec3(1.3,1.,-0.5), vec3(0.01,0.08,1.)); \n    \n  // Add all the Shapes --------------------\n  shape.dist = max(wall, -placeholder); \n  shape.dist = max(shape.dist, -archBottom); \n  shape.dist = max(shape.dist, -archTop);\n  shape.dist = min(shape.dist, archDesign); \n  shape.dist = min(shape.dist, archDesign2); \n  shape.dist = min(shape.dist, archDesign3);\n  shape.dist = min(shape.dist, stair1);\n  shape.dist = min(shape.dist, stair2); \n  shape.dist = min(shape.dist, stair3); \n  shape.dist = min(shape.dist, statueStand); \n  shape.dist = min(shape.dist, statueLevels); \n  shape.dist = min(shape.dist, statueLevel2); \n  shape.dist = min(shape.dist, statueSign); \n  shape.dist = min(shape.dist, lincolnBody); \n  shape.dist = min(shape.dist, lincolnNeck); \n  shape.dist = min(shape.dist, lincolnHead); \n  shape.dist = min(shape.dist, lincolnNose);\n  shape.dist = min(shape.dist, lincolnEye);\n  shape.dist = min(shape.dist, bowMiddle);\n  shape.dist = min(shape.dist, bowT);\n  shape.dist = min(shape.dist, bowT2); \n  shape.dist = min(shape.dist, backWall); \n  shape.dist = min(shape.dist, backFloorR); \n  shape.dist = min(shape.dist, backFloorL); \n  shape.dist = min(shape.dist, clockFrame);\n  shape.dist = min(shape.dist, clockMiddle);\n  shape.dist = min(shape.dist, clockHand1); \n  shape.dist = min(shape.dist, clockHand2); \n  shape.dist = min(shape.dist, stairsBack1); \n  shape.dist = min(shape.dist, stairsBack2); \n  shape.dist = min(shape.dist, stairsBack3);\n  shape.dist = min(shape.dist, stairsBack4); \n  shape.dist = min(shape.dist, stairsBack5); \n  shape.dist = min(shape.dist, backSign); \n  shape.dist = min(shape.dist, backLeftWall);\n  shape.dist = min(shape.dist, backRightWall);\n  shape.dist = min(shape.dist, door);\n  shape.dist = max(shape.dist, -doorOutline); \n  shape.dist = min(shape.dist, doorKnobCircle); \n  shape.dist = min(shape.dist, doorKnobRect); \n  shape.dist = min(shape.dist, stairsLeft1); \n  shape.dist = min(shape.dist, stairsLeft2); \n  shape.dist = min(shape.dist, stairsLeft3); \n  shape.dist = min(shape.dist, stairsLeft4); \n  shape.dist = min(shape.dist, stairsLeft5); \n  shape.dist = min(shape.dist, stairRails); \n  shape.dist = min(shape.dist, railBack);\n  shape.dist = min(shape.dist, handRail); \n  shape.dist = min(shape.dist, railbackExtension); \n  shape.dist = min(shape.dist, backWallDeep);\n  shape.dist = max(shape.dist, -window); \n  shape.dist = max(shape.dist, -window2); \n  shape.dist = max(shape.dist, -pane); \n  shape.dist = min(shape.dist, heater);\n  shape.dist = min(shape.dist, heater2);  \n  shape.dist = max(shape.dist, -heaterLine);\n  shape.dist = max(shape.dist, -heaterLine2);\n  shape.dist = max(shape.dist, -heaterLine3);\n  shape.dist = max(shape.dist, -heaterLine4);\n  shape.dist = max(shape.dist, -pattern1);\n  shape.dist = max(shape.dist, -pattern2);\n  shape.dist = max(shape.dist, -pattern3);\n  shape.dist = max(shape.dist, -pattern4);\n  shape.dist = max(shape.dist, -hozPattern1); \n  shape.dist = max(shape.dist, -hozPattern2); \n  shape.dist = max(shape.dist, -hozPattern3); \n  shape.dist = max(shape.dist, -hozPattern4); \n  shape.dist = max(shape.dist, -hozPattern5); \n  shape.dist = max(shape.dist, -hozPattern6); \n  shape.dist = max(shape.dist, -hozPattern7); \n  shape.dist = max(shape.dist, -hozPattern8); \n  \n  \n  \n  // ---------------------------------------\n   \n  // Add Colors ----------------------------\n  shape.color = mix(wColor, pColor, mixColors(placeholder, wall, 0.1)); \n  shape.color = mix(shape.color, adColor1, mixColors(archDesign, shape.dist, 0.1)); \n  shape.color = mix(shape.color, adColor2, mixColors(archDesign2, shape.dist, 0.1)); \n  shape.color = mix(shape.color, adColor3, mixColors(archDesign3, shape.dist, 0.1)); \n  shape.color = mix(shape.color, s1Color, mixColors(stair1, shape.dist, 0.1)); \n  shape.color = mix(shape.color, s2Color, mixColors(stair2, shape.dist, 0.1)); \n  shape.color = mix(shape.color, s3Color, mixColors(stair3, shape.dist, 0.1)); \n  shape.color = mix(shape.color, ssColor, mixColors(statueStand, shape.dist, 0.1)); \n  shape.color = mix(shape.color, slColor, mixColors(statueLevels, shape.dist, 0.1)); \n  shape.color = mix(shape.color, sl2Color, mixColors(statueLevel2, shape.dist, 0.01)); \n  shape.color = mix(shape.color, bFRColor, mixColors(backFloorR, shape.dist, 0.1)); \n  shape.color = mix(shape.color, bFLColor, mixColors(backFloorL, shape.dist, 0.1)); \n  shape.color = mix(shape.color, lnColor, mixColors(lincolnNose, shape.dist, 0.1)); \n  shape.color = mix(shape.color, lssColor, mixColors(statueSign, shape.dist, 0.1)); \n  shape.color = mix(shape.color, lbColor, mixColors(lincolnBody, shape.dist, 0.1)); \n  shape.color = mix(shape.color, lneColor, mixColors(lincolnNeck, shape.dist, 0.1)); \n  shape.color = mix(shape.color, lhColor, mixColors(lincolnHead, shape.dist, 0.1));\n  shape.color = mix(shape.color, sl1Color, mixColors(stairsLeft1, shape.dist, 0.1)); \n  shape.color = mix(shape.color, sle2Color, mixColors(stairsLeft2, shape.dist, 0.1)); \n  shape.color = mix(shape.color, sl3Color, mixColors(stairsLeft3, shape.dist, 0.1)); \n  shape.color = mix(shape.color, sl4Color, mixColors(stairsLeft4, shape.dist, 0.1)); \n  shape.color = mix(shape.color, sl5Color, mixColors(stairsLeft5, shape.dist, 0.1)); \n  shape.color = mix(shape.color, cfColor, mixColors(clockFrame, shape.dist, 0.1)); \n  shape.color = mix(shape.color, cmColor, mixColors(clockMiddle, shape.dist, 0.1)); \n  shape.color = mix(shape.color, ch1Color, mixColors(clockHand1, shape.dist, 0.1)); \n  shape.color = mix(shape.color, ch2Color, mixColors(clockHand2, shape.dist, 0.1));  \n  shape.color = mix(shape.color, srColor, mixColors(stairRails, shape.dist, 0.1)); \n  shape.color = mix(shape.color, hrColor, mixColors(handRail, shape.dist, 0.1)); \n  shape.color = mix(shape.color, srbColor, mixColors(railBack, shape.dist, 0.1)); \n  shape.color = mix(shape.color, srbeColor, mixColors(railbackExtension, shape.dist, 0.1)); \n  shape.color = mix(shape.color, doorColor, mixColors(door, shape.dist, 0.1)); \n  shape.color = mix(shape.color, knobColor, mixColors(doorKnobCircle, shape.dist, 0.1)); \n  shape.color = mix(shape.color, knobrectColor, mixColors(doorKnobRect, shape.dist, 0.1)); \n  shape.color = mix(shape.color, backsignColor, mixColors(backSign, shape.dist, 0.1)); \n  shape.color = mix(shape.color, bowTColor, mixColors(bowT, shape.dist, 0.1)); \n  shape.color = mix(shape.color, bowT2Color, mixColors(bowT2, shape.dist, 0.1)); \n  shape.color = mix(shape.color, bowMColor, mixColors(bowMiddle, shape.dist, 0.1));\n  // ---------------------------------------\n  return shape; \n}\n\nShape map(vec3 c){\n  Shape lobby = LincolnLobby(c);\n  return lobby;\n}\n\nfloat mapDist(vec3 c){\n  Shape lobby = LincolnLobby(c);\n  return lobby.dist;\n}\n\nvec4 mapColor(vec3 c){\n  Shape lobby = LincolnLobby(c);\n  return lobby.color;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n  float farPlane = 10000.;\n    for (int i = 0; i < 644; ++i) {\n        float dist = mapDist(origin + r * t);\n        if(dist < EPSILON || t > farPlane) {\n          break;\n      }\n        t += dist;\n    }\n    return t;\n}\n\n// Calculates Normal Values (Finds nearest surfaces x,y,z) \nvec3 computeSurfaceNormal(vec3 p){\n    float d = mapDist(p);\n    return normalize(vec3(\n            mapDist(vec3(p.x + EPSILON, p.y, p.z)) - d ,\n            mapDist(vec3(p.x, p.y + EPSILON, p.z)) - d ,\n            mapDist(vec3(p.x, p.y, p.z + EPSILON)) - d\n            ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l) {\n\n    return vec3(dot(normalize(l-p), n));\n}\n\n// The Ambient Occlusion Factor given a point (p) and the normal of the surface at p (n). \nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n  float stepSize = 0.00001;\n  float t = stepSize;\n  float oc = 0.0;\n  for(int i = 0; i < 1000; ++i)\n  {\n    float d = mapDist(p + n * t);\n    oc += t - d; \n    t += stepSize;\n  }\n\n  return clamp(oc, 1., 2.);\n}\n\nvec3 computeColor(vec3 origin, vec3 ray){\n  \n  float t = trace(origin, ray); \n  vec3 p = origin + ray * t; \n  float d = mapDist(p); \n  vec3 normal = computeSurfaceNormal(p);\n    \n  vec3 light = vec3(0., 30.5, -15.);\n  vec3 light2 = vec3(-3., 30.5, 0.);\n  vec3 mat = computeLambert(p, normal, light);\n  vec3 mat_2 = computeLambert(p, normal, light2);\n  float ao = ambientOcclusion(p, normal);\n  mat = mat * (3. - ao);\n  mat_2 = mat_2*(2. - ao);\n  return mat + mat_2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n  vec3 cam = vec3(0., 0., -5.);\n  vec3 f = normalize(vec3(v, 1.));\n    \n  vec3 scene = cam;\n  fragColor = vec4(0.);\n  Shape c = map(scene); // Calc SDF\n  vec3 fc = computeColor(cam, f);\n  fc *= vec3(mapColor(fc));\n    \n  // Display\n  fragColor = c.color*vec4(vec3(fc), 1.);\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n  }\n}\n","name":"Image","description":"","type":"image"}]}