{"ver":"0.1","info":{"id":"ddyfDR","date":"1698110877","viewed":61,"name":"hyperbolicTiling(twoTone colors)","username":"darkfox","description":"hyperbolic tiling.\nsee also this: https://openprocessing.org/sketch/1499154","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tiling","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 32\n#define UPPER_HALF 0\n#define POINCARE 1\n#define PI 3.14159\n#define MULTIPLY 0\n#define SCREEN 1\n#define BLACK 0\n#define WHITE 1\n\n// 反転操作\nvec2 inversion(in vec2 q, in float r, in float c){\n  float factor = pow(r, 2.0) / (pow(q.x - c, 2.0) + pow(q.y, 2.0));\n  return vec2(c, 0.0) + (vec2(q.x - c, q.y) * factor);\n}\n\n// 複素変換\nvec2 sltf(in vec2 z, in float a, in float b, in float c, in float d){\n  vec2 w = vec2((a * d + b * c) * z.x + (a * c) * (z.x * z.x + z.y * z.y) + b * d, z.y);\n  return w / (pow(c * z.x + d, 2.0) + pow(c * z.y, 2.0));\n}\n\n// ポアンカレ平面→上半平面\nvec2 poincare_to_half(in vec2 p){\n  return vec2(-2.0 * p.y, (1.0 - pow(p.x, 2.0) - pow(p.y, 2.0))) / (pow(p.x - 1.0, 2.0) + pow(p.y, 2.0));\n}\n\n// 三角形の各辺との距離の計算（多分上半平面でやってる）\nfloat calc_dist(in float x, in float y, in float c, in float r){\n  vec3 temp = vec3(pow(x - c, 2.0), pow(y, 2.0), pow(r, 2.0));\n  float g = sqrt(pow(temp[0] - temp[1] - temp[2], 2.0) + 4.0 * temp[0] * temp[1]) - abs(temp[0] + temp[1] - temp[2]);\n  return log(2.0 * r * y / g);\n}\n\n// 内容がmagSqなのでmagSqに改名\nfloat magSq(in vec2 p){ return p.x * p.x + p.y * p.y; }\n\n// reflectionのiteration.\nvec4 iteration(in vec2 p, in float time, in vec2 center, in vec2 radius, in vec3 distWithEdge, in int mode){\n  // 10秒周期\n  float properTime = min(fract(time * 0.1), 1.0 - fract(time * 0.1)) * 2.0;\n  // diffは5秒で0～PI, 5秒でPI～0, を繰り返す。\n  float diff = PI * properTime;\n  float r = 0.5 + properTime * properTime * 300.0;\n  float a = center.x * r;\n  float b = center.y * r;\n  float s = radius.x * r;\n  float t = radius.y * r;\n  float count = 0.0;\n  bool arrived = false;\n  float norm = magSq(p);\n  if(mode == UPPER_HALF){\n    p = p + vec2(0.0, 1.0);\n  }\n  if(mode == POINCARE){\n    if(norm > 0.999){ return vec4(-1.0, -1.0, 0.0, 0.0); }\n    p = poincare_to_half(p);\n  }\n\n  p = sltf(p, cos(diff), sin(diff), -sin(diff), cos(diff));\n  float border_0 = pow(r, 2.0), border_1 = (s - a) * (s + a), border_2 = (t - b) * (t + b);\n  for(int i = 0; i < ITERATIONS; i++){\n    norm = magSq(p);\n    if(norm < border_0){\n      p = inversion(p, r, 0.0);\n      count += 1.0;\n    }else if(norm - 2.0 * p.x * a > border_1){\n      p = inversion(p, s, a);\n      count += 1.0;\n    }else if(norm - 2.0 * p.x * b > border_2){\n      p = inversion(p, t, b);\n      count += 1.0;\n    }else{\n      arrived = true;\n    }\n    if(arrived){ break; }\n  }\n  p = p / r;\n  float e_0 = calc_dist(p.x, p.y, center.y, radius.y) / distWithEdge.x;\n  float e_1 = calc_dist(p.x, p.y, center.x, radius.x) / distWithEdge.y;\n  float e_2 = calc_dist(p.x, p.y, 0.0, 1.0) / distWithEdge.z;\n  float e = pow(e_0*e_1*e_2,0.5) * 6.0;\n  return vec4((2.0 * e_0 + e_2 * (e_1 - e_0)) / (2.0 * (e_0 + e_1)), 1.0 - e_2, mod(count, 2.0), e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // center_yUp\n  vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n  \n  vec3 mainColor = vec3(0.0, 0.518, 0.9);\n  vec3 subColor = vec3(0.56, 0.698, 0.8);\n  vec2 center = vec2(-1.7, 1.7);\n  vec2 radius = vec2(2.4, 2.4);\n  vec3 distWithEdge = vec3(0.8424, 0.8424, 0.5306);\n  int mode = POINCARE;\n  int borderType = MULTIPLY;\n  int backgroundType = WHITE;\n \n  vec4 color = vec4(1.0);\n\n\n  vec4 result = iteration(uv, iTime, center, radius, distWithEdge, mode);\n\n  color = vec4(vec3(result.z),1.0);\n\n  // result.xが負の場合は外側なので何もせず抜ける\n  if (result.x < 0.0) {\n    color = vec4(0.0);\n  } else {\n    //vec4 textureColor = texture(uImg, result.xy);\n    vec4 textureColor = vec4(0.0);\n    vec3 backColor = vec3(result.w);\n    vec3 baseColor = vec3((1.0 - result.z) * mainColor + result.z * subColor);\n    vec3 finalColor;\n    if (borderType == MULTIPLY) {\n      finalColor = baseColor * backColor;\n    } else {\n      backColor = 1.0 - backColor;\n      finalColor = baseColor + backColor - backColor * baseColor;\n    }\n    // textureにalphaは梱包済みなので、重ねてalphaを掛けると境界が汚くなってしまう。\n    // これでwebglのone,one_minus_src_alphaの効果になるわね。\n    color.rgb = textureColor.rgb + (1.0 - textureColor.w) * finalColor;\n    color.a = 1.0;\n  }\n  if (mode == POINCARE) {\n    // ポアンカレの場合は境界を透明にする\n    float circle = max(0.0, 0.99 - length(uv));\n    circle = pow(circle, 0.7);\n    color *= circle;\n  }\n  if (backgroundType == WHITE) {\n    color.rgb = color.rgb + (1.0 - color.a) * vec3(1.0);\n    color.a = 1.0;\n  }\n\n  // Output to screen\n  fragColor = color;\n}","name":"Image","description":"","type":"image"}]}