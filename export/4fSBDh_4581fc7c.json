{"ver":"0.1","info":{"id":"4fSBDh","date":"1726692284","viewed":23,"name":"bad attempt at 4d rendering","username":"shaderamogus","description":"just followed a paper ---> https://hollasch.github.io/ray4/Four-Space_Visualization_of_4D_Objects.html#chapter4\ncomment any improvements if u want (im still very new to shadertoy)\ni also have a bad 5d if ur interested.\nsend bugs pls","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void calcmat(vec3 from, vec3 up, vec3 to, out vec3 a, out vec3 b, out vec3 c);\nvoid calcmat4(vec4 from, vec4 up, vec4 over, vec4 to, out vec4 a, out vec4 b, out vec4 c, out vec4 d);\nvec3 matmult3(vec3 v, mat3 m);\nvec4 matmult4(vec4 v, mat4 m);\nfloat ldist(vec2 p, vec2 p1, vec2 p2);\nvec4 cross4(vec4 u, vec4 v, vec4 w);\nfloat dot4(vec4 v, vec4 w);\n\nconst float pi = 3.1415926535897932384626433832795028841971693993751058209749;\n\nfloat fov = 90. *(pi / 180.);\n\nvec4 points[21];\nvec2 lines[36];\nvec4 axiscols[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    axiscols[0] = vec4(1,0,0,0);\n    axiscols[1] = vec4(0,1,0,0);\n    axiscols[2] = vec4(0,0,1,0);\n    axiscols[3] = vec4(1,1,0,0);\n\n    points[0] = vec4(0);\n    points[1] = vec4(-1, -1, -1, -1);\n    points[2] = vec4(-1, -1, 1, -1);\n    points[3] = vec4(-1, 1, -1, -1);\n    points[4] = vec4(-1, 1, 1, -1);\n    points[5] = vec4(1, -1, -1, -1);\n    points[6] = vec4(1, -1, 1, -1);\n    points[7] = vec4(1, 1, -1, -1);\n    points[8] = vec4(1, 1, 1, -1);\n    points[9] = vec4(-1, -1, -1, 1);\n    points[10] = vec4(-1, -1, 1, 1);\n    points[11] = vec4(-1, 1, -1, 1);\n    points[12] = vec4(-1, 1, 1, 1);\n    points[13] = vec4(1, -1, -1, 1);\n    points[14] = vec4(1, -1, 1, 1);\n    points[15] = vec4(1, 1, -1, 1);\n    points[16] = vec4(1, 1, 1, 1);\n    \n    lines[0] = vec2(1,2);\n    lines[1] = vec2(1,3);\n    lines[2] = vec2(1,5);\n    lines[3] = vec2(4,2);\n    lines[4] = vec2(4,3);\n    lines[5] = vec2(4,8);\n    lines[6] = vec2(6,2);\n    lines[7] = vec2(6,5);\n    lines[8] = vec2(6,8);\n    lines[9] = vec2(7,3);\n    lines[10] = vec2(7,5);\n    lines[11] = vec2(7,8);\n    lines[12] = vec2(9,10);\n    lines[13] = vec2(9,11);\n    lines[14] = vec2(9,13);\n    lines[15] = vec2(12,10);\n    lines[16] = vec2(12,11);\n    lines[17] = vec2(12,16);\n    lines[18] = vec2(14,10);\n    lines[19] = vec2(14,13);\n    lines[20] = vec2(14,16);\n    lines[21] = vec2(15,11);\n    lines[22] = vec2(15,13);\n    lines[23] = vec2(15,16);\n    lines[24] = vec2(1,9);\n    lines[25] = vec2(2,10);\n    lines[26] = vec2(3,11);\n    lines[27] = vec2(4,12);\n    lines[28] = vec2(5,13);\n    lines[29] = vec2(6,14);\n    lines[30] = vec2(7,15);\n    lines[31] = vec2(8,16);\n    \n    points[17] = vec4(1, 0, 0, 0);\n    points[18] = vec4(0, 1, 0, 0);\n    points[19] = vec4(0, 0, 1, 0);\n    points[20] = vec4(0, 0, 0, 1);\n    \n    lines[32] = vec2(0, 17);\n    lines[33] = vec2(0, 18);\n    lines[34] = vec2(0, 19);\n    lines[35] = vec2(0, 20);\n    \n    const int pcount = 17;\n    const int lcount = 32;\n    const int axiscount = 4;\n\n    vec2 center = iResolution.xy/2.;\n    fragColor = vec4(0.);\n    float projc = 1./tan(fov/2.);\n    float aratio = iResolution.x / iResolution.y;\n    float lthicc = 1.;\n    \n    float theta = iTime * 2. * pi * 0.1;\n    float phi = iTime * 2. * pi * 0.07;\n    mat4 rotmat = mat4(cos(theta), 0, 0, -sin(theta), 0, cos(phi), -sin(phi), 0, 0, sin(phi), cos(phi), 0, sin(theta), 0, 0, cos(theta));\n    \n    vec4 from4 = vec4(0);\n    vec4 to4 = vec4(0, 0, 0, 2);\n    vec4 up4 = vec4(0, 1, 0, 0);\n    vec4 over4 = vec4(0, 0, 1, 0);\n    \n    vec4 a4, b4, c4, d4;\n    calcmat4(from4, up4, over4, to4, a4, b4, c4, d4);\n    \n    for (int i = 0; i < pcount + axiscount; i++)\n    {\n        vec4 v = matmult4(points[i], rotmat);\n        v = v + to4 - from4;\n        vec4 prime = matmult4(v, mat4(a4, b4, c4, d4));\n        float cons4 = projc / dot4(v, d4);\n        vec3 p;\n        p.x = cons4 * dot4(v, a4);\n        p.y = cons4 * dot4(v, b4);\n        p.z = cons4 * dot4(v, c4);\n        points[i].xyz = p;\n    }\n    \n    \n\n    vec3 from = vec3(0);\n    vec3 to = vec3(-7, -3, 10);\n    vec3 up = vec3(0, 1, 0);\n    \n    vec3 a, b, c;\n    calcmat(from, up, to, a, b, c);\n    \n    for (int i = 0; i < pcount; i++)\n    {\n        vec3 x = points[i].xyz;\n        vec3 v = x + to - from;\n        vec3 prime = matmult3(v, mat3(a, b, c));\n        vec2 t = vec2(prime.x/prime.z * projc, prime.y/prime.z * projc);\n        float cons = projc / dot(v, c);\n        vec2 s;\n        s.x = center.x + (iResolution.x * cons * dot(v, a));\n        s.y = center.y + (iResolution.y * cons * dot(v, b) * aratio);\n        points[i].xy = s; \n        if (distance(fragCoord, s) <= 2.)\n        {\n            fragColor = vec4(1, 0, 0, 1);\n            if (i == 0)\n            {\n                fragColor = vec4(1, 0.7, 0.5, 1);\n            }\n        }\n    }\n    \n    for (int i = 0; i < axiscount; i++)\n    {\n        vec3 x = points[i + pcount].xyz;\n        vec3 v = x + to - from;\n        vec3 prime = matmult3(v, mat3(a, b, c));\n        vec2 t = vec2(prime.x/prime.z * projc, prime.y/prime.z * projc);\n        float cons = projc / dot(v, c);\n        vec2 s;\n        s.x = center.x + (iResolution.x * cons * dot(v, a));\n        s.y = center.y + (iResolution.y * cons * dot(v, b) * aratio);\n        points[i + pcount].xy = s; \n        if (distance(fragCoord, s) <= 4.)\n        {\n            fragColor = axiscols[i];\n        }\n    }\n    \n    \n    \n    for (int i = 0; i < lcount; i++)\n    {\n        vec2 p1 = points[int(lines[i].x)].xy;\n        vec2 p2 = points[int(lines[i].y)].xy;\n        float pd = distance(p1, p2);\n        float p1d = distance(p1, fragCoord);\n        float p2d = distance(p2, fragCoord);\n        float ld = ldist(fragCoord, p1, p2);\n        if (fragColor == vec4(0.) && ld < lthicc && p1d < pd + lthicc && p2d < pd + lthicc)\n        {\n            fragColor = vec4(1);\n        }\n    }\n    \n    for (int i = 0; i < axiscount; i++)\n    {\n        vec2 p1 = points[int(lines[i + lcount].x)].xy;\n        vec2 p2 = points[int(lines[i + lcount].y)].xy;\n        float pd = distance(p1, p2);\n        float p1d = distance(p1, fragCoord);\n        float p2d = distance(p2, fragCoord);\n        float ld = ldist(fragCoord, p1, p2);\n        if (ld < lthicc)\n        {\n            fragColor += axiscols[i] * 0.2;\n        }\n    }\n}\n\nvoid calcmat(vec3 from, vec3 up, vec3 to, out vec3 a, out vec3 b, out vec3 c)\n{\n    c = normalize(to-from);\n    a = normalize(cross(up, c));\n    b = cross(c, a);\n}\n\nvoid calcmat4(vec4 from, vec4 up, vec4 over, vec4 to, out vec4 a, out vec4 b, out vec4 c, out vec4 d)\n{\n    d = normalize(to-from);\n    a = normalize(cross4(up, over, d));\n    b = normalize(cross4(over, d, a));\n    c = cross4(d, a, b);\n}\n\nvec3 matmult3(vec3 v, mat3 m)\n{\n    vec3 o;\n    o.x = v.x*m[0][0] + v.y*m[0][1] + v.z*m[0][2];\n    o.y = v.x*m[1][0] + v.y*m[1][1] + v.z*m[1][2];\n    o.z = v.x*m[2][0] + v.y*m[2][1] + v.z*m[2][2];\n    return o;\n}\n\nvec4 matmult4(vec4 v, mat4 m)\n{\n    vec4 o;\n    o.x = v.x*m[0][0] + v.y*m[0][1] + v.z*m[0][2] + v.w*m[0][3];\n    o.y = v.x*m[1][0] + v.y*m[1][1] + v.z*m[1][2] + v.w*m[1][3];\n    o.z = v.x*m[2][0] + v.y*m[2][1] + v.z*m[2][2] + v.w*m[2][3];\n    o.w = v.x*m[3][0] + v.y*m[3][1] + v.z*m[3][2] + v.w*m[3][3];\n    return o;\n}\n\nfloat ldist(vec2 p, vec2 p1, vec2 p2)\n{\n    float a = p1.y - p2.y;\n    float b = p2.x - p1.x;\n    float c = (p1.x - p2.x)*p1.y + (p2.y - p1.y)*p1.x;\n    \n    return abs(a*p.x + b*p.y + c)/sqrt(a*a + b*b);\n}\n\nvec4 cross4(vec4 u, vec4 v, vec4 w)\n{\n    vec4 o;\n    o.x = determinant(mat3(u.y, v.y, w.y, u.z, v.z, w.z, u.w, v.w, w.w));\n    o.y = determinant(mat3(u.x, v.x, w.x, u.z, v.z, w.z, u.w, v.w, w.w));\n    o.z = determinant(mat3(u.x, v.x, w.x, u.y, v.y, w.y, u.w, v.w, w.w));\n    o.w = determinant(mat3(u.x, v.x, w.x, u.y, v.y, w.y, u.z, v.z, w.z));\n    return o;\n}\n\nfloat dot4(vec4 v, vec4 w)\n{\n    return v.x*w.x + v.y*w.y + v.z*w.z + v.w*w.w;\n}","name":"Image","description":"","type":"image"}]}