{"ver":"0.1","info":{"id":"7tfczX","date":"1648414348","viewed":69,"name":"Reflexion par raytracing","username":"lyesmaz","description":"Raytracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float     FLT_MAX                   = 1.0 / 0.0;    \n\nconst int       MAX_NB_BOUNCES            = 10;\nconst int       NB_LIGHTS                 = 2;\n\nconst int       TIME_SAMPLING_SIZE        = 5;\nconst float     TIME_SAMPLING_OFFSET_TIME = 0.075;\n\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n\nstruct ShaderInfo\n{\n    vec3 shaderCol;\n    float Ks;\n};\n\nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n    \n\n      vec3\t   cameraPos    = vec3(6,  4, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\n      vec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.1/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.1/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n\n\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t\nconst vec3     light1Col     = vec3(1,1,1);\t\t\n      vec3     light1Pos     = vec3(8, 10, -12);\nconst float    light1Pow    = 0.8;\nconst vec3     light2Col   = vec3(1,1,1);   \n      vec3     light2Pos    = vec3(1, 1, 1);\nconst float    light2Pow    = 0.5; \n\n\nLightInfo lights[NB_LIGHTS];\n\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n  \n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n        \n    \n\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        \n  \n        intersecPt = rayPos + t * rayDir;\n\n     \n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n  \n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t\n        return -1.0;\t\t\t\n        \t\t\t\t\t\t\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n\n    intersecPt = rayPos + t * rayDir;\n    \n\n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n  \n    \n    vec3 up = vec3(0,1,0);\n    vec3 cx = normalize(cross(-up, cz));\n    \n    vec3 cy = normalize(cross( cz, cx));\n\n  \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n\n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    \n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    \n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    \n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n  \n    \n    vec3  shadowRayStart = I + 0.0001 * N;\t\n\n    vec3  shadowRayDir   = L;\n    \n  \n    int   unusedInt;\n    vec3  unusedVec1, unusedVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir,\n                                                 unusedInt, unusedVec1, unusedVec2);\n    \n \n    float shadowFactor = (shadowRes < 0.0 || shadowRes >= Ldist) ? 1.0 : objectMat.Ka;\n    \n    return shadowFactor;\n}\n\n\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,\n                         float shadowFactor, vec3 N, int indL, vec3 L, vec3 R, vec3 V)\n{   \n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lights[indL].col * lights[indL].power *   max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *              lights[indL].col * lights[indL].power *   pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n\n    return phongCol;\n}\n\n\n\n\n\nfloat integrate(vec2 pos1, vec2 pos2)\n{\n    vec2 D = pos2 - pos1; \n    \n    float t0 = 0.;\n    float t1 = 1.;\n    \n    \n    return 0.0;\n}\n\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    float time = iTime;\n    float dtime = iTimeDelta;   \n    \n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord,rayPos, rayDir);\n    \n    ShaderInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n        if (distI <= 0.0)\n        {\n            infos[nbBounces].shaderCol = skyCol;\n            infos[nbBounces].Ks        = 0.1;\n            break;\n        }\n  \n        for (int i=0; i<NB_LIGHTS; i++)\n        {\n            vec3 L = lights[i].pos - intersecI;\n            float Ldist = length(L);\n            L = L / Ldist;\n            vec3 R = 2.0 * dot(normalI, L) * normalI - L;\n            vec3 V = -rayDir;\n\n            Material objectMat;\n            vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n            float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n            infos[nbBounces].shaderCol += computePhongShading(objectCol, objectMat, shadowFactor, normalI, i, L, R, V);\n            infos[nbBounces].Ks        = objectMat.Ks;\n        }  \n        \n        rayPos = intersecI + normalI * 0.001;\n        rayDir = reflect(rayDir, normalI);\n        nbBounces ++;\n        \n    }while (nbBounces < MAX_NB_BOUNCES);\n    \n    if (nbBounces == 0) return skyCol;\n    \n    vec3 resCol = infos[nbBounces - 1].shaderCol;\n    \n    int i=nbBounces;\n    while(i>=0){\n        resCol = resCol * infos[i].Ks + infos[i].shaderCol;\n        i--;\n    \n    }\n    \n    \n    \n  \n    return resCol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].power = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].power = light2Pow;\n\n    \n        \n    \n    vec3 resCol = RaytraceAtPixelCoord(fragCoord);\n    \n    \n    fragColor = vec4(resCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}