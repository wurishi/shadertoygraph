{"ver":"0.1","info":{"id":"wsVBz1","date":"1607732241","viewed":287,"name":"Sierpinski Tetrahedron - Final","username":"amhall","description":"The final result of the raymarching tutorial. Click to rotate!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching the Sierpinski Tetrahedron: Final\n// Created by Anthony Hall for Writ 107T\n\n// Raymarching constants\nconst float maxDistance = 30.0;\nconst float epsilon = 0.001;\n\nconst float maxShadowDistance = 10.0;\nconst float shadowEpsilon = 0.005;\n\n// Lighting\nconst float kAmbient = 0.35;\nconst float kDiffuse = 1.0 - kAmbient;\n\nconst float shadowK = 30.0;\n\nconst float aoIncrement = 0.02;\nconst float aoK = 4.0;\n\n// Camera\nvec3 cameraPos = vec3(0.0, 0.5, 4.0);\nconst float fov = radians(50.0);\n\n// Other scene globals\nconst vec3 skyColor = vec3(0.5, 0.75, 1.0);\nconst vec3 toSun = normalize(vec3(-1.0, 3.75, 2.0));\n\n// Number of iterations for the Sierpinski IFS\nconst int sierpinskiLevel = 5;\n\n// Vertices of the tetrahedron defined by the SDF\nconst vec3[] vertices = vec3[](\n    vec3(1.0, 1.0, 1.0),\n    vec3(-1.0, 1.0, -1.0),\n    vec3(-1.0, -1.0, 1.0),\n    vec3(1.0, -1.0, -1.0));\n\n// Get a 2D rotation matrix\nmat2 getRotationMatrix(float angle)\n{\n\treturn mat2(cos(angle), sin(angle),\n                -sin(angle), cos(angle));\n}\n\n// Get a surface color based on a point's location\n// Uses a procedural palette from iq\n// https://www.shadertoy.com/view/ll2GD3\nvec3 getColor(vec3 point)\n{\n    // Set t such that the floor color will change slowly\n    // and the tetrahedron color will change more rapidly\n    float t;\n    if (point.y < -1.9) {\n        t = point.x / 60.0 + 0.2;\n    }\n    else {\n        point /= 2.0;\n     \tt = point.x * point.x - point.y + point.z * point.z;\n    }\n    \n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.00, 0.10, 0.20);\n\tvec3 color = a + b*cos( radians(360.0)*(c*t+d) );\n    \n    // Lighten the color a bit\n    return mix(color, vec3(1.0), 0.3);\n}\n\n// Signed distance to a floor plane\nfloat sdFloor(vec3 point, float floorY)\n{\n\treturn point.y - floorY;\n}\n\n// Signed distance to a tetrahedron within canonical cube\n// https://www.shadertoy.com/view/Ws23zt\nfloat sdTetrahedron(vec3 point)\n{\n    return (max(\n\t    abs(point.x + point.y) - point.z,\n\t    abs(point.x - point.y) + point.z\n\t) - 1.0) / sqrt(3.);\n}\n\n// Fold a point across a plane defined by a point and a normal\n// The normal should face the side to be reflected\nvec3 fold(vec3 point, vec3 pointOnPlane, vec3 planeNormal)\n{\n    // Center plane on origin for distance calculation\n    float distToPlane = dot(point - pointOnPlane, planeNormal);\n    \n    // We only want to reflect if the dist is negative\n    distToPlane = min(distToPlane, 0.0);\n    return point - 2.0 * distToPlane * planeNormal;\n}\n\n// Signed distance to Sierpinski tetrahedron at specified level\n// Rotates over time or with mouse press\nfloat sdSierpinski(vec3 point, int level)\n{\n    // If the mouse is not pressed, rotate the tetrahedron over time\n    // Otherwise, rotate it based on the mouse position\n    if (iMouse.z <= 0.0) {\n        float time = iTime / 4.0;\n        point.xz = getRotationMatrix(time) * point.xz;\n    }\n    else {\n     \tvec2 mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        \n        point.yz = getRotationMatrix(mouse.y) * point.yz;\n        point.xz = getRotationMatrix(mouse.x) * point.xz;\n    }\n    \n    float scale = 1.0;\n    for (int i = 0; i < level; i++)\n    {\n    \t// Scale point toward corner vertex, update scale accumulator\n        point -= vertices[0];\n        point *= 2.0;\n        point += vertices[0];\n        \n        scale *= 2.0;\n        \n        // Fold point across each plane\n        for (int i = 1; i <= 3; i++)\n        {\n            // The plane is defined by:\n            // Point on plane: The vertex that we are reflecting across\n            // Plane normal: The direction from said vertex to the corner vertex\n         \tvec3 normal = normalize(vertices[0] - vertices[i]); \n            point = fold(point, vertices[i], normal);\n        }\n    }\n    // Now that the space has been distorted by the IFS,\n    // just return the distance to a tetrahedron\n    // Divide by scale accumulator to correct the distance field\n    return sdTetrahedron(point) / scale;\n}\n\n// Returns signed distance to the scene\nfloat scene(vec3 point)\n{\n    // Create a sierpinski tetrahedron and a floor\n \tfloat sierpinskiDist = sdSierpinski(point, sierpinskiLevel);\n    float floorDist = sdFloor(point, -2.0);\n    \n    return min(sierpinskiDist, floorDist);\n}\n\n// Approximates the normal at an intersection by calculating the gradient of the distance function\nvec3 estimateNormal(vec3 point) {\n\treturn normalize(vec3(\n        scene(vec3(point.x + epsilon, point.y, point.z)) - scene(vec3(point.x - epsilon, point.y, point.z)),\n        scene(vec3(point.x, point.y + epsilon, point.z)) - scene(vec3(point.x, point.y - epsilon, point.z)),\n        scene(vec3(point.x, point.y, point.z  + epsilon)) - scene(vec3(point.x, point.y, point.z - epsilon))));\n}\n\n// Distance field AO\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf slide 53\nfloat calcAO(vec3 surfacePoint, vec3 normal)\n{\n    float t = aoIncrement;\n    float distSum = 0.0; // Sum of distance differences\n\n    // Take four distance samples, compare to orthogonal distance\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 point = surfacePoint + t * normal;\n     \tfloat dist = scene(point);\n        \n        distSum += exp2(-float(i)) * (t - dist);\n        \n        t += aoIncrement;\n    }\n    return 1.0 - aoK * distSum;\n}\n\n// Calculates the percentage that a point is illuminated\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadow(vec3 surfacePoint)\n{\n    // Initialize our marching variables\n \tvec3 point = surfacePoint;\n    float t;\n    float illumination = 1.0;\n    \n    // Initialize the ray a little bit away from the point\n    // We don't want to start close enough to be considered a hit\n    for (t = 2.0 * shadowEpsilon; t < maxShadowDistance;)\n    {\n     \tpoint = surfacePoint + t * toSun;\n        float dist = scene(point);\n        \n        // The path to the sun is blocked\n        if (dist < shadowEpsilon) {\n            return 0.0;\n        }\n        \n        // Get darker if we get closer to the scene than we have been before\n        illumination = min(illumination, shadowK * dist/t);\n        t += dist;\n    }\n    return illumination;\n}\n\n// Shades a surface at the given point\nvec3 shadeSurface(vec3 point) {\n    // Calculate the surface normal and color of our point\n    vec3 normal = estimateNormal(point);\n    vec3 surfaceColor = getColor(point);\n    \n    // Ambient\n    vec3 color = kAmbient * surfaceColor;\n    \n    // Diffuse\n\tfloat diffuseIntensity = max(dot(normal, toSun), 0.0);\n    \n    // Shadow\n    float illumination = calcShadow(point);\n    diffuseIntensity *= illumination;\n    color += kDiffuse * diffuseIntensity * surfaceColor;\n    \n    // AO (only on pyramid)\n    if (point.y > -2.0 + epsilon) {\n        float occlusion = calcAO(point, normal);\n        color *= occlusion;\n    }\n    \n    return color;\n}\n\n// Returns the result color of casting any ray\nvec3 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    // Initialize our marching variables\n    vec3 point = rayOrigin;\n    float t;\n    vec3 color = skyColor;\n    \n    // Repeatedly march the ray forward based on the distance to the scene\n    for (t = 0.0; t < maxDistance; point = rayOrigin + t * rayDir)\n    {\n     \tfloat dist = scene(point);\n        \n        // We got a hit\n        if (dist <= epsilon) {\n            color = shadeSurface(point);\n        \tbreak;\n        }\n        t += dist;\n    }\n    float totalDist = t / maxDistance;\n    return mix(color, skyColor, totalDist * totalDist);\n}\n\nmat3 rotateRay(vec3 camera, vec3 dest, vec3 up)\n{\n    vec3 forward = normalize(dest - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    return mat3(right, up, -forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize the coordinates to [-1, 1] in the minimum dimension\n    // Use this to calculate the ray direction\n    float minDimension = min(iResolution.x, iResolution.y);\n    vec2 coord = 2.0 * (fragCoord - iResolution.xy/2.0) / minDimension;\n    vec3 rayDir = normalize(vec3(coord * tan(fov/2.0), -1.0));\n\n    // Make the camera point toward the origin\n    rayDir = rotateRay(cameraPos, vec3(0), vec3(0, 1, 0)) * rayDir;\n    \n    // Cast the ray!\n    vec3 color = castRay(cameraPos, rayDir);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}