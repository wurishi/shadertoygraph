{"ver":"0.1","info":{"id":"tlKBzc","date":"1614805891","viewed":105,"name":"Coherent White Light Hot Wall","username":"Quazi","description":"wave equation for a \"coherent\" white glowing wall (laser?), implementing shadertoy version of my page https://quazikb.github.io/WaveEq/index.html, hopefully with a heat model too eventually","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"wlKfRc","parentname":"White Light Hot Wall"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    int data_index = int(fragCoord.x)%2;\n    vec2 data_offset0 = vec2(-data_index,0);\n    vec2 data_offset1 = vec2(-data_index+1,0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    // sample texture and output to screen\n    vec4 buffA = texture(iChannel0, uv);\n    //vec4 buffD = textureLod(iChannel2, uv,1.0);\n\n    // Time varying pixel color (wave display)\n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    if(buffA.r<0.){\n    col.b = -1.0*buffA.r;\n    }else{\n    col.r = buffA.r;\n    }\n    \n    //col.rgb = LMS_2_RGB(buffB.rgb)*1.0;\n    vec2 data_uv = (fragCoord+data_offset1)/iResolution.xy;\n    \n    vec4 integrator = texture(iChannel1, data_uv);\n    vec3 RGB = LMS_2_RGB(integrator.rgb)*2.0;\n    vec4 disp = vec4(RGB,1.0);\n    // Output to screen\n    fragColor = disp;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 p = fragCoord.xy;\n    vec2 res = iResolution.xy;\n    vec2 uv = p/res;\n    vec4 col = vec4(0.0,0.0,0.0,1.0);   \n    \n    vec4 pc = texture(iChannel0, p/res);\n    float t1 = pc.r;\n    float t0 = pc.g;\n    \n    //define absorbing boundary to minimize echoes using rounded rect from sdf\n    vec4 bg = vec4(1,1,1,1);\n    float ramp_width = 30.0;\n    vec2 b = res*0.5-vec2(ramp_width,ramp_width);\n    vec2 q = abs((p-res*0.5)) - b;\n    float sd =length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    bg.b=clamp(1.0-sd/ramp_width,0.0,1.0);\n    \n    float R = c_cell_per_dt*(1.0-(1.0-bg.g));\n    \n    float v = t1-t0;\n    vec4 laplacian_t1 = -4.0*pc;\n    laplacian_t1 += texture(iChannel0, (p+vec2( 1, 0))/res);\n    laplacian_t1 += texture(iChannel0, (p+vec2(-1, 0))/res);\n    laplacian_t1 += texture(iChannel0, (p+vec2( 0, 1))/res);\n    laplacian_t1 += texture(iChannel0, (p+vec2( 0, -1))/res);   \n    col.r = (t1+v*wave_vel_damping*bg.b+R*R*laplacian_t1.r); //symplectic wave equation step\n    col.g = pc.r;//store prev state\n    \n    //forcing\n    float light_wavelength_nm = mix(300.0,1000.0,iMouse.x/res.x); \n    //if(iMouse.z>0.){\n        vec2 m_c = iMouse.xy;\n        //vec2 m_c = res*0.5;\n        vec2 m_p = p-m_c;\n        uvec2 up = uvec2(m_c)+uvec2(((0,iFrame%1000000)*1080));\n        vec3 rand = hash3( up.x + 1920U*up.y + (1920U*1080U)*uint(iFrame) );\n        if(uv.x < 0.1){\n            col.r = sin(float(iFrame)*(2.0*PI*(c_cell_per_dt*grid_nm_per_cell/light_wavelength_nm))+rand.r*2.0*PI)*0.8;\n            col.r = rand.r*0.8;\n            //col.r = random(p);\n            //col.r\n            //col.g = col.r;\n        }\n        if(length(m_p)<30.){\n            col.r = 0.0;\n            col.g = 0.0;\n        }\n    //}\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 p = fragCoord.xy;\n    vec2 res = iResolution.xy;\n    fragColor = texture(iChannel0, p/res);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626433832795\n//bunch of constants\nconst float wave_speed = 1.0;\nconst float c_cell_per_dt = 0.5*wave_speed;\nconst float grid_nm_per_cell = 50.625;\nconst vec3 rgb_peak_perceptive_wavelength_nm = vec3(553.71685738,531.2838817,443.52513556);\nconst vec3 rgb_eye_sensitivity_damp_ratio = vec3(0.09500278,0.08503587,0.06160486);\nconst vec3 rgb_eye_sensitivity_masses = vec3(1.1675646,1.3637187,1.8458749);\nconst vec3 rgb_peak_perceptive_waves_per_dt = (c_cell_per_dt*grid_nm_per_cell)/rgb_peak_perceptive_wavelength_nm;\nconst vec3 rgb_omega = 2.0*PI*rgb_peak_perceptive_waves_per_dt;\nconst float wave_vel_damping = 1.0;\nvec3 XYZ_2_RGB(vec3 C) {\n  vec3 RGB = vec3(\n 3.2404542*C.x - 1.5371385*C.y - 0.4985314*C.z,\n-0.9692660*C.x + 1.8760108*C.y + 0.0415560*C.z,\n 0.0556434*C.x - 0.2040259*C.y + 1.0572252*C.z);\n  //sRGB correction?\n  vec3 abs_RGB = abs(RGB);\n  return clamp(mix(1.055 * pow(RGB, vec3(0.41666,0.41666,0.41666)) - 0.055, 12.92 * RGB,vec3(abs_RGB.x<0.0031308,abs_RGB.y<0.0031308,abs_RGB.z<0.0031308)),0.0,1.0);\n  //return RGB;\n}\nvec3 LMS_2_RGB(vec3 LMS) {\n    vec3 XYZ = vec3(\n        1.91019683*LMS.x-1.11212389*LMS.y+2.01907957e-01*LMS.z,\n        3.70950088e-01*LMS.x+6.29054257e-01*LMS.y-8.05514218e-06*LMS.z,\n        1.00000000*LMS.z\n    );\n    return XYZ_2_RGB(XYZ);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n//https://www.shadertoy.com/view/llGSzw\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n//void tempdump( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    //oscillators\n//    vec2 p = fragCoord.xy;\n//    vec2 res = iResolution.xy;\n//    vec4 col = vec4(0.0,0.0,0.0,0.0);\n//\n//    float k = 0.9;\n//    vec4 p1 = texture(iChannel0, p/res);\n//    vec4 t1 = texture(iChannel1, p/res);\n//    vec4 t0 = texture(iChannel2, p/res);\n//    vec4 v = t1-t0;\n//    col.rgb = t1.rgb\n//    +v.rgb-rgb_eye_sensitivity_damp_ratio*rgb_omega*v.rgb\n//    -rgb_omega*rgb_omega*(t1.rgb)\n//    +k*p1.r/rgb_eye_sensitivity_masses;\n//    \n//    fragColor = col;\n//}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //oscillators\n    vec2 p = fragCoord.xy;\n    int data_index = int(p.x)%2;\n    vec2 data_offset0 = vec2(-data_index,0);\n    vec2 data_offset1 = vec2(-data_index+1,0);\n    \n    vec2 res = iResolution.xy;\n    vec4 col = vec4(0.0,0.0,0.0,0.0);\n\n    float k = 0.9;\n    vec4 p1 = texture(iChannel0, (p+data_offset0)/res);\n    vec4 t1 = texture(iChannel1, (p+data_offset0)/res);\n    vec4 t0 = texture(iChannel2, (p+data_offset0)/res);\n    vec4 v = t1-t0;\n    //v.r = t1.r-t0.r;\n    //col.g = t1.r;\n    //col.r = t1.r\n    //+v.r-rgb_eye_sensitivity_damp_ratio.r*rgb_omega.r*v.r\n    //-rgb_omega.r*rgb_omega.r*(t1.r)\n    //+k*p1.r/rgb_eye_sensitivity_masses.r;\n    if(data_index==0){\n        col.rgb = t1.rgb\n        +v.rgb-rgb_eye_sensitivity_damp_ratio*rgb_omega*v.rgb\n        -rgb_omega*rgb_omega*(t1.rgb)+k*p1.r/rgb_eye_sensitivity_masses;\n    }\n    else{\n        vec4 current = texture(iChannel1, (p+data_offset1)/res);\n        //wave value\n        vec3 integrator = 0.5*(rgb_eye_sensitivity_masses*((v.rgb*v.rgb)+rgb_omega*rgb_omega*(t1.rgb*t1.rgb-v.rgb*t1.rgb)))/0.5*rgb_eye_sensitivity_damp_ratio;\n        col = mix(current,vec4(integrator,0.0),0.001);\n    }\n    \n    fragColor = col;\n}\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{    \n//    vec2 p = fragCoord.xy;\n//    vec2 res = iResolution.xy;\n//    vec4 col = vec4(0.0,0.0,0.0,1.0);\n//    \n//    //define absorbing boundary to minimize echoes using rounded rect from sdf\n//    vec4 props = vec4(1,1,1,1);\n//    float ramp_width = 30.0;\n//    vec2 b = res*0.5-vec2(ramp_width,ramp_width);\n//    vec2 q = abs((p-res*0.5)) - b;\n//    float sd =length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n//    props.b=clamp(1.0-sd/ramp_width,0.0,1.0);\n//    \n//    \n//    \n//    \n//    \n//    vec4 pc = texture(iChannel0, p/res);\n//    vec4 t0 = texture(iChannel1, p/res);\n//    float v = pc.r-t0.r;\n//    vec4 L = -4.0*pc;\n//    L += texture(iChannel0, (p+vec2( 1, 0))/res);\n//    L += texture(iChannel0, (p+vec2(-1, 0))/res);\n//    L += texture(iChannel0, (p+vec2( 0, 1))/res);\n//    L += texture(iChannel0, (p+vec2( 0, -1))/res);   \n//    col.r = pc.r+v*props.b+c_cell_per_dt*c_cell_per_dt*L.r;\n//    col.g = pc.r;//store prev state\n//    \n//    //forcing\n//    float freq = 10.0;\n//    //if(iMouse.z>0.){\n//        vec2 m_p = p-iMouse.xy;\n//        m_p = p-vec2(300,300);\n//        if(length(m_p) < 30.0){\n//            col.r = sin(iTime*freq)*1.0;\n//            col.g = col.r;\n//        }\n//    //}\n//    \n//    fragColor = col;\n//}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec2 p = fragCoord.xy;\n    vec2 res = iResolution.xy; \n    fragColor = texture(iChannel0, p/res);\n}","name":"Buffer D","description":"","type":"buffer"}]}