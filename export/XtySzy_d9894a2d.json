{"ver":"0.1","info":{"id":"XtySzy","date":"1484761865","viewed":627,"name":"Bidirectional Monte Carlo","username":"TekF","description":"Fixed the black rim! Turns out using non-PBR specular was probably never going to work (should have realised that).\n\nGreat PBR reference can be found here: https://learnopengl.com/#!PBR/Theory","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["bidirectionalmontecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    if ( true )\n    {\n    \tfragColour = texture(iChannel0,fragCoord/iResolution.xy);\n    }\n    else\n    {\n    \t// 3x3 blur\n        fragColour = vec4(0);//texture(iChannel0,fragCoord/iResolution.xy);\n\n        vec3 d = vec3(-1,0,1);\n        //fragColour += texture(iChannel0,(fragCoord+d.xx)/iResolution.xy);\n        fragColour += texture(iChannel0,(fragCoord+d.xy)/iResolution.xy);\n        fragColour += texture(iChannel0,(fragCoord+d.xz)/iResolution.xy);\n        fragColour += texture(iChannel0,(fragCoord+d.yx)/iResolution.xy);\n        fragColour += texture(iChannel0,(fragCoord+d.yy)/iResolution.xy);\n        fragColour += texture(iChannel0,(fragCoord+d.yz)/iResolution.xy);\n        fragColour += texture(iChannel0,(fragCoord+d.zx)/iResolution.xy);\n        fragColour += texture(iChannel0,(fragCoord+d.zy)/iResolution.xy);\n        //fragColour += texture(iChannel0,(fragCoord+d.zz)/iResolution.xy);\n    }\n    \n    fragColour /= fragColour.a;\n    \n    // HDR\n    const float a = 2.5;\n    const float p = 2.; // curve where colours hit white (lower = softer)\n    const float r = 1.2; // overflow\n    fragColour = r*pow(1.-1./(1.+pow(a*fragColour/r,vec4(p))),vec4(1./p));\n    \n\tfragColour = pow(fragColour,vec4(1./2.2));\n    fragColour.a = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define TREES 1\n#define SHINYBALL 1\n\nconst int DEPTH = 3; // trace depth - longest path is 2*DEPTH+1\n\nconst float tau = 6.28318530717958647692;\nconst float phi = 1.61803398875;\n\nvec2 Rand( in float seed )\n{\n\t// line artefacts get worse as seed gets higher => rand isn't the problem\n//    seed /= 100.;\n    // concentrates more at the edges\n//    vec2 r = vec2( fract(37*sin(phi*seed)), fract(31*sin(seed/phi)) );\n\n\t// offsetting by a procession = almost perfect!\n    vec2 r = fract( vec2( 37.*sin(phi*seed), 31.*sin(seed/phi) ) + seed/1024.);\n    \n    return fract( r + .5);  // offset to make edge biases more visible\n}\n\n\n// generate a unique seed \nvec2 Rand( in int seed, in int roll )\n{\n    return Rand( float(seed)*(1.+phi/(1.+float(roll))) );\n}\n\n\nvec3 SphereRand( in int seed, in int roll )\n{\n    vec2 a = Rand(seed,roll);\n    \n    a.x = a.x*2.-1.;\n    a.x = sign(a.x)*(1.-sqrt(1.-abs(a.x))); // this is not the perfect distribution\n    a.x *= tau/4.;\n    a.y *= tau;\n    \n    return vec3(cos(a.x)*sin(a.y),-sin(a.x),cos(a.x)*cos(a.y));\n}\n\nvec3 HemisphereRand( in int seed, in int roll, in vec3 dir )\n{\n    vec3 r = SphereRand(seed,roll);\n    \n    return r*(step(.0,dot(r,dir))*2.-1.);\n}\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\t// high precision interpolation, if needed\n\tvec2 uv = (p.xy+vec2(37.0,-17.0)*p.z);\n    vec4 rg = mix( mix(\n                    textureLod( iChannel3, (uv+0.5)/256.0, 0.0 ),\n                    textureLod( iChannel3, (uv+vec2(1,0)+0.5)/256.0, 0.0 ),\n                    f.x ),\n\t\t\t\t  mix(\n                    textureLod( iChannel3, (uv+vec2(0,1)+0.5)/256.0, 0.0 ),\n                    textureLod( iChannel3, (uv+1.5)/256.0, 0.0 ),\n                    f.x ),\n\t\t\t\tf.y );\n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n// Cheaper, but has some stepping artefacts\nvec2 Noise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,-17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel3, (uv+0.5)/256.0, 0.0 );\n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\n//const vec3 lightPos = vec3(-20,10,50); const vec3 lightSourceCol = vec3(2,1,.5);\n//const vec3 lightPos = vec3(-20,40,40); const vec3 lightSourceCol = vec3(1.5,1.3,1.1); //vec3(1.5,1.2,.9);\n//const vec3 lightPos = vec3(20,50,-10); const vec3 lightSourceCol = vec3(1.4,1.3,1.2); //vec3(1.5,1.2,.9);\n//const vec3 lightPos = vec3(20,40,-40); const vec3 lightSourceCol = vec3(1.5,1.3,1.1); //vec3(1.5,1.2,.9);\nconst vec3 lightPos = vec3(20,20,-50); const vec3 lightSourceCol = vec3(1.5,1.2,1); //vec3(1.5,1.2,.9);\n\nconst vec3 skyTone = vec3(.25,.5,1.);\n//const vec3 skyTone = vec3(.04,.05,.1);\n\n// I can't do emissive at present, so centre sky dome on light source and adjust its colour to compensate for light colour\nconst float skyRadius = 1000.;\n\n\nfloat Box( in vec3 pos, in vec3 centre, in vec3 dims )\n{\n    vec3 box = abs(pos-centre) - dims/2.;\n    return max(max(box.x,box.y),box.z);\n}\n\nfloat GroundHeight( in vec2 pos2D )\n{\n    return (Noise(vec3(pos2D.x,0,pos2D.y)/100.+20.).x-.635)*40.;\n}\n\nfloat GroundHeight2( in vec2 pos2D )\n{\n    return (Noise2(vec3(pos2D.x,0,pos2D.y)/100.+20.).x-.635)*40.;\n}\n\nfloat Tree( in vec3 pos, in vec3 c )\n{\n    vec3 posl = pos-c;\n/*    posl.xz -= c;\n    posl.y -= GroundHeight2(c);*/\n    return min( (length(posl-vec3(0,3,0))-1.7+.5*Noise2(pos*2.).x/*+.2*Noise2(pos*5.).x*/)*.8, max( abs(posl.y-.5)-2.5, length(posl.xz)-.2 ) );\n}\n\nfloat TargetSphere( in vec3 pos )\n{\n    return length(pos - vec3(-.5,1.4,1.)) - .8;\n}\n\nfloat Ground( in vec3 pos )\n{\n    float h = GroundHeight(pos.xz);\n    return(pos.y - h)*.8;\n}\n\nfloat SDF( in vec3 pos )\n{\n    // sky dome\n    float f = -(length(pos-lightPos)-skyRadius);\n    \n    // ground bumps\n    f = min( f, Ground(pos) );\n    \n    \n    // place trees in a grid (by finding closest grid square and drawing 4 trees)\n    const float grid = 5.;\n    vec2 cell = floor(pos.xz/grid);\n    \n#ifdef TREES\n    f = min( f, Tree( pos, vec3((cell+vec2(0,0))*grid,h).xzy ) );\n    f = min( f, Tree( pos, vec3((cell+vec2(1,0))*grid,h).xzy ) );\n    f = min( f, Tree( pos, vec3((cell+vec2(0,1))*grid,h).xzy ) );\n    f = min( f, Tree( pos, vec3((cell+vec2(1,1))*grid,h).xzy ) );\n#else    \n    f = min( f, Box( pos, vec3(4,1.5,0), vec3(2) ) );\n    f = min( f, Box( pos, vec3(4,2.5,0), vec3(2.2,.2,2.2) ) );\n    f = max( f, -Box( pos, vec3(3,1.5,0), vec3(.5,1,.5) ) );\n    f = min( f, Box( pos, vec3(0,1,4), vec3(2) ) );\n    f = min( f, Box( pos, vec3(6,1,6), vec3(4) ) );\n    f = min( f, Box( pos, vec3(-6,1,0), vec3(3) ) );\n    f = min( f, Box( pos, vec3(0,1,-6), vec3(3) ) );\n    f = min( f, Box( pos, vec3(-5,5,-5), vec3(4) ) );\n#endif    \n\n#ifdef SHINYBALL\n    f = min( f, TargetSphere( pos ) );\n#endif\n    \n\treturn f;\n}\n\nvec3 BRDF( in vec3 toCam, in vec3 toLight, in vec3 normal, in vec3 pos )\n{\n  \tfloat _ndoti = dot(normal,toCam);\n    float _ndotl = dot(normal,toLight);\n\n    if ( _ndoti < .0 || _ndotl < .0 )\n    {\n        return vec3(0);\n    }\n\n    // I don't know how but the above if() isn't preventing NaNs.\n\tfloat ndoti = max(_ndotl,.000001);\n    float ndotl = max(_ndotl,.000001);\n\n    // map materials to scene\n    \n    float roughness = .3;//mix( .02, .3, smoothstep(.35,.55,Noise(pos*2.).x) );\n    float metallicity = .0;\n    float f0 = .05; // plastic\n    float f1 = 1.; // should be 1 for all materials, I think.\n    vec3 albedo = vec3(.7);\n\n    if ( length(pos-lightPos)-skyRadius >= -.001  )\n    {\n        vec3 sp = (pos-lightPos)/skyRadius;\n        \n        albedo = mix(vec3(0),vec3(.5),exp2(-abs(sp.y)/skyTone));\n        \n        albedo /= lightSourceCol; \n        f0 = .0;\n        f1 = .0;\n    }\n#ifdef SHINYBALL\n    else if ( TargetSphere(pos) < .001 )\n    {\n        //albedo = vec3(1.,.71,.29); // gold (from https://learnopengl.com/#!PBR/Theory )\n        albedo = vec3(.95,.64,.54); // copper\n        //albedo = vec3(0.56, 0.57, 0.58); // iron\n// we get artefacts for low roughness values, because the random distribution isn't perfect\n        metallicity = mix( 0., 1., pow(cos(Noise(pos*2.).x*tau*2.5)*.5+.5,1.) );\n        roughness = mix( .2, .05, metallicity );\n        albedo = mix( vec3(.2,.2,.2), .125*albedo, metallicity );\n    }\n#endif\n/*\nHmm... blending based on metallicity creates incorrect in-between colours\nSurely there's a way to parameterise it to correctly approximate a blend between the *result* of shading metal vs diffuse\nKind of amazed games aren't doing it if there is a way.\ne.g. roughness => number of microfacets at a particular angle, so want metallicity => number of metallic microfacets\n\nThe problem is extracting albedo from reflectance - we really want 2 separate RGB values so we never lerp them\n=> that's why games aren't doing it, saves texture channels. Doh.\n\nWhat if we fudge it with a /8 *8, so the error of albedo used as diffuse gets smaller?\nIT WORKS!!!! HAHAHAHAHAHAHAHA I RULE!\n*/    \n\n    vec4 reflectance;\n    reflectance.a = f1;\n    reflectance.rgb = mix( vec3(f0), 8.*albedo, metallicity );\n    albedo *= 1.-metallicity;\n    \n    // shading\n        \n    // specular\n    vec3 h = normalize(toCam+toLight);\n    float hdotn = max(dot( normal, h ),.0);\n\n    float spec = .0;\n    \n    {\n//        spec = pow( abs(hdotn), power );\n\n        // experiment to fix the dark edge (unsuccessful, but it doesn't hurt anything)\n//        spec *= max(dot(h,toCam),.0)/hdotn; // weigh up facets facing camera vs edge-on facets\n        \n        // normalisation (found by fitting a curve to brute force sampled data)\n//        spec /= 1.35/(.75+power);\n//        spec /= 2./(2.+power);\n        \n        // from https://learnopengl.com/#!PBR/Theory\n        float a = roughness*roughness;\n        float d = hdotn*hdotn*(a-1.)+1.;\n        float D = a / ( d*d /*.5*tau*/ ); // think this tau/2. is (unintentionally) happening implicitly elsewhere in my algorithm\n        float F = 1.; // surely this is handled by fresnel lerp\\/?\n        float k = (roughness+1.);\n        k = k*k / 8.;\n        float G = ndoti / mix( ndoti, 1., k );\n        G *= ndotl / mix( ndotl, 1., k );\n        spec = D*F*G / (4. * ndoti);// * ndotl); - I think the dotl part is implicit in monte carlo - certainly fixes artefacts when I lose this\n    }\n    \n    vec3 fresnel = mix( reflectance.xyz, reflectance.www, pow( 1.-_ndoti, 5. ) );\n\n\treturn mix( albedo * max(.0,dot(toLight,normal)), vec3(spec), fresnel );\n}\n\n\n\nvec3 Normal( in vec3 pos )\n{\n    vec2 d = vec2(-1,1)*.0001;\n    vec3 ignore; float ignore2;\n    return normalize(\n        SDF(pos+d.xxx)*d.xxx +\n        SDF(pos+d.yyx)*d.yyx +\n        SDF(pos+d.yxy)*d.yxy +\n        SDF(pos+d.xyy)*d.xyy\n    );\n}\n\n\nvec3 Trace( in vec3 pos, in vec3 dir )\n{\n    const float e = .001;\n    const float e2 = e*2.;\n    \n    // try to push ray start out of an object\n    float t = .0;\n    \n    float h = SDF( pos );\n    if ( h < e2 )\n    {\n        vec3 n = Normal(pos);\n\t\tt += (e2-h)/max(.01,dot(dir,n));\n// think ^ this is screwing up shallow-angle reflections\n    }\n    \n    for ( int i=0; i < 500; i++ )\n    {\n        h = SDF( pos+dir*t );\n        t += h;\n        if ( h < .001 ) break;\n    }\n    \n    return pos+dir*t;\n}\n\n\nfloat TestTrace( in vec3 from, in vec3 to )\n{\n    // try to push ray start out of an object\n    float t = max( .1-SDF( from ), .0 );\n    \n    float d = .001;\n    \n    float tEnd = length(to-from) - d;\n    \n    vec3 dir = normalize(to-from);\n        \n    for ( int i=0; i < 100; i++ )\n    {\n        float h = SDF( from+dir*t );\n        t += h;\n        if ( h < d || t > tEnd ) break;\n    }\n    \n    return step( tEnd, t );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    int pass = iFrame;\n//    int pixelSeed = pass + 121*int(fragCoord.x) + 1023*int(fragCoord.y);\n    int pixelSeed = int( Rand( pass, 0 ) * 256. ) + pass*61 + int(fragCoord.x) + 1023*int(fragCoord.y);\n    \n    vec2 jitter = Rand( pixelSeed, 0 );\n    \n    vec3 ray;\n    ray.xy = (fragCoord.xy+(jitter-.5)*1.-iResolution.xy*.5)/iResolution.y;\n//    if ( max(abs(ray.x),abs(ray.y)) > .5 ) discard;\n    \n    vec3 pos = vec3(-2,1.4,-.5);\n    vec3 target = vec3(0,1.4,1); ray.z = 1.;\n\n    ray = normalize(ray);\n\n    vec3 forward = normalize(target-pos);\n    vec3 right = normalize(cross(vec3(0,1,0),forward));\n    vec3 up = cross(forward,right);\n    ray = ray.x*right + ray.y*up + ray.z*forward;\n\n    \n    // point light, fire ray in random direction\n    vec3 lightRay = SphereRand(pixelSeed,1);\n    \n\n    const int N = DEPTH;\n    vec3 viewIntersections[N], lightIntersections[N];\n    vec3 viewNormal[N], lightNormal[N];\n    vec3 viewCol[N], lightCol[N];\n    \n    viewIntersections[0] = Trace( pos, ray );\n    lightIntersections[0] = Trace( lightPos, lightRay );\n    viewNormal[0] = Normal(viewIntersections[0]);\n    lightNormal[0] = Normal(lightIntersections[0]);\n\n    vec3 lastViewDir = ray;\n    vec3 lastLightDir = lightRay;\n    vec3 viewDir = HemisphereRand(pixelSeed,0,viewNormal[0]);\n    vec3 lightDir = HemisphereRand(pixelSeed,1,lightNormal[0]);\n\n    viewCol[0] = BRDF( -lastViewDir, viewDir, viewNormal[0], viewIntersections[0] );\n    lightCol[0] = lightSourceCol * BRDF( lightDir, -lastLightDir, lightNormal[0], lightIntersections[0] );\n\n    for ( int i=1; i < N; i++ )\n    {\n    \tviewIntersections[i] = Trace( viewIntersections[i-1], viewDir );\n    \tlightIntersections[i] = Trace( lightIntersections[i-1], lightDir );\n    \tviewNormal[i] = Normal(viewIntersections[i]);\n    \tlightNormal[i] = Normal(lightIntersections[i]);\n\n        lastViewDir = viewDir;\n        lastLightDir = lightDir;\n        viewDir = HemisphereRand(pixelSeed,2*i+0,viewNormal[i]);\n        lightDir = HemisphereRand(pixelSeed,2*i+1,lightNormal[i]);\n\n        viewCol[i] = viewCol[i-1] * BRDF( -lastViewDir, viewDir, viewNormal[i], viewIntersections[i] );\n        lightCol[i] = lightCol[i-1] * BRDF( lightDir, -lastLightDir, lightNormal[i], lightIntersections[i] );\n    }\n\n    // connect every light intersection (including source) with every view intersection (excluding source)\n    vec3 col = vec3(0);\n    vec3 lastViewPos = pos;\n    vec3 lastViewCol = vec3(1,1,1);\n    for ( int i=0; i < N; i++ )\n    {\n        vec3 toView = normalize(lastViewPos - viewIntersections[i]);\n        float weight = 1./min(float(1+i),float(2*N-i)); // divide by the number of rays which have this many bounces\n        float shadow = TestTrace( viewIntersections[i], lightPos );\n        col += weight * lastViewCol * lightSourceCol * BRDF( toView, normalize(lightPos-viewIntersections[i]), viewNormal[i], viewIntersections[i] ) * shadow;\n\n        vec3 lastLightPos = lightPos;\n        vec3 lastLightCol = lightSourceCol;\n        for ( int j=0; j < N; j++ )\n        {\n            weight = 1./min(float(2+i+j),float(2*N-1-i-j)); // divide by the number of rays which have this many bounces\n            shadow = TestTrace( viewIntersections[i], lightIntersections[i] );\n\n            vec3 toLight = normalize(lightIntersections[i]-viewIntersections[i]);\n            vec3 lightColHere = lastLightCol * BRDF( -toLight, normalize(lastLightPos-lightIntersections[i]), lightNormal[i], lightIntersections[i] );\n    \n            col += weight * lastViewCol * lightColHere * BRDF( toView, toLight, viewNormal[i], viewIntersections[i] ) * shadow;\n            \n            lastLightPos = lightIntersections[i];\n            lastLightCol = lightCol[j];\n        }\n        \n        lastViewPos = viewIntersections[i];\n        lastViewCol = viewCol[i];\n    }\n\n//col = vec3(exp2(-length(pos - viewIntersections[0])));\n    \n\tfragColour = texture(iChannel0,fragCoord/iResolution.xy);\n        if ( pass == 0 ) fragColour = vec4(0);\n    fragColour.rgb += col;\n    fragColour.a += 1.;\n}\n\n\n","name":"Buf A","description":"","type":"buffer"}]}