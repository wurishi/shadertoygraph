{"ver":"0.1","info":{"id":"4lsfRr","date":"1510800692","viewed":225,"name":"DataVis","username":"c0de517e","description":"Test - WIP of palettes for data visualization","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["palette","datavis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// One dimensional, sequential data. This is similar to Viridis palette\n// The idea is to have good range by being brighness linear but still exploit color and saturation\nvec3 ColorFn1D (float x)\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\n\tfloat r = -0.121 + 0.893 * x + 0.276 * sin (1.94 - 5.69 * x);\n\tfloat g = 0.07 + 0.947 * x;\n\tfloat b = 0.107 + (1.5 - 1.22 * x) * x;\n\treturn vec3 (r, g, b);\n}\n\n// One dimensional, diverging data\nvec3 ColorFn1Ddiv (float y)\n{\n\ty = clamp (y, -1.0, 1.0); // optional\n\t\n#if 0\n\tfloat r = 0.569 + (0.396 + 0.834 * y) * sin (2.15 + 0.93 * y);\n\tfloat g = 0.911 + (-0.06 - 0.863 * y) * sin (0.181 + 1.3 * y);\n\tfloat b = 0.939 + (-0.309 - 0.705 * y) * sin (0.125 + 2.18 * y);\n#else // This one is more similar to ColorFn1D, if one cares:\n\tfloat r = 0.484 + (0.432 - 0.104*y)*sin(1.29 + 2.53*y);\n\tfloat g = 0.334 + (0.585 + 0.00332*y)*sin(1.82 + 1.95*y);\n\tfloat b = 0.517 + (0.406 - 0.0348*y)*sin(1.23 + 2.49*y);\n#endif\n\treturn vec3 (r, g, b);\n}\n\n// One dimensional, sequential data, two categories\nvec3 ColorFn1DtwoC (float x, int c)\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\t\n\tfloat r, g, b;\n\tif (c == 0)\n\t{\n\t\tr = max (0.0, -0.724 + (2.52 - 0.865*x)*x);\n\t\tg = 0.315 + 0.589*x;\n\t\tb = x > 0.464 ? (0.302*x + 0.641) : (1.27*x + 0.191);\n\t}\n\telse\n\t{\n\t\tr = min (1.0, 0.5 + 1.36*x);\n\t\tg = max (0.0, -0.5 + (2.31 - 0.878*x)*x);\n\t\tb = 0.142 + 0.539*x*x*x;\n\t}\n\treturn vec3 (r, g, b);\n}\n\nvec3 ColorFn1DfiveC (float x, int c) // One dimensional, sequential data, up to five categories\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\t\n\tfloat r, g, b;\n\tswitch (c)\n\t{\n\t\tcase 1 :\n\t\tr = 0.22 + 0.71*x; g = 0.036 + 0.95*x; b = 0.5 + 0.49*x;\n\t\tbreak;\n\n\t\tcase 2 :\n\t\tr = 0.63 + 0.47*x; g = 0.1 + 0.8*x; b = 0.64*x;\n\t\tr = 0.48 + x * (1.7 + (-1.8 + 0.56 * x) * x);\n\t\tb = x * (-0.21 + x);\n\t\tbreak;\n\n\t\tcase 3 :\n\t\tr = 0.85*x; g = 0.33 + 0.69*x; b = 0.059 + 0.78*x;\n\t\tr = x * (-0.21 + (2.6 - 1.5 * x) * x);\n\t\tbreak;\n\n\t\tcase 4 :\n\t\tr = 0.83*x; g = 0.22 + 0.75*x; b = 0.52 + 0.5*x;\n\t\tr = 0.033 + x * (-0.35 + (2.7 - 1.5 * x) * x);\n\t\tb = 0.45 + (0.97 - 0.46 * x) * x;\n\t\tbreak;\n\n\t\tdefault :\n\t\tr = g = b = 0.025 + 0.96*x;\n\t}\n\treturn vec3 (r, g, b);\n}\n\n// One dimension is sequential, the other diverging - EXPERIMENTAL\nvec3 ColorFn2Ddiv (float x, float div)\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\tdiv = clamp (div, -1.0, 1.0); // optional\n\n#if 0\n\tdiv = div * 0.5 + 0.5;\n\tfloat r1 = (0.0812 + (0.479 + 0.267) * x) * div;\n\tfloat g1 = (0.216 + 0.407 * x) * div;\n\tfloat b1 = (0.323 + 0.679 * x) * div;\n\n\tdiv = 1.0 - div;\n\tfloat r2 = (0.0399 + (0.391 + 0.196) * x) * div;\n\tfloat g2 = (0.232 + 0.422 * x) * div;\n\tfloat b2 = (0.0910 + (0.137 - 0.213) * x) * div;\n    \n    return vec3(r1, g1, b1) + vec3(r2, g2, b2);\n#else\n    float r = 0.651 + (-0.427 - 0.138*div) * sin(0.689 + 1.95*div);\n    float g = 0.713 + 0.107*div - 0.0565*div*div;\n    float b = 0.849 - 0.13*div - 0.233*div*div;\n    \n    return vec3 (r, g, b) * (x * 0.7 + 0.3);\n#endif\n}\n\nvec3 ColorFn2D (float x, float y) // Two sequential dimensions - EXPERIMENTAL\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\ty = clamp (abs (y), 0.0, 1.0); // optional\n\n#if 0\n\tfloat r = x;\n\tfloat g = 0.5*(x + 0.6)*y;\n\tfloat b = y;\n#else\n    x = x < 0.0433 ? 1.37 * x : x * (0.194 * x + 0.773) + 0.0254;\n\ty = y < 0.0433 ? 1.37 * y : y * (0.194 * y + 0.773) + 0.0254;\n    \n\tfloat r = x;\n\tfloat g = 0.6 * y;\n\tfloat b = 0.0;\n#endif\n\n\treturn vec3 (r, g, b);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime;\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tfloat plas;\n\tfloat p2 = 0.0;\n\n\tif (p.y <= 0.05) plas = p.x*2.0 - 1.0;\n\telse if (p.y <= 0.1) plas = p.x;\n\telse if (p.y <= 0.15) { plas = -p.x; p2 = 1.0; }\n\telse\n\t{\n\t\tp *= 0.25;\n\t\tfloat part1 = sin (p.x*(90.0 + 21.0*cos (p.y*0.0)) + time);\n\t\tfloat part2 = cos (p.y*(32.0 + 11.0*sin (p.x*57.0)) + time);\n\t\tfloat part3 = sin (p.x*(55.0 + 21.0*sin (p.y*32.0)) + time);\n\t\tplas = 0.5 + 0.65*part1*part2 + 0.35*part3*part2;\n\n\t\tp2 = sin (p.x*(30.0 + 20.0*cos (p.y*7.0)) + time);\n\t\tp2 *= cos (p.x*(20.0 + 50.0*sin (p.y*7.0)) + time);\n\t\tp2 += 0.25 * sin (p.x*(40.0 + 70.0*sin (p.y*7.0)) + time);\n\t}\n\n#if 0\n\tfragColor = vec4 (ColorFn2D (plas, p2), 1.0);\n#elif 0\n\tfragColor = vec4 (ColorFn2Ddiv (plas, p2*2.0 - 1.0), 1.0);\n#elif 0\n\tfragColor = vec4 (ColorFn1DfiveC (plas, int (p2*4.5)), 1.0);\n#elif 1\n\tfragColor = vec4 (ColorFn1DtwoC (plas, int (p2*2.0)), 1.0);\n#elif 0\n\tfragColor = vec4 (ColorFn1Ddiv (plas), 1.0);\n#else\n\tfragColor = vec4 (ColorFn1D (plas), 1.0);\n#endif\n}","name":"Image","description":"","type":"image"}]}