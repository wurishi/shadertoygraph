{"ver":"0.1","info":{"id":"fsyfWt","date":"1658970848","viewed":112,"name":"Wave Eq 7 - PML absorbers","username":"athibaul","description":"Simple implementation of Perfectly Matched Layers for the acoustic equation. They absorb VERY well.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["wave","acoustic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementing FDTD perfectly matched layers\n// for acoustics\n// as described in\n//\n// Yuan, X., Borup, D., Wiskin, J. W., Berggren, M., \n// Eidens, R., & Johnson, S. A. (1997). Formulation \n// and validation of Berenger's PML absorbing boundary \n// for the FDTD simulation of acoustic scattering. \n// IEEE transactions on ultrasonics, ferroelectrics, \n// and frequency control, 44(4), 816-822.\n//\n// These perfectly matched layers absorb incident waves\n// extremely well, even at steep incidence angles.\n// We put them all around our domain, in order to avoid\n// having any waves reflected back into our simulation\n// (virtually infinite domain).\n\n\nvoid mainImage( out vec4 fragColor, in vec2 coo )\n{\n    vec2 uv = (2.*coo - iResolution.xy)/iResolution.y;\n    vec4 P = texelFetch(iChannel0, ivec2(coo), 0);\n    float p = P.x + P.y;\n    //fragColor = clamp(vec4(p) * 1., 0., 1.);\n    fragColor = clamp(abs(p) + p*vec4(0.7,0.2,-0.7,0.), 0., 1.);\n    //fragColor = clamp(vec4(p) * 100., 0., 1.); // to see reflections better\n    \n    if(pressureSource(uv,0.).y > 0.\n       || rho_at(coo,iResolution.xy) > 1.)\n        fragColor = mix(fragColor, vec4(0,0,1,0), 0.5);\n    \n    if(alphax_at(coo, iResolution.xy) > 0.) // x-direction PML\n        fragColor = mix(fragColor, vec4(1,0,0,0), 0.5);\n    \n    if(alphay_at(coo, iResolution.xy) > 0.) // y-direction PML\n        fragColor = mix(fragColor, vec4(0,1,0,0), 0.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Px(ij) texelFetch(iChannel0, ij, 0).x\n#define Py(ij) texelFetch(iChannel0, ij, 0).y\n#define Ux(ij) texelFetch(iChannel1, ij, 0).x\n#define Uy(ij) texelFetch(iChannel1, ij, 0).y\n#define R ivec2(iResolution)\n\nvoid mainImage( out vec4 fragColor, in vec2 coo )\n{\n\n    vec2 uv = (2.*coo - iResolution.xy)/iResolution.y;\n    ivec2 ij = ivec2(coo);\n    ivec2 di = ivec2(1,0), dj = ivec2(0,1);\n    \n    if(iFrame == 0 || texelFetch(iChannel0, ivec2(0), 0).w != iResolution.x)\n    {\n        float p0 = 0.; //sin(12.*3.1416*coo.x/iResolution.x) * sin(7.*3.1416*coo.y/iResolution.y);\n        //float p0 = 0.5*smoothstep(0.95,0.9,length(uv));\n        fragColor = vec4(0.5*p0, 0.5*p0, 0, iResolution.x);\n        return;\n    }\n    \n    float alphax = alphax_at(vec2(ij), iResolution.xy);\n    float alphay = alphay_at(vec2(ij), iResolution.xy);\n    float Delta = 1.;\n    float c_max = 1.;\n    float h = Delta / (2. * c_max);\n    float kappa = 1.;\n    \n    \n    float e1x = (alphax > 0.) ? exp(-alphax*h/kappa) : 1.;\n    float e2x = (alphax > 0.) ? ((1. - e1x)/(Delta * alphax)) : (h/(Delta*kappa));\n    float px_np1 = Px(ij) * e1x - e2x * (Ux(ij) - Ux(ij-di));\n    //float px_np1 = Px(ij) - 0.5 * (Ux(ij) - Ux(ij-di));\n    \n    float e1y = (alphay > 0.) ? exp(-alphay*h/kappa) : 1.;\n    float e2y = (alphay > 0.) ? ((1. - e1y)/(Delta * alphay)) : (h/(Delta*kappa));\n    float py_np1 = Py(ij) * e1y - e2y * (Uy(ij) - Uy(ij-dj));\n    //float py_np1 = Py(ij) - 0.5 * (Uy(ij) - Uy(ij-dj));\n    \n    vec2 ps = pressureSource(uv, float(iFrame));\n    \n    if(iMouse.z > 0.)\n    {\n        float d = length(coo - iMouse.zw);\n        float source = smoothstep(30., 0.0, d);\n        px_np1 += source;\n        py_np1 += source;\n    }\n    \n    if(   ij.x == 0     || ij.y == 0 \n       || ij.x == R.x-1 || ij.y == R.y-1)\n    {\n        // Zero pressure on boundary\n        fragColor = vec4(0, 0, 0, iResolution.x);\n    }\n    else if(ps.y > 0.)\n    {\n        fragColor = vec4(ps.x*0.5, ps.x*0.5, 0, iResolution.x);\n    }\n    else\n    {\n        fragColor = vec4(px_np1, py_np1, 0, iResolution.x);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define Px(ij) texelFetch(iChannel0, ij, 0).x\n#define Py(ij) texelFetch(iChannel0, ij, 0).y\n#define Ux(ij) texelFetch(iChannel1, ij, 0).x\n#define Uy(ij) texelFetch(iChannel1, ij, 0).y\n#define R ivec2(iResolution)\n\nvoid mainImage( out vec4 fragColor, in vec2 coo )\n{\n    \n    ivec2 ij = ivec2(coo);\n    ivec2 di = ivec2(1,0), dj = ivec2(0,1);\n\n    if(iFrame == 0 || texelFetch(iChannel1, ivec2(0),0).w != iResolution.x)\n    {\n        fragColor = vec4(0,0,0,iResolution.x);\n        return;\n    }\n\n    float Delta = 1.;\n    float c_max = 1.;\n    float h = Delta / (2. * c_max);\n    float kappa = 1.;\n    float rhox = rho_at(vec2(ij) + vec2(0.5,0), iResolution.xy),\n          rhoy = rho_at(vec2(ij) + vec2(0,0.5), iResolution.xy); // shifted density values\n    float gammax = alphax_at(vec2(ij) + vec2(0.5,0), iResolution.xy) / kappa,\n          gammay = alphay_at(vec2(ij) + vec2(0,0.5), iResolution.xy) / kappa;\n\n    \n    float e3x = (gammax > 0.) ? exp(-gammax*h) : 1.;\n    float e4x = (gammax > 0.) ? ((1. - e3x)/(Delta * rhox * gammax)) : (h/(Delta*rhox));\n    float ux_np1 = Ux(ij) * e3x - e4x * (Px(ij+di) - Px(ij) + Py(ij+di) - Py(ij));\n    \n    float e3y = (gammay > 0.) ? exp(-gammay*h) : 1.;\n    float e4y = (gammay > 0.) ? ((1. - e3y)/(Delta * rhoy * gammay)) : (h/(Delta*rhoy));\n    float uy_np1 = Uy(ij) * e3y - e4y * (Px(ij+dj) - Px(ij) + Py(ij+dj) - Py(ij));\n    \n    fragColor = vec4(ux_np1, uy_np1, 0, iResolution.x);\n \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define sqr(x) (x)*(x)\n\nconst float alphamax = 2.3;\nconst float m = 8.; // PML thickness\n\n// ---- Hash function by Dave Hoskins -- we use it to generate noise\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(float t)\n{\n    float it = floor(t), ft = fract(t);\n    ft = smoothstep(0.,1.,ft);\n    return mix(hash11(it), hash11(it+1.), ft);\n}\n\n// -----------------\n\n\n\nvec2 pressureSource(vec2 uv, float iF)\n{\n\n    // pressureSource(uv).y is 1 if we impose pressure at that point\n    // .x is the value\n    \n    if(length(uv - vec2(-0.5,0.7)) < 0.05)\n    //if(length(uv - vec2(-0.1,0.6)) < 0.05)\n        //return vec2(1.*sin(iF*0.2), 1.);\n        //return vec2(10.*smoothstep(0.,10.,iF)*smoothstep(20.,10., iF), 1);\n        //return vec2(2.*sin(iF*0.2)*sqr(sqr(cos(iF*0.0162))), 1.);\n        return vec2(5.*(noise(iF*0.1)-0.5) * smoothstep(0.,20.,iF), 1.);\n    \n    return vec2(0);\n}\n\nfloat alphax_at(vec2 coo, vec2 iResolution)\n{\n    float xdist2wall = min(coo.x, iResolution.x - coo.x);\n    xdist2wall = min(xdist2wall, m);\n    return alphamax * sqr((m-xdist2wall)/m);\n}\n\nfloat alphay_at(vec2 coo, vec2 iResolution)\n{\n    float ydist2wall = min(coo.y, iResolution.y - coo.y);\n    ydist2wall = min(ydist2wall, m);\n    return alphamax * sqr((m-ydist2wall)/m);\n}\n\nfloat rho_at(vec2 coo, vec2 iResolution)\n{\n    vec2 uv = (2.*coo - iResolution)/iResolution.y;\n    \n    \n    // Add an obstacle, so that the visuals are somewhat interesting\n    vec2 q = uv;\n    vec2 q2 = abs(q);\n    //vec2 q3 = abs(q-vec2(0,0.05));\n    //if(max(q2.x,q2.y) < 0.4 && max(q3.x, q3.y) > 0.35)\n        //return 4.;\n        \n    vec2 q3 = abs(q-vec2(0,0.2));\n    if(length(q2) < 0.5 && max(q3.x-0.35, q3.y-0.4) > 0.)\n        return 2.;\n    \n    return 1.;\n    \n}\n","name":"Common","description":"","type":"common"}]}