{"ver":"0.1","info":{"id":"wttBzj","date":"1613090349","viewed":135,"name":"Lovely Cup","username":"marcelfernandez13","description":"This was inspired in a real cup that I have in my home. One day I was having breakfast and \nI looked to to the cup and I said: \"Why not?\". And here is the result. :)\n\nYou can use the \"Shader Configuration\" section to play with the shader.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","ambientocclusion","sphericalharmonics","texturemapping","pbr","cup"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------------\n// Lovely Cup - 2021 Marcel Fernandez\n// \n// This was inspired in a real cup that I have in my home. One day I was having breakfast and \n// I looked to to the cup and I said: \"Why not?\". And here is the result. :)\n//\n// My inspiration: https://drive.google.com/file/d/1jXmxIvEJTQo_jkJ9B0XvcHxwaC1gkfue/view?usp=sharing\n// \n// Move the mouse to control the camera. You can also \n// use the \"Shader Configuration\" section to play with the shader.\n//\n// Techniques used:\n// - Ray marching\n// - PBR based rendering (Ambient Oclussion, environment mapping, reflections, Spherical Harmonics, etc)\n// - Procedural texture generation\n// - Texture mapping\n//\n// ------------------------------------------------------------------------------------------\n \n \n#define PI 3.14159265358979323846264338327950288\n#define DEG_TO_RAD (PI / 180.0)\n\n#define MAX_STEPS 1000\n#define MAX_DISTANCE 1000.0\n#define SURFACE_DIST 0.0001\n\n#define NO_HIT           0\n#define CUP_OUTER_HIT    1\n#define CUP_INNER_HIT    2\n#define CUP_HANDLE_HIT   3\n#define BASE_HIT         4\n\n#ifndef saturate\n    #define saturate(val) clamp(val, 0.0, 1.0)\n#endif\n\n// #define TEXTURE_MODE\n\n\n// -------------------- Shader Configuration -------------------\n// Cup\nconst float kCupRadius = 1.5;\nconst float kCupThickness = 0.03;\n\nconst vec3  kHandlePos = vec3(1.9, 3.15, 0);\nconst float kHandleRadius = 0.5;\nconst float kHandleInnerRadius = 0.11;\nconst float kHandleScale = 0.55;               // To compress the handle\n\n// Camera\nconst float kCameraFov = 30.0 * DEG_TO_RAD;\nconst vec3  kCameraOrigin = vec3(0.0, 4.5, -11.0);\nconst vec3  kCameraLookAtPoint = vec3(0, 1.9, 0);\n\n// Illumination\n\nconst vec3 kLightColor = vec3(1.0);\nconst vec3 kLightPos = vec3(1., 0.9, 0.0);\n\nconst float kAmbientOclussionFactor = 16.0;\nconst float kShadowAttenuation = 0.6;\n\n// -------------------------------------------------------------\n\n// Structs\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct RayHit {\n    float dist;\n    vec3 dir;\n    vec3 point;\n    vec3 normal;\n    int objectId;\n};\n\nRayHit ConstructRayHit() {\n    RayHit hit;\n    hit.dist = MAX_DISTANCE;\n    hit.dir = hit.point = hit.normal = vec3(0);\n    hit.objectId = NO_HIT;\n\n    return hit;\n}\n\nRayHit ConstructRayHit(float dist, int objectId) {\n    RayHit hit = ConstructRayHit();\n    hit.dist = dist;\n    hit.objectId = objectId;\n\n    return hit;\n}\n\n// Auxiliar Functions\n\nvec3 gammaToLinear(in vec3 c) {\n    return pow(c, vec3(2.2));\n}\n\nvec3 linearToGamma(in vec3 c) {\n    return pow(c, vec3(0.45));\n}\n\nvec3 packedNormal(vec3 normal) {\n    return (normal + 1.0) * 0.5;\n}\n\nmat2 rotMat(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat2(c, -s, s, c);\n}\n\nfloat pow2(in float val) {\n    return val * val;\n}\n    \nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Taken from https://www.shadertoy.com/view/ll2GD3\nvec3 genColor(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nRayHit S(RayHit obj1, RayHit obj2) {\n    if (obj1.dist > -obj2.dist) {\n        return obj1;\n    } else if (obj1.dist < -obj2.dist) {\n        obj2.dist *= -1.0;\n        return obj2;\n    }\n    \n    return obj1;\n}\n\nRayHit U(RayHit obj1, RayHit obj2) {\n    if (obj1.dist > obj2.dist) {\n        return obj2;\n    } else if (obj1.dist < -obj2.dist) {\n        return obj1;\n    }\n    \n    return obj1;\n}\n\nRayHit SmoothUnion(RayHit hit1, RayHit hit2, float k) {\n    float smoothMin = smin(hit1.dist, hit2.dist, k);\n\n    if (hit1.dist < hit2.dist) {\n        hit1.dist = smoothMin;\n        return hit1;\n    } else {\n        hit2.dist = smoothMin;\n        return hit2;\n    }\n}\n\n// St. Peter's Basilica Spherical Harmonics\n// https://www.shadertoy.com/view/lt2GRD\nstruct SHCoefficients\n{\n\tvec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients SH_STPETER = SHCoefficients(\n\tvec3(0.3623915, 0.2624130, 0.2326261),\n\tvec3(0.1759131, 0.1436266, 0.1260569),\n\tvec3(-0.0247311, -0.0101254, -0.0010745),\n\tvec3(0.0346500, 0.0223184, 0.0101350),\n\tvec3(0.0198140, 0.0144073, 0.0043987),\n\tvec3(-0.0469596, -0.0254485, -0.0117786),\n\tvec3(-0.0898667, -0.0760911, -0.0740964),\n\tvec3(0.0050194, 0.0038841, 0.0001374),\n\tvec3(-0.0818750, -0.0321501, 0.0033399)\n);\n\nvec3 SHIrradiance(vec3 nrm)\n{\n\tconst SHCoefficients c = SH_STPETER;\n\tconst float c1 = 0.429043;\n\tconst float c2 = 0.511664;\n\tconst float c3 = 0.743125;\n\tconst float c4 = 0.886227;\n\tconst float c5 = 0.247708;\n\treturn (\n\t\tc1 * c.l22 * (nrm.x * nrm.x - nrm.y * nrm.y) +\n\t\tc3 * c.l20 * nrm.z * nrm.z +\n\t\tc4 * c.l00 -\n\t\tc5 * c.l20 +\n\t\t2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\n\t\t2.0 * c1 * c.l21  * nrm.x * nrm.z +\n\t\t2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\n\t\t2.0 * c2 * c.l11  * nrm.x +\n\t\t2.0 * c2 * c.l1m1 * nrm.y +\n\t\t2.0 * c2 * c.l10  * nrm.z\n\t\t);\n}\n\n// Surface dist functions\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float radius) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n\n    float t = dot(ap, ab) / dot(ab, ab);\n    vec3 c = a + t * ab;\n\n    float x = length(p - c) - radius;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float externalDist = length(max(vec2(x, y), 0.0));\n    float iteriorDist = min(max(x, y), 0.0);\n\n    // The ray marchers an aproximation to the distance. \n    // So, sometimes the distance cooresponds to a point inside\n    // the cylinder.\n\n    return externalDist + iteriorDist;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float radius) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    vec3 c = a + t * ab;\n\n    return length(p - c) - radius;\n}\n\nfloat sdTorus(vec3 p, float mainRadius, float secRadius) {\n    float x = length(p.xz) - mainRadius;\n    return length(vec2(x, p.y)) - secRadius;\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float radius) {\n     return length(p - pos) - radius; \n}\n\n// Camera functions\n\nRay cameraLookAt(in vec2 uv, in vec3 o, in vec3 d)\n{\n    vec3 forward = normalize(d - o);\n    vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up      = normalize(cross(right, forward));\n\n    uv = (uv * 2.0) - 1.0;\n\n    float u = tan(kCameraFov) * distance(o, d);\n    float v = u * (iResolution.y / iResolution.x);\n\n    return Ray(o, normalize(d + (uv.x * u * right) + (uv.y * v * up) - o));\n}\n\n// Raymarching func\n\nRayHit map(in vec3 p) {\n    vec3 a = vec3(0);        // Upper Point\n    vec3 b = vec3(0, -0.1, 0); // Lower Point\n    RayHit baseHit = ConstructRayHit(sdCylinder(p, a, b,  kCupRadius + 2.0), BASE_HIT);\n    \n    a = vec3(0, 4, 0);\n    b = vec3(a.x, 0, a.z);\n\n    float bodyDelta = pow2(smoothstep(0.9, 1.0, clamp(p.y / a.y, 0.0, 1.0)));\n    float cupRadius = kCupRadius + (bodyDelta * 0.07);\n\n    RayHit cupOuterHit = ConstructRayHit(sdCylinder(p, a, b, cupRadius), CUP_OUTER_HIT);\n    RayHit cupInnerHit = ConstructRayHit(sdCylinder(p, vec3(0, 5, 0), vec3(0, 0.1, 0), cupRadius - kCupThickness), CUP_INNER_HIT);\n\n    RayHit cupHit = S(cupOuterHit, cupInnerHit);\n    \n    // Handle\n    float y = clamp(p.y, 0.7, kHandlePos.y);\n    float handleDelta = 1.0 - clamp((y / kHandlePos.y), 0.0, 1.0);\n    \n    vec3 p2 = p;\n    // This defines the handle curve\n    handleDelta = smoothstep(0.05, .8, handleDelta);\n    float offset = 2.0 * kHandleRadius * handleDelta;\n    p2.x += offset;\n    p2.z *= kHandleScale;\n\n    \n    a = vec3(kHandlePos.x + kHandleRadius, kHandlePos.y, 0);\n    b = vec3(a.x, 0.7, a.z);\n\n    RayHit capsuleHit = ConstructRayHit(sdCapsule(p2, a, b, kHandleInnerRadius), CUP_HANDLE_HIT);\n    \n    p = p - kHandlePos;\n    p.yz *= rotMat(PI * 0.5);\n    p.y *= kHandleScale;\n\n    RayHit handleHit = ConstructRayHit(sdTorus(p, 0.5, kHandleInnerRadius), CUP_HANDLE_HIT);\n    RayHit sphereHit =  ConstructRayHit(sdSphere(p, vec3(-0.5, 0, 0), kHandleInnerRadius), CUP_HANDLE_HIT);\n    \n    // I want to cut the torus lower part\n    // z because is rotated\n    if (p.z < kHandlePos.z) {\n        handleHit.objectId = NO_HIT;\n        handleHit.dist = MAX_DISTANCE;\n    }\n\n    handleHit = U(handleHit, sphereHit);\n    handleHit = U(handleHit, capsuleHit);\n\n    cupHit = SmoothUnion(handleHit, cupHit, 0.27);\n\n    return U(cupHit, baseHit);\n}\n\n// The idea of this is move p in the normal direction. Trying to find a \n// smaller minimum surface distance. If it's found, means that you hace a closer\n// surface \nfloat AO(in RayHit hit)\n{\n\tfloat ao = 0.0;\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\tfloat off = 0.001 + 0.2 * float(i) / 5.;\n\t\tfloat t = map(hit.normal * off + hit.point).dist;\n\t\tao += (off - t) * s;\n\t\ts *= 0.4;\n\t}\n\n    ao *= kAmbientOclussionFactor;\n\n\treturn smoothstep(0.0, 1.0, (1.0 - ao));\n}\n\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv)\n{\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\n\n// PBR \nvec3 fresnel(in vec3 specularColor, in float vdoth)\n{\n\tvec3 fresnel = specularColor + (1.0 - specularColor) * pow((1.0 - vdoth), 5.0);\n\treturn fresnel;\n}\n\nfloat distribution(in float roughness, in float ndoth)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat visibility(in float roughness, in float ndotv, in float ndotl)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\nvec3 getNormal(in RayHit hit) {\n    vec3 p = hit.point;\n    float d = map(p).dist;\n    \n    // This is a delta to calculate a very closer point to p.\n    // Then you can get the normal vector\n    vec2 e = vec2(0.001, 0);\n\n    vec3 normal = d - vec3(map(p - e.xyy).dist,\n                           map(p - e.yxy).dist,\n                           map(p - e.yyx).dist);\n\n    return normalize(normal);\n}\n\nRayHit march(in Ray ray) {\n    // Distance to the object\n    float dO = 0.1;\n    int objectId = NO_HIT;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ray.origin + (dO * ray.dir);\n        RayHit hit = map(p);\n        \n        if (abs(hit.dist) < SURFACE_DIST) {\n            objectId = hit.objectId;\n            break;\n        } else if (dO >= MAX_DISTANCE) {\n            objectId = NO_HIT;\n            break;\n        }\n\n        dO += hit.dist;\n    }\n\n    // Construct hit struct\n    RayHit hit = ConstructRayHit();\n    hit.dist = dO;\n    hit.point = ray.origin + dO * ray.dir;\n    hit.normal = getNormal(hit);\n    hit.dir = ray.dir;\n    hit.objectId = objectId;\n    \n    return hit;\n}\n\n// Procedural texture methods\n// UV input from 0 to 1\n\nvec4 renderCupHandleTex(in vec3 n) {\n    vec3 col = vec3(0);\n    float alpha = 0.0;\n\n    if (n.x > 0.0) {\n        float handleLineWidth = 0.35;\n        vec3 handleColor = vec3(0.3, 0.24, 0.8);\n        alpha = smoothstep(handleLineWidth + 0.03, handleLineWidth - 0.03, abs(n.z));\n        col += alpha * handleColor;\n    }\n\n    return vec4(col, alpha);\n}\n\nvec3 renderCupBodyTex(in vec2 uv) {\n    vec3 col = vec3(0);\n    vec3 backGroundColor = vec3(0);\n    vec3 circleColor = vec3(0);\n\n    // Devide screen in 8 tiles. 4 x 2 \n    vec2 newUV = uv * vec2(4.0, 2.0);\n    float tileId = trunc(newUV.x) + trunc(newUV.y) * 4.0;\n    newUV = fract(newUV);\n    \n    // Move (0,0) to the meddle\n    newUV -= 0.5;\n\n    // Circle \n    float circleRadius = 0.12;\n    vec3 circleMaskAlpha = 1.0 - vec3(smoothstep(circleRadius - 0.004, circleRadius + 0.004, length(newUV)));\n\n    // Sample the middle color of the gradient generated by genColor.\n    // use colorT = uv.x to see the gradient\n    float colorT = float(tileId) / 4.0;\n\n    if (tileId > 3.) {\n        backGroundColor = genColor(colorT, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n    } else {\n        backGroundColor = genColor(colorT + 0.5, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    }\n    \n    circleColor = genColor(colorT + 0.2, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20));\n    \n    // Transform uv coord to polar coordinates in order to generate \n    // petals circular pattern\n    vec2 polarCoordsUvs = newUV;\n    polarCoordsUvs = vec2(atan(polarCoordsUvs.x, polarCoordsUvs.y), length(polarCoordsUvs));\n    \n    // Because atan return values from -PI to PI, to convert this to\n    // 0 to 1 we do this\n    polarCoordsUvs = vec2(polarCoordsUvs.x / (2. * PI) + 0.5, polarCoordsUvs.y);\n    \n    vec2 petalsUvs = (polarCoordsUvs) * 20.0;\n    float petalId = trunc(petalsUvs.x);\n    \n    // Puts the highest point in the middle of each petal\n    petalsUvs.x += 0.5;\n    \n    float m = 1.0 - (pow2(min(fract(petalsUvs.x), fract(1.0 - petalsUvs.x))) * 2.0);\n    \n    float petalLenght = 11.2 + N2(vec2(petalId + tileId)) * 2.;\n    float petalVal = step(0.5, petalsUvs.y) * smoothstep(0.4, 0.85, m * petalLenght - petalsUvs.y - 3.5);\n    \n    col = saturate(backGroundColor + vec3(petalVal));\n    col = mix(col, circleColor, circleMaskAlpha.r);\n\n    return col;\n}\n\nvec3 renderScene(RayHit hit) {\n    vec3 col = vec3(0);\n\n    float roughness = 0.3;\n    float roughnessSquare = pow2(roughness);\n    vec3 albedo = vec3(0.85);\n    vec3 diffuse = vec3(0);\n\tvec3 specular = vec3(0);\n\n\tvec3 lightDir = normalize(kLightPos);\n\n    vec3 viewDir = -hit.dir;\n\tvec3 refl = reflect(hit.dir, hit.normal);\n\n    vec3 halfVec = normalize(viewDir + lightDir);\n    float vdoth  = saturate(dot(viewDir, halfVec));\n    float ndoth  = saturate(dot(hit.normal, halfVec));\n    float ndotv  = saturate(dot(hit.normal, viewDir));\n    float ndotl  = saturate(dot(hit.normal, lightDir));\n\n    float shadowFactor = 1.0;\n\n    // Circular projection\n    vec2 uv = vec2(atan(hit.point.x, hit.point.z), hit.point.y);\n    uv = vec2(uv.x / (2.0 * PI) + 0.5, uv.y / 4.);\n    \n    if (hit.objectId == CUP_OUTER_HIT) {\n        albedo = renderCupBodyTex(uv);\n\n    } else if (hit.objectId == CUP_HANDLE_HIT && hit.point.x > kHandlePos.x) {\n        vec4 handleColor = renderCupHandleTex(hit.normal);\n        albedo = mix(albedo, handleColor.rgb, handleColor.a);\n\n    } else if (hit.objectId == BASE_HIT) {\n        albedo = vec3(0.2);\n        roughness = roughnessSquare = 0.0;  \n\n        // Cup replection\n        Ray reflRay = Ray(hit.point, refl);\n        RayHit cupHit = march(reflRay);\n        vec4 reflCol = vec4(0);\n\n        if (cupHit.objectId == CUP_OUTER_HIT) {\n            vec2 uv = vec2(atan(cupHit.point.x, cupHit.point.z), cupHit.point.y);\n            uv = vec2(uv.x / (2.0 * PI) + 0.5, uv.y / 4.);\n            reflCol = vec4(renderCupBodyTex(uv), 1.0);\n\n        } else if (cupHit.objectId == CUP_HANDLE_HIT) {\n            vec3 handleCol =vec3(0.85);\n            reflCol = cupHit.point.x > kHandlePos.x ? renderCupHandleTex(cupHit.normal) : vec4(0);\n            reflCol = vec4(mix(handleCol, reflCol.rgb, reflCol.a), 1.0);\n        }\n\n        albedo = mix(albedo, albedo * reflCol.rgb, reflCol.a * 0.7);\n\n        // Process shadow\n        Ray shadowRay = Ray(hit.point, lightDir);\n        RayHit shadow = march(shadowRay);\n        if (shadow.dist < length(kLightPos - hit.point)) {\n            shadowFactor = kShadowAttenuation;\n        }\n    }\n\n    albedo = gammaToLinear(albedo);\n\n    // Apply spherical harmonics ambient illumination\n    diffuse += albedo * shadowFactor *  gammaToLinear(SHIrradiance(hit.normal) * 2.0);\n    \n    // Apply diffuse illumination\n    diffuse += albedo * kLightColor * shadowFactor * saturate(dot(hit.normal, lightDir));\n\n    // Apply Ambient Occlussion\n    float ao = AO(hit);\n    diffuse *= ao;\n\n    vec3 specularColor = EnvBRDFApprox(vec3(0.0), roughnessSquare, ndotv);\n    \n    // Env maps\n    vec3 env = gammaToLinear(2.0 * texture(iChannel0, refl).rgb);\n    vec3 envBlured = gammaToLinear(2.0 * texture(iChannel1, refl).rgb);\n    vec3 env2 = gammaToLinear(SHIrradiance(refl));\n    vec3 finalEnv = mix(env, envBlured, saturate(4.0 * roughnessSquare));\n    finalEnv = mix(finalEnv, env2, saturate((roughnessSquare - 0.25) / 0.75));\n\n    specular += specularColor * finalEnv;\n    \n    vec3  F = fresnel(specularColor, vdoth);\n    float D = distribution(roughness,  ndoth);\n    float V = visibility(roughness, ndotv, ndotl);\n    specular += kLightColor * F * D * V * PI * ndotl;\n    specular *= saturate(pow(ndotv + ao, roughnessSquare) - 1.0 + ao);\n\n    col = diffuse + specular;\n\n    return col;\n}\n\nvec3 render(RayHit hit) {\n    vec3 col = vec3(0.4);\n\n    if (hit.objectId == NO_HIT) {\n        col = gammaToLinear(texture(iChannel0, hit.dir).rgb);\n    } else {\n        col = renderScene(hit);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0);\n\n    #ifdef TEXTURE_MODE\n        col = renderCupBodyTex(fragCoord / iResolution.xy);\n    #else    \n        vec3 camOrig = kCameraOrigin;\n        float delta = iTime * 0.3;\n\n        if (iMouse.z > 0.0) {\n            delta = (iMouse.x / iResolution.x) * 2.0 * PI;  \n        }\n\n        camOrig.xz *= rotMat(delta);\n\n        Ray ray = cameraLookAt(uv, camOrig, kCameraLookAtPoint);\n        RayHit hit = march(ray);\n        col = render(hit); \n        \n    #endif\n\n    vec2 centeredUv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float dist = length(centeredUv);\n    float vignette = clamp((1.0 - dist) / 0.95, 0.0, 1.0);\n    col *= vignette;\n\n    col = linearToGamma(col);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}