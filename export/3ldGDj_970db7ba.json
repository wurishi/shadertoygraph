{"ver":"0.1","info":{"id":"3ldGDj","date":"1577827492","viewed":87,"name":"andalousia","username":"dinialo","description":"First shader experimentation","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["animation","rotation","mosaic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Adapted from https://iquilezles.org/articles/distfunctions */\nfloat sdTriPrism(vec3 p, vec2 h) {\n    vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5) - 0.01;   \n}\n\nfloat sdCube(vec3 p, float r, float isoSurface) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d,0.0)) - isoSurface;    \n}\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\n/**\n * Models/Objects\n */\nvec2 map(in vec3 position)\n{\n    // add support mouse rotation\n    vec4 mouse = normalize(iMouse);\n    float theta = sqrt((iMouse.x)*10.0)/10.0 + iTime; \t\n    float alpha = sqrt((iMouse.y)*10.0)/10.0;\n    float gama = sqrt((iMouse.y+iMouse.x))/10.0 + iTime;\n    vec4 rotate = vec4(position, 1.0)* rotationX(alpha) * rotationY(theta) * rotationZ(gama);\n    position = vec3(rotate.x, rotate.y, rotate.z);\n    // end rotation support \n\t\n    //float time = normalize(iTime);\n    //float theta = sqrt((time)*10.0)/10.0; \t\n    //vec4 rotate = vec4(position, 1.0) * rotationX(theta) * rotationY(theta) * rotationZ(theta);\n    //position = vec3(rotate.x, rotate.y, rotate.z); \n    \n    float timeRandmo1 = (cos(iTime)+1.0)/4.0;\n    float timeRandom2 = (sin(iTime+10.0)+1.0)/4.0;\n    float timeRandom3 = (cos(iTime*0.5)+1.0)/4.0;\n    float timeRandom4 = (cos(iTime*2.0)+1.0)/4.0;\n    float sphere = length(position) - timeRandmo1+0.05;\n    float cube = sdCube(position, timeRandom2, 0.04);\n    vec3 symetric = vec3(abs(position.x), abs(position.y), abs(position.z));\n    vec3 symetric2 = vec3(abs(position.y), abs(position.x), abs(position.z));\n    theta = 0.009;\n    rotate = vec4(symetric, 1.0) * rotationX(theta) * rotationY(theta) * rotationZ(theta);\n    vec3 symetric3 = vec3(abs(rotate.x), abs(rotate.y), abs(rotate.z));\n\n    float triPrism = sdTriPrism(vec3(symetric.x, symetric.y, symetric.z), vec2(timeRandom3, 0.53));\n    float triPrism2 = sdTriPrism(vec3(symetric.y, symetric.x, symetric.z), vec2(timeRandom2, 0.53));\n    float triPrism3 = sdTriPrism(vec3(symetric3.z, symetric3.x, symetric3.y), vec2(timeRandom3, 0.53));\n    //float triPrism4 = sdTriPrism(vec3(symetric3.x, symetric3.y, symetric3.z), vec2(0.50, 0.53));\n    float triPrism5 = sdTriPrism(vec3(symetric3.z, symetric3.y, symetric3.x), vec2(timeRandom4, 0.53));\n    \t\n    \n    //float ret = min(sphere, floor);\n    vec2 result = vec2(0, cube);\n    if (sphere < result.y)\n      result = vec2(1,sphere);\n    if (triPrism < result.y)\n      result = vec2(2,triPrism);  \n    if (triPrism2 < result.y)\n      result = vec2(3,triPrism2); \n    if (triPrism3 < result.y)\n      result = vec2(4,triPrism3);\n    //if (triPrism4 < result.y)\n    //  result = vec2(5,triPrism4);\n    if (triPrism5 < result.y)\n      result = vec2(5,triPrism5);\n    \n    //float ret = min(sphere, cube);\n    //ret = min(ret, triPrism);\n    //return ret;\n    return result;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(map(pos+e.xyy).y-map(pos-e.xyy).y,\n                          map(pos+e.yxy).y-map(pos-e.yxy).y,\n                          map(pos+e.yyx).y-map(pos-e.yyx).y));\n}\n\n// rematcher\nvec2 castRay(in vec3 cameraOrigin, in vec3 cameraDirection)\n{\n    float m = -1.0;\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n    \tvec3 pos = cameraOrigin + t*cameraDirection;\n        vec2 map = map(pos);\n        float h = map.y;\n        m = map.x;\n        if (h < 0.001)\n            break;\n        \n        t += h;\n        if (t>20.0) \n            break;\n    }\n    if (t > 20.0)\n        t = -1.0;\n    \n    return vec2(t, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 pixel2dNormalized = (2.0*fragCoord-iResolution.xy)/iResolution.y; // we devide by only y to keep domain as square\n    \n    //float f = smoothstep(0.2, 0.3, length(pixel2dNormalized))*0.5;\n    float an = 1.0;//10.0*iTime/iResolution.x;\n    float bn = 1.0;//10.0*iTime/iResolution.y;\n    vec3 cameraOrigin = vec3(0, 0,5.5);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta-cameraOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 cameraDirection = normalize(pixel2dNormalized.x*uu + pixel2dNormalized.y*vv + 5.0*ww);\n\n    // Sky color\n    vec3 col = vec3(0.8, 0.8, 0.8) - 0.4*pixel2dNormalized.y;\n    // add Horizon fog\n    //col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10.0*pixel2dNormalized.y));\n    \n    \n    vec2 castr = castRay(cameraOrigin, cameraDirection);\n    float t = castr.x;\n    if (t > 0.0) {\n        vec3 intersection = cameraOrigin + t*cameraDirection;\n        vec3 objectSurfaceNormal = calcNormal(intersection);\n             \n        // material base color\n        vec3 material = vec3(0.2, 0.2, 0.2);\n        if (castr.y == 1.0) { //sphere\n        \tmaterial *= vec3(1.0, 0.0, 0.0);\n        } else if (castr.y == 2.0) {\n            material *= vec3(0.1, 0.1, 7.0);  \n        } else if (castr.y == 3.0) {\n            material *= vec3(0.9, 0.9, 0.0);  \n        } else if (castr.y == 4.0) {\n            material *= vec3(0.0, 0.9, 0.0);  \n        } else if (castr.y == 5.0) {\n            material *= vec3(0.8, 0.4, 0.0);  \n        }\n\n        vec3 sunDirectionNormal = normalize(vec3(0.5, 0.5, 0.1));\n        float sunDiffusion = clamp(dot(objectSurfaceNormal, sunDirectionNormal), 0.0, 1.0);\n        float skyDiffusion = clamp(dot(objectSurfaceNormal, vec3(0.6, 0.6, 0.6)), 0.5, 1.0);\n        float sunShadow = step(castRay(intersection+objectSurfaceNormal*0.001, sunDirectionNormal).x, 0.0);\n        float bounceDiffuse = clamp(dot(objectSurfaceNormal, vec3(1.0, -1.0, 0.0)), 1.0, 0.0);\n        \n        // lighthing adjustment\n    \tcol  = material*vec3(5.0, 4.0, 4.0)*sunDiffusion*sunShadow;  \n        col += material*vec3(0.5, 0.8, 0.9)*skyDiffusion; \n        col += material*vec3(0.5, 0.3, 0.2)*bounceDiffuse;  \n    }\n    \n    // Gama correction\n    col = pow(col, vec3(0.4545));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}