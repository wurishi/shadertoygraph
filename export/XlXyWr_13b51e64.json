{"ver":"0.1","info":{"id":"XlXyWr","date":"1504241402","viewed":247,"name":"AA grid with dots","username":"etale_cohomology","description":"An antialiased grid with dots!\n\nA reproduction of the diagram at 0:33 of the video: youtube.com/watch?v=ekScy_oQABY\n\n(Enable zoom by commenting in the 2nd-half of first line)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","grid","math","tutorial","antialias","dots"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE      2. //* ((1.02 + sin(.5 * iTime)) * 6.)\n#define DOT_FREQ   1.\n#define DOT_RADIUS .1\n#define LINE_FREQ  .5\n\n#define LINE_THICKNESS .004\n\n#define RGB_DARK  vec3(.1)\n#define RGB_LIGHT vec3(.8)\n#define RGB_BLUE  vec3(.0, .6, 1.)\n\n// -----------------------------------------------------------------------------------------------\n// The vector-projection of vec_a to vec_b is always a scalar multiple of vec_b\n// (ie. a vector in the direction of vec_b, or, equivalently, a vector in the subspace spanned by vec_b).\n// This function computes that scalar multiple!\nfloat vproj_scalar(vec2 vec_a, vec2 vec_b){\n\treturn dot(vec_a, vec_b) / dot(vec_b, vec_b);\n}\n\n// A line is given by (any) 2 vertices in the line\nfloat df_line(vec2 uv, vec2 vec_a, vec2 vec_b){\n    vec2 dvec_ap =    uv - vec_a;  // Displacement vector from vec_a to current pixel\n    vec2 dvec_ab = vec_b - vec_a;  // Displacement vector from vec_a to vec_b\n    vec2 vproj_ap_ab = dvec_ab * vproj_scalar(dvec_ap, dvec_ab);  // Standard linear algebra vector projection!\n    return distance(dvec_ap, vproj_ap_ab) - LINE_THICKNESS;\n}\n\n// SDF for a disk centered at the origin!\nfloat sdf_disk(vec2 uv, float radius){\n    return length(uv) - radius;\n}\n\n// -----------------------------------------------------------------------------------------------\n// Repeat primitives, via iq's repeat method!\n// @scale is a number that aids antialiasing!\nfloat draw_linegrid(vec2 uv, float scale){\n\t//vec2 uv_repeat = LINE_FREQ * (fract(uv / LINE_FREQ - .5) - .5);  // 1st, repeat the coordinates!\n    vec2 uv_repeat = mod(uv - .5 * LINE_FREQ, LINE_FREQ) - .5 * LINE_FREQ;  // 1st, repeat the coordinates!\n\n    float hlines = df_line(uv_repeat, vec2(0), vec2(1, 0));  // 2nd, draw the primitives over the repeated coordinates!\n    float vlines = df_line(uv_repeat, vec2(0), vec2(0, 1));\n\n    float line_aa = 4. * scale / iResolution.y;\n    return smoothstep(line_aa, .0, min(hlines, vlines));\n}\n\n// Fork of cacheflowe's https://www.shadertoy.com/view/MdBfzm\n// @scale is a number that aids antialiasing!\nfloat draw_dotgrid(vec2 uv, float scale){\n    vec2  dot_uv = mod(uv - .5 * DOT_FREQ, DOT_FREQ) - .5 * DOT_FREQ;\n    float dot_aa = 4. * scale / iResolution.y;  // Scale-sensitive antialiasing!\n    return smoothstep(dot_aa, 0., sdf_disk(dot_uv, DOT_RADIUS));\n}\n\n// -----------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n    float time = .25 * iTime;\n    uv *= mat2(cos(time), sin(time), -sin(time), cos(time));\n\n    float linegrid = draw_linegrid(uv, SCALE);\n    float dotgrid  = draw_dotgrid(uv, SCALE);\n\n    vec3 scene = RGB_LIGHT;  // Background!\n    scene = mix(scene, RGB_BLUE, linegrid);\n    scene = mix(scene, RGB_DARK, dotgrid);\n\n    fragColor.rgb = scene;\n}\n","name":"Image","description":"","type":"image"}]}