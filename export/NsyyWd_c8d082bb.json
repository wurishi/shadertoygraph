{"ver":"0.1","info":{"id":"NsyyWd","date":"1655789954","viewed":96,"name":"dm-radar","username":"dongmo","description":"雷达加扫光","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["radar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define green vec3(0.0,1.0,0.0)\n#define red vec3(1.0,0.0,0.0)\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 6.283185307179586476925286766559;\n\nfloat RadarSweep(in float time, in vec2 c, in vec2 center, in float radius, in float speed, in bool dir_cw, in float tailLength){\n    \n    time *= speed; // adjust speed by multiplying the time\n    \n    c -= center; //adjust pixel by asuming we are in the center at 0,0 !polar coordinate system!    \n    if(!dir_cw) c.xy = c.yx; // simple hack i still don't understand it myself\n    \n    // x,y - polar coords see header\n    float x = length(c); // x = length of 0,0 to current pixel\n    // y is the angle of our coord system. i mod it to TWO PI to reduce doubler effects\n    float y = mod(atan(c.y, c.x) + time, TWOPI);// see header or build in function\n\n    y /= tailLength;// 1.0 - angle ... so we divide instead of multiplying\n    \n    float result = 0.0;\n    if(x < radius) result += 1.0 - y;// if pixel is in radius x\n       \n    return result;\n}\n\nfloat sdCircle(vec2 uv,float r){\n    return length(uv)-r;\n}\n\nfloat ring(vec2 uv,float r,float width,float w){\n    float c = abs(sdCircle(uv,r))-width;\n    return smoothstep(w,-w,c);\n}\n\nfloat drawLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    return clamp(((1.0 - d)-0.99)*100.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float w = 1.0/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    uv -=0.5;\n    uv.x *=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(.0);\n    float a = 0.0;\n\n    // Time varying pixel color\n    \n    float cir;\n    float r = 0.3+mod(iTime,1.5)*0.5;\n    cir += ring(uv-vec2(0.0),r,0.02,w);\n    //col = mix(col,vec3(0.0,0.5,0.7),cir);\n    col+=vec3(0.0,0.5,0.7) * cir;\n     \n    float radar = RadarSweep(iTime,uv,vec2(0.0,0.0),0.3,1.5,true,PI / 2.0);\n    col += vec3(0.5,0.8,0.3)*radar;\n    a = 1.0 - radar;\n     \n    vec2 pointPos = uv-vec2(sin(iTime*0.5),sin(iTime*0.5)+cos(iTime*0.5))*0.15;\n    float point = sdCircle(pointPos,0.02);\n    point = smoothstep(w,-w,point);\n    col = mix(col,vec3(0.9,0.2,1.0),point);\n    col += min(radar,point);\n    \n    float cir2 = ring(uv-vec2(0.0),0.3,0.002,w);\n    cir2 += ring(uv-vec2(0.0),0.2,0.002,w);\n    cir2 += ring(uv-vec2(0.0),0.1,0.002,w);\n    col = mix(col,vec3(0.0,1.0,0.0),cir2);\n    \n    float line  = drawLine(uv, vec2(-0.3,0.0), vec2(0.3,0.0));\n    line += drawLine(uv, vec2(0.0, -0.3), vec2(0.0,0.3));\n    col = mix(col,vec3(0.0,1.0,0.0),line);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}