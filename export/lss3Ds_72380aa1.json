{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const int MaxIter=6;\n\nfloat scl=1.;\nfloat scl2=1.;\nvoid init(){\n\tscl=pow(0.5,float(MaxIter));\n\tscl2=scl*scl;\n}\n\n//Coposition of two \"rotations\"\nvec2 fG(vec2 t0, vec2 t1){\n\treturn vec2(dot(t0,t1), dot(t0, t1.yx));\n}\n\n//Action of rotation on \"elementary\" coordinates\nvec2 fA(vec2 t, vec2 p){\n\treturn fG(t,p-vec2(0.5))+vec2(0.5);\n}\n\n//Given \"elementary\" coordinates of position, returns the corresponding \"rotation\".\nvec2 fCg(vec2 p){\n\treturn vec2(p.y, (1.-2.*p.x)*(1.-p.y));\n}\n\n//Given \"elementary\" coordinates of position (c=2*p.x+p.y), returns the \"elementary\" linear coordinates\nfloat fL(float c){\n\treturn max(0.,0.5*((-3.*c+13.)*c-8.));\n}\n\n//Given a point inside unit square, return the linear coordinate\nfloat C2L(vec2 p){\n\tvec2 t=vec2(1.,0.);//initial rotation is the identity\n\tfloat l=0.;//initial linear coordinate\n\tfor(int i=0; i<MaxIter;i++){\n\t\tp*=2.; vec2 p0=floor(p); p-=p0;//extract leading bits from p. Those are the \"elementary\" (cartesian) coordinates.\n\t\tp0=fA(t,p0);//Rotate p0 by the current rotation\n\t\tt=fG(t,fCg(p0));//update the current rotation\n\t\tfloat c= p0.x*2.+p0.y;\n\t\tl=l*4.+fL(c);//update l\n\t}\n\treturn l*scl2;//scale the result in order to keep between 0. and 1.\n}\n\n//Given the linear coordinate of a point (in [0,1[), return the coordinates in unit square\n//it's the reverse of C2L\nvec2 L2C(float l){\n\tvec2 t=vec2(1.,0.);\n\tvec2 p=vec2(0.,0.);\n\tfor(int i=0; i<MaxIter;i++){\n\t\tl*=4.; float c=floor(l); l-=c;\n\t\tc=0.5* fL(c);\n\t\tvec2 p0=vec2(floor(c),2.*(c-floor(c)));\n\t\tt=fG(t,fCg(p0));\n\t\tp0=fA(t,p0);\n\t\tp=p*2.+p0;\n\t}\n\treturn p*scl;\n}\n\nfloat dist2box(vec2 p, float a){\n\tp=abs(p)-vec2(a);\n\treturn max(p.x,p.y);\n}\n\nfloat d2line(vec2 p, vec2 a, vec2 b){//distance to line (a,b)\n\tvec2 v=b-a;\n\tp-=a;\n\tp=p-v*clamp(dot(p,v)/(dot(v,v)),0.,1.);//Fortunately it still work well when a==b => division by 0\n\treturn min(0.5*scl,length(p));\n}\n\nfloat ll=0.;//for coloring\nfloat DE(vec2 p) {//Returns the distance to Hilbert curve.\n\tfloat ds=dist2box(p-0.5,.5-0.5*scl);\n\tif(ds>0.5*scl) return ds;//p=p-floor(p);\n\tfloat l=C2L(p);//Get linear coordinate of the Nearest vertex in the curve to p\n\tvec2 p0=scl*floor(p/scl)+vec2(.5*scl);//Nearest vertex in the curve to p\n\tvec2 pp=L2C(max(l-scl2,0.))+vec2(.5*scl);//Previous vertex\n\tvec2 ps=L2C(min(l+scl2,1.-scl2))+vec2(.5*scl);//next vertex\n\tll=l-iTime;\n\treturn max(ds,min(d2line(p,p0,pp),d2line(p,p0,ps)));\n}\n\nfloat coverageFunction(float t){\n\t//this function returns the area of the part of the unit disc that is at the rigth of the verical line x=t.\n\t//the exact coverage function is:\n\t//t=clamp(t,-1.,1.); return (acos(t)-t*sqrt(1.-t*t))/PI;\n\t//this is a good approximation\n\treturn 1.-smoothstep(-1.,1.,t);\n\t//a better approximation:\n\t//t=clamp(t,-1.,1.); return (t*t*t*t-5.)*t*1./8.+0.5;//but there is no visual difference\n}\n\nconst float DRadius=0.75;\nconst float Width=2.;\nconst float Gamma=2.;\nconst vec3 BackgroundColor=vec3(1.,1.,1.);\nconst vec3 CurveColor=vec3(0.,0.,0.);\n\nfloat coverageLine(float d, float lineWidth, float pixsize){\n\td=d*1./pixsize;\n\tfloat v1=(d-0.5*lineWidth)/DRadius;\n\tfloat v2=(d+0.5*lineWidth)/DRadius;\n\treturn coverageFunction(v1)-coverageFunction(v2);\n}\n\nvec3 color(vec2 pos) {//I have to improve the gamma correction :/\n\tfloat pixsize=dFdx(pos.x);\n\tfloat v=coverageLine(abs(DE(pos)), Width, pixsize);\n\tvec3 col=pow(mix(pow(BackgroundColor,vec3(Gamma)),pow(CurveColor,vec3(Gamma)),v),vec3(1./Gamma));\n\treturn col*(0.7+0.3*sin(vec3(ll,7./3.*ll,17./5.*ll)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (0.45*sin(0.25*iTime)+0.55)*(fragCoord.xy-0.5*iResolution.xy) / iResolution.y+0.5;//-vec2(0.5*iResolution.x/iResolution.y-0.5,0.);\n\tinit();\n\tfragColor = vec4(color(uv),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lss3Ds","date":"1382123178","viewed":631,"name":"Hilbert Curve","username":"knighty","description":"My attempt at drawing the Hilbert curve without bitwise integer operations and no non constant array indexing. ","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["curve","hilbert"],"hasliked":0,"parentid":"","parentname":""}}