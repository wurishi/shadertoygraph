{"ver":"0.1","info":{"id":"3lySWt","date":"1583874194","viewed":210,"name":"Rain Effect RayMarch","username":"DG622","description":"The Art of Code tutorials are excellent this is my current understanding of the Ray marching set and the rain effect from the Drive Home set of tutorials. I have not got the camera effect but holding the mouse and moving hopefully you will see my wine!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["rainraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat2 Rot (float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n    \n}\n\n\tfloat box (vec3 p, vec3 s){\n                return length (max(abs(p) - s, 0.0));\n                }\n\n\tfloat sphere (vec4 dim, vec3 p){\n\t\t\tfloat retValue = length(p - dim.xyz)-dim.w;\n\t\t\treturn retValue;\n\t\t\t\t}\n\n    //Raymarhing for the dust see my sheets or Art of Code\n       vec2 GetDist(vec3 p){\n\t\t\tvec2 retValue;\n            //sphere         \n           float dSphere = sphere(vec4(1.0,3.5,5.0,1.5),p);\n           float dPlane = dot(vec3(p.x,p.y-4.4,p.z), normalize(vec3 (0.0,1.0,0.0)));//the vec 3 is the normal of the plane\n         \t\t\t\t\t\t\t//  if(dSphere< 0.0 && dSphere >-0.2) dSphere = abs(dSphere);//makes it hollow ie removes the negative number, if statement makes a sphere within\n           dSphere = abs(dSphere);// hollows it out the goblet so the fluid sphere shows        \n           float d = max(dSphere, dPlane) - 0.01;//max gives intersection of a plane, the number: thickness\n\t\t\t\n           //fluid levels\n           float wave =sin(iTime*2.0)* sin(15.0*p.x+iTime*2.0)*0.08;//fluid moves\n           float fSphere = sphere(vec4(1.0,3.5,5.0,1.4),p);\n           \n          \t\t\t//1 vec3 pT= p;//trying to get fluid to rotate too not working\n           \t\t\t//1pT.xz *=Rot(iTime*0.5);\n          \t\t\t//1 float FPlane = dot(vec3(pT.x ,p.y-4.1-wave,pT.z), normalize(vec3 (0.0,1.0,0.0)));\n           float FPlane = dot(vec3(p.x ,p.y-4.1-wave,p.z), normalize(vec3 (0.0,1.0,0.0)));        \n           float dF = max(fSphere, FPlane) - 0.01;\n           \n           d = min (d, dF);//blend them\n                      \n            //box\n            float bPlane = p.y;// - sin(p.x)/10.0;// plane for the ground then\n            vec3 bp = p-vec3(1.0  , 1.0  , 5.0  );//box position\n           \tbp.xz *= Rot(iTime*0.5);//rotates it\n            float scale = mix (0.8,4.0, smoothstep(-1.0, 0.5, bp.y));//gives the tapered column\n            bp.xz *= scale;\n            float db = box( bp , vec3(1.0));\n            float boxpos = min( db, bPlane)/scale*0.3;// the 0.3 sharpens and reduces artifact\n           \n           \tif (db < bPlane || dSphere < bPlane){retValue.y = 6.0;// sets the object colour with the colour multiplyier \n                          }else retValue.y = 1.0;//set an absoute value for an if statement\n           if (fSphere<0.0) {\n               \t\t\tretValue.y +=.9;//this fraction is liberated to create a red colour of tyhe fouid\n         \t\t\t\t\t\t\t\t\t//so if negative ie inside then fluid sphere is made red\n            \t\t//\tvec2 ref = GetLight(p.xy);\t\n                            }\n           \n            retValue.x = min(d, boxpos);                    \n            return retValue;\n        }\n        vec2 RayMarch(vec3 ro, vec3 rd){\n            float dO = 0.0;\n            vec2 retVal;\n            for(int i = 0; i < 100; i++){\n                vec3 p = ro + dO * rd;\n                retVal = GetDist(p);\n               \n           \t\tfloat dS = retVal.x;\n                dO += dS;\n                if( dS < 0.01 || dO > 100.0){\n                    break;\n                    }\n              }\n          \tretVal.x = dO;\n            return retVal;           \n       }\n\n\t\tvec3 GetNormal (vec3 p){\n            vec2 e = vec2(0.01, 0.0);\n            vec2 retVal = GetDist(p);\n          \tfloat d = retVal.x;\n          \n            vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x, GetDist(p-e.yyx).x);           \n            n = normalize(n);\n            return n;           \n       }\n        vec2 GetLight(vec3 p){\n         \tvec3 lightPos = vec3( 5.0, 8.0, 4.0);\n\n            lightPos.xz += vec2(sin(iTime), cos(iTime));\n            vec3 light = normalize(lightPos - p);\n            vec3 n = GetNormal(p);           \n            vec2 dif = vec2(clamp(dot(n,light), 0.0, 1.0), 0.0);// so no negative numbers, last one just a value\n            //for the shadow\n            vec2 retVal  = RayMarch(p + n * 0.01 * 3.0, light);//this 3.0 is a work around\n            float d = retVal.x;\n            if (d < length (lightPos - p )) dif.x *= 0.1;                                                    \n            dif.y = retVal.y;\n            return dif;\n        }\n     \nvec2 Rain(vec2 uv, float t){//this calculates the offset\n    //uv*=2.;//trial and error these 2\n    t*= 7.;\n    vec2 a = vec2(3., 1.);//aspect ratio chganges dot roundness\n    \n    vec2 st = uv*a;\n    vec2 id = floor(st);\n    st.y += t* 0.22;\t\t\t\t//this moves the box down\n    float noise = fract(sin(id.x*716.37)*769.46);\n    st.y += noise;//makes boxes different levels pseudo rand\n    uv.y +=noise;\n    id = floor(st);//need to reset\n    st =fract(st)- 0.5;\t\t\t//this gives the initial boxes, corners of which -0.5 to 0.5\n    \n     \n    t+=fract(sin(id.x*76.37+id.y*1453.7)*769.46)*6.283;//varies timing of the drops falling\n    \n    float y = -sin(t+sin(t+sin(t)*0.5))*.4;\t//positions dot in the box gives the movement\n    vec2 p1 = vec2(0.0, y);\n    \n    vec2 offset1 = (st-p1)/a;\t\t\t\t//this relates to where the UV is in relation to the droplet\n    float d = length(offset1);\t\t\t\t//this puts the dot in the box\n    float m1 = smoothstep( 0.07, 0.0, d);\t\t//mask 1 draws the dot\n    \n    vec2 offset2 = fract(uv*a.x * vec2(1.0,2.0))-0.5/vec2(1.,2.);\n    d=length(offset2);//draws the trailing dots\n    \n    float m2 = smoothstep(.3*(0.5-st.y), 0.0, d)* smoothstep(-.1,0.1, st.y-p1.y);//shape of the trailing drops\n   // if(st.x>0.46||st.y>0.49) m1 = 1.;\n    \n    return vec2(m1*offset1*20.+m2*offset2*10.);\n               \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \t\tvec3 RGB = vec3(0.1, 0.1, 0.1);\n\t\t\tvec2 uv = (fragCoord/iResolution.xy)*2.0-1.0;   \n\t\t\tvec3 mp = (iMouse.xyz/iResolution.xyz)*2.-1.;         \n            vec3 col = vec3(0.5);\n   \t\t\tfloat t = iTime*0.5;\n    \n            vec3 ro = vec3(mp.x -=0.0 , mp.y += 5.0 ,-2.0  );\n   // uv.x += sin(uv.y*50.0)*0.1;\n    \t\tvec2 RainDist = Rain(uv*5., t);\n    \t\tRainDist += Rain(uv*7., t);\n    \t\tuv-=RainDist*0.5;\n    \n    \t\tuv.x += sin(uv.y*90.)*0.0051;\n    \t\tuv.y += sin(uv.x*170.)*0.001;\n    \n            vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n            vec2 retVal = RayMarch(ro,rd);\n\t\t\tfloat d = retVal.x;\n           \n            vec3 p= ro+rd*d;\n    \n            vec2 diff = GetLight(p);\n    \t\t\n    \t\tdiff/=2.0;// brightness factor\n    \t\tfloat grad = p.y /28.0;//number trial and error\n    \t\tif (retVal.y == 1.0){\n        \t\tif (p.y > 0.1){RGB = vec3( 0.2 * grad, 0.3 * grad, 0.8* grad);//sky\n                }else RGB = vec3( 0.2, 0.5, 0.1);//ground\n    \t\t}\n    \t\tfloat fluidCol = fract(retVal.y);//takes the fractionaql component to make it red\n    \t\tfluidCol *=10.0;\n    \t\t                         \n            col = vec3(diff.x + RGB.r*fluidCol, diff.x + RGB.g, diff.x + RGB.b * retVal.y);\n    \t\t   \n    \t//\tcol = vec3(RainDist, 0.0);//the r g channels\n    \n            fragColor = vec4(col, 0.1);\n}","name":"Image","description":"","type":"image"}]}