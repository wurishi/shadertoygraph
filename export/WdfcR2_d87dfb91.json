{"ver":"0.1","info":{"id":"WdfcR2","date":"1585103187","viewed":568,"name":"pag-Cartoon/ComicBook FX","username":"h3r3x3","description":"Uses Sobel edge detection, bilateral filtering, and halftone to achieve cartoon or comic book style rendering","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["sobel","cartoon","edgedetection","halftone","comic","comicbook","bilateral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Cartoon/ComicBook FX\" by snakebyteme2. https://shadertoy.com/view/XtSfW1\n// 2020-03-25 02:25:40\n// change textureSize to iChannelResolution\n\n\n#define DOTSIZE 1.48\n#define D2R(d) radians(d)\n#define MIN_S 4.0\n#define MAX_S 4.0\n#define SPEED 0.0\n\n#define SST 0.888\n#define SSQ 0.288\n\n#define ORIGIN (0.5 * iResolution.xy)\nfloat R;\nfloat S;\n\nvec4 rgb2cmyki(in vec3 c)\n{\n\tfloat k = max(max(c.r, c.g), c.b);\n\treturn min(vec4(c.rgb / k, k), 1.0);\n}\n\nvec3 cmyki2rgb(in vec4 c)\n{\n\treturn c.rgb * c.a;\n}\n\nvec2 px2uv(in vec2 px)\n{\n\treturn vec2(px / iResolution.xy);\n}\n\nvec2 grid(in vec2 px)\n{\n\treturn px - mod(px,S);\n}\n\nvec4 ss(in vec4 v)\n{\n\treturn smoothstep(SST-SSQ, SST+SSQ, v);\n}\n\nvec4 halftone(in vec2 fc,in mat2 m)\n{\n\tvec2 smp = (grid(m*fc) + 0.5*S) * m;\n\tfloat s = min(length(fc-smp) / (DOTSIZE*0.5*S), 1.0);\n    vec3 texc = texture(iChannel0, px2uv(smp+ORIGIN)).rgb;\n    texc = pow(texc, vec3(2.2)); // Gamma decode.\n\tvec4 c = rgb2cmyki(texc);\n\treturn c+s;\n}\n\nmat2 rotm(in float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\nvec4 halftone( in vec2 fragCoord )\n{\n    vec4 fragColor = vec4(1.0);\n    R = SPEED*0.333*iTime;\n    S = MIN_S + (MAX_S-MIN_S) * (0.5 - 0.5*cos(SPEED*iTime));\n    \n\tif (iMouse.z > 0.5)\n\t{\n\t\tS = MIN_S + (MAX_S-MIN_S) * 2.0*abs(iMouse.x-ORIGIN.x) / iResolution.x;\n\t\tR = D2R(180.0 * (iMouse.y-ORIGIN.y) / iResolution.y);\n\t}\n\t\n\tvec2 fc = fragCoord.xy - ORIGIN;\n\t\n\tmat2 mc = rotm(R + D2R(15.0));\n\tmat2 mm = rotm(R + D2R(75.0));\n\tmat2 my = rotm(R);\n\tmat2 mk = rotm(R + D2R(45.0));\n\t\n\tfloat k = halftone(fc, mk).a;\n\tvec3 c = cmyki2rgb(ss(vec4(\n\t\thalftone(fc, mc).r,\n\t\thalftone(fc, mm).g,\n\t\thalftone(fc, my).b,\n\t\thalftone(fc, mk).a\n\t)));\n    \n    c = pow(c, vec3(1.0/2.2)); // Gamma encode.\n\tfragColor = vec4(c, 1.0);\n    return fragColor;\n}\n\n// Bilateral Filter for Younger. starea.\n// URL: https://www.shadertoy.com/view/XtVGWG\n// Press mouse for comparison.\n// Filter forked from mrharicot: https://www.shadertoy.com/view/4dfGDH \n// Skin detection forked from carlolsson's Skin Detection https://www.shadertoy.com/view/MlfSzn#\n// With performance improvement by athlete\n#define SIGMA 10.0\n#define BSIGMA 0.1\n#define MSIZE 15\n//#define USE_CONSTANT_KERNEL\n//#define SKIN_DETECTION\n\nconst bool GAMMA_CORRECTION = false; \nfloat kernel[MSIZE];\n\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * x * x/ (sigma * sigma)) / sigma;\n}\n\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v,v) / (sigma * sigma)) / sigma;\n}\n\nfloat normalizeColorChannel(in float value, in float min, in float max) {\n    return (value - min)/(max-min);\n}\n\nvec4 bilateral( in vec2 fragCoord ) {\n\tvec4 fragColor = vec4(1.0);\n    vec3 c = texture(iChannel0, (fragCoord.xy / iResolution.xy)).rgb;\n    const int kSize = (MSIZE - 1) / 2;\n    vec3 final_colour = vec3(0.0);\n    float Z = 0.0;\n    \n#ifdef USE_CONSTANT_KERNEL\n    // unfortunately, WebGL 1.0 does not support constant arrays...\n    kernel[0] = kernel[14] = 0.031225216;\n    kernel[1] = kernel[13] = 0.033322271;\n    kernel[2] = kernel[12] = 0.035206333;\n    kernel[3] = kernel[11] = 0.036826804;\n    kernel[4] = kernel[10] = 0.038138565;\n    kernel[5] = kernel[9]  = 0.039104044;\n    kernel[6] = kernel[8]  = 0.039695028;\n    kernel[7] = 0.039894000;\n    float bZ = 0.2506642602897679;\n#else\n\t//create the 1-D kernel\n\tfor (int j = 0; j <= kSize; ++j) {\n\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), SIGMA);\n\t}\n    float bZ = 1.0 / normpdf(0.0, BSIGMA);\n#endif\n    \n\n    vec3 cc;\n    float factor;\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            cc = texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n            factor = normpdf3(cc-c, BSIGMA) * bZ * kernel[kSize+j] * kernel[kSize+i];\n            Z += factor;\n            if (GAMMA_CORRECTION) {\n            \tfinal_colour += factor * pow(cc, vec3(2.2));\n            } else {\n            \tfinal_colour += factor * cc;\n            }\n        }\n    }\n    \n    if (GAMMA_CORRECTION) {\n    \tfragColor = vec4(pow(final_colour / Z, vec3(1.0/2.2)), 1.0);\n    } else {\n    \tfragColor = vec4(final_colour / Z, 1.0);\n    }\n    \n    bool isSkin = true; \n    \n#ifdef SKIN_DETECTION\n    isSkin = false; \n    vec4 rgb = fragColor * 255.0;\n    vec4 ycbcr = rgb;\n    ycbcr.x = 16.0 + rgb.x*0.257 + rgb.y*0.504 + rgb.z*0.098;\n    ycbcr.y = 128.0 - rgb.x*0.148 - rgb.y*0.291 + rgb.z*0.439;\n    ycbcr.z = 128.0 + rgb.x*0.439 - rgb.y*0.368 - rgb.z*0.071;\n    if (ycbcr.y > 100.0 && ycbcr.y < 118.0 &&\n        ycbcr.z > 121.0 && ycbcr.z < 161.0) {\n     \tisSkin = true; \n    }\n#endif\n\n    if (iMouse.z > 0.0 || !isSkin) {\n        fragColor = vec4(texture(iChannel0, fragCoord.xy / iResolution.xy).xyz, 1.0); \n    }\n    return fragColor;\n}\n\n\nvec2 res;\nvec2 inv_res;\n\n\nfloat luminance(vec4 color_in) {\n\treturn 0.25 * color_in.r + 0.5 * color_in.g + 0.25 * color_in.b;\n}\n\nfloat luminance(sampler2D texture_in, vec2 uv, float bias) {\n\tvec4 sample_color = texture(texture_in, uv, bias);\n\treturn luminance(sample_color);\n}\n\nfloat luminance(sampler2D texture_in, vec2 uv) {\n\treturn luminance(texture_in, uv, 0.0);\n}\n\n\nconst mat3 YCoCr_mat = mat3(\n\t1./4., 1./2., 1./4.,\n    -1./4., 1./2., -1./4.,\n    1./2., 0.0, -1./2.\n);\n\nvec3 YCoCr(vec3 color_in) {\n\treturn YCoCr_mat * color_in;\n}\n\nvec3 YCoCr(sampler2D texture_in, vec2 uv) {\n\treturn YCoCr(texture(texture_in, uv).xyz);\n}\n    \n\nconst mat3 sx = mat3( \n    1.0, 2.0, 1.0, \n    0.0, 0.0, 0.0, \n   -1.0, -2.0, -1.0 \n);\nconst mat3 sy = mat3( \n    1.0, 0.0, -1.0, \n    2.0, 0.0, -2.0, \n    1.0, 0.0, -1.0 \n);\n\n\nfloat calc_sobel_res(mat3 I) {\n\tfloat gx = dot(sx[0], I[0]) + dot(sx[1], I[1]) + dot(sx[2], I[2]); \n\tfloat gy = dot(sy[0], I[0]) + dot(sy[1], I[1]) + dot(sy[2], I[2]);\n\n\treturn sqrt(pow(gx, 2.0)+pow(gy, 2.0));\n}\n\n\n// Sobel\n// Based on https://computergraphics.stackexchange.com/questions/3646/opengl-glsl-sobel-edge-detection-filter\nvec3 sobel(vec2 uv) {\n    mat3 Y;\n    mat3 Co;\n    mat3 Cr;\n    \n    vec3 temp; \n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n        \tvec2 pos = uv + vec2(float(i-1) * inv_res.x, float(j-1) * inv_res.y);\n            temp = YCoCr(iChannel0, pos);\n            Y[i][j] = temp.x;\n            Co[i][j] = temp.y;\n            Cr[i][j] = temp.z;\n\t    }\n\t}\n    \n\treturn vec3(calc_sobel_res(Y), calc_sobel_res(Co), calc_sobel_res(Cr));\n}\n\n//toggle between cartoon and comic mode\n#define COMIC\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 fillColor = bilateral(fragCoord);\n    vec4 halftoneColor = halftone(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_mirror_x = vec2(uv.x, uv.y);\n    inv_res = vec2(1.) / iChannelResolution[0].xy;\n    \n\t//fragColor = vec4(vec3(YCoCr(iChannel0, uv_mirror_x).xyz), 1.0);\n    //fragColor = vec4((texture(iChannel0, uv_mirror_x).xyz + sobel(uv_mirror_x))/2., 1.0);\n    vec3 sobe_edge = sobel(uv_mirror_x);\n    fragColor = vec4(sobe_edge, 1.0);\n    \n    fragColor = vec4(vec3(clamp((sobe_edge.x + sobe_edge.y + sobe_edge.z)/3., 0.0, 1.0)), 1.0);\n    if (fragColor.x < 0.05) {\n        fragColor = vec4(0.0);\n    } \n#ifdef COMIC\n    vec3 outlineColor = fragColor.xyz;\n    fragColor.xyz = (halftoneColor.xyz + fillColor.xyz) / 2.0;\n    fragColor.xyz -= outlineColor;\n    \n#else\n    fragColor = (fillColor - fragColor);\n#endif\n    \n    \n}","name":"Image","description":"","type":"image"}]}