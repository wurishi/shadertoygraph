{"ver":"0.1","info":{"id":"wdtcWn","date":"1601981986","viewed":302,"name":"Rasterization-Viewport","username":"sapporo_dynamite","description":"multi-viewport\nvp1. FILL_SOILD\nvp2. FILL_LINE\nvp3. OUT_COLOR_ZBUFFER","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["rasterizer","viewport","zbuffer","perspectivecorrect","cullmode","fillmode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tRasterizer\n\n\tSoftware Rasterization\n\tImplemented Viewport\n\n\tauthor:\n\tsapporo_dynamite/2020 \n\n\tLicense :\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n/*\n2020/10/06\n\t0.0.0 → 1.0.0\n\t・最初のリリース\n*/\n\nstruct Triangle\n{\n    vec3 p0;\n    vec3 p1;\n    vec3 p2;\n    vec3 c0;\n    vec3 c1;\n    vec3 c2;\n};\n\nTriangle triangles[1];\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setPerspective( float fovy, float aspect, float near, float far)\n{\n    float d = 1. / (tan( radians(fovy) * 0.5 ));\n    float q = far  / ( far - near );\n    return mat4( d/aspect,    0,   0,        0,\n        \t\t        0,    d,   0,        0,\n                        0,    0,  -q,       -1,\n                        0,    0,  -q * near, 0 );\n}\n\nmat4 SetOrtho( float l, float r, float b, float t, float near, float far)\n{\n    return mat4( 2./(r-l),        0,              0,                             0,\n                 0,               2./(t-b),       0,                             0,\n                 0,               0,              (1. / (far - near) * 0.5),     0,\n                 -(r+l)/(r-l),   -(t+b)/(t-b),    (-near / (far - near) + 0.5),  1 );\n}\n\n\nvoid createTriangle( void )\n{\n    triangles[0].p0 = vec3( 0.0,  1.0, -0.0); \n    triangles[0].c0 = vec3( 1.0,  0.0,  0.0); \n    triangles[0].p1 = vec3(-1.0, -1.0, -0.0);\n    triangles[0].c1 = vec3( 0.0,  1.0,  0.0); \n    triangles[0].p2 = vec3( 1.0, -1.0, -0.0);\n    triangles[0].c2 = vec3( 0.0,  0.0,  1.0);\n}\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nfloat edge(vec2 a, vec2 b, vec2 c) \n{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n} \n\nfloat line( vec2 a, vec2 b, vec2 p, float r)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return (length( pa - ba*h ) - r);    \n}\n\n// draw endless line trough A and B\nfloat DrawLine(vec2 P, vec2 A, vec2 B, float r)\n{\n\tvec2 g = B - A;\n    float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    bool PERSP = true;\n    bool OUT_COLOR = true;\n    bool PERSP_CORRECT = true;\n    bool FILL_SOILD =  true;\n    bool CULL_MODE  =  true;\n   \n    float n = 1.0;\n    float f = 100.0;\n    float fov = 90.0;\n    \n    vec2 uv = (fragCoord.xy) / iResolution.xy;\n    \n    // viewport settging\n    vec4 viewport[3] = vec4[]( \n        vec4( 0., 0, iResolution.x/3., iResolution.y),\n        vec4( iResolution.x/3., 0, iResolution.x/3.,  iResolution.y),\n        vec4( 2.*iResolution.x/3., 0., iResolution.x/3.,  iResolution.y)\n    );\n    \n    // current viewport\n    vec4 vp = vec4(0);\n    \n    // clear color\n    vec3 col = vec3(float(0x4c)/255.0, float(0x7f)/255.0, float(0xb2)/255.0);\n    \n    bool draw = false;\n    if(fragCoord.x >= viewport[0].x && fragCoord.x <= (viewport[0].z + viewport[0].x) &&\n       fragCoord.y >= viewport[0].y && fragCoord.y <= (viewport[0].w + viewport[0].y) )    \n    {\n        draw = true;\n        vp = viewport[0];\n    }\n    else if(fragCoord.x >= viewport[1].x && fragCoord.x <= (viewport[1].z + viewport[1].x) &&\n            fragCoord.y >= viewport[1].y && fragCoord.y <= (viewport[1].w + viewport[1].y) ) \n    {\n        draw = true;\n        FILL_SOILD = false;\n        vp = viewport[1];\n    }\n    else if(fragCoord.x >= viewport[2].x && fragCoord.x <= (viewport[2].z + viewport[2].x) &&\n            fragCoord.y >= viewport[2].y && fragCoord.y <= (viewport[2].w + viewport[2].y) ) \n    {\n        draw = true;\n        OUT_COLOR = false;\n        vp = viewport[2];\n        col = vec3(1,1,1);\n    }\n    \n    if(draw)\n    { \n        float aspect = vp.z / vp.w;\n    \n        // Projeciotn Matrix\n        mat4 proj = PERSP ? setPerspective(fov, aspect, n, f) : SetOrtho(-1.5 * aspect, 1.5 * aspect, -1.5, 1.5, n, f);    \n\n        mat4 modelViewProj = proj * setTranslation( 0.0, 0.0, -3.5 ) * setRotation( 0.0, 3.1*sin(0.3*iTime), 0.0);\n        \n        vec2 px = (fragCoord - vp.xy)/(vp.zw);\n        px -= vec2(0.5);\n        \n        // line width\n        float line_width = 0.004;\n\n        // clear zbuffer\n        float mindist = 1000000.0;\n\n        // setup triangle\n        createTriangle();\n\n        // 三角形の描画\n        // render triangles\n        for( int i = 0; i < 1; i++ )\n        {\n            // モデル&ビュー&投影 座標系 変換\n            // transform modelViewProj space\n            vec4 v0 = (modelViewProj * vec4(triangles[i].p0, 1));\n            vec4 v1 = (modelViewProj * vec4(triangles[i].p1, 1));\n            vec4 v2 = (modelViewProj * vec4(triangles[i].p2, 1));\n\n            // クリップ座標系 変換\n            // transform clip space\n            float w0 = 1.0 / v0.w;\n            float w1 = 1.0 / v1.w;\n            float w2 = 1.0 / v2.w;\n\n\n            // 正規化デバイス座標系 変換\n            // transform NDC\n            vec3 c0_ndc = triangles[i].c0 * (PERSP_CORRECT ? w0 : 1.0);\n            vec3 c1_ndc = triangles[i].c1 * (PERSP_CORRECT ? w1 : 1.0);\n            vec3 c2_ndc = triangles[i].c2 * (PERSP_CORRECT ? w2 : 1.0);\n\n            // xy\n            vec2 v0_ndc = v0.xy * w0;\n            vec2 v1_ndc = v1.xy * w1;\n            vec2 v2_ndc = v2.xy * w2;\n\n            // z\n            float z0_ndc = v0.z * w0;\n            float z1_ndc = v1.z * w1;\n            float z2_ndc = v2.z * w2;\n\n            // サブ三角形の面積計算\n            // calculate areas for subtriangles        \n            float e = edge( v1_ndc, v0_ndc, v2_ndc);\n\n            vec3 area_ccw = vec3( edge( v1_ndc, v0_ndc, px),\n                                  edge( v2_ndc, v1_ndc, px),\n                                  edge( v0_ndc, v2_ndc, px) );\n\n            vec3 line_area = vec3( line(v0_ndc, v1_ndc, px, line_width),\n                                   line(v1_ndc, v2_ndc, px, line_width),\n                                   line(v2_ndc, v0_ndc, px, line_width) );\n\n             // ピクセルが三角形に重なるかどうか  \n             // pixel overlaps the triangle\n             bool ccw_test  = all(greaterThan(area_ccw,vec3(0.0))) && FILL_SOILD;\n             bool cw_test   = all(lessThan(area_ccw,vec3(0.0))) && FILL_SOILD && CULL_MODE;\n             bool line_test = !all(greaterThan(line_area,vec3(0.0))) && !FILL_SOILD;;\n\n\n             // ラスタライズ\n             // Rasterize \n             if( ccw_test || cw_test || line_test)\n             {\n                 // 重心座標は サブ三角形の面積を全体の三角形の面積で割ったもの \n                 // barycentric coordinates are the sub-triangle area divided by total triangle area.\n                  vec3 ba = vec3(ccw_test || cw_test) * area_ccw.yzx / ( area_ccw.x + area_ccw.y + area_ccw.z) + \n                            vec3(line_test)  *  area_ccw.yzx / ( e );\n\n\n                 // 頂点属性の 重心補間\n                 // barycentric interpolation of attributes and 1/z\n                 float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n                 vec2  uv = vec2(0, 0);            \n                 vec3  color = vec3(ba.x * c0_ndc.x + ba.y * c1_ndc.x + ba.z * c2_ndc.x,\n                                    ba.x * c0_ndc.y + ba.y * c1_ndc.y + ba.z * c2_ndc.y,\n                                    ba.x * c0_ndc.z + ba.y * c1_ndc.z + ba.z * c2_ndc.z );\n\n                 // zs[ 0～1 ]\n                 float zs = ba.x*z0_ndc + ba.y*z1_ndc + ba.z*z2_ndc;\n                 // 補間された値 を 戻す\n                 // recover interpolated attributes\n                 float z =  1.0/iz;\n\n                 // z near/far clip\n                 // ニア/ファー クリップ\n                 if( zs >= 0.0 && zs <= 1.0)\n                 {\n                     // depth buffer test\n                     // Zバッファ テスト\n                     if( zs < mindist )\n                     {\n                            mindist = zs;\n                            color *= (PERSP_CORRECT ? z : 1.0);\n                            col = OUT_COLOR ? vec3( color) :vec3( zs ) ;\n                     }\n                 }\n             }\n        }\n    }\n    \n    float intensity = DrawLine(uv, vec2(viewport[0].x/iResolution.x,0), vec2(viewport[0].x/iResolution.x,1), 0.001); \n    intensity += DrawLine(uv, vec2(viewport[1].x/iResolution.x,0), vec2(viewport[1].x/iResolution.x,1), 0.001); \n    intensity += DrawLine(uv, vec2(viewport[2].x/iResolution.x,0), vec2(viewport[2].x/iResolution.x,1), 0.001); \n    \n    col = mix(col, vec3(0,0,0), intensity);\n    \n    \n    // 出力\n    // Output to screen\n    fragColor = vec4(col,1.0);\n  \n}","name":"Image","description":"","type":"image"}]}