{"ver":"0.1","info":{"id":"mtcSDl","date":"1686163941","viewed":88,"name":"Basic skybox","username":"Toiture","description":"A basic skybox that tries to reproduce the behavior of real sky. Keep in mind it is not accurate at all but I only tried to match the colors. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sky","skybox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define lookAt vec3(0. , 0.25,0. ) \n#define DAY_SPEED_MULT 1.\n\n/////////////////////////////////////////////////////////////////\nfloat plaIntersection( vec3 ro, vec3 rd, vec3 normal,float shift) \n{\n    float dis = dot(normal,rd);\n    if (-dis > 0.001){\n        float t = dot(vec3(shift)-ro,normal)/dis ;\n\n        return t ;\n    } \n    else return -1. ;\n}\n/////////////////////////////////////////////////////////////////\n//random number functions I found on internet\nfloat rand(vec3 co, float seed){\n    return fract(sin(dot(co, vec3(12.9898*seed, 78.233,23.1243*seed))) * 43758.5453);\n}\n//https://stackoverflow.com/questions/53500550/generating-a-pseudo-random-number-between-0-an-1-glsl-es \nfloat random(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\nfloat fbmWeird(vec2 x, int oct) {\n    float mul = 1. ;\n    float size = 1. ;\n    float tex = 0. ;\n    float finalD = 0.;\n    for(int i = 0 ; i < oct ; i++) {\n        finalD+=mul ;\n        tex+=texture(iChannel1, x*size).r*mul ;\n        size*=2. ;\n        mul/=2. ;\n    } \n    return tex/finalD ;\n} \n/////////////////////////////////////////////////////////////////\nfloat cloud2Density(vec3 p) {\n    /*vec3 noise = texture(iChannel1, (p.xz+iTime*50.) /vec2(30000.,30000.) ).rgb;\n    float mask = dot(noise, vec3(0.333));*/\n    float mask = fbmWeird((p.xz+iTime*1000.)/vec2(30000., 10000),4);\n    //mask-=0.5 ;\n    //mask/=0.8;\n    \n    return smoothstep(0.6,0.7,mask)*mask ;\n} \nvec4 clouds2D(vec3 ro, vec3 rd, vec3 sundir) {\n    //cloud color calculations\n    float light = 1. ;\n    float dotS = clamp(dot(vec3(0.,1.,0.),sundir ),0.,1. ) ;\n    vec3 cloudCol = mix(vec3(1.),vec3(1.,0.5,0.),exp(-dotS*13.) );\n    float dotS2 = dot(vec3(0.,1.,0.), sundir);\n    if(dotS2<0.){\n\n        light= exp(dotS2*14.) ;\n\n    } \n    cloudCol = light*cloudCol+(1.-light)*vec3(0.2, 0.2,0.3);\n    \n    //cloud rendering\n    float d = plaIntersection(ro, rd, vec3(0.,-1.,0.),1000. ) ;\n    if(d>0.){\n        vec3 p = ro+rd*d;\n        float mask = cloud2Density(p) ;\n        \n        return vec4(cloudCol, max(0.,mask)) ;\n    } \n    return vec4(cloudCol, 0.) ;\n} \nvec3 getSky(vec3 ro, vec3 rd, vec3 sundir) {\n\n    //world Dots\n    float dotS = clamp(dot(vec3(0.,1.,0.),sundir),0.,1.);\n    float TdotS = exp(-dotS*11.) ;\n    float GdotS = exp(-dotS*20.);\n    \n    float Ddot = clamp(dot(rd.xz,sundir.xz),0.,1.);\n    float Ddot2 = exp(-Ddot*0.1) ;\n    //sun is under world\n    float light = 1.;\n    float dotS2 = dot(vec3(0.,1.,0.), sundir);\n    if(dotS2<0.){\n        light= exp(dotS2*14.) ;\n    } \n    \n    //Color Masks\n    float bMask = mix(exp(-(1.-rd.y)*0.1), max(1.-exp(-rd.y*3.),0.) , Ddot2*TdotS) ;\n    //float bMask = exp(-(1.-rd.y)*0.1);\n    \n    //float rFactor = mix() \n    float rMask = mix(exp(-rd.y*0.55), exp(-rd.y*0.1), Ddot2*GdotS) ;\n    //float gMask = exp(-(1.-rd.y)*GdotS);\n    float gMask =mix(exp(-(1.-rd.y)*0.05) ,mix(0.3,1.,max(1.-exp(-rd.y*5.),0.)),Ddot2*GdotS);\n    //float gMask = exp(-(1.-rd.y)*0.05);\n    \n    //Color Gradients\n    float blue = exp(-rd.y*0.612);\n    float red = exp(-rd.y/0.56);\n    float green = exp(-rd.y) ;\n    \n    //Sun\n    float sunM = smoothstep(0.9999,1.,dot(rd, sundir))*50. ;\n    vec3 sunColor = mix(vec3(1.,0.3,0.),vec3(1.,1.,0.9),dotS);\n    vec3 sun = sunColor*sunM;\n    \n    //sun Halo\n    float haloStrength = 0.06 ;\n    float haloM1 = smoothstep(0.993,1.,dot(rd,sundir))*haloStrength;\n    vec3 halo1 = sunColor*haloM1 ;\n    float haloM2 = smoothstep(0.998,1.,dot(rd,sundir))*haloStrength;\n\n    vec3 halo2 = sunColor*haloM2 ;\n    float haloM3 = smoothstep(0.9993,1.,dot(rd,sundir))*haloStrength;\n\n    vec3 halo3 = sunColor*haloM3 ;\n    vec3 haloFinal = halo1+halo2+halo3 ;\n    \n    \n    //stars \n    //thanks to https://www.youtube.com/watch?v=rvDo9LvfoVE \n    //I only swiched from 2d to 3d\n    vec3 uv = rd*50. ;\n    vec3 lv = fract(uv)-0.5 ;\n    vec3 stars = vec3(0.);\n    for(float x =-1.;x<1.;x++){\n        for(float y =-1.;y<1.;y++){\n            for(float z =-1.;z<1.;z++){\n                vec3 offs = vec3(x, y, z) ;\n                vec3 id = floor(uv+offs) ;\n    \n                float pos = rand(id, 262.262);\n                float c = length(lv-offs-vec3(pos,fract(pos*62.5475),fract(pos*253.26)));\n                float circle = 0.02/c ;\n                stars += vec3(circle)*max(0.,exp(-c*10.) )*3.;\n            } \n        } \n    } \n    //moon\n    float moonM = smoothstep(0.99996,1.,dot(rd,-sundir));\n    vec3 moon = moonM*vec3(0.9,0.9,1.)*20. ;\n    \n    //planar clouds\n    vec4 cloud = clouds2D(ro, rd, sundir); \n    \n    //night sky\n    float nBlue = exp(-rd.y)*0.5;\n    float nRed = exp(-rd.y/2.)*0.2;\n    \n    float nGreen = 0.1 ;\n    \n    vec3 purple = vec3(nRed, nGreen, nBlue) ;\n    vec3 nightCol = mix(vec3(0.,0.,0.2),purple,dotS2 )+stars ;\n    vec3 dayCol = vec3(red*rMask,green*gMask,blue*bMask)+sun+haloFinal;\n    //return mix(final*light+moon+(1.-light)*stars, cloud.rgb,cloud.a);\n    //return final*light+moon+(1.-light)*stars ; //sky without clouds\n    //return vec3(nRed, nGreen, nBlue) ;\n    //return vec3(bMask)+sun;\n    return mix(dayCol*light+moon+(1.-light)*nightCol, cloud.rgb,cloud.a) ;\n} \n\n//////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y ;\n    \n    //camera setup\n    vec3 ro = vec3(0.,1.,0.);\n    vec3 rd = normalize(vec3(uv,-1. )+lookAt ) ;\n    \n    //sun\n    vec3 sundir = normalize(vec3(0.,sin(iTime*0.25*DAY_SPEED_MULT)*0.75,-1. ));\n    \n    //sky \n    vec3 col = getSky(ro, rd, sundir) ;\n    \n    float d = plaIntersection(ro, rd, vec3(0.,1.,0.),0.);\n    if(d>0.){\n        vec3 p = ro+rd*d;\n        \n        //terrain color\n        float light = 1. ;\n        float dotS = clamp(dot(vec3(0.,1.,0.),sundir ),0.,1. ) ;\n        vec3 Col = mix(vec3(1.),vec3(1.,0.4,0.),exp(-dotS*15.) );\n        \n        //sun test if night\n        float dotS2 = dot(vec3(0.,1.,0.), sundir);\n\n        if(dotS2<0.){\n            light= exp(dotS2*14.) ;\n        } \n        Col = light*Col+(1.-light)*vec3(0.1);\n        col = vec3(0.3,0.4,0.)*Col ;\n    } \n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}