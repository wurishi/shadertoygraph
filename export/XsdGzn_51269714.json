{"ver":"0.1","info":{"id":"XsdGzn","date":"1447736799","viewed":200,"name":"spinning cubefield","username":"BigotedSJW","description":"Thanks Shane for so carefully explaining things\nAug-9-2017 edit: opps! saving as a draft does not make a copy. So the original is gone forever.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cuberaymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define sEPS 0.00005 // Minimum surface distance threshold.\n#define FAR 20. // Maximum ray distance threshold.\n\n//from http://www.pouet.net/topic.php?which=7920&page=1#c364352\nfloat cube (vec3 v, float size) //scalar field who's values at any give point is <= distance to closest surface?\n{\n    vec3 x = vec3(abs(v.x)-size,\n              \t  abs(v.y)-size,\n                  abs(v.z)-size);\n    vec3 distf = vec3(max(x.x,0.0),max(x.y,0.0),max(x.z,0.0));\n    return length(distf);\n}\n\n//ye olde rotation matrix; sad this is done every pixel, needs only be done once per frame for purposes here\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\nfloat map(vec3 p)\n{\n     vec3 pos=floor(p*0.5)*0.05;\n     p = mod(p, 2.)-1.;\n\t \n     p.xy*=rot(iTime * mix(.75,4.0,abs(pos.x)) );\n     //p.yz*=rot(iTime * mix(.75,2.0,abs(pos.y)) );\n     p.zx*=rot(iTime * mix(.25,3.0,abs(pos.z)) );\n     return cube(p,0.3333);\n    //return length(p) - 0.3333;\n}\n\n\n///rip off from https://www.shadertoy.com/view/4tlSWl\nfloat raymarch(vec3 ro, vec3 rd) {\n\tfloat d, t = 0.0;\n    \n    for (int i = 0; i < 128 ; i++){\n        d = map(ro + rd *t);    \n        \tif (d<sEPS || t>FAR) break;  \n        t += d*0.75;\n    }\n\n    if (d<sEPS) t += d;\n    \n    return t;\n}\n\n// Standard normal function.\nvec3 getNormal(in vec3 p) {\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n\t));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y; //\"normalized\" screen coords\n    vec3 rd = normalize(vec3(uv, 1.0)); //ray direction for a given position on screen\n    //rd.xz *= rot(iTime*1.250);\n    \n    vec3 ro = vec3(0.0,0.0,6.0); //ray origin \n   \tmat2 cam = rot(iTime*0.75);\n    ro.xz *= cam; \n    rd.xz *= -cam;\n    \n    vec3 col = vec3(0.0);\n    \n    float dist=raymarch(ro,rd);\n    if (dist > FAR)\n    {fragColor = texture(iChannel0,rd);}\n    else fragColor = vec4(abs(getNormal(ro+dist*rd)),1.0);\n}","name":"Image","description":"","type":"image"}]}