{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define M_PI          3.1415926535897932384626433832795\n#define MAXDISTANCE   32.\n#define MAXITERATIONS 32\n#define PRECISION     1e-3\n\nfloat rand(vec2 co){\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat plane(vec3 p, float z) {\n\treturn p.z - z;\n}\n\nfloat udBox(vec3 p, vec3 b, out int object) {\n\tfloat tme = iTime*2.0 + 1024.0;\n\n\tp.y += tme / 2.0;\n\tfloat rowOffset = rand(vec2(0, floor(p.y/2.0)));\n\tp.x += tme * (2. * rowOffset + texture(iChannel0, vec2(rowOffset,.25)).x/500.);\n\n\tobject = int(6. * mod(p.x/(32.*6.), 1.)) + 2;\n\n\tvec2 c = vec2(32, 2);\n\tp.xy = mod(p.xy, c)-.5*c;\n\treturn length(max(abs(p)-b,0.));\n}\n\nfloat getMap(vec3 p, out int object) {\n\tfloat distance = MAXDISTANCE;\n\tfloat tempDist;\n\tint tempObject;\n\n\tdistance = plane(p, 0.0);\n\tobject = 1;\n\n\ttempDist = udBox(p, vec3(12.0, 0.5, 0.5), tempObject);\n\tif (tempDist <= distance) {\n\t\tdistance = tempDist;\n\t\tobject = tempObject;\n\t}\n\treturn distance * 0.5;\n}\n\nvec2 castRay(vec3 origin, vec3 direction, out int object) {\n\tfloat distance = rand(vec2(direction.y * iTime, direction.x)) * 6.0;\n\tfloat delta = 0.0;\n\tobject = 0;\n\n\tfor (int i = 0; i < MAXITERATIONS; i++) {\n\t\tvec3 p = origin + direction * distance;\n\n\t\tdelta = getMap(p, object);\n\n\t\tdistance += delta;\n\t\tif (delta < PRECISION) {\n\t\t\treturn vec2(distance, float(i));\n\t\t}\n\t\tif (distance > MAXDISTANCE) {\n\t\t\tobject = 0;\n\t\t\treturn vec2(distance, float(i));\n\t\t}\n\t}\n\t\n\tobject = 0;\n\treturn vec2(distance, MAXITERATIONS);\n}\n\nvec3 drawScene(vec3 origin, vec3 direction) {\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tint object = 0;\n\n\tvec2 ray = castRay(origin, direction, object);\n\n\tif (object != 0) {\n\t\tif (object == 1) {\n\t\t\tcolor = vec3(1.0, 1.0, 1.0);\n\t\t}\n\t\telse if (object == 2) {\n\t\t\tcolor = vec3(1.0, 0.3, 0.3);\n\t\t}\n\t\telse if (object == 3) {\n\t\t\tcolor = vec3(0.3, 1.0, 0.3);\n\t\t}\n\t\telse if (object == 4) {\n\t\t\tcolor = vec3(0.3, 0.3, 1.0);\n\t\t}\n\t\telse if (object == 5) {\n\t\t\tcolor = vec3(1.0, 1.0, 0.3);\n\t\t}\n\t\telse if (object == 6) {\n\t\t\tcolor = vec3(0.3, 1.0, 1.0);\n\t\t}\n\t\telse if (object == 7) {\n\t\t\tcolor = vec3(1.0, 0.3, 1.0);\n\t\t}\n\t}\n\treturn mix(color, vec3(0.0, 0.0, 0.0), ray.y/float(MAXITERATIONS));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tp.x *= aspect;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tvec3 origin = vec3(0.0, 0.0, 12.0);\n\tvec3 direction = normalize(vec3(p.x, p.y, -1.0));\n\tdirection.xy = mat2(cos(M_PI/4.0), sin(M_PI/4.0), -sin(M_PI/4.0), cos(M_PI/4.0)) * direction.xy;\n\t\n\tcolor = drawScene(origin, direction);\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsBXW1","date":"1411245556","viewed":352,"name":"Colored Bars","username":"novalis","description":"Ported from GLSL Sandbox (thanks MG and gyabo). Added some things + music response.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}