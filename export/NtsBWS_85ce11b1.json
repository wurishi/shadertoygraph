{"ver":"0.1","info":{"id":"NtsBWS","date":"1670695829","viewed":210,"name":"Liquid Drawer","username":"koil","description":"test","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n//\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu;\n    const uint ieeeOne      = 0x3F800000u;\n\n    m &= ieeeMantissa;\n    m |= ieeeOne;\n\n    float  f = uintBitsToFloat( m );\n    return f - 1.0;\n}\n\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec4 rand = vec4(random( vec3( fragCoord * 100.0 + 1.0 * iTime + 13.456, iTime ) ),\n                             random( vec3( fragCoord * 100.0 + 2.0 * iTime - 23.245, iTime ) ),\n                             random( vec3( fragCoord * 100.0 + 3.0 * iTime + 12.123, iTime ) ),\n                             random( vec3( fragCoord * 100.0 + 4.0 * iTime - 64.593, iTime ) ));\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    if (iTime <= iTimeDelta || texelFetch(iChannel2, ivec2(66, 0), 0).x != 0.0) {\n        fragColor = rand;\n    }\n    if (iTime <= iTimeDelta || texelFetch(iChannel2, ivec2(67, 0), 0).x != 0.0) {\n        fragColor = rand;\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//https://www.shadertoy.com/view/Wlfyzl\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = texture(iChannel0,\n                        (-(texture(iChannel2,\n                        fragCoord/iResolution.xy).xy*2.0-1.0)\n                        +fragCoord)/iResolution.xy);\n    if (iMouse.z > 0.0 && !(iMouse.w > 0.0)) {\n        float c = line_segment(fragCoord, iMouse.xy, texture(iChannel3, fragCoord).xy);\n        vec4 cc;\n        if (10.0-c<=0.0) {\n            cc = vec4(0);\n        } else {\n            cc = vec4(1.0);\n        }\n        fragColor = mix(fragColor, cc, cc);\n    }\n    if (texelFetch(iChannel1, ivec2(67, 0), 0).x != 0.0) {\n        fragColor = vec4(0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n//\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu;\n    const uint ieeeOne      = 0x3F800000u;\n\n    m &= ieeeMantissa;\n    m |= ieeeOne;\n\n    float  f = uintBitsToFloat( m );\n    return f - 1.0;\n}\n\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec4 rand = vec4(random( vec3( fragCoord * 100.0 + 1.0 * iTime + 13.456, iTime ) ),\n                    random( vec3( fragCoord * 100.0 + 2.0 * iTime - 23.245, iTime ) ),\n                    random( vec3( fragCoord * 100.0 + 3.0 * iTime + 12.123, iTime ) ),\n                    random( vec3( fragCoord * 100.0 + 4.0 * iTime - 64.593, iTime ) ));\n\n    vec4 D = clamp(vec4(0),vec4(1),rand);\n    fragColor = texture(iChannel0,(-(rand.xy*2.0-1.0)*1.0+fragCoord)/iResolution.xy);\n    fragColor += rand*2.0-1.0;\n    if (iTime <= iTimeDelta || texelFetch(iChannel3, ivec2(66, 0), 0).x != 0.0) {\n        fragColor = rand;\n    }\n    if (iTime <= iTimeDelta || texelFetch(iChannel3, ivec2(67, 0), 0).x != 0.0) {\n        fragColor = rand;\n    }\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = iMouse;\n}","name":"Buffer A","description":"","type":"buffer"}]}