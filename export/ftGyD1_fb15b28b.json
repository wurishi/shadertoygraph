{"ver":"0.1","info":{"id":"ftGyD1","date":"1661373366","viewed":133,"name":"Perfectly still square squares","username":"cnlohr","description":"Just a color shifting optical illusion","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool grey_bars = false;\n\nfloat QSS( float t )\n{\n    return t * t * (3.0 - 2.0 * t);\n}\n\nvec3 CalcColor(vec2 uv )\n{\n    //uv += 10.0;\n    uv *= 10.0;\n    vec3 col = vec3( 0.) ;//vec3( fract(uv*10.).xxy );\n    \n    vec2 cell;\n    vec2 cuv = modf( uv+10000.0f, cell );\n\n    vec2 fleur = abs( 0.5 - fract( uv ) );\n\n    vec2 fleurb = fleur * abs(fleur.x*fleur.y);\n    //float fleurbmax = max( max( fleurb.x - fleurb.y, fleurb.y - fleurb.x ), 0.2-length( 0.5-fleur) );\n    float fleurbmax = 0.11-length( 0.5-fleur);\n    \n    //col = vec3( fleurbmax, 0.0, 0.0 )*9.0;\n\n    if( fleurbmax > 0.025 )\n    {\n        vec2 cellofs;\n        vec2 cuvofs = modf( uv + vec2( 200.5 ), cellofs );\n        cellofs-=vec2(200.0);\n\n        // Try different shifting functions\n        float oddcell = (cellofs.x*1.2 + cellofs.y*1.1 + iTime*1.0 + 200.0);\n        //float oddcell = length(cellofs.xy)*.4 + iTime*2.0;\n        \n        float cellindex = oddcell;\n        float oddmap[8] = float[8]( 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0 );\n\n        int ici = int(cellindex);\n        float cell = oddmap[ici%8];\n        float celh = oddmap[(ici+1)%8];\n        float t = cellindex - float(ici);\n        float porp = QSS( t );\n        float oddness = mix( cell, celh, fract(porp) );\n\n        col = mix( vec3(1.0, 1.0, 1.0), vec3(1.0, 0.1, 1.0), clamp(oddness, 0.0, 1.0) );\n    }\n    else\n    {\n        int oddcell = (int(cell.x+10000.0) ^ int(cell.y+10000.0));\n        col = ((oddcell&1) != 0)?vec3(0.3, 0.8, 0.8 ):vec3( 0.4, 1.0, 0.3 );\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;///iResolution.xy;\n    uv -= iResolution.xy/2.0;\n    vec2 uvz = uv * 2. - 1.;\n    \n    uvz *= 0.003;\n    \n    // Grey bars on the sides.\n    if( grey_bars )\n        if( uvz.x < -iResolution.y/iResolution.x || uvz.x > iResolution.y/iResolution.x ) { fragColor = vec4( 0.5); return; }\n    \n    // Make it square.\n    //uvz.x *= iResolution.x/iResolution.y;\n \n    vec3 col = vec3( 0.0 );\n    float count = 0.0;\n    \n    // Anti-alias it to mush.\n    vec2 uvofsl = vec2(1.3/iResolution.xy);\n    vec2 ofs = -uvofsl;\n    for( ; ofs.x <= uvofsl.x; ofs.x += uvofsl.x*0.3 )\n    {\n        for( ofs.y = -uvofsl.y; ofs.y <= uvofsl.y; ofs.y += uvofsl.y*0.3 )\n        {\n            col += CalcColor( uvz+ofs );\n            count ++;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col/count,1.0);\n}","name":"Image","description":"","type":"image"}]}