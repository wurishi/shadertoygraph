{"ver":"0.1","info":{"id":"Nld3DH","date":"1636175320","viewed":210,"name":"Simplex Experiment #3","username":"Yusef28","description":"A very rough draft from just fiddling around.","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["triangles","simplex"],"hasliked":0,"parentid":"NldGDr","parentname":"Simplex Experiment #2"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv =  (fragCoord.xy)/iResolution.x;\n    vec3 col = texture(iChannel0,uv).rgb;\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = scale*(fragCoord)/iResolution.xy;\n    //uv.x += iTime/4.;\n\n    uv *= (skew);\n    vec2 uvFL = floor(uv);\n    uv = fract(uv);\n    float side = sign(uv.x-uv.y);\n    uvFL += vec2(1., 0.);\n    uvFL += (vec2(0.,0.5))*float(side<0.);\n    \n    uvFL *= inverse(skew);\n    //uv *= inverse(skew);\n    \n    //uvFL+=vec2(side<0.)*0.5;\n    \n    vec3 col = texture(iChannel0, (uvFL/scale) ).rgb;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define eps 8./iResolution.y\n#define S smoothstep\n#define scale 25.\n#define cross2D(a,b) (a).y*(b).x-(a).x*(b).y\n#define asp iResolution.y/iResolution.x\n\nmat2 skew = mat2(2./sqrt(3.), 0., 1./sqrt(3.), 1.); ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//barycentric\n\n//skew matrix often written as \n//mat2 skew = mat2(1.1547, 0., 1.1547/2., 1.);\n\n\n//This hash is pretty bad\nfloat badHash(vec2 x){\n    return fract(sin(dot(vec2(23.,72.),x)*134.)*43143.);\n}\n\n// based on comments from FabriceNeyret2\n// https://www.shadertoy.com/view/7d3SDS\n// super elegant\nvec2 bary(vec2 A, vec2 B, vec2 C, vec2 P){\n    \n    //We want areas for the three triangles created\n    //with out point P and the 3 sides\n    //we get a triangle with vectors AtoB and AtoP\n    //Repeat with B and C\n    vec3 tri = vec3(length(cross2D(B-A,P-A)),\n                    length(cross2D(C-B,P-B)),\n                    length(cross2D(A-C,P-C))\n                    );\n    //If P is in the middle, all areas are equal\n    //If P lays between two sub triangles, those areas\n    //will be equal and there will be one other area\n    \n    \n    //chill sort to find the smallest area triangle\n   \n    //id which we will swap simultenously\n    vec3 id = vec3(1.,2.,3.);\n   \n    //swap to get minumum at x\n    //swap remaining two to get minumum at y\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    if(tri.y < tri.x) tri = tri.yxz, id = id.yxz;\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    //with tri sorted, can do smoothstep without abs\n    \n    \n    //Those areas become a coordinate system because together \n    //they tell us relatively how close P is to any of \n    //the three sides.\n    \n    //so \"borders\" are like with uv.x-uv.y but now 3d \n    //border of area1 and area2 like (uv.y-uv.x)\n    float f1 = S(0.,eps, tri.y-tri.x - 0.02);\n    //border of area1 and area3 (uv.z-uv.y)\n    float f2 = S(0.,eps, tri.z-tri.x - 0.02);\n    return vec2(id.x,f1*f2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor =vec4(0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = scale*(fragCoord)/iResolution.xy;\n    //uv.x += iTime/4.;\n    uv *= skew;\n    vec2 uvFL = floor(uv);\n    uv = fract(uv);\n    \n    vec2 f = 1.0 - S(0.0, eps*2., abs(uv-0.5)-0.45 );\n    float fd =  S(0., eps*3., abs(uv.x-uv.y)-eps*1. );\n    \n    float side = sign(uv.x-uv.y);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(vec3(0,2,4));\n    \n    vec2 stuff = bary(vec2(0.), \n                       vec2(1.,side<0.), \n                       vec2(side>0.,1.),\n                       uv);\n                       \n    col = 0.5 + 0.5*cos(vec3(1.,2.,4.)/3. + \n          badHash(uvFL+side*0.5 + stuff.x/3.)*80. + iTime/2. );\n  \n    col = texture(iChannel0, (fragCoord)/iResolution.xy).rgb;\n    \n    col *= f.x;\n    col *= f.y;\n    col *= fd;\n    //col *= stuff.y;\n    \n    // Output to screen\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}