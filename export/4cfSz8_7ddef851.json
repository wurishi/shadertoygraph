{"ver":"0.1","info":{"id":"4cfSz8","date":"1706278112","viewed":188,"name":"Left Over Cuttings","username":"UnstableLobster","description":"Taking advantage of the voronoi index-space particle buffer to make stiff soft-bodies at reasonable time steps.\n\nLooks better at x4 or x8 speed.\n","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","particles","tracking","verlet","physicsr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Shapes and Sizes\" by UnstableLobster. https://shadertoy.com/view/XcXGW7\n// 2023-12-26 18:18:45\n\n#define aaSoft 0.8\n#define erf(x) tanh( clamp( 2.0/sqrt(PI) * (x + (11.0/123.0)*x*x*x), -10.0, 10.0) )\n#define mixSDF(a, b, s, t) mix(a, b, erf((-(s)/(t)*2.0*aaSoft))*0.5+0.5)\n\nfloat smin(float a, float b, float k, float p, out float t)\n{\n    float h = max(k - abs(a-b), 0.0)/k;\n    float m = 0.5 * pow(h, p);\n    t = (a < b) ? m : 1.0-m;\n    return min(a, b) - (m*k/p);\n}\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    vec2 middle = floor( R.xy * 0.5 - vec2(int(R.x) % 2, int(R.y) % 2) );\n    \n    // closest particles to this pixel    \n    ivec4 ids = ivec4(texel(ch0, pos*voronoi_res));\n    \n    float pSize = particle_rad*2.0;\n\n    particle Pa = getParticle(ids.x, middle, ch3);\n    particle Pb = getParticle(ids.x + 1, middle, ch3);\n    particle Pc = getParticle(ids.x - 1, middle, ch3);\n    particle Pd = getParticle(ids.x + int(R.x/pSize*voronoi_res), middle, ch3);\n    particle Pe = getParticle(ids.x - int(R.x/pSize*voronoi_res), middle, ch3);\n       \n    float da = distance(Pa.NX, pos*voronoi_res) - Pa.R;\n    float db = distance(Pb.NX, pos*voronoi_res) - Pb.R;\n    float dc = distance(Pc.NX, pos*voronoi_res) - Pc.R;\n    float dd = distance(Pd.NX, pos*voronoi_res) - Pd.R;\n    float de = distance(Pe.NX, pos*voronoi_res) - Pe.R;\n    \n    float k = 4.0;\n    float p = 2.0;\n    float t;\n    da = smin(da, db, k, p, t);\n    da = smin(da, dc, k, p, t);\n    da = smin(da, dd, k, p, t);\n    da = smin(da, de, k, p, t);\n    \n    rng_initialize(vec2(Pa.GID), 0);\n    \n    vec2 V = (Pa.NX - Pa.X)/dt;\n    V =  mix(dir(rand()), V, min(length(V)+rand(), 1.0));\n    float v = atan(V.y, V.x) + rand()*TAU;\n    vec3 vc = vec3(\n        dot(vec2(1,0), dir(v + TAU*1.0/3.0) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(v + TAU*2.0/3.0) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(v + TAU*3.0/3.0) * 0.5 + 0.5)\n    );\n    \n    particle Pr = getParticle(ids.x, middle, ch2);\n    vec2 A = (V - (Pr.NX-Pr.X))/dt;\n    float a = atan(A.y, A.x) + rand()*TAU;\n    vec3 ac = vec3(\n        dot(vec2(1,0), dir(a + TAU*1.0/3.0) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(a + TAU*2.0/3.0) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(a + TAU*3.0/3.0) * 0.5 + 0.5)\n    );\n    \n    // shadow\n    particle Ps = getParticle(int(texel(ch0, pos*voronoi_res - vec2(10.0, 5.0)).x), middle, ch3);\n    float ds = distance(Ps.X, pos*voronoi_res - vec2(10.0, 5.0)) - Ps.R;\n    ds = smin(ds, ds, 4.0, 2.0, t);\n    \n    O.xyz = mixSDF(vec3(0.75), vec3(0.68), ds, 1.0);\n    O.xyz = mixSDF(O.xyz, vec3(0.5 + rand()*0.2) * sin(-da) + (vc-ac) * length(V) * 0.08 + hash4(uvec4(ids.x)).x*0.15, da, 1.0);\n    \n    O.xyz = pow(O.xyz, vec3(1.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution\n\n#define PI acos(-1.0)\n#define TAU (PI*2.0)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define snormalize(x) (length(x) > 0.0 ? normalize(x) : x*0.0)\n\n\n//-----------\n// Sim settings\n//---------------\n#define voronoi_res 1.0\n#define particle_rad 2.0\n#define particle_count int(R.x*R.y*voronoi_res*voronoi_res/(particle_rad*particle_rad*4.0))\n\n//#define second_order_neighbours\n\n#define distance_loops 5\n#define compression_compliance 0.0\n#define tension_compliance 0.0\n#define dt (1.0/13.0)\n\n\n//--\n// RNG\n//------\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, frame, p.x + p.y);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand() { pcg4d(s0); return float(s0.x)/float(0xffffffffu);  }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);  }\nvec3 rand3() { pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu); }\nvec4 rand4() { pcg4d(s0); return vec4(s0)/float(0xffffffffu);     }\n\nvec4 hash4(uvec4 seed) { pcg4d(seed); return vec4(seed)/float(0xffffffffu); }\n//-----------------------------------------------------------------------\n\n\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\n//--\n// SDF\n//-----\nfloat sdSegment(vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n//--------------------------------------------\n\nfloat border(vec2 p, vec2 R)\n{\n    return -sdBox(p - R*0.5, R*vec2(0.5, 0.5)) - 1.0;\n}\n\n#define hh 1.\nvec3 bN(vec2 p, vec2 R)\n{\n    vec3 dx = vec3(-hh,0,hh);\n    vec4 idx = vec4(-1./hh, 0., 1./hh, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy, R)\n           + idx.xyw*border(p + dx.xy, R)\n           + idx.yzw*border(p + dx.yz, R)\n           + idx.yxw*border(p + dx.yx, R);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\n\n\n\nvec2 idToPos(int id, vec2 m)\n{\n    int x = int(m.x);\n    return vec2(id % x, id / x);\n}\n\nint posToId(vec2 p, vec2 m)\n{\n    return (int(p.y) * int(m.x)) + int(p.x);\n}\n\n\nstruct particle\n{\n    vec2 X;     // position\n    vec2 NX;    // corrective position\n    \n    float R;    // radius\n    float M;    // mass\n    bool A;     // active\n    int GID;    // group ID\n};\n\nparticle getParticle(vec2 p, vec2 m, sampler2D ch)\n{\n    particle P;\n    vec4 data0 = texel(ch, p);\n    vec4 data1 = texel(ch, p + vec2(m.x, 0.0));\n\n    P.X = data0.xy;\n    P.NX = data0.zw;\n    \n    P.R = data1.x;\n    P.M = data1.y;\n    P.A = data1.z > 0.5;\n    P.GID = int(data1.w);\n        \n    return P;\n}\n\nparticle getParticle(int id, vec2 m, sampler2D ch)\n{\n    return getParticle(idToPos(id, m), m, ch);\n}\n\nfloat particleSDF(particle P, vec2 pos)\n{\n    float s = distance(P.NX, pos) - P.R;\n    return s;\n}\n\nvec2 particleNormal(particle P, vec2 pos)\n{\n    float e = 0.001;\n    \n    float dx = particleSDF(P, pos + vec2(e, 0.0)) - particleSDF(P, pos - vec2(e, 0.0));\n    float dy = particleSDF(P, pos + vec2(0.0, e)) - particleSDF(P, pos - vec2(0.0, e));\n    return normalize(vec2(dx, dy));\n}\n\nivec4 getClosestIDs(particle P, sampler2D ch)\n{\n    return ivec4(texel(ch, P.NX));\n}\n\n\nvoid compare(inout ivec4 nn, ivec4 n)\n{\n    if (any(equal(ivec4(nn.x), n))) nn.x = -1;\n    if (any(equal(ivec4(nn.y), n))) nn.x = -1;\n    if (any(equal(ivec4(nn.z), n))) nn.x = -1;\n    if (any(equal(ivec4(nn.w), n))) nn.x = -1;\n}\n\n\nfloat initialMap(vec2 pos, vec2 R,  out int i)\n{\n    float div = 100.0;\n    \n    int idx = int(floor(pos.x / div));\n    int idy = int(floor(pos.y / div));\n    i = idx + idy * int(floor(R.x/div));\n    \n    pos.x = mod(pos.x, div);\n    pos.y = mod(pos.y, div);\n    \n    if (float(idx + 1) * div > R.x) return 1.0;\n    if (float(idy + 1) * div > R.y) return 1.0;\n        \n    vec4 h = hash4(uvec4(i));\n    if (h.x < 1.0/4.0)\n        return sdHeart((pos-vec2(50.0, 10.0))/50.0);\n    else if (h.x < 2.0/4.0)\n        return sdCross((pos-vec2(50.0, 38.0)), vec2(35.0, 9.0), 0.0);\n    else if (h.x < 3.0/4.0)\n        return sdBox(pos-vec2(50.0, 40.0), vec2(20.0) + (h.yz-0.5)*10.0);\n    else\n    {\n        if (h.w < 0.25)\n            return sdArc(pos-vec2(50.0, 25.0), vec2(1.0, 1.0), 25.0, 10.0);\n        else\n            return sdArc(pos-vec2(50.0, 42.0), vec2(.0, 0.), 20.0, 9.0);\n    }\n}\n\nvoid initialConditions(inout vec4 O, vec2 pos, vec2 middle, vec2 R)\n{\n    int gid = 0;\n    \n    //positions\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos - vec2(0.0, 0.0), middle);\n        \n        //O.xy = rand2() * R.xy * voronoi_res;\n        int pr = int(particle_rad*2.0);\n        O.xy = vec2(id*pr % int(R.x*voronoi_res), id*pr / int(R.x*voronoi_res) * pr) + particle_rad;\n        O.zw = O.xy + (rand2()-0.5)*0.5;      \n        \n        if (initialMap(O.xy, R, gid) >= 0.0)\n        {\n            O = vec4(-10.0);\n        }\n    }\n    // radius - mass - active - groupID\n    else if (pos.y <= middle.y && pos.x > middle.x)\n    {\n        int id = posToId(pos - vec2(middle.x, 0.0), middle);\n    \n        O.x = particle_rad;\n        O.y = O.x*O.x*PI;\n        \n        int pr = int(particle_rad*2.0);\n        vec2 p = vec2(id*pr % int(R.x*voronoi_res), id*pr / int(R.x*voronoi_res) * pr) + particle_rad;\n        \n        O.z = 0.0;\n        if (initialMap(p, R, gid) < 0.0)\n        {\n            O.z = 1.0;\n            O.w = float(gid);\n        }\n    }\n}\n\n\n//----------\n// Simulation\n//----------\nvoid Integrate(inout particle P, vec4 mouse, vec2 R)\n{\n    vec2 V = (P.NX - P.X)/dt;\n    vec2 A = vec2(0.0);\n\n    // mouse\n    if (mouse.z > 0.0)\n    {\n        vec2 dx = mouse.xy*voronoi_res - P.NX;\n        float d = length(dx);\n        float f = exp(-d*d/(R.x*voronoi_res)/10.0)*0.15;\n        \n        vec2 mx = mouse.xy-abs(mouse.zw);\n        \n        A += snormalize(dx) * f;// * snormalize(mx);\n    }\n\n    // gravity\n    A += vec2(0.0, -0.01);\n\n    if (length(V) > 4.25) V = normalize(V) * 4.25;\n\n    P.X = P.NX;\n    P.NX += V*dt + A*dt*dt;\n}\n\nvoid Substep(inout particle P, int id, sampler2D ch, vec2 middle, int neis[16], int nn, vec2 R)\n{\n    vec2 F = vec2(0.0);\n\n    // collisions\n    for (int i = 0; i < nn; i++)\n    {\n        int pid = neis[i];\n        if (pid == id || pid < 0) continue;\n\n        particle P0 = getParticle(pid, middle, ch);\n        \n        if (P.GID == P0.GID) continue;\n\n        vec2 dx = P.NX - P0.NX;\n        float d = length(dx);\n        vec2 n = snormalize(dx);\n        float r = (P.R + P0.R);\n        float m = P0.M/(P.M+P0.M); \n\n        // collision\n        float C = d - r;\n        float l = -C * m;\n        \n        if (d < r)\n           F += n * l * 0.5 / (1.0 + compression_compliance / dt / dt);\n           \n        // friction\n        vec2 pv = P.NX - P.X;\n        vec2 p0v = P0.NX - P0.X;\n        \n        vec2 ta = vec2(n.y, -n.x);\n        vec2 fta = ta * dot(ta, (pv-p0v));\n        \n        if (d <= r)\n            F -= fta * m;\n    }\n    \n    // connections\n    for (int i = -distance_loops; i <= distance_loops; i++)\n    for (int j = -distance_loops; j <= distance_loops; j++)\n    if (abs(i) + abs(j) > 0)\n    {\n        float pSize = particle_rad*2.0;\n    \n        int pid = id;\n        pid += i;\n        pid += j * int(R.x/pSize*voronoi_res);\n        pid = max(pid, 0);\n        \n        particle P0 = getParticle(pid, middle, ch);\n        if (!P0.A) continue;\n        if (P.GID != P0.GID) continue;\n\n        vec2 dx = P.NX - P0.NX;\n        float d = length(dx);\n        vec2 n = snormalize(dx);\n        float r = length(vec2(i, j))*pSize;\n        float m = P0.M/(P.M+P0.M);\n        \n        // distance\n        float C = d - r;\n        float l = -C * m;\n        \n        if (l > 0.0) l /= 1.0 + compression_compliance / dt / dt;\n        if (l < 0.0) l /= 1.0 + tension_compliance / dt / dt;\n        \n        F += n * l / r / r * pSize * pSize * 0.25;\n    }\n\n    // border\n    vec2 n = bN(P.NX, middle*2.0*voronoi_res).xy;\n    float d = border(P.NX, middle*2.0*voronoi_res) - P.R;\n    if (d < 0.0)\n        F -= n*d * 1.0;\n        \n    // border friction\n    if (d < 0.0)\n    {\n        vec2 v = P.NX - P.X;\n        vec2 p = vec2(n.y, -n.x);\n        vec2 tang = p * dot(p, v);\n\n        F -= tang * 1.0;\n    }\n\n    P.NX += F;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// voronoi structure https://www.shadertoy.com/view/WltSz7\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int ni, float nd)\n{\t \n    if      (nd < d[0]) { i = ivec4(   ni, i.xyz ); d = vec4(    nd, d.xyz); }\n    else if (nd < d[1]) { i = ivec4(i.x, ni, i.yz); d = vec4(d.x, nd, d.yz); }\n    else if (nd < d[2]) { i = ivec4(i.xy, ni, i.z); d = vec4(d.xy, nd, d.z); }\n    else if (nd < d[3]) { i = ivec4(i.xyz, ni    ); d = vec4(d.xyz, nd    ); }\n}\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    rng_initialize(pos, iFrame);\n\n    vec2 middle = floor( R.xy * voronoi_res - vec2(ivec2(R.xy) % ivec2(2)) );\n    vec2 pMiddle = floor( R.xy * 0.5 - vec2(ivec2(R.xy) % ivec2(2)) );\n    \n    // initial conditions\n    if (iFrame == 0)\n    {\n        O = rand4() * float(particle_count-1); \n        \n        //float pSize = particle_rad*2.0;\n        //O.x = (pos.x/pSize) + floor(pos.y/pSize) * (middle.x/pSize);\n        //O.x = min(O.x, float(particle_count-1));\n        return;\n    }\n     \n    // voronoi tracking\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        ivec4 new = ivec4(-1);\n        vec4 dis = vec4(R.x*R.y);\n\n        ivec4 o = ivec4(texel(ch0, pos + vec2( 0, 0)));      \n        ivec4 e = ivec4(texel(ch0, pos + vec2( 1, 0)));\n        ivec4 n = ivec4(texel(ch0, pos + vec2( 0, 1)));\n        ivec4 w = ivec4(texel(ch0, pos + vec2(-1, 0)));\n        ivec4 s = ivec4(texel(ch0, pos + vec2( 0,-1))); \n        ivec4 r = ivec4(texel(ch0, pos + round(rand2())*2.0-1.0));\n        \n        ivec4[6] candidates = ivec4[6](o, e, n, w, s, r); \n\n        for (int i = 0; i < 6; i++)\n        for (int j = 0; j < 4; j++)\n        {\n            int id = candidates[i][j];      \n          \n            if (id < 0) continue;\n            if (any(equal(ivec4(id), new))) continue; // id already contained\n\n            particle P0 = getParticle(id, pMiddle, ch3); \n            if (!P0.A) continue;\n            \n            float pd = particleSDF(P0, pos);              \n            if (pd < dis.w)\n                insertion_sort(new, dis, id, pd);\n        } \n\n        // random recovery\n        int h = int(rand() * float(particle_count-1));\n        particle rP = getParticle(h, pMiddle, ch3);\n        int rPid = int( texel(ch0, rP.X).x );\n        if (rP.A && h != rPid) // force insertion only if particle is not being tracked\n            new.w = h;\n\n        O = vec4(new);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// particle substep\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    rng_initialize(pos, iFrame);\n\n    vec2 middle = floor( R.xy * 0.5 - vec2(ivec2(R.xy) % ivec2(2)) );\n          \n    // initial conditions\n    if (iFrame < 2)\n    {\n        O *= 0.0;\n        initialConditions(O, pos, middle, R.xy);\n        return;\n    }\n     \n    // simulation substep\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos, middle);\n              \n        if (id < particle_count)\n        {\n            particle P = getParticle(id, middle, ch3);\n            if (!P.A) return;\n            \n            ivec4 neis = ivec4(texel(ch0, P.NX));\n            int nn = 3;\n            int n[16];\n\n            n[0] = neis.y; n[1] = neis.z; n[2] = neis.w;\n            \n            // neighbours of neighbours\n        #ifdef second_order_neighbours\n            ivec4 neisB = getClosestIDs(getParticle(neis.y, middle, ch3), ch0);\n            ivec4 neisC = getClosestIDs(getParticle(neis.z, middle, ch3), ch0);\n            ivec4 neisD = getClosestIDs(getParticle(neis.w, middle, ch3), ch0);\n            \n            ivec4[3] candidates = ivec4[3](neisB, neisC, neisD); \n            \n            for (int i = 0; i < 3; i++)\n            {\n                compare(candidates[i], neis);\n                for (int j = 0; j < i; j++)\n                    compare(candidates[i], candidates[j]);\n                    \n                for (int k = 0; k < 4; k++)\n                {\n                    int id = candidates[i][k];\n                    if (id >= 0)\n                    {\n                        n[nn] = id;\n                        nn++;\n                    }\n                }\n            }\n        #endif\n        \n            Substep(P, id, ch3, middle, n, nn, R.xy);\n            Integrate(P, iMouse, R.xy);\n            \n            O = vec4(P.X, P.NX);\n        }       \n    } \n    else\n        discard;  \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// particle substep\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    rng_initialize(pos, iFrame);\n\n    vec2 middle = floor( R.xy * 0.5 - vec2(ivec2(R.xy) % ivec2(2)) );\n       \n    // initial conditions\n    if (iFrame < 2)\n    {\n        O *= 0.0;\n        initialConditions(O, pos, middle, R.xy);\n        return;\n    }\n     \n    // simulation substep\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos, middle);\n              \n        if (id < particle_count)\n        {\n            particle P = getParticle(id, middle, ch1);\n            if (!P.A) return;\n            \n            ivec4 neis = ivec4(texel(ch0, P.NX));\n            int nn = 3;\n            int n[16];\n\n            n[0] = neis.y; n[1] = neis.z; n[2] = neis.w;\n            \n            // neighbours of neighbours\n        #ifdef second_order_neighbours\n            ivec4 neisB = getClosestIDs(getParticle(neis.y, middle, ch1), ch0);\n            ivec4 neisC = getClosestIDs(getParticle(neis.z, middle, ch1), ch0);\n            ivec4 neisD = getClosestIDs(getParticle(neis.w, middle, ch1), ch0);\n            \n            ivec4[3] candidates = ivec4[3](neisB, neisC, neisD); \n            \n            for (int i = 0; i < 3; i++)\n            {\n                compare(candidates[i], neis);\n                for (int j = 0; j < i; j++)\n                    compare(candidates[i], candidates[j]);\n                    \n                for (int k = 0; k < 4; k++)\n                {\n                    int id = candidates[i][k];\n                    if (id >= 0)\n                    {\n                        n[nn] = id;\n                        nn++;\n                    }\n                }\n            }\n        #endif\n        \n            Substep(P, id, ch1, middle, n, nn, R.xy);\n            Integrate(P, iMouse, R.xy);\n                        \n            O = vec4(P.X, P.NX);\n        }       \n    } \n    else\n        discard;   \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// particle substep\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    rng_initialize(pos, iFrame);\n\n    vec2 middle = floor( R.xy * 0.5 - vec2(ivec2(R.xy) % ivec2(2)) );\n       \n    // initial conditions\n    if (iFrame < 2)\n    {\n        O *= 0.0;\n        initialConditions(O, pos, middle, R.xy);\n        return;\n    }\n    \n    // simulation substep\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos, middle);\n              \n        if (id < particle_count)\n        {\n            particle P = getParticle(id, middle, ch2);\n            if (!P.A) return;\n            \n            ivec4 neis = ivec4(texel(ch0, P.NX));\n            int nn = 3;\n            int n[16];\n\n            n[0] = neis.y; n[1] = neis.z; n[2] = neis.w;\n                       \n            // neighbours of neighbours\n        #ifdef second_order_neighbours\n            ivec4 neisB = getClosestIDs(getParticle(neis.y, middle, ch2), ch0);\n            ivec4 neisC = getClosestIDs(getParticle(neis.z, middle, ch2), ch0);\n            ivec4 neisD = getClosestIDs(getParticle(neis.w, middle, ch2), ch0);\n            \n            ivec4[3] candidates = ivec4[3](neisB, neisC, neisD); \n            \n            for (int i = 0; i < 3; i++)\n            {\n                compare(candidates[i], neis);\n                for (int j = 0; j < i; j++)\n                    compare(candidates[i], candidates[j]);\n                    \n                for (int k = 0; k < 4; k++)\n                {\n                    int id = candidates[i][k];\n                    if (id >= 0)\n                    {\n                        n[nn] = id;\n                        nn++;\n                    }\n                }\n            }\n        #endif\n        \n            Substep(P, id, ch2, middle, n, nn, R.xy);\n            Integrate(P, iMouse, R.xy);\n                        \n            O = vec4(P.X, P.NX);\n        }       \n    }  \n    else\n        discard;  \n}","name":"Buffer D","description":"","type":"buffer"}]}