{"ver":"0.1","info":{"id":"4dXBzN","date":"1494968883","viewed":100,"name":"pruebas_04","username":"ps","description":"raymarching \n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// recursos interesantes \n// elevated de iq https://www.shadertoy.com/view/MdX3Rr\n// raymarching de iq https://iquilezles.org/articles/rmshadows\n// iluminación de iq https://iquilezles.org/articles/outdoorslighting\n// (buena explicación de raymarching) tutorial para esfera con iluminacion phong mediante raymarching http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// la base del codigo parte de esta https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n// Constantes.\n#define STEPS 64\n#define EPS 0.01\n#define FAR 100.0\n#define PI 3.14159265359\nfloat rand(vec2 co){\n\t// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise2f( in vec2 p )\n{\n\tvec2 ip = vec2(floor(p));\n\tvec2 u = fract(p);\n\t// https://iquilezles.org/articles/morenoise\n\tu = u*u*(3.0-2.0*u);\n\t//u = u*u*u*((6.0*u-15.0)*u+10.0);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),  rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),   rand(ip+vec2(1.0,1.0)),u.x),\n\t\tu.y)\n\t;\n\treturn res*res;\n\t//return 2.0* (res-0.5);\n}\n// define el terreno (signed distanced function) dada unas coordenadas x y z devuelve si ha colisionado o no\nfloat terrainSDF (vec2 posxz){\n  float x=posxz.x;\n    float  z=posxz.y;\n    return 3.2 + 0.1*sin(20.0*x)*cos(20.0*z);\n}\nfloat terrain2SDF (vec2 posxz){\n  float x=posxz.x;\n    float  z=posxz.y;\n    float i;\n\tz = 3.5f;\n\tfor( i=0.; i<20.; i+=1. )\n{\n    float nx = x*x-z*z - 0.745f;\n    float nz = 2.0f*x*z + 0.186f;\n    if( nx*nx+nz*nz>4.0f ) break;\n    x = nx;\n    z = nz;\n}\n  //  return 2.;\nreturn 4.f + sqrt(sqrt(sqrt(i*0.001f)));\n}\n\nfloat terrain3SDF (vec2 posxz){\n     float x=posxz.x;\n    float  z=posxz.y;\nfloat f;\nf = 0.5000000f*noise2f( posxz);\nf += 0.2500000f*noise2f( posxz);\nf = 0.5f+0.5f*f;\nf = f*f*(3.0f-2.0f*f);\nf = f*f*(3.0f-2.0f*f);\nf = 2.5f + 1.5f*f;\nreturn f;\n}\n\n\n\n// escena donde se guardara la composición de objetos de la escena\nfloat scene(vec2 posxz){\n  return terrain3SDF(posxz);\n}\n/*float scene(vec3 p){\n    vec2 posxz=p.xz;\n    //return terrainSDF(posxz);\n     return sphereSDF(p);\n}*/\n// \nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    vec3 pos;\n    float t = tmin;\n\t\tfor( int i=0; i<256; i++ )\n\t{\n         pos = ro + t*rd;\n\t\tfloat h = pos.y - scene( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 calcNormal( in vec3 pos)\n{\n    vec2  eps = vec2( 0.0001 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 makeFog(in vec3 realColor, vec3 fogColor, float distancia, float fogDensity){\n    float theE = 2.718281828459045235360;\n\tfloat res = 1.0/(pow(theE,((distancia*fogDensity)*(distancia*fogDensity)*(distancia*fogDensity))));\n    return mix(fogColor,realColor,res);\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 nor, vec3 ro) {\n \n    /*vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n  //  vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(10.0 * sin(iTime),  2.0,10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    Sfactor=pow(Sfactor,length(nor));\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;*/\n    vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n   // vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(ro.x+10.0 * sin(iTime),\n                          ro.y+2.0,\n                          ro.z+10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    //Sfactor=pow(Sfactor,length(nor));\n    Sfactor = max(dot(R,V),0.0001)*0.001;\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;\n}\n\nfloat fogAngleFixer(vec3 angle){\n\treturn clamp(-angle.y*2.0+0.1,0.0,1.0);   \n}\nvec3 getBackground(vec3 angle){\n    float heigh = clamp(angle.y*2.0+0.2,0.0,1.0);\n    return vec3(0.3*(1.0-heigh),0.5*heigh*0.5+0.5,1.0*heigh/2.0+0.5);\n}\nvec3 getColor(vec3 pos, vec3 norm){\n    float col1=0.0,col2 = 0.0, col3 = 0.0;\n    col1 = clamp((pos.y-3.6) * 10.0, 0.0, 1.0);\n    col2 = (clamp(abs((pos.y-3.6) * 10.0), 0.0, 1.0) * -1.0) + 1.0;\n    col3 = 1.0 - col1 - col2;\n    return\n        col1 * vec3(1.0,1.0,1.0) +\n        col2 * vec3(0.2,0.9,0.3) +\n        col3 * vec3(0.7,0.5,0.1);\n}\nvec4 render ( vec3 ro, in vec3 rd){\n    vec3 light1 = normalize( vec3(4.8,10.4,4.3) );\n\tfloat tmin = 1.0;\n    float tmax = 100.; // distancia maxima del rayo\n\tvec3 col;\n\tvec3 colorGround=vec3(0.474, 0.313, 0.086);\n    vec3 colorBackground=vec3(0.1,0.1,0.8);\n    float fogDensity = 0.1;\n    fogDensity*=fogAngleFixer(rd);\n    vec3 fogColor = vec3(1.0,1.0,1.0);\n    //return vec4(fogDensity);\n \n    \n    \n\tfloat t = intersect( ro, rd, tmin, tmax );\n    if (t>tmax){\n\n        //draw background\n        col = getBackground(rd);// colorBackground;\n        t = -1.0;\n        col = makeFog(col, fogColor, tmax, fogDensity);\n        \n    \n    }else{\n        //draw terrain\n        vec3 pos = ro + t*rd;\n        //vec3 matGround=colorGround;\n        vec3 nor = calcNormal( pos, t );\n        vec3 matGround=getColor(pos,nor);\n        // return vec4 (nor,1. ); //descomentar para mostrar las normales\n        vec3 ref = reflect( rd, nor );\n\n        vec3 K_a = vec3(0.5, 0.5, 0.5);\n        //vec3 K_d = vec3(0.7, 0.2, 0.2);\n        vec3 K_d = matGround;\n        vec3 K_s = vec3(0.2, 0.2, 0.2);\n        float shininess = 1.0;\n\n        vec3 p=pos;\n        vec3 eye=ro;\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye, nor,ro);\n        //return vec4(color,1.0);\n\t\tcol = makeFog(color, fogColor, t*3.0, fogDensity);\n        \n    }\n\treturn vec4(col,t);\n}\nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Pixeles de la imagen\n\t//vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    //vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n   \n    vec2  m = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\ndir.xz = rot2D(dir.xz, 180. * m.x);\n    \n    vec3 ro = vec3(0.0, 4.8, +2.5-iTime); // inicio de rayo\n    vec3 rd = normalize(vec3(uv, -1.0)); // direccion de rayo\n    vec4 res= render(ro,dir); //funcion que nos devolverá el color del fragmento\n\t\n\tfragColor = vec4(res.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}