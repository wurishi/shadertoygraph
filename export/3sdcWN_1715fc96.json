{"ver":"0.1","info":{"id":"3sdcWN","date":"1642775424","viewed":68,"name":"Lab 4 Sebastian Meredith","username":"smeredith116","description":"Lab 4 assignment","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN\n// asPoint: promote a 3D vector into a 4D vector representing a point (w=1)\n//point: input 3D vector\n\nvec4 asPoint(in vec3 point)\n{\n    return vec4(point, 1.0);\n}\n// asOffset: promote a 3D vector into a 4D vector representing an offset (w=0)\n//    point: input 3D vector\nvec4 asOffset(in vec3 offset)\n{\n    return vec4(offset, 0.0);\n}\n// calcViewport: calculate the viewing plane (viewport) coordinate\n//    viewport:       output viewing plane coordinate\n//    ndc:            output normalized device coordinate\n//    uv:             output screen-space coordinate\n//    aspect:         output aspect ratio of screen\n//    resolutionInv:  output reciprocal of resolution\n//    viewportHeight: input height of viewing plane\n//    fragCoord:      input coordinate of current fragment (in pixels)\n//    resolution:     input resolution of screen (in pixels)\nvoid calcViewport(out vec3 viewport, out vec2 ndc, out vec2 uv,out float aspect, out vec2 resolutionInv,in float viewportHeight, in float focalLength,in vec2 fragCoord, in vec2 resolution)\n{\n    // inverse (reciprocal) resolution = 1 / resolution\n    resolutionInv = 1.0 / resolution;\n    // aspect ratio = screen width / screen height\n    aspect = resolution.x * resolutionInv.y;\n    // uv = screen-space coordinate = [0, 1) = coord / resolution\n    uv = fragCoord * resolutionInv;\n    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1\n    ndc = uv * 2.0 - 1.0;\n    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2), z = -f\n    viewport = vec3(ndc * vec2(aspect, 1.0) * (viewportHeight * 0.5), -focalLength);}\n    // calcRay: calculate the ray direction and origin for the current pixel\n    //    rayDirection: output direction of ray from origin\n    //    rayOrigin:    output origin point of ray\n    //    viewport:     input viewing plane coordinate (use above function to calculate)\n\n\nstruct sSphere\n{\n    vec4 center;\n    float radius;\n};\n    void initSphere(out sSphere sphere,in vec3 center, in float radius)\n{\n    sphere.center = asPoint(center);\n    \n    sphere.radius = abs(radius);\n}\n   \n//    focalLength:  input distance to viewing plane\nvoid calcRay(out vec4 rayDirection, out vec4 rayOrigin,in vec3 eyePosition, in vec3 viewport)\n{\n    // ray origin relative to viewer is the origin\n    // w = 1 because it represents a point; can ignore when using\n    rayOrigin = asPoint(eyePosition);\n    // ray direction relative to origin is based on viewing plane coordinate\n    // w = 0 because it represents a direction; can ignore when using\n    rayDirection = asOffset(viewport - eyePosition);\n}\nfloat lenSq(vec2 x)\n{\n    return dot(x,x);\n}\n// calcColor: calculate the color of a pixel given a ray\n//    rayDirection: input ray direction\n//    rayOrigin:    input ray origin\nvec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin)\n{\n    // DUMMY RESULT: OUTPUT RAY DIRECTION AS-IS//  -> what does the ray look like as color?\n    //return rayDirection;\n    //Scene\n    sSphere sphere;\n    initSphere(sphere, vec3(0.0, 0.0, -4.0),0.5);\n    \n    //testing proc sphere\n    vec3 dp;\n    dp.xy = rayDirection.xy - sphere.center.xy;\n    float lSq = lenSq(dp.xy);\n    float rSq = sphere.radius * sphere.radius;\n    if (lSq <= rSq)\n    if(length(dp.xy) <= sphere.radius)\n    {\n        //return vec4(0.0,1.0,1.0,1.0);\n        //dx,dy,r\n        dp.z = rSq - lSq;\n        vec3 position = sphere.center.xyz + vec3(dp.x,dp.y, sqrt(dp.z));\n        vec3 normal = //normalize(position - sphere.center.xyz);\n        (position - sphere.center.xyz) / sphere.radius;\n        return vec4(normal * 0.5 + 0.5, 1.0);\n        // this is actually dz_sq\n    }\n    // BACKGROUND\n    const vec3 warm = vec3(0.8, 0.4, 0.2), cool = vec3(0.2, 0.4, 0.8);\n    //return vec4(mix(warm, cool, rayDirection.y), 1.0);\n    return vec4(0.5);\n}\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // viewing plane (viewport) info\n    vec3 viewport;\n    vec2 ndc, uv, resolutionInv;\n    float aspect;\n    const float viewportHeight = 2.0, focalLength = 1.0;\n    // ray\n    vec4 rayDirection, rayOrigin;\n    // setup\n    fragColor = vec4(0.0);\n    calcViewport(viewport, ndc, uv, aspect, resolutionInv,viewportHeight,focalLength,fragCoord, iResolution.xy);\n    calcRay(rayDirection, rayOrigin, vec3(0.0), viewport);\n    fragColor += calcColor(rayDirection, rayOrigin);\n}\n\n","name":"Image","description":"","type":"image"}]}