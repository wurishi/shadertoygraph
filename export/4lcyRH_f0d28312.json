{"ver":"0.1","info":{"id":"4lcyRH","date":"1531428171","viewed":145,"name":"Example7122018","username":"ShadowFlare","description":"an example","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float speed = 4.0;\nconst float waves = 14.0;\n\nconst float acc = 1.;\n\nconst int timeI = 600;\n\n/*\nvec4 oImage(in vec2 uv )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tfloat r = 0.05;\n    // Time varying pixel color\n    float dist = distance(uv, vec2(0.5));\n    vec4 col = vec4(0.0);\n    float f = (float(iFrame%timeI)/float(timeI));\n    for (float i = 0.0; i < ceil(f*4.); i += 1.) {\n        \n        if (dist > (f/i)-(r/2.) && dist < (f/i)+(r/2.)) {\n            col.rgba = vec4(1.0);\n        }\n    }\n    \n\n    // Output to screen\n    //return col;\n    return texture(iChannel0, uv);\n}\n*/\n\n\nvec4 oImage (in vec2 uv) {\n   \tfloat pixelH = 40.0/iResolution.y;\n    float pixelW = 40.0/iResolution.x;\n    vec2 offsetX, offsetY;\n    offsetX.x = pixelW;\n    offsetY.y = pixelH;\n    float alpha = texture(iChannel0, uv).a;\n    alpha += ceil(texture(iChannel0, uv+offsetX).a);\n    alpha += ceil(texture(iChannel0, uv-offsetX).a);\n    alpha += ceil(texture(iChannel0, uv+offsetY).a);\n    alpha += ceil(texture(iChannel0, uv-offsetY).a);\n   \tvec4 col = texture(iChannel0, uv).rgba;\n    if (ceil(alpha) <= 4.0 && ceil(alpha) > 0.0) {\n        col.rgb = vec3(0.0);\n     \tcol.r = 1.0;\n    } else {\n     \tcol.rgba = vec4(0.0);   \n    }\n\n    // Output to screen\n    return col;  \n}\n\nvec4 ImageA(in vec2 fragCoord)\n{\n    float radius = 30.;\n    float r = min(iResolution.x, iResolution.y);\n    \n\tvec2 uv = fragCoord / iResolution.xy;\n    //uv.x /= 8.0;\n    //uv.y = 1.0 - uv.y;\n    \n    vec3 c = oImage(uv).rgb;\n    \n    float a = oImage(uv).a;\n    bool i = bool(step(0.5, a) == 1.0);\n    \n    float md = radius;\n    float h_md = md;\n    \n    float d = float(md);\n    \n    for (float x = -h_md; x < h_md; x+=acc)\n    {\n        for (float y = -h_md; y < h_md; y+=acc)\n        {\n            vec2 o = vec2(float(x), float(y));\n            vec2 s = ((fragCoord + o)) / r;\n    \t\t//s.x /= 8.0;\n    \t\t//s.y = 1.0 - s.y;\n            \n            float o_a = oImage(s).a;\n            bool o_i = bool(step(0.5, o_a) == 1.0);\n            if (!i && o_i || i && !o_i)\n                d = min(d, length(o));\n        }\n    }\n    \n    d = clamp(d, 0.0, float(md)) / float(md);\n    \n    //d = d * 0.5 + 0.5;\n   // d = 1.0 - d;\n    d += 1.0;\n    \n    float border_fade_outer = 0.1;\n    float border_fade_inner = 0.01;\n    float border_width = 0.25;\n    float n1 = 2.*border_width;\n    vec3 border_color = vec3(1.0, 0.0, 0.0);\n    float outer = smoothstep(n1 - (border_width + border_fade_outer), n1, d);\n    \n    vec3 temp = vec3(0.0, 0.0, 0.0);\n    vec4 border = mix(vec4(temp, 0.0), vec4(border_color, 1.0), outer);\n    \n    float inner = smoothstep(n1, n1 + border_fade_inner, d);\n    \n    vec4 color = mix(border, vec4(c, 1.0), inner);\n    \n    return color;\n}\n\nvec4 distortImage (in vec2 fragCoord)\n{\n   \n \tvec2 uv = (fragCoord.xy) / iResolution.xy;\n\tvec4 col = ImageA(fragCoord);\n    float dilation = col.r;\n\tfloat sinArg = dilation * waves + (iTime*800.)/800. * speed;\n\tfloat slope = cos(sinArg);\n    vec4 color;\n    vec4 co = texture(iChannel1, uv + vec2(dilation) * slope * 0.05);\n    if (dilation == 0.0) {\n\t\tcolor = co;\n    } else {\n     \tcolor = textureLod(iChannel1, uv + vec2(dilation) * slope * 0.05, 2.);\n    \tfloat A = 0.5;\n        color.rgb = mix(co, color, A).rgb;\n    \t\n    }\n\t\n\treturn color;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = distortImage(fragCoord);\n}","name":"Image","description":"","type":"image"}]}