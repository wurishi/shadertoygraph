{"ver":"0.1","info":{"id":"DllGR7","date":"1671518290","viewed":82,"name":"Ray-Marching Sphere","username":"mattwilson720","description":"Using ray marching to render a sphere.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Matthew K. Wilson\n\n#define PI 3.14159265\n#define MAX_ITER 20\n\n// Define the camera\nvec3 camPosition = vec3(0,0,10);\nvec3 lookAtP = vec3(0,0,0);\nvec3 vup = vec3(0,1,0);\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 getLightPosition() {\n    vec2 mousePos = iMouse.xy/iResolution.xy;\n    mousePos = (mousePos * 4.0) - 2.0;\n    return vec3(mousePos, 5.0);\n}\n\n// defines sphere at origin with radius 2\nfloat sdf(vec3 p) {\n    return length(p) - 2.0;\n}\n\nvec3 calcNormal(vec3 poi) {\n    return normalize(poi);\n}\n\nvec3 march(Ray ray) {\n\n    vec3 o = ray.origin;\n    vec3 d = ray.direction;\n    \n    float dist = sdf(o);\n    int it = 0;\n    \n    while(dist > 0.01 && it < MAX_ITER) {\n       o += d*dist;\n       dist = sdf(o);\n       it++;\n    }\n    \n    if(dist >= 0.0) {\n        vec3 lightPosition = getLightPosition();\n        \n        vec3 N = calcNormal(o);\n        vec3 L = normalize(lightPosition - o);\n        float i = max(dot(N,L), 0.0);\n        return vec3(1.0,1.0,1.0)*i;\n    }\n    return vec3(0.0,0.0,0.0);\n}\n\n// creates ray in world coordinates\nRay createRay(vec2 uv)\n{\n    vec3 k = normalize(camPosition - lookAtP);\n    vec3 i = normalize(cross(vup, k));\n    vec3 j = cross(k, i);\n    mat4 Mcam = mat4(vec4(i,0.0), vec4(j,0.0), vec4(k,0.0), vec4(camPosition, 1.0));\n    mat4 Mview = inverse(Mcam);\n\n    // Define the view frustum\n    float aspect = 16.0/9.0;\n    float fov = 60.0;\n    float n = 5.0;\n    float f = 10.0;\n\n    float r = n * tan((fov*PI/180.0)/2.0);\n    float l = -r;\n\n    float b = l/aspect;\n    float t = r/aspect;\n\n    mat4 Mproj = mat4(\n        2.0*n/(r-l), 0.0, 0.0, 0.0,\n        0.0, 2.0*n/(t-b), 0.0, 0.0,\n        (r+l)/(r-l), (t+b)/(t-b), -(f+n)/(f-n), -1.0,\n        0.0, 0.0, -2.0*f*n/(f-n), 0.0);\n\n    float x = uv.x * (2.0*r) - r;\n    float y = uv.y * (2.0*t) - t;\n    float z = -n;\n    vec4 position = Mcam * vec4(x,y,z,1.0);\n    vec3 direction = normalize(position.xyz - camPosition);  \n    return Ray(camPosition, direction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    Ray ray = createRay(uv);\n    vec3 color = march(ray);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}