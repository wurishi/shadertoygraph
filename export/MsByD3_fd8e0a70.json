{"ver":"0.1","info":{"id":"MsByD3","date":"1494060292","viewed":387,"name":"Music Beast","username":"SudoNhim","description":"What have the beats summoned this time?","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["voxels","music"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n\n//[Scene]========================================\\\n\n#define VOXEL_ERROR 0\n#define VOXEL_NONE 1\n#define VOXEL_STONE 2\n\n#define EDGE_RADIUS 0.1\n\nvec3 g_ro;\n\nvec3 getTexAt(vec3 p)\n{\n    float r = length(p);\n    float theta = mod(atan(p.y, p.z)/PI + r/20.0, 1.0);\n    vec2 uv = vec2(1.0-abs(p.x)/32.0, theta);\n    return textureLod(iChannel0, uv, 0.0).rgb-0.1;\n}\n\nbool isTerrainAt(ivec3 ip, out vec3 fog)\n{\n    if (ip.x < -32 || ip.x > 32) return false;\n    if (length(vec3(ip) - g_ro) < 4.0) return false;\n    vec3 s = getTexAt(vec3(ip));\n    fog = s;\n    return max(s.x, max(s.y, s.z)) * 2.0 > length(vec2(ip.zy));\n}\n\nint getTerrainTypeAt(ivec3 ip)\n{    \n    vec3 fog;\n    if (isTerrainAt(ip, fog)) return VOXEL_STONE;\n    else return VOXEL_ERROR;\n}\n\nfloat dfVoxel(vec3 p, bvec3 adj)\n{\n    vec3 cube = vec3(0.5, 0.5, 0.5) + vec3(adj);\n    return length(max(abs(p)-(cube - EDGE_RADIUS),0.0)) - EDGE_RADIUS;\n}\n\nvec3 nrmVoxel(vec3 p, bvec3 adj) \n{\n    p += 0.01 * normalize(p);\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, adj);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, adj) - base,\n        dfVoxel(p+dd.yxy, adj) - base,\n        dfVoxel(p+dd.yyx, adj) - base\n    ));\n}\n\nbvec3 voxelAdjAt(ivec3 mapPos, vec3 p)\n{\n    ivec3 sp = ivec3(sign(p)); vec3 fog;\n    return bvec3(\n    \tisTerrainAt(mapPos + ivec3(sp.x, 0, 0), fog),\n    \tisTerrainAt(mapPos + ivec3(0, sp.y, 0), fog),\n        isTerrainAt(mapPos + ivec3(0, 0, sp.z), fog));\n}\n        \n//[/Scene]========================================/\n        \n        \n//[Voxel Marcher]=================================\\\n        \n#define MAX_HITS 4\n\nivec3 g_mapPos, g_rayStep;\nvec3 g_rd, g_deltaDist, g_sideDist;\nvec3 g_fogAccum;\nivec3 g_hits[MAX_HITS];\nint g_nHits;\nfloat g_prevDist;\n        \nvoid voxelMarchInit(vec3 ro, vec3 rd)\n{\n    g_ro = ro;\n    g_rd = rd;\n\tg_mapPos = ivec3(floor(ro));\n    g_deltaDist = abs(vec3(length(rd)) / rd);\n    g_rayStep = ivec3(sign(rd));\n    g_sideDist = (sign(rd) * (vec3(g_mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * g_deltaDist;\n    g_nHits = 0;\n    g_prevDist = 0.0;\n    g_fogAccum = vec3(0.0);\n}\n        \nvoid voxelMarchStep()\n{\n    vec3 mi = step( g_sideDist.xyz, g_sideDist.yzx ); \n    vec3 mm = mi*(1.0-mi.zxy);\n    float newDist = min(g_sideDist.x, min(g_sideDist.y, g_sideDist.z));\n    vec3 fog;\n    g_sideDist += mm * vec3(g_rayStep) / g_rd;\n    g_mapPos += ivec3(mm)*g_rayStep;\n    if (isTerrainAt(g_mapPos, fog) && g_nHits < MAX_HITS)\n        g_hits[g_nHits++] = g_mapPos;\n    g_fogAccum += fog * (newDist - g_prevDist);\n    g_prevDist = newDist;\n}\n\nstruct VoxelHit\n{\n    int terrainType;\n\tivec3 mapCoord;\n    vec3 hitLocation;\n    vec3 normal;\n    float weight;\n};\n        \nstruct VoxelMarchResult\n{\n    VoxelHit first;\n    VoxelHit second;\n};\n        \nVoxelMarchResult voxelMarchResolve()\n{\n    VoxelMarchResult result;\n    result.first.terrainType = VOXEL_NONE;\n    result.second.terrainType == VOXEL_NONE;\n    \n    if (g_nHits == 0) return result;\n    \n    // for hits before the last hit, do distance field intersection\n\tfor (int i=0; i<MAX_HITS-1; i++)\n    {\n        if (i == g_nHits-1) break;\n        \n        VoxelHit hit;\n        hit.mapCoord = g_hits[i];\n        hit.terrainType = getTerrainTypeAt(hit.mapCoord);\n        \n        // intersect with voxel cube\n        vec3 hitVoxelCenter = vec3(hit.mapCoord) + 0.5;\n        vec3 cubeIntersect = (hitVoxelCenter - g_ro - 0.5*sign(g_rd))/g_rd;\n        float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n        \n        // get adjacency\n        bvec3 adj = voxelAdjAt(hit.mapCoord, g_ro + g_rd * dist - hitVoxelCenter);\n        \n        // distance march\n        float diff; float mindiff = 1.0; float finaldist = 0.0;\n        for (int i=0; i<8; i++) {\n            vec3 p = g_ro + g_rd * dist;\n            diff = dfVoxel(p - hitVoxelCenter, adj);\n            if (diff < mindiff) {\n                mindiff = diff;\n                finaldist = dist;\n            }\n            dist += diff; \n        }\n        \n        float pixSizeApprox = 2.0/iResolution.x * finaldist; // the FOV is actually about 1 radian :)\n        hit.weight = smoothstep(pixSizeApprox, 0.0, mindiff - 0.01); // anti-alias blend\n        hit.hitLocation = g_ro + g_rd * finaldist - hitVoxelCenter;\n        hit.normal = nrmVoxel(hit.hitLocation, adj);\n        \n        if (hit.weight > 0.0)\n            if (result.first.terrainType == VOXEL_NONE)\n                result.first = hit;\n            else {\n                result.second = hit;\n                return result;\n            }\n    }\n    \n    VoxelHit hit;\n    hit.mapCoord = g_hits[g_nHits-1];\n    hit.terrainType = getTerrainTypeAt(hit.mapCoord);\n    \n    // for the last hit, just do cube intersection\n    vec3 hitVoxelCenter = vec3(hit.mapCoord) + 0.5;\n    vec3 cubeIntersect = (hitVoxelCenter - g_ro - 0.5*sign(g_rd))/g_rd;\n    float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    bvec3 adj = voxelAdjAt(hit.mapCoord, g_ro + g_rd * dist - hitVoxelCenter);\n    \n    hit.weight = 1.0;\n    hit.hitLocation = g_ro + g_rd * dist - hitVoxelCenter;\n    hit.normal = nrmVoxel(hit.hitLocation, adj);\n    \n    if (result.first.terrainType == VOXEL_NONE)\n        result.first = hit;\n    else\n        result.second = hit;\n    \n    return result;\n}\n        \n//[/Voxel Marcher]================================/\n\n\n//[Render]========================================\\\n\nvec3 g_lightDir;\n\nfloat calcAmbientOcclusion(VoxelHit hit)\n{\n    float ambientOcc = 0.0;\n    \n    // for each of the 28 voxels surrounding the hit voxel\n    for (int i=-1; i<=1; i++) for (int j=-1; j<=1; j++) for (int k=-1; k<=1; k++) {\n        if (i == 0 && j == 0 && k == 0) continue; // skip the hit voxel\n        ivec3 offset = ivec3(i, j, k);\n\n        if (dot(hit.normal, vec3(offset)) <= 0.0) continue; \n        \n        int terrainType=VOXEL_STONE; vec3 fog;\n        if (isTerrainAt(hit.mapCoord + offset, fog)) {\n            \n            // use the distance from just above the intersection to estimate occlusion\n            float dist = dfVoxel(hit.hitLocation + hit.normal*0.5 - vec3(offset), bvec3(false));\n            ambientOcc += smoothstep(1.0, 0.0, dist);\n        }\n    }\n    \n    return ambientOcc / 8.0;\n}\n\nvec3 renderVoxelHit(VoxelHit hit)\n{\n    vec3 v = getTexAt(vec3(hit.mapCoord))*0.2;\n    v.g = v.r*v.r;\n    v.r = 0.3 + 0.7*v.r;\n    v = 0.5 * v + min(vec3(0.5), g_fogAccum/128.0);\n    \n    vec3 color = vec3(1.0, 0.0, 0.0);\n    if (hit.terrainType == VOXEL_STONE)\n        color = v;\n    \n    float ambient = 0.4*(1.0-calcAmbientOcclusion(hit));\n    float diffuse = 0.6*max(dot(hit.normal, g_lightDir), 0.0);\n    \n    return (ambient + diffuse) * color;\n}\n\n//[/Render]=======================================/\n\n\n//[Main]==========================================\\\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 ro = vec3(sin(iTime*0.3)*5.0, sin(iTime*0.23)*22.0, cos(iTime*0.3)*22.0);\n    mat3 camMat = lookAt(ro, vec3(0.0), sin(iTime*0.1)*0.1);\n    vec3 rd = normalize(camMat*vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    \n    voxelMarchInit(ro, rd);\n    \n    for (int i=0; i<96; i++)\n        voxelMarchStep();\n    \n    VoxelMarchResult result = voxelMarchResolve();\n    \n    vec3 color = vec3(0.0);\n    g_lightDir = camMat*normalize(vec3(-1.0, -0.2, -.4));\n    if (result.first.terrainType != VOXEL_NONE)\n    {\n        color = renderVoxelHit(result.first);\n        if (result.second.terrainType != VOXEL_NONE)\n            color = mix(color, renderVoxelHit(result.second), 1.0-result.first.weight);\n    }\n    else\n        color = min(vec3(0.5), g_fogAccum/128.0);\n    \n\tfragColor = vec4(color,1.0);\n}\n\n//[/Main]=========================================/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float fa = texture(iChannel0, vec2(uv.x, 0.5)).x;\n    float fb = texture(iChannel0, vec2(uv.x, 0.25)).x;\n    float fc = texture(iChannel0, vec2(uv.x, 0.75)).x;\n    vec3 belowCol = texture(iChannel1, uv + vec2(0.0, 1.0/iResolution.y)).rgb;\n    \n    vec3 color = belowCol * 0.90;\n    \n    color += smoothstep(0.4, 0.6, (1.0-uv.y)*vec3(fa, fb, fc)*0.9) * 1.5;\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}