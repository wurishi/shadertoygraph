{"ver":"0.1","info":{"id":"3l2XRW","date":"1565221939","viewed":171,"name":"Cauliflower Cheese","username":"mewo2","description":"Let's play with fractal raymarching!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat hash(float x) {\n    return mod(x*324327. * sin(x*423254.), 1.0);\n}\n\nfloat smax(float x, float y) {\n    return log(exp(x*10.) + exp(y*10.))/10.;\n}\n\nfloat smin(float x, float y) {\n    return -smax(-x, -y);\n}\n\nfloat box(vec3 p, vec3 s) {\n\tvec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nvec3 eyepos() {\n    return vec3(4. * cos(iTime * .3), 5. * sin(iTime * .26), 3. * sin(iTime * .11));\n}\n\nfloat sdf(vec3 p) {\n    float eyeball = length(p - eyepos()) - .1;\n    float d0 = 1.;\n    float s = 1.;\n    float m = 1.35 + .2 * sin(iTime * 0.29);\n    for (int i = 0; i < 6; i++) {\n        p.xy = rot(iTime * .23) * p.xy;\n        p.y = -abs(p.y);\n        p += vec3(.3, 1.+sin(iTime * 0.27), cos(iTime * .29));\n        p.yz = rot(iTime * .07) * p.yz;\n        p.x = -abs(p.x - .4) + .9;\n        p *= m;\n        s *= m;\n        float d = min(box(p, vec3(0.5)), box(p - vec3(0.5), vec3(0.5)));\n        d0 = smin(d/s, d0);\n    }\n    return smax(d0, -eyeball);\n}\n\nvec3 normal(vec3 p) {\n\tfloat h = 0.001;\n    vec3 a1 = vec3(1., 1., 1.);\n    vec3 a2 = vec3(1., -1., -1.);\n    vec3 a3 = vec3(-1., 1., -1.);\n    vec3 a4 = vec3(-1., -1., 1.);\n    return normalize(a1 * sdf(p + h * a1) + a2 * sdf(p + h * a2) + a3 * sdf(p + h * a3) + a4 * sdf(p + h * a4));\n}\n\nvec3 sky(vec3 r) {\n    return vec3(.5, .2, .2) + r.y * vec3(-.5 * r.y, -.1 * r.y, .1);\n}\nvec3 march(vec3 start, vec3 r) {\n            vec3 c = vec3(1.);\n\tfloat t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 p = start + t * r;\n        float d = min(sdf(p), .5);\n        c -= vec3(.01);\n\n        if (d < 0.001) {\n            vec3 n = normal(p);\n\t\t\tfloat ao = exp(sdf(p + n/5.) + sdf(p + n/4.)+ sdf(p + n/3.));\n            return mix( c * (vec3(.5 + .2 * dot(n, normalize(eyepos() - p)),.6,.9 + .5 * n.y) + .0 * n) * ao , sky(r),t/(vec3(5., 3., 1.)+t));\n        }\n        t += d;\n    }\n    return sky(r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    vec3 eye = eyepos();\n    vec3 look = vec3(0.);\n    vec3 fwd = normalize(look - eye);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = normalize(cross(fwd, up));\n    up = normalize(cross(right, fwd));\n    vec3 r = normalize(uv.x * right + uv.y * up + fwd);\n    float vignette = 1. - length(uv)/3.;\n    vec3 c = march(eye, r) * vignette;\n    float w = (c.r + c.g + c.b) / 3.+ .1 * hash(uv.x+hash(uv.y)+hash(iTime*.1));\n    fragColor = vec4(c * w / (.1 + w), 1.0) * vignette;\n}","name":"Image","description":"","type":"image"}]}