{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    // a sphere centered at the origin has equation |xyz| = r\n    // meaning, |xyz|^2 = r^2, meaning <xyz, xyz> = r^2\n    // now, xyz = ro + t*rd, therefore |ro|^2+|t*rd|^2 + 2<ro, rd> t - r^2 = 0\n\t// |rd| = 1 (normalized) so equation reduce to |ro|^2+ t^2 + 2<ro, rd> t - r^2 = 0\n    // which is a quadratic equation, so\n\n    vec3 oc = ro - sph.xyz;\n    float b = 2.0 *dot(oc, rd);\n    float c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - 4.0 *c;\n    if(h <0.0) return -1.0; //no intersection\n\n    //pick smaller one(i.e, close one)\n    //not (-b+sqrt(h)) /2\n    float t = (-b - sqrt(h))/ 2.0;\n    return t;\n}\nvec3 nSphere(in vec3 pos, in vec4 sph)\n{\n    //sphere center at (l, m, n) radius r\n    //normal at intersect point N= ( (x-l)/r, (y-m)/r, (z-n)/r )\n    return (pos - sph.xyz)/sph.w;\n}\nfloat iPlane(in vec3 ro, in vec3 rd)\n{\n    //equation of a plane, y=0 = ro.y+t*rd.y\n    // t = -ro.y/rd.y\n    return -ro.y/rd.y;\n}\nvec3 nPlane(in vec3 pos)\n{// normal of plane\n    return vec3(0.0, 1.0, 0.0);\n}\nvec4 sph1 = vec4(0.0, 1.0, 0.0, 1.0);//sphere center\nfloat intersect(in vec3 ro, in vec3 rd, out float resT)\n{\n    resT = 1000.0;\n    float id = -1.0;\n    float tsph = iSphere(ro, rd, sph1);// intersect with a sphere\n    float tpla = iPlane(ro, rd);//intersect with a plane\n    if(tsph >0.0)//if intersect with sphere\n    {\n        id  = 1.0;\n        resT = tsph;\n    }\n    if(tpla > 0.0 && tpla < resT)\n    {//if intersect with plane and nearer than sphere or -1\n        id = 2.0;\n        resT = tpla;\n    }\n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light direction\n    vec3 lightDir = normalize(vec3(0.57703));\n\t\n    //uv are the pixel coordinates, from 0 to 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //let's move that sphere...\n    sph1.x = 0.5 * cos(iTime);\n    sph1.z = 0.5 * sin(iTime);\n\n    //we generate a ray with origin \"ro\" and direction \"rd\"\n    vec3 ro = vec3(0.0, 0.5, 3.0);\n\t//vec2(1.78, 1.0) adjust ratio of length and width\n    vec3 rd = normalize(vec3( (-1.0 +2.0*uv) *vec2(1.78, 1.0), -1.0));\n    //we intersect the ray with the 3d scene\n    float t;\n    float id = intersect (ro, rd, t);\n\n    //we need to do some lighting\n    // and for that we need normals\n    //we draw black, by default\n    vec3 col = vec3(0.7);\n    if (id >0.5 && id<1.5)\n    {//if we hit the sphere\n        //intersect position\n        vec3 pos = ro + t*rd;\n        //normal at intersect position\n        vec3 nor = nSphere(pos, sph1);\n        //diffuse light cos(theta) = dot(surface normal, direction to light)\n        float dif = clamp(dot(nor, lightDir), 0.0, 1.0);//use clamp restrict cos to[0, 1]\n        //ambient occlusion\n        float ao = 0.5 + 0.5*nor.y;\n        col = vec3(0.9, 0.8, 0.6)*dif*ao +\n            vec3(0.1, 0.2, 0.4)*ao;\n    }\n    else if (id>1.5)\n    {//we hit the plane\n        vec3 pos = ro + t*rd;\n        vec3 nor = nPlane( pos );\n        //ambient occlusion\n        float amb = smoothstep(0.0, 2.0* sph1.w, length(pos.xz-sph1.xz));\n        col = vec3(amb* 0.7);\n    }\n    col = sqrt(col);\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ds3zs","date":"1377419180","viewed":1774,"name":"Basic Raytracer","username":"jlyharia","description":"self study at raytracing in fs together with comments :)\nCurrently study ambient occlusion, if anyone can help\nReport: https://sites.google.com/site/breezeverywhere/shadertoy/basic-raytracer\nReference: http://www.youtube.com/watch?v=9g8CdctxmeU","likes":42,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere"],"hasliked":0,"parentid":"","parentname":""}}