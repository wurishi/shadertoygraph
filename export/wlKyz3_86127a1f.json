{"ver":"0.1","info":{"id":"wlKyz3","date":"1611487404","viewed":1075,"name":"SDF voxels","username":"DragonWolf","description":"Determines the state of a voxel (outside, edge or inside) given an SDF function by marching circles around the perimeter of a square of progressively smaller size until a minsize is reached (i.e. the size of pixel in this case)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdfvoxel"],"hasliked":0,"parentid":"wlyyRc","parentname":"SDF determine voxel state"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Similar to my first two shaders of a similar name, but this one\n * effectively ray marches the perimeter of the voxel using circles\n * to check if the sdf lies inside the voxel to a given degree of accuracy (the size of a pixel).\n *\n * It also does the checks in a slightly larger area than the voxel to catch edge cases where an sdf resolves to\n * less than minstep size between two voxels.\n */\n\n#define gridSize1 5.0\n#define gridSize2 10.0\n#define gridSize3 20.0\n#define gridSize4 40.0\n\nfloat cornerRadiusMultiplier2d = 3.-2./sqrt(2.)-sqrt(2.); // 0.17157287525\nfloat cornerRadiusMultiplier3d = 3./16.; // 0.1875\n\nfloat sdBox( vec2 p, in vec2 bounds )\n{\n    vec2 d = abs(p)-bounds;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 pixelSize() {\n    return 2.0 * ((vec2(iResolution.x, iResolution.y) - (0.5*iResolution.xy))/iResolution.y) / iResolution.xy;\n}\n\nfloat sdf(vec2 uv) {\n\n    vec2 pixelSize = pixelSize();\n    \n    float screenEdgeMargin = 0.5;\n\n    float radius1 = 0.25 * (1.0 + sin(iTime * 0.6));\n    vec2 position1 = vec2(sin(iTime * 0.2) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.10) * (1. - screenEdgeMargin));\n    float circle1 = sdCircle(uv - position1, radius1);   \n    \n    // 1/10th the size of a pixel circles\n    float radius3 = 0.1 * min(pixelSize.x, pixelSize.y); \n    vec2 position3 = vec2(sin(iTime * 0.6) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.6) * (1. - screenEdgeMargin));\n    float circle3 = sdCircle(uv - position3, radius3);\n    \n    // animation\n    float ta = 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n    float tb = 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    float rb = 0.15*(0.5+0.5*cos(iTime*0.41+3.0));\n    float size = 1.;\n    \n    // distance\n    // vec2 arcPosition1 = vec2(sin(iTime * 0.25) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.25) * (1. - screenEdgeMargin));\n    vec2 arcPosition1 = vec2(0.,0.);\n    // vec2 arcPosition1 = vec2(0.542,0.543);\n    float arc1 = sdArc(uv - arcPosition1,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), size, rb);\n    \n    return min(min(circle1, circle3), arc1);\n}\n    \nbool insideBoundingSquare(vec2 position, vec2 bound) {\n\n    vec2 pixelSize = pixelSize();\n\n    // We'll check just outside of the square to catch cases where the sdf resolves in sub-pixel level between\n    // two squares. This means we potentially treat a square as inside/touching when it isn't but better than\n    // artefacts due to this scenario.\n    vec2 adjustedBound = bound + pixelSize;\n\n    // If all points inside the grid's outer circle are negative, then we're definitely inside.\n    float midpointD = sdf(position);\n    if (midpointD <= -length(adjustedBound)) {\n        return true;\n    } else if (abs(midpointD) < min(adjustedBound.x, adjustedBound.y)) {\n        // There is an sdf edge inside the inner circle, so must not be completely inside.\n        return false;\n    }\n    \n    // For each corner,\n    for (float x = 0.; x < 2.; x++) {\n        for (float y = 0.; y < 2.; y++) {\n            vec2 cornerDirection = normalize(vec2(-1.0 + 2. * x, -1.0 + 2.0 * y)); // -1.0, -1.0 to 1.0, 1.0\n            float r = adjustedBound.x; // Set radius of to radius of inner circle of square.\n            float distFromMidpoint = r; // Total distance from midpoint to corner circle midpoint.\n\n            // Keep shrinking the corner circle until we reach pixel size (or return a value inside).\n            while (r >= min(pixelSize.x, pixelSize.y)) {\n            \n                // Calculate size of inscribed circle in corner.\n                r = cornerRadiusMultiplier2d * r;\n                distFromMidpoint += r; // Move to midpoint of new circle\n                vec2 cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n                distFromMidpoint += r; // Move to edge of circle for next circle\n                \n                // We march in a clock-wise direction around the perimeter.\n                float posOrNeg = 1. - x*2.; // 1 or -1\n                float applyX = abs(x-y); // 1 or 0\n                float applyY = abs(applyX - 1.); // 1 or 0\n                vec2 edgeDirection = vec2(applyX * posOrNeg, applyY * posOrNeg);\n                \n                // March along the edge.\n                for (float i = r; i < adjustedBound.x - r; i = i + r) {\n                    vec2 midpoint = cornerCircleMidpoint + i * edgeDirection;\n                    if (sdf(midpoint) > r) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n            \n    return true;\n}\n\nbool touchingBoundingSquare(vec2 position, vec2 bound) {\n\n    vec2 pixelSize = pixelSize();\n\n    // We'll check just outside of the square to catch cases where the sdf resolves in sub-pixel level between\n    // two squares. This means we potentially treat a square as inside/touching when it isn't but better than\n    // artefacts due to this scenario.\n    vec2 adjustedBound = bound + pixelSize;\n\n    // If all points inside the grid's outer circle are outside,\n    // then we're definitely outside and not touching.\n    float midpointD = sdf(position);\n    if (midpointD > length(adjustedBound)) {\n        // Doesn't touch outer circle, so must be completely outside sdf volume.\n        return false;\n    } else if (midpointD < min(adjustedBound.x, adjustedBound.y)) {\n        // Touches inner circle so must be inside square.\n        return true;\n    }\n\n    // For each corner,\n    for (float x = 0.; x < 2.; x++) {\n        for (float y = 0.; y < 2.; y++) {\n            vec2 cornerDirection = normalize(vec2(-1.0 + 2. * x, -1.0 + 2.0 * y)); // -1.0, -1.0 to 1.0, 1.0\n            float r = adjustedBound.x; // Set radius of to radius of inner circle of square.\n            float distFromMidpoint = r; // Total distance from midpoint to corner circle midpoint.\n\n            // Keep going until we reach pixel size or exit condition.\n            while (r >= min(pixelSize.x, pixelSize.y)) {\n            \n                // Calculate size of inscribed circle in corner.\n                r = cornerRadiusMultiplier2d * r;\n                distFromMidpoint += r; // Move to midpoint of new circle\n                vec2 cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n                distFromMidpoint += r; // Move to edge of circle for next circle\n                float posOrNeg = 1. - x*2.; // 1 or -1\n                float applyX = abs(x-y); // 1 or 0\n                float applyY = abs(applyX - 1.); // 1 or 0\n                vec2 edgeDirection = vec2(applyX * posOrNeg, applyY * posOrNeg);\n                // March along the edge.\n                for (float i = r; i < adjustedBound.x - r; i = i + r) {\n                    vec2 midpoint = cornerCircleMidpoint + i * edgeDirection;\n                    if (sdf(midpoint) <= r) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = pixelSize();\n\n    // Normalized pixel coordinates (from y = -1 to 1 with 0,0 in the center of the screen)\n    vec2 uv = 2.0 * (fragCoord - (0.5*iResolution.xy))/iResolution.y;\n    \n    vec2 minScreenExtent = 2.0 * (vec2(0,0) - (0.5*iResolution.xy))/iResolution.y;\n    vec2 maxScreenExtent = 2.0 * (iResolution.xy - (0.5*iResolution.xy))/iResolution.y;\n    \n    // Calculate SDF\n    float d = sdf(uv);\n\n    float gridSize;\n    if (uv.x > minScreenExtent.x + 3. * (maxScreenExtent.x - minScreenExtent.x) / 4.) {\n        gridSize = gridSize4;\n    } else if (uv.x > minScreenExtent.x + 2. * (maxScreenExtent.x - minScreenExtent.x) / 4.) {\n        gridSize = gridSize3;\n    } else if (uv.x > minScreenExtent.x + 1. * (maxScreenExtent.x - minScreenExtent.x) / 4.) {\n        gridSize = gridSize2;\n    } else {\n        gridSize = gridSize1;\n    }\n\n    // Bounding Box\n    vec2 voxelMidpoint = vec2((floor(uv.x * gridSize) / gridSize) + (0.5 / gridSize), (floor(uv.y * gridSize) / gridSize) + (0.5 / gridSize));\n    vec2 voxelSize = vec2(0.5 / gridSize, 0.5 / gridSize);\n    vec2 minExtent = voxelMidpoint - voxelSize;\n    vec2 maxExtent = voxelMidpoint + voxelSize;\n    float box1 = sdBox(voxelMidpoint - uv, voxelSize);\n    \n    // Work out if the SDF is inside the box or not.\n    bool touching = touchingBoundingSquare(voxelMidpoint, voxelSize);\n    bool inside = false;\n    if (touching) {\n        inside = insideBoundingSquare(voxelMidpoint, voxelSize);\n    }\n    \n    bool outside = !touching;\n\n    vec3 statusColor = vec3(1.0, 1.0, 0.0);\n    if (inside) {\n        statusColor = vec3(0.0, 1.0, 0.0);\n    } else if (outside) {\n        statusColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    // Set base colour depending on inside or outside bounding box.\n    vec3 baseColor = vec3(0.1,0.4,0.7);\n   \n    // Taken from iq to visualize sdf distances (https://www.shadertoy.com/view/4lcBWn)    \n    vec3 col = vec3(1.0) - sign(d)*baseColor;\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)));\n    \n    // Add the grid\n    col = mix( col, statusColor, 1.0 - smoothstep(0.0,0.008,abs(box1)) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}