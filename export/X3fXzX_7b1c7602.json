{"ver":"0.1","info":{"id":"X3fXzX","date":"1709746927","viewed":173,"name":"ShaderBRDF","username":"VictorKostin","description":"brdf","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1416\n\n#define TILING 2.0\n\n#define CUBE_MAP iChannel1\n#define CUBE_MAP_LOD 10.0\n\n#define HEIGHT_MAP iChannel0\n#define HEIGHT_MAP_RESOLUTION iChannelResolution[0].xy\n\n#define NORMAL_DEPTH 124.0\n\n#define SSAO_SAMPLES 64.0\n#define SSAO_RADIUS 1.0\n#define SSAO_POWER 8.0\n\n#define LIGHT_Z 124.0\n#define LIGHT_RADIANCE 124.0\n#define LIGHT_SAMPLING_RANGE 2.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n#define STONE_REFLECTANCE 0.036\n#define AIR_REFLECTANCE 1.0\n\n#define SHADOW_STEPS 128.0\n#define SHADOW_POWER 2.0\n#define SHADOW_COLOR vec3(0.0, 0.0, 0.0)\n\nfloat oneMinus(const float value)\n{\n    return 1.0 - value;\n}\n\nfloat getHeight(const sampler2D heightMap, const vec2 uv)\n{\n  \treturn texture(heightMap, uv).r;\n}\n\nvec3 calculateNormal(const vec2 uv, const sampler2D heightMap)\n{\n    vec2 delta = 1.0 / HEIGHT_MAP_RESOLUTION;\n    float xHeight = getHeight(heightMap, uv - vec2(delta.r, 0.0)) - getHeight(heightMap, uv + vec2(delta.r, 0.0));\n    float yHeight = getHeight(heightMap, uv - vec2(0.0, delta.g)) - getHeight(heightMap, uv + vec2(0.0, delta.g));\n    \n    return normalize(vec3(xHeight, yHeight, 1.0 / NORMAL_DEPTH));\n}\n\nfloat calculateSSAO(const vec2 uv, const sampler2D heightMap)\n{\n    float ao = 0.0;\n    for (float index = 0.0; index < SSAO_SAMPLES; ++index)\n    {\n        float angle = PI * fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453) * index;\n        vec2 offset = (vec2(cos(angle), sin(angle)) * 2.0 - 1.0) * SSAO_RADIUS;\n        ao += max(texture(heightMap, uv + offset).r - getHeight(heightMap, uv), 0.0);\n    }\n\n    ao /= SSAO_SAMPLES;\n    return pow(1.0 - ao, SSAO_POWER);\n}\n\nfloat calculateDistributionGGX(const float NdotM, const float roughness)\n{\n    float alpha = roughness * roughness * roughness * roughness;\n    float divider = NdotM * NdotM * (alpha - 1.0) + 1.0;\n    return alpha / (PI * divider * divider);\n}\n\nfloat calculateGeometrySchlickGGX(const float NdotV, const float divisionFactor)\n{\n    return NdotV / (NdotV * oneMinus(divisionFactor) + divisionFactor);\n}\n\nfloat calculateFresnelSchlick(const float F0, const float NdotL, const float F90)\n{\n    return F0 + (F90 - F0) * pow(oneMinus(NdotL), 5.0);\n}\n\nfloat calculateShadow(const vec3 lightPosition, const float samplingRange, const sampler2D heightMap, const vec2 uv)\n{\n    float height = getHeight(heightMap, uv);\n    float deltaZ = lightPosition.z / NORMAL_DEPTH - height;     \n    vec2 offsetUV = (lightPosition.xy / HEIGHT_MAP_RESOLUTION) - uv;\n    \n    float shadow = 0.0;\n    for (float index = 0.0; index < samplingRange; index += samplingRange / SHADOW_STEPS)\n    {\n        float pointHeight = getHeight(heightMap, uv + index * offsetUV);\n        float rayHeight = height + index * deltaZ;\n        shadow += max(0.0, pointHeight - rayHeight);\n    }\n    return clamp(shadow * SHADOW_POWER, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 offset = vec2(iResolution.r / iResolution.g, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.yy) * TILING - offset;\n    \n    float ao = calculateSSAO(uv, HEIGHT_MAP);\n    vec3  normal = calculateNormal(uv, HEIGHT_MAP);\n    vec3  albedo = vec3(1.0, 1.0, 1.0);\n    float metalness = 0.2;\n    float roughness = 0.5;\n    \n    vec3 planePoint = vec3(uv * HEIGHT_MAP_RESOLUTION, 0.0);                    \n    vec3 lightPoint = vec3(((iMouse.xy / iResolution.yy) * TILING - offset) * HEIGHT_MAP_RESOLUTION, LIGHT_Z);\n    \n    vec3 lightDirection = normalize(lightPoint - planePoint);\n    vec3 viewDirection = vec3(0.0, 0.0, 1.0);\n    \n    float NdotL = max(dot(normal, lightDirection), 0.0);\n    float NdotV = max(dot(normal, viewDirection), 0.0);\n    float NdotM = max(dot(normal, normalize(viewDirection + lightDirection)), 0.0);\n    \n    vec3 pointLighting;\n    {                   \n        float distribution = calculateDistributionGGX(NdotM, roughness);\n        float divisionFactor = (roughness + 1.0);\n        divisionFactor = (divisionFactor * divisionFactor) / 8.0;\n        float geometry = calculateGeometrySchlickGGX(NdotV, divisionFactor) * \n                         calculateGeometrySchlickGGX(NdotL, divisionFactor);\n        float fresnel = calculateFresnelSchlick(STONE_REFLECTANCE, NdotL, AIR_REFLECTANCE);\n        float specular = (distribution * geometry * fresnel) / max(4.0 * NdotV * NdotL, 0.001); \n        \n        float lightDistance = length(lightPoint - planePoint);\n        float lightAttenuation = (LIGHT_RADIANCE * LIGHT_RADIANCE) / (lightDistance * lightDistance);\n        vec3 lightRadiance = LIGHT_COLOR * lightAttenuation;\n        \n        vec3 diffuse = oneMinus(fresnel) * oneMinus(metalness) * albedo / PI * ao;      \n        vec3 color = (diffuse + specular) * lightRadiance * NdotL;\n        \n        pointLighting = pow(color, vec3(1.0/2.2));  \n    }\n    \n    vec3 IBLLighting;\n    {\n        vec3 irradiance = textureLod(CUBE_MAP, normal, CUBE_MAP_LOD).rgb;\n        \n        vec3 specularColor = textureLod(CUBE_MAP, reflect(-viewDirection, normal), roughness * CUBE_MAP_LOD).rgb;\n            \n        float fresnel = calculateFresnelSchlick(STONE_REFLECTANCE, NdotV, AIR_REFLECTANCE);\n        float diffuseReflection = oneMinus(fresnel) * oneMinus(metalness);\n        \n        IBLLighting = ((diffuseReflection * albedo * irradiance * ao) + (specularColor * fresnel));\n    }\n    \n    float shadow = calculateShadow(lightPoint, LIGHT_SAMPLING_RANGE, HEIGHT_MAP, uv);\n    \n    pointLighting = mix(pointLighting, SHADOW_COLOR, shadow);   \n    fragColor = vec4(pointLighting + IBLLighting, 1.0);\n}","name":"Image","description":"","type":"image"}]}