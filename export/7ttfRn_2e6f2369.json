{"ver":"0.1","info":{"id":"7ttfRn","date":"1662583527","viewed":141,"name":"Playing with raymarching sdfs","username":"maxexmachina","description":"Drawing some procedural models with sdfs","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf","edu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITERS = 90;\nconst float MAX_DIST = 10.0;\nconst float EPS = 0.001;\n\nmat3 rotateX(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    return mat3(vec3(1, 0, 0),\n                vec3(0, c, -s),\n                vec3(0, s, c));\n}\n\nmat3 rotateY(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    return mat3(vec3(c, 0, -s),\n                vec3(0, 1, 0),\n                vec3(s, 0, c));\n}\n\nfloat sphereSDF(in vec3 p, in vec3 center, in float radius)\n{\n    return length(p - center) - radius;\n}\n\nfloat ellipsoidSDF(vec3 p, vec3 center, vec3 r)\n{\n  p = p - center;\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\nfloat roundedBoxSDF(in vec3 p, in vec3 size, float cornerRadius)\n{\n    vec3 q = abs(p) - size;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - cornerRadius;\n}\n\nfloat roundedCylinderSDF(vec3 p, float ra, float rb, float h)\n{\n  vec2 d = vec2(length(p.xy) - 2.0 * ra + rb, abs(p.z) - h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat octahedronSDF(vec3 p, vec3 center, float s)\n{\n  p = abs(p - center);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat planeSDF(in vec3 p, in float h)\n{\n    return p.y - h;\n}\n\nfloat smoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat displacement(vec3 p)\n{\n    return -0.2 * p.z;\n}\n\nfloat ramiels(in vec3 p)\n{\n    vec3 repetitionPeriod = vec3(2.2, 2.2, 0);\n    vec3 repetitionBounds = vec3(1, 1, 0);\n    vec3 l = p - repetitionPeriod * clamp(round(p / repetitionPeriod),\n                                        -repetitionBounds, repetitionBounds);                      \n    \n    return octahedronSDF(l, vec3(0, 0, -2.5), 1.5);\n}\n\nfloat baloons(in vec3 p)\n{   \n    vec3 tileRepetitionPeriod = vec3(0.7, 0.7, 0.7);\n    vec3 tileRepetitionBounds = vec3(2, 2, 0);\n    vec3 q = p - tileRepetitionPeriod * clamp(round(p / tileRepetitionPeriod),\n                                        -tileRepetitionBounds, tileRepetitionBounds);\n    \n    float offset = 0.5 * sin(2.0 * iTime);\n    \n    float d1 = ellipsoidSDF(q, vec3(0, 0, offset), vec3(0.2, 0.2, 0.3));\n    float d2 = displacement(q);\n    float cylinderResult = d1 + d2;\n    \n    return smoothUnion(roundedCylinderSDF(q, 0.2, 0.1, 0.05),\n                        cylinderResult, 0.2);\n                        \n}\n\nfloat plane(in vec3 p)\n{\n    return planeSDF(p, -4.0);\n}\n\nfloat map(in vec3 p)\n{\n    return min(min(baloons(p), ramiels(p)), plane(p));\n}\n\nvec3 rayMarch(in vec3 rayOrigin, in vec3 rayDirection, out bool hit, out int objIndex)\n{\n    vec3 p = rayOrigin;\n    float totalDist = 0.0;\n    \n    hit = false;\n    \n    for (int steps = 0; steps < MAX_ITERS; ++steps)\n    {\n        float distBaloons = baloons(p);\n        float distRamiels = ramiels(p);\n        float distPlane = plane(p);\n        \n        float unionDist = min(min(distBaloons, distRamiels), distPlane);\n        \n        if (unionDist < EPS)\n        {\n            hit = true;\n            if (distBaloons < EPS)\n            {\n                objIndex = 0;\n            }\n            else if (distRamiels < EPS)\n            {\n                objIndex = 1;\n            }\n            else\n            {\n                objIndex = 2;\n            }\n            break;\n        }\n        \n        totalDist += unionDist;\n        \n        if (totalDist > MAX_DIST)\n        {\n            break;\n        }\n        p += unionDist * rayDirection;\n    }\n    \n    return p;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPS;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec4 triplanarMap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat calcAmbientOcclusion(in vec3 p, in vec3 normal)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        float d = map(p + h * normal);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n//const vec3 lightColor = vec3 ( 0.8, 0.8, 0.3 );\nconst float gamma = 2.2;\nconst float pi = 3.1415926;\nconst float FDiel = 0.04;\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n    product = clamp ( product, 0.0, 1.0 ); // saturate\n    return mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float NdH2 = NdH * NdH;\n    float d = (m2 - 1.0) * NdH2 + 1.0;\n    return m2 / (pi * d * d);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n    return nl * nv / max ( nl, nv );\n}\n\nvec3 cookTorrance ( in float nl, in float nv, in float nh, in float vh, in vec3 f0, in float roughness )\n{\n    float D = D_GGX ( roughness, nh );\n    float G = G_neumann ( nl, nv );\n    return f0 * D * G;\n}\n\nconst float zoom = 2.0;\nconst float dollyDist = 6.0;\nconst float lightDist = 5.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float rotX = (iMouse.x / iResolution.x) * 2.0 * 3.14;\n    float rotY = (iMouse.y / iResolution.y) * 3.14;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;  \n    \n    float angle = 0.5 * iTime;\n    vec3 lightPos = vec3(lightDist, 3.0, lightDist);\n    \n    vec3 ro = vec3( dollyDist * sin(-rotX), 3.0, dollyDist * cos(-rotX) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 front = normalize( ta - ro );\n    vec3 right = normalize( cross(front, vec3(0.0, 1.0, 0.0) ) );\n    vec3 up = normalize( cross(right,front));\n    vec3 rd = normalize( uv.x * right + uv.y * up + zoom * front );\n    \n    fragColor = texture(iChannel2, rd);\n    \n    bool hit = false;\n    int objIndex = -1;\n    vec3 p = rayMarch(ro, rd, hit, objIndex);\n\n    if (hit) \n    {\n        vec3 l = normalize(lightPos - p);\n        vec3 v = normalize(ro - p);\n        vec3 h = normalize(l + v);\n        vec3 n = calcNormal(p);\n        float nv = max ( 0.0, dot ( n, v ));\n        float nl = max ( 0.0, dot ( n, l ));\n        float nh = max ( 0.0, dot ( n, h ));\n        float hl = max ( 0.0, dot ( h, l ));\n        float vh = max ( 0.0, dot ( h, v ));\n        float metallness = 0.0;\n        float roughness = 0.25;\n        vec3 base = vec3(0.0);\n        if (objIndex == 0)\n        {\n            metallness = 0.1;\n            roughness = 0.1;\n            base = triplanarMap(iChannel1, p, n, 8.0).xyz;\n        }\n        else if (objIndex == 1)\n        {\n            metallness = 0.0;\n            roughness = 0.8;\n            base = triplanarMap(iChannel3, p, n, 8.0).xyz;\n        }\n        else\n        {\n            metallness = 0.9;\n            base = texture(iChannel0, p.xz * 5.0).xyz * vec3(1.5);\n        }\n        \n        base = pow(base, vec3(gamma));\n        \n        vec3 lightColor = texture(iChannel2, reflect(-v, n)).xyz;\n        \n        vec3 F0 = mix ( vec3 ( FDiel ), base, metallness );\n        vec3 specFresnel = fresnel ( F0, nv );\n        vec3 spec = cookTorrance ( nl, nv, nh, vh, specFresnel, roughness ) * nl /\n              max ( 0.001, 4.0 * nl * nv );\n        vec3 diff = (vec3(1.0) - specFresnel) * nl / pi;\n        \n        float occ = calcAmbientOcclusion(p, n);\n        \n        fragColor = pow ( vec4 ( ( diff * mix ( base, vec3(0.0), metallness) + spec )\n            * lightColor * occ, 1.0 ), vec4 ( 1.0 / gamma ) );\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;  \n    float dist = length(uv) * sin(0.2 * iTime);\n    \n    float offset = 0.6 * pow(sin(10.0 * dist), 5.0) + 0.3 * cos(3.0 * dist);\n\n    vec3 col = vec3(0.1, 0.2 + offset, 0.8 + offset);\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}