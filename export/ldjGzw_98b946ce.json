{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// For performance, because I didn't need the extra precision\nprecision lowp float;\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction; // assumed to be a unit vector\n};\n\n// max terrain height\nconst float MAX_H = 2.5;\n\n// camera\nconst float CAMERA_HEIGHT = MAX_H + 15.0;\nconst float CAMERA_PITCH_DEG = 40.0;\n\n// sky color\nconst vec4 SKY = vec4(0.5,0.5,1.0,0.0);\n\n// terrain texture scale\nconst float SCALE = 50.0;\n\n\n// calcuations\nconst vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\nconst float INF = 1000000.0; // arbitrarily large number\nfloat CAMERA_PITCH_COS_RAD = cos(radians(CAMERA_PITCH_DEG));\nfloat CAMERA_PITCH_SIN_RAD = sin(radians(CAMERA_PITCH_DEG));\n//float NEG_CAMERA_PITCH_SIN_RAD = -1.0 * CAMERA_PITCH_SIN_RAD;\nconst float INV_SCALE = 1.0 / SCALE;\nconst float FD = 2.1583468527305348600363230610125;\n\n// codez...\n\n// Neat-o dynamic # of marches\nfloat Marches()\n{\n\treturn 50.0 + 40.0 * cos(iTime / 1.0);\n}\n\nbool TerrainMiss(Ray ray)\n{\n\treturn \n\t\t(ray.origin.z >= MAX_H && ray.direction.z >= 0.0) ||\n\t\t(ray.origin.z <= 0.0 && ray.direction.z <= 0.0);\n}\n\nRay CastRay(Ray ray, float dist)\n{\n\treturn Ray(ray.origin + ray.direction * dist, ray.direction);\n}\n\nfloat TerrainHeight(vec3 pos)\n{\n\treturn length(texture(iChannel0, INV_SCALE * pos.xy))/3.0 * MAX_H;\n}\n\nvec4 TerrainColor(vec3 pos)\n{\n\treturn texture(iChannel0, INV_SCALE * pos.xy);\n}\n\nvec4 RayMarch(Ray initialRay)\n{\n\tif (TerrainMiss(initialRay))\n\t{\n\t\treturn SKY;\n\t}\n\t\n\t// raycast directly to MAX_H if above MAX_H and casting downwards\n\tif (initialRay.origin.z > MAX_H && initialRay.direction.z < 0.0)\n\t{\n\t\tinitialRay = CastRay(initialRay, (initialRay.origin.z - MAX_H) / abs(initialRay.direction.z));\n\t}\n\t\n\tfloat marches = Marches();\n\tfloat delt = MAX_H / marches / abs(initialRay.direction.z);\n\t\n\tfor(float t = 0.0; t <= INF;  t++)\n\t{\n\t\tif (t > marches)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\t\t\n\t\tfloat dist = delt * t;\n\t\tRay ray = CastRay(initialRay, dist);\n\t\t\n\t\t// We marched our way right out of the terrain bounds...\n\t\tif (TerrainMiss(ray))\n\t\t{\n\t\t\treturn SKY;\n\t\t}\n\t\t\n\t\tif (ray.origin.z < TerrainHeight(ray.origin))\n\t\t{\n\t\t\t// todo: ray backtracing\n\t\t\treturn TerrainColor(ray.origin);\n\t\t}\n\t}\n\t\n\treturn RED;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// change pixel coordinate into world coordinates\n\tvec3 uv = vec3(fragCoord.xy / iResolution.xx, FD) - vec3(0.5, 0.5 * iResolution.y / iResolution.x, 0.0);\n\t\n\t// swizzle into standard coordinate system, so that z is up\n\tuv = uv.xzy;\n\t\n    float NEG_CAMERA_PITCH_SIN_RAD = -1.0 * CAMERA_PITCH_SIN_RAD;\n\tvec3 dir = normalize(mat3(1.0, 0.0, 0.0, 0.0, CAMERA_PITCH_COS_RAD, NEG_CAMERA_PITCH_SIN_RAD, 0.0, CAMERA_PITCH_SIN_RAD, CAMERA_PITCH_COS_RAD) * uv);\n\t\n\t// animate the camera\n\tvec3 pos = uv + vec3(1.0, 1.0 * iTime, CAMERA_HEIGHT);\n\t\n\t// raymarch the terrain\n\tfragColor = RayMarch(Ray(pos,dir));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldjGzw","date":"1385445354","viewed":446,"name":"Optimized terrain raymarcher","username":"kp1197","description":"Features:\n0. Dynamic # of marches\n1. Raycasts directly to max terrain height before entering raymarch loop\n2. Doesn't raymarch terrain misses\n3. marches with same LOD even at horizon (set CAMERA_PITCH_DEG to 0.0 to see)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","optimized"],"hasliked":0,"parentid":"","parentname":""}}