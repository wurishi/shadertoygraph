{"ver":"0.1","info":{"id":"cscXzs","date":"1680235658","viewed":92,"name":"Random Float Sample (Varying)","username":"remexre","description":"randomly samples from a circle","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint rotl(uint x, uint b) { return (x << b) | (x >> (32u - b)); }\n\nvoid QR(inout uint a, inout uint b, inout uint c, inout uint d) {\n  a += b;\n  d ^= a;\n  d = rotl(d, 16u);\n  c += d;\n  b ^= c;\n  b = rotl(b, 12u);\n  a += b;\n  d ^= a;\n  d = rotl(d, 8u);\n  c += d;\n  b ^= c;\n  b = rotl(b, 7u);\n}\n\nvoid DR(inout uvec4 a, inout uvec4 b, inout uvec4 c, inout uvec4 d) {\n  QR(a.x, b.x, c.x, d.x);\n  QR(a.y, b.y, c.y, d.y);\n  QR(a.z, b.z, c.z, d.z);\n  QR(a.w, b.w, c.w, d.w);\n\n  QR(a.x, b.y, c.z, d.w);\n  QR(a.y, b.z, c.w, d.x);\n  QR(a.z, b.w, c.x, d.y);\n  QR(a.w, b.x, c.y, d.z);\n}\n\nvoid update(inout uvec4 a, inout uvec4 b, inout uvec4 c, inout uvec4 d) {\n  for (uint i = 0u; i < 10u; i++)\n    DR(a, b, c, d);\n}\n\nfloat uniformUintToUniformFloat(uint u) { return float(u) / 4294967296.0; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const uvec4 seed = uvec4(0x11223344, 0x55667788, 0x99aabbcc, 0xddeeff00);\n  const float tau = 6.283185307179586;\n\n  // TODO: Really, this should be generated to an intermediate buffer that's\n  // the result of downsampling by a factor of 8, since each pixel only needs\n  // 64 bits randomness.\n  uvec4 a = uvec4(0x61707865, 0x3320646e, 0x79622d32, 0x6b206574);\n  uvec4 b = seed;\n  uvec4 c = uvec4(fragCoord.x, fragCoord.y, floatBitsToUint(iTime), 0);\n  uvec4 d = uvec4(0);\n  update(a, b, c, d);\n\n  // TODO: Some transformation should be applied to rFactor, so the\n  // (rFactor, theta) polar coordinate is uniformly distributed through the\n  // unit circle.\n  float rFactor = uniformUintToUniformFloat(a.x);\n  float theta = tau * uniformUintToUniformFloat(a.y);\n\n  // TODO: This should vary.\n  vec2 coordFromCenter = ((fragCoord / iResolution.xy) * 2.0) - 1.0;\n  float r = max(0.5, (length(coordFromCenter) - 0.3) * 10.0);\n\n  float y = r * cos(theta);\n  float x = r * sin(theta);\n\n  vec2 coord = (fragCoord + vec2(x, y)) / iResolution.xy;\n\n  fragColor = texture(iChannel0, coord);\n}\n","name":"Image","description":"","type":"image"}]}