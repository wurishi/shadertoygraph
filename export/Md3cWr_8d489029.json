{"ver":"0.1","info":{"id":"Md3cWr","date":"1518444675","viewed":2283,"name":"cross stitch britney","username":"flockaroo","description":"cross stitching on a cold winters day ...the moment you notice yourself getting old ;-)\nalso see shaderoo version here: [url]https://shaderoo.org/?shader=KQ0Lsl[/url]","likes":61,"published":1,"flags":32,"usePreview":1,"tags":["effect","crossstitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// cross stitch\n\n// mixing, lighting, ssao, color bleeding\n\n// configured for green-screen background.\n// uncomment your prefered bg in BufA from line 178 on\n\n#ifdef SHADEROO\n#define CrossSize floor((18.*sqrt(iResolution.x/650.))/(1.-.0003*iMouseData.z))\n#else\n#define CrossSize floor(18.*sqrt(iResolution.x/650.))\n#endif\n\nfloat getVal(vec2 coord)\n{\n    return texture(iChannel0,coord/iResolution.xy).w;\n}\n\nvec2 getGrad(vec2 coord,float eps)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getVal(coord+d.xy)-getVal(coord-d.xy),\n        getVal(coord+d.yx)-getVal(coord-d.yx)\n        )/eps/2.;\n}\n\nvec4 getRand(vec2 coord)\n{\n    vec2 rres=vec2(textureSize(iChannel1,0));\n    return texture(iChannel1,coord/rres);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 rnd=texture(iChannel1,fragCoord/iResolution.xy*.04);\n    vec4 rnd2=texture(iChannel1,fragCoord/iResolution.xy*.08);\n    vec4 col=texture(iChannel0,fragCoord/iResolution.xy);\n    // FIXME: +log(iResolution.x/600.) is not right because ao spread should be proportional \n    // to pixel size which scales by sqrt(res) ...\n    vec4 col1=texture(iChannel0,fragCoord/iResolution.xy,1.+log(CrossSize/20.)/log(2.));\n    vec4 col2=texture(iChannel0,fragCoord/iResolution.xy,3.+log(CrossSize/20.)/log(2.));\n    vec3 n=normalize(vec3(-getGrad(fragCoord,.1)-2.*getGrad(fragCoord,2.)+.75*(rnd.xy-.5)+.3*(rnd2.xy-.5),1.5));\n    //fragColor.xyz=vec3(1)*col.w*mix(vec3(1,.9,.8),vec3(1),step(.7,col.x));\n    float diff = clamp(dot(n,normalize(vec3(.5,.05,1.))),0.,1.);\n    float amb=0.5;\n    fragColor.xyz=mix(((col1.xyz-.5)*2.+.5)*amb,(.15*col.xyz+.55*col1.xyz+.3*col2.xyz),diff)*(.5+.5*sqrt(col.w));\n    vec2 sc=(fragCoord/iResolution.xy-.5)*2.;\n    vec2 ds=((fragCoord-iResolution.xy*.5)/iResolution.x);\n    // color bleeding\n    fragColor.xyz=mix(fragColor.xyz,col2.xyz,.2);\n    // ssao\n    fragColor.xyz*=vec3(clamp(1.-(.75*(col2.w-col1.w)-.25*(col1.w-col.w))*.2,0.,1.));\n    //fragColor.xyz=pow(fragColor.xyz,vec3(.8));\n    fragColor.xyz*=(1.-1.5*dot(ds,ds))*1.1\n    *(1.-smoothstep(.9,1.4,abs(sc.x)))\n    *(1.-smoothstep(.9,1.4,abs(sc.y)));\n    //fragColor.xyz=vec3(texture(iChannel0,fragCoord/iResolution.xy).w);\n    fragColor.w=1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// cross stitch\n\n// generating crosses, cloth patterns,...\n\n// configured for green-screen background.\n// uncomment your prefered bg in BufA from line 178 on\n\n#define PI 3.14159265359\t\n#define sin01(x) sin((x)*PI*2.)\n#define cos01(x) cos((x)*PI*2.)\n#define hump(x) cos(clamp(x,-.5,.5)*PI)\n#define humpW(x,w) cos(clamp((x)/(w),-.5,.5)*PI)\n#define hump01(x) sin(clamp(x,0.,1.)*PI)\n//#define hump(x) exp(-x*x)\n\n#ifdef SHADEROO\n#define CrossSize floor((18.*sqrt(iResolution.x/650.))/(1.-.0003*iMouseData.z))\n#else\n#define CrossSize floor(18.*sqrt(iResolution.x/650.))\n#endif\n\nfloat window(float x, float w)\n{\n    return exp(-x*x/w*w);\n}\n\nfloat tuch(vec2 coord)\n{\n    coord=coord*2.+.25;\n    vec4 rnd1=texture(iChannel1,coord*vec2(.001,.015));\n    vec4 rnd2=texture(iChannel1,coord*vec2(.015,.001));\n    float p=0.;\n    vec2 c=clamp(cos01(coord)*1.,-1.,1.);\n    vec2 c2=abs(clamp(sin01(coord*2.6),-1.,1.))*.5+.5;\n    //c2=vec2(1);\n    p=max(p,( c.x*c.y*.5+.5+.4*rnd2.x)*1.*abs(c.x+.4*(rnd2.x-.5))*c2.x);\n    p=max(p,(-c.x*c.y*.5+.5+.4*rnd1.x)*1.*abs(c.y+.4*(rnd1.x-.5))*c2.y);\n    return p;\n}\n\nfloat kreuz(vec2 coord)\n{\n    float stitchWidth=1.;\n    vec4 rnd=texture(iChannel1,(floor(coord*2.+.5))/256.);\n    coord+=abs(cos01(coord.x*1.))*abs(cos01(coord.y*1.))*.3*(rnd.xy-.5+.15*vec2(-1,1));\n    vec2 pc=fract(coord*2.+.5);\n    pc+=.0*sin01(pc);\n    float faser1=.7+.3*abs(sin01((pc.x+pc.y)*1.7-(pc.x-pc.y)*.5));\n    float faser2=.7+.3*abs(sin01((pc.x-pc.y)*1.7+(pc.x+pc.y)*.5));\n    return max(\n        -.15+humpW(pc.x+pc.y-1.,stitchWidth)*faser1*1.2,\n         .15+humpW(pc.x-pc.y   ,stitchWidth)*faser2*1.2\n        )*(.5+.5*hump01(pc.x)*hump01(pc.y))*2.4;\n}\n\nfloat gauss(vec2 v)\n{\n    return exp(-dot(v,v)*25.);\n}\n\nfloat kreuzAO(vec2 coord)\n{\n    //return 1.;\n    vec4 rnd=texture(iChannel1,(floor(coord*2.+.5))/256.);\n    coord+=abs(cos01(coord.x*1.))*abs(cos01(coord.y*1.))*.3*(rnd.xy-.5+.15*vec2(-1,1));\n    vec2 pc=fract(coord*2.+.5);\n    return 1.-.6*(gauss(pc)+gauss(pc-vec2(1,0))+gauss(pc-vec2(1,1))+gauss(pc-vec2(0,1)));\n}\n\nvec3 quant(vec3 c, ivec3 num)\n{\n    vec3 fnum=vec3(num);\n    return floor(c*(fnum-.0001))/(fnum-1.);\n}\n\n// HSV <-> RGB from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 quantHSV(vec3 c, ivec3 num)\n{\n    return hsv2rgb(quant(rgb2hsv(c)*vec3(1,1.1,1.1),num));\n}\n\nvec3 vid(vec2 coord)\n{\n    return clamp(quantHSV(texture(iChannel0,coord/iResolution.xy).xyz,ivec3(48,6,6)),0.,1.);\n}\n\nint idiv(int a, int b)\n{\n    return (a>=0)?a/b:(a-b+1)/b;\n}\n\nint imod(int a, int b)\n{\n    //return (a>=0)?a%b:(a+b*(-a/b+1))%b;\n    return (a>=0)?a%b:(b-((-a)%b))%b;\n}\n\nvoid zigzag(inout vec3 col, int period, ivec2 coord)\n{\n    col=((imod(coord.x,period)-period/2)==(imod(idiv(coord.x,period),2)*2-1)*coord.y)?vec3(0,.75,0):col;\n}\n\nvoid flower(inout vec3 col, ivec2 coord)\n{\n    float l=length(vec2(coord.xy));\n    col=(l<2.5)?vec3(.75,0,0):col;\n    col=(l<1.0)?vec3(.75,.75,0):col;\n}\n\nvoid frameLine(inout vec3 col, inout float isStitch, ivec2 coord, int w, bool trunk)\n{\n    //if (abs(coord.y)<w/2+coord.x%2) { isStitch = 0.; col=vec3(1); };\n    vec3 oldcol;\n    oldcol=col;\n    if(trunk) zigzag(col, w/2, coord);\n    if (oldcol!=col) isStitch=1.;\n    oldcol=col;\n    flower(col, ivec2(imod(coord.x,20)-10,coord.y+int(sin(float(idiv(coord.x,20))*2.)*float(w)*.35)));\n    if (oldcol!=col) isStitch=1.;\n}\n\nvoid frame(inout vec3 col, inout float isStitch, ivec2 coord, ivec2 s, int w)\n{\n    //if (coord.y-s.y<-s.y+w-coord.x%2) { isStitch = 0.; col=vec3(1); };\n    if (abs(coord.y-s.y)>s.y-w+imod(coord.x+1,2)) { isStitch = 0.; col=vec3(1); };\n    if (abs(coord.x-s.x)>s.x-w+imod(coord.y+1,2)) { isStitch = 0.; col=vec3(1); };\n    frameLine(col, isStitch, (coord+ivec2(0,-w/3)).xy, w,true);\n    frameLine(col, isStitch, (coord+ivec2(0,-s.y*2+w/3)).xy, w,true);\n    frameLine(col, isStitch, (coord+ivec2(-w/3,0)).yx, w,true);\n    frameLine(col, isStitch, (coord+ivec2(-s.x*2+w/3,0)).yx, w,true);\n}\n\nvec4 getRand(vec2 coord)\n{\n    coord+=1000.;\n    vec2 res=vec2(textureSize(iChannel1,0));\n    //return texture(iChannel1,coord/res);\n    vec2 p = floor(coord);\n    vec2 f = fract(coord);\n    // iq's special interpolation\n    f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    return texture(iChannel1,(p.xy + 0.5 + f.xy)/res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragCoord-=.5*(iMouse.xy-.5*iResolution.xy);\n    fragCoord+=3.0*sin(iTime*1.*vec2(1,1.7))*iResolution.y/400.;\n    vec3 clothCol = vec3(1,.95,.8);\n    //vec4 rnd=texture(iChannel1,fragCoord*.00005);\n    vec4 rnd=getRand(fragCoord*.012)-.5;\n    vec4 rndx=getRand(vec2(fragCoord.x*.008,.5))-.5;\n    vec4 rndy=getRand(vec2(.5,fragCoord.y*.008));\n    vec2 coord=(fragCoord+10.*vec2(rndy.x,rndx.y)+3.*rnd.xy);\n    float crossSize=CrossSize;\n    vec2 tc=coord/crossSize;\n    float tuchPat = sqrt(tuch(tc));\n    tuchPat=clamp(tuchPat,0.,1.);\n    //fragColor.xyz = vec3(0) + tuch(tc) * vec3(0,1,1) + kreuz(tc) * vec3(1,0,0);\n    vec2 vidCoord = floor(coord*2./crossSize+.5)/2.*crossSize;\n    //vec3 vidCol = vid(vidCoord)*vec3(fract(coord*2.*tuchScale+.5),0.);\n    #define FrameWidth 6\n    vec2 vc;\n    vc=(vidCoord-.5*iResolution.xy)*iResolution.xy/(iResolution.xy-float(FrameWidth-1)*crossSize)+.5*iResolution.xy;\n    //vc=vidCoord;\n    vec3 vidCol = vid(vc);\n    float kreuzPat=kreuz(tc);\n    float pixGrad=(1.-.5*length(fract(coord*2./crossSize+.5)-.5));\n\n    float isStitch = 1.;\n    \n    // green screen\n    isStitch = 1.-step(.5,dot(vidCol.xyz,vec3(-1,2,-1)));\n    \n    // black bg\n    //isStitch = step(0.01,dot(vidCol,vec3(.333)));\n    \n    // white bg\n    //isStitch = 1.-step(0.9,vidCol.x);\n    \n    // cloth bg\n    //isStitch = step(0.2,length(vidCol-clothCol));\n    \n    vidCol=vidCol*.75+.1; // suggestion by P_Malin - FIXME: want to tweak this and maybe get rid of HSV*vec3(1,1.1,1.1) in quantHSV. but eyes too tired now for this... ;-(\n    frame(vidCol, isStitch, ivec2(floor(vidCoord*2./crossSize)),ivec2(iResolution.xy/crossSize+.5),FrameWidth);\n    \n    //float allPat = mix(tuchPat,isStitch,isStitch*kreuzPat);\n    float allPat = max(tuchPat,isStitch*kreuzPat);\n    vec3 col = mix(vec3(1,.9,.8),vidCol*1.5,isStitch*kreuzPat);\n    col=vec3(1);\n    //if (fragColor.xyz!=tuchCol) fragColor.xyz*=vidCol*1.7;\n    //fragColor.xyz*=mix(vec3(1),vidCol,isStitch);\n    fragColor.xyz = allPat*col;\n    //fragColor.xyz = vec3(0)+kreuzPat;\n    vec2 ds=(fragCoord.xy-iResolution.xy*.5)/iResolution.xy*2.;\n    fragColor.xyz = (allPat>tuchPat)?vidCol*kreuzAO(tc):clothCol;\n    /*fragColor.xyz = mix(\n        vec3(1,.9,.8)*tuchPat,\n        vidCol*1.5,\n        isStitch*clamp(kreuzPat,0.,1.)\n        );*/\n    //fragColor.xyz = vec3(0)+kreuzPat;\n    fragColor.w=allPat\n    +.04*(getRand(fragCoord/CrossSize*20.*2.).y-.5)\n    +.08*(getRand(fragCoord/CrossSize*20.*1.).y-.5)\n    +.16*(getRand(fragCoord/CrossSize*20.*.5).y-.5)\n        ;\n}\n\n","name":"Buf A","description":"","type":"buffer"}]}