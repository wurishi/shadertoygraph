{"ver":"0.1","info":{"id":"XtlyWH","date":"1504628307","viewed":258,"name":"Manual multi-scale grid","username":"etale_cohomology","description":"Fork of https://www.shadertoy.com/view/XllyD8\n\nI'm addicted to grids (also, it's the only thing I can do)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","grid","math","tutorial","abs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/XllyD8\n\n#define SCALE 1. * (40. * (1.01 + sin(.4 * iTime)))  // Global scale!\n#define FSAA 4.  // Fullscreen antialiasing!\n\n#define GRID_SCALE0_FREQ .25\n#define GRID_SCALE1_FREQ 1.\n#define GRID_SCALE2_FREQ 4.\n\n#define MAX_GRID_SCALE0_SCALE (32. * GRID_SCALE0_FREQ)\n#define MAX_GRID_SCALE1_SCALE (32. * GRID_SCALE1_FREQ)\n#define MAX_GRID_SCALE2_SCALE (32. * GRID_SCALE2_FREQ)\n\n#define RGB_LIGHT vec3(.96)\n#define RGB_DARK  vec3(.04)\n#define RGB_GRAY  vec3(.7)\n#define RGB_BLUE  vec3(.0, .5, 1.)\n\n// I wonder if there's a shorter way to write this...\nvec2 df_op_repeat(vec2 point, vec2 frequency){\n    vec2 half_frequency = .5 * frequency;\n    return mod(point - half_frequency, frequency) - half_frequency;\n    //return frequency * (fract(point / frequency - .5) - .5);  // By ollj!\n}\n\nvec3 rgb_grid(vec2 uv, float aa){\n    //uv.y += sin(uv.x + iTime);\n\n    // This is the manual part. Instead of manually adding each scale (either unrolled or by looping through each scale),\n    // perhaps there's a way do write a function that does this *without* loops!\n    vec2 grid_scale0 = abs(df_op_repeat(uv, vec2(GRID_SCALE0_FREQ)));\n    vec2 grid_scale1 = abs(df_op_repeat(uv, vec2(GRID_SCALE1_FREQ)));\n    vec2 grid_scale2 = abs(df_op_repeat(uv, vec2(GRID_SCALE2_FREQ)));\n\n    // This is the manual part. Instead of manually adding each scale (either unrolled or by looping through each scale),\n    // perhaps there's a way do write a function that does this *without* loops!\n    vec3 rgb = RGB_LIGHT;  // Background color!\n    rgb = mix(rgb, RGB_GRAY, smoothstep(aa, .0, min(grid_scale0.x, grid_scale0.y)) * float(SCALE < MAX_GRID_SCALE0_SCALE));\n    rgb = mix(rgb, RGB_BLUE, smoothstep(aa, .0, min(grid_scale1.x, grid_scale1.y)) * float(SCALE < MAX_GRID_SCALE1_SCALE));\n    rgb = mix(rgb, RGB_DARK, smoothstep(aa, .0, min(grid_scale2.x, grid_scale2.y)) * float(SCALE < MAX_GRID_SCALE2_SCALE));\n    return rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float time = .1 * iTime;\n    uv = mat2(cos(time), -sin(time), sin(time), cos(time)) * uv;\n\n    float grid_aa = FSAA * SCALE / iResolution.y;\n    fragColor.rgb = rgb_grid(uv, grid_aa);\n}\n","name":"Image","description":"","type":"image"}]}