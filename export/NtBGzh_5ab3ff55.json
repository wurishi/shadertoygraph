{"ver":"0.1","info":{"id":"NtBGzh","date":"1623950435","viewed":352,"name":"LottesRVM","username":"TimothyLottes","description":"Retro Video Monitor - New CRT scalar shader with 3 visual modes inspired by {Sony BVM/PVM at 240p, Sony Wega TV 480p, Vintage Arcade}","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["crt","scalar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//_____________________________/\\_______________________________\n//==============================================================\n//                      SETUP FOR RVM\n//--------------------------------------------------------------\n// Example of integrating\n// What to do before including header (below)\n//==============================================================\n// Modes {0:=BVM/PVM 240p-like,1:=Wega TV 480p-like,2:=arcade}\n#define RVM_MODE 0\n// Select portability paths\n#define RVM_GLSL 1\n// #define RVM_HLSL 1\n// Select 32-bit or packed 16-bit source path\n#define RVM_32BIT 1\n// Debug pixels\n//#define RVM_ZOOM 1\n// Toggle on/off warping of screen\n#define RVM_WARP 1\n// Debug split line position (comment out to remove)\n#define RVM_SPLIT 400\n//_____________________________/\\_______________________________\n//==============================================================\n//                SPECIFIC TO SHADERTOY EXAMPLE\n//==============================================================\n// Horizonal scan blur\n//  0.50 := blurry\n//  0.75 := default\n//  1.00 := blocky\n#define INPUT_BLUR 0.75\n//--------------------------------------------------------------\n// Since shadertoy doesn't have sRGB textures\n// And we need linear input into shader\n// Don't do this in your code\nfloat FromSrgb1(float c){\n return (c<=0.04045)?c*(1.0/12.92):\n  pow(c*(1.0/1.055)+(0.055/1.055),2.4);}\n//--------------------------------------------------------------\nvec3 FromSrgb(vec3 c){return vec3(\n FromSrgb1(c.r),FromSrgb1(c.g),FromSrgb1(c.b));}\n//--------------------------------------------------------------\n// Output pixels per input pixel (can be fractional)\n// Enables consistent output regardless of viewport size\n#if RVM_MODE==0\n #define INPUT_DOT 4.8\n#else\n #define INPUT_DOT 2.8\n#endif\n//--------------------------------------------------------------\n// Setup the function which returns gather4 results\n// Have to emulate gather4 as ShaderToy doesn't support it\n// Gather 4 ordering\n//  W Z\n//  X Y\nvec4 RvmR4F(vec2 uv){\n // For shadertoy, scale to get native texels in the image\n uv*=iResolution.xy/vec2(INPUT_DOT,INPUT_DOT);\n vec2 px=vec2(1.0,1.0)/iChannelResolution[0].xy;\n uv*=px;\n px*=0.5;\n vec4 o;\n o.w=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x,-px.y),0.0).r);\n o.z=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x,-px.y),0.0).r);\n o.x=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x, px.y),0.0).r);\n o.y=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x, px.y),0.0).r);\n return o;}\n//\nvec4 RvmG4F(vec2 uv){\n // For shadertoy, scale to get native texels in the image\n uv*=iResolution.xy/vec2(INPUT_DOT,INPUT_DOT);\n vec2 px=vec2(1.0,1.0)/iChannelResolution[0].xy;\n uv*=px;\n px*=0.5;\n vec4 o;\n o.w=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x,-px.y),0.0).g);\n o.z=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x,-px.y),0.0).g);\n o.x=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x, px.y),0.0).g);\n o.y=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x, px.y),0.0).g);\n return o;}\n//\nvec4 RvmB4F(vec2 uv){\n // For shadertoy, scale to get native texels in the image\n uv*=iResolution.xy/vec2(INPUT_DOT,INPUT_DOT);\n vec2 px=vec2(1.0,1.0)/iChannelResolution[0].xy;\n uv*=px;\n px*=0.5;\n vec4 o;\n o.w=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x,-px.y),0.0).b);\n o.z=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x,-px.y),0.0).b);\n o.x=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x, px.y),0.0).b);\n o.y=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x, px.y),0.0).b);\n return o;}\n \n \n\n\n\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________.._______________________________\n//==============================================================\n//\n//\n//             [RVM] RETRO VIDEO MONITOR - v20210519\n//                         _\n//                     by  |imothy Lottes\n//\n//\n//==============================================================\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________.._______________________________\n//==============================================================\n//\n//                           ABOUT\n//\n//--------------------------------------------------------------\n// RVM is a CRT stylized up-sampler with three modes\n// RVM requires linear color inputs {0.0 to 1.0} ranged\n// Non-integer scaling works best\n// Using RVM_WARP also improves output\n//--------------------------------------------------------------\n// RVM_MODE 0\n// ==========\n// Designed for '240p' and similar input resolutions\n// Meaning 4x or more scaling on a dimension\n// So a 1080p output needs to have <= 270 pix height input\n// Inspired by Sony PVM and BVM display output\n// No grille, instead focusing on scanlines\n// Scanline thickness is variable to simulate phosphor bloom\n// Scanline thickness is highest at color peak\n// Output intensity increases to normalize out scan thining\n// Thus there is only a slight reduction in peak brightness\n//--------------------------------------------------------------\n// RVM_MODE 1\n// ==========\n// Designed for '480p' and similar input resolutions\n// No visible scanlines, instead this focuses on grille\n// Inspired by Sony Wega TV display output\n// Filters mostly vertical since grille masks the horizontal\n// Using similar normalization tick to maintain peak brightness \n//--------------------------------------------------------------\n// RVM_MODE 2\n// ==========\n// Same as mode 1 except this has a slot mask instead of grille\n// Inspired by vintage arcade CRTs\n//--------------------------------------------------------------\n// TODO\n// ====\n// - This is an initial prototype\n// - Currently only tested for RVM_32BIT and RVM_GLSL\n// - HLSL and 16BIT paths might have bugs\n// - Put in approximations\n//==============================================================\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________.._______________________________\n//==============================================================\n//\n//          LICENSE = UNLICENSE (aka PUBLIC DOMAIN)\n//\n//--------------------------------------------------------------\n// This is free and unencumbered software released into the \n// public domain.\n//--------------------------------------------------------------\n// Anyone is free to copy, modify, publish, use, compile, sell, \n// or distribute this software, either in source code form or as\n// a compiled binary, for any purpose, commercial or \n// non-commercial, and by any means.\n//--------------------------------------------------------------\n// In jurisdictions that recognize copyright laws, the author or\n// authors of this software dedicate any and all copyright \n// interest in the software to the public domain. We make this\n// dedication for the benefit of the public at large and to the\n// detriment of our heirs and successors. We intend this \n// dedication to be an overt act of relinquishment in perpetuity\n// of all present and future rights to this software under \n// copyright law.\n//--------------------------------------------------------------\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\n// KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE \n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR \n// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT \n// OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n// DEALINGS IN THE SOFTWARE.\n//--------------------------------------------------------------\n// For more information, please refer to \n// <http://unlicense.org/>\n//==============================================================\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________.._______________________________\n//==============================================================\n//                         PORTABILITY\n//==============================================================\n#define RVM_2PI 6.28318530718\n//--------------------------------------------------------------\n#ifdef RVM_GLSL\n #define RvmF1 float\n #define RvmF2 vec2\n #define RvmF2_(x) vec2((x),(x))\n #define RvmF3 vec3\n #define RvmF3_(x) vec3((x),(x),(x))\n #define RvmF4 vec4\n #define RvmU1 uint\n #define RvmFractF1 fract\n // As close to the V_COS_F32 as possible without intrinsic\n #define RvmNCosF2(x) cos((x)*RvmF2_(RVM_2PI))\n #define RvmRcpF1(x) (1.0/(x))\n #define RvmRcpF2(x) (RvmF2_(1.0)/(x))\n #define RvmRcpF3(x) (RvmF3_(1.0)/(x))\n #define RvmSatF1(x) clamp((x),0.0,1.0)\n #define RvmSatF2(x) clamp((x),0.0,1.0)\n//--------------------------------------------------------------\n RvmF1 RvmMax3F1(RvmF1 a,RvmF1 b,RvmF1 c){\n  return max(a,max(b,c));}\n//--------------------------------------------------------------\n RvmF2 RvmMax3F2(RvmF2 a,RvmF2 b,RvmF2 c){\n  return max(a,max(b,c));}\n//--------------------------------------------------------------\n #ifdef RVM_16BIT\n  #define RvmH1 float16_t\n  #define RvmH2 f16vec2\n  #define RvmH2_(x) f16vec2((x),(x))\n  #define RvmH3 f16vec3\n  #define RvmH3_(x) f16vec3((x),(x),(x))\n  #define RvmH4 f16vec4\n  #define RvmFractH1 fract\n  #define RvmNCosH2(x) cos((x)*RvmH2_(RVM_2PI))\n  #define RvmRcpH1(x) (RvmH1(1.0)/(x))\n  #define RvmRcpH2(x) (RvmH2_(1.0)/(x))\n  #define RvmRcpH3(x) (RvmH3_(1.0)/(x))\n  #define RvmSatH1(x) clamp((x),RvmH1(0.0),RvmH1(1.0))\n  #define RvmSatH2(x) clamp((x),RvmH2(0.0,0.0),RvmH2(1.0,1.0))\n//--------------------------------------------------------------\n  RvmH1 RvmMax3H1(RvmH1 a,RvmH1 b,RvmH1 c){\n   return max(a,max(b,c));}\n//--------------------------------------------------------------\n  RvmH2 RvmMax3H2(RvmH2 a,RvmH2 b,RvmH2 c){\n   return max(a,max(b,c));}\n//--------------------------------------------------------------\n #endif\n#endif\n//==============================================================\n#ifdef RVM_HLSL\n #define RvmF1 float\n #define RvmF2 float2\n #define RvmF2_(x) float2((x),(x))\n #define RvmF3 float3\n #define RvmF3_(x) float3((x),(x),(x))\n #define RvmF4 float4\n #define RvmU1 uint\n // Better match to the GCN opcode V_FRACT_F32\n RvmF1 RvmFractF1(RvmF1 x){return x-floor(x);}\n #define RvmNCosF2(x) cos((x)*RvmF2_(RVM_2PI))\n #define RvmRcpF1(x) rcp(x)\n #define RvmRcpF2(x) rcp(x)\n #define RvmRcpF3(x) rcp(x)\n #define RvmSatF1(x) saturate(x)\n #define RvmSatF2(x) saturate(x)\n//--------------------------------------------------------------\n RvmF1 RvmMax3F1(RvmF1 a,RvmF1 b,RvmF1 c){\n  return max(a,max(b,c));}\n//--------------------------------------------------------------\n RvmF2 RvmMax3F2(RvmF2 a,RvmF2 b,RvmF2 c){\n  return max(a,max(b,c));}\n//--------------------------------------------------------------\n #ifdef RVM_16BIT\n  #define RvmH1 min16float\n  #define RvmH2 min16float2\n  #define RvmH2_(x) min16float2((x),(x))\n  #define RvmH3 min16float3\n  #define RvmH3_(x) min16float3((x),(x),(x))\n  #define RvmH4 min16float4\n  RvmH1 RvmFractH1(RvmH1 x){return x-floor(x);}\n  #define RvmNCosH2(x) cos((x)*RvmH2_(RVM_2PI))\n  #define RvmRcpH1(x) rcp(x)\n  #define RvmRcpH2(x) rcp(x)\n  #define RvmRcpH3(x) rcp(x)\n  #define RvmSatH1(x) saturate(x)\n  #define RvmSatH2(x) saturate(x)\n//--------------------------------------------------------------\n  RvmH1 RvmMax3H1(RvmH1 a,RvmH1 b,RvmH1 c){\n   return max(a,max(b,c));}\n//--------------------------------------------------------------\n  RvmH2 RvmMax3H2(RvmH2 a,RvmH2 b,RvmH2 c){\n   return max(a,max(b,c));}\n//--------------------------------------------------------------\n #endif\n#endif\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________.._______________________________\n//==============================================================\n//                        FILTER CONTROL\n//==============================================================\n#define RVM_DARK (7.0/8.0)\n#define RVM_SCAN_DIV 3.0\n#define RVM_SCAN_MAX (8.0/15.0)\n#define RVM_SCAN_MIN (RVM_SCAN_DIV*RVM_SCAN_MAX)\n#define RVM_SCAN_SIZ (RVM_SCAN_MAX-RVM_SCAN_MIN)\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________.._______________________________\n//==============================================================\n//                     FILTER ENTRY F32\n//--------------------------------------------------------------\n// Input must be linear {0.0 to 1.0}\n// Output color is linear\n//==============================================================\n#ifdef RVM_32BIT\n // Paired gaussian approximation\n RvmF2 RvmPolyF2(RvmF2 x){\n  x=RvmSatF2(-x*x+RvmF2(1.0,1.0));return x*x;}\n//==============================================================\n RvmF3 RvmF(\n//--------------------------------------------------------------\n // SV_POSITION, fragCoord.xy, etc\n RvmF2 ipos,\n//--------------------------------------------------------------\n // inputSize / outputSize (in pixels)\n RvmF2 inputSizeDivOutputSize,     \n//--------------------------------------------------------------\n // 0.5 * inputSize (in pixels)\n RvmF2 halfInputSize,\n//--------------------------------------------------------------\n // 1.0 / inputSize (in pixels)\n RvmF2 rcpInputSize,\n//--------------------------------------------------------------\n // 2.0 / outputSize (in pixels)\n RvmF2 twoDivOutputSize,   \n//--------------------------------------------------------------\n // inputSize.y\n RvmF1 inputHeight,\n//--------------------------------------------------------------\n // Warp scanlines\n //  0.0 = no warp\n //  1.0/64.0 = light warping\n //  1.0/32.0 = more warping\n // Want x and y warping to be different (based on aspect)\n RvmF2 warp,\n//--------------------------------------------------------------\n // Control horizontal blur\n //  0.50 := blurry\n //  0.75 := default\n //  1.00 := blocky\n RvmF1 blur,\n // Derived constant {0.5*blur,-0.5*blur,-1.5*blur,-2.5*blur}\n RvmF4 blur4){\n//--------------------------------------------------------------\n  #ifdef RVM_ZOOM\n   ipos=floor(ipos*RvmF2(0.5));\n  #endif\n//--------------------------------------------------------------\n  // Optional apply warp\n  RvmF2 pos;\n  #ifdef RVM_WARP\n   // Convert to {-1 to 1} range\n   pos=ipos*twoDivOutputSize-RvmF2_(1.0);\n   // Distort pushes image outside {-1 to 1} range\n   pos*=RvmF2_(1.0)+pos.yx*pos.yx*warp;\n   // Vignette to kill off-image content\n   RvmF2 vin2=RvmSatF2(pos*pos);  \n   // 1-((1-x)*(1-y)) -> (1-x)*y+x\n   RvmF1 vin=(RvmF1(1.0)-vin2.x)*vin2.y+vin2.x;\n   vin=RvmSatF1((-vin)*inputHeight+inputHeight);   \n   // Leave in {0 to inputSize}\n   pos=pos*halfInputSize+halfInputSize;     \n  #else\n   pos=ipos*inputSizeDivOutputSize;\n  #endif\n//--------------------------------------------------------------\n  // Get to center for first gather 4\n  //  W Z W Z\n  //  X Y X Y\n  #if RVM_MODE==0\n   RvmF2 g=floor(pos+RvmF2(-1.5,-0.5))+RvmF2_(1.0);\n   RvmF2 gp=g*rcpInputSize;\n   g.y-=RvmF1(0.5);\n  #endif\n//--------------------------------------------------------------\n  // Get to center for first gather 4\n  //  W Z\n  //  X Y\n  //  W Z\n  //  X Y\n  #if RVM_MODE!=0\n   RvmF2 g=floor(pos+RvmF2(-0.5,-1.5))+RvmF2_(1.0);\n   RvmF2 gp=g*rcpInputSize;\n   g.x-=RvmF1(0.5);\n  #endif\n//--------------------------------------------------------------\n  // Using gather4 to keep in SoA form for packed 16-bit\n  // Both 32-bit and 16-bit paths use same logic\n  // Gather 4 ordering\n  //  W Z\n  //  X Y\n  // 4x2 sampled footprint\n  //  _S_ _T_\n  //  W Z W Z\n  //  X Y X Y\n  #if RVM_MODE==0\n   RvmF4 colRS=RvmR4F(gp);\n   RvmF4 colGS=RvmG4F(gp);\n   RvmF4 colBS=RvmB4F(gp);\n   gp.x+=RvmF1(2.0*rcpInputSize.x);\n   RvmF4 colRT=RvmR4F(gp);\n   RvmF4 colGT=RvmG4F(gp);\n   RvmF4 colBT=RvmB4F(gp);\n  #endif\n//--------------------------------------------------------------\n  // 2x4 sampled footprint\n  //  W Z |s\n  //  X Y |s\n  //  W Z :t\n  //  X Y :t\n  #if RVM_MODE!=0\n   RvmF4 colRS=RvmR4F(gp);\n   RvmF4 colGS=RvmG4F(gp);\n   RvmF4 colBS=RvmB4F(gp);\n   gp.y+=RvmF1(2.0*rcpInputSize.y);\n   RvmF4 colRT=RvmR4F(gp);\n   RvmF4 colGT=RvmG4F(gp);\n   RvmF4 colBT=RvmB4F(gp);\n  #endif\n//--------------------------------------------------------------\n  // Debug view without effect\n  #ifdef RVM_SPLIT\n   if(ipos.x<RvmF1(RVM_SPLIT)){\n    return RvmF3(colRS.z,colGS.z,colBS.z);}\n  #endif\n//--------------------------------------------------------------\n  // Horizontal kernel is simple gaussian filter approximation\n  #if RVM_MODE==0\n   RvmF1 offB=RvmF1(pos.x-g.x);\n   RvmF2 offS=RvmF2(offB,offB)*RvmF2_(blur)+blur4.xy;\n   RvmF2 offT=RvmF2(offB,offB)*RvmF2_(blur)+blur4.zw;\n   RvmF2 horS=RvmPolyF2(offS);\n   RvmF2 horT=RvmPolyF2(offT);\n  #endif\n//--------------------------------------------------------------\n  // Vertical\n  #if RVM_MODE!=0\n   RvmF1 offB=RvmF1(pos.y-g.y);\n   RvmF2 offS=RvmF2(offB,offB)*RvmF2_(blur)+blur4.xy;\n   RvmF2 offT=RvmF2(offB,offB)*RvmF2_(blur)+blur4.zw;\n   RvmF2 horS=RvmPolyF2(offS);\n   RvmF2 horT=RvmPolyF2(offT);\n  #endif\n//--------------------------------------------------------------\n  // Get kernel totals and then rcp\n  RvmF2 hor0=horS+horT;\n  RvmF1 horD=RvmRcpF1(hor0.x+hor0.y);\n//--------------------------------------------------------------\n  // Get rid of off-screen pixels on edge\n  #ifdef RVM_WARP\n   horD*=RvmF1(vin);\n  #endif\n//--------------------------------------------------------------\n  // Apply horizontal filter, up and down sums\n  #if RVM_MODE==0\n   RvmF2 colRU2=colRS.wz*horS+colRT.wz*horT;\n   RvmF2 colGU2=colGS.wz*horS+colGT.wz*horT;\n   RvmF2 colBU2=colBS.wz*horS+colBT.wz*horT;\n   RvmF2 colRD2=colRS.xy*horS+colRT.xy*horT;\n   RvmF2 colGD2=colGS.xy*horS+colGT.xy*horT;\n   RvmF2 colBD2=colBS.xy*horS+colBT.xy*horT;\n//--------------------------------------------------------------\n   // Pair total so that {x:=up, y:=down}\n   // Expensive transpose from pairs of taps, to pairs of lines\n   RvmF2 colRL=RvmF2(colRU2.x+colRU2.y,colRD2.x+colRD2.y);\n   RvmF2 colGL=RvmF2(colGU2.x+colGU2.y,colGD2.x+colGD2.y);\n   RvmF2 colBL=RvmF2(colBU2.x+colBU2.y,colBD2.x+colBD2.y);\n  #endif\n//--------------------------------------------------------------\n  // Apply vertical filter\n  #if RVM_MODE!=0\n   RvmF2 colRL=colRS.wz*horS.xx+colRS.xy*horS.yy+\n               colRT.wz*horT.xx+colRT.xy*horT.yy;  \n   RvmF2 colGL=colGS.wz*horS.xx+colGS.xy*horS.yy+\n               colGT.wz*horT.xx+colGT.xy*horT.yy;  \n   RvmF2 colBL=colBS.wz*horS.xx+colBS.xy*horS.yy+\n               colBT.wz*horT.xx+colBT.xy*horT.yy;  \n  #endif\n//--------------------------------------------------------------\n  // Normalize by kernel total\n  colRL*=RvmF2_(horD);\n  colGL*=RvmF2_(horD);\n  colBL*=RvmF2_(horD);\n//--------------------------------------------------------------\n  #if RVM_MODE==0\n   // Get channel maximums and shape\n   RvmF2 colML=RvmMax3F2(colRL,colGL,colBL);\n   // TODO: Approximation...\n   colML=sqrt(colML);\n//--------------------------------------------------------------\n   // Convert shaped channel maximums into scan width\n   RvmF2 scnL=colML*RvmF2_(RVM_SCAN_SIZ)+RvmF2_(RVM_SCAN_MIN);\n   RvmF1 offY=RvmF1(pos.y-g.y);\n   scnL.x=( offY)*scnL.x;  \n   scnL.y=(-offY)*scnL.y+scnL.y;  \n   scnL=min(RvmF2_(0.5),scnL);\n   scnL=RvmNCosF2(scnL);\n   scnL=scnL*RvmF2_(0.5)+RvmF2_(0.5);\n//--------------------------------------------------------------\n   // Normalize for reduction in scan width\n   RvmF2 nrmL=RvmF2_(1.0)-colML;\n   nrmL=nrmL*RvmF2_(RVM_SCAN_MIN/RVM_SCAN_MAX-1.0)+RvmF2_(1.0);\n   scnL*=nrmL;\n  #endif\n//--------------------------------------------------------------\n  #if RVM_MODE!=0\n   RvmF1 offX=RvmF1(pos.x-g.x);\n   RvmF2 scnL=RvmF2(RvmF1(1.0)-offX,offX);\n  #endif\n//--------------------------------------------------------------\n  // Apply scan\n  colRL*=scnL; \n  colGL*=scnL;   \n  colBL*=scnL;\n//--------------------------------------------------------------\n  // Merge contribution from both nearest lines\n  RvmF3 col;\n  col.r=colRL.x+colRL.y;\n  col.g=colGL.x+colGL.y;\n  col.b=colBL.x+colBL.y;\n//--------------------------------------------------------------\n  // Grille\n  #if RVM_MODE==1\n   RvmF1 lim=RvmF1(1.0/((1.0/3.0)+(2.0/3.0)*RVM_DARK));\n   RvmF3 colD=col*col;\n   colD*=RVM_DARK;\n   RvmF3 amp=RvmRcpF3(\n    RvmF3_(lim*1.0/3.0)+RvmF3_(lim*2.0/3.0)*col);\n   ipos.x=RvmFractF1(ipos.x*RvmF1(1.0/3.0));\n   col*=amp;colD*=amp;\n   if(     ipos.x<RvmF1(1.0/3.0)){colD.r=col.r;}\n   else if(ipos.x<RvmF1(2.0/3.0)){colD.g=col.g;}\n   else                          {colD.b=col.b;}\n   return colD;\n  #endif\n//--------------------------------------------------------------\n  // Slot mask\n  #if RVM_MODE==2\n   RvmF1 lim=RvmF1(1.0/((3.0/12.0)+(9.0/12.0)*RVM_DARK));\n   if(RvmFractF1(ipos.x*RvmF1(1.0/6.0))>RvmF1(0.5))\n    ipos.y+=RvmF1(2.0);\n   ipos.y=RvmFractF1(ipos.y*RvmF1(1.0/4.0));\n   RvmF3 colD=col*col;\n   colD*=RVM_DARK;\n   RvmF3 amp=RvmRcpF3(\n    RvmF3_(lim*3.0/12.0)+RvmF3_(lim*9.0/12.0)*col);\n   ipos.x=RvmFractF1(ipos.x*RvmF1(1.0/3.0));\n   col*=amp;colD*=amp;\n   if(ipos.y>RvmF1(1.0/4.0)){\n    if(     ipos.x<RvmF1(1.0/3.0)){colD.r=col.r;}\n    else if(ipos.x<RvmF1(2.0/3.0)){colD.g=col.g;}\n    else                          {colD.b=col.b;}}\n   return colD;\n  #endif\n//--------------------------------------------------------------\n  return col;}\n#endif\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________.._______________________________\n//==============================================================\n//                     FILTER ENTRY F16\n//--------------------------------------------------------------\n// Input must be linear {0.0 to 1.0}\n// Output color is linear\n//==============================================================\n#ifdef RVM_16BIT\n // Paired gaussian approximation\n RvmH2 RvmPolyH2(RvmH2 x){\n  x=RvmSatH2(-x*x+RvmH2(1.0,1.0));return x*x;}\n//==============================================================\n RvmH3 RvmH(\n//--------------------------------------------------------------\n // SV_POSITION, fragCoord.xy, etc\n RvmF2 ipos,\n//--------------------------------------------------------------\n // inputSize / outputSize (in pixels)\n RvmF2 inputSizeDivOutputSize,     \n//--------------------------------------------------------------\n // 0.5 * inputSize (in pixels)\n RvmF2 halfInputSize,\n//--------------------------------------------------------------\n // 1.0 / inputSize (in pixels)\n RvmF2 rcpInputSize,\n//--------------------------------------------------------------\n // 2.0 / outputSize (in pixels)\n RvmF2 twoDivOutputSize,   \n//--------------------------------------------------------------\n // inputSize.y\n RvmF1 inputHeight,\n//--------------------------------------------------------------\n // Warp scanlines\n //  0.0 = no warp\n //  1.0/64.0 = light warping\n //  1.0/32.0 = more warping\n // Want x and y warping to be different (based on aspect)\n RvmF2 warp,\n//--------------------------------------------------------------\n // Control horizontal blur\n //  0.50 := blurry\n //  0.75 := default\n //  1.00 := blocky\n RvmH1 blur,\n // Derived constant {0.5*blur,-0.5*blur,-1.5*blur,-2.5*blur}\n RvmH4 blur4){\n//--------------------------------------------------------------\n  #ifdef RVM_ZOOM\n   ipos=floor(ipos*RvmF2(0.5));\n  #endif\n//--------------------------------------------------------------\n  // Optional apply warp\n  RvmF2 pos;\n  #ifdef RVM_WARP\n   // Convert to {-1 to 1} range\n   pos=ipos*twoDivOutputSize-RvmF2_(1.0);\n   // Distort pushes image outside {-1 to 1} range\n   pos*=RvmF2_(1.0)+pos.yx*pos.yx*warp;\n   // Vignette to kill off-image content\n   RvmF2 vin2=RvmSatF2(pos*pos);  \n   // 1-((1-x)*(1-y)) -> (1-x)*y+x\n   RvmF1 vin=(RvmF1(1.0)-vin2.x)*vin2.y+vin2.x;\n   vin=RvmSatF1((-vin)*inputHeight+inputHeight);   \n   // Leave in {0 to inputSize}\n   pos=pos*halfInputSize+halfInputSize;     \n  #else\n   pos=ipos*inputSizeDivOutputSize;\n  #endif\n//--------------------------------------------------------------\n  // Get to center for first gather 4\n  //  W Z W Z\n  //  X Y X Y\n  #if RVM_MODE==0\n   RvmF2 g=floor(pos+RvmF2(-1.5,-0.5))+RvmF2_(1.0);\n   RvmF2 gp=g*rcpInputSize;\n   g.y-=RvmF1(0.5);\n  #endif\n//--------------------------------------------------------------\n  // Get to center for first gather 4\n  //  W Z\n  //  X Y\n  //  W Z\n  //  X Y\n  #if RVM_MODE!=0\n   RvmF2 g=floor(pos+RvmF2(-0.5,-1.5))+RvmF2_(1.0);\n   RvmF2 gp=g*rcpInputSize;\n   g.x-=RvmF1(0.5);\n  #endif\n//--------------------------------------------------------------\n  // Using gather4 to keep in SoA form for packed 16-bit\n  // Both 32-bit and 16-bit paths use same logic\n  // Gather 4 ordering\n  //  W Z\n  //  X Y\n  // 4x2 sampled footprint\n  //  _S_ _T_\n  //  W Z W Z\n  //  X Y X Y\n  #if RVM_MODE==0\n   RvmH4 colRS=RvmR4H(gp);\n   RvmH4 colGS=RvmG4H(gp);\n   RvmH4 colBS=RvmB4H(gp);\n   gp.x+=RvmF1(2.0*rcpInputSize.x);\n   RvmH4 colRT=RvmR4H(gp);\n   RvmH4 colGT=RvmG4H(gp);\n   RvmH4 colBT=RvmB4H(gp);\n  #endif\n//--------------------------------------------------------------\n  // 2x4 sampled footprint\n  //  W Z |s\n  //  X Y |s\n  //  W Z :t\n  //  X Y :t\n  #if RVM_MODE!=0\n   RvmH4 colRS=RvmR4H(gp);\n   RvmH4 colGS=RvmG4H(gp);\n   RvmH4 colBS=RvmB4H(gp);\n   gp.y+=RvmF1(2.0*rcpInputSize.y);\n   RvmH4 colRT=RvmR4H(gp);\n   RvmH4 colGT=RvmG4H(gp);\n   RvmH4 colBT=RvmB4H(gp);\n  #endif\n//--------------------------------------------------------------\n  // Debug view without effect\n  #ifdef RVM_SPLIT\n   if(ipos.x<RvmF1(RVM_SPLIT)){\n    return RvmH3(colRS.z,colGS.z,colBS.z);}\n  #endif\n//--------------------------------------------------------------\n  // Horizontal kernel is simple gaussian filter approximation\n  #if RVM_MODE==0\n   RvmH1 offB=RvmH1(pos.x-g.x);\n   RvmH2 offS=RvmH2(offB,offB)*RvmH2_(blur)+blur4.xy;\n   RvmH2 offT=RvmH2(offB,offB)*RvmH2_(blur)+blur4.zw;\n   RvmH2 horS=RvmPolyH2(offS);\n   RvmH2 horT=RvmPolyH2(offT);\n  #endif\n//--------------------------------------------------------------\n  // Vertical\n  #if RVM_MODE!=0\n   RvmH1 offB=RvmH1(pos.y-g.y);\n   RvmH2 offS=RvmH2(offB,offB)*RvmH2_(blur)+blur4.xy;\n   RvmH2 offT=RvmH2(offB,offB)*RvmH2_(blur)+blur4.zw;\n   RvmH2 horS=RvmPolyH2(offS);\n   RvmH2 horT=RvmPolyH2(offT);\n  #endif\n//--------------------------------------------------------------\n  // Get kernel totals and then rcp\n  RvmH2 hor0=horS+horT;\n  RvmH1 horD=RvmRcpH1(hor0.x+hor0.y);\n//--------------------------------------------------------------\n  // Get rid of off-screen pixels on edge\n  #ifdef RVM_WARP\n   horD*=RvmH1(vin);\n  #endif\n//--------------------------------------------------------------\n  // Apply horizontal filter, up and down sums\n  #if RVM_MODE==0\n   RvmH2 colRU2=colRS.wz*horS+colRT.wz*horT;\n   RvmH2 colGU2=colGS.wz*horS+colGT.wz*horT;\n   RvmH2 colBU2=colBS.wz*horS+colBT.wz*horT;\n   RvmH2 colRD2=colRS.xy*horS+colRT.xy*horT;\n   RvmH2 colGD2=colGS.xy*horS+colGT.xy*horT;\n   RvmH2 colBD2=colBS.xy*horS+colBT.xy*horT;\n//--------------------------------------------------------------\n   // Pair total so that {x:=up, y:=down}\n   // Expensive transpose from pairs of taps, to pairs of lines\n   RvmH2 colRL=RvmH2(colRU2.x+colRU2.y,colRD2.x+colRD2.y);\n   RvmH2 colGL=RvmH2(colGU2.x+colGU2.y,colGD2.x+colGD2.y);\n   RvmH2 colBL=RvmH2(colBU2.x+colBU2.y,colBD2.x+colBD2.y);\n  #endif\n//--------------------------------------------------------------\n  // Apply vertical filter\n  #if RVM_MODE!=0\n   RvmH2 colRL=colRS.wz*horS.xx+colRS.xy*horS.yy+\n               colRT.wz*horT.xx+colRT.xy*horT.yy;  \n   RvmH2 colGL=colGS.wz*horS.xx+colGS.xy*horS.yy+\n               colGT.wz*horT.xx+colGT.xy*horT.yy;  \n   RvmH2 colBL=colBS.wz*horS.xx+colBS.xy*horS.yy+\n               colBT.wz*horT.xx+colBT.xy*horT.yy;  \n  #endif\n//--------------------------------------------------------------\n  // Normalize by kernel total\n  colRL*=RvmH2_(horD);\n  colGL*=RvmH2_(horD);\n  colBL*=RvmH2_(horD);\n//--------------------------------------------------------------\n  #if RVM_MODE==0\n   // Get channel maximums and shape\n   RvmH2 colML=RvmMax3H2(colRL,colGL,colBL);\n   // TODO: Approximation...\n   colML=sqrt(colML);\n//--------------------------------------------------------------\n   // Convert shaped channel maximums into scan width\n   RvmH2 scnL=colML*RvmH2_(RVM_SCAN_SIZ)+RvmH2_(RVM_SCAN_MIN);\n   RvmH1 offY=RvmH1(pos.y-g.y);\n   scnL.x=( offY)*scnL.x;  \n   scnL.y=(-offY)*scnL.y+scnL.y;  \n   scnL=min(RvmH2_(0.5),scnL);\n   scnL=RvmNCosH2(scnL);\n   scnL=scnL*RvmH2_(0.5)+RvmH2_(0.5);\n//--------------------------------------------------------------\n   // Normalize for reduction in scan width\n   RvmH2 nrmL=RvmH2_(1.0)-colML;\n   nrmL=nrmL*RvmH2_(RVM_SCAN_MIN/RVM_SCAN_MAX-1.0)+RvmH2_(1.0);\n   scnL*=nrmL;\n  #endif\n//--------------------------------------------------------------\n  #if RVM_MODE!=0\n   RvmH1 offX=RvmH1(pos.x-g.x);\n   RvmH2 scnL=RvmH2(RvmH1(1.0)-offX,offX);\n  #endif\n//--------------------------------------------------------------\n  // Apply scan\n  colRL*=scnL; \n  colGL*=scnL;   \n  colBL*=scnL;\n//--------------------------------------------------------------\n  // Merge contribution from both nearest lines\n  RvmH3 col;\n  col.r=colRL.x+colRL.y;\n  col.g=colGL.x+colGL.y;\n  col.b=colBL.x+colBL.y;\n//--------------------------------------------------------------\n  // Grille\n  #if RVM_MODE==1\n   RvmH1 lim=RvmH1(1.0/((1.0/3.0)+(2.0/3.0)*RVM_DARK));\n   RvmH3 colD=col*col;\n   colD*=RVM_DARK;\n   RvmH3 amp=RvmRcpH3(\n    RvmH3_(lim*1.0/3.0)+RvmH3_(lim*2.0/3.0)*col);\n   ipos.x=RvmFractF1(ipos.x*RvmF1(1.0/3.0));\n   col*=amp;colD*=amp;\n   if(     ipos.x<RvmF1(1.0/3.0)){colD.r=col.r;}\n   else if(ipos.x<RvmF1(2.0/3.0)){colD.g=col.g;}\n   else                          {colD.b=col.b;}\n   return colD;\n  #endif\n//--------------------------------------------------------------\n  // Slot mask\n  #if RVM_MODE==2\n   RvmH1 lim=RvmH1(1.0/((3.0/12.0)+(9.0/12.0)*RVM_DARK));\n   if(RvmFractF1(ipos.x*RvmF1(1.0/6.0))>RvmF1(0.5))\n    ipos.y+=RvmF1(2.0);\n   ipos.y=RvmFractF1(ipos.y*RvmF1(1.0/4.0));\n   RvmH3 colD=col*col;\n   colD*=RVM_DARK;\n   RvmH3 amp=RvmRcpH3(\n    RvmH3_(lim*3.0/12.0)+RvmH3_(lim*9.0/12.0)*col);\n   ipos.x=RvmFractF1(ipos.x*RvmF1(1.0/3.0));\n   col*=amp;colD*=amp;\n   if(ipos.y>RvmF1(1.0/4.0)){\n    if(     ipos.x<RvmF1(1.0/3.0)){colD.r=col.r;}\n    else if(ipos.x<RvmF1(2.0/3.0)){colD.g=col.g;}\n    else                          {colD.b=col.b;}}\n   return colD;\n  #endif\n//--------------------------------------------------------------\n  return col;}\n#endif\n\n\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n\n\n//_____________________________/\\_______________________________\n//==============================================================\n//                    USE HEADER IN SHADER\n//--------------------------------------------------------------\n// Example of integrating\n// What to do after including header\n//==============================================================\n// Convert from linear to sRGB\n// Since shader toy output is not linear\nfloat ToSrgb1(float c){\n return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\n//--------------------------------------------------------------\nvec3 ToSrgb(vec3 c){return vec3(\n ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n//--------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n vec2 res=iResolution.xy/vec2(INPUT_DOT,INPUT_DOT);\n fragColor.rgb=RvmF(\n  fragCoord.xy,       // ipos\n  res/iResolution.xy, // inputSizeDivOutputSize\n  res*vec2(0.5,0.5),  // halfInputSize\n  1.0/res,            // rcpInputSize\n  2.0/iResolution.xy, // twoDivOutputSize\n  res.y,\n  #if RVM_MODE==0\n   vec2(1.0/256.0,1.0/24.0),\n  #endif\n  #if RVM_MODE==1\n   vec2(1.0/4096.0,1.0/24.0),\n  #endif\n  #if RVM_MODE==2\n   vec2(1.0/48.0,1.0/24.0),\n  #endif\n  INPUT_BLUR,\n  RvmF4(0.5*INPUT_BLUR,-0.5*INPUT_BLUR,-1.5*INPUT_BLUR,-2.5*INPUT_BLUR));\n // Shadertoy outputs non-linear color   \n fragColor.rgb=ToSrgb(fragColor.rgb);}","name":"Image","description":"","type":"image"}]}