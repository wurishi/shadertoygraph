{"ver":"0.1","info":{"id":"4ftcRS","date":"1730818038","viewed":23,"name":"Breath ","username":"Secretstar","description":"Julia fractal ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER 150\n\n#define ZOOM 1.5\n\n// Funzione per creare un effetto di glow attorno ai contorni del frattale\n\nfloat glow(vec2 z, vec2 c) {\n\n    float glowEffect = 0.0;\n\n    vec2 zn = z;\n\n    for (int i = 0; i < 5; i++) {\n\n        zn = vec2(zn.x * zn.x - zn.y * zn.y, 2.0 * zn.x * zn.y) + c;\n\n        glowEffect += exp(-dot(zn, zn));\n\n    }\n\n    return glowEffect * 0.05;\n\n}\n\n// Funzione per calcolare il colore di sfondo basato sul tempo\n\nvec3 getBackgroundColor(float time) {\n\n    // Colori di base per il gradiente\n\n    vec3 color1 = vec3(0.2, 0.1, 0.4);\n\n    vec3 color2 = vec3(0.3, 0.6, 0.9);\n\n    vec3 color3 = vec3(0.8, 0.3, 0.5);\n\n    // Calcolo del colore di sfondo variabile nel tempo\n\n    vec3 bgColor = mix(color1, color2, 0.5 + 0.5 * sin(time * 0.2));\n\n    bgColor = mix(bgColor, color3, 0.5 + 0.5 * cos(time * 0.3));\n\n    return bgColor;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Coordinate UV normalizzate per il rendering\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Effetto di pulsazione per la variazione delle iterazioni e della luminosità\n\n    float pulse = 0.5 + 0.5 * sin(iTime);  // Valore oscillante da 0 a 1\n\n    int dynamicIter = int(mix(50.0, float(MAX_ITER), pulse));  // Variazione tra 50 e MAX_ITER\n\n    // Parametri del frattale Julia che cambiano nel tempo\n\n    float time = iTime * 0.2;\n\n    float cRe = cos(time) * 0.6;\n\n    float cIm = sin(time) * 0.6;\n\n    // Inizializzazione delle coordinate di partenza\n\n    vec2 z = uv * ZOOM;\n\n    float iter = 0.0;\n\n    float dist = 0.0;\n\n    // Ciclo di iterazione del frattale Julia\n\n    for (int i = 0; i < dynamicIter; i++) {\n\n        if (dot(z, z) > 4.0) break;  // Condizione di escape\n\n        // Formula iterativa di Julia\n\n        z = vec2(z.x * z.x - z.y * z.y + cRe, 2.0 * z.x * z.y + cIm);\n\n        iter += 1.0;\n\n        // Accumulo della distanza per effetti di ombreggiatura\n\n        dist += exp(-length(z) * 0.5);\n\n    }\n\n    // Calcolo dell’effetto glow per contorni brillanti\n\n    float glowEffect = glow(uv * ZOOM, vec2(cRe, cIm));\n\n    // Colorazione basata sul numero di iterazioni, regolata dall'effetto di pulsazione\n\n    float colorFactor = iter / float(dynamicIter);  // Normalizzazione in base alle iterazioni dinamiche\n\n    vec3 baseColor1 = vec3(0.2, 0.1, 0.5);  // Colore base scuro\n\n    vec3 baseColor2 = vec3(1.0, 0.8, 0.3);  // Colore base chiaro\n\n    // Gradiente di colore dinamico basato su `colorFactor` e pulsazione\n\n    vec3 col = mix(baseColor1, baseColor2, colorFactor);\n\n    // Aggiunta dell’effetto di glow alla luminosità\n\n    col += glowEffect * vec3(0.9, 0.6, 1.0) * pulse;\n\n    // Ombreggiatura e profondità visiva\n\n    col *= dist * 0.03 + 0.7 * pulse;  // L’intensità varia con la pulsazione\n\n    // Colore di sfondo cangiante in base al tempo\n\n    vec3 bgColor = getBackgroundColor(iTime);\n\n    // Mescolanza tra il frattale e il colore di sfondo\n\n    col = mix(bgColor, col, smoothstep(0.2, 1.0, colorFactor));  // Transizione graduale frattale-sfondo\n\n    // Correzione gamma per migliorare l'output visivo\n\n    col = pow(col, vec3(0.8));\n\n    fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}