{"ver":"0.1","info":{"id":"3lVGzm","date":"1578583564","viewed":95,"name":"eindacor_02","username":"Eindacor_DS","description":"moving bricks","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bricks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// they're bricks, you dolt!\n\nfloat normalizeSin(float sinValue)\n{\n  \treturn (sinValue + 1.) / 2.;  \n}\n\nfloat floorSegment(float value, float segment)\n{\n    return floor(value / segment) * segment;\n}\n\nfloat ceilSegment(float value, float segment)  \n{\n    return ceil(value / segment) * segment;\n}\n\nfloat roundSegment(float value, float segment)\n{\n    return round(value / segment) * segment;\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvec3 obscureColor(vec3 original, float factor)\n{\n    float seed = hash(vec2(original.r, factor)) * 2. - 1.;\n    float obscureCoeff = .1;\n    vec3 rgbAdjustmentCoeff = original * factor * obscureCoeff;\n    return original + rgbAdjustmentCoeff * ( 2.*seed-1. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    float aspectRatio =  iResolution.y / iResolution.x;\n    \n    // brickHeight indicates screenspace dimension\n    float brickHeight = .1;\n    float brickWidth = brickHeight * 3.39 * aspectRatio;\n    float colorRepeat = 20.;\n    \n    float timeScale = .15;\n    \n    uv.x += iTime * timeScale;\n    uv.y += normalizeSin(sin(iTime * timeScale)) * colorRepeat * brickHeight;\n    \n    float fractY = fract(uv.y / brickHeight);\n    \n    // calcs based on nominal brick dimensions\n    float mortarThickness = brickHeight * 1.25 / 3. / 2.25 / 2.;\n    float xThickness = mortarThickness * aspectRatio;\n    \n    bool evenRow = mod(floor(uv.y / brickHeight), 2.) == 0.; \n    \n    float repeatIncrementX = colorRepeat * brickWidth;\n    float repeatIncrementY = colorRepeat * brickHeight;\n    float xDist = evenRow ? uv.x + brickWidth / 2. : uv.x;\n    float shadeValue = .6;\n    vec3 mortarColor = vec3(.8);\n    \n    // horizontal mortar\n    if (abs(uv.y - round(uv.y / brickHeight) * brickHeight) < mortarThickness / 2.)\n    {   \n        col = mortarColor;\n        float floorSegY = floorSegment(uv.y, brickHeight);\n        if ((uv.y - floorSegY) < mortarThickness * .75)\n        {\n            if (xDist - floorSegment(xDist, brickWidth) < brickWidth - mortarThickness * aspectRatio)\n            {\n                col *= shadeValue; \n            }\n\t\t\telse // angled shadow\n            {\n                float deltaY = floorSegY + (mortarThickness / 2.) - uv.y;\n                float deltaX = (ceilSegment(xDist, brickWidth) - (xThickness / 2.) - xDist) / aspectRatio;\n                if (deltaY < deltaX)\n                {\n                    col *= shadeValue;\n                } \n            }\n    \t}\n    }\n    else // vertical mortar\n    {\n        // vertical mortar\n        if (abs(xDist - roundSegment(xDist, brickWidth)) < xThickness / 2.)\n        {\n            col = mortarColor;\n            float floorSegX = floorSegment(xDist, brickWidth);\n            if (xDist - floorSegX < xThickness / 2.)\n            {\n                if (ceilSegment(uv.y, brickHeight) - uv.y > mortarThickness)\n                {\n                    col *= shadeValue;\n                }\n                else // angled shadow\n                {\n                    float deltaY = ceilSegment(uv.y, brickHeight) - (mortarThickness / 2.) - uv.y;\n                    float deltaX = (floorSegX + (xThickness / 2.) - xDist) / aspectRatio;\n                    if (deltaY > deltaX)\n                    {\n                        col *= shadeValue;\n                    }                \n                }\n            }             \n        }\n        else\n        {\n            vec2 floored = vec2(floorSegment(xDist, brickWidth), floorSegment(uv.y, brickHeight));\n            \n            col = obscureColor(vec3(1., 156./255., 123./255.), hash(floored));\n            \n            // George's bricks\n            if (false)\n            {\n                float gVal = (fragCoord/iResolution.xy).x;\n                float dividedGVal = fract(gVal / .333);\n\n                vec3[] colors = vec3[](\n                    vec3(1.0, 0.0, 0.0), \t// red\n                    vec3(1.0, .5, 0.0), \t// orange\n                    vec3(1.0, 1.0, 0.), \t// yellow\n                    vec3(0.0, 1.0, 0.0), \t// green\n                    vec3(0.0, 1.0, 1.0), \t// blue\n                    vec3(1.0, 0.0, 1.0) \t// purple\n                );\n\n                int colorCount = 7;\n                float colorStep = 1. / float(colorCount);\n                for (int i=0; i<colorCount; i++)\n                {\n                    vec3 color1 = colors[i];\n                    vec3 color2 = (i == (colorCount - 1)) ? colors[2] : colors[i + 1];\n\n                    float leftSide = float(i) * colorStep;\n                    float rightSide = leftSide + colorStep;\n                    if (gVal < leftSide || gVal > rightSide)\n                        continue;\n\n                    float cVal = smoothstep(leftSide, leftSide + colorStep, gVal);\n\n                    if (cVal > 0.)\n                    {\n                        col = mix(color1, color2, cVal);\n                    }\n                } \n            }   \n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}