{"ver":"0.1","info":{"id":"7ld3zN","date":"1635847323","viewed":77,"name":"phase flow","username":"jvm1001","description":"Each pixel simulates a unit-length-pendulum-on-a-mass-on-a-horizontal-spring with different initial state (spring extension on vertical, pendulum angle on horizontal). (R,G,B) = current (spring extension, pendulum y, pendulum x).","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["dynamicalsystems"],"hasliked":0,"parentid":"XdtSWn","parentname":"Shader Lesson #10, saving state"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// UP arrow key to zoom into the last-clicked spot, DOWN arrow key to zoom out\n// LEFT arrow key to reset state after zooming\n// RIGHT arrow key to reset state AND bounds when toggling fullscreen\n//\n\n\n//this just reads the buffer output and converts it to a color\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = vec4(0,0,0,1);\n    \n    vec4 state = texture(iChannel2, uv);\n    \n    fragColor.xyz = vec3(.5+state.x/4., .25*(1.-cos(state.y)), .5*(1.+sin(state.y)));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\n//zoom factor and bounds\n#define ZOOM 3.\nconst vec2 mins0 = vec2(0.,-1.);\nconst vec2 deltas0 = vec2(2.*PI,2.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5) / (iResolution.xy-vec2(1.,1.));\n    \n    //reads own output for persistent bounds\n    //compounds any off-by-one error 60x per second\n    vec2 mins = texelFetch(iChannel0, ivec2(0,0), 0).xy;\n    vec2 deltas = texelFetch(iChannel0, ivec2(iResolution.xy)-ivec2(1,1), 0).xy - mins;\n    \n    if (iFrame == 1 || texelFetch( iChannel1, ivec2(KEY_RIGHT,1), 0 ).x == 1.) {\n        mins = mins0;\n        deltas = deltas0;\n    }\n    \n    float up = texelFetch( iChannel1, ivec2(KEY_UP,1), 0 ).x;\n    float down = texelFetch( iChannel1, ivec2(KEY_DOWN,1), 0 ).x;\n    \n    mins += deltas*(iMouse.xy/iResolution.xy)*(up*(1.-1./ZOOM)+down*(1.-ZOOM));\n    deltas *= (1. + down*(ZOOM-1.))/(1. + up*(ZOOM-1.));\n    \n    fragColor = vec4(mins + uv*deltas,0.,0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.14159\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\n//parameters\n//m: ratio of mass on spring to mass on pendulum\n#define m 1.\n//f: ratio of spring natural frequency to pendulum natural frequency\n#define f 1.\n//timestep: self explanatory. Has large effect on output, chaos theory I guess.\n#define timestep 0.015\n//maybe I'll upgrade the Euler iteration to RK4.\n\nconst vec2 mins0 = vec2(0.,-1.);\nconst vec2 deltas0 = vec2(2.*PI,2.);\n\n//returns time derivative of state\nvec4 dv (vec4 v)\n{\n    //pendulum on spring\n    return vec4(\n                v.z,\n                v.w,\n                (sin(2.*v.y)/2. + pow(v.w,2.)*sin(v.y) - pow(f,2.)*v.x)/(m + pow(sin(v.y),2.)),\n                (pow(f,2.)*v.x*cos(v.y)-pow(v.w,2.)*sin(2.*v.y)/2.-(1.+m)*sin(v.y))/(m+pow(sin(v.y),2.))\n               );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 state = texture(iChannel2, uv);\n    \n    //(re)initialize\n    if (iFrame == 1\n         || texelFetch( iChannel1, ivec2(KEY_LEFT,1), 0 ).x == 1.\n         || texelFetch( iChannel1, ivec2(KEY_RIGHT,1), 0 ).x == 1.) {\n        state = texture(iChannel0, uv).yxzw;\n        //disable zoom: state = vec4((mins0+uv*deltas0).yx,0.,0.);\n    }\n    \n    state += timestep*dv(state);\n    \n    fragColor = state;\n}","name":"Buffer B","description":"","type":"buffer"}]}