{"ver":"0.1","info":{"id":"l3c3RH","date":"1716798523","viewed":53,"name":"3D terrain","username":"hamster","description":"3d terrain (can be moved with mouse, x changes detail). The specular light is disabled by default.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","terrain","lights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// terrain\nfloat SCALE = 4.0;\nfloat HEIGHT = 0.75;\nfloat BUMP_MAP_MUL = 0.0;\nfloat BUMP_MAP_SCALE = 10.0;\nint BUMP_MAP_DETAIL = 10;\nint DETAIL = 3;\nfloat DEPTH_DETAIL = 100.0;\n\n// lights\nvec3 LIGHT_DIR = normalize(vec3(sqrt(0.5), -sqrt(0.5) * 0.25, sqrt(0.5)));\nvec3 BACKGROUND = vec3(0, 0, 1);\nfloat AMBIENT = 0.5;\nfloat DIFFUSE = 0.5;\nfloat SPECULAR = 0.0; // you might need to use bigger values if increasing SPECULAR_POW\nfloat SPECULAR_POW = 10.0;\n\nfloat hash(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat octNoise(vec2 p, int detail) {\n    float mul = 1.0;\n    float v = 0.0;\n    for(int i = 0; i < detail; ++i) {\n        v += noise(p / mul) * mul;\n        mul *= 0.5;\n    }\n    return v;\n}\n\nfloat light(vec2 p, float mul) {\n    vec3 noise1 = vec3(1, octNoise(p + vec2(mul, 0), DETAIL), 0);\n    vec3 noise2 = vec3(-1, octNoise(p + vec2(-mul, 0), DETAIL), 0);\n    float y_offset = (iMouse.y / iResolution.y * 2.0 - 1.0) * mul;\n    vec3 noise3 = vec3(0, octNoise(p + vec2(0, mul), DETAIL) - y_offset, 1);\n    vec3 noise4 = vec3(0, octNoise(p + vec2(0, -mul), DETAIL) + y_offset, -1);\n    vec3 normal2 = normalize(cross(noise1 - noise2, noise3 - noise4));\n    vec2 p2 = p * BUMP_MAP_SCALE;\n    vec3 bump_map1 = vec3(1, octNoise(vec2(p2.x + 10000.0 + mul, p2.y + 200000.0), BUMP_MAP_DETAIL), 0);\n    vec3 bump_map2 = vec3(-1, octNoise(vec2(p2.x + 10000.0 - mul, p2.y + 200000.0), BUMP_MAP_DETAIL), 0);\n    vec3 bump_map3 = vec3(0, octNoise(vec2(p2.x + 10000.0, p2.y + 200000.0 + mul), BUMP_MAP_DETAIL), 1);\n    vec3 bump_map4 = vec3(0, octNoise(vec2(p2.x + 10000.0, p2.y + 200000.0 - mul), BUMP_MAP_DETAIL), -1);\n    vec3 bump_normal = cross(bump_map1 - bump_map2, bump_map3 - bump_map4);\n    vec3 normal = normalize(normal2 + bump_normal * BUMP_MAP_MUL);\n    vec3 r = 2.0 * dot(normal, LIGHT_DIR) * normal - LIGHT_DIR;\n    float specular = pow(max(dot(r, vec3(0, 0, -1)), 0.0), SPECULAR_POW) * SPECULAR;\n    float diffuse = dot(normal, LIGHT_DIR);\n    return diffuse * DIFFUSE + specular * SPECULAR + AMBIENT;\n}\n\n// noise smoothing fn inverse could be used to speed up depth\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoffset = iTime * 2.0;\n    int z = -500;\n    float gt = 0.0;\n    float yoffset = iMouse.y / iResolution.y * 2.0 - 1.0;\n    int zlimit = int(DEPTH_DETAIL * max(min(1.0 / yoffset, 10.0), 1.0));\n    while(gt == 0.0 && z < zlimit) {\n        float x = fragCoord.x / iResolution.y * SCALE;\n        float addY = float(z) / DEPTH_DETAIL * yoffset;\n        gt = sign(octNoise(vec2(x, float(z) * SCALE / DEPTH_DETAIL + zoffset), DETAIL) * 0.1 * HEIGHT + addY - fragCoord.y / iResolution.y + 0.25) * 0.5 + 0.5;\n        ++z;\n    }\n    float background = 1.0;\n    if(z == zlimit) {\n        background = 0.0;\n    }\n    float c = light(vec2(fragCoord.x / iResolution.y * SCALE, float(z) * SCALE / DEPTH_DETAIL + zoffset), 0.1) * background;\n    vec3 color = vec3(c, c, c) + BACKGROUND * (1.0 - background);\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}