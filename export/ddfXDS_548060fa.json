{"ver":"0.1","info":{"id":"ddfXDS","date":"1669623339","viewed":153,"name":"Stars Field","username":"vladosina","description":"stars","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nmat2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// возвращает число 0...1\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvec3 ray(vec2 uv, float f, float g) {\n    float ray = max(0., 1. - (f * abs(uv.x) * abs(uv.y) + g * length(uv)));\n    return vec3(ray);\n}\n\nvec3 star(vec2 uv, float size, float flare) {\n    // вычисляем расстояние до центра координат\n    float d = length(uv);\n    vec3 color = vec3(.0);\n\n    float glow = .02 / d * size;\n    color += pow(glow, 1.8) ;\n\n    color += ray(uv, 1024. / size, 4.) * flare;\n    color += ray(rotate(PI / 4.) * uv, 1024. / size, 5.) * flare;\n\n    //float rays = max(0., 1. - abs(uv.x * uv.y) * 3000.);\n    //color += rays * flare;\n    //color *= smoothstep(.45, .25, d);\n        \n    // abs(uv.x * uv.y) дает крестообразное изображение\n    // 1 - abs(uv.x * uv.y) - инверсное изображение\n    // то есть белое крестообразное изображение\n    //float rays = max(0., 1. - abs(uv.x * uv.y * 10000.));\n    //color += rays * flare;\n    \n    // поворачиваем на 45 градусов, чтобы добавить еще лучей\n    //uv *= rotate(PI / 4.);\n    // 1000000.\n    //rays = max(0., 1. - abs(uv.x * uv.y * 10000.));\n    // .3 - opacity\n    // color += rays * .3 * flare;\n    \t\t\n    //color *= smoothstep(1., .3, d);\n\n    return color;\n}\n\nvec3 starsLayer(vec2 uv) {\n    // создает много систем координат на плоскости\n    // и смещаем центр координат\n        float t = iTime * .01;\n\n// problem\n    vec2 gv = fract(uv ) - .5;\n    // задает id системы координат, то id ячейки\n    vec2 id = floor(uv);\n    vec3 color = vec3(.0);\n    // проходим по соседям каждой ячейки\n    // так как используем псевдорандом, то ячейки дополнят друг друга\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 offset = vec2(x, y);\n            \n            float n = hash21(id + offset); \n            float flare = max(0., cos(iTime * 1. * fract(n * 345.32)));\n            \n            // сверкание только на больших звездах\n            //if (size > .85) \n               //size = sin(iTime * .1 * size);\n           \n    \n            vec2 pos = vec2(n, fract(n * 34.)) - .5;\n            vec3 s = star(gv - offset - pos, fract(n * 345.32) * 2.5, flare); //smoothstep(.85, 1., size) \n            color+=s;\n            // размер \"точек и свечения\"\n            //color += s * fract(n * 345.32);// max(.5, size + .2) ;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    float t = iTime * .1;\n    //uv *= rotate(t);\n    uv *= 8.;\n\n    vec3 result = vec3(.0);\n    \n\n    /////\n    \n    //for (float i = .0; i < 1.; i += 1./3.) {\n        //float depth = fract(i);\n        //float scale = mix(10., .5, 0.);\n        //float fade = depth * smoothstep(1., .9, depth);\n        \n        result += starsLayer(uv); // + vec2(t)\n    //}\n\n    vec2 gv = fract(uv ) - .5;\n\n    \n    // подсветка ячеек\n    //if (gv.x > .48 || gv.y > .48) result.r = 1.;\n    \n    // для каждой ячейки со звездочкой возвращается свой хэш\n    // который можно использовать для позиционирования\n    // col += hash21(id);\n    \n    // col.rg = gv;\n    \n\n    fragColor = vec4(result,1.0);\n}","name":"Image","description":"","type":"image"}]}