{"ver":"0.1","info":{"id":"wlXyRj","date":"1592457451","viewed":225,"name":"path tracer implementation","username":"okdalto","description":"custom path tracer implementation","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n#define EP 0.001\n#define iterJ 4.0\n#define iterI 4.0\n#define M_PI 3.14159265358979323846\n\n\n\nvoid rotX(inout vec3 z, float s, float c) {\n   z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\n\nvoid rotY(inout vec3 z, float s, float c) {\n   z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\n\nvoid rotZ(inout vec3 z, float s, float c) {\n   z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\n\nvoid rotX(inout vec3 z, float a) {\n   rotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec3 z, float a) {\n   rotY(z, sin(a), cos(a));\n}\n\nvoid rotZ(inout vec3 z, float a) {\n   rotZ(z, sin(a), cos(a));\n}\n\n\nfloat sdSphere(vec3 p){\n    return length(p) - 0.5;\n}\n\nfloat fractal(vec3 p){\n    rotX(p, iTime);\n    rotY(p, iTime);\n    rotZ(p, iTime);\n    for(int i = 0; i < 2; i++){\n        rotY(p, iTime);\n        if(p.x+p.y<0.0) p.xy = -p.yx; // fold 1\n        if(p.y+p.z<0.0) p.yz = -p.zy; // fold 2\n        if(p.z+p.x<0.0) p.zx = -p.xz; // fold 3   \n\n        p -= 0.8;\n    }\n    return length(p) - 0.85;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdSphere( q );\n}\n\nfloat opRepLim( in vec3 p, in float c, in vec3 l )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdSphere( q );\n}\n\n\nfloat sdf(vec3 p){\n    float sphere = fractal(p);\n    float plane = sdPlane(p, vec4(0,1,0, 2));\n    return min(sphere, plane);\n}\n\n\n\nvec3 getNormal(vec3 p){\n    vec2 ep = vec2(EP, 0);\n    return normalize(vec3(\n        sdf(p + ep.xyy) - sdf(p - ep.xyy),\n        sdf(p + ep.yxy) - sdf(p - ep.yxy),\n        sdf(p + ep.yyx) - sdf(p - ep.yyx)\n        ));\n}\n\n\n\n\n\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 rv2 = hash2(seed);\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = normalize( cross( uu, n ) );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\n\n\nvec3 sampleRandomHemisphere(vec3 p, vec3 n){\n    vec3 randomVector = normalize(hash33(p * 10000.0 + iTime));\n\tfloat dotValue = dot(randomVector, n);\n    randomVector *= dotValue;\n    randomVector = normalize(randomVector);\n\n    return randomVector;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    \n    float tmax = 12.0;\n    \n    float t = 0.001;\n    for(int i=0; i<40; i++ )\n    {\n        float h = sdf(ro+rd*t);\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\n\nvec3 march(inout vec3 rayOrigin, inout vec3 rayDir, in vec3 lightPos, in int stage, inout int isOut, float seed){\n    vec3 col = vec3(0.0);\n    vec3 rayPos = rayOrigin;\n    float trvlDist = 0.1;\n    \n    for(int i = 0; i < 34; i++){\n        rayPos = rayOrigin + rayDir * trvlDist;\n        float dist = sdf(rayPos);\n        if(dist < EP){\n            vec3 norm = getNormal(rayPos);\n            vec3 lightDir = normalize(lightPos - rayPos);\n            //float diff = max(0.0, dot(norm, lightDir));\n            float fresnel = max(0.0, 1.0 - dot(-rayDir, norm));\n            fresnel = pow(fresnel, 0.2);\n            \n            //col = sampleRandomHemisphere(rayPos * float(i+1), norm);\n            //col = norm;\n            //col = texture(iChannel0, norm).xyz;\n            \n            rayOrigin = rayPos + norm * EP * 2.0;\n            //rayDir = mix(sampleRandomHemisphere(rayPos * float(stage+1), norm), reflect(rayDir, norm), fresnel);\n            rayDir = mix(cosWeightedRandomHemisphereDirection(norm, seed), reflect(rayDir, norm), fresnel);\n            //rayDir = mix(reflect(rayDir, norm), sampleRandomHemisphere(rayPos * float(stage+1), norm), fresnel);\n            rayDir = normalize(rayDir);\n            //rayDir = reflect(rayDir, norm);\n            \n            return col += texture(iChannel0, rayDir).xyz * vec3(shadow(rayPos, rayDir));\n        }\n        trvlDist += dist;\n        if(trvlDist > 16.0){\n            break;\n            isOut = 1;\n        }\n    }\n    return texture(iChannel0, rayDir).xyz;\n}\n\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    float seed = uv.x + fract(uv.y * 18753.43121412313) + fract(12.12345314312)*iTime;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    //vec3 cameraPos = vec3(0, 0, -5);\n    vec3 cameraPos = vec3(sin(iTime), 0.1, cos(iTime)) * 5.0;\n    //vec3 lightPos = vec3(sin(0.0), 0, cos(0.0)) * 10.0;\n    vec3 lightPos = vec3(-1) * 10.0;\n    \n    \n    vec3 up = vec3(0,1,0);\n    vec3 front = normalize(-cameraPos);\n    vec3 right = normalize(cross(up, front));\n    up = normalize(cross(front, right));\n    for(int j = 0; j < int(iterJ); j++){\n        vec3 rayPos = cameraPos;\n        vec3 rand = (hash3(seed) * 2.0 - 1.0);\n        \n        float dof = 0.3;\n\t\tvec3 voff = sqrt(rand.x)*(right*sin(rand.y*6.283)+up*cos(rand.z*6.283))*dof;\n\t\trayPos-=voff;\n        /*float focusdistance = length(vec3(0.0)-cameraPos)*dof;\n        float fov = 0.8;\n\t\tvec3 rayDir=normalize(  uv.x * right + \n                                uv.y * up +\n                                fov*front + \n                                voff * 0.26);*/\n    \t//vec3 rayDir = normalize((up * uv.y) + (front) + (right * uv.x) );\n        \n                \n        vec3 rayDir = normalize((up * uv.y) + (front) + (right * uv.x) );\n        vec3 fp = cameraPos + rayDir * 2.7;\n        rayDir = normalize(fp - rayPos);\n\n        float trvlDist = 0.0;\n\n        int isOut = 0;\n        int count = 0;\n        for(int i = 0; i < int(iterI); i++){\n            col += march(rayPos, rayDir, lightPos, j, isOut, seed);\n            if(isOut == 1){\n                break;\n            }\n            count ++;\n        }\n        //\n    }\n    col /= (iterJ * iterI);\n    \n    \n    //col = pow(col, vec3(1.0/2.2));\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(clamp(col/4096.0, 0.0, 1.0),1.0) + backPixels;\n\n}\n\n\n","name":"Image","description":"","type":"image"}]}