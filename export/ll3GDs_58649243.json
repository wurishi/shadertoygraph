{"ver":"0.1","info":{"id":"ll3GDs","date":"1472411919","viewed":1018,"name":"Gas giant V2","username":"A2K","description":"Storms are not moving in the opposite direction. It is just an illusion.","likes":21,"published":1,"flags":0,"usePreview":1,"tags":["procedural","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 rotation;\n//uniform float time;\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(float v)\n{\n    return snoise(vec2(v));\n}\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nvec2 rotate( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat noise( float a, float b )\n{\n    return snoise(vec2(a, b));\n}\n\nvoid handleMouse() \n{\n    rotation.z = ((1.0 - iMouse.y / iResolution.y) - 0.5);\n    rotation.x = -((1.0 - iMouse.x / iResolution.x) - 0.5);\n}\n\nvoid mainImagePlanet(out vec4 fragColor, in vec3 nor)\n{\n\n    float rot = rotation.z;\n    nor = (mat3(1.0, 0.0, 0.0, \n                     0.0, cos(rot), - sin(rot), \n                     0.0, sin(rot), cos(rot)) * nor).xyz;\n    rot = rotation.x;\n    nor = (mat3(cos(rot), 0.0, sin(rot), \n                0.0, 1.0, 0.0,\n                -sin(rot), 0.0, -cos(rot)) * nor).xyz;\n    \n    rot = iTime / 1000.0;\n    vec2 pos = (mat3(cos(rot), 0.0, sin(rot), 0.0, 1.0, 0.0, -sin(rot), 0.0, cos(rot)) * vec3(nor.xy,-10.0)).xy;\n    \n\t\n    float time = iTime;\n\tfloat q = time / 1000.0;\n\n    \n\tfloat srnd = snoise((q + nor.yx) * 50.0) / 5.0;\n\tsrnd += snoise((q + nor.yx) * 10.0) / 2.0;\n    srnd += snoise((q + nor.yx) * 100.0) / 10.0;\n\tfloat rnd = snoise((q + nor.xy) * 50.0) / 50.0;\n\n    float lat = 0.5;\n    float stormity = sqrt(max(0.0, 1.0 - abs(lat - nor.y) / lat) / 1.2);\n    float s1 = snoise(nor.xy * 1.520) * stormity;\n    float s2 = snoise(nor.xy * 1.75) * stormity;\n    float s3 = snoise(nor.xy * 0.75) * stormity;\n    \n    float storm = s1 * s2 *s3;\n    vec2 sv;\n    if (storm > 0.0) {\n    \tsv = (nor * vec3(storm * storm * 10.0)).xy;\n    } else {\n        sv = vec2(0.0);\n    }\n    \n    nor.xy *= (1.0 - sv);\n        \n\tvec4 color = (texture(iChannel0,((nor + 1.0) * 0.5).yy + srnd / 100.0 + rnd / 10.0)\n        +\n        texture(iChannel0,((nor + 1.00) * 0.5).yy + 0.003 + srnd / 100.0  )\n        +\n        texture(iChannel0,((nor + 1.00) * 0.5).yy - 0.003 + srnd / 100.0)) / 3.0;\n\t\n    \n    fragColor = color;// * ((0.25 + dot(nor.xyz, vec3(-10.25, 10.5, 0.0))) / 4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    handleMouse();\n\n    float rot = iTime / 1000.0;\n    vec2 p = -1.0 + 2.0 * fragCoord / iResolution.xy * vec2(iResolution.x / iResolution.y, 1.0) - vec2(0.5*iResolution.x / iResolution.y,0.0);\n    \n        \n\t\n    vec3 ro = vec3( 0.0, 0.0, 2.25 );\n    vec3 rd = normalize( vec3( p, -2.0 ) );\n\n    vec3 col = vec3(0.0);\n\n    // intersect sphere\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - 1.0;\n    float h = b*b - c;\n\tfloat t = -b - sqrt(abs(h));\n\n  \n\n\tvec3 nor = (ro + t*rd);\n    \n    if (length(p) > 0.9) {\n        fragColor.g += t;\n    }\n    \n    if (h > 0.0) {\n    mainImagePlanet(fragColor, nor);\n    }\n    \n    \n    float light = dot(nor.xyz, vec3(15.25, 10.5, 3.0));\n    \n    \n    {\n        \n        vec3 c = vec3(0.15, 0.09, 0.05);\n        float lum = light / 20.0;\n        \n        if (h <= 0.0) \n        {\n        \tlum *= abs(log(abs(h)));\n    \t}\n        \n        fragColor.rgb = max(fragColor.rgb, 0.0);\n        \n        if (h <= 0.0) {\n            fragColor.rgb = c * lum;\n        } else {        \t\n            fragColor.rgb = fragColor.rgb * (max(0.1, light / 10.0)) + c * lum;\n            \n        }\n        \n    }\n    \n    //fragColor.a = 0.0;//abs(h);\n}\n","name":"Image","description":"","type":"image"}]}