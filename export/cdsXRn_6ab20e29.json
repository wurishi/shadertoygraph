{"ver":"0.1","info":{"id":"cdsXRn","date":"1668531328","viewed":99,"name":"Mirror shader","username":"helenhsn","description":"Playing with reflections","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 10000\n#define MAX_DIST 1000.0\n#define SURF_DIST .0001\n#define PI 3.14159265359\n\n\nstruct object {\n    int id;\n    float sd;\n};\n\nmat2 Rotate(float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th)); \n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nconst int NB_OBJECTS = 3;\n\nvec3[NB_OBJECTS] colors = vec3[NB_OBJECTS](\n                vec3(1., 1., 1.),\n                vec3(1., 1., 0.), \n                vec3(100., 250., 128.)/255.);\n               \n\n\nfloat sdCube(vec3 p, float r) {\n    \n  vec3 proj = abs(p) - r;\n  return length(max(proj,0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdPlane(vec3 p, vec2 plane) {\n    return p.y; //plane = (x=0,z=0)\n}\n\n\n//////\n// OPERATIONS\n//////\n\nvec3 rot(vec3 p, float angle) {\n    vec3 q = p;\n    q.xz *= Rotate(angle);\n    return q;\n}\n\nvec3 scale(vec3 p, vec3 center, vec3 scaleVect){\n    vec3 q = p - center;\n    return q/scaleVect;\n}\n\n//REPETITIONS\nvec3 repetition(vec3 p, vec3 repVec) {\n    return mod(p+0.5*repVec, repVec)- 0.5*repVec;\n}\n\nvec3 repetitionLim(vec3 p, float c, vec3 lim) {\n    return p - c*clamp(round(p/c), -lim, lim);\n}\n\n//////\n// RAYMARCHER\n/////\n\nobject minObj(object[NB_OBJECTS] objects) {\n\n    int idObj = objects[0].sd < objects[1].sd ? 0 : 1;\n    for (int i = 2; i<NB_OBJECTS; i++) {\n        idObj = objects[i].sd < objects[idObj].sd ? i : idObj;\n    }\n    return objects[idObj];\n}\n\n\nobject getDist(vec3 p) {\n\n    object objects[NB_OBJECTS];\n    \n    //PLANE\n    objects[0] = object(0, sdPlane(p, vec2(0., 0.)));\n    \n    //GROS MIRROR CUBE\n    vec3 center = vec3(5., 3., 12.);\n    vec3 pScaled = scale(p, center, vec3(1.));\n    float mirror1 = sdCube(pScaled, 8.);\n    \n    //MIRROR CUBE PETIT\n    center = vec3(-6., 2., 0.);\n    pScaled = scale(p, center, vec3(1.));\n    vec3 pRot = rot(pScaled, iTime*.3);\n    vec3 pRep = repetitionLim(pRot, 5.5, vec3(3));\n    float mirror2 = sdSphere(pRep, .5) - .1;\n    \n    objects[1]= object(1, smin(mirror1, mirror2, 1.) );\n    \n    \n    //CUBE\n    center = vec3(0., 1., 0.);\n    pScaled = scale(p, center, vec3(1.));\n    objects[2]= object(2, sdCube(rot(pScaled, iTime), 1.) -.2);\n   \n    \n    return minObj(objects);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, inout vec3 Color, inout object intersectObj) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n       \n        intersectObj = getDist(p);\n        dO += intersectObj.sd;\n        if(dO>MAX_DIST || intersectObj.sd<SURF_DIST)  {\n            Color = colors[intersectObj.id];\n            break;\n        }\n    }\n    \n    return dO;\n}\n\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p).sd;\n    vec2 eps = vec2(.001, 0);\n    \n    vec3 n = vec3(\n        getDist(p+eps.xyy).sd - getDist(p-eps.xyy).sd,\n        getDist(p+eps.yxy).sd - getDist(p-eps.yxy).sd,\n        getDist(p+eps.yyx).sd - getDist(p-eps.yyx).sd);\n        \n    return normalize(n);\n}\n\nvec3 getRayDir(vec2 uv, vec3 ro, vec3 lookAt, float zoom) {\n    vec3 fwd = normalize(lookAt-ro);\n    vec3 rgt = normalize(cross(vec3(0.,1.,0.), fwd));\n    vec3 upLoc = cross(fwd,rgt);\n    vec3 rd = normalize(fwd*zoom + uv.x*rgt + uv.y*upLoc);\n    return rd;\n}\n\nvec3 getLight(vec3 p, inout vec3 Color) {\n\n    //casting light\n    vec3 lightPos = vec3(2., 5., -8.);\n    vec3 lightRay = normalize(lightPos - p);\n   \n    vec3 normalVect = getNormal(p);\n    \n    float result = clamp(dot(lightRay, normalVect), 0., 1.); //values equal to -1. behind the sphere so we need to put them btw 0. & 1.\n    \n    //casting shadow\n    vec3 tempColor = vec3(1., 0., 1.);\n    object tempObject = object(0, 0.);\n    float dist = rayMarch(p+normalVect*SURF_DIST*2., lightRay, tempColor, tempObject); //we need to add an offset so that the point isn't considered on the plane\n    //otherwise its dist will be automatically set to 0.\n    \n    if (dist<length(lightPos - p)) {\n       result *=.2;\n    }\n    return result*Color;\n}\n\n\nvoid getReflection(vec3 ro, inout vec3 intersection, object intersectObject, inout vec3 Color) {\n    \n    object objectEncountered = intersectObject;\n\n    vec3 startRay = ro; // camera\n        \n    vec3 ray;\n    vec3 n;\n    vec3 reflectedRay;\n    float dist;\n    \n    int index = 0;\n\n    \n    while (index<5 && (objectEncountered.id ==1))\n    {\n        ray = normalize(startRay - intersection);\n\n        n = getNormal(intersection);\n\n        reflectedRay = normalize(- ray + 2.*n*dot(n, ray));\n        \n        dist = rayMarch(intersection + n*SURF_DIST*2., reflectedRay, Color, objectEncountered);\n        \n        startRay = intersection;\n        intersection += reflectedRay*dist;\n        index++;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(1.);\n    \n    vec3 ro = vec3(0., 4., -10.);\n    vec3 lookAt = vec3(0., 4., 0.);\n    //ro.xz += 2.*vec2(length(lookAt-ro)*sin(iTime*0.8), length(lookAt-ro)*cos(iTime*0.8)) + lookAt.xz;\n    \n    vec3 rd = getRayDir(uv, ro, lookAt, .9);\n    \n    object intersectObj;\n    float sdf = rayMarch(ro, rd, color, intersectObj);\n    \n    vec3 intersection = ro + rd*sdf;\n   \n    \n    getReflection(ro, intersection, intersectObj, color);\n    \n    color = getLight(intersection, color);\n\n   \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}