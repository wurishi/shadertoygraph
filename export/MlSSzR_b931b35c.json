{"ver":"0.1","info":{"id":"MlSSzR","date":"1440946505","viewed":171,"name":"up and right from forward vec","username":"public_int_i","description":"needed to calculate up and right vectors for something so made this to test it out first.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define FOV_SCALE .5\n#define ITER 74\n#define EPSILON .04\n#define NORMAL_EPSILON .04\n#define CAMERA_SPEED .5\n\n\nvec3 lightDir = normalize(vec3(4.,6.,2.));\nvec3 color = vec3(1.,.2,.9);\nvec3 hitColor = vec3(.2);\n\nvec3 ray,rayRight,rayUp;\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\n#define fi float(i)\nfloat df(in vec3 rp) {\n    \n    return min(  sdCapsule(rp,vec3(0.),ray*10.,0.2),\n           min(  sdCapsule(rp,vec3(0.),normalize(rayRight)*10.,0.2),\n           sdCapsule(rp,vec3(0.),normalize(rayUp)*10.,0.2)) );\n}\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df(rp+ne)-df(rp-ne),\n                          df(rp+ne.yxz)-df(rp-ne.yxz),\n                          df(rp+ne.yzx)-df(rp-ne.yzx)));\n}\n\nfloat fixa(in float a) {\n    return a/10.;\n}\n\nvoid calculateUpRight(vec3 normal, out vec3 tangent, out vec3 binormal)\n{\n    if (abs(normal.x) > abs(normal.y)) {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    } else {\n\t\ttangent = normalize(vec3(0., normal.z, -normal.y));\n\t}\n    \n\tbinormal = cross(normal, tangent);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    //https://www.garagegames.com/community/forums/viewthread/17992\n    ray = normalize(vec3(-1.,1.,1.));\n    vec3 majorAxis = abs(ray);\n    if (majorAxis.x > majorAxis.y) {\n        if (majorAxis.x > majorAxis.z) {\n            majorAxis = vec3(1.,0.,0.);\n            if (ray.x == 1.) ray = vec3(0.999,0.001,0.0);\n        } else {\n            majorAxis = vec3(0.,0.,1.);\n            if (ray.z == 1.) ray = vec3(0.,0.001,0.999);\n        }\n    } else {\n        if (majorAxis.y > majorAxis.z) {\n            majorAxis = vec3(0.,1.,0.);\n            if (ray.y == 1.) ray = vec3(0.,0.999,0.001);\n        } else {\n            majorAxis = vec3(0.,0.,1.);\n            if (ray.z == 1.) ray = vec3(0.,0.001,0.999);\n        }\n    }\n    \n    rayRight = normalize(cross(majorAxis,ray));\n    rayUp = normalize(cross(ray,rayRight));\n\tcalculateUpRight(ray,rayRight,rayUp);\n    \n    float cst = iTime*CAMERA_SPEED;\n    vec3 rp = ray*40. + rayRight*6.*cos(cst) + rayUp*6.*sin(cst);\n    vec3 rd = normalize(-rp);\n    vec3 rr = cross(vec3(0.,1.,0.),rd);\n    rd = normalize(rd*FOV_SCALE + uv.x*rr + uv.y*cross(rd,rr));\n    \n    float d, a = 0.;\n    for (int i = 0; i < ITER; i++) {\n        d = df(rp);\n        if (d < EPSILON) break;\n        rp += d*rd;\n    }\n\n    vec4 bg = texture(iChannel0,rd);\n\tif (d > EPSILON) {\n       fragColor = bg;\n    \treturn;\n\t}\n\n    \n    fragColor = color.xyzz*.2 + color.xyzz*.8*max(0.,dot(lightDir,normal(rp)));\n}","name":"Image","description":"","type":"image"}]}