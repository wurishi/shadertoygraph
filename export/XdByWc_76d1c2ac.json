{"ver":"0.1","info":{"id":"XdByWc","date":"1534590422","viewed":163,"name":"Color Stuff","username":"TinyTexel","description":".","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define lerp(a, b, l) (a + (b - a) * l)\n#define rsqrt inversesqrt\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat Pow(float x, float e) {return pow(x, e);}\nvec2 Pow(vec2 x, float e) {return pow(x, vec2(e));}\nvec3 Pow(vec3 x, float e) {return pow(x, vec3(e));}\nvec4 Pow(vec4 x, float e) {return pow(x, vec4(e));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n// D65 assumed throughout for sRGB\n\n// https://en.wikipedia.org/wiki/CIE_1931_color_space\nvec3 CIERGB_to_XYZ(vec3 rgb)\n{\n    const float o = 1.0 / 0.17697;\n    \n    float x = dot(rgb, vec3(0.49000, 0.31000, 0.20000) * o);\n    float y = dot(rgb, vec3(0.17697, 0.81240, 0.01063) * o);\n    float z = dot(rgb, vec3(0.00000, 0.01000, 0.99000) * o);\n    \n    return vec3(x, y, z);\n}\n\n//*\nvec3 XYZ_to_CIERGB(vec3 xyz)\n{\n    const float o = 0.17697;\n    \n    float r = dot(xyz, vec3( 2.3646138465383655  , -0.896540570739668   , -0.4680732757986974 ) * o);\n    float g = dot(xyz, vec3(-0.515166208447888   ,  1.4264081038563887  ,  0.08875810459149917) * o);\n    float b = dot(xyz, vec3( 0.005203699075231191, -0.014408162665216048,  1.0092044635899848 ) * o);\n    \n    return vec3(r, g, b);\n}\n/*/\nvec3 XYZ_to_CIERGB(vec3 xyz)\n{\n    float r = dot(xyz, vec3( 0.418470, -0.15866, -0.082835));\n    float g = dot(xyz, vec3(-0.091169,  0.25243,  0.015708));\n    float b = dot(xyz, vec3(0.00092090,-0.0025498,0.178600));\n    \n    return vec3(r, g, b);\n}\n//*/\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 XYZ_to_sRGB(vec3 xyz)\n{\n    float r = dot(xyz, vec3( 3.2406, -1.5372, -0.4986));\n    float g = dot(xyz, vec3(-0.9689,  1.8758,  0.0415));\n    float b = dot(xyz, vec3( 0.0557, -0.2040,  1.0570));\n    \n    return vec3(r, g, b);\n}\n\n\n//vec3 sRGB_to_XYZ(vec3 rgb)\n//{\n//    float x = dot(rgb, vec3(0.4124, 0.3576, 0.1805));\n//    float y = dot(rgb, vec3(0.2126, 0.7152, 0.0722));\n//    float z = dot(rgb, vec3(0.0193, 0.1192, 0.9505));\n//    \n//    return vec3(x, y, z);\n//}\n//\n//const vec3 D65_XYZ = vec3(0.9505, 1.0, 1.089);\n\nvec3 sRGB_to_XYZ(vec3 rgb)\n{\n    float x = dot(rgb, vec3(0.412395588967414200, 0.35758343076371480, 0.18049264738170157));\n    float y = dot(rgb, vec3(0.212586230785595520, 0.71517030370341080, 0.07220049864333620));\n    float z = dot(rgb, vec3(0.019297215491746934, 0.11918386458084851, 0.95049712513157980));\n    \n    return vec3(x, y, z);\n}\n\nfloat sRGB_to_Y(vec3 rgb)\n{\n    float y = dot(rgb, vec3(0.212586230785595520, 0.71517030370341080, 0.07220049864333620));\n\n    return y;\n}\n\n//*\nvec3 CIERGB_to_sRGB(vec3 rgb)\n{\n    float sr = dot(rgb, vec3( 7.435473334463469   , -1.4082685200881504,  0.7807287336836757));\n    float sg = dot(rgb, vec3(-0.8069202350680907  ,  6.91617743120303  , -0.7501567836356445));\n    float sb = dot(rgb, vec3(-0.049776120246369425, -0.7791863027631802,  5.963731027857829 ));\n    \n    return vec3(sr, sg, sb);\n}\n/*/\nvec3 CIERGB_to_sRGB(vec3 rgb) { return XYZ_to_sRGB(CIERGB_to_XYZ(rgb)); }\n//*/\n\n//*\nvec3 sRGB_to_CIERGB(vec3 srgb)\n{\n    float r = dot(srgb, vec3(0.13724583227348197  , 0.026294336655049138, -0.014659764065962068));\n    float g = dot(srgb, vec3(0.016368881681819134 , 0.14980304339289327 ,  0.01670030262564575 ));\n    float b = dot(srgb, vec3(0.0032841812209659232, 0.019791856647418008,  0.16973987192755477 ));\n    \n    return vec3(r, g, b);\n}\n/*/\nvec3 sRGB_to_CIERGB(vec3 rgb) { return XYZ_to_CIERGB(sRGB_to_XYZ(rgb)); }\n//*/\n\n// D65 white point\nconst vec3 D65_XYZ = vec3(0.9504716671128306, 0.9999570331323425, 1.0889782052041752);\n\nfloat sRGB_NonlinearEncode(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_NonlinearDecode(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_NonlinearEncode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_NonlinearDecode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n\nfloat sRGB_EOTF(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_InvEOTF(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_InvEOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n\n// https://en.wikipedia.org/wiki/CIELUV\nvec3 XYZ_to_Luv(vec3 xyz)\n{\n    const float upn = 0.19783;\n    const float vpn = 0.46834;\n\n    float X = xyz.x;\n    float Y = xyz.y;\n    float Z = xyz.z;\n    \n    float d = X + 15.0*Y + 3.0*Z;\n    \n    float up = 4.0*X / d;\n    float vp = 9.0*Y / d;\n    \n    float Y2 = Y / D65_XYZ.y;\n    \n    float L = Y2 > Pow3(6.0/29.0) ? pow(Y2, 1.0/3.0) * 116.0 - 16.0 : Y2 * Pow3(29.0/3.0);\n    \t  L *= 0.01;\n    \n    float u = 13.0*L * (up - upn);\n    float v = 13.0*L * (vp - vpn);\n    \n    return vec3(L, u, v);\n}\n\nvec3 Luv_to_XYZ(vec3 luv)\n{\n    const float upn = 0.19783;\n    const float vpn = 0.46834;\n\n    float L = luv.x;\n    float u = luv.y;\n    float v = luv.z;\n    \n    float up = u / (13.0*L) + upn;\n    float vp = v / (13.0*L) + vpn;\n    \n          L *= 100.0;\n    float Y = D65_XYZ.y*1.0 * (L > 8.0 ? Pow3(L/116.0 + 16.0/116.0) : L * Pow3(3.0/29.0));\n    \n    float X = Y * (9.0/4.0) * (up/vp);\n    float Z = Y * (12.0 - 3.0*up - 20.0*vp) / vp * 0.25;\n        \n    return vec3(X, Y, Z);\n}\n\n// https://en.wikipedia.org/wiki/Lab_color_space\nfloat Lab_to_XYZ_f(float t)\n{\n    const float d = 6.0/29.0;\n    \n    return t > d*d*d ? pow(t, 1.0/3.0) : t / (3.0 * d*d) + 4.0/29.0;\n}\n\n#define f(t) Lab_to_XYZ_f(t)\nvec3 XYZ_to_Lab(vec3 xyz)\n{\n    float X2 = f(xyz.x / D65_XYZ.x);\n    float Y2 = f(xyz.y / D65_XYZ.y);\n    float Z2 = f(xyz.z / D65_XYZ.z);\n    \n    float L = 1.16 *  Y2 - 0.16;\n    float a = 5.0  * (X2 - Y2);\n    float b = 2.0  * (Y2 - Z2);\n    \n    return vec3(L, a, b);\n}\n\nfloat Y_to_L(float y)\n{\n    return f(y / D65_XYZ.y) * 1.16 - 0.16; \n}\n#undef f\n\nfloat Lab_to_XYZ_fi(float t)\n{\n    const float d = 6.0/29.0;\n    \n    return t > d ? t*t*t : 3.0 * d*d * (t - 4.0/29.0);\n}\n#define fi(t) Lab_to_XYZ_fi(t)\n\nvec3 Lab_to_XYZ(vec3 lab)\n{\n    float L2 = lab.x / 1.16 + 0.16/1.16;\n    \n    float X = D65_XYZ.x * fi(L2 + lab.y * 0.2);\n    float Y = D65_XYZ.y * fi(L2);\n    float Z = D65_XYZ.z * fi(L2 - lab.z * 0.5);\n    \n    return vec3(X, Y, Z);\n}\n\nfloat L_to_Y(float l)\n{\n    return D65_XYZ.y * fi(l / 1.16 + 0.16/1.16);\n}\n#undef fi\n\n//#if 0\n//\t#define XYZ_to_Luv XYZ_to_Lab\n//\t#define Luv_to_XYZ Lab_to_XYZ\n//#endif\n\nvec3 HCL_to_Lab(vec3 hcl)\n{\n    //hcl.x += 1.0/16.0;\n    \n    vec2 ab = vec2(cos(hcl.x * Pi * 2.0), sin(hcl.x * Pi * 2.0)) * hcl.y;\n    \n    return vec3(hcl.z, ab); \n}\n\nvec3 Lab_to_HCL(vec3 lab)\n{\n    vec2 ab = lab.yz;\n    \n    float c = length(ab);  \n    \n    float h = atan(-ab.y, -ab.x) / Pi * 0.5 + 0.5;\n    \n    return vec3(h, c, lab.x);\n}\n\n//#define HCL_to_Luv HCL_to_Lab\n//#define Luv_to_HCL Lab_to_HCL\n\n\nvec3 Hue_to_RGB(float hue)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n\treturn clamp(vec3(R, G, B), 0.0, 1.0);\n}\n\nvec3 HSV_to_RGB(vec3 hsv)\n{\n    return (Hue_to_RGB(hsv.x) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\n\nfloat SCurveC1(float x) { return x*x*(3.0-2.0*x); }\nvec3  SCurveC1(vec3  x) { return x*x*(3.0-2.0*x); }\n\n\n\n\n/*\n// <---------------------------------------------------------------------------------------------------------------------------------\nfloat RGB_to_Hue(vec3 rgb)\n{\n    float v = (rgb.r - rgb.g - rgb.b) / 6.0 + 1.0/3.0;\n    \n    float mx = max(rgb.r, max(rgb.g, rgb.b));\n    float mn = min(rgb.r, min(rgb.g, rgb.b));\n    \n    return (rgb.g == mn || rgb.b == mx ? v : -v) + 0.5;    \n}\n/*/\nfloat RGB_to_Hue(vec3 rgb)\n{\n    float v = (rgb.r - rgb.g - rgb.b) *  (1.0/6.0) + (1.0/3.0);\n    \n    return (rgb.b < rgb.g ? -v : v) + 0.5;     \n}\n//*/\n\nvec3 RGB_to_HSV(vec3 rgb)\n{\n    float v = max(rgb.r, max(rgb.g, rgb.b));\n    \n    if(v == 0.0) return vec3(0.0);\n    \n    rgb /= v;\n    \n    float ds = min(rgb.r, min(rgb.g, rgb.b));\n    float s = 1.0 - ds;\n    \n    if(ds == 1.0) return vec3(0.0, 0.0, v);\n    \n    rgb = (rgb - ds) / s;\n    \n    float h = RGB_to_Hue(rgb);\n    \n    return vec3(h, s, v);\n}\n\n\nvec3 Lab_to_sRGB(vec3 lab){return XYZ_to_sRGB(Lab_to_XYZ(lab));}\nvec3 Luv_to_sRGB(vec3 lab){return XYZ_to_sRGB(Luv_to_XYZ(lab));}\nvec3 HCL_to_sRGB(vec3 hcl){return Lab_to_sRGB(HCL_to_Lab(hcl));}\n\nvec3 sRGB_to_Luv(vec3 rgb){return XYZ_to_Luv(sRGB_to_XYZ(rgb));}\nvec3 sRGB_to_Lab(vec3 rgb){return XYZ_to_Lab(sRGB_to_XYZ(rgb));}\nvec3 sRGB_to_HCL(vec3 rgb){return Lab_to_HCL(sRGB_to_Lab(rgb));}\n\n\nvec3 HSV_to_Lab(vec3 hsv){return sRGB_to_Lab(HSV_to_RGB(hsv));}\nvec3 HSV_to_Luv(vec3 hsv){return sRGB_to_Luv(HSV_to_RGB(hsv));}\nvec3 HSV_to_HCL(vec3 hsv){return sRGB_to_HCL(HSV_to_RGB(hsv));}\n\nvec3 Lab_to_HSV(vec3 lab){return RGB_to_HSV(Lab_to_sRGB(lab));}\nvec3 Luv_to_HSV(vec3 lab){return RGB_to_HSV(Luv_to_sRGB(lab));}\nvec3 HCL_to_HSV(vec3 hcl){return RGB_to_HSV(HCL_to_sRGB(hcl));}\n\nvec4 RGBL_From_RGB(vec3 rgb)\n{\n    float wr = 0.21258623078559552;\n    float wg = 0.71517030370341080;\n    float wb = 0.07220049864333620;\n    \n    return vec4(rgb, dot(rgb, vec3(wr, wg, wb)));\n}\n\nvec3 RGB_From_RGBL(vec4 rgbl)\n{\n    return vec3\n    (\n        dot(rgbl, vec4(0.971065, -0.0973416, -0.00982719, 0.13611)),\n        dot(rgbl, vec4(-0.0973416, 0.672529, -0.0330601, 0.457892)),\n        dot(rgbl, vec4(-0.00982719, -0.0330601, 0.996662, 0.0462268))\n    );\n}\n\nvec2 CmplxMul(vec2 c0, vec2 c1) \n{ \n    return vec2(c0.x * c1.x - c0.y * c1.y, \n                c0.x * c1.y + c0.y * c1.x); \n}\n\nvec2 CmplxDiv(vec2 c0, vec2 c1) \n{ \n   float div = (c1.x * c1.x) + (c1.y * c1.y);\n    \n   return vec2(c0.x * c1.x + c0.y * c1.y, \n               c0.y * c1.x - c0.x * c1.y) / div; \n}\n\nfloat Det2D(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat PotExpFwrd(float x, float s)\n{\n    return 1.0 / (exp2(s * x) - 1.0);\n}\n\nfloat PotExpInv(float x, float s)\n{\n    return log2(1.0 + 1.0 / x) / s;\n}\n\nfloat SMinPotExp(float a, float b, float s)\n{\n    return PotExpInv(PotExpFwrd(a, s) + PotExpFwrd(b, s), s);\n}\n\nfloat BlerbBiasExp(float x, float bx, float bs)\n{\n    return SMinPotExp(x / bx, (1.0 - x) / (1.0 - bx), bs);\n}\n\nfloat BlerpExp(float y0, float y1, float x, float bx, float by, float bs)\n{\n    return y0 + (y1 - y0) * x + by * BlerbBiasExp(x, bx, bs);\n}\n\n// limit bs->0 BlerbBiasExp(x, bx, bs):\nfloat BlerbBiasSqr(float x, float bx)\n{\n    return (x*x - x) / ((x * 2.0 - 1.0) * bx - x);\n}\n\n// Blerp(y0, y1, x, 0.5, 0.0) == lerp(y0, y1, x)\nfloat Blerp(float y0, float y1, float x, float bx, float by)\n{\n    return y0 + (y1 - y0) * x + by * BlerbBiasSqr(x, bx);\n}\n\nfloat SCurveT(float x, float l)\n{\n    const float a = Pi * 0.5 - 1.0;\n    const float b = 0.768178157887372;\n \n    x = x * 2.0 - 1.0;\n    \n    float sig = x < 0.0 ? -1.0 : 1.0;\n    \n    x = abs(x) * 2.0 - 1.0;\n    \n    float cabs = 1.0 - SMinPotExp(1.0 - x, (x + 1.0) * lerp(2.0, a, l), b / l);\t\n    float ramp = (x - cabs) * 0.5;\n    \n    return (ramp + 1.0) * sig * 0.5 + 0.5;\n}\n\nvec3 Hue2_to_RGB(float hue, float blur)\n{\n    float H6 = hue * 6.0;\n    \n    float R =           abs(hue *-2.0 +  1.0      );\n    float G = abs(1.0 - abs(hue * 2.0 - (2.0/3.0)));\n    float B = abs(1.0 - abs(hue * 2.0 - (4.0/3.0)));\n    \n    R = SCurveT(R, blur);\n    G = SCurveT(G, blur);\n    B = SCurveT(B, blur);\n    \n    vec3 rgb = vec3(R, G, B);\n    \n\treturn clamp(rgb, 0.0, 1.0);\n}\n\nvec3 HSV2_to_RGB(vec3 hsv, float hueBlur)\n{\n    return (SCurveC1(Hue2_to_RGB(hsv.x, hueBlur)) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\nvec3 Hue_to_RGB(float hue, float blur)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n    float R2 = sin((hue + 3.0/6.0) * Pi); R2 *= R2;\n    float G2 = sin((hue + 1.0/6.0) * Pi); G2 *= G2;\n    float B2 = sin((hue + 5.0/6.0) * Pi); B2 *= B2;\n\n    vec3 rgb = mix(clamp(vec3(R, G, B), 0.0, 1.0), vec3(R2, G2, B2), blur);\n    \n\treturn rgb;\n}\n\nvec3 HSV_to_RGB(vec3 hsv, float hueBlur)\n{\n    return (SCurveC1(Hue_to_RGB(hsv.x, hueBlur)) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    vec2 tex2 = uv / PixelCount.yy;\n    \n    \n    vec3 col = vec3(0.0);\n    \n    fragColor = SCurveT(tex.x, 0.12) < tex.y ? vec4(1.0) : vec4(0.0);\n    //return;\n\t/*\n    col = Lab_to_sRGB(vec3(0.5, tex2.xy * 2.0 - 1.0));\n    col = Luv_to_sRGB(vec3(0.5, tex2.xy * 4.0 - 2.0));\n\n    if(col.r < 0.0 || col.r > 1.0 || col.g < 0.0 || col.g > 1.0 || col.b < 0.0 || col.b > 1.0) col = vec3(1.0, 0.0, 1.0);\n    if(tex2.x > 1.0) col *= 0.1;\n    \n    fragColor = vec4(sRGB_NonlinearEncode(col), 1.0);\n    \n    return;\n    /**/\n    \n    if(false)\n    {\n        col = vec3(tex.x);\n        col = Hue_to_RGB(tex.x);\n        col = tex.y < 0.5 ? col * tex.y * 2.0 : mix(col, vec3(1.0), tex.y * 2.0 - 1.0);\n        \n        float L = sRGB_to_Y(col);\n        float o = 16.0;\n        float Lq = round(L * o) / o;\n        \n        //col = vec3(L);\n        if(L != 0.0) col = col / L * Lq;\n        \n        float q = 8.0;\n        vec3 luv = RGB_to_HSV(col);\n        luv.xz = round(luv.xz * q) / q;\n        \n        //luv = Lab_to_HCL(luv);\n        //luv.xy = round(luv.xy * q) / q;\n        //luv = HCL_to_Lab(luv);\n        //col = HSV_to_RGB(luv);\n        col = clamp(col, 0.0, 1.0);\n        \n\t\tfragColor = vec4(sRGB_NonlinearEncode(col), 1.0);\n        return;\n    }\n    \n    \n    {\n    float q = 8.0;\n    \n    //float v = texelFetch(iChannel0, ivec2(mod(uv, 8.0)), 0).x;\n\n    if(tex.y < 0.25)\n    {\n    tex.x = floor(tex.x * q) / (q - 1.0);\n        //tex.x = mod(tex.x*6.0,1.0);\n        //fragColor = vec4(tex.x);\n        //return;\n    //tex.x = (floor(tex.x * q) + fract(tex.x * q)) / q;\n    //tex = (floor(tex * q) + step(v, fract(tex * q))) / q;\n    }\n    else if(tex.y > 0.75)\n    tex.x = sRGB_NonlinearDecode(floor(sRGB_NonlinearEncode(tex.x) * q) / (q - 1.0));\n        \n    }\n    \n    vec3 hsv0 = vec3(0.6, 0.99, 0.02);\n    vec3 hsv1 = vec3(0.12, 0.40, 1.00);\n    \n    vec3 rgb0 = HSV_to_RGB(hsv0);\n    vec3 rgb1 = HSV_to_RGB(hsv1);\n    \n    vec3 lab0 = HSV_to_Lab(hsv0);\n    vec3 lab1 = HSV_to_Lab(hsv1);  \n    \n    vec3 luv0 = HSV_to_Luv(hsv0);\n    vec3 luv1 = HSV_to_Luv(hsv1);\n    \n    col = HSV_to_RGB(mix(hsv0, hsv1, tex.x));\n   \n    col = HSV_to_RGB(vec3(Blerp(hsv0.x, hsv1.x, tex.x, 0.6, 0.1),\n                          Blerp(hsv0.y, hsv1.y, tex.x, 0.1,-0.2), \n                           lerp(hsv0.z, hsv1.z, tex.x))\n                     ,0.5);\n    \n    //col = mix(rgb0, rgb1, tex.x);\n    //col = Luv_to_sRGB(mix(luv0, luv1, tex.x));\n    //col = col / sRGB_to_Y(col) * lerp(hsv0.z, hsv1.z, tex.x);\n    \n    //col = Hue2_to_RGB(tex.x, 0.5);\n    //col = Hue_to_RGB(tex.x, lerp(0.8, 0.01, tex.x));\n    \n    //if(false)\n    if(tex.y < 0.02)\n    if(col.r < 0.0 || col.r > 1.0 || col.g < 0.0 || col.g > 1.0 || col.b < 0.0 || col.b > 1.0) \n        col = vec3(1.0, 0.0, 1.0)*0.0+0.1;\n    \n    //vec3 col3 = CIERGB_to_sRGB(sRGB_to_CIERGB(col));\n    //if(length(col - col3) > 0.0000001) col = vec3(1.0);\n        \n        //col = XYZ_to_Luv(Luv_to_XYZ(col));\n        \n\tfragColor = vec4(sRGB_NonlinearEncode(col), 1.0);\n    //fragColor = vec4(sRGB_NonlinearDecode(floor(sRGB_NonlinearEncode(tex.x) * 8.0) / (8.0 - 1.0)));\n    //fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}