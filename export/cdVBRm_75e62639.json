{"ver":"0.1","info":{"id":"cdVBRm","date":"1698068062","viewed":84,"name":"Lenia Pt.7 Multi-channel arrays","username":"26apastor","description":"An implementation of continuous arrays with multi-channel Lenia.","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["automata","life","cellular","continuous","artificial","lenia"],"hasliked":0,"parentid":"mdGfzR","parentname":"Lenia Pt.6 Continuous Arrays"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float nop        = 0.0;\nconst int inop         = 0;\nconst ivec4 iv0        = ivec4(0);\nconst ivec4 iv1        = ivec4(1);\nconst ivec4 iv2        = ivec4(2);\nconst float noise_width = 100.0;\nconst float mouse_noise = 10.0;\n\n\nconst mat4 rmu = mat4(vec4(0.5), vec4(0.5), vec4(0.5), vec4(0.5));\nconst mat4 rsigma = mat4(vec4(0.15), vec4(0.15), vec4(0.15), vec4(0.15));\n\nconst float noise_base = 0.165;\nconst float max_radius = 12.;\nconst float T = 2.;\nconst mat4 betaLen = mat4( 1., 1., 1., 2., 1., 2., 1., 1., 1., 1., 1., 3., 1., 1., 2., nop );  // kernel ring number\nconst mat4 beta0   = mat4( 1., 1., 1., 1./12., 1., 5./6., 1., 1., 1., 1., 1., 1., 1., 1., 1., nop );  // kernel ring heights\nconst mat4 beta1   = mat4( 0., 0., 0., 1., 0., 1., 0., 0., 0., 0., 0., 11./12., 0., 0., 1./12., nop );\nconst mat4 beta2   = mat4( 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., nop );\nconst mat4 mu      = mat4( 0.168, 0.1, 0.265, 0.111, 0.327, 0.223, 0.293, 0.465, 0.606, 0.404, 0.377, 0.297, 0.319, 0.483, 0.1, nop );  // growth center\nconst mat4 sigma   = mat4( 0.062, 0.1495, 0.0488, 0.0555, 0.0763, 0.0333, 0.0724, 0.1345, 0.1807, 0.1413, 0.1136, 0.0701, 0.1038, 0.1185, 0.0571, nop );  // growth width\nconst mat4 eta     = mat4( 0.076, 0.562, 0.548, 0.306, 0.568, 0.598, 0.396, 0.298, 0.59, 0.396, 0.156, 0.426, 0.558, 0.388, 0.132, nop );  // growth strength\nconst mat4 rho    = mat4( 0.58, 0.68, 0.5, 0.87, 1.0, 1.0, 0.88, 0.88, 0.86, 0.98, 0.63, 0.53, 1.0, 0.89, 0.59, nop );  // relative kernel radius\nconst mat4 c0     = mat4( 0., 0., 0., 1., 1., 1., 2., 2., 2., 0., 0., 1., 1., 2., 2., nop );  // source channels\nconst mat4 c1    = mat4( 0., 0., 0., 1., 1., 1., 2., 2., 2., 1., 2., 0., 2., 0., 1., nop );  // destination channels\n\nvec3 soft_clip(vec3 x) {\n    return clamp(tanh(2.0 * x - 1.0) / 2.0 + 0.5, 0.0, 1.0);\n}\n\nmat4 gaussian_bell(mat4 sum, mat4 m, mat4 s) {\n    mat4 p = -matrixCompMult((sum - m) / s, (sum - m) / s) / 2.0;\n    return mat4(exp(p[0]), exp(p[1]), exp(p[2]), exp(p[3]));\n}\n\nfloat gaussian_bell(float x, float m, float s) {\n    return exp(-pow((x - m) / s, 2.0) / 2.0);\n}\n\nfloat getGrowthDest(mat4 growth, ivec4 channel) {\n    return dot(growth[0], vec4(equal(ivec4(c1[0]), channel))) + \n           dot(growth[1], vec4(equal(ivec4(c1[1]), channel))) + \n           dot(growth[2], vec4(equal(ivec4(c1[2]), channel))) + \n           dot(growth[3], vec4(equal(ivec4(c1[3]), channel)));\n}\n\nvec4 getRGB(vec3 v, ivec4 srcv)\n{\n    return v.r * vec4(equal(srcv, iv0)) + v.g * vec4(equal(srcv, iv1)) + v.b * vec4(equal(srcv, iv2));\n}\n\nmat4 getCell(vec2 xy)\n{\n    xy = mod(xy / iResolution.xy, 1.);\n    vec3 cell = texture(iChannel0, xy).rgb;\n    return mat4(getRGB(cell, ivec4(c0[0])), \n                getRGB(cell, ivec4(c0[1])), \n                getRGB(cell, ivec4(c0[2])), \n                getRGB(cell, ivec4(c0[3]))\n           );\n}\n\nmat4 getWeight(float dist, mat4 rho) {\n    mat4 Br = betaLen / rho * dist;\n    mat4 radiuses = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));\n    for (int i = 0; i < 4; i++)\n    for (int j = 0; j < 4; j++) {\n        radiuses[i][j] += beta0[i][j] * gaussian_bell(dist, 0.0, 1.0 / betaLen[i][j]) +\n                          beta1[i][j] * gaussian_bell(dist, 1.0, 1.0 / betaLen[i][j]) +\n                          beta2[i][j] * gaussian_bell(dist, 2.0, 1.0 / betaLen[i][j]);\n    }\n    mat4 Br_mod = mat4(mod(Br[0], 1.0), mod(Br[1], 1.0), mod(Br[2], 1.0), mod(Br[3], 1.0));\n    return matrixCompMult(radiuses, gaussian_bell(Br_mod, rmu, rsigma));\n}\n\n/*\nvec3 getWeight(float dist) {\n    vec3 Br = dist * betaLen;\n    vec3 radiuses = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        radiuses[i] += beta0[i] * gaussian_bell(dist, 0.0, 1.0 / betaLen[i]) +\n                       beta1[i] * gaussian_bell(dist, 1.0, 1.0 / betaLen[i]) +\n                       beta2[i] * gaussian_bell(dist, 2.0, 1.0 / betaLen[i]);\n    }\n    \n    vec3 Br_mod = mod(Br, 1.0);\n    return radiuses * gaussian_bell(Br_mod, vec3(rho), vec3(omega));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    mat4 sum = mat4(0.0), total = mat4(0.0);\n    mat4 weight = getWeight(0.0, rho);\n    mat4 cell = getCell(fragCoord); sum += matrixCompMult(cell, weight); total += weight;\n    \n    for(float x = 1.0; x <= max_radius; x++) {\n        float R = x / max_radius;\n        weight = getWeight(R, rho);\n        cell = getCell(fragCoord + vec2(x, 0));   sum += matrixCompMult(cell, weight); total += weight;\n        cell = getCell(fragCoord + vec2(-x, 0));  sum += matrixCompMult(cell, weight); total += weight;\n        cell = getCell(fragCoord + vec2(0, x));  sum += matrixCompMult(cell, weight); total += weight;\n        cell = getCell(fragCoord + vec2(0, -x)); sum += matrixCompMult(cell, weight); total += weight;   \n    }\n\n    for(float x = 1.0; x <= max_radius; x++) {\n        for(float y = 1.0; y <= max_radius; y++) {\n            float R = sqrt(x * x + y * y) / max_radius;\n            if (R <= 1.0) {\n                weight = getWeight(R, rho);\n                cell = getCell(fragCoord + vec2(x, y));   sum += matrixCompMult(cell, weight); total += weight;\n                cell = getCell(fragCoord + vec2(-x, y));  sum += matrixCompMult(cell, weight); total += weight;\n                cell = getCell(fragCoord + vec2(x, -y));  sum += matrixCompMult(cell, weight); total += weight;\n                cell = getCell(fragCoord + vec2(-x, -y)); sum += matrixCompMult(cell, weight); total += weight;\n                \n            }\n        }\n    }\n    \n    sum /= total;\n    \n    mat4 g = matrixCompMult(eta, gaussian_bell(sum, mu, sigma) * 2.0 - 1.0);\n    vec3 rgb_growth = vec3(getGrowthDest(g, iv0), getGrowthDest(g, iv1), getGrowthDest(g, iv2));\n    vec3 previous_cell = texture(iChannel0, uv).rgb;\n    vec3 rgb = soft_clip(previous_cell + rgb_growth / T);\n    \n    if (iFrame < 1) {\n        rgb.r = noise_base + noise(fragCoord/noise_width + mod(iDate.w,1.)*44.5);\n        rgb.g = noise_base + noise(fragCoord/noise_width + mod(iDate.w,1.)*100.0);\n        rgb.b = noise_base + noise(fragCoord/noise_width + mod(iDate.w,1.)*155.5);\n    }\n    if (iMouse.z > 0.) {\n        float d = length((fragCoord.xy - iMouse.xy) / iResolution.xx);\n        if (d <= max_radius/iResolution.x) {\n        \trgb.r = 0.3 + noise(fragCoord/mouse_noise + mod(iDate.w,1.)*44.5);\n            rgb.g = 0.3 + noise(fragCoord/mouse_noise + mod(iDate.w,1.)*100.0);\n            rgb.b = 0.3 + noise(fragCoord/mouse_noise + mod(iDate.w,1.)*155.5);\n        }\n    }\n    fragColor = vec4(rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*Chakazul's use of this hash function is genius and all credits to him in his implementation of lenia: https://www.shadertoy.com/user/Chakazul\n*/\n\n// Noise simplex 2D by iq - https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}","name":"Common","description":"","type":"common"}]}