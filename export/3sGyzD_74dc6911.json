{"ver":"0.1","info":{"id":"3sGyzD","date":"1602279411","viewed":75,"name":"fffaster","username":"adr","description":"..","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["seizure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// followed great raymarch tutorial https://www.shadertoy.com/view/XlBGDW\n#define CLIP_NEAR 0.1\n#define CLIP_FAR 40.0\n#define STEPS 100\n#define EPSILON 0.0001\n#define DISTANCE_BIAS 0.7\n#define PI 3.14159\n#define SPEED 0.25\n#define START 10.0\n\n// distance to sphere function (p is world position of the ray, s is sphere radius)\n// from https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat scene(vec3 p) {\n    vec3 pos_big = vec3(fract(p.x * p.x + 0.5) - 0.5, p.y, p.z); // this + careful camera control is where the effect comes from \n    float d = sdSphere(pos_big, 0.3);\n    return d;\n}\n\nfloat raymarch(vec3 p, vec3 direction) {\n\tfloat dist = CLIP_NEAR;\n    float result;\n    for (int i = 0; i < STEPS; ++i) {\n        result = scene(p + direction * dist);\n        if (result < EPSILON) { break; }\n        dist += result * DISTANCE_BIAS;\n        if (dist > CLIP_FAR) { break; }\n    }\n    return dist;\n}\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy) - scene(ray_hit_position - dn.xyy);\n\tn.y\t= scene(ray_hit_position + dn.yxy) - scene(ray_hit_position - dn.yxy);\n\tn.z\t= scene(ray_hit_position + dn.yyx) - scene(ray_hit_position - dn.yyx);\n\treturn normalize(n);\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(eye - center);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 offset = vec3(SPEED * iTime + START, 0.0,  0.0);\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 direction = normalize(vec3(uv, 2.5));    \n    \n    vec3 eye = vec3(\n        1.5 - 0.5 * sin(PI * iMouse.x / iResolution.x) + offset.x,\n        0.12 - 0.05 * iMouse.y / iResolution.y + offset.y + 0.1 * sin(PI * iMouse.x / iResolution.x),\n        0.0 - 0.2 * cos(PI * iMouse.x / iResolution.x) + offset.z);\n    \n    mat4 viewToWorld = viewMatrix(eye, offset, vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(direction, 0.0)).xyz;\n    direction = worldDir;\n    vec3 camera_origin = eye;\n    float result = raymarch(camera_origin, direction);\n\n    // arbitrary fog to hide artifacts near the far plane\n    // 1.0 / distance results in a nice fog that starts white\n    // but if distance is 0 \n    float fog = 1.0 - result / CLIP_FAR;\n    \n    vec3 materialColor = vec3(1.0, 0.25, 0.1);\n    \n    // We can reconstruct the intersection point using the distance and original ray\n    vec3 intersection = camera_origin + direction * result;\n    \n    // The normals can be retrieved in a fast way\n    // by taking samples close to the end-result sample\n    // their resulting distances to the world are used to see how the surface curves in 3D\n    // This math I always steal from somewhere ;)\n    vec3 nrml = normal(intersection, 0.01);\n    \n    // Lambert lighting is the dot product of a directional light and the normal\n    vec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n   \tfloat diffuse = dot(light_dir, nrml);\n    // Wrap the lighting around\n    // https://developer.valvesoftware.com/wiki/Half_Lambert\n    //diffuse = diffuse * 0.5 + 0.5;\n    // For real diffuse, use this instead (to avoid negative light)\n    //diffuse = max(0.0, diffuse);\n    \n    // Combine ambient light and diffuse lit directional light\n    vec3 light_color = vec3(1.4, 1.2, 0.7);\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n\tfragColor = vec4(diffuseLit, 1.0) * fog; /* applying the fog last */\n}","name":"Image","description":"","type":"image"}]}