{"ver":"0.1","info":{"id":"lXGXR3","date":"1720789565","viewed":47,"name":"ray-march steps1: basic","username":"letbonsaibe","description":"learn material \n1. https://www.youtube.com/watch?v=PGtv-dBi2wE&t=1591s&ab_channel=TheArtofCode\n2. https://iquilezles.org/articles/rmshadows/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 80\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.01\n#define NORMAL_DELTA 0.01\n#define DIFFUSE_COLOR vec3(0.671,0.651,0.651)\n#define AMBIENT_COLOR vec3(0.1, 0.1, 0.1)\n#define AA 2\n\n\nfloat GetDist(vec3 p) {\n    vec4 sphere = vec4(0., 1., 6., 1.);\n    float distanceSphere = length(p - sphere.xyz) - sphere.w;\n    float distancePlane  = p.y;\n    return min(distanceSphere, distancePlane);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_DELTA, 0.);\n    return normalize(vec3(\n        GetDist(p+e. xyy) - GetDist(p-e.xyy),\n        GetDist(p+e.yxy) - GetDist(p-e.yxy),\n        GetDist(p+e.yyx) - GetDist(p-e.yyx)\n    )); \n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float distanceFromOrigin = 0.;\n    \n    for (int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + distanceFromOrigin*rd;\n        float distanceFromSurface = GetDist(p);\n        distanceFromOrigin += distanceFromSurface;\n        if(distanceFromSurface<SURFACE_DIST || distanceFromOrigin>MAX_DIST) break;\n    }\n    return distanceFromOrigin;\n}\n\n\nfloat GetShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<MAX_STEPS && t<maxt; i++ )\n    {\n        float h = GetDist(ro + rd*t);\n        if( h<SURFACE_DIST )\n            return 0.0;\n\t\tres = min( res, k*h/t );\n        t += max(.001, .5 *h);\n    }\n    return res;\n}\n\nfloat GetDiffuseLight(vec3 p, vec3 lightPos ) {\n    vec3 incidentLight = normalize(p - lightPos);\n    vec3 surfaceNormal = GetNormal(p);\n    float diffuseRatio = clamp(dot(-incidentLight,surfaceNormal), 0.0, 1.0);\n    \n    float distanceFromLight = distance(p, lightPos);\n    float shadow = GetShadow(\n        p + SURFACE_DIST * 2.0 * surfaceNormal, \n        -incidentLight, \n        0.1, \n        distance(p, lightPos), \n        4.\n    );\n    \n    return diffuseRatio * shadow;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 tot = vec3(0.0);\n\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    // pixel coordinates\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n    vec3 col = vec3(0.0);\n    \n    vec3 rayOrigin    = vec3(0., 1., 3.);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.));\n    \n    float d = RayMarch(rayOrigin, rayDirection);\n    vec3 p = rayOrigin + rayDirection * d;\n    \n    \n    vec3 directionalLightPosition = vec3(1., 5., 5.);\n    directionalLightPosition.xz += vec2(sin(iTime), cos(iTime)*2.);\n    \n    float diffuse = GetDiffuseLight(p, directionalLightPosition);\n    \n    col += diffuse  * DIFFUSE_COLOR ;\n    col += AMBIENT_COLOR;\n    \n    tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 ); \n}","name":"Image","description":"","type":"image"}]}