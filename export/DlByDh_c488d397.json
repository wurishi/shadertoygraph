{"ver":"0.1","info":{"id":"DlByDh","date":"1691691495","viewed":31,"name":"00GraphicsClassLesson02","username":"foodini","description":"GraphicsIntro","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["graphicsintro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragCoord comes in as the x,y index into the pixel array of the screen. In other\n    // words, its scale depends upon the screen resolution. It's most convenient to think\n    // of pixels' locations in terms of their relative positions. This scales the screen\n    // to range from 0.0 to 1.0 in both dimensions.\n    vec2 uv = fragCoord/(iResolution.xy - vec2(1.0, 1.0));\n\n    // We want 0,0 to be the center of the screen, so we rescale and recenter:\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    // The pixels in the image now go from <-1.0, -1.0> at the bottom left to\n    // <1.0, 1.0> at the top right. This means our pixels are squashed. Going up\n    // by one pixel incrases y by more than going right by one increases x. Rescale\n    // in the y direction to compensate. This means that the bottom left is no\n    // longer <-1.0, -1.0>. It's more like <-1.0, -.65>, though it depends on your screen\n    // resolution.\n    uv.y /= (iResolution.x/iResolution.y);\n    \n    // Draw a square....\n    if(abs(uv.x) < 0.2 && abs(uv.y) < 0.2)\n        fragColor = vec4(vec3(1.0), 1.0);\n    else\n        fragColor = vec4(vec3(0.0), 1.0);\n        \n        \n    // WHAT HAPPENS IF YOU FORGOT TO SCALE uv.y on line 21, above?\n    \n    // Draw a circle....\n    \n    // Draw an X.....\n        \n    // No, draw THAT X.\n    return;\n\n    // Harder: Draw a spiral....\n    //fragColor.xyz = vec3(sin(atan(uv.x, uv.y) + 20.0*length(uv)));\n    \n    // HARDER? Draw a W?\n}","name":"Image","description":"","type":"image"}]}