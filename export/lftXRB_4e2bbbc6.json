{"ver":"0.1","info":{"id":"lftXRB","date":"1714113625","viewed":128,"name":"Pathfinder (recreation)","username":"Envy24","description":"Original: https://www.shadertoy.com/view/XcK3Wd\nAlmost same code as in original shader + magnification.\nHold LMB to magnify.\nPress Q to generate new maze.\n","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["solver","flood","dynamic","maze","fill","programming"],"hasliked":0,"parentid":"McdSzS","parentname":"Flood fill (recreation)"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ImageTab\n// Coloring, Scene magnification.\n\n#define UNIT                      ( (200.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nvec3 scene( in vec2 SC ) \n{ \n    vec4 state = TEXF0(SC);\n    \n    if (state.r > 0.) // Filled cell?\n    {\n        if (TEXF0(MAZE_EXIT).x != 0.) // Backward traverse?\n        {\n            return state.a == 1. ? // Already traversed?\n                PATH :\n                FLOOR;\n        }\n    }\n    // Forward traverse.\n    return state.rgb;\n}\n\nfloat squareSDF(in vec2 NDC, in vec2 C, in float r) \n{ \n    NDC -= C; NDC = abs(NDC) - vec2(r); \n    return length(max(NDC,vec2(0.))) + min(max(NDC.x, NDC.y),0.0);\n}\n\nvec3 mag_scene(vec2 NDC, vec2 pos, float mag, inout vec3 color)\n{\n    float r = 80., s = 20.0;\n    color = mix(color,                    vec3(1), SMAA(squareSDF(NDC, pos, r+1.) - s)); // outline\n    color = mix(color, scene((NDC-pos)/mag + pos), SMAA(squareSDF(NDC, pos, r) - s));    // magnified scene    \n    return color;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC ) \n{\n    vec2 MP = iMouse.xy == vec2(0) ? iResolution.xy * .5 : iMouse.xy;   \n    float mag = 3.;\n    \n    vec3 color = scene(SC);\n         \n    if (LMB_IS_HOLD)\n        color = mag_scene(SC, MP, mag, color);\n        \n    O = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define KEY_Q                     ( 81.5 )\n#define KEY_Q_IS_PRESSED          ( texelFetch(iChannel3, ivec2(KEY_Q,1), 0).x > 0.)\n\n#define WALL       vec3(0,.3,.5)\n#define FLOOR      vec3(0)\n#define FILL       vec3(1,0,0)\n#define PATH       vec3(1)\n#define MAZE_ENTER vec2(0, floor(iResolution.y-1.))\n#define MAZE_EXIT  vec2(floor(iResolution.x-1.), 0)\n\n/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat fHuu(uint x, uint y)\n{\n    // Pick some seed values.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * seed2 + x;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n    \n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n#define FHUU(P) ( fHuu(uint(P.x), uint(P.y)) )","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// BufferA:\n// Maze generation, Flood fill (forward), Path reconstruction (backward).\n\nvec3 generate_maze(vec2 SC)\n{\n    float gate_size = 20.;\n    if ( (SC.x < gate_size && SC.y > iResolution.y - gate_size) || // Enter gate?\n         (SC.x > iResolution.x - gate_size && SC.y < gate_size) )  // Exit gate?\n    return FLOOR;\n\n    float treshold = 0.621; // bigger value -> more black points -> better solvability\n    SC += vec2(iFrame);  \n    return FHUU(SC) > treshold ? WALL : FLOOR;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC ) \n{ \n    SC = floor(SC);\n    \n    if ( iFrame == 0 || KEY_Q_IS_PRESSED ) // Generate maze?\n    {\n             if (SC == MAZE_ENTER) O = vec4(FILL, 0);\n        else                       O = vec4(generate_maze(SC), 0);\n        return;\n    }\n\n    /* Pathfinder algorithm from: https://www.shadertoy.com/view/XcK3Wd. */\n    vec4 state = TEXF0(SC); // Read cell state\n    // state.r = travel cost from enter to that cell; color information.\n    // state.g = color information.\n    // state.b = color information.\n    // state.a = forward of backward traverse flag.\n    \n    if (state.rgb == WALL) // Wall cell?\n    { O = state; return; } // Bypass.\n    \n    vec4 U = TEXF0(SC+vec2( 0., 1.)),\n         D = TEXF0(SC+vec2( 0.,-1.)),\n         R = TEXF0(SC+vec2( 1., 0.)),\n         L = TEXF0(SC+vec2(-1., 0.));\n\n    if (TEXF0(MAZE_EXIT).x == 0.) // MAZE_EXIT not reached yet?\n    {\n        // Forward traverse.\n    \n        float max_cost = max(max(U.r, D.r), max(R.r, L.r));\n    \n        if ( state.x == 0. && // Floor cell?\n             max_cost > 0. )  // Reachable cell?\n        { state.x = max_cost + 1.; } // Assign cost.\n    }\n    else\n    {\n        // Backward traverse (starts from MAZE_EXIT).\n    \n        // Mark MAZE_EXIT as traversed.\n        if (SC == MAZE_EXIT) { state.a = 1.; } \n                  \n        // Neighour is reachable?\n        // AND distance to that neighbour is 1?\n        if ( (U.a == 1. && U.r == state.r + 1.) ||\n             (D.a == 1. && D.r == state.r + 1.) ||\n             (R.a == 1. && R.r == state.r + 1.) ||\n             (L.a == 1. && L.r == state.r + 1.) )\n        { state.a = 1.; } // Mark as traversed.\n    }  \n    /* !Pathfinder algorithm from: https://www.shadertoy.com/view/XcK3Wd. */\n    \n    O = state;\n}","name":"Buffer A","description":"","type":"buffer"}]}