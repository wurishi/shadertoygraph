{"ver":"0.1","info":{"id":"dd3XWl","date":"1680549480","viewed":64,"name":"Mirror Scroller (pixel stretch)","username":"conc2304","description":"Mirror and scroll/tile an image or video from channel0. Speed and direction of scroll are based on mouse click.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["video","image","mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Scale the mouse position to adjust scrolling speed\n    float scrollSpeed = iMouse.x / iResolution.x;\n    \n    // Calculate the x and y coordinates with infinite scrolling\n    float x = mod(uv.x + iTime * scrollSpeed, 1.0);\n    float y = mod(uv.y + iTime * scrollSpeed, 1.0);\n    \n    // Calculate which image to display based on x and y coordinates\n    int xPos = int(floor(x * 2.0));\n    int yPos = int(floor(y * 2.0));\n    \n    // Flip the image based on its position in the grid\n    bool flipX = (xPos % 2) == 1;\n    bool flipY = (yPos % 2) == 1;\n    \n    // Calculate the offset of the current image\n    vec2 offset = vec2(float(xPos) * 0.5, float(yPos) * 0.5);\n    \n    // Apply the offset and flip to the UV coordinates\n    vec2 newUV = vec2(x * 2.0 - offset.x, y * 2.0 - offset.y);\n    if (flipX) newUV.x = 1.0 - newUV.x;\n    if (flipY) newUV.y = 1.0 - newUV.y;\n    \n    // Sample the texture at the transformed UV coordinates\n    fragColor = texture(iChannel0, newUV);\n}\n","name":"Image","description":"","type":"image"}]}