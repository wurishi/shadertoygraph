{"ver":"0.1","info":{"id":"flBSWt","date":"1629056286","viewed":222,"name":"Gravity Lake","username":"dominionxvii","description":"A weird structure being affected by gravity in a day cycle","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","lake","gravity","obelisk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MATERIAL_OBELISK 0\n#define MATERIAL_GEM 2\n\n#define MATERIAL_WATER 1\n\n#define PI 3.1416\n#define TAU 6.2831\n\n//comment out for render picture\n//#define ANTIALIASING\n\nfloat dayCycle;\nfloat gravitation;\nfloat gravitationDelay;\nfloat tremor;\nvec3 gemPos;\nvec3 lightPos;\n\nstruct Material\n{\n    float reflection;\n    int id;\n};\n\nstruct RayPrimHit\n{\n    float dist;\n    Material material;\n};\n\nstruct RayHit \n{\n    bool hasHit;\n    vec3 hitPos;\n    float dist;\n    vec3 normal;\n    vec3 reflPos;\n    vec3 reflDir;\n    Material material;\n    vec2 uv;\n};\n\nstruct Box\n{\n    vec3 position;\n    vec3 scale;\n    vec4 rotation;\n};\n\nstruct Triangle\n{\n    vec3 v0;\n    vec3 v1;\n    vec3 v2; \n};\n\n\nstruct Pyramid\n{\n    vec3 position;\n    vec3 scale;\n    vec4 rotation;\n};\n\n\nRayPrimHit SelectPrimHit(RayPrimHit hit1, RayPrimHit hit2)\n{\n    if(hit1.dist < hit2.dist)\n        return hit1;\n    else\n        return hit2;\n}\n\nvec3 ShrinkXZ(vec3 pos, vec3 level, float shrink)\n{\n    float h = abs(pos.y - level.y);\n    vec2 shrinkDir = normalize(level.xz - pos.xz);\n    pos.xz += shrinkDir * h * shrink; \n    return pos;\n}\n\n//Ray tracing \nbool AABBCollision(vec3 ro, vec3 rd, vec3 boxMin, vec3 boxMax, out float minDist)\n{\n    vec3 invRd = 1.0 / rd;\n    vec3 t1 = (boxMin - ro) * invRd;\n    vec3 t2 = (boxMax - ro) * invRd;\n\n    vec3 mins = min(t1, t2);\n    vec3 maxs = max(t1, t2);\n\n    float tmin = max(mins.x, max(mins.y, mins.z));\n    float tmax = min(maxs.x, min(maxs.y, maxs.z));\n\n    minDist = tmin;\n    return tmax > tmin && tmax > 0.0;\n}\n\nbool TriangleIntersection(vec3 ro, vec3 rd, in Triangle tri, out float minDist, out vec2 uv)\n{\n    uv = vec2(0.0);\n    minDist = 0.0;\n    vec3 v0v1 = tri.v1 - tri.v0;\n    vec3 v0v2 = tri.v2 - tri.v0;\n    vec3 pvec = cross(rd, v0v2);\n    float det = dot(v0v1, pvec);\n\n    //used to cull two sided triangles\n    if (abs(det) < 0.001)\n        return false;\n\n    float invDet = 1.0 / det;\n\n    vec3 tvec = ro - tri.v0;\n\n    float u = dot(tvec, pvec) * invDet;\n    if (u < 0.0 || u > 1.0) return false;\n\n    vec3 qvec = cross(tvec, v0v1);\n    float v = dot(rd, qvec) * invDet;\n    if (v < 0.0 || u + v > 1.0) return false;\n\n    minDist = dot(v0v2, qvec) * invDet;\n\n    uv = vec2(u, v);\n    return minDist > 0.0;\n}\n\n\n\nbool BoxIntersection(vec3 ro, vec3 rd, Box box, out float minDist)\n{\n    //todo inverse\n    vec4 invRot = qInverse(box.rotation);\n\n    //Set everything in local space\n    ro = qmul(invRot, ro - box.position);\n    rd = qmul(invRot, rd);\n    \n    vec3 aabbMin = -box.scale;\n    vec3 aabbMax = box.scale;\n\n    return AABBCollision(ro, rd, aabbMin, aabbMax, minDist);\n}\n\nvec3 CalculateCubeNormal(Box box, vec3 hitPos)\n{\n    vec3 diff = (hitPos - box.position);\n    \n    vec4 invRot = qInverse(box.rotation);\n    vec3 localHit = qmul(invRot, diff) / box.scale;\n    int longestDim = 0;\n    float maxLength = 0.0;\n    float hitSign = 0.0;\n\n    for (int i = 0; i < 3; i++)\n    {\n        if (abs(localHit[i]) > maxLength)\n        {\n            longestDim = i;\n            maxLength = abs(localHit[i]);\n            hitSign = localHit[i]  >= 0.0 ? 1.0 : -1.0;\n        }\n    }\n\n    vec3 normal = (longestDim == 0) ? vecX(hitSign) : ((longestDim == 1) ? vecY(hitSign) : vecZ(hitSign));\n    return qmul(box.rotation, normal);\n}\n\nvec2 CalculateProjectedUV(Box box, vec3 hitPos, vec3 normal)\n{\n    vec4 invRotation = qInverse(box.rotation);\n\n    vec3 diff = (hitPos - box.position);\n    vec3 localHit = qmul(invRotation, diff);\n    vec3 localNormal = qmul(invRotation, normal);\n\n    vec3 unlerpLocalHit = unlerp(localHit, -box.scale, box.scale);\n    \n    if (abs(localNormal.x) > 0.5)\n    {    \n        return unlerpLocalHit.zy * abs(box.scale.zy);\n    }\n    else if (abs(localNormal.y) > 0.5)\n    {    \n        return unlerpLocalHit.xz * abs(box.scale.xz);\n    }\n    else if (abs(localNormal.z) > 0.5)\n    {    \n        return unlerpLocalHit.xy * abs(box.scale.xy);\n    }   \n    return vec2(0.0);\n}\n\nbool PyramidIntersection(vec3 ro, vec3 rd, in Pyramid pyramid, out float minDist, out vec3 normal, out vec2 uv)\n{\n    vec3 s = pyramid.scale;\n    vec4 r = pyramid.rotation;\n    vec3 v0 = pyramid.position + qmul(r, vec3( s.x, 0.0,  s.z));\n    vec3 v1 = pyramid.position + qmul(r, vec3(-s.x, 0.0,  s.z));\n    vec3 v2 = pyramid.position + qmul(r, vec3( s.x, 0.0, -s.z));\n    vec3 v3 = pyramid.position + qmul(r, vec3(-s.x, 0.0, -s.z));\n    vec3 vTop = pyramid.position + qmul(r, vec3(0, s.y, 0));\n\n\n    const int size = 4;\n    Triangle tris[size] = Triangle[size]\n    (\n        Triangle(v2, vTop, v0),\n        Triangle(v3, vTop, v2),\n        Triangle(v1, vTop, v3),\n        Triangle(v0, vTop, v1)\n        //Triangle(v2, v0, v3), //Bottom 1\n        //Triangle(v3, v0, v1)  //Bottom 2\n    );\n\n    bool hasHit = false;\n    minDist = 9999.;   \n    for(int i = 0; i< size; i++)\n    {\n        float tempDist;    \n        vec2 tempUv;\n        Triangle tri = tris[i];\n\n        if(TriangleIntersection(ro, rd, tris[i], tempDist, tempUv) && tempDist < minDist)\n        {\n            uv = tempUv;\n            minDist = tempDist;\n            normal = normalize(cross(tri.v0 - tri.v2, tri.v1 - tri.v2));\n            hasHit = true;\n        }\n    }\n\n    return hasHit;\n}\n\n\nRayPrimHit RayCastObelisk(vec3 ro, vec3 rd, inout vec3 normal, inout vec2 uv)\n{\n    RayPrimHit hit;\n    hit.material.id = MATERIAL_OBELISK;\n    hit.material.reflection = 0.0;\n    \n    float minDist = 9999.0;\n    Box bestBox;\n    \n    bool hasHit = false;\n    vec3 basePosition =  vec3(0., 0.3, 3.);\n    float levitationHeight = 0.2;\n    vec3 boxScale = vec3(0.3, 0.1, 0.3);\n    float hourglassRatio = 0.5;\n    \n    float offsetRotation = PI/384.;\n    float dayRotation = dayCycle * TAU * 0.5;\n    float dayLevitation = dayCycle * TAU * 4.0;\n    float sinOffset = -1.5;\n    \n    const float quaterTurn = TAU / 8.0;\n    \n    int boxCount = 11;\n    float invBoxCount = 1.0 / float(boxCount - 1);\n    \n    for(int i = 0; i< boxCount; i++)\n    { \n        float t = float(i) * invBoxCount;\n        float halfDist = float(abs(0.5 - t) * 2.0);\n        \n        //Add a slight delay to the crystal\n        float currentGravitation = (i < boxCount - 1) ? gravitation : gravitationDelay;\n        \n        vec3 levitationOffset = 1.5 * currentGravitation * t * vecY(1.);\n        vec3 position = basePosition + vecY(float(i) * levitationHeight) + levitationOffset;\n        float angleOffset = float(i) * offsetRotation + dayRotation;\n        float turnSection = floor(angleOffset / quaterTurn);\n        \n        //Rotation animation offset\n        float animAngle = mod(angleOffset, quaterTurn) / quaterTurn;         \n        animAngle = easeInOutCubic(animAngle);\n        animAngle = easeOutBounce(animAngle);\n        animAngle *= quaterTurn;\n               \n        angleOffset = animAngle;\n        \n        //add 45 degree and ajust to the turn section      \n        angleOffset += quaterTurn * 0.5 + turnSection * quaterTurn;\n           \n        vec4 rotation = qAxisAngleRotation(vecY(1.0), angleOffset);\n        float tempDist;\n        vec2 tempUv;\n        vec3 tempNormal;\n        \n        if(i < boxCount - 1)\n        {\n             Box box;\n             box.position = position;\n             box.rotation = qAxisAngleRotation(vecY(1.0), angleOffset);\n             box.scale = boxScale + easeInOutCubic(halfDist) * (vecX(hourglassRatio) + vecZ(hourglassRatio));\n             \n             if(i == 0)//bottom box\n             {\n                 box.rotation =  qAxisAngleRotation(vecY(1.0), 0.5 * 0.785398);\n                 box.scale.y += 0.5;\n                 box.position.y -= 0.5;\n             }\n             if(BoxIntersection(ro, rd, box, tempDist) && tempDist < minDist)\n             {\n                minDist = tempDist;\n                bestBox = box;\n                hasHit = true;\n                vec3 hitPos = ro + rd * tempDist;\n                normal = CalculateCubeNormal(bestBox, hitPos);\n                uv = CalculateProjectedUV(bestBox, hitPos, normal);\n             }\n        }        \n        else //top is a pyramid\n        {\n            Pyramid pyramid;\n            vec3 shakeResonance = 0.5 * tremor * cheapNoise(vec3(dayCycle), dayCycle * TAU * 5000.);\n            pyramid.position = position + vecY(0.75) + shakeResonance;\n            pyramid.rotation = qAxisAngleRotation(vecY(1.0), -angleOffset * 2.0 + quaterTurn / 2.0);\n            pyramid.rotation = qmul(pyramid.rotation, qAxisAngleRotation(vecZ(1.0), PI / 2.0));\n            pyramid.scale = vec3(0.5, 0.7, 0.5);\n            \n            if(PyramidIntersection(ro, rd, pyramid, tempDist, tempNormal, tempUv) && tempDist < minDist)\n            {\n                minDist = tempDist;\n                uv = tempUv;\n                normal = tempNormal;\n                hit.material.id = MATERIAL_GEM;\n            }\n                       \n            //pyramid.position = position + vecY(1.25);\n            pyramid.rotation = qAxisAngleRotation(vecY(1.0), -angleOffset * 2.0 + quaterTurn / 2.0);\n            pyramid.scale = vec3(0.5, 1.6, 0.5);\n            if(PyramidIntersection(ro, rd, pyramid, tempDist, tempNormal, tempUv) && tempDist < minDist)\n            {\n                minDist = tempDist;\n                uv = tempUv;\n                normal = tempNormal;\n                hit.material.id = MATERIAL_GEM;\n            }\n            \n            gemPos = pyramid.position;\n        }   \n    }\n\n    hit.dist = minDist; \n    return hit;\n}\n\nfloat LakeDist(vec3 pos, vec3 objectPos)\n{   \n    float rippleFreq = 13.;\n    float rippleSpeed = 252.;\n    float rippleAmp = .002;\n    float rippleFadeDist = 4.;\n    \n    float rippleDist = distance(pos.xz, objectPos.xz);\n    float rippleFade = 1. - saturate(rippleDist / rippleFadeDist);\n\n    float ripple = rippleFade * rippleAmp * sin(rippleDist * rippleFreq - dayCycle * rippleSpeed);\n    \n    float bigRipple = (0.0005 + tremor * 0.04) * sin(rippleDist * 3.0 - dayCycle * 555.0);\n    float height = ripple + bigRipple;\n\n    return sdPlane(pos, vec3(0., 1., 0.), height);\n}\n\nRayPrimHit GetWaterPrimHit(vec3 pos, vec3 objectPos)\n{\n    RayPrimHit hit;  \n    hit.material.id = MATERIAL_WATER;\n    hit.material.reflection = .95;\n    hit.dist = LakeDist(pos, objectPos);\n    return hit;\n}\n\n\nRayPrimHit DistanceFunction(vec3 pos)\n{\n    vec3 obeliskPos = vec3(0.,1., 3.);\n    RayPrimHit lakeHit = GetWaterPrimHit(pos, obeliskPos);\n    return lakeHit;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    const float eps = 0.001;\n    const vec2 h = vec2(eps,0);\n    \n    float distX1 = DistanceFunction(p+h.xyy).dist;\n    float distX2 = DistanceFunction(p-h.xyy).dist;\n    \n    float distY1 = DistanceFunction(p+h.yxy).dist;\n    float distY2 = DistanceFunction(p-h.yxy).dist;\n    \n    float distZ1 = DistanceFunction(p+h.yyx).dist;\n    float distZ2 = DistanceFunction(p-h.yyx).dist;\n\n    return normalize( vec3(distX1 - distX2,\n                           distY1 - distX2,\n                           distZ1 - distZ2));\n}\n\nRayHit SetupRayHit(vec3 ro, vec3 rd, bool hasHit, float dist, vec3 normal, vec2 uv, RayPrimHit primHit)\n{\n    RayHit rayHit;\n    rayHit.hasHit = hasHit;\n    rayHit.hitPos = ro + rd * dist;\n    rayHit.dist = dist;\n    rayHit.normal = normal; \n    rayHit.material = primHit.material;\n    rayHit.reflDir = reflect(rd, rayHit.normal);\n    rayHit.reflPos = rayHit.hitPos + rayHit.reflDir * 0.01;\n    rayHit.uv = uv;\n    return rayHit;\n}\n\nRayHit Raymarch(vec3 ro, vec3 rd)\n{\n    float currentDist = 0.;\n    bool hasHit = false;\n    RayPrimHit primHit;   \n    primHit.dist = 9999.9;\n    \n    vec3 normal;\n    vec2 uv;\n    RayPrimHit obeliskHit = RayCastObelisk(ro, rd, normal, uv);\n    bool hasObelistHit = obeliskHit.dist < 100.0;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        vec3 pos = ro + rd * currentDist;\n        primHit = DistanceFunction(pos);\n        float dist = primHit.dist;\n        currentDist += dist;\n        \n        //Obelist hit first, skip\n        if(hasObelistHit && (currentDist > obeliskHit.dist))\n        {\n            break;\n        }\n        \n        if(dist < 0.01)\n        {    \n            hasHit = true;\n            break;\n        }\n    }\n\n   \n    if(hasObelistHit && obeliskHit.dist < currentDist)\n    {\n        return SetupRayHit(ro, rd, true, obeliskHit.dist, normal, uv, obeliskHit);\n    }\n    else\n    {\n        normal = calcNormal(ro + rd * currentDist);\n        uv = vec2(0.0);\n        return SetupRayHit(ro, rd, hasHit, currentDist, normal, uv, primHit);\n    }   \n}\n\n//Nasty trick to save 2s of compilation, remove Lake from reflection\nRayHit RaymarchReflection(vec3 ro, vec3 rd)\n{\n    vec3 normal;\n    vec2 uv;\n    RayPrimHit obeliskHit = RayCastObelisk(ro, rd, normal, uv);\n    if(obeliskHit.dist < 100.)\n    {\n        return SetupRayHit(ro, rd, true, obeliskHit.dist, normal, uv, obeliskHit);\n    }\n    RayHit rayHit;\n    return rayHit;\n}\n\n\nfloat GetLightIntensity(vec3 pos, vec3 lightPos)\n{\n    vec3 l = normalize(lightPos - pos);\n    vec3 n = calcNormal(pos);\n    return saturate(dot(n, l));\n}\n\nvec4 GetObeliskColor(in RayHit hit, vec3 lightPos, vec3 viewDir)\n{\n    float dark = easeInOutCubic(DASRCurve(dayCycle, 0.4, 0.6, 0.9, 1.0));\n    //dark = Remap(0.0, 1.0, 0.0, 0.75, dark);\n    \n    vec3 fakeDirLight = normalize(vec3(-1.0, 0.5, -1.5)); \n    \n    float light = saturate(dot(hit.normal, lightPos));\n    float fakeLightIntensity = saturate(dot(hit.normal, fakeDirLight));\n    light = fakeLightIntensity;\n    vec2 uv = hit.uv;\n    \n    float gradOffset = 0.0;\n    vec2 gradientUv = vec2(0.0);\n    if(hit.material.id == MATERIAL_GEM)\n    {\n        gradOffset = 0.5;\n    }\n    \n    //Create veritacal gradient\n    gradientUv.x = fbm_4(vec3(viewDir.x, viewDir.y, 0.0) * 2.0);\n    gradientUv.y = Remap(0.0, 2.0, 0.1, 0.0, hit.hitPos.y);    \n    vec4 gradCol = GetGradientColor(gradientUv, gradOffset + dayCycle + fakeLightIntensity * 0.3);\n    \n    const int size = 3;\n    vec4 cols[size] = vec4[size]\n    (\n        GetCol(126, 128, 163),\n        GetCol(167, 161, 187),\n        GetCol(202, 193, 210)      \n    );\n    \n    light *= dark;\n    float sizeT = light * float(size);\n    int id1 = int(sizeT);\n    int id2 = (id1 + 1);\n    \n    float tt = unlerp(sizeT, float(id1), float(id2));\n    tt = easeInOutCubic(tt);\n    vec4 col = mix(cols[id1], cols[id2 % size], tt);  \n    \n    vec4 finalCol = mix(gradCol, col, 0.5);\n    float invDark = (1.0 - dark);\n    if(hit.material.id == MATERIAL_GEM)\n    {\n        vec4 dayCol = GetCol(207, 166, 255);\n        vec4 nightCol = vec4(0.0);\n        vec4 gemCol = mix(dayCol, nightCol, dark);  \n        float t = mix(0.75, 0.0, dark);\n        \n        vec2 noiseUV = vec2(viewDir.x * 0.75, viewDir.y * 0.75);\n        float cloud = cellfbm(noiseUV, 4);\n        \n        float twirl = distance(hit.hitPos, vec3(gemPos)) * 3.0;\n        vec3 localPos = (hit.hitPos - vec3(gemPos)) * 0.55;\n        vec3 rotPos = RotateZ(localPos, dayCycle * TAU * 3.0 + twirl);\n        float cloud2 = saturate(pow(norm(fbm_4r(rotPos)), 1.3));\n        vec4 nebulaCol = GetGradientColor(vec2(cloud, cloud2 * 0.75), dayCycle + 0.25);\n        \n        float edge = distance(vec2(0.5), hit.uv) * 1.0;\n        edge = pow(edge, mix(3.5, 1.5, dark));\n        \n        finalCol = mix(gradCol, gemCol, t);\n        \n        vec4 dayFinalCol = finalCol + vec4(edge * 0.55);\n        vec4 nightFinalCol = finalCol * 0.1 + nebulaCol * cloud2 + vec4(edge);\n        \n        finalCol = mix(dayFinalCol, nightFinalCol, dark);\n\n    }\n    else\n    {\n        //Accentuate viewDir to create a nicer frenel\n        viewDir.x *= 2.5;\n        viewDir = normalize(viewDir);\n        float fresnel = abs(dot(hit.normal, -viewDir));\n        vec4 fresnelCol = vec4(0.0);\n        fresnel = fresnel * 0.75 * invDark;\n        \n        float edge = pow(distance(vec2(0.5), hit.uv) * 1.0, 2.5);\n\n        finalCol = mix(finalCol, fresnelCol, fresnel) + vec4(edge * 0.1);\n    }\n    \n    vec4 skyBoxRefl = texture(iChannel1, hit.normal);       \n    return mix(finalCol, skyBoxRefl, 0.2);    \n}\n\nvec4 GetWaterColor(in RayHit hit, vec3 lightPos, vec3 viewDir)\n{\n    return GetCol(255, 255, 255);\n}\n\n\nvec4 GetMaterialColor(in RayHit hit, vec3 lightPos, vec3 viewDir)\n{\n    switch(hit.material.id)\n    {\n        case MATERIAL_OBELISK :\n        case MATERIAL_GEM :\n            return GetObeliskColor(hit, lightPos, viewDir);\n         \n        case MATERIAL_WATER :\n            return GetWaterColor(hit, lightPos, viewDir);  \n    }\n    return vec4(0.);\n}\n\n\nvec4 GetFinalColor(inout RayHit hit, vec3 lightPos, vec2 uv, vec3 camPos, vec3 viewDir)\n{\n    vec4 col = GetMaterialColor(hit, lightPos, viewDir);\n\n    if(hit.hasHit)\n    {      \n        vec4 skyBox = texture(iChannel1, viewDir);\n        float viewDist = distance(camPos, hit.hitPos);\n        float fadeMinDist = 40.;\n        float fadeMaxDist = 40.;\n        \n        //Distance fade\n        if(viewDist > fadeMinDist)\n        { \n            float t = saturate(unlerp(viewDist, fadeMinDist, fadeMaxDist));\n            \n            hit.material.reflection = mix(hit.material.reflection, 0.0, t);\n            col = mix(col, texture(iChannel1, -viewDir), 0.0);\n\n            return mix(col, skyBox, t);\n        }\n             \n        //indirect lighting, we use the -viewDir because the cube map\n        // will contains the ambiant color in everyface except the background\n        col = mix(col, texture(iChannel1, -viewDir), 0.0);\n        \n        return col;\n    }\n    else\n    {\n        vec4 skyBox = texture(iChannel1, viewDir);\n        return skyBox;\n    }\n}\n\nfloat GetGravitation(float gravitationTime)\n{\n    float gravitation =  gravitationTime < 0.5 ? \n        easeInCirc(DASRCurve(gravitationTime, 0.1, 0.25, 0.5, 0.5)) : //from 0.0s -> 0.5s\n        easeOutCubic(DASRCurve(gravitationTime, 0.0, 0.0, 0.6, 0.73)); //from 0.5s to 1.0s\n        \n    return gravitation;\n}\n\nfloat GetGravitationDelay(float gravitationTime)\n{\n    float gravitation =  gravitationTime < 0.5 ? \n        easeInQuad(DASRCurve(gravitationTime, 0.1, 0.25, 0.5, 0.5)) : //from 0.0s -> 0.5s\n        (easeOutCirc(DASRCurve(gravitationTime, 0.0, 0.0, 0.6, 0.73))); //from 0.5s to 1.0s\n        \n    return gravitation;\n}\n\nvec3 GetViewDir(vec2 uv)\n{\n    return normalize(vec3(uv.x, uv.y - 0.075, 1.0));\n}\n\nvoid PerspectiveCam(vec3 camPos, vec4 camRot, vec2 uv, out vec3 ro, out vec3 rd)\n{\n    vec3 forward = normalize(vec3(uv.x, uv.y, 1.0));\n\n    ro = camPos;\n    rd = qmul(camRot, forward);\n}\n\n\nvoid OrthographicCam(vec3 camPos, vec4 camRot, vec2 uv, out vec3 ro, out vec3 rd)\n{\n    const float zoom = 0.1;\n    \n    vec3 up = qmul(camRot, vecY(1.0));\n    vec3 right = qmul(camRot, vecX(1.0));\n\n    ro = camPos + (up * uv.y + right * uv.x) * (1.0 / zoom);\n    rd = qmul(camRot, vecZ(1.0));\n}\n\nvec4 GetRaycastColor(vec3 camPos, vec4 camRot, vec2 uv)\n{\n    vec3 ro, rd;\n    PerspectiveCam(camPos, camRot, uv, ro, rd);\n    //OrthographicCam(camPos, camRot, uv, ro, rd);\n\n    RayHit hit = Raymarch(ro, rd);    \n    vec4 col1 = GetFinalColor(hit, lightPos, uv, ro, rd);\n    float reflection = hit.material.reflection;\n    if(!hit.hasHit || reflection == 0.)\n    {\n       return col1;\n    }\n    \n    RayHit hit2 = RaymarchReflection(hit.reflPos, hit.reflDir);\n    vec4 col2 = GetFinalColor(hit2, lightPos, uv, ro, hit.reflDir);\n\n    vec4 colBlurSum = col2;\n    \n    int steps = 15;\n    float blurFactor = 0.025;\n    for(int i = 0; i < steps; i++)\n    {\n        vec3 blurDir = normalize(hit.reflDir + blurFactor * cheapNoise(hit.reflPos, float(i) * 123.2));    \n        RayHit hitBlur = RaymarchReflection(hit.reflPos, blurDir);\n        vec4 colBlur = GetFinalColor(hitBlur, lightPos, uv, camPos, blurDir);\n        colBlurSum += colBlur;\n    }\n    vec4 blurCol = colBlurSum / (float(steps + 1));\n\n    vec4 skycolor = texture(iChannel1, hit2.reflDir);\n          \n    if(hit2.hasHit)\n    {\n        return mix(col1, mix(blurCol, skycolor, hit2.material.reflection), reflection);\n    }\n    else\n    {\n        return mix(col1, col2, reflection);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    dayCycle = fract(iTime * 0.05);\n    \n    float gravitationTime = fract(dayCycle * 4.0);\n    gravitation = GetGravitation(gravitationTime);\n    gravitationDelay = GetGravitationDelay(fract(gravitationTime));\n\n    //float heatWave = DASRCurve(dayCycle, 0.2, 0.21, 0.3, 0.31);\n    //if(dayCycle > 0.3 && dayCycle < 0.5)\n    //uv.x += 0.0015 * sin(uv.y * 10.1 + iTime * 5.) * heatWave;\n    \n    float levitateShake = 0.0; //0.01 * DASRCurve(fract(gravitationTime + 0.36), 0.5, 0.55, 0.55, 0.6);\n    float rotationLockShake = 0.04 * DASRCurve(fract(gravitationTime + 0.13), 0.35, 0.41, 0.58, 0.65);\n    float landShake = 0.15 * easeInOutCubic(DASRCurve(fract(gravitationTime + 0.69), 0.4, 0.41, 0.45, 0.75));\n    float shakeIntensity =  levitateShake + rotationLockShake + landShake;\n    tremor = shakeIntensity;\n    \n    vec3 shakeScreen = shakeIntensity * cheapNoise(vec2(0.0), dayCycle * 128. * 3.0);\n\n\n    vec3 lightPosStart = vec3(-55. , -25., 25.);\n    vec3 lightAxis = normalize(vec3(-1.0, 1.0, 0.0));\n    \n    lightPos = RotateAroundAxis(lightPosStart, lightAxis, -dayCycle * TAU);\n    \n    vec3 camPos = vec3(0., 2.0, -10.0) + shakeScreen;\n    vec4 camRot = qAxisAngleRotation(vecX(1.0), .02);\n\n    #ifdef ANTIALIASING\n        vec4 colorSum = vec4(0.0);        \n        vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n\n        colorSum += GetRaycastColor(camPos, camRot, uv);\n        colorSum += GetRaycastColor(camPos, camRot, mix(uv, vec2(uv.x, nextUv.y), 0.5));\n        colorSum += GetRaycastColor(camPos, camRot, mix(uv, vec2(nextUv.x, uv.y), 0.5));\n        colorSum += GetRaycastColor(camPos, camRot, mix(uv, nextUv, 0.5));\n        colorSum /= 4.0;\n        \n        fragColor = colorSum;  \n    #else\n        fragColor = GetRaycastColor(camPos, camRot, uv);\n    #endif\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//MATHS\n#define PI 3.1416\n#define TAU 6.2831\n\n\n//[-1, 1] -> [0, 1]\nfloat norm(float x)\n{\n    return x * 0.5 + 0.5;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return vec3(saturate(x.x), saturate(x.y), saturate(x.z));\n}\n\nvec4 saturate(vec4 x)\n{\n    return vec4(saturate(x.x), saturate(x.y), saturate(x.z), saturate(x.w));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat unlerp(float x, float fromMin, float fromMax)\n{\n    return (x - fromMin) / (fromMax - fromMin);\n}\nvec3 unlerp(vec3 x, vec3 fromMin, vec3 fromMax)\n{\n    return vec3(\n        unlerp(x.x, fromMin.x, fromMax.x),\n        unlerp(x.y, fromMin.y, fromMax.y),\n        unlerp(x.z, fromMin.z, fromMax.z));       \n}\n\n\nfloat Remap(float fromMin, float fromMax, float toMin, float toMax, float x)\n{\n    float t = saturate(unlerp(x, fromMin, fromMax));\n    return mix(toMin, toMax, t);\n}\n\nfloat ReduceResolution(float x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\n//Ease, https://easings.net\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\nfloat easeOutBounce(float x)\n{\n    const float n1 = 7.5625;\n    const float d1 = 2.75;\n\n    if (x < 1.0 / d1) {\n        return n1 * x * x;\n    } else if (x < 2.0 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\nfloat easeOutElastic(float x)\n{\n    const float c4 = (2.0 * PI) / 5.0;\n\n    return x == 0.0\n      ? 0.0\n      : x == 1.0\n      ? 1.0\n      : pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\nfloat easeInOutBack(float x) \n{\n    const float c1 = 1.70158;\n    const float c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2.0 * x, 2.0) * ((c2 + 1.0) * 2.0 * x - c2)) / 2.0\n      : (pow(2.0 * x - 2.0, 2.0) * ((c2 + 1.0) * (x * 2.0 - 2.0) + c2) + 2.0) / 2.0;\n}\n\nfloat easeInBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat easeOutBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return 1.0 + c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);\n}\n\nfloat easeInCirc(float x)\n{\n    return 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\n\nfloat easeInQuad(float x)\n{\n    return x * x;\n}\n\nfloat easeOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat easeInCubic(float x)\n{\n    return x * x * x;\n}\n\nfloat easeOutCubic(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutCirc(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\n\n//Angles\n\n\nfloat SignedAngle(vec3 a, vec3 b, vec3 axis)\n{\n    float angle = acos(dot(a, b));\n    vec3 crossab = cross(a, b);\n    angle *= sign(dot(axis, crossab));\n    return angle;\n}\n\nfloat SignedAngle(vec2 a, vec2 b)\n{\n    return SignedAngle(vec3(a, 0.), vec3(b, 0.), vec3(0., 0., 1.));\n}\n\nfloat Angle(vec2 a, vec2 b)\n{\n    return acos(dot(a, b));\n}\n\n//Stuff\n\nfloat Luminance(vec3 col)\n{\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722; \n}\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\n\n//positive sign, no 0\nfloat signP(float x)\n{\n    return x < 0. ? -1. : 1.;\n}\n\n//delay attack sustain release\nfloat DASRCurve(float t, float delay, float attack, float sustain, float release)\n{\n    if(t < delay)\n        return 0.0;\n    if(t < attack)\n        return Remap(delay, attack, 0.0, 1.0, t);\n    if(t < sustain)\n        return 1.0;\n    else if(t < release)\n        return Remap(sustain, release, 1.0, 0.0, t);\n    else\n        return 0.0;\n        \n}\n\nvec3 CubicBezier(vec3 a, vec3 b, vec3 c, float t)\n{\n    return mix(mix(a,b,t), mix(b,c,t), t);\n}\n\nfloat cheapNoise(vec2 v)\n{\n    return \n        0.333 * sin(v.x * 3.151) +\n        0.333 * sin(v.y * 8.357) + \n        0.333 * cos((v.x + v.y) * 3.723);\n\n}\nvec3 cheapNoise(vec2 v, float t)\n{\n    return vec3(\n        cheapNoise(vec2(v.x, v.y + t + 126.)),\n        cheapNoise(vec2(v.x, v.y + t + 252.)),\n        cheapNoise(vec2(v.x, v.y + t + 623.))\n        );\n}\n\nvec3 cheapNoise(vec3 v, float t)\n{\n    return vec3(\n        cheapNoise(vec2(v.x, v.y + t + 126.)),\n        cheapNoise(vec2(v.y, v.z + t + 252.)),\n        cheapNoise(vec2(v.z, v.x + t + 623.))\n        );\n}\n\nvec3 project(vec3 a, vec3 b)\n{\n    return (dot(a, b)/dot(b,b))*b;\n}\n\nvec3 reject(vec3 a, vec3 b)\n{\n    return a - project(a, b);\n}\n\nvec3 Quantize(vec3 v, vec3 cellSize)\n{\n    return vec3(floor(v / cellSize));\n}\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat snoise(vec2 v)\n{\n    vec4 C = vec4(0.211324865405187,  // (3.0-math.sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(math.sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = math.step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0f, 1.0f);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    float  gx = a0.x * x0.x + h.x * x0.y;\n    vec2 gyz = a0.yz * x12.xz + h.yz * x12.yw;\n    vec3 g = vec3(gx,gyz);\n\n    return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v)\n{\n    vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy; \n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                                 i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n    }\n\n\nvec2 cellular(vec2 P)\n{\n    const float K = 0.142857142857f; // 1/7\n    const float Ko = 0.428571428571f; // 3/7\n    const float jitter = 1.0f; // Less gives more regular pattern\n\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p * K) - Ko;\n    vec3 oy = mod7(floor(p * K)) * K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter * ox;\n    vec3 dy = Pf.y - of + jitter * oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 0.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 1.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(float xmin, float xmax, inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return mix(xmin, xmax, t);\n}\n\nvec3 NextVec3(vec3 rmin, vec3 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    float z = NextFloat(rmin.z, rmax.z, state);\n    return vec3(x, y, z);\n}\n\n//ROTATION\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n     \n\nvec3 RotateX(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x,\n        p.y * c - p.z * s,\n        p.y * s + p.z * c);\n}\n\nvec3 RotateY(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.z * s,\n        p.y,\n        p.x * s + p.z * c);\n}\n\nvec2 RotateY(vec2 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec2(\n        p.x * c - p.y * s,\n        p.x * s + p.y * c);\n}\n\n\n//Bend pos is either p.x, or p.y\nvec3 BendZ(vec3 p, float a, float bendPos)\n{\n    float c = cos(-a * bendPos);\n    float s = sin(-a * bendPos);\n    return vec3(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c,\n        p.z);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c,\n        p.z);\n}\n\nvec3 RotateYQuater(vec3 p)\n{\n    const float a = 0.707; \n    return vec3(\n        p.x * a - p.z * a,\n        p.y,\n        p.x * a + p.z * a);\n}\n\nvec3 RotateAroundAxis(vec3 p, vec3 axis, float a)\n{\n    vec3 parallel = project(p, axis);\n    vec3 orthogonal = reject(p, axis);\n    vec3 vcross = cross(p, axis);\n    return parallel + orthogonal * cos(a) + vcross * sin(a);\n}\n\n\n// FBMS\n\n     \nfloat fbm_4r( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n    }\n\treturn a;\n}\n\nfloat fbm_4r( in vec3 x, mat3 rot)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\nfloat fmb4_3x( in vec3 x)\n{\n    return fbm_4(x + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\nfloat fmb4r_3x( in vec3 x, mat3 rot)\n{\n    return fbm_4r(x + vec3(fbm_4r(x + vec3(fbm_4r(x, rot), rot), rot)));\n}\n\nfloat fmb4_3x( in vec3 x, vec3 offset)\n{\n    return fbm_4(x + offset + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\nfloat cellfbm( in vec2 x, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*x;\n    }\n\treturn a;\n}\n\nfloat cellfbmr( in vec2 x, mat2 rot, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\n//SHAPES see https://iquilezles.org/articles/distfunctions\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//MODIFIER\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n\nvec3 opTwist(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\nvec3 opRepLim( in vec3 p, in vec3 c,  in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n//COLORS\n\nvec4 GetCol(int r, int g, int b)\n{\n    return vec4(r, g, b, 1.) / 255.;\n}\n\n//Quaternions\n\n// Quaternion multiplication.\n// http://mathworld.wolfram.com/Quaternion.html\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n// Rotate a vector with a rotation quaternion.\n// http://mathworld.wolfram.com/Quaternion.html\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x*s,axis.y*s,axis.z*s,c);\n}\n\nvec4 qInverse(vec4 q)\n{\n    vec4 x = q;\n    return vec4(1.0/(dot(x, x)) * x * vec4(-1.0, -1.0, -1.0, 1.0));\n}\n\n\n\n/// Project specific\n\n\nvec4 GetGradientColor(vec2 uv, float dayCycle)\n{\n    dayCycle += 0.05;\n\n    float x = abs(0.5 - uv.x * 0.5) * 0.1;\n    x = pow(x, 1.2);\n    float y = abs(uv.y) * .7;\n    \n    float noise1 = 0.1 * fbm_4(vec3(uv.x, uv.y, sin(4. * TAU * dayCycle) * 0.1));\n    float noise2 = 0.5 - 0.5 * cellfbm(vec2(uv.x, uv.y +  sin(3. * TAU *dayCycle) * 0.1), 4);\n\n    float t = fract(y + x + noise1 - noise2 + dayCycle);\n    \n    const int size = 8;\n      \n    vec4 cols[size] = vec4[size]\n    (\n        GetCol(86, 167, 204),\n        GetCol(179, 225, 232),\n        GetCol(66, 214, 255),\n        GetCol(235, 214, 163),\n        GetCol(255, 163, 163),\n        GetCol(95, 237, 194), //GetCol(211, 67, 240),    \n        GetCol(29, 26, 176),\n        GetCol(96, 63, 204)\n    );\n    \n    float sizeT = t * float(size);\n    int id1 = int(sizeT);\n    int id2 = (id1 + 1);\n    \n    float tt = unlerp(sizeT, float(id1), float(id2));\n    return mix(cols[id1], cols[id2 % size], tt);    \n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define PI 3.1416\n#define TAU 6.2831\n\n//from https://www.shadertoy.com/view/tdXfDM\n#define FACE_X_POS (0)\n#define FACE_X_NEG (1)\n#define FACE_Y_POS (2)\n#define FACE_Y_NEG (3)\n#define FACE_Z_POS (4)\n#define FACE_Z_NEG (5)\nint dir2face(in vec3 dir)\n{\n    vec3 d = abs(dir);\n    if (d.z >= d.x && d.z >= d.y) return dir.z < 0.0 ? FACE_Z_NEG : FACE_Z_POS;\n    if (d.y >= d.x              ) return dir.y < 0.0 ? FACE_Y_NEG : FACE_Y_POS;\n    \t\t\t\t\t\t\t  return dir.x < 0.0 ? FACE_X_NEG : FACE_X_POS;  \n}\n\n//DAY\n\nvec2 GetSunPos(vec2 uv, float dayCycle)\n{\n    float t = saturate(dayCycle * 1.5);\n    vec2 dawnPos = vec2(-0.3, -0.3);\n    vec2 highNoonPos = vec2(-0.3, 0.5);\n    vec2 nightPos = vec2(1.5, 0.8);\n  \n    vec2 sunPos = mix(\n        mix(dawnPos, highNoonPos, t),\n        mix(highNoonPos, nightPos, t),\n        t);\n    return sunPos;\n}\n\nvec4 Sun(vec2 uv, vec2 sunPos)\n{\n    float sunDist = distance(uv, sunPos);\n    float sunSize = 0.02;\n    float fadeDist = sunSize * 3.;\n \n    if(sunDist < sunSize)\n    {\n        return vec4(1.);\n    }\n    else if(sunDist < fadeDist)\n    {\n        float intensity = 1. - unlerp(sunDist, sunSize, fadeDist);\n        intensity = pow(intensity, 1.9);\n        return vec4(intensity);\n    }\n    else\n    {\n        return vec4(0);\n    }\n}\n\nvec4 SunShaft(vec2 uv, vec2 sunPos, float angleRange, float baseAngle, float dayCycle)\n{\n    float sunShaftDist = 0.7;\n    float dist = distance(uv, sunPos);\n    \n    if(dist < sunShaftDist)\n    {\n        vec2 up = RotateZ(vec3(0.0, 1.0, 0.0), radians(baseAngle)).xy;\n        vec2 toSun = normalize(sunPos - uv);\n        \n        float angle = degrees(SignedAngle(up, toSun));\n        \n        float angleHalfRange = angleRange * 0.5;\n        \n        float angleMod = mod(angle, angleRange);\n        bool inAngle = angleMod < angleHalfRange;\n                \n        if(!inAngle)\n            return vec4(0);\n            \n        float angleID = floor(angle / angleRange);\n        float sinIntensity = norm(sin(angleID * 2.15 + dayCycle * 11.15));\n\n            \n        float angleFade = saturate(unlerp(angleMod, 0., angleHalfRange));\n        angleFade = 2. * angleFade;\n        if(angleFade > 1.)\n            angleFade = 1. - (angleFade - 1.);\n            \n        float intensity = 1. - unlerp(dist, 0., sunShaftDist);\n        intensity = pow(intensity, 5.);\n        return vec4(intensity) * angleFade * sinIntensity;\n    }\n    return vec4(0.);\n}\n\nfloat GenerateClouds(vec2 uv, float dayCycle)\n{\n    vec3 noisePos = \n        vec3(uv * 23.1, 0.0) +\n        vec3(6.5, 7.5, dayCycle * 1.52) + \n        vec3(3.32 * dayCycle, 0.0, 0.0);\n    \n    vec3 cellPos = \n        vec3(uv * 23.1, 0.0) +\n        vec3(6.5, 7.5, dayCycle * 25.52) + \n        vec3(3.32 * dayCycle, 0.0, 0.0);\n    \n    float noiseValue1 = norm(snoise(vec3(7.31) + noisePos * 0.05)); \n    noiseValue1 = saturate(pow(noiseValue1, 3.));\n\n    float cellScale = 0.3;\n    float cellFBM = 1.7 - cellfbm(noisePos.xy * cellScale, 4);\n    float cellOffset = 0.2 * fbm_4(cellPos);\n    \n    cellFBM = pow(cellFBM, 3.3);\n    cellFBM += cellOffset;\n    return saturate(noiseValue1 * cellFBM);\n}\n\nvec4 GetDayColor(vec2 uv, vec4 backgroundColor, float dayCycle)\n{\n    float dayIntensity = DASRCurve(dayCycle, 0.1, 0.2, 0.45, 0.60);\n    if(dayIntensity <= 0.0)\n        return vec4(0.0);\n\n\n    vec4 skyColor = backgroundColor; \n    vec2 sunPos = GetSunPos(uv, dayCycle);\n          \n    float cloudTime = DASRCurve(dayCycle, 0., 0., 0.3, 0.5);\n    float cloud = GenerateClouds(uv, dayCycle) * cloudTime;\n    float sunDist = distance(sunPos, uv);\n    float cloudLight = cloud + 0.1 * saturate(1. - sunDist/0.5); \n    vec4 cloudCol = GetCol(242, 248, 255);\n   \n    cloudCol.a = cloud;\n    \n    float cloudCoverage = saturate(1. - cloud);\n\n    vec4 sunShafts =\n        0.8 * SunShaft(uv, sunPos, 45.0, 034. + dayCycle * 353.3, dayCycle) +\n        0.5 * SunShaft(uv, sunPos, 22.5, 073. + dayCycle * 525.2, dayCycle) +\n        0.5 * SunShaft(uv, sunPos, 45.0, 141. + dayCycle * 131.1, dayCycle) +\n        1.3 * SunShaft(uv, sunPos, 90.0, 117. + dayCycle * 312.1, dayCycle);\n    sunShafts = saturate(sunShafts);\n    \n    sunShafts = cloudCoverage * sunShafts * 0.1;\n    vec4 sunColor = pow(cloudCoverage, 1.) * Sun(uv, sunPos);\n    \n    vec4 sky = mix(skyColor, cloudCol, cloudCol.a);\n    vec4 dayColor = sunColor + sunShafts + sky;\n\n\n    return saturate(dayColor) * dayIntensity;\n}\n\n//NIGHT\n\nvec4 Stars(vec2 uv, float size, float angle, float dayCycle)\n{\n    //float shine = Remap(sin(uv.x * 15.+ uv.y * 15. + dayCycle * 25.5), -0.1, 1.0, 0.5, 1.0);\n    //vec2 uvGroup = floor(uv/0.2);\n    \n    float shineSin = sin((uv.x + uv.y) * 55.1 + dayCycle * 25.5);\n    float shine = 1.0; Remap(shineSin, -0.1, 1.0, 0.5, 1.0);\n    uv = RotateZ(vec3(uv, 0), -angle).xy;\n    \n    float cell = cellular(uv * 25.).x;\n    float starSize = size;\n    float fadeDist = size * 25.;\n\n    if(cell < starSize)\n    {\n        return vec4(1.) * shine;\n    }\n    else if(cell < fadeDist)\n    {\n        float intensity = 1. - unlerp(cell, starSize, fadeDist);\n        intensity = pow(intensity, 5.);\n        return vec4(intensity) * shine * 0.15;\n    }\n    else\n    {\n        return vec4(0);\n    }\n}\n\nvec4 GetNebulaColor(vec2 uv, float angle, float dayCycle)\n{        \n    uv = RotateZ(vec3(uv, 0.0), -angle).xy;\n    float scaling = 2.7;\n    float timeScaling = 0.28;\n    \n    vec2 newuv = uv + vec2(0.2 * uv.y, 0.2 * sin(uv.x * 5.12));\n    vec3 noisePos1 = vec3(newuv * scaling, dayCycle * timeScaling);\n    vec2 noisePos2 = vec2(uv * scaling * 2.);\n    \n    mat3 rot = mat3(\n        vec3(0.80, 0.60, 0.0),\n        vec3(-0.60, 0.80, 0.0),\n        vec3(0.0, 0.0, 1.0));\n  \n    float noiseValue1 = fmb4r_3x(vec3(uv * 2.2, .2 + 0.05 * dayCycle), rot);\n    float noiseValue2 = norm(cellular(noisePos2).x); \n\n    float noiseMask = pow(norm(fbm_4r(noisePos1 + vec3(2.), rot)), 2.5); \n\n    float offset = dayCycle + 0.1 * noiseValue1 +  0.1 * noiseValue2;\n    vec4 nebulaColor = noiseMask * GetGradientColor(uv, offset);\n    return nebulaColor;\n}\n\n\nvec4 GetNightColor(vec2 uv, vec4 gradientColor, float dayCycle)\n{\n    float angle = dayCycle * .53; \n     \n    float starIntensity = DASRCurve(dayCycle, 0.5, 0.7, 0.85, 1.0);\n    float nightIntensity = DASRCurve(dayCycle, 0.5, 0.7, 0.9, 1.0) * 0.8;\n    \n    vec4 stars = vec4(0.0);\n    vec4 nebulaColor = vec4(0.0);\n    \n    if(nightIntensity > 0.0)\n        nebulaColor = GetNebulaColor(uv, angle, dayCycle);\n    if(starIntensity > 0.0)\n        stars = \n            0.2 * Stars(uv * 0.90, 0.010, 3.541 + dayCycle * 1.01, dayCycle) + \n            0.3 * Stars(uv * 0.60, 0.010, 2.943 + dayCycle * .75, dayCycle) + \n            1.0 * Stars(uv * .30, 0.0075, angle, dayCycle);\n        \n     \n    return nebulaColor * nightIntensity + stars * starIntensity;\n}\n\nvec4 GetBackgroundSky(vec2 uv, float dayCycle, vec4 gradientColor)\n{   \n    vec4 dayColor = GetDayColor(uv, gradientColor, dayCycle);\n    vec4 nightColor = GetNightColor(uv, gradientColor, dayCycle);\n    float backgroundIntensity = DASRCurve(dayCycle, 0.0, 0.0, 0.1, 0.2) + DASRCurve(dayCycle, 0.93, 1.0, 1.0, 1.0);\n\n    return dayColor + nightColor + gradientColor * backgroundIntensity;\n}\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir)\n{\n    //vec2 uv = (fragCoord / iResolution.xy) * (iResolution.y/iResolution.x);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv.y = -uv.y;\n    \n    int faceId = dir2face(rayDir);\n \n    float dayCycle = fract(iTime * 0.05);       \n    vec4 gradientColor = GetGradientColor(uv, dayCycle);\n\n    //vec2 uv = fragCoord / iResolution.xy;\n    if(faceId == FACE_Z_POS)\n    {\n        fragColor = GetBackgroundSky(uv, dayCycle, gradientColor);//uv.x = 1.0 - uv.x;\n    }\n    else \n    {\n        fragColor = gradientColor;\n    }\n}","name":"Cube A","description":"","type":"cubemap"}]}