{"ver":"0.1","info":{"id":"fsVGDR","date":"1631350669","viewed":89,"name":"weird little circle","username":"HaleyHalcyon","description":"a","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\n// Reverse lerp and keeps the value between 0. and 1.\nfloat map(float vmin, float vmax, float v) {\n    return clamp(\n        (v-vmin)/(vmax-vmin), // reverse lerp\n        0., 1. // clamp\n    );\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x &= 65535u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x & 65535u;\n}\n// Fade function defined by Ken Perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// Corner vector for Perlin noise\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, 256.));\n  float n = (float(hash(x + hash(y))) / 65535. + time) * TAU;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// Perlin generator.\n// Coordinates can loop an integer number of cells,\n// including in only 1 coordinate\n// * uv: coordinates\n// * offset: time from 0 to 1 (will loop around)\n// * loop: number of cells to loop around\nfloat perlin(vec2 uv, float offset, vec2 loop) {\n  // loop coordinates\n  if (loop.x > 0.) {uv.x = mod(uv.x, loop.x);}\n  if (loop.y > 0.) {uv.y = mod(uv.y, loop.y);}\n  vec2 i = floor(uv); // floored coordinates\n  vec2 n = floor(uv + 1.); // next coordinates\n  // loop next coordinates for wrap-around\n  if (loop.x > 0.) {n.x = mod(uv.x + 1., loop.x);}\n  if (loop.y > 0.) {n.y = mod(uv.y + 1., loop.y);}\n  // blending ratio\n  vec2 f = fract(uv);\n  vec2 u = fade(f);\n  offset = fract(offset);\n  // monstrous meta-mix expression\n  return\n  mix( // mix vertically\n    mix( // mix top horizontally\n      dot(cvec(i,              offset), f - vec2(0.0,0.0)),\n      dot(cvec(vec2(n.x, i.y), offset), f - vec2(1.0,0.0)),\n    u.x),\n    mix( // mix bottom horizontally\n      dot(cvec(vec2(i.x, n.y), offset), f - vec2(0.0,1.0)),\n      dot(cvec(n,              offset), f - vec2(1.0,1.0)),\n    u.x),\n  u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime / 6.0);\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    // use log distance for perspective/tunnel effect\n    float dist = log(uv.x * uv.x + uv.y * uv.y);\n    float angle = atan(uv.y, uv.x) / TAU;\n    vec2 rt = vec2(0.5 + dist * 2., angle * 24. + dist * 0.2);\n    // generate noise\n    float noise = 1.0 * perlin(\n        rt * 1. + vec2(-10., 16.) * time,\n        time,\n        vec2(10., 24.)\n    );\n    noise += 0.3 * perlin(\n        rt * 3. + vec2(-20., 16.) * time,\n        -2. * time,\n        vec2(20., 24.)\n    );\n    //noise *= max(0.0, dist * 0.2 + 2.);\n    // calculate the total \"brightness\" of the image\n    float bright = noise + rt.x * 0.4;\n    \n    // add some smoldering from the perimeter\n    float smolder = \n        sin(dist + (3. * time * TAU)) * 0.8\n        + sin(dist + (3. * (time - 0.2) * TAU)) * 0.4;\n    bright += smolder;\n    \n    bright = max(-2., bright);\n    \n    // separately, add little stars\n    float stars = perlin(\n        uv * 16. + vec2(0., -7.) * time,\n        time,\n        vec2(0., 7.)\n    );\n    stars += perlin(\n        uv * 37. + vec2(0., -7.) * time,\n        time,\n        vec2(0., 7.)\n    );\n    \n    // add symbol in the center\n    float letterSize = 0.185 + (0.025 * sin(8. * time * TAU));\n    // check if the region is within the square region around the center\n    if (abs(uv.x) < letterSize * 0.9 && abs(uv.y) < letterSize * 0.9) {\n        bright += 1. * texture(\n            iChannel0, // the letter texture thing\n            (uv / 2. // zoom out for +-2 unit side length\n            / letterSize // zoom in to fit our cut-out region\n            + \n                vec2(floor(time * 16.), floor(fract(time * 16.) * 16.)) // character offset\n                             // take the ascii code in hex, y is high nybble, x is low nybble\n                             // e.g. ? is (15, 3) because its ASCII code is 0x3F\n                             // this texture has other symbols in place of control or whitespace characters\n                             // like eighth note in 0x0A\n                + vec2(0.5, -0.5)\n            ) / 16. // zoom in for 16 characters tall and wide texture\n        ).r;\n    }\n    \n    // map the brightness to colors\n    float bright0 = map(\n        -1.5, -1.45, bright\n    );\n    float bright1 = map(\n        -0.5, -0.45, bright\n    );\n    vec3 col = mix(\n        HEX(0xfec157),\n        mix(\n            HEX(0xe5502f),\n            mix(\n                HEX(0x793c37), HEX(0xFFFF9f), step(\n                    0.5, stars\n                )\n            ),\n            bright1\n        ), bright0\n    );\n    \n    // Output to screen\n    fragColor = vec4(\n        col, 1.0\n    );\n}","name":"Image","description":"","type":"image"}]}