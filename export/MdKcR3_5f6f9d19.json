{"ver":"0.1","info":{"id":"MdKcR3","date":"1522946710","viewed":135,"name":"osu!lazer buffered","username":"Sunpy","description":"Buffered version of https://www.shadertoy.com/view/MdVyRK\nI have never used buffers before and I see the usecase of it, however I am not the best to reuse stuff and I might think the wrong way of things.\nThis was however interesting :P","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["buffer","osu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Checkout Common tab\n\nvec3 background(vec2 uv){\n    return mix(\n        mix(\n            vec3(0.51953125, 0.52734375, 0.5859375),\n            vec3(0.21875, 0.2890625, 0.37890625),\n            cos(uv.x * sin(uv.y * 4.0 + iTime) + uv.y * 2.0)\n            ),\n        vec3(0.21, 0.4, 0.5),\n        sin(uv.y * 7.24 + cos(uv.x * uv.y + iTime) * sin(iTime + uv.x * 5.3)) / 2.0 + 1.0\n    );\n}\n\nvec3 background2(vec2 uv){\n\treturn mix(\n        vec3(0.453125, 0.75, 0.828125),\n        vec3(0.59375, 0.81640625, 0.828125),\n        sin(uv.y * 6.0 + cos(uv.x * 3.6))\n    );   \n}\n\nvec3 addTriangleLayer(vec2 uv, vec3 col){\n    float r = iResolution.x / iResolution.y;\n    vec2 uv_r = uv * vec2(r, 1.0);\n    float c = circ(uv_r, vec2(0.5 * r, 0.5), 0.6);\n    \n    col = mix(col, texture(iChannel0, uv).rgb, c);\n    \n    return col;\n}\n\nvec3 addLogo(vec2 uv, vec3 col){\n    // Shadow\n    col -= mix(0.0, 0.4, texture(iChannel2, uv + vec2(0.0, 0.02)).b);\n    \n    // Reset dark values\n    col = r_dark(col);\n    \n    // Add Logo\n    col += smoothstep(0.0, 0.1, texture(iChannel2, uv).b);\n    \n    // Reset light values\n    col = r_light(col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = vec4(background(uv), 1.0);\n    \n    if (!DEBUG){\n        float lines = texture(iChannel1, uv * vec2(1.0 - LINE_SHADOW_DEPTH * 2.0, 1.0) + vec2(LINE_SHADOW_DEPTH, 0.0)).r;\n        float shadow_lines = texture(iChannel1, uv).r;\n\n        col.rgb -= min(1.0, shadow_lines) * LINE_SHADOW_STRENGTH;\n        col.rgb = mix(col.rgb, background2(uv), min(1.0, lines));\n\n        col.rgb = addTriangleLayer(uv, col.rgb);\n        col.rgb = addLogo(uv, col.rgb);\n    }\n    else // Debug\n    {\n        if (!DEBUG_MULTIVIEW)\n    \t\tcol = texture(iChannel0, uv);\n        else\n        {\n            float r = iResolution.x / iResolution.y;\n\n            uv = uv * 2.0;\n            vec2 uv_n = fract(uv);\n\n            vec2 vid = floor(uv);\n            float i = vid.x + vid.y * 2.0;\n\n            if (i == 0.0)\n                col = texture(iChannel0, uv_n);\n            else if (i == 1.0)\n                col = texture(iChannel1, uv_n);\n            else if (i == 2.0)\n                col = texture(iChannel2, uv_n);\n            else\n                col = texture(iChannel3, uv_n * PIXEL.x * MEMORY_STRIP); // Scaled up to show memory strips better\n        }\n    }\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// TRIANGLE RENDERER\n\nfloat tri(vec2 uv, vec2 p, float s){\n    vec2 v = uv;\n    v -= p;\n    v /= max(s, 0.01);\n    \n\tfloat a = atan(v.x, v.y) + PI;\n    float r = TWO_PI / 3.0;\n    \n    float t = cos(floor(0.5 + a / r) * r - a) * length(v);\n    \n    return smoothstep(0.4, 0.41, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float MEMORY_STRIP_END = MEMORY_STRIP * MEMORY_STRIP;\n    \n    vec2 uv = fragCoord/iResolution.yy;\n    vec3 col = TRIANGLE_COLOR;\n    \n    float r = iResolution.x / iResolution.y;\n    \n    float alp = 0.0;\n    for (float i = 0.0; i < TRIANGLES; i++){\n        vec2 pointer = getAddr(/*MEMORY_STRIP_END - i*/ i);\n        vec4 d = texture(iChannel3, pointer * PIXEL + PIXEL * 0.5);\n        \n        float t = mix(0.9, 1.1, d.a);\n        float s = mix(0.04, 0.6, d.b - SCALE_MIN);\n        float y = mix(-s * 0.84, 1.0 + s * 0.4, d.g);\n        float x = d.r * r;\n        vec2 p = vec2(x, y);\n        \n        float a = tri(uv, p, s);\n        col = mix(TRIANGLE_COLOR * t, col, a);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// MULTIPART RENDERER\n\nfloat getLine(vec2 uv, vec2 p, float l, float s){  \n    vec2 c = (uv - p + vec2(0.0, 0.1));\n    c /= vec2(s, s / 2.0);\n    c.x -= l / 2.0;\n    \n    if (c.x < -l)\n        c.x = abs(-l - c.x);\n    \n    return texture(iChannel2, c).r;\n}\n\nfloat getLines(vec2 uv){\n    float r = iResolution.x / iResolution.y;\n    \n    uv *= rot(-PI_D4);\n    \n    float c = 0.0;\n    for (float i = 0.0; i < LINES; i++){\n        vec2 pointer = getAddr(i);\n        vec4 d = texture(iChannel3, pointer * PIXEL + PIXEL * 0.5);\n        \n        float l = mix(1.0, 6.0, d.a);\n        float s = mix(0.025, 0.14, d.b);\n        float y = (-i * r * 2.0) / LINES + 2.0 / r;\n        float x = mix(-d.a * 0.75 - 0.1, 1.6 + d.a, d.g) - y;\n        vec2 p = vec2(x, y);\n        \n        c += getLine(uv, p, l, s);\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    vec3 col = vec3(0.0);\n    \n    col.r += getLines(uv);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// PRE-RENDERED COMMON SHAPES\n\nfloat noise(vec2 uv, vec3 c){\n    c.r = rand(c.b + iTimeDelta + uv.y);//random(uv);\n    c.b = rand(c.r + iTimeDelta + uv.x);\n    return max(MIN_SPEED, c.b);\n}\n\nfloat logo(vec2 uv){\n    float dist = distance(uv, vec2(0.5 * iResolution.x / iResolution.y, 0.5));\n    float l = abs(dist - 0.4);\n    return 1.0 - mix(0.3, 1.0, min(1.0, l * 30.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_s = fragCoord/iResolution.yy;\n    vec4 col = vec4(0.0);\n    vec4 prev_col = texture(iChannel2, uv);\n    \n    col.r = circ(uv_s, vec2(-0.01, 0.5), 0.98); // Not 1.0 diamiter due to edges on top and bottom\n    col.g = noise(uv_s, col.rgb); // Wow, what is this? An actual hardware level random?\n    col.b = logo(uv_s); // Shadow of osu logo (sign to get solid logo)\n    \n    fragColor = col;\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// MEMORY BANK\n\n\n// STORAGE RULE\n// \n// RED:   X axis\n// GREEN: Y axis\n// BLUE:  Scale\n// ALPHA: Length\n\n\n// STORAGE DETAILS\n//\n// Data is stored in MEMORY_STRIP x MEMORY_STRIP~ blocks (256x256 by default)\n\nfloat random(vec2 uv){\n    \n    return texture(iChannel2, uv).g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_s = fragCoord/iResolution.yy;\n    \n    vec4 col = texture(iChannel3, uv);\n    \n    // Object memory addr // Initialize data in pixel\n    if (uv_s.x < PIXEL.x * MEMORY_STRIP && uv_s.y < PIXEL.y * MEMORY_STRIP)\n    {\n        if (col.g > 1.0 || col.g <= 0.0){\n            col.g = 0.001;\n\n            col.r = random(uv_s);\n            col.b = mix(SCALE_MIN, SCALE_MAX, rand(col.r + iTimeDelta + uv_s.x));\n            col.a = mix(LENGTH_MIN, LENGTH_MAX, rand(col.b + iTimeDelta + uv_s.y));\n        }\n        else // Do basic step\n        {\n            col.g += col.b * SPEED_SCALE;\n        }\n    }\n    \n    fragColor = col;\n}","name":"Buf D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DEBUG false\n#define DEBUG_MULTIVIEW true\n\n#define SCALE_MIN 0.2\n#define SCALE_MAX 1.0\n#define LENGTH_MIN 0.2\n#define LENGTH_MAX 1.0\n\n#define LINES 256.0\n#define LINE_SHADOW_DEPTH 0.02\n#define LINE_SHADOW_STRENGTH 0.2\n\n#define TRIANGLES 256.0\n#define TRIANGLE_SPEED 0.02\n#define TRIANGLE_COLOR vec3(0.9411764705882353,0.4274509803921569,0.6549019607843137)\n\n#define MIN_SPEED 0.0001\n#define SPEED_SCALE 0.0008\n\n#define PIXEL (vec2(1.0) / iResolution.xx)\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define PI_D4 0.7853981633974483\n\n#define MEMORY_STRIP 300.0\n\nfloat rand(float n){\n    return max(MIN_SPEED, fract(sin(n) * 43758.5453123));\n}\n\nfloat rand(vec2 n) { \n\treturn max(MIN_SPEED, fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453));\n}\n\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat circ(vec2 uv, vec2 p, float s){\n    vec2 d = uv - p;\n    return 1.-smoothstep(s-(s*0.01),\n                         s+(s*0.01),\n                         dot(d,d)*4.0);\n}\n\nvec3 r_light(vec3 c){\n    return min(vec3(1.0), c);\n}\n\nvec3 r_dark(vec3 c){\n    return max(vec3(0.0), c);\n}\n\nvec2 getAddr(float i){\n    vec2 uv = vec2(0.0);\n    \n    float x = fract(i / MEMORY_STRIP);\n    float y = floor(i / MEMORY_STRIP) / MEMORY_STRIP;\n    \n    uv = vec2(x, y) * MEMORY_STRIP;\n    \n    return uv;\n}\n","name":"Common","description":"","type":"common"}]}