{"ver":"0.1","info":{"id":"flccWs","date":"1660858153","viewed":257,"name":"Simple CSG 2","username":"kastorp","description":"same using pathtracing showcase by Reinder\n","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","csg"],"hasliked":0,"parentid":"Nl3yDN","parentname":"Simple CSG "},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tl23Rm\n//\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n\n\n    vec4 data = texelFetch(iChannel0, ivec2(fc), 0);\n    vec3 col = data.rgb / data.w;\n    \n    // gamma correction\n    col = max( vec3(0), col - 0.004);\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define NOHIT 1e10\n\nstruct its\n{\n\tfloat t;\n\tvec3 n;    //normal \n\t\n};\n\nconst its  NO_its=its(NOHIT,vec3(0));\nstruct span\n{\n\tits n;\n\tits f;\n};\n/*----------------------------------\nREFERENCE TABLE\n(span 1= AB, span 2 = CD)\n\n-------Union---Inter----Sub--\nABCD | AB, CD |  -   | AB\nACBD | AD     | CB   | AC\nACDB | AB     | CD   | AC, DB\nCABD | CD     | AB   | -\nCADB | CB     | AD   | DB\nCDAB | CD, AB | -    | AB\n\nif result is a double span: \nuse first span if in front of the viewer, \notherwise use second span\n------------------------------------*/\n\nspan Inter(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   if(cp.x && cp.z) return span(NO_its,NO_its);\n   else if(cp.x && !cp.z && cp.w)  return span(b.n,a.f);\n   else if(cp.x && !cp.z && !cp.w) return b;\n   else if(!cp.x && cp.y &&  cp.w) return a;\n   else if(!cp.x && cp.y &&  !cp.w) return span(a.n,b.f);\n   else return span(NO_its,NO_its);\n}\n\nspan Sub(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   \n   if     (cp.x && cp.z) return a;\n   else if(cp.x && !cp.z && cp.w)  return span(a.n,b.n);\n   else if(cp.x && !cp.z && !cp.w && b.n.t>0.) return span(a.n,b.n); \n   else if(cp.x && !cp.z && !cp.w && b.n.t<0.) return span(b.f,a.f); //+ secondary span =  span(b.f,a.f)\n   else if(!cp.x && cp.y && cp.w) return span(NO_its,NO_its);\n   else if(!cp.x && cp.y && !cp.w) return span(b.f,a.f);\n   else return a;\n   \n}\n\n// useful if transparent \nspan Union(span a, span b)\n{\n\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   if(b.n.t==NOHIT) return a;\n   else if(a.n.t==NOHIT) return b;    \n   else if     (cp.x  && cp.z  && a.f.t>0.) return a;\n   else if(cp.x  && cp.z  && a.f.t<0.) return b;\n   else if(cp.x  && !cp.z && cp.w) return span(a.n,b.f);\n   else if(cp.x  && !cp.z && !cp.w) return a;\n   else if(!cp.x && cp.y  && cp.w) return b;\n   else if(!cp.x && cp.y  && !cp.w) return span(b.n,a.f);\n   else if(!cp.x && !cp.y  && a.f.t>0.) return b;\n   else /*if(!cp.x && !cp.y  && a.f.t<0.) */ return a;   \n}\n\n\n//-----------Intersection functions--(based on Iq)------------------\nspan iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return span(NO_its,NO_its); // no intersection\n    h = sqrt( h );\n    vec3 oNor =normalize(ro-(b+h)*rd); \n    vec3 fNor= normalize(ro-(b-h)*rd); \n    return span(its(-b-h,oNor) , its(-b+h,-fNor));\n}\n\nspan iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF ) return span(NO_its,NO_its); // no intersection\n    vec3 oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n    vec3  fNor=- sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy); \n    return  span(its(tN,oNor) , its(tF,fNor));\n}\n\nspan iRBox( in vec3 ro, in vec3 rd, vec3 boxSize,mat3 rot  ) {\n\tmat3 txx = inverse( rot );   \n    span s= iBox(txx*ro,txx*rd,boxSize);\n    s.n.n=(rot*s.n.n).xyz;\n    s.f.n=(rot*s.f.n).xyz;    \n    return s;\n}\n\n\n//  plane with thickness h\nspan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d1= -dot(ro,n)/dot(rd,n),   d2= -(dot(ro-h*n,n))/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3 oNor=n;\n    if(d1<d2) return span(its(d1,-oNor),its(d2,oNor));\n    return span(its(d2,oNor),its(d1,-oNor));\n}\n\n\nspan iCylinder( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return span(NO_its,NO_its); //no intersection\n    h = sqrt(h);\n    vec2 t =vec2(-b-h,-b+h)/a;\n    vec2 d= vec2(dot(oc +t.x*rd,ca) ,dot(oc +t.y*rd,ca) );\n    vec3 nN=normalize( oc +t.x*rd -d.x*ca),nF=normalize( oc +t.y*rd -d.y*ca);\n    its iN= its( t.x, nN); //todo uv\n    its iF= its( t.y, nF);\n    return  span(iN , iF );   \n}\n//---------mixed functions--------------------------\n\nstruct Hit{   \n    float d;\n    vec3 n;\n    int id;\n};\n\n\nHit nearestHit( Hit a, Hit b)\n{   \n   if(a.d<b.d) return a;\n   else return b;\n}\n\n\n\n//------------------------------------\nHit getHit(span s, int mat){\n    \n    if(s.f.t < 0.  ) return Hit(NOHIT,vec3(0),0);    \n    its ix = s.n;\n    if(s.n.t<0.) ix=s.f;\n    return Hit( ix.t,ix.n,mat);\n}\n\n// Iq \n\n\nmat3 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat3( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define PATH_LENGTH 10\n#define MAX_DIST 1e10\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray tracer helper functions\n//\n\nfloat FresnelSchlickRoughness( float cosTheta, float F0, float roughness ) {\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\n}\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec3 modifyDirectionWithRoughness( const vec3 normal, const vec3 n, const float roughness, inout float seed ) {\n    vec2 r = hash2(seed);\n    \n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\t\n    float a = roughness*roughness;\n    \n\tfloat rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));\n\tfloat ra = sqrt(abs(1.-rz*rz));\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    \n    vec3 ret = normalize(rr);\n    return dot(ret,normal) > 0. ? ret : n;\n}\n\nvec2 randomInUnitDisk( inout float seed ) {\n    vec2 h = hash2(seed) * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n//\n// Scene description\n//\n\nvec3 rotateY( const in vec3 p, const in float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nvec3 opU( vec3 d, span s, inout vec3 normal, float mat ) {\n    if( s.n.t<d.y && s.n.t>d.x) {\n        normal=s.n.n;\n        d=vec3(d.x, s.n.t, mat);\n    }\n\treturn d;\n}\n        \nvec3 worldhit( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal ) {\n    \n   vec3  d = vec3(dist, 0.);\n \n    span s = iBox(ro-vec3(0.,-.4,0.),rd,vec3(10.,.4,10.));\n        iPlane(ro,rd,-vec3(0,1.,0),1.);           \n    d= opU(  d,  s,  normal, 1. ) ;\n    \n    span s2,s3;\n\n    // DICE= sphere * cube\n    s2= iBox(ro-vec3(0.,.4,0.),rd,vec3(.4));\n    s3= iSphere(ro-vec3(0.,.4,0.),rd,.5);\n    d= opU(  d,  Inter(s2,s3),normal , 7.);   \n         \n    // LAMP= cube -sphere \n    s2= iBox(ro-vec3(1.,.4,0.),rd,vec3(.4));\n    s3= iSphere(ro-vec3(1.,.4,0.),rd,-.5);\n    d= opU(  d,  Sub(s2,s3),normal , 6.);   \n\n   // RAMP= box * plane\n    s2= iBox(ro-vec3(-1.,.4,0.),rd,vec3(.4));\n    s3= iPlane(ro-vec3(-1.,.4,0.),rd,normalize(-vec3(1.,1.,0.)),2.);\n    d= opU(  d,  Inter(s2,s3),normal , 10.);\n    \n\n    // HEMISPHERE = sphere * plane\n    s2= iSphere(ro-vec3(1.,.4,1.),rd,.4);\n    s3= iPlane(ro-vec3(-1.,.4,0.),rd,normalize(vec3(0.,-1.,0.)),.4);    \n     d= opU(  d,  Inter(s2,s3),normal , 10.);\n  \n\n    // SNOWMAN = sphere  + sphere\n    s2= iSphere(ro-vec3(0.,.2,1.),rd,.2);\n    s3= iSphere(ro-vec3(0.,.5,1.),rd,.2);\n     d= opU(  d,  Union(s2,s3),normal , 4.);\n\n    // UFO = sphere * sphere\n    s2= iSphere(ro-vec3(-1.,.4,1.),rd,.4);\n    s3= iSphere(ro-vec3(-1.,0.,1.),rd,.4);\n    d= opU(  d,  Inter(s2,s3),normal , 8.);\n    \n    //POT = box - box\n    s2= iBox(ro-vec3(1.,.4,-1.),rd,vec3(.4));\n    s3= iBox(ro-vec3(1.,.6,-1.),rd,vec3(.3,.4,.3));\n    d= opU(  d,  Sub(s2,s3),normal , 9.);\n    \n    //POT2= box - sphere\n    s2= iBox(ro-vec3(0.,.4,-1.),rd,vec3(.4));\n    s3= iSphere(ro-vec3(0.,.8,-1.),rd,.4);\n   d= opU(  d,  Sub(s2,s3),normal , 11.);\n\n    //MAGNET=box - box\n    s2= iBox(ro-vec3(-1.,.4,-1.),rd,vec3(.4,.4,.2));\n    s3= iBox(ro-vec3(-1.,.6,-1.),rd,vec3(.2,.4,.8));\n    d= opU(  d,  Sub(s2,s3),normal , 5.);\n\n     if(dot(rd,normal)>0.) normal=-normal;\n    return d;\n}\n\n//\n// Palette by Íñigo Quílez: \n// https://www.shadertoy.com/view/ll2GD3\n//\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos(6.28318530718*(c*t+d));\n}\n\nfloat checkerBoard( vec2 p ) {\n   return mod(floor(p.x) + floor(p.y), 2.);\n}\n\nvec3 getSkyColor( vec3 rd ) {\n    vec3 col = mix(vec3(1),vec3(.5,.7,1), .5+.5*rd.y);\n    float sun = clamp(dot(normalize(vec3(-.4,.7,-.6)),rd), 0., 1.);\n    col += vec3(1,.6,.1)*(pow(sun,4.) + 10.*pow(sun,32.));\n    return col;\n}\n\n#define LAMBERTIAN 0.\n#define METAL 1.\n#define DIELECTRIC 2.\n\nfloat gpuIndepentHash(float p) {\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid getMaterialProperties(in vec3 pos, in float mat, \n                           out vec3 albedo, out float type, out float roughness) {\n    albedo = pal(mat*.59996323+.5, vec3(.5),vec3(.5),vec3(1),vec3(0,.1,.2));\n\n    if( mat < 1.5 ) {            \n        albedo = vec3(.25 + .25*checkerBoard(pos.xz * 5.));\n        roughness = .75 * albedo.x - .15;\n        type = METAL;\n    } else {\n        type = floor(gpuIndepentHash(mat+.3) * 3.);\n        roughness = (1.-type*.475) * gpuIndepentHash(mat);\n    }\n}\n\n//\n// Simple ray tracer\n//\n\nfloat schlick(float cosine, float r0) {\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\nvec3 render( in vec3 ro, in vec3 rd, inout float seed ) {\n    vec3 albedo, normal, col = vec3(1.); \n    float roughness, type;\n    \n    for (int i=0; i<PATH_LENGTH; ++i) {    \n    \tvec3 res = worldhit( ro, rd, vec2(.0001, 100), normal );\n\t\tif (res.z > 0.) {\n\t\t\tro += rd * res.y;\n       \t\t\n            getMaterialProperties(ro, res.z, albedo, type, roughness);\n            \n            if (type < LAMBERTIAN+.5) { // Added/hacked a reflection term\n                float F = FresnelSchlickRoughness(max(0.,-dot(normal, rd)), .04, roughness);\n                if (F > hash1(seed)) {\n                    rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);\n                } else {\n                    col *= albedo;\n\t\t\t        rd = cosWeightedRandomHemisphereDirection(normal, seed);\n                }\n            } else if (type < METAL+.5) {\n                col *= albedo;\n                rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);            \n            } else { // DIELECTRIC\n                vec3 normalOut, refracted;\n                float ni_over_nt, cosine, reflectProb = 1.;\n                if (dot(rd, normal) > 0.) {\n                    normalOut = -normal;\n            \t\tni_over_nt = 1.4;\n                    cosine = dot(rd, normal);\n                    cosine = sqrt(1.-(1.4*1.4)-(1.4*1.4)*cosine*cosine);\n                } else {\n                    normalOut = normal;\n                    ni_over_nt = 1./1.4;\n                    cosine = -dot(rd, normal);\n                }\n            \n\t            // Refract the ray.\n\t            refracted = refract(normalize(rd), normalOut, ni_over_nt);\n    \t        \n        \t    // Handle total internal reflection.\n                if(refracted != vec3(0)) {\n                \tfloat r0 = (1.-ni_over_nt)/(1.+ni_over_nt);\n\t        \t\treflectProb = FresnelSchlickRoughness(cosine, r0*r0, roughness);\n                }\n                \n                rd = hash1(seed) <= reflectProb ? reflect(rd,normal) : refracted;\n                rd = modifyDirectionWithRoughness(-normalOut, rd, roughness, seed);            \n            }\n        } else {\n            col *= getSkyColor(rd);\n\t\t\treturn col;\n        }\n    }  \n    return vec3(0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool reset = iFrame == 0;\n            \n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n        \n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n        reset = true;\n    }\n    \n    vec3 ro = vec3(+2.5*cos(1.5+6.*mo.x), 1.+2.*mo.y, +2.5*sin(1.5+6.*mo.x));\n    vec3 ta = vec3(0.,0.,0.);\n    mat3 ca = setCamera(ro, ta, 0.);    \n    vec3 normal;\n    \n    float fpd = data.x;\n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        // Calculate focus plane.\n        float nfpd = worldhit(ro, normalize(vec3(.0,0.4,0)-ro), vec2(0, 100), normal).y;\n\t\tfragColor = vec4(nfpd, mo*iResolution.xy, iResolution.x);\n    } else { \n        vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\n\n        // AA\n        p += 2.*hash2(seed)/iResolution.y;\n        vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \n\n        // DOF\n        vec3 fp = ro + rd * fpd;\n        ro = ro + ca * vec3(randomInUnitDisk(seed), 0.)*.02;\n        rd = normalize(fp - ro);\n\n        vec3 col = render(ro, rd, seed);\n\n        if (reset) {\n           fragColor = vec4(col, 1);\n        } else {\n           fragColor = vec4(col, 1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}