{"ver":"0.1","info":{"id":"slVfWD","date":"1727795267","viewed":50,"name":"Blocks Symmetric 2D","username":"spalmer","description":"working my way up to something bigger with asymmetry, starting smaller\n[url=view/7tVBWw]3D version[/url]","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","pattern","brick","detail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see http://shadertoy.com/view/7ttfWf where much of this framework started out\n// but split off since this doesn't involved any hashes or colorization or much of the complexity\n// went 3d at http://shadertoy.com/view/7tVBWw\n// see also simpler Brickwork 2D http://shadertoy.com/view/WdsfWH\n// which now is on a par with this, even has cell id coloration.  No sdf mouse debug yet.\n\nconst float\n    fillet = .03, // .25; //.375; //.5; //.125; //0.; // (was rnd)\n    mortar = .015, //0.; //.125; // mortar crack width (was gap/mgap)\n    mdepth = .375, // how deep in the cracks the mortar is\n    bwidth = 2., // 1 for square blocks, 2 for rectangular\n    smth = 1e-5; // smoothmin tightness arg\n    \nconst vec2\n    bsize = .5 * vec2(bwidth, 1); // half-size, radial extents of a brick\n       \n\n// e is box half-extent\nfloat dbox(vec2 q, vec2 e)\n{\n    q = abs(q) - e;\n    return min(0., max(q.x, q.y)) + length(max(q, 0.)); // iq way\n}\n\nfloat brick(vec2 q)\n{\n    return dbox(q, bsize - fillet - mortar) - fillet;\n}\n\nbool isodd(float f)\n{\n    return fract(.5 * /*floor*/(f)) >= .5;\n}\n\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = a - b;\n    return .5 * (a + b - sqrt(h * h + k));\n}\n// sqrt version is apparently best\nfloat smax(float a, float b, float k)\n{\n\treturn -smin(-a, -b, k);\n}\n\n\n\nvec2 bid(vec2 p)\n{\n    p.x /= bwidth;\n    vec2 i = vec2(floor(p));\n    i += .5;\n    if (isodd(i.y))\n        i.x += step(.0, p.x - i.x) - .5;\n    i.x *= bwidth;\n    return i;\n}\n// TODO may want to return the two closest neighbor brick locations\n\n\nfloat brickyTestShape(vec2 q)\n{\n    // torus to exclude blocks\n    return .375 //.6 //.275 //.125 //\n        - abs(length(q) - .875);\n}\n\nfloat blockLowDetail(vec2 q);\n\nbool hasBlock(vec2 q);\n\n// version from Brickwork 2D\n// unlike *all* those other implementations,\n// it does *not* scale the bricks an extra factor of 2\n// and fixing it would ruin the elegance, so...\n// officially this is the new *correct* block size\n// and all the other ones are just wrong, half as big as these.\nfloat blocksSparse(vec2 f)\n{\n    float dbound = blockLowDetail(f),\n        dlod = dbound - .994;\n    if (dbound > 3.)\n        return dlod;\n    vec2 c = bid(f),\n        z = .5 * vec2(bwidth, 1);\n    float d = dbound + mdepth;    \n    for (int j = 4; j-- > -2; )\n    for (int i = 3; i-- > -2; )\n    {\n        vec2 t = 2. * vec2(z) * vec2(i,j) + c;\n        bool odd = (j & 1) != 0;\n        if (odd) \n            t.x -= z.x;\n        if (hasBlock(t)) {\n            float r = brick(f - t);\n            if (d > r) d = r;\n        }\n        if (odd) {\n            t.x += 2. * z.x;\n            if (hasBlock(t)) {\n                float r = brick(f - t);\n                if (d > r) d = r;\n            }\n        }\n    }\n    if (d > 2.) d = dlod;  // switch to LOD\n    return d;\n}\n\n// I like it.\nfloat blocksSparse4(vec2 f)\n{\n    float dbound = blockLowDetail(f),\n        dlod = dbound - .975;\n    if (dbound > 3.)\n        return dlod;\n    vec2 c = floor(f / 2.) * 2. + .5, //bid(f),\n        z = .5 * vec2(bwidth, 2);\n    float d = dbound + mdepth;\n    for (int k = 3; (k -= 2) >= -1; ) { // which row\n        c = floor(f / 2.) * 2. + .5\n            + float(k) * vec2(.5,.5) * z;\n        for (int j = 2; j-- > -1; )\n        for (int i = 2; i-- > -1; )\n        {\n            vec2 t = 2. * vec2(z) * vec2(i,j) + c;\n            if (hasBlock(t)) {\n                float r = brick(f - t);\n                if (d > r) d = r;\n            }\n        }\n    }\n    if (d > 2.5) d = dlod;  // switch to LOD\n    return d;\n}\n\n \nfloat grid; // = 24.; //12.; //6.; //3.; //\n\n        \nfloat blockLowDetail(vec2 q)\n{\n    return brickyTestShape(q / grid) * grid;\n}\n\n// is position of center of block inside the shape?\nbool hasBlock(vec2 q)\n{\n    return brickyTestShape(q / grid) <= 0.;\n}\n\n\nfloat blocks(vec2 f)\n{\n    return blocksSparse4 \n        //blocksSparse\n        (f);\n}\n        //blocksSparse3\n        //blocksSparse2\n        //blocksSparseSquare\n\n\nvoid mainImage(out vec4 o, vec2 f)\n{\n    grid = mix(4., 24., .5 * cos(.3 * iTime) + .5);\n    vec2 r = iResolution.xy; \n    float aa = min(r.x, r.y) / grid;\n    f = (f + f - r) / aa;\n    //f.y = 0.; // force to 1d slice (be sure to disable grid)\n    // sdf in v.z, block id in v.w, location in v.xy\n    float d = blocks(f);\n    vec3 c = vec3(.5); // grey background\n    vec2 id = bid(f);\n    if (d <= 0.)  // inside block?\n        c = abs(cos(id.x + 77.*sqrt(1.25)*id.y + vec3(0,2,4))) * .2 + vec3(.6,.5,.2); // colorize\n    c *= .6 - .4 * cos(d * aa * .7); // isolines\n    //c = mix(d <= 0. ? vec3(.5,.5,0) : vec3(0,0,.5), c, exp2(-4. * abs(d))); // alternate colorize + shade by distance\n    if (d > 0.) c *= vec3(.1,.2,1);\n    c *= exp2(-.7 * abs(d)); // shade by distance\n    vec2 l = .5 - abs(fract(f) - .5); // grid cell edges\n    //c = mix(c, vec3(1), clamp(1.-.1 * aa * min(l.x,l.y), 0., 1.)); // grid overlay - seems broken\n    if (iMouse.z > 0.) {\n        vec2 m = (iMouse.xy * 2. - r) / aa;\n        c = mix(c, vec3(d < 0., d > 0., 0), clamp(\n            1. - abs(length(m - f) - abs(blocks(m))) * .5 * aa,\n            0., 1.));\n    }\n    o = vec4(pow(c, vec3(1./2.2)), 1); // OETF\n}\n\n\n/*\n// checkerboard\nbool isodd(vec2 f)\n{\n//    f = floor(f); return (int(f.x+f.y)&1) != 0;\n    return fract(.5*(floor(f.x) + floor(f.y))) >= .5;\n}\n\nfloat cellId(inout vec2 k)\n{\n    k = floor(k);\n    return k.y + 67. * k.x; // 'unique' linear id, runs bottom to top, left to right\n    // resulting id is even if the cell is even, and odd if the cell is odd.. I think!\n}\n*//*\nvoid brickwork(vec2 q, out vec2 bpos, out vec2 bsize)\n{\n    vec2 i = floor(q);\n    bpos = .5 * ((2. * i) + .5);\n    bsize = vec2(.5,.25) - .0;\n}\n        \n        // locate center of cell's block (but at this point still in grid coordinates)\nvec2 brickworkOld(vec2 q)\n{\n    vec2 t = floor(q);\n    if (isodd(t.y))\n        t.x += .5;\n    return t + .5;\n}\nfloat blocksSparseSquare(vec2 f)\n{\n    vec2 k = floor(f);\n    float d = 1.;\n    for (int j = 2; j >= -1; j--)\n    for (int i = 2; i >= -1; i--)\n    {\n        vec2 t = brickworkOld(vec2(i,j));\n        if (!hasBlock(k + t))\n            continue;\n        float r = brick(f - t);\n        if (r < d) { d = r; }\n    }\n    if (d >= 1.)\n        d = max(.4, blockLowDetail(f) - mdepth);\n    return d;\n}\n\nfloat blocksSparse2(vec2 f)\n{\n    float\n        dbound = blockLowDetail(f),\n        dlod = dbound - .46;\n    if (dbound > 1.)\n        return dlod;\n    vec2 c, z;\n    brickwork(f, c, z);\n    float fillet = .03,\n        mortar = .015,\n        depth = .375,\n        smth = 1e-5,\n        d = dbound + depth;\n    for (int j = 3; j-- > -1; )\n    for (int i = 3; i-- > -1; )\n    {\n        vec2 t = 2. * vec2(z) * vec2(i,j) + c;\n        if (!hasBlock(t))\n            continue;\n        bool odd = true && (j & 1) != 0;\n        if (odd) \n            t.x -= z.x;\n        if (hasBlock(t)) {\n            float r = brick(f - t);\n            if (d > r) { d = r; }\n        }\n        if (odd && true) {\n            t.x += 2. * z.x;\n            if (hasBlock(t)) {\n                float r = brick(f - t);\n                if (d > r) { d = r; }\n            }\n        }\n    }\n    if (d > .5) d = dlod;\n    return d;\n}\n\nfloat blocksSparse3(vec2 f)\n{\n    float\n        dbound = blockLowDetail(f),\n        dlod = dbound - .46;\n    if (dbound > 2.)\n        return dlod;\n    //if (dbound > 1.5)\n    //    return dbound - 1.;\n    vec2 c, z;\n    brickwork(f, c, z); //c = floor(f) + .5; z = vec2(.5,.5); //\n    float fillet = .03,\n        mortar = .015,\n        depth = .375,\n        smth = 1e-5,\n        //db0 = dbox(f - c, z - fillet - mortar) - fillet,\n        //clpd = (hasBlock(c) ? db0 : .25 - db0),\n        //lmtd = smin(dbound + depth, db0, smth),\n        d = dbound + depth; //3.; //smax(dbound - .0, lmtd, smth);\n        //d = hasBlock(c) \n        //    ? smax(    db0, dbound, smth) \n        //    : smax(.25-db0, dbound, smth);\n    \n    for (int j = 4; j-- > -2; )\n    for (int i = 3; i-- > -2; )\n    {\n        vec2 t = 2. * vec2(z) * vec2(i,j) + c;\n        bool odd = true && (j & 1) != 0;\n        if (odd) \n            t.x -= z.x;\n        if (hasBlock(t)) {\n            // TODO cornerize?\n            float r = dbox(f - t, z - fillet - mortar) - fillet; //cell(f, t) - .25; //length(f-t) - .5; //cell(f, t);\n            if (d > r) { d = r; }\n        }\n        if (odd && true) {\n            t.x += 2. * z.x;\n            if (hasBlock(t)) {\n                float r = dbox(f - t, z - fillet - mortar) - fillet; //cell(f, t) - .25; //length(f-t) - .5; //cell(f, t);\n                    if (d > r) { d = r; }\n            }\n        }\n    }\n    if (d > 1.) d = dlod; // just switch to the LOD\n    return d;\n}\n*/","name":"Image","description":"","type":"image"}]}