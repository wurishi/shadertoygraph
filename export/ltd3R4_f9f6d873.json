{"ver":"0.1","info":{"id":"ltd3R4","date":"1468323120","viewed":274,"name":"Wooden Sculpture","username":"Nesvi7","description":"I wanted to create a math sculpture inspired by Inigo's sculptures. This is my first published shader in shadertoy and one of my first raymarching shaders, so I will be glad to learn from all your feedback and improvements.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","sculpture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//By Nestor Vina\n//Thanks to Inigo Quilez for his work and articles.\n//Thanks to https://www.shadertoy.com/view/XsB3Rm by gltracy.\n\n// ray marching\nconst int max_iterations = 10000;\nconst float stop_threshold = 0.00001;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat lerp( float a, float b, float t){\n return a+(b-a)*t;   \n}\n\nvec3 opTwist( vec3 p )\n{\n    float c = cos(1.0*p.y);\n    float s = sin(1.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*(p).xz,(p).y);\n    return q;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat coolThing( vec3 pos, float r ) {\n    float lerpValue = (sin(iTime) +1.0)/2.0;\n\tfloat lerpValueSlow = (sin(iTime/10.0) +1.0)/2.0;\n    pos = opTwist(pos);\n    pos += vec3(0,sin(pos.y*10.0*lerpValue),0);\n    float sphere = sdSphere(pos,3.0);\n    float torus = sdTorus(pos, vec2(2.0,1.0));\n    float outputDist = torus + (sphere - torus) * lerpValueSlow ;\n    return outputDist;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n    \n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 map( vec3 pos ) {\n\tfloat s = 2.0;\n\tfloat ct = coolThing( pos/s, 1.7)*s;\n    float peana = sdCappedCylinder(pos+vec3(0.0,8.0,0.0),vec2(10.0,1.0));\n    if( peana > ct)\n        return vec2(ct,0.0);\n    else\n    \treturn vec2(peana,1.0);\n}\n\n// ray marching\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n        dist -= dist*0.95;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\nfloat reflections_ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {        \n\t\tfloat dist = coolThing( ( origin + dir * depth )/2.0, 1.7)*2.0;\n        dist -= dist*0.95;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nvec3 shadingWood( vec3 v, vec3 n, vec3 eye ) {\n    //return vec3(0,0,1.0);\n    vec3 sunDir = normalize(vec3(-1.0,1.0,0));\n    \n    //Texturing \n    vec2 uv = v.xy;\n    vec3 albedo = texture(iChannel0, uv, 1.0).xyz;\t   \n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.7,0.3,0.1) * fresnel(n,viewDir,2.0);    \n    \n    float diffuse = dot(sunDir,n)*0.3;\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    \n    return albedo+diffuse+fresnelColor+ambient;\n}\n\nvec3 shadingMarble( vec3 v, vec3 n, vec3 eye ) {\n    \n    vec3 sunDir = normalize(vec3(-1.0,1.0,0));\n\n    vec3 albedo = vec3(0.5,0.5,0.5);\n\t    \n    vec3 viewDir = normalize(eye-v);\n    \n    vec3 reflectionVector = reflect(n+texture(iChannel1, v.xz).xyz/2.0,viewDir);\n    float reflectionRayDist = reflections_ray_marching( v, reflectionVector, 0.0, clip_far );\n    vec3 reflectionColor = vec3(0.0); \n    \n    if( reflectionRayDist < clip_far )\n    {\n    \tvec3 rpos = v + reflectionVector * reflectionRayDist;\n\t\tvec3 n = normal( rpos );\n    \treflectionColor = shadingWood( rpos, n, v ) * 0.3;\n    }\n    \n    vec3 fresnelColor = vec3(0.7,0.3,0.1) * fresnel(n,viewDir,2.0);\n    \n    float diffuse = dot(sunDir,n)*0.3;\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    \n    return albedo+diffuse+ambient+reflectionColor/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 45.0 + sin(iTime)*5.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2(-0.2, iTime/2.0 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n    vec2 rayResult = ray_marching( eye, dir, 0.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(0.3,0.3,0.3,1.0);//Background color\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n    \n    if( rayResult.y == 0.0 )\n    \tfragColor = vec4(shadingWood( pos, n, eye ), 1);\n    else\n    \tfragColor = vec4(shadingMarble( pos, n, eye ),1.0);\n}","name":"Image","description":"","type":"image"}]}