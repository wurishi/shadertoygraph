{"ver":"0.1","info":{"id":"tttXW8","date":"1581045580","viewed":102,"name":"Pong Test ver.5","username":"abhinavneelam","description":"Pong game. Use mouse to control right paddle. game resets when one player has 9 points","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COLOR_RED vec4(1.0f,0.0f,0.0f,1.0f)\n#define COLOR_GREEN vec4(0.0f,1.0f,0.0f,1.0f)\n#define COLOR_BLUE vec4(0.0f,0.0f,1.0f,1.0f)\n\n#define COLOR_YELLOW vec4(1.0f,1.0f,0.0f,1.0f)\n#define COLOR_LBLUE vec4(0.0f,1.0f,1.0f,1.0f)\n#define COLOR_PINK vec4(1.0f,0.0f,1.0f,1.0f)\n\n#define COLOR_BLACK vec4(0.0f,0.0f,0.0f,1.0f)\n#define COLOR_WHITE vec4(1.0f,1.0f,1.0f,1.0f)\n\n#define WH iResolution.xy\n#define W iResolution.x\n#define H iResolution.y\n\nconst vec4 background = COLOR_BLACK;\n\nvec4 out_color;\nvec2 in_coord;\n\nconst ivec2 buffer_reg = ivec2(0,0);\nconst ivec2 score_reg = ivec2(1,0);\nconst ivec2 ball_reg  = ivec2(2,0);\nconst ivec2 paddle_reg = ivec2(3,0);\n\nconst ivec2 window_width_reg = ivec2(10,0);\nconst ivec2 window_height_reg = ivec2(11,0);\n\nvec4 load(in ivec2 reg)\n{\n \treturn texelFetch(iChannel1, reg, 0);\n}\n\nvoid drawRect(in vec2 pos, in vec4 color, in vec2 size)\n{\n    if(in_coord.x >= pos.x && (in_coord.x) <= pos.x + size.x && in_coord.y >= pos.y && (in_coord.y) < pos.y + size.y)\n        out_color = color;\n}\n\nvoid drawCircle(in vec2 pos, in vec4 color, in float radius)\n{\n \tif(distance(in_coord, pos) < radius)\n        out_color = color;\n}\n\nvoid drawLetter(vec2 fontPos, vec2 fontSize, vec2 renderPos, vec2 renderSize)\n{\n   if(in_coord.x >= renderPos.x && (in_coord.x) <= renderPos.x + renderSize.x && in_coord.y >= renderPos.y && (in_coord.y) < renderPos.y + renderSize.y)\n   {\n      float rx = renderPos.x, ry = renderPos.y;\n      float fx = fontPos.x, fy = fontPos.y;\n      \n      float Rx = (renderPos.x + renderSize.x), Ry = (renderPos.y + renderSize.y);\n      float Fx = (fontPos.x + fontSize.x), Fy = (fontPos.y + fontSize.y);\n      \n      float normdifx = (in_coord.x - rx) / (renderSize.x);\n      float normdify = (in_coord.y - ry) / (renderSize.y);\n      \n      float font_actx = normdifx * fontSize.x + fontPos.x;\n      float font_acty = normdify * fontSize.y + fontPos.y;\n      \n      vec4 temp_color = texture(iChannel0, vec2(font_actx,font_acty) / iResolution.xy).xxxw;\n      \n      if(temp_color.x > 0.5f)\n\t \t out_color = temp_color;\n   }\n}\n\nvoid drawSingleNumber(int num, vec2 renderPos, vec2 renderSize, bool setOriginMiddle)//uses channel 0 as default\n{\n    vec2 pos = vec2(5.0+(W/16.0)*float(num),(H/16.0)*12.0);\n    vec2 size = vec2(H/12.0,W/32.0);//30, 20\n    \n    if(setOriginMiddle)\n      drawLetter(pos,size,renderPos - renderSize/2.0f,renderSize);\n    else\n      drawLetter(pos,size,renderPos,renderSize);\n}\n\nvoid drawInteger(int num, vec2 renderPos, vec2 renderSize)\n{\n \tvec2 pos = vec2(5+40*num, 22.5*float(12));\n    vec2 size = vec2(30,20);\n    \n    int cur_val=num;\n    float counter= 1.0f;\n    \n    int f_num = num;\n    int f_cur_val = cur_val;\n    int f_counter=0;\n    \n    while(f_num != 0)\n    {\n\t\tf_cur_val = f_num%10;\n        f_num /= 10;\n        f_counter++;\n    }\n    \n    renderPos.x += 2.0 * counter * renderSize.x;\n    \n    while(num != 0)\n    {\n        cur_val = num%10;\n\t\tnum /= 10;\n        \n        drawSingleNumber(cur_val, renderPos, renderSize, true);\n        renderPos.x -= counter * renderSize.x/2.0f;\n    }\n}\n\nvoid drawMain()\n{   \n    float score_h = 90.0f;\n    float score_w = 50.0f;\n    float ball_rad = 10.0f;\n    \n    vec2 paddle_size = vec2(18.0f,100.0f);\n    \n    ivec2 score = ivec2(load(score_reg).xy);\n    \n    drawSingleNumber(score.x,vec2(W/2.0f-score_w,H-score_h), vec2(100,100), true);\n    drawSingleNumber(score.y,vec2(W/2.0f+score_w,H-score_h), vec2(100,100), true);\n    \n    float vsize = 10.0f;\n    \n    for(int i=0;i<int(H/vsize/2.0f);i++)\n        drawRect(vec2(W/2.0f,H - (float(i) * 23.0f)), COLOR_WHITE, vec2(3,vsize));\n    \n    vec4 paddle_pos = load(paddle_reg);\n    \n    vec4 buffer = load(buffer_reg);\n    \n    drawRect(paddle_pos.xy, COLOR_WHITE, paddle_size);\n    drawRect(paddle_pos.zw, COLOR_WHITE, paddle_size);\n    \n    vec2 ball_pos = load(ball_reg).xy;\n    drawCircle(ball_pos, COLOR_RED, ball_rad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    in_coord = fragCoord-vec2(0.5);\n    drawMain();\n    fragColor = out_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define WH iResolution.xy\n#define W iResolution.x\n#define H iResolution.y\n\nvec4 out_color;\nvec2 in_coord;\n\n/*\nTODO:\n\t-fullscreen issues with buffers need to be fixed\n\t-left paddle needs to have AI\n*/\n\nconst ivec2 buffer_reg = ivec2(0,0);\nconst ivec2 score_reg = ivec2(1,0);\nconst ivec2 ball_reg  = ivec2(2,0);\nconst ivec2 paddle_reg = ivec2(3,0);\n\nconst ivec2 window_width_reg = ivec2(10,0);\nconst ivec2 window_height_reg = ivec2(11,0);\n\nconst ivec2 window_size = ivec2(12,0);\n\nvoid save(in ivec2 regx, in vec4 newval)\n{\n    if(in_coord == vec2(regx))\n        out_color = newval;\n}\n\nvoid drawMain()\n{   \n    const float paddleWDelta = 20.0f;\n    const vec2 paddle_size = vec2(18.0f,100.0f);\n    //paddle\n    \n    float score_h = 90.0f;\n    float score_w = 50.0f;\n    \n    float ball_rad = 10.0f;\n    float speed = 10.0f;\n    \n    float maxdegfac=45.0f;\n    //ball data\n        \n    //AI Mechanics\n    float aiSpeed = 1.4f;\n    \n    vec4 score_act;\n    vec4 ball_act;\n    vec4 paddle_act;\n    vec4 buffer_act;\n\n    if(iFrame == 0)\n    {\n        buffer_act = vec4(W, H, 0.0f,0.0f);\n     \tscore_act = vec4(0.0f);\n        ball_act = vec4(WH/2.0f,speed,-speed*radians(15.0));\n        paddle_act= vec4(paddleWDelta, H/2.0f, W - paddleWDelta * 2.0,H/2.0f);\n    }\n    else\n    {\n        score_act = texelFetch(iChannel0, score_reg,0);\n   \t\tball_act = texelFetch(iChannel0, ball_reg, 0);\n        paddle_act = texelFetch(iChannel0, paddle_reg, 0);\n        buffer_act = texelFetch(iChannel0, buffer_reg, 0);\n    }\n    \n    //update\n    paddle_act.w = iMouse.y - 50.0f;\n    //paddle_act.y = iMouse.y - 50.0f;\n    \n    vec2 ball_center = ball_act.xy + ball_rad;\n    \n    if(ball_center.x + ball_rad >= paddle_act.x && ball_center.x - ball_rad <= paddle_act.x + paddle_size.x * 2.0f && ball_center.y - ball_rad * 2.0f < paddle_act.y + paddle_size.y && ball_center.y > paddle_act.y)\n    {\n        //ball_act.zw *= -1.0;\n        \n        float diff = ball_center.y - paddle_act.y - paddle_size.y/2.0;\n        \n        float div = diff/paddle_size.y;\n        float deg = maxdegfac * div;\n        \n        float rad = radians(deg);\n        \n   \t\tball_act.w = sin(rad) * speed;\n        ball_act.z = cos(rad) * speed;\n    }//left collision\n    \n    if(ball_center.x - ball_rad <= paddle_act.z + paddle_size.x && ball_center.x >= paddle_act.z && ball_center.y - ball_rad * 2.0f < paddle_act.w + paddle_size.y && ball_center.y > paddle_act.w)\n    {\n        float diff = ball_center.y - paddle_act.w - paddle_size.y/2.0;\n        \n        float div = diff/paddle_size.y;\n        float deg = maxdegfac * div;\n        \n        float rad = radians(deg);\n        \n   \t\tball_act.w = sin(rad) * speed;\n        ball_act.z = cos(rad) * -speed;\n        \n    }//right collision\n    \n    if(ball_center.y >= H || ball_center.y - ball_rad * 2.0f <= 0.0)\n    {\n     \tball_act.w *= -1.0;\n    }//top & bottom\n    \n    if(ball_center.x <= 0.0f - ball_rad * 8.0)\n    {\n        score_act.y++;\n        ball_act = vec4(WH/2.0f,speed,-speed*radians(15.0));\n    }\n    \n    if(ball_center.x + ball_rad >= W + ball_rad * 8.0)\n    {\n    \tscore_act.x++;\n        ball_act = vec4(WH/2.0f,-speed,-speed*radians(15.0));\n    }\n    \n    if(score_act.x==9.0||score_act.y==9.0)\n    {\n     \tscore_act = vec4(0.0f);\n        ball_act = vec4(WH/2.0f,speed,-speed*radians(15.0));\n    }\n    \n    ball_act.xy += ball_act.zw;\n    \n    paddle_act.y += aiSpeed * clamp(ball_center.y - paddle_act.y - paddle_size.y/2.0f, -1.0f, 1.0f);\n    \n    //save\n    save(ball_reg,   ball_act);\n    save(score_reg, score_act);\n    save(paddle_reg, paddle_act);\n    save(buffer_reg, buffer_act);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    in_coord = fragCoord-vec2(0.5);\n    drawMain();\n    fragColor = out_color;\n}","name":"Buffer A","description":"","type":"buffer"}]}