{"ver":"0.1","info":{"id":"MsXBzM","date":"1495281707","viewed":208,"name":"Bluish Noise Histogram","username":"TinyTexel","description":"histogram of non-remapped bluish noise (https://www.shadertoy.com/view/MdffRN)\nred:  distribution after filtering\nblue: remapping s-curve ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bluish Noise Histogram\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nhistogram of non-remapped bluish noise (https://www.shadertoy.com/view/MdffRN)\nred:  distribution after filtering\nblue: remapping s-curve \n*/\n\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nfloat Pow(float b, float e){return exp(log(b)*e);}\n\nfloat Distr0(float y)\n{\n    float y2 = y*y;\n    float y3 = y2 * y;\n    float y4 = y2*y2;\n    \n    if(y <= -2.0) return 0.0;\n    \n    if(y <= -1.0) return 0.25 * (16.0 +16.0*y +24.0*y2 +16.0*y3 +3.0*y4);\n    \n    if(y <= 0.0) return 0.25 * (12.0 - y4);\n    \n    if(y <= 2.0) return 3.0;\n    \n    if(y <= 3.0) return 0.25 * (-68.0 +176.0*y -120.0*y2 +32.0*y3 -3.0*y4);\n    \n    if(y <= 4.0) return 0.25 * Pow4(-4.0 + y);\n    \n    return 0.0;\n}\n\nfloat Distr00(float y) {return Distr0(y) + Distr0(-y);}\n\nfloat Distr(float y) {return Distr00(y * 8.0)/24.0 * 4.0; }\n\n\nfloat SCurveU_Sh(float x)\n{\n    float a, b, c, d, e, f;\n    \n    if(x < 0.25)\n    {\n        a =       0.0; b =      2.0; c =       0.0; d =       0.0; e =       0.0; f =-64.0/15.0;\n    }else\n    if(x < 0.5)\n    {\n        a = -1.0/60.0; b =  7.0/3.0; c = -8.0/3.0 ; d =  32.0/3.0; e = -64.0/3.0; f = 64.0/5.0 ;\n    }else\n    if(x < 0.75)\n    {\n        a = 47.0/60.0; b =-17.0/3.0; c = 88.0/3.0 ; d =-160.0/3.0; e = 128.0/3.0; f =-64.0/5.0 ;\n    }        \n    else\n    {\n        a =-49.0/15.0; b = 64.0/3.0; c =-128.0/3.0; d = 128.0/3.0; e = -64.0/3.0; f = 64.0/15.0;\n    }\n    \n    return a + x*(b + x*(c + x*(d + x*(e + x*f)))); \n}\n\n\nfloat SCurveU(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveU_Sh(abs(x)) * s;\n}\n\nfloat SCurveU01(float x)\n{\n    return SCurveU(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\n\nfloat SCurveU2_Sh(float x)\n{\n    float a, b, c, d, e, f, g, h;\n    \n    if(x < 1.0/6.0)\n    {\n        a = 0.; b = 2.; c = 0.; d = 0.; e = 0.; f = 0.; g = 0.; h =-648.0/35.0;\n    }else\n    if(x < 1.0/3.0)\n    {\n        a =-1.0/2520.0; b =121.0/60.; c =-3./10.; d =3.; e =-18.; f =324./5.; g =-648./5.; h =648./7.; \n    }else\n    if(x < 0.5)\n    {\n        a =319./2520.; b =-13./20.; c =237./10.; d =-117.; e =342.; f =-2916./5.; g =2592./5.; h =-1296./7.; \n    }else        \n    if(x < 2.0/3.0)\n    {\n        a =-6971./2520.; b =797./20.; c =-2193./10.; d =693.; e =-1278.; f =6804./5.; g =-3888./5.; h =1296./7.; \n    }else        \n    if(x < 5.0/6.0)\n    {\n        a =33989./2520.; b =-7849./60.; c =5487./10.; d =-1227.; e =1602.; f =-6156./5.; g =2592./5.; h =-648./7.; \n    }\n    else        \n    {\n        a =-613./35.; b =648./5.; c =-1944./5.; d =648.; e =-648.; f =1944./5.; g =-648./5.; h =648./35.;\n    }\n    \n    return a + x*(b + x*(c + x*(d + x*(e + x*(f + x*(g + x*h)))))); \n}\n\nfloat SCurveU2(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveU2_Sh(abs(x)) * s;\n}\n\nfloat SCurveU201(float x)\n{\n    return SCurveU2(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\n\nfloat SCurveUA1_Sh(float x)\n{\n    float a, b, c, d, e;\n    \n    if(x < 0.5)\n    {\n        a = 0.0;\n        b = 2.0;\n        c = 0.0;\n        d = 4.0/15.0;\n        e =-12.0/5.0;\n    }\n    else\n    {\n        a =-17.0/15.0;\n        b = 44.0/ 5.0;\n        c =-68.0/ 5.0;\n        d = 28.0/ 3.0;\n        e =-12.0/ 5.0;\n    }\n    \n    return a + x*(b + x*(c + x*(d + x*e)));\n}\n\nfloat SCurveUA0_Sh(float x)\n{\n    float a, b, c, d, e;\n    \n    if(x < 0.6)\n    {\n        a = 0.0;\n        b = 2.0;\n        c = 0.0;\n        d =-3344.0/10125.0;\n        e =-10691.0/8100.0;\n    }\n    else\n    {\n        a =-33517.0/24000.0;\n        b = 60479.0/6000.0;\n        c =-63441.0/4000.0;\n        d = 66403.0/6000.0;\n        e =-13873.0/4800.0;\n    }\n    \n    return a + x*(b + x*(c + x*(d + x*e)));\n}\n\n\nfloat SCurveUA0(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveUA0_Sh(abs(x)) * s;\n}\n\nfloat SCurveUA001(float x)\n{\n    return SCurveUA0(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\nfloat NormGrad(float x)\n{\n    return x / length(vec2(dFdx(x), dFdy(x)));\n}\n\nfloat GraphMask(float x)\n{\n    return clamp01(1.0 - Pow2(NormGrad(x)));\n}\n                      \nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    \n    float v = textureLod(iChannel0, vec2(tex.x, 0.0), 0.0).r;\n    vec3 col = vec3(0.0);\n    \n    if(uv.x < 256.0)\n    {      \n        #if 0\n        if(uv.y == 0.0) \n        {\n            if(v > 0.0)\n            col = vec3(1.0, 0.0, 0.0);   \n        }\n        else\n        #endif\n            \n        col = v * 255.0*128.0 < uv.y ? vec3(0.0) : vec3(0.1);\n\n        {\n           float x = uv0.x / 256.0;\n           float y = uv0.y / 256.0;\n\n            col = mix(col, vec3(1.0, 0.0, 0.0), GraphMask(Distr(x - 0.5) - y));// red\n            \n            col = mix(col, vec3(0.0, 0.0, 1.0), GraphMask(SCurveU01(x) - y));// blue\n        }\n    }\n    else\n        col = vec3(0.01);\n    \n    //if(uv.y > 256.0) col *= vec3(0.5);\n\n    //col = vec3(1.0) - col;\n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Bluish Noise Histogram\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nhistogram of non-remapped bluish noise (https://www.shadertoy.com/view/MdffRN)\nred:  distribution after filtering\nblue: remapping s-curve \n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)//TODO: fix nans\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453);\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\nfloat CheapHash(vec3 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898 + v.z * 33.7311);\n}\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//=============================================================================================================================================//\n// \"Hash without Sine\"        | https://www.shadertoy.com/view/4djSRW \n//  Created by David Hoskins  | \n//  used under CC BY-SA 4.0   | https://creativecommons.org/licenses/by-sa/4.0/             \n//  reformatted from original |              \n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash11I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41I(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42I(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43I(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44I(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n \n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash11F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41F(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42F(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43F(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44F(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n\n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//=============================================================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n//#define Hash BJXorShift\n//#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n//uint Hash(uint  v) { return BJXorShift(v); }\nuint Hash(uint  v) { return WangHash(v); }\n//uint Hash(uint  v) { return GMXorShift(v); }\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\n/*\nfloat PowL_Hyp20(float x, float s, float o)\n{\n    return pow(pow(x, o) + pow(s, o), 1.0/o) - s;\n}\n\nfloat PowL_Hyp2(float x, float s, float o)\n{\n    return PowL_Hyp20(x, s, o) / PowL_Hyp20(1.0, s, o);\n}\n\nfloat SCruve_L(float x)\n{\n    x *= 2.0;\n    \n    float xp = x < 1.0 ? x : 2.0 - x;\n    \n    float f = PowL_Hyp2(xp, 0.622, 5.0) * 0.5;\n    \n    return x < 1.0 ? f : 1.0 - f;\n}\n*/\n\nfloat SCurveU_Sh(float x)\n{\n    float a = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 1.0 / 60.0 :\n              x < 0.75 ?  47.0 / 60.0 :\n                         -49.0 / 15.0 ;\n    \n    float b = x < 0.25 ?   2.0        :\n              x < 0.5  ?   7.0 /  3.0 :\n              x < 0.75 ? -17.0 /  3.0 :\n                          64.0 /  3.0 ; \n\n    float c = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 8.0 /  3.0 :\n              x < 0.75 ?  88.0 /  3.0 :\n                         -128.0/  3.0 ; \n\n    float d = x < 0.25 ?   0.0        :\n              x < 0.5  ?  32.0 /  3.0 :\n              x < 0.75 ? -160.0/  3.0 :\n                          128.0/  3.0 ; \n    \n    float e = x < 0.25 ?   0.0        :\n              x < 0.5  ? -64.0 /  3.0 :\n              x < 0.75 ?  128.0/  3.0 :\n                         -64.0 /  3.0 ;    \n    \n    float f = x < 0.25 ? -64.0 / 15.0 :\n              x < 0.5  ?  64.0 /  5.0 :\n              x < 0.75 ? -64.0 /  5.0 :\n                          64.0 / 15.0 ;  \n    \n    float r = a + x*(b + x*(c + x*(d + x*(e + x*f)))); \n    \n    //r = 1.0 - sqrt(1.0 - r);\n    \n    return r;\n}\n\nfloat SCurveU(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveU_Sh(abs(x)) * s;\n}\n\nfloat SCurveU01(float x)\n{\n    return SCurveU(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\nfloat SCurveUA0_Sh(float x)\n{\n    float a, b, c, d, e;\n    \n    if(x < 0.5)\n    {\n        a = 0.0;\n        b = 2.0;\n        c = 0.0;\n        d = 4.0/15.0;\n        e =-12.0/5.0;\n    }\n    else\n    {\n        a =-17.0/15.0;\n        b = 44.0/ 5.0;\n        c =-68.0/ 5.0;\n        d = 28.0/ 3.0;\n        e =-12.0/ 5.0;\n    }\n    \n    return a + x*(b + x*(c + x*(d + x*e)));\n}\n\nfloat SCurveUA1_Sh(float x)\n{\n    float a, b, c, d, e;\n    \n    if(x < 0.6)\n    {\n        a = 0.0;\n        b = 2.0;\n        c = 0.0;\n        d =-3344.0/10125.0;\n        e =-10691.0/8100.0;\n    }\n    else\n    {\n        a =-33517.0/24000.0;\n        b = 60479.0/6000.0;\n        c =-63441.0/4000.0;\n        d = 66403.0/6000.0;\n        e =-13873.0/4800.0;\n    }\n    \n    return a + x*(b + x*(c + x*(d + x*e)));\n}\n\nfloat SCurveUA0(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveUA0_Sh(abs(x)) * s;\n}\n\nfloat SCurveU01A0(float x)\n{\n    return SCurveUA0(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\n/*\nfloat SCurveM01(float x)\n{\n    return x*x*(3.0-2.0*x);\n}\n\nfloat SCurveM01(float x, float m)\n{\n    float c = m * -3.0 + 3.0;\n    float d = m *  2.0 - 2.0;\n    \n    return x*(m + x*(c + d*x));\n}\n\n\nfloat FNoise0(vec2 uv)\n{\n    uvec2 hh = uvec2(0xB8D3E97Cu, 0x951F262Cu);\n\n    float v  = clamp01(Hash(uv, hh) * 0.5 + 0.5);\n    float v0 = clamp01(Hash(uv + vec2(-1.0, 0.0), hh) * 0.5 + 0.5);\n    float v1 = clamp01(Hash(uv + vec2( 1.0, 0.0), hh) * 0.5 + 0.5);\n    float v2 = clamp01(Hash(uv + vec2( 0.0,-1.0), hh) * 0.5 + 0.5);\n    float v3 = clamp01(Hash(uv + vec2( 0.0, 1.0), hh) * 0.5 + 0.5);\n    \n    float vf = (v*4.0 - (v0+v1+v2+v3)) / 8.0 + 0.5;    \n\n    return vf;  \n}\n\nfloat FNoise(vec2 uv)\n{\n    #if 1\n    return SCurveU01(FNoise0(uv));\n    #else\n\treturn SCurveU01A0(FNoise0(uv));   \n    #endif\n}\n\nfloat FNoise2(vec2 uv)\n{\n    float v = FNoise0(uv);\n    \n    float v0 = FNoise0(uv + vec2(-1.0, 0.0));\n    float v1 = FNoise0(uv + vec2( 1.0, 0.0));\n    float v2 = FNoise0(uv + vec2( 0.0,-1.0));\n    float v3 = FNoise0(uv + vec2( 0.0, 1.0));\n    \n    float vf = (v*4.0 - (v0+v1+v2+v3)) / 8.0 + 0.5;    \n\n\n\tvf = SCurveU01A0(vf);     \n    vf = SCurveM01(vf, 0.04);\n    return vf;\n}\n*/\n\nvec2 Ul(float a)\n{\n    return AngToVec(a * Pi * 2.0);\n}\n\nfloat SCruveE02(float x)\n{\n    if(x < 1.0)\n    {\n        x *= x;\n    }\n    else\n    {\n        x = (4.0 - x) * x - 2.0;                \n    }\n\n    x *= 0.5;\n    \n    return x;\n}\n\nfloat SCurveE(float x)\n{\n    if(x < 0.0)\n    {\n        x += 1.0;\n        x *= x;\n        x -= 1.0;\n    }\n    else\n    {\n        x = 1.0 - x;\n        x *= x;\n        x = 1.0 - x;               \n    }\n    \n    return x;\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\nfloat BNoise0(vec2 uv, uvec2 seed)\n{\n    float v  = Hash(uv                  , seed);   \n    float v0 = Hash(uv + vec2(-1.0, 0.0), seed);\n    float v1 = Hash(uv + vec2( 1.0, 0.0), seed);\n    float v2 = Hash(uv + vec2( 0.0,-1.0), seed);\n    float v3 = Hash(uv + vec2( 0.0, 1.0), seed);\n       \n    float vf = (v0+v1+v2+v3) * -0.125 + v * 0.5;    \n\n    return vf * 0.5 + 0.5;\n    return SCurveU(vf) * 0.5 + 0.5;  \n}\n\n// experimental stuff\nfloat SCurveC2(float x) { return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x; }\nvec2 Dir(float x) {return vec2(cos(x * Pi), sin(x * Pi));}\nfloat BNoise1(vec2 uv, uvec2 seed)\n{\n    float v   = Hash(uv, seed);\n    \n    float v0  = Hash(uv + vec2(-1.0, 0.0), seed);\n    float v1  = Hash(uv + vec2( 1.0, 0.0), seed);\n    float v2  = Hash(uv + vec2( 0.0,-1.0), seed);\n    float v3  = Hash(uv + vec2( 0.0, 1.0), seed);\n \n    float v4  = Hash(uv + vec2(-1.0, 1.0), seed);\n    float v5  = Hash(uv + vec2( 1.0, 1.0), seed);\n    float v6  = Hash(uv + vec2(-1.0,-1.0), seed);\n    float v7  = Hash(uv + vec2( 1.0,-1.0), seed);\n\n    float v8  = Hash(uv + vec2(-2.0, 0.0), seed);\n    float v9  = Hash(uv + vec2( 2.0, 0.0), seed);\n    float v10 = Hash(uv + vec2( 0.0,-2.0), seed);\n    float v11 = Hash(uv + vec2( 0.0, 2.0), seed);\n    \n    //float vf = v*0.5 - (v0+v1+v2+v3)*0.125 + 0.5;    \n    float vf = ((v0+v1+v2+v3) * -0.25 + v) * 0.5 + 0.5; \n    \n    vec2 d  = Dir(v);\n    vec2 d0 = Dir(v0);\n\tvec2 d1 = Dir(v1);\n\tvec2 d2 = Dir(v2);\n\tvec2 d3 = Dir(v3);\n    vec2 d4 = Dir(v4);\n\tvec2 d5 = Dir(v5);\n\tvec2 d6 = Dir(v6);\n\tvec2 d7 = Dir(v7);\n\tvec2 d8 = Dir(v8);\n\tvec2 d9 = Dir(v9);\n\tvec2 d10 = Dir(v10);\n\tvec2 d11 = Dir(v11);\n    \n    \n    vec2 o = normalize((d0+d1+d2+d3) - d*4.0);\n         //o = normalize((d4+d5+d6+d7) + (d0+d1+d2+d3) * 2.0 - d*12.0);\n         o = normalize((d8+d9+d10+d11) + (d4+d5+d6+d7)*2.0 - (d0+d1+d2+d3)*8.0 + d*20.0);\n         o = normalize(                  (d4+d5+d6+d7)*2.0 - (d0+d1+d2+d3)*8.0 + d*20.0);        \n\n    float h = ((v8+v9+v10+v11) + (v4+v5+v6+v7)*2.0 - (v0+v1+v2+v3)*8.0 + v*20.0) / (4.0 + 4.0*2.0 + 4.0*8.0 + 20.0);\n    h = h * 0.5 + 0.5;\n    //h = SCurveU01(h);\n    //h = h*h*(3.0-2.0*h);\n    h = h*h*(3.0-2.0*h);\n    //h = h*h*(3.0-2.0*h);\n    h = h < 0.5 ? Pow2(h*2.0)*0.5 : (1.0-Pow2(1.0-(h*2.0-1.0)))*0.5+0.5;\n        h = h < 0.5 ? Pow2(h*2.0)*0.5 : (1.0-Pow2(1.0-(h*2.0-1.0)))*0.5+0.5;\n\n    \n    //h=SCurveC2(h);\n    //h=SCurveC2(h);\n\n    //h = SCurveU01(h); \n    //return h;\n    \n    //return h+0.4 >1.0?1.0:0.0;\n    //return SCurveU01(+0.5);\n    //return acos(normalize(o + vec2(0.0, 1.0)).y)/Pi*2.0;\n    //return o.x*0.5+0.5;\n    return acos(o.x)/Pi;\n    return atan(o.y, o.x) / Pi*0.5 + 0.5;\n}\n\n#define BNoise BNoise0\n\nfloat ErfI(float x)\n{\n    //x = Erf(x);\n\tbool neg = x < 0.0;\n\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(1.0 - x*x);\n    float c = u * 0.5 + b;\n    \n    float y = sqrt(sqrt(c*c - u*a) - c);\n    //float o = rsqrt(c*c - u*a);\n    //float y = rsqrt(o / (1.0 - c*o));\n    \n    return neg ? -y : y;\n}\n\nfloat Erf2(float x)\n{\n    bool neg = x < 0.0;\n    x = abs(x);\n    \n    const float p = 0.3275911;\n    const float a1 = 0.254829592;\n    const float a2 =-0.284496736;\n    const float a3 = 1.421413741;\n    const float a4 =-1.453152027;\n    const float a5 = 1.061405429;\n    \n   // a1 = 0.254829592, a2 = −0.284496736, a3 = 1.421413741, a4 = −1.453152027, a5 = 1.061405429\n    float t = 1.0/(1.0 + p*x);\n    \n    float y = 1.0 - (a1*t + a2*t*t + a3*t*t*t + a4*t*t*t*t + a5*t*t*t*t*t) * exp(-x*x);\n    \n    return neg ? -y : y;\n}\n#define Erf Erf2\n\n//#define Hash22I HashTex2\n\nfloat GHash(vec2 uv, uvec2 seed)\n{\n    //vec2 vv = Hash22I(uv);\n    return ErfI(Hash(uv, seed));\n   // return sqrt(max(0.0, -2.0 * log(max(0.000000000001, vv.x)))) * cos(Pi * 2.0 * vv.y);// * 0.5 + 0.5;\n}\n#define Hash12I GHash\n\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec2 uv = uv0 - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n    vec4 pos        = ReadVar4(4, 0);\n    vec4 state      = ReadVar4(5, 0); \n    \n        float stepNum  = state.x ;\n        float stepSize = state.y ;\n        vec2  stepDir  = state.zw;\n    \n        if(frameAccu == 0.0)\n        {\n            stepSize = 1.0;\n            stepDir = vec2(0.0, 1.0);\n        }\n    \n    \n    vec3 col = vec3(0.0);\n    col = vec3(tex, sin(Time) * 0.5 + 0.5);\n\n    \n    float fv = 0.0;\n    \n    if((uv.x < 256.0 && uv.y == 0.0) || \n      ((uv.x == 4.0 || uv.x == 5.0) && uv.y < 4.0))\n    {\n        const float n = 1024.0;\n        float hv = 0.0;\n        \n        // uses https://www.shadertoy.com/view/Xsffz7\n        for(float i = 0.0; i < n; ++i)\n        {\n            uvec2 hh = uvec2(0xB8D3E97Cu, 0x951F262Cu);\n            \n            #if 1\n            float v = clamp01(Hash(pos.xy, hh) * 0.5 + 0.5);\n            float v0 = clamp01(Hash(pos.xy + vec2(-1.0, 0.0), hh) * 0.5 + 0.5);\n            float v1 = clamp01(Hash(pos.xy + vec2( 1.0, 0.0), hh) * 0.5 + 0.5);\n            float v2 = clamp01(Hash(pos.xy + vec2( 0.0,-1.0), hh) * 0.5 + 0.5);\n            float v3 = clamp01(Hash(pos.xy + vec2( 0.0, 1.0), hh) * 0.5 + 0.5);\n            #else\n            float v = Hash12I(pos.xy, hh);\n            \n            float v0 = Hash12I(pos.xy + vec2(-1.0, 0.0), hh);\n    \t\tfloat v1 = Hash12I(pos.xy + vec2( 1.0, 0.0), hh);\n    \t\tfloat v2 = Hash12I(pos.xy + vec2( 0.0,-1.0), hh);\n    \t\tfloat v3 = Hash12I(pos.xy + vec2( 0.0, 1.0), hh);\n \t\t\n    \t\tfloat v4 = Hash12I(pos.xy + vec2(-1.0, 1.0), hh);\n    \t\tfloat v5 = Hash12I(pos.xy + vec2( 1.0, 1.0), hh);\n    \t\tfloat v6 = Hash12I(pos.xy + vec2( 1.0,-1.0), hh);\n    \t\tfloat v7 = Hash12I(pos.xy + vec2(-1.0,-1.0), hh);\n            #endif\n            \n            #if 0\n            float v4 = clamp01(Hash(pos.xy + vec2(-1.0, 1.0), hh) * 0.5 + 0.5);\n            float v5 = clamp01(Hash(pos.xy + vec2( 1.0, 1.0), hh) * 0.5 + 0.5);\n            float v6 = clamp01(Hash(pos.xy + vec2(-1.0,-1.0), hh) * 0.5 + 0.5);\n            float v7 = clamp01(Hash(pos.xy + vec2( 1.0,-1.0), hh) * 0.5 + 0.5);\n            #endif\n            \n            #if 0\n            // experiment; doesnt result in a triangle distr\n            v  = Sample_Triangle(v*2.-1.)*.5+.5;\n            v0 = Sample_Triangle(v0*2.-1.)*.5+.5;\n            v1 = Sample_Triangle(v1*2.-1.)*.5+.5;\n            v2 = Sample_Triangle(v2*2.-1.)*.5+.5;\n            v3 = Sample_Triangle(v3*2.-1.)*.5+.5;\n            #endif\n            \n            float vf = v - (v0+v1+v2+v3)*0.25;  \n            //vf = mix(vf, - 0.25*(v4+v5+v6+v7)\n            //vf = 3.0 * v - 0.5 * (v0+v1+v2+v3) - 0.25 * (v4+v5+v6+v7);\n            //vf = Erf((vf)*0.5*1.8);\n  \t\t\t//vf = (3.0 * v - 0.5 * (v0+v1+v2+v3) - 0.25 * (v4+v5+v6+v7)) / 6.0;// + 0.5;\n    //return Erf((v + v0)*0.5*1.41421)*0.5 + 0.5;\n    \t\t//vf = Erf(vf*1.875)*0.5 + 0.5; \n            //vf = vf * 0.5 + 0.5;\n//            vf = v * 0.5 + 0.5;\n            //vf = abs(mod(pos.x + mod(pos.y, 2.0), 2.0) - ((v0+v1+v2+v3) * 0.25 + v) * 0.5);\n            \n            #if 0\n            vf = SCurveU01(vf);// apply remapping (the proper one)\n            #endif\n            \n            #if 0\n            v  = v  * 2.0 - 1.0;\n            v0 = v0 * 2.0 - 1.0;\n            v1 = v1 * 2.0 - 1.0;\n            v2 = v2 * 2.0 - 1.0;\n            v3 = v3 * 2.0 - 1.0;\n            \n            //vf = SCruveE02(SCruveE02(v0 + v1) + SCruveE02(v2 + v3));\n            \n            // repreatedly maps triangle back to uniform; doesnt look good\n            vf = SCurveE((SCurveE((v0 + v1)*.5) + SCurveE((v2 + v3)*.5))*.5);\n            vf = SCurveE((v - vf)*.5);\n                \n            vf = vf * 0.5 + 0.5;\n            #endif\n                       \n            //vf = Sample_Triangle(vf*2.-1.)*.5+.5;\n            \n            \n            #if 0\n            // circular average instead of s-curve; doesnt look good\n            v = fract(v + 0.5);\n    \n    \t\tvec2 vec = Ul(v0) + Ul(v1) + Ul(v2) + Ul(v3) + Ul(v);\n    \n    \t\tvf = atan(vec.x, vec.y) / Pi;\n    \t\tvf = vf * 0.5 + 0.5;\n            #endif\n            \n            \n            vf = BNoise(pos.xy, hh);// * 0.5 + 0.5;\n            \n            \n            float h = vf;\n            \n            float h2 = floor(h * 256.0);\n            //if(h2 >= 256.0) h2 = 255.0;\n            float hv0 = h2 == uv.x ? 1.0 : 0.0;\n\n            hv += hv0;\n            \n            \n            pos.xy += stepDir;\n            ++stepNum;\n\n            if(stepNum == stepSize || stepNum == stepSize * 2.0)\n            stepDir = vec2(stepDir.y, -stepDir.x);\n\n            if(stepNum == stepSize * 2.0)\n            {\n                stepNum = 0.0;\n                ++stepSize;\n            }\n            \n        }\n        hv /= n;\n        \n\t  float lv = textureLod(iChannel0, tex, 0.0).r;  \n      fv = mix(lv, hv, 1.0 / (frameAccu + 1.0)); \n    }\n    \n    outCol = vec4(fv, 0.0, 0.0, 0.0);\n    \n  \n\n        \n\n\n        \n        \n        state.x  = stepNum ;\n        state.y  = stepSize;\n        state.zw = stepDir ;\n\n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n        WriteVar4(pos,           4, 0);\n        WriteVar4(state,         5, 0);        \n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}