{"ver":"0.1","info":{"id":"lfjyRV","date":"1722644871","viewed":50,"name":"6-4-3 march","username":"Tivi","description":"Marching a wacky grid made of hexes, rectangles and triangles","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"Mf2cRK","parentname":"Hex traverse test"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Stole from iquilez\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    //#if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    //#else\n    //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    //vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    //#endif\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    int numOctaves=8;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(f*x).x;\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// hex-xy conversion stole from https://www.redblobgames.com/grids/hexagons/#rounding\n\nvec2 cube_to_axial(vec3 cube)\n{\n    float q = cube.x;\n    float r = cube.y;\n    return vec2(q, r);\n}\n\nvec3 axial_to_cube(vec2 hex)\n{\n    float q = hex.x;\n    float r = hex.y;\n    float s = -q-r;\n    return vec3(q, r, s);\n}\n    \nvec3 cube_round(vec3 frac)\n{\n    float q = round(frac.x);\n    float r = round(frac.y);\n    float s = round(frac.z);\n\n    float q_diff = abs(q - frac.x);\n    float r_diff = abs(r - frac.y);\n    float s_diff = abs(s - frac.z);\n\n    if (q_diff > r_diff && q_diff > s_diff)\n        q = -r-s;\n    else if (r_diff > s_diff)\n        r = -q-s;\n    else\n        s = -q-r;\n\n    return vec3(q, r, s);\n}\n\nvec2 axial_round(vec2 hex){\n    return cube_to_axial(cube_round(axial_to_cube(hex)));\n}\n\nvec2 xyToHex(vec2 point)\n{\n    float size = 1.;\n    float q = (sqrt(3.)/3. * point.x  -  1./3. * point.y) / size;\n    float r = (                          2./3. * point.y) / size;\n    return axial_round(vec2(q, r));\n}\n\n\nvec2 xyToHexSmooth(vec2 point)\n{\n    float size = 1.;\n    float q = (sqrt(3.)/3. * point.x  -  1./3. * point.y) / size;\n    float r = (                          2./3. * point.y) / size;\n    return vec2(q, r);\n}\n\nvec2 hexToXy(vec2 hex)\n{\n\n    float size = 1.;\n    float x = size * (sqrt(3.) * hex.x  +  sqrt(3.)/2. * hex.y);\n    float y = size * (                          3. /2. * hex.y);\n    return vec2(x, y);\n}\n\nvec3 xyToCell(vec2 point)\n{\n    vec2 hex = xyToHex(point);\n    vec2 newHex = hex;\n    vec3 local = vec3(xyToHexSmooth(point)-newHex,0.);\n    local.z=-local.x-local.y;\n    float step = 1./3.;\n    float kind = 0.;\n    if (int(hex.y)%2 == 0 && int(hex.x)%2 == 0)\n    {\n        if(local.z > -step && local.z < step) kind=3.;\n        else if(local.z <= -step)\n        {\n            newHex = (newHex*3. + vec2(1.,0.) + vec2(0.,1.)) / 3.; kind=4.;\n        }\n        else\n        {\n            newHex = (newHex*3. + vec2(-1.,0.) + vec2(0.,-1.)) / 3.; kind=5.;\n        }\n    }\n    else if (int(hex.y)%2 == 0)\n    {\n        if (local.x > -step && local.x < step) kind=2.;\n        else if(local.x <= -step)\n        {\n            newHex = (newHex*3. + vec2(-1.,0.) + vec2(-1.,1.)) / 3.; kind=4.;\n        }\n        else\n        {\n            newHex = (newHex*3. + vec2(1.,0.) + vec2(1.,-1.)) / 3.; kind=5.;\n        }\n    }\n    else if (int(hex.x)%2 == 0)\n    {\n        if(local.y > -step && local.y < step) kind=1.;\n        else if(local.y <= -step)\n        {\n            newHex = (newHex*3. + vec2(0.,-1.) + vec2(1.,-1.)) / 3.; kind=4.;\n        }\n        else //if(local.y >= step)\n        {\n            newHex = (newHex*3. + vec2(0.,1.) + vec2(-1.,1.)) / 3.; kind=5.;\n        }\n    }\n    return vec3(newHex, kind);\n}\n\n#define BIGFLOAT (100000.)\n// return normal + t\n\n\nfloat traverse2(vec3 ro, vec3 rd, vec2 targetcell, vec3 target)\n{\n\n    vec3 ro_ = ro;\n    //vec3 cell = floor (ro_);\n    vec3 cell = vec3(xyToHex(ro.xz), floor(ro.y)).xzy;\n    vec3 normal;\n    float t = BIGFLOAT;\n    for (int i=0; i<300; i++)\n    {\n        float size = 1.;\n        float cellx = size * (sqrt(3.) * cell.x  +  sqrt(3.)/2. * cell.z);\n        float cellz = size * (                            3./2. * cell.z);\n        vec3 cellCtr = vec3(cellx, cell.y+0.5, cellz);\n        // Forward march\n        vec3 slabdir_x = vec3(1.,0.,0.);\n        vec3 slabdir_y = vec3(0.,1.,0.);\n        vec3 slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)); \n        vec3 slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.));\n        float cellR = sqrt(3.)/2.;\n        float cellCtr_z = dot(slabdir_z, cellCtr);\n        float cellCtr_w = dot(slabdir_w, cellCtr);\n        \n        vec4 plane;\n        \n        vec4 ro_slab = vec4(ro.x, ro.y, dot(ro,slabdir_z), dot(ro,slabdir_w));\n        vec4 rd_slab = vec4(rd.x, rd.y, dot(rd,slabdir_z), dot(rd,slabdir_w));\n        plane.x = rd.x<0. ? cellCtr.x - cellR : cellCtr.x + cellR;\n        plane.y = rd.y<0. ? cellCtr.y - 0.5: cellCtr.y + 0.5;\n        plane.z = rd_slab.z<0. ? cellCtr_z - cellR : cellCtr_z + cellR;\n        plane.w = rd_slab.w<0. ? cellCtr_w - cellR : cellCtr_w + cellR;\n        vec4 planet = abs((plane-ro_slab)/rd_slab);\n        vec4 step = rd_slab / abs(rd_slab);\n        \n        normal = vec3(0.,0.,1.);\n        float t_ = planet.z;\n        if (planet.x < planet.y && planet.x < planet.z && planet.x < planet.w)\n        {\n            cell.x += step.x;\n            normal = vec3(1.,0.,0.);\n            t_ = planet.x;\n        }\n        else if(planet.y < planet.z && planet.y < planet.w)\n        {\n            cell.y += step.y;\n            normal = vec3(0.,1.,0.);;\n            t_ = planet.y;\n        }\n        else if(planet.z < planet.w)\n        {\n            cell.x -= step.z;\n            cell.z += step.z;\n            t_ = planet.z;\n        }\n        else\n        {\n            cell.z += step.w;\n            t_ = planet.w;\n        }\n        //normal *= -step;\n        \n        //if (cell.y < sin(cell.x*0.5)*1.6f + cos(cell.x*0.2-cell.z*0.4)*0.8f)\n        float h = fbm(cellCtr.xz,0.8)*5. - length(cellCtr.xz)*0.22;\n        if (cell.xz == targetcell)\n        {\n            return 1.*float(i+2);\n        }\n        //if (length(cellCtr-target)<2.) return true;\n        //if (cell.y > 20. && rd.y > 0.) break;\n        \n    }\n    return 0.;\n    //return vec4(normal, t);\n}\n\n\nvec4 traverse(vec3 ro, vec3 rd)\n{\n\n    vec3 ro_ = ro;\n    //vec3 cell = floor (ro_);\n    vec3 cell = vec3(xyToHex(ro.xz), floor(ro.y)).xzy;\n    vec3 normal;\n    float t = BIGFLOAT;\n    for (int i=0; i<300; i++)\n    {\n        float size = 1.;\n        float cellx = size * (sqrt(3.) * cell.x  +  sqrt(.3)/2. * cell.z);\n        float cellz = size * (                            3./2. * cell.z);\n        vec3 cellCtr = vec3(cellx, cell.y+0.5, cellz);\n        // Forward march\n        vec3 slabdir_x = vec3(1.,0.,0.);\n        vec3 slabdir_y = vec3(0.,1.,0.);\n        vec3 slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)); \n        vec3 slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.));\n        float cellR = sqrt(3.)/2.;\n        float cellCtr_z = dot(slabdir_z, cellCtr);\n        float cellCtr_w = dot(slabdir_w, cellCtr);\n        \n        vec4 plane;\n        \n        plane.x = rd.x<0. ? cellCtr.x - cellR : cellCtr.x + cellR;\n        plane.y = rd.y<0. ? cellCtr.y - 0.5: cellCtr.y + 0.5;\n        plane.z = rd.z<0. ? cellCtr_z - cellR : cellCtr_z + cellR;\n        plane.w = rd.z<0. ? cellCtr_w - cellR : cellCtr_w + cellR;\n        vec4 ro_slab = vec4(ro.x, ro.y, dot(ro,slabdir_z), dot(ro,slabdir_w));\n        vec4 rd_slab = vec4(rd.x, rd.y, dot(rd,slabdir_z), dot(rd,slabdir_w));\n        vec4 planet = abs((plane-ro_slab)/rd_slab);\n        vec3 step = rd / abs(rd);\n        \n        normal = vec3(0.,0.,1.);\n        float t_ = planet.z;\n        if (planet.x < planet.y && planet.x < planet.z && planet.x < planet.w)\n        {\n            cell.x += step.x;\n            normal = vec3(1.,0.,0.);\n            t_ = planet.x;\n        }\n        else if(planet.y < planet.z && planet.y < planet.w)\n        {\n            cell.y += step.y;\n            normal = vec3(0.,1.,0.);;\n            t_ = planet.y;\n        }\n        else if(planet.z < planet.w)\n        {\n            cell.x -= step.z;\n            cell.z += step.z;\n            t_ = planet.z;\n        }\n        else\n        {\n            cell.z += step.z;\n            t_ = planet.w;\n        }\n        normal *= -step;\n        \n        //if (cell.y < sin(cell.x*0.5)*1.6f + cos(cell.x*0.2-cell.z*0.4)*0.8f)\n        float h = fbm(cellCtr.xz,0.8)*5. - length(cellCtr.xz)*0.22;\n        if (cell.y < h)\n        {\n            //hit = ro + rd*t;\n            t = t_;\n            break;\n        }\n        if (cell.y > 20. && rd.y > 0.) break;\n        \n        \n    }\n    return vec4(normal, t);\n}\n\n\n\n\nfloat thingy(vec2 cell, float time)\n{\n//return 0.;\n\n    return -3.+sin(cell.x*0.2 + time)*1.2 + 1.4*cos(cell.y*0.3 + time*0.8);\n}\n\nvec4 traverseCells(vec3 ro, vec3 rd, float time)\n{\n    vec3 normal = vec3(100.f);\n    vec3 wipCell = xyToCell(vec2(ro.xz));\n    float y_ = floor(ro.y - thingy(wipCell.xy, time));\n    float t = BIGFLOAT;\n    for(int i=0; i<300; i++)\n    {\n        //wipCell = xyToCell(hexToXy(wipCell.xy));\n        float kind = wipCell.z;\n\n\n        float cellR = sqrt(3.)/2.;\n        vec3 cellCtr = vec3(hexToXy(wipCell.xy),y_+0.5+thingy(wipCell.xy, time)).xzy;\n        vec3 slabdir_x = vec3(1.,0.,0.);\n        vec3 slabdir_y = vec3(0.,1.,0.);\n        vec3 slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)); \n        vec3 slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.));\n        vec2 thres_x = vec2(-cellR,+cellR);\n        vec2 thres_z = vec2(-cellR,+cellR);\n        vec2 thres_w = vec2(-cellR,+cellR);\n\n        if (kind == 1.)\n        {\n            slabdir_w = vec3(0.);\n            slabdir_z = vec3(0.,0.,1.);\n            thres_z = vec2(-.5,.5);\n\n        }\n        else if (kind == 2.)\n        {\n            slabdir_x = vec3(0.);\n            slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n            thres_z = vec2(-.5,.5);\n        }\n        else if (kind == 3.)\n        {\n            slabdir_x = vec3(0.);\n            slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.)).zyx; \n            thres_w = vec2(-.5,.5);\n        }\n        else if (kind == 4.)\n        {\n            slabdir_x = vec3(0.,0.,1.);\n            slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n            slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.)).zyx; \n            thres_x = vec2(-1.,.5);\n            thres_w = vec2(-.5,1.);\n            thres_z = vec2(-1.,.5);\n        }\n        else if (kind == 5.)\n        {\n            slabdir_x = vec3(0.,0.,1.);\n            slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n            slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.)).zyx; \n            thres_x = vec2(-.5,1.);\n            thres_w = vec2(-1.,.5);\n            thres_z = vec2(-.5,1.);\n        }\n        float cellCtr_x = dot(slabdir_x, cellCtr);\n        float cellCtr_y = dot(slabdir_y, cellCtr);\n        float cellCtr_z = dot(slabdir_z, cellCtr);\n        float cellCtr_w = dot(slabdir_w, cellCtr);\n\n        vec4 plane;\n\n        vec4 ro_slab = vec4(dot(ro,slabdir_x), ro.y, dot(ro,slabdir_z), dot(ro,slabdir_w));\n        vec4 rd_slab = vec4(dot(rd,slabdir_x), rd.y, dot(rd,slabdir_z), dot(rd,slabdir_w));\n\n\n\n        plane.x = rd_slab.x<0. ? cellCtr_x + thres_x.x : cellCtr_x + thres_x.y;\n        plane.y = rd_slab.y<0. ? cellCtr_y - 0.5: cellCtr_y + 0.5;\n        plane.z = rd_slab.z<0. ? cellCtr_z + thres_z.x : cellCtr_z + thres_z.y;\n        plane.w = rd_slab.w<0. ? cellCtr_w + thres_w.x : cellCtr_w + thres_w.y;\n        vec4 planet = abs((plane-ro_slab)/rd_slab);\n        vec4 step = rd_slab / abs(rd_slab);\n\n        bool vert= false;\n        float t_ = planet.z;\n        vec3 newCellPos = cellCtr;\n        if (planet.x < planet.y && planet.x < planet.z && planet.x < planet.w)\n        {\n            //cell.x += step.x;\n            //wipCell += xstep*step.x;\n            //newCellPos += step.x * slabdir_x;\n            normal =-step.x*slabdir_x;\n            newCellPos += slabdir_x* (rd_slab.x<0. ? thres_x.x*1.1 : thres_x.y*1.1);\n            t_ = planet.x;\n        }\n        else if(planet.y < planet.z && planet.y < planet.w)\n        {\n            //cell.y += step.y;\n            //wipCell += ystep*step.y;\n            normal = -step.y*slabdir_y;\n            //newCellPos += step.y * slabdir_y;\n            //newCellPos += slabdir_y* (rd_slab.y<0. ? - cellR*1.1 : + cellR*1.1);\n            newCellPos += slabdir_y* (rd_slab.y<0. ? - 0.5*1.1 : + 0.5*1.1);\n            t_ = planet.y;\n            vert=true;\n        }\n        else if(planet.z < planet.w)\n        {\n            //cell.x -= step.z;\n            //cell.z += step.z;\n            //wipCell += zstep*step.z;\n            //newCellPos += step.z * slabdir_z;\n            normal = -step.z*slabdir_z;\n            newCellPos += slabdir_z* (rd_slab.z<0. ? thres_z.x*1.1 : thres_z.y*1.1);\n            t_ = planet.z;\n        }\n        else\n        {\n            //cell.z += step.z;\n            //wipCell += wstep*step.w;\n            //newCellPos += step.w * slabdir_w;\n            normal = -step.w*slabdir_w;\n            newCellPos += slabdir_w* (rd_slab.w<0. ? thres_w.x*1.1 : thres_w.y*1.1);\n            t_ = planet.w;\n        }\n\n        wipCell = xyToCell(newCellPos.xz);\n        \n        //wipCell = xyToCell(hexToXy(wipCell.xy));\n        y_ = floor(newCellPos.y - thingy(wipCell.xy,time));\n        //y_ = floor(newCellPos.y)- thingy(wipCell.xy,time);\n        if (!vert) y_ = floor(ro.y+rd.y*t_ - thingy(wipCell.xy,time));\n        //if (!vert) y_ = floor(ro.y+rd.y*t_);\n\n\n        \n        float h = fbm(hexToXy(wipCell.xy),0.8)*6. - length(hexToXy(wipCell.xy))*0.25;\n        if (y_ < h)\n        {\n            //hit = ro + rd*t;\n            t = t_;\n            break;\n        }\n        if (y_ > 20. && rd.y > 0.) break;\n\n    }\n    return vec4(normal, t);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    //fragColor = vec4(xyToHex(uv*10.)/10.,0.,1.);\n    //fragColor = vec4(col,1.0);\n    //return;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    \n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\t//float time = 32.0 + iTime*1.5;\n\tfloat time = 32.0 + iTime*1.5 + mo.x*200.;\n\n    // true => 2d traversal test\n    if(false)\n    {\n    \n        vec2 p = 10.*((2.0*fragCoord-iResolution.xy)/iResolution.y);\n        //vec3 cell = floor(xyToCell(p));\n        //fragColor = vec4(normalize(vec3(hex, -hex.x-hex.y)),1.);\n        \n        vec2 target = 10.*((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n        vec3 targetCell = xyToCell(target);\n        \n        \n        vec3 cell = xyToCell(p);\n        \n                vec3 local = vec3(xyToHexSmooth(p)-cell.xy, 0.);\n                local.z = -local.x-local.y;\n                fragColor = vec4(local,1.);\n        if (cell == targetCell) fragColor=vec4(1.f);\n        \n        float kind = targetCell.z;\n        //if(kind==0.)\n        \n        vec3 ro = vec3(1.,0.5,-2.);\n        vec3 rd = normalize(vec3(target-ro.xz,0.)).xzy;\n        \n        if (length(p-ro.xz-dot(p-ro.xz,rd.xz)*rd.xz) < 0.1) fragColor = vec4(1.f);\n        \n        vec3 wipCell = xyToCell(vec2(ro.xz));\n        for(int i=0; i<20; i++)\n        {\n            wipCell = xyToCell(hexToXy(wipCell.xy));\n            kind = wipCell.z;\n            \n            \n            float cellR = sqrt(3.)/2.;\n            vec3 cellCtr = vec3(hexToXy(wipCell.xy),0.).xzy;\n            if (length(p - cellCtr.xz) < 0.1) fragColor=vec4(1.f,0.1f,0.,1.);\n            else if (wipCell.xy == cell.xy) fragColor = vec4(1.f,0.5f,0.,1.);\n            vec3 slabdir_x = vec3(1.,0.,0.);\n            vec3 slabdir_y = vec3(0.,1.,0.);\n            vec3 slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)); \n            vec3 slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.));\n            vec2 thres_x = vec2(-cellR,+cellR);\n            vec2 thres_z = vec2(-cellR,+cellR);\n            vec2 thres_w = vec2(-cellR,+cellR);\n            \n            if (kind == 1.)\n            {\n                thres_w = vec2(-100.,100.);\n                slabdir_z = vec3(0.,0.,1.);\n                thres_z = vec2(-.5,.5);\n                \n            }\n            else if (kind == 2.)\n            {\n                slabdir_x = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n                slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n                thres_z = vec2(-.5,.5);\n            }\n            else if (kind == 3.)\n            {\n                thres_x = vec2(-100.,100.);\n                slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.)).zyx; \n                thres_w = vec2(-.5,.5);\n            }\n            else if (kind == 4.)\n            {\n                slabdir_x = vec3(0.,0.,1.);\n                slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n                slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.)).zyx; \n                thres_x = vec2(-1.,.5);\n                thres_w = vec2(-.5,1.);\n                thres_z = vec2(-1.,.5);\n            }\n            else if (kind == 5.)\n            {\n                slabdir_x = vec3(0.,0.,1.);\n                slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n                slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.)).zyx; \n                thres_x = vec2(-.5,1.);\n                thres_w = vec2(-1.,.5);\n                thres_z = vec2(-.5,1.);\n            }\n            float cellCtr_x = dot(slabdir_x, cellCtr);\n            float cellCtr_y = dot(slabdir_y, cellCtr);\n            float cellCtr_z = dot(slabdir_z, cellCtr);\n            float cellCtr_w = dot(slabdir_w, cellCtr);\n\n            vec4 plane;\n\n            vec4 ro_slab = vec4(dot(ro,slabdir_x), ro.y, dot(ro,slabdir_z), dot(ro,slabdir_w));\n            vec4 rd_slab = vec4(dot(rd,slabdir_x), rd.y, dot(rd,slabdir_z), dot(rd,slabdir_w));\n            \n            \n            \n            plane.x = rd_slab.x<0. ? cellCtr_x + thres_x.x : cellCtr_x + thres_x.y;\n            plane.y = rd_slab.y<0. ? cellCtr_y - 0.5: cellCtr_y + 0.5;\n            plane.z = rd_slab.z<0. ? cellCtr_z + thres_z.x : cellCtr_z + thres_z.y;\n            plane.w = rd_slab.w<0. ? cellCtr_w + thres_w.x : cellCtr_w + thres_w.y;\n            vec4 planet = abs((plane-ro_slab)/rd_slab);\n            vec4 step = rd_slab / abs(rd_slab);\n            vec3 pt = vec3(p,0.).xzy;\n            vec4 pt_slab = vec4(dot(pt,slabdir_x), dot(pt,slabdir_y), dot(pt,slabdir_z), dot(pt,slabdir_w));\n            bool slabx = pt_slab.x > cellCtr_x + thres_x.x && pt_slab.x < cellCtr_x + thres_x.y;\n            bool slaby = pt_slab.y > cellCtr_y - cellR && pt_slab.y < cellCtr_y + cellR;\n            bool slabz = pt_slab.z > cellCtr_z + thres_z.x && pt_slab.z < cellCtr_z + thres_z.y;\n            bool slabw = pt_slab.w > cellCtr_w + thres_w.x && pt_slab.w < cellCtr_w + thres_w.y;\n            //if (slabx && slaby && slabz && slabw) fragColor = vec4(0.,0.,1.,1.);\n            \n\n            float t_ = planet.z;\n            vec3 newCellPos = cellCtr;\n            if (/*planet.x < planet.y &&*/ planet.x < planet.z && planet.x < planet.w)\n            {\n                //cell.x += step.x;\n                //wipCell += xstep*step.x;\n                \n                if (wipCell.xy == cell.xy) fragColor = vec4(1.f,0.5f,1.,1.);\n                //newCellPos += step.x * slabdir_x;\n                newCellPos += slabdir_x* (rd_slab.x<0. ? thres_x.x*1.1 : thres_x.y*1.1);\n                t_ = planet.x;\n            }\n            else if(/*planet.y < planet.z &&*/ planet.y < planet.w)\n            {\n                //cell.y += step.y;\n                //wipCell += ystep*step.y;\n                newCellPos += step.y * slabdir_y;\n                //newCellPos = slabdir_y* (rd_slab.y<0. ? cellCtr_y - cellR*1.1 : cellCtr_y + cellR*1.1);\n                t_ = planet.y;\n            }\n            else if(planet.z < planet.w)\n            {\n                //cell.x -= step.z;\n                //cell.z += step.z;\n                //wipCell += zstep*step.z;\n                \n                if (wipCell.xy == cell.xy) fragColor = vec4(0.f,1.,1.,1.);\n                //newCellPos += step.z * slabdir_z;\n                newCellPos += slabdir_z* (rd_slab.z<0. ? thres_z.x*1.1 : thres_z.y*1.1);\n                t_ = planet.z;\n            }\n            else\n            {\n                //cell.z += step.z;\n                //wipCell += wstep*step.w;\n                //newCellPos += step.w * slabdir_w;\n                newCellPos += slabdir_w* (rd_slab.w<0. ? thres_w.x*1.1 : thres_w.y*1.1);\n                t_ = planet.w;\n            }\n            \n            vec3 fuu = normalize(1./planet.xzw);\n                if (wipCell.xy == cell.xy) fragColor = vec4(fuu.x,fuu.y,fuu.z,1.);\n            \n            wipCell = xyToCell(newCellPos.xz);\n\n        }\n        \n        if(false)\n        {\n            float cellR = sqrt(3.)/2.;\n            vec3 cellCtr = vec3(hexToXy(targetCell.xy),0.).xzy;\n            vec3 slabdir_x = vec3(1.,0.,0.);\n            vec3 slabdir_y = vec3(0.,1.,0.);\n            vec3 slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)); \n            vec3 slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.));\n            vec2 thres_x = vec2(-cellR,+cellR);\n            vec2 thres_z = vec2(-cellR,+cellR);\n            vec2 thres_w = vec2(-cellR,+cellR);\n            \n            // gridsteps\n            vec3 xstep = vec3(1.,0.,0.);\n            vec3 ystep = vec3(0.,1.,0.);\n            vec3 zstep = vec3(-1.,0.,1.);\n            vec3 wstep = vec3(0.,0.,1.);\n            \n            if (kind == 1.)\n            {\n                thres_w = vec2(-100.,100.);\n                slabdir_z = vec3(0.,0.,1.);\n                thres_z = vec2(-.5,.5);\n            }\n            else if (kind == 2.)\n            {\n                thres_x = vec2(-100.,100.);\n                slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n                thres_z = vec2(-.5,.5);\n            }\n            else if (kind == 3.)\n            {\n                thres_x = vec2(-100.,100.);\n                slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.)).zyx; \n                thres_w = vec2(-.5,.5);\n            }\n            else if (kind == 4.)\n            {\n                slabdir_x = vec3(0.,0.,1.);\n                slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n                slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.)).zyx; \n                thres_x = vec2(-1.,.5);\n                thres_w = vec2(-.5,1.);\n                thres_z = vec2(-1.,.5);\n            }\n            else if (kind == 5.)\n            {\n                slabdir_x = vec3(0.,0.,1.);\n                slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)).zyx; \n                slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.)).zyx; \n                thres_x = vec2(-.5,1.);\n                thres_w = vec2(-1.,.5);\n                thres_z = vec2(-.5,1.);\n            }\n            float cellCtr_x = dot(slabdir_x, cellCtr);\n            float cellCtr_y = dot(slabdir_y, cellCtr);\n            float cellCtr_z = dot(slabdir_z, cellCtr);\n            float cellCtr_w = dot(slabdir_w, cellCtr);\n\n            vec4 plane;\n\n            //vec4 ro_slab = vec4(ro.x, ro.y, dot(ro,slabdir_z), dot(ro,slabdir_w));\n            //vec4 rd_slab = vec4(rd.x, rd.y, dot(rd,slabdir_z), dot(rd,slabdir_w));\n            \n            \n            \n            //plane.x = rd.x<0. ? cellCtr.x - cellR : cellCtr.x + cellR;\n            //plane.y = rd.y<0. ? cellCtr.y - 0.5: cellCtr.y + 0.5;\n            //plane.z = rd_slab.z<0. ? cellCtr_z - cellR : cellCtr_z + cellR;\n            //plane.w = rd_slab.w<0. ? cellCtr_w - cellR : cellCtr_w + cellR;\n            //vec4 planet = abs((plane-ro_slab)/rd_slab);\n            //vec4 step = rd_slab / abs(rd_slab);\n            vec3 pt = vec3(p,0.).xzy;\n            vec4 pt_slab = vec4(dot(pt,slabdir_x), dot(pt,slabdir_y), dot(pt,slabdir_z), dot(pt,slabdir_w));\n            bool slabx = pt_slab.x > cellCtr_x + thres_x.x && pt_slab.x < cellCtr_x + thres_x.y;\n            bool slaby = pt_slab.y > cellCtr_y - cellR && pt_slab.y < cellCtr_y + cellR;\n            bool slabz = pt_slab.z > cellCtr_z + thres_z.x && pt_slab.z < cellCtr_z + thres_z.y;\n            bool slabw = pt_slab.w > cellCtr_w + thres_w.x && pt_slab.w < cellCtr_w + thres_w.y;\n            if (slabx && slaby && slabz && slabw) fragColor = vec4(0.,0.,1.,1.);\n            \n            \n        }\n        \n        \n        return;\n    }\n\n    // Camera stoel IIRC from iquilez\n    // camera\t\n    vec3 ta = vec3( 0.25, -0.75, -0.75 );\n    //vec3 ro = ta + vec3( 40.*cos(0.1*time + 40.0*mo.x), 35, 40.*sin(0.1*time + 40.0*mo.x) );\n    \n    //vec3 ro = ta + vec3( 40.*cos(0.1*time + 40.0*mo.x), 45.-30.*mo.y, 40.*sin(0.1*time + 40.0*mo.x) );\n    vec3 ro = ta + vec3( 40.*cos(0.1*time), 45.-30.*mo.y, 40.*sin(0.1*time) );\n    \n    //vec3 ro = ta + vec3( 25.*cos(0.1*time + 40.0*mo.x), 30, 25.*sin(0.1*time + 20.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // focal length\n    const float fl = 2.5;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,fl) );\n    rd = normalize(rd);\n   \n    \n    vec3 planehit = ro - rd * (ro.y / rd.y);\n    \n    //vec2 xy = floor(planehit.xz*1.f);\n    \n    //vec3 col_ = 0.5 + 0.5*cos(xy.xyy);\n    vec3 xy = floor(vec3(planehit.x-planehit.z,planehit.x+planehit.z,planehit.x));\n    \n    vec3 col_ = 0.5 + 0.5*cos(xy.xyz);\n    fragColor = vec4(col_,1.0);\n    if(false)return;\n    \n    vec4 fuu = traverseCells(ro, rd, time);\n\n    float t = fuu.w;\n    vec3 normal = fuu.xyz;\n    vec3 hit = ro+t*rd;\n    //vec3 cell = floor(hit);\n    vec3 cell = vec3(xyToHex(hit.xz), floor(hit.y)).xzy;\n    \n    vec3 sun = vec3(20.f,25.f,20.f);\n    vec3 shadow_rd = normalize(sun-hit);\n    vec4 bar = traverseCells(hit + 0.01*shadow_rd, shadow_rd, time);\n    float shadow_occ = 1.f;\n    if (bar.w != BIGFLOAT)\n        shadow_occ = 0.f;\n    //shadow_occ=1.f;\n    \n    float ambient = 0.1;\n    \n    vec3 lightdir = normalize(sun-hit);\n    \n    \n\tfloat spec = max(pow( max(0.,dot( -rd ,normalize(2.0*dot(lightdir,normal)*normal + (lightdir))) ), 100.0),0.)*2.;\n        //spec=0.;\n        \n    float diff = shadow_occ* (0.8)*clamp(dot(normal, normalize(sun-hit)), 0., 1.);\n        \n    float light = pow( ambient+spec+diff, 1.0/2.2 ); // (thanks to spalmer for reminding that gamma correction is nice!)\n    vec3 col = clamp((10.f+cell)/20.f,0.1,1.) *vec3(1.f,1.,0.5)* (light);\n    //vec3 col = clamp((10.f)/20.f,0.1,1.) *vec3(1.f,1.,0.5)* (light);\n    col = clamp(col,0.,1.);\n    //col=normalize(normal)*0.5+0.5;\n    //col = ((10.f+cell)/20.f);// * ((hit.z)/20.f);\n    //col = ((cell)/20.f);// * ((hit.z)/20.f);\n    //col = ((10.f+cell)/20.f) * (hit.y-cell.y);\n    //col = max(0.,0.5+0.5*dot(vec3(0.3,0.7,0.4), normal)) * vec3(0.15, 0.2, 0.3);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}