{"ver":"0.1","info":{"id":"cdSGzW","date":"1667260633","viewed":70,"name":"geometric series subdiv. lines","username":"jt","description":"N-ary subdivision lines SDF (should be exact euclidean - errors only at boundaries between lines).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lines","distance","euclidean","subdivision","geometric","short","nary","series","sum","telescope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/cdSGzW geometric series subdiv. lines by jt\n// based on https://www.shadertoy.com/view/dsj3z1 geometric series subdivision tex by jt\n\n// tag: sdf, lines, distance, euclidean, subdivision, geometric, short, nary, series, sum, telescope\n\nfloat lines(vec2 p, float n)\n{\n    float n1 = n - 1.0;\n    float b = n / n1;\n    float l = ceil(-log2(p.y) / log2(b)); // level\n    float s = pow(b, l); // scale\n    p = fract(s * p * n1);\n    \n    return abs(p.y-n1/(n+n1))*b/s/n;\n}\n\nfloat map(vec2 p)\n{    \n    float n = floor((0.5 - 0.5 * cos(iTime)) * 10.0 + 2.0);\n    return p.y > 0.0 ? lines(p, n) : -p.y;\n}\n\n#define pi 3.1415926\n\n#define EPSILON 0.001\n\nvec2 gradient(vec2 p) // NOT normalized so we can use it's length to detect errors in the SDF.\n{\n    vec2 h = vec2(EPSILON, 0);\n    return (vec2(map(p + h.xy) - map(p - h.xy),\n                 map(p + h.yx) - map(p - h.yx))) / EPSILON / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    float d = map(p);\n\n\t// using iq's sdf visualization\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(150.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n\n    if(iMouse.z > 0.001)\n    {\n        d = map(m);\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.0025));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n    }\n\n    // sdf error-detection from https://www.shadertoy.com/view/DdX3WH Interior Distance Detect Errors\n    {\n        float error = map(p - gradient(p) * map(p));\n        col.r += smoothstep(0.0, EPSILON, abs(error)) * (cos(iTime * 2.0 * pi) * 0.5 + 0.5); // detect some (interior and exterior) sdf inconsistencies\n    }\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}