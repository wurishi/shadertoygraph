{"ver":"0.1","info":{"id":"wlXSD8","date":"1562719186","viewed":612,"name":"raymarching: sea of clouds","username":"takumifukasawa","description":"raymarching: sea of clouds","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud","volumetric","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//-----------------------------------------------------------\n// ref\n// https://www.shadertoy.com/view/lss3zr\n// https://qiita.com/edo_m18/items/876f2857e67e26a053d6\n// https://qiita.com/edo_m18/items/cbba0cc4e33a5aa3be55\n//-----------------------------------------------------------\n\n#define saturate(a) clamp(a, 0., 1.);\n\n#define EPS 0.0001\n\n#define USE_DIRECTIONAL_LIGHT\n#define USE_AMBIENT_LIGHT\n\n#define SAMPLE_COUNT 40\n\n#define SHADOW_LENGTH 3.6\n#define SHADOW_ITERATIONS 4\n\n#define DENSITY_INTENSITY .55\n#define AMBIENT_INTENSITY 24.\n\nvec3 ABSORPTION_INTENSITY = vec3(.5, .8, .7) * .25;\n\nvec3 sunDirection = normalize(vec3(.5, .8, .5));\nvec3 lightColor = vec3(.3, .3, .2);\n    \nvec3 ambientLightDir = normalize(vec3(0., 1., 0.));\nvec3 ambientLightColor = vec3(.9, .7, .3);\n\nvec3 cloudColor = vec3(.92);    \n    \nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f;\n    p = m * p * 1.5;\n    f  = .5 * noise(p);\n    p = m * p * 2.;\n    f += .15 * noise(p);\n    //p = m * p * .2;\n    //f += 0.15 * noise(p);\n    return f;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat scene(vec3 p) {\n    return 1. - sdPlane(p, vec4(0., 1., 0., 1.)) + fbm(p * .7 + iTime) * 2.8;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy) - scene(p - e.xyy),\n            scene(p + e.yxy) - scene(p - e.yxy),\n            scene(p + e.yyx) - scene(p - e.yyx)\n        )\n    );\n    \n    /* cheap\n    const float h = EPS;\n    const vec2 k = vec2(1., -1.);\n    return normalize(\n    \tk.xyy * scene(p + k.xyy * h) +\n        k.yyx * scene(p + k.yyx * h) +\n        k.yxy * scene(p + k.yxy * h) +\n        k.xxx * scene(p + k.xxx * h)\n    );\n\t*/\n}\n\nmat3 camera(vec3 ro, vec3 ta) {\n    vec3 forward = normalize(ta - ro);\n    vec3 side = normalize(cross(forward, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(side, forward));\n    return mat3(side, up, forward);\n}\n\nvec4 rayMarchFog(vec3 p, vec3 dir) {    \n    float zStep = 16. / float(SAMPLE_COUNT);\n    \n    float transmittance = 1.;\n    \n    vec3 color = vec3(0.);    \n    \n    float densityScale = DENSITY_INTENSITY * zStep;\n    float shadowSize = SHADOW_LENGTH / float(SHADOW_ITERATIONS);\n    vec3 shadowScale = ABSORPTION_INTENSITY * shadowSize;\n    vec3 shadowStep = sunDirection * shadowSize;    \n    \n    for(int i = 0; i < SAMPLE_COUNT; i++) {\n    \tfloat density = scene(p);\n        \n        if(density > EPS) {\n            density = saturate(density * densityScale);\n            \n            #ifdef USE_DIRECTIONAL_LIGHT\n            \n            {\n\t            vec3 shadowPosition = p;\n    \t        float shadowDensity = 0.;\n        \t    for(int si = 0; si < SHADOW_ITERATIONS; si++) {\n            \t    float sp = scene(shadowPosition);\n                \tshadowDensity += sp;\n                \tshadowPosition += shadowStep;\n            \t}\n\t            vec3 attenuation = exp(-shadowDensity * shadowScale);\n    \t        vec3 attenuatedLight = lightColor * attenuation;\n        \t    color += cloudColor * attenuatedLight * transmittance * density;\n            }\n                \n            #endif\n            \n            #ifdef USE_AMBIENT_LIGHT\n            \n            {\n\t            float shadowDensity = 0.;\n    \t        vec3 shadowPosition = p + ambientLightDir * .05;\n        \t    shadowDensity += scene(p) * .05;\n            \tshadowPosition = p + ambientLightDir * .1;\n            \tshadowDensity += scene(p) * .05;\n            \tshadowPosition = p + ambientLightDir * .2;\n            \tshadowDensity += scene(p) * .1;\n            \tfloat attenuation = exp(-shadowDensity * AMBIENT_INTENSITY);\n            \tvec3 attenuatedLight = vec3(ambientLightColor * attenuation);\n            \tcolor += cloudColor * attenuatedLight * transmittance * density;\n            }\n            \n            #endif\n            \n            transmittance *= 1. - density;            \n        }\n\n        if(transmittance < EPS) {\n        \tbreak;\n    \t}\n        \n        p += dir * zStep;\n        \n    }\n    \n    //return color;\n    return vec4(color, 1. - transmittance);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    float rot = sin(iTime * .8) * .06;\n    uv *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n\n  \tfloat fov = 1.2;\n    vec3 f = vec3(0., 0., iTime);\n    vec3 lookAt = vec3(\n        cos(iTime * .4) * .4 + 0.,\n        sin(iTime * .5) * .18 + 1.6,\n        0.\n    ) + f + vec3(mouse, 0.) * 1.;\n    vec3 cameraPos = vec3(\n        0.,\n        2.35,\n        2.\n    ) + f;\n\n  \t// raymarch\n  \tvec3 rayOrigin = cameraPos;\n  \tvec3 rayDirection = camera(rayOrigin, lookAt) * normalize(vec3(uv, fov));\n\n    vec4 color = vec4(vec3(0.), 0.);\n    \n    vec4 res = rayMarchFog(rayOrigin, rayDirection);\n    color += res;\n    \n    vec3 bg = mix(\n        vec3(.6, .3, .4),\n        vec3(.9, .6, .4),\n        smoothstep(-.6, .4, uv.y)\n    );\n    \n    color.rgb += bg;\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}