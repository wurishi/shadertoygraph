{"ver":"0.1","info":{"id":"Mt2SzK","date":"1445287331","viewed":124,"name":"[CIS 565 2015f] RayMarcher","username":"sanchitgarg","description":"Another ray marcher","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Github Project Page : https://github.com/sanchitgarg/Project5-GLSL-Ray-Marcher\n\n//Other ray marching demos can be found at the following links\n// PACMAN : https://www.shadertoy.com/view/4lBSz3\n// FRACTAL : https://www.shadertoy.com/view/4tSSz3\n// TERRAIN : https://www.shadertoy.com/view/ll2SzK\n\n// Reference : https://www.shadertoy.com/view/Xds3zN\n\n#define MAX_DIS 20.0\n#define MAX_STEPS 100\n#define EPSILON 0.001\n#define SCENE_Y -3.0\n\n//Comment SHADOW_SCALE to remove shadow\n#define SHADOW_SCALE 30.0\n\n//----------------------Color Modes----------------------\n//Uncomment the coloring mode you want to view and comment the rest\n\n//#define DEPTH_COLOR\n//#define STEP_COUNT_COLOR\n//#define NORMAL_COLOR\n#define LAMBERT_COLOR\n//-------------------------------------------------------\n\n#define DISPLACEMENT 5.0\n\n//------------------Ray Casting Modes--------------------\n//#define NAIVE_RAY_CAST\n#define SPHERICAL_RAY_CAST\n//-------------------------------------------------------\n\n\n//-------------------------------------------------------\n//\t\t\t\t\tTransformation Matrices\n//-------------------------------------------------------\n\n\nstruct transformationMat {\n\tvec3 translate;\n    vec3 rotate;\n    vec3 scale;\n \n    mat4 translateMat;\n\tmat4 rotateMat;\n    mat4 scaleMat;\n};\n\ntransformationMat m1, m2, m3, m4, m5;\nmat4 matrix1, matrix2, matrix3, matrix4, matrix5;\n\nmat4 transpose(mat4 m)\n{\n\tmat4 retM;\n    \n    for(int i=0; i<4; i++)\n    {\n\t\tfor(int j=0; j<4; j++)\n        {\n            retM[i][j] = m[j][i];\n        }\n    }\n    \n    return retM;\n}\n\nmat3 transpose(mat3 m)\n{\n\tmat3 retM;\n    \n    for(int i=0; i<3; i++)\n    {\n\t\tfor(int j=0; j<3; j++)\n        {\n            retM[i][j] = m[j][i];\n        }\n    }\n    \n    return retM;\n}\n\nmat4 buildTransformationMatrix(transformationMat m)\n{\n    m.translateMat = (mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        -m.translate.x, -m.translate.y, -m.translate.z, 1.0));\n    \n\tmat4 rotateX = (mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, cos(m.rotate.x), sin(m.rotate.x), 0.0,\n\t\t\t\t\t\t0.0, -sin(m.rotate.x), cos(m.rotate.x), 0.0,\n                        0.0, 0.0, 0.0, 1.0));\n    \n\tmat4 rotateY = (mat4(cos(m.rotate.y), 0.0, -sin(m.rotate.y), 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n\t\t\t\t\t\tsin(m.rotate.y), 0.0, cos(m.rotate.y), 0.0,\n                        0.0, 0.0, 0.0, 1.0));\n    \n    mat4 rotateZ = (mat4(cos(m.rotate.z), sin(m.rotate.z), 0.0, 0.0,\n                        -sin(m.rotate.z), cos(m.rotate.z), 0.0, 0.0,\n\t\t\t\t\t\t0.0, 0.0, 1.0, 0.0,\n                     \t0.0, 0.0, 0.0, 1.0));\n   \n    m.rotateMat = transpose(rotateX * rotateY * rotateX);\n    \n    m.scaleMat = mat4(1.0/m.scale.x, 0.0, 0.0, 0.0,\n                      0.0, 1.0/m.scale.y, 0.0, 0.0,\n                      0.0, 0.0, 1.0/m.scale.z, 0.0,\n                      0.0, 0.0, 0.0, 1.0);\n    \n    return (m.scaleMat * m.rotateMat * m.translateMat);\n}\n\nvoid setMatrices()\n{\n \tm1.translate = vec3(-0.5, 1.5 + SCENE_Y, 4.5);\n    m1.rotate = radians(vec3(0.0));\n    m1.scale = vec3(1.0);\n    matrix1 = buildTransformationMatrix(m1);\n    \n\tm2.translate = vec3(2.0, -0.5+ SCENE_Y, 7.0);\n    m2.rotate = radians(vec3(0.0));\n    m2.scale = vec3(1.0);\n    matrix2 = buildTransformationMatrix(m2);\n    \n   \tm3.translate = vec3(-3.0, -0.5+ SCENE_Y, 7.0);\n    m3.rotate = radians(vec3(0.0));\n    m3.scale = vec3(1.0);\n    matrix3 = buildTransformationMatrix(m3);\n    \n    m4.translate = vec3(-3.0, -0.5+ SCENE_Y, 2.0);\n    m4.rotate = radians(vec3(0.0));\n    m4.scale = vec3(1.0);\n    matrix4 = buildTransformationMatrix(m4);\n    \n\tm5.translate = vec3(2.0, -0.5+ SCENE_Y, 2.0);\n    m5.rotate = radians(vec3(0.0));\n    m5.scale = vec3(1.0);\n\tmatrix5 = buildTransformationMatrix(m5);\n}\n\n//-------------------------------------------------------\n//\t\t\t\t\tDistance Estimators\n//-------------------------------------------------------\n\n\n//--------Distance functions for various objects---------\nfloat sdPlane (vec3 p, float y)\n{\n\treturn p.y - y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n//--------------------CSG Operations---------------------\nfloat opDifference( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat opIntersect( float d1, float d2 )\n{\n    return max(d2,d1);\n}\n\nfloat opBlend(float a, float b, float blendRadius) {\n    float c = 1.0 * (0.5 + (b - a) * (0.5 / blendRadius));\n    return ((c) * a + (1.0-c) * b) - blendRadius * c * (1.0 - c);\n}\n\n#ifdef DISPLACEMENT\nfloat opDisplacement(vec3 pt)\n{\n    float factor = DISPLACEMENT;\n    return sin(factor * pt.x) * sin(factor * pt.y) * sin(factor * pt.z);\n}\n#endif\n\nvec3 opTx( vec3 p, mat4 m )\n{\n\treturn vec3(m * vec4(p, 1.0));\n}\n\nvec3 opTx( vec3 p, transformationMat m )\n{\n\treturn vec3(buildTransformationMatrix(m) * vec4(p, 1.0));\n}\n\n\n//Function to create the actual scene\nfloat disEstimator(vec3 pt)\n{\n    //Infinite\n    float dis = sdPlane(pt, -2.0 + + SCENE_Y);\n    \n    //Difference\n    \t  dis = opUnion(dis, opDifference(sdBox(opTx(pt, matrix2), vec3(0.5)),\n                                          sdSphere(opTx(pt, matrix2), 0.6)));\n\t\t\n    //Intersection\n    \t//Dice\n\t\t  dis = opUnion(dis, opIntersect(sdBox(opTx(pt, matrix3), vec3(0.5)),\n                                          sdSphere(opTx(pt, matrix3), 0.7)));\n    \t//one\n\t      dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.0,-0.5,0.0), matrix3), 0.1));\n        //two\n    \tdis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2,0.5,-0.2), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2,0.5,0.2), matrix3), 0.1));\n    \t//three\n    \tdis = opDifference(dis, sdSphere(opTx(pt-vec3(0.5,0.0,0.0), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.5,0.25,0.25), matrix3), 0.1));\n\t      dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.5,-0.25,-0.25), matrix3), 0.1));\n\t    //four\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, 0.2, 0.5), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, -0.2, 0.5), matrix3), 0.1));\n\t\t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, 0.2, 0.5), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, -0.2, 0.5), matrix3), 0.1));\n    //five\n    \tdis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,0.0,0.0), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,0.25,0.25), matrix3), 0.1));\n\t      dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,-0.25,-0.25), matrix3), 0.1));\n\t\t\tdis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,0.25,-0.25), matrix3), 0.1));\n\t      dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.5,-0.25,0.25), matrix3), 0.1));\n    //six\n\t\tdis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, 0.25, -0.5), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, 0.0, -0.5), matrix3), 0.1));\n\t\t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(0.2, -0.25, -0.5), matrix3), 0.1));\n\t\tdis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, 0.25, -0.5), matrix3), 0.1));\n    \t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, 0.0, -0.5), matrix3), 0.1));\n\t\t  dis = opDifference(dis, sdSphere(opTx(pt-vec3(-0.2, -0.25, -0.5), matrix3), 0.1));\n    \n    //Blend\n    \tdis = opUnion(dis, opBlend(\n                      sdSphere(opTx(pt-vec3(0.0,0.0,0.5), matrix4), 0.5),\n\t\t  \t          sdSphere(opTx(pt+vec3(0.0,0.0,0.5), matrix4), 0.5),\n            \t\t\t0.5)\n                      );\n   \n//    #ifdef NAIVE_RAY_CAST\n    #ifdef DISPLACEMENT\n    //Displacement\n\t    dis = opUnion(dis, (opDisplacement(opTx(pt, matrix5))+\n\t\t\t\t\t\t\tsdSphere(opTx(pt, matrix5), 0.5)));\n    #endif\n //   #endif\n\n    \n    \n    return dis;\n}\n\n\n\n//-------------------------------------------------------\n//\t\t\t\tColor calculation functions\n//-------------------------------------------------------\n\n//Function to calculate the normal\nvec3 getNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    disEstimator(pos+eps.xyy) - disEstimator(pos-eps.xyy),\n\t    disEstimator(pos+eps.yxy) - disEstimator(pos-eps.yxy),\n\t    disEstimator(pos+eps.yyx) - disEstimator(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n#ifdef SHADOW_SCALE\n//Function to calculate the soft shadow\nfloat getSoftShadow(vec3 pt, vec3 lightPos)\n{\n    float t = 2.0;\n    float minT = 2.0;\n    \n    vec3 rd = normalize(lightPos - pt);\n    vec3 ro = pt;\n    float maxT = (lightPos.x - ro.x) / rd.x;\n\tfloat shadow = 1.0;\n    \n\tfor(int i=0; i<MAX_STEPS; ++i )\n    {\n\t\tpt = ro + t * rd;\n\n        float dt = disEstimator(pt);\n        \n        if(dt < EPSILON)\n        {\n\t\t\treturn 0.0;\n        }\n\n        t += dt;\n        shadow = min(shadow, SHADOW_SCALE * (dt / t));\t\t\n        \n        if(t > maxT)\n        {\n          \treturn shadow;\n        }\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n#endif\n\n//Function to calculate lambert color\nvec3 getLambertColor(vec3 pt, vec3 ro)\n{\n \tvec3 lightPos = vec3(5.0,5.0,0.0);\n    vec3 lightCol = vec3(1.0);\n    vec3 lightVector = normalize(lightPos - pt);\n    \n    vec3 normal = getNormal(pt);\n    \n    #ifdef SHADOW_SCALE\n\t\tfloat shadow = getSoftShadow(pt, lightPos);\n\t\treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol * (shadow) + 0.01;\n    #else\n\t    return clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol + 0.01;\n    #endif\n}\n\n//Function to calculate color based on number of steps\nvec3 getStepCountColor(vec2 steps)\n{\n    float t = (steps.y - steps.x) / steps.y;\n\tvec2 c = vec2(t, 0.0);\n    return vec3(1.0-t, t, 0);\n}\n\n//Function to calculate colors\nvec3 colorCalculation(vec3 pt, vec2 dis, vec3 ro, vec2 steps)\n{\n    #ifdef DEPTH_COLOR\n\t\treturn vec3(abs((dis.y - dis.x) / dis.y));\n    #endif\n    \n    #ifdef STEP_COUNT_COLOR\n\t\treturn getStepCountColor(steps);\n\t#endif\n    \n    #ifdef NORMAL_COLOR\n        return abs(getNormal(pt));\n\t#endif\n    \n    #ifdef LAMBERT_COLOR\n        return getLambertColor(pt, ro);\n\t#endif\n    \n\treturn vec3(0.0);\n}\n\n//-------------------------------------------------------\n//\t\t\t\tRay Cast Functions\n//-------------------------------------------------------\n\nvec3 naiveRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n    float i = 0.0;\n    int maxSteps = 500;\n\tfor(float t = 0.00; t < MAX_DIS; t+=0.01)\n\t{\n        ++i;\n        pt = ro + rd * t;\n        \n        float dis = disEstimator(pt);\n        \n     \tif(dis < EPSILON)\n        {\n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(i, maxSteps));\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\nvec3 sphericalRayCast(in vec3 ro, in vec3 rd)\n{\n    vec3 pt = ro;\n   \t\n//    float dt = disEstimator(pt);\n\tfloat t = 0.0;\n    \n    for(int i = 1; i<MAX_STEPS; i++)\n\t{\n        pt = ro + t * rd;\n        \n        float dt = disEstimator(pt);\n        \n     \tif(dt < EPSILON)\n        {   \n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(float(i), MAX_STEPS));\n        }\n        \n\t\tt += dt;\n        \n        if(t > MAX_DIS)\n  \t    {\n         \treturn vec3(0.0);\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\n\n//-------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    #ifdef NAIVE_RAY_CAST\n\t    return naiveRayCast(ro, rd);\n    #else \n        return sphericalRayCast(ro, rd);\n    #endif\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    setMatrices();\n    \n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}