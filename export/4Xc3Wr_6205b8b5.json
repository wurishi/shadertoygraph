{"ver":"0.1","info":{"id":"4Xc3Wr","date":"1716307397","viewed":83,"name":"Box Glitch","username":"m4nu","description":"Moarrr ray marching stuff!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"XXc3Wn","parentname":"Fork Fork Fork  m4nu 622"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\nconst int NUM_OF_STEPS = 500;\nconst float MIN_DIST_TO_SDF = 0.0001;\nconst float MAX_DIST_TO_TRAVEL = 300.0;\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n\nvec2 minID(vec2 res1, vec2 res2) {\n    return (res1.x < res2.x) ? res1 : res2;\n}\n\n\nmat2 rot2D(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2( c, -s, s, c);\n}\n\nvec3 makeRay(vec2 uv, vec3 ro, vec3 lookAtPoint, float fov) {\n  vec3 worldUpVec = vec3(0,1,0);\n  vec3 forward = normalize(lookAtPoint - ro);\n  vec3 rightStep = normalize(cross(worldUpVec, forward));\n  vec3 upStep = cross(forward,rightStep);\n  vec3 center = ro + forward * fov;\n  vec3 intersectionPoint = center + (uv.x * rightStep) + (uv.y * upStep);\n  vec3 ray = normalize(intersectionPoint - ro);\n  return ray;\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n////////////////////////////////////////////////////////////////\n//\n//             SDF\n//\n////////////////////////////////////////////////////////////////\n\n// Signed distance function for a box\nfloat sdfBox(vec3 p, vec3 s, float offset, bool reversed) {\n    if (reversed) {\n        // For growth from top to bottom\n        p.y -= offset * 2.;\n        p.y += s.y;\n    } else {\n        // For growth from bottom to top\n        p.y -= offset * 2.;\n        p.y -= s.y;\n    }\n    vec3 d = abs(p) - s;\n    // return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    return outsideDistance * 0.5 + insideDistance ;\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             RAY MARCHING\n//\n////////////////////////////////////////////////////////////////\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat rand(float x) {\n  return(fract(sin(x) * 10000.));\n}\n\nvec2 map(vec3 p) {\n\nfloat floorHeight = 0.;\n\nfloat planeDist = sdPlane(p, vec3(0., 1., 0.), floorHeight);\n\nfloat planeId = 1.;\n\nvec2 plane = vec2(planeDist, planeId);\n\nfloat boxDistance = 3.;\n\nfloat boxWidth = 1.;\n\nfloat boxDist = 99999.;\n\nvec3 pb = p;\n\nint boxIndex = int(floor(p.z / boxDistance));\n\nfor(int i=boxIndex-1; i<=boxIndex+1; ++i)\n\n{\n\npb.z = p.z - (float(i)+0.5) * boxDistance;\n\nfloat height = rand(float(i)) * 6.;\n\nvec3 boxSize = vec3(boxWidth, height, boxWidth);\n\nboxDist = min(boxDist, sdfBox(pb, boxSize, 0., false) * 0.9);\n\n}\n\nfloat boxId = 2.;\n\nvec2 box = vec2(boxDist, boxId);\n\nreturn minID(plane, box);\n\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float marched = 0.;\n  float currentIdx = 0.;\n  vec2 object;\n  for( int i = 0; i < NUM_OF_STEPS; i ++ ) {\n    currentIdx += 1.;\n    vec3 stp = ro + rd * marched; \n    object = map(stp);\n    marched += object.x;\n    if (abs(object.x) < MIN_DIST_TO_SDF || marched > MAX_DIST_TO_TRAVEL ) {\n      break;\n    }\n  }\n  return vec2(marched, object.y);\n}\n\n\nvec3 getNormal(vec3 p) {\n  vec2 d = vec2(0.01, 0.0);\n  float gx = map(p + d.xyy).x - map(p - d.xyy).x;\n  float gy = map(p + d.yxy).x - map(p - d.yxy).x;\n  float gz = map(p + d.yyx).x - map(p - d.yyx).x;\n  vec3 normal = vec3(gx, gy, gz);\n  return normalize(normal);\n}\n\n\n\nvec3 getMaterial(vec3 p, float objectID) {\n  vec3 material;\n  switch(int(objectID)) {\n    case 1:\n      int boxIndex = int(floor(p.z / 0.3));\n      // material = vec3(0.2 + float(boxIndex) * mod(floor(p.z), .3), 0., 0.);\n      // material = vec3(float(boxIndex) * 0.05, 0., 0.);\n      material = vec3(0.2 + 0.4 * mod(floor(p.x) + floor(p.z), 2.0));\n      break;\n    case 2:\n      material = vec3(.8, .8, .2);\n      break;\n    case 3:\n      material = vec3(0.698, 0.6824, 0.698);\n      break;\n    default:\n      material = vec3(0.);\n      break;\n  }\n  return material;\n}\n\nvec3 getLight(vec3 p, vec3 rd, vec2 object) {\n  vec3 lightPos = vec3(20. , 20., -10.);\n  vec3 L = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n  vec3 color = getMaterial(p, object.y);\n\n  // phong lighting model\n  vec3 V = -rd;\n  vec3 R = reflect(-L, normal);\n  vec3 specColor = vec3(.5);\n  vec3 specular = specColor * pow(clamp(dot(R, V), 0.0, 1.0), 10.);\n  vec3 ambient = color * 0.02;\n  // Simple lighting model\n  vec3 diffuse = color * clamp(dot(L, normal), 0., 1.);\n\n  // shadow\n  float distToLight = rayMarch(p + normal * 0.02, normalize(lightPos)).x;\n  if (distToLight < length(lightPos - p)) {\n    return ambient * distToLight;\n  }\n    return diffuse + ambient + specular;\n}\n\nvoid mouseMouvement(inout vec3 ro, vec3 lookAtPoint) {\n vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;  \n vec3 relPos = ro - lookAtPoint;\n  relPos.yz *= rot2D(-m.y * 2.);\n  relPos.xz *= rot2D(-m.x * 4.);\n  ro = relPos + lookAtPoint;\n}\n\nvec3 render(vec2 uv) {\n  vec3 ro = vec3(15., 7.2, 3.3);\n  vec3 lookAtPoint = vec3(0., 1., 4.);\n  float zoom = 1.4;\n  mouseMouvement(ro, lookAtPoint);\n  vec3 rd = makeRay(uv, ro, lookAtPoint, zoom);\n  vec2 marched = rayMarch(ro, rd);\n\n  vec3 BACKGROUND = vec3(.5, .8, .9);\n  vec3 color = vec3(.0);\n  if (marched.x < MAX_DIST_TO_TRAVEL) {\n    vec3 p = ro + rd * marched.x;\n    color += getLight(p, rd, marched);\n    // Fog effect to attenuate pixel distortion in horizon\n    color  = mix(color, BACKGROUND, 1. - exp(-0.0002 * marched.x * marched.x));\n  } else {\n    // Background\n    color += BACKGROUND - max(0.95 * rd.y, 0.0);\n  }\n  color = pow(color, vec3(0.4545));\n  return color;\n}\n\nvec2 getUV(vec2 offset) {\n    return (2.0 * (gl_FragCoord.xy + offset) - iResolution.xy) / iResolution.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n  vec3 color = vec3(0.0);\n\n  color = render(uv);\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}