{"ver":"0.1","info":{"id":"wtsBz7","date":"1596395646","viewed":163,"name":"Raytracing experiment","username":"dub","description":"Raytracer","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","phong","oddlysatisfying"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// reference:\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\n#define MOVING\n\nconst float MAXFLOAT = 3.402823e+38;\nconst float EPSILON = 0.001;\nconst int MAX_BOUNCE = 6;\n\nvec3 camera = vec3(0.0, 0.0, 0.0);\n\nvec3 center = vec3(0.0, 0.0, 2.0);\n\nvec3 light = vec3(-10.0, 10.0, -10.0);\n\nfloat radius = 1.0;\nfloat radius2 = 1.0; // squared\n\nvec3 color_white = vec3(1.0, 1.0, 1.0);\nvec3 color_black = vec3(0.0, 0.0, 0.0);\nconst vec3 sphere_color = vec3(1.0, 0.0, 0.0);\n\nvec4[5] scene = vec4[](\n    vec4(0.0, 0.0, 4.0, 0.9),\n    vec4(-2.0, 0.6, 4.0, 0.9),\n    vec4(2.0, 0.6, 4.0, 0.9),\n    vec4(-0.5, -0.5, 2.0, 0.3),\n    vec4(0.5, -0.5, 2.0, 0.3)\n);\n\nvec3 sky(vec3 a)\n{\n    #if 0\n    return mix(\n        color_white,\n        vec3(0.0, 0.423, 0.784),\n        dot(normalize(a), vec3(0.0, 1.0, 0.0))*0.5+0.5);\n    #else\n    // happy accident\n    return mix(\n        color_white,\n        color_black,\n        dot(normalize(a), vec3(0.0, 1.0, 0.0)));\n    #endif\n}\n\nbool sphere_intersect(in vec4 sphere, in vec3 origin, in vec3 dir, out float x0, out float x1)\n{\n    vec3 center = sphere.xyz;\n    float radius2 = sphere.w*sphere.w;\n    \n\tvec3 L = origin - center;\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, L);\n    float c = dot(L, L) - radius2;\n    \n    float discr = b * b - 4.0 * a * c;\n    \n    if (discr < 0.0)\n        return false;\n    \n    if (discr == 0.0)\n    {\n        x0 = x1 = -0.5 * b / a;\n        \n        return true;\n    }\n    \n    float q = (b > 0.0) ?\n        -0.5 * (b + sqrt(discr)) :\n    \t-0.5 * (b - sqrt(discr));\n    x0 = q / a;\n    x1 = c / q;\n    \n    if (x0 > x1)\n    {\n        float t = x0;\n        x0 = x1;\n        x1 = t;\n    }\n    \n    if (x0 < 0.0)\n    {\n        x0 = x1;\n        if (x0 < EPSILON) // avoid self colisions roughly\n            return false;\n    }\n    \n    return true;\n}\n\n// Blinn-Phong (light, view, normal)\nvec3 phong(in vec3 l, in vec3 v, in vec3 n)\n{\n\tvec3 h = normalize(l + v);\n\n    vec3 diffuse = sphere_color * max(dot(n, l), EPSILON);\n\n    vec3 specular = color_white * max(pow(dot(n, h), 200.0), EPSILON);\n    \n    return (specular * 0.3) + (diffuse * 0.5) + color_white * 0.2;\n}\n\nbool nearest_intersection(in vec3 origin, in vec3 dir, out vec3 center, out float t)\n{\n    t = MAXFLOAT;\n    float t0, t1;\n    bool hit = false;\n    \n    #ifdef MOVING\n    vec4 sphere;\n    \n    for (int i = 0; i < 3; i++)\n    {\n        if(sphere_intersect(scene[i], origin, dir, t0, t1))\n    \t{\n            if(t0 < t)\n            {\n                t = t0;\n                center = scene[i].xyz;\n            }\n            \n            hit = true;\n        }\n    }\n    \n    // let's add some stuff not on the scene\n    for (int i = 0; i < 8; i++)\n    {\n    \t//sphere = scene[0];\n        float ts = iTime + float(i) * 3.14/4.0;\n        \n        sphere = vec4(cos(ts)*1.5, -0.6, sin(ts)*1.5+4.0, 0.5);\n        \n        if(sphere_intersect(sphere, origin, dir, t0, t1))\n        {\n            if(t0 < t)\n            {\n                t = t0;\n                center = sphere.xyz;\n            }\n\n            hit = true;\n        }\n    }\n    \n    #else\n    for (int i = 0; i < 5; i++)\n    {\n        if(sphere_intersect(scene[i], origin, dir, t0, t1))\n    \t{\n            if(t0 < t)\n            {\n                t = t0;\n                center = scene[i].xyz;\n            }\n            \n            hit = true;\n        }\n    }\n    #endif\n    \n    return hit;\n}\n\nvoid reflect_n(in vec3 origin, in vec3 dir, out vec3 color)\n{\n    vec3 center;\n    float t = MAXFLOAT;\n    bool hit = true;\n    // color = color_white;\n    color = sky(dir);\n    \n    for (int n = 0; n < MAX_BOUNCE; n++)\n    {\n        if(!nearest_intersection(origin, dir, center, t))\n        \tbreak;\n        \n        vec3 intersection = origin + dir * t;\n        vec3 normal = normalize(intersection - center);\n\n        vec3 pcolor = phong(\n            normalize(light - intersection), // light\n            normalize(origin - intersection), // view\n            normal); // normal\n\n        color = mix(color, pcolor, 0.6);\n\n        origin = intersection;\n        dir = reflect(dir, normal);\n    }\n    color = mix(color, sky(dir), 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y);\n    \n    // primary rays\n    vec3 dir = normalize(vec3(uv.x - aspect / 2.0, uv.y-0.5, 1.0));\n\n   \tvec3 rcolor;\n    reflect_n(camera, dir, rcolor);\n    fragColor = vec4(rcolor, 1.0);\n}","name":"Image","description":"","type":"image"}]}