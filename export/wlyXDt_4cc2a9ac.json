{"ver":"0.1","info":{"id":"wlyXDt","date":"1585692139","viewed":73,"name":"Tree under moonlight","username":"btwist","description":"A tree by night","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265359;\n\n/* \n * Returns the mask of a tree silhouette, given its trunk radius, foliage size and shift in space\n * The math tools used to draw the shapes is mainly inspired by Inigo Quilez tutorial 'The principles of painting with maths'\n * https://www.youtube.com/watch?v=0ifChJ0nJfM\n */\nfloat makeTree(vec2 uv, vec2 shift, float trunkRadius, float trunkHeight, float foliageRadius)\n{\n    // Shift foreground decor\n    uv -= shift;\n    \n    // Trunk\n    \n    // Ground the trunk to the floor with exponential behavior\n    trunkRadius += exp(-80.0 * (uv.y + 0.3));\n    float trunkMask = smoothstep(trunkRadius - 0.003, trunkRadius + 0.003, abs(uv.x) + 0.05*sin(uv.y));\n    \n    uv -= vec2(0.0, 1.0);\n    \n    // Animated foliage 1\n    \n    // The atan function allows to recover the angle formed by the vector pointing to uv with the x principal axis\n    float foliageFrequency = 10.0;\n    float angle = atan(uv.y, uv.x);\n    // Apply a time-varying radial offset in x direction\n    float offset = (25.0 + cos(3.0 * iTime)) * uv.x + 2.0;\n    \n    float foliageContour = foliageRadius + 0.2 * cos(foliageFrequency * angle + offset);\n    float foliageMask = smoothstep(foliageContour - 0.01, foliageContour + 0.01, length(uv + vec2(.1)));\n    \n    // Animated foliage 2\n    \n    foliageFrequency = 15.0;\n    offset = (30.0 + cos(5.0 * iTime)) * uv.x;\n    \n    foliageContour = foliageRadius + 0.1 * cos(foliageFrequency * angle + offset);\n    foliageMask *= smoothstep(foliageContour - 0.01, foliageContour + 0.01, length(uv - vec2(.1)));\n    \n    uv += vec2(0., 1.3);\n    \n    // Animated Bush\n    \n    // Draw the same way as tree foliage\n    float bushFrequency = 10.0;\n    angle = atan(uv.y, uv.x);\n    offset = (15.0 + cos(3.0 * iTime)) * uv.x + abs(cos(iTime));\n    \n    float bushContour = 0.2 + 0.08 * cos(bushFrequency * angle - offset);\n    float bushMask = smoothstep(bushContour - 0.01, bushContour + 0.01, length(uv));\n    \n    return trunkMask * foliageMask * bushMask;\n}\n\n/*\n * Returns a time-varying radial gradient between minRadius and maxRadius at position center\n */\nfloat makeHalo(vec2 center, float minRadius, float maxRadius, vec2 uv)\n{\n    return smoothstep(minRadius + 0.01  * cos(5.0*iTime), maxRadius + 0.05 * cos(5.0*iTime), length(center - uv));\n}\n\n/*\n * Returns a mask of a simple circle at position center\n */\nfloat makeMoon(vec2 center, float radius, vec2 uv)\n{\n    return smoothstep(radius - 0.005, radius + 0.005, length(center - uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    // Normalized Device Coordinates\n    uv = (uv - vec2(0.5, 0.5)) * 2.0;\n    // Scale space with respect to image aspect ratio\n    uv.x *= aspectRatio;\n    \n    // Similarly, map mouse coordinates between -1 and 1\n    vec2 uvMouse = iMouse.xy / iResolution.xy;\n    uvMouse = (uvMouse - vec2(0.5, 0.5)) * 2.0;\n    // And scale it with respect to image aspect ratio\n    uvMouse.x *= aspectRatio;\n    \n    // Sky colors\n    vec3 lightBlue = vec3(0.83, 0.99, 1.0);\n    vec3 darkBlue = vec3(0.075, 0.263, 0.263);\n    \n    // Moon effect\n    float haloMask = makeHalo(uvMouse, 0.2, 1.5, uv);\n    float moonMask = makeMoon(uvMouse, 0.18, uv);\n    \n    vec3 bgColor = (1.0 - haloMask) * lightBlue + haloMask * darkBlue;\n    bgColor = moonMask * bgColor + (1.0 - moonMask) * vec3(1.0);\n    \n    // Draw foreground silhouettes\n    vec3 col = makeTree(uv, vec2(0.7, 0.0), 0.1, 1.0, 0.3) * bgColor;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}