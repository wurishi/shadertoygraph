{"ver":"0.1","info":{"id":"McVyRG","date":"1732041051","viewed":151,"name":" remake superchain","username":"nayk","description":"original source https://www.shadertoy.com/view/XcKyRG","likes":8,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","reflection","torus","rings","chain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 乱数\n#define hash(x) (tan(x) * 43758.5453123)\n\nconst float PI = acos(-1.);\nconst float PI2 = PI * 2.;\n//const float BPM = 140.;\nconst float BPM = 12.;\nfloat reTime; // 速さに変化をつけた時間\n\n// 2Dの乱数\nfloat hash12(vec2 p) {\n    return hash(dot(p, vec2(1.9898, 78.233)));\n}\n\n// 2Dの回転行列\nmat2 rotate2D(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// HSVからRGBへの変換\nvec3 hsv(float h, float s, float v) {\n    vec3 res = fract(h + vec3(0, 2, 1) / 3.);\n    res = clamp(abs(res * 6. - 3.) - 1., 0., 1.);\n    res = (res - 1.) * s + 1.;\n    return res * v;\n}\n\n// レイを算出\nvec3 rayDir(vec2 uv, vec3 dir, float fov) {\n    dir = normalize(dir);\n       \n    vec3 u = abs(dir.y) < 0.999 ? vec3(0, 1, 0) : vec3(0, 0, 1);\n    vec3 side = normalize(cross(dir, u));\n    vec3 up = cross(side, dir);\n    return normalize(uv.x * side + uv.y * up + dir / tan(fov / 360. * PI));\n}\n\n// トーラスの距離関数\nfloat sdTorus(vec3 p, float R, float r) {\n    return length(vec2(p.z, length(p.xy) - R)) - r;\n}\n\n// 距離関数の値が小さい方の距離とIDを返す\nvec3 opU(vec3 d1, vec3 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\n#define Q(p) p *= 2.*r(round(atan(p.x, p.y) * 4.) / 4.)\n#define r(a) mat2(cos(a + asin(vec4(0,1,-1,0))))\nfloat sdSuperChain(vec3 p, out vec3 ID) {\n    ID.xz = floor(p.xz / 2.) * 2.;\n    \n    p.xz = mod(p.xz, 2.) - 1.;\n    vec2 s = sign(p.xz);\n    ID.y = s.x * s.y;\n  p.xy*=rotate2D(iTime*0.5);\n    p.xz = abs(p.xz) - 0.5;\n\n    const float R = 0.85;\n    const float a = 0.4;\n    const float r = 0.07;\n    \n    vec4 t1 = vec4(p.xz - 0.5, p.xz + 0.5);\n    vec4 t2 = t1 * t1 * a;\n    \n    float d1 = sdTorus(vec3(t1.xy, p.y - (t2.x - t2.y)), R, r);\n    float d2 = sdTorus(vec3(t1.yz, p.y - (t2.y - t2.z)), R, r);\n    float d3 = sdTorus(vec3(t1.zw, p.y - (t2.z - t2.w)), R, r);\n    float d4 = sdTorus(vec3(t1.wx, p.y - (t2.w - t2.x)), R, r);\n    \n    vec3 res = vec3(d1, ID.xz + s);\n\n    res = opU(res, vec3(d2, ID.xz + vec2(0, s.y)));\n    res = opU(res, vec3(d3, ID.xz));\n    res = opU(res, vec3(d4, ID.xz + vec2(s.x, 0)));\n    ID.xz = res.yz;\n    \n    return res.x;\n}\n\n// 参考: Log-polar Mapping in 3D\n// https://www.osar.fr/notes/logspherical/\nconst float N = 10.;\nvec3 logPolar(vec3 p, out float mul) {\n    float L = length(p.xz);\n       \n    p.xz = vec2(log(L), atan(p.z, p.x));\n    float scale = N / PI / sqrt(2.);\n    mul = L / scale;\n    p *= scale;\n    p.y /= L;\n    return p;\n}\n\n// 距離関数\nfloat map(vec3 p, out vec3 ID) {\n    float d;\n     p.xz*=rotate2D(iTime*0.5);\n   Q(p.xz);\n    float mul;\n    p = logPolar(p, mul);\n    d = p.y; // 床\n    p.y -= 0.4;\n    p.xz*=rotate2D(iTime*0.5);\n    d = min(d, sdSuperChain(p, ID));\n  \n;\n    \n\n    ID.xz -= floor(dot(ID.xz, vec2(0.5 / N))) * N;\n    \n    return d * mul;\n}\n\n// 法線ベクトルを算出\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0);\n   // y軸からの距離に比例してオブジェクトが大きくなるため\n    vec3 ID;\n    return normalize(vec3(map(p + e.xyy, ID) - map(p - e.xyy, ID),\n                          map(p + e.yxy, ID) - map(p - e.yxy, ID),\n                          map(p + e.yyx, ID) - map(p - e.yyx, ID)));\n}\n\n// オブジェクトの色を計算\nvec3 calcColor(vec3 p, vec3 ID) {\n    if(p.y < 0.01) {\n        return mix(vec3(0.05), vec3(0.9), ID.y * 0.5 + 0.5);\n    }\n    float h = hash12(ID.xz);\n    return hsv(h, 0.8, 1.);\n}\n\n// Fresnel反射率のSchlickによる近似\nfloat fresnelSchlick(float f0, float cosTheta) {\n    return f0 + (1. - f0) * pow(1. - cosTheta, 5.);\n}\n\n// レイマーチング\nvec3 raymarch(inout vec3 ro, inout vec3 rd, inout bool hit, inout vec3 refAtt) {\n    vec3 col = vec3(0);\n    float t = 0.; // オブジェクトの表面まで伸ばしたレイの長さ\n    hit = false;\n    vec3 far = vec3(0.6, 0.7, 0.9) * 0.1; // 遠景のフォグの色\n    vec3 ID; // リングのID\n    \n    for(int i = 0; i < 100; i++) {\n        float d = map(ro + t * rd, ID);\n        if(abs(d) < 0.001) {\n            hit = true;\n            break;\n        }\n        if(t > 1e3) {\n            return far;\n        }\n        t += d * 0.75;\n    }\n      Q(ro.xy);\n    ro += t * rd; // レイをオブジェクトの表面まで伸ばす\n       ro.xz*=rotate2D(iTime*0.5);\n    vec3 albedo = calcColor(ro, ID); // アルベド\n    albedo.xz*=rotate2D(iTime*0.5);\n    vec3 n = calcNormal(ro); // 法線ベクトル\n      n.xz*=rotate2D(iTime*0.5);\n    vec3 ld = normalize(vec3(2, 5, -1)); // 平行光源の向き\n          ld.xz*=rotate2D(iTime*0.5);\n    float diff = max(dot(n, ld), 0.); // 直接光による拡散反射\n    float spec = pow(max(dot(reflect(ld, n), rd), 0.), 20.); // 直接光による鏡面反射\n    float invFog = exp(-t * t * 0.000); // フォグ\n  \n    //float lp = pow(sin(reTime * 2. + h * PI2) * 0.5 + 0.5, 1000.) * 300.;\n    float lp = ro.y ;\n    col += albedo * (mix(diff, spec, 0.95) * (5. + lp) + 0.01);\n    col = mix(far, col, invFog);\n    \n    vec3 ref = reflect(rd, n);\n    col *= refAtt;\n    \n    refAtt *= albedo * fresnelSchlick(0.8, dot(ref, n)) * invFog; // 反射の減衰率を更新\n    \n    ro += 0.01 * n;\n    rd = ref;\n    \n    return col;\n}\n\n// 範囲[-1, 1.]の間で等間隔にn個の値を取る滑らかな階段状のノイズ\nfloat stepNoise(float x, float n) {\n    const float factor = 0.2;\n    float i = floor(x);\n    float f = x - i;\n    float u = smoothstep(0.5 - factor, 0.5 + factor, f);\n    float res = mix(floor(hash(i) * n), floor(hash(i + 1.) * n), u);\n    res /= (n - 1.) * 0.5;\n    return res - 1.;\n}\n\n// ルーマ（色をグレースケールに変換）\nfloat luma(vec3 col) {\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\n// 三角波\nfloat triWave(float x) {\n    //x -= 0.5;\n    //x *= 0.5;\n    float res = abs(fract(x) - 0.5) - 0.25;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 画面上の座標を正規化\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * 0.5;\n    \n    vec3 col = vec3(0); // 色\n    \n\n\n    //reTime = Time + triWave(Time * 1. + 0.5) * 0.9;\n    \n    vec3 ro = vec3(0, 4, 3); // カメラの位置(レイの原点)\n\n    vec3 ta = vec3(0); // カメラのターゲットの座標\n\n    vec3 dir = ta - ro; // カメラの向き\n    float fov = 60.; // 視野角\n \n    vec3 rd = rayDir(uv, dir, fov); // レイの向き\n    \n    bool hit = false;\n    vec3 refAtt = vec3(1); // 反射の減衰率\n    for(int i = 0; i < 3; i++) {\n        col += raymarch(ro, rd, hit, refAtt);\n        if(!hit) {\n            break;\n        }\n    }\n    \n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n    \n    // 口径食（vignetting）\n    vec2 p = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16. * p.x * p.y * (1. - p.x) * (1. - p.y), 0.5);\n    \n    // RGBずらし（色収差）\n    float lu = luma(col);\n    vec2 dis = (p - 0.5) * 0.05;\n\n    \n    fragColor = vec4(col, lu);\n}","name":"Image","description":"","type":"image"}]}