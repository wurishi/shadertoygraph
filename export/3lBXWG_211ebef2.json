{"ver":"0.1","info":{"id":"3lBXWG","date":"1566943354","viewed":335,"name":"Planet Hoon","username":"mattnewport","description":"Procedural planet: trying for something like ISS shots where city lights visible on dark side [url]https://i.ytimg.com/vi/WMZQoGcHQfY/maxresdefault_live.jpg[/url] Inspiration: https://www.shadertoy.com/view/4sf3Rn and https://www.shadertoy.com/view/lsX3z4","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash2d( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noise2dd( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    vec2 ga = hash2d( i + vec2(0.0,0.0) );\n    vec2 gb = hash2d( i + vec2(1.0,0.0) );\n    vec2 gc = hash2d( i + vec2(0.0,1.0) );\n    vec2 gd = hash2d( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nvec3 fbm2dd(vec2 p)\n{\n    float w = 0.66;\n    vec3 acc = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 6; ++i)\n    {\n        acc += noise2dd(p) * w;\n        w *= 0.5;\n        p *= 2.0;\n    }\n    return acc;\n}\n\nfloat length2(vec2 p) { return dot(p, p); }\n\nfloat worley(vec2 p) {\n\tfloat d = 1e30;\n\tfor (int xo = -1; xo <= 1; ++xo)\n\tfor (int yo = -1; yo <= 1; ++yo) {\n\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\td = min(d, length2(p - tp - hash2d(tp)));\n\t}\n\treturn 3.*pow(2.718, -4.*abs(2.*d - 1.));\n}\n\nfloat fworley(vec2 p) {\n    float off = 2.5;\n    float r = 1.0;\n    for (int i = 0; i < 6; ++i)\n    {\n        r *= worley(p + off);\n        p *= 2.0;\n        off *= 0.5;\n        off += 1.173;\n    }\n    return sqrt(sqrt(sqrt(r)));\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nvec3 gainv(vec3 x, float k)\n{\n    return vec3(gain(x.x, k), gain(x.y, k), gain(x.z, k));\n}\n\nvec3 lerpv(vec3 x, vec3 y, float t)\n{\n    return mix(x, y, t);\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 col(float x, float y)\n{\n    float xt = (x - 0.5) * 2.0;\n    float yt = (y - 0.5) * 2.0;\n    vec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 rd = normalize(vec3(xt, yt, -2.0));\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - 1.0;\n    float h = b * b - c;\n    if (h > 0.0)\n    {\n        float t = -b - sqrt(h);\n        vec3 pos = ro + rd * t;\n        vec3 n = pos;\n        float dif = max(n.x * 2.0 + n.z, 0.0);\n        float zlus1 = n.z + 1.0;\n        vec2 nc = ((n.xy / zlus1) + vec2(1.0, 1.0)) * 3.0;\n        vec3 nois = fbm2dd(nc);\n        float wateramt = 0.5;\n        float wateramtv = 2.0 * wateramt - 1.0;\n        float albt = smoothstep(wateramtv, wateramtv + 0.01, nois.x);\n        float nv = saturate(nois.x);\n        vec3 alb = lerpv(vec3(0.05, 0.27, 0.44), lerpv(vec3(0.4, 0.45, 0.35), vec3(0.3, 0.2, 0.1), nv), albt);\n        float spe = saturate(dot(n, normalize(vec3(0.4, -0.3, 1.0))));\n        float spev = pow(spe, 64.0) * (1.0 - albt);\n        float fwor = fworley(nc);\n        float city = pow(fwor, 2.5);\n        float cityamt = smoothstep(0.0, dif, 0.2) * albt;\n\t\tvec3 emm = max(vec3(city * vec3(1.8, 1.8*city, 0.5)), 0.0);\n        \n        float cloud = gain(smoothstep(-0.15, 0.3, fbm2dd(nc + vec2(3.7, 9.6)).x), 1.5);\n        vec3 albc = lerpv(alb, vec3(1.2), cloud);\n        vec3 lit = albc * (0.08 + dif * 0.75) + spev + emm * cityamt;\n        float fre = 1.0-clamp(n.z,0.0,1.0);\n        lit += mix( vec3(0.20,0.10,0.05), vec3(0.4,0.7,1.0), dif )*0.2*fre;\n        lit += mix( vec3(0.02,0.10,0.20), vec3(0.7,0.9,1.0), dif )*fre*fre*fre;\n        \n        return lit;\n    }\n    else\n    {\n        return vec3(0.1, 0.1, 0.1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Output to screen\n    fragColor = vec4(col(uv.x, 1.0 - uv.y), 1.0);\n}","name":"Image","description":"","type":"image"}]}