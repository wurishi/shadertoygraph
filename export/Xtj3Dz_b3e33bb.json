{"ver":"0.1","info":{"id":"Xtj3Dz","date":"1428302404","viewed":369,"name":"Fractale_","username":"shezard","description":"From http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.14\n#define TWO_PI 7.28\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n    \nfloat noise(in vec2 uv) {\n\treturn sin(1.5*uv.x)*sin(1.5*uv.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm(vec2 uv) {\n    float f = 0.0;\n    f += 0.5000*noise(uv); uv = m*uv*2.02;\n    f += 0.2500*noise(uv); uv = m*uv*2.03;\n    f += 0.1250*noise(uv); uv = m*uv*2.01;\n    f += 0.0625*noise(uv);\n    return f/0.9375;\n}\n\nfloat fbm2(in vec2 uv) {\n   vec2 p = vec2(fbm(uv + vec2(0.0,0.0)),\n                 fbm(uv + vec2(5.2,1.3)));\n\n   return fbm(uv + 4.0*p);\n}\n\nfloat rand(in vec2 uv) {\n    return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 add(in vec2 a, in vec2 b) {\n \n    int mat = 0;\n    if(a.x < b.x) {\n      mat = int(a.y);\n    } else {\n      mat = int(b.y);\n    }\n    \n    return vec2(min(a.x,b.x), mat);\n}\n\nvec2 sub(in vec2 a, in vec2 b) {\n    \n    int mat = 0;\n    if(a.x < b.x) {\n      mat = int(b.y);\n    } else {\n      mat = int(a.y);\n    }\n    \n    return vec2(max(a.x, b.x),mat);\n}\n\nvec3 rep(in vec3 p, in vec3 c) {\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec2 rotate(in vec2 p, in float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 torus(in vec3 p, in vec2 t, in int mat) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return vec2(length(q)-t.y, mat);\n}\n\nvec2 sphere(in vec3 p, in float r, in int mat) {\n    return vec2(length(p) - r, mat);\n}\n\nvec2 plane(in vec3 p, in vec4 n, in int mat) {\n  return vec2(dot(p,n.xyz) + n.w, mat);\n}\n\nvec2 cylinder(in vec3 p, in vec3 c, in int mat) {\n  return vec2(length(p.xz-c.xy)-c.z, mat);\n}\n\nvec2 box(in vec3 p, in vec3 b, in int mat) {\n  return vec2(length(max(abs(p)-b,0.0)), mat);\n}\n\nvec2 fractal(in vec3 pos) {\n    \n    const int iterations = 30;\n    const float bailout = 15.0;\n          float power = 7.;\n    \n    vec3 z = pos;\n    float dr = 1.5;\n    float r = 0.0;\n    \n    int step = 0;\n    \n    for (int i = 0; i < iterations ; i++) {\n    \tr = length(z);\n   \t\tif (r > bailout) break;\n        \n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        \n        dr =  pow( r, power-1.0)*power*dr + 1.0;\n        float zr = pow( r,power);\n        theta = theta*power;\n        phi = phi*power;\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z+=pos;\n        step++;\n    }\n    \n    return vec2(0.5*log(r)*r/dr, float(step) / float(iterations));\n}\n\nfloat map(in vec3 p, inout float mat) {\n   \n   p *= 1.0 + .25 * cos(iTime*.25);\n    \n   vec2 f  = fractal(p);\n    \n   mat = f.y;\n    \n   return f.x;\n}\n\nmat3 setLookAt(in vec3 ro, in vec3 ta,in float cr) {\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // camera\t\n    vec3 ro = vec3(\n        -2.5*cos(.25*iTime),\n        cos(.5*iTime),\n        -2.5*sin(.25*iTime)\n   \t);\n    \n    vec3 ta = vec3(0.0,0.0,0.0);\n    float roll = 0.0;\n\n    // camera tx\n    mat3 ca = setLookAt( ro, ta, roll );\n    vec3 rd = normalize( ca * vec3(p.xy,1.75) );\n\n    float t = 0.001;  // Near\n    float tmax = 5.0; // Far\n   \t\n    float h = 0.001;\n    float hmax = 0.001;\n    \n    float mat = 0.0;\n    \n    vec3 c = vec3(0.0);\n    vec3 ao = vec3(0.0);\n    \n    const int steps = 100;\n    for(int i = 0 ; i < steps ; i++) {\n        \n        if(h < hmax || t > tmax ) {\n        \tao = vec3(1.0) - float(i)/float(steps);\n            break;\n        }\n        \n        h = map(ro + t *rd, mat);\n        t += h;\n    }\n    \n    if(t < tmax) {\n        vec3 pos = ro+rd*t;\n      \t\n        c = vec3(1.0,0.4,0.1);\n        \n        c -= ao*.25;\n        \n        c = c*pow(c.x,1.5);\n        \n        c = rgb2hsv(c);\n        \n        c.x += iTime * .05 + mat;\n        c.y = 1.0;\n        c.z *= 1.0 + mat;\n        \n        c = hsv2rgb(c);\n        \n    } else {\n        c = vec3(0.0);\n    }\n    \n\tfragColor = vec4(c,1.0);\n}","name":"","description":"","type":"image"}]}