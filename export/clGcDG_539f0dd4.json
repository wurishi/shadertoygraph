{"ver":"0.1","info":{"id":"clGcDG","date":"1700584600","viewed":248,"name":"Rain in the gallery","username":"Longinus","description":"Rain inside the gallery. You can drag camera around.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["water","rain","drops","gallery"],"hasliked":0,"parentid":"slGGW1","parentname":"Learn water generation"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI \t\t\t3.14159265359\n#define FOV \t\t80.0\n\n\n// borrowed IQs hash\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 hash33( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat s_rain = 4.;\n\nfloat flexTime(){\n    return 4.0*(iTime+2.0*sin(iTime*.5));\n}\n\nvec4 getDrop(in vec3 p){\n    vec3 s = vec3(s_rain);\n    float dropSize =0.08;\n    vec3 rainFactor =vec3(0,flexTime()*s.x,0);\n    vec3 pp = p+rainFactor;\n    vec3 cell0 = s*round(pp/s);\n    vec3 h =vec3(hash33(uvec3(-(-cell0.xyz*10000.-10000000.))));\n    return vec4(pp- cell0+((h.xyz-0.5)*(s-dropSize)),dropSize);\n}\n\nfloat waves(in vec3 p){\n    float sum =0.;\n    for(int i=0; i<2; i++){\n        vec3 h2 = hash33(uvec3(7+i));\n        vec3 pp= p*2.0;\n        float t = flexTime()*3.;\n        vec3 h = hash33(uvec3(3+i))*0.5+0.5;\n        float a = h2.x*PI*2.;\n        sum += sin((h.z+t+pp.x)*h2.y*sin(a)+(pp.z+h.x+t)*cos(a)*h2.y+t*h.y);\n    }\n    return sum;\n}\n\nfloat calculateDropWaves(in vec3 p){\n    float sum = 0.;\n    for(int i=-1; i<2;i++){\n        for(int j=-1; j<2; j++){\n            for(int k=-1; k<1; k++){     \n                vec4 drop =getDrop(p+vec3(i,k,j)*vec3(s_rain));\n                drop.xyz-=vec3(i,k,j)*vec3(s_rain);\n                if(drop.y > 0.0){\n                    float rippleSize =s_rain;\n                    float dist =max(drop.y-length(drop.xz),0.0);\n                    float size =min(dist, rippleSize)/rippleSize;\n                    float factor = min(max(0.,(rippleSize-drop.y))/rippleSize,1.);\n                    sum+=factor*factor*(size*size)*0.5*sin(5.0*dist);\n                }\n            }\n        }\n    }\n    return sum+waves(p)*0.01;\n}\n\n\nfloat rain( vec3 p){\n    vec4 drop = getDrop(p);\n    return length(drop.xyz)-drop.w;\n}\n\nvec4 skyColor(in vec3 ro, in vec3 rd){\n    return texture(iChannel0, normalize(rd));\n}\n\nfloat water_level = 1.0;\n\nvec2 map_the_world(in vec3 p)\n{\n    float water_0 = p.y>0.5?1e20:sdPlane(p, vec3(0,1,0), water_level)+2.5*calculateDropWaves(p);\n    float rain_0 = rain(p);\n    return (rain_0<water_0)?vec2(2,rain_0):vec2(1,water_0);\n}\n\n\nvec3 calculate_normal(in vec3 p, in bool ignore_water)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    float gradient_x = map_the_world(p + small_step.xyy).y - map_the_world(p - small_step.xyy).y;\n    float gradient_y = map_the_world(p + small_step.yxy).y - map_the_world(p - small_step.yxy).y;\n    float gradient_z = map_the_world(p + small_step.yyx).y - map_the_world(p - small_step.yyx).y;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\n\nvec4 ray_march(in vec3 ro, in vec3 rd, in bool ignore_water)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 256;\n    const float MINIMUM_HIT_DISTANCE = 0.01;\n    const float MAXIMUM_TRACE_DISTANCE = 300.0;\n    float watereffect = ignore_water?0.25:0.;\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled * rd;\n        vec2 distance_to_closest = map_the_world(current_position);\n        if (distance_to_closest.y < MINIMUM_HIT_DISTANCE ) \n        {\n            vec3 normal = calculate_normal(current_position, ignore_water);\n            vec3 light_position = 10000.0*vec3(-0.5,-1.,-1.)+ro;\n            if(distance_to_closest.x==1.0 && !ignore_water){   // reflect from surface of water\n                vec3 rrd =reflect(rd, normal);\n                return vec4(rrd,-total_distance_traveled);\n            }else if(distance_to_closest.x==2.0 && !ignore_water){ // refract from rain drops\n                ro=ro+rd*total_distance_traveled;\n                rd = (1./1.33)*(cross(normal,cross(-normal,rd))-normal*sqrt(1.-pow(1./1.33,2.0)*dot(cross(normal,rd),cross(normal,rd))));\n                continue;\n            }\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE ||\n            current_position.z>40.0 ||\n            current_position.z<-40.0 ||\n            current_position.x>160.0 ||\n            current_position.x<-300.0)\n            {\n                break;\n            }\n        total_distance_traveled += distance_to_closest.y;\n    }\n    \n    return mix(vec4(skyColor(ro,rd).xyz,1.0),vec4(0.0,0.0,0.1,1.0),watereffect);\n}\n\nvec4 samplePixel(in vec2 fragCoord){\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/min (iResolution.x, iResolution.y) * tan (radians (FOV)/2.0);\n\n    float a = iMouse.x/float(iResolution.x)*PI*2.0+iTime*0.1;\n    float p = iMouse.y/float(iResolution.y)*PI*2.0;\n\tvec3 up = vec3 (0.0, 1.0, 0.0);\t\t\t// up \n    vec3 fw = vec3 (sin(a), 0.0, -cos(a));\t\t\t// forward\n\tvec3 lf = cross (up, fw); \t\t\t\t\t// left\n\t\n\tvec3 ro = -fw * 5.0 + vec3 (0.0, 5.0, 0.0); // ray origin\n\tvec3 rd = normalize (uv.x * lf + uv.y * up + fw) ; \t\t// ray direction\n    \n    vec4 march = ray_march(ro,rd, false);\n    if(march.w<0.){\n        march = ray_march(ro+normalize(rd)*-march.w,march.xyz, true);\n    }\n    \n    return (march.w<30.)?vec4(march.xyz,1.0):skyColor(ro,rd);\n}\n\nvec4 superSamplePixel(in vec2 fragCoord){\n    vec2 step = vec2(.5);\n    vec4 sum=vec4(0);\n    for(int i=0;i<2;i++){\n        for(int j=0; j<2;j++){\n            sum+=samplePixel(fragCoord+vec2(i,j)*step);\n        }\n    }\n    return sum/4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    fragColor = samplePixel(fragCoord);\n}","name":"Image","description":"","type":"image"}]}