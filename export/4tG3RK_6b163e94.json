{"ver":"0.1","info":{"id":"4tG3RK","date":"1475391686","viewed":199,"name":"Sphere skeleton 2","username":"deadmanswitch","description":"Just experimenting...","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sphere","folding","tetrahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOV 60.0\n\n#define MAX_STEP   16\n#define MAX_STEP_F 16.0\n\nconst float infinity = 1.0/0.000000000000001;\nconst float PI = asin(1.0)*2.0;\n\n\nfloat max4(in vec4 v4) {\n    return max( max(v4.x, v4.y), max(v4.z, v4.w) );\n}\n\n\n// rotations\nvec3 rotateX(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0],\n        vec[1]*cos(rad) - vec[2]*sin(rad),\n        vec[1]*sin(rad) + vec[2]*cos(rad)\n    );\n        \n}\n\nvec3 rotateY(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[2]*sin(rad) + vec[0]*cos(rad),\n        vec[1],\n        vec[2]*cos(rad) - vec[0]*sin(rad)\n    );\n}\n\nvec3 rotateZ(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0]*cos(rad) - vec[1]*sin(rad),\n        vec[0]*sin(rad) + vec[1]*cos(rad),\n        vec[2]\n    );\n}\n\n\n/***************\n\nTetrahedron start\n\n***************/\n\n// normals\nconst vec3 norm1 = vec3(\n\t0.4714045226573944,\n    0.3333333432674408,\n    -0.8164966106414795\n);\nconst vec3 norm2 = vec3(\n\t-0.9428090453147888,\n    0.3333333432674408,\n    0.0\n);\nconst vec3 norm3 = vec3(\n\t0.4714045524597168,\n    0.3333333432674408,\n    0.8164966106414795\n);\n\n// points\nconst vec3 point0 = vec3(0.0,1.0,0.0);\nconst vec3 point1 = vec3(0.9428090453147888,-0.3333333432674408,0);\nconst vec3 point2 = vec3(-0.4714045226573944,-0.3333333432674408,-0.8164966106414795);\nconst vec3 point3 = vec3(-0.4714045226573944,-0.3333333432674408,0.8164966106414795);\n\nfloat planedist(in vec3 point, in vec3 norm) {\n\n    return dot(point, norm) - norm.y;\n\n}\n\nconst float size = 3.0;\nfloat tet(in vec3 point) {\n    \n    point = point/size;\n\n    // subtracting the planes from a sphere\n    float dist = max4(vec4(\n        planedist(point, norm1),\n        planedist(point, norm2),\n        planedist(point, norm3),\n        -(1.0/3.0+point.y)\n    ));\n\n    // the sphere has a `size` radius\n    dist = max(length(point)-1.0, dist)*size;\n\n    return dist;\n    \n}\n\n/***************\n\nTetrahedron end\n\n***************/\n\nconst mat2 foldb = mat2(0.7071067690849304, -0.7071067690849304, 0.7071067690849304, 0.7071067690849304);\nconst mat2 foldi = mat2(0.7071067690849304, 0.7071067690849304, -0.7071067690849304, 0.7071067690849304);\n\nvoid fold(inout vec2 vec) {\n    vec = (abs(vec*foldb))*foldi;\n}\n\nfloat DE(in vec3 pos) {\n    \n    float rot = (iTime*0.25)*PI*2.0;\n    \n    pos = rotateX(pos, rot);\n    pos = rotateY(pos, rot);\n    pos = rotateZ(pos, rot*0.5);\n    \n    // folding\n    for(int i=0; i<16; i++) {\n        \n        fold(pos.xy);\n        //if(pos.x+pos.y<0.0){pos.xy=-pos.yx;}\n        //pos.xy = mix(pos.xy, -pos.yx, float(pos.x+pos.y<0.0));\n        \n        pos = rotateY(pos,  0.9+cos(iTime)*0.1);\n        \n        fold(pos.xz);\n        //if(pos.x+pos.z<0.0){pos.xz=-pos.zx;}\n        //pos.xz = mix(pos.xz, -pos.zx, float(pos.x+pos.z<0.0));\n        \n        pos = rotateZ(pos, -0.6-cos(iTime)*0.1);\n        \n        fold(pos.yz);\n        //if(pos.y+pos.z<0.0){pos.yz=-pos.zy;}\n        //pos.yz = mix(pos.yz, -pos.zy, float(pos.y+pos.z<0.0));\n        \n        \n    }\n    \n    return min(max(\n        tet(pos),\n        -(length(pos)-1.7)\n    ), length(pos)-1.6);\n}\n\nconst vec3 shadowColor = vec3(0.0, 0.0, 0.25);\nconst vec3 backColor = vec3(0.5, 0.4, 0.5);\nconst vec3 oColor = vec3(0.25, 0.9, 0.25);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n\tvec2 view = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    float a = tan(FOV * (PI/180.0) / 2.0);\n    vec2 ab = vec2(a * aspect, a);\n    \n    // the start point, and the direction of the ray\n    vec3 dir = normalize(vec3(ab*view, -1.0));\n    vec3 point = vec3(0.0, 0.0, 5.0+sin(iTime)*1.0);\n    \n    // ray-march\n    float closest = infinity;\n\n    for(int i = 0; i<MAX_STEP; i++) {\n\n        vec3 pos = point;\n\n        float dist = DE(pos);\n\n        if(dist < 0.0025) {\n            fragColor = vec4(mix(\n                oColor,\n                shadowColor,\n                sqrt(float(i)/MAX_STEP_F)\n            ), 1.0);\n            return;\n        }\n\n        closest = min(closest, dist);\n\n        point += dir*dist;\n\n    }\n\n    // background shading\n    fragColor = vec4(mix(\n        shadowColor,\n        backColor,\n        sqrt(clamp(closest/2.0, 0.0, 1.0))\n    ), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}