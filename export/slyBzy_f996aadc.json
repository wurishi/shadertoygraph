{"ver":"0.1","info":{"id":"slyBzy","date":"1664740573","viewed":178,"name":"non-chiral interlocked bricks","username":"jt","description":"Symmetric non-chiral space filling with cuboids (bricks) so that no layer could be moved along either coordinate.\nBricks visualized colored or grey, \"left-over\" cubes shown in white. Animation shows different parts of the structure.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["grid","cube","voxel","honeycomb","dda","tiling","tesselation","skew","regular","spacefilling","interlocked","bcc","apeirohedron","nonchiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/slyBzy non-chiral interlocked bricks, 2022 by Jakob Thomsen\n// based on https://www.shadertoy.com/view/7dK3D3 Branchless Voxel Raycasting Tex\n// using DDA from https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), based on http://lodev.org/cgtutor/raycasting.html\n// 3d-texture on voxels addon by jt\n\n// Symmetric non-chiral space filling with cuboids (bricks),\n// so that no layer could be moved along either coordinate.\n// (This structure refines https://www.shadertoy.com/view/styfRG interlocked grids.)\n// Animation shows different parts of the structure.\n// Bricks visualized colored or grey, \"left-over\" cubes shown in white.\n\n// Here non-chiral is supposed to mean that this structure\n// does not have a \"preferred\" diagonal around which it is MORE symmetric (rotationally)\n// (contrary to e.g. https://www.shadertoy.com/view/sttBDl stacked pipes).\n\n// It appears that for a maximally symmetric structure \"left-over\" cubes cannot be avoided.\n// Also when trying to simplify this structure either symmetry gets lost or bricks become cubes.\n// The only smaller structure with similar properties I could find is\n// https://www.shadertoy.com/view/stVfDw interlocked cube tori\n\n// tags: grid, cube, voxel, honeycomb, dda, tiling, tesselation, spacefilling, interlocked, bcc, regular, skew, apeirohedron, non-chiral\n\n#define REPETITIONS 2u\n\n#define BLACK 0u\n#define RED (BLACK + 1u)\n#define GREEN (RED + 1u)\n#define YELLOW (GREEN + 1u)\n#define BLUE (YELLOW + 1u)\n#define MAGENTA (BLUE + 1u)\n#define CYAN (MAGENTA + 1u)\n#define WHITE (CYAN + 1u)\n#define COLORS (WHITE + 1u)\n\n#define GREY COLORS\n\nvec3 palette(uint i)\n{\n    return i == GREY ? vec3(0.5) : vec3((i >> 0u) & 1u, (i >> 1u) & 1u, (i >> 2u) & 1u);\n}\n\nbool node(uvec3 l) // local coordinates\n{\n    if(l.y == 1u && l.z == 1u && l.x == 1u) return true;\n\n    return false;\n}\n\nbool beam(uvec3 l) // local coordinates\n{\n    if(l.y == 1u && l.z == 1u && l.x > 1u) return true;\n\n    return false;\n}\n\n// two half-patterns fit together to fill one cube exactly in a body-centred cubic (BCC) lattice pattern.\nuint half_pattern(ivec3 i, uint stage)\n{\n    stage = stage & 15u; // using bit-operators to avoid modulo-bugs on windows\n\n    //if(any(lessThan(i, ivec3(0)))) return 0u;\n    uvec3 l = uvec3(i) & 7u; // using bit-operators to avoid modulo-bugs on windows\n\n    if(l.x >= 4u) l.x = 7u - l.x; // mirror\n    if(l.y >= 4u) l.y = 7u - l.y; // mirror\n    if(l.z >= 4u) l.z = 7u - l.z; // mirror\n\n    uvec2 o = uvec2(0,1); // offset\n\n    if(node(l+o.yyy)) return WHITE;\n    if(stage >= 0u) if(node(l+o.xxx)) return WHITE;\n    if(stage >= 1u) if(node(l+o.yxx)) return GREY;\n    if(stage >= 2u) if(node(l+o.xyx)) return GREY;\n    if(stage >= 3u) if(node(l+o.xxy)) return GREY;\n\n    if(stage >= 4u) if(beam(l.xyz+o.yyy)) return RED;\n    if(stage >= 5u) if(beam(l.yzx+o.yyy)) return GREEN;\n    if(stage >= 6u) if(beam(l.zxy+o.yyy)) return BLUE;\n    \n    if(stage >= 7u) if(beam(l.xyz+o.xxx)) return RED;\n    if(stage >= 8u) if(beam(l.yzx+o.xxx)) return GREEN;\n    if(stage >= 9u) if(beam(l.zxy+o.xxx)) return BLUE;\n    \n    if(stage >= 10u) if(beam(l.xyz+o.xxy)) return CYAN;\n    if(stage >= 11u) if(beam(l.yzx+o.xxy)) return MAGENTA;\n    if(stage >= 12u) if(beam(l.zxy+o.xxy)) return YELLOW;\n\n    if(stage >= 13u) if(beam(l.xyz+o.xyx)) return CYAN;\n    if(stage >= 14u) if(beam(l.yzx+o.xyx)) return MAGENTA;\n    if(stage >= 15u) if(beam(l.zxy+o.xyx)) return YELLOW;\n\n    return 0u;\n}\n\n// Fills one unit cell (composed of 6^3 voxels).\nuint pattern(ivec3 i, uint stage)\n{\n    // NOTE: using bit-operators rather than modulo because of % bugs on windows\n\n    stage = stage & 31u;\n\n    {\n        uint c = half_pattern(i, stage);\n        if(c > 0u)\n            return c;\n    }\n\n    if((stage >> 4u) != 0u)\n    {\n        uint c = half_pattern(i+4, stage);\n        if(c > 0u)\n            return c;\n    }\n\n    return 0u;\n}\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\nfloat sdSphere(vec3 p, float d)\n{ \n    return length(p) - d;\n} \n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nbool getVoxel(ivec3 c, uint stage)\n{\n    if(any(greaterThan(abs(c), ivec3(REPETITIONS * 6u)))) return false;\n    return pattern(c, stage) > 0u;\n}\n\n// \"The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS (24u * (1u << REPETITIONS))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint stage = uint(floor(iTime / 2.0)) + 15u/*for interesting preview image*/;\n\n    vec2 screenPos = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = vec3(screenPos.x, screenPos.y, 2.0);\n    vec3 rayPos = vec3(0.0, 0.0, -float(REPETITIONS * 20u));\n\n    float mx = 2.0 * PI * float(-iMouse.x) / float(iResolution.x);\n    float my = PI * float(-iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * PI * fract(iTime * 0.025) + (PI/4.0)/*for interesting preview image*/;\n    my = (iMouse.y > 10.0) ? my : PI / 2.0 + (PI/4.0)/*for interesting preview image*/;\n\n    mat2 S = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    rayPos.yz = S * rayPos.yz;\n    rayDir.yz = S * rayDir.yz;\n\n    mat2 R = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    rayPos.xy = R * rayPos.xy;\n    rayDir.xy = R * rayDir.xy;\n    \n    rayDir = normalize(rayDir);\n\n    ivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n    vec3 color = vec3(1.0);\n    vec3 sideDist;\n    bvec3 mask;\n    // core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n    vec3 deltaDist;\n    {\n        deltaDist = 1.0 / abs(rayDir);\n        ivec3 rayStep = ivec3(sign(rayDir));\n        sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\n        for (uint i = 0u; i < MAX_RAY_STEPS; i++)\n        {\n            if (getVoxel(mapPos, stage)) break; // forked shader used continue here\n\n            //Thanks kzy for the suggestion!\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n            sideDist += vec3(mask) * deltaDist;\n            mapPos += ivec3(vec3(mask)) * rayStep;\n        }\n\n        color *= mask.x ? vec3(0.25) : mask.y ? vec3(0.5) : mask.z ? vec3(0.75) : vec3(0.0);\n    }\n\n    fragColor = vec4(0);\n    \n    if(any(greaterThan(abs(mapPos), ivec3(REPETITIONS * 6u))))\n        return;\n\n    color *= palette(pattern(mapPos, stage));\n\n    // jt's 3d-texture addon recovering distance & subvoxel intersection-position of ray \n    // as described in https://lodev.org/cgtutor/raycasting.html (see \"perpWallDist\" there)\n    //float d = (mask.x ? sideDist.x - deltaDist.x : mask.y ? sideDist.y - deltaDist.y : mask.z ? sideDist.z - deltaDist.z : 0.0) / length(rayDir);\n    //float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir); // rayDir not normalized\n    float d = length(vec3(mask) * (sideDist - deltaDist)); // rayDir normalized\n\n    vec3 dst = rayPos + rayDir * d;    \n\n    //color *= smoothstep(0.6,0.61, distance(dst, vec3(mapPos)+0.5));\n    color += 0.05*(1.0-smoothstep(0.6,0.61, distance(dst, vec3(mapPos)+0.5)));\n\n    vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n    //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n    color *= mix(fogcolor, color, exp(-d * d / 200.0)); // fog for depth impression & to suppress flickering\n\n    //fragColor = vec4(color, 1.0);\n\tfragColor = vec4(sqrt(color), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}