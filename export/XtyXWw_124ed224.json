{"ver":"0.1","info":{"id":"XtyXWw","date":"1484507125","viewed":263,"name":"OJ - Fibber 28, scene 1","username":"rammoskar","description":"Full demo: https://www.youtube.com/watch?v=kw5uLHZiRpY","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["3d","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus62( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length6(q)-t.y;\n}\n\n\nfloat smin( float a, float b)\n{\n\tfloat k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\n#define MAT_BLOCK 1.0\n#define MAT_S1_TORUS 12.0\n#define EPS 0.01\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\nvec2 unn(vec2 a, float dis, float mat)\n{\n\treturn a.x < dis ? a : vec2(dis, mat);\n}\n\n\n\nvec2 scene(vec3 p, vec3 rd)\n{\n\tfloat t = mod(iTime, 30.0);\n\tvec2 res = vec2(99999, -1);\n\tif (p.z > 23.0){\n\t\tvec3 s = vec3(30, 30, 30);\n\t\tvec3 q = mod(p - vec3(15, 15, 5), s)-0.5*s;\n\t\t\n\t\tres = vec2(sdTorus(q.xzy, vec2(4, 1)), MAT_S1_TORUS);\n\t}\n\t\n\t\n\tvec3 s = vec3(1);\n\tvec3 q = mod(p,s)-0.5*s;\n\tivec3 n = ivec3(floor(p / s));\n\tfloat dis = -sdCylinder(vec3(n.xzy), vec3(0.0, 0.0, 15.0));\n\tdis = min(dis, -sdBox(vec3(n), vec3(200.0)));\n\tif (dis < 0.0) {\n\t\tres = un(res, vec2(udRoundBox(q , vec3(0.3), 0.23), MAT_BLOCK));\n\t} else {\n\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\tfloat a = max(dis - 1.73, b + EPS);\n\t\tres = un(res, vec2(max(EPS, a), -1));\n\t}\n\t\n\treturn res;\n}\n\n\n\nvec3 getNormal(vec3 p, vec3 rd, vec3 ro)\n{\n    vec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = scene(p + ep.xyz, rd).x - scene(p - ep.xyz, rd).x;\n    normal.y = scene(p + ep.yxz, rd).x - scene(p - ep.yxz, rd).x;\n    normal.z = scene(p + ep.yzx, rd).x - scene(p - ep.yzx, rd).x;\n    return normalize(normal);\n}\n\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n\nfloat shadow(in vec3 ro, in vec3 rd, float mint, float maxt, float shadowAmbient)\n{\n    \n    float t = 0.1;\n    for(float _ = 0.0; _ == 0.0; _ += 0.0)\n    {\n        if (t >= maxt) {\n        \treturn 1.0;\n        }\n        float h = scene(ro + rd*t, rd).x;\n        if( h<0.01 )\n            return shadowAmbient;\n        t += h;\n    }\n    return 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 eye = vec3(0);\n\tvec3 light = vec3(0);\n\tvec3 tar = vec3(0);\n\tbool waterRefract = false;\n\tfloat lightInvSize = 0.5;\n\tfloat shadowAmbient = 0.3;\n\tfloat lightIntensity = 0.004;\n\tbool lightCollision = false;\n\tconst int jumps = 2;\n\tfloat refJumpDistance = 0.02;\n\tbool shadows = true;\n\tconst int imax = 600;\n\tfloat tmax = 800.0;\n\tvec3 skyColor = vec3(0);\n\tbool cubicDis = false;\n\tvec3 rollV = vec3(0, 1, 0);\n\t\n    float t = mod(iTime, 30.0);\n    eye = vec3(0.0, -7.0, t*0.4);\n    tar = eye + vec3(0.01*cos(t), 0.02*sin(t), 1.0 + 0.02*cos(t));\n    if(t < 5.0){\n        light = vec3(0.0, 0.0 + -7.0*smoothstep(0.0,4.0,t), -20.0 + 60.0*smoothstep(0.0, 4.0, t));\t\n    } else if (t < 20.0){\n        float r = 13.0*smoothstep(5.0, 15.0, t);\n        light = vec3(r*cos(t*2.0), -7.0 + 7.0*smoothstep(5.0,10.0,t)+ r*sin(t*2.0), 40.0);\n    } else if (t < 25.0){\n        float r = 13.0 - 13.0*smoothstep(20.0, 25.0, t);\n        light = vec3(r*cos(t*2.0), -7.0 + 7.0*smoothstep(5.0,10.0,t) + r*sin(t*2.0), 40.0);\n    } else {\n        lightCollision = true;\n        light = vec3(0.0,0.0, 40.0 + 70.0*smoothstep(25.0,30.0, t));\n    } \n\n    \n    \n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(rollV, dir)); //vec3(0, 1, 0)\n \tvec3 up = cross(dir, right);\n    \n    float u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (iResolution.y/iResolution.x); \n\n    vec3 color = skyColor;//vec3(0.3);\n      \n    t = 0.0;\n    //vec3 ro = eye + forward * 1 + right * u + up * v;\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\t\n\tfloat ref = 1.0;\n\tfloat lightAura = 0.0;\n    float breakVar = 0.0;\n\tfor(int j = 0; j < jumps; ++j)\n    {\n        if (breakVar > 0.5) {\n            break;\n        }\n    \tt = 0.0;\n    \t for(int i = 0; i < imax; ++i)\n   \t\t {\n             if (t >= tmax) {\n             \tbreak;\n             }\n\t        vec3 p = ro + rd * t;\n\t        vec2 dm = scene(p, rd);\n\t        float d = dm.x;\n\t        float m = dm.y;\n\t\t\t\n\t\t\t\n\t        if(d < EPS || i == imax || t >= tmax) //d < 0.001 \n\t        {\n\t        \tvec3 x0 = light;\n\t        \tvec3 x1 = ro;\n\t        \tvec3 x2 = ro + rd;\n\t        \tfloat ldis = pow(length(cross(x2 - x1, x1 - x0)),2.0) / pow( distance(x2, x1), 2.0); \n\t        \tvec3 normal = getNormal(p, rd, ro);\n\t\t\t\t\n\t\t\t\tvec3 invLight = normalize(light - p);\n\t        \tfloat diffuse = max(0.,dot(invLight, normal));\n\t        \tvec3 refrd = reflect(rd, normal);\n\t        \t\n\n\t        \tvec3 n = floor(p);\n\t\t\t\tvec3 c = vec3(0.5);\n\t\t\t\t\n\t\t\t\tif(m == MAT_BLOCK){\n\t\t\t\t\tc = vec3(sin(n.y) * 0.1 + 0.3, sin(n.y) * 0.1 +0.1, sin(n.y) * 0.1 + 0.1)*1.1;\t\t\t\t\n\t\t\t\t} else if (m == MAT_S1_TORUS) {\n\t\t\t\t\tc = vec3(0.4, 0.4, 0.4); //TODO  + 0.7 * vec3(texture(noiseP, vec2(p.xy * 0.1)));\n\t\t\t\t}\n\t\t\t\t\n\t        \t\n\t        \t\n                c = 0.7*c* (1.0 + diffuse);\n                if(shadows){\n                    c *= shadow(p, normalize(light - p), 0.1, length(light - p) - 1.0, shadowAmbient);\n                }\n                c += specular(normal, -invLight, normalize(eye - p), 70.0);\n\t        \t\n\t            \n\t            float dis = length(light - p);\n\t            float disFact = 1.0 / (1.0 + lightIntensity*dis*dis * (cubicDis ? dis : 1.0 ));\n\t            c *= disFact;\n\t\t\t\t\n\t\t\t\t\t        \t\n\t        \tfloat tl = -dot(x1 - x0, x2 - x1)/pow(distance(x2,x1),2.0);\n\t        \tif(tl > 0.0 && ((lightCollision && distance(eye, light) < distance(eye, p)) || !lightCollision)){\n\t        \t\tlightAura = max(lightAura, 1.0/(0.01 + lightInvSize*ldis));\n\t        \t}\n\t\t\t\t\n\t\t\t\tcolor = mix(color, c, ref);\n\t\t\t\t\n\t\t\t\t\n                rd = reflect(rd, normal);\n\n                ro = p + rd*refJumpDistance;\n\n\n\t\t\t\t\n\t           \n\t        \t\n\t        \n\t\t        ref = 0.0;\n\t        \t\n\t        \tif (ref <= 0.01) {\n\t\t\t\t\tbreakVar = 1.0;\t        \t\t\n\t        \t}\n\t           \tbreak;\n\t        }\n\t\n\t        t += d;\n    \t}\n    }\n    \n   \n    fragColor = vec4(color + vec3(lightAura),  1.0); \n}\n\n","name":"Image","description":"","type":"image"}]}