{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Created by vincent francois - cyanux/2014\n// Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License (CC BY-NC-ND 3.0)\n\n#define D 5.0\n\n//#define OBJECT(P) sdBoundedPlane(P, vec2(1.0, 0.5))\n//#define OBJECT(P) sdBox(P, vec3(1.5))\n//#define OBJECT(P) sdFastOctahedron(P, 0.7)\n//#define OBJECT(P) sdHexagon(P, 0.5)\n//#define OBJECT(P) sdInfiniteSquarePrism(P, vec2(0.5, 0.7))\n//#define OBJECT(P) sdInfiniteHexagonalPrism(P, vec2(0.5, 0.3))\n//#define OBJECT(P) sdInfiniteRhombusPrism(P, vec3(0.5))\n#define OBJECT(P) sdRhombicuboctahedron(P, vec3(0.7))\n//#define OBJECT(P) sdRhombus(P, 0.5)\n//#define OBJECT(P) sdSquarePyramid(P, 1.0)\n//#define OBJECT(P) sdTriangle(P, vec3(1.0))\n//#define OBJECT(P) sdTruncatedCuboctahedron(P, vec3(0.7))\n//#define OBJECT(P) sdTruncatedOctahedron(P, vec3(1.0))\n//#define OBJECT(P) sdSphere(P, 1.5)\n\nvec2 M;\n\nvec3 rX(vec3 v, float t) {\n\tfloat COS = cos(t);\n\tfloat SIN = sin(t);\n\treturn vec3(v.x,SIN*v.z+COS*v.y,COS*v.z-SIN*v.y);\n}\nvec3 rY(const vec3 v, const float t) {\n\tfloat COS = cos(t);\n\tfloat SIN = sin(t);\n\treturn vec3(COS*v.x-SIN*v.z, v.y, SIN*v.x+COS*v.z);\n}\n\nfloat sdBox(vec3 p, vec3 r) {\n\treturn\n\t\tmax(abs(p.x) - r.x, 0.0) +\n\t\tmax(abs(p.y) - r.y, 0.0) + \n\t\tmax(abs(p.z) - r.z, 0.0);\n}\nfloat sdBoundedPlane(vec3 p, vec2 r)\n{\n\treturn\n\t\tmax(\n\t\t\tabs(p.x) - r.x + abs(p.z) - r.y,\n\t\t\tabs(p.y - r.y));\n}\nfloat sdFastOctahedron(vec3 p, float r) {\n\treturn abs(p.x) - r + abs(p.y) - r + abs(p.z) - r;\n}\nfloat sdHexagon(vec3 p, float r) {\n\treturn\n\t\tmax(\n\t\t\tmax(abs(p.x) - r , 0.0) - r +\tmax(abs(p.y) -r , 0.0) - r,\n\t\t\tabs(p.z - r));\n}\nfloat sdInfiniteSquarePrism(vec3 p, vec2 r) {\n\treturn\n\t\tmax(\n\t\t\tmax(abs(p.x) - r.x, 0.0) + max(abs(p.y) - r.y, 0.0),\n\t\t\tabs(p.y) - r.y);\n}\nfloat sdInfiniteHexagonalPrism(vec3 p, vec2 r) {\n\treturn\n\t\tmax(abs(p.x) - r.x, 0.0) - 0.5 * r.x +\n\t\tmax(abs(p.y) - r.y, 0.0) - 0.5 * r.y;\n}\nfloat sdInfiniteRhombusPrism(vec3 p, vec3 r) {\n\treturn\n\t\tmin(\n\t\t\tmax(abs(p.x) - r.x, 0.0) +\n\t\t\tmax(abs(p.y) - r.y, 0.0) +\n\t\t\tmax(abs(p.z) - r.z, 0.0),\n\t\t\tabs(p.x) - r.x + abs(p.y) - r.y);\n}\nfloat sdRhombicuboctahedron(vec3 p, vec3 r) {\n\treturn\n\t\tmax(abs(p.x) - r.x, 0.0) - 0.5 * r.x +\n\t\tmax(abs(p.y) - r.y, 0.0) - 0.5 * r.y +\n\t\tmax(abs(p.z) - r.z, 0.0) - 0.5 * r.z;\n}\nfloat sdRhombus(vec3 p, float r) {\n\treturn\n\t\tmax(\n\t\t\tabs(p.x) - r + abs(p.y) - r + abs(p.z) - r,\n\t\t\tabs(p.x - r));\n}\nfloat sdSquarePyramid(vec3 p, float r) {\n\treturn \n\t\tmax(\n\t\t\tabs(p.x) - r + abs(p.y) - r + abs(p.z) - r,\n\t\t\tmax(r - p.y, 0.0) - 0.5);\n}\nfloat sdTriangle(vec3 p, vec3 r) {\n\treturn \n\t\tmax(\n\t\t\tmax(\n\t\t\t\tabs(p.x) - r.x + abs(p.y) - r.y + abs(p.z) - r.z,\n\t\t\t\tmax(r.y - p.y - 0.5, 0.0)),\n\t\t\tabs(p.x - r.x));\n\t\t\t\n}\nfloat sdTruncatedCuboctahedron(vec3 p, vec3 r) {\n\treturn\n\t\tmax(\n\t\t\tabs(p.x) - r.x + abs(p.y) - r.y + abs(p.z) - r.z - (abs(r.x)+abs(r.y)+abs(r.z)) * 0.33,\n\t\t\tmax(abs(p.x) - r.x, 0.0) - 0.5 * r.x + max(abs(p.y) - r.y, 0.0) - 0.5 * r.y + max(abs(p.z) - r.z, 0.0) - 0.5 * r.z\n\t\t);\t\t\t\n}\nfloat sdTruncatedOctahedron(vec3 p, vec3 r) {\n\treturn\n\t\tmax(\n\t\tabs(p.x) - r.x +\n\t\tabs(p.y) - r.y + \n\t\tabs(p.z) - r.z,\n\t\t\tmax(abs(p.x) - r.x, 0.0) - 0.5 * r.x + max(abs(p.y) - r.y,0.0) - 0.5 * r.y + max(abs(p.z) - r.z,0.0));\n}\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nbool is_dCM = false;\n\nfloat scene(vec3 p) {\n\tfloat dCM = -sdSphere(p, 16.0);\t\n\tp = rY(p, iTime);\t\n\tfloat dO = OBJECT(p);\n\tis_dCM = dCM < dO ? true : false;\n\treturn min(dO, dCM);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    M = 8.0 * (iMouse.xy / iResolution.xy - 0.5);\n\tfragColor = vec4(1.0);\n\t\n\tvec2 ar = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = ar * (fragCoord.xy / iResolution.xy - 0.5);\n\t\n\tvec3 ro = -rY(rX(vec3(0.0, 0.0, D) , M.y), M.x);\n\tvec3 co = ro;\n\tvec3 rd = normalize(rY(rX(vec3(uv, 1.0), M.y), M.x));\n\t\n\tvec3 g;\n\tfloat d;\n\t\n\tfor(float n = 0.0; n < 200.0; n++) {\n\t\td = scene(ro);\n\t\tif(d < 0.01)\n\t\t\tbreak;\n\t\tro += rd * d * 0.5;\n\t}\n\t\n\tif(is_dCM == true)\n\t{\n\t\tfragColor = texture(iChannel0, ro);\n\t\treturn;\n\t}\n\n\tg = vec3(\n\t\tOBJECT(rY(ro + vec3(0.0005, 0.0000, 0.0000), iTime)),\n\t\tOBJECT(rY(ro + vec3(0.0000, 0.0005, 0.0000), iTime)),\n\t\tOBJECT(rY(ro + vec3(0.0000, 0.0000, 0.0005), iTime)));\n\t\n\tg = normalize(g - d);\n\t\n\tfragColor = mix(mix(texture(iChannel0, reflect(rd, g)),texture(iChannel1, reflect(g, rd)), 0.4), vec4(0.0), 0.2);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dfXRf","date":"1404818779","viewed":326,"name":"SomethingMetallic7","username":"cyanux","description":"Improved engine. [Chrome & Firefox OK]","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""}}