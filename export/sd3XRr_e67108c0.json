{"ver":"0.1","info":{"id":"sd3XRr","date":"1632495921","viewed":84,"name":"NoiseTransformations","username":"xx3000","description":"Quick reference for noise implementations and transformations.\nLeft side is value noise, right side is Perlin.\n\nNoise is based on a white noise texture, but could easily be replaced by any random number generator.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NOISE_TYPE 2 // 0 - value, 1 - perlin, 2 - both\n#define ANIMATE_OCTAVES 0\n#define RIDGED 0  // 0 - disabled, 1 - enabled, 2 - animated\n#define BANDED 0 // 0 - disabled, 1 - enabled, 2- animated\n#define BAND_AMOUNT 7.0\n#define RADIAL_FALLOFF 0\n#define FALLOFF_DISTANCE 0.1\n#define DOMAIN_DISTORTION 1\n\n#define BASE_FREQUENCY 8\n#define OCTAVES 7\n\n\n#define SQRT2 1.41421356\n\nvec2 GetGradientVec(ivec2 tex)\n{\n    return (texelFetch(iChannel0, ivec2(mod(float(tex.x), 256.0), mod(float(tex.y), 256.0)), 0).xy - vec2(0.5)) * 2.0;\n}\n\nvec2 GetGradientVecNorm(ivec2 tex)\n{\n    return normalize(GetGradientVec(tex));\n}\n\nfloat JustLerp(vec4 vals, vec2 pos)\n{\n    return mix(mix(vals.x, vals.y, pos.x),mix(vals.z, vals.w, pos.x), pos.y);\n}\n\nfloat SmoothLerp(vec4 vals, vec2 pos)\n{\n    return mix(mix(vals.x, vals.y, smoothstep(0.0,1.0,pos.x)),mix(vals.z, vals.w, smoothstep(0.0,1.0,pos.x)), smoothstep(0.0,1.0,pos.y));\n}\n\nfloat value2D(ivec2 gridCoord,vec2 gridPos)\n{\n    float v1 = GetGradientVec(gridCoord + ivec2(0,0)).x;\n    float v2 = GetGradientVec(gridCoord + ivec2(1,0)).x;\n    float v3 = GetGradientVec(gridCoord + ivec2(0,1)).x;\n    float v4 = GetGradientVec(gridCoord + ivec2(1,1)).x;\n    return SmoothLerp(vec4(v1,v2,v3,v4), gridPos);\n}\n\nfloat perlin2D(ivec2 gridCoord,vec2 gridPos)\n{\n    vec2 grad1 = GetGradientVecNorm(gridCoord + ivec2(0,0));\n    vec2 grad2 = GetGradientVecNorm(gridCoord + ivec2(1,0));\n    vec2 grad3 = GetGradientVecNorm(gridCoord + ivec2(0,1));\n    vec2 grad4 = GetGradientVecNorm(gridCoord + ivec2(1,1));\n    \n    vec2 d1 = gridPos - vec2(0,0);\n    vec2 d2 = gridPos - vec2(1,0);\n    vec2 d3 = gridPos - vec2(0,1);\n    vec2 d4 = gridPos - vec2(1,1);\n    \n    float v1 = dot(grad1, d1);\n    float v2 = dot(grad2, d2);\n    float v3 = dot(grad3, d3);\n    float v4 = dot(grad4, d4);\n    \n    return SmoothLerp(vec4(v1,v2,v3,v4), gridPos) * SQRT2;\n}\n\nfloat noise2D(vec2 pos, int baseFrequency, int octaves, bool perlin)\n{\n    ivec2 texSize = textureSize(iChannel0, 0);\n    int gridSize = min(texSize.x - 1, baseFrequency * octaves);\n    vec2 gridCoordCont = pos * float(gridSize);\n    ivec2 gridCoord = ivec2(int(gridCoordCont.x), int(gridCoordCont.y));\n    vec2 gridPos = gridCoordCont - vec2(gridCoord.x, gridCoord.y);\n\n    \n    float valueNoise = value2D(gridCoord, gridPos);\n    float perlinNoise = perlin2D(gridCoord, gridPos);\n    \n    return (perlin ? perlinNoise : valueNoise );\n}\n\nfloat fbmNoise(vec2 p, int octaves, bool usePerlin, bool uNorm)\n{\n    int baseFreq = BASE_FREQUENCY;\n    float fractNoise = 0.0;\n    float normDiv = 0.0;\n    for(int i = 0; i < octaves; ++i)\n    {\n        float octave = pow(2.0,float(i));\n        fractNoise += noise2D(p, baseFreq, int(octave), usePerlin) * (1.0 / octave);\n        normDiv += 1.0 / octave;\n    }\n\n    fractNoise /= normDiv;\n    if(!uNorm)\n    {\n        fractNoise *= 2.0;\n        fractNoise -= 1.0;\n    }\n    return fractNoise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 normUV = fragCoord / iResolution.x;\n\n#if ANIMATE_OCTAVES == 1\n    int octaves = int(mix(1.1,OCTAVES + 0.9,(sin(iTime - 3.1415926 * 0.5) + 1.0) * 0.5));\n#else\n    int octaves = OCTAVES;\n#endif\n\n#if NOISE_TYPE == 2\n    bool usePerlin = uv.x > 0.5;\n#elif NOISE_TYPE == 1\n    bool usePerlin = true;\n#else\n    bool usePerlin = false;\n#endif\n    \n    float fractNoise = 0.0;\n    \n#if DOMAIN_DISTORTION == 1\n    vec2 posNoise = vec2(0,0);\n    posNoise.x = fbmNoise(normUV + vec2(0.05 * iTime, 0.0), octaves, usePerlin, false);\n    posNoise.y = fbmNoise(normUV +vec2(0.0,0.05 * iTime), octaves, usePerlin, false);\n    posNoise *= 0.01;\n    \n    fractNoise = fbmNoise(normUV + fbmNoise(normUV + fbmNoise(normUV + posNoise, octaves, usePerlin, false) * 0.1, octaves, usePerlin, false) * 0.05, octaves, usePerlin, true);\n#else\n    fractNoise = fbmNoise(normUV, octaves, usePerlin, true);\n#endif\n    float normNoise = (fractNoise + 1.0) * 0.5;\n    //normNoise = pow(normNoise, 7.0);\n\n    float outNoise = 0.0;\n    \n#if RIDGED == 2\n    float ridgedNoise = 1.0-abs(fractNoise);\n    outNoise = mix(normNoise, ridgedNoise, (sin(iTime* 0.5 - 3.1415926 * 0.5) + 1.0) * 0.5);\n#elif RIDGED == 1\n    outNoise = 1.0-abs(fractNoise);\n#else\n    outNoise = normNoise;\n#endif\n\n\n\n#if RADIAL_FALLOFF == 1\n    vec2 uv2 = fragCoord/iResolution.y;\n    uv2.x -= ((iResolution.x / iResolution.y) * 0.25);\n    float dist = length(vec2(0.5,0.5) - uv2 );   \n    outNoise = mix(0.0,outNoise, smoothstep(0.0, 1.0, 1.0 - min(1.0,max(0.0, dist - FALLOFF_DISTANCE))));  \n#endif\n\n#if BANDED == 1\n    outNoise = floor(outNoise * BAND_AMOUNT) / BAND_AMOUNT;\n#elif BANDED == 2\n    outNoise = mix(outNoise, floor(outNoise * BAND_AMOUNT) / BAND_AMOUNT, (sin(iTime* 0.25 - 3.1415926 * 0.5) + 1.0) * 0.5);\n#endif\n    \n    fragColor = vec4(outNoise ,outNoise,outNoise,1.0);\n}","name":"Image","description":"","type":"image"}]}