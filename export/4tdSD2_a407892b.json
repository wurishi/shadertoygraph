{"ver":"0.1","info":{"id":"4tdSD2","date":"1481744510","viewed":12687,"name":"Ancient Tech","username":"zackpudil","description":"Heavily inspired by this [url=https://www.shadertoy.com/view/XtX3zj]this[/url].  Using the Apollonian fractal instead.\n\nNote: Before going fullscreen comment out the #define AA line, it'll run much smoother.","likes":84,"published":1,"flags":0,"usePreview":1,"tags":["2d","fractal","kali"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Comment out this line before going full screen for a smoother experience.\n#define AA 7\n\nfloat time() { return iTime; }\nvec3 grey = vec3(0.21, 0.72, 0.07); // grey scale http://www.johndcook.com/blog/2009/08/24/algorithms-convert-color-grayscale/\nvec2 mouse() { return (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y; } // proper mouse coords.\n\nmat2 r(float th) {  vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); } // cosine-less rotation.\n\n// screen movement. Need this for formula and textures.  \nvoid animate(inout vec2 p) {\n    p *= r(time()*0.1 + mouse().x);\n\tp.y += time()*0.3;\n\tp.x += 3.0*cos(time()*0.1);\n}\n\n\n// fractal is drawn via orbit trapping.\nvec2 orb(vec2 p) {\n\tanimate(p);\n    \n\tfloat s = 1.0;\n    float m = 1.0;\n\t\n    // appolonian gasket fractal https://en.wikipedia.org/wiki/Apollonian_gasket\n    // with a bit of a twist.\n\tfor(int i = 0; i < 3; i++) {\n\t\tp = -1.0 + 2.0*fract(0.5 - 0.5*p);\n\t\tp *= 2.3/max(dot(p, p), 0.4);\n       \n\t\ts = min(s, abs(cos(p.x)));\n        m = min(m, abs((p.y)));\n\t}\n\t\n\treturn vec2(s, m);\n}\n\n\n// simple 2.5d bump mapping.\nvec3 bump(vec2 p, float e, float z) {\n\tvec2 r = vec2(e, 0.0); vec2 l = r.yx;\n\tvec3 g = vec3(orb(p + l).x - orb(p - l).x,\n\t\t\t   orb(p + r).x - orb(p - r).x,\n\t\t\t   z); //The \"z\" coordinate should be between -1.0, 0.0.  The closer to zero the more pop the geometry has.\n\t\n\treturn normalize(g);\n}\n\n// texture 2.5d bump mapping.\nvec3 texbump(sampler2D s, vec2 p, float e) {\n    vec2 r = vec2(e, 0.0); vec2 l = r.yx;\n    float ce = dot(grey, texture(s, p).rgb);\n    vec3 g = (grey*mat3(\n        texture(s, p - r).rgb,\n        texture(s, p - l).rgb,\n        vec3(ce)) - ce)/e;\n    \n    return normalize(g);\n}\n\nvec3 render(vec2 p) {\n\tvec3 rd = normalize(vec3(p, 1.0)); // \"ray direction. This also doubles as the light.\n\tvec3 sn = bump(p, 0.01, -0.7);\n\tvec3 col = vec3(0);\n    \n    vec2 ma = orb(p);\n    \n    float occ = ma.x;\n    float tm = pow(ma.y, 10.0); //texture mask\n   \n    animate(p);\n    \n   \tsn = normalize(sn + 0.2*mix(texbump(iChannel1, p, 0.001), texbump(iChannel0, p, 0.01), tm)); // add bump mapping for textures.\n    vec3 re = reflect(rd, sn);\n\t\n    // diffuse and specular.\n\tcol += pow(clamp(dot(-rd, sn), 0.0, 1.0), 10.0);\n\tcol += pow(clamp(dot(-rd, re), 0.0, 1.0), 32.0);\n    \n    col *= mix(texture(iChannel1, p).rgb, texture(iChannel0, p).rgb, tm); // material\n    col *= 3.0*occ; // ambient occlusion.\n    \n    // emission.\n    p += vec2(1, 0);\n    p = mod(p + 1.0, 2.0) - 1.0;\n    float mask = smoothstep(0.7, 0.71, length(p));\n    \n    col += vec3(4.1, 4.2, 0.2)*pow(abs(occ), 8.0)*mask\n        *smoothstep(-1.0, 1.0, cos(10.0*time() + 3.0*p.y));\n    \n    col += vec3(0.1, 5.0, 3.5)*pow(abs(occ), 9.0)*(1.0 - mask)\n        *smoothstep(-1.0, 1.0, cos(5.0*time()));\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 uv = fragCoord;\n\tvec2 of = vec2(0.3);\n    \n    // small bit of anti-aliasing.\n    #ifdef AA\n\tconst float aa = float(AA);\n    #else\n    const float aa = 1.0;\n    #endif\n\t\n\tvec3 col = render((-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y);\n\tfor(float i = 0.0; i < aa - 1.0; i++) {\n\t\t// super-sample around the center of the pixel.\n\t\tvec2 p = (-iResolution.xy + 2.0*(uv + of))/iResolution.y;\n\t\tcol += render(p);\n\t\tof *= r(3.14159/8.0);\n\t}\n\t\n\tcol /= aa;\n\t\n\t//col += 0.2*clamp(col, 0.0, 0.5);\n\tcol = pow(col, vec3(1.0/2.2));\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}