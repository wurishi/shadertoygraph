{"ver":"0.1","info":{"id":"dtV3Rm","date":"1683793970","viewed":161,"name":"Particle sim","username":"Nazlbit","description":"Particle sim","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["particles","sim"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.y;\n\n    vec2 mouse_pos = iMouse.xy / iResolution.y;\n    vec2 d = uv - mouse_pos;\n    bool lmb = iMouse.z > 0.0;\n    if(lmb && length(d) < radius)\n    {\n        fragColor = vec4(1.0);\n        return;\n    }\n\n    for(int i = 0; i < num_particles; ++i)\n    {\n        vec4 p = get_particle(iChannel0, iResolution.x, i);\n        \n        vec2 d = uv - p.xy;\n        \n        if(length(d) < radius)\n        {\n            fragColor = vec4(hsv2rgb(vec3(float(i) / sqrt(2.0), 1.0, 1.0)), 1.0);\n            return;\n        }\n    }\n\n    fragColor = vec4(0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int num_particles = 300;\nconst float radius = 0.009;\nconst float dt = 0.001;\nconst float G = 0.01;\nconst float friction_factor = 15.0;\nconst float collision_factor = 1000.0;\nconst float the_force_factor = 70.0;\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nfloat noise(vec2 uv, int frame, inout int seed)\n{\n    return random(uv + vec2(frame, seed++));\n}\n\nvec2 noise2(vec2 uv, int frame, inout int seed)\n{\n    return vec2(noise(uv, frame, seed), noise(uv, frame, seed));\n}\n\nvec4 sample_data_channel(sampler2D data_channel, ivec2 uv)\n{\n    return texelFetch(data_channel, uv, 0);\n}\n\nvec4 get_particle(sampler2D channel, float res_x, int i)\n{\n    ivec2 uv;\n    uv.x = i % int(res_x);\n    uv.y = i / int(res_x);\n    return sample_data_channel(channel, uv);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int seed = 0;\n\nvoid walls(inout vec4 p)\n{\n    if(p.x - radius < 0.0)\n    {\n        p.z = abs(p.z);\n    }\n    if(p.x + radius > iResolution.x / iResolution.y)\n    {\n        p.z = -abs(p.z);\n    }\n    if(p.y - radius < 0.0)\n    {\n        p.w = abs(p.w);\n    }\n    if(p.y + radius > 1.0)\n    {\n        p.w = -abs(p.w);\n    }\n}\n\nvec2 the_force(const vec4 p)\n{\n    bool lmb = iMouse.z > 0.0;\n    if(!lmb)\n    {\n        return vec2(0);\n    }\n    vec2 mouse_pos = iMouse.xy / iResolution.y;\n    vec2 dp = mouse_pos.xy - p.xy;\n    float d_2 = dot(dp, dp);\n    float d = sqrt(d_2);\n    float d_2_inv = 1.0 / d_2;\n    vec2 dpn = dp / d;\n\n    float f = 0.0;\n\n    if(d < radius * 2.0)\n    {\n        const float c = 4.0 * radius * radius;\n        f += -(1.0 / (d_2 / c + 1.0) - 0.5) * collision_factor * 10.0;\n        f += dot(-p.zw, dpn) * friction_factor * 10.0;\n    }\n    else\n    {\n        f += the_force_factor * G * d_2_inv;\n    }\n\n    return f * dpn;\n}\n\nvoid mainImage( out vec4 p, in vec2 frag_coord )\n{\n    vec2 uv = frag_coord / iResolution.xy;\n    int current_index = int(frag_coord.x) + int(frag_coord.y) * int(iResolution.x);\n    \n    if(current_index >= num_particles)\n    {\n        return;\n    }\n    \n    if(0 == iFrame)\n    {\n        p.xy = noise2(uv, 0, seed);\n        p.x *= iResolution.x / iResolution.y;\n        p.zw = p.xy;\n        p.zw -= vec2(iResolution.x / iResolution.y, 1.0) * 0.5;\n        p.zw = vec2(p.w, -p.z) * 2.0;\n    }\n    else\n    {\n        p = sample_data_channel(iChannel0, ivec2(frag_coord));\n        vec2 a = vec2(0);\n        \n        for(int i = 0; i < num_particles; ++i)\n        {\n            if(i == current_index)\n            {\n                continue;\n            }\n\n            vec4 p1 = get_particle(iChannel0, iResolution.x, i);\n\n            vec2 dp = p1.xy - p.xy;\n            float d_2 = dot(dp, dp);\n            float d = sqrt(d_2);\n            float d_2_inv = 1.0 / d_2;\n            vec2 dpn = dp / d;\n\n            float f = 0.0;\n\n            if(d < radius * 2.0)\n            {\n                const float c = 4.0 * radius * radius;\n                f += -(1.0 / (d_2 / c + 1.0) - 0.5) * collision_factor;\n                f += dot(p1.zw - p.zw, dpn) * friction_factor;\n            }\n            else\n            {\n                f += G * d_2_inv;\n            }\n\n            a += f * dpn;\n        }\n\n        a += the_force(p);\n\n        walls(p);\n\n        p.xy += (p.zw + a * dt * 0.5) * dt;\n        p.zw += a * dt;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}