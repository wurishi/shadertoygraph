{"ver":"0.1","info":{"id":"WsdBWl","date":"1606261743","viewed":262,"name":"checkerboard animation 11","username":"DjinnKahn","description":"for https://isohedral.ca/swirled-series/","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nfloat sqr( float x ) { return x*x; }\n\n//void rayCastSphere( vec3 p, vec3 v, float radius, inout float dist, inout float color )\n//{    \n//\tfloat S = sqr( dot( p, v ) ) - dot( p, p ) + sqr(radius);\n//    if ( S < 0. ) return;\n//    float t0 = -dot( p, v ) - sqrt( S );\n//    float t1 = -dot( p, v ) + sqrt( S );\n//    float t;\n//    if ( t0 >= 0. && t0 < dist )\n//        t = t0;\n//    else if ( t1 >= 0. && t1 < dist )\n//        t = t1;\n//    else \n//        return;\n//    \n//    vec3 hitPt = p + v*t;\n//    dist = t;\n//    color = t*.4;\n//}\n\nfloat easeInOutQuad( float x ) \n{\n\treturn x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nfloat ease01( float t )\n{\n    t = clamp( t, 0., 1. );\n    return t*t*.5; // want slope=1 at t=1\n}\n\nconst float END_TIME = 3.6;\n\nfloat timelineRaw( float t )\n{\n    float ret = 0.;\n    t = mod( t, END_TIME + .2 );\n    \n    const float EASE_IN_DURATION = .4;\n    const float EASE_OUT_DURATION = .4;\n    const float LINEAR_DURATION = END_TIME - EASE_IN_DURATION - EASE_OUT_DURATION;\n    \n    ret += ease01( t / EASE_IN_DURATION ) * EASE_IN_DURATION;\n    t -= EASE_IN_DURATION;\n    if ( t <= 0. ) return ret;\n    \n    ret += min( t, LINEAR_DURATION );\n    t -= LINEAR_DURATION;\n    if ( t <= 0. ) return ret;\n    \n    ret += ( ease01( 1. ) - ease01( 1. - t / EASE_OUT_DURATION ) ) * EASE_IN_DURATION;\n    return ret;\n}\n\nfloat timeline( float t )\n{\n    return timelineRaw( t ) / timelineRaw( END_TIME ) * END_TIME;\n}\n\n\nvec3 rotY( vec3 p, float angle )\n{\n    return vec3( p.x * cos(angle) + p.z * sin(angle), p.y, p.x * -sin(angle) + p.z * cos(angle) );\n}\nvec3 rotX( vec3 p, float angle )\n{\n    return vec3( p.x, p.y * cos(angle) + p.z * sin(angle), p.y * -sin(angle) + p.z * cos(angle) );\n}\n\nfloat checker( vec2 p ) \n{    \n    return fract( p.x ) >= .5 == fract( p.y ) > .5 ? 0. : 1.; \n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nconst float CAMERA_Z = -3.;\nconst float FLOOR_POS = 3.5;\nconst float WALL_POS = FLOOR_POS;\n\nfloat sdScene( vec3 p )\n{\n \tfloat sd = sdTorus( p, vec2( .8, .4 ) );\n    sd = min( sd, sdPlane( p, vec3(0.,0.,-1.), FLOOR_POS ) );\n    sd = min( sd, sdPlane( p, vec3(0.,-1.,0.), WALL_POS ) );\n    sd = min( sd, sdPlane( p, vec3(0.,1.,0.), WALL_POS ) );\n    sd = min( sd, sdPlane( p, vec3(0.,0.,1.), WALL_POS ) );\n    return sd;\n}\n\n\nfloat projectChecker( vec3 p )\n{\n    vec3 cameraPos = vec3( 0, 0, CAMERA_Z );\n    float t = ((CAMERA_Z-1.) - p.z) / (cameraPos.z - p.z);\n    vec3 screenUV = p * (1.-t) + cameraPos * t;\n    return checker( screenUV.xy * 4. );\n}\n\nfloat go( vec2 fragCoord, float t )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    if ( uv.x < -.5 || uv.x >= .5 )\n        return .2;\n        \n    //uv.xy += .5 / iResolution.y;\n    \n    float angle = t*2.*PI;\n    \n    vec3 pos = vec3( 0., 0., CAMERA_Z + sin( angle )*1.1 );\n    vec3 dir = vec3( uv.xy, 1. );\n    pos += dir * max(-1.2 - pos.z, 0.); // ignore walls that we move behind\n    dir = normalize( dir );\n    \n    pos = rotY( pos, sin(angle)*.8 );\n    dir = rotY( dir, sin(angle)*.8 );\n    pos = rotX( pos, angle );\n    dir = rotX( dir, angle );\n    \n           \n    \n    \n    for ( int i = 0; i < 300; i++ )\n    {\n        float dist = sdScene( pos );\n   \t\tpos += dir * dist;\n        if ( dist < .0001 )\n        {\n            const float EPS = .01;\n            //return pos.y / 5.;\n            float f = 4. / (FLOOR_POS-CAMERA_Z);\n            if ( pos.y >= WALL_POS-EPS )\n                return checker( pos.xz * f );\n            if ( pos.y <= -(WALL_POS-EPS) )\n                return checker( pos.xz * f );\n            if ( pos.z <= -(WALL_POS-EPS) )\n                return checker( pos.xy * f );\n            return projectChecker( pos );\n        }\n    }\n    \n    return .4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat c = go( fragCoord, timeline( iTime ) / END_TIME );\n    \n    int BLUR_N = 4;\n    \n    float colSum = 0.;\n    for ( int i = 0; i < BLUR_N; i++ )\n    {    \n\t\tcolSum += go( fragCoord, ( timeline( iTime + iTimeDelta * float(i) / float(BLUR_N) ) ) / END_TIME ) / float(BLUR_N);\n    }\n\n    fragColor = vec4(vec3(colSum),1.0);\n    //fragColor = vec4(vec3(c),1.0);\n}","name":"Image","description":"","type":"image"}]}