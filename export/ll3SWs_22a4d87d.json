{"ver":"0.1","info":{"id":"ll3SWs","date":"1482111577","viewed":1645,"name":"Per-Pixel Particle Party!","username":"huwb","description":"Pass B does particle dynamics, Buf B is a uniform grid data structure (with capacity for a single particle per pixel/bucket!). Mouse emits and moves scene elements around! Not the first to discover this technique, see comments. Really slow in webgl2.0 :((","likes":92,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","particles","dynamics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// final render\n\n// scene data\n#define HOSE vec2(.5,.5)/iResolution.xy\n#define ATTRACTOR vec2(1.5,0.5)/iResolution.xy\n#define COL0 vec2(2.5,0.5)/iResolution.xy\n#define COL1 vec2(3.5,0.5)/iResolution.xy\n#define COL2 vec2(4.5,0.5)/iResolution.xy\n#define HOSE_TARGET vec2(5.5,0.5)/iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // bg\n    fragColor = vec4(.22);\n    float period = 60.;\n    vec2 gridLocal = mod( fragCoord, period );\n    gridLocal.x = min( gridLocal.x, period - gridLocal.x );\n    gridLocal.y = min( gridLocal.y, period - gridLocal.y );\n    if( gridLocal.x < 2. && gridLocal.y < 8. ||\n        gridLocal.x < 8. && gridLocal.y < 2. ) fragColor += .07;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 col0Pos = texture(iChannel2, COL0).xy;\n    vec2 col1Pos = texture(iChannel2, COL1).xy;\n    vec2 col2Pos = texture(iChannel2, COL2).xy;\n\n    // draw colliders\n    vec2 off; float loff2;\n    off = fragCoord - col0Pos; loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) fragColor = mix( fragColor, vec4(.5,.8,0.5,0.)*(.44 + .1*sign(off.x*off.y)),  smoothstep( 2500., 2400., loff2 ) );\n    off = fragCoord - col1Pos; loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) fragColor = mix( fragColor, vec4(.5,.8,0.5,0.)*(.44 + .1*sign(off.x*off.y)),  smoothstep( 2500., 2400., loff2 ) );\n    off = fragCoord - col2Pos; loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) fragColor = mix( fragColor, vec4(.5,.8,0.5,0.)*(.44 + .1*sign(off.x*off.y)),  smoothstep( 2500., 2400., loff2 ) );\n\n    // no reason for the max except it makes the result a little less pixel-y!\n    fragColor += max(abs(texture( iChannel1, uv )),abs(texture( iChannel1, uv+1./iResolution.xy )));\n\n    vec2 hoseCoord = texture(iChannel2, HOSE).xy;\n    vec2 hoseOff = fragCoord.xy - hoseCoord;\n    if( length(hoseOff) < 11. )\n    {\n        vec2 target = texture(iChannel2, HOSE_TARGET).xy;\n        vec2 dir = 2.8*normalize(target-fragCoord.xy);\n        dir += .15*sin(15.*iTime)*vec2(-dir.y,dir.x);\n        if( dot( hoseOff, dir ) < 0. )\n            fragColor = .5*vec4(.5,.8,0.5,0.);\n    }\n    \n    vec2 attractCoord = texture(iChannel2, ATTRACTOR).xy;\n    vec2 attractOff = fragCoord - attractCoord;\n    float attractDist = dot( attractOff, attractOff );\n    if( attractDist < 6.*6. )\n    {\n        fragColor.xyz = .2*fragColor.xyz + vec3(0.2,.5,0.2);\n    }\n    else if( abs(attractDist-50.*50.) < 200. )\n    {\n        float stroke = fract(2.*atan(attractOff.y,attractOff.x) + 3.142)<.5 ? 1. : 0.;\n        fragColor.xyz = mix( fragColor.xyz, .2*fragColor.xyz + vec3(0.2,.5,0.2), stroke );\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// scene data\n#define HOSE vec2(0.5,0.5)\n#define ATTRACTOR vec2(1.5,0.5)\n#define COL0 vec2(2.5,0.5)\n#define COL1 vec2(3.5,0.5)\n#define COL2 vec2(4.5,0.5)\n#define HOSE_TARGET vec2(5.5,0.5)\n#define MOUSE vec2(6.5,0.5)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.y > 1. )\n        return;\n    \n    vec4 hoseData = textureLod(iChannel2, HOSE/iResolution.xy, 0.);\n    vec4 attrData = textureLod(iChannel2, ATTRACTOR/iResolution.xy, 0.);\n    vec4 col0Data = textureLod(iChannel2, COL0/iResolution.xy, 0.);\n    vec4 col1Data = textureLod(iChannel2, COL1/iResolution.xy, 0.);\n    vec4 col2Data = textureLod(iChannel2, COL2/iResolution.xy, 0.);\n    vec4 hoseTargetData = textureLod(iChannel2, HOSE_TARGET/iResolution.xy, 0.);\n    vec4 mouseOld = textureLod(iChannel2, MOUSE/iResolution.xy, 0.);\n    \n    bool clickEvent = mouseOld.z <= 0. && iMouse.z > 0.;\n    bool curDragging = hoseData.z + attrData.z + col0Data.z + col1Data.z + col2Data.z > 0.;\n    \n    if( fragCoord == HOSE )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4(50., 200., 0., 0.);\n        else\n            fragColor = hoseData;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=11.*11.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == ATTRACTOR )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4( 510., 100., 0., 0.);\n        else\n            fragColor = attrData;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=6.*6.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == COL0 )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4( iResolution.xy/2. + vec2(-100.,20.), 0., 0.);\n        else\n            fragColor = col0Data;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=50.*50.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == COL1 )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4( iResolution.xy/2. + vec2(-130.,-100.), 0., 0.);\n        else\n            fragColor = col1Data;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=50.*50.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == COL2 )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4( iResolution.xy/2. + vec2(-20.,-80.), 0., 0.);\n        else\n            fragColor = col2Data;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=50.*50.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == HOSE_TARGET )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4(iResolution.xy/2.,0.,0.);\n        else\n            fragColor = hoseTargetData;\n        \n        if( !curDragging && iMouse.z > 0. && !clickEvent )\n            fragColor.xy = iMouse.xy;\n    }\n    else if( fragCoord == MOUSE )\n    {\n        fragColor = iMouse;\n    }\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buf A is a uniform grid data structure, but storage in each pixel is 1 particle\n// (.xy=vel, .zw=pos). For each bucket, searches neighbourhood for newly arriving particle,\n// greedily takes first one so particles can annihilate each other if they land in the same\n// pixel bucket.\n\n// Flock or perhaps even SPH behavious could probably be implemented on a similar framework.\n\n#define R 5.\n#define RESTITUTION .5\n\n// scene data\n#define HOSE vec2(.5,.5)/iResolution.xy\n#define ATTRACTOR vec2(1.5,0.5)/iResolution.xy\n#define COL0 vec2(2.5,0.5)/iResolution.xy\n#define COL1 vec2(3.5,0.5)/iResolution.xy\n#define COL2 vec2(4.5,0.5)/iResolution.xy\n#define HOSE_TARGET vec2(5.5,0.5)/iResolution.xy\n\nvec2 GetVel( vec4 part ) { return part.xy; }\nvoid SetVel( inout vec4 part, vec2 newVel ) { part.xy = newVel; }\nvec2 GetPos( vec4 part ) { return part.zw; }\nvoid SetPos( inout vec4 part, vec2 newPos ) { part.zw = newPos; }\n\nvec2 FindArrivingParticle( vec2 arriveCoord, out vec4 partData )\n{\n    for( float i = -R; i <= R; i++ )\n    {\n        for( float j = -R; j <= R; j++ )\n        {\n            vec2 partCoord = arriveCoord + vec2( i, j );\n            \n            vec4 part = textureLod( iChannel0, partCoord / iResolution.xy, 0. );\n            \n            // particle in this bucket?\n            if( dot(part,part) < 0.001 )\n                continue;\n            \n            // is the particle going to arrive at the current pixel after one timestep?\n            vec2 partPos = GetPos( part );\n            vec2 partVel = GetVel( part );\n            vec2 nextPos = partPos + partVel;\n            // arrival means within half a pixel of this bucket\n            vec2 off = nextPos - arriveCoord;\n            if( abs(off.x)<=.5 && abs(off.y)<=.5 )\n            {\n                // yes! greedily take this particle.\n                // a better algorithm might be to inspect all particles that arrive here\n                // and pick the one with the highest velocity.\n                partData = part;\n                return partCoord;\n            }\n        }\n    }\n    // no particle arriving at this bucket.\n    return vec2(-1.);\n}\n\nvoid Clip( inout vec4 partData, vec2 col0Pos, vec2 col1Pos, vec2 col2Pos )\n{\n    vec2 pos = GetPos( partData );\n    vec2 vel = GetVel( partData );\n    \n    vec2 nextPos = pos + vel;\n    if( nextPos.y < 0. ) vel.y *= -RESTITUTION;\n    if( nextPos.x < 0. ) vel.x *= -RESTITUTION;\n    if( nextPos.y > iResolution.y ) vel.y *= -RESTITUTION;\n    if( nextPos.x > iResolution.x ) vel.x *= -RESTITUTION;\n\n    vec2 off; float loff2;\n    off = nextPos - col0Pos;\n    loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) {\n        loff2 = sqrt(loff2);\n        vec2 n = off/loff2;\n        vel -= (1.+RESTITUTION) * dot( vel, n ) * n;\n        SetPos( partData, col0Pos + 50.*n );\n    }\n    off = nextPos - col1Pos;\n    loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) {\n        loff2 = sqrt(loff2);\n        vec2 n = off/loff2;\n        vel -= (1.+RESTITUTION) * dot( vel, n ) * n;\n        SetPos( partData, col1Pos + 50.*n );\n    }\n    off = nextPos - col2Pos;\n    loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) {\n        loff2 = sqrt(loff2);\n        vec2 n = off/loff2;\n        vel -= (1.+RESTITUTION) * dot( vel, n ) * n;\n        SetPos( partData, col2Pos + 50.*n );\n    }\n\n    SetVel( partData, vel );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col0Data = textureLod(iChannel2, COL0, 0.).xyz;\n    vec3 col1Data = textureLod(iChannel2, COL1, 0.).xyz;\n    vec3 col2Data = textureLod(iChannel2, COL2, 0.).xyz;\n    \n    // add loads of particles on first frame\n    if( iFrame == 0 )\n    {\n        fragColor = vec4(0.);\n        if( mod(fragCoord,10.) == vec2(2.5) )\n        {\n            vec4 newPart;\n            SetPos( newPart, fragCoord );\n            SetVel( newPart, vec2(0.) );\n            Clip( newPart, col0Data.xy, col1Data.xy, col2Data.xy );\n            fragColor = newPart;\n        }\n        return;\n    }\n    \n    // scene data\n    vec3 hoseData = textureLod(iChannel2, HOSE, 0.).xyz;\n    vec3 attractData = textureLod(iChannel2, ATTRACTOR, 0.).xyz;\n    vec2 hoseTarget = textureLod(iChannel2, HOSE_TARGET, 0.).xy;\n    \n    float dragCount = hoseData.z + attractData.z + col0Data.z + col1Data.z + col2Data.z;\n    \n    // mouse emits\n    if( iMouse.z > 0. && length(iMouse.xy-fragCoord.xy) < 9. && dragCount == 0. )\n    {\n        vec4 newPart;\n        SetPos( newPart, fragCoord );\n        SetVel( newPart, 3.*normalize(fragCoord.xy-iMouse.xy));\n        fragColor = newPart;\n        return;\n    }\n    \n    // hose 0\n    if( length(hoseData.xy-fragCoord.xy) < 9. )\n    {\n        vec4 newPart;\n        SetPos( newPart, fragCoord );\n        /*vec2 target = iResolution.xy/2.;\n        if( iMouse.x*iMouse.y > 0. ) target = iMouse.xy;*/\n        SetVel( newPart, 2.8*normalize(hoseTarget-fragCoord.xy) );\n        newPart.xy += .15*sin(15.*iTime)*vec2(-newPart.y,newPart.x);\n        fragColor = newPart;\n        return;\n    }\n    \n    // look for a particle arriving at the current bucket\n    vec4 partData;\n    vec2 partCoord = FindArrivingParticle( fragCoord, partData );\n    if( partCoord.x < 0. )\n    {\n        // no particle, empty this bucket\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 pos = GetPos( partData );\n    vec2 vel = GetVel( partData );\n    \n    // integrate pos using current vel\n    SetPos( partData, pos + vel );\n    \n    // integrate velocity\n    \n    // gravity\n    vel += vec2(0.,-.05);\n    \n    // attractor\n    vec2 attract = attractData.xy-fragCoord;\n    float attractStrength = 20./(.1+dot(attract,attract)) - 0.004;\n    if( attractStrength > 0. )\n    {\n        vel += attract*attractStrength;\n    }\n    \n    // drag\n    vel *= .995;\n    // turbulence (divergence free curl could work great here but i just want to add a little variation)\n    // NOTE this needs mipmapping to be disabled on the texture!\n    vel += .125*normalize(textureLod( iChannel1, iTime + 4.*fragCoord/iResolution.xy, 0. ).xy-.5);\n    // clamp to the maximum search radius. rsults would benefit from increasing R!\n    vel = clamp(vel,-R,R);\n    \n    SetVel( partData, vel );\n    \n    Clip( partData, col0Data.xy, col1Data.xy, col2Data.xy );\n    \n    fragColor = partData;\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// accumulation buffer for particle trails\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor.zw = vec2(0.);\n    fragColor.xy = .75 * texture( iChannel1, uv ).xy;\n    vec2 vel = texture(iChannel0,uv).xy;\n    if( dot(vel,vel) != 0. ) fragColor += 1.;\n}\n","name":"Buf C","description":"","type":"buffer"}]}