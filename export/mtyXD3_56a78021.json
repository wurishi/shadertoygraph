{"ver":"0.1","info":{"id":"mtyXD3","date":"1686412613","viewed":156,"name":"Raymarching SDF","username":"dzufque","description":"Raymarching with shadows, AO and AA","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdfraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define AO  \n#define SHADOWS\n#define AA 2\n\n\n// Constants\nconst int MAX_MARCHING_STEPS=255;\nconst float MIN_DIST=0.;\nconst float MAX_DIST=100.;\nconst float PRECISION=.0001;\nconst float EPSILON=.0005;\nconst float PI=3.14159265359;\n\n// === APP UNIFORMS ===\n// uniform vec3  u_ambient;\n// uniform vec3  u_specular;\n// uniform vec3  u_diffuse;\n// uniform vec3  u_emission;\n// uniform float u_ka;\n// uniform float u_ks;\n// uniform float u_kd;\n// uniform float u_smoothness;\n// uniform vec2  u_cameraAng;\n// uniform float u_zoom;\n// uniform vec2  u_resolution;\n// uniform vec2  u_mouse;\n// uniform vec3 lightsPos[4];\n// uniform vec3 lightsColor[4];\n\n// === TEST UNIFORMS ===\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nconst vec3 u_specular=vec3(1.30,1.,.70);\nconst vec3 u_diffuse=vec3(1.30,0.0,0.70);\nconst vec3 u_emission=vec3(.02);\nconst vec3 u_ambient = vec3(0.8392, 0.7216, 0.8667);\nconst vec3 u_ambientEnv = vec3(0.01);\nconst float u_ka = 0.4;\nconst float u_ks = 30.0;\nconst float u_kd = 2.0;\nconst float u_smoothness=100.;\nconst float u_zoom=2.5;\nconst vec2 u_cameraAng=vec2(0.0,0.0);\n\nstruct Material\n{\n  vec3 ambient;\n  float ka;\n  vec3 diffuse;\n  float kd;\n  vec3 specular;\n  float ks;\n  vec3 emission;\n  float smoothness;\n};\n\nstruct Surface{\n  float sd;\n  Material mat;\n};\n\nmat3 RotateX(float theta){\n  float c=cos(theta);\n  float s=sin(theta);\n  return mat3(\n    vec3(1.,0.,0.),\n    vec3(0.,c,-s),\n    vec3(0.,s,c)\n  );\n}\n\nmat3 RotateY(float theta){\n  float c=cos(theta);\n  float s=sin(theta);\n  return mat3(\n    vec3(c,0.,s),\n    vec3(0.,1.,0.),\n    vec3(-s,0.,c)\n  );\n}\n\n// === DEFORM OPERATORS ===\n\nvec3 Twist(in vec3 p,in float k)\n{\n  float c=cos(k*p.y);\n  float s=sin(k*p.y);\n  mat2 m=mat2(c,-s,s,c);\n  vec3 q=vec3(m*p.xz,p.y);\n  return q;\n}\n\nvec3 Bend(in vec3 p,in float k)\n{\n  float c=cos(k*p.x);\n  float s=sin(k*p.x);\n  mat2 m=mat2(c,-s,s,c);\n  vec3 q=vec3(m*p.xy,p.z);\n  return q;\n}\n\nvec3 Elongate(in vec3 p, in vec3 h )\n{\n    return p - clamp( p, -h, h );\n}\n\nfloat Round(float p, float rad )\n{\n    return p-rad;\n}\n\n// === REPEAT OPERATORS ===\nvec3 Repeat(in vec3 p,in float s,in vec3 lim)\n{\n  return p-s*clamp(floor(p/s+.5),-lim,lim);\n}\n\nvec3 InfiniteRepeat(in vec3 p,in float s)\n{\n  return mod(p+.5*s,s)-.5*s;\n}\n\n// === BOOLEAN OPERATORS ===\n\nSurface SurfaceUnion(Surface s1,Surface s2){\n  if(s1.sd<s2.sd)\n  return s1;\n  \n  return s2;\n}\n\nfloat Union(float a,float b,float k,float n,out float interp)\n{\n  if(k==0.){\n    return min(a,b);\n  }\n  float h=max(k-abs(a-b),0.)/k;\n  float m=pow(h,n)*.5;\n  float s=m*k/n;\n  \n  interp=a<b?m:1.-m;\n  return(a<b)?a-s:b-s;\n}\n\nfloat Intersection(float a,float b,float k,float n,out float interp)\n{\n  return -Union(-a,-b,k,n,interp);\n}\n\nfloat Difference(float a,float b,float k,float n,out float interp)\n{\n  return Union(a,-b,k,n,interp);\n}\n\n// === TRANSFORM OPERATORS ===\nvec3 RotateX(vec3 p,float theta){\n  float c=cos(theta);\n  float s=sin(theta);\n  \n  return mat3(\n    vec3(1.,0.,0.),\n    vec3(0.,c/(c*c+s*s),s/(c*c+s*s)),\n    vec3(0.,-s/(c*c+s*s),c/(c*c+s*s))\n  )*p;\n}\n\nvec3 RotateY(vec3 p,float theta){\n  float c=cos(theta);\n  float s=sin(theta);\n  \n  return mat3(\n    vec3(c/(c*c+s*s),0.,-s/(c*c+s*s)),\n    vec3(0.,1.,0.),\n    vec3(s/(c*c+s*s),0.,c)\n  )*p;\n}\n\nvec3 RotateZ(vec3 p,float theta){\n  float c=cos(theta);\n  float s=sin(theta);\n  \n  return mat3(\n    vec3(c/(c*c+s*s),s/(c*c+s*s),0.),\n    vec3(-s/(c*c+s*s),c/(c*c+s*s),0.),\n    vec3(0.,0.,1.)\n  )*p;\n}\n\nvec3 Translate(vec3 p,vec3 t){\n  return p-t;\n}\n\n// === REPEAT OPERATORS ===\n\nvec3 SimX(vec3 p){\n  return vec3(abs(p.x),p.yz);\n}\n\nvec3 SimY(vec3 p){\n  return vec3(p.x,abs(p.y),p.z);\n}\n\nvec3 SimZ(vec3 p){\n  return vec3(p.xy,abs(p.z));\n}\n\nvec3 SimXY(vec3 p){\n  return vec3(abs(p.xy),p.z);\n}\nvec3 SimXZ(vec3 p){\n  return vec3(abs(p.x),p.y,abs(p.z));\n}\n\nvec3 SimYZ(vec3 p){\n  return vec3(p.x,abs(p.yz));\n}\n\nvec3 SimXYZ(vec3 p){\n  return abs(p);\n}\n\n// === PRIMITIVES ===\nfloat Sphere(vec3 p,float radius)\n{\n  return length(p)-radius;\n}\n\nfloat Box(vec3 p,vec3 size)\n{\n  vec3 q=abs(p)-size;\n  return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat Cone( vec3 p, float angle, float h ){\n\n  float s = sin(angle);\n  float c = cos(angle);\n  float q = length(p.xz);\n  return max(dot(vec2(s,c),vec2(q,p.y)),-h-p.y);\n}\n\nfloat Ellipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat Torus(vec3 p,vec2 size)\n{\n  vec2 q=vec2(length(p.xz)-size.x,p.y);\n  return length(q)-size.y;\n}\n\nfloat Cylinder(vec3 p,float h,float r)\n{\n  vec2 d=abs(vec2(length(p.xz),p.y))-vec2(r,h);\n  return min(max((abs(vec2(length(p.xz),p.y))-vec2(r,h)).x,(abs(vec2(length(p.xz),p.y))-vec2(r,h)).y),0.)+length(max(abs(vec2(length(p.xz),p.y))-vec2(r,h),0.));\n}\n\nfloat Line(in vec3 p,in vec3 start,in vec3 end,in float thickness){\n  vec3 ba=end-start;\n  vec3 pa=p-start;\n  float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n  return length(pa-h*ba)-thickness;\n}\n\nfloat InfCylinder(vec3 p,vec3 c)\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat plane(vec3 p,vec3 n,float h)\n{\n  return dot(p,n)+h;\n}\n\nfloat sdf(vec3 p){\n  float interp;\n  float esfera=Sphere(p-vec3(.5),1.);\n  float cilindro=Cylinder(p,1.,.5);\n\n  return Union(esfera,cilindro,.5,3.,interp);\n}\n\nSurface map(vec3 p){\n  \n  Material mat = Material(\n      u_ambient,    // ambient\n      u_ka,         // ka\n      u_diffuse,    // diffuse\n      u_kd,         // kd\n      u_specular,   // specular\n      u_ks,         // ks\n      u_emission,   // emission\n      u_smoothness  // smoothness\n    );\n\n  Material matBox = Material(\n    vec3(0.0118, 0.2235, 0.302),\n    1.0,\n    vec3(0.1216, 0.2824, 0.5608),\n    5.0,\n    vec3(0.4431, 0.4314, 0.5098),\n    10.0,\n    vec3(0.0, 0.0, 0.0),\n    15.0\n  );\n\n  vec3 col = mod(p.x, 5.0)>0.3 && mod(p.z, 5.0) > 0.3 ? vec3(0.4392, 0.4275, 0.4275) : vec3(0.2471, 0.2392, 0.2392);\n  Surface suelo=Surface(\n    plane(Translate(p,vec3(0.,-0.5,0.)),vec3(0.,1.,0.),.5),\n    Material(vec3(1.0, 1.0, 1.0),0.,col,3.,vec3(1.0, 1.0, 1.0),25.,vec3(.1),50.)\n  );\n\n  Surface auricular=Surface(\n    sdf(p),\n    mat\n  );\n\n  Surface esfera = Surface(Sphere(p-vec3(4.0,0.0,0.0),3.), mat);\n  Surface cubo   = Surface(Round(Box(p-vec3(-1.0,0.0,0.0), vec3(2.0)),0.2), matBox);\n  Surface final=SurfaceUnion(suelo,esfera);\n  final = SurfaceUnion(final, cubo);\n  \n  //====== float a,float b,float k,float n,out float interp\n  float interp;\n  float cuboEsfera = Union(cubo.sd,esfera.sd,2.1,2.0,interp);\n  Material m = Material(\n      u_ambient,    // ambient\n      u_ka,         \n      mix(matBox.diffuse, mat.diffuse, interp),  \n      u_kd,         // kd\n      u_specular,   // specular\n      u_ks,         // ks\n      u_emission,   // emission\n      u_smoothness  // smoothness\n      );\n  return Surface(cuboEsfera, m);\n  //======\n  return final;\n}\n  \nSurface rayMarch(vec3 ro,vec3 rd,float start,float end){\n  float depth=start;\n  Surface co;\n  \n  for(int i=0;i<MAX_MARCHING_STEPS;i++){\n    vec3 p=ro+depth*rd;\n    co=map(p);\n    depth+=co.sd;\n    if(co.sd<PRECISION||depth>end)break;\n  }\n  \n  co.sd=depth;\n  \n  return co;\n}\n\n\nfloat calcAO(in vec3 pos, in vec3 norm){\n  const float OCC_SAMPLES = 4.0;\n  const float s = -OCC_SAMPLES;\n  const float increment = 1.0/OCC_SAMPLES;\n\n  float ao = 1.0;\n\n  for(float i = increment; i < 1.0; i+=increment)\n  {\n    ao -= pow(2.0,i*s)*(i-map(pos+i*norm).sd);\n  }\n\n  return ao;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow(in vec3 ro,in vec3 rd,in float mint,in float tmax, float w)\n{\n  // bounding volume\n  float tp=(.8-ro.y)/rd.y;if(tp>0.)tmax=min(tmax,tp);\n  \n  float res =1.0;\n  float t = mint;\n\n  for(int i=0;i<24;i++)\n  {\n    float h=map(ro+rd*t).sd;\n    float s=clamp(w*h/t,0.,1.);\n    res=min(res,s);\n    t+=clamp(h,.01,.2);\n    if(res<.004||t>tmax)break;\n  }\n  \n  return res;\n}\n\nvec3 lighting(vec3 pos, vec3 rd, vec3 nor, Surface s){\n  float lightPos[6], lightColor[6], lightSize[2];\n  lightPos[0] = 0.5; lightPos[1] = 0.4; lightPos[2] = -0.6;\n  lightPos[3] = -1.0; lightPos[4] = 1.0; lightPos[5] = -2.0;\n  lightColor[0] = 0.4; lightColor[1] = 0.4; lightColor[2] = 0.4;\n  lightColor[3] = 0.4; lightColor[4] = 0.4; lightColor[5] = 0.4;\n  lightSize[0] = 1.5; lightSize[1] = 10.;\n\n  const int nLights = 2;\n\n  vec3 result = u_ambientEnv;\n\n  float occ = 1.0;\n  #ifdef AO\n  occ= calcAO(pos,nor);\n  #endif\n\n  for(int i=0; i<2; i++){\n    vec3 Li=normalize(vec3(lightPos[3*i], lightPos[3*i+1], lightPos[3*i+2]));\n    vec3 lColor = vec3(lightColor[3*i], lightColor[3*i+1], lightColor[3*i+2]);\n    vec3 h=normalize(Li-rd);\n    float NLi=max(0.,dot(nor,Li));\n    float NH=max(0.,dot(nor,h));\n\n    float shadow = 1.0;\n    #ifdef SHADOWS\n    shadow=calcSoftshadow(pos,Li,.02,2.5,lightSize[i]);\n    #endif\n    vec3 amb = s.mat.ka*s.mat.ambient;\n    vec3 dif=NLi*s.mat.kd*s.mat.diffuse;\n    vec3 spe=NLi*s.mat.ks*s.mat.specular*pow(NH,s.mat.smoothness);\n\n    spe*=.04+.96*pow(clamp(1.-dot(h,Li),0.,1.),5.);\n\n    result += lColor*shadow;\n  }\n\n  return result;\n}\n\nvec3 calcNormal(in vec3 p){\n  return normalize(vec3(\n    map(vec3(p.x+EPSILON,p.y,p.z)).sd-map(vec3(p.x-EPSILON,p.y,p.z)).sd,\n    map(vec3(p.x,p.y+EPSILON,p.z)).sd-map(vec3(p.x,p.y-EPSILON,p.z)).sd,\n    map(vec3(p.x,p.y,p.z+EPSILON)).sd-map(vec3(p.x,p.y,p.z-EPSILON)).sd\n  ));\n}\n  \nmat3 camera(vec3 cameraPos,vec3 lookAtPoint){\n  vec3 cd=normalize(lookAtPoint-cameraPos);\n  vec3 cr=normalize(cross(vec3(0.,1.,0.),cd));\n  vec3 cu=normalize(cross(cd,cr));\n  \n  return mat3(-cr,cu,-cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  const vec3 backgroundColor=vec3(0.6784, 0.8824, 0.9333);\n  const vec3 lookAt=vec3(0.);\n\n  vec3 col=vec3(0.);\n  vec3 eye=vec3(3.,3.,5.);\n  mat3 rot=(RotateY(u_cameraAng.x)*RotateX(u_cameraAng.y));\n  eye=rot*eye*(u_zoom * sin(iTime)+3.5);\n  mat3 cam = camera(eye,lookAt);\n  \n\n  #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n      vec2 o = vec2(float(m),float(n)) / float(AA) - vec2(0.25);\n      vec2 uv=((fragCoord.xy+o) - 0.5*iResolution.xy) / iResolution.y;\n  # else\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n  #endif\n  \n \n  vec3 rayDir=cam*normalize(vec3(uv,-1));\n\n  Surface co=rayMarch(eye,rayDir,MIN_DIST,MAX_DIST);\n  \n  if(co.sd>MAX_DIST){\n    col+=backgroundColor;\n  }\n  else{\n    vec3 p=eye+rayDir*co.sd;\n    vec3 normal=calcNormal(p);\n    \n    col += lighting(p, rayDir, normal, co);\n  }\n  \n  #if AA>1\n    }\n    col /= float(AA*AA);\n  #endif\n  \n  fragColor=vec4(col,1.);\n  return;\n}","name":"Image","description":"","type":"image"}]}