{"ver":"0.1","info":{"id":"NsjcWc","date":"1644248021","viewed":148,"name":"Wobbly Red Portal","username":"jackdavenport","description":"A cool little portal shader. I wanted to experiment with lighting/shadows through a portal surface, which I've demonstrated here with the moving light.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["shadow","raymarcher","red","table","portal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER_ROOM 150\n#define MAX_DIST_ROOM 10.\n#define MIN_DIST_ROOM .001\n#define MAX_ITER_PORTAL 256\n#define MAX_DIST_PORTAL 300.\n#define MAX_BOUNCES 3\n\n#define NUM_LIGHTS 2\n\n#define RGB(r,g,b) (vec3(r,g,b)/255.)\n\nstruct Material {\n    vec3 diffuse;\n    vec3 specular;\n    vec3 emission;\n    float shininess;\n    float reflective;\n};\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float range;\n    float hardness;\n};\n\nvec2 rot2D(vec2 p, float a) {\n    float s = sin(a), c = cos(a);\n    return p * mat2(c,s,-s,c);\n}\n\n// source: https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec2 minDst(vec2 a, float bd, float bm) {\n    if(a.x < bd) return a;\n    else return vec2(bd,bm);\n}\n\nvec2 dstPortal(vec3 p) {\n    vec3 c = vec3(1.);\n    p = mod(p+0.5*c,c)-0.5*c;\n    vec2 d = vec2(length(p) - .2, 3.);\n    \n    //d = minDst(d, length(p-PORTAL_LIGHT)-.2, 4.);\n    \n    return d;\n}\n\nvec2 marchPortal(vec3 ro, vec3 rd, float start) {\n    float t = start;\n    float m = -1.;\n    for(int i = 0; i < MAX_ITER_PORTAL; i++) {\n        vec2 d = dstPortal(ro+rd*t);\n        if(abs(d.x) < MIN_DIST_ROOM || t > MAX_DIST_PORTAL) break;\n        t += d.x;\n        m  = d.y;\n    }\n    return vec2(t,m);\n}\n\nvec3 normalPortal(vec3 p, float t) {\n    vec2 e = vec2(.001*t,0.);\n    vec3 n = vec3(\n        dstPortal(p+e.xyy).x-dstPortal(p-e.xyy).x,\n        dstPortal(p+e.yxy).x-dstPortal(p-e.yxy).x,\n        dstPortal(p+e.yyx).x-dstPortal(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec2 dstRoom(vec3 p) {\n    vec2 d = vec2(p.y,0.); // floor\n    d = minDst(d, p.x+1., 1.); // wall\n    \n    // box thingy\n    vec3 q = p;\n    q.xz = rot2D(q.xz, .4);\n    d = minDst(d, sdBoxFrame(q-vec3(.4,.19,.9),vec3(.4,.2,.3), .02), 2.);\n    \n    return d;\n}\n\nvec2 marchRoom(vec3 ro, vec3 rd, float start) {\n    float t = start;\n    float m = -1.;\n    for(int i = 0; i < MAX_ITER_ROOM; i++) {\n        vec2 d = dstRoom(ro+rd*t);\n        if(abs(d.x) < MIN_DIST_ROOM || t > MAX_DIST_ROOM) {\n            break;\n        }\n        t += d.x;\n        m  = d.y;\n    }\n    return vec2(t,m);\n}\n\nvec3 normalRoom(vec3 p, float t) {\n    vec2 e = vec2(.001*t,0.);\n    vec3 n = vec3(\n        dstRoom(p+e.xyy).x-dstRoom(p-e.xyy).x,\n        dstRoom(p+e.yxy).x-dstRoom(p-e.yxy).x,\n        dstRoom(p+e.yyx).x-dstRoom(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nbool isPortal(vec3 p) {\n    float dis = sin(p.z*56.+iTime*3.)+cos(p.y*30.);\n    return length(p.zy*vec2(1.,.55)-vec2(0.,.75)) < .7+dis*.01;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = dstRoom(ro + rd*t).x;\n        if( h<0.01 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid material(inout Material mat, in vec3 p, in vec3 n, in float m) {\n    if(m == 0.) { // floor\n        mat.diffuse = texture(iChannel0, p.xz).rgb;\n        mat.specular = vec3(1.);\n        mat.shininess = 20.;\n        mat.reflective = .7;\n    } else if(m == 1.) { // wall\n        mat.diffuse = texture(iChannel1, p.zy*.5).rgb;\n        mat.specular = vec3(.2);\n        mat.shininess = 2.;\n        mat.reflective = .1;\n    } else if(m == 2.) { // box thingy\n        mat.diffuse = vec3(.9);\n        mat.specular = vec3(1.);\n        mat.shininess = 70.;\n        mat.reflective = 1.;\n    } else if(m == 3.) { // infinite spheres\n        mat.diffuse = vec3(1.);\n        mat.specular = vec3(1.);\n        mat.shininess = 20.;\n        mat.reflective = 0.;\n    } else if(m == 4.) { // light in portal\n        mat.diffuse = vec3(0.);\n        mat.specular = vec3(0.);\n        mat.shininess = 1.;\n        mat.emission = vec3(1.);\n        mat.reflective = 0.;\n    }\n}\n\nvoid defineLights(inout Light lights[NUM_LIGHTS]) {\n    lights[0] = Light(vec3(-.8,1.3,0.), RGB(255, 90, 0), 8.+3.*sin(iTime*4.), 10.);\n    lights[1] = Light(vec3(-2., 1.6+.1*cos(iTime), sin(iTime*.5)), vec3(1.), 20., 10.);\n}\n\nfloat shadow(vec3 p, vec3 ld, float dist, Light light) {\n    if(light.pos.x < -1.) {\n        vec2 hit = marchRoom(p, ld, .07);\n        if(hit.x < dist && isPortal(p+ld*hit.x)) {\n            return marchPortal(p, ld, hit.x).x < dist ? 0. : 1.;\n        } else {\n            return 0.;\n        }\n    }\n    return softshadow(p, ld, .07, dist, light.hardness);\n}\n\nvec3 lighting(vec3 p, vec3 n, vec3 r, Light lights[NUM_LIGHTS], Material mat) {\n    vec3 diff = vec3(0.);\n    vec3 spec = vec3(0.);\n    \n    for(int i = 0; i < NUM_LIGHTS; i++) {\n        vec3 lv = lights[i].pos - p;\n        float ld = length(lv);\n        lv /= ld;\n        \n        float ndotl = max(dot(n,lv),0.);\n        float rdotl = max(dot(r,lv),0.);\n        float att = clamp(1.0 - ld*ld/(lights[i].range*lights[i].range), 0.0, 1.0);\n        float shd = shadow(p, lv, ld, lights[i]);\n        \n        //shd = softshadow(p, lv, .07, ld, lights[i].hardness);\n        \n        diff += lights[i].color * ndotl * att * shd;\n        spec += lights[i].color * pow(rdotl,mat.shininess) * att * shd;\n    }\n    \n    return mat.diffuse * diff + mat.specular * spec + mat.emission;\n}\n\nvec3 shadePortal(vec3 ro, vec3 rd, float dist, Light lights[NUM_LIGHTS]) {\n    vec3 col = vec3(1.,0.,0.);\n    vec2 hit = marchPortal(ro, rd, dist);\n    \n    if(hit.x < MAX_DIST_PORTAL) {\n        vec3 p = ro+rd*hit.x;\n        vec3 n = normalPortal(p, hit.x);\n        vec3 r = normalize(reflect(rd,n));\n        \n        Material mat;\n        material(mat,p,n,hit.y);\n        \n        col = lighting(p,n,r,lights,mat);\n    }\n    \n    float fog = 1.0 - exp( -hit.x*.1 );\n    col = mix(col, vec3(1.,0.,0.), fog);\n    \n    float light = max(dot(normalize(lights[1].pos-ro),rd),0.);\n    col = mix(col, vec3(1.), 1.-step(pow(light,300.),.9));\n    \n    return col;\n}\n\nvec3 shade(vec3 ro, vec3 rd) {\n    Light lights[NUM_LIGHTS];\n    defineLights(lights);\n\n    vec3 col = vec3(0.);\n    vec3 mask = vec3(1.);\n    \n    for(int i = 0; i < MAX_BOUNCES; i++) {\n        vec2 hit = marchRoom(ro,rd,0.);\n\n        if(hit.x < MAX_DIST_ROOM) {\n            vec3 p = ro + rd * hit.x;\n\n            if(isPortal(p)) {\n                col += mask * shadePortal(ro, rd, hit.x, lights);\n                break;\n            } else {\n                vec3 n = normalRoom(p,hit.x);\n                vec3 r = normalize(reflect(rd,n));\n\n                Material mat;\n                material(mat, p, n, hit.y);\n\n                col += mask * lighting(p,n,r,lights,mat);\n                \n                float fres = pow(max(0.,-dot(rd,n)),6.);\n                mask *= mat.diffuse * mat.reflective * (1.-fres);\n                ro = p + r * .01;\n                rd = r;\n                \n            }\n        } else {\n            break;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ro = vec3(2.5,1.,0.);\n    vec3 rd = vec3(-1., uv.yx);\n    \n    float an = .2 * sin(iTime * .3);\n    vec3 tn = vec3(-1., 0., 0.);\n    tn.xz = rot2D(tn.xz, an);\n    ro = vec3(-1.,1.,0.) + tn * -3.5;\n    rd = vec3(-1., uv.yx);\n    rd.xz = rot2D(rd.xz, an);\n    \n    fragColor.rgb = shade(ro, normalize(rd));\n    fragColor.a   = 1.;\n}","name":"Image","description":"","type":"image"}]}