{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// If you get artefacts on the ground, try this:\n//#define INTERPOLATION_FIX\n\n//compiler won't let me init const with mix()\n#define lerp(a,b,c) ((a)*(1.0-(c))+(b)*(c))\n\n// control colours\nconst vec3 rock = vec3(.8,.33,.18);\nconst vec3 darkRock = lerp(rock, vec3(.1,0,0),.8);\nconst vec3 dust = vec3(1,.53,.35);\nconst vec3 scrub = vec3(.13,.3,.1);\n\nconst vec3 sunColour = vec3(1.8,1.7,1.5);\nconst vec3 ambientColour = vec3(.09,.12,.2);\n\t\nconst vec3 atmosphere = vec3(.1,.25,1.0)/8.0; // this is the rate of attenuation per channel\n\n\n\nconst float tau = 6.28318530717958647692;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec3 localRay;\n\nvoid Cam( out vec3 pos, out vec3 ray, in vec3 origin, in vec3 look, in float zoom, in vec2 fragCoord )\n{\n\tvec3 dir = look-origin;\n\t\n\tvec2 yrot = normalize(dir.xz);\n\tvec2 xrot = normalize(vec2(length(dir.xz),dir.y));\n\t\n\t// get rotation coefficients\n\tvec2 c = vec2(xrot.x,yrot.y);\n\tvec4 s;\n\ts.xy = vec2(-xrot.y,yrot.x); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\tlocalRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin;\n}\n\n\n// Noise functions, distinguished by variable types\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\n#ifndef INTERPOLATION_FIX\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// on some hardware interpolation lacks precision\n\tvec4 rg = mix( mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(1,0)+0.5)/256.0,  0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(0,1)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+1.5)/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x.xy);\n    vec2 f = fract(x.xy);\n\tf = f*f*(3.0-2.0*f);\n//\tvec2 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = p.xy + f.xy;\n#ifndef INTERPOLATION_FIX\n\treturn textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// on some hardware interpolation lacks precision\n\treturn mix( mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(1,0)+0.5)/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(0,1)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+1.5)/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn textureLod( iChannel0, (vec2(x)+0.5)/256.0, 0.0 );\n}\n\nvec2 Noise( in ivec3 x )\n{\n\tvec2 uv = vec2(x.xy)+vec2(37.0,17.0)*float(x.z);\n\treturn textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).xz;\n}\n\nvec4 Rand( in int x )\n{\n\tvec2 uv;\n\tuv.x = (float(x)+0.5)/256.0;\n\tuv.y = (floor(uv.x)+0.5)/256.0;\n\treturn textureLod( iChannel0, uv, 0.0 );\n}\n\nfloat DistanceField( vec3 pos, float t );\nfloat DistanceField2( vec3 pos );\n\nvec3 Normal( vec3 pos )\n{\n\tconst vec2 delta = vec2(0,.001);\n\tvec3 grad;\n\tgrad.x = DistanceField2( pos+delta.yxx )-DistanceField2( pos-delta.yxx );\n\tgrad.y = DistanceField2( pos+delta.xyx )-DistanceField2( pos-delta.xyx );\n\tgrad.z = DistanceField2( pos+delta.xxy )-DistanceField2( pos-delta.xxy );\n\treturn normalize(grad);\n}\n\nfloat Trace( vec3 pos, vec3 ray, vec2 interval )\n{\n\t//const vec2 interval = vec2(0.0,10.0); // could do ray traced bounding shape to get tighter region\n\t\n\tfloat h = 1.0;\n\tfloat t = interval.x;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tif ( t > interval.y || h < .001 )\n\t\t\tbreak;\n\t\th = DistanceField( pos+ray*t, t );\n\t\tt += h;\n\t}\n\t\n\tif ( t > interval.y || t < interval.x || h > .1 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat Trace2( vec3 pos, vec3 ray, vec2 interval )\n{\n\t//const vec2 interval = vec2(0.0,10.0); // could do ray traced bounding shape to get tighter region\n\t\n\tfloat h = 1.0;\n\tfloat t = interval.x;\n\tfor ( int i=0; i < 30; i++ )\n\t{\n\t\tif ( t > interval.y || h < .01 )\n\t\t\tbreak;\n\t\th = DistanceField( pos+ray*t, 1.0 );\n\t\tt += h;\n\t}\n\t\n\tif ( t > interval.y || t < interval.x || h > .1 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\n// ----------------------\n\nfloat Mesa( vec2 pos )\n{\n\treturn\n\t\tNoise( pos*exp2(1.0) ).x/exp2(1.0) +\n\t\tNoise( pos*exp2(2.0) ).x/exp2(2.0) +\n\t\tNoise( pos*exp2(3.0) ).x/exp2(3.0) +\n\t\tNoise( pos*exp2(4.0) ).x/exp2(4.0) +\n\t\tNoise( pos*exp2(5.0) ).x/exp2(5.0) +\n\t\tNoise( pos*exp2(6.0) ).x/exp2(6.0) +\n\t\tNoise( pos*exp2(7.0) ).x/exp2(7.0) +\n\t\tNoise( pos*exp2(8.0) ).x/exp2(8.0);\n}\n\nfloat Mesa2( vec2 pos )\n{\n\treturn\n\t\tNoise( pos*exp2(1.0) ).x/exp2(1.0) +\n\t\tNoise( pos*exp2(2.0) ).x/exp2(2.0) +\n\t\tNoise( pos*exp2(3.0) ).x/exp2(3.0) +\n\t\tNoise( pos*exp2(4.0) ).x/exp2(4.0) +\n\t\tNoise( pos*exp2(5.0) ).x/exp2(5.0);\n}\n\nfloat Mesa3( vec2 pos )\n{\n\treturn\n\t\tNoise( pos*exp2(1.0) ).x/exp2(1.0) +\n\t\tNoise( pos*exp2(2.0) ).x/exp2(2.0) +\n\t\tNoise( pos*exp2(3.0) ).x/exp2(3.0) +\n\t\tNoise( pos*exp2(4.0) ).x/exp2(4.0) +\n\t\tNoise( pos*exp2(5.0) ).x/exp2(5.0) +\n\t\tNoise( pos*exp2(6.0) ).x/exp2(6.0) +\n\t\tNoise( pos*exp2(7.0) ).x/exp2(7.0) +\n\t\tNoise( pos*exp2(8.0) ).x/exp2(8.0) +\n\t\tNoise( pos*exp2(9.0) ).x/exp2(9.0);\n}\n\nfloat Mesa0( vec2 pos )\n{\n\treturn\n\t\tNoise( pos*exp2(1.0) ).x/exp2(1.0) +\n\t\tNoise( pos*exp2(2.0) ).x/exp2(2.0);\n}\n\nfloat DistanceField( vec3 pos, float t )\n{\n\treturn\n\t\tmin(\n\t\t\t//pos.y+.1-.5*max(.0,.5-Mesa(pos.xz)),\n\t\t\t(pos.y+.1-2.4*pow(max(.0,.6-Mesa2(pos.xz)),3.0))*1.0,\n\t\t\t(Mesa(pos.xz)+pos.y*.01-.3)*.5\n\t\t\t+.1*.03*(pos.y/.03-cos(pos.y/.03+Noise(pos.xy).g*2.0))\n\t\t)\n\t\t*mix(2.0,.9,1.0/max(1.0,t*3.0-4.0)); // lower values give more errors in distance but better up close\n}\nfloat DistanceField2( vec3 pos )\n{\n\treturn\n\t\tmin(\n\t\t\t//pos.y+.1-.5*max(.0,.5-Mesa(pos.xz)),\n\t\t\t(pos.y+.1-2.4*pow(max(.0,.6-Mesa2(pos.xz)),3.0))*1.0,\n\t\t\t(Mesa3(pos.xz)+pos.y*.01-.3)*.5\n\t\t\t+.003*(pos.y/.1-cos(pos.y/.1+Noise(pos.xy).g*2.0))\n\t\t);\n}\n\n\nvec3 Shade( vec3 pos, vec3 norm, float dist )\n{\n\tvec3 sunDir = normalize(vec3(1,2,3));\n\tfloat ndotl = dot(norm, sunDir);\n\n\t// shadow\n\tvec2 interval = vec2(.03,(.2-pos.y)/sunDir.y);\n\tfloat shadow = 1.0;\n\tif ( ndotl > 0.0 )\n\t{\n\t\tfloat s = Trace2( pos, sunDir, interval );\n\t\t\n\t\tif ( pos.y < .199 && (s > .0 || DistanceField( pos+interval.x*sunDir, dist ) < .0) )\n\t\t\tshadow = 0.0;\n\t}\n\t\n\t// albedo\n\tvec3 p = pos*vec3(5,100,5);\n\tfloat sedimentary = pow(mix(Noise(p).x,Noise(p*8.0).y,.2),2.0);\n\tvec3 albedoRock = mix( rock, darkRock, sedimentary );\n\t\n\tp = pos*100.0;\n\tp.xy = p.xy*cos(.75)+p.yx*vec2(-1,1)*sin(.75);\n\tp.yz = p.yz*cos(.5)+p.zy*vec2(-1,1)*sin(.5);\n\tfloat scrubPattern = pow((Noise(p).x+Noise(p*2.0).x*.5+Noise(p*16.0).x*.25)/1.75,2.0);\n\tvec3 albedoDirt = mix( dust, scrub, scrubPattern );\n\t\n\tvec3 albedo = mix( albedoRock, albedoDirt, smoothstep(.65,1.0,norm.y) );\n\n\tvec3 ambient = (dot(norm,sunDir*vec3(-1,1,-1))*.5+.5)*ambientColour;\n\t\n\tvec3 lighting = shadow*max(ndotl,.0)*sunColour + ambient;\n\t\n\tvec3 col = albedo*lighting;\n\n\t// fog\n\t// absorb blue faster, by mixing each channel independently\n\tcol = mix( vec3(.5), col, exp2(-dist*atmosphere*2.0));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat T = iTime*.2+iMouse.x*.1;\n\t\n\tvec3 camPos, ray;\n//\tCamPolar(camPos, ray, vec3(T,-.2,0), vec2(-cos(T*.5)*.15+.26,T/8.0), 4.0, 2.0);\n\n\t// better camera path\n\tvec3 look = vec3(T*.1-4.0,-.0,0);\n\tfloat a = -1.0-T/8.0;\n\tcamPos = look + 2.0*vec3(sin(a),0,cos(a));\n\tcamPos.y = /*min( camPos.y,*/ .35-.6*Mesa0(camPos.xz) ;//);\n\tCam( camPos, ray, camPos, look, 2.0, fragCoord );\n\t\n\tvec3 pos = camPos;\n\t\n\t// ray trace against bounding plane on top\n\t// this improves precision and lets us render waaaay into the distance\n\tvec2 interval = vec2(0,10.0);\n\tbool sky = false;\n\tif ( pos.y > .2 )\n\t{\n\t\tif ( ray.y < .0 )\n\t\t\tinterval.x = (pos.y-.2)/(-ray.y);\n\t\telse\n\t\t\tsky = true;\n\t}\n\telse\n\t{\n\t\tif ( ray.y > .0 )\n\t\t\tinterval.y = min( interval.y, (pos.y-.2)/(-ray.y) );\n\t}\n\t\n\tvec3 norm;\n\n\tif ( DistanceField(pos+interval.x*ray, 1.0) <= .0 )\n\t{\n\t\tif ( interval.x > interval.y )\n\t\t\tsky = true;\n\t\t\n\t\tpos = pos + interval.x*ray;\n\t\tnorm = vec3(0,1,0); // if we're inside the pattern, normal is up\n\t}\n\telse\n\t{\n\t\tfloat t = Trace( pos, ray, interval );\n\t\t\n\t\tif ( t <= .0 )\n\t\t\tsky = true;\n\t\t\n\t\tpos = pos+t*ray;\n\t\tnorm = Normal(pos);\n\t}\n\n\tvec3 col;\n\tif ( sky )\n\t{\n\t\tcol = mix( vec3(1), vec3(0), exp2(-(10.0/max(ray.y,.01))*atmosphere/2.5));;\n\t}\n\telse\n\t{\n\t\tcol = Shade( pos, norm, length(pos-camPos) );\n\t}\n\t\n\t// a little post-processing, to make it feel a bit photographic\n\t// vignette\n\tcol *= smoothstep(.65,1.0,localRay.z*localRay.z);\n\n\t// grain\n\tvec3 grainPos = vec3(fragCoord.xy*.8,iTime*30.0);\n\tgrainPos.xy = grainPos.xy*cos(.75)+grainPos.yx*vec2(-1,1)*sin(.75);\n\tgrainPos.yz = grainPos.yz*cos(.5)+grainPos.zy*vec2(-1,1)*sin(.5);\n\tvec2 filmNoise = Noise(grainPos);\n\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .4*pow(filmNoise.y,2.0) );\n\n\t// dust\n\tvec2 uv = fragCoord.xy/iResolution.y;\n\tT = floor( iTime * 60.0 );\n\tvec2 scratchSpace = mix( Noise(vec3(uv*8.0,T)).xy, uv.yx+T, .8 )*1.0;\n\tfloat scratches = texture( iChannel1, scratchSpace ).r;\n\t\n\tcol *= vec3(1.0)-vec3(.3,.5,.7)*pow(1.0-smoothstep( .0, .05, scratches ),2.0);\n\n\t\n\t// brightness, contrast\n\t//col = smoothstep(vec3(.0),vec3(.8),col);\n\tcol = col*1.3-.02;\n\n\tcol = max(vec3(0),col);\n\tfragColor = vec4(ToGamma(col),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdjGRw","date":"1385674885","viewed":1921,"name":"Mesas","username":"TekF","description":"Just sketching.\n\nTry uncommenting #define INTERPOLATION_FIX if the ground has stripy artefacts.","likes":50,"published":1,"flags":0,"usePreview":0,"tags":["distancefield"],"hasliked":0,"parentid":"","parentname":""}}