{"ver":"0.1","info":{"id":"4cdcz7","date":"1730414912","viewed":104,"name":"Dissolving Starburst","username":"scottmas","description":"Attempt to imitate starburst effect when looking at the sun\n","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["sun","star","starburst","sunburst","dissolving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize fragment coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float potential = 0.0;\n\n    // Define the sampling radius in pixels (adjust as needed)\n    const int RADIUS = 100; // Adjust this to change the sampling window size\n    const int STEP = 15; // Adjust the step size for performance/accuracy trade-off\n\n    for(int x = -RADIUS; x <= RADIUS; x += STEP) {\n        for(int y = -RADIUS; y <= RADIUS; y += STEP) {\n            vec2 offset = vec2(float(x), float(y));\n            vec2 otherFragCoord = fragCoord + offset;\n\n            // Ensure the coordinates stay within the screen boundaries\n            if(otherFragCoord.x < 0.0 || otherFragCoord.x >= iResolution.x ||\n               otherFragCoord.y < 0.0 || otherFragCoord.y >= iResolution.y)\n               continue;\n\n            // Calculate distance and ensure it's not zero\n            float distSqr = dot(offset, offset);\n            float distance = sqrt(distSqr);\n            if(distance == 0.0) continue;\n\n            vec2 uvOther = otherFragCoord / iResolution.xy;\n            float weight = texture(iChannel0, uvOther).r;\n            if(weight <= 0.0) continue;\n\n            // Modify potential contribution with a non-linear distance scaling\n            float distanceFactor = 1.0 / pow(distance, 0.5); // Adjust exponent for stronger/weaker effect\n            float potentialContrib = weight * distanceFactor; // Apply modified scaling\n\n            potential += potentialContrib;\n        }\n    }\n\n    float alpha = potential * 0.05; // Adjust this scale factor as needed\n    \n    // Combine the potential with the original color to brighten the star\n    fragColor = vec4(col.x + alpha, col.y + alpha * 0.7, col.z, 1.0);\n   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//A randomized version of DmitRex's starburst shader: https://www.shadertoy.com/view/tlfyRS\n\nfloat GetRotatedScaledEllipseLength( vec2 pos, float angle, vec2 scale )\n{\n    return pow( \n      length( \n        vec2( \n          pos.x * sin( angle ) - pos.y * cos( angle ), \n          pos.x * cos( angle ) + pos.y * sin( angle ) \n        ) * scale \n      ),\n     0.5 );\n}\n\n\nstruct RayParams {\n    float rotation;          // Rotation/Scale factor for GetRotatedScaledEllipseLength\n    vec2 scale;              // Scale vector for GetRotatedScaledEllipseLength\n    float ss2_lower;         // Lower bound for the second smoothstep\n    float ss2_upper;         // Upper bound for the second smoothstep\n    float posLengthFactor;   // Factor for positionLength when calculating rayFade\n};\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 158.5453);\n}\n\nRayParams getRandomRayParams(int rayIndex){\n    // Create a unique seed for each ray based on its index\n    vec2 seed = vec2(float(rayIndex) * 12.9898, float(rayIndex) * 78.233);\n    \n    RayParams ray;\n\n    // Randomize rotation between -0.5 and 3.0\n    ray.rotation = mix(-0.5, 3.0, rand(seed + vec2(0.1, 0.1)));\n    \n    // Randomize scale.x between 10.0 and 20.0\n    float scaleX = mix(2.0, 20.0, rand(seed + vec2(0.2, 0.2)));\n    \n    // Randomize scale.y between 0.8 and 1.25\n    float scaleY = mix(1.5, 2.0, rand(seed + vec2(0.3, 0.3)));\n    ray.scale = vec2(scaleX, scaleY);\n    \n    // Randomize ss2_lower between 0.0 and 0.15\n    ray.ss2_lower = mix(0.0, 0.15, rand(seed + vec2(0.4, 0.4)));\n    \n    // Randomize ss2_upper between 0.85 and 1.0\n    ray.ss2_upper = mix(0.85, 1.0, rand(seed + vec2(0.5, 0.5)));\n    \n    // Randomize posLengthFactor between 0.4 and 1.0\n    ray.posLengthFactor = mix(0.4, 1.0, rand(seed + vec2(0.6, 0.6)));\n        \n    return ray;\n}\n\nvec3 DoStarburst(in vec3 bgcolor, in vec2 SunPosition)\n{\n    vec3 sunColor = vec3(0.96, 0.94, 0.93333);\n    float positionLength = length(SunPosition);\n    \n    // Initialize finalColor with the background color\n    vec3 finalColor = bgcolor;\n    \n    // Define the number of rays\n    const int NUM_RAYS = 10;\n    \n    for(int i = 0; i < NUM_RAYS; ++i)\n    {\n        // Get randomized parameters for the current ray\n        RayParams ray = getRandomRayParams(i);\n        \n        // Calculate the rotated and scaled ellipse length\n        float ellipseLength = GetRotatedScaledEllipseLength(SunPosition, ray.rotation, ray.scale);\n        \n        // Apply the first smoothstep\n        float x = smoothstep(1.0, 0.0, ellipseLength);\n        \n        // Apply the second smoothstep\n        x = smoothstep(ray.ss2_lower, ray.ss2_upper, x);\n\n        \n        // Calculate rayFade\n        float rayFade = clamp(1.0 - positionLength * ray.posLengthFactor * 1.0, 0.0, 1.0);\n        \n        // Mix the colors\n        finalColor = mix(finalColor, sunColor, x * rayFade);\n    }\n    \n    // Clamp the final color to ensure it stays within the valid range\n    return clamp(finalColor, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Oscillation parameters\n    float minScale = 0.4;       // Minimum scale factor\n    float maxScale = 2.0;       // Maximum scale factor\n    float period = 5.0;         // Oscillation period in seconds\n\n    // Calculate the angular frequency\n    float omega = 6.2831853 / period; // omega = 2 * PI / period\n\n    // Calculate the scaleFactor oscillating between minScale and maxScale\n    float scaleFactor = mix(minScale, maxScale, 0.5 * (sin(iTime * omega) + 1.0));\n\n\n    float halfMaxScale = maxScale / 2.0;\n\n    float normScaleFactor;\n    if (scaleFactor > halfMaxScale) {\n        normScaleFactor = 1.0;\n    } else {\n        normScaleFactor = (scaleFactor - minScale) / (halfMaxScale - minScale);\n    }\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 sunCenter = vec2( 0.5 );\n    \n\tvec2 SunPosition = (uv - sunCenter) * scaleFactor;\n    \n    // aspect ratio\n    SunPosition.x *= float( iResolution.x / iResolution.y );\n    \n\tvec3 col = DoStarburst( vec3( 0.0, 0.0, 0.0 ), SunPosition );\n\n    // Output to screen\n    fragColor = vec4(col * normScaleFactor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}