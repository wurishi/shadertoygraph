{"ver":"0.1","info":{"id":"wtjXz3","date":"1566665409","viewed":117,"name":"LiveCodingPractice007(1h)","username":"Hirai_worthless","description":"test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265;\nfloat sTime(float scale){\n\tfloat a = floor(iTime * scale);\n    float b = smoothstep(0.,1.,fract(iTime * scale));\n    return a + b;\n}\nmat2 genRot(float v){\n\t return mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nvec3 modC(vec3 p,vec3 b){\n\tp = (fract(p / b + 0.5)-0.5) * b;\n    return p;\n}\n\nfloat maxEx(vec3 p){\n\treturn max(p.x,max(p.y,p.z));\n}\n\nfloat map(vec3 p){\n    //p.xy = abs(p.xy);\n    float tmp = 2.;\n    p.xy += tmp/2.;\n    p = modC(p,vec3(tmp));\n    vec3 q = p;\n\tfloat sp = length(p) - 0.4;\n    sp = min(sp,length(p.yz) - 0.1);\n    sp = min(sp,length(p.xz) - 0.1);\n    sp = min(sp,length(p.xy) - 0.1);\n    \n    q.xy *= genRot(PI/4.);\n    q.xz *= genRot(iTime);\n    float cb = maxEx(abs(q)) - 0.5;\n    cb = max(cb, -(max(abs(q.x),abs(q.y)) - 0.25));\n    cb = max(cb, -(max(abs(q.x),abs(q.z)) - 0.25));\n    cb = max(cb, -(max(abs(q.z),abs(q.y)) - 0.25));\n\n    return mix(sp,cb,sin(fract(sTime(0.5)) * PI));\n}\nvec3 getNormal(vec3 p){\n\tvec3 x= dFdx(p);\n    vec3 y = dFdy(p);\n    return normalize(cross(x,y));\n}\n\nvec4 trace(vec3 o,vec3 r){\n    float t = 0.;\n    for(int i = 0; i < 96; i++){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    vec3 p = o + r * t;\n    vec3 n = getNormal(p);\n    return vec4(n,t);\n}\n\nvec3 ray(vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n    r.xz *= genRot(PI / 12.);\n    r.yz *= genRot(PI / 12.);\n\n    r.xy *= genRot(cos(sTime(0.125) * PI) * 0.75 * PI);\n    return r;\n}\nvec3 cam(){\n\tvec3 c = vec3(0.,0.,-2.5 + iTime * 4.);\n    return c;\n}\n\nvec3 getColor(vec3 o,vec3 r,vec4 d){\n\tfloat t = d.w;\n    vec3 n = d.xyz;\n    float a = dot(r,n);\n    vec3 bc = vec3(1. - a *0.75);\n    vec3 cc;\n    float at = atan(r.y/r.x) * 2.;\n    cc.x = sin(sTime(1.) + at);\n    cc.y = sin(sTime(1.) + at + PI  *2. / 3.);\n    cc.z = sin(sTime(1.) + at + PI * 4. / 3.);\n    cc = cc * 0.5 + 0.5;\n    vec3 p = o + r * t;\n    cc = fract((length(p.z) + iTime) / 2.) < 0.75 ? cc : vec3(1.);\n    bc *= cc * 1.5;\n\n    float fog = 1./(1. + t * t * 0.05);\n    bc = mix(bc,vec3(0.),1.-fog);\n    return vec3(bc);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.x;\n\tvec3 o = cam();\n    vec3 r = ray(uv,1. * sin(iTime * 0.25));\n    vec4 d = trace(o,r);\n    // Time varying pixel color\n    vec3 col = getColor(o,r,d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}