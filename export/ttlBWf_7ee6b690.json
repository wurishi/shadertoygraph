{"ver":"0.1","info":{"id":"ttlBWf","date":"1597964701","viewed":193,"name":"Box occlusion optimized","username":"clem494949","description":"Analytic box occlusion with half the number of acos calls. It's based on the cube's perimeter instead of the individual faces' perimeter.\nFork of : https://www.shadertoy.com/view/4djXDy","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["box","occlusion","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of: https://www.shadertoy.com/view/4djXDy\n\n//=====================================================\n// Box occlusion (if fully visible)\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    \n    // Orient the hexagon based on p\n    vec3 f = rad * sign(p);\n    \n    // Make sure the hexagon is always convex\n    vec3 s = sign(rad - abs(p));\n    \n    // 6 verts\n    vec3 v0 = normalize( vec3( 1.0, 1.0,-1.0)*f - p);\n    vec3 v1 = normalize( vec3( 1.0, s.x, s.x)*f - p);\n    vec3 v2 = normalize( vec3( 1.0,-1.0, 1.0)*f - p);\n    vec3 v3 = normalize( vec3( s.z, s.z, 1.0)*f - p);\n    vec3 v4 = normalize( vec3(-1.0, 1.0, 1.0)*f - p);\n    vec3 v5 = normalize( vec3( s.y, 1.0, s.y)*f - p);\n    \n    // 6 edges\n    return abs( dot( n, normalize( cross(v0,v1)) ) * acos( dot(v0,v1) ) +\n    \t    \tdot( n, normalize( cross(v1,v2)) ) * acos( dot(v1,v2) ) +\n    \t    \tdot( n, normalize( cross(v2,v3)) ) * acos( dot(v2,v3) ) +\n    \t    \tdot( n, normalize( cross(v3,v4)) ) * acos( dot(v3,v4) ) +\n    \t    \tdot( n, normalize( cross(v4,v5)) ) * acos( dot(v4,v5) ) +\n    \t    \tdot( n, normalize( cross(v5,v0)) ) * acos( dot(v5,v0) ))\n            \t/ 6.283185;\n}\n\n// returns t and normal\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n//-----------------------------------------------------------------------------------------\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p.x, p.y-0.3,-3.5) );\n\t\n    // box animation\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n\tmat4 tra = translate( 0.0, 0.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\tvec3 box = vec3(0.2,0.5,0.6) ;\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = boxOcclusion( pos, nor, txx, txi, box );\n\n        col = vec3(1.1);\n        col *= 1.0 - occ;\n    }\n\n    vec4 res = boxIntersect( ro, rd, txx, txi, box );\n    float t2 = res.x;\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.yzw;\n\t\tcol = vec3(0.8);\n\n\t\tvec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n//\t\tcol *= abs(onor.x)*texture( iChannel1, 0.5+0.5*opos.yz ).xyz + \n  //             abs(onor.y)*texture( iChannel1, 0.5+0.5*opos.zx ).xyz + \n    //           abs(onor.z)*texture( iChannel1, 0.5+0.5*opos.xy ).xyz;\n        col *= 1.7;\n        col *= 0.6 + 0.4*nor.y;\n\t}\n\n\tcol *= exp( -0.05*tmin );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}