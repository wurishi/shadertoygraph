{"ver":"0.1","info":{"id":"mt3XRf","date":"1690172105","viewed":40,"name":"voronoi repeating attempt","username":"SkyanSam","description":"sdsd","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoiunityaaaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.youtube.com/watch?v=vcfIJ5Uu6Qw\nfloat u_gridSize = 3.0;\n\nvec2 noise2x2(vec2 p) {\n  p = mod(p, u_gridSize);\n  float x = dot(p, vec2(123.4, 234.5));\n  float y = dot(p, vec2(345.6, 456.7));\n  vec2 noise = vec2(x, y);\n  noise = sin(noise);\n  noise = noise * 43758.5453;\n  noise = fract(noise);\n  return noise;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n  float aspect = float(iResolution.x) / float(iResolution.y);\n  /*vec3 jResolution = iResolution / 2.0;\n  vec2 jfragCoord = vec2(\n      mod(fragCoord.x, jResolution.x),\n      mod(fragCoord.y, jResolution.y)\n  );*/\n  \n  vec2 jfragCoord = fragCoord;\n  vec3 jResolution = iResolution;\n  vec2 uv = vec2(jfragCoord.x / jResolution.x, jfragCoord.y / jResolution.y);\n  //uv = jfragCoord.xy / jResolution.y;\n\n  vec3 color = vec3(0.0);\n\n  // part 1.1 - set up the grid\n  // clouds thumbnail -> uv = uv * 3.0;\n  uv = uv * u_gridSize;\n  vec2 currentGridId = floor(uv);\n  vec2 currentGridCoord = fract(uv);\n  color = vec3(currentGridCoord, 0.0);\n  currentGridCoord = currentGridCoord - 0.5;\n  color = vec3(currentGridCoord, 0.0);\n\n  // part 1.2 - add red grid to help visualize voronoi noise\n  vec2 redGridUv = currentGridCoord;\n  redGridUv = abs(redGridUv);\n  float distToEdgeOfGridCell = 2.0 * max(redGridUv.x, redGridUv.y);\n\n  // part 1.3 - uncomment one line at a time for explanation\n  color = vec3(distToEdgeOfGridCell);\n  color = vec3(smoothstep(0.5, 1.0, distToEdgeOfGridCell));\n  color = vec3(smoothstep(0.9, 1.0, distToEdgeOfGridCell), 0.0, 0.0);\n\n  // part 1.4 - store this variable for later use\n  vec3 redGridColor = vec3(smoothstep(0.9, 1.0, distToEdgeOfGridCell), 0.0, 0.0);\n\n  // part 2.1 - add a point at the center of each grid\n  float pointsOnGrid = 0.0;\n  float minDistFromPixel = 100.0;\n\n  for (float i = -1.0; i <= 1.0; i++) {\n    for (float j = -1.0; j <= 1.0; j++) {\n      vec2 adjGridCoords = vec2(i, j);\n      vec2 pointOnAdjGrid = adjGridCoords;\n\n      // part 3.1 - vary the points based on time + noise\n      // pointOnAdjGrid = adjGridCoords + sin(u_time) * 0.5;;\n      \n      vec2 cGid = vec2(currentGridId.x / aspect, currentGridId.y);\n      vec2 uCoords = currentGridId + adjGridCoords;\n      //fragColor = vec4(cGid, 0.0, 1.0) / (u_gridSize * 2.0);\n      /*uCoords = vec2(\n          mod(-uCoords.y, u_gridSize), \n          mod(uCoords.y, u_gridSize)\n          );*/\n      /*if (uCoords.y < 0.0) {\n          uCoords.y = u_gridSize - 1.0;\n      }\n      else if (uCoords.y >= u_gridSize) {\n          uCoords.y = 0.0;\n      }\n      if (uCoords.x < 0.0) {\n          uCoords.x = u_gridSize * aspect - (1.0 * aspect);\n          //fragColor = vec4(1,1,0,0);\n      }\n      else if (uCoords.x >= u_gridSize * aspect) {\n          uCoords.x = 0.0;\n          //fragColor = vec4(1,0,1,0);\n      }*/\n      \n      vec2 noise = noise2x2(uCoords);\n      pointOnAdjGrid = adjGridCoords + sin(iTime * noise) * 0.5;\n\n      float dist = length(currentGridCoord - pointOnAdjGrid);\n      minDistFromPixel = min(dist, minDistFromPixel);\n\n      pointsOnGrid += smoothstep(0.95, 0.96, 1.0 - dist);\n    }\n  }\n\n  // part 2.2 - draw white points on grid for reference\n  vec3 pointsOnGridColor = vec3(pointsOnGrid);\n  color = redGridColor + pointsOnGridColor;\n  color = redGridColor + pointsOnGridColor + minDistFromPixel;\n  color = redGridColor + minDistFromPixel;\n\n  // part 3.2 - display voronoi noise\n  //color = vec3(minDistFromPixel);\n  color = vec3(smoothstep(0.0, 2.0, minDistFromPixel));\n\n  // part 3.3 - display clouds\n  //color = vec3(smoothstep(0.25, 1.0, 1.0 - minDistFromPixel));\n\n  // part 3.4 - display clouds with dots\n  //color = vec3(smoothstep(0.0, 2.0, minDistFromPixel)) + pointsOnGridColor;\n\n  // part 4 - create display for final section\n  // if (uv.x > 4.745) {\n  //   color = pointsOnGridColor + vec3(smoothstep(0.0, 1.0, minDistFromPixel));\n  // } else {\n  //   color = vec3(smoothstep(0.1, 1.0, 1.0 - minDistFromPixel)) - pointsOnGridColor;\n  // }\n\n  fragColor = vec4(color, 1.0);\n  //fragColor = vec4(currentGridId, 0.0, 1.0) / (u_gridSize * 2.0);\n}","name":"Image","description":"","type":"image"}]}