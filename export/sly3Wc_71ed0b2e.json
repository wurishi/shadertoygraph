{"ver":"0.1","info":{"id":"sly3Wc","date":"1638545996","viewed":120,"name":"Game of life Interactive!","username":"Nordaa","description":"Interactive Game of life  based on Intro to Game of life used to create some sweet visual effects","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["2d","simple","game","interactive","automata","life","reference","cellular","buffer","gameoflife","gameoflife","multipass","gol","gol"],"hasliked":0,"parentid":"MtdXRn","parentname":"Introduction to Game of Life"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    This is a forked project starting with base impolementation of Introduction to Game of Life ( https://www.shadertoy.com/view/MtdXRn)\n    \n \n    \n    Hotkeys:\n    Z + Mouse click = Zoom\n    X + Mouse click = Paint \n    \n    ## Press space once then key to start using generators ##\n    Q = multi segment spinner\n    W = radial waves\n    R = single segment spinner\n    \n    1 = enable/disable colors\n    2 = radial elimination wave\n    3 = GoL rule change -> makes expansion faster then destruction\n    4 = Change colors\n    \n    B = blur effect\n    N = bleed effect\n\t \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.f);\n   \n    \n    /*\n       Zoom on Z key pressed\n    */\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    const float zoom_face = 4.0;\n    bool z_pressed = texelFetch( iChannel2, ivec2(KEY_Z, 0), 0 ).x > 0.;\n    if( z_pressed ) {\n        uv += mousePos.xy * (zoom_face - 1.);\n        uv /= zoom_face;\n    }\n    \n    color += texture(iChannel0, uv).rgb;\n    \n    \n\tfragColor = vec4(color , 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void revive(inout vec4 texel, in vec3 color, float alive) {\n    texel.rgb = color * alive;\n    texel.a = 1.0 * alive;\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 o_color = vec4(0.0);\n    vec3 color = vec3(1.);\n    float alpha = 0.0;\n    float cell = texture(iChannel0, uv).x;\n    if (true) { //mod(iTime, 0.1) < 0.01) {\n\n        vec2 tex_size = vec2(1.) / iResolution.xy;\n        vec4 mouse = iMouse;\n        mouse.xy /= iResolution.xy;\n\n        float neighbors = 0.0;\n\n        const float grid_radius = 1.0;\n        for(float i = -grid_radius; i <= grid_radius; i += 1.0)\n        {\n            for( float j = -grid_radius; j <= grid_radius; j += 1.0)\n            {\n                vec2 offset = vec2(i, j) / iResolution.xy;\t\t \n                vec4 lookup = texture(iChannel0, uv + offset); \n                neighbors += lookup.a;\t\t\t\t\n            }\n        }\n\n        /*\n            Color based on neighbourcount\n        */\n        if (texelFetch( iChannel2, ivec2(KEY_ONE,2), 0).x == 0.0) {\n            if (texelFetch( iChannel2, ivec2(KEY_FOUR,2), 0).x == 0.0) {\n                color = hsv2rgb_smooth(vec3(uv.x * 2.0, 0.5, 1.0));\n            } else {\n                color = hsv2rgb_smooth(vec3(0.18,0.5,1.0));\n            }\n        }\n\n        //color = hsv2rgb_smooth(vec3(neighbors * 1. / 4., 1.0, 1.0));\n\n        /*\n            RULES:\n            1. Any live cell with two or three live neighbours survives.\n            2. Any dead cell with three live neighbours becomes a live cell.\n            3. All other live cells die in the next generation. Similarly, all other dead cells stay dead.\n        */\n        float lower_bound = 3.0 + texelFetch( iChannel2, ivec2(KEY_D,2), 0).x;;// + cos(iTime*0.15);\n        float upper_bound = 4.0 + texelFetch( iChannel2, ivec2(KEY_THREE,2), 0).x;// + sin(iTime*0.15) + 1.0;\n\n        if(cell > 0.0) {\n            if(neighbors >= lower_bound && neighbors <= upper_bound) {\n                revive(o_color, color, 1.0);\n            }\n        } else if(neighbors > 2.0 && neighbors < 4.0) {\n            revive(o_color, color, 1.0);\n        }\n\n        /*\n            CUSTOM RULES:\n        */\n        if (texelFetch( iChannel2, ivec2(KEY_TWO,2), 0).x > 0.0) {\n            if(cell > 0.0) { \n                float d = length(uv - mouse.xy);\n                d = d - iTime*0.15;\n                d = mod(d, 0.2);\n\n                if(d < 0.01) {\n                    o_color = vec4(0.f);\n                }\n            }\n        }\n\n\n        /*\n            Mouse press to review\n        */\n        bool x_pressed = texelFetch( iChannel2, ivec2(KEY_X, 0), 0 ).x > 0.;\n        if( mouse.z>0.0 && x_pressed) {\n            // Dot\n            if (length(uv-mouse.xy)< tex_size.y){\n                revive(o_color, color, 1.0);\n            }\n            // shape\n            /*\n            for (float i = 0.; i < 9.; i = i + 1.) {\n                float filled = c_shape_boat[int(i)];\n                vec2 dist = uv-mouse.xy;\n                if (filled > 0. &&  \n                    abs(dist.x) >= tex_size.x * (i-1.) &&\n                    abs(dist.x) <= tex_size.x * (i) &&\n                    dist.y <= tex_size.y &&\n                    dist.y >= -tex_size.y * 150.\n                    ) {\n                    revive(o_color, color, 1.0);\n                }\n            }\n            */\n        }\n    } else {\n        o_color = vec4(cell);\n    }\n    \n    /*\n        Reset Game of Life\n    */\n    bool space_pressed = !(texelFetch( iChannel2, ivec2(KEY_SPACE,2), 0 ).x > 0.);\n    if(iTime < 1.0 || space_pressed) {\n        float alive = texture(iChannel1, fragCoord.xy / iResolution.xx).x;\n        o_color.rgb += alive * vec3(1.0);\n        alive += o_color.a;\n        revive(o_color, color, alive);\n        o_color *= 1.0 - texelFetch( iChannel2, ivec2(KEY_C, 0), 0 ).x;\n    }\n    \n    fragColor = o_color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int KEY_SPACE  = 32;\nconst int KEY_Q  = 81;\nconst int KEY_W  = 87;\nconst int KEY_D  = 68;\nconst int KEY_E  = 69;\nconst int KEY_B  = 66;\nconst int KEY_R  = 82;\nconst int KEY_C  = 67;\nconst int KEY_N  = 78;\n\nconst int KEY_X  = 88;\nconst int KEY_Z  = 90;\n\nconst int KEY_ONE     = 49;\nconst int KEY_TWO     = 50;\nconst int KEY_THREE   = 51;\nconst int KEY_FOUR    = 52;\nconst int KEY_FIVE    = 53;\nconst int KEY_SIX     = 54;\nconst int KEY_SEVEN   = 55;\n\n\nconst float gauss_fac_s = 1./16.;//1./16.;\nconst float[] gauss_kernel_s = float[](\n    1., 2., 1.,\n    2., 4., 2.,\n    1., 2., 1.\n);\n\nvec3 gaussian_blur_s(in sampler2D sampler, in vec2 uv, in vec2 resolution, in float step_size) {\n    vec3 color = vec3(0);\n    const float grid_radius = 1.0;\n    for(float i = -grid_radius; i <= grid_radius; i += 1.0)\n    {\n        for( float j = -grid_radius; j <= grid_radius; j += 1.0)\n        {\n        \tvec2 offset = vec2(i, j) / resolution;\t\t \n        \tvec3 tex_color = texture(sampler, uv + offset * step_size).rgb; \n        \tcolor += tex_color * gauss_kernel_s[int(i + grid_radius) + int(j + grid_radius) * int(grid_radius * 2.0 + 1.0)];\n        }\n    }\n    color *= gauss_fac_s;\n    return color;\n}\n\nconst float gauss_fac_m = 1./100.;//1./273.;\nconst float[] gauss_kernel_m = float[](\n    1., 4.,   7.,  4., 1.,\n    4., 16., 26., 16., 4.,\n    7., 26., 41., 26., 7.,\n    4., 16., 26., 16., 4.,\n    1., 4.,   7.,  4., 1.\n);\n\nvec3 gaussian_blur_m(in sampler2D sampler, in vec2 uv, in vec2 resolution, in float step_size) {\n    vec3 color = vec3(0);\n    const float grid_radius = 2.0;\n    for(float i = -grid_radius; i <= grid_radius; i += 1.0)\n    {\n        for( float j = -grid_radius; j <= grid_radius; j += 1.0)\n        {\n        \tvec2 offset = vec2(i, j) / resolution;\t\t \n        \tvec3 tex_color = texture(sampler, uv + offset * step_size).rgb; \n        \tcolor += tex_color * gauss_kernel_m[int(i + grid_radius) + int(j + grid_radius) * int(grid_radius * 2.0 + 1.0)];\n        }\n    }\n    color *= gauss_fac_m;\n    return color;\n}\n\nconst float[] c_shape_boat = float[](\n    1., 0., 1.,\n    0., 0., 0.,\n    1., 0., 1.\n);\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.f);\n    vec4 texel = vec4(0.f);\n    bool space_pressed = texelFetch( iChannel2, ivec2(KEY_SPACE,0), 0 ).x > 0.;\n    if (true || !space_pressed)\n    {\n        /*\n            Sphere\n        */\n        texel = texture(iChannel0, uv);\n        vec4 prevFrame = texture(iChannel1, uv);\n        \n        float bleedSpeed = 0.9;\n        vec3 bleed = prevFrame.rgb * bleedSpeed * texelFetch( iChannel2, ivec2(KEY_N,2), 0).x;\n        color = texel.rgb + bleed;\n\n        /*\n            Gaussian blur small\n        */\n        if (texelFetch( iChannel2, ivec2(KEY_B,2), 0).x > 0.0) {\n            color = gaussian_blur_m(iChannel0, uv, iResolution.xy, 1.) + bleed;\n        }\n        \n    }\n    \n\tfragColor = vec4(color , 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Credits to source: Segment -> https://www.shadertoy.com/view/MlcGDB\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\n\nvec2 rotate_point(in vec2 p, in float a) {\n    p.x *= cos(a) - sin(a);\n    p.y *= sin(a) + cos(a);\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.);\n   \n    if (texelFetch(iChannel2, ivec2(KEY_Q,2), 0).x > 0.0) {\n        float d = 0.f;\n        float seg_count = 50.;\n        for (float i=0.; i < seg_count - sin(iTime * 0.5) * seg_count; i+=1.) {\n            // Start point\n            vec2 p0 = vec2(0.5+sin(iTime* 0.25)*0.5, 0.25+sin(iTime * 0.25)*0.1*cos(iTime * 2.0));\n            // End point\n            float x = cos(iTime + i*sin(iTime*0.15)*cos(iTime*0.238));\n            float y = 0.2+5.0*i*cos(iTime)*sin(iTime*0.55)/seg_count;\n            vec2 p1 = vec2(x, y)*0.1;\n            \n            // Rotate\n            p1 = rotate_point(p1, iTime * 0.25);\n            \n            d += segment(uv, p0 + p1, p0, 2.0 / iResolution.x);\n        }\n        color += vec3(d);\n    }\n    \n     if (texelFetch(iChannel2, ivec2(KEY_R,2), 0).x == 0.0) {\n        float d = 0.f;\n        float seg_count = 1.;\n        for (float i=0.; i < seg_count; i+=1.) {\n            // Start point\n            vec2 p0 = vec2(0.5+sin(iTime* 0.25)*0.5, 0.25+sin(iTime * 0.25)*0.1*cos(iTime * 2.0));\n            // End point\n            float x = 0.4;\n            float y = 0.6;\n            vec2 p1 = vec2(x, y)*0.1;\n            \n            // Rotate\n            p1 = rotate_point(p1, iTime * 2.5);\n            \n            d += segment(uv, p0 + p1, p0, 2.0 / iResolution.x);\n        }\n        color += vec3(d);\n    }\n    \n    \n    if (texelFetch(iChannel2, ivec2(KEY_W,2), 0).x > 0.0) {\n        vec2 normMousePos = iMouse.xy/iResolution.xy;\n        normMousePos.y -= 0.5;\n        const float thickness = 0.01;\n        const float speed = 0.10;\n        float d = length(normMousePos - uv);\n        d = d - iTime*speed;\n        d = mod(d, 0.2);\n        d = float(d < thickness);\n        \n        \n        color += vec3(d);\n    }\n     \n    fragColor = vec4(color,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}