{"ver":"0.1","info":{"id":"XtKBRc","date":"1572716550","viewed":56,"name":"Raymarching LOG01","username":"oktomus","description":"I'm just learning.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.000001\n\n#define SHOW_HEAT_MAP\n#define PI 3.14159265\n\nvec3 rotateX(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x, x.y * c - x.z * s, x.z * c + x.y * s);\n}\n\nvec3 rotateY(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x * c - x.z * s, x.y, x.z * c + x.x * s);\n}\n\nvec3 rotateZ(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x * c - x.y * s, x.y * c + x.x * s, x.z);\n}\n\nvec3 map(vec3 begin, vec3 end, float t) {\n    return (1.0 - t) * begin + t * end;\n}\n\nfloat dist_to_sphere(vec3 p, vec3 center, float radius)\n{\n    return length(p - center) - radius;\n}\n\nfloat dist_to_plane(vec3 p,vec4 normal)\n{\n    return dot(p, normal.xyz) + normal.w;\n}\n\nfloat dist_union(float d1, float d2) {  return min(d1,d2); }\nfloat dist_union(float d1, float d2, float d3) {  return min(d1,min(d2,d3)); }\nfloat dist_union(float d1, float d2, float d3, float d4) {  return min(d4, min(d1,min(d2,d3))); }\n\nfloat scene_dist(vec3 p) {\n\treturn \n        dist_to_sphere(p, vec3(0.0, 0.0, sin(iTime) * 5.0 + 10.0), 1.0);           \n}\n\nvec3 scene_normal(vec3 p) {\n    return normalize(vec3(\n        scene_dist(vec3(p.x + EPS, p.y, p.z)) - scene_dist(vec3(p.x - EPS, p.y, p.z)),\n        scene_dist(vec3(p.x, p.y + EPS, p.z)) - scene_dist(vec3(p.x, p.y - EPS, p.z)),\n        scene_dist(vec3(p.x, p.y, p.z  + EPS)) - scene_dist(vec3(p.x, p.y, p.z - EPS))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n\n    float fovDegrees = 40.0;\n    float fovRadians = fovDegrees / 180.0 * PI;\n    float fovTan = tan(fovRadians / 2.0);\n    vec3 eyeDir = normalize(vec3(uv * fovTan, 1.0));\n    //eyeDir = vec3(0.0, 0.0, 1.0);\n\n    float camRotX = (iMouse.y / iResolution.y * 2.0 - 1.0) * PI;\n    float camRotY = (iMouse.x / iResolution.x * 2.0 - 1.0) * PI;\n    float camRotZ = 0.0;\n    \n    eyeDir = rotateZ(eyeDir, camRotZ);\n   \teyeDir = rotateX(eyeDir, camRotX);\n    eyeDir = rotateY(eyeDir, camRotY);\n    \n    vec3 eyePos = vec3(0.0, 0.0, 0.0);\n    //eyePos = rotateX(eyePos, camRotX);\n    //eyePos = rotateY(eyePos, camRotY);\n    \n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st = (st * 2.0) - 1.0;\n    \n    vec3 color = vec3(0.);\n    vec3 rpos = vec3(uv.x, uv.y, 0.0);\n        \n    const float t_min = 0.5;\n    const float t_max = 100.0;\n    float t = t_min;\n    const int max_iterations = 10;\n\n\n    int iterations;\n    float it_step = 0.0;\n    float last_dist = 1000.0;\n    float best_match = t_max;\n    float best_match_t = t;\n    \n    vec3 high_sky = vec3(0.8, 0.7, 0.8) * 0.5;\n    vec3 lower_sky = vec3(0.7, 0.4, 0.2) * 0.3;\n    \n    color = map(lower_sky, high_sky, st.y);\n    \n    for (iterations = 0; iterations < max_iterations; ++iterations) {        \n        float signed_dist = scene_dist(rpos + eyeDir * t);\n        float dist = abs(signed_dist);               \n        \n        last_dist = dist;\n        float error = dist / t;\n        \n       \t// Is this closer to what we got so far ?\n        if (error < best_match)\n        {\n            best_match = error;\n            best_match_t = t;\n        }\n        \n        if (error < EPS || t > t_max)\n            break;\n\t\t\n        t += dist;\n    }        \n    \n    bool hit = t <= t_max && best_match <= EPS;\n    if (hit)\n    {\n        color = vec3(0.0, 1.0, 0.0);\n    }\n\n    \n#ifdef SHOW_HEAT_MAP    \n    color = map(\n        vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), \n        float(iterations) / float(max_iterations));\n#endif    \n\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}