{"ver":"0.1","info":{"id":"tsByRh","date":"1586079662","viewed":128,"name":"Iterative Bouncing - Spheres","username":"amhall","description":"Iteratively bouncing rays in ray marching rendered on a scene of spheres. See TODOs to reduce anti-aliasing and bounces to speed up rendering.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres","bouncing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray marching limits\nconst float epsilon = 0.0075;\nconst float maxDistance = 30.0; // This is per bounce rather than total\nconst int maxIterations = 100;\n\n// Supersample\nconst int supersample = 1;\nconst int samplesPerPixel = supersample * supersample;\nconst float sampleWeight = 1.0 / float(samplesPerPixel);\nconst float ssIncrement = 1.0 / float(supersample);\nconst float ssOffset = ssIncrement / 2.0 - 0.5;\n\n// Camera/Light\nvec3 cameraPos; // Set in mainImage(...)\nvec3 lightPos; \nconst vec3 lightIntensity = vec3(1200.0);\n\n// Light constants\nconst float kAmbient = 0.15;\nconst float kDiffuse = 1.0;\nconst float kSpecular = 1.0;\nconst float specularExponent = 8.0;\n\n// Bounce\nconst int maxBounces = 3; // TODO change the number of bounces calculated\nconst float bounceWeight = 0.55; // Percentage of color that the new bounce will occupy\n\n// Sphere at (0, 0, 0), r = 0.85\nconst vec3 spherePos = vec3(0.0, 0.0, 0.0);\nconst float sphereRadius = 1.45;\nconst float sphereCycle = 4.0; // Dimensions of repeating box\nconst vec3 sphereOffset = vec3(sphereCycle/2.0, sphereCycle/2.0, sphereCycle/2.0); // Offset from center to corner of repeating box\nconst vec3 sphereColor = vec3(0.1, 0.6, 1.0);\n\nconst vec3 fogColor = vec3(0.7, 0.8, 1.0);\n\n// (Repeating) sphere signed distance function\nfloat sphereSDF(vec3 point)\n{\n\t// Calculate point within repeating box\n\tpoint += sphereOffset;\n\tpoint = mod(point, sphereCycle);\n\tpoint -= sphereOffset;\n\treturn length(spherePos - point) - sphereRadius;\n}\n\n// Minimum distance to scene - currently just using spheres\nfloat minDistance(vec3 point) {\n \treturn sphereSDF(point);   \n}\n\n// Approximates the normal at an intersection by calculating the gradient\nvec3 estimateNormal(vec3 point) {\n\treturn normalize(vec3(\n        minDistance(vec3(point.x + epsilon, point.y, point.z)) - minDistance(vec3(point.x - epsilon, point.y, point.z)),\n        minDistance(vec3(point.x, point.y + epsilon, point.z)) - minDistance(vec3(point.x, point.y - epsilon, point.z)),\n        minDistance(vec3(point.x, point.y, point.z  + epsilon)) - minDistance(vec3(point.x, point.y, point.z - epsilon))\n    ));\n}\n\n// Linear interpolate a vec3 based on (clamped) decimal\n// Lower weight shifts to a, higher weight shifts to b\nvec3 lerp(vec3 a, vec3 b, float weight) {\n\tweight = clamp(weight, 0.0, 1.0);\n\treturn (1.0 - weight) * a + weight * b;\n}\n\n// Returns the direction of a ray bounce based on the incident ray and surface normal\n// Ray direction and normal should already be normalized by other parts of the code so they are\n// assumed to be normal\nvec3 getBounceDirection(vec3 incidentRay, vec3 normal) {\n    // This calculation should result in a unit vector, so no need to normalize\n \treturn incidentRay - 2.0 * normal * dot(incidentRay, normal);\n}\n\n// Returns the shaded color based on the original surface color\n// Only does ambient and diffuse shading\nvec3 shadePoint(vec3 point, vec3 normal, vec3 color) {\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\t\n\t// Ambient\n\tresult += color * kAmbient;\n\t\n\tvec3 toLight = lightPos - point;  \n\tvec3 falloff = lightIntensity / dot(toLight, toLight);\n    toLight = normalize(toLight);\n    \n    vec3 toCamera = normalize(cameraPos - point);\n    vec3 viewAngleBisector = normalize(toLight + toCamera);\n\t\n    // Diffuse\n\tresult += kDiffuse * color * falloff * max(0.0, dot(normal, toLight));\n\tresult += kSpecular * falloff * pow(max(0.0, dot(normal, viewAngleBisector)), specularExponent);\n    \n\treturn result;\n}\n\n// Returns the color of casting a ray from rayOrigin in rayDirection\n// Normalizes ray direction\nvec3 castRay(vec3 rayOrigin, vec3 rayDirection)\n{\n\tvec3 color = fogColor;\n\t\n\tvec3 testPoint = rayOrigin; // Point to test distance function at\n\trayDirection = normalize(rayDirection);\n    \n    // Result colors and distances for each cast\n    vec3[maxBounces + 1] results;\n    float[maxBounces + 1] distances;\n    \n    // The index of current cast\n    int castIndex;\n    int lastCastIndex;\n    \n    for (castIndex = 0; castIndex <= maxBounces; castIndex++)\n    {\n        lastCastIndex = castIndex;\n\t\tbool hit = false; // Flag to test if this iteration hit\n        \n        // The result color of this cast\n        vec3 resultColor = fogColor;\n        \n        float tCurrent = 0.0; // Scalar of rayDirection from testPoint (i.e. t for current iteration)\n    \tfloat tTotal = 0.0; // Scalar of rayDirection from rayOrigin (i.e. total t)\n        \n        for (int i = 0; i < maxIterations && tTotal < maxDistance; i++)\n        {\n            tCurrent = minDistance(testPoint);\n            if(tCurrent < epsilon) // HIT\n            { \n                hit = true;\n                \n                vec3 hitNormal = estimateNormal(testPoint);\n\n                resultColor = shadePoint(testPoint, hitNormal, sphereColor); // shade result\n                \n                // Calculate new ray direction\n                rayDirection = getBounceDirection(rayDirection, hitNormal);\n\n                // March ray slightly more than the epsilon away from the hit point\n                testPoint = testPoint + rayDirection * epsilon * 1.1;            \n\n                break;\n            }\n            testPoint += tCurrent * rayDirection; // March ray\n            tTotal += tCurrent;\n        }\n        // Store color and distance results\n        results[castIndex] = resultColor;\n        distances[castIndex] = tTotal;\n\n        // Stop recursing if we don't hit anything\n        if(!hit) {\n            break;\n        }\n    }\n    \n    // Go backwards to calculate bounce colors with fog fades\n    for(int i = lastCastIndex; i >= 0; i--)\n    {\n        float fogWeight = distances[i] / maxDistance;\n        \n        // Blend hit color with fog if we are at last cast,\n        // otherwise do bounce blend then fog blend\n        if(i == lastCastIndex) {\n         \tcolor = lerp(results[i], fogColor, fogWeight);\n        }\n        else {\n            vec3 colorWithBounce = lerp(results[i], color, bounceWeight);\n            color = lerp(colorWithBounce, fogColor, fogWeight);\n        }\n    }\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // CAMERA AND LIGHTS\n\tfloat zOffset = 0.9*iTime; // Move camera and lights backward over time\n\t\n\t// Move camera and light backward\n\tcameraPos = vec3(sphereOffset.xy, zOffset);\n\tlightPos = vec3(22.0, 22.0, zOffset + 22.0);\n\n    // Assume camera is always upright and pointed in -z direction\n\t\n\t// Field of view in shortest axis\n\tfloat fov = 60.0;\n    float scale = tan(radians(fov/2.0));\n    float limit = min(iResolution.x, iResolution.y); // Limiting dimension for FOV\n    \n    // Initialize sample coord and color for supersampling\n    vec2 sampleCoord = fragCoord + ssOffset;\n    vec3 color = vec3(0.0);\n    \n    for(int j = 0; j < supersample; j++) {\n        for(int i = 0; i < supersample; i++)\n        {\n            // Normaize pixel coordinate such that y is in [-1, 1]\n            vec2 rayXY = (2.0 * sampleCoord - iResolution.xy) / limit;\n\n            // Scale coordinate based on camera FOV, then create ray pointing at -Z\n            vec3 rayDirection = vec3(rayXY *= scale, -1.0);\n            \n            color += sampleWeight * castRay(cameraPos, rayDirection);\n            sampleCoord.x += ssIncrement;\n        }\n        // Reset x, increment y\n        sampleCoord.x = fragCoord.x + ssOffset;\n        sampleCoord.y += ssIncrement;\n    }\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}