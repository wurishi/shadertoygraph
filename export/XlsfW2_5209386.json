{"ver":"0.1","info":{"id":"XlsfW2","date":"1513384801","viewed":280,"name":"subsurface scatter attempt","username":"mds2","description":"ugly attempt at subsurface scatter effect.  Decided to add in some refraction and a touch of surface reflection just to give the shape volume.  Then I set it to music, because I set everything to music.  Thanks for adding music, IQ!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ugly","sdf","subsurface","scatter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" float cyl_length = 2.0;\n float cyl_rad = 0.8;\n float curve_rad = 0.2;\nconst vec3 cyl_center = vec3(0.1, 0.0, -1.0);\n\nfloat cyl_sdf(in highp vec3 point) {\n    vec3 cyl_dir =\n        vec3(sin(0.1 * iTime) * cos(0.33 * iTime),\n             sin(0.33*iTime),\n             cos(0.1 * iTime) * cos(0.33 * iTime));\n\tvec3 rel = point - cyl_center;\n    float along = dot(rel, cyl_dir);\n    vec3 across = rel - cyl_dir * along;\n    return length(max(vec2(length(across) - cyl_rad + curve_rad,\n                  \t       abs(along) - 0.5 * cyl_length + curve_rad),\n                     0.0)) - curve_rad;\n}\n\nvec3 cyl_norm(in highp vec3 point) {\n\tfloat v = cyl_sdf(point);\n    return normalize(vec3(v + cyl_sdf(point + vec3(0.01, 0.00, 0.00)),\n                          v + cyl_sdf(point + vec3(0.00, 0.01, 0.00)),\n                          v + cyl_sdf(point + vec3(0.00, 0.00, 0.01))));\n}\n\nfloat cyl_isect(in highp vec3 ray_orig, in highp vec3 ray_dir) {\n\tfloat result = 0.0;\n    vec3 p = ray_orig;\n    float last_d = 20.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = cyl_sdf(p);\n        result += d;\n        p += d * ray_dir;\n        last_d = d;\n    }\n    if (last_d > 1.0e-3) {\n        return -1.0; // miss\n    }\n    return result;\n}\n\nfloat dist_out_of_cyl(in highp vec3 ray_orig, in highp vec3 ray_dir) {\n\n    float result = 0.1;\n    vec3 p = ray_orig + 0.1 * ray_dir;\n    for (int i = 0; i < 64; ++i) {\n        float d = -0.8 * cyl_sdf(p);\n        result += d; // d may be negative\n        p += d * ray_dir;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float texture_y = 0.0;\n    float val1 = \n        texture(iChannel0, vec2(0.2, texture_y)).r + \n        texture(iChannel0, vec2(0.4, texture_y)).r;\n    float val2 =\n        texture(iChannel0, vec2(0.6, texture_y)).r +\n        texture(iChannel0, vec2(0.8, texture_y)).r;\n    cyl_length = 0.5 * (1.0 + 3.0 * val1);\n    cyl_rad = sqrt(4.0 / cyl_length);\n curve_rad = 0.5 * (1.0 + val2) * min(0.9 * cyl_rad, 0.4 * cyl_length);\n    // cyl_rad -= curve_rad;\n    //cyl_length -= 2.0 * curve_rad;\n    const vec3 scatter_color = vec3(1.0, 0.4, 0.1);\n    const vec3 rough_color = vec3(1.0, 0.8, 0.1);\n    vec3 light_loc =\n        //5.0 * vec3(sin(iTime), 1.0, cos(iTime) + 0.5);\n        vec3(5.0, 2.0, -1.0);\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 ray_orig = vec3(0.0, 0.0, 2.0);\n    vec3 ray_dir = normalize(vec3(uv, -1.0));\n    \n    float d = cyl_isect(ray_orig, ray_dir);\n    float eta = 0.16;\n    if (d > 0.0) {\n    \tvec3 p = ray_orig + d * ray_dir;\n        \n        vec3 light_dir = normalize(light_loc - ray_orig);\n\n        vec3 n = cyl_norm(p);\n        vec3 b = reflect(ray_dir, n);\n        float diffuse = smoothstep(0.9, 1.0, dot(b, light_dir));\n        \n        vec3 refr_ray = normalize(refract(ray_dir, n, eta));\n        float refr_d = dist_out_of_cyl(p, refr_ray);\n        vec3 refr_p = p + refr_d * refr_ray;\n        vec3 refr_n = -cyl_norm(refr_p);\n        refr_ray = normalize(refract(refr_ray, refr_n, 1.0 / eta));\n        vec3 refr_light_dir = normalize(light_loc - refr_p);\n        float refracted = smoothstep(0.9, 1.0, dot(refr_ray,\n                                                   refr_light_dir));\n        \n        float d = dist_out_of_cyl(p, light_dir);\n        float subsurface = exp(-1.0 * d);\n\t\tfragColor = vec4(subsurface * scatter_color +\n                         diffuse * rough_color +\n                         refracted * vec3(0.2),1.0);\n\n    } else {\n        vec3 light_dir = normalize(light_loc - ray_orig);\n\t\tfragColor = vec4(0.5 * vec3(smoothstep(0.9, 1.0, dot(ray_dir,\n                                                       light_dir))),1.0);\n    }\n        // fragColor = texture(iChannel0, ray_dir);\n}","name":"Image","description":"","type":"image"}]}