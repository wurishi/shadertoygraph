{"ver":"0.1","info":{"id":"4syyRy","date":"1522355746","viewed":175,"name":"Emissive plasma.","username":"Pr0fed","description":"More tweaking of  https://www.shadertoy.com/view/XdKyWm \nAny ideas on reducing the jitter and adding some kind of blur are aprecciated.\nI understand that it is probably because of noise , and might really be hard to clean somehow.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Just another generative piece of 'art' (lol), for FBM and noise training purpose.\n\n\n// \"replace this by something better\" (IQ said).\n// and i'm really not yet sure what is 'better'.\n// Better means faster? Or better distribution? \nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.318653, 0.3673123 );\n    x = x * k + k.yx;\n    \n    // Earlier version, too noisy now. You have to lower\n    // values on 72 and 79 and 88 to get ~ initial result.\n    // It was not such big as if you uncomment this now, but\n    // really a lot more than smooth version. \n    \n    // So smoothstepping a noise is cool if you can improve \n    // a picture after it, without adding more. Nice!\n    \n    //return -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y)));\n    \n    // A bit smoother version, with less jitter.\n    return smoothstep(0.0, 1.15, -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y))));\n}\n\n// Simple 2D gradient noise taken from you know where: https://www.shadertoy.com/view/XdXGW8\n// Thx IQ :)\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Rotation matrix, it does a big impact, as usual.\nconst mat2 m = mat2( 1.20,  1.00, -1.00,  1.20 );\n\n// Four octave FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise2D( p ); p = p * 2. * m;\n    f += 0.2500 * noise2D( p ); p = p * 2. * m;\n    f += 0.1250 * noise2D( p ); p = p * 2. * m;\n    f += 0.0625 * noise2D( p );\n    return f;\n}\n\n// Six octave FBM.\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.250000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.125000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.062500 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.031250 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.015625 * (0.5 + 0.5 * noise2D( p ));\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron)\n{\n    // Waves motion.\n    float ql = length( q.y );\n    q += 0.05 * (0.5 + 0.5 * sin(iTime + ql * 1.05));\n\n    // First point.\n    vec2 o;\n    \n    // Vice versing fbm's addition for points gives nice result.\n    o = vec2(fbm4(q + fbm6( vec2(2.0 * q + vec2(6.)))));\n\n    // Second point.\n    vec2 n;\n    n = vec2(fbm6(q + fbm4( vec2(4.0 * o + vec2(2.)))));\n\n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 8.0 * n;\n    float f = 0.5 + 0.5 * fbm6( p );\n\n    // I have seen that cubic mixing a couple of times\n    // is it just gives a nice result, or there is something\n    // behind it? Anyone?\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    // Really just a magic which i've seen in IQ's https://www.shadertoy.com/view/lsl3RH.\n    float g = 0.5 + 0.5 * sin(5.0 * p.x) * sin(5.0 * p.y);\n    f *= 1.0 - 0.55 * pow( g, 16.0 ) * f;\n    \n\tron = vec4( o, n );\n\n    return f;\n}\n\n// Main color mixing function.\nvec3 GetColor(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    \n    float f = GetFBM(p, on);\n    \n    vec3 col = vec3(0.0);\n    \n    col = mix( vec3(0.78, 0.0, 0.56), vec3(0.0, 0.0, 0.11), f );\n    col = mix( col, vec3(0.2, 0.85, 0.85), dot(on.xy, on.zw));\n    col = mix( col, vec3(0.1, 0.79, 0.88), 1.2 * smoothstep(0.8, 1.6, abs(on.z) + abs(on.z)));\n    \n    return col * 6. * 0.4545;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect ratio - UV normalization.\n   \tvec2 p = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Zoom level.\n    p*= 4.;\n\n    fragColor = vec4( GetColor( p ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}