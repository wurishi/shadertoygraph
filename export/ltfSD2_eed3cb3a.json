{"ver":"0.1","info":{"id":"ltfSD2","date":"1439744098","viewed":301,"name":"Basic Shadow","username":"Phong","description":"Basic shadow example.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"vec3 Direction(vec2 tex, vec2 res, vec2 fov)\n{\n\treturn normalize(vec3((2.0 * vec2(tex.x, tex.y) - 1.0) * fov, 1));\n}\n\nvec2 Add(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 Sub(vec2 d1, vec2 d2)\n{\n    return (-d2.x > d1.x) ? d2 : d1;\n}\n\nfloat Plane(vec3 p, vec4 n )\n{\n  return dot(p,normalize(n.xyz)) + n.w;\n}\n\nfloat Sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat RoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0)) - r;\n}\n\nmat4 RotX(float th)\n{\n\treturn mat4(1.0,0.0,0.0,0.0,0.0,cos(th),-sin(th),0.0, 0.0, sin(th), cos(th), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotY(float th)\n{\n\treturn mat4(cos(th), 0.0, sin(th), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(th), 0.0, cos(th), 0.0, 0.0, 0.0, 0.0, 0.0);\n}\n\nvec3 RotatingLight(float s)\n{\n\tvec3 p = vec3(14, 0, 0);\n    p = (RotY(s * iTime) * vec4(p,1)).xyz;\n\tp += vec3(0,8,0);\n\treturn p; \n}\n\nvec2 Scene(vec3 p)\n{\n    vec2 pl = vec2(Plane(p, vec4(0,1,0,15)), 0.0);\n    vec2 pl0 = vec2(Plane(p, vec4(0,0,-1,15)), 0.0);\n    vec2 pl1 = vec2(Plane(p, vec4(1,0,0,15)), 0.0);\n\tvec2 sph = vec2(Sphere(p-RotatingLight(1.0), 0.25), 0.5);\n\tvec2 sph2 = vec2(Sphere(p-RotatingLight(2.0), 0.25), 0.5);\n    vec2 obj = vec2(RoundBox(p - vec3(0,5.0 + (7.0 * sin(4.0 * iTime)),0), vec3(3,0.5,3), 0.5), 0.0);\n\treturn Add(Add(Add(Add(Add(pl, pl0), pl1), sph), sph2), obj);\n}\n\nvec2 March(vec3 o, vec3 d)\n{\n\tfloat t = 1.0; // Near plane.\n\tfloat f = 100.0;\n\tfloat m = -1.0;\n\n\tfor (int i=0; i < 256; ++i)\n\t{\n\t\tvec2 v = Scene(o + d * t);\n\n\t\tif (v.x <= .0002)\n\t\t\tbreak;\n\n\t\tt += v.x;\n\t\tm = v.y;\n\t}\n\tif (t>f)\n\t\tm = -1.0;\n\treturn vec2(t, m); \n}\n\nvec3 CalculateNormal(vec3 pos)\n{\n\tvec3 e = vec3(0.001,0,0);\n\tvec3 n = vec3(\n\t\tScene(pos+e.xyy).x - Scene(pos-e.xyy).x,\n\t\tScene(pos+e.yxy).x - Scene(pos-e.yxy).x,\n\t\tScene(pos+e.yyx).x - Scene(pos-e.yyx).x);\n\treturn normalize(n);\n}\n\nvec4 Phong(vec3 p, vec3 lp, vec3 v, vec4 diff)\n{\n\tvec3 l = normalize(lp - p);\n\tvec3 n = CalculateNormal(p);\n\tfloat ndl = clamp(dot(n,l), 0.0, 1.0);\n\tvec4 d = mix(vec4(0.0,0.0,0.0,0.0), diff, ndl);\n\tvec3 r = reflect(v, n);\n\tfloat rdl = pow(clamp(dot(r, l), 0.0, 1.0), 6.0);\n\n\tvec4 s = mix(vec4(0.0,0.0,0.0,0.0), vec4(1.0,1.0,1.0,1.0), rdl);\n\n\treturn d + s;\n}\n\nvec4 Shadow(vec3 p, vec3 lp, vec3 v)\n{\n    vec3 l = normalize(lp - p);\n    \n    vec2 res = March(p, l);\n    \n    if (res.y == 0.5)\n        return vec4(1,1,1,1);\n    \n\treturn vec4(0,0,0,0); \n}\n\nvec4 RenderScene(vec3 ro, vec3 rd)\n{\n\tvec2 res = March(ro, rd);\n\tvec4 c = vec4(0,0,0,1);\n\n\t// PHONG\n\tif (res.y == 0.0)\n\t{\n\t\tvec3 pos = ro + rd * res.x;\n\t\tvec3 lp = RotatingLight(1.0);\t\t\n\t\tvec3 lp2 = RotatingLight(2.0);\t\t\n\t\tvec3 lp3 = RotatingLight(3.0);\t\t\n\t\tvec3 lp4 = RotatingLight(4.0);\t\t\n\t\t\n\t\tc = Phong(pos, lp, rd, vec4(0.0,0.0,1.0,1.0));\n\t\tc += Phong(pos, lp2, rd, vec4(1.0,0.0,0.0,1.0));\n\n        vec4 sh = vec4(0,0,0,0);\n        \n        sh += Shadow(pos, lp, rd);\n        sh += Shadow(pos, lp2, rd);\n        sh /= 2.0;\n        c *= sh;\n\t}\n\telse if (res.y == 0.5 )\n\t{\n\t\tc = vec4(1,1,1,1);\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(40,40,-40);\n    float aspect = iResolution.y / iResolution.x;\n    float hFOV = 3.1415/4.0;\n    \n\tvec3 rd = Direction(uv, iResolution.xy, vec2(hFOV, aspect * hFOV));\n\trd = (RotX(-3.1415/6.0) * vec4(rd,1)).xyz;\n\trd = (RotY(3.1415/4.0) * vec4(rd,1)).xyz;\n\t\n\tfragColor = RenderScene(ro, rd);\n}","name":"Image","description":"","type":"image"}]}