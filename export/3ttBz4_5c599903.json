{"ver":"0.1","info":{"id":"3ttBz4","date":"1612350929","viewed":72,"name":"Subsurface Scattering Attempt","username":"denosya","description":"Atelier Maths Subsurface Scattering","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["subsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/////////////////////////////////////////////////////////////////////\n// Exercice : rendu avec Subsurface Scattering\n/////////////////////////////////////////////////////////////////////\nvec4 computeColor(in vec3 ray, in vec3 p, in vec3 normal, in vec3 lightSource) {\n    \n    vec3 light = normalize(p-lightSource);\n    \n    float distorsion = -0.5;\n    float diffuse = clamp(dot(normal, -light), 0.0, 1.0) * 1.;\n    vec3 outlight = normalize(light + normal * distorsion);\n    float scatter = clamp(dot(-ray, outlight), 0.0, 1.0) * 1.;\n\n    vec4 outter_color = vec4(121, 179, 255, 255)/255.;    \n    vec4 inner_color  = vec4(0, 179, 255, 255)/255.;\n\n    return outter_color * (0.15 + diffuse) + inner_color * (0.25 + scatter);    \n}\n\n\n\nfloat map(vec3 m) {\n    \n\tvec3 sphereCenter = vec3(sin(iTime)*4.0, 0.0, +20.0);\n    float radius = 6.0+sin(iTime)*0.25;\n    return length(m - sphereCenter) - radius + sin(m.x)*sin(m.y)*sin(m.z);\n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n\n    const float zFar  = 40.0;\n\n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n    for(int i = 0; i<200; i++) {\n        m = origin + ray * marchingDist;    \n    \tfloat dist = map(m);\n        if(dist < 0.001) {\n            return true;\n        }\n        else {\n            marchingDist += dist * 0.75;\n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n\treturn false;    \n}\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\nvec4 run(in vec2 fragCoord) {\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), 1.);\n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, -1.850);\n    vec3\tray\t\t\t\t= normalize(viewportCoord);\n    vec3\tp;\n    \n    vec3\tlightSource\t\t= vec3(-20.0, 0.0, 40.0);\n    \n    if(rayMarching(eye, ray, p)) {\n        vec3 normal = computeNormal(p);\n        return computeColor(ray, p, normal, lightSource);\n    }\n    else {\n        return vec4(0.0, 0, 0, 1.0);        \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = run(fragCoord); \n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}