{"ver":"0.1","info":{"id":"3sGGDt","date":"1571265234","viewed":232,"name":"Zoomy Boxes","username":"dalp","description":"trying to recreate a trick I did in Flash back in the 1920s","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["boxes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a combination of a semi-random noise gnerator \n// from Art of Code on Youtube - https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg/videos\n// a step/HSV effect I got from https://www.shadertoy.com/view/XdyXz3\n// and some stuff I did myself (constantly changing noise and the squares)\n// it was basically me learning how to work with masks\n// it's a mess, but it works\n\n#define S(a,b,t) smoothstep(a,b,t)\nconst float LEVELS = 12.;\n\nvec4 N14(float t) {\n    return fract(sin(t*vec4(123., 1024., 3456., 9564.))*vec4(6547., 345., 7799., 1564.));\n}\n\nvec4 NN14(float t) {\n    return fract(sin(t*vec4(1243., 10224., 13456., 69564.))*vec4(61547., 4345., 27799., 15564.));\n}\n\nfloat N11(float p) {\n    float a = fract(p*345.65);\n\ta += dot(a, a+34.45);\n    return fract(a);\n}\n\nfloat N21 (vec2 p) {\n    return fract(sin(p.x*122.+p.y*52453.)*244156.); // returns a single randomish number based on a coord input\n}\n\nvec3 hsv2rgb(vec3 c){  // taken from https://www.shadertoy.com/view/XdyXz3\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat SmoothNoise(vec2 uv) {\n \tvec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b,t,lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv,float d) {\n    float c;\n    float uvscale = 4.;\n    float detail = 1.;\n    for (float i=1.;i<=d;i++) {\n    \tc += SmoothNoise(uv*uvscale)*detail;\n        detail *= 0.5;\n        uvscale *= 2.;\n    }\n    return c/1.3;;\n}\n\nfloat GetClouds(vec2 uv, float t, float d) {\n    float speed = sin(t)*.5+.5;\n    float pi = 3.141592653;\n    // put a thing in here so that whenever the mix is fully one way or another, the 'hidden' one changes\n    float pitime = mod(floor((t - (pi*.5)) / (pi*2.)),100.); // Had to mod this, as after a while it starts drifting\n    float pitime2 = mod(floor((t - (pi*1.5)) / (pi*2.)),100.); // And at high numbers, the cloud function get a little janky\n    vec2 offs = vec2(-2.,-2.);\n    vec2 target1 = uv+(offs*pitime);\n    vec2 target2 = uv+vec2(11.,22.)+(offs*pitime2);\n    \n    // pull two noise maps\n    float c1 = SmoothNoise2(target1, d);\n    float c2 = SmoothNoise2(target2, d);\n    float c = mix(c1,c2,speed);                 \n\t\n    return floor(c*LEVELS)/LEVELS;\n}\n\nvec3 DoClouds (vec2 uv) {\n    uv *= .2;\n\tfloat t = iTime*1.;\n    //vec2 offset = vec2(sin(t)*0.006,cos(t)*0.006);  // rotating lightsource. doesn't look so good without a visual light cue.\n    vec2 offset = vec2(0.006,0.006);\n    \n    uv += iTime*0.02;  // slow diagonal move\n\tfloat detail = 4.; // 1-6 working range\n\n    float c = GetClouds(uv,t,detail);//\n    float edge = GetClouds(uv+offset,t,detail);\n    \n    //calc HSV color (taken from https://www.shadertoy.com/view/XdyXz3)\n    float h = c*.9 - .2; //rainbow hue\n    float s = 0.5;\n    float v = 1. - ( c*(detail*.05) ); //deeper is darker\n    \n    v -= c-edge;\n    \n    return hsv2rgb(vec3(-h,s,v));\n}\n\nvec4 RoundedBox( in vec2 p, in vec2 b, in float r, in vec4 rgba ) \n{\n    vec2 q = abs(p) - b;\n    float d = min(max(q.x,q.y),0.0) + length(max(q,0.0));\n    d *= 10.;\n    return S(.8,.6,d) * rgba;\n}\n\nfloat RoundedBoxInnerMask( in vec2 p, in vec2 b, in float r) \n{\n    vec2 q = abs(p) - b;\n    float d = min(max(q.x,q.y),0.0) + length(max(q,0.0));\n    d *= 10.;\n    return S(.8,.6,d);\n}\n\nvec4 RoundedBoxRing( in vec2 p, in vec2 b, in float r) \n{\n    vec2 q = abs(p) - b;\n    float d = (min(max(q.x,q.y),0.0) + length(max(q,0.0)))*4.;\n    return S(1.,0.85,d)-S(.4,.25,d)*vec4(0.,0.,0.,1.);\n}\n\nvec4 dots(vec2 uv,float t, vec4 rgba, float seed) {\n    vec4 b = vec4(0.); // Box\n    float bm = 0.; // Box Mask\n    vec4 br = vec4(0.); // Box Ring\n    float brm = 0.; // Box Ring Mask\n    vec2 p = vec2(0.); // Box coords\n    float nn = 20.; // Number of boxes\n    float pi = 3.141592653;\n\n    for (float n=1.;n<nn;n++) {\n        float ti = (t*2.2)+.22*n; // change move time offset for each box so they don't all move at the same time\n        // Put a thing in here to change the seed each cycle\n        float pitimes = floor((ti - (pi*.5)) / (pi*2.))*nn;\n        float pitimet = floor((ti - (pi*1.5)) / (pi*2.))*nn;\n        float s1 = seed*n+pitimes;\n        float s2 = seed*n+pitimet;\n        vec4 rands = (N14(s1)-.5)*5.;\n        vec4 randt = (NN14(s2)-.5)*5.;\n        float locx = rands.x+(S(0.,1.,sin(ti)*.5+.5)*(randt.x-rands.x));\n        float locy = rands.y+(S(0.,1.,sin(ti)*.5+.5)*(randt.y-rands.y));\n\n        p.x = uv.x+(locx*1.8); // Needs to be wider.  should fix to aspect ratio, but cba right now.\n        p.y = uv.y+locy;\n        \n        b += RoundedBox(vec2(p),vec2(0.5,0.5),0.1, rgba);\n        bm += RoundedBoxInnerMask(vec2(p.x,p.y),vec2(0.5,0.5),0.1);\n        br += RoundedBoxRing(vec2(p.x,p.y),vec2(0.5,0.5),0.1);\n    }\n\tfloat maskring = clamp(1.-bm,0.,1.);\n    return (b)-(maskring*br);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    float  t = iTime*.6+m.x+6.;\n\tuv *= 5.;\n\tvec4 col = vec4(.0);\n    \n    col += vec4(DoClouds(uv),1.);\n    \n    col += dots(uv,t,vec4(.1,.1,.35,.15),N11(54.)); // Add some boxes\n    \n    fragColor = vec4(col);\n}\n","name":"Image","description":"","type":"image"}]}