{"ver":"0.1","info":{"id":"Ml2XRc","date":"1445603206","viewed":345,"name":"The Death Star [WIP]","username":"jackdavenport","description":"A raymarched Death Star for all your Darthly Needs ;P\n\nLots of this was a variation of code from the fantastic iq:\nhttps://iquilezles.org/articles/distfunctions/distfunctions.htm\nhttps://iquilezles.org/articles/smin/smin.htm","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["star","space","raymarcher","boolean","starwars","death","ship"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define MAX_ITERATIONS 32\n#define MIN_DISTANCE  .001\n#define LENGTH 20.\n\n#define PI 3.14159\n\nstruct Ray {\nvec3 ori;\nvec3 dir;\n};\nstruct Dist {\nfloat dist;\nint id;\n};\nstruct Hit {\nvec3 p;\nDist dist;\n};\n    \nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nfloat distSphere(vec3 p, vec3 pos, float radius) {\n\n    return length(pos - p) - radius;\n    \n}\n\nfloat distCone(vec3 p, vec3 pos, vec3 c) {\n \n    p -= pos;\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n    \n}\n\nfloat distBox(vec3 p, vec3 pos, vec3 r) {\n    \n    return length(max(abs(pos - p) - r, 0.));\n    \n}\n\nfloat distDeathStar(vec3 p) {\n \n    float base = distSphere(p, vec3(3., 0., 10.), 6. );\n    float lens = distSphere(p, vec3(1., 1.7, 5. ), 1.3);\n    //float trench = distBox(p, vec3(2.,0.,10.),vec3(10.,.05,10.));\n    \n    float x = max(-lens, base);\n    return x;\n    //return max(-trench,x);\n    \n}\n\nfloat distDroid(vec3 p, vec3 pos, float scale) {\n \n    float base = distCone(p, (pos + vec3(0.,0.,0.))*scale, vec3(1.));\n    float eye  = distBox (p, (pos + vec3(.8,-.8,0.))*scale+vec3(.4,-.6,0.), vec3(.3,.1,.1)*2.);\n    return smin(base, eye, 0.1);\n    \n}\n\nDist distScene(vec3 p) {\n \n    float time = mod(iTime, LENGTH);\n    float x    = time / LENGTH;\n    \n    float deathStar = distDeathStar(p);\n    return Dist(deathStar, 0);\n    //float droid     = distDroid(p, vec3(0., 0., -6.), .3);\n    \n    //float dist = min(deathStar, droid);\n    //return Dist(dist, dist == deathStar ? 0 : 1);\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    float t = 0.;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dist d = distScene(p);\n        p += ray.dir * d.dist;\n        \n        if(d.dist <= MIN_DISTANCE) {\n         \n            t = d.dist;\n            id = d.id;\n            \n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,Dist(t,id));\n    \n}\n\nvec3 getSunDir() {\n    \n    vec3 dir = vec3(20.,20.,-20.);\n    return normalize(dir);\n    \n}\n\nvec3 normal(vec3 p) {\n \n    const float d = .001;\n    \n    vec3 left = vec3(p.x - d,p.yz);\n    vec3 right = vec3(p.x + d,p.yz);\n    vec3 up = vec3(p.x,p.y-d,p.z);\n    vec3 down = vec3(p.x,p.y+d,p.z);\n    vec3 front = vec3(p.xy,p.z-d);\n    vec3 back = vec3(p.xy,p.z+d);\n    \n    float distLeft = distScene(left).dist;\n    float distRight = distScene(right).dist;\n    float distUp = distScene(up).dist;\n    float distDown = distScene(down).dist;\n    float distFront = distScene(front).dist;\n    float distBack = distScene(back).dist;\n    \n    return normalize(vec3(distRight-distLeft,distDown-distUp,distBack-distFront));\n    \n}\n\nvec3 rgb(float r, float g, float b) {\n \n    return vec3(r / 255., g / 255., b / 255.);\n    \n}\n\nvec4 clearColor(vec3 dir) {\n \n    vec4 tex = texture(iChannel0, dir.xy * 2.);\n    float noise = (tex.x + tex.y + tex.z) / 3.;\n    \n    if(noise < .95) {\n     \n        noise = 0.;\n        \n    }\n    \n    return vec4(noise,noise,noise,1.);\n        \n}\n\nvec4 shadeDeathStar(Ray ray, Hit scene) {\n \n    vec3 n  = normal(scene.p);\n    vec3 ld = getSunDir();\n    \n    float d = .1 + (.9 * max(dot(ld,n), 0.));\n    Ray sr  = Ray(scene.p + (ld * .1), ld);\n   \tDist sd = raymarch(sr).dist;\n    \n    float u = asin(n.x) / PI * .5;\n    float v = asin(n.y) / PI * .5;\n    vec2 uv = vec2(u,v);\n    \n    vec4 tex = texture(iChannel1, uv * 4.);\n   \tfloat noise = (tex.x+tex.y+tex.z)/3.;\n    \n    tex = (texture(iChannel2, uv * 7.) + texture(iChannel2, uv * -7.))/2.;\n    tex = vec4((tex.x+tex.y+tex.z)/3.);\n    \n    float bandWidth = .1;\n    if(uv.y < (.5+bandWidth) && uv.y > (.5-bandWidth)) tex *= .5;\n    \n    vec3 sum = tex.xyz * d;\n    sum += rgb(117., 111., 69.) * (noise < .85 ? 0. : noise);\n \treturn vec4(sum,1.);\n    \n}\n\nvec4 shadeDroid(Ray ray, Hit droid) {\n \n    vec3 n = normal(droid.p);\n    vec3 rd = reflect(ray.dir, n);\n    \n    Ray  rr = Ray(droid.p + (rd * .01), rd);\n    Hit  rh = raymarch(rr);\n    vec4 rc = rh.dist.id == 0 ? shadeDeathStar(rr, rh) : clearColor(rd);\n    \n    float diffuse  = max(dot(getSunDir(),n), 0.);\n    float specular = max(pow(dot(normalize(rd),getSunDir()), 30.), 0.);\n    \n \tvec4 col = vec4(rgb(227.,156.,25.), 1.) * diffuse;   \n    return mix(col, rc, .4) + (vec4(1.) * specular);\n    \n}\n\nvec4 shade(Ray ray) {\n\n    Hit scene = raymarch(ray);\n    \n    if(scene.dist.id == 0) {\n\n        return shadeDeathStar(ray, scene);\n        \n    } else if(scene.dist.id == 1) {\n     \n        return shadeDroid(ray, scene);\n        \n    }\n    \n    return clearColor(ray.dir);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n\t\n    float time = mod(iTime, LENGTH);\n    float x    = time / LENGTH;\n    \n    vec3 ori = vec3(mix(0., 4., x),0.,mix(-10., -6., x));\n    vec3 dir = vec3(uv, 1.);\n    \n    float fade = smoothstep(0., 2., time) * (1. - smoothstep(LENGTH - 2., LENGTH, time));\n    fragColor = shade(Ray(ori,dir)) * fade;\n}","name":"","description":"","type":"image"}]}