{"ver":"0.1","info":{"id":"Xd3GRX","date":"1451120795","viewed":1685,"name":"Audio Visualizer - Raymarching","username":"Lallis","description":"Beware of the audio volume from soundcloud!\nHad a lot of fun with this one. I redirected my audio output to the microphone channel so I could have my own music in shadertoy and it was pretty cool! Check the comments if you want to try out some stuff.","likes":35,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","audio","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MsjGDG","filepath":"https://soundcloud.com/user2727940/deadmau5-strobe","previewfilepath":"https://soundcloud.com/user2727940/deadmau5-strobe","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\tIf you have any ideas please let me know in the comments! :)\n\tEspecially if you have a better idea for the frequency distribution.\n\tRight now it's MAXF/2^(x/2) where x is a frequency band numbered from 0 to 15.\n\tIt would probably be smart to include more than a single frequency over each band.\n\t\n*/\n//Enable dithering\n#define ENABLEDITHER\n\n//Enable rotation\n//#define ENABLEROT\n\n//Enable zooming with beat (sucks ass)\n//#define ENABLEBEAT\n\n//Show only the back wall without perspective\n//#define FLAT\n\n//Enable waveform\n#define ENABLEWAVE\n\n//Waveform amplitude; adjust according to audio source volume\n#define WAVEAMP 1.0\n\n//Height for gradient middle color; set to 1.0 for 2 color gradient\n#define GRADVAL 0.8\n\n#define time iTime\n\n\nconst vec3 Color1 = vec3(0.25,0.625,0.625);\nconst vec3 Color2 = vec3(0.25,0.25,1.00); // TEAL->BLUE->RED\nconst vec3 Color3 = vec3(1.00,0.25,0.25);\n\n//Some color combinations\n\n/*const vec3 Color1 = vec3(0.25,1.00,0.25);\nconst vec3 Color2 = vec3(0.75,0.50,0.25); // GREEN->YELLOW->RED\nconst vec3 Color3 = vec3(1.00,0.25,0.25);*/\n\n/*const vec3 Color1 = vec3(0.00,0.00,0.00);\nconst vec3 Color2 = vec3(0.70,0.55,0.25); // BLACK->YELLOW->WHITE\nconst vec3 Color3 = vec3(0.5);*/\n\n/*const vec3 Color1 = vec3(0.25,0.25,1.00);\nconst vec3 Color2 = vec3(0.25,0.625,0.625); // BLUE->TEAL->WHITE\nconst vec3 Color3 = vec3(0.5);*/\n\n\n/*const vec3 Color1 = vec3(0.75); // WHITE\n//const vec3 Color1 = vec3(0.25,0.50,1.00); // LIGHT BLUE\nconst vec3 Color2 = Color1;\nconst vec3 Color3 = Color1;*/\n\nfloat noise(vec2 p)\n{\n\treturn fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453);\n}\n\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nvec3 getCol(float v, vec3 col1, vec3 col2)\n{\n    v = clamp(v,0.0,1.0);\n    vec3 res = vec3(0.0);\n    for(int i = 0; i<3; i++)\n    {\n        res[i] = col1[i] + v * (col2[i] - col1[i]);\n    }\n    return res;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nvec4 map(vec3 rp)\n{\n\tvec4 d = vec4(0.0);\n\t  \n    vec3 bgCol = vec3(0.125,0.125,0.125);\n    \n    #ifdef ENABLEWAVE\n    float waveF = texture(iChannel0, vec2((rp.x+1.8)/3.6, 0.75)).r;\n    float waveDist = udBox(rp-vec3(0.0,-waveF*WAVEAMP+WAVEAMP/2.0,0.25), vec3(1.8,0.02,0.001));\n    vec4 wave = vec4(vec3(0.3), waveDist);\n    #endif\n    \n    float backWallDist = udBox(rp-vec3(0.0,0.0,0.75), vec3(1.8, 1.1, 0.5));\n    vec4 backWall = vec4(bgCol, backWallDist);\n    \n    float edgeLeftDist = udBox(rp-vec3(1.9,0.0,0.3725), vec3(0.1,1.1,1.0));\n    vec4 edgeLeft = vec4(bgCol, edgeLeftDist);\n    \n    float edgeRightDist = udBox(rp-vec3(-1.9,0.0,0.3725), vec3(0.1,1.1,1.0));\n    vec4 edgeRight = vec4(bgCol, edgeRightDist);\n    \n    float edgeTopDist = udBox(rp-vec3(0.0,1.2,0.3725), vec3(2.0,0.1,1.0));\n    vec4 edgeTop = vec4(bgCol,edgeTopDist);\n    \n    float edgeBotDist = udBox(rp-vec3(0.0,-1.2,0.3725), vec3(2.0,0.1,1.0));\n    vec4 edgeBot = vec4(bgCol,edgeBotDist);\n    \n    d = edgeLeft.a > backWall.a ? backWall : edgeLeft;\n    d = edgeRight.a > d.a ? d : edgeRight;\n    d = edgeTop.a > d.a ? d : edgeTop;\n    d = edgeBot.a > d.a ? d : edgeBot;\n    \n    #ifdef ENABLEWAVE\n    d = wave.a > d.a ? d : wave;\n    #endif   \n\n    return d;\n    \n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\n\treturn normalize( vec3(\n           map(rp+eps.xyy).a - map(rp-eps.xyy).a,\n           map(rp+eps.yxy).a - map(rp-eps.yxy).a,   \n           map(rp+eps.yyx).a - map(rp-eps.yyx).a ) );\n\n}\n\nfloat light(vec3 lp, vec3 rp, vec3 n, float pulse)\n{\n    return (1.5*(pulse+0.05)/pow(distance(lp,rp),2.0))*max(dot(normalize(lp-rp), n), 0.0)*0.25;\n}\n\nfloat drawLight(vec3 lp, vec3 rd, vec3 ro, float td, float pulse)\n{\n    float res = 0.0;\n    if(td > distance(lp,ro))\n    {\n\t\tfloat dlp = length(cross(lp-ro, lp-(ro+rd)))/length((ro+rd)-ro);\n\t\tres=max(exp(-dlp*64.0*((1.0-pulse)+0.5)),0.0);\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0*uv-1.0;\n    p.x*=iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m.x = iMouse.x == 0.0 ? 0.5 : iMouse.x/iResolution.x;\n    m = 2.0*m-1.0;\n    vec3 col = vec3(0.00);\n    \n    float hArr[16];\n    for(int i = 0; i < 16; i++)\n    {\n     \thArr[i] = texture(iChannel0, vec2( 1.0/pow(2.0,float(i)*0.5)-0.001,0.25)).r;\n    }    \n    \n    float z = -0.5;\n    \n    #ifdef ENABLEROT\n    z = -2.0*(sin(time*0.25)*0.5+0.5);\n    #endif\n    #ifdef ENABLEBEAT\n    z += -2.0*hArr[14];\n    #endif\n    vec3 ro = vec3(0.0,0.0,z-2.0);\n    #ifdef FLAT\n    ro = vec3(p/vec2(1.0,1.25), z-2.0);\n    #endif\n    vec3 rd = normalize( vec3(p, z) - ro );\n    \n    vec3 ang = vec3( 0.0, 0.0 , 0.0);\n    #ifdef ENABLEROT\n    ang = vec3(1.54*sin(time*0.125)*0.25, 1.54*cos(time*0.25)*0.25, 0.0);\n    #endif\n    ro*=rot(ang);\n    rd*=rot(ang);\n    \n    vec3 rp = vec3(0.0);\n    \n    vec4 d = vec4(0.0);\n    float td = 0.5;\n\tfloat dMax = 25.0;\n    \n    for(int i = 0; i < 64; i++)\n    {\n        if(td >= dMax) break;\n        rp = ro+rd*td;\n     \td = map(rp);\n        if(d.a < 0.001)\n        {\n         \tbreak;   \n        }\n        td += d.a*0.75;\n    }\n    \n    vec3 lp[16];\n    \n    for(int i = 0; i < 16; i++)\n    {\n     \tlp[i] = vec3( (7.5-float(i))*0.2125, hArr[i]*2.0-1.0, 0.0);      \n    }\n    \n    float g = 1.0/(1.0-GRADVAL);\n    float r = 1.0/GRADVAL;\n    \n    vec3 lc[16];\n    \n    for(int i = 0; i < 16; i++)\n    {\n     \tlc[i] = getCol((hArr[i]-GRADVAL)*g, getCol(hArr[i]*r, Color1, Color2), Color3);    \n    }\n    \n    vec3 n = normal(rp);\n    if(d.a < 0.001)\n    {\t\t\t\n        \n        vec3 illumination = vec3(0.01);\n        \n        for(int i = 0; i < 16; i++)\n        {\n         \tillumination += lc[i] * light(lp[i], rp, n, hArr[i] );   \n        }\n      \n     \tcol = d.rgb*illumination;   \n    }\n    \n    for(int i = 0; i < 16; i++) \n    {\n     \tcol += lc[i] * drawLight(lp[i], rd, ro, td, hArr[i] );   \n    }\n\n    col = clamp(col, 0.0, 1.0);\n    \n    col = pow(col, vec3(0.45)); //gamma adjust\n    \n    float f = 8.0;\n    col = (1.0/(1.0+exp(4.0-f*col))-0.0003)/(0.982-0.018); //contrast\n    p.x/=iResolution.x/iResolution.y;\n    col *= smoothstep( 1.325, 0.825, abs(p.x) ); //dark edges\n    col *= smoothstep( 1.325, 0.825, abs(p.y) );\n    \n    #ifdef ENABLEDITHER\n    float dither = 4.0/256.0;\n\n   \tcol += (noise3D(vec3(p,fract(time)))*2.0-1.0)*dither;\n    #endif\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}