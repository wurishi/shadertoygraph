{"ver":"0.1","info":{"id":"lf3XzM","date":"1714150479","viewed":111,"name":"Pseudospectral (slow!)","username":"thepinkpanzer","description":"Pseudospectral simulation of the Euler equations. ","likes":0,"published":1,"flags":32,"usePreview":1,"tags":["simulation","fluid","physics","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 jet(float x) // from 0 to 1\n{\n    return pow(vec4(x*x*(1.-x)/0.148, pow(x*(1.-x)*4.,2.), x*(1.-x)*(1.-x)/0.148, 0), vec4(1.6));\n}\nvec4 twilight(float x) // from -1 to 1\n{\n    float s  = sign(x);\n    x *= s;\n    \n    float r  = mix(1., (s > 0. ? x*x : x*x*x*x*x), 0.8);\n    float b  = mix(1., (s < 0. ? x*x : x*x*x*x*x), 0.8);\n    float g  = mix(1., x*x*x*x, 0.95);\n    return pow(vec4(r, g, b, 0), vec4(1.4));\n}\nvec4 recolor(float x)\n{\n    x = tanh(x);\n    return jet(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord    = mix(iResolution.xy/2., fragCoord, 1.);\n    vec2 cell    = floor(fragCoord/ORDER)*ORDER;\n    vec2 subcell = 2.*(fragCoord - cell)/ORDER-1.;\n\n    vec4 Q = Evaluate(iChannel0, cell, subcell, iResolution.xy);\n    \n    vec4 q   = Q/Q.r;\n    \n    float ek = 0.5*(q.g*q.g+q.b*q.b);\n    float t  = q.a-ek;\n    float s  = (GAMMA-1.)*t*pow(Q.r, -GAMMA);\n    \n    // Color represents direction of motion, brightness is mostly density (but goes to zero when velocity goes to zero).\n    fragColor = tanh(0.5*pow(0.52+0.5*cos(vec4(0,1,2,3)*PI*2./3.+atan(Q.b,Q.g)), vec4(0.7))*tanh(4.*length(Q.gb))*pow(Q.r-0.5,1.));\n    //fragColor = tanh(normalize(recolor(pow(t/14., 1.1)))*pow(Q.r*0.5, 0.65));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Adiabatic constant\n#define GAMMA 1.667\n\n// Order of the scheme; order of the polynomials *plus one*\n#define ORDER 4.\n#define NUM_CELL_VALUES int(ORDER*(ORDER+1.)/2.)\n// Half integration order (has to be at least ORDER)\n#define HALF_INTEG_ORDER (ORDER)\n// Timestep\n#define DT 0.01\n\n#define PI 3.14159265358\n#define SUBCELL_INITIALCONDITIONS\n\n/*\nThis is probably my magnum opus so far, slow as it may be.\nI've gone through a good spiel on my other DG scheme (https://www.shadertoy.com/view/4fBGRt) about the principle and challenges.\nIn short, we multiply our equations for the fluid by \"test functions\" - here, the Legendre polynomials.\nWe then integrate over a cell, and we get terms corresponding to the boundary and flow inside the cell. Simple enough.\nA pseudospectral scheme is one where we do that, but we have *lots* of test functions, and so each cell has a pretty good\nrepresentation of the local fluid state.\nProblem is, this method is unstable. Oscillations grow and grow until the sim dies.\nThe trick is to put in viscosity - or something reminiscent of its effects. In the past, I've filled this role using a\n\"limiter\" - a notion brought in by Bram van Leer. Basically, where our functions are going bad and exceeding their allowed range,\nwe \"limit\" them back to more reasonable values.\nThis doesn't work so well for pseudospectral methods, where we're trying to replace a local operation (viscosity) with a\nmore global one (limiting). So what I've done here is combined dissipation from three sources:\n1. Smoothing at the boundaries between cells\n2. Artificial viscosity where the system detects shocks\n3. Limiting (where all else fails)\nOverall I find this combination works reasonably well, and it can even capture shocks without being completely limited to\n1st order.\nSome important things to consider are (a) that each cell here is ORDER*ORDER across - while it looks a lot more diffusive\nthan my other sims at first glance, it's in large part because the resolution is much much smaller too. (b) this thing is\n*ridiculously* slow at higher orders. It goes as ORDER^4. I think you might be able to improve it (N^2 logN?) with Chebyshev \npolynomials or whatever, and I might figure that out some day. That might sound like an absolute loss, but the accuracy is\nexponential in the order, and that crushes any power law. The only thing to consider then is whether you expect shocks - \nbecause if so, you're perhaps better off running a low-order simulation with adaptivity because limiting reduces the \norder anwyway.\n\nWhat else do I need to say?\nI do the integration inside the cells with Clenshaw-Curtis; I could figure out how to create and save Gauss weights and save\na factor of ~4 on the integration (assuming texture reads are cheap). Tbh, not sure what else to optimise - gradient\ncalculations in the artificial viscosity could be improved ig. \nI'm simulating the Euler equations; in principle, you could change the EOS by changing the Flux function and wherever the \nspeed of sound turns up (Lax-Friedrichs, Visc, and Limit functions). \nIf you want to simulate shocks, you probably need to turn up the dissipation. That generally means the limiting and the\nLax-Friedrichs diffusion. \nTimestep usually has to start low (large gradients need to be smoothed by dissipation) but then you can turn it up a little,\ncould probably start compiling it when it starts running and then when it's done it'll be smooth enough lol\nBuffer A decides the initial conditions and you can play around with the color schemes in Image; both of them will compile\nseparately to Common and Buffer B so changing them doesn't take a full minute of compile time. \nI use a 2nd-order \"TVD\" integrator. TVD means \"total variation diminishing\" - if your solution isn't screwed up after one\nEuler forward timestep, it won't be screwed up by one timestep with the TVD integrator either. A lot of popular integrators\n(like RK2) aren't among this exclusive class so be warned. It looks like \n{u1 = u(t) + dt u'(t), u(t+dt) = 0.5(u(t) + u1 + dt u1')}.\nIf you have any questions, comments are always there.\n*/\n\n// Q = vec4(mass density, vec2(momentum density), energy density)\nvec4 Flux(vec4 Q, vec2 n)\n{\n    float vn = dot(Q.gb/Q.r, n);\n    float P  = (GAMMA-1.)*(Q.a - 0.5*dot(Q.gb, Q.gb)/Q.r);\n    return vec4(Q.r*vn, Q.g*vn + n.x*P, Q.b*vn + n.y*P, (Q.a + P)*vn);\n}\nvec4 LaxFriedrichs(vec4 QL, vec4 QR, vec2 n)\n{   // Very diffusive way of calculating the flux - but it reduces to the correct value when no discontinuities.\n    vec4 FL = Flux(QL, n);\n    vec4 FR = Flux(QR, n);\n    float c = max(abs(dot(QL.gb,n)/QL.r) + sqrt(GAMMA*(GAMMA-1.)*(QL.a - 0.5*dot(QL.gb, QL.gb)/QL.r)/QL.r),\n                  abs(dot(QR.gb,n)/QR.r) + sqrt(GAMMA*(GAMMA-1.)*(QR.a - 0.5*dot(QR.gb, QR.gb)/QR.r)/QR.r));\n    return 0.5*(FL+FR + 2.*c*DT*ORDER*(QL-QR));\n}\nvec4 Visc(vec4 Q, vec4 dQx, vec4 dQy, vec2 n)\n{\n    float divV = (Q.r*(dQx.g+dQy.b) - Q.g*dQx.r - Q.b*dQy.r)/(Q.r*Q.r);\n    float c    = sqrt(GAMMA*(GAMMA-1.)*(Q.a - 0.5*dot(Q.gb, Q.gb)/Q.r)/Q.r);\n    \n    return -(dQx*n.x+dQy*n.y)*max(3.*(ORDER*abs(divV)/c-0.03),0.);\n}\n\nfloat Evaluate(float n, float x) // Unnormalized Legendre polynomials\n{\n    if      (n == 0.)\n    {\n        return 1.;\n    }\n    else if (n == 1.)\n    {\n        return x;\n    }\n    else\n    {\n        float Pn_1 = 1.;\n        float Pn   = x;\n        for (float i = 1.; i < n; i++)\n        {\n            float Pnp1 = ((2.*i+1.)*x*Pn - i*Pn_1)/(i+1.);\n            Pn_1 = Pn; Pn = Pnp1;\n        }\n        return Pn;\n    }\n}\nfloat Evaluate(float x, float y, vec2 pos) // Normalized Legendre polynomials\n{\n    return Evaluate(x, pos.x)*Evaluate(y, pos.y)*sqrt((2.*x+1.)*(2.*y+1.)/4.);\n}\nvec4  Evaluate_old(sampler2D sampler, vec2 cell, vec2 pos, vec2 res)\n{\n    vec2 resm = res - mod(res, ORDER);\n    cell = mod(cell+resm, resm);\n    vec4 total = vec4(0.);\n    for (float y = 0.; y < ORDER; y++)\n    {\n        for (float x = 0.; x < ORDER-y; x++)\n        {\n            total += Evaluate(x, y, pos)*texture(sampler, (cell+vec2(x,y)+vec2(0.5))/res);\n        }\n    }\n    return total;\n}\nvoid  Evaluate(vec2 pos, out float poly_x[int(ORDER)], out float poly_y[int(ORDER)])\n{\n    vec2 Pn_1 = vec2(1);\n    vec2 Pn   = pos;\n    poly_x[0]  = sqrt(0.5); poly_y[0]  = sqrt(0.5);\n    for (float i = 1.; i < ORDER; i++)\n    {\n        poly_x[int(i)]  = Pn.x*sqrt((2.*i+1.)/2.); poly_y[int(i)]  = Pn.y*sqrt((2.*i+1.)/2.);\n        vec2 Pnp1      = ((2.*i+1.)*pos*Pn - i*Pn_1)/(i+1.);\n        Pn_1 = Pn; Pn = Pnp1;\n    }\n}\nvec4  Evaluate(sampler2D sampler, vec2 cell, vec2 pos, vec2 res)\n{\n    vec2 resm = res - mod(res, ORDER);\n    cell = mod(cell+resm, resm);\n    vec4 total = vec4(0.);\n    float poly_x[int(ORDER)];\n    float poly_y[int(ORDER)];\n    Evaluate(pos, poly_x, poly_y);\n    for (int y = 0; y < int(ORDER); y++)\n    {\n        for (int x = 0; x < int(ORDER)-y; x++)\n        {\n            total += poly_x[x]*poly_y[y]*texture(sampler, (cell+vec2(x,y)+vec2(0.5))/res);\n        }\n    }\n    return total;\n}\n\nfloat Differential(float n, float x) // Unnormalized Legendre polynomials\n{\n    if (n == 0.)\n    {\n        return 0.;\n    }\n    else if (n == 1.)\n    {\n        return 1.;\n    }\n    else\n    {\n        float  Pn_1 = 1.;\n        float  Pn   = x ;\n        float dPn   = 1.;\n        \n        for (float i = 1.; i < n; i++)\n        {\n            float  Pnp1 = ((2.*i+1.)*x*Pn - i*Pn_1)/(i+1.);\n            float dPnp1 =  (i+1.)*Pn + x*dPn;\n            Pn_1 = Pn; Pn = Pnp1; dPn = dPnp1;\n        }\n        return dPn;\n    }\n}\nvec2  Gradient(float x, float y, vec2 pos) // Normalized Legendre polynomials\n{\n    return vec2(Differential(x, pos.x)*Evaluate(y, pos.y), Evaluate(x, pos.x)*Differential(y, pos.y))*sqrt((2.*x+1.)*(2.*y+1.)/4.);\n}\nvoid  Gradient(sampler2D sampler, vec2 cell, vec2 pos, vec2 res, out vec4 xg, out vec4 yg)\n{\n    vec2 resm = res - mod(res, ORDER);\n    cell = mod(cell+resm, resm);\n    xg = vec4(0.);\n    yg = vec4(0.);\n    for (float y = 0.; y < ORDER; y++)\n    {\n        for (float x = 0.; x < ORDER-y; x++)\n        {\n            vec2 gradient = Gradient(x, y, pos);\n            vec4 Q = texture(sampler, (cell+vec2(x,y)+vec2(0.5))/res);\n            xg += Q*gradient.x;\n            yg += Q*gradient.y;\n        }\n    }\n}\n\n// Clenshaw-Curtis integration weights\nfloat Weight(float n)\n{\n    // D_{ij} = 2/N cos(N ij pi/(N/2)) * {1/2 if j = 0, N/2; 1 otherwise\n    // where N is the order of our integration. We have N+1 points.\n    // In our case, N/2 == HALF_INTEG_ORDER.\n    // d_i = 2/(1-(2i)^2) * {1/2 if i = 0, N/2; 1 otherwise\n    // and w = (D^T) d\n    float weight = 0.;\n    for (float i = 0.; i <= HALF_INTEG_ORDER; i++)\n    {\n        weight += \n        (1./HALF_INTEG_ORDER)*cos(i*n * PI/(HALF_INTEG_ORDER))\n                          * ((n == HALF_INTEG_ORDER || n == 0.) ? 0.5 : 1.) // D^T\n        \n       *(2./(1.-(4.*i*i)) * ((i == HALF_INTEG_ORDER || i == 0.) ? 0.5 : 1.)); // d\n    }\n    return weight;\n}\n\n// Unused; there's some super-efficient caching going on behind the scenes so texture reads aren't a worry\nvoid ReadValues(sampler2D sampler, vec2 cell, vec2 res, out vec4 cellValues[NUM_CELL_VALUES])\n{\n    for (int n = 0; n < NUM_CELL_VALUES; n++)\n    {\n        float x = floor(0.5*(1. - 2.*ORDER - sqrt(1. - 4.*ORDER + 4.*ORDER*ORDER + 8.*float(n))));\n        float y = float(n) - x/2.*(2.*ORDER + x - 1.);\n        cellValues[n] = texture(sampler, (cell+vec2(x,y)+0.5)/res);\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 RateOfChange(sampler2D sampler, vec2 cell, vec2 subcell)\n{\n    vec4 rateOfChange = vec4(0);\n    // Flux inside the cell\n    vec4 dQx, dQy;\n    for (float x = 0.; x <= HALF_INTEG_ORDER; x++)\n    {\n        float x_weight = Weight(x);\n        for (float y = 0.; y <= HALF_INTEG_ORDER; y++)\n        {\n            vec2  point    = vec2(cos(x*PI/(2.*HALF_INTEG_ORDER)), cos(y*PI/(2.*HALF_INTEG_ORDER)));\n            float y_weight = Weight(y);\n            \n            vec4 Qpp = Evaluate(sampler, cell, vec2( 1, 1)*point, iResolution.xy);\n            vec4 Qmp = Evaluate(sampler, cell, vec2(-1, 1)*point, iResolution.xy);\n            vec4 Qpm = Evaluate(sampler, cell, vec2( 1,-1)*point, iResolution.xy);\n            vec4 Qmm = Evaluate(sampler, cell, vec2(-1,-1)*point, iResolution.xy);\n            \n            rateOfChange += Flux(Qpp, Gradient(subcell.x, subcell.y, vec2( 1, 1)*point))*x_weight*y_weight;\n            rateOfChange += Flux(Qmp, Gradient(subcell.x, subcell.y, vec2(-1, 1)*point))*x_weight*y_weight;\n            rateOfChange += Flux(Qpm, Gradient(subcell.x, subcell.y, vec2( 1,-1)*point))*x_weight*y_weight;\n            rateOfChange += Flux(Qmm, Gradient(subcell.x, subcell.y, vec2(-1,-1)*point))*x_weight*y_weight;\n            \n            Gradient(sampler, cell,                                            vec2( 1, 1)*point, iResolution.xy, dQx, dQy);\n            rateOfChange += Visc(Qpp, dQx, dQy, Gradient(subcell.x, subcell.y, vec2( 1, 1)*point))*x_weight*y_weight;\n            Gradient(sampler, cell,                                            vec2(-1, 1)*point, iResolution.xy, dQx, dQy);\n            rateOfChange += Visc(Qmp, dQx, dQy, Gradient(subcell.x, subcell.y, vec2(-1, 1)*point))*x_weight*y_weight;\n            Gradient(sampler, cell,                                            vec2( 1,-1)*point, iResolution.xy, dQx, dQy);\n            rateOfChange += Visc(Qpm, dQx, dQy, Gradient(subcell.x, subcell.y, vec2( 1,-1)*point))*x_weight*y_weight;\n            Gradient(sampler, cell,                                            vec2(-1,-1)*point, iResolution.xy, dQx, dQy);\n            rateOfChange += Visc(Qmm, dQx, dQy, Gradient(subcell.x, subcell.y, vec2(-1,-1)*point))*x_weight*y_weight;\n        }\n    }\n\n    // Flux through interfaces    \n    for (float x = 0.; x <= HALF_INTEG_ORDER; x++)\n    {\n        float weight = Weight(x);\n        float pos    = cos(x*PI/(2.*HALF_INTEG_ORDER));\n        \n        rateOfChange -= LaxFriedrichs(Evaluate(sampler, cell+vec2(     0,     0), vec2( -1,  pos), iResolution.xy), \n                                      Evaluate(sampler, cell+vec2(-ORDER,     0), vec2(  1,  pos), iResolution.xy),\n                                      vec2(-1, 0))*Evaluate(subcell.x, subcell.y, vec2( -1,  pos)) * weight;\n                                      \n        rateOfChange -= LaxFriedrichs(Evaluate(sampler, cell+vec2(     0,     0), vec2(  1,  pos), iResolution.xy), \n                                      Evaluate(sampler, cell+vec2( ORDER,     0), vec2( -1,  pos), iResolution.xy),\n                                      vec2( 1, 0))*Evaluate(subcell.x, subcell.y, vec2(  1,  pos)) * weight;\n                                      \n        rateOfChange -= LaxFriedrichs(Evaluate(sampler, cell+vec2(     0,     0), vec2( pos,  -1), iResolution.xy), \n                                      Evaluate(sampler, cell+vec2(     0,-ORDER), vec2( pos,   1), iResolution.xy),\n                                      vec2( 0,-1))*Evaluate(subcell.x, subcell.y, vec2( pos,  -1)) * weight;\n                                      \n        rateOfChange -= LaxFriedrichs(Evaluate(sampler, cell+vec2(     0,     0), vec2( pos,   1), iResolution.xy), \n                                      Evaluate(sampler, cell+vec2(     0, ORDER), vec2( pos,  -1), iResolution.xy),\n                                      vec2( 0, 1))*Evaluate(subcell.x, subcell.y, vec2( pos,   1)) * weight;\n                                      \n                                      \n        rateOfChange -= LaxFriedrichs(Evaluate(sampler, cell+vec2(     0,     0), vec2( -1, -pos), iResolution.xy), \n                                      Evaluate(sampler, cell+vec2(-ORDER,     0), vec2(  1, -pos), iResolution.xy),\n                                      vec2(-1, 0))*Evaluate(subcell.x, subcell.y, vec2( -1, -pos)) * weight;\n                                      \n        rateOfChange -= LaxFriedrichs(Evaluate(sampler, cell+vec2(     0,     0), vec2(  1, -pos), iResolution.xy), \n                                      Evaluate(sampler, cell+vec2( ORDER,     0), vec2( -1, -pos), iResolution.xy),\n                                      vec2( 1, 0))*Evaluate(subcell.x, subcell.y, vec2(  1, -pos)) * weight;\n                                      \n        rateOfChange -= LaxFriedrichs(Evaluate(sampler, cell+vec2(     0,     0), vec2(-pos,  -1), iResolution.xy), \n                                      Evaluate(sampler, cell+vec2(     0,-ORDER), vec2(-pos,   1), iResolution.xy),\n                                      vec2( 0,-1))*Evaluate(subcell.x, subcell.y, vec2(-pos,  -1)) * weight;\n                                      \n        rateOfChange -= LaxFriedrichs(Evaluate(sampler, cell+vec2(     0,     0), vec2(-pos,   1), iResolution.xy), \n                                      Evaluate(sampler, cell+vec2(     0, ORDER), vec2(-pos,  -1), iResolution.xy),\n                                      vec2( 0, 1))*Evaluate(subcell.x, subcell.y, vec2(-pos,   1)) * weight;\n    }\n    return rateOfChange;\n}\nvoid Limit(inout vec4 Q, vec2 cell, vec2 subcell)\n{\n    // We do limiting via a check on the high-frequency components and limiting\n    vec4 sumsq = vec4(0.);\n    for (float n = 0.; n < ORDER; n++)\n    {\n        vec4 sp = texture(iChannel0, (cell + vec2(ORDER-n-1., n) + 0.5)/iResolution.xy);\n        sumsq  += sp*sp;\n    }\n    sumsq = sqrt(sumsq);\n    vec4 Q0 = texture(iChannel0, (cell+0.5)/iResolution.xy);\n    Q0.gb = vec2(sqrt(GAMMA*(GAMMA-1.)*(Q0.a - 0.5*dot(Q0.gb, Q0.gb)/Q0.r)/Q0.r));\n    // if (ORDER*ORDER*sumsq) >~ Q0, we want to limit the cell\n    float scalefactor = (subcell.x+subcell.y)/(ORDER);\n    scalefactor *= scalefactor*scalefactor;\n    Q *= 1. - scalefactor*(1.-Q0/max(Q0, 0.5*(ORDER-1.)*(ORDER-1.)*sumsq));\n}\n\n// Evolution of the cell\nvoid mainImage( out vec4 Q, in vec2 fragCoord )\n{\n    vec2 cell    = floor(fragCoord/ORDER)*ORDER;\n    vec2 subcell = floor(fragCoord - cell);\n        \n    if (iFrame % 2 == 0)\n    {\n        vec4 rateOfChange = RateOfChange(iChannel0, cell, subcell);\n        Q  = texture(iChannel0, fragCoord/iResolution.xy);\n        Q += rateOfChange*DT;\n        Limit(Q, cell, subcell);\n    }\n    else\n    {\n        vec4 rateOfChange = RateOfChange(iChannel0, cell, subcell);\n        Q  = 0.5*(texture(iChannel0, fragCoord/iResolution.xy) + texture(iChannel1, fragCoord/iResolution.xy));\n        Q += 0.5*rateOfChange*DT;\n        Limit(Q, cell, subcell);\n    }\n    \n    // Initial conditions (integrate sub-cell values)\n    if (iFrame == 1)\n    {\n        #ifdef SUBCELL_INITIALCONDITIONS\n        Q = vec4(0);\n        for (float x = 0.; x <= HALF_INTEG_ORDER; x++)\n        {\n            float x_weight = Weight(x);\n            for (float y = 0.; y <= HALF_INTEG_ORDER; y++)\n            {\n                vec2  point    = vec2(cos(x*PI/(2.*HALF_INTEG_ORDER)), cos(y*PI/(2.*HALF_INTEG_ORDER)));\n                float y_weight = Weight(y);\n                \n                Q += texture(iChannel3, (cell+0.5*ORDER*(vec2( 1, 1)*point+1.))/iResolution.xy)\n                         *Evaluate(subcell.x, subcell.y, vec2( 1, 1)*point)*x_weight*y_weight;\n                Q += texture(iChannel3, (cell+0.5*ORDER*(vec2(-1, 1)*point+1.))/iResolution.xy)\n                         *Evaluate(subcell.x, subcell.y, vec2(-1, 1)*point)*x_weight*y_weight;\n                Q += texture(iChannel3, (cell+0.5*ORDER*(vec2( 1,-1)*point+1.))/iResolution.xy)\n                         *Evaluate(subcell.x, subcell.y, vec2( 1,-1)*point)*x_weight*y_weight;\n                Q += texture(iChannel3, (cell+0.5*ORDER*(vec2(-1,-1)*point+1.))/iResolution.xy)\n                         *Evaluate(subcell.x, subcell.y, vec2(-1,-1)*point)*x_weight*y_weight;\n            }\n        }\n        #else\n        if (subcell == vec2(0))\n        {\n            Q = texture(iChannel3, (cell+ORDER*0.5+0.5)/iResolution.xy);\n        }\n        else\n        {\n            Q = vec4(0);\n        }\n        #endif\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Used for second-order integration\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Initial conditions buffer\nvec4 InitialConditions(vec2 coord)\n{\n    /*\n    coord = 1.4*iResolution.xy/iResolution.yy\n    float inner = smoothstep(-0.01,0.01,length(coord)                                         - 0.32);\n    float outer = smoothstep(-0.01,0.01,length(coord) + 0.005*cos(12.*atan(coord.x, coord.y)) - 0.45);\n    \n    return mix(mix(vec4(10,0,0,1),vec4(1,0,0,1),inner),vec4(1,0,0,50),outer);\n    */\n    return mix(vec4(4.,0.25,0.,2.), vec4(1.,-1.,0.,2.5), smoothstep(-0.005,0.005,abs(coord.y)-0.15+0.003*sin(coord.x*PI*22.+PI*coord.y)+0.01*sin(coord.x*PI*6.+PI*coord.y)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = mix(vec4(0.1,0,0,0.1), vec4(1,0,0,2), smoothstep(0.2,0.3,length(fragCoord - iResolution.xy/2.)/iResolution.y));\n    fragColor = InitialConditions((fragCoord - iResolution.xy/2.)/iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"}]}