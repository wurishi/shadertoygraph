{"ver":"0.1","info":{"id":"MllGRn","date":"1434567549","viewed":159,"name":"TH_DistanceField","username":"TomHammersley","description":"Ray marching distance fields","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float sphereDistance(vec3 position, vec3 spherePosition, float sphereRadius)\n{\n    vec3 delta = position - spherePosition;\n    return length(delta) - sphereRadius;\n}\n\nvec3 sphereNormal(vec3 position, vec3 spherePosition, float sphereRadius)\n{\n    return normalize(position - spherePosition);\n}\n\nfloat planeDistance(vec3 position, vec4 planeEq)\n{\n    return dot(position, planeEq.xyz) + planeEq.w;\n}\n\nbool shadowTest(vec3 pos1, vec3 pos2, in vec3 spherePositions[3], in float sphereRadius[3], in vec3 sphereColours[3], in vec4 plane, in int hitSphereIndex)\n{\n    float hitEpsilon = 0.01;\n    vec3 rayPosition = pos1;\n    vec3 rayDirection = normalize(pos2 - pos1);\n    for(int step = 0; step < 4; ++step)\n    {\n        vec3 nearestColour;\n        vec3 nearestNormal;\n        float nearestDistance = 10000000000.0;\n        for(int sphere = 0; sphere < 3; ++sphere)\n        {\n            if(sphere != hitSphereIndex)\n            {\n        \t\tfloat distToSphere = sphereDistance(rayPosition, spherePositions[sphere], sphereRadius[sphere]);\n            \tif(distToSphere < nearestDistance)\n            \t{\n\t\t\t\t\tnearestDistance = distToSphere;\n    \t            nearestNormal = sphereNormal(rayPosition, spherePositions[sphere], sphereRadius[sphere]);\n        \t        nearestColour = sphereColours[sphere];\n            \t}\n            }\n        }\n        \n        float distToPlane = planeDistance(rayPosition, plane);\n        if(distToPlane < nearestDistance && distToPlane > 0.0)\n        {\n            nearestDistance = distToPlane;\n            nearestNormal = plane.xyz;\n            nearestColour = vec3(0.5, 0.5, 0.5);\n        }\n        \n        if(nearestDistance < hitEpsilon)\n        {\n            return true;\n        }\n        else\n        {\n            // If we didn't hit then the nearest distance tells us how far away the nearest object is and therefore\n            // we can step at most that far without hitting anything\n            \n            // so\n            \n            // Step *almost* that far and try again\n            rayPosition += rayDirection * nearestDistance * (1.0 - hitEpsilon);\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set up a ray\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 rayDirection = vec3(uv * 2.0 - 1.0, 1.0);\n    rayDirection.y *= iResolution.y / iResolution.x;\n    rayDirection = normalize(rayDirection);\n            \n   \t// Scene - light source\n    vec3 lightPosition = vec3(0.6, 5.0, 2.0);\n\n    // Scene - spheres\n    float scaledTime = iTime * 0.1;\n    float theta0    = fract(scaledTime) * 2.0 * 3.141;\n    float cosTheta0 = cos(theta0);\n    float sinTheta0 = sin(theta0);\n    float theta1    = fract(scaledTime + 0.5) * 2.0 * 3.141;\n    float cosTheta1 = cos(theta1);\n    float sinTheta1 = sin(theta1);\n    const int numSpheres = 3;\n\tvec3 spherePositions[3];\n    vec3 sphereColours[3];\n    float sphereRadius[3];\n    spherePositions[0] = vec3(cosTheta0 * 2.0, 0.0, -sinTheta0 * 2.0 + 5.0);\n    spherePositions[1] = vec3( 0.0, 0.0, 5.0);\n    spherePositions[2] = vec3(cosTheta1 * 2.0, 0.0, -sinTheta1 * 2.0 + 5.0);\n    sphereColours[0] = vec3(1.0, 0.0, 0.0);\n    sphereColours[1] = vec3(0.0, 1.0, 0.0);\n    sphereColours[2] = vec3(0.0, 0.0, 1.0);\n    sphereRadius[0] = 0.6;\n    sphereRadius[1] = 0.3;\n    sphereRadius[2] = 0.6;\n\n    // Scene - plane\n    vec4 plane = vec4(0.0, 1.0, 0.0, 3.0);\n    \n    vec3 rayPosition = vec3(0.0, 0.0, 0.0);\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    float hitEpsilon = 0.001;\n    for(int step = 0; step < 48; ++step)\n    {\n        int nearestSphere = -1;\n        vec3 nearestColour;\n        vec3 nearestNormal;\n        float nearestDistance = 10000000000.0;\n        for(int sphere = 0; sphere < numSpheres; ++sphere)\n        {\n        \tfloat distToSphere = sphereDistance(rayPosition, spherePositions[sphere], sphereRadius[sphere]);\n            if(distToSphere < nearestDistance)\n            {\n\t\t\t\tnearestDistance = distToSphere;\n                nearestNormal = sphereNormal(rayPosition, spherePositions[sphere], sphereRadius[sphere]);\n                nearestColour = sphereColours[sphere];\n                nearestSphere = sphere;\n            }\n        }\n        \n        float distToPlane = planeDistance(rayPosition, plane);\n        if(distToPlane < nearestDistance && distToPlane > 0.0)\n        {\n            nearestDistance = distToPlane;\n            nearestNormal = plane.xyz;\n            nearestColour = vec3(0.5, 0.5, 0.5);\n            nearestSphere = -1;\n        }\n        \n        if(nearestDistance < hitEpsilon)\n        {\n            // Hit the object - adjust ray position and shade\n            vec3 hitPosition = rayPosition + rayDirection * nearestDistance;\n            vec3 hitNormal = nearestNormal;//sphereNormal(hitPosition, nearestSpherePosition, nearestSphereRadius);\n\n            if(!shadowTest(hitPosition + rayDirection * 0.01,\n                           lightPosition - rayDirection * 0.01,\n                           spherePositions, \n                           sphereRadius,\n                           sphereColours,\n                           plane,\n                           nearestSphere))\n            {\n                vec3 lightDir = normalize(lightPosition - hitPosition);\n                float NdotL = clamp(dot(hitNormal, lightDir), 0.0, 1.0);\n                colour = NdotL * nearestColour;\n            }\n            \n            colour += vec3(0.1, 0.1, 0.1);\n            \n            break;\n        }\n        else\n        {\n            // If we didn't hit then the nearest distance tells us how far away the nearest object is and therefore\n            // we can step at most that far without hitting anything\n            \n            // so\n            \n            // Step *almost* that far and try again\n            rayPosition += rayDirection * nearestDistance * (1.0 - hitEpsilon);\n        }\n    }\n    \n\tfragColor = vec4(colour, 1.0);\n}\n","name":"","description":"","type":"image"}]}