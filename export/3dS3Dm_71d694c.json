{"ver":"0.1","info":{"id":"3dS3Dm","date":"1548977063","viewed":229,"name":"[TWITCH] Studies on rupees","username":"Flopine","description":"This is the result of a live session on Twitch, you can see the progression here : https://www.twitch.tv/videos/373019927\n\nWant to try some Zelda rendering stuff again, on small objects this time :) Hope you'll enjoyed it","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","palette","specular","zelda","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define time iTime\n#define ITER 64.\n#define PI 3.141592\n\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 25.18152)))*5418.548416);}\n\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a), -sin(a), cos(a));}\n\n\nfloat moda (inout vec2 p, float rep)\n{\n  float per = 2.*PI/rep;\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  float id = floor(a/per);\n  a = mod(a, per)-per/2.;\n  p = vec2(cos(a), sin(a))*l;\n  // condition on the id can be found in mercury lib : http://mercury.sexy/hg_sdf/\n  if (abs(id) >= (rep/2.)) id = abs(id);\n\treturn id;\n}\n\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(max(q.x, max(q.y, q.z)),0.) + length(max(q,0.));\n}\n\n\nfloat plane (vec3 p, vec3 n, float dist)\n{return dot(p,normalize(n))-dist;}\n\n\nfloat crystal (vec3 p)\n{\n  p.xz *= rot(time*0.5);\n  p.yz *= rot(time*0.8);\n  float b = box(p, vec3(.5, 0.7, 0.15));\n  p = abs(p);\n  float p1 = plane (p, vec3(0.7,1.,0.7), 0.5);\n  float p2 = plane (p, vec3(1.,0.,0.8), 0.3);\n  float d = max(p2,max(b,p1));\n  return d;\n}\n\n\nvec2 SDF (vec3 p)\n{\n  p.xy *= rot(time*0.1);\n  float id_crystal = moda(p.xy, 3.);\n  p.x -= 1.+sin(time)*0.2+0.1;\n  return vec2(crystal(p), id_crystal);\n}\n\n\nvec3 palette (float uv)\n{\n  if (uv < -0.33) return vec3(8.,0.,0.5);\n  if (uv >= -0.33 && uv < 0.3) return vec3(0.,.8,0.3);\n  if (uv >= 0.3) return vec3(0.,0.,.8);\n}\n\n\nvec3 get_normals(vec3 p)\n{\n  vec2 eps = vec2(0.01,0.);\n  return normalize(vec3(SDF(p+eps.xyy).x - SDF(p-eps.xyy).x,\n                        SDF(p+eps.yxy).x - SDF(p-eps.yxy).x,\n                        SDF(p+eps.yyx).x - SDF(p-eps.yyx).x\n                        )\n                  );\n}\n\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+.5;}\n\n\nvec3 point_light (vec3 p, vec3 n)\n{\n  vec3 lpos = vec3(0.,0., 1.);\n  vec3 ldir = normalize(lpos-p);\n  float ldist = length(lpos-p);\n  float dotNL = dot(n , ldir)* 0.5 +0.5;\n  return (vec3(0.4,0.4,0.1)*dotNL) / (0.5 * ldist * ldist);\n}\n\n// courtesy of Alkama\nvec3 pales (vec2 uv)\n{\n  uv *= rot(-time*.2);\n  return floor(smoothstep(0.1, 0.2,cos(atan(uv.y, uv.x)*5.)))*vec3(0.4);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n \tuv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = random(uv);\n\n    vec3 ro = vec3(0.001,0.001, -4.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(0.);\n    \n    float shad = 0.;\n    float fre = 0.;\n    for (float i=0.; i<ITER;i++)\n    {\n        vec2 d = SDF(p);\n        if (d.x<0.01)\n        {\n            // get the normals\n            vec3 n = get_normals(p);\n            // declare a directionnal light\n            vec3 l = vec3(0.,1.,-2.);\n\n\t\t\t// albedo from a palette ranged with id's of rupees\n            col  =  palette(d.y);\n            \n            // get the global lighting\n            float _lighting = lighting(n, l);\n            col += mix(vec3(0.1), vec3(0.6,0.5,0.), _lighting);\n            \n            // get the point light\n            vec3 point = point_light(p,n);\n            col += point;\n            \n            // calculate the fresnel\n            fre = pow(1.-clamp(dot(-rd, n),0.,1.), 4.5);\n            col += fre*palette(d.y+5.)*1.5;\n            \n            // half vector for specular\n            vec3 h = normalize(l-rd);\n            // calculate the specular\n            float spe = pow(max(dot(h,n) ,0.), 15.);\n            col += spe*_lighting;\n            \n            // fake AO\n            shad = i/ITER;\n            col *= (1.-shad);\n\n            break;\n        }     \n        if (d.x>10.)\n        {\n            col = pales(uv);\n            break;\n        } \n\t\t\n        d.x *= 0.9 + dither*0.1;\n        p+=d.x*rd;\n    }\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}