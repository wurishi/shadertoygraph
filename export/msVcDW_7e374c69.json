{"ver":"0.1","info":{"id":"msVcDW","date":"1696168380","viewed":39,"name":"Mouse drag 3","username":"mrboggieman","description":"Demo of dragging around items with the mouse (state persisted in buffers). Simplified the state persistence and magic.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["mouse","state","drag"],"hasliked":0,"parentid":"ctfczj","parentname":"Mouse drag 2 (derived state)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//MIT Licence\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    \n    //draw circles\n    int circleDragIndex = getInt(dragIndex);\n\n    for (int i=0; i<circles.length(); i++) {\n        Circle circle = circles[i];\n\n        if (distance(uv, getVec2(circle.position)) < circle.radius) {\n            vec3 col = circle.colour;\n\n            //being dragged? highlight it\n            if (circleDragIndex == circle.index) {\n                col = vec3(0.0, 1.0, 0.0);\n            }\n            \n            fragColor = vec4(col, 1.0);\n            return;\n        }\n    }\n\n    fragColor = vec4(vec3(0.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool isMouseDown() {\n    return iMouse.z > 0.0;\n}\n\nvec2 getMousePosition() {\n    return iMouse.xy / iResolution.y;\n}\n\nvec2 calcDragPosition() {\n    if (isMouseDown()) {\n        return getMousePosition();\n    }\n    \n    return getVec2(dragPosition);\n}\n\nint calcDragIndex() {\n    //stop dragging when the mouse is released\n    if (!isMouseDown()) {\n        return -1;\n    }\n    \n    //something is already being dragged, keep dragging it\n    int prevDragIndex = getInt(dragIndex);\n    if (prevDragIndex != -1) {\n        return prevDragIndex;\n    }\n    \n    //if there are no dragged item, check if any of the items can be dragged\n    vec2 mousePosition = getMousePosition();\n\n    for (int i=0; i<circles.length(); i++) {\n        Circle circle = circles[i];\n        \n        //ensure the mouse is inside the circle when the mouse is down to drag\n        if (distance(mousePosition, getVec2(circle.position)) < circle.radius) {\n            return circle.index;\n        }\n    }\n\n    //nothing being dragged\n    return -1;\n}\n\nvec2 calcCirclePosition(Circle circle) {\n    if (circle.index == getInt(dragIndex)) {\n        //this is the circle we are dragging, move it\n        return getVec2(circle.position) + getMousePosition() - getVec2(dragPosition);\n    } else {\n        //keep track of the previous position\n        return getVec2(circle.position);\n    }\n}\n\n//need to map the result back into a vec4 so we can store it\nvec4 intoVec4(in float data) { return vec4(data, 0.0, 0.0, 0.0); }\nvec4 intoVec4(in vec2 data) { return vec4(data, 0.0, 0.0); }\nvec4 intoVec4(in vec3 data) { return vec4(data, 0.0); }\nvec4 intoVec4(in vec4 data) { return data; }\nvec4 intoVec4(in bool data) { return vec4(data, 0.0, 0.0, 0.0); }\nvec4 intoVec4(in bvec2 data) { return vec4(data, 0.0, 0.0); }\nvec4 intoVec4(in bvec3 data) { return vec4(data, 0.0); }\nvec4 intoVec4(in bvec4 data) { return vec4(data); }\nvec4 intoVec4(in int data) { return vec4(data, 0.0, 0.0, 0.0); }\nvec4 intoVec4(in ivec2 data) { return vec4(data, 0.0, 0.0); }\nvec4 intoVec4(in ivec3 data) { return vec4(data, 0.0); }\nvec4 intoVec4(in ivec4 data) { return vec4(data); }\nvec4 intoVec4(in uint data) { return vec4(data, 0.0, 0.0, 0.0); }\nvec4 intoVec4(in uvec2 data) { return vec4(data, 0.0, 0.0); }\nvec4 intoVec4(in uvec3 data) { return vec4(data, 0.0); }\nvec4 intoVec4(in uvec4 data) { return vec4(data); }\n\n#define store(item, func) if (index == item.index) { fragColor = intoVec4(func); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = toIndex(fragCoord);\n    \n    //default to the previous frame\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    \n    //set the initial values if they have not yet been set\n    if (!getBool(initialValuesSet)) {\n        if (index < dynamic_items.length()) {\n            Item item = dynamic_items[index];\n            fragColor = item.value;\n        }\n        return;\n    }\n    \n    //associate the functions to call to calculate each dynamic value\n    for (int i=0; i<circles.length(); i++) {\n        Circle circle = circles[i];\n        store(circle.position, calcCirclePosition(circle));\n    }\n\n    store(dragIndex, calcDragIndex());\n    store(dragPosition, calcDragPosition());\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//used across persistance and rendering\n#define fromIndex(index) ivec2(index % int(iResolution.x), floor(float(index) / iResolution.x))\n#define toIndex(uv) int(floor(uv.x) + floor(uv.y) * iResolution.x)\n#define get(item) texelFetch(iChannel0, fromIndex(item.index), 0).rgba\n#define getBool(item) bool(get(item).r)\n#define getBvec2(item) bvec2(get(item).rg)\n#define getBvec3(item) bvec3(get(item).rgb)\n#define getBvec4(item) bvec4(get(item).rgba)\n#define getUint(item) uint(get(item).r)\n#define getUvec2(item) uvec2(get(item).rg)\n#define getUvec3(item) uvec3(get(item).rgb)\n#define getUvec4(item) uvec4(get(item).rgba)\n#define getInt(item) int(get(item).r)\n#define getIvec2(item) ivec2(get(item).rg)\n#define getIvec3(item) ivec3(get(item).rgb)\n#define getIvec4(item) ivec4(get(item).rgba)\n#define getFloat(item) get(item).r\n#define getVec2(item) get(item).rg\n#define getVec3(item) get(item).rgb\n#define getVec4(item) get(item).rgba\n\n//just a wrapper around a value we want to persist and the index where it should be saved\n#define item(value, index) Item(vec4(value, 0.0, 0.0, 0.0), index)\n#define item2(value, index) Item(vec4(value, 0.0, 0.0), index)\n#define item3(value, index) Item(vec4(value, 0.0), index)\n#define item4(value, index) Item(vec4(value), index)\n\nstruct Item {\n    vec4 value;\n    int index;\n};\n\n//demo\nstruct Circle {\n    Item position;\n    float radius;\n    vec3 colour;\n    int index;\n};\n\nconst Circle circle1 = Circle(item2(vec2(0.4, 0.4), 0), 0.1, vec3(1.0, 0.0, 0.0), 0);\nconst Circle circle2 = Circle(item2(vec2(0.8, 0.6), 1), 0.2, vec3(0.0, 0.0, 1.0), 1);\nconst Circle circle3 = Circle(item2(vec2(0.5, 0.1), 2), 0.3, vec3(1.0, 0.0, 1.0), 2);\n\nconst Item dragPosition = item2(vec2(0.0), 3);\nconst Item dragIndex = item(-1, 4);\n\nconst Item initialValuesSet = item(true, 5);\n\nconst Circle[] circles = Circle[](\n    circle1,\n    circle2,\n    circle3\n);\n\nconst Item[] dynamic_items = Item[](\n    circle1.position,\n    circle2.position,\n    circle3.position,\n    dragPosition,\n    dragIndex,\n    initialValuesSet\n);\n","name":"Common","description":"","type":"common"}]}