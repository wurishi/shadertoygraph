{"ver":"0.1","info":{"id":"wlByRV","date":"1594826580","viewed":205,"name":"Textured Tunnel","username":"voax","description":"stripped down version of https://www.shadertoy.com/view/XllBRB\nadded some parameters; mouse controls curvature/squareness","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","tunnel","textured","curved"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float speed \t = 4.0;\nfloat squareness = 1.0;\nfloat swirl\t\t = 0.2;\nfloat fadeout\t = 1.0;\nvec2 curvature \t = vec2(2.0, 2.0);\nvec3 bg \t\t = vec3(1,1,1);\n\n#define EPS 0.005\n#define FAR 40.0 \n#define PI 3.14159265359\n#define T iTime\n#define NTILES 1.0\n\nstruct Scene {\n    float t;\n    vec2 walluv;\n    vec2 uvr;\n};\n    \nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\nvec3 path(float t) {\n    vec2 ab = vec2(sin(t * PI / 16.0 + 1.5707963 * 1.0),\n        \t\t   cos(t * PI / 16.0));\n    return vec3(ab * curvature, t);    \n}\n\nScene map(vec3 rp) {\n    rp.xy -= path(rp.z).xy;\n    rp.xy = rot(rp.z * swirl) * rp.xy;\n    \n    float r1 = length(rp.xy);\n    float r2 = pow( pow(rp.x*rp.x,4.0) + pow(rp.y*rp.y,4.0), 1.0/8.0 );\n    float r = mix(r1,r2, squareness);\n    \n    float a = atan(rp.y,rp.x);\n    \n    vec2 uv = vec2(a / PI, rp.z);\n    vec2 uvr = vec2(abs(a) / PI, rp.z);\n\n    float tun = 1.7 - r;\n\n    return Scene(tun, uv, uvr);\n}\n\nScene march(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    vec2 walluv = vec2(0.0);\n    vec2 walluvr = vec2(0.0);\n    vec2 cellid = vec2(0.0);\n    float edge1 = 0.0;\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        Scene scene = map(rp);\n        if (scene.t < EPS || scene.t > FAR) {\n            walluv = scene.walluv;\n            walluvr = scene.uvr;\n            break;\n        }\n        t += scene.t;\n    }\n    \n    return Scene(t, walluv, walluvr);\n}\n\nvec3 colour(Scene scene) {\n    return textureGrad(iChannel0, scene.walluv, dFdx(scene.uvr), dFdy(scene.uvr)).xyz; // uvr: https://iquilezles.org/articles/tunnel\n}\n\nvoid setupCamera(vec2 fragCoord, out vec3 ro, out vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    float ct = T * speed;\n\n    vec3 lookAt = vec3(0.0, 0.0, ct);\n    ro = lookAt + vec3(0.0, 0.0, -5.0);\n\n    lookAt.xy += path(lookAt.z).xy;\n    ro.xy += path(ro.z).xy;\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iMouse.z > 0.5) {\n     \tcurvature *= iMouse.x/iResolution.x;\n        squareness *= iMouse.y/iResolution.y;\n    }\n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n\n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n\n    Scene scene = march(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        pc = colour(scene) / (scene.t * 0.5);\n        mint = scene.t;\n    }\n    else\n        pc = bg;\n    \n    pc = mix(pc, bg, fadeout * pow(scene.t/FAR, 2.0));\n        \n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}