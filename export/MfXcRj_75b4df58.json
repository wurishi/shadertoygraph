{"ver":"0.1","info":{"id":"MfXcRj","date":"1721305040","viewed":117,"name":"FABRIK inverse kinematics solver","username":"chronos","description":"FABRIK, Forwards And Backwards Reaching Inverse Kinematics. Approximate inverse kinematics solver.","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["interactive","inverse","approximate","kinematics","fabrik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    FABRIK inverse kinematics solver by chronos\n    -------------------------------------------------\n\n    FABRIK: Forwards And Backwards Reaching Inverse Kinematics.\n    Simple and quick approximate IK solver.\n    \n    One issue with this approach, besides being approximate,\n    is that it doesn't always give continuous/smooth solutions,\n    which can lead to undesirable popping when used in e.g procedural animation.\n    \n    Inspired by: \"A simple procedural animation technique\" by argonaut\n    https://www.youtube.com/watch?v=qlfh_rv6khY\n    \n    See also: \"Curious Blob\" https://www.shadertoy.com/view/MffyD4\n    \n    self link: https://www.shadertoy.com/view/MfXcRj\n*/\n\nconst int num_iterations = 5;\nconst int num_nodes = 4;\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\n\nfloat dsc(vec2 a, float r, vec2 p)\n{\n    return length(a - p) - r;\n}\n\nfloat crc(vec2 a, float r, vec2 p)\n{\n    return abs(length(a - p) - r);\n}\n\nfloat target(vec2 a, float r, vec2 p)\n{\n    return min(seg(a-vec2(r), a+vec2(r), p), seg(a-vec2(-r,r), a+vec2(-r,r), p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = .5;\n    vec2 uv = zoom*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 mouse = zoom*(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    if(length(iMouse.xy) < 10.) mouse = zoom*vec2(1.3*cos(iTime*.3), .75*sin(iTime)); // Idle mouse animation\n    \n    float ps = zoom*2./iResolution.y;\n    \n    vec3 bg_color = vec3(3,6,9)*.1 * (1.-length(uv*.5));\n    \n    vec3 color = bg_color;\n    \n    float link_size = 0.2; // Distance constraint between consequtive nodes\n    \n    // Allocate and initialize nodes\n    vec2 nodes[num_nodes];\n    for(int n = 0; n < num_nodes; n++)\n    {\n        nodes[n] = vec2(n,0)*link_size;\n    }\n    \n    // FABRIK:\n    for(int i = 0; i < num_iterations; i++)\n    {\n        // Forwards:\n        nodes[num_nodes-1] = mouse;\n        \n        \n        // Enforce constraints (from last to first)\n        for(int n = num_nodes-2; n > 0; n--)\n        {\n            nodes[n] = normalize(nodes[n] - nodes[n+1]) * link_size + nodes[n+1];\n        }\n        \n        // Backwards:\n        nodes[0] = vec2(0);\n        \n        // Enforce constraints (from first to last)\n        for(int n = 0; n < num_nodes-1; n++)\n        {\n            nodes[n+1] = normalize(nodes[n+1] - nodes[n]) * link_size + nodes[n];\n        }\n    }\n    \n    \n    // Drawing\n    \n    float r = 0.05; // Drawn circle radius\n    \n    for(int i = 0; i < num_nodes-1; i++) // Iterate over chain\n    {\n        float disc = smoothstep(ps, -ps, dsc(nodes[i], r, uv));\n        float circle = smoothstep(2. * ps, .5*ps, crc(nodes[i], r, uv));\n        float segment = smoothstep(2. * ps, .5*ps, seg(nodes[i], nodes[i+1], uv));\n\n        color = mix(color, vec3(1), segment);\n        color = mix(color, bg_color, disc);\n        color = mix(color, vec3(1), circle);\n    }\n    \n    float disc = smoothstep(ps, -ps, dsc(nodes[num_nodes-1], r, uv));\n    float circle = smoothstep(2. * ps, .5*ps, crc(nodes[num_nodes-1], r, uv));\n\n    color = mix(color, bg_color, disc); // last disc\n    color = mix(color, vec3(1), circle);// last circle\n    \n    float d = target(mouse, 0.025, uv);\n    float alpha = smoothstep(2.*ps, ps, d);\n    color = mix(color, vec3(1), alpha); // Target X\n\n    color = mix(color, vec3(1), smoothstep(ps, -ps, dsc(nodes[0], r*0.6, uv))); // Anchor\n    \n    \n    color = pow(color, vec3(1./2.2)); // Approximate gamma\n    color += (texelFetch(iChannel0, ivec2(fragCoord)%1024, 0).rgb-0.5)/255.; // Dither\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}