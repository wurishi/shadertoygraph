{"ver":"0.1","info":{"id":"td2fRw","date":"1589752228","viewed":149,"name":"Basic Shapes RM with texture","username":"ibragim_aghdabi","description":"work and progress","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raymarchirng"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// some relief lighting\n\n#define Res  iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n#define Res3 vec2(textureSize(iChannel3,0))\n\nvec4 getRand(vec2 pos) \n{\n    vec2 uv=pos/Res1;\n    return texture(iChannel1,uv);\n}\n\nfloat getVal(vec2 uv)\n{\n\tfloat r = getRand(uv*iResolution.xy*.02).x*2.-1.;\n\tr=0.*exp(-abs(r)/0.05);\n\t\n    return mix(1.,\n    //length(textureLod(iChannel0,uv,1.7+.5*log2(iResolution.x/1920.)).xyz)\n    length(textureLod(iChannel0,uv,2.5+.5*log2(iResolution.x/1920.)).xyz)*.6+\n    length(textureLod(iChannel0,uv,1.5+.5*log2(iResolution.x/1920.)).xyz)*.3+\n    length(textureLod(iChannel0,uv,.5+.5*log2(iResolution.x/1920.)).xyz)*.2\n    ,1.-r);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/Res;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),150.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,-1,.8));\n    float diff=clamp(dot(n,light),0.,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,12.0)*.5;\n    float sh=clamp(dot(reflect(light*vec3(-1,-1,1),n),vec3(0,0,-1)),0.0,1.0);\n    sh=pow(sh,4.0)*.1;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*mix(diff,1.,.8)+spec*vec4(.85,1.,1.15,1.)-sh*vec4(.85,1.,1.15,1.);\n\tfragColor.w=1.;\n    \n    if(true)\n    {\n        vec2 scc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n        float vign = 1.3-2.5*dot(scc,scc);\n        vign*=1.-.8*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n        vign*=1.-.8*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n        fragColor.xyz *= vign;\n    }\n    \n\t//fragColor = texture(iChannel3,fragCoord/Res3);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t= clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t= clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x,y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n\n}\n\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s, 0.));\n}\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float cd = sdCapsule(p, vec3(5, 2, 11), vec3(5, 1, 11), .1);  // position,size\n    float td = sdTorus(p-vec3(0.5,.5,9), vec2(1.5, .1));\n    float bd = dBox(p-vec3(-2.7, .5, 6), vec3(.6));\n    float cyld = sdCylinder(p, vec3(0, .3, 3.5), vec3(3, .3, 5), .2);\n    \n    float d = min(cd, planeDist);\n    d = min(d, td);\n    d = min(d, bd);\n    d = min(d, cyld);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    \n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3 (0);\n    vec3 ro = vec3(0, 2, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y-.15, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd *  d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// trying to resemble oil painting style\n\n#define PI2 6.28318531\n\n#define Res  iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n\nvec4 getCol(vec2 pos, float level)\n{\n    // preserve aspect ratio of original vid\n\tvec2 uv = (pos-Res*.5)*min(Res0.x/Res.x,Res0.y/Res.y)/Res0+.5;\n    \n    vec4 c1 = textureLod(iChannel0,uv,level);\n    //return c1;\n\n    // green screen and bg\n    uv = uv*vec2(-1,-1)*2.7+0.015*vec2(sin(iTime*1.1),sin(iTime*0.271));\n    // had to use .xxxw because tex on channel2 seems to be a GL_RED-only tex now (was probably GL_LUMINANCE-only before)\n    vec4 c2 = vec4( vec3(0.5,0.7,1.0)*.5*(.3*textureLod(iChannel2,uv,level).xyz+.7*textureLod(iChannel2,uv*.33,level).xyz), 1 );\n    float d=clamp(dot(c1.xyz,vec3(-0.5,1.0,-0.5)),0.0,1.0);\n    return mix(c1,c2,1.8*d);\n    return c1;\n}\n\nfloat getVal(vec2 pos, float level)\n{\n    return length(getCol(pos,level).xyz)+0.0002*length(pos-0.5*Res);\n}\n    \nvec2 getGrad(vec2 pos,float delta)\n{\n    float l = log2(delta*Res0.x/Res.x);\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(pos+d.xy,l)-getVal(pos-d.xy,l),\n        getVal(pos+d.yx,l)-getVal(pos-d.yx,l)\n    )/delta;\n}\n\nvec4 getRand(vec2 pos) \n{\n    vec2 uv=pos/Res1;\n    return texture(iChannel1,uv);\n}\n\nvec4 getRandBlueS(vec2 pos) \n{\n    vec2 uv=pos/Res1;\n    return texture(iChannel1,uv)-texture(iChannel1,uv+.5);\n}\n\nvec4 getRandBlue(vec2 pos) \n{\n    vec2 uv=pos/Res1;\n    vec4 c = clamp((texture(iChannel1,uv)-texture(iChannel1,uv+.5))*1.2+.5,0.,1.);\n    //return c;\n    return mix(c.xxxx,c,.3);\n}\n\nvec4 getPatt(vec2 pos) \n{\n    vec2 uv=pos/Res1;\n    vec4 s = sin(.23*pos.xyxy*PI2-vec4(0,0,PI2/4.,PI2/4.))*.5+.5;\n    return vec4(\n        dot(s.xy,vec2(.5)),\n        dot(s.zw,vec2(.5)),\n        dot(s.yz,vec2(.5)),\n        dot(s.wx,vec2(.5))\n        )\n    ;\n}\n\nvec4 getColDist(vec2 pos)\n{\n\t//return smoothstep(0.5,1.5,getCol(pos,0.)+getRand(pos).xxxx);\n\treturn 1.-smoothstep(0.5,1.5,(1.-getCol(pos,0.))+pow(getRandBlue(pos),vec4(.75))*.75);\n\t//return smoothstep(0.5,1.5,getCol(pos,0.)+mix(getPatt(pos),getRandBlue(pos),.75));\n}\n\n#define SampNum 24\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos0 = fragCoord;\n    vec2 pos = pos0;\n    vec3 col=vec3(0);\n    float cnt=0.0;\n    float fact=1.0;\n    for(int i=0;i<SampNum;i++)\n    {\n        col+=fact*getColDist(pos).xyz;\n        vec2 gr=vec2(0);\n        gr+=getGrad(pos,8.0*iResolution.x/600.);\n        gr+=getGrad(pos,4.0*iResolution.x/600.);\n        gr+=getGrad(pos,2.0*iResolution.x/600.);\n        //gr+=getGrad(pos,1.0*iResolution.x/600.);\n        \t\n        vec2 d = gr.yx*vec2(1,-1);\n        \n        pos+=.5*iResolution.x/600.*normalize(d);\n        //fact/=1.1;\n        cnt+=fact;\n    }\n    col/=cnt;\n\tfragColor = vec4(col,1.0);\n\t//fragColor.xyz = getPatt(pos0).xyz;\n\t//float r = getRand(pos0*.07).x*2.-1.;\n\t//r=exp(-r*r/0.03);\n\t//fragColor.xyz = vec3(0)+r;\n}\n\n","name":"Buf B","description":"","type":"buffer"}]}