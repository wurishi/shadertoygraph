{"ver":"0.1","info":{"id":"tdVyzW","date":"1602453756","viewed":97,"name":"Mandlebrot Example","username":"TheMunro","description":"Controls:\nWASD: translate\nQE: rotate\n-/+: zoom (need to update this, broken for some)","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["mandlebrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nconst int iterations = 512;\n\n//read normalised data from buffer a texture\nvec4 get_transform(vec2 uv) \n{\n    return texture(iChannel0, uv).xyzw;\n}\n\n//encode complex number as 2d vector\n//(x + yi)^2\n//x^2 + 2xyi + y^2*i^2\n//x^2 + 2xyi - y^2\n//(x^2 - y^2) + (2xy)i\nvec2 square_complex (vec2 p) \n{\n    return vec2(p.x * p.x - p.y * p.y, 2. * p.x * p.y);\n}\n\nfloat mandlebrot(vec2 p) \n{\n    vec2 z = vec2(0,0);\n    const float B = 256.0;\n    float acc = 0.0;\n    \n    for(int i = 0; i <= iterations; i++)\n    {\n        //iteration step\n        z = square_complex(z) + p;\n\n        //no idea how this works yet\n        //https://iquilezles.org/articles/msetsmooth\n        if( dot(z,z)>(B*B) ) \n            break;\n        \n        acc += 1.0;\n    }\n    \n    //inside boundary\n    if(acc >= float(iterations))\n        return 0.;\n    \n    //no idea how this works yet\n    //https://iquilezles.org/articles/msetsmooth\n    return acc - log2(log2(dot(z, z))) + 4.;\n}\n\n//remaps smoothed iteration value to output colour\nvec4 map_colour(float d) \n{\n    return vec4(0.5 + 0.5*cos(3.0 + d*0.15 + vec3(0.0,0.6,1.0)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n      \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        //add additional subpixel samples for AA pass\n        vec2 uv = (2.0 * ((fragCoord.xy + vec2(float(m),float(n))/float(AA))) -  iResolution.xy)/iResolution.y;\n        vec4 transform = get_transform(uv);\n#else    \n        vec2 uv = (2.0 * fragCoord.xy -  iResolution.xy)/iResolution.y;\n        vec4 transform = get_transform(uv);\n#endif\n\n        //apply transformations\n        //scale\n        uv.xy *= transform.w;\n\n        //rotate\n        uv.xy *= rotation(transform.z);\n\n        //translate\n        uv.x += transform.x;\n        uv.y += transform.y;\n\n        //evaluate\n        float d = mandlebrot(uv);\n        col += map_colour(d);\n        \n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n    //output\n    fragColor = col;\n}\n\n\n\n//-----------------------------------------//\n//old code, since this thing has no history\n//-----------------------------------------//\n        \n//https://en.wikipedia.org/wiki/Mandelbrot_set#Basic_properties\n//point is only in mandlebrot set if length of vector is <= 2\n//number of iterations implies point when orbit becomes unstable\n//i.e. how close (or far) it is to stability\n//if(length(z) > 2.)\n//\tbreak;\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int A_KEY = 65;\nconst int D_KEY = 68;\nconst int W_KEY = 87;\nconst int S_KEY = 83;\nconst int Q_KEY = 81;\nconst int E_KEY = 69;\nconst int UP_KEY = 38;\nconst int DOWN_KEY = 40;\nconst int PLUS_KEY = 187;\nconst int MINUS_KEY = 189;\n  \n//read raw data from keyboard texture\nbool is_key_down(in int keycode)\n{\n    return texelFetch(iChannel1, ivec2(keycode, 0), 0).x > 0.;\n}\n\n//read normalised data from buffer a texture\nvec4 get_transform(vec2 uv) \n{\n    return texture(iChannel0, uv).xyzw;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{  \n    //initialise or get buffered values \n\tvec4 transform;\n    transform = get_transform(fragCoord);\n    \n    if(transform.w == 0.0)\n        transform = vec4(0.,0.,0.,1.);\n        \n    \n    //rotate\n    if(is_key_down(Q_KEY)) transform.z += 0.01;\n    if(is_key_down(E_KEY)) transform.z -= 0.01;\n    \n    //adjust translation inputs based on current rotation, such that movement\n    //is as expected w.r.t. the screen\n    mat2 rotation = rotation(transform.z);\n    vec2 x_axis = vec2(0.01 * transform.w, 0.);\n    vec2 y_axis = vec2(0., 0.01 * transform.w);\n    \n    //translate\n    if(is_key_down(D_KEY)) transform.xy += x_axis * rotation;\n    if(is_key_down(A_KEY)) transform.xy -= x_axis * rotation;\n    if(is_key_down(W_KEY)) transform.xy += y_axis * rotation;\n    if(is_key_down(S_KEY)) transform.xy -= y_axis * rotation;\n    \n    //scale\n    if(is_key_down(PLUS_KEY)) transform.w *= 0.99;\n    if(is_key_down(MINUS_KEY)) transform.w *= 1.01;\n    \n    //update transformation parameters in the output buffer per fragment coordinate\n    //essentially creates an entire image with the same data...\n    fragColor = transform;\n}\n","name":"Buffer @","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//2d rotation matrix\nmat2 rotation(float angle) \n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, s,\n        \t   -s, c);\n}\n","name":"Common","description":"","type":"common"}]}