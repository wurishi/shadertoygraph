{"ver":"0.1","info":{"id":"sssSWn","date":"1618688700","viewed":61,"name":"Petrova, 325, v. 4,5","username":"Anastasia_Petrova","description":"Петрова Анастасия, 325","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv)/float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(0, 1.2, -6);\n\nconst vec3 LIGHT1_POS =vec3(-0.2, 2.15, -0.6);\nconst float LIGHT1_RADIUS = 0.5;\nconst vec3 LIGHT1_COLOR = vec3(5, 5, 8);\n\nconst vec3 LIGHT2_POS = vec3(1.5, 2.4, -3);\nconst float LIGHT2_RADIUS = 0.2;\nconst vec3 LIGHT2_COLOR = vec3(4.3, 1, 1.0);\nvec3 randDir;\nfloat PI = acos(0.0);\n\nstruct Minecraft\n{\n    bool  flag;\n    vec3  a;\n    vec3  b;\n    vec3  n;\n    float d;\n};\n\nstruct Triangle {\n  vec3 t1, t2, t3;\n};\nvec3[20] list = vec3[20](\n  vec3(0.357, -0.9346380972862244, 0),\n  vec3(0.5776381398439407, -0.5776381398439407,0.5776381398439407),\n  vec3(-0.357, -0.9346380972862244, 0),\n  vec3(0, -0.357, 0.9346380972862244),\n  vec3(-0.5776381398439407, -0.5776381398439407, 0.5776381398439407),\n  vec3(-0.5776381398439407, -0.5776381398439407, -0.5776381398439407),\n  vec3(0, -0.357, -0.9346380972862244),\n  vec3(0.5776381398439407, -0.5776381398439407, -0.5776381398439407),\n  vec3(0.9346380972862244, 0, -0.357),\n  vec3(0.9346380972862244, 0, 0.357),\n  vec3(0, 0.357, -0.9346380972862244),\n  vec3(0.5776381398439407, 0.5776381398439407, -0.5776381398439407),\n  vec3(0, 0.357, 0.9346380972862244),\n  vec3(0.5776381398439407, 0.5776381398439407, 0.5776381398439407),\n  vec3(-0.357, 0.9346380972862244, 0),\n  vec3(0.357, 0.9346380972862244, 0),\n  vec3(-0.5776381398439407, 0.5776381398439407, -0.5776381398439407),\n  vec3(-0.9346380972862244, 0, -0.357),\n  vec3(-0.9346380972862244, 0, 0.357),\n  vec3(-0.5776381398439407, 0.5776381398439407, 0.5776381398439407)\n);\n\nint[108] triangle = int[](\n  1, 2, 3, 2, 4, 3, 1, 3, 7, 8, 9, 1, 9, 10, 1, 15, 16, 12, 12, 11, 15,\n  11, 17, 15,10, 2, 1,9, 8, 7, 7, 11, 9, 11, 12, 9,16, 15, 13, 15, 20, 13,\n  13, 4, 2, 4, 5, 3, 2, 10, 13, 10, 14, 13, 6, 3, 19, 12, 16, 10, 12, 10, 9, 16, 14, 10,\n  3, 6, 7, 7, 8, 1,18, 19, 15, 18, 15, 17, 19, 20, 15, 11, 7, 6, 6, 18, 11,18, 17, 11,\n  3, 5, 19, 19, 18, 6, 13, 14, 16, 19, 5, 4, 4, 13, 19,13, 20, 19\n);\n\n\nfloat noise(vec3 p)\n{\n    vec3 size = 1.0 / vec3(textureSize(iChannel3, 0));\n    return (textureLod(iChannel3,(p * size * 1.0 + vec3(0.51, 0.77, 0.49)), 0.0).x * 0.5 +\n            textureLod(iChannel3,p * size * 2.0 + vec3(0.34, 0.30, 0.76), 0.0).x * 0.25 +\n            textureLod(iChannel3, p * size * 4.0 + vec3(0.71, 0.26, 0.92),0.0).x  * 0.125)* 1.14;\n}\n\n\nMinecraft getGrass(vec3 pos1, vec3 dir)\n{\n   \n    float d = 200.;\n    Minecraft m;\n    m.n = -dir;\n    m.d = 200.;\n    vec3 pos = pos1;\n    vec3 j = 1.0 / dir;\n    vec3 li = max(-sign(dir), 0.0);\n    vec3 u = floor(pos1) - li * vec3(equal(floor(pos1), pos1));\n\n    for (int k = 0; k < 200; k++) {\n        if (d <= 0.0 || (pos1.y > 3. && dir.y > 0.0)) {\n        \tbreak;\n        }\n        if (noise(u * 0.07) + u.y * -0.019 > 0.8) {\n\t\t\tm.a = u; m.b = pos; m.d = d; m.flag = true;\n\t\t\treturn m;\n        }\n\n        vec3 n = mix(floor(pos + 1.0), ceil(pos - 1.0), li);\n\t\tvec3 t = (n - pos) * j;\n\t\tfloat di = min(t.x, min(t.y, t.z));\n\t\tvec3 a = vec3(equal(vec3(di), t));\n        u += sign(dir) * a;\n        m.n = -sign(dir) * a;\n        pos = mix(pos + dir * di, n, a);\n        d -= di;\n    }\n\n    return m;\n}\n\nvec3 takeGrass(Minecraft m, vec3 orig, vec3 dir)\n{\n    vec3 grass = vec3(0.53, 0.84, 0.25);\n    vec3 dirt = vec3(0.80, 0.58, 0.39);\n    float Mix = 0.0;\n    vec3 u = m.a + vec3(0, 2, 0);\n    if(!(noise(u * 0.07) + u.y * -0.019 > 0.8)){\n       \n        Mix = max(0.0, m.n.y);\n        if (textureLod(iChannel3, m.b * 0.5, 0.0).r * 4.0 + floor(fract(m.b.y) * 16.0) > 15.0) {\n            Mix = 1.0;\n        }\n    }\n    \n    vec3 t = vec3(textureLod(iChannel3, m.b * 0.5, 0.0).r) * 0.3 + 0.75;\n    vec3 grassColor = t * mix(dirt, grass, Mix);\n    return grassColor;\n}\n\nvec3 render1(vec3 pos, vec3 dir)\n{\n    Minecraft r = getGrass(pos, dir);\n    if (r.flag) {\n        return takeGrass(r, pos, dir);\n    }\n    return vec3(0.35, 0.35, 0.80);\n}\n\n\nfloat Alpha(vec2 fragCoord, vec2 o, float r)\n{\n    vec2 d = fragCoord - o;\n    float n = length(d) / r;\n    float res =  0.85 - n;\n    if (res < 0.0) return 0.0;\n    return res;\n}\n\n\n///////////////////\n\n\nbool newP(vec3 curPos, vec3 curDir, Triangle tr, out float t, out vec3 pos, out vec3 normal) \n{\n  mat3 m1, m2;\n  m1[0] = curPos - tr.t1;\n  m1[1] = tr.t2 - tr.t1;\n  m1[2] = tr.t3 - tr.t1;\n  m2[0] = curDir;\n  m2[1] = tr.t2 - tr.t1;\n  m2[2] = tr.t3 - tr.t1;\n\n  float T = determinant(m2);\n  if (abs(T) < 0.0)\n      return true;\n      \n  t = -determinant(m1)/T;\n\n  pos = curDir * t + curPos;\n\n  if (t < 1e-5)\n    return false;\n  \n  vec3 u1 = cross(pos - tr.t1, tr.t2 - tr.t1);\n  vec3 u2 = cross(pos - tr.t2, tr.t3 - tr.t2);\n  vec3 u3 = cross(pos - tr.t3, tr.t1 - tr.t3);\n\n  if (dot(u2, u1) < 0.0 || dot(u2, u3) < 0.0)\n    return false;\n  normal = normalize(cross(tr.t2 - tr.t1, tr.t3 - tr.t1));\n  return true;\n}\n\nfloat traceDodecahedron(vec3 s, vec3 u, out vec3 normal) \n{\n  float a = 1e9;\n  float b = INF;\n  vec3 p;\n  for (int i = 0; i < 36; ++i) \n  {\n    vec3 t1 = list[triangle[i * 3 + 0] - 1];\n    vec3 t2 = list[triangle[i * 3 + 1] - 1];\n    vec3 t3 = list[triangle[i * 3 + 2] - 1];\n    Triangle t = Triangle(t1, t2, t3);\n    vec3 p1, normal1;\n    float a1;\n    if (newP(s, u, t, a1, p1, normal1) && a1 < a) \n    {\n      a = a1;\n      p = p1;\n      normal = normal1;\n      b = a;\n    }\n  }\n\n  if (dot(p, normal) < 0.0)\n    normal = -normal; \n  return b;\n}\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphNorm;\n    float sphT = traceSphere(pos, dir, 1.0, sphNorm);\n    if (sphT < dist)\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 4.0f / distSq1;\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 10.0f / distSq2;\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\nvec3 getColour(vec3 curPos,vec3 curDir,float l){\n        float t = INF;\n        vec3 color;    \n        vec3 normal;        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            color = computeLight(worldPos, color, planeNorm);\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n           \n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n          \n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            \n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n            color = computeLight(worldPos, color, planeNorm);\n        }\n   \n    if(t==INF){\n        color=texture(iChannel1, curDir).rgb;\n        l=pow(0.93,50.);\n    }\n    else{\n        l = pow(0.93, distance(curPos, t*curDir+curPos));\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    const int POL=4;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    const float DIAMOND_N = 2.5;\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    vec3 res,res1=vec3(0,0,0);\n    vec3 colorMult = vec3(1, 1, 1);\n    float R=0.;\n    bool refl=false;\n    bool maincraft=false;\n    float l=0.;\n    float alpha;\n    //float col;\n    vec4 col = vec4(0);\n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        vec3 sphNorm;\n        float sphT = traceDodecahedron(curPos,curDir , sphNorm);\n        if (sphT < t) {\n            t = sphT;\n            normal = sphNorm;\n            \n                materialType =REFRACTION;\n            \n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n           \n        }\n       \n        if (!maincraft && refl) {\n            \n            float r = iResolution.x / 8.0*1.1;\n            vec2 o = vec2(iResolution.x * 0.5, iResolution.y * 0.5-1.8);\n\n            if (length(fragCoord - o) / r + noise(vec3(fragCoord, 0) * 0.5) < 1.5) {\n                t = 0.1;\n              \n                materialType = POL;\n                maincraft=true;\n                col = vec4(0.0);\n                \n                vec2 coord = ((fragCoord - o + r) / (2.0 * r))*iResolution.x;\n                col = vec4(render1(curPos,curDir),1.0);\n                \n                alpha = Alpha(fragCoord, o, r);\n               \n            }\n           \n            \n        }\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            \n            if (materialType == POL) {\n                res1=color;\n               \n            }\n            else\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                if(refl){\n                    if(maincraft){\n                        fragColor.rgb=mix(vec4(fragColor.rgb, 1.0), col, alpha).rgb;\n                    }\n                    fragColor.rgb = R *res  + (1.0 - R) *fragColor.rgb ;\n                    }\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                 if(maincraft){\n                        fragColor.rgb=mix(vec4(fragColor.rgb, 1.0), col, alpha).rgb;\n                    }\n                if(refl){\n                    fragColor.rgb =  R *res+ (1.0 - R) *fragColor.rgb *l;}\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                if(nEnter==GLASS_N && !refl){\n                    refl=true;\n                    float reflC=GLASS_N;\n                    float R0 = ((1.0 - reflC) / (1.0 + reflC));\n                    R0 *= R0;\n                    R = R0 + (1.0 - R0) * pow(1.0 + dot(curDir,normal), 5.0);\n                 \n                    res = getColour( worldPos+ reflect(curDir, normal)*0.00005,reflect(curDir, normal),l) ;\n                    \n                }\n                else{\n                    l=pow(0.92, distance(curPos, t*curDir+curPos));}\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n            if(maincraft){\n                        fragColor.rgb=mix(vec4(fragColor.rgb, 1.0), col, alpha).rgb;\n                    }\n            if(refl){\n                fragColor.rgb = R *res  + (1.0 - R) *fragColor.rgb*0.7;}\n        }\n        \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv)+ texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}