{"ver":"0.1","info":{"id":"7sVBR3","date":"1658616184","viewed":86,"name":"virality","username":"geoffroy","description":"shader based on John Conway's Game of life algorithm","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["gameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Conway's Game of Life\n// https://iquilezles.org/articles/gameoflife\n//\n// State based simulation. Buffer A contains the simulated world,\n// and it reads and writes to itself to perform the simulation.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    //ivec2 coord = ivec2(fragCoord*0.5);\n    //coord += ivec2(iResolution.xy*0.25);\n    \n    vec3 c = texelFetch( iChannel0, coord, 0 ).xyz;\n    c *= 0.082;\n    fragColor = vec4( c.y, c.z, c.z*0.5 , 1.0 );\n    //fragColor = vec4( c.y, 0.0, 0.0 , 1.0 );\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;   \n    float d = (1.0 + sin((8.0+iTime)*0.5)) * 0.5;\n    d *= 4.0;\n    d = min(0.4, d);\n    return (texelFetch(iChannel0, p, 0 ).x > 0.1 + d) ? 1 : 0;\n}\n\nfloat CellF( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).x;\n}\n\nfloat CellF2( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).y;\n}\n\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    vec2 uv = fragCoord/iResolution.xy;  \n    uv -= 0.5;\n    uv *= 2.0;\n   \n\n\tint k =   Cell(px+ivec2(-1,-1)) + Cell(px+ivec2(0,-1)) + Cell(px+ivec2(1,-1))\n            + Cell(px+ivec2(-1, 0))                        + Cell(px+ivec2(1, 0))\n            + Cell(px+ivec2(-1, 1)) + Cell(px+ivec2(0, 1)) + Cell(px+ivec2(1, 1));\n            \n    float col =                                      CellF(px+ivec2(0,-2))\n                          + CellF(px+ivec2(-1,-1)) + CellF(px+ivec2(0,-1)) + CellF(px+ivec2(1,-1))\n+ CellF(px+ivec2(-2, 0))  + CellF(px+ivec2(-1, 0))                         + CellF(px+ivec2(1, 0)) + CellF(px+ivec2(2, 0))  \n                          + CellF(px+ivec2(-1, 1)) + CellF(px+ivec2(0, 1)) + CellF(px+ivec2(1, 1))\n                                                   + CellF(px+ivec2(0,2));\n                \n    col += CellF2(px);\n   // col += 0.01;\n             \n    col *= 0.8;\n    \n    float d = (1.0 + sin((8.0+iTime)*0.5)) * 0.5;\n    \n    d = 1.0 - d;\n    \n    float c2 = pow(col, (3.2 * d));\n    \n    c2 *= 0.001;\n\n    int e = Cell(px);\n\n    float o1 = CellF(px);\n    o1 += 0.001;\n    float o2 = ( ((k==2)&&(e==1)) || (k==3) ) ? 1.0 : 0.0;\n    \n    float f;\n    \n    f = mix(o1, o2, 0.5);    \n    \n    \n    if( iFrame==0 ) f = step(0.8, (1.0 - length(uv))) * step(0.95, hash1(fragCoord.x*16.0+hash1(fragCoord.y*71.1)));\n\t\n\tfragColor = vec4( f, col, c2, 0.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}