{"ver":"0.1","info":{"id":"MdXcWN","date":"1488230379","viewed":88,"name":"Rays","username":"t91","description":"ray marching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3  v_cam_pos = vec3(0.0, 1.0, -6.0);\nvec3  v_cam_forward = vec3(0.0, 0.0, 1.0);\nvec3  v_cam_right = vec3(1.0, 0.0, 0.0);\nvec3  v_cam_up = vec3(0.0, 1.0, 0.0);\nvec3  v_sundir = normalize(vec3(0.0, 0.7, 1.0));\nfloat f_near = 2.3;\n\n#define FLOOR 999\n#define INFINITY 99999.0\n\nvec3 ToRay(in vec2 fragCoord, in mat3 m)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 invResolution = 1.0 / iResolution.xy;\n\tvec2 ndc = (fragCoord.xy * invResolution) * 2.0 - 1.0; \n\tvec3 ray = vec3(aspect * ndc.x, ndc.y, f_near);\n    \n\treturn m * normalize(ray);\n}\n\nvec3 IdToColor(int id)\n{\n\tif (id == FLOOR)\n        return vec3(3.4, 3.4, 5.0);\n    \n    float f = float(id);\n    \n    float sf = sin(f * 2.0) * 0.5 + 0.5;\n    float cf = cos(f * 3.0) * 0.5 + 0.5;\n    \n    return vec3(sf, cf, fract(sf+cf + 0.5)) * 2.0;\n}\n\nfloat Scene(vec3 point, out int id)\n{\n    vec3 offset = vec3(0.0, 3.4, 0.0);\n    float distance = INFINITY;\n\n    id = -1;\n    \n    #define ITER 6  \n    for (int i = 0; i < ITER*ITER; ++i)\n    {\n        int h = ITER / 2;\n        int a = i / ITER;\n        int b = i % ITER;\n        \n        vec3 position = vec3(float(a - h), 0.0, float(b - h)) * 5.0;\n        float radius = 0.9 + sin(float(a) + float(b)) * 0.5 + 0.5;\n        \n        position.y = 4.0; \n        \n        \n        float l2c = length(point - position) - radius;\n        l2c = max(0.0, l2c);\n        \n        if (l2c < distance)\n        {\n        \tdistance = l2c;\n            id = i;\n        }\n    }\n\n    float t = iTime;\n    float H = sin(length(point.xz) - iTime * 2.0) * 0.3;\n    \n    float h = point.y - H;\n    \n    if (h < distance)\n    {\n        id = FLOOR;\n    \tdistance = h;\n    }\n    \n\n\treturn distance;\n}\n\nvec4 March(vec3 start, vec3 ray, out int id)\n{   \n    float step = 0.0;\n    \n\tfor (int i = 0; i < 100; ++i)\n    {\n        start = start + (step * ray);\n        step = Scene( start, id );\n\n        if (step < 0.0005)\n        {\n            return vec4(start, float(i));\n        }  \n        \n        if (step > 30.0)\n        {\n        \tbreak;\n        }\n\n    }\n    \n    return vec4(0,0,0,-1);\n}\n\n\nfloat ShadowSample(vec3 pos)\n{\n    int id = -1;\n    float shadow = 1.0;\n    vec4 shadow_pos = March(pos + v_sundir * 80.0, -v_sundir, id);\n\n    if (shadow_pos.w < 0.0)\n        return 1.0;\n    \n    float distToShadowCaster = length(shadow_pos.xyz - pos.xyz);\n    \n    shadow = min(1.0, max(0.0, 1.0 - distToShadowCaster));\n    \n    \n    return shadow;\n}\n\nfloat Shadow(vec3 pos)\n{\n    return ShadowSample(pos);\n}\n\nvec3 Ambient()\n{\n\treturn vec3(1.0, 1.0, 1.0) * 0.3;\n}\n\nvec3 Diffuse(vec3 nrm)\n{\n\treturn dot(nrm, v_sundir) * vec3(0.9, 0.2, 0.2) * 6.0;\n}\n\nvec3 Opq(vec3 pos, int id)\n{\n    vec2 uv = pos.xz;\n    uv.x += fract(pos.y);\n    uv.y += fract(pos.y);\n    \n    uv = fract(uv);\n    uv *= 0.2;\n\n    vec3 color = vec3(1,1,1);\n    \n    if (id == FLOOR)\n    {\n        uv *= 0.04;\n    \tcolor = texture(iChannel0, uv).xyz;\n    }\n    \n    color *= IdToColor(id);\n    \n\treturn color;\n}\n\nvec3 Reflection(vec3 ray, vec4 pos, vec3 nrm, int surface_id)\n{  \n    vec3 reflected = reflect(ray, nrm);\n    \n    int id = -1;\n    vec4 hit = March(pos.xyz + nrm*0.01, reflected, id);\n    \n    if (hit.w < 0.0)\n\t\treturn vec3(0, 0, 0);\n    \n    \n    return Opq(hit.xyz, id);\n}\n\nvec3 Fog(vec4 pos)\n{\n    if (pos.w < 0.0)\n        return vec3(0.0, 0.0, 0.0);\n    \n    float distance = length(pos.xyz - v_cam_pos);\n\n\treturn max(0.0, exp(-distance * 0.04 )) * vec3(1.0, 1.0, 1.0);\n}\n\nvec3 Specular(vec3 pos, vec3 nrm)\n{\n    vec3 VertexToEye = normalize(v_cam_pos - pos);\n    vec3 LightReflect  = normalize(reflect(-v_sundir, nrm));\n    \n    float str = max(0.0, dot(VertexToEye, LightReflect));\n    \n\tvec3 spc = pow(str, 30.0) * vec3(1.0, 1.0, 1.0);\n    \n    return spc;\n}\n\nfloat AmbientOcclusion(vec4 pos)\n{\n\treturn (1.0-clamp(pow(pos.w / 100.0, 0.2), 0.0, 1.0));\n}\n\nmat3 CameraMatrix()\n{\n\tfloat radius = 30.0;\n    float param = iMouse.x * 0.03;//obalTime * 0.3;\n    \n    v_cam_pos.x = sin(param) * radius;\n    v_cam_pos.y = 1.0 + iMouse.y * 0.01;\n    v_cam_pos.z = cos(param) * radius;\n    \n    v_cam_forward = -normalize(v_cam_pos);\n    v_cam_forward.y = 0.0;\n    v_cam_forward = normalize(v_cam_forward);\n    \n    v_cam_forward = -normalize(v_cam_pos);\n    \n    v_cam_right   = cross(v_cam_forward, v_cam_up);\n \n    mat3 m;\n    m[0] = v_cam_right;\n    m[1] = v_cam_up;\n    m[2] = v_cam_forward;\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmat3 cam = CameraMatrix();\n\n    int id = -1;\n    \n    vec3 ray   = ToRay(fragCoord, cam);\n    vec4 pos   = March(v_cam_pos, ray, id);\n    \n    \n    \n    int id_alt = -1;\n    vec3 ray_A = ToRay(fragCoord + vec2(0.2, 0.0), cam);\n    vec3 ray_B = ToRay(fragCoord + vec2(0.0, 0.2), cam);\n    vec3 pos_A = March(v_cam_pos, ray_A, id_alt).xyz;\n    vec3 pos_B = March(v_cam_pos, ray_B, id_alt).xyz;\n    vec3 diff1 = normalize(pos.xyz - pos_A);\n    vec3 diff2 = normalize(pos.xyz - pos_B);\n    vec3 nrm = normalize(cross(diff1, diff2));\n\n    vec3  opq = Opq(pos.xyz, id);\n    vec3  rfl = Reflection(ray, pos, nrm, id);\n    vec3  spc = Specular(pos.xyz, nrm);\n    vec3  amb = Ambient();\n    vec3  dif = Diffuse(nrm);\n    vec3  fog = Fog(pos);\n    float shd = Shadow(pos.xyz);\n    \n    vec3 color;\n\n    color = (amb + dif * shd + (spc + rfl)) * opq;\n\n    color *= AmbientOcclusion(pos);\n    fragColor.xyz = color * fog;\n\n    \n    fragColor.w = 1.0;  \n    \n}","name":"Image","description":"","type":"image"}]}