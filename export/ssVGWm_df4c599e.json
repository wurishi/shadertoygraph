{"ver":"0.1","info":{"id":"ssVGWm","date":"1631687962","viewed":139,"name":"Hypnotic flower","username":"xlat","description":"Very simple.","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["fragmentshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MtlSDj","filepath":"https://soundcloud.com/russian-mafia-deep/grivina-mickey-riot-chocolate-boom","previewfilepath":"https://soundcloud.com/russian-mafia-deep/grivina-mickey-riot-chocolate-boom","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///----------------------------------------------------------------------------|\n/// XLAT\n/// www.cyberforum.ru\n///----------------------------------------------------------------------------:\n/// (... written on the knee, no optimizations or obfuscations ...)\n///----------------------------------------------------------------------------:\n\n///------------------------|\n/// Config.                |\n///------------------------:\nconst float RADIUSS  =  0.7;\nconst float NSEC     = 18.0;\n      float SPEED    =  0.3;\n///------------------------.\n\nconst vec4  WHITE    = vec4(0.9, 0.9, 0.9, 1.);\nconst vec4  BLUE     = vec4(0.0, 0.0, 0.6, 1.);\nconst vec4  RED      = vec4(0.6, 0. , 0. , 1.);\nconst vec4  BGROUND  = vec4(0.0, 0.0, 0.2, 1.);\nconst vec4  YELLOW   = vec4(0.0, 0.0, 0.0, 1.);\n\nconst float PIx2     = 6.2831853;\n\n/// not use\n////////////////////////////////////////////////////////////////////////////////\nhighp float rand_(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n\n    return fract(sin(sn) * c);\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m )\n{\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat rand( float x ) { return floatConstruct(hash(floatBitsToUint(x+iTime))); }\nfloat rand( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v+iTime))); }\nfloat rand( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v+iTime))); }\nfloat rand( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v+iTime))); }\n\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 tonsin(float minn, float maxx, float a)\n{   a = a - minn;\n    float x = 1.57 / (maxx - minn);\n    float c  = 0.3  * cos(a * x);\n    return vec4(c, c, c, 0.9);\n}\n\nfloat distance_x2(vec2 p1, vec2 p2)\n{   vec2   dp = p1 - p2;\n    return dp.x * dp.x + dp.y * dp.y;\n}\n\nbool isCircle(vec2 p, float radius)\n{   float d = distance_x2(p, vec2(0., 0.));\n    float r = radius * radius;\n    if( d < r && d > r * 0.8 ) return true ;\n                               return false;\n}\n\n#define step_t vec2\n\nfloat Speed ;\nfloat Speed1;\nfloat Speed2;\nfloat RADIUS;\n\n#define SIN  sin(Speed)\n#define SIN1 sin(Speed1)\n#define SIN2 sin(Speed2)\n#define COS  cos(Speed) \n#define COS1 cos(Speed1)\n#define COS2 cos(Speed2)\n\n#define STEP(amplitude_x, speed_x, amplitude_y, speed_y) step_t( \\\n                              -abs(amplitude_x * sin(speed_x)),  \\\n                                   amplitude_y * sin(speed_y))\n\n#define NO if(false)\n\nvec4 colorArrayCircles(vec2 pos, bool odd)\n{   \n\n//NO\n    if(isCircle(pos + step_t(-abs(0.2 * sin(Speed     )), 0.01), 0.05 * SIN + 0.1)) \n        return vec4(0.5*COS + 0.5, 0.5*SIN+0.5, 0.2*SIN+0.2, 1.0);\n        \n//NO    \n    if(isCircle(pos + STEP(0.3, Speed, 0.1, Speed + 1.), 0.1 * SIN2 + 0.3)) \n        return vec4(0.5*SIN+0.5, 0.5*COS + 0.5, 0.2*SIN+0.2, 1.0);\n        \n//NO    \n    if(isCircle(pos + STEP(0.4, Speed+1., 0.2, Speed+1.), 0.15 * SIN1 + 0.3)) \n        return vec4(0.5*SIN2+0.5, 0.2*SIN2+0.2, 0.5*COS2 + 0.5, 1.0);\n        \n//NO    \n    if(isCircle(pos + step_t(-abs(0.4 * sin(Speed1 + 2.)),\n                                  0.05 * sin(Speed + 1.)), 0.06)) \n        return vec4(0.2*SIN1+0.2, 0.5*SIN1+0.5, 0.5*COS1 + 0.5, 1.0);\n        \n//NO    \n    if(isCircle(pos + step_t(-abs(-0.2  * sin(Speed2 + 2.)),\n                                   0.2  * sin(Speed2 + 1.)), 0.2)) \n        return vec4(0.2*SIN2+0.8, 0.0, 0.2*COS2+0.2, 1.);\n        \n    return vec4(-1.0);\n}\n\nvec4 colorArrayCircles2(vec2 pos, bool odd)\n{\n//NO    \n    if(isCircle(pos + step_t(-abs(-0.2  * sin(Speed2 + 2.)),\n                                   0.2  * sin(Speed2 + 1.)), 0.2)) \n        return vec4(0.2*SIN2+0.8, 0.0, 0.2*COS2+0.2, 1.);\n\n//NO    \n    if(isCircle(pos + step_t(-abs(0.4 * sin(Speed1 + 2.)),\n                                  0.05 * sin(Speed + 1.)), 0.06)) \n        return vec4(0.2*SIN1+0.2, 0.5*SIN1+0.5, 0.5*COS1 + 0.5, 1.0);\n   \n//NO    \n    if(isCircle(pos + STEP(0.4, Speed+1., 0.2, Speed+1.), 0.15 * SIN1 + 0.3)) \n        return vec4(0.5*SIN2+0.5, 0.2*SIN2+0.2, 0.5*COS2 + 0.5, 1.0);\n\n//NO    \n    if(isCircle(pos + STEP(0.3, Speed, 0.1, Speed + 1.), 0.1 * SIN2 + 0.3)) \n        return vec4(0.5*SIN+0.5, 0.5*COS + 0.5, 0.2*SIN+0.2, 1.0);\n        \n//NO\n    if(isCircle(pos + step_t(-abs(0.2 * sin(Speed     )), 0.01), 0.05 * SIN + 0.1)) \n        return vec4(0.5*COS + 0.5, 0.5*SIN+0.5, 0.2*SIN+0.2, 1.0);\n                 \n    return vec4(-1.0);\n}\n\nvec2 rot(vec2 p, float a)\n{   return vec2( p.x * cos(a) - p.y * sin(a),\n                 p.x * sin(a) + p.y * cos(a) );\n}\n\nfloat getAngle(vec2 pos)\n{   vec2 p = normalize(pos);\n    \n    if(p.y > 0.0) return        acos(p.x);\n    else          return PIx2 - acos(p.x);\n}\n\nvec4 colorBorder(vec2 pos)\n{   if(pos.y < 0.05) return tonsin(0., 0.05, pos.y);\n    if(pos.y > 0.95) return tonsin(0.95, 1., pos.y);\n    if(pos.x < 0.05) return tonsin(0., 0.05, pos.x);\n    if(pos.x > 0.95) return tonsin(0.95, 1., pos.x);\n    return vec4(0.);\n}\n\nvec4 colorSectors(vec2 pos)\n{\n    pos = rot(pos - 0.5, Speed);\n\n    if(RADIUS * RADIUS < pos.x * pos.x + pos.y * pos.y) return BGROUND;\n\n    float asector = PIx2 / NSEC  ;\n    float a       = getAngle(pos);\n\n    for(float i = asector, j = 0.; i < PIx2; i += asector, j += 1.)\n    {\n        if(a < i)\n        {   \n            if(mod(j, 2.) == 0.)\n            {\n                vec4 color = colorArrayCircles(rot(pos, -i), false);\n                if(color.a > 0.)\n                {   return color + vec4( 0., 0., fract(a)/3., 0.);\n                }\n            }\n            else\n            {   float t =  i - asector - a - a;\n                vec4 color = colorArrayCircles2(rot(pos, t), true );\n                if(color.a > 0.)\n                {   return color + vec4( fract(t)/3., fract(t)/3., fract(t)/3., 0.);\n                }\n            }\n\n            return vec4(0.3*sin(i)+0.4, 0.0, 0.0, 1.0);\n        }\n    }\n\n    return RED;\n}\n\n///----------------------------------------------------------------------------|\n/// Run.\n///----------------------------------------------------------------------------:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   float xx = iChannelResolution[0].x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float a = ((SPEED+.6)*sin(iTime/ 5.) - 1.6) / iTime;\n    \n    Speed    = iTime * (SPEED+a)      ;\n    Speed1   = iTime * (SPEED+a) * 1.2;\n    Speed2   = iTime * (SPEED+a) * 1.5;\n    \n    RADIUS   = iTime / 5.; if(RADIUS > RADIUSS) RADIUS = RADIUSS;\n\n    vec4 b = colorBorder(uv);\n    if(  b.a > 0.) fragColor = vec4(mix( colorSectors(uv).xyz, b.xyz, 0.8), 1.);\n    else           fragColor = colorSectors(uv);\n}\n","name":"Image","description":"","type":"image"}]}