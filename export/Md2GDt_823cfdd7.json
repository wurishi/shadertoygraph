{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// to-shadertoy preamble\n#define time (iTime)\n#define t (iTime)\n#define resolution (iResolution.xy)\n/*float time=iTime;vec2 resolution=iResolution.xy;*/float N(vec2 v){return fract(sin(dot\n\n//orig: uniform float time;uniform vec2 resolution;float N(vec2 v){return fract(sin(dot\n(vec2(7.,23.),v))*519.);}vec2 e=vec2(1.,0.),s,f,F;float M(vec2 v){F=floor(v);f=\nfract(v);f*=f*(3.-2.*f);return mix(mix(N(F),N(F+e.xy),f.x),mix(N(F+e.yx),N(F+e.\nxx),f.x),f.y);}float B(vec2 v){return M(v)+.5*M(v*2.)+.2*M(v*8.);}\nfloat l=0.,r;void mainImage( out vec4 fragColor, in vec2 fragCoord ){for(int i=0;i<99;++i){vec3 q=vec3(fragCoord.xy/resolution\n-.5,1.)*l;q.z-=2.;q.x*=1.8;r=length(q)-1.;s=42.*(q.xy+M(vec2(r-t*.5))-M(vec2(r-\nt*.3))*e.xy);l+=.4*(r+.2*B(s));}fragColor=1.-vec4(B(s),B(s+.1),B(s+.3),1.);}\n\n// I DEMAND AN EXPLANATION\n//\n// TL;DR: not much, just some common techinques squeezed together.\n//\n// let's break down the lines a bit:\n//\n// line 1:\n// obvious and uninteresting uniform declarations\n// \tuniform float time;uniform vec2 resolution;\n//\n// lines 1-2:\n// hash noise function R^2 -> R\n// \tfloat N(vec2 v) { \n//\t\treturn fract(sin(\n//\n// get from vec2 to float\n//\t\t\tdot(vec2(7.,23.),v)\n//\t\t)*519.);\n//\t}\n//\n// line 2:\n// declare all vec2 vars in one place so there as little declaration overhead as possible\n// \tvec2 e=vec2(1.,0.),s,f,F;\n// \n// lines 2-4:\n// C2-smooth value noise from hash noise.\n// simply a bilinear interpolation of 4 adjacent hashes\n// \tfloat M(vec2 v){\n//\n// cell params\n// F = bottom-left vertex coordinates\n// f = sampling point coords relative to F\n// \t\tF=floor(v);\n//\t\tf=fract(v);\n//\n// guarantee smoothness:\n//\t\tf*=f*(3.-2.*f);\n//\n// interpolate bilinearly\n//\t\treturn mix(\n//\t\t\tmix(N(F),N(F+e.xy),f.x),\n//\t\t\tmix(N(F+e.yx),N(F+e.xx),f.x),\n//\t\t\tf.y);\n//\t}\n//\n// line 4:\n// fractal value noise sum with 3 octaves\n//\tfloat B(vec2 v){\n//\t\treturn\n//\t\t\tM(v)\n//\t\t\t+.5*M(v*2.)\n//\t\t\t+.2*M(v*8.);\n//\t}\n//\n// lines 4-5:\n// as before with vec2 declare all float variables in one place\n// float t=time,l=0.,r;\n// l is raymarched distance\n//\n// lines 5-7: void main\n// simple sdf raymarching\n// \tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n//\n// for max 99 ray samples\n//\t\tfor(int i=0;i<99;++i){\n//\n// calculate ray sample position from screen pixel coords and marched distance l\n//\t\t\tvec3 q=vec3(fragCoord.xy/resolution-.5,1.)*l;\n//\n// begin ray at (0., 0., -2.)\n//\t\t\tq.z-=2.;\n//\n// fix aspect at ~16:9\n//\t\t\tq.x*=1.8;\n//\n// get distance to sphere center\n// \t\t\tr=length(q)-1.;\n//\n// calculate displacement map coordinates\n// \t\t\ts=42.*(\n//\n// begin with current xy screen coordinates\n//\t\t\t\tq.xy\n//\n// add random \"bottom-left to top-right\" rotation\n// note that we have only a vec2 noise function so we need to wrap arguments in vec2.\n// this is cheaper than having separate float N(float) by a few bytes.\n// subtracting time from radius gives the wavy fur look\n//\t\t\t\t+M(vec2(r-t*.5))\n//\n// add analogous random \"right to left\" rotation just to add one more visible degree of freedom\n//\t\t\t\t-M(vec2(r-t*.3))*e.xy);\n//\n// sample radius displacement as fractal noise and step along the ray accordingly\n//\t\t\tl+=.4*(r+.2*B(s));\n//\t\t}\n//\n// re-use displacement coordinates as a hash value for determining color\n//\t\tfragColor=1.-vec4(B(s),B(s+.1),B(s+.3),1.);\n//\t}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md2GDt","date":"1395476418","viewed":2798,"name":"[TDF2014] caress","username":"w23","description":"specially for 7x79 GLSL compo at Tokyo Demo Fest 2014","likes":44,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","fur"],"hasliked":0,"parentid":"","parentname":""}}