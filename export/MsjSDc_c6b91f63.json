{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float sat( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\nfloat truncate( float x, float l )\n{\n\treturn floor(x * l) / l;\n}\nfloat remap( float a, float b, float v ) {\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n\n// ====\n\nfloat hash11( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\nfloat noise31( vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\t//f = f*f*(3.0 - 2.0 * f); //smoothstep\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix( mix( hash11(n+  0.0), hash11(n+  1.0), f.x),\n\t\t\t\t\t\t mix( hash11(n+ 57.0), hash11(n+ 58.0), f.x), f.y),\n\t\t\t\t\t mix(mix( hash11(n+113.0), hash11(n+114.0), f.x),\n\t\t\t\t\t\t mix( hash11(n+170.0), hash11(n+171.0), f.x), f.y), f.z);\n\treturn res;\n}\n\n//note: normalized [0;1[\nfloat noise11( float x )\n{\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n\n    //note: smoothstep\n\t//f = f*f*(3.0 - 2.0 * f);\n\n\tfloat n = p;\n\n    float res = mix( hash11(n+  0.0), hash11(n+  1.0), f);\n        \n\treturn res;\n}\n\nfloat fbm11( float p )\n{\n\tfloat f;\n\tf  = 0.5000 * noise11( p ); p = p*2.02;\n\tf += 0.2500 * noise11( p ); p = p*2.03;\n\tf += 0.1250 * noise11( p ); p = p*2.01;\n\tf += 0.0625 * noise11( p );\n\treturn f;\n}\n\n// ====\n\nfloat flicker0( float t )\n{\n    const float FLICKER_RATE = 13.0;\n    const float FLICKER_PHASE = 13.583;\n    float ft0 = truncate( t + FLICKER_PHASE, FLICKER_RATE );\n    \n    //note: single sample\n    return hash11( ft0 );\n}\n\nfloat flicker1( float t )\n{\n    const float FLICKER_RATE = 13.0;\n    const float FLICKER_PHASE = 13.583;\n    float ft0 = truncate( t + FLICKER_PHASE, FLICKER_RATE );\n    \n    //note: single sample\n    //return hash11( ft0 );\n    \n    //note: multisample for 1 frame\n    const int NUM_SAMPLES = 32;\n    const float RCP_NUM_SAMPLES_F = 1.0 / float(NUM_SAMPLES);\n    const float diff_t = 1.0/60.0; //note: delta-time at 60Hz\n    const float filterwidth = 4.0 * diff_t;\n    float stepsiz = (filterwidth) * RCP_NUM_SAMPLES_F;\n    float sum = 0.0;\n    float st = t - 0.25*filterwidth; //TODO: rnd offset...\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        float ft = truncate( st + FLICKER_PHASE, FLICKER_RATE );\n        sum += hash11( ft );\n\n        //sum += fract( ft );\n        \n        st += stepsiz;\n    }\n    \n    return sum * RCP_NUM_SAMPLES_F;\n}\n\nfloat flicker2( float t )\n{\n    return 1.0 - 2.0*sat(noise11( 20.0 * t )-0.5);\n    \n    //return remap( 0.0, 0.125, hash11( t ) );\n}\n\nfloat flicker3( float t )\n{\n    //return fract( t );\n    \n    //t = trunc( t, 5.0 ); //note: change 5 times per second\n    //return remap( 0.0, 1.0, hash11( t ) );\n\n    return fbm11( t );\n    //return 1.0 - 4.0 * (fbm11(t);\n}\n\n// ====\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2( iResolution.x / iResolution.y, 1.0 );\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = vec2( fract( 3.0 * uv.x ), 3.0 * uv.y );\n    \n    vec2 ctr = vec2(0.5,0.5);\n\n    int idx = int( floor(3.0*uv.x) );\n    \n    float dist = 1.0 - length( (ctr -  p + vec2(0.0, 1.5) ) * aspect  );\n\n    float circle = remap( 0.6, 0.625, dist );\n    circle = smoothstep( 0.0, 1.0, circle );\n\n    float its = 0.0;\n    if ( idx == 0 )\n    \tits = flicker0( iTime );\n    else if ( idx == 1 )\n    \tits = flicker1( iTime );\n    else if ( idx == 2 )\n    \tits = flicker2( iTime );\n\n    its *= circle;\n\n    //TODO: show histogram of distribution\n        \n    const float ysiz = 0.25;\n\t//note: current is left\n    if ( uv.y < ysiz )\n    {\n        //note: quantize to 60Hz\n        const float hztime_s = 1.0;\n        p.x = iTime - fract( uv.x * 3.0 * hztime_s );\n        p.y = uv.y / (ysiz*0.9);\n        \n        float t = truncate( p.x, 60.0 * hztime_s );\n        float v = 0.0;\n\n        if ( uv.x < 1.0/3.0 )\n        {\n            v = flicker0( t );\n        }\n        else if ( uv.x < 2.0/3.0 )\n        {\n            v = flicker1( t );\n        }\n        else\n        {\n            v = flicker2( t );\n        }\n        its = step( p.y, v );\n        \n        if ( abs(fract(uv.x*3.0) - 0.49) > 0.5 )\n        {\n            fragColor = vec4(1.0);\n            return;\n        }\n    }\n    if ( abs( uv.y - ysiz ) < 1.0 / iResolution.y )\n    {\n        fragColor = vec4(1.0);\n\t\treturn;\n    }\n    \n\tfragColor = vec4( vec3(its), 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsjSDc","date":"1416834675","viewed":135,"name":"flicker","username":"hornet","description":"flickertests using a random hash, linearly blended noise, and multi-frequency noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["flicker"],"hasliked":0,"parentid":"","parentname":""}}