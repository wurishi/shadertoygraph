{"ver":"0.1","info":{"id":"tdsBD2","date":"1597245698","viewed":55,"name":"rayMarch_basis","username":"Dobios","description":"Quick attempt at raymarching a sphere","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.01\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define GLOW_SIZE 1.0f\n#define BACK_PLANE_Z 10.0f\n\nstruct Material {\n\tvec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n    \nstruct Object {\n    Material mat;\n    float dist;\n};\n    \nconst Material sphere_mat = Material(\n\tvec3(1.0, 0.0, 0.0),\n    vec3(0.5, 0.5, 0.0),\n    vec3(1.0, 1.0, 1.0),\n    0.5\n);\n\nconst Material plane_mat = Material(\n\tvec3(0.0, 0.0, 1.0),\n    vec3(0.0, 0.5, 0.5),\n    vec3(1.0, 1.0, 1.0),\n    0.0\n);\n\nconst Material back_plane_mat = Material(\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.5, 0.5, 0.5),\n    vec3(1.0, 1.0, 1.0),\n    0.0\n);\n\n/**\n * @brief Computes the distance from a given point to a given sphere\n * @param point, the point from which we want to compute our distance \n * @param sphere, (xyz: center, w: radius) of the sphere we want to draw\n * @return the distance from the given point to the given sphere\n */\nfloat sphereSDF(vec3 point, vec4 sphere) {\n\treturn length(point - sphere.xyz) - sphere.w;\n}\n\nfloat cirleSDF(vec3 point, vec4 sphere) {\n\treturn length(point.xy - sphere.xy) - sphere.w;\n}\n\nfloat backplaneSDF(vec3 point) {\n    return BACK_PLANE_Z - point.z;\n}\n\n//SDF of the entire scene\nObject getDist(vec3 point) {\n\t//Construct our sphere\n    vec4 sphere = vec4(0, 1, 6, 1);\n    float sphere_dist = sphereSDF(point, sphere);\n    \n    float back_dist = backplaneSDF(point);\n    \n    //Our scene is a sphere on a plane\n    float min_back = min(sphere_dist, back_dist);\n    float min_dist = min(point.y, min_back);\n    float is_sphere = float(min_dist == sphere_dist);\n    \n    if(min_dist == sphere_dist) {\n    \treturn Object(sphere_mat, sphere_dist);\n    }\n    \n    if(min_dist == back_dist) {\n        return Object(back_plane_mat, back_dist);\n    }\n    \n    return Object(plane_mat, point.y);\n}\n\n//SDF of the entire scene\nObject getDistCircle(vec3 point) {\n\t//Construct our sphere\n    vec4 sphere = vec4(0, 1, 6, 1);\n    float sphere_dist = sphereSDF(point, sphere);\n    \n    return Object(sphere_mat, sphere_dist);\n}\n\n/**\n * @brief Estimates the normal vector at a given point using finite diff\n * @param point, the point at which we want to compute the normal\n * @returns an estimated surface normal at the given point\n */\nvec3 getNormal(vec3 point) {\n\tvec2 epsilon = vec2(EPSILON, 0);\n    float dist = getDist(point).dist;\n    \n    return normalize(dist - vec3(\n    \tgetDist(point - epsilon.xyy).dist,\n        getDist(point - epsilon.yxy).dist,\n        getDist(point - epsilon.yyx).dist\n    ));\n}\n\n/**\n * @brief Marches along a given ray and finds the distance to the nearest object\n * @param ray_origin, the origin of the ray we are marching along\n * @param ray_direction, the direction of the ray we are marching along\n */\nObject rayMarch(vec3 ray_origin, vec3 ray_dir) {\n\tfloat origin_dist = 0.f;\n    Material mat;\n    \n    //Sphere trace along the ray\n    for(int i = 0; i < MAX_STEPS; ++i) {\n        //Compute the position of the next point\n    \tvec3 next_point = ray_origin + origin_dist * ray_dir;\n        \n        //Get the distance to the surface using the scene SDF\n        Object intersected = getDist(next_point);\n        origin_dist += intersected.dist;\n        mat = intersected.mat;\n        \n        //Check if we are closer than our Epsilon\n        if(intersected.dist < EPSILON || origin_dist > MAX_DIST) {\n            break;\n        }\n    }\n    \n    return Object(mat, origin_dist);\n}\n\nvec3 shadePoint(vec3 point, Material mat) {\n    //Define our light\n    vec3 light_pos = vec3(0, 5, 6);\n   \tlight_pos.xy += vec2(sin(iTime), cos(iTime));\n    \n    //Direction from our point to the light\n    vec3 dir_to_light = light_pos - point;\n    vec3 light_dir = normalize(dir_to_light);\n   \n    //Compute the normal\n    vec3 normal = getNormal(point);\n    \n    //Compute the lighting components\n    float diffuse = clamp(dot(normal, light_dir), 0.0, 1.0);\n    float ambient = 0.1;\n    \n    //Check for shadows\n    Object surface = rayMarch(point + normal * (EPSILON * 2.0), light_dir);\n    \n    if(surface.dist < length(dir_to_light)) {\n    \tdiffuse *= 0.1;\n    }\n    \n    float glow_amount = 1.0f;\n    vec3 glow_color = vec3(0.1f, 0.1f, 0.1f);\n    \n    //Check for glow\n   \n    /*if(sphere_dist < GLOW_SIZE && sphere_dist > 0.0f) {\n        glow_amount = (1.0f / (sphere_dist * sphere_dist)); \n    }*/\n    \n    //Compute the final light\n    vec3 light_color = (mat.ambient * ambient) + mat.diffuse * diffuse;\n            //glow_color * glow_amount;\n    \n    return light_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (0 -> 1) (0 is in the middle)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 ray_origin = vec3(0, 1, 0);\n    vec3 ray_direction = normalize(vec3(uv.x, uv.y, 1));\n    \n    Object intersected = rayMarch(ray_origin, ray_direction);\n    \n    //Compute the point which we hit with our march\n    vec3 point = ray_origin + ray_direction * intersected.dist;\n    \n    //diffuse light\n    col = shadePoint(point, intersected.mat); \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}