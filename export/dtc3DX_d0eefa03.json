{"ver":"0.1","info":{"id":"dtc3DX","date":"1686071931","viewed":411,"name":"Star Nursery for Starherd","username":"xingyzt","description":"Dynamic background for my stellar evolution project: https://x-ing.space/starherd\n(well, dynamic once I add in the evolution in the final WebGL webpage)\n\nBased off of Dusty Nebula by Duke: https://www.shadertoy.com/view/MsVXWW\nInspired by \"Cosmic Cliffs\"\n","likes":14,"published":1,"flags":0,"usePreview":1,"tags":["cloud","star","space","nebula","dust","filament"],"hasliked":0,"parentid":"MsVXWW","parentname":"Dusty nebula 4"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Dusty nebula 4\" by Duke\n// https://www.shadertoy.com/view/MsVXWW\n// (Tweaked by Xing for Starherd)\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 3\" (https://www.shadertoy.com/view/lsVSRW) \n// and \"Protoplanetary disk\" (https://www.shadertoy.com/view/MdtGRl) \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n//#define ROTATION\n//#define MOUSE_CAMERA_CONTROL\n\n\n#define TONEMAPPING\n#define BACKGROUND\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//=====================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 2; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{ \n    float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.yxz);   // mid-range noise\n    final += SpiralNoiseC(p.zyx*0.5123+100.0)*4.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n    return mix(3.0, final, smoothstep(-1., 0., p.z)); // museum screen\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi);\n\t#endif\n    \n    p.y += 0.5; // artistic pan up\n    \n\tfloat NebNoise = abs(NebulaNoise(p)*1.3);\n    \n\treturn NebNoise + 0.1;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 2.*vec3(0.8,0.6,0.5);\n\tvec3 colEdge = 0.5*vec3(0.8,0.6,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvec3 star(float i)\n{\n    vec3 p = (hash31(i*5.)-0.5) * vec3(3,2,0.5);\n    \n\t#ifdef ROTATION\n\tR(p.xz, -iMouse.x*0.008*pi);\n\t#endif\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n    vec2 mouse = 0.5-iMouse.xy/iResolution.y;\n    \n\tvec3 ro = vec3(2.0*mouse, -3);\n    ro.x += sin(iTime/5.0);\n    ro.z += cos(iTime/3.0);\n    \n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n\n    // raymarch loop\n\tfor (int i=0; i<32; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n        if(td>0.5 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n\t    \n        // evaluate distance function\n        float d = map(pos)*1.5;\n\t\t       \n\t\t// change this string to control density \n\t\t//d = max(d,0.08);\n        \n        // n stars\n        float lDist = 100.;\n        float n = 20.;\n        for(float s=0.; s<n; s+=1.0)\n        {\n            // point light calculations\n            vec3 sPos = star(s);\n            sPos += hash31(s+1.0)*sin(iTime/3.0+s*7.0)*0.2;\n            float sRadius = s/n*0.1+0.01;\n            float sDist = length(sPos - pos);\n            float surfDist = max(0.0, sDist - sRadius);\n            lDist = min(lDist, surfDist);\n            \n            // star in center\n            vec3 sCol = mix(\n                vec3(1.0,0.2,0.0),\n                vec3(0.6,0.6,1.0),\n                s/n + sin(iTime + s*7.0)\n            );\n            \n            float colorFade = clamp(0.0, 1.0, inversesqrt(surfDist));\n            \n            float fade = 0.5*mix( \n                1.0, \n                1e-3/sDist, \n                smoothstep(0.0, 1.0, sDist/sRadius) \n            ) + 5e-4;\n            \n            sum.rgb += fade * mix( \n                vec3(0.3,0.2,0.1), \n                sCol,\n                colorFade\n            ); // star itself and bloom around the light\n            \n        }\n        \n        if(lDist < 0.0) break;\n\t\t//td += 1./70.;\n       \n        // enforce minimum stepsize\n        d = max(d, 0.08); \n      \n        // add in noise to reduce banding and create fuzz\n\t\t\n        // trying to optimize step size near the camera and near the light source\n        t += max(min(lDist, d * 0.1 * max(min(lDist,length(ro)),1.0)), 0.04);\n        \n        // jitter\n        //t += fract(1e3*sin(1e4*dot(fragCoord,vec2(114,211.1)))) * 1e-2;\n      \n\t}\n    \n    // simple scattering\n\tsum *= 1. / exp( ld * 0.2 ) * 0.9;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n    \n    \n    #ifdef BACKGROUND\n    // stars background\n    if (td<0.8)\n    {\n        float stars = noise(rd*500.0)*0.5+0.5;\n        float starbg = smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0);\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n   \n    fragColor = vec4(ToneMapFilmicALU(sum.xyz),1.0);\n}","name":"Image","description":"","type":"image"}]}