{"ver":"0.1","info":{"id":"ldlczH","date":"1488784586","viewed":195,"name":"weird terrain","username":"polyrhythm","description":"raymarched  terrain","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\nconst vec3 SUN_DIR = normalize(vec3(0.2, 1.0, -0.75));\n\n// ----------\n// Noise\n// ----------\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n\n  vec2 i1;\n\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n\n  i = mod289(i); \n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// ---------------\n// transformations\n// ---------------\nfloat degToRad(float deg) {\n  return deg * (PI / 180.0);\n}\n\nmat3 rotateY(float deg) {\n  float theta = degToRad(deg);\n  float sinTh = sin(theta);\n  float cosTh = cos(theta);\n  return mat3(cosTh, 0.0, sinTh,\n              0.0,   1.0, 0.0,\n             -sinTh, 0.0, cosTh);\n}\n\nmat3 scale(vec3 s) {\n  return mat3(s.x, 0.0, 0.0,\n              0.0, s.y, 0.0,\n              0.0, 0.0, s.z);\n}\n\n// ---------------\n// terrain\n// ---------------\nfloat terrainMap(vec2 pos) {\n  float scale = 0.01;\n  const float amplitude = 13.0;\n  pos *= scale;\n  float time = iTime / 5.0;\n  return snoise(pos) * amplitude;\n}\n\n// ---------------\n// raytrace\n// ---------------\nvec2 trace(vec3 ro, vec3 rd) {\n  float dist, th;\n  const int MAX_STEPS = 400;\n  const float minT = 5.0;\n  const float maxT = 400.0;\n  float t = minT;\n  float origT = t;\n  float origDist = 0.0;\n  float height = 0.0;\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    th = 0.001 * t;\n    vec3 p = ro + rd * t;\n    float env = terrainMap(p.xz);\n    dist = p.y - env;\n    height = p.y;\n    if (dist < th) {\n      break;\n    }\n\n    origT = t;\n    origDist = dist;\n    t += 0.01 * t * dist * 0.6;\n\n    if (t > maxT) break;\n  }\n\n  if (t > maxT) return vec2(-1.0);\n\n  t = origT + (th - origDist) * (t - origT) / (dist - origDist);\n\n  return vec2(t, height);\n}\n\nvec3 getNormal(const vec3 pos) {\n  const float epsilon = 0.02;\n  vec3 n = vec3(terrainMap(vec2(pos.x - epsilon, pos.z)) - terrainMap(vec2(pos.x + epsilon, pos.z)),\n                2.0 * epsilon,\n                terrainMap(vec2(pos.x, pos.z - epsilon)) - terrainMap(vec2(pos.x, pos.z + epsilon)));\n\n  return normalize(n);\n}\n\n// ---------------\n// render\n// ---------------\nvec3 renderSky(vec3 ro, vec3 rd) {\n  vec3 col = 0.9 * vec3(0.8, 0.9, 1.0) - rd.y * vec3(0.75, 0.36, 0.4);\n\n  return col;\n}\n\nvec3 getMaterial(vec3 pos, vec3 n) {\n  vec3 green = vec3(0.2, 0.8, 0.1);\n  vec3 brown = vec3(0.9, 0.8, 0.3);\n\n  return 0.65 * mix(brown, green, smoothstep(0.4, 0.9, n.y));\n}\n\nfloat getShading(vec3 pos, vec3 n, float height) {\n  return saturate(dot(SUN_DIR, n)) + height * 0.035;\n}\n\nvec3 applyFog(vec3 colour, float dist) {\n  float fogAmount = 1.0 - exp(-dist * colour.z * 0.1);\n  vec3 fogColour = vec3(0.5, 0.6, 0.7) * 0.8;\n  return mix(colour, fogColour, fogAmount);\n}\n\nvec3 terrainColour(vec3 ro, vec3 rd, vec2 env) {\n  vec3 pos = ro + rd * env.x;\n\n  vec3 n = getNormal(pos);\n  float s = getShading(pos, n, env.y);\n  vec3 m = getMaterial(pos, n);\n\n  return applyFog(m * s, env.x);\n}\n\nvec4 render(vec3 ro, vec3 rd) {\n  vec4 col = vec4(0.0);\n  vec2 env = trace(ro, rd);\n  if (env.x != -1.0) {\n    col = vec4(terrainColour(ro, rd, env), 1.0);\n  }\n\n  return col;\n}\n\n// ---------------\n// Setup\n// ---------------\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  p *= iResolution.xy / iResolution.y;\n\n  vec3 colour = vec3(0.0);\n\n  vec3 origin = vec3(0.0, 20.0, -40.0);\n  origin.z += iTime * 1.5;\n  origin.x += iTime;\n  vec3 target = vec3(0.0, 0.0, 0.0);\n  target.z += iTime * 1.5;\n  target.x += iTime;\n  mat3 toWorld = setCamera(origin, target, 0.0);\n  vec3 rd = toWorld * normalize(vec3(p.xy, 1.25));\n\n  // sky\n  colour = renderSky(origin, rd);\n\n  // terrain\n  vec4 terrain = render(origin, rd);\n  colour = colour * (1.0 - terrain.w) + terrain.xyz;\n\n  fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}