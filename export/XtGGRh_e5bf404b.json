{"ver":"0.1","info":{"id":"XtGGRh","date":"1472951017","viewed":215,"name":"SnakeWay","username":"ARPP3","description":"KA...\nME...\nHA...\nME...\nHAAAAAA","likes":10,"published":1,"flags":1,"usePreview":0,"tags":["dbz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is Snake Way from DBZ\n\nvec3 sundir = normalize( vec3(-1.0,0.3,-1.0) );\nfloat depth = 0.0;\nfloat Falloff = 0.2;\n\nvec4 mapPath( vec3 p);\nmat2 rot35 = mat2(cos(radians(-35.0)), -sin(radians(-35.0)), sin(radians(-35.0)), cos(radians(-35.0)));\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    p.xy = rot35 * p.xy;\n    p.y -= 0.01;\n    vec3 q = abs(p);\n    return max(q.z-h.y * 0.5,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec3 doBump( in vec3 pos, in vec3 nor, in float signal, in float scale )\n{\n    // build frame\t\n    vec3  s = dFdx( pos );\n    vec3  t = dFdy( pos );\n    vec3  u = cross( t, nor );\n    vec3  v = cross( nor, s );\n    float d = dot( s, u );\n\n    // compute bump\t\n    float bs = dFdx( signal );\n    float bt = dFdy( signal );\n\t\n    // offset normal\t\n#if 1\n\treturn normalize( nor - scale*(bs*u + bt*v)/d );\n#else\n    // if you cannot ensure the frame is not null\t\n\tvec3 vSurfGrad = sign( d ) * ( bs * u + bt * v );\n    return normalize( abs(d)*nor - scale*vSurfGrad );\n#endif\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nvec3 calcNormals(in vec3 p)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        mapPath(p + eps.xyy).w - mapPath(p - eps.xyy).w,\n        mapPath(p + eps.yxy).w - mapPath(p - eps.yxy).w,\n        mapPath(p + eps.yyx).w - mapPath(p - eps.yyx).w));\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime * 0.5;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime * 0.5;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime * 0.5;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime * 0.5;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat sinX(float coeff) {\n    return (sin(coeff) + sin(coeff * (0.5 / 2.7182)) + sin(coeff * 0.0132)) * 2.4;\n}\nfloat sinY(float coeff) {\n\treturn (sin(-coeff) + sin(coeff * 2.7182) + sin(-coeff * 0.132)) * 0.1;\n}\n\nvec4 mapPath( vec3 p)\n{\n    vec3 coords = vec3(0.0, 0.0, iTime * 0.5);\n    float coeff = p.z - iTime * 0.5;\n    p.x += sinX(coeff);\n    p.y += sinY(coeff);\n    float r = radians(90.0);\n    mat3 rotate = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(r), -sin(r),\n        0.0, sin(r), cos(r));\n    \n    // cylinder\n    vec3 c = vec3(0.0, 0.3, 0.3);\n  \tfloat cyl = length((rotate * (p + vec3(0.0, 0.0, 0.0))).xz-c.xy)-c.z;\n\t\n    // box\n    c.xyz = vec3(0.3, 0.1, 99999.0);\n\tvec3 d = abs(p + vec3(0.0, -0.01, 0.0)) - c.xyz;\n  \tfloat box = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    \n    rotate = mat3(\n        cos(r), 0.0, sin(r),\n        0.0, 1.0, 0.0,\n        -sin(r), 0.0, cos(r));  \n    \n    // triangle instance 1\n    float tri = sdTriPrism(mod((rotate * p + vec3(iTime * 0.5, 0.3, 0.0)), 0.38) - 0.19, vec2(0.06, 0.01));\n    tri = min(tri, sdTriPrism(mod((rotate * p + vec3(iTime * 0.5 + 0.1266, 0.3, 0.0)), 0.38) - 0.19, vec2(0.06, 0.01)));\n    tri = min(tri, sdTriPrism(mod((rotate * p + vec3(iTime * 0.5 - 0.1266, 0.3, 0.0)), 0.38) - 0.19, vec2(0.06, 0.01)));\n    tri = min(tri, sdTriPrism(mod((rotate * p + vec3(iTime * 0.5 - 0.1266 * 0.5, 0.3, 0.0)), 0.38) - 0.19, vec2(0.06, 0.01)));\n    tri = min(tri, sdTriPrism(mod((rotate * p + vec3(iTime * 0.5 + 0.1266 * 0.5, 0.3, 0.0)), 0.38) - 0.19, vec2(0.06, 0.01)));\n    tri = min(tri, sdTriPrism(mod((rotate * p + vec3(iTime * 0.5 - 0.1266 * 1.5, 0.3, 0.0)), 0.38) - 0.19, vec2(0.06, 0.01)));\n    \n    float ret = min(max(tri, box), max(cyl, -box));\n    return vec4(p.xyz - coords, ret);\n}\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    // lighting\n    vec3 lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0, 0.6, 0.3)*dif;        \n    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n    col.xyz *= lin;\n    if (depth < t)\n        col = vec4(bgcol, col.a);\n    else\n    \tcol.xyz = mix( col.xyz  * vec3(1.3, 1.04, 0.52), bgcol, 1.0-exp(-0.003*t*t));\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.05,0.02*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(30,map5);\n    MARCH(30,map4);\n    MARCH(30,map3);\n    MARCH(30,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec4 rayMarchPath( in vec3 ro, in vec3 rd)\n{   \n    vec4 d = vec4(0.0);\n    float t = 0.0;\n\tfor (int i = 0; i < 256; i++)\n    {\n        vec3 point = ro + rd * t;\n        d = mapPath(point);\n        t += d.w * 0.45;\n    }\n    \n    vec3 worldSpace = ro + rd * t;\n    vec3 norm = calcNormals(worldSpace);\n    \n    mat2 rot = mat2(cos(radians(45.0)), -sin(radians(45.0)),\n                    sin(radians(45.0)), cos(radians(45.0)));\n    \n    vec3 col = texture(iChannel1, rot * (worldSpace.zy * vec2(2.0) - vec2(iTime * 2.0 * 0.5, 0.0))).xyz;\n    col = 1.0 - col * 0.2;\n    \n    if (dot(norm, vec3(0.0, 1.0, 0.0)) > 0.9)\n        col = 1.0 - texture(iChannel2, d.xz).xyz * 0.01;\n    norm = doBump(worldSpace, norm, dot(col, vec3(0.33)) * 0.2, 0.6);\n    \n    float sun1 = clamp(0.0, 1.0, dot(norm, sundir));\n    float sun2 = clamp(0.0, 0.6, dot(norm, -sundir));\n    float sun3 = clamp(0.0, 0.8, dot(norm, normalize(sundir - vec3(0.0, -0.6, 0.0))));\n    \n    return vec4(max(vec3(0.4), max(sun1, max(sun2, sun3))) *\n    \t(col * vec3(0.58, 0.82, 1.2)), clamp(0.0, 1000.0, t));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.81,0.6,0.85) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.7;\n\tcol += 0.2*vec3(1.0,1.0,0.05)*pow( sun, 8.0 );\n\n    // path\n    vec4 path = rayMarchPath(ro, rd);\n    float t = 1.0 / (path.w * path.w * 0.01);\n    depth = path.w;\n    \n    col = mix(col, path.xyz, clamp(0.0, 1.0, t));\n    \n    // clouds    \n    vec4 res = raymarch( ro, rd, col );\n    col = col*(1.0-res.w) + res.xyz;\n        \n    // sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    \n    // camera\n    \n    float xPos = sinX(-iTime * 0.5);\n    float yPos = sinY(-iTime * 0.5);   \n    \n    vec3 ro = vec3(-xPos, -yPos + 0.1, 0.0);\n\tvec3 ta = vec3(-sinX(-iTime * 0.5 - 0.1), 0.0, -0.8);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    float rf = sqrt(dot(p, p)) * Falloff;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);\n    \n    fragColor = render( ro, rd );\n    fragColor = fragColor * (fragColor * 0.6 + 0.4) * e;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir );\n}","name":"Image","description":"","type":"image"}]}