{"ver":"0.1","info":{"id":"MffcD2","date":"1723643725","viewed":79,"name":"Underwater Tunnel Explorer","username":"lz","description":"Autopilot with collision detection.\nif EXPLORE_OUTSIDE is defined (and started over) than it travels between the tubes.\nShould easily handle most of full-screen configurations.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["3d","motionblur","hud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Creator: Leonid Zaides\n *\n * Underwater Tunnel Explorer\n *\n * Copyright © 2024 Leonid Zaides\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *   \n *  --------------------------------------------------------\n *\n *\n * After making Alien Tunnel (https://www.shadertoy.com/view/X3ySRc) \n * had some offline comments that it would be interesting to\n * go inside, and explore the tunnels, so here it is.\n *\n * While I have used the same double-gyroid geometry, this\n * should work for any geometry (up-to parameter tuning).\n *\n * I have decreased the lighting complexity to focus on the\n * movement and increase FPS to achieve smooth travel on\n * higher resolutions. It runs well on full of screen \n * MacBook Pro M2 (~35 fps on an equivalent of 3.5K resolution)\n * so should handle most of full screens well and 4K with\n * a decent GPU.\n *\n * \n * ------------------\n * \n * The implementation is rather straightforward - \n * Shoot rays into several directions and go to the \n * direction with the farthest distance. (Buffer A)\n * \n * Motion Blur is done by finding velocity vector at\n * each frame, projecting it and averaging along this\n * vector. (Buffer D)\n *\n * Hud displays information on some of the 'sensors':\n * Speed, lateral proximity, forward proximity and roll\n */\n \n // DEBUG PRINT SECTION\n//#define DEBUG_PRINT\n\n#define _0 vec2(0., 12.)\n#define _1 vec2(1., 12.)\n#define _2 vec2(2., 12.)\n#define _3 vec2(3., 12.)\n#define _4 vec2(4., 12.)\n#define _5 vec2(5., 12.)\n#define _6 vec2(6., 12.)\n#define _7 vec2(7., 12.)\n#define _8 vec2(8., 12.)\n#define _9 vec2(9., 12.)\n#define _DOT    vec2(14., 13.)\n#define _DASH   vec2(13., 13.)\n\n#define ADVANCE_ST(_v) (st.x += _v*0.5*_dsize.x)\n#define TRANSLATE_ST(_v) (st.x + _v * 0.5*_dsize.x)\n#define MAX_PRE_DOT_DIGITS 4.\n#define MAX_POST_DOT_DIGITS 1.\n\n#define INC_COL(a) (a += 1.1*d_size.y)\n\nfloat printSymbol(in vec2 _uv, in vec4 _dbox, in vec2 _symb)\n{\n    vec2 inside = step(_dbox.xy, _uv) - step(_dbox.xy + _dbox.zw, _uv);\n    if (inside.x * inside.y < 0.5)\n        return 0.;\n        \n    vec2 uv = clamp((_uv - _dbox.xy) / _dbox.zw, 0.1, 0.9);\n    float f = texture(iChannel2, 0.0625 * (_symb + uv)).w;\n    return 75.*smoothstep(.5, 0.1, f);\n}\n\nfloat printFixedNumber(in vec2 _uv, in vec2 _dstart, in vec2 _dsize, in float _num)\n{\n    vec2 st = _dstart;\n    float hndr_digit = floor(_num * 0.01);\n    float ten_digit = floor(_num * 0.1);\n    float unit_digit = floor(mod(_num, 10.));\n    float tenth_digit = floor(fract(_num) * 10.);\n    \n    float f;\n    f += printSymbol(_uv, vec4(st, _dsize), vec2(ten_digit, 12.));\n    ADVANCE_ST(1.1);\n    f += printSymbol(_uv, vec4(st, _dsize), vec2(unit_digit, 12.));\n    st.y -= _dsize.y*0.3;\n    st.x -= _dsize.x*0.01;\n    //f += printSymbol(_uv, vec4(st, _dsize), _DOT);\n    //ADVANCE_ST(0.75);\n    //f += printSymbol(_uv, vec4(st, 0.5*_dsize), vec2(tenth_digit, 12.));\n    \n    return f;\n}\n#ifdef DEBUG_PRINT\n\nfloat printNumber(in vec2 _uv, in vec2 _dstart, in vec2 _dsize, in float _num)\n{\n    vec2 symb;\n    vec2 st = _dstart;\n    float f = 0.;\n    if (_num < 0.) {\n        f = printSymbol(_uv, vec4(st, _dsize), _DASH);\n        _num *= -1.;\n        ADVANCE_ST(1.);\n    }\n    float num = _num;\n    float div = 1.;\n    float nd = 0.;\n    for (;nd < MAX_PRE_DOT_DIGITS && num >= div; nd++, div *= 10.);\n    //f += printSymbol(_uv, vec4(st, _dsize), vec2(nd, 12.));\n    \n    ADVANCE_ST(nd);\n    \n    // before the dot\n    float inum = 0.;\n    for (float id = 0.; id < nd; id++) {\n        float digit = floor(mod(num, 10.));\n        inum += digit * (id + 1.);\n        num /= 10.;\n        f += printSymbol(_uv, vec4(TRANSLATE_ST(-(id + 1.)), st.y, _dsize), vec2(digit, 12.));\n    }\n    if (nd == 0.0)\n    {\n        ADVANCE_ST(1.);\n        f += printSymbol(_uv, vec4(TRANSLATE_ST(-1.), st.y, _dsize), _0);\n    }\n    \n    f += printSymbol(_uv, vec4(st, _dsize), _DOT);\n    \n    num = _num - inum;\n    // print 2 digits after the dot\n    ADVANCE_ST(1.); //\n    for (float id = 0.; id < MAX_POST_DOT_DIGITS; id++) {\n        num *= 10.;\n        float digit = floor(mod(num, 10.));\n        f += printSymbol(_uv, vec4(st, _dsize), vec2(digit, 12.));\n        ADVANCE_ST(1.);\n    }\n    \n\n    return f;\n}\n#endif\n\n\n#define TFC(CRD) texelFetch(iChannel0, ivec2(CRD),0)\n#define TEX(UV)  texture(iChannel0, UV)\n\n// Heads Up Display\n// This function is a bit messy\nvec4 draw_hud(in vec2 _uv, vec4 _params) {\n    vec3 o = TF1(ORIG_POS).xyz;\n    vec3 d = TF1(ORIG_DIR).xyz;\n    vec3 u = TF1(ORIG_UP).xyz;\n    vec4 prox = TF1(PROX_SNS);\n    vec4 hitp = TF1(D_HIT_POS);\n    \n    vec3 r = cross(d, u);\n    \n    float ratio = iResolution.x/iResolution.y;\n    //ratio = iResolution.y/iResolution.x / HUD_TARGET_RATIO;\n    vec2 cuv = _uv;\n    CURVE_UV(cuv);\n    float luv = length(cuv);\n    \n    // patterns\n    float y_pattern = pow(abs(0.25 + 2.*cos(cuv.y*200.)), 2.);\n    float x_pattern = pow(abs(0.25 + 2.*cos(cuv.x*200.)), 2.);\n    float xy_pattern = 0.15*(y_pattern + x_pattern);\n    ivec2 ch_grid = ivec2(cuv * 200.);\n    float ch_pattern = max(0.1 + float(abs(ch_grid.x + ch_grid.y) % 2), 1.);\n    vec4 prox_active = smoothstep(2., 1., prox);\n    float hit = smoothstep(7.5, 0., hitp.w);\n    float vel_start = mix(1., 0., clamp((_params.x * _params.x * 0.25), 0., 1.));\n\n    // field of view based animation of the rings\n    float fov_t = -0.025 * (1.-FOV_T(iTime));\n\n    vec2 ang_cuv = ANG_UV(cuv);\n    vec2 sqr_cuv = STR_UV(cuv, 1.5);\n    \n    float f = hud_frame(_uv, ratio, vec3(HUD_DIM * vec2(ratio, 1.), 0.695));\n    vec2 fc_uv = vec2(f, abs(abs(_uv.y)-0.4*HUD_DIM) - 0.02);\n    fc_uv.y = abs(fc_uv.y);\n    float fsc = max(sdTrapezoid(fc_uv, 0.2, 0.00, 0.15), -(f+0.05));\n\n    f = max(f, -fsc);\n    float hf = smoothstep(0., 0.01, -f);\n    \n    // white on borders\n    float to_white = 0.5*luv*luv*dot(normalize(vec2(0.15*_uv.x, _uv.y)), vec2(1., 0.));\n    vec3 col = hf*mix(HUD_BASE_CLR,vec3(1.), to_white * to_white);\n    \n    col += vel_start * vec3(1., 0.4, 0.1)*PULSE_T(-f, 0.01, 0.05, 0.051);\n    \n    // white frame\n    float wf = hud_frame(_uv, ratio, vec3(HUD_DIM * vec2(ratio*1.03, 0.95), 0.705));\n    wf = max(wf, -(f+0.011));\n    wf = smoothstep(0., 0.01, -wf);\n    col +=  ch_pattern * wf * vec3(1.) * (0.999*cuv.y*cuv.y);\n    \n    vec2 ang_grid = ang_cuv * vec2(1., 1.);\n    vec2 iang_grid = floor(ang_grid);\n    vec2 fang_grid = fract(ang_grid);\n    float border = 0.1;\n    float cnt_d_size = mix(0.22 + + fov_t, 0.22 + + fov_t, smoothstep(0., 1., _params.x*0.1));\n    float fline = sdSegment(vec2(ang_grid.x - cnt_d_size, fract(ang_grid.y + 0.5)), vec2(0., border),\n                                    vec2(0., 1.-border));\n    \n    float snsGrid = mod((ang_grid.y*4. + 0.5), 4.);\n    \n    float fcring = PULSE_T(ang_grid.x, 0.02, 0.15 + fov_t, 0.16 + fov_t);// sdSegment(vec2(ang_grid.x - cnt_d_size, fract(ang_grid.y + 0.5)), vec2(0., 3.), vec2(0.,7.));\n    float fprox_sns = PULSE_T(ang_grid.x, 0.01, 0.155 + fov_t, 0.155 + fov_t);\n    fprox_sns *= PULSE_T(fract(snsGrid), 0.05, 0.25, 0.75);\n    fcring -= fprox_sns;\n    float fring = PULSE_T(ang_grid.x, 0.005, 0.27 + fov_t, 0.27 + fov_t);\n    fring += PULSE_T(ang_grid.x, 0.005, 0.28 + fov_t, 0.28 + fov_t);\n    \n    float froll = 0.75 * PULSE_T(fract(ang_grid.y * 2.), 0.1, 0.4 + _params.y*0.75, 0.6 + _params.y*0.75) \n            * PULSE_T(ang_grid.x, 0.01, 0.31 + fov_t, 0.31 + fov_t);\n   \n    float nticks = mix(30., 150., clamp((iResolution.y - 300.)/1000., 0.,1.));\n    float fcticks = PULSE_T(fract(ang_grid.y * nticks), 0.2, 0.5, 0.5);\n    float ftick_hlt = mix(1., 20., step(1.-fract(ang_grid.y + 0.5), _params.x*0.1));\n    float fdbl = PULSE_T(fline, 0.005, 0.0195, 0.02);\n    \n    // sensors\n    float fside_sns = PULSE_T(sqr_cuv.x, 0.01, 0.375 + fov_t, 0.4 + fov_t);\n    fside_sns *= PULSE_T(fract(snsGrid), 0.05, 0.25, 0.75);\n    \n    // single line\n    float fsng = smoothstep(0.015, 0., fline);\n    \n    // double line\n    col += fdbl * mix(HUD_BASE_CLR.bgr, vec3(1.), 0.25);\n    col += fsng * fcticks * mix(fract(ang_grid.y - 0.5)*HUD_BASE_CLR.bgr*ftick_hlt, vec3(1.), 0.25);\n    col += (froll);\n\n    // front collision sensors\n    col += fprox_sns * mix(vec3(0.7, 0.7, 0.8),\n               vec3(1.75, 0.7, 0.1), \n               hit * \n               ORIG2UNIT(cos(iTime*PI2)));\n    \n    // side proximity sensors\n    col += fside_sns * ch_pattern * prox_active[int(snsGrid)];\n    \n    // side sonar ---\n    vec2 rad_uv = cuv - vec2(HUD_DIM.x * ratio * 0.7, -0.4);\n    float fradar = exp(-length(rad_uv)*3.3);\n    fradar = smoothstep(0.4, 1., fradar);\n    float rscale = 80. + _params.x*5.;\n    vec3 rad_p = o + rscale * (r * rad_uv.x + d * rad_uv.y);\n    vec3 gyro = double_gyroid(rad_p, get_gyroid_t(rad_p, iTime),\n                                iTime, 0.);\n    // borders\n    vec3 gyro_col = vec3(1.)*PULSE_T(gyro.x, 0.1, -0.01, 0.01);\n    float i_f = mix(0.5, 1.5, floor(abs(gyro.x * 4.))/4.);\n    // brown tunnel\n    gyro_col += ch_pattern * mix(INV_TUNNEL0_CLR.bgr * i_f, \n        vec3(0.5), 0.75) * smoothstep(0., 1., gyro.y) * smoothstep(0., 1., -gyro.z);\n    // blue tunnel\n    gyro_col += ch_pattern * mix(INV_TUNNEL1_CLR.bgr * i_f, vec3(0.5), 0.75) * smoothstep(0., 1., gyro.y) * smoothstep(0., 1., gyro.z);\n    gyro_col += (mix(HUD_BASE_CLR.rbg, vec3(1.), 0.5)*xy_pattern) * smoothstep(0., 1., -gyro.y);\n    gyro_col *= smoothstep(0., 0.2, fradar);\n    gyro_col += 3.*PULSE_T(fradar, 0.01, 0.05, 0.05);\n    \n    // self character\n    float fself = sdEquilateralTriangle(vec2(rad_uv.x, rad_uv.y + 20.*(rad_uv.x*rad_uv.x)), 0.02);\n    gyro_col += 0.75*smoothstep(0.005, 0., abs(fself) - 0.0001);\n    gyro_col += vec3(0.3, 0.2, 0.1)*smoothstep(0.005, 0.001, fself);\n    \n    vec2 d_size = vec2(0.35 / ratio, 0.2);\n    float fvel = 1.5*printFixedNumber(cuv, vec2(-d_size.x*0.76, -d_size*0.5), d_size, _params.x);\n    col += fvel * mix(3.*HUD_BASE_CLR.gbb, vec3(1.), 0.);\n    col += fradar * gyro_col;\n    \n    float alpha = max(0.5*hf, 0.6*wf);\n    alpha = mix(alpha, 0.75, fcring);\n    alpha = mix(alpha, 0.75, fring);\n    alpha = mix(alpha, 0.7, fsng * fcticks);\n    alpha = mix(alpha, 0.7, froll);\n    alpha = mix(alpha, 0.25, fdbl);\n    alpha = mix(alpha, 0.25, fvel);\n    alpha = max(alpha, 1.25*fradar);\n    return vec4(col, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ruv = fragCoord / iResolution.xy;\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 muv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n    vec4 col = texture(iChannel3, ruv);\n    float roll = TF1(ORIG_DIR).w;\n    float vel = TF1(ORIG_VEL).x;\n    float fps = TF1(FPS_DATA).y;\n    float ratio = iResolution.x/iResolution.y;\n    \n    uv = ROT2D(uv, roll);\n    float frame = hud_frame(uv, ratio,\n                        vec3(HUD_DIM * vec2(ratio*10.5, 1.1), 100.815));\n\n    float rdepth = col.w/FAR;\n    // post processing  \n    col.rgb = mix(col.rgb, 0.25 * col.rgb, rdepth * rdepth);\n    col.rgb = mix(col.rgb, vec3(0., 0.36, 0.7), 1.-exp(-rdepth*5.));\n    col *= 3.;\n    col /= (1. + col);\n    col.rgb = pow(col.rgb, vec3(2.2));\n    \n    \n    vec4 hcl = draw_hud(uv, vec4(vel, roll, 0., 0.));\n    // draw hud\n    col.rgb = mix(col.rgb, hcl.rgb, hcl.w);\n    \n    #ifdef DEBUG_PRINT\n    vec2 d_size = vec2(0.05 / ratio, 0.05);\n    vec4 hit = TF1(D_HIT_POS);\n\n    vec4 dvals = TF1(D_VALS);\n    vec3 rd = TF1(ORIG_DIR).xyz;\n    float col_up;\n    col.rgb += printNumber(ruv, vec2(0.01, 0.01), d_size, fps);\n    //col.r += printNumber(ruv, vec2(0.01, 0.01 + INC_COL(col_up)), d_size, dvals.y);\n    //col.g += printNumber(ruv, vec2(0.01, 0.01 + INC_COL(col_up)), d_size, dvals.z);\n    //col.g += printNumber(ruv, vec2(0.01, 0.01 + INC_COL(col_up)), d_size, dvals.w);\n    \n    #endif\n    \n    col = mix(vec4(0.), col, smoothstep(0., 0.25, iTime));\n    \n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_H 1.57079632679\n\n#define PHI 1.6180339887\n#define INV_PHI 0.6180339887\n\n#define INT(f) int(f + 0.00001)\n\n#define SEL_ZONE_Y 0.01\n\n#define ROT2D(p2d, ang) (cos(ang) * p2d.xy + sin(ang) * vec2(p2d.y, -p2d.x))\n\n#define FAR 60.\n#define M_ITER 256\n#define T_EPS 0.001\n#define N_EPS 0.001\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n#define ASYM_PULSE_T(_t, _ea, _pa, _eb, _pb) (smoothstep(_pa - _ea, _pa, _t) - smoothstep(_pb, _pb + _eb, _t))\n#define ANIM_T_CF(_t, _p, _e0, _e1, _cf0, _cf1) (_cf0 * smoothstep(_p - _e0, _p, _t) - _cf1 * smoothstep(_p, _p + _e1, _t))\n#define ANIM_T_CF3(_t, _p0, _p1, _p2, _e0, _e1, _e2, _cf0, _cf1) (_cf0 * smoothstep(_p0 - _e0, _p0, _t) - _cf1 * smoothstep(_p1, _p1 + _e1, _t) - (_cf0-_cf1) * smoothstep(_p2, _p2 + _e2, _t))\n#define ANG_UV(_uv) vec2(length(_uv), 0.5 * (1. + atan(_uv.x, _uv.y)/PI))\n#define SQR_UV(_uv) vec2(max(abs(_uv.x), abs(_uv.y)), 0.5 * (1. + atan(_uv.x, _uv.y)/PI))\n#define STR_UV(_uv, _p) vec2(pow(pow(abs(_uv.x), _p) + pow(abs(_uv.y), _p), 1./_p), 0.5 * (1. + atan(_uv.x, _uv.y)/PI))\n#define RMB_UV(_uv) vec2(abs(_uv.x) + abs(_uv.y), 0.5 * (1. + atan(_uv.x, _uv.y)/PI))\n\n#define UNIT2ORIG(_a) (1. - 2. * _a)\n#define ORIG2UNIT(_a) (0.5 + 0.5 * _a)\n\n#define MAX_ITER 128.\n#define COLLISION_FAR 30.\n#define T_COL_EPS 0.01\n#define ARCTAN_30 0.5773502\n#define ARCTAN_45 1.\n#define ARCTAN_60 1.7320508\n#define ARCTAN_80 5.6712818\n#define ANG_EPS 0.1\n\n#define FOV_T(_t) PULSE_T(mod(_t, 40.), 3., 10., 35.)\n#define FOV(_t) (1. + 2.5 * FOV_T(_t))\n\n//#define HUD_ONLY\n//#define EXPLORE_OUTSIDE\n#ifdef EXPLORE_OUTSIDE\nconst vec3 start_pos = vec3(-8, -16., -5.);\n#else\nconst vec3 start_pos = vec3(-8, -2., -5.);\n#endif\nconst vec3 start_dir = normalize(vec3(0., -0.75, 1.));\nconst vec3 start_up = vec3(0., 1., 0.);\nconst float acc_factor = 15.; // \nconst float max_velocity = 30.; // units per second.\nconst float min_stopping_distance = 2.; // minimum stopping distance from obstacle\n\nconst float dir_update_wait = 0.25;\nconst float drag = acc_factor/(max_velocity * max_velocity);\n\n// do we want to keep up with the current direction\n// or always go with the farthest?\nconst float direction_policy = 0.5;\n\n// turning speed\nconst float rad_per_sec = 0.5;\n\n// weight of primary direction in choosing new direction\nconst float primary_dir_weight = 1.;\n\n// Movement control fields\n#define CONTROL_ZONE ivec2(5,5)\n#define ORIG_POS ivec2(0,0)\n#define ORIG_DIR ivec2(0,1)\n#define ORIG_UP  ivec2(0,2)\n#define ORIG_VEL ivec2(0,3)\n// last chosen direction\n#define PREV_DIR ivec2(0,4)\n#define D_HIT_POS  ivec2(1,0) // vec4(pos, dist)\n#define D_VALS ivec2(2,0)\n#define PP_DIR ivec2(3,0)\n#define PROX_SNS ivec2(3, 1)\n\n#define FPS_DATA ivec2(4,0)\n\n#define TF0(crd) texelFetch(iChannel0, crd, 0)\n#define TF1(crd) texelFetch(iChannel1, crd, 0)\n#define TF2(crd) texelFetch(iChannel2, crd, 0)\n#define TF3(crd) texelFetch(iChannel3, crd, 0)\n#define TF(ch, crd) texelFetch(ch, crd, 0)\n\n#define TX0(_uv) texture(iChannel0, _uv)\n#define TX1(_uv) texture(iChannel1, _uv)\n#define TX2(_uv) texture(iChannel2, _uv)\n#define TX3(_uv) texture(iChannel3, _uv)\n\n#define HUD_BASE_CLR vec3(0.03, 0.08, 0.2)\n#define INV_TUNNEL0_CLR  vec3(0.23, 0.25, 0.97)\n#define INV_TUNNEL1_CLR  vec3(1., 0.6, 0.321)\n#define CURVE_UV(_uv) (_uv.y *= (1. - 0.3*smoothstep(0.0, HUD_DIM.y, abs(_uv.y))*(_uv.x*_uv.x*0.1)))\n#define DECURVE_UV(_uv) (_uv.y /= (1. - 0.3*smoothstep(0.0, HUD_DIM.y, abs(_uv.y))*(_uv.x*_uv.x*0.1)))\n\n#define HUD\n#ifdef HUD\n//\n#define HUD_DIM vec2(0.8, 0.7)\n#define HUD_TARGET_RATIO 0.25\n#define TARGET_RATIO 1.\n#else\n//#define TARGET_RATIO 0.5625\n#define TARGET_RATIO 0.428\n//\n#endif\n//\n// iq SDF functions\n//https://iquilezles.org/articles/distfunctions/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n#define dot2(k) dot(k, k)\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat smax(in float _f1, in float _f2, in float _k)\n{\n  float df = _f1 - _f2;\n  return 0.5 * (_f1 + _f2 + sqrt(df * df + _k));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n//\n\n// https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\nvec3 rotate(in vec3 _v, in vec3 _k, in float _a) {\n    float ca = cos(_a);\n    float sa = sin(_a);\n    \n    vec3 rv = _v * ca + cross(_k, _v) * sa + _k * dot(_k, _v) * (1. - ca);\n    \n    return normalize(rv);\n}\n\n// noise\nfloat hash(in float s) {\n  return fract(5313.235 * mod(s, 0.78182) * mod(s, 0.1242));\n}\n\nfloat hash2(in vec2 st) {\n    return fract(sin(dot(st.xy,\n        vec2(113.9928,1178.243)))\n            * 4358.5475123);\n}\n\nfloat noise(in float s)\n{\n  float i = floor(s);\n  float f = fract(s);\n  \n  return mix(hash(i), hash(i + 1.0), f * f* (3.0 - 2.0 * f));\n}\n\n//https://www.shadertoy.com/view/ldSSzV\nvec3 hash31(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\nfloat grayscale(in vec3 col)\n{\n    float gray = dot(col.rgb, vec3(0.299, 0.587, 0.114));\n    return gray;\n}\n\n\nfloat hash(in vec3 p)\n{\nreturn fract(sin(dot(p,\nvec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nfloat noise3(in vec3 p)\n{\nvec3 pi = floor(p);\nvec3 pf = fract(p);\n\npf = pf*pf*(3.-2.*pf);\n\nfloat a = hash(pi + vec3(0., 0., 0.));\nfloat b = hash(pi + vec3(1., 0., 0.));\nfloat c = hash(pi + vec3(0., 1., 0.));\nfloat d = hash(pi + vec3(1., 1., 0.));\n\nfloat e = hash(pi + vec3(0., 0., 1.));\nfloat f = hash(pi + vec3(1., 0., 1.));\nfloat g = hash(pi + vec3(0., 1., 1.));\nfloat h = hash(pi + vec3(1., 1., 1.));\n\nreturn mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\nmix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 4; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 12.274739;\n  }\n\n  return f;\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat hud_frame(in vec2 _uv, float _r, in vec3 _hdims) {\n    vec2 cuv = _uv;\n    // add curvature\n    CURVE_UV(cuv);\n\n    float fb = sdBox(cuv, _hdims.xy);\n    float fl = dot(abs(_uv), normalize(vec2(1.))) - _hdims.z*sqrt(_r*_r + 1.);\n    float f = max(fl, fb);\n    \n    return f;\n}\n\nfloat get_gyroid_t(in vec3 p, in float _time) {\n    return 0.7 + 0.1*noise(p.z);\n}\n\nfloat get_slen(in vec3 p, in float _t, in float _factor) {\n   //return PI2 * (3. + 0.8*sin(_t * 0.45 + p.x*0.5) + _factor * (18. + noise3(p*0.1) + 0.15*sin(5.*_t)-2.5*(log(length(p)))) );\n    return PI2 * (5. + 0.01*pow(0.5 + 0.5 * sin(_t * 2. + 0.02*p.x), 2.));\n}\nvec3 double_gyroid(in vec3 p, in float t, in float _time, in float high)\n{\n    vec3 r;\n    float s_len = get_slen(p, _time, 0.5);\n    \n    float fn = dot(cos(p*PI2 / s_len), sin(p.yzx * PI2 / s_len));\n    \n    r.x = fn*fn - t*t;\n    \n    // differentiate gyroid\n    r.z = sign( (abs(fn - t) - abs(fn + t)) );\n    \n    // differentiate side of the gyroid\n    r.y = sign( r.x );\n    \n    r.x = 0.5*abs(r.x);\n    \n    return r;\n}\n\n\n// returning positive for negative values\nfloat geom_c(in vec3 _p, in float _time) {\n    float tval = get_gyroid_t(_p, _time);    \n    return 0.25*double_gyroid(_p, tval, _time, 1.).x;\n}\n\nfloat traceGeomHit(in vec3 _o, in vec3 _d, in vec4 _param) {\n    float t = 0., ft = 10.;\n    float i = 0.;\n    vec3 p;\n    for (i = 0.; i < MAX_ITER; i++) {\n        p = _o + t * _d;\n        ft = geom_c(p, _param.x);\n        \n        if (ft > FAR || abs(ft) < T_COL_EPS * t) {\n            break;\n        }\n        \n        t += ft;\n    }\n    \n    return t;\n}\n\nmat4 makeSymPerspective(in float _n, in float _f, in float _alpha, in float _ratio)\n{\n    float r = tan(_alpha);\n    float l = -r;\n    float t = r;\n    float b = -t;\n    \n    return transpose(mat4(_n/r, 0., 0., 0.,\n                0., _n/t, 0., 0., \n                0., 0., -(_f+_n)/(_f-_n), -2.*_f*_n/(_f-_n),\n                0., 0., -1., 0.));\n}\n\nmat4 translate(const vec3 _xyz)\n{\n    return transpose(mat4(1., 0., 0., 0.,\n                           0., 1., 0., 0.,\n                           0., 0., 1., 0.,\n                -_xyz.x, -_xyz.y, -_xyz.z, 1.));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n#define ATF(_crd, _pos, _val) if (_crd.x == _pos.x && _crd.y == _pos.y) { col = _val; }\n#define N_LATERAL_SENSORS 6\n#define N_SENSORS 2 * N_LATERAL_SENSORS + 1\n\nvec4 collision_dirs[N_SENSORS]; // collision directions\n\n// this is just a short notation\n#define CLS collision_dirs\n\n// calculate direction score based on distance and current direction\nfloat d_score(in vec3 _v, in float _dist, in vec3 _pv, in float _vel_factor) {\n    \n    return mix(dot(_pv, _v), _dist, direction_policy);\n}\n\nfloat eps_sign(in float _v, in float _eps) {\n    float rv = step(_eps, _v) - step(_v, -_eps);\n    return rv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col;\n    ivec2 crd = ivec2(fragCoord);\n    \n\n#if N_LATERAL_SENSORS == 4\n    const vec4 dir_cf = vec4(ARCTAN_30, -ARCTAN_30, ARCTAN_60, -ARCTAN_60);\n    \n#else  \n    const float[N_LATERAL_SENSORS] dir_cf = float[6](ARCTAN_30, -ARCTAN_30,\n                                     ARCTAN_45, -ARCTAN_45,\n                                     ARCTAN_60, -ARCTAN_60);\n#endif    \n    // update controls\n    if (crd.x < CONTROL_ZONE.x && crd.y < CONTROL_ZONE.y) {\n        vec3 o = TF0(ORIG_POS).xyz;\n        vec3 d = normalize(TF0(ORIG_DIR).xyz);\n        float roll = TF0(ORIG_DIR).w;\n        vec3 u = normalize(TF0(ORIG_UP).xyz);\n        vec4 v = TF0(ORIG_VEL);\n        vec3 r = normalize(cross(d, u));\n        vec4 pd = TF0(PREV_DIR); // previous direction\n        vec3 ppd = TF0(PP_DIR).xyz;\n        vec4 fps_data = TF0(FPS_DATA);\n        \n        // initialize\n        if (iFrame == 0){\n            ATF(crd, ORIG_POS, vec4(start_pos, 0.));\n            ATF(crd, ORIG_DIR, vec4(start_dir, 0.));\n            ATF(crd, ORIG_UP, vec4(start_up, 0.));\n            ATF(crd, ORIG_VEL, vec4(0., start_dir));\n            ATF(crd, D_HIT_POS, vec4(0.));\n            ATF(crd, PREV_DIR, vec4(start_dir, 0.));\n            ATF(crd, D_VALS, vec4(0.));\n            ATF(crd, PP_DIR, vec4(start_dir, 0.));\n        }\n        else {\n            vec3 vd = d;\n            vec4 dvals;\n            // setup directions for collision detection\n            collision_dirs[0] = vec4(d, 0.);\n            for (int id = 1; id < N_LATERAL_SENSORS + 1; id++) {\n                collision_dirs[id] = vec4(normalize(d + u * dir_cf[id - 1]), 0.);\n                collision_dirs[id + N_LATERAL_SENSORS] = vec4(normalize(d + r * dir_cf[id - 1]), 0.);\n            }\n\n            // compute distance to collision in the current course\n            for (int id = 0; id < N_SENSORS; id++)\n                collision_dirs[id].w = traceGeomHit(o, collision_dirs[id].xyz, vec4(iTime, 0., 0., 0.));\n            \n            vec3 d_hit_pos = o + d * collision_dirs[0].w;\n            \n            // choose new direction based on distance\n            // The primary direction is given less weight\n            // to explore more.\n            float prim_dir_weight = mix(1., primary_dir_weight, v.x/max_velocity);\n            \n            // we want to be pretty decisive in low velocities and \n            // being able to fluctuate in higher\n            float vel_factor = mix(20., 5., v.x/max_velocity);\n            float I = mix(0., 1., step(d_score(CLS[0].xyz, prim_dir_weight*CLS[0].w, pd.xyz, vel_factor),\n                                       d_score(CLS[1].xyz, CLS[1].w, pd.xyz, vel_factor)));\n            \n            // There is score computation duplication here but\n            // it's rather cheap and maybe better than storing \n            for (int id = 2; id < N_SENSORS; id++)\n                I = mix(I, float(id), step(\n                                    d_score(CLS[int(I)].xyz,CLS[int(I)].w, pd.xyz, vel_factor), \n                                    d_score(CLS[id].xyz, CLS[id].w, pd.xyz, vel_factor)));\n            \n            // chosen direction\n            vec3 cv = CLS[int(I)].xyz;\n\n            // can't play with the stick too much :(\n            // otherwise it will be shaky\n            float f_update_time = (iTime - pd.w) / dir_update_wait;\n            \n            float dir_update = step(1., f_update_time);\n            \n            ppd = mix(ppd, pd.xyz, dir_update);\n            cv = mix(pd.xyz, cv, dir_update);\n            \n            float update_time = mix(pd.w, iTime, dir_update);\n            // update direction\n            \n            // Get Theta and Phi\n            mat3 rot = mat3(r, u, d);\n            vec3 trf_cv = transpose(rot) * cv;\n            float rcv = length(trf_cv);\n            float phi = asin(trf_cv.y/rcv);\n            float theta = atan(trf_cv.x, trf_cv.z);\n            \n            \n            // rotate lateral angle\n            vec3 dd = rotate(d, u, -eps_sign(theta, ANG_EPS) * iTimeDelta * rad_per_sec * 0.0);\n            d = rotate(d, u, -eps_sign(theta, ANG_EPS) * iTimeDelta * rad_per_sec);\n            // update r\n            r = normalize(cross(d, u));\n            // rotate axial angle\n            d = rotate(d, r, eps_sign(phi, ANG_EPS) * iTimeDelta * rad_per_sec);\n            // update u\n            u = normalize(cross(r, d));\n            \n            // update roll\n            \n            float droll = 0.1 * iTimeDelta * mix(step(ANG_EPS, abs(roll))*-sign(roll), \n                -eps_sign(theta, ANG_EPS), \n                step(ANG_EPS, abs(theta)));\n            \n            float inc_roll = step(abs(roll + droll), PI/6.);\n            roll += droll * inc_roll;\n            u = rotate(u, d, droll * inc_roll);\n            r = normalize(cross(d, u));\n            \n            // update acceleration\n            // add deceleration on turns based on velocity.\n            float accf = clamp(mix(0.25 * acc_factor, acc_factor, v.x / (10.)),0., acc_factor);\n            float acc = accf - v.x*(abs(theta) + abs(phi)); //\n            \n            // stopping distance is relative to current velocity\n            float stop_dist = max(v.x, min_stopping_distance);\n            \n            // This is pushing on breaks to avoid collision.\n            float dcc = -1.5 * (v.x + collision_dirs[0].w);\n            acc = mix(dcc, acc, smoothstep(stop_dist - min_stopping_distance, \n                                           stop_dist + min_stopping_distance, collision_dirs[0].w));\n           \n            \n            vd *= v.x;\n            // drag on current velocity;\n            vd -= d * drag * v.x * v.x * iTimeDelta;\n            \n            // update velocity\n            vd += acc * d * iTimeDelta;\n            \n            v.x = length(vd);\n            vd = v.x * normalize(vd);\n            // update position\n            o += vd * iTimeDelta;\n\n            r = cross(d, u);\n            u = cross(r, d);\n\n            // proximity sensors\n            // the order is ccw starting from the bottom\n            vec4 prox;\n            prox.x = traceGeomHit(o, d + normalize(d - u * ARCTAN_80), vec4(iTime, 0., 0., 0.));\n            prox.y = traceGeomHit(o, d + normalize(d - r * ARCTAN_80), vec4(iTime, 0., 0., 0.));\n            prox.z = traceGeomHit(o, d + normalize(d + u * ARCTAN_80), vec4(iTime, 0., 0., 0.));\n            prox.w = traceGeomHit(o, d + normalize(d + r * ARCTAN_80), vec4(iTime, 0., 0., 0.));\n            \n            \n            // DEBUG VALUES\n            //dvals.x = ppd.x;\n            //dvals.y = ppd.y;\n            //dvals.z = cv.x;\n            //dvals.w = cv.y;\n            //\n            ATF(crd, D_VALS, dvals);\n            ATF(crd, ORIG_POS, vec4(o, 0.));\n            ATF(crd, ORIG_DIR, vec4(d, roll));\n            ATF(crd, ORIG_UP, vec4(u, 0.));\n            ATF(crd, ORIG_VEL, vec4(v));\n            ATF(crd, PREV_DIR, vec4(cv, update_time)); // record the timestamp of previous change\n            ATF(crd, D_HIT_POS, vec4(d_hit_pos, collision_dirs[0].w));\n            ATF(crd, PP_DIR, vec4(ppd, 0.));\n            ATF(crd, PROX_SNS, prox);\n            \n            ATF(crd, FPS_DATA, fps_data);\n            if (iFrame % 20 == 1) {\n              float fps = 20. / (iTime - fps_data.x);\n              ATF(crd, FPS_DATA, vec4(iTime, fps, vec3(0.)));\n            }\n        }\n    }\n    \n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n - Draw the 3D Scene\n*/\n\nvec4 geomI(in vec3 p, in bool high)\n{\n    //p.x += 2.5*sin(p.x*0.01) + 0.1*sin(p.y*2. + iTime*0.5);\n    //p.y += 4.3*cos(p.z*0.1) + 0.1*cos(p.z*2. + iTime*0.75) + 0.2*cos(p.x*2. + iTime*0.37);\n    //float dfx = PULSE_T(mod(iTime, 4.), 2., 2., 2.);\n    float tval = get_gyroid_t(p, iTime);\n    vec3 gf = double_gyroid(p, tval, iTime, float(high));\n    \n    \n    float rf = (high) ? 0.1*fbm(p) : 0.0;//smoothstep(0., 10., (iTime - 20.)*0.5)*noise3(p);\n    gf.x += rf;\n    \n    // create holes\n    float s_len = get_slen(p, iTime, 0.5) ;\n    vec3 r = (p * PI2) / s_len;\n    float ad = max(length(p)*0.025, 0.);\n    float holeGrid = 0.1;\n    vec3 q = r - holeGrid*floor((r+0.5*holeGrid)/holeGrid);\n    float hf = 0.4*holeGrid;//mix(0., .4*holeGrid, smoothstep(0., 1., ad*30.));\n    float f = length(q)- hf;\n    \n    gf.x = max(gf.x, -f);\n    //gf.x *= -1.;\n    return vec4(gf, rf);\n}\n\nvec4 traceI(in vec3 o, in vec3 d) {\n  float t = 0.0;\n  float mint = 10.0;\n\n  vec2 res = vec2(mint, 0.);\n    \n  for (int i=0 ; i < M_ITER ; i++)\n  {\n    vec3 p = o + t*d;\n    \n    res = geomI(p, false).xz;\n    mint = abs(res.x);\n    t += mint;\n\n    if (mint < T_EPS*t || t > FAR) break;\n  }\n  \n   \n  return vec4(t, mint, res.y, res.y);\n}\n\nvec3 normI(in vec3 p, in bool hres)\n{\n    vec3 n;\n    vec2 e = vec2(N_EPS*10., 0.0);\n    \n    n.x = geomI(p + e.xyy, hres).x - geomI(p - e.xyy, hres).x;\n    n.y = geomI(p + e.yxy, hres).x - geomI(p - e.yxy, hres).x;\n    n.z = geomI(p + e.yyx, hres).x - geomI(p - e.yyx, hres).x;\n    \n    return normalize(n);\n}\n\nvec3 normfI(in vec3 p, in bool hres)\n{\n    vec3 n;\n    vec2 e = vec2(N_EPS*10., 0.0);\n    \n    float f = geomI(p, hres).x;\n    n.x = geomI(p + e.xyy, hres).x - f;\n    n.y = geomI(p + e.yxy, hres).x - f;\n    n.z = geomI(p + e.yyx, hres).x - f;\n    \n    return normalize(n);\n}\n\n\n// Fresnel-Shlick\nfloat F(in float _f0, in vec3 _h, in vec3 _v)\n{\n    float hv = max(dot(_h, _v), 0.);\n    float hv1 = pow(1. - hv, 5.);\n    return _f0 + (1. - _f0) * hv1;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/(iResolution.y);\n    \n    float fov = FOV(iTime);\n    \n    vec3 o = TF0(ORIG_POS).xyz;\n    vec3 d = TF0(ORIG_DIR).xyz;\n    vec3 u = TF0(ORIG_UP).xyz;\n    float roll = TF0(ORIG_DIR).w; // \n    \n    uv = ROT2D(uv, roll);\n    vec2 duv = uv;\n    \n    // make this line as macro/function\n    CURVE_UV(duv);\n    \n    vec3 od = normalize(vec3(fov*(duv),-1.));\n    vec3 light = normalize(vec3(1., -1., -1.));\n    \n    mat3 view;\n\n    vec3 col;\n    vec3 bckcol = vec3(0.);\n    vec4 ccol = vec4(0.);\n    \n    float depth = 0.0;\n\n#ifdef HUD_ONLY\n    float frame = hud_frame(uv, ratio, vec3(HUD_DIM * vec2(ratio, 1.), 0.615));\n#else\n    // in this case I care only about the top and bottom cut\n    float frame = hud_frame(uv, ratio,\n                        vec3(HUD_DIM * vec2(ratio*10.5, 1.1), 100.815));\n    float sm_col = smoothstep(0.001,-0.001, frame);\n#endif    \n    if (frame > 0.001)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 r = cross(d, -u);\n    d = mat3(cross(d, u), u, -d) * od;\n    //d = camera(o, d, target, view);\n\n      vec4 g3res = traceI(o, d);\n      // hit position to gyroid.\n      vec3 totp = o + g3res.x * d;\n\n      vec4 mtl = geomI(o + g3res.x * d, true);\n\n      float inside = step(0.1, mtl.y);\n\n      vec3 gcol = mix(INV_TUNNEL0_CLR, INV_TUNNEL1_CLR, step(0.1, mtl.z));\n\n      // differentiate inside/outside\n      gcol *= (1. - 0.5*inside);\n\n      depth += g3res.x;\n      vec3 n3gyr = normI(totp, false);\n\n      gcol *= (1. + 0.5*noise(length(0.25*totp)));\n      gcol = mix(vec3(1.), gcol, 0.9 + 0.1*noise(length(totp) + 23.11));\n\n      // bright one of the two gyroids.\n      gcol *= (1. + 2.*step(0.1, mtl.z));\n\n      // light direction towards the cube.\n      vec3 lpos0 = (o - 0.5*r);\n      vec3 lpos1 = (o - 0.5*r);\n      vec3 ldir = normalize(totp - lpos0);\n\n      vec3 rfl = reflect(d, n3gyr);\n      vec3 h = normalize(ldir - d);\n      vec3 spec = vec3(1., 0.85, 0.8)*max(dot(rfl, -ldir), 0.) + F(0.15, h, d);\n      vec3 acol = (0.1 + max(0.9*dot(n3gyr, -ldir), 0.0)) + spec;\n\n      ldir = normalize(totp - lpos1);\n\n      rfl = reflect(d, n3gyr);\n      h = normalize(ldir - d);\n      spec = vec3(1., 0.85, 0.8)*max(dot(rfl, -ldir), 0.) + F(0.15, h, d);\n\n      vec3 acol2 = (0.1 + max(0.9*dot(n3gyr, -ldir), 0.0)) + spec;\n      //acol2 *= 2.*PI2/pow(length(lpos1 - totp), 2.);\n      //acol2 *= abs(dot(normalize(totp), d));\n      gcol *= 0.35*(acol + acol2);\n\n      bckcol += gcol;\n    \n    col = mix(bckcol, ccol.rgb, pow(clamp(1.02*ccol.a, 0., 1.), 2.));\n    col = col.bgr;\n    col = max(vec3(0.), col)*sm_col;\n    //col = mix(col, col.bgr, _ANIMATION(11));\n    \n    //col = mix(col, tcol.rgb, (step(0.1, ccol.a) - step(0.75, ccol.a)) * 0.5 * smoothstep(1.2, 1.8, length(col - tcol.rgb)) );\n    // Output to screen\n    fragColor = vec4(col, depth);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/* Motion Blur */\n\n// Get projected velocity vector\nvec2 projectVelocityVector(in vec2 _uv, in float _depth, in float _vel) {\n    vec3 o = normalize(TF1(ORIG_POS).xyz);\n    vec3 d = normalize(TF1(ORIG_DIR).xyz);\n    vec3 u = normalize(TF1(ORIG_UP).xyz);\n    \n    // set the camera to match rendering (Buffer C)\n    float roll = TF1(ORIG_DIR).w; \n    \n    vec2 duv = _uv;\n    duv = ROT2D(duv, roll);\n    \n    float fov = FOV(iTime);\n\n    CURVE_UV(duv);\n    \n    vec3 od = normalize(vec3(fov*duv,-1.));\n    \n    vec3 r = normalize(cross(d, -u));\n    od = normalize(mat3(cross(d, u), u, -d) * od);\n    \n    vec3 p = o + od * _depth;\n    \n    // This is the point on 3D to project\n    vec3 p2 = p + d * _vel * 0.1 * fov;\n    \n    mat4 view = mat4(r.xyz, 0.,\n                -u.xyz, 0.,\n                d.xyz, 0.,\n                vec3(0.),  1.);\n                \n    mat4 proj = makeSymPerspective(1., 400.2, atan(fov),  iResolution.x/iResolution.y);\n    view = transpose(translate(o) * (view));\n    \n    vec4 ep2 = view * vec4(p2, 1.);\n    vec4 op2 = (proj) * ep2;\n    op2.xyz /= op2.w;\n    \n    // unroll\n    op2.xy = ROT2D(op2.xy, -roll);\n    \n    // remove curvature\n    DECURVE_UV(op2.xy);\n    return vec2(op2.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ruv = fragCoord / iResolution.xy;\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    float vel = TF1(ORIG_VEL).x;\n    vec4 col = TX0(ruv);\n    vec4 dmix = TX2(ruv);\n    vec2 pp;\n\n// The velocity vector needs to be inverted to open it.\n// And then need to handle the black (outside of view areas)\n#ifndef EXPLORE_OUTSIDE\n   pp = projectVelocityVector(uv, vel, col.w);\n\n   // [-r,r]x[-1,1] -> [0, 1]x[0, 1]\n   vec2 pruv = 0.5 + 0.5 * (pp * iResolution.y) / iResolution.xy;\n\n   vec2 ang_uv = vec2(atan((pruv - ruv).y, (pruv - ruv).x), length(pruv - ruv));\n   float salt1 = UNIT2ORIG(hash(ang_uv.x * 11.3 + ang_uv.y + 7.3));\n   float salt2 = UNIT2ORIG(hash(ang_uv.x * 7.9 + ang_uv.y + 1.7));\n   float salt3 = UNIT2ORIG(hash(ang_uv.x * 3.71 + ang_uv.y * 3.13));\n   float salt4 = UNIT2ORIG(hash(ang_uv.x * 5.37 + ang_uv.y * 12.17));\n   float salt5 = UNIT2ORIG(hash(ang_uv.x * 9.23 + ang_uv.y * 11.1));\n   \n\n   col.rgb = mix(col.rgb,\n                 0.2 * (TX0(mix(ruv, pruv, 0.1 + 0.1 * salt1)).rgb + \n                         TX0(mix(ruv, pruv, 0.2 + 0.1 * salt2)).rgb +\n                         TX0(mix(ruv, pruv, 0.3 + 0.1 * salt3)).rgb +\n                         TX0(mix(ruv, pruv, 0.4 + 0.1 * salt4)).rgb +\n                         TX0(mix(ruv, pruv, 0.5 + 0.1 * salt5)).rgb),\n                 smoothstep(2., 10., vel));\n#endif\n    \n    fragColor = vec4(col);\n}","name":"Buffer D","description":"","type":"buffer"}]}