{"ver":"0.1","info":{"id":"stSBWz","date":"1652014842","viewed":186,"name":"A Klein bottle in the forest","username":"Observer","description":"Up to 12 iterations. Using a Stack-construct to overcome the lack of recursion. Check out the SHOWSECTION macro!","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["reflection","refraction","kleinbottle","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define SHOWSECTION\n//#define FLOORPLANE\n\n#define ZERO (min(iFrame, 0))\n\n// Wall thickness of the bottle\nconst float WALL = 0.006;\nconst int PTUBE = 10;\nconst vec4[] tube = vec4[PTUBE] (\n    // TUBE - rendered as sphere with diameter w swept along a curve\n    // xy: Curve uv, z: curvature, w: tube diameter\n    vec4(0.0,  0.06,  0.0,  0.15 + WALL*2.), \n    vec4(0.0,  0.21, 10.0,  0.11), \n    vec4(0.07, 0.35,  0.20, 0.07), \n    vec4(0.19, 0.43,  0.68, 0.06), \n    vec4(0.31, 0.52, -0.63, 0.06), \n    vec4(0.39, 0.70, -0.28, 0.07), \n    vec4(0.32, 0.91, -0.28, 0.07), \n    vec4(0.12, 0.95, -0.19, 0.08), \n    vec4(0.01, 0.81, -0.19, 0.11), \n    vec4(0.0,  0.70, -0.62, 0.135)\n);    \n\nconst int PVASE = 6;\nconst vec3[] vase = vec3[PVASE] (\n    // VASE - rendered as a surface of revolution\n    // xy: Curve uv, z: curvature\n    vec3(0.0672, 0.7036, 0.0), \n    vec3(0.0876, 0.5883, -1.0277), \n    vec3(0.146,  0.4642, -0.292), \n    vec3(0.2453, 0.2847, 0.5212), \n    vec3(0.1956, 0.0292, 0.2635), \n    vec3(0.0759, 0.0599, 0.0672)\n);\n\nconst vec3 bboxTubeMin = vec3(-0.076, -0.07, 0.0599);\nconst vec3 bboxTubeMax = vec3(0.424, 0.07, 1.0);\nconst vec3 bboxVaseMin = vec3(-0.265, -0.265, -0.04);\nconst vec3 bboxVaseMax = vec3(0.265, 0.265, 0.7036);\nconst vec3 bboxMin = min(bboxTubeMin, bboxVaseMin);\nconst vec3 bboxMax = max(bboxTubeMax, bboxVaseMax);\n\nconst vec3 BOTTLEPOS = vec3(0.0, 0.0, 0.4);\n\nconst float PI = acos(0.0) * 2.0;\nconst float REFL = 0.3;\nconst float REFR = 0.8;\nconst float IOR = 1.1;\nconst float JITTER = 0.0;\nconst int MAXITER = 12;\n\nconst vec3 SUN_POS = vec3(-4.0, 4.0, 3.0);\n\nvec3[PTUBE] precalc;\n\nstruct TubeDist {\n    float dist;\n    float radius;\n    vec2 pos;\n};\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Camera{\n    vec3 from;\n    vec3 at;\n    vec3 up;\n\n    vec3 look;\n    vec3 hor;\n    vec3 ver;\n};\n\nCamera GetCamera() {\n    Camera camera;\n    \n    float dst = 1.5;\n    vec2 m = iMouse.xy != vec2(0.) && iMouse.z >= 0.\n        ? (2.0 * iMouse.xy / iResolution.xy - 1.0) * PI\n        : vec2(iTime * 0.1 + 1.1, 1.2);\n    camera.from = vec3(\n        dst * cos(m.x) * cos(m.y * 0.5),\n        dst * sin(m.x) * cos(m.y * 0.5),\n        0.2 + dst * sin(m.y * 0.5)\n    );\n    camera.at = vec3(0.0, 0.0, 1.0);\n    camera.up = vec3(0.0, 0.0, 1.0);\n    float aper = 50.0;\n    float size = tan(aper * PI / 180.0);\n    camera.look = normalize(camera.at - camera.from);\n    camera.hor = cross(camera.look, camera.up);\n    camera.ver = cross(camera.hor, camera.look);\n    camera.look /= size;\n\n    return camera;\n}\n\nRay GetCameraRay(in Camera camera, in vec2 uv) {\n    Ray ray;\n    ray.ro = camera.from;\n    ray.rd = normalize(camera.look + uv.x * camera.hor + uv.y * camera.ver);\n    return ray;\n}\n\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Distance to 2D arc-polyline\n// xy: closest position on polyline, z: distance, w: radius\nvec4 distTube(in vec2 uv)\n{\n    vec4 a = tube[0];\n    float dist = 100.0;\n    vec2 pos = vec2(0.);\n    float radius = 0.;\n    for (int n = ZERO + 1; n < PTUBE; n++)\n    {\n        // Calculate distance to arc between point a and b\n        vec4 b = tube[n];\n\n        // Having radius r (sign: the side of arc)\n        float r = b.z;\n\n        // point c: center between a and b\n        vec2 c = 0.5 * (a.xy + b.xy);\n\n        vec2 v1 = b.xy - a.xy;\n        vec2 v2 = sign(r) * vec2(v1.y, -v1.x);\n        float d = length(v1);\n        float l = sqrt(r * r - 0.25 * d * d);\n\n        // Center of the arc-circle\n        vec2 v3 = v2 * l / d;\n        vec2 s = c + v3;\n        vec2 v4 = uv - s.xy;\n        float f1 = dot(-v3, v2) / dot(v4, v2);\n        vec2 p = s.xy + f1 * v4;\n        vec2 v5 = p - c;\n        float f2 = length(v5) / d * 2.0;\n\n        float d1 = sign(r)*length(v4) - r;\n        if (d1 < dist && f2 <= 1.1 && f1 >= 0.)\n        {\n            float f3 = length(p - a.xy) / d;\n            dist = d1;\n            radius = mix(a.w, b.w, f3) * 0.5;\n            pos = s.xy + normalize(v4) * abs(r);\n        }\n        a = b;\n    }\n    return vec4(pos, dist, radius);\n}\n\n// Distance to 2D arc-polyline\n// xy: closest position on polyline, z: distance\nvec3 distVase(in vec2 uv)\n{\n    vec3 a = vase[0];\n    float dist = 100.0;\n    vec2 pos = vec2(0.);\n    for (int n = 1; n < PVASE; n++)\n    {\n        // Calculate distance to arc between point a and b\n        vec3 b = vase[n];\n\n        // Having radius r (sign: the side of arc)\n        float r = b.z;\n\n        // point c: center between a and b\n        vec2 c = 0.5 * (a.xy + b.xy);\n\n        vec2 v1 = b.xy - a.xy;\n        vec2 v2 = sign(r) * vec2(v1.y, -v1.x);\n        float d = length(v1);\n        float l = sqrt(r * r - 0.25 * d * d);\n\n        // Center of the arc-circle\n        vec2 v3 = v2 * l / d;\n        vec2 s = c + v3;\n        vec2 v4 = uv - s.xy;\n        float f1 = dot(-v3, v2) / dot(v4, v2);\n        vec2 p = s.xy + f1 * v4;\n        vec2 v5 = p - c;\n        float f2 = length(v5) / d * 2.0;\n\n        float d1 = sign(r)*length(v4) - r;\n        if (d1 < dist && f2 <= 1.1 && f1 >= 0.)\n        {\n            float f3 = length(p - a.xy) / d;\n            dist = d1;\n            pos = s.xy + normalize(v4) * abs(r);\n        }\n        a = b;\n    }\n    return vec3(pos, dist);\n}\n\n\nfloat GetVaseDist(in vec3 pos) \n{\n\tvec2 uv = vec2(length(pos.xy), pos.z);\n\tvec3 dst = distVase(uv);\n    \n    float d = dst.z;\n    d = max(-d-WALL, d);\n    \n    // Cut out tube opening\n    float ds = sdSphere (pos - vec3(0.17, 0., 0.42), 0.034);\n    return max(d, -ds);\n}\n\nfloat GetTubeDist(in vec3 pos) \n{\n\tvec2 uv = pos.xz;\n\tvec4 dst = distTube(uv);\n    vec3 p = vec3(dst.x, 0.0, dst.y);\n    vec3 v = pos - p;\n\n    float d = length(v);\n    float r1 = dst.w;\n    float r2 = r1 - WALL;\n    return max(r2 - d, d - r1); \n}\n\n//------------------------------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI(vec2 d1, vec2 d2)\n{\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2(1e10, 0.0);\n\n\tvec3 posVase = pos - BOTTLEPOS;\n    if(sdBox(posVase - bboxTubeMin, bboxTubeMax - bboxTubeMin) < res.x)\n    {\n\t\tres = opU(res, vec2(GetTubeDist(posVase), 3.9));\n    }\n    if(sdBox(posVase - bboxVaseMin, bboxVaseMax - bboxVaseMin) < res.x)\n    {\n\t\tres = opU(res, vec2(GetVaseDist(posVase), 3.9));\n    }\n    \n    #ifdef SHOWSECTION\n    res = opI(res, vec2(sdBox(posVase - vec3(0.3, -0.3, -0.1), vec3(0.6, 0.31, 1.2)), 4.7));\n    #endif\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast(in Ray ray)\n{\n    vec2 res = vec2(-1.0, -1.0);\n\n    float tmin = 0.03;\n    float tmax = 4.0;\n\n#ifdef FLOORPLANE\n    // raytrace floor plane\n    float tp1 = (-2.0-ray.ro.z) / ray.rd.z;\n    if (tp1 > tmin)\n    {\n        tmax = min(tmax, tp1);\n        res = vec2(tp1, 1.0);\n    }\n#endif    \n   \n    // raymarch Klein bottle\n    vec2 tb = iBox( ray.ro - bboxMin - BOTTLEPOS, ray.rd, bboxMax-bboxMin );\n    if( tb.x < tb.y && tb.y > 0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x, tmin);\n        tmax = min(tb.y, tmax);\n\n        float t = tmin;\n        for(int i = min(0, iFrame); i < 80 && t < tmax; i++)\n        {\n            vec2 h = map(ray.ro + ray.rd * t);\n            if(abs(h.x)<(0.001*t))\n            { \n                res = vec2(t, h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773*0.0005;\n    return normalize(e.xyy * map(pos + e.xyy).x + \n\t\t\t\t\t e.yyx * map(pos + e.yyx).x + \n\t\t\t\t\t e.yxy * map(pos + e.yxy).x + \n\t\t\t\t\t e.xxx * map(pos + e.xxx).x);\n}\n\n\nfloat fresnel(vec3 l, vec3 n, float eta1, float eta2)\n{\n    float c = abs(dot(l, n));\n    float g = sqrt((eta2 * eta2) / (eta1 * eta1) - 1.0 + c * c);\n    float gpc = g + c;\n    float gmc = g - c;\n    float f1 = c * gpc - 1.0;\n    float f2 = c * gmc + 1.0;\n    \n    return 0.5 * (gmc * gmc) / (gpc * gpc) * (1.0 + (f1 * f1) / (f2 * f2));\n}\n\nstruct StackItem \n{\n    Ray ray;\n    bool inside;\n    float factor;\n    vec3 col;\n};\n\nvec3 render(in Ray ray)\n{ \n    StackItem[MAXITER] stack;\n    int sw = 0;   // Stack write index\n    int sr = 0;   // Stack read index\n\n    vec3 col1; \n\n    // Write the first stack item\n    StackItem item;\n    item.inside = false;\n    item.ray = ray;\n    item.factor = 1.0;\n    stack[sw++] = item;\n    \n    do\n    {\n        // Read stack item\n        StackItem item = stack[sr], newItem;\n        item.col = vec3(0.0);\n        vec2 res = raycast(item.ray);\n        float t = res.x;\n        float m = res.y;\n        if(m > -0.5)\n        {\n            vec3 pos = item.ray.ro + t * item.ray.rd;\n            if(m < 1.5)\n            {\n                // Plane\n                vec3 nor =vec3(0.0, 0.0, 1.0);\n                item.col = mix(\n                    vec3(0.2, 0.4, 0.3), \n                    vec3(0.5, 0.7, 0.4), \n                    0.5 + 0.5 * (1.0 / (t / 10.0)) * vec3(smoothstep(-0.001, 0.001, sin(pos.x * PI / 2.0) * sin(pos.y * PI / 2.0)))\n                );\n                newItem.ray.ro = pos;\n                newItem.ray.rd = reflect(item.ray.rd, nor);\n                newItem.inside = item.inside;\n                newItem.factor = 0.1;\n                stack[sw++] = newItem;\n            }\n            else\n            {\n                vec3 nor = calcNormal(pos);\n                \n                vec3 lig = normalize(SUN_POS - item.ray.ro);\n                item.col = vec3(0.0, 0.0, 0.1) * max(0., dot(nor, lig));\n                \n                if (!item.inside)    // From air to glass\n                {\n                    float f = fresnel(-item.ray.rd, nor, 1.0, IOR);\n                    vec3 refr = refract(item.ray.rd, nor, IOR);\n                    newItem.ray.ro = pos;\n                    newItem.ray.rd = refr;\n                    newItem.factor = (1.0 - f) * REFR;\n                    newItem.inside = true;\n                    stack[sw++] = newItem;\n                    \n                    newItem.ray.ro = pos;\n                    newItem.ray.rd = reflect(ray.rd, nor);\n                    newItem.factor = f * REFR + REFL;\n                    newItem.inside = false;\n                    \n                    stack[sw++] = newItem;\n                }\n                else  // From glass to air\n                {\n                    vec3 refr = refract(item.ray.rd, nor, 1. / IOR);\n                    if (length(refr) < 0.1)\n                    {\n                        // Total inner reflection\n                        newItem.ray.ro = pos;\n                        newItem.ray.rd = reflect(ray.rd, nor);\n                        newItem.factor = REFR;\n                        newItem.inside = true; // We stay inside\n                        stack[sw++] = newItem;\n                    }\n                    else\n                    {\n                        newItem.ray.ro = pos;\n                        newItem.ray.rd = refr;\n                        newItem.factor = REFR;\n                        newItem.inside = false;\n                        stack[sw++] = newItem;\n                    }\n                }\n            }\n        }\n        else\n        {\n            item.col = texture(iChannel0, item.ray.rd.xzy).rgb;\n            if (sr > 0) \n            {\n                float sun = 0.;\n                vec3 lig = normalize(SUN_POS - item.ray.ro);\n                sun = pow(max(0., dot(item.ray.rd, lig)), 200.) * 10.0;\n                item.col += vec3(1.0, .96, .43) * sun * item.col;\n            }\n        }\n        stack[sr++] = item;\n    }\n    while (sw < MAXITER && sr < sw);\n\n    vec3 col = vec3(0.);\n    for (int n = sr - 1; n >= 0; n--)\n    {\n        col += stack[n].factor * stack[n].col;\n    }\n    \n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    Camera camera = GetCamera();\n    Ray ray = GetCameraRay(camera, uv);\n    vec3 color = clamp(render(ray), vec3(0.0), vec3(1.0));\n\n    /*\n    uv = fragCoord.x < iResolution.x * 0.5\n        ? fragCoord * 1.4 / iResolution.yy - vec2(0.6, 0.2)\n        : (fragCoord + iMouse.xy * 4.0 - vec2(1400., 500.)) * 0.2 / iResolution.yy;\n\n    vec3 pos = vec3(uv.x, 0., uv.y);\n    float d = GetVaseDist(vec3(pos));\n    color.g += 1.0 / (abs(d) * 1000.0);\n    d = GetTubeDist(pos);\n    color.g += 1.0 / (abs(d) * 1000.0);\n    d = GetTubeDist(pos);\n    color.g += 1.0 / (abs(d) * 1000.0);\n    */\n \n \t// Gamma correction\n\tcolor = pow(color, vec3(1./2.2));\n\t\n    fragColor.rgb = color;\n}","name":"Image","description":"","type":"image"}]}