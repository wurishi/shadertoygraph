{"ver":"0.1","info":{"id":"MXBfDz","date":"1729328702","viewed":81,"name":"Refract_RMarch_test","username":"sobayaOnJupiter","description":"sobaya special","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sobayaspecial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.141592;\n\nvec3 ex = vec3(1.0,0.0,0.0);\nvec3 ey = vec3(0.0,1.0,0.0);\nvec3 ez = vec3(0.0,0.0,1.0);\nvec3 one3 = vec3(1.0);\n\nfloat atan2(in float y, in float x){\n    return x == 0.0 ? sign(y)*PI/2.0 : atan(y, x);\n}\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\nvec3 rotate3d (vec3 v, vec3 n, float a) {\n\treturn v * cos(a) + cross(n, v) * sin(a) + n * dot(n, v) * (1. - cos(a));\n}\n\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n// 球の距離関数\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat shapeSDF (vec3 p){\n    vec3 center0 = vec3(sin(iTime*1.45), sin(iTime*1.61), sin(iTime*1.77)*0.4)*2.0;\n    vec3 center1 = vec3(sin(iTime*1.85), sin(iTime*1.71), sin(iTime*1.37)*0.4)*2.5;\n    return smin(sphereSDF(p - center0, 2.0), sphereSDF(p-center1, 2.0), 0.2);\n}\n\nfloat signedSDF(vec3 p, int isInside){\n    return shapeSDF(p) * (isInside==1 ? -1.0 : 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // カメラの設定\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // カメラの設定\n    vec3 target = vec3(0.0, 0.0, 0.0);      // カメラが注目するターゲット位置\n    vec3 cp = vec3(0.0, 0.0, -15.0);       // カメラの位置\n    vec3 cd = normalize(target - cp);       // カメラの視線方向\n    vec3 cs = -normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n    vec3 cu = normalize(cross(cd, cs));     // 上方向\n    \n    float fov = 1.5; // 視野角\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); // レイの方向\n    \n    // レイマーチングのループ\n    //float t = 0.0;\n    vec3 currPos = cp;\n    int maxSteps = 180;\n    bool hit = false;\n    float maxDistance = 1000.0;\n    float epsilon = 0.001;\n    vec3 color = vec3(0.0);\n    int inside = 0;\n    \n    for (int i = 0; i < maxSteps; i++) {\n        //vec3 currPos = cp + t * rd;\n        float distWire = sdBoxFrame(rotate3d(currPos-vec3(0.0,0.0,8.0),\n            vec3(cos(iTime),0.0,sin(iTime)),iTime), vec3(1.0) +2.0* (0.5+0.5*sin(2.*iTime)), 0.1 ) ;\n        \n        if (distWire < epsilon) {\n            hit = true;\n            color += vec3(0.6,0.3,0.0);\n            break;\n        }\n        \n        float distSigned = signedSDF(currPos, inside);\n        \n        vec3 normalSigned = vec3(signedSDF(currPos+ex*0.01,inside) - distSigned,\n            signedSDF(currPos+ey*0.01,inside) - distSigned,\n            signedSDF(currPos+ez*0.01,inside) - distSigned);\n           \n        normalSigned = normalize(normalSigned);\n        \n        if (distSigned < epsilon && (dot(normalSigned,-rd)>0.1)) {\n            vec3 baseColor = vec3(0.0, 0.5, 0.5); //(normalSigned*0.5 + vec3(0.5))\n            color += 0.8* baseColor * (1.0-abs(dot(normalize(rd),normalSigned)));\n            rd = normalize(refract(rd,normalSigned,0.8));\n            currPos += rd*0.1;\n            inside = 1-inside;\n        }\n        \n        currPos += min(distWire,distSigned) * rd;\n        if (length(currPos-cp) > maxDistance) break;\n    }\n    \n    // フラグメントカラーを設定\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}