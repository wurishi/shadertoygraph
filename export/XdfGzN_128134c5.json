{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"music","id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const vec3 camera_location = vec3(0.0, 0.0, -1.8);\nvec3 light_direction = normalize(vec3(-0.2, 0.5, -1.0));\nvec3 ambient_light = vec3(0.3, 0.3, 0.35);\nfloat zoom = 1.5;\nfloat perspective = 0.45;\nfloat march_step = 1.0;\nfloat minimum_distance = 0.001;\nfloat camera_distance = length(camera_location);\nfloat shadow_bias = 0.1;\nfloat shadow_penumbra_factor = 256.0;\n\nfloat cube(vec3 v, vec3 size, vec3 position) {\n\tvec3 distance = abs(v + position) - size;\n\tvec3 distance_clamped = max(distance, 0.0);\n\treturn length(distance_clamped) - 0.05;\n}\n\nfloat sphere(vec3 v, float radius, vec3 position) {\n\treturn length(v + position) - radius;\n}\n\nfloat scene(vec3 v) {\n\tfloat distance = camera_distance * 100.0;\n\tdistance = min(distance, cube(v, vec3(2.0, 2.0, 0.3), vec3(0.0, 0.0, -1.0)));\n\t\n\tdistance = min(distance, cube(v, vec3(0.35, 0.35, 0.35), vec3(0.0, 0.0, 0.7)));\n\t\n\tdistance = max(distance, -sphere(v, 0.50, vec3(0.0, 0.0, 0.7)));\n\t\n\tdistance = min(distance, sphere(v, 0.25, vec3(sin(iTime) * 0.6, 0.0, 0.7)));\n\tdistance = min(distance, sphere(v, 0.25, vec3(0.0, cos(iTime) * 0.6, 0.7)));\n\t\n\treturn distance;\n}\n\n\nmat3 axis_x_rotation_matrix(float angle) {\n\treturn mat3(1.0, 0.0, 0.0,\n\t\t\t\t0.0, cos(angle), -sin(angle),\n\t\t\t\t0.0, sin(angle), cos(angle));\n}\n\nmat3 axis_y_rotation_matrix(float angle) {\n\treturn mat3(cos(angle), 0.0, sin(angle),\n\t\t\t\t0.0,        1.0, 0.0,\n\t\t\t\t-sin(angle), 0.0, cos(angle));\n}\n\nvec3 raymarch(vec3 ray, vec3 view_direction, float cube_size) {\n\t\n\tvec3 output_color = vec3(0.0, 0.0, 0.0);\n\tfloat distance = minimum_distance * 2.0;\n\t\n\tfor (int iteration = 0; iteration < 100; ++iteration) {\n\t\tdistance = scene(ray);\n\t\tif (distance < minimum_distance) {\n\t\t\tbreak;\n\t\t}\n\t\tray += view_direction * march_step * distance;\n\t}\n\t\n\tif (distance < minimum_distance) {\n\t\tvec3 epsilon = vec3(0.01,0.0,0.0);\n\t\tvec3 normal = normalize(vec3(\n\t\t\tscene(ray + epsilon.xyy) - scene(ray - epsilon.xyy),\n\t\t\tscene(ray + epsilon.yxy) - scene(ray - epsilon.yxy),\n\t\t\tscene(ray + epsilon.yyx) - scene(ray - epsilon.yyx)\n\t\t));\n\t\t\n\t\tfloat shadow_value = 1.0;\n\t\t\n\t\tray += light_direction * march_step * shadow_bias;\n\t\tfor (int iteration = 0; iteration < 100; ++iteration) {\n\t\t\tdistance = scene(ray);\n\t\t\tif (distance < minimum_distance) {\n\t\t\t\tshadow_value = 0.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tshadow_value = min( shadow_value, shadow_penumbra_factor * distance / float(iteration) );\n\t\t\tray += light_direction * march_step * distance;\n\t\t}\n\t\t\n\t\tfloat light_contribution = max(0.0, dot(normal, light_direction)) * shadow_value;\n\t\tfloat specular_light_contribution = pow(max(0.0, dot(reflect(view_direction, normal), light_direction)), 64.0) * shadow_value;\n\t\toutput_color = vec3(1.0, 1.0, 1.0) * light_contribution + ambient_light + specular_light_contribution;\n\t}\n\t\n\treturn output_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 bass_sound_sample = texture(iChannel0, vec2(0.1,0.1));\n\tvec4 mid_sound_sample = texture(iChannel0, vec2(0.5,0.1));\n\tvec4 treble_sound_sample = texture(iChannel0, vec2(0.9,0.1));\n\tvec2 screen_space_coords = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tscreen_space_coords.x *= aspect_ratio;\n\tscreen_space_coords.xy /= zoom;\n\t\n\tvec2 screen_space_mouse_coords = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n\tscreen_space_mouse_coords.x *= aspect_ratio;\n\tscreen_space_mouse_coords.y = -screen_space_mouse_coords.y;\n\n\tvec3 ray = vec3(screen_space_coords.xy, 0.0) + camera_location;\n\tmat3 rotation = axis_y_rotation_matrix(screen_space_mouse_coords.x);\n\trotation *= axis_x_rotation_matrix(screen_space_mouse_coords.y);\n\tvec3 view_direction = normalize(vec3(screen_space_coords.x * perspective, screen_space_coords.y * perspective, 1.0));\n\tlight_direction *= rotation;\n\tray *= rotation;\n\tview_direction *= rotation;\n\t\n\tvec3 light_contribution = raymarch(ray, view_direction, 0.50);\n\tvec3 output_color = vec3(bass_sound_sample.r, mid_sound_sample.r, treble_sound_sample.r) * light_contribution;\n    fragColor = vec4(output_color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdfGzN","date":"1363369806","viewed":269,"name":":V","username":"Ufinii","description":"Use mouse to rotate the scene","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarched"],"hasliked":0,"parentid":"","parentname":""}}