{"ver":"0.1","info":{"id":"mdcyWs","date":"1696255947","viewed":43,"name":"Synthese_image","username":"hawafof","description":"Ce shader est mon TP de sythèse d'image en M1 Informatique 2023-2024","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["synthese"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Ellipsoid {\n    vec3 c;     // Center\n    vec3 r;     // Rayons sur les trois axes (x, y, z)\n    int i;      // Identifiant de texture\n};\n\nstruct Box {\n    vec3 minCorner;  // Coin minimum (coin en bas à gauche)\n    vec3 maxCorner;  // Coin maximum (coin en haut à droite)\n    int i;           // Identifiant de texture\n};\n\nstruct Disk {\n    vec3 c; // Center\n    vec3 n; // Normal\n    float r;  // Radius\n    int i;// Texture Id\n};\n\nstruct Cylinder {\n    vec3 center;   // Centre du cylindre\n    float radius;  // Rayon du cylindre\n    vec3 height;  // Hauteur du cylindre\n    int i;         // Identifiant de texture\n};\n\nstruct Capsule {\n    vec3 start;    // Point de départ du cylindre\n    vec3 end;      // Point d'arrêt du cylindre\n    float radius;  // Rayon de la capsule\n    int i;         // Identifiant de texture\n};\n\nstruct Torus {\n    vec3 center;      // Centre du tore\n    float majorRadius; // Grand rayon (distance du centre au centre du tube)\n    float minorRadius; // Petit rayon (rayon du tube)\n    int i;            // Identifiant de texture\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return Material(vec3(.8,.5,.4));\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col);\n    }\n    return Material(vec3(0));\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\n// Ellipsoid intersection\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    vec3 oc = ray.o - ellipsoid.c;\n    vec3 invR = 1.0 / ellipsoid.r;  // Inverse des rayons sur les trois axes\n\n    // Calcul des coefficients de l'équation quadratique\n    float a = dot(ray.d * invR, ray.d * invR);\n    float b = 2.0 * dot(oc * invR, ray.d * invR);\n    float c = dot(oc * invR, oc * invR) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Sélectionne la solution la plus proche (la plus petite t > 0)\n        float t = (t1 > 0.0) ? t1 : t2;\n\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            // La normale de l'ellipsoïde est simplement la normale à la surface de la sphère unitaire\n            x = Hit(t, normalize(p - ellipsoid.c), ellipsoid.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Box intersection\nbool IntersectBox(Ray ray, Box box, out Hit x) {\n    // Calcul des paramètres d'intersection pour chaque plan de la boîte\n    float t1 = (box.minCorner.x - ray.o.x) / ray.d.x;\n    float t2 = (box.maxCorner.x - ray.o.x) / ray.d.x;\n    float t3 = (box.minCorner.y - ray.o.y) / ray.d.y;\n    float t4 = (box.maxCorner.y - ray.o.y) / ray.d.y;\n    float t5 = (box.minCorner.z - ray.o.z) / ray.d.z;\n    float t6 = (box.maxCorner.z - ray.o.z) / ray.d.z;\n\n    // Trouver les valeurs min et max des paramètres d'intersection\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    // Vérifier si l'intervalle d'intersection est valide\n    if (tmax >= tmin && tmax >= 0.0) {\n        // L'intersection est valide\n        vec3 p = Point(ray, tmin);  // Utiliser tmin pour obtenir le point d'intersection\n        vec3 normal = vec3(1.0);   // La normale dépendra de quel plan a été intersecté, vous devez la calculer en conséquence\n        // Remarque : Les normales des faces de la boîte doivent être calculées ici en fonction de l'intersection\n        // L'identifiant de texture est box.i\n\n        x = Hit(tmin, normal, box.i);\n        return true;\n    }\n\n    return false;\n}\n\nbool IntersectDisk(Ray ray,Disk d ,out Hit x){\n    float t=-dot(ray.o-d.c,d.n)/dot(ray.d,d.n);\n    if(t>0.)\n    {\n        vec3 p=Point(ray,t);\n        if(distance(p, d.c) <= d.r){\n            x=Hit(t,d.n,d.i);\n            return true;\n        }\n        return false;\n    }\n    return false;\n}\n\nbool intersectCylinder(Ray ray, Cylinder cylinder, out Hit hit){\n    \n    vec3 oc = ray.o - cylinder.center;\n    vec2 dxy = ray.d.xy;\n\n    float a=ray.d.x*ray.d.x+ray.d.y*ray.d.y;\n    float b=2.*(oc.x*ray.d.x+oc.y*ray.d.y);\n    float c=oc.x*oc.x+oc.y*oc.y-cylinder.radius*cylinder.radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        \n        float t = min(t1,t2);\n        \n        float x = ray.o.x + t * ray.d.x;\n\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            if(p.z>cylinder.center.z && p.z<cylinder.height.z) {\n\n                vec3 u=cylinder.height-cylinder.center;\n                vec3 q=cylinder.center+(dot(u,p-cylinder.center)/dot(u,u))*u;\n                vec3 n=normalize(p-q);\n\n                hit.t = t;\n                hit.n = n;\n                hit.i = cylinder.i;\n\n                return true;\n            }\n        }\n        if (ray.d.z > 0.0) {\n\n            Disk disk = Disk(cylinder.center, vec3(0., 0., -1), cylinder.radius, cylinder.i);\n\n            if(IntersectDisk(ray, disk, hit)){\n                return true;\n            }\n        }\n        else {\n\n            Disk disk = Disk(cylinder.height, vec3(0., 0., 1), cylinder.radius, cylinder.i);\n\n            if(IntersectDisk(ray, disk, hit)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// Cylinder intersection with closed ends\nbool IntersectCylinderClosed(Ray ray, Cylinder cylinder, out Hit x) {\n    // Les coordonnées du centre du cylindre\n    vec3 c = cylinder.center;\n    // Rayon du cylindre\n    float r = cylinder.radius;\n    // Hauteur du cylindre\n    float h = cylinder.height;\n\n    // Translation du rayon et du cylindre pour aligner le cylindre avec l'axe y du repère monde\n    ray.o -= c;\n\n    // Coordonnées cylindriques du rayon\n    float a = ray.d.x * ray.d.x + ray.d.z * ray.d.z;\n    float b = 2.0 * (ray.d.x * ray.o.x + ray.d.z * ray.o.z);\n    float c1 = ray.o.x * ray.o.x + ray.o.z * ray.o.z - r * r;\n\n    // Résolution de l'équation quadratique en coordonnées cylindriques\n    float discriminant = b * b - 4.0 * a * c1;\n\n    if (discriminant >= 0.0) {\n        // Deux solutions possibles\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Vérification de la hauteur de l'intersection\n        float y1 = ray.o.y + t1 * ray.d.y;\n        float y2 = ray.o.y + t2 * ray.d.y;\n\n        // Vérification de la première solution\n        if (t1 >= 0.0 && y1 >= 0.0 && y1 <= h) {\n            vec3 p = Point(ray, t1);\n            // Calcul de la normale\n            vec3 normal = normalize(vec3(p.x, 0.0, p.z));\n            // Utilisation de la fonction Texture pour obtenir le matériau en fonction de l'identifiant de texture\n            Material mat = Texture(p, cylinder.i);\n            x = Hit(t1, normal, cylinder.i);\n            return true;\n        }\n\n        // Vérification de la deuxième solution\n        if (t2 >= 0.0 && y2 >= 0.0 && y2 <= h) {\n            vec3 p = Point(ray, t2);\n            // Calcul de la normale\n            vec3 normal = normalize(vec3(p.x, 0.0, p.z));\n            // Utilisation de la fonction Texture pour obtenir le matériau en fonction de l'identifiant de texture\n            Material mat = Texture(p, cylinder.i);\n            x = Hit(t2, normal, cylinder.i);\n            return true;\n        }\n    }\n\n    // Vérification des intersections avec les extrémités du cylindre (cercles)\n    float tTop = (h - ray.o.y) / ray.d.y;\n    float tBottom = (-ray.o.y) / ray.d.y;\n\n    if (tTop >= 0.0 && tTop <= h && (ray.o.x * ray.o.x + ray.o.z * ray.o.z) <= r * r) {\n        vec3 topHit = Point(ray, tTop);\n        x = Hit(tTop, normalize(vec3(0.0, 1.0, 0.0)), cylinder.i);\n        return true;\n    }\n\n    if (tBottom >= 0.0 && tBottom <= h && (ray.o.x * ray.o.x + ray.o.z * ray.o.z) <= r * r) {\n        vec3 bottomHit = Point(ray, tBottom);\n        x = Hit(tBottom, normalize(vec3(0.0, -1.0, 0.0)), cylinder.i);\n        return true;\n    }\n\n    return false;\n}\n\n\n\n\n// Intersection avec une capsule\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n    vec3 start = capsule.start;\n    vec3 end = capsule.end;\n    float radius = capsule.radius;\n    \n    // Vecteur direction du cylindre\n    vec3 cylinderDir = end - start;\n    float cylinderHeight = length(cylinderDir);\n    vec3 cylinderAxis = normalize(cylinderDir);\n    \n    // Translation du rayon et de la capsule\n    ray.o -= start;\n    \n    // Coordonnées cylindriques du rayon\n    float a = dot(ray.d - dot(ray.d, cylinderAxis) * cylinderAxis, ray.d - dot(ray.d, cylinderAxis) * cylinderAxis);\n    float b = 2.0 * dot(ray.d - dot(ray.d, cylinderAxis) * cylinderAxis, ray.o - dot(ray.o, cylinderAxis) * cylinderAxis);\n    float c = dot(ray.o - dot(ray.o, cylinderAxis) * cylinderAxis, ray.o - dot(ray.o, cylinderAxis) * cylinderAxis) - radius * radius;\n    \n    // Résolution de l'équation quadratique en coordonnées cylindriques\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant >= 0.0) {\n        float sqrtDiscriminant = sqrt(discriminant);\n        float t1 = (-b - sqrtDiscriminant) / (2.0 * a);\n        float t2 = (-b + sqrtDiscriminant) / (2.0 * a);\n        \n        // Vérification de l'intervalle d'intersection\n        if (t1 >= 0.0 && t1 <= cylinderHeight) {\n            // Calcul du point d'intersection\n            vec3 p = Point(ray, t1);\n            \n            // Vérification si le point est à l'intérieur des demi-sphères\n            float y = dot(p - start, cylinderAxis);\n            \n            if (y >= 0.0 && y <= cylinderHeight) {\n                // Le point d'intersection est à l'intérieur de la capsule\n                vec3 normal = normalize(p - start - y * cylinderAxis);\n                x = Hit(t1, normal, capsule.i);\n                return true;\n            }\n        }\n        \n        if (t2 >= 0.0 && t2 <= cylinderHeight) {\n            // Calcul du point d'intersection\n            vec3 p = Point(ray, t2);\n            \n            // Vérification si le point est à l'intérieur des demi-sphères\n            float y = dot(p - start, cylinderAxis);\n            \n            if (y >= 0.0 && y <= cylinderHeight) {\n                // Le point d'intersection est à l'intérieur de la capsule\n                vec3 normal = normalize(p - start - y * cylinderAxis);\n                x = Hit(t2, normal, capsule.i);\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Intersection avec un tore\nbool IntersectTorus(Ray ray, Torus torus, out Hit x) {\n    vec3 c = torus.center;\n    float R = torus.majorRadius;\n    float r = torus.minorRadius;\n\n    // Translation du rayon et du tore\n    ray.o -= c;\n\n    // Coefficients de l'équation quartique\n    float a = dot(ray.d, ray.d);\n    float b = dot(ray.o, ray.d);\n    float c1 = dot(ray.o, ray.o);\n    float R2 = R * R;\n    float r2 = r * r;\n\n    float k = (c1 - R2 - r2) * 0.5;\n    float discriminant = b * b - a * k;\n\n    if (discriminant >= 0.0) {\n        float sqrtDiscriminant = sqrt(discriminant);\n        float t1 = (-b - sqrtDiscriminant) / a;\n        float t2 = (-b + sqrtDiscriminant) / a;\n\n        // Vérification de la hauteur de l'intersection\n        float y1 = ray.o.y + t1 * ray.d.y;\n        float y2 = ray.o.y + t2 * ray.d.y;\n\n        // Vérification de la première solution\n        if (t1 >= 0.0 && y1 >= -r && y1 <= r) {\n            vec3 p = Point(ray, t1);\n            vec3 normal = normalize(vec3(p.x, y1, p.z));\n            x = Hit(t1, normal, torus.i);\n            return true;\n        }\n\n        // Vérification de la deuxième solution\n        if (t2 >= 0.0 && y2 >= -r && y2 <= r) {\n            vec3 p = Point(ray, t2);\n            vec3 normal = normalize(vec3(p.x, y2, p.z));\n            x = Hit(t2, normal, torus.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Intersection avec une demi-sphère\nbool IntersectHalfSphere(Ray ray, vec3 center, float radius, out Hit x) {\n    vec3 oc = ray.o - center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(oc, ray.d);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant > 0.0) {\n        float t = (-b - sqrt(discriminant)) / (2.0 * a);\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            vec3 normal = normalize(p - center);\n            x = Hit(t, normal, 0);  // L'identifiant de texture peut être ajusté\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph1=Sphere(vec3(0.,0.,1.),1.,1);\n    const Sphere sph2=Sphere(vec3(-3.,0.,2.),1.,1);\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n    const Ellipsoid elip1 = Ellipsoid(vec3(5.0, 1.0, 3.0), vec3(1.0, 2.0, 1.5), 1);\n    const Box box1 = Box(vec3(3.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), 1);\n    //const Cylinder cyl1 = Cylinder(vec3(2.0, 0.0, 2.0), 1.0, 3.0, 1);\n    const Cylinder cyl2 = Cylinder(vec3(8.0, 0.0, 2.0), 1.0, 3.0, 1);\n    const Capsule cap1 = Capsule( vec3(1.0, 2.0, 3.0), vec3(1.0, 2.0, 5.0), 0.5, 1);\n    //const Torus tor1 = Torus(vec3(-0.25, 1.0, -0.25), 0.4, 0.1, 1);\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectEllipsoid(ray,elip1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectBox(ray,box1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectCylinder(ray,cyl2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    /*if(IntersectCylinderClosed(ray,cyl2, current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    */\n    \n    if(IntersectCapsule(ray,cap1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    /*if(IntersectTorus(ray,tor1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    */\n    \n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n)\n{\n    vec3 light=normalize(vec3(1,1,1));\n    \n    float diff=clamp(dot(n,light),0.,1.);\n    vec3 col=m.d*diff+vec3(.2,.2,.2);\n    return col;\n}\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx=Intersect(ray,x);\n    \n    if(idx)\n    {\n        vec3 p=Point(ray,x.t);\n        Material mat=Texture(p,x.i);\n        \n        return Color(mat,x.n);\n    }\n    else\n    {\n        return Background(ray.d);\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}