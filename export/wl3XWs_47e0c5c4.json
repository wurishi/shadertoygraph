{"ver":"0.1","info":{"id":"wl3XWs","date":"1581941031","viewed":1634,"name":"Blue noise vs Bayer dithering","username":"Suslik","description":"This shader compares dithering quality using either blue noise or bayer matrices on moving objects. Note that even  though blue noise has somewhat superior quality of dithering compared to bayer noise, it has a very perceptible moving pattern.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["dithering","bluenoise","bayermatrices"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float RaySphereIntersection(vec3 rayStart, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n\tfloat scale = -1.0;\n\n\tfloat a = dot(rayDir, rayDir);\n\tvec3 delta = rayStart - sphereCenter;\n\tfloat b = 2.0 * dot (delta, rayDir);\n\tfloat c = dot(sphereCenter, sphereCenter) + dot(rayStart, rayStart) - 2.0 * dot(rayStart, sphereCenter) - sphereRadius * sphereRadius;\n\tfloat disc = b * b - 4.0 * a * c;\n\tif (disc > 0.0)\n\t{\n\t\tfloat sqrtDisc = sqrt(disc);\n\n\t\tscale = (-b - sqrtDisc) / (2.0 * a);\n\t}\n\treturn scale;\n}\n\nfloat RaytraceScene(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenters[2], vec3 lightPos)\n{\n    for(int i = 0; i < 2; i++)\n    {\n        float hitScale = RaySphereIntersection(rayOrigin, rayDir, sphereCenters[i], iResolution.x * 0.14);\n        if(hitScale < 0.0)\n            continue;\n        vec3 hitPoint = rayOrigin + rayDir * hitScale;\n        vec3 normal = normalize(hitPoint - sphereCenters[i]);\n        \n        float diffuse = max(0.0, dot(normal, -normalize(hitPoint - lightPos)));\n        return diffuse * 0.8 + 0.2;\n    }\n    return 0.1;\n}\n\nfloat GetBayerDither(float grayscale, ivec2 pixelCoord)\n{    \n    //use this for 2x2 bayer test\n    /*int bayerMatrix4[4] = int[4](0, 2, 3, 1);\n    int pixelIndex4 = (pixelCoord.x % 2) + (pixelCoord.y % 2) * 2;\n    return grayscale > (float(bayerMatrix4[pixelIndex4]) + 0.5) / 4.0 ? 1.0 : 0.0;*/\n\n    //use this for 8x8 bayer test\n    /*vec2 uv = (vec2(pixelCoord) + vec2(0.5)) / 8.0; //8 is the texture size\n    return textureLod(iChannel0, fract(uv), 0.0).x < grayscale ? 1.0 : 0.0; //8x8 creates more artifacts on moving objects than 4x4*/\n    \n    //this is the default 4x4 bayer\n    int bayerMatrix16[16] = int[16](0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5);\n    int pixelIndex16 = (pixelCoord.x % 4) + (pixelCoord.y % 4) * 4;\n    return grayscale > (float(bayerMatrix16[pixelIndex16]) + 0.5) / 16.0 ? 1.0 : 0.0;\n}\n\nfloat GetBlueNoiseDither(float grayscale, ivec2 pixelCoord)\n{\n    vec2 uv = (vec2(pixelCoord) + vec2(0.5)) / 1024.0; //1024 is the texture size\n    float blueNoiseValue = textureLod(iChannel1, fract(uv), 0.0).x;\n    //blueNoiseValue = sin(blueNoiseValue * 2.0 * 3.141592 + iTime) * 0.5 + 0.5;\n    return blueNoiseValue < grayscale ? 1.0 : 0.0;\n}\n\nfloat GetPixelColor(vec2 pixelCoord)\n{\n    float xPos = mix(iResolution.x * 0.2, iResolution.x * 0.8, sin(iTime) * 0.5 + 0.5);\n    float yPos = sin(iTime * 3.0) * 0.05 * iResolution.y * 0.0;\n    vec3 sphereCenters[2];\n    sphereCenters[0] = vec3(xPos, iResolution.y * 0.25 + yPos, 0.0);\n    sphereCenters[1] = vec3(xPos, iResolution.y * 0.75 - yPos, 0.0);\n    \n    vec3 lightPos = vec3(iResolution.x * (1.5), iResolution.y * 0.5, -1.5 * iResolution.x);\n    \n    vec3 rayOrigin = vec3(iResolution.x * 0.5, iResolution.y * 0.5, -iResolution.x);\n    vec3 rayDst = vec3(pixelCoord.xy, 0.0);\n    vec3 rayDir = normalize(rayDst - rayOrigin);\n    vec3 normals[2];\n\t\n    float grayscale = RaytraceScene(rayOrigin, rayDir, sphereCenters, lightPos);\n    float ditherColor = 0.0;\n    if(pixelCoord.y > iResolution.y * 0.5)\n    {\n        ditherColor = GetBayerDither(grayscale, ivec2(pixelCoord));\n    }else\n    {\n        ditherColor = GetBlueNoiseDither(grayscale, ivec2(pixelCoord));\n    }\n    //ditherColor = grayscale; //use for test without dithering\n    return ditherColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    float linearColor = 0.0;\n    if(sin(iTime) * 0.5 + 0.5 > abs(fragCoord.y / iResolution.y - 0.5) * 2.0)\n    {\n        linearColor = GetPixelColor(fragCoord.xy);\n    }else\n    {\n        ivec2 offset;\n        float sumColor = 0.0f;\n        float sumWeight = 0.0f;\n        for(int x = -2; x < 2; x++)\n        {\n            for(int y = -2; y < 2; y++)\n            {\n                sumColor += GetPixelColor(fragCoord.xy + vec2(x, y));\n                sumWeight += 1.0;\n            }\n        }\n        linearColor = sumColor / sumWeight;\n    }\n    fragColor = vec4(pow(vec3(linearColor), vec3(1.0 / 2.2)), 1.0); //linear->srgb manual conversion as shadertoy does not support actual srgb\n}","name":"Image","description":"","type":"image"}]}