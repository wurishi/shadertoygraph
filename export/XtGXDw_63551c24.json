{"ver":"0.1","info":{"id":"XtGXDw","date":"1484513075","viewed":214,"name":"experiment with rings 4","username":"grapespace","description":"base structure from\nhttp://ibreakdownshaders.blogspot.se/\n\nhttps://www.shadertoy.com/view/4djGDc\nhelped me figure out the zooming rings\n\nalot of comments to help me break down the code, tinkering, trial and error. guilty of crappy documentation.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ringscircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    //uv alternatives\n    //as done by FabriceNeyret2\n    \n    \n    //alt 1 and 2 divides both xy by  y\n    \n    //alt1\n    // uv = fragcoord\n    //   vec2  R = iResolution.xy;\n    //   uv = (2.*uv - R ) / R.y;\n    \n    //alt2 me\n\tvec2 uv = vec2 (1.,1.); \n    \n    uv = (1.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    \n   \n   //supposed to give same result (why is it not?)\n    //note to self to check!\n    \n   //alt3\n    \n   //vec2 uv= fragCoord.xy/iResolution.xy -vec2(0.5,0.5);\n    \n    //uv.x*=iResolution.x/iResolution.y;\n    \n    \n    \n    \n    \n    //\"calculate the radiusfrom the center\"\n    float radius =  sqrt(uv.x*uv.x + uv.y*uv.y);\n    \n    \n    //we moved time further down\n   //\"Calculate the angle from the center.\"\n    float angle = atan(uv.y,uv.x);\n    \n    \n    \n    \n    //\"apply a sin operation to produce rings\"\n    \n    // pow â€” return the value of the first parameter raised to the power of the second\n    // \"By raising our sine function to the second power, we'll generate faster peaks.\"\n    \n    //remember radius is using uv-coordinates for our pixels and calculates its distance from center\n    //which we have moved to the center\n    \n    //why *32 * 0.5 + 0.5??? CHECK!\n    \n    //sin() give values -1<= x <= 1\n    // frequency effect how quickly we move between these values\n    \n    // fr  = frequency\n    // amp = amplitude, multiply the value of each point\n    // then 1.7 simply add on the values\n    // lastly to the power of 2  // ^2\n    \n    //play around with the values, get less and more intensive colours and rings\n    \n    \n    //sin(arctan)  \n    //switch fr to 1.0 to understand better what is going on!\n    // arctan(0,1) = 90*  sin (90*) = 1\n    \n    \n    \n    \n    float fr = 7.0;\n    float amp = .9;\n    \n    //multiply by radius in order to darken points closer to middle\n    \n    float radialIntensity = pow( sin (radius*fr- iTime  ) , 2.0)*radius;\n   \n    \n   // float angleIntensity = pow( sin (angle*fr)* amp  + 0.5, 2.0);\n    \n    \n    //\nfloat angleIntensity = \n\n   // ange*value: value give how many blobs in a ring\n    // frequecny gives us how many rings\n    //favourites 8.0, 1.0, 2.0, 5.0, 15  70\n    \n    \n    \n    //Edit so it jumps to different values \n    \n    \n    \n    \npow( sin (angle * 17. + fr*iTime * sin(fr*radius- iTime)/abs(sin(fr*radius-iTime))) * amp + 1.9, 2.0);\n    \n    \n\t//\"Multiply the masks together\"\n    float finalIntensity = radialIntensity*angleIntensity;\n    \n    \n    //set final color\n    \n    //color = vec3(bl.x*tr.y*tr.x*bl.y);\n    \n    vec2 bl = smoothstep(vec2(-1.8), vec2 (-.8),uv);\n    vec2 tr = smoothstep(vec2(1.8), vec2 (0.8), uv);\n    \n    vec3 borders = vec3(bl.x*tr.y*tr.x*bl.y);\n    vec3 background = vec3(0.0, 0.1, 0.09);  //(rgba\n    \n    vec3 finalIntensityVec3 = (vec3(0.05*finalIntensity, 0.2*finalIntensity, finalIntensity) + background)*borders;\n    \n    //RG = red/green\n    //float RG = 0.1*finalIntensity;\n    \n    \n    \n    \n\tfragColor = vec4(finalIntensityVec3, 1.0);\n}","name":"Image","description":"","type":"image"}]}