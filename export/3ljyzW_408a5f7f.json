{"ver":"0.1","info":{"id":"3ljyzW","date":"1594479502","viewed":214,"name":"Trantor Express","username":"shau","description":"Sci-Fi train","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["3d","pathtrace","asimov"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n * Borrowing code from Some Boxes & Basic Montecarlo by IQ\n * https://www.shadertoy.com/view/Xd2fzR\n * https://www.shadertoy.com/view/MsdGzl\n * ... and a plethora of others too\n * render quality can be configured with defines in Buffer A\n */\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (2.0*(U) - R.xy)/R.y;\n    \n    if (iFrame>0)\n    {\n        col = vec4(dof(iChannel0,U/R,texture(iChannel0,U/R).w),1.).xyz;\n        col /= float(iFrame);\n        col = pow(col,vec3(.43545));\n    }  \n    \n    col = 1.15*pow(col,vec3(0.9,0.95,1.0)) + vec3(-0.04,-0.04,0.0);\n    col = pow(col,vec3(0.80,0.85,0.9));\n    col *= 1. / (1. + length(uv)*length(uv)*0.2);\n    \n    C = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define GIQ 3 //GI bounces\n#define AA 1 //anti-aliasing passes\n\nstruct Ray\n{\n\tvec3 ro;\n    vec3 rd;\n};\n\nstruct Scene \n{\n    float tt;\n\tfloat mint;\n    float roof;\n    float wall;\n    float cab;\n    float window;\n    float metal;\n    float spot;\n    float light;\n    float light2;\n    float floorLight;\n    float fan;\n};\n    \n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDir(vec2 h2, vec3 nor)\n{\n    float a = 6.2831853 * h2.y;\n    float u = 2.0*h2.x - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n//SDFs and sphere functions IQ\n//https://iquilezles.org/www/index.htm\n\nvec3 uniformVector(vec2 h2)\n{\n    float a = 3.141593*h2.x;\n    float b = 6.283185*h2.y;\n    return vec3(sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) \n{\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nfloat sdBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedCylinderV(vec3 p, float h, float r) \n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderH(vec3 p, float h, float r) \n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) \n{\n    return (length(p / r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\n\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n    float angle = 6.283185 / repetitions;\n    float a = atan(p.y, p.x) + angle / 2.0;\n    float r = length(p);\n    float c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nfloat smin(float a, float b, float k) \n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) \n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nfloat dfFan(vec3 p, float offs)\n{\n    #if AA>1  \n    p.xy *= rot(offs*0.06);\n    #endif\n    pModPolar(p.yx,16.);\n    p.xz *= rot(0.3);\n    p.yz *= rot(0.5);\n    return sdBox(p - vec3(0.0,0.06,0.), vec3(0.03,0.1,0.006));\n}    \n\nScene map(vec3 p, float offs) \n{\n\n    Scene s = Scene(0.,FAR,FAR,FAR,FAR,FAR,FAR,FAR,FAR,FAR,FAR,FAR);\n    \n    //roof\n    vec3 q = p;\n    float scale = 1.;\n    for (int i = 0; i < 10; i++) {\n        q = mod(q - 1.,2.) - 1.;\n        q -= sign(q) * 0.03; //IQ\n        float k = 1. / dot(q,q);\n        q *= k;\n        scale *= k;\n    }\n    s.roof = max(.25*length(q)/scale,-(p.y - 1.));\n    \n    q = p - vec3(1.0,1.0,1.0);\n    vec3 q2 = q;\n    \n    //floor\n    q2.z = mod(q2.z,2.0)-1.;\n    q2.x = abs(q2.x);    \n    s.wall = sdBox(q2 - vec3(100.1,-1.3,0.),vec3(100.0,1.0,0.98));\n    s.wall = smax(s.wall, -sdCappedCylinderH(q2 - vec3(0.,0.2,0.),0.8,1.0),0.04);\n    s.floorLight = sdBox(p - vec3(0.,0.,0), vec3(100.,0.1,100.));\n    \n    //mono rail\n    s.metal = sdCappedCylinderV(q2 - vec3(0.,0.8,0.),0.02,0.2);\n    s.metal = min(s.metal,sdBox(p - vec3(1.,1.6,0.),vec3(0.1,0.01,100.)));\n    \n    //pillars\n    q2.x = mod(q2.x,2.0)-1.0;\n    q2.y += 1.;\n    float plr = sdCappedCylinderV(q2,0.16,0.96); \n    plr = smax(plr,-sdBox(q2,vec3(0.04,1.,1.)),0.02);\n    plr = smax(plr,-sdBox(q2,vec3(1.0,1.,0.04)),0.02);\n    s.wall = min(s.wall,plr-0.02);\n    s.light2 = sdCappedCylinderV(q2,0.12,0.94); \n    \n    //lights\n    q = p - vec3(0.,3.,0.);\n    q.xz = mod(q.xz,2.)-1.0;\n    s.light = length(q) - 0.3;\n    s.metal = min(s.metal,sdCappedCylinderV(q - vec3(0.0,10.0,0.0),0.02,10.));\n\n\t//cab\n    q = p - vec3(1.0,1.0,0.5);\n    s.cab = sdCappedCylinderH(q,0.3,1.0);\n    s.cab = min(s.cab,sdEllipsoid(q - vec3(0.,0.,-1.),vec3(0.3,0.3,0.8)));\n    s.cab = smax(s.cab,-sdBox(q - vec3(0.,0.,0.2),vec3(0.5,0.02,0.3)),0.01);\n    s.window = sdCappedCylinderH(q,0.27,0.9);\n    \n    q2 = q;\n    q2.xy *= rot(0.523598);\n    pModPolar(q2.xy,3.0);\n    float headLight = sdEllipsoid(q2 - vec3(0.27,0.0,-1.3),vec3(0.07,0.07,0.38));\n    headLight = smax(headLight,-sdBox(q2 - vec3(0.27,0.0,-1.5),vec3(0.1,0.1,0.2)),0.02);\n    s.cab = smin(s.cab,headLight,0.02);\n    s.cab = smax(s.cab,-sdEllipsoid(q2 - vec3(0.27,0.0,-1.34),vec3(0.06,0.06,0.38)),0.01);\n    s.spot = sdEllipsoid(q2 - vec3(0.27,0.0,-1.27),vec3(0.05,0.05,0.03)); \n\n    q.x = abs(q.x);\n    s.cab = smax(s.cab, -sdBox(q - vec3(0.25,0.1,-1.7),vec3(0.2,0.02,0.1)),0.014);\n    s.window = min(s.window,sdEllipsoid(q - vec3(0.,0.0,-1.),vec3(0.27,0.27,0.78)));\n\ts.window = max(s.window,-sdBox(q - vec3(0.,0.0,-1.),vec3(0.4,0.4,0.56)));\n\n    float cowl = sdEllipsoid(q - vec3(0.3,-0.2,-1.),vec3(0.18,0.18,0.8));\n    cowl = smax(cowl,-sdBox(q - vec3(0.3,-0.2,-1.6),vec3(0.24,0.24,0.24)),0.02);\n    \n    s.cab = smin(s.cab,cowl,0.04);\n    s.cab = smax(s.cab,-sdEllipsoid(q - vec3(0.3,-0.2,-1.2),vec3(0.14,0.14,0.6)),0.02);\n    s.cab = min(s.cab,sdEllipsoid(q - vec3(0.3,-0.2,-1.),vec3(0.04,0.04,0.4))); \n    s.light2 = min(s.light2,sdTorus(q - vec3(0.3,-0.2,-1.3),vec2(0.13,0.01)));\n    \n    //fan\n    s.fan = dfFan(p - vec3(1.3,0.8,-0.84),offs);\n    s.fan = min(s.fan,dfFan(p - vec3(0.7,0.8,-0.84),offs));\n\n    //carriage\n    q.z -= 10.;\n    q = opRepLim(q,2.,vec3(0.,0.,4.));\n    s.cab = min(s.cab,sdCappedCylinderH(q,0.3,0.9));\n    s.cab = smax(s.cab,-sdBox(q,vec3(0.4,0.02,0.8)),0.01);\n    s.window = min(s.window,sdCappedCylinderH(q,0.26,0.8));\n    s.cab = smin(s.cab,sdBox(q - vec3(0.,0.2,0.),vec3(0.006,0.4,0.2)),0.04);\n    s.cab = smin(s.cab,sdBox(q - vec3(0.,0.6,0.),vec3(0.12,0.04,0.3)),0.04);\n    q.xy *= rot(-0.7);\n    s.cab = smin(s.cab,sdBox(q - vec3(0.4,0.0,0.0),vec3(0.12,0.03,0.7)),0.04);\n\n    //cab hook\n    q = p;\n    q.yz *= rot(0.4);\n    float hook = sdBox(q - vec3(1.,1.4,-0.68),vec3(0.006,0.4,0.2));\n    hook = max(hook,-sdBox(p - vec3(1.,1.8,0.0),vec3(0.3,0.2,0.3)));\n    hook = smin(hook,sdBox(p - vec3(1.,1.6,0.0),vec3(0.12,0.04,0.3)),0.04);\n\ts.cab = min(s.cab,hook - 0.01);\n    \n    s.mint = min(s.mint,min(s.roof,min(s.light,min(s.window,min(s.wall,min(s.cab,min(s.metal,min(s.light2,min(s.spot,min(s.floorLight,s.fan))))))))));\n    \n    return s;\n}\n\nfloat panelTex(vec3 p)\n{\n    return (((S(-1.17,-1.169,p.z) * S(-1.165,-1.166,p.z) + \n              S(1.0,1.001,p.y))*S(1.003,1.002,p.y)) +\n            ((S(0.81,0.811,p.y) * S(0.82,0.819,p.y) +\n              S(-0.74,-0.741,p.z))*S(-0.75,-0.749,p.z)) +\n             (S(0.995,0.996,p.x) * S(1.005,1.004,p.x)) + \n              S(-1.265,-1.266,p.z)) * S(-1.268,-1.267,p.z);\n}\n\nvec3 panelBump(vec3 p, vec3 n) {\n    vec4 d = vec4(0.);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p,0.);\n        s[i] += EPS;\n        d[i] = panelTex(s.xyz);\n    }\n    return normalize(n - d.xyz * 0.4);\n}\n\nvec3 normal(vec3 p, float offs) \n{  \n    vec4 n = vec4(0.);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p,0.);\n        s[i] += EPS;\n        n[i] = map(s.xyz,offs).mint;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n,float offs) \n{    \n    float ra = 0., w = 1., d = 0.;\n    for (int i=ZERO; i<4; i++){\n        d = float(i)/5.;\n        ra += w * (d - map(p + n * d,offs).mint);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nScene relaxedMarch(Ray ray, float offs) {\n\n    const float PR = EPS;\n    Scene s = Scene(0.,FAR,FAR,FAR,FAR,FAR,FAR,FAR,FAR,FAR,FAR,FAR);\n\n    float om = 1.3,\n          t = EPS,\n          ce = FAR,\n          ct = EPS,\n          pr = 0.0,\n          sl = 0.0,\n          fs = map(ray.ro,offs).mint<0.0 ? -1.0 : 1.0;\n\n    for (int i=0; i<100; ++i) {\n        Scene si = map(ray.ro + ray.rd*t,offs);\n        float sr = fs*si.mint,\n              r = abs(sr);\n        bool fail = om>1.0 && (r + pr)<sl;\n        if (fail) {\n            sl -= om*sl;\n            om = 1.;\n        } else {\n            sl = sr*om;\n        }\n        pr = r;\n        float err = r/t;\n        if (!fail && err<ce) {\n            ct = t;\n            ce = err;\n        }\n        if (!fail && err<PR || t>FAR) {\n            s = si;\n            break;\n        }\n        t += sl;\n    }\n\n    s.tt = ct;\n    if (t>FAR || ce>PR) s.tt = -1.;\n\n    return s;\n}\n\nvec4 render(Ray ray, float pass)\n{\n    vec3 lp = vec3(1,1,-3),\n         accColour = vec3(0),\n         colourMask = vec3(1);\n    \n    float t = FAR,\n          il = 0.,\n          tt = 0.,\n          offs = float(AA*AA)-pass;\n    \n    for (int i=0; i<GIQ; i++)\n    {\n    \tScene s = relaxedMarch(ray,offs);\n        if (s.tt<0.) break; //missed        \n        if (i==0) t = s.tt;\n        \n        vec3 albedo = vec3(0),\n             emit = vec3(0),\n             emitShade = vec3(0),\n             p = ray.ro + ray.rd*s.tt,\n             n = normal(p,offs),\n             ld = normalize(lp - p);\n\n        float rg = 0.,\n\t\t      pnt = S(0.1,0.11,p.z+p.y)*(S(0.91,0.9,p.z+p.y) + S(1.11,1.1,p.y)),\n              ao = AO(p,n,offs),\n              attn = length(lp - p),\n              nz = (n3D(p*0.7) - S(0.4,0.7,n3D(5.7+p*vec3(32.,22.,63.))))*S(0.62,0.7,abs(p.x-1.))*max(0.,n.y),\n              ly = 1. - sin(p.y*600.)*sin(p.x*600.)*0.8;\n        \n        if (s.mint==s.roof)\n        {\n            albedo = vec3(0.3,0.6,0.7);\n            rg = 0.6;\n        }\n        else if (s.mint==s.light)\n        {\n            emit =  vec3(1.0,0.8,0.4);\n            float w = sphDensity(ray.ro,ray.rd,vec4(floor(p.x+0.5),3.0,floor(p.z+0.5),0.3),FAR);\n            emitShade = emit + vec3(1)*w*w*w*w*1.;\n        }\n        else if (s.mint==s.window)\n        {\n            emit = mix(vec3(0.5,0.7,1),vec3(0,0,1),S(1.08,1.12,p.y));  \n            emitShade = emit;\n        }\n        else if (s.mint==s.wall)\n        {\n            albedo = vec3(0.2);\n            rg = 0.6-nz*0.4;\n        }\n        else if (s.mint==s.cab)\n        {\n            n = panelBump(p,n);\n            albedo = mix(vec3(1.),vec3(.8,0.,0.),min(1.,pnt));\n            rg = 0.1;\n        }\n        else if (s.mint==s.metal)\n        {\n            albedo = vec3(0.4);    \n        }\n        else if (s.mint==s.light2)\n        {\n            emit = vec3(0.3,1,0.6);    \n            emitShade = emit;\n        }\n        else if (s.mint==s.spot)\n        {\n            emit = vec3(0.8,0.7,1.0)*ly;\n            emitShade = emit;\n        }\n        else if (s.mint==s.floorLight)\n        {\n            float ei = fract(p.z*2.0);\n            emit = vec3(2.4,1.4,1.0)*S(0.1,0.25,ei)*S(0.9,0.75,ei);\n            emitShade = emit;\n        }\n\t\telse if (s.mint==s.fan)\n        {\n            albedo = vec3(1);\n            rg = 0.3;\n        }\n        \n        //emmisive lights\n        if (length(emit)>0.0) \n        {\n            if (i==0)\n            {\n                accColour = emitShade; \n                il = 1.;\n            }\n            else \n            {\n                accColour = emit*colourMask; \n            }\n            break;\n        }\n        \n        //direct lighting\n        colourMask *= albedo;\n        \n        vec3 dl = vec3(0);\n        dl += vec3(1.,0.6,0.3)*max(0.05,dot(ld,n))/(1. + attn*attn)*ao;\n        accColour += colourMask*dl;\n        \n        tt += s.tt;\n        if (tt>20.) break;\n        \n        Ray scatter = Ray(p + n*EPS, cosineDir(hash23(p*float(i + iFrame)),n));\n        float h1 = hash1(3U + 37U*uint(i) + 31U*uint(iFrame));\n        if (h1>rg)\n        {\n            scatter.rd = normalize(reflect(ray.rd,n)) + uniformVector(hash23(7.+p*float(3*i + 11*iFrame)))*rg;\n        }\n        ray = scatter;\n\n        if (dot(colourMask,colourMask) < 0.001) break; //Reinder\n    }\n    \n    accColour /= il>0. ? 1. : (1. + t*t*2.);\n        \n    \n    return vec4(accColour,t);\n}\n\n//IQ\nmat3 camera(vec3 la, vec3 ro, float cr)\n{\n\tvec3 cw = normalize(la - ro),\n\t     cp = vec3(sin(cr),cos(cr),0.0),\n\t     cu = normalize(cross(cw,cp)),\n\t     cv =          (cross(cu,cw));\n    return mat3(cu,cv,cw); \n}\n    \nvoid mainImage(out vec4 C, vec2 U)\n{\n    float fl = 1.5,\n          dof = 0.,\n          h1 = hash1(3U+(7U*uint(iFrame)))-0.5;\n    vec4 buf = texture(iChannel0, U/R.xy);\n    if (iFrame==0) buf = vec4(0);   \n    \n    vec3 la = vec3(1.,1.,-0.5),\n         ro = vec3(0.25,0.9,-1.7),\n         col = vec3(0);\n    mat3 cam = camera(la,ro,0.);   \n    \n    #if AA>1    \n    for (int i=0; i<AA; i++)\n    for (int j=0; j<AA; j++)\n    {\n        vec2 offs = vec2(float(i),float(j))/float(AA) - 0.5;\n        vec2 tuv = (2.0*(U+offs) - R)/R.y;\n        vec3 trd = cam*normalize(vec3(tuv,fl));\n        vec4 scene = render(Ray(ro,trd), float(i*j + j));\n        col += scene.xyz;\n        dof = length(la - (ro + trd*scene.w))/25.;\n    }\n    col /= float(AA*AA);\n    #else\n    vec2 uv = (2.0*(U+h1) - R.xy)/R.y;\n    vec3 rd = cam*normalize(vec3(uv,fl));\n    vec4 scene = render(Ray(ro,rd), 0.);\n    col = scene.xyz;\n    dof = length(la - (ro + rd*scene.w))/25.;\n    #endif\n    \n    if (ivec2(U)==ivec2(0)) {\n        C = R.xyxy; //Reinder\n    } else {\n        if (texelFetch(iChannel0, ivec2(0),0).xy == R.xy) {\n            C = vec4(col+buf.xyz,dof);\n        } \n        else\n        {\n            C = vec4(col,dof);    \n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define S(a, b, v) smoothstep(a, b, v)\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS .002\n#define FAR 10.\n#define T iTime\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins - hash without\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//IQ\nfloat hash1(uint n) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float(n&0x7fffffffU)/float(0x7fffffff);\n}\n","name":"Common","description":"","type":"common"}]}