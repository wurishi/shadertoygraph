{"ver":"0.1","info":{"id":"M3t3RB","date":"1716729874","viewed":50,"name":"simpleMountain","username":"PixelPants","description":" primarily generated by Perlin noise, where the cloud formations are created by inputting x and y coordinates, and the mountain heights are obtained by inputting x and z coordinates.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["mountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float eps = 0.01;\n\n\nfloat S(in float l)\n{\n    return l*l*(3.0-2.0*l);\n}\n\nfloat GetHeight(in float x,in float y)\n{\n    float tmp;\n    float i0 = floor(x);\n    float i1 = ceil(x);\n    float j0 = floor(y);\n    float j1 = ceil(y);\n    \n    vec2 a2 = 50.0*fract(vec2(i0,j0)/3.1415926);\n    if(a2.x==0.0)\n    a2.x = 0.5;\n    if(a2.y==0.0)\n    a2.y = 0.5;\n    float a = 2.0*fract(a2.x*a2.y*(a2.x+a2.y))-1.0;\n    \n    \n    vec2 b2 = 50.0*fract(vec2(i1,j0)/3.1415926);\n    if(b2.x==0.0)\n    b2.x = 0.5;\n    if(b2.y==0.0)\n    b2.y = 0.5;\n    float b = 2.0*fract(b2.x*b2.y*(b2.x+b2.y))-1.0;\n    \n    vec2 c2 = 50.0*fract(vec2(i1,j1)/3.1415926);\n    if(c2.x==0.0)\n    c2.x = 0.5;\n    if(c2.y==0.0)\n    c2.y = 0.5;\n    float c = 2.0*fract(c2.x*c2.y*(c2.x+c2.y))-1.0;\n    \n    vec2 d2 = 50.0*fract(vec2(i0,j1)/3.1415926);\n    if(d2.x==0.0)\n    d2.x = 0.5;\n    if(d2.y==0.0)\n    d2.y = 0.5;\n    float d = 2.0*fract(d2.x*d2.y*(d2.x+d2.y))-1.0;\n    \n    \n    float ans = a+(b-a)*S(x-i0)+(d-a)*S(y-j0)+(a-b-d+c)*S(x-i0)*S(y-j0);\n    \n    \n    \n    \n    \n    return ans;\n}\n\nfloat GetSeriesHeight(vec3 p,int n,float strenth,float scale)\n{\n    float height  = 0.0;\n    float s = 1.0;\n    float sc = 1.0;\n    vec3 tmp = p;\n    \n    for(int i = 0;i<n;i++)\n    {\n        tmp = p;\n        p.x = tmp.x*0.8+tmp.z*0.6;\n        p.z = -tmp.x*0.6+tmp.z*0.8;\n        height+=s*GetHeight(p.x*sc,p.z*sc);\n        s*=strenth;\n        sc*=scale;\n    }\n    \n    return height;;\n}\nfloat easyGetHeight(vec3 p)\n{\n    return GetSeriesHeight(p,5,0.5,2.0);\n}\n\nvec2 v_uv;\nvec3 rayOrigin;\nvec3 rayDirection;\n\nfloat smin(float a, float b, float k) {  \n    float h = clamp(0.5 + 0.5 * (a -b) / k, 0.0, 1.0);  \n    return mix(a, b, h) - k * h * (1.0 - h);  \n}\n\nvec3 lerp(vec3 l,vec3 r,float k)\n{\n    return l*k+r*(1.0-k);\n}\n\nvec3 getNormal( const vec3  p )\n{\n    return normalize( vec3( easyGetHeight(vec3(p.x-eps,p.z,p.y)) - easyGetHeight(vec3(p.x+eps,p.z,p.y)),\n                            2.0f*eps,\n                            easyGetHeight(vec3(p.x,p.z-eps,p.y)) - easyGetHeight(vec3(p.x,p.z+eps,p.y)) ) );\n}\n\nfloat gray;\nfloat map(in vec3 p)\n{\n    vec3 tmp = p;\n    \n\n    \n   \n    p.y = tmp.y*cos(-0.1)+tmp.z*sin(-0.1);\n    p.z = -tmp.y*sin(-0.1)+tmp.z*cos(-0.1);\n    \n    \n    tmp = p;\n    float time = 0.3*iTime;\n    p.x = tmp.x*cos(time)+tmp.z*sin(time);\n    p.z = -tmp.x*sin(time)+tmp.z*cos(time);\n\n    float height = easyGetHeight(p);\n    \n    vec3 normal = getNormal(p);\n    vec3 light = normalize(vec3(0.5,0.5,-0.3));\n    \n    gray = dot(light,normal);\n    \n    \n    float ground = 0.5*height+p.y+1.0;\n    return ground;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    v_uv = (fragCoord*2.0-iResolution.xy)/iResolution.xy;\n    v_uv.x*=iResolution.x/iResolution.y;\n    vec3 rayOrigin = vec3(0.0,0.0,-3.0);\n    vec3 rayDirection = normalize(vec3(v_uv,0.0)-rayOrigin);\n\n    float t = 0.0;\n    vec3 color;\n    for(int i = 0;i<80;i++)\n    {\n        float nearest;\n        nearest =map(rayOrigin+t*rayDirection);\n        t+=nearest*0.3;\n        if(nearest<0.001||t>1000.0)break;\n    }\n    \n    gray = t*0.058;\n    gray = min(gray,1.0);\n    gray = sqrt(gray);\n    fragColor = vec4(gray*0.4,gray*0.3,gray*0.2,1.0);\n    if(gray>=0.88)\n    {\n        fragColor = vec4(0.3,0.6,0.9,1.0);\n        fragColor+=0.2*GetSeriesHeight(vec3(fragCoord.x*0.01+iTime,0.0,fragCoord.y*0.01),3,0.5,2.0);\n    }\n    fragCoord.y-=iResolution.y+180.0;\n    fragCoord.x+=100.0;\n    \n    \n    float d = fragCoord.x*fragCoord.x+fragCoord.y*fragCoord.y;\n    fragColor+=0.05/(d/(iResolution.x*iResolution.x+iResolution.y*iResolution.y))*vec4(1.0,0.5,0.0,0.0);\n}","name":"Image","description":"","type":"image"}]}