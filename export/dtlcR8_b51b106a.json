{"ver":"0.1","info":{"id":"dtlcR8","date":"1693499828","viewed":37,"name":"shadow sphere 2 ","username":"nenuser","description":"shadow sphere 2  ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadow","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Darko (omegasbk) \n//\n// Darko's Gamedev Cookbok Youtube serial\n// https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA\n//\n// Lesson 2 - Directional Light\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float zoom; \n} camera;\n\nstruct Sphere\n{\n    vec3 color;\n    vec3 position;\n    float radius;     \n} sphere;\n\nstruct Light\n{\n\tvec3 direction;    \n} light;\n\nstruct Plane\n{\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n}plane;\n\n\nvoid setupScene()\n{\n    camera.position = vec3(0., 0., 3.5);\n    camera.direction = vec3(0., 0., -1.);\n    camera.zoom = 1.0;\n    \n    \n    plane.point = vec3(0., -0.5, 0.);\n    plane.normal = vec3(0., 1., 0.);\n    plane.color = vec3(0.5, 0.5, 0.5);  // Plane color is grey\n    \n    sphere.position = vec3(0., 0., 0.);\n    sphere.radius = 0.3;\n    sphere.color = vec3(0.9, 0.2, 0.3);\n    \n    light.direction = normalize(vec3(0., -1., -0.78));\n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nbool intersect(vec3 direction, out vec3 surfaceNormal)\n{\n    vec3 L = camera.position - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n        float t = t0;\n        if (t1 < t0)\n        {\n            t = t1;\n        }\n        \n        vec3 Phit = camera.position + t * direction;\n        surfaceNormal = normalize(Phit - sphere.position);\n        \n        return true;\n    }  \n     \n    return false;\n}\n\n\n\n\nbool intersectPlane(vec3 direction, out vec3 Phit)\n{\n    float denom = dot(plane.normal, direction);\n    if (abs(denom) < 0.0001) return false;  // parallel to the plane\n    \n    float tTemp = dot(plane.point - camera.position, plane.normal) / denom;\n    if (tTemp >= 0.) {\n        Phit = camera.position + direction * tTemp;\n        return true;\n    }\n    \n    return false;\n}\n\nvec3 rayTrace(vec3 direction)\n{\n    vec3 surfaceNormal;\n    vec3 Phit;\n    \n    if (intersect(direction, surfaceNormal))\n    {\n        float coeff = -dot(light.direction, surfaceNormal);                          \n        \n        return coeff * sphere.color;\n    }\n    \n    if (intersectPlane(direction, Phit))\n    {\n        // Calculate the shadow position. \n        // We now project along the light direction.\n        vec3 shadowPos = sphere.position + light.direction * abs(dot(sphere.position - plane.point, plane.normal));\n        // Calculate the distance between the hit point and the shadow position.\n        float dist = length(shadowPos - Phit);\n        // If the distance is less than the radius, the hit point is in the shadow.\n        if (dist < sphere.radius) {\n            return vec3(0., 0., 0.);  // Shadow color\n        } else {\n            return plane.color;\n        }\n    }\n    \n    return vec3(0., 0., 0.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{        \n    setupScene();\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 direction = normalize(vec3(uv, camera.zoom) - camera.position);\n    \n    \n    \n    light.direction.x = -(iMouse.x / iResolution.x - 0.5);\n    light.direction.y = -(iMouse.y / iResolution.y - 0.5);\n    light.direction = normalize(light.direction);\n    \n    \n    \n    vec3 col = rayTrace(direction);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}