{"ver":"0.1","info":{"id":"WlSSWV","date":"1567051363","viewed":9180,"name":"One Way Trip","username":"PVM","description":"\"One Way Trip\" by PVM\nRanked 2nd in the 4 kbytes compo at Evoke 2019, Germany.\nCode: Kali, Music: Uctumi\nYou can download Windows 4kbyte executable from: http://pungas.space/releases/pvm-owtr.zip \n+PVM Info: http://pungas.space","likes":150,"published":1,"flags":64,"usePreview":0,"tags":["intro","4k","demoscene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4lXGWS","filepath":"https://soundcloud.com/pablo-andrioli/uctumi-alien-reefs-wip","previewfilepath":"https://soundcloud.com/pablo-andrioli/uctumi-alien-reefs-wip","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -------------------------------------------------------------------------------------------\n\n// \"ONE WAY TRIP\" by PVM\n\n// Shadertoy version of our 4k intro entry for Evoke 2019\n\n// Code: Kali\n// Music: Uctumi\n\n// NOTE: Rewind the shader after it starts to correct audio sync\n\n// -------------------------------------------------------------------------------------------\n\n// Original code without optimizations for the 4k intro and including PVM logo\n\n// global variables\nfloat det=.005, fin=0., time; // raymarching threshold, aux variable\nconst float maxdist=60.; // max distance for raymarching\nvec3 ldir=vec3(0.,1.,4.); // light direction (without normalization)\nvec3 fcol; // global for coloring\nvec3 suncol=vec3(2.,1.,.6); // sun color\n\n// 2D rotation functions\nmat2 rot2D(float a) {\n\tfloat s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n// A version with degrees used when designing the logo\nmat2 rot2Ddeg(float a) {\n\ta=radians(a);\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\n// -------------------------------------------------------------------------------------------\n\n// PVM LOGO\n\n\n// 2D rectangle with a tilt distortion value\nfloat rect(vec2 p, vec2 b, float inc) {\n    p.x+=p.y*inc;\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// 2D triangle function by iq (I think)\nfloat tri(vec2 p, vec2 q, float ang) {\n    p*=rot2Ddeg(ang);\n    p.x = abs(p.x);\n    \n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n// Here the logo is constructed from distoted rectangles and triangles\nvec4 logo(vec2 uv) {\n    uv*=1.2;\n    uv.x*=1.15;\n    uv.y-=.6;\n    uv.x-=1.3;\n    float d=rect(uv,vec2(.045,.25),-.5);\n\tuv.x+=.25;\n    uv.y+=.01;\n    d=min(d,rect(uv,vec2(.045,.24),.5));\n\tuv.x+=.265;\n    uv.y-=.04;\n    d=min(d,rect(uv,vec2(.045,.2),-.55));\n\tuv.x-=.73;\n    uv.y-=.06;\n    d=min(d,rect(uv,vec2(.045,.16),.4));\n\tuv.x-=.105;\n    uv.y+=.074;\n    d=min(d,rect(uv,vec2(.045,.085),-.45));\n\tuv.x-=.105;\n    uv.y+=.045;\n    d=min(d,rect(uv,vec2(.045,.13),.45));\n\tuv.x-=.25;\n    uv.y+=.1;\n    d=min(d,rect(uv,vec2(.18,.03),.0));\t\n\tuv.x+=1.32;\n    uv.y-=.18;\n    d=min(d,rect(uv+vec2(0.0,.03),vec2(.35,.03),.0));\t\n    uv.x-=.5165;\n    uv.y+=.4;\n    d=min(d,tri(uv,vec2(.09,.185),0.));\n    uv.x-=.492;\n    uv.y-=.56;\n    d=min(d,tri(uv,vec2(.063,.14),180.));\n    uv.x+=.225;\n    uv.y-=.17;\n    d=min(d,tri(uv,vec2(.063,.145),180.));\n    uv.x-=.142;\n    uv.y+=.555;\n    d=min(d,tri(uv,vec2(.063,.145),0.));\n    uv.x+=.985;\n    uv.y+=.075;\n    vec2 uvd=uv-vec2(uv.y,0.);\n    d=min(d,tri(uvd-vec2(0.003,0.022),vec2(.04,.05),0.));\n    uv.x-=.16\t;\n    uv.y-=.63;\n    uvd=uv+vec2(uv.y*.4,0.);\n    d=min(d,tri(uvd+vec2(.03,0.),vec2(.07,.23),-145.));    \n   \tuvd=uv+vec2(.465,.33);\n    uvd*=rot2Ddeg(27.);\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\n   \tuvd=uv+vec2(-1.43,.534);\n    uvd*=rot2Ddeg(206.);\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\n    float s=pow(abs(d)+.9,10.);\n\tuvd=uv+vec2(-.28,.36);\n    uvd*=rot2Ddeg(50.);\n    d=max(d,-rect(uvd,vec2(.1,.025),.0));\n    // logo coloring, RGBA \n    float o=1.-smoothstep(0.,.01,d);\n    float l=1.-smoothstep(0.,.05,d);\n    vec3 col=mix(vec3(2.,.15,.1),vec3(1.,2.,.5),min(1.,abs(uv.y+.4)));\n    return vec4(col*o+.1,l);\n}\n\n\n// -------------------------------------------------------------------------------------------\n\n// FRACTAL \n\n// A bunch of sin and cos that defines the curves of the fractal path\n// it returns the displacement at a given point. freq was used to explore diferent scales \nvec3 pitpath(float ti) { \n\tfloat freq=.5;\n    ti*=freq;\n\tfloat x=cos(cos(ti*.35682)+ti*.2823)*cos(ti*.1322)*1.5;\n\tfloat y=sin(ti*.166453)*4.+cos(cos(ti*.125465)+ti*.17354)*cos(ti*.05123)*2.;\n\tvec3  p=vec3(x,y,ti/freq);\n\treturn p;\n}\n\n// Distance Estimation function\n\nfloat de(vec3 pos) {\n    float x=1.-smoothstep(5.,8.,abs(pos.x)); // aux variable used for washing the colors away from the path in the fractal\n\tpos.y+=.9; // offset y position for the fractal object\n\tpos.xy-=pitpath(pos.z).xy; // distortion of coordinates based on the path function\n    mat2 rot=rot2D(.5); // rotation matrix used in the fractal iteration loop\n    float organic=smoothstep(.5,1.,-sin(pos.z*.005)); // used for the \"organic\" part of the fractal\n    mat2 rot2=rot2D(organic*.4); // rotation matrix used in the fractal iteration loop, it mutates the fractal to kinda \"organic\" shapes\n    float fold=2.6+sin(pos.z*.01)+organic*1.5; // fold is a parameter for one of the operations inside the fractal loop\n    pos.x+=pow(organic,.2)*fold*.75; // x offset for the organic part\n    pos.y+=organic*.3; // y offset for the organic part\n\tpos.z=abs(5.-mod(pos.z,10.)); // tiling for repeating the fractal along the z axis\n    pos.x=abs(10.-mod(pos.x+10.,20.)); // tiling for reapeating along x axis\n\tpos.x-=fold; // x offset to center the fractal\n    vec4 p=vec4(pos,1.); // w value will be used for calculating the derivative\n    vec3 m=vec3(1000.); // for orbit trap coloring\n    int it=int(8.+fin*2.); // gives more iterations to the fractal at the end\n    // Amazing Surface fractal formula by Kali\n    // Derived from Mandelbox by tglad\n    for (int i=0; i<it; i++) {\n\t\tp.xz=clamp(p.xz,-vec2(fold,2.),vec2(fold,2.))*2.0-p.xz; // fold transform on xz plane\n\t\tp.xyz-=vec3(.5,.8,1.); // translation transform\n        p=p*(2.-organic*.2)/clamp(dot(p.xyz,p.xyz),.25,1.)-vec4(2.,.5,-1.,0.)*x; // scale + spheric fold + translation transform\n\t\t// rotation transforms\n        p.xy*=rot;\n        p.xz*=rot2; // rotations on xz and yz give the \"organic\" feel for the \"alien reefs\" part\n        p.yz*=rot2; \n        m=min(m,abs(p.xyz)); // saves the minimum value of the position during the iteration, used for \"orbit traps\" coloring\n    }\n    // fractal coloring (fcol global variable)\n    fcol=vec3(1.,.3,.0)*m*x; \n    fcol=max(fcol,length(p)*.0015*vec3(1.,.9,.8)*(1.-fin))*(1.+organic*.5);\n    return (max(p.x,p.y)/p.w-.025*(1.-fin))*.85; // returns the distance estimation to the fractal's surface, with some adjustment towards the end\n}\n\n\n// -------------------------------------------------------------------------------------------\n\n// RAYMARCHING\n\n// Returns the perpendicular vector to the surface at a given point\nvec3 normal(vec3 p) {\n    vec3 d=vec3(0.,det*2.,0.);\n\treturn normalize(vec3(de(p-d.yxx),de(p-d.xyx), de(p-d.xxy))-de(p));\n}\n\n\n// Ambient occlusion and soft shadows, classic iq's methods\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat td=0., ao=0.;\n    for(int i=0; i<6; i++) {\n\t\ttd+=.05;\n\t\tfloat d=de(p-n*td);\n        ao+=max(0.,(td-d)/td);\n    }\n\treturn clamp(1.-ao*.1,0.,1.);\n}\n\n\nfloat shadow(vec3 p) {\n\tfloat sh=1.,td=.1;\n    for (int i=0; i<50; i++) {\n\t\tp+=ldir*td;\n        float d=de(p);\n\t\ttd+=d;\n        sh=min(sh,10.*d/td);\n        if (sh<.05) break;\n    }\n    return clamp(sh,0.,1.);\n}\n\n// Lighting\n\nvec3 shade(vec3 p, vec3 dir, vec3 n, vec3 col) {\n\tfloat sha=shadow(p); \n    float aoc=ao(p,n);\n    float amb=.25*aoc; // ambient light with ambient occlusion\n    float dif=max(0.,dot(ldir,-n))*sha; // diffuse light with shadow\n    vec3 ref=reflect(dir,n); // reflection vector\n    float spe=pow(max(0.,dot(ldir,ref)),10.)*.7*sha; // specular lights    \n    return col*(amb+dif)+spe*suncol; // lighting applied to the surface color\n}\n\n// Raymarching\n\nvec4 march(vec3 from, vec3 dir, vec3 camdir) {\n    // variable declarations\n\tvec3 p=from, col=vec3(0.1), backcol=col;\n    float totdist=0., d=0.,sdet, glow=0., lhit=1.;\n\t// the detail value is smaller towards the end as we are closer to the fractal boundary\n   \tdet*=1.-fin*.7;\n    // raymarching loop to obtain an occlusion value of the sun at the camera direction\n    // used for the lens flare\n    for (int i=0; i<70; i++) {\n    \tp+=d*ldir; // advance ray from camera pos to light dir\n        d=de(p)*2.; // distance estimation, doubled to gain performance as we don't need too much accuracy for this\n        lhit=min(lhit,d); // occlusion value based on how close the ray pass from the surfaces and very small if it hits \n        if (d<det) { // ray hits the surface, bye\n            break;\n        }\n    }\n    // main raymarching loop\n    for (int i=0; i<150; i++) {\n    \tp=from+totdist*dir; // advance ray\n        d=de(p); // distance estimation to fractal surface\n        sdet=det*(1.+totdist*.1); // makes the detail level lower for far hits \n        if (d<sdet||totdist>maxdist) break; // ray hits the surface or it reached the max distance defined\n    \ttotdist+=d; // distance accumulator  \n        glow++; // step counting used for glow\n    }\n    float sun=max(0.,dot(dir,ldir)); // the dot product of the cam direction and the light direction using for drawing the sun\n    if (d<.2) { // ray most likely hit a surface\n    \tp-=(sdet-d)*dir; // backstep to correct the ray position\n        vec3 c=fcol; // saves the color set by the de function to not get altered by the normal calculation\n        vec3 n=normal(p); // calculates the normal at the ray hit point\n        col=shade(p,dir,n,c); // sets the color and lighting\n    } else { // ray missed any surface, this is the background\n        totdist=maxdist; \n    \tp=from+dir*maxdist; // moves the ray to the max distance defined\n        // Kaliset fractal for stars and cosmic dust near the sun. \n        vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;\n        for (int i = 0; i < 10; i++) st = abs(st) / dot(st,st) - .8;\n        backcol+=length(st)*.015*(1.-pow(sun,3.))*(.5+abs(st.grb)*.5);\n        sun-=length(st)*.0017;\n        sun=max(0.,sun);\n\t\tbackcol+=pow(sun,100.)*.5; // adds sun light to the background\n    }\n    backcol+=pow(sun,20.)*suncol*.8; // sun light\n    float normdist=totdist/maxdist; // distance of the ray normalized from 0 to 1\n    col=mix(col,backcol,pow(normdist,1.5)); // mix the surface with the background in the far distance (fog)\n    col=max(col,col*vec3(sqrt(glow))*.13); // adds a little bit of glow\n\t// lens flare\n    vec2 pflare=dir.xy-ldir.xy;\n    float flare=max(0.,1.0-length(pflare))-pow(abs(1.-mod(camdir.x-atan(pflare.y,pflare.x)*5./3.14,2.)),.6);\n\tfloat cflare=pow(max(0.,dot(camdir,ldir)),20.)*lhit;\n    col+=pow(max(0.,flare),3.)*cflare*suncol;\n\tcol+=pow(sun,30.)*cflare;\n    // \"only glow\" part (at sec. 10)\n    col.rgb=mix(col.rgb,glow*suncol*.01+backcol,1.-smoothstep(0.,.8,abs(time-10.5)));\n    return vec4(col,normdist); // returns the resulting color and a normalized depth in alpha\n}\t//(depth was going to be used for a postprocessing shader) \n\n\n// -------------------------------------------------------------------------------------------\n\n// Camera and main function\n\n// I learnt this function from eiffie,\n// it takes a direction, a reference up vec3\n// and returns the rotation matrix to orient a vector\nmat3 lookat(vec3 dir, vec3 up){\n    dir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\n// the path of the camera at a given point of time\nvec3 campath(float ti) {\n    float start=pow(max(0.,1.-ti*.02),3.); // interpolation curve for the starting camera\n\tvec3 p=pitpath(ti); // path displacement of the fractal \n    p*=1.-start; // the camera gradually ends following the fractal when, that happens when start=0\n    p+=vec3(start*30.,start*25.,0.); // position offset for starting camera curve   \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 dir=normalize(vec3(uv,1.)); // ray direction  \n\ttime=mod(iTime,162.); // time loop\n    fin=smoothstep(145.,147.5,time); // aux variable used for the end sequence\n    // camera accelerations and slow downs\n    float acel1=smoothstep(11.,12.,time)*7.31;\n    float acel2=smoothstep(99.,100.,time)*4.;\n    float desacel1=smoothstep(77.,78.,time)*5.;\n    float desacel2=fin*9.5;\n\tfloat tt=time;\n\t// freeze BW frame\n    if (abs(tt-25.5)<.5) tt=25.;\n    float acel=acel1+acel2-desacel1-desacel2;\n\t// time variable\n    float t=tt*(3.6+acel)-acel1*11.-acel2*99.+desacel1*77.+desacel2*147.5;\n    t+=smoothstep(125.,145.,time)*243.;\n    vec3 from=campath(t); // camera position\n    from.y-=desacel2*.035; // camera offset on 2nd slow down\n\tvec3 fw=normalize(campath(t+3.)-from); // camera forward direction\n    from.x-=fw.x*.1; // camera x offset based on the forward direction\n    dir=dir*lookat(fw*vec3(1.,-1.,1.),vec3(fw.x*.2,1.,0.)); // re-orientation of the ray dir with the camera fwd dir\n\tldir=normalize(ldir); // light dir normalization \n\tvec4 col=march(from, dir, fw); // get color from raymarching and background\n    col.rgb=mix(vec3(length(col.rgb)*.6),col.rgb,.85-step(abs(tt-25.),.1)); // BW freeze frame sequence coloring\n\tcol.rgb*=1.-smoothstep(25.,26.,time)+step(25.1,tt); // BW freeze frame sequence fading\n    col.rgb*=1.+step(abs(tt-25.),.1);\n    // PVM Logo color mixing\n    vec4 pvm=logo(uv*1.5+vec2(.9,.5))*smoothstep(1.,3.,time+uv.x*2.)*(1.-smoothstep(7.5,8.,time+uv.x*2.));\n    col.rgb=mix(col.rgb,pvm.rgb,pvm.a);\n    // fade in from black\n    col.rgb*=smoothstep(0.,4.,time);\n    // fade out to black\n    col.rgb*=1.-smoothstep(160.,162.,time);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}