{"ver":"0.1","info":{"id":"DdGXW1","date":"1680991062","viewed":81,"name":"revision 2023 shaderjam shader","username":"Exca","description":"Shader made during revision 2023 shader jam remotely. Did not show correctly on screen due to some odd network issues & missing fftIntegrated here.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["revision","jam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fGlobalTime = 0.0;\n\n\nfloat fftS = 0.0;\nfloat fftI = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\t\n  \n  //c = 1.0-c;//\n  \n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float fGlobalTime = 0.0;\n\n\nfloat fftS = 0.0;\nfloat fftI = 0.0;\n\n// Matrix rotations.\nmat3 RotX(float a)\n{\n    return mat3(\n        1.0, 0.0, 0.0, \n        0.0, cos(a), -sin(a), \n        0.0, sin(a), cos(a)\n    );\n}\nmat3 RotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, sin(a), \n        0.0, 1.0, 0.0, \n        -sin(a), 0.0, cos(a)\n    );\n}\nmat3 RotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.0, \n        sin(a), cos(a), 0.0, \n        0.0, 0.0, 1.0\n    );\n}\nmat3 Rot(float x,float y,float z)\n{\n    return RotX(x)*RotY(y)*RotZ(z);\n}\n\nvec3 repeat( vec3 p, vec3 q)\n{\n  return mod( p + 0.5 *q, q)- 0.5*q;\n}\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam);\n  vec3 right = normalize( cross(vec3(0,1,0), forward));\n  vec3 up = normalize( cross(forward, right));\n  return normalize( uv.y * up + uv.x * right + fov * forward);\n}\n\nfloat rbox( vec3 p, vec3 b, float r)\n{\n  vec3 q = abs(p)-b;\n  return length( max(q, 0.0)) + min(max(q.x, max(q.y, q.z)),0.0)-r;\n}\n\nfloat sphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat ground( vec3 p, float h)\n{\n  return p.y  - h;\n}\n\nvec3 U(vec3 a, vec3 b)\n{\n  return a.x < b.x ? a : b;\n}\n\nfloat gh( vec3 p)\n{\n  vec2 gx = p.xz;\n  vec2 sined = vec2( sin(gx.x*0.4), cos(gx.y*0.3));\n  sined += (Rot(0.0, 0.7,0.0)*vec3(sined*3.4+vec2(0.5+fftS,1.3),0.0)).xy*0.75;\n  sined += (Rot(0.0, 1.7,0.0)*vec3(sined*7.3+vec2(2.5-40.0*sin(fftI*0.4-0.3),1.3),0.0)).xy*0.5;\n  sined += (Rot(0.1, 0.7,3.0)*vec3(sined*16.5+vec2(4.5+sin(fftI)*4.0,3.3),0.0)).xy*0.2;\n  return length(sined)*0.15;\n  \n}\n\nvec3 map( vec3 p)\n{\n  vec3 op = p * Rot(0.0,fftI*2.1, 0.0) + vec3(0.0, -0.75, 0.0);\n  \n  vec2 towerIndex = floor( op.xz/0.2); \n   op = repeat( op, vec3( 8.0, 0.0, 8.0));\n  float s1 = sphere(op + vec3( 0.0, sin(fGlobalTime)*0.0-0.5, 0.0), length(op)*0.3+ 1.25+smoothstep(0.005, 0.075,fftS)*4.0);\n  float b1 = rbox( \n    repeat(op, vec3( 0.4+fftS, 0.0, 0.4)), \n    vec3(0.1+fftS*30.0, 45.0 * fftS + 0.25 + sin(towerIndex.y+fftI)+cos(towerIndex.x+fftI), 0.1), 0.01);\n  \n  b1 = max(s1, b1);\n  \n  b1 = min(max(s1, ground(p, 0.5)), b1);\n  \n  \n  float h = gh(p + vec3(fftI, -fftI, -fftI*3.3));\n  float g1 = ground(p, h*0.1);\n  \n  vec3 mat = U(\n    vec3( b1, 2.0, 0.0),\n    vec3( g1, 1.0, 0.0)\n  );\n  \n  return mat;\n}\n\nvec3 march(vec3 cam, vec3 rd, out vec3 p, out float t)\n{\n  p = cam; t = 0.0;\n  for(int i = 0; i < 100; i++)\n  {\n    p = cam + rd * t;\n    vec3 r = map(p);\n    t+=r.x;\n    if(r.x < 0.01)\n    {\n      return r;\n    }\n    if(t > 50.0)\n    {\n      t = 50.0;\n      return vec3(-1.0);\n    }\n  }\n  return vec3(-1.0);\n}\n\nvec3 normal( vec3 p )\n{\n  vec2 e = vec2(0.01, 0.0);\n  vec3 c = map( p);\n  return normalize( vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  \n  )-c.x);\n}\n\nfloat light(vec3 p, vec3 l, vec3 n)\n{\n  return max(0.0, dot(normalize(l-p), n));\n}\n\nvec3 col1 = vec3(1.0, 0.65, 0.2);\nvec3 col2 = vec3(0.2, 0.65, 1.0);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 c = vec3(0.0);\n  fGlobalTime = iTime;\n  fftS = texture(iChannel1,vec2(0.25,0.5)).r*0.01;\n  fftI = /*texture(texFFTIntegrated, 0.25).r*1.75*/ fGlobalTime*0.3 + fftS*0.1;\n  \n  \n  vec3 cam  = vec3( sin(sin(fftI)*0.001)*5.0, cos(fftI* 0.1)*3.0+5.2, cos(fftI*0.001)*3.0);\n  vec3 light1 = vec3( sin(fGlobalTime), 2.0, 1.0);\n  vec3 target = vec3(0,0.85,0);\n  float fov = 0.9 + step( mod(fftI,2.0), 1.0)*2.0  -0.24* step( mod(fftI*0.5,2.0), 1.0);\n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  vec3 marchP = cam; float marchT = 0.0;\n  vec3 result = march( cam, rd, marchP, marchT);\n  \n  if(result.y > 1.5)\n  {\n    // ball\n    vec3 n =  normal(marchP);\n    float l1 = light(marchP, light1, n);\n    float gridI = mod( floor(marchP.x) + floor(marchP.z), 2.0 );\n    c = vec3(1.0)  * l1 * mix( col1, col2, gridI);\n  }\n  else if(result.y > 0.5)\n  {\n    //ground\n    vec3 n =  normal(marchP);\n    float l1 = light(marchP, light1, n);\n    float gridI = mod( floor(marchP.x) + floor(marchP.z), 2.0 );\n    c = 0.25* mix(vec3(0.0, 0.4, 1.0), vec3(1.4,0.4, 1.0), -marchP.y*fftS*130.0)  * l1;\n  }\n  \n  \n  else \n  {\n    //bg\n  }\n  uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  \n  uv -= vec2(0.5, 0.15);\n  uv *= 0.99;\n  uv += vec2(0.5, 0.15);\n  vec3 prev = texture(iChannel0, uv).rgb;\n  \n  vec3 oldc = c;\n  c = mix( c*0.5 + prev*0.75, c*0.5+ prev*1.5, smoothstep(0.0, 0.02, fftS));\n  c = max(oldc*0.02,c);\n  float modt = mod( fftI, 4.0);\n  if(modt < 1.0) c.rgb = c.grb;\n  else if(modt < 2.0) c.rgb = c.brg;\n  else if(modt < 3.0) c.rgb = c.rbg;\n  \n  \n  //c = 1.0-c;//\n  \n\tfragColor = vec4(c, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}