{"ver":"0.1","info":{"id":"DlSGD1","date":"1673207338","viewed":522,"name":"animated ball split","username":"snolot","description":"try to create an animated fractured ball. code borrowed from 'tdhooper': https://www.shadertoy.com/view/WlKyzW ","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["sdf","animation","ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PHI 1.618033988749895\n#define SPEED .1\n#define saturate(x) clamp(x, 0., 1.)\n#define FOV 3.\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    //return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    //return pal(n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    //return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    //return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n}\n\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// Rotate on axis, blackle\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n\n// Sign but returns -1 instead of 0\nvec3 boolSign(vec3 v) {\n    return max(vec3(0), sign(v)) * 2. - 1.;\n}\n\n// Closest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3;\n    ap = abs(p);\n    v = vec3(PHI, 1, 0);\n    v2 = v.yzx;\n    v3 = v2.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    return normalize(v) * boolSign(p);\n}\n\n// Closest dodecahedron vertex\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3, v4;\n    ap = abs(p);\n    v = vec3(PHI);\n\tv2 = vec3(0, 1, PHI + 1.);\n\tv3 = v2.yzx;\n    v4 = v3.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    if (distance(ap, v4) < distance(ap, v)) v = v4;\n    return normalize(v) * boolSign(p);\n}\n\n// Second closest dodecahedron vertex\nvec3 secondDodecahedronVertex(vec3 p, vec3 iv, vec3 dv) {\n    // Find which side of the icosahedron vertex -> dodecahedron vertex line we're on\n    float side = sign(dot(p, cross(iv, dv)));\n    // Rotate dodecahedron vertex around the dodecahedron face\n    return erot(dv, iv, PI * 2. / 5. * side);\n}\n\n// The model to explode\nfloat object(vec3 p) {\n    pR(p.xz, 1.2);\n    pR(p.xy, .3);\n    float d = length(p) - .3;//fBox(p, vec3(.25 - .02)) - .02;\n    d = max(d, -d - .015);\n    return d;\n}\n\n// https://iquilezles.org/articles/functions\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat pausingWave(float x, float a, float b) { //    ___          ___          ___\n    x = abs(fract(x) - .5) * 1. - .5 + a;      //   /   \\        /   \\        /   \\ \n    return smoothstep(0., a - b, x);           // --     --------     --------     ------\n}\t\t\n\nvec4 map2(vec3 p) {\n    tRotate(p.xz, iTime * .5);\n    tRotate(p.xy, iTime * .75);\n    // Three closest vertices of a spherical pentakis dodecahedron\n    // or, three closest faces of a buckyball\n    vec3 a = icosahedronVertex(p);\n    vec3 b = dodecahedronVertex(p);\n    vec3 c = secondDodecahedronVertex(p, a, b);\n\n    float d = 1e12;\n\n    vec3 pp = p;\n    \n    // Render the nearest three fragments to get\n    // a clean distance estimation\n    \n    vec3 face = step(vec3(vmax(abs(p))), abs(p)) * sign(p);\n    float faceIndex = max(vmax(face * vec3(0,1,2)), vmax(face * -vec3(3,4,5)));\n    vec3 col = spectrum(faceIndex / 6. + .1 + .5);\n    \n    for (int i = 0; i < 3; i++) {\n\n        // Offset space\n        float t = mod((iTime - dot(a.xy, vec2(1,-1)) / 6.) / 3., 1.);\n        float t2 = min(t * 1.85, 1.);\n        float explode = 1. - pow(1. - t2, 10.); // expand\n        explode *= 1. - pow(t2, 5.); // contract\n        t2 = max(t - .53, 0.) * 1.2;\n        float wobble = sin(expImpulse(t2, 20.) * 2.2 + pow(3. * t2, 1.5) * 2. * PI * 2. - PI) * smoothstep(.4, .0, t2) * .15;\n        float anim = wobble + explode;\n        p -= a * anim / 2.8;\n\n        // Build boundary edge of face\n        float edgeA = dot(p, normalize(b - a));\n        float edgeB = dot(p, normalize(c - a));\n        float edge = max(edgeA, edgeB);\n\n        // Intersect with object\n        d = min(d, max(object(p), edge));\n        \n        /*float thick = .033;\n         float gap = .005;\n\n        // block edge\n        float r = .05;\n        float cut = -fBox(abs(p) - (1. + r + gap), vec3(1.)) + r;\n        d = smax(d, -cut, thick / 2.);*/\n\n        // Reset space for next iteration\n        p = pp;\n        \n        // Cycle faces for next iteration\n        vec3 aa = a;\n        a = b;\n        b = c;\n        c = aa;\n    }\n    \n    /*vec3 ap = abs(p);\n    float l = sqrt(sqrt(1.) / 3.);\n    vec3 plane = cross(abs(face), normalize(vec3(1)));\n    float groove = max(-dot(ap.yzx, plane), dot(ap.zxy, plane));\n    d = smax(d, -abs(groove), .01);\n    \n    float thick = .033;\n     float gap = .005;\n    \n    // block edge\n    float r = .05;\n    float cut = -fBox(abs(p) - (1. + r + gap), vec3(1.)) + r;\n    d = smax(d, -cut, thick / 2.);\n*/\n\n    return vec4(d, col);\n}\n\n\nvec4 map(vec3 p) {\n    if (iMouse.x > 0. && iMouse.y > 0.) {\n        pR(p.yz, (.5 - iMouse.y / iResolution.y) * PI / 2.);\n        pR(p.xz, (.5 - iMouse.x / iResolution.x) * PI * 2.);\n    }\n    return map2(p);\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, float r )\n{\n\tvec3 oc = ro;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\n    // iq optimisation, stop looking for occluders when we\n    // exit the bounding sphere for the model\n    vec2 bound = iSphere(ro, rd, .55);\n    tmax = min(tmax, bound.y);\n    \n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<100; i++ )\n    {\n        vec4 hit = map2( ro + rd*t );\n        float h = hit.x;\n        if (hit.y > 0.) { // don't create shadows from bounding objects\n            res = min( res, 10.0*h/t );\n        }\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    //vec3 col = vec3(0);\n    uv.x-=0.025;\n    /*vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;*/\n    \n   /*     float speed = .25 / 10.5;\n    float time = mod(iTime, 290.);\n    time -= 10.5;\n    if (time > 167.) time -= 167.; else\n    if (time > 63.) time -= 63.;\n    time -= 5.25;\n\ttime *= speed;\n    \n    vec2 rot = vec2(\n            iTime * SPEED * PI,//had to slightly modify \\/ this value due to an issue reported by Fabrice\n            mix(sin(iTime * SPEED) * PI / 8., PI / 2. - 1e-5, saturate(exp(-iTime + 10.5))));\n    */\n    \n    \n    vec3 camPos = vec3(0,0,3.2);\n    vec3 rayDirection = normalize(vec3(p,-4));\n    \n    vec3 rayPosition = camPos;\n    \n    /*vec3 rayDirection =  normalize(vec3(uv, FOV));\n    vec3 rayPosition = vec3(0, 0, -2);\n    \n    tRotate(rayDirection.yz, rot.y);\n    tRotate(rayDirection.xz, rot.x);\n    //tRotate(light.xz, rot.x);\n    tRotate(rayPosition.yz, rot.y);\n    tRotate(rayPosition.xz, rot.x);\n    */\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = false;\n    //vec3 bgcol = vec3(.007);\n    vec3 bgcol = mix(vec3(0.07),vec3(0.),length(uv));\n    //col = bg;\n        \n    vec3 col = bgcol;\n    vec4 dc;\n    \n    for (int i = 0; i < 150; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        dc = map(rayPosition);\n        dist = dc.x;\n        \n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n\n        if (rayLength > 7. && rayLength < 9.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        \n        \n        col = dc.yzw;\n        vec3 nor = calcNormal(rayPosition);        \n        vec3 lig = normalize(vec3(-.33,.3,.25));\n        vec3 lba = normalize( vec3(.5, -1., -.5) );\n        vec3 hal = normalize( lig - rayDirection );\n        float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-rayPosition.y,0.0,1.0);\n        float fre = pow( clamp(1.0+dot(nor,rayDirection),0.0,1.0), 2.0 );\n\n        vec3 ldd = normalize(vec3(0,1,0));\n        \n        float sss=0.5;\n        float sssteps = 10.;\n        for(float i=1.; i<sssteps; ++i){\n            float dist = i*0.2;\n            sss += smoothstep(0.,1.,map(rayPosition+ldd*dist).x/dist)/(sssteps*1.5);\n        }\n        sss = clamp(sss,0.0,1.0);\n        \n        \n        \n        // iq optimisation, skip shadows when we're facing away\n        // from the light\n\t\t//if( dif > .001) dif *= softshadow( rayPosition, lig, 0.001, .9 );\n        \n        float occ = 1.;\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n            dif *\n            (0.04 + 0.96*pow( clamp(1.0+dot(hal,rayDirection),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 2.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 1.55*bac*vec3(0.25,0.25,0.25)*occ*vec3(2,0,1);\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n        col = col*lin;\n        \n        vec3 refl = reflect( rayDirection, nor );\n        col.rgb += texture( iChannel0, refl ).xyz * .6;\n        \n\t\tcol *= sss + spe*vec3(1.10,0.90,0.70);\n        \n        \n        col = mix(col, bgcol, 1.0 - exp2(-0.2 * pow(rayLength - 1., 3.)));\n        \n        \n    }\n\n    col = pow(col, vec3(1./1.6));\n    //col = pow(col,vec3(2.2));\n    \n    fragColor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}