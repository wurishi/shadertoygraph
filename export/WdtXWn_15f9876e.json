{"ver":"0.1","info":{"id":"WdtXWn","date":"1572490497","viewed":197,"name":"Emakina","username":"snolot","description":"My compagny logo","likes":13,"published":1,"flags":8,"usePreview":0,"tags":["sdf","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks to XT95 to implement SSS in this shadertoy:\n// https://www.shadertoy.com/view/MsdGz2\n\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 90\n#define RAYMARCHING_JUMP 1.\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\n#define ADD(z) x = min(x, z)\n#define SADD(z, k) x = smoothAdd(x, z, k)\n#define SUB(z) x = max(-z, x)\n#define ZERO (min(iFrame,0))\n\n#define MOD3 vec3(.16532,.17369,.15787)\n#define MOD2 vec2(.16632,.17369)\n\nconst float PI = 3.14159265359, ASP = 2.36550308, WW = 0.039930556, LH = 0.451595072, RM = 0.506145483, RN = 0.436, SA = 0.25, SR = 0.35, SY = 0.36;\nconst int MAX_MARCHING_STEPS = 128;\nconst float MIN_DIST = 3.2, MAX_DIST = 5.5, EPSILON = 0.0001;\nconst float ANI_DUR = 20.0, SLIDE_DUR = 2.0, FADE_DUR = 5.0;\n\nfloat snoise(vec3 v);\n\nfloat anitime = 0.0;\n\n//----------------------------------------------------------\n\nfloat hash12(vec2 p)\n{\n    p  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\nfloat Hash(vec3 p)\n{\n    p  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat Noise3d(in vec3 p)\n{\n    vec2 add = vec2(1.0, 0.0);\n    p *= 10.0;\n    float h = 0.0;\n    float a = .3;\n    for (int n = 0; n < 4; n++)\n    {\n        vec3 i = floor(p);\n        vec3 f = fract(p); \n        f *= f * (3.0-2.0*f);\n\n        h += mix(\n            mix(mix(Hash(i), Hash(i + add.xyy),f.x),\n                mix(Hash(i + add.yxy), Hash(i + add.xxy),f.x),\n                f.y),\n            mix(mix(Hash(i + add.yyx), Hash(i + add.xyx),f.x),\n                mix(Hash(i + add.yxx), Hash(i + add.xxx),f.x),\n                f.y),\n            f.z)*a;\n         a*=.5;\n        p += p;\n    }\n    return h;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    p.xz -= iTime*7.+sin(p.z*.3)*3.;\n    p.y -= iTime*.5;\n\n    return (max(Noise3d(p*.008+.1)-.1,0.0)*Noise3d(p*.1))*.3;\n}\n\n//------------------------------------------------------------------  SIGNED PRIMITIVES\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2./repetitions*PI;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat smoothAdd( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sheer(vec3 p, float a, vec2 o, vec3 b ) {\n\tp.xy -= 0.5*b.xy;\n\tp.xy += b.xy*o/2.0; p.x += a*p.y;p.xy -= b.xy*o/2.0; \n\treturn fBox(p, b);\n}\n\nvec4 opElong( in vec3 p, in vec3 h ){\n    return vec4( p-clamp(p,-h,h), 0.0 );\n}\n\nfloat time;\nvec3 anim(float offset) {\n\treturn vec3(0.0,0.5*(1.0-smoothstep(0.0, 1.0, time-offset)),0.0) + vec3(0.0,0.0,0.2*smoothstep(ANI_DUR-SLIDE_DUR-FADE_DUR, ANI_DUR-SLIDE_DUR, time-offset));\n}\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y+q.z*1.5-h)/3.0 );\n}\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n\tfloat t = 1., dt = SLIDE_DUR/12.0;\n\n\t/*float d = pos.y;\n    pos -= snoise(pos*0.15);\n    vec3 q = pos-vec3(0.,5.,0.);\n    pModPolar(q.xz, 6.);\n    q -= vec3(20,sin(iTime * .2) * 20.,0);\n\td = fOpUnionRound(d, fBox(q,vec3(5.)),4.4);\n    q = pos;\n    pModPolar(q.xz,8.);\n\td = fOpUnionRound(d, fBox(q,vec3(6.,20.,6.)),6.);\n\treturn d;*/\n\tfloat d = pos.y;\n\n\tfloat bassScale = 1.;\n\tfloat midScale = 1.;\n   \tpos -= snoise(pos*0.05) ;\n    vec3 q = pos;\n    /*pR45(q.xz);\n\tfloat d = pyramid(q,20.);\n    pModPolar(q.xz,4.); \n    q.x-=11.;\n    d = min(pyramid(q,5.),d); */\n    q -= vec3(0,/*-50. +sin(iTime * .1) * 75.*/-40. + min(float(iFrame)*.1, 60.),0);\n    vec3 q2 = q - vec3(-9. * bassScale,0.,0);\n    vec3 q3 = q - vec3(9. * bassScale,0.,0);\n    t-=dt;\n    //d = min(-8.55+distance(pos.xyz,vec3(0.))/20.+pos.y-max(.1,texture(iChannel0,pos.xz/1.).x)*0.05,d);\n    d = min(-1.55+distance(pos.xyz,vec3(0.))/8.+pos.y-max(.1,texture(iChannel0,pos.xz/100.).x)*3.1,d);\n    //d = max(-fBox(pos+vec3(0.,-3.,5.5),vec3(1.,1.,2.5)),d);\n    ////d = fOpUnionRound(d, max(-fBox(pos+vec3(0.,-3.,5.5),vec3(1.,1.,2.5)),d), 8.4);\n\n\n    d = fOpUnionRound(d, fBox(q,vec3(2.5 * bassScale, 11. * bassScale, 2.5 * bassScale) + anim(t)),4.4);\n    t-=dt;\n    d = fOpUnionRound(d, fBox(q2,vec3(2.5 * bassScale, 11. * bassScale, 2.5 * bassScale) + anim(t)),4.4);\n    t-=dt;\n    d = fOpUnionRound(d, fBox(q3,vec3(2.5 * bassScale, 11. * bassScale, 2.5 * bassScale) + anim(t)),4.4);\n    t-=dt;\n    vec3 q4 = q - vec3(0,18. * bassScale,0);\n    vec3 q5 = q - vec3(0,27. * bassScale,0);\n    vec3 q6 = q - vec3(0.,36. * bassScale,0);\n    \n    d = fOpUnionRound(d, fBox(q4,vec3(11. * bassScale,2.5 * bassScale,  2.5 * bassScale)),4.4);\n    d = fOpUnionRound(d, fBox(q5,vec3(11. * bassScale,2.5 * bassScale, 2.5 * bassScale)),4.4);\n    d = fOpUnionRound(d, fBox(q6,vec3(11. * bassScale,2.5 * bassScale, 2.5 * bassScale)),4.4);\n\n\n    d = min(-2.55+distance(pos.xyz,vec3(0.))/8.+pos.y-max(.1,texture(iChannel0,pos.xz/100.).x)*2.1,d);\n    //d = max(-fBox(pos+vec3(0.,-3.,5.5),vec3(1.,1.,2.5)),d);\n\n    return d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, out float drift, inout float depth, in vec2 scUV )\n#else\nfloat castRay( in vec3 ro, in vec3 rd, out float drift, in vec2 scUV )\n#endif\n{\n\t//float t = 0.0;\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n\tfloat res;\n\tfloat d = hash12(scUV);\n\tdrift = 0.0;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*d;\n\t\tres = map( pos );\n\t\tif(res < precis || d > 110.) break;\n\t\t//t += res*RAYMARCHING_JUMP;\n\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t\tdrift +=  fogmap(pos, d);\n\t\td += min(res*.65 + d * .002, 4.0);\n\t}\n\n\tdrift = min(drift, 1.0);\n\treturn d;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale(line117) & inverse the color(line 118)\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd ) {\n  float res = 1.0;\n  float t = 0.0005;                 // selfintersection avoidance distance\n  float h = 1.0;\n  for( int i=0; i<40; i++ ) {\n    h = map(ro + rd*t);\n    res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n    t += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n  }\n  return clamp(res,0.0,1.0);\n}\n\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// gamma correction\n\t// col = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t// vigneting\n\t//col *= 0.7+.8*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 1.95 );\n\tcol*=1.-pow(length(uv*uv*uv*uv)*1.1,6.);\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\tfloat fg;\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,fg,depth, uv);\n\t#else\n\tfloat t = castRay(ro,rd,fg, uv);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n\t\n\n    float thi = thickness(pos, nor, 2., 1.5);\n\n    vec3 lpos1 = vec3(0.0,35.+sin(iTime * 2.)*5.,0.0);\n\tvec3 ldir1 = normalize(lpos1-pos);\n\tfloat latt1 = pow( length(lpos1-pos)*.1, 1.5 );\n    float trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\tvec3 diff1 = vec3(.0,.5,1.) * (max(dot(nor,ldir1),0.) ) / latt1;\n\tcol =  diff1;\n\tcol += vec3(.3,.2,.05) * (trans1/latt1)*thi;\n\t\n\n    for(int i = 0; i<6; i++){\n        float angle = float(i)/6.*PI*2.;\n        float radius = 30.;\n        vec3 lpos1 = vec3(cos(angle)*radius,5.,sin(angle)*radius);\n\t\tvec3 ldir1 = normalize(lpos1-pos);\n\t\tfloat latt1 = pow( length(lpos1-pos)*(.3+abs(sin(iTime)*2.)), 1. );\n    \tfloat trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\t\tcol += vec3(.2,.2,.4) * (trans1/latt1)*thi;\n\t}\n    \n\t\n\t\n\tcol *= ao;\n\t\n\tcol = max(vec3(.05),col);\n\tcol = mix(col, vec3(.3, .35, .8), fg * .85);\n\t//col = sqrt( col );\n\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tanitime = fract(iTime / ANI_DUR) * ANI_DUR;\n\n\tfloat time = iTime;\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//uv += uv*dot(uv,uv)*0.1;\n\tvec2 uv = fragCoord.xy - iResolution.xy*0.5;\n    uv /= iResolution.y;\n    \n    // screen deformation\n    //uv += uv*dot(uv,uv)*0.5;\n    \n    // get tile and center\n    uv *= 64.0;\n    vec2 center = floor(uv) + 0.5;\n    uv = uv - center;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\tfloat bassScale = 1.;\n\t//Camera\n\tfloat radius = 70.;\n\tvec3 ro = orbit(PI/2.-.5,PI/2.+time * .5 ,radius);\n\tvec3 ta  = vec3(0.0, (iMouse.y - 128.)/8./* clamp(-2. + sin(iTime * .2) * 60. * bassScale, 0., 80.)*/, 0.0);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, fragCoord.xy );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n\n//------------------------------------------------------------------ NOISE\n//AshimaOptim https://www.shadertoy.com/view/Xd3GRf\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// All credits for this awesome sound to Dave Hoskins ;)\n\n        vec2 add = vec2(1.0, 0.0);\n        #define MOD2 vec2(.16632,.17369)\n        #define MOD3 vec3(.16532,.17369,.15787)\n\n        float tri(in float x){return abs(fract(x)-.5)*2.0;}\n        //----------------------------------------------------------------------------------------\n        //  1 out, 1 in ...\n        float hash11(float p)\n        {\n            vec2 p2 = fract(vec2(p) * MOD2);\n            p2 += dot(p2.yx, p2.xy+19.19);\n            return fract(p2.x * p2.y);\n        }\n        //----------------------------------------------------------------------------------------\n        //  2 out, 1 in...\n        vec2 hash21(float p)\n        {\n            //p  = fract(p * MOD3);\n            vec3 p3 = fract(vec3(p) * MOD3);\n            p3 += dot(p3.xyz, p3.yzx + 19.19);\n           return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n        }\n\n        //----------------------------------------------------------------------------------------\n        ///  2 out, 2 in...\n        vec2 hash22(vec2 p)\n        {\n            vec3 p3 = fract(vec3(p.xyx) * MOD3);\n            p3 += dot(p3.zxy, p3.yxz+19.19);\n            return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n        }\n\n        //----------------------------------------------------------------------------------------\n        //  2 out, 1 in...\n        vec2 Noise21(float x)\n        {\n            float p = floor(x);\n            float f = fract(x);\n            f = f*f*(3.0-2.0*f);\n            return  mix( hash21(p), hash21(p + 1.0), f)-.5;\n            \n        }\n\n        //----------------------------------------------------------------------------------------\n        //  2 out, 1 in...\n        float Noise11(float x)\n        {\n            float p = floor(x);\n            float f = fract(x);\n            f = f*f*(3.0-2.0*f);\n            return mix( hash11(p), hash11(p + 1.0), f)-.5;\n\n        }\n\n\n        //----------------------------------------------------------------------------------------\n        //  2 out, 2 in...\n        vec2 Noise22(vec2 x)\n        {\n            vec2 p = floor(x);\n            vec2 f = fract(x);\n            f = f*f*(3.0-2.0*f);\n            \n            vec2 res = mix(mix( hash22(p),          hash22(p + add.xy),f.x),\n                           mix( hash22(p + add.yx), hash22(p + add.xx),f.x),f.y);\n            return res-.5;\n        }\n\n        //----------------------------------------------------------------------------------------\n        // Fractal Brownian Motion...\n        vec2 FBM22(vec2 x)\n        {\n            vec2 r = vec2(0.0);\n            \n            float a = .6;\n            \n            for (int i = 0; i < 8; i++)\n            {\n                r += Noise22(x * a) / a;\n                a += a;\n            }\n             \n            return r;\n        }\n\n\n        vec2 mainSound( in int samp, float time ){\n        \n            vec2 audio = vec2(.0);\n            for (float t = 0.0; t < 1.0; t+=.5)\n            {\n                time = time+t;\n                vec2 n1 = FBM22( time*(Noise21(time*3.25)*40.0+Noise21(time*.03)*5500.0+9500.0)) * (abs(Noise21(time)))*1.5;\n                vec2 n2 = FBM22( time*(Noise21(time*.4)+1900.0))*abs(Noise21(time*1.5))*1.5;\n                vec2 n3 = FBM22( time*(Noise21(time*1.3)+Noise21(-time*.03)*200.0+1940.0))*(.5+abs(Noise21(time-99.)))*1.5;\n                vec2 s1 = sin(time*3300.+(Noise21(time*.23))*(Noise21(-time*.12)*3000.0+4000.0))*abs(Noise21(time*32.3+199.))*abs(Noise21(-time*.04+9.)+.5)*3.;\n\n                audio += (n1+n2+n3+s1)/4.0;\n            }\n           \n            audio =  clamp(audio, -1.0, 1.0) * smoothstep(0.0, 3.0, time) * smoothstep(180.0, 170.0, time);\n            \n            // float y =  (audio.x + audio.y)/2.;\n\n            \n           float k;\n            {\n                float t = fract(time*2.0);\n                float f = 220.0*exp(-5.0*t);\n                float a = sin( 6.2831*f*t*0.5 );\n                float v = 0.0;\n                v += clamp(a*8.0,-1.0,1.0)*(exp(-10.0*t) + exp(-1.0*t));\n                v += a*8.0*exp(-1.0*t);\n                k = 0.4*v;\n            }\n\n\n            return audio;\n            \n        }\n","name":"Sound","description":"","type":"sound"}]}