{"ver":"0.1","info":{"id":"ssSSWm","date":"1620456043","viewed":127,"name":"Melting Spheres_gld","username":"GoldenThumbs","description":"Just learning some SDF stuff.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sdf","lighting","sphere"],"hasliked":0,"parentid":"ssSXDw","parentname":"SDF-Learning_gld"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float FXAA_SPAN_MAX = 8.0;\n    const float FXAA_REDUCE_MUL = 1.0/8.0;\n    const float FXAA_REDUCE_MIN = 1.0/128.0;\n    \n    vec2 pixelSize = 1.0/iResolution.xy;\n    vec2 UV = fragCoord*pixelSize;\n    \n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float dist = dot(texture(iChannel0, UV).rgb, luma);\n    float lumaNW = dot(texture(iChannel0, UV-pixelSize).rgb, luma);\n    float lumaNE = dot(texture(iChannel0, UV+vec2( pixelSize.x,-pixelSize.y)).rgb, luma);\n    float lumaSW = dot(texture(iChannel0, UV+vec2(-pixelSize.x, pixelSize.y)).rgb, luma);\n    float lumaSE = dot(texture(iChannel0, UV+pixelSize).rgb, luma);\n    \n    float lumaMin = min(dist, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(dist, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    vec2 dir;\n    dir.x =-((lumaNW+lumaNE) - (lumaSW+lumaSE));\n    dir.y = ((lumaNW+lumaSW) - (lumaNE+lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * pixelSize;\n    \n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, UV + dir * (1.0 / 3.0 - 0.5)).rgb +\n        texture(iChannel0, UV + dir * (2.0 / 3.0 - 0.5)).rgb\n    );\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, UV + dir * -0.5).rgb +\n        texture(iChannel0, UV + dir * 0.5).rgb\n    );\n    \n    float lumaB = dot(rgbB, luma);\n    \n    vec3 color = vec3(0.0);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = rgbA;\n    else\n        color = rgbB;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// SDF learning exercise, following this tutorial (with a few minor modifications by myself):\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\n#define M_PI 3.14159265358979323846\n#define M_TWOPI 6.283185307179586\n#define M_INV_PI 1.0 / M_PI\n\nconst int MAX_STEPS = 255;\nconst float NEAR_CLIP = 0.01;\nconst float FAR_CLIP = 100.0;\nconst float EPSILON = 0.0001;\n\nconst float GAMMA = 2.2;\n\nconst vec2 XY_POS[9] = vec2[](\n    vec2(-1,-1),\n    vec2( 0,-1),\n    vec2( 1,-1),\n    \n    vec2(-1, 0),\n    vec2( 0, 0),\n    vec2( 1, 0),\n    \n    vec2(-1, 1),\n    vec2( 0, 1),\n    vec2( 1, 1)\n);\n\nmat3 rotationMatrix(vec3 angle)\n{\n    vec3 tmp;\n    tmp.x = radians(angle.x);\n    tmp.y = radians(angle.y);\n    tmp.z = radians(angle.z);\n    \n    float cosZ = cos(tmp.z);\n    float sinZ = sin(tmp.z);\n    float cosY = cos(tmp.y);\n    float sinY = sin(tmp.y);\n    float cosX = cos(tmp.x);\n    float sinX = sin(tmp.x);\n    \n    return mat3(\n        vec3(cosZ*cosY,(cosZ*sinY*sinX)-(sinZ*cosX),(cosZ*sinY*cosX)+(sinZ*sinX)),\n        vec3(sinZ*cosY,(sinZ*sinY*sinX)+(cosZ*cosX),(sinZ*sinY*cosX)-(cosZ*sinX)),\n        vec3(-sinY,cosY*sinX,cosY*cosX)\n    );\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdfPlane(vec3 pos)\n{\n    return pos.y;\n}\n\nfloat sdfQuad(vec3 pos, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ba = b - a; vec3 pa = pos - a;\n    vec3 cb = c - b; vec3 pb = pos - b;\n    vec3 dc = d - c; vec3 pc = pos - c;\n    vec3 ad = a - d; vec3 pd = pos - d;\n    vec3 nrm = cross(ba, ad);\n    \n    return sqrt(\n       (sign(dot(cross(ba,nrm),pa)) +\n        sign(dot(cross(cb,nrm),pb)) +\n        sign(dot(cross(dc,nrm),pc)) +\n        sign(dot(cross(ad,nrm),pd))<3.0)\n        ?\n        min(min(min(\n        dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n        dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n        dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n        dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n        :\n        dot(nrm,pa)*dot(nrm,pa)/dot2(nrm)\n    );\n}\n\nfloat sdfSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdfBox(vec3 pos, vec3 bounds, float radius)\n{\n    vec3 q = abs(pos) - bounds;\n    return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)), 0.0) - radius;\n}\n\nfloat sdfCylinder(vec3 pos, float height, float radius)\n{\n    vec2 d = abs(vec2(length(pos.xz), pos.y)) - vec2(height, radius);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opUnionSmooth(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opSubtract(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat opSubtractSmooth(float d1, float d2, float k)\n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h);\n}\n\nfloat opIntersect(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat opRound(float d, float h)\n{\n    return d-h;\n}\n\nfloat opOnion(float d, float h)\n{\n    return abs(d) - h;\n}\n\nfloat sdfScene(vec3 pos)\n{\n    //float scn = sdfQuad(pos+vec3(0, 0.7, 0),\n    //                    vec3( 15.0, 0.0, 15.0),\n    //                    vec3(-15.0, 0.0, 15.0),\n    //                    vec3(-15.0, 0.0,-15.0),\n    //                    vec3( 15.0, 0.0,-15.0));\n    float scn = sdfPlane(pos+vec3(0.0, 0.7, 0.0));\n    for(int i = 0; i < 9; i++)\n    {\n        vec2 xyPos = XY_POS[i];\n        vec3 obPos = pos-vec3(xyPos.x * 5.0, 0.75, xyPos.y * 5.0);\n        obPos -= vec3(0.0, sin(iTime + (xyPos.x + xyPos.y) * 0.5), 0.0);\n        float obj = sdfSphere(obPos, 0.5);\n        scn = opUnionSmooth(obj, scn, 1.5);\n    }\n    return scn;\n}\n\nfloat shortestDist2Surf(vec3 eye, vec3 marchingDir, float start, float end)\n{\n    float depth = start;\n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        float dist = sdfScene(eye + depth * marchingDir);\n        dist = abs(dist);\n        if (dist < start)\n            return depth;\n        if (depth >= end)\n            break;\n        depth += dist;\n    }\n    return end;\n}\n\nvec3 rayDir(float fov, vec2 resolution, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = resolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec3 pos_0a = vec3(pos.x + EPSILON, pos.y, pos.z);\n    vec3 pos_0b = vec3(pos.x - EPSILON, pos.y, pos.z);\n    \n    vec3 pos_1a = vec3(pos.x, pos.y + EPSILON, pos.z);\n    vec3 pos_1b = vec3(pos.x, pos.y - EPSILON, pos.z);\n    \n    vec3 pos_2a = vec3(pos.x, pos.y, pos.z + EPSILON);\n    vec3 pos_2b = vec3(pos.x, pos.y, pos.z - EPSILON);\n    \n    return normalize(vec3(\n        sdfScene(pos_0a) - sdfScene(pos_0b),\n        sdfScene(pos_1a) - sdfScene(pos_1b),\n        sdfScene(pos_2a) - sdfScene(pos_2b)\n    ));\n}\n\nfloat calcShadow(vec3 pos, vec3 lightPos, float tMin, float tMax)\n{\n    float res = 1.0;\n    float ph = EPSILON;\n    for (float t=tMin; t<tMax; )\n    {\n        float h = sdfScene(pos + lightPos * t);\n        if (h<EPSILON)\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 16.0*d/max(0.0, t-y));\n        ph = h;\n        t += clamp(h, 0.02, 0.1);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = sdfScene( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat D_GGX(float r4, float NdH)\n{\n\tfloat f = (NdH * r4 - NdH) * NdH + 1.0;\n\treturn r4 / (M_PI * f * f);\n}\n\nfloat V_SmithGGX(float NdL, float NdV, float r4)\n{\n\tfloat V1 = 2.0*NdL*NdV;\n\tfloat V2 = NdL + NdV;\n\treturn 0.5/mix(V1, V2, r4);\n}\n\nvec3 F_Schlick(float u, vec3 f0)\n{\n    float f = pow(1.0-u, 5.0);\n    return f + f0 * (1.0 - f);\n}\n\nvec3 specularBRDF(float NdL, float NdV, float NdH, float LdH, float rougness, vec3 f0, out vec3 F)\n{\n    float d = D_GGX(rougness, NdH);\n    float v = V_SmithGGX(NdL, NdV, rougness);\n    vec3 f = F_Schlick(LdH, f0);\n    \n    return f * vec3(d * v);\n}\n\nvec3 diffuseBRDF(float NdL, float metallic, vec3 F, vec3 albedo)\n{\n    vec3 kD = vec3(1.0) - F;\n    kD *= 1.0 - metallic;\n    \n    return kD * albedo * (NdL * M_INV_PI);\n}\n\nvec3 BRDF(vec3 nrm, vec3 view, vec3 pos, vec3 lightDir, vec3 lightColor, int lightType, vec3 albedo, float roughness, float metallic)\n{\n    const float radius = 10.0;\n    float r4 = pow(roughness, 4.0);\n    float atten = 0.0;\n    vec3 light = vec3(0.0);\n    if (lightType != 0){\n        vec3 toLight = lightDir - pos;\n        light = normalize(toLight);\n        \n        float dist = length(toLight);\n        atten = clamp(1.0 - dist*dist/(radius*radius), 0.0, 1.0);\n    }else{\n        light = normalize(lightDir);\n        atten = 1.0;\n    }\n    vec3 halfWay = normalize(light + view); // half-way vector for blinn-phong specular\n    \n    vec3 f0 = vec3(0.04);\n    f0 = mix(f0, albedo, metallic);\n    \n    float NdV = max(EPSILON, dot(nrm, view));\n    float NdL = max(EPSILON, dot(nrm, light));\n    float NdH = max(EPSILON, dot(nrm, halfWay));\n    float LdH = max(EPSILON, dot(light, halfWay));\n    \n    vec3 shadowPos = pos + EPSILON * nrm;\n    atten *= NdL;\n    atten *= calcShadow(pos, light, 0.1, 5.0);\n    vec3 rad = lightColor * atten;\n    \n    vec3 fresnel = vec3(0.0);\n    vec3 spec = specularBRDF(NdL, NdV, NdH, LdH, r4, f0, fresnel);\n    vec3 diff = diffuseBRDF(NdL, metallic, fresnel, albedo);\n    \n    return (diff + spec) * rad;\n}\n\nvec3 calcLights(vec3 ambient, vec3 albedo, vec2 specInfo, vec3 pos, vec3 nrm, vec3 view)\n{\n    vec3 l_0 = BRDF(nrm, view, pos, vec3(2.0, 1.5, 0.0), vec3(1.0) * 5.0, 0, albedo, specInfo.x, specInfo.y);\n    \n    vec3 finalLit = l_0;\n    finalLit += albedo * ambient;\n    return finalLit;\n}\n\nvec3 getClearCol(vec3 dir)\n{\n    return texture(iChannel0, dir).rgb;\n}\n\nvec3 getCol(vec3 pos, vec3 nrm, vec3 view)\n{   \n    const float rough = 0.2;\n    const float metal = 0.0;\n\n    vec3 k_a = vec3(0.02, 0.02, 0.02);\n    k_a *= calcAO(pos, nrm);\n    \n    vec3 k_d = vec3(0.4, 0.1, 0.1);\n    vec2 k_s = vec2(rough, metal);\n    \n    vec3 color = calcLights(k_a, k_d, k_s, pos, nrm, view);\n    \n    return color;\n}\n\nvec3 render(vec3 eye, vec3 dir, out vec3 nrm, out vec3 pos, out vec3 view, out float dist)\n{\n    dist = shortestDist2Surf(eye, dir, NEAR_CLIP, FAR_CLIP);\n    if (dist > FAR_CLIP - EPSILON)\n    {\n        return getClearCol(dir);\n    }\n    pos = eye + dist * dir;\n    nrm = calcNormal(pos);\n    view = normalize(eye-pos);\n    \n    return getCol(pos, nrm, view);\n}\n\n// reflection function adapted from here:\n// https://www.shadertoy.com/view/tdlXzr\nvec3 reflection(inout vec3 pos, inout vec3 nrm, inout vec3 view, inout float dist)\n{\n    vec3 ref = reflect(-view, nrm);\n    float NdR = max(EPSILON, dot(nrm, ref));\n    vec3 eye = pos + EPSILON * nrm;\n    if (dist > FAR_CLIP - EPSILON)\n    {\n        return vec3(0.0);\n    }\n    return render(eye, ref, nrm, pos, view, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDir(45.0, iResolution.xy, fragCoord);\n    mat3 rot = rotationMatrix(vec3(0.0, iTime * 25.0, 0.0));\n    vec3 eye = vec3(2.0, 2.0, 8.0) * rot;\n    \n    mat4 view2World = viewMatrix(eye, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (view2World * vec4(dir, 0.0)).xyz;\n    \n    vec3 nrm = vec3(0.0);\n    vec3 pos = vec3(0.0);\n    vec3 view = vec3(0.0);\n    float dist = 0.0;\n    vec3 color = render(eye, worldDir, nrm, pos, view, dist);\n    color += reflection(pos, nrm, view, dist) * 0.25;\n    color += reflection(pos, nrm, view, dist) * 0.25;\n    color += reflection(pos, nrm, view, dist) * 0.25;\n    color += reflection(pos, nrm, view, dist) * 0.25;\n    \n    color = pow(color, vec3(1.0/GAMMA));;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}