{"ver":"0.1","info":{"id":"7ttfRN","date":"1663685541","viewed":53,"name":"A simple bouncing ball","username":"bowari","description":"If you want the camera's rotation you can uncoment line 21 in the common file.\nYou can change parametres of the ball in the common file lines 11-15.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------------\n// -------------------------------------- EVALUATIONS ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// Evaluate the sdf witch correspond to p_num\nfloat evaluate( in vec3 p_point, in float p_num ){\n    switch(int(p_num)){\n        // box\n        case 0: return op_union(\n                        sdf_boxFrame(p_point, vec3(20.), 0.2),\n                        sdf_box(p_point+vec3(0.,20.,0.),vec3(20.,0.2,20.))\n                       );\n        \n        // ball\n        case 1: return sdf_sphere(p_point+getVal(POS_POS,iResolution.x),2.5);  \n        \n        default : return 1e10;\n    }\n}\n\n// Evaluate the global sdf of the scene and return distance and num nearest primitive\nvec2 evaluateScene(in vec3 p_point){\n    vec2 res = vec2(1e10,-1.);\n\n    for(float i=0.; i<2. ;i++){\n        float tmp = evaluate(p_point,i);\n        if(tmp<res.x) res = vec2(tmp,i); \n    }\n    \n    return res;\n}\n\n// Evaluate the global sdf of the scene and return distance\nfloat evaluateSceneAny(in vec3 p_point){\n    float res = 1e10;\n    \n    for(float i=0.; i<2. ;i++)\n        res = min(res,evaluate(p_point,i));\n            \n    return res;\n}\n\n// ------------------------------------------------------------------------------------------\n// ---------------------------------------- SHADING -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// Evaluate scene and find normal by computing gradient at 'p_point'\nvec3 findNormal( in vec3 p_point, in vec2 p_hit ){\n\treturn normalize(vec3(evaluate( p_point + vec3( EPS_NORMAL, 0., 0. ), p_hit.y ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., EPS_NORMAL, 0. ), p_hit.y ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., 0., EPS_NORMAL ), p_hit.y ))\n\t\t\t\t\t -p_hit.x);\n}\n\n// find the shade of the primitive\nvec3 brdf( in vec3 p_point, in vec3 p_lo, in vec3 p_li, in vec3 p_normal, in float p_numOBJ ){\n    switch(int(p_numOBJ)){\n        case 0: \n\t\t\tfloat cTo = dot( p_lo, p_normal );\n\t\t\tfloat To = acos( cTo );\n\t\t\tfloat cTi = dot( p_li, p_normal );\n\t\t\tfloat Ti = acos( cTi );\n\t\t\tfloat PHI = dot( normalize(p_lo-p_normal*cTi), normalize(p_li-p_normal*cTo) );\n\t\t\t\n\n\t\t\tfloat r2 = 0.25;\n\t\t\tfloat A = 1.-0.5*(r2/(r2+0.33));\n\t\t\tfloat B\t= 0.45*(r2/(r2+0.09));\n\n\t\t\treturn vec3(1.) * (A+(B*max(0.,PHI) * sin(max(Ti,To)) * tan(min(Ti,To)) ) ); // oren-nayar roughness 0.5 color vec3(1.)\n            \n        case 1: return vec3(0.85,0.,0.)*INV_PI + vec3(1.)*pow(max(0.,dot(p_normal,normalize(p_lo+p_li))),128.); // blinn-phong pow 128\n    }\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat computeShadow( in vec3 p_rayD, in vec3 p_rayO, in float p_tMax, in float p_factor ) {    \n    float res = 1., t=0.;\n    \n    float rp=1e10;  // radius previous\n    float rc, rc2;  // radius curent\n    float tmp;\n\n    for( int i=0; i<1000 ;i++ ){\n\t\trc = evaluateSceneAny( p_rayO + t*p_rayD );\n        \n        rc2 = rc*rc;\n        tmp = rc2/(2.*rp);\n        res = t<=tmp ? res : min( res, p_factor*sqrt(rc2-tmp*tmp) / (t-tmp));\n\n        t += rc;\n        if(res<0.001 || t>p_tMax) break;\n        \n        rp = rc;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat computeAO( in vec3 p_rayD, in vec3 p_rayO){\n\tfloat factor=1., occ=0.;\n    for( float t=0.; t<0.25 ;t+=0.03 ){\n        occ += (t-evaluateSceneAny( p_rayO + t*p_rayD ))*factor;\n        factor *= 0.95;\n    }\n    return clamp( 1.-occ, 0., 1. ); \n}\n\n// ******************** light ********************\nvec3 pointLight(in vec3 p_dir, in vec3 p_point, in vec3 p_normal, in vec3 p_li, in vec3 p_color, in float p_pow, in float p_factor, in float p_num){\n    vec3 vec = p_li-p_point;\n    float dist = dot(vec,vec);\n    vec3 li = normalize(vec);\n    \n    return brdf(p_point, p_dir, li, p_normal, p_num)*\n           p_color*(p_pow/dist)*\n           computeShadow(li, p_point, sqrt(dist), p_factor)*\n           max(0.,dot(li,p_normal));\n}\n\n// ********************  MAIN  *******************\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec2 uv = fragCoord/iResolution.xy;    // Normalized pixel coordinates (from 0 to 1)\n\n    #ifdef MOOVING_CAM \n    vec3 posCam = vec3(70.*sin(iTime),0.,-70.*cos(iTime));\n    #else\n    vec3 posCam = vec3(70.,0.,0.);\n    #endif\n    \n    float focalDistance = 2.5;\n    float fovy = PI/3.;\n    \n    vec3 w = normalize( posCam );    //lookAt(0,0,0)\n    vec3 u = normalize( cross( vec3(0.,-1.,0.) ,w ) );\n    vec3 v = normalize( cross( w ,u ) );\n\n    float size = 2. * tan(0.5*fovy) * focalDistance;\n    \n    vec3 viewportV = v * size;\n    vec3 viewportU = u * size * (iResolution.x/iResolution.y);\n    vec3 viewportTopLeftCorner = posCam - w*focalDistance + 0.5*(viewportV - viewportU);\n    \n    float t=0.;\n    vec2 hit;\n    vec3 point, \n         d=normalize( viewportTopLeftCorner + viewportU * uv.x + - viewportV * uv.y - posCam ), \n         o=posCam, \n         color=CLEAR_COLOR;\n\n    for(int nbStep=MAX_STEP; nbStep>0 ;nbStep--){\n        hit = evaluateScene(point = t*d + o); // hit = vec2(distance, num OBJ nearest)\n\n        if(hit.x<EPS){\n            vec3 normal = findNormal(o = point, hit);\n            o += normal*(EPS_OH-hit.x);\n            color = pointLight(-d,o,normal,vec3(0.,20,0.) ,vec3(1.), 1000., 8. ,hit.y)*computeAO(normal, o)+vec3(0.001);\n            break;\n        }\n        t += hit.x;\n        if(t>1000.) break;\n    }\n    \n    // tone map (aces)\n    color = clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59 ) + 0.14), 0., 1.);\n    \n    // gamma correction\n    color = pow(color,vec3(0.45));\n    \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// todo add trackBall camera\n// todo change gravity by the orientation of the box\n// todo add reset when press r\n// todo add pushBall when press p\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    ivec2 fc = ivec2(fragCoord);\n    fragColor=texelFetch(iChannel0,fc,0);\n    \n    int index = fc.x+fc.y*int(iResolution.x);\n    \n    if(iTime<0.1) {\n    \tsetVal(index,POS_A,ACCELERATION);\n        setVal(index,POS_VEL,VELOCITY);\n        setVal(index,POS_POS,POSITION);  \n    }else{\n        vec3 pos = getVal(POS_POS,iResolution.x);\n        vec3 vel = getVal(POS_VEL,iResolution.x);        \n        pos += vel;\n\n        if(pos.x>HEIGHT || pos.x<-HEIGHT){\n            vel = vec3(-vel.x*DAMPING,vel.y,vel.z);\n            pos = vec3(clamp(pos.x,-HEIGHT,HEIGHT),pos.y,pos.z);\n        }\n        if(pos.x>HEIGHT_D || pos.x<-HEIGHT_D) vel*=DRAG;\n            \n        if(pos.y>HEIGHT || pos.y<-HEIGHT){\n            vel = vec3(vel.x,-vel.y*DAMPING,vel.z);\n            pos = vec3(pos.x,clamp(pos.y,-HEIGHT,HEIGHT),pos.z);\n        }\n        if(pos.y>HEIGHT_D || pos.y<-HEIGHT_D) vel*=DRAG;\n        \n        if(pos.z>HEIGHT || pos.z<-HEIGHT){\n            vel = vec3(vel.x,vel.y,-vel.z*DAMPING);\n            pos = vec3(pos.x,pos.y,clamp(pos.z,-HEIGHT,HEIGHT));\n        }\n        if(pos.z>HEIGHT_D || pos.z<-HEIGHT_D) vel*=DRAG;\n        \n        setVal(index,POS_POS,pos);\n        setVal(index,POS_VEL,vel+getVal(POS_A,iResolution.x)*iTimeDelta);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// ******************** GLOBAL VARIABLE ********************\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n#define INV_PI 0.31830988\n\n// --- ball ---\n#define POS_A  0\n#define POS_VEL 1\n#define POS_POS 2\n\n#define POSITION vec3(0.)\n#define VELOCITY vec3(2.,-20.,5.)\n#define ACCELERATION vec3(0.,9.81,0.)\n#define DAMPING 0.8\n#define DRAG 0.99\n\n#define HEIGHT 17.3\n#define HEIGHT_D 17.25\n\n// --- others ---\n//#define MOOVING_CAM \n#define MAX_STEP 1000\n#define EPS 0.001\n#define EPS_OH 0.0015\n#define EPS_NORMAL 0.0001\n#define CLEAR_COLOR vec3(0.)\n\n// ******************** COMMON FUNCTIONS ********************\n#define setVal(p_iThread, p_iRef, p_val) if(p_iThread==p_iRef) fragColor = vec4(p_val,0.)\n#define getVal(p_iRef, p_xRes) texelFetch(iChannel0,ivec2((p_iRef)%int(p_xRes),int(float(p_iRef)/p_xRes)),0).xyz\n\n\n// *** https://iquilezles.org/articles/distfunctions/ ***\n\n// --- OPERATION ---\nfloat op_union( in float p_sdf1, in float p_sdf2 ) {\n\treturn (p_sdf1<p_sdf2) ? p_sdf1 : p_sdf2; // faster than min(d1,d2)\n}\n\n// --- SDF ---\nfloat sdf_sphere( in vec3 p_point, in float p_radius ){\n  return length(p_point)-p_radius;\n}\n\nfloat sdf_box( in vec3 p_point, in vec3 p_bounds ){\n  vec3 q = abs(p_point) - p_bounds;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf_boxFrame( in vec3 p_point, in vec3 p_bounds, in float p_e ){\n    p_point = abs(p_point)-p_bounds;\n    vec3 q = abs(p_point+p_e)-p_e;\n    return min(min(\n      length(max(vec3(p_point.x,q.y,q.z),0.0))+min(max(p_point.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p_point.y,q.z),0.0))+min(max(q.x,max(p_point.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p_point.z),0.0))+min(max(q.x,max(q.y,p_point.z)),0.0));\n}\n","name":"Common","description":"","type":"common"}]}