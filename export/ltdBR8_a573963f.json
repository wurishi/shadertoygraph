{"ver":"0.1","info":{"id":"ltdBR8","date":"1538699181","viewed":2156,"name":"Into The Retro (DAC-FRA 2018)","username":"teessider","description":"This is the shader which was made for my talk at the Digital Art Conference Frankfurt 2018. Brushed up on my raymarching stuff and learned some stuff along the way. Set myself the challenge of not using textures.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["grid","80s","retro","pyramid","fra","2018","dacfra","dac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* By Andrew \"teessider\" Bell\nMade for my talk at Digital Art Conference Frankfurt 2018.\n\nLink to talk slides:\nhttps://docs.google.com/presentation/d/1FNYOsMmWiEzUhIcq-FBusBHGARw9IpcFf6XB8OK4Xf0/edit?usp=sharing\n\nThis is based on the dac-fra.com website graphic.\n\nSome improvements I would like to make (After the talk):\n- Floating Pyramid inside shapes\n- DAC-FRA text\n- Make the Floating Pyramid spin a cool way!\n\n*/\n\n// A couple of helper macros - coming from HLSL ;) and others too!\n#define mad(m, a, b) m*a+b\n#define rcp(x) 1.0/x\n#define saturate(a) clamp( a, 0.0, 1.0 ) // It seems that (not sure if this is a WebGL thing) the whitespace matters in macros!\n#define testMask(x) vec3( x )\n\n#define PI 3.1415\n#define TAU 6.2831\n\n// RAYMARCH LOOP PARAMS\n#define MAX_STEPS 64\n#define MAX_DIST 30.0\n#define EPSILON 0.01\n////\n\n// OBJECT IDs\n#define BACKGROUND -1.0\n#define FLOOR 1.0\n#define PYRAMID 2.0\n\n\n#define UV_SCALE 150.0\n#define SPEED 6.0\n#define GRID_SIZE 0.75\n\n////// IQ STUFF\n// IQ DISTANCE FUNCTIONS\nfloat sdSphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat sdPlane2(vec3 point, vec4 normal)\n{\n    return dot(point, normal.xyz) + normal.w;\n}\n\nfloat sdBox( vec3 point, vec3 b )\n{\n    vec3 d = abs(point) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    //return max(-box,octa); // Subtraction\n    return max(box,octa); // Subtraction, opposite\n }\n\n\n// Operator - Union\n// Includes support for the IDs\nvec2 opU(vec2 d1, vec2 d2)\n{\n    // the < operator can only deal with scalars so just the DF is used. NEED IT LIKE THIS BECAUSE OF IDs\n    return(d1.x < d2.x) ? d1 : d2;\n}\n\n\n// More info here: https://iquilezles.org/articles/voronoise\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    float inv_v = 1.0-v;\n    inv_v *= inv_v;\n    inv_v *= inv_v;\n\t\t\n\t//float k = 63.0*pow(1.0-v,4.0) + 1.0;\n    float k = 63.0*inv_v + 1.0;\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n////// END IQ STUFF\n\n// This is where all the Distance Fields (DFs) are added into the scene\n// also know as map() in iq's shaders :D\nvec2 scene(in vec3 point)\n{\n    // To make the sphere move along with the camera, for now it has the same speed added to it plus an offset\n    // Z is depth in this case ;)\n    // For some reason, the shape is off center if set to 0.0 ? \n    vec2 pyramid = vec2(sdPryamid4(point - vec3(0.05, sin(iTime*PI)+4.0, iTime*20.0+1.0), vec3(0.65,0.33,1.0)), PYRAMID);\n\n\n    // FOR TESTING ONLY\n    //vec2 sphere1 = vec2(sdSphere(point-vec3(0.0, sin(iTime*PI)+4.0, iTime*20.0+15.0), 8.0), PYRAMID);\n\n    float mountainsHeight = mix(1.0, smoothstep(-.05, 1., iqnoise(point.xz*.75, 1.0, 1.0)*.25), saturate(abs(point.x)-3.0));\n    vec2 mountainsGround = vec2(sdPlane2(point, vec4(0.0, mountainsHeight, 0.0, 0.0)), FLOOR);\n\n    vec2 result = opU(mountainsGround, pyramid);\n\n    return result;\n}\n\n\n//// MORE IQ STUFF\n// https://iquilezles.org/articles/normalsSDF\n// Normals can be estimated from a gradient!\nvec3 calculateNormal(in vec3 point)\n{\n    vec2 h = vec2(EPSILON, 0.0); // Some small value(s)\n    return normalize(vec3(scene(point + h.xyy).x - scene(point - h.xyy).x,\n                          scene(point + h.yxy).x - scene(point - h.yxy).x,\n                          scene(point + h.yyx).x - scene(point - h.yyx).x));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.12*float(i)*0.25 + 0.01;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return saturate(1.0 - 3.0*occ);    \n}\n//// END IQ STUFF\n\nvec2 raymarch(in vec3 origin, in vec3 ray)\n{\n    float t = 0.0; // t is the clipping plane where anything below this is removed.\n    float id = -1.0; // For the Background\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec2 dist = scene(origin + ray * t);\n        if (dist.x < EPSILON)\n        {\n            break; // We are inside the surface.\n        }\n        // Move along the ray in constant steps\n        t += dist.x;\n        // Since each element has an ID, we want that there too!\n        id = dist.y;\n\n        if (t >= MAX_DIST)\n        {\n            id = BACKGROUND;\n            return vec2(MAX_DIST, id); //We are too far away!\n        }\n    }\n    return vec2(t, id);\n}\n\nvec4 render(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    // INITIALISE finalColor so it be used later and fed into \n    vec3 finalColor = vec3(0.0);\n\n    // BACKGROUND\n    vec3 bgColor = mix(vec3(0.345,0.212,0.388), vec3(0.145,0.357,0.612), saturate(rayDirection.x));\n    float stars = smoothstep(0.745, 1.0, iqnoise(rayDirection.xy*UV_SCALE, 1.0, 1.0)); // ORIGINALLY USED UVs BUT USING RAY DIRECTION IS WAY COOLER\n    vec3 scene_background = 0.2*stars + bgColor;\n\n    // SCENE THAT ISNT THE BACKGROUND (BUT BEFORE \"POST PROCESS\" STUFF)\n    vec2 result = raymarch(rayOrigin, rayDirection);\n    if (result.y > BACKGROUND)\n    {\n\n        vec3 point = result.x * rayDirection + rayOrigin;\n        vec3 normal = calculateNormal(point);\n\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -4.0));\n        float nDotL = saturate(dot(normal, lightDir));\n\n        if (result.y == FLOOR)\n        {\n            vec2 gridUVs = mod(point.xz, 1.5); //GRID SIZE\n            gridUVs = round(mad(GRID_SIZE, 0.5, gridUVs)); // GRID LINE SIZE\n            float grid = saturate(mad(-gridUVs.x, gridUVs.y, 1.0));\n\n            vec3 gridColor = vec3(0.345,0.212,0.388);\n\n            float fog = saturate(saturate(1.0-exp(-result.x*0.1)-0.8)*8.0);\n\n            finalColor = mix(gridColor+scene_background, scene_background, saturate(max(fog, 1.-grid)));\n            finalColor *= sqrt(calcAO(point, normal)); // Only want AO on FLOOR but not as intense\n        }\n        else\n        {\n            /// CURRENTLY ONLY FOR PYRAMID\n            vec3 sunColor = vec3(1.0, 0.5, 0.0);\n            vec3 ambientColor = vec3(0.0, 0.0, 0.0);\n            //finalColor = saturate(mix(nDotL * sunColor, finalColor, 1.0-exp(-result.x*0.1))); // SIMPLE FOG TEST\n            finalColor = pow(saturate(nDotL * sunColor +ambientColor), vec3(0.4545));  // Simple Gamma Correction\n            //finalColor = -normal.zzz; // FOR INSIDE MASK EVENTUALLY\n            //finalColor = (result.yyy-1.5)*fract(-iTime*0.5)*2.5-0.1; //PULSING TEST\n        }\n    }\n    else\n    {\n        finalColor = scene_background;\n    }\n    return vec4(finalColor, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Remap from [0-1] to [-1-1] so that 0 is the middle point in\n    // Also apply aspect ratio correction too\n    vec2 orig_uv = fragCoord.xy / iResolution.xy;\n    vec2 uv = mad(2.0, orig_uv, -1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // RAYMARCH STUFF - THE SCENE\n    vec3 ray_orig = vec3(0.0, 3.0, -5.0);\n    ray_orig += vec3(0.0, 0.0, iTime*20.);\n    vec3 ray_dir = normalize(vec3(uv, 1.16)); // ray_dir.z is FOV\n    vec3 sceneColor = render(ray_orig, ray_dir).xyz;\n\n    // SCANLINES\n    vec3 linesColor = vec3(0.0, 0.04, 0.08);\n    float linesAlpha = sin(uv.y * UV_SCALE + (iTime * SPEED));\n    sceneColor = (linesColor * linesAlpha) + sceneColor;\n\n    // VIGNETTE\n    float vignette = sqrt(orig_uv.x * orig_uv.y *(1.0-orig_uv.x) * (1.0-orig_uv.y) * 16.0);\n    sceneColor *= vignette;\n    fragColor = vec4(sceneColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}