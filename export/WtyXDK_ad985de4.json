{"ver":"0.1","info":{"id":"WtyXDK","date":"1583595372","viewed":130,"name":"Wave Pool","username":"rmccampbell7","description":"A simple wave simulation\nClick to make waves","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["wave","fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COLOR0 vec3(0, 0, 1)\n// Fun colors\n//#define COLOR0 (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))\n#define COLOR1 vec3(1, 1, 1)\n#define MAXVAL 10.\n#define MINVAL -10.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 state = texture(iChannel0, uv);\n    float z = state.x;\n\n    float norm = clamp((z - MINVAL) / (MAXVAL - MINVAL), 0., 1.);\n    vec3 color = mix(COLOR0, COLOR1, norm);\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Should be factor of display resolution\n#define SCALE 1.\n#define STEP 1\n#define K 0.2\n#define DAMPING .002\n#define DIAG .4\n#define SPLASH 25.\n// Uncomment to enable wrapping\n//#define WRAP\n\nfloat hash1(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 t = smoothstep(0., 1., f);\n    return mix(mix(hash1(i+vec2(0,0)), hash1(i+vec2(1,0)), t.x),\n               mix(hash1(i+vec2(0,1)), hash1(i+vec2(1,1)), t.x), t.y);\n}\n\nfloat fbm(vec2 p, int oct) {\n    float n = 0.;\n    for (int i=0; i<oct; i++) {\n        float f = exp2(float(i));\n        n += noise(p * f) / f;\n    }\n    return n;\n}\n\nvec4 init(vec2 coord, vec2 res) {\n    float z = (fbm(coord/64., 6)-1.) * 4.;\n    vec2 edge = min(coord, res - coord);\n    float edgedist = min(edge.x, edge.y);\n    z *= clamp(edgedist/20., 0., 1.);\n    return vec4(z, 0, 0, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = floor(fragCoord / SCALE) + .5;\n    vec2 res = iResolution.xy / SCALE;\n    vec2 uv = coord / res;\n    vec4 state = texture(iChannel0, uv);\n\n    if (iFrame < 4) {\n        state = init(coord, res);\n    }\n    else if (iFrame % STEP == 0) {\n        float z = state.x;\n        float v = state.y;\n    \tif (iMouse.z > 0.) {\n            vec2 mouse = floor(iMouse.xy / SCALE) + .5;\n            if (length(mouse - coord) <= 1.) {\n                v += SPLASH;\n            }\n        }\n        float ortho_force = K*(\n            texture(iChannel0, uv + vec2( 1, 0)/res).x +\n            texture(iChannel0, uv + vec2( 0, 1)/res).x +\n            texture(iChannel0, uv + vec2(-1, 0)/res).x +\n            texture(iChannel0, uv + vec2( 0,-1)/res).x - 4.*z);\n        float diag_force = K*DIAG*(\n            texture(iChannel0, uv + vec2( 1, 1)/res).x +\n            texture(iChannel0, uv + vec2(-1, 1)/res).x +\n            texture(iChannel0, uv + vec2(-1,-1)/res).x +\n            texture(iChannel0, uv + vec2( 1,-1)/res).x - 4.*z);\n        float a = ortho_force + diag_force - v*DAMPING;\n        v += a;\n        z += v;\n        state = vec4(z, v, 0., 0.);\n    }\n#ifndef WRAP\n    if (coord.x < 1. || coord.y < 1. || coord.x > res.x-1. || coord.y > res.y-1.) {\n        state = vec4(0);\n    }\n#endif\n    fragColor = state;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}