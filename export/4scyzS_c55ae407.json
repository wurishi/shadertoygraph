{"ver":"0.1","info":{"id":"4scyzS","date":"1519413534","viewed":79,"name":"Fractelissimo","username":"BowToes","description":"Full description in the Common tab, but in short: this is a fractal generator that can be used to generate interesting images through the use of iterative complex functions. Any feedback is most appreciated.","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["fractal","numbers","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Time vectors that go in a circle.\n#define VECTIME vec2(cos(iTime), sin(iTime))\n#define VECTIME2 vec2(cos(t), sin(t))\n\nvoid iterate(vec2 z, vec2 c, vec2 pow, vec2 cPow, float iter, out float it, out vec2 itt)\n{    \n    float k;\n    vec2 n;\n    for (float i = 0.; i < iter; i++)\n    {\n        k=i;\n        n=z;\n        if(mag(z) > 16.)\n            break;\n        z = cpow(z, pow)+cpow(c, cPow);\n    }\n    \n    it = k;\n    itt = n;\n}\nvoid burnShip(vec2 z, vec2 c, vec2 pow, vec2 cPow, float iter, out float it, out vec2 itt)\n{\n    float k;\n    vec2 n;\n    for (float i = 0.; i < iter; i++)\n    {\n        k=i;\n        n=z;\n        if(mag(z) > 16.)\n            break;\n        z = cpow(vec2(-abs(z.x), abs(z.y)), pow)+cpow(c, cPow);\n    }\n    \n    it = k;\n    itt = n;\n}\n\nvec3 intCol(vec2 end, float hue2)\n{\n    float hue = exp(-mag(end));\n    \n    return hsvToRGB(hue-hue2, .75, 1.);\n}\nvec3 outCol(float iter, float maxiter, float freq, float offset)\n{\n    float x = pow(iter/(maxiter-1.), 1.25);\n    float b = twopi*freq;\n\tfloat b2 = 3.*freq;\n    float c = pi/(2.*b)+offset;\n   \n    float red = SIN(b*(x-c)+0.0*pi/b2);\n    float gre = SIN(b*(x-c)+2.0*pi/b2);\n    float blu = SIN(b*(x-c)+3.0*pi/b2);\n    //float red = pow(COS2(b*(x-c)+0.*pi/b2), 3.);\n\t//float blu = pow(COS2(b*(x-c)+2.*pi/b2), .3);\n\t//float gre = pow(COS2(b*(x-c)+4.*pi/b2), 2.);\n    \n    return vec3(red, gre, blu);\n}\n\nvoid myFunc(vec2 z, vec2 c, vec2 pow, vec2 cPow, float iter, out float it, out vec2 itt)\n{\n    float k;\n    vec2 n;\n    for (k = 0.; k < iter;)\n    {\n        k++;\n        n=z;\n        if(mag(z) > 1.)\n            break;\n        z = cpow(z, pow)+cpow(c, cPow);\n    }\n    \n    it = k;\n    itt = n;\n}\n\n#define MAXITER 300.\n#define ZOOM 6.\n//Decrease this for a deeper zoom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //++=PRE-SETUP=++//\n    bool ak = keyClick(65, iChannel0); //If 'A' is pressed\n    bool ck = keyClick(67, iChannel0); //If 'C' is pressed\n    bool ek = keyClick(69, iChannel0); //If 'E' is pressed\n    bool qk = keyClick(81, iChannel0); //If 'Q' is pressed\n    bool zk = keyClick(90, iChannel0); //If 'Z' is pressed\n    \n    bool tab = keyClick(9, iChannel0); //If 'Tab' is pressed\n    bool space = keyClick(32, iChannel0); //If 'Space' is pressed\n    \n    float t, t2, n;\n    vec2 l, z, pnt, tpnt, apnt, initVal, jInitVal, offSet, pwr, cPwr, pixelComp, n2;\n    vec3 color;\n    //++=SETUP=++//\n    {\n    \tt = iTime/8.;\n    \t    \n    \tl = ZOOM*((iMouse.xy/iResolution.xy)-.5);\n    \tl.y*=iResolution.y/iResolution.x;\n    \tlock(l, iChannel0);\n    \t\n    \tz = (fragCoord/iResolution.xy)-.5;\n    \tz*=ZOOM;\n    \tz.y *= iResolution.y/iResolution.x;\n    \t\n    \ttpnt = VECTIME2;\n    \t\n    \tpnt = l;\n    \tif(tab) pnt = normalize(pnt);\n    \tif (ak) pnt = roundTo(pnt, prec);\n    }    \n    //++=INIT=++// This is where you'll want to do most of you're editing;\n    {\n    \tapnt = vec2(-1.41, 0.);\n    \tinitVal   = vZero;\n    \tjInitVal  = pnt;\n    \toffSet    = vec2(0.25, 0.);//vec2(.3125, -0.03);\n    \tpwr       = vOne*2.;\n    \tcPwr      = vOne;\n    \tpixelComp = z; //Value 'z' that is passed into iterative function;\n    }\n    //++=CALCULATION=++//\n    {\n    \tif (!(zk||ck||ek))  iterate(initVal, pixelComp, pwr, cPwr, MAXITER, n, n2); //Plain Mandelbrot\n    \telse if (zk && !ek)    burnShip(initVal, pixelComp, pwr, cPwr, MAXITER, n, n2); //Burning Ship\n    \telse if (ck && !ek)      myFunc(initVal, pixelComp, pwr, cPwr, MAXITER, n, n2); //Custom function\n    \t\n    \telse if (zk && ek)    burnShip(pixelComp, jInitVal, pwr, cPwr, MAXITER, n, n2); //Julia of Burning Ship\n    \telse if (ck && ek)      myFunc(pixelComp, jInitVal, pwr, cPwr, MAXITER, n, n2); //Julia of custom function\n    \telse                   iterate(pixelComp, jInitVal, pwr, cPwr, MAXITER, n, n2); //Julia set of Mandelbrot\n    }\n    //++=COLORING=++//\n    {\n    \tif(n == MAXITER-1.) \n    \t{   \n            if (space) color = intCol(n2, t);\n    \t\telse color = vec3(0.);\n        }\n    \telse color = outCol(n, MAXITER, pi, 0.);\n    \t    \n    \tif(qk) drawGrid(fragCoord, 1., vec3(0., 1., 0.), vec3(0.3, 0.5, 0.8), iResolution.xy/2., iResolution.x/ZOOM, color);\n        drawPoint(pnt, z, ZOOM/length(iResolution), vec3(1., .4, .9), color);\n\t\t//drawPoint(tpnt-offSet, z, ZOOM/2., vec3(1.), color);\n    \t//drawPoint(apnt, z, ZOOM/2., vec3(.5, .5, 1.), color);\n    }\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//This is a little shader I had made on in the early months of 2018.\n//It is designed for users to easily manipulate and create their own fractals\n//\tout of iterative functions. All major trig, hyperbolic, and their inverse \n//\tfunctions are included, even for complex numbers. As well, I've included\n//  complex exponential functions, complex logarithms, and complex roots.\n//If you've seen my other shader, I used that as a practicing ground for \n//\timplementing the majority of these functions properly.\n//If you've got any other ideas for complex functions I should include, please tell\n//\tme. I'd love to see more interesting functions and how they play out in\n//\tproducing fractals.\n\n//Normalized Trig\n#define SIN(x) (sin(x)*.5+.5)\n#define COS(x) (cos(x)*.5+.5)\n\n\n//Precision variable.\nconst float prec = 0.10;\n\nconst float e = exp(1.);\nconst float pi = acos(-1.);\nconst float twopi = acos(-1.)*2.;\nconst float halfpi = acos(-1.)/2.;\n\n//Radians to degrees converter, acronymed rtod.\nconst float rtod = 180./pi;\n\nconst vec2 vOne \t= vec2(1.0, 0.0);\nconst vec2 vImagOne = vec2(0.0, 1.0);\nconst vec2 vZero \t= vec2(0.0, 0.0);\nconst vec2 vComp \t= vec2(1.0, 1.0);\n\n\n//===++===//\n//===++===//\n\n//Range [-π, π]\nfloat arg(vec2 z) { return atan(z.y,z.x); }\n\n//Range [0, 2π]\nfloat arg2(vec2 z) { return arg(z)+pi; }\n\n//Range [0, 360]\nfloat argd(vec2 z) { return arg(z)*rtod+180.; }\n\n//Range of [0, 1]\nfloat narg(vec2 z) { return arg(z)/twopi+.5; }\n\nfloat mag(vec2 z)  { return length(z); }\nvec2 conj(vec2 z)  { return vec2(z.x, -z.y); }\n\n//===++===//\n//===++===//\n\n//Basic arithmetic.\n\nvec2 cmul(vec2 z, vec2 w) { return vec2(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x); }\nvec2 csquare(vec2 z) { return vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y); }\nvec2 cdiv(vec2 z, vec2 w) { return vec2((z.x*w.x+z.y*w.y)/(w.x*w.x+w.y*w.y),(z.y*w.x-z.x*w.y)/(w.x*w.x+w.y*w.y)); }\n\n//Reciprocal\nvec2 recip(vec2 z) { return vec2(z.x/(z.x*z.x+z.y*z.y), -z.y/(z.x*z.x+z.y*z.y)); }\n\nvec2 fromPol(float mag, float arg) { return vec2(mag*cos(arg), mag*sin(arg)); }\n\nvec2 csqrt(vec2 z) { return fromPol(sqrt(mag(z)), arg(z)/2.); }\n\nvec2 imMul(vec2 z) { return vec2(-z.y, z.x); }\n\n//===++===//\n//===++===//\n\n//Exponentiables\n\nvec2 cln (vec2 z) { return vec2(.5*log(dot(z,z)), arg(z)); }\nvec2 clog(vec2 b, vec2 p) { return cdiv(cln(b), cln(p)); }\nvec2 cexp(float x) { return vec2(cos(x), sin(x)); }\nvec2 cexp(vec2 z)  { return exp(z.x)*vec2(cos(z.y), sin(z.y)); }\n\n//need to figure out how to remove the if statements from this one.\nvec2 cpow(  vec2 z,  vec2 w)\n{ \n    if (z == vZero)\n        return w == vZero ? vOne : vZero;\n    return cexp(cmul(w, cln(z)));\n}\n\nvec2 croot( vec2 w,  vec2 z) { return cpow(z, recip(w)); }\n\n//===++===//\n//===++===//\n\nvec2   csin(vec2 z) { return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y)); }\nvec2   ccos(vec2 z) { return vec2(cos(z.x)*cosh(z.y), -(sin(z.x)*sinh(z.y))); }\nvec2   ctan(vec2 z) { return cdiv(csin(z), ccos(z)); }\nvec2   ccot(vec2 z) { return cdiv(ccos(z), csin(z)); }\nvec2   csec(vec2 z) { return recip(ccos(z)); }\nvec2   ccsc(vec2 z) { return recip(csin(z)); }\n\nvec2  casin(vec2 z) { return -imMul(cln(imMul(z)+csqrt(vOne-csquare(z)))); }\nvec2  cacos(vec2 z) { return -imMul(cln(z+csqrt(csquare(z)-vOne))); }\nvec2  catan(vec2 z) { return (imMul(cln(vOne-imMul(z))-cln(vOne+imMul(z))))/2.; }\nvec2  cacot(vec2 z) { return catan(recip(z)); }\nvec2  casec(vec2 z) { return cacos(recip(z)); }\nvec2  cacsc(vec2 z) { return casin(recip(z)); }\n\nvec2  csinh(vec2 z) { return vec2(sinh(z.x)*cos(z.y), cosh(z.x)*sin(z.y)); }\nvec2  ccosh(vec2 z) { return vec2(cosh(z.x)*cos(z.y), sinh(z.x)*sin(z.y)); }\nvec2  ctanh(vec2 z) { return cdiv(csinh(z), ccosh(z)); }\nvec2  ccoth(vec2 z) { return cdiv(ccosh(z), csinh(z)); }\nvec2  csech(vec2 z) { return recip(ccosh(z)); }\nvec2  ccsch(vec2 z) { return recip(csinh(z)); }\n\nvec2 casinh(vec2 z) { return cln(z+csqrt(csquare(z)+vOne)); }\nvec2 cacosh(vec2 z) { return cln(z+cmul(csqrt(z+vOne), csqrt(z-vOne))); }\nvec2 catanh(vec2 z) { return (cln(cdiv(vOne+z, vOne-z)))/2.; }\nvec2 cacoth(vec2 z) { return (cln(cdiv(z+vOne, z-vOne)))/2.; }\nvec2 casech(vec2 z) { return cln(recip(z)+cmul(csqrt(recip(z)+vOne), csqrt(recip(z)-vOne))); }\nvec2 cacsch(vec2 z) { return cln(recip(z)+csqrt(recip(csquare(z))+vOne)); }\n\n//===++===//\n//===++===//\n\nvec3 hsvToRGB(float h, float s, float v)\n{\n    vec3 z0 = fract(h+vec3(3.,2.,1.)/3.);  //is vec3(((h+3)/3) % 1, fract(h+2))\n    vec3 z1 = abs(z0*6.-3.);               //if h==0 => vec3(3, 1, 1)\n    vec3 e0 = vec3(1.);\t\t\t   \t       \n    vec3 e1 = clamp((z1-1.),0.,1.);        //if h==0 => vec3(1, 0, 0)\n    return mix(e0,e1,s)*v; //if v==1 && s==1 && h==0 => vec3(1, 0, 0)\n}\nvec3 hsvToRGB(vec3 c)\n{ return hsvToRGB(c.x, c.y, c.z); }\n\nvec3 hslToRGB(float h, float s, float l)\n{\n    float v = (2.*l+s*(1.-abs(2.*l-1.)))/2.;\n    float sv = (2.*(v-l))/v;\n    return hsvToRGB(h, sv, v);\n}\nvec3 hslToRGB(vec3 c)\n{ return hslToRGB(c.x, c.y, c.z); }\n\n//===++===//\n//===++===//\n\n//Sourced of p5.js's map function.\nfloat map(float n, float start1, float stop1, float start2, float stop2) { return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2; }\nbool isBetween(float a, float mn, float mx) { return (a >= mn && a <=mx); }\nbool isNear(float val, float compare, float p) { return isBetween(val, compare-p, compare+p); }\nbool isNear(vec2 val, float compare, float p)  { return isNear(val.x, compare, p) && isNear(val.y, compare, p); }\nbool isNear(vec2 val, vec2 compare, float p)   { return isNear(distance(compare, val), p, p); }\n\n//===++===//\n//===++===//\n\nvoid drawPoint(vec2 pos, vec2 pix, float r, vec3 cl, out vec3 col)\n{\n    //pix is the pixel to test, r is the radius, cl is the color.\n    if(isNear(pix, pos, r))\n        col = cl;\n}\n\n//This works using simple modular arithmatic\n//void drawGrid(vec2 pix, float thickness, vec3 col, vec3 originCol, vec2 origin, float spacing, out vec3 color)\n//{\n//    //pix is the pixel to test, thickness is the width of the grid, \n//    //\tcol is the color of the regular grid, originCol is the color of the\n//    //\tx and y axes, origin is the pixel coordinates of the origin of the grid,\n//    //\tspacing is the num of pixels inbetween lines.\n//    if(isNear(mod(origin.x-pix.x, spacing), 0., thickness) || isNear(mod(origin.y-pix.y, spacing), 0., thickness))\n//        color = col;\n//    if(isNear(pix.x, origin.x, thickness) || isNear(pix.y, origin.y, thickness))\n//        color = originCol;\n//}\n\nvoid drawGrid(vec2 pix, float thickness, vec3 col, vec3 originCol, vec2 origin, float spacing, out vec3 color)\n{\n    //pix is the pixel to test, thickness is the width of the grid, \n    //\tcol is the color of the regular grid, originCol is the color of the\n    //\tx and y axes, origin is the pixel coordinates of the origin of the grid,\n    //\tspacing is the num of pixels inbetween lines.\n    if(isNear(mod(origin.x-pix.x, spacing), 0., thickness) || isNear(mod(origin.y-pix.y, spacing), 0., thickness))\n        color = col;\n    if(isNear(pix.x, origin.x, thickness) || isNear(pix.y, origin.y, thickness))\n        color = originCol;\n}\n\n//TODO: make this look like David Bau's checkers.\nvoid checker(vec2 pix, vec3 col, float spacing, out vec3 color)\n{\n    if(mod(pix.x, pix.x-spacing) < spacing || mod(pix.y, pix.y-spacing) < spacing) color = col;\n}\n\n//===++===//\n//===++===//\n\nfloat roundTo(float a, float p) { return round(a/p)*p; }\nvec2 roundTo(vec2 a, float p) { return vec2(round(a.x/p)*p, round(a.y/p)*p); }\n\nbool keyClick(int ascii, sampler2D channel) {\n\treturn (texture(channel, vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nvoid lock(out vec2 a, sampler2D channel)\n{\n    if(keyClick(17, channel)) a = vec2(a.x, 0.); //l-ctrl\n    else if (keyClick(16, channel)) a = vec2(0., a.y); //l-shft\n}","name":"Common","description":"","type":"common"}]}