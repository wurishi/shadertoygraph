{"ver":"0.1","info":{"id":"Ml2SzG","date":"1444730885","viewed":200,"name":"FisherCat","username":"Makio64","description":"Raymarching test featuring Cat","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fishing Cat\n// By David Ronai / @Makio64\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define SHADOW\n\n#define RAYMARCHING_STEP 60\n#define RAYMARCHING_JUMP .85\n\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n\n//------------------------------------------------------------------ MATRIX Functions\n\nmat2 Rot2(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat2( c, -s, s, c );\n}\n\nmat4 Rot4X(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4( 1, 0, 0, 0,\n\t\t\t\t 0, c,-s, 0,\n\t\t\t\t 0, s, c, 0,\n\t\t\t\t 0, 0, 0, 1 );\n}\n\nmat4 Rot4Y(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4( c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t-s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1 );\n}\n\nmat4 Rot4Z(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4(\n\t\tc,-s, 0, 0,\n\t\ts, c, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\t);\n}\n\nmat4 matRotate( in vec3 xyz )\n{\n\tvec3 si = sin(xyz);\n\tvec3 co = cos(xyz);\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n\t\t\t\t si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n\t\t\t\t co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t\t 0.0,                      0.0,                      0.0,        1.0 );\n}\n\nmat4 Loc4( vec3 p ) {\n\treturn mat4(\n\t\t1,  0,  0,  -p.x,\n\t\t0,  1,  0,  -p.y,\n\t\t0,  0,  1,  -p.z,\n\t\t0,  0,  0,  1\n\t);\n}\n\nmat4 matInverse( in mat4 m )\n{\n\treturn mat4(\n\t\tm[0][0], m[1][0], m[2][0], 0.0,\n\t\tm[0][1], m[1][1], m[2][1], 0.0,\n\t\tm[0][2], m[1][2], m[2][2], 0.0,\n\t\t-dot(m[0].xyz,m[3].xyz),\n\t\t-dot(m[1].xyz,m[3].xyz),\n\t\t-dot(m[2].xyz,m[3].xyz),\n\t\t1.0 );\n}\n\n//------------------------------------------------------------------ PRIMITIVES\n\nfloat sdCappedCylinder( in vec3 p, in vec2 h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat d1 = -p.y-c.z;\n\tfloat d2 = max( dot(q,c.xy), p.y);\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdSphere( vec3 p, float r ) {\n\treturn length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//------------------------------------------------------------------ OPERATIONS\nfloat sMinP( float a, float b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float a, float b ) {\n\treturn max( a, -b );\n}\n\nvec3 opTx( vec3 p, mat4 m ) {\n\treturn (transpose(m)*vec4(p,1.0)).xyz;\n}\n\n//------------------------------------------------------------------ MATERIALS\n\n#define BLACK 1.\n#define WHITE 2.\n#define BLUE 3.\n#define PINK 4.\n\n\n//------------------------------------------------------------------ MAP : Create object in the scenes\n\nvec2 opU( in vec2 v1, in vec2 v2){\n\t//Alternative wihout if.\n\t//return mix(v1,v2,clamp(sign(v1.x - v2.x),0.,1.));\n\treturn (v1.x<v2.x)?v1:v2;\n}\n\nvec3 posFromAngle(in float phi, in float theta, in float radius){\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n// Return distance + material ID\nvec2 map( in vec3 pos )\n{\n\tvec3 q = pos;\n\n    vec3 headPos = pos+vec3(0.,abs(cos(iTime*2.))*.5,0.);\n\n    q = opTx( headPos - vec3(.5,5.2,-3.), Rot4X(.3) );\n\tfloat pinkHearL = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = opTx( headPos - vec3(.5,5.2,3.), Rot4X(-.3) );\n\tfloat pinkHearR = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tfloat pinkHears = min(pinkHearL,pinkHearR);\n\n\tq = opTx( headPos - vec3(0.,6.,-3.), Rot4X(.3) );\n\tfloat hearL = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = opTx( headPos - vec3(0.,6.,3.), Rot4X(-.3) );\n\tfloat hearR = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tfloat hears = min(hearR,hearL);\n\tpinkHears = max(pinkHears,hears);\n\thears = opS(hears,pinkHears);\n\n\tq = headPos;\n\tfloat head = min(hears,sdSphere(q,5.));\n\tfloat head2 = sdSphere(q,5.2);\n\tq = headPos;\n\tpinkHears = opS(pinkHears,head2);\n\tq = pos;\n\tfloat body = sdCapsule(q, vec3( 0., -12., 0. ), vec3( 0., -12., 0.), 8.2 );\n\tbody = sMinP(body, head, 5.);\n    \n    q = pos - vec3(-5.,0.,0.+sin(pos.y/2.+iTime));\n    float tail = sdCapsule(q, vec3( -15., -5., 0. ), vec3( 0., -15., 0.), .5+max(0.,min((pos.y+15.)/7.,3.)) );\n    \n    q = pos;\n    float can = sdCapsule(q, vec3( 4., -10., 5. ), vec3( 13., 8.+cos(iTime/2.)*1.5, 5.+sin(7.3/2.+iTime*2.)/2.), .5 );\n    float can2 = sdCapsule(q, vec3(  13., 8.+cos(iTime/2.)*1.5, 5.+sin(pos.y/2.+iTime*2.)/2. ), vec3( 16., -15., 5.), .1 );\n    can = min(can,can2);\n    \n    vec3 bassinPos = pos-vec3(15.,-17.,5.);\n    float bassin = sdTorus(bassinPos, vec2(6.,.5));\n    //return vec2(bassin, WHITE);\n    \n    vec2 white = vec2(min(bassin,min(can,min(tail,body))),WHITE);\n\n\tfloat phi = sin(iTime/2.)*.3;\n\n\tq = pos - posFromAngle(phi+1.35,.3,5.);\n\tfloat eyeL = sdSphere(q,.3);\n\n\tq = pos - posFromAngle(phi+1.35,-.3,5.);\n\tfloat eyeR = sdSphere(q,.3);\n\n    float water = sdCappedCylinder(bassinPos,vec2(6.,.25));\n\tfloat eyes = min(water,min(eyeL,eyeR));\n\tvec2 blue = vec2(eyes, BLUE);\n\tvec2 pink = vec2(pinkHears,PINK);\n\n\tq = pos - posFromAngle(phi+1.5,0.,5.1);\n\tfloat noze = sdSphere(q,.1);\n\n\tq = pos - posFromAngle(phi+1.5,.4,5.);\n\tq = opTx( q, Rot4X(-1.3) );\n\tfloat mustache = sdCappedCylinder(q, vec2(.05,2.5));\n\n\tq = pos - posFromAngle(phi+1.55,.4,5.);\n\tq = opTx( q, Rot4X(-1.4) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.6,.4,5.);\n\tq = opTx( q, Rot4X(-1.5) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.5,-.4,5.);\n\tq = opTx( q, Rot4X(1.3) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.55,-.4,5.);\n\tq = opTx( q, Rot4X(1.4) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.6,-.4,5.);\n\tq = opTx( q, Rot4X(1.5) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tvec2 black = vec2(min(noze,mustache),BLACK);\n\n\tvec2 infos = opU(white,blue);\n\tinfos = opU(infos,pink);\n\tinfos = opU(infos,black);\n\treturn infos;\n}\n\n\n//------------------------------------------------------------------ RAYMARCHING Stuffs\n\n#ifdef RENDER_DEPTH\nvec2 castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nvec2 castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat tmax = 120.;\n\tfloat precis = .01;\n\tfloat t = 0.0;\n\tvec2 res;\n\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res.x<precis || t>tmax ) break;\n\t\tt += res.x*RAYMARCHING_JUMP;\n\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn vec2( t, res.y );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773*.01;\n\treturn normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.01 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\n//------------------------------------------------------------------ POSTEFFECTS\n\nvec3 bw( in vec3 col )\n{\n\treturn vec3(0.299*col.r + 0.587*col.g + 0.114*col.b);\n}\n\n#ifdef POSTPROCESS\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n\tcol *= 0.25+0.75*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\n\t//extra bright\n\tcol+=0.05;\n\treturn col;\n}\n\n#endif\n\n//------------------------------------------------------------------ RENDER\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col;\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tvec2 res = castRay(ro,rd,depth);\n\t#else\n\tvec2 res = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n    if(mod(iTime,3.)<1.){\n\t\treturn vec3(depth)*vec3(.1,.5,1.);\n    }\n\t#endif\n\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tvec3 pos = ro + t * rd;\n\t#ifdef RENDER_NORMAL\n    if(mod(iTime,3.)<2.){\n\t\treturn calcNormal( pos );\n    }\n    #endif\n\n\tif(t>65.){\n\t\tcol = vec3(.6,.5,.35);\n\t}\n\telse if( m == WHITE )\n\t{\n\t\t// material\n\t\tcol = vec3(1.);\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\t\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\t\tvec3 ambient = vec3(.3,.3,.4);\n\t\tcol += ambient*(1.-col);\n        \n        //Uncomment for the Little Big Planet versions\n        //vec2 uv = vec2(pos.z*1.5,pos.y*1.5);\n        //vec3 text = texture( iChannel0, uv, 0.0 ).rgb;\n\t\t//col*=text*1.2;\n\t}\n\telse if( m == BLACK )\n\t{\n\t\tcol = vec3(.0);\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\t\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\t}\n\telse if( m == BLUE )\n\t{\n\t\tcol = vec3(.1,.1,.5);\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\t\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\t\tvec3 ambient = vec3(.2,.2,.5+sin(iTime)*.1);\n\t\tcol += ambient*(1.-col);\n\n\t}\n    \n\telse if( m == PINK )\n\t{\n\t\t// material\n\t\tcol = vec3(.85,0.4,.45);\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\t\tvec3 ambient = col/3.;\n\t\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\t\tcol += ambient*(1.-col);\n\t}\n\n\treturn col;\n}\n\n//------------------------------------------------------------------ CAMERA\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n//------------------------------------------------------------------ MAIN\n// setup cam\n// render\n// apply postEffect\n//---------------------\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tfloat time = iTime;\n\tvec2 uv = coords.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\n\tvec2 q = coords.xy/iResolution.xy;\n\tvec2 p = (-iResolution.xy+2.0*coords.xy)/iResolution.y;\n\n\tfloat angle = 0.-time;\n\tfloat radius = 35.;\n    vec3 ro = vec3(cos(angle)*radius,cos(time/3.)*4.+9.,sin(angle)*radius);\n\tvec3 ta = vec3(0.);\n\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.5) );\n\n\tvec3 color = render( ro, rd, uv );\n\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}