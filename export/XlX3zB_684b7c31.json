{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\n#define DISPLAY_FACES true\n#define DISPLAY_SEGMENTS true\n#define DISPLAY_VERTICES true\n\nint Type=3;\nfloat U=0.,V=0.,W=1.;\nfloat SRadius=0.03, VRadius=0.07;\n\nvec3 nc,p,pab,pbc,pca;\nvoid init() {//setup folding planes and vertex\n\tfloat t=iTime;\n    Type=int(fract(0.025*t)*3.)+3;\n    U=0.5*sin(t*1.5)+0.5;\n    V=0.5*sin(t*0.8)+0.5;\n    W=0.5*sin(t*0.3)+0.5;\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tp=normalize((U*pab+V*pbc+W*pca));//U,V and W are the 'barycentric' coordinates (coted barycentric word because I'm not sure if they are really barycentric... have to check)\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\nvec3 fold(vec3 pos) {\n\tfor(int i=0;i<5 /*Type*/;i++){\n\t\tpos.xy=abs(pos.xy);//fold about xz and yz planes\n\t\tpos-=2.*min(0.,dot(pos,nc))*nc;//fold about nc plane\n\t}\n\treturn pos;\n}\n\nfloat D2Planes(vec3 pos) {//distance to the 3 faces\n\tpos-=p;\n    float d0=dot(pos,pab);\n\tfloat d1=dot(pos,pbc);\n\tfloat d2=dot(pos,pca);\n\treturn max(max(d0,d1),d2);\n}\n\nfloat length2(vec3 p){ return dot(p,p);}\n\nfloat D2Segments(vec3 pos) {\n\tpos-=p;\n\tfloat dla=length2(pos-min(0.,pos.x)*vec3(1.,0.,0.));\n\tfloat dlb=length2(pos-min(0.,pos.y)*vec3(0.,1.,0.));\n\tfloat dlc=length2(pos-min(0.,dot(pos,nc))*nc);\n\treturn sqrt(min(min(dla,dlb),dlc))-SRadius;\n}\n\nfloat D2Vertices(vec3 pos) {\n\treturn length(pos-p)-VRadius;\n}\n\nfloat Polyhedron(vec3 pos) {\n\tpos=fold(pos);\n\tfloat d=10000.;\n\tif(DISPLAY_FACES) d=min(d,D2Planes(pos));\n\tif(DISPLAY_SEGMENTS) d=min(d,D2Segments(pos));\n\tif(DISPLAY_VERTICES)  d=min(d,D2Vertices(pos));\n\treturn d;\n}\n\nvec3 getColor(vec3 pos){//Not optimized.\n#define Face0Color vec3(.8,0.6,0.);\n#define Face1Color vec3(0.3,0.7,0.2);\n#define Face2Color vec3(0.1,0.4,1.);\n#define SegmentsColor vec3(0.4,0.4,0.7);\n#define VerticesColor vec3(1.,.4,.3);\n\tpos=fold(pos);\n\tfloat d0=1000.0,d1=1000.0,d2=1000.,df=1000.,dv=1000.,ds=1000.;\n\tif(DISPLAY_FACES){\n\t\td0=dot(pos-p,pab);\n\t\td1=dot(pos-p,pbc);\n\t\td2=dot(pos-p,pca);\n\t\tdf=max(max(d0,d1),d2);\n\t}\n\tif(DISPLAY_SEGMENTS) ds=D2Segments(pos);\n\tif(DISPLAY_VERTICES) dv=D2Vertices(pos);\n\tfloat d=min(df,min(ds,dv));\n\tvec3 col=Face0Color;\n\tif(d==df){\n\t\tif(d==d1) col=Face1Color;\n\t\tif(d==d2) col=Face2Color;\n\t}else{\n\t\tif(d==ds) col=SegmentsColor;\n\t\tif(d==dv) col=VerticesColor;\n\t}\n\treturn col;\n}\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 p)\n{\n    //return length(p)-1.;\n\treturn mix(length(p)-1.,Polyhedron(p),0.8);//just for fun\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    p.yz = rotate(p.yz, iTime * 0.2 + (iMouse.y-0.5*iResolution.y)*PI2/360.);\n    p.zx = rotate(p.zx, iTime * 0.125 + (0.5*iResolution.x-iMouse.x)*PI2/360.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.3 + p.y * 0.1);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    init();\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        col = getColor(pos) * dif;\n        col = pow(col, vec3(0.8));\n\t}\n   \tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlX3zB","date":"1422817818","viewed":2194,"name":"Polyhedron again","username":"knighty","description":":D","likes":61,"published":1,"flags":0,"usePreview":0,"tags":["de","polyhedron"],"hasliked":0,"parentid":"","parentname":""}}