{"ver":"0.1","info":{"id":"tdSfWG","date":"1595142001","viewed":2385,"name":"OCEAN SURFACE: FOURIER","username":"alro","description":"IDFT ocean shader based on Tessendorf's paper. Use mouse to move camera.","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["waves","sea","simulation","water","ocean","fourier","dft","tessendorf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Studying Tessendorf's ocean paper.\n//Thanks to @nbickford for helping fix the spectrum code.\n//https://www.shadertoy.com/view/wt2yRd\n\n//Based on:\n// \"Simulating Ocean Water\", Jerry Tessendorf\n// http://asu-cs.donntu.org/sites/default/files/images/doc/opencl.programming.guide.pdf ch. 18\n// https://arm-software.github.io/opengl-es-sdk-for-android/ocean_f_f_t.html\n// \"Realistic simulation of ocean surface using wave spectra\", Jocelyn Fr√©chot\n// https://www.shadertoy.com/view/3sf3Dj\n\n//Common: Simulation variables and general description\n//Buffer A: Phillips spectrum with camera and variable tracking\n//Buffer B: Fourier coefficients at time t\n//Buffer C: Inverse discrete fourier transform\n//Buffer D: Normal map\n//Image: Ray marching and shading\n\n//TODO: DFT for normals\n//\t\tLateral movement\n//\t\tFolding map for foam\n//\t\tHeight normalisation (Parseval's identity)?\n\n// Average the results of a 2x2 region of subpixel samples for antialiasing.\n//#define AA\n\n// The surface of the ocean can be modelled as a sum of sinusoids with more waves producing a \n//\tbetter look. The paper uses the number of grid points of its ocean as the number of waves.\n//\n// Waves here mean complex sine waves with unique frequencies and phases which are used as \n//\tthe building blocks of the ocean surface. The frequencies used constitute the spectrum \n//\tof the ocean surface. \n//\n// The Philips spectrum generates \"the estimated variance for waves at certain wavelengths \n//\tbased on wind direction and speed.\"\n// \n// The spectrum gives energy based on frequency. The energy information is converted into \n//\twave amplitudes and these are assigned random real and imaginary parts.\n//\n// Adding the waves together to produce a realistic ocean surface is slow with a regular \n//\tsummation but fast with an inverse FFT. On Shadertoy, an inverse DFT works better with \n//  fewer passes and buffers used. IDFT code is from https://www.shadertoy.com/view/3sf3Dj\n\n// The algorithm:\n//\t1) On an NxN grid, generate NxN wave energies using the Philips spectrum.\n//\t2) Turn these into random Fourier amplitudes at time 0 using a Gaussian distribution.\n//\t3) For each position on the ocean surface, use the IDFT to sum together the spectrum waves\n//\t   at time t, which is found from the amplitudes at time 0 and a dispersion relation.\n//\t4) The real part of the IDFT sum is the height of the ocean at the sample point.\n//\t5) Normals can be found through calculating the local gradient or by another IDFT, \n//\t   which is more accurate. We use gradients.\n\n// Questions (answers and corrections are welcome):\n//\n//\tHow does equation 25 give the wave amplitudes?\n//\t\tThe 1/sqrt(2) or 0.707 term is the root mean square (RMS) of a sine wave with \n//\t\tamplitude 1. https://apps.dtic.mil/dtic/tr/fulltext/u2/739935.pdf table 1.2 says that \n//\t\t\"the average wave will have an amplitude of 0.707*sqrt(variance)\". Why is that?\n//\n//\tHow does equation 26 give the waves at time t?\n//\t\tA real sinusoid can be expressed as the sum of two complex sinusoids with frequencies\n//\t\tof opposite signs.\n//\n//\t\thttps://www.youtube.com/watch?v=Tm3gI6PQOYo&feature=youtu.be&t=456\n//\t\thttps://en.wikipedia.org/wiki/Wave_equation#Plane_wave_eigenmodes\n//\t\thttps://en.wikipedia.org/wiki/Superposition_principle#Wave_superposition\n//\n//\t\t[4]: \"To decrease the FFT computation time by a factor two, real numbers can be used \n//\t\tinstead of complex ones. This is achieved by adding two waves with same amplitude \n//\t\tand travelling in opposite direction.\"\n//\n//\tWhy then do large waves move with the wind?\n//\t\tIf the formulation creates standing waves which are expressed as the superposition of \n//\t\troughly equal but opposite moving complex sinusoids, then why do large wind speeds \n//\t\tproduce waves travelling in the wind direction? Where does this bias come in? \n//\t\tThe negative dispersion term for opposite travelling waves in equation 26.\n//\n//\tWhat is the logic of the Phillips spectrum?\n//\t\tJust a description based on empirical data.\n//\n//\tHow would the lateral movement of grid points for sharp features work in shadertoy?\n//\t\tCould https://www.shadertoy.com/view/ttsSzX be used to achieve lateral movement and \n//\t\tincreased speed by changing ray marching into ray/plane intersection?\n//\n\nconst int MAX_STEPS = 300;\nconst float MAX_DIST = 400.0;\nconst float EPSILON = 1e-4;\n\nconst vec3 skyColour = vec3(0.09, 0.33, 0.81);\nconst vec3 sunLightColour = vec3(1);\nconst vec3 sunColour = sunLightColour;\n\nfloat specularStrength = 1.0;\nfloat shininess = 512.0;\nconst vec3 specularColour = sunLightColour;\n\n//In a circle of 2*PI\nconst float sunLocation = 0.0;\nconst float sunHeight = 0.5;\n\nconst float diffuseStrength = 0.2;\nconst vec3 diffuseColour = diffuseStrength * vec3(0.05,0.4,0.65);\n\nfloat ambientStrength = 0.5;\nvec3 ambientColour = 0.5 * diffuseColour;\n\nvec3 scatterColour = vec3(0.05, 0.8, 0.7);\nfloat power = 8.0;\nfloat scale = 0.4;\nfloat distortion = 0.2;\nfloat scatterStrength = 0.5;\n\n\n//https://iquilezles.org/articles/hwinterpolation\nvec3 bilinearTexture(sampler2D sampler, vec2 uv){\n    \n    ivec2 iuv = ivec2( uv );\n    vec2 f = fract( uv );\n    \n    //f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec3 a = texelFetch(sampler, (iuv+ivec2(0.0,0.0)), 0).rgb;\n    vec3 b = texelFetch(sampler, (iuv+ivec2(1.0,0.0)), 0).rgb;\n    vec3 c = texelFetch(sampler, (iuv+ivec2(0.0,1.0)), 0).rgb;\n    vec3 d = texelFetch(sampler, (iuv+ivec2(1.0,1.0)), 0).rgb;\n\n    return mix( mix( a, b, f.x),mix( c, d, f.x), f.y );\n}\n\nvec2 getUV(vec3 pos){\n    //The height field and normal map are tiles of SIZE * SIZE pixels\n    //with a 1-pixel wide tranmissive halo around it for interpolation.\n\treturn modulo(SCALE*pos.xz, SIZE) + 1.0;\n}\n\n//Get height of waves at xz coordinates.\nfloat getHeight(vec3 pos){\n    vec2 uv = getUV(pos);\n    return HEIGHT_SCALE*texture(iChannel1, uv/iChannelResolution[1].xy, 0.0).r;\n}\n\n//Get normal from normal map.\nvec3 getNormal(vec3 pos){\n    vec2 uv = getUV(pos);\n    //There are texture filtering artefacts on some machines. Interpolate manually.\n    return normalize(bilinearTexture(iChannel2, (uv)).rgb);\n    /*\n    return normalize(texture(iChannel2, uv/iChannelResolution[2].xy, 0.0).rgb);\n\t*/\n}\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//Darken sky when looking up and add a white haze at the horizon.\nvec3 getSkyColour(vec3 rayDir){\n    return mix(vec3(1), mix(skyColour, 0.2*skyColour, rayDir.y), \n               smoothstep(-0.5, 0.25, rayDir.y));\n}\n\n//Binary search for 0 crossing given two points on either side of the surface.\nfloat bisection(vec3 start, vec3 rayDir, float near_, float far_){\n    float midpoint = (far_ + near_) * 0.5;\n    //Sample point\n    vec3 p = vec3(0);\n    float near = near_;\n    float far = far_;\n    float height = 0.0;\n    //Difference between sample point and water height.\n    float diff = 0.0;\n    \n    for(int i = 0; i < 8; i++){\n        p = start + rayDir * midpoint;\n        height = getHeight(p);\n        diff = p.y - height;\n        \n        if(abs(diff) < EPSILON){\n        \tbreak;\n        }else{\n            \n            if(diff < EPSILON){\n                //Point is below waves\n                //Search first half\n                far = midpoint;\n            }else{\n                //Point is above waves\n                //Search second half\n                near = midpoint;\n            }\n            midpoint = (far + near) * 0.5;\n        }\n    }\n    return midpoint;\n}\n\n//Assume normalised vectors.\nbool getPlaneIntersection(vec3 org, vec3 ray, vec3 planePoint, vec3 normal, out float t){\n    float denom = dot(normal, ray); \n    if (denom > 1e-6) { \n        vec3 p0l0 = planePoint - org; \n        t = dot(p0l0, normal) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nfloat getIntersection(vec3 start, vec3 rayDir){\n\t//Distance between sample points. Set according to previous sample.\n    float stepSize = 0.0;\n    //Height of the waves.\n    float height = 0.0;\n    //Length of the ray.\n    float dist = 0.0;\n    //Difference between sample point and wave heights.\n    float diff = 0.0;\n    \n    //Start ray tracing from intersection with xz-plane at y == 2*A.\n    float distToStart = 0.0;\n    bool hitsPlane = getPlaneIntersection(start, rayDir, vec3(0.0, 3.0*A, 0.0), \n                                          vec3(0,-1,0), distToStart);\n    if(hitsPlane){\n        dist =  distToStart;\n    }\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        //Sample point\n        vec3 p = start + rayDir * dist;\n        \n        //The height of the waves at the xz coordinates of the sample point.\n        height = getHeight(p);\n        \n        diff = abs(p.y - height);\n        \n        //If sample point is close enough to the water surface, return distance.\n        if(diff < EPSILON){\n            return dist;\n        }\n        //If height of sample point is less than the height of the waves,\n        //the ray has hit the water. Use bisection to find the 0 crossing.\n        if(p.y < height){\n        \tdist = bisection(start, rayDir, dist - stepSize, dist);\n            return dist;\n        }\n        \n        //Static step size misses features and leads to banding. \n        //Set the step size to a fraction of the distance above the waves.\n        //Could also have a small step size which increases with distance, giving \n        //detailed results close to the camera and reaching far. However, \n        //this approach is used in many shaders and seems to give best results.\n        stepSize = diff * 0.5;\n        \n        //Increment ray\n        dist += stepSize;\n        \n        if(dist > MAX_DIST){\n        \treturn MAX_DIST;\n        }\n    }\n    return dist;\n}\n\n//https://learnopengl.com/PBR/Theory\nfloat fresnelSchlick(vec3 cameraPos, vec3 position, vec3 normal){\n    float cosTheta = dot(normal, normalize(cameraPos - position));\n\tfloat F0 = 0.02;\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//Return colour of surface fragment based on light information.\nvec3 shading(vec3 cameraPos, vec3 position, vec3 normal, vec3 rayDir, \n             float dist, vec3 lightDirection){\n    \n\tvec3 result = vec3(0.0); \n    \n\tvec3 halfwayDir = normalize(lightDirection - rayDir);  \n\tfloat spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\n\n\t//Colour of light sharply reflected into the camera.\n\tvec3 specular = spec * specularColour * sunLightColour; \n\t\n\t//How much a fragment faces the sun.\n\tfloat sun = max(dot(normal, lightDirection), 0.0);\n    //Main sunlight contribution.\n    vec3 sunLight = sun * sunLightColour;\n    \n    //How much the fragment faces up.\n    float sky = max(dot(normal, vec3(0,1,0)), 0.0);\n    //Sky light. A blue light from directly above.\n\tvec3 skyLight = sky * skyColour;\n    \n    //Combine light\n    result += 0.1 * sunLight;\n    result += 0.1 * skyLight;\n    \n    //Sample point height in the wave.\n    float heightFraction = saturate((position.y + A)  / (2.0*A));\n\n    //Lighten the water when looking towards the horizon and darken it straight down.\n    vec3 col = mix(ambientColour, 0.5*scatterColour, pow(0.5+0.5*rayDir.y, 2.0));\n\n    //Light and material interaction.\n    result *= diffuseColour;\n    result += ambientStrength * col + specularStrength * specular;\n    \n    //Fake subsurface scattering based on light direction and surface normal.\n    //https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/\n    vec3 h = normalize(-lightDirection + normal * distortion);\n\tfloat vDotH = pow(saturate(dot(rayDir, -h)), power) * scale;\n    \n    //Scattering in stronger higher in the wave.\n    result += scatterStrength * pow((1.0-dist/MAX_DIST), 4.0) * \n        \t\theightFraction * vDotH * scatterColour;\n    \n    //Reflection of the sky.\n    vec3 reflectedDir = normalize(reflect(rayDir, normal));\n    vec3 reflectedCol = getSkyColour(reflectedDir);\n    float fresnel = saturate(fresnelSchlick(cameraPos, position, normal));\n   \tresult = mix(result, 0.5*reflectedCol, fresnel);\n    \n    return  result;\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n\treturn pow(radius/dist, intensity);\t\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //Camera position is persistent and calculated in BufferA.\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(xidx, 1.5), 0).xyz;\n    vec3 targetDir = -cameraPos;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    //Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n    \n    vec3 lightDirection = normalize(vec3(sin(sunLocation), sunHeight, cos(sunLocation)));\n    vec3 col = vec3(0);\n    vec3 rayDir;\n    bool skyVisible = false;\n\n    #ifdef AA\n    \n    for(int i = 0; i <= 1; i++) {\n        for(int j = 0; j <= 1; j++) {\n\n            //Get the default direction of the ray (along the negative Z direction).\n            rayDir = rayDirection(55.0, fragCoord+vec2(i,j)/2.0);\n            \n            #else\n            \n            rayDir = rayDirection(55.0, fragCoord);\n            \n            #endif\n\n            //Transform the ray to point in the correct direction.\n            rayDir = normalize(viewMatrix * rayDir);\n\n            float dist = MAX_DIST;\n\n            //Only render water for rays pointing down.\n            if(rayDir.y < 0.0){\n                //Find the distance to where the ray stops.\n                dist = getIntersection(cameraPos, rayDir);\n            }\n\n            if(dist == MAX_DIST){\n                skyVisible = true;\n                col += getSkyColour(rayDir);\n            }else{\n                vec3 position = cameraPos + rayDir * dist;\n\n                float xzDist = length(cameraPos.xz - position.xz);\n\n                vec3 normal = getNormal(position);\n                col += shading(cameraPos, position, normal, rayDir, dist, lightDirection);\n            }\n            #ifdef AA\n        }\n    }\n\n    col *= 0.25;\n    \n    #endif\n\n    //Display the sun as a glow in the light direction.\n    if(skyVisible){\n        float mu = dot(rayDir, lightDirection);\n        col += sunColour*getGlow(1.0-mu, 0.0005, 1.0);\n    }\n    \n    //Tonemapping.\n    col = ACESFilm(col);\n\n    //Gamma correction 1.0/2.2 = 0.4545...\n    col = pow(col, vec3(0.4545));\n    \n    //Output to screen.\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Phillips spectrum, camera and variable changes.\n\n//Root mean square of sinusoid with amplitude 1.\nconst float RMS = 1.0/sqrt(2.0);\n\nfloat random(vec2 par){\n   return fract(sin(dot(par.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//https://www.shadertoy.com/view/4ssXRX\n//http://www.dspguide.com/ch2/6.htm\nfloat gaussianRandom(vec2 seed){\n\tfloat nrnd0 = random(seed);\n\tfloat nrnd1 = random(seed + 0.1);\t\n\treturn sqrt(-2.0*log(max(0.001, nrnd0)))*cos(TWO_PI*nrnd1);\n}\n\n//In the paper, vector k is the wave vector and the scalar k is its magnitude.\nfloat phillips(vec2 k, vec2 windDir, float L, float lMax){\n    float kMagnitude = length(k);\n    //Avoid division by 0 and NaN values\n    if(kMagnitude == 0.0){\n    \treturn 0.0;\n    }\n    //Stop waves travelling perpendicular to the wind.\n    float kw = pow(dot(normalize(k), normalize(windDir)), 2.0);\n   \tfloat p = A * (exp(-1.0/(kMagnitude * L * L))/pow(kMagnitude, 4.0)) * kw;\n    //Limit waves that are too small.\n    return p * exp(-1.0 * kMagnitude * kMagnitude * lMax * lMax);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    if(fragCoord.x > 0.5 && fragCoord.x < SIZE + 1.0 && \n       fragCoord.y > 0.5 && fragCoord.y < SIZE + 1.0){\n            //Values of SIZE, SIDE and A last frame\n        \tvec3 oldData0 = texelFetch(iChannel0, ivec2(xidx, 4.5), 0).rgb;\n            bool resetFlag = false;\n            if(oldData0 != vec3(SIZE, SIDE, A)){\n            \tresetFlag = true;\t\n            }\n\n            //Values of windDir and V last frame\n        \tvec3 oldData1 = texelFetch(iChannel0, ivec2(xidx, 5.5), 0).rgb;\n            \n            if(oldData1 != vec3(windDir, V)){\n            \tresetFlag = true;\t\n            }\n        \n        if(iFrame < 1 || resetFlag){\n            \n            vec4 h = vec4(0);\n\n            //Spectrum tile is shifted by 1 in the buffer.\n            float n = (fragCoord.x-1.5) - SIZE/2.0;\n            float m = (fragCoord.y-1.5) - SIZE/2.0;\n\n            vec2 k = (TWO_PI * vec2(n, m)) / SIDE;\n\n            //Random real and imaginary coefficients.\n            float er = gaussianRandom(fragCoord.xy*0.01);\n            float ei = gaussianRandom(fragCoord.xy*0.001);\n\n            float pk = phillips(k, windDir, L, L * 1.0e-4);\n\n            //Equation 25\n            h.x = RMS * (er) * sqrt(pk);\n            h.y = RMS * (ei) * sqrt(pk);\n\n            //Same for -k\n            //Random real and imaginary coefficients.\n            er = gaussianRandom((iResolution.xy+fragCoord.xy)*0.01);\n            ei = gaussianRandom((iResolution.xy+fragCoord.xy)*0.001);\n\n            pk = phillips(-k, windDir, L, L * 1.0e-4);\n\n            //Equation 25 for -k\n            h.z = RMS * (er) * sqrt(pk);\n            h.w = RMS * (ei) * sqrt(pk);\n\n            fragColor = h;\n            \n        }else{\n            \n            fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n            \n        }\n        \n    }else if((fragCoord.x == xidx) && (fragCoord.y < 6.0)){\n        \n    \t//Store camera and data change in unused pixels\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = modulo(polarAngles.x, TWO_PI - angleEps);\n        polarAngles.y = min(0.49*PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(1.3, 1.2);\n                mouse = vec2(0);\n            }\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        //Store resolution change data\n        if(fragCoord == vec2(xidx, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(xidx, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n        \n        //Store whether the mouse button is down\n        if(fragCoord == vec2(xidx, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n        //When grid or wind variables change, we need to restart the IDFT as it takes two frames\n        //to produce the height field and a change in between leads to wrong results.\n        if(fragCoord == vec2(xidx, 4.5)){\n            //Values of SIZE, SIDE and A last frame\n        \tvec3 oldData = texelFetch(iChannel0, ivec2(xidx, 4.5), 0).rgb;\n            float resetIDFT = 0.0;\n            if(oldData != vec3(SIZE, SIDE, A)){\n            \tresetIDFT = 1.0;\t\n            }\n            fragColor = vec4(SIZE, SIDE, A, resetIDFT);\n        }\n        \n       \tif(fragCoord == vec2(xidx, 5.5)){\n            //Values of windDir and V last frame\n        \tvec3 oldData = texelFetch(iChannel0, ivec2(xidx, 5.5), 0).rgb;\n            float resetIDFT = 0.0;\n            if(oldData != vec3(windDir, V)){\n            \tresetIDFT = 1.0;\t\n            }\n            fragColor = vec4(windDir, V, resetIDFT);\n        }\n        \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2020 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define PI 3.14159\n#define TWO_PI 6.283185\n#define CAMERA_DIST 132.0\n\n//Index of pixels outside Fourier tile to store camera and other data.\n//Shift spectrum tile by one pixel and use first pixels in Buffer A \n//to store persistent data.\nfloat xidx = 0.5;\n\n//Grid, wave and wind constants are tracked using BuffferA.\n//Changes to other variables require time reset for iFrame = 0\n\n//Size of wave vector and IDFT grids.\nconst float SIZE = 128.0;\n\n//Length of patch side in metres.\nconst float SIDE = 64.0;\n\n//Tiling of wave patch.\nconst float SCALE = 1.0;\n\n//Wave height multiplier for spectrum.\nconst float A = 3.0;\n\n//Wave height multiplier for height field.\nconst float HEIGHT_SCALE = 1.0/(3.0*SIDE);\n\n//Wind direction.\nconst vec2 windDir = normalize(vec2(0.2,1));\n\n//Wind speed.\nconst float V = 12.0;\n\n//Gravitational constant.\n//Change not tracked.\nconst float g = 9.81;\n\n//Height of largest wave.\n//Change not tracked.\nconst float L = pow(V, 2.0)/g;\n\n//Multiplier for iTime.\nconst float SPEED = 1.0;\n\n//Complex arithmetic.\nvec2 c_mul(vec2 a, vec2 b){\n    return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 c_conj(vec2 a){\n\treturn vec2(a.x, -a.y);\n}\n\nvec2 c_exp(float x){\n\treturn vec2(cos(x), sin(x));\n}\n\n//Better modulo across 0.\nvec2 modulo(vec2 p, float s){\n\treturn mod(mod(p, s) + s, s);\n}\n\nfloat modulo(float m, float n){\n  return mod(mod(m, n) + n, n);\n}\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Fourier coefficients at time t\n//Equation 26\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec4 col = vec4(0);\n\n    if(fragCoord.x < SIZE && fragCoord.y < SIZE){\n\n        vec4 h0 = texelFetch(iChannel0, ivec2(fragCoord.xy+1.0), 0);\n        vec2 h0_k = h0.xy;\n        vec2 h0_minus_k = h0.zw;\n\n        //Spectrum tile is shifted by 1 in the buffer.\n        vec2 k = (TWO_PI * ((fragCoord.xy-1.5) - SIZE/2.0)) / SIDE;\n\n        float dispersion = sqrt(g * length(k)) * iTime * SPEED;\n\n        vec2 hkt = c_mul(h0_k, c_exp(dispersion)) + \n            c_conj(c_mul(h0_minus_k, c_exp(-dispersion)));\n\n        col.rg = hkt;\n    }\n\n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Summation of wave amplitudes using an inverse discrete fourier transform. \n//Produces the height field with a single halo layer around it for interpolation.\n\n//IDFT from https://www.shadertoy.com/view/3sf3Dj\n//It takes two frames to produce the final height field as first all the elements\n//are added up horizontally and stored in Buffer C and the next frame the results \n//are read and added up vertically. BA channels hold the intermediate sum and \n//RG hold the final sum. The height field is \"one frame late\" compared to input.\n\n//Shifts the spectrum by half the grid.\n//Doesn't seem to work without this. Why?\nfloat shift(float x){\n    return mod(x + SIZE/2.0, SIZE);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec4 col = vec4(0);\n\n    bool resetFlag0 = texelFetch(iChannel0, ivec2(xidx, 4.5), 0).a == 1.0;\n    bool resetFlag1 = texelFetch(iChannel0, ivec2(xidx, 5.5), 0).a == 1.0;\n\n    if(!(resetFlag0 || resetFlag1)){\n\n        if(fragCoord.x < SIZE+2.0 && fragCoord.y < SIZE+2.0){\n\n            float column = fragCoord.x - 1.0;\n            float row = fragCoord.y - 1.0;\n\n            if(fragCoord.x == 0.5){\n                column = SIZE - 1.0;\n            }\n            if(fragCoord.y == 0.5){\n                row = SIZE - 1.0;\n            }\n            if(fragCoord.x == SIZE + 1.5){\n                column = 0.0;\n            }\n            if(fragCoord.y == SIZE + 1.5){\n                row = 0.0;\n            }\n            for(float n = 0.0; n < SIZE; n++){\n                float m = shift(n);\n                vec2 h_tilde = texelFetch(iChannel1, ivec2(m, row), 0).xy;\n                vec2 horizontalSum = texelFetch(iChannel2, ivec2(column, m), 0).zw;\n                vec2 a = TWO_PI * (fragCoord.xy-0.5) * n/SIZE;\n\n                col.zw += c_mul(h_tilde, c_exp(a.x));\n                col.xy += c_mul(horizontalSum, c_exp(a.y));\n\n            }\n        }\n    }\n    fragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Normal texture from heigh field finite-difference.\n//Has a single layer transmissive halo for interpolation.\n\nvec2 left(vec2 uv){\n    if(uv.x == 0.0){\n    \treturn vec2(SIZE-1.0, uv.y);\n    }\n\treturn uv+vec2(-1.0, 0.0);\n}\n\nvec2 right(vec2 uv){\n    if(uv.x == SIZE+1.0){\n    \treturn vec2(2.0, uv.y);\n    }\n\treturn uv+vec2( 1.0, 0.0);\n}\n\nvec2 bottom(vec2 uv){\n    if(uv.y == 0.0){\n    \treturn vec2(uv.x, SIZE-1.0);\n    }\n\treturn uv+vec2( 0.0,-1.0);\n}\n\nvec2 top(vec2 uv){\n    if(uv.y == SIZE+1.0){\n    \treturn vec2(uv.x, 2.0);\n    }\n\treturn uv+vec2( 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec3 norm = vec3(1);\n    \n    if(fragCoord.x < SIZE+2.0 && fragCoord.y < SIZE+2.0){\n        vec2 uv = fragCoord.xy-0.5;\n\t\tvec3 a = vec3(-1.0, HEIGHT_SCALE*texelFetch(iChannel0, ivec2(left(uv)\t), 0).r,  0.0);\n    \tvec3 b = vec3( 1.0, HEIGHT_SCALE*texelFetch(iChannel0, ivec2(right(uv)\t), 0).r,  0.0);\n\t\tvec3 c = vec3( 0.0, HEIGHT_SCALE*texelFetch(iChannel0, ivec2(bottom(uv)), 0).r, -1.0);\n    \tvec3 d = vec3( 0.0, HEIGHT_SCALE*texelFetch(iChannel0, ivec2(top(uv)\t), 0).r,  1.0);\n    \tnorm = normalize(cross(c - d, a - b));\n    }\n    fragColor = vec4(norm, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}