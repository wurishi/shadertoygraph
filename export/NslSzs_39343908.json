{"ver":"0.1","info":{"id":"NslSzs","date":"1619074957","viewed":51,"name":"MMX parametric pacman gate","username":"yakovgal","description":"MMX parametric pacman gate\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mmx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tau = 6.283185, pi = tau/2.;\n\n/*\ntop red spot --\n    drop point; the last point of contact of the top marble before it's dropped into the \"primed\" position\n\nbottom red spot --\n    release point; the last point of contact of the primed marble prior to release\n    \nblack dot --\n    axis of rotation\n\nblue regions --\n    area outside of the marble channel\n\n\nThe gate geometry is the subset of the gray region.\nThe only material that's important is the contact points (red spots).\nEverything else can be subtracted.\n\n\ntodo: round contact points -- equivalent to increasing marble_r by the round radius, solving, and then extruding the gate by the same amount.\n\n*/\n\n// parameters\nconst float marble_R = 7.9375; // marble radius\nconst float contact_z = 0.0; // offset of the contact plane along the axle\nconst float separation = -0.5; // distance to keep between top and primed marble (must be <= 0)\nconst float swing_angle = tau/360.0*25.0;\nconst float offset_x = 2.0; // horizontal offset of axis from marble release point\nconst float offset_y = 4.0; // vertical offset of axis from marble release point\nconst float scale = 15.0; // i.e. zoom\n\n// derived quantities\nconst float marble_r = sqrt(marble_R*marble_R - contact_z*contact_z);\nconst vec2 jaw1 = vec2(-offset_x, -offset_y);\n\nconst vec2 nn = vec2(cos(swing_angle), sin(swing_angle));\nconst vec2 dd = vec2(-sin(swing_angle), cos(swing_angle));\nconst vec2 vv = jaw1 + vec2(-marble_r, 2.*marble_R + separation) + offset_x*nn;\nconst float nnvv = dot(nn,vv);\nconst vec2 jaw0 = (dot(dd,vv) - sqrt(marble_r*marble_r - nnvv*nnvv))*dd - offset_x*nn; // intersection of rotated channel wall with top marble\n\n\nvec2 cosin(float a) { return vec2(cos(a), sin(a)); }\nvec4 blend(vec4 x, vec4 y) { return x*(1.-y.a) + y; } // y over x\nfloat edge(float d) { return smoothstep(.5/scale, -.5/scale, d); }\n\n\n// SDF of a segment by IQ\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// green marble\nvec4 marble(vec4 c, vec2 uv) {\n    float d = length(uv) - marble_R;\n    float nz = sqrt(max(1. - dot(uv/marble_R,uv/marble_R), 0.));\n    c = blend(c, edge(d)*mix(vec4(0,0.4,0,1), vec4(.5,.8,.5,1), nz));\n    d = length(uv) - marble_r;\n    c += vec4(.1,.1,.1,0)*edge(d); // lighten up the part infront of the contact plane\n    return c;\n}\n\n// push the marble from p along d till it hits c\nvec2 trace(vec2 p, vec2 d, vec2 c) {\n    vec2 n = vec2(-d.y,d.x);\n    c -= p;\n    float t = dot(c,d);\n    float s = dot(c,n);\n    return p + d*(t - sqrt(marble_r*marble_r - s*s));\n}\n\nvoid mainImage( out vec4 OUT, in vec2 fragCoord )\n{\n    vec2 uv = 1./scale*(fragCoord - iResolution.xy/2.) - vec2(offset_x, 0);\n    vec4 c_fore = vec4(0), c_back = vec4(1);\n    float a = -(1. - cos(iTime))/2.*swing_angle;\n    mat2 M = mat2(cos(a), -sin(a), sin(a), cos(a));\n    bool primed = fract(iTime/tau) >= 0.5;\n    \n    //uv = transpose(M)*uv;\n\n    // marbles\n    vec2 j = transpose(M)*(primed ? jaw1 : jaw0); // contact point in uv\n    j.x += offset_x + marble_r;\n\n    float y = uv.y - (j.y + sqrt(marble_r*marble_r - j.x*j.x));\n    if(y > 0.)\n        y = mod(y+marble_R, 2.*marble_R)-marble_R;\n\n    c_back = marble(c_back, vec2(uv.x+marble_r+offset_x,y));\n\n    // channel; axis of rotation is at uv = 0\n    if(uv.x > -offset_x || uv.x < -offset_x - 2.*marble_r)\n        c_fore = blend(c_fore, vec4(0,0,.1,.5));\n    c_fore = blend(c_fore, edge(length(uv) - .5)*vec4(0,0,0,1));\n\n\n    // render the gate in rotated frame of reference\n    uv = M*uv;\n    \n    // lower channel\n    float sd = sdSegment(uv - jaw1, vec2(-marble_r, 0), vec2(-marble_r, -100.));\n\n    // upper channel\n    {\n        vec2 p = trace(vec2(-marble_r-offset_x,0), vec2(0,-1), jaw0);\n        sd = min(sd, sdSegment(uv, p, p+vec2(0, 100)));\n    }\n\n    // upper channel rotated\n    {\n        vec2 d = cosin(tau/4. + swing_angle);\n        vec2 n = vec2(-d.y,d.x);\n        vec2 p = trace(jaw0 + n*marble_r, -d, jaw1);\n        sd = min(sd, sdSegment(uv, p, p + d*100.));\n    }\n    \n    // primed marble negative space\n    // I don't know of an analytic solution, so do a discrete approximation\n    for(float a = 0.; a < swing_angle; a += 0.05)\n    {\n        vec2 n = -cosin(a);\n        vec2 d = vec2(n.y, -n.x);\n        \n        float s = dot(jaw1,n) - (offset_x + marble_r);\n        float t = dot(jaw1,d);\n        vec2 p = (t + sqrt(marble_r*marble_r - s*s))*d + (offset_x + marble_r)*n;\n\n        sd = min(sd, length(uv - p));\n    }\n\n\n    float inside = edge(marble_r - sd);\n    \n    vec4 c_gate = vec4(.2,.2,.2,1.);\n    float contact = edge(min(length(uv - jaw0), length(uv - jaw1)) - 0.2);\n    c_gate = blend(inside*c_gate, contact*vec4(1,0,0,1));\n\n    OUT = blend(blend(c_back, c_gate), c_fore);\n    OUT.rgb = pow(OUT.rgb, vec3(0.4545));\n}\n","name":"Image","description":"","type":"image"}]}