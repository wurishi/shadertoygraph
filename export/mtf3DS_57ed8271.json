{"ver":"0.1","info":{"id":"mtf3DS","date":"1672314353","viewed":109,"name":"Spot Light Falloff - Cornell Box","username":"wagyx","description":"A simple point light with some fall off.\nClick on the image to set the light position.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["light","spot","falloff"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n*/\n\n\n/**\nRAYMARCHING ALGORITHM\nfrom  Ray Marching: Part 2 by jfwong : https://www.shadertoy.com/view/lt33z7\nfrom  Raymarching - Primitives by iq : https://www.shadertoy.com/view/Xds3zN\n*/\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653589793;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\nfloat sdPlane( vec3 p ){\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s ){\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat opU( float d1, float d2 ) {\n\treturn min(d1,d2);\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size * 0.5;\n    float z = size.y / tan(radians(fieldOfView) * 0.5);\n    return normalize(vec3(xy, z));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float res = 1e10;\n    res = opU(res, sdSphere(samplePoint-vec3(1.0,0.5,-1.), 0.5));\n    res = opU(res, sdBox(samplePoint-vec3(-1.0,0.5,1.), vec3(0.5,0.5,0.5)));\n    \n    float size=2.;\n    float thickness=0.01;\n    res = opU(res, sdBox(samplePoint-vec3(0.0,0.0,0.0),vec3(size,thickness,size)));\n    res = opU(res, sdBox(samplePoint-vec3(0.0,2.*size,0.0),vec3(size,thickness,size)));\n    res = opU(res, sdBox(samplePoint-vec3(-size,size,0.0),vec3(thickness,size,size)));\n    res = opU(res, sdBox(samplePoint-vec3(size,size,0.0),vec3(thickness,size,size)));\n    res = opU(res, sdBox(samplePoint-vec3(0.0,size,size),vec3(size,size,thickness)));\n    return res;\n}\n\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\n\n///////////////////////////////////////////////////////////\n// LIGHTS\n///////////////////////////////////////////////////////////\n\nfloat spotLightHard(vec3 view, vec3 axis, float coneAngle) {\n   // spot light without falloff\n    return step(cos(coneAngle),dot(view,axis));\n}\n\nfloat spotLightSmooth(vec3 view, vec3 axis, float coneAngle, float falloff) {\n    //spot light with falloff (a value of 0 is the same as no falloff)\n    return smoothstep(cos(clamp(coneAngle+falloff,0.0,PI)), cos(clamp(coneAngle-falloff,0.0,PI)), dot(view,axis));\n}\n\n////////////////////////////////////////////////////////\n// MAIN\n////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 camPos = vec3(0.,2.,-6.);\n    float camFov = 90.0;\n    Ray ray = Ray(camPos, rayDirection(camFov, iResolution.xy, fragCoord));\n    // compute intersection of camera ray with the scene\n    float dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0,0.0,0.0, 1.0);\n        return;\n    }\n    vec3 hitPoint = ray.origin + dist * ray.direction;\n    vec3 hitPointNormal = estimateNormal(hitPoint);\n    // adds a first point light on the camera so that we can still see things even outside of the second light range\n    vec3 col = vec3(1.0)*dot(hitPointNormal, -ray.direction)/(dist*dist);\n    \n    // set the light properties of the second point light\n    vec3 lightPos = vec3(0.0,3.0,0.0);\n    vec3 lightColor = vec3(abs(cos(iTime)),abs(sin(iTime)),0.5)*3.;\n    \n    // light pointing down, not moving\n    //vec3 lightAxis = vec3(0.0,1.0,0.0); //set to vertical axis\n    //float coneAngle = PI*0.5; //set to hemisphere\n\n\n    // user driven light that follows the mouse click\n    ray = Ray(camPos, rayDirection(camFov, iResolution.xy, iMouse.xy));\n    dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST, MAX_DIST);\n    vec3 mouseHit = ray.origin + dist * ray.direction;\n    vec3 lightAxis = normalize(lightPos-mouseHit);\n    float coneAngle = 0.3*(sin(iTime)+1.)+0.1;\n    \n    // animated light\n    if (length(iMouse.xy) < 20.) {\n        lightAxis = normalize(vec3(cos(iTime),2.,sin(iTime*0.5)));\n        coneAngle = (sin(iTime)+1.)*PI*0.15;\n    }\n   \n    vec3 dirToLight = lightPos-hitPoint;\n    float distToLight = length(dirToLight);\n    dirToLight = dirToLight/distToLight;\n    \n    // compute intersection of light ray with geometry and then the light intensity\n    ray = Ray(lightPos, -dirToLight);\n    dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST, MAX_DIST);\n    if (abs(dist - distToLight) < 0.001) {\n        col += \n        lightColor // the light radiance\n        * spotLightSmooth(dirToLight, lightAxis, coneAngle, 0.05) // this is the intensity distribution\n        // because it is a point light, we need to convert to irradiance\n        * dot(hitPointNormal, dirToLight)/(distToLight*distToLight);\n    }\n    \n    // Output to screen\n    //fragColor = vec4((hitPointNormal+1.)*0.5, 1.);\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"}]}