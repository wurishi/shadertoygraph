{"ver":"0.1","info":{"id":"mlfyDl","date":"1692045836","viewed":55,"name":"Quasar_","username":"Shrey_0703","description":"This is a my version of the shader \"Starfield\" implemented in the tutorial in \"The Art of Code\"\nLink: https://www.youtube.com/watch?v=rvDo9LvfoVE","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["2d","sdf","shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Md33W4","filepath":"https://soundcloud.com/epicsoundtrackmusic/galaxies-by-paul-landry?si=22f009ddf5454813b2fbe10b4ddd98a5&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/epicsoundtrackmusic/galaxies-by-paul-landry?si=22f009ddf5454813b2fbe10b4ddd98a5&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n   This is a my version of the \"Starfield\" shader  implemented in the tutorial in \"The Art of Code\"\n   Link: https://www.youtube.com/watch?v=rvDo9LvfoVE\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n#define NUM_OF_LAYERS 5.0f\n#define PI_OVER_SIX 0.523598f \nmat2 Rot(float angle){\n    float s=sin(angle), c=cos(angle);\n    return mat2(c,-s,s,c);\n}\nfloat Rand(vec2 seed){\n    seed = fract(seed*vec2(123.34f, 456.21f));\n    seed += dot(seed, seed+45.56f);\n    \n    return fract(seed.x*seed.y);\n}\nfloat Rand(float seed){\n    seed = fract(seed*12345.346f);\n    seed += dot(seed, seed+45.5456f);\n    \n    return fract(seed*seed);\n}\nfloat Star(vec2 uv, float flare){\n\n    float dist = length(uv);\n    float radius = 0.025f;\n    \n    float m = radius/dist;\n    m += m*flare;\n    \n    // Adding cross rays\n    float rays = max(0.0, 1.0f - abs(uv.x*uv.y*1000.0f));\n    m += rays*flare;\n    \n    uv *=  Rot(3.1415f/4.0f);\n    \n    // Adding slanted rays\n    float slantedrays = max(0.0, 1.0f - abs(uv.x*uv.y*2000.0f));\n    m += slantedrays*flare;\n    \n    // Adding glowing nebulae\n    float nebula;\n    nebula += Rand(fract(flare*34.567f));\n    m += nebula*flare;\n    \n    m *= smoothstep(1.0f, 0.2f, dist);\n    \n    return m;\n}\nvec3 Starlayer(vec2 uv) {\n    vec3 col = vec3(0.0f);\n    vec2 gv = fract(uv)-0.5f;\n    vec2 id = floor(uv);\n    \n    for(int y=-1; y<=1; y++){\n        for(int x=-1; x<=1; x++){\n        \n            vec2 offs = vec2(x,y);\n            \n            float n = Rand(id+offs);\n            float size = fract(n*345.32f);\n            float star = Star(gv-offs-(vec2(n, fract(n*34.0f))-0.5f), smoothstep(0.9f, 1.0f, size)*0.3f);\n            vec3 c = sin(vec3(0.3f, 0.0f, 1.0f+size)*fract(n*230.54f)*10.2831f)*0.5f+0.5f;\n            \n            col += star*size*c;\n        }\n    }\n    \n    return col;\n}\nfloat Galaxy(vec2 uv, float flare) {\n    float dist = length(uv);\n\n    flare = smoothstep(0.01f,0.1f, flare);\n    vec2 uv1 = uv*Rot(3.1415f+Rand(6.283185f)+Rand(flare));\n    uv1 += Rand(flare*3.1f)+vec2(uv1.x+Rand(flare*0.001f), uv1.y-Rand(flare*0.001f));\n\n    // Adding the galaxies\n    float galaxy;\n    float flareradius = 0.1f*flare;\n    \n    galaxy += smoothstep(flareradius, flareradius+10.0f, max(0.0f, 1.0f-(10.0f*(uv1.x*uv1.x-0.1f)+50.0f*(uv1.y*uv1.y))));\n    galaxy += 3.5f*smoothstep(flareradius-0.01f, flareradius+4.0f, max(0.0f, 1.0f-(10.0f*(uv1.x*uv1.x+0.001f)+999.0f*(uv1.y*uv1.y))));\n    galaxy += 1.1f*min(0.5f,Rand(flare))*smoothstep(0.001f, flareradius+2.0f, max(0.0f, 1.0f-(10.00f*(uv1.x*uv1.x+0.01f)+100.0f*(uv1.y*uv1.y))));\n    \n    galaxy += galaxy*flare*5.0f;\n    \n    galaxy *= smoothstep(1.0f, 0.2f, dist);\n    \n    return galaxy;\n}\nvec3 Galaxylayer(vec2 uv) {\n    vec3 col = vec3(0.0f);\n    vec2 gv = fract(uv)-0.5f;\n    vec2 id = floor(uv);\n    \n    for(int y=-1; y<=1; y++){\n        for(int x=-1; x<=1; x++){\n        \n            vec2 offs = vec2(x,y);\n            \n            float n = Rand(id+offs);\n            float size = fract(n*345.32f);\n            \n            vec2 uv1 = gv-offs-(vec2(n, fract(n*34.0f))-0.5f);\n            uv1 = uv1*Rot(3.1415f+Rand(6.283185f*n)+Rand(n));\n            \n            \n            float galaxy = Galaxy(uv1, smoothstep(0.9f, 1.0f, size)*0.3f);\n            vec3 c = sin(vec3(0.3f, 0.0f, 1.0f+size)*fract(n*230.54f)*10.2831f)*0.5f+0.5f;\n            \n            col += galaxy*size*c;\n        }\n    }\n    \n    return col;\n}\nvec3 Quasar(vec2 uv, float intensity){\n\n    vec3 col;\n    \n    // Creating the outer debree field\n    float d;\n    float flareradius = 0.05f;\n    \n    float dist = 1.0f/length(uv);\n    \n    d += sqrt(0.7f - abs(uv.x*uv.x)+abs(uv.y*uv.y))+0.1f;\n    d += smoothstep(0.001f, 1.0f, sqrt(0.7f - abs(uv.x*uv.x)+abs(uv.y*uv.y))-0.1f);\n    \n    d *= d/smoothstep(flareradius, flareradius+0.01f, dist)*0.28f;\n    d *= d/smoothstep(0.02f, 0.02f+0.01f, dist);\n    \n    d *= 1.0f-smoothstep(1.0f, 2.2f, length(uv));\n    \n    col += max(0.001f, d*0.24f)*vec3(0.99f, 0.85f, 0.5f)*intensity;\n    \n    // Creating the disk\n    float disk;\n    disk += smoothstep(flareradius, flareradius+2.0f, max(0.0f, 1.0f-(1.2f*(uv.x*uv.x+0.1f)+10.0f*(uv.y*uv.y))));\n    disk += smoothstep(flareradius, flareradius+2.0f, max(0.0f, 1.0f-(0.25f*(uv.x*uv.x+0.1f)+22.0f*(uv.y*uv.y))));\n    vec3 diskcol = vec3(0.9f, 0.42f, 0.1f)+disk;\n    \n    col += disk*diskcol;\n    col += disk*diskcol*1.5f*intensity;\n    \n    // Creating the star\n    float m;\n    float starradius = 0.045f;\n    float dist1;\n    dist1 = length(uv);\n    \n    m += starradius/dist1*0.9f;\n    \n    col += 0.001f-m*intensity;\n    \n    // Creating the gamma ray\n    float p,q;\n    p += max(0.0f, smoothstep(0.001f, 0.5f,0.1f - abs(uv.x*0.5f)));\n    \n    col += p*8.0f*intensity;\n    \n    // Creating the gamma ray burst\n    float s;\n    float len = length(uv);\n    len = sin(len*5.0f-iTime*20.0f)/15.0f;\n    \n    float gammarayN, gammarayS;\n    \n    // North ray\n    gammarayN = max(0.0f, smoothstep(0.1f, 3.0f, 1.0f-((uv.x*uv.x*20.0f)-(uv.y-len))-0.7f));\n    \n    // South ray\n    gammarayS = max(0.0f, smoothstep(0.1f, 3.0f, 1.0f-((uv.x*uv.x*20.0f)+(uv.y-len))-0.7f));\n    \n    m += (gammarayN+gammarayS)*intensity;\n    \n    col += m*(gammarayN+gammarayS)*vec3(1.0f,1.0f,1.0f)*((sin(intensity*5.0f+iTime)+sin(1234.0f)+cos(1234.0f)/9999.0f)+0.7f);\n    \n    vec3 c = (vec3(0.1f, 0.01f, 0.0f*intensity)*fract(230.54f)*10.0f)*0.5f+0.5f;\n    \n    col *= c;\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0f - 1.0f;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 uv1 = uv*1.5f;\n    \n    vec3 color = vec3(0.0f);\n    float t = iTime*0.01f;\n    uv1 *= Rot(PI_OVER_SIX);\n    \n    for(float i=0.0f; i<1.0f; i+= 1.0f/NUM_OF_LAYERS) {\n        \n        float depth = fract(i+t);\n        float scale = mix(20.0f, 0.5f, depth);\n        float fade = depth* smoothstep(1.0,0.9,depth);\n        float layerfade = mix(0.001f, 0.01f, i);\n        color += Starlayer(uv*scale+i*453.2f)*fade-layerfade;\n    }\n    color += Galaxylayer(uv*4.f)/5.f;\n    \n    color += Quasar(uv1, 1.0f);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0f);\n}","name":"Image","description":"","type":"image"}]}