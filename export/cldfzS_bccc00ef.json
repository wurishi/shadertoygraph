{"ver":"0.1","info":{"id":"cldfzS","date":"1701361091","viewed":64,"name":"simple terrain shading","username":"rawburt","description":"just some playarrond with noise and stuff..lots to optmize","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec3  campos        = vec3( 0. , .7 , -.8 );\nfloat max_distance  = 50.;\nint   max_steps     = 2500; \nfloat hit_distance  = 0.01;\nvec3  light_pos     = vec3( -10., 60., -10. );\nmat2  rot           = mat2(cos(0.2), sin(0.2),\n                          -sin(0.2), cos(0.2) );\n\nfloat \ndistance_sphere( in vec3 position, in vec3 sphere_position, float sphere_rad) {\n\n    float onion_out = length( ( position ) - sphere_position ) - sphere_rad;\n    \n    return onion_out;\n}\n\nfloat \ndistance_box( in vec3 position, in vec3 box_dims ) {\n\n    vec3 q =  abs( position ) - box_dims;\n    float onion_out = length( max( q, 0.0 ) );\n\n    return onion_out;\n}\n\nfloat \nsmin(float a, float b, float k ) {\n    float h = max( k - abs( a - b ), 0.0 );\n    return min( a, b ) - ( .25 / k )*h*h;\n}\n\n\nfloat rand(vec2 p) {\n    vec2 f = fract(p);\n     return fract(sin(dot(f.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.7;\n    vec2 shift = vec2(45.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                   -sin(0.5), cos(0.5));\n    \n    for (int i = 0; i < 8; ++i) {\n        v += a * noise(_st );\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat\nmap_world(in vec3 p ) {\n\n   vec3 q = p;\n   q.yz = rot * q.yz;\n   float height = q.y > 0.2 ? 0.2 : fbm(.5*q.xz);\n   \n   float sd = (((q.y) - height) + 1.) *.5;\n   \n   return sd;\n\n}\n\nvec3\ncalc_normals( vec3 position ) {\n    vec3 small_step = vec3( 0.0001, 0., 0. );\n\n    float grad_x    = map_world( position + small_step.xyy ) - map_world( position - small_step.xyy );\n    float grad_y    = map_world( position + small_step.yxy ) - map_world( position - small_step.yxy );\n    float grad_z    = map_world( position + small_step.yyx ) - map_world( position - small_step.yyx ); \n\n    return normalize( vec3( grad_x, grad_y, grad_z ) );\n}\n\nfloat cast_ray(vec3 start, vec3 direct, bool shadow) {\n    float total_distance = 0.;\n\n    vec3  new_pos        = vec3(0., 0., 0.);\n\n    for(int i = 0; i < max_steps; i++) {\n\n        vec3  new_pos     = start + total_distance * direct;\n        float distance    = map_world( new_pos );\n\n        if( distance < hit_distance ) {\n            return total_distance;\n        }\n        if( total_distance > max_distance ) {\n            return -1.;\n        }\n        total_distance += .005;\n    }\n    float retval = shadow ? total_distance : -1.;\n    return retval;\n}\n\nvec3 ray_march(vec3 dir) {\n    float  t = cast_ray(campos, dir, false);\n    vec3 col = vec3( .2, .5, .9) - .8 * dir.y;\n         col = mix( col, vec3( .9, .95, .9 ), exp( -8. * dir.y) );\n\n    if( t >= 0. ) {\n        vec3  new_pos    = campos +  t * dir;\n   \n           new_pos.yz = rot * new_pos.yz;\n\n        vec3  normal     =  calc_normals( new_pos );\n\n        vec3 light_dir  = normalize( light_pos - new_pos );\n\n        float intensity = clamp( dot( light_dir, normal ), .0, 1.);\n\n        vec3 refl       = reflect( -normalize(( campos - new_pos )), normal );\n        \n        float spec      = pow(max(dot(light_dir, refl ), 0. ), 16. );\n        \n        float sky       = clamp( .5 + .5 * dot(normal, vec3(0., 1., 0.) ), 0., 1.);\n\n        float shad      = step( cast_ray( new_pos + .01 * normal, light_dir , true ), 0.0 );\n\n        vec3 start = vec3( .1, .2, .8);\n        vec3 end   = vec3( .1, .3, .7);\n\n        vec3 col = vec3(.2, .3,  .5) * .3 * abs(1./(2.*new_pos.y + .5)) * .4*(.5 + .5 * sin(iTime)*vec3(1.,1.0,0.)*normal );\n        col += .01 * abs( new_pos.z * new_pos.y  ) * vec3(.1, .1, .1);\n\n        return col * shad * ( intensity + spec ) + vec3(.0, .1, .3 ) * sky;\n        \n  \n    }\n\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec3 cam_dir = vec3(.0, 0., .1 );\n    cam_dir.yz   = inverse(rot) * cam_dir.yz;\n    campos += cam_dir * 10.*iTime;\n    \n    vec3  dir           = normalize( vec3( p, 1.5 ) );\n    // Output to screen\n    fragColor   = vec4(ray_march(dir) ,1.0);\n    \n    \n    //fragColor = smoothstep(fragColor, intcol, vec4(1./dir, 1.));\n     \n}","name":"Image","description":"","type":"image"}]}