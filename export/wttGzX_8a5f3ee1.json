{"ver":"0.1","info":{"id":"wttGzX","date":"1577124355","viewed":122,"name":"DeJong","username":"hectorD","description":"How does a 2D representation of the sensitivity to initial conditions of the Peter De Jong map vary along a path through the 4D parameter space?","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","math","chaos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 deJong(vec2 pt, vec4 params) {\n    return vec2(\n        sin(pt.y * params.x) - sin(pt.x * params.y),\n        sin(pt.x * params.z) - sin(pt.y * params.w));\n}\n\nvec2 normalise(vec2 pt) {\n    return (pt / iResolution.xy - vec2(0.5, 0.5)) * 2.0;\n}\n\n#define TWO_PI 6.283185307179586\n#define TWO_PI_BY_THREE 2.0943951023931953\n\nfloat peturb_around(vec2 pt, vec2 peturb_vector, vec4 params) {\n    vec2 peturb = pt + peturb_vector;\n    float diff = 0.0;\n    \n    for (int i=0; i<5; i++) {\n        pt = deJong(pt, params);\n        peturb = deJong(peturb, params);\n        diff += length(pt - peturb);\n    }\n    return diff;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = normalise(fragCoord);\n    float complexity = 3.3;\n    \n    // A random 4x4 orthogonal matrix.\n    mat4 R = mat4(\n        -0.53558962,  0.71863663,  0.31432821, -0.31289444,\n         0.75893198,  0.20212791,  0.28305564, -0.55049619,\n        -0.20643669, -0.5377592 ,  0.81500374, -0.06299071,\n        -0.30748967, -0.39181723, -0.39603811, -0.77141635\n         );\n    \n    mat4 R_t = mat4(\n        -0.5355896235456705,   0.7589319802843446,  -0.2064366917119645,  -0.3074896693661576, \n         0.7186366264902774,   0.20212791358190718, -0.5377592037106321,  -0.39181723346760217, \n         0.3143282083763952,   0.2830556397465259,   0.8150037431580668,  -0.3960381053193117, \n        -0.31289444168243946, -0.5504961949554176,  -0.06299071183806501, -0.7714163453842388\n        );\n    \n    vec4 params = complexity*vec4(sin(iTime/2.0), -cos(iTime/2.0), sin(iTime/3.0), -cos(iTime/3.0));\n    params = R_t*params;\n    \n    float theta = 0.0;\n\tconst float samples = 4.0;\n    float[int(samples)] diffs;\n    float max_diff = -1.0;\n    vec2 centre_of_mass = vec2(0.0);\n    \n    for (float i=0.0; i < samples; i++) {\n        theta = TWO_PI * i / samples;\n        vec2 peturb_vector = vec2(0.01*sin(theta), 0.01*cos(theta));\n        \n        float diff = peturb_around(pos, peturb_vector, params);\n        \n        diffs[int(i)] = diff;\n        \n        if (diff > max_diff) {\n            max_diff = diff;\n        }\n        \n        centre_of_mass += diff*vec2(sin(theta), cos(theta));\n    }\n    \n    // A random 3x3 orthogonal matrix.\n    mat3 rot3 = mat3(\n        -0.45811713672452714, 0.10981361927735007, -0.8820825687318222, \n        0.3945090460723311, -0.8641323656778489, -0.31247058606387884, \n        -0.7965496228148125, -0.49113768294564186, 0.35255137892847077\n     );\n    \n    mat3 rot3_t = mat3(\n        -0.45811713672452714, 0.3945090460723311, -0.7965496228148125, \n        0.10981361927735007, -0.8641323656778489, -0.49113768294564186, \n        -0.8820825687318222, -0.31247058606387884, 0.35255137892847077\n     );\n\t\n    float val = log(max_diff+1.0);\n        \n    vec3 col = vec3(val*centre_of_mass.x*sin(iTime), val*centre_of_mass.y*cos(iTime), 0.5*length(centre_of_mass));\n    \n    fragColor = vec4(rot3*col*rot3_t, 1.0);\n}","name":"Image","description":"","type":"image"}]}