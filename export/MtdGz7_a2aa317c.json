{"ver":"0.1","info":{"id":"MtdGz7","date":"1468525725","viewed":193,"name":"dueling clods vs the empire","username":"bpt","description":"well not sure what to say...this is pretty absurd and makes me laugh so maybe you will enjoy it too. \n","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["remix","workinprogress","clods","empire","absurdism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float th = 8.0; // threshold\nfloat a2 = 1.2;\nfloat spill = 1.0;\n\nfloat getAlpha(vec4 c){\n\t// First Vlahos assumption: Gf <= a2Bf\t\n\treturn 1.0 - th*(c.g-a2*(max(c.r,c.b)));\n\t}\n\nvec4 despill(vec4 c){\n\t/// Second Vlahos assumption: max (Gf - Bf,0) <= max(Bf - Rf, 0)\n\tfloat sub = max(c.g - mix(c.b, c.r, 0.45), 0.0);\n\tc.g -= sub;\n\t\n\t/// \n\tc.a -= smoothstep(0.25, 0.5, sub*c.a);\n\t\n\t//restore luminance (kind of, I slightly reduced the green weight)\n\tfloat luma = dot(c.rgb, vec3(0.350, 0.587,0.164));\n\tc.r += sub*c.r*2.0*.350/luma;\n\tc.g += sub*c.g*2.0*.587/luma;\n\tc.b += sub*c.b*2.0*.164/luma;\n\n\treturn c;\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv0 = fragCoord.xy / iResolution.xy; // * vec2(1.0,0.7) * vec2(1.5,1.5);\n    \n    uv0.x = 0.9-abs(uv0.x-0.5);\n    \n\tvec2 uv1 = vec2(0,1) + vec2(1,-1) * fragCoord.xy / iResolution.xy;\n\t   \n\tvec4 fg = texture(iChannel0,uv0);\n\tvec4 bg = texture(iChannel1,uv1);\n    \n    if (uv0.x > 1.0 || uv0.y > 1.0)\n    {\n        fg = vec4(0.01,1,0.01,0);\n    }   \n    \n\tvec4 ofg = fg;\n\t\n\tfg.a = clamp(getAlpha(fg), 0.0, 1.0)*(step(bg.a,0.25)*step(bg.a,0.5));\n\tfg = despill(fg);\n\t\n\tfragColor.rgb = ofg.rgb;\n\tfragColor.rgb = bg.rgb*(1.0-fg.a) + fg.rgb*fg.a;\n    \n    //if ( iMouse.xy == iMouse.zw ) { fragColor.rgb = vec3( bg.a ); }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Fancy ties by nimitz (twitter: @stormoid)\n\n/*\n\tSomewhat complex modelling in a fully procedural shader that runs decently fast.\n\tI kinda cheated on the wings, the real ones are less hexagonal than this.\n\tNot doing proper occlusion checking for the lens flares to keep it fast.\n*/\n\n#define ITR 100\n#define FAR 155.\n#define time iTime\n\nconst float fov = 1.5;\n\n//Global material id (keeps code cleaner)\nfloat matid = 0.;\n\n//--------------------Utility, Domain folding and Primitives---------------------\nfloat tri(in float x){return abs(fract(x)-.5);}\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n//From Dave_Hoskins\nvec2 hash22(vec2 p){\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec3 hash33(vec3 p){\n\tp  = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.yzx, p.xyz  + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));\n}\n\n\n//2dFoldings, inspired by Gaz/Knighty  see: https://www.shadertoy.com/view/4tX3DS\nvec2 foldHex(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.5, 0.8657);\n    const vec2 pl2 = vec2(-0.8657, 0.5);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    return p;\n}\n\nvec2 foldOct(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.7071, 0.7071);\n    const vec2 pl2 = vec2(-0.9237, 0.3827);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    \n    return p;\n}\n\nfloat sbox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cyl( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t ){\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//using floor() in a SDF causes degeneracy.\nfloat smoothfloor(in float x, in float k)\n{\n    float xk = x+k*0.5;\n    return floor(xk-1.) + smoothstep(0.,k,fract(xk));\n}\n\nfloat hexprism(vec3 p, vec2 h){\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.y*0.866025+q.x*0.5),q.x)-h.x);\n}\n\n//------------------------------------------------------------------------\n\nvec3 position(in vec3 p)\n{\n    float dst =7.;\n    float id = floor(p.z/dst*.1);\n    p.xy += sin(id*10.+time);\n    p.z += sin(id*10.+time*0.9)*.5;\n    p = rotz(p,sin(time*0.5)*0.5+id*0.1);\n    p.z = (abs(p.z)-dst)*sign(p.z);\n    return p;\n}\n\nfloat map(vec3 p)\n{\n    matid= 0.;\n\tvec3 bp =p; //keep original coords around\n   \n    float mn = length(bp)-.7; //main ball\n    \n    //Cockpit\n    p.z -=0.8;\n    vec3 q = p;\n    q.xy *= mat2(0.9239, 0.3827, -0.3827, 0.9239); //pi/8\n    q.xy = foldOct(q.xy);\n    p.z += length(p.xy)*.46;\n    p.xy = foldOct(p.xy);\n    float g = sbox(p-vec3(0.32,0.2,0.),vec3(.3,0.3,0.04)); //Cockpit Spokes\n   \tfloat mg = min(mn,g);\n    if (mn < -g)matid = 2.;\n    mn = max(mn,-g);\n    float g2 = sbox(q,vec3(.45,0.15,.17)); //Cockpit center\n    if (mn < -g2)matid = 2.;\n    mn = max(mn,-g2);\n    mn = min(mn,torus(bp.yzx+vec3(0,-.545,0),vec2(0.4,0.035))); //Cockpit lip\n    mn = max(mn,-torus(bp+vec3(0,-.585,0),vec2(0.41,0.03))); //Hatch\n    \n    //Engine (Polar coords)\n    mn = max(mn,-(bp.z+0.6));\n    vec3 pl = bp.xzy;\n    pl = vec3(length(pl.xz)-0.33, pl.y, atan(pl.z,pl.x));\n    pl.y += .55;\n    mn =  min(mn,sbox(pl, vec3(.29+bp.z*0.35,.25,4.)));\n    pl.z = fract(pl.z*1.7)-0.5;\n    mn = min(mn, sbox(pl + vec3(0.03,0.09,0.), vec3(0.05, .1, .2)));\n    \n    p = bp;\n    p.x = abs(p.x)-1.1; //Main symmetry\n    \n    mn = min(mn, cyl(p.xzy-vec3(-0.87,.43,-0.48),vec2(.038,0.1))); //Gunports\n    \n    const float wd = 0.61; //Main width\n    const float wg = 1.25; //Wign size\n    \n    mn = min(mn, cyl(p.yxz,vec2(0.22+smoothfloor((abs(p.x+0.12)-0.15)*4.,0.1)*0.04,0.6))); //Main structure\n    vec3 pp = p;\n    pp.y *= 0.95;\n    vec3 r = p;\n    p.y *= 0.65;\n    p.z= abs(p.z);\n    p.z -= 0.16;\n    q = p;\n    r.y = abs(r.y)-.5;\n    mn = min(mn, sbox(r-vec3(-.3,-0.37,0.),vec3(0.35,.12-smoothfloor(r.x*2.-.4,0.1)*0.1*(-r.x*1.7),0.015-r.x*0.15))); //Side Structure\n    mn = min(mn, sbox(r-vec3(-.0,-0.5,0.),vec3(0.6, .038, 0.18+r.x*.5))); //Side Structure\n    p.zy = foldHex(p.zy)-0.5;\n    pp.zy = foldHex(pp.zy)-0.5;\n    mn = min(mn, sbox(p-vec3(wd,wg,0),vec3(0.05,.01,.6))); //wing Outer edge\n    q.yz = foldHex(q.yz)-0.5;\n    \n    \n    mn = min(mn, sbox(q-vec3(wd,-0.495-abs(q.x-wd)*.07,0.),vec3(0.16-q.z*0.07,.015-q.z*0.005,wg+.27))); //wing spokes\n    mn = min(mn, sbox(q-vec3(wd,-0.5,0.),vec3(0.12-q.z*0.05,.04,wg+.26))); //Spoke supports\n    \n    mn = min(mn, sbox(pp-vec3(wd,-0.35,0.),vec3(0.12,.35,.5))); //Wing centers\n    mn = min(mn, sbox(pp-vec3(wd,-0.35,0.),vec3(0.15+tri(pp.y*pp.z*30.*tri(pp.y*2.5))*0.06,.25,.485))); //Wing centers\n    \n    float wgn = sbox(p-vec3(wd,0,0),vec3(0.04,wg,1.));//Actual wings (different material)\n    if (mn > wgn)matid = 1.;\n    mn = min(mn, wgn);\n    \n    //Engine port\n    float ep = hexprism(bp+vec3(0,0,0.6),vec2(.15,0.02));\n    if (mn > ep)matid = 2.;\n    mn = min(mn, ep);\n\n    \n    return mn;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n        float res = map(position(ro+rd*d))*0.93;\n        h = res;\n    }\n\treturn d;\n}\n\n//greeble-ish texture\nfloat tex(in vec3 q)\n{\n    q.zy = foldOct(q.zy);\n    vec2 p = q.zx;\n    float id = floor(p.x)+100.*floor(p.y);\n    float rz= 1.0;\n    for(int i = 0;i<3;i++)\n    {\n        vec2 h = (hash22(floor(p))-0.5)*.95;\n        vec2 q = fract(p)-0.5;\n        q += h;\n        float d = max(abs(q.x),abs(q.y))+0.1;\n        p += 0.5;\n        rz += min(rz,smoothstep(0.5,.55,d))*1.;\n        p*=1.4;\n    }\n    rz /= 7.;\n    return rz;\n}\n\nvec3 wingtex(in vec2 p, in float ds, in float ind)\n{\n    p.y *= 0.65;\n    p.x = abs(p.x)-0.14;\n    p = foldHex(p);\n    \n    //Fighting aliasing with distance and incidence.\n    float rz = smoothstep(0.07,.0,tri(p.x*7.5))*15.*(ind)/(ds*ds);\n    return vec3(1,.9,.8)*rz*0.7;\n}\n\nfloat mapHD(in vec3 p)\n{\n    float d= map(p);\n    d += tex(p*3.+vec3(4.,0.,0.))*0.03/(length(p)*.3+.9);\n    return d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.008;\n\treturn normalize(e.yxx*mapHD(p + e.yxx) + e.xxy*mapHD(p + e.xxy) + \n\t\t\t\t\t e.xyx*mapHD(p + e.xyx) + e.yyy*mapHD(p + e.yyy) );   \n}\n\n//form iq\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.13*float(i)/3.;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1. - 3.5*occ, 0.0, 1.0 );    \n}\n\n//smooth and cheap 3d starfield\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*.85*fov;\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        float rn = hash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    return c*c*1.5;\n}\n\nvec3 flare(in vec2 p, in vec2 pos, in vec3 lcol, in float sz)\n{\n\tvec2 q = p-pos;\n    q *= sz;\n\tfloat a = atan(q.x,q.y);\n    float r = length(q);\n    \n    float rz= 0.;\n    rz += .07/(length((q)*vec2(7.,200.))); //horiz streaks\n    rz += 0.3*(pow(abs(fract(a*.97+.52)-0.5),3.)*(sin(a*30.)*0.15+0.85)*exp2((-r*5.))); //Spokes\n\t\n    vec3 col = vec3(rz)*lcol;   \n    col += exp2((1.-length(q))*50.-50.)*lcol*vec3(3.);\n    col += exp2((1.-length(q))*20.-20.)*lcol*vec3(1,0.95,0.8)*0.5;    \n    return clamp(col,0.,1.);\n}\n\nmat3 htranspose(in mat3 m)\n{\n    return mat3(m[0][0], m[1][0], m[2][0],\n                m[0][1], m[1][1], m[2][1],\n                m[0][2], m[1][2], m[2][2]);\n}\n\n//A weird looking small moon\nfloat slength(in vec2 p){ return max(abs(p.x), abs(p.y)); }\nfloat moontex(in vec3 p)\n{\n    float r = length(p);\n    vec3 q = vec3(r, acos(p.y/r), atan(p.z,p.x));\n    q *= 6.5;\n    vec3 bq = q;\n    q.y = q.y*0.44-0.42;\n    vec2 id = floor(q.zy);\n    vec2 s = fract(q.zy)-0.5;\n    \n    float rz = 1.;\n    float z = 0.25;\n    for(int i=0;i<=3;i++)\n    {\n        vec2 rn = hash22(id+vec2(i)+0.0019)*.6 + 0.4;\n        s -= abs(s)-rn*0.45;\n        rz -= smoothstep(0.5,0.45-float(i)*0.1,slength(s*rn*1.3))*z;\n        q *= 3.5;\n        z *= .85;\n        id = floor(q.zy);\n    \ts = fract(q.zy)-0.5;\n    }\n    \n    rz -= smoothstep(0.035,.03,abs(bq.y-10.15))*.3; //main trench\n    return rz;\n}\n\nfloat sphr(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h < 0.) return -1.;\n\telse return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.15,0.):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo*=4.;\n\tmo.x += time*0.17+0.1;\n\n    vec3 ro = vec3(0.,0.,17.);\n    vec3 rd = normalize(vec3(vec2(-p.x,p.y),-fov));\n    float cms = 1.-step(sin((time+0.0001)*0.5),0.);\n    mat3 inv_cam = mat3(0);\n    \n    if (cms < 0.5)\n    {\n        mat3 cam = rot_x(-mo.y)*rot_y(-mo.x);\n        inv_cam = rot_y(-mo.x)*rot_x(mo.y); \n        ro *= cam;rd *= cam;\n    }\n    else\n    {\n        float frct = fract(time*0.15915);\n        float frct2 = fract(time*0.15915+0.50001);\n        float cms = 1.-step(sin((time+0.0001)*0.5),0.);\n        ro = vec3(-15.,1.-(step(frct2,0.5))*frct2*40.,140.-frct*280.);\n        vec3 ta = vec3(0);\n        vec3 fwd = normalize(ta - ro);\n        vec3 rgt = normalize(cross(vec3(0., 1., 0.), fwd ));\n        vec3 up = normalize(cross(fwd, rgt));\n        mat3 cam = mat3(rgt,up,-fwd);\n        rd = normalize(vec3(vec2(p.x,p.y),-fov))*cam;\n        inv_cam = transpose(cam);\n    }\n    \n\tfloat rz = march(ro,rd);\n\t\n    vec3 lgt = normalize( vec3(.2, 0.35, 0.7) );\n    vec3 col = vec3(0.0);\n    float sdt = max(dot(rd,lgt),0.); \n    \n    vec3 lcol = vec3(1,.85,0.73);\n    col += stars(rd);\n    \n    vec3 fp = (-lgt*inv_cam);\n    col += clamp(flare(p,-fp.xy/fp.z*fov, lcol,1.)*fp.z*1.1,0.,1.);\n    \n    //Another nearby star\n    vec3 lcol2 = vec3(0.25,.38,1);\n    vec3 lgt2 = normalize(vec3(-0.2,-.1,-0.8));\n    fp = (-lgt2*inv_cam);\n    col += clamp(flare(p,-fp.xy/fp.z*fov, lcol2,2.)*fp.z*1.1,0.,1.);\n    \n    //A \"moon\"\n    vec4 sph = vec4(2000,500,-700,1000);\n    float mn = sphr(ro,rd,sph);\n    \n    if (mn > 0.)\n    {\n        vec3 pos = ro+rd*mn;\n        vec3 nor = normalize(pos-sph.xyz);\n        vec3 dif = clamp(dot( nor, lgt ), 0., 1.)*0.985*lcol;\n        vec3 bac = clamp( dot( nor, lgt2), 0.0, 1.0 )*lcol2;\n        col = moontex((pos-sph.xyz))*vec3(0.52,0.54,0.7)*0.3;\n        col *= dif + bac*0.01 + 0.005;\n    }\n    \n    float alp = 0.0;\n    if ( rz < FAR )\n    {\n        float mat = matid;\n        vec3 pos = ro+rz*rd;\n        pos = position(pos);\n        vec3 nor= normal(pos);\n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, lgt2), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),7.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 3.0 );\n        vec3 brdf = vec3(0.);\n        brdf += bac*mix(lcol2,vec3(1),0.5)*0.06;\n        brdf += 1.5*dif*lcol;\n        col = vec3(0.54,0.56,0.65)*1.1;\n        col *= col;\n        if (mat == 1.) \n        {\n            brdf *= 0.0;\n            spe *= 0.05;\n            fre *= 0.05;\n            brdf += wingtex(pos.zy,rz, max(dot(-rd,nor),0.)*0.5+0.5)*0.6;\n        }\n        else if (mat == 2.)\n        {\n            col = vec3(0);\n            spe *= 0.1;\n        }\n        \n        col = col*brdf + spe*.23 +.03*fre;\n        col *= getAO(pos,nor);\n        alp = 1.-pos.x*step(0.0,abs(pos.z));\n    }\n    \n    col = clamp(col, 0.,1.);\n    col = pow(clamp(col,0.,1.), vec3(0.416667))*1.055 - 0.055; //sRGB\n\t\n\tfragColor = vec4( col, alp );\n}","name":"Buf A","description":"","type":"buffer"}]}