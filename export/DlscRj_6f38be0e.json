{"ver":"0.1","info":{"id":"DlscRj","date":"1691024721","viewed":196,"name":"Realistic Path Tracer Depth","username":"Depth","description":"Simulates the way light travels through a 3d scene","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","tracer","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//if you go into fullscreen make sure to press R to reset buffer b\n\n//Changeable Options\n#define Bounces 2000\n#define FOV 300\n#define Fog 0.005\n#define Scene 0\n#define UseExtraRays 0 //Causes Lag When Not Moving In Turn For Faster Results\n\n//Do NOT Change These!\n#define Epsilon -.0001\n#define KeyLeft 65\n#define KeyRight 68\n#define KeyUp 87\n#define KeyDown 83\n#define KeyE 69\n#define KeyQ 81\n#define KeyR 82\n\n//Basic Object Construction\nstruct Camera{\n    vec3 xyz;\n    vec2 angles;\n};\n\nstruct Object{\n    int type;\n    vec3 xyz;\n    vec3 size;\n    vec3 rgb;\n    float es;\n    float rg;\n    float repb;\n};\n\nstruct Ray{\n    vec3 xyz;\n    vec3 dir;\n};\n\n//Initialize Global Variables\nvec2 uv;\nint RPP;\nint Seed;\nfloat iter;\nvec3 oldC;\nint FogInt = int(100./(pow(Fog*10000.,2.)/100000000.));\nCamera Cam;\nObject Objects[10];\n\nvoid InitailizeScene(){\n    //0=Nothing 1=Sphere 2=Box\n    if(Scene==0){\n        Objects[0] = Object(1,vec3(-8000,16000,8000),vec3(400,0,0),vec3(1,.5,.5), 8000.0,1.0,0.0);\n        Objects[1] = Object(1,vec3(0,0,100),vec3(100,0,0),vec3(1,1,1), 0.0,0.1,0.1);\n        Objects[2] = Object(1,vec3(-200,-50,100),vec3(50,0,0),vec3(1,0,1), 0.0,1.0,0.1);\n        Objects[3] = Object(1,vec3(200,-50,100),vec3(50,0,0),vec3(0,1,0), 0.0,1.0,0.1);\n        Objects[4] = Object(2,vec3(0,-125,100),vec3(1000,50,1000),vec3(.75,.75,.4), 0.0,1.0,0.1);\n        Objects[5] = Object(2,vec3(0,-75,-100),vec3(50,50,50),vec3(0,0,1),0.0,0.5,0.1);\n    } else{\n        //Objects[0] = Object(1,vec3(-8000,16000,8000),vec3(400,0,0),vec3(1,.5,.5), 8000.0,1.0,0.0);\n        Objects[1] = Object(1,vec3(-500,0,350),vec3(100,0,0),vec3(1,1,1), 10.0,1.0,0.0);\n        Objects[2] = Object(2,vec3(-100,0,-100),vec3(10,200,500),vec3(1,.8,.5), 0.0,1.0,0.0);\n        Objects[3] = Object(2,vec3(100,0,0),vec3(10,200,700),vec3(1,.8,.5), 0.0,1.0,0.0);\n        Objects[4] = Object(2,vec3(0,-105,0),vec3(200,10,700),vec3(.5,.5,.5), 0.0,1.0,0.0);\n        Objects[5] = Object(2,vec3(0,0,-345),vec3(200,200,10),vec3(1,.8,.5),0.0,1.0,0.0);\n        Objects[6] = Object(2,vec3(0,0,255),vec3(200,200,10),vec3(1,.8,.5),0.0,1.0,0.0);\n        Objects[7] = Object(2,vec3(0,105,0),vec3(200,10,700),vec3(.5,.5,.5), 0.0,1.0,0.0);\n    }\n}\n\n//code\nfloat GetRand(in float mi, in float ma){\n    Seed = Seed * 747796405 + 2891336453;\n    int result = ((Seed >> ((Seed >> 28) + 4)) ^ Seed) * 277803737;\n    result = (result >> 22) ^ result;\n    return (mod(float(result)/149729.4323, (ma-mi)) + mi);\n}\n\nvec3 GetRandVec(){\n    return normalize(vec3(GetRand(-1.,1.), GetRand(-1.,1.), GetRand(-1.,1.)));\n}\n\nvoid Swap(inout float v1, inout float v2){\n    float t = v1;\n    v1 = v2;\n    v2 = t;\n}\n\nvec3 GetNormal(in Ray ray, in int ID){\n    Object Obj = Objects[ID];\n    if(Obj.type == 1){\n        return normalize(ray.xyz-Obj.xyz);\n    } else{\n        vec3 n = ray.xyz-Obj.xyz;\n        n /= Obj.size/2.;\n        if(abs(n.x)>=max(abs(n.y),abs(n.z))) return vec3(n.x/abs(n.x),0,0);\n        if(abs(n.y)>=max(abs(n.x),abs(n.z))) return vec3(0,n.y/abs(n.y),0);\n        if(abs(n.z)>=max(abs(n.y),abs(n.x))) return vec3(0,0,n.z/abs(n.z));\n    }\n}\n\nvec3 GetReflectDir(in Ray ray, in int ID){\n    vec3 Normal = GetNormal(ray, ID);\n    return ray.dir-(2.*Normal*dot(ray.dir,Normal));\n}\n\nvoid Bounce(inout Ray ray, in int ID){\n    vec3 Normal = GetNormal(ray, ID);\n    vec3 new = (GetRandVec()*Objects[ID].rg)+(reflect(ray.dir, Normal)*(1.-Objects[ID].rg));\n    if(dot(new, Normal)<0.){\n        new *= -.1;\n    }\n    ray.dir = new;\n}\n\nfloat GetObjIntersection(in Ray ray, in int ID){\n    Object Obj = Objects[ID];\n    if(Obj.type == 1){\n        vec3 L = Obj.xyz-ray.xyz;\n        float d = dot(L,ray.dir);\n        if(d<0.) return -1.;\n        float L2 = dot(L,L)-(d*d);\n        if(L2>(Obj.size.x*Obj.size.x)) return -1.;\n        float ta = sqrt((Obj.size.x*Obj.size.x)-L2);\n        float t0 = d-ta;\n        float t1 = d+ta;\n        if(t1<t0) Swap(t0,t1);\n        if(t0<0.) return t1;\n        return t0;\n    } else{\n        vec3 t0 = ((Obj.xyz-(Obj.size/2.))-ray.xyz)/ray.dir;\n        vec3 t1 = ((Obj.xyz+(Obj.size/2.))-ray.xyz)/ray.dir;\n        if(t1.x<t0.x) Swap(t0.x, t1.x);\n        if(t1.y<t0.y) Swap(t0.y, t1.y);\n        if(t1.z<t0.z) Swap(t0.z, t1.z);\n        if(t0.x>t1.y || t0.y>t1.x) return -1.;\n        float mi = (t0.y>t0.x) ? t0.y:t0.x;\n        float ma = (t1.y<t1.x) ? t1.y:t1.x;\n        if(mi>t1.z || t0.z>ma) return -1.;\n        mi = (mi>t0.z) ? mi:t0.z;\n        ma = (ma<t1.z) ? ma:t1.z;\n        if(mi<0.) return ma+(Epsilon*10.);\n        return mi;\n    }\n}\n\nfloat GetIntersection(in Ray ray, inout int resultID, in int LightID){\n    float resT = 9999999999.;\n    resultID = -1;\n    Object LightObj;\n    if(LightID != -1){\n        resT = GetObjIntersection(ray, LightID);\n        LightObj = Objects[LightID];\n    }\n    for(int i=0; i<Objects.length(); i++){\n        if(Objects[i]!=LightObj){\n            float t = GetObjIntersection(ray, i);\n            if(t<resT && t>Epsilon){\n                resT = t;\n                resultID = i;\n            }\n        }\n    }\n    float randFog = GetRand(0.,float(FogInt));\n    if(randFog<resT && Fog!=0.){\n        resT = randFog;\n        resultID = -1;\n    }\n    return resT;\n}\n\nvec3 GetLight(in Ray ray, in int resultID){\n    vec3 Light;\n    Ray sRay = ray;\n    for(int i=0; i<Objects.length(); i++){\n        Object Obj = Objects[i];\n        if(Obj.es>0.){\n            vec3 Rand;\n            if(resultID != -2){\n                if(Obj.type == 1){\n                    Rand = Obj.xyz+(Obj.size.x*GetRandVec());\n                } else{\n                    Rand = Obj.xyz+((Obj.size/2.)*GetRandVec());\n                }\n                sRay.dir = normalize(Rand-sRay.xyz);\n            }\n            int resID;\n            GetIntersection(sRay, resID, i);\n            if(resID == -1){\n                float F = 10./pow(length(Rand-sRay.xyz)/50.,2.);\n                F = min(F, 1.);\n                if(resultID!=-1){\n                    F *= dot(sRay.dir,GetNormal(sRay,resultID));\n                    F *= Objects[resultID].rg;\n                }\n                F = max(F, 0.);\n                Light += Obj.rgb*Obj.es*F;\n            }\n        }\n    }\n    return Light;\n}\n\nvec3 Pathtrace(){\n    vec3 Color = vec3(1,1,1);\n    vec3 Light;\n    vec3 tdir = vec3(0,(uv.y*cos(Cam.angles.y))+(float(FOV)*sin(Cam.angles.y)),(float(FOV)*cos(Cam.angles.y))-(uv.y*sin(Cam.angles.y)));\n    tdir = vec3((uv.x*cos(Cam.angles.x))+(tdir.z*sin(Cam.angles.x)), tdir.y, (tdir.z*cos(Cam.angles.x))-(uv.x*sin(Cam.angles.x)));\n    tdir.xy += vec2(GetRand(-.5,.5),GetRand(-.5,.5));\n    Ray ray = Ray(Cam.xyz, normalize(tdir));\n    float direct = 1.;\n    for(int b=0; b<Bounces; b++){\n        int resultID;\n        Object resObj;\n        float t = GetIntersection(ray, resultID, -1);\n        if(resultID!=-1){\n            if(GetRand(0.,1.)<Objects[resultID].repb) Objects[resultID].rg = 0.;\n            resObj = Objects[resultID];\n            Color *= (resObj.rgb*resObj.rg) + (1.-resObj.rg);\n            Light += Color*resObj.es*direct;\n            if(length(Color)<.05) return Light;\n        }\n        ray.xyz = ray.xyz + (ray.dir*t);\n        Light += Color*GetLight(ray, resultID);\n        if(resultID == -1) return Light;\n        Bounce(ray, resultID);\n        direct *= 1.-resObj.rg;\n    }\n    return Light;\n}\n\nvoid GetData(){\n    iter = (texture(iChannel1, vec2(.35,.05)).x*1000.)+1.;\n    Cam.angles = texture(iChannel1, vec2(.25,.05)).xy;\n    Cam.xyz = vec3(0,0,-FOV)+texture(iChannel1, vec2(.15,.05)).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    uv = (fragCoord/iResolution.xy)-vec2(.5,.5);\n    uv = vec2(uv.x*480., uv.y*(480.*(iResolution.y/iResolution.x)));\n    Seed = int(mod(((mod(iTime, 5.34)+(mod(iTime, 5.34)*35432432.))*7893112.)+iTime,2.324)+(((uv.x*30.)+mod(uv.y*4232432., mod(iTime+2.32,5.)*443200.34))));\n    \n    GetData();\n    //if(iter>10000.){\n        //uv = fragCoord/iResolution.xy;\n        //fragColor=vec4(texture(iChannel0, uv).xyz,(iter-1.)/1000.);\n        //return;\n    //}\n    RPP = (UseExtraRays==1) ? int((1./(iTimeDelta))*float(iter>30.))+1:1;\n    vec3 Color;\n    for(int i=0; i<RPP; i++){\n        InitailizeScene();\n        Color += Pathtrace();\n    }\n    uv = fragCoord/iResolution.xy;\n    oldC = texture(iChannel0, uv).xyz;\n    Color /= float(RPP); \n    Color = (Color*(1./iter)) + (oldC*(1.-(1./iter)));\n    fragColor = vec4(Color,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define KeyLeft 65\n#define KeyRight 68\n#define KeyUp 87\n#define KeyDown 83\n#define KeyE 69\n#define KeyQ 81\n#define KeyR 82\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //(0,0)=mouse, (1,0)=campos, (2,0)=camangle, (3,0)=iter\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(floor(uv*10.)==vec2(0,0)){\n        fragColor = vec4(iMouse.xy/iResolution.xy,1.0,1.0);\n    }\n    \n    if(floor(uv*10.)==vec2(1,0)){\n        vec2 CamAngle = texture(iChannel0, vec2(.25,.05)).xy;\n        vec3 CamOffset = texture(iChannel0, uv).xyz;\n        if(texelFetch(iChannel1, ivec2(KeyLeft,0),0).x==1.){\n            CamOffset.x += 4.*-cos(CamAngle.x);\n            CamOffset.z += 4.*sin(CamAngle.x);\n        }\n        if(texelFetch(iChannel1, ivec2(KeyRight,0),0).x==1.){\n            CamOffset.x += 4.*cos(CamAngle.x);\n            CamOffset.z += 4.*-sin(CamAngle.x);\n        }\n        if(texelFetch(iChannel1, ivec2(KeyUp,0),0).x==1.){\n            CamOffset.x += 4.*-sin(-CamAngle.x);\n            CamOffset.z += 4.*cos(-CamAngle.x);\n        }\n        if(texelFetch(iChannel1, ivec2(KeyDown,0),0).x==1.){\n            CamOffset.x += 4.*sin(-CamAngle.x);\n            CamOffset.z += 4.*-cos(-CamAngle.x);\n        }\n        CamOffset.y += 4.*texelFetch(iChannel1, ivec2(KeyE,0),0).x;\n        CamOffset.y -= 4.*texelFetch(iChannel1, ivec2(KeyQ,0),0).x;\n        if(texelFetch(iChannel1, ivec2(KeyR,0),0).x==1.){\n            CamOffset = vec3(0,0,0);\n        }\n        fragColor = vec4(CamOffset,1.0);\n    }\n    if(floor(uv*10.)==vec2(2,0)){\n        vec2 CamAngle = texture(iChannel0, uv).xy;\n        CamAngle.x -= 4.*(texture(iChannel0, vec2(.05,.05)).x-iMouse.x/iResolution.x)*float(abs(texture(iChannel0, vec2(.05,.05)).x-iMouse.x/iResolution.x)<.05);\n        CamAngle.y -= 4.*(texture(iChannel0, vec2(.05,.05)).y-iMouse.y/iResolution.y)*float(abs(texture(iChannel0, vec2(.05,.05)).y-iMouse.y/iResolution.y)<.05);\n        if(texelFetch(iChannel1, ivec2(KeyR,0),0).x==1.){\n            CamAngle = vec2(0,0);\n        }\n        fragColor = vec4(CamAngle,1.0,1.0);\n    }\n    if(floor(uv*10.)==vec2(3,0)){\n        float iter = texture(iChannel0, uv).x+.001;\n        if(texture(iChannel0, vec2(.05,.05)).xy != iMouse.xy/iResolution.xy) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyLeft,0), 0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyRight,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyUp,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyDown,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyE,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyQ,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyR,0),0).x==1.) iter = 0.;\n        fragColor = vec4(iter,0,0,0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}