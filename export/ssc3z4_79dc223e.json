{"ver":"0.1","info":{"id":"ssc3z4","date":"1629314084","viewed":421,"name":"Simple Raymarching Clouds","username":"SirBelfer4","description":"A very simple volumetric cloud raymarching demo.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------//\n// I made this to remember how volumetric clouds worked.  //\n// Feel free to use it anyway you like!                   //\n//--------------------------------------------------------//\n\n// Usage: 0 = sphere, 1 = box, 2 = noise\n#define SDF_TYPE 0\n\n// Usage: 0 = false, 1 = true\n#define USE_SHADOWS 1\n\n// Steps to compute cloud\n#define CLOUD_STEPS 200\n// Steps to compute shadow\n#define SHADOW_STEPS 10\n// Shadow factor\n#define SHADOW_MULT 0.03\n// Raymarching step size in cloud\n#define STEP_SIZE 0.1\n// Volume factor\n#define CLOUD_THRES 0.5\n// Density factor\n#define CLOUD_MULT 2.0\n\n// Colors\n#define CLOUD_COLOR vec3(0.9, 0.85, 0.8)\n#define SKY_COLOR vec3(0.5, 0.7, 0.8)\n\n// Utility\n#define PI 3.141592\nvec3 rotate(vec3 v, vec3 a);\nfloat sdSphere(vec3 p, float s);\nfloat sdBox(vec3 p, vec3 b);\nfloat sdNoise(vec3 x);\n\n// Clouds\nfloat sdf(vec3 p)\n{\n    switch(SDF_TYPE)\n    {\n    case 0: return sdSphere(p, 2.0);\n    case 1: return sdBox(p, vec3(2.0));\n    case 2: return sdNoise(vec3(p.x + iTime, p.yz) * 0.5);\n    }\n}\n\nfloat density(vec3 p)\n{\n    return max(CLOUD_THRES - sdf(p), 0.0) * CLOUD_MULT;\n}\n\nvec4 raymarch(vec3 ro, vec3 rd, vec3 ld, vec3 lc)\n{\n    vec4 ct = vec4(0.0); // color-transmittance\n    \n    for (int i = 0; i < CLOUD_STEPS; i++)\n    {\n        float den = density(ro);\n        if (den > 0.01) // inside\n        {\n            // shadows\n            float shadow = 0.0;\n            #if USE_SHADOWS\n            for (int j = 0; j < SHADOW_STEPS; j++)\n                shadow += density(ro - ld * (float(j) + 1.0) * STEP_SIZE) * SHADOW_MULT;\n            shadow = clamp(shadow, 0.0, 1.0);\n            #endif\n            \n            // clouds\n            vec4 col = vec4(CLOUD_COLOR, den);\n            col.a = min(col.a * STEP_SIZE, 1.0);\n            col.rgb *= col.a * (1.0 - shadow);\n            ct += col * (1.0 - ct.a);\n        }\n        \n        // march\n        float dt = den > 0.01 ? STEP_SIZE : max(den, STEP_SIZE);\n        ro += rd * dt;\n        \n        if (ct.a > 0.99) break; // opaque\n    }\n    \n    return clamp(ct, 0.0, 1.0);\n}\n\n// Main\nvoid mainImage(out vec4 pColor, in vec2 pCoord)\n{\n    // display\n    float aspect = iResolution.y / iResolution.x;\n    vec2 ndc = 0.5 - pCoord / iResolution.xy;\n    \n    // controls\n    vec3 camRot = vec3(0.5 - iMouse.yx / iResolution.yx, 0) * 2.0 * PI;\n    camRot.y = -camRot.y;\n    \n    // light\n    vec3 ld = normalize(vec3(-1.0, -10.0, -2.0));\n    vec3 lc = SKY_COLOR;\n\n    // ray\n    vec3 ro = vec3(0, 0, 15.0);\n    vec3 rd = normalize(vec3(ndc.x, ndc.y * aspect, -1.0));\n    ro = rotate(ro, camRot);\n    rd = rotate(rd, camRot);\n    \n    // render\n    vec4 ct = raymarch(ro, rd, ld, lc);\n    pColor = vec4(lc * (1.0 - ct.a) + ct.rgb, 1.0);\n}\n\n// Utility impl\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    // https://iquilezles.org/articles/distfunctions\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    // https://iquilezles.org/articles/distfunctions\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat sdNoise(vec3 x)\n{\n\tconst vec3 step = vec3(110, 241, 171);\n\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n \n\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the \n\t// incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}","name":"Image","description":"","type":"image"}]}