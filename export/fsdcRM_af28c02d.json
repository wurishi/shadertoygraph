{"ver":"0.1","info":{"id":"fsdcRM","date":"1653190982","viewed":149,"name":"Haru86_Ray_220522-02","username":"Haru86_","description":"Haru86_Ray_220522","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n#define time iTime\n#define resolution iResolution\nuniform float _cameraPositionIndex;\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define PI 3.14159265\nstruct DBuffer{\n  float d1;\n  float d2;\n  float d3;\n  float mainD;\n};\n\nstruct AccBuffer{\n  float acc1;\n  float acc2;\n  float acc3;\n};\n\nvec2 random2(vec2 seeds)\n{\n seeds = vec2(dot(seeds, vec2(127.1, 311.7)),\n dot(seeds, vec2(269.5, 183.3)));\n return fract(sin(seeds) * 43758.5453123);\n}\n\nfloat perlinNoise(vec2 seeds)\n{\nvec2 i = floor(seeds);\nvec2 f = fract(seeds);\nvec2 i00 = i + vec2(0, 0);\nvec2 i10 = i + vec2(1, 0);\nvec2 i01 = i + vec2(0, 1);\nvec2 i11 = i + vec2(1, 1);\nvec2 f00 = f - vec2(0, 0);\nvec2 f10 = f - vec2(1, 0);\nvec2 f01 = f - vec2(0, 1);\nvec2 f11 = f - vec2(1, 1);\nvec2 g00 = normalize(-1.0 + 2.0 * random2(i00));\nvec2 g10 = normalize(-1.0 + 2.0 * random2(i10));\nvec2 g01 = normalize(-1.0 + 2.0* random2(i01));\nvec2 g11 = normalize(-1.0 + 2.0* random2(i11));\nfloat v00 = dot(g00, f00);\nfloat v10 = dot(g10, f10);\nfloat v01 = dot(g01, f01);\nfloat v11 = dot(g11, f11);\nvec2 p = smoothstep(0.0, 1.0, f);\nfloat v00v10 = mix(v00, v10, p.x);\nfloat v01v11 = mix(v01, v11, p.x);\nreturn mix(v00v10, v01v11, p.y) * 0.5 + 0.5;\n}\n\nvec2 fmod(vec2 p,float r){\n  float a=atan(p.x,p.y)+PI/r;\n  float n=(2.*PI)/r;\n  a=floor(a/n)*n;\n  return rot(a)*p;\n}\n\n\n#define foldingLimit 1.0\nvec3 boxFold(vec3 z, float dz) {\n    return clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\nvoid sphereFold(inout vec3 z, inout float dz, float minRadius, float fixedRadius) {\n    float m2 = minRadius * minRadius;\n    float f2 = fixedRadius * fixedRadius;\n    float r2 = dot(z, z);\n    if (r2 < m2) {\n        float temp = (f2 / m2);\n        z *= temp;\n        dz *= temp;\n    } else if (r2 < f2) {\n        float temp = (f2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\n// ref: http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\n#define ITERATIONS 12\nfloat deMandelbox(vec3 p, float scale, float minRadius, float fixedRadius) {\n    vec3 z = p;\n    float dr = 1.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        z = boxFold(z, dr);\n        sphereFold(z, dr, minRadius, fixedRadius);\n        z = scale * z + p;\n        dr = dr * abs(scale) + 1.;\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\nfloat Plane(vec3 p){\n  return p.y;\n}\n\nfloat Cube(vec3 p,vec3 s){\n  return length(max(abs(p)-s,0.0));\n}\n\nfloat d1(vec3 p){\n     p*=.5;\n\n/*  p.xy*=rot(time);\n  p.xz*=rot(time);\n  p.yz*=rot(time);*/\n\nfloat speed=10.0;\n  p.z-=time*speed;\n  float k=12.0;\n  p=mod(p,k)-k*0.5;\n  \n  p=abs(p);\n  float s=1.;\n  float ts=0.05;\n  float dt=floor(time)+pow(fract(time),0.5);\n  for(int i=0;i<2;i++){\n    p.xy=fmod(p.xy,12.);\n    p.xz*=rot(0.25);\n    p.xz=fmod(p.xz,6.);\n    p.yz*=rot(0.25);\n    p.yz=fmod(p.yz,6.);\n    p.xy*=rot(0.25);\n\n   p.x=abs(p.x)-0.5;\n    p.z=abs(p.z)-.015;\n  }\n\n  p.xy=fmod(p.xy,36.);\n\n  float val=sin(.15);\n  float d=deMandelbox(p, 2.0, .05+val, 1.+val*0.05);\n  return d;\n  //return length(p)-0.5;\n}\n\nfloat d2(vec3 p){\n   \n\n  float d=length(p)-1.;\n\n//p.x+=1.5;\n  p.xy*=rot(time);\n  p.xz*=rot(time);\n  p.yz*=rot(time);\n  for(int i=0;i<3;i++){\n    p=abs(p)-.6;\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n\n    p.xy*=rot(0.5);\n    p.xz*=rot(0.15);\n    p.yz*=rot(0.25);\n}\n\nd=min(d,Cube(p,vec3(.2,.2,.2)));\n\n  return d;\n}\nDBuffer map(vec3 p){\n  DBuffer d;\n  d.d1=d1(p);\n  d.d2=d2(p-vec3(0.,0.,9.));\n  d.d3=2000.0;\n  d.mainD=min(min(d.d1,d.d2),d.d3);\n  return d;\n}\n\nvec3 gn(vec3 p){\n  vec2 e=vec2(0.001,0.);\n  return normalize(\n    vec3(\n      map(p+e.xyy).mainD-map(p-e.xyy).mainD,\n      map(p+e.yxy).mainD-map(p-e.yxy).mainD,\n      map(p+e.yyx).mainD-map(p-e.yyx).mainD\n      )\n    );\n}\n\nvec3 hsv2rgb2(vec3 c, float k) {\n    return smoothstep(0. + k, 1. - k,\n        .5 + .5 * cos((vec3(c.x, c.x, c.x) + vec3(3., 2., 1.) / 3.) * radians(360.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st = (fragCoord.xy*2.0-resolution.xy) / min(resolution.x,resolution.y);\n // vec2 st=uv*2.0-1.0;\n  //st.x*=(resolution.x/resolution.y);\n\n  vec3 col=vec3((st.y+1.0)*0.5*0.25);\n  float radius=15.;\nfloat speed=-.25;\n vec3 ta=vec3(0.);\n// vec3 ta=vec3(cos(time),0.,sin(time));\n vec3 ro=vec3(0.,0.,14.);\n\n float adjustAcc=0.5;\n /*if(_cameraPositionIndex==0){\n adjustAcc=0.5;\n    ro=vec3(0.,0.,15.);\n }else if(_cameraPositionIndex==1){\n    adjustAcc=0.5;\n    float radius=1.0*(perlinNoise(vec2(0.123,time*5.0))+1.0)*2.25;\n    ta=vec3(0.,0.,9.);\n    ro=vec3(cos(time)*radius,sin(time)*radius,sin(time)*radius);\n }else if(_cameraPositionIndex==2){\n    adjustAcc=0.25;\n    //st*=rot(time);\n    ro=vec3(-2.,-1.,20.);\n }*/\n\n// vec3 ro=vec3(0.,0.,0.);\n vec3 cDir=normalize(ta-ro);\n vec3 cSide=cross(cDir,vec3(0.,-1.,0.));\n vec3 cUp=cross(cDir,cSide);\n float depth=1.;\n vec3 rd=normalize(vec3(st.x*cSide+st.y*cUp+cDir*depth));\n\n  DBuffer d;\n  AccBuffer acc;\n  float t=0.0;\n  for(int i=0;i<128;i++){\n    d=map(ro+rd*t);\n    if(d.d1<0.01||d.d2<0.001||d.d3<0.001||t>1000.0)break;\n    t+=d.mainD;\n\n    acc.acc1+=exp(-6.0*(d.mainD));\n    acc.acc2+=exp(-1.0*d.mainD);\n    acc.acc3+=exp(-1.0*d.mainD);\n  }\n\n  if(d.d1<0.01||t<1.0){\n    vec3 pos=ro+rd*t;\n    float flash=1.0-abs(sin(pos.z*.5+time*4.0));\n    flash+=.1;\n    float rim=pow(min(d.d1,2.0),.5);\n    float H = mod(time*0.5, 1.0);\n    col+=vec3(exp(-.1*t))*rim*acc.acc1*.75*flash*hsv2rgb2(vec3(H,1.0,1.0),2.2)*(1.0/(adjustAcc*2.0));\n    //*pow((1.0-abs(dot(n,rd))),.5)\n    ;\n  }\n\n  if(d.d2<0.001){\n    vec3 refro=ro+rd*t;\n    vec3 n=gn(refro);\n    rd=reflect(rd,n);\n    ro=refro;\n    t=0.1;\n    float acc2;\n\n    for(int i=0;i<33;i++){\n      d=map(ro+rd*t);\n      if(d.mainD<0.001)break;\n      t+=d.mainD;\n      float H = mod(time*0.5, 1.0);\n      acc2+=exp(-3.*d.mainD);\n    }\n\n    vec3 pos=ro+rd*t;\n    float flash=1.0-abs(sin(pos.z*.5+time*4.0));\n    flash+=.1;\n    float H = mod(time*0.5, 1.0);\n    col+=vec3(exp(-.1*t))*acc.acc2*.75*flash*hsv2rgb2(vec3(H,1.0,1.0),2.2)*adjustAcc;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/","name":"Image","description":"","type":"image"}]}