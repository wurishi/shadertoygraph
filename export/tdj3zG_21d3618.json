{"ver":"0.1","info":{"id":"tdj3zG","date":"1549239050","viewed":127,"name":"Raymarch Sierpinski","username":"darkeclipz","description":"raymarcher\n\n - http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n - http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-ii-lighting-and-coloring/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define M ((2.*iMouse.xy-R)/R.y*4.)\n#define MaxSteps 100.\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-ii-lighting-and-coloring/\nfloat DE(vec3 z)\n{\n    float Iterations = 12.;\n    float Scale = 2.0;\n    float Offset = 0.5;\n    float n = 0.;\n    while (n < Iterations) {\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\n       z = z*Scale - Offset*(Scale-1.0);\n       n++;\n    }\n    return length(z) * pow(Scale, -float(n));\n}\n\nvec2 trace(vec3 o, vec3 r) {\n\tfloat t = 0.0;\n    for(float i = 0.; i < MaxSteps; i++) {\n    \tvec3 p = o + r * t;\n        float d = DE(p);\n        if(d < 0.0005) break;\n        if(d > 20.) return vec2(20.,1.);\n        t += d;\n    }\n\treturn vec2(t, 1. - t / MaxSteps);\n}\n\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 8.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 view) {\n    \n    vec3 lpos1 = vec3(0,-3,-3);\n    vec3 lpos2 = vec3(0,3,0);\n    vec3 col1 = vec3(201./255., 234./255., 1.);\n    \n\tvec3 L1 = shadeBlinnPhong(p, view, n, lpos1, 10., vec3(1., 252./255., 240./255.));\n    vec3 L2 = shadeBlinnPhong(p, view, n, lpos2, 10., vec3(1., 252./255., 240./255.));\n    return L1 + L2 + vec3(0.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and center coordinates.\n    vec2 uv = (2.*fragCoord-R) / R.y;\n\n\t// create a ray and march it\n    vec3 o = vec3(.0,0,-3);\n    vec3 r = normalize(vec3(uv, 1.0)-o);\n    \n    o += vec3(0,0,0);\n    \n    mat3 rot = rotateY(M.x);\n    mat3 rotZ = rotateZ(M.y);\n    rot = rot * rotZ;\n    o *= rot;\n    r *= rot;\n    \n    vec2 hit = trace(o, r);\n    float t = hit.x;\n    float occl = hit.y;\n    \n    // find the point where we hit the object.\n    vec3 p = o + r*t;\n    \n    // calculate the normal.\n    float eps = 0.001;\n    vec3 xDir = vec3(eps,0,0), yDir = vec3(0,eps,0), zDir = vec3(0,0,eps);\n    vec3 n = normalize(vec3(DE(p+xDir)-DE(p-xDir),\n\t\t                DE(p+yDir)-DE(p-yDir),\n\t\t                DE(p+zDir)-DE(p-zDir)));\n    \n    vec3 col = vec3(0);\n    if(t < 20.) {\n        col = getLight(p, n, xDir) * occl;\n    }\n    else {\n        col = mix(2.*vec3(0., 15./255., 36./255.), 2.3*vec3(0., 35./255., 84./255.), fragCoord.y / iResolution.y);\n    }\n    \n    //col = vec3(occl);\n   \n    \n    fragColor = vec4(vec3(col),1.0);\n}\n","name":"Image","description":"","type":"image"}]}