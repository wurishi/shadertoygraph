{"ver":"0.1","info":{"id":"NdyfWd","date":"1658984842","viewed":165,"name":"Painting 1","username":"scry","description":"From following along iq's \"Painting a Landscape With Maths\" video https://www.youtube.com/watch?v=BFld4EBO2RE\n:)","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","sunset","mountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////////////////////////////////////////////////////////////////////////\n#define pi acos(-1.)\n#define R iResolution.xy\n#define deg pi/180.\n#define time iTime*0.01\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//#define dtime time*hill(time,10.)\nfloat bitm(vec2 uv,int c) {\n    float h = 5.;\n    float w = 3.;\n    int p = int(pow(2.,w));\n    float line1 = 9591.;\n    uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);\n    float c1 = 0.;\n    float cc = uv.x + uv.y*w;\n    c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);\n    c1 *= step(0.,uv.x)*step(0.,uv.y);\n    c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));\n    return (c1);\n}\n \n\nvec3 slogo(vec2 uv, float ar, float size) {\n    vec2 px = vec2(1./3.,1./5.);\n    float ls = 4.1;\n    uv.x = 0.993-uv.x;\n    uv *= 8.*ls*(1./size);\n    ls += 2.;\n    float ul = length(uv);\n    uv -= px.yx*0.5*0.5*ls;\n    ul = length(vec2(uv.x*0.5,uv.y)-0.5);\n    uv.x *= ar*1.75;\n    int s = 29671;\n    int c = 29263;\n    int r = 31469;\n    int y = 23186;\n    uv.x= 5.-uv.x;\n    float b = bitm(uv,s);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,c);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,r);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,y);\n    float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));\n    b = clamp(b,0.,1.);\n    vec3 l = hsv2rgb(vec3(b+iTime/40.,0.1,rr-b*1.9))*rr;\n    l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);\n    return vec3(l);\n}\n\n\nfloat opSu( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat b2(vec2 uv) {\n    return ((sin(uv.x)*0.5+0.5)+(sin(uv.y)*0.5+0.5))*0.5;\n}\n\n//TERRAIN\nfloat th(vec3 p, int st,float t,vec3 o) {\n    float d = p.y;\n    float a = 12.;\n    float oa = a;\n    float m = 0.66;\n    float c = length(p.xz);\n    vec2 uz = p.xz;\n    vec2 uc = uz;\n    //d += .5;\n    //d += b2(uz*0.01)*50.;\n    float f = 0.001;\n    //d += b2(uz*f*20.)*a*2.;\n    for (int i=0;i<17;i++) {\n        //uz *= r2d(deg*45.+time);\n        //uz += 0.;\n        uz *= r2d(deg*(float(i)*0.5+10.)+0.005+d*0.01);\n        uz *= r2d(c*0.01);\n        //uz -= 0.5;\n        //uz *= r2d(float(i)*0.1+sin(c*0.001/f+iTime*0.5+float(i)*20.)*f*0.1);\n        //uz += 0.;\n        //uz *= r2d(deg*(float(i)*0.5+10.)+sin(iTime*10.+sin(p.x*0.1)+sin(p.y*0.1))*0.1*f);\n        vec2 uzf = abs(fract(uz*f-0.5)-0.5)/f;\n        //uz *= r2d(sin(uzf.x*0.1));\n        f *= 1.966;\n        //f -= 0.01*(log(c));\n        uz.xy = uzf.xy;\n        //uz += sin(uz*float(i));\n        //uz *= r2d((sin(p.x)-sin(p.z+float(i)*1.)));\n        a *= m;\n        //a *= 0.1;\n        a *= exp(-0.01*c);\n        d += b2(uz*0.15+sin(c*0.1)*0.2)/0.4;\n        //d += b2(uz*f)*(a+0.1)*0.1;\n        //d += b2(uz*f+(time+float(i)*20.)*100.)*a*1.;\n        if (i > 10) {\n        //if (i > int(iTime+exp(-c*0.1)*10.-10.)) {\n        //    uc = uz;\n            uz *= r2d(5.*pow(float(i-7),1.5)+c*2.);\n        }\n        //a *= m;\n        m *= 0.99;\n        //m *= 0.5;\n    }\n    //d += b2(uc*0.5)/0.4;\n    //d = d*d;\n    //d += sin(uz.x)*0.1;\n    //d -= 25.;\n    d -= oa*2.;\n    //d += (1.-exp(-0.01*c))*150.;\n    //d += log(c);\n    //d += c-exp(-0.001*c)*4.;\n    //d += pow(c,1.05);\n    //d *= 1.4;\n    //uz += sin(uz);\n    //d += b2(uz*2.5)*0.01;\n    //d += b2(uz*0.1)*10.;\n    return d;\n}\n\n\n//CAMERA POSITION\nvec3 cpos(float t) {\n    vec3 c = vec3(0.);\n    //c.z -= iTime*time*5.;\n    c.z = -127.;\n    c.z *= 0.34;\n    c.y -= 0.;\n    c.xz *= r2d(0.5+time);\n    //c.z += 5.;\n    float tr = th(c,7,t,c);\n    //c.z -= 5.;\n    //c.y = 0.961;\n    //c.y *= (exp(-0.01*iTime));\n    c.y = -tr*0.;\n    //c.y += (-tr+0.18)*(1.-exp(-0.006*iTime));\n    //c.y += 6.;\n    \n    //c.y += 1.;\n    return c;\n}\n\n//CAMERA ROTATION\nmat4 eye(void) {\n    vec3 c = cpos(time);\n    vec3 l = vec3(cpos(time+0.1));\n    //l *= 1.;\n    //l *= 1.2;\n    //l.y *= 0.7;\n    //l.y -= 0.19;\n    l.xz *= r2d(deg*170.);\n    l.y -= 16.;\n    //l.xz *= r2d(120.*deg);\n    //l *= 0.5;\n    //l *= sin(time)*2.;\n    //c *= sin(time);\n    //l.xz *= r2d(sin(time)*0.1+time*0.1);\n    //l.yz *= r2d(sin(time)*0.1);\n    //l.x += 0.5;\n    vec3 f = normalize(l-c);\n    vec3 r = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = cross(f,r);\n    return mat4(r.x,r.y,r.z,0.,\n                u.x,u.y,u.z,0.,\n                f.x,f.y,f.z,0.,\n                0.,0.,0.,1.);\n}\n\n//SUN POSITON\nvec3 spos(void) {\n    vec3 s = vec3(1.,5.,1.);\n    s *= 0.;\n    vec3 c = -cpos(time);\n    //s -= cpos(time);\n    s += c;\n    s.y += 4.;\n    //s.y += 2.*(sin(iTime*0.5)*0.5+0.45);\n    //s.x += 0.;\n    //s.y += 4.+sin(time*100.)-1.;\n    float lr = time*3.5;\n    //s.y += 4.*(sin(lr)*0.5+0.5);\n    //s.y += 0;\n    \n    //s.y = abs(s.y);\n    //s.xy *= r2d(iTime);\n    //s.z += 1000.;\n    //s.x += 0.;\n    //s.z += (length(cpos(time)));\n    //s += c;\n    vec3 ap = vec3(0.);\n    //ap.xy *= r2d(iTime);\n    ap.yz += vec2(500.,0.)*r2d((fract((iTime+35.25)/160.)-0.5)*pi*2.);\n    ap.xz *= r2d(deg*-ap.y*0.05);\n    ap.xy *= r2d(deg*10.);\n    //ap.xz *= r2d(deg*sin(iTime*20.)*2.);\n    //ap.xy += vec2(2.,0.)*r2d(deg*sin(iTime*20.)*25.);\n    //ap.y += 20.*(sin(iTime*0.8)*0.5+0.5);\n    //s.y += 0.6;\n    //ap = normalize(ap)*120.;\n    //s += 1.;\n    //ap.y += 3.;\n    //ap.x += 2.;\n    //ap.y += -iTime*0.2;\n    //ap.xz = vec2(length(ap.xz),atan(ap.x,ap.z));\n    s += ap;\n    //s += c;\n    //s.y = abs(s.y);\n    //s.z = s.y;\n    //s.x *= cos(iTime);\n    //s.x = fract(s.x/1500.)*500.;\n    //s.xz *= r2d(4.);\n    //s.xz += vec2(cos(lr),sin(lr))*sin(time*200.)*120.;\n    //s.x -= 50.;\n    //s -= cpos(time);\n    //s = normalize(s)*10.;\n    s = (inverse(eye())*vec4(s,1.)).xyz;\n    //s = normalize(s)*100.;\n    //s -= cpos(time);\n    //s.y += 4.;\n    //s.y -= 0.1;\n    //s *= 0.;\n    //s = (inverse(eye())*vec4(s,1.)*(eye())).xyz;\n    //s += cpos();\n    return s;\n}\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p = (eye()*vec4(p,1.)).xyz;\n    //p.yz *= r2d(deg*-45.*0.2);\n    //p += cpos(time);\n    //p += c;\n    p += cpos(time);\n    float ms = length(o-vec3(0.,0.,2.))-0.1;\n    ms = min(ms,length(o-vec3(0.,0.,300.))-100.);\n    vec3 c = cpos(o.x);\n    float d = th(p,12,time,o);\n    vec3 pa = vec3(0.,d,0.);\n    float cl = length(p.xz);\n    d = min(d,length(p+vec3(0.,-0.25,-0.))-0.1);\n    d = min(d,length(abs(p+vec3(0.,-0.,-0.))-0.9)-0.2);\n    d = min(d,length(abs(p+vec3(0.,-0.,-0.))-220.)-10.);\n    p.y = d;d = 10000.;d = min(d,p.y);\n    //p -= pa;\n    \n    d = min(d,length(p+vec3(0.,-0.25,-0.))-0.1);\n    d = min(d,length(abs(p+vec3(0.,-0.,-0.))-0.2)-0.1);\n    d = min(d,length(abs(p+vec3(0.,-0.,-0.))-220.)-10.);\n    \n    float py = p.y;\n    //d -= th(p*4.,4)*0.01;\n    //d -= th(p*10.,4)*0.01;\n    //d *= 0.5;\n    //o.y += 0.03;\n    //o.y -= d;\n    float dy = d;\n    d += cl*0.2;\n   // d += sin(p.z*20.)*sin(p.x*20.)*0.002;\n    //d += sin(p.z*1200.)*sin(p.x*1200.)*0.0008;\n    //d = min(d,);\n    //d = min(d,ms);\n    //p.xz = (fract(p.xz*1.4)-0.5)/1.4;\n    //d = min(d,max(length(p.xz)-0.01,abs(p.y)-0.5));\n    //p.y += -0.5;\n    //p.x -= 0.;\n    //p.x += 0.1;\n    //vec2 pt = vec2(length(p.xy)-0.01,atan(p.x,p.y));\n    //float pt = length(vec2(p.z,length(p.xy)-0.1))-0.01;\n    //d = min(d,max(pt,-p.y));\n    //d = min(d,length(pt)-0.1);\n    d = max(d,-(length(o)-0.15));\n    \n    //c.y += 0.03;\n    //o.y -= 0.1;\n    //o.x += 0.04;\n    //o.y += c.y*0.9;\n    //o.y += d*1.6;\n    //d = min(d, length(vec2(o.x+p.x*0.2,dy-0.002))-0.001);\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    \n    //float rt = time1*1.;\n    for (int i=0;i<99;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w*0.9;\n        //float dS = map(p).w*(1.-exp(-0.1*iTime));\n        //ro.xy += vec2(sin(rt),cos(rt))/R.x*0.05;\n        dO += dS/1.6;\n        ii += 0.01;\n        if (dS < 0.005 || dO > 16000.) {break;}\n    }\n    //dO *= 1.02;\n    return vec2(dO,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p-h.xyy).w-map(p+h.xyy).w,\n        map(p-h.yxy).w-map(p+h.yxy).w,\n        map(p-h.yyx).w-map(p+h.yyx).w\n    ));\n}\n\nvec3 sh(vec3 p, vec3 n, vec3 l, vec3 r, vec2 t, vec3 ro) {\n    vec3 rd = normalize(l-p);\n    vec2 d = RM(p-n*0.1,rd);\n    float s = 1.;\n    if (length(l-p) > d.x) {\n        s = 0.;\n    }\n    vec3 rc = cpos(time);\n    vec3 lv = -l;\n    \n    float ll = length(lv);\n    float a = clamp( dot( rd, lv/ll ), 0.0, 1. );\n    //a *= ll;\n    //a = acos(a)*ll;\n    //a *= 0.99;\n    float a2 = 1.-smoothstep(0.,16.8,acos(a)*ll);\n    //a2 = length(rd.xy-l.xy*-l.z)-5.;\n    //a *= 0.1;\n    //a = a2;\n    a = 0.;\n    //float lt = length(lv-rc);\n    float lt = map(l).w;\n    //if (lt < ll) {\n    //a += 1.-smoothstep(0.,1.2,length(l.xy-r.xy*l.z));\n    //a *= 0.;\n    //a = a2+t.y;\n    //} else {\n    //a += a2;\n    //}\n    \n    a += (1.-smoothstep(0.,1.2,length(l.xy-rd.xy*l.z/rd.z)))*a2;\n    //a *= 0.;\n    //if (t.x < ll) {\n    //    a *= 0.;\n    //}\n    a += a2;\n    a *= 0.5+lt;\n    a = clamp(a,0.,1.);\n    //a = a2+t.y;\n    //} else {\n    //a += a2;\n    //if (lt < 0.) {\n        //a *= 1.-lt;\n    //}\n    //}\n    //a = ll-6.;\n    //a = acos(a)*ll;\n    //if (t.x > ll) {\n    //a = ll-4.;\n    \n    //a = a2*a2*100.*exp( -0.00007*ll*ll );\n    //a = a2*exp( -0.07*ll*ll );\n    //a = 1.-step(a2,0.8+t.y*0.1);\n    //a *= 20.;\n    //a = 1.-smoothstep(0.,122.,-a*ll);\n    //a = 1.-a*0.5;\n    //a = (a-0.5)*2.;\n    \n        //a *= 0.6;\n    //}\n    //a = pow(a,3.);\n    //a *= t.x;\n    //a = a*exp(-0.003*ll*ll);\n    //a = pow(a,10.);\n    //float a = clamp(length(l-rd)-7.1,0.,1.);\n    //a = (1.-length(l-p)*0.)*a;\n    //a = clamp(a,0.,1.);\n    //a = pow(a,3.);\n    return vec3(clamp(dot(rd,-n),0.,1.),s,a);\n}\n\nvec3 colo(vec3 p, vec3 n, vec2 d, vec3 rd, vec3 ro) {\n    vec3 col = vec3(0.);\n    vec3 mp = map(p).xyz;\n    vec3 cn = ((eye())*vec4(n,1.)).xyz;\n    vec3 gc = vec3(0.99,0.75,0.45);\n    float m = 2.;\n    float a = 1.;\n    vec2 gv = mp.xz;\n    float gd = smoothstep(0.8,0.9,-n.y);\n    gc = gc*(1.-gd)+gd*vec3(0.,0.2,0.);\n    //gc = clamp(gc,0.,1.);\n    vec3 sc = vec3(0.4,0.6,0.99);\n    vec3 sp = spos();\n    float sunh = clamp(sp.y*0.002,0.,1.);\n    sc += (sin(vec3(1.,2.,3.)+d.y/(0.56+sunh))*clamp(d.x*0.007,-9.,1.)*0.9)*(1.-sunh);\n    sc = mix(sc,vec3(0.,0.,0.1),pow(1.-sunh,3.));\n    //sc *= sunh*0.9;\n    //sc += sin(vec3(1.,2.,3.)+d.y*1.2)*clamp(d.x*0.001,0.,1.);\n    //sc *= clamp(spos().y*0.005,0.,1.);\n    //sc -= 1.-clamp(spos().y*0.01,0.,1.);\n    //sc -= 1.-exp(p.y*0.001*vec3(1.,2.,3.));\n    vec3 bge = exp(-0.002*d.x*vec3(1.,2.,4.));\n    col += 1.-d.xxx*0.005;\n    //col *= 0.;\n    //col += n*0.25;\n    vec3 s = sh(p,n,spos(),rd,d,ro);\n    col = gc*s.x*s.y;\n    //col = gc*((s.x*s.y)+(((1.+-n.y)/2.)*sc*0.1));\n    //col += s.z;\n    //col += s.z*10.;\n    //col *= 0.5;\n    //col = clamp(col,0.,0.1);\n    col += s.z;\n    col += ((1.+-n.y)/2.)*sc*0.1;\n    col += clamp(dot(-spos(),-n),0.,1.)*gc*0.1;\n    //col += (-n.y)*sc*0.2*gc;\n    //col = col+col*vec3(1.5,.1,.5)*n.x*0.5;\n    if (d.x > 1000.) {\n        col = d.yyy*sc*0.4;\n        col += sc*0.4;\n        col *= 0.;\n        //sc = sin(vec3(1.,2.,3.)+d.y);\n        //col += s.z*1.;\n    }\n    \n    \n    //col -= d.y*d.y*0.9+0.3;\n    col = clamp(col,0.,1.);\n    col = bge*col+(1.-bge)*sc;\n    //col *= 0.1;\n    //col *= 0.4;\n    col += s.z*1.;\n    //col = clamp(col,0.,1.);\n    //n.xy *= r2d(time*100.);\n    //col = col+col*vec3(1.5,.1,.5)*n.x*0.1;\n    //n.br *= r2d(d.x*0.1);\n    //col -= n*0.2;\n    col = rgb2hsv(col);\n    //col.z = -cn.y;\n    //col.x *= cn.z;\n    \n    col = hsv2rgb(col);\n    //col += s.z*0.5;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    vec2 tv = uv;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    uv *= 1.4;\n    float ua = time*1509210.;\n    //uv.x -= 0.5;\n    //uv\n    //uv.xy += vec2(sin(ua),cos(ua))/R.x*10.5;\n    //uv.y += 0.8;\n    float c = length(uv);\n    vec3 rd = normalize(vec3(uv,1.2-c*0.2));\n    rd.xz *= r2d(-deg*10.);\n    //vec3 rd = normalize(vec3(uv,(12.1-c*c*50.)*0.1+0.5));\n    vec3 bak = texture(iChannel0,tv).rgb;\n    vec2 sv = tv;\n    //sv -= 0.5;\n    //sv *= r2d(time*900.);\n    //sv += 0.5;\n    //sv += sin(sv.x*(200.+sin(c+time)*150.)+time*190.)*0.2;\n    //if (fract(time*sin(time*80.+c*0.01)*530.-sv.x) < 0.94) {\n        \n    \n    //if (iFrame > 10) {\n        //fragColor = vec4(bak,1.);\n        //return;\n    //}\n    vec2 d = RM(ro,rd);\n    //ua = iTime*1000.;\n    //ro.xy += vec2(sin(ua),cos(ua))*d.x*0.01;\n    //rd.xy += vec2(sin(ua),cos(ua))/R.x*0.1*(d.x);\n    //rd = normalize(vec3(uv,1.));\n    //rd = normalize(vec3(uv,(12.1-c*c*50.)*0.1+0.5));\n    //d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    //col += 1.-d.xxx*0.1;\n    col = colo(p,n,d,rd,ro);\n    sv = tv;\n    float a = 40.;\n    a += (sin(sv.x*30.)+sin(sv.y*30.)+time*20.)*0.1;\n    sv -= 0.5;\n    //sv *= r2d(deg*45.*4.+time*10.*floor(fract(log(c)+time*7.)*1.2)*20.);\n    sv += (sin(sv.x*a)+cos(sv.y*a))*0.0002;\n    a *= 2.;\n    sv += (sin(sv.x*a)+cos(sv.y*a))*0.0002;\n    a *= 2.;\n    sv += (sin(sv.x*a)+cos(sv.y*a))*0.0002;\n    //sv *= r2d(-deg*45.);\n    sv += 0.5;\n    //bak = texture(iChannel0,sv).rgb;\n    col += slogo(tv,ar,1.)/30.;\n    //col += (sin(col*time*1.-20.)*0.5);\n    col = clamp(col,0.,1.);\n    col = mix(col,bak,0.4);\n    //col = mix(col,bak,1.-clamp(exp(-22.5*(iTime)),0.,1.));\n    //col = clamp(col,0.,1.);\n    //col += bak*0.6;\n    //col += bak*0.4;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}