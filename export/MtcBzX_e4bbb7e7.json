{"ver":"0.1","info":{"id":"MtcBzX","date":"1540579035","viewed":223,"name":"biomech 1","username":"benhardy","description":"experiment with biomechanical things - WORK IN PROGRESS","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","biomech"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int ID_FLOOR = 2;\nconst int ID_SPINE = 3;\nconst int ID_VERTEBRA = 4;\nconst int ID_PIPE = 5;\nconst int ID_GUTS = 6;\nconst int ID_ROD = 7;\nconst int ID_BONE = 8;\nconst int ID_SOCKET = 9;\nconst int ID_CLIP = 10;\n\n/**\n * Measure the distance between the given point\n * and the closest object in the scene.\n * Returns a vector containing:\n *.   x: the distance to the closest object\n *.   y: the id of the closest object, as a float\n */\n\nfloat cylinder_z(vec3 where, vec3 center, float radius) {\n    return length((where - center).xy) -radius;\n}\n\nfloat cylinder_z_finite(vec3 where, vec3 center, float radius, float zstart, float zend) {\n    float c = length((where - center).xy) -radius;\n    return max(c, max(zstart - where.z, where.z - zend));\n}\n\nfloat cylinder_x_finite(vec3 where, vec3 center, float radius, float halfLength) {\n    vec3 p = abs(where - center);\n    float r = length(p.yz);\n    return length(vec2(max(0.0, r-radius), max(0.0, p.x-halfLength)));\n}\n\nfloat cylinder_x(vec3 where, vec3 center, float radius) {\n    return length((where - center).yz) -radius;\n}\nfloat cylinder_y(vec3 where, vec3 center, float radius) {\n    return length((where - center).xz) -radius;\n}\nfloat torus_x(vec3 where, float major, float minor) {\n    float r = length(where.yz);\n    return length(vec2(r-major, where.x)) - minor;\n}\n\nconst float cord_height = 2.9;\nconst float cord_offset = 1.6;\n\nfloat notched_cord(vec3 notch_pos) {\n    notch_pos = abs(notch_pos);\n    notch_pos.x = abs(mod(notch_pos.x + 0.2, 0.4) - 0.2);\n    float major = cylinder_x(notch_pos, vec3(0,cord_height,cord_offset), 0.4);\n    float cutplane = notch_pos.x-0.1;\n    float combined = max(major, cutplane);\n    float edge = length(vec2(major,cutplane)) - 0.02;\n    return blend(edge,combined, 0.04); // round edge slightly\n}\n\nconst float rib_spacing = 4.0;\n\nfloat cmod(float x, float d) {\n    return mod(x + d/2.0, d) - d/2.0;\n}\n\nfloat square_torus_z(vec3 where, \n                     float half_height, float half_length, float major, float minor)\n{\n    where = abs(where);\n    where.yz = max(where.yz - vec2(half_height, half_length), 0.0);\n    float r = length(where.yz) - major;\n    return length(vec2(r,where.x))- minor;\n}\n\nvec2 measure(vec3 where) {\n    float dist_floor = where.y;\n    float closest = 100000.0;\n    int who = 0;\n    vec3 spine_center = vec3(0.0,2.0,0.0);\n    vec3 cyl_center = vec3(0.0, 1.0, 0.0);\n    vec3 rib_pos = where;\n    rib_pos.x = cmod(rib_pos.x, rib_spacing);\n    vec3 clip_pos = rib_pos;\n    rib_pos.z /= 10.0;\n    rib_pos.x -= 1.0 - cos(rib_pos.z);\n    rib_pos.y -= 2.0 * cos(rib_pos.z);\n    rib_pos.y *= 3.0; //squishy\n    float dist_spine = (1.0/10.0)*\n        cylinder_z_finite(rib_pos, cyl_center, 1.0, -1.5, 1.5);\n    \n    \n    clip_pos.x -= 1.0 - cos(rib_pos.z);\n    clip_pos.y -= 2.0 * cos(rib_pos.z);\n    clip_pos.z = abs(clip_pos.z)-8.0;\n    clip_pos.y -= 0.7;\n    float dist_clip = square_torus_z(clip_pos, -0.05, 0.78, 0.2, 0.1);\n    vec3 strap_dims = vec3(2.5, 0.05, 0.7);\n    float dist_strap = round_box(clip_pos, strap_dims, 0.001);\n    vec3 hole_pos = vec3(cmod(clip_pos.x,0.5), clip_pos.y, cmod(clip_pos.z,0.45));    \n\tfloat hole = round_box(hole_pos, vec3(0.2,0.3,0.1), 0.01);\n    dist_strap = max(dist_strap, - hole);\n    dist_clip = min(dist_clip, dist_strap);\n    \n    vec3 vert_spot = where;\n    vert_spot.x = mod(vert_spot.x +2.0, 4.0) - 2.0;\n    vert_spot.y += 0.5*cos(vert_spot.x) - 0.1 *cos(vert_spot.z);\n    vert_spot.z = abs(vert_spot.z);\n    vert_spot.y -= 2.0;\n\tfloat dist_vertebra = min(\n        round_box(vert_spot, vec3(1.5,0.5,1), 0.2),\n        round_box(vert_spot, vec3(6,0.2,0.6), 0.2)\n    );\n    float dist_fused_rib_vert = blend(dist_vertebra, dist_spine, 0.5);\n        \n    vec3 bone_spot = where;\n    //bone_spot.x -= 1.0;\n    bone_spot.x = cmod(bone_spot.x, 4.0);\n    bone_spot.y -= 3.7;\n    float squeeze = 1.0 + 0.2 * cos(bone_spot.x*1.5);\n    bone_spot.yz *= squeeze;\n\tfloat dist_bone = cylinder_x_finite(bone_spot, vec3(0,0,0),0.5,1.499) - 0.5;\n\n    vec3 cable_spot = where;\n    cable_spot.x -=0.5;\n    cable_spot.x = cmod(cable_spot.x, 4.0);\n    cable_spot.y *= 0.93;\n    float stretch = 2.0*cos(cable_spot.z)+3.0;\n    cable_spot.x /= stretch;\n    float cable = torus_x(cable_spot, 4.0, 0.2) * stretch *0.8;\n    dist_bone = blend(dist_bone, cable, 0.5);\n\n    float dist_socket = length(vec2(cable-0.1, dist_spine*2.0+0.1)) - 0.2;\n    \n    vec3 pp = where;\n    pp.z = abs(pp.z);\n    // skinny rod\n    float dist_rod = cylinder_x(pp, vec3(0,cord_height,cord_offset), 0.2);\n    float dist_notched = notched_cord(pp);\n     //notch = 1000.0;\n    //float dist_pipe = min(pipe_pos, notched);\n    float dist_blended = blend(dist_notched, dist_fused_rib_vert, 0.15);\n    vec3 guts_where = where;\n    guts_where.z = cmod(guts_where.z, 4.0);\n    float dist_guts = cylinder_x(guts_where, vec3(0,-3,0), 4.0);\n    \n    \n    if (dist_floor < closest) {\n\t    who = ID_FLOOR;\n        closest = dist_floor;\n    }\n    if (dist_socket < closest) {\n        who = ID_SOCKET;\n        closest = dist_socket;\n    }\n    if (dist_spine < closest) {\n\t    who = ID_SPINE;\n        closest = dist_spine;\n    }\n    if (dist_blended < closest) {\n\t    who = ID_VERTEBRA;\n        closest = dist_blended;\n    }\n    if (dist_rod < closest) {\n        who = ID_ROD;\n        closest = dist_rod;\n    }\n    if (dist_guts < closest) {\n\t    who = ID_GUTS;\n        closest = dist_guts;\n    }\n    if (dist_bone < closest) {\n\t    who = ID_BONE;\n        closest = dist_bone;\n    }\n    if (dist_clip < closest) {\n\t    who = ID_CLIP;\n        closest = dist_clip;\n    }\n    /*\n    if (dist_vertebra < closest) {\n\t    who = ID_VERTEBRA;\n        closest = dist_vertebra;\n    }\n    if (dist_pipe < closest) {\n\t    who = ID_PIPE;\n        closest = dist_pipe;\n    }*/\n    return vec2(closest, who);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = measure( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n/**\n * Figure out coloring for where we hit\n */\nconst vec4 floor_color = vec4(0.18,0.18,0.22,0.0);\nconst vec4 spine_color = vec4(0.3,0.28,0.27,0.0);\nconst vec4 guts_color = vec4(0.5,0.2,0.1,0.0);\nconst vec4 rod_color = vec4(1,0,0,1.0);\nconst vec4 bone_color = vec4(0.6,0.57,0.50,0.0);\nconst vec4 clip_color = vec4(1,1,1,0.0);\nconst vec4 sky = vec4(0,0,0,0);\n\nvec4 paint(vec2 hit, vec3 where) {\n\n    int who = int(hit.y);\n    float ambient = 0.0;\n    if (who == ID_FLOOR) {\n        vec2 w = fract(where.xz);\n        float target = fract(length(where.xz));\n        vec4 tile = vec4(1.0, target*0.5+0.5, target,0);\n        return min(w.x, w.y) > 0.1 ? tile : sky;\n    }\n    if (who == ID_SPINE) {\n        return spine_color;\n    }\n    if (who == ID_VERTEBRA) {\n        return spine_color;\n    }\n    if (who == ID_PIPE) {\n        return spine_color;\n    }\n    if (who == ID_GUTS) {\n        return guts_color;\n    }\n    if (who == ID_ROD) {\n        vec4 rod = rod_color;\n        rod.w = pow(sin(9.0*iTime-where.x),2.0);\n        return rod;\n    }\n    if (who == ID_BONE) {\n        return bone_color;\n    }\n    if (who == ID_SOCKET) {\n        return spine_color;\n    }\n    if (who == ID_CLIP) {\n        return clip_color;\n    }\n    return sky;\n}\n\n/**\n * Ray marching parameters for this scene\n */\nconst int   MAX_STEPS = 1000;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst float STEP_RATIO = 0.25;\n\nvec3 calc_surface_normal(vec3 hit);\n\n\n/**\n * main entrypoint\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(sin(iTime*0.31)*10.0+5.0,\n                    sin(iTime*0.22)*10.0+14.0,\n                    cos(iTime*0.13)*10.0-15.0);\n    vec3 look_at = vec3(0,3,0);\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    for(int steps =0;steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0,0,0);\n    if (who == 0){\n        fragColor = vec4(fog_color, 1.0);\n        return;\n    }\n\tvec3 hit = where;\n    vec4 the_paint = paint(current, where);\n    vec3 to_light = normalize(vec3(-10,5,-1));\n    float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    vec3 surface_normal = calc_surface_normal(hit);\n    float dotty = dot(to_light, surface_normal);\n    float light_amount = max(0.0, dotty);\n    float light_fade = 1.0;\n    float ambient = the_paint.w;\n    float lighting = ambient + (1.0-ambient) * \n        (shadow*0.5 * (1.0 + light_amount * light_fade));\n\n\tvec3 coloring = light_fade *(the_paint.xyz * lighting)\n        + fog_color * (1.0-light_fade);\n    vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    vec3 toEye = normalize(-ray);\n\tfloat specular = pow(max(0.0, dot(toEye, reflected)), 32.0);\n\tcoloring += vec3(specular, specular, specular);\n    fragColor = vec4(coloring,1.0);\n}\n\n#define NORMAL_DELTA 0.001\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}","name":"Common","description":"","type":"common"}]}