{"ver":"0.1","info":{"id":"MslyRr","date":"1486852157","viewed":696,"name":"Dragon egg","username":"nomadiclizard","description":"Voronoi cells on a fibonacci sphere. Isotropic without any distortion at poles due to regular distribution of fib points and use of spherical distances. Colouring by summing functions of cell index gives lovely spirals :3","likes":14,"published":1,"flags":1,"usePreview":0,"tags":["3d","voronoi","fibonacci"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// voronoi cells on a fibonacci sphere\n// looks like a magical dragon egg rawr!\n\n#define pi 3.14159265359\n#define twoPi 6.28318530718\n#define halfPi 1.57079632679\n#define infinity 100.0\n#define phi 1.61803398875\n#define phiMinusOne 0.61803398875\n#define twoPiOnPhi 3.88322207745\n#define root5 2.2360679775\n#define logPhiPlusOne 0.96242365011\n\n// egg definition and colouring\nconst float maxn = 2500.0;\nconst float growtime = 5.0;\nconst bool convex = true;\nconst float f1 = 856.0, s1 = 3.0, a1 = 0.15;\nconst float f2 = 335.0, s2 = 2.0, a2 = 0.10;\n\n// SIMPLE STUFF THAT WOULD BE COOL IF WEBGL HAD IN A STANDARD LIBRARY :V\n\nvec3 lookat(vec3 p1, vec3 p2)\n{\n    return normalize(p2 - p1);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec4 rotationQuat(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float c = cos(0.5 * angle);\n    float s = sqrt(1.0 - c * c);\n    return vec4(axis.x * s, axis.y * s, axis.z * s, c);\n}\n\nvec3 rotate(vec3 p, vec4 q)\n{\n\treturn p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    return rotate(p, rotationQuat(axis, angle));\n}\n\nmat4 translationMatrix(vec3 p)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\nmat4 scaleMatrix(float s)\n{\n    return mat4(s,   0.0, 0.0, 0.0,\n                0.0, s,   0.0, 0.0,\n                0.0, 0.0, s,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// INVERSE SPHERICAL FIBONACCI MAPPING\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping.pdf\n\n// k'th fibonacci number\nfloat calcfk(float k)\n{\n\treturn round(pow(phi, k) / root5);\n}\n\n// calculates a basis vector for fibonacci sphere n\nvec2 calcbk(float fk, float n)\n{\n    return vec2(twoPi * fract((fk + 1.0) * phiMinusOne) - twoPiOnPhi,\n                -2.0 * fk / n);\n}\n\n// calc point i of n in spherical coordinates\nvec2 calcpoint(float i, float n)\n{\n    return vec2(twoPi * fract(i * phiMinusOne),\n                1.0 - (2.0 * i + 1.0) / n);\n}\n\n// converts [phi,cos theta] into [x,y,z] for unit sphere\nvec3 s2c(vec2 s)\n{\n    float sinTheta = sqrt(1.0 - s.y * s.y);\n    return vec3(cos(s.x) * sinTheta,\n                sin(s.x) * sinTheta,\n                s.y);\n}\n\n// converts [x,y,z] into [phi, cos theta] for unit sphere\nvec2 c2s(vec3 c)\n{\n    return vec2(atan(c.y, c.x),\n                c.z);\n}\n\n// angle between two points in spherical coords\nfloat angdist(vec2 sp1, vec2 sp2)\n{\n    float sinTheta1 = sqrt(1.0 - sp1.y * sp1.y);\n    float sinTheta2 = sqrt(1.0 - sp2.y * sp2.y);\n    return acos(sp1.y * sp2.y + sinTheta1 * sinTheta2 * cos(sp2.x - sp1.x));\n}\n\n// calculate new point [phi, cos theta] if walking point sp on bearing ib distance d\nvec2 gcircle(vec2 sp, float ib, float d)\n{\n    float cosd = cos(d);\n    float sind = sin(d);\n    float sinTheta1 = -sp.y;\n    float cosTheta1 = sqrt(1.0 - sp.y * sp.y);\n    float sinTheta2 = sinTheta1 * cosd + cosTheta1 * sind * cos(ib);\n    float theta2 = asin(sinTheta2);\n    float phi2 = sp.x + atan(sin(ib) * sind * cosTheta1, cosd - sinTheta1 * sinTheta2);\n    return vec2(mod(phi2, twoPi), cos(theta2 + halfPi));\n}\n\n// 0..1 for seed x\nfloat random(float x)\n{\n    return fract(abs(sin(x * 12.9898) * 43758.5453));\n}\n\n// distance to nearest cell on a fibonacci sphere\nfloat fibspheren(vec3 p, float n, out float minidx, out vec3 sn)\n{\n    // get spherical coords for point p on surface of unit sphere\n    vec2 sp = c2s(p);\n    float avdist = sqrt(4.0 * pi / n);\n    \n    // calc the dominant zone number\n    float k = max(2.0, floor(log(root5 * n * pi * (1.0 - sp.y * sp.y)) / logPhiPlusOne));   \n    \n    // calc basis vectors for this zone\n    // [could all be precalculated and looked up for k,n]\n    vec2 f = vec2(calcfk(k), calcfk(k + 1.0));\n    vec2 bk = calcbk(f[0], n);\n    vec2 bk1 = calcbk(f[1], n);\n    mat2 b = mat2(bk, bk1);\n    mat2 invb = inverse(b);\n    \n    // change of basis for point sp to local grid uv\n    float z0 = 1.0 - 1.0 / n;\n    vec2 c = floor(invb * (sp - vec2(0.0, z0)));\n    \n    // for k<=4 paper suggests using (-1,0,+1)^2 offset factors but we'll\n    // stick with (0,1)^2 and live with the occasional glitches\n    float mindist = pi;\n    vec2 minisp;\n    for (int s = 0; s < 4; s++) {\n        // figure out the point index and generate fib point\n        vec2 o = vec2(s - (s/2) * 2, s / 2);\n        float idx = dot(f, c + o);\n        if (idx > n) continue;        \n        vec2 isp = calcpoint(idx, n);\n        \n        // walk on a random bearing a random distance to make cells move a bit\n        //float b = mod((-0.05 + 0.1 * random(idx + 42.39)) * iTime, twoPi);\n        //float d = dist * random(idx + 28.93) * cos((-0.5 + 1.0 * random(idx + 42.39)) * iTime);\n        //isp = gcircle(isp, b, d);\n        \n        // closest?\n        float dist = angdist(isp, sp);\n        if (dist < mindist) {\n\t\t\tmindist = dist;\n            minidx = idx;\n            minisp = isp;\n        }\n    }\n    \n    // use nearest point to calculate surface normal via rotation around cotangent from p -> ip\n    // ohhhh wow I can make keeled scales real easy if dist varies by direction!\n    vec3 ip = s2c(minisp), cotan;\n    if (convex) {\n        cotan = cross(ip - p, p);\n    } else {\n        cotan = cross(p - ip, p);\n    }\n    sn = rotate(p, cotan, mindist / avdist);\n    return mindist;\n}\n\n// view stuff\nconst float fov = radians(50.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\n// calculates intersection parameters for a ray through a sphere at sp radius r\n// return true if the halfray ro + t1.rd is hitting\nbool spherehit(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)\n{\n    vec3 rosp = ro - sp;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, rosp);\n    float c = dot(rosp, rosp) - (r * r);\n    float b2m4ac = b * b - 4.0 * a * c;\n    if (b2m4ac >= 0.0) {\n        float r = sqrt(b2m4ac);\n        t1 = (-b - r) / (2.0 * a);\n        t2 = (-b + r) / (2.0 * a);\n        return t1 >= 0.0 || t2 >= 0.0;\n    } else {\n        return false;\n    }\n}\n\n// black -> white via red and yellow for 0,1\nvec4 falsecolourr(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\n// black -> white via green and cyan for 0,1\nvec4 falsecolourg(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd)\n{\n    // number of points in fibsphere\n    float n = pow(2.0, log(maxn) / log(2.0) * smoothstep(0.0,1.0,iTime / growtime)); \n    \n    // fibsphere location and size\n    vec3 sp = vec3(0.0, 0.0, -2.0);\n    float sr = pow((n / maxn), 0.333) * (1.0 + 0.01 * cos(iTime));\n    \n    // mouse rotates it\n    float r1 = (iMouse.x / iResolution.x - 0.5) * twoPi;\n    float r2 = (iMouse.y / iResolution.y - 0.5) * twoPi;\n    r1 += iTime * 0.25;\n    \n    // transform and inverse matrices\n    mat4 ms = scaleMatrix(1.0 / sr) *\n              translationMatrix(-sp);\n    mat4 mr = rotationMatrix(forward, -r1) *\n              rotationMatrix(right, -r2);\n    mat4 mmr = rotationMatrix(right, r2) *\n        \t   rotationMatrix(forward, r1);\n    \n    // check if an intersection is possible (in world space)\n    float t1, t2;\n    if (spherehit(sp, sr, ro, rd, t1, t2)) {\n        vec4 wp = vec4(ro + t1 * rd, 1.0);\n    \t// calculate hit of fibsphere (back in model space)\n        vec3 mp = vec3(mr * ms * wp), msn;\n        float idx, ir = fibspheren(mp, n, idx, msn);\n        \n        // surface normal back in world coords\n        vec3 sn = vec3(mmr * vec4(msn, 1.0));\n        \n        // colour it all pretty - similar to adding octaves of noise\n        // overlaying lots of waves gives it a cool mesmerising effect\n        float vrange = 0.5 + a1 * cos(f1 * (idx / maxn) + s1 * iTime) +\n            \t\t\ta2 * cos(f2 * (idx / maxn) + s2 * iTime);\n        vec4 c = falsecolourg(vrange, 1.3);\n        \n        // light it up like a bossss\n        float light = 0.9 * pow(dot(-forward, sn), 2.0);\n        fragColor = c * light;\n    } else {\n        fragColor = 0.3 + 0.3 * vec4(fragCoord.y / iResolution.y);\n    }\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd)\n{\n    // the VR version does it for us\n    render(fragColor, fragCoord, ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // figure out where to look\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = lookat(ro, vec3(uv.x * tan(fov), uv.y * tan(fov), -1.0));\n    render(fragColor, fragCoord, ro, rd);\n}","name":"Image","description":"","type":"image"}]}