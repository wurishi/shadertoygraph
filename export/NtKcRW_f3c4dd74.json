{"ver":"0.1","info":{"id":"NtKcRW","date":"1661038015","viewed":99,"name":"black and white square flower","username":"sachatouille","description":"square,petal,flower,black,white,inversion,noise,random","likes":3,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec2 _st = st;\n   \n    st.x *= iResolution.x/iResolution.y;\n    st.x-=0.39;\n\n    vec3 color = vec3(0.0);\n    st -= vec2(0.5);\n    st = rotate2d( (sin(iTime*3.14 )/(3.14) + iTime -0.5 ) * pow(floor(distance(vec2(0.),vec2(st.x))*6.+2.),0.200)* pow(floor(distance(vec2(0.),vec2(st.y))*6.+2.),0.200)*1.)*st;\n    st += vec2(0.5);\n    float c1= circle(vec2(st),0.1 +abs(sin(snoise(st/0.120))));\n\tvec2 shade = repetition(st,vec2(6.));\n    color = vec3(c1);\n    float shading = (shade.x * sign(_st.x-0.5) + 1. * step(_st.x,0.5))*(shade.y * sign(_st.y-0.5) + 1. * step(_st.y,0.5)) ;\n\tcolor *= shading;\n    \n\tfloat inversion = sin(iTime/2.)*1.5 +0.5 + snoise(st*10.)*_st.y ;\n    inversion = step(inversion,0.5);\n    \n    color = vec3(color *inversion + (1. - color) * (1.- inversion));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n\nfloat random (in vec2 _st, float variation) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        (43757.969 + variation +_st.x));\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle), -sin(_angle),\n               sin(_angle),cos(_angle));\n}\nvec2 repetition(vec2 _st, vec2 _scale){\n    return\tfract(_st*_scale);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n\n    \n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n   \n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n  \n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n \n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.02),\n                         dot(dist,dist)*4.);\n}","name":"Common","description":"","type":"common"}]}