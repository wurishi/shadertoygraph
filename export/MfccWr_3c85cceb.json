{"ver":"0.1","info":{"id":"MfccWr","date":"1731798399","viewed":50,"name":"Cellnoise variants","username":"stegu","description":"Testing hashes for a cellnoise() implementation. Hoskins' version is surprisingly good for this purpose.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["random","cellnoise","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The infamous \"fract-sin hash\", an abusive hack that works only by accident\nfloat sin_hash( float x ) {\n    return fract( sin( floor(x) * 12.9898 ) * 43758.5453 );\n}\n\n// A horrible cellnoise that works only by accident, and not very well\nfloat cellnoise_sin( vec2 p ) {\n    return fract( sin( dot( floor(p), vec2(12.9898, 78.233) ) ) * 43758.5453 );\n}\n\n// A still-horrible but not quite as bad looking cellnoise\nfloat cellnoise_sin2( vec2 p ) {\n    return sin_hash( sin_hash( p.x ) * 78.233 + floor(p.y) );\n}\n\n// One of Dave Hoskins' \"sin-less\" fract hashes,\n// taken from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// A surprisingly good cellnoise using Hoskin's \"hash12\"\nfloat cellnoise_hoskins( vec2 p ) {\n    return hash12(floor(p));\n}\n\n// A somewhat low quality but fast and mostly adequate cellnoise\nfloat cellnoise_perm(vec2 p) {\n    p = mod(floor(p), 289.0);\n    float hash = mod((p.x*34.0 + 10.0)*p.x + p.y, 289.0);\n    return mod((hash*34.0 + 10.0)*hash, 289.0) / 289.0;\n}\n\n// A good hash function, but fast only with good integer support\nuint pcg_hash(uint seed)\n{\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\n// A great cellnoise by two nested calls to pcg_hash\nfloat cellnoise_pcg2(vec2 p) {\n\tuvec2 pu = uvec2( ivec2( floor( p ) ) & ivec2( 0x7FFFFFFF ) );\n\treturn float( pcg_hash( pu.x + pcg_hash( pu.y) ) & 0xFFFFu ) / 65536.0;\n}\n\n// Still great cellnoise by one call to pcg_hash with ad-hoc combo of x and y\nfloat cellnoise_pcg(vec2 p) {\n\tuvec2 pu = uvec2( ivec2( floor(p) ) & ivec2( 0x7FFFFFFF ) );\n\treturn float( pcg_hash( pu.x + pu.y * 289u) & 0xFFFFu) / 65536.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.x;\n    float x6 = p.x * 6.0;\n    p = p*300.0;\n\n    float n;\n\n    if(x6 < 1.0)\n        n = cellnoise_sin(p);\n    else if(x6 < 2.0)\n        n = cellnoise_sin2(p);\n    else if (x6 < 3.0)\n        n = cellnoise_hoskins(p);\n    else if (x6 < 4.0)\n        n = cellnoise_perm(p);\n    else if (x6 < 5.0)\n        n = cellnoise_pcg2(p);\n    else\n        n = cellnoise_pcg(p);\n\n    float lines = step(-0.02,x6-1.0)-step(0.02,x6-1.0);\n    lines += step(-0.02,x6-2.0)-step(0.02,x6-2.0);\n    lines += step(-0.02,x6-3.0)-step(0.02,x6-3.0);\n    lines += step(-0.02,x6-4.0)-step(0.02,x6-4.0);\n    lines += step(-0.02,x6-5.0)-step(0.02,x6-5.0);\n    n = max(n, lines);\n\n    vec3 col = vec3(n);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}