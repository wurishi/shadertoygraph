{"ver":"0.1","info":{"id":"NslfWs","date":"1645554896","viewed":137,"name":"Signed Distance Propagation","username":"tdhooper","description":"Find the distance to the 0.5 threshold of a monochrome texture, with the cost spread across several frames.\n\n[url=https://store.steampowered.com/news/app/1671410/view/3693562733652084110]This was used for the sediment in Somerville[/url]","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["floodfill","jumpflood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Signed Distance Propagation\n    ---------------------------\n    \n    Find the distance to the 0.5 threshold of a monochrome texture.\n    \n    Usually you'd use the Jump Flood Algorithm for this, however\n    you need to run it a few times before you get a usable result.\n    My use case is a dynamic 3d texture, and JFA is a bit expensive\n    to run several times a frame.\n    \n    This approach calculates the distance with a simple flood fill\n    that spreads the cost over several frames. Faraway distances take\n    a good few frames to be calculated, but that's okay if your source\n    texture only changes slowly.\n    \n    It's not accurate, notice the bulging in the cardinal directions,\n    but good enough for my needs.\n    \n    Buffer A - Source Texture\n    Buffer B - Propagate Distance\n\n*/\n\nfloat smoothFract(float t, float fw)\n{\n    float tw = 1. - (fract(t + .5) - .5) / fw;\n    float tf = fract(t);\n    return tf < .5 ? max(tf, tw) : min(tf, tw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0); return; // show source\n\n    float fill = texelFetch(iChannel0, ivec2(fragCoord), 0).r;\n    fill -= .5;\n    \n    float fw = fwidth(length(fragCoord));\n    vec3 col = mix(vec3(0.2,0.5,0.8), vec3(0.6,0.2,0.8), smoothstep(fw, 1. - fw, fill));\n    col *= 1. - smoothFract((abs(fill) + 2. / fw ) / 30., fw / 30.) * .95;\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n    Source Texture\n    --------------\n    \n    This is what we want calculate distances for, 0 is inside, 1 is outside\n\n*/\n\n\n// Voronoi from iq https://www.shadertoy.com/view/ldl3W8\n\n#define ANIMATE\n//#define DRAW\n\nvec2 hash2( vec2 p )\n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( .1 * iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    return mr;\n}\n\n#ifndef DRAW\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx;\n\n    float scale = 4.;\n    vec2 c = voronoi( scale * p ) / scale;\n    \n    float d = length(c) - .1;\n    \n    float fw = fwidth(length(p));\n    \n    d = clamp(d / fw, 0., 1.); // smooth edges\n    //d = step(.5, d); // hard edges\n    \n\tfragColor = vec4(d, 0, 0, 0);\n}\n\n#else\n\n// Drawing version\n// Click to draw, shift + click to erase.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n\n    float fill = 1.;\n\n    if (iFrame > 0)\n    {\n        fill = texelFetch(iChannel0, coord, 0).r;\n\n        vec2 p = (fragCoord - iResolution.xy * .5) / iResolution.y;\n        vec2 m = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n\n        bool down = iMouse.z >= 0.;\n        if (down && length(p - m) < .1) {\n            float shiftDown = texelFetch(iChannel1, ivec2(16,0), 0).x;\n            fill = shiftDown;\n        }\n    }\n\n    fragColor = vec4(fill,0,0,0);\n}\n\n#endif","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\n    Propagate Distance\n    ------------------\n    \n    Using the texture from BufferA as a source, flood-fill the\n    distance to the boundary.\n\n*/\n\nconst float distanceLimit = 200.;\n\nfloat propagateDistance(ivec2 coord, float source) {\n    \n    // Preserve values in this range, this is our boundary\n    if (source > 0. && source < 1.)\n    {\n        return source;\n    }\n\n    // Positive for inside, negative for outside\n    float positiveDistance = distanceLimit;\n    float negativeDistance = -distanceLimit;\n\n    // Do a flood fill step, where we propogate a distance\n    // from the 0.5 threshold\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            if (x == 0 && y == 0 )\n            {\n                continue;\n            }\n            \n            ivec2 offset = ivec2(x, y);\n            ivec2 neighborCoord = coord + offset;\n            \n            if (\n                neighborCoord.x < 0 ||\n                neighborCoord.y < 0 ||\n                neighborCoord.x >= int(iChannelResolution[1].x) ||\n                neighborCoord.y >= int(iChannelResolution[1].y)\n            )\n            {\n                continue;\n            }\n                \n\n            float neighborFill = texelFetch(iChannel1, neighborCoord, 0).r;\n            float neighbourDistance = length(vec2(offset));\n            positiveDistance = min(positiveDistance, max(1., neighborFill + neighbourDistance));\n            negativeDistance = max(negativeDistance, min(0., neighborFill - neighbourDistance));\n        }\n    }\n    \n    // If a value is outside the 0-1 range, set its value to our\n    // estimated distance from the 0.5 threshold\n                \n    // Cells that are already outside will get the positive max distance,\n    // cells that are already inside get the negative min distance\n    \n    float result = source;\n    \n    \n    if (result >= 1.)\n    {\n        result = positiveDistance;\n    }\n\n    if (result <= 0.)\n    {\n        result = negativeDistance;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n\n    float result = distanceLimit;\n\n    if (iFrame > 0)\n    {\n        float source = texelFetch(iChannel0, coord, 0).r;\n        result = propagateDistance(coord, source);\n    }\n    \n    fragColor = vec4(result,0,0,0);\n}","name":"Buffer B","description":"","type":"buffer"}]}