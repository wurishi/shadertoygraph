{"ver":"0.1","info":{"id":"7d2GRt","date":"1641577667","viewed":125,"name":"Fork wave simul racon 197","username":"racon","description":"controls: q,e,d,r,a,click\nq : toggle wave generator;\ne : toggle view mode (wave / energy views)\nd : toggle 2nd view mode (energy / frequency view)\nr : reset\na : reload seed\nclick : move the yellow wave graph\nversion 2","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["sim"],"hasliked":0,"parentid":"ttGBDy","parentname":"wave simulator by racon"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//optional overlays (e.g.yellow graph)\nint getGraphY(in ivec2 c){\n    return int((texelFetch(iChannel0,c,0).w-0.5)*100.);\n}\nfloat getDistToYaxisGraph(in vec2 fragCoord,vec2 drawPosVec2){\n    ivec2 iv=ivec2(fragCoord);\n    ivec2 drawPos=ivec2(drawPosVec2);\n    int pos=drawPos.x+int(mod(float(iFrame),2.));//modulo the wave-frequency\n    int val;\n    ivec2 range;\n    bool first=true;//[min,max]\n    for(int x=0;x<2;x++){\n        val=getGraphY(ivec2(pos,iv.y+x));\n        if(first){first=false;range=ivec2(val);}\n        else range=ivec2(min(range.x,val),max(range.y,val));\n    }\n    int magnitude=(range.x+range.y)/2;\n    iv-=drawPos;\n    return float(abs(iv.x)-magnitude);\n}\nfloat getDistToXaxisGraph(in vec2 fragCoord,vec2 drawPosVec2){\n    ivec2 iv=ivec2(fragCoord);\n    ivec2 drawPos=ivec2(drawPosVec2);\n    int pos=drawPos.y+int(mod(float(iFrame),2.));//modulo the wave-frequency\n    int val;\n    ivec2 range;\n    bool first=true;//[min,max]\n    for(int x=0;x<2;x++){\n        val=getGraphY(ivec2(iv.x+x,pos));\n        if(first){first=false;range=ivec2(val);}\n        else range=ivec2(min(range.x,val),max(range.y,val));\n    }\n    int magnitude=(range.x+range.y)/2;\n    iv-=drawPos;\n    return float(abs(iv.y)-magnitude);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv2=fragCoord/iChannelResolution[0].xy;\n    ivec2 iv=ivec2(fragCoord);\n    vec4 col=texelFetch(iChannel0,iv,0);\n    ivec2 drawPos=ivec2(iMouse.xy); //ivec2(400,200);\n    if(\n        getDistToXaxisGraph(fragCoord,iMouse.xy)<0.\n        ||\n        getDistToYaxisGraph(fragCoord,iMouse.xy)<0.\n    ){//if(iv.x>=range.x&&iv.x<=range.y){\n        fragColor=vec4(0.8,0.8,0.1,1.);\n    }\n    else{\n        fragColor=vec4(col.xyz*0.8,1.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//process wave\n//cell=[mass,velocity,friction,damping]\nvec2 uv;\nvec4 getTPos(vec2 add){\n    vec4 t=texture(iChannel0,clamp(uv+add/iResolution.xy,vec2(0.0),vec2(1.0)));\n    t=clamp(t,vec4(0.00001),vec4(0.99999));\n    return getPos(t);\n}\nvec4 cellA;\nvec4 object;\nfloat dt=1.0;\nconst float sumOfDists2=(38.0+15.0*sqrt(2.0))/5.0;//~11.84264\nvec4 doCellSim(vec2 neighbourPos){//diffuse\n    vec4 cellBTemp=getTPos(neighbourPos);\n    //if(cellBTemp==vec4(0.0))return vec4(0.0);\n    vec4 cellB=(cellBTemp);\n    float move=(cellB.x-cellA.x)/sqrt(dot(neighbourPos,neighbourPos));\n    move*=object.z*4.5/sumOfDists2;//*6.8/9.0;\n    float d=object.w;\n    return vec4(move/8.0*d,move/2.0*(1.0-d),0.0,0.0);//*cellA;\n}\nvec2 wave(float t,float mul){return vec2(sin(t*mul),cos(t*mul)*mul);}\nvec2 wave_white(float t,float mul){return vec2(sign(sin(t*mul)),sign(cos(t*mul)*mul));}\nvec2 waveEquation(float t){\n    float amp=1.;\n    float period=1.;//wave period = 1/frequency\n    t=t/period;//current phase\n    //t=mod(t,1.);\n    //t=clamp(t,0.,1.);\n    t*=tau;\n    vec2 w;float m=4.,s=0.1;for(float i=1.;i<=m;i+=s)w+=wave(t,s)*s;w*=s/m;\n    return amp*(\n        wave(t,1./3.5)\n        //+wave(t,1./8.)\n        //+wave(t,1./16.)\n        //wave_white(t,1./16.)\n    )/vec2(1.,period*tau);\n}\nvec2 onClickWave(vec2 fragCoord){\n    float time=float(iFrame)*dt;\n    return vec2(waveEquation(time));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    object = texelFetch(iChannel2,ivec2(fragCoord),0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 res=iResolution.xy;\n    uv = fragCoord/iResolution.xy;\n    cellA =getTPos(vec2(0.0,0.0));\n    vec4 temp=texelFetch(iChannel0,ivec2(fragCoord),0);\n    //onReset(press 'r') => make all black and reset all\n    if(texelFetch(iChannel1,ivec2(82,0),0).x==1.0)temp=vec4(0.0);\n    //onReload (press 'a') =>{make edge and circle}\n    if(dot(temp,temp)==0.0||texelFetch(iChannel1,ivec2(65,0),0).x==1.0){\n        if(dot(temp,temp)==0.0)cellA=vec4(0.0,0.0,1.0,0.0);\n        if(cellA.z!=0.0)cellA.xy/=cellA.z;else cellA.xy=vec2(0.0);\n        cellA.xy*=cellA.z;\n        fragColor=setPos(cellA);\n        return;\n    }\n    vec4 sum;{sum = (\n        doCellSim(vec2(-1.0,-1.0))\n        +doCellSim(vec2(-1.0, 1.0))\n        +doCellSim(vec2( 1.0,-1.0))\n        +doCellSim(vec2( 1.0, 1.0))\n        +doCellSim(vec2( 0.0,-1.0))\n        +doCellSim(vec2( 0.0, 1.0))\n        +doCellSim(vec2(-1.0, 0.0))\n        +doCellSim(vec2( 1.0, 0.0))\n        \n        + //doCellSim(vec2(-2.0,-2.0))+\n            doCellSim(vec2(-2.0,-1.0))+\n            doCellSim(vec2(-2.0, 0.0))+\n            doCellSim(vec2(-2.0, 1.0))\n        + //doCellSim(vec2(-2.0, 2.0))+\n            doCellSim(vec2(-1.0, 2.0))+\n            doCellSim(vec2( 0.0, 2.0))+\n            doCellSim(vec2( 1.0, 2.0))\n        + //doCellSim(vec2( 2.0, 2.0))+\n            doCellSim(vec2( 2.0, 1.0))+\n            doCellSim(vec2( 2.0, 0.0))+\n            doCellSim(vec2( 2.0,-1.0))\n        + //doCellSim(vec2( 2.0,-2.0))+\n            doCellSim(vec2( 1.0,-2.0))+\n            doCellSim(vec2( 0.0,-2.0))+\n            doCellSim(vec2(-1.0,-2.0))\n    );}\n    //toggle sine wave (click or 'q')\n    if(!(iMouse.z>0.0&&false ^^ texelFetch(iChannel1,ivec2(81,2),0).x==1.0)){//onClick\n        float lineSize=20.;\n        vec4 col=vec4(0.5); \n        vec2 dif=vec2(borderSize+2.,iResolution.y/2.+0.*184.)-fragCoord;//iMouse.xy-fragCoord;\n        dif.y=max(0.0,abs(dif.y)-lineSize);\n        if(dot(dif,dif)<1.0){\n            cellA.xy=onClickWave(fragCoord).xy;//can use \".xy\";\n            fragColor = setPos(cellA);return;\n        }\n    }\n    float acceleration=sum.y*dt*dt;\n    sum=sum*dt*dt+cellA;\n    sum.y*=(1.0-0.4*sum.w);\n    sum.x/=(1.0+0.002*sum.w);\n    sum.x+=sum.y;\n    sum.z=acceleration;\n    //sum.z=sum.z+0.1*(0.0-sum.z+1.0/(1.0+0.4*abs(sum.x)));\n    sum=setPos(sum);\n    fragColor=sum;//fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//SETTINGS:\n    const float borderSize = 40.;\n//----\nconst float tau=4.0*asin(1.0);\n\nvec4 setPos(vec4 cell){return vec4(1.0)/(vec4(1.0)+(exp(-cell)));}\nvec3 setPos(vec3 cell){return vec3(1.0)/(vec3(1.0)+(exp(-cell)));}\nvec2 setPos(vec2 cell){return vec2(1.0)/(vec2(1.0)+(exp(-cell)));}\nfloat setPos(float cell){return 1.0/(1.0+(exp(-cell)));}\nvec4 getPos(vec4 cell){return -log(vec4(1.0)/cell-vec4(1.0));}\nvec3 getPos(vec3 cell){return -log(vec3(1.0)/cell-vec3(1.0));}\nvec2 getPos(vec2 cell){return -log(vec2(1.0)/cell-vec2(1.0));}\nfloat getPos(float cell){return -log(1.0/cell-1.0);}\nfloat len(vec2 a){return sqrt(dot(a,a));}\nfloat lenh(vec2 a){return sqrt(abs(a.x*a.x-a.y*a.y));}\nvec2 wave(float time,float period,float amplitude,float phase){\n    return amplitude*vec2(\n        (sin(time/period*tau)),\n        (cos(time/period*tau))/period\n    );\n}\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n    return hsl2rgb(vec3(h, s, l));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//process world objects\n//cell = [friction,damping]\nvec2 getObjects(vec2 fragCoord){\n    vec2 c;\n    vec2 c1;\n    vec2 res=iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    if(false){//double slit\n        c1=fragCoord-vec2(40,res.y/2.);\n        const float rot=tau*(-0.0/8.0);\n        float width = res.y/8.;\n        float separation = res.y/32.;\n        c1*=mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n        if(abs(abs(c1.y)-separation-width)-width>0.){\n            if(abs(c1.x)<1.)return vec2(0.,0.0);\n            float apsorbsionWidth=8.;\n            if(c1.x<0.&&abs(c1.x)<apsorbsionWidth)return vec2(1.,.84);\n        }\n    }\n    if(false){//single slit\n        c1=fragCoord-vec2(50,res.y/2.);\n        const float rot=tau*(-0.0/8.0);\n        float width = res.y/8.;\n        c1*=mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n        if(abs(c1.y)-width>0.){\n            if(abs(c1.x)<1.)return vec2(0.,0.0);\n            float apsorbsionWidth=8.;\n            if(c1.x<0.&&abs(c1.x)<apsorbsionWidth)return vec2(1.,.84);\n        }\n    }\n    if(false){//Penrose \"unilluminable\" room\n        vec2 center=vec2(res.x/2.,res.y/2.);\n        c1=fragCoord-center;\n        c1=abs(c1);\n        float squareLen=center.y*0.2;\n        float ellipseLen=center.x*0.2;\n        vec2 focalPoint=vec2(center.x*0.8,squareLen);\n        float dist=length(c1-focalPoint)+length(c1-focalPoint*vec2(-1.,1.));\n        ellipseLen+=length(focalPoint.x*2.);\n        dist-=ellipseLen;//ellipse sum length\n        vec2 boxes=vec2(c1.x-ellipseLen/2.+squareLen,c1.y-squareLen/2.);\n        float boxes2Len=squareLen*0.8;\n        bool boxes2=boxes.x<0.&&boxes.x+boxes2Len>0.\n            &&boxes.y<squareLen*cos(boxes.x/boxes2Len*tau*0.25);\n        if(dist>0.\n            &&(c1.x>ellipseLen/2.||c1.y>squareLen)\n            ||(boxes.x>0.&&boxes.y<0.)\n            ||boxes2\n        ){\n            return vec2(0.,0.);\n        }\n    }\n    if(false){//coloured object\n        c1=fragCoord-vec2(300,res.y/2.);\n        const float rot=tau*(-1./8.0);\n        const float size = 80.;\n        const float grateSize = 6.;\n        const float velocity = 0.72;\n        float width = res.y/8.;\n        float separation = res.y/32.;\n        c1*=mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n        if(c1.x>0.&&c1.x<size){\n            if(c1.x<3.){\n                if(mod(c1.y,grateSize)<2.)return vec2(0,0);\n                else return vec2(1.,0);\n            }\n            else if(c1.x<6.){\n                return vec2(velocity,0.0);\n            }\n            //return vec2(1.,c1.x/size*0.5);\n        }\n    }\n    if(false){//prism\n        const float size = 100.;\n        c1=fragCoord-vec2(110,res.y/2.+50.-size*0.5);\n        const float rot=tau*(0./8.0);\n        c1.x=abs(c1.x);\n        if(c1.x*sqrt(2.)*1.5<size-c1.y&&c1.y>-size/2.)return vec2(0.8,0.);\n    }\n    if(false){//many slits{\n        c1=fragCoord-vec2(200,144);\n        const float rot=tau*(-1.7/8.0);\n        const float depth = 10.0;\n        const float gapSize = 16.0;\n        c1*=mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n        //if(abs(c1.x+depth*2.0)<depth/2.0)return vec2(0.1,0.0);\n        //c1=vec2(c1.x,);\n        c1.y-=30.;\n        if(c1.x>0.0&&(c1.x-=3.0)<0.0)if(mod(c1.y,gapSize)<1.0)return vec2(0.0,0.0);\n        //if(c1.x>0.0&&(c1.x-=2.0)<0.0)return vec2(0.6,0.0);\n        //if(c1.x>0.0&&(c1.x-=2.0)<0.0)if(mod(c1.y-=0.0,10.0)>4.)return vec2(0.0,0.0);\n        //if(c1.x>0.0&&(c1.x-=2.0)<0.0)return vec2(0.6,0.0);\n    }\n    if(false){//rough surface\n        c1=fragCoord-vec2(400,144);\n        const float rot=tau*(1./8.0);\n        c1*=mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n        float x = c1.y;\n        if(abs(c1.x)<3.7*(1.+(2.+sin(2.*x)+sin(tau/6.*x))/4.))return vec2(0.0,0.0);\n    }\n    if(false){//circle objects\n        c1=fragCoord-vec2(200.,res.y/2.);\n        c1.y=abs(c1.y)-30.;\n        c1.x/=1.;\n        float x=.0;//float[](.5,1.)[max(0,int(mod(length(c1)/2.,2.)-0.2))];\n        float len=length(c1);\n        //x=1.-(1.-x)/2.*(1.+sin(len));\n        if(length(c1)<20.)return vec2(x,0.7);\n    }\n    if(false){//eye\n        c1=fragCoord-vec2(300,res.y/2.);\n        c1.y*=0.8;\n        float lensSize=50.;\n        {//circle lens\n            float x=0.8;//float[](.5,1.)[max(0,int(mod(length(c1)/2.,2.)-0.2))];\n            float len=length(c1);\n            //x=1.-(1.-x)/2.*(1.+sin(len));\n            if(length(c1)<lensSize)return vec2(x,0.);\n        }\n        {//wall\n            vec2 c2=c1+vec2(5.,0);\n            float wallWidth=7.;\n            if(abs(c2.x)<1.)return vec2(0,0);\n            if(abs(c2.x)<wallWidth)return vec2(0.8,0.+.6*max(0.,abs(c2.x)/wallWidth));\n        }\n        if(false){//light catcher\n            vec2 c2=c1;\n            c2.x=fragCoord.x-480.;\n            float wallWidth=20.;\n            if(abs(c2.x)<wallWidth)if(mod(c1.y,4.0)>2.)return vec2(0.0,0.0);\n        }\n    }\n    if(false){//gradient glass\n        c1=fragCoord-vec2(200,res.y/2.);\n        const float rot=tau*(-0.0/8.0);\n        const float depth = 10.0;\n        c1*=mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n        c1.y=abs(c1.y);\n        float len=250.;\n        float target=0.1;\n        float targetWidth=10.;\n        c1.x=abs(c1.x-len)-targetWidth;\n        //if(c1.x<0.&&c1.y>200.&&c1.y<210.)return vec2(0.,0.);//markers\n        if(c1.x<len){\n            float n = max(0.,min(1.,c1.x/len))*(1.-target)+target;\n            float borderLen=20.;\n            float toEdge= (abs(fragCoord.y-res.y/2.)-res.y/2.+borderLen)/borderLen;\n            if(abs(fragCoord.y-res.y/2.)>res.y/2.-borderLen)return vec2(n,toEdge);//border\n            else return vec2(n,0.);\n        }\n    }\n    {//borders:{\n        const float b=borderSize;//defined in Common\n        c1=abs(abs(uv-vec2(0.5))-vec2(0.5))*res;\n        float minv=min(c1.x,c1.y);\n        if(minv<b){\n            return vec2(1.0+0.25*(b-minv)/b,1.0*(b-minv)/b);;\n        }\n        \n    }//}borders\n    {\n        \n    }\n    {\n        //col=vec4(0.0,0.0,1.0,0.0);\n        return vec2(1.0,0.00);\n        //return vec2(1.0,0.004);\n    }//default\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 temp=fragColor;\n    //onReset(press 'r') => make all black and reset all\n    //onReload (press 'a') =>{make edge and circle}\n    if(true||texelFetch(iChannel1,ivec2(82,0),0).x==1.0||dot(fragColor,fragColor)==0.0||texelFetch(iChannel1,ivec2(65,0),0).x==1.0){\n        fragColor=vec4(0.0,0.0,1.0,0.0);\n        fragColor.zw=getObjects(fragCoord);\n        return;\n    }\n    else fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"struct EnergyData{\n    float frequency,phase,amplitude,energy;\n};\nvec4 EnergyData_toVec4(EnergyData data){\n    return vec4(data.frequency,data.phase,data.amplitude,data.energy);\n}\nEnergyData EnergyData_fromVec4(vec4 data){\n    return EnergyData(data.x,data.y,data.z,data.w);\n}\nvec4 getEnergy(vec2 pos){\n    vec4 cell=getPos(texture(iChannel0,pos));\n    vec4 world=texture(iChannel2,pos);\n    float frequency,phase,amplitude,energy;\n    frequency=sqrt(abs(-cell.z/cell.x));\n    phase=atan(cell.y/(cell.x*frequency));\n    float capMul=3.;\n    if(abs(phase)>tau/4.*capMul)phase=tau/4.*capMul*(float[2](-1.,1.))[int(phase>0.)];\n    amplitude=abs(cell.x)/cos(phase);\n    energy=frequency*amplitude/world.z;\n    return vec4(frequency,phase,amplitude,energy);\n}\n//get energy, image processing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    vec2 uv2=fragCoord/iChannelResolution[0].xy;\n    vec4 cell=getPos(texture(iChannel0,uv2));\n    vec4 world=texture(iChannel2,uv2);\n    \n    vec4 data = getEnergy(uv2);\n    if(true)data.xy = (data.xy//average frequency over a larger area\n        +(getEnergy(uv2+vec2(1,0)/iChannelResolution[0].xy).xy\n        +getEnergy(uv2+vec2(0,1)/iChannelResolution[0].xy).xy\n        +getEnergy(uv2+vec2(-1,0)/iChannelResolution[0].xy).xy\n        +getEnergy(uv2+vec2(0,-1)/iChannelResolution[0].xy).xy)/(1.+sqrt(1.))\n        +(getEnergy(uv2+vec2(1,1)/iChannelResolution[0].xy).xy\n        +getEnergy(uv2+vec2(1,-1)/iChannelResolution[0].xy).xy\n        +getEnergy(uv2+vec2(-1,1)/iChannelResolution[0].xy).xy\n        +getEnergy(uv2+vec2(-1,-1)/iChannelResolution[0].xy).xy)/(1.+sqrt(2.))\n    )/(1.+2.*4.+sqrt(2.)*4.);\n    float frequency,phase,amplitude,energy;\n    frequency = data.x;\n    phase = data.y;\n    amplitude = data.z;\n    energy = data.w;\n    //press 'e' and 'd' to change view modes\n    //frequency tends to max out at 1hz = 1 wave per frame\n    bool viewMode=texelFetch(iChannel1,ivec2(69,2),0).x==1.0;\n    bool viewMode1=texelFetch(iChannel1,ivec2(68,2),0).x==1.0;\n    if(viewMode)//amplitude move\n    fragColor =vec4(setPos(vec3(world.z-1.0,vec2(cell.x,cell.y)/*/world.z*/)),setPos(frequency));\n    if(!viewMode)\n    if(viewMode1)//if(1==0)//energy mode\n    fragColor =vec4(setPos(vec3(world.z-1.0,vec2(energy*4.))),setPos(energy*2.));\n    else//frequency mode\n    fragColor =vec4(hsl2rgb((frequency<0.2?.58:0.)/0.58*0.66,1.-(1.-world.z)*0.4,0.66*pow(energy,0.)),setPos(energy*2.));\n}","name":"Buffer C","description":"","type":"buffer"}]}