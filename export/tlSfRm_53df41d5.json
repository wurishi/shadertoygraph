{"ver":"0.1","info":{"id":"tlSfRm","date":"1598535302","viewed":74,"name":"AARO PERAMAA-II","username":"jorge2017a1","description":"AARO PERÄMAA, 2014","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["aaroperamaaii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//AARO PERÄMAA, 2014\n\n\n//\n// This is a one of my rare non ray marching algorithms. \n// I developed this originally on my phone, so i wanted to make it\n// as fast as possible, but still have plenty of features.\n// I designed this to be a voxel renderer, so it would have only\n// AABB intersection, but later on i added sphere intersection code too.\n// \n// The performace with this renderer is pretty decend, since i got it running \n// on my phone (Samsung Galaxy S Advance (lower end version on S II)) ~15fps\n// with 800x480 resolution. Using fisheye edge and disabling other lamp i got ~20fps\n// With my PC i got OVER 60fps with 1920x1080 (even with 0.5 selected from the dropbox above (is that 3840x2160 then?)) resolution with HD 7770 and Chrome\n//\n// YOU ARE FREE TO USE THIS CODE, BUT PLEASE GIVE ME CREDIT IF YOU DO.\n//\n\n#define MAX 1337. //Max render distance\n#define ERR 0.00001 //Smaller this is, more artifacts\n                 //but larger value means more shadow bia#define FISHEYE //Fun!\n//#define FISHEYE //Not sure if this is a proper fisheye projection, but it seems to work pretty well\n//#define FISHEYEEDGE //Use only with fisheye (i did this back when in early stages to hide a small artifact around the corners lol)\n#define VIGNETTE 1.0 //i dunno how to spell it xD\n//(.8,.84,.87) (.4,.7,.9)\n#define AMBIENT vec3(.8) //Ambient light color, used with shadows (also has strange issue, dont even ask)\n#define POINT //Pointlight, not very well visible if used with directional\n#define DIRECTIONAL //Sun\n#define DIRDIR vec3(.5,-1.,-.5) //directional direction lol (also dont comment)\n#define SKY\n//#define DITHER //implement\n#define GLOSS 16.0 //Glossiness\n#define GLOSSMAP //Only applies to ground\n#define CAMMOVEMENT //Orbiting camera\n#define CAMROT //Rotating camera, designed to be used with CAMMOVEMENT\n#define SHADOW //Shadows or not?\n#define VFOV 1.25 //Vertical field of view\n\n/*\nprecision highp float;\n\n\nuniform float time;\nuniform vec2 resolution;\n*/\n\nconst vec3 lb1=vec3(-50,-1,-50);\nconst vec3 rt1=vec3(50,0,50);\nconst vec3 lb2=vec3(-1,0,-1);\nconst vec3 rt2=vec3(1,2,1);\n\n//vec3 sc=vec3(0,3.+abs(sin(time*3.1415)),0);\nvec3 sc;\n\n\nfloat sphere(vec3 d, vec3 o, vec3 sc, float r)\n{\nvec3 oc=o-sc;\nfloat b=2.*dot(d,oc);\nfloat c=dot(oc,oc)-r*r;\nfloat disc=b*b-4.*c;\nif(disc<0.)\n  return MAX;\n\nfloat q;\nif(b<0.)\n  q=(-b-sqrt(disc))/2.;\nelse\n  q=(-b+sqrt(disc))/2.;\n\nfloat t0=q;\nfloat t1=c/q;\n\nif(t0>t1){\nfloat tmp=t0;\nt0=t1;\nt1=tmp;\n}\nif(t1<0.0)\n  return MAX;\n\nif(t0<0.)\nreturn t1;\nelse\n  return t0;\n}\n\nvec3 spheren(vec3 p, vec3 c)\n{\nreturn normalize(p-c);\n}\n\nfloat aabb(vec3 r, vec3 o, vec3 lb, vec3 rt)\n{\n// r.dir is unit direction vector of ray\nvec3 dirfrac;\ndirfrac.x = 1.0 / r.x;\n  dirfrac.y = 1.0 / r.y;\n  dirfrac.z = 1.0 / r.z;\n   // lb is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner //\n   //\tr.org is origin of ray\n   float t1 = (lb.x - o.x)*dirfrac.x;\n   float t2 = (rt.x - o.x)*dirfrac.x;\n   float t3 = (lb.y - o.y)*dirfrac.y;\n   float t4 = (rt.y - o.y)*dirfrac.y;\n   float t5 = (lb.z - o.z)*dirfrac.z;\n   float t6 = (rt.z - o.z)*dirfrac.z;\n   float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n   float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n   float t=0.;\n   // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behind us\n   if (tmax < 0.) {\n   t = tmax;\n   return MAX;\n   } // if tmin > tmax, ray doesn't intersect AABB\n   if (tmin > tmax) {\n   t = tmax;\n   return MAX;\n   }\n   t = tmin;\n   return t;\n}\n\nvec3 aabbn(vec3 p, vec3 lb, vec3 rt) {\nif(abs(p.x-lb.x)<ERR)\nreturn vec3(-1,0,0);\nif(abs(p.x-rt.x)<ERR)\nreturn vec3(1,0,0);\nif(abs(p.y-lb.y)<ERR)\nreturn vec3(0,-1,0);\nif(abs(p.y-rt.y)<ERR)\nreturn vec3(0,1,0);\nif(abs(p.z-lb.z)<ERR)\nreturn vec3(0,0,-1);\nif(abs(p.z-rt.z)<ERR)\nreturn vec3(0,0,1);\nreturn vec3(0,0,0);\n}\n\nvec3 sky(vec3 d){\n#ifdef SKY\nvec3 r=mix(vec3(.8,.84,.87),vec3(.4,.7,.9),d.y);\nr=mix(r,vec3(1,.95,.85),\nmax(0.,pow(max(dot(d,-DIRDIR),0.)/1.2,16.)));\nreturn r;\n#endif\nreturn vec3(0);\n}\n\nvec3 shadow(vec3 d, vec3 o){\nfloat t=1000.;\nt=min(t,aabb(d,o,lb2,rt2));\nt=min(t,aabb(d,o,lb1,rt1));\nt=min(t,sphere(d,o,sc,1.));\n  if(distance(t,1000.)>ERR)\nreturn vec3(0);\nreturn AMBIENT;\n}\n\nvec3 shade(vec3 n, vec3 p,vec3 d,int i)\n{\n//how long did it have to take until i made\n//a proper diffuse shade? waaay too long\n\n//return n/2.+.5;\nvec3 r=vec3(0);\nvec3 c;\nfloat gi=1.;\nif(i==2)\n{\nif(mod(floor(p.x),2.0)==\n     mod(floor(p.z),2.0))\n   {\n    if(mod(floor(p.x+p.z),2.0)==\n      mod(floor(p.z-p.x),2.0))\n   {\n   c=vec3(.8,.8,.8);\n   gi=.8;\n  }\n  else{\n   c=vec3(0.5,0.5,0.5);\n   gi=.5;\n  }\n}\nelse {\n  c=vec3(.65);\n  gi=.65;\n}\n}\nif(i==1)\nc=vec3(.9);\nif(i==3)\nc=n/2.+.5;\n\n  #ifndef GLOSSMAP\n  gi=1.;\n  #endif\n\nvec3 ld=-DIRDIR;\nvec3 lo=vec3(-sin(iTime)*5.,4.,cos(iTime)*5.);\nvec3 ld2=normalize(lo-p);\n\nvec3 dr=r,pr=r;\nvec3 ds=vec3(1),ps=ds;\n\n//r=max(0.,dot(ld2,n))*c*r;\n\n#ifdef DIRECTIONAL\nld=normalize(ld);\ndr+=vec3(.9,.90,.8)*c;\n//r-=shadow(ld,p+n*(ERR*5.)).zyx;\ndr*=max(0.,dot(ld,n));\n\n#ifdef SHADOW\nds=shadow(ld,p+n*(ERR*5.));\n#endif\n\n#ifdef GLOSS\ndr+=vec3(pow(max(dot(reflect(ld,n),d),0.),GLOSS))*gi;\n#endif\n\ndr*=ds;\n  #endif\n\n  #ifdef POINT\npr+=3./max(distance(lo, p),1.)*c;\n//r-=shadow(ld2,p+n*ERR).zyx;\npr*=max(0.,dot(ld2,n));\n\n#ifdef SHADOW\nps=shadow(ld2,p+n*(ERR*5.));\n#endif\n\n#ifdef GLOSS\npr+=vec3(pow(max(dot(reflect(ld2,n),d),0.),GLOSS))*gi;\n//r=min(vec3(1),r);\n#endif\n\n  pr*=ps;\n#endif\n\n  //final composit\n  dr=min(vec3(1),dr);\n  pr=min(vec3(1),pr);\n\n  r=dr+pr;\nr=min(vec3(1),r);\nreturn r;\n}\n\n\nvec3 depthSort(vec3 d, vec3 o){\nfloat t=MAX;\nfloat tmp=0.;\nvec3 n=vec3(0,0,0);\nint i=0;\n\ntmp=aabb(d,o,lb2,rt2);\nif(tmp<t) {\nt=tmp;\nn=aabbn(d*t+o,lb2,rt2);\ni=1;\n}\n\ntmp=aabb(d,o,lb1,rt1);\n\nif(tmp<t) {\ni=2;\nt=tmp;\nn=aabbn(d*t+o,lb1,rt1);\n}\n\ntmp=sphere(d,o,sc,1.);\n\nif(tmp<t){\ni=3;\nt=tmp;\nn=spheren(d*t+o,sc);\n}\n\nif(t!=MAX)\nreturn shade(n, d*t+o, d, i);\nreturn sky(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tsc=vec3(0,3.+abs(sin(iTime*3.1415)),0);\n    \n    vec2 uv=fragCoord.xy/iResolution.xy*2.-1.;\n\tfloat ar=iResolution.x/iResolution.y;\n\t\n    uv.x*=ar;\n\tvec3 c=vec3(0,0,0);\nvec3 o=vec3(0.,2.5,5);\n#ifdef FISHEYEEDGE\nif(length(uv)>.75)\n  return;\n#endif\n#ifdef CAMMOVEMENT\no.x=sin(iTime)*5.;\no.z=cos(iTime)*5.;\n#endif\nvec3 d=normalize(vec3(uv,1./-VFOV));\n#ifdef FISHEYE\nd.z+=length(uv);\nd=normalize(d);\n#endif\n#ifdef CAMROT\nfloat deg=-iTime;\nvec2 oldR=d.xz;\nd.x=oldR.x*cos(deg)-oldR.y*sin(deg);\nd.z=oldR.x*sin(deg)+oldR.y*cos(deg);\n#endif\n\nc=depthSort(d,o);\n#ifdef VIGNETTE\nc/=max(length(uv)+VIGNETTE-1.*ar,1.);\n#endif\n#ifdef DITHER\n//TODO: Implement dither (hash)\n#endif\nfragColor=vec4(c,1);\n}\n\n","name":"Image","description":"","type":"image"}]}