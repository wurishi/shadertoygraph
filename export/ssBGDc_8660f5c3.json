{"ver":"0.1","info":{"id":"ssBGDc","date":"1619077751","viewed":88,"name":"Newton v. Möbius","username":"adamjmurray","description":"A Newton fractal animated via a Möbius transformation.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"ssBGWc","parentname":"Simple Newton Fractal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int quality = 2; // antialiasing: 1=off, 2=on, >2=more anti-aliasing\n\nvec2 cmul(vec2 a, vec2 b) { // complex multiplication\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) { // complex division\n    float denom = (b.x*b.x+b.y*b.y);\n    if (denom < 0.0000000001) denom = 0.0000000001; // avoid division by zero\n    return vec2(a.x*b.x+a.y*b.y, -a.x*b.y+a.y*b.x) / denom;\n}\n\nvec2 fn(vec2 z) { // f(z) = z^3 - 1\n    return cmul(z,cmul(z,z)) - vec2(1,0);\n}\nvec2 dfn(vec2 z) { // f'(z) = 3*z^2\n    return cmul(vec2(3,0),cmul(z,z));\n}\n\nvec2 mobius(vec2 a, vec2 b, vec2 c, vec2 d, vec2 z) { // f(z) = (az + b)/(cz + d)\n\treturn cdiv(cmul(a,z) + b, cmul(c,z) + d);\n}\n\nvec3 hsl2rgb( in vec3 c ) { // © 2014 Inigo Quilez, MIT license, see https://www.shadertoy.com/view/lsS3Wc\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat gain(float x, float k) { // https://iquilezles.org/articles/functions\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\nfloat ease(float wave, float k) {\n    // map cos/sin wave to [0,1], apply the gain function, and map back to [-1,1]\n    return gain(wave * 0.5 + 0.5, k) * 2. - 1.;\n}\n\nvec3 newton(vec2 z) { // iteratively apply z = z-f(z)/f'(z)\n    vec2 prevZ = z;\n    float i = 0.;\n    float intensity = 0.;\n    \n    for (i=1.0; i<100.; i++) {\n        z -= cdiv(fn(z),dfn(z));\n        if (length(z-prevZ) < 0.0001) break;  \n        \n        // http://www.fractalforums.com/programming/smooth-colouring-of-convergent-fractals/msg33392/#msg33392\n        intensity += exp(-length(z) - 0.5/(length(prevZ-z)));       \n        \n        prevZ = z;\n    }\n    \n    float theta = atan(z.y,z.x);\n    float angle = mod(theta/6.2832+1.0, 1.0);\n    float hue = mod(angle + iTime/50.0, 1.0);\n    \n    return hsl2rgb(vec3(hue, 0.7, intensity/3.-0.2));\n}\n\nvec3 draw(vec2 z) {\n    float speed = 0.03;\n    // The mobius transformation is very fast-moving in the middle, so squash the animation curve to keep it under control.    \n    // squashFactor < 1.0 is a \"rush in, slow in the middle, rush out\" easing function.\n    float squashFactor = 0.5; \n    \n    return newton(mobius(\n        vec2(1,0),\n        vec2(0.005*sin(iTime/6.),0),// rotational movement\n        vec2(0, 300.*ease(cos(iTime*speed), squashFactor)),\n        vec2(1,0),\n        z\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 10.;\n    float samples = 0.;    \n    vec3 color = vec3(0,0,0);\n    float subpixel = 1./float(quality);\n    \n    for (float x=0.; x<1.; x+=subpixel) {\n        for (float y=0.; y<1.; y+=subpixel) {\n            vec2 pt = (2.*(fragCoord + vec2(x,y)) - iResolution.xy)/iResolution.y; // [-1,1] vertically    \n            pt /= zoom;\n            color += draw(pt);\n            samples++;\n        }\n    }\n    fragColor = vec4(color/samples,1);\n}\n","name":"Image","description":"","type":"image"}]}