{"ver":"0.1","info":{"id":"l3sfW8","date":"1728337754","viewed":17,"name":"Mardi","username":"Djeinaba_dia","description":"a compléter","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["infographie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray{\n    vec3 o; // Origine\n    vec3 d; // Direction\n};\n\nstruct Val {\n  float v; // Distance signée\n  int c; // Coût\n};\n\n// Calcule un point sur un rayon\n// ray : Le rayon\n//   t : Distance\nvec3 Point(Ray ray, float t)\n{\n    return ray.o + t * ray.d;\n}\n\n// Direction aléatoire dans un hémisphère\n// seed : Graine entière, de 0 à N\n//    n : Direction de l'hémisphère\nvec3 Hemisphere(int seed, vec3 n)\n{\n    float a = fract(sin(176.19 * float(seed))); // Aléatoire uniforme\n    float b = fract(sin(164.19 * float(seed)));\n    \n    float u = 2. * 3.1415 * a; // Angle aléatoire\n    float v = acos(2. * b - 1.); // Distribution arccosine pour compenser aux pôles\n    \n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v)); // Direction\n    if (dot(d, n) < 0.) { d = -d; } // Hémisphère\n    \n    return d;\n}\n\n// Caméra -------------------------------------------------------------------------------\n\n// Matrice de rotation autour de l'axe z\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa = sin(a); float ca = cos(a);\n  return mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n}\n\n// Calcule le rayon\n//      m : Position de la souris\n//      p : Pixel\nRay CreateRay(vec2 m, vec2 p)\n{\n  float a = 3. * 3.14 * m.x;\n  float le = 3.5;\n  \n  // Origine\n  vec3 ro = vec3(37., 0., 15.);\n  ro *= Rz(a);\n  \n  // Point cible\n  vec3 ta = vec3(0., 0., 1.);\n  \n  // Repère orthonormé\n  vec3 w = normalize(ta - ro);\n  vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n  vec3 v = normalize(cross(u, w));\n  vec3 rd = normalize(p.x * u + p.y * v + le * w);\n  return Ray(ro, rd);\n}\n\n// Primitives -------------------------------------------------------------------------------\n\n// Sphère\n// p : point\n// c : centre du squelette\n// r : rayon\nVal Sphere(vec3 p, vec3 c, float r)\n{\n  return Val(length(p - c) - r, 1);\n}\n\n// Plan \n// p : point\n// n : normale du plan\n// o : point sur le plan\nVal Plane(vec3 p, vec3 n, vec3 o)\n{\n    return Val(dot((p - o), n), 1);\n}\n\n// Opérateurs\n\n// Union\n// a, b : fonction de champ des sous-arbres gauche et droit\nVal Union(Val a, Val b)\n{\n  return Val(min(a.v, b.v), a.c + b.c + 1);\n}\n\n// Champ potentiel de l'objet\n// p : point\nVal object(vec3 p)\n{\n  Val v = Union(\n    Sphere(p, vec3(0., 2., 2.), 2.25),\n    Sphere(p, vec3(3., 0., -1.), 3.)\n  );\n\n  v = Union(v, Plane(p, vec3(0., 0., 1.), vec3(0.0, 0.0, -4.0)));\n  \n  return v;\n}\n\n// Analyse du champ scalaire -----------------------------------------------------------------\n\nconst int Steps = 200; // Nombre de pas\nconst float Epsilon = .01; // Epsilon de marche\n\n// Normale de l'objet\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps = .001;\n  vec3 n;\n  Val val = object(p);\n  float v = val.v;\n  n.x = object(vec3(p.x + eps, p.y, p.z)).v - v;\n  n.y = object(vec3(p.x, p.y + eps, p.z)).v - v;\n  n.z = object(vec3(p.x, p.y, p.z + eps)).v - v;\n  return normalize(n);\n}\n\n// Tracer un rayon avec la méthode de marche sur les rayons\n// ray : Le rayon\n//   e : Distance maximale\n//   h : Impact\n//   s : Nombre de pas\n//   c : Coût\nbool SphereTrace(Ray ray, float e, out float t, out int s, out int c)\n{\n  bool h = false;\n  \n  // Démarrer à l'origine\n  t = 0.0;\n  c = 0;\n  \n  for (int i = 0; i < Steps; i++)\n  {\n    s = i;\n    vec3 p = Point(ray, t);\n    Val val = object(p);\n    float v = val.v;\n    c += val.c;\n    // Impact sur l'objet\n    if (v < 0.)\n    {\n      h = true;\n      break;\n    }\n    // Avancer le long du rayon\n    t += max(Epsilon, v);\n    // Échapper si trop loin\n    if (t > e)\n    {\n      break;\n    }\n  }\n  return h;\n}\n\n// Éclairage -------------------------------------------------------------------------------\n\n// Couleur d'arrière-plan\n// ray : Rayon \nvec3 background(Ray ray)\n{\n  return mix(vec3(.45, .55, .99), vec3(.65, .69, .99), ray.d.z * .5 + .5);\n}\n\n// Ombre\n// p : Point\n// n : Normale\n// l : Direction de la lumière\nfloat Shadow(vec3 p, vec3 n, vec3 l)\n{\n  float t;\n  int s;\n  int c;\n  bool hit = SphereTrace(Ray(p + Epsilon * n, l), 100., t, s, c);\n  if (!hit)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Ombrage et éclairage\n//   p : Point\n//   n : Normale au point\n// eye : Direction de l'œil\nvec3 Shade(vec3 p, vec3 n, Ray eye)\n{\n  // Lumière ponctuelle\n  const vec3 lp = vec3(5., 10., 25.);\n  \n  // Direction de la lumière vers la lumière ponctuelle\n  vec3 l = normalize(lp - p);\n  \n  // Couleur ambiante\n  vec3 ambient = .25 + .25 * background(Ray(p, n));\n  \n  // Calcul de l'ombre\n  float shadow = Shadow(p, n, l);\n  \n  // Diffusion Phong\n  vec3 diffuse = .35 * clamp(dot(n, l), 0., 1.) * vec3(1., 1., 1.);\n  \n  // Spéculaire\n  vec3 r = reflect(eye.d, n);\n  vec3 specular = .15 * pow(clamp(dot(r, l), 0., 1.), 35.) * vec3(1., 1., 1.);\n  vec3 c = ambient + shadow * (diffuse + specular);\n  return c;\n}\n\n// Ombrage selon le nombre de pas dans le traçage de sphères\n// n : Nombre de pas\nvec3 ShadeSteps(int n, int m)\n{\n  float t = float(n) / float(m);\n  return .5 + mix(vec3(.05, .05, .5), vec3(.65, .39, .65), t);\n}\n\n// Image\nvoid mainImage(out vec4 color, in vec2 pxy)\n{  \n  // Convertir les coordonnées du pixel\n    vec2 pixel = (-iResolution.xy + 2. * pxy) / iResolution.y;\n\n  // Souris\n  vec2 m = iMouse.xy / iResolution.xy;\n  \n  // Caméra\n  Ray ray = CreateRay(m, pixel);\n  \n  // Tracer le rayon\n  \n  // Impact et nombre de pas\n  float t = 0.0;\n  int s = 0;\n  int c;\n  bool hit = SphereTrace(ray, 100., t, s, c);\n  \n  // Ombrage de l'arrière-plan\n  vec3 rgb = background(ray);\n  \n  if (hit)\n  {\n    // Position\n    vec3 p = Point(ray, t);\n    \n    // Calcul de la normale\n    vec3 n = ObjectNormal(p);\n    \n    // Ombrer l'objet avec la lumière\n    rgb = Shade(p, n, ray);\n  }\n  \n  // Décommentez cette ligne pour ombrer l'image avec des couleurs représentant le nombre de pas\n    // rgb = ShadeSteps(s, Steps);\n  \n   // Décommentez cette ligne pour ombrer le coût\n  // rgb = ShadeSteps(c, 500);\n  color = vec4(rgb, 1.);\n}\n","name":"Image","description":"","type":"image"}]}