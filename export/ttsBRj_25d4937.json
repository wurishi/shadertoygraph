{"ver":"0.1","info":{"id":"ttsBRj","date":"1598393368","viewed":286,"name":"2D N-Body Dynamics","username":"ndeshler","description":"A simple simulator for gravitating bodies. Changing the gravitational constant and the mass density affects the dynamics. Under 2D gravity, masses can never reach escape velocity!\n\nNOTE: There have been issues running this on mobile devices and explorer.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["physicssimulation","orbits"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// N-Body Simulation by ndeshler\n// https://www.shadertoy.com/view/ttsBRj\n// 08/31/2020\n// --------------------------------------------------------------------------------\n// PROJECT 3: A 2D simulator for the interaction of gravitating bodies.\n// \n// ---------------------------------------------------------------------------------\n// Enjoy!\n\n#define numbodies 15.\n#define PI 3.1415926538\t\t// Pi constant\n\nbool isPointInBody(vec2 pt, float r, vec2 o) {\n    return length(pt - o) < r;\n}\n\nvec4 getBodyPosVel(float id) {\n    return texture(iChannel0, vec2(id + 0.5, 0.5)/iResolution.xy);\n}\n\nvec4 getBodyMassRad(float id) {\n    return texture(iChannel1, vec2(id + 0.5, 0.5)/iResolution.xy);\n}\n\nbool drawBody(vec2 pt, float id) {\n    \n    vec4 bodyPosVel = getBodyPosVel(id);\n    vec4 bodyMassRad = getBodyMassRad(id);\n    \n    vec2 pos = bodyPosVel.xy;\n    float r = bodyMassRad.y;\n\n    return isPointInBody(pt, r, pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n            \n    for (float id = 0.; id < numbodies; id++) {\n        \n        vec4 bodyPosVel = getBodyPosVel(id);\n    \t        \n        // Color for body\n        vec3 rgb = vec3(sin((id/numbodies - 0.5) * PI) ,cos(id/numbodies * PI), bodyPosVel.x/iResolution.x);\n        rgb /= max(max(rgb.x,rgb.y),rgb.z);\n        \n    \tvec4 col = vec4(rgb,1.);\n        \n        // Draw fragment if it corresponds to a body\n        if (drawBody(fragCoord, id)) fragColor += col;         \n    \n    \n    }\n    \n       \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer performs the position and velocity updates for the massive bodies\n// iChannel0 contains the position and velocity vectors for each massive body\n\n\n#define numbodies 15.\t\t// Number of massive bodies (must be integer value represented as float)\n#define GravConst 1E3\t\t// The gravitational constant for the simulated universe (tunable)\n#define PI 3.1415926538\t\t// Pi constant\n\n\nvec4 getBodyPosVel(float id) {\n    return texture(iChannel0, vec2(id + 0.5, 0.5)/iResolution.xy);\n}\n\nvec4 getBodyMassRad(float id) {\n\treturn texture(iChannel1, vec2(id + 0.5,0.5)/iResolution.xy);\n\n}\n\nvec2 hash2(float n) { return fract(abs(vec2(sin(n),cos(n*7.))*43758.5)); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.,0.,0.,0.);\t\t\t// default data\n    \n    if (fragCoord.y > 0.5 || fragCoord.x > numbodies) discard;\n    \n    float id = floor(fragCoord.x);\n    \n    // initialize pseudo random positions, velocities\n    if(iFrame < 1)\n    {\t\n        float nfrac = id/numbodies;\n        vec2 init_p = (iResolution.y / 2.) * nfrac * vec2(cos(nfrac * 2. * PI),sin(nfrac * 2. * PI));\n        init_p += iResolution.xy / 2.;\n        vec2 init_v = sqrt(100.)*vec2(-sin(nfrac * 2. * PI),cos(nfrac * 2. * PI));\n        \n        // UNCOMMENT TO randomize position and velocity initializations\n        //vec2 init_p = hash2(id)*iResolution.xy;\n        //vec2 init_v = vec2(sin(id),cos(id))*iResolution.xy;\n     \t//init_v /= length(init_v) / 10.;\n        fragColor = vec4(init_p, init_v);\n    } else {        \n        \n        // body of interest\n        vec4 pvBody = getBodyPosVel(id);\n        vec4 mrBody = getBodyMassRad(id);\n            \n        vec2 p = pvBody.xy;\t\t// position\n        vec2 v = pvBody.zw;\t\t// velocity\n        float m = mrBody.x;\t\t// mass\n        float r = mrBody.y;\t\t// radius\n        \n        \n        // initialize gravitational acceleration vector\n        vec2 a = vec2(0.);\n\n        // loop over neighboring massive bodies and build update vectors accordingly\n        for (float nid = 0.; nid < numbodies; nid++) {\n            \n            if (nid != id) {\n                  \n                // neighboring body\n        \t\tvec4 pvNeighbor = getBodyPosVel(nid);\n        \t\tvec4 mrNeighbor = getBodyMassRad(nid);\n            \n        \t\tvec2 n_p = pvNeighbor.xy;\t\t// position\n        \t\tvec2 n_v = pvNeighbor.zw;\t\t// velocity\n        \t\tfloat n_m = mrNeighbor.x;\t\t// mass\n        \t\tfloat n_r = mrNeighbor.y;\t\t// radius\n                \n            \t\n                vec2 sep = n_p - p;\n                float ls = max(length(sep),0.01); // Take max to avoid stability issues\n                \n\n            \t// Update gravitational acceleration vector based on superposition principle (fields are additive)\n                vec2 hat = (sep/ls); // attractive force direction\n                \n                // Use 2D Newtonian gravity to update force. \n                // Note: This is not the inverse square law but rather the inverse law              \n                a = a + GravConst * n_m / ls * hat ;  \n            }       \n        }\n            \n        // Apply position and velocity updates using Newtonian Gravity Law\n        v = v + iTimeDelta * a;\t\t// update velocity\n        p = p + iTimeDelta * v;\t\t// update position\n\n        fragColor = vec4(p,v);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer instantiates the mass and the radii of the massive bodies\n// iChannel1 contains the mass and the radius of each massive body\n\n#define numbodies 15.\t\t// Number of massive bodies (must be integer value represented as float)\n#define massdensity 1.\t\t// Mass density of the planets\n#define PI 3.1415926538\t\t// Pi constant\n\nfloat hash1(float n) { return fract(sin(n)*43758.5); }\n\nvec4 getBodyMassRad(float id) {\n    return texture(iChannel1, vec2(id + 0.5, 0.5)/iResolution.xy);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,0.);\n    \n    if (fragCoord.y > 0.5 || fragCoord.x > numbodies) discard;\n    \n    float id = floor(fragCoord.x);\n    \n    // initialize pseudo-random masses and radii\n    if(iFrame < 1) {\n        \n        \n        float init_r = 5.;\n        float init_m = massdensity;\n        \n        //float init_r = hash1(id) * (iResolution.x + iResolution.y) / 20.;\n        //float init_m = massdensity * PI * init_r * init_r;\t \t\t\t\t// mass is initialized such that mass density = m / A \n        fragColor = vec4(init_m, init_r,0.,0.);\n    } else {\n    \tfragColor = getBodyMassRad(id);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}