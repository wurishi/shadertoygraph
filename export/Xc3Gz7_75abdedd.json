{"ver":"0.1","info":{"id":"Xc3Gz7","date":"1711489318","viewed":58,"name":"Closest Segment Pt - Rectangle","username":"natevm","description":"Closest point between a segment and a rectangle on the XY plane. More here: https://www.shadertoy.com/playlist/fcGBWG\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","box","segment","closest"],"hasliked":0,"parentid":"43XSWS","parentname":"Closest Segment Point - Box"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2024 Nate Morrical\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The below is a collection of functions to compute the closest point between \n// a point / line / segment and a rectangle. \n\n// Returns the closest point from a 3D point to a 2D rectangle face\n// The rectangle is aligned to the X-Y plane, and is centered at the origin\n//   o - the query origin\n//   r - the rectangle's half length extents\nvec3 pointRectangleQuery( vec3 o, vec2 r ) {\n    return vec3(clamp(o.xy, -r.xy, r.xy), 0.0);\n}\n          \n// Returns the closest point from an infinite 3D line to a 2D rectangle on the X-Y plane, plus the closest \"t\" along o+t*d\n//   o - the origin of the segment\n//   d - the direction along the segment (which does not need to be normalized)\n//   b - the rectangle radius (2 half side lengths)\nvec4 lineRectangleQuery( vec3 ro, vec3 rd, vec2 b )\n{\n    // Test if ray intersects quad. If so, that's the closest point.\n    if (abs(rd.z) > 1e-6f) {\n        float tIntersect = -ro.z / rd.z;\n        vec3 Y = ro + tIntersect * rd;\n        if (all(lessThanEqual(abs(Y.xy), b.xy))) {\n            // The point Y is contained by the rectangle.\n            return vec4(Y, tIntersect);\n        }\n    }\n    \n    // Otherwise, the point is an edge. Check the four edges to determine which is closest\n    vec2 corners[4] = vec2[](vec2(-b.x, -b.y), vec2(b.x, -b.y), vec2(b.x, b.y), vec2(-b.x, b.y));\n    \n    float rdLen2 = dot(rd, rd);\n    float minDist = 1e38f;\n    vec4 result;\n    for (int i = 0; i < 4; ++i) {\n        vec3 s0 = vec3(corners[i], 0.0);\n        vec3 s1 = vec3(corners[(i + 1) % 4], 0.0);        \n        vec3 sd = s1 - s0;\n        vec3 diff = ro - s0;\n        \n        float sdLen2 = dot(sd, sd);\n        float rdDotSd = -dot(rd, sd);\n        float roDotRd = dot(rd, diff);\n        float sdDotRo = -dot(sd, diff);\n\n        float det = max(rdLen2 * sdLen2 - rdDotSd * rdDotSd, 0.0);\n        float tRay = mix(-roDotRd / rdLen2, (rdDotSd * sdDotRo - sdLen2 * roDotRd) / det, (det > 0.0));\n        float tSeg = mix(0.0, clamp((rdDotSd * roDotRd - rdLen2 * sdDotRo) / det, 0.0, 1.0), (det > 0.0));\n        \n        vec3 cpRay = ro + tRay * rd;\n        vec3 cpSeg = s0 + tSeg * sd;\n        diff = cpRay - cpSeg;\n        float diffLen2 = dot(diff, diff);        \n        if (diffLen2 < minDist) {\n            minDist = diffLen2;\n            result = vec4(cpSeg, tRay);\n        }\n    }\n    \n    return result;\n}\n\n// Returns the closest point from a finite 3D segment to a 2D rectangle on the X-Y plane, plus the closest \"t\" along o+t*d\n//   s - the start of the segment\n//   e - the end of the segment\n//   b - the rectangle radius (2 half side lengths)\nvec4 segmentRectangleQuery( vec3 s, vec3 e, vec2 b ) {\n    vec3 o = s;\n    vec3 d = e - s;\n    vec4 lrOutput = lineRectangleQuery(o, d, b);\n    \n    // If closest is within the segment, return that result directly\n    if (lrOutput.w >= 0. && lrOutput.w <= 1.) \n        return lrOutput;\n    \n    // Otherwise, compute the closest point to either side of the segment\n    float parameter = (lrOutput.w < 0.) ? 0. : 1.;\n    vec3 pbOutput = pointRectangleQuery(o + d * parameter, b);\n    return vec4(pbOutput, parameter);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n//------------------------------------------------------------\nconst vec2 rect_rad = vec2(0.5,0.4)*1.5f;\n\nvec2 map( in vec3 pos, bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    // compute closest point to the segment on the surace of the box\n    vec4 result = segmentRectangleQuery(sampleLineStart, sampleLineStop, rect_rad );\n    vec3 closestPointOnLine = mix(sampleLineStart, sampleLineStop, result.w);\n    vec3 closestPointOnBox = result.xyz;\n    \n    vec2 res = vec2(1e38f);\n    \n    // query line\n    {\n    float d = sdCapsule( pos, sampleLineStart, sampleLineStop, 0.015 );\n    if( d<res.x ) res =  vec2( d, 1.0 );\n    }\n    \n    // closest point on line\n    {\n    float d = sdSphere( pos, closestPointOnLine, 0.06 );\n    if( d<res.x ) res = vec2( d, 1.0 );\n    }\n    \n    // Closest point on box\n    {\n    float d = sdSphere( pos, closestPointOnBox, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // The rectangle's surface\n    {\n    float d = sdBox( pos, vec3(rect_rad.xy, .01) );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment from line to box\n    {\n    float d = sdCapsule( pos, closestPointOnLine, closestPointOnBox, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    // Capsule demonstrating correctness.\n    if (showCapsule){\n    float radius = distance(closestPointOnBox, closestPointOnLine);   \n    float d = sdCapsule( pos, sampleLineStart, sampleLineStop, radius );\n    if( d<res.x ) res =  vec2( d, 1.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showCapsule, sampleLineStart, sampleLineStop ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showCapsule, sampleLineStart, sampleLineStop).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate query line\n        vec3 sampleLineStart = -sin(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n        vec3 sampleLineStop  = -cos(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n        // make box transparent\n        bool showBox = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showCapsule = ((samp.x+samp.y+1)&1)==0; \n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showCapsule,sampleLineStart, sampleLineStop);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showCapsule,sampleLineStart, sampleLineStop);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            vec4 result = segmentRectangleQuery(sampleLineStart, sampleLineStop, rect_rad);\n            vec3 closestPointOnLine = mix(sampleLineStart, sampleLineStop, result.w);\n            vec3 closestPointOnRect = result.xyz;\n                \n            // show distance isolines on rectangle\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdBox( closestPointOnLine, vec3(rect_rad, .01) );\n                float dsam = length(pos-closestPointOnLine);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n            // Show distance isolines on open capsule\n            if( abs(m-1.0)<0.6 )\n            {\n                float dref = sdCapsule( closestPointOnRect, sampleLineStart, sampleLineStop, .1 );\n                float dsam = length(pos-closestPointOnRect);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n                        \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showCapsule,sampleLineStart,sampleLineStop);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}