{"ver":"0.1","info":{"id":"mdB3WR","date":"1667595479","viewed":146,"name":"interactive double precision","username":"pb","description":"-Keys: Z, X - Zoom In and Out,  Space to stop Zooming when Play is active\n-Click the Mouse to target the Point you want to Zoom in on\n-You can also Pause and hold down Z or X\n-Key: A  to toggle Anti Alias (only do it when you are not Zooming and Paused)","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot","doubleprecision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// philip.bertani@gmail.com\n\n// I would not full screen this while animating - do it when static and you want to take a full screen peek\n\n// this shader extends: https://www.shadertoy.com/view/WsXGzj by Josh Scholar by making it interactive and other changes\n\n// Navigable Double Precision Mandelbrot Set - guarantee you will see something you have never seen before\n// Click the Mouse and that point will become the new Zoom Center\n// Keys:Z,X Zoom In/Out\n// Space Bar: Stop Zooming\n// Key:A Toggle Anti Aliasing (don't do this until you have found a spot you really want to stop near)\n//      turn Anti Aliasing off when you want to Zoom In and Out or Move around again\n\n// See Common for Double Precision framework (oh glorious precision!)\n\n// See Buffer A for User Input and Parameter Persistence\n\n//************* Modify this for different Color Cycling *********************************\n#define COLORS 5. //play with this to get different visuals, usual want to deccrease it the further you are zoomed in\n                  //increase it when you are in the filamenty areas\n                  \n//************* Modify this for more iterations at higher Zoom Levels *******************\nconst int max_iterations = 3000;  //increase to [4000,8000] when you see large voids but press Pause!\n\nconst float PI = 3.14159265358979323846264;\nconst float threshold = 8.;  //\"Infinity\"\n\nfloat max_colors, color_scale,inverse_max_colors;\nvec4 storedZoom;\n\n\nvec4 color_ramp(int i) {\n    // Running the index through cos creates a continous ramp.\n    float normalized_mod = mod(float(i), (max_colors)) * inverse_max_colors;\n\tfloat normalized_cos = (cos(normalized_mod * 2.0 * PI) + 1.0) * 0.5;\n    i = int(float(max_colors) * normalized_cos);\n\n    float factor = float(i) / float(max_colors);\n    float inverse_factor = 1.0 - factor;\n    // An arbritrary ramp of colors\n    return vec4(sqrt(sqrt(factor)), factor, inverse_factor * 0.5, 1.0);\n}\n\nvec4 color_from_ramp(int i, float f) {\n\tvec4 first = color_ramp(i);\n\tvec4 second = color_ramp(i + 1);\n    return first * (1.0 - f) + second * f;\n}\n\nvec4 color_from_iteration(vec4 z, int i) {\n    // Continuous coloring\n    vec2 len=dcLength(z);\n    float s = float(i) + log2(log(threshold)) - log2(log(len.x+len.y));\n    s *= color_scale;\n    int first = int(floor(s));\n    return color_from_ramp(first, s - float(first));\n}\n\nvec3 double_fractal( vec2 U)\n{\n    vec2 Threshold = set(threshold);\n        \n    vec4  storedOffset = texelFetch( iChannel0, ivec2(0), 0 );\n\n    float scaletemp = ZOOM_LEVEL;\n    \n\tvec4 c = vec4(\n        set(U.x * scaletemp),\n        set(U.y * scaletemp)\n    );\n    \n    c = dcAdd(c, storedOffset);\n\n    vec4 z = vec4(0.0, 0.0, 0.0, 0.0);\n    int final_i; int escape=0;\n    for (int i = 0; i < max_iterations; i++) {\n        final_i = i;\n\n        if (cmp(dcLength(z), Threshold)>0.) { escape=1; break; } \n\n        z = dcAdd(dcMul(z, z), c);\n    }\n\n    if ( escape==1 ) return color_from_iteration(z, final_i).rgb;\n    \n    return vec3(0);\n}\n\nvec3 fractal( vec2 fragCoord)\n{\n    return double_fractal(fragCoord);\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.xy = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n\tfragColor.rgb  = fractal( fragCoord  );\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n\n \n    storedZoom = texelFetch( iChannel0, ivec2(1),  0 ); \n    max_colors = 100.;    // maybe increase as we zoom in, play with it\n\n    color_scale = COLORS/(1.+storedZoom[1]);    //needs to decrease as we zoom in\n    inverse_max_colors = 1.0 / max_colors;\n\n    mainImage0(O,U);\n        \n    float antiAlias = texelFetch(iChannel0,ivec2(2),0).x;\n    \n    //Fabrice Neyret anti alias loop here\n    //but I can't get a good result using fwidth so just turning it on and off here\n    if (antiAlias > 0. )\n    {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n    }\n    \n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// in this texture we save changes to parameters based on user input\n\nvec4 handleKeyboard() {     \n\n    vec4 ik = vec4(0);\n\n    ik[0] = texelFetch(iChannel1, ivec2(90,0),0).x - texelFetch(iChannel1,ivec2(88,0),0).x;\n    ik[1] = texelFetch(iChannel1, ivec2(32,0),0).x;\n\n    //z,w,space - to zoom in , zoom out, stop zooming\n\n    return ik;\n\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n \n  O -= O;\n  \n  ivec2 iU = ivec2(U);\n  \n  if ( iU == ivec2(0) ) {\n  \n    if (iFrame < 10) {\n      O = vec4(set(-.5),vec2(0));\n    }\n    \n    else {\n           \n      //we need to store the Double Precision offset so we \n      //can click the mouse and recenter on that point\n      vec4 storedOffset = texelFetch( iChannel0, iU, 0); \n      \n      if (  iMouse.w > 0. ) {\n      \n        vec2  mm = iMouse.xy / iResolution.xy;\n\n        vec4 storedZoom   = texelFetch( iChannel0, ivec2(1), 0);\n        \n        float scaletemp = ZOOM_LEVEL ; \n    \n        vec2 scalexdp = set(scaletemp*2.*iResolution.x/iResolution.y);\n        vec2 scaleydp = set(scaletemp*2.);\n    \n        vec2 mmx = set(mm.x-.5);\n        vec2 mmy = set(mm.y-.5);\n    \n        vec2 offxdp = mul( mmx, scalexdp );\n        vec2 offydp = mul( mmy, scaleydp );\n\n        vec4 offsetdp = vec4( offxdp, offydp );\n      \n        storedOffset = dcAdd( storedOffset, offsetdp);\n      \n        \n      }\n      \n      O = vec4(storedOffset);\n\n    }\n    \n  }\n  \n  else if (iU == ivec2(1) ) {\n  \n     if ( iFrame < 10 ) {\n       O = vec4(0,0,0,0);\n     }\n     else {\n  \n       //need to keep track of Zoom Level\n       vec4 ik = handleKeyboard(); \n       vec4 storedZoom = texelFetch( iChannel0, iU, 0);\n       \n       if ( ik[0] > 0. ) {\n         storedZoom[0] = .01;\n       }\n       else if (ik[0] < 0. ) {\n         storedZoom[0] = -.01;\n       }\n       else if (ik[1] > 0. ) {\n         storedZoom[0] = 0.;\n       }\n       \n       storedZoom[1] += storedZoom[0];\n       \n       O = storedZoom;\n    \n     }\n  \n  }\n  \n  else if ( iU == ivec2(2) ) {\n  \n     //anti Alias toggle\n     \n     float keyA = texelFetch(iChannel1, ivec2(65,0),0).x;\n     vec4  aa = texelFetch(iChannel0, iU, 0);\n     \n     if (keyA > 0. ) {\n       aa.x = aa.x > 0. ? 0. : 1.;  //toggle\n     }\n     \n     O = aa;\n     \n  }\n   \n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// I did not come up with this code - it already was working in https://www.shadertoy.com/view/WsXGzj\n// where he made the following comments:\n\n// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n//\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n// Substract: res = ds_add(a, b) => res = a + b\n    \nconst float init_scale = 1.0;\nconst float timeFac = .2;\n#define ZOOM_LEVEL init_scale / exp(storedZoom[1])\n    \nfloat times_frc(float a, float b) {\n  return mix(0.0, a * b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat plus_frc(float a, float b) {\n  return mix(a, a + b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat minus_frc(float a, float b) {\n  return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);\n}\n\n// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n//\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n// Substract: res = ds_add(a, b) => res = a + b\nvec2 add (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float t1, t2, e;\n\n  t1 = plus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = plus_frc(plus_frc(plus_frc(minus_frc(dsb.x, e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Substract: res = ds_sub(a, b) => res = a - b\nvec2 sub (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float e, t1, t2;\n\n  t1 = minus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = minus_frc(plus_frc(plus_frc(minus_frc(minus_frc(0.0, dsb.x), e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat cmp(vec2 dsa, vec2 dsb) {\n  if (dsa.x < dsb.x) {\n    return -1.;\n  }\n  if (dsa.x > dsb.x) {\n    return 1.;\n  }\n  if (dsa.y < dsb.y) {\n    return -1.;\n  }\n  if (dsa.y > dsb.y) {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Multiply: res = ds_mul(a, b) => res = a * b\nvec2 mul (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float c11, c21, c2, e, t1, t2;\n  float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n  cona = times_frc(dsa.x, split);\n  conb = times_frc(dsb.x, split);\n  a1 = minus_frc(cona, minus_frc(cona, dsa.x));\n  b1 = minus_frc(conb, minus_frc(conb, dsb.x));\n  a2 = minus_frc(dsa.x, a1);\n  b2 = minus_frc(dsb.x, b1);\n\n  c11 = times_frc(dsa.x, dsb.x);\n  c21 = plus_frc(times_frc(a2, b2), plus_frc(times_frc(a2, b1), plus_frc(times_frc(a1, b2), minus_frc(times_frc(a1, b1), c11))));\n\n  c2 = plus_frc(times_frc(dsa.x, dsb.y), times_frc(dsa.y, dsb.x));\n\n  t1 = plus_frc(c11, c2);\n  e = minus_frc(t1, c11);\n  t2 = plus_frc(plus_frc(times_frc(dsa.y, dsb.y), plus_frc(minus_frc(c2, e), minus_frc(c11, minus_frc(t1, e)))), c21);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n\n  return dsc;\n}\n\n// create double-single number from float\nvec2 set(float a) {\n  return vec2(a, 0.0);\n}\n\nfloat rand(vec2 co) {\n  // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\n// double complex multiplication\nvec4 dcMul(vec4 a, vec4 b) {\n  return vec4(sub(mul(a.xy,b.xy),mul(a.zw,b.zw)),add(mul(a.xy,b.zw),mul(a.zw,b.xy)));\n}\n\nvec4 dcAdd(vec4 a, vec4 b) {\n  return vec4(add(a.xy,b.xy),add(a.zw,b.zw));\n}\n\n// Length of double complex\nvec2 dcLength(vec4 a) {\n  return add(mul(a.xy,a.xy),mul(a.zw,a.zw));\n}\n\nvec4 dcSet(vec2 a) {\n  return vec4(a.x,0.,a.y,0.);\n}\n\nvec4 dcSet(vec2 a, vec2 ad) {\n  return vec4(a.x, ad.x,a.y,ad.y);\n}\n\n// Multiply double-complex with double\nvec4 dcMul(vec4 a, vec2 b) {\n  return vec4(mul(a.xy,b),mul(a.wz,b));\n}\n\nvec4 dcSub(vec4 a, vec4 b) {\n\treturn vec4(sub(a.xy,b.xy),sub(a.zw,b.zw));\n}\n\n\n\n","name":"Common","description":"","type":"common"}]}