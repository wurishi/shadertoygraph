{"ver":"0.1","info":{"id":"3ljczy","date":"1595009191","viewed":304,"name":"shutter vidscreen","username":"Carandiru","description":"another gif for a game I make\n :P","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["led","shutterstock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3ljczy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n//\nconst float PANEL_SZ = 1.0f; // watch-out!\nconst float COL = 512.0f * PANEL_SZ;\nconst float HCOL = COL * 0.5f;\nconst float ROW = 144.0f * PANEL_SZ;\n\nconst float LED_SZ = 0.5f; // ok\nconst float LED_SPRITE = 0.666f; // ok\nconst vec3 LUMA = vec3(0.2126f, 0.7152f, 0.0722f);\n#define SEED (slow_time * GOLDEN_RATIO * 100.0f)\n\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_MIN_ONE (GOLDEN_RATIO - 1.0)\n#define GOOD_COLOR (vec3(239.0/255.0, 6.0/255.0, 105.0/255.0))\n\n#define LINE (0.01666f)\n#define BEGIN (0.3333f * 0.5f)\n#define END (1.0f - BEGIN)\n#define SEP ((1.0f / LINE) * 0.74f)\n\n// iq goodness\nvec2 rndC(in vec2 pixel) // good function, works with any texture sampling that uses interpolation\n{\n    pixel = pixel + 0.5f;\n    vec2 ipixel = floor( pixel );\n    vec2 fpixel = fract( pixel );\n    \n\tpixel = ipixel + fpixel*fpixel*(3.0f-2.0f*fpixel); \n \n\treturn(pixel - 0.5f);  // returns in same unit as input, pixels\n}\n\nfloat rand(in float t)\n{\n    t *= 1.0f / iChannelResolution[2].x;\n    t = fract(t);\n    return textureLod(iChannel2, vec2(t, fract(GOLDEN_RATIO * t)), 0.0f).r;\n}\n\nvec2 rotate(vec2 a,float b) {\n    return vec2(a.x*cos(b)-a.y*sin(b),a.x*sin(b)+a.y*cos(b));\n}\n\nfloat screen(in vec2 uv) {\n    float s = texture(iChannel1,uv).b;\n    return s;\n}\n\n\nvec4 light(vec2 coord, in float luma, out float led, out vec4 ledll){\n\tfloat x = mod(coord.x,COL)-(HCOL);\n\tfloat y = floor(coord.y/ROW);\n    x*=LED_SZ * 2.0f;\n    y*=LED_SZ * 2.0f;\n    y+=LED_SZ * 2.0f;\n    \n    led = screen(vec2(x + SEED,y) / vec2(COL,ROW)) * (LED_SZ + luma * LED_SZ);\n    float sprite = led * LED_SPRITE;\n    ledll = vec4(x-sprite,x+sprite,y+sprite,y-sprite);\n    \n    return vec4(x-LED_SZ,x+LED_SZ,y+LED_SZ,y-LED_SZ);\n}\nvec3 lum(vec2 coord, out float luma){\n\tfloat x = mod(coord.x,COL)-(HCOL);\n\tfloat y = floor(coord.y/ROW);\n    \n    vec2 uv = vec2(x + iTime * 0.5f,y);\n     \n    vec3 rgb = texture(iChannel0,uv*0.125f).rgb;\n        \n    rgb /= max(rgb.x,max(rgb.y,rgb.z));\n    rgb.x=pow(rgb.x,3.3f);\n    rgb.y=pow(rgb.y,3.3f);\n    rgb.z=pow(rgb.z,3.3f);\n    \n    luma = dot(rgb, LUMA);\n    \n    return rgb * screen(vec2(x + SEED,y) / vec2(COL,ROW));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float pi=acos(-1.);\n    vec2 uv=fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float time=iTime*.1;\n    vec3 cam=vec3(0.0,1.7,-4.5);\n    vec3 dir=normalize(vec3(uv,1));\n    \n    \n    float tw=-cam.z/dir.z;\n    float tf=-cam.y/dir.y;\n\tconst float PI = acos(-1.);\n    \n    vec3 color=vec3(0);\n\n    \n    vec3 hit=cam+dir*tw;\n\n    float led;\n    vec4 ledll;\n\n    float luma;\n    vec3 col1=lum(fragCoord.xy, luma);\n    vec4 l1 = light(fragCoord.xy, luma, led, ledll);\n\n\n    vec2 mid=(l1.xz+l1.yw)*.5;\n    vec2 rad=(l1.yz-l1.xw)*.5;\n    vec2 a=(rad-abs(hit.xy-mid))*iResolution.y*.25+.5;\n\n    vec2 midled=(ledll.xz+ledll.yw)*.5;\n    vec2 radled=(ledll.yz-ledll.xw)*.5;\n    vec2 aled=(radled-abs(hit.xy-midled))*iResolution.y*.25+.5;\n\n    float ledmin = clamp(min(aled.x,aled.y),0.,1.);\n    float ledmax = clamp(min(a.x,a.y),0.,1.);\n\n    color += col1 * (ledmax - ledmin) * 100.0f;\n    \n    color += dot(texture(iChannel1,uv).rgb, LUMA);\n    \n    float sides = 0.0f;\n    float y = BEGIN;\n    \n    float r = rand(iTime * GOLDEN_RATIO + uv.x * GOLDEN_RATIO_MIN_ONE);\n    r = 1.0f - r;\n    \n    do {\n        \n        float d, h, w;\n        \n        d = ((uv.y + 0.46f) - y);\n        h = abs(LINE / d);\n        w = smoothstep(0.0f, step(0.5f, uv.x), r);\n        \n        sides += h * w;\n        \n        d = ((uv.y - 0.46f) - 0.5f + y);\n        h = abs(LINE / d);\n        w = (1.0f - w);\n        \n        sides += h * w;\n        \n        y += SEP / iResolution.y;\n    \n    } while( y < (END * r) );\n    \n    sides = smoothstep(0.0f, 1.0f, sides);\n    \n    color += GOOD_COLOR * sides;\n    \n    // add some regular blue noise to hide the banding\n    fragColor = vec4(color,1) + texelFetch(iChannel2,ivec2(fragCoord)&1023, 0) * (17.0f/255.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3ljczy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nconst float GOLDEN_RATIO = 1.6180339887498948f;\n\n\n#define slow_time (iTime * 0.001f)\n\nfloat trunct(float x, float num_levels)\n{\n    return floor(x * num_levels) / num_levels;\n}\nfloat random(vec2 uv, float scale){\n\treturn fract(sin(dot(floor(uv * scale), vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat random(in vec2 st){\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat random(in float p){\n    return fract(sin(p) * 100000.0);\n}\n\n\n// https://www.shadertoy.com/view/MlfXzN (modified)\nvec3 matrix(in vec3 color, in vec2 st, float t){\n    float rows = 18.0;\n    vec2 ipos = floor(st*rows);\n\n    ipos += vec2(floor(t*20.),.0);\n\n    vec2 fpos = fract(st*rows);\n    vec2 center = (.5-fpos);\n\n    float pct = random(ipos.x);\n    float glow = (1.-dot(center,center)*pct*2.0)*2.0;\n\n    return color * vec3(random(ipos) * pct * glow);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3ljczy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nconst vec3 left = vec3(1,0,0);\nconst vec3 right = vec3(0,0,1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color = vec3(0); //vec3(abs(uv.x * 2.0f - 1.0f));\n    \n    vec2 side_left = vec2(uv.x,uv.y);\n    \n    vec2 side_right = vec2(1.0f - side_left.x, uv.y);\n    \n    color += side_left.x * matrix(left, uv, iTime); \n    color += side_right.x * matrix(right, side_right, iTime); \n      \n    fragColor = vec4(color, 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3ljczy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n\n    // Define the bluring radius/strength (direction independant)\n    vec2 radius = vec2(60);\n    // Calculate the value at the corners so that the matrix can be easily inverted\n    float maxi = radius.x*radius.y;\n    // Define the variable which will hold the blured values\n    vec3 blur = vec3(0.0);\n\n    // Define the variable which will be used to normalize the image\n    float sum = 0.0;\n    // The kernel is dynamically created based on the bluring radius\n        for(float v = -radius.x; v<=radius.x; v++){\n            // The pixel weight used by the kernel is defined as: the distance from the kernel origin (0,0)\n            // to the current kernel position, subtracted from the maximum possible distance. This leads\n            // to a gradient from 0% relative weight on the edges to 100% relative weight at the origin of the kernel\n            float weight = abs(maxi - radius.y*v);\n            // The weight is then exponentialized which seams to sleightly maintain more of the origianl detail\n            //weight = pow(weight, 2.0);\n            // The weight is then multiplied by the texture being sampled and added to the overall blurred values\n            vec2 new_uv = uv + vec2(v, radius.y)/iResolution.xy;\n            blur += weight * texture( iChannel0, new_uv ).rgb;\n              \n            \n            // The weight is then added for normalizing purposes\n            sum += weight;\n        }\n\n    // Finally the blurred image is normalized\n    blur /= sum;\n\n    // Output to screen\n    fragColor = vec4(blur, 1.0f);\n}","name":"Buffer B","description":"","type":"buffer"}]}