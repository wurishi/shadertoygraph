{"ver":"0.1","info":{"id":"XdKSD3","date":"1538013552","viewed":1188,"name":"ShaneCopy","username":"bergi","description":"Displacing a plane with with a nicely antialiased kaliset texture, rendering in Shane's excellent environment from  \n[url=https://www.shadertoy.com/view/MsySWK]Raymarched 2D Sierpinski[/url]. Be sure to watch in fullscreen, for it is quite fast. ","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["displacement","kaliset","bumpmapping","mapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Taken completely from Shane, https://www.shadertoy.com/view/MsySWK\n\n/*\n\n\tRaymarched 2D Sierpinski\n\t------------------------\n\n\tRaymarching a 2D Sierpinski Carpet pattern. The raymarching process is pretty straight\n\tforward. Basically, Sierpinski height values are added to a plane. Height maps with \n\tsharp edges don't raymarch particularly well, so a little edge smoothing was necessary,\n\tbut that's about it.\n\n\tThe rest is just lighting. Most of it is made up. A bit of diffuse, specular, fake \n\tenvironment mapping, etc.\n\t\n\n*/\n\n#define FAR 5.\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Sierpinski Carpet heightmap - Essentially, space is divided into 3 each iteration, \n// and a shape of some kind is rendered. In this case, it's a smooth edged rectangle (w)\n// with a bit of curvature (l) around the sides.\n//\n// There are some opportunites to optimize, but I'll leave it partly readable for now.\n//\nfloat heightMap2(vec2 p){\n    \n    p /= 2.; // Extra scaling.\n    \n    float  h = 0., a = 1., sum = 0.; // Height, amplitude, sum.\n    \n    for(int i=0; i<4; i++){\n    \n        p = fract(p)*2.666; // Subdividing space.\n        // Far more interesting, mutated subdivision, courtesy of Aiekick.\n        //p = fract(p+sin(p.yx*9.)*0.025 + cos(p.yx*9.)*0.025)*3.; \n        // Another one with a time component.\n        //p = fract(p + sin(p*9. + cos(p.yx*13. + iTime*2.))*0.02)*3.;\n        \n        vec2 w = .5 - abs(p - 1.5); // Prepare to make a square. Other shapes are also possible.\n        float l = sqrt( max(16.0*w.x*w.y*(1.0-w.x)*(1.0-w.y), 0.))*.5+.5; // Edge shaping.\n        w = smoothstep(0., .05, w); // Smooth edge stepping.\n        h = max(h, w.x*w.y*a*l); // Producing the smooth edged, shaped square.\n        //h += w.x*w.y*a*l;\n        //h = max(h, abs(abs(w.x)-abs(w.y))*a*l);\n        sum += a; // Keep a total... This could be hardcoded to save cycles.\n        a *= .4; // Lower the amplitude for the next subdivision, just because it looks tidier.\n        //if(i==2)a*=.75;\n    }\n    \n    return h/sum;\n    \n}\n\nfloat heightMap3(in vec2 pos)\n{\n    pos /= 7.;\n    vec2 m1 = mod(pos, 1.), m2 = mod(pos, 2.);\n    pos = mix(m1, 1.-m1, max(vec2(0.), sign(m2-1.)));\n    //if (m2.x >= 1.) m1.x = 1. - m1.x;\n    //pos = m1;\n    pos += vec2(4,.5);\n    vec3 p = vec3(pos, 1.);\n    float d = 0.;\n    for (int i=0; i<24; ++i)\n    {\n        p = abs(p) / dot(p.xy, p.xy);\n        //d = min(d, exp(- p.x/p.z));\n        d += 1.*( exp(-p.x/p.z*(1.+1.*float(i*i))) )/float(1+i);\n        if (float(i)>(18.+6.*sin(iTime)))\n            break;\n        p.xy -= .99;//+.02*sin(iTime);\n    }\n    return d;//smoothstep(0.1,.0, d);\n}\n\nfloat heightMap(in vec2 uv)\n{\n    uv /= 6.;\n    // mirror repeat\n\tvec2 m1 = mod(uv, 1.), m2 = mod(uv, 2.);\n    uv = mix(m1, 1.-m1, max(vec2(0.), sign(m2-1.)));\n    \n    vec4 k = texture(iChannel1, uv);\n\treturn 0.2*k.x;    \n}\n\n\n// Raymarching a heightmap on an XY-plane. Pretty standard.\nfloat map(vec3 p){\n\n    // Cheap, lame distortion, if you wanted it.\n    //p.xy += sin(p.xy*7. + cos(p.yx*13. + iTime))*.01;\n    \n    // Back plane, placed at vec3(0, 0, 1), with plane normal vec3(0., 0., -1).\n    // Adding some height to the plane from the heightmap. Not much else to it.\n    float d = 1. - p.z;\n    //if (d<0.2) \n        d-= heightMap(p.xy)*.125;\n    return d;\n    \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Standard normal function.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 3., occ = 0.;\n    for(int i=0; i<5; i++){\n    \n        float hr = .01 + float(i)*.5/4.;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    // Note that the ray is starting just above the raised plane, since nothing is\n    // in the way. It's normal practice to start at zero.\n    float d, t = 0.75; \n    for(int j=0;j<32;j++){\n      \n        d = map(ro + rd*t); // distance to the function.\n        // The plane \"is\" the far plane, so no far=plane break is needed.\n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n\n        t += d*.7; // Total distance from the camera to the surface.\n    \n    }\n\n    return min(t, FAR);\n    \n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// It gives you a scalar curvature value for an object's signed distance function, which \n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n// calculations, I'm assuming. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p){\n\n    const float eps = 0.02, amp = 8., ampInit = 0.6;\n\n    vec2 e = vec2(-1., 1.)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 envMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.075;\n    rd *= 3.;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit directional ray with no divide, courtesy of Coyote.\n    vec3 rd = normalize(vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n    \n    // Rotating the XY-plane back and forth, for a bit of variance.\n    // 2D rotation with fewer instructions, courtesy of Fabrice Neyret.\n    vec2 a = sin(vec2(1.570796, 0) - sin(iTime/4.)*.3);\n    rd.xy = rd.xy*mat2(a, -a.y, a.x);\n    \n    \n    // Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(iTime/5., cos(iTime/4.), 0.);\n    \n    //fragColor = vec4( envMap(rd, vec3(1,1,1)), 1.);\n    //return;\n    \n    // Light position, hovering around camera.\n    vec3 lp = ro + vec3(cos(iTime/2.)*.5, sin(iTime/2.)*.5, -.5);\n    \n    // Standard raymarching segment. Because of the straight forward setup, not many \n    // iterations are needed.\n \tfloat t = trace(ro, rd);\n    \n   \n    // Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    vec3 sn = getNormal(sp);\n    \n    \n\t// Texture scale factor.\n    const float tSize0 = 1./2.;\n    // Texture-based bump mapping.\n\tsn = doBumpMap(iChannel0, sp*tSize0, sn, 0.002);    \n    \n    \n    // Point light.\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld), 0.001); // Light distance.\n    float atten = 1./(1. + lDist*lDist*.125); // Light attenuation.\n    ld /= lDist; // Normalizing the light direction vector.\n    \n   // Obtaining the surface texel, then ramping up the contrast a bit.\n    vec3 oC = smoothstep(0., 1., tex3D(iChannel0, sp*tSize0, sn));\n    // Using the height map to highlight the raised squares. Not for any particular reason.\n    oC *= smoothstep(0., .125, heightMap(sp.xy))*1.5 + .5;\n\n    \n    float diff = max(dot(ld, sn), 0.); // Diffuse.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.); // Specular.\n    float fre = clamp(dot(sn, rd)+1., .0, 1.); // Fake fresnel, for the glow.\n    \n    // Shading. Note, there are no actual shadows. The camera is front on, so the following\n    // two functions are enough to give a shadowy appearance.\n    float crv = curve(sp); // Curve value, to darken the crevices.\n    float ao = calculateAO(sp, sn); // Ambient occlusion, for self shadowing.\n \n    \n    // Combining the terms above to light the texel.\n    vec3 col = (oC*(diff + .25) + vec3(1, .7, .3)*spec) + vec3(.1, .3, 1)*pow(fre, 4.)*4.;\n    \n    col += (oC*.5+.5)*envMap(reflect(rd, sn), sn)*6.; // Fake environment mapping.\n    //col += envMap(reflect(rd, sn), sn)*4.;\n    \n    // Applying the shades.\n    col *= (atten*crv*ao);\n    \n    // Vignette.\n    vec2 uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125);\n\n    \n    // Presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 hash2(in vec2 p) { return fract(sin(p*vec2(3,7))*(9867.+p.x*17.-p.y*11.)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc = (fragCoord);\n\tvec2 suv = fc.xy / iResolution.xy;\n\tvec2 uv = (fc.xy - iResolution.xy*.5) / iResolution.y * 2.;\n\tvec2 seed = sin(uv+iTime)*999.;\n    \n    // x,y, mindist, mindist\n    vec4 kali = texture(iChannel0, suv);\n    \n    if (iFrame > 20 && false)\n    {\n        fragColor = kali;\n        return;\n    }\n    \n    float ti = (iTime);\n\t\n    vec2 resdif = texture(iChannel0, vec2(.5)/iResolution.xy,-100.).xy - iResolution.xy;\n    \n    // reset\n\tif (iFrame < 1 \n        || int(mod(float(iFrame), 10.)) == 0\n        || dot(resdif,resdif)>1.\n       )\n    {\n        // pos to sample from\n\t    vec2 aa = hash2(fragCoord+sin(iTime)) / iResolution.xy;\n        vec2 pos = vec2(suv+aa);\n        \n        kali = vec4(pos, 1., 1.);\n        fragColor = kali;\n    }\n    //float iter = float(iFrame);\n    \n    for (int i=0; i<4; ++i)\n    {\n        kali.xy = abs(kali.xy) / dot(kali.xy, kali.xy);\n        kali.zw = min(kali.zw, float(1+i*i)*vec2(kali.x, dot(kali.xy,kali.xy)));\n        kali.xy -= 1.;//+.01*sin(ti/140.);\n    }\n    \n    fragColor = kali;\n    \n    if (fragCoord.x < 1. && fragCoord.y < 1.)\n        fragColor.xy = iResolution.xy;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n\n    vec4 kali = texture(iChannel0, suv);\n    vec4 prev = texture(iChannel1, suv);\n       \n\tvec2 resdif = texture(iChannel1, vec2(.5)/iResolution.xy,-100.).xy - iResolution.xy;\n\n\tif (iFrame < 2 || dot(resdif, resdif)>1.)\n    {\n        fragColor = vec4(0,0,0,1);\n    }\n    else\n    {\n        fragColor = prev;\n        if (int(mod(float(iFrame+1), 10.)) == 0)\n        {\n            kali = vec4(pow(1.-kali.z,40.));\n        \tfragColor = mix(prev, kali, 1./min(float(10+iFrame/7),150.));\n        }\n    }\n\n\tif (fragCoord.x < 1. && fragCoord.y < 1.)\n        fragColor.xy = iResolution.xy;\n}","name":"Buffer B","description":"","type":"buffer"}]}