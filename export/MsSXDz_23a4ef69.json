{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":2,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//// input\n// keys\nint kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\n#define kRed k1\n#define kGreen k2\n#define kBlue k3\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKeyBool( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat ReadKeyFloat( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn step(.5,keyVal);\n}\n\n\n//// convert screen coords to -asp to +asp for x, -1 to +1 for y, asp = aspect ratio\n// normalized device coords\nvec2 ndc(vec2 p)\n{\n    p *= 2.0/iResolution.y;\n    p += vec2(-iResolution.x/iResolution.y,-1.0);\n\treturn p;\n}\n\n// generate a 2d rotation matrix\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n\n//// raytrace plane\n// return color of plane at xyz, this plane is at y = 0\nvec3 planeColor(vec3 loc,bool pc)\n{\n    float lodBias = -.2;\n    vec3 ret3 = texture(iChannel2,vec2(loc.x,-loc.z),lodBias).xyz;\n    if (pc) {\n        if (loc.x >= 0.0)\n        \tret3.r += .25;\n    \tif (loc.z >= 0.0)\n        \tret3.g += .25;\n        if (fract(loc.x*.05) >= .5)\n            ret3.r -= .15;\n        if (fract(loc.z*.05) >= .5)\n            ret3.g -= .15;\n    }\n\treturn ret3;\n}\n\n\n//// sky and plane\nvec3 skyPlane(vec3 rs,vec3 rd,bool planeaxis) // unnormalized direction\n{\n// sky color\n    vec3 skycolor = vec3(0.0,0.0,1.0) - vec3(0.0,0.0,rd.y);\n    \n    // plane color\n    float t = -rs.y/rd.y;\n    vec3 isect = rs + rd*t;\n    vec3 planecolor = planeColor(isect,planeaxis);\n    \n    vec3 skyplanecolor;\n    if (rd.y >= 0.0)\n        skyplanecolor = skycolor;\n    else\n        skyplanecolor = planecolor;\n    return skyplanecolor;\n}\n\n\n//// raymarch\nfloat sdSphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p,vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// h.x = radius h.y = height\nfloat sdCappedCylinder(vec3 p,vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// n.w is the distance from origin to the plane P*N = D\nfloat sdPlane(vec3 p,vec4 n)\n{\n  // n.xyz must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// CSG Union d1 U d2\nfloat opU(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n// CSG Intersection d1 ^ d2\nfloat opI(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n// CSG Subtract d1 - d2\nfloat opS(float d1,float d2)\n{\n    return max(d1,-d2);\n}\n\nfloat scene1(vec3 p)\n{\n    vec3 pr = p;\n    //pr.x += 4.0;\n    pr.xy *= rot(iTime*.5);\n    pr.xz *= rot(iTime*.25);\n    float d1 = sdBox(pr,vec3(.5,1.0,1.5));\n    //float d1 = sdBox(pr,vec3(.25,.5,.75));\n    float d2 = sdSphere(p,1.0); // p or pr, it's a sphere\n    //float d3 = sdTorus(pr,vec2(1.0,.25));\n    //float d4 = sdCappedCylinder(pr,vec2(.25,1.0));\n    //return opU(d1,d2);\n    //return opI(d1,d2);\n    return opS(d1,d2);\n    //return opS(d2,d1);\n    //return d1;\n    //return d2;\n    //return d3;\n    //return d4;\n}\n\nfloat opRep_scene1(vec3 p,vec3 c)\n{\n    vec3 q;\n\tq = mod(p+.5*c,c)-.5*c;\n    return scene1(q);\n}\n\nfloat opRepLimit_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat opRepLimitCenter_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 lm1 = lim-vec3(1.0);\n    p += c*.5*lm1;\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat scene2(vec3 p)\n{\n\treturn opRep_scene1(p,vec3(10.0));\n}\n\nfloat scene3(vec3 p)\n{\n\treturn opRepLimit_scene1(p,vec3(10.0),vec3(2.0,3.0,4.0));\n}\n\nfloat scene4(vec3 p)\n{\n\tfloat rs1 = opRepLimitCenter_scene1(p,vec3(10.0),vec3(9.0));\n    //float pn = sdPlane(p,vec4(0.0,0.0,-1.0,10.0));\n    //float pn = sdPlane(p,vec4(.7071,0.,-.7071,7.071));\n    //return opU(rs1,pn);\n    return rs1;\n}\n\nvec3 march(vec3 rs,vec3 rd,out bool hit)\n{\n    vec3 col = vec3(1.0,0.0,0.0);\n    float compensate = .87;\n    const int steps = 180;\n    float eps = .001;\n    float toobig = 1000.0;\n    //hit = false;\n    for (int i=0;i<steps;++i) {\n        //float d = scene1(rs);\n        //float d = scene2(rs);\n        //float d = scene3(rs);\n        float d = scene4(rs);\n  //        float d = .091;\n //       if (false) {\n //       //if (d > toobig) { // bail early if clearly can't hit anything\n //           hit = false;\n //          break;\n //       }\n        if (d < eps) {\n        //if (true) {\n    \t\tcol.g = float(i)*(10.0/256.0); \n            if (rs.y >= 0.0)\n                hit = true;\n            //break;\n            return col;\n        }\n        rs += rd*d*compensate;\n    }\n    //hit = true;\n\n    return col;\n}\n\n\n//// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool roll = ReadKeyBool(k1,true);\n    bool planeaxis = !ReadKeyBool(k2,true);\n    bool movexy = ReadKeyBool(k3,true);\n\n    // ndc\n    vec2 pos = ndc(fragCoord.xy);\n    vec2 mouse = vec2(0.0,0.0);\n    \n    //if (iMouse.z > 0.0)\n    \tmouse = ndc(iMouse.xy);\n    \n    // keyboard color, for circle (press 1,2,3)\n    vec3 keycolor = vec3(ReadKeyFloat(kRed,true),\n             ReadKeyFloat(kGreen,true),\n             ReadKeyFloat(kBlue,true));\n    \n    //// camera\n    const float zoom = 2.0;\n    // make a ray, left handed coords\n    vec3 rs;\n    if (movexy) {\n\t    rs = vec3(0.0,60.0,-60.0) + vec3(mouse*59.99,0.0); // ray start\n    } else {\n\t    rs = vec3(0.0,12.0,-3.0); // ray start\n    }\n    vec3 rd = vec3(pos,1.0); // ray direction\n    // zoom factor\n    rd.xy /= zoom;\n    if (!movexy) {\n        rd.yz *= rot(mouse.y*3.14 ); // pitch\n        if (roll)\n            rd.xy *= rot(mouse.x*3.14 ); // roll\n        else\n            rd.xz *= rot(mouse.x*3.14 ); // yaw\n    }\n    vec3 nrd = normalize(rd); // normalized for the marching, unnormalized for the sky gradient\n\n    \n    // cursor color\n    vec3 circlecolor = keycolor;\n    // is inside circle\n    vec2 del =  pos - mouse;\n    float d2 = dot(del,del);\n    float rad = 1.0/30.0;\n    bool iscursor = d2<rad*rad;\n    \n    // sky plane color\n    vec3 skyplanecolor = skyPlane(rs,rd,planeaxis); // do this with an unnormalized ray\n   \n    // march color\n    bool hit = false; // did hit something\n    vec3 marchcol = march(rs,nrd,hit);\n    \n    \n    // put it all together\n    vec3 comp;\n    if (iscursor)\n        comp = circlecolor;\n    else if (hit)\n\t\tcomp = marchcol;\n\telse\n        comp = skyplanecolor;\n\tfragColor = vec4(comp,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSXDz","date":"1411154754","viewed":185,"name":"marcher","username":"rickiters","description":"first pass at a ray marcher","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}