{"ver":"0.1","info":{"id":"XtGXWV","date":"1485884672","viewed":248,"name":"Atmospheric ","username":"binaryzebra","description":"Experiments with atmospheric scattering","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["atmosphericscattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\nfloat3 lightPosition0 = float3(1.0, 0.0, 0.0);\n\n#define EPSILON\t\t\t0.00001\n#define _PI\t\t\t\t3.1415926535897932384626433832795\n#define _2PI\t\t\t(3.1415926535897932384626433832795 * 2.0)\n#define _4PI \t\t\t(3.1415926535897932384626433832795 * 4.0)\n\n#define NUM_OUT_SCATTERING_STEPS 20.0\n#define NUM_OUT_SCATTERING_STEPS_I 20\n#define NUM_IN_SCATTERING_STEPS 20.0 \n#define NUM_IN_SCATTERING_STEPS_I 20\n\n#define PLANET_RADIUS 6.36\n#define ATMOSPHERE_RADIUS 6.42\n#define H0Rayleigh\t\t\t0.13333\n#define H0Mie\t\t\t\t0.02\n#define KRayleigh\t\t\tfloat3(0.058 * 1.0, 0.135 * 1.0, 0.331 * 1.0)\n#define KMie\t\t\t\tfloat(0.21)\n\n//float3 planetRadius = float3(0.0, 0.0, PLANET_RADIUS);\n\n/*float3 CartesianToSpherical(float3 v)\n{\n    float r = length(v);\n    float theta = acos(v.z / r);\n    float phi = atan(v.y, v.x);\n    return float3(r, theta, phi);\n}\n\nfloat3 SphericalToCartesian(float3 v)\n{\n    float x = v.x * sin(v.y) * cos(v.z);\n    float y = v.x * sin(v.y) * sin(v.z);\n    float z = v.x * cos(v.y);\n    return float3(x, y, z);\n}*/\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\nfloat3 CartesianToSpherical(float3 v)\n{\n\tfloat r = sqrt(\tv.x * v.x +\n\t\t\t\t\tv.y * v.y +\n\t\t\t\t\tv.z * v.z);\n\tfloat phi = acos(v.y / r);\n\tfloat theta = atan(v.x, v.z);\n\treturn float3(r, theta, phi);\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\nfloat3 SphericalToCartesian(float3 v)\n{\n\tfloat x = v.x/*r*/ * sin(v.z/*phi*/) * sin(v.y/*theta*/);\n\tfloat y = v.x/*r*/ * cos(v.z/*phi*/);\n\tfloat z = v.x/*r*/ * sin(v.z/*phi*/) * cos(v.y/*theta*/);\n\n\treturn float3(x, y, z);\n}\n\nfloat3 RaySphereIntersectionFast(float3 p, float3 v, float r)\n{\n//    v = -normalize(v);\n    float a = dot(v, v);\n    float b = dot(p, v) * 2.00001; // need to be *2. 2.00001 is placed to overcome compiler optimization bug(it omits multiplication by 2)\n    float c = dot(p, p) - r * r;\n    float d = b * b - 4.0 * a * c;\n\n    //if(D < 0) // - no intersection\n\n    float dist = (-b - sqrt(d)) / (a * 2.0);\n    return p + v * dist;\n}\n\nfloat RaySphereIntersectionFastDistance(float3 p, float3 v, float r)\n{\n    float a = dot(v, v);\n    float b = dot(p, v) * 2.00001; // need to be *2. 2.00001 is placed to overcome compiler optimization bug(it omits multiplication by 2)\n    float c = dot(p, p) - r * r;\n    float d = b * b - 4.0 * a * c;\n\n    //if(d > 0.0) // - no intersection\n\n    float dist = (-b - sqrt(d)) / (a * 2.0);\n    return dist;\n}\n\nfloat2 RaySphereIntersectionFastTwoPointsDistance(float3 p, float3 v, float r)\n{\n    float a = dot(v, v);\n    float b = dot(p, v) * 2.00001; // need to be *2. 2.00001 is placed to overcome compiler optimization bug(it omits multiplication by 2)\n    float c = dot(p, p) - r * r;\n    float d = b * b - 4.0 * a * c;\n\n    //if(D < 0) // - no intersection\n\n    float sqrd = sqrt(d);\n    return float2((-b - sqrd) / (a * 2.0), (-b + sqrd) / (a * 2.0));\n}\n\n/*\n,\tm_planet_radius\t\t\t\t(6.36f)\n,\tm_atmosphere_radius\t\t\t(6.42f)\n,\tm_rayleigh_H0\t\t\t\t(0.13333f)\n,\tm_mie_H0\t\t\t\t\t(0.02f)\n,\tm_rayleigh_K\t\t\t\t(0.058f * 5.0f, 0.135f * 5.0f, 0.331f * 5.0f, 0)\n,\tm_mie_K\t\t\t\t\t\t(0.21f)\n,\tm_multiplier_K\t\t\t\t(1.0f)\n*/\n    \nfloat4 OutScattering(float3 a, float3 b, float4 k, float2 H0)\n{\n    float atmosphereHeight = ATMOSPHERE_RADIUS - PLANET_RADIUS; \n\n    float3 dir = b - a;\n    float3 step = dir / NUM_OUT_SCATTERING_STEPS;\n    float stepLength = length(step);\n    float3 pos = a + step * 0.5;\n\n    float2 result = float2(0.0);\n    for (int i = 0; i < NUM_OUT_SCATTERING_STEPS_I; ++i)\n    {\n        float h = (length(pos) - PLANET_RADIUS) / atmosphereHeight;\n        h = max(0.0, h); \n        result += exp(-h / H0);\n        pos += step;\n    }\n    result *= stepLength;\n    return result.xxxy * k * _4PI;\n}\n\nfloat4 InScattering(float3 a, float3 b, float4 k, float2 H0, float3 lightDirection)\n{\n    float atmosphereHeight = ATMOSPHERE_RADIUS - PLANET_RADIUS; \n\n    float3 dir = b - a;\n    float3 step = dir / NUM_IN_SCATTERING_STEPS;\n    float stepLength = length(step);\n    float3 pos = a + step * 0.5;\n    \n    float4 result = float4(0.0);\n\n    for (int i = 0; i < NUM_IN_SCATTERING_STEPS_I; ++i)\n    {\n        float h = (length(pos) - PLANET_RADIUS) / atmosphereHeight;\n\t\th = max(0.0, h); // same question\n        float2 expIn = exp(-h / H0); \n\n        float3 atmosphereToSunPos = RaySphereIntersectionFast(pos, -lightDirection, ATMOSPHERE_RADIUS);\n        float4 outScatter1 = OutScattering(pos, atmosphereToSunPos, k, H0);\n        float4 outScatter2 = OutScattering(pos, a, k, H0);\n\t\tfloat4 outS = outScatter1 + outScatter2;\n        float4 expOut = exp(-outS);\n        \n        result += expIn.xxxy * exp(-(outScatter1 + outScatter2));\n        \n        //result += float4(outScatter1.xyz, 1.0);\n        pos += step; \n    }\n    result *= stepLength;\n\n    return result * k;\n}\n\nfloat RayleighPhase(float mu)\n{\n    float mu2 = mu * mu;\n    return (3.0 / 4.0) * (1.0 + mu2);\n}\n\nfloat MiePhase(float mu)\n{\n    float mu2 = mu * mu;\n    float g = -0.99;\n    float g2 = g * g;\n    return (3.0 * (1.0 - g2) / (2.0 * (2.0 + g2))) * (1.0 + mu2) / pow((1.0 + g2 - 2.0 * g * mu), 3.0 / 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    \n    float3 sphericalDirection = float3(1.0, (uv.x * 2.0 - 1.0) * _PI, uv.y * _PI);\n    float3 direction = SphericalToCartesian(sphericalDirection);\n    // always expect information about directional sun light\n    float3 sunDirection = normalize(lightPosition0.xyz);\n    float3 toLightDirection = -normalize(sunDirection);\n    float t = -0.16 + iTime;\n    toLightDirection = float3(sunDirection.x * cos(t) + sunDirection.y*sin(t),\n                              sunDirection.x * (-sin(t)) + sunDirection.y *cos(t), 0.0);\n    toLightDirection = normalize(toLightDirection);\n    \n    //float sunDirection\n    float wDotL = dot(direction, -toLightDirection);\n\n    //float3 sp = CartesianToSpherical(\n    \n    float3 startPos = float3(0.0, PLANET_RADIUS, 0.0);\n    float2 t2 = RaySphereIntersectionFastTwoPointsDistance(startPos, direction, ATMOSPHERE_RADIUS);\n    float3 atmospherePos = startPos + direction * t2.y;\n    \n    float4 scatterin2g = InScattering(startPos, atmospherePos, float4(KRayleigh, KMie), float2(H0Rayleigh, H0Mie), toLightDirection) * 10.0;\n    \n    \n    float fov = 90.0;\n    float imageAspectRatio = iResolution.x / iResolution.y; // assuming width > height \n\tfloat x = fragCoord.x;\n    float y = fragCoord.y;\n    \n    float Px = (2.0 * ((x + 0.5) / iResolution.x) - 1.0) * tan(fov / 2.0 * _PI / 180.0) * imageAspectRatio; \n\tfloat Py = (1.0 - 2.0 * ((y + 0.5) / iResolution.y)) * tan(fov / 2.0 * _PI / 180.0);\n\t\n    float3 rayOrigin = float3(0.0, 0.0, 0.0); \n\tfloat3 rayDirection = float3(Px, Py, -1) - rayOrigin; // note that this just equal to Vec3f(Px, Py, -1); \n\trayDirection = normalize(rayDirection); // it's a direction so don't forget to normalize \n    \n    float3 fcoo = CartesianToSpherical(rayDirection);\n    /*\n\t\t(uv.x * 2.0 - 1.0) * _PI, uv.y * _PI)\n\t*/\n    \n    float2  uvn = float2((fcoo.y / _PI + 1.0) / 2.0, fcoo.z / _PI);  \n    float4 scattering = texture(iChannel0, uvn.xy);\n  \n\t//fragColor = vec4((direction.x < 0.0) ? (1.0): (0.0),0.0, 0.0, 1.0);\n\tfragColor = vec4(scattering.xyz * RayleighPhase(wDotL)  + scattering.www * MiePhase(wDotL), 1.0);\n}\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    \n    float3 sphericalDirection = float3(1.0, (uv.x * 2.0 - 1.0) * _PI, uv.y * _PI);\n    float3 direction = SphericalToCartesian(sphericalDirection);\n    // always expect information about directional sun light\n    float3 sunDirection = normalize(lightPosition0.xyz);\n    float3 toLightDirection = -normalize(sunDirection);\n    float t = -0.16 + iTime;\n    toLightDirection = float3(sunDirection.x * cos(t) + sunDirection.y*sin(t),\n                              sunDirection.x * (-sin(t)) + sunDirection.y *cos(t), 0.0);\n    toLightDirection = normalize(toLightDirection);\n    \n    //float sunDirection\n    float wDotL = dot(direction, toLightDirection);\n\n    //float3 sp = CartesianToSpherical(\n    \n    float3 startPos = float3(0.0, PLANET_RADIUS, 0.0);\n    float2 t2 = RaySphereIntersectionFastTwoPointsDistance(startPos, direction, ATMOSPHERE_RADIUS);\n    float3 atmospherePos = startPos + direction * t2.y;\n    \n    float4 scattering = InScattering(startPos, atmospherePos, float4(KRayleigh, KMie), float2(H0Rayleigh, H0Mie), toLightDirection) * 10.0;\n    \n\t//fragColor = vec4((direction.x < 0.0) ? (1.0): (0.0),0.0, 0.0, 1.0);\n\tfragColor = vec4(scattering.xyz + scattering.www, 1.0);\n}*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\nfloat3 lightPosition0 = float3(1.0, 0.0, 0.0);\n\n#define EPSILON\t\t\t0.00001\n#define _PI\t\t\t\t3.1415926535897932384626433832795\n#define _2PI\t\t\t(3.1415926535897932384626433832795 * 2.0)\n#define _4PI \t\t\t(3.1415926535897932384626433832795 * 4.0)\n\n#define NUM_OUT_SCATTERING_STEPS 20.0\n#define NUM_OUT_SCATTERING_STEPS_I 20\n#define NUM_IN_SCATTERING_STEPS 20.0 \n#define NUM_IN_SCATTERING_STEPS_I 20\n\n#define PLANET_RADIUS 6.36\n#define ATMOSPHERE_RADIUS 6.42\n#define H0Rayleigh\t\t\t0.13333\n#define H0Mie\t\t\t\t0.02\n#define KRayleigh\t\t\tfloat3(0.058 * 1.0, 0.135 * 1.0, 0.331 * 1.0)\n#define KMie\t\t\t\tfloat(0.21)\n\n//float3 planetRadius = float3(0.0, 0.0, PLANET_RADIUS);\n\n/*float3 CartesianToSpherical(float3 v)\n{\n    float r = length(v);\n    float theta = acos(v.z / r);\n    float phi = atan(v.y, v.x);\n    return float3(r, theta, phi);\n}\n\nfloat3 SphericalToCartesian(float3 v)\n{\n    float x = v.x * sin(v.y) * cos(v.z);\n    float y = v.x * sin(v.y) * sin(v.z);\n    float z = v.x * cos(v.y);\n    return float3(x, y, z);\n}*/\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\nfloat3 CartesianToSpherical(float3 v)\n{\n\tfloat r = sqrt(\tv.x * v.x +\n\t\t\t\t\tv.y * v.y +\n\t\t\t\t\tv.z * v.z);\n\tfloat phi = acos(v.y / r);\n\tfloat theta = atan(v.x, v.z);\n\treturn float3(r, theta, phi);\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\nfloat3 SphericalToCartesian(float3 v)\n{\n\tfloat x = v.x/*r*/ * sin(v.z/*phi*/) * sin(v.y/*theta*/);\n\tfloat y = v.x/*r*/ * cos(v.z/*phi*/);\n\tfloat z = v.x/*r*/ * sin(v.z/*phi*/) * cos(v.y/*theta*/);\n\n\treturn float3(x, y, z);\n}\n\nfloat3 RaySphereIntersectionFast(float3 p, float3 v, float r)\n{\n//    v = -normalize(v);\n    float a = dot(v, v);\n    float b = dot(p, v) * 2.00001; // need to be *2. 2.00001 is placed to overcome compiler optimization bug(it omits multiplication by 2)\n    float c = dot(p, p) - r * r;\n    float d = b * b - 4.0 * a * c;\n\n    //if(D < 0) // - no intersection\n\n    float dist = (-b - sqrt(d)) / (a * 2.0);\n    return p + v * dist;\n}\n\nfloat RaySphereIntersectionFastDistance(float3 p, float3 v, float r)\n{\n    float a = dot(v, v);\n    float b = dot(p, v) * 2.00001; // need to be *2. 2.00001 is placed to overcome compiler optimization bug(it omits multiplication by 2)\n    float c = dot(p, p) - r * r;\n    float d = b * b - 4.0 * a * c;\n\n    //if(d > 0.0) // - no intersection\n\n    float dist = (-b - sqrt(d)) / (a * 2.0);\n    return dist;\n}\n\nfloat2 RaySphereIntersectionFastTwoPointsDistance(float3 p, float3 v, float r)\n{\n    float a = dot(v, v);\n    float b = dot(p, v) * 2.00001; // need to be *2. 2.00001 is placed to overcome compiler optimization bug(it omits multiplication by 2)\n    float c = dot(p, p) - r * r;\n    float d = b * b - 4.0 * a * c;\n\n    //if(D < 0) // - no intersection\n\n    float sqrd = sqrt(d);\n    return float2((-b - sqrd) / (a * 2.0), (-b + sqrd) / (a * 2.0));\n}\n\n/*\n,\tm_planet_radius\t\t\t\t(6.36f)\n,\tm_atmosphere_radius\t\t\t(6.42f)\n,\tm_rayleigh_H0\t\t\t\t(0.13333f)\n,\tm_mie_H0\t\t\t\t\t(0.02f)\n,\tm_rayleigh_K\t\t\t\t(0.058f * 5.0f, 0.135f * 5.0f, 0.331f * 5.0f, 0)\n,\tm_mie_K\t\t\t\t\t\t(0.21f)\n,\tm_multiplier_K\t\t\t\t(1.0f)\n*/\n    \nfloat4 OutScattering(float3 a, float3 b, float4 k, float2 H0)\n{\n    float atmosphereHeight = ATMOSPHERE_RADIUS - PLANET_RADIUS; \n\n    float3 dir = b - a;\n    float3 step = dir / NUM_OUT_SCATTERING_STEPS;\n    float stepLength = length(step);\n    float3 pos = a + step * 0.5;\n\n    float2 result = float2(0.0);\n    for (int i = 0; i < NUM_OUT_SCATTERING_STEPS_I; ++i)\n    {\n        float h = (length(pos) - PLANET_RADIUS) / atmosphereHeight;\n        h = max(0.0, h); \n        result += exp(-h / H0);\n        pos += step;\n    }\n    result *= stepLength;\n    return result.xxxy * k * _4PI;\n}\n\nfloat4 InScattering(float3 a, float3 b, float4 k, float2 H0, float3 lightDirection)\n{\n    float atmosphereHeight = ATMOSPHERE_RADIUS - PLANET_RADIUS; \n\n    float3 dir = b - a;\n    float3 step = dir / NUM_IN_SCATTERING_STEPS;\n    float stepLength = length(step);\n    float3 pos = a + step * 0.5;\n    \n    float4 result = float4(0.0);\n\n    for (int i = 0; i < NUM_IN_SCATTERING_STEPS_I; ++i)\n    {\n        float h = (length(pos) - PLANET_RADIUS) / atmosphereHeight;\n\t\th = max(0.0, h); // same question\n        float2 expIn = exp(-h / H0); \n\n        float3 atmosphereToSunPos = RaySphereIntersectionFast(pos, -lightDirection, ATMOSPHERE_RADIUS);\n        float4 outScatter1 = OutScattering(pos, atmosphereToSunPos, k, H0);\n        float4 outScatter2 = OutScattering(pos, a, k, H0);\n\t\tfloat4 outS = outScatter1 + outScatter2;\n        float4 expOut = exp(-outS);\n        \n        result += expIn.xxxy * exp(-(outScatter1 + outScatter2));\n        \n        //result += float4(outScatter1.xyz, 1.0);\n        pos += step; \n    }\n    result *= stepLength;\n\n    return result * k;\n}\n\nfloat RayleighPhase(float mu)\n{\n    float mu2 = mu * mu;\n    return (3.0 / 4.0) * (1.0 + mu2);\n}\n\nfloat MiePhase(float mu)\n{\n    float mu2 = mu * mu;\n    float g = -0.99;\n    float g2 = g * g;\n    return (3.0 * (1.0 - g2) / (2.0 * (2.0 + g2))) * (1.0 + mu2) / pow((1.0 + g2 - 2.0 * g * mu), 3.0 / 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    \n    float3 sphericalDirection = float3(1.0, (uv.x * 2.0 - 1.0) * _PI, uv.y * _PI);\n    float3 direction = SphericalToCartesian(sphericalDirection);\n    // always expect information about directional sun light\n    float3 sunDirection = normalize(lightPosition0.xyz);\n    float3 toLightDirection = -normalize(sunDirection);\n    float t = -0.16 + iTime;\n    toLightDirection = float3(sunDirection.x * cos(t) + sunDirection.y*sin(t),\n                              sunDirection.x * (-sin(t)) + sunDirection.y *cos(t), 0.0);\n    toLightDirection = normalize(toLightDirection);\n    \n    //float sunDirection\n    float wDotL = dot(direction, -toLightDirection);\n\n    //float3 sp = CartesianToSpherical(\n    \n    float3 startPos = float3(0.0, PLANET_RADIUS, 0.0);\n    float2 t2 = RaySphereIntersectionFastTwoPointsDistance(startPos, direction, ATMOSPHERE_RADIUS);\n    float3 atmospherePos = startPos + direction * t2.y;\n    \n    float4 scattering = InScattering(startPos, atmospherePos, float4(KRayleigh, KMie), float2(H0Rayleigh, H0Mie), toLightDirection) * 10.0;\n    \n\t//fragColor = vec4((direction.x < 0.0) ? (1.0): (0.0),0.0, 0.0, 1.0);\n\tfragColor = scattering.xyzw;\n    \n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    \n    float3 sphericalDirection = float3(1.0, (uv.x * 2.0 - 1.0) * _PI, uv.y * _PI);\n    float3 direction = SphericalToCartesian(sphericalDirection);\n    // always expect information about directional sun light\n    float3 sunDirection = normalize(lightPosition0.xyz);\n    float3 toLightDirection = -normalize(sunDirection);\n    float t = -0.16 + iTime;\n    toLightDirection = float3(sunDirection.x * cos(t) + sunDirection.y*sin(t),\n                              sunDirection.x * (-sin(t)) + sunDirection.y *cos(t), 0.0);\n    toLightDirection = normalize(toLightDirection);\n    \n    //float sunDirection\n    float wDotL = dot(direction, toLightDirection);\n\n    //float3 sp = CartesianToSpherical(\n    \n    float3 startPos = float3(0.0, PLANET_RADIUS, 0.0);\n    float2 t2 = RaySphereIntersectionFastTwoPointsDistance(startPos, direction, ATMOSPHERE_RADIUS);\n    float3 atmospherePos = startPos + direction * t2.y;\n    \n    float4 scattering = InScattering(startPos, atmospherePos, float4(KRayleigh, KMie), float2(H0Rayleigh, H0Mie), toLightDirection) * 10.0;\n    \n\t//fragColor = vec4((direction.x < 0.0) ? (1.0): (0.0),0.0, 0.0, 1.0);\n\tfragColor = vec4(scattering.xyz + scattering.www, 1.0);\n}*/","name":"Buf A","description":"","type":"buffer"}]}