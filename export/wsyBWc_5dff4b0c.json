{"ver":"0.1","info":{"id":"wsyBWc","date":"1609698976","viewed":117,"name":"Caves - WebGLSamples","username":"oneshade","description":"Underwhelming recreation of \"Caves\" by Jasmine Kent Langridge from [url=https://webglsamples.org/caves/caves.html]https://webglsamples.org/caves/caves.html[/url]. This one was hard! I even recreated the annoying controls for lack of a better idea :D","likes":3,"published":3,"flags":48,"usePreview":0,"tags":["procedural","recreation","caves","webglsamples"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nUnderwhelming recreation of \"Caves\" by Jasmine Kent Langridge:\nhttps://webglsamples.org/caves/caves.html\n\nIt is very slow so if you have suggestions for speeding it up,\nplease share them.\n\nMouse to rotate, arrow keys to move.\nClick to dig.\n*/\n\nfloat mapScene(in vec3 p) {\n    float bbox = max(abs(p.x), abs(p.z)) - 50.0;\n    float scene = max(abs(p.y + fnoise2D(p.xz)) - GROUND_THICKNESS, bbox);\n\n    // Draw each tunnel\n    float currentIndex = getCurrentIndex() + 3.0;\n    for (float i=0.0; i < currentIndex; i += 3.0) {\n        vec3 tunnelEntrance = getTunnelEntrance(int(i));\n        vec3 tunnelExit = getTunnelExit(int(i));\n        scene = max(scene, sdCutTunnel(p, tunnelEntrance, tunnelExit));\n        scene = smin(scene, sdTunnel(p, tunnelEntrance, tunnelExit), 2.0);\n    }\n\n    return scene;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy),\n                          mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy),\n                          mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx)));\n}\n\nvec3 material(in vec3 p, in vec3 n) {\n    p.xz = fract(p.xz / 16.0);\n    vec2 uv = p.xz;\n\n    vec3 tex1 = texture(iChannel1, uv).rgb;\n    vec3 tex2 = texture(iChannel2, uv).rgb;\n    vec3 tex3 = texture(iChannel3, uv).rgb;\n\n    return mix(mix(tex3, tex2, max(0.0, -n.y)), tex1, max(0.0, n.y));\n}\n\nmat3 getCamera(in vec2 viewDirection) {\n    // Turns yaw/pitch rotations into matrix\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),\n                vec3(s.x *  c.y, s.y, -c.x *  c.y));\n}\n\nmat2x3 getRay(in vec2 uv, in vec3 viewPosition, in mat3 camera) {\n    vec3 rayDirection = normalize(FOCAL_LENGTH * camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n    return mat2x3(viewPosition,\n                  rayDirection);\n}\n\nmat2x4 traceRay(in mat2x3 ray) {\n    float distanceTraveled = 0.0;\n    for (int iteration=0; iteration < MAX_ITERATIONS; iteration++) {\n        vec3 position = ray[0] + ray[1] * distanceTraveled;\n        float sceneDistance = mapScene(position);\n        if (abs(sceneDistance) < MIN_HIT_DISTANCE * (distanceTraveled + 1.0)) {\n            vec3 normal = getNormal(position);\n            return mat2x4(position, 1.0,\n                            normal, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            return mat2x4(0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.0);\n        }\n\n        distanceTraveled += sceneDistance;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 viewPosition = getViewPosition();\n    mat3 camera = getCamera(getViewDirection());\n    mat2x3 ray = getRay(uv, viewPosition, camera);\n\n    mat2x4 traceInfo = traceRay(ray);\n    if (traceInfo[0].w > 0.0) {\n        fragColor.rgb += material(traceInfo[0].xyz, traceInfo[1].xyz); // Apply material\n        fragColor.rgb *= max(AMBIENT, dot(traceInfo[1].xyz, LIGHT)); // Diffuse\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float mapScene(in vec3 p) {\n    float bbox = max(abs(p.x), abs(p.z)) - 50.0;\n    float scene = max(abs(p.y + fnoise2D(p.xz)) - GROUND_THICKNESS, bbox);\n\n    // Draw each tunnel\n    float currentIndex = getCurrentIndex() + 3.0;\n    for (float i=0.0; i < currentIndex; i += 3.0) {\n        vec3 tunnelEntrance = getTunnelEntrance(int(i));\n        vec3 tunnelExit = getTunnelExit(int(i));\n        scene = max(scene, sdCutTunnel(p, tunnelEntrance, tunnelExit));\n        scene = smin(scene, sdTunnel(p, tunnelEntrance, tunnelExit), 2.0);\n    }\n\n    return scene;\n}\n\nmat3 getCamera(in vec2 viewDirection) {\n    // Turns yaw/pitch rotations into matrix\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),\n                vec3(s.x *  c.y, s.y, -c.x *  c.y));\n}\n\nmat2x3 getRay(in vec2 uv, in vec3 viewPosition, in mat3 camera) {\n    vec3 rayDirection = normalize(FOCAL_LENGTH * camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n    return mat2x3(viewPosition,\n                  rayDirection);\n}\n\nmat2x4 traceRay(in mat2x3 ray) {\n    float distanceTraveled = 0.0;\n    for (int iteration=0; iteration < MAX_ITERATIONS; iteration++) {\n        vec3 position = ray[0] + ray[1] * distanceTraveled;\n        float sceneDistance = mapScene(position);\n        if (abs(sceneDistance) < MIN_HIT_DISTANCE * (distanceTraveled + 1.0)) {\n            return mat2x4(     position, 1.0,\n                          0.0, 0.0, 0.0, 0.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            return mat2x4(0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.0);\n        }\n\n        distanceTraveled += sceneDistance;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    ivec2 address = ivec2(fragCoord);\n    if (address == VIEW_POSITION_ADDR) {\n        fragColor.xyz = vec3(0.0, 10.0, 0.0);\n    }\n\n    if (address == VIEW_DIRECTION_ADDR) {\n        fragColor.xy = vec2(0.0, -QUARTER_PI); // pi/4 radians = 45 degrees\n    }\n\n    if (address == CURRENT_INDEX_ADDR) {\n        fragColor.x = -3.0;\n    }\n\n    if (iFrame > 0) {\n        fragColor = vec4(texelFetch(iChannel0, address, 0).xyz, 1.0);\n        if (address == VIEW_POSITION_ADDR) {\n            // Flythrough controls\n            vec3 viewPosition = getViewPosition();\n            vec2 viewDirection = getViewDirection();\n            mat3 camera = getCamera(viewDirection);\n\n            fragColor = vec4(viewPosition, 1.0);\n\n            if (keyUpPressed()) {\n                fragColor.xyz += camera[2] * TRAVEL_SPEED;\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= camera[2] * TRAVEL_SPEED;\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += camera[0] * TRAVEL_SPEED;\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= camera[0] * TRAVEL_SPEED;\n            }\n        }\n\n        if (address == VIEW_DIRECTION_ADDR) {\n            vec2 viewDirection = getViewDirection();\n            bool mouseClick = mouseDown();\n            bool pointerHit = false;\n            if (mouseDown()) {\n                // Trace a ray from the mouse to the scene\n                vec2 mousePosition = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 viewPosition = getViewPosition();\n                mat3 camera = getCamera(viewDirection);\n\n                mat2x3 mouseRay = getRay(mousePosition, viewPosition, camera);\n                mat2x4 clickTraceInfo = traceRay(mouseRay);\n                pointerHit = bool(clickTraceInfo[0].w);\n\n                vec2 mouseRotation = mousePosition * TWO_PI * ROTATION_SPEED;\n                viewDirection += mouseRotation;\n            }\n\n            // Whether the pointer has hit anything is conveniently (or inconveniently?) squashed in as well\n            fragColor = vec4(viewDirection, pointerHit, 1.0);\n        }\n\n        if (address == DIG_START_ADDR) {\n            fragColor = vec4(getDigStart(), 1.0);\n\n            if (!userIsDigging() && mouseDown()) {\n                // Trace a ray from the mouse to the scene\n                vec2 mousePosition = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 viewPosition = getViewPosition();\n                vec2 viewDirection = getViewDirection();\n                mat3 camera = getCamera(viewDirection);\n\n                mat2x3 mouseRay = getRay(mousePosition, viewPosition, camera);\n                mat2x4 clickTraceInfo = traceRay(mouseRay);\n\n                if (bool(clickTraceInfo[0].w)) {\n                    fragColor.xyz = clickTraceInfo[0].xyz;\n                }\n            }\n        }\n\n        if (address == DIG_DIRECTION_ADDR) {\n            fragColor = vec4(getDigDirection(), 1.0);\n\n            // Generate a ray from the mouse position\n            vec2 mousePosition = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n            vec3 viewPosition = getViewPosition();\n            vec2 viewDirection = getViewDirection();\n            mat3 camera = getCamera(viewDirection);\n\n            mat2x3 mouseRay = getRay(mousePosition, viewPosition, camera);\n\n            if (!userIsDigging() && mouseDown()) {\n                mat2x4 clickTraceInfo = traceRay(mouseRay);\n                if (bool(clickTraceInfo[0].w)) {\n                    fragColor.xyz = mouseRay[1].xyz;\n                }\n            }\n        }\n\n        if (address == CURRENT_INDEX_ADDR) {\n            fragColor = vec4(getCurrentIndex(), getDigTimestamp(), 0.0, 1.0);\n\n            if (!userIsDigging() && mouseDown()) {\n                // Trace a ray from the mouse to the scene\n                vec2 mousePosition = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 viewPosition = getViewPosition();\n                vec2 viewDirection = getViewDirection();\n                mat3 camera = getCamera(viewDirection);\n\n                mat2x3 mouseRay = getRay(mousePosition, viewPosition, camera);\n                mat2x4 clickTraceInfo = traceRay(mouseRay);\n                if (bool(clickTraceInfo[0].w)) {\n                    // Move onto new tunnel\n                    fragColor.x += 3.0; // Update texture location\n                    fragColor.y = iTime; // Creation timestamp (conveniently (or inconveniently?) squashed in)\n                }\n            }\n        }\n\n        int currentIndex = int(getCurrentIndex());\n        if (address.y == 1 && address.x <= currentIndex + 3) {\n            // Index for tunnel data (existence, entrance, exit)\n            int dataIndex = address.x % 3;\n            // Starting index for tunnel data\n            int tunnelIndex = address.x - dataIndex;\n            bool isTunnel = tunnelExists(tunnelIndex);\n            bool isCurrent = tunnelIndex == currentIndex;\n            if (dataIndex == 0) {\n                // Existence\n                fragColor = vec4(isTunnel, 0.0, 0.0, 1.0);\n                if (isCurrent) {\n                    fragColor.x = 1.0;\n                }\n            }\n\n            if (dataIndex == 1) {\n                // Entrance\n                if (isTunnel) {\n                    fragColor = vec4(getTunnelEntrance(tunnelIndex), 1.0);\n                }\n\n                if (isCurrent) {\n                    fragColor = vec4(getDigStart(), 1.0);\n                }\n            }\n\n            if (dataIndex == 2) {\n                // Exit\n                if (isTunnel) {\n                    fragColor = vec4(getTunnelExit(tunnelIndex), 1.0);\n                }\n\n                if (isCurrent && userIsDigging()) {\n                    fragColor.xyz = getDigStart() + getDigDirection() * (iTime - getDigTimestamp()) * DIG_SPEED;\n                }\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Environment constants:\nconst vec3 LIGHT    = vec3(-0.58, 0.58, 0.58);\nconst float AMBIENT = 0.3;\n\nconst float GROUND_THICKNESS = 1.5;\nconst float TUNNEL_RADIUS    = 5.0;\nconst float WALL_THICKNESS   = 0.1;\n\n// Raymarching constants:\nconst vec3 GRADIENT_STEP       = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 500.0;\nconst float MIN_HIT_DISTANCE   = 0.01;\nconst int MAX_ITERATIONS       = 100;\nconst float FOCAL_LENGTH       = 1.0;\n\n// Math constants:\nconst float TWO_PI     = 6.2832;\nconst float QUARTER_PI = 0.7854;\n\n// User control speeds:\nconst float TRAVEL_SPEED   = 0.5;\nconst float ROTATION_SPEED = 0.01;\nconst float DIG_SPEED      = 2.0;\n\n// Addresses to viewing data:\nconst ivec2 VIEW_POSITION_ADDR  = ivec2(0, 0);\nconst ivec2 VIEW_DIRECTION_ADDR = ivec2(1, 0);\nconst ivec2 DIG_START_ADDR      = ivec2(2, 0);\nconst ivec2 DIG_DIRECTION_ADDR  = ivec2(3, 0);\nconst ivec2 CURRENT_INDEX_ADDR  = ivec2(4, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_RIGHT = 39;\nconst int KEY_LEFT  = 37;\n\n#define getViewPosition()            texelFetch(iChannel0,  VIEW_POSITION_ADDR, 0).xyz\n#define getViewDirection()           texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).xy\n\n#define userIsDigging()         bool(texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).z)\n#define getDigStart()                texelFetch(iChannel0,      DIG_START_ADDR, 0).xyz\n#define getDigDirection()            texelFetch(iChannel0,  DIG_DIRECTION_ADDR, 0).xyz\n#define getDigTimestamp()            texelFetch(iChannel0,  CURRENT_INDEX_ADDR, 0).y\n\n#define getCurrentIndex()            texelFetch(iChannel0,  CURRENT_INDEX_ADDR, 0).x\n#define tunnelExists(addr)      bool(texelFetch(iChannel0,      ivec2(addr, 1), 0).x)\n#define getTunnelEntrance(addr)      texelFetch(iChannel0,  ivec2(addr + 1, 1), 0).xyz\n#define getTunnelExit(addr)          texelFetch(iChannel0,  ivec2(addr + 2, 1), 0).xyz\n\n#define mouseDown()             iMouse.z > 0.0\n\n#define keyUpPressed()          bool(texelFetch(iChannel1,    ivec2(   KEY_UP, 0), 0).x)\n#define keyDownPressed()        bool(texelFetch(iChannel1,    ivec2( KEY_DOWN, 0), 0).x)\n#define keyRightPressed()       bool(texelFetch(iChannel1,    ivec2(KEY_RIGHT, 0), 0).x)\n#define keyLeftPressed()        bool(texelFetch(iChannel1,    ivec2( KEY_LEFT, 0), 0).x)\n\nfloat noise2D(in vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise2D(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = noise2D(cell);\n    float br = noise2D(cell + vec2(1.0, 0.0));\n    float tl = noise2D(cell + vec2(0.0, 1.0));\n    float tr = noise2D(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat fnoise2D(in vec2 p) {\n    p *= 0.1;\n\n    float nscale = 1.0;\n    float tscale = 0.0;\n    float value = 0.0;\n\n    for (float octave=0.0; octave < 4.0; octave++) {\n        value += snoise2D(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale * 5.0;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat noise3D(in vec3 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise3D(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise3D(cell);                       // Left, Down, Back\n    float rdb = noise3D(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise3D(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise3D(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise3D(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise3D(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise3D(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise3D(cell + vec3(1.0, 1.0, 1.0)); // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat fnoise3D(in vec3 p) {\n    p *= 0.5;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < 2.0; octave++) {\n        value += snoise3D(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\n// Inigo Quilez's polynomial smooth minimum from https://iquilezles.org/articles/smin:\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdCutTunnel(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    return TUNNEL_RADIUS - length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdTunnel(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 ba = a - b;\n    vec2 sp = vec2(atan(ba.z, ba.x), atan(ba.y, length(ba.xz)));\n    vec4 cs = vec4(cos(sp), sin(sp));\n\n    p -= b;\n    p.xz *= mat2(cs.x, cs.z, -cs.z, cs.x);\n    p.xy *= mat2(cs.y, cs.w, -cs.w, cs.y);\n\n    vec2 size = vec2(TUNNEL_RADIUS, length(b - a));\n    vec2 pr = vec2(length(p.yz), p.x);\n\n    float tunnel = pr.y < 0.0 ? abs(length(pr) - size.x) : pr.y < size.y ? abs(abs(pr.x) - size.x) : length(abs(pr - vec2(0.0, size.y)) - vec2(size.x, 0.0));\n    return tunnel - WALL_THICKNESS - fnoise3D(p);\n}","name":"Common","description":"","type":"common"}]}