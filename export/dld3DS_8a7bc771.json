{"ver":"0.1","info":{"id":"dld3DS","date":"1683064788","viewed":248,"name":"Isometric Pixel Castles!","username":"SnoopethDuckDuck","description":"The castles are inspired by: https://www.instagram.com/p/BpuJAdIlTZt/\nThe color palette is modified from Dawnbringer32: https://lospec.com/palette-list/dawnbringer-32\n\nMake sure you click the music thingy in iChannel1!","likes":29,"published":3,"flags":96,"usePreview":0,"tags":["pixel","tower","isometric","castle","pixelart","dawnbringer"],"hasliked":0,"parentid":"mll3zf","parentname":"[House]"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sd3z8","filepath":"https://soundcloud.com/jordgubbsblond/ichika-nito?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/jordgubbsblond/ichika-nito?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 cell(in vec2 q) {\n    ivec2 p = ivec2(q);\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0);\n}\n\nvec2 pxToF(vec2 px) { return round(sc * (px - 0.5 * res) / res.y); }\nvec2 fToPx(vec2 f)  { return f / sc * res.y + 0.5 * res; }\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 f = round(sc * uv);\n    \n    vec4 c = cell(px);\n    float x = 1.;\n    vec4 t = cell(fToPx(f - vec2( 0,  x)));\n    vec4 l = cell(fToPx(f - vec2( x,  0)));\n    vec4 r = cell(fToPx(f - vec2(-x,  0)));\n    vec4 b = cell(fToPx(f - vec2( 0, -x)));\n    \n    // Outline (might be off by one or two pixels)\n    if (c.a == 2. && (t.a != 2. || l.a != 2. || r.a != 2. || b.a != 2.))\n        c.rgb *= 0.95;//= vec3(63,63,116) / 255.;\n    \n    O = c;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define res iResolution.xy\nfloat sc = 120.; // Grid scale","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Small issues:\n// Spacing wrong for big towers + overlap occurs\n// Some low towers only cover half the wall trim e.g. 65 seconds\n\n// todo maybe:\n// raise wall,tower heights from 0->max height from fract(t)=0 to 1\n// or: audiovisual, heights change with sound\n// make island consider thickness of towers\n// make bottom of island consider towDim.y\n// add door and path/road\n// add centre castle\n\n// Basis vectors for skewed plane\nconst vec2 bX = vec2( 2, 1);\nconst vec2 bY = vec2(-2, 1);\n\n\n// --- COLORS ---\n\n// 0: tower dark\n// 1: tower light\n// 2: background\n// 3: trim dark\n// 4: trim light\n// 5: carpet\n// 6: grass dark\n// 7: grass\n// 8: grass light\n// 9: under light\n// 10: under dark\n// 11: flag \n\nint pal;   // Color palette: 0=grey+green 1=orange 2=green+blue\nfloat ind; // Color index\n\nconst int nCol = 12;\nconst vec3[] colArr = vec3[3 * nCol] ( \nvec3(89,86,82),  vec3(132,126,135),vec3(91,110,225),vec3(99,155,255), vec3(95,205,225), vec3(217,87,99), vec3(55,148,110),vec3(106,190,48),vec3(153,229,80), vec3(143,86,59),vec3(102,56,49),vec3(255),\nvec3(143,86,59), vec3(180,123,80), vec3(55,148,110),vec3(217,160,102),vec3(238,195,154),vec3(180,123,80),vec3(223,113,38),vec3(254,182,45),vec3(238,195,154),vec3(143,86,59),vec3(102,56,49),vec3(255),\nvec3(55,148,110),vec3(106,190,48), vec3(180,123,80),vec3(203,219,252),vec3(255,255,255),vec3(153,229,80),vec3(48,96,130), vec3(91,110,225),vec3(99,155,255), vec3(143,86,59),vec3(102,56,49),vec3(255)\n);\n\nvec3 getCol() {\n    return colArr[pal * nCol + int(ind)] / 255.;\n}\n\n\n// --- HASH FUNCTIONS ---\n\n// ty Dave Hoskins! https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// --- PRIMITIVE SHAPES --- \n\n// x,y bottom left corner\nfloat box(vec2 f, float x, float y, float w, float h) {\n    return step(x, f.x) * step(f.x, x + w - 1.) *\n           step(y, f.y) * step(f.y, y + h - 1.);\n}\n// Diamond\nfloat dia(vec2 f, float w, float h) {\n    f = abs(f - vec2(0.5, 0));\n    return step(f.x, h - 2. * f.y) * step(f.x, w); \n}\n// Slanted box: left+right sides are vertical, bottom+top are slanted\nfloat sbox(vec2 f, float w, float h, float s) {\n    f -= vec2(0.5 * (s - 1.), 0.); // Why -1.?\n    f.x *= s;\n    return step(0., f.x) * step(f.x, w) *\n           step(f.x, 2.*f.y+1.) * step(2.*f.y-h, f.x);\n}\n// Slanted rect: b bottom point, t top point\nfloat srect(vec2 f, vec2 b, vec2 t) {\n    vec2 fb = f-b;\n    vec2 ft = f-t;\n    float s = step(fb.x-2.*fb.y, 0.) * step(1., fb.x+2.*fb.y); \n    return s * step(1., ft.x-2.*ft.y) * step(ft.x+2.*ft.y, 0.);\n}\n// Slanted rect with extra height\nfloat srect2(vec2 f, vec2 b, vec2 t, float h) {\n    vec2 fb = f-b-vec2(0,h);\n    vec2 ft = f-t;\n    float l = t.y-b.y+0.5*(t.x-b.x);\n    float r = t.y-b.y-0.5*(t.x-b.x);\n    float s = step(1., ft.x-2.*ft.y) * step(ft.x+2.*ft.y, 0.);\n    s *= step(fb.x-2.*fb.y, 0.) * step(1., fb.x+2.*fb.y); \n    s *= step(f.x-r, -1.) * step(2.,f.x+l);\n    return s;\n}\n\n\n// --- OBJECTS --- \n\n// b: bottom point, t: top point, h: height of lower island\nvoid drawIsland(vec2 f, vec2 b, vec2 t, float h) {\n    float top = srect(f, b, t);\n    float bot = srect2(f, b, t, -h) - top;\n    float uInd = mix(9., 10., step(b.x-t.x+1., f.x));\n    ind = mix(ind, 7., top);  \n    ind = mix(ind, uInd, bot);\n}\n// dm: diamond dimensions, h: height (>4), th: bot thickness\nvoid drawTower(vec2 f, vec2 dm, float h, float th) {\n    f.y -= h + 0.5*dm.y;\n    float m = min(dm.x, dm.y);\n    float di1    = dia(f, dm.x, dm.y);\n    float di2    = dia(f, dm.x - 2., dm.y - 2.);\n    float di3    = dia(f - vec2(0, -1), dm.x - 2., dm.y - 2.);\n    float base   = dia(f - vec2(0, -0.5*h), th, dm.y+h);\n    float top    = dia(f - vec2(0, -1.), m, 2.+dm.y);\n    float shadow = dia(f - vec2(0, -2.), m-1., 2.+dm.y);  \n    ind = mix(ind, mix(0., 1., step(f.x, 0.)), base);\n    ind = mix(ind, 0., shadow);\n    ind = mix(ind, mix(0., 1., step(f.x, 1.)), top);\n    ind = mix(ind, 5., di1);\n    ind = mix(ind, mix(3., 4., step(f.x, 0.)), di1 - di2);\n    ind = mix(ind, 0., max(0., di2 - di3));\n}\nvoid drawWallTL(vec2 f, vec2 dm, float th) {\n    float base = sbox(f, dm.x + 1., dm.y, 1.);\n    float carpet = sbox(f - vec2(0, 0.5*dm.y+1.), dm.x-0., 2., 1.);\n    carpet *= step(f.y - (0.5*dm.y+1.), 0.5*dm.x);\n    float shadow = sbox(f - vec2(0, 0.5*dm.y+3.), dm.x-2., 0., 1.);\n    float trim = sbox(f - vec2(0, 0.5*dm.y+4.), dm.x-2., 0., 1.);\n    ind = mix(ind, 0., base);\n    ind = mix(ind, 5., carpet);\n    ind = mix(ind, 0., shadow);\n    ind = mix(ind, 4., trim);\n}\nvoid drawWallTR(vec2 f, vec2 dm, float th) {\n    float base = sbox(f, dm.x + 1., dm.y, -1.);\n    float carpet = sbox(f - vec2(0, 0.5*dm.y+1.), dm.x, 2., -1.);\n    carpet *= step(f.y - (0.5*dm.y+1.), 0.5*dm.x);\n    float shadow = sbox(f - vec2(0, 0.5*dm.y+3.), dm.x-2., 0., -1.);\n    float trim = sbox(f - vec2(0, 0.5*dm.y+4.), dm.x-2., 0., -1.);\n    ind = mix(ind, 1., base);\n    ind = mix(ind, 5., carpet);\n    ind = mix(ind, 0., shadow);\n    ind = mix(ind, 3., trim);\n}\nvoid drawWallBL(vec2 f, vec2 dm) {\n    float base = sbox(f, dm.x, dm.y, -1.);\n    float shadow = sbox(f - vec2(0, 0.5*dm.y+1.), dm.x, 0., -1.);\n    float trim = sbox(f - vec2(0, 0.5*dm.y+2.), dm.x, 0., -1.);   \n    float carpet = sbox(f - vec2(0, 0.5*dm.y+3.), dm.x-1., 2., -1.);\n    ind = mix(ind, 1., base);\n    ind = mix(ind, 0., shadow);\n    ind = mix(ind, 4., trim);\n    ind = mix(ind, 5., carpet);\n}\nvoid drawWallBR(vec2 f, vec2 dm) {\n    float base = sbox(f, dm.x, dm.y + 2., 1.);\n    float trim = sbox(f - vec2(0, 0.5*dm.y+2.), dm.x, 0., 1.);\n    float carpet = sbox(f - vec2(0, 0.5*dm.y+3.), dm.x-1., 2., 1.);\n    ind = mix(ind, 0., base);\n    ind = mix(ind, 3., trim);\n    ind = mix(ind, 5., carpet);\n}\n// Only B and R towers\nvoid drawTowerShadow(vec2 f, vec2 dm, float th) {\n    f.y -= 0.5 * dm.y;\n    float shadow = dia(f - vec2(4, 0), dm.x, dm.y);\n    ind = mix(ind, 6., shadow);\n}\n// Only TL and BR walls\nvoid drawWallShadow(vec2 f, vec2 dm) {\n    float shadow = sbox(f - vec2(2, -1), dm.x + 1., 3., 1.);\n    ind = mix(ind, 6., shadow);\n}\nvoid drawTowerGrass(vec2 f, vec2 dm, float th) {\n    f.y -= 0.5 * dm.y;\n    float grass = dia(f - vec2(0, -1), th, dm.y);\n    ind = mix(ind, 8., grass);\n}\nvoid drawWallGrass(vec2 f, vec2 dm) {\n    float grass = sbox(f - vec2(0, -1), dm.x, 0., -1.);\n    ind = mix(ind, 8., grass);\n}\nvoid drawFlag(vec2 f, float h) {\n    float m = mod(floor(4. * iTime), 2.);\n    float pole = box(f, 0., 0., 1., h);\n    float tip  = box(f, 0., h + 1., 1., 1.);\n    float flag = box(f, 0., h, 1., 1.) + box(f, 1., h-2.+m, 1., 3.) +\n                 box(f, 2., h-1.-m, 1., 3.);\n    float shadow = box(f, 1., 0., 2., 1.);  \n    ind = mix(ind, 1., pole);\n    ind = mix(ind, 4., tip);\n    ind = mix(ind, 11., flag);\n    ind = mix(ind, 0., shadow);\n}\n// Unfinished, needs to consider tower thickness? has a left bias\nvoid drawDoor(vec2 f, float w, float h) {\n    //if (ind != 1.) return; // Only draw on front wall\n    w = 5.;\n    h = 48.;    \n    float door = sbox(f - 0.25*(2.-w)*bY, w, h, -1.);\n    float e = step(f.x, -floor(0.5*w)-2.) * door;\n    //ind = mix(ind, 0., e);   \n    ind = mix(ind, 7., door);   \n    ind = mix(ind, 0., e);  \n}\n\nvoid mainImage(out vec4 O, in vec2 px) {  \n    vec2 uv = (px - 0.5 * res.xy) / res.y;\n    \n    // Pixelate uv\n    vec2 f = round(sc * uv); // Towers look good with f = sc * uv\n    \n    // Pick palette with time\n    pal = int(mod(floor(iTime), 3.));\n    \n    // Random parameters\n    float[13] rand;\n    float fTime = floor(iTime);\n    for (int i = 0; i < 13; i++) {\n        rand[i] = hash11(fTime + float(i) / 13.);\n    }\n  \n    // Tower: dimensions, height, thickness\n    vec2 towDim = vec2(0, 6. + 2.*floor(8. * rand[0]));\n    towDim.x = floor(mix(max(5., 0.25*towDim.y), towDim.y+2., rand[1]));\n    float towH = 2.*floor(mix(4., 20., rand[2]));\n    float towTh = 2.;//floor(mix(6., min(towDim.x, towDim.y)-1., rand[3]));\n    towTh = clamp(towTh, 4., min(towDim.x, towDim.y)-1.);\n    \n    // Wall: height, lengths (keep height even, lengths odd)\n    float wallH = 2.*floor(mix(2., 0.5*towH, rand[4]));\n    wallH = min(wallH, towH+2.);\n    float wallX = 1. + 2.*max(8., floor(30.*rand[5]));\n    float wallY = 1. + 2.*max(8., floor(30.*rand[6]));\n    \n    // Island: padding (>=4.), height\n    float islPad = 4.;\n    float islH = 4.;\n    \n    // Flag: height\n    float flagH = floor(mix(8., 17., rand[7]));\n        \n    // Positions\n    vec2 pTowT = vec2(0);\n    vec2 pTowL = -0.5 * bX * (3. + wallX);\n    vec2 pTowR = -0.5 * bY * (3. + wallY);\n    vec2 pTowB = pTowL + pTowR;    \n    vec2 pWallTL = pTowL + vec2(8.-towTh, 0.5*(1.+towTh));\n    vec2 pWallTR = pTowR + vec2(towTh-6., 0.5*(1.+towTh));\n    vec2 pWallBR = pTowB + vec2(1, 2.5);\n    vec2 pWallBL = pWallBR;\n        \n    // Centre coords to centre of castle and translate\n    f += round(0.5*pTowB);\n    f.y += 18.;\n    \n    \n    // --- DRAW --   \n\n    // Background \n    ind = 2.;\n    \n    // Island (offset with bX, bY for non-constant padding)\n    drawIsland(f, pTowB - vec2(0, islPad), pTowT - vec2(0, 1.-towDim.y-islPad), islH);\n    \n    // Grass and Shadows\n    drawTowerShadow(f - pTowT, towDim, towTh); \n    drawWallGrass  (f - pWallBL, vec2(wallY, wallH));\n    drawWallGrass  (f - pWallTR, vec2(wallY, wallH));\n    drawTowerGrass (f - pTowL, towDim, towTh);\n    drawTowerGrass (f - pTowB, towDim, towTh);\n    drawTowerShadow(f - pTowL, towDim, towTh); \n    drawTowerShadow(f - pTowB, towDim, towTh);\n    drawTowerShadow(f - pTowR, towDim, towTh);\n    drawWallShadow (f - pWallTL, vec2(-2.+wallX, wallH));\n    drawWallShadow (f - pWallBR, vec2(1.+wallX, wallH));    \n    \n    // Towers and Walls\n    drawTower (f - pTowT, towDim, towH, towTh);  \n    drawWallTR(f - pWallTR, vec2(-2.+wallY, wallH), towTh);\n    drawWallTL(f - pWallTL, vec2(-2.+wallX, wallH), towTh);      \n    drawTower (f - pTowL, towDim, towH, towTh);\n    drawTower (f - pTowR, towDim, towH, towTh);    \n    drawWallBR(f - pWallBR, vec2(wallX, wallH));\n    drawWallBL(f - pWallBL, vec2(wallY, wallH));\n    drawTower (f - pTowB, towDim, towH, towTh);      \n          \n    // Door (todo)\n    // drawDoor(f - 0.5*(pTowB+pTowL)- vec2(0, 3), 9., 6.);\n          \n    // Flags\n    if (rand[8] > 0.5) \n        drawFlag(f - pTowT - vec2(0, towH + 0.5 * towDim.y), flagH);     \n    if (rand[9] > 0.5) \n        drawFlag(f - pTowL - vec2(0, towH + 0.5 * towDim.y), flagH);    \n    if (rand[10] > 0.5) \n        drawFlag(f - pTowR - vec2(0, towH + 0.5 * towDim.y), flagH);    \n    if (rand[11] > 0.5) \n        drawFlag(f - pTowB - vec2(0, towH + 0.5 * towDim.y), flagH);    \n\n    vec3 col = getCol();\n         \n    // Texture front wall and a random part\n    float hh = hash12(mod(floor(iTime) + mod(f + ind, 4.),vec2(301.)));\n    float hi1 = floor(float(nCol) * hash11(floor(iTime)));\n    float hi2 = floor(float(nCol) * hash11(floor(iTime) + 0.5));\n    if (rand[12] > 0.4 && (ind == hi1 || ind == hi2))\n        col *= 0.9 + 0.2 * hh;\n     \n    // Vignette (very weak)\n    col = mix(col, vec3(1), 1.-1./cosh(0.25*length(uv)));\n    \n    O = vec4(col, ind);\n}","name":"Buffer A","description":"","type":"buffer"}]}