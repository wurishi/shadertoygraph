{"ver":"0.1","info":{"id":"tdlSDj","date":"1552249289","viewed":81,"name":"my_first_task","username":"runrus9991","description":"suppper)","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["cubemap","fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define RM_USE_ABSORPTION\n#define RM_USE_SCATTERING\n#define RM_USE_SCATTERING2\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n\n// Primitives :-----------------------------------------------------------------------\n\n\nfloat sphere(vec3 p, float radius)\n{\n    return length(p)-radius;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    return max(length(vec2(length(p.xz)-t.x,p.y))-t.y, 0.0);\n}\n\nfloat opTwist(in vec3 p, float radius)\n{\n    const float k = 2.0; \n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return torus(q, vec2(0.2, 0.3));\n}\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat tor(in vec3 pos) {\n    float d = 1e10;\n    vec3 q = pos ;\n    vec4 w = opElongate( q, vec3(0.6,0.0,0.6) );\n    d = min( d, w.w+torus( w.xyz, vec2(0.4,0.05) ) );\n    return d; \n}\n\nfloat plane(vec3 p) { return p.y + .0; }\n\nfloat length4(vec2 p) {\n    return pow( p.x*p.x*p.x*p.x + p.y*p.y*p.y*p.y, 1.0/4.0 );\n}\n\nfloat torus42(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length4(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n\nfloat fracSec( vec3 r ){\n    vec3 zn = vec3( r.xyz );\n    float rad = 0.0;\n    float hit = 0.0;\n    float p = 8.0;\n    float d = 1.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        \n            rad = length( zn );\n\n            if( rad > 1.09 )\n            {   \n                hit = 0.5 * log(rad) * rad / d;\n            }else{\n\n            float th = atan( length( zn.xy ), zn.z );\n            float phi = atan( zn.y, zn.x );     \n            float rado = pow(rad,8.0);\n            d = pow(rad, 7.0) * 7.0 * d + 1.0;\n            \n\n\n            float sint = sin( th * p );\n            zn.x = rado * sint * cos( phi * p );\n            zn.y = rado * sint * sin( phi * p );\n            zn.z = rado * cos( th * p ) ;\n            zn += r;\n            }\n            \n    }\n    \n    return hit;\n\n}\n\n\n\n\n\nfloat sdHexPrism (vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\nfloat fracTh( vec3 p ){\n\tfloat d = sdHexPrism(p , vec2(1.9));\n\tfloat s = 2.0;\n    for( int m=0; m < 5; m++ )\n    {\n        vec3 a = mod( (p)*s, 2.0 )-1.0;\n        s *= 3.;\n        vec3 r = abs(1.0 - 3. *abs(a));\n\n        float da = min(r.x,r.y);\n        float db = min(r.y,r.z);\n        float dc = min(r.z,r.x);\n        float c = (max(da,max(db,dc))-1.0)/s;\n\n        d = max(d,c);\n    }\n\n    return d;\n\n}\n\n/*\n*/\n\nfloat fracFi (vec3 p)\n{\n    float d = sdBox(p , vec3(1.9));\n\n    float s = 2.0;\n    for( int m=0; m < 6; m++ )\n    {\n        vec3 a = mod( (p)*s, 2.0 )-1.0;\n        s *= 3.;\n        vec3 r = abs(1.0 - 3. *abs(a));\n\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        d = max(d,c);\n    }\n\n    return d;\n}\n\n// Operator :-----------------------------------------------------------------------\nvec2 opUnion(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n\n// Scene settings :\n//const vec3    eyeTarget = vec3(0, 3., 0);\n            \nconst float focalLength = .7;\nconst vec3  lightPos = vec3(-0., 2, 0),\n            lightPos2 = vec3(-2., 4, -4),\n            lightPos3 = vec3(-3., 4., 3.),\n            frackPos = vec3(-5., 5., 5.),\n            frackPos2 = vec3(5., 5., 5.),\n            lightDir = vec3(-6.0, -0.5, 0.7),\n            lightDir2 = vec3(6.0, 0., 0.7),\n            lightCol = vec3(0.3, 0.3, 0.3);\nconst float lightSpan = -5.5, \n    \t\tlightSpan2 = .5, \n            lightRadiance = 25.0,\n            lightRadiance2 = 35.0,\n            thetaRing2 = 0.2,\n            thetaRing3 = 0.4,\n            PI = 3.141592;\nconst ivec2 POSITION = ivec2(1, 0),\n            VMOUSE = ivec2(1, 1);\n\nmat3 rotMat2, torMat;\n\n\nvec2 sceneMap(in vec3 p)\n{\n    vec3 objectCenter = vec3( 4.0 * cos(1.),2,4.0 * sin(0.));\n    return  opUnion( vec2(plane(p), 1), \n           \n            opUnion( vec2(sphere(p-lightPos, 0.31), 1111),\n            opUnion( vec2(sphere(p-lightPos3, 0.2), 1111),\n            opUnion( vec2(sphere(p-objectCenter, 0.5), 2),\n            opUnion( vec2(fracFi(p-lightPos2), 12),\n            opUnion( vec2(fracSec(p-frackPos), 15),\n            opUnion( vec2(fracTh(p-frackPos2), 16),\n            opUnion( vec2(tor(torMat*(p-objectCenter)), 3),\n            opUnion( vec2(torus42(p-objectCenter, vec2(0.6, 0.05)), 4),\n                     vec2(torus42(rotMat2*(p-objectCenter), vec2(0.8, 0.05)), 5)\n                     )))))))));\n}\n\n\nfloat sceneMapSimple(vec3 p) {\n    vec3 objectCenter = vec3( 4.0 * cos(1.),2,4.0 * sin(0.));\n    return \tmin( plane(p), \n            min( sphere(p-objectCenter, 0.5),\n            min( fracFi(p-lightPos2),\n            min( fracSec(p-frackPos),\n            min( tor(torMat*(p-objectCenter)),\n            min( torus42(p-objectCenter, vec2(0.6, 0.05)),\n                     torus42(rotMat2*(p-objectCenter), vec2(0.8, 0.05))\n                     ))))));\n}\n\nmat3 computeCameraMatrix(in vec3 p, in vec3 target, float roll) {\n    vec3    vForward = normalize(target-p),\n            vUpAlign = vec3(0.0, 1.0, 0.0),\n            vLeftReal = normalize(cross(vForward, vUpAlign)),\n            vUpReal = normalize(cross(vLeftReal, vForward));\n    return mat3(vLeftReal, vUpReal, vForward);\n}\n\n\nfloat absorption(vec3 p, vec3 dir, float d) {\n    return d*exp(-p.y*5.0)/2.0;\n}\n\nfloat scattering(vec3 p, vec3 dir, float d) {\n    vec3 u = normalize(p - lightPos);\n    float dLight = distance(p, lightPos);\n    return  d*0.2*exp(-p.y*0.1)/(dLight*dLight) * (max(dot(u, normalize(lightDir)), lightSpan)-lightSpan)/(1.0-lightSpan);\n}\n\n\nfloat scattering2(vec3 p, vec3 dir, float d) {\n    vec3 u = normalize(p - lightPos3);\n    float dLight = distance(p, lightPos3);\n    return  d*0.2*exp(-p.y*0.1)/(dLight*dLight) * (max(dot(u, normalize(lightDir2)), lightSpan2)-lightSpan2)/(1.0-lightSpan2);\n}\n\nvec4 castRay(in vec3 rayOrigin, in vec3 rayDirection, const float dMin, const float dNear, const float dMax, float ss)\n{\n    const int numSteps = 128;\n    float d = dMin;\n    float m = -1.0;\n    float a = 0.0, s = 0.0;\n    for(int i=0; i<numSteps; i++) {\n        vec3 p = rayOrigin+rayDirection*d;\n        vec2 res = sceneMap(p);\n        if((res.x < dNear) || (dMin > dMax)) break;\n        d += res.x;\n        m = res.y;\n        #ifdef RM_USE_ABSORPTION\n        a += absorption(p, rayDirection, res.x);\n        #endif\n        #ifdef RM_USE_SCATTERING\n        s += scattering(p, rayDirection, res.x);\n        #endif\n        #ifdef RM_USE_SCATTERING2\n        ss += scattering2(p, rayDirection, res.x);\n        #endif\n    }\n    if(d>dMax)\n        m = -1.0;\n    return vec4(d, m, a, s);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    const vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3( sceneMap(pos+eps.xyy).x - sceneMap(pos-eps.xyy).x,\n                            sceneMap(pos+eps.yxy).x - sceneMap(pos-eps.yxy).x,\n                            sceneMap(pos+eps.yyx).x - sceneMap(pos-eps.yyx).x ));\n}\n\n// Other tools : \nfloat softShadow(vec3 rayOrigin, vec3 lightPos, float dNearLight, float kShadowSoftness) {\n    const int maxStep = 128;\n    const float dNearIntersect = 0.0000001;\n    vec3 rayDirection = lightPos - rayOrigin;\n    float dMax = length(rayDirection) - dNearLight;\n    rayDirection = normalize(rayDirection);\n    float res = 1.0;\n    float d=0.0;\n    for(int k=0; k<maxStep; k++) {\n        float closest = sceneMapSimple(rayOrigin + rayDirection*d);\n        if(closest<dNearIntersect)\n            return 0.0;\n        res = min(res, kShadowSoftness*closest/d);\n        d += closest;\n        if(d>=dMax)\n            break;\n    }\n    return res;\n}\n\n\n//-----------------------------------------------------------\n\nvec4 renderMaterial(vec3 p, vec3 dir, vec3 normal, float material, float dist, float absorption, float scattering, float scattering2, vec2 fragCoord)\n{\n    vec4 col = vec4(0, 0, 0, 1);\n\n    if(material>0.0) { // Valid object intersection\n        if(material<=1.0) { //floor\n            //col = mod(floor(5.0*p.z) + 1.0*p.x, 4.)*mix(vec4(1., 1.0, 1.0, 0.0), vec4(0., 0.4, 0.0, 0.0),  (calcNormal(p), 0.0));\n        \n            vec2 uv = fragCoord.xy / iResolution.xy;\n    \n            vec3 tex1 = texture(iChannel0, uv).rgb;\n            \n            col = vec4(tex1, 0.)*vec4(7.0, 7.0, 7.0, .0);\n        }\n        else if(material == 10.){\n           // if((mod(p.y + 35., 3.) >= 1.) && (mod(p.y + 5., 2.) <=  1.03) && (mod(p.z + 5., 2.) >= 1.) && (mod(p.z + 5., 2.) <= 1.03)) col = vec4(11.0, 11.0, 11.0, .0);\n           // else {\n                vec2 uv = vec2(dist/iResolution.x, dist/iResolution.z);\n                col = mod(floor(5.0*p.z) + 1.0*p.x, 4.)* vec4(0.5 + 0.5*cos(117.89+uv.xyx+vec3(0,2,4)), 1.0);\n            //}\n        }    \n            \n        else // other\n            col =  vec4(material/5.0,1.0-material/5.0, dist*dist/25.0-p.y/3.0, 1.0);\n\n        // Simple shading :\n        vec3 u = p - lightPos;\n        float l = length(u);\n        u = u/l;\n        float s = max(dot(-dir, normal), 0.0) * max(dot(-u, normal),0.0) * max((max(dot(u, normalize(lightDir)), lightSpan)-lightSpan)/(1.0-lightSpan), 0.0) / max(l*l, 1.0) * lightRadiance + max((max(dot(u, normalize(lightDir2)), lightSpan2)-lightSpan2)/(1.0-lightSpan2), 0.0) / max(l*l, 1.0);\n        col = col * max(s,0.0001) * vec4(lightCol,1);\n\n        // Light source : \n        col = (material>=1024.0) ? vec4(1,1,1,1) : col;\n        col.rgb = col.rgb * softShadow(p, lightPos3, 1.0, 32.0) * max(1.0 - absorption,0.0) * softShadow(p, lightPos, 1.0, 32.0) + scattering * lightRadiance * lightCol/max(1.0,dist*dist)  + scattering2 * lightRadiance2 * lightCol/max(1.0,dist*dist);\n        \n    }\n    else{\n        col = texture(iChannel2, p);\n    }\n\n    return col;\n}\n\n\n\nvec4 renderScene(vec3 eyePos, vec3 eyeTarget, const float focalLength, const float dMin, const float dNear, const float dMax, vec2 fragCoord)\n{\n    vec2 formatSize = vec2(540, 320);\n    mat3 camera = computeCameraMatrix(eyePos, eyeTarget, 0.0);\n    vec2 o = (gl_FragCoord.xy - vec2(formatSize)/2.0)/max(float(formatSize.x),float(formatSize.y));\n    vec3 rayOrigin = vec3(o, 0.0) + eyePos,\n        rayDirection = normalize(camera*vec3(o, focalLength));\n    float ss = 0.0;\n    vec4 res = castRay(rayOrigin, rayDirection, dMin, dNear, dMax, ss);\n    vec3 p = rayOrigin + rayDirection * res.x;\n    vec3 n = calcNormal(p);\n    return renderMaterial(p, rayDirection, n, res.y, res.x, res.z, res.w, ss, fragCoord);\n}\n\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) \n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup the animation of the scene :\n    vec3 eyePos = vec3(0.0);\n    vec3 eyeTarget = vec3(0.0);\n   \n    \n    rotMat2 = mat3( 1, 0, 0,\n                    0, cos(thetaRing2*iTime), sin(thetaRing2*iTime),\n                    0, -sin(thetaRing2*iTime), cos(thetaRing2*iTime));\n\n    torMat = mat3( -cos(thetaRing3*iTime), 0, sin(thetaRing3*iTime),\n                   0, 1, 0,\n                   sin(thetaRing3*iTime), 0, cos(thetaRing3*iTime));\n    Camera(fragCoord, eyePos, eyeTarget);\n    //vec3 eyePos = eyeTarget + vec3(4.0*cos(0.1), 1.5, 4.0*sin(0.1));\n    \n    // Render :\n    vec4 c = renderScene(eyePos, eyeTarget, focalLength, 0.5, 0.001, 100., fragCoord);\n    fragColor = vec4(pow(c.rgb, vec3(1, 1, 1)/2.2), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\n\nconst int KEY_UP    = 65;\n\nconst int KEY_DOWN  = 68;\n\nconst int KEY_RIGHT = 83;\n\nconst int KEY_LEFT  = 87;\n\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, max(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(4.0, 2.0, 3.0, 0.0));\n        store(TARGET, vec4(4.0, 5.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta * 5.0;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(pm + (iMouse.zw - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}