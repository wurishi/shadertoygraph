{"ver":"0.1","info":{"id":"3ssXW2","date":"1552599993","viewed":284,"name":"Ink 1","username":"OliverSchaff","description":"My first try with distorted persistence.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["2d","fbm","buffer","multipass","quasifluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // read in the image from Buffer A\n\tvec4 col0 = texture(iChannel0, uv);\n    \n    // send it to the screen\n    fragColor = col0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Palette by Inigo Quilez\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color(float c) {\n// 0.0 < c < 1.0 covers the full palette\n    return pal( c, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n#define NUM_OCTAVES 4\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 8.0/15.0;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat disk(in vec2 st, in float r, in vec2 center) {\n    st -= center;\n    float dist = clamp(length(st)-r, 0.0,1.0);\n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspectVector = vec2(iResolution.x/iResolution.y, 1.0);\n    \n    // Define coordinates for reading in the last image\n    vec2 stRead = uv;\n    \n    // only now scale the uv coordinates. \n    // This scaling would have screwed up the read-in of the last image\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Read the last image (better: pixelcolor) from Buffer A\n    // We apply a shift to stRead before reading the last image\n    // This adds the swirly fluid effect\n    \n    // Distort the stRead plane with fbm\n    vec2 shiftStRead = -.005*vec2(fbm(10.0*stRead+0.1*iTime)-0.5, fbm(10.0*stRead.yx-0.1*iTime)-0.5);\n    stRead += shiftStRead;\n\t\n    // Read the last image pixel color at the distorted position\n    vec3 col = texture(iChannel0, stRead).xyz;\n    \n    // Darken the last image somewhat\n    col *= 0.99995;\n    \n    // Constant that is used in anti-aliasing\n    float aa = 1.5/min(iResolution.x, iResolution.y);\n    \n    // Define the disks parameters\n    float radius = 0.05;\n\n    vec2 centerOfScreen = vec2(0.5, 0.5)*aspectVector;\n    vec2 shiftDisk0 = ((1.0-2.2*radius)*(vec2(noise(vec2(0.5*iTime)),noise(vec2(0.5*iTime,-0.1*iTime)))-0.5))*aspectVector;\n    vec2 centerDisk0 = centerOfScreen + shiftDisk0;\n    vec2 shiftDisk1 = ((1.0-2.2*radius)*(vec2(noise(vec2(-0.4*iTime)), noise(vec2(0.6*iTime,0.1*iTime)))-0.5))*aspectVector;\n    vec2 centerDisk1 = centerOfScreen + shiftDisk1;\n    vec2 shiftDisk2 = ((1.0-2.2*radius)*(vec2(noise(vec2(0.6*iTime+0.65,0.2*iTime)), noise(vec2(0.3*iTime,-0.2*iTime)))-0.5))*aspectVector;\n    vec2 centerDisk2 = centerOfScreen + shiftDisk2;\n\n    // Generate distance functions for the disks\n    float dist0 = disk(uv, radius, centerDisk0);\n    float dist1 = disk(uv, radius, centerDisk1);\n    float dist2 = disk(uv, radius, centerDisk2);\n\n    // Add the circles to the last image (residing in col)\n    // Change the colors with time\n    col = mix(col, color(sin(0.2*iTime)), 1.0-smoothstep(0.0, 0.0+aa, dist0));\n    col = mix(col, color(sin(0.2*iTime+0.5)), 1.0-smoothstep(0.0, 0.0+aa, dist1));\n    col = mix(col, color(sin(0.2*iTime+1.0)), 1.0-smoothstep(0.0, 0.0+aa, dist2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}