{"ver":"0.1","info":{"id":"43l3Dl","date":"1708049715","viewed":317,"name":"Optical phenomena simulation","username":"Nazlbit","description":"A simulation of the optical phenomena - dispersion, interference, reflection, refraction, diffraction.\n1) A light pulse passes through a prism.\n2) A coherent light pulse passes through a wall with 2 slits.\n3) A coherent light pulse passes through a lens.","likes":29,"published":1,"flags":48,"usePreview":0,"tags":["2d","reflection","wave","simulation","refraction","lens","interference","field","vector","double","dispersion","diffraction","slit"],"hasliked":0,"parentid":"XXlGzn","parentname":"2D Vector Field Wave Simulation"},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Use the mouse to emit light pulses. Hold the mouse button, pull and release.\n// Press Space to reverse the direction of the simulation.\n// Press Shift to clear the field.\n// Press Backspace to reset the simulation to the initial state.\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 tonemap(const vec3 c)\n{\n    return c / (c + 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coords = ivec2(fragCoord);\n    ivec2 extent = ivec2(iResolution.xy);\n    vec2 normalized_extent = iResolution.xy / iResolution.y;\n\n    if(boundary(coords, extent))\n    {\n        fragColor = vec4((coords.y == extent.y - 1) ? 0. : 1.);\n        return;\n    }\n\n    vec4 field = read_buffer(iChannel0, coords);\n\n    if(iMouse.z > 0.)\n    {\n        field += mouse_pulse(coords, extent, iMouse);\n    }\n\n    float amp = length(field.xy);\n    float angle = atan(field.y, field.x);\n    float hue = (angle + radians(180.)) / radians(360.);\n    vec3 color = hsv2rgb(vec3(hue, 1., amp));\n    color += (1. - lens(vec2(coords), extent)) * 0.01;\n    color += (1. - prism(vec2(coords), extent)) * 0.01;\n\n    float graph_scale =  iResolution.y * 0.002;\n    float screen_right = read_buffer(iChannel0, ivec2(min(coords.x+1, extent.x-1), extent.y - 1)).x * graph_scale;\n    float screen = read_buffer(iChannel0, ivec2(coords.x, extent.y - 1)).x * graph_scale;\n    float screen_left = read_buffer(iChannel0, ivec2(max(coords.x-1, 0), extent.y - 1)).x * graph_scale;\n\n    float distance_to_the_wall = float(extent.y - coords.y - 1) / float(extent.y);\n    float distance_to_the_line = abs(distance_to_the_wall - screen);\n    const float line_width = 0.002;\n    float line_width_corrected_for_slope = line_width + abs(screen_right - screen_left)*0.5;\n    if(distance_to_the_line < line_width_corrected_for_slope)\n    {\n        color += 0.3;\n    }\n\n    color = tonemap(color*10.);\n\n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 field, in vec2 _coords )\n{\n    ivec2 coords = ivec2(_coords);\n    ivec2 extent = ivec2(iResolution.xy);\n\n    field = read_buffer(iChannel0, coords);\n\n    if(iFrame % 36000 == 0)\n    {\n        field += initial_state(coords, extent);\n        return;\n    }\n\n    simulation(field, coords, extent, iChannel0);\n\n    if(!boundary(coords, extent))\n    {\n        bool space_is_clicked = bool(texelFetch(iChannel1, ivec2(32, 1), 0).x);\n        bool shift_is_clicked = bool(texelFetch(iChannel1, ivec2(16, 1), 0).x);\n        bool backspace_is_clicked = bool(texelFetch(iChannel1, ivec2(8, 1), 0).x);\n        if(space_is_clicked)\n        {\n            // Reverse the direction of the simulation.\n            vec2 tmp = field.xy;\n            field.xy = field.zw;\n            field.zw = tmp;\n        }\n        else if (shift_is_clicked)\n        {\n            // Clear the field.\n            field = vec4(0);\n        }\n        else if (backspace_is_clicked)\n        {\n            // Reset the simulation.\n            field = initial_state(coords, extent);\n        }\n\n        bool prev_mouse_state = read_buffer(iChannel0, ivec2(0, extent.y - 1)).y > 0.;\n        if(iMouse.z < 0. && prev_mouse_state)\n        {\n            field += mouse_pulse(coords, extent, iMouse);\n        }\n    }\n    else if(coords == ivec2(0, extent.y - 1))\n    {\n        field.y = iMouse.z;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float c = 0.5;\nconst float lens_ior = 1.5;\nconst float prism_ior = 1.5;\nconst float damping_coeff = 0.9999;\nconst float pulse_1_size = 0.04;\nconst float pulse_1_ampl = 1.;\nconst float pulse_1_wl_min = 8.;\nconst float pulse_1_wl_max = pulse_1_wl_min * 3.;\nconst float pulse_2_size = 0.06;\nconst float pulse_2_wl = 10.;\nconst float pulse_2_ampl = 1.;\nconst float pulse_3_size = 0.06;\nconst float pulse_3_wl = 12.;\nconst float pulse_3_ampl = 0.3;\nconst float lens_r = 0.5;\nconst float lens_size = 0.5;\nconst float slit_size = pulse_2_wl;\nconst float slits_pos_y = 0.5;\nconst float slit_offset = 0.15;\nconst vec2 mouse_pulse_size = vec2(0.03);\nconst float mouse_pulse_wl = 10.;\nconst float edge_smoothing_r = 4.;\n\nbool slits(const ivec2 coords, const ivec2 extent)\n{\n    float x = float(coords.x) / float(extent.x) * 2. - 1.;\n    return coords.y == int(float(extent.y) * slits_pos_y) &&\n           coords.x > extent.x / 3 &&\n           coords.x < extent.x / 3 * 2 &&\n           abs(x - slit_offset / 3.) > slit_size / float(extent.x) &&\n           abs(x + slit_offset / 3.) > slit_size / float(extent.x);\n}\n\nfloat lens(const vec2 coords, const ivec2 extent, const vec2 pos, const vec2 orientation, const float r, const float size)\n{\n    vec2 normalized_coords = (vec2(coords) - vec2(extent) * 0.5) / float(extent.y);\n    normalized_coords -= pos;\n    normalized_coords = vec2(dot(normalized_coords, vec2(orientation.y, -orientation.x)), dot(normalized_coords, orientation));\n    float a = sqrt(r * r - size * size * 0.25);\n    normalized_coords += normalized_coords.y > 0. ? vec2(0, a) : -vec2(0, a);\n\n    return clamp((r - length(normalized_coords)) * float(extent.y) / edge_smoothing_r, 0., 1.);\n}\n\nfloat lens(const vec2 coords, const ivec2 extent)\n{\n    vec2 extent_f = vec2(extent);\n    vec2 normalized_extent = extent_f / extent_f.y;\n    return mix(1., 1. / lens_ior, lens(coords, extent, vec2(normalized_extent.x / 3., 0), vec2(0, 1), lens_r, min(lens_size, normalized_extent.x/3.)));\n}\n\nfloat prism(const vec2 coords, const ivec2 extent, const vec2 pos, const vec2 orientation, const float size)\n{\n    vec2 normalized_coords = (vec2(coords) - vec2(extent) * 0.5) / float(extent.y);\n    normalized_coords -= pos;\n    normalized_coords = vec2(dot(normalized_coords, vec2(orientation.y, -orientation.x)), dot(normalized_coords, orientation));\n    float a = dot(normalized_coords, vec2(cos(radians(30.)), sin(radians(30.))));\n    float b = dot(normalized_coords, vec2(cos(radians(150.)), sin(radians(150.))));\n    float c = dot(normalized_coords, vec2(cos(radians(270.)), sin(radians(270.))));\n    float d = max(max(a, b), c);\n    return clamp((size - d) * float(extent.y) / edge_smoothing_r, 0., 1.);\n}\n\nfloat prism(const vec2 coords, const ivec2 extent)\n{\n    vec2 extent_f = vec2(extent);\n    vec2 normalized_extent = extent_f / extent_f.y;\n    const float angle = radians(-20.);\n    vec2 dir = vec2(cos(angle), sin(angle));\n    return mix(1., 1. / prism_ior, prism(coords, extent, -vec2(normalized_extent.x / 3. + 0.1, 0), dir, 0.2));\n}\n\nbool walls(const ivec2 coords, const ivec2 extent)\n{\nreturn coords.x == extent.x / 3 ||\n       coords.x == extent.x / 3 * 2 ||\n       slits(coords, extent);\n}\n\nbool boundary(const ivec2 coords, const ivec2 extent)\n{\n    return any(lessThan(coords, ivec2(0))) ||     // bottom-left corner\n           any(greaterThan(coords, extent - ivec2(1, 2))) ||  // top-right corner\n           walls(coords, extent);\n}\n\n#define read_buffer(buffer, uv) texelFetch(buffer, uv, 0)\n\nvec2 sample_field(ivec2 coords, const ivec2 extent, const sampler2D channel)\n{\n    if(boundary(coords, extent))\n    {\n        // wall\n        return vec2(0);\n    }\n\n    return read_buffer(channel, coords).xy;\n}\n\nvec4 pulse(const ivec2 coords, const ivec2 extent, const vec2 pos, const vec2 direction, const float wl, const float ampl, const vec2 pulse_size)\n{\n    vec4 result;\n    vec2 extent_f = vec2(extent);\n    vec2 normalized_coords = (vec2(coords) - vec2(extent) * 0.5) / float(extent.y);\n\n    vec2 transformed_coords = normalized_coords - pos;\n    transformed_coords = vec2(dot(transformed_coords, vec2(direction.y, -direction.x)), dot(transformed_coords, direction));\n    float r = length(transformed_coords / pulse_size);\n    float phase = transformed_coords.y * extent_f.y * radians(360.) / wl;\n    result.xy = vec2(cos(phase), sin(phase)) * exp(-r*r);\n\n    transformed_coords += vec2(0, c / extent_f.y);\n    r = length(transformed_coords / pulse_size);\n    phase = transformed_coords.y * extent_f.y * radians(360.) / wl;\n    result.zw = vec2(cos(phase), sin(phase)) * exp(-r*r);\n    return result * ampl;\n}\n\nfloat accumulated_collision_energy(const ivec2 coords, const sampler2D channel, const float prev_energy)\n{\n    vec2 ampl = read_buffer(channel, coords - ivec2(0, 1)).xy;\n    float mix_ratio = 0.3;\n    return prev_energy * mix_ratio + dot(ampl, ampl);\n}\n\nvec4 dispersion_pulse(const ivec2 coords, const ivec2 extent)\n{\n    vec2 extent_f = vec2(extent);\n    vec2 normalized_extent = extent_f / extent_f.y;\n    vec2 pos = vec2(-normalized_extent.x / 3. - 0.15, -0.35);\n    const float angle = radians(55.);\n    vec2 dir = vec2(cos(angle), sin(angle));\n    const int num_samples = 100;\n    float ampl = pulse_1_ampl / float(num_samples);\n    vec4 result = vec4(0);\n    for(int i = 0; i < num_samples; ++i)\n    {\n        float wl = mix(pulse_1_wl_min, pulse_1_wl_max, float(i)/float(num_samples - 1));\n        result += pulse(coords, extent, pos, dir, wl, ampl, vec2(pulse_1_size));\n    }\n    return result;\n}\n\nvec4 initial_state(const ivec2 coords, const ivec2 extent)\n{\n    vec2 extent_f = vec2(extent);\n    vec2 normalized_extent = extent_f / extent_f.y;\n    return dispersion_pulse(coords, extent) +\n           pulse(coords, extent, vec2(0., -0.3), vec2(0, 1), pulse_2_wl, pulse_2_ampl, vec2(pulse_2_size)) +\n           pulse(coords, extent, vec2(normalized_extent.x / 3., -0.3), vec2(0, 1), pulse_3_wl, pulse_3_ampl, vec2(pulse_3_size));\n}\n\nvec4 mouse_pulse(const ivec2 coords, const ivec2 extent, vec4 mouse)\n{\n    vec2 extent_f = vec2(extent);\n        \n    // Emit a pulse.\n    vec2 current_pos = (mouse.xy - extent_f * 0.5) / extent_f.y;\n    vec2 click_pos = (abs(mouse.zw) - extent_f * 0.5) / extent_f.y;\n\n    vec2 diff = current_pos - click_pos;\n    float ampl = length(diff);\n\n    if(ampl != 0.)\n    {\n        vec2 direction = diff / ampl;\n        return pulse(coords, extent, click_pos, direction, mouse_pulse_wl, ampl, mouse_pulse_size);\n    }\n    return vec4(0);\n}\n\n#define f(v, coords, offset, extent, channel) \\\n     ((sample_field(coords + offset, extent, channel) - v) * \\\n      pow(lens(vec2(coords) + vec2(offset) * 0.5, extent) * prism(vec2(coords) + vec2(offset) * 0.5, extent), 2.))\n\nvoid simulation(inout vec4 field, const ivec2 coords, const ivec2 extent, const sampler2D channel)\n{\n    if(coords.y == extent.y - 1)\n    {\n        field.x = accumulated_collision_energy(coords, channel, field.x);\n        return;\n    }\n\n    if(boundary(coords, extent))\n    {\n        return;\n    }\n\n    vec2 a = f(field.xy, coords, +ivec2(1, 0), extent, channel) +\n             f(field.xy, coords, -ivec2(1, 0), extent, channel) +\n             f(field.xy, coords, +ivec2(0, 1), extent, channel) +\n             f(field.xy, coords, -ivec2(0, 1), extent, channel) +\n            (f(field.xy, coords, +ivec2(1, 1), extent, channel) +\n             f(field.xy, coords, -ivec2(1, 1), extent, channel) +\n             f(field.xy, coords, +ivec2(1,-1), extent, channel) +\n             f(field.xy, coords, -ivec2(1,-1), extent, channel)) * exp(-1.);\n    a /= 1. + sqrt(0.5);\n\n    vec2 prev = field.xy;\n    field.xy += (field.xy - field.zw)*damping_coeff + a * c * c;\n    field.zw = prev;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 field, in vec2 coords )\n{\n    field = read_buffer(iChannel0, ivec2(coords));\n    simulation(field, ivec2(coords), ivec2(iResolution.xy), iChannel0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 field, in vec2 coords )\n{\n    field = read_buffer(iChannel0, ivec2(coords));\n    simulation(field, ivec2(coords), ivec2(iResolution.xy), iChannel0);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 field, in vec2 coords )\n{\n    field = read_buffer(iChannel0, ivec2(coords));\n    simulation(field, ivec2(coords), ivec2(iResolution.xy), iChannel0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}