{"ver":"0.1","info":{"id":"7lBXzV","date":"1628078851","viewed":112,"name":"Ellipsoid (Max Norm Distance)","username":"TheTurk","description":"Maximum norm distance function for an ellipsoid.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","sphere","circle","distance","ellipsoid","ellipse","linfinity","maximumnorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nTo compute the maximum norm distance between a point p and a \nprimitive we need to find the size of the smallest \naxis-aligned cube (compared to the size of the smallest \nsphere under Euclidian norm) centered at p that touches the \nsurface of the primitive. There are usually three cases that \nneed to be handled depending on whether the point that \ntouches the surface of the primitive lies on a corner, edge \nor face of the cube.\n*/\n\nfloat ellipse(vec2 position, vec2 radius) {\n    position = abs(position);\n    float d = max(abs(position.x - radius.x), position.y);\n    d = min(d, max(position.x, abs(position.y - radius.y)));\n    float a = dot(vec2(1.0), 1.0 / (radius * radius));\n    float b = dot(vec2(1.0), position / (radius * radius));\n    float c = dot(vec2(1.0), (position * position) / (radius * radius)) - 1.0;\n    float discriminant = b * b - a * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / a;\n        d = min(t, d);\n    }\n    return d;\n}\n\nfloat ellipsoid(vec3 position, vec3 radius) {\n    position = abs(position);\n\n    // closest point lies on cube face\n    float d = max(max(abs(position.x - radius.x), position.y), position.z);\n    d = min(d, max(max(position.x, abs(position.y - radius.y)), position.z));\n    d = min(d, max(max(position.x, position.y), abs(position.z - radius.z)));\n      \n    // closest point lies on cube edge\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.yz * radius.yz));\n        float b = dot(vec2(1.0), position.yz / (radius.yz * radius.yz));\n        float c = dot(vec2(1.0), (position.yz * position.yz) / (radius.yz * radius.yz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.x));\n        }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xz * radius.xz));\n        float b = dot(vec2(1.0), position.xz / (radius.xz * radius.xz));\n        float c = dot(vec2(1.0), (position.xz * position.xz) / (radius.xz * radius.xz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.y));\n       }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xy * radius.xy));\n        float b = dot(vec2(1.0), position.xy / (radius.xy * radius.xy));\n        float c = dot(vec2(1.0), (position.xy * position.xy) / (radius.xy * radius.xy)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.z));\n        }\n    }\n\n    // closest point lies on cube corner\n    float a = dot(vec3(1.0), 1.0 / (radius * radius));\n    float b = dot(vec3(1.0), position / (radius * radius));\n    float c = dot(vec3(1.0), (position * position) / (radius * radius)) - 1.0;\n    float discriminant = b * b - a * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / a;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;  \n    float z = (fract((iTime * 0.2) + 0.5) * 2.0 - 1.0) * 0.6;\n\n    // float d = ellipse(position, vec2(0.75, 0.5));\n    vec3 radius = vec3(0.75, 0.5, 0.5);\n    float d = ellipsoid(vec3(position, z), radius);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0, 0.9, 1.0) + sign(d) * vec3(-0.3, 0.4, 0.3); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d); // ripples\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.001) * iResolution.y)); // outline\n    fragColor = vec4(color, 1.0);\n} ","name":"Image","description":"","type":"image"}]}