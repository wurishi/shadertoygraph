{"ver":"0.1","info":{"id":"fsV3zt","date":"1631987255","viewed":55,"name":"cube&julia set","username":"AndryM793","description":"test cube & Julia set","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int accuracy = 25;\nconst float jlen = 2.;\nconst vec3 axis = vec3(0.,1.,1.);\nconst float battery = 0.02;\n\n\nmat3 rotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nfloat boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return (-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return (tN > 0.)?tN:tF;\n}\n\n\nfloat lengthToJulia(in vec2 p, in vec2 c){\n    int i = 0;\n    for(float t; i <= accuracy;){\n        t = (p.x*p.x) - (p.y*p.y);\n        p.y = (p.x*p.y) + (p.y*p.x);\n        p.x = t;\n        p += c;\n        if(length(p) > jlen){ break; }\n        i++;\n    }\n    return float(i) / float(accuracy);\n}\n\n\nfloat figureNoise(in vec2 x, float seed){\n    return fract(tan(dot(x, vec2(10.58927, 10.89820471)/seed/50.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n    mat3 rt = rotationMatrix(axis, iTime);\n    vec3 start = vec3(0, 0, -5) * rt;\n    vec3 rd = normalize(vec3(uv, 0.7)) * rt;\n    vec3 n;\n    float bl = boxIntersection(start, rd, vec3(1.7,1.7,1.7), n);\n    if(bl > 0.){ \n        vec3 ts = rd*bl + start;\n        vec2 c = vec2(sin(iTime)*sin(iTime/30.), cos(iTime));\n        vec2 p;\n        if(abs(n.x) > 0.){ p = ts.yz; }else if(abs(n.y) > 0.){ p = ts.xz; }else{ p = ts.xy; }\n        float jl = lengthToJulia(p, c);\n        if(false){//jl >= 1.\n            fragColor = vec4(1., 1., 1., 1.0) * figureNoise(fragCoord, iTime-float(int(iTime)));\n        }\n        else{\n            vec3 light = normalize(vec3(-sin(iTime*2.), cos(iTime*4.), -sin(iTime)));\n            fragColor = vec4(1.0 - battery, battery, 0.0, 1.0) * (jl+max(0., dot(light, n))); \n        }\n    }\n    else{ fragColor = vec4(1., 1., 1., 1.0) * figureNoise(fragCoord, iTime-float(int(iTime))); }\n    \n}","name":"Image","description":"","type":"image"}]}