{"ver":"0.1","info":{"id":"4dBBWt","date":"1502636125","viewed":466,"name":"Basic Raymarching - Spheres","username":"CaliCoastReplay","description":"My first attempt at truly learning raymarching principles from the ground up.  Experiments in faked backlit \"global illumination\" and Fresnel shadows. Using tutorial work from:\n\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Learning from : http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\n\n//Contains some experimental terms to simulate global illumination\n//on backside of object via a variation\n//on specular highlights, and the use of Fresnel terms\n//for both light and shadow on the outside of objects.\n\n//Comments encouraged - code will be commented for teaching purposes soon.\n\n//--CaliCoastReplay\n\nfloat distance_from_sphere(in vec3 world_point, in vec3 sphere_center, float radius)\n{\n    return length(world_point - sphere_center) - radius;\n}\n\n\nfloat map_the_world(in vec3 world_point)\n{\n    \n //   float sphere_0 = distance_from_sphere(p, vec3(-0.4 + cos(iTime), 0.0, 0.0), 1.5);    \n //   float sphere_1= distance_from_sphere(p, vec3(2.4 + sin(iTime), 1.0, 1.5), 1.5);\n //   float sphere_2= distance_from_sphere(p, vec3(-0.0 + cos(iTime+1.57), 2.0,3.0),1.5);\n      \n    float sphere_0 = distance_from_sphere(world_point, vec3(-0.4, 0.0, 0.0), 1.5);    \n    float sphere_1= distance_from_sphere(world_point, vec3(2.4, 1.0, 1.0), 1.5);\n    float sphere_2= distance_from_sphere(world_point, vec3(-0.0, 2.0,2.0),1.5);\n    \n    return min(min(sphere_0, sphere_1), sphere_2);\n}\n\nvec3 calculate_normal(in vec3 world_point)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(world_point + small_step.xyy)\n        - map_the_world(world_point - small_step.xyy);\n    float gradient_y = map_the_world(world_point + small_step.yxy) \n        - map_the_world(world_point - small_step.yxy);\n    float gradient_z = map_the_world(world_point + small_step.yyx) \n        - map_the_world(world_point - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 ray_march(in vec3 ray_origin, in vec3 ray_direction)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 64;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ray_origin + total_distance_traveled * ray_direction;\n\n\t\tfloat distance_to_closest = map_the_world(current_position);\n\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \n        {\n            vec3 normal = calculate_normal(current_position);\n            \n            vec3 light_positions[3];\n            light_positions[0] = vec3(1.0+sin(iTime)*5.0, -3.0+3.0*cos(iTime/3.0), 4.0 + 1.0 *sin(iTime/5.0));\n            light_positions[1] = vec3(1.0-sin(iTime/2.0)*2.0, -1.0-cos(iTime/2.0), 7.0 + 1.0 -sin(iTime/4.0));\n            light_positions[2] = vec3(2.0-sin(iTime/2.0)*2.0, -5.0-sin(iTime/4.0), 2.0 + 1.0 -sin(iTime/1.0));\n            float light_intensities[3];\n            light_intensities[0] = 0.8;\n            light_intensities[1] = 0.4;\n            light_intensities[2] = 0.7;\n            vec3 direction_to_view = normalize(current_position - ray_origin);\n            \n            vec3 col = vec3(0.0);\n            \n            for (int j = 0; j < 3; j++)\n            {\n                vec3 direction_to_light = normalize(current_position - light_positions[j]);\n                vec3 light_reflection_unit_vector =\n                \t reflect(direction_to_light ,normal);                \n\n                float diffuse_intensity = 0.6*pow(max(0.0, dot(normal, direction_to_light)),5.0);            \n                float ambient_intensity = 0.2;            \n                float specular_intensity = \n                    1.15* pow(clamp(dot(direction_to_view, light_reflection_unit_vector), 0.0,1.0), 50.0);\n                float backlight_specular_intensity =             \n                    0.2* pow(clamp(dot(direction_to_light, light_reflection_unit_vector),0.0,1.0), 3.0); \n                float fresnel_base = 1.0 + dot(direction_to_view, normal);\n                float fresnel_intensity = 0.10*pow(fresnel_base, 0.3);\n                float fresnel_shadowing = pow(fresnel_base, 5.0);            \n                float fresnel_supershadowing = pow(fresnel_base, 50.0);\n                float attenuation =  pow(total_distance_traveled,2.0)/180.0;\n\n                \n            \tvec3 colFromLight = vec3(0.0);\n                colFromLight += vec3(0.89, 0.0, 0.0) * diffuse_intensity;\n                colFromLight += vec3(0.3, 0.1, 0.1) * ambient_intensity;\n                colFromLight += vec3(1.0) * specular_intensity;            \n                colFromLight += vec3(1.0,0.5,0.5) * backlight_specular_intensity;            \n                colFromLight += vec3(1.0, 0.1, 0.2) * fresnel_intensity;\n                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_shadowing ;\n                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_supershadowing * col * col;\n                colFromLight += vec3(.3, 0.1, 0.1) - attenuation ; \n               \tcolFromLight /= 1.2;\n                colFromLight *= light_intensities[j];\n                col += colFromLight;\n            }\n            return col;\n        }\n\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n\n    vec3 camera_position = vec3(0.5, 0.5 + sin(iTime)/2.0, -6.0+cos(iTime));\n    vec3 ray_origin = camera_position;\n    vec3 ray_direction = vec3(uv, 1.0);\n\n    vec3 shaded_color = ray_march(ray_origin, ray_direction);\n\n    fragColor = vec4(shaded_color, 1.0);\n}","name":"Image","description":"","type":"image"}]}