{"ver":"0.1","info":{"id":"MXjyWz","date":"1727161563","viewed":64,"name":"Moon Cake","username":"JackFreeman","description":"hah","likes":7,"published":1,"flags":40,"usePreview":0,"tags":["jjy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// storage register/texel addresses\nconst ivec2 txCakePosition = ivec2(0,0);\nconst ivec2 txCakeVersion  = ivec2(1,0);\nconst ivec2 txBiteCount     = ivec2(2,0);\nconst ivec2 txPoints       = ivec2(3,0);\nconst ivec2 txColor       = ivec2(4,0);\nconst ivec2 txState      = ivec2(5, 0);\nconst ivec2 txRo      = ivec2(6, 0);\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nconst int[] powers = int[](1, 10, 100, 1000, 10000);\n\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\n\nint PrintInt( in vec2 uv, in int value )\n{\n    const int maxDigits = 3;\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the exact distance to a generic (non symmetric) ellipsoid\n// requires solving a sixth degree equation, which can be difficult.\n// Approximating the distance is easier though. This shaders shows one\n// such approximation that produces better results than the naive\n// distance bound which is based on a scaled sphere. More info here:\n//\n// https://iquilezles.org/articles/ellipsoids\n//\n// The technique is based on dividing the bad approximation's distance estimation\n// by the length of its gradient to get a first order approximation to the true\n// distance (see https://iquilezles.org/articles/distance)\n\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n//------------------------------------------------------------------\n// ellipsoid SDF approximation\n//------------------------------------------------------------------\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length2(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n//------------------------------------------------------------------\n// vec3 center = vec3(0.5, 0.3, 0.1);\n\nfloat sdMooncake(in vec3 p, vec3 center, int biteCount){\n    float ra = 0.1;\n    float height = 0.05;\n    float d1 = sdRoundedCylinder(p-center, ra, ra * 0.1, height);\n\n    float d3 = d1;\n    float an = 2.0f;\n    vec3 surface = vec3(0.0f, height+0.007f, 0.0f);\n    float d_lace = sdTorus(p-(center+surface+ra*2.0f*vec3(0.0f, 0.0f, 1.0f)), vec2(0.02, 0.01));\n    float size = 0.025;\n    for (float i = 0.0f; i < 2.0f*3.1415926; i += 0.4f){\n      vec3 c = center + ra*2.0f*vec3(sin(i), 0.0f, cos(i));\n      d3 = min(d3, sdRoundedCylinder(p-c, size, ra*0.01, height));\n      d_lace = min(d_lace, sdTorus(p-c-surface, vec2(size, 0.01)));\n    }\n    d_lace = max(-sdRoundedCylinder(p-center, ra, ra*0.1, height*2.0f), d_lace); // 减掉中间部分\n    d_lace = min(d_lace, sdTorus(p-center-surface, vec2(ra*2.0f, 0.01))); // 加个环\n    //圈\n    vec3 q = p - center-surface;\n    d_lace = min( d_lace, sdTorus82( q, vec2(0.2/1.414,0.01) ) );\n    \n    //装饰线条\n    float d_line = sdCapsule(p-center-surface, vec3(-0.01, 0.0f, -ra-ra), vec3(-0.01, 0.0f, ra+ra), 0.01);\n    d_line = min(d_line, sdCapsule(p-center-surface, vec3(-0.01, 0.0f, -ra-ra), vec3(-0.01, 0.0f, ra+ra), 0.01));\n    d_line = min(d_line, sdCapsule(p-center-surface, vec3(0.01, 0.0f, -ra-ra), vec3(0.01, 0.0f, ra+ra), 0.01));\n    \n    d_line = min(d_line, sdCapsule(p-center-surface, vec3(ra+ra, 0.0f, 0.01), vec3(-ra-ra, 0.0f, 0.01), 0.01));\n    d_line = min(d_line, sdCapsule(p-center-surface, vec3(ra+ra, 0.0f, -0.01), vec3(-ra-ra, 0.0f, -0.01), 0.01));\n    d_line = max(-sdBox(p-center-surface, vec3(2.0*ra/1.414, 0.1, 2.0*ra/1.414)), d_line);\n\n    d_lace = min(d_lace, d_line);\n\n    //字\n    float d_char = sdCapsule(p-center-surface, vec3(-0.05, 0.0f, -0.1), vec3(0.04, 0.0f, -0.1), 0.01);\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.02, 0.0f, -0.1), vec3(-0.03, 0.0f, -0.02), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.05, 0.0f, -0.06), vec3(0.03, 0.0f, -0.06), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(0.03, 0.0f, -0.06), vec3(0.03, 0.0f, -0.02), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.05, 0.0f, -0.02), vec3(0.05, 0.0f, -0.02), 0.01));\n\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.08, 0.0f, 0.06), vec3(-0.03, 0.0f, 0.02), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.05, 0.0f, 0.045), vec3(-0.05, 0.0f, 0.1), 0.01));\n\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.01, 0.0f, 0.04), vec3(0.04, 0.0f, 0.04), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.02, 0.0f, 0.1), vec3(0.05, 0.0f, 0.1), 0.01));\n    \n    \n    d1 = min(d3, d_char);\n    d1 = min(d1, d_lace);\n\n    // 咬掉2口\n    vec3 bite_center[2] = vec3[2](\n        vec3(0.2, 0, 0.1), \n        vec3(0.2, 0, -0.1)\n    );\n    for(int i = 0; i < biteCount; ++ i){\n        d1 = max(-sdRoundedCylinder(p-center-bite_center[i], ra*1.2, 0.01, 100.0*height), d1);\n    }\n    return d1;\n}\n\nfloat sdSmallMooncake(in vec3 p, const vec3 center, int biteCount){\n    float ra = 0.1;\n    float height = 0.05;\n    float d = sdRoundedCylinder(p-center, ra, ra * 0.1, height);\n    vec3 surface = vec3(0.0f, height+0.007f, 0.0f);\n    float size = 0.025;\n    float d2 = d;\n    float d_lace = 100.f;\n    for (float i = 0.0f; i < 2.0f*3.1415926; i += 0.4f){\n      vec3 c = center + ra*2.0f*vec3(sin(i), 0.0f, cos(i));\n      d = min(d, sdRoundedCylinder(p-c, size, ra*0.01, height));\n      d_lace = min(d_lace, sdTorus(p-c-surface, vec2(size, 0.01)));\n    }\n    d_lace = max(-sdRoundedCylinder(p-center, ra, ra*0.1, height*2.0f), d_lace); // 减掉中间部分\n    d_lace = min(d_lace, sdTorus(p-center-surface, vec2(ra*2.0f, 0.01))); // 加个环\n    d = min(d, d_lace);\n    vec3 c = (center+surface);\n    for (float i =  0.0f; i < 3.14159*2.0; i = i + 2.0 * 3.1415926 / 5.0){\n        vec3 aa1 = c + ra * vec3(sin(i), 0.0f, cos(i)) + vec3(0.0f, 0.075, 0.0f);\n        vec3 aa2 = c + ra * vec3(sin(i), 0.0f, cos(i));\n        float roundcore = max(-sdRoundCone(p, aa1, c, 0.04, 0.001), sdRoundCone(p, aa2, c, 0.045, 0.001));\n        d = min(d, roundcore);\n    }\n    vec3 bite_center[2] = vec3[2](\n        vec3(0.2, 0, 0.1), \n        vec3(0.2, 0, -0.1)\n    );\n    for (int i = 0; i < biteCount; ++ i){\n        d = max(-sdRoundedCylinder(p-center-bite_center[i], ra*1.2, 0.001, 100.0*height), d);\n    }\n    return d;\n}\nvec2 map( in vec3 p, int cakeVersion, int biteCount)\n{    \n    float d1 = p.y+0.1;\n    if (cakeVersion == 0){\n        return vec2(d1,2.0);\n    }else if(cakeVersion == 1){\n        float d2 = sdMooncake(p, vec3(-0.1), biteCount);\n        return (d1<d2) ? vec2(d1,2.0) : vec2(d2,1.0); \n    }else{\n        float d2 = sdSmallMooncake(p, vec3(-0.1), biteCount);\n        return (d1<d2) ? vec2(d1,2.0) : vec2(d2,1.0);\n    }\n}\n\n// https://iquilezles.org/articles/nvscene2008/\nvec2 castRay( in vec3 ro, in vec3 rd, int cakeVersion, int biteCount)\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 20.0;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, cakeVersion, biteCount);\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n// https://iquilezles.org/articles/nvscene2008/\nfloat calcAO( in vec3 pos, in vec3 nor, int cakeVersion, int biteCount)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, cakeVersion, biteCount).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y); \n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, int cakeVersion, int biteCount)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, cakeVersion, biteCount).x;\n        res = min( res, smoothstep(0.0,1.0,4.0*h/t ));\n        t += clamp( h, 0.0001, 0.002 );\n        if( res<0.1 || t>1.0 ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*res*(4.0-3.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos, int cakeVersion, int biteCount)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, cakeVersion, biteCount).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, cakeVersion, biteCount).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, cakeVersion, biteCount).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, cakeVersion, biteCount ).x );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, int cakeVersion, int biteCount, vec3 cakeColor)\n{ \n    vec3 col = vec3(0.0);\n    \n    vec2  res = castRay(ro,rd, cakeVersion, biteCount);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n        vec3 perturbedNormal = vec3(0.0f);\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            // col = 0.05*vec3(1.0);\n            col = vec3(0.94, 0.53, 0.07f);\n            // occ = calcAO(pos, nor);\n        }\n        else\n        {\n            nor = calcNormal( pos, cakeVersion, biteCount);\n            // occ = 0.5+0.5*nor.y;\n            // col = vec3(0.64, 0.33, 0.07f);\n            col = cakeColor;\n            // col = texture(iChannel0, pos);\n        }\n        occ = calcAO(pos, nor, cakeVersion, biteCount);\n        vec3 lin = vec3(0.0);\n\n        // sun\n        float ks = 0.4;\n        {\n            vec3  lig = normalize( vec3(1.5, 1.5, -2.5) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, cakeVersion, biteCount);\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            // lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            vec3 ref = reflect(rd, nor);\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, cakeVersion, biteCount);\n            lin += col*0.20*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*0.1;\n\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );           \n    }\n    \n\treturn col;\n}\n\nfloat hit( in vec3 ro, in vec3 rd, int cakeVersion, int biteCount)\n{ \n    vec3 col = vec3(0.0);\n    \n    vec2  res = castRay(ro,rd, cakeVersion, biteCount);\n    if (res.y > 0.5 && res.y <= 1.5){\n        return 0.0f;\n    }\n    return 1.0f;\n}\n\n// utility functions\n// conversion from cartesian to polar\nvec2 toPolar(vec2 uv) { return vec2(length(uv),atan(uv.y,uv.x)); }\n// conversion from polar to cartesian\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\n// complex division in polar form z = vec2(radius,angle)\nvec2 zdiv(vec2 z1, vec2 z2) { return vec2(z1.x/z2.x,z1.y-z2.y); }\n// complex log in polar form z = vec2(radius,angle)\nvec2 zlog(vec2 z) { return toPolar(vec2(log(z.x),z.y)); }\n// complex exp in polar form z = vec2(radius,angle)\nvec2 zexp(vec2 z) { z = toCarte(z); return vec2(exp(z.x),z.y); }\n// smoothstep antialias with fwidth\nfloat ssaa(float v) { return smoothstep(-1.,1.,v/fwidth(v)); }\n// stroke an sdf 'd', with a width 'w', and a fill 'f' \nfloat stroke(float d, float w, bool f) {  return abs(ssaa(abs(d)-w*.5) - float(f)); }\n// fills an sdf 'd', and a fill 'f'. false for the fill means inverse \nfloat fill(float d, bool f) { return abs(ssaa(d) - float(f)); }\n// a signed distance function for a rectangle 's' is size\nfloat sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// a signed distance function for a circle, 'r' is radius\nfloat sdfCircle(vec2 uv, float r) { return length(uv)-r; }\n// a signed distance function for a hexagon\nfloat sdfHex(vec2 uv) { vec2 auv = abs(uv); return max(auv.x * .866 + auv.y * .5, auv.y)-.5; }\n// a signed distance function for a equilateral triangle\nfloat sdfTri(vec2 uv) { return max(abs(uv.x) * .866 + uv.y * .5, -uv.y)-.577; }\n// a 'fold' is a kind of generic abs(). \n// it reflects half of the plane in the other half\n// the variable 'a' represents the angle of an axis going through the origin\n// so in normalized coordinates uv [-1,1] \n// fold(uv,radians(0.)) == abs(uv.y) and fold(uv,radians(90.)) == abs(uv.x) \nvec2 fold(vec2 uv, float a) { a -= 1.57; vec2 axis = vec2(cos(a),sin(a)); return uv-(2.*min(dot(uv,axis),.0)*axis); }\n// 2d rotation matrix\nmat2 uvRotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // load game state\n    int cakeVersion     = int(loadValue( txCakeVersion ).x);\n    int biteCount       = int(loadValue( txBiteCount ).x);\n    float points       = loadValue( txPoints ).x;\n    vec3 cakeColor = texelFetch( iChannel0, txColor, 0 ).xyz;\n    vec3 ro = texelFetch( iChannel0, txRo, 0 ).xyz;\n\n    // camera\n    float position = 0.5;\n    //vec3 ro = vec3(position, 3.0f*position, position);\n    // center = vec3(0.1, 0.3 * iTime, 0.1);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize(cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          (cross(cu,cw) );\n\n    vec3 tot = vec3(0.0);\n\n    vec3 col = vec3(0.94, 0.53, 0.07f);\n    \n    // center = vec3(0.1, - mod(iTime * 0.5, 4.0), 0.1);\n    // int cakeVersion = 2;\n    // int biteCount = 2;\n\n    vec2 fc = fragCoord;\n\n    vec2 p = (2.0*fc-iResolution.xy)/iResolution.y;\n    \n    vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n    \n    col = render( ro, rd, cakeVersion, biteCount, cakeColor);\n\n    col = pow( col, vec3(0.4545) );\n\n    tot += col;\n    \n    // score\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    {\n        float f = float(PrintInt( (uv-vec2(-1.5,0.8))*10.0, int(points) ));\n        tot = mix( tot, vec3(1.0,1.0,1.0), f );\n    }\n    \n    // rabbit\n    // uv for the rabbit\n    // save current uv for the rabbit\n    vec2 uvr = uv;\n    // a flag for the scene\n    float sc = 1.;\n    uvr = uvr*2.3+vec2(3.75,-1.84);\n    \n    // uv for the rabbit ears\n    vec2 uvears = vec2(abs(uvr.x),uvr.y)*uvRotate(radians(-20.)); \n    float ears = stroke(sdfCircle(vec2(-abs(uvears.x),uvears.y)-vec2(.16,.3),.2),.04,true); \n    \n    // uv for the rabbit eyes\n    vec2 uveyes = vec2(abs(uvr.x),uvr.y)*uvRotate(radians(-40.)); \n    float eyes = fill(sdfCircle(vec2(-abs(uveyes.x),uveyes.y)-vec2(.05,.1),.07),false); \n    \n    // nose ant teeth\n    float nose = fill(sdfCircle(vec2(abs(uvr.x),uvr.y)-vec2(.008,.0),.02),false);\n    float teeth = fill(sdfRect(vec2(abs(uvr.x),uvr.y)-vec2(.007,-.045),vec2(.005,.015)),false);\n\n    // the face is just a bunch of circles\n    float face = max(max(\n        fill(sdfCircle(uvr-vec2(.0,.0),.07),true),\n        fill(sdfCircle(vec2(abs(uvr.x),uvr.y)-vec2(.078,.05),.07),true)),\n        fill(sdfCircle(uvr-vec2(.0,.1),.12),true));\n    \n    // compose the rabbit\n    float rabbit = min(min(min(eyes,nose),teeth),max(ears,face));\n    \n    tot = mix( tot, vec3(1.0,1.0,1.0), rabbit);\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n// Function to generate a piano-like waveform\nfloat pianoWave(float freq, float t) {\n    float envelope = exp(-3.0 * t); // Exponential decay envelope\n    float harmonics = sin(2.0 * PI * freq * t) +\n                      0.5 * sin(2.0 * PI * 2.0 * freq * t) +\n                      0.25 * sin(2.0 * PI * 3.0 * freq * t);\n    return envelope * harmonics;\n}\n\nconst float f_0 = 0.0;\nconst float f_1_ = 130.81;\nconst float f_2_ = 146.83;\nconst float f_3_ = 164.81;\nconst float f_4_ = 174.61;\nconst float f_5_ = 196.00;\nconst float f_6_ = 220.00; // 6_\nconst float f_7_ = 246.94; // 7_\nconst float f_1 = 261.63; // 1\nconst float f_2 = 293.66; // 2\nconst float f_3 = 329.63; // 3\nconst float f_4 = 349.23; // 4\nconst float f_5 = 392.00; // 5\nconst float f_6 = 440.00; // 6\nconst float f_7 = 493.88; // 7\nconst float f_1_P = 523.25; // 1 (octave higher)\n\n// http://p.onegreen.net/GePu/HTML/210905.html\n// Define notes and their durations (in seconds)\nconst float[] notes = float[] (\n    // repeat twice\n    f_5_,    f_5_,   f_5_,    f_1,f_2,\n    f_0,       f_5_,   f_5_, f_5_,\n    f_5,           f_3,     f_2,\n    f_3,  f_2, f_0,\n    f_5_, f_5_, f_5_, f_5, f_3,\n    f_2, f_1, f_0, f_6_, f_1,\n    f_2, f_2, f_1,\n    f_3, f_2,\n    \n    f_5_,    f_5_,   f_5_,    f_1,f_2,\n    f_0,       f_5_,   f_5_, f_5_,\n    f_5,           f_3,     f_2,\n    f_3,  f_2, f_0,\n    f_5_, f_5_, f_5_, f_5, f_3,\n    f_2, f_1, f_0, f_6_, f_1,\n    f_2, f_2, f_1,\n    f_3, f_2,\n    // repeat end\n    \n    \n    f_2, f_1, f_6_, f_5_,\n    f_5_,\n    \n    f_5_, f_5, f_3,\n    f_2,\n    f_5_, f_5, f_3,\n    f_2,\n    f_5_, f_5, f_3,\n    \n    f_2, f_1, f_6_, f_1,\n    f_2, f_2, f_1,\n    f_6_, f_5_,\n    \n    // repeat twice start \n    f_2, f_2, f_1,\n    f_2, f_5, f_5, f_5,\n    \n    f_6, f_0, f_6, f_3,\n    f_6, f_5, f_5, f_0, f_3, f_3, f_5,\n    f_2, f_2, f_1,\n    f_7_, f_6_, f_5_, f_0, f_5, f_5, f_5,\n    \n    \n    f_6, f_0, f_6, f_3,\n    f_6, f_5, f_5, f_0, f_3, f_3, f_5,\n    f_2, f_2, f_2, f_1,\n    f_2, f_5, f_5, f_0, f_5,\n    \n    f_2, f_2, f_1,\n    f_2, f_5, f_5, f_5,\n    \n    f_6, f_0, f_6, f_3,\n    f_6, f_5, f_5, f_0, f_3, f_3, f_5,\n    f_2, f_2, f_1,\n    f_7_, f_6_, f_5_, f_0, f_5, f_5, f_5,\n    \n    \n    f_6, f_0, f_6, f_3,\n    f_6, f_5, f_5, f_0, f_3, f_3, f_5,\n    f_2, f_2, f_2, f_1,\n    f_2, f_5, f_5, f_0, f_5\n    // repeat end\n\n);\nconst float[] durations = float[] (\n    0.5, 0.5, 0.5, 0.25, 1.25, // Durations for each note\n    0.25, 0.25, 0.25, 0.25,\n    1.0,        0.75,  0.25,\n    0.5, 0.5, 1.0,\n    0.25, 0.5, 0.25, 0.75, 0.25,\n    0.25, 0.75, 0.5, 0.25, 0.25,\n    1.0, 0.75, 0.25,\n    0.5, 1.5,\n    \n    0.5, 0.5, 0.5, 0.25, 1.25,\n    0.25, 0.25, 0.25, 0.25,\n    1.0,        0.75,  0.25,\n    0.5, 0.5, 1.0,\n    0.25, 0.5, 0.25, 0.75, 0.25,\n    0.25, 0.75, 0.5, 0.25, 0.25,\n    1.0, 0.75, 0.25,\n    0.5, 1.5,\n    \n    0.75, 0.25, 0.25, 0.75,\n    2.0,\n    \n    1.0, 0.75, 0.25,\n    2.0,\n    1.0, 0.75, 0.25,\n    2.0,\n    1.0, 0.75, 0.25,\n    \n    0.5, 1.0, 0.25, 0.25,\n    1.0, 0.75, 0.25,\n    0.5, 1.5,\n    1.0, 0.75, 0.25,\n    0.25, 1.25, 0.25, 0.25,\n    \n    1.0, 0.25, 0.5, 0.25,\n    0.25, 0.75, 0.25, 0.25, 0.25, 0.25,\n    1.0, 0.75, 0.25,\n    0.25, 0.25, 0.5, 0.25, 0.25, 0.25, 0.25,\n    \n    1.0, 0.25, 0.5, 0.25,\n    0.25, 0.25, 0.5, 0.25, 0.25,0.25,0.25,\n    0.75, 0.25, 0.75, 0.25,\n    0.25, 0.25, 1.0, 0.25, 0.25,\n    \n    1.0, 0.75, 0.25,\n    0.25, 1.25, 0.25, 0.25,\n    \n    1.0, 0.25, 0.5, 0.25,\n    0.25, 0.75, 0.25, 0.25, 0.25, 0.25,\n    1.0, 0.75, 0.25,\n    0.25, 0.25, 0.5, 0.25, 0.25, 0.25, 0.25,\n    \n    1.0, 0.25, 0.5, 0.25,\n    0.25, 0.25, 0.5, 0.25, 0.25,0.25,0.25,\n    0.75, 0.25, 0.75, 0.25,\n    0.25, 0.25, 1.0, 0.25, 0.25\n);\n\nvec2 mainSound(in int samp, float time) {\n    vec2 result = vec2(0.0);\n    float currentTime = 0.0;\n\n    for (int note = 0; note < notes.length(); note++) {\n        float duration = durations[note];\n        if (time >= currentTime && time < currentTime + duration) {\n            result += pianoWave(notes[note], time - currentTime);\n        }\n        currentTime += duration;\n    }\n\n    return result;\n}\n","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// storage register/texel addresses\nconst ivec2 txCakePosition = ivec2(0,0);\nconst ivec2 txCakeVersion  = ivec2(1,0);\nconst ivec2 txBiteCount    = ivec2(2,0);\nconst ivec2 txPoints       = ivec2(3,0);\nconst ivec2 txColor       = ivec2(4,0);\nconst ivec2 txState      = ivec2(5, 0);\nconst ivec2 txRo      = ivec2(6, 0);\n\nconst float gameSpeed =  0.1;\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length2(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n//------------------------------------------------------------------\n// vec3 center = vec3(0.5, 0.3, 0.1);\n\nfloat sdMooncake(in vec3 p, vec3 center, int biteCount){\n    float ra = 0.1;\n    float height = 0.05;\n    float d1 = sdRoundedCylinder(p-center, ra, ra * 0.1, height);\n\n    float d3 = d1;\n    float an = 2.0f;\n    vec3 surface = vec3(0.0f, height+0.007f, 0.0f);\n    float d_lace = sdTorus(p-(center+surface+ra*2.0f*vec3(0.0f, 0.0f, 1.0f)), vec2(0.02, 0.01));\n    float size = 0.025;\n    for (float i = 0.0f; i < 2.0f*3.1415926; i += 0.4f){\n      vec3 c = center + ra*2.0f*vec3(sin(i), 0.0f, cos(i));\n      d3 = min(d3, sdRoundedCylinder(p-c, size, ra*0.01, height));\n      d_lace = min(d_lace, sdTorus(p-c-surface, vec2(size, 0.01)));\n    }\n    d_lace = max(-sdRoundedCylinder(p-center, ra, ra*0.1, height*2.0f), d_lace); // 减掉中间部分\n    d_lace = min(d_lace, sdTorus(p-center-surface, vec2(ra*2.0f, 0.01))); // 加个环\n    //圈\n    vec3 q = p - center-surface;\n    d_lace = min( d_lace, sdTorus82( q, vec2(0.2/1.414,0.01) ) );\n    \n    //装饰线条\n    float d_line = sdCapsule(p-center-surface, vec3(-0.01, 0.0f, -ra-ra), vec3(-0.01, 0.0f, ra+ra), 0.01);\n    d_line = min(d_line, sdCapsule(p-center-surface, vec3(-0.01, 0.0f, -ra-ra), vec3(-0.01, 0.0f, ra+ra), 0.01));\n    d_line = min(d_line, sdCapsule(p-center-surface, vec3(0.01, 0.0f, -ra-ra), vec3(0.01, 0.0f, ra+ra), 0.01));\n    \n    d_line = min(d_line, sdCapsule(p-center-surface, vec3(ra+ra, 0.0f, 0.01), vec3(-ra-ra, 0.0f, 0.01), 0.01));\n    d_line = min(d_line, sdCapsule(p-center-surface, vec3(ra+ra, 0.0f, -0.01), vec3(-ra-ra, 0.0f, -0.01), 0.01));\n    d_line = max(-sdBox(p-center-surface, vec3(2.0*ra/1.414, 0.1, 2.0*ra/1.414)), d_line);\n\n    d_lace = min(d_lace, d_line);\n\n    //字\n    float d_char = sdCapsule(p-center-surface, vec3(-0.05, 0.0f, -0.1), vec3(0.04, 0.0f, -0.1), 0.01);\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.02, 0.0f, -0.1), vec3(-0.03, 0.0f, -0.02), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.05, 0.0f, -0.06), vec3(0.03, 0.0f, -0.06), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(0.03, 0.0f, -0.06), vec3(0.03, 0.0f, -0.02), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.05, 0.0f, -0.02), vec3(0.05, 0.0f, -0.02), 0.01));\n\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.08, 0.0f, 0.06), vec3(-0.03, 0.0f, 0.02), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.05, 0.0f, 0.045), vec3(-0.05, 0.0f, 0.1), 0.01));\n\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.01, 0.0f, 0.04), vec3(0.04, 0.0f, 0.04), 0.01));\n    d_char = min(d_char, sdCapsule(p-center-surface, vec3(-0.02, 0.0f, 0.1), vec3(0.05, 0.0f, 0.1), 0.01));\n    \n    \n    d1 = min(d3, d_char);\n    d1 = min(d1, d_lace);\n\n    // 咬掉2口\n    vec3 bite_center[2] = vec3[2](\n        vec3(0.15, 0, 0.15), \n        vec3(0.15, 0, -0.15)\n    );\n    for(int i = 0; i < biteCount; ++ i){\n        d1 = max(-sdRoundedCylinder(p-center-bite_center[i], ra, ra * 0.1, 2.0*height), d1);\n    }\n    return d1;\n}\n\nfloat sdSmallMooncake(in vec3 p, const vec3 center, int biteCount){\n    float ra = 0.1;\n    float height = 0.05;\n    float d = sdRoundedCylinder(p-center, ra, ra * 0.1, height);\n    vec3 surface = vec3(0.0f, height+0.007f, 0.0f);\n    float size = 0.025;\n    float d2 = d;\n    float d_lace = 100.f;\n    for (float i = 0.0f; i < 2.0f*3.1415926; i += 0.4f){\n      vec3 c = center + ra*2.0f*vec3(sin(i), 0.0f, cos(i));\n      d = min(d, sdRoundedCylinder(p-c, size, ra*0.01, height));\n      d_lace = min(d_lace, sdTorus(p-c-surface, vec2(size, 0.01)));\n    }\n    d_lace = max(-sdRoundedCylinder(p-center, ra, ra*0.1, height*2.0f), d_lace); // 减掉中间部分\n    d_lace = min(d_lace, sdTorus(p-center-surface, vec2(ra*2.0f, 0.01))); // 加个环\n    d = min(d, d_lace);\n    vec3 c = (center+surface);\n    for (float i =  0.0f; i < 3.14159*2.0; i = i + 2.0 * 3.1415926 / 5.0){\n        vec3 aa1 = c + ra * vec3(sin(i), 0.0f, cos(i)) + vec3(0.0f, 0.075, 0.0f);\n        vec3 aa2 = c + ra * vec3(sin(i), 0.0f, cos(i));\n        float roundcore = max(-sdRoundCone(p, aa1, c, 0.04, 0.001), sdRoundCone(p, aa2, c, 0.045, 0.001));\n        d = min(d, roundcore);\n    }\n    vec3 bite_center[2] = vec3[2](\n        vec3(0.15, 0, 0.15), \n        vec3(0.15, 0, -0.15)\n    );\n    for (int i = 0; i < biteCount; ++ i){\n        d = max(-sdRoundedCylinder(p-center-bite_center[i], ra, ra * 0.1, 2.0*height), d);\n    }\n    return d;\n}\nvec2 map( in vec3 p, int cakeVersion, int biteCount)\n{    \n    float d1 = p.y+0.1;\n    if (cakeVersion == 0){\n        return vec2(d1,2.0);\n    }else if(cakeVersion == 1){\n        float d2 = sdMooncake(p, vec3(-0.1), biteCount);\n        return (d1<d2) ? vec2(d1,2.0) : vec2(d2,1.0); \n    }else{\n        float d2 = sdSmallMooncake(p, vec3(-0.1), biteCount);\n        return (d1<d2) ? vec2(d1,2.0) : vec2(d2,1.0);\n    }\n}\n\n// https://iquilezles.org/articles/nvscene2008/\nvec2 castRay( in vec3 ro, in vec3 rd, int cakeVersion, int biteCount)\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 20.0;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, cakeVersion, biteCount);\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n// https://iquilezles.org/articles/nvscene2008/\nfloat calcAO( in vec3 pos, in vec3 nor, int cakeVersion, int biteCount)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, cakeVersion, biteCount).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, int cakeVersion, int biteCount)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, cakeVersion, biteCount).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t ));\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos, int cakeVersion, int biteCount)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, cakeVersion, biteCount).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, cakeVersion, biteCount).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, cakeVersion, biteCount).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, cakeVersion, biteCount ).x );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, int cakeVersion, int biteCount)\n{ \n    vec3 col = vec3(0.0);\n    \n    vec2  res = castRay(ro,rd, cakeVersion, biteCount);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n        vec3 perturbedNormal = vec3(0.0f);\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            // col = 0.05*vec3(1.0);\n            col = vec3(0.94, 0.53, 0.07f);\n            // occ = calcAO(pos, nor);\n        }\n        else\n        {\n            nor = calcNormal( pos, cakeVersion, biteCount);\n            // occ = 0.5+0.5*nor.y;\n            col = vec3(0.64, 0.33, 0.07f);\n            // col = texture(iChannel0, pos);\n        }\n        occ = calcAO(pos, nor, cakeVersion, biteCount);\n        vec3 lin = vec3(0.0);\n\n        // sun\n        float ks = 0.4;\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, cakeVersion, biteCount);\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            // lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            vec3 ref = reflect(rd, nor);\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, cakeVersion, biteCount);\n            lin += col*0.20*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*0.1;\n\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );           \n    }\n    \n\treturn col;\n}\n\nfloat hit( in vec3 ro, in vec3 rd, int cakeVersion, int biteCount)\n{ \n    if (cakeVersion == 0) {\n        return 0.0f;\n    }\n    vec3 col = vec3(0.0);\n    \n    vec2  res = castRay(ro,rd, cakeVersion, biteCount);\n    if (res.y > 0.5 && res.y <= 1.5){\n        return 0.0f;\n    }\n    return 1.0f;\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n\n    // load game state\n    float cakeVersion       = loadValue( txCakeVersion ).x;\n    float biteCount       = loadValue( txBiteCount ).x;\n    float points       = loadValue( txPoints ).x;\n    vec3 color = loadValue( txColor ).xyz;\n    float state = loadValue( txState ).x;\n    vec3 ro = loadValue( txRo ).xyz;\n    \n    //---------------------------------------------------------------------------------\n    // reset\n\t//---------------------------------------------------------------------------------\n\tif( iFrame==0 ) {\n        cakeVersion = 1.0f;\n        biteCount = 0.0f;\n        points = 0.0f;\n        color = vec3(0.64, 0.33, 0.07);\n        state = 0.0f;\n        ro = vec3(0.5, 1.5, 0.5);\n    }\n\n    // camera\t\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize(cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          (cross(cu,cw) );\n\n    vec3 tot = vec3(0.0);\n\n    vec3 col = vec3(0.94, 0.53, 0.07f);\n    \n    vec2 fc = vec2(iMouse.z, iMouse.w);\n    vec2 p = (2.0*fc-iResolution.xy)/iResolution.y;\n    vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n    \n    vec3 rt = vec3(0.2, 0.4, 0.2);\n    \n    vec3 direction = rt - vec3(0.5, 1.5, 0.5);\n    \n    // 拉近\n    if (state == 1.0f) {\n        ro = ro - vec3(0.03, 0.11, 0.03) * (iTimeDelta);\n        if (ro.y < 0.4) {\n            state = 0.0f;\n        }\n    }\n    \n    vec3[] colorList = vec3[](\n    vec3(0.1f, 0.8f, 0.1f),\n    vec3(0.2f, 0.1f, 0.9f),\n    vec3(0.9f, 0.6f, 0.3f),\n    vec3(0.4f, 0.7f, 0.2f),\n    vec3(0.3f, 0.2f, 0.8f),\n    vec3(0.5f, 0.5f, 0.5f),\n    vec3(0.6f, 0.1f, 0.7f),\n    vec3(0.2f, 0.9f, 0.4f),\n    vec3(0.7f, 0.3f, 0.6f),\n    vec3(0.8f, 0.4f, 0.1f),\n    vec3(0.1f, 0.5f, 0.9f),\n    vec3(0.3f, 0.8f, 0.2f),\n    vec3(0.9f, 0.2f, 0.5f),\n    vec3(0.4f, 0.6f, 0.7f),\n    vec3(0.5f, 0.3f, 0.9f),\n    vec3(0.2f, 0.7f, 0.8f),\n    vec3(0.6f, 0.4f, 0.2f),\n    vec3(0.7f, 0.1f, 0.5f),\n    vec3(0.3f, 0.9f, 0.6f),\n    vec3(0.8f, 0.5f, 0.3f),\n    vec3(0.1f, 0.6f, 0.8f),\n    vec3(0.4f, 0.2f, 0.9f),\n    vec3(0.9f, 0.3f, 0.4f),\n    vec3(0.5f, 0.7f, 0.1f),\n    vec3(0.2f, 0.8f, 0.7f),\n    vec3(0.6f, 0.5f, 0.4f),\n    vec3(0.7f, 0.2f, 0.9f),\n    vec3(0.3f, 0.6f, 0.5f),\n    vec3(0.8f, 0.1f, 0.4f),\n    vec3(0.1f, 0.9f, 0.3f),\n    vec3(0.4f, 0.3f, 0.7f),\n    vec3(0.9f, 0.5f, 0.2f),\n    vec3(0.5f, 0.4f, 0.8f),\n    vec3(0.2f, 0.6f, 0.9f),\n    vec3(0.6f, 0.7f, 0.3f),\n    vec3(0.7f, 0.4f, 0.1f),\n    vec3(0.3f, 0.5f, 0.9f),\n    vec3(0.8f, 0.2f, 0.6f),\n    vec3(0.1f, 0.7f, 0.4f),\n    vec3(0.4f, 0.9f, 0.5f),\n    vec3(0.9f, 0.1f, 0.7f),\n    vec3(0.5f, 0.6f, 0.2f),\n    vec3(0.2f, 0.4f, 0.8f),\n    vec3(0.6f, 0.3f, 0.9f),\n    vec3(0.7f, 0.5f, 0.4f),\n    vec3(0.3f, 0.8f, 0.1f),\n    vec3(0.8f, 0.6f, 0.5f),\n    vec3(0.1f, 0.4f, 0.9f),\n    vec3(0.4f, 0.7f, 0.3f),\n    vec3(0.9f, 0.2f, 0.6f),\n    vec3(0.5f, 0.1f, 0.8f),\n    vec3(0.2f, 0.9f, 0.7f),\n    vec3(0.6f, 0.5f, 0.3f),\n    vec3(0.7f, 0.6f, 0.2f),\n    vec3(0.3f, 0.4f, 0.9f),\n    vec3(0.8f, 0.7f, 0.1f),\n    vec3(0.1f, 0.3f, 0.8f),\n    vec3(0.4f, 0.8f, 0.6f),\n    vec3(0.9f, 0.4f, 0.3f),\n    vec3(0.5f, 0.2f, 0.7f),\n    vec3(0.2f, 0.5f, 0.9f),\n    vec3(0.6f, 0.9f, 0.4f),\n    vec3(0.7f, 0.3f, 0.5f),\n    vec3(0.3f, 0.1f, 0.6f),\n    vec3(0.8f, 0.4f, 0.7f),\n    vec3(0.1f, 0.6f, 0.2f),\n    vec3(0.4f, 0.5f, 0.9f),\n    vec3(0.9f, 0.7f, 0.1f),\n    vec3(0.5f, 0.3f, 0.6f),\n    vec3(0.2f, 0.8f, 0.4f),\n    vec3(0.6f, 0.2f, 0.7f),\n    vec3(0.7f, 0.9f, 0.3f),\n    vec3(0.3f, 0.6f, 0.8f),\n    vec3(0.8f, 0.1f, 0.5f),\n    vec3(0.1f, 0.7f, 0.9f),\n    vec3(0.4f, 0.2f, 0.6f),\n    vec3(0.9f, 0.5f, 0.4f),\n    vec3(0.5f, 0.8f, 0.3f),\n    vec3(0.2f, 0.4f, 0.7f),\n    vec3(0.6f, 0.1f, 0.9f),\n    vec3(0.7f, 0.2f, 0.8f),\n    vec3(0.3f, 0.9f, 0.5f),\n    vec3(0.8f, 0.3f, 0.4f),\n    vec3(0.1f, 0.5f, 0.7f),\n    vec3(0.4f, 0.6f, 0.2f),\n    vec3(0.9f, 0.8f, 0.1f),\n    vec3(0.5f, 0.4f, 0.6f),\n    vec3(0.2f, 0.7f, 0.9f),\n    vec3(0.6f, 0.3f, 0.5f),\n    vec3(0.7f, 0.1f, 0.4f),\n    vec3(0.3f, 0.5f, 0.8f),\n    vec3(0.8f, 0.9f, 0.2f),\n    vec3(0.1f, 0.4f, 0.6f),\n    vec3(0.4f, 0.1f, 0.7f),\n    vec3(0.9f, 0.6f, 0.5f)\n    );\n\n    if( iMouse.z > 0.0f && hit(ro, rd, int(round(cakeVersion)), int(round(biteCount))) < 1.0f) {\n        if (cakeVersion == 0.0f) {\n            cakeVersion = 1.0f;\n            biteCount = 0.0f;\n            if (state == 0.0f && points >= 1.0 && int(points) %2 == 0) {\n                state = 1.0f;\n            }\n        } else if (cakeVersion == 1.0f && biteCount <= 1.0f) {\n            biteCount += 1.0f;\n        } else if (cakeVersion == 1.0f && biteCount == 2.0f) {\n            cakeVersion =2.0f;\n            biteCount = 0.0f;\n            points += 1.0f;\n             color = colorList[int(points)% colorList.length()];\n            //color = colorList[int(iTime * 1000.0) % colorList.length()];\n        } else if (cakeVersion == 2.0f && biteCount <= 1.0f) {\n            biteCount += 1.0f;\n        } else if (cakeVersion == 2.0f && biteCount == 2.0f) {\n            cakeVersion = 0.0f;\n            biteCount = 0.0f;\n            points += 1.0f;\n            //color = colorList[int(iTime * 1000.0) % colorList.length()];\n            color = colorList[int(points)% colorList.length()];\n        } else {\n            ;\n        }\n    }\n    //---------------------------------------------------------------------------------\n\t// store game state\n\t//---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n    \n    storeValue( txCakeVersion, vec4(cakeVersion, 0, 0, 0),       fragColor, ipx );\n    storeValue( txBiteCount, vec4(biteCount, 0, 0, 0),       fragColor, ipx );\n    storeValue( txPoints, vec4(points, 0, 0, 0),       fragColor, ipx );\n    storeValue( txColor, vec4(color, 0),       fragColor, ipx );\n    storeValue( txState, vec4(state, 0, 0, 0),       fragColor, ipx );\n    storeValue( txRo, vec4(ro, 0),       fragColor, ipx );\n\n}","name":"Buffer A","description":"","type":"buffer"}]}