{"ver":"0.1","info":{"id":"XcycRt","date":"1732235501","viewed":148,"name":"Framed Box","username":"incre_ment","description":"Thought up another way to do edges on a box.\nThere's a black glitch flying across the face of the cube.  Need to track that down...","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 boxSize = vec3(.99,.99,.99);\nvec3 frameSize = vec3(1.0,1.0,1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = vec3(0);\n  float tt = fract(.1*iTime);\n   \n  vec3 camPos = vec3(0., 0., 4.5); \n  vec3 rayDir = normalize(vec3(uv, -1));\n  \n  float depth = 0.0;\n  float closest;\n  float d;\n  vec3 p = vec3(0);\n  for(int numIter = 0; numIter < 50; numIter++){\n    p = camPos + depth * rayDir;\n    \n    // Question: I'm rotating the box via the ray coordinates, here.  \n    // Is that the right way to do it?  It just \n    // intuitively doesn't seem right to me, and maybe it only works \n    // because I have a single object (or in the case of domain repetition, a\n    // individual \"coordinate system\" per object).  If I had another (stationary,\n    // non-rotating) object to the right of the cube (for example), I don't\n    // think it would make sense to rotate every ray coordinate.  So, I'm\n    // thinking maybe I should just pass the rotation applied p as an argument \n    // to the SDF function, so that the original ray coordinate is maintained?\n    p.xy *= rotation(TAU*tt);\n    p.xz *= rotation(TAU*tt);\n    \n    float box = sdBox(p, boxSize);\n    float frame = sdBoxFrame(p, frameSize, .025);  \n    d = min(box,frame);\n    closest = step(0.,box-frame);\n    depth += d;\n    if (d < .0001 || depth > 50.0) break;\n  }\n  \n  d = depth;\n\n  if (d > 50.) {\n    col = vec3(0.);  \n  } \n  else if (closest == 0.){\n    vec2 side;\n    \n//    Old logic -- has a glitch\n//    if(abs(p.x) > boxSize.x) side = p.yz;\n//    if(abs(p.y) > boxSize.y) side = p.xz;\n//    if(abs(p.z) > boxSize.z) side = p.xy;\n    \n    // Updated logic by lz.  Thanks!\n    vec3 q = abs(p);\n    if (q.x > q.y && q.x > q.z) side = p.yz;\n    else if (q.y >= q.x && q.y > q.z) side = p.xz;\n    else side = p.xy;\n    \n    vec2 star_uv = 12. * side;\n    vec2 starID = floor(star_uv);\n    star_uv = fract(star_uv) - .5;\n    float off = fract(323.23*sin(starID.x/10.) * 12.*sin(starID.y/10.));\n    float star_rad = .2 + .2*sin(4.*TAU*tt + TAU*off);\n    float star = length(star_uv) - star_rad;\n     \n    col += smoothstep(0.,-fwidth(star),star);\n  } \n  else if (closest == 1.){\n    col += vec3(1.);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat PI = 3.14159;\nfloat TAU = 2.*3.14159;\n\n// Thanks IQ for the SDF functions!\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n","name":"Common","description":"","type":"common"}]}