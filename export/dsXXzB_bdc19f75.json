{"ver":"0.1","info":{"id":"dsXXzB","date":"1669122494","viewed":180,"name":"The triangle portal","username":"Asif","description":" ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","retrowave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nstruct Ray\n{\n    vec3 or;\n    vec3 dir;\n};\n\nconst vec2 eps = vec2(0.0001, 0.0000);\n\nfloat edge(vec2 p0, vec2 p1, vec2 p)\n{\n    return (p1.x - p0.x) * (p.y - p0.y) - (p.x - p0.x) * (p1.y - p0.y);\n}\n\nvec2 rotate(vec2 p, float a)\n{\n    return cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nRay genRay(vec3 pos, vec3 dir, vec2 uv, float aspect) \n{\n    // vec3 p = vec3(frag_coord - iResolution.xy * 0.5, iResolution.y);\n    vec3 p = normalize(vec3(uv * 2.0 - 1.0, 1.0));\n    p.x *= aspect;\n\n    vec3 ww = normalize(dir);\n    vec3 uu = cross(ww, vec3(0, 1, 0));\n    vec3 vv = cross(uu, ww);\n\n    return Ray(pos, normalize(p.x * uu + p.y * vv + p.z * ww));\n}\n\n/// Looked here: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint hash(uint x)\n{\n    x += (x << 10u);\n    x ^= (x >> 6u);\n    x += (x << 3u);\n    x ^= (x >> 11u);\n    x += (x << 15u);\n    return x;\n}\n\n/// Looked here: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint hash(uvec2 v)\n{\n    return hash(v.x ^ hash(v.y));\n}\n\n/// Looked here: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat floatConstruct(uint m)\n{\n    const uint ieeeMantissa = 0x007fffffu;\n    const uint ieeOne       = 0x3f800000u;\n\n    m &= ieeeMantissa;\n    m |= ieeOne;\n\n    return uintBitsToFloat(m) - 1.0;\n}\n\n/// Looked here: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat random(vec2 v)\n{\n    return floatConstruct(hash((floatBitsToUint(v))));\n}\n\nfloat noise(vec2 p) {\n    vec2    ip  = floor(p);\n    vec2    fp  = smoothstep(vec2(0), vec2(1), fract(p));\n    float   a   = random(ip + vec2(0, 0));\n    float   b   = random(ip + vec2(1, 0));\n    float   c   = random(ip + vec2(0, 1));\n    float   d   = random(ip + vec2(1, 1));\n    return mix(mix(a, b, fp.x), mix(c, d, fp.x), fp.y);\n}\n\nfloat sdSphere(vec3 pos, float r) \n{\n    return length(pos) - r;\n}\n\nfloat sdPlane(vec3 pos, float d)\n{\n    return pos.y + d;\n}\n\nfloat sdCircle(vec2 pos, float r)\n{\n    return length(pos) - r;\n}\n\nbool inTriangle(vec2 p0, vec2 p1, vec2 p2, vec2 p) \n{\n    float e1 = clamp(edge(p0, p1, p), -1.0, 0.0);\n    float e2 = clamp(edge(p1, p2, p), -1.0, 0.0);\n    float e3 = clamp(edge(p2, p0, p), -1.0, 0.0);\n\n    // return true;\n    // return false;\n    return e3 * e2 * e1 < 0.0;\n}\n\nfloat mapInTriangle(vec3 pos)\n{\n    vec2 v = pos.xz;\n\n    float noise_value = 3.0 * noise(v * .4);\n\n    v           = rotate(v, radians(15.0));\n    noise_value += 0.4 * noise(v * 2.9);\n    \n    v           = rotate(v, radians(15.0));    \n    noise_value += 50.0 * noise(v * 0.05);\n\n    v           = rotate(v, radians(15.0));    \n    noise_value += 100.0 * noise(v * 0.005);\n\n    return sdPlane(pos, 10.0 - noise_value * 0.15);\n}\n\nvec3 calcNormalInTriangle(vec3 p)\n{\n    return normalize(vec3(\n        mapInTriangle(p + eps.xyy) - mapInTriangle(p - eps.xyy),\n        mapInTriangle(p + eps.yxy) - mapInTriangle(p - eps.yxy),\n        mapInTriangle(p + eps.yyx) - mapInTriangle(p - eps.yyx)\n    ));\n}\n\nfloat traceInTriangle(Ray r, float s, float e) \n{\n    float depth = s, dist;\n    \n    const uint max_step = 216u;\n    for (uint i = 0u; i < max_step; ++i) {\n        dist = mapInTriangle(r.or + r.dir * depth);\n\n        if (dist < eps.x) {\n            return depth;\n        }\n\n        depth += dist;\n\n        if (depth > e) {\n            return e;\n        }\n    }\n\n    return e;\n}\n\n/// Looked here: http://casual-effects.com/research/McGuire2019ProcGen/McGuire2019ProcGen.pdf\nvec3 genSkyColor(float x, float y, float f)\n{\n    float h = max(0.0, f - y - pow(abs(x - 0.5), 3.0));   \n    return vec3(pow(h, 3.0), pow(h, 7.0), 0.2 + pow(max(0.0, h - 0.1), 10.0)) * 1.5;\n}\n\nvec3 renderinginInTriangle(Ray ray)\n{\n    const float scene_depth = 200.0;\n\n    vec3    col = vec3(0);\n    float   t   = traceInTriangle(ray, 0.01, scene_depth);\n\n    if (t < scene_depth) {\n        const vec3 ld = normalize(vec3(1, 1, 1));\n\n        vec3 p = ray.or + ray.dir * t;\n        vec3 n = calcNormalInTriangle(p);\n\n        col += vec3(0.54, 0.34, 0.65) * max(dot(n, ld), 0.0);\n    }\n\n    return col + genSkyColor(ray.dir.x * 0.1, -ray.dir.y, 0.6);\n}\n\nfloat mapOutTriangle(vec3 pos)\n{\n    return sdPlane(pos, 6.0);\n}\n\nfloat traceOutTriangle(Ray r, float s, float e) \n{\n    float depth = s, dist;\n    \n    const uint max_step = 216u;\n    for (uint i = 0u; i < max_step; ++i) {\n        dist = mapOutTriangle(r.or + r.dir * depth);\n\n        if (dist < eps.x) {\n            return depth;\n        }\n\n        depth += dist;\n\n        if (depth > e) {\n            return e;\n        }\n    }\n\n    return e;\n}\n\nfloat quad(vec2 uv, float board) \n{\n    vec2 s = vec2(1.0) - step(uv, vec2(board));\n    s -= step(vec2(1) - uv, vec2(board));\n    return s.x * s.y;\n}\n\nvec3 calcSunColor(vec2 p, float t)\n{\n    float x = p.y * 45.0  + 20.0;\n    float s = step(0.5, clamp(sin(clamp(x, 0.0, 3.14 * 8.0)), 0.0, 1.0));\n\n    const float i       = 1.7;\n    const vec3  col_1   = vec3(1.0, 0.0, 0.17) * i;\n    const vec3  col_2   = vec3(1.0, 0.46, 0.1) * i;\n\n    return mix (\n        mix(col_1, col_2, smoothstep(0.0, 1.0, t - 0.1)),\n        vec3(0),\n        step(0.5,  step(0.0, sdCircle(p - vec2(0., 0.1), 0.7)) + s)\n    );\n}\n\nvec3 drawSun(vec2 p, float t)\n{\n    const float bs = 1.0 / 128.0;\n\n    vec3 sum = vec3(0);\n\n    sum += calcSunColor(p + vec2(-bs * 4.0, 0.0), t) * 0.05;\n    sum += calcSunColor(p + vec2(-bs * 3.0, 0.0), t) * 0.09;\n    sum += calcSunColor(p + vec2(-bs * 2.0, 0.0), t) * 0.12;\n    sum += calcSunColor(p + vec2(-bs, 0.0), t) * 0.15;\n    sum += calcSunColor(p, t) * 0.16;\n    sum += calcSunColor(p + vec2(bs, 0.0), t) * 0.15;\n    sum += calcSunColor(p + vec2(bs * 2.0, 0.0), t) * 0.12;\n    sum += calcSunColor(p + vec2(bs * 3.0, 0.0), t) * 0.09;\n    sum += calcSunColor(p + vec2(bs * 4.0, 0.0), t) * 0.05;\n\n    sum += calcSunColor(p + vec2(0.0, -bs * 4.0), t) * 0.05;\n    sum += calcSunColor(p + vec2(0.0, -bs * 3.0), t) * 0.09;\n    sum += calcSunColor(p + vec2(0.0, -bs * 2.0), t) * 0.12;\n    sum += calcSunColor(p + vec2(0.0, -bs), t) * 0.15;\n    sum += calcSunColor(p, t) * 0.16;\n    sum += calcSunColor(p + vec2(0.0, bs), t) * 0.15;\n    sum += calcSunColor(p + vec2(0.0, bs * 2.0), t) * 0.12;\n    sum += calcSunColor(p + vec2(0.0, bs * 3.0), t) * 0.09;\n    sum += calcSunColor(p + vec2(0.0, bs * 4.0), t) * 0.05;\n\n    return calcSunColor(p, t) + sum * 1.2;\n}\n\nvec3 renderingOutTriangle(Ray ray, vec2 ps, vec2 uv)\n{   \n    const float scene_depth = 35.0;\n\n    vec3    col = vec3(0);\n    float   t   = traceOutTriangle(ray, 0.01, scene_depth);\n\n    if (t < scene_depth) {\n        vec2 p = fract((ray.or.xz + ray.dir.xz * t) * 0.3);\n\n        const float b1 = 0.01;\n        const float b2 = 0.05;\n\n        col += vec3(mix(vec3(0.0), vec3(0.54, 0.34, 0.65), quad(p, b1) - quad(p, b2)));\n        col *= vec3(1.0 - t / scene_depth) * 0.5;\n    } \n\n    return mix(col, drawSun(ps, uv.y), (t / scene_depth) * uv.y * 0.5);\n}\n\n/// Looked here: https://www.shadertoy.com/view/lslGzl\nvec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color, float white)\n{\n#if 0\n    if (length(color) < eps.x) {\n        return color;\n    }\n    \n    const float inv_gamma = 1.0 / 2.2;    \n#endif\n\n\tfloat luma              = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat tone_mapped_luma  = luma * (1. + luma / (white*white)) / (1. + luma);\n\n\tcolor *= tone_mapped_luma / luma;\n\n#if 0\n    return pow(color, vec3(inv_gamma));\n#else \n    return sqrt(color);\n#endif\n}\n\nvoid mainImage(out vec4 color, vec2 coord)\n{\n    float   aspect  = iResolution.x / iResolution.y;\n    vec2    uv      = coord / iResolution.xy;\n\n    const float s   = 0.5;\n    const vec2  p0  = vec2(-s, -s);\n    const vec2  p1  = vec2(0.0, s);\n    const vec2  p2  = vec2(s, -s); \n    \n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= aspect;\n\n    vec3 col = vec3(0);\n\n#if AA != 0\n    const vec2  inv_aa          = vec2(1.0 / float(AA));\n    const float two_aa          = float(2 * AA);\n    const float pow_2_aa        = two_aa * two_aa;\n    const float inv_pow_2_aa    = 1.0 / pow_2_aa;\n\n    vec2 pixs = vec2(1.0) / iResolution.xy;\n#endif\n\n    if (inTriangle(p0, p1, p2, p)) {\n#if AA == 0\n        Ray ray = genRay(vec3(0, 20, -iTime * 10.0), vec3(0, 0., -1), uv, aspect);\n        col += renderinginInTriangle(ray);\n#else \n        for (int i = -AA; i < AA; ++i) {\n            for (int j = -AA; j < AA; ++j) {\n                vec2    m   = vec2(i, j) * inv_aa;\n                Ray     ray = genRay(vec3(0, 20, -iTime * 10.0), vec3(m * pixs, -1), uv, aspect);\n\n                col += renderinginInTriangle(ray);\n            }\n        }\n\n        col *= inv_pow_2_aa;\n#endif\n    } else {\n#if AA == 0\n        Ray ray = genRay(vec3(0, 0, -iTime * 1.8), vec3(0, 0, -1), uv, aspect);\n        col += renderingOutTriangle(ray, p, uv);\n#else \n        for (int i = -AA; i < AA; ++i) {\n            for (int j = -AA; j < AA; ++j) {\n                vec2    m   = vec2(i, j) * inv_aa;\n                Ray     ray = genRay(vec3(0, 0, -iTime * 1.8), vec3(m * pixs, -1), uv, aspect);\n\n                col += renderingOutTriangle(ray, p, uv);\n            }\n        }\n\n        col *= inv_pow_2_aa;\n#endif\n    }\n\n   color = vec4(whitePreservingLumaBasedReinhardToneMapping(col, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}