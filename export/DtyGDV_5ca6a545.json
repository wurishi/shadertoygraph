{"ver":"0.1","info":{"id":"DtyGDV","date":"1700633737","viewed":73,"name":"New Year is soon","username":"kryden","description":"The year is coming to an end. It has been very hard for me, but very fruitful. Recently, I found a wonderful Christmas tree in a Christmas tree garden :)\nI wish everyone luck and inspiration!","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sdf","winter","christmastree","pbrr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired\n// https://www.shadertoy.com/view/XlXGRM\n// https://www.shadertoy.com/view/wdfGzr\n\n#define EPSILON 0.005\n#define MAXIMUM_STEPS 800\n#define FAR 40.0\n\n#define MAKE_FOREST\n\n#define SC normalize(vec2(3.0, 0.1))\n\n#define BRANCH_COLOR vec3(0.1, 0.1, 0.0)\n#define SMALL_BRANCH_COLOR vec3(0.79,0.51,0.066)\n#define NEEDLE_COLOR_A vec3(0.152, 0.36, 0.18)\n#define NEEDLE_COLOR_B vec3(0.07, 0.86, 0.00)\n\n#define NEEDLES_IN_WREATH 12.0\n#define CHILD_BRANCHES_F  0.2\n#define BRANCHES_VF       0.3\n\n#define BRANCH_ID 1.0\n#define SMALL_BRANCH_ID 2.0\n#define NEEDLE_ID 3.0\n#define LOG_ID 4.0\n#define BOUND_ID 5.0\n\n#define FIX_NEEDLE_REPEAT\n#define FIX_REPEAT\n//#define FIX_REPEAT_TWO\n\nfloat id = 0.0;\nfloat STEP_SIZE = 0.5;\n\n// v.x - needles in wreath\n// v.y - wreath radius\n// v.z - needle length\nfloat sdNeedleWreath(vec3 p, vec3 v) {\n  vec3 q = p;\n  float f = repeatAngle(p.yx, v.x);\n  p.yx *= rotate(f); p.y -= v.y;\n  float needle = sdCone(p, SC, v.z);\n  #ifdef FIX_NEEDLE_REPEAT\n  float next = f + 2.0 * PI / v.x;\n  q.yx *= rotate(next); q.y -= v.y;\n  needle = min(needle, sdCone(q, SC, v.z));\n  #endif\n  return needle;\n}\n\nvec2 MIN(vec2 a, vec2 b) {\n  if (a.x < b.x) return a;\n  return b;\n}\n\n// b.x - branch length, b.y - branch radius\n// n.x - needles in wreath, n.y - needle freq, n.z - length\nvec2 sdBranch(vec3 p, vec2 b, vec3 n) {\n  float branch = sdCapsule(p, b.x, b.y);\n  p.y -= clamp(n.y * round(p.y / n.y), 0.0, b.x);\n  float wreath = sdNeedleWreath(p.xzy, vec3(n.x, b.y, n.z));\n  float ret = min(branch, wreath);\n  float out_id = 0.0;\n  if (ret == branch) out_id = BRANCH_ID;\n  else if (ret == wreath) out_id = NEEDLE_ID;\n  return vec2(ret, out_id);\n}\n\n#define BASE(X, a)     sdCapsule(X, a, 0.009)\n#define CHILD(X, a, b) sdBranch(X, vec2(a, 0.003), vec3(b, 0.03, -0.02)) // length can be < 0.0\n\n// v - base length\nvec2 sdBigBranch(vec3 p, float v, vec2 ind) {\n  float seed = random(ind);\n  float length = v + 0.25 * seed;\n\n  p.xz *= rotate(seed * PI / 6.0);\n\n  #ifdef FIX_REPEAT\n  p.yz *= rotate(p.y * -0.1); // forward - back\n  p.xy *= rotate(p.y * 0.1); // up - down\n  #endif\n\n  float branch = BASE(p, length);\n\n  vec3 q = p;\n  q.x = abs(q.x) - 0.03;\n  float m = CHILD_BRANCHES_F; // child freq\n  float sub_ind = clamp(round(q.y / m), 1.0, length / m);\n  float child_seed = random(vec2(seed, sub_ind));\n  float child_length = 0.1 + 0.1 * child_seed; // child length\n  \n  vec3 r = q; r.y -= m * (sub_ind - 1.0);\n  q.y -= m * sub_ind;\n\n  #ifdef FIX_REPEAT\n  q.xy *= rotate(1.5 * q.x); r.xy *= rotate(2.0 * r.x);\n  #endif\n\n  vec2 child_1 = CHILD(q.zxy, child_length, NEEDLES_IN_WREATH);\n  vec2 child_2 = CHILD(r.zxy, child_length, NEEDLES_IN_WREATH);\n\n  vec2 child = MIN(child_1, child_2);\n  float ret = min(branch, child.x);\n  if (child.y == BRANCH_ID) child.y = SMALL_BRANCH_ID;\n  float out_id = (ret == branch) ? BRANCH_ID : child.y;\n  return vec2(ret, out_id);\n}\n\nfloat getHeight(vec2 p) {\n  float h = 0.21 * sin(2.0 * p.x) + 0.19 * cos(3.0 * p.y);\n  h = 0.35 * sin(2.0 * h + p.x) + 0.3 * cos(2.0 * h + p.y);\n  return h;\n}\n\nfloat sdTerrain(vec3 p) {\n  return p.y - getHeight(p.xz);\n}\n\n#define LENGTH(X) max(2.0 - 0.3 * X, 0.0)\n\nfloat sdTree(vec3 p, vec2 hr) {\n  float log = sdCapsule(p, hr.x + 0.2, hr.y);\n  float sectors = 16.0;\n  float id_a = repeatAngle(p.xz, sectors); float id_a_next = id_a + 2.0 * PI / sectors;\n  float s = BRANCHES_VF; float id_b = s * clamp(round(p.y / s), 6.0, 1.0 + hr.x / s); float id_b_next = id_b + s; float id_b_nn = id_b_next + s; \n  vec3 q = p; p.xz *= rotate(id_a); q.xz *= rotate(id_a_next);\n  vec2 ret_1 = sdBigBranch(p.zxy - vec3(0.0, hr.y, id_b), LENGTH(id_b), vec2(id_a, id_b));\n  vec2 ret_2 = sdBigBranch(q.zxy - vec3(0.0, hr.y, id_b), LENGTH(id_b), vec2(id_a_next, id_b));\n  #ifdef FIX_REPEAT\n  vec2 ret_3 = sdBigBranch(p.zxy - vec3(0.0, hr.y, id_b_next), LENGTH(id_b_next), vec2(id_a, id_b_next));\n  vec2 ret_4 = sdBigBranch(q.zxy - vec3(0.0, hr.y, id_b_next), LENGTH(id_b_next), vec2(id_a_next, id_b_next));\n    #ifdef FIX_REPEAT_TWO \n    vec2 ret_5 = sdBigBranch(p.zxy - vec3(0.0, hr.y, id_b_nn), LENGTH(id_b_nn), vec2(id_a, id_b_nn));\n    vec2 ret_6 = sdBigBranch(q.zxy - vec3(0.0, hr.y, id_b_nn), LENGTH(id_b_nn), vec2(id_a_next, id_b_nn));\n    ret_1 = MIN(ret_1, MIN(ret_2, MIN(ret_3, min(ret_4, min(ret_5, ret_6)))));\n    #else\n    ret_1 = MIN(ret_1, MIN(ret_2, MIN(ret_3, ret_4)));\n  #endif\n  #else\n  ret_1 = MIN(ret_1, ret_2);\n  #endif\n  float ret = min(ret_1.x, log);\n  if (ret == ret_1.x) id = ret_1.y;\n  else id = LOG_ID;\n  return ret;\n}\n\nfloat scene(vec3 p, bool bound) {\n  float terrain = sdTerrain(p);\n  float ret = terrain;\n\n  #ifdef MAKE_FOREST \n  p.xz -= 8.0 * round(p.xz / 8.0);\n  #endif \n\n  if (bound) {\n    ret = min(length(p.xz) - 2.0, terrain);\n    id = (ret == terrain) ? 0.0 : BOUND_ID;\n  } else {\n    ret = min(sdTree(p, vec2(6.0, 0.1)), terrain);\n    id = (ret == terrain) ? 0.0 : id;\n  }\n  \n  return ret;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\n\nvec3 getNormal(in vec3 p, bool bound) {\n  vec3 epsilon = vec3(EPSILON, 0.0, 0.0);\n  vec3 normal = vec3(\n      scene(p + epsilon.xyy, bound) - scene(p - epsilon.xyy, bound),\n      scene(p + epsilon.yxy, bound) - scene(p - epsilon.yxy, bound),\n      scene(p + epsilon.yyx, bound) - scene(p - epsilon.yyx, bound));\n  return normalize(normal);\n}\n\nHit rayMarch(in Ray ray, float near, bool bound, float current_t) {\n  Hit hit;\n  hit.is = false;\n  float t = near;\n  for (int i = 0; i < MAXIMUM_STEPS; i++) {\n    vec3 p = ray.origin + ray.direction * t;\n    float d = scene(p, bound);\n    if (d < EPSILON) {\n      hit.t = t;\n      hit.is = true; hit.position = p;\n      hit.normal = getNormal(hit.position, bound);\n      break;\n    }\n    t += STEP_SIZE * d;\n    if (t > FAR - current_t) { break; }\n  }\n  return hit;\n}\n\nvec3 sky(vec2 uv) {\n  float star = step(texture(iChannel0, uv).x, 0.1);\n  vec3 color = vec3(star, star, star);\n  float moon = smoothstep(0.13, 0.12, length(uv - vec2(0.5, 0.7)));\n  color += vec3(0.95, 0.956, 0.3) * max(moon, 0.0);\n  color += vec3(0.0, 0.0, 0.02);\n  uv.x += iTime;\n  color += 0.1 * fbm(2.5 * uv, 1.5) * smoothstep(0.1, 0.6, uv.y);\n  return color;\n}\n\nfloat ambientOcclusion(in vec3 n, in vec3 rp) {\n  float dist = 0.1;\n  rp += n * dist;\n  float occ = 0.0;\n  const float steps = 6.0; \n  for (float i = 0.0; i < steps; i += 1.0) {\n    float d = scene(rp, false);\n    float o = clamp(d / (dist * i + 1.0), 0.0, 1.0);\n    occ += o;\n    rp += n * dist;\n  }\n  occ /= steps;\n  return occ;        \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n  vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n  float r = 2.5;\n  vec3 target = vec3(0.0, 3.5, 0.0);\n  Ray ray;\n  ray.origin = vec3(2.5, 3.5, -iTime);\n  ray.direction = normalize(vec3(uv, -1.0));\n\n  vec3 light = normalize(vec3(1.0, 2.0, -1.0));\n  vec3 light_color = vec3(2.8, 2.8, 2.0);\n  vec3 color = sky(uv);\n\n  Hit hit = rayMarch(ray, 0.0, true, 0.0);\n\n  vec3 hit_position;\n  vec3 hit_normal;\n  float metallic = 0.0; float roughness = 0.1;\n  vec3 albedo = sky(uv);\n  vec3 Lo = vec3(0.0);\n\n  if (hit.is == true) {\n    if (id == 0.0) {\n      hit_position = hit.position; hit_normal = hit.normal;\n      albedo = vec3(0.7) + texture(iChannel0, hit_position.xz).x;\n      metallic = 0.2; roughness = 0.9;\n    } else {\n      //STEP_SIZE = 0.3;\n      Ray tree_ray = Ray(hit.position, ray.direction);\n      Hit tree_hit = rayMarch(tree_ray, 0.0, false, hit.t);\n      if (tree_hit.is == true) {\n        hit_position = tree_hit.position; hit_normal = tree_hit.normal;\n        if (id == BRANCH_ID) { albedo = BRANCH_COLOR; metallic = 0.1; roughness = 0.8; }\n        if (id == SMALL_BRANCH_ID) { albedo = SMALL_BRANCH_COLOR; metallic = 0.2; roughness = 0.6; }\n        else if (id == NEEDLE_ID) { albedo = mix(NEEDLE_COLOR_A, NEEDLE_COLOR_B, 0.2 * hit_position.y); metallic = 0.7; roughness = 0.1; }\n        else if (id == LOG_ID) { albedo = texture(iChannel1, 4.0 * hit_position.yz).xyz; metallic = 0.1; roughness = 0.9; }\n        else if (id == 0.0) { albedo = vec3(0.7) + texture(iChannel0, hit_position.xz).x; metallic = 0.2; roughness = 0.9; }\n      }\n    }\n    if (albedo != color) {\n      vec3 F0 = vec3(0.04); \n      F0 = mix(F0, albedo, metallic);\n      vec3 halfway_direction = normalize(light - ray.direction);\n      float NDF = DistributionGGX(hit_normal, halfway_direction, roughness); \n      float G   = GeometrySmith(hit_normal, -ray.direction, light, roughness);  \n      vec3 F    = fresnelSchlick(max(dot(halfway_direction, -ray.direction), 0.0), F0);\n      vec3 specular = NDF * G * F / (4.0 * max(dot(hit_normal, -ray.direction), 0.0) * max(dot(hit_normal, light), 0.0) + 0.0001);\n      vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\n      float NdotL = max(dot(hit_normal, light), 0.0);          \n      Lo += (kD * albedo / PI + specular) * light_color * NdotL;\n      vec3 ambient = vec3(0.03) * albedo * ambientOcclusion(hit_normal, hit_position);\n      color = ambient + Lo;\n    }\n  }\n\n  color = pow(abs(clamp(color, 0.0, 1.0)), vec3(0.45));\n\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897\n\nstruct Hit {\n  bool is;\n  float t;\n  vec3 normal;\n  vec3 position;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nfloat random(in vec2 p) {\n  float q = dot(p, vec2(12.9898, 78.233));\n  return fract(sin(q) * 43758.5453123);\n}\n\nmat2 rotate(float a) {\n  return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat repeatAngle(vec2 p, float n) {\n  float sp = 2.0 * PI / n;\n  float an = atan(p.y, p.x);\n  float id = floor(an / sp);\n  return sp * id;\n}\n\n// https://iquilezles.org/articles/distfunctions/\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p) - r;\n}\n\nfloat sdCone(vec3 p, vec2 c, float h) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y - h)), -p.y);\n}\n\n\n// https://learnopengl.com/PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a = roughness * roughness;\n  float a2 = a * a;\n  float NdotH = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH * NdotH;\n  float nom   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n  return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r * r) / 8.0;\n  return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n  return ggx1 * ggx2;\n}\n\nfloat noise(in vec2 uv) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n    \n  float a = random(i + vec2(0.0, 0.0));\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  vec2 u = smoothstep(0.0, 1.0, f);\n  return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(in vec2 x, in float H) {    \n  float t = 0.0;\n  for (int i = 0; i < 4; i++) {\n    float f = pow(2.0, float(i) );\n    float a = pow(f, -H);\n    t += a * noise(f * x);\n  }\n  return t;\n}\n\n\n","name":"Common","description":"","type":"common"}]}