{"ver":"0.1","info":{"id":"msKBRw","date":"1698667993","viewed":70,"name":"ray tracing with effects","username":"SamuelZ","description":"Ray tracing shader.","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Gamma correction\n    fragColor = pow(texelFetch(iChannel0, ivec2(fragCoord), 0), vec4(1.0 / 2.2));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Transform {\n    vec3 position;\n    vec3 rotation;\n};\n\nstruct Plane {\n    Transform transform;\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Sphere {\n    Transform transform;\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Cuboid {\n    Transform transform;\n    vec3 scale;\n    int i;\n};\n\nstruct Elipsoid {\n    Transform transform;\n    vec3 scale;\n    int i;\n};\n\nstruct Capsule {\n    Transform transform;\n    float radius;\n    float height;\n    int i;\n};\n\nstruct Cylinder {\n    Transform transform;\n    float radius;\n    float height;\n    int i;\n};\n\nstruct Torus {\n    Transform transform;\n    vec2 radii; // x component is the radius of the whole torus, y component is the \"thickness\" of the torus\n    int i;\n};\n\nstruct Hit {\n    int geometryID;\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray {\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;// Diffuse\n    vec3 specular;\n    float roughness;\n};\n\n//Math constants\nconst float PI = 3.14159265359;\n\nconst vec3 lightDirection = -normalize(vec3(1,1,1));\nconst vec3 lightColor = vec3(0.4);\n\nmat3 createRotationMatrix(in vec3 rotation) {\n    //Create quaternion\n    vec3 c = cos(rotation * 0.5);\n    vec3 s = sin(rotation * 0.5);\n\n    vec4 quat;\n\n    quat.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    quat.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    quat.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    quat.z = c.x * c.y * s.z - s.x * s.y * c.z;\n\n    //Create matrix\n    mat3 rotationMatrix = mat3(1.0);\n    float qxx = quat.x * quat.x;\n    float qyy = quat.y * quat.y;\n    float qzz = quat.z * quat.z;\n    float qxz = quat.x * quat.z;\n    float qxy = quat.x * quat.y;\n    float qyz = quat.y * quat.z;\n    float qwx = quat.w * quat.x;\n    float qwy = quat.w * quat.y;\n    float qwz = quat.w * quat.z;\n\n    rotationMatrix[0][0] = 1.0 - 2.0 * (qyy +  qzz);\n    rotationMatrix[0][1] = 2.0 * (qxy + qwz);\n    rotationMatrix[0][2] = 2.0 * (qxz - qwy);\n\n    rotationMatrix[1][0] = 2.0 * (qxy - qwz);\n    rotationMatrix[1][1] = 1.0 - 2.0 * (qxx +  qzz);\n    rotationMatrix[1][2] = 2.0 * (qyz + qwx);\n\n    rotationMatrix[2][0] = 2.0 * (qxz + qwy);\n    rotationMatrix[2][1] = 2.0 * (qyz - qwx);\n    rotationMatrix[2][2] = 1.0 - 2.0 * (qxx +  qyy);\n\n    return rotationMatrix;\n}\n\nRay transformRayFromWorldToObjectSpace(in Ray ray, in Transform transform, out mat3 rotationMatrix) {\n    rotationMatrix = createRotationMatrix(radians(transform.rotation));\n    mat3 invRotationMatrix = inverse(rotationMatrix);\n\n    Ray transformedRay;\n    transformedRay.o = invRotationMatrix * (ray.o - transform.position);\n    transformedRay.d = invRotationMatrix * ray.d;\n    \n    return transformedRay;\n}\n\nfloat checkers(in vec2 p) {\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    float res = .5-.5*i.x*i.y;\n    \n    //HACK\n    if (isinf(res) || isnan(res))\n        return 0.0;\n    \n    return res;\n}\n\nuvec4 s0;\nivec2 pixel;\n\nvoid rngInitialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d()\n{\n\ts0 = s0 * 1664525u + 1013904223u;\n    \n    s0.x += s0.y*s0.w;\n    s0.y += s0.z*s0.x;\n    s0.z += s0.x*s0.y;\n    s0.w += s0.y*s0.z;\n    \n    s0 = s0 ^ (s0 >> 16u);\n    \n    s0.x += s0.y*s0.w;\n    s0.y += s0.z*s0.x;\n    s0.z += s0.x*s0.y;\n    s0.w += s0.y*s0.z;\n    \n    return s0;\n}\n\nfloat rand() {\n    return float(pcg4d().x) / float(0xffffffffu);\n}\n\nvec2 rand2() {\n    return vec2(pcg4d().xy) / float(0xffffffffu);\n}\n\nvec3 rand3() {\n    return vec3(pcg4d().xyz) / float(0xffffffffu);\n}\n\nvec4 rand4() {\n    return vec4(pcg4d()) / float(0xffffffffu);\n}\n\nfloat randomFloat(inout uint s) {\n    s = (1664525u * s + 1013904223u);\n    \n    return float(s & 0x00FFFFFFu) / float(0x01000000);\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(vec3 n)\n{\n    float a=rand();\n    float b=rand();\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n/*\nmat3 angleAxis3x3(float angle, vec3 axis) {\n    float c = cos(angle);\n    float s = sin(angle);\n\n    float t = 1.0 - c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n\n    return mat3(\n        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,\n        t * x * y + s * z,  t * y * y + c,      t * y * z - s * x,\n        t * x * z - s * y,  t * y * z + s * x,  t * z * z + c\n    );\n}\n\nvec3 coneSample(vec3 direction, float coneAngle) {\n    float cosAngle = cos(coneAngle);\n\n    // Generate points on the spherical cap around the north pole [1].\n    // [1] See https://math.stackexchange.com/a/205589/81266\n    float z = (rand() * 2.0 - 1.0) * (1.0f - cosAngle) + cosAngle;\n    float phi = (rand() * 2.0 - 1.0) * 2.0f * PI;\n\n    float x = sqrt(1.0f - z * z) * cos(phi);\n    float y = sqrt(1.0f - z * z) * sin(phi);\n    vec3 north = vec3(0.f, 0.f, 1.f);\n\n    // Find the rotation axis `u` and rotation angle `rot` [1]\n    vec3 axis = normalize(cross(north, normalize(direction)));\n    float angle = acos(dot(normalize(direction), north));\n\n    // Convert rotation axis and angle to 3x3 rotation matrix [2]\n    mat3 R = angleAxis3x3(angle, axis);\n\n    return R * vec3(x, y, z);\n}\n*/\n\n//Not uniformly distributed\nvec3 randomVectorInUnitSphere() {\n    return normalize(vec3(rand(), rand(), rand()));\n}\n\nvec3 coneSample(vec3 direction, float roughness) {\n    return normalize(direction + randomVectorInUnitSphere() * roughness);\n}\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o + t * ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i) {\n    if (i == 4) {\n        float noise = fractalSimplexNoise3D(p);\n    \n        return Material(vec3(0.2), vec3(noise), vec3(mix(0.0, noise, 0.4)), 0.1);\n    } else if (i == 3) {\n        return Material(vec3(0.2), vec3(0.2), vec3(3.0), 0.4);\n    } else if (i == 2) {\n        return Material(vec3(0.2), vec3(1.0), vec3(0.0), 1.0);\n    } else if(i == 1) {\n        return Material(vec3(0.2), vec3(.8,.5,.4), vec3(0.2), 0.2);\n    } else if(i == 0) {\n        // compute checkboard\n        float f = checkers(.5*p.xy);\n        vec3 diffuse = vec3(.4,.5,.7) + (1.0 - f) * 0.1;\n        vec3 specular = vec3(f);\n        \n        return Material(vec3(0.2), diffuse, specular * 0.2, 0.1);\n    }\n    return Material(vec3(0), vec3(0), vec3(0), 0.0);\n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool intersectPlane(Ray ray,Plane pl,out Hit x) {\n    mat3 rotationMatrix;\n    Ray transformedRay = transformRayFromWorldToObjectSpace(ray, pl.transform, rotationMatrix);\n\n    float t = -dot(transformedRay.o,pl.n) / dot(transformedRay.d, pl.n);\n    if(t > 0.) {\n        x = Hit(0, t, rotationMatrix * vec3(0,0,1), pl.i);\n        \n        return true;\n    }\n    \n    return false;\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool intersectSphere(Ray ray,Sphere sph,out Hit x) {\n    mat3 rotationMatrix;\n    Ray transformedRay = transformRayFromWorldToObjectSpace(ray, sph.transform, rotationMatrix);\n\n    vec3 oc = transformedRay.o;\n    float b = dot(oc,transformedRay.d);\n    float c = dot(oc,oc) - sph.r * sph.r;\n    float d = b * b - c;\n    if (d > 0.) {\n        float t=-b-sqrt(d);\n        if(t>0.) {\n            vec3 p = Point(transformedRay, t);\n            x = Hit(1, t, rotationMatrix * normalize(p), sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\n// Cuboid intersection\n// ray : The ray\n//   x : Returned intersection information\nbool intersectCuboid(Ray ray, Cuboid cuboid, out Hit x) {\n    mat3 rotationMatrix;\n    Ray transformedRay = transformRayFromWorldToObjectSpace(ray, cuboid.transform, rotationMatrix);\n\n    vec3 tMin = (-cuboid.scale * 0.5 - transformedRay.o) / transformedRay.d;\n    vec3 tMax = (cuboid.scale * 0.5 - transformedRay.o) / transformedRay.d;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    \n    if(tNear < tFar && tFar > 0.0) {\n        vec3 p = Point(transformedRay, tNear);\n        vec3 normal = p / cuboid.scale;\n        normal /= max(max(abs(normal.x), abs(normal.y)), abs(normal.z));\n        for (int i = 0; i < 3; i++) {\n            if (abs(normal[i]) < 1.0)\n                normal[i] = 0.0;\n        }\n        x = Hit(2, tNear, rotationMatrix * normal, cuboid.i);\n        \n        return true;\n    }\n    \n    return false;\n}\n\nbool intersectElipsoid(Ray ray, Elipsoid elipsoid, out Hit x) {\n    mat3 rotationMatrix;\n    Ray transformedRay = transformRayFromWorldToObjectSpace(ray, elipsoid.transform, rotationMatrix);\n    \n    vec3 ocn = transformedRay.o / elipsoid.scale;\n    vec3 rdn = transformedRay.d / elipsoid.scale;\n    float a = dot( rdn, rdn );\n    float b = dot( ocn, rdn );\n    float c = dot( ocn, ocn );\n    float h = b*b - a*(c-1.0);\n    if(h < 0.0)\n        return false;\n    h = sqrt(h);\n    \n    float t = (-b - h) / a;\n    \n    if (t > 0.) {\n        vec3 p = Point(transformedRay, t);\n        vec3 normal = normalize(p / (elipsoid.scale * elipsoid.scale));\n        x = Hit(3, t, rotationMatrix * normal, elipsoid.i);\n\n        return true;\n    }\n        \n    return false;\n}\n\nvec3 getCapsuleNormal(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return (pa - h * ba) / r;\n}\n\nbool intersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n    mat3 rotationMatrix;\n    Ray transformedRay = transformRayFromWorldToObjectSpace(ray, capsule.transform, rotationMatrix);\n    \n    vec3 pb = vec3(0.0, 0.0, capsule.height * 0.5);\n    vec3 pa = -pb;\n    \n    vec3  ba = pb - pa;\n    vec3  oa = transformedRay.o - pa;\n    float baba = dot(ba, ba);\n    float bard = dot(ba, transformedRay.d);\n    float baoa = dot(ba, oa);\n    float rdoa = dot(transformedRay.d, oa);\n    float oaoa = dot(oa, oa);\n    float a = baba      - bard * bard;\n    float b = baba * rdoa - baoa * bard;\n    float c = baba * oaoa - baoa * baoa - capsule.radius * capsule.radius * baba;\n    float h = b * b - a * c;\n    if(h >= 0.0) {\n        float t = (-b -sqrt(h)) / a;\n        float y = baoa + t * bard;\n        \n        float trueT = -1.0;\n        \n        // body\n        if(y > 0.0 && y < baba)\n            trueT = t;\n        \n        // caps\n        vec3 oc = (y <= 0.0) ? oa : transformedRay.o - pb;\n        b = dot(transformedRay.d, oc);\n        c = dot(oc, oc) - capsule.radius * capsule.radius;\n        h = b*b - c;\n        if (trueT == -1.0 && h > 0.0)\n            trueT = -b - sqrt(h);\n        \n        if (trueT >= 0.0) {\n            vec3 p = Point(transformedRay, trueT);\n            vec3 normal = getCapsuleNormal(p, pa + vec3(0.0, 0.0, -capsule.height), pb, capsule.radius);\n            x = Hit(4, trueT, rotationMatrix * normal, capsule.i);\n            \n            return true;\n        }\n    }\n    \n    return false;\n}\n\nbool intersectCylinder(Ray ray, Cylinder cylinder, out Hit x) {\n    mat3 rotationMatrix;\n    Ray transformedRay = transformRayFromWorldToObjectSpace(ray, cylinder.transform, rotationMatrix);\n    \n    vec3 b = vec3(0.0, 0.0, cylinder.height * 0.5);\n    vec3 a = -b;\n    \n    vec3  ba = b - a;\n    vec3  oc = transformedRay.o - a;\n    float baba = dot(ba, ba);\n    float bard = dot(ba, transformedRay.d);\n    float baoc = dot(ba, oc);\n    float k2 = baba - bard*bard;\n    float k1 = baba * dot(oc, transformedRay.d) - baoc * bard;\n    float k0 = baba * dot(oc, oc) - baoc * baoc - cylinder.radius * cylinder.radius * baba;\n    float h = k1*k1 - k2*k0;\n    if (h < 0.0)\n        return false;\n        \n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n    \n    float trueT = -1.0;\n    vec3 normal;\n    \n    // body\n    float y = baoc + t*bard;\n    if (y > 0.0 && y < baba) {\n        trueT = t;\n        normal = Point(transformedRay, trueT);\n        normal.z = 0.0;\n        normal = normalize(normal);\n    }\n        \n    // caps\n    if (trueT < 0.0) {\n        for (int i = 0; i < 2; i++) {\n            vec3  o = transformedRay.o - (i == 0 ? a : b);\n            float t = -dot(vec3(0.0, 0.0, 1.0), o) / dot(transformedRay.d, vec3(0.0, 0.0, 1.0));\n            vec3  q = o + transformedRay.d * t;\n\n            if (dot(q, q) < cylinder.radius * cylinder.radius) {\n                trueT = t;\n                normal = (i == 0 ? vec3(0.0, 0.0, -1.0) : vec3(0.0, 0.0, 1.0));\n            }\n        }\n    }\n    \n    if (trueT >= 0.0) {\n        x = Hit(5, trueT, rotationMatrix * normal, cylinder.i);\n\n        return true;\n    }\n    \n    return false;\n}\n\nbool intersectTorus(Ray ray, Torus torus, out Hit x) {\n    mat3 rotationMatrix;\n    Ray transformedRay = transformRayFromWorldToObjectSpace(ray, torus.transform, rotationMatrix);\n    \n    float po = 1.0;\n    float Ra2 = torus.radii.x*torus.radii.x;\n    float ra2 = torus.radii.y*torus.radii.y;\n    float m = dot(transformedRay.o,transformedRay.o);\n    float n = dot(transformedRay.o,transformedRay.d);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(transformedRay.d.xy,transformedRay.d.xy) + k;\n    float k1 = n*k - Ra2*dot(transformedRay.d.xy,transformedRay.o.xy);\n    float k0 = k*k - Ra2*dot(transformedRay.o.xy,transformedRay.o.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    float trueT = -1.0;\n    \n    if(h >= 0.0)  \n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        trueT = t;\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 )\n        return false;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    \n    if (trueT < 0.0)\n        trueT = t;\n    \n    if (trueT >= 0.0) {\n        vec3 p = Point(transformedRay, trueT);\n        vec3 normal = normalize(p *(dot(p, p) - ra2 - Ra2 * vec3(1.0, 1.0, -1.0)));\n        x = Hit(6, trueT, rotationMatrix * normal, torus.i);\n        \n        return true;\n    }\n    \n    return false;\n}\n\n#define SHAPE_SCENE\n//#define GLOBAL_ILLUMINATION_SCENE\n//#define REFLECTION_SCENE\n//#define MOVING_SCENE\n\n//Scene configurations\n#ifdef MOVING_SCENE\n#define ONLY_MIRROR_REFLECTIONS\n\nconst uint REFLECTION_SAMPLES = 1u;\nconst uint SHADOW_SAMPLES = 8u;\nconst uint GLOBAL_ILLUMINATION_SAMPLES = 16u;\n\nconst float SHADOW_PENUMBRA_SIZE = 0.02;\nconst float GLOBAL_ILLUMINATION_RADIUS = 0.1;\n\nconst float TEMPORAL = 0.5;\n#else\nconst uint REFLECTION_SAMPLES = 4u;\nconst uint SHADOW_SAMPLES = 4u;\nconst uint GLOBAL_ILLUMINATION_SAMPLES = 12u;\n\nconst float SHADOW_PENUMBRA_SIZE = 0.1;\nconst float GLOBAL_ILLUMINATION_RADIUS = 0.2;\n\nconst float TEMPORAL = 0.95;\n#endif\n\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x) {\n    Plane plane = Plane(Transform(vec3(0.,0.,0.), vec3(0.0)), vec3(0.,0.,1.),0);\n    \n#ifdef SHAPE_SCENE\n    #define SPHERE_COUNT 1\n    Sphere spheres[] = Sphere[](\n        Sphere(Transform(vec3(0.,0.,1.), vec3(0.0)),1.,3)\n    );\n    #define CUBOID_COUNT 1\n    Cuboid cuboids[] = Cuboid[](\n        Cuboid(Transform(vec3(0.0, 4.0, 2.0), vec3(0.0, 0.0, 60.0)), vec3(1.0, 2.0, 0.5), 1)\n    );\n    #define ELIPSOID_COUNT 1\n    Elipsoid elipsoids[] = Elipsoid[](\n        Elipsoid(Transform(vec3(0.0, -4.0, 2.0), vec3(0.0, 0.0, 0.0)), vec3(1.0, 1.0, 3.0), 2)\n    );\n    #define CAPSULE_COUNT 1\n    Capsule capsules[] = Capsule[](\n        Capsule(Transform(vec3(4.0, 0.0, 4.0), vec3(0.0, 0.0, 0.0)), 2.0, 2.0, 0)\n    );\n    #define CYLINDER_COUNT 1\n    Cylinder cylinders[] = Cylinder[](\n        Cylinder(Transform(vec3(-4.0, 0.0, 2.5), vec3(0.0, 0.0, 0.0)), 0.5, 2.0, 4)\n    );\n    #define TORUS_COUNT 1\n    Torus toruses[] = Torus[](\n        Torus(Transform(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0)), vec2(8.0, 0.5), 1)\n    );\n#endif\n#ifdef GLOBAL_ILLUMINATION_SCENE\n    #define SPHERE_COUNT 3\n    Sphere spheres[] = Sphere[](\n        Sphere(Transform(vec3(-3.,0.,2.75), vec3(0.0)),2.,2),\n        Sphere(Transform(vec3(0.,0.,2.), vec3(0.0)),1.,2),\n        Sphere(Transform(vec3(0.,0.,3.5), vec3(0.0)),1.,1)\n    );\n    #define TORUS_COUNT 1\n    Torus toruses[] = Torus[](\n        Torus(Transform(vec3(-1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0)), vec2(4.0, 0.5), 2)\n    );\n#endif\n#ifdef REFLECTION_SCENE\n    #define SPHERE_COUNT 3\n    Sphere spheres[] = Sphere[](\n        Sphere(Transform(vec3(-3.,0.,2.75), vec3(0.0)),2.,3),\n        Sphere(Transform(vec3(2.,0.,2.), vec3(0.0)),1.,2),\n        Sphere(Transform(vec3(2.,0.,3.5), vec3(0.0)),1.,1)\n    );\n    #define TORUS_COUNT 1\n    Torus toruses[] = Torus[](\n        Torus(Transform(vec3(-1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0)), vec2(4.0, 0.5), 4)\n    );\n#endif\n#ifdef MOVING_SCENE\n    #define SPHERE_COUNT 1\n    Sphere spheres[] = Sphere[](\n        Sphere(Transform(vec3(0.,0.,7.0), vec3(0.0)),1.,1)\n    );\n    #define CUBOID_COUNT 1\n    Cuboid cuboids[] = Cuboid[](\n        Cuboid(Transform(vec3(0.0, 2.0 * sin(iTime * 2.0), 1.0), vec3(0.0, 0.0, degrees(iTime * 4.0))), vec3(0.5, 2.0, 0.5), 1)\n    );\n    #define CAPSULE_COUNT 1\n    Capsule capsules[] = Capsule[](\n        Capsule(Transform(vec3(0.0, -5.0, 0.5), vec3(iTime * 180.0, 90.0, 0.0)), 0.5, 2.0, 4)\n    );\n    #define TORUS_COUNT 2\n    Torus toruses[] = Torus[](\n        Torus(Transform(vec3(0.0, 0.0, 1.0), vec3(90.0, 0.0, 0.0)), vec2(4.0, 0.5), 2),\n        Torus(Transform(vec3(0.0, 2.0 * sin(iTime), 4.0 + 3.0 * cos(iTime)), vec3(90.0, 0.0, 0.0)), vec2(1.0, 0.2), 1)\n    );\n#endif\n    \n    x = Hit(-1, 1000.0,vec3(0),-1);\n    Hit current;\n    bool ret = false;\n    \n    //Plane\n    if(intersectPlane(ray, plane, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    //Spheres\n#ifdef SPHERE_COUNT\n    for (int i = 0; i < SPHERE_COUNT; i++) {\n        if(intersectSphere(ray, spheres[i], current) && current.t < x.t) {\n            x = current;\n            ret = true;\n        }\n    }\n#endif\n    //Cuboids\n#ifdef CUBOID_COUNT\n    for (int i = 0; i < CUBOID_COUNT; i++) {\n        if(intersectCuboid(ray, cuboids[i], current) && current.t < x.t) {\n            x = current;\n            ret = true;\n        }\n    }\n#endif\n    //Elipsoid\n#ifdef ELIPSOID_COUNT\n    for (int i = 0; i < ELIPSOID_COUNT; i++) {\n        if(intersectElipsoid(ray, elipsoids[i], current) && current.t < x.t) {\n            x = current;\n            ret = true;\n        }\n    }\n#endif\n    //Capsule\n#ifdef CAPSULE_COUNT\n    for (int i = 0; i < CAPSULE_COUNT; i++) {\n        if(intersectCapsule(ray, capsules[i], current) && current.t < x.t) {\n            x = current;\n            ret = true;\n        }\n    }\n#endif\n    //Cylinder\n#ifdef CYLINDER_COUNT\n    for (int i = 0; i < CYLINDER_COUNT; i++) {\n        if(intersectCylinder(ray, cylinders[i], current) && current.t < x.t) {\n            x = current;\n            ret = true;\n        }\n    }\n#endif\n    //Torus\n#ifdef TORUS_COUNT\n    for (int i = 0; i < TORUS_COUNT; i++) {\n        if(intersectTorus(ray, toruses[i], current) && current.t < x.t) {\n            x = current;\n            ret = true;\n        }\n    }\n#endif\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd) {\n    //return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n    float a = 0.5 * (rd.z + 1.0);\n    \n    return (1.0 - a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta) {\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 getColor(Material material, vec3 normal, vec3 viewDir, vec4 reflectedColor, float intensity)\n{\n    //Diffuse\n    float diff = clamp(dot(normal, -lightDirection),0.,1.) * intensity;\n    \n    //Specular\n    //vec3 halfwayDir = normalize(lightDirection + viewDir);\n    vec3 reflectDir = reflect(viewDir, normal);\n    float spec = pow(max(dot(-lightDirection, reflectDir), 0.0), 32.0);\n    vec3 specular = mix(lightColor * spec, reflectedColor.rgb, reflectedColor.a);\n    \n    vec3 col = (material.ambient + material.diffuse * diff) * lightColor + material.specular * specular;\n    \n    return col;\n}\n\n// Renderingy\nvec3 Shade(Ray ray)\n{\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx = Intersect(ray,x);\n    \n    if(idx)\n    {\n        vec3 p = Point(ray,x.t);\n        Material mat = Texture(p,x.i);\n        \n        //Offset the point along the normal to prevent artifacts\n        float normalBias = 0.001;\n        //HACK: use higher offset for torus\n        if (x.geometryID == 6)\n            normalBias = 0.05;\n        \n        vec3 pWithBias = p + x.n * normalBias;\n        \n        //Reflection\n        vec4 reflectedColor = vec4(0.0, 0.0, 0.0, 1.0);\n        for (uint i = 0u; i < REFLECTION_SAMPLES; i++) {\n            Ray reflectedRay;\n            reflectedRay.o = pWithBias;\n            float roughness = mat.roughness;\n#ifdef ONLY_MIRROR_REFLECTIONS\n            roughness = 0.0;\n#endif\n            reflectedRay.d = coneSample(reflect(ray.d, x.n), roughness);\n            Hit reflectedHit;\n            if (Intersect(reflectedRay, reflectedHit)) {\n                Material reflectedMaterial = Texture(Point(reflectedRay, reflectedHit.t), reflectedHit.i);\n                reflectedColor.rgb += getColor(reflectedMaterial, reflectedHit.n, reflectedRay.d, vec4(0.0), 1.0);\n            } else {\n                reflectedColor.rgb += Background(reflectedRay.d);\n            }\n        }\n        reflectedColor.rgb /= float(REFLECTION_SAMPLES);\n        \n        //Shadow\n        float intensity = 0.0;\n        for (uint i = 0u; i < SHADOW_SAMPLES; i++) {\n            Ray shadowRay; \n            shadowRay.o = pWithBias;\n            shadowRay.d = coneSample(-lightDirection, SHADOW_PENUMBRA_SIZE);\n            Hit shadowHit;\n            if (!Intersect(shadowRay, shadowHit))\n                intensity += 1.0;\n        }\n        intensity /= float(SHADOW_SAMPLES);\n         \n        //Global illumination\n        vec3 globalIlluminationColor = vec3(0.0);\n        for (uint i = 0u; i < GLOBAL_ILLUMINATION_SAMPLES; i++) {\n            Ray illuminationRay;\n            illuminationRay.o = pWithBias;\n            illuminationRay.d = Hemisphere(x.n);\n            Hit illuminationHit;\n            if (Intersect(illuminationRay, illuminationHit)) {\n                Material illuminationMaterial = Texture(Point(illuminationRay, illuminationHit.t), illuminationHit.i);\n                float attenuation = smoothstep(0.0, 1.0, illuminationHit.t / GLOBAL_ILLUMINATION_RADIUS);\n                globalIlluminationColor += attenuation * getColor(illuminationMaterial, illuminationHit.n, illuminationRay.d, vec4(0.0), 1.0);\n            } else {\n                globalIlluminationColor += Background(illuminationRay.d);\n            }\n        }\n        globalIlluminationColor /= float(GLOBAL_ILLUMINATION_SAMPLES);\n        \n        //Get the color\n        vec3 color = getColor(mat, x.n, ray.d, reflectedColor, intensity) + globalIlluminationColor * mat.diffuse;\n        \n        return color;\n    }\n    \n    return Background(ray.d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    //Seed\n    rngInitialize(fragCoord, iFrame);\n    \n    // Render\n    vec3 col = Shade(Ray(ro, rd));\n    \n    float temporal = TEMPORAL;\n    if (iMouse.z > 0.0) //Mouse button is pressed\n        temporal = 0.0;\n    \n    fragColor.rgb = mix(col, texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, temporal);\n    fragColor.a = 1.0;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 random3(vec3 c) {\n\tfloat j = 4096.0 * sin(dot(c, vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0 * j);\n\tj *= .125;\n\tr.x = fract(512.0 * j);\n\tj *= .125;\n\tr.y = fract(512.0 * j);\n    \n\treturn r - 0.5;\n}\n\nconst float F3 = 0.3333333;\nconst float G3 = 0.1666667;\n\n/* 3d simplex noise */\nfloat simplexNoise3D(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e * (1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\t \t\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0 * G3;\n\t vec3 x3 = x - 1.0 + 3.0 * G3;\n\t \n\t vec4 w;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t w = max(0.6 - w, 0.0);\n\t \n     vec4 d;\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t return dot(d, vec4(52.0));\n}\n\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\nfloat fractalSimplexNoise3D(vec3 m) {\n    return    0.5333333 * simplexNoise3D(m * rot1)\n\t\t\t+ 0.2666667 * simplexNoise3D(2.0 * m * rot2)\n\t\t\t+ 0.1333333 * simplexNoise3D(4.0 * m * rot3)\n\t\t\t+ 0.0666667 * simplexNoise3D(8.0 * m);\n}\n","name":"Common","description":"","type":"common"}]}