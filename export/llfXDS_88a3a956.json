{"ver":"0.1","info":{"id":"llfXDS","date":"1445121644","viewed":703,"name":"Bloobophone","username":"metabog","description":"Playing around with smooth blended SDF CSG. Still working on this. \n\nThere are occasional edge artifacts, but I am too dumb (tm) to figure out why. \nI also want to make the pieces of the model 'fade' in somehow over the first 15 seconds.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","csg","blend","smooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define bloobyness 0.8 //increase for less cutting\n#define boolbyness 0.4 //increase for more adding\n#define numbloobs 15 //number of CSG pieces (less is smoother and better framerate, more is more weird)\n\nvec3 cameraOrigin = vec3(-18.0, 0.0, 10.0);\nvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\nvec3 upDirection = vec3(0.0, 1.0, 0.0);\n\nconst int MAX_ITER = 100; \nconst float MAX_DIST = 150.0; \nconst float EPSILON = 0.01;\nvec3 lightPosition1 = vec3(20.0,10.0,100.0);\nvec3 lightPosition2 = vec3(-200.0,100.0,-100.0);\n\nfloat Hash( float n )\n{\n\treturn fract( (1.0 + cos(n)) * 415.92653);\n}\n\nfloat Noise2d( in vec2 x )\n{\n    float xhash = Hash( x.x * 37.0 );\n    float yhash = Hash( x.y * 57.0 );\n    return fract( xhash + yhash );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat smax(float x, float y, float k)\n{\n    return log( exp(x) + exp(y) )/k;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n\nfloat distfunc(vec3 pos, float ampenv)\n{\n    ampenv = ampenv*3.0;\n    \n    float val = sphere(pos, 4.0*ampenv);\n    \n   \n    for(int i =0; i< numbloobs; i++)\n    {\n        if(float(i)<iTime)\n        {\n            \n            float power = iTime - float(i);\n            if(power>1.0)\n                power = 1.0;\n            \n            \n        \tfloat a = iTime*0.001;\n\t\t\tfloat rad = float(i)/3.0+3.0;\n        \trad = rad* ampenv*0.8;\n        \tfloat xang = texture(iChannel0, vec2(float(i)/30.0 + a,float(i)/20.0)).x;\n        \tfloat yang = texture(iChannel1, vec2(1.0 - float(i)/30.0,float(i)/20.0) + a).y;\n        \n        \tfloat x = rad * cos(xang*6.28) * sin(yang*6.28);\n        \tfloat y = rad * sin(xang*6.28) * sin(yang*6.28);\n        \tfloat z = rad * cos(yang*6.28);\n\n        \tvec3 npos = vec3(x,y,z);\n        \n        \tif(mod(float(i),2.0) == 0.0)\n        \t\tval = smin(val, sphere(pos+npos,2.0),boolbyness); //a positive edit\n        \telse\n            \tval = smax(-sphere(pos+npos,4.0),val,bloobyness); //a negative edit\n        }\n    }\n    \n \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n\tvec3 startPoint = cameraOrigin;\n\tvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    //amplitude envelope\n    float audioEnvelope = (texture(iChannel2, vec2(iChannelTime[1],0.0))).x;\n   \tint c =0;\n  \tfor(float k = 0.0; k<0.02; k+=0.001)\n    {\n    \tc++;\n    \tfloat val = abs((texture(iChannel2, vec2(iChannelTime[1]+k,0.0))).x);\n    \taudioEnvelope+=  val*val;\n    }\n    audioEnvelope = audioEnvelope/float(c);\n    \n    \n    \n    vec3 camOrigin = cameraOrigin + cameraDir*iTime*0.02;\n    \n    float totalDist = 0.0;\n\tvec3 pos = camOrigin;\n\tfloat dist = EPSILON;\n    \n    \n    \tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv*=0.5; //FOV\n    uv.x*= iResolution.x /iResolution.y;\n    \n    uv*= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * (uv.y) + cameraDir);\n    \n    \n    for (int i = 0; i < MAX_ITER; i++)\n\t{\n    \n    if (dist < EPSILON || totalDist > MAX_DIST)\n        break; \n\n    \tdist = distfunc(pos,audioEnvelope); \n    \ttotalDist += dist;\n    \tpos += dist * rayDir; \n\t}\n    \n\tif (dist < EPSILON)\n\t{\n    \tvec2 eps = vec2(0.0, EPSILON);\n\t\tvec3 normal = normalize(vec3(\n    \tdistfunc(pos + eps.yxx,audioEnvelope) - distfunc(pos - eps.yxx,audioEnvelope),\n   \t\tdistfunc(pos + eps.xyx,audioEnvelope) - distfunc(pos - eps.xyx,audioEnvelope),\n   \t\tdistfunc(pos + eps.xxy,audioEnvelope) - distfunc(pos - eps.xxy,audioEnvelope)));\n       vec3 lightVec1 = normalize(pos - lightPosition1);\n        vec3 lightVec2 = normalize(pos - lightPosition2);\n\n        \n   \t\tvec3 diffuse = vec3(0.0); \n        float redLight = max(0.0, dot(-lightVec1, normal))*0.5;\n        float blueLight = max(0.0, dot(-lightVec2, normal))*0.5;\n        diffuse += vec3(redLight*0.2,0.8*redLight,0.7*redLight);\n        diffuse += vec3(blueLight*0.1,blueLight*0.2,blueLight*0.73);\n        diffuse += vec3(0.2,0.2,0.2); //ambient\n            \n\n\t\tfragColor = vec4(diffuse, 1.0);\n\t}\n\telse\n\t{\n        \t//background.. needs snazzing up\n        \tfloat val1 = uv.x;\n        \tfloat val2 = 1.0 - uv.x;\n        \t\n\t\t\tfragColor = vec4(0.05,0.4,0.7,1.0) * val2 + vec4(0.2,0.8,0.7,1.0) * val1 + 0.6;\n\t}\n}","name":"Image","description":"","type":"image"}]}