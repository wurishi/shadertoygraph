{"ver":"0.1","info":{"id":"td23DR","date":"1548827621","viewed":170,"name":"Monocolour Value Steps","username":"Elyxian","description":"Playing around with some more ideas from https://www.shadertoy.com/view/ws2GRm. More info there.\nThe methodology here isn't perfect and can lead to artifacts.\nUse the camera to look around.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["heightmap","value"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float heightMap(vec2 p) {\n\t\n    float hScale = 0.5;\n    float vScale = 1.0;\n    \n    float height = valueNoise(p / hScale) * vScale;\n    height = floor(height / 0.1) * 0.1;\n    return height;\n    \n}\n\nfloat raytrace(vec3 ro, vec3 rd) {\n\t\n    // Parameters\n    int maxSteps = 500;\n    float maxStepDist = 0.05;\n    float maxDist = 100.0;\n    int maxIterations = 15;\n    float eps = 0.001;\n    \n    // Initial Raymarching Steps\n    bool didHit = false;\n    float beforeDist = -1.0;\n    float afterDist = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < maxSteps && t < maxDist; i++) {\n        \n        beforeDist = afterDist;\n        afterDist = t;\n    \tvec3 p = ro + t * rd;\n        float height = heightMap(p.xz);\n        if (p.y - height < eps) {\n\t\t\tdidHit = true;\n            break;\n        }\n        \n        t += min(p.y - height, maxStepDist);\n        \n    }\n    if (!didHit) {\n    \treturn -1.0;\n    }\n    \n    // Use the interval bisection method to find a closer point, as moving forward by a fixed step\n    // size may have embedded the ray in a cliff\n    for (int i = 0; i < maxIterations; i++) {\n    \tfloat midVal = (beforeDist + afterDist) / 2.0;\n        vec3 p = ro + midVal * rd;\n        if (p.y < heightMap(p.xz)) {\n        \tafterDist = midVal;\n        }\n        else {\n        \tbeforeDist = midVal;\n        }\n    }\n    \n    // Return the midpoint of the closest point before the terrain, and the closest point after it\n    return (beforeDist + afterDist) / 2.0;\n    \n\n}\n\nvec3 getNormal(vec3 p) {\n    \n    // Central differences method to generate a normal vector (doesn't work perfectly for this\n    // non-continuous heightmap)\n    vec2 eps = vec2(0.005, 0.00);\n    vec3 normal = vec3(\n    \theightMap(p.xz + eps.xy) - heightMap(p.xz - eps.xy),\n\t\t2.0 * eps.x,\n\t\theightMap(p.xz + eps.yx) - heightMap(p.xz - eps.yx)\n    );\n    normal = normalize(normal);\n    return normal;\n    \n}\n\nvec3 getDiffuse(vec3 p) {\n    \n    return vec3(0.772, 0.580, 0.176);\n    \n}\n\nvec3 getColor(vec3 p) {\n\t\n    // Directional light source\n    vec3 lightDir = normalize(vec3(0.8, 1.0, -0.8));\n    \n    // The intensity/color of light (all three values are the same for white light)\n    vec3 lightCol = vec3(1.0);\n    \n    // Applies the 'base color' of the light\n    vec3 baseLightCol = vec3(1.0, 1.0, 1.0);\n    lightCol *= baseLightCol;\n    \n    // Applies normal-based lighting\n    vec3 normal = getNormal(p);\n    float normalLight = max(0.05, saturate(dot(normal, lightDir)));\n    lightCol *= normalLight;\n    \n    // Gets the diffuse lighting\n    vec3 diffuse = getDiffuse(p);//vec3(0.368, 0.372, 0.901);\n    \n    // Get the final color\n    vec3 col = lightCol * diffuse;\n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\t\n    vec3 skyCol = vec3(0.9, 0.9, 0.9);\n    float t = raytrace(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if (t >= 0.0) {\n        col = getColor(ro + t * rd);\n    }\n    \n    else {\n        col = skyCol;\n    }\n    \n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray and the origin\n    vec3 ro = vec3(0.0, 3.0, 0.0) + vec3(1.0, 0.0, 1.0) * iTime * 0.5;\n    vec3 rd = normalize(vec3(p, 1.4));\n\n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.0, -0.0):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    rd.yz *= mm2(mo.y);\n    rd.yz *= mm2(-3.14159 / 2.0 + 0.5);\n    rd.xz *= mm2(mo.x);\n    \n    // Render and output the ray to screen\n    vec3 col = render(ro, rd);\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// This file just contains standard noise functions and so on.\n\n// Returns the matrix that rotates a point by 'a' radians\nmat2 mm2(in float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n// Returns the clamped version of the input\nfloat saturate(float t) {\n    return clamp(t, 0.0, 1.0);\n}\n\n// ----------------------------\n// ------ HASH FUNCTIONS ------\n// ----------------------------\n\n// Hash function by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p) {\n    \n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n    \n}\n\n// -------------------------\n// ------ VALUE NOISE ------\n// -------------------------\n\n// Standard value noise function (max. gradient is (15/16)^2)\n\nfloat valueNoise(vec2 p) {\n    \n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    vec2 add = vec2(1.0,0.0);\n    float res = mix(\n        mix(hash12(i + add.yy), hash12(i + add.xy), f.x),\n        mix(hash12(i + add.yx), hash12(i + add.xx), f.x),\n        f.y);\n    return res;\n        \n}","name":"Common","description":"","type":"common"}]}