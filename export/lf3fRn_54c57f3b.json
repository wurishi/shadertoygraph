{"ver":"0.1","info":{"id":"lf3fRn","date":"1732616069","viewed":98,"name":"Fog of Worm","username":"MackFitz","description":"Army of Worms on parade to celebrate the 29th bday of the game. My homage to the glossy charm of rendered cutscenes, with characters stylized in the way I drew them. It make heavy use of line segments & mod(). Didn't manage shadows so here's fog of war.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d","cartoon","animation","mod","valuenoise","worms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define PI 3.14159265359\n#define RES iResolution\n#define PT iMouse\n#define smin smoothmin\n#define smax smoothmax\n\nfloat sdSeg(in vec3 p, in vec3 a, in vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h);\n}\n\nfloat sdSphere(in vec3 p, in vec3 center, float radius) {\n  return length(p - center) - radius;\n}\n\nfloat whiteNoise2x1(vec2 p) {\n  float random = dot(p, vec2(12.235, 78.37283));\n  random = sin(random);\n  random *= 4358.4346;\n  random = fract(random);\n  return random;\n}\n\nfloat valueNoise(vec2 uv) {\n  uv *= 4.0;\n  vec2 gridUV = fract(uv);\n  vec2 gridId = floor(uv);\n\n  gridUV = smoothstep(0.0, 1.0, gridUV);\n\n  float bL = whiteNoise2x1(gridId);\n  float bR = whiteNoise2x1(gridId + vec2(1.0, 0.0));\n  float b = mix(bL, bR, gridUV.x);\n\n  float tL = whiteNoise2x1(gridId + vec2(0.0, 1.0));\n  float tR = whiteNoise2x1(gridId + vec2(1.0));\n  float t = mix(tL, tR, gridUV.x);\n  float noise = mix(b, t, gridUV.y);\n\n  return noise;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n  float noiseValue = valueNoise(p.xz*10.);\n  float heightAdjustment = 0.05 * noiseValue;\n  return dot(p, n) + h + heightAdjustment;\n}\n\nfloat smoothmin(float d1, float d2, float k) {\n  float h = max(k - abs(d1 - d2), 0.) / k;\n  return min(d1, d2) - h * h * k * (1. / 4.);\n}\n\nfloat smoothmax(float d1, float d2, float k) {\n    float h = max(k - abs(d1 - d2), 0.) / k;\n    return max(d1, d2) + h * h * k * (1. / 4.);\n}\n\nint partID = 1;\n\nfloat map(vec3 p) {\n  \n  vec3 g = p;\n  float mx = .33, mz = 1.05;\n  p.x = mod(p.x - mx,2.*mx) - mx;\n  p.z = mod((p.z + iTime/4.) - mz,2.*mz) - mz;\n\n  float m = .05*p.y*(-1. + cos(iTime*5.));\n\n  p.x/=1.5;\n  vec3 n = vec3(0,.25,0.);\n  float off = n.z;\n  n.z+=m;\n  float nose = sdSphere(p,n,.125);\n\n  p.x*=1.5;\n\n  float tR = .125;\n  vec3 ta = vec3(0,.5,.2+m),\n       tb = ta;\n       tb.y = - ta.y;\n       tb.z = off + .2;\n  float torso = sdSeg(p, ta, tb) - tR;\n\n  vec3 tc = vec3(0,-.5,.35),\n       td = tb;\n  td.z = 0.95 - m*4.;\n\n  float tail = sdSeg(p, tc, td) - tR;\n\n  vec3 h = abs(p), z = abs(p);\n  h.y = (mod(h.y - .05,.1));\n  float cutY = h.y;\n  z.z = (mod(z.z - .05+.005*cos(-iTime*5.),.1+.01*cos(-iTime*5.)));\n  float cutZ = z.z;\n\n  float body = smin(smin(\n                smax(torso,-cutY,.03),\n                smax(tail,-cutZ,.03),.1),\n                nose,.025);\n\n  vec3 eA = vec3(.075,.4,.1+m),\n       eB = eA;\n  eB.x = -eA.x;\n\n  float eye1 = sdSphere(p,eA,.1),\n        eye2 = sdSphere(p,eB,.09),\n        eyes = min(eye1,eye2);\n\n  vec3 pA = vec3(.075,.4,.045+m),\n       pB = pA;\n  pB.x = -pA.x;\n\n  float p1 = sdSphere(p,pA,.048),\n        p2 = sdSphere(p,pB,.041),\n        pupils = min(p1,p2);\n\n  \n  p.z-=iTime*.5;\n  float ground = sdPlane(g, vec3(0.,1.,0.), .6);\n\n  float result = min(min(body, min(eyes,pupils)),ground);\n\n  if (result == body) {\n    partID = 1;\n  } else if (result == eyes) {\n    partID = 2;\n  } else if (result == pupils) {\n    partID = 3;\n  }\n  else {\n    partID = 4;\n  }\n\n  return result;\n}\n\nvec3 norm(vec3 p) {\n  float h = 1e-3;\n  vec2 k = vec2(-1, 1);\n  return normalize(\n    k.xyy * map(p + k.xyy * h) +\n    k.yxy * map(p + k.yxy * h) +\n    k.yyx * map(p + k.yyx * h) +\n    k.xxx * map(p + k.xxx * h)\n  );\n}\n\nfloat d0 = 25.;\n\nfloat raymarch(inout vec3 p, vec3 rd) {\n  float dd = 0.0;\n\n  for (float i = 0.0; i < 100.0; i++) {\n    float d = map(p);\n  if (d < 1e-3 || dd > d0) break;\n    p += rd * d;\n    dd += d;\n  }\n  return dd;\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n    float shd=1., maxd=length(lp-p);\n    vec3 l=normalize(lp-p);\n    for (float i=1e-3; i<maxd;) {\n        float d=map(p+l*i);\n        if (d<1e-3) {\n            shd=.0;\n            break;\n        }\n        shd=min(shd,128.*d/i);\n        i+=d;\n    }\n    return shd;\n}\n\nvec3 render(vec3 p, vec3 rd) {\n  float d = raymarch(p, rd);\n  vec3 col = vec3(0);\n\n  if (d < d0) {\n    vec3 n = norm(p),\n         lp = vec3(-1, 2, -5),\n         l = normalize(lp - p);\n    float diffuse = clamp(dot(l, n), 0., 1.),\n          reflective = clamp(dot(reflect(rd, n), l), .0, 1.0);\n          col += .5*diffuse;\n          \n    if (partID <= 3) {\n      col += pow(reflective, 32.);\n    }\n\n    if (partID == 1) {\n      col = mix(col, vec3(1.,0.,0.), .33);\n    } else if (partID == 2) {\n      col = mix(col, vec3(1.), .5);\n    } else if (partID == 3) {\n      col = mix(col, vec3(-.5), .5);\n    } else if (partID == 4) {\n      col = mix(col, vec3(-1.25,-2.,-2.25), .25);\n    }\n    col += .1+.4*diffuse*shadow(p+n*5e-2, lp);\n  } else {\n    col += vec3(.25,.6*(abs(rd.z)),.6);\n  }\n\n  float fogFactor = clamp(d / d0, 0.0, 1.0);\n  vec3 fogColor = vec3(0.25, 0.6 * abs(rd.z), 0.6);\n  col = mix(col, fogColor, fogFactor);\n\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - .5 * RES.xy) / RES.y;\n\n  float angleX = PT.z > 0. ? (PT.x / RES.x * 2. + 2.)*PI/3. : PI + cos(iTime/6.),\n        angleY = PT.z > 0. ? (PT.y / RES.y * 2. - 1. - 1.)*PI*-.25 : .5 - .15*(1. + cos(iTime/5.)),\n        camR = 5.;\n  vec3 target = vec3(0.0);\n\n  vec3 ro = vec3(\n    sin(angleX)*cos(angleY),\n    sin(angleY),\n    cos(angleX)*cos(angleY)\n    )*camR;\n\n  vec3 fwd = normalize(target - ro),\n      right = normalize(cross(vec3(0., 1., 0.), fwd)),\n      up = cross(fwd, right),\n      rd = normalize(fwd + uv.x * right + uv.y * up);\n\n  float t = 0.0;\n  vec3 p = ro, col = render(ro, rd);\n  fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}