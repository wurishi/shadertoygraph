{"ver":"0.1","info":{"id":"WdcXRr","date":"1571263289","viewed":270,"name":"ShaderTober - Overgrown","username":"Flopine","description":"A small doodle with inktober's theme \"Overgrown\"","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","plant","vines","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 64.\n#define PI 3.141592\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash11 (float x)\n{return fract(sin(x)*124.5);}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id)>= rep/2.) id = abs(id);\n    return id;\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat leaf (vec3 p)\n{\n    p.xz *= rot(PI);\n    p.y += sin((p.x+3.5)*1.5)*0.5;\n    return box(p, vec3(1.5,0.01+p.x*0.02,0.28+sin(p.x*2.)*0.3));\n}\n\nfloat vine (vec3 p)\n{\n    float c = cyl(p.xz,0.5);\n   \n    p.y = mod(p.y, 3.)-3.*0.5;\n    moda(p.xz, 3.);\n    p.x -= 2.;\n    \n    return stmin(c,leaf(p),0.3, 3.);\n}\n\nfloat s_id;\nfloat sprout (vec3 p)\n{\n\tp.xz *= rot(iTime*0.2);\n    p.xz *= rot(p.y*0.5);\n    s_id = moda(p.xz, 7.);\n    p.x -= .8+sin(p.y+iTime)*0.3;\n    return vine(p);\n}\n\nfloat SDF (vec3 p)\n{\n    p.y += iTime*0.5; \n    return sprout(p);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(SDF(p)- vec3(SDF(p-eps.xyy), SDF(p-eps.yxy), SDF(p-eps.yyx)));\n}\n\nfloat dir_light (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.001,-1.5,-4.),\n        p = ro,\n        rd = getcam(ro, vec3(0.,0.8,0.), uv),\n        l = vec3(2.,0.,.5),\n        col = vec3(0.,0.3-uv.y*0.2,0.5);\n    \n    bool hit = false;\n    float shad = 0.;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        \n        p+=d*rd*0.5;\n    }\n    \n    float t = length(ro-p);\n    \n   \tif (hit)\n    {\n        vec3 n = getnorm(p);\n        vec3 v_col = vec3(hash11(s_id)*0.8,1.,hash11(s_id+0.5));\n        col = mix(vec3(0.,0.1,0.3), v_col, clamp(dir_light(n,l),0.,1.));\n        col *= 1.-shad;\n    }\n   \tvec3 back_col = mix(vec3(0.,0.3-uv.y*0.2,0.5), \n                        vec3(0.8,0.8,0.9), \n                        texNoise(uv*0.03+vec2(0.,iTime*0.004)).g*0.8);\n    col = mix(col,back_col, 1.-exp(-0.03*t*t));\n    \n    // vignetting (from iq)\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.7);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}