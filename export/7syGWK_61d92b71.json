{"ver":"0.1","info":{"id":"7syGWK","date":"1634635829","viewed":97,"name":"Человечек PBR+Texture","username":"lumidelta","description":"PBR","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 1000;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat lengthpow ( in vec2 p, in float pwr ) {\n    return pow ( pow ( p.x, pwr ) + pow ( p.y, pwr ), 1.0/ pwr );\n}\n\nfloat lengthpow ( in vec3 p, in float pwr ) {\n    return pow ( pow ( p.x, pwr ) + pow ( p.y, pwr ) + pow ( p.z, pwr ), 1.0/ pwr );\n}\n\nfloat dSphere ( vec3 p, in vec3 c, in float skale, in float pwr ) {\n\treturn lengthpow ( p - c, pwr ) - 1.0 * skale;\n}\n\n\nfloat dTorus ( vec3 p, vec2 t ) {\n\tvec2\tq = vec2 ( lengthpow ( p.xz, 8.0 ) - t.x, p.y );\n\t\n\treturn lengthpow ( q, 8.0 ) - t.y;\n}\n\nfloat dEllipsoid ( in vec3 p, in vec3 c, in vec3 size, in float skale, in float pwr) { \n    return lengthpow ( vec3((p.x - c.x)/size.x, (p.y - c.y)/size.y, (p.z - c.z)/size.z) , pwr ) - 1.0 * skale;\n} \n\n//float dCylinder(in vec3 p, in vec3 c, in vec3 size, in float skale, in float pwr) {\n//    if (p.x < size.x * skale && p.x > -size.x * skale) {\n//        return (pow((p.y - c.y)/size.y, pwr) + pow((p.z - c.z)/size.z, pwr) - skale);\n//        }\n//        else {\n//            return 1000.0;\n//        }\n//}\n\nfloat smin ( float a, float b, float k ) {\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\n\nfloat smax ( float a, float b, float k ) {\n\tfloat res = exp ( -k*a ) - exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p ) {\n    //return dSphere ( p, vec3 ( 0, 0, 0 ) );\n    //return dBox ( p, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn dTorus ( p, vec2 ( 0.73, 0.5 ) );\n}\n\nfloat sdf ( in vec3 p, in mat3 m ) {\n    float k = 0.3;\n    vec3 q = m * p;\n\treturn\n    min(\n        smin(\n            smin(\n                dEllipsoid ( q, vec3 ( 0, -1.5, 0 ), vec3(1, 1, 1), 0.1, 8.0 ),\n                dEllipsoid ( q, vec3 ( 0, -3.7, 0 ), vec3(2, 7, 4), 0.3, 8.0 ), \n                25.0\n            ),\n            max(\n                min(\n                    dEllipsoid ( q, vec3 ( 0, -0.5, 0 ), vec3(2, 3, 2), 0.3, 2.0 ),\n                    dEllipsoid ( q, vec3 ( 0.6, -0.55, 0 ), vec3(1, 1, 1), 0.1, 2.0 )\n                ),\n                -dEllipsoid ( q, vec3 ( 1.0, -0.8, 0 ), vec3(2, 0.25, 2), 0.3, 2.0 )\n            ),\n            25.0\n        ),\n        min(\n            smin(\n                dTorus ( q, vec2 ( 0.5, 0.1 )),\n                dEllipsoid ( q, vec3 ( 0, 0.5, 0 ), vec3(4.5, 6, 4.5), 0.1, 8.0 ),\n                25.0\n            ),\n            min(\n                dSphere(q, vec3(0.49, -0.35, -0.2), 0.1, 2.0),\n                dSphere(q, vec3(0.49, -0.35, 0.2), 0.1, 2.0)\n            )\n        )\n    );\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m ) {\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m ) {\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst vec3 lightColor = vec3 ( 1.0 ); \nconst float gamma     = 2.2; \nconst float pi        = 3.1415926; \nconst float FDiel     = 0.04; \t\t\t// F0 - Fresnel for dielectrics \n\nvec3 fresnel ( in vec3 f0, in float product ) { \n    product = clamp ( product, 0.0, 1.0 ); // saturate \n\n    return mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) ); \n} \n\nfloat D_blinn(in float roughness, in float NdH)  { \n    float m = roughness * roughness; \n    float m2 = m * m; float n = 2.0 / m2 - 2.0; \n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n); \n} \n\nfloat D_beckmann ( in float roughness, in float NdH ) { \n    float m = roughness * roughness; \n    float m2 = m * m; \n    float NdH2 = NdH * NdH; \n    return exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2); \n}\n\n\nfloat D_GGX ( in float roughness, in float NdH )  { \n    float m = roughness * roughness; \n    float m2 = m * m; \n    float NdH2 = NdH * NdH; \n    float d = (m2 - 1.0) * NdH2 + 1.0; \n\n    return m2 / (pi * d * d); \n} \n\nfloat G_schlick ( in float roughness, in float nv, in float nl ) { \n    float k = roughness * roughness * 0.5; \n    float V = nv * (1.0 - k) + k; \n    float L = nl * (1.0 - k) + k; \n\n    return 0.25 / (V * L); \n}\n\nfloat G_neumann ( in float nl, in float nv )  { \n    return nl * nv / max ( nl, nv ); \n} \n\nfloat G_klemen ( in float nl, in float nv, in float vh )  { \n    return nl * nv / (vh * vh ); \n} \n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh ) { \n    return min ( 1.0, min ( 2.0 * nh * nv / vh, 2.0 * nh * nl/vh ) ); \n}\n\n\nvec3 cookTorrance ( in float nl, in float nv, in float nh, in float vh, in vec3 f0, in float roughness )  { \n    float D = D_GGX ( roughness, nh ); \n    float G = G_neumann ( nl, nv ); \n    return f0 * D * G; \n}\n\nvec4 PBR(in vec3 p, in vec3 n, in vec3 l, in vec3 v, in mat3 m) {\n    vec3 q = m * p;\n    // float roughness = 0.8;\n    float roughness = texture ( iChannel0, q.yz * 0.3* (1.5 - sin(iTime))).x;        \n    float metallness = 1.0;\n    vec3  color  = 0.5 * vec3 ( 0.8, 0.8, 0.2 ) + 0.5 * texture(iChannel0, q.yz * 0.3 * (1.5 - sin(iTime))).rgb;\n    vec3  base  = pow ( color, vec3 ( gamma ) );\n    vec3  h = l + v;\n    vec3 n2 = normalize ( n ); \t\t\t// normalize incoming directions\n    vec3 l2 = normalize ( l ); \n    vec3 h2 = normalize ( h ); \n    vec3  v2 = normalize ( v );\n    float nv = max ( 0.0, dot ( n2, v2 )); \n    float nl = max ( 0.0, dot ( n2, l2 )); \n    float nh = max ( 0.0, dot ( n2, h2 )); \n    float hl = max ( 0.0, dot ( h2, l2 )); \n    float vh = max ( 0.0, dot ( h2, v2 ));\n    vec3 F0          = mix ( vec3 ( FDiel ), base, metallness ); \n    vec3 specFresnel = fresnel ( F0, nv );\n    vec3 spec        = cookTorrance ( nl, nv, nh, vh, specFresnel, roughness ) * nl / \n    max ( 0.001, 4.0 * nl * nv ); \n    vec3 diff        = (vec3(1.0) - specFresnel) * nl / pi; \n\n    vec4 result = pow ( vec4 ( ( diff * mix ( base, vec3(0.0), metallness) + spec )\n     * lightColor, 1.0 ), vec4 ( 1.0 / gamma ) );\n     \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 1, 1, 1, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit ) {\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n\t\t//color = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 1, 1, 1, 1 );\n         color = PBR ( p, n, l, v, m);\n\t} \n\n    // Output to screen\n    fragColor = color;\n}\n\n","name":"Image","description":"","type":"image"}]}