{"ver":"0.1","info":{"id":"wssfR8","date":"1587724042","viewed":102,"name":"2d Stars ","username":"ai221","description":"it's stars wow\n\nmouse to move the camera","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst vec3 star_colors[] = vec3[](vec3(0xff,0xff,0xff)/255.0,vec3(0xfb,0xf3,0xf9)/255.0,vec3(0xba,0xd8,0xfc)/255.0);\n\nvec3 do_star_plate(vec2 fragCoord, vec3 camera, vec2 dcamera_dt, float size)\n{\n    const float coeffecient_smear = 1.0/20.0;\n    \n    fragCoord += (camera.xy*size);\n    \n    float star_size = ceil(3.f*size);\n    float space_between = star_size;\n\n    vec2 star_id = floor(fragCoord/space_between);\n    \n    bool is_star = rand(star_id) < 0.001;\n    \n    float randval = rand(star_id+vec2(512.4f, 1231.2f));\n    \n    vec2 star_center = (star_id * star_size)+star_size/2.0;\n   \n    const float rel_size_of_100_brightness_spot = .25;\n    \t   \n    float star_brightness_at_this_spot = 0.0;\n    \n    //basically, to get this equation I:\n    //\n    //1. set the center of each star to be 1.0 and the edges to taper off\n    //2. forced a circle around the center to be 100% bright, and \n    //   only begin to taper after exiting that circle (which is of size \n    //   star_size * rel_size_of_100_brightness_spot;\n    if (is_star)\n    {\n        if (false)//star_size/camera.z < 1.5)\n        {\n            star_brightness_at_this_spot = 1.0;\n        }\n        else\n        {\n            star_brightness_at_this_spot = \n                clamp((((star_size/2.0)-distance(fragCoord,star_center)))/star_size + rel_size_of_100_brightness_spot, 0.0, 1.0)-rel_size_of_100_brightness_spot;\n\n            star_brightness_at_this_spot /= rel_size_of_100_brightness_spot;\n\n            star_brightness_at_this_spot = clamp(star_brightness_at_this_spot,0.0,1.0);\n        }\n    }\n\n    \n    vec3 star_color = star_colors[int(randval*3.0)];\n    \n    \n    return star_color*vec3(star_brightness_at_this_spot,star_brightness_at_this_spot,star_brightness_at_this_spot);\n    \n\n}\n\n/*vec2 rotationCCW(vec2 v, float r)\n{\n    float new_x = v.x*cos(r) + v.y*sin(r);\n    v.y = v.y*cos(r) - v.x*sin(r);\n    v.x = new_x;\n    return v;\n}*/\nvec2 rotation(vec2 v, float r)\n{\n    float new_x = v.x*cos(r) - v.y*sin(r);\n    v.y = v.y*cos(r) + v.x*sin(r);\n    v.x = new_x;\n    return v;\n}\n\nvec2 centered_rotation_scale(vec2 v, float r, float scale, vec2 size)\n{\n\tv -= size/2.0;\n    v *= scale;\n    v = rotation(v,r);\n    v += size/2.0;\n    return v;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camera;// = vec2(iTime*300.0f,iTime+iTime*cos(iTime/5.0)*5.0);//*0.0;\n    vec2 dcamera_dt = vec2(00.0, abs(cos(iTime/5.0) *(sin(iTime/5.0)*iTime)/5.0)); \n    \n    camera.y = 0.0;\n    camera.x = iMouse.x;\n    camera.z = (iMouse.y*4.0)/iResolution.y;\n    \n    //fragCoord *= camera.z;\n    \n    fragCoord = centered_rotation_scale(fragCoord, iTime/5.0,camera.z, iResolution.xy);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0,0,0);\n    \n    col += do_star_plate(fragCoord,camera,dcamera_dt,1.0);\n    col += do_star_plate(fragCoord,camera,dcamera_dt,.5);\n    col += do_star_plate(fragCoord,camera,dcamera_dt,.1);\n   \n    \n/*\n    \n    star_id = floor(fragCoord/space_between);\n    \n    if (mod(fragCoord.x, space_between) < size &&\n        mod(fragCoord.y, space_between) < size &&\n        rand(star_id) < 0.2f)\n    {\n       col = vec3(1,1,rand(star_id*3.0)+0.25);\n    }\n*/\n    //mod(2.f,3.f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n} \n \n","name":"Image","description":"","type":"image"}]}