{"ver":"0.1","info":{"id":"ctccRl","date":"1699523827","viewed":193,"name":"INRIA's Voronoi","username":"rubioh","description":"Voronoi from INRIA's website (in fact it's a delaunay tesselation on their website nvm I'm too lazy to change this it's a 5minutes work) : https://www.inria.fr/fr/modelisation-et-simulation","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["voronoiinria"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// INSPIRE FROM https://www.inria.fr/fr/modelisation-et-simulation\n\n#define AA\n#define PI 3.14\nvec2 hash22(vec2 st) {\n    return vec2(fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123),fract(cos(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123));\n}\n\nvec2 voronoi(vec2 uv)\n{\n    vec2 uv_id = floor (uv);\n    vec2 uv_st = fract(uv);\n\n    vec2 m_diff;\n    vec2 m_point;\n    float m_dist = 10.;\n    for (int j = -2; j<=2; j++){\n        for (int i = -2; i<=2; i++){\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = hash22(uv_id + neighbor);\n            point = 0.5+0.5*sin(2.*PI*point);\n            vec2 diff = neighbor + point - uv_st;\n            float dist = length(diff);\n            if (dist < m_dist)\n            {\n                m_dist = dist;\n                m_point = point + neighbor + uv_id;\n            }\n        }\n    }\n    return vec2(m_point);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    uv = uv*5.;\n    vec2 m = ( 2.*iMouse.xy - iResolution.xy ) / iResolution.y;\n    m *= 5.;\n    \n    \n    vec2 dx = vec2(1./iResolution.y*5., .0);\n    vec2 dy = vec2(.0, 1./iResolution.y*5.);\n    \n    float P = .9;\n    vec3 C = vec3(.2, .9, .4)*1.2;\n    \n    vec2 uv_w = voronoi(uv);      \n    float L = 1.5*1./(1.+length(uv_w - m));\n    vec3 col = pow(L, P) * C;\n    \n    \n    // CHEAP VERSION OF ANTI ALIASING :'(\n    #ifdef AA\n    uv_w = voronoi(uv+dx);      \n    L = 1.5*1./(1.+length(uv_w - m));\n    col += pow(L, P) * C;\n    \n    uv_w = voronoi(uv+dy);      \n    L = 1.5*1./(1.+length(uv_w - m));\n    col += pow(L, P) * C;\n    \n    uv_w = voronoi(uv-dx);      \n    L = 1.5*1./(1.+length(uv_w - m));\n    col += pow(L, P) * C;\n    \n    uv_w = voronoi(uv-dy);      \n    L = 1.5*1./(1.+length(uv_w - m));\n    col += pow(L, P) * C;\n\n    \n    col /= 5.;\n    #endif\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}