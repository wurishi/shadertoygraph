{"ver":"0.1","info":{"id":"DtB3Wy","date":"1673816787","viewed":122,"name":"A Present","username":"NivBehar","description":"It's a bit hard for me to put it into words so I'll draw it for you :)\n\nUse the mouse to reset","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["heart","gift","love","present"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 0 to 1\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 backgroundCol = vec3(251.,241.,211.)/255.;\n\nfloat ILoveUsdf(vec2 UV, bool tofixEdge)\n{\n    // I\n    float I_top_bot = sdBox(vec2(UV.x, abs(UV.y)) - vec2(-1.3, 0.5), vec2(0.3, 0.1));\n    float I_mid = sdBox(UV - vec2(-1.3, 0.), vec2(0.07, 0.4));\n    float I = min(I_top_bot, I_mid);\n    //I = smoothstep(0.,0.01, I);\n    \n    // <3\n    float Love = sdHeart(UV - vec2(-0.18,-0.5));\n    float edgeFix = length(UV*vec2(1.6,1.) - vec2(-0.16,0.65)) - 0.2; // not in use\n    Love = tofixEdge ? max(Love, -edgeFix) : Love;\n    //Love = smoothstep(0.,0.01, Love);\n    \n    // U\n    vec2 U_pos = vec2(1.15, 0.13);\n    float U = sdTunnel(vec2(UV.x, -UV.y) - U_pos, vec2(0.51,0.75));\n    float inner_U = sdTunnel(vec2(UV.x, -UV.y) - U_pos, vec2(0.3,15));\n    U = max(U, -inner_U);\n    //U = smoothstep(0.,0.01, U);\n    \n    float ret = min(min(I, Love), U);\n    return ret;\n}\n\nvec3 getBackround(vec2 uv)\n{\n    float FBM = fbm(vec3(uv*0.05, 0.));\n    return backgroundCol - 0.12*FBM*FBM*FBM;\n}\n\nvec3 mask(vec3 col, float toMask)\n{\n    col -= toMask;\n    col = clamp(col, vec3(0.), vec3(1.));\n    col += toMask;\n    return col;\n}\n\nvec3 mask(vec3 col, float toMask, vec3 maskCol)\n{\n    col -= toMask;\n    col = clamp(col, vec3(0.), vec3(1.));\n    col += toMask * maskCol;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy ) / min(iResolution.x,iResolution.y); // -1 to 1\n    vec2 uv_temp = uv;\n    vec3 col;\n    vec3 prev_col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    if(iFrame == 0 || iMouse.z > 0.)\n    {\n        float FBM = fbm(vec3(fragCoord*0.1, 0.));\n        col = getBackround(fragCoord);\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    float frame = float(iFrame);\n    vec2 hash = hash21(frame);\n    vec2 RandPos = (hash-0.5)*vec2(5.5,2.5);\n    vec2 uv_heart = rot(uv - RandPos - vec2(0, -0.05), hash11(frame)*5.);\n    float r = 4. + 10.*hash11(frame);\n    float heart = smoothstep(0.01,0.0, length(uv_heart) - r);\n    heart = smoothstep(0.15,0.0, sdHeart((uv_heart)* r));\n    float heartEdge = smoothstep(0.12,0.08, sdHeart((uv_heart)* r));\n    heartEdge = heart - heartEdge;\n    heart = heart - heartEdge;\n    \n    \n    col = vec3(0.);\n    float distFromLove = ILoveUsdf(uv, false); // I can't belive I named it that way\n    distFromLove = smoothstep(0., 0.1,distFromLove);\n    float distFromLoveUV = ILoveUsdf(uv, false);\n    distFromLoveUV = smoothstep(0., 0.06,distFromLoveUV);\n\n\n    float FBM = fbm(vec3((fragCoord)*1., 0.));\n\n    // final color for small hearts\n    vec3 finalHeartCol;\n    \n    // white heart col\n    vec3 whiteHeartCol = vec3(1.,1.,1.) - 0.13*vec3(FBM);\n    \n    // red heart col\n    vec3 redHeartCol = vec3(0.86,0.,0.) * (1. - FBM*0.3);\n\n    // set final color for the hearts\n    //float mixBy = clamp(distFromLove/length(vec2(uv.x*0.8,uv.y)), 0., 1.);\n    finalHeartCol = mix(redHeartCol, whiteHeartCol, clamp(1.-smoothstep(0.05,0.17,length(uv*0.05)), 0., 1.));\n    float mixBy = clamp(distFromLove, 0., 1.);\n    finalHeartCol = mix(redHeartCol, finalHeartCol, mixBy);\n    float distFromLoveUVEdge = smoothstep(0.01, 0.0,ILoveUsdf(uv, false));\n    distFromLoveUVEdge -= smoothstep(0.06, 0.0,ILoveUsdf(uv, false));\n    finalHeartCol -= vec3(distFromLoveUVEdge);\n\n    // set the final color to previous frame and add another small heart\n    col = mask(prev_col, heart, finalHeartCol);\n    // add small heart edge\n    col = mask(col, heartEdge);\n    \n    //col = vec3(distFromLove);//\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nvec2 rot(vec2 p, float t)\n{\n    mat2 mat = mat2(cos(t),-sin(t),sin(t),cos(t));\n    return mat * p;\n}\n\n// by IQ\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// by IQ\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// by IQ\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n// by Dave_Hoskins\nfloat hash13(vec3 p)\n{\n\tp = fract(p * .1031);\n\tp = p + dot(p, vec3(p.z, p.y, p.x) + 31.32);\n\treturn fract((p.x + p.y) * p.z);\n}\n\n// overkill for this shader but I dont care\nfloat TrilinearInterpolationHash(vec3 p)\n{\n\t// www.en.wikipedia.org/wiki/Trilinear_interpolation\n\tif (fract(p.x) == 0. && fract(p.y) == 0. && fract(p.z) == 0.)\n\t{\n\t\treturn hash13(p);\n\t}\n\telse\n\t{\n\t\tvec3 p0 = vec3(floor(p.x), floor(p.y), floor(p.z));\n\t\tvec3 p1 = vec3(floor(p.x) + 1., floor(p.y) + 1., floor(p.z) + 1.);\n\t\tvec3 pd = vec3(fract(p.x), fract(p.y), fract(p.z));\n\t\tfloat c000 = hash13(p0);\n\t\tfloat c001 = hash13(vec3(p0.x, p0.y, p1.z));\n\t\tfloat c010 = hash13(vec3(p0.x, p1.y, p0.z));\n\t\tfloat c011 = hash13(vec3(p0.x, p1.y, p1.z));\n\t\tfloat c100 = hash13(vec3(p1.x, p0.y, p0.z));\n\t\tfloat c101 = hash13(vec3(p1.x, p0.y, p1.z));\n\t\tfloat c110 = hash13(vec3(p1.x, p1.y, p0.z));\n\t\tfloat c111 = hash13(p1);\n\n\t\tfloat c00 = mix(c000, c100, pd.x);\n\t\tfloat c01 = mix(c001, c101, pd.x);\n\t\tfloat c10 = mix(c010, c110, pd.x);\n\t\tfloat c11 = mix(c011, c111, pd.x);\n\n\t\tfloat c0 = mix(c00, c10, pd.y);\n\t\tfloat c1 = mix(c01, c11, pd.y);\n\n\t\tfloat c = mix(c0, c1, pd.z);\n\n\t\treturn c;\n\t}\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * TrilinearInterpolationHash(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// by Dave_Hoskins\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// by Dave_Hoskins\nvec2 hash21(float p) // 0-1\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .4030, .10973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}","name":"Common","description":"","type":"common"}]}