{"ver":"0.1","info":{"id":"Msfyzs","date":"1489534409","viewed":141,"name":"balls with light","username":"t91","description":"ray marching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3  v_cam_pos = vec3(0.0, 1.0, -6.0);\nvec3  v_cam_forward = vec3(0.0, 0.0, 1.0);\nvec3  v_cam_right = vec3(1.0, 0.0, 0.0);\nvec3  v_cam_up = vec3(0.0, 1.0, 0.0);\nvec3  v_sundir = normalize(vec3(0.0, 1.0, 1.10));\nfloat f_near = 2.3;\n\n#define SPHERE 100\n#define FLOOR 999\n#define WALL 1000\n#define CEIL 1001\n#define INFINITY 99999.0\n\n#define EPSILON 0.00001\n#define MAX_STEPS 400\n\n#define CEIL_HEIGHT 12.0\n#define BOX_RADIUS 20.0\n\n#define PI 3.1415926535\n\nvec3 ToRay(in vec2 fragCoord, in mat3 m)\n{\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 ndc = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0; \n\tvec3 ray = vec3(aspect * ndc, f_near);\n\treturn m * normalize(ray);\n}\n\nvoid Box(vec3 point, out int matid, inout float distance)\n{\n    float boxdist = INFINITY;\n\n    #define TEST(dist, mid) if (dist<distance) { distance = dist; matid=mid; }\n    \n    float zrad = sin(point.x)*0.2 + BOX_RADIUS;\n    float xrad = sin(point.z)*0.2 + BOX_RADIUS;\n    \n    float z = zrad + point.z;\n    float x = xrad + point.x;\n    \n    if (point.z > 0.0)\n    \tz = zrad - point.z;\n\n    if (point.x > 0.0)\n    \tx = xrad - point.x;\n\n    TEST(z, WALL);\n    TEST(x, WALL);\n    TEST(point.y - 0.1*sin(length(point.xz)+iTime), FLOOR);\n    TEST(CEIL_HEIGHT - point.y, CEIL);\n}\n\nvec3 spheres_pos[7];\n\nvoid Sphere(vec3 point, out int matid, inout float distance, float x, float y, int id)\n{   \n    float dist = (1.0 + max(0.0, sin(iTime * 4.0 + (float(id)*PI * 0.25)))) * 3.0;\n    \n    vec3 position = vec3(x * dist, 2.0, y * dist);\n    float radius = 1.0;\n    \n    spheres_pos[id] = position + vec3(0.0, radius * 1.1, 0.0);\n\n    float l2c = length(point - position) - radius;\n\n    if (l2c < distance)\n    {\n        distance = l2c;\n        matid = int((x * 17.0) + (y * 13.0) + 23.0) ^ 0x55555555;\n    }\n}\n\nfloat SceneDistance(vec3 point, out int matid)\n{\n    vec3 offset = vec3(0.0, 3.4, 0.0);\n    float distance = INFINITY;\n\n    Sphere(point, matid, distance, -1.0,  0.0, 0);\n    Sphere(point, matid, distance,  0.0,  0.0, 1);\n    Sphere(point, matid, distance,  1.0,  0.0, 2);\n    Sphere(point, matid, distance,  0.0,  1.0, 3);\n    Sphere(point, matid, distance,  0.0, -1.0, 4);\n\tSphere(point, matid, distance, -2.0, -2.0, 5);\n    Sphere(point, matid, distance,  2.0,  2.0, 6);\n    \n    Box(point, matid, distance);\n\n\n\treturn distance;\n}\n\nvec3 March(vec3 start, vec3 ray, out int matid, out int samples, out float prec)\n{   \n    matid = -1;\n    samples = -1;\n    float step = 0.0;\n    \n\tfor (int i = 0; i < MAX_STEPS; ++i)\n    {\n        step = SceneDistance( start, matid );\n\n        if (step < EPSILON)\n        {\n            prec = step;\n            samples = i;\n            return start;\n        }  \n        \n        start += step * ray;\n    }\n    \n    return vec3(0,0,0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// calculate normal \n// taken from https://www.shadertoy.com/view/4lGSWt\nfloat df(vec3 p)\n{\n    int matid = 0;\n\treturn SceneDistance(p, matid);\n}\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.001;\n\treturn normalize(vec3(\n\t\tdf(p + vec3(eps, 0, 0)) - df(p + vec3(-eps, 0, 0)),\n\t\tdf(p + vec3(0, eps, 0)) - df(p + vec3(0, -eps, 0)),\n\t\tdf(p + vec3(0, 0, eps)) - df(p + vec3(0, 0, -eps))\n\t\t));\n}\n/////////////////////////////////////////////////////////////////////////////\n\nvoid SampleEnv(in vec3 ori, in vec3 dir, out vec3 pos, out vec3 nrm, out int matid, out int samples)\n{\n    float prec;\n    \n    pos = March(ori, dir, matid, samples, prec);   \n    nrm = calcNormal(pos);\n}\n\nvec4 IdToColor(int id)\n{\n    vec4 outc = vec4(0.0);\n\n    outc.x = float((id)%11) * 0.1;\n    outc.y = float((id+3)%11) * 0.1;\n    outc.z = float((id+6)%11) * 0.1;\n    outc.w = 0.7;\n    \n    if (id == FLOOR)\n    {\n    \toutc = vec4(1.3, 1.0, 0.3, 0.1);\n    }\n    else if (id == CEIL)\n    {\n        outc = vec4(1.0, 0.5, 1.0, 1.0);\n    }\n    else if (id == WALL)\n    {\n    \toutc = vec4(3.0, 1.3, 1.0, 0.1);\n    }\n\n    return outc;\n}\n\nfloat AmbientOcclusion(float samples)\n{\n\treturn (1.0-clamp(pow(samples / 400.0, 0.2), 0.0, 1.0));\n}\n\nfloat ShadowSample(vec3 pos, vec3 sunpos)\n{\n    sunpos *= 0.9;\n    int id;\n    int smp;\n    float prec;\n\n    vec3 sundir = normalize(pos-sunpos);\n    \n    vec3 shadow_pos = March(sunpos, sundir, id, smp, prec);\n\n    if (smp < 0)\n        return 1.0;\n    \n    float dist2pos = length(sunpos - pos);\n    float dist2shd = length(sunpos - shadow_pos);\n    \n    float dist = abs(dist2pos - dist2shd);\n    \n    if (dist2shd + 0.01 < dist2pos)\n        return 0.5;\n\telse \n        return 1.0;\n}\n\nfloat Shadow(vec3 pos)\n{\n    float shadow = 0.0;\n\n    for (int i = 0; i < 7; ++i)\n    {\n        shadow += ShadowSample(pos, spheres_pos[i] );\n    }\n    \n\n    return shadow * 0.25;\n}\n\nvec3 AmbientLight()\n{\n\treturn vec3(1.0, 1.0, 1.0) * 0.2;\n}\n\nvec3 SunLight(vec3 nrm)\n{\n\treturn dot(nrm, v_sundir) * vec3(1.0, 1.0, 1.0); // * vec3(0.9, 0.2, 0.2) * 6.0;\n}\n\nvec3 Diffuse(vec3 pos, int id)\n{\n    vec3 color = IdToColor(id).xyz;\n    \n\treturn color;\n}\n\nvec3 Specular(vec3 pos, vec3 nrm, int id)\n{\n    vec3 VertexToEye = normalize(v_cam_pos - pos);\n    float str = 0.0;\n \n    for (int i = 0; i < 7; ++i)\n    {\n        vec3 sundir = normalize(pos - (spheres_pos[i]));\n        \n        vec3 LightReflect  = normalize(reflect(sundir, nrm));\n        \n        str = max(str, dot(VertexToEye, LightReflect));\n       \n    }\n\n    float spec = IdToColor(id).w;\n    \n\tvec3 spc = pow(str, 30.0 * spec) * vec3(1.0, 1.0, 1.0);\n    \n    return spc;\n}\n\nvec3 Reflection(vec3 ray, vec3 pos, vec3 nrm, int surface_id)\n{  \n    vec3 reflected = reflect(ray, nrm);\n    \n    int matid;\n    int samples;\n    float prec;\n    vec3 hit = March(pos.xyz + nrm*0.01, reflected, matid, samples, prec);\n    \n    if (samples < 0)\n\t\treturn vec3(0, 0, 0);\n    \n    \n    return Diffuse(hit.xyz, matid);\n}\n\nvec3 Fog(vec3 pos)\n{\n    float distance = length(pos.xyz - v_cam_pos);\n\n\treturn max(0.0, exp(-distance * 0.01 )) * vec3(1.0, 1.0, 1.0);\n}\n\nmat3 CameraMatrix()\n{\n    float radius = 15.0;\n\n    float param = iTime * 0.3;\n    float height = 4.0;\n    \n    if (iMouse.z > 0.0)\n    {\n    \tparam = iMouse.x * 0.1;//obalTime * 0.3;\n    \theight = 1.0 + iMouse.y * 0.01;\n    \n    }\n\t\n    v_cam_pos.x = sin(param) * radius;\n    v_cam_pos.y = height;\n    v_cam_pos.z = cos(param) * radius;\n    \n    v_cam_forward = -normalize(v_cam_pos);\n    v_cam_forward.y = 0.0;\n    v_cam_forward = normalize(v_cam_forward);\n    \n    v_cam_forward = -normalize(v_cam_pos);\n    \n    v_cam_right   = cross(v_cam_forward, v_cam_up);\n \n    mat3 m;\n    m[0] = v_cam_right;\n    m[1] = v_cam_up;\n    m[2] = v_cam_forward;\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmat3 cam = CameraMatrix();\n    vec3 ray = ToRay(fragCoord, cam);\n    \n    vec3 pos;\n    vec3 nrm;\n    int matid;\n    int samples;\n    \n    SampleEnv(v_cam_pos, ray, pos, nrm, matid, samples);\n\n    vec4  mat = IdToColor(matid);\n    \n    vec3  dif = Diffuse(pos, matid);\n    vec3  spc = Specular(pos, nrm, matid);\n    vec3  rfl = Reflection(ray, pos, nrm, matid);\n    vec3  amb = AmbientLight();\n    vec3  sun = SunLight(nrm);\n    vec3  fog = Fog(pos);\n    float shd = AmbientOcclusion(float(samples)) * Shadow(pos);\n    \n    vec3 color = vec3(0.0);\n\n    color = (amb + dif + spc + rfl*mat.w) * shd * fog;\n    \n    fragColor.xyz = color;\n    \n    //fragColor.xyz = mat.xyz;\n   // fragColor.xyz = nrm * 0.5 + 0.5;\n    fragColor.w = 1.0;  \n    \n}","name":"Image","description":"","type":"image"}]}