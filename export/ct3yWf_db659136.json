{"ver":"0.1","info":{"id":"ct3yWf","date":"1699863627","viewed":39,"name":"形变动画","username":"to0th","description":"计算机动画作业\n课本上的公式：\nS(i) = 1 - pow(i/(n+1), k+1), k>=0\nS(i) = pow(1 - i/(n+1), -k+1), k<0","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int num_points = 6;//顶点个数\nint num_lines = 9;//边数\nbool[num_points*num_points] graph;//邻接矩阵\nint[num_points] weights;//距离拖拽点的最小相连边数\nint[num_points] visit_times;//顶点访问次数（出度+入度）\nint[num_points] degree;//顶点的度数\nint queue[100];\nint l = 0;\nint r = -1;\n\n//定义顶点\nvec2[] points = vec2[](\n    vec2(0.3,0),\n    vec2(0.,0.1),\n    vec2(0.,-0.1),\n    vec2(-0.4,0.3),\n    vec2(-0.5,0.),\n    vec2(-0.4,-0.3)\n);\n\n//偏移量的权重，就是公式中的S(i)\nfloat[] offsets = float[](\n    0., 0., 0., 0., 0., 0.\n);\n\n//定义线段的结构体（两个端点）\nstruct line{\n    int start_index;\n    int end_index;\n};\n\n//利用顶点下标定义线段\nline[] lines = line[](\n    line(0,1),\n    line(0,2),\n    line(1,2),\n    \n    line(1,3),\n    line(1,4),\n    line(2,4),\n    line(2,5),\n    \n    line(3,4),\n    line(4,5)\n);\n\n//初始化权重、度数、邻接矩阵\nvoid init(int start){\n    for(int i=0; i<num_points; i++){\n        weights[i] = 10000;\n        visit_times[i] = 0;\n        degree[i] = 0;\n    }\n    weights[start] = 0;\n    for(int i=0; i<num_points; i++){\n        for(int j=0; j<num_points; j++){\n            graph[i*num_points + j] = false;\n        }\n    }\n    for(int i=0; i<num_lines; i++){\n        line a = lines[i];\n        graph[a.start_index * num_points + a.end_index] = true;\n        graph[a.end_index * num_points + a.start_index] = true;\n        degree[a.start_index]++;\n        degree[a.end_index]++;\n    }\n}\n\n//广度优先搜索图，确定到选定点的最小边数\nvoid search(int start) {\n    queue[++r] = start;\n    while (l<=r)\n    {\n        int v = queue[l++];\n        for (int i = 0; i < num_points; i++) {\n            \n            if (graph[v*num_points+i]&&visit_times[i] < degree[i]) {\n                visit_times[i]++;\n                visit_times[v]++;\n                int w = weights[v] + 1;\n                weights[i] = weights[i] > w ? w : weights[i];\n                bool p = true;\n                for (int j = l; j <= r; j++) {\n                    if (queue[j] == i) { p = false; break; }\n                }\n                if(p)\n                    queue[++r] = i;\n            }\n        }\n    }\n}\n\n//生成每个顶点的S(i)值\nvoid generate_offset(int start, int k){\n    init(start);\n    search(start);\n    int n = -1;\n    for(int i=0;i<num_points;i++){\n        n = max(n, weights[i]);\n    }\n    for(int i=0;i<num_points;i++){\n        if(k >= 0)\n            offsets[i] = 1. - pow(float(weights[i])/float(n+1), float(k+1));\n        else\n            offsets[i] = pow(1. - float(weights[i])/float(n+1), float(-k+1));\n    }\n}\n\n//绘制线段\nfloat line_segment_with_two_point (vec2 st,vec2 start,vec2 end,float line_width){\n  vec2 line_vector_from_end = normalize(vec2(start.x,start.y) - vec2(end.x,end.y));//结束点指向起始点的向量\n  vec2 line_vector_from_start = -line_vector_from_end;//起始点指向结束点的向量\n  vec2 st_vector_from_end = st - vec2(end.x,end.y); //结束点指向画布中任意点的向量\n  vec2 st_vector_from_start = st - vec2(start.x,start.y);//起始点指向画布中任意点的向量\n\n  float proj1 = dot(line_vector_from_end,st_vector_from_end);\n  float proj2 = dot(line_vector_from_start,st_vector_from_start);\n\n  if(proj1>0.0&&proj2>0.0){//通过点乘结果>0判断是否同相，过滤掉线段两头超出部分\n\n    //求结束点指向画布中任意点的向量与结束点指向起始点的向量的夹角\n    float angle = acos(dot(line_vector_from_end,st_vector_from_end)/(length(st_vector_from_end)*length(line_vector_from_end)));\n    //屏幕上任意点到直线的垂直距离\n    float dist = sin(angle)*length(st_vector_from_end);\n\n    return pow(1.0-smoothstep(0.0,line_width/2.0,dist),6.0);\n  } else {\n    return 0.0;\n  }\n}\n\n//绘制线框多边形\nvec3 draw_polygons(vec2 st, vec3 line_color, vec3 color, float width){\n    float pct = step(0.02,st.y);\n    for(int i=0; i < num_lines; i++){\n        vec2 start = points[lines[i].start_index];\n        vec2 end = points[lines[i].end_index];\n        pct = line_segment_with_two_point(st,start,end,width);\n        color = mix(color,line_color,pct);\n    }\n    return color;\n}\n\n//控制拖拽动画\nvoid drag(vec2 dir){\n    float time = iTime;\n    while(time > 3.){\n        time -= 3.;\n    }\n    if(time < 1.5){\n        for(int i=0; i<num_points; i++){\n            points[i] += dir*time*offsets[i];\n        }\n    }else{\n        for(int i=0; i<num_points; i++){\n            points[i] += dir*(3.-time)*offsets[i];\n        }\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n    float pct = step(0.02,st.y);\n    vec3 line_color = vec3(1.0,1.0,0.0);\n    vec3 color = vec3(0.6);\n    \n    //例1\n    //拖动最右方的顶点移动\n    generate_offset(0, 0);//最右方的顶点下标为0，取k=0\n    drag(vec2(1.,0.));//拖拽方向为向上vec2(1.,0.)\n    \n    //例2\n    //拖动最上方的顶点移动\n    //generate_offset(3, -1);//最上方的顶点下标为3，取k=-1\n    //drag(vec2(0.,1.));//拖拽方向为向上vec2(0.,1.)\n    color = draw_polygons(st, line_color, color, 0.04);\n\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}