{"ver":"0.1","info":{"id":"ttf3RS","date":"1556725896","viewed":306,"name":"Stellated Dodecahedra","username":"fizzer","description":"The four stellations of the dodecahedron (only three shown here in the cycle, since we've all seen the original dodecahedron many times already).\nSee [url]https://en.wikipedia.org/wiki/List_of_Wenninger_polyhedron_models#Stellations_of_dodecahedron[/url].","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["dodecahedron","stellated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The four stellations of the dodecahedron:\n// https://en.wikipedia.org/wiki/List_of_Wenninger_polyhedron_models#Stellations_of_dodecahedron\n//\n// Note that here they are raytraced, not raymarched. So a bunch of rays can be traced in a pixel,\n// allowing here anti-aliasing, one shadow ray, and one specular reflection ray all summing to\n// a total of 12 rays per pixel.\n//\n\nconst float phi = (1. + sqrt(5.)) / 2.;\nconst float phi2 = phi + 1.; // == phiÂ²\nconst float pi = acos(-1.);\nconst float outerAngle = 2. * pi / 5.;\nconst float innerAngle = 3. * pi / 5.;\n\n// Pentagram shape mask\nfloat pentagram(vec2 p, float incircleRadius, float rot)\n{\n    float r = incircleRadius / cos(outerAngle / 2.);\n    float edgeLength = sin(outerAngle / 2.) * r;\n    float r2 = incircleRadius + edgeLength / tan(innerAngle - pi / 2.);\n\n    float a = -(floor((atan(p.y, p.x) - outerAngle / 4. + rot) / outerAngle) + .5) * outerAngle - outerAngle / 4. + rot;\n\n    p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p;\n    p.y = abs(p.y);\n\n    return step(p.x, mix(r2, incircleRadius, p.y / edgeLength));\n}\n\n// A stellated pentagon mask, which forms the polygonal face of one of the sides of\n// a stellated dodecahedron. Note that the inner part is solid, but in the case of the \n// dodecahedron this is never visible anyway.\nfloat stellatedPentagon(vec2 p, float incircleRadius, int stellation)\n{\n    float r = incircleRadius / cos(outerAngle / 2.);\n    float edgeLength = sin(outerAngle / 2.) * r;\n    float r2 = incircleRadius + edgeLength / tan(innerAngle - pi / 2.);\n    float incircleRadius2 = r2 * cos(outerAngle / 2.);\n\n    if(stellation == 3)\n        return pentagram(p, incircleRadius2, -outerAngle / 2.);\n\n    if(stellation == 2)\n        p.y =- p.y;\n\n    float a = -(floor((atan(p.y, p.x) - outerAngle / 4.) / outerAngle) + .5) * outerAngle - outerAngle / 4.;\n\n    p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p;\n\n    if(stellation == 0)\n        return step(p.x, incircleRadius);\n\n    if(stellation == 1)\n        return step(p.x, mix(r2, incircleRadius, abs(p.y) / edgeLength));\n\n    if(stellation == 2)\n        return step(p.x, incircleRadius2);\n}\n\n\nfloat intersectStellatedDodecahedron(vec3 ro, vec3 rd, inout vec3 nearN, out mat2x3 nearST, int stellation)\n{\n    // Points of initial pentagonal face\n    vec3 a = vec3(+.5, 0, phi2 / 2.);\n    vec3 b = vec3(-.5, 0, phi2 / 2.);\n    vec3 c = vec3(0, phi2 / 2., + .5);\n    vec3 d = vec3(-1, 1, 1) * phi / 2.;\n    vec3 e = vec3(+1, 1, 1) * phi / 2.;\n\n    // Make the great stellated dodecahedron smaller, for the sake of visualisation\n    if(stellation == 3)\n    {\n        ro *= 2.;\n        rd *= 2.;\n    }\n    \n    vec3 faceCentre = (a + b + c + d + e) / 5.;\n\n    float incircleRadius = cos(outerAngle / 2.) * distance(a, faceCentre);\n\n    float invFaceHeight = 1. / (incircleRadius  + incircleRadius  / cos(outerAngle / 2.));\n\n    float nearT = 1e4;\n    bool hit = false;\n\n    nearN = vec3(0);\n    nearST = mat2x3(vec3(0), vec3(0));\n\n    // The dodecahedron can be formed by 6 intersected slabs, much like how a parallelipiped\n    // can be formed by 3 intersected slabs. In fact the dodecahedron can be formed\n    // by 2 intersected parallelipipeds, and that's what I did here.\n    \n    for(int j = 0; j < 2; ++j)\n    {\n        for(int i = 0; i < 3; ++i)\n        {\n            vec3 faceCentre = (a + b + c + d + e) / 5.;\n\n            // Intersect ray with the near plane of this slab\n            \n            vec3 n = cross(c - a, b - a);\n            float w = dot(n, a);\n\n            float dp = dot(rd, n);\n            float si = -sign(dp);\n\n            float t0 = (w * si - dot(ro, n)) / dp;\n\n            vec3 rp = ro + rd * t0;\n\n            // Make a tangent coordinate system for this face. This is used to\n            // get UV coordinates for the polygon mask, and it's also used later for shading\n            \n            vec3 mvec = normalize(faceCentre);\n            vec3 s = b - a;\n            vec3 t = (c - (a + b) / 2.) * invFaceHeight * si;   \n            vec2 uv = vec2(dot(rp - mvec, s), dot(rp - mvec, t));\n\n            // Do a depth test and point-in-polygon test using the mask for the chosen\n            // face polygon type\n            \n            if(t0 > 1e-4 && t0 < nearT && stellatedPentagon(uv, incircleRadius, stellation) > .5)\n            {\n                nearT = t0;\n                nearN = n * si;\n                nearST = mat2x3(s, t);\n                hit = true;\n            }\n\n            // Rotate the pentagonal face so it lies in the plane of the next face\n            // of the parallelipiped.\n            \n            a = a.yzx;\n            b = b.yzx;\n            c = c.yzx;\n            d = d.yzx;\n            e = e.yzx;\n        }\n        \n        // The next parallelipiped is mirrored in the Y axis\n        \n        a.x = -a.x;\n        b.x = -b.x;\n        c.y = -c.y;\n        d.y = -d.y;\n        e.y = -e.y;\n    }\n\n    if(hit)\n    {\n        // An intersection was found\n        nearN = normalize(nearN);\n        return nearT;\n    }\n\n    return -1.;\n}\n\nfloat trace(vec3 ro, vec3 rd, out vec3 nearN, out mat2x3 nearST, int stellation)\n{\n    return intersectStellatedDodecahedron(ro, rd, nearN, nearST, stellation);\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nvec4 render(vec2 fragCoord)\n{    \n    // Set up primary ray, including ray differentials\n    \n    vec2 p = fragCoord / iResolution.xy * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0, -0, 5.7), rd = vec3(p, -2.);\n\n    vec3 rdx = rd + dFdx(rd);\n    vec3 rdy = rd + dFdy(rd);\n    \n    vec3 ld = normalize(vec3(1,1.5,.9));\n\n    // Rotation transformation\n    \n    mat3 m = rotX(iTime / 4.) * rotY(iTime / 3.);\n\n    ro = m * ro;\n    rd = m * rd;\n    rdx = m * rdx;\n    rdy = m * rdy;\n    ld = m * ld;\n\n    vec3 nearN;\n    mat2x3 nearST;\n\n    // Alpha for shape transition\n    \n    float time = iTime + 1.;\n    float phaseLength = 7.;\n    float transitionLength = .2;\n    float alpha = smoothstep(0., transitionLength, phaseLength / 2. - abs(mod(time, phaseLength) - phaseLength / 2.));\n\n    int stellation = 1 + (int(floor(time / phaseLength)) % 3);\n\n    // Trace primary ray\n    float t0 = trace(ro, rd, nearN, nearST, stellation);\n\n    if(t0 < 0.)\n        return vec4(0);\n    \n    vec4 fragColor = vec4(0);\n\n    // Get intersection points and pixel footprint\n    vec3 rp = ro + rd * t0;        \n    vec2 uv = vec2(dot(nearST[0], rp), dot(nearST[1], rp));\n\n    vec3 rpx = ro + rdx * dot(rp - ro, nearN) / dot(rdx, nearN);        \n    vec2 uvx = vec2(dot(nearST[0], rpx), dot(nearST[1], rpx));\n\n    vec3 rpy = ro + rdy * dot(rp - ro, nearN) / dot(rdy, nearN);         \n    vec2 uvy = vec2(dot(nearST[0], rpy), dot(nearST[1], rpy));\n\n    float uvscale = .5;\n\n    // MIP level from footprint\n    float lod = log2(max(length(uvx - uv), length(uvy - uv)) * 256. * uvscale);\n\n    float ao = 1.;\n\n    vec3 r = reflect(rd, nearN);\n\n    // Some AO term\n    if(stellation == 1)\n        ao = smoothstep(1., 2., length(rp));\n    if(stellation == 2)\n        ao = smoothstep(1.1, 3., length(rp));\n    if(stellation == 3)\n        ao = smoothstep(.5, 2.2, length(rp));\n\n    vec3 key = vec3(max(0., dot(nearN, ld))) * 1.3 * mix(.5, 1., ao);\n\n    vec3 dummy;\n\n    // Trace shadow ray for key light\n    if(trace(rp, ld, dummy, nearST, stellation) > -1.)\n        key *= 0.;\n\n    vec3 fill = vec3(.35) * ao * mix(.5, 1., (.5 + .5 * (transpose(m) * nearN).y));\n\n    float fresnel = mix(.2, .9, pow(clamp(1. - dot(-rd, nearN), 0., 1.), 2.));\n\n    vec3 refl = textureLod(iChannel1, r, 1.).rgb;\n\n    // Trace reflection ray\n    if(trace(rp, r, dummy, nearST, stellation) > -1.)\n        refl *= .0;\n\n    vec3 albedo = textureLod(iChannel0, uv * uvscale, lod).rgb;\n\n    fragColor.rgb = mix(vec3(1), albedo, .9) * (key + fill);\n\n    // Apply reflection with some gloss map\n    fragColor.rgb = mix(fragColor.rgb, refl, clamp(fresnel * pow(max(0., albedo.b), 5.) * 3., 0., 1.));\n\n    fragColor.a = alpha;\n\n\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    vec3 backg = vec3(.07);\n\n    // Anti-aliasing loop\n    \n    for(int y = 0; y < 2; ++y)\n        for(int x = 0; x < 2; ++x)\n        {\n            vec4 r = render(fragCoord + vec2(x,y) / 2.);\n            r.rgb = mix(backg, r.rgb, r.a);\n            fragColor.rgb += clamp(r.rgb, 0., 1.);\n        }\n\n    fragColor /= 4.;\n\n    // Gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n    fragColor.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"}]}