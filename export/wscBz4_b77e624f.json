{"ver":"0.1","info":{"id":"wscBz4","date":"1604450609","viewed":70,"name":"RIOW - 11 - Camera","username":"TheMunro","description":"https://raytracing.github.io/books/RayTracingInOneWeekend.html#positionablecamera","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    //divide by the number of samples (w component = sum of samples = 2 in this case)\n    //take square root to gamma correct\n    fragColor = vec4(sqrt(data.rgb/data.w), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AA 1\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\nconst int MAX_OBJECTS = 10;\nconst int MAX_ITERATIONS = 100;\n\n//functions\nvec4 get_vector(in sampler2D channel, ivec2 uv) \n{\n    return texelFetch(channel, uv, 0);\n}\n\nvec3 random_in_unit_sphere()\n{\n    //https://stackoverflow.com/questions/5408276/sampling-uniformly-distributed-random-points-inside-a-spherical-volume\n    //can probably simplify this with trig identities\n    vec3 rnd = hash_3d(seed) * vec3(tau, 2., 1.) - vec3(0., 1., 0.);\n        \n    float phi = rnd.x;\n    float theta = acos(rnd.y);\n    float r = pow(rnd.z, 1./3.);   \n        \n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n                            \n    return vec3(x, y, z);\n}\n\nvec2 random_in_unit_circle()\n{\n    //https://stackoverflow.com/questions/5837572/generate-a-random-point-within-a-circle-uniformly\n    vec2 rnd = hash_2d(seed);\n        \n    float r = rnd.x == 0.0 ? 0.0 : sqrt(rnd.x);\n\tfloat theta = 2.0 * pi *  rnd.y;\n        \n    float x = r * cos(theta);\n\tfloat y = r * sin(theta);\n                            \n    return vec2(x, y);\n}\n\n//vec3 reflect(in vec3 v, in vec3 n)\n//{\n//    return v - 2.*dot(v,n)*n;\n//}\n\n//vec3 refract(in vec3 i, in vec3 n, in float refraction_ratio) \n//{\n//    float c_theta = min(dot(-i, n), 1.);\n//    vec3 perpendicular = refraction_ratio * (i + c_theta * n);\n//    vec3 parallel = -sqrt(abs(1. - dot(perpendicular, perpendicular))) * n;\n//    return perpendicular + parallel;\n//}\n\n////lambertian distribution\n//vec3 random_in_unit_sphere()\n//{\n//    vec2 r.direction = hash_2d(seed) * vec2(tau, 2.) - vec2(0., 1.);\n//        \n//    float a = r.direction.x;\n//    float z = r.direction.y;\n//    float r = sqrt(1. - z*z);   \n//                          \n//    return vec3(r*cos(a), r*sin(a), z);\n//}\n\nfloat schlick_approximation(in float cosine, in float ratio)\n{\n    float r0 = (1.-ratio) / (1.+ratio);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow(1.-cosine, 5.);\n}\n\nbool lambertian_scatter(in Ray r, in HitRecord rec, out vec3 attenuation, out Ray scattered)\n{\n    vec3 scatter_direction = normalize(rec.normal + random_in_unit_sphere());\n    if (length(scatter_direction) < 1e-8)\n        scatter_direction = rec.normal;\n    \n    scattered = Ray(rec.p, scatter_direction);\n    attenuation = rec.mat.albedo;    \n    return true;\n}\n\nbool metal_scatter(in Ray r, in HitRecord rec, out vec3 attenuation, out Ray scattered)\n{\n    vec3 reflected = reflect(normalize(r.direction), rec.normal);\n    float shininess = 1. - clamp(rec.mat.value, 0., 1.);\n    vec3 direction = normalize(reflected + shininess * random_in_unit_sphere());\n    scattered = Ray(rec.p, direction);\n    attenuation = rec.mat.albedo;   \n\n    return dot(scattered.direction, rec.normal) > 0.;\n}\n\nbool dielectric_scatter(in Ray r, in HitRecord rec, out vec3 attenuation, out Ray scattered)\n{\n   attenuation = one;\n   float refraction_ratio = rec.front_face ? (1. / rec.mat.value) : rec.mat.value;\n   \n   vec3 d_n = normalize(r.direction);\n   float cos_theta = min(dot(-d_n, (rec.normal)), 1.0);\n   float sin_theta = sqrt(1. - cos_theta*cos_theta);\n   \n   vec3 dir;\n   bool cannot_refract = sin_theta * refraction_ratio >= 1.;\n   \n  \n   //dir = refract(d_n, rec.normal, refraction_ratio);\n       \n    if(cannot_refract || schlick_approximation(cos_theta, refraction_ratio) > hash_1d(seed))\n    {\n        dir = reflect(d_n, rec.normal);\n        \n        //https://github.com/RayTracing/raytracing.github.io/issues/713\n        //this doesn't work, leaves a black outline\n        //scattered = Ray(rec.p, dir);\n            \n        //this does work\n    \tscattered = Ray(r.origin, dir); \n    }\n    else\n    {\n        dir = refract(d_n, rec.normal, refraction_ratio);\n    \tscattered = Ray(rec.p, dir); \n    }\n    \n    return true;\n}\n\nbool scatter(in Ray r, in HitRecord rec, out vec3 attenuation, out Ray scattered)\n{\n    if(rec.mat.type == LAMBERTIAN)\n    {\n        return lambertian_scatter(r, rec, attenuation, scattered);\n    }\n    \n    if(rec.mat.type == METAL)\n    {\n        return metal_scatter(r, rec, attenuation, scattered);\n    }\n    \n    if(rec.mat.type == DIELECTRIC)\n    {\n        return dielectric_scatter(r, rec, attenuation, scattered);\n    }\n    \n    return false;\n}\n\nbool compute_hit(in Sphere s, in Ray r, in float t, in float t_min, in float t_max, out HitRecord rec)\n{\n    if(t < t_max && t > t_min) \n    {\n        rec.t = t;\n        rec.p = r.direction * t + r.origin;\n        rec.normal = (rec.p - s.centre) / s.radius;\n        rec.front_face = dot(rec.normal, r.direction) < 0.;\n        rec.normal = rec.front_face ? rec.normal : -rec.normal;\n        rec.mat = s.mat;\n        return true;\n    }\n    \n    return false;\n}\n\nbool hit_sphere(in Sphere s, in Ray r, in float t_min, in float t_max, out HitRecord rec)\n{\n    //quadratic solution to sphere-line intersection\n    //N.B. 0/1/2 solutions all possible solutions\n    //0 in complex case\n    //1 in tangent case\n    //2 in full sphere intersection case\n    \n    //vector from ray origin to sphere centre\n    vec3 oc = r.origin - s.centre;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius*s.radius;\n    \n    float discriminant = half_b*half_b - a*c;\n        \n    if(discriminant < 0.)\n        return false;\n    \n    float t;\n    //closest intersection point calculation\n    t = (-half_b - sqrt(discriminant)) / a;\n    if(compute_hit(s, r, t, t_min, t_max, rec)) \n        return true;\n    \n    //farthest intersection point calculation\n    t = (-half_b + sqrt(discriminant)) / a;\n    if(compute_hit(s, r, t, t_min, t_max, rec)) \n        return true;\n\n    return false;\n}  \n\nbool world_hit(in Ray r, in float t_min, in float t_max, out HitRecord rec) \n{\n    //fix spheres\n    HitRecord temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    const Sphere sphere0 = Sphere(vec3(0.0, -100.5, 0.0), 100.0,               \n                                  Material(LAMBERTIAN, vec3(0.8, 0.8, 0.0), 1.));\n    \n    const Sphere sphere1 = Sphere(vec3(0.0, 0.025, 0.0), 0.5,             \n                                  Material(DIELECTRIC, vec3(1.0, 1.0, 1.0), 1.5));\n    \n    const Sphere sphere2 = Sphere(vec3(0.0, 0.025, 0.0), -0.4,            \n                                  Material(DIELECTRIC, vec3(1.0, 1.0, 1.0), 1.5));\n    \n    const Sphere sphere3 = Sphere(vec3(-1.1, 0.0, 0.0), 0.5,    \n                                  Material(LAMBERTIAN, vec3(0.8, 0.8, 0.8), 1.0));\n    \n    const Sphere sphere4 = Sphere(vec3(1.1, 0.0, 0.0), 0.5,     \n                                  Material(METAL, vec3(0.8, 0.6, 0.2), 0.975));\n    \n    const Sphere sphere5 = Sphere(vec3(-1.0, 0.2, -1.5), 0.7,   \n                                  Material(LAMBERTIAN, vec3(0.3, 1.0, 0.8), 1.0));\n    \n    const Sphere sphere6 = Sphere(vec3(-0.4, -0.3, 0.5), 0.2,    \n                                  Material(DIELECTRIC, vec3(1.0, 1.0, 1.0), 1.5));\n    \n    const Sphere sphere7 = Sphere(vec3(0.2, -0.4, 0.4), 0.1,    \n                                  Material(DIELECTRIC, vec3(1.0, 1.0, 1.0), 1.5));\n    \n    const Sphere sphere8 = Sphere(vec3(0.7, -0.2, -0.75), 0.3,     \n                                  Material(METAL, vec3(0.9, 0.4, 0.6), 0.7));\n    \n    const Sphere sphere9 = Sphere(vec3(0.4, -0.3, 0.6), 0.2,     \n                                  Material(METAL, vec3(0.4, 0.7, 1.0), 1.0));\n    \n    Sphere[MAX_OBJECTS] s = Sphere[](sphere0, sphere1, sphere2, sphere3, \n                                     sphere4, sphere5, sphere6, sphere7, \n                                     sphere8, sphere9);\n\n\n    //checks each intersectable object for hit, updates rec if closer\n    for(int i = 0; i < MAX_OBJECTS; i++) \n    {\n        if(hit_sphere(s[i], r, t_min, t_max, temp_rec)) \n        {\n            if(temp_rec.t < closest_so_far) \n            {\n                hit_anything = true;\n                closest_so_far = temp_rec.t;\n                rec = temp_rec;\n            }\n        }\n    }\n    \n    return hit_anything;\n}\n\n\nvec3 trace_ray(in Ray r)\n{\n    HitRecord rec;\n    vec3 col = one;\n    bool hit;\n    \n    for(int i = 0; i <= MAX_ITERATIONS; i++)\n    {\n        if(i == MAX_ITERATIONS)\n            return vec3(0.);\n        \n        if(world_hit(r, near, far, rec)) \n        {\n            Ray scattered;\n            vec3 attenuation;\n            if(scatter(r, rec, attenuation, scattered))\n            {\n                col *= attenuation;\n                r = scattered; \n                hit = true;\n            }\n        }\n        else \n        {\n            float t = 0.5 * (r.direction.y + 1.);\n            return col *= mix(one, vec3(0.5, 0.7, 1.), t);\n        }\n    } \n    \n    return col;\n}\n\n\nCamera get_camera(float h_fov, vec3 origin, vec3 direction, vec3 up) \n{\n    Camera camera;\n    \n    camera.h_fov = tan(h_fov/2.);\n    camera.rotation = get_camera_matrix(direction, up);\n    camera.origin = origin;\n    return camera;    \n}\n\nRay get_camera_ray(Camera camera, vec2 uv)\n{\n    vec3 rnd = vec3(camera.lens_radius * random_in_unit_circle(), 0);\n    vec3 offset = vec3(uv, 0) * rnd;\n    \n    vec3 direction = camera.rotation * vec3(uv * camera.h_fov, 1);\n    return Ray(camera.origin + offset, direction);\n}\n\n//output\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{    \n    vec2 resolution = get_vector(iChannel1, RESOLUTION).xy;\n    bool reset = get_vector(iChannel1, RESET).x > 0.0;\n    vec3 origin = get_vector(iChannel1, POSITION).xyz;\n    vec3 direction = get_vector(iChannel1, DIRECTION).xyz;\n    \n    vec3 col;\n    seed = hash_2d(fragCoord + iTime);\n    \n#if AA>1\n    for(int m = 0; m < AA; m++)\n    for(int n = 0; n < AA; n++)\n    {\n        vec2 uv = (2. * fragCoord.xy - iResolution.xy + vec2(float(m),float(n))/float(AA) + hash_2d(seed))/iResolution.y;\n#else      \n        vec2 uv = (2. * fragCoord.xy - iResolution.xy + hash_2d(seed))/iResolution.y;\n#endif\n        \n        //position \n        float fov = radians(20.);\n        Camera camera = get_camera(fov, origin, direction, up);\n        Ray r = get_camera_ray(camera, uv);\n        \n        //this is affecting output colour somehow...\n        col += trace_ray(r);\n        \n#if AA>1\n    }\n    col /= float(AA * AA);\n#endif\n\n    if (reset) {    \n        fragColor = vec4(col,1);\n    } else {    \n    \tfragColor = vec4(col,1) + get_vector(iChannel0, ivec2(fragCoord));    \n    }\n}","name":"Buffer @","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//constants\nvec3 zero = vec3(0., 0., 0.);\nvec3 one = vec3(1., 1., 1.);\nvec3 up = vec3(0., 1., 0.);\nvec2 seed;\n\nfloat pi =  3.141592653;\nfloat tau = 6.283185307;\n\nfloat near = 0.0001;\nfloat far = 1e20;\n//wherever you are...\n\nconst ivec2 RESOLUTION = ivec2(0, 0);\nconst ivec2 RESET = ivec2(0, 1);\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 DIRECTION = ivec2(1, 1);\nconst ivec2 MOUSE = ivec2(2, 1);\n\n//data types\nstruct Ray\n{ \n    vec3 origin; \n    vec3 direction;\n};\n       \nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float value; //smoothness when metal, refractive index when dielectric\n};\n    \nstruct Sphere\n{ \n    vec3 centre; \n    float radius;\n    Material mat;\n};\n\nstruct HitRecord\n{\n    vec3 p;\n    vec3 normal;\n    float t;\n    bool front_face;\n    Material mat;\n};\n    \n//could've use a mat4 here, but it felt better to split rotation from translation\n//since Ray is split into direction and origin already\nstruct Camera\n{\n    mat3 rotation;\n    vec3 origin;\n    float h_fov;\n    float lens_radius;\n    float focus_distance;    \n};\n    \nmat3 get_camera_matrix(vec3 direction, vec3 up) \n{\n    mat3 matrix;\n    \n    vec3 w = normalize(direction);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    matrix[0] = u;\n    matrix[1] = v;\n    matrix[2] = w;\n    \n    return matrix;    \n}\n\n\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n\nuint base_hash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash_1d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash_2d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash_3d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash_4d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}  \n\nfloat hrand(in vec2 coord) \n{\n    uint hashed_coord = base_hash(floatBitsToUint(coord));\n    return float(hashed_coord)/float(0xFFFFFFFFU);  \n}\n\nfloat length_squared(vec3 v)\n{\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\n// other\nfloat nrand(in vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//camera\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_Q = 81;\nconst int KEY_E = 69;\n\nstruct Inputs\n{\n    vec3 movement;\n    vec2 mouse;\n    float dt;\n    bool button;\n};\n    \n\n//read raw data from keyboard texture\nfloat key(in sampler2D channel, in int keycode)\n{\n    return step(.5, texelFetch(channel, ivec2(keycode, 0), 0).x);\n}\n\n//read normalised data from buffer a texture\nvec4 get_vector(in sampler2D channel, ivec2 uv) \n{\n    return texelFetch(channel, uv, 0);\n}\n\nvoid LoadInputs(out Inputs inputs)\n{\n    inputs.button = iMouse.z >= 0.;\n    inputs.mouse = iMouse.xy;\n    inputs.dt = iTimeDelta;\n\n    float x = key(iChannel3, KEY_D) - key(iChannel3, KEY_A);\n    float y = key(iChannel3, KEY_Q) - key(iChannel3, KEY_E);\n    float z = key(iChannel3, KEY_W) - key(iChannel3, KEY_S);\n    \n    inputs.movement = vec3(x, y, z);\n}\n\nmat3 rotation_matrix(vec2 delta) \n{  \n    delta.x = -delta.x;\n    float c_x = cos(delta.y);\n    float c_y = cos(delta.x);\n    float s_x = sin(delta.y);\n    float s_y = sin(delta.x);\n    \n    vec3 u = vec3(c_y, s_x * s_y, s_y * c_x);\n    vec3 v = vec3(0, c_x, -s_x);\n    vec3 w = vec3(-s_y, s_x * c_y, c_y * c_x);\n    \n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool reset = false;\n    vec2 resolution = get_vector(iChannel1, RESOLUTION).xy;\n    vec4 last_mouse = get_vector(iChannel1, MOUSE);\n    vec3 position = get_vector(iChannel1, POSITION).xyz;\n    vec3 direction = normalize(get_vector(iChannel1, DIRECTION).xyz);\n         \n    if(any(notEqual(iResolution.xy, resolution)))\n        reset = true;\n    \n    if (reset || iTime == 0.0 || iFrame == 0)\n    {        \n        if(all(equal(ivec2(fragCoord), RESOLUTION)))\n        \tfragColor = vec4(iResolution.xy, 0, 0);\n    \n        if(all(equal(ivec2(fragCoord), MOUSE))) \n            fragColor = vec4(0);\n\n        if(all(equal(ivec2(fragCoord), RESET)))\n            fragColor = vec4(true, 0, 0, 0);\n        \n      \tif(all(equal(ivec2(fragCoord), POSITION))) \n\t    \tfragColor = vec4(0, 5, -5, 0);  \n        \n      \tif(all(equal(ivec2(fragCoord), DIRECTION))) \n\t    \tfragColor = vec4(0, -0.7071, 0.7071, 0);  \n\n        return;\n    }\n    \n    Inputs inputs;\n    LoadInputs(inputs);\n    \n    mat3 matrix = get_camera_matrix(direction, up);\n    \n    if(inputs.button)\n    {\n    \tvec2 difference = last_mouse.z > 0. ? (iMouse.xy - last_mouse.xy) : vec2(0);\n        direction = (matrix * rotation_matrix(difference * 0.1 * iTimeDelta))[2];\n        \n        reset = true;\n    }\n    \n    position += matrix * inputs.movement * 0.1;\n    last_mouse = iMouse;\n    \n    if(dot(inputs.movement, inputs.movement) > 0.) \n        reset = true;\n    \n\tif(all(equal(ivec2(fragCoord), RESOLUTION)))\n        fragColor = vec4(resolution, 0, 0);\n    \n\tif(all(equal(ivec2(fragCoord), MOUSE))) \n\t    fragColor = vec4(last_mouse);\n    \n\tif(all(equal(ivec2(fragCoord), RESET)))\n        fragColor = vec4(reset, 0, 0, 0);\n\t\n\tif(all(equal(ivec2(fragCoord), POSITION))) \n\t    fragColor = vec4(position, 0);\n\t\n\tif(all(equal(ivec2(fragCoord), DIRECTION))) \n\t    fragColor = vec4(direction, 0);\n}","name":"Buffer @","description":"","type":"buffer"}]}