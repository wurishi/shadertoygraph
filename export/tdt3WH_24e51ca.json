{"ver":"0.1","info":{"id":"tdt3WH","date":"1568447872","viewed":666,"name":"Julia4D","username":"senzheng","description":"Julia Set Based on Quaternion.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Julia 4D\n\n  - Created by SEN ZHENG - 2019/09/14\n  - Jsut enjoy it.\n  - Respect to inigo quilez.I learned a lot from iq's blog and codes.\n*/\n\n#define MAX_RAYMARCHING_COUNT 320\n#define PRECISION 0.0001\n#define FAR 6.\n#define mouse (iMouse.xy / iResolution.xy)\n#define time iTime\n\nvec3 juliaCXYZ = vec3(0.088, 0.733, 0.722);\nint juliaIterations = 12;\n\n// quaternion \nvec4 qln(vec4 a) {\n    float r = sqrt(a.w*a.w + a.y*a.y + a.z*a.z);\n    float t = r > 0.00001 ? atan(r, a.x)/r : 0.0;\n    return vec4(0.5*log(dot(a, a)),\n                a.y * t,\n                a.z * t,\n                a.w * t);\n}\nvec4 qexp(vec4 a) {\n    float r = sqrt(a.w*a.w + a.y*a.y + a.z*a.z);\n    float et = exp(a.x);\n    float s = r >= 0.00001 ? et*sin(r)/r : 0.0;\n    return vec4(et*cos(r),\n                a.y * s,\n                a.z * s,\n                a.w * s);\n}\nvec4 qpow(vec4 a, float n) {\n    return qexp(n*qln(a));\n}\nvec4 qmul(vec4 b, vec4 a) {\n    return vec4(a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w,\n                a.y*b.x + a.x*b.y - a.w*b.z + a.z*b.w,\n                a.z*b.x + a.w*b.y + a.x*b.z - a.y*b.w,\n                a.w*b.x - a.z*b.y + a.y*b.z + a.x*b.w);\n}\n\nHit julia(vec3 p) {\n    float globalScale =  0.7;\n    p /= globalScale;\n    p.zy = rotate(p.zy, time*0.5);\n    p.x *= .4;\n    \n    float Power = 6.0 + sin(time*0.6)*2.0;\n    vec4 z = vec4(p, 0.0);\n    vec4 zderiv = vec4(1.0);\n    float dr = 1.0;\n    float r = dot(z, z);\n    vec4 offsetC = vec4(juliaCXYZ + vec3(sin(time*0.3 + PI),cos(time*0.6+PI),cos(time*0.1 + PI))*0.1, 0.0);\n    int i = 0;\n    for (; i < juliaIterations ; i++) {\n        r = dot(z, z);\n        if (r>20.0) break;\n        zderiv = qmul(offsetC,zderiv) - qmul(qmul(Power*offsetC, qpow(z, Power-1.0)),zderiv);\n        dr = dot(zderiv,zderiv);\n        z = qmul(offsetC, (z - qpow(z, Power)));\n    }\n    r = sqrt(r);\n    dr = sqrt(dr);\n    float d = 0.5*log(r)*r/dr*globalScale;\n    \n    float uv = pow(float(i)/float(juliaIterations), 6.0);\n    vec3 col0 = vec3(0.27, 0.3, 0.32);\n    vec3 col1 = vec3(1.0, 0.4, 0.2);\n    vec3 col = mix(col0, col1, uv);\n    \n    return Hit(d, vec2(uv), col, (1.0-uv)*0.0, 1.0-uv, 0.0, d, vec3(0), 0.0);\n}\n\nHit map2(vec3 p) {\n    Hit res = julia(p);\n    return res;\n}\n\n\nvec3 calcuNormal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n    return normalize(e.yxx*map2(p + e.yxx).d + e.xxy*map2(p + e.xxy).d + \n                     e.xyx*map2(p + e.xyx).d + e.yyy*map2(p + e.yyy).d );   \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map2( ro + rd*t ).d;\n        res = min( res, 5.0*h/t );\n        t += clamp( h, 0.02, 0.2 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map2( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec4 render(vec3 ro, vec3 rd, vec2 samplepos) {\n    Hit hitdata;\n    float t = 0.0;\n    float told = t, mid, dn;\n    float d = map2(rd*t + ro).d;\n    float sgn = sign(d);\n\n    if (sgn < 0.0) return vec4(0);\n    \n    vec3 col = vec3(1.0, 0.0, 0.0);\n    \n    vec3 bgCol = pow(vec3(max(0.0, dot(rd, -normalize(ro))))*0.5, vec3(1.8)) * vec3(1.0, 1.05, 1.15);\n    //bgCol = texture( iChannel0, rd ).xyz;\n    \n    // light source\n    vec3 lp = vec3(ro.x, 3.0, ro.z);\n    \n    float forwardstep = FAR / float(MAX_RAYMARCHING_COUNT);\n    \n    for (int i = 0 ; i < MAX_RAYMARCHING_COUNT ; i++) {\n        \n        vec3 sp = ro + rd*t;\n        vec3 sundir = lp - sp;\n        float sundist = length(sundir);\n        vec3 ld = normalize(sundir);\n        \n        hitdata = map2(rd*t + ro);\n        d = hitdata.d;\n        \n        if (sign(d) != sgn || d < PRECISION) {\n        \n            // The code below is useful for those sdf function that may return Negative Distance.\n            // But in this scene, Julia(also Mandelbulb) always return Positive Distance, so I just comment them.\n            \n            /*if (sign(d) != sgn) {\n                hitdata = map2(rd*told + ro);\n                dn = sign(hitdata.d);\n                vec2 iv = vec2(told, t);\n                \n                for (int j = 0 ; j < 8 ; j++) {\n                    mid = dot(iv, vec2(.5));\n                    hitdata = map2(rd*mid + ro);\n                    d = hitdata.d;\n                    if (abs(d) < PRECISION) break;\n                    iv = mix(vec2(iv.x, mid), vec2(mid, iv.y),step(0.0, d*dn));\n                }\n                t = mid;\n            }*/\n            \n            vec3 nor = normalize(calcuNormal(sp));\n            float shd = calcSoftshadow( sp, ld, 0.02, FAR );\n            float occ = calcAO( sp, nor );\n            \n            vec3 hal = normalize( lp - rd );\n            float amb = clamp( 0.3+ 0.7*nor.y, 0.0, 1.0 );\n            float dif = max( dot( ld, nor ), 0.0);\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 32.0)*dif;\n            float bac = clamp( dot( nor, normalize(vec3(lp.x,-lp.y,lp.z))), 0.0, 1.0 );\n            \n            // surface color\n            col = hitdata.col;\n            \n            vec3 lin = vec3(2.) * dif * shd;\n            lin += 0.3*amb*vec3(1)*occ;\n            lin += 0.3*bac*vec3(1)*occ;\n            lin += hitdata.spe*spe*vec3(1.2);//*occ;\n            col *= lin;\n            \n            // reflect\n            vec3 r = reflect(rd, nor);\n    \t\tcol += texture( iChannel0, r ).xyz * hitdata.ref;\n            \n            //col = mix(col, bgCol, smoothstep(0.5, FAR, t));\n\n            break;\n        } else if (t >= FAR || i+1 == MAX_RAYMARCHING_COUNT) {\n            col = bgCol;\n            break;\n        }\n        \n        told = t;\n        t += d;\n        t = min(FAR, t);\n    }\n    col = pow(col, vec3(1.2));\n    \n    return vec4(col, t);\n}\n\nmat3 setCamera(vec3 ro, vec3 lookAt, vec3 cp) {\n    vec3 cw = normalize(lookAt-ro);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    float dist = 2.2;\n    vec3 ro = vec3(sin(time*0.5)*dist, 0.0, cos(time*0.5)*dist);\n    vec3 lookAt = vec3(0.0);\n    vec3 camup = vec3(0.0, 1.0, 0.0);\n    mat3 viewMat = setCamera(ro, lookAt, camup);\n    \n    vec3 rd = viewMat * normalize(vec3(p, 1.));\n    vec4 col = render( ro, rd, p );\n\n    fragColor = vec4(col.rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n\nstruct Hit {\n    float d;\n    vec2 uv;\n    vec3 col;\n    float ref;\n    float spe;\n    float rough;\n    float lightD;\n    vec3 lightCol;\n    float lightStrength;\n};\n    \nvec2 rotate(vec2 v, float a) {\n    return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n","name":"Common","description":"","type":"common"}]}