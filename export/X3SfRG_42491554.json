{"ver":"0.1","info":{"id":"X3SfRG","date":"1729571699","viewed":19,"name":"Null2","username":"shigel","description":"null2 shader video","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["null2","digitalnature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAdvanced Shader by ChatGPT\nRealistic, multi-layered, colorful, and shiny moving waves with advanced lighting and post-processing effects.\n*/\n\n#define PI 3.14159265359\n\n// Function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Improved noise function (Simplex or Perlin noise would be ideal, but here's a better approximation)\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\n// Smooth interpolation\nfloat smoothNoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    // Smoothstep for interpolation\n    float a = noise(i);\n    float b = noise(i + vec2(1.0, 0.0));\n    float c = noise(i + vec2(0.0, 1.0));\n    float d = noise(i + vec2(1.0, 1.0));\n    \n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(a, b, u.x) +\n           (c - a)* u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec2 p) {\n    float total = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.0;\n    for(int i = 0; i < 5; i++) {\n        total += smoothNoise(p * pow(2.0, float(i))) * amplitude;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n// Wave function with multiple layers and noise\nfloat getWave(vec2 uv, float time) {\n    // Base wave\n    float wave = sin((uv.x + time) * 3.0) * cos((uv.y + time) * 3.0);\n    \n    // Adding turbulence with fbm\n    wave += fbm(uv * 5.0 + time * 0.5) * 0.3;\n    wave += fbm(uv * 10.0 + time * 1.0) * 0.1;\n    \n    return wave;\n}\n\n// Lighting calculations\nvec3 calculateLighting(vec3 normal, vec3 lightDir, vec3 viewDir, float shininess) {\n    // Ambient component\n    vec3 ambient = vec3(0.1);\n    \n    // Diffuse component\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * vec3(0.5, 0.5, 0.5);\n    \n    // Specular component\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    vec3 specular = spec * vec3(1.0);\n    \n    return ambient + diffuse + specular;\n}\n\n// Main shader function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize coordinates to range [-1, 1]\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv.x *= iResolution.x / iResolution.y; // Maintain aspect ratio\n    \n    // Time variable\n    float time = iTime * 0.5;\n    \n    // Get wave height\n    float wave = getWave(uv, time);\n    \n    // Normalize wave height\n    float normalizedWave = (wave + 1.5) / 3.0; // Adjust based on wave amplitude\n    \n    // Calculate color based on wave height\n    float hue = mod(normalizedWave + 0.0, 1.0);\n    vec3 color = hsv2rgb(vec3(hue, 0.8, 0.9)); // Slightly desaturated for realism\n    \n    // Calculate normal for lighting\n    float delta = 0.001;\n    float waveX = getWave(uv + vec2(delta, 0.0), time);\n    float waveY = getWave(uv + vec2(0.0, delta), time);\n    vec3 normal = normalize(vec3(waveX - wave, waveY - wave, 1.0));\n    \n    // Define light direction and view direction\n    vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0)); // Light coming from top-right\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0)); // Viewer is directly in front\n    \n    // Calculate lighting\n    vec3 lighting = calculateLighting(normal, lightDir, viewDir, 32.0);\n    \n    // Apply lighting to color\n    color *= lighting;\n    \n    // Add reflections (simple approximation)\n    float reflection = smoothstep(0.4, 0.6, normalizedWave) * 0.3;\n    color += vec3(1.0) * reflection;\n    \n    // Background color\n    vec3 background = vec3(0.02, 0.02, 0.05);\n    \n    // Blend wave color with background\n    color = mix(background, color, normalizedWave);\n    \n    // Add bloom effect\n    float bloom = smoothstep(0.7, 0.9, normalizedWave);\n    color += vec3(1.0) * bloom * 0.5;\n    \n    // Final color with gamma correction\n    color = pow(color, vec3(0.8));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}