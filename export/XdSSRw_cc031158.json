{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Parametrics by nimitz (twitter @stormoid)\n// https://www.shadertoy.com/view/XdSSRw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tThe problem with the drawing parametric curves in 2d (or 3d) can be seen as a mathematical\n\toptimization problem: Trying to find the closest distance between a point and a given\n\tparametric curve.\n\n\tThe goal is then to find the global minimum of the distance between a pixel and said curve.\n\tThe approach I am taking here is to stepping through the curve's parameter and trying to \n\tfind a coarse global minimum. Then I use the bisection method on the derivative of the\n\tdistance to find the exact minimum.\n\n\tI am sure the main iterator can be optimized, or that my method could be improved.\n\tLet me know if you can help.\n*/\n\n#define time iTime\n#define pi 3.14159265\n\n//Included a few types of parametric curves\n// 1= Hypotrochoid | 2 = Epitrochoid | 3 = Rose curve | 4 = Lissajous | 5 =  Hypocycloid\n#define TYPE 2\n\n//Coloring scheme\n// 1 = Default | 2 = Vintage | 3 = Argon\n#define COLOR_TYPE 1\n\n//might need to be adjusted depending on the curve\n#define STRIDE 0.035\n\n#if TYPE == 5\n#undef STRIDE\n#define STRIDE 0.13\n#endif\n\n//the main number of iterations to find the global minimum region (simple curves need much less)\n#define ITR 100\n\n//for animations\nfloat sfloor(in float x, in float w)\n{\n    float fx = floor(x);\n    return fx+smoothstep(fx+w,fx+1.-w,x);\n}\n\n//parametric equation\nvec2 f(in float t)\n{   \n    //Hypotrochoid\n    #if TYPE == 1\n    float cam= sfloor(time*0.6,.2)*pi;\n    float R = mod(floor(time*0.3),9.)+3.;\n    const float r = 1.;\n    //float d = sin(time*1.)*2.+3.5;\n    float d= R;\n    float x = ((R-r)*cos(t-cam)+d*cos((R-r)/r*t))/(R+.5)*3.;\n    float y = ((R-r)*sin(t)-d*sin((R-r)/r*t))/(R+.5)*3.;\n    \n    //Epitrochoid\n    #elif TYPE == 2\n    float cam= sfloor(time*0.4,.1)*pi*2.;\n    const float R = 2.8;\n    const float r = .4;\n    float d = sin(time*0.21)*2.+2.6;\n    float x = (R+r)*cos(t-cam)-d*cos((R+r)/r*t);\n    float y = (R+r)*sin(t)-d*sin((R+r)/r*t);\n    \n    //Rose Curve\n    #elif TYPE == 3\n    float cam= sfloor(time*0.4,.1)*pi;\n    float k = mod(floor(time*0.4),6.)+2.;\n    float x = cos(k*t-cam)*cos(t+cam)*5.5;\n    float y = cos(k*t)*sin(t)*5.5;\n    \n    //Lissajous\n    #elif TYPE == 4\n    float ft = mod(floor(time*0.25),3.);\n    float a = 3.+ft;\n    float b = 2.+ft;\n    float y = sin(a*t+pi/2.+time*1.5)*5.;\n    float x = sin(b*t)*5.;\n    \n    //Hypocycloid (just a special case of hypotrochoids)\n    #elif TYPE == 5\n    const float a = 6.;\n    float ft = mod(floor(time*0.25),5.)+2.25;\n    float b = 6./ft;\n    float cam= sfloor(time*0.5,.2)*pi;\n    float x = ((a-b)*cos(t-cam) + b*cos(t*(a/b-1.)));\n    float y = ((a-b)*sin(t) - b*sin(t*(a/b-1.)));\n    \n    #else\n    //we can also use triangle waves :)\n    float x= (abs(fract(t*1.+time*0.2)-0.5)-0.25)*20.;\n    float y= ((abs(fract(t*.5+.5*abs(fract(t*.5+.5)-0.5))-0.5))-0.25)*20.;\n    #endif\n\n    return vec2(x,y);\n}\n\n//squared distance from point (pixel) to curve\nfloat fd(in vec2 p, in float t)\n{\n    p = p+f(t);\n    return dot(p,p);\n}\n\n\n//root finding on the derivative\nfloat bisect(in vec2 p, in float near, in float far)\n{\n    float mid = 0.;\n    float mdrv = 0.;\n    float ep = 0.02;\n    for (int i = 0; i <= 5; i++)\n    {\n        mid = (near + far)*.5;\n        mdrv = fd(p, mid+ep)-fd(p, mid-ep);\n        if (abs(mdrv) < 0.001)break;\n        mdrv > 0. ? far=mid : near=mid;\n    }    \n    //once the root is found. return the actual length (not squared)\n    return length(p+ f((near + far)*.5));\n}\n\n\n//this function can most definitely be optimized\nfloat intersect(in vec2 p, in float near, in float far)\n{\n    float t = near;\n    float told = near;\n    float nr = 0., fr = 1.;\n    float mn = 10000.;\n    \n    for (int i = 0; i <= 120; i++)\n    {\n        float d = fd(p, t);\n        if (d < mn)\n        {\n            mn = d;\n            nr = told;\n            fr = t+.05;\n        }\n        if (t > far)break;\n        told = t;\n        //t += log(d1+1.15)*.03;\n        t += log(d+1.15)*STRIDE;\n    }\n    \n   \treturn bisect(p, nr,fr);\n}\n\n\n//Reinhard based tone mapping\nvec3 tone(vec3 color, float gamma)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n    vec2 bp = p+0.5;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 19.;\n    float rz = intersect(p,0.,30.);\n    \n    #if COLOR_TYPE == 1\n    rz = pow(rz*2.,0.5);\n    vec3 col = vec3(2.,1.5,.1)*1.-log(rz+1.8);\n    col = clamp(col,0.5,10.);\n    col *= (texture(iChannel0,p*0.00025*iResolution.x+fract(time)*vec2(51,100)).r-0.5)*.24+1.;\n    col = mix(col,tone(col,1.7),0.5);\n    \n    #elif COLOR_TYPE == 2\n    vec3 col = vec3(5.,1.5,.5)*log(rz+1.05);\n    col = tone(col,8.5);\n    col *= (texture(iChannel0,p*0.00017*iResolution.x+fract(time)*vec2(51,100)).r-0.5)*.12+1.;\n    \n    #else\n    rz = pow(rz*50.,.7);\n    vec3 col = vec3(.6,.2,1.)/(rz+1.5)*9.;\n    col *= (texture(iChannel0,p*0.00025*iResolution.x+fract(time)*vec2(51,100)).r-0.5)*.45+1.;\n    col = tone(col,1.6);\n    #endif\n    \n    \n    //vign from iq (very nice!)\n\tcol *= pow(16.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y),.45);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdSSRw","date":"1409970375","viewed":10699,"name":"Parametrics","username":"nimitz","description":"Parametric plotting as minimum finding and root finding.  Please let me know if you know faster methods.","likes":61,"published":1,"flags":0,"usePreview":1,"tags":["2d","plot","tonemapping","parametric"],"hasliked":0,"parentid":"","parentname":""}}