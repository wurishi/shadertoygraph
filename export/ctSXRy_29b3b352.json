{"ver":"0.1","info":{"id":"ctSXRy","date":"1676257924","viewed":86,"name":"Worley sampling w edge awareness","username":"totimannino","description":"Iter on https://www.shadertoy.com/view/DtjXzR\nThe worley sampling itself now has edge awareness to eliminate bleeding edges from the undersampling. It's a little cleaner.\n\nCommented out output on the bottom of the mainImage shows to worley field","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["filter","imageprocessing","worley","edgedetection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// computes worley noise by checking all adjacent cells\n// and comparing the distance to their points\nvec3 worley(vec2 coord, float numCells) {\n    vec2 cell = getCell(coord, numCells);\n    float dist = 1.0;\n    vec2 dist_cell = vec2(0.0f);\n    \n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n        \tvec2 cell_point = getCellPoint(cell + vec2(x, y), numCells);\n            float maxedgeval = 0.0;\n            // march from the current point to the cell point and check if we've crossed edges\n            for(int ti = 0; ti < 20; ti++)\n            {\n                float tf = float(ti)/20.0f;\n                vec2 rm = coord*(1.0f - tf) + cell_point*tf;\n                maxedgeval = max(texture(iChannel0, rm).a,maxedgeval);\n            }\n            \n            if(maxedgeval < 0.005)\n            {\n                cell_point = cell_point - coord;\n                float len = dot(cell_point, cell_point);\n                if (len < dist)\n                {\n                    dist = len;\n                    dist_cell = cell_point;\n                }\n            }\n        }\n    }\n    \n    return vec3(dist_cell.xy+coord, dist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixCoord = iChannelResolution[0].xy*fragCoord/iResolution.xy;\n    float ySum = 0.0f;\n    float xSum = 0.0f;\n    vec2 xOffset, yOffset;\n    float fi, sigfi;\n    for(int i = -2; i <= 2; ++i)\n    {\n        fi = float(i);\n        sigfi = sigmoid(fi);\n        xOffset = vec2(fi, 0.0f);\n        yOffset = vec2(0.0f, fi);\n        xSum += sigfi*rgb2gray(texture(iChannel0, (pixCoord + xOffset)/iChannelResolution[0].xy).rgb);\n        ySum += sigfi*rgb2gray(texture(iChannel0, (pixCoord + yOffset)/iChannelResolution[0].xy).rgb);\n    }\n        \n    float edge = max(abs(xSum),abs(ySum));\n    float numCells = 56.0;\n    vec3 sampWorley = worley(fragCoord/iResolution.xy, numCells);\n    if(edge < 0.04)\n    {\n        fragColor = texture(iChannel0, sampWorley.xy);\n    }\n    else\n    {\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    }\n    \n    // input passthrough\n    //fragColor = vec4(texture(iChannel0, fragCoord/iChannelResolution[0].xy).rgb, 1.0);\n    \n    // edge detection\n    //fragColor = vec4(100.0*texture(iChannel0, fragCoord/iChannelResolution[0].xy).a);\n    \n    // worley distance with edge blocking neighboring points\n    //fragColor = vec4(vec3(1000.0*sampWorley.z),1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Arbitrary random, can be replaced with a function of your choice\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(.24, 1.023))) * 330.5453);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec2 getCellPoint(vec2 cell, float numCells) \n{\n    return (cell + hash22(cell)) / numCells;\n}\n\nvec2 getCell(vec2 coord, float numCells) \n{\n    return floor(vec2(coord * numCells));\n}\n\nfloat sigmoid(float x)\n{\n    return 1.0f/(1.0f + exp(-x)) - 0.5;\n}\n\nfloat rgb2gray(vec3 color)\n{\n    return 0.2989*color.r + 0.5870 *color.g + 0.1140*color.b; \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixCoord = iChannelResolution[0].xy*fragCoord/iResolution.xy;\n    float ySum = 0.0f;\n    float xSum = 0.0f;\n    vec2 xOffset, yOffset;\n    float fi, sigfi, Ix, Iy;\n    for(int i = -2; i <= 2; ++i)\n    {\n        fi = float(i);\n        sigfi = sigmoid(fi);\n        xOffset = vec2(fi, 0.0f);\n        yOffset = vec2(0.0f, fi);\n        xSum += sigfi*rgb2gray(texture(iChannel0, (pixCoord + xOffset)/iChannelResolution[0].xy).rgb);\n        ySum += sigfi*rgb2gray(texture(iChannel0, (pixCoord + yOffset)/iChannelResolution[0].xy).rgb);\n    }\n    fragColor = vec4(texture(iChannel0, pixCoord/iChannelResolution[0].xy).rgb, xSum*xSum + ySum*ySum);\n}","name":"Buffer A","description":"","type":"buffer"}]}