{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// License CC-Attribution-Sharealike-NonCommercial\n\n#define THRESHOLD 0.025\n#define MAX_DISTANCE 2.0\n\n#define RAY_STEPS 22\n\n// Comment out for nicer normals on OSX\n#define OUCH\n\n// Uncomment to turn off the music vis.\n//#define WATER\n\n\n// iq's LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat map( in vec3 p )\n{\n\tvec3 q = p + 0.3*vec3(-1.0, 0.3, 1.2)*iTime;\n\tfloat f;\n#ifndef WATER\nfloat m1 = texture(iChannel1, vec2(0.0)).r;\nfloat m2 = texture(iChannel1, vec2(1.0/iChannelResolution[0].x,0.0)).r;\nfloat m3 = texture(iChannel1, vec2(2.0/iChannelResolution[0].x)).r;\nfloat m4 = texture(iChannel1, vec2(4.0/iChannelResolution[0].x,0.0)).r;\nfloat m5 = texture(iChannel1, vec2(7.0/iChannelResolution[0].x)).r;\nfloat m6 = texture(iChannel1, vec2(9.0/iChannelResolution[0].x,0.0)).r;\n#endif\n#ifdef WATER\n\t// trying to do something like TekF's 6-octave ocean noise\n    f  = 0.500*noise( q ); q = q*2.0;\n    f += 0.25*noise( q ); q = q*2.0;\n    f += 0.125*noise( q ); q = q*2.0;\n    f += 0.0625*noise( q ); q = q*2.0;\n    f += 0.03125*noise( q ); q = q*2.0;\n    f += 0.015625*noise( q );\n\treturn pow(f, 0.7)*0.1+0.2;\n#else\n    f  = m1*0.500*noise( q ); q = q*2.0;\n    f += m2*0.25*noise( q ); q = q*2.0;\n    f += m3*0.125*noise( q ); q = q*2.0;\n    f += m4*0.0625*noise( q ); q = q*2.0;\n    f += m5*0.03125*noise( q ); q = q*2.0;\n    f += m6*0.015625*noise( q );\n\treturn pow(f, 6.0)*-2.0+0.2;\n#endif\n}\n\n\nfloat scene(vec3 p)\n{\n\treturn min(length(p-vec3(0.0, 0.9, 0.0))-0.7, max(length(p)-2.8, (map(p)+0.9+p.x+p.y)));\n}\n\nvec3 normal(vec3 p, float d)\n{\n#ifdef OUCH\n\tif (abs(length(p)-2.8 - d) < 0.00001) {\n\t\treturn -normalize(p);\n\t} else if (abs(length(p-vec3(0.0, 0.9, 0.0))-0.7 - d) < 0.00001) {\n\t\treturn -normalize(p-vec3(0.0, 0.9, 0.0));\n\t} else {\n\t\tfloat ed = 14.4 / iResolution.y;\n\t\tp += vec3(0.0, 0.0, ed);\n\t\tfloat d1 = map(p)+0.9+p.x+p.y;\n\t\tfloat dt = d1-d;\n\t\treturn normalize(vec3(ed, ed, dt));\n\t}\n#else\n\tfloat e = 0.05;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n#endif\n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 bgLight = normalize(vec3(\n\t\tcos(iTime*0.2)*4.0, \n\t\tsin(iTime)*3.0 - 4.0, \n\t\tsin(iTime*0.2)*8.0\n\t));\n\tvec3 sun = vec3(2.0, 1.0, 0.5);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.7, 0.7, 1.0);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.7, 0.7);\n\tbgCol += vec3(0.2, 0.5, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * (fragCoord.xy / iResolution.xy) - 1.0) * aspect;\n\tvec3 d = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(uv*-2.0, -6.5) + d*4.0;\n\tif (dot(d,vec3(0.0, 0.0, 1.0)) > 0.77) {\n\t\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\t\tfloat dist = scene(p);\n\t\t\tif (dist < THRESHOLD) {\n\t\t\t\tvec3 nml = normal(p, dist);\n\t\t\t\td = reflect(d, nml);\n\t\t\t\tp += (23.0*THRESHOLD) * d;\n\t\t\t}\n\t\t\tif (dist > MAX_DISTANCE) {\n\t\t\t\tbreak; \n\t\t\t}\n\t\t\tp += dist * d;\n\t\t}\n\t}\n\tfragColor = vec4( 1.0 - exp(-1.3 * shadeBg(-d, fragCoord)), 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2GWh","date":"1387204657","viewed":490,"name":"Audiophilia","username":"kig","description":"Tried to use noise in a distance field, got hijacked by CGI. \n","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["terrain","raymarch"],"hasliked":0,"parentid":"","parentname":""}}