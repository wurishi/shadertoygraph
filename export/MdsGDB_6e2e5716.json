{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"musicstream","id":"XlsSWX","filepath":"https://soundcloud.com/mark-r-3/as-far-away-as-possible","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\npwd\n\nwww.prinzipiell.com - www.psykosoft.net\n\neye sonic ornamental\n\ncredits:\niq (eyeball), mu6k (wierd balls)\n\n*/\n\n#define occlusion_enabled\n#define occlusion_pass1_quality 4\n#define occlusion_pass2_quality 3\n\n#define noise_use_smoothstep\n\n#define object_count 11\n#define object_speed_modifier .5\n\n#define render_steps 28\n\nvec4  eyeball;\nfloat fft, led, dx;\n\nfloat displace(vec3 p) {\n\t\n\treturn ((cos(4.*p.x)*sin(4.*p.y)*sin(4.*p.z))*cos(30.1))*sin(iTime);\n\t\n}\n\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat hashmix(vec3 p0, vec3 p1, vec3 interp)\n{\n\tfloat v0 = hashmix(p0.xy+vec2(p0.z*143.0,0.0),p1.xy+vec2(p0.z*143.0,0.0),interp.xy);\n\tfloat v1 = hashmix(p0.xy+vec2(p1.z*143.0,0.0),p1.xy+vec2(p1.z*143.0,0.0),interp.xy);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec3(0.0),vec3(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[2]);\n}\n\nfloat noise(vec3 p) // 3D noise\n{\n\tvec3 pm = mod(p,1.0);\n\tvec3 pd = p-pm;\n\treturn hashmix(pd,(pd+vec3(1.0,1.0,1.0)), pm);\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0,+1.0);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat dist(vec3 p)//distance function\n{\n\n\tfloat t = iTime+4.0;\n\tfloat d = 1000.0;//p.y+2.0;\n\tp.y+=sin(t*.5)*.2;\n\td=min(length(p)-1.0,d);\n\t\n\tfloat dp  = displace(p);\n\td =d + dp;\n\t\n\tfor (int i=0; i<object_count; i++)\n\t{\n\t\tfloat fi = float(i); \n\t\tfloat tof=1442.530/float(object_count)*fi;\n\t\tvec3 offs = vec3(\n\t\t\tsin(t*.7+tof*6.0),\n\t\t\tsin(t*.8+tof*4.0),\n\t\t\tsin(t*.9+tof*3.0));\n\t\tvec3 v = p+normalize(offs)*1.0;\n\t\td = min(d,length(v)-fft/4.);\n\t\t\n\t}\n\t\n\treturn d;\n}\n\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\t#define ambe 0.2\n\n\tacc+=dist(p+vec3(-ambe,-ambe,-ambe));\n\tacc+=dist(p+vec3(-ambe,-ambe,+ambe));\n\tacc+=dist(p+vec3(-ambe,+ambe,-ambe));\n\tacc+=dist(p+vec3(-ambe,+ambe,+ambe));\n\tacc+=dist(p+vec3(+ambe,-ambe,-ambe));\n\tacc+=dist(p+vec3(+ambe,-ambe,+ambe));\n\tacc+=dist(p+vec3(+ambe,+ambe,-ambe));\n\tacc+=dist(p+vec3(+ambe,+ambe,+ambe));\n\treturn 0.5+acc /(16.0*ambe);\n}\n\nfloat occ(vec3 start, vec3 light_pos, float size)\n{\n\tvec3 dir = light_pos-start;\n\tfloat total_dist = length(dir);\n\tdir = dir/total_dist;\n\t\n\tfloat travel = .1;\n\tfloat o = 1.0;\n\tvec3 p=start;\n\t\n\tfloat search_travel=.0;\n\tfloat search_o=1.0;\n\t\n\tfloat e = .5*total_dist/float(occlusion_pass1_quality);\n\t\n\t//pass 1 fixed step search\n\t\n\tfor (int i=0; i<occlusion_pass1_quality;i++)\n\t{\n\t\ttravel = (float(i)+0.5)*total_dist/float(occlusion_pass1_quality);\n\t\tfloat cd = dist(start+travel*dir);\n\t\tfloat co = cd/travel*total_dist*size;\n\t\tif (co<search_o)\n\t\t{\n\t\t\tsearch_o=co;\n\t\t\tsearch_travel=travel;\n\t\t\tif (co<.0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t//pass 2 tries to find a better match in close proximity to the result from the \n\t//previous pass\n\t\t\n\tfor (int i=0; i<occlusion_pass2_quality;i++)\n\t{\n\t\tfloat tr = search_travel+e;\n\t\tfloat oc = dist(start+tr*dir)/tr*total_dist*size;\n\t\tif (tr<.0||tr>total_dist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (oc<search_o)\n\t\t{\n\t\t\tsearch_o = oc;\n\t\t\tsearch_travel = tr;\n\t\t}\n\t\te=e*-.75;\n\t}\n\t\n\to=max(search_o,.0);\n\n\treturn o;\n}\n\nfloat occ(vec3 start, vec3 light_pos, float size, float dist_to_scan)\n{\n\tvec3 dir = light_pos-start;\n\tfloat total_dist = length(dir);\n\tdir = dir/total_dist;\n\t\n\tfloat travel = .1;\n\tfloat o = 1.0;\n\tvec3 p=start;\n\t\n\tfloat search_travel=.0;\n\tfloat search_o=1.0;\n\t\n\tfloat e = .5*dist_to_scan/float(occlusion_pass1_quality);\n\t\n\t//pass 1 fixed step search\n\t\n\tfor (int i=0; i<occlusion_pass1_quality;i++)\n\t{\n\t\ttravel = (float(i)+0.5)*dist_to_scan/float(occlusion_pass1_quality);\n\t\tfloat cd = dist(start+travel*dir);\n\t\tfloat co = cd/travel*total_dist*size;\n\t\tif (co<search_o)\n\t\t{\n\t\t\tsearch_o=co;\n\t\t\tsearch_travel=travel;\n\t\t\tif (co<.0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t//pass 2 tries to find a better match in close proximity to the result from the \n\t//previous pass\n\t\t\n\tfor (int i=0; i<occlusion_pass2_quality;i++)\n\t{\n\t\tfloat tr = search_travel+e;\n\t\tfloat oc = dist(start+tr*dir)/tr*total_dist*size;\n\t\tif (tr<.0||tr>total_dist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (oc<search_o)\n\t\t{\n\t\t\tsearch_o = oc;\n\t\t\tsearch_travel = tr;\n\t\t}\n\t\te=e*-.75;\n\t}\n\t\n\to=max(search_o,.0);\n\n\treturn o;\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nmat2 m = mat2( 0.10,  0.60, -0.10,  0.80 );\n\nfloat noise(float p)\n{\n\tfloat pm = mod(p,1.0);\n\tfloat pd = p-pm;\n\treturn hashmix(pd,pd+1.0,pm);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n    return (f/0.984375);\n}\n\nfloat length2( vec2 p )\n{\n    float ax = abs(p.x);\n    float ay = abs(p.y);\n    return pow( pow(ax,4.0) + pow(ay,4.0), 1.0/4.0 );\n}\n\nvec3 background(vec3 p,vec3 d)//render background\n{\n\tvec3 color = mix(vec3(.9,.6,.2),vec3(.1,.4,.8),d.y*.5+.5);\n\treturn (color*(noise(d)+.3*pow(noise(d*4.0),4.0)));\n\n}\n\n\n\nvec3 object_material(vec3 p, vec3 d) //computes the material for the object\n{\n\tvec3 n = normal(p,.001); //normal vector\n\tvec3 oldn=n; float nns = 64.0; float nna = .1;\n\tn.x+=(noise(oldn.yz*nns)-.5)*nna;\n\tn.y+=(noise(oldn.zx*nns)-.5)*nna;\n\tn.z+=(noise(oldn.xy*nns)-.5)*nna;\n\tn=normalize(n);\n\tvec3 r = reflect(d,n); //reflect vector\n\tfloat ao = amb_occ(p); //fake ambient occlusion\n\tvec3 color = vec3(.0,.0,.0); //variable to hold the color\n\tfloat reflectance = 1.0+dot(d,n);\n\treflectance += 1.4;\n\n\tfloat or = occ(p,p+r*10.0,0.5,2.0);\n\t\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tvec3 offs = vec3(\n\t\t\t-sin(5.0*(1.0+fi)*123.4),\n\t\t\t-sin(4.0*(1.0+fi)*723.4),\n\t\t\t-sin(3.0*(1.0+fi)*413.4));\n\t\n\t\tvec3 lp = offs*100.0;\n\t\tvec3 ld = normalize(lp-p);\n\t\t\n\t\tfloat diffuse = dot(ld,n);\n\t\tfloat od=.0;\n\t\tif (diffuse>.0)\n\t\t{\n\t\t\tod = occ(p,lp,0.05,2.0);\n\t\t}\n\t\t\n\t\tfloat spec = pow(dot(r,ld)*.5+.5,100.0);\n\t\t\n\t\tvec3 icolor = vec3(eyeball.r,eyeball.g,eyeball.b)*diffuse*od*.6 + vec3(spec)*od*reflectance;\n\t\tcolor += icolor;\n\t}\n\n\tcolor += background(p,r)*(.1+or*reflectance) * eyeball.rgb;\n\n\t\n\treturn color*ao*1.2;\n\t\n}\n\nfloat rand(vec2 position) {\n\treturn fract(sin(dot(position.xy ,vec2(12.9898,78.233))) * 43758.5453+(fft*0.5));\n}\n\nfloat radius = .5;\nfloat refractionIndex = 1.9;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv_ = fragCoord.xy / iResolution.xy;\n\tvec2  p_ = -1.0 + 2.0 * uv_;\n    vec2 dist_ = p_;\n    float radius2 = radius * radius;\n    float r2 = dist_.x * dist_.x + dist_.y * dist_.y;\n        \n\tif ( r2 > 0.0 && r2 < radius2 )\n\t{\n\t\tfloat z2 = radius2 - r2;\n\t\tfloat z = sqrt(z2);\n\t\t\n\t\tfloat xa = asin( dist_.x / sqrt( dist_.x * dist_.x + z2 ) );\n\t\tfloat xb = xa - xa * refractionIndex;\n\t\tfloat ya = asin( dist_.y / sqrt( dist_.y * dist_.y + z2 ) );\n\t\tfloat yb = ya - ya * refractionIndex;\n\t\t\n\t\tp_.x -= z * tan( xb );\n\t\tp_.y -= z * tan( yb );\n\t}\n       \n    float r = length( p_ );\n    float a = atan( p_.y, p_.x );\n\n    float dd = 0.2*sin(0.7*iTime);\n    float ss = .85 + clamp(1.0-r,0.0,1.0)*dd/.5;\t\t\t\n\tr *= ss;\n\n    vec3 col = vec3( 1.0, 0.53, 0.64 );\n    float f = fbm( 2.0*p_ );\n\t\n    col = mix( col, vec3(0.2,0.5,0.4), f );\n\tcol = mix( col, vec3(0.9,0.6,0.2), 1.0-smoothstep(0.2,0.6,r) );\n    a += 0.05*fbm( 20.0*p_ );\n    f = smoothstep( 0.3, 1.0, fbm( vec2(20.0*a,6.0*r) ) );\n    col = mix( col, vec3(1.0,1.0,1.0), f );\n    f = smoothstep( 0.4, 0.9, fbm( vec2(15.0*a,10.0*r) ) );\n    col *= 1.0-0.5*f;\n    col *= 1.0-0.25*smoothstep( 0.6,0.8,r );\n    f = 1.0-smoothstep( 0.0, 0.6, length2( mat2(0.6,0.8,-0.8,0.6)*(p_-vec2(0.3,0.5) )*vec2(1.0,2.0)) );\n    col += vec3(1.0,0.9,0.9)*f*0.985;\n    col *= vec3(0.8+0.2*cos(r*a));\n    f = 1.0-smoothstep( 0.2, 0.25, r );\n    col = mix( col, vec3(0.0), f );\n    f = 1.0 - smoothstep( 0.79, 0.82, r );\n\n    eyeball = vec4(col*f,f);\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\n\t//setup the camera\n\tconst float bands = 40.;\n\tvec3 p = vec3(.0,0.0,-2.0);\n\t\n\tfft  = texture( iChannel0, vec2(p.x,0.0) ).x;\t\n\tdx  = fract( (uv.x - p.x) * bands) - 0.5;\n\tled = smoothstep(0.5, 0.3, abs(dx));\t\n\n\tfloat t = iTime*.5*object_speed_modifier + 30.0 * fft / 14.;\n\tmouse += vec3(sin(t)*.1,sin(t)*.1,.0);\n\t\n\tp = rotate_x(p,mouse.y*9.0);\n\tp = rotate_y(p,mouse.x*9.0);\n\tp.y*.2;\n\tvec3 d = vec3(uv,1.0);\n\td.z -= length(d)*.6; //lens distort\n\td = normalize(d);\n\td = rotate_x(d,mouse.y*9.0);\n\td = rotate_y(d,mouse.x*9.0);\n\t\n\tvec3 sp = p;\n\tvec3 color;\n\n\t\n\t//raymarching \n\tfor (int i=0; i<render_steps; i++)\n\t{\n\t\tdd = dist(p);\n\t\tp+=d*dd;\n\t\tif (dd<.001||dd>2.0) break;\n\t}\n\t\n\tif (dd<.03)\n\t{\n\t\tcolor = object_material(p,d);\n\t}\n\telse\n\t{\n\t\tcolor = background(p,d);\n\t}\n\t\n\tcolor = mix(color*color,color,1.4);\n\tcolor *=.8;\n\tcolor -= length(uv)*.1;\n\tcolor = cc(color,.5,.5);\n\tcolor += hash(uv.xy+color.xy)*.02;\n\t\n\tcolor *= 1.0+0.3*sin(uv.y*(iResolution.y*1.75));\n\tcolor = (color*0.85)+(color*0.25*vec3(rand(uv)));\n\t\n\tfragColor = vec4(color,1.0) * fft;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":true},"info":{"id":"MdsGDB","date":"1379058075","viewed":583,"name":"sonic eye ornaments","username":"_pwd_","description":"...eye wants sound *retina reloaded*","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["procedural","3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}