{"ver":"0.1","info":{"id":"4cGSzW","date":"1715170041","viewed":67,"name":"Our Solar System","username":"GarlicGraphix","description":"Solar System. Would've liked to get the lighting and some of the planets looking better but I've been working on this for too long, it's time for something new.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","space","solarsystem"],"hasliked":0,"parentid":"4cdXzj","parentname":"GarlicGraphix Raymarch Template"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define OBJ_GROUP_0 0\n#define OBJ_GROUP_1 1\n#define OBJ_GROUP_2 2\n#define OBJ_GROUP_3 3\n\n#define MERCURY 0\n#define VENUS 1\n#define EARTH 2\n#define MARS 3\n#define JUPITER 4\n#define SATURN 5\n#define URANUS 6\n#define NEPTUNE 7\n#define PLUTO 8\n#define SUN 9\n\n#define MOON_COUNT 8\n\nfloat planetSizes[10] = float[](0.03, 0.06, 0.06, 0.04, 0.15, 0.13, 0.1, 0.09, 0.03, 0.3);\nfloat planetDistances[10] = float[](0.39, 0.72, 1.0, 1.52, 2.2, 3.54, 5.2, 6.06, 7.3, 0.0);\nvec3 planetColours[10] = vec3[](\n            // Mercury\n            vec3(0.6, 0.6, 0.6), // Greyish\n\n            // Venus\n            vec3(0.87, 0.6, 0.15), // Sandy yellow\n\n            // Earth\n            vec3(0.0, 0.5, 1.0), // Blue\n\n            // Mars\n            vec3(1.0, 0.3, 0.0), // Reddish\n\n            // Jupiter\n            vec3(0.8, 0.6, 0.4), // Pale brown\n\n            // Saturn\n            vec3(0.9, 0.8, 0.6), // Pale gold\n\n            // Uranus\n            vec3(0.5, 0.7, 0.9), // Pale blue\n\n            // Neptune\n            vec3(0.2, 0.4, 0.8), // Deep blue\n\n            // Pluto\n            vec3(0.6, 0.6, 0.6), // Greyish\n            \n            // Sun\n            vec3(1.0, 1.0, 0.0) // Yellow\n        );\nvec2 moons[MOON_COUNT] = vec2[](\n    vec2(EARTH, 0),\n    vec2(JUPITER, 0),\n    vec2(JUPITER, 1),\n    vec2(JUPITER, 2),\n    vec2(JUPITER, 3),\n    vec2(SATURN, 2),\n    vec2(NEPTUNE, 0),\n    vec2(PLUTO, 0)\n);\nvec3 getPlanetPos(int planet) {\n    float orbitHeight = planetDistances[planet];\n    float divisor = 2.0*float(planet);\n    if (divisor == 0.0) {\n        divisor = 1.0;\n    }\n    float orbitSpeed = 1.2/(divisor);\n    return vec3(sin(iTime*orbitSpeed), 0.0, cos(iTime*orbitSpeed))*orbitHeight;\n}\n\nvec3 getMoonPos(vec2 moon) {\n    int planet = int(moon.x);\n    int moonNum = int(moon.y);\n    vec3 planetPos = getPlanetPos(planet);\n    float orbitHeight = planetSizes[planet]+0.1 + float(moonNum)*0.1;\n    float orbitSpeed = 1.2 - 0.2*float(moonNum);\n    vec3 relMoonPos = vec3(sin(iTime*orbitSpeed), 0.0, cos(iTime*orbitSpeed))*orbitHeight;\n    if (planet == NEPTUNE) {\n        relMoonPos = vec3(sin(-iTime*orbitSpeed), 0.0, cos(-iTime*orbitSpeed))*orbitHeight;\n    }\n    return planetPos - relMoonPos;\n}\n\nfloat rand(float seed) {\n    return fract(sin(seed+60.0)*290000.0);\n}\nmat2 rot2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nvec3 proj(vec3 u, vec3 v) {\n    return v*(dot(u, v)/ dot(v, v));\n}\n\n//Signed distance & smooth union from Inigo Quilez\nfloat sdSphere( vec3 ray, float size ) {\n  return length(ray)-size;\n}\n\nfloat sdBox( vec3 ray, vec3 dimensions ) {\n  vec3 q = abs(ray) - dimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 ray, vec3 normal, float height ) {\n  normal = normalize(normal);\n  return dot(ray,normal) + height;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n//Object definition\nfloat getDist(vec3 ray, int state) {\n    if (state == OBJ_GROUP_0) {\n        //Sun\n        return sdSphere(ray, 0.3);\n    } else if (state == OBJ_GROUP_1) {\n        //Planets\n        float dist = 10000.0;\n        for (int i = 0; i < 9; i++) {\n            vec3 pos = getPlanetPos(i);\n            dist = min(dist, sdSphere(ray-pos, planetSizes[i]));\n        }\n        return dist;\n    } else if (state == OBJ_GROUP_2) {\n        //Moons\n        float dist = 10000.0;\n        for (int i = 0; i < MOON_COUNT; i++) {\n            dist = min(dist, sdSphere(ray - getMoonPos(moons[i]), 0.02));\n        }\n\n        return dist;\n    } else if (state == OBJ_GROUP_3) {\n        //Saturn's ring\n        vec3 pos = ray - getPlanetPos(SATURN);\n        float sRing = sdTorus(pos, vec2(0.2, 0.04));\n        sRing = max(sdPlane(pos, normalize(vec3(0.0, 1.0, 0.0)), -0.001), sRing);\n        sRing = max(-sdPlane(pos, normalize(vec3(0.0, 1.0, 0.0)), 0.001), sRing);\n        //Uranus Ring\n        pos = ray - getPlanetPos(URANUS);\n        pos.zy *= rot2D(PI/2.0);\n        float uRing = sdTorus(pos, vec2(0.15, 0.02));\n        uRing = max(sdPlane(pos, normalize(vec3(0.0, 1.0, 0.0)), -0.001), uRing);\n        uRing = max(-sdPlane(pos, normalize(vec3(0.0, 1.0, 0.0)), 0.001), uRing);\n        return min(sRing, uRing);\n        \n    } else {\n        return 0.0;\n    }\n}\n\nfloat getDistToPlanet(vec3 ray, int planet) {\n    vec3 pos = getPlanetPos(planet);\n    return sdSphere(ray-pos, planetSizes[planet]);\n}\n\n//From Art of Code\nvec3 getNormal(vec3 p, int state) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = getDist(p, state) - \n        vec3(getDist(p-e.xyy, state), getDist(p-e.yxy, state),getDist(p-e.yyx, state));\n    \n    return normalize(n);\n}\n\n// Closest planet for texturing purposes!\nint getClosestPlanet(vec3 ray) {\n    //Planets        \n        float dist = 10000.0;\n        int currentPlanet = 0;\n        for (int i = 0; i < 9; i++) {\n            vec3 pos = getPlanetPos(i);\n            float oldDist = dist;\n            dist = min(dist, sdSphere(ray-pos, planetSizes[i]));\n            if (oldDist != dist) {\n                currentPlanet = i;\n            }\n        }\n        return currentPlanet;\n}\nvec2 getClosestMoon(vec3 ray) {\n    float dist = 10000.0;\n    vec2 currentMoon = vec2(EARTH, 0);\n    for (int i = 0; i < MOON_COUNT; i++) {\n        float oldDist = dist;\n        dist = min(dist, sdSphere(ray - getMoonPos(moons[i]), 0.02));\n        if (dist != oldDist) {\n            currentMoon = moons[i];\n        }\n    }\n\n    return currentMoon;\n}\n\n// textures objeccts based on ray\nvec3 textureObj(vec3 ray, int state) {\n    vec3 colXZ;\n    vec3 colXY;\n    vec3 colYZ;\n    if (state == OBJ_GROUP_0) {\n        colXZ = texture(iChannel0, ray.xz * 0.25 + 0.5).rgb;\n        colXY = texture(iChannel0, ray.xy * 0.5 + 0.5).rgb;\n        colYZ = texture(iChannel0, ray.yz * 0.5 + 0.5).rgb;\n    } else if (state == OBJ_GROUP_1) {\n        int planet = getClosestPlanet(ray);\n        vec3 textureRay = ray - getPlanetPos(getClosestPlanet(ray));\n        \n        if (planet == SATURN || planet == JUPITER || planet == NEPTUNE) {\n            textureRay.xz *= rot2D(iTime);\n            textureRay.x *= 0.1;\n            colXZ = texture(iChannel2, textureRay.yx * 0.25 + 0.5).rgb;\n            colXY = texture(iChannel2, textureRay.yx * 0.5 + 0.5).rgb;\n            colYZ = texture(iChannel2, textureRay.yx * 0.5 + 0.5).rgb;\n        } else if (planet == URANUS) {\n            textureRay.xy *= rot2D(iTime);\n            textureRay.y *= 0.1;\n            colXZ = texture(iChannel2, textureRay.zy * 0.25 + 0.5).rgb;\n            colXY = texture(iChannel2, textureRay.zy * 0.5 + 0.5).rgb;\n            colYZ = texture(iChannel2, textureRay.zy * 0.5 + 0.5).rgb;\n        } else {\n            textureRay.xz *= rot2D(iTime);\n            colXZ = texture(iChannel1, textureRay.xz * 0.25 + 0.5).rgb;\n            colXY = texture(iChannel1, textureRay.xy * 0.5 + 0.5).rgb;\n            colYZ = texture(iChannel1, textureRay.yz * 0.5 + 0.5).rgb;\n        }\n        \n        vec3 planetColour = planetColours[planet];\n        colXZ *= planetColour;\n        colXY *= planetColour;\n        colYZ *= planetColour;\n    } else if (state == OBJ_GROUP_2) {\n        colXZ = vec3(0.2);\n        colXY = vec3(0.2);\n        colYZ = vec3(0.2);\n    } else if (state == OBJ_GROUP_3) {\n        vec3 textureRay = ray - getPlanetPos(getClosestPlanet(ray));\n        textureRay.xz *= rot2D(iTime*2.0);\n        vec3 pixel = vec3(length(textureRay));\n        int closestPlanet = getClosestPlanet(ray);\n        vec3 towardsSun = normalize(-ray);\n        if (getDistToPlanet(getPlanetPos(closestPlanet) + towardsSun, closestPlanet) > 0.5) {\n            colXZ = texture(iChannel3, pixel.xz * 0.25 + 0.5).rgb;\n            colXY = texture(iChannel3, pixel.xy * 0.5 + 0.5).rgb;\n            colYZ = texture(iChannel3, pixel.zy * 0.5 + 0.5).rgb;\n        }\n    }\n    \n    vec3 normal = getNormal(ray, state);\n    \n    return colXZ * abs(normal.y) + colXY * abs(normal.z) + colYZ * abs(normal.x);\n}\n//Returns colour of object\nvec3 raymarch(vec3 origin, vec3 ray) {\n    float totDist = 0.0;\n    int iterations = 80;\n    vec3 colour = vec3(0.0);\n    vec3 transColour = vec3(0.0);\\\n    bool transCull = false;\n\n    for (int i = 0; i < iterations; i++) {\n        vec3 pos = origin + ray * totDist;\n        float group0 = getDist(pos, OBJ_GROUP_0);\n        float group1 = getDist(pos, OBJ_GROUP_1);\n        float group2 = getDist(pos, OBJ_GROUP_2);\n        float group3 = 1000.0;\n        if (!transCull) {\n            group3 = getDist(pos, OBJ_GROUP_3);\n        }\n        float dist = group0;\n        dist = min(dist, group1);\n        dist = min(dist, group2);\n        if (!transCull) {\n            dist = min(dist, group3);\n        }\n        \n        totDist += dist;\n        \n        if (dist <= 0.001) {\n            if (dist == group0) { //Sun\n                colour = textureObj(pos, OBJ_GROUP_0);\n            } else if (dist == group1) { // Planets\n                colour = textureObj(pos, OBJ_GROUP_1);\n                // Shadows\n                vec3 normal = getNormal(pos, OBJ_GROUP_1);\n                colour *= -dot(normalize(getPlanetPos(getClosestPlanet(pos))), normal);\n                colour = clamp(colour*2.0, 0.0, 1.0);\n            } else if (dist == group2) { //Moons\n                colour = textureObj(pos, OBJ_GROUP_2);\n                // Shadows\n                vec3 normal = getNormal(pos, OBJ_GROUP_2);\n                colour *= -dot(normalize(getMoonPos(getClosestMoon(pos))), normal);\n                colour = clamp(colour*2.0, 0.0, 1.0);\n            } else if (dist == group3) {\n                transColour = textureObj(pos, OBJ_GROUP_3);\n                transCull = true;\n                continue;\n            }\n            \n            break;\n        } else if (dist >= 100.0 || i == 79) {\n            iterations = i;\n            colour = vec3(0.0);\n            break;\n        }\n    }\n    if (transColour != vec3(0.0)) {\n        colour *= 0.3;\n    }\n    return clamp(colour+0.3*transColour, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv made for raymarching\n    vec2 uv = (fragCoord *2. - iResolution.xy) / iResolution.y;\n    \n    // Camera Definition\n    vec3 origin = vec3(0.0, 0.0, -0.5);\n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    \n    // Camera Rotation\n    float rotationYZ = 0.5;\n    origin.yz *= rot2D(rotationYZ);\n    ray.yz *= rot2D(rotationYZ);\n    \n    float rotationXZ = -iTime*0.3;\n    origin.xz *= rot2D(rotationXZ);\n    ray.xz *= rot2D(rotationXZ);\n    \n    // Focus on random planet every 5 seconds\n    int planet = int(floor(rand(floor(iTime/5.0))*10.0));\n    origin += getPlanetPos(planet);\n    \n    // Time varying pixel color\n    vec3 col = raymarch(origin, ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //uv.x += iTime*0.3;\n    vec3 col = texture(iChannel0, uv.xy).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}