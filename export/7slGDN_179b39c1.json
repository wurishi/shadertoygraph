{"ver":"0.1","info":{"id":"7slGDN","date":"1616017351","viewed":86,"name":"hash test (vlllll)","username":"valalalalala","description":"Testing out the hash function from Blackle Mori's https://suricrasia.online/demoscene/functions/  along side a couple of other hashes.\n\nThe red version is un-scaled input, green is tiny scale and blue is hugely scaled","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"hash test\"                                               // //\n     //                                                            //  //\n    //  Testing out the hash function from Blackle Mori's         //   //\n   //  https://suricrasia.online/demoscene/functions/            //    //   \n  //  along side a couple of other hashes                       //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     // \n//                                                            //    //\n// CC0 1.0 Universal                                          //   //\n// https://creativecommons.org/publicdomain/zero/1.0/         //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// color settings\n\nconst vec2 HILO = vec2( .7, .2 );\nconst vec3 RED = HILO.xyy;\nconst vec3 GRN = HILO.yxy;\nconst vec3 BLU = HILO.yyx;\n\n////////////////////////////////////////////////////////////////\n// comment this out to disable scale testing\n\n#define TEST_SCALING\n\nconst float TINY = 2e-6;\nconst float HUGE = 2e+6;\n\n////////////////////////////////////////////////////////////////\n// test hash with different rates of change on input values\n\nconst float SLOW = .00000001;\nconst float FAST = .1;\nconst float SPEED = FAST;\n\n////////////////////////////////////////////////////////////////\n\n#define RZ iResolution\n\n////////////////////////////////////////////////////////////////\n// from https://suricrasia.online/demoscene/functions/\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\n\nfloat hash(vec2 p) {\n  int x = FK(p.x); int y = FK(p.y);\n  return float((x-y*y)*(x*x+y)-x)/2.14e9;\n}\n\n#define FK7(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash7(vec2 p ) {\n    int x = FK7(p.x); int y = FK7(p.y);\n    return float((x-y*y)*(x*x+y)-x)/2.14e9;\n}\n\n////////////////////////////////////////////////////////////////\n// variation on the above using dot product instead of cosine\n// and another using an ivec2 which seems comparable with some\n// possible simpification of the \"to float\" mechanism\n\n#define FBI(k)   floatBitsToInt(dot(k,k))^floatBitsToInt(k)\n\nfloat vash(vec2 p) {\n#if 0\n  int x = FBI(p.x); int y = FBI(p.y);\n  return float((x-y*y)*(x*x+y)-x)/2.14e9;\n#else\n  ivec2 q = FBI( p );\n  // alternative: simplify a lot...\n  return float( q * q * q ) / 2.14e9;\n  // alternative: simplify a bit...\n  //return float( q * q - 2 * q * q * q + q * q * q * q ) / 2.14e9;\n  // alternative: multiply by dot product...\n  //return float( q * ( q.x * q.x + q.y * q.y ) ) / 2.14e9;\n  // original version:\n  return float((q.x-q.y*q.y)*(q.x*q.x+q.y)-q.x)/2.14e9;\n#endif\n}\n\n////////////////////////////////////////////////////////////////\n// this is sort of what I usually use:\n\nfloat hashV( in vec2 uv ) {\n    vec3 q = fract( uv.xyx * vec3( 19.191, 53.733, 73.761 ) );\n    q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );\n    return fract(  q.x * q.y + q.y * q.z );\n}\n\n////////////////////////////////////////////////////////////////\n// this is from https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n////////////////////////////////////////////////////////////////\n// this is from https://thebookofshaders.com/11/\n\nfloat random( in vec2 st ) {\n    return fract(\n        sin(\n            dot( st, vec2( 12.9898, 78.233 ) )\n        ) * 43758.5453123\n    );\n}\n\n////////////////////////////////////////////////////////////////\n// main function\n\nvoid mainImage( out vec4 fragColor, in vec2 p ) {\n    vec2 uv = p / RZ.xy + iTime * SPEED;\n    vec3 color = RED;\n    \n    #ifdef TEST_SCALING\n        switch( int( mod( iTime, 10. ) / 2. ) ) {\n            case 1: uv *= TINY; color = GRN; break; // small values\n            case 2: uv *= HUGE; color = BLU; break; // large values\n        }\n    #else\n        color = HILO.xxx;\n    #endif \n    \n    float h;\n    switch( int( p.x * 6. / RZ.x ) ) {\n        case 0: h = hash( uv ); break;\n        case 1: h = hash7( uv ); break;\n        case 2: h = vash( uv ); break;\n        case 3: h = hashV( uv ) ; break;\n        case 4: h = hash12( uv ); break;\n        case 5: h = random( uv ); break;\n    }\n    \n    float line = step( mod( p.x + 1., RZ.x / 6. ), 2. );\n    color = mix( h * color, RED, line );\n    fragColor = vec4( color, 1. );\n}\n\n// EOF\n////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"}]}