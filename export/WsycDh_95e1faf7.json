{"ver":"0.1","info":{"id":"WsycDh","date":"1602670564","viewed":113,"name":"Example 34 - wave-simulation","username":"jt","description":"A basic wave-simulation.\nMore info [url]https://en.wikipedia.org/wiki/Wave_equation[/url]\n(If nothing happens reset time)","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["example","wave","simulation","rendertotexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) + 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define scale 1.0\n\nvoid mainImage( out vec4 Output, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    if(iTime < 1.0)\n    {\n        //Output.z = 0.5 * step(length(2.0 * fragCoord/res.y - 1.0), 0.125);\n        Output.z = exp(-pow(10.0 * length(2.0 * fragCoord/res.y - 1.0), 2.0));\n        Output.x = 0.0;\n        Output.y = 0.0;\n    }\n    else\n    {\n        vec3 Center = texelFetch(iChannel0, ivec2(mod(fragCoord, res)), 0).xyz;\n        vec3 Left = texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(-1.0, 0.0), res)), 0).xyz;\n        vec3 Right = texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(+1.0, 0.0), res)), 0).xyz;\n        vec3 Down = texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(0.0, -1.0), res)), 0).xyz;\n        vec3 Up = texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(0.0, +1.0), res)), 0).xyz;\n        Output.z = Center.z + (Center.x - Right.x + Center.y - Up.y) * iTimeDelta * scale;\n        Output.x = Center.x + (Left.z - Center.z) * iTimeDelta * scale;\n        Output.y = Center.y + (Down.z - Center.z) * iTimeDelta * scale;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}