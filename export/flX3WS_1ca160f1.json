{"ver":"0.1","info":{"id":"flX3WS","date":"1622682809","viewed":76,"name":"Worley Noise 2D __","username":"Envy24","description":"noise, random, worley, cellular","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","worley","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* playlist: https://www.shadertoy.com/playlist/sXfSDS */\n\n/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample2DHashUI32(uint x, uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * enthropy2 + x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n    \n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n\nfloat WorleyNoise2D(float u, float v)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n\n    float minDistance = 3.40282347e+37f; // FL_MAX = 3.40282347e+38f\n\n    for (float y = -1.0f; y < 2.0f; y += 1.0f)\n    {\n        for (float x = -1.0f; x < 2.0f; x += 1.0f)\n        {\n            // Pseudorandom sample coordinates in corresponding cell.\n            float xSample = x + sample2DHashUI32(uint(u + x), uint(v + y));\n            float ySample = y + sample2DHashUI32(uint(u + x), uint(v + y));\n\n            // Distance from pixel to pseudorandom sample.\n            //float _distance = \n                //sqrt(\n                    //(fractU - xSample) * (fractU - xSample) +\n                    //(fractV - ySample) * (fractV - ySample));\n                    \n            float _distance = \n                    (fractU - xSample) * (fractU - xSample) +\n                    (fractV - ySample) * (fractV - ySample);\n\n            // Mistance from pixel to pseudorandom sample.\n            minDistance = min(minDistance, _distance);\n        }\n    }\n\n    return minDistance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;\n    \n    if (fragCoord.x < iResolution.x * 0.5) { uv = fragCoord/iResolution.xy * 6.0f; }\n    else { uv = fragCoord/iResolution.xy * 18.0f; }\n\n    float _u = uv.x + iMouse.x * 0.1f + iTime * 0.1f;\n    float _v = uv.y + iMouse.y * 0.1f + iTime * 0.2f;\n\n    float gray = WorleyNoise2D(_u, _v) * 0.5f;\n    gray += WorleyNoise2D(_u * 2.054f, _v * 2.210f) * 0.25f;\n    gray += WorleyNoise2D(_u * 4.554f, _v * 4.710f) * 0.125f;\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"}]}