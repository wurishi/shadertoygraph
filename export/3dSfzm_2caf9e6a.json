{"ver":"0.1","info":{"id":"3dSfzm","date":"1589724533","viewed":128,"name":"AreaLight","username":"a451107390","description":"area light","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["arealight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// create time : 2020-05-17\n// author : samuelfu\n// email : 451107390@qq.com\n\nconst float PI = 3.1415926;\nconst float TWOPI = 6.2831852;\n// SSAA Sample Points\nconst int nAASamples = 8;\nconst vec2 aaSample[nAASamples] = vec2[nAASamples]( vec2(-0.5, 0.5), vec2(0.5, 0.5), vec2(0.5, -0.5), vec2(-0.5, -0.5),\n                                    vec2(-0.25, 0.75), vec2(0.75, 0.25), vec2(0.25, -0.75), vec2(-0.75, -0.25));\n\nconst int nDiskVertices = 20;\nvec3 diskVertices[nDiskVertices];\n\nconst int lightType = 1; // 0-quad,1-sphere,2-disk\nconst bool polygonApproximate = true; // for sphere or disk light (true - polygon approximate) \nconst float scale = 0.0310; // roughness?\n// Sphere Light Parameter\nconst vec3 sphereCenter = vec3(0, 1.77, 0);\nconst float sphereRadius = 0.21;\n// Disk Light Parameter\nconst vec3 diskCenter = vec3(0, 1.98, 0);\nconst float diskRadius = 0.31;\nconst vec3 diskNormal = vec3(0, -1, 0);\n\nstruct Quad\n{\n    vec3 p1, p2, p3, p4;\n    vec3 n, col, e;\n};\n\nconst Quad Scene[6] = Quad[6](\n    Quad(vec3(-1, 0, -1), vec3(-1, 0, 1), vec3(1, 0, 1), vec3(1, 0, -1), vec3(0, 1, 0), vec3(0.725, 0.725, 0.725), vec3(0)),   //floor \n    Quad(vec3(-1, 2, -1), vec3(1, 2, -1), vec3(1, 2, 1), vec3(-1, 2, 1), vec3(0, -1, 0), vec3(0.725, 0.725, 0.725), vec3(0)),   //ceil\n    Quad(vec3(-1, 0, 1), vec3(-1, 0, -1), vec3(-1, 2, -1), vec3(-1, 2, 1), vec3(1, 0, 0), vec3(0.63, 0.065, 0.05), vec3(0)),   //left\n    Quad(vec3(1, 0, 1), vec3(1, 2, 1), vec3(1, 2, -1), vec3(1, 0, -1), vec3(-1, 0, 0), vec3(0.14, 0.45, 0.091), vec3(0)), //right\n    Quad(vec3(-1, 0, -1), vec3(1, 0, -1), vec3(1, 2, -1), vec3(-1, 2, -1), vec3(0, 0, 1), vec3(0.725, 0.725, 0.725), vec3(0)),    //back\n    Quad(vec3(-0.21, 1.98, 0.21), vec3(0.21, 1.98, 0.21), vec3(0.21, 1.98, -0.21), vec3(-0.21, 1.98, -0.21), vec3(0, -1, 0), vec3(0), vec3(17, 12, 4))\n    );\n\nbool intersectWithQuad(vec3 rayOrig, vec3 rayDir, int i, inout float t)\n{\n    Quad quad = Scene[i];\n    vec3 n = quad.n;\n\n    float A = dot(n, rayOrig);\n    float B = dot(n, rayDir);\n    float C = dot(n, quad.p3);\n    float tt = (C - A) / B;\n    if (tt < 0.0001) return false;\n    if (tt > t) return false;\n\n    vec3 pos = rayOrig + tt * rayDir;\n    if (i == 0 || i == 1)\n    {\n        if (pos.x < -1.0 || pos.x > 1.0) return false;\n        if (pos.z < -1.0 || pos.z > 1.0) return false;\n    }\n    else if (i == 2 || i == 3)\n    {\n        if (pos.y < 0.0 || pos.y > 2.0) return false;\n        if (pos.z < -1.0 || pos.z > 1.0) return false;\n    }\n    else if (i == 4)\n    {\n        if (pos.x < -1.0 || pos.x > 1.0) return false;\n        if (pos.y < 0.0 || pos.y > 2.0) return false;\n    }\n    else if (i == 5)\n    {\n        if (pos.x < -0.21 || pos.x > 0.21) return false;\n        if (pos.z < -0.21 || pos.z > 0.21) return false;\n    }\n\n    t = tt;\n\n    return true;\n}\n\nbool intersectWithSphere(vec3 rayOrig, vec3 rayDir, inout float t)\n{\n    vec3 op = rayOrig - sphereCenter;\n\n\t//float A = dot(rayDir, rayDir); //rayDir is normalized\n\tfloat B = dot(op, rayDir);\n\tfloat C = dot(op, op) - sphereRadius*sphereRadius;\n\n\tfloat delta = B*B - C;\n\tif (delta < 0.f)\n\t\treturn false;\n\n\tfloat sqrDelta = sqrt(delta);\n\tfloat t1 = -B - sqrDelta;\n\tfloat t2 = -B + sqrDelta;\n\tif(t1 > t2)\n    {\n        float tt = t1;\n        t1 = t2;\n        t2 = tt;\n    }\n    \n\tif(t2 < 0.0001 || t1 > t) return false;\n    t = t1;\n    \n    return true;\n}\n\nbool intersectWithDisk(vec3 rayOrig, vec3 rayDir, inout float t)\n{\n    float tt = (diskCenter.y - rayOrig.y) / rayDir.y;\n    if(tt < 0.0001 || tt > t) return false;\n    vec3 pos = rayOrig + tt * rayDir;\n    vec3 delta = pos - diskCenter;\n    if(dot(delta, delta) > diskRadius * diskRadius) return false;\n    t = tt;\n    \n    return true;\n}\n\nbool intersectWithScene(vec3 rayOrig, vec3 rayDir, out int id, out vec3 pos)\n{\n    int num = lightType == 0 ? 6 : 5;\n    bool intersect = false;\n    float t = 500.0;\n    for (int i = 0; i < num; ++i)\n    {\n        if (intersectWithQuad(rayOrig, rayDir, i, t))\n        {\n            id = i;\n            intersect = true;\n        }\n    }\n    \n    if(lightType == 1)\n    {\n     \tif(intersectWithSphere(rayOrig, rayDir, t))\n        {\n        \tid = 5;\n            intersect = true;\n        }\n    }\n    else if(lightType == 2)\n    {\n     \tif(intersectWithDisk(rayOrig, rayDir, t))\n        {\n            id = 5;\n            intersect = true;\n        }\n    }\n    \n\n    if (intersect)\n    {\n        pos = rayOrig + t * rayDir;\n    }\n\n    return intersect;\n}\n\nvec3 toLocal(vec3 u, vec3 n, vec3 w, vec3 v)\n{\n    return vec3(dot(u, v), dot(n, v), dot(w, v));\n}\n\nvec3 toWorld(vec3 u, vec3 n, vec3 w, vec3 v)\n{\n \treturn v.x * u + v.y * n + v.z * w;   \n}\n\nvoid makeCoordinate(vec3 n, out vec3 u, out vec3 w)\n{\n    //make coordinate\n    if (abs(n.x) > abs(n.y))\n    {\n        float invLen = 1.0 / sqrt(n.x * n.x + n.z * n.z);\n        w = vec3(n.z * invLen, 0.0, -n.x * invLen);\n    }\n    else\n    {\n        float invLen = 1.0 / sqrt(n.y * n.y + n.z * n.z);\n        w = vec3(0.0, n.z * invLen, -n.y * invLen);\n    }\n    u = cross(w, n);   \n}\n\nvoid InitDiskVertices()\n{\n\tfor(int i = 0; i < nDiskVertices; ++i)\n    {\n     \tfloat angle = float(-i) / float(nDiskVertices - 1) * TWOPI;\n        diskVertices[i] = vec3(cos(angle), 0, sin(angle));\n    }\n}\n\nfloat integralEdge(vec3 edge1, vec3 edge2)\n{\n    vec3 n = normalize(cross(edge1, edge2));\n    float theta = acos(clamp(dot(edge1, edge2), -1.0, 1.0));\n    return -n.y * theta * 0.5;\n}\n\nfloat calcQuadFormFactor(vec3 u, vec3 n, vec3 w, mat3 mInv, Quad light, vec3 pos)\n{\n    vec3 edge[4];\n    edge[0] = normalize(mInv*toLocal(u, n, w, light.p1 - pos));\n    edge[1] = normalize(mInv*toLocal(u, n, w, light.p2 - pos));\n    edge[2] = normalize(mInv*toLocal(u, n, w, light.p3 - pos));\n    edge[3] = normalize(mInv*toLocal(u, n, w, light.p4 - pos));\n    \n    float formFactor = 0.0;\n    formFactor += integralEdge(edge[0], edge[1]);\n    formFactor += integralEdge(edge[1], edge[2]);\n    formFactor += integralEdge(edge[2], edge[3]);\n    formFactor += integralEdge(edge[3], edge[0]);\n    \n    return formFactor;\n}\n\nfloat calcFormfactorForDiskNavie(vec3 u, vec3 n, vec3 w, mat3 mInv, vec3 pos, vec3 diskCenter, vec3 diskNormal, float diskRadius)\n{\n    vec3 localU, localW;\n    makeCoordinate(diskNormal, localU, localW);\n    \n    vec3 edge[nDiskVertices];\n \tfor(int i = 0; i < nDiskVertices; ++i)\n    {\n        edge[i] = toWorld(localU, diskNormal, localW, diskVertices[i] * diskRadius) + diskCenter; \n    \tedge[i] = normalize(mInv*toLocal(u, n, w, edge[i] - pos)); \n    }\n    \n    float formFactor = 0.0;\n    for(int i = 0; i < nDiskVertices - 1; ++i)\n    {\n        vec3 e1 = edge[i];\n        vec3 e2 = edge[i + 1];\n     \tformFactor += integralEdge(e1, e2);   \n    }\n    \n    return formFactor;\n}\n\nfloat calcFormfactorForDisk(vec3 u, vec3 n, vec3 w, mat3 mInv, vec3 pos, vec3 diskCenter, vec3 diskNormal, float diskRadius)\n{\n \tvec3 posToLight = diskCenter - pos;\n    vec3 tangent, bitangent;\n    makeCoordinate(diskNormal, tangent, bitangent);\n    tangent *= diskRadius;\n    bitangent *= diskRadius;\n    vec3 boundsPos[4];\n    boundsPos[0] = posToLight + tangent + bitangent;\n    boundsPos[1] = posToLight + tangent - bitangent;\n    boundsPos[2] = posToLight - tangent - bitangent;\n    boundsPos[3] = posToLight - tangent + bitangent;\n    // to local space\n    boundsPos[0] = normalize(mInv*toLocal(u, n, w, boundsPos[0]));\n    boundsPos[1] = normalize(mInv*toLocal(u, n, w, boundsPos[1]));\n    boundsPos[2] = normalize(mInv*toLocal(u, n, w, boundsPos[2]));\n    boundsPos[3] = normalize(mInv*toLocal(u, n, w, boundsPos[3]));\n    vec3 averageDir = (normalize(boundsPos[0]) + normalize(boundsPos[1])\n                    + normalize(boundsPos[2]) + normalize(boundsPos[3])) * 0.25;\n    \n    float projectedArea = 0.0;\n    projectedArea += integralEdge(boundsPos[0], boundsPos[1]);\n    projectedArea += integralEdge(boundsPos[1], boundsPos[2]);\n    projectedArea += integralEdge(boundsPos[2], boundsPos[3]);\n    projectedArea += integralEdge(boundsPos[3], boundsPos[0]);\n                \n    float area = 4.0 * diskRadius * diskRadius;\n    float ratio = projectedArea / area;\n    float formFactor = PI * diskRadius * diskRadius * ratio;\n    \n    return formFactor;\n}\n\nfloat calcFormfactorForCircle(vec3 u, vec3 n, vec3 w, vec3 pos, vec3 diskCenter, vec3 diskNormal, vec3 diskRadius)\n{\n \tvec3 lightDir = normalize(pos - diskCenter);\n    vec3 localW = dot(lightDir, diskNormal) * diskNormal;\n    return 0.0;\n}\n\nvec3 render(vec3 rayOrig, vec3 rayDir)\n{\n    int id;\n    vec3 pos;\n    bool intersect = intersectWithScene(rayOrig, rayDir, id, pos);\n    if (intersect)\n    {\n        Quad light = Scene[5];\n        Quad quad = Scene[id];\n        if (id == 5) return quad.e;\n\t\t\n        if(id != 4)\n        { \t// lambert\n            vec3 n = quad.n, u, w;\n            makeCoordinate(n, u, w);\n            mat3 identity = mat3(vec3(1,0,0),vec3(0,1,0),vec3(0,0,1));\n\n            float formFactor = 0.0;\n            if(lightType == 0)\n            {\n                formFactor = calcQuadFormFactor(u, n, w, identity, light, pos);\n            }\n            else if(lightType == 1)\n            {\n                if(polygonApproximate)\n                {\n                    vec3 posToLight = sphereCenter - pos;\n                    float lenSq = dot(posToLight, posToLight);\n                    float numerator = sqrt(lenSq - sphereRadius * sphereRadius);\n                    float costheta = numerator / sqrt(lenSq);\n                    float radius = sphereRadius * costheta;\n                    vec3 normalizedDir = normalize(posToLight);\n                    vec3 center = pos + normalizedDir * numerator * costheta;\n                    formFactor = calcFormfactorForDiskNavie(u, n, w, identity, pos, center, -normalizedDir, radius); \n                }\n                else\n                {\n                    vec3 posToLight = sphereCenter - pos;\n                    float radius = sphereRadius / length(posToLight);\n                    float diskArea = PI * radius * radius;\n                    formFactor = diskArea * dot(n, normalize(posToLight));\n                }\n            }\n            else if(lightType == 2)\n            {\n                if(polygonApproximate)\n             \t\tformFactor = calcFormfactorForDiskNavie(u, n, w, identity, pos, diskCenter, diskNormal, diskRadius); \n                else\n             \t\tformFactor = calcFormfactorForDisk(u, n, w, identity, pos, diskCenter, diskNormal, diskRadius);   \n            }\n\n            vec3 diff = quad.col / PI * light.e * formFactor;\n            return diff;\n        }\n        else\n        {\n            // ggx\n            vec3 n = quad.n, u, w;\n            vec3 v = -rayDir;\n            vec3 reflectDir = 2.0 * dot(v, n) * n - v;\n            n = reflectDir;\n            makeCoordinate(n, u, w);\n\n            mat3 m = mat3(\n                vec3(scale,   0,   0),\n                vec3(    0,   1,   0),\n                vec3(    0,   0,   scale)\n            );\n\t\t\tmat3 mInv = inverse(m);\n            \n            float formFactor = 0.0;\n            if(lightType == 0)\n            {\n            \tformFactor = calcQuadFormFactor(u, n, w, mInv, light, pos);\n            }\n            else if(lightType == 1)\n            {\n                vec3 posToLight = sphereCenter - pos;\n                vec3 normalizedDir = -normalize(posToLight);\n                \n                if(polygonApproximate)\n                    formFactor = calcFormfactorForDiskNavie(u, n, w, mInv, pos, sphereCenter, normalizedDir, sphereRadius);   \n                else\n                \tformFactor = calcFormfactorForDisk(u, n, w, mInv, pos, sphereCenter, normalizedDir, sphereRadius);   \n            }\n            else if(lightType == 2)\n            {\n                if(polygonApproximate)\n             \t\tformFactor = calcFormfactorForDiskNavie(u, n, w, mInv, pos, diskCenter, diskNormal, diskRadius); \n                else\n             \t\tformFactor = calcFormfactorForDisk(u, n, w, mInv, pos, diskCenter, diskNormal, diskRadius);   \n            }\n\n            vec3 spec = vec3(1.0) / PI * light.e * formFactor;\n            \n            return spec;\n        }\n    }\n    else\n    {\n        return vec3(0, 0, 0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(lightType != 0 && polygonApproximate)\t\n    \tInitDiskVertices();\n    \n    // View Matrix\n    vec2 offset = (iMouse.xy / iResolution.xy - 0.5) * 3.0;\n    vec3 eye = vec3(offset.x, 1.0 + offset.y, 6.8);\n    vec3 center = vec3(0, 1, 0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 forward = normalize(eye - center);\n    vec3 right = normalize(cross(up, forward));\n    up = cross(forward, right);\n\n    // Projection Matrix\n    float fov = 19.5, near = 0.1, far = 100.0, aspect = 1.7777777778;\n    float height = tan(fov * 0.5 * 0.0174532925198889) * near;\n    float width = height * aspect;\n    mat4 proj = mat4(vec4(near / width, 0, 0, 0),\n        vec4(0, near / height, 0, 0),\n        vec4(0, 0, -(far + near) / (far - near), -2.0 * far * near / (far - near)),\n        vec4(0, 0, -1, 0));\n    mat4 invProj = inverse(transpose(proj));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - vec2(1.0);\n\t\n    vec3 outColor = vec3(0);\n    // SSAA\n    for(int i = 0; i < nAASamples; ++i)\n    {\n        vec3 rayOrig = eye;\n        vec2 aaOffset = aaSample[i] / iResolution.xy;\n        vec3 rayDir = normalize((invProj * vec4(uv + aaOffset, -1.0, 1.0)).xyz);\n        rayDir = toWorld(right, up, forward, rayDir);\n\n        vec3 col = render(rayOrig, rayDir);\n\n        //ACES\n        vec3 c = col - vec3(0.004);\n        c = max(col, vec3(0.0));\n        c = (c * (6.2 * c + 0.5)) / (c * (6.2 * c + 1.7) + 0.06);\n        col = c;\n        \n        outColor += col / float(nAASamples);\n    }\n\n    // Output to screen\n    fragColor = vec4(outColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}