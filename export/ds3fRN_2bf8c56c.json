{"ver":"0.1","info":{"id":"ds3fRN","date":"1696913367","viewed":60,"name":"Fork Fork yetAn DigitalSha 350","username":"DigitalShadow","description":"yetAnotherRaymarcher","likes":1,"published":1,"flags":4,"usePreview":0,"tags":["yetanotherraymarcher"],"hasliked":0,"parentid":"ds3fR4","parentname":"Fork yetAnother DigitalSha 985"},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159;\n\nstruct Surface\n{\n    float sd;\n    vec3 col;\n};\n\nmat3 rotX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3\n    (\n        vec3(1., 0., 0.),\n        vec3(0., c , -s),\n        vec3(0 , s ,  c)\n    );\n}\n\nmat3 rotY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3\n    (\n        vec3(c , 0., s ),\n        vec3(0., 1., 0.),\n        vec3(-s, 0., c )\n    );\n}\n\nmat3 rotZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3\n    (\n        vec3(c , -s, 0.),\n        vec3(s ,  c, 0.),\n        vec3(0., 0., 1.)\n    );\n}\n\nmat3 identity = mat3(\n    vec3(1., 0., 0.),\n    vec3(0., 1., 0.),\n    vec3(0., 0., 1.)\n);\n\nSurface sdFloor(vec3 p, vec3 col)\n{\n    float d = p.y + 1.;\n    return Surface(d, col);\n}\n\nSurface sdBox(vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n    p = (p - offset) * transform;\n    vec3 q = abs(p) - b;\n    float d = length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n    return Surface (d, col); \n}\n\nSurface sdTorus(vec3 p, vec3 t, vec3 offset, vec3 col, mat3 transform)\n{\n    p = (p - offset) * transform;\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    float d = length(q)-t.y;\n    return Surface (d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2)\n{\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\nSurface sdScene(vec3 p)\n{\n    vec3 objOrigin = vec3(0., 0.5, 0.);\n    vec3 floorColor = vec3 (1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    vec3 boxColor = vec3(1., 0., 0.);\n    vec3 torusColor = vec3(0., 0., 1.);\n    \n    mat3 t = identity; \n    t *= rotY(iTime/2.);\n    t *= rotX(iTime/3.);\n    \n\n    vec3 pR = p * t;\n    float s = texture(iChannel0, vec2((mod(pR.y + iTime / 10., 1.)/25.)+0.0, 0.25)).r;\n    s *= 0.5;\n    t *= rotZ(iTime/5. + pR.z*sin(iTime) + pR.x*cos(iTime));\n  \n    Surface co = sdFloor(p, floorColor);\n    Surface box = sdBox(p, vec3(1.), objOrigin, boxColor, t);\n    Surface torus = sdTorus(p, vec3(1., .5, .5), objOrigin, torusColor, t); \n    \n    \n    \n    float mixObj = 0.5 + 0.5*sin(iTime+s*3.141);\n    \n    Surface obj = Surface\n    (\n        mix(box.sd, torus.sd, mixObj), \n        mix(box.col, torus.col, mixObj)\n    );\n    \n    //co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4.), vec3(1., 0., 0.),  rotY(iTime*2.)*rotX(iTime)));\n    //co = minWithColor(co, sdTorus(p, vec3(1., .5, .5), vec3(0, 0.5, -4.), vec3(0., 0., 1.),  rotY(iTime*2.)*rotX(iTime)));\n    \n    co = minWithColor(co, obj);\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end)\n{\n    float depth = start;\n    Surface co;\n    \n    for (int i=0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > end) break;\n    }\n    \n    co.sd = depth;\n    return co;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * sdScene(p + e.xyy).sd +\n        e.yyx * sdScene(p + e.yyx).sd +\n        e.yxy * sdScene(p + e.yxy).sd +\n        e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n   vec3 backgroundColor = vec3(0.835, 1., 1.);\n   \n   vec3 cam = vec3(5. * sin(iTime/7.), 0., 5. * cos(iTime/7.));\n   \n   vec3 col = vec3(0.);\n   vec3 ro = vec3(0., 0., 0.);          //ray origin\n   ro -= cam;\n   vec3 rd = normalize(vec3(uv, -1));   //ray direction\n   rd *= rotY(iTime / 7. + PI);\n   \n   \n   Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n   \n   if (co.sd > MAX_DIST)\n   {\n       col = backgroundColor;\n   } \n   else\n   {\n       vec3 p = ro + rd * co.sd;\n       vec3 normal = calcNormal(p);\n       vec3 lightPosition = vec3 (-10. * sin(iTime / 7.), 2., -10. * cos(iTime/7.));\n       vec3 lightDirection = normalize(lightPosition - p);\n       float dif = clamp(dot(normal, lightDirection), 0.3, 1.);    //diffuse reflection\n       col = dif * co.col + backgroundColor * .2;                  //Add a bit of bg color to diffuse\n   }\n   \n   fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}