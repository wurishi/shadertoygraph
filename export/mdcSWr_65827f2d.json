{"ver":"0.1","info":{"id":"mdcSWr","date":"1679630635","viewed":195,"name":"Kosmaj","username":"foxthreefire","description":"Kosmaj (https://www.spomenikdatabase.org/kosmaj)","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["voronoi","trees","firework","sparkler","statue","serbia","spomenik","kosmaj","yugoslavia"],"hasliked":0,"parentid":"DssXDM","parentname":"Kosmaj_test"},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// draw sub glitters\n// composite\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvAspect = fragCoord / iResolution.y;\n    vec3 center = GetSparkCenter(time);\n    vec4 subGlitterCol = vec4(0);\n\n    vec4 colA = texture(iChannel0, uv);\n    vec4 colC = texture(iChannel2, uv);\n    vec4 colD = texture(iChannel3, uv);\n    \n    if (center.z < 1.0 && colD.a > 0.0)\n    {\n        vec2 subGlitterCenter = colD.rg;\n        // draw sub glitters\n        if (sdCircle(uvAspect - subGlitterCenter, SUBGLITTER_RADIUS) < 0.0)\n        {\n            float subSubGlitterAmount = 0.0;\n            subGlitterCol = sparks(uvAspect, subGlitterCenter, SUBGLITTER_RADIUS, vec2(0.13, 0.8), time, iChannel1, 0.4 + 0.1 * cos(hash2(uvAspect).x * 2.0 * time), subSubGlitterAmount);\n        }\n    }\n    \n    vec3 sparkCol = mix(colC.rgb, subGlitterCol.rgb, subGlitterCol.a);\n    vec3 col = colA.rgb + sparkCol.rgb;\n    //col = 0.0 * colA.rgb + 0.0 * colC.rgb /** (colC.a == 0.0 ? 1.0 : 0.0)*/ + 1.0 * colD.rgb;\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// util\n#define cmod(x,  r) (mod(x + 0.5 *r, r) - 0.5 * r)\n#define PI 3.1415926\n\n#define SPARK_RADIUS 0.4\n#define GLITTER_RADIUS 0.4\n#define SUBGLITTER_RADIUS 0.04\n\n// https://www.shadertoy.com/view/4tByz3\nvec2  hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\nvec3  hash3( vec3 p ) { return fract(sin(p)*vec3(338.5453123,278.1459123,191.1234)); }\n\nfloat dot2(in vec3 v ) \n{ \n    return dot(v,v); \n}\n\nfloat dot2(in vec2 v ) \n{ \n    return dot(v,v); \n}\n\nfloat fresnell(vec3 nor, vec3 rd, float power)\n{\n    return pow((1.0 - clamp(dot(nor, rd), 0.0, 1.0)), power);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    return vec2(smin(a.x, b.x, k), a.x < b.x ? a.y : b.y);\n}\n\nvec2 xmin( vec2 a, vec2 b)\n{\n    return vec2(min(a.x, b.x), a.x < b.x ? a.y : b.y);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nvec2 smax( vec2 a, vec2 b, float mixy, float k )\n{\n    return vec2(smax(a.x, b.x, k), a.x > 0.0 && b.x > 0.0 ? mix(a.y, b.y, mixy) : (a.x > b.x ? a.y : b.y));\n}\n\nvec2 xmax( vec2 a, vec2 b, float mixy)\n{\n    return vec2(max(a.x, b.x), a.x > 0.0 && b.x > 0.0 ? mix(a.y, b.y, mixy) : (a.x > b.x ? a.y : b.y));\n}\n\nvec2 xmax(vec2 a, vec2 b)\n{\n    return vec2(max(a.x, b.x), a.x > b.x ? a.y : b.y);\n}\n\nfloat noise2d( sampler2D tex, in vec2 x )\n{\n    return textureLod(tex,(x+0.5)/32.0,0.0).x;\n}\n\nfloat fbm2d( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise2d(tex,x); x*=2.01;\n    f += 0.2500*noise2d(tex,x); x*=2.01;\n    f += 0.1250*noise2d(tex,x); x*=2.01;\n    f += 0.0625*noise2d(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\n\nfloat noise3d( sampler3D tex, in vec3 x )\n{\n    return textureLod(tex,(x+0.5)/64.0,0.0).x;\n}\n\nfloat fbm3d( sampler3D tex, in vec3 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise3d(tex,x); x*=2.01;\n    f += 0.2500*noise3d(tex,x); x*=2.01;\n    f += 0.1250*noise3d(tex,x); x*=2.01;\n    f += 0.0625*noise3d(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\n\n// primitive\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdRoundedBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\nfloat sdHeart(vec3 q, float r )\n{\n    q.y -= r;\n    float x = abs(q.z);\n    float y = q.y;\n    float z = q.x;\n    y = 4.0 + y*1.2 - x*sqrt(max((20.0-x)/15.0,0.0));\n    z *= 2.0 - y/15.0;\n    float d = sqrt(x*x+y*y+z*z) - r;\n    return d/3.0;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdQuad(in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4, float thickness)\n{\n    #if 1\n    // handle ill formed quads\n    if( dot( cross( v2-v1, v4-v1 ), cross( v4-v3, v2-v3 )) < 0.0 )\n    {\n        vec3 tmp = v3;\n        v3 = v4;\n        v4 = tmp;\n    }\n    #endif\n\n    \n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v43 = v4 - v3; vec3 p3 = p - v3;\n    vec3 v14 = v1 - v4; vec3 p4 = p - v4;\n    vec3 nor = cross( v21, v14 );\n\n    float result = sqrt((sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v43,nor),p3)) + \n                  sign(dot(cross(v14,nor),p4))<3.0) \n                  ?\n                  min( min( dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                            dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                       min( dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3),\n                            dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) ))\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor));\n    return result - thickness;\n}\n\n// 2d primitives\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float id = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - id*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (id<0.5 || p.x>0.0) ? p : -p;\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdQuad( in vec2 p, in vec2 v[4] )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n// operations\nfloat opRound2D( float d, in float r )\n{\n  return d - r;\n}\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\n\nfloat opExtrussionY( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec2 opRot2D(vec2 p, float degree)\n{\n    float rad = radians(degree);\n    float s = sin(rad);\n    float c = cos(rad);\n    return vec2(p.x*c-p.y*s, p.x*s+p.y*c);\n}\n\nvec3 opRotY(vec3 p, float degree)\n{\n    vec2 res = opRot2D(p.xz, degree);\n    return vec3(res.x, p.y, res.y);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec3 opRepXZ(vec3 p, vec3 c)\n{\n    vec2 res = mod(p.xz+0.5*c.xz,c.xz)-0.5*c.xz;\n    return vec3(res.x, p.y, res.y);\n}\n\nvec2 opRepOriginXZ(vec3 p, vec3 c)\n{\n    vec3 origin = floor((p + 0.5*c)/c) * c;\n    return vec2(origin.x, origin.z);\n    //ivec2 grid = ivec2((p.xz+0.5*c.xz)/c.xz);\n    //return vec2(float(grid.x) * c.x, float(grid.y) * c.z) - 0.5*c.xz;\n}\n\n// sparkler\nconst vec2 pBegin = vec2(1.3, 0.6);\nconst vec2 pEnd = vec2(1.6, -0.1);\nconst vec2 pCoatingEnd = mix(pBegin, pEnd, 0.6);\nconst vec2 pHandleBegin = mix(pBegin, pEnd, 0.61);\n\nvec3 GetSparkCenter(float time)\n{\n    // z > 1 if burnt out\n    float speed = 0.008 * time;\n    vec2 noise2 = hash2(vec2(time, time * time));\n    return vec3(mix(pBegin, pCoatingEnd, min(1.0, speed)), speed + 0.05 * (noise2.x + noise2.y));\n}\n\nvec4 sparks(vec2 pos, vec2 center, float radius, vec2 variation, float time, sampler2D tex, float amount, out float subSparkAmount)\n{\n    float alpha = 0.0f;\n    vec2 dif = pos - center;\n    float dis = length(dif);\n    vec2 dir = normalize(dif);\n    float noise = texture(tex, (0.5 * dir.yx + 0.5) + variation).r;\n    vec3 noise3A = hash3(10.0 * noise * time);\n    vec3 noise3B = hash3(5.0 * noise * time);\n    vec3 col = vec3(0.7, 0.3, 0.0) + vec3(0.2, 0.3, 0.2) * noise3A;\n    float r = radius * noise;\n    subSparkAmount = 0.0;\n    if (sdCircle(dif, r) < 0.0)\n    {\n        if (texture(tex, 1.0 * (fract(time) + (0.5 * dir + 0.5))).r > 1.0 - amount)\n        {\n            alpha = 0.7f + 0.3f * noise3B.x;\n            subSparkAmount = alpha * step(r - 0.1, dis) * noise3B.y;\n        }\n    }\n    return vec4(col, alpha);\n}\n\nfloat PackTwoUnormInOneFloat(vec2 uv)\n{\n    uvec2 uUV = uvec2(uv * float(1 << 16));\n    uUV = clamp(uUV, uvec2(0), uvec2(0xffff));\n    uint packeduUV = ((uUV.x & 0xffffu) << 16) | (uUV.y & 0xffffu);\n    return uintBitsToFloat(packeduUV);\n}\n\nvec2 UnpackOneFloatInTwoUnorm(float packed)\n{\n    uint packeduUV = floatBitsToUint(packed);\n    uvec2 uUV = uvec2((packeduUV & 0xffff0000u) >> 16, packeduUV & 0xffffu);\n    return vec2(uUV) / float(1 << 16);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define HIT_IF_SMALLER 0.000001\n#define TMIN 0.01\n#define TMAX 20.0\n\n#define SUN_X 0.6\n#define SUN_Y 0.4\n#define SUN_Z 0.2\n\n#define DEFAULT 1.0\n#define WHITE 2.0\n#define BLACK 3.0\n#define RED 4.0\n#define TREE 5.0\n#define TRUNK 6.0\n#define STATUE 7.0\n#define PEDESTAL 8.0\n\n#define GRID_SIZE 2.5\n#define HALF_GRID_SIZE (0.5 * GRID_SIZE)\n\n#define DEBUG_NORMAL 0\n#define CAMERA_CONTROL 0\n\nvec4 sparkler(vec2 pos, float time)\n{\n    vec3 col = vec3(1, 1, 0);\n    float alpha = 0.0f;\n    \n    vec2 pBurntEnd = GetSparkCenter(time).xy;\n    float dHandle = opRound2D(sdOrientedBox(pos, pHandleBegin, pEnd, 0.0001), 0.003);\n    float dCoating = smin(opRound2D(sdOrientedBox(pos, pBegin, pCoatingEnd, 0.0001), 0.005), dHandle, 0.01);\n    float dBurnt = opRound2D(sdOrientedBox(pos, pBegin, pBurntEnd, 0.0002), 0.005);\n    if (dBurnt < 0.0)\n    {\n        col = vec3(0.5, 0.4, 0.3) * texture(iChannel1, vec3(1.0 * pos, 0.0)).rgb;\n        alpha = 1.0f;\n    }\n    else if (dHandle < 0.0)\n    {\n        col = vec3(0.3,0.3,0.3)  * texture(iChannel0, pos).rgb;\n        alpha = 1.0f;\n    }\n    else if (dCoating < 0.0)\n    {\n        col = vec3(0.5,0.5,0.5) * texture(iChannel2, 0.01 * pos).rgb;\n        alpha = 1.0f;\n    }\n    \n    return vec4(col, alpha);\n}\n\nvec4 jet(vec2 pos, vec3 sky, float time)\n{\n    const float yBegin = 0.2;\n    const float yEnd = 1.3;\n    const float width = 0.01;\n    vec3 col = sky;\n    vec2 A = vec2(1.9, yBegin);\n    vec2 B = vec2(-0.3, yEnd);\n    vec2 C = B + width;\n    float alpha = 0.0;\n    float f = fract(0.02 * time);\n    float f2 = f*f;\n    float t = min(1.0, 2.5 * exp(50.0 * f - 5.0));\n    float smokeAlpha = max(0.0, 1.0 - f2);\n    float progress = mix(yBegin, yEnd, t);\n    if (sdTriangle(pos, A, B, C) < 0.0)\n    {\n        alpha = smokeAlpha;\n        if (pos.y < progress)\n            col = vec3(1,0,0);\n    }\n    else if (sdTriangle(pos, A, B + width, C + width) < 0.0)\n    {\n        alpha = smokeAlpha;\n        if (pos.y < progress)\n            col = vec3(1,1,1);\n    }\n    else if (sdTriangle(pos, A, B + width * 2.0, C + width * 2.0) < 0.0)\n    {\n        alpha = smokeAlpha;\n        if (pos.y < progress)\n            col = vec3(0,0,1);\n    }\n    // float noise = texture(iChannel1, fract(0.002 * time) + pos * max(0.0001, 1.0 - fract(0.002 * time))).r;\n    float noise = texture(iChannel1, fract(0.002 * time) + vec3(pos, 0.5 + 0.5 * sin(0.03 * time)) * max(1.0, 1.0 - fract(0.002 * time))).r;\n    return vec4(col, 0.5 * alpha * noise);\n}\n\nfloat voronoi(vec2 pos)\n{\n    const vec2 cellCount = vec2(10, 10);\n    const vec2 cellSize = 1.0 / cellCount;\n    const vec2 halfCellSize = 0.5 * cellSize;\n    vec2 cellIndex = floor(pos / cellSize);\n    const float cellSizeMax = max(cellSize.x, cellSize.y);\n    float dMin = 2.0 * cellSizeMax;\n    float dMin2 = dMin;\n    for(int i = -1;i<=1;i++)\n    for(int j = -1;j<=1;j++)\n    {\n        vec2 cI = cellIndex + vec2(i, j);\n        vec3 noise3 = hash3((cI.x + cI.y) * (cI.x - cI.y));\n        vec2 c = (cI + noise3.xy) * cellSize;\n        float d = length(pos - c);\n        if(d < dMin)\n        {\n            dMin2 = dMin;\n            dMin = d;\n        }\n        else if (d < dMin2)\n            dMin2 = d;\n    }\n    //return 1.0 - vec2(dMin2 - dMin) / cellSizeMax;\n    //return (dMin / dMin2 - 0.9) < 0.01 ? vec2(0) : vec2(1);\n    return smoothstep(0.8, 1.0, dMin/dMin2);\n}\n\n// element\nvec2 ground( in vec3 pos, float atime )\n{\n    float fh = -0.1;\n    float d = pos.y - fh;\n    //float disA = 0.01*fbm2d(iChannel1,2.0*pos.xz);\n    //float disB = 0.03*fbm2d(iChannel1,0.1*pos.xz);\n    float disC = 0.008*(1.0 - voronoi(fract(pos.xz)));\n    float dis = disC;//disA + disB + disC;\n    d -= dis;\n    return vec2(d, DEFAULT);\n}\n\nvec2 base( in vec3 pos, float atime )\n{\n    // triangle vertices order: lowest, highest, the other\n    float ring = sdTriangle(opRevolution(pos, 0.0), vec2(0.85, 0), vec2(0.278, 1.08), vec2(0.56, 0.97));\n    vec2 res = vec2(ring, STATUE);\n    if (ring > HIT_IF_SMALLER)\n        return res; // early out\n        \n    float rad = radians(54.0); // radians of the pie to cut out\n    for (int i = 0;i < 5;i++)\n    {\n        float offsetDegree = 72.0 * float(i);\n        vec3 q = opRotY(pos, offsetDegree);\n        q.zy = opRot2D(q.zy, -7.0); // tilt so that wing tips are thinner\n        q.z -= 0.345; // offset the apex of the pie\n        float cut = opExtrussionY(q, sdPie(q.xz, vec2(sin(rad), cos(rad)), 3.0), 1.5);\n        res.x = max(-cut, res.x);\n    }\n    return res;\n}\n\nvec2 wing( in vec3 pos, float atime )\n{\n    //float debug = 1.0f;\n    pos.y -= 0.8;\n    \n    vec2 verts[4];\n    verts[0] = vec2(1.2, 0.6);\n    verts[1] = vec2(0.3, 0.3);\n    verts[2] = vec2(0.28, 0.5);\n    verts[3] = vec2(0.5, 1.5);\n    \n    float ring = opRound2D(sdQuad(opRevolution(pos, 0.0), verts), 0.03);\n    vec2 res = vec2(ring, STATUE);\n    if (ring > HIT_IF_SMALLER)\n        return res; // early out\n    \n    float rad = radians(40.0); // radians of the pie to cut out\n    for (int i = 0;i < 5;i++)\n    {\n        float offsetDegree = 72.0 * float(i);\n        vec3 q = opRotY(pos, offsetDegree);\n        q.zy = opRot2D(q.zy, -5.0); // tilt so that wing tips are thinner\n        q.z -= 0.2; // offset the apex of the pie\n        float cut = opExtrussionY(q, sdPie(q.xz, vec2(sin(rad), cos(rad)), 1.5), 2.0);\n        res.x = max(-cut, res.x);\n        //debug = min(cut, debug);\n    }\n    \n    vec2 vertsCut[4];\n    vertsCut[0] = vec2(1.3, 0.7);\n    vertsCut[1] = vec2(0.45, 0.5);\n    vertsCut[2] = vec2(0.45, 0.53);\n    vertsCut[3] = vec2(0.58, 1.5);\n    float ringCut = opRound2D(sdQuad(opRevolution(pos, 0.0), vertsCut), 0.05);\n    res.x = max(-ringCut, res.x);\n    \n    vec3 A = vec3(0,0.47,0.5);\n    vec3 B = A + 1.6 * (vec3(0,0.9,1) - A);\n    for (int i = 0;i < 5;i++)\n    {\n        float offsetDegree = 72.0 * float(i);\n        vec3 q = opRotY(pos, offsetDegree);\n        float cut = sdRoundCone(q, A, B, 0.26, 0.95); // it would be better if the radius are 2D\n        res.x = smax(-cut, res.x, 0.01);\n    }\n    \n    return res;\n}\n\nvec2 neck( in vec3 pos, float atime )\n{\n    float cutBaseRing = sdTriangle(opRevolution(pos, 0.0), vec2(0, 0), vec2(0, 1.19), vec2(0.56, 0.97));\n    pos.y -= 0.8;\n    \n    vec2 verts[4];\n    verts[0] = vec2(1.2, 0.6);\n    verts[1] = vec2(0.29, 0.29);\n    verts[2] = vec2(0.28, 0.5);\n    verts[3] = vec2(0.5, 1.5);\n    \n    float cutWingRing = opRound2D(sdQuad(opRevolution(pos, 0.0), verts), 0.03);\n    float res = 1.0;\n    float yOffset = 0.25;\n    float height = 0.08;\n    for (int i = 0;i < 5;i++)\n    {\n        float offsetDegree = 72.0 * float(i) + 36.0;\n        vec3 q = opRotY(pos, offsetDegree);\n        q.y -= yOffset;\n        q.z -= 0.32;\n        float merge = opExtrussionY(q, sdTriangle(q.xz, vec2(-0.1,-0.05), vec2(0.1,-0.05), vec2(0,0.13 + smoothstep(0.0, 0.5, abs(q.y - height / 2.0 + 0.02))/*smoothstep(0.0, 10.0, 3.0 * (q.y - 0.265))*/)), height);\n        res = min(merge, res);\n    }\n    res = max(-cutWingRing, res);\n    res = max(-cutBaseRing, res);\n    return vec2(res, STATUE);\n}\n\nvec2 pedestal( in vec3 pos, float atime )\n{\n    vec2 res = vec2(1.0, DEFAULT);\n    if (pos.y > 0.5)\n        return res;\n    vec2 q = opRevolution(pos, 0.0);\n    res = vec2(min(sdCappedCylinder(pos, 1.0, 0.2), sdStairs(vec2(1.5 - q.x, q.y), vec2(0.05, 0.02), 10.0)), PEDESTAL);\n    return res;\n}\n\n// idea from blackjero's https://www.shadertoy.com/view/fsXXzX\n// \"hack: use a different normal offset for trees as noise shadows are very sensitive to that\"\nfloat hash13(vec3 p3) { p3 = fract(p3 * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( vec3(3.0) - x * 2.0 ); }\n\n#define INDEXHASHOFFSET3 vec3( 137.0, 53.0, 173 )\nfloat noise13( vec3 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tfloat v000 = hash13( p000 );\n\tfloat v100 = hash13( p100 );\n\tfloat v010 = hash13( p010 );\n\tfloat v110 = hash13( p110 );\n\tfloat v001 = hash13( p001 );\n\tfloat v101 = hash13( p101 );\n\tfloat v011 = hash13( p011 );\n\tfloat v111 = hash13( p111 );\n\n\tvec3 f = fract( p ); // bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f);\n\t\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\nfloat sfbm2_13_leaf( vec3 p ) { return (noise13(p*0.8,true)+noise13(p*4.0,true)*0.6)/1.5;}\n\nvec2 statue( in vec3 pos, float atime )\n{\n    vec2 res = vec2(1.0, DEFAULT);\n    pos = opRotY(pos, 18.0);\n    \n    if (sdSphere(vec3(pos.x, pos.y - 0.8, pos.z), 1.8) >= 0.0)\n        return res; // bounding sphere early out\n    \n    pos.y += 0.14;\n    \n    vec2 dPedestal = pedestal(pos, atime);\n    \n    pos.y += 0.3;\n    \n    vec2 dBase = base(pos, atime);\n    vec2 dNeck = neck(pos, atime);\n    vec2 dWing = wing(pos, atime);\n    \n    res = xmin(dBase, res);\n    res = xmin(dWing, res);\n    res = smin(dNeck, res, 0.01);\n    \n#if !DEBUG_NORMAL\n    if (res.y == STATUE /*&& !approx*/)\n        res.x += sfbm2_13_leaf( pos * 30.0 ) * 0.005;  \n#endif\n\n    res = xmin(dPedestal, res);\n    return res;\n}\n\nvec2 treeA(vec3 pos, vec3 center, float atime, bool approx)\n{\n    float rad50 = radians(50.0);\n    float rad60 = radians(60.0);\n    float rad75 = radians(75.0);\n    vec2 res = vec2(100.0, TREE);\n    vec3 grid = vec3(GRID_SIZE,8,GRID_SIZE);\n    vec2 repOri = opRepOriginXZ(pos, grid);\n    if (length(repOri - center.xz) < 2.0)\n        return res;\n    vec3 noise3x = hash3(repOri.x*(repOri.y + 123.4));\n    vec3 noise3y = hash3(repOri.y*(repOri.x - 432.1));\n    vec3 q = opRepXZ(pos, grid);\n    q.xz = q.xz + 0.5 * (noise3x.xy * 2.0 - 1.0);\n    q.y = q.y + 0.2 * (noise3x.z * 2.0 - 1.0);\n        \n    vec3 scale = vec3(0.8, 0.6, 0.5) + vec3(0.08, 0.06, 0.04) * (noise3y * 2.0 - 1.0);\n      \n    //for (int i = -1; i <= 1; i++)\n    //for (int j = -1; j <= 1; j++)\n    {\n    //vec3 p = q + vec3(i, 0, j) * grid;\n    res.x = smin(res.x, sdCone(q - vec3(0,1.0,0), vec2(sin(rad50), cos(rad50)), scale.x), 0.2);\n    res.x = smin(res.x, sdCone(q - vec3(0,1.3,0), vec2(sin(rad60), cos(rad60)), scale.y), 0.2);\n    res.x = smin(res.x, sdCone(q - vec3(0,1.7,0), vec2(sin(rad75), cos(rad75)), scale.z), 0.2);\n    res = xmin(res, vec2(sdRoundCone(q, vec3(0,-0.2,0), vec3(0,1,0), 0.1, 0.05), TRUNK));\n    }\n#if !DEBUG_NORMAL\n    if (res.y == TREE && !approx)\n        res.x += sfbm2_13_leaf( pos * 20.0 ) * 0.03;  \n    else if (res.y == TRUNK && !approx)\n        res.x += sfbm2_13_leaf( pos * 10.0 ) * 0.01;\n#endif\n    return res;\n}\n\nvec2 treeB(vec3 pos, vec3 center, float atime, bool approx)\n{\n    vec2 res = vec2(100.0, TREE);\n    vec3 grid = vec3(GRID_SIZE,8,GRID_SIZE);\n    vec2 repOri = opRepOriginXZ(pos, grid);\n    if (length(repOri - center.xz) < 2.0)\n        return res;\n    vec3 noise3x = hash3(repOri.x * 218.0 + repOri.y * 1995.0);\n    vec3 noise3y = hash3(repOri.x * 1995.0 + repOri.y * 218.0);\n    vec3 q = opRepXZ(pos, grid);\n    q.xz = q.xz + 0.5 * (noise3x.xy * 2.0 - 1.0);\n    q.y = q.y + 0.3 * (noise3x.z * 2.0 - 1.0);\n    \n    vec3 scale = vec3(0.4,0.3,0.2) + vec3(0.05, 0.03, 0.01) * (noise3y * 2.0 - 1.0);\n        \n    //for (int i = -1; i <= 1; i++)\n    //for (int j = -1; j <= 1; j++)\n    {\n    //vec3 p = q + vec3(i, 0, j) * grid;\n    res.x = smin(res.x, sdSphere(q - vec3(0,0.7,0), scale.x), 0.2);\n    res.x = smin(res.x, sdSphere(q - vec3(0,0.9,0), scale.y), 0.2);\n    res.x = smin(res.x, sdSphere(q - vec3(0,1.2,0), scale.z), 0.2);\n    res = xmin(res, vec2(sdRoundCone(q, vec3(0,-0.2,0), vec3(0,1,0), 0.1, 0.05), TRUNK));\n    }\n#if !DEBUG_NORMAL\n    if (res.y == TREE && !approx)\n        res.x += sfbm2_13_leaf( pos * 20.0 ) * 0.03;  \n    else if (res.y == TRUNK && !approx)\n        res.x += sfbm2_13_leaf( pos * 10.0 ) * 0.01;  \n#endif\n    return res;\n}\n\nvec2 tree(vec3 pos, float atime, bool approx)\n{\n    vec2 res = vec2(100.0, TREE);\n    if (pos.y > 1.8)\n        return res; // height early out\n    \n    vec3 center = vec3(0);\n    res = treeA(pos, center, atime, approx);\n    pos.xz += vec2(1.6, 2.1);\n    center.xz += vec2(1.6, 2.1);\n    res = xmin(res, treeB(pos, center, atime, approx));\n    pos.xz += vec2(2.1, 0.2);\n    center.xz += vec2(2.1, 0.2);\n    res = xmin(res, treeA(pos, center, atime, approx));\n    return res;\n}\n\n// ray march\nvec2 map( in vec3 pos, float atime, bool approx )\n{\n    vec2 dground = vec2(100.0, DEFAULT);\n    vec2 dstatue = vec2(100.0, DEFAULT);\n    vec2 dtree = vec2(100.0, DEFAULT);\n    vec2 res = vec2(100.0, DEFAULT);\n    \n    // ground\n    dground = ground(pos, atime);\n    \n    // statue\n    dstatue = statue(pos, atime);\n    \n    // tree\n    dtree = tree(pos, atime, approx);\n    \n    res = xmin(res, dground);\n    res = xmin(res, dstatue);\n    res = xmin(res, dtree);\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, float time, bool approx )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.01;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    for( int i=0; i<512 && t<tmax; i++ )\n    {\n        vec2 h;\n        h = map( ro+rd*t, time, approx );\n        if( h.x<HIT_IF_SMALLER ) \n        {\n            res = vec2(t,h.y);\n            break;\n        }\n        t += h.x;//min(0.05, h.x);\n    }\n        \n    return res;\n}\n\n//vec3 calcNormalTree(vec3 pos, float time, bool approx)\n//{\n//    vec2 e = vec2(0.01,0.0);\n//    return normalize( vec3( \n//        tree( pos + e.xyy, time, approx ).x - tree( pos - e.xyy, time, approx ).x,\n//\t\ttree( pos + e.yxy, time, approx ).x - tree( pos - e.yxy, time, approx ).x,\n//\t\ttree( pos + e.yyx, time, approx ).x - tree( pos - e.yyx, time, approx ).x ));\n//}\n\n//vec3 calcNormal( in vec3 pos, float time, bool approx)\n//{\n//    vec2 e = vec2(0.01,0.0);\n//    return normalize( vec3( \n//        map( pos + e.xyy, time, approx ).x - map( pos - e.xyy, time, approx ).x,\n//\t\tmap( pos + e.yxy, time, approx ).x - map( pos - e.yxy, time, approx ).x,\n//\t\tmap( pos + e.yyx, time, approx ).x - map( pos - e.yyx, time, approx ).x ));\n//}\n\n// compile time optimization magic suggested by Shane, thanks!\nvec3 calcNormalTree(in vec3 p, float time, bool approx) {\n\t\n    const vec2 e = vec2(.0005, 0);\n    \n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n        vec2 res = tree(p + sgn*e6[i/2], time, approx);\n\t\tmp[i] = res.x;\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\nvec3 calcNormal(in vec3 p, float time, bool approx) {\n\t\n    const vec2 e = vec2(.0005, 0);\n    \n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n        vec2 res = map(p + sgn*e6[i/2], time, approx);\n\t\tmp[i] = res.x;\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\nvec3 GetSunDir()\n{\n    return normalize( vec3(SUN_X, SUN_Y, SUN_Z) );\n}\n\nvec3 lighting(vec3 col, vec3 pos, vec3 nor, vec3 norShadow, vec3 rd, float ks, float t, float time, bool approxShadow)\n{\n    // lighting\n    vec3  sun_lig = GetSunDir();\n    float sun_dif = clamp(dot(/*norShadow*/nor, sun_lig), 0.0, 1.0 );\n    vec3  sun_hal = normalize( sun_lig-rd );\n    float norOffset = 0.001;\n    if (approxShadow)\n        norOffset = 0.05;\n    float sun_sha = step(castRay( pos+norOffset*norShadow, sun_lig, time, approxShadow ).y,0.0);\n\tfloat sun_spe = ks*pow(clamp(dot(norShadow,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n    float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\n\tvec3 lin = vec3(0.0);\n    lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha;\n    lin += sky_dif*vec3(0.50,0.70,1.00);\n    lin += bou_dif*vec3(0.60,0.40,0.30);\n\tcol = col*lin;\n\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;    \n    col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );   \n    return col;\n}\n\nvec3 sky(vec2 uv, vec3 rd, float time)\n{\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    vec4 j = jet(uv, col, time);\n    return mix(col, j.rgb, j.a);\n}\n\nvec4 render(vec2 uv, vec3 ro, vec3 rd, float time)\n{ \n    // sky dome\n    vec3 col = sky(uv, rd, time);\n    float tdepth = TMAX; // very large value\n    vec2 res = castRay(ro, rd, time, false);\n    if( res.x>0.0 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time, false );\n        vec3 norShadow = nor;\n        vec3 ref = reflect( rd, nor );\n        tdepth = t;\n        float ks = 1.0;\n        bool approxShadow = false;\n        \n        if (res.y<DEFAULT+0.5)\n        {\n            ks = 0.9;\n            col = vec3(0.3)*texture(iChannel2, fract(pos.xz)).rgb;\n        }\n        else if (res.y<WHITE+0.5)\n        {\n            col = vec3(0.2); // white\n        }\n        else if (res.y<BLACK+0.5)\n        {\n            col = vec3(0.01); // black\n        }\n        else if (res.y<RED+0.5)\n        {\n            col = vec3(0.09, 0.008, 0.008); // red\n        }\n        else if (res.y<TREE+0.5)\n        {\n            norShadow = calcNormalTree( pos, time, true );\n            approxShadow = true;\n#if DEBUG_NORMAL            \n            col = norShadow * 0.5 + 0.5;\n#else\n            vec3 noise3 = hash3(pos);\n            col = vec3(0.05,0.5 - 0.2 * fract(noise3.x + noise3.y * noise3.z) ,0.1);\n#endif\n        }\n        else if (res.y<TRUNK+0.5)\n        {\n            ks = 0.1;\n            vec2 uv = vec2(fract(pos.y), fract(pos.x));\n            col = vec3(0.3, 0.15, 0.03)*texture(iChannel3, uv).rgb;\n        }\n        else if (res.y<STATUE+0.5)\n        {\n            ks = 0.3;\n            col = vec3(0.5, 0.6, 0.4)*texture(iChannel0, fract(pos.xz)).rgb;\n        }\n        else if (res.y<PEDESTAL+0.5)\n        {\n            ks = 0.1;\n            col = vec3(0.28,0.3,0.3)*texture(iChannel2, fract(pos.xy)).rgb;\n        }\n        else\n        {\n            col = vec3(0, 0.5, 0);\n        }\n        \n#if !DEBUG_NORMAL\n        col = lighting(col, pos, nor, norShadow, rd, ks, t, time, approxShadow);\n#endif\n    }\n    vec3 pos = ro + tdepth*rd;\n    // fog\n    vec3 fogPos = fract(0.1 * (pos + (time * 0.8) * vec3(SUN_X, 0, SUN_Z)));\n    col = mix(col, mix(0.8 + 0.2 * texture(iChannel1, fogPos).rrr, col, smoothstep(0.0, 5.0, pos.y)), smoothstep(TMIN, TMAX, tdepth));\n    // sparkler\n    vec4 sparklerCol = sparkler(uv, time);\n    col = mix(col, sparklerCol.rgb, sparklerCol.a);\n    return vec4(col, tdepth);\n}\n\n// basic\nvoid GetRoRd(vec2 fragCoord, float time, out vec3 ro, out vec3 rd)\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    time *= 0.9;\n\n    // camera\t\n    const float dist = 2.2;\n    float mouse = 0.0f;\n#if CAMERA_CONTROL\n    mouse = iMouse.x;\n#endif\n    float an = 10.57*mouse/iResolution.x + 2.5;\n    vec3  ta = vec3(0.2,0.6,0.4);\n    ro = ta + vec3( dist*cos(an), -0.5, dist*sin(an) );\n\n    // frame\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n\n    rd = normalize( p.x*cu + p.y*cv + 1.8*cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.y;\n    vec3 ro, rd;\n    \n    GetRoRd(fragCoord, time, ro, rd);\n    vec3 col = render(uv, ro, rd, time).rgb;\n    col.rgb = pow(col.rgb, vec3(0.4545));\n    \n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// draw sparks\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvAspect = fragCoord / iResolution.y;\n    vec3 center = GetSparkCenter(time);\n    vec4 sparksCol = vec4(0);\n    fragColor = vec4(0);\n    \n    if (sdCircle(uvAspect - center.xy, SPARK_RADIUS) >= 0.0)\n        return; // early out\n        \n    // sparks\n    float subSparkAmount = 0.0;\n    if (center.z < 1.0)\n    {\n        sparksCol = sparks(uvAspect, center.xy, SPARK_RADIUS, vec2(0, 0), time, iChannel0, 0.18 + 0.02 * sin(time), subSparkAmount);\n    }\n    // core\n    float sinZeroOne = 0.5 * (sin(time) + 1.0);\n    float afterBurntOut = step(1.0, center.z);\n    if (sdCircle(uvAspect - center.xy, 0.005) < 0.0)\n    {\n        sparksCol = vec4(0.98, 0.1, 0, 0.96) * (1.0 - afterBurntOut * 0.5 * sinZeroOne);\n    }\n    fragColor = vec4(mix(vec3(0), sparksCol.rgb, sparksCol.a), 0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// blur sparks\n// draw glitters\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvAspect = fragCoord / iResolution.y;\n    vec3 center = GetSparkCenter(time);\n    fragColor = vec4(0);\n    \n    if (sdCircle(uvAspect - center.xy, SPARK_RADIUS) >= 0.0)\n        return; // early out\n        \n#if 1\n    // bloom sparks\n    int bloomSize = int((5.0 / 800.0) * iResolution.x);\n    vec4 bloom = vec4(0);\n    for(int i = -bloomSize; i <= bloomSize; i++)\n    {\n        for(int j = -bloomSize; j <= bloomSize; j++)\n        {\n            vec4 col = texture(iChannel0, uv + vec2(i, j) / iResolution.xy);\n            float dis = 1.0 / length(vec2(i, j));\n            float weight = pow(dis, 1.5);\n            if (any(greaterThan(col.rgb, vec3(0))))\n                bloom += vec4(col.rgb, 1) * weight;\n        }\n    }\n    bloom = 1.0 - exp(-bloom);\n    fragColor = vec4(mix(vec3(0), bloom.rgb, bloom.a), 0.0);\n#endif\n\n\n    if (sdCircle(uvAspect - center.xy, GLITTER_RADIUS) >= 0.0)\n        return; // early out\n        \n#if 1\n    // draw glitters\n    float subGlitterAmount = 0.0;\n    vec4 glitterCol = vec4(0);\n    if (center.z < 1.0)\n    {\n        // glitters (thinner sparks)\n        glitterCol = sparks(uvAspect, center.xy, GLITTER_RADIUS, vec2(0.13, 0.8), time, iChannel1, 0.18 + 0.02 * cos(2.0 * time), subGlitterAmount);\n    }\n    \n    // pack glitter\n    if (glitterCol.a > 0.0f)\n    {\n        float packedSubsparkCenter = 0.0;\n        if (subGlitterAmount > 0.2)\n        {\n            // pack uv instead of uvAspect because they are within [0, 1]\n            packedSubsparkCenter = PackTwoUnormInOneFloat(uv);\n        }\n        fragColor = vec4(mix(fragColor.rgb, glitterCol.rgb, glitterCol.a), packedSubsparkCenter);\n    }\n#endif\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// blur glitters\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvAspect = fragCoord / iResolution.y;\n    vec3 center = GetSparkCenter(time);\n    fragColor = vec4(0);\n    \n    if (sdCircle(uvAspect - center.xy, GLITTER_RADIUS + SUBGLITTER_RADIUS) >= 0.0)\n        return; // early out\n    \n    int glitterSize = int((8.0 / 800.0) * iResolution.x);\n    vec4 glitter = vec4(0);\n    float glitterCenterDisMax = 0.0;\n    for(int i = -glitterSize; i <= glitterSize; i++)\n    {\n        for(int j = -glitterSize; j <= glitterSize; j++)\n        {\n            vec4 col = texture(iChannel0, uv + vec2(i, j) / iResolution.xy);\n            if (col.a != 0.0)\n            {\n                vec2 glitterCenter = UnpackOneFloatInTwoUnorm(col.a);\n                vec2 glitterCenterAspect = glitterCenter * iResolution.xy / iResolution.y;\n                float dis = length(glitterCenterAspect - center.xy);\n                if (dis > glitterCenterDisMax)\n                {\n                    glitterCenterDisMax = dis;\n                    glitter = vec4(glitterCenterAspect, 0, glitterCenterDisMax);\n                }\n            }\n        }\n    }\n    fragColor = glitter;\n}","name":"Buffer D","description":"","type":"buffer"}]}