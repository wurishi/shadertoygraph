{"ver":"0.1","info":{"id":"7dBSWG","date":"1620896787","viewed":126,"name":"symmetry tiling practise","username":"caogtaa","description":"It's implemented by 2 overlapped layers, but how to handle layer 2 by kind of \"symmetry\"?","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["tiling","symmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define R 2.\n#define MARGIN 2.\n#define GRIDS 4.\n\n\nfloat Circle(vec2 st, vec2 o, float r, float blur) {\n\t return smoothstep(r+blur, r, distance(st, o));\n}\n\nmat2 Rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n            sin(angle),cos(angle));\n}\n\nfloat Shape(vec2 st, float angle, float blur) {\n    // 对单个格子缩放画布\n    // scale canvas for single grid\n    float width = PI+R+MARGIN;\n    st *= width;\n    \n    // 对角镜像\n    // diagonal mirror\n    st = st.x + st.y > width ? width - st : st;\n\n    st = Rotate2d(angle) * st;\n    st = abs(st);    \n    \n    // 绘制\"头部\"。Y从R向0移动时，圆心逐渐向远处移动，使圆变形\n    // draw \"head\", shift circle origin as Y decrease to 0, deform it heart-like\n    float deform = 0.6;\n    float circle = Circle(st, vec2(PI+(st.y-R) * deform, 0.), R, blur);\n    \n    // 绘制\"颈部\"，对cos函数做缩放偏移, \"shift\"控制粗细\n    // draw \"neck\" with cosine wave, \"shift\" controls thickness\n    float shift = 0.35;\n    float cosine = -cos(st.x) * (1.-shift) + 1.+shift;\n    float cosineDist = smoothstep(blur, 0., st.y - cosine);\n    \n    float mask = st.x < PI ? cosineDist : circle;\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= GRIDS;\n\n    vec2 st = fract(uv);\n    vec2 id = floor(uv);\n    \n    float t = iTime;\n    float angle = 0.;\n    angle = sin(t*0.5) * PI;\n    float everyOther = mod(id.x + id.y, 2.);\n    \n    // 每隔一个格子初始角度偏移PI/2，为了画面衔接\n    // every other grid shift init angle by PI/2\n    angle += everyOther * PI * 0.5;\n    \n    // 每隔一个格子初始角度偏移PI/2，为了画面衔接\n    // every other grid rotate reversly\n    angle *= everyOther * 2. - 1.;\n    \n    float blur = 1./iResolution.y * GRIDS;\n    float mask = 0.;\n    mask += Shape(st, angle, blur);\n    \n    // 叠加第二层，目前没学会如何用对称的方法处理第二层。如果有请教教我\n    // overlap layer 2. how to handle layer 2 by kind of \"symmetry\"?\n\tmask += Shape(vec2(1.-st.y, st.x), -angle, blur);\n    vec3 color = vec3(mask);\n\n    // Output to screen\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}