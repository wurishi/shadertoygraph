{"ver":"0.1","info":{"id":"7tccWM","date":"1660065482","viewed":104,"name":"Mouse drag (state)","username":"mrboggieman","description":"Demo of dragging around items with the mouse (state persisted in buffers)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["mouse","state","drag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//MIT Licence\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    \n    int elementIndex = getInt(dragIndex);\n    \n    //draw circles\n    for (int i=0; i<circles.length(); i++) {\n        Circle circle = circles[i];\n\n        if (distance(uv, getVec2(circle.pos)) < getFloat(circle.radius)) {\n            vec3 col = getVec3(circle.colour);\n\n            //being dragged?\n            if (elementIndex == i) {\n                col = vec3(0.0, 1.0, 0.0);\n            }\n            \n            fragColor = vec4(col, 1.0);\n            return;\n        }\n    }\n\n    fragColor = vec4(vec3(0.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define storeInit(index, item) if (index == item.index) fragColor = item.value\n#define store(index, item, value) if (index == item.index) fragColor = value\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = toIndex(fragCoord);\n    \n    //default to the previous frame\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    \n    //store initial values\n    if (iFrame == 0) {\n        for (int i=0; i<circles.length(); i++) {\n            Circle circle = circles[i];\n            storeInit(index, circle.pos);\n            storeInit(index, circle.radius);\n            storeInit(index, circle.colour);\n        }\n        \n        storeInit(index, dragPosition);\n        storeInit(index, dragIndex);\n        return;\n    }\n    \n    //updates\n    bool mouseDrag = iMouse.z > 0.0;\n    \n    if (mouseDrag) {\n        vec2 mousePos = iMouse.xy / iResolution.y;\n        int prevDragIndex = getInt(dragIndex);\n\n        if (prevDragIndex == -1) {\n            //drag start\n            for (int i=0; i<circles.length(); i++) {\n                Circle circle = circles[i];\n\n                if (distance(mousePos, getVec2(circle.pos)) < getFloat(circle.radius)) {\n                    store(index, dragIndex, setInt(i));\n                    break;\n                }\n            }\n        } else {\n            //dragging\n            vec2 prevDragPos = getVec2(dragPosition);\n            Circle dragCircle = circles[prevDragIndex];\n            vec2 prevCirclePos = getVec2(dragCircle.pos);\n\n            store(index, dragCircle.pos, setVec2(prevCirclePos + mousePos - prevDragPos));\n        }\n\n        store(index, dragPosition, setVec2(mousePos));\n    } else {\n        //drag end\n        store(index, dragIndex, setInt(-1));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//must be macros to be used in constants\n#define setFloat(value) vec4(value, 0.0, 0.0, 0.0)\n#define setVec2(value) vec4(value, 0.0, 0.0)\n#define setVec3(value) vec4(value, 0.0)\n#define setVec4(value) value\n#define setBool(value) vec4(float(value), 0.0, 0.0, 0.0)\n#define setBvec2(value) vec4(vec2(value), 0.0, 0.0)\n#define setBvec3(value) vec4(vec3(value), 0.0)\n#define setBvec4(value) vec4(value)\n#define setUint(value) vec4(float(value), 0.0, 0.0, 0.0)\n#define setUvec2(value) vec4(vec2(value), 0.0, 0.0)\n#define setUvec3(value) vec4(vec3(value), 0.0)\n#define setUvec4(value) vec4(value)\n#define setInt(value) vec4(float(value), 0.0, 0.0, 0.0)\n#define setIvec2(value) vec4(vec2(value), 0.0, 0.0)\n#define setIvec3(value) vec4(vec3(value), 0.0)\n#define setIvec4(value) vec4(value)\n\n//used across persistance and rendering\n#define fromIndex(index) ivec2(index % int(iResolution.x), floor(float(index) / iResolution.x))\n#define toIndex(uv) int(floor(uv.x) + floor(uv.y) * iResolution.x)\n#define get(item) texelFetch(iChannel0, fromIndex(item.index), 0).rgba\n#define getBool(item) bool(get(item).r)\n#define getBvec2(item) bvec2(get(item).rg)\n#define getBvec3(item) bvec3(get(item).rgb)\n#define getBvec4(item) bvec4(get(item).rgba)\n#define getUint(item) uint(get(item).r)\n#define getUvec2(item) uvec2(get(item).rg)\n#define getUvec3(item) uvec3(get(item).rgb)\n#define getUvec4(item) uvec4(get(item).rgba)\n#define getInt(item) int(get(item).r)\n#define getIvec2(item) ivec2(get(item).rg)\n#define getIvec3(item) ivec3(get(item).rgb)\n#define getIvec4(item) ivec4(get(item).rgba)\n#define getFloat(item) get(item).r\n#define getVec2(item) get(item).rg\n#define getVec3(item) get(item).rgb\n#define getVec4(item) get(item).rgba\n\n//just a wrapper around a value we want to persist and the index where it should be saved\nstruct Item {\n    vec4 value;\n    int index;\n};\n\n//demo\n#define circle(pos, radius, colour, index) Circle(Item(setVec2(pos), index), Item(setFloat(radius), index + 1), Item(setVec3(colour), index + 2))\n\nstruct Circle {\n    Item pos;\n    Item radius;\n    Item colour;\n};\n\nconst Circle[] circles = Circle[](\n    circle(vec2(0.4, 0.4), 0.1, vec3(1.0, 0.0, 0.0), 0), //need to manually code the indexes :(\n    circle(vec2(0.8, 0.6), 0.2, vec3(0.0, 0.0, 1.0), 3),\n    circle(vec2(0.5, 0.1), 0.3, vec3(1.0, 0.0, 1.0), 6)\n);\n\nconst Item dragPosition = Item(setVec2(vec2(0.0)), 9);\n\nconst Item dragIndex = Item(setInt(-1), 10);\n","name":"Common","description":"","type":"common"}]}