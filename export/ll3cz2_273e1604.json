{"ver":"0.1","info":{"id":"ll3cz2","date":"1533195055","viewed":298,"name":"particles collision simulator","username":"archibate","description":"very cool to watching particle moves, collisions togeter. and their traces.\nbetter and faster than my older version [url]https://www.shadertoy.com/view/4ttyRS[/url].","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","particles","physics","gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define mainImage(O, U) O = texture(iChannel0, U/iResolution.xy);//*.5+.5;","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define TAU (atan(1.)*8.)\n#define MAXINITVEL 180.\n\nvec2 mkrandvel(inout vec2 co)\n{\n    float vel = MAXINITVEL * rand(co);\n    co.y = vel;\n    float vang = TAU * rand(co);\n    return vel * vec2(cos(vang), sin(vang));\n}\n\nvec2 mkrandpos(inout vec2 co)\n{\n    vec2 p;\n    p.x = iResolution.x * rand(co);\n    co.y = p.x;\n    p.y = iResolution.y * rand(co);\n    co.x = p.y;\n    return p;\n}\n\nvec2 intgratAccel(vec2 p, int myid)\n{\n    vec2 f = vec2(0);\n    for (int id = 0; id < MAX_BODIES; id++) {\n        if (id == myid)\n            continue;\n        vec2 d = p - getBody(id).xy;\n        float d2 = dot(d,d);\n        vec2 acc = d / (d2*sqrt(d2));\n    \tf += acc * smoothstep(5.,14.,d2);\n    }\n    return +450000.*f; // change '+' to '-' to simulate gravity\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    if (U.y >= 1. || U.x >= float(MAX_BODIES))\n        return;\n    \n    if (iFrame <= 5) {\n        vec2 co = U + 12.35;\n        O.xy = mkrandpos(co);\n        O.zw = mkrandvel(co);\n        return;\n    }\n    \n    #if 0\n    if (iMouse.w >= .5 && abs(\n        \t\trand(iMouse.xy + iTime * 2.3) * float(MAX_BODIES) - U.x\n    \t\t\t\t\t\t ) < 1.) {\n        vec2 co = U;\n        co += sin(dot(iMouse.xy, vec2(12.345,540.321)) - (iMouse.x * iMouse.y + 73.12) * iTime) - iTime * 82.346;\n        co *= 3.18 + cos(iTime);\n        O.xy = iMouse.xy;\n        O.zw = mkrandvel(co);\n        return;\n    }\n    #endif\n    \n    vec4 o = getBody(U.x);\n    o.xy += .5 * o.zw * iTimeDelta;\n    o.zw += intgratAccel(o.xy, int(U.x)) * iTimeDelta;\n    o.xy += .5 * o.zw * iTimeDelta;\n    \n    if (o.x < 0.)\n        o.z = abs(o.z);\n    else if (o.x >= iResolution.x)\n        o.z = -abs(o.z);\n    if (o.y < 0.)\n        o.w = abs(o.w);\n    else if (o.y >= iResolution.y)\n        o.w = -abs(o.w);\n        \n    O = o;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define getBody(id) texelFetch(iChannel0, ivec2(id, 0), 0)\n#define getProp(id) texelFetch(iChannel0, ivec2(id, 1), 0)\n\n#define MAX_BODIES 20\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define DRAD 8.\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 u;\n    O = vec4(0);\n    vec4 old = texture(iChannel1, U/iResolution.xy);\n    if (old.r == 1.)\n        O.g = 1.;\n    if (old.b > 0.)\n        O.b = min(.6, old.b * .98);\n    if (old.g >= .1)\n        O.g = old.g * .5;\n    for (int id = 0; id < MAX_BODIES; id++) {\n        float d = distance(getBody(id).xy, U);\n        if (d < DRAD) {\n            O += smoothstep(0., -1.5, d - DRAD);\n        }\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}