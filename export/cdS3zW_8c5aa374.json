{"ver":"0.1","info":{"id":"cdS3zW","date":"1667264307","viewed":92,"name":"geometric subdiv triangular line","username":"jt","description":"Exploring possibilities of \"geometric repetition\".\nInfinite triangle filled with n-ary subdivision lines SDF (should be exact euclidean - errors mostly at skeleton / spines, other random-looking are hopefully false alarms, perhaps numerical inaccuracies).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lines","distance","euclidean","subdivision","geometric","short","nary","series","sum","telescope"],"hasliked":0,"parentid":"cdSGzW","parentname":"geometric series subdiv. lines"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/cdS3zW geometric subdiv triangular lines by jt\n// based on https://www.shadertoy.com/view/cdSGzW geometric series subdiv. lines by jt\n\n// tag: sdf, lines, distance, euclidean, subdivision, geometric, short, nary, series, sum, telescope\n\n// Exploring the possibilities of \"geometric series repetition\".\n// Infinite triangle filled with n-ary subdivision lines SDF\n// (should be exact euclidean - errors mostly at skeleton / spines,\n//  other random-looking are hopefully false alarms, perhaps numerical inaccuracies).\n\n#define pi 3.1415926\n\nfloat lines(vec2 p, float n)\n{\n    float n1 = n - 1.0;\n    float b = n / n1;\n    float l = ceil(-log2(p.y) / log2(b)); // level\n    float s = pow(b, l); // scale\n    p = fract(s * p * n1);\n    \n    return abs(p.y-n1/(n+n1))*b/s/n;\n}\n\nfloat map(vec2 p)\n{ \n    //float phi = pi / 4.0;\n    float phi = mix(0.0, pi / 4.0, 0.5+0.5*cos(iTime/3.0));\n    mat2 R = mat2(sin(phi),cos(phi),-cos(phi),sin(phi));\n    vec2 p0 = R*p;\n    vec2 p1 = p*R;\n    if(dot(vec2(abs(p.x), p.y), R[0]) < 0.0) return length(p); // TODO: fix for phi > pi / 4.0\n    if(p0.y < 0.0) return -p0.y;\n    if(p1.y < 0.0) return -p1.y;\n    float n = floor((0.5 - 0.5 * cos(iTime)) * 10.0 + 2.0);\n    //float n = 5.0;\n    //return min(lines(R*p, n), lines(p*R, n));\n    float h = sin(phi);\n    return min(min(lines(R*p, n), lines(p*R, n)), lines(p*h, n)/h);\n}\n\n#define EPSILON 0.001\n\nvec2 gradient(vec2 p) // NOT normalized so we can use it's length to detect errors in the SDF.\n{\n    vec2 h = vec2(EPSILON, 0);\n    return (vec2(map(p + h.xy) - map(p - h.xy),\n                 map(p + h.yx) - map(p - h.yx))) / EPSILON / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    float d = map(p);\n\n\t// using iq's sdf visualization\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(150.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n\n    if(iMouse.z > 0.001)\n    {\n        d = map(m);\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.0025));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n    }\n\n    // sdf error-detection from https://www.shadertoy.com/view/DdX3WH Interior Distance Detect Errors\n    {\n        float error = map(p - gradient(p) * map(p));\n        col.r += smoothstep(0.0, EPSILON, abs(error)) * (cos(iTime * 2.0 * pi) * 0.5 + 0.5); // detect some (interior and exterior) sdf inconsistencies\n    }\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}