{"ver":"0.1","info":{"id":"ws2fWh","date":"1589978553","viewed":193,"name":"stochastic blur test","username":"mystran","description":"Uses the hash-based \"pseudo-blue\" noise from my dither shader to offset texture sampling instead, with adjustable number of samples (=rounds*2).\n\nAdjust radius with mouse Y.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat rounds = 8.; \t\t// number of taps is 2*rounds\nbool temporal = false;\t// randomize noise over time\n\nuint hash(uint x)\n{\n    x ^= x >> 16; x *= 0x7feb352du; \n    x ^= x >> 15; x *= 0x846ca68bu; \n    x ^= x >> 16;\n    return x;\n}\n\nvec4 hash2v(uint x, uint y)\n{\n    // take a hash, split it into components\n    uint h = hash(uint(x)+(uint(y)<<16));\n    vec4 v;\n    v.x = float(h&0xffu); h >>= 8;\n    v.y = float(h&0xffu); h >>= 8;\n    v.z = float(h&0xffu); h >>= 8;\n    v.w = float(h&0xffu);\n    \n    return v / float(0xffu);\n}\n\nvec4 noise(uvec2 xy, float seed)\n{\n    // temporal noise\n    xy.y += uint(seed*1337.+(temporal?1337.:0.)*mod(iTime,1.));\n    \n    // compute noise\n    vec4 h = hash2v(xy.x, xy.y);\n    h -= .25 * hash2v(xy.x-1u, xy.y);\n    h -= .25 * hash2v(xy.x+1u, xy.y);\n    h -= .25 * hash2v(xy.x, xy.y-1u);\n    h -= .25 * hash2v(xy.x, xy.y+1u);\n\n    // noise scale\n    h *= 2.;\n\n    return h;\n}\n\nvec3 ug(vec3 v) { return v*v; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float radius = (iResolution.y - iMouse.y) * 1./16.;\n\n    vec3 c = vec3(0.);\n    for(float i = 0.; i < rounds; ++i)\n    {\n        vec4 n = noise(uvec2(fragCoord.xy), i);\n        c += ug(texture(iChannel0, uv + n.xy * radius / iResolution.xy).xyz);\n        c += ug(texture(iChannel0, uv + n.zw * radius / iResolution.xy).xyz);\n    }\n    c *= .5 / rounds;\n   \n    // Output to screen\n    fragColor = vec4(sqrt(c), 1.0);\n}","name":"Image","description":"","type":"image"}]}