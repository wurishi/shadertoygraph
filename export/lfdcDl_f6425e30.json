{"ver":"0.1","info":{"id":"lfdcDl","date":"1731364516","viewed":41,"name":"House with pines","username":"lilis","description":"Devoir de groupe de mif02 de Nessim et Khalissa","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mif02"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.09.15\n// Mechiche Nessim - Rhoulam Khalissa\n\n// default colors\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 BLUE = vec3(0.035, 0.192, 0.478);\nconst vec3 GRAY = vec3(0.831, 0.643, 0.545);\nconst vec3 LIGHT_GRAY = vec3(0.95, 0.75, 0.75);\nconst vec3 DARK_GREEN = vec3(0.25, 0.75, 0.25);\nconst vec3 MINT_GREEN = vec3(0.56, 0.93, 0.56);\nconst vec3 BROWN = vec3(0.55, 0.27, 0.07);\nconst vec3 PINE_GREEN = vec3(0.0, 0.5, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.6, 0.2);\n\n// Camera and raymarching parameters\n#define CAMERA_POS vec3(-8., 20., 10.)\n#define STEPS 400\n#define EPSILON .01\n#define MAX_DIST 100.\n// Light parameters\n#define LIGHT_POS vec3(15., 15., 25.)\n#define LIGHT_SIZE 0.04\n#define AC 0.1 // ambiant coefficient\n#define DC 0.35 // diffuse coefficient\n#define SC 0.10 // specular coefficient\n\nstruct Ray \n{\n    vec3 o; // Origin\n    vec3 d; // Direction\n};\n\nstruct Val \n{\n    float v; // Signed distance\n    int c; // Cost\n    vec3 color; // Object color\n};\n\n// Compute point on ray\n// ray : The ray\n// t : Distance\nvec3 Point(Ray ray, float t)\n{\n    return ray.o + t * ray.d;\n}\n\n// Random direction in a hemisphere\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed, vec3 n)\n{\n    float a = fract(sin(176.19 * float(seed))); // Uniform randoms\n    float b = fract(sin(164.19 * float(seed)));\n\n    float u = 2. * 3.1415 * a; // Random angle\n    float v = acos(2. * b - 1.); // Arccosine distribution to compensate at poles\n\n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v)); // Direction\n    if (dot(d, n) < 0.) {\n        d = -d;\n    } // Hemisphere\n\n    return d;\n}\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\nmat3 RotZcamera(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\nRay CreateRay(vec2 m, vec2 p)\n{\n    float a = 3. * 3.14 * m.x;\n    float le = 3.5;\n\n    // Origin\n    vec3 ro = CAMERA_POS;\n    ro *= RotZcamera(a);\n\n    // Target point\n    vec3 ta = vec3(0., 0., 1.);\n\n    // Orthonormal frame\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = normalize(cross(u, w));\n    vec3 rd = normalize(p.x * u + p.y * v + le * w);\n    return Ray(ro, rd);\n}\n\n// Primitives -------------------------------------------------------------------------------\n\n// Sphere\n// p : Point\n// r : Radius\n// color : Color of the object\nVal Sphere(vec3 p, float r, vec3 color)\n{\n    return Val(length(p) - r, 1, color);\n}\n\n// Plane\n// p : Point\n// n : Normal of plane\n// color : Color of the object\nVal Plane(vec3 p, vec3 n, vec3 color)\n{\n    return Val(dot(p, n), 1, color);\n}\n\n// Box\n// p : Point\n// b : Dimensions(x, y, z)\n// color : Color of the object\nVal Box(vec3 p, vec3 b, vec3 color)\n{\n    vec3 q = abs(p) - b / 2.0;\n    return Val(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), 1, color);\n}\n\n// Pyramid\n// p : Point\n// h : Height\n// color : Color of the object\nVal Pyramid(vec3 p, float h, vec3 color)\n{\n    float m2 = h * h + 0.25;\n\n    // switch x y z to -y z -x so that the base is on the xy plane\n    float var = p.x;\n    p.x = -p.y;\n    p.y = p.z;\n    p.z = -var;\n\n    p.xz = abs(p.xz);\n    p.xz = (p.z > p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    vec3 q = vec3(p.z, h * p.y - 0.5 * p.x, h * p.x + 0.5 * p.y);\n\n    float s = max(-q.x, 0.0);\n    float t = clamp((q.y - 0.5 * p.z) / (m2 + 0.25), 0.0, 1.0);\n\n    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;\n    float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);\n\n    float d2 = min(q.y, -q.x * m2 - q.y * 0.5) > 0.0 ? 0.0 : min(a, b);\n\n    return Val(sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p.y)), 1, color);\n}\n\n// TODO : demi-axes devient axe (diviser par 2)\n// Ellipsoid\n// p : Point\n// r : Dimensions(x, y, z)\n// color : Color of the object\nVal Ellipsoid(vec3 p, vec3 r, vec3 color) \n{\n    vec3 scaled_p = p / r;\n\n    Val sphere = Sphere(scaled_p, 1.0, color);\n\n    return Val(sphere.v, sphere.c + 1, color);\n}\n\n// Operators -------------------------------------------------------------------------------\n\n// Union\n// a,b : field function of left and right sub-trees\nVal Union(Val a, Val b)\n{\n    if (a.v < b.v) {\n        return Val(a.v, a.c + b.c + 1, a.color); // Utiliser la couleur de 'a'\n    } else {\n        return Val(b.v, a.c + b.c + 1, b.color); // Utiliser la couleur de 'b'\n    }\n}\n\n// Translation\n// t : Translation vector\nmat4 Trans(vec3 t) {\n    return mat4(\n        1., 0., 0., 0.,\n        0., 1., 0., 0.,\n        0., 0., 1., 0.,\n        -t.x, -t.y, -t.z, 1.\n    );\n}\n\n// Scaling\n// s : Scaling factor vector\nmat4 Scale(vec3 s) {\n    return mat4(\n        1. / s.x, 0., 0., 0.,\n        0., 1. / s.y, 0., 0.,\n        0., 0., 1. / s.z, 0.,\n        0., 0., 0., 1.\n    );\n}\n\n// Rotation around X axis\n// angle : Angle\nmat4 RotX(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, s, 0.0,\n        0.0, -s, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n// Rotation around Y axis\n// angle : Angle\nmat4 RotY(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(\n        c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n// Rotation around Z axis\n// angle : Angle\nmat4 RotZ(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(\n        c, s, 0.0, 0.0,\n        -s, c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n// Boolean Difference\n// a,b : field function of left and right sub-trees\nVal Difference(Val a, Val b)\n{\n    return Val(max(a.v, -b.v), a.c + b.c + 1, a.color);\n}\n\n//12 grad direction\nfloat grad(int hash, float x, float y, float z) \n{\n    int h = hash & 15;\n    float u = h < 8 ? x : y;\n    float v = h < 4 ? y : h == 12 || h == 14 ? x : z;\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\n// Simple noise function\nfloat Noise(vec3 p) \n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    int n = int(dot(i, vec3(1.0, 57.0, 113.0)));\n    return mix(mix(mix(grad(n, f.x, f.y, f.z), grad(n + 1, f.x - 1.0, f.y, f.z), f.x),\n            mix(grad(n + 57, f.x, f.y - 1.0, f.z), grad(n + 58, f.x - 1.0, f.y - 1.0, f.z), f.x), f.y),\n        mix(mix(grad(n + 113, f.x, f.y, f.z - 1.0), grad(n + 114, f.x - 1.0, f.y, f.z - 1.0), f.x),\n            mix(grad(n + 170, f.x, f.y - 1.0, f.z - 1.0),\n                grad(n + 171, f.x - 1.0, f.y - 1.0, f.z - 1.0), f.x), f.y), f.z);\n}\n\nfloat FractalNoise(vec3 p, int octaves, float persistence) \n{\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    float maxValue = 0.0; // Utilisé pour normaliser\n    float total = 0.0;\n\n    for (int i = 0; i < octaves; i++) {\n        total += Noise(p * frequency) * amplitude;\n\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n\n    return total / maxValue;\n}\n\nfloat Turbulence(vec3 p, int octaves) {\n    float w = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        t += abs(Noise(p * w)) / w;\n        w *= 2.0;\n    }\n    return t;\n}\n\nfloat ComplexNoise(vec3 p) \n{\n    return 0.3 * FractalNoise(p * 1.5 + vec3(sin(p.y * 0.7), cos(p.x * 0.8), sin(p.z * 0.9)), 3, 0.4)\n        + 0.15 * FractalNoise(p * 3.0 + vec3(cos(p.y * 1.3), sin(p.x * 1.4), cos(p.z * 1.5)), 2, 0.3)\n        + 0.1 * Turbulence(p * 1.2, 2);\n}\n\n// Apply noise to an object based in it's position \n// type = true -> bump, false -> hole\nVal ObjectWithNoise(Val obj, bool type, vec3 p) \n{\n    float noiseAmount = -0.5; // Intensity of the noise\n    if (type) {\n        noiseAmount = 0.5;\n    }\n    float deformation = noiseAmount * ComplexNoise(p);\n\n    // apply deformation to object distance\n    float deformedDistance = obj.v + deformation;\n\n    return Val(deformedDistance, obj.c + 1, obj.color);\n}\n\n// Complex primitives ---------------------------------------------------------------------\n\n// Cylinder\n// p : Point\n// a, b : Center of each extremities of the cylinder\n// r : Radius\n// color : Color of the object\nVal Cylinder(vec3 p, vec3 a, vec3 b, float r, vec3 color) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec3 q = pa - ba * h;\n\n    // Cylinder without extremities\n    Val cylinder = Val(length(q) - r, 1, color);\n\n    // Add spheres at the extremities\n    Val sphereA = Sphere(p - a, r, color);\n    Val sphereB = Sphere(p - b, r, color);\n\n    // Difference between the cylinder and the spheres to create plane extremities\n    cylinder = Difference(Difference(cylinder, sphereA), sphereB);\n\n    return cylinder;\n}\n\n// Capsule\n// p : Point\n// a, b : Center of each extremities of the capsule\n// r : Radius\n// color : Color of the object\nVal Capsule(vec3 p, vec3 a, vec3 b, float r, vec3 color) {\n    Val sphereA = Sphere(p - a, r, color);\n    Val sphereB = Sphere(p - b, r, color); \n    Val cylinder = Cylinder(p, a, b, r, color); \n    Val capsule = Union(sphereA, Union(sphereB, cylinder));\n    return capsule;\n}\n\n// Cone\n// p : Point\n// a, b : Center of each extremities of the cone\n// ra, rb : Radius of each extremities\n// color : Color of the object\nVal Cone(vec3 p, vec3 a, vec3 b, float ra, float rb, vec3 color)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return Val(s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) ),1,color);\n}\n\n// Create a tree at coordinates `coord`\nVal sapin(vec3 p, vec3 coord) {\n\n\n    // Tronc de l'arbre (cylindre)\n    Val tronc = Cylinder(p, coord, coord+vec3(0.,0.,4.), 0.25, BROWN); // Tronc marron\n\n    // Branches du sapin (cônes)\n    Val branche1 = Cone(p, coord+vec3(0., 0., 2.), coord+vec3(0., 0., 4.), 1.5, 0.0, PINE_GREEN);\n    Val branche2 = Cone(p, coord+vec3(0., 0., 3.), coord+vec3(0., 0., 5.), 1.25, 0.0, PINE_GREEN);\n    Val branche3 = Cone(p, coord+vec3(0., 0., 4.), coord+vec3(0., 0., 6.), 1., 0.0, PINE_GREEN);\n\n    Val sapin = Union(tronc, Union(branche1, Union(branche2, branche3)));\n\n    return sapin;\n}\n\nVal maison(vec3 p, vec3 coor) {\n    Val chemine = Box((Trans(coor + vec3(-1.3, 0., 5.0)) * vec4(p, 1.)).xyz, vec3(0.8, 0.8, 2.), BLUE);\n    Val porte = Box((Trans(coor + vec3(0., 2.1, 0.5)) * vec4(p, 1.)).xyz, vec3(0.6, 0.2, 1.4), RED);\n    Val fenetre = Box((Trans(coor + vec3(-1., 2.1, 2.)) * vec4(p, 1.)).xyz, vec3(0.6, 0.5, 0.7), RED);\n    Val fenetre2 = Box((Trans(coor + vec3(-2., 0., 2.)) * vec4(p, 1.)).xyz, vec3(0.6, 1., 0.7), RED);\n    Val box = Box((Trans(coor + vec3(0., 0., 2.)) * vec4(p, 1.)).xyz, vec3(4., 4., 4.), ORANGE);\n    box = Difference(box,fenetre);\n    box = Difference(box,fenetre2);\n    Val toit = Pyramid((Scale(vec3(4., 4., 3.)) * Trans(coor + vec3(0., 0., 4.)) * vec4(p, 1.)).xyz, 0.7, BLUE);\n\n    Val maison =Union(\n            porte,\n            Union(\n                chemine,\n                Union(\n                    toit,box)));\n\n    return maison;\n}\n\n// Potential field of the object\n// p : Point\nVal object(vec3 p) {\n\n    Val maison = maison(p, vec3(-1., 4., 0.));\n\n    Val plan = ObjectWithNoise(Plane(p, vec3(0., 0., 1.), GRAY), true, p); \n\n    Val sapinun = sapin(p, vec3(-6., 0., 0.));\n    sapinun = Union(sapinun, sapin(p, vec3(-3., 0., 0.)));\n    sapinun = Union(sapinun, sapin(p, vec3(6., 6., 0.)));\n\n    Val scene = Union(\n        Union(plan, sapinun),\n        maison\n    );\n\n    return scene; \n}\n\nVal sapin_bound(vec3 p, vec3 coord) {\n\n    return Cone(p, coord+vec3(0., 0., 0.), coord+vec3(0., 0., 6.1), 1.5, 1.5, RED);\n}\n\nVal object_bound(vec3 p) {\n\n    Val vol_englobant = Union(\n        Box((Trans(vec3(-1., 4., 3.)) * vec4(p, 1.)).xyz, vec3(4.2, 4.5, 6.5), RED),\n        Box((Trans(vec3(0., 0., 0.)) * vec4(p, 1.)).xyz, vec3(120., 120.,2.5), RED)\n    );\n    vol_englobant = Union(vol_englobant, sapin_bound(p, vec3(-6., 0., 0.)));\n    vol_englobant = Union(vol_englobant, sapin_bound(p, vec3(-3., 0., 0.)));\n    vol_englobant = Union(vol_englobant, sapin_bound(p, vec3(6., 6., 0.)));\n    \n    if( vol_englobant.v > 0.0 ) {\n        Val retour = Val(vol_englobant.v, vol_englobant.c, vol_englobant.color);\n        return retour;\n    }\n\n    Val maison = maison(p, vec3(-1., 4., 0.));\n\n    Val plan = ObjectWithNoise(Plane(p, vec3(0., 0., 1.), GRAY), true, p); \n\n    Val sapinun = sapin(p, vec3(-6., 0., 0.));\n    sapinun = Union(sapinun, sapin(p, vec3(-3., 0., 0.)));\n    sapinun = Union(sapinun, sapin(p, vec3(6., 6., 0.)));\n\n    Val scene = Union(\n        Union(plan, sapinun),\n        maison\n    );\n\n    return scene;\n}\n\n// Analysis of the scalar field -----------------------------------------------------------------\n\n// Object normal\n// p : Point\nvec3 ObjectNormal(vec3 p)\n{\n    const float eps = .001;\n    vec3 n;\n    Val val = object(p);\n    float v = val.v;\n    n.x = object(vec3(p.x + eps, p.y, p.z)).v - v;\n    n.y = object(vec3(p.x, p.y + eps, p.z)).v - v;\n    n.z = object(vec3(p.x, p.y, p.z + eps)).v - v;\n    return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\n// color : color\nbool SphereTrace(Ray ray, float e, out float t, out int s, out int c, out vec3 color)\n{\n    bool h = false;\n\n    // Start at the origin\n    t = 0.0;\n    c = 0;\n\n    for (int i = 0; i < STEPS; i++)\n    {\n        s = i;\n        vec3 p = Point(ray, t);\n\n        // bounded object\n        Val val = object_bound(p);\n\n        // unbounded object\n        // Val val = object(p);\n        float v = val.v;\n        c += val.c;\n        // Hit object\n        if (v < 0.)\n        {\n            h = true;\n            color = val.color;\n            break;\n        }\n        // Move along ray\n        t += max(EPSILON, v);\n        // Escape marched too far away\n        if (t > e)\n        {\n            break;\n        }\n    }\n    return h;\n}\n\n// Lighting -------------------------------------------------------------------------------\n\n// Background color\n// ray : Ray\nvec3 Background(Ray ray)\n{\n    return mix(vec3(.45, .55, .99), vec3(.65, .69, .99), ray.d.z * .5 + .5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p, vec3 n, vec3 l, vec3 objColor)\n{\n    float t;\n    int s;\n    int c;\n    bool hit = SphereTrace(Ray(p + EPSILON * n, l), MAX_DIST, t, s, c, objColor);\n    if (!hit)\n    {\n        return 1.;\n    }\n    return 0.;\n}\n\n// Soft shadowing\n// p : Point\n// n : Normal\n// l : Light direction\n// w : Light size\nfloat SoftShadow(vec3 p, vec3 n, vec3 l, float w )\n{\n    Ray ray = Ray(p + EPSILON * n, l);\n    float maxt = 100.;\n    float res = 1.0;\n    float ph = 1e20;\n    float t = 0.0;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = object(ray.o + ray.d*t).v;\n        if( h<0.0 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// float SoftShadow(vec3 p, vec3 n, vec3 l, float w )\n// {\n//     Ray ray = Ray(p + EPSILON * n, l);\n//     float maxt = 100.;\n//     float res = 1.0;\n//     float t = 0.0;\n//     for( int i=0; i<256 && t<maxt; i++ )\n//     {\n//         float h = object(ray.o + t*ray.d).v;\n//         res = min( res, h/(w*t) );\n//         t += clamp(h, 0.005, 0.50);\n//         if( res<-1.0 || t>maxt ) break;\n//     }\n//     res = max(res,-1.0);\n//     return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n// }\n\n// Ambient occlusion\n// p : Point\n// n : Normal\nfloat AmbientOcclusion(vec3 p, vec3 n) \n{\n    int samples = 16; \n    float occlusion = 0.0;\n\n    for (int i = 0; i < samples; i++) {\n        vec3 randomDir = Hemisphere(i + 35, n);\n        Ray occlusionRay;\n        occlusionRay.o = p + n * 0.001; \n        occlusionRay.d = randomDir;\n\n        // check in an hemisphere around the point if there is an object\n        float h = object(occlusionRay.o + occlusionRay.d* .3).v;\n        // if there is an object, increment the occlusion\n        if( h<0.0 ) occlusion += 1.0;\n    }\n    return 1.0 - (occlusion / float(samples))*0.3;\n}\n\n// Shading and lighting\n//   p : Point\n//   n : Normal at point\n// eye : Eye direction\nvec3 Shade(vec3 p, vec3 n, Ray eye)\n{\n    // Point light\n    const vec3 lp = LIGHT_POS;\n\n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    // Ambient color\n    float ao = AmbientOcclusion(p, n);\n    vec3 ambient = ao * (AC + .25 * Background(Ray(p, n)));\n    \n    // Shadow computation\n    //float shadow = Shadow(p, n, l, objColor);\n    float shadow = SoftShadow(p, n, l, LIGHT_SIZE);\n\n    // Phong diffuse\n    vec3 diffuse = DC * clamp(dot(n, l), 0., 1.) * vec3(1., 1., 1.);\n\n    // Specular\n    vec3 r = reflect(eye.d, n);\n    vec3 specular = SC * pow(clamp(dot(r, l), 0., 1.), 35.) * vec3(1., 1., 1.);\n    vec3 c = ambient + shadow * (diffuse + specular);\n    return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n, int m)\n{\n    float t = float(n) / (float(m));\n    return .5 + mix(vec3(.05, .05, .5), vec3(.65, .39, .65), t);\n}\n\n// Shading according to the cost\n// if cost < val1 -> purple to blue\n// if val1 <= cost < val1 -> blue to yellow\n// if cost >= val2 -> yellow to red\nvec3 shadeCout(in int c, float val1, float val2, float valMax)\n{\n    vec3 rgb;\n    vec3 purple = vec3(1., 0., 1.);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n    vec3 red = vec3(1.0, 0.0, 0.0);\n\n    float new_c = float(c);\n\n    if (new_c < val1) {\n        rgb = mix(purple, blue, new_c / val1);\n    } else if (new_c < val2) {\n        rgb = mix(blue, yellow, (new_c - val1) / (val2 - val1));\n    } else {\n        rgb = mix(yellow, red, (new_c - val2) / (valMax - val2));\n    }\n    return rgb;\n}\n\n// Compute color of pixel\nvoid mainImage(out vec4 color, in vec2 pxy)\n{\n    // Convert pixel coordinates\n    vec2 pixel = (-iResolution.xy + 2. * pxy) / iResolution.y;\n\n    // Mouse\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    // Camera\n    Ray ray = CreateRay(m, pixel);\n\n    // Trace ray\n\n    // Hit and number of steps\n    float t = 0.0;\n    int s = 0;\n    int c;\n    vec3 objColor = vec3(0.0); // Object color initialized to black\n    bool hit = SphereTrace(ray, MAX_DIST, t, s, c, objColor);\n\n    // Shade Background\n    vec3 rgb = Background(ray);\n\n    if (hit)\n    {\n        // Position\n        vec3 p = Point(ray, t);\n\n        // Compute normal\n        vec3 n = ObjectNormal(p);\n\n        // Shade object with light\n        rgb = objColor;\n        vec3 shading = Shade(p, n, ray);\n        rgb *= shading;\n    }\n\n    // Uncomment this line to shade image with false colors representing the number of steps\n    //rgb=ShadeSteps(s,STEPS);\n\n    // Uncomment this line to shade cost\n    // rgb = shadeCout(c, 600.0, 1200.0, 3000.0);\n\n    color = vec4(rgb, 1.);\n}","name":"Image","description":"","type":"image"}]}