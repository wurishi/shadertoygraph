{"ver":"0.1","info":{"id":"llscD7","date":"1505160204","viewed":176,"name":"yonic tunnel","username":"visy","description":"marche","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","smooth","plastic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n\n#define FXAA_SPAN_MAX 16.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n    \n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n        \n    vec3 col;\n\n   \tvec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n\tcol = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\n        \n    fragColor = vec4( col, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR_CLIPPING_PLANE 0.005\n#define FAR_CLIPPING_PLANE 1000.0\n#define NUMBER_OF_MARCH_STEPS 500\n#define EPSILON 0.1\n#define DISTANCE_BIAS 0.2\n\n#define AA 1\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - (s);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\nconst float kHashScale1 = 443.8975;\n\nfloat hash11(float p) {\n  vec3 p3 = fract(vec3(p) * kHashScale1);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nvec2 scene1(vec3 pos)\n{\n    vec3 translate = vec3(-0.1, fract(pos.y), 0.);\n\n    vec3 opos = pos - translate;\n\n    float finalDist = sdSphere(cos(opos*0.2),1.1+cos(pos.z*0.01+cos(pos.x*1.1)*0.1)*0.2)*3.91;\n    \t\n    return vec2(finalDist, 0.0);\n}\n\nvec2 scene2(vec3 pos)\n{\n    float keke = -1.0+(0.01+(iTime+51.)*0.02);\n    if (keke >= 1.0) keke = 1.0;\n    float ox = cos(pos.z+pos.y*0.2+iTime)*1.;\n    float ox2 = 0.0;\n    float oy = 1.+fract(pos.z*0.01*keke);\n    float oy2 = fract(pos.y)+1.;\n    float oz = 0.5-cos((pos.z*0.5)*10.1)*0.1;\n    float oz2 = -500.0;\n\n    float mx = 0.0;\n    if (iTime > 60.) mx = (iTime-60.)*0.01;\n    if (mx > 1.0) mx = 1.0;\n    \n    float vari = 0.0;\n    if (iTime > 120.) vari = -(iTime-120.)*0.00001;\n    \n    float x = mix(ox2,ox,1.0-mx);\n    float y = mix(oy,oy2,mx);\n    float z = mix(oz2,oz,1.0-mx);\n    \n    vec3 translate = vec3(x, y, z);\n\n    vec3 opos = pos - translate;\n\n    float finalDist = sdSphere(cos(opos*((-0.5+pos.z*(0.001+vari))+iTime*0.0015)),1.1+abs(sin(pos.z*0.1+cos(pos.x*1.1))*0.1)*0.2)*3.91;\n    \n    return vec2(finalDist, 1.0);\n}\n\nvec2 scene(vec3 pos) {\n    float mixer = 1.0*cos(iTime*0.001+pos.z*1.01);\n    if (mixer < 0.0) mixer = 0.0;\n    if (mixer > 1.0) mixer = 1.0;\n    float mat = 0.0;\n\tvec2 res1 = scene1(pos);\n\tvec2 res2 = scene2(pos);\n    if (res1.x < res2.x) mat = res1.y;\n    else mat = res2.y;\n\treturn vec2(min(res1.x,res2.x),mat);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat err(float dist){ return min(EPSILON, pow(dist*0.02, 2.0)); }\n\nvec3 discontinuity_reduction(vec3 origin, vec3 direction, vec3 position){ for(int i = 0; i < 3; i++)position = position + direction * (scene(position).x - err(distance(origin, position))); return position; }\n\n\nvec3 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    float acc = 0.0;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 pos = position + direction * total_distance;\n        //pos = discontinuity_reduction(position,direction,pos);\n        vec2 result = scene(pos);\n        acc+=cos(result.x*1.)*0.05;\n\n        if(result.x < EPSILON)\n        {\n            return vec3(total_distance, acc,result.y);\n        }\n        \n        total_distance += result.x * DISTANCE_BIAS;\n        \n        \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    return vec3(FAR_CLIPPING_PLANE, acc, 0.0);\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec3 eps = vec3(0.3,0.0,0.0)*EPSILON;\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // pixel coordinates\n    vec2 uv = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n    \n    vec3 direction = normalize(vec3(uv, 0.0));\n    float cx = 0.0;\n    float cy = 1.0;\n    float cz = iTime*5.9;\n\n    float ker = ((iTime-204.)*0.001);\n    if (ker > 3.0) ker = 3.0;\n    if (iTime > 204.) cz = -iTime*(ker);\n    \n    vec3 camera_origin = vec3(cx, cy, cz);\n\tvec3 lookAt = vec3(cx,cy,cz+1.);\n    \n    vec3 forward = normalize(lookAt-camera_origin); // Forward vector.\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); // Right vector... or is it left? Either way, so long as the correct-facing up-vector is produced.\n    vec3 up = normalize(cross(forward,right)); // Cross product the two vectors above to get the up vector.\n\n    float FOV = 0.05+iTime*0.01;\n\n\tif (FOV > 0.55) FOV = 0.55;\n        \n    vec3 ro = camera_origin;\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    vec3 result = raymarch(ro, rd);\n            \n    float fog = pow(1.0 / (1.0 + result.x), 0.2);\n    \n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n\t\tmaterialColor = vec3(1.0-result.x*0.01*0.5,0.9-cos(result.x*0.1)*0.5,1.0*0.5);\n\n    vec3 intersection = ro + rd*result.x;\n    \n    vec3 nrml = normal(intersection);\n    float occ = calcAO( intersection, nrml );\n    vec3 light_dir = normalize(vec3(sin(result.x*0.1),0.3,-1.0));\n    vec3 ref = reflect( rd, nrml );\n    float dom = smoothstep( -0.1, 0.9, ref.y);\n    float spe = pow(clamp( dot( ref, light_dir ), 0.0, 1.0 ),32.0);\n\n//    float diffuse = dot(light_dir, nrml)-result.y*0.3;\n\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,0.3,0.7)-result.y*0.05;\n    \n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    vec3 ambient_color = vec3(1.0,1.0, 1.0);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    vec3 outColor = diffuseLit*occ*fog+dom*0.2+spe*0.3;\n\tif (result.x >= FAR_CLIPPING_PLANE) outColor = vec3(0.0);\n\tfragColor = vec4(outColor, 1.0);\n\n}\n","name":"Buffer A","description":"","type":"buffer"}]}