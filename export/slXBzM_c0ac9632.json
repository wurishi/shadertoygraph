{"ver":"0.1","info":{"id":"slXBzM","date":"1650630868","viewed":269,"name":"Pieces of confetti","username":"bitless","description":"A little experiment with sorting elements into layers.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","confetti"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: Pieces of confetti\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n// IQ's vec2 to float hash.\nvec2 h22(vec2 p){\n    p += 22.;\n    p = vec2(dot(p, vec2(27.609, 157.583)), dot(p, vec2(58.827, 17.443)));\n    return fract(sin(p)*43758.5453); \n} \n\n\n//Inigo Quiles article \"Simple color palettes\" \n//https://iquilezles.org/articles/palettes/\n#define pall(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) )\n\n//Inigo Quiles article \"Remapping functions\" \n//https://iquilezles.org/articles/functions/ \nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.;\n    x /= w;\n    return 1. - x*x*(3.-2.*x);\n}\n\nvoid mainImage0( out vec4 O, in vec2 g )\n{\n    vec2 r =    iResolution.xy\n        ,uv =   (g+g-r)/r.y/2.\n                *vec2(10.+sin(iTime*.5)*2.) //camera zoom\n                *vec2(-1,1);    //flip x-coordinate\n\n    O = -O;\n    \n    float   T = iTime*4.\n            ,i = (mod(T,60.) < 30.) ? 1. : -1.\n            ,j = (mod(T+15.,60.) < 30.) ? 1. : -1.\n            ,m              \n            ,d = .6     //size of confetti piece\n            ,d2\n            ,m_max = -1.    \n            ,s\n            ,t = floor(T/15.); //cicle number\n    \n    vec4    cm, cr[9];  \n            \n    uv -= cubicPulse(1.,5.,(mod(T-1.,15.)-5.))*.5*vec2(i,j); //camera move cicle\n    vec2 cl = floor(uv),            //current cell id\n         xy = fract(uv)-.5,         //cell local coordinates\n         c, sh;\n        \n    int x, y;\n    \n    for (x = -1; x <2; x++)     //filling the array (3,3) of the current cell and its neighbors\n    {\n        for (y = -1; y <2; y++)\n        {\n            c = cl-vec2(x,y);   //cell id\n            cm.z = h22(c).x;      //cell height value\n            cm.w = cubicPulse(1.,4.,c.x*i+c.y*j+(mod(iTime*4.,15.)-5.)*5.) *.1; //coefficient of variation of confetti diameter for a given cell\n            sh = h22(vec2(cm.z*t)); //piece current position\n            ////mixes the current position of the piece with the position in the next cycle  \n            sh = mix (sh, h22(vec2(cm.z*(t+1.))), smoothstep(-2.,9.,c.x*i+c.y*j+(mod(T,15.)-5.)*5.)); \n            cm.xy = vec2(x,y) + sh*.7 + cm.w*.4; //confetti shift relative to the center of the cell\n            cr[(x+1)*3+y+1] = cm; \n        }\n    }\n        \n    for (x = 0; x < 9; x++)  //find the topmost piece\n    {\n        m = cr[x].z*step (length(xy+cr[x].xy),cr[x].w+d); //height and mask of piece\n        if (m_max < m) \n        {\n            cm = cr[x];\n            m_max = m;\n        }\n    }\n        \n    for (x = 0; x < 9; x++) //add the shadows from all neighboring pieces above the current one\n    {\n        d2 = cr[x].w*3.+d;\n        m = cr[x].z* step (length(xy+cr[x].xy+vec2(cr[x].w+.05)),d2); //mask of piece shadow\n        if (m > m_max)  s = max (s, smoothstep (d2,d2-cr[x].w*2.-.05,length(xy+cr[x].xy+vec2(cr[x].w+.05))));\n    }\n    \n    d = cm.w+d; //piece diameter\n    m = step (length(xy+cm.xy),d); //piece mask\n\n    O = mix (vec4 (0,.05,.1,1) //background color\n            ,vec4(pall(cm.z,vec3(.6),vec3(.5),vec3(.5),vec3(.1,.2,.3)) //piece color\n                *(1.5-fract(cm.z*10.))                                  //piece brightness variation                           \n                *(1.-abs(fract(length(xy+cm.xy)*(10.-cm.w*15.))-.5)*.5) //circle pattern\n                ,1.)\n            ,m);\n    O = mix (O,vec4(0),s*.5);      //add shadows\n    \n}\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    vec4 T;                                                \n    int AA = 2, /* Set the Anti-Aliasing level (1-16) higher numbers are SLOW! */\n        x = 0, y;\n    O = vec4(0);\n    for (;x++ < AA;) for (y=0; y++ < AA; O += min(T,1.) )  \n        mainImage0( T, U + vec2(x,y)/float(AA)-.5 );        \n    O /= float(AA*AA);\n}","name":"Image","description":"","type":"image"}]}