{"ver":"0.1","info":{"id":"4tGXWz","date":"1483746786","viewed":92,"name":"GR - A Point on a Grid","username":"bradleygriffith","description":"A point on a grid.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["grid","point"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nfloat whenEq(float x, float y) {\n  return 1.0 - abs(sign(x - y));\n}\n\nfloat whenNeq(float x, float y) {\n  return abs(sign(x - y));\n}\n\nfloat whenGt(float x, float y) {\n  return max(sign(x - y), 0.0);\n}\n\nfloat whenLt(float x, float y) {\n  return max(sign(y - x), 0.0);\n}\n\n// Taken from https://www.shadertoy.com/view/MdlGRr\nfloat IsGridLine(vec2 fragCoord, float spacing)\n{\n\t// Define the size we want each grid square in pixels\n\tvec2 vPixelsPerGridSquare = vec2(spacing);\n\t\n\t// Get a value in the range 0->1 based on where we are in each grid square\n\t// fract() returns the fractional part of the value and throws away the whole number part\n\t// This helpfully wraps numbers around in the 0->1 range\n\tvec2 vGridSquareCoords = fract(fragCoord / vPixelsPerGridSquare);\n\t\n\t// Convert the 0->1 co-ordinates of where we are within the grid square\n\t// back into pixel co-ordinates within the grid square \n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\n\t// step() returns 0.0 if the second parmeter is less than the first, 1.0 otherwise\n\t// so we get 1.0 if we are on a grid line, 0.0 otherwise\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\t\n\t// Combine the x and y gridlines by taking the maximum of the two values\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\n\treturn fIsGridLine;\n}\n\n// Useful for adjusting x or y distances in accordance with screen ratio.\nvec2 stepAdjustment () {\n    vec2 adjustment = vec2(1.0);\n\n    adjustment.x -= (1.0 - iResolution.y / iResolution.x) * whenGt(iResolution.y, iResolution.x);\n    adjustment.y -= (1.0 - iResolution.x / iResolution.y) * whenGt(iResolution.x, iResolution.y);\n   \n\treturn adjustment;\n}\n\n// Slope from degrees, adjusted for screen ratio.\nfloat normalizedSlopeForDegrees(float degrees) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n    float radians = degrees * (PI / 180.0);\n    float slope = tan(radians);\n\n    return ((slope * 100.0) / p.x) / (100.0 / p.y);\n}\n\n// Given x, a slope, and another point, find y for x.\nfloat yForXOnSlope(float x, float slope, vec2 p2) {\n\treturn -1.0 * ((slope * (p2.x - x)) - p2.y);\n}\n\n// Given y, a slope, and another point, find x for y.\nfloat xForYOnSlope(float y, float slope, vec2 p2) {\n    return ((y - p2.y) + (slope * p2.x)) / slope;\n}\n\nvec2 offsetsForUvAtDistanceOnSlope(float d, float slope) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n    float slopeAdjustment = 0.0;\n\n    slopeAdjustment += (iResolution.y / iResolution.x) * whenGt(iResolution.y, iResolution.x);\n    slopeAdjustment += (iResolution.x / iResolution.y) * whenGt(iResolution.x, iResolution.y);\n    \n    \n\treturn vec2(\n        ((d * p.x) * cos(atan(slope / slopeAdjustment))),\n        ((d * p.y) * sin(atan(slope / slopeAdjustment))) \n    );\n}\n\nfloat point(vec2 fragCoord, vec2 position, float width) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n\n    float dist = distance(fragCoord, position * iResolution.xy);\n    \n    return smoothstep(width, width + 1.0, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 stepAdjustment = stepAdjustment();\n    \n    vec2 position = vec2(0.5);\n    if (iMouse.z > 0.0) {\n        position = iMouse.xy / iResolution.xy;\n    }\n    \n    float pointWidth = 10.0;\n    float gridWidth = 20.0;\n    \n    // Test Config Here -----------------------------\n    \n    float angle = 45.0;\n    float slope = normalizedSlopeForDegrees(angle);\n    vec2 anchor = vec2(0.5);\n    \n    float x = (sin(iTime) / 4.0 * stepAdjustment.x) + 0.5;\n    position = vec2(x, yForXOnSlope(x, slope, anchor));\n    \n    //float y = (sin(iTime) / 4.0 * stepAdjustment.y) + 0.5;\n    //position = vec2(xForYOnSlope(y, slope, anchor), y);\n    \n    vec2 k = offsetsForUvAtDistanceOnSlope(0.0, slope);\n    position += k;\n    \n    //float reverseSlope = -(1.0 / slope);\n    //vec2 k2 = offsetsForUvAtDistanceOnSlope(0.0, reverseSlope);\n    //position += k2;\n   \t\n    // ----------------------------------------------\n    \n    float point = point(fragCoord, position, pointWidth);\n    float grid = IsGridLine(fragCoord, gridWidth);\n\n    fragColor = vec4(point - grid);\n}","name":"Image","description":"","type":"image"}]}