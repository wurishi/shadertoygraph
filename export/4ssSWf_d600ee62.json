{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Cairo tiling by nimitz (stormoid.com) (twitter: @stormoid)\n\n//Inspired by Petri Leskinen's \"Cairo Pentagonal Tiling\" http://pixelero.wordpress.com/page/2/\n\n/*\n\tCairo pentagonal tiling made using a \"voronoi-like\" function,\n\tthe main difference is that half the tiles are reflected and the centers are\n\tdisplaced symmetrically.\n\n\tPlease let me know if you can think of a simple way to get all the edges.\n*/\n\n#define time iTime*0.5\nfloat hash( float n ){ return fract(sin(n)*43758.5453);}\n\n\n//returns: x -> distance form center | y -> cell id | z -> distance from edge\nvec3 field(const in vec2 p)\n{\n    vec2 fp = fract(p);\n    vec2 ip = floor(p);\n    \n    vec3 rz = vec3(1.);\n    \n    //vary the offset over time\n    float of = sin(time*0.6)*.5;\n    \n    //reflect\n   \tfloat rf = mod(ip.x+ip.y,2.0);\n    fp.x = rf-fp.x*sign(rf-.5);\n    \n\tfor(float j=0.; j<=1.; j++)\n\tfor(float i=0.; i<=1.; i++)\n    {\n        vec2 b = vec2(j, i);\n        \n        //Displace each sample\n        float sgn = sign(j-0.5); \n        float cmp = float(j == i);\n        vec2 o = vec2(sgn*cmp,-sgn*(1.-cmp));\n        //o = b-vec2(i,j); //variation\n        vec2 sp = fp - b + of*o;\n        b += o;\n        \n        float d = dot(sp,sp);\n        \n        if( d<rz.x )\n        {\n            rz.z = rz.x;\n            rz.x = d;\n            b.x = rf-b.x*sign(rf-.5);\n        \trz.y = hash( dot(ip+b,vec2(7.0,113.0) ) );\n        }\n        else if( d<rz.z )\n\t\t{\n            rz.z = d;\n\t\t}\n    }\n    \n    //truncation\n    float d = dot(fp-.5,fp-.5);\n    d += 0.4; //truncation weight\n    if (d < rz.x)\n    {\n        rz.z = rz.x;\n        rz.x = d;\n        rz.y = hash( dot(ip,vec2(7.0,113.0) ) );\n    }\n    else if(d < rz.z )\n\t{\n    \trz.z = d;\n\t}\n    \n    //F2-F1 edge detection\n    rz.z = rz.z-rz.x;\n    \n    return rz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n    float a = sin(time)*.5;\n    float b = .5;\n    \n    p *= 6.+sin(time*0.4);\n    p.x += time;\n    p.y += sin(time)*0.5;\n    \n    vec3 rz = field(p);\n    \n    vec3 col = (sin(vec3(.2,.55,.8)+rz.y*4.+2.)+0.4)*0.6+0.5;\n    col *= 1.-rz.x;\n    col *= smoothstep(0.,.04,rz.z);\n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ssSWf","date":"1407374606","viewed":2097,"name":"Cairo tiling","username":"nimitz","description":"Cairo pentagonal tiling and snub square tiling.\n\nThe standard \"F2-F1\" edge detection misses the reflected edges, is there a solution which doesn't involve evaluating twice? ","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","tiling"],"hasliked":0,"parentid":"","parentname":""}}