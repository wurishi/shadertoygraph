{"ver":"0.1","info":{"id":"ctSGWW","date":"1673278645","viewed":334,"name":"Alternative Scrolling Matrix","username":"Pseudonymous","description":"Samples a given video as if it were part of the matrix","likes":2,"published":1,"flags":2,"usePreview":0,"tags":["pixel","pixelation","matrix"],"hasliked":0,"parentid":"dtSGDR","parentname":"Pixelated Video Matrix"},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup pixel counts of horizontal and vertical divisions\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // process video\n    vec2 resolution = vec2(40., 300.);\n    vec2 remapped = round(resolution * uv + .5) / resolution;\n    // the above basically collapses our uv coordinates to a discrete field instead of a continuous one\n    // by sampling the texture with these new uvs, we find multiple pixels now map to the same uv coord, \n    // giving the effect of pixelation\n    vec3 col = texture(iChannel0, remapped).rgb;\n    \n    // convert video to grayscale based on average of RGB channels\n    col = vec3(col.r + col.g + col.b) / 3.;\n    \n    // bump contrast\n    col *= col * col * 3. - .2;\n    \n    \n    vec2 fontGrid = vec2(16.);\n    \n    float speed = .3;\n    // 0 - 1\n    float sampleInd = fract(uv.y + speed * abs(fract(10.*remapped.x+iTime)+abs(5.*sin(remapped.x * 3.14) + sin(remapped.x * 10.))));\n    \n    \n    // row col offset to start sample into grid\n    vec2 fontStart = vec2(1., 0.);\n    vec2 fontEnd = vec2(8., 16.);\n    \n    vec2 fontSampleCoord = vec2(\n        fontStart.x + fract(resolution.x * (uv.x - remapped.x)), \n        fontStart.y + (fontEnd.y - fontStart.y) * sampleInd\n    );\n        \n    fontSampleCoord /= fontGrid; // normalize to grid size\n    \n    col *= texture(iChannel1, fontSampleCoord).rrr;\n    //col = vec3(fontSampleCoord, 0.);\n    \n    // color correct to matrix green\n    col *= vec3(.1, 1., .3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}