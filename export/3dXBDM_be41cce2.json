{"ver":"0.1","info":{"id":"3dXBDM","date":"1588313317","viewed":64,"name":"flame_fractal","username":"blepfo","description":"Technically an IFS is a flame fractal\nMight add more detail later","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // raw y in [0, 1]\n    float rawY = uv.y;\n    vec2 iMouse = iMouse.xy / iResolution.xy;\n    // Move to origin\n    uv = translate(uv, vec2(0.5, 0.45));\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Map coordinates to [-globalScale, -globalScale] x [globalSclae, globalScale]\n    float globalScale = 28.;\n    vec2 scaleLayer = uv*globalScale;\n    \n    // Sierpinski gaskets\n    int ITERATIONS = 3;\n    // Limit iterations to prevent crash\n    ITERATIONS = int(min(float(ITERATIONS), 4.));\n    float gasketScale = 2.;\n    vec2 gasketLayer = uv * gasketScale;\n    // Waver = noise in x direction decaying with y\n    float waverFrequency = gasketScale * 3.;\n    float waverLowIntensity = 0.235;\n    float waverHighIntensity = .01;\n    vec2 waverLayer = (uv + iTime/3.) * waverFrequency;\n    float waver = waverLowIntensity * symmetrize(smoothRand(waverLayer.y, vec2(0.050,0.400)));\n    waver = mix(waver, \n                waverHighIntensity*symmetrize(smoothRand(waverLayer.y*5., vec2(0.060,0.190))),\n                0.5\n               );\n    // Decay waver with y\n    waver *= (uv.y + 0.5) / 3.968;\n    gasketLayer = translate(gasketLayer, vec2(waver, 0));\n\t// GASKETS\n    float gasketMain = sierpinskiPseudoSdf(gasketLayer, ITERATIONS);\n    float subGasketY = -0.49;\n    float subGasketX = -1.5;\n    float gasketL = sierpinskiPseudoSdf(\n        translate(gasketLayer*2., vec2(subGasketX,subGasketY)), ITERATIONS\n    );\n\tfloat gasketR = sierpinskiPseudoSdf(\n        translate(gasketLayer*2., vec2(-subGasketX,subGasketY)), ITERATIONS\n    );\n    float sdfSmoothing = 32.;\n    float gasket = smoothMin(gasketMain, gasketL, sdfSmoothing);\n    gasket = smoothMin(gasket, gasketR, sdfSmoothing);\n    // background = lower opacity\n    float bgX = -1.328;\n    float bgY = -0.468;\n    float bgMain = sierpinskiPseudoSdf(\n        translate(gasketLayer*vec2(-.935, 0.95), vec2(0., .02)), ITERATIONS\n    );\n    vec2 bgDetailScale = vec2(-1.75, 1.9);\n    float bgL = sierpinskiPseudoSdf(\n        translate(gasketLayer*bgDetailScale, vec2(-bgX, bgY)), ITERATIONS\n    );\n    float bgR = sierpinskiPseudoSdf(\n        translate(gasketLayer*bgDetailScale, vec2(bgX, bgY)), ITERATIONS\n    );\n    float bgGasket = smoothMin(bgMain, bgL, sdfSmoothing);\n    bgGasket = smoothMin(bgGasket, bgR, sdfSmoothing);\n    \n    // Animate with pixelated vaue noise\n    float noiseFrequency = 1.216;\n    float noiseScale = 0.018;\n    vec2 noiseLayer = translate(scaleLayer*noiseFrequency, vec2(2.848*sin(iTime),6.*iTime));\n    float vNoise = noiseScale*symmetrize(valueNoise(noiseLayer, vec2(1.000,0.850)));\n    // foreground noise\n    float foregroundSdf = gasket + vNoise;\n    float foreground = step(0., foregroundSdf);\n    float foregroundBorder = step(0., abs(foregroundSdf) - 0.013);\n    // backgorund noise\n    float bgSdf = bgGasket - vNoise;\n    float bg = step(0., bgSdf);\n    float bgBorder = step(0., abs(bgSdf) - 0.023);\n    \n    float yellowScaleNoise = sin(iTime) * (.02 / float(ITERATIONS));\n    float yellowScale = (.27 / float(ITERATIONS)) + yellowScaleNoise;\n    float yellowBox = step(0., foregroundSdf + yellowScale);\n\n    // Colors\n    vec3 nightTop = vec3(0.029,0.035,0.195);\n    vec3 nightBottom = vec3(0.215,0.331,0.615);\n    vec3 red = vec3(0.895,0.262,0.098);\n    vec3 yellow = vec3(0.890,0.713,0.014);\n    \n    vec3 color = mix(nightBottom, nightTop, sqrt(rawY));\n    // Uncomment to see gasket noise\n    // color = vec3(((vNoise / noiseScale)+1.)/2.);\n    // Uncomment to see waver noise\n    // color = vec3(waver) / 0.024;\n    \n    // Flame backgrounds\n    float bgOpacity = 0.676;\n    color = mix(color, vec3(0.), (1.-bgBorder)*1.);\n    color = mix(color, yellow, (1.-bg)*bgOpacity);\n    // Main flames\n    color = mix(color, vec3(0.), 1.-foregroundBorder);\n    color = mix(color, red, 1.-foreground);\n    color = mix(color, yellow, 1.-yellowBox);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define RAND_SEED (283846.698)\n#define MAX_ITERATIONS (128)\n\n\n\n/* To generate binomial coefficients needed for Sierpinski iteration N, \nuse below Python script.\nIteration N needs 2^N Binomial coefficients, which can be stored in a (2^(N-1))*((2^(N-1))+1) array\nCopy below into https://repl.it/languages/python\n\n\nSCRIPT\n------\n\n# N Sierpinski iterations\nN = 4\n# Sierpinski iteration N needs 2^N rows\nMAX_PASCAL_ROWS = pow(2, N)\n# M Pascal rows needs (M/2)*((M/2)+1) entries\nPASCAL_STORAGE = (MAX_PASCAL_ROWS // 2) * ((MAX_PASCAL_ROWS // 2) + 1)\n\ndef choose(n, k):\n  c = 1\n  for i in range(k):\n    c = c * (n - i) / (i + 1)\n  return c\n\nbCoeffs = [1]*PASCAL_STORAGE\ni = 0\nfor n in range(MAX_PASCAL_ROWS):\n  for k in range(0, (n//2 )+1):\n    bCoeffs[i] = int(choose(n, k))\n    i += 1\n\nbCoeffStr = str(bCoeffs).replace('[', '').replace(']', '')\nnCoeffs = len(bCoeffs)\nprint(f'int[{nCoeffs}] BCOEFFS = int[{nCoeffs}]({bCoeffStr});')\n\n\nEXAMPLE OUTPUT (N = 4)\n--------------\nint[72] BCOEFFS = int[72](1, 1, 1, 2, 1, 3, 1, 4, 6, 1, 5, 10, 1, 6, 15, 20, 1, 7, 21, 35, 1, 8, 28, 56, 70, 1, 9, 36, 84, 126, 1, 10, 45, 120, 210, 252, 1, 11, 55, 165, 330, 462, 1, 12, 66, 220, 495, 792, 924, 1, 13, 78, 286, 715, 1287, 1716, 1, 14, 91, 364, 1001, 2002, 3003, 3432, 1, 15, 105, 455, 1365, 3003, 5005, 6435);\n*/\n\nint[72] BCOEFFS = int[72](1, 1, 1, 2, 1, 3, 1, 4, 6, 1, 5, 10, 1, 6, 15, 20, 1, 7, 21, 35, 1, 8, 28, 56, 70, 1, 9, 36, 84, 126, 1, 10, 45, 120, 210, 252, 1, 11, 55, 165, 330, 462, 1, 12, 66, 220, 495, 792, 924, 1, 13, 78, 286, 715, 1287, 1716, 1, 14, 91, 364, 1001, 2002, 3003, 3432, 1, 15, 105, 455, 1365, 3003, 5005, 6435);\n\nint choose(int n_, int k_) {\n    // Convert to float for easier arithmetic\n    float n = float(n_);\n    float k = float(k_);\n    \n    // If k > (n//2), flip to (n-k)\n    k = (k > floor(n / 2.))\n    \t? n-k\n        : k\n\t;\n        \n \tfloat i = \n        // If n even, start at (n/2)*((n/2)+1)\n        ((1. - mod(n, 2.)) * ((n/2.)*((n/2.)+1.)))\n        // If n odd, start at ((n+1)/2)^2\n        + (mod(n, 2.) * ((n+1.)/2.)*((n+1.)/2.))\n  \t;\n    int idx = int(i);\n    return BCOEFFS[idx+int(k)];  \n}\n\n\n\nvec2 translate(vec2 uv, vec2 t) {\n    return uv - t;\n}\n\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\n\nfloat random2(vec2 uv) {\n    return fract(\n        RAND_SEED\n        * (sin(dot(uv, vec2(21.12, 17.23)))\n        \t+ cos(dot(uv, vec2(12.2241, 22.433)))\n        )\n    );\n}\n\n\nfloat smoothRand(float x, vec2 blur) {\n    float i = floor(x);\n    return mix(random2(vec2(i)), random2(vec2(i+1.)), smoothstep(blur[0], blur[1], fract(x)));\n}\n\n\nfloat valueNoise(vec2 uv, vec2 blur) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    float a = random2(i);\n    float b = random2(i + vec2(1., 0));\n    float c = random2(i + vec2(0., 1.));\n    float d = random2(i + vec2(1., 1.));\n\tvec2 u = smoothstep(blur[0], blur[1], f);\n    // Bilinear\n    float ab = mix(a, b, u.x);\n    float cd = mix(c, d, u.x);\n    return mix(ab, cd, u.y);\n}\n\n\n// Rectangle centered at (0, 0)\nfloat rectSdf(vec2 uv, vec2 halfSize) {\n    vec2 edgeDist = abs(uv) - halfSize;\n    float inDist = min(max(edgeDist.x, edgeDist.y), 0.);\n    float outDist = length(max(edgeDist, 0.));\n    return inDist + outDist;\n}\n\n// Sierpinski gasket SDF using min of squares\nfloat sierpinskiPseudoSdf(vec2 uv, int N) {\n    vec2 sUv = 2.*uv;\n    float sdf = 100000.;\n    // Iteration N has 3^N boxes of scale 2^(-N)\n    float scale = pow(2., float(N));\n    float fscale = 1. / scale;\n    \n    if (N == 0) return rectSdf(uv, vec2(0.5));\n    \n    vec2 startCenter = vec2(-1. + fscale);\n    // Colstart resets to (fscale / 2.) farther to the right every row\n    float colStart = -1. + fscale;\n    \n    // Pascals triangle idxs\n    int pascalRow = int(scale) - 1;\n    int pascalCol = 1;\n    \n    for (int row = 0; row < MAX_ITERATIONS; row++) {\n        if (pascalRow < 0) { break; }\n        pascalCol = 0;\n        startCenter.x = colStart;\n        for (int col = 0; col < MAX_ITERATIONS; col++) {\n            if (pascalCol > pascalRow) { break; }\n            int pascalCoeff = choose(pascalRow, pascalCol);\n            if (mod(float(pascalCoeff), 2.) == 1.) {\n            \tsdf = min(\n                \tsdf, \n                    //sdEquilateralTriangle(sUv*scale)\n                \trectSdf(translate(sUv, startCenter), vec2(fscale))\n            \t);\n            }\n        \t// Update coords for next column\n            pascalCol += 1;\n        \tstartCenter.x += fscale * 2.;\n        }\n        pascalRow -= 1;\n        // Adjust coordinates for next row\n        colStart += fscale;\n        startCenter.y += fscale * 2.;\n    }\n\n    return sdf;\n}\n\n// Remap x in [0, 1] to [-1, 1]\nfloat symmetrize(float x) {\n    return (2.*x) - 1.;\n}\n\n\nfloat smoothMax(float a, float b, float k) {\n    return (1. / k) * log2(exp2(k*a) + exp2(k*b));\n}\n\n\nfloat smoothMin(float a, float b, float k) {\n    return -smoothMax(-a, -b, k);\n}","name":"Common","description":"","type":"common"}]}