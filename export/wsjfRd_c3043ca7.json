{"ver":"0.1","info":{"id":"wsjfRd","date":"1590646563","viewed":427,"name":"fwidth vs length(dFdxy)","username":"FabriceNeyret2","description":"fwidth() is convenient to tune a LOD. \nBut it's a L1 norrm, not L2, and thus angularly biased -> length(vec2(dFdx,dFdy)) is better (top).\nWhat then applied to vectors ? MIPmap rely on max. Again, length() is smoother (top).\nBottom: len(width) vs width(len","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["tuto","hardwarederivatives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define matNorm(m) sqrt( m[0][0]*m[0][0] +  m[1][0]*m[1][0] +  m[0][1]*m[0][1] +  m[1][1]*m[1][1] )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         M = 2.*iMouse.xy - 1. - R,\n         U = ( 2.* u -1. - R ) / R.y;\n    \n    U = U/dot(U,U);                                   // example function: inversion\n    \n    int i = int(U.x>0.) + 2*int(U.y>0.);              // quadrant id\n    if (iMouse.z>0.) i = int(M.x>0.) + 2*int(M.y>0.); // click to open\n    else if (U.y==0.||U.x==0.&&U.y<0.) { O = vec4(0,0,1,0); return; }  // blue separators\n    \n    float m =   i==0 ?  length(fwidth(U))\n              : i==1 ?  fwidth(length(U))\n           // : i==2 ?  fwidth(U.x)+fwidth(U.y)       // looks identical to case 0 * sqrt(2)\n           // : i==2 ?  max(fwidth(U.x),fwidth(U.y))  // looks identical to case 0 / sqrt(2)\n              :         length(vec2(length(dFdx(U)),length(dFdy(U)))); \n                        // is matNorm( mat2(dFdx(U),dFdy(U)) );\n    O = vec4(16.*m);\n    O.gb = sin(O.gb);\n}","name":"Image","description":"","type":"image"}]}