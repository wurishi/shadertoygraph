{"ver":"0.1","info":{"id":"ldtyRn","date":"1517807715","viewed":235,"name":"pulse ring","username":"germ","description":"learning and looking for feedback","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["pulse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by https://codepen.io/peeke/pen/BjxXZa\n#ifndef PI\n#define PI 3.141592653589793\n#endif\n\nfloat backIn(float t) {\n    return pow(t, 3.0) - t * sin(t * PI);\n}\n\n// see how our zigZag and upWave waves look plotted:  \n// https://www.desmos.com/calculator/dn8kffitdg\n \n// zigzag wave\nfloat zigZag(float dx) {\n    float b = -mod(floor(dx), 2.0);\n    float a = (-1.0 + 2.0 * mod(floor(dx), 2.0));\n\n    return (dx - floor(dx)) * a + b + 1.0;\n}\n\n// diagonal line that goes up\n// returns [0, 1]\nfloat upWave(float dx) {\n    return (dx - floor(dx));\n}\n\nfloat circle(vec2 uv, float startRadius, float rangeSize, bool fade) {\n    float time = 0.5 + iTime * 0.8;\n\n    float ease;\n\n    if (fade) {\n      // shifted, but at a normal frequency\n      ease = upWave(0.5 + time);\n    } else {\n      // increased frequency\n      ease = backIn(zigZag(2.0 * time));\n    }\n\n    float radius = startRadius + ease * rangeSize;\n    \n    // our coordinate system uses [0, 1] and we want to find the distance\n    // of our point to the center (0.5, 0.5).  we first adjust our point\n    // by the center (giving it a new center of 0, 0).  we can then use this\n    // toCenter point to find the distance (vector length) to the center.\n    vec2 toCenter = vec2(uv - 0.5);\n  \n    // adjust toCenter for aspect ratio\n    toCenter.x *= iResolution.x / iResolution.y;\n\n    // (vector length) distance from the pixel to the center\n    float dist = length(toCenter);\n    \n    // a single pixel in [0, 1] coordinate space is 1 / res;\n    float res = min(iResolution.x, iResolution.y);\n\n    /*\n    // circle without smoothed edges\n    // (if the distance to the pixel is less than our radius)\n    float c = (dist <= radius / res) ? 1.0 : 0.0;\n    */  \n    \n    // our smoothness area\n    float smoothness = 2.0 / res;\n    \n    // circle with smoothed edges\n    // smoothstep(e1, e2, x) interpolates from [0, 1] when x is within e1 and e2\n    // returns 0 when x < e1 and 1 when x > e2.\n    // essentially, this does the same thing as \"circle without smoothed edges\", but \n    // gives us a nice gradient when we are within radius and radius + smoothness\n    float c = smoothstep(radius / res + smoothness, radius / res, dist);\n    \n    // mix(x, y, a) will interoplate a from x to y\n    if (fade) {\n      // fade the ring as we go outward\n      float opacity = (1.0 - smoothstep(0.1, 0.9, ease));\n      return mix(0.0, 1.0, c * opacity);\n    } else {\n      return mix(0.0, 1.0, c);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalize pixel coordinates to [0, 1]\n    vec2 uv = ( fragCoord.xy / iResolution.xy ) ;\n\n    // define the base background color\n    vec3 color = vec3(.21, .22, .28);\n  \n    // calculate the circles\n    float outerCircleAlpha = circle(uv, 25.0, 80.0, true) * 0.85;\n    float innerCircleAlpha = circle(uv, 45.0, 10.0, false);\n  \n    // mix in the circle alpha colors with a circle color and the base color \n    color = mix(color, vec3(0.0, .64, .91), outerCircleAlpha);\n    color = mix(color, vec3(1.0, 1.0, 1.0), innerCircleAlpha);    \n    \n    // render the color\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}