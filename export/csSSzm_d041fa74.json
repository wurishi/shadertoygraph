{"ver":"0.1","info":{"id":"csSSzm","date":"1670785851","viewed":131,"name":"biq logo animation ðŸ”Š","username":"blurryroots","description":"Company logo animation with sound effects.\nhttps://think-biq.com/","likes":5,"published":1,"flags":40,"usePreview":0,"tags":["sdf","logo","animation","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy Educational License\n// (c) Original work by Sven Freiberg.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n#define WITH_SOUND_IN 1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float generalspeed = phi;\n    float t = generalspeed * iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvn = \n        (fragCoord.xy - 0.5*iResolution.xy)\n            / min (iResolution.x, iResolution.y)\n        ;\n    uvn *= 2.;\n    \n    float pqgravity = 0.0\n        + 0.2 * animate (t, 1.8, 2.0)\n        - 0.1 * animate (t, 3.8, phi)\n        ;\n    \n    Box shadowl = DefaultBox, shadowr;\n    shadowl.size = vec2 (0.4);\n    shadowl.position.x = 0.0\n        - 0.7 * animate (t, 0.3, 1.88)\n        + pqgravity\n        ;\n    shadowr = shadowl;\n    shadowr.position.x *= -1.;\n    \n    Circle c = DefaultCircle, b = DefaultCircle, cdot = DefaultCircle;\n    c.size = 0.4;\n    c.position.x = 1.6\n        - 0.9 * animate (t, 0.2, 2.0)\n        - pqgravity\n        ;\n    c.fade = .001;\n    c.thickness = 0.1;\n    c.sharpness = 0.5;\n    b = c;\n    b.position.x *= -1.;\n    cdot.position.y = 0.0\n        + phi0/1.0 // * animate ((t-1.0)/2.)\n        ;\n    cdot.size = .05 * animate (t, phi-0.5, phi);\n    cdot.thickness = 1.;\n    cdot.sharpness = 0.5;\n    cdot.fade = .001;\n    \n    float wwintensity = 0.042;\n    float ww = 0.0\n        + wwintensity * animate (t, phi-0.5, phi)\n        - wwintensity * animate (t, pi-0.5, (phi*phi))\n        ;\n    float w = whisp (uvn, vec2 (0.0, phi0), ww);\n    \n    Box bi = DefaultBox, bidot = bi, bl, br;\n    bi.size = vec2 (0.02, .4 * animate (t, 0.0, 0.4));\n    bidot.size.x = bi.size.x;\n    bidot.size.y = bidot.size.x * animate (t, 0.0, phi0);\n    bidot.position.x = 0.0;\n    bidot.position.y = 0.0\n        + phi0 * animate (t, 0.0, (phi0))\n        ;\n    bl = bi;\n    bl.position.x = 0.0\n        - 1.08 * animate (t, 0.3, phi)\n        + pqgravity\n        ;\n    bl.position.y = 0.0\n        + 0.20 * animate (t, 0.5*phi0*phi, (phi*phi))\n        ;\n    bl.size.y = 0.0\n        + 0.40 * animate (t, 0.0, 0.4)\n        + 0.20 * animate (t, 0.5*phi0*phi, (phi*phi))\n        ;\n    br = bl;\n    br.position *= -1.0;\n    \n    vec3 wh = vec3 (1.0);\n    vec3 gL = vec3 (phi0, 0., phi0);\n    vec3 gR = 1. - vec3 (1., phi0, phi0);\n    vec3 ggL = wh;\n    vec3 ggR = wh;\n    #if 0\n    ggL = mix (wh, gL, phi0i/2.*animate (t, 3.*phi, phi));\n    ggR = mix (wh, gR, phi0i/2.*animate (t, 3.*phi, phi));\n    #endif\n    \n    // smoothstep(1.5*pixelwidth, 0., dist )\n    \n    vec3 s = vec3 (0.0);\n    s = max (box3 (uvn, shadowl, wh), box3 (uvn, shadowr, wh));\n    #if 1\n    // cutout of shadow/occluder regions.\n    s = min (s, max (circle3 (uvn, b, ggL), circle3 (uvn, c, ggR)));\n    #endif\n    s = max (s, box3 (uvn, bl, ggL));\n    s = max (s, box3 (uvn, bi, mix (ggL, ggR, 0.5)));\n    s = max (s, box3 (uvn, br, ggR));\n    s = max (s, circle3 (uvn, cdot, wh));\n    s = max (s, box3 (uvn, bidot, wh));\n    s = max (s, w);\n    \n    vec3 color = vec3 (s);\n    #if WITH_SOUND_IN\n    vec3 sound_in = texture (iChannel1, uv).rgb;\n    color = max (color, sound_in);\n    #endif\n    fragColor = vec4 (color, 1.0);\n} ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\nconst float phi = (1. + sqrt (5.)) / 2.;\nconst float phi0 = phi - 1.;\nconst float phi0i = 1. - phi0;\nconst float pi = 355./113.;\nconst float halfpi = 0.5 * pi;\nconst float tau = 2.0 * pi;\n\nint select (float t, float interval, int first, int last) {\n    return first + int (mod (floor (t / interval), float (last + 1 - first)));\n}\n\nfloat psin (float t) { return (1.0 + sin (t - halfpi)) / 2.0; }\nfloat pcos (float t) { return (1.0 + cos (t - halfpi)) / 2.0; }\n\nfloat sinramp (float t) {\n    float x = pi * clamp (t, 0.0, 1.0) - halfpi;\n    float s = sin (x) + 1.;\n    return (0.5 * s);\n}\nfloat animate (float t, float delay, float duration) {\n    return sinramp ((t - delay) / duration);\n}\nfloat mate (float t, vec2 range, float delay, float duration) {\n    float base = range.x;\n    float extend = range.y - base;\n    return base + extend * animate (t, delay, duration);\n}\nfloat smoothmate (float t, vec2 range, float delay, float duration) {\n    float x = smoothstep (delay, delay + duration, t);\n    float k = x * (range.y - range.x);\n    return range.x + k;\n}\n\nstruct Circle {\n    float size;\n    float fade;\n    float thickness;\n    float sharpness;\n    vec2 position;\n};\nconst Circle DefaultCircle =\n    Circle (1.0, 0.01, 0.5, 1.0, vec2 (0.0, 0.0));\n\nfloat circle (vec2 uv, Circle c) {\n    float d = c.size - length (uv - c.position);\n    float f = smoothstep (0.0, c.fade, d);\n    float tf = c.thickness * c.size;\n    float s = f * smoothstep (tf + c.fade, tf, d);\n    s = pow (s, c.sharpness);\n    float k = 1.0 - step(s, 0.0);\n    return s;\n}\n\nvec3 circle3 (vec2 uv, Circle c, vec3 color) {\n    return color * circle (uv, c);\n}\n\nfloat whisp (vec2 uv, vec2 p, float s) {\n    return (s / distance (uv, p));\n}\n\nvec3 whisp3 (vec2 uv, vec2 p, float s, vec3 color) {\n    return color * whisp (uv, p, s);\n}\n\nstruct Box {\n    vec2 size;\n    vec2 position;\n};\nconst Box DefaultBox = Box (vec2 (0.1), vec2 (0.0));\n\nfloat box (vec2 uv, Box b) {\n    vec2 d = abs (uv - b.position) - b.size;  \n\tfloat s = length (max (d, vec2 (0))) + min (max (d.x, d.y), 0.0);\n    s = -sign (s);\n    return s;\n}\n\nvec3 box3 (vec2 uv, Box b, vec3 color) {\n    return color * box (uv, b);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n#define SOFT 1\n#define STRONG 2\n\n#define VERSION STRONG\n\nfloat tone (float t, float f) {\n    return sin(tau * f * t);\n}\n\nvec2 mainSound (int samp, float time) {\n    float f = 432.0;\n    float k = 1.0 + 1./3.;\n    float s = 0.0;\n    \n    float a = 0.0\n        + animate (time, phi0*phi, phi0)\n        #if (SOFT == VERSION)\n        - animate (time, 1.*phi, phi0/3.0)\n        #else\n        - animate (time, phi, phi0/1.0)\n        #endif\n        ;\n    float m1 = a * tone (time, f);\n    float f0 = f / pow (k, 1.);\n    float m2 = a * phi0 * tone (time, f0);\n    s = mix (m2, m1, phi0);\n    \n    float a2 = 0.0\n        + animate (time, phi0/phi, phi)\n        - animate (time, 1.0, 1.0)\n        ;\n    float f2 = \n        #if (SOFT == VERSION)\n        mate (time, vec2 (k, k*k), phi0/2., phi)\n        #else\n        f * pow (k, 2.)\n        #endif\n        ; \n    float m3 = 1.0*a2 * tone (time, f2);\n    s = mix (m3, s, phi0);\n    \n    float a3 = 0.0    \n        + animate (time, 0.0, 0.4)\n        - animate (time, 0.4, phi0/2.)\n        ;\n    float f3 = f / pow (k, 3.);\n    float m4 = a3 * tone (time, f3);\n    s = mix (m4, s, phi0);   \n    \n    float a4 = 0.0    \n        + animate (time, 2.3, phi0)\n        - animate (time, 3.3, phi0/2.)\n        ;\n    float fff = k * k * k;\n    float m5 = a4 * tone (time, f / fff);\n    s = mix (m5, s, phi0);         \n          \n    float v = phi0;\n\n    vec2 o = v * vec2 (s);\n    return o;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const bool SOUND_IN = true;\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n// ===\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (SOUND_IN) {\n    // Overlay by FabriceNeyret2 https://www.shadertoy.com/view/MtyXRW\n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}  \n    }\n    \n    fragColor = vec4 (0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}