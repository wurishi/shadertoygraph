{"ver":"0.1","info":{"id":"WlcXRl","date":"1581496393","viewed":298,"name":"Raycasting Shader","username":"WillGordon","description":"A simple shader that renders a sphere using raycasting, can be used for point or directional light","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["rays","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphereIntersect(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n vec3 rc = ray-center;\n float c = dot(rc, rc) - (radius*radius);\n float b = dot(dir, rc);\n float d = b*b - c;\n float t = -b - sqrt(abs(d));\n float st = step(0.0, min(t,d));\n return mix(-1.0, t, st);\n}\n\n//CAMERA VARS --------\n\nvec3 cameraCenter = vec3(0.0, 0.0, -3.0);\n\nfloat imagePlaneDist = 1.0;\n\n//SPHERE VARS --------\n\nvec3 sphereCenter = vec3(0.0, 0.0, 10.0);\n\nfloat radius = 3.0;\n\nvec3 sphereColor = vec3(1.0, 0.1, 0.1);\n\n//LIGHTING ------------\n\n//Set 1 to use direction, 0 to use Point\nfloat useDirectionalLight = 0.0; \n\n//DIRECTIONAL ONLY\n\n//Strength of light\nfloat intensity = 1.0;\n\n//Direction of light\nvec3 lightDir = vec3(0.0, 1.0, -1.0);\n\n\n//POINT ONLY\n\n//Position of light\nvec3 lightPos = vec3(0.0, 1.0, 1.0);\n\n//Only maximum range\nfloat maxLightRange = 10.0;\n\n//resulting range based on position, no need to set\nfloat lightRange = 0.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Fix Aspect ratio\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Ray start\n    vec3 rayOrigin = cameraCenter;\n\n    //Ray move\n    vec3 imagePlanePixel = vec3(uv.x, uv.y, cameraCenter.z + imagePlaneDist);\n    vec3 rayDir = normalize(imagePlanePixel - rayOrigin);\n   \n    //Sphere Intersect\n    float t = sphereIntersect(rayOrigin, rayDir, sphereCenter, radius);\n\n    //hit position\n    vec3 hit = rayOrigin + rayDir * t;\n    \n    //Clamp sphere intersection to 0 or 1\n    t = clamp(t, 0.0, 1.0);\n    \n    //Normal of sphere\n    vec3 normal = normalize(hit - sphereCenter); \n    \n    //Get distance to light\n    vec3 lightDist = (lightPos - normal);            \n        \n    //Get how bright the pixel should be if using directional light\n    float dotProduct = max(dot(normalize(lightDist), normalize(-lightDir)), 0.0);                       \n            \n    //Falloff calculations    \n    lightRange = step(maxLightRange, length(lightDist));    \n    lightRange = (length(lightDist) * length(lightDist)) / (maxLightRange * maxLightRange);\n    lightRange = 1.0 - lightRange;\n    float lightLambert = max(dot(normal, normalize(lightPos - hit)), 0.0);        \n                        \n    // Output to screen\n    //Check to see if using directional or point light\n    float check = step(1.0, useDirectionalLight);    \n        \n    vec4 dirColor = vec4(sphereColor * dotProduct * t * intensity, 1.0) * check;            \n    \n    vec4 pointColor = vec4(sphereColor * lightRange * t * lightLambert, 1.0) * (1.0 - check);\n    \n    //One will be zero the other will have a color\n    fragColor = dirColor + pointColor;     \n    \n}","name":"Image","description":"","type":"image"}]}