{"ver":"0.1","info":{"id":"dsyXRD","date":"1680783019","viewed":55,"name":"L'anneau unique","username":"masniera","description":"L'anneau flottant sur un lac de lave","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["lave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Définition de la résolution de l'écran\n#define R iResolution.xy\n\n// Distance minimale aux objets\n#define DIST_MIN 1.\n\n// Distance maximale aux objets\n#define DIST_MAX 200.0\n\n// Nombre maximal d'étapes pour le ray-marching\n#define RAY_MARCH_STEPS 100\n\n// Considérer comme une intersection si on atteint cette distance\n#define RAY_MARCH_PRECI 0.0001\n\n// Pour le calcul de la direction du rayon\n#define PI 3.14159265359\n\n// Structure pour un rayon\nstruct Ray\n{\n    vec3 o; // Origine\n    vec3 d; // Direction\n};\n\n// Structure pour une surface\nstruct Surface\n{\n    float t; // Distance à la surface\n    vec3 c;  // Couleur de la surface\n};\n\n// Opération de fusion de deux distances\nfloat opUnion(float d1, float d2) { return min(d1, d2); }\n\n// Fonction pour calculer la distance à une surface plane\nfloat sdFloor(vec3 p)\n{\n    return p.y + 0.1;\n}\n\n// Fonction pour calculer la distance à une sphère creuse\nfloat sdCutHollowSphere(vec3 p, float r, float h, float t)\n{\n    // Calculs indépendants de l'échantillonnage (dépendent uniquement de la forme)\n    float w = sqrt(r * r - h * h);\n\n    // Calculs dépendants de l'échantillonnage\n    vec2 q = vec2(length(p.xz), p.y);\n    return ((h * q.x < w * q.y) ? length(q - vec2(w, h)) : abs(length(q) - r)) - t;\n}\n\n// Fonction de hachage\nfloat hash13(vec3 p)\n{\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.5432))) * 43758.5453123);\n}\n\n// Fonction pour calculer la surface à une position donnée\nSurface scene(in vec3 p)\n{\n    float intensity = 0.1;\n    float speed = iTime / 2.;\n    float heigth = 4.;\n\n    vec3 t = (cos((p)*intensity + speed));\n    float d = (t.x * t.y * t.z) * heigth;\n\n    float intensity2 = 0.6;\n    float speed2 = iTime * 1.5;\n    float heigth2 = 0.5;\n\n    vec3 t2 = (cos((p)*intensity2 + speed2));\n    float d2 = (t2.x * t2.y * t2.z) * heigth2;\n\n    return Surface(opUnion(sdFloor(p) + mix(d, d2, 0.5), sdCutHollowSphere(p, 10., sin(iTime), 1.)), vec3(0.));\n}\n\n// Fonction pour effectuer le ray-marching\nSurface march(in Ray r)\n{\n    float t = DIST_MIN;\n\n    for (int i = 0; i < RAY_MARCH_STEPS, t <= DIST_MAX; ++i)\n    {\n        Surface s = scene(r.o + t * r.d);\n\n        if (s.t < RAY_MARCH_PRECI)\n        {\n            return Surface(t + s.t, s.c);\n        }\n\n        t = t + s.t;\n    }\n\n    return Surface(DIST_MAX, vec3(0));\n}\n\n// Computes the normal at the given point on the surface\nvec3 normalAt(in Surface s, in Ray r)\n{\n    const float e = 1.;\n\n    // Compute the point on the surface\n    vec3 p = r.o + s.t * r.d;\n\n    // Compute the x, y, and z components of the normal using finite difference\n    float nx = scene(vec3(p.x + e, p.y, p.z)).t - scene(vec3(p.x - e, p.y, p.z)).t;\n    float ny = scene(vec3(p.x, p.y + e, p.z)).t - scene(vec3(p.x, p.y - e, p.z)).t;\n    float nz = scene(vec3(p.x, p.y, p.z + e)).t - scene(vec3(p.x, p.y, p.z - e)).t;\n\n    // Normalize the resulting vector\n    return normalize(vec3(nx, ny, nz));\n}\n\n// Computes a value in 3D noise at the given point\nfloat vnoise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(mix(hash13(p + vec3(0., 0., 0.)), hash13(p + vec3(1., 0., 0.)), f.x),\n            mix(hash13(p + vec3(0., 1., 0.)), hash13(p + vec3(1., 1., 0.)), f.x), f.y),\n        mix(mix(hash13(p + vec3(0., 0., 1.)), hash13(p + vec3(1., 0., 1.)), f.x),\n            mix(hash13(p + vec3(0., 1., 1.)), hash13(p + vec3(1., 1., 1.)), f.x), f.y),\n        f.z);\n}\n\n// Computes fractional 3D noise at the given point, using multiple octaves\nfloat fnoise(in vec3 p, in float amplitude, in float frequency, in float persistence, in int nboctaves)\n{\n    float a = amplitude;\n    float f = frequency;\n    float n = 0.0;\n\n    // Compute the noise for each octave and add them up\n    for (int i = 0; i < nboctaves; ++i)\n    {\n        n = n + a * vnoise(p * f);\n        f = f * 2.;\n        a = a * persistence;\n    }\n\n    return n;\n}\n\n// Computes the color of a texture at the given point\nvec3 texColor(in vec3 p, in vec3 c)\n{\n    vec3 t = p * 2. + vec3(sin(iTime * 1.5), 0., 0.);\n\n    // create a texture color\n    float d = fnoise(t, 1., 0.8, 0.5, 3);\n    return vec3(d, 0., 0. - d);\n}\n// La fonction \"shade\" calcule la couleur d'un point sur une surface, en fonction de la lumière, des matériaux, et de la caméra\nvec3 shade(in Surface s, in Ray r)\n{\n    // Calcul de la normale de la surface à partir du point et de la direction du rayon\n    vec3 n = normalAt(s, r);\n\n    // Direction de la source de lumière (ici, une source fixe)\n    vec3 l = normalize(vec3(0., 1., -1.));\n\n    // Direction de la caméra\n    vec3 v = -r.d;\n\n    // Direction du rayon réfléchi par la surface (pour le calcul de la specularité)\n    vec3 e = reflect(-l, n);\n\n    // Couleur diffuse de la surface (dépend de la texture et de la position du point)\n    vec3 Kd = texColor(r.o + s.t * r.d, s.c);\n\n    // Couleur spéculaire de la surface\n    vec3 Ks = vec3(0.5);\n\n    // Couleur ambiante de la surface\n    vec3 Ka = vec3(0);\n\n    // Exposant de la specularité (plus il est faible, plus la surface est brillante)\n    float sh = 9.;\n\n    // Calcul de la luminosité diffuse (basée sur la normale et la direction de la source de lumière)\n    float diff = max(dot(n, l), 0.);\n\n    // Calcul de la luminosité spéculaire (basée sur la direction du rayon réfléchi et de la direction de la caméra)\n    float spec = pow(max(dot(e, v), 0.), sh);\n\n    // Calcul de la couleur finale (somme des couleurs diffuse, spéculaire et ambiante)\n    return Ka + Kd * diff + Ks * spec;\n}\n\n// La fonction \"camRay\" calcule le rayon correspondant à un pixel donné, pour une caméra fixe\nRay camRay(in vec2 p)\n{\n    // Position de la souris (inutile ici)\n    vec2 m = iMouse.xy / R.y;\n\n    // Position de la caméra\n    vec3 ro = vec3(20., 8., m * 50.);\n\n    // Point cible de la caméra\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    // Vecteur de vue de la caméra\n    vec3 cw = normalize(ta - ro);\n\n    // Vecteur \"up\" de la caméra\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n\n    // Vecteur \"right\" de la caméra\n    vec3 cu = normalize(cross(cw, cp));\n\n    // Vecteur \"up\" normalisé de la caméra\n    vec3 cv = normalize(cross(cu, cw));\n\n    // Angle de vue de la caméra (en degrés)\n    float fovDeg = 50.;\n\n    // Conversion en radians\n    float fovRad = (fovDeg / 360.) * 2. * PI;\n\n    // Distance focale (plus elle est petite, plus le champ de vision est grand)\n    float zf = 1. / tan(fovRad / 2.);\n\n    // Calcul de la direction du rayon (en incluant la perspective)\n    vec3 rd = normalize(p.x * cu + p.y * cv * (R.y / R.x) + zf * cw);\n\n    return Ray(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / R.xy) * 2. - 1.;\n\n    Ray r = camRay(uv);\n    Surface s = march(r);\n    vec3 c = vec3(0.3, 0.1, 0.1);\n\n    if (s.t < DIST_MAX)\n    {\n        c = shade(s, r);\n    }\n\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}