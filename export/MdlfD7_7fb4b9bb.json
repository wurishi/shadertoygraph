{"ver":"0.1","info":{"id":"MdlfD7","date":"1496552780","viewed":387,"name":"2D Rotation Visualisation","username":"gilesruscoe","description":"The relationship between 2D rotation and sin/cos","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","visualization","lines","sin","cos","curve","dots","rotation","visualisation","points","vectors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 6.0 / iResolution.y\n#define SIZE 0.75\n\nfloat disk(vec2 uv, vec2 center, float radius)\n{\n    float d = length(uv - center);\n    return smoothstep(d, d + 0.01, radius);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b, float width)\n{\n    vec2 pa = uv - a;\n    vec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\t\n\treturn 1.0 - smoothstep(-AA, AA, length(pa - ba * h) - width);\n}\n\nfloat cosLine(vec2 uv, float width)\n{\n    return smoothstep(AA, -AA, length(cos(iTime - uv.x) - uv.y) - width);\n}\n\nfloat sinLine(vec2 uv, float width)\n{\n    return smoothstep(AA, -AA, length(sin(iTime - uv.y) - uv.x) - width);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius)\n{\n    return smoothstep(AA, -AA, abs(length(uv - center)-radius));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //Uvs\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y / SIZE;\n    \n    //Cos and Sin waves power the rotation angle\n    float sinx = sin(iTime);\n    float cosx = cos(iTime);\n    \n    //Lines showing indivisual axis movements\n    float lineSX = line(uv, vec2(sinx, -1.0), vec2(sinx, 1.0), 0.005);\n    float lineCX = line(uv, vec2(-1.0, cosx), vec2(1.0, cosx), 0.005);\n    \n    //Points of interest\n    vec2 pRot = vec2(sinx, cosx);\n    vec2 pOrigin = vec2(0);\n    float p0 = disk(uv, pOrigin, 0.04);\n    float p1 = disk(uv, vec2(sinx, 0.0), 0.03);\n    float p2 = disk(uv, vec2(0.0, cosx), 0.03);\n    float p3 = disk(uv, pRot, 0.04);\n    \n    //Lazy single channel colours...\n    fragColor = vec4(0.1);\n\tfragColor.x += max(lineSX, p1);\n    fragColor.y += max(lineCX, p2);\n    float rotLine =  max(p3 + p0, line(uv, pOrigin, pRot, 0.01));\n    fragColor.xyz += max(rotLine, circle(uv, pOrigin, 1.0));\n    fragColor.xyz += cosLine(uv, 0.005) * 0.25;\n    fragColor.xyz += sinLine(uv, 0.005) * 0.25;\n}","name":"Image","description":"","type":"image"}]}