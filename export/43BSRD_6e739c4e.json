{"ver":"0.1","info":{"id":"43BSRD","date":"1712095031","viewed":114,"name":"Buildings thing","username":"Balas","description":"Buildings raymarch scene I did to practice raymarching. Its a bit of a mess but I dont really feel like working on it anymore.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PXL_S 1.0/iResolution.xy\n\n#define PI 3.14\n#define E 2.718\n#define GB_D 1\n\n\nfloat mip(sampler2D s, vec2 uv, float i){\n    return textureGrad(s, uv, vec2(i), vec2(i)).a;\n}\nfloat boxBlurTwoPass(sampler2D sTex, vec2 vUV, int str){    \n    float blurPxl = 0.;\n    int iC = 0;\n    for(int i=-str; i<=str; ++i, iC++){\n        blurPxl+=texture(sTex, vUV+(vec2(i, 0) * PXL_S) ).a;\n    }\n    for(int i=-str; i<=str; ++i, iC++){\n        blurPxl+=texture(sTex, vUV+(vec2(0, i) * PXL_S) ).a;\n    }\n    blurPxl=blurPxl/float(iC);\n    return blurPxl;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float bloom_sample = mip(iChannel0, uv, 0.001)+\n                         mip(iChannel0, uv, 0.002);\n   \n    bloom_sample += boxBlurTwoPass(iChannel0, uv, 15); //sure\n    \n                         \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col+bloom_sample*vec3(1., 1., 0.),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define rgb(r, g, b) vec3(r, g, b)/255.0\n#define tile(v, f) vec3(mod(v.x, f), v.y, mod(v.z, f))\n#define iTime100 vec3(iTime, 0.0, 0.0)\n#define iTime010 vec3(0.0, iTime, 0.0)\n#define iTime001 vec3(0.0, 0.0, iTime)\n#define nMouseX iMouse.x/iResolution.x*2.-1.\n#define nMouseY iMouse.y/iResolution.y*2.-1.\n\n#define DEG2RAD(x) x/360.0*3.1416*2.0\n\nstruct m_pair{\n    float dist;\n    uint id;\n};\n\nstruct RaymarchHit{\n    float depth;\n    vec3 pos;\n    uint id;\n};\n\nfloat nsin(float x){\n    return sin(x)*0.5+0.5;\n}\n\nfloat mround(float x, float s){\n    return fract(x)<=s?floor(x):ceil(x);\n}\n\nvec3 mround(vec3 x, float s){\n    return vec3(mround(x.x, s), mround(x.y, s), mround(x.z, s));\n}\n\n\n//https://www.youtube.com/watch?v=I8fmkLK1OKg&t=863s&ab_channel=BlackleMori\nvec2 edge(vec2 _p){ //accounting for diagonal neighbours\n    vec2 p2 = abs(_p);\n    if(p2.x > p2.y) return vec2((_p.x < 0.0) ? -1.0 : 1.0, 0.0);// Changed to prevent it from looking\n                    return vec2(0., (_p.y<0.0) ? /*-*/-1.0 : 1.0); //to neighbours in negative Z\n}\n\n//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n    //vec3\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n    //vec2\nfloat hash(vec2 uv)\n{\n    return fract(sin(7.289 * uv.x + 11.23 * cos(uv.y*123.1)*uv.y) * 23758.5453);\n}\n\n    //vec1\nfloat hash(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(hash(fl), hash(fl + 1.0), fc);\n}\n\nfloat rand_in_range(float _x, float _min, float _max){\n    float range = abs(_max-_min);\n    float ans = hash(_x)*range;\n    ans = ans+min(_min, _max);\n    \n    return ans;\n}\n\n//https://gist.github.com/983/e170a24ae8eba2cd174f\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//https://iquilezles.org/articles/sdfrepetition/\nvec3 repeated( vec3 p, float s )\n{\n    vec3 r = p - s*round(p/s);\n    return (r);\n}\n\nvec3 rotAxisAngle(vec3 p, vec3 axis, float a){\n    float x, y, z;\n    x=axis.x; y = axis.y; z=axis.z;\n    \n    mat3x3 rot = \n        mat3x3(x*x*(1.0-cos(a))+cos(a), x*z*(1.0-cos(a))-z*sin(a), x*z*(1.0-cos(a))+y*sin(a), \n               y*x*(1.0-cos(a))+z*sin(a), y*y*(1.0-cos(a))+cos(a), y*z*(1.0-cos(a))-x*sin(a),\n               z*x*(1.0-cos(a))-y*sin(a), z*y*(1.0-cos(a))+x*sin(a), z*z*(1.0-cos(a))+cos(a) \n               );\n    return rot*p;\n}\n\nmat4x4 rotationMatrix(vec3 _rot){ //X:Yaw Y:Pitch Z:Roll \n    float x, y, z;\n    x =_rot.z; y=_rot.x; z = _rot.y; //Might have messed up something at some point if I have to change axes\n    return mat4x4(cos(x)*cos(y), cos(x)*sin(y)*sin(z)-sin(x)*cos(z), cos(x)*sin(y)*cos(z)+sin(x)*sin(z), 0.0,\n                  sin(x)*cos(y), sin(x)*sin(y)*sin(z)+cos(x)*cos(z), sin(x)*sin(y)*cos(z)-cos(x)*sin(z), 0.0,\n                  -sin(y), cos(y)*sin(z), cos(y)*cos(z), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n}\n\nmat4x4 translationMatrix(vec3 _pos){\n    return mat4x4(1.0, 0.0, 0.0, _pos.x,\n                  0.0, 1.0, 0.0, _pos.y,\n                  0.0, 0.0, 1.0, _pos.z,\n                  0.0, 0.0, 0.0, 1.0);\n}\n\nmat4x4 worldMatrix(vec4 pos, vec3 rot, vec3 scale){\n    return mat4x4(1.0);\n}\n\n//https://carmencincotti.com/2022-05-02/homogeneous-coordinates-clip-space-ndc/\nmat4x4 clipMatrix(float _near, float _far, float _aspect, float _fov_y){\n    float tanHF = tan(_fov_y/2.0);\n    //return mat4x4(1.0/(tan(_fov_y/2.0)*_aspect), 0.0, 0.0, 0.0,\n      //            0.0, 1.0/tan(_fov_y/2.0), 0.0, 0.0,\n        //          0.0, 0.0, -((_far+_near)/(_far-_near)), -((2.0*_far*_near)/(_far-_near)),\n          //        0.0, 0.0, -1.0, 0.0);\n    mat4 ans = mat4(0.0);\n    ans[0][0] = 1.0/(_aspect*tanHF);\n    ans[1][1] = 1.0/(tanHF);\n    ans[2][2] = (_far+_near)/(_far-_near);\n    ans[2][3] = 1.0;\n    ans[3][2] = (2.0*_far*_near)/(_far-_near);\n    return ans;\n}\n\n////////////////////////\n\n//Utils\n\nfloat grid(vec3 pos, float width){\n    width = max(width, max(fwidth(pos.x), fwidth(pos.z)));    \n    float gridMask = min(step(width, fract(pos.x+width/2.0)), step(width, fract(pos.z+width/2.0)));\n    return (gridMask);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 2000\n#define MAX_DIST 100.0\n#define EPS 0.001F\n\n#define PLANE_COL vec3(1.0, 0.0, 0.0)\n#define BUILDINGS_COL vec3(1.0, 0.0, 0.0)\n\n\n\n//#define DEBUG\n\n//#define RGB_INTERPOLATION\n\n\n//SDF MIX OPERATIONS\nvec2 softBlendSDF( vec2 _d1, vec2 _d2, float _k )\n{\n    float h = clamp( 0.5 + 0.5*(_d2.x-_d1.x)/_k, 0.0, 1.0 );    \n    \n    return mix( _d2, _d1, h ) - _k*h*(1.0-h);\n}\n\nm_pair unionSDF (m_pair _d1, m_pair _d2){\n    if (_d1.dist<_d2.dist)\n        return _d1;\n    return _d2;\n}\n\n//BASIC SDF FORMULAS\nfloat sphereSDF(vec3 _pos, vec3 _center, float _r){\n    if(_r<=EPS)\n        return MAX_DIST;\n    return (length(_pos-_center)-_r);\n}\n\nfloat boxSDF(vec3 _p, vec3 _b ){\n  _b/=vec3(2.0);\n  vec3 q = abs(_p) - _b;  \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat floorSDF(vec3 pos){\n    return pos.y;\n}\n\n//COMPOSITE SDF FUNCS (return vec2 to account for possible multiple material IDs within the SDF)\nm_pair buildingsSDF(vec3 _wpos){\n    //Constants\n    const float BUILDING_SPACING = 1.3;\n    const float BUILDING_MAX_HEIGHT = 60.0;   \n    \n    //Building pivot definitions\n    vec3 pivot, neigh_pivot = vec3(0.0);\n    pivot.xz = round(_wpos.xz*(1.0/BUILDING_SPACING))*(BUILDING_SPACING);\n    float pivot_hash = hash(pivot.xz);\n    neigh_pivot.xz = pivot.xz + edge(_wpos.xz-pivot.xz)*BUILDING_SPACING;\n    \n    //Constants but they are not constant\n    float BUILDING_SIDE_SIZE = min(\n                                .85,\n                                BUILDING_SPACING/1.5); //to prevent from twisting into other domains\n    float WINDOW_SPACING = rand_in_range(pivot_hash, .5, .8);\n    vec3 WINDOW_SIZE = vec3(1., 1.5, 1.)*rand_in_range(pivot_hash, .1, .3);\n    \n    //Space deformation (needs to happen before window pivot to twist whole chunks together)\n    float rot_angle = (pivot_hash+_wpos.y*step(.2, pivot_hash)*.1+(pivot_hash)*.2);    \n    vec3 twisted_wpos = rotAxisAngle(_wpos-pivot, vec3(0.0, 1.0, 0.0), rot_angle)+pivot;    \n                 \n    //Size definitions\n    float anim_alpha = nsin(iTime*.1+pivot_hash*123.123);\n    vec3 box_size = vec3(BUILDING_SIDE_SIZE, \n                         nsin(pivot_hash)*BUILDING_MAX_HEIGHT,\n                         BUILDING_SIDE_SIZE );\n    \n    //Window pivot definitions\n    vec3 window_pivot_offset = vec3(0.15, fract(box_size.y), 0.15);\n    vec3 window_pivot = round((twisted_wpos-window_pivot_offset + vec3(0.0, WINDOW_SPACING/2.0, 0.0))\n                        /WINDOW_SPACING)*WINDOW_SPACING + window_pivot_offset;    \n    window_pivot.y = min(window_pivot.y, 27.);\n     \n    \n    //Distance funcs\n    float own_dist = boxSDF(twisted_wpos-pivot, box_size);\n    float neigh_dist = boxSDF(_wpos-neigh_pivot, vec3(BUILDING_SPACING*.9, BUILDING_MAX_HEIGHT, \n                        BUILDING_SPACING*.9));         \n    float window_dist = boxSDF(twisted_wpos-window_pivot+vec3(0.0, WINDOW_SPACING/2.0, 0.0), WINDOW_SIZE);\n    float ans_dist = max(-window_dist, min(own_dist, neigh_dist));\n    \n    //Materials\n    uint mat_id = max(window_dist+0.01, min(own_dist, neigh_dist)) > 0.01 ? 1U:2U;\n    //mat_id=1U;\n    ans_dist = min(own_dist, neigh_dist);\n    //ans_dist = neigh_dist;\n    //ans_dist = window_dist;    \n    return m_pair(ans_dist, mat_id);\n}\n\n\n//SCENE\nm_pair sceneSDF(vec3 pos){ //x is dist to scene, y is material/primitive ID\n\n    vec3 n = vec3(noise(pos), noise(pos+vec3(0.0, iTime, 0.0)), noise(pos*0.3));\n    float cell_hash = floor(pos.x*0.2 + 0.5)*.15 + floor(pos.z*0.2)*.08;\n    float cell_n = noise(cell_hash*11.1);\n    float anim = fract(iTime*.5+cell_hash);\n    \n    m_pair ans = m_pair(floorSDF(pos), 0U);//FLOOR\n    ans = unionSDF(ans, buildingsSDF(pos)); //BUILDINGS\n    //ans = unionSDF(ans, vec2(boxSDF(pos-vec3(0.0, 5.0, 10.0), vec3(1.0, 1.0, 1.0)), 1.0));\n    return ans;\n}\n\nRaymarchHit raymarch(vec3 _camPos, vec3 _rayDir){\n    RaymarchHit ans; //depth and primitiveHash\n    int steps = 0;\n    while(steps++<MAX_STEPS){\n        if(ans.depth>MAX_DIST){//background\n            ans.pos = vec3(-1.0);\n            ans.depth = MAX_DIST;\n            ans.id = 99U;\n            break;\n        }\n        \n        m_pair scene = sceneSDF(_camPos+_rayDir*ans.depth);\n        ans.depth+=scene.dist;\n        if(scene.dist<EPS){//surface\n            ans.pos = _camPos+_rayDir*ans.depth;\n            ans.id = scene.id;                       \n            break; \n        }\n    }\n    return ans;\n}\n\nvec3 ComputeNormals(vec3 _pos){\n    vec3 ans;\n    float n_sample_o = 0.01;\n\n    ans.x = sceneSDF(_pos + vec3(n_sample_o, 0.0, 0.0)).dist;\n    ans.x -= sceneSDF(_pos - vec3(n_sample_o, 0.0, 0.0)).dist;\n    ans.x /=2.0;\n    ans.y = sceneSDF(_pos + vec3(0.0, n_sample_o, 0.0)).dist;\n    ans.y -= sceneSDF(_pos - vec3(0.0, n_sample_o, 0.0)).dist;\n    ans.y /=2.0;\n    ans.z = sceneSDF(_pos + vec3(0.0, 0.0, n_sample_o)).dist;\n    ans.z -= sceneSDF(_pos - vec3(0.0, 0.0, n_sample_o)).dist;\n    ans.z /=2.0;\n    ans = normalize(ans);\n    return ans;\n}\n\nfloat Shadow(vec3 _startingPos, vec3 _rayDir, float _minDist, float _maxDist){\n    float t = _minDist;\n    for(int i=0; i<256 && t<_maxDist;){\n        float h = sceneSDF(_startingPos+_rayDir*t).dist;\n        if(h<EPS)\n            return 0.0;\n        t+=h;\n    }\n    return 1.0;\n}\n\nconst vec3 buildingsPalette[5] = vec3[](rgb(110, 84, 83),\n                                        rgb(100, 100, 82),\n                                        rgb(96, 60, 91),\n                                        rgb(254, 251, 182)*5.0,\n                                        rgb(110, 84, 83));                                       \n\nconst vec3 fogColTop = rgb(340, 193, 190);\nconst vec3 fogColBot = rgb(10, 180, 60);\n\nconst float mouseCamRange = 3.14*2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\n    vec3 dirLight = rotAxisAngle(normalize(vec3(0.0, -1.0, 0.5)), vec3(0.0, 1.0, 0.0), iTime*.2);\n\n    vec3 lookAt = vec3(0., 0., 0.);\n    vec3 camPos = vec3(iTime*.33, 28.0, -5.5);\n    //vec3 camF = normalize(lookAt-camPos);\n    vec3 camF = normalize(vec3(0.0, -.8, 1.0));\n    vec3 camU = normalize(cross(camF, vec3(1.0, 0.0, 0.0)));\n    vec3 camR = normalize(cross(camU, camF));\n\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    vec2 rayXY = uv*2.-1.;\n    float fov = 90.0;\n    float rayZ = 1.0/(fov/180.0)-1.;\n    vec3 ray = normalize(vec3(rayXY, rayZ));\n    mat4 viewMat = mat4(vec4(camR, 0.0), \n                        vec4(camU, 0.0),\n                        vec4(camF, 0.0),\n                        vec4(vec3(0.), 1.));                          \n    ray = (viewMat * vec4(ray, 0.0)).xyz;\n \n    \n    RaymarchHit scene = raymarch(camPos, ray);\n    vec3 Normals = ComputeNormals(scene.pos);\n    float fresnel = 1.0-saturate(-dot(Normals, ray));\n    \n    float Depth = scene.depth;\n    vec3 Albedo;\n    float Emissive=0.0;\n    if(scene.id ==0U){\n        Albedo = saturate(scene.pos/10.0);\n        Albedo*=grid(scene.pos+vec3(0.5), 0.1)*\n                grid(scene.pos/5.0 + vec3(0.5), 0.5/5.0);\n    }\n    else if(scene.id==1U){\n        float n = noise(scene.pos*10.);\n        Albedo = mix(buildingsPalette[0], buildingsPalette[1], n);\n        float n2 = noise(scene.pos*100.);\n        Albedo = mix(Albedo, buildingsPalette[2], n2);\n        vec3 piv = vec3(round(scene.pos.xz/1.3)*1.3, 0.0);\n        piv.yz = piv.zy;\n        float n3 = noise(piv);\n        Albedo = hsv2rgb(rgb2hsv(Albedo)+vec3(n3, 0., 0.));\n    }\n    else if(scene.id==2U){\n        Albedo = buildingsPalette[3];\n        vec3 window_pivot = round(scene.pos);\n        float window_hash = noise(window_pivot);\n        Emissive = window_hash;\n    }\n    //Albedo = scene.pos.zzz;\n    \n    float selfShadowing = saturate(-dot(Normals, dirLight));\n    float Shadows = min(\n            Shadow(scene.pos, -dirLight, 1.0, MAX_DIST), \n            selfShadowing);\n    Shadows = max(0.2, Shadows);\n    \n    vec3 r = reflect(dirLight, Normals); //=normalize(2.0 * dot(Normals, -dirLight) * Normals + dirLight);\n    float Specular =  pow(saturate(-dot(r, normalize(ray))), 20.0) * 1.0;\n    float RimLight = fresnel * .5;\n    \n    float DepthFog = smoothstep(0.0, 50.0, (Depth));\n    \n    \n    vec3 OutCol = mix((Albedo+Specular+RimLight)*Shadows, mix(fogColBot, fogColTop, uv.y), DepthFog);\n    fragColor = vec4(OutCol, Emissive);\n}","name":"Buffer A","description":"","type":"buffer"}]}