{"ver":"0.1","info":{"id":"flS3Wz","date":"1623671050","viewed":419,"name":"Hommage à Tyler Hobbs 1","username":"DrNoob","description":"Hommage à Tyler Hobbs (REPETITION I-III [2018])\nAnimated reproductions of these pieces by Tyler Hobbs:\nhttps://tylerxhobbs.com/works/2018/repetition-i\nhttps://tylerxhobbs.com/works/2018/repetition-ii\nhttps://tylerxhobbs.com/works/2018/repetition-iii","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Hommage à Tyler Hobbs (REPETITION I-III [2018])\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Animated reproductions of these pieces by Tyler Hobbs:\n// https://tylerxhobbs.com/works/2018/repetition-i\n// https://tylerxhobbs.com/works/2018/repetition-ii\n// https://tylerxhobbs.com/works/2018/repetition-iii\n\nconst vec3 BG = vec3(249, 248, 244) / 255.0;\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int NOCTAVES = 5;\n    for (int i = 0; i < NOCTAVES; ++i) {\n        v += a * vnoise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat sdCircle(vec2 p, vec2 center, float r) {\n    return length(p - center) - r;\n}\n\n// Oriented box by iq\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat time() {\n    return 0.02 * iTime;\n}\n\nfloat animWidth() {\n    return 0.1 + 0.1 * sin(3.0 * iTime);\n}\n\nfloat animSurface(vec2 p) {\n    vec2 pOff = vec2(p.x, p.y + time());\n    float dust = vfbm(70.0 * pOff);\n    float freckles = vfbm(20.0 * pOff);\n    return 0.02 * smoothstep(0.3, 0.9, dust) +\n           0.1  * smoothstep(0.75, 0.85, freckles);\n}\n\nvec3 repetition1(in vec2 uv) {\n    // Domain warping\n    vec2 st = uv - 0.5;\n    st.y = 1.0 - abs(st.x) - 0.9 * st.y;\n\n    // Colors\n    vec3 col = BG;\n    vec3 fg = vec3(240, 196, 69) / 255.0 + animSurface(vec2(uv.x, 1.0 - uv.y));\n\n    // Lines\n    const float freq = 125.0;\n    float w = 0.2 + animWidth();\n    float f = 0.5 + 0.5 * sin(freq * (st.y + time()));\n    float lns = w - f;\n    col = mix(col, fg, smoothstep(fwidth(lns), 0.0, lns));\n\n    // Solid\n    const float SP = 0.8;\n    float solid = SP - st.y;\n    col = mix(col, fg, smoothstep(fwidth(solid), 0.0, solid));\n    \n    return col;\n}\n\nvec3 repetition2(in vec2 uv) {\n    // Domain warping\n    vec2 st = uv;\n    st.y = 1.0 - st.y;\n    st.y -= 0.1 + 0.1 * sin(4.0 * pow(st.y, 0.6) * st.x + 2.0);\n\n    // Colors\n    vec3 col = BG;\n    vec3 fg = vec3(242, 111, 73) / 255.0 + animSurface(vec2(1.0 + st.x, st.y));\n\n    // Lines\n    const float freq = 125.0;\n    float w = (1.0 - st.y - 0.2) + animWidth();\n    float f = 0.5 + 0.5 * sin(freq * (st.y + time()));\n    float lns = w - f;\n    float fade = smoothstep(0.975, 1.025, sdCircle(uv, vec2(0.9, 3.85), 1.975));\n    col = mix(col, fg, fade * smoothstep(fwidth(lns), 0.0, lns));\n\n    // Solid\n    const float SP = 0.6;\n    float solid = SP - st.y;\n    col = mix(col, fg, smoothstep(fwidth(solid), 0.0, solid));\n\n    return col;\n}\n\nvec3 repetition3(in vec2 uv) {\n    // Domain warping\n    vec2 st = uv - 0.4;\n    st.y = 1.0 - abs(st.x) - 0.7 * st.y;\n    st.y -= 0.1 + 0.1 * sin(4.0 * st.x);\n\n    // Colors\n    vec3 col = BG;\n    vec3 fg = vec3(78, 200, 163) / 255.0 + animSurface(vec2(2.0 + uv.x, 1.0 - uv.y));\n    \n    // Common properties\n    const float freq = 250.0;\n    \n    // Thick lines\n    float w1 = 0.5 + animWidth();\n    float f1 = 0.5 + 0.5 * sin(freq * (st.y + time()));\n    float thick = w1 - f1;\n    float r1 = 0.25 + 0.1 * animWidth();\n    float r2 = 0.35 + 0.1 * animWidth();\n    float fade1 = smoothstep(0.15, 0.4, sdCircle(uv, vec2(-0.1, 1.3), r1)) // Top left\n                * smoothstep(0.15, 0.4, sdCircle(uv, vec2(1.0, 1.3), r2)); // Top right\n    col = mix(col, fg, fade1 * smoothstep(fwidth(thick), 0.0, thick));\n\n    // Thin lines\n    const float W2 = 1.0;\n    float f2 = 0.5 + 0.5 * sin(freq * (st.y + time() + 45.0));\n    float thin = W2 - f2;\n    float fade2 = smoothstep(0.15, 0.4, sdCircle(st, vec2(0.0), 0.4));\n    col = mix(col, fg, fade2 * smoothstep(fwidth(thin), 0.0, thin));\n\n    // Solid\n    const float SP = 0.8;\n    float solid = SP - st.y;\n    col = mix(col, fg, smoothstep(fwidth(solid), 0.0, solid));\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized screen coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Initialize with background\n    vec3 col = BG;\n\n    // Panels\n    const float pos1 = 0.333;\n    const float pos2 = 0.666;\n    if (uv.x < pos1) {\n        col = repetition1(vec2(3.0 * uv.x, uv.y));\n    } else if (uv.x < pos2) {\n        col = repetition2(vec2(3.0 * uv.x - 1.0, uv.y));\n    } else {\n        col = repetition3(vec2(3.0 * uv.x - 2.0, uv.y));\n    }\n\n    // Panel boundaries\n    const float w = 0.01;\n    float n = -0.001 + 0.002 * vfbm(100.0 * uv - iTime);\n    float f1 = sdOrientedBox(uv, vec2(pos1 + n, 0.0), vec2(pos1 + n, 1.0), w);\n    col = mix(col, BG, smoothstep(fwidth(f1), 0.0, f1));\n    float f2 = sdOrientedBox(uv, vec2(pos2 + n, 0.0), vec2(pos2 + n, 1.0), w);\n    col = mix(col, BG, smoothstep(fwidth(f2), 0.0, f2));\n\n    // Result\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}