{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*** Uses noise / fbm apparatus from Clouds by iq on shadertoy ***/\n\nfloat pi = 3.14159;\n\n\nmat3 m = mat3( 0.0,  0.8,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return 1.0 - sqrt(res);\n}\n\nfloat fbm( vec3 p )\n{\n    float f;    \n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.0130;\n    f += 0.1250*noise( p ); p = m*p*2.0370;\n\t// enable smallest component for more wiggliness\n\t// f += 0.0625*noise( p );\n\t// f /= 0.9375\n    f /= 0.875;\n    return f;\n}\n\nfloat nat(in vec2 q, in float z, in float mx) {\n   return mx * noise(vec3(q, z)) + (1.0 - mx) * fbm(vec3(q, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 mouse = vec2(1.0 - iMouse.x / iResolution.x, 1.0 - iMouse.y / iResolution.y);\n  vec3 col = vec3 (0., 0., 0.);\n  \n  float s = 1.0 / ((1.0 + mouse.y) * 45.0);\n  float fbmz = 1.0 + 0.1 * iTime;\n  vec2 p = (fragCoord.xy * s);\n\n  float as = (4.0 * (1.0 - mouse.y) + (3.0 * (1.0 - mouse.x))) + 7.5;\n  float pdir = nat(p, fbmz, mouse.x) * 2.0 * pi * as;\n  float d = as * 1.0 / length(iResolution);\n  vec2 dp = vec2(d*sin(pdir), d * cos(pdir));\n  vec2 q = p + dp;\n  vec2 q2 = p - dp;\n  float qdir = nat(q, fbmz, mouse.x) * 2.0 * pi * as;\n  pdir = nat(q2, fbmz, mouse.x) * 2.0 * pi * as;\n  vec2 c = (q2 + q) / 2.0;\n  float pql = length(q - q2);\n\n  float mdir = (pdir + qdir)/2.0;\n  float ddir = mod((qdir - pdir)/2.0, pi * 2.0);\n  float tdd = tan(ddir);\n  vec2 co = vec2(pql * sin(mdir) / tdd, pql * cos(mdir) / tdd);\n  float ro = length(q2 - c + co);\n\n  float rf = .25 + (0.2 * (1.0 - mouse.x));\n  if (ro < rf) {\n    col += normalize(vec3(cos(ro/ddir),  1.0 - sin((ro/rf) * pi/2.0), 1.0 - ro/rf/ddir));\n    col *= (1.0 - (ro/rf));\n  } \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XssGD8","date":"1368743280","viewed":1176,"name":"Wiggly (try mouse)","username":"Underspecified","description":"Attempt to make wiggly string-like texture from treating a noise field as an angle and sampling the curvature, with some dodgy trig.\n\nMouse x transitions between a wormy, fbm-based mode and noise-based spirals, mouse y does scale and wiggliness","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","spiral","spaghetticode","string"],"hasliked":0,"parentid":"","parentname":""}}