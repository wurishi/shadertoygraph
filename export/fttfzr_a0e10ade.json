{"ver":"0.1","info":{"id":"fttfzr","date":"1662565655","viewed":113,"name":"Golden Ratio Helix","username":"romeosoft","description":"Growth In Scale:  Golden ratio helix!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["helix","goldenratio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'  \n            \n          “If I can’t picture it, I can’t understand it.”\n*/\n\n#define real float\n#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define pi 3.1415926535\n// ---------------------------------------------------------\n// Coordinate System:\n// A coordinate system in two-dimensional space \n// consists of an origin plus two orientation axes \n// c++ version : https://github.com/panguojun/Coordinate-system-transformation\n// ---------------------------------------------------------\nstruct coord2\n{\n   vec2 ux,uy;   // two axial unit vectors\n   float s;      // scaling[opt]\n   vec2 o;       // origin\n};\ncoord2 create_coord(vec2 _ux, vec2 _o, real _s)\n{\n   coord2 c; c.ux = _ux;c.uy = vec2(-_ux.y, _ux.x);c.o = _o; c.s = _s;\n    return c;\n}\n// mul: define a vector in a coordinate system\nvec2 coord_mul (vec2 p, coord2 c)\n{\n\treturn c.ux * (p.x*c.s) + c.uy * (p.y*c.s) + c.o;\n}\n// rot: rotate the coord\ncoord2 coord_rot (coord2 c, real ang)\n{\n    ROT(c.ux, ang);\n    ROT(c.uy, ang);\n    return c;\n}\n// div: measure a vector in a coordinate system\nvec2 coord_div (vec2 p, coord2 c)\n{\n    vec2 v = p - c.o;\n    return vec2(dot(v,c.ux)/c.s, dot(v,c.uy)/c.s);\n}\n\n// ---------------------------------------------------------\n// HSV color system\n// ---------------------------------------------------------\nvec3 HSV2RGB(vec3 c)\n{\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, clamp(p - K.xxx,0.0,1.0), c.y);\n}\n\n// ---------------------------------------------------------\n// mainImage\n// ---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;\n    vec3 col = vec3(0.);\n    \n    float gr = (sqrt(5.) - 1.) / 2.0; // The Golden Ratio\n    vec2 bellybutton = vec2(gr,gr);   // Belly Button\n    \n    coord2 c = create_coord(vec2(1.,0.),bellybutton,gr); // Coordinate System\n    c = coord_rot(c, pi/2.);\n    \n    float val = 30.25f; // HSV color system\n    float hue = 1.0f;\n    for(int i = 0; i < 10; i ++)\n    {\n        if(uv.x > 0. && uv.x < 1.){ \n            if(uv.x > gr){\n                uv = coord_div(uv, c); //  here is the thing! Coordinate System is good to use!\n            }\n            else{\n                float d = length(uv - vec2(gr,0.));\n                if(abs(d - gr) < gr * 0.02){\n                   col.xy += 0.1f*exp(-(d - gr)/(gr * 0.02));\n                }\n                else if(d < gr){\n                   col = HSV2RGB(vec3(hue + 0.08,2.0,val));\n                   hue *= gr;\n                   val *= gr;\n                }\n            }\n        }\n        else\n            break;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}