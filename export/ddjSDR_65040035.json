{"ver":"0.1","info":{"id":"ddjSDR","date":"1670203684","viewed":97,"name":"gol2 asap","username":"almightysapling","description":"Shader to implement Game of Life in various formats (traditional, continuous, colorful, etc)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["life","sim"],"hasliked":0,"parentid":"mdSXDR","parentname":"lifekernel"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nGoL shader\n\nCan we get global statistics? I'd liike to see percentage of screen black/rgb at any frame\n*/\n\n//rows here represent internal columns, represent colors\nconst mat4 rgba2cols = mat4(0.0, 1.0, 1.0, 0.0,\n                            0.4, 0.2, 0.0, 0.0,\n                            0.0, 0.0, 1.0, 0.0,\n                            0.0, 0.0, 0.0, 0.0);\n\nvec4 hsv2rgb(float h,float s,float v)\n{\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    s=clamp(s,0.0,1.0);\n    v=clamp(v,0.0,1.0);\n    \n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n \n\treturn vec4(v * mix( vec3(1.0), rgb, s),1.0);\n}\n\n#define framebufferCheck(fb){\\\n    vec4[2] settingsBox = vec4[2]( getVal(fb), getVals(fb,2)); \\\n    if(inRect(settingsBox[0],fragCoord-0.5)){ \\\n        fragColor = mix(fragColor,bufferFetch(fragCoord-0.5+settingsBox[1].xy-settingsBox[0].xy),0.8); \\\n    } \\\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = rgba2cols * texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor.a = 1.0;\n\n    // float s = getVal(EPS1).x;\n   \n    /*\n    //math here\n    //float s=2.*0.5/3.14159;\n    //fragColor = hsv2rgb(s*atan(fragColor.y,fragColor.x),1.0,length(fragColor.xy));\n    /**/\n    framebufferCheck(SETTINGS_TAB);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Input Buffer (A)\n    Two purposes: gather inputs (duh) such as keyboard, mouse, mic, etc\n        and do as much per-object pre-processing as possible (mouse SDF)\n    \n    Condenses KeyBoard and Mouse info into a convenient and compatible format \n    with the State Buffer (B)\n    \n    NOPE:(A) will keep a local copy of the keyboard (in the usual spot)(why?)\n    \n    YEP: in they KEYBOARDPLUS row, it will expose a vec4 (which (B) will expose forward)\n    x - State (1/0)\n    y - State toggled (+1 pressed, -1 released) \n    z - Toggle status\n    w - time since toggle\n        \n    And the mouse state similarly at (mousekey,kb+)\n    With mouse distances in the INTERACT BOX\n    for each \"clickable\" object in Buffer B we compute the sdf for that object type\n    then the mouse handler doesn't need to compute them one by one (less to load, no math)\n    \n    \n    oh boy\n    \n    iMouse gives xy  - drag position\n                |zw| - click pos.\n                sgn(z) = mouse down\n                zgn(w) = mouse click (ie ogMousePress)\n                \n    W/O drag hack can only get mouse pos when clicked/down\n    Ideally we search State object list for clickable and store that info too\n    perhaps \"old\" data as well.\n*/\n\n#define ogkeyState(k)  texelFetch( iChannel2, ivec2(k,0), 0 ).x\n#define ogkeyPress(k)  texelFetch( iChannel2, ivec2(k,1), 0 ).x\n#define ogkeyToggle(k) texelFetch( iChannel2, ivec2(k,2), 0 ).x\n#define noChange texelFetch( iChannel0, ivec2(fc),0)\n\nvec4 newkeyState(int k){\n    vec4 f = texelFetch(iChannel0,ivec2(k,KEYBOARDPLUS),0);\n    return vec4(ogkeyState(k),\n                ogkeyPress(k)>0.0?1.0: ogkeyState(k)==f.x? 0.0: -1.0,\n                ogkeyToggle(k),\n                ogkeyToggle(k)==f.z? f.w+iTimeDelta:0.0 );\n}\n    \nvec4 newMouseState(){\n    vec4 f = texelFetch(iChannel0,ivec2(mouseKey,KEYBOARDPLUS),0);\n    return vec4(mouseDown? 1.0:0.0,\n                mouseClicked? 1.0: f.x*(mouseDown? 0.0:-1.0),\n                mouseClicked? 1.0-f.z:f.z,\n                f.y!=0.0? 0.0: f.w+iTimeDelta);\n}\n\nfuncSliderDist\n\nvec4 getDist(ivec2 fc){\n    if(fc.x<FRAMEBUFFERS_){\n    }else if(fc.x<SLIDERS_){\n        float d = distTo_slider(fc.x,iMouse.xy -getVal(SETTINGS_TAB).xy);\n        return vec4(d,float(fc.x),0.0,0.0);\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 fc = ivec2(fragCoord-0.5);\n    //if(fc.y<3){\n        //save keyboard rows 0-2\n    //    fragColor = texelFetch(iChannel2, fc,0);\n    //} else\n    if(fc.y==KEYBOARDPLUS){\n        //condense keyboard \n        fragColor = (fc.x==mouseKey)?newMouseState():newkeyState(fc.x);\n    } \n    else if (fc.y==MOUSE_DISTANCE){\n        fragColor = mouseClicked?getDist(fc):noChange;\n    }\n    else fragColor = vec4(0.0);\n     \n }","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*Buffer Data Stored in Rows 0-3\n    User Settings\n        Frame Buffers\n        Sliders\n        Buttons\n        ... --anything--\n        \n    System States\n        Change Tracking\n        Behind the scenes stuff        \n*/\n//Frame buffers\n#define SETTINGS_TAB 101\n#define FRAMEBUFFERS_ 200\n\n//Sliders\n    //bounds change per time step\n    //gol change rate\n#define EPS1 201\n    //color rotate change rate\n#define EPS2 202\n    //growth-shrink ratio\n#define EPS2D 203\n\n#define MIN_GROWTH 205\n#define MAX_GROWTH 206\n#define UND_CROWD 210\n#define LOOPT_CROWD 220\n#define HIOPT_CROWD 221\n#define OVR_CROWD 230\n#define SLIDERS_ 300\n\n//Radio Buttons\n#define LIFE_MODE 301\n#define GRIDTH 302\n#define RADIOS_ 400\n\n\n\n//system values 400+\n#define NOTHING 0\n\n//row num not col num\n#define KEYBOARDPLUS 5\n#define MOUSE_DISTANCE 6\n\n#define VIEW_CHANGE 504\n#define TEX_CHANGE 501\n#define MOUSE_CONTROL 502\n//#define MOUSE_CLICK 502\n//#define MOUSE_DRAGSTATE 503\n#define CURVE_DATA 505\n\n//should move curve data to separate field... \"buffer\" stuff away from \"custom\" stuff\n\n#define mouseDown (iMouse.z>0.0)\n#define mouseClicked (iMouse.w>0.0)\n#define mouseDragFrom abs(iMouse.zw)\n//#define mouseDragged (mouseDown && (iMouse.xy==abs(iMouse.zw)))\n#define keyPressed(k) (texelFetch(iChannel1,ivec2(k,KEYBOARDPLUS),0).y==1.0)\n#define keyDown(k) (texelFetch(iChannel1,ivec2(k,KEYBOARDPLUS),0).x==1.0)\n#define keyReleased(k) (texelFetch(iChannel1,ivec2(k,KEYBOARDPLUS),0).y==-1.0)\n#define mouseKey 300\n\n//these names could be better but I've painted myself into a corner \n//want to fetch \n\n#define bufferFetch(u) texelFetch(iChannel1,ivec2(u),0)\n#define bufferFetch2(u,v) texelFetch(iChannel1,ivec2(u,v),0)\n\n#define getVal(U) texelFetch(iChannel1,ivec2(U,0),0)\n#define getVals(U,n) texelFetch( iChannel1, ivec2(U,n),0)\n//#define getCoord(U) texelFetch( iChannel1, ivec2(U), 0 )\n#define getValStruct(U) \\\n    vec4[3]( texelFetch( iChannel1, ivec2(U,0), 0 ), \\\n    texelFetch( iChannel1, ivec2(U,1), 0 ), \\\n    texelFetch( iChannel1, ivec2(U,2), 0 ))\n//    texelFetch( iChannel1, ivec2(U,3), 0 ))\n    \n\nbool onRect (vec4 r, vec2 p){\n    return any(equal(p.xy,r.xy)) || any(equal(p.xy,r.zw-1.0));\n}\n\nbool inRect (vec4 r, vec2 p){\n    return vec2(1.0,1.0) == step(r.xy,p)-step(r.zw,p);// [) x [)\n}\n\n#define inTabBuffer(U,V) inRect(getVals(U,2),V)\n\n/*\nmost overloads are for 3-point format (endpoints of segment, off point)\nand a 2 vector format (abs position irrelevant)\n*/\n\n//Amount of a in b, relative to b. \n#define adjProj(a,b) dot(a,b)/dot(b,b)\n\n/*u is the line parameter (r(u) =r_0+u*v) */\nfloat nearestU_line(vec2 r, vec2 v){\n    return adjProj(r,v);\n}\nfloat nearestU_line(vec4 endpoints, vec2 point){\n    vec2 v = endpoints.zw-endpoints.xy;\n    vec2 r = point-endpoints.xy;\n    return nearestU_line(r,v);\n}\n\nfloat distTo_line(vec2 r, vec2 v){\n    return length(r-nearestU_line(r,v)*v);\n}\nfloat distTo_line(vec4 endpoints, vec2 point){\n    vec2 v = endpoints.zw-endpoints.xy;\n    vec2 r = point-endpoints.xy;\n    return distTo_line(r,v);\n    //2 dots, div,mult,minus,length\n    \n    //vs r*vP / len(v)\n    //\"perp\", dot, length, div\n}\n\nfloat nearestU_lineSegment(vec2 r, vec2 v){\n    return clamp(nearestU_line(r,v),0.0,1.0);\n}\nfloat nearestU_lineSegment(vec4 endpoints, vec2 point){\n    return clamp(nearestU_line(endpoints,point),0.0,1.0);\n}\n\nfloat distTo_lineSegment(vec4 endpoints, vec2 point){\n    vec2 v = endpoints.zw-endpoints.xy;\n    vec2 r = point-endpoints.xy;\n    return length(r-nearestU_lineSegment(r,v)*v);\n//    return length(point-rayFollow(endpoints,clamp(normProj(r,v),0.0,1.0));\n\n//vs if(r*v < 0 return len(r)\n    //if(r*v > len(v) return len(v-r)\n    //else return r*vP/len(v)\n}\n\nfloat distTo_circle(vec3 circle, vec2 point){\n    return length(point-circle.xy)-circle.z;\n}\n\n#define funcSliderDist float distTo_slider(int n,vec2 point){ \\\n    vec4[2] slider = vec4[2](getVals(n,0),getVals(n,1)); \\\n    float d = distTo_lineSegment(slider[1],point); \\\n    d=min(d,distTo_circle(vec3(slider[0].zw,10.0),point)); \\\n    return d; \\\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Buffer B is our \"proprietary\" 2D data map. \nStore objects as vec4 \"towers\" in the bottom n rows (n=3 currently)\nwhere object type is determined by x range and object is determined by x value\nAbove n we keep our various 2D shit: rendered images, pallettes, idk\n\nTO ADD: KB copy. \n\nParadigm of GPU programming: data that changes together stays together\nTry to group parameters by this and sort by volatility\n\nFrame Buffer Boxes\n    0- Screen Location (ll, ur)\n    1- On/Off + Size   (on,off, w,h) //on off is currently two binaries but could be made one float\n    2- Buffer Location (ll, ur) \n    \nSliders\n    0- point     (t, u, box.xy)             <- \n     - last      (o_t,o_u,o_boxxy)          <- unimplemented\n    1- endpoints (ll ur)                             <- \n    2- info      (tmin,tmax,lowerSlider,UpperSlider)       <- switch to just checking anyway\n\nRadio Buttons\n    inherit slider paradigm (point represents selected node as int)\n    and just lock t values to discrete points\n    2- info (tmin,tmax, numButtons, button radius)\n*/\n\n/*Double Parameterized Line Segments are key to my implementation\nThere's the natural parameter (u) which goes from 0 to 1 along\nAnd then there's the actual value that this represents for the slider's function\n\nAlright, these are disjoint so let's use u everywhere and switch to t's OTF (mix u)\n*/\n\n\n#define rayFollow(endpoints, t) mix(endpoints.xy,endpoints.zw,t)\n\nfuncSliderDist\n\n//vec4 Distance Info (x = dist, y = info (object id), zw = closest point)\n\n/*vec4 sdf(vec2 point){\n    point-=getVal(SETTINGS_TAB).xy;\n    float d = 5000.0;\n    int n = 0;\n    for(int i = SLIDERS_ -100;i<SLIDERS_;i++){\n        if(getVals(i,2).x==getVals(i,2).y)continue;\n        //skip if no slider\n        float d2 = distTo_slider(i,point);\n        n=(d<d2)?n:i;\n        d=min(d,d2);\n    }\n    return vec4(d, float(n),0.0,0.0);\n}*/\nvec4 qsdf(){\n    vec4 msf = vec4(5000.0);\n    for(int i = SLIDERS_-100;i<SLIDERS_;i++){\n        if(getVals(i,2).x==getVals(i,2).y)continue;\n        vec4 d = texelFetch(iChannel0,ivec2(i,MOUSE_DISTANCE),0);\n        if(msf.x>d.x) msf=d;\n    }\n    return msf;\n}\n\n#define addSlider(slider,default,loc,range,bounds) \\\n    if(uv.x==slider) switch(uv.y){ \\\n        case 0: return vec4(default,(default-range.x)/(range.y-range.x), \\\n            mix(loc.xy,loc.zw,(default-range.x)/(range.y-range.x))); \\\n        case 1: return loc; \\\n        case 2: return vec4(range,vec2(bounds)); \\\n    }    \n    \n//loc.xy = location, loc.zw = size    \n#define addBox(box, loc) \\\n    if(uv.x==box) switch(uv.y){ \\\n        case 0: return vec4(loc.xy,loc.xy+loc.zw); \\\n        case 1: return vec4(1.0,0.0,loc.zw); \\\n        case 2: return vec4(buffBox,buffBox+loc.zw); \\\n    } \\\n    buffBox.x+=loc.z;\n \n\nvec4 initVals(ivec2 uv){   \n    vec2 buffBox = vec2(0.0,100.0);\n    \n    addBox(SETTINGS_TAB, vec4(-384.0,iResolution.y,384.0,256.0));\n    //decorate edges here?\n\n    addSlider(EPS1,       0.04, vec4(288.0,32.0,288.0,224.0), vec2(0.0,1.0),  ivec2(0,0));\n    addSlider(EPS2,       0.02, vec4(320.0,32.0,320.0,224.0), vec2(0.0,0.5),  ivec2(0,0));\n    addSlider(EPS2D,       2.0, vec4(352.0,32.0,352.0,224.0), vec2(0.0,5.0),  ivec2(0,0));\n    \n    addSlider(MIN_GROWTH, -1.1, vec4(32.0,32.0,32.0,224.0),   vec2(-1.5,1.5), ivec2(0,MAX_GROWTH));\n    addSlider(MAX_GROWTH,  1.1, vec4(32.0,32.0,32.0,224.0),   vec2(-1.5,1.5), ivec2(MIN_GROWTH,0));\n   \n    addSlider(UND_CROWD,   0.9, vec4(32.0,32.0,256.0,32.0),   vec2(0.0,8.0),  ivec2(0,LOOPT_CROWD));\n    addSlider(LOOPT_CROWD, 2.2, vec4(32.0,224.0,256.0,224.0), vec2(0.0,8.0),  ivec2(UND_CROWD,HIOPT_CROWD));\n    addSlider(HIOPT_CROWD, 2.5, vec4(32.0,224.0,256.0,224.0), vec2(0.0,8.0),  ivec2(LOOPT_CROWD,OVR_CROWD));\n    addSlider(OVR_CROWD,  2.73, vec4(32.0,32.0,256.0,32.0),   vec2(0.0,8.0),  ivec2(HIOPT_CROWD,0));\n\n    //add radio buttons?\n    if(uv.y==0) switch(uv.x){\n        case LIFE_MODE: return vec4(0.0);\n        case GRIDTH: return vec4(5.0);\n    }\n    return vec4(0.0);\n}\n\nvec4 settingsTab(vec2 uv){\n    vec4[3] control;\n\n    if(onRect(getVals(SETTINGS_TAB,2),uv)) return vec4(0.0,1.0,0.0,1.0);\n    vec4 o = getVals(uv.x,uv.y);\n//    if(!mouseDown) return o;\n    uv -= getVals(SETTINGS_TAB,2).xy;\n\n/*\ndraw each slider requires significant branching (checking each slider one by one to see if this is the one)\nwhat's needed is a map from coord to slider num\nmultiple sliders per line segment tho makes that essentially impossible\nso... def check for changes\n*/\n    vec3 col = vec3(0.0);\n    for(int i = SLIDERS_-100;i<SLIDERS_;i++){\n//      for(int i = 201;i<202;i++){\n        control=getValStruct(i);\n        if(control[2].x==control[2].y)continue;\n        col = mix(vec3(1.0,0.0,0.0), col, \n            clamp(distTo_lineSegment(control[1],uv), 0.0,1.0) );\n        col = mix(vec3(1.0,1.0,0.0), col, smoothstep(3.0,4.0,length(uv-control[0].zw)) );\n    }\n\n    //draw \"map\" connececting sliders\n    //level 0 spline vertex map is 2ep+4midp\n    //draw grid\n    \n    //coord now in \"Settings Box\" Coordinates [0,384) x [0,256)\n                                            //[0,48)x[0,32)\n    \n    return vec4(col,1.0); \n}\n\nvec4 updateFBs(ivec2 uv){\n    //changes to FB data: move the screen location (bring settings tab in/out)\n    //set activity flags [1].xy\n    vec4[3] O = getValStruct(uv.x);\n    switch(uv.x){\n    case SETTINGS_TAB:\n        if(uv.y==0) {\n            if(getVal(MOUSE_CONTROL).x>0.0) return O[0];\n            const vec2 dx=vec2(16.0,-10.0);\n            if((iMouse.x>O[1].z)||(iMouse.y<iResolution.y-O[1].w)){\n                O[0].zw-=dx;\n            }else if((iMouse.x<O[1].z)&&(iMouse.y>iResolution.y-O[1].w)){\n                O[0].zw+=dx;\n            }\n            O[0].zw = clamp(O[0].zw, vec2(0.0,iResolution.y),vec2(0.0,iResolution.y)+ O[1].zw);\n            O[0].xy = O[0].zw -O[1].zw;\n            return O[0];\n        }\n        else if(uv.y==1){\n            O[1].x = (O[0].z==O[1].z)? 1.0 :0.0;//x 1 means fully open\n            O[1].y = (O[0].z==0.0   )? 1.0 :0.0;//y 1 means fully closed\n            return O[1];\n        }\n        return O[2];\n    }\n    return O[uv.y]; \n}\n        \nvec4 updateSliders(ivec2 uv){\n    vec2 m=iMouse.xy-getVal(SETTINGS_TAB).xy;\n    /*0- t, u, screen button\n      1- screen bar\n      2- t_range, slider bounds\n      */\n    \n    vec4[3] O = getValStruct(uv.x);\n\n    if(uv.y==0){\n        float d = (getVal(MOUSE_CONTROL).x==float(uv.x))? distTo_lineSegment(getVals(uv.x,1),m): 2000.0;\n        float u = (d<20.0)? nearestU_lineSegment(getVals(uv.x,1),m):O[0].y;\n        O[0]=vec4(mix(O[2].x,O[2].y,u),u,rayFollow(O[1],u));    \n\n//        O[0].zw = mix(O[1].xy,O[1].zw,O[0].y);\n        //Set screen position to match t-value\n        \n        //update when clicked\n        //dragged\n        //or otherwise changed\n        /*\n        designate MOUSE_COUNTROL env var and set that to the appropriate selected item, \n        then check that for updating sliders?\n        \n        */\n    \n        \n        \n            //update all the stuff\n//        float u = nearestU_lineSegment(getVals(uv.x,1),m);\n//        float d = distTo_lineSegment(getVals(uv.x,1),m);\n//        O[0]=vec4(mix(O[2].x,O[2].y,u),u,rayFollow(O[1],u));    \n        return O[0];\n    }\n    else if(uv.y==1){//Set Horizontal Sliders to Min/Max Growth\n        float mg = 0.0;\n        if((uv.x==UND_CROWD)||(uv.x==OVR_CROWD)){ \n            mg = getVal(MIN_GROWTH).w;\n            O[1].yw =vec2( mg);\n\n        } \n        else if((uv.x==LOOPT_CROWD)||(uv.x==HIOPT_CROWD)){\n            mg = getVal(MAX_GROWTH).w;\n            O[1].yw =vec2( mg);\n\n        };\n       // O[1].yw =vec2( mg);\n        return O[1];\n    }\n    return O[2]; \n}\n\nvec4 updateState(vec4 o, ivec2 uv){\n    switch(uv.x){\n    case VIEW_CHANGE: return vec4(iResolution.xy,o.xy);\n    case TEX_CHANGE: return vec4(iChannelResolution[1].xy,o.xy);//or \"reset\" is clicked\n    case MOUSE_CONTROL: \n        o.z=o.x;\n        if(!mouseDown)o.x = float(NOTHING);\n        else if (mouseClicked){\n            vec4 c = qsdf();\n            o.x= c.x>0.0 ? float(NOTHING): c.y;\n            //o.y=mouseDragged?1.0:0.0;\n            //for each control\n            //use SDF to find closest control\n            //figure out what it clicked\n            //|zw| stores _click_ location, w+ on click(1 frame) z+ on down\n            //xy stores drag location, ++\n        } else if (o.x>0.0){\n            //if out of range disable control?\n        }\n        break;\n    case CURVE_DATA: return vec4(0.0);\n    //case MOUSE_CLICK: o.xy = iMouse.xy; break;//very very poorly named\n    //case MOUSE_DRAGSTATE: o.xy = iMouse.zw; break;//also prolly unnecessary\n    }\n    return o;\n}\n\nvec4 updateVals(ivec2 uv){\n    if(uv.x<FRAMEBUFFERS_) return updateFBs(uv);\n    if(uv.x<SLIDERS_) return updateSliders(uv);\n    if(uv.x<RADIOS_) return updateSliders(uv);\n    if(uv.y==0)return updateState(getVal(uv.x),uv);\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragCoord-=0.5;\n    if(iFrame==0) fragColor = initVals(ivec2(fragCoord));\n    else if(inTabBuffer(SETTINGS_TAB,fragCoord)) fragColor = settingsTab(fragCoord);\n    //add Tabs here\n    else if(fragCoord.y<3.0) fragColor = updateVals(ivec2(fragCoord));\n    else fragColor = vec4(0.0);\n}    ","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define D(x) texelFetch(iChannel0, ivec2(x),0)\n//#define D(x,y) texelFetch(iChannel0, ivec2(x,y),0)\n\nvec4 avail(vec2 c) {\n    const vec2 i2=vec2(1.0,0.0);\n    vec4 cgrid[5];//L-DCU-R\n    cgrid[0] = D(c - i2);\n    cgrid[4] = D(c + i2);\n    for(int i=-1;i<=1;i++) cgrid[i+2] = D(c + float(i)*i2.yx);\n\n    return cgrid[2];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = avail(fragCoord);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define grid iChannel0\n/* A simple \"continuous\" GoL\nThe direct analogue would have e1 = infinity, and we see that quite rapidly \nWe get popcorn fuzz for large (>1) epsilon, starting to see interesting \"classic\" GoL above 1 \n(though too crowded to see at default sparse until 1.7ish)\nFor small epsilon (<) we get worms/evolving Labyrinths\nand in between we get a blend wall/popcorn\n\n(sparsity<=1) = space-filled walls, smaller eps = more lava lampy, but still pretty solid\n(sparsity * epsilon >> 2) = GoL\n(sparsity * epsilon << 2) = worm walls\n*/\n//coordinate shifts. Good for Loop, ugly\nconst ivec2 t3x3[9] = ivec2[9](\n                ivec2(-1,1),  ivec2(0,1),  ivec2(1,1),\n                ivec2(-1,0),  ivec2(0,0),  ivec2(1,0),\n                ivec2(-1,-1), ivec2(0,-1), ivec2(1,-1)\n                );\n/*const ivec2 t5x5[25] = ivec2[25](\n                ivec2(-2.,2.), vec2(-1.,2.), vec2(0.,2.), vec2(1.,2.), vec2(2.,2.),\n                ivec2(-2.,1.), vec2(-1.,1.), vec2(0.,1.), vec2(1.,1.), vec2(2.,1.),\n                ivec2(-2.,0.), vec2(-1.,0.), vec2(0.,0.), vec2(1.,0.), vec2(2.,0.),\n                ivec2(-2.,-1.),vec2(-1.,-1.),vec2(0.,-1.),vec2(1.,-1.),vec2(2.,-1.),\n                ivec2(-2.,-2.),vec2(-1.,-2.),vec2(0.,-2.),vec2(1.,-2.),vec2(2.,-2.)\n                );*/\n                 \n//counting kernel\nconst float k3x3[9] = float[9](\n                1.0, 01.0, 01.0,\n                1.0, 00.0, 01.0,\n                1.0, 01.0, 01.0\n                );\n\n\nconst float k5x5[25] = float[25](\n                0.0858, 0.4752, 0.672, 0.4752, 0.0858, \n                0.4752, 0.3036, 0.033, 0.3036, 0.4752, \n                0.672 , 0.033,  00.0,  0.033,  0.672, \n                0.4752, 0.3036, 0.033, 0.3036, 0.4752, \n                0.0858, 0.4752, 0.672, 0.4752, 0.0858\n                );  //assume symm and shorten?(worth?)\n\nconst float k5x5_2[25] = float[25](\n                0.25, 0.25, 0.25, 0.25, 0.25, \n                0.25, 0.5,   0.5,  0.5, 0.25, \n                0.25, 0.5,   0.0,  0.5, 0.25, \n                0.25, 0.5,   0.5,  0.5, 0.25, \n                0.25, 0.25, 0.25, 0.25, 0.25\n                );  //assume symm and shorten?(worth?)\nconst float k5x5_3[25] = float[25](\n                0.3438, 0.2438, 0.3438, 0.4438, 0.3438, \n                0.4438, 0.3125, 0.3125, 0.3125, 0.2438, \n                0.3438, 0.3125,    0.0, 0.3125, 0.3438, \n                0.2438, 0.3125, 0.3125, 0.3125, 0.4438, \n                0.3438, 0.4438, 0.3438, 0.2438, 0.3438\n              );  //assume symm and short3438?(wo3438h?)\n                \n                  \nfloat overcrowd(float v){\n    const float sparsity = 10.5;\n\n    if(v<1.0)return v;\n    return 1.0-sparsity*(v-1.0);\n}\nvec4 overcrowd(vec4 g){\n    g.x=overcrowd(g.x);//there's gotta be an auto-vectorize operation... isn't that the whole point???\n    g.y=overcrowd(g.y);\n    g.z=overcrowd(g.z);\n    return g;\n}\n\nvec4 wormLikeGoL(vec4 cell, vec4 count){\n    const float center = 2.3;\n    float clamp0 = getVal(MIN_GROWTH).x;\n\n    vec4 growth = count-center;\n    growth = overcrowd(growth);\n    if (clamp0>0.0) growth = clamp(growth, -clamp0, clamp0);\n    return cell+getVal(EPS1).x*growth;\n}\n\n\nfloat worm2(float n){\n\n    vec4 switches = vec4(getVal(UND_CROWD).x,getVal(LOOPT_CROWD).x,\n                        getVal(HIOPT_CROWD).x,getVal(OVR_CROWD).x);\n    vec4 vals = vec4(getVal(MIN_GROWTH).x,getVal(MAX_GROWTH).x,0.0,0.0);\n//    vals.zw = vals.yx;\n    vals.zw = (vals.yx-vals.xy)/(switches.yw-switches.xz);\n    //y1=y4, y2=y3, slopeUp, slopeDown\n    /*\n    (x1,y1) --- (x2,y2)\n          (x)->(y)\n          y=(m)(x-x1)+y1\n    \n    */\n    return clamp( (n<switches.y)? vals.z*(n-switches.x)+vals.x:vals.w*(n-switches.z)+vals.y, vals.x,vals.y);\n}\n\nvec4 worm2(vec4 cell, vec4 count){\n    vec4 growth;\n    growth.x=worm2(count.x);\n    growth.y=worm2(count.y);\n    growth.z=worm2(count.z);\n    vec4 clamp0 = getVal(MIN_GROWTH);\n    clamp0.y = getVal(MAX_GROWTH).x;\n    if(clamp0.x<0.0) growth = clamp(growth,clamp0.x,clamp0.y);\n    return cell+getVal(EPS1).x*growth;\n}\n\n/*vec4 rgbMono(vec4 cell,vec4 count){\n    float clamp0 = getVals(CLAMP0).x;\n\n    cell.g += eps1*clamp(worm2(count.g),-clamp0,clamp0);\n    //only one color grows on its own accord\n    //then, whenever 2 colors are present, they combine to become the third\n    vec3 pwm = max(count.yzx,count.zxy);\n    //so out.x += e (+ max(in.y,in.z)) - (max(in.x,inz)) - (max(in.x,iny)) ;\n    //   out.y += e (- max(in.y,in.z)) + (max(in.x,inz)) - (max(in.x,iny))  \n    //   out.z += e (- max(in.y,in.z)) - (max(in.x,inz)) + (max(in.x,iny)) \n    vec3 growth = pwm.xyz - pwm.yzx - pwm.zxy;\n    \n    return cell + eps2*vec4(growth,0.0);\n    \n}*/\n\nvec4 rgbRotor(vec4 cell,vec4 count){\n    float eps2 = getVal(EPS2).x;\n    float eps2d = getVal(EPS2D).x;\n    //first have colors self-interact according to GoL rules\n    cell = worm2(cell,count);\n    vec4 growth = vec4(0.0);\n    //then apply pokemon color rules\n    //+1 for 1-7 neighbors, +0 for 0 or 8 neighbors, linear between\n    growth.rgb = clamp(3.0-abs(count.gbr-4.0),0.0,1.0)-eps2d*clamp(3.0-abs(count.brg-4.0),0.0,1.0);\n    //it's not at all clear to me what's stopping colors from just changing on their own... green -> red\n    //\n    \n    return cell+eps2*growth;\n}\n\n/*vec4 rgbOther(vec4 cell,vec4 count){\n    vec4 growth = vec4(0.0);\n    \n    //color X will increase if X and X_booster are nearby in equal ammounts\n    growth.rgb = max(count.rgb,count.gbr);\n\n//else color X will stagnate if (X neabry > X depleter nearby)\n//else color X will deplete\n    vec4 deplete = vec4(0.0);\n    deplete.rgb = clamp(count.brg-count.rgb,0.0,8.0);\n    \n    return cell + eps2*(growth-2.5*deplete);\n}*/\n\nvec4 classicGoL(vec4 cell, vec4 count){\n    //make rule customizable?\n    float x=count.x;\n    float g=0.0;\n    if(x<1.95)g=-1.0;\n    else if(x<2.1)g=0.0;\n    else if(x<3.1)g=1.0;\n    else g=-1.0;\n    return vec4(cell.x+g);\n}\n\nvec4 ker3x3(ivec2 coord){\n    vec4 ker = vec4(0.0);\n    for(int i = 0; i < 9; i++){\n  \t\tker += texelFetch(grid, (coord + t3x3[i]),0) * k3x3[i];//builtin?\n\t}\n    return ker;\n}\nvec4 ker5x5(ivec2 coord){\n    vec4 ker = vec4(0.0);\n    for(int i = 0; i<5;i++){\n        for(int j = 0;j<5;j++){\n       \t\tker += texelFetch(grid, coord + ivec2(i-2,j-2),0) * k5x5[i];\n        }\n    }\n    for(int i = 0; i < 25; i++){\n//  \t\tker += texelFetch(grid, (coord + t5x5[i]),0) * k5x5[i];\n        //can this be made more generic easily?\n\t}\n    return ker;\n}\n\nvec4 schrod(ivec2 coord){\n    //d/dt = 1/(2ihm)p^2 + V\n     //    = ih/2m * d^2/dx^2 + V\n\n\n    float eps2 = getVal(EPS2).x;\n    vec2 phi = texelFetch(grid, coord,0).xy;\n\n     \n    //compute V(x)\n    //copmute laplacian\n    //\n    \n    vec2 lap=vec2(0.0);\n    ivec2 i2=ivec2(1,0);\n    lap += texelFetch(grid, coord+i2,0).xy\n         + texelFetch(grid, coord-i2,0).xy\n         + texelFetch(grid, coord+i2.yx,0).xy\n         + texelFetch(grid, coord-i2.yx,0).xy;\n    lap -= 4.0*phi;\n    lap *= 0.5;\n    \n    //*i\n    phi += eps2*lap.yx * vec2(-1.0,1.0);\n    return vec4(phi,0.0,0.0);\n}\n\nvec4 lazyNorm(vec4 c){\n    c.a = 1.0 - (c.r+c.g+c.b);\n    c.rgb += c.a * 0.333333;\n    return c;\n}\n\n#define physMin(speed,outV, inV, inQ) \\\n   t = min(min(speed,outV),min(1.0-inV,inQ)); \\\n   outV -= t; inV += t;\n\nfloat avail(float outV, float inV, float inQ, float speed){\n   return min(min(speed,outV),min(1.0-inV,inQ));\n}\n\nvec4 smallPhys(ivec2 coord){\n/*RGBA = air, earth, water, (?) \n\n    */\n    const mat3 downTrans=mat3(0.0, 0.0, 0.0, \n                              0.15, 0.0, 0.0,\n                              0.2, 0.1, 0.0);\n    const mat3 rightTrans=mat3(0.0, 0.0, 0.08, \n                              0.0, 0.0, 0.0,\n                              0.08, 0.0, 0.0);\n\n    const ivec2 i2=ivec2(1,0);\n    //probs better suited by transition matrix\n    // Type1 Dir Type2 -> Rate\n    // float 4 x 3 x 4\n    // maybe less because in theory A -> B eq B <- A\n    //so UpDown Map Type1 x Type 2 and LR map Type1 Type2\n    //\n    const float airWaterSpeed = 0.1;\n    const float airEarthSpeed = 0.1;\n    const float waterEarthSpeed = 0.1;\n\n    const float airWaterMinDrift = 0.99500;\n\n    const float airShare = 0.33333;\n    const float waterShare= 0.5;\n    const float earthShare = 1.0;\n\n    vec4 cgrid[5];\n    cgrid[0] = texelFetch(grid, coord - i2, 0);\n    cgrid[4] = texelFetch(grid, coord + i2, 0);\n    for(int i=-1;i<=1;i++) cgrid[i+2] = texelFetch(grid, coord + i*i2.yx, 0);\n    \n/*    vec4 ctable[25];//from this table you have the UDLR and the UDLR for each neighbor.\n        //might be better to use another buffer to create the pressure table first\n    for(int i=-2;i<=2;i++)for(int j=-2;j<=2; j++)\n         ctable[(i+2)*5+j+2]=texelFetch(grid, coord +i*i2 +j*i2.yx, 0);\n\n    /* 04 -              - 24\n            08 - 13 - 18 \n            07 -(12)- 17\n            06 - 11 - 16\n       00 - 05 - 10 - 15 - 20\n    */\n    vec4 c = cgrid[2];\n    vec4 cr = cgrid[4];\n    vec4 cl = cgrid[0];\n    vec4 cu = cgrid[3];\n    vec4 cd = cgrid[1];\n    \n    \n    //new approach\n    // for each type: look around and determine how much it's getting, and how much it's giving\n    // air: \n        //give upwards = amount of air missing in upper cell\n        //give/take outwards = fraction of difference\n        //take downwards = amount of air missing in lower cell\n    \n    //old approach\n    float t;\n    const vec2 swap=vec2(1.0,-1.0);\n\n    //Earth v Air\n    c.rg += avail(c.g, c.r, cd.r , airEarthSpeed) * swap;\n    c.rg -= avail(c.r , c.g, cu.g , airEarthSpeed) * swap;\n/*    t = avail(c.g * earthShare, c.r, cd.r * airShare, airEarthSpeed);\n    c.g -= t; c.r += t;\n    t = avail(c.r * airShare, c.g, cu.g * earthShare, airEarthSpeed);\n    c.r -= t; c.g += t;\n/**/\n    //Water v air\n    c.rb += avail(c.b*waterShare,c.r,cd.r,airWaterSpeed) * swap;\n    c.rb -= avail(c.r,c.b,cu.b*waterShare,airWaterSpeed) * swap;\n    \n    //Water < Air\n//    t= clamp(c.b-cl.b-airWaterMinDrift,0.0,cl.r);\n    //physMin(airWaterSpeed*0.25, c.b, c.r, min(cl.r,max(0.0,c.b-cl.b-airWaterMinDrift)));\n    //physMin(airWaterSpeed*0.25, c.r, c.b, min(cr.b,max(0.0,cr.b-c.b-airWaterMinDrift)));\n    //Water > Air\n    //physMin(airWaterSpeed*0.25, c.b, c.r, min(cr.r,max(0.0,c.b-cr.b-airWaterMinDrift)));\n    //physMin(airWaterSpeed*0.25, c.r, c.b, min(cl.b,max(0.0,cl.b-c.b-airWaterMinDrift)));\n\n    //Earth v Water\n    c.bg += avail(c.g,c.b,cd.b*waterShare,waterEarthSpeed) * swap;\n    c.bg -= avail(c.b*waterShare,c.g,cu.g,waterEarthSpeed) * swap;\n    //physMin(waterEarthSpeed,c.g,c.b,cd.b);\n    //physMin(waterEarthSpeed,c.b,c.g,cu.g);\n        \n   //drift inducing errors\n       //cu=Earth over c=Water over cd=Air. \n           //c will realize it doesn't have enough water for both\n           //cd takes water first, cu takes water that doesn't exist\n               //shitty solution: whenever competition exist, cut available reserves in 4.\n               //\n               \n    /*\n            ( )\n      ( )  (AWE)   ( )\n            ( )\n            \n    */\n \n  \n    //c = lazyNorm(c); \n    return  c;\n}\n\nvec4 timeStep(ivec2 coord) {\n    const int renderMode=3;\n    const int opMode = 0;\n    const bool monochrome = false;\n    \n    if((coord.x==0)||(coord.y==0)||(coord.x==1279)||(coord.y==719))return vec4(0.0);\n    \n    switch(opMode){\n    case 0: return smallPhys(coord);\n    case 1: return schrod(coord);\n    }\n    //case 3\n    vec4 cell = texelFetch(grid, coord,0);\n    \n    \n    //first count the nearby cells. This is done color independent.\n    //3x3 is a true neighbor count. 5x5 \"mimics\" the 3x3 (sums to 8)\n    vec4 ker = ker5x5(coord);\n    //now that we have a count, do something with this information\n   \n    vec4 o;\n\n    switch(renderMode){\n    case 0: o = rgbRotor(cell,ker); break;\n    //case 1: o = rgbMono(cell,ker); break;\n    case 2: o = worm2(cell,ker); break;\n    case 3: o = wormLikeGoL(cell,ker); break;\n    case 4: o = classicGoL(cell,ker); break;\n    }\n    o=clamp(o,0.0,1.0);\n\n    return monochrome?vec4(o.x):o;\n}\n\n//Color to BW\nfloat bw(sampler2D tex, vec2 uv) {\n\treturn dot(texture(tex, uv).xyz, vec3(1.0/3.0));\n}\n\n/*Initialize the buffer*/\nvec4 initBuff(vec2 coord){\n    vec4 c = texture(iChannel2,coord/iResolution.xy);\n    //col -> Comp?\n    return lazyNorm(c);\n    return vec4(bw(iChannel2,coord/iResolution.xy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if((iResolution.xy != getVal(VIEW_CHANGE).xy)||(getVal(TEX_CHANGE).xy != getVal(TEX_CHANGE).zw)){\n        fragColor = initBuff(fragCoord);\n        return;\n    }\n    fragColor = timeStep(ivec2(fragCoord-0.5));\n}\n","name":"Buffer D","description":"","type":"buffer"}]}