{"ver":"0.1","info":{"id":"mtXBz2","date":"1693365172","viewed":34,"name":"Sketch #9: Perlin Islands","username":"MOONtyzoo","description":"My practice with creating perlin noise. The \"island\" appearance is a little shoddy but I think it's good enough for a first try. \n\nPan mouse.x to change land density and mouse.y for cam zooming.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nfloat random(float x)\n{\n    return fract(439029.0*sin(x));\n}\n\nfloat random(vec2 uv)\n{\n    return fract(439029.0*sin(dot(uv, vec2(85.3876, 9.38532))));\n}\n\nvec2 randomGradientVec(vec2 uv)\n{\n    float angle = 2.0*PI*random(uv);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat smoothmix(float a, float b, float x)\n{\n    return (1.0-smoothstep(0.0, 1.0, x))*a + smoothstep(0.0, 1.0, x)*b;\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -= 0.5*iResolution.xy)/iResolution.y;\n    \n    /*\n        Control variables\n    */\n    float sampleNum = 5.0 + 10.0*iMouse.y/iResolution.y;\n    float islandDensity = 0.5*iMouse.x/iResolution.x;\n    vec3[5] terrainColors = vec3[](vec3(0.078,0.569,0.941), vec3(0.855,0.800,0.604), \n    vec3(0.282,0.753,0.188), vec3(0.565,0.486,0.392), vec3(0.957,0.980,0.984));\n    float[5] terrainHeights = float[](0.65, 0.70, 0.80, 0.99, 1.0);\n    \n    /*\n        Creates gradients at sample points\n        \n        Quadrants 1, 2, 3, 4 correspond to letters d, c, a, b\n    */\n    vec2 uv_i = floor(uv*sampleNum);\n    vec2 uv_f = fract(uv*sampleNum);\n    float time_i = floor(iTime);\n    float time_f = fract(iTime);\n    \n    vec2 gradA = randomGradientVec(uv_i);\n    vec2 gradB = randomGradientVec(uv_i + vec2(1.0, 0.0));\n    vec2 gradC = randomGradientVec(uv_i + vec2(0.0, 1.0));\n    vec2 gradD = randomGradientVec(uv_i + vec2(1.0, 1.0));\n    \n    /*\n        Dot product and interpolation to get noise value at each pixel\n    */\n    float valA = dot(uv_f, gradA);\n    float valB = dot(uv_f - vec2(1.0, 0.0), gradB);\n    float valC = dot(uv_f - vec2(0.0, 1.0), gradC);\n    float valD = dot(uv_f - vec2(1.0, 1.0), gradD);\n    float valAB = smoothmix(valA, valB, uv_f.x);\n    float valBC = smoothmix(valC, valD, uv_f.x);\n    float val = 0.8*smoothmix(valAB, valBC, uv_f.y) + 0.5;\n    \n    /*\n        Color screen based on \"height\" value from the perlin noise\n    */\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < terrainHeights.length(); i++)\n    {\n        color = terrainColors[i];\n        if (val <= float(terrainHeights[i]) - islandDensity) {break;}\n    }\n    \n    \n    fragColor = vec4(vec3(color), 1.0);\n}","name":"Image","description":"","type":"image"}]}