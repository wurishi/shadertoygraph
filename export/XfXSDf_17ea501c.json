{"ver":"0.1","info":{"id":"XfXSDf","date":"1705778875","viewed":71,"name":"Falling Sands at Night","username":"Altoids","description":"A (mostly) working implemention of a super simple falling sands mock-up. Using *SHADERS*!\n\nIt's obviously a little cursed to be making something like this, but I think it worked out okay in the end. The bugs are simply an exercise for the reader :^)","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["noise","interactive","weird","fallingsand","cursedfloatmath","whydoesthesandreplicateidek"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 mainColor = texture(iChannel0, uv).rgba;\n    float noise = texture(iChannel1,uv + mainColor.a).r;\n    \n    // Add some parallax up in this bitch\n    vec3 col = vec3(0.0);\n    col += texture(iChannel0, vec2(uv.x,uv.y - 0.25)).rgb * 0.125;\n    col = max(col,texture(iChannel0, vec2(1.0 - uv.x,uv.y - 0.15)).rgb * 0.25);\n    col += (1.0 - step(0.05,col.r)) *\n           pow(texture(iChannel1,uv*5.0).r,5.0);\n    \n    \n    fragColor = vec4(max(col,mainColor.rgb - noise*0.2 * mainColor.a ),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This is the fragment shader responsible for the game's logic.\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    // Initial gamestate setup\n    if(iFrame == 0) {\n        vec2 ratio = fragCoord/iResolution.xy;\n        if(ratio.y + ratio.x/2.0 < 0.9 && ratio.y > 0.5) {\n            fragColor = vec4(SAND_COLOR,FALLIFY(SAND));\n        } else if(ratio.y < 0.1) {\n            fragColor = vec4(WALL_COLOR,WALL);\n        } else {\n            fragColor = vec4(NOTHING);\n        }\n        return; // Early return is mostly okay, since this branch is uniform-dependent\n    }\n    \n    // Pull in this fragment's previous state\n    vec4 prev = texelFetch( iChannel0, iFragCoord, 0 );\n    fragColor = prev;\n    \n    vec4 above = texelFetch( iChannel0, ivec2(iFragCoord.x, iFragCoord.y + 1), 0 );\n    vec4 below = texelFetch( iChannel0, ivec2(iFragCoord.x, iFragCoord.y - 1), 0 );\n    vec4 left = texelFetch( iChannel0, ivec2(iFragCoord.x - 1, iFragCoord.y), 0 );\n    vec4 right = texelFetch( iChannel0, ivec2(iFragCoord.x + 1, iFragCoord.y), 0 );\n    \n    ivec2 rand = ivec2((iFragCoord.y + iFrame) % 12, (iFragCoord.x + iFrame) % 14);\n    int tileType = floatBitsToInt(fragColor.a) & ~IS_FALLINGint;\n    int isFalling = floatBitsToInt(fragColor.a) & IS_FALLINGint;\n    switch(tileType) {\n        case WALLint: // Walls don't move\n            break;\n        case NOTHINGint: // Has to handle anything moving into this tile\n            if(MAYBE_FALLING(above.a,SAND)) {\n                fragColor = vec4(SAND_COLOR,FALLIFY(SAND));\n            } else if(MAYBE_FALLING(above.a,WATER)) {\n                fragColor = vec4(WATER_COLOR,FALLIFY(WATER));\n              // Only sand or water that has landed can dither left or right\n            } else if(rand.x < 2 && left.a == SAND || right.a == SAND) {\n                fragColor = vec4(SAND_COLOR,FALLIFY(SAND));\n            } else if(rand.x > 7 && left.a == WATER || right.a == WATER) {\n                fragColor = vec4(WATER_COLOR,FALLIFY(WATER));\n            }\n            break;\n        case SANDint:\n            if(below.a == NOTHING) {\n                fragColor = vec4(NOTHING);\n            } else if(below.a == WATER) {\n                fragColor = vec4(WATER_COLOR,FALLIFY(WATER));\n            } else if(isFalling != 0 && rand.x < 2 && left.a * right.a == NOTHING) {\n                fragColor = vec4(NOTHING);\n            } else {\n                fragColor = vec4(SAND_COLOR,SAND);\n            }\n            break;\n        case WATERint:\n            if(above.a == SAND) {\n                fragColor = vec4(SAND_COLOR,SAND);\n            } else if(below.a == NOTHING) {\n                fragColor = vec4(NOTHING);\n            } else if(isFalling != 0 && rand.x > 7 && left.a * right.a == NOTHING) {\n                fragColor = vec4(NOTHING);\n            } else {\n                fragColor.a = WATER;\n            }\n            break;\n    }\n    \n    // Override everything we just did, if the user is drawing something on this pixel\n    if(iMouse.z > 0. && distance(iMouse.xy,fragCoord) < 4.0){\n        if(buttPressed(KEY_X))\n            fragColor = vec4(NOTHING);\n        else if(buttPressed(KEY_W))\n            fragColor = vec4(WATER_COLOR,FALLIFY(WATER));\n        else\n            fragColor = vec4(SAND_COLOR,FALLIFY(SAND));\n    }    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Visualization settings\nconst float ZOOM = 0.5;\n\n// Tile types (as floats since that's how they'll be stored anyways)\nconst float NOTHING = 0.0;\nconst float WALL = 0.125;\nconst float SAND = 0.25;\nconst float WATER = 0.375;\nconst float IS_FALLING = -0.0; // Using negative zero as a flag, lmao\n\n// Their dorky int versions (for doing switches and bit manipulation)\nconst int NOTHINGint = floatBitsToInt(NOTHING);\nconst int WALLint = floatBitsToInt(WALL);\nconst int SANDint = floatBitsToInt(SAND);\nconst int WATERint = floatBitsToInt(WATER);\nconst int IS_FALLINGint = floatBitsToInt(IS_FALLING);\n\n#define MAYBE_FALLING(x,y) (x == y || x == intBitsToFloat(floatBitsToInt(y) | IS_FALLINGint))\n#define FALLIFY(x) intBitsToFloat(floatBitsToInt(x) | IS_FALLINGint)\n\n//Their colours\nconst vec3 SAND_COLOR = vec3(0.82,0.7,0.2);\nconst vec3 WALL_COLOR = vec3(0.5,0.4,0.5);\nconst vec3 WATER_COLOR = vec3(0.2,0.4,0.7);\n\n// Keyboard stuff\n#define buttPressed(key) (texelFetch(iChannel1, ivec2(key, 0), 0).r != 0.0)\nconst int KEY_X = 88;\nconst int KEY_W = 87;\n","name":"Common","description":"","type":"common"}]}