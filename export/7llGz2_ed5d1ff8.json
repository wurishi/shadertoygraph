{"ver":"0.1","info":{"id":"7llGz2","date":"1622472115","viewed":464,"name":"Sea Adventure","username":"IamWiki","description":"I applied my own skills, combined with a sea shader I found, to make a sail through a sea with some fire elements around it. The shader is essentially lots of different elements combined into one (water, lights, moon, stars, cubes?, fire).","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["reflection","waves","sea","fire","water","ocean","fog","stars","moon","lights","liquid","seascape","sail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Credits to TDM https://www.shadertoy.com/view/Ms2SD1\n\nfloat smin(float a, float b, float h)\n{\n    float k = clamp((a-b)/ h * .5 + .5, 0., 1.);\n    return mix(a,b,k) - k * (1.-k) * h;\n}\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sph(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y,p.z));\n}\n\nfloat repeat(float p, float s)\n{\n    return (fract(p/s-.5)-.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s)\n{\n    return (fract(p/s-.5)-.5)*s;\n}\n\nvec3 repeat(vec3 p, vec3 s)\n{\n    return (fract(p/s-.5)-.5)*s;\n}\n\nvec3 kifs(vec3 p, float t)\n{\n    p.xz = repeat(p.xz, vec2(10.));\n    p.xz = abs(p.xz);\n\n    vec2 s = vec2(10,7) * 0.7;\n    for(float i = 0.; i < 5. ; ++i)\n    {\n        p.xz *= rot(t);\n        p.xz = abs(p.xz) - s;\n        p.y -= 0.1*abs(p.z);\n        s *= vec2(0.68, 0.55);\n    }\n\n    return p;\n}\n\nvec3 kifs3d(vec3 p, float t)\n{\n    p.xz = repeat(p.xz, vec2(32.));\n    p = abs(p);\n\n    vec2 s = vec2(10,7) * 0.6;\n    for(float i = 0.; i < 5. ; ++i)\n    {\n        p.yz *= rot(t * .7);\n        p.xz *= rot(t);\n        p.xz = abs(p.xz) - s;\n        p.y -= 0.1*abs(p.z);\n        s *= vec2(0.68, 0.55);\n    }\n\n    return p;\n}\n\nvec3 tunnel(vec3 p)\n{\n    vec3 off = vec3(0);\n    float dd = p.z * 0.02;\n    dd = floor(dd) + smoothstep(0., 1., smoothstep(0., 1., fract(dd)));\n    dd *= 1.7;\n    off.x += sin(dd) * 10.;\n    //off.y += sin(dd * 0.7) * 10.;\n\n    return off;\n}\n\nfloat fire = 0.;\nfloat solid(vec3 p)\n{\n    float t = iTime * .2;\n    vec3 pp = p;\n    vec3 p5 = p;\n    pp += tunnel(p);\n\n    float path = abs(pp.x) - 1.;\n\n    vec3 p2 = kifs(p, 0.5);\n    vec3 p3 = kifs(p + vec3(1,0,0), 1.9);\n\n    float d5 = -1.;\n    p5.xy *= rot(2.8);\n    p5.xz *= rot(0.5);\n\n\n    float trk = 1.;\n    float z = 1.;\n    int iterations = 10;\n    for(int i = 0; i < iterations; ++i)\n    {\n        p5 += sin(p5.zxy*0.75*trk + t*trk*.8);\n        d5 -= abs(dot(cos(p5), sin(p5.yzx)) * z);\n        trk *= 1.6;\n        z *= 0.4;\n        \n        p5.y += t * 3.;\n    }\n    \n    float d;\n\n    float b1 = box(p2, vec3(1,1,0.5));\n    float b2 = box(p3, vec3(0.5,1.3,1));\n\n    float m1 = max(abs(b1), abs(b2)) - 0.2;\n    d = m1;\n    d = max(d, -path);\n    d5 = abs(d5);\n    d += + sin(iTime * 0.1)*.3+.5;\n    if(p5.y - t * 3. * float(iterations) > -10.)\n    {\n        d = smin(d, d5, 3.);\n    }\n\n    fire += 0.2 / (0.1 + abs(d));\n\n    return d;\n}\n\nvec3 lpos = vec3(0,200,200);\nfloat moonlight = 0.;\nfloat ghost(vec3 p)\n{\n    vec3 p2 = kifs3d(p - vec3(0,2,3), 0.8 + iTime * 0.1);\n    vec3 p3 = kifs3d(p - vec3(3,0,0), 1.2 + iTime * 0.07);\n\n    float b1 = box(p2, vec3(5));\n    float b2 = box(p3, vec3(3));\n\n    float m1 = max(abs(b1), abs(b2)) - .2;\n\n    float d = abs(m1) - 0.02;\n    return d;\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,137,235);\n  vec4 val=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 v = mix(fract(sin(val)*5672.655), fract(sin(val+st.x)*5672.655), p.x);\n  vec2 v2 = mix(v.xz,v.yw, p.y);\n  return mix(v2.x,v2.y,p.z);\n}\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);\n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat water(vec3 p)\n{\n    float freq = 0.16;//SEA_FREQ;\n    float amp = 0.6;//SEA_HEIGHT;\n    float choppy = 4.;//SEA_CHOPPY;\n    float sea_time = 1. + iTime * 0.8;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n    float d, h = 0.0;    \n    for(int i = 0; i < 5/*ITER_GEOMETRY*/; i++) {        \n    \td = sea_octave((uv+sea_time)*freq,choppy);\n    \td += sea_octave((uv-sea_time)*freq,choppy);\n        h += d * amp;\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h + 1.;\n}\n\nbool isGhost = true;\nbool isWater = true;\nfloat at = 0.;\nfloat at1 = 0.;\nfloat map(vec3 p)\n{\n    float sol = solid(p);\n    float wat = water(p);\n    float gho = ghost(p);\n    float d = smin(sol, wat, 0.1);\n    isWater = wat < sol;\n    isGhost = gho < d;\n    at += 0.1/(0.1+abs(gho));\n    at1 += 0.01/(0.1+abs(gho));\n    at -= at1;\n    at = (at + abs(at))/2.;\n\n    // moon\n    float d1 = length(p - lpos) - 30.;\n    moonlight += 0.5/(0.5+(d1 + abs(d1)));\n    d = min(d,d1);\n\n    d *= 0.7;\n    return d;\n}\n\nvec3 stars(vec2 uv)\n{\n    float iterations = 17.;\n    float formuparam = 0.53;\n\n    float volsteps = 20.;\n    float stepsize = 0.1;\n\n    float zoom = 0.200;\n    float tile = 0.850;\n    //float speed = 0.010;\n\n    float brightness = 0.0015;\n    float darkmatter = 0.300;\n    float distfading = 0.730;\n    float saturation = 0.850;\n\n    uv *= rot(iTime * 0.001);\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=1.;\n\n\t//volumetric rendering\n\tfloat s=0.1,fade=0.2;\n\tvec3 v=vec3(0.);\n\tfor (float r=0.; r<volsteps; r++) {\n\t\tvec3 p=s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (float i=0.; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6.) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\treturn vec3(v*.01);\t\n\t\n}\n\nvec3 lin2srgb( vec3 cl )\n{\n\t//cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs / 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) / 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\n\nvec3 getPixel(vec2 coord)\n{\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;   \n\n    float adv = (sin(iTime * 0.01)+1.) * 100.;\n\n    vec3 s = vec3(0,.6,0);\n    vec3 t = vec3(0,.6,1);\n\n    s.z += adv;\n    t.z += adv;\n\n    s -= tunnel(s);\n    t -= tunnel(t);\n\n    //vec3 r = normalize(vec3(uv, 1.));\n    vec3 cz = normalize(t - s);\n    vec3 cx = normalize(cross(vec3(0,1,0), cz));\n    vec3 cy = normalize(cross(cz,cx));\n\n    float fov = 1.;\n    vec3 r = normalize(uv.x * cx + uv.y * cy + cz * fov);\n\n    vec3 sky = vec3(0);\n\n    vec3 p = s;\n    vec2 off = vec2(0.01, 0.);\n    vec3 n;\n    float dd = 0.;\n    float i = 0.;\n    for(i = 0.; i < 100.; ++i)\n    {\n        float d = map(p);\n        dd += d;\n        if(dd > 1000.) \n        {\n            sky = stars(vec2(r.x,r.y));\n\n            break;\n        }\n        if(d < 0.001)\n        {\n            if(!isGhost)\n            {\n                if(!isWater) break;\n\n                n = normalize(map(p) - vec3(map(p - off.xyy), map(p - off.yxy), map(p - off.yyx)));\n\n                r = reflect(r, n);\n            }\n\n            d = 0.01;\n        }\n        \n        p += r*d;\n    }\n    \n    vec3 l = normalize(p - lpos);\n\n    float falloff = 3.;\n\n    vec3 col = vec3(0);\n    \n    //col += pow(1.-i/101., 8.);\n    col = vec3((dot(l, -n)*.5+.5) * (1. / (0.01 + dd * falloff)));\n    col += pow(at * .2, 0.5) * vec3(1,0,0);\n    col += pow(at1 * .2, 1.) * vec3(0,153./255.,153./255.);\n    col += pow(moonlight * 2., 2.);\n    col += pow(fire * 0.01, 2.) * vec3(1,0,0);\n    col += sky;\n\n    return col;\n}\n\nfloat hash( vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7, 527.53));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = getPixel(fragCoord);\n\n\n    col = pow(col,vec3(2.2));\n    col = lin2srgb(col);\n    //col = pow(col, vec3(3.));\n    //col = col + (vec3(col.r + col.g + col.b) / 3.) * hash(vec3(fragCoord, 1.0)) * 50.;\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}