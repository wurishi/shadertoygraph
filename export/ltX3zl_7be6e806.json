{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Unsuccessful attempt to use Levenberg-Marquardt with \"residual\" function as \n// displacement from curve, along with variable stepsize, to win money and fame in\n// the \"Parametric competition\" (see https://www.shadertoy.com/view/Xlf3zl, etc.)\n//\n// Background:\n//\n//    http://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm \n//\n// Right now I'm around 26 iterations which looks ok for most of the curve, \n// but leaves some significant bald spots.\n//\n// Hoping that someone comes along to fix my faulty L-M code???\n//\n// -mattz\n\nvec2 map(float t){//from iq's shader https://www.shadertoy.com/view/Xlf3zl\n\treturn 0.85*cos( t + vec2(0.0,1.0) )*(0.6+0.4*cos(t*7.0+vec2(0.0,1.0)));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t\n    \n\tfloat t=0.0, tcur=0.0;\n    vec2 m = map(t), mprev = m, r = p-m; // 1 map\n    float d=length(r);\n    \n    const float dt = 2.*0.157;\n    const int jmax = 20;\n    const int kmax = 5;\n \n\n    // Do a coarse step around the curve to find an initial minimum    \n    for (int j=0; j<jmax; ++j) { // jmax+1 maps\n        \n        tcur += dt;\n        vec2 mcur = map(tcur);\n        vec2 rcur = p - mcur;\n        float dcur = length(rcur);\n        \n        if (dcur<d) {\n            d = dcur;\n            t = tcur;\n            r = rcur;\n            m = mcur;\n        }\n\n        /* // Tried to improve with linear approximation, didn't work.\n       \tfloat u = clamp(dot(p-mprev,mcur-mprev)/dot(mcur-mprev,mcur-mprev), 0.0, 1.0);\n        vec2 mu = mprev+u*(mcur-mprev);\n        float tu = tcur - dt + u*dt;\n        rcur = p - mu;\n        dcur = length(rcur);        \n        \n        if (dcur<d) {\n            t = tcur;\n            r = rcur;\n            m = mcur;\n            //d = dcur;\n        }\n\n        mprev = mcur;\n\t\t*/\n\n        \n    }    \n    \n    // h is some step size only used once\n    const float h = 0.0001;\n    \n    \n    // Our residual (error function) is q = p-map(t)\n    // The (negative) gradient with respect to t of that residual is g\n    // Note that this is only an approximate gradient.\n    vec2 g = (map(t+h)-m)/h; // kmax+2 maps\n   \n    // Lambda is the adaptive step size for L-M\n    float lambda = 0.1;\n    \n\t// Try a handful of L-M iters (sad more doesn't seem to help)\n    for (int k=0; k<kmax; ++k) { // jmax+2+kmax maps\n         \n        // This is the step computation for L-M\n        // we will add s to t to get a new t value.        \n        float s = dot(r,g)/(dot(g,g)+lambda);\n        \n        // Get the new map sample\n        vec2 mcur = map(t + s);\n        \n        // New gradient estimate\n        vec2 gcur = (mcur - m)/s;\n\n        // New residual\n        vec2 rcur = p - mcur;\n        \n        // New distance\n        float dcur = length(rcur);\n        \n        // Did we improve?\n        if (dcur < d) {\n            // Yes, accept step and increase stepsize \n            lambda *= 0.5;\n            t += s;\n            d = dcur;\n            m = mcur;\n            r = rcur;\n            g = gcur;\n        } else {\n            // No, reject step and decrease stepsize.\n            lambda *= 10.;\t\n        }\n        \n        \n    }\n\t    \n\td=smoothstep(0.0,0.01,d);\n\tvec3 col=vec3(sqrt(d),d*d,d);\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltX3zl","date":"1424233859","viewed":242,"name":"Parametric fail","username":"mattz","description":"L-M don't work? See comments...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["parametric","competition"],"hasliked":0,"parentid":"","parentname":""}}