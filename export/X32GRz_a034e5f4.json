{"ver":"0.1","info":{"id":"X32GRz","date":"1708124010","viewed":74,"name":"Fast 3d Fractal Noise","username":"Zentient","description":"Simple layered 3D value noise using billinear interpolation. Doesn't look great at low octaves but I'm going for speed for volumetric raymarching.\nMouseY changes Z value.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["whitenoise","hashing"],"hasliked":0,"parentid":"432GzR","parentname":"Fast 2d fractal noise"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define hashi(x)   lowbias32(x)\n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\nconst float kernelDia = 3.0; //odd numbers only\n\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n//Random function and hash from https://www.shadertoy.com/view/WttXWX\nfloat rand(vec3 position)\n{\n    uvec3 V = uvec3(position);\n    float h = hash( V.x + (V.y<<16) + (V.z<<8));  // 2D hash (should be ok too )\n    return h;\n\n}\n\n\n\n//linear interpolation function \nfloat interpolate(vec3 position)\n{\n    vec3 quantPos = round((position + 0.5));\n    vec3 divPos = fract(0.0 + (1.0 * position));\n    \n\n    //Finds noise values for the corners, treats Z axis as a separate rectnagle\n    vec4 lerpXY = vec4(\n        rand(quantPos + vec3(0.0, 0.0, 0.0)),\n        rand(quantPos + vec3(1.0, 0.0, 0.0)),\n        rand(quantPos + vec3(1.0, 1.0, 0.0)),\n        rand(quantPos + vec3(0.0, 1.0, 0.0)));\n    \n    vec4 lerpXYZ = vec4(\n        rand(quantPos + vec3(0.0, 0.0, 1.0)),\n        rand(quantPos + vec3(1.0, 0.0, 1.0)),\n        rand(quantPos + vec3(1.0, 1.0, 1.0)),\n        rand(quantPos + vec3(0.0, 1.0, 1.0)));\n    \n    //Calculates the area of rectangles\n    vec4 weights = vec4(\n    abs((1.0 - divPos.x) * (1.0 - divPos.y)),\n    abs((0.0 - divPos.x) * (1.0 - divPos.y)),\n    abs((0.0 - divPos.x) * (0.0 - divPos.y)),\n    abs((1.0 - divPos.x) * (0.0 - divPos.y)));\n    \n    //linear interpolation between values\n    vec4 lerpFinal = mix(lerpXY, lerpXYZ, divPos.z);\n   \n    return weights.r * lerpFinal.r +\n           weights.g * lerpFinal.g +\n           weights.b * lerpFinal.b +\n           weights.a * lerpFinal.a;\n    \n}\n//Octaves of noise, sligtly less than a perfect octave to hide linear interpolation artifatcs\nfloat octave(vec3 coord, float octaves, float div)\n{\n    \n    float col = 0.0;\n    float it = 1.0;\n    float cnt = 1.0;\n    for(float i = 1.0; i <= octaves; i++)\n    {\n        col = col + interpolate((it * coord / (div))) / it;\n        it = it * 1.9;\n        cnt = cnt + 1.0 / it;\n       \n    }\n    return col / cnt;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   float oct = 5.0;\n   vec2 uv = fragCoord/iResolution.x;\n   vec3 motCoord = vec3(fragCoord, iMouse.y / 10.0);\n   vec3 col = vec3( pow(octave(motCoord, oct, 60.0), 1.0 ) );\n   fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}