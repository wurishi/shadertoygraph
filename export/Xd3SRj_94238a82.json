{"ver":"0.1","info":{"id":"Xd3SRj","date":"1460137027","viewed":1618,"name":"Voronoi comparison","username":"mattz","description":"Why do we want a spherical Voronoi function? Left: traditional 3D Voronoi cells projected onto sphere lead to curvy borders, uneven cell sizes. Right: new method computed directly on the sphere mitigates these issues.","likes":51,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","worley","spherical","picking","point"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//===============================================================================================\n//\n// Comparison of Voronoi cells on sphere created by \"traditional\" 3D Voronoi with spherical\n// Voronoi. This is a mash-up of two shaders:\n//\n//   left:  \"Voronoi - 3D\" by iq: https://www.shadertoy.com/view/ldl3Dl\n//   right: \"Spherical voronoi\" by mattz: https://www.shadertoy.com/view/MtBGRD\n//\n// Most of the code here comes from iq's original, with some extra bits pasted in to make the\n// latter one work.\n//\n// The left half of the screen is the set of traditional 3D Voronoi boundaries projected onto\n// the sphere. Since the cutting planes beween 3D Voronoi cells are not locally perpendicular\n// to the sphere, they can form curves instead of straight lines on thes sphere's surface. \n// Also since the jittered 3D points are not uniformly distributed on the sphere, the Voronoi\n// cells appear to have an uneven size distribution.\n//\n// The right half of the screen is the spherical Voronoi diagram, which is constructed to \n// combat both problems.\n//\n// Licensed under the MIT License, since iq's original is, too. \n//\n// His code is copyright © 2013 Inigo Quilez\n// My additions are copyright © 2016 Matt Zucker\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//===============================================================================================\n\nvec3 hash( vec3 x )\n{\n  x = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n            dot(x,vec3(269.5,183.3,246.1)),\n            dot(x,vec3(113.5,271.9,124.6)));\n\n  return fract(sin(x)*43758.5453123);\n}\n\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x, out vec3 p1, out vec3 p2 )\n{\n\n  vec3 p = floor( x );\n  vec3 f = fract( x );\n\n  float id = 0.0;\n  vec2 res = vec2( 100.0 );\n  \n  p1 = vec3(1000.);\n  p2 = p1;\n  \n  for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n      for( int i=-1; i<=1; i++ )\n        {\n          // b is cell with integer coordinates\n          vec3 b = vec3( float(i), float(j), float(k) );\n          vec3 r = vec3( b ) - f + hash( p + b );\n          float d = dot( r, r );\n\n          if( d < res.x )\n            {\n              id = dot( p+b, vec3(1.0,57.0,113.0 ) );\n              res = vec2( d, res.x );\n              p2 = p1;\n              p1 = r;\n            }\n          else if( d < res.y )\n            {\n              res.y = d;\n              p2 = r;\n            }\n        }\n\n  return vec3( sqrt( res ), abs(id) );\n}\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n/* Magic angle that equalizes projected area of squares on sphere. */\n#define MAGIC_ANGLE 0.868734829276 // radians\n\n/* Try to restrict branching? Don't know if this has any effect... */\n#define RESTRICT_BRANCHING\n\nfloat warp_theta = MAGIC_ANGLE;\nfloat tan_warp_theta;\n\nconst float N = 6.0;\n\n/* Return a permutation matrix whose first two columns are u and v basis \n   vectors for a cube face, and whose third column indicates which axis \n   (x,y,z) is maximal. */\nmat3 getPT(in vec3 p) {\n\n    vec3 a = abs(p);\n    float c = max(max(a.x, a.y), a.z);    \n#ifdef RESTRICT_BRANCHING\n    vec3 s = step(vec3(c), a);\n    s.yz -= vec2(s.x*s.y, (s.x + s.y - s.x*s.y)*s.z);\n#else\n    vec3 s = c == a.x ? vec3(1.,0,0) : c == a.y ? vec3(0,1.,0) : vec3(0,0,1.);\n#endif\n    s *= sign(dot(p, s));\n    vec3 q = s.yzx;\n    return mat3(cross(q,s), q, s);\n\n}\n\n/* For any point in 3D, obtain the permutation matrix, as well as grid coordinates\n   on a cube face. */\nvoid posToGrid(in vec3 pos, out mat3 PT, out vec2 g) {\n    \n    // Get permutation matrix and cube face id\n    PT = getPT(pos);\n    \n    // Project to cube face\n    vec3 c = pos * PT;     \n    vec2 p = c.xy / c.z;      \n    \n    // Unwarp through arctan function\n    vec2 q = atan(p*tan_warp_theta)/warp_theta; \n    \n    // Map [-1,1] interval to [0,N] interval\n    g = (q*0.5 + 0.5)*N;\n    \n}\n\n\n/* For any grid point on a cube face, along with projection matrix, \n   obtain the 3D point it represents. */\nvec3 gridToPos(in mat3 PT, in vec2 g) {\n    \n    // Map [0,N] to [-1,1]\n    vec2 q = g/N * 2.0 - 1.0;\n    \n    // Warp through tangent function\n    vec2 p = tan(warp_theta*q)/tan_warp_theta;\n\n    // Map back through permutation matrix to place in 3D.\n    return PT * vec3(p, 1.0);\n    \n}\n\n\n/* Return whether a neighbor can be identified for a particular grid cell.\n   We do not allow moves that wrap more than one face. For example, the \n   bottom-left corner (0,0) on the +X face may get stepped by (-1,0) to \n   end up on the -Y face, or, stepped by (0,-1) to end up on the -Z face, \n   but we do not allow the motion (-1,-1) from that spot. If a neighbor is \n   found, the permutation/projection matrix and grid coordinates of the \n   neighbor are computed.\n*/\nbool gridNeighbor(in mat3 PT, in vec2 g, in vec2 delta, out mat3 PTn, out vec2 gn) {\n\n    vec2 g_dst = g.xy + delta;\n    vec2 g_dst_clamp = clamp(g_dst, 0.0, N);\n\n    vec2 extra = abs(g_dst_clamp - g_dst);\n    float esum = extra.x + extra.y;\n \n#ifdef RESTRICT_BRANCHING    \n        \n    vec3 pos = PT * vec3(g_dst_clamp/N*2.0-1.0, 1.0 - 2.0*esum/N);\n    PTn = getPT(pos);\n    gn = ((pos*PTn).xy*0.5 + 0.5) * N;\n    \n    return min(extra.x, extra.y) == 0.0 && esum < N;\n    \n#else\n    \n    if (max(extra.x, extra.y) == 0.0) {\n        PTn = PT;\n        gn = g_dst;\n        return true;\n    } else if (min(extra.x, extra.y) == 0.0 && esum < N) {\n        // Magic stuff happens here.\n        vec3 pos = PT * vec3(g_dst_clamp/N*2.0-1.0, 1.0 - 2.0*esum/N);\n        PTn = getPT(pos);\n        gn = ((pos * PTn).xy*0.5 + 0.5) * N;\n        return true;\t        \n    } else {\n        return false;\n    }\n    \n#endif\n\n}\n\n/* From https://www.shadertoy.com/view/Xd23Dh */\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n                  dot(p,vec2(269.5,183.3)), \n                  dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n\n/* Return squared great circle distance of two points projected onto sphere. */\nfloat sphereDist2(vec3 a, vec3 b) {\n\t// Fast-ish approximation for acos(dot(normalize(a), normalize(b)))^2\n    return 2.0-2.0*dot(normalize(a),normalize(b));\n}\n\n\n/* Just used to visualize distance from spherical Voronoi cell edges. */\nfloat bisectorDistance(vec3 p, vec3 a, vec3 b) {\n    vec3 n1 = cross(a,b);\n    vec3 n2 = normalize(cross(n1, 0.5*(normalize(a)+normalize(b))));\n    return abs(dot(p, n2));             \n}\n\n/* Color the sphere/cube points. */\nvec3 gcolor(vec3 pos) {\n\n    mat3 PT;\n    vec2 g;\n\n    // Get grid coords\n    posToGrid(pos, PT, g);\n    \n    // Snap to cube face - note only needed for visualization.\n    pos /= dot(pos, PT[2]);\n\n    const float farval = 1e5;\n    \n    // Distances/colors/points for Voronoi\n    float d1 = farval;\n    float d2 = farval;\n\n    float m1 = -1.0;\n    float m2 = -1.0;\n\n    vec3 p1 = vec3(0);\n    vec3 p2 = vec3(0);\n\n\t// For drawing grid lines below\n    vec2 l = abs(fract(g+0.5)-0.5);\n\n    // Move to center of grid cell for neighbor calculation below.\n    g = floor(g) + 0.5;\n\n    // For each potential neighbor\n    for (float u=-1.0; u<=1.0; ++u) {\n        for (float v=-1.0; v<=1.0; ++v) {\n            \n            vec2 gn;\n            mat3 PTn;\n\n            // If neighbor exists\n            if (gridNeighbor(PT, g, vec2(u,v), PTn, gn)) {\n                \n                float face = dot(PTn[2], vec3(1.,2.,3.));\n                \n                // Perturb based on grid cell ID\n                gn = floor(gn);\n                vec3 rn = hash3(gn*0.123 + face);\n                gn += 0.5 + (rn.xy * 2.0 - 1.0)*1.0*0.5;\n\n                // Get the 3D position\n                vec3 pos_n = gridToPos(PTn, gn);\n                \n                // Compute squared distance on sphere\n                float dp = sphereDist2(pos, pos_n);\n                \n                // See if new closest point (or second closest)\n                if (dp < d1) {\n                    d2 = d1; p2 = p1;\n                    d1 = dp; p1 = pos_n;\n                } else if (dp < d2) {\n                    d2 = dp; p2 = pos_n;\n                }\n                \n            }\n        }\n    }\n\n    vec3 c = vec3(1.0);\n\n    // voronoi lines    \n    c = mix(c, vec3(0.0),\n            smoothstep(0.01, 0.005, bisectorDistance(pos, p2, p1)));\n\n    // goodbye\n    return c;\n\n}\n\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n  // camera movement\n  const float twopi = 6.283185307179586;\n  float an = iTime*twopi/12.0;\n  vec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n  vec3 ta = vec3( 0.0, 1.0, 0.0 );\n  // camera matrix\n  vec3 ww = normalize( ta - ro );\n  vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n  vec3 vv = normalize( cross(uu,ww));\n  // create view ray\n  vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n  // sphere center\t\n  vec3 sc = vec3(0.0,1.0,0.0);\n    \n  tan_warp_theta = tan(warp_theta);\n\n\n  // raytrace\n  float tmin = 10000.0;\n  vec3  nor = vec3(0.0);\n  float occ = 1.0;\n  vec3  pos = vec3(0.0);\n\t\n  // raytrace-plane\n  float h = (0.0-ro.y)/rd.y;\n  if( h>0.0 ) \n    { \n      tmin = h; \n      nor = vec3(0.0,1.0,0.0); \n      pos = ro + h*rd;\n      vec3 di = sc - pos;\n      float l = length(di);\n      occ = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n    }\n\n  // raytrace-sphere\n  vec3  ce = ro - sc;\n  float b = dot( rd, ce );\n  float c = dot( ce, ce ) - 1.0;\n  h = b*b - c;\n  if( h>0.0 )\n    {\n      h = -b - sqrt(h);\n      if( h<tmin ) \n        { \n          tmin=h; \n          nor = normalize(ro+h*rd-sc); \n          occ = 0.5 + 0.5*nor.y;\n        }\n    }\n\n  // shading/lighting\t\n  vec3 col = vec3(0.9);\n  if( tmin<100.0 ) \n    {\n      pos = ro + tmin*rd;\n\n      vec3 pv = 4.0*pos;\n      float f = 1.0;\n      if (h == tmin) {\n\n        if (p.x >= 0.0) {\n          f = gcolor(pos-sc).x;\n        } else {\n          vec3 p1, p2;\n          vec3 v = voronoi( pv, p1, p2 );\n          \n          vec3 pm = 0.5*(p1+p2);\n          vec3 n = normalize(p2-p1);\n          vec3 np = normalize(pos-sc);\n          float d = abs(dot(pm, n));\n          float cos_theta = dot(n, np); \n          float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n          f = smoothstep(0.005, 0.01, 0.28*d/sin_theta);\n        }\n        \n      } else {\n\n        f = 0.4;\n\n      }\n\n\t\t\n      f *= occ;\n      col = vec3(f*1.2);\n      col = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n    }\n\t\n  col = sqrt( col );\n  col *= step(1.0/640.0, abs(fragCoord.x - 0.5*iResolution.x)/iResolution.x);\n\t\n\t\n  fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}