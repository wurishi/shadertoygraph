{"ver":"0.1","info":{"id":"4tBXDD","date":"1445356747","viewed":622,"name":"Yet another raymarch #4","username":"hexjayi","description":"experiment #4","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","raymarch","bumpmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/* \n\tToying with code from :\n\t@paulofalcao -> https://www.shadertoy.com/view/ldfGzr\n\tIQ raymarch reference and noise -> https://www.shadertoy.com/view/Xds3zN \n\tShane's texture bump mapping -> https://www.shadertoy.com/view/MlXSWX\n*/\n\nconst int ITER = 50;\nconst float PI = 3.14159265;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.9 );\n\nmat3 rotate3(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\nfloat ss(float mi,float ma,float a)\n{ // sineSignal (min,max,alpha)\n\treturn (sin(a)+1.)*(ma-mi)*0.5+mi;\n}\n\n\n//   /\n//---  Noise\n//   \\\n\n\nfloat noise( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec2 p )\n{\n\tp*=3.;\n\tfloat f = 0.0;\n    f += 0.25000*noise( p ); p = m2*p*0.02;\n    f += 0.12500*noise( p ); p = m2*p*0.13;\n    f += 0.06250*noise( p ); p = m2*p*0.01;\n    f += 0.03125*noise( p ); p = m2*p*0.04;\n    f += 0.01500*noise( p );\n    return f/0.38375;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n//    /\n//----  Objects / Primitives\n//    \\\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n#if 0\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n#else\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif    \n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n//    /\n//----  Operators\n//    \\\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p, float freq, float phase )\n{\n    float  c = cos(freq*p.y+phase);\n    float  s = sin(freq*p.y+phase);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\n//    /\n// ---  Field\n//    \\\n\nmat3 rotation;\n\nfloat distanceField(in vec3 p) \n{\n    vec2 res,res0,res1,res2;\n\tres = vec2(9999999.,0.);\n\n    float fbmp=fbm(p);\n        \n  \tp = opRep(p, vec3(10,10.,10.) );\n    \n    res1 = vec2(sdCapsule(p, vec3(0.,0.,-5.), vec3(0.,0.,5.),4.2 ), 000002.);\n    res = opU(res,res1);\n    res1 = vec2(sdCapsule(p, vec3(0.,-5.,0.), vec3(0.,5.,0.),4.2 ), 009900.);\n    res = opU(res,res1);\n    res1 = vec2(sdCapsule(p, vec3(-5.,0.,0.), vec3(5.,0.,0.),4.2 ), 999900.);\n    res2 = opU(res,res1);\n    \n    res1 = vec2( sdBox(p,vec3(5.,5.,5.)),990000);\n    res.x = opS(res1.x,res2.x);\n    \n    return res.x+fbmp*ss(0.,0.8,iTime/2.35);\n}\n\n//    /\n// ---  Texturing\n//    \\\n\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// from Shane : https://www.shadertoy.com/view/MlXSWX\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n//    /\n// ---  Main\n//\t  \\\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \tvec3 bgColor = vec3 (0.1,0.0,0.0);\n\n  \tvec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n  \tvec3 finalColor = vec3 (0.0);  \n  \n  \t//Camera animation\n  \tvec3 vuv=vec3(0,0,1);//Change camere up vector here\n  \t\n    vec3 prp=vec3(\n        \tss(-5.4,15.6,iTime/2.),\n        \tss(-2.,2.,iTime),\n        \t4. ); //Change camera path position here\n  \t\n        \t//2.5 , 2., 2.5 );\n        \t\n    vec3 vrp=vec3(\n        2.5,\n        2.5,\n        //ss(0.,8.,iTime) ); //Change camere view here\n        2.5);\n\n  \t//Camera setup\n  \tvec3 vpn=normalize(vrp-prp);\n  \tvec3 u=normalize(cross(vuv,vpn)*rotate3(vec3(ss(-0.3,0.3,iTime*0.63),0.,0.) ));\n  \tvec3 v=cross(vpn,u);\n  \tvec3 vcv=(prp+vpn);\n  \tvec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp=normalize(scrCoord-prp);\n\n  \t//Raymarching\n  \tconst vec3 e=vec3(0.2,0,0);\n  \tconst float maxd=50.0; //Max depth\n\n  \tfloat s= 0.1;\n  \tvec3 c,p,n;\n\n  \tfloat f=1.0;\n  \tfor(int i=0;i<  ITER ; i++)\n    {\n    \tif (abs(s)<.01||f>maxd) break;\n    \tf+=s;\n    \tp=prp+scp*f;\n    \ts=distanceField(p);\n  \t}\n\n  \tif (f<maxd)\n    {\n    \t\n    \tn=normalize(\n      \tvec3(s-distanceField(p-e.xyy),\n        \ts-distanceField(p-e.yxy),\n        \ts-distanceField(p-e.yyx)));\n    \t\n        float texScale = 0.5;\n        n = doBumpMap(iChannel1, p*texScale, n,  0.40);\n        \n        float b=dot(n,normalize(prp-p));\n\t\t\n        c=tex3D(iChannel1, p*texScale, n)*4.;\n    \t\n        vec3 lightPos = vec3( 2.5,2.5,sin(iTime*1.1)*4. );\n        vec3 lightDir = normalize(lightPos-p);\n        float lightDistance = distance(lightPos,p);\n        \n        float b2=dot(lightDir,n);\n        \n        vec3 c1 = vec3( b*c+pow(b,8.) ) ;\n        vec3 c2 = vec3( c*(b2 + pow(b2, 8.) + 0.35)*1.5/(1.+lightDistance*.1+lightDistance*lightDistance*.005));  // Shane suggestion\n        \n        \n        finalColor = mix(c1,c2,.6);\n\t\tfinalColor*=0.44;\n    \n    \t// vignetting from : https://www.shadertoy.com/view/4lSXDm\n    \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \tvec2 coord = (uv - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    \tfloat Falloff = 0.35;\n        float rf = sqrt(dot(coord, coord)) * Falloff;\n\t    float rf2_1 = rf * rf + 1.0;\n\t    float e = 1.0 / (rf2_1 * rf2_1);\n    \n\t    vec4 src = vec4(finalColor,1.);\n\t\tfragColor = vec4(src.rgb * e, 1.0);    \n    \t//fragColor = vec4( finalColor, 1.);\n  \t} else \n    { // background color\n    \tbgColor = \n\t  \t\tvec3(0.1,0.1,0.1)*0.4;\n\t  \tfragColor=vec4(bgColor,1.);\n  \t}\n}","name":"","description":"","type":"image"}]}