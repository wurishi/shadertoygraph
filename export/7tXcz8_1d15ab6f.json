{"ver":"0.1","info":{"id":"7tXcz8","date":"1677440170","viewed":63,"name":"Exercise 2.12 - Camera Position","username":"marcpages2020","description":"camera position","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["cameraposition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float TAU = 3.14159265359f * 2.0f;\n\nstruct Sphere\n{\n vec3 position;\n float radius;\n vec3 color;\n};\n\nstruct Hit\n{\n  vec3 point;\n  vec3 normal;\n  int objectId;\n};\n\n//Global Variables ===================================================\nvec3 cameraPosition = vec3(0.0f, 0.0f, 5.0f);\nvec3 target = vec3(0.0, 0.2, 0.0);\nfloat planeYPosition = -0.5f;\nSphere spheres[3];\nvec3 lightPosition = vec3(0.5f, 1.0f, 0.5f);\nvec3 lightDirection = normalize(vec3(1.0)); \n//=====================================================================\n\nvec3 rayDirection (in vec2 fragCoord, in vec3 origin)\n{\n  vec3 nearCoord = vec3(2.0 * fragCoord / iResolution.xy - 1.0, 0.0);\n  nearCoord.x *= iResolution.x / iResolution.y;\n  vec3 d = normalize(nearCoord - origin);\n  return d;\n}\n\nbool CastRay(in vec3 origin, in vec3 direction, inout Hit hit, in int ignoreObjectId)\n{ \n  float pt = (planeYPosition - origin.y) / direction.y;\n  vec3 planeIntersectionPoint = origin + direction * pt;  \n  float closestDistance = 10000000000000000000000.0f;\n  \n  //Calculate plane intersection\n  bool hitSomething = false;\n  if(pt > 0.01f)\n  {\n    hit.objectId = -1;\n    hitSomething = true;\n    hit.point = planeIntersectionPoint;\n    hit.normal = vec3(0.0f, 1.0, 0.0f);\n  }\n  \n  for(int i = 0; i < 3; ++i)\n  {\n    if(i == ignoreObjectId)\n    {\n       continue;\n    }\n    \n    float proj = dot(spheres[i].position - origin, direction);\n    vec3 k = origin + direction * proj; \n\n    float l1 = length(spheres[i].position - k);\n    float l2 = sqrt(spheres[i].radius * spheres[i].radius - l1 * l1);\n    \n    float t = proj - l2;\n    \n    vec3 P = origin + direction * t;\n    \n    float sphereIntersection = step(l1, spheres[i].radius);\n    vec3 normals = normalize(P - spheres[i].position);\n    \n    float distanceToIntersection = length(spheres[i].position + normals - cameraPosition);\n    \n    //Collided with sphere\n    if(l1 < spheres[i].radius && distanceToIntersection < closestDistance && t > 0.0f)\n    { \n      closestDistance = distanceToIntersection;\n      hit.objectId = i;\n      hit.point = P;\n      hit.normal = normals;\n      hitSomething = true;\n    }   \n  }\n  \n  return hitSomething;\n}\n\nvec3 Fresnel(vec3 direction, in vec3 normal)\n{\n    vec3 F0 = vec3(0.2f);\n        \n    float cosTheta = dot(-direction, normal);\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 nearCoord = vec3(2.0 * fragCoord / iResolution.xy - 1.0, 0.0);\n    nearCoord.x *= iResolution.x / iResolution.y;\n    \n    \n    cameraPosition = 3.0 *vec3(cos(1.0 - iMouse.y/iResolution.y)*cos(TAU*iMouse.x/iResolution.x),\n                               sin(1.0 - iMouse.y/iResolution.y),\n                               cos(1.0 - iMouse.y/iResolution.y)*sin(TAU*iMouse.x/iResolution.x));\n    \n    vec3 movement = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    \n    cameraPosition += movement;\n    target += movement;\n\n    vec3 front = normalize(cameraPosition - target);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), front));\n    vec3 up = cross(front, right);\n    vec3 d = normalize(right * nearCoord.x + up * nearCoord.y - front * 1.8);\n\n    //Sphere setting\n    float sphereRadius = 0.5f;\n    spheres[0] = Sphere(vec3(-1.0f, 0.0f, 0.2f), sphereRadius, vec3(1.0, 0.0, 0.0));\n    spheres[1] = Sphere(vec3(0.0f, 0.0f, -0.5f), sphereRadius, vec3(0.0, 1.0, 0.0));\n    spheres[2] = Sphere(vec3(1.0f, 0.0f, 0.0f), sphereRadius, vec3(0.0, 0.0, 1.0));\n    \n    //Camera setting\n    vec3 direction = normalize(rayDirection(fragCoord, cameraPosition));\n    direction = d;\n    \n    //Sky setting\n    vec3 skyColor = vec3(0.65, 0.7, 0.8);\n    skyColor = mix(skyColor, vec3(1.0f), -direction.y);      \n    \n    vec3 color = skyColor;\n    \n    vec3 floorColor = vec3(0.65f);\n    \n    Hit hit;\n    vec3 fresnel = vec3(0.0f);\n    vec3 colorReflection = color;\n    \n    //Calculate first intersection\n    if(CastRay(cameraPosition, direction, hit, -2))\n    {\n      //Doesn't collide with anything\n      if(hit.objectId == -1)\n      {\n       color = floorColor;\n      }\n      //Collides with an object\n      else\n      {\n        color = spheres[hit.objectId].color * vec3(max(dot(hit.normal, lightDirection), 0.0f));\n      }\n      \n      fresnel = Fresnel(direction, hit.normal);\n      vec3 reflection = reflect(direction, hit.normal);\n      \n      //Shadows\n      if(CastRay(hit.point, lightDirection, hit, hit.objectId))\n      {\n        color *= 0.2f;\n      }\n      \n      //Reflection\n      if(CastRay(hit.point, normalize(reflection), hit, hit.objectId))\n      {\n         //Plane\n         if(hit.objectId == -1)\n         {\n            colorReflection= max(vec3(dot(hit.normal, lightDirection) * floorColor), vec3(0.0f));\n         }\n         //Sphere\n         else\n         {\n            colorReflection= max(vec3(dot(hit.normal, lightDirection) * spheres[hit.objectId].color), vec3(0.0f));\n         }\n      }\n    }\n    \n    color = mix(color, colorReflection, fresnel);\n    \n    // Output to screen\n    fragColor = vec4(color ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int W = 87;\nconst int A = 65;\nconst int S = 83;\nconst int D = 68;\nconst int Q = 81;\nconst int E = 69;\n\nfloat speed = 0.1f;\n\nvoid CheckKeyboard(inout vec3 movement)\n{\n  if(texelFetch(iChannel1, ivec2(A,0), 0).x == 1.0)\n  {\n    movement.x -= speed;\n  }\n   if(texelFetch(iChannel1, ivec2(D,0), 0).x == 1.0)\n  {\n    movement.x += speed;\n  }\n  \n  if(texelFetch(iChannel1, ivec2(Q,0), 0).x == 1.0)\n  {\n    movement.y += speed;\n  }\n  if(texelFetch(iChannel1, ivec2(E,0), 0).x == 1.0)\n  {\n    movement.y -= speed;\n  }\n  \n  if(texelFetch(iChannel1, ivec2(W,0), 0).x == 1.0)\n  {\n    movement.z -= speed;\n  }\n   if(texelFetch(iChannel1, ivec2(S,0), 0).x == 1.0)\n  {\n    movement.z += speed;\n  }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    vec3 movement = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    CheckKeyboard(movement);\n    //movement = vec3(.0);\n    fragColor = vec4(movement, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}