{"ver":"0.1","info":{"id":"lXt3R2","date":"1716819936","viewed":167,"name":"voronoi 细胞边界距离","username":"shadertoyjiang","description":"点落在哪个细胞中\n再求点到此细胞所有边界的距离并取最近距离\n（将各坐标复原到“世界”坐标，就可以像平时一样画图，各方格过程都相同）\n（细胞核不在细胞中心）","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["x"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\n// 2024年5月27日10时39分32秒\n// 细胞\n\n// hash: Dave_Hoskins: www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * .1031);\n        p3 += dot(p3, p3.zyx + 33.33);\n        return fract((p3.x + p3.y) * p3.z);\n}\n\n// 轨迹半径\nfloat rcel(vec2 ip){return mix(.25,.45, hash12(ip+.2));}                                      \n\nvec2 cell(vec2 ip)\n{// 求细胞核位置\n        float ag = 6.28*hash12(ip + 1.23) + 5.*iTime ;//  * mix(.5,1.5,hash12(ip+3.));// 不同转速，有误差, 数字大点差就大了?                  \n        return vec2(cos(ag), sin(ag)) * rcel(ip);\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        O = vec4(0);\n        \n        #define bl if(iMouse.x<iResolution.x*.52)\n        vec2 R = iResolution.xy,\n             u = 3.*(U+U - R) / R.y+vec2(0,iTime),\n             g =(u-.5)- round(u-.5);\n        // 画格子\n        g = abs(g); if( g.x<g.y )g = g.yx;\n        bl O += .4 * exp(-1e2 * g.y);\n        // 原点\n        bl O += exp(-1e2 * length(u));\n        \n        vec2 p  = u,\n             ip = round(p),\n             fp = p - ip,\n             ct;\n        \n        //ct = normalize(hash22(ip))*rc;\n        ct = cell(ip);\n        \n        // 细胞核轨迹\n        O.x += exp(-30. * length(fp - ct));\n        bl O += .2 * exp(-99. * abs(length(fp) - rcel(ip))) ;\n        \n        // 参考：https://iquilezles.org/articles/voronoilinex/\n        // 找最近细胞核\n        vec2 a,ia;\n        float i,j,md=1e8,d;\n        for(j=-1.;j<2.;j++)\n        for(i=-1.;i<2.;i++)\n        {\n                vec2 e = ip + vec2(i,j),\n                     c = cell(e)+e;\n                d = length(c-p);\n                if(d<md)\n                {\n                        md = d;\n                        ia = e; // 正方形中心\n                        a  = c; // 细胞核位置\n                }\n        }\n        // 细胞上色，点 p 在细胞 a 里\n        O += mix(vec4(.5,0,(ia.y-iTime)/2.,1)+.3,vec4(0,.3,(ia.x-0.)*.3,0)+.2,hash12(ia) );\n        \n        // 求到相交边界的距离\n        md=1e8;\n        for(j=-2.;j<=2.;j++)\n        for(i=-2.;i<=2.;i++)\n        {\n                if(abs(i)+abs(j)>.1) // 不在原点，不跟自己比较\n                //if(length(vec2(i,j))>.1)\n                {\n                        vec2 e = ia + vec2(i,j), // 邻居所在正方形\n                             b = cell(e)+e;      // 第二细胞核位置\n                        d = dot( p- (a+b)/2., normalize(a-b));\n                        md=min(md, d);//md=min(md,abs(d));\n                }\n        }\n        \n        // 线框\n        d = 10. * clamp(exp(-2e2*md), 0., 1.);\n        \n        // 条纹\n        d += .1* clamp(exp(-2e2*cos(80.*md)), 0., 1.);\n        \n        O = max(O-.5*d,0.)+d;\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}