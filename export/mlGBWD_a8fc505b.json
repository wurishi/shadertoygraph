{"ver":"0.1","info":{"id":"mlGBWD","date":"1702065176","viewed":7,"name":"Raycasting test - Early Night","username":"Jupux","description":"First try at implementing raycasting 3d in shadertoy, for a school project\nWarning : there is a high compilation time (between 40 and 100 seconds)\nIm working on it, but if anyone has a clue what I did wrong, just let me know !","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"ctyczm","parentname":"Raytracing - Optimisation test"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int LIGHTS_COUNT = 3;\nconst float epsilon = 0.001;\nconst float pi = 3.1415;\nconst int SP_COUNT = 4;\nconst int PL_COUNT = 6;\nconst int CL_COUNT = 2;\nconst int TR_COUNT = 9;\nconst int OBJECTS_COUNT = SP_COUNT + PL_COUNT + CL_COUNT + TR_COUNT;\nconst int CL_IND = SP_COUNT + PL_COUNT;\nconst int PL_IND = SP_COUNT;\nconst int TR_IND = CL_IND + CL_COUNT;\nconst float SPEED_FACTOR = 2.0;\nconst float RENDER_DISTANCE = 100.0;\n\nvec3 rotateY(vec3 v, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c * v.x - s * v.z, v.y, s * v.x + c * v.z);\n}\n\nvec3 rotateX(vec3 v, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(v.x, c * v.y - s * v.z, s * v.y + c * v.z);\n}\n\n\n/* TO DO : Fix check_shadows epsilon bug\nImprove texture of water\nShadows : use colour instead of grey\nImprove performances (Compilation : cylinder collision, FPS : Better collision detect ? texture applying ?)\n*/\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nCamera C;\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    vec3 vertical = vec3(0.0,0.0,1.0);\n    C.View = normalize(LookAt - Obs);\n    C.Horiz = normalize(cross(vertical, C.View));\n    C.Up = normalize(cross(C.View,C.Horiz));\n    C.Obs = Obs;\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H / (2.0*tan(aperture/2.0));\n    return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   r.Dir = -normalize(C.View * C.z + (XY.x - 0.5 * C.W) * C.Horiz + (XY.y - 0.5 * C.H) * C.Up);\n   return r;\n}\n\n\n//Structure qui correspond à n'importe quel objet de la scène\nstruct Object {\n   int type; // 0 for Sphere, 1 for Plan, 2 for Cylinder, 3 for transparent objects\n   vec3 Center; // Center for sphere, origin for cylinder / plan\n   float R; // Radius for sphere and cylinder\n   vec3 Color;\n   vec3 ColorBis;\n   float opacity;\n   bool is_light;\n   bool is_finite;\n   bool is_triangle;\n   bool force_render;\n   float texture_scaling;\n   \n   vec3 d1; // First vector of plan & Up vector for cylinder\n   vec3 d2; // Second vector of plan\n   vec3 normal; // Normal for the plan\n   float height; // height of plan / cylinder\n   float width; // Width for plan / cylinder\n   \n   \n};\n\n// Structure des lumières\nstruct Light {\n    vec3 Pos;\n    vec3 Color;\n    float Intensity;\n    float bypassIntensity;\n    float maxtheta;\n    float minIntensity;\n    float diffusion; // factor by which intensity decreasing is affected\n    float attExp;\n    float attLin;\n    float attCon;\n};\n\n// Tableaux qui contiennent mes lumières / les centres de mes objets   \nLight lights[LIGHTS_COUNT];\nvec3 centers[OBJECTS_COUNT];\n\n\n// Fonction qui calcule  la direction de la normale d'un plan suivant la position de la caméra\nvec3 compute_normal(in Camera C, in Object P) {\n    vec3 n = cross(P.d1,P.d2);\n    if(dot(n,C.Obs - P.Center) > 0.0) {\n        n = -n;\n    }\n    return n;\n}\n\n\n// Fonction qui \"stocke\" mes objets en les recalculant\nObject next_object(in int type, int num) {\n\n    Object O;\n    float a = iTime*SPEED_FACTOR;\n    O.type = type;\n    O.texture_scaling = 0.0;\n    O.opacity = 1.0;\n    float speed = 3.0;\n   \n           \n    if (type == 0) {\n    \n       if (num== 0) { // Sphère de l'arbre\n       \n       O.Center = centers[num];\n       O.R = 1.6;\n       O.Color = vec3(40, 64, 46)/255.0;\n       O.is_light = false;\n       }\n       \n       else if (num == 1) { // Flamme de la lanterne\n       \n       O.Center = centers[num];\n       O.R = 0.125;\n       O.Color= vec3(247, 188, 87)/255.0*(1.0 + max(0.0,0.2*(sin(5.0*a) + sin(8.0*a) +0.5*sin(13.0*a))));\n       O.is_light = true;\n       }\n        \n       else if (num == 2) { // Poignée de la lanterne\n\n       O.Center = centers[num];\n       O.R = 0.15;\n       O.Color = O.Color = vec3(102, 94, 81)/255.0;\n       O.is_light = false;\n       }\n         \n       else if (num == 3) { // Luciole\n       \n       O.R = 0.075;\n\n       O.Color =vec3(247, 233, 161)/255.0*(1.0 + max(0.0,0.2*(sin(5.0*a/speed) + sin(8.0*a/speed) +0.5*sin(13.0*a/speed)))) ;\n       O.is_light = true;\n       O.Center = centers[num];\n       O.force_render = true;\n       }\n       \n      }\n \n    \n    else if (type == 1) {\n        \n        if (num == 0) { // Fond Marin\n        \n        O.is_light = false;\n        O.Center = centers[num + PL_IND] + vec3(0,0,0.3);\n        O.d1 = vec3(0.0,1.0,0.0);\n        O.d2 = vec3(1.0,0.0,0.0);\n        O.Color = vec3(255, 230, 128)/255.0;\n        O.normal = compute_normal(C,O);\n        O.is_finite = false;\n        O.is_triangle = false;\n        }\n        \n        else if (num == 1) { // Herbe\n        \n            O.is_light = false;\n            O.Center = centers[num + PL_IND];\n            O.d1 = vec3(0.0,1.0,0.0);\n            O.d2 = vec3(1.0,0.0,0.0);\n            O.Color = vec3(48, 110, 55)/255.0;\n            O.normal = compute_normal(C,O);\n            O.is_finite = true;\n            O.height = 500.0;\n            O.width = 500.0;\n            O.is_triangle = false;\n        }\n        \n        else if (num == 2) {  // Plan incliné X\n        \n            O.is_light = false;\n            O.Center = centers[num + PL_IND];\n            mat3 rotZ = rotateY(-pi/8.0);\n            O.d1 = vec3(0.0,1.0,0.0) * rotZ;\n            O.d2 = vec3(1.0,0.0,0.0) * rotZ;\n            O.Color = vec3(110, 81, 52)/255.0;\n            O.normal = compute_normal(C,O);\n            O.is_finite = true;\n            O.height = 10.0;\n            O.width = 500.0;\n            O.is_triangle = false;\n        }\n        \n        else if (num == 3) { // Plan incliné Y\n            \n            O.is_light = false;\n            O.Center = centers[num + PL_IND];\n            mat3 rotZ = rotateX(pi/8.0);\n            O.d1 = vec3(0.0,1.0,0.0) * rotZ;\n            O.d2 = vec3(1.0,0.0,0.0) * rotZ;\n            O.Color = vec3(110, 81, 52)/255.0;\n            O.normal = compute_normal(C,O);\n            O.is_finite = true;\n            O.height = 500.0;\n            O.width = 10.0;\n            O.is_triangle = false;\n        \n        }\n        else if (num == 4) { // Pas utiisé\n            \n            O.is_light = false;\n            O.Center = centers[num + PL_IND];\n             mat3 rotX = rotateX(pi/8.0);\n             mat3 rotZ = rotateZ(-pi/4.0);\n             mat3 rotY = rotateY(0.0);\n            O.d1 = vec3(-1.0,0.0,0.0)*rotX*rotZ*rotY;\n            O.d2 = vec3(0.0,-1.0,0.0)*rotX*rotZ*rotY;\n            O.Color = vec3(110, 81, 52)/255.0;\n            O.normal = compute_normal(C,O);\n            O.is_finite = true;\n            float b = 0.75/tan(pi/8.0);\n            float a = sqrt(b*b + 0.75*0.75);\n            O.height = a*sqrt(2.0);\n            O.width = b;\n            O.is_triangle = true;\n        \n        }\n        else if (num == 5) { // Pas utilisé\n            \n            O.is_light = false;\n            O.Center = centers[num + PL_IND];\n            O.d1 = vec3(0.0,1.0,0.0);\n            O.d2 = vec3(0.0,0.0,-1.0);\n            O.Color = vec3(110, 81, 52)/255.0;\n            O.normal = compute_normal(C,O);\n            O.is_finite = true;\n            O.height = 10.0;\n            O.width = 10.0;\n            O.is_triangle = true;\n        \n        }\n        else if (num >= 6) { // Pas utilisé\n            \n            O.is_light = false;\n            O.Center = centers[num + PL_IND];\n            mat3 rotX = rotateX(0.5*a);\n            mat3 rotZ = rotateZ(2.0*a);\n            O.d1 = vec3(0.0,0.0,1.0)*rotZ*rotX;\n            O.d2 = vec3(1.0,0.0,0.0)*rotZ*rotX;\n            O.Color = vec3(1.0,1.0,1.0);\n            O.normal = compute_normal(C,O);\n            O.is_finite = true;\n            O.height = 0.5;\n            O.width = 0.7;\n        \n        }\n        \n        \n        }\n    \n    \n    else if (type == 2) {\n        \n        if (num == 0) { // Tronc de l'arbre\n     \n         O.is_light = false;\n         O.R = 0.5;\n         O.Color = vec3(69, 50, 38)/255.0;\n         O.height = 3.5;\n         O.width = 0.00;\n         O.d1 = vec3(0,0,1);\n         O.Center = centers[num + CL_IND];         \n         }\n         \n        \n        else if (num == 1) { // Bûche couchée\n     \n         O.is_light = false;\n         O.R = 0.5;\n         mat3 rotX = rotateX(pi/2.0);\n         mat3 rotZ = rotateZ(20.0*pi/180.0);\n         O.Color = vec3(69, 50, 38)/255.0;\n         O.height = 3.5;\n         O.width = 0.1;\n         O.d1 = vec3(0,0,1)*rotX*rotZ;\n         O.Center = centers[num + CL_IND];         \n         }\n         \n         \n        }\n    else if (type == 3) {\n        \n        if (num == 0) { // Eau\n        \n        O.is_light = false;\n        O.Center = centers[num + TR_IND];\n        O.d1 = vec3(0.0,1.0,0.0);\n        O.d2 = vec3(1.0,0.0,0.0);\n        O.Color = vec3(0.0,102.0/255.0,1.0);\n        O.normal = compute_normal(C,O);\n        O.is_finite = false;\n        O.is_triangle = false;\n        O.texture_scaling = 3.0;\n        //O.ColorBis = vec3(7, 100, 240)/255.0;\n        O.ColorBis = vec3(186, 235, 247)/255.0; //pour banger\n        O.opacity = 0.65;\n        \n        }\n        \n        else if (num == 1) { // Première face de la lanterne\n        \n        O.is_light = false;\n        O.Center = centers[num + TR_IND];\n        mat3 rotX = rotateX(0.0);\n        mat3 rotZ = rotateZ(0.0);\n        mat3 rotY = rotateY(pi/2.0);\n        O.d1 = vec3(0.0,1.0,0.0)*rotX*rotY*rotZ;\n        O.d2 = vec3(1.0,0.0,0.0)*rotX*rotY*rotZ;\n        O.Color = vec3(158, 150, 131)/255.0;\n        O.normal = compute_normal(C,O);\n        O.is_finite = true;\n        O.is_triangle = false;\n        O.height = 0.375;\n        O.width = 0.25;\n        O.opacity = 0.30;\n        \n        }\n        \n        else if (num == 2) {// Seconde ...\n        \n        O.is_light = false;\n        O.Center = centers[num + TR_IND];\n        mat3 rotX = rotateX(0.0);\n        mat3 rotZ = rotateZ(pi/2.0);\n        mat3 rotY = rotateY(pi/2.0);\n        O.d1 = vec3(0.0,1.0,0.0)*rotX*rotY*rotZ;\n        O.d2 = vec3(1.0,0.0,0.0)*rotX*rotY*rotZ;\n        O.Color = vec3(158, 150, 131)/255.0;\n        O.normal = compute_normal(C,O);\n        O.is_finite = true;\n        O.is_triangle = false;\n        O.height = 0.375;\n        O.width = 0.25;\n        O.opacity = 0.30;\n        \n        }\n        else if (num == 3) { // troisième\n        \n        O.is_light = false;\n        O.Center = centers[num + TR_IND];\n        mat3 rotX = rotateX(0.0);\n        mat3 rotZ = rotateZ(pi/2.0);\n        mat3 rotY = rotateY(pi/2.0);\n        O.d1 = vec3(0.0,1.0,0.0)*rotX*rotY*rotZ;\n        O.d2 = vec3(1.0,0.0,0.0)*rotX*rotY*rotZ;\n        O.Color = vec3(158, 150, 131)/255.0;\n        O.normal = compute_normal(C,O);\n        O.is_finite = true;\n        O.is_triangle = false;\n        O.height = 0.375;\n        O.width = 0.25;\n        O.opacity = 0.30;\n        \n        }\n        else if (num == 4) { // Quatrième\n        \n        O.is_light = false;\n        O.Center = centers[num + TR_IND];\n        mat3 rotX = rotateX(0.0);\n        mat3 rotZ = rotateZ(0.0);\n        mat3 rotY = rotateY(pi/2.0);\n        O.d1 = vec3(0.0,1.0,0.0)*rotX*rotY*rotZ;\n        O.d2 = vec3(1.0,0.0,0.0)*rotX*rotY*rotZ;\n        O.Color = vec3(158, 150, 131)/255.0;\n        O.normal = compute_normal(C,O);\n        O.is_finite = true;\n        O.is_triangle = false;\n        O.height = 0.375;\n        O.width = 0.25;\n        O.opacity = 0.30;\n        \n        }\n        else if (num == 5) { // Cinquième\n        \n        O.is_light = false;\n        O.Center = centers[num + TR_IND];\n        mat3 rotX = rotateX(0.0);\n        mat3 rotZ = rotateZ(0.0);\n        mat3 rotY = rotateY(0.0);\n        O.d1 = vec3(0.0,1.0,0.0)*rotX*rotY*rotZ;\n        O.d2 = vec3(1.0,0.0,0.0)*rotX*rotY*rotZ;\n        O.Color = vec3(102, 94, 81)/255.0;\n        O.normal = compute_normal(C,O);\n        O.is_finite = true;\n        O.is_triangle = false;\n        O.height = 0.25;\n        O.width = 0.25;\n        O.opacity = 0.95;\n        \n        }\n        \n        else if (num == 6) { // Sixième\n        \n        O.is_light = false;\n        O.Center = centers[num + TR_IND];\n        mat3 rotX = rotateX(0.0);\n        mat3 rotZ = rotateZ(0.0);\n        mat3 rotY = rotateY(0.0);\n        O.d1 = vec3(0.0,1.0,0.0)*rotX*rotY*rotZ;\n        O.d2 = vec3(1.0,0.0,0.0)*rotX*rotY*rotZ;\n        O.Color = vec3(102, 94, 81)/255.0;\n        O.normal = compute_normal(C,O);\n        O.is_finite = true;\n        O.is_triangle = false;\n        O.height = 0.25;\n        O.width = 0.25;\n        O.opacity = 1.00;\n        \n        }\n        \n        else if (num == 7) { // Première aile de la luciole\n        \n        O.is_light = true;\n        O.Center = centers[num + TR_IND];\n        mat3 rotX = rotateX(0.0);\n        mat3 rotZ = rotateZ(a/5.0);\n        mat3 rotY = rotateY(pi/2.0 - pi/4.0 - sin(a*14.0)/8.0*pi);\n        O.d1 = vec3(0.0,1.0,0.0)*rotX*rotY*rotZ;\n        O.d2 = vec3(1.0,0.0,0.0)*rotX*rotY*rotZ;\n        O.Color = vec3(199, 242, 242)/255.0*(1.0 + max(0.0,0.2*(sin(5.0*a/speed) + sin(8.0*a/speed) +0.5*sin(13.0*a/speed))));\n        O.normal = compute_normal(C,O);\n        O.is_finite = true;\n        O.is_triangle = true;\n        O.height = 0.2;\n        O.width = 0.2;\n        O.opacity = 0.85;\n        \n        }\n        \n        else if (num == 8) { // Seconde\n        \n        O.is_light = true;\n        O.Center = centers[num + TR_IND];\n        mat3 rotX = rotateX(0.0);\n        mat3 rotZ = rotateZ(a/5.0);\n        mat3 rotY = rotateY(pi/2.0 + pi/4.0 + sin(a*14.0)/8.0*pi);\n        O.d1 = vec3(0.0,1.0,0.0)*rotX*rotY*rotZ;\n        O.d2 = vec3(1.0,0.0,0.0)*rotX*rotY*rotZ;\n        O.Color = vec3(199, 242, 242)/255.0*(1.0 + max(0.0,0.2*(sin(5.0*a/speed) + sin(8.0*a/speed) +0.5*sin(13.0*a/speed))));\n        O.normal = compute_normal(C,O);\n        O.is_finite = true;\n        O.is_triangle = true;\n        O.height = 0.2;\n        O.width = 0.2;\n        O.opacity = 0.85;\n        \n        }\n        \n        \n        else if (num >= 9) { // Pas utilisé\n        \n        O.is_light = false;\n        O.Center = centers[num + TR_IND];\n        mat3 rotX = rotateX(0.5*a);\n        mat3 rotZ = rotateZ(2.0*a);\n        O.d1 = vec3(0.0,0.0,1.0)*rotZ*rotX;\n        O.d2 = vec3(1.0,0.0,0.0)*rotZ*rotX;\n        O.normal = compute_normal(C,O);\n        O.Color = vec3(1.0,0.0,0.0);\n        O.opacity = 0.4;\n        O.is_finite = true;\n        O.width = 0.5;\n        O.height = 0.5;\n        }\n        \n    \n    }\n    \n    \n    return O;\n\n}\n\n\n// Fonction de base pour l'intersection d'un rayon avec un cylindre ouvert\nbool intersect_cylinder_base(in Ray R, in Object C, out float t, out float l) {\n\n    const float m = 1.93;\n    vec3 x = (R.Dir - dot(C.d1,R.Dir)*C.d1);\n    vec3 y = (R.Origin - C.Center - dot(C.d1,(R.Origin - C.Center))*C.d1);\n    float a = length(x) * length(x);\n    float b = 2.0*dot(x,y);\n    float c = length(y)*length(y) - C.R*C.R;\n    l = -1.0;\n    \n    float delta = b*b - 4.0*a*c;\n    if (delta > 0.0) {\n        float t1 = (-b + sqrt(delta))/(2.0*a);\n        float t2 = (-b - sqrt(delta))/(2.0*a); \n        \n        float l1 = dot(C.d1,-(R.Origin + t1*R.Dir - C.Center));\n        float l2 = dot(C.d1,-(R.Origin + t2*R.Dir - C.Center));\n        \n        bool b1 = ( l1 > C.height || l1 < 0.0);\n        bool b2 = ( l2 > C.height || l2 < 0.0);\n        \n        if ( b1 && b2 ) {\n            t = -1.0;\n            return false;\n        } else if (b1) {\n             t = t2;\n             l = l2;\n             \n        } else if (b2) {\n            t = t1;\n            l = l1;\n        } else {\n            if (t1 < 0.0) {\n                t = t2;\n                l = l2;\n            }\n            if (t2 < 0.0) {\n                t = t1;\n                l = l1;\n            }\n            if (t1 > 0.0 && t2 > 0.0) {\n                t = min(t1,t2);\n                if (t == t1) { l = l1;} else {l= l2;}\n                \n            }\n        }\n\n    } else if (delta == 0.0) {\n        t = -b/(2.0*a);\n        l = dot(C.d1,-(R.Origin + t*R.Dir - C.Center));\n        \n        if ( l > C.height && l < 0.0) {\n            t = -1.0;\n            return false;\n        }\n    }\n    \n   \n    else {\n        t = -1.0;\n        return false;\n    }\n    \n    return true;\n}\n\n\n// Intersection d'un rayon avec l'extrémité bouchée des cylindres épais \nbool intersect_edge_cylinder(in Ray R, in Object P, in float min_radius, out float t) {\n\n    if (abs(dot(cross(P.d2,P.d1),R.Dir)) <= 0.00001) {\n        t = -1.0;\n        return false;\n    }\n    float denom = dot(P.normal, R.Dir);\n    \n    t = dot(P.normal, P.Center - R.Origin) / denom;\n\n    vec3 I = R.Origin + t * R.Dir;\n\n    vec3 v0 = I - P.Center;\n    float u = dot(v0, P.d1) / dot(P.d1, P.d1);\n    float v = dot(v0, P.d2) / dot(P.d2, P.d2);\n    float distanceToCenter = distance(vec2(u,v),vec2(0,0));\n\n       \n    if (!(distanceToCenter >= (min_radius) && distanceToCenter <= P.R)) {\n         t= -1.0;\n         return false;\n    }\n    \n    return true;\n    \n    \n    /*\n    mat3 X = inverse(mat3(R.Dir,\n                    -P.d1,\n                     -P.d2));\n    vec3 v0 = P.Center - R.Origin;\n    vec3 C = X*v0;\n    t = C.x;\n    \n    float u = C.y;\n    float v = C.z;\n    float distanceToCenter = distance(vec2(u,v),vec2(0,0));\n\n       \n    if (!(distanceToCenter >= (min_radius) && distanceToCenter <= P.R)) {\n         t= -1.0;\n         return false;\n    }\n    \n    return true;*/\n\n}\n\n// Intersection d'un rayon avec un cylindre. Traite le cas de base, et le cas du cylindre épais\nbool intersect_cylinder(in Ray R, in Object C, out float t, out vec3 normal) {\n\n    const float m = 1.92;\n    float l1;\n    float t1;\n    bool result1 = intersect_cylinder_base(R,C,t1,l1);\n    bool result2;\n    bool result3;\n    bool result4;\n    t = t1;\n    normal = -(R.Origin + t*R.Dir - (C.Center-(l1*C.d1)));\n    if (C.width > 0.0) {\n    \n        float old_R = C.R;\n        C.R = C.R-C.width;\n        float t2;\n        float l2;\n        result2 = intersect_cylinder_base(R,C,t2,l2);\n        C.R = old_R;\n        \n        if (t2 > 0.0) {\n        \n            if (t < 0.0 || (t2 < t && t2 > 0.0)) {t = t2;normal = (R.Origin + t*R.Dir - (C.Center-(l2*C.d1)));}\n            \n        }\n        \n        \n        Object P1;\n        P1.Center = C.Center;\n        P1.normal = -C.d1;\n        P1.d1 = normalize(cross(P1.normal, vec3(1.0, 0.0, 0.0)));\n        P1.d2 = normalize(cross(P1.normal, P1.d1));     \n        P1.R = C.R;\n        \n        float t3;\n        result3 = intersect_edge_cylinder(R,P1,C.R-C.width,t3);\n        \n        if (t3 > 0.0) {\n        \n            if (t < 0.0 || (t3 < t && t3 > 0.0)) {t = t3; normal = P1.normal;}\n            \n        }\n        \n        Object P2;\n        P2.Center = C.Center - C.height*normalize(C.d1);\n        P2.normal = C.d1;\n        P2.d1 = normalize(cross(P2.normal, vec3(1.0, 0.0, 0.0)));\n        P2.d2 = normalize(cross(P2.normal, P2.d1));     \n        P2.R = C.R;\n\n        float t4;\n        result4 = intersect_edge_cylinder(R,P2,C.R-C.width,t4);\n\n        if (t4 > 0.0) {\n        \n            if (t < 0.0 || (t4 < t && t4 > 0.0)) {t = t4;normal = P2.normal;}\n            \n        }\n        \n    }\n    normal = normalize(normal);\n    return result1||result2||result3||result4;\n\n}\n\n// Intersection avec un plan. Traite le cas des plans finis et des triangles\nbool intersect_plan(in Ray R, in Object P, out float t, out vec2 loc) {\n\n    if (abs(dot(cross(P.d2,P.d1),R.Dir)) <= -0.00001) {\n        t = -1.0;\n        return false;\n    }\n    /*\n    mat3 X = inverse(mat3(R.Dir,\n                    -P.d1,\n                     -P.d2));\n    vec3 v0 = P.Center - R.Origin;\n    vec3 C = X*v0;\n    t = C.x;\n    float u = C.y;\n    float v = C.z;*/\n    \n    \n    float denom = dot(P.normal, R.Dir);\n    \n    t = dot(P.normal, P.Center - R.Origin) / denom;\n\n    vec3 I = R.Origin + t * R.Dir;\n\n    vec3 v0 = I - P.Center;\n    float u = dot(v0, P.d1) / dot(P.d1, P.d1);\n    float v = dot(v0, P.d2) / dot(P.d2, P.d2);\n    loc.x = u;\n    loc.y = v;\n    float distanceToCenter = distance(vec2(u,v),vec2(0,0));\n    \n    if (P.is_finite && (P.width < abs(u) || P.height < abs(v))) {\n         t= -1.0;\n         return false;\n    }\n    \n    bool not_in_triangle = !((v < (u*(-P.height/P.width) + P.height)));\n    \n    if (P.is_triangle && ( (u<0.0) || (v <0.0) || not_in_triangle) ) {\n        t = -1.0;\n        return false;\n    }\n    return true;\n}\n\n\n\n// Intersection avec une sphère\nbool intersect_sphere(in Ray R, in Object S, out float t, out bool is_light) {\n    \n    float delta = 4.0*(pow(dot(R.Dir,R.Origin - S.Center),2.0) - pow(length(R.Dir),2.0)*(pow(length(R.Origin - S.Center),2.0) - pow(S.R,2.0)))                        ;\n    is_light = false;\n    if (delta > 0.0) {\n        float t1 = (-2.0*(dot(R.Dir,R.Origin - S.Center)) - sqrt(delta))/(2.0*pow(length(R.Dir),2.0));\n        float t2 =(-2.0*(dot(R.Dir,R.Origin - S.Center)) + sqrt(delta))/(2.0*pow(length(R.Dir),2.0));\n        t = t1;\n        \n        if (t1 < 0.0) {\n            t = t2;\n            if (t2 < 0.0) {return false;}\n        }\n    \n    } else if (delta == 0.0) {\n        t = -(dot(R.Dir,R.Origin - S.Center))/(pow(length(R.Dir),2.0));\n        if (t < 0.0) {return false;}\n    } else {\n        t = -1.0;\n        return false;\n    }\n    is_light = S.is_light;\n    return true;\n}\n\n\n// Gestion du calcul des ombres entre un point et une source lumineuse. Retourne l'intensité de l'ombre à appliquer\nfloat check_for_shadows(in Ray R, in Light L, in float t, in int i, in bool itself) {\n\n    float itself_dist = 0.001;\n    Ray Rl;\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = (L.Pos - Rl.Origin);\n    Rl.Origin = Rl.Origin + 0.0001*Rl.Dir;\n    float t2 = -1.0;\n    bool intersect = false; \n    float s_intensity = 0.0;\n    \n    \n    for(int j = 0; j < OBJECTS_COUNT; j++) {\n        Object O;\n        if (j < SP_COUNT) {O = next_object(0,j);}\n        else if (j < SP_COUNT + PL_COUNT) {O = next_object(1,j-SP_COUNT);}\n        else if (j < SP_COUNT + PL_COUNT + CL_COUNT) {O = next_object(2,j-SP_COUNT-PL_COUNT);}\n        else if (j < SP_COUNT + PL_COUNT + CL_COUNT + TR_COUNT) {O = next_object(3,j-SP_COUNT-PL_COUNT-CL_COUNT);}\n        if ((itself || j != i) && s_intensity < 0.99  && ((length(O.Center - L.Pos) > 0.1) || O.type != 0)) {\n            bool a = false;\n            vec4 f = vec4(0,0,0,1);\n            t2 = -1.0;\n            if (O.type == 0) {\n                intersect_sphere(Rl, O, t2,a);\n            } else if (O.type == 1 || O.type == 3) {\n                vec2 loc = vec2(0,0);\n                intersect_plan(Rl,O,t2,loc);\n            } else if (O.type == 2) {\n                 vec3 f = vec3(0,0,0);\n                 intersect_cylinder(Rl,O,t2,f);\n            }\n            if (j!=i && (t2 > epsilon && t2 < 1.00 - epsilon)) {\n                s_intensity += O.opacity;\n            } else if (j == i && (t2 > itself_dist && t2 < 1.00 - epsilon)) {\n                s_intensity += O.opacity;\n            }\n        }\n    }\n    return s_intensity;\n\n}\n\n// Fonctions liées au calcul du bruit Simplex. Seules fonctions que je n'ai pas faites\n//Simplex Noise 2D\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat randomNoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\n// Fonction qui calcule la couleur d'un objet après l'application d'une lumière donnée. Gère l'application de la texture de l'eau\nvec3 apply_light(in Ray R, in Object S, in Light L, in float t, in int i, in bool itself) {\n    float costheta;\n    float dist;\n    float finalIntensity;\n    // calcul de costheta\n    if (S.type == 0) {\n        costheta = dot(normalize(S.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n        dist = length((R.Origin + t*R.Dir) - L.Pos);\n    } else if (S.type == 1 || S.type == 3) {\n        vec3 n = S.normal;\n        costheta = dot(normalize(n),normalize((R.Origin + t*R.Dir) - L.Pos));\n        dist = length((R.Origin + t*R.Dir) - L.Pos);\n    } else if (S.type == 2) {\n        vec3 n;\n        intersect_cylinder(R,S,t,n);\n        costheta = dot(normalize(n),normalize((R.Origin + t*R.Dir) - L.Pos));\n        dist = length((R.Origin + t*R.Dir) - L.Pos);\n        \n    }\n    \n    // Gestion lumière \"normale\"\n    if (L.bypassIntensity == 0.0) {\n        costheta = max(0.0,costheta);\n        float dist_reduction = dist/L.diffusion;\n        if (dist_reduction >0.0){\n                finalIntensity = L.Intensity/(dist_reduction*dist_reduction*L.attExp + dist_reduction*L.attLin + L.attCon) * costheta;\n        } else {\n            \n            finalIntensity = L.Intensity * costheta;\n        }\n        \n        \n    } else { // Gestion lumière \"ambiante\"\n        \n        float theta = acos(costheta)*180.0/pi;\n        float cosMax = cos(L.maxtheta*pi/180.0);\n        costheta = max(0.0,costheta);\n        finalIntensity = L.Intensity*L.bypassIntensity;\n        if (theta <=90.0 && theta >= L.maxtheta) { // On gonfle les niveaux de luminosité pris pour les angles plus élevés\n            \n            float a = (L.minIntensity) / cosMax;\n            float b = 0.0;\n            costheta = a*costheta + b;\n\n        } else if ( theta <= 90.0 && theta < L.maxtheta) { // On restreint la plage de valeur pour les angles plus faibles\n            \n            float a = (1.0-L.minIntensity) / (1.0 - cosMax);\n            float b = L.minIntensity - a*cosMax;\n            costheta = a*costheta + b;\n        \n            }\n        finalIntensity = finalIntensity / (L.Intensity + 1.0);\n        \n        }\n    \n       \n       \n    \n    costheta = min(1.0,costheta);\n    \n    float s_intensity = check_for_shadows(R, L, t, i,itself);\n    if (s_intensity > 0.999 && S.is_light == false) {\n        return vec3(0,0,0);\n    }\n    \n    \n    if ((S.texture_scaling == 0.0)) {\n    return vec3(finalIntensity*L.Color*S.Color*costheta)*(1.0-s_intensity);\n    \n    \n    } else { // Application de sa texture à l'eau\n        vec2 loc = vec2(0.0,0.0);\n        float t2;\n        intersect_plan(R,S,t2,loc);\n        if(abs(loc.x) + abs(loc.y) < RENDER_DISTANCE) {\n       \n        float a = (iTime+300.0)/1.50;\n        vec2 texture_offset = vec2(a,a/2.0);\n        vec3 text = randomNoise(loc*S.texture_scaling + texture_offset)*vec3(1,1,1);\n         //vec3 text = vec3(1,1,1);\n        //text = texture(iChannel0, loc*S.texture_scaling + texture_offset).xyz;\n        vec3 color;\n        \n        //if(text.x <0.0) {color = S.ColorBis;} else {color = S.Color;}\n        float seuil = max(0.87,0.89 + sin(abs(text.x)*a)/8.0);\n        if(text.x < -seuil) {color = S.ColorBis;}\n        else {color = S.Color * (1.0-(text.x+seuil)/(1.0+seuil) + S.ColorBis*(text.x+seuil)/(1.0+seuil));} //effet banger mais jsp pas pk\n        \n        return (color*finalIntensity*costheta*L.Color)*(1.0-s_intensity);\n        } else {\n            return vec3(finalIntensity*costheta*L.Color*S.Color) *(1.0-s_intensity);\n        }\n        \n    }\n    }\n\n\n// Retour d'un flottant aléatoire\nfloat rand(float co) { return fract(sin(co*iTime*(91.3458)) * 47453.5453); }\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n   \n    float a = iTime*SPEED_FACTOR;    \n\n    /*float C_trig_pos= mod(a,2.0*pi)/2.0 - pi/2.0;;\n    if (C_trig_pos > 0.0) {\n        C_trig_pos =- C_trig_pos ;\n    }\n\n    \n    float t = clamp((C_trig_pos + pi / 2.0) / pi, 0.0, 1.0);\n    t = smoothstep(0.0, 1.0, t);\n\n    \n    float easedRadius = radius * t;\n    \n    */\n    \n    \n    \n    \n    vec3 cornerPosition = vec3(-5.0,5.0,2.65);\n    \n    /*\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n   \n    bool isMouseClick = iMouse.z > 0.0;\n    */\n    \n\n    /*\n    if (isMouseClick)\n    {\n        vec2 delta = mouse - 0.5; \n        lookAtPosition = rotateY(lookAtPosition, delta.x * 3.0);\n        lookAtPosition = rotateX(lookAtPosition, delta.y * 3.0);\n        \n    }*/\n    \n    vec3 lookAtPosition = vec3(-15.0, -5.0, 2.0);\n    float radius = 2.5;\n    vec3 cameraPosition = vec3(radius * cos(a/10.0), radius * sin(a/10.0), 1.5) + vec3(8.0,13.0,-3.0);//vec3(8.0,13.0,-3.0); //vec3(radius * cos(a/10.0), radius * sin(a/10.0), 1.5) + vec3(8.0,13.0,-3.0);\n    \n    \n    C.Obs.x += 2.0 * (iMouse.x / iResolution.x - 0.5);\n    C.Obs.y -= 2.0 * (iMouse.y / iResolution.y - 0.5);\n\n    \n    \n    float fov = 100.0 * 180.0 / pi;\n\n    C = camera(cameraPosition, lookAtPosition, fov);\n    vec3 offset;\n    mat3 rotZ;\n    mat3 rotX;\n    vec3 rotatedOffset;\n    \n    // Définition de la position de tous mes objets\n    centers[0] = cornerPosition + vec3(-6.0,-3.0,-4.3);  \n   \n    centers[PL_IND] = vec3(0.0,0.0,3.4);\n    centers[PL_IND+1] = vec3(-505.0,-495.0,2.65);\n    centers[PL_IND+2] = vec3(4.2,-495.0,6.473);\n    centers[PL_IND+3] = vec3(-505.,14.2,6.473);\n    centers[PL_IND+4] = vec3(-3.4,6.4,13.68);\n    centers[PL_IND+5] = vec3(-1000,0,1000);\n   \n   \n   \n    centers[CL_IND] = cornerPosition + vec3(-6.0,-3.0,0.2);\n    centers[CL_IND + 1 ] = centers[CL_IND] + vec3(2.0,-6.0,-0.5);\n   \n    centers[TR_IND] = centers[PL_IND] + vec3(0,0,-0.5 + sin(a*0.2)/6.0);\n    \n    vec3 lanternPosition = cornerPosition + vec3(-4.5,-4.5,0.0);\n    \n    centers[1] = lanternPosition + vec3(0,0,-0.375); //Flame\n    centers[2] = lanternPosition + vec3(0,0,-0.75-0.15); // Handle\n    \n    centers[TR_IND + 1] = lanternPosition + vec3(0.25,0.0,-0.375);  \n    centers[TR_IND + 2] = lanternPosition + vec3(0.0,0.25,-0.375);\n    centers[TR_IND + 3] = lanternPosition + vec3(0.0,-0.25,-0.375);\n    centers[TR_IND + 4] = lanternPosition + vec3(-0.25,0.0,-0.375);\n    centers[TR_IND + 5] = lanternPosition + vec3(0.0,0.0,-0.75); // top \n    centers[TR_IND + 6] = lanternPosition + vec3(0.0,0.0,-0.005); // Bottom\n    \n    float circleRadius = 1.4;\n    float sp = 0.37;\n    vec3 fireflyPosition = centers[CL_IND+1] + vec3(0,0,-1.65);\n    float circleX = centers[CL_IND+1].x + circleRadius * cos(a/5.0) + 0.33*(sin(2.5*a*sp) + 0.67*sin(7.8*a*sp) + 0.33*sin(18.0*a*sp) + sin(5.4*a*sp));\n    float circleY = centers[CL_IND+1].y + circleRadius * sin(a/5.0) + 0.33*(sin(2.5*(a+3.0)*sp) + 0.67*sin(7.8*(a+3.0)*sp) + 0.33*sin(18.0*(a+3.0)*sp) + sin(5.4*(a+3.0)*sp));\n    float circleZ = centers[CL_IND+1].z -1.65 + 0.33*0.5*(sin((a-3.0)*sp) + 0.67*sin(7.8*(a-3.0)*sp) + 0.33*sin(18.0*(a-3.0)*sp) + sin(5.4*(a-3.0)*sp)); \n    fireflyPosition = vec3(circleX, circleY, circleZ);\n    centers[3] = fireflyPosition;\n    centers[TR_IND + 7] = fireflyPosition;\n    centers[TR_IND + 8] = fireflyPosition; //wings\n    \n    \n   \n   lights[0].Pos = lanternPosition + vec3(0,0,-0.375);\n   lights[0].Color = vec3(247, 188, 87)/255.0;\n   lights[0].Intensity = 2.5*(2.0 + 0.33*(sin(5.0*a) + sin(8.0*a) +0.5*sin(13.0*a)));\n   lights[0].bypassIntensity = 0.0;\n   lights[0].diffusion = 50.0;\n   lights[0].attCon = 1.0;\n   lights[0].attLin = 0.03;\n   lights[0].attExp = 0.002;\n   \n   lights[1].Pos = vec3(100,-5,-16)/4.0;\n   lights[1].Color =vec3(242, 211, 157)/255.0;// vec3(222, 184, 89)/255.0;\n   lights[1].Intensity = 50000000.0;\n   lights[1].bypassIntensity = 1.0;\n   lights[1].maxtheta = 60.0;\n   lights[1].minIntensity = 0.8;\n   lights[1].attCon = 1.0;\n   lights[1].attLin = 0.3;\n   lights[1].attExp = 2.0;\n   \n   float speed = 3.0;\n   \n   lights[2].Pos = fireflyPosition + vec3(0,0,0.125);\n   lights[2].Color = vec3(247, 233, 161)/255.0*(1.0 + max(0.0,0.2*(sin(5.0*a/speed) + sin(8.0*a/speed) +0.5*sin(13.0*a/speed))));\n   lights[2].Intensity = 0.34;\n   lights[2].diffusion = 50.0;\n   lights[2].attCon = 1.0;\n   lights[2].attLin = 0.03;\n   lights[2].attExp = 0.002;\n\n   \n   \n   vec2 uv = fragCoord / iResolution.xy;\n   vec3 bgColor1 = vec3(4, 44, 89)/255.0;\n   vec3 bgColor2 = vec3(250, 175, 82)/255.0;\n   vec3 bgColor = mix(bgColor2, bgColor1, uv.y);\n   fragColor = vec4(bgColor,1);//vec4(centralPixelColor,1);\n   \n   float last_cloudy = 999999.0;\n   float accumulated_alpha = 1.0;\n   vec3 transparent_coloring = vec3(0,0,0);\n   \n   Ray R = launch(C, fragCoord);\n   bool force_render;\n   \n   \n   // Test des collisions entre les rayons de la caméra et les objets de la scène\n   for(int i = 0; i < OBJECTS_COUNT; i++) {\n       float t = 0.0;\n       bool intersect = false;\n       bool itself = false;\n       Object O;\n       if (i < SP_COUNT) {\n           O = next_object(0,i);\n           intersect =  (intersect_sphere(R,O, t,O.is_light));\n       } else if (i < SP_COUNT + PL_COUNT) {\n             O = next_object(1,i-SP_COUNT);\n             vec2 loc = vec2(0,0);\n             intersect = (intersect_plan(R,O,t,loc));\n       } else if (i < SP_COUNT + PL_COUNT + CL_COUNT) {\n            O = next_object(2,i-SP_COUNT-PL_COUNT);\n            vec3 f = vec3(0,0,0);\n            intersect =  (intersect_cylinder(R,O,t,f));\n            itself = true;\n\n       } else if (i <SP_COUNT + PL_COUNT + CL_COUNT + TR_COUNT) {\n           O = next_object(3,i-SP_COUNT-PL_COUNT-CL_COUNT);\n           vec2 loc = vec2(0,0);\n           intersect = (intersect_plan(R,O,t,loc));\n       }\n       \n       if (intersect) {\n           if (t>0.0 && t< last_cloudy) {\n                   vec3 o_color = vec3(0,0,0);\n                   force_render = O.force_render;\n                   // calcul de la couleur de l'objet après application des lumières\n                    for (int j = 0; j < LIGHTS_COUNT; j++){\n                           o_color += apply_light(R,O, lights[j], t, i, itself);\n\n                    }\n                    if (O.opacity == 1.0) { // Objets opaques\n                       last_cloudy = t;\n                       accumulated_alpha = 1.0;\n                       transparent_coloring = vec3(0,0,0);\n                       fragColor = vec4(o_color,1);\n                    \n                   } else { //Gestion de la transparence\n                       float modifier = 1.0;\n                       if(force_render) {modifier = 2.0;}\n                       if(t > RENDER_DISTANCE) { // Fog\n                           O.opacity *= min(1.0/modifier,50.0/(t-RENDER_DISTANCE));\n                           O.opacity = max(O.opacity,0.0);\n                       }\n                       transparent_coloring += o_color*O.opacity*accumulated_alpha;\n                       accumulated_alpha *= (1.0 - O.opacity);\n                   }\n                   if (O.is_light) { // cas des objets-lumières\n                       fragColor = vec4(O.Color,1);\n                   }\n             }\n       }\n   }\n   //Fog\n   if (last_cloudy > RENDER_DISTANCE) {\n       float modifier = 1.0;\n       if(force_render) {modifier = 2.0;}\n       bgColor = mix(fragColor.xyz,bgColor,min(1.0/modifier,(last_cloudy-RENDER_DISTANCE) / 50.0));\n       fragColor = vec4(bgColor,1.0);\n   }\n   fragColor = vec4(fragColor.xyz*(accumulated_alpha) + transparent_coloring, 1);\n   \n   \n}\n","name":"Image","description":"","type":"image"}]}