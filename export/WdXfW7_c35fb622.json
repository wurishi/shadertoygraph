{"ver":"0.1","info":{"id":"WdXfW7","date":"1588327945","viewed":284,"name":"[TWITCH] Isometric Cages","username":"Flopine","description":"My first isometric doodle with raymarching! It's so much fun :D \nDid it during a live session on twitch you can re-watch here: https://www.twitch.tv/flopine","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","isometric","twitch","orthographicprojection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// References used for this isometric shader:\n// https://en.wikipedia.org/wiki/Isometric_projection\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define time iTime\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p= abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat sc(vec3 p, float s) \n{\n    vec3 pp = p;\n    p = abs(p);\n    p = max(p, p.yzx);\n    float d = min(p.x, min(p.y, p.z)) - s;\n    return d;\n    return max(d,-(abs(pp.x)-0.2));\n}\n\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat g1=0.;\nfloat SDF (vec3 p)\n{\n    float dt = ((2.*PI)/4.)*(floor(time) + (pow(fract(time)+1., 6.)-1.)*exp(-15.*fract(time)));\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(TAU/8.);\n\n    float per = 10.;\n    p.xz = mod(p.xz, per)-per*.5;\n    mo(p.xz, vec2(1.5, 2.));\n    p.x -= 1.;\n    mo(p.yz, vec2(1.));\n    p.z += 1.;\n    mo(p.xy, vec2(0.8));\n    p.x -= 0.5;\n    p.xz += vec2(cos(dt),sin(dt));\n    float d = od(p,0.5);\n    g1 += 0.01/(0.01+d*d);\n    return stmin(od(p, 0.5),max(-sc(p,0.85),box (p, vec3(1.))), 0.5, 4.);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2 (0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvec3 rm (inout bool hit, inout vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.); \n    float shad=0., d=0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        p += d*rd;\n    }\n    if (hit)\n    {\n        col = vec3(0.4,0.5,0.6);\n        col *= (1.-shad);\n    }\n    return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    bool hit =  false;\n    \n\t// Isometric definition of camera, thanks to moringox! <3\n    vec3 ro = vec3(uv*10.,-50.),\n        rd = normalize(vec3(0.,0.,1.)),\n        p = ro;\n    vec3 col = rm(hit,p,ro,rd);\n    vec3 n = getnorm(p);\n    \n    if (hit)\n    {\n        p += 0.01*n;\n        float fre = pow(clamp(dot(-rd,n),0.,1.),2.);\n        col += rm(hit,p,ro,reflect(rd,n))*fre;\n    }\n    col += g1*vec3(0.8,0.1,0.01)*0.05;\n\n    fragColor = vec4(clamp(sqrt(col),0.,1.),1.);\n}","name":"Image","description":"","type":"image"}]}