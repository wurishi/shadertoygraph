{"ver":"0.1","info":{"id":"XsKyW1","date":"1521839761","viewed":107,"name":"Wheels_Anvoker","username":"Anvoker","description":"Tiling rotating wheels","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["beginner","circle","wheel","rotating","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Setup=========\nconst int n = 12;\nconst float rotSpeed = 0.5;\nconst float circleBorder = 0.8;\nconst float lineBorder = 0.0025;\nconst vec3 backCol = vec3(0.0, 0.0, 0.0);\nconst vec3 lineCol = vec3(0.0, 0.75, 0.0);\nconst vec3 circCol = vec3(0.75, 0.0, 1.0);\n//==============\n\nconst float nf = float(n);\nconst float r = 1.0 / float(n * 2);\nconst float lengthLine = r * 0.9;\nconst float rSqr = r * r;\nconst float rSqr2 = rSqr * circleBorder;\n\n#define M_PI 3.141593\n\nvec3 drawCircles(in vec2 uv)\n{\n    vec3 col = backCol;\n    \n    // Time based radius\n    float rtime = abs(cos(iTime * rotSpeed)) * rSqr;\n    float rtime2 = abs(cos(iTime * rotSpeed)) * rSqr2;\n    \n    // Shift the coordinate system by the radius\n    // Otherwise everything is drawn in the bottom left corner instead of the center of the circle\n    uv.x = uv.x - r;\n    uv.y = uv.y - r;\n    \n    // Get the x coord of center of the circle closest to our current coord\n    float i = round(uv.x * nf);\n    float a = i / nf;\n    \n    // Get the y coord of center of the circle closest to our current coord\n    float j = round(uv.y * nf);\n    float b = j / nf;\n    \n    // Circle Equation\n    float ax = uv.x - a;\n    float by = uv.y - b;\n    float circle = by * by + ax * ax;\n    \n    //Line Coords\n    float x = ax;\n    float y = by;\n    \n    //Controls the rotational offset of the lines\n    float iTime2 = iTime + M_PI / 2.0;\n    float iTime3 = iTime + M_PI / 4.0;\n    float iTime4 = iTime - M_PI / 4.0;\n    \n    //Line Equations\n    float lineEq1 =   sin(iTime) * x - cos(iTime) * y\n                    + cos(iTime) * x + sin(iTime) * y;\n    \n    float lineEq2 =   sin(iTime2) * x - cos(iTime2) * y\n                    + cos(iTime2) * x + sin(iTime2) * y;\n    \n    float lineEq3 =   sin(iTime3) * x - cos(iTime3) * y\n                    + cos(iTime3) * x + sin(iTime3) * y;\n    \n    float lineEq4 =   sin(iTime4) * x - cos(iTime4) * y\n                    + cos(iTime4) * x + sin(iTime4) * y;\n\n    // Circle color\n    col += circCol * max(sign(rtime - circle ), 0.0) \n                   * max(sign(circle - rtime2), 0.0);\n\n    // Line Color\n    col += lineCol * max(sign(rtime2 - circle), 0.0) \n        *  (  max(sign(lineBorder - abs(lineEq1)), 0.0)\n           +  max(sign(lineBorder - abs(lineEq2)), 0.0)\n           +  max(sign(lineBorder - abs(lineEq3)), 0.0)\n           +  max(sign(lineBorder - abs(lineEq4)), 0.0));\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = drawCircles(uv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}