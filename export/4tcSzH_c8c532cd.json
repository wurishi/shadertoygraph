{"ver":"0.1","info":{"id":"4tcSzH","date":"1478011490","viewed":722,"name":"Terraced Hills Gradient","username":"ttoinou","description":"Original by Shane : https://www.shadertoy.com/view/MtdSRn \nContinuous Gradient : https://www.shadertoy.com/view/XtK3Dd","likes":15,"published":1,"flags":96,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DX iMouse.x/iResolution.x\n#define DY iMouse.y/iResolution.y\n\n#define PI (3.14159265359)\n#define TWOPI (3.14159265359*2.0)\n#define temporalSpeed 6.0\n\n#define to01(x) clamp(x,0.0,1.0)\n\n#define sound iChannel0\nvec4 fft(float freq){\n    return texture(sound,vec2(freq,0.));\n}\n\nvec4 fft(float freq,float time){\n    return texture(sound,vec2(freq,time));\n}\n\n// continuous gradient\n// https://www.shadertoy.com/view/XtK3Dd\n#define BORDERRADIUS (8)\n#define GAMMA        (1.)\n#define PI           (3.14159265359)\n#define LUMWEIGHT    (vec3(0.2126,0.7152,0.0722))\n#define pow3(x,y)    (pow( max(x,0.) , vec3(y) ))\n#define gradientInput iChannel1\n\n#define BORDERRADIUSf float(BORDERRADIUS)\n#define BORDERRADIUS22f float(BORDERRADIUS*BORDERRADIUS)\n\n// https://www.shadertoy.com/view/MsS3Wc\n// HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 viewport(vec2 p)\n{   \n    return p/(iResolution.xy);\n}\n\nvec3 sampleGradientInput(vec2 coord){\n   return pow3(texture(gradientInput,viewport(coord)).rgb,GAMMA);\n}\n\nfloat gradientKernel(int a,int b){\n    return float(a)*exp(-float(a*a + b*b)/BORDERRADIUS22f)/BORDERRADIUSf;\n}\n\nvoid gradient( in vec2 fragCoord , out vec3 colX , out vec3 colY )\n{\n    vec3 col;\n    colX = vec3(0.);\n    colY = vec3(0.);\n    \n    for( int i = -BORDERRADIUS ; i <= BORDERRADIUS ; i++ ){\n    \tfor( int j = -BORDERRADIUS ; j <= BORDERRADIUS ; j++ ){\n            col = sampleGradientInput(fragCoord.xy+vec2(i,j));\n            colX += gradientKernel(i,j)*col;\n            colY += gradientKernel(j,i)*col;\n        }\n        \n    }\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel1,uv);\n    vec3 colX,colY;\n    gradient(fragCoord,colX,colY);\n\n\n    vec3 derivative = sqrt( (colX*colX + colY*colY) )/(BORDERRADIUSf*BORDERRADIUSf);\n    float angle = atan(dot(colY,LUMWEIGHT),dot(colX,LUMWEIGHT))/(2.*PI);\n    vec3 derivativeWithAngle = hsv2rgb_smooth(vec3(\n        (floor(angle*4.)/4.)* (fft(0.05).g*0.4) + fft(0.4).r*0.3\n        ,0.8\n        ,pow(dot(derivative,LUMWEIGHT)*3.,3.)*3.*(1. - fft(0.8).g)\n    ));\n    \n    fragColor.rgb = mix(derivative,fragColor.rgb,0.4);\n        \n    fragColor.rgb += derivativeWithAngle;\n    fragColor.rgb = pow3(fragColor.rgb,1./GAMMA);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsB3WR","filepath":"https://soundcloud.com/guts/back-to-the-streets","previewfilepath":"https://soundcloud.com/guts/back-to-the-streets","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/XtVGDz\n\n#define buffer iChannel0\n#define sound  iChannel1\n#define soundRes iChannelResolution[1]\n#define step 1.0/iResolution.y\n\n// fft Options\n#define inputSound iChannel0\n#define fftWidth \t\t1.0\t\t\t// width of fft texture (why not 512.0 ?! )\n\n#define fftSmooth \t\t1.3\t\t\t// smoothness coeff\n#define fftPreamp\t\t0.65\t\t// pre amp before dynamic\n#define fftBoost  \t\t0.14\t\t// dynamic amp\n#define fftAmp\t\t\t0.7\t\t\t// pre amp before dynamic\n#define fftMinBass \t\t0.00196 \t// 1.0/512.0\n#define noiseLevel      0.05\n\n#define fftRadiusR\t\t8.0/512.0\n#define fftRadiusG\t\t8.0/512.0*4.0\n#define fftRadiusB\t\t8.0/512.0*4.0*4.0\n#define fftSamplesR \t8 // number of iteration for fft sampling, increases quality !\n#define fftSamplesG \t8*4\n#define fftSamplesB \t8*4*4\n#define fftGBGain       1.1\n\n#define to01(x) clamp(x,0.0,1.0)\n\nfloat remapIntensity(float f, float i){\n  // noise level\n  i = to01( (i - noiseLevel) / (1.0 - noiseLevel) );\n  float k = f-1.0;\n  // preamp, x2 for trebles -> x1 for bass\n  //i *= ( 2.0 - 1.0*k*k ) * fftPreamp;\n  //i *= ( 3.0 - 1.5*k*k ) * fftPreamp;\n  i *= ( 3.0 - 1.6*k*k ) * fftPreamp;\n  // more dynamic\n  i *= (i+fftBoost);\n  // limiter\n  return i*fftAmp;\n  // limiter, kills dynamic when too loud\n  //return 1.0 - 1.0 / ( i*4.0 + 1.0 );\n}\n\nfloat remapFreq(float freq){\n // linear scale\n //return clamp(freq,fftMinBass,1.0);\n // log scale\n return clamp(to01(- log(1.0-freq/2.0 + fftMinBass*8.0)),fftMinBass,1.0);\n}\n\nfloat fftR(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesR ; i++ ){\n        k = float(i)/float(fftSamplesR-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusR)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum);\n}\n\nfloat fftG(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesG ; i++ ){\n        k = float(i)/float(fftSamplesG-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusG)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain;\n}\n\nfloat fftB(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesB ; i++ ){\n        k = float(i)/float(fftSamplesB-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusB)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain*fftGBGain;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n   \t// black by default\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    float k = texture( iChannel2, vec2(82.5/256.0,0.0) ).x;\n\n     // key R => Reset\n    if( abs(k) < 0.1 ){\n        // store current fft\n        if( fragCoord.y <= 1.0 ){\n            \n            float freq = uv.x;\n            float i1,i2,i3;\n\n            i1 = fftR(freq);\n            i2 = fftG(freq);\n            i3 = fftB(freq);\n\n            fragColor = vec4(i1,i2,i3,1.0);\n            \n        // store previous fft\n        } else if( fragCoord.y < iResolution.y - 1.0 ) {\n            fragColor=texture(buffer,vec2(uv.x,uv.y - step));\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define dx (iMouse.x/iResolution.x)\n#define dy (iMouse.y/iResolution.y)\n\n#define sound iChannel0\nvec4 fft(float freq){\n    return texture(sound,vec2(freq,.0));\n}\n\nvec4 fft(float freq,float time){\n    return texture(sound,vec2(freq,time));\n}\n\n// https://www.shadertoy.com/view/MtdSRn\n\n/*\n\n\tTerraced Hills\n\t--------------\n\n    This is an abstract representation of the terraced hills you see throughout various parts \n\tof the world. In essence, it's just a very basic terrain layout with some edging.\n\n\tI wanted to make something nice and simple. The code is reasonably compact, but without \n\tsacrificing too much in the way of efficiency or readability.\n\n*/\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool.\nfloat tri(in float x){return abs(x-floor(x)-.5);} // Triangle function.\n//vec2 tri(in vec2 x){return abs(x-floor(x)-.5);} // Triangle function.\nvec2 tri(in vec2 x){return cos(x*6.2831853)*0.25+0.25;} // Smooth version. Not used here.\n\n// A simple noisey layer made up of a sawtooth combination.\nfloat hLyr(vec2 p) { return dot(tri(p/1.5 + tri(p.yx/3. + .25)), vec2(1)); }\n\n\n// I've mentioned this before, but you can make some pretty interesting surfaces simply by \n// combining mutations of a rudimentary functional layer. Take the base layer, then rotate, change\n// frequency, amplitude, etc, and combine it with the previous layer. Continue ad infinitum...\n// or until your GPU makes you stop. :)\nfloat hMap(vec2 p) {\n    \n    float ret = 0., a = 1.;\n\n    // Combining three layers of the function above.\n    for(int i=0; i<3; i++) {\n        ret += abs(a)*hLyr(p/a); // Add a portion of the layer to the final result.\n        //p = rot2(1.5707963/3.)*p;\n        p = mat2(.866025, .5, -.5, .866025)*p; // Rotate the layer.\n        a *= -0.3; // Multiplying the amplitude by a negative for an interesting variation.     \n    }\n\n    // Squaring and smoothing the result for some peakier peaks. Not mandatory.\n    ret = smoothstep(-.2, 1.6 - fft(0.5).r, ret*ret/1.39/1.39);\n    \n    \n    // The last term adds some ridges. Basically, you take the result then blend in a \n    // small periodic portion of it... The code explains it better. \n    \n    return ret*.975 + tri(ret*12.)*(.1 * fft(0.1).b); // Range: [0, 1].. but I'd double check. :)\n    //return ret*.99 + clamp(cos((ret)*6.283*24.)*.5+.5, 0., 1.)*.01; // Another way.\n\n\n}\n\n// Distance function. A flat plane perturbed by a height function of some kind.\nfloat map(vec3 p) { return (p.y - hMap(p.xz)*.35)*.75; }\n\n\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so am saving a few map calls.\n// I've added to the function to include a rough tetrahedral edge calculation.\nvec3 normal(in vec3 p, inout float edge){\n  \n    // Edging thickness. I wanted the edges to be resolution independent... or to put it\n    // another way, I wanted the lines to be a certain pixel width regardless of the \n    // canvas size. If you don't, then the lines can look to fat in fullscreen.\n    vec2 e = vec2(-1., 1.)*.5/iResolution.y;  \n    \n    // The hit point value, and four nearby samples, spaced out in a tetrahedral fashion.\n\tfloat d1 = map(p + e.yxx), d2 = map(p + e.xxy);\n\tfloat d3 = map(p + e.xyx), d4 = map(p + e.yyy); \n    float d = map(p);\n    \n    // Edge calculation. Taking for samples around the hit point and determining how\n    // much they vary. Large variances tend to indicate an edge.\n    edge = abs(d1 + d2 + d3 + d4 - d*4.);\n    edge = smoothstep(0., 1., sqrt(edge/e.y*2.));\n    \n    // Recalculating for the normal. I didn't want the sample spacing to change from\n    // one resolution to the next. Hence, the fixed number. Just for the record, I tend\n    // to work within the 800 by 450 window. \n    e = vec2(-1., 1.)*.001;  \n\td1 = map(p + e.yxx), d2 = map(p + e.xxy);\n\td3 = map(p + e.xyx), d4 = map(p + e.yyy); \n    \n    // Normalizing.\n\treturn normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );   \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\t{\n\t\n\n    // Unit direction ray.\n\tvec3 rd = normalize(vec3(fragCoord.xy - iResolution.y*.5, iResolution.y));\n    \n    // Orienting to face a particular direction.\n    rd.yz = rot2(0.4*fft(0.2).b)*rd.yz;\n    \n    // Camera point - Placed above the plane and moving along the XZ plane. \n    vec3 ro = vec3(iTime*.4, .5, iTime*.2);\n    \n    // Basic raymarching.\t\n\tfloat t=0., d;\n\tfor(int i=0; i<96; i++) {\n        \n\t\td = map(ro + rd*t); // Closest distane to current ray point.\n        \n        // Break condition - Surface hit, or too far.\n        if(abs(d)<.001*(t*.125 + 1.) || t>20.) break; \n\n        // Advancing the ray - Using a bit more accuracy nearer the camera.\n        t += (step(1., t)*.3 + .7)*d;\n\t}\n    \n    // Hit point. Note that about a quarter of the screen hits the curved far plane (sky),\n    // so a few cycles are wasted, but there's no nested code block, which looks a bit\n    // neater... I wouldn't do this for more sophisticated examples, but it's OK here.\n    vec3 sp = ro + rd*t;\n    \n    // Applying direct lighting. It's simpler, but it's more of an aesthetic choice for this\n    // particular example.\n    vec3 ld = vec3(-0.676, 0.408, 0.613); // Normalized, or pretty close.\n    \n\n    // Normal and edge value.\n    float edge;\n    vec3 n = normal(sp, edge);\n    \n    float dif = max(dot(ld, n), 0.); // Diffuse.\n    float spe = pow(max(dot(reflect(rd, n), ld), 0.), 16.); // specular.\n\n    float sh = hMap(sp.xz); // Using the height map to enhance the peaks and troughs.\n    \n    // A bit of random, blocky sprinkling for the hills. Cheap, bit it'll do.\n    float rnd = fract(sin(dot(floor(sp.xz*512.), vec2(41.73, 289.67)))*43758.5453)*.5 + .5;\n\n    // The fog. Since the foreground color is pretty bland, I've made it really colorful. I've gone\n    // for the sunset cliche... or misty morning sunrise, if you prefer. :)\n    vec3 fog = mix(vec3(.75,.77, .78), vec3(1.04, .95, .87), (pow(1.0 + dot(rd, ld), 3.))*.35);\n   \n    // Using the values above to produce the final color, then mixing in some fog according to distance.\n    vec3 c = mix((vec3(1.1, 1.05, 1)*rnd*(dif + .1)*sh + fog*spe)*(1. - edge*.7), fog*fog, min(1., t*.3));\n\n    // No gamma correction. If you wanted, you could think of it as postprocessing the final\n    // color and gamma correction rolled into one. :)\n    fragColor = vec4(c, 1);\n}\n","name":"Buf B","description":"","type":"buffer"}]}