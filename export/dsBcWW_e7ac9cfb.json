{"ver":"0.1","info":{"id":"dsBcWW","date":"1688771907","viewed":143,"name":"OpenAI Logo","username":"TheTurk","description":"OpenAI logo constructed just from line segments and circular arcs ([url]https://www.shadertoy.com/playlist/scBBRD[/url]).","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","line","lines","logo","arc","arcs","ai","artificial","overlords","openai","welcome","gpt","chatgpt","intelligence","paperclip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float line(vec2 position, inout vec2 currentPoint, vec2 end) {\n    vec2 p = position - currentPoint;\n    vec2 e = end - currentPoint;\n    float h = clamp(dot(p, e) / dot(e, e), 0.0, 1.0);\n    float d = length(p - e * h);\n    float s = 1.0;\n    // even-odd rule\n    if ((p.y > 0.0) != (p.y > e.y)) {\n        if ((e.y * p.x < e.x * p.y) != (e.y < 0.0)) {\n            s = -s;\n        } \n    }\n    currentPoint = end;\n    return d * s;\n}\n\nfloat arc(vec2 position, inout vec2 currentPoint, vec2 tangent1End, vec2 tangent2End, float radius) {    \n    vec2 p = position - tangent1End;\n    vec2 a = normalize(currentPoint - tangent1End);\n    vec2 b = normalize(tangent2End - tangent1End);\n    vec2 center = (a + b) * radius / abs(a.x * b.y - a.y * b.x);\n    vec2 start = tangent1End + a * dot(center, a);\n    vec2 end = tangent1End + b * dot(center, b);\n    p -= center;\n    // even-odd rule\n    float s = 1.0;\n    float c = radius * radius - p.y * p.y;\n    if (c > 0.0) {\n        c = sqrt(c);\n        vec2 p1 = vec2(-c, p.y); \n        vec2 p2 = vec2(c, p.y);\n        float s1 = dot(p1, a);\n        float s2 = dot(p1, b);\n        float s3 = dot(p2, a);\n        float s4 = dot(p2, b);\n        if (p.x < p1.x && s1 < 0.0 && s2 < 0.0) {\n            s = -s;\n        }\n        if (p.x < p2.x && s4 < 0.0 && s3 < 0.0) {\n            s = -s;\n        }\n    } \n    vec2 e = start - currentPoint;\n    vec2 q = position - currentPoint;    \n    if ((q.y > 0.0) != (q.y > e.y)) {\n        if ((e.y * q.x < e.x * q.y) != (e.y < 0.0)) {\n            s = -s;\n        } \n    }\n    currentPoint = end;\n    float s1 = dot(p, a);\n    float s2 = dot(p, b);\n    if (s1 < 0.0 && s2 < 0.0) {\n        return abs(length(p) - radius) * s;\n    }\n    vec2 d1 = q - e * clamp(dot(q, e) / dot(e, e), 0.0, 1.0);\n    vec2 d2 = position - end;\n    return sqrt(min(dot(d1, d1), dot(d2, d2))) * s;\n}\n\nfloat arc(vec2 position, float radius, vec2 a, vec2 b) {\n    vec2 start = a * radius;\n    vec2 end = b * radius;\n    bool m = a.x * b.y < a.y * b.x;\n    // even-odd rule\n    float s = 1.0;\n    float c = radius * radius - position.y * position.y;\n    if (c > 0.0) {\n        c = sqrt(c);\n        bool s1 = -c * a.y < position.y * a.x;\n        bool s2 = -c * b.y < position.y * b.x;\n        bool s3 = c * a.y < position.y * a.x;\n        bool s4 = c * b.y < position.y * b.x;\n        if (position.x < -c && (s1 != m && s2 == m) == m) {\n            s = -s;\n        }\n        if (position.x < c && (s3 != m && s4 == m) == m) {\n            s = -s;\n        }\n    }\n    bool s1 = position.x * a.y < position.y * a.x;\n    bool s2 = position.x * b.y < position.y * b.x;\n    if ((s1 != m && s2 == m) == m) {  \n        return abs(length(position) - radius) * s;\n    }\n    vec2 d1 = position - start;\n    vec2 d2 = position - end;\n    return sqrt(min(dot(d1, d1), dot(d2, d2))) * s;\n}\n\nvec4 intersectCircleCircle(vec2 center1, float radius1, vec2 center2, float radius2) {\n    vec2 d = center2 - center1;\n    float m = length(d);\n    float a = (radius1 * radius1 - radius2 * radius2 + m * m) / (2.0 * m);\n    float h = sqrt(radius1 * radius1 - a * a);    \n    vec2 p1 = center1 + d * (a / m) - vec2(d.y, -d.x) / m * h;\n    vec2 p2 = center1 + d * (a / m) + vec2(d.y, -d.x) / m * h;\n    return vec4(p1, p2);\n}\n\nfloat logo(vec2 position) {\n    float halfThickness1 = 0.15;\n    float halfThickness2 = 0.2;\n    float a = 2.1;\n    float b = 1.6;\n    float radius = 1.47;\n    \n    vec2 center1 = vec2(-sqrt(3.0) * 0.5, 0.5) * a + vec2(radius, b - 1.0);\n    vec2 center2 = vec2(-sqrt(3.0) * 0.5, a - 0.5) + vec2(sqrt(3.0) * 0.5, 0.5) * b + vec2(0.5, -sqrt(3.0) * 0.5) * radius;\n    \n    vec2 start = intersectCircleCircle(center1, radius + halfThickness2, center2, radius + halfThickness2).xy;\n    vec2 center = center2;\n    float d1 = float(0xffffffffU);\n    float s1 = 1.0;\n    for (int i = 0; i < 6; i++) {\n        vec2 end = vec2(start.x * 0.5 - start.y * -sqrt(3.0) * 0.5, start.x * -sqrt(3.0) * 0.5 + start.y * 0.5);\n        float d = arc(position - center, radius + halfThickness2, (start - center) / (radius + halfThickness2), (end - center) / (radius + halfThickness2));\n        d1 = min(d1, abs(d));\n        s1 *= sign(d);\n        start = end;\n        center = vec2(center.x * 0.5 - center.y * -sqrt(3.0) * 0.5, center.x * -sqrt(3.0) * 0.5 + center.y * 0.5);\n    }\n    \n    start = vec2(0.0, halfThickness1 / (sqrt(3.0) * 0.5) - 1.0);\n    float d2 = float(0xffffffffU);\n    float s2 = 1.0;\n    for (int i = 0; i < 6; i++) {\n        vec2 end = vec2(start.x * 0.5 - start.y * -sqrt(3.0) * 0.5, start.x * -sqrt(3.0) * 0.5 + start.y * 0.5);\n        float d = line(position, start, end);\n        d2 = min(d2, abs(d));\n        s2 *= sign(d);\n    }\n            \n    vec2 p1 = vec2(-sqrt(3.0) * 0.5 - halfThickness1, (3.0 * halfThickness1) / sqrt(3.0) - 0.5);\n    vec2 p2 = vec2(-sqrt(3.0) * 0.5 * a + halfThickness2, 0.5 * a + halfThickness1 / (sqrt(3.0) * 0.5) - halfThickness2 / sqrt(3.0) - 1.0);\n    vec2 p3 = vec2(-sqrt(3.0) * 0.5, 0.5) * a + vec2(halfThickness2, b - 1.0);\n    vec2 p4 = intersectCircleCircle(center1, radius - halfThickness2, center2, radius + halfThickness2).xy;\n    vec2 p5 = vec2(-sqrt(3.0) * 0.5, a - 0.5) + vec2(sqrt(3.0) * 0.5, 0.5) * b + vec2(-0.5, sqrt(3.0) * 0.5) * halfThickness2;\n    vec2 p6 = vec2(-sqrt(3.0) * 0.5 - halfThickness1, a + (2.0 * halfThickness2 - halfThickness1) / sqrt(3.0) - 0.5);\n    float d3 = float(0xffffffffU);\n    float s3 = 1.0;\n    for (int i = 0; i < 6; i++) {\n        vec2 p = p1;\n        float d4 = line(position, p, p2);\n        float d5 = line(position, p, p3);\n        float d6 = arc(position - center1, radius - halfThickness2, (p3 - center1) / (radius - halfThickness2), (p4 - center1) / (radius - halfThickness2)); \n        float d7 = arc(position - center2, radius + halfThickness2, (p5 - center2) / (radius + halfThickness2), (p4 - center2) / (radius + halfThickness2));\n        p = p5;\n        float d8 = arc(position, p, p6, p1, halfThickness2);\n        float d9 = line(position, p, p1);\n        d3 = min(min(min(min(min(min(d3, abs(d4)), abs(d5)), abs(d6)), abs(d7)), abs(d8)), abs(d9));\n        s3 *= sign(d4 * d5 * d6 * d7 * d8 * d9);\n        position = vec2(position.x * 0.5 - position.y * -sqrt(3.0) * 0.5, position.x * -sqrt(3.0) * 0.5 + position.y * 0.5);\n    }\n   \n    return max(max(d1 * s1, -d2 * s2), -d3 * s3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float scale = 0.23;\n    float d = logo(position / scale) * scale;\n    vec3 color = mix(vec3(1.0), vec3(0.0), 1.0 - smoothstep(0.0, 3.0, d * iResolution.y));\n    if (iMouse.z > 0.0) {\n        if (d > 0.02) {\n           float d1 = 1.0 - smoothstep(0.0, 3.0, abs((mod(d + 0.15, 0.3) - 0.15) * iResolution.y) - 2.0);\n           float d2 = 1.0 - smoothstep(0.0, 3.0, abs((mod(d + 0.03, 0.06) - 0.03) * iResolution.y) - 2.0);\n           color -= max(d1 * 0.2, d2 * 0.02);\n        }\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}