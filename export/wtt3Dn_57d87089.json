{"ver":"0.1","info":{"id":"wtt3Dn","date":"1576125722","viewed":229,"name":"Training 06 (Copo)","username":"coposuke","description":"Training","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["training"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 onepix = 1.0 / iResolution.xy;\n    vec2 uv1 = (fragCoord.xy * 2.0 - iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec2 uv2 = fragCoord / iResolution.xy;\n    \n    vec2 direction = vec2(0.0) - (uv1);\n    float power = distance(vec2(0.0), (uv1));\n    power = power * power * 10.0;\n    \n    vec3 color = texture(iChannel0, uv2).rgb;\n    float r = texture(iChannel0, uv2 + onepix * direction * power).r;\n    float g = color.g;\n    float b = texture(iChannel0, uv2 - onepix * direction * power).b;\n    color.rgb = vec3(r,g,b);\n    \n    fragColor.rgb = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI      3.14159265357989\n#define PI_2    6.28318530715978\n\nmat3 rotate(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m;\n}\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c,s,-s,c);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct geometry\n{\n    int type;\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float glare;\n};\n\nstruct info\n{\n    int type;\n    float dist;\n};\n\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nvec2 pmod(vec2 pos, float split, out float id)\n{\n    float angle = atan(pos.x, pos.y) + PI / split;\n    float n = PI_2 / split;\n    id = floor(angle / n);\n    angle = id * n;\n    return pos * rotate(-angle);\n}\n\nvec4 shot(vec3 rayPos, float pmodSplit, float idSplit, float idOffset, float time)\n{\n    const float SPEED = 10.0;\n    const float SIZE = 0.025;\n    \n    float pmodID = 0.0;\n    vec3 modPos = rayPos;\n    modPos.xz = pmod(rayPos.xz, pmodSplit, pmodID);\n    modPos.z += mod(pmodID + idOffset, idSplit) * 0.5 - fract(time) * SPEED;\n    float zmodID = (modPos.z + fract(time) * SPEED) * SIZE;\n    modPos.z = mod(modPos.z, 10.0) - 5.0;\n    \n    return vec4(modPos, zmodID);\n}\n\ninfo map(in vec3 rayPos)\n{\n    vec2 result = vec2(0, 1e+4);\n\n    vec4 modPos1 = shot(rotate(     iTime, vec3(1,0,0)) * rayPos, 10.0, 10.0, 0.0, iTime);\n    vec4 modPos2 = shot(rotate(sin(iTime), vec3(0,1,0)) * rayPos, 10.0, 10.0, 0.0, iTime + 0.5);\n    vec4 modPos3 = shot(rotate(    -iTime, vec3(0,0,1)) * rayPos, 10.0,  5.0, 0.0, iTime + 0.25);\n\n    const float SIZE = 0.5;\n    \n    result.x = 1.0;\n    result.y = length(modPos1.xyz) - SIZE + clamp(modPos1.w, 0.0, 5.5);\n    result.y = opSmoothUnion(result.y, length(modPos2.xyz) - SIZE + clamp(modPos2.w, 0.0, 5.5), 1.0);\n    result.y = opSmoothUnion(result.y, length(modPos3.xyz) - SIZE + clamp(modPos3.w, 0.0, 5.5), 1.0);\n    result.y = opSmoothUnion(result.y, length(rayPos) - 2.0 - abs(sin(iTime * 3.0)), 0.5);\n\n    return info(int(result.x), result.y);\n}\n\nvec3 computeNormal(in vec3 pos)\n{\n    const float EPSILON = 1e-4;\n    return normalize(vec3(\n        map(vec3(pos.x + EPSILON, pos.y, pos.z)).dist - map(vec3(pos.x - EPSILON, pos.y, pos.z)).dist,\n        map(vec3(pos.x, pos.y + EPSILON, pos.z)).dist - map(vec3(pos.x, pos.y - EPSILON, pos.z)).dist,\n        map(vec3(pos.x, pos.y, pos.z + EPSILON)).dist - map(vec3(pos.x, pos.y, pos.z - EPSILON)).dist\n    ));\n}\n\ngeometry raymarch(in vec3 camPos, in vec3 camRay)\n{\n    geometry result;\n    vec3 rayPos = camPos;\n    float dist = 0.0;\n\n    for(int i=0 ; i<128 ; ++i)\n    {\n        rayPos += camRay * dist;\n\n        info inf = map(rayPos);\n        dist = inf.dist;\n        result.dist += inf.dist;\n        \n        float glare = clamp(1.0 - inf.dist, 0.0, 1.0);\n        result.glare += glare * glare * glare;\n\n        if(dist < 1e-4)\n        {\n            result.type = inf.type;\n            result.position = rayPos;\n            result.normal = computeNormal(rayPos);\n            return result;\n        }\n    }\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    mat3 camMat = rotate(0.4, vec3(1,0,0));\n    vec3 camPos = camMat * vec3(0, 0, -10) + vec3(0,0,0);\n    vec3 camRay = normalize(camMat * vec3(uv, 1.0));\n    vec3 lightDir = normalize(vec3(-1, 1, -1));\n\n    geometry result = raymarch(camPos, camRay);\n\n    vec3 light = vec3(0);\n    light += float(result.type == 0) * vec3(1);\n    light += float(result.type == 1) * (1.5 - clamp(dot(-camRay, result.normal), 0.2, 1.0));\n\n    vec3 diffuse = vec3(0);\n    diffuse += float(result.type == 0) * vec3(1.0 - cos(uv.x * PI*0.25));\n    diffuse += float(result.type == 1) * vec3(1);\n    \n    vec3 glare = vec3(0);\n    glare += float(result.type == 0) * result.glare * 0.2;\n\n    fragColor = vec4(diffuse * light + glare, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}