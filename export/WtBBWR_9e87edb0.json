{"ver":"0.1","info":{"id":"WtBBWR","date":"1599231705","viewed":147,"name":"3D SDF: Round Polygonal Prism","username":"JacobC","description":"The sdf of a polygonal prism(another).\nMove camera by dragging the mouse while clicking it","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"3D SDF: Round Polygonal Prism\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n// Version 1.0 - 2020\n// Barycentric coord to get the inside of the polygon\n/*float polyPrism(in vec3 p, float n, float r, float h, float s)\n{\n    float Pi = 3.141592;\n    float d = atan(-p.z, -p.x) / Pi * .5 + .5;\n    float i = floor(d * n);\n    float j = ceil(d * n);\n    \n    n *= .5;\n    \n    vec3 a = vec3(cos(i * Pi / n), 0., sin(i * Pi / n)) * (r - s);\n    vec3 b = vec3(cos(j * Pi / n), 0., sin(j * Pi / n)) * (r - s);\n    \n    p.y = min(h - abs(p.y), 0.);\n    \n    float dAB = a.x*b.z - a.z*b.x;\n    float w1 = max((p.x*b.z - p.z*b.x) / dAB, 0.);\n    float w2 = max((a.x*p.z - a.z*p.x) / dAB, 0.);\n    \n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float l = length(pa - ba * t);\n    \n    return (w1 + w2 > 1. ? \n            l : min(l, length(p - (a * w1 + b * w2)))) - s;\n}*/\n\n// Version 2.0 - 2020\n// Instead of barycentric coord, use the sign of the dot product between \n// a 2D point and the edge to get the inside of the polygon.\n// I guess it's better than Version 1.0 above\nfloat polyPrism(in vec3 p, float n, float r, float h, float s)\n{\n    float Pi = 3.141592;\n    float d = atan(-p.z, -p.x) / Pi * .5 + .5;\n    float i = floor(d * n);\n    float j = ceil(d * n);\n    \n    n *= .5;\n    \n    vec3 a = vec3(cos(i * Pi / n), 0., sin(i * Pi / n)) * (r - s);\n    vec3 b = vec3(cos(j * Pi / n), 0., sin(j * Pi / n)) * (r - s);\n    \n    p.y = min(h - abs(p.y), 0.);\n    \n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    \n    float S = sign(dot(vec2(ba.z, -ba.x), pa.xz));\n    \n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float l = length(pa - ba * t);\n    \n    return (S > 0. ?\n        l :\n        abs(p.y)) - s;\n}\n\nvec3 scene(in vec3 p)\n{\n    float t = iTime * .5;\n    float f = p.y + 1.;\n    \n    p.yz *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    p.xy *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    \n    float pp = polyPrism(p, max(abs(floor(sin(t * .25) * 12.)), 3.), 2.5, 4., abs(sin(t) * .75) + .2);\n    \n    return vec3(min(f, pp), max(f, pp), pp < f ? 0. : 1.);\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).x;\n    return normalize(d - vec3(scene(p - e.xyy).x, scene(p - e.yxy).x, scene(p - e.yyx).x));\n}\n\n#define STEPS 99\n#define MIN_S .01\n#define MAX_S 66.\n\nvec3 marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 s = scene(o + d * t);\n        t += s.x;\n        if (s.x < MIN_S)\n            return vec3(t, s.yz);\n        if (t > MAX_S)\n            return vec3(-1.);\n    }\n    return vec3(-1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. / (c + i * l + i * i * q);\n}\n\n#define AA 2.\n#define gd vec3(.5)\n#define sk vec3(1.)\n#define Pi 3.14152\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 f_col;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n    \t\tvec2 uv = (st + n - iResolution.xy * .5) / iResolution.y;\n\t\t\tvec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n            \n            vec3 o = vec3(0., 8., 16.);\n            if (iMouse.z > 0.)\n            \to = vec3(cos(ms.x * Pi), max(ms.y, .05), sin(ms.x * Pi)) * 16.;\n            vec3 d = camera(uv, o, vec3(0.));\n            \n            vec3 bg = mix(gd, sk, d.y * .5 + .5);\n    \t\tvec3 col = vec3(0.);\n            \n            vec3 m = marcher(o, d);\n            if (m.z != -1.)\n            {\n                vec3 p = o + d * m.x;\n                vec3 n = normal(p);\n                bg = mix(gd, sk, n.y * .5 + .5);\n                \n                if (m.z >= 1.)\n                {\n                    float s = m.y;\n                    \n                    col += mix(vec3(1.), vec3(.0, 1., .5), map(s, 1., .01, .025));\n                    col *= mix(vec3(1.), vec3(.5, .85, .25), map(s-5., 1., .01, .025));\n                    col *= mix(vec3(1.), vec3(1., 1., .0), map(s-10., 1., .01, .025));\n                    \n                    float f = abs(fract(s * map(m.x, 1., .0007, .00035)) - .5);\n                    f = smoothstep(.0, .05, f - .05);\n\n                \tcol *= clamp(mix(f+1., f, map(m.x * s * .05, 1., .05, .01)), 0., 1.);\n                }\n                else\n                    col += bg;\n                col *= 1. - map(m.y, 1., .7, 2.);\n                \n            }\n            else\n                col += .9;\n            f_col += col;\n        }\n    }\n    \n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col), 1.);\n}","name":"Image","description":"","type":"image"}]}