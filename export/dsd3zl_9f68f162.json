{"ver":"0.1","info":{"id":"dsd3zl","date":"1677769215","viewed":107,"name":"Texture noise vs Procedural","username":"ianertson","description":"Just comparing texture noise with procedural noise in a ray-marched scene.\nTexture noise is a lot less appealing, however; it's faster than procedural noise.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","test","noise","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\nJust comparing texture noise with procedural noise in a ray-marched scene.\nTexture noise is a lot less appealing, however; it's faster than procedural noise.\n\nThere are some solutions to make it more appealing, for example increasing the radius when\nestimating the normals.\n\nAnother solution is to do something that I did here:\nhttps://www.shadertoy.com/view/mljSzK\n\nwhere I do blending between corners.\n\nHowever, there are some other problems with texture noise.\nFor example, it will usually break apart when the UV coordinates grows too big.\n\nI wish there was a built-in really fast noise function in GLSL that produces the kind of noise\nyou see to the right.\n\n( The procedural noise implementation is in the \"Common\" tab btw. )\n*/\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\nfloat textureNoise(in vec2 p, in float seed) {\n    return textureLod(iChannel3, (p+(seed*1.08277273123))/256., 0.0).r;\n}\n\nfloat textureNoise(in vec2 p, in float seed, in float freq, in int levels) {\n    float amp = 1.0;\n    float div = 0.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * textureNoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n/ div;\n}\n\nfloat sdf(in vec3 p) {\n    float n1 = 0.0;\n    float n2 = 0.0;\n    \n    if (p.x > 0.) {\n        n1 = noise(p.xz, 0.2931823, 0.05, 6);\n        n2 = noise(p.xz, 0.9231755, 0.1, 3);\n    } else {\n        n1 = textureNoise(p.xz, 0.2931823, 0.05, 6);\n        n2 = textureNoise(p.xz, 0.9231755, 0.1, 3);\n    }\n    float h = 0.0;\n    h += n1*10.;\n    h -= n2*4.;\n\n    return p.y - h;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        float next = sdf(ro+rd*d);\n        d += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(p) - vec3(\n        sdf(p - e.xyy),\n        sdf(p - e.yxy),\n        sdf(p - e.yyx)\n    ));\n    \n    data.p = p;\n    data.n = n;\n    data.d = d;\n    \n    return true;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0, 0., -1.);\n    vec3 rd = normalize(vec3(uv.xy,1.0));\n    \n    if (m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    }\n    \n    ro.y += 10.;\n    \n    Data data = NEW_DATA;\n    \n    if (march(data, ro, rd)) {\n        vec3 L = normalize(vec3(1, 2, -3.));\n        vec3 n = data.n;\n        float NdotL = cdot(n, L);\n        col += NdotL;\n    }\n    \n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR)\n\nfloat hash(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    p ^= (p << 17U);\n    s ^= (~p.x << ~p.y);\n    p ^= (p >> 7U);\n    p ^= (p << 5U);\n    s ^= (p.x ^ p.y) ^ s >> 3U;\n    p ^= (s >> 3U);\n    uint n = ((p.x*s+p.y) << (p.x ^ p.y)) + (p.x+p.y);\n    return float(n*5003U) / float(0xFFFFFFFFU);\n}\n\nfloat hash(in vec3 ip, in float seed) {\n    uvec3 p = uvec3(floatBitsToUint(ip.x), floatBitsToUint(ip.y), floatBitsToUint(ip.z));\n    uint s = floatBitsToUint(seed);\n    p ^= (p << 17U);\n    s ^= (~p.x << ~p.y) << ~p.z;\n    p ^= (p >> 7U);\n    p ^= (p << 5U);\n    s ^= (p.x ^ p.y ^ p.z) ^ s >> 3U;\n    p ^= (s >> 3U);\n    uint n = ((p.x*s+p.y*p.z) << ((p.x ^ p.y) << p.z)) + (p.x+p.y+p.z);\n    return float(n*5003U) / float(0xFFFFFFFFU);\n}\n\nfloat noise(in vec2 ip, in float seed) {\n    ip += seed+0.2092391233;\n    vec2 id = floor(ip);\n    vec2 lv = fract(ip);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n        mix(hash(id + vec2(0, 0), seed), hash(id + vec2(1, 0), seed), lv.x),\n        mix(hash(id + vec2(0, 1), seed), hash(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat noise(in vec2 ip, in float seed, in float freq, in int levels) {\n    ip += seed+0.2092391233;\n    float amp = 1.0;\n    float div = 0.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * noise(ip*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nfloat noise(in vec3 ip, in float seed) {\n    ip += seed+0.2092391233;\n    vec3 id = floor(ip);\n    vec3 lv = fract(ip);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n        mix(\n            mix(hash(id + vec3(0, 0, 0), seed), hash(id + vec3(1, 0, 0), seed), lv.x),\n            mix(hash(id + vec3(0, 1, 0), seed), hash(id + vec3(1, 1, 0), seed), lv.x),\n            lv.y\n        ),\n        mix(\n            mix(hash(id + vec3(0, 0, 1), seed), hash(id + vec3(1, 0, 1), seed), lv.x),\n            mix(hash(id + vec3(0, 1, 1), seed), hash(id + vec3(1, 1, 1), seed), lv.x),\n            lv.y\n        ),\n        lv.z\n    );\n}\n\nfloat noise(in vec3 ip, in float seed, in float freq, in int levels) {\n    ip += seed+0.2092391233;\n    float amp = 1.0;\n    float div = 0.0;\n    float n = 0.0;\n    for (int i = 0; i < levels; i++) {\n        n += amp * noise(ip*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n","name":"Common","description":"","type":"common"}]}