{"ver":"0.1","info":{"id":"cscGzs","date":"1677793292","viewed":126,"name":"connecting sparcles","username":"SlowMetanoia","description":"made from \"universe within\" tutorial mostly\nhttps://www.youtube.com/watch?v=3CycKKJiwis","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a ,b ,t) smoothstep(a, b, t)\n\nconst float gridSize = 5.5;\nconst float width = .01;\nconst float lineBlur = .005;\nconst float leftFadeEdge = .8;\nconst float rightFadeEdge = 1.2;\nconst float layerNumber = 4.;\nconst float fadeDistance = .1;\nconst float rotationSpeed = 1.;\n\n\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba), .0, 1.);\n    return length(pa - ba*t);\n\n}\nfloat R21(vec2 p){\n    p = fract(p*vec2(237.543,8723.456));\n    p += dot(p, p+23.534);\n    return fract(p.x*p.y);\n}\nvec2 R22 (vec2 p) {\n    float x = R21(p);\n    float y = R21(p + x);\n    return vec2(x,y);\n}\nvec2 getPosition(vec2 gp, vec2 offset, float m){\n    vec2 r= R22(gp+offset);\n    vec2 n = r*(iTime) + m;\n    return offset + sin(n)*.4;\n}\nfloat Line(vec2 uv, vec2 p1, vec2 p2, float width, float blur){\n    float d = DistLine(uv, p1, p2);\n    float m = S(width+blur, width, d);\n    m*=S(rightFadeEdge,leftFadeEdge,length(p1-p2))*.5 + S(.2,.05, abs(length(p1-p2)-.75));\n    return m;\n}\nfloat Layer(vec2 uv, float gridSize, float n){\n    float m = 0.;\n    //in cell position\n    vec2 gv = fract(uv*gridSize) -.5;\n    //in grid position \n    vec2 gridPos = floor(uv*gridSize);\n    \n    vec2 p = getPosition(gridPos,vec2(0.),n);\n    \n    vec2 ps[9];\n    int i = 0;\n    \n    //float d = length(gv - p);\n    //float m = S(.1,.05,d);\n    \n    \n    for(float x = -1.;x<=1.;x++){\n        for(float y = -1.;y<=1.;y++){\n            vec2 shift = iResolution.xy/gridSize * iResolution.x/iResolution.y;\n            vec2 offset = vec2(x,y);\n            ps[i] = getPosition(gridPos,offset,n);\n            i++;\n        }\n    }\n    for(int j = 0;j<9; j++){\n        m += Line(gv, ps[4], ps[j],width,lineBlur);\n        \n        float brightness = sin(iTime+uv.x*10.)*.5+.5;\n        \n        vec2 l = (ps[j] - gv)*15./brightness;\n        \n        float sparckle = 1./dot(l,l);\n        m+=sparckle;\n    }\n    m += Line(gv, ps[1], ps[3],width,lineBlur);\n    m += Line(gv, ps[1], ps[5],width,lineBlur);\n    m += Line(gv, ps[3], ps[7],width,lineBlur);\n    m += Line(gv, ps[5], ps[7],width,lineBlur);\n    //debug grid\n    //if(gv.x>.47 || gv.y>.47){m = 1.;}\n    return m;\n}\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime/3.*rotationSpeed;\n    \n    mat2 rotation = mat2(cos(t), -sin(t), sin(t), cos(t));\n    \n    uv*=rotation;\n    \n    vec3 col = vec3(0.);\n    \n    float m = 0.;\n    float gs = clamp(gridSize - fract(iTime) - layerNumber,.1,1000.);\n    \n    for(float i = gs;i<gridSize;i++){\n        float mid = gridSize - layerNumber/2.;\n        float a = -abs(mid - i)+layerNumber/2.;\n        float layerAlfa = S(fadeDistance,layerNumber/2.,a);\n        m+=clamp(Layer(uv, i, i)*layerAlfa,0.,1.);\n    }\n    \n    col = vec3(m);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}