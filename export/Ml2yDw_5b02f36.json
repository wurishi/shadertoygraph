{"ver":"0.1","info":{"id":"Ml2yDw","date":"1508869675","viewed":432,"name":" Star Nest Fractal MRI 2","username":"Good","description":"Experiment with this beautiful, cheap-to-compute fractal.  Inspired by Kali's \"Star Nest\" fork from  Magic Fractal by dgreensp //www.shadertoy.com/view/4ljGDd","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const int MAGIC_BOX_ITERS = 12;\nconst float MAGIC_BOX_MAGIC = 0.77;//55;\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.288, 0.699, 0.653,\n                    0.069, 0.665, -0.743,\n                    -0.954, 0.260, 0.143);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // scroll a certain number of screenfuls/second\n    //uv.x += iTime*0.02;\n    \n    float z= iTime*0.05+100.0;    \n    if(iMouse.z>0.){ z += iMouse.x/500.0; }\n\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.    \n    vec3 p = 0.25*M*vec3(uv, z);\n    \n    float result = magicBox(p);\n    // Scale to taste.  Also consider non-linear mappings.\n    result *= 0.07;\n    float result1 = smoothstep(.4, .51, result);\n    float result2 = smoothstep(.15, .4, result);\n    vec3 c = mix(vec3(.9,.2,.0),vec3(.1,.05,.15), result2);\n    c = mix(c, vec3(0,0,0), result1);\n    fragColor = vec4(c,1);\n    \n}","name":"Image","description":"","type":"image"}]}