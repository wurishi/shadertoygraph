{"ver":"0.1","info":{"id":"mljSzK","date":"1676336129","viewed":117,"name":"3D RGB Noise","username":"ianertson","description":"Just some noise experiments","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","rgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 0 = Custom noise\n// 1 = Noise from 2D texture\n#define USE_TEXTURE_NOISE 1\n\n\n#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\n\n///////////// Noise using texture\n\nvec3 texHash33(sampler2D ch, vec3 p, float div, float seed, vec2 lod) {\n    return textureLod(ch, (vec2(p.x, p.y) +\n        div*(textureLod(ch, (vec2((p.y*p.z), p.z)+seed)/div, lod.x).xy*2.0-1.0))/div, lod.y).xyz;\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float seed, vec2 lod) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n\n    float div = vec2(textureSize(tex, 0).xy).y;\n\n    return mix(\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 0), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 0), div, seed, lod), lv.x),\n          lv.y),\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 1), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 1), div, seed, lod), lv.x),\n          lv.y),\n        lv.z\n    );\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float freq, float seed, vec2 lod) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}\n\nfloat hash11(float x) {\n  uint y = floatBitsToUint(x) >> 3u;\n  uint w = (~y) ^ (y >> 3u) & (~y >> 3u);\n  y ^= ((~(y << w)) ^ (y >> 3u) << (w ^ (y << w) >> 3u));\n  return float(y * 3948u) / float(0xFFFFFFFFU);\n}\n\n\n///////////// Custom noise without texture\n\nfloat hash31(vec3 x, float seed) {\n  uvec3 y = uvec3(floatBitsToUint(hash11(x.x)), floatBitsToUint(hash11(x.y)),\n                  floatBitsToUint(hash11(x.z)));\n  uvec3 w = (~y) >> 3u;\n  uint s = floatBitsToUint(seed);\n  \n  w ^= (w << s);\n  uint xy = (((y.x << w.x) ^ (y.y << w.y)) << (y.x ^ y.y)) +\n            (((w.x >> y.y) << (y.x << w.y)) & (y.x ^ y.y));\n  uint yz = (((y.y << w.y) ^ (y.z << w.z)) << (y.y ^ y.z)) +\n            (((w.y >> y.z) << (y.y << w.z)) & (y.y ^ y.z));\n  uint xz = (((y.x << w.x) ^ (y.z << w.z)) << (y.x ^ y.z)) +\n            (((w.x >> y.z) << (y.x << w.z)) & (y.x ^ y.z));\n  return hash11(float(xy + yz + xz) / float(0xFFFFFFFFU));\n}\n\nvec3 pHash33(vec3 p, float seed) {\n    float x = hash31(p, seed);\n    float y = hash31(p, seed+4.021);\n    float z = hash31(p, seed+16.0982);\n    return vec3(x, y, z);\n}\n\nvec3 pNoise(vec3 p, float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n\n    return mix(\n        mix(mix(\n              pHash33(id + vec3(0, 0, 0), seed),\n              pHash33(id + vec3(1, 0, 0), seed), lv.x),\n          mix(pHash33(id + vec3(0, 1, 0), seed),\n              pHash33(id + vec3(1, 1, 0), seed), lv.x),\n          lv.y),\n        mix(mix(\n              pHash33(id + vec3(0, 0, 1), seed),\n              pHash33(id + vec3(1, 0, 1), seed), lv.x),\n          mix(pHash33(id + vec3(0, 1, 1), seed),\n              pHash33(id + vec3(1, 1, 1), seed), lv.x),\n          lv.y),\n        lv.z\n    );\n}\n\nvec3 pNoise(vec3 p, float freq, float seed) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    n += amp * pNoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * pNoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * pNoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * pNoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}\n\n\n\n///////////// Render\n\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0, 0, 0.);\n    ro.z += T*0.16;\n    vec3 rd = normalize(vec3(uv.xy, 1.));\n    \n    if (iMouse.z > 0.01) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        rd.yz *= rot(cos(T*0.16));\n        rd.xz *= rot(T*0.16);\n    }\n\n    #if USE_TEXTURE_NOISE > 0\n    col += texNoise(iChannel0, ro+rd, 10., 0.5, vec2(0.0, 0.0));\n    #else\n    col += pNoise(ro+rd, 10.0, 0.5);\n    #endif\n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}