{"ver":"0.1","info":{"id":"tdjcR3","date":"1587080288","viewed":81,"name":"Penumbra + SS","username":"ez21","description":"Subsurface Scattering, Penumbra shadows, Noise-custom textures","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["approx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.4;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 4.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float SCALE = 8.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 2.;\n\n// ambient occlusion\nconst float KSTEP = 2.;\nconst float OCCDist = 0.085;\n\n\n#define FLOOR_SDF plane(pos, vec3(0., 1.0, 0.), vec3(0., -2.5, 0.))\n#define SPHERE1_SDF sphere(pos, 1., vec3(-7.5, 0., 12.))\n#define SPHERE2_SDF sphere(pos, 5., vec3(2.5, 0.5, 10.))\n#define SUN_SDF sphere(pos, 1.5, lightPos)\n\n    \n#define FLOOR_ID 3\n#define SPHERE1_ID 4\n#define SPHERE2_ID 5\n#define SUN_ID 6\n\n\nconst float FOVY = (3.141569 * 2.) * 19.5 / 360.;\nconst int RAY_STEPS = 256;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n    vec3 n;\n};\n    \n/********************************/\n/***** NOISE FUNCTIONS BEGIN*****/\n/********************************/\n\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 191.999)),\n                          dot(p, vec3(269.5, 183.3, 765.54)), \n                          dot(p, vec3(420.69, 631.2, 109.21))))\n                 * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))\n                 * 43758.5453);\n}\n\nfloat WorleyNoise2D(vec2 p) {\n    \n    // Tile the space\n    vec2 pointInt = floor(p);\n    vec2 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(pointInt + neighbor);\n\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(1., 1., 1.);\nconst vec3 d = vec3(0.81,0.81,0.74);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nconst vec3 a2 = vec3(0.5, 0.5, 0.5);\nconst vec3 b2 = vec3(0.5, 0.5, 0.5);\nconst vec3 c2 = vec3(1., 1., 1.);\nconst vec3 d2 = vec3(0.2,0.25,0.25);\n\n\nvec3 colorPalette2(float t) {\n    return a2 + b2 * cos(6.28 * (t * c2 + d2));\n}\n\nfloat noise2D(vec2 p ) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                 43758.5453);\n}\n\n\nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1., intY));\n    float v3 = noise2D(vec2(intX, intY + 1.));\n    float v4 = noise2D(vec2(intX + 1., intY + 1.));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\nfloat fbm(vec2 p) {\n    float total = 0.;\n    float persistence = 0.7f;\n    float octaves = 8.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(p.x * freq,\n                               p.y * freq) * amp;\n    }\n    return total;\n}\n\n\n\n/********************************/\n/***** NOISE FUNCTIONS END ******/\n/********************************/\n    \n\n// SDF of a sphere\nfloat sphere(vec3 p , float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n// SDF of plane\nfloat plane(vec3 p, vec3 n, vec3 c)\n{\n  \t// n must be normalized\n  \tvec3 a = p - c;\n  \tvec3 b = n;\n    \n    if (dot(a, b) < -0.001) {\n        return 10000.;\n    }\n  \n  \treturn dot(a ,b) / length(b);\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n// transformation\nmat4 inverseTransform(vec3 s, vec3 rDeg, vec3 t) {\n    \n    // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 rMat = r_x * r_y * r_z;\n    \n    // creating worldTransform matrix\n    mat4 translateMat;\n    translateMat[0] = vec4(1., 0., 0., 0.);\n    translateMat[1] = vec4(0., 1., 0., 0.);\n    translateMat[2] = vec4(0., 0., 1., 0.);\n    translateMat[3] = vec4(t.x, t.y, t.z, 1.);\n    \n    mat4 scaleMat;\n    scaleMat[0] = vec4(s.x, 0., 0., 0.);\n    scaleMat[1] = vec4(0., s.y, 0., 0.);\n    scaleMat[2] = vec4(0., 0., s.z, 0.);\n    scaleMat[3] = vec4(0., 0., 0., 1.);\n\n    mat4 worldTrans = translateMat * rMat * scaleMat;\n    \n    return inverse(worldTrans);\n}\n\nmat4 rotateMat(vec3 rDeg) {\n        // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 rMat = r_x * r_y * r_z;\n    return rMat;\n}\n\n// SDF of box\nfloat box(vec3 p, vec3 s, vec3 r, vec3 t) {\n    mat4 inverseTrans = inverseTransform(s, r, t);\n    vec4 tempP = inverseTrans * vec4(p, 1.f);\n    p = vec3(tempP.x, tempP.y, tempP.z);\n    \n    vec3 q = abs(p) - vec3(0.5, 0.5, 0.5);\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) <t) {\n        t = t2;\n        obj = SPHERE1_ID;\n    }\n    if ((t2 = SPHERE2_SDF) <t) {\n        t = t2;\n        obj = SPHERE2_ID;\n    }\n    if ((t2 = SUN_SDF) <t) {\n        t = t2;\n        obj = SUN_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SPHERE2_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SUN_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thin) {\n\tvec3 scatterDir = lightDir + normal * DISTORTION; // Last term is tunable\n\tfloat lightReachingEye = pow(clamp(dot(viewVec, -scatterDir),\n\t\t\t\t\t\t\t     0.0, 1.0), GLOW) * SCALE;\n\tfloat attenuation = max(0.0, dot(normal, lightDir)\n                             + dot(viewVec, -lightDir));\n    //attenutation = 1.f;\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n\treturn totalLight;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float max_t, float k) {\n    float res = 1.0;\n    for(float t = min_t; t < max_t; /*No update in loop header*/) {\n        float m = sceneMap3D(origin + t * dir, vec3(0., 0., 0.));\n        if(m < 0.0001) {\n            return 0.0; // In shadow\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec2 sphereUVMapSun(vec3 pos, vec3 lightPos) {\n    vec3 n = normalize(pos - lightPos); // sphere point - sphere center: for the sun\n    float phi = atan(n.z, n.x);\n    if (phi < 0.) {\n        phi += 2. * 3.1415926;\n    }\n    float theta = acos(n.y);\n    float u = 1. - phi / (2. * 3.1415926);\n    float v = 1. - theta / 3.1415926;\n    return vec2(u, v);\n}\n\nvec2 planeUVMap(vec3 pos) {\n    vec3 n = vec3(0., 1., 0.);\n    vec3 u = normalize(vec3(1., 0., 0.));\n    vec3 v = cross(n, u);\n    \n    float u_coord = dot(u, pos);\n\tfloat v_coord = dot(v,pos);\n    return vec2(u_coord, v_coord);\n}\n\nvec3 computeMaterial(int hitObj, vec3 pos, vec3 n, vec3 lightVec, vec3 view, float thickness, vec3 lightPos) {\n    float lambert = max(0., dot(lightVec, n)) * softShadow(lightVec, pos, 0.1, 50., 6.0);\n    switch(hitObj) {\n        case FLOOR_ID:\n        \treturn vec3(1., 1., 1.) * lambert * colorPalette(cos(iTime / 2.)* WorleyNoise2D(planeUVMap(pos)));\n        \tbreak;\n        case SPHERE1_ID:\n        \treturn vec3(1., 0., 0.) * lambert;\n            break;\n\t\tcase SPHERE2_ID:\n        \tvec3 color = vec3(0.1, 0.4, 1.) * lambert;\n        \treturn color + subsurface(lightVec, n, view, thickness) * vec3(0.2, 0.5, 1.);\n            break;\n        case SUN_ID:\n        \treturn vec3(1.0, 0.88, 0.7) * colorPalette2(fbm(sphereUVMapSun(pos, lightPos)) * cos(iTime / 8.));\n        \tbreak;\n        case -1:\n            return vec3(0., 0., 0.);\n        \tbreak;\n    }\n    return vec3(0., 0., 0.);\n}\n\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos), \n                    \t  sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n    \n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nfloat AO5Step(vec3 p, vec3 n) {\n    float sum = 0.;\n    for (float i = 1.; i <= 5.; i = i + 1.) {\n        float distSDF = sceneMap3D(p + n * i * OCCDist, vec3(0.));\n        sum += (1. / pow(2., i)) * (i * OCCDist - distSDF);\n    }\n    float ao = 1.0 - KSTEP * sum;\n    return ao;\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect, lightPos);\n    \n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = AO5Step(isect, -nor);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness, lightPos);\n        \n    return Intersection(t, surfaceColor, isect, hitObj, nor);\n}\n\n// returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0, 1, 0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 5.5, -35);\n    vec3 ref = vec3(0, 2.5, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    vec3 lightPos = rotateY(vec3(0, 3.4, 18.0), sin(iTime * 0.5));\n\n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n    \n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.);\n}","name":"Image","description":"","type":"image"}]}