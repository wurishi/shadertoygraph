{"ver":"0.1","info":{"id":"slSBzt","date":"1652589867","viewed":333,"name":"Render & sample 3D texture","username":"LuncyTB","description":"Render 3D texture into a buffer and sample it as a 3D texture.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","fluid"],"hasliked":0,"parentid":"fl2BzK","parentname":"Water low"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Copyright (c) 2022 LuncyTB. All rights reserved.\n */\n\n#define AA 1\n// #define AA 4\n\nprecision highp float;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pix = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 uvfix = vec2(iResolution.x / iResolution.y, 1.0);\n    uv = (uv - 0.5) * uvfix + 0.5;\n\n    mat4 cubeTrans = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    vec3 camera = vec3(0.3 + cos(iTime * 0.5 + iMouse.x * 0.01) * 3.0, 0.1 + sin(iTime * 0.5 + iMouse.x * 0.01) * 3.0, 0.3 + 1.8 * cos(iTime * 0.2));\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 light0 = normalize(vec3(-0.4, 0.6, -1.3));\n    vec4 light0Col = vec4(1.0, 1.0, 0.9, 1.7);\n    vec3 enviroment = vec3(0.57, 0.67, 0.7);\n\n    mat4 mV = matView(camera, lookAt);\n    mat4 imV = transpose(mV);\n\n    vec4 ray = normalize(mV * vec4(uv.x * 2.0 - 1.0, 0.6, uv.y * 2.0 - 1.0, 0.0));\n    enviroment = calSky(ray.xyz, light0, light0Col);\n\n    fragColor = vec4(enviroment, 1.0);\n    // fragColor = vec4(texV3D(iChannel0, vec3(fract(iTime / 10.0), uv)).rgb, 1.0);\n    // fragColor = vec4(texture2D(iChannel0, uv).rgb, 1.0);\n\n    vec4 col = fragColor;\n    vec2 aa[4];\n    aa[0] = vec2(-pix.x, -pix.y);\n    aa[1] = vec2(pix.x, -pix.y);\n    aa[2] = vec2(-pix.x, pix.y);\n    aa[3] = vec2(pix.x, pix.y);\n\n    vec3 normal = -ray.xyz;\n    \n    col = vec4(0.0);\n    for (int i = 0; i < AA; i += 1) {\n        Hit hit = marchTest(camera, ray.xyz + vec3(aa[i], 0.0), iChannel0, light0);\n        if (hit.pos.w > 0.0) {\n            normal = hit.normal.xyz;\n            col += vec4(phone(hit.color.xyz, light0Col.xyz * light0Col.w, hit.normal.xyz, light0, ray.xyz, enviroment, hit.shadow, hit.pos.xyz), 1.0);\n        } else {\n            col += fragColor;\n        }\n    }\n    for (int i = 0; i < AA; i += 1) {\n        Hit hit = marchCloud(camera, ray.xyz + vec3(aa[i], 0.0), iChannel0, light0, enviroment);\n        float p = pow(0.5 + 0.5 * cos(iTime * 0.4), 3.3);\n        col = mix(hit.color, col, pow(1.0 - max(0.0, dot(-ray.xyz, normal)), 3.0) * p + 1.0 - p);\n    }\n    if (col.w > 0.0) {\n        fragColor = vec4(col.xyz / float(AA), 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pos = uvTo3(uv);\n    // fragColor = vec4(vec3(noise(uv, vec2(7.0))), 1.0);\n    float k = 0.4;\n    float side = min(min(\n        (1.0 - max(abs(pos.x - 0.5) - k, 0.0) / k),\n        (1.0 - max(abs(pos.y - 0.5) - k, 0.0) / k)),\n        (1.0 - max(abs(pos.z - 0.5) - k, 0.0) / k));\n    fragColor = vec4(vec3(0.1 * mnoise3(pos + vec3(1.3), vec3(4.0), 3.0, 0.5)) * pow(side, 5.0), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Hit {\n    vec4 pos;\n    vec4 normal;\n    vec4 color;\n    vec4 mres;\n    float shadow;\n};\n\nvec3 uvTo3(vec2 uv) {\n    uv = clamp(uv, 0.0, 1.0);\n    vec3 pos = vec3(\n        fract(uv.x * 10.0),\n        fract(uv.y * 10.0),\n        (uv.x * 10.0 + floor(uv.y * 10.0) * 10.0) / 100.0\n    );\n    return pos;\n}\n\nvec2 vec3ToUv(vec3 pos) {\n    vec3 rpos = vec3(\n        clamp(pos.x, 0.01, 1.0 - 0.01),\n        clamp(pos.y, 0.01, 1.0 - 0.01),\n        clamp(pos.z, 0.01, 1.0 - 0.01));\n    \n    vec2 base = vec2(\n        floor(fract(rpos.z * 10.0) * 10.0) / 10.0,\n        floor(rpos.z * 10.0) / 10.0\n    );\n    return base + rpos.xy / 10.0;\n}\n\nfloat sdfCube(vec3 pos, vec3 size, float r) {\n    vec3 dis = abs(pos) - size;\n    if (dis.x > 0.0 && dis.y > 0.0 && dis.z > 0.0) {\n        return length(dis) - r;\n    }\n    if (dis.x > 0.0 && dis.y > 0.0) {\n        return length(dis.xy) - r;\n    }\n    if (dis.x > 0.0 && dis.z > 0.0) {\n        return length(dis.xz) - r;\n    }\n    if (dis.z > 0.0 && dis.y > 0.0) {\n        return length(dis.zy) - r;\n    }\n    return max(dis.z, max(dis.x, dis.y)) - r;\n}\n\nvec4 texV3D(sampler2D tex, vec3 pos, vec3 size) {\n    pos = pos / size;\n    if (pos.x >= 1.0 || pos.y >= 1.0 || pos.z >= 1.0 || \n        pos.x <= 0.0 || pos.y <= 0.0 || pos.z <= 0.0) {\n        vec3 dis = abs(pos - 0.5) - 0.4;\n        float r = 0.09;\n        if (dis.x > 0.0 && dis.y > 0.0 && dis.z > 0.0) {\n            return vec4(length(dis) - r);\n        }\n        if (dis.x > 0.0 && dis.y > 0.0) {\n            return vec4(length(dis.xy) - r);\n        }\n        if (dis.x > 0.0 && dis.z > 0.0) {\n            return vec4(length(dis.xz) - r);\n        }\n        if (dis.z > 0.0 && dis.y > 0.0) {\n            return vec4(length(dis.zy) - r);\n        }\n        return vec4(max(dis.z, max(dis.x, dis.y)) - r);\n    }\n    vec3 rpos = vec3(\n        clamp(pos.x, 0.01, 1.0 - 0.01),\n        clamp(pos.y, 0.01, 1.0 - 0.01),\n        clamp(pos.z, 0.01, 1.0 - 0.01));\n    \n    vec2 base0 = vec2(\n        floor(fract(rpos.z * 10.0) * 10.0) / 10.0,\n        floor(rpos.z * 10.0) / 10.0\n    );\n    vec2 base1 = vec2(\n        floor(fract((rpos.z + 1.0 / 100.0) * 10.0) * 10.0) / 10.0,\n        floor((rpos.z + 1.0 / 100.0) * 10.0) / 10.0\n    );\n    \n    return (0.7 - 10.0 * mix(textureLod(tex, base0 + rpos.xy / 10.0, 0.0), textureLod(tex, base1 + rpos.xy / 10.0, 0.0), fract(rpos.z * 100.0))) / max(size.x, max(size.y, size.z));\n}\n\nmat4 matView(vec3 c, vec3 l) {\n    vec3 right = normalize(cross(l - c, vec3(0.0, 0.0, 1.0)));\n    vec3 front = normalize(l - c);\n    vec3 up = normalize(cross(right, front));\n    return mat4(\n        vec4(right, 0.0),\n        vec4(front, 0.0),\n        vec4(up, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nfloat sdfSphere(vec3 c, float r, vec3 p) {\n    return (distance(p, c) - r);\n}\n\nfloat sdfSphereTest2(vec3 p) {\n    vec3 testBall1 = vec3(1.4, 1.5, 0.2);\n    float testR1 = 0.7;\n    vec3 testBall2 = vec3(2.6, -0.1, 1.7);\n    float testR2 = 0.4;\n    return min(sdfSphere(testBall1, testR1, p), sdfSphere(testBall2, testR2, p));\n}\n\nfloat sdfV(vec3 p, sampler2D volume) {\n    vec4 data = texV3D(volume, p + 1.5, vec3(4.0));\n    return data.r;\n}\n\nfloat Senece(vec3 p, sampler2D volume) {\n    float d = sdfSphereTest2(p);\n    d = min(d, sdfV(p, volume));\n    d = min(d, sdfCube(p - vec3(2.0, 0.8, -0.3), vec3(1.0, 0.5, 0.3), 0.1));\n    return d;\n}\n\nfloat solid(vec3 p) {\n    float d = sdfSphereTest2(p);\n    d = min(d, sdfCube(p - vec3(2.0, 0.8, -0.3), vec3(1.0, 0.5, 0.3), 0.1));\n    return d; \n}\n\nfloat noise(vec2 uv, vec2 size) {\n    vec2 fix = vec2(5.543234,2.43243);\n    float base = 67219.4322341;\n    vec2 pos = uv * size;\n    float r00 = fract(sin(dot(floor(pos), fix)) * base);\n    float r01 = fract(sin(dot(floor(pos + vec2(0.0, 1.0)), fix)) * base);\n    float r11 = fract(sin(dot(floor(pos + vec2(1.0, 1.0)), fix)) * base);\n    float r10 = fract(sin(dot(floor(pos + vec2(1.0, 0.0)), fix)) * base);\n    return mix(mix(r00, r01, fract(pos.y)), mix(r10, r11, fract(pos.y)), fract(pos.x));\n}\n\nfloat mnoise(vec2 uv, vec2 size, float times, float scale) {\n    float v = 0.0;\n    for (float i = 0.0; i < times; i += 1.0) {\n        v += noise(uv, size * pow(2.0, i)) * pow(scale, i);\n    }\n    return v;\n}\n\nfloat noise3(vec3 uv, vec3 size) {\n    vec3 pos = uv * size;\n    float r0 = noise(uv.xy + floor(pos.z + 1.0) * 38.3242, size.xy);\n    float r1 = noise(uv.xy + floor(pos.z) * 38.3242, size.xy);\n    return mix(r1, r0, fract(pos.z));\n}\n\nfloat mnoise3(vec3 uv, vec3 size, float times, float scale) {\n    float v = 0.0;\n    for (float i = 0.0; i < times; i += 1.0) {\n        v += noise3(uv, size * pow(2.0, i)) * pow(scale, i);\n    }\n    return v;\n}\n\nHit marchTest(vec3 start, vec3 ray, sampler2D volume, vec3 light) {\n    ray = normalize(ray);\n\n    float side = 0.1;\n    vec2 normalE = vec2(-1.0, 1.0) * 0.001;\n\n    Hit hit = Hit(vec4(0.0), vec4(0.0), vec4(1.0, 0.2, 1.0, 1.0), vec4(0.0, 0.0, 0.0, 0.0), 1.0);\n\n    float step = side;\n    vec3 now = start;\n\n    for (float i = 0.0; i < 64.0; i += 1.0) {\n        step = step * 1.01;\n        now += ray * step;\n        vec3 noiseC = ray * noise3(ray, vec3(2048.0)) * step;\n        float lastD = Senece(now + noiseC, volume);\n        if (lastD <= 0.0) {\n            now -= ray * step - noiseC;\n            float c = 0.0;\n            float over = step;\n            float end = 0.0;\n            for (float j = 0.0; j < 64.0; j++) {\n                lastD = Senece(now + ray * (c + end * 0.5), volume);\n                if (lastD > 0.0) {\n                    c += end * 0.5;\n                }\n                end *= 0.5;\n                c += lastD;\n                if (lastD < 0.001) {\n                    hit.pos = vec4(now + ray * c, 1.0);\n                    \n                    hit.normal = vec4(normalize(vec3(\n                        normalE.yxy * Senece(hit.pos.xyz + normalE.yxy, volume) + \n                        normalE.yyx * Senece(hit.pos.xyz + normalE.yyx, volume) + \n                        normalE.xyy * Senece(hit.pos.xyz + normalE.xyy, volume) + \n                        normalE.xxx * Senece(hit.pos.xyz + normalE.xxx, volume)\n                    )), 0.0);\n\n                    hit.shadow = 1.0;\n                    float shadowStep = 0.45;\n                    vec3 ch = vec3(noise3(hit.normal.xyz, vec3(1024.0)), noise3(hit.normal.yzx, vec3(1024.0)), noise3(hit.normal.zxy, vec3(1024.0)));\n                    vec3 lray = normalize(light + ch * 0.1);\n                    for (float sdi = 0.0; sdi < 32.0; sdi += 1.0) {\n                        vec3 nmove = lray * noise3(lray, vec3(2048.0)) * shadowStep;\n                        vec3 sdtest = hit.pos.xyz - lray * sdi * shadowStep - nmove;\n                        lastD = Senece(sdtest, volume);\n                        if (lastD < 0.0) {\n                            sdtest = hit.pos.xyz - lray * (sdi - 1.0) * shadowStep - nmove;\n                            c = 0.1;\n                            for (float j = 0.0; j < 16.0; j++) {\n                                lastD = Senece(sdtest - light * c, volume);\n                                c = max(0.05, c + lastD);\n                                if (lastD < 0.001) {\n                                    hit.shadow = 0.0;\n                                    break;\n                                }\n                            }\n                            if (hit.shadow < 0.5) {\n                                break;\n                            }\n                        }\n                    }\n\n                    float U = hit.pos.x;\n                    float V = hit.pos.y + hit.pos.z;\n                    // U = atan(hit.normal.y, hit.normal.x);\n                    // V = atan(hit.normal.z, length(hit.normal.xy));\n                    if (solid(hit.pos.xyz) > 0.002) {\n                        hit.color = vec4(0.4, 0.3, 0.2, 1.0);\n                    } else {\n                        hit.color = mix(vec4(0.4, 0.6, 0.9, 1.0), vec4(0.2, 0.3, 0.1, 1.0), mod(floor(fract(U * 2.0) * 2.0) + floor(fract(V * 2.0) * 2.0), 2.0));\n                    }\n                    end = 1.0;\n                    break;\n                }\n            }\n            if (end > 0.5) { break; }\n        }\n    }\n    return hit;\n}\n\nHit marchCloud(vec3 start, vec3 ray, sampler2D volume, vec3 light, vec3 bg) {\n    ray = normalize(ray);\n\n    float side = 0.1;\n    vec2 normalE = vec2(-1.0, 1.0) * 0.001;\n\n    Hit hit = Hit(vec4(0.0), vec4(0.0), vec4(bg, 1.0), vec4(0.0, 0.0, 0.0, 0.0), 1.0);\n\n    float step = side;\n    vec3 now = start;\n\n    for (float i = 0.0; i < 64.0; i += 1.0) {\n        step = step * 1.01;\n        now += ray * step;\n        vec3 noiseC = ray * noise3(ray, vec3(2048.0)) * step;\n        float lastD = Senece(now + noiseC, volume);\n        if (lastD <= 0.0) {\n            hit.color *= pow(mix(vec4(1.0), vec4(0.9, 0.0, 0.0, 1.0), 0.1), vec4(step / side));\n            hit.pos = vec4(now + noiseC, 1.0);\n\n            /* now -= ray * step - noiseC;\n            float c = 0.0;\n            float over = step;\n            float end = 0.0;\n            for (float j = 0.0; j < 64.0; j++) {\n                lastD = Senece(now + ray * (c + end * 0.5), volume);\n                if (lastD > 0.0) {\n                    c += end * 0.5;\n                }\n                end *= 0.5;\n                c += lastD;\n                if (lastD < 0.001) {\n                    hit.pos = vec4(now + ray * c, 1.0);\n                    \n                    hit.normal = vec4(normalize(vec3(\n                        normalE.yxy * Senece(hit.pos.xyz + normalE.yxy, volume) + \n                        normalE.yyx * Senece(hit.pos.xyz + normalE.yyx, volume) + \n                        normalE.xyy * Senece(hit.pos.xyz + normalE.xyy, volume) + \n                        normalE.xxx * Senece(hit.pos.xyz + normalE.xxx, volume)\n                    )), 0.0);\n\n                    hit.shadow = 1.0;\n                    float shadowStep = 0.45;\n                    vec3 ch = vec3(noise3(hit.normal.xyz, vec3(1024.0)), noise3(hit.normal.yzx, vec3(1024.0)), noise3(hit.normal.zxy, vec3(1024.0)));\n                    vec3 lray = normalize(light + ch * 0.1);\n                    for (float sdi = 0.0; sdi < 32.0; sdi += 1.0) {\n                        vec3 nmove = lray * noise3(lray, vec3(2048.0)) * shadowStep;\n                        vec3 sdtest = hit.pos.xyz - lray * sdi * shadowStep - nmove;\n                        lastD = Senece(sdtest, volume);\n                        if (lastD < 0.0) {\n                            sdtest = hit.pos.xyz - lray * (sdi - 1.0) * shadowStep - nmove;\n                            c = 0.1;\n                            for (float j = 0.0; j < 16.0; j++) {\n                                lastD = Senece(sdtest - light * c, volume);\n                                c = max(0.05, c + lastD);\n                                if (lastD < 0.001) {\n                                    hit.shadow = 0.0;\n                                    break;\n                                }\n                            }\n                            if (hit.shadow < 0.5) {\n                                break;\n                            }\n                        }\n                    }\n\n                    float U = hit.pos.x;\n                    float V = hit.pos.y + hit.pos.z;\n                    // U = atan(hit.normal.y, hit.normal.x);\n                    // V = atan(hit.normal.z, length(hit.normal.xy));\n                    if (solid(hit.pos.xyz) > 0.002) {\n                        hit.color = vec4(0.4, 0.3, 0.2, 1.0);\n                    } else {\n                        hit.color = mix(vec4(0.4, 0.6, 0.9, 1.0), vec4(0.2, 0.3, 0.1, 1.0), mod(floor(fract(U * 2.0) * 2.0) + floor(fract(V * 2.0) * 2.0), 2.0));\n                    }\n                    end = 1.0;\n                    break;\n                }\n            }\n            if (end > 0.5) { break; } */\n        }\n    }\n    return hit;\n}\n\nvec3 calSky(vec3 normal, vec3 sun, vec4 sunCol) {\n    vec3 top = mix(vec3(0.27, 0.37, 0.6) * 1.3, vec3(0.8, 0.84, 0.89), max(0.0, normal.z) * pow(mnoise(normal.xy / normal.z, vec2(1.0), 4.0, 0.5), 3.0));\n    vec3 ground = vec3(0.4, 0.34, 0.3) * 1.1;\n    vec3 fog = vec3(0.8, 0.78, 0.76);\n    float base = -0.2;\n    if (normal.z > base) {\n        return mix(fog, top, 1.0 - 0.5 * (1.0 - pow(normal.z - base, 0.8))) + pow(max(0.0, dot(normal, -sun)), 128.0) * sunCol.rgb * sunCol.a;\n    }\n    if (normal.z <= base) {\n        return mix(fog, ground, 1.0 - 0.5 * (1.0 - pow(base - normal.z, 0.8))) + pow(max(0.0, dot(normal, -sun)), 128.0) * sunCol.rgb * sunCol.a;\n    }\n}\n\nvec3 calSkyDiff(vec3 normal) {\n    vec3 top = vec3(0.27, 0.37, 0.6) * 1.4;\n    vec3 ground = vec3(0.4, 0.34, 0.3) * 1.1;\n    vec3 fog = vec3(0.8, 0.78, 0.76);\n    float base = -0.2;\n    if (normal.z > base + 0.6) {\n        return mix(fog, top, 1.0 - 0.5 * (1.0 - pow(normal.z - base, 1.0)));\n    } else if (normal.z <= base - 0.6) {\n        return mix(fog, ground, 1.0 - 0.5 * (1.0 - pow(base - normal.z, 1.0)));\n    } else {\n        return mix(\n            mix(fog, top, 1.0 - 0.5 * (1.0 - pow(0.6, 1.0))),\n            mix(fog, ground, 1.0 - 0.5 * (1.0 - pow(0.6, 1.0))),\n            (base + 0.6 - normal.z) / 1.2\n        );\n    }\n}\n\nvec3 phone(vec3 base, vec3 lightc, vec3 normal, vec3 light, vec3 ray, vec3 env, float shadow, vec3 pos) {\n    return base * calSkyDiff(normal) * 0.6\n        + base * lightc * max(dot(normal, -light), 0.0) * shadow\n        + lightc * pow(max(0.0, dot(reflect(ray, normal), -light)), 67.0) * 0.5 * shadow\n        + calSky(reflect(ray, normal), light, vec4(lightc, 1.0)) * (base * 0.1 + pow(1.0 - abs(dot(-ray, normal)), 5.0) * length(base) * 0.9);\n        ;\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nprecision highp float;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pos = uvTo3(uv);\n    vec3 px = vec3(0.01, 0.01, 0.01);\n    \n    vec3 v = vec3(0.0);\n    float m = 0.0;\n    float base = 0.0;\n\n    for (float i = pos.x - px.x; i <= pos.x + px.x * 1.1; i += px.x) {\n        for (float j = pos.y - px.y; j <= pos.y + px.y * 1.1; j += px.y) {\n            for (float k = pos.z - px.z; k <= pos.z + px.z * 1.1; k += px.z) {\n                if (i <= 0.01 || i >= 0.99 || j <= 0.01 || j >= 0.99 || k <= 0.01 || k >= 0.99) {\n                    if (distance(vec3(i, j, k), pos) > length(px) * 0.1) { continue; }\n                }\n                vec3 pp = vec3(i, j, k);\n                vec4 stat = texture(iChannel0, vec3ToUv(pp));\n                vec3 pv = stat.yzw * 2.0 - 1.0;\n                float pm = stat.x;\n                if (distance(pp + pv * px, pos) < length(px) && pm <= 0.1)\n                {\n                    v += pv;\n                    m += pm;\n                    base += 1.0;\n                }\n            }\n        }\n    }\n\n    v = v / m;\n\n    float m2 = 0.0;\n    vec3 v2 = vec3(0.0);\n    for (float i = pos.x - px.x; i <= pos.x + px.x * 1.1; i += px.x) {\n        for (float j = pos.y - px.y; j <= pos.y + px.y * 1.1; j += px.y) {\n            for (float k = pos.z - px.z; k <= pos.z + px.z * 1.1; k += px.z) {\n                if (i <= 0.01 || i >= 0.99 || j <= 0.01 || j >= 0.99 || k <= 0.01 || k >= 0.99) {\n                    if (distance(vec3(i, j, k), pos) > length(px) * 0.1) { continue; }\n                }\n                vec3 pp = vec3(i, j, k);\n                vec4 stat = texture(iChannel0, vec3ToUv(pp));\n                vec3 pv = stat.yzw * 2.0 - 1.0;\n                float pm = stat.x;\n\n                if (pm > 0.1) {\n                    float subm = pm / 8.0;\n                    m += subm;\n                    v = pv * subm + v * m;\n                }\n            }\n        }\n    }\n\n    v += vec3(0.0, 0.0, -0.01) + vec3(\n        noise3(pos.xyz, vec3(100.0)),\n        noise3(pos.yzx, vec3(100.0)),\n        noise3(pos.zxy, vec3(100.0))\n    ) * 0.002;\n    v *= 0.95;\n    if (pos.z < 0.1) {\n        v += vec3(0.0, 0.0, 0.01);\n    }\n\n    fragColor = vec4(m, v * 0.5 + 0.5);\n\n    if (distance(pos, vec3(0.5, 0.5, 0.5)) < 0.1) {\n        // fragColor = vec4(0.1, 0.5, 0.5, 0.5);\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}