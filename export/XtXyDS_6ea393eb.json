{"ver":"0.1","info":{"id":"XtXyDS","date":"1508017749","viewed":400,"name":"Grow a Fjord?","username":"SudoNhim","description":"Store a voxel world in a texture, and grow vegetation on it!\n\nThis is basically a tech demo - I need to make it pretty now.","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NONE 0u\n\n#define WATER 1u\n#define GRASS 2u\n#define WOOD 3u\n#define LEAVES 4u\n\n#define DIRT 9u\n#define COBBLESTONE 11u\n#define ROCK 12u\n#define SAND 13u\n\n#define MAXSTEPS 256\n\n// Voxel marching and lighting code swiped/mangled from reinder's Minecraft: https://www.shadertoy.com/view/4ds3WS\n// Which in turn swiped voxel marching code from iq :)\n\nvec3 baseColor(uint terr) {\n    switch(terr) {\n\tcase DIRT:\n        return vec3(0.336, 0.255, 0.145);\n    case COBBLESTONE:\n        return vec3(0.176, 0.176, 0.164);\n    case ROCK:\n        return vec3(0.280, 0.292, 0.300);\n    case SAND:\n        return vec3(0.949, 0.820, 0.557);\n    case WATER:\n        return vec3(0.143, 0.220, 0.607);\n    case GRASS:\n        return vec3(0.131, 0.318, 0.127);\n    case WOOD:\n        return vec3(0.198, 0.127, 0.088);\n    case LEAVES:\n        return vec3(0.037, 0.167, 0.004);\n        \n    case NONE:\n        return vec3(1.0, 1.0, 0.0);\n    }\n    \n    return vec3(1.0, 0.0, 0.0);\n}\n\n\nuint map(in vec3 c ) {\n    c.xz = mod(c.xz, 512.0);\n\tivec3 ip = ivec3(c);\n    if (ip.y < 0) return WATER;\n    if (ip.y > 29 || ip.x < 0 || ip.z < 0 || ip.x > 511 || ip.z > 511) return NONE;\n    uvec4 data = floatBitsToUint(texelFetch(iChannel0, ip.xz, 0));\n    uvec4 samp = (data >> ip.y) & 1u;\n  \treturn samp[0] + samp[1] * 2u + samp[2] * 4u + samp[3] * 8u;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 0.0;\n\tvec3 mm = vec3(0.0);\n\tbool hit = false;\n\t\n\tfor( int i=0; i<MAXSTEPS; i++ ) \n\t{\n\t\tif( hit ) break;\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t\tif( map(pos) != NONE ) { hit = true;}\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn hit?t:0.;\n\n}\n\nfloat castVRay( in vec3 ro, in vec3 rd, in float maxDist ) {\n\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 1.0;\n\t\n\tfor( int i=0; i<18; i++ ) \n\t{\n\t\tif( map(pos) != NONE ) {res=0.0; break; }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\t\n\treturn res;\n\n}\n\nvec3 path( float t ) {\n    vec2 p = vec2(255.0);\n    p += 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\tp +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x,30.+4.*(1.-cos(iTime*0.1)), p.y );\n}\n\n\n//=====================================================================\n// Ambient occlusion \n\nvec4 edges( in vec3 vos, in vec3 nor, in vec3 dir )\n{\n\tvec3 v1 = vos + nor + dir.yzx;\n\tvec3 v2 = vos + nor - dir.yzx;\n\tvec3 v3 = vos + nor + dir.zxy;\n\tvec3 v4 = vos + nor - dir.zxy;\n\n\tvec4 res = vec4(0.0);\n\tif( map(v1) != NONE ) res.x = 1.0;\n\tif( map(v2) != NONE ) res.y = 1.0;\n\tif( map(v3) != NONE ) res.z = 1.0;\n\tif( map(v4) != NONE ) res.w = 1.0;\n\n\treturn res;\n}\n\nvec4 corners( in vec3 vos, in vec3 nor, in vec3 dir )\n{\n\tvec3 v1 = vos + nor + dir.yzx + dir.zxy;\n\tvec3 v2 = vos + nor - dir.yzx + dir.zxy;\n\tvec3 v3 = vos + nor - dir.yzx - dir.zxy;\n\tvec3 v4 = vos + nor + dir.yzx - dir.zxy;\n\n\tvec4 res = vec4(0.0);\n\tif( map(v1) != NONE ) res.x = 1.0;\n\tif( map(v2) != NONE ) res.y = 1.0;\n\tif( map(v3) != NONE ) res.z = 1.0;\n\tif( map(v4) != NONE ) res.w = 1.0;\n\n\treturn res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    \n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+4. );\n\tta.y = ro.y;\n\t\n\t// build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww + vec3(0.0, -0.7, 0.0) );\n\n\tfloat sun = clamp( dot(normalize(vec3(1.0)),rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\t\n\tif( t>0.0 ) {\n\t\tvec3 nor = -dir*sign(rd);\n\t\t\n\t\tvec3 pos = ro + rd*t;\n\t\tuint mMat = map( vos );\t\t\t\n\t\tvec3 mpos = mod( pos * 16., 16. );\n\t\tvec3 mCol = baseColor(mMat);\n\t\t\n\t\t// lighting\n        vec3 sundir = normalize(vec3(1.0));\n\t\tfloat dif = clamp( dot( nor, sundir ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( dif>0.01) sha=castVRay(pos+nor*0.01,sundir,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(sundir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n\t\tfloat amb = 1.0;//clamp(0.75 + pos.y/100.0,0.0,1.0);\n\t\t\t\n        // ambient occlusion\n\t\t\n        vec4 ed = edges( vos, nor, dir );\n        vec4 co = corners( vos, nor, dir );\n        vec3 uvw = pos - vos;\n        vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\n        float occ = 0.0; \n        // (for edges)\n        occ += (    uv.x) * ed.x;\n        occ += (1.0-uv.x) * ed.y;\n        occ += (    uv.y) * ed.z;\n        occ += (1.0-uv.y) * ed.w;\n        // (for corners)\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n\t\t\n\t\t\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 4.0*dif*vec3(1.)*(0.5+0.5*occ)*(0.25+0.75*sha);\n\t\tlin += 1.8*bac*vec3(1.0,0.5,1.0)*(0.5+0.5*occ);\n\t\tlin += 4.0*sky*vec3(0.6,0.71,0.75)*occ;\n\t\n\t\t\n\t\tif( mMat == 10u ) {\n\t\t\tcol = mix( col, mCol*lin*0.6, 0.3);\t\t\n\t\t} else {\n\t\t\t// atmospheric\n\t\t\tcol = mix( mCol*lin*0.2, col, 1.0-exp(-0.0000001*t*t*t) );\n\t\t}\t\t\t\n\t}\n\t\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\t\n    // gamma\t\n\tcol = pow( col, vec3(0.45) );\n\t\n\t// contrast\n    col = col* 0.25 + 0.75*col*col*(3.0-2.0*col);\n\t\t\n    col = clamp( col, 0.0, 1.0 );\n\n\t// vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// encodes the scene into four channels like so:\n// total size: 512x512x30\n// r,g,b, a: four bit block ID\n\n#define NONE 0u\n\n#define WATER 1u\n#define GRASS 2u\n#define WOOD 3u\n#define LEAVES 4u\n\n#define DIRT 9u\n#define COBBLESTONE 11u\n#define ROCK 12u\n#define SAND 13u\n\nuvec4 prev[9];\n\nvoid initPrev(uvec2 coord)\n{\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            uvec2 samp = uvec2(ivec2(coord) + ivec2(i-1, j-1));\n            prev[i*3+j] = floatBitsToUint(texelFetch(iChannel2, ivec2(samp), 0));\n        }\n    }\n}\n\nuint prevUnder[9] = uint[9]( NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE );\nuint prevLevel[9] = uint[9]( NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE );\nuint prevAbove[9] = uint[9]( NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE );\n\nvoid initLocalPrev(uint height)\n{\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            int index = i*3 + j;\n            uvec4 samp = (prev[index] >> (height + 1u)) & 1u;\n            prevAbove[i*3 + j] = samp[0] + samp[1] * 2u + samp[2] * 4u + samp[3] * 8u;\n   \t\t\tsamp = (prev[index] >> height) & 1u;\n  \t\t\tprevLevel[i*3 + j] = samp[0] + samp[1] * 2u + samp[2] * 4u + samp[3] * 8u;\n    \t\tsamp = (prev[index] >> (height - 1u)) & 1u;\n  \t\t\tprevUnder[i*3 + j] = samp[0] + samp[1] * 2u + samp[2] * 4u + samp[3] * 8u;\n        }\n    }\n}\n\n#define I_NW  0\n#define I_N   1\n#define I_NE  2\n#define I_W   3\n#define I_MID 4\n#define I_E   5\n#define I_SW  6\n#define I_S   7\n#define I_SE  8\n\n\nuint map(ivec3 ip)\n{\n    // if cell already occupied, return\n    if (prevLevel[I_MID] != NONE)\n        return prevLevel[I_MID];\n    \n    // anything to grow from?\n    uint solidContact = \n        max(prevUnder[I_MID],\n            max(prevAbove[I_MID],\n                max(prevLevel[I_N],\n                    max(prevLevel[I_E],\n                        max(prevLevel[I_S], prevLevel[I_W]))))\n    );\n    \n    // we do need a foundation\n    if (ip.y == 0)\n        solidContact = ROCK;\n    \n    // but no castles in the sky, lets be realistic\n    if (solidContact == NONE)\n        return NONE;\n    \n    // terrain should be ~lumpy~\n    int terrAdjCount = ip.y == 0 ? 99 : 0;\n    for (int i=0; i<9; i++) {\n        terrAdjCount += prevAbove[i] >= DIRT ? 1 : 0;\n        terrAdjCount += prevLevel[i] >= DIRT ? 1 : 0;\n        terrAdjCount += prevUnder[i] >= DIRT ? 1 : 0;\n    }\n    \n    // do terrain\n    vec3 p = vec3(ip);\n    vec4 noise8 = texture(iChannel0, vec3(ip)/256.0);\n    vec4 noise16 = texture(iChannel0, vec3(ip)/512.0);\n    vec4 noise32 = texture(iChannel0, vec3(ip)/1024.0);\n    vec4 noise128 = texture(iChannel0, vec3(ip)/4096.0);\n    \n    float hdirt = noise32[0] * 28.0 - 12.0 + noise128[0] * 4.0;\n    float dirtbump = noise8[0]*smoothstep(0.5, 1.0, noise16[0])*10.0-3.0;\n    hdirt += dirtbump;\n    float hsand = sqrt(max(0.0, hdirt*2.0)) * (noise32[1]*0.5 - 0.25);\n    \n    // rocks don't grow on trees, etc\n    if (solidContact >= DIRT && terrAdjCount > 3) {\n        if (p.y < hsand) return SAND;\n        if (p.y < hdirt && p.y + noise32.g >= hdirt) return GRASS;\n        if (p.y < hdirt) return DIRT;\n\n        if (hdirt > 1.0) {\n            vec4 rocks = texture(iChannel1, vec2(ip.xz)/64.0) * smoothstep(0.3, 0.8, noise128.g);\n            float hrocks = smoothstep(0.2, 0.8, rocks.r) * 12.0 + hdirt*0.7;\n            if (p.y < hrocks) return ROCK;\n            if (p.y > hrocks*0.7 && p.y < hrocks*1.3) return COBBLESTONE;\n        }\n    }\n    \n    // grow trees\n    float rnd = fract(324.63*sin(iTime*42.2526*float(ip.x*1000 + ip.z* 80 + ip.y)));\n    if (rnd < 0.2) {\n        \n        // trunks\n        if ((prevUnder[I_MID] == DIRT || prevUnder[I_MID] == WOOD) && prevAbove[I_MID] == NONE) {\n            bool hasRoom = true;\n            for (int i=0; i<9; i++)\n                hasRoom = hasRoom && (prevLevel[i] != WOOD);\n\n            if (hasRoom) {\n                if (rnd < 0.03 || ip.y > 27)\n                    return LEAVES;\n                else\n                    return WOOD;\n            }\n        }\n        \n        // branches\n        bool adjToTrunk = (\n               (prevLevel[I_N] == WOOD && prevAbove[I_N] == WOOD && prevUnder[I_N] == WOOD)\n            || (prevLevel[I_E] == WOOD && prevAbove[I_E] == WOOD && prevUnder[I_E] == WOOD)\n            || (prevLevel[I_S] == WOOD && prevAbove[I_S] == WOOD && prevUnder[I_S] == WOOD)\n            || (prevLevel[I_W] == WOOD && prevAbove[I_W] == WOOD && prevUnder[I_W] == WOOD)\n        );\n        bool aboveBelowClear = (\n               prevUnder[I_MID] == NONE && prevAbove[I_MID] == NONE\n            && prevUnder[I_MID] == NONE && prevAbove[I_MID] == NONE\n        );\n        bool diagonalsClear = (\n            prevUnder[I_NE] == NONE && prevLevel[I_NE] == NONE && prevAbove[I_NE] == NONE\n            && prevUnder[I_SE] == NONE && prevLevel[I_SE] == NONE && prevAbove[I_SE] == NONE\n            && prevUnder[I_SW] == NONE && prevLevel[I_SW] == NONE && prevAbove[I_SW] == NONE\n            && prevUnder[I_NW] == NONE && prevLevel[I_NW] == NONE && prevAbove[I_NW] == NONE\n        );\n        \n        if (adjToTrunk && aboveBelowClear && diagonalsClear)\n            return WOOD;   \n        \n        // leaves\n        if (rnd < 0.05 && solidContact < DIRT) {\n            int woodCount = 0;\n            int leavesCount = 0;\n            for (int i=0; i<9; i++) {\n                if (prevAbove[i] == WOOD) woodCount++;\n                if (prevLevel[i] == WOOD) woodCount++;\n                if (prevUnder[i] == WOOD) woodCount++;\n                if (prevAbove[i] == LEAVES) leavesCount++;\n                if (prevLevel[i] == LEAVES) leavesCount++;\n                if (prevUnder[i] == LEAVES) leavesCount++;\n            }\n            \n            int leafLimit = int(4.0 * (noise16.g + noise32.g));\n            leafLimit = min(leafLimit, leafLimit + ip.y - int(hdirt) - 4);\n\n            if (!adjToTrunk && woodCount > 0 && leavesCount < leafLimit)\n                return LEAVES;\n            \n            bool isFrond = (\n                (prevAbove[I_N] == LEAVES && prevLevel[I_N] == LEAVES)\n                || (prevAbove[I_S] == LEAVES && prevLevel[I_S] == LEAVES)\n                || (prevAbove[I_E] == LEAVES && prevLevel[I_E] == LEAVES)\n                || (prevAbove[I_W] == LEAVES && prevLevel[I_W] == LEAVES)\n            );\n            \n            if (isFrond && leavesCount < leafLimit + 1)\n                return LEAVES;\n            \n        }\n    }\n    \n    return NONE;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= 512.0 || fragCoord.y >= 512.0) {\n        discard;\n        return;\n    }\n    \n    uint counter = floatBitsToUint(texelFetch(iChannel2, ivec2(0, 0), 0))[0];\n    if (ivec2(fragCoord) == ivec2(0, 0)) {\n        fragColor = uintBitsToFloat(uvec4(counter + 1u, 0u, 0u, 0u));\n        return;\n    }\n    \n    ivec2 uv = ivec2(fragCoord.xy);\n    initPrev(uvec2(uv));\n    uvec4 data = prev[I_MID];\n    \n    uint updateIndex = (counter) % 30u;\n    initLocalPrev(updateIndex);\n    uint terr = map(ivec3(uv.x, updateIndex, uv.y));\n    data |= ((uvec4(terr) >> uvec4(0u, 1u, 2u, 3u)) & 1u) << updateIndex;    \n    data |= uint(1<<30);\n    \n    fragColor = uintBitsToFloat(data);\n}","name":"Buf A","description":"","type":"buffer"}]}