{"ver":"0.1","info":{"id":"l3fcRn","date":"1726267840","viewed":100,"name":"Byzantine Church","username":"fishe","description":"Small Byzantine church with ray marching.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float infinity = 999.9; // 1.0 / 0.0;\nconst float pi = atan(1.0, 1.0) * 4.0;\nconst float epsilon = 0.001;\n\n// https://iquilezles.org/articles/distfunctions/\n\nfloat ndot(vec2 a, vec2 b){\n    return a.x*b.x - a.y*b.y;\n}\n\nfloat cylinder(vec3 p, float r, float h){\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rhombus(vec3 p, float la, float lb, float h){\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y), p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat solidangle( vec3 p, vec2 c, float ra ){\n    vec2 q = vec2( length(p.xz), p.y );\n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat prism(vec3 p, vec2 h){\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat arch(vec3 p, float r, float h, float d){\n    return min(cylinder(p.xzy, r, d), box(p + vec3(0.0, h, 0.0), vec3(r, h, d)));\n}\n\nfloat arches(vec3 p){\n    float t = infinity;\n    t = min(t, arch(p.zyx - vec3(0.0, -0.5, 2.6), 0.6, 1.0, 1.0));\n    t = min(t, arch(p.zyx - vec3(1.25, -0.5, 2.6), 0.17, 0.15, 1.0));\n    t = min(t, arch(p.zyx - vec3(0.0, 1.5, 1.8), 0.07, 0.1, 1.0));\n    t = min(t, cylinder(p.zxy - vec3(0.0, 2.6, 0.5), 0.14, 1.0));\n    return t;\n}\n\nfloat material1(vec3 p){\n    float t = infinity;\n    t = min(t, box(p + vec3(0.0, 0.8, 0.0), vec3(1.8, 0.7, 1.8)));\n    t = min(t, box(p, vec3(1.0, 1.1, 1.0)));\n    t = min(t, rhombus(p.yzx + vec3(0.1, 0.0, 0.0), 0.6, 1.8, 1.8));\n    t = min(t, cylinder(p - vec3(0.0, 0.5, 0.0), 0.9, 1.3));\n    t = min(t, prism(p.xzy - vec3(0.0, 0.0, 2.5), vec2(0.03, 0.3)));\n    t = min(t, prism(p.xyz - vec3(0.0, 2.6, 0.0), vec2(0.03, 0.2)));\n    t = min(t, prism(p.zyx - vec3(0.0, 2.6, 0.0), vec2(0.03, 0.2)));\n    p.xz = abs(p.xz);\n    if(p.x < p.z) p.xz = p.zx;\n    t = min(t, box(p + vec3(0.0, 0.5, 0.0), vec3(1.8, 1.0, 1.0)));\n    t = min(t, rhombus(p.yxz - vec3(0.5, 0.0, 0.0), 0.5, 1.0, 1.8));\n    t = max(t, -arches(p));\n    return t;\n}\n\nfloat slate(vec2 p){\n    float n = 0.0;\n    n += abs(sin(p.y * 23.0));\n    //n += fract(p.x * 7.0) * 3.0;\n    n += pow(cos(p.x * 40.0) * 0.5 + 0.5, 0.4) * 0.5;\n    return n * 0.02;\n}\n\nfloat roof(vec3 p, float w, float h, float d){\n    float s = slate(p.xz);\n    return max(\n        rhombus(p.yzx, h, w, d) - s,\n        -rhombus(p.yzx + vec3(0.07, 0.0, 0.0), h, w, d + 1.0)\n    );\n}\n\nfloat material2(vec3 p){\n    float t = infinity;\n    t = min(t, solidangle(p - vec3(0.0, 1.1, 0.0), vec2(sin(1.0), cos(1.0)), 1.15) - slate(vec2(atan(p.x, p.z), length(p.zx))));\n    vec3 q = p;\n    q.xz = abs(q.xz);\n    if(q.x > q.z) q.xz = q.zx;\n    t = min(t, roof(q + vec3(0.0, -0.5, 0.0), 1.05, 0.5, 1.85));\n    t = min(t, max(roof(p.xyz + vec3(0.0, 0.1, 0.0), 1.85, 0.6, 1.85), -box(q, vec3(0.95, 1.5, 3.0))));    \n    return t;\n}\n\nfloat map(vec3 p){\n    float a = material1(p);\n    float b = material2(p);\n    return min(a, b);\n}\n\nvec3 nor(vec3 p){\n    float e = 0.001;\n    return normalize(\n        map(p) - vec3(map(p - vec3(e, 0.0, 0.0)),\n                      map(p - vec3(0.0, e, 0.0)),\n                      map(p - vec3(0.0, 0.0, e)))\n    );\n}\n\nvec4 surface(sampler2D t, vec3 p, vec3 n){\n    vec4 cx = texture(t, p.yz);\n    vec4 cy = texture(t, p.xz);\n    vec4 cz = texture(t, p.xy);\n    vec3 m = n * n;\n    return (cx * m.x + cy * m.y + cz * m.z) / (m.x + m.y + m.z);\n}\n\nvoid mat(vec3 p, out vec3 normal, out vec3 colour){\n    float a = material1(p);\n    float b = material2(p);\n    normal = nor(p);\n    colour = a < b ? surface(iChannel0, p, normal).rgb\n                   : surface(iChannel1, p, normal).rgb;\n}\n\nfloat march(vec3 origin, vec3 direction){\n    float t = 0.0;\n    for(int i = 0; i < 100; i++){\n        if(t > 10.0) return infinity;\n        float d = map(origin + direction * t);\n        if(d < epsilon) return t;\n        t += d;\n    }\n    return -1.0;\n}\n\nvec3 background(vec3 direction){\n    vec3 a = vec3(0.9, 0.9, 0.9);\n    vec3 b = vec3(0.6, 0.8, 1.0);\n    return mix(a, b, direction.y * 0.5 + 0.5);\n}\n\nvec3 gen(vec2 p, float fov, vec3 from, vec3 to){\n    p = p / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 n = normalize(vec3(p, -1.0 / tan(fov / 2.0))); \n    vec3 z = normalize(from-to);\n    vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    vec3 y = cross(z, x);\n    return x * n.x + y * n.y + z * n.z;\n}\n\nvoid mainImage(out vec4 c, in vec2 p){\n    \n    float theta, phi;\n    if(iMouse.z > 0.0){\n        theta = iMouse.x/iResolution.x * 2.0 * pi;\n        phi = iMouse.y/iResolution.y * pi;\n    }else{\n        theta = -iTime/4.0;\n        phi = 1.2;\n    }\n\n    vec3 origin  = vec3(\n        cos(theta) * sin(phi),\n        cos(phi),\n        sin(theta) * sin(phi)\n    ) * 5.0;\n\n    vec3 direction = gen(p, 1.4, origin, vec3(0.0));\n        \n    float t = march(origin, direction);\n    \n    if(t < 0.0){\n    \n        c.rgb = vec3(0.0);\n    \n    }else if(t < infinity){\n    \n        vec3 light1 = normalize(vec3(23.0, 20.0, 17.0));\n        vec3 light1_col = vec3(1.0, 0.9, 0.8);\n        vec3 light2 = normalize(vec3(0.5, 1.0, -0.8));\n        vec3 light2_col = vec3(0.5, 0.6, 0.8);\n        vec3 light3 = normalize(vec3(-1.0, -0.4, -0.4));\n        vec3 light3_col = vec3(0.3, 0.3, 0.4);\n\n        vec3 normal, colour;\n        mat(origin + direction * t, normal, colour);\n        \n        float s = march(origin + direction * (t - 0.05), light1) == infinity ? 1.0 : 0.0;\n        c.rgb = colour * max(0.0, dot(normal, light1)) * s * light1_col;\n        c.rgb += colour * max(0.0, dot(normal, light2)) * light2_col;\n        c.rgb += colour * max(0.0, dot(normal, light3)) * light3_col;\n        \n    }else{\n    \n        c.rgb = background(direction);\n        \n    }\n    \n    c.a = 1.0;\n\n}","name":"Image","description":"","type":"image"}]}