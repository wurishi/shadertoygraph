{"ver":"0.1","info":{"id":"MtGyWK","date":"1537716058","viewed":848,"name":"Pathtracer Without Spheretracing","username":"slerpy","description":"This shader has been heavily inspired by [url=https://www.youtube.com/watch?v=9r8pxIogxZ0]noby's awesome 4k intro[/url] (I've basically been trying to copy it as closely as possible), so please check that out if you haven't already!","likes":41,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","basic","dof","shadows","reflections","pathtracer","tracing","realtime","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    c = 8. * c / c.w;\n    //acc = mix(acc, smoothstep(.0, 1., acc), .3);\n\t\n    c /= 1.0 + c;\n    \n    vec4 g = (c + c.zxyw + c.yzxw) / 3.0;\n    c = mix(g, c, 1.6);\n    \n    c = smoothstep(.0, 1., c);\n    \n    fragColor = pow(c, vec4(1) / 2.2);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TAU 6.28318530718\n#define PI 3.14159265358\n\n#define FAR 1e5\n\n//#define FOG 30.\n#define CA 0.01\n#define AA 1.1\n#define DOF 0.08\n\n//Set this number as high as\n//your machine can handle!\n#define SAMPLES 40\n\n#define BOUNCES 4\n#define TINT 0.1\n\n//#define STILL\n#define OFFSET 2.87\n\n#ifdef STILL\n#define tt OFFSET\n#else\n#define tt (iTime + OFFSET)\n#endif\n\n\n// Utility\n\nmat3 rx(float a){ float sa=sin(a), ca=cos(a); return mat3(1.,0.,0.,0.,ca,sa,0.,-sa,ca); }\nmat3 ry(float a){ float sa=sin(a), ca=cos(a); return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca); }\nmat3 rz(float a){ float sa=sin(a), ca=cos(a); return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.); }\n\nfloat box(vec3 p){ p=abs(p); return max(max(p.x, p.y), p.z); }\nfloat box(vec2 p){ p=abs(p); return max(p.x, p.y); }\n\n\n\n// Hashing functions\n\nvec4 rv;\n\nvoid shuffle()\n{\n    rv = fract(1e4*sin(rv) + rv.wxyz + 0.5);\n}\n\nvec3 hemi(vec3 n)\n{\n\tvec3  uu = normalize(cross(n, vec3(1)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = 6.2831*rv.x;\n    float rb = sqrt(rv.y);\n\tfloat rx = rb*cos(ra); \n\tfloat ry = rb*sin(ra);\n\tfloat rz = sqrt(1.0-rv.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n\treturn normalize(rr);\n}\n\n\n\n// Tracing\n\nfloat t;\nvec3 sp, sn, mat;\n\n\nfloat sphere(vec3 ro, vec3 rd)\n{\n    vec3 p = ro + ( dot(-ro, rd) * rd);\n\tfloat nt = length(p - ro) - sqrt(1. - dot(p,p));\n    if(nt < .001)nt = 1e+31;\n    \n    if(nt < t)\n    {\n        t = nt;\n        sp = ro + rd * t;\n        sn = normalize(sp);\n    }\n    \n    return nt;\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 n, float d)\n{\n    float nt = -(dot(ro,n) + d) / dot(n, rd);\n    if(nt < .001)nt = 1e+31;\n    \n    if(nt < t)\n    {\n        t = nt;\n        sp = ro + rd * t;\n        sn = n;\n    }\n    \n    return nt;\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{   \n    t = FAR;\n    \n    float ball = sphere(ro, rd);\n    \n    float lit_wall = FAR;\n    lit_wall = min(lit_wall, plane(ro, rd, vec3( 0, 1, 0), 1.));\n    lit_wall = min(lit_wall, plane(ro, rd, vec3( 0, 0,-1), 2.));\n    lit_wall = min(lit_wall, plane(ro, rd, vec3(-1, 0, 0), 4.));\n    \n    lit_wall = min(lit_wall, plane(ro, rd, vec3( 1, 0, 0), 8.));\n    lit_wall = min(lit_wall, plane(ro, rd, vec3( 0, 0, 1), 8.));\n    \n    plane(ro, rd, vec3( 0,-1, 0), 6.);\n    \n    mat = vec3(1, 0, 0);\n    \n    if(t == lit_wall)\n    {\n#if 1\n        float tm = tt + .2;\n        float h = sp.y + .6*round(sp.x/3.) - 0.001;\n        mat.y = step(.75, fract(.7*round(4.*tm) - h - 0.05));\n        mat.z = sin(h-tm);\n#else\n        vec3 q = abs(fract(sp)-.5);\n        q = min(q, q.zxy);\n        mat.y = step(min(q.x, q.y), .05);\n#endif\n    }\n    else if(t == ball)\n    {\n        mat = vec3(0,0,0);\n    }\n    \n    return t;\n}\n\n\n\n// Rendering\n\nvoid camera(out vec3 ro, out vec3 rd, in vec2 p)\n{\n#ifdef AA\n    p.xy += AA * (rv.xy-.5);\n    shuffle();\n#endif\n    \n    vec2 uv = (2.*p.xy-iResolution.xy)/iResolution.x;\n    vec2 ra = vec2(.2 + .2*cos(tt), -.7 + .6*sin(tt));\n    \n#ifdef DOF\n    vec2 dof = rv.xy - rv.zw;\n    vec2 adf = abs(dof);\n    dof = DOF * dof * sqrt(1. + abs(adf.x-adf.y));\n    shuffle();\n#else\n    vec2 dof = vec2(0);\n#endif\n    \n    mat3 rm = ry(ra.y) * rx(ra.x);\n\tro = rm * (vec3(-.5, 0, -3) + vec3(dof, 0));\n    rd = rm * normalize(vec3(uv-dof/length(ro), 1));\n    \n    ro += vec3(-.5,0,0);\n}\n\nvec3 aberrationColor(float f)\n{\n    f = f * 3.0 - 1.5;\n    return clamp(vec3(-f,1.0-abs(f),f),0.,1.);\n}\n\nvec4 render(vec2 coord)\n{\n    shuffle();\n    \n#ifdef CA\n    float sc = rv.x;\n    vec2 hR = 0.5 * iResolution.xy;\n    coord = exp(CA * sc) * (coord - hR) + hR;\n    shuffle();\n#endif\n    \n    vec3 ro, rd;\n    camera(ro, rd, coord);\n    \n    vec3 emit = vec3(0), absorb = vec3(1);\n    \n    for(int i=0; i<BOUNCES; i++)\n    {\n        tracer(ro, rd);\n        if(t > FAR)break;\n        \n        shuffle();\n        \n#ifdef FOG\n        float ft = FOG * rv.x * rv.y;\n        if(ft < t)\n        {\n            shuffle();\n            ro += rd * ft;\n            rd = hemi(rd);\n            continue;\n        }\n        \n        absorb *= exp(-0.3*ft/FOG);\n#endif\n        \n        vec3 color = mat.y * max(1. + vec3(mat.z, -TINT, -mat.z), .0);\n\n        emit += absorb * color;\n        absorb /= PI;\n\n        rd = normalize(mix(reflect(rd, sn), hemi(sn), mat.x));\n        ro = sp;\n    }\n    \n#ifdef CA\n    emit *= aberrationColor(sc) * 3.;\n#endif\n    \n    return vec4(emit, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef STILL\n    vec4 acc = texelFetch(iChannel0, ivec2(fragCoord), 0);\n#else\n    vec4 acc = vec4(0);\n#endif\n    \n    rv = vec4(fragCoord, iFrame, 1);\n    for(int i=0; i<16; i++)shuffle();\n    \n    for(int i=0; i<SAMPLES; i++)\n        acc += render(fragCoord);\n    \n    fragColor = acc;\n}","name":"Buffer A","description":"","type":"buffer"}]}