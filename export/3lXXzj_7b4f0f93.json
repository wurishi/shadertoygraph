{"ver":"0.1","info":{"id":"3lXXzj","date":"1563478380","viewed":194,"name":"My Mandelbox 1","username":"ankd","description":"my first mandelbox trial","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tMy Mandelbox 1\n\tauthor - ankd\n\tdate - 2019/07/19\n\n\treferences -\n\t<mandelbox>\n\t- http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\n\t- https://www.shadertoy.com/view/XscyD2\n\t<softshadow, ambient occlusion>\n\t- https://www.shadertoy.com/view/lsKcDD\n*/\n\n\n#define AA 1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = 1./iResolution.xy;\n    \n    vec3 col = vec3(0.);\n    for(int i=0;i<AA;i++) {\n        for(int j=0;j<AA;j++) {\n            col += texture(iChannel0, uv+offset*vec2(float(i), float(j))).rgb;\n        }\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define minRadius2 1.5\n#define fixedRadius2 4.0\nvoid sphereFold(inout vec3 p, inout float dz) {\n\tfloat r2 = dot(p, p);\n    if (r2<minRadius2) {\n        float tmp = fixedRadius2 / minRadius2;\n        p *= tmp;\n        dz *= tmp;\n    } else if (r2 < fixedRadius2) {\n    \tfloat tmp = fixedRadius2 / r2;\n        p *= tmp;\n        dz *= tmp;\n    }\n}\n#define foldingLimit 1.5\nvoid boxFold(inout vec3 p, inout float dz) {\n\tp = clamp(p, -foldingLimit, foldingLimit) * 2.0 - p;\n}\n\n#define Iterations 12\n#define Scale 2.0\nfloat mb(in vec3 p) {\n\tvec3 offset = p*1.2;\n    float dr = 1.0;\n    for(int i=0;i<Iterations; i++) {\n    \tboxFold(p, dr);\n        sphereFold(p, dr);\n        \n        p = Scale*p + offset;\n        dr = dr*abs(Scale)+1.0;\n    }\n    float r = length(p);\n    return r / abs(dr);\n}\n\nvec2 opU(in vec2 d1, in vec2 d2) { return d1.x<d2.x ? d1 : d2; }\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5, -1.);\n    res = opU(res, vec2(mb(p), 0.));\n    return res;\n}\n\n#define MARCH_MIN 0.5\n#define MARCH_MAX 50.\n#define MARCH_THR 1e-3\n#define MARCH_ITR 200\nvec2 rayMarch(in vec3 ro, in vec3 rd) {\n\tfloat d=MARCH_MIN, m=-1.;\n    for(int i=0;i<MARCH_ITR;i++) {\n    \tvec3 pos = ro + rd*d;\n        vec2 tmp = map(pos);\n        //tmp.x = max(tmp.x, MARCH_THR);\n        if(tmp.x<MARCH_THR || MARCH_MAX<tmp.x) break;\n        d += tmp.x*0.5;\n        m = tmp.y;\n    }\n    if(MARCH_MAX<d) m=-1.;\n    return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p) {\n\tvec2 e = vec2(1., -1.) * 5e-3;\n    return normalize(\n    \te.xyy * map(p+e.xyy).x +\n    \te.yxy * map(p+e.yxy).x +\n    \te.yyx * map(p+e.yyx).x +\n    \te.xxx * map(p+e.xxx).x\n    );\n}\nfloat diffuse(in vec3 n, in vec3 l, in float s) { return pow(clamp(dot(n, l), 0., 1.), s); }\nfloat specular(in vec3 r, in vec3 l, in float s) { return pow(clamp(dot(r, l), 0., 1.), s); }\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ ) {\n\t\tfloat h = map( ro + rd*t ).x;\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\nvec3 render(in vec3 ro, in vec3 rd) {\n\tvec2 res = rayMarch(ro, rd);\n    float d=res.x, m=res.y;\n    \n    if(m<0.) return vec3(0.);\n    \n    vec3 pos = ro+rd*d;\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor);\n    \n    vec3 lp = ro + vec3(0.);\n    vec3 ld = normalize(vec3(1.));\n    ld = normalize(lp - pos);\n    \n    \n    vec3 material = vec3(1.2, 1.1, .8);\n    \n    vec3 color = material;\n    \n    float dif = diffuse(nor, ld, 1.);\n    float sha = calcSoftshadow(pos, ld, 0.01, 0.3);\n    float spe = specular(ref, ld, 10.);\n\n    color *= dif * sha;\n    color += spe;\n    \n    float occ = calcAO(pos, nor);\n    float amb = clamp(0.5+0.5*nor.y, 0., 1.);\n    color += amb*occ*vec3(0.5, 0.3, 0.1);\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord.xy*2.-iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = 7.0*sin(10.+iTime*vec3(0.07, 0.09, 0.05));\n    vec3 tar = vec3(0.);\n    vec3 cz = normalize(tar - ro);\n    float cr = iTime*0.1;\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy,cz) * vec3(p, 2.));\n    \n    vec3 col = render(ro, rd);\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}