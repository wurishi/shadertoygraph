{"ver":"0.1","info":{"id":"XlsSRr","date":"1434102286","viewed":499,"name":"Arc - distance 2D","username":"ajs15822","description":"Signed distance to 2D arc segment. working on optimizing, tips welcome","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Signed Distance to 2D Arc by Adam Simmons\n// Based roughly on code by Behdad Esfahbod\n\n// Arc segment with certain depth\nstruct Arc {\n  vec2 p0;\n  vec2 p1;\n    \n  // Depth of the Arc, valid range of (-1.0, 1.0)\n  // with 0.0 = straight line, 1.0 = semi-circle\n  float d;\n};\n\nvec2 perpendicular (const vec2 v) {\n  return vec2 (-v.y, v.x);\n}\n\nfloat tan2atan (float d) {\n  return 2. * d / (1. - d * d);\n}\n\nvec2 computeArcCenter (const Arc a) {\n  return mix (a.p0, a.p1, .5) +\n\t perpendicular (a.p1 - a.p0) / (2. * tan2atan (a.d));\n}\n\nfloat sdArcWedge (Arc a, const vec2 p) {\n  vec2 c = computeArcCenter (a);\n  return -sign (a.d) * (distance (a.p0, c) - distance (p, c));\n}\n\nbool isPointInsideArcWedge (const Arc a, const vec2 p) {\n  float d2 = tan2atan (a.d);\n  return dot (p - a.p0, (a.p1 - a.p0) * mat2(1,  d2, -d2, 1)) >= 0. &&\n\t dot (p - a.p1, (a.p1 - a.p0) * mat2(1, -d2,  d2, 1)) <= 0.;\n}\n\nfloat sdArcOutsideWedge (const Arc a, const vec2 p) {\n  vec2 m = mix (a.p0, a.p1, .5);\n  float d2 = tan2atan (a.d);\n  if (dot (p - m, a.p1 - m) < 0.)\n    return -dot (p - a.p0, normalize ((a.p1 - a.p0) * mat2(+d2, -1, +1, +d2)));\n  else\n    return -dot (p - a.p1, normalize ((a.p1 - a.p0) * mat2(-d2, -1, +1, -d2)));\n}\n\nfloat sdArc(Arc arc, vec2 p) {\n  // trick to avoid depth values very close to 0.0\n  arc.d = max(abs(arc.d), 0.0001) * (2. * step(0.9, sign(arc.d)) - 1.);\n  \n  if (isPointInsideArcWedge(arc, p))\n    return sdArcWedge(arc, p);\n  \n  return min (distance (p, arc.p0), distance (p, arc.p1)) * sign(sdArcOutsideWedge(arc, p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    Arc arc;\n    arc.p0 = vec2(-1.0, 0.0);\n    arc.p1 = vec2(1.0, 0.0);\n    arc.d = cos( iTime ) / 1.01;\n\n\tfloat d = sdArc(arc, p );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}