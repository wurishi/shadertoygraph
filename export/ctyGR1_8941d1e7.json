{"ver":"0.1","info":{"id":"ctyGR1","date":"1683523347","viewed":83,"name":"Multifocal Lemniscate","username":"Envy24","description":"Example from \"Geometry for Programmers\", \n10.3.6 A play button made of multifocal lemniscate (commented in mainImage).\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lemniscate","multifocal"],"hasliked":0,"parentid":"dsXXzX","parentname":"SDF template"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE ( 4. )\n#define ORIGIN      ( vec2(0) )\n\n//#define METRIC(B, E) ( L1(B, E) )\n#define METRIC(B, E) ( L2(B, E) )\n//#define METRIC(B, E) ( Linf(B, E) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n        \n    /*Example from book.*\n    vec2 f0 = vec2(-0.6, -1.12), f1 = vec2(-0.6, 1.12),\n         f2 = vec2(-1.12, -2.06), f3 = vec2(-1.12, 2.06),\n         f4 = vec2(0.4, 0), f5 = vec2(1.2, 0.);\n         \n    float minDist = \n        METRIC(NDC, f0) *\n        METRIC(NDC, f1) *\n        METRIC(NDC, f2) *\n        METRIC(NDC, f3) *\n        METRIC(NDC, f4) *\n        METRIC(NDC, f5) - pow(2., 6.);\n    /*Randomized.*/\n    randomize_focuses(iTime*0.75);\n    float minDist = \n        METRIC(NDC, focuses[0]) *\n        METRIC(NDC, focuses[1]) *\n        METRIC(NDC, focuses[2]) *\n        METRIC(NDC, focuses[3]) *\n        METRIC(NDC, focuses[4]) *\n        METRIC(NDC, focuses[5]) - pow(2., 6.);\n    /**/\n\n    float aa = pow(2., 14.)/iResolution.y;\n    vec3 color = vec3(smoothstep(0., aa, sign(minDist)*minDist*minDist));\n    \n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n}\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\nfloat Linf(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return max(abs(D.x), abs(D.y));\n}\n\nconst int num_of_focuses = 6;\nvec2 focuses[num_of_focuses] = vec2[num_of_focuses](\n    vec2(-0.6, -1.12), vec2(-0.6, 1.12),\n    vec2(-1.12, -2.06), vec2(-1.12, 2.06),\n    vec2(0.4, 0), vec2(1.2, 0.)\n);\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hash2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nvoid randomize_focuses(float time)\n{\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < num_of_focuses; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = hash2to2(x, y);\n        vec2 n = hash2to2(x + 1u, y + 2u);\n    \n        focuses[k] = (c * (1. - t) + n * t) * 2.2;\n    }\n}","name":"Common","description":"","type":"common"}]}