{"ver":"0.1","info":{"id":"Xfsfz7","date":"1723537793","viewed":28,"name":"ghost is coming...","username":"vovach777","description":"simple perlin noise 2D effect ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","perlinnoise","effect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 luma_to_color(float luma) \n{\n    vec3 color = vec3(sin(iTime+luma*PI), sin(iTime*1.2+luma*PI), 0.)*0.5+0.5;\n    color.b = clamp(1. - color.r - color.g,0.,1.);\n    return color;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = rotate( 2.*fragCoord/iResolution.xy - .1, iTime*0.1);\n\n    // Time varying pixel color\n    float luma = pow(1.-abs( ValuePerlin2D( uv+iTime,.75) + ValuePerlin2D( uv * 4.,0.5)*0.1),4.) *  ( ValuePerlin2D( uv,1.)*0.5+0.5 )*2.5;\n\n    // Output to screen\n    fragColor = vec4( luma_to_color(luma)*luma, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\nvec2 Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\n\nvoid FAST32_hash_2D( \tvec2 gridcell,\n                        out vec4 hash_0,\n                        out vec4 hash_1,\n                        out vec4 hash_2\t)\t//\tgenerates 3 random numbers for each of the 4 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n    const vec2 OFFSET = vec2( 26.0, 161.0 );\n    const float DOMAIN = 71.0;\n    const vec3 SOMELARGEFLOATS = vec3( 951.135664, 642.949883, 803.202459 );\n    vec4 P = vec4( gridcell.xy, gridcell.xy + 1.0 );\n    P = P - floor(P * ( 1.0 / DOMAIN )) * DOMAIN;\n    P += OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    hash_0 = fract( P * ( 1.0 / SOMELARGEFLOATS.x ) );\n    hash_1 = fract( P * ( 1.0 / SOMELARGEFLOATS.y ) );\n    hash_2 = fract( P * ( 1.0 / SOMELARGEFLOATS.z ) );\n}\n\nfloat ValuePerlin2D( vec2 P, float blend_val )\n{\n    //\testablish our grid cell and unit position\n    vec2 Pi = floor(P);\n    vec4 Pf_Pfmin1 = P.xyxy - vec4( Pi, Pi + 1.0 );\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_value, hash_x, hash_y;\n    FAST32_hash_2D( Pi, hash_value, hash_x, hash_y );\n\n    //\tcalculate the gradient results\n    vec4 grad_x = hash_x - 0.49999;\n    vec4 grad_y = hash_y - 0.49999;\n    vec4 grad_results = inversesqrt( grad_x * grad_x + grad_y * grad_y ) * ( grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww );\n    grad_results *= 1.4142135623730950488016887242097;\t\t//\tscale the perlin component to a -1.0->1.0 range    *= 1.0/sqrt(0.5)\n    grad_results = mix( (hash_value * 2.0 - 1.0), grad_results, blend_val );\n\n    //\tblend the results and return\n    vec2 blend = Interpolation_C2( Pf_Pfmin1.xy );\n    vec4 blend2 = vec4( blend, vec2( 1.0 - blend ) );\n    return dot( grad_results, blend2.zxzx * blend2.wwyy );\n}\n\n\nfloat periodic(float v) {    \n  return clamp( abs( mod(v,1.) - 0.5)*2., 0., 1.);\n}\n\nvec2 rotate(vec2 uv, float angle)\n{\n\nfloat c = cos(angle);\nfloat s = sin(angle);\nmat2 rotationMatrix = mat2(c, -s, s, c);\n\n\nreturn rotationMatrix * (uv - 0.5) + 0.5;\n}\n","name":"Common","description":"","type":"common"}]}