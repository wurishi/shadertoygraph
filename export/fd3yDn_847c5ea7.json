{"ver":"0.1","info":{"id":"fd3yDn","date":"1653291522","viewed":78,"name":"Oddly Satisfying Render 1","username":"QuantumShader","description":"My First attempt at SDF modelling from scratch without a tutorial. Hence it surely is very inefficient.\n\nRecreation of render by arbenl1berateme\nhttps://youtu.be/iLRsCtd5P9s?t=329\n\nRaymarching base template used\nhttps://www.shadertoy.com/view/Ndl3WS","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","modelling","seamless","satisfying","pendulm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Oddly Satisfying Render 1\" by QuantumShader. https://shadertoy.com/view/fd3yDn\n// 2022-05-25 14:19:06\n\n#define MAX_STEPS 200\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define PI 3.14159265\n\n#define S smoothstep\n#define T iTime\n\n// Disk Debug\nconst int DISK_COUNT = 4;\nconst float yPivot = 8.;\nconst float DISK_RAD = 0.17;\nconst float DISK_WIDTH = 0.037;\nconst float SPEED =1.6;\nconst float AMPLITUDE = 1.3; \n\n// Render Debug\nconst int NUM_BOUNCES = 2;\nconst bool FREE_ROTATION = false;\nconst bool SPINNING = true;\n\n// Material Setup\nconst int MAT_BASE = 1;\nconst int MAT_DISK = 2;\nconst int MAT_LINE = 3;\nconst int MAT_TABLE_INNER = 4;\nconst int MAT_TABLE_OUTER = 5;\n\nmat2 Rot(float a) \n{\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nmat3 rotateX(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\nmat3 rotateY(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 Min(vec3 a, vec3 b)\n{\n    return a.x<b.x ? a : b;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdBox(vec3 p, vec3 s) \n{\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, float rad)\n{\n    return (length(p) - rad);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xy)-2.0*ra+rb, abs(p.z) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdLineSeg(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ap=p-a, ab=b-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    vec3 c = a + ab*t;\n    \n    return length(p - c);\n}\n\nfloat sdBase(vec3 p)\n\n{\n\n    // main shape and cut out sphere\n    float rCut = 1.7;\n    float baseMain = sdSphere(p - vec3(0, -0.5, 0), 1.2);\n    float baseSphereCut = sdSphere(p - vec3(0, rCut+0.08, 0), rCut);\n    \n    float d = opSmoothSubtraction(baseSphereCut, baseMain, 0.05);\n    \n    \n    // cut out disk paths\n    float dCutRad = yPivot;\n    float dCutWidth = DISK_WIDTH + 0.02;\n    float dUnion = 1.;\n    for(int i=0; i<DISK_COUNT; i++)\n        {\n \n        // rotate in xz-plane\n        vec3 pDisk = rotateY(float(i) * PI/float(DISK_COUNT)) * (p - vec3(0, 2.*dCutRad + 0.05,0));        \n \n        float diskCut = sdRoundedCylinder(pDisk, dCutRad, 0.03, dCutWidth);\n        \n        dUnion = min(dUnion, diskCut);\n    }\n    d = opSmoothSubtraction(dUnion, d, 0.05);\n    \n    return d;\n}\n\n\nvec3 sdTable(vec3 p)\n{\n    //float table = p.y - 0.02;\n    float r1 = 1.6;\n    float r2 = 1.8;\n    float h = 3.;\n\n    float ring1 = sdCappedCylinder(p - vec3(0, -h + 0.02, 0), r1, h) - 0.05;\n    float ring2 = sdCappedCylinder(p - vec3(0, -h +0.05 , 0), r2, h) - 0.05;\n    float baseCutOut = sdSphere(p - vec3(0, -0.5, 0), 1.21);\n    \n    \n    float d = opSmoothSubtraction(ring1-0.002, ring2, 0.1);\n    d = min(ring1, d);\n    \n    int mat = d==ring1 ? MAT_TABLE_INNER : MAT_TABLE_OUTER;\n    \n    d = opSmoothSubtraction(baseCutOut, d, 0.1);\n    \n    return vec3(d, mat, 0.);\n}\n\nvec3 diskTransform(vec3 p, int diskID)\n{\n    float h = 2. * DISK_RAD + 0.1;\n    \n    // rotate in xz-plane\n    vec3 pDisk = rotateY(float(diskID) * PI/float(DISK_COUNT)) * (p - vec3(0, h, 0));\n    \n    // swinging motion\n    pDisk.y -= yPivot;\n        // check if number of disks is even or odd and \n        // use appropriate phase offset\n    float check = mod(float(DISK_COUNT), 2.) == 0. ? 1.62 : 2.;\n    float angle = sin(SPEED*T + check*float(diskID)*PI / float(DISK_COUNT)) * AMPLITUDE / yPivot;\n    pDisk.xy *= Rot(angle);\n    pDisk.y += yPivot;\n    \n    return pDisk;\n}\n\n// create swinging disks\nvec3 sdDisk(vec3 p, int diskID)\n{\n    \n    vec3 pDisk = diskTransform(p, diskID);\n    \n\n    // create disk\n    float disk = sdRoundedCylinder(pDisk, DISK_RAD -0.02, 0., DISK_WIDTH) - 0.02;\n    disk += sin(pDisk.x * 30.)*0.0002;\n\n    // create ropes + attachment ring\n    float ring = sdCappedCylinder(pDisk - vec3(0, 2.*DISK_RAD -0.05 + 0.03, 0), 0.01, 0.03) -0.01;\n    float line = sdLineSeg(pDisk, vec3(0, 2.*DISK_RAD-0.05, 0), vec3(0, yPivot, 0) ) - 0.005;\n\n    disk = min(disk, ring);\n    float d = min(disk, line);\n\n   \n    return vec3(d, d==disk ? MAT_DISK : MAT_LINE, float(diskID));\n}\n\n\nvec3 GetDist(vec3 p) {\n    \n    vec3 disks = vec3(1., MAT_DISK, 0.);\n    \n    // make base + bump map\n    float base = sdBase(p);\n    base += sin(p.x*7.)*0.0045;\n    base += 0.0008*(1.-texture(iChannel2, vec2(p.xz)).r);\n    \n    \n    // make table\n    vec3 table = sdTable(p);\n    float d = min(table.x, base);\n    \n    // make disks\n    for(int i=0; i<DISK_COUNT; i++)\n    {\n        vec3 disk = sdDisk(p, i);\n        disks = Min(disk, disks);\n    }\n    \n    d = min(disks.x, d);\n    \n    int mat = 0;\n    int ID = 0;\n    \n    if(d==base)\n        mat = MAT_BASE;\n    else if(d==table.x)\n        mat = int(table.y);\n    else if(d==disks.x)\n        mat = int(disks.y);\n        ID = int(disks.z);\n        \n    return vec3(d, mat, ID);\n}\n\n// https://iquilezles.org/articles/rmshadows/\n// https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float k, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<512; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n          res = min( res, k*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, k*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n      \n    return pow(res, 0.8);\n    return res * res * (3. -2.*res);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = GetDist( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, int max_steps, float max_dist, float surf_dist) \n{\n\tfloat dO=0.;\n    vec3 dSMat = vec3(0);\n    \n    for(int i=0; i<max_steps; i++) {\n    \tvec3 p = ro + rd*dO;\n        dSMat = GetDist(p);\n        \n        dO += dSMat.x;\n        if(dO>max_dist || abs(dSMat.x)<surf_dist) break;\n    }\n    \n    return vec3(dO, dSMat.y, dSMat.z);\n}\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvec3 Render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int iBounce, int max_steps, float max_dist, float surf_dist)\n{\n    vec3 col = clamp(0.+texture(iChannel0, rd).ggg, 0., 1.);\n    vec3 dMat = RayMarch(ro, rd, max_steps, max_dist, surf_dist);\n    \n    ref = vec3(0);\n    if(dMat.x<max_dist) {\n        vec3 p = ro + rd * dMat.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 refTex = texture(iChannel0, r).rgb;\n        float fresnel = pow(clamp(1.-dot(n, -rd), 0., 1.), 5.);\n        \n        // key light & shadow\n        int technique = 0; // 0 is basic, 1 more complex \n        float k = 30.; // softness: 10 soft, 128+ sharp\n        vec3 lig = normalize(vec3(1.2, 2, -2.1));\n        float sShadow = 1.; // no shadows on 2nd+ bounce\n        if(iBounce == 0) sShadow = calcSoftshadow(p, lig, 0.001, 10., k, technique);\n        float dif = clamp(dot(n, lig), 0.2, 1.) * sShadow;\n        col = vec3(dif);\n        \n\n      \n        // Materials and texture\n        \n        int mat = int(dMat.y);\n        \n        if(mat==MAT_BASE){\n            col *= vec3(.9*dif);\n            ref = vec3(mix(.001, .2, fresnel));\n            \n            // Texture (triplanar projection)\n            vec3 roughXZ = 1.- texture(iChannel2, vec2(p.xz)).rrr;\n            vec3 roughXY = 1.-texture(iChannel2, vec2(p.xy)).rrr;\n            vec3 roughYZ = 1.-texture(iChannel2, vec2(p.yz)).rrr;\n            \n            vec3 nTex = abs(n);\n            \n            col *= mix(roughXZ * nTex.y + roughXY * nTex.z + roughYZ * nTex.x, vec3(1.), 0.6);\n        }\n        else if(mat==MAT_TABLE_INNER){\n            col *= vec3(1.*dif);\n            ref = vec3(mix(.1, .99, fresnel));\n            \n            // Texture\n            vec2 tableUV = p.xz * .5;\n            tableUV.x *= 1.8;\n            vec3 marble = texture(iChannel1, tableUV).rrr;\n            marble = mix(marble, vec3(1.), 0.01);\n            \n            col = mix(col, marble, pow(1.-marble.r,3.));\n        \n        }\n        else if(mat==MAT_DISK){\n            col *= 0.01*dif;\n              \n            // apply disk transformation to texture\n            vec3 pDisk = diskTransform(p, int(dMat.z));\n            vec3 nDisk = normalize(diskTransform(n, int(dMat.z)));\n            \n            // Texture (triplanar projection)\n            vec3 roughXZ = 1.-texture(iChannel3, 0.5+ 1.*vec2(pDisk.xz)).rrr;\n            vec3 roughXY = 1.-texture(iChannel3, 0.5+ 1.*vec2(pDisk.xy)).rrr;\n            vec3 roughYZ = 1.-texture(iChannel3, 0.5+ 1.*vec2(pDisk.yz)).rrr;\n            \n            vec3 nTex = abs(nDisk);\n            \n            vec3 tex = pow(roughXZ * nTex.y + roughXY * nTex.z + roughYZ * nTex.x, vec3(2.));\n            \n            col *= tex;\n            //col = nTex;\n            \n            // reflections\n            ref = .85*vec3(1, .7, .3) * mix(vec3(0.2), vec3(1.), tex.r);\n            if(iBounce == NUM_BOUNCES-1) col += ref*refTex;\n            //col= nTex;\n            \n        \n        }\n        else if(mat==MAT_TABLE_OUTER){\n            col *= 0.01*dif;\n              \n            \n            // Texture (triplanar projection)\n            vec3 roughXZ = 1.-texture(iChannel3, 0.5+ vec2(p.xz)).rgb;\n            vec3 roughXY = 1.-texture(iChannel3, 0.5+ vec2(p.xy)).rgb;\n            vec3 roughYZ = 1.-texture(iChannel3, 0.5+ vec2(p.yz)).rgb;\n            \n            vec3 nTex = abs(n);\n            \n            vec3 tex = pow(roughXZ * nTex.y + roughXY * nTex.z + roughYZ * nTex.x, vec3(1.));\n            \n            col *= tex;\n            \n            // reflections\n            ref = .85*vec3(1, .7, .3) * mix(vec3(0.2), vec3(1.), tex.r);\n            if(iBounce == NUM_BOUNCES-1) col += ref*refTex;\n        }\n        \n        else if(mat==MAT_LINE){\n            col *= dif*vec3(1.000,0.902,0.761);\n            ref = vec3(0);\n        }\n            \n           \n        ro = p+n*surf_dist*3.;\n        rd= r;\n         \n        // ambient light\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        col += 0.008*amb*vec3(0.996,0.965,0.996);\n        \n        // fog (not working rn)\n        // col *= exp( -0.0005*dMat.x*dMat.x*dMat.x );\n        \n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 2.1, -3.4);\n    if(FREE_ROTATION) {\n    ro.yz *= Rot(m.y*3.14 / 2.+1.);\n    }\n    ro.xz *= Rot(-m.x*6.2831 + 2.);\n    if(SPINNING) ro.xz *= Rot(-iTime*0.05);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,.5,0), 1.5);\n    \n    vec3 \n        ref = vec3(0.),\n        fil = vec3(1.);\n        \n    vec3 col = Render(ro, rd, ref, 0, MAX_STEPS, MAX_DIST, SURF_DIST);\n    \n    // idea : let render also return MAT, and if its 0 (background) do not bounce.\n    for(int i=0; i<NUM_BOUNCES;i++)\n    {\n        fil *= ref;\n        // reduced quality ray march in reflection\n        vec3 bounce = fil*Render(ro, rd, ref, i, 100, 5., 0.002);\n        col += bounce * (1.-0.2*float(i)/float(NUM_BOUNCES));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    // lens flare\n    col += 0.3*(1.-length(uv - vec2(-1, 0.5))) * vec3(1.000,0.635,0.439);\n  \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}