{"ver":"0.1","info":{"id":"Mc3BDl","date":"1733609751","viewed":93,"name":"Gaussian Primes By RikR","username":"rikr","description":"Just a first little shader for the easiest one of these number fields. Made by Rik Riesmeijer, 2024 - No rights reserved (CC0).","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["complex","cc0","integers","gaussianprimes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gaussian Primes By RikR.\n// Made by Rik Riesmeijer - CC0, no rights reserved.\n\n// Slow and basic primality test.\nbool ordinaryprime(int n) {\n    if(n < 2)\n        return false;\n    for(int i = 2; i * i <= n; i++)\n        if(n % i == 0)\n            return false;\n    return true;\n}\n\n// Main prime testing and visualization code.\nvoid mainImage(out vec4 y, in  vec2 z) {\n               \n    z = z - 0.5 * iResolution.xy; // Centering the uv coordinates at 0.\n    z = z / iResolution.y * 128.0;  // Roughly get -100 to 100 scale grid.\n    \n    z = abs(z);           // This symmetry stems from i now being a unit.\n    ivec2 i = ivec2(z);   // Make into integer vector.\n    bool isprime = false; // Initialize primality flag variable.\n    \n    // We now have a + bi, with a,b integer. We can now split on cases.\n    int norm = i.x * i.x + i.y * i.y; // Compute the norm for later.\n    \n    // Just for ease of notation.\n    int a = i.x;\n    int b = i.y;\n    int s = a + b;\n    \n    // Gaussian primality test.\n    if(a > 0 && b > 0)\n        isprime = ordinaryprime(norm);\n    else\n        isprime = s % 4 == 3 && ordinaryprime(s);\n    \n    y = vec4(isprime); // White if prime black if not.\n}","name":"Image","description":"","type":"image"}]}