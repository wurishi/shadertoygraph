{"ver":"0.1","info":{"id":"ftVyRD","date":"1661069236","viewed":146,"name":"Packing Data","username":"MisterSirCode","description":"Using a lossy technique to pack together data. 2 ^ 20 is the highest square precision that makes usable data.\n\nYou can really only pack 1 deep... Float precision isnt great..\nTheoretically, with infinite precision, this technique could be \"lossless\"","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["textures","pack","vectors","unpack","packing","data","floats","unpacking","lossy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float snap(float v, float r) {\n    return round(v * r) / r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 cn = (fragCoord - iResolution.xy / 2.0);\n    vec4 raw = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    cn.x += cn.y / 10.0; // skew\n    \n    vec4[2] texq = unpack(raw);\n    \n    vec2 tex0 = texq[0].xy;\n    vec2 tex1 = texq[0].zw;\n    vec2 tex2 = texq[1].xy;\n    vec2 tex3 = texq[1].zw;\n    \n    // Rendering 8 different texture channels, not 4 :)\n    \n    float pos = snap(cn.x / iResolution.x + 1.0 / 8.0 / 2.0, 7.0) * 7.0;\n    \n    switch(int(pos)) {\n        case -3:\n            fragColor = vec4(tex0.x, 0.0, 0.0, 1.0);\n            break;\n        case -2:\n            fragColor = vec4(vec2(tex2.x), 0.0, 1.0);\n            break;\n        case -1:\n            fragColor = vec4(0.0, tex1.x, 0.0, 1.0);\n            break;\n        case 0:\n            fragColor = vec4(0.0, vec2(tex3.x), 1.0);\n            break;\n        case 1:\n            fragColor = vec4(0.0, 0.0, tex0.y, 1.0);\n            break;\n        case 2:\n            fragColor = vec4(tex2.y, 0.0, tex2.y, 1.0);\n            break;\n        case 3:\n            fragColor = vec4(tex1.y, 0.0, 0.0, 1.0);\n            break;\n        case 4:\n            fragColor = vec4(vec2(tex3.y), 0.0, 1.0);\n            break;\n        default:\n            fragColor = vec4(0);\n            break;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\nprecision highp sampler2D;\n\n// I want a packing precision of 2^20 or 1048576\n// This is the highest precision you can go with a highp float and still get usable images\n// \n// Its expected that the packed floats are between -1 and 1 anyhow...\n\nfloat cap = 1048576.0;\nfloat zer = 1000000.0;\n\n// Float packing. idfk\n\nfloat pack(float one, float two) {\n    float num = (trunc(clamp(one, 0.0, 1.0) * cap) + (clamp(two, 0.0, 1.0) * cap / zer));\n    return num / cap;\n}\n\nfloat[2] unpack(float num) {\n    num *= cap;\n    return float[2](trunc(num) / cap, (num - trunc(num)) * zer / cap);\n}\n\n// Vec3 packing. Put two colors in one!\n\nvec3 pack(vec3 one, vec3 two) {\n    return vec3(pack(one.x, two.x), pack(one.y, two.y), pack(one.z, two.z));\n}\n\nvec3[2] unpack(vec3 num) {\n    float[2] x = unpack(num.x);\n    float[2] y = unpack(num.y);\n    float[2] z = unpack(num.z);\n    return vec3[2](\n        vec3(x[0], y[0], z[0]),\n        vec3(x[1], y[1], z[1])\n    );\n}\n\n// Vec4 packing. Maybe ya wanna push 8 values to another layer, rather than just 4\n\nvec4 pack(vec4 one, vec4 two) {\n    return vec4(pack(one.x, two.x), pack(one.y, two.y), pack(one.z, two.z), pack(one.w, two.w));\n}\n\nvec4[2] unpack(vec4 num) {\n    float[2] x = unpack(num.x);\n    float[2] y = unpack(num.y);\n    float[2] z = unpack(num.z);\n    float[2] w = unpack(num.w);\n    return vec4[2](\n        vec4(x[0], y[0], z[0], w[0]),\n        vec4(x[1], y[1], z[1], w[1])\n    );\n}\n\n// Should theoretically be able to pack Vec4's further with CMYK lol\n\nvec4 toCMYK(vec3 col) {\n    vec3 nc = 1.0 - col;\n    float k = min(nc.r, min(nc.g, nc.b));\n    float nk = 1.0 - k;\n    return vec4(\n        (nc.r - k) / nk,\n        (nc.g - k) / nk,\n        (nc.b - k) / nk,\n        k\n    );\n}\n\nvec3 toRGB(vec4 col) {\n    vec4 nc = 1.0 - col;\n    return vec3(\n        nc.r * nc.w,\n        nc.g * nc.w,\n        nc.b * nc.w\n    );\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// SOME STUFF FOR TEXTURE\n\nvec3 hash3(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash3(i + vec2(0.0,0.0)), \n                   hash3(i + vec2(1.0,0.0)), u.x),\n               mix(hash3(i + vec2(0.0,1.0)), \n                   hash3(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nvec3 fractal(vec2 p, int oct) {\n    float tier = 0.5;\n    mat2 m = mat2(1.6, 1.2, 1.2, -1.6);\n    p *= 4.0;\n    vec3 n = vec3(0);\n    for (int i = 0; i < oct; i++) {\n        n += noise(p) * tier; \n        p = m * p;\n        tier *= tier;\n    }\n    return sqrt(n);\n}\n\nvec3 fbm(vec2 p, int oct, int iter) {\n    for (int i = 0; i < iter; i++) {\n        p = (fractal(p, oct) + noise(p * 50.0) / 25.0).xy - p;\n    }\n    return fractal(p, oct);\n}\n\n// ACTUALLY TESTING PACKING HERE:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 cn = (fragCoord - iResolution.xy / 2.0);\n    \n    vec3 tex0 = hash3(cn);    \n    vec3 tex1 = noise(cn / 2.0);    \n    vec3 tex2 = fractal(cn / 100.0, 6);    \n    vec3 tex3 = fbm(cn / 100.0, 6, 6);\n    \n    vec4 texq1 = vec4(tex0.x, tex0.y, tex1.x, tex1.y);\n    vec4 texq2 = vec4(tex2.x, tex2.y, tex3.x, tex3.y);\n    \n    fragColor = pack(texq1, texq2);\n}","name":"Buffer A","description":"","type":"buffer"}]}