{"ver":"0.1","info":{"id":"XlGXzh","date":"1482695651","viewed":528,"name":"Voyage","username":"huwb","description":"Use the arrow keys to sail the oceans and discover the ancient relics. Merry xmas all!","likes":17,"published":1,"flags":112,"usePreview":0,"tags":["game","lowpoly","boat","sailing","sphericalworld"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// main image. sample ocean and land gbuffers and shade\n\n// really happy with how this shader turned out. it is inspired by\n// many things including Journey, http://www.ro.me/ , zelda, and work ive done with colleagues\n// on a couple of disney infinity playsets that had oceans (one didnt ship sadly :().\n//\n// i wanted to add more like birds, fish and stuff but it's already at the point where\n// Buf A will only compile on my laptop if its plugged into mains (!), and perf is at the min\n// of what im comfortable with (45-50fps not fullscreen) so i think ill stop now.\n//\n// im happy for any of this to be used in an unlimited way, although a link back to\n// this shader would be appreciated!\n//\n// some implementation notes in case anyone is interested..\n//\n// - it renders two gbuffers in Buf A&B - one for transparents and one for opaques.\n// - bounding spheres are used for the water and land to cull trivially non-intersecting rays\n// and to give tstart and tmax values. this gave a great speedup (~30fps to 45-50fps)\n// - bounding sphere is also used for the boat. opaque uses a hybrid mix of raymarching and raycasting\n// - ocean and land heights come from tri-plane texture mapping. i really should normalize\n// pt at the start of LandHeight() but not doing so creates some wacky shapes in the terrain\n// so i left it. the low poly look comes from projecting each point to a world-aligned cube. the\n// heights are sampled at verts shown in iq's diagrams here https://iquilezles.org/articles/patchedsphere\n// and then lerp'd. i had an alternate version which sampled a low res texture for the heights (the\n// low poly look came from hardware bilinear interpolation). this was promising but annoying to make\n// the uv mapping seemless.\n// - some of the terrain coloring looks funky because the 4 verts of each quad are not coplanar! i\n// changed it to be triangles instead (c.f commented code in OceanDE() in BufC) but i didnt like\n// the regularity so im adopting the funky colors and calling it 'charm' :)\n// - the land gbuffer is rendered first, it reads the depth of the ocean surface from the last frame\n// and avoids raymarching too deep below the (previous frame's) water.\n// - the ocean gbuffer is rendered second and takes an up to date opaque surface depth, and uses\n// this for tmax in the RM.\n// - one thing that im really happy with is the shoreline foam, its based on land height. it has two\n// foam lines on sine waves, with phase shifts coming from the world space position.\n// - the boat and camera motion just use simple lerps. i wanted to make this a proper RB and finess\n// the motion but as mentioned BufA is already unwieldy on my laptop. i tried to achieve a minimum\n// expression of the 3Cs http://blog.digitaltutors.com/character-controls-camera-3cs-game-development/\n// \n\n#define DIST_MAX 2.\n#define WAVE_AMP .0125\n#define EPS 0.001\n#define FOAM_THRESH_LANDH -0.02\n#define RELICR 0.005\n#define RELIC_COUNT 9.\n#define BOATR .02\n\nvoid Camera( in vec2 p, out vec3 ro, out vec3 rd );\nvec4 Text( vec2 fragCoord, bool allRelicsCollected );\nfloat Letter( in sampler2D samp, in float ind, in vec2 uv );\n\n// for materials\nfloat LandHeights2D( vec2 xy )\n{\n    xy *= 10.;\n    float h = 0.;\n    h += .05*sin(3.+1.5*(xy.x+.45*xy.y));\n   \th += .2*sin(4.+.5*(.73*xy.x-.52*xy.y));\n    h -= .1;\n    return h;\n}\nfloat LandHeight( vec3 pt )\n{\n    vec3 apt = normalize(abs(pt));\n    float xw = apt.x * LandHeights2D(pt.yz);\n    float yw = apt.y * LandHeights2D(pt.xz);\n    float zw = apt.z * LandHeights2D(pt.xy);\n    return xw + yw + zw;\n}\n\n// to detect boat material\nfloat DEBoat( in vec3 pt, in vec3 boatPos, in vec3 boatFo, in vec3 boatUp )\n{\n    float res = DIST_MAX;\n    \n    vec3 boatRi = cross(boatFo,boatUp);\n    vec3 ptoff = pt - boatPos;\n    \n    float offri = dot(ptoff,boatRi);\n    float offup = dot(ptoff,boatUp);\n    float offfo = dot(ptoff,boatFo);\n    \n    //res = min( res, length( pt - (boatPos+.01*boatUp) ) - .0025);\n    float dSail = abs(offri+.4*offfo)-.0005;\n    if( false )\n    \tdSail = max( dSail, length(ptoff) - 0.019 );\n    else\n    {\n        //float sailR = sqrt(offri*offri + offfo*offfo +offup*offup);\n        //float sailR = sqrt(offri*offri + offfo*offfo );\n        //float sailR = abs(offri) + abs(offfo);\n        //dSail = max( dSail, sailR - 0.019 );\n        float hat = .025 - sqrt(offri*offri + offfo*offfo );\n        dSail = max( dSail, offup-hat );\n    }\n    dSail = max( dSail, -offup + .005 );\n    //dSail = max( dSail, -offup + .01 );\n    \n    res = min( res, dSail );\n    \n    pt = boatPos + ptoff - offri*boatRi + 2.4 * offri * boatRi\n        -offup * boatUp + 1.9 * offup * boatUp\n        ;\n    \n    float xr = abs( dot(pt-boatPos,boatRi) );\n    float zr = abs( dot(pt-boatPos,boatFo) );\n    float dDeck = dot( pt - boatPos, boatUp ) - (.002 + 16.*zr*zr + 8.*xr*xr);\n    \n    float dHull = max( dDeck, length(pt - boatPos) - BOATR );\n    res = min( res, dHull );\n    \n    return res;\n}\n\n// for foam\nfloat WaveHeights2D( vec2 xy )\n{\n    xy *= 10.;\n    float h = 0.;\n    h += sin(.9*iTime+3.5*(.01*xy.x+.45*xy.y));\n   \th += .5*sin(-1.3*iTime+3.9*(.01*.73*xy.x-.52*xy.y));\n    h *= WAVE_AMP;\n    return h;\n}\nfloat WaterHeight( vec3 pt )\n{\n    pt = normalize(pt);\n    vec3 apt = abs(pt);\n    float xw = apt.x * WaveHeights2D(pt.yz);\n    float yw = apt.y * WaveHeights2D(pt.xz);\n    float zw = apt.z * WaveHeights2D(pt.xy);\n    \n    float res = xw + yw + zw;\n    \n    float landH = LandHeight(pt);\n    res *= mix( 1., smoothstep( 0., -0.07, landH ), .8 );\n    \n    return res;\n}\n\n// from iq. currently used for relics\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 fogColor = vec3(.7,.7,1.);\nvec3 fogColorToward = vec3(1.,1.,.9);\nvec3 fogColorAway = vec3(.6,.6,1.);\nvec3 SkyLight( vec3 rd, vec3 L )\n{\n    vec3 result = fogColor;\n        \n    float dp = dot( rd, L );\n    if( dp > 0. )\n        result = mix( result, fogColorToward, pow(dp,16.) );\n    else\n    {\n        result = mix( result, fogColorAway, pow(-dp,1.) );\n    }\n    \n    /*\n\t// experiment with clouds. they add a lot of noise to reflections so ill leave off.\n    vec3 ard = abs(rd);\n    float freq = .02;\n    float xc = ard.x * texture(iChannel3,freq*ard.yz).x;\n    float yc = ard.y * texture(iChannel3,freq*ard.xz).x;\n    float zc = ard.z * texture(iChannel3,freq*ard.xy).x;\n    float clouds = xc + yc + zc;\n    result = pow(clouds,2.) > 1. ? mix( vec3(1.), result, .3 ) : result;\n    */\n    return result;\n}\n\n//float drawNumber( float num, vec2 pos, vec2 pixel_coords );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // gbuffers for rendering\n    vec4 opaqueGbuffer = texture(iChannel1,fragCoord/iResolution.xy);\n    vec4 oceanGbuffer = texture(iChannel3,fragCoord/iResolution.xy);\n    // boat data for materials etc\n    vec3 boatPos = texture( iChannel2, vec2(.5,.5)/iResolution.xy ).xyz;\n    vec3 boatFo = texture(iChannel2,vec2(2.5,.5)/iResolution.xy).xyz;\n    vec3 boatUp = texture(iChannel2,vec2(3.5,.5)/iResolution.xy).xyz;\n    \n\tvec2 p = fragCoord.xy / iResolution.xy; p -= .5; p.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro, rd;\n    Camera( p, ro, rd );\n    \n    float topaque = opaqueGbuffer.w;\n    float tocean = oceanGbuffer.w;\n    \n    // relics\n    float relicIndex = -1.;\n    //bool allCollected = true;\n    float nearestRelicIdx = -1.;\n    float nearestRelicDist2 = DIST_MAX*DIST_MAX;\n    for( float i = 0.; i < RELIC_COUNT; i++ )\n    {\n        vec4 posStatus = texture( iChannel2, vec2(10.5+i,.5)/iResolution.xy );\n        \n        // not collected?\n        if( posStatus.w == 0. )\n        {\n            //allCollected = false;\n            float d2 = dot(posStatus.xyz-boatPos,posStatus.xyz-boatPos);\n            if( d2 < nearestRelicDist2 )\n            {\n                nearestRelicDist2 = d2;\n                nearestRelicIdx = i;\n            }\n        }\n        \n        float tr = sphIntersect( ro, rd, vec4( posStatus.xyz, RELICR ) );\n        if( tr > 0. && tr < topaque )\n        {\n            topaque = tr;\n            relicIndex = i;\n        }\n    }\n    \n    float Lt = iTime+13.;\n    vec3 sunDir = texture(iChannel2,vec2(20.5,.5)/iResolution.xy).xyz;\n    //vec3 L = normalize(vec3(sin(Lt*.05),cos(Lt*.06),sin(Lt*.07)));\n    vec3 Lcol = vec3(1.,1.,.6)*.8;\n    \n    float tnearest = min( topaque, tocean );\n    \n    if( tnearest >= DIST_MAX )\n    {\n        fragColor.xyz = SkyLight( rd, sunDir );\n        vec4 reward = texture(iChannel2,fragCoord/iResolution.xy );\n        fragColor.xyz = mix( fragColor.xyz, 1.2*vec3(1.9,.75,.0), reward.a*.3 );\n        return;\n\t}\n    \n    vec3 result = vec3(0.);\n\n    bool foamyWater = true;\n    vec3 ptocean;\n    vec3 nocean;\n    \n    if( tocean < topaque )\n    {\n\t    ptocean = ro + tocean*rd;\n\t    nocean = oceanGbuffer.xyz; //NOcean( ptocean );\n\t    vec3 R = reflect(rd,nocean);\n        \n        vec3 col;\n        float landH = LandHeight(ptocean);\n        float waterH = WaterHeight(ptocean);\n        foamyWater = waterH >= 0.024; // && dot(nocean,normalize(ptocean))>.98; // wave crests\n        if( landH > -0.005 )\n        {\n            // always foamy under land\n            foamyWater = true;\n        }\n        else if( landH > FOAM_THRESH_LANDH )\n        {\n            float br = 0.002;\n            float loc0 = (.5+.5*sin(iTime+12.*dot(ptocean,vec3(1.)))) * FOAM_THRESH_LANDH;\n            float loc1 = (.5+.5*sin(iTime+12.*dot(ptocean,vec3(1.))+3.14)) * FOAM_THRESH_LANDH;\n            foamyWater = abs(landH-loc0) < br || abs(landH-loc1) < br;\n        }\n        if( foamyWater )\n        {\n            // foam - diffuse lighting\n            col.xyz = vec3(1.5) * ( max(0.,dot(nocean,sunDir)) + fogColor );//vec3(.2,.135,0.05) );\n        }\n        else\n        {\n            // diffuse\n            col.xyz =.25*( vec3(0.25,0.4,1.0) * ( max(0.,dot(nocean,sunDir))*Lcol + .5*fogColor ));// vec3(.2,.135,0.05) );\n            // fresnel\n            float fresnel = 1. - dot( -rd, nocean );\n            fresnel = pow( fresnel, 2. );\n            col.xyz += fresnel * SkyLight( R, sunDir );\n            // specular\n\t        col.xyz += .9*pow(max(0.,dot(R,sunDir)),128.)*Lcol;\n        }\n        \n        result = vec3( col.xyz );\n    }\n\n    if( topaque < tocean || !foamyWater )\n    {\n        vec3 ptopaque = ro + topaque*rd;\n        vec3 nopaque = opaqueGbuffer.xyz;// NOpaque( ptopaque, boatPos, boatFo, boatUp );\n        \n\t    vec3 opaqueCol = vec3(0.);\n        float opaqueR = length(ptopaque);\n        vec3 ptopaqueN = ptopaque/opaqueR;\n        \n        // hit a relic\n        if( relicIndex > -1. )\n        {\n            opaqueCol = vec3(1.9,.75,.0)*.8;\n            vec3 relicPos = texture( iChannel2, vec2(10.5+relicIndex,.5)/iResolution.xy ).xyz;\n            vec3 fragOff = ptopaque-relicPos;\n            nopaque = fragOff/RELICR + .5;\n            float letterIdx = relicIndex + 144.;\n            float li = max( max(\n                Letter( iChannel0, letterIdx, nopaque.xz ), \n                Letter( iChannel0, letterIdx, nopaque.yz ) ),\n                Letter( iChannel0, letterIdx, nopaque.xy ) );\n            opaqueCol += li;\n        }\n        else if( DEBoat( ptopaque, boatPos, boatFo, boatUp ) < 2.*EPS )\n        {\n            // boat col\n            opaqueCol = vec3(1.,.85,.75);\n        }\n        else\n        {\n            if( dot(nopaque,ptopaqueN) > .9 )\n            {\n                if( abs( opaqueR - 1. ) < .01 )\n                {\n                    // sand\n                    opaqueCol = vec3(1.,1.,.3)*1.1;\n                }\n                else\n                {\n                    if( opaqueR > 1. )\n                        // grass\n                        opaqueCol = vec3(.2,1.,.2)*.7;\n                    else\n                        // reef\n                        opaqueCol = vec3(1.,.3,1.);\n                }\n            }\n            else\n            {\n                if( dot(nopaque,ptopaqueN) > .8 && topaque < tocean )\n                    // dirt\n                    opaqueCol = vec3(1.,.65,.3)*.8;\n                else\n                    opaqueCol = vec3(.7,.7,.7); // rock\n            }\n        }\n        \n\t    vec3 dif = opaqueCol * ( max(0.,dot(nopaque,sunDir))*Lcol + fogColor );\n        \n        if( topaque > tocean && !foamyWater )\n        {\n            float ext = exp(-8.*(topaque-tocean) - 1. );\n            \n            result.xyz = mix( result.xyz, dif, ext );\n        }\n        else\n        {\n            result.xyz = dif;\n        }\n    }\n\n    \n    // exp fog\n    result.xyz = mix( result.xyz, fogColor, smoothstep(0.5,1.3,tnearest) );\n    \n    fragColor.xyz = pow( result.xyz, vec3(1./sqrt(2.2)) );\n    \n    vec4 text = Text( fragCoord, nearestRelicIdx == -1. );\n    fragColor = mix( fragColor, text, text.w );\n    \n    // reward effect for collecting all relics\n    {\n        bool allColl = nearestRelicIdx == -1.;\n        vec3 center = !allColl ? texture( iChannel2, vec2(10.5+nearestRelicIdx,.5)/iResolution.xy ).xyz : boatPos;\n        vec3 centerOff = ro+rd*tnearest-center;\n        float period = allColl ? 5. : 11.;\n        float curDist = .14*mod(iTime, period );\n        if( abs(dot(centerOff,centerOff)-curDist*curDist) < .0005 )\n            fragColor.xyz = .7*fragColor.xyz + .5*vec3(1.9,.75,.0);\n    }\n    \n\t/*vec4 posStatus8 = texture( iChannel2, vec2(10.5+8.,.5)/iResolution.xy );\n    fragColor -= drawNumber( posStatus9.x, vec2(0.1,0.14), .5*fragCoord/iResolution.xy );\n    fragColor -= drawNumber( posStatus9.y, vec2(0.1,0.12), .5*fragCoord/iResolution.xy );\n    fragColor -= drawNumber( posStatus9.z, vec2(0.1,0.10), .5*fragCoord/iResolution.xy );*/\n}\n\nvoid Camera( in vec2 p, out vec3 ro, out vec3 rd )\n{\n    vec3 boatPos = texture( iChannel2, vec2(.5,.5)/iResolution.xy ).xyz;\n    vec3 boatVel = texture( iChannel2, vec2(1.5,.5)/iResolution.xy ).xyz;\n    vec3 boatFo = texture( iChannel2, vec2(2.5,.5)/iResolution.xy ).xyz;\n\tvec3 boatPosN = normalize( boatPos );\n    \n    vec4 posAndFOV = texture( iChannel2, vec2(4.5,.5)/iResolution.xy );\n    \n    // camera eye pos\n    ro = posAndFOV.xyz;\n    // camera target\n    vec3 target = boatPos + .03*boatPosN;\n     \n    // camera frame\n    vec3 fo = normalize(target-ro);\n    vec3 up = texture( iChannel2, vec2(5.5,.5)/iResolution.xy ).xyz;\n    up = normalize( up - dot(up,fo)*fo );\n    vec3 ri = cross( up, fo );\n     \n    // multiplier to emulate a fov control\n    float fov = posAndFOV.w; // + .1*speed;\n\t\n    // ray direction\n    rd = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\n// some hastily hacked macros for stringing chracters together. im guessing someone has done this\n// more elegantly, please comment if you know of a better implementation.\n#define LINIT(loc,sz) float _lletter = 0., _lx = loc.x, _ly = loc.y; vec2 _lwh = sz*vec2(17./32.,1.);\n#define L(ind) _lletter = max( _lletter, Letter(iChannel0, float(ind), _lx, _ly, _lwh, fragCoord) );\n#define LN(num) _lletter = max( _lletter, Letter(iChannel0, 48.+num, _lx, _ly, _lwh, fragCoord) );\n#define LRESULT _lletter\nfloat Letter( in sampler2D samp, in float ind, inout float x, in float y, in vec2 wh, in vec2 fragCoord ) {\n    // 16 letters per row\n\tfloat row = floor(ind/16.); float col = ind - row*16.; row = 15. - row;\n    vec2 uv = clamp((fragCoord - vec2(x,y)) / wh,0.,1.); uv.x = .5 + (uv.x-.5)*.56; // squeeze out some of the horiz padding. .65 worked for star (28). .56 works for capital leetters at scales down to 16.\n    x += wh.x;\n    return texture( samp, vec2(col+uv.x,row+uv.y)*64./1024. ).x;\n}\nfloat Letter( in sampler2D samp, in float ind, in vec2 uv ) {\n\tfloat row = floor(ind/16.); float col = ind - row*16.; row = 15. - row;\n    uv = clamp(uv,0.,1.); uv.x = .5 + (uv.x-.5)*.56; // squeeze out some of the horiz padding. .65 worked for star (28). .56 works for capital leetters at scales down to 16.\n    return texture( samp, vec2(col+uv.x,row+uv.y)*64./1024. ).x;\n}\nvec4 Text( vec2 fragCoord, bool allRelicsCollected )\n{\n    if( fragCoord.y > 37.5 ) return vec4(0.);\n    \n    LINIT(vec2(10.,2.5), 32. );\n    L(82) L(69) L(76) L(73) L(67) L(83) L(32.);\n    \n    for( float i = 0.; i < 9.; i++ )\n    {\n        vec4 posStatus = texture( iChannel2, vec2(10.5+i,.5)/iResolution.xy );\n        // collected?\n        if( posStatus.w > 0. )\n        {\n            L(144.+i);\n        }\n        else\n        {\n            L(183.);\n        }\n    }\n    \n    if( allRelicsCollected )\n    {\n        // complete easter egg is bigger than normal letters and i want it on the RHS, so extract and hack\n        // out the letter macro code here\n        fragCoord.x = iResolution.x - fragCoord.x;\n        vec2 uv = clamp((fragCoord - vec2(10.,_ly)) / (vec2(1./.7,1.)*_lwh),0.,1.); uv.x = .5 + (uv.x-.5)*.75; // squeeze out some of the horiz padding. .65 worked for star (28). .56 works for capital leetters at scales down to 16.\n        float row = 14.; float col = 13.;\n        _lletter = max( _lletter, texture( iChannel0, vec2(col+uv.x,row+uv.y)*64./1024. ).x );\n    }\n\n    return vec4(1.,1.,1., .7*(1.-LRESULT) );\n}\n\n/*\n// digits based on the nice ascii shader by movAX13h\n\nfloat drawDig( vec2 pos, vec2 pixel_coords, float bitfield )\n{\n\t// offset relative to \n\tvec2 ic = pixel_coords - pos ;\n\tic = floor(ic*iResolution.xy);\n\t// test if overlap letter\n\tif( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )\n\t{\n\t\t// compute 1d bitindex from 2d pos\n\t\tfloat bitIndex = ic.y*3.+ic.x;\n\t\t// isolate the bit\n\t\treturn floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );\n\t}\n\treturn 0.;\n}\n// decimal point\nfloat drawDecPt( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 1. );\n}\n// minus sign\nfloat drawMinus( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 448. );\n}\n// digits 0 to 9\nfloat drawDigit( float dig, vec2 pos, vec2 pixel_coords )\n{\n\tif( dig == 1. )\n\t\treturn drawDig( pos, pixel_coords, 18724. );\n\tif( dig == 2. )\n\t\treturn drawDig( pos, pixel_coords, 31183. );\n\tif( dig == 3. )\n\t\treturn drawDig( pos, pixel_coords, 31207. );\n\tif( dig == 4. )\n\t\treturn drawDig( pos, pixel_coords, 23524. );\n\tif( dig == 5. )\n\t\treturn drawDig( pos, pixel_coords, 29671. );\n\tif( dig == 6. )\n\t\treturn drawDig( pos, pixel_coords, 29679. );\n\tif( dig == 7. )\n\t\treturn drawDig( pos, pixel_coords, 31012. );\n\tif( dig == 8. )\n\t\treturn drawDig( pos, pixel_coords, 31727. );\n\tif( dig == 9. )\n\t\treturn drawDig( pos, pixel_coords, 31719. );\n\t// 0\n\treturn drawDig( pos, pixel_coords, 31599. );\n}\n\n// max num width is 26px (minus, 3 nums, dec pt, 2 nums)\n// max height is 6px\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords )\n{\n\tfloat result = 0.;\n\tbool on = false;\n\tfloat d;\n\t\n\t// minus sign\n\tif( num < 0. )\n\t{\n\t\tresult += drawMinus( pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\tnum = -num;\n\t}\n\t// hundreds\n\td = floor(mod(num/100.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// tens\n\td = floor(mod(num/10.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// ones\n\td = floor(mod(num,10.));\n\tresult += drawDigit( d, pos, pixel_coords );\n\tpos.x += 4. / iResolution.x;\n\t// dec pt\n\tresult += drawDecPt( pos, pixel_coords );\n\tpos.x += 2. / iResolution.x;\n\t// tenths\n\td = floor(mod(num/.1,10.));\n\tif( true )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// hundredths\n\td = floor(mod(num/.01,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// thousandths\n\td = floor(.5+mod(num/.001,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t\n\treturn clamp(result,0.,1.);\n}\n*/\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsB3Ry","filepath":"https://soundcloud.com/safena-1/journey","previewfilepath":"https://soundcloud.com/safena-1/journey","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// dynamics (boat, camera)\n// note due to the limited texture slots in Image, this data gets copied into\n// texture D and accessed from there!\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\n#define WAVE_AMP .0125\n#define EPS 0.001\n#define FOAM_THRESH_LANDH -0.02\n#define RELIC_COUNT 9.\n#define PI 3.141592654\n\nvoid Quantize( vec3 pt, out vec3 pt0, out vec3 pt1, out vec3 pt2, out vec3 pt3, out vec2 f );\n\nfloat WaveHeights2D( vec2 xy )\n{\n    xy *= 10.;\n    float h = 0.;\n    h += sin(.9*iTime+3.5*(.01*xy.x+.45*xy.y));\n   \th += .5*sin(-1.3*iTime+3.9*(.01*.73*xy.x-.52*xy.y));\n    h *= WAVE_AMP;\n    return h;\n}\n\nfloat LandHeights2D( vec2 xy )\n{\n    xy *= 10.;\n    float h = 0.;\n    h += .05*sin(3.+1.5*(xy.x+.45*xy.y));\n   \th += .2*sin(4.+.5*(.73*xy.x-.52*xy.y));\n    h -= .1;\n    return h;\n}\nfloat LandHeight( vec3 pt )\n{\n    vec3 apt = normalize(abs(pt));\n    float xw = apt.x * LandHeights2D(pt.yz);\n    float yw = apt.y * LandHeights2D(pt.xz);\n    float zw = apt.z * LandHeights2D(pt.xy);\n    return xw + yw + zw;\n}\n\nfloat WaterHeight( vec3 pt )\n{\n    pt = normalize(pt);\n    vec3 apt = abs(pt);\n    float xw = apt.x * WaveHeights2D(pt.yz);\n    float yw = apt.y * WaveHeights2D(pt.xz);\n    float zw = apt.z * WaveHeights2D(pt.xy);\n    \n    float res = xw + yw + zw;\n    \n    float landH = LandHeight(pt);\n    res *= mix( 1., smoothstep( 0., -0.07, landH ), .8 );\n    \n    return res;\n}\nfloat DEOcean( vec3 pt )\n{\n    vec3 pt0, pt1, pt2, pt3;\n    vec2 f;\n    Quantize( pt, pt0, pt1, pt2, pt3, f );\n    \n    float wh0 = WaterHeight(pt0),\n        wh1 = WaterHeight(pt1),\n        wh2 = WaterHeight(pt2),\n        wh3 = WaterHeight(pt3);\n    float ptlen = length(pt);\n    pt0 = (1.+wh0) * pt0;\n    pt1 = (1.+wh1) * pt1;\n    pt2 = (1.+wh2) * pt2;\n    pt3 = (1.+wh3) * pt3;\n    \n    vec3 ptlerp = mix( mix( pt0, pt1, f.x ), mix( pt2, pt3, f.x ), f.y );\n    \n    return ptlen - length(ptlerp)/ptlen;\n}\n\nvec3 NOcean( vec3 pos )\n{\n    vec2 dd = vec2(EPS,0.);\n    float c = DEOcean(pos);\n    return normalize(\n        vec3( DEOcean(pos+dd.xyy), DEOcean(pos+dd.yxy), DEOcean(pos+dd.yyx) ) - c\n        );\n}\n\nfloat DELand( vec3 pt )\n{\n    vec3 pt0, pt1, pt2, pt3;\n    vec2 f;\n    Quantize( pt, pt0, pt1, pt2, pt3, f );\n    \n    float lh0 = LandHeight(pt0),\n        lh1 = LandHeight(pt1),\n        lh2 = LandHeight(pt2),\n        lh3 = LandHeight(pt3);\n    \n    float ptlen = length(pt);\n    pt0 = (1.+lh0) * pt0;\n    pt1 = (1.+lh1) * pt1;\n    pt2 = (1.+lh2) * pt2;\n    pt3 = (1.+lh3) * pt3;\n    \n    vec3 ptlerp = mix( mix( pt0, pt1, f.x ), mix( pt2, pt3, f.x ), f.y );\n    \n    return ptlen - length(ptlerp)/ptlen; // this divide compensates for quantize giving the 4 points with same length as input point\n    //return ptlen - (1. + mix( mix( lh0, lh1, f.x ), mix( lh2, lh3, f.x ), f.y ) );\n}\n\nvec3 NLand( vec3 pos )\n{\n    vec2 dd = vec2(EPS,0.);\n    \n    float c = DELand(pos);\n    return normalize(\n        vec3( DELand(pos+dd.xyy), DELand(pos+dd.yxy), DELand(pos+dd.yyx) ) - c\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.y > 1. || fragCoord.x > 21. )\n        return;\n    \n    float dt = min(iTimeDelta,1./30.); // say no to big dts\n    \n    vec3 boatPt = texture(iChannel2,vec2(.5,.5)/iResolution.xy).xyz;\n    vec3 boatV = texture(iChannel2,vec2(1.5,.5)/iResolution.xy).xyz;\n    vec3 boatFo = texture(iChannel2,vec2(2.5,.5)/iResolution.xy).xyz;\n    vec3 boatUp = texture(iChannel2,vec2(3.5,.5)/iResolution.xy).xyz;\n    vec4 camPosAndFOV = texture(iChannel2,vec2(4.5,.5)/iResolution.xy);\n    vec3 camPt = camPosAndFOV.xyz;\n    float camFOV = camPosAndFOV.w;\n    vec3 camUp = texture(iChannel2,vec2(5.5,.5)/iResolution.xy).xyz;\n    vec3 sunDir = texture(iChannel2,vec2(20.5,.5)/iResolution.xy).xyz;\n    \n    // init here so we'll have valid state throughout the branches below\n    if( iFrame == 0 )\n    {\n        boatPt = vec3(0.,-1.,0.);\n        boatFo = normalize(vec3(.5,0.,.5));\n        boatUp = normalize(boatPt);\n        boatV = 0.01 * boatFo;\n        \n        // camPt is init'd in the branch below\n        camUp = boatUp;\n        camFOV = .33;\n        sunDir = boatFo;\n    }\n    \n    float boatR = length(boatPt);\n    vec3 boatPtN = boatPt/boatR;\n    vec3 boatRi = normalize(cross( boatPt, boatFo ));\n    \n    \n    // construct ocean surface local frame below boat\n    float waterHeight = 1. + WaterHeight( boatPtN );\n    vec3 oceanSurfFrame_O = boatPtN * waterHeight;\n    vec3 oceanSurfFrame_U = NOcean(oceanSurfFrame_O);\n    vec3 oceanSurfFrame_F = boatFo;\n    oceanSurfFrame_F = normalize( oceanSurfFrame_F - dot(oceanSurfFrame_F,oceanSurfFrame_U)*oceanSurfFrame_U );\n    vec3 oceanSurfFrame_R = cross( oceanSurfFrame_U, oceanSurfFrame_F );\n\n    \n    if( fragCoord == vec2(.5) )\n    {\n        // BOAT POSITION\n        \n        boatPt += dt * boatV;\n        \n        // limit how far boat goes under water\n        waterHeight = 1. + WaterHeight( boatPt );\n        float maxUnderWater = .0;\n        if( length( boatPt ) < waterHeight-maxUnderWater )\n        {\n            boatPt = normalize(boatPt) * (waterHeight-maxUnderWater);\n        }\n        \n        //boatPt = (1. + waterH) * normalize(boatPt);\n        fragColor = vec4( boatPt, 0.0 );\n    }\n    else if( fragCoord == vec2(1.5,.5) )\n    {\n        // BOAT VELOCITY\n        \n        if( texture( iChannel0, vec2(KEY_UP,0.5/3.0) ).x > 0. )\n\t        boatV += .08*dt * boatFo;\n        if( texture( iChannel0, vec2(KEY_DOWN,0.5/3.0) ).x > 0. )\n\t        boatV -= .08*dt * boatFo;\n        \n        //float waterHeightV = (1. + wh( boatPtN, iTime + EPS ) - waterHeight ) / EPS;\n        \n        float boatRideHeight = 0.005;\n        //if( boatR + boatRideHeight < waterHeight )\n        {\n            boatV += boatPtN * (waterHeight - (boatR-boatRideHeight));\n        }\n        \n        // if we're getting too close to shore, push away\n        float landH = LandHeight(boatPt);\n        if( landH > 1.25*FOAM_THRESH_LANDH )\n        {\n            vec3 landN = NLand( boatPtN );\n            // don't do anything in up/down direction\n            landN -= dot( landN, boatPtN ) * boatPtN;\n            if( dot(landN,boatV) < .0 )\n\t            boatV += .5 * landN * dt;\n        }\n    \n        // damping\n        float boatVxL = dot( boatV, oceanSurfFrame_R );\n        float boatVyL = dot( boatV, oceanSurfFrame_U ); // - waterHeightV;\n        float boatVzL = dot( boatV, oceanSurfFrame_F );\n        boatVxL *= 1. - min(.5,.045*30.*dt);\n        boatVyL *= 1. - min(.5,.075*30.*dt);\n        boatVzL *= 1. - min(.5,.025*30.*dt);\n        boatV = boatVxL*oceanSurfFrame_R + boatVyL*oceanSurfFrame_U + boatVzL*oceanSurfFrame_F;\n        \n        // ensure min velocity\n        float l2 = dot(boatV,boatV);\n        if( l2 < 0.0001 )\n            boatV *= 0.0001/l2;\n        \n        fragColor = vec4( boatV, 0.0 );\n    }\n    else if( fragCoord == vec2(2.5,.5) )\n    {\n        // BOAT FORWARD VECTOR\n        float leftK = texture( iChannel0, vec2(KEY_LEFT,0.5/3.0) ).x;\n        float rightK = texture( iChannel0, vec2(KEY_RIGHT,0.5/3.0) ).x;\n        if( leftK > 0. || rightK > 0. )\n        {\n            boatFo +=.9*dt*(rightK-leftK)*boatRi;\n        }\n        \n        // if we're getting too close to shore, turn away\n        float landH = LandHeight(boatPt);\n        if( landH > 1.25*FOAM_THRESH_LANDH )\n        {\n            vec3 landN = NLand( boatPtN );\n            // don't do anything in up/down direction\n            landN -= dot( landN, boatPtN ) * boatPtN;\n            if( dot( boatFo, landN ) < 0. )\n            {\n\t            landN = normalize(landN);\n                float mul = sqrt(dot(landN,-boatFo));\n\t            boatFo += 2. * mul * sign(dot(landN,boatRi)) * boatRi * dt;\n            }\n            \n            boatV += .5 * landN * dt;\n        }\n\n        // lock forward to tangent plane of sphere world for now\n        boatFo -= dot( boatFo, boatPtN ) * boatPtN;\n        \n        fragColor = vec4(normalize(boatFo),0.);\n    }\n    else if( fragCoord == vec2(3.5,.5) )\n    {\n        // BOAT UP VECTOR\n\n        // lerp towards ocean up\n        float leftK = texture( iChannel0, vec2(KEY_LEFT,0.5/3.0) ).x;\n        float rightK = texture( iChannel0, vec2(KEY_RIGHT,0.5/3.0) ).x;\n        vec3 targetUp = oceanSurfFrame_U\n            - .25*(rightK-leftK)*oceanSurfFrame_R\n            + 2.*dot(boatV,oceanSurfFrame_R)*oceanSurfFrame_R;\n        //vec3 targetUp = oceanSurfFrame_U + 4.*dot(boatV,oceanSurfFrame_R)*oceanSurfFrame_R;\n        fragColor.xyz = mix( boatUp, targetUp, min(1.,5. * dt) );\n    }\n    else if( fragCoord == vec2(4.5,.5) )\n    {\n        // CAMERA POSITION, FOV\n        \n        float speed = length(boatV);\n        //vec3 boatVelN = boatVel / speed;\n        vec3 newPos = boatPt + .17 * boatPtN;\n        //ro = 1.2 * normalize(boatPos);\n       \tnewPos -= (.4 + 0.*.5*speed) * boatFo;\n        //ro = vec3( 0.,0.,-5.);//vec3(xoff,0.,zoff);\n        \n        if( iFrame == 0 )\n            camPt = newPos;\n        else\n            camPt = mix( camPt, newPos, 1.*dt );\n        \n        fragColor.xyz = camPt;\n        \n        float upKey = texture( iChannel0, vec2(KEY_UP,0.5/3.0) ).x;\n        float targetFOV = .33 + .12 * upKey;\n        \n        fragColor.w = mix( camFOV, targetFOV, 1.*dt );\n    }\n    else if( fragCoord == vec2(5.5,.5) )\n    {\n        // CAMERA UP\n        \n        // take from x vel of boat to lean into turn\n        fragColor.xyz = boatPtN - dot(boatV,oceanSurfFrame_R)*oceanSurfFrame_R;\n    }\n    else if( fragCoord.x > 10. && fragCoord.x < 19. )\n    {\n        // RELICS\n        \n        float relicIdx = fragCoord.x - 10.5;\n        \n        vec4 posStatus;\n        if( iFrame == 0 )\n        {\n            vec3 initPos;\n            if( relicIdx == 0. )\n            {\n                initPos = vec3( -.82, -.421, -.347 )*1.008;\n            }\n            else if( relicIdx == 1. )\n            {\n                initPos = vec3( -.415, .547, .714 ); //*1.008;\n            }\n            else if( relicIdx == 2. )\n            {\n                initPos = vec3( -.457, .825, .281 ); //*1.008;\n            }\n            else if( relicIdx == 3. )\n            {\n                initPos = vec3( -.35, -.05, .92 ) * 1.0;\n            }\n            else if( relicIdx == 4. )\n            {\n                initPos = vec3( -.452, -.078, -.885 ); //*1.008;\n            }\n            else if( relicIdx == 5. )\n            {\n                initPos = vec3( .864, .433, -.252 ) * .99; //*1.008;\n            }\n            else if( relicIdx == 6. )\n            {\n                initPos = vec3( .75*.94, .75*.94, .01 );\n            }\n            else if( relicIdx == 7. )\n            {\n                initPos = vec3( .538, -.41, .719 );\n            }\n            else if( relicIdx == 8. )\n            {\n                initPos = vec3( .488, .732, -.456 );\n            }\n            /*else if( relicIdx == 9. )\n            {\n                initPos = boatPt + .1*boatFo;\n                float lh = 1. + LandHeight( initPos );\n                initPos = 1.01*normalize(initPos)*lh;\n            }*/\n\t        posStatus = vec4(initPos,0.);\n        }\n        else\n        {\n            posStatus = texture( iChannel2, fragCoord/iResolution.xy );\n        }\n        \n        vec3 pos = posStatus.xyz;\n        bool collected = posStatus.w > 0.;\n        if( !collected )\n        {\n            collected = dot(boatPtN,normalize(pos)) > .995;\n            if( collected )\n                // record collect time\n                posStatus.w = iTime;\n        }\n        \n        if( collected )\n        {\n            // search for another relic to follow. due to webgl crapness have to search from 0 :/\n            float followDist = .02;\n            vec3 tgt = boatPt;\n            bool allCollected = true;\n            for( float otherRelic = 0.; otherRelic < RELIC_COUNT; otherRelic++ )\n            {\n                //if( otherRelic == relicIdx )\n                //    break;\n\n                vec4 otherPosStatus = texture( iChannel2, vec2(10.5+otherRelic,.5)/iResolution.xy );\n                bool collected = otherPosStatus.w > 0.;\n                allCollected = allCollected && collected;\n                if( collected && otherRelic < relicIdx )\n                {\n                    tgt = otherPosStatus.xyz;\n                    followDist = .0075;\n                }\n            }\n            \n            vec3 posOff = pos - tgt;\n            vec3 targetPos = tgt + followDist * normalize(posOff);\n            \n            // tend to water surface\n\t        float wh = 1. + WaterHeight( targetPos );\n            targetPos = normalize(targetPos)*wh * .99;\n            \n            //if( allCollected )\n            {\n                vec3 center = boatPt;\n                vec3 centerOff = targetPos-center;\n                float period = allCollected ? 5. : 11.;\n                float curDist = .14*mod(iTime, period );\n                float heightOff = 0.03 * max( 0., 2. - 200.*abs(dot(centerOff,centerOff)-curDist*curDist) );\n\t\t\t\ttargetPos += boatPtN * heightOff;\n            }\n            \n            pos = mix( pos, targetPos, min(1.,3.*dt) );\n        }\n        \n        fragColor = vec4( pos, posStatus.w );\n    }\n    /*\n    else if( fragCoord.x > 20. && fragCoord.x < 30. )\n    {\n        //FISH\n        float theta = iTime;\n        float radius = .015;\n        vec3 pos = oceanSurfFrame_O\n            + radius * (cos(theta)*oceanSurfFrame_R + sin(theta)*oceanSurfFrame_F);\n        fragColor = vec4(pos,0.);\n    }*/\n    else if( fragCoord.x == 20.5 )\n    {\n        // sun moves around with the player, tries to get in the players face now and then\n        vec3 targetSunDir = normalize(boatFo - dot(boatPtN,boatFo)*boatPtN);\n        float elev = (sin(4.6+.2*(iTime))*.5) * PI/2.;\n        targetSunDir = cos(elev)*targetSunDir + sin(elev)*boatPtN;\n        sunDir = normalize(mix( sunDir, targetSunDir, .15*dt ));\n        fragColor = vec4(sunDir, 1.);\n    }\n}\n\nvoid Quantize( vec3 pt, out vec3 pt0, out vec3 pt1, out vec3 pt2, out vec3 pt3, out vec2 f )\n{\n    float l = length(pt);\n    float q = .1*.3*sqrt(3.);\n    vec3 ap = abs(pt);\n    if( ap.z > ap.y )\n    {\n        if( ap.z > ap.x )\n        {\n            pt /= ap.z;\n            f = pt.xy - floor(pt.xy/q)*q;\n            pt.xy -= f; f /= q;\n            pt0 = l*normalize( pt );\n            pt1 = l*normalize( pt + vec3( q,0.,0.) );\n            pt2 = l*normalize( pt + vec3(0., q,0.) );\n            pt3 = l*normalize( pt + vec3( q, q,0.) );\n            return;\n        }\n    }\n    else if( ap.y > ap.x )\n    {\n        pt /= ap.y;\n        f = pt.xz - floor(pt.xz/q)*q;\n        pt.xz -= f; f /= q;\n        pt0 = l*normalize( pt );\n        pt1 = l*normalize( pt + vec3( q,0.,0.) );\n        pt2 = l*normalize( pt + vec3(0.,0., q) );\n        pt3 = l*normalize( pt + vec3( q,0., q) );\n        return;\n    }\n    pt /= ap.x;\n    f = pt.yz - floor(pt.yz/q)*q;\n    pt.yz -= f; f /= q;\n    pt0 = l*normalize( pt );\n    pt1 = l*normalize( pt + vec3(0., q,0.) );\n    pt2 = l*normalize( pt + vec3(0.,0., q) );\n    pt3 = l*normalize( pt + vec3(0., q, q) );\n    return;\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ray trace/march against opaque surfaces\n\n#define DIST_MAX 2.\n#define EPS 0.001\n#define RELICR 0.005\n#define BOATR .02\n#define RM_ITERS 55\n#define STEP_MUL .9\n// old settings: rmiters 72, stepmul .9\n\nvoid Camera( in vec2 p, out vec3 ro, out vec3 rd );\nvoid Quantize( vec3 pt, out vec3 pt0, out vec3 pt1, out vec3 pt2, out vec3 pt3, out vec2 f );\n\nfloat LandHeights2D( vec2 xy )\n{\n    xy *= 10.;\n    float h = 0.;\n    h += .05*sin(3.+1.5*(xy.x+.45*xy.y));\n   \th += .2*sin(4.+.5*(.73*xy.x-.52*xy.y));\n    h -= .1;\n    return h;\n}\nfloat LandHeight( vec3 pt )\n{\n    vec3 apt = normalize(abs(pt));\n    float xw = apt.x * LandHeights2D(pt.yz);\n    float yw = apt.y * LandHeights2D(pt.xz);\n    float zw = apt.z * LandHeights2D(pt.xy);\n    return xw + yw + zw;\n}\n\nfloat DELand( vec3 pt )\n{\n    vec3 pt0, pt1, pt2, pt3;\n    vec2 f;\n    Quantize( pt, pt0, pt1, pt2, pt3, f );\n    \n    float lh0 = LandHeight(pt0),\n        lh1 = LandHeight(pt1),\n        lh2 = LandHeight(pt2),\n        lh3 = LandHeight(pt3);\n    \n    float ptlen = length(pt);\n    pt0 = (1.+lh0) * pt0;\n    pt1 = (1.+lh1) * pt1;\n    pt2 = (1.+lh2) * pt2;\n    pt3 = (1.+lh3) * pt3;\n    \n    vec3 ptlerp;\n    \n    /*\n\t// tris - seems to work but for some reason makes the terrain colors go crazy\n    if( f.x > f.y )\n    {\n        vec3 w;\n        w.x = 1. - f.x;\n        w.z = f.y;\n        w.y = 1. - w.x - w.z;\n        //Barycentric( f, vec2(0.,0.), vec2(1.,0.), vec2(1.,1.), w.x, w.y, w.z );\n        //w[0] = 1.-f.x-f.y;\n        //w[1] = f.x;\n        //w[2] = f.y;\n        //w = 1.-w;\n        ptlerp = w[0]*pt0 + w[1]*pt1 + w[2]*pt3;\n    }\n    else\n    {\n        vec3 w;\n        w.x = 1. - f.y;\n        w.z = f.x;\n        w.y = 1. - w.x - w.z;\n        ptlerp = w[0]*pt0 + w[1]*pt2 + w[2]*pt3;\n    }\n\t*/\n    ptlerp = mix( mix( pt0, pt1, f.x ), mix( pt2, pt3, f.x ), f.y );\n    \n    return ptlen - length(ptlerp)/ptlen; // this divide compensates for quantize giving the 4 points with same length as input point\n    //return ptlen - (1. + mix( mix( lh0, lh1, f.x ), mix( lh2, lh3, f.x ), f.y ) );\n}\n\n#define BOATR .02\nfloat DEBoat( in vec3 pt, in vec3 boatPos, in vec3 boatFo, in vec3 boatUp )\n{\n    float res = DIST_MAX;\n    \n    vec3 boatRi = cross(boatFo,boatUp);\n    vec3 ptoff = pt - boatPos;\n    \n    float offri = dot(ptoff,boatRi);\n    float offup = dot(ptoff,boatUp);\n    float offfo = dot(ptoff,boatFo);\n    \n    //res = min( res, length( pt - (boatPos+.01*boatUp) ) - .0025);\n    float dSail = abs(offri+.4*offfo)-.0005;\n    if( false )\n    \tdSail = max( dSail, length(ptoff) - 0.019 );\n    else\n    {\n        //float sailR = sqrt(offri*offri + offfo*offfo +offup*offup);\n        //float sailR = sqrt(offri*offri + offfo*offfo );\n        //float sailR = abs(offri) + abs(offfo);\n        //dSail = max( dSail, sailR - 0.019 );\n        float hat = .025 - sqrt(offri*offri + offfo*offfo );\n        dSail = max( dSail, offup-hat );\n    }\n    dSail = max( dSail, -offup + .005 );\n    //dSail = max( dSail, -offup + .01 );\n    \n    res = min( res, dSail );\n    \n    pt = boatPos + ptoff - offri*boatRi + 2.4 * offri * boatRi\n        -offup * boatUp + 1.9 * offup * boatUp\n        ;\n    \n    float xr = abs( dot(pt-boatPos,boatRi) );\n    float zr = abs( dot(pt-boatPos,boatFo) );\n    float dDeck = dot( pt - boatPos, boatUp ) - (.002 + 16.*zr*zr + 8.*xr*xr);\n    \n    float dHull = max( dDeck, length(pt - boatPos) - BOATR );\n    res = min( res, dHull );\n    \n    return res;\n}\n\nvec3 NOpaque( vec3 pos, vec3 boatPos, vec3 boatFo, vec3 boatUp )\n{\n    vec2 dd = vec2(EPS,0.);\n    \n    float cBoat = DEBoat( pos, boatPos, boatFo, boatUp );\n    if( cBoat < EPS )\n    {\n        return normalize(\n            vec3( DEBoat(pos+dd.xyy,boatPos, boatFo, boatUp), DEBoat(pos+dd.yxy,boatPos, boatFo, boatUp), DEBoat(pos+dd.yyx,boatPos, boatFo, boatUp) )\n            ) - cBoat;\n    }\n    \n    float c = DELand(pos);\n    return normalize(\n        vec3( DELand(pos+dd.xyy)-c, DELand(pos+dd.yxy)-c, DELand(pos+dd.yyx)-c )\n        );\n}\n\n// from iq\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n// from iq, modified by huwb to give both intersections\nvoid sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph, out float t0, out float t1 )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n    if( h<0.0 ) { t0 = t1 = -1.; return; }\n    t0 = -b - sqrt( h );\n    t1 = -b + sqrt( h );\n}\n\nfloat RMBoat( in vec3 ro, in vec3 rd, in vec3 boatPos, in vec3 boatFo, in vec3 boatUp )\n{\n    float t = sphIntersect( ro, rd, vec4(boatPos,BOATR) );\n    if( t <= 0. ) return DIST_MAX;\n    float tboat = 0.;\n    for( int i = 0; i < 20; i++ )\n    {\n        vec3 x = ro + (t+tboat)*rd;\n        float d = DEBoat( x, boatPos, boatFo, boatUp );\n        tboat += STEP_MUL * d;\n        if( abs(d) < EPS ) return t+tboat;\n        if( tboat > 2.*BOATR ) break;\n    }\n    return DIST_MAX;\n}\nfloat RayMarchOpaque( in vec3 ro, in vec3 rd, in vec3 boatPos, in vec3 boatFo, in vec3 boatUp, float tmax )\n{\n    float t = 0.;\n    for( int i = 0; i < RM_ITERS; i++ )\n    {\n        vec3 x = ro + t*rd;\n        float d = DELand(x);\n        t += STEP_MUL * d;\n        if( abs(d) < EPS ) break;\n        if( t > tmax ) break;\n    }\n    \n    t = min( t, RMBoat( ro, rd, boatPos, boatFo, boatUp ) );\n    \n    /*float fishR = 0.01;\n    vec3 fishPos = texture(iChannel2,vec2(20.5,.5)/iResolution.xy).xyz;\n    float tfish = sphIntersect( ro, rd, vec4(fishPos,fishR) );\n    if( tfish > 0. )\n\t    t = min( t, tfish );*/\n    \n    return t;\n}\n\nvec3 NBoat( vec3 pos, vec3 boatPos, vec3 boatFo, vec3 boatUp )\n{\n    vec2 dd = vec2(EPS,0.);\n    float c = DEBoat( pos, boatPos, boatFo, boatUp );\n    return normalize(\n        vec3( DEBoat(pos+dd.xyy,boatPos, boatFo, boatUp)-c, DEBoat(pos+dd.yxy,boatPos, boatFo, boatUp)-c, DEBoat(pos+dd.yyx,boatPos, boatFo, boatUp)-c )\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy; p -= .5; p.x *= iResolution.x/iResolution.y;\n    \n    vec3 boatPos = texture( iChannel2, vec2(.5,.5)/iResolution.xy ).xyz;\n    vec3 boatVel = texture( iChannel2, vec2(1.5,.5)/iResolution.xy ).xyz;\n    vec3 boatFo = texture(iChannel2,vec2(2.5,.5)/iResolution.xy).xyz;\n    vec3 boatUp = texture(iChannel2,vec2(3.5,.5)/iResolution.xy).xyz;\n    \n    vec3 ro, rd;\n    Camera( p, ro, rd );\n    \n    vec4 landBoundingSphere = vec4( vec3(0.), 1. + .25 -.1 + 0.025 );\n    float si0, si1;\n    sphIntersect( ro, rd, landBoundingSphere, si0, si1 );\n    //float si = sphIntersect( ro, rd, landBoundingSphere );\n    bool cameraInsideVolume = dot( ro+si0*rd, rd ) > 0.; // first intersection travelling outwards\n    if( si1 < 0. )\n    {\n        // missed bounding sphere - no intersection\n        fragColor = vec4(vec3(0.),DIST_MAX);\n        return;\n    }\n    float tstart = max( si0, 0. );\n    float tmax = min( si1, DIST_MAX );\n    \n\n    float lastFrameWaterZ = texture(iChannel0,fragCoord/iResolution.xy).w;\n    // optimisation - only ray cast a limited amount into lastFrameWaterZ\n    if( lastFrameWaterZ > 0. )\n    \ttmax = min( tmax, lastFrameWaterZ + .3 );\n        \n    //float tboat = RMBoat( ro, rd, boatPos, boatFo, boatUp );\n    float topaque = RayMarchOpaque( ro, rd, boatPos, boatFo, boatUp, tmax );\n    // if exceeded tmax, write DIST_MAX to signify no hit\n    if( topaque > tmax ) topaque = DIST_MAX;\n    \n    vec3 nopaque = NOpaque( ro + topaque * rd, boatPos, boatFo, boatUp );\n    \n    fragColor = vec4(nopaque, topaque);\n}\n\nvoid Camera( in vec2 p, out vec3 ro, out vec3 rd )\n{\n    vec3 boatPos = texture( iChannel2, vec2(.5,.5)/iResolution.xy ).xyz;\n\tvec3 boatPosN = normalize( boatPos );\n    vec4 posAndFOV = texture( iChannel2, vec2(4.5,.5)/iResolution.xy );\n    \n    // camera eye pos\n    ro = posAndFOV.xyz;\n    // camera target\n    vec3 target = boatPos + .03*boatPosN;\n     \n    // camera frame\n    vec3 fo = normalize(target-ro);\n    vec3 up = texture( iChannel2, vec2(5.5,.5)/iResolution.xy ).xyz;\n    up = normalize( up - dot(up,fo)*fo );\n    vec3 ri = cross( up, fo );\n     \n    // multiplier to emulate a fov control\n    float fov = posAndFOV.w; // + .1*speed;\n\t\n    // ray direction\n    rd = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\nvoid Quantize( vec3 pt, out vec3 pt0, out vec3 pt1, out vec3 pt2, out vec3 pt3, out vec2 f )\n{\n    float l = length(pt);\n    float q = .1*.3*sqrt(3.);\n    vec3 ap = abs(pt);\n    if( ap.z > ap.y )\n    {\n        if( ap.z > ap.x )\n        {\n            pt /= ap.z;\n            f = pt.xy - floor(pt.xy/q)*q;\n            pt.xy -= f; f /= q;\n            pt0 = l*normalize( pt );\n            pt1 = l*normalize( pt + vec3( q,0.,0.) );\n            pt2 = l*normalize( pt + vec3(0., q,0.) );\n            pt3 = l*normalize( pt + vec3( q, q,0.) );\n            return;\n        }\n    }\n    else if( ap.y > ap.x )\n    {\n        pt /= ap.y;\n        f = pt.xz - floor(pt.xz/q)*q;\n        pt.xz -= f; f /= q;\n        pt0 = l*normalize( pt );\n        pt1 = l*normalize( pt + vec3( q,0.,0.) );\n        pt2 = l*normalize( pt + vec3(0.,0., q) );\n        pt3 = l*normalize( pt + vec3( q,0., q) );\n        return;\n    }\n    pt /= ap.x;\n    f = pt.yz - floor(pt.yz/q)*q;\n    pt.yz -= f; f /= q;\n    pt0 = l*normalize( pt );\n    pt1 = l*normalize( pt + vec3(0., q,0.) );\n    pt2 = l*normalize( pt + vec3(0.,0., q) );\n    pt3 = l*normalize( pt + vec3(0., q, q) );\n    return;\n}\n\n// Compute barycentric coordinates (u, v, w) for\n// point p with respect to triangle (a, b, c)\n/*void Barycentric( vec2 p, vec2 a, vec2 b, vec2 c, out float u, out float v, out float w )\n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float den = v0.x * v1.y - v1.x * v0.y;\n    v = (v2.x * v1.y - v1.x * v2.y) / den;\n    w = (v0.x * v2.y - v2.x * v0.y) / den;\n    u = 1. - v - w;\n}*/\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// ray trace/march against ocean\n\n#define DIST_MAX 2.\n#define EPS 0.001\n#define RM_ITERS 35\n#define STEP_MUL 1.4\n#define WAVE_AMP .0125\n// old settings: rmiters 72, stepmul .9\n\nvoid Camera( in vec2 p, out vec3 ro, out vec3 rd );\nvoid Quantize( vec3 pt, out vec3 pt0, out vec3 pt1, out vec3 pt2, out vec3 pt3, out vec2 f );\n\nfloat LandHeights2D( vec2 xy )\n{\n    xy *= 10.;\n    float h = 0.;\n    h += .05*sin(3.+1.5*(xy.x+.45*xy.y));\n   \th += .2*sin(4.+.5*(.73*xy.x-.52*xy.y));\n    h -= .1;\n    return h;\n}\nfloat LandHeight( vec3 pt )\n{\n    vec3 apt = normalize(abs(pt));\n    float xw = apt.x * LandHeights2D(pt.yz);\n    float yw = apt.y * LandHeights2D(pt.xz);\n    float zw = apt.z * LandHeights2D(pt.xy);\n    return xw + yw + zw;\n}\n\nfloat WaveHeights2D( vec2 xy )\n{\n    xy *= 10.;\n    float h = 0.;\n    h += sin(.9*iTime+3.5*(.01*xy.x+.45*xy.y));\n   \th += .5*sin(-1.3*iTime+3.9*(.01*.73*xy.x-.52*xy.y));\n    h *= WAVE_AMP;\n    return h;\n}\n\nfloat WaterHeight( vec3 pt )\n{\n    pt = normalize(pt);\n    vec3 apt = abs(pt);\n    float xw = apt.x * WaveHeights2D(pt.yz);\n    float yw = apt.y * WaveHeights2D(pt.xz);\n    float zw = apt.z * WaveHeights2D(pt.xy);\n    \n    float res = xw + yw + zw;\n    \n    float landH = LandHeight(pt);\n    res *= mix( 1., smoothstep( 0., -0.07, landH ), .8 );\n    \n    return res;\n}\nfloat DEOcean( vec3 pt )\n{\n    vec3 pt0, pt1, pt2, pt3;\n    vec2 f;\n    Quantize( pt, pt0, pt1, pt2, pt3, f );\n    \n    float wh0 = WaterHeight(pt0),\n        wh1 = WaterHeight(pt1),\n        wh2 = WaterHeight(pt2),\n        wh3 = WaterHeight(pt3);\n    float ptlen = length(pt);\n    pt0 = (1.+wh0) * pt0;\n    pt1 = (1.+wh1) * pt1;\n    pt2 = (1.+wh2) * pt2;\n    pt3 = (1.+wh3) * pt3;\n    \n    vec3 ptlerp;\n    \n    /*\n\t// tris - seems to work but for some reason makes the terrain colors go crazy\n    if( f.x > f.y )\n    {\n        vec3 w;\n        w.x = 1. - f.x;\n        w.z = f.y;\n        w.y = 1. - w.x - w.z;\n        //Barycentric( f, vec2(0.,0.), vec2(1.,0.), vec2(1.,1.), w.x, w.y, w.z );\n        //w[0] = 1.-f.x-f.y;\n        //w[1] = f.x;\n        //w[2] = f.y;\n        //w = 1.-w;\n        ptlerp = w[0]*pt0 + w[1]*pt1 + w[2]*pt3;\n    }\n    else\n    {\n        vec3 w;\n        w.x = 1. - f.y;\n        w.z = f.x;\n        w.y = 1. - w.x - w.z;\n        ptlerp = w[0]*pt0 + w[1]*pt2 + w[2]*pt3;\n        //ptlerp = mix( mix( pt0, pt1, f.x ), mix( pt2, pt3, f.x ), f.y );\n    }\n\t*/\n    ptlerp = mix( mix( pt0, pt1, f.x ), mix( pt2, pt3, f.x ), f.y );\n    \n    return ptlen - length(ptlerp)/ptlen;\n}\n\nvec3 NOcean( vec3 pos )\n{\n    vec2 dd = vec2(EPS,0.);\n    float c = DEOcean(pos);\n    return normalize(\n        vec3( DEOcean(pos+dd.xyy), DEOcean(pos+dd.yxy), DEOcean(pos+dd.yyx) ) - c\n        );\n}\n\nfloat RayMarchOcean( vec3 ro, vec3 rd, float tstart, float tmax )\n{\n    float t = tstart;\n    for( int i = 0; i < RM_ITERS; i++ )\n    {\n        vec3 x = ro + t*rd;\n        float d = DEOcean(x);\n        t += STEP_MUL * d;\n        if( abs(d) < EPS ) return t;\n        if( t > tmax ) break;\n    }\n    return t;\n}\n\n// from iq, modified by huwb to give both intersections\nvoid sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph, out float t0, out float t1 )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n    if( h<0.0 ) { t0 = t1 = -1.; return; }\n    t0 = -b - sqrt( h );\n    t1 = -b + sqrt( h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy; p -= .5; p.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro, rd;\n    Camera( p, ro, rd );\n    \n    vec4 oceanBoundingSphere = vec4( vec3(0.), 1. + 0.025 + 1.5*WAVE_AMP );\n    float si0, si1;\n    sphIntersect( ro, rd, oceanBoundingSphere, si0, si1 );\n    if( si1 == -1. )\n    {\n        // missed bounding sphere - no intersection\n        fragColor = vec4(vec3(0.),DIST_MAX);\n        return;\n    }\n    float tstart = max( si0, 0. );\n    float tmax = min( si1, DIST_MAX );\n    \n    float currentFrameLandZ = texture(iChannel0,fragCoord/iResolution.xy).w;\n    // don't raymarch into land - land always blocks water\n    tmax = min( tmax, currentFrameLandZ );\n    \n    float tocean = RayMarchOcean( ro, rd, tstart, tmax );\n    // if exceeded tmax, write DIST_MAX to signify no hit\n    if( tocean > tmax ) tocean = DIST_MAX;\n    \n    vec3 nocean = NOcean( ro + tocean * rd );\n    \n    fragColor = vec4(nocean, tocean);\n}\n\nvoid Camera( in vec2 p, out vec3 ro, out vec3 rd )\n{\n    vec3 boatPos = texture( iChannel2, vec2(.5,.5)/iResolution.xy ).xyz;\n\tvec3 boatPosN = normalize( boatPos );\n    vec4 posAndFOV = texture( iChannel2, vec2(4.5,.5)/iResolution.xy );\n    \n    // camera eye pos\n    ro = posAndFOV.xyz;\n    // camera target\n    vec3 target = boatPos + .03*boatPosN;\n     \n    // camera frame\n    vec3 fo = normalize(target-ro);\n    vec3 up = texture( iChannel2, vec2(5.5,.5)/iResolution.xy ).xyz;\n    up = normalize( up - dot(up,fo)*fo );\n    vec3 ri = cross( up, fo );\n     \n    // multiplier to emulate a fov control\n    float fov = posAndFOV.w; // + .1*speed;\n\t\n    // ray direction\n    rd = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\nvoid Quantize( vec3 pt, out vec3 pt0, out vec3 pt1, out vec3 pt2, out vec3 pt3, out vec2 f )\n{\n    float l = length(pt);\n    float q = .1*.3*sqrt(3.);\n    vec3 ap = abs(pt);\n    if( ap.z > ap.y )\n    {\n        if( ap.z > ap.x )\n        {\n            pt /= ap.z;\n            f = pt.xy - floor(pt.xy/q)*q;\n            pt.xy -= f; f /= q;\n            pt0 = l*normalize( pt );\n            pt1 = l*normalize( pt + vec3( q,0.,0.) );\n            pt2 = l*normalize( pt + vec3(0., q,0.) );\n            pt3 = l*normalize( pt + vec3( q, q,0.) );\n            return;\n        }\n    }\n    else if( ap.y > ap.x )\n    {\n        pt /= ap.y;\n        f = pt.xz - floor(pt.xz/q)*q;\n        pt.xz -= f; f /= q;\n        pt0 = l*normalize( pt );\n        pt1 = l*normalize( pt + vec3( q,0.,0.) );\n        pt2 = l*normalize( pt + vec3(0.,0., q) );\n        pt3 = l*normalize( pt + vec3( q,0., q) );\n        return;\n    }\n    pt /= ap.x;\n    f = pt.yz - floor(pt.yz/q)*q;\n    pt.yz -= f; f /= q;\n    pt0 = l*normalize( pt );\n    pt1 = l*normalize( pt + vec3(0., q,0.) );\n    pt2 = l*normalize( pt + vec3(0.,0., q) );\n    pt3 = l*normalize( pt + vec3(0., q, q) );\n    return;\n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// end game reward\n\n#define DIST_MAX 2.\n#define EPS 0.001\n#define RELIC_COUNT 9.\n\nvoid Camera( in vec2 p, out vec3 ro, out vec3 rd )\n{\n    vec3 boatPos = texture( iChannel0, vec2(.5,.5)/iResolution.xy ).xyz;\n\tvec3 boatPosN = normalize( boatPos );\n    vec4 posAndFOV = texture( iChannel0, vec2(4.5,.5)/iResolution.xy );\n    \n    // camera eye pos\n    ro = posAndFOV.xyz;\n    // camera target\n    vec3 target = boatPos + .03*boatPosN;\n     \n    // camera frame\n    vec3 fo = normalize(target-ro);\n    vec3 up = texture( iChannel0, vec2(5.5,.5)/iResolution.xy ).xyz;\n    up = normalize( up - dot(up,fo)*fo );\n    vec3 ri = cross( up, fo );\n     \n    // multiplier to emulate a fov control\n    float fov = posAndFOV.w; // + .1*speed;\n\t\n    // ray direction\n    rd = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\nfloat rewardFn( vec3 rd, vec3 dir, float tn )\n{\n    float r = 1.-.025*tn;\n    float thick = 1.- tn;\n    return abs(dot(dir,rd)-r)<.003*thick ? 1. : 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ive run out of texture slots on Image so im going to copy across the dynamics data in\n    // the first row of this buffer. yay!\n    if( fragCoord.y == .5 )\n    {\n        fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n        return;\n    }\n    \n    float currentFrameLandZ = texture(iChannel1,fragCoord/iResolution.xy).w;\n    float currentFrameWaterZ = texture(iChannel2,fragCoord/iResolution.xy).w;\n    \n    if( currentFrameLandZ < DIST_MAX || currentFrameWaterZ < DIST_MAX )\n        return;\n    \n    bool allCollected = true;\n    for( float i = 0.; i < RELIC_COUNT; i++ )\n    {\n        vec4 posStatus = texture( iChannel0, vec2(10.5+i,.5)/iResolution.xy );\n        \n        // not collected?\n        if( posStatus.w == 0. )\n        {\n            fragColor = vec4(0.);\n\t        return;\n        }\n    }\n    \n    \n\tvec2 p = fragCoord.xy / iResolution.xy; p -= .5; p.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro, rd;\n    Camera( p, ro, rd );\n    \n    float rew = 0.;\n    float period = 1.;\n    #define REWARDCOUNT 20\n    float phase[REWARDCOUNT];\n    phase[0] = 0.; phase[1] = period/4.; phase[2] = 3.*period/4.; phase[3] = 2.*period/4.; phase[4] = 1.5*period/4.;\n    for( int i = 0; i < REWARDCOUNT; i++ )\n    {\n        float tshifted = iTime+sin(398393.*float(i));\n        float t = fract(tshifted/period);\n        float idx = tshifted - t*period;\n        \n\t    vec3 dir = normalize( texture( iChannel3, vec2(idx,0.5+float(i))/64. ).xyz - .5 );\n        \n        rew = max( rew, rewardFn( rd, dir, t ) );\n    }\n    \n    fragColor = vec4(rew);\n}\n","name":"Buf D","description":"","type":"buffer"}]}