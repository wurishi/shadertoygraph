{"ver":"0.1","info":{"id":"MXBGDw","date":"1708513842","viewed":67,"name":"testytesttt","username":"0xdrip","description":"test","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define grad_step 0.01\n#define time iTime+2.31\n\n// Spectrum colour palette\n// Modified to create neonish colors\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.0, 0.5, 0), vec3(0, 0.1, 0.0), vec3(0, 1, 0), vec3(0, 0.1, 0) );\n}\n\nvec3 carToPol(vec3 p) {\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nmat3 rotationXY(vec2 angle) {\n    float cx = cos(angle.x);\n    float sx = sin(angle.x);\n    float cy = cos(angle.y);\n    float sy = sin(angle.y);\n    \n    return mat3(\n        cy, 0.0, -sy,\n        sx * sy, cx, sx * cy,\n        cx * sy, -sx, cx * cy\n    );\n}\n\nvec3 selfColor(vec3 pos) {\n    vec3 pol = carToPol(pos);\n    return spectrum(1.0 * pol.z / PI / 2.0 + 0.5 * pol.y / PI) * 2.0; // Increase brightness\n}\n\n// Distance function for a sphere\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// Operation for union of two shapes with smoothing parameter k\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// Operation for creating an \"onion\" shape by adding a thickness to a shape\nfloat opOnion(float sdf, float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat map( vec3 pos ){\n    \n    vec3 p2 = vec3(1.0*cos(-0.3*time),1.4*sin(time)*cos(-0.4*time),1.7*sin(time)*sin(-0.3*time));\n    float d2 = sdSphere( pos-p2, 0.2);\n    vec3 p3 = vec3(1.4*sin(0.3*time),0.2,-1.6*sin(0.3*time+0.3));\n    float d3 = sdSphere( pos-p3, 0.2);\n    vec3 p4 = vec3(0);\n    float d4 = sdSphere( pos-p4, 0.2);\n    float d00 = sdUnion_s(d2,d3,0.2);\n    \n    float d0 = sdUnion_s(d00,d4,0.2);\n\n    vec3 pol = carToPol(pos);\n    \n    float d1 = sdSphere( pos, 1.0 );\n    float wave = 0.07*sin(20.*(pol.y));\n    d1 = opOnion(d1+wave, 0.001);\n    \n    return sdUnion_s(d1,d0,0.3);\n    \n}\n\n\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ) - map( pos - dx ),\n\t\t\tmap( pos + dy ) - map( pos - dy ),\n\t\t\tmap( pos + dz ) - map( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\nfloat rCoeff(in vec3 p, in vec3 rd){\n    vec3 g = gradient(p);\n    g = rotationXY(vec2(2.0,1.0))*g;\n    float refl = 1.0-dot(g,rd);\n    return refl;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n//    vec3 ro = vec3( -5.0*cos(0.2*iTime+0.0), 0.0, 5.0*sin(0.2*iTime+0.0));\n    vec3 ro = vec3( 0.0, 5.0*cos(0.3*time), 5.0*sin(0.3*time));\n    vec3 ta = vec3( 0. , 0. , 0. );\n\n    \n    float aa = 1.0/min(iResolution.y,iResolution.x);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 1.5);  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy, 3.0) ); // 3.0 is the lens length\n    \n    // rotate camera with mouse\n    mat3 rot = rotationXY((iMouse.xy - iResolution.xy * 0.5).yx * vec2(0.01, -0.01));\n    rd = rot * rd;\n    ro = rot * ro;\n    vec3 col = vec3(0.1); // Dark background color\n    \n    // Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n    float t = 0.0, layers = 0.0, d, aD;\n    \n    // Surface distance threshold. Smaller numbers give a sharper object. Antialiased with aa\n    float thD = 0.5 * sqrt(aa); \n    \n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n    for(int i = 0; i < 80; i++) {\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers > 10.0 || col.x < 0.0 || t > 8.0) break;\n        \n        // Current ray postion\n        vec3 sp = ro + rd * t;\n        \n        d = map(sp); // Distance to nearest point in the cube field.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        aD = (thD - abs(d)) / thD; // Normalized distance from the surface threshold value to our current isosurface value.\n        \n        // If we're within the surface threshold, accumulate some color.\n        if(aD > 0.0) { \n            // Smoothly interpolate the accumulated surface distance value, then apply some\n            // basic falloff (fog, if you prefer) using the camera to surface distance, \"t.\"\n            // selfColor is the color of the object at the point sp\n            vec3 sc = selfColor(sp);\n            float refl = 0.1 * pow(exp(-4.0 * rCoeff(sp, rd)), 2.0);\n            col += sc * (aD * aD * (3.0 - 2.0 * aD) / (1.0 + t * t * 2.25) * 7.5);\n            col += refl;\n            layers++;\n        }\n        \n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit of \n        // knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        t += max(abs(d) * 0.5, thD * 0.8); \n    }\n    \n    // I'm virtually positive \"col\" doesn't drop below zero, but just to be safe...\n    col = max(col, 0.0);\n    \n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}