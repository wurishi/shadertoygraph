{"ver":"0.1","info":{"id":"lldSWX","date":"1481951370","viewed":210,"name":"VoidChicken Rewind 2016 Top 10","username":"VoidChicken","description":"Over about a year, I have made about 100 shaders on Shadertoy. Lets look at my top 10 ones this year. :D 93rd shader! (No particular order in rank)","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["2d","3d","chicken","history","movie","rewind"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sBGWw","filepath":"https://soundcloud.com/ma77/nightshade-4th-edit","previewfilepath":"https://soundcloud.com/ma77/nightshade-4th-edit","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Made by VoidChicken\n//Creative Commons 4.0 Attribution\n#define iRatio (iResolution.x/iResolution.y)\n#define ready(x, y) if (x>0.&&y<1.)\n#define MIN1(a,b) (a.x<b.x?a:b)\n#define T iTime\nconst float pi = acos(-1.);\nfloat timer(float gtime, float start, float end) {\n\treturn clamp((gtime-start)/(end-start), 0., 1.);\n}\nfloat trans1( vec2 uv, float time ) {\n\tfloat t = 0.;\n    if (uv.x+uv.y/10.<time*1.1) {\n    \tt=1.;    \n    }\n    return t;\n}\nvec3 opener( vec2 u,float t) {\n    u.x=(u.x-.5)*iRatio+.5;\n    vec3 c = vec3(.05);\n    vec2 k = u-.5;\n    if (abs(k).x<.25&&abs(k).y<.25) {\n    \tvec2 y = k/.5+.5;\n        float q = abs(y.y-.5)*2.;\n        vec3 o = c;\n        float au = mix(1.-y.x, y.x, (-cos(t*pi)*.5+.5));\n        if (q<au) {\n            float i = abs(q-au)/au;\n            \n            o=mix(o,vec3((.75+.25*sin(i+(1.-texture(iChannel3,vec2(0))).r*5.))),\n                pow(i,1./2.))\n                ;\n        }\n        \n        c=(o);\n    }\n    return c;\n}\n//SET 1\n\n\nvec3 L(vec3 d) {\n    return mix(vec3(0,.5,1), vec3(1), pow(max(dot(d, vec3(0, 1, 0)), 0.), .2));\n}\n\nvec3 shader1(  vec2 f )\n{\n\tvec2 R=iResolution.xy,u = f;\n    \n    vec3 d = vec3(u*2.-1., 1);\n   \n    vec3 po = vec3(0, 4, iTime);\n    vec3 p = po;\n    d.y*=R.y/R.x;\n     vec3 m = L(d+vec3(0, .6, 0));\n    \n    bool h = false;\n  \n    for (int i = 0; i < 96; ++i) {\n    \tfloat f = p.y+texture(iChannel0, p.xz/10.).r*2.+sin(p.x+p.z/10.)*cos(p.z-p.x/100.)-texture(iChannel0, p.xz/100.).r*2.;\n        if (length(p-po)>20.) break;\n        if (f < .2) {\n            h = true;\n           \n        }\n        p+=d*f/5.;\n    }\n    if (h)\n    \t    m = mix(\n                texture(iChannel1, p.xz).grb+(vec3(.8-length(p-po)/20.))/2.,\n                m, pow(length(p-po)/20., 25.))*(1.-texture(iChannel0, p.xz/10.).r*.7);\n    return pow(vec3(m)*(1.-length(u-.5)/1.62), vec3(1./1.5));\n}\n\n   //End1 \n//set 2 \nfloat R(float x) {return x+fract(x)<.5?0.:1.;}\nfloat cuboid ( vec3 p, vec3 b ) {\n\tfloat f = 0.;\n    vec3 a = abs(p)-b;\n    f = max(a.x, max(a.y, a.z));\n    \n    return f;\n}\n\nfloat lattice( vec3 p ) {\n\n    float f = 0.;\n    float r = .1;\n    float b = cuboid(p, vec3(1));\n   \n    f = max(abs(p.x)-r, abs(p.y)-r);\n    f = min(f, max(abs(p.x)-r, abs(p.z)-r));\n    f = min(f, max(abs(p.y)-r, abs(p.z)-r));\n  \n    return max(f, b);//+(length(p)-1.)/5.;\n    \n}\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nfloat map ( vec3 p ) {\n\n    p=fract(p)-.5;\n\treturn lattice(p);    \n}\nvec3 calcNormal( in vec3 x )\n{\n    vec2 e = vec2( .001, 0.0 );\n    return normalize( vec3( map(x+e.xyy) - map(x-e.xyy),\n                            map(x+e.yxy) - map(x-e.yxy),\n                            map(x+e.yyx) - map(x-e.yyx) ) );\n}\nfloat trace (vec3 o, vec3 d) {\n\tfloat t = 0.;\n    for (int i = 0; i < 64; ++i) {\n        float f = map(o+t*d);\n        \n        if (t>50.||f<.002) break;\n        t+=f;\n    }\n    return t;\n}\n\nvec3 uniperp ( vec3 n ) {\n\treturn n.yzx+n;    \n}\nvec3 stx (vec2 u) {\n\treturn texture(iChannel1,u).rgb;    \n}\nvec3 render( vec2 uv ) {\n    vec3 col = vec3(0);\n\tvec3 ro = vec3 (0,0, 4.);\n    ro*=rotationMatrix(vec3(-1,0,0),iTime/5.);\n    vec3 rd = vec3 (vec2(1, iResolution.y/iResolution.x)*(uv*2.-1.), 1);\n    rd=normalize(rd);\n    rd*=rotationMatrix(vec3(0,0,1),iTime);\n    rd*=rotationMatrix(vec3(1,1,0),iTime/5.);\n    float t = trace( ro, rd );\n    vec3 i = ro+rd*t;\n    float m = map(i);\n    if (m<.2) {\n        \n         vec3 l = vec3 (0,0, 4.);\n    \tl*=rotationMatrix(vec3(-1,0,0),iTime/5.+.314);\n        \n        vec2 uv = vec2(0);\n        vec3 n = calcNormal(i);\n        \n        uv=vec2(dot(i,uniperp(n)),dot(i,cross(uniperp(n), n)));\n        float u = .3*distance(l, i);\n        u=sqrt(u);\n        u/=dot(n,normalize(l-i));\n    \tcol = (stx(uv))*(1./t)/(u);    \n    }    \n    return col;\n}\nvec3 shader2( vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n\tvec3 col = vec3(0);\n\t\n    col+=render(uv);\n    return 1.-exp(-(vec3(col*(1.-length(uv-.5)))*sin(clamp(iTime-.25, 0., pi/2.)))*.6);\n}\n//end 2\n//set 3\n\n#define mul 2.0\nvec2 offset(vec2 uv) {\n\treturn (vec2(.5)-texture(iChannel0, uv+vec2(iTime/10.0)).xy)*mul;   \n}\nvec2 offseta(vec2 uv) {\n\treturn (vec2(.5, .5)-texture(iChannel0, uv+vec2(-iTime/10.0)).xy)*mul;\n}   \nvec3 shader3(  vec2 fragCoord )\n{\n\tvec2 uv = fragCoord;\n\treturn texture(iChannel0,uv+offset(uv)/100.0+offseta(uv)/100.0).rgb*vec3(0, 0.5,0.5);\n}\n//end 3\n//set 4\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\nfloat MUL = 10.;\nvec2 FLOW = vec2(1);\nfloat h (vec3 v) {\n    return snoise(vec3(v.x*MUL-T*FLOW.x,T,v.z*MUL-T*FLOW.y));\n}\nfloat function(vec3 v) {\n    return v.y-h(v);\n}\nvec3 calcNormal( in vec3 x, in float eps )\n{\n    vec2 e = vec2( eps, 0.0 );\n    return normalize( vec3( function(x+e.xyy) - function(x-e.xyy),\n                            function(x+e.yxy) - function(x-e.yxy),\n                            function(x+e.yyx) - function(x-e.yyx) ) );\n}\nvec3 shader4(  in vec2 fragCoord )\n{\n   \tvec2 mm = iMouse.xy;\n    if (mm==vec2(0)) mm=iResolution.xy/2.;\n\tvec2 uv = fragCoord.xy;\n    //FLOW = normalize(vec2(iMouse.xy/iResolution.xy*2.-1.));\n    vec3  v = calcNormal(vec3(uv.x,1,uv.y),.01);\n    vec3 p = vec3(mm.x/iResolution.x*2.-1.,2,mm.y/iResolution.y*2.-1.);\n    vec3 d = vec3(uv.x*2.-1., 0, uv.y*2.-1.);\n\treturn vec3( texture(iChannel1,uv+(v.xz/15.*.25))*clamp(max(dot(v,p-d),0.)+.6,0.,1.)*clamp(3.-distance(d,p)+.6,0.,1.) );\n}\n\n//end 4\n//set 5\nvec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         \n              );\n}\nvec3 tnt( sampler2D samp, in vec2 uv, float v )\n{\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n\tvec3 va = vec3(0.0);\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec4 o = hash4( p + g );\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + v*o.zw, ddx, ddy ).xyz;\n\t\tva += w*c;\n\t\twt += w;\n    }\n\t\n    return va/wt;\n}\n\n\n\nfloat height( vec3 q ) {\n\tfloat f;\n    f  = 0.50000*snoise( q ); \n    f += 0.25000*snoise( q ); \n    f += 0.12500*snoise( q ); \n    f += 0.06250*snoise( q ); \n    f += 0.03125*snoise( q ); \n    return f;\n}\nfloat map2( vec3 r ) {\n\treturn \n         (r.y-height(vec3(r.xz/10.,0))*2.)+snoise(r/((tnt(iChannel2, r.xz/10., r.x+r.z).r+1.)/3.))/5./3.;\t\n}\nfloat cld( vec3 r ) {\n\treturn r.y-(height(vec3(r.xz/5.+iDate.w*vec2(0, 2),0))*4.+3.)+snoise(r)*2.+snoise(r*2.55);\t\n}\nconst float pr = .02;\nvec4 march(vec3 ro, vec3 rd) {\n    vec3 r = ro;\n    bool hit = false;\n    float t = 0.;\n    float q = 0.;\n   \tfloat tf = 0.;\n    int j = 0;\n    vec3 cdl = vec3(0);\n    bool cht = false;\n    for ( int i = 0; i < 90; ++i ) {\n        float df = map2(r);\n        t= ((r-ro)/rd).r;\n        if (df < pr*10.) {\n        \tq += df;\n        }\n        if ((df < pr&&df>-.5)||t>50.) {\n            if (df < pr) {\n                \n            hit = true;\n            }\n            break;\n        }\n        if (df<-.5) {\n\t\t\tdf = -df/2.;\n        }\n        float cl = cld(r);\n        tf += cl;    \n        if (cl < pr) {\n            j++;\n            vec3 a = tnt(iChannel2, (r.zy+r.xz+r.xy+vec2(iTime*0.)+float(j))/10., 1.).rrr*smoothstep(6., 0., clamp(tf, 0., 6.)/6.);\n        \tcdl += a*sqrt(float(j))*1.5*pow(smoothstep(0., 1., clamp(float(j)/15., 0., 1.)), 1./2.5);\n            cht = true;\n        }\n        r+=rd*df;\n    }\n    vec3 O = vec3(1.2, 1.1, 1);\n    vec3 COL = O;\n    \n    if (hit) {\n   \t\tvec3 sand = .5*(tnt(iChannel1, r.xz+snoise(r)/2., 1.)+tnt(iChannel2, r.xz/4., 2.).rrr*vec3(1.2, 1.1, 0)/2.)*vec3(1.1, 1.2, 1);\n        COL = sand*.8/(1.-height(vec3(r.xz/10.,0))*.6);\n        \n    }\n    COL += max(vec3(0.),cdl/float(j)*.2)*clamp((t-tf), 0., 1.);\n    float fog = clamp((50.-t)/(50.-30.), 0., 1.);\n    return vec4(mix(COL,O, 1.-fog), clamp(q/4., 0., 1.));\n}\n\nvec3 shader5(  in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord;\n    uv = uv*2.-1.;\n    uv.y*=iResolution.y/iResolution.x;\n\treturn march(vec3(0, mix(height(vec3(vec2(0, iTime*7.)/10.,0)*2.)+3.4, 7., iMouse.w>0.?iMouse.y/iResolution.y:.5*(sin(iTime/10.)+1.)), iTime*9.), vec3(uv, 1)*rotate(vec3(1,0,0),cos(iTime*1.*texture(iChannel3, vec2(iTime/30.)/10., 10.).r/10.)*.05-.05)*rotate(vec3(0,1,0),.6*sin(iTime/5.+texture(iChannel3, vec2(iTime)/50.).r/10.)*3.14/2.)).xyz;\n}\n//end 5\n//set 6\n#define R(x) (fract(x)<.6?floor(x):ceil(x))\nfloat M ( vec3 x ) {\n    return length(x)-2.;\n}\nfloat N(vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\t\n\tvec2 u = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 g = texture( iChannel2, (u+.5)/256., -100. ).yx;\n\treturn mix( g.x, g.y, f.z );\n}\nfloat p=atan(1.)*4.;\nvec3 shader6(  vec2 f )\n{\n    float tt = iTime-99.;\n    tt*=15./20.;\n\tvec2 R=iResolution.xy,k=f;\n    float j = sin(min(.5,tt/24.)*p);\n    vec3 c,o=vec3(mix(2.8, 0., j), 0, -5.*j),d=normalize(vec3(vec2(1,R.y/R.x)*(k*2.-1.+(k-.5)/40.),1)),i;\n \n    float t = 0.;\n    for (int i = 0; i < 64; ++i)\n        t+=M(o+d*t);\n    i=o+d*t;\n    if (M(i)<.2){\n        vec3 g=vec3(.96,.66,.29),z=vec3(0,.35, .035),n = normalize(i);\n    \tfloat t,q,l=.5+max(0., dot(n, vec3(1,1,-3))), o=min(1.,tt/8.);\n        \n        t=N(i+o);\n        t=max(t,0.);\n       \tq=N(i*200.+o)+.2;\n        q=(max(.9,q)-.9)/.2;\n        c=R(t)*g*q*.7+.3*mix(z,vec3(0,.2,1),1.-t);\n    }\n\treturn c.xyz*min(tt*.25, 1.)*max(min(15.-tt,1.),0.)*(1.62-length(k-.5));\n}\n//end 6\n//set 7\nvec3 flag ( vec2 u ) {\n    vec3 c = vec3(1);\n    if (fract(u.y*13.5)>.5) {\n    \tc = vec3(1,0,0);    \n    }\n    if ((u.x<.3&&u.x<.31)&&u.y>.7) {\n       \n    \tc = vec3(0, 0, 1);    \n    }\n\treturn c;    \n}\nvec3 shader7(  in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    uv-=.5;\n    uv*=2.;\n    uv+=.5;\n    uv+=texture(iChannel2, vec2(1)*iTime/100./4.).rg/45.;\n    vec3 col = vec3(0.1, .4, 1.);\n    if (uv.y<cos(uv.x*3.)/3.) col = vec3(0,.3,0);\n    \n    {\n        vec2 u = uv+vec2(0, sin(iTime*5.-uv.x*20.)/20.*(uv.x-.2));\n        if (u.x>.2&&u.x<.5) {\n            if (u.y<.8&&u.y>.5) {\n                col = flag(u)*(1.8-max(.9, sin(iTime*5.-uv.x*20.)/4.+.8));\n            }    \n        }\n       \tif (abs(u.x-.2)<.002&&uv.y<.8)\n          \tcol = vec3(min(.7/(abs(u.x-.2)*700.), .8));\n    }\n    \n    if (uv.y<cos(uv.x*10.)/10.) col = vec3(0,.6,0);\n    if (uv.y<sin(uv.x*5.)/10.) col = vec3(0,1,0);\n    \n    col*=1.-length(uv-.5);\n    if (length(uv-.9)<.1) col = vec3(1,1,0)/(length(uv-.9)*13.);\n    \n\treturn col;\n}\n//end 7\n//set 8\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 shader8(  in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv+=.5;\n    vec3 col = vec3(0);\n    float v = 0.;\n    \n    float u = texture(iChannel3, vec2(.25*uv.x+uv.y*.17, 1.)+iTime).r;\n    u+=texture(iChannel0, vec2(.17*uv.x+uv.y*.25, 1.)).r;\n    u/=2.;\n    v+=tan(u)/pow(u, 1.5);\n    v*=min(1., sin(min(iTime,4.)/4.*3.14159/2.));\n    col = hsv2rgb(fract(vec3(uv.x/5.-1.6, uv.y ,sin(iTime*2.-2.*u)/4.+.7)))*(1.-length(uv-.5));\n    if (abs(length(uv-.5)-(.1+v/10.))<.002) {\n\t\tcol = vec3(fract(u+uv.x*uv.y+.1*iTime), 1, 1);    \t    \n    }\n    \n\treturn hsv2rgb(col)/(abs(length(uv-.5)-(.1+v/10.))*1000.);\n}\n\n//end 8\n//set 9\n\nvec3 tex( vec2 u ) {\n    float k = 0.;\n    k=(sign(sin(u.x*3.14))+sign(sin(u.y*3.14)));\n    float jt =  ((sin(u.x*3.14))+(sin(u.y*3.14)));\n    vec3 i = vec3(.2,.1,0)*pow(abs(1.-clamp(jt, 0., 1.)), 10.);\n    i+=abs(jt)/2.;\n    return i;\n}\nfloat pRTd( vec3 o, vec3 d ) {\n    if (d.y>=0.) return 10.; \n    return ((o.y-2.)/(-d.y));\n}\nfloat smin( float a, float b )\n{\n    float k = 2.;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat map ( vec3 o, vec3 d ) {\n    vec2 sph = (mod(o.xz, 10.)-5.);\n\treturn smin(pRTd(o, d), length(vec3(sph.x, o.y, sph.y))-(4.));    \n}\nfloat trace1( vec3 o, vec3 d ) {\n\tfloat t = 0.;\n    for (int i = 0; i < 64; ++i) {\n        float f = map(o+d*t, d);\n        if (t>30.||f<.02) break;\n        t+=f*.7;\n    }\n    return t;\n}\nvoid render ( vec2 u, out vec4 c ) {\n    vec3 col = vec3(1);\n    vec3 o = vec3 (0, 6, iTime*3.),\n        d = normalize(vec3(vec2(iResolution.x/iResolution.y, 1)*(u*2.-1.), 1));\n\t\n    float t = 0.;\n    float hit = 0.;\n    t=trace1(o, d);\n    \n    vec3 r = o+t*d;\n    hit=-(map(r, d)-.2);\n    \n    if (hit>=0.) {\n   \t\t col=mix(col, tex(r.xz).rgb, (1.-t/30.));   \n    }\n    col=col*col;\n    col+=texture(iChannel0, u.xy+1000.*(iTime)).r/20.;\n\tcol*=min(1.,iTime*.25);\n    c=1.-exp(-col.xyzx*(1.-pow(length(u-.5), 2.))*2.13);\n}\nvec3 shader9( in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord;\n    vec4 c = vec4(0);\n    render ( uv,c);\n    return c.rgb;\n}\n\n//end 9\n//set 10 \n\nfloat FOV = 60.; //60 degrees FOV\nvec2 project( vec3 p ) {\n    float RAD = FOV/360.*pi;\n    float DVN = p.z;\n    return p.xy/DVN+.5;\n}\nfloat line ( vec2 p, vec2 a, vec2 b, float r ) {\n\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 ac = abs( pa - ba*h );\n    return ac.x+ac.y - r;\n    \n}\nfloat lp(vec2 p, vec2 a, vec2 b) {\n\tfloat xP = (p.x-min(a.x,b.x));\n    float xFP = xP/abs(a.x-b.x);\n    float yP = (p.y-min(a.y,b.y));\n    float yFP = yP/abs(a.y-b.y);\n    return xFP>yFP?xP:yP;\n}\nmat3 rmx(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n              );\n}\nvec3 poly[4];\nvec2 proj[4];\nvec3 shader10( in vec2 fragCoord )\n{\n    poly[0]=vec3(-1, -1, 0);\n    poly[1]=vec3(1, -1, 0);\n    poly[2]=vec3(1, 1, 0);\n    poly[3]=vec3(-1,1,0);\n\tvec2 uv = fragCoord.xy;\n    float df = 5000000.;\n    for (int i = 0; i < 4; i++) {\n    \tproj[i]=project(poly[i]*rmx(vec3(cos(iTime),1,sin(iTime)), iTime)+vec3(0,0,3));    \n    }\n    float lv = 0.;\n    for (int i = 0; i < 4; i++) {\n        vec2 nv =  proj[i+1];\n        if (i+1>3){\n        \tnv=proj[0];    \n        }\n    \tdf=min(df,line(uv, proj[i],nv, .002)); \n\t\tlv=lp(uv,proj[i],nv);\n    }\n\n    vec3 c = vec3(0);\n    if (df<.02) {\n     \tvec3 ct = texture(iChannel0, vec2(lv)).rgb;\n        c=pow(1.-df/.02,5.)*ct;\n    }\n\treturn c;\n}\n\n//end 10\nfloat tval( float i ) {\n\treturn timer(iTime, i*20.-1.,i*20.);    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 c = vec3(0);\n  \n    float t1 = timer(iTime, 0., 1.);\n    float t2 = timer(iTime, 4., 5.);\n    float t3 = trans1(uv, tval( 1. ) );\n    float t4 = trans1(uv, tval( 2. ) );\n    float t5 = trans1(uv, tval( 3. ) );\n    float t6 = trans1(uv, tval( 4. ) );\n    float t7 = trans1(uv, tval( 5. ) );\n    float t8 = trans1(uv, tval( 6. ) );\n    float t9 = trans1(uv, tval( 7. ) );\n    float t10= trans1(uv, tval( 8. ) );\n    float t11= trans1(uv, tval( 9. ) );\n    vec3 s1 = vec3(0);\n    ready(t1, t2) s1=opener(uv,timer(iTime, 1.,4.));\n    \n    vec3 s2 = vec3(0);\n    ready(t2, t3) s2=shader1(uv);\n    \n    vec3 s3 = vec3(0);\n    ready(t3, t4) s3=shader2(uv);\n    \n    vec3 s4 = vec3(0);\n    ready(t4, t5) s4=shader3(uv);\n    \n    vec3 s5 = vec3(0);\n    ready(t5, t6) s5=shader4(uv);\n    \n   \tvec3 s6 = vec3(0);\n    ready(t6, t7) s6=shader5(uv);\n   \t\n    vec3 s7 = vec3(0);\n    ready(t7, t8) s7=shader6(uv);\n    \n    vec3 s8 = vec3(0);\n    ready(t8, t9) s8=shader7(uv);\n    \n    vec3 s9 = vec3(0);\n    ready(t9, 0.) s9=shader8(uv);\n    \n    vec3 s10 = vec3(0);\n    ready(t10, t11) s10=shader9(uv);\n    \n    vec3 s11 = vec3(0);\n    ready(t11, 0.) s11=shader10(uv);\n   \n    c=mix(vec3(0), s1, t1);\n    c=mix(c, s2, t2);\n    c=mix(c, s3, t3);\n    c=mix(c, s4, t4);\n    c=mix(c, s5, t5);\n    c=mix(c, s6, t6);\n    c=mix(c, s7, t7);\n    c=mix(c, s8, t8);\n    c=mix(c, s9, t9);\n    c=mix(c,s10,t10);\n    c=mix(c,s11,t11);\n    c=mix(c,vec3(0.),tval(10.));\n    \n    c-=max(0., pow(abs(uv.y-.5),5.))*3.;\n    float hot = timer(iTime,0., 200.);\n \n    vec2 q = vec2(hot,.095);\n    float cld= length(q*vec2(iResolution.x/iResolution.y,1)-vec2(uv.x*iResolution.x/iResolution.y,uv.y));\n    \n   \n    \n    if (uv.y<.1) {\n    \tc=mix(vec3(25./256.),c,.2);    \n        vec2 v = uv/.1;\n        if (uv.y >.09) {\n            vec3 a = c+.1;\n            if (uv.x<hot) {\n                a=vec3(1, 0,0)*clamp(cld*60.,.3,1.);\n            }\n        \tc=a;    \n        }else\n        if (v.x>.1&&v.x<.4&&v.y<.8&&v.y>.1&&abs(.1+.3/2.-v.x)>.05) {\n         \tc=vec3(1);   \n        }\n    }\n      if (cld<.009) {\n        \tc=vec3(1);\n          \n      \t\tif (cld<.006) {\n        \t\tc=vec3(1,0,0)*(1.-clamp(cld*100.,.3,1.));    \n        \t}\n        }\n    \n    float qm = 0.;\n    if (hot == 1.) {\n    \tqm = iTime/200.-1.;\n        qm *= 200.;\n    }\n\tfragColor = vec4(c,1)*(1.-clamp(qm,0.,1.));\n}","name":"Image","description":"","type":"image"}]}