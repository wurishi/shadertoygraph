{"ver":"0.1","info":{"id":"dt33WS","date":"1683023052","viewed":114,"name":"Schwarz Ribbons","username":"dansh0","description":"Playing around with low step count on volumetric rendering.\nThrowing in Schwarz TPMS for the first time for me.\nI definitely need to put more time into optimizations but I'm happy with the design at least.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric","orthographic","schwarz"],"hasliked":0,"parentid":"msySDW","parentname":"Orthographic RayMarcher Template"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS_BOUNDS 10000\n#define MAX_STEPS_FILL 8\n#define SUBSTEPS 1\n#define MAX_DIST 400.\n#define MIN_DIST 0.01\n#define DOTS_PER_MM 10.\n#define NORM_EPS 0.001\n#define PI 3.141592\n\n// PARAMS\nfloat tpmsDiv = 5.0; // # of periods within the volume\nfloat cDist = 200.; // Camera distance from center\nvec3 objCol = vec3(1.0, 1.0, 1.0); // Base material color\nvec3 lCol = vec3(1.0, 1.0, 1.0); // Light color\nvec3 lPos = vec3(0.); // Light source position\nfloat alStr = 0.2; // Ambient light strength\nfloat dlStr = 0.8; // Diffuse light strength\n\n// Globals\nfloat scl; // Part Size\nfloat tpmsSc; // Fill Periodicity\nfloat tpmsFac; // Fill Density (width only in this case)\n\n// GEOMETRY\n    \n// Sphere SDF\nfloat dSphere(vec3 p, vec3 c, float r) {\n    vec3 transPoint = (p - c);\n    return length(transPoint) - r;\n}\n\n// Schwarz SDF\nfloat dSchwarz(vec3 p) {\n    p *= tpmsSc;\n    float fac = 0.10 + 0.075*sin(2.0*PI*(mod(iTime,10.0)/10.0 + 4.0*length(p)/scl));\n    return abs(dot(cos(p), vec3(1.0))) - fac;\n}\n    \n\n// GEOMETRY COMBINATIONS\n\n// Distance Function Combine\nfloat dComb( vec3 p ) {\n    \n    // geometry\n    float sph = dSphere( p, vec3(0.), scl);\n    float tpms = dSchwarz(p);\n    \n    return max(tpms, sph);\n    \n}     \n\n    \n// RAY TOOLS\n    \n// Ray March for boundary\nfloat mrch(vec3 p, vec3 d) {\n    float dist = 0.;\n    for (int iStep=0; iStep<MAX_STEPS_BOUNDS; iStep++) {\n        float mDist = dSphere( p, vec3(0.), scl);\n        if (mDist > MIN_DIST && dist < MAX_DIST) {\n            p += mDist * d;\n            dist += mDist;\n        } else {\n            return dist;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Volumetric raymarch for fill\nfloat mrchFixSt(vec3 p, vec3 d, float bDist, float step, out int iter) {\n            \n    // start at start of bounding sphere\n    vec3 bPos = p + bDist * d;\n    float dist = bDist; \n    p = bPos;\n\n    for (int iStep=0; iStep<MAX_STEPS_FILL; iStep++) {\n        float sdfDist = dComb(p);\n        if (sdfDist>MIN_DIST && dist<MAX_DIST) {\n            p += step * d;\n            dist += step;\n        } else {\n            iter = iStep;\n            return dist;\n        }\n    }\n    return MAX_DIST;\n}\n    \n// tpmsGradient instead of normal (maybe the same??)\nvec3 tpmsGrad(vec3 p) {\n    vec3 change;\n    change.x = dSchwarz(p + vec3(NORM_EPS, 0, 0)) - dSchwarz(p - vec3(NORM_EPS, 0, 0));\n    change.y = dSchwarz(p + vec3(0, NORM_EPS, 0)) - dSchwarz(p - vec3(0, NORM_EPS, 0)); \n    change.z = dSchwarz(p + vec3(0, 0, NORM_EPS)) - dSchwarz(p - vec3(0, 0, NORM_EPS)); \n    return normalize( change );\n}\n\n\n// CAMERA TOOLS\n\n// Orbit Controls\nvec3 orbitCtrl(float cDist, vec2 sphAngles) {\n    // spherical angles is x = theta -PI to PI and y = phi -PI/2 to PI/2\n    vec3 cPos;\n    cPos.x = cDist * cos(sphAngles.x) * sin(sphAngles.y);\n    cPos.z = cDist * sin(sphAngles.x) * sin(sphAngles.y);\n    cPos.y = cDist * cos(sphAngles.y);\n    return cPos;  \n}    \n\n\n// Camera Fragment Position (Orthographic)\nvec3 orthoFragP(vec3 cPos, vec3 cDir, vec2 cSize, vec2 fCoord) {\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    if (cDir.x == 0.0 && cDir.z == 0.0 && cDir.y != 0.0) {\n        up = vec3(0.0, 0.0, 1.0);\n    }\n    vec2 off = ((fCoord / iResolution.xy) * cSize) - (cSize * 0.5);\n    vec3 rCh = normalize(cross(cDir, up));\n    vec3 upCh = normalize(cross(rCh, cDir));\n    vec3 wrldOff = off.x * rCh + off.y * upCh;\n    return cPos + wrldOff;\n}\n\n    \n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Background color default\n    vec3 col = vec3(0.0);\n    \n    // Set Geometry Size\n    float hMargRg = (iResolution.y + 30.) / 2.0;\n    float marg = -iResolution.y + hMargRg * (1.0-cos(iTime/50.0));//-iResolution.y; \n    float sphRPx = min(iResolution.y, iResolution.x)/2.0 - marg;\n    scl = sphRPx / DOTS_PER_MM;\n    tpmsSc = (2.0*PI)/((2.0*scl)/tpmsDiv);\n    \n    // Init camera\n    vec2 cSize = iResolution.xy / DOTS_PER_MM;\n    vec2 cAngles = vec2(sin(iTime/20.0)*PI, (PI/2.0)+(sin(iTime/25.0-PI/2.0))*0.999*(PI/2.0));\n    //fragColor = vec4(vec3(-1.0*cAngles.y/(2.0*PI), cAngles.y/(2.0*PI), 0.0), 1.0);\n    vec3 cPos = orbitCtrl(cDist, cAngles);\n    vec3 cDir = normalize(-cPos);\n    vec3 fragPos = orthoFragP(cPos, cDir, cSize, fragCoord);\n    \n    // Ray March Step Boundary\n    float objDist = mrch(fragPos.xyz, cDir);\n    vec3 objPos = fragPos + cDir * objDist;\n    \n    // Ray March Fixed Step Lattice\n    float step = 2.0*scl / float(MAX_STEPS_FILL);\n    int iter;\n    float tpmsDist = mrchFixSt(fragPos.xyz, cDir, objDist, step, iter);\n    vec3 tpmsPos = fragPos + cDir * tpmsDist;\n    \n    \n    if (tpmsDist < MAX_DIST) {\n        // Find gradient\n        vec3 grad = tpmsGrad(tpmsPos);\n        objCol = 1.0 - abs(grad)/2.0;\n        \n        // Color Based on Iteration\n        float colMod = 3.0;\n        float iterVal = floor(abs(mod(float(iter),8.0)-3.9));\n        vec3 colMult = vec3(float(iterVal>2.0), float(iterVal<2.0), float(iterVal>0.0));\n        objCol *= colMult*colMod;\n        \n        // Ambient Lighting\n        vec3 ambiLight = lCol * alStr;\n        \n        // Diffuse Lighting\n        vec3 diffDir = normalize(lPos - tpmsPos);\n        vec3 diffLight = lCol * dlStr * max(dot(grad, diffDir), 0.0);\n        \n        // Combined Lighting\n        vec3 combLight = ambiLight + diffLight;\n        col = combLight * objCol;\n\n    } else {\n        // Background\n            col = vec3(abs(dSchwarz(vec3(fragCoord.xy*(5.0),iTime/2.0)/tpmsSc))*0.1);\n    \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}