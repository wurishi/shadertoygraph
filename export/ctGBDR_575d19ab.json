{"ver":"0.1","info":{"id":"ctGBDR","date":"1701966396","viewed":123,"name":"PerfTest Branching Samples","username":"gehtsiegarnixan","description":"Performance Test to see how one can sample different amount of textures for different pixels.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["test","texture","performance","sample","speed"],"hasliked":0,"parentid":"mdSfRw","parentname":"PerfTest Cubemapping"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis performance test aims to check methods for variable sample count \nbetween pixels. I find the results below a bit suprising, I would have\nexpected \"if\" the be worse than 2 samples since I read that both sides \nare executed, but apparently not. Branch predication may be the reason.\nFeel free to correct mistakes or add notes. \n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS are below your monitors refreshrate \n    (probably somewhere around 60-144 fps)\n- Modify TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n*/\n\n// Number of repeats of the test, 5000 should be enough for RTX3080\n#define REPEAT 1\n\n// switch between the test cases\n// 0 = sample 1 texture ~ 112 fps\n// 1 = sample 1 textureGrad ~ 60 fps\n// 2 = sample 2 textures ~ 30 fps\n// 3 = sample 2 textureGrad ~ 13 fps\n// 4 = sample 1-2 textures using if 73 fps\n// 5 = sample 1-2 textureGrad using if 43 fps\n// 6 = sample 1-2 textures using if with pixel mask 40 fps\n// 7 = sample 1-2 textures using for 67 fps\n#define TEST 7\n\n// sample 1 texture\nvec4 singleTex(vec2 uv) {\n    return texture(iChannel0, uv);\n}\n\n// sample 1 texture with partial derivatives mips\nvec4 singleTexGrad(vec2 uv) {\n    // Mip caculation for testing\n    vec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );\n\n    return textureGrad(iChannel0, uv, duvdx, duvdy);\n}\n\n// sample two textures\nvec4 doubleTex(vec2 uv) {\n    // sample two textures with different uvss\n    vec4 a = texture(iChannel0, uv);\n    vec4 b = texture(iChannel0, uv.yx);\n    \n    // 50/50 lerp between them\n    return mix(a,b,0.5);\n}\n\n// sample two textures with partial derivatives mips\nvec4 doubleTexGrad(vec2 uv) {\n    // Mip caculation for testing\n    vec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );\n\n    // sample two textures with different uvss\n    vec4 a = textureGrad(iChannel0, uv, duvdx, duvdy);\n    vec4 b = textureGrad(iChannel0, uv.yx, duvdx, duvdy);\n    \n    // 50/50 lerp between them\n    return mix(a,b,0.5);\n}\n\n// switch 50/50 between 1 and 2 samples using if\nvec4 ifTex(vec2 uv) {\n    if (uv.x < uv.y) {\n        // rotating this texture to make even harder\n        return singleTex(vec2(uv.y, -uv.x));\n    } else {    \n        return doubleTex(uv);\n    }\n}\n\n// switch 50/50 between 1 and 2 samples using if with partial derivatives mips\nvec4 ifTexGrad(vec2 uv) {\n    if (uv.x < uv.y) {\n        // rotating this texture to make even harder\n        return singleTex(vec2(uv.y, -uv.x));\n    } else {    \n        return doubleTexGrad(uv);\n    }\n}\n\n// switch 50/50 between 1 and 2 samples using if and chess pattern\nvec4 ifChessTex(vec2 uv, vec2 fragCoord) {\n    // amplify the pixels for debugging\n    //fragCoord = floor(fragCoord /16.); \n\n    // chess mask\n    float chess = mod(fragCoord.x+fragCoord.y,2.);\n    \n    if (chess < 0.5) {\n        // rotating this texture to make even harder\n        return singleTex(vec2(uv.y, -uv.x));\n    } else {    \n        return doubleTex(uv);\n    }\n}\n\n// switch 50/50 between 1 and 2 samples using for\nvec4 forTex(vec2 uv) {\n    // alternate between 1 and 2 repeats\n    int n =  uv.x < uv.y ? 1 : 2;\n    \n    // weight for interpolation\n    float weight = 1./float(n); \n\n    // repeat this n times\n    vec4 result;\n    for (int i=0; i<n ; i++) { \n        // sample texture\n        vec4 color = texture(iChannel0, uv);\n        \n        // interpolate the result\n        result += color * weight;\n        \n        // mutate the uvs\n        uv = uv.yx;\n    }    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // if you get around 144 fps use a higher repeat value\n    vec4 test;\n    for(int i=0; i<REPEAT; i++) {\n    \n        // unique permutation each iteration\n        float mut = (float(i)/float(REPEAT)); \n          \n        // use which ever you wish to test\n        #if TEST == 0\n            test += singleTex(uv + mut);\n        #elif TEST == 1\n            test += singleTexGrad(uv + mut);\n        #elif TEST == 2\n            test += doubleTex(uv + mut);\n        #elif TEST == 3\n            test += doubleTexGrad(uv + mut);\n        #elif TEST == 4\n            test += ifTex(uv + mut);\n        #elif TEST == 5\n            test += ifTexGrad(uv + mut);\n        #elif TEST == 6\n            test += ifChessTex(uv + mut, fragCoord);\n        #else\n            test += forTex(uv + mut);\n        #endif   \n    }\n\n    // Output to screen\n    fragColor = vec4(fract(test));\n}","name":"Image","description":"","type":"image"}]}