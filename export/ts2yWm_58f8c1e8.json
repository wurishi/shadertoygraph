{"ver":"0.1","info":{"id":"ts2yWm","date":"1586789944","viewed":753,"name":"Wackelkontakt (4k intro)","username":"slerpy","description":"This is a shadertoy port of [url=https://www.pouet.net/prod.php?which=85220]\"Wackelkontakt\"[/url], a 4k intro released at Revision 2020.\n\nNote: All comments on how to minify the shader further will be deleted.","likes":62,"published":1,"flags":96,"usePreview":0,"tags":["intro","4k","demoscene","revision","2020"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Mtj3Wh","filepath":"https://soundcloud.com/noby/solukudos-wackelkontakt","previewfilepath":"https://soundcloud.com/noby/solukudos-wackelkontakt","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// stage 2: \"post\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [debugging code]\n    \n    #if 0\n    //  ^ set this to 1 to skip the shader stage\n    fragColor=texelFetch(D,ivec2(fragCoord),0);\n    return;\n    #endif\n    \n    // [shadertoy fix-up]\n    \n    P=acos(-1.),T=2.*P;    // calculate pi and tau\n    c=.0*R,m=c;            // init c and m as vec4(0)\n    \n    // ^ Both of these steps are done outside\n    //   the main function in the actual intro.\n\n    // [common code across all stages]\n    \n    vec2 v=gl_FragCoord.xy;  // get short mutable pixel coord\n    r=vec4(v,R.yz);          // init random vector using pixel coord + time\n    S();S();S();S();         //   and hash it 8 times\n    S();S();S();S();         // *shuffle*, *shuffle*, *shuffle*\n\n    float tt=R.z*7./48.,     // current chord playing in the soundtrack\n    w=floor(tt)*step(2.,tt), // camera movement offset\n    z=1.-.3*smoothstep(-.7,.0,-abs(tt-2.1))   // zoom around 00:14\n        +.2*smoothstep(-1.,0.,-abs(tt-20.));  // zoom around 02:17\n    if(tt<8.)z-=pow(tt/8.,48.);               // camera plunge at 00:54\n    \n    // ^ None of these camera specific vars are needed\n    //   in this stage and they are only here for completeness.\n\n    // [stage specific code]\n\n    // get uv\n    v/=R.xy;\n    \n    // calculate bloom\n    for(float a=.0;a<T;a+=.63)\n        c+=max(textureLod(D,v+7.8*pl(a)/R.xy/*+.011*R.xy/R.x*/,5.5)-.06,0.);\n    \n    // ^ The bloom is a simple mipmap blur with circular sampling to make it less blocky.\n    //   The code commented out above is needed in the intro to offset the texel centers\n\t//   from 'lower left corner' (default in OpenGL) to 'center' (used in Shadertoy).\n    //   The constant used for the offset is calculated like this:\n    //   offset = texel_size/2 = pow(2,-mipmap)/2 = 1/(2^6.5) = ~0.0110485\n    \n    // final color\n    c=pow(texture(D,v)+.02*c,vec4(.45))+.01*(r.x-.5);\n\t//      ^color      ^bloom  ^gamma    ^film noise\n    \n    // [common code across all stages]\n    \n    fragColor=c;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// shader uniforms\n#define R vec4(iResolution.xy, mod(iTime, 150.), 0)\n#define D iChannel0\n\n// ^ R.w is the shader stage in the actual intro,\n//   so intead of having 3 different shaders (one for each stage),\n//   we only have a single shader which we run in a loop.\n//   This approach makes the framework a bit more compact\n//   and allowes for a lot of minification in the shader.\n\n// global variables\nfloat P,T;   // pi, tau\nvec4 r,c,m;  // random vector, color, mask\n\n// ^ These variables are defined at declaration in the actual intro.\n//   Since this is not allowed on Shadertoy, they are left undefined\n//   here and assigned a value in the \"shadertoy fix-up\" section in\n//   the main function of every stage.\n\n// shuffle function\nvoid S()\n{\n    // hash global \"random vector\" variable\n    r=fract(1e4*sin(r)+r.wxyz);\n    \n    // Instead of making a function that returns random numbers,\n    // this intro has a global variable `r` which holds random\n    // numbers. Whenever those numbers were used, we call this\n    // shuffle function afterwards to replace the values of `r`.\n    \n    // The hashing function itself is not very good, but it's\n    // short and random enough for the small number of samples\n    // used in the path tracer.\n    \n    // If you do decide to use it, make sure to initialize `r`\n    // with a non-zero vector and shuffle at least 5 times before\n    // the first use.\n}\n\n// polar function\nvec2 pl(float a)\n{\n    // angle -> point on unit circle\n    return vec2(cos(a),sin(a));\n}\n\n// rotation functions\nmat3 rx(float a){return mat3(1,0,0,0,cos(a),sin(a),0,-sin(a),cos(a));}\nmat3 ry(float a){return mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));}\n\n// 2D hash function\nvec2 H(vec2 p)\n{\n    vec3 r=vec3(p,1);\n    \n    for(int i=0;i<4;i++)\n        r=fract(1e4*sin(r)+r.yzx);\n       \n    // ^ Same hashing function used in the shuffle function (S)\n    //   with the same variable name to aid compression.\n    \n    // Fun fact: The Nvidia GTX and RTX cards implement the sin\n    // function slightly differently and this noise function does\n    // a great job amplifying those tiny differences, so a lot of\n    // effects in this intro can look quite different depending\n    // on what graphics card you're using.\n    \n    // We only found out because we noticed the noise patterns\n    // looked different on the compo machine compared to what we\n    // intended it to look like. If you want to see the intro\n    // exactly as we designed it, check out noby's capture linked\n    // as \"youtube\" or \"video\" on the pouet page.\n    \n    return r.xy;\n}\n\n// 2D continuous noise function\nvec2 N(vec2 p)\n{\n    vec2 i=floor(p),f=p-i,o=vec2(0,1);\n    \n    return mix(mix(H(i),\n                   H(i+o),f.y),\n               mix(H(i+o.yx),\n                   H(i+o.y),f.y),f.x);\n}\n\n// 2D continuous perlin noise function\nvec2 pr(vec2 u)\n{\n    vec2 y=.0*u,n=y+2.;\n    \n    for(int i=0;i<8;i++)\n        y+=N(u*n)/n,n*=2.;\n    \n    return y;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// stage 0: \"screen\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [shadertoy fix-up]\n    \n    P=acos(-1.),T=2.*P;    // calculate pi and tau\n    c=.0*R,m=c;            // init c and m as vec4(0)\n    \n    // ^ Both of these steps are done outside\n    //   the main function in the actual intro.\n\n    // [common code across all stages]\n    \n    vec2 v=gl_FragCoord.xy;  // get short mutable pixel coord\n    r=vec4(v,R.yz);          // init random vector using pixel coord + time\n    S();S();S();S();         //   and hash it 8 times\n    S();S();S();S();         // *shuffle*, *shuffle*, *shuffle*\n\n    float tt=R.z*7./48.,     // current chord playing in the soundtrack\n    w=floor(tt)*step(2.,tt), // camera movement offset\n    z=1.-.3*smoothstep(-.7,.0,-abs(tt-2.1))   // zoom around 00:14\n        +.2*smoothstep(-1.,0.,-abs(tt-20.));  // zoom around 02:17\n    if(tt<8.)z-=pow(tt/8.,48.);               // camera plunge at 00:54\n\n    // ^ The camera specific vars are misused\n    //   as temporary vars in this stage.\n    \n    // [stage specific code]\n    \n    ivec2 j=ivec2(v);                  // set up mask, so every pixel in the fake\n    m[j.x%3]=exp(float(1-j.y%3));      //   screen is only either red, green or blue\n    vec2 u=vec2(j/3),y=3.*u/R.xy,t,h;  // some useful uv conversions for later effects\n    m.xy*=vec2(.8,.9);                 // blue shift\n    \n    // scene 0: \"crosses\"\n    if(tt<2.)\n    {\n        t=abs(mod(v,180.+R.z)-90.);  // triangle function / repeating box distance function\n        t=max(t/4.,t-t.yx);          // cross distance / intersection between boxes and a diagonal grid\n        \n        h=10.+8.*step(1.,tt)+vec2(0,.5);  // set size of the crosses (low edge, high edge)\n        \n        c+=smoothstep(-.5,.5,-cos(dot(2.*v-R.xy,vec2(4))/6e3-T*tt))  // wave effect\n            *(1.-smoothstep(h.x,h.y,max(t.x,t.y)));                  // crosses with minor smoothstep AA\n        \n        // ^ The AA is just make the crosses less snappy as they\n        //   slowly drift towards the top right corner of the screen.\n    }\n\n\t// scene 1: \"perlin noise\"\n    else if(tt<4.)\n    {\n        t=pr(u/24.+T);  // calculate perlin noise\n        \n        c+=mix(\n            step(fract(.4*R.z+2.*t.x),.2),    // foreground pattern\n            dot(normalize(t-.5),pl(20.*tt)),  // background pattern\n            .2*(.5-.5*cos(T*tt))              // pulsating effect\n            *smoothstep(2.,4.,tt)             // intensify over time\n        );\n    }\n\n\t// scene 2: \"burning horse\"\n    else if(tt<8.)\n    {\n        t=(2.*v-R.xy)/R.y,h=t; // set uv (in t and h)\n        \n        for(int i=0;i<2;++i)                 // two step shifting perlin noise\n            t+=(.3+.5*smoothstep(5.,7.,tt))  //   distortion effect, which\n            \t*(pr(3.*t+7.+(tt-6.))-.5);   //   intensifies over time\n        \n        c+=max(\n            step(fract(4.*length(t)-R.z),.1),  // distorted rings\n            .04*dot(normalize(h-t),t)          // distortion visualizer\n        );\n        \n        // ^ Notice the background shading indicates how quickly\n        //   the rings move at any point on the plane.\n    }\n\n\t// scene 3: \"blocky\"\n    else if(tt<12.)\n    {\n        t=v/R.xy;  // set uv\n        w=R.z;     // set time\n        \n        for(int i=int(max(.0,tt-11.9)*100.);i<12;i++)\n        \t//   ^ the transition out of the scene happends here \n        {\n            // divide area into two sides, [0,z) and [z,1)\n            z=.5+.2*sin(w+7.*floor(tt));\n            \n            // decide what side we're in and remap\n            if(t.x<z)t.x/=z,w=.6+w*1.1;  // [0,z) -> [0,1) + update time\n            else t.x=(t.x-z)/(1.-z);     // [z,1) -> [0,1)\n            \n            w+=.5;   // update time\n            t=t.yx;  // swizzle uv, so we get splits in both axis\n        }\n        \n        c+=.5+.5*cos(.5*P*w); // turn w into a color\n    }\n\n\t// scene 4: \"distorted rain\"\n    else if(tt<16.)\n    {\n        t=N(floor(vec2(.5*v.x                                 // get random offset\n\t\t\t+R.y*pr(.8*(.5*v)/R.y+3.).x                       //   with perlin noise distortion,\n\t\t\t\t*smoothstep(.0,1.,smoothstep(12.7,15.2,tt))   //   which intensifies over time\n\t\t,0.)));\n        \n        // simple gradient + offset = pixel rain\n        c+=max(.02*t.y,4.*fract(t.x-.3*R.z-y.y)-3.);\n        \n        \n        // anti strobe filter\n        m=mix(vec4(.3),m,.15+.85*smoothstep(.0,.25,max(abs(tt-13.4)-.5,0.)));\n        \n        // ^ This line drops the saturation down to 15% to\n        //   remove violent 60 Hz flickering around 1:32.\n        //   Comment out this line at your own risk!\n    }\n\n    // scene 5: \"ending\"\n    else\n    {\n        w=1.7; // set initial brightness\n        \n        // set uv (with a lot of random screen space distortion and rotation)\n        h=pl(floor(min(tt+step(17.85,tt)+step(17.9,tt),19.)-4.)*P/3.);\n        y=(((2.+h.y)*v-R.xy)/R.y+.06*H(vec2(j/int(50.-50.*h.x*h.y)))+3.)*mat2(1,1,-1,1)/6.;\n        y*=mat2(h.x,h.y,-h.y,h.x);\n        \n        // ^ The screen distortion is just there to give the viewer something to\n        //   focus on. Without it, all you get is 2 layers of random camera movement\n        //   (both on and in front of the screen), which is quite disorienting to look at.\n        \n        // simple parallex effect\n        for(int i=0;i<14;i++)\n        {\n            // update brightness\n            w*=.6*(1.-smoothstep(18.,21.,tt));\n            \n            // draw patterns\n            t=abs(fract(y+=vec2(4,1)*R.z/200.)-.5);\n            c+=w*step(min(t.x,t.y),.01);\n            \n            // update scale\n            y*=1.5;\n        }\n    }\n\n    c=max(c*m,0.); // apply mask and clip at 0\n\n    // [common code across all stages]\n    \n    fragColor=c;\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// stage 1: \"tracer\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [debugging code]\n    \n    //#define CUSTOM_SAMPLE_COUNT 10\n    \n    #if 0\n    //  ^ set this to 1 to skip the shader stage\n    fragColor=2.*texelFetch(D,ivec2(fragCoord),0);\n    return;\n    #endif\n    \n    // [shadertoy fix-up]\n    \n    P=acos(-1.),T=2.*P;    // calculate pi and tau\n    c=.0*R,m=c;            // init c and m as vec4(0)\n    \n    // ^ Both of these steps are done outside\n    //   the main function in the actual intro.\n\n    // [common code across all stages]\n    \n    vec2 v=gl_FragCoord.xy;  // get short mutable pixel coord\n    r=vec4(v,R.yz);          // init random vector using pixel coord + time\n    S();S();S();S();         //   and hash it 8 times\n    S();S();S();S();         // *shuffle*, *shuffle*, *shuffle*\n\n    float tt=R.z*7./48.,     // current chord playing in the soundtrack\n    w=floor(tt)*step(2.,tt), // camera movement offset\n    z=1.-.3*smoothstep(-.7,.0,-abs(tt-2.1))   // zoom around 00:14\n        +.2*smoothstep(-1.,0.,-abs(tt-20.));  // zoom around 02:17\n    if(tt<8.)z-=pow(tt/8.,48.);               // camera plunge at 00:54\n\n    // [stage specific code]\n\n    // sample loop\n    #ifdef CUSTOM_SAMPLE_COUNT\n    for(int i=0;i<CUSTOM_SAMPLE_COUNT;i++)\n    #else\n    for(int i=0;i<200;i++)\n    #endif\n    {\n        // update random vector to keep it random\n        S();\n        \n        // camera movement\n        float h=fract(clamp(tt,2.,20.)-1e-5),\n              s=1.2*pow(1.-h,5.5);\n        vec2  f=.07*sqrt(r.z)*pl(T*r.w),             // depth of field\n              u=(v+r.xy-.5-.5*R.xy)/R.y,             // pixel uv\n             rv=pl(.2*(R.z-.1*h+99.*min(0.,w-12.))); // rotation vector\n        \n        // camera setup\n        mat3 rm=rx(.3*rv.x)*ry(.6*rv.y);        // calculate rotation matrix\n        vec3 o=rm*vec3(z*.5*f,-s-1.),           // get camera origin\n             d=rm*normalize(vec3(z*u-f,s+2.));  // get camera direction\n        \n        // get color from screen\n        c+=texelFetch(D,ivec2(R.y*(o.xy-d.xy*o.z/d.z)+.5*R.xy),0) // intersect ray with screen and fetch texture\n           \t+.01*pow(.5+.5*d.y,3.);                               // add super simple skybox\n        \n        // ^ Because we can be sure that it's always going to hit the same geometry,\n        //   we can directly calculate the texture coordinate from camera direction and orientation.\n        //   This shortcut is not only great for size, but also performance.\n    }\n    \n    // brightness correction\n    #ifdef CUSTOM_SAMPLE_COUNT\n    c*=1.6/float(CUSTOM_SAMPLE_COUNT);\n    #else\n    c/=125.;\n    #endif\n\n    // [common code across all stages]\n    \n    fragColor=c;\n}","name":"Buffer B","description":"","type":"buffer"}]}