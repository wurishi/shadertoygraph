{"ver":"0.1","info":{"id":"NtXXRB","date":"1625909438","viewed":278,"name":"alternative packing","username":"Carandiru","description":"simple dart throwing algorithm\nsimplified. modified to seek into future frames, distributed with bluenoise \"influence\".\nfork of shane's shader \"Packet Object Pattern\" (link above)\ndart throwing algorithm by oneshade","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["circle","circle","bubble","vector","polygon","packed","dart","throwing"],"hasliked":0,"parentid":"stlSW4","parentname":"Packed Object Pattern"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// alternative packing - simplification of shane's shader \"Packet Object Pattern\".\n//                       simple dart throwing algorithm by oneshade\n// [options in common]\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 svUV = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 uv = rot2(-3.14159/3.5)*svUV - iTime/32.;\n    \n    vec4 buf = texture(iChannel0, fract(uv));\n\n    vec3 col = vec3(buf.r);\n        \n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// alternative packing - simplification of shane's shader \"Packet Object Pattern\".\n//                       simplified dart throwing algorithm by oneshade\n\n// The dart throwing algorithm.\n\n\n//\nvec2 hashblue22(vec2 p){  \n    return textureLod(iChannel1, (p * iResolution.xy)/1024.0, 0.0f).rg; \n}\nfloat hashblue21(vec2 p){  \n    return textureLod(iChannel1, (p * iResolution.xy)/1024.0, 0.0f).r; \n}\n\n// choose your sdf wisely, this one is slow but allows testing different shapes easily.\nfloat Polygon(vec2 p, float vertices, float radius){\n\n    float segmentAngle = 6.2831853/vertices;\n    \n    float angleRadians = atan(p.x, p.y);\n    float repeat = mod(angleRadians, segmentAngle) - segmentAngle/2.;\n    float inradius = radius*cos(segmentAngle/2.);\n    float circle = length(p);\n    float x = sin(repeat)*circle;\n    float y = cos(repeat)*circle - inradius;\n\n    float inside = min(y, 0.);\n    float corner = radius*sin(segmentAngle/2.);\n    float outside = length(vec2(max(abs(x) - corner, 0.0), y))*step(0.0, y);\n    return inside + outside;\n}\n\n \n// Object distance field and central position based ID.\nvec4 object(in vec2 p, in float r, in vec2 id){\n\n    p = rot2(hashblue21(id)*6.2831*4.)*p; \n    float d = Polygon(p, DART_SIDES, r);\n    return vec4(d, id, r);\n}\n\nvec2 newSeed(int offset) \n{\n    return vec2(1.618, 1)*mod(float(iFrame + offset)*0.0127 + iDate.w, 256.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \n    vec2 uv = (fragCoord)/iResolution.xy;\n    \n    vec2 seed = newSeed(0);\n    \n    // Set all data slots to one.\n    vec4 col = vec4(1);\n     \n    // After loading or hitting the mouse button, reset.\n    if(textureSize(iChannel0, 0).x<2 || iMouse.z>1.){\n          \n          fragColor = col;\n          return;\n    }\n    \n    // After the first frame, start filling the buffer.\n    if (iFrame>0) { \n    \n        // Closest object distance, ID and width at this pixel postion.\n        col = texture(iChannel0, uv);\n        \n        // object size.\n        float rad = DART_SIZE;\n\n        for(int i=0; i<SEED_SEARCH_FRAMES; ++i){ // frames ahead...\n        \n            // Random canvas postion.\n            vec2 rndPos = hashblue22(seed + vec2(.141, .083));\n\n            // Object distance at the random start postion.\n            vec4 dataRndPos = texture(iChannel0, fract(rndPos + .5));\n\n            for(int j=0; j<2; ++j){            \n\n                // If there's enough room to place the new object, do so. \n                if(dataRndPos.x>rad){ \n\n                    // Create the object at the new position.\n                    vec4 tmp = object(fract(uv - rndPos) - .5, rad, rndPos);\n                    // Compare it to the old closest object, then update if necessary.\n                    if (tmp.x < col.x) {\n                        col = tmp;\n                    }\n                    else {\n                        col.x *= 1.0 + DART_REPLACEMENT_FACTOR;\n                    }\n                }\n                // If there's not enough room, reduce the object size and try again.\n                rad *= .5;\n            }\n\n            // If we've made it this far, we didn't get a hit, so update the\n            // seed and try at the next position \n            // (techincally the position of a new dart created next frame - the future)\n            seed = newSeed(i + 1);\n        }\n    }\n    \n    fragColor = col;\n \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DART_SIZE 0.00001               // + size of dart - set really low here to stress test algorithm packing\n#define DART_SIDES 4.0                  // + shape of dart\n#define DART_REPLACEMENT_FACTOR 0.000001 // + percentage of darts replaced\n\n#define SEED_SEARCH_FRAMES 32  // will crash shader if set too high\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }","name":"Common","description":"","type":"common"}]}