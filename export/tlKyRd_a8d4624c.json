{"ver":"0.1","info":{"id":"tlKyRd","date":"1611617951","viewed":67,"name":"Box Of Chocolates, Permutations","username":"mherreshoff","description":"Animated box of chocolates, each generated by a different permutation of transformations, inspired by the Genuary 25th prompt.\nhttps://genuary2021.github.io/prompts#jan25","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["animated","chocolate","symmetry","genuary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (2.0*3.14159)\n#define SYMMETRY_N 4\nint permutation_order(int perm, int a) {\n  for (int i = SYMMETRY_N; i >= 1; i--) {\n    int digit = perm%i; perm /= i;\n    if (a == digit) {\n      return i-1;\n    } else if (a > digit) {\n      a--;\n    }\n  }\n  return 0;\n}\nvec2 apply(vec2 uv, int transform) {\n    if (transform == 0) {\n        // 3 Fold Symmetry\n        float r = length(uv);\n        float theta = mod(atan(uv.y , uv.x)/TAU, 1.0);\n        theta = mod(3.0*theta + iTime*.03, 1.0);\n        uv.x = r*cos(theta*TAU);\n        uv.y = r*sin(theta*TAU);\n    } else if (transform == 1) {\n        // Wave\n        uv.y += .1 * sin(uv.x*7.0 - .5*iTime);\n    } else if (transform == 2) {\n        // Ripple\n        float r = length(uv);\n        float theta = mod(atan(uv.y , uv.x)/TAU, 1.0);\n        r *= 3.;\n        r = floor(r) + smoothstep(0., 1., mod(r, 1.0));\n        r /= 3.;\n        uv.x = r*cos(theta*TAU);\n        uv.y = r*sin(theta*TAU);\n    } else if (transform == 3) {\n        // Swirl\n        float r = length(uv);\n        float theta = mod(atan(uv.y , uv.x)/TAU, 1.0);\n        theta += r*.2;\n        uv.x = r*cos(theta*TAU);\n        uv.y = r*sin(theta*TAU);\n    }\n    return uv;\n}\nfloat smooth_hill(float a, float b, float c, float d, float x) {\n    return smoothstep(a,b,x) - smoothstep(c,d,x);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    float scale = min(iResolution.y/4.0, iResolution.x/6.0);\n    float xOffset = (iResolution.x - scale*6.0)/2.;\n    float yOffset = (iResolution.y - scale*4.0)/2.;\n    vec2 coord = (U - vec2(xOffset, yOffset))/scale;\n    vec2 uv = mod(coord, 1.0);\n    vec2 cell = floor(coord);\n    if (cell.x < 0. || cell.x >= 6. || cell.y < 0. || cell.y >= 4.){\n        O = vec4(0); return;\n    }\n    int perm = int(cell.y + cell.x*6.0);\n    uv = uv - .5;\n    vec2 original = uv;\n    vec2 spot = vec2(0, .3);\n\n    float hStripe = 0.0, vStripe = 0.0;\n    for (int i = 0; i < SYMMETRY_N; i++) {\n        int transform = permutation_order(perm, i);\n        uv = apply(uv, transform);\n        //spot = apply(spot, transform);\n        if (transform == 2) {\n            hStripe = smooth_hill(0.0, 0.1,0.2,0.3, mod(uv.y*5.0+iTime*.05, 1.0));\n        } else if (transform == 3) {\n            vStripe = smooth_hill(0.0, 0.1,0.2,0.3, mod(uv.x*5.0+iTime*.05, 1.0));\n        }\n    }\n    \n    float interior = 1.-smoothstep(.3, .4, length(uv));\n    vec4 color = mix(vec4(0,0,0,1), 1.3*vec4(.54, .27,.08, 1.), interior);\n    color = mix(color, vec4(.9,.0,0,1), interior*vStripe);\n    color = mix(color, vec4(.9,.9,.8,1), interior*hStripe);\n    \n    O = mix(vec4(1,1,0,1), color, smoothstep(0., .1, distance(uv, spot)));\n}","name":"Image","description":"","type":"image"}]}