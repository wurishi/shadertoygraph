{"ver":"0.1","info":{"id":"wlXBW8","date":"1596557295","viewed":67,"name":"Interactive Raymarching Template","username":"Giraugh","description":"Testing some different lighting effects.\n\n- Phong Specular Highlights\n- Ambient Occlusion\n- Glow","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Simplest Possible Raymarcher */\n/* By Giraugh */\n\n#define MAX_STEPS 100\n#define MAX_DIST 1000.\n#define SURF_DIST 0.01\n\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n    \tc, -s, s, c\n    );\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    float ss = min(20., iTime)/5.;\n    p *= scale * ss;\n\tfloat g = abs(bias + dot(sin(p), cos(p.zxy))) / (scale * ss);\n    return (g - thickness) / 1.3;\n}\n\nfloat sdBox(vec3 p, vec3 o, vec3 r) {\n \treturn length(max(abs(p - o) - r, 0.));   \n}\n\nfloat sdSphere(vec3 p, vec3 o, float r) {\n    return length(p - o) - r;\n}\n\n// Return the distance to the nearest point in the scene\n// from (point)\nfloat GetDist(vec3 point) {\n    float m = length(point);\n    point.xz *= Rot(iTime / 10.);\n    point.yz *= Rot(iTime / 10.);\n    point.x = mod(point.x, 3.) - 1.5;\n    point.z = mod(point.z, 3.) - 1.5;\n    point.y = mod(point.y, 3.) - 1.5;\n    point.xz *= Rot(iTime);\n    point.yz *= Rot(iTime);\n    float bd = sdBox(point, vec3(0), vec3(.02 + .6/exp(m))) - .02;\n    float sd = sdSphere(point, vec3(0), .7);\n    float d = mix(bd, sd, (sin(iTime)+1.)/2.); //(bd + sd) / 2.;\n    return d;\n}\n\n// March a ray forwards into the scene determined by (GetDist)\n// Returns the distance the ray travelled before getting\n// below (SURF_DIST) distance from a surface or too far away\nint ray_march_iters;\nfloat smallest_dist;\nbool did_hit;\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    ray_march_iters = 0;\n    smallest_dist = MAX_DIST;\n    did_hit = false;\n    float d = 0.;\n    for (ray_march_iters = 0; ray_march_iters < MAX_STEPS; ray_march_iters++) {\n        vec3 p = rayOrigin + rayDirection * d;\n        float d_delta = GetDist(p);\n        d += d_delta;\n        if (abs(d_delta) < smallest_dist) smallest_dist = abs(d_delta);\n        if (abs(d_delta) < SURF_DIST) did_hit=true;\n        if (d > MAX_DIST || abs(d_delta) < SURF_DIST) break;\n    }\n    return d;\n}\n\n// Calculate the surface normal at (point)\n// can reduce (off) to improve accuracy\nvec3 GetNormal(vec3 point) {\n    float d = GetDist(point);\n    float off = .01;\n    vec3 n = vec3(\n    \td - GetDist(point - vec3(off,0,0)),\n        d - GetDist(point - vec3(0,off,0)),\n        d - GetDist(point - vec3(0,0,off))\n    );\n    return normalize(n);\n}\n\n// Determine degree of lighting (0 to 1) at (pos) by (lightPos)\nfloat GetLighting(vec3 point, vec3 lightPos) {\n    vec3 l = normalize(lightPos - point);\n    vec3 n = GetNormal(point);\n    float diff = clamp(dot(l, n), 0., 1.);\n    return diff;\n}\n\nfloat GetLightingPhong(vec3 point, vec3 view, vec3 lightPos, float shininess) {\n\tvec3 l = normalize(lightPos - point);\n    vec3 n = GetNormal(point);\n    vec3 r = 2. * n * dot(n, l) - l;\n    \n    if (dot(n, l) < 0.0) {\n        return 0.;\n    } else {\n    \treturn .3 * pow(max(0., dot(r, normalize(-view))), shininess);\n    }\n}\n\nvec3 MouseCameraOrigin(vec3 rayOrigin) {\n\tfloat rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayOrigin.yz *= Rot(rotY);\n    rayOrigin.xz *= Rot(rotX);\n\treturn rayOrigin;\n}\n\nvec3 MouseCameraDirection(vec3 rayDirection) {\n \tfloat rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayDirection.yz *= Rot(rotY);\n    rayDirection.xz *= Rot(rotX);\n    rayDirection = normalize(rayDirection);\n\treturn rayDirection;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (square) (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    // Declare camera position in terms of ray origin and direction\n    vec3 rayOrigin = MouseCameraOrigin(vec3(0, 0, -3));\n    vec3 rayDirection = MouseCameraDirection(vec3(uv.x, uv.y, 1));\n    \n    // RayMarch to find point\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + dist * rayDirection;\n    \n    // Determine lighting\n    vec3 lightPos = vec3(0, 4, -7);\n    float lighting = GetLighting(hitPoint, lightPos);\n    float highlight = GetLightingPhong(hitPoint, rayDirection, lightPos, 30.);\n\tvec3 col = vec3(lighting + highlight);\n    \n    // Hacky AA\n    col -= 5. * vec3(pow(smoothstep(0., float(MAX_STEPS), float(ray_march_iters)), 1.2));\n    col.r += .4 * sin(hitPoint.y);\n    col.g += .2 * cos(hitPoint.y);\n    \n    if (!did_hit) col = vec3(.2);\n    \n    // Glow\n    //if (!did_hit)\n    //col += .03 * vec3(50, 50, 63) * smoothstep(100. * SURF_DIST, SURF_DIST, pow(smallest_dist, 0.15));\n    \n    // Ouput colour at full transparency\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}