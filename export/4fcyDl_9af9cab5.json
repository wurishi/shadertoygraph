{"ver":"0.1","info":{"id":"4fcyDl","date":"1731485509","viewed":93,"name":"Fork mandelhub simplexqwe 769","username":"simplexqwe","description":"mandelhub","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["mandelhub"],"hasliked":0,"parentid":"DdtfD8","parentname":"mandelhub"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 75\n#define MAX_DIST 5.\n#define SURF_DIST .0025\n#define Power 4.\n#define speed 4.\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n    }\n\nfloat DE(vec3 pos,float time) {\n\tvec3 z = (pos);\n\tfloat dr = 1.;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 8 ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.)*Power*dr + 1.;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\tz = (zr*vec3(sin(theta+time)*cos(phi+time), sin(phi+time)*sin(theta+time), cos(theta+time)));\n\t\tz+=pos;\n\t}\n    \n    \t\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat GetDist(vec3 p){\n    return DE(p,0.);\n}\n\n\nvec2 SmoothRayMarch(vec3 ro,vec3 rd,float mdist){\n  float dO=0.;\n  float mindist=1.;\n    \n  for(int i=0;i<MAX_STEPS;i++){\n    vec3 p = ro+rd*dO;\n    float ds=GetDist(p);\n    dO+=ds;\n    mindist=min(mindist,ds);\n    if(dO>mdist || abs(ds)<SURF_DIST) {\n      break;\n    }\n  }  \n  return vec2(mindist,dO);\n}\n\n\n\nvec3 GetNormal (vec3 p){\n    float d = GetDist(p);\n    vec2  e = vec2(.01,0.);\n    \n    vec3  n =d-vec3(\n    GetDist(p-e.xyy),\n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight (vec3 p){\n\n    return GetDist(p+GetNormal(p));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 colo = vec3(0);\n    \n    vec3 ro  = vec3(0,0.01,-3);\n    vec3 rd  = normalize(vec3(uv.x,uv.y,1));\n    rd.yz*=Rot(iTime/25.*speed);\n    ro.yz=(ro.yz)*Rot(iTime/25.*speed);\n    \n    rd.xz*=Rot(iTime/10.*speed);\n    ro.xz=(ro.xz)*Rot(iTime/10.*speed);\n\n\n\n\n//    float  d =       RayMarch(ro,rd);\n    vec2   d = SmoothRayMarch(ro,rd,MAX_DIST);\n    vec3  p  = ro+rd* d.y;\n    \n    float  dif =GetLight( p);\n    colo = clamp(vec3(col(d.x*20.)),0.,1.);\n    colo += mod(clamp((dif),0.,1.),1.);\n        \n    fragColor = vec4(colo,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 Geoffrey(float t)\n{\n    vec3 r = t * 2.1 - vec3(1.8, 1.14, 0.3);\n    return 0.99 - r * r;\n}\n\nvec4 col(float uv){\n    vec3 col1 = Geoffrey(uv * 2.0 - 0.5);\n    vec4 col = vec4(0.0);\n    col = vec4(col1,0.);\n    return col;\n\n}\n","name":"Common","description":"","type":"common"}]}