{"ver":"0.1","info":{"id":"Wts3zH","date":"1555661236","viewed":257,"name":"Proper dithering","username":"orlp","description":"Proper dithering with triangular noise.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["dither"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original idea by Mikkel Gjoel (https://computergraphics.stackexchange.com/a/5952/10515),\n// simplified to one readable function.\n\n// Dithers and quantizes color value c in [0, 1] to the given color depth.\n// It's expected that rng contains a uniform random variable on [0, 1].\nuint dither_quantize(float c, uint depth, float rng) {\n    float cmax = float(depth) - 1.0;\n    float ci = c * cmax;\n\n    float d;\n    if (ci < 0.5 || ci >= cmax - 0.5) {\n        // Uniform distribution on [-0.5, 0.5] for edges.\n        d = rng - 0.5;\n    } else {\n        // Symmetric triangular distribution on [-1, 1].\n        d = (rng < 0.5) ? sqrt(2.0 * rng) - 1.0 : 1.0 - sqrt(2.0 - 2.0*rng);\n    }\n\n    return uint(clamp(ci + d + 0.5, 0.0, cmax));\n}\n\nuint dither_quantize_bad(float c, uint depth, float rng) {\n    float cmax = float(depth) - 1.0;\n    float ci = c * cmax;\n    return uint(clamp(ci + rng, 0.0, cmax));\n}\n\n\n\n#define LINE_THICKNESS 0.002\n#define DEPTH 4.\n#define REPS 500.\n\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat line(float d) {\n    return smoothstep(0., d, LINE_THICKNESS);\n}\n\n\nfloat i2f(uint i) {\n    return float(i) / (DEPTH - 1.0);\n}\n\nvec3 graphic(vec2 uv) {\n    vec2 g = vec2(uv.x * 1.5 - 0.25, (uv.y - 0.05) / 0.4);\n    \n    if (-LINE_THICKNESS < g.x && g.x < 0. ||\n        1.0 < g.x && g.x < 1.0 + LINE_THICKNESS) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    \n    uvec3 seed = uvec3(int(uv.x * 10000.), int(uv.y*10000.), iFrame);\n    float signal = clamp(g.x, 0.0, 1.0);\n    float dithered = i2f(dither_quantize(signal, uint(DEPTH), hash(seed).x));\n    float avg = 0.;\n    float variance = 0.;\n    for (float i = 0.; i < REPS; i += 1.) {\n        uvec3 r = seed + uint(i);\n        float d = i2f(dither_quantize(signal, uint(DEPTH), hash(r).x));\n        avg += d / REPS;\n        variance += (d - signal) * (d - signal) / REPS;\n    }\n    \n    if (uv.y > 4.5/6.) {\n        return vec3(signal);\n    }\n    \n    //if (uv.y > 4./6.) {\n    //    return vec3(avg);\n    //}\n    \n    if (uv.y > 3./6.) {\n        return vec3(dithered);\n        //float rand = texture(iChannel0, uv*iResolution.xy/1024.).y;\n        //return vec3(i2f(dither_quantize(signal, uint(DEPTH), rand)));\n    }\n    \n    vec3 c = vec3(0.);\n    \n    // Signal.\n    c += vec3(0.5) * line(abs(g.y - signal));\n    \n    // Average dithered signal.\n    c += vec3(1.0, 1.0, 0.0) * line(abs(g.y - avg));\n    \n    // Error of average.\n    float error = (avg - signal) * 5.;\n    c += vec3(1.0, 0.0, 0.0) * line(abs(g.y - 0.5 - error));\n    \n    // Variance.\n    c += vec3(0.0, 0.0, 1.0) * line(abs(g.y - variance * 15.));\n    \n    return c;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.);\n    fragColor = vec4(graphic(uv), 1.0);\n}","name":"Image","description":"","type":"image"}]}