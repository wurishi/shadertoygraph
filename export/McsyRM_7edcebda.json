{"ver":"0.1","info":{"id":"McsyRM","date":"1720960266","viewed":93,"name":"A Terrain generation","username":"Yuujin","description":"A realistic (?) generation of infinite terrain based on [https://www.shadertoy.com/view/NlSGDz] this shader","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["terrain","proceduralgeneration","biomes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, float frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\nvec3 rgb(int r, int g, int b)\n{\n    return vec3(r, g, b) / 255.0;\n}\n\nvec4 colorblend(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat IsNaN(float x) {\n    return (x < 0. || x > 0. || x == 0.) ? 0. : 1.;\n}\n\nfloat get_height(vec2 position, float fm, uint initial_seed)\n{\n    // Terrain detail + islands\n    uint seed = initial_seed; // can be set to something else if you want a different set of random values\n    float value = perlinNoise(position, fm * 4.0, 12, 0.25, 2.0, seed); // multiple octaves\n    value = (value + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n    value = pow(value, 15.0);\n    \n    // Terrain\n    uint seed1 = hash(seed, 0x0U); // can be set to something else if you want a different set of random values\n    float value1 = perlinNoise(position, fm * 1.2, 12, 0.5, 2.0, seed1); // multiple octaves\n    value1 = (value1 + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n    value1 = pow(value1, 2.8) * 1.7;\n    \n    float height = (value + value1) / 2.0;\n    \n    // Big oceans\n    uint seed3 = hash(seed1, 0x0U); // can be set to something else if you want a different set of random values\n    float value3 = perlinNoise(position, fm * 0.1, 6, 0.5, 2.0, seed3); // multiple octaves\n    value3 = (value3 + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n    value3 = pow(value3, 2.0);\n    value3 = smoothstep(0.20, 0.30, value3);\n\n    height -= value3;\n    height = height < 0.0 ? 0.0 : height;\n    \n    // Rivers\n    uint seed2 = hash(seed3, 0x0U); // can be set to something else if you want a different set of random values\n    float value2 = perlinNoise(position, fm * 4.0, 12, 0.5, 2.0, seed2); // multiple octaves\n    value2 = (value2 + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n    value2 = pow(value2, 2.0);\n    float temp1 = smoothstep(0.25, 0.27, value2); // value2 > 0.26 ? 1.0 : 0.0;\n    float temp2 = smoothstep(0.29, 0.31, value2); //value2 > 0.30 ? 1.0 : 0.0;\n    value2 = temp1 - temp2;\n    \n    \n    if(value2 > 0.01 && height > 0.14 && height < 0.7)\n        height = 0.15 - value2 * 0.03;\n    \n    // Small rivers\n    uint seed4 = hash(seed2, 0x0U); // can be set to something else if you want a different set of random values\n    float value4 = perlinNoise(position, fm * 32.0, 12, 0.5, 2.0, seed4); // multiple octaves\n    value4 = (value4 + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n    value4 = pow(value4, 2.0);\n    float temp3 = value4 > 0.29 ? 1.0 : 0.0;\n    float temp4 = value4 > 0.32 ? 1.0 : 0.0;\n    value4 = temp3 - temp4;\n    \n    if(value4 == 1.0 && height > 0.14 && height < 0.7)\n        height = 0.13;\n        \n    return height;\n}\n\nfloat get_temperature(vec2 position, float fm, uint initial_seed)\n{\n    uint seed = initial_seed; // can be set to something else if you want a different set of random values\n    float temperature = perlinNoise(position, fm * 2.0, 12, 0.65, 2.0, seed); // multiple octaves\n    temperature = (temperature + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n    \n    if(IsNaN(temperature) == 1.)\n        temperature = 0.0; \n    \n    return temperature;\n}\n\nfloat get_humidity(vec2 position, float fm, uint initial_seed)\n{\n    uint seed = initial_seed; // can be set to something else if you want a different set of random values\n    float humidity = perlinNoise(position, fm * 0.5, 12, 0.65, 2.0, seed); // multiple octaves\n    humidity = (humidity + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n    \n    humidity = smoothstep(-0.05, 1.0, humidity);\n    \n    if(IsNaN(humidity) == 1.)\n        humidity = 0.0; \n    \n    return humidity;\n}\n\nbool in_range(float range1, float range2, float value)\n{\n    float start = min(range1, range2);\n    float end = start + abs(range1 - range2);\n    \n    return value >= start && value <= end;\n}\n\nint get_biome_index(float height, float temp, float humm)\n{\n        \n    // Ocean\n    if(height < 0.12)\n        return 11;\n    \n    // Beach;\n    if(in_range(0.12, 0.16, height))\n        return 10;\n        \n    vec2 selector = vec2(1.0 - temp, humm); \n    selector = length(selector) > 1.0 ? normalize(selector) : selector;\n    \n    // Desert - 0\n    if(in_range(0.0, 0.2, selector.x) && in_range(0.0, 0.2, selector.y))\n        return 0;\n    \n    // Savanna - 1\n    if(in_range(0.0, 0.2, selector.x) && in_range(0.2, 0.6, selector.y))\n        return 1;\n        \n    // Plains - 2\n    if(in_range(0.2, 0.5, selector.x) && in_range(0.0, 0.2, selector.y))\n        return 2;\n        \n    // Forest - 3\n    if(in_range(0.2, 0.5, selector.x) && in_range(0.2, 0.6, selector.y))\n        return 3;\n        \n    // Rainforest - 4\n    if(in_range(0.0, 0.5, selector.x) && in_range(0.6, 1.0, selector.y))\n        return 4;\n        \n    // Taiga (Pineforest) - 5\n    if(in_range(0.5, 0.7, selector.x) && in_range(0.0, 0.4, selector.y))\n        return 5;\n        \n    // Ice desert - 6\n    if(in_range(0.7, 1.0, selector.x) && in_range(0.0, 0.2, selector.y))\n        return 6;\n        \n    // Tundra - 7\n    if(in_range(0.7, 1.0, selector.x) && in_range(0.2, 0.4, selector.y))\n        return 7;\n        \n    // Dense taiga (Dense pineforest) - 8\n    if(in_range(0.5, 1.0, selector.x) && in_range(0.4, 1.0, selector.y))\n        return 8;\n        \n    return 2;\n}\n\nvec3 get_color_desert(float height) \n{ \n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 sand = rgb(254, 240, 138);\n    vec3 sandstone = rgb(68, 64, 60);\n    vec3 sandstonepeak = rgb(202, 138, 4);\n    \n    if(height > 0.75)\n        value *= sandstonepeak;\n    else if(height > 0.65)\n        value *= sandstone;\n    else if(height > 0.16)\n        value *= sand;\n    else if(height > 0.14)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\nvec3 get_color_savanna(float height) \n{ \n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 sand = rgb(254, 240, 138);\n    vec3 sandgrass = rgb(77, 124, 15);\n    vec3 stone = rgb(68, 64, 60);\n    vec3 snow = rgb(245, 245, 245);\n    \n    if(height > 0.8)\n        value *= snow;\n    else if(height > 0.65)\n        value *= stone;\n    else if(height > 0.35)\n        value *= sandgrass;\n    else if(height > 0.20)\n        value *= sand;\n    else if(height > 0.14)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\n\nvec3 get_color_plains(float height)\n{\n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 sand = rgb(254, 240, 138);\n    vec3 grass = rgb(21, 128, 61);\n    vec3 stone = rgb(68, 64, 60);\n    vec3 snow = rgb(245, 245, 245);\n    \n    if(height > 0.75)\n        value *= snow;\n    else if(height > 0.65)\n        value *= stone;\n    else if(height > 0.16)\n        value *= grass;\n    else if(height > 0.14)\n        value *= sand;\n    else if(height > 0.12)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\n\nvec3 get_color_forest(float height)\n{\n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 sand = rgb(254, 240, 138);\n    vec3 trees = rgb(20, 83, 45);\n    vec3 stone = rgb(68, 64, 60);\n    vec3 snow = rgb(245, 245, 245);\n    \n    if(height > 0.75)\n        value *= snow;\n    else if(height > 0.65)\n        value *= stone;\n    else if(height > 0.16)\n        value *= trees;\n    else if(height > 0.14)\n        value *= sand;\n    else if(height > 0.12)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\n\nvec3 get_color_rainforest(float height)\n{\n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 sand = rgb(254, 240, 138);\n    vec3 trees = rgb(5, 46, 22);\n    vec3 stone = rgb(68, 64, 60);\n    vec3 snow = rgb(245, 245, 245);\n    \n    if(height > 0.75)\n        value *= snow;\n    else if(height > 0.70)\n        value *= stone;\n    else if(height > 0.16)\n        value *= trees;\n    else if(height > 0.14)\n        value *= sand;\n    else if(height > 0.12)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\n\nvec3 get_color_taiga(float height) \n{ \n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 sand = rgb(254, 240, 138);\n    vec3 grass = rgb(54, 83, 20);\n    vec3 trees = rgb(19, 78, 74);\n    vec3 stone = rgb(68, 64, 60);\n    vec3 snow = rgb(245, 245, 245);\n    \n    if(height > 0.75)\n        value *= snow;\n    else if(height > 0.70)\n        value *= stone;\n    else if(height > 0.30)\n        value *= trees;\n    else if(height > 0.16)\n        value *= grass;\n    else if(height > 0.14)\n        value *= sand;\n    else if(height > 0.12)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\n\nvec3 get_color_dense_taiga(float height) \n{ \n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 sand = rgb(254, 240, 138);\n    vec3 trees = rgb(4, 47, 46);\n    vec3 stone = rgb(68, 64, 60);\n    vec3 snow = rgb(245, 245, 245);\n    \n    if(height > 0.75)\n        value *= snow;\n    else if(height > 0.70)\n        value *= stone;\n    else if(height > 0.16)\n        value *= trees;\n    else if(height > 0.14)\n        value *= sand;\n    else if(height > 0.12)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\n\nvec3 get_color_ice_desert(float height) \n{ \n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 stone = rgb(68, 64, 60);\n    vec3 snow = rgb(245, 245, 245);\n    \n    if(height > 0.60)\n        value *= snow;\n    else if(height > 0.55)\n        value *= stone;\n    else if(height > 0.14)\n        value *= snow;\n    else if(height > 0.12)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\n\nvec3 get_color_tundra(float height) \n{ \n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 stone = rgb(68, 64, 60);\n    vec3 grass = rgb(15, 118, 110);\n    vec3 snow = rgb(245, 245, 245);\n    \n    if(height > 0.60)\n        value *= snow;\n    else if(height > 0.55)\n        value *= stone;\n    else if(height > 0.14)\n        value *= grass;\n    else if(height > 0.12)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\n\n\nvec3 get_color_beach(float height)\n{\n    vec3 value = vec3(1.0);\n    \n    vec3 darkWater = rgb(23, 37, 84);\n    vec3 water = rgb(37, 99, 235);\n    vec3 sand = rgb(254, 240, 138);\n    \n    if(height > 0.14)\n        value *= sand;\n    else if(height > 0.12)\n        value *= water;\n    else\n        value *= darkWater;\n        \n    return value;\n}\n\nvec3 get_color(float height, int biome_index)\n{\n    if(biome_index == 0) return get_color_desert(height);\n    if(biome_index == 1) return get_color_savanna(height);\n    if(biome_index == 2) return get_color_plains(height);\n    if(biome_index == 3) return get_color_forest(height);\n    if(biome_index == 4) return get_color_rainforest(height);\n    if(biome_index == 5) return get_color_taiga(height);\n    if(biome_index == 6) return get_color_ice_desert(height);\n    if(biome_index == 7) return get_color_tundra(height);\n    if(biome_index == 8) return get_color_dense_taiga(height);\n    \n    if(biome_index == 11) return rgb(23, 37, 84);\n    if(biome_index == 10) return get_color_beach(height);\n    \n    return get_color_plains(height);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = vec2(500) + (fragCoord / iResolution.xy) - vec2(0.5);\n    position.x *= iResolution.x / iResolution.y;\n    position += iTime * 1.0;\n    \n    float fm = 2.0; // Change this to zoom in and out\n    \n    uint seed = 0x52c5bcf8U;\n    float height = get_height(position, fm, hash(seed, 0U));\n    float temp = get_temperature(position, fm, hash(seed, 1U));\n    float humidity = get_humidity(position, fm, hash(seed, 2U));\n    \n    int biome = get_biome_index(height, temp, humidity);\n    \n    vec3 color = get_color(height, biome);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}