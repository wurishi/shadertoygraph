{"ver":"0.1","info":{"id":"7sjSDw","date":"1620398475","viewed":272,"name":"Growing Fern","username":"Bleuje","description":"3 seconds long perfect loop","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["2d","spiral","fern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n\n#define otherDesign false\n#define ratio 0.55\n#define r0 0.5\n#define duration 3.0\n#define AA true\n#define horizontalScroll false\n#define shake false\n\n#define PI 3.14159\n#define TAU (2.*PI)\n\nfloat time;\n\nvec2 spiralCoord(vec2 uv)\n{\n    float theta0 = atan(uv.y,uv.x);\n    // r = r0*pow(ratio,it+theta0/TAU);\n    // log_ratio(r/r0)-theta0/TAU = it\n    float it = log(length(uv)/r0)/log(ratio)-theta0/TAU;\n    float it_small = floor(it);\n    float it_big = it_small+1.;\n    float r_small = r0*pow(ratio,it_small+theta0/TAU);\n    float r_big = r0*pow(ratio,it_big+theta0/TAU);\n    float r = length(uv);\n    // (1-p)*r_small + p*r_big = r\n    // p*(r_big - r_small) = r - r_small\n    // p = (r - r_small)/(r_big - r_small)\n    float p = (r - r_small)/(r_big - r_small);\n    float theta = TAU*it_small + theta0;\n    return vec2(p,theta);\n}\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    if(horizontalScroll) time = iTime/duration;\n    else time = mod(iTime,duration)/duration;\n    \n    if(shake)\n    {\n        float shakeSpeed = 1.5;\n        uv += 0.01*vec2(simplex3d(vec3(shakeSpeed*cos(TAU*time),shakeSpeed*sin(TAU*time),0.)),simplex3d(vec3(shakeSpeed*cos(TAU*time),shakeSpeed*sin(TAU*time),100.456)));\n    }\n    uv.y -= 0.1;\n    \n    vec3 background = vec3(0.5,0.8,1.0)*(1.5+0.7*uv.y);\n    // sunset version :\n    //vec3 background = vec3(1.0,0.7,0.2)*(1.5+0.7*uv.y);\n    \n    vec3 col = background;\n    \n    float nbIterations = 7.0;\n    \n    for(float it=0.;it<nbIterations;it++)\n    {\n        float pw = 1.7;\n        float reduction = pow(pw,it);\n        \n        vec2 uv2 = uv+vec2((horizontalScroll?0.45/reduction*time:0.),0.);\n        vec2 pos = 2.75*uv2*reduction;\n        \n        float rl = (otherDesign?1.0:1.3*pow(1.3,it));\n        pos.x += (mod(it,2.0)>0.?rl/2.0:0.);\n        \n        pos.x += rl*simplex3d(vec3(1234.789,333.333*it,0.));\n        \n        float ind = floor((pos.x+rl/2.0)/rl);\n        pos.x = mod(pos.x+rl/2.0,rl)-rl/2.0;\n        \n        float sv = 0.055*sin(TAU*(time + hash12(vec2(ind,it+123.))));\n        \n        pos.y += (mod(it,2.0)>0.?0.9:0.) + sv - pow(pw,it)*1.1*simplex3d(vec3(100.*ind,333.333*it,230.));\n        if(mod(ind,2.0)>0.) pos.x = -pos.x;\n        \n        vec2 pt = spiralCoord(pos);\n\n        bool ok = true;\n        if(pt.y<0.)\n        {\n            float factor = 0.03;\n            float left = (r0*ratio+factor*pos.y);\n            float right = r0-factor*pos.y;\n            pt.x = 1.-(pos.x - left)/(right - left);\n            pt.y = PI*pos.y;\n            if(pt.y>0.|| pt.x<0.||pt.x>1.) ok = false;\n        }\n        if(ok){\n            float indx = floor(pt.x/0.25);\n            float indy = floor(3.*iTime+pt.y/TAU/0.035);\n            float type = mod(indx+indy,2.0);\n\n            float rad = 1.0;\n            float offset = -0.1*pt.y;\n            float scl = 15.0;\n\n            float val1 = simplex3d(vec3(125.*it+rad*cos(TAU*(time-offset)),65.987*ind+rad*sin(TAU*(time-offset)),scl*pt.x));\n            float val2 = simplex3d(vec3(125.*it+111.111+rad*cos(TAU*(time-offset)),163.987*ind+rad*sin(TAU*(time-offset)),scl*pt.x));\n            float val3 = simplex3d(vec3(125.*it+222.222+rad*cos(TAU*(time-offset)),265.987*ind+rad*sin(TAU*(time-offset)),scl*pt.x));\n            \n            float a = 4.0*pow(max(-0.5,(val1+val2+val3)*0.5),3.0);\n            col = vec3(0.38-a,0.73-0.1*hash12(vec2(ind,it))-a,0.1);\n\n\n            if(min(pt.x,1.-pt.x)<0.07+0.02*it) col = vec3(0.,0.2,0.);\n             \n            float fog = it/(nbIterations+1.0); \n            \n            col = clamp(mix(col,background,fog),0.,1.);\n\n            break;\n        }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// smart AA, from FabriceNeyret2\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if(AA)\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 3d simplex noise from https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}","name":"Common","description":"","type":"common"}]}