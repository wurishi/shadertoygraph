{"ver":"0.1","info":{"id":"XXV3WG","date":"1718158951","viewed":56,"name":"Satisfying grid pattern","username":"orange389","description":"The sequel to satisfying cube pattern","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getParcelDistance(in ivec2 index) {\n    return  30.0 + 5.0 * sin(iTime * ((float(index.x) - 12.5) + (float(index.y) - 12.5)));\n}\n\n\nvec3 getParcelColor(in ivec2 index) {\n    return vec3(0.5, 1.0, 0.5);\n}\n\nvec2 getParcelDimension() {\n    return vec2(4.0, 4.0);\n}\n\nvec2 getParcelCorner(in ivec2 index) {\n    vec2 parcelDimension = getParcelDimension();\n    return vec2(index) * parcelDimension;\n}\n\nivec2 getParcelIndex(in vec3 pos) {\n    vec2 parcelDimension = getParcelDimension();\n    ivec2 index = ivec2(floor(pos.xy / parcelDimension));\n    return index;\n}\n\nivec2 getParcelIndex(in vec3 pos, in vec3 dir) {\n    vec2 parcelDimension = getParcelDimension();\n    vec2 relPos = fract(pos.xy / parcelDimension);\n    ivec2 index = ivec2(pos.x / parcelDimension.x, pos.y / parcelDimension.y);\n    if (relPos.x <= 0.001 || relPos.x >= 0.999)\n        return index + (dir.x < 0.0 ? ivec2(-1, 0) : ivec2(0, 0));\n    if (relPos.y <= 0.001 || relPos.y >= 0.999)\n        return index + (dir.x < 0.0 ? ivec2(0, -1) : ivec2(0, 0));\n    return index;\n}\n\n\nvec3 getParcelColor(in vec3 pos) {\n    if (abs(pos.z - getParcelDistance(getParcelIndex(pos))) < 0.1) {\n        return getParcelColor(getParcelIndex(pos));\n    }\n    vec2 relPos = fract(pos.xy * getParcelDimension());\n    if (relPos.x < 0.00001 || relPos.x > 0.99999) {\n        return vec3(1.0, 1.0, 0.5);\n    }\n    if (relPos.y < 0.00001 || relPos.y > 0.99999) {\n        return vec3(1.0, 0.5, 1.0);\n    }\n    return vec3(1.0, 1.0, 1.0);\n}\n\nfloat xSDF(in vec3 pos, in ivec2 index, in float unit) {\n    if (unit > 0.0) {\n        return (getParcelCorner(index).x + getParcelDimension().x - pos.x) * unit;\n    }\n    else {\n        return (getParcelCorner(index).x - pos.x) * unit;\n    }\n}\n\nfloat ySDF(in vec3 pos, in ivec2 index, in float unit) {\n    if (unit > 0.0) {\n        return (getParcelCorner(index).y + getParcelDimension().y - pos.y) * unit;\n    }\n    else {\n        return (getParcelCorner(index).y - pos.y) * unit;\n    }\n}\n\nfloat zSDF(in vec3 pos, in ivec2 index, in float unit) {\n    if (unit > 0.0) {\n        return max((getParcelDistance(index) - pos.z) * unit, 0.0);\n    }\n    else {\n        return (getParcelDistance(index) - pos.z) < -0.0001 ? 0.0 : 1000000.0;\n    }\n}\n\nbool march(inout vec3 pos, inout ivec2 index, in vec3 dir, in vec3 unit) {\n    float x = xSDF(pos, index, unit.x);\n    float y = ySDF(pos, index, unit.y);\n    float z = zSDF(pos, index, unit.z);\n    float sdf = min(min(x, y),z);\n    pos += dir * sdf;\n    if (sdf == z) {\n        return true;\n    }\n    if (sdf == x) {\n        index.x += (dir.x > 0.0) ? 1 : -1;\n    }\n    else {\n        index.y += (dir.y > 0.0) ? 1 : -1;\n    }\n    return false;\n}\n\nbool rayMarching(inout vec3 pos, in vec3 dir) {\n    vec3 unit;\n    unit.x = (dir.x == 0.0) ? 100000000.0 : (1.0 / dir.x);\n    unit.y = (dir.y == 0.0) ? 100000000.0 : (1.0 / dir.y);\n    unit.z = (dir.z == 0.0) ? 100000000.0 : (1.0 / dir.z);\n    ivec2 index = getParcelIndex(pos, dir);\n    bool hit = false;\n    int i = 0;\n    while(!hit && i < 200) {\n        ++i;\n        hit = march(pos, index, dir, unit);\n    }\n    return hit;\n}\n\nvoid reflectDir(in vec3 pos, inout vec3 dir) {\n    if (abs(pos.z - getParcelDistance(getParcelIndex(pos))) < 0.1) {\n        dir.z = -dir.z;\n    }\n    vec2 relPos = fract(pos.xy / getParcelDimension());\n    if (relPos.x < 0.00001 || relPos.x > 0.99999) {\n        dir.x = -dir.x;\n    }\n    if (relPos.y < 0.00001 || relPos.y > 0.99999) {\n        dir.y = -dir.y;\n    }\n    \n}\nvec3 reflectiveRayMarching(inout vec3 pos, inout vec3 dir) {\n    bool marching = true;\n    int i = 0;\n    float factor = 1.0;\n    float mul = 0.5;\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    while(marching && i < 25) {\n        ++i;\n        marching = rayMarching(pos, dir);\n        reflectDir(pos, dir);\n        if (!marching) {\n            break;\n        }\n        factor *= mul;\n        finalColor += factor * getParcelColor(pos);\n    }\n    return finalColor + vec3(1.0, 1.0, 1.0) * factor * dot(vec3(0, 0, -1), dir);\n}\n\nvoid rotateCamera(inout vec2 uv) {\n    float t = iTime * 0.25;\n    uv = vec2(uv.x * cos(t) + uv.y * sin(t), uv.x * -sin(t) + uv.y * cos(t));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy * 2.0 - 1.0) * iResolution.xy / iResolution.xx;\n    rotateCamera(uv);\n    vec3 pos = vec3(uv.x + 50.0, uv.y + 50.0, 0.0);\n    vec3 dir = vec3(uv.x, uv.y, 1.0);\n    dir = dir / length(dir);\n    vec3 color = reflectiveRayMarching(pos, dir);\n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}