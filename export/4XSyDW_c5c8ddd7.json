{"ver":"0.1","info":{"id":"4XSyDW","date":"1727245713","viewed":16,"name":"3-Body Moon","username":"emmajune","description":"Canux, Zhihui, Emma","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3body"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#iChannel0 \"file://data/home.png\"\n//#iChannel1 \"file://data/end.png\"\n//#iChannel2 \"file://data/canon.mp3\"\n//#iChannel3 \"file://data/JudgmentDay.wav\"\n//#iChannel4 \"file://data/words.png\"\n\n// shared functions.\nvec3 drawMoon(vec3 ro, vec3 rd, vec3 position, float radius) {\n    vec3 oc = ro - position;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return vec3(0.0);\n    h = sqrt(h);\n    float t = -b - h;\n    vec3 p = ro + t * rd;\n    vec3 n = normalize(p - position);\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    float diff = max(dot(n, lightDir), 0.0);\n\n    // 计算反射向量\n    vec3 reflectDir = reflect(-lightDir, n);\n    // 计算观察向量\n    vec3 viewDir = normalize(-p);\n    // 计算镜面反射强度\n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), 32.0);\n\n    // 添加镜面反射\n    vec3 specular = vec3(0.01) * spec;\n\n    // 添加环境光\n    vec3 ambient = vec3(0.1);\n\n    // 计算最终颜色\n    vec3 color = vec3(0.8, 0.8, 0.8) * diff + specular + ambient;\n\n    return color;\n}\n\nvec2 avoidOverlap(vec2 pos1, vec2 pos2, float minDistance) {\n    vec2 direction = normalize(pos2 - pos1);\n    float distance = length(pos2 - pos1);\n    if (distance < minDistance) {\n        pos2 += direction * (minDistance - distance);\n    }\n    return pos2;\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// bad moon\nvec3 badMoon(vec2 uv) {\n    vec3 ro = vec3(0.0, 0.0, 2.0); // 观察者位置\n    vec3 rd = normalize(vec3(uv, -1.0)); // 光线方向\n\n    // 随机生成三个位置\n    float time = iTime;\n    float speed = 0.1;\n    vec2 pos1 = vec2(rand(vec2(1.0, 2.0)) * 1.6 - 0.8, rand(vec2(3.0, 4.0)) * 1.6 - 0.8);\n    vec2 pos2 = vec2(rand(vec2(5.0, 6.0)) * 1.6 - 0.8, rand(vec2(7.0, 8.0)) * 1.6 - 0.8);\n    vec2 pos3 = vec2(rand(vec2(9.0, 10.0)) * 1.6 - 0.8, rand(vec2(11.0, 12.0)) * 1.6 - 0.8);\n\n    // 计算月亮的移动轨迹\n    float radius = 0.2 * 1.5; // 修改月亮大小为现在的2.5倍\n    float angle1 = time * speed;\n    float angle2 = time * speed * 2.0;\n    float angle3 = time * speed * 3.0;\n    pos1 = vec2(cos(angle1), sin(angle1)) * radius;\n    pos2 = vec2(cos(angle2), sin(angle2)) * radius;\n    pos3 = vec2(cos(angle3), sin(angle3)) * radius;\n\n    // 确保月亮在屏幕内完整显示且不重叠\n    float moonRadius = 0.2 * 1.5; // 修改月亮大小为现在的2.5倍\n    float minDistance = 2.0 * moonRadius;\n    pos1 = clamp(pos1, vec2(-0.8), vec2(0.8));\n    pos2 = clamp(pos2, vec2(-0.8), vec2(0.8));\n    pos3 = clamp(pos3, vec2(-0.8), vec2(0.8));\n    pos2 = avoidOverlap(pos1, pos2, minDistance);\n    pos3 = avoidOverlap(pos1, pos3, minDistance);\n    pos3 = avoidOverlap(pos2, pos3, minDistance);\n\n\n    // 绘制三个月亮\n    vec3 color = drawMoon(ro, rd, vec3(pos1, 0.0), moonRadius);\n    color += drawMoon(ro, rd, vec3(pos2, 0.0), moonRadius);\n    color += drawMoon(ro, rd, vec3(pos3, 0.0), moonRadius);\n\n    return color;\n}\n\n// draw moon for good situation\nvec3 goodMoon(vec2 uv)  {\n    vec3 ro = vec3(0.0, 0.0, 2.0); // 观察者位置\n    vec3 rd = normalize(vec3(uv, -1.0)); // 光线方向\n\n    // 随机生成两个位置\n    float time = iTime;\n    float speed = 0.1;\n    vec2 pos1 = vec2(0.0, 0.0); // 月亮1始终在屏幕中间\n    vec2 pos2 = vec2(rand(vec2(5.0, 6.0)) * 1.6 - 0.8, rand(vec2(7.0, 8.0)) * 1.6 - 0.8);\n    vec2 pos3 = vec2(rand(vec2(9.0, 10.0)) * 1.6 - 0.8, rand(vec2(11.0, 12.0)) * 1.6 - 0.8);\n\n    // 计算月亮的移动轨迹\n    float radius = 0.2 * 1.5; // 修改月亮大小为2.5倍\n    float angle1 = time * speed;\n    float angle2 = time * speed * 2.0;\n    float angle3 = time * speed * 3.0;\n    pos2 = vec2(cos(angle2), sin(angle2)) * radius;\n    pos3 = vec2(cos(angle3), sin(angle3)) * radius;\n\n    // 确保月亮在屏幕内完整显示且不重叠\n    float moonRadius = 0.2 * 1.5; // 修改月亮大小为2.5倍\n    float minDistance = 2.0 * moonRadius;\n    pos2 = avoidOverlap(pos1, pos2, minDistance);\n    pos3 = avoidOverlap(pos1, pos3, minDistance);\n    pos3 = avoidOverlap(pos2, pos3, minDistance);\n\n    // 绘制背景\n    vec3 background = vec3(0.3, 0.45, 0.66); // 星空黑背景\n    vec3 color = background;\n\n    // 绘制三个月亮\n    color += drawMoon(ro, rd, vec3(pos1, 0.0), moonRadius);\n    color += vec3(0.9, 0.8, 0.3) * drawMoon(ro, rd, vec3(pos2, 0.18), moonRadius); // 月亮2的颜色为银灰色\n    color += vec3(0.9, 0.6, 0.6) * drawMoon(ro, rd, vec3(pos3, 0.18), moonRadius); // 月亮3的颜色为银灰色\n\n    return color;\n}\n\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define PI 3.1415926\n\nfloat Hash21(vec2 p) {\n    p = fract(p * vec2(123.45, 234.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n\n}\nmat2 Rot(float a) {\n    a = a / 180. * PI;\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 withInBox(vec2 uv, vec4 rect) {\n    return (uv - rect.xy) / (rect.zw - rect.xy);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    float proj = clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0);\n    return length(ap - proj * ab);\n}\n\nvec4 Head(vec2 uv, float time) {\n    vec4 col = vec4(vec3(1.0, 0.976, 0.96), 0.);\n\n    float y = uv.y + (uv.x * uv.x) * 0.5;\n    vec2 nuv = vec2(uv.x, y);\n    float d = length(nuv);\n    float blur = 0.005;\n    float m = S(0.2, 0.2 - blur, d);\n    float size = 0.;\n\n    float side = sign(uv.x);\n    uv.x = abs(uv.x);\n    float t = fract(time * 0.3);\n    float rt = smoothstep(0.1, 0.22, t) * smoothstep(0.25, 0.22, t);\n    float rt2 = smoothstep(0.22, 0.34, t) * smoothstep(0.46, 0.34, t);\n    rt += rt2;\n    float rotation = mix(-13., -15., rt);\n    vec2 ruv = uv * Rot(rotation);\n    vec4 rect = vec4(0.0, 0.0, 0.5, 0.5);\n    nuv = withInBox(ruv - vec2(0.08, 0.2), rect);\n    nuv = vec2(nuv.x, nuv.y - (nuv.x * nuv.x) * 20.);\n    nuv *= vec2(4.0, 1.0);\n    d = length(nuv);\n\n    size = 0.4;\n    blur = 0.01;\n    m += S(size, size - blur, d);\n\n    // ear\n    m = clamp(m, 0., 1.);\n    col.a = max(col.a, m);\n    vec3 pink = vec3(255, 182, 195) / 255.;\n    blur = 0.05;\n    nuv = withInBox(ruv * vec2(2.) - vec2(0.15, 0.55), rect);\n    nuv = vec2(nuv.x, nuv.y - (nuv.x * nuv.x) * 10.);\n    nuv *= vec2(4.0, 1.0);\n\n    d = length(nuv);\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, pink, m);\n\n    // eye\n    blur = 0.05;\n    size = 0.37;\n    rect = vec4(0.0, 0.0, 0.1, 0.1);\n    vec2 offs = vec2(0.12, -0.03);\n    rect.xy += offs;\n    rect.zw += offs;\n    nuv = withInBox(uv, rect);\n    d = length(nuv);\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, vec3(0.2), m);\n\n    // eye highlights\n    blur = 0.05;\n    size = 0.15;\n    rect = vec4(0.0, 0.0, 0.1, 0.1);\n    offs = vec2(0.12, -0.03);\n    rect.xy += offs;\n    rect.zw += offs;\n    nuv = withInBox(uv, rect);\n\n    t = smoothstep(0.5, 0.6, fract(time * 0.5)) * 3.14159 * 2.;\n    float xx = 0.1 * cos(t + 1.);\n    float yy = 0.1 * sin(t + 1.);\n    d = length(nuv - vec2(xx * side, yy));\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, vec3(1.0), m);\n\n    // blush\n    blur = 0.5;\n    size = 0.68;\n    rect = vec4(0.0, 0.0, 0.1, 0.1);\n    offs = vec2(0.12, -0.03);\n    rect.xy += offs;\n    rect.zw += offs;\n    nuv = withInBox(uv, rect);\n    d = length(nuv - vec2(0.2, -0.9));\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, pink * 1.2, m);\n\n    blur = 0.01;\n    size = 0.015;\n    rect = vec4(0.0, 0.0, 0.5, 0.5);\n    offs = vec2(0.0, -0.0);\n    rect.xy += offs;\n    rect.zw += offs;\n    nuv = withInBox(uv, rect);\n    nuv.y += -6. * ((nuv.x - 0.05) * (nuv.x - 0.05));\n    nuv.y -= -0.18;\n    d = line(nuv, vec2(0.), vec2(0.08, 0.0));\n    m = S(size, size - blur, d);\n    col.rgb = mix(col.rgb, vec3(0.), m);\n\n    return col;\n}\n\nvec4 draw(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    float gradient = smoothstep(-0.5, 0.2, uv.y);\n    vec3 col = mix(vec3(0, 0, 0), vec3(0, 0, 0), gradient);\n    vec4 head = Head(uv, iTime);\n\n    uv *= 5.;\n    vec2 id = floor(uv);\n    float n = Hash21(id);\n    vec2 st = fract(uv) - 0.5;\n    float vn = smoothstep(0.2, 0.8, n) * 0.5 + 0.1;\n    st *= Rot(fract(iTime * vn) * 360. + n * 123.4);\n\n    vec4 fractHead = Head(st, 0.);\n    col = mix(col, fractHead.rgb, fractHead.a);\n\n    fragColor = vec4(col, 1.0);\n    return fragColor;\n}\n// main function\n// 1. homepage\n// 2. click to moon\n// 存储左键点击状态的变量\nint clickFrame = -1;\nint displayState = 0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float time = mod(iTime, 30.0);\n\n    if (time < 7.0) {\n        if (iMouse.z > 0.0) {\n            displayState = 1; // display words\n        } else {\n            displayState = 0;\n        }\n    } else if (time >= 7.0 && time < 12.0) {\n        displayState = 2;\n    } else if (time >= 12.0 && time < 15.0) {\n        displayState = 3;\n    }  else if (time >= 15.0 && time < 25.0) {\n        displayState = 4;\n    }  else if (time >= 25.0 && time < 30.0) {\n        displayState = 5;  \n    }\n\n    // Determine the current and next images based on the display state\n    switch (displayState) {\n        case 0:\n            fragColor = texture(iChannel0, uv);\n            break;\n        case 1:\n            //fragColor = words(uv);\n            fragColor = texture(iChannel3, uv);\n            break;\n        case 2:\n            // good\n            vec2 uv2 = uv * 2.0 - 1.0;\n            uv2.x *= iResolution.x / iResolution.y;\n            float audioLeft = texture(iChannel2, vec2(uv.x, 0.25)).r;\n            float audioRight = texture(iChannel2, vec2(uv.x, 0.75)).g;\n            float audio2 = (audioLeft + audioRight) * 0.5;\n            fragColor = vec4(goodMoon(uv2), 1.0);\n            break;\n        case 3:\n            fragColor = draw(fragColor,fragCoord);\n            break;\n        case 4:\n            vec2 uv3 = uv * 2.0 - 1.0;\n            uv3.x *= iResolution.x / iResolution.y;\n            float audioLeft3 = texture(iChannel2, vec2(uv.x, 0.25)).r;\n            float audioRight3 = texture(iChannel2, vec2(uv.x, 0.75)).g;\n            float audio3 = (audioLeft3 + audioRight3) * 0.5;\n            fragColor = vec4(badMoon(uv3), 1.0);\n            break;\n        case 5:\n            fragColor = texture(iChannel1, uv);\n            break;\n             \n        default:\n            fragColor = texture(iChannel0, uv);\n            break;\n    }\n}","name":"Image","description":"","type":"image"}]}