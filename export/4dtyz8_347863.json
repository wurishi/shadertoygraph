{"ver":"0.1","info":{"id":"4dtyz8","date":"1518031869","viewed":98,"name":"HW3 Swing","username":"ChloeSnyder","description":"HW3","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\n// RAY MARCHING CODE SOURCE JAMIE WONG\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 300.0;\nconst float EPSILON = 0.0001;\n\nvec3 K_d = vec3(-1.0, -1.0, -1.0); // diffuse color\nfloat shininess;\n\nfloat noise(vec3 x)\n{\n        return fract(sin(dot(x.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// modified from https://thebookofshaders.com/edit.php#11/wood.frag\nfloat lines(vec3 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin((pos.y) *3.1415) + cos((pos.y) *3.1415)+b*2.0))*.5);\n}\n\n\nfloat perlinNoise(vec3 v) \n{ \n    vec3 nXnYnZ = floor(v); // grid corner\n    vec3 i = fract(v);\n\n    // generate other grid corners\n    vec3 pXpYpZ = nXnYnZ + vec3(1.0, 1.0, 1.0);\n    vec3 pXpYnZ = nXnYnZ + vec3(1.0, 1.0, 0.0);\n    vec3 pXnYnZ = nXnYnZ + vec3(1.0, 0.0, 0.0);\n    vec3 pXnYpZ = nXnYnZ + vec3(1.0, 0.0, 1.0);\n    vec3 nXpYpZ = nXnYnZ + vec3(0.0, 1.0, 1.0);\n    vec3 nXnYpZ = nXnYnZ + vec3(0.0, 0.0, 1.0);\n    vec3 nXpYnZ = nXnYnZ + vec3(0.0, 1.0, 0.0);\n\n    // feed these grid corners into a noise function that takes a vec3 and returns a float\n    float ppp = noise(pXpYpZ);\n    float ppn = noise(pXpYnZ);\n    float pnn = noise(pXnYnZ);\n    float pnp = noise(pXnYpZ);\n    float npp = noise(nXpYpZ);\n    float nnp = noise(nXnYpZ);\n    float npn = noise(nXpYnZ);\n    float nnn = noise(nXnYnZ);\n\n    // interpolate 3D  to 2D\n    float nn = nnn * (1.0 - i.x) + pnn * i.x;\n    float np = nnp * (1.0 - i.x) + pnp * i.x;\n    float pn = npn * (1.0 - i.x) + ppn * i.x;\n    float pp = npp * (1.0 - i.x) + ppp * i.x;\n\n    //interpolate 2D to 1 D\n    float n = nn * (1.0 - i.y) + pn * i.y;\n    float p = np * (1.0 - i.y) + pp * i.y;\n\n    return n * (1.0 - i.z) + p * i.z;\n\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale) * min(scale.x, min(scale.y, scale.z));\n}\n\n/**\n * Rotation matrix around the X axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n/** JW\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/** JW\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/** JW\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//iq\nfloat cubeSDF( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n/** JW\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n// iq\nfloat cylinderSDF( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ramp(vec3 p)\n{\n    p += vec3(0.0, .05, 0.0);\n    // create ring for main body of half pipe\n    vec3 cylp = p - vec3(0.0,.9,0.0);\n    cylp = rotateX(90.0 * deg2rad) * cylp;\n    cylp = rotateZ(90.0 * deg2rad) * cylp;\n   \tfloat cyl = cylinderSDF(cylp, vec2(1.0, 1.0)) - .03;    \n    float outerCyl = cylinderSDF(cylp, vec2(1.0, 5.0)) - .03;\n    cyl = differenceSDF(cyl, outerCyl); \n    \n    // remove upper half\n    vec3 rectp = p - vec3(0.0, 1.8, 0.0);\n    float rect = cubeSDF(rectp, vec3(1.5, 1.0, 1.5));  \n    float halfpipe = differenceSDF(cyl, rect) - .05;\n    \n    // legs of halfpipe\n    float legs = cubeSDF(p - vec3(0.0, -.40, -3.0), vec3(1.0, .19, 7.0)) - .05;\n    halfpipe = smin(halfpipe, legs, .1) - .01;\n    \n    // line down the middle of half pipe\n    float centercut = cubeSDF(p, vec3(1.14, .9, .2)) - .01;\n    float rampBody = differenceSDF(halfpipe, centercut) - .01;\n    \n  \n    // curved cut out\n    float cutoutlefttop = cubeSDF(p - vec3(0.0, -.35, 2.6), vec3(1.1, .06, 2.05)) - .2;\n    float cutoutrighttop = cubeSDF(p - vec3(0.0, -.35, -4.5), vec3(1.1, .06, 4.0)) - .2;\n    float cutouttop = smin(cutoutlefttop, cutoutrighttop, .5);\n    \n\n    float cutoutleftbottom = cubeSDF(p - vec3(0.0, -.90, 1.6), vec3(1.12, -.3, 1.8)) - .25;\n    float cutoutrightbottom = cubeSDF(p - vec3(0.0, -.90, -1.9), vec3(1.12, -.3, 5.5)) - .4;\n   \n    float cutTop = differenceSDF(rampBody, cutouttop) - .01;\n    float cutBottom = unionSDF(cutoutleftbottom, cutoutrightbottom) - .01;\n    float cut = intersectSDF(cutouttop, cutBottom) - .02;\n    cut = intersectSDF(cut, legs);\n\n    return smin(cut, cutTop, .2);\n\n}\n\n// iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat pendulum (vec3 p)\n{\n  \n    p = rotateX(90.0 * deg2rad) * p;\n    \n    // pendulum motion\n    float g = 9.80665;\n    float L = 3.0;\n    float omega = sqrt(g/L);\n    float theta = cos(omega * iTime);\n\n    vec3 offset = vec3(3.0, 0.0, 0.0) * cos(theta - PI / 2.0);\n    offset += vec3(0.0, 0.0, 3.0) * sin(theta - PI / 2.0);\n    \n    vec3 cp = p + offset;\n    // inner and outter cylinders for ring shape\n    float outer = cylinderSDF(cp, vec2(1.0, .30));\n    float inner = cylinderSDF(cp, vec2(.5, 1.5));\n    \n    float pend = differenceSDF(outer, inner); \n    \n    // fishing line\n    vec3 endpt = rotateX(cos(iTime)) * vec3(0.0, 0.0, 2.0);\n    endpt = rotateZ(sin(iTime)) * endpt;\n    float line = sdCapsule(p, -offset + vec3(0.0, 0.0, -.7), vec3(0.0, 0.0, -2.8), .0099);\n    \n    // set color\n    if(line < 0.0 + EPSILON)\n    {\n        K_d = vec3(1.0, 1.0, 1.0);\n    } \n   \n    \n    return unionSDF(line, pend);\n}\n\nfloat triangle_wave(float x, float freq, float amplitude)\n{\n    return abs(mod((x*freq), amplitude) - (0.5 * amplitude)) - 1.5;\n}\n\nfloat ball(vec3 p)\n{\n    //estimate circular motion as a pendulum so that I can match the period\n    // of motion with the pendulum\n    p -= vec3(0.0, 2.3, 0.0);\n    float g = 9.80665;\n    float L = 3.0;\n    float omega = sqrt(g/L);\n   \n    float theta = omega * cos(omega * iTime);\n    \n     \n    vec3 offset = vec3(0.0, 0.0, 6.0) * cos(theta - PI / 2.0);\n    offset += vec3(0.0, 6.0, 0.0) * -sin(theta - PI / 2.0);\n    \n    vec3 p_ball = p + offset;\n    vec3 p_stripe1;\n    vec3 p_stripe2;\n    \n    // flip direction of rotation at top of ramp\n    float direction = floor(triangle_wave(theta - PI / 2.0, PI / 2.0, 8.0)); \n    direction = clamp(direction, -1.0, 1.0);\n    \n   \tp_ball = rotateX(direction * omega * iTime) * p_ball;\n    p_stripe1 = rotateX(direction * omega * iTime) * p_ball + vec3(0.0, -.5, 0.0);\n    p_stripe2 = rotateX(direction * omega * iTime) * p_ball + vec3(0.0, .5, 0.0);\n    \n    \n    float ball = sphereSDF(p_ball);\n    \n    // model the stripe as a rectangle intersecting with the ball\n    float stripe1 = cubeSDF(p_stripe1, vec3(1.0, .2, 1.0));\n    float stripe2 = cubeSDF(p_stripe2, vec3(1.0, .2, 1.0));\n\n    // set color\n    if(stripe1 < 0.0 + EPSILON || stripe2 < 0.0 + EPSILON)\n    {\n        K_d = vec3(1.0, 1.0, 1.0);\n    }\n    \n    if(ball < 0.0 + EPSILON && K_d.x < 0.0)\n    {\n        K_d = vec3(.5, .5, 0.2);\n    } \n\n    return ball;\n}\n\n// iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n//iq\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  n = normalize(n);\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat groundPlane(vec3 p)\n{\n    float backrect = cubeSDF(p + vec3(25.0, .8, 0.0), vec3(20.5, .2, 15.0));\n    float plane = sdPlane(p + vec3(0.0, .8, 0.0), vec4(0.0, 1.0, 0.0, 1.0));\n    if(backrect < 0.0 + EPSILON)\n    {\n        K_d =  cos(perlinNoise(.5 * p)) * vec3(20, 55, 129) / 255.0;\n    }\n    if(plane < 0.0 + EPSILON)\n    {\n        K_d =  vec3(4, 45, 112) / 255.0;\n    }\n    return unionSDF(plane, backrect);\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float ball = ball(samplePoint / .2) * .2;\n    float ramp = ramp((samplePoint - vec3(0.0, -.750, 0.0)) / 1.4) * 1.4;\n    float pend = pendulum((samplePoint - vec3(0.0, 1.1, 0.0)) / .6) * .6;\n    shininess = 10.0;\n    if(ramp < 0.0 + EPSILON)\n    {\n        // Woodgrain\n        float pattern = samplePoint.x;\n        vec3 p = rotateX(cos(perlinNoise(samplePoint))) *  rotateY(sin(perlinNoise(samplePoint))) * rotateZ(perlinNoise(samplePoint)) * samplePoint;\n        pattern = lines(p, .50) + lines(rotateX(30.0) * p + vec3(.5, 1.0, 1.0), .1) / 2.0;\n        vec3 d = vec3(178, 153, 132)/255.0;\n        vec3 b = vec3(114, 109.0, 94.0) / 255.0;\n        vec3 c = vec3(58.0, 52.0, 35.0) / 255.0;\n        vec3 a = vec3(99.0, 79.0, 62.0) / 255.0;\n        K_d = palette(pattern, a, b, c, d) * c + d + vec3(.02, .02, 0.0);\n    } \n    if(pend < 0.0 + EPSILON)\n    {\n        if(K_d.x < 0.0)\n        {  \n            // give the pendulum a gold color if color hasn't already been set\n            // if color has been set, that means its the fishing line\n    \t\tK_d = vec3(249.0 / 255.0, 199.0 / 255.0, 17.0 / 255.0);\n        }\n        shininess = .90;\n    }\n    float rampAndPend = unionSDF(ramp, pend);\n    float ground = groundPlane(samplePoint);\n    float scene = unionSDF(rampAndPend, ball);\n    \n    return unionSDF(scene, ground);\n}\n\n\n// Modified from iq\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = sceneSDF(ro + rd*t);\n        if( h<0.001 )\n            return 0.02;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n/** JW\n * \n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/** JW\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/** JW\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/** JW\n * \n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/** JW\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          10.0,\n                          6.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity)\n                \t\t\t\t* shadow(p, normalize(light1Pos - p), 0.1, 10.0, 8.0);\n         \t\t\t\t\t\t\n    \n    vec3 light2Pos = eye + vec3(2.0 ,\n                          2.0 ,\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity)\n         \t\t\t\t\t\t;   \n    return color;\n}\n\n/** JW\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(11.0, 3.0, 5.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir; // eye must be frag coord converted to world space! TO DO!!!!\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n  //  vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n   // float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}