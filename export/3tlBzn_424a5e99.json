{"ver":"0.1","info":{"id":"3tlBzn","date":"1595854736","viewed":310,"name":"Drifting 2D pixel art cloud","username":"Healthire","description":"Pixelated drifting 2D cloud made from multiple layers of perlin noise","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","cloud","pixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define W0 0x3504f335u\n#define W1 0x8fc1ecd5u\n#define M 741103597u\n\nuint fast_hash(uint x, uint y) {\n    x *= W0;\n    y *= W1;\n    x ^= y;\n    x *= M;\n    return x;\n}\n\nfloat hash_to_float(uint h) {\n    return float(h >> 8u) * (1.0 / 16777216.0);\n}\n\nvec2 rand_vec(uvec2 p) {\n    float angle = hash_to_float(fast_hash(p.x, p.y)) * radians(360.);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin_noise(in vec2 point, vec2 wrap, float seed) {\n    vec2 point_i = floor(point);\n    vec2 point_f = fract(point);\n\n\tvec2 vec_tl = rand_vec(uvec2(mod(point_i + vec2(0., 0.), wrap) + vec2(seed)));\n\tvec2 vec_tr = rand_vec(uvec2(mod(point_i + vec2(1., 0.), wrap) + vec2(seed)));\n\tvec2 vec_bl = rand_vec(uvec2(mod(point_i + vec2(0., 1.), wrap) + vec2(seed)));\n\tvec2 vec_br = rand_vec(uvec2(mod(point_i + vec2(1., 1.), wrap) + vec2(seed)));\n\n\tvec2 u = point_f * point_f * (3.0 - 2.0 * point_f);\n    return mix(\n        mix(dot(vec_tl, point_f - vec2(0.0, 0.0)), dot(vec_tr, point_f - vec2(1.0, 0.0)), u.x),\n        mix(dot(vec_bl, point_f - vec2(0.0, 1.0)), dot(vec_br, point_f - vec2(1.0, 1.0)), u.x),\n        u.y\n    ) * 1.41;\n}\n\n\nfloat cloud_noise(vec2 uv, float freq, float seed, float time) {\n    vec2 wrap = vec2(24., 24.);\n    vec2 move = vec2(-time, -time) * wrap;\n    float v1 = abs(perlin_noise(uv * freq + move * vec2(-1.0, 1.0), wrap, seed));\n    float v2 = abs(perlin_noise(uv * freq * 2. + move * 1.5, wrap * 1.5, seed + wrap.x)) * 0.5;\n    float v3 = abs(perlin_noise(uv * freq * 4. + move * 2., wrap * 2., seed + wrap.x * 2.5)) * 0.25;\n\n    float x_mul = min(smoothstep(0.0, 0.5, uv.x), smoothstep(1.0, 0.5, uv.x));\n    float y_mul = min(smoothstep(0.0, 0.2, uv.y), smoothstep(1.0, 0.2, uv.y));\n\n    return (v1 + v2 + v3) * x_mul * y_mul * 1. - 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragCoord = floor(fragCoord / 2.0) * 2.0;\n    \n    vec3 light_dir = vec3(cos(iTime * 0.1), sin(iTime * 0.1), 0.0);\n    if (iMouse.z > 0.0) {\n        vec2 center = iResolution.xy / 2.;\n        light_dir = vec3(normalize(iMouse.xy - center), 0.);\n    }\n    \n    float morph_time = 200.0;\n    float freq = 1.5;\n    float height = cloud_noise(fragCoord / iResolution.xy, freq, 0., mod(iTime / morph_time, 1.0));\n    float other = cloud_noise((fragCoord - light_dir.xy) / iResolution.xy, freq, 0., mod(iTime / morph_time, 1.0));\n    float brightness = mix(0.8, 1.0, ceil(other - height));\n    \n    vec3 sky = vec3(0.1, 0.5, 0.9);\n    \n    height = min(ceil(max(height, 0.0)), 1.0);\n    fragColor = vec4(mix(sky, mix(sky, vec3(1.0), brightness), height), 1.0);\n}","name":"Image","description":"","type":"image"}]}