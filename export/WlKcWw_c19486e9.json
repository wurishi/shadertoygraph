{"ver":"0.1","info":{"id":"WlKcWw","date":"1611144371","viewed":153,"name":"Jump legs","username":"gaz","description":"3d","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["bounding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 M[BoneCnt];\nbool inBound;\n\nvoid camera(out vec3 ro, inout vec3 rd)\n{\n    ro=texelFetch(iChannel2,getBufUV(100,iResolution),0).xyz;\n    rd=mat3(\n        texelFetch(iChannel2,getBufUV(101,iResolution),0).xyz,\n        texelFetch(iChannel2,getBufUV(102,iResolution),0).xyz,\n        texelFetch(iChannel2,getBufUV(103,iResolution),0).xyz\n        )*rd;\n}\n\nvec4 bufData (int p)\n{\n  return texelFetch(iChannel0,getBufUV(p,iResolution),0);\n}\n\nmat4 getMat(int id, int reel)\n{\n    id+=ReelCnt*reel;\n\tid*=4;\n    return mat4(bufData(id++),bufData(id++),bufData(id++),bufData(id));\n}\n\n#define tf(a,b) transform(a,b)\nvec3 transform(mat4 m,vec3 p)\n{\n    return (m*vec4(p,1)).xyz;\n}\n\nfloat deStage(vec3 p)\n{\n    float de=p.y;\n    de=min(de, deRoundBox(p-vec3(30,0,0),vec3(1,12,100),.6));\n    de=min(de, deRoundBox(p-vec3(-30,0,0),vec3(1,12,100),.6));\n    vec3 coord=vec3(2,4,0);\n    coord.x+=sin(iTime*2.)*2.;\n    p-=coord;\n    p.z-=-iTime*7.;\n    p.xz=mod(p.xz,10.)-5.;\n    p.xy*=rot(iTime);\n    p.xz*=rot(iTime*.5);\n    de=min(de,deStella(p,.7));\n    return de;\n}\n\n#define T boneTail\nfloat deModel(vec3 p)\n{\n    float de=1e9;\n    de=min(de,deRoundBox(tf(M[Waist],p)-T[Waist]*.5,\n        vec3(.1,T[Breast].y*.5,.1),.4));\n    de=min(de,deRoundBox(tf(M[Breast],p)-T[Breast]*.5,\n        vec3(1.,T[Breast].y*.5,.3),.3));\n    de=min(de,deCapsule(tf(M[Neck],p),T[Neck],.3));\n    de=min(de,\n        deRoundBox(tf(M[Head],p)-T[Head]*.5,\n        vec3(.5 ,T[Head].y*.5,.3),.1));\n    de=min(de,deCapsule(tf(M[RightUpperArm],p),T[RightUpperArm],.4));\n    de=min(de,deCapsule(tf(M[RightLowerArm],p),T[RightLowerArm],.4));\n    de=min(de,\n        deRoundBox(tf(M[RightHand],p)-T[RightHand]*.5,\n        vec3(.5,.3 ,.1),.2));\n    de=min(de,deCapsule(tf(M[LeftUpperArm],p),T[LeftUpperArm],.4));\n    de=min(de,deCapsule(tf(M[LeftLowerArm],p),T[LeftLowerArm],.4));\n    de=min(de,\n        deRoundBox(tf(M[LeftHand],p)-T[LeftHand]*.5,\n        vec3(.5,.3 ,.1),.2));\n        \n    de=min(de,deRoundBox(tf(M[Hip],p)-T[Hip]*.5,\n        vec3(.8,-T[Hip].y*.5,.3),.3));\n    de=min(de,deCapsule(tf(M[RightUpperLeg],p),T[RightUpperLeg],.4));\n    de=min(de,deCapsule(tf(M[RightLowerLeg],p),T[RightLowerLeg],.4));\n    de=min(de,deCapsule(tf(M[RightHeel],p),T[RightHeel],.4));\n    de=min(de,\n        deRoundBox(tf(M[RightToe],p)-T[RightToe]*.5,\n        vec3(.3,.1 ,T[RightToe].z*.5),.15));\n    de=min(de,deCapsule(tf(M[LeftUpperLeg],p),T[LeftUpperLeg],.4));\n    de=min(de,deCapsule(tf(M[LeftLowerLeg],p),T[LeftLowerLeg],.4));\n    de=min(de,deCapsule(tf(M[LeftHeel],p),T[LeftHeel],.4));\n    de=min(de,\n        deRoundBox(tf(M[LeftToe],p)-T[LeftToe]*.5,\n        vec3(.3,.1 ,T[LeftToe].z*.5),.15));\n    return de;\n}\n\nfloat map(vec3 p)\n{\n    float de=deStage(p);\n    if(inBound)de=min(de,deModel(p));\n    return de;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat calcSoftShadow(vec3 p, vec3 light)\n{\n\tvec3 rd=normalize(light-p);\n\tvec3 ro=p;\n\tfloat far = 30.;\n\tfloat t=.1;\n    float res=1.;\n\tconst float k=8.;\n    for( int i=0; i<50; i++)\n    {\n        float d=map(ro+rd*t);\n        if(d<.001)return 0.;\n\t\tres = min(res,k*d/t);\t\t\n        t+=d;\t\t\n\t\tif(t>far)return res;\n    }\n    return res;\n}\n\nvec3 doColor(vec3 p)\n{\n    if(deModel(p)<.001)return vec3(0,.3,1);\n    if(p.y<.007)return .3*(cos(vec3(3,5,14)+p*6.)*.5+.5);\n    return vec3(1.2,.1,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for(int i=0;i<BoneCnt;i++)M[i]=getMat(i,0);   \n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro;\n    vec3 rd = normalize(vec3(uv,2));\n    camera(ro,rd);\n    vec3 col=vec3(0);\n    vec4 B=texelFetch(iChannel1,ivec2(fragCoord),0);\n    float t=B.x,d;\n    for(int i=0;i<90;i++)\n    {\n        inBound=t<B.y&&B.w==1.;\n        t+=d=map(ro+rd*t);\n        if(d<.001)break;\n        if(t>=B.y&&t<B.z)t=B.z;\n        if(t>=maxd)break;\n    }\n    if(t<maxd)\n        {\n            vec3 p=ro+rd*t;\n            col=doColor(p); \n            vec3 n=calcNormal(p);      \n            vec3 lightPos=vec3(5,20,10)*50.;\n            vec3 li=normalize(lightPos-p);\n            float dif=clamp(dot(n,li),0.,1.);\n            inBound=true;\n            float sha=calcSoftShadow(p,lightPos);\n            col*=max(dif*sha,.2);\n            float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n            float frn=rimd+2.2*(1.-rimd);\n            col*=frn*.6;\n            col*=max(.5+.5*n.y,.3);\n            col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n            col=mix(vec3(0),col,exp(-t*t*.0005));\n        }\n        \n// Show bounding        \n#if 0\n    col=mix(col,vec3(1,0,0),B.w*.2);\n#endif\n\n    col=pow(col,vec3(1./2.2));\n    fragColor = vec4(col,1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define maxd 150.\n#define ReelCnt 30\n#define BoneCnt 24\n\n#define Center 0\n#define Waist 1\n#define Breast 2\n#define Neck 3\n#define Head 4\n#define RightShoulder 5\n#define RightUpperArm 6\n#define RightLowerArm 7\n#define RightHand 8\n#define LeftShoulder 9\n#define LeftUpperArm 10\n#define LeftLowerArm 11\n#define LeftHand 12\n#define Hip 13\n#define RightHip 14\n#define RightUpperLeg 15\n#define RightLowerLeg 16\n#define RightHeel     17\n#define RightToe      18\n#define LeftHip 19\n#define LeftUpperLeg 20\n#define LeftLowerLeg 21\n#define LeftHeel    22\n#define LeftToe      23\n#define None 255\n\nint parentIdx[BoneCnt]=int[]( // parentIdx\n    None,// Center\n    Center,// Waist\n    Waist,// Breast\n    Breast,// Neck\n    Neck,// Head\n    Breast,// RightShoulder\n    RightShoulder,// RightUpperArm\n    RightUpperArm,// RightLowerArm\n    RightLowerArm,// RightHand\n    Breast,// LeftShoulder\n    LeftShoulder,// LeftUpperArm\n    LeftUpperArm,// LeftLowerArm\n    LeftLowerArm,// LeftHand\n    Center,// Hip\n    Hip,// RightHip\n    RightHip,// RightUpperLeg\n    RightUpperLeg,// RightLowerLeg\n    RightLowerLeg,// RightHeel\n    RightHeel,// RightToe\n    Hip,// LeftHip\n    LeftHip,// LeftUpperLeg\n    LeftUpperLeg,// LeftLowerLeg\n    LeftLowerLeg,// LeftHeel\n    LeftHeel// LeftToe\n);\n\nvec3 boneTail[BoneCnt]=vec3[]( // boneTail\n    vec3(0,0,0), // Center\n    vec3(0,1.5,0), // Waist\n    vec3(0,2,0), //\tBreast\n    vec3(0,1,0), //\tNeck\n    vec3(0,1,0), //\tHead\n    vec3(1.5,0,0), //\tRightShoulder\n    vec3(3.4,0,0), //\tRightUpperArm\n    vec3(3.4,0,0), //\tRightLowerArm\n    vec3(.3,0,0), //\tRightHand,\n    vec3(-1.5,0,0), // LeftShoulder\n    vec3(-3.4,0,0), // LeftUpperArm\n    vec3(-3.4,0,0), // LeftLowerArm\n    vec3(-.3,0,0), // LeftHand\n    vec3(0,-1.5,0), // Hip\n    vec3(1.,0,0), // RightHip\n    vec3(0,-5,0), // RightUpperLeg\n    vec3(0,-5,0), // RightLowerLeg\n    vec3(0,0,4), // RightHeel\n    vec3(0,0,2), // RightToe\n    vec3(-1.,0,0), // LeftHip\n    vec3(0,-5,0), // LeftUpperLeg\n    vec3(0,-5,0), // LeftLowerLeg\n    vec3(0,0,4), // LeftHeel\n    vec3(0,0,2) // LeftToe\n);\n\n\nmat4 move(vec3 p) {\n  return mat4(1,0,0,0,0,1,0,0,0,0,1,0,p,1);\n}\n\nmat4 rotX(float a) {\n  float s=sin(a),c=cos(a);\n  return mat4(1,0,0,0,0,c,s,0,0,-s,c,0,0,0,0,1);\n}\nmat4 rotY(float a) {\n  float s=sin(a),c=cos(a);\n  return mat4(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);\n}\n\nmat4 rotZ(float a) {\n  float s=sin(a),c=cos(a);\n  return mat4(c,s,0,0,-s,c,0,0,0,0,1,0,0,0,0,1);\n}\n\nmat4 rot(vec3 axis, float t) {\n    vec3 a = normalize(axis);\n    float s=sin(t),c=cos(t),r=1.0-c;\n    return mat4(\n      a.x*a.x*r+c,a.y*a.x*r+a.z*s,a.z*a.x*r-a.y*s,0,\n      a.x*a.y*r-a.z*s,a.y*a.y*r+c,a.z*a.y*r+a.x*s,0,\n      a.x*a.z*r+a.y*s,a.y*a.z*r-a.x*s,a.z*a.z*r+c,0,\n      0,0,0,1);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nmat3 lookat(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 w = normalize(target-eye), u = normalize(cross(w,up));\n    return mat3(u,cross(u,w),w);\n}\n\nivec2 getBufUV(int n, vec3 r)\n{\n    return ivec2(n%int(r.y),n/int(r.y));\n}\n\n\nvoid sFold45(inout vec2 p)\n{\n\tvec2 v=normalize(vec2(1,-1));\n\tfloat g=dot(p,v);\n\tp-=(g-sqrt(g*g+5e-3))*v;\n}\n\nfloat deStella(vec3 p, float s)\n{\n    p=sqrt(p*p+5e-3);\n    sFold45(p.xz);\n\tsFold45(p.yz);\n    return dot(p,normalize(vec3(1,1,-1)))-s;\n}\n\nfloat deCapsule(vec3 p, vec3 v, float r)\n{\n    float len=length(v);\n    v=normalize(v);\n    p-=clamp(dot(p,v),0.,len)*v;\n    return length(p)-r;\n}\n\nfloat deRoundBox(vec3 p, vec3 v, float r)\n{\n    p-=clamp(p,-v,v);\n    return length(p)-r;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define t iTime/3.1415\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tint p = int(fragCoord.x) + int(iResolution.y) * int(fragCoord.y);\n    // camera\n    if(p>=100&&p<104)\n    {\n        vec3 ro = vec3(2,20,23);\n        vec3 ta=vec3(0,12,0);\n        ro.xz*=rot(sin(iTime*.2)*.6);\n        \n        mat3 m=lookat(ro,ta,vec3(0,1,0));\n        if(p==100)fragColor.xyz=ro;\n        else fragColor.xyz=m[p-101];    \n    }\n    \n    // skinning\n\tif (p < BoneCnt*4)\n    {\n        mat4 m[BoneCnt];\n        // init\n        for(int i=0;i<BoneCnt;i++)m[i]=mat4(1);\n        m[Center]=move(vec3(0,12,0));\n        m[Hip]=rotX(0.5);\n        m[RightUpperLeg]=rotX(-1.0)*rotZ(0.2);\n        m[RightLowerLeg]=rotX(1.5);\n        m[RightHeel]=rotX(-.2);\n        m[RightToe]=rotX(-.7);\n           \n        m[LeftUpperLeg]=rotX(-1.0)*rotZ(-0.2);\n        m[LeftLowerLeg]=rotX(1.5);\n        m[LeftHeel]=rotX(-.2);\n        m[LeftToe]=rotX(-.7);\n        \n        m[RightLowerArm]= rotY(0.5)*rotZ(0.);\n        m[LeftLowerArm]=rotY(-0.5)*rotZ(0.);\n\n        // amimetion\n        float a=sin(t*8.+.2)*.5-.5;\n        float b=asin(sin(t*4.+.4))*7.;\n        //m[Center]*=rotX(t*4.); // test\n        m[Center]*=move(vec3(b,-a*7.,0));\n        \n        a=sin(t*8.-.3)*.5-.5;\n        a*=1.2;\n        m[RightUpperLeg]*=rotX(a);\n        m[RightLowerLeg]*=rotX(-a);\n        m[RightHeel]*=rotX(-a);\n        m[RightToe]*=rotX(a);\n                \n        m[LeftUpperLeg]*=rotX(a);\n        m[LeftLowerLeg]*=rotX(-a);\n        m[LeftHeel]*=rotX(-a);\n        m[LeftToe]*=rotX(a);\n        \n        a=sin(t*8.);\n        m[RightUpperArm]*=rotZ(-a);\n        m[LeftUpperArm]*=rotZ(a);\n        \n        fragColor = m[p/4][p&3];  \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool existReel(int p,int reel)\n{\n    int id=p/4-reel*ReelCnt;\n    return id<BoneCnt && id>=0;\n}\n\nvec4 bufData (int p)\n{\n  return texelFetch(iChannel0,getBufUV(p,iResolution),0);\n}\n\nmat4 getMat(int id)\n{\n    mat4 m=move(boneTail[parentIdx[id]]);\n\tid*=4;\n    return m*mat4(bufData(id++),bufData(id++),bufData(id++),bufData(id));\n}\n\nmat4 boundMat(int id)\n{\n    mat4 m=mat4(1); \n    while(id<None)\n    {\n        m = getMat(id)*m;\n        id = parentIdx[id];\n    }\n    return m;\n}\n\nmat4 marchMat(int id)\n{\n    mat4 m=mat4(1); \n    while(id<None)\n    {\n        m *= inverse(getMat(id));\n        id = parentIdx[id];\n    }\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int p = int(fragCoord.x) + int(iResolution.y) * int(fragCoord.y);\n    int id=(p/4)%ReelCnt;\n    mat4 m; \n    if(existReel(p,0)) m=marchMat(id);\n\tif(existReel(p,1)) m=boundMat(id);      \n    fragColor = m[p&3];  \n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void camera(out vec3 ro, inout vec3 rd)\n{\n    ro=texelFetch(iChannel1,getBufUV(100,iResolution),0).xyz;\n    rd=mat3(\n        texelFetch(iChannel1,getBufUV(101,iResolution),0).xyz,\n        texelFetch(iChannel1,getBufUV(102,iResolution),0).xyz,\n        texelFetch(iChannel1,getBufUV(103,iResolution),0).xyz\n        )*rd;\n}\n\nvec4 bufData (int p)\n{\n  return texelFetch(iChannel0,getBufUV(p,iResolution),0);\n}\n\nmat4 getMat(int id, int reel)\n{\n    id+=ReelCnt*reel;\n\tid*=4;\n    return mat4(bufData(id++),bufData(id++),bufData(id++),bufData(id));\n}\n\nvec3 transform(mat4 m,vec3 p)\n{\n    return (m*vec4(p,1)).xyz;\n}\n\nvec2 intersectCapsule(vec3 ro, vec3 rd, inout vec3 a, vec3 b,float r)\n{\n    vec3 ab=b-a,ao = a-ro;\n    float len=length(ab);\n    ab=normalize(ab);\n\tfloat d0=dot(rd, ab);\n\tfloat d1=dot(rd, ao);\n\tfloat d2=dot(ab, ao);\n    a+=ab*clamp((d0*d1-d2)/(1.-d0*d0),0.,len);;\n    vec3 u=cross(a-ro,rd);\n    float h=r*r-dot(u,u);\n    return h>=0.?vec2(-1,1)*sqrt(h)+dot(a-ro,rd):vec2(1e9,-1);\n}\n\n// bounding list\nint BoundList[18]=int[]( \n    Waist,\n    Breast,\n    Head,\n    RightUpperArm,\n    RightLowerArm,\n    RightHand,\n    LeftUpperArm,\n    LeftLowerArm,\n    LeftHand,\n    Hip,\n    RightUpperLeg,\n    RightLowerLeg,\n    RightHeel,\n    RightToe,\n    LeftUpperLeg,\n    LeftLowerLeg,\n    LeftHeel,\n    LeftToe\n);\n\n// bounding capsule radus   \nfloat BoundR[BoneCnt]; \n\nvoid boundRInit()\n{\n    BoundR[Waist]=.5;\n    BoundR[Breast]=1.5;\n    BoundR[Head]=.8;\n    BoundR[RightUpperArm]=.5;\n    BoundR[RightLowerArm]=.5;\n    BoundR[RightHand]=.5;\n    BoundR[LeftUpperArm]=.5;\n    BoundR[LeftLowerArm]=.5;\n    BoundR[LeftHand]=.5;\n    BoundR[Hip]=1.;\n    BoundR[RightUpperLeg]=.5;\n    BoundR[RightLowerLeg]=.5;\n    BoundR[RightHeel]=.5;\n    BoundR[RightToe]=.5;\n    BoundR[LeftUpperLeg]=.5;\n    BoundR[LeftLowerLeg]=.5;\n    BoundR[LeftHeel]=.5;\n    BoundR[LeftToe]=.5;\n}\n\nfloat deStage(vec3 p)\n{\n    float de=p.y;\n    de=min(de, deRoundBox(p-vec3(30,0,0),vec3(1,12,100),.6));\n    de=min(de, deRoundBox(p-vec3(-30,0,0),vec3(1,12,100),.6));\n    vec3 coord=vec3(2,4,0);\n    coord.x+=sin(iTime*2.)*2.;\n    p-=coord;\n    p.z-=-iTime*7.;\n    p.xz=mod(p.xz,10.)-5.;\n    // An alternative to bounding\n    de=min(de,length(p)-2.7);\n    /*\n    p.xy*=rot(iTime);\n    p.xz*=rot(iTime*.5);\n    de=min(de,deStela(p)-.3);\n    */\n    return de;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro;\n    vec3 rd = normalize(vec3(uv,2));\n    camera(ro,rd);\n    \n    float near=maxd;\n    float far=-1.;\n    \n    // model bounding\n    boundRInit();\n    for(int i=0;i<BoundList.length();i++)\n    {\n        int id=BoundList[i];\n        mat4 m=getMat(id,1);\n        vec3 v0=transform(m,boneTail[id]);\n        vec3 v1=transform(m,vec3(0));\n        float r=BoundR[id];\n        vec2 g=intersectCapsule(ro,rd,v0,v1,r+.3);\n        near=min(near,g.x);\n        far=max(far,g.y);\n    }\n    if(far==-1.)far=maxd;\n    fragColor.w=(maxd>near)?1.:0.;\n                \n    // get a rough distance\n    float t=0.;   \n    float offset=.5;\n    for(int i=0;i<80;i++)\n    {\n        float d=deStage(ro+rd*t);\n        if (d<.001)\n        {\n            t-=offset;\n            break;\n        }                \n        if (t>=maxd)\n        {\n            t=maxd;\n            break;\n        }\n        t+=d*1.3; // Extend the ray distance.\n    }\n    fragColor.x=min(near,t);\n    fragColor.y=far;\n    fragColor.z=t;\n}","name":"Buffer C","description":"","type":"buffer"}]}