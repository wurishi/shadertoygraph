{"ver":"0.1","info":{"id":"XdK3Rt","date":"1458478715","viewed":431,"name":"Enter the blob","username":"elzeru","description":"Simple ray-tracer, pseudo ambient occlusion. Colors are a bit bleached, I should work on it.","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracer","pseudoambientocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Enter the blob\n// By el Zeru\n// Space condiments are nice, but scares the girls, so this new shader is a bit less freaky <:o)\n// Basic ray tracer, pseudo ambient occlusion\n\n\nfloat stepize(float a, int nb)\n{\n \ta = float(int(a*float(nb)))/float(nb);   \n    return a;\n}\n\nvec4 cellShading(vec4 inputPixel, int nbColor)\n{\n    vec4 returnImage;\n    if (inputPixel.a < 0.4) returnImage = vec4(0.0,0.0,0.0,1.0);\n    else\n    {\n\treturnImage.x = stepize(inputPixel.x, nbColor);\n    returnImage.y = stepize(inputPixel.y, nbColor);\n    returnImage.z = stepize(inputPixel.z, nbColor);\n    returnImage.a = inputPixel.a;\n    }\n    return returnImage; \n}\n\nvec4 glow(vec2 fragCoord)\n{\n    vec3 color = vec3(texture(iChannel0,fragCoord / iResolution.xy).xyz) +\n        vec3(texture(iChannel0,(fragCoord+vec2(1.0,0.0)) / iResolution.xy).xyz)+\n        vec3(texture(iChannel0,(fragCoord+vec2(-1.0,0.0)) / iResolution.xy).xyz)+\n        vec3(texture(iChannel0,(fragCoord+vec2(0.0,1.0)) / iResolution.xy).xyz)+\n        vec3(texture(iChannel0,(fragCoord+vec2(0.0,1.0)) / iResolution.xy).xyz);\n     color = color*0.2;\n     return vec4(color,1.0);\n        \n}\n\nvec4 lens(vec4 inputPixel, vec2 fragCoord, float amount)\n{\n    vec4 returnImage;\n    \n    vec2 lensShift = vec2(amount*abs(0.5-fragCoord.x/iResolution.x)\n                         ,amount*abs(0.5-fragCoord.y/iResolution.y));\n    vec4 lShift = vec4(texture(iChannel0,(fragCoord-lensShift) / iResolution.xy).xyzx);\n    vec4 rShift = vec4(texture(iChannel0,(fragCoord+lensShift) / iResolution.xy).xyzx);\n   \n    returnImage = vec4(lShift.r, inputPixel.g, rShift.b ,inputPixel.a);\n    \n    return returnImage; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 inputColor = vec4(texture(iChannel0,fragCoord / iResolution.xy).rgba);\n   \n    //inputColor = glow(fragCoord);\n    fragColor = inputColor;\n    //fragColor = lens(inputColor, fragCoord, 5.0);\n    //fragColor = cellShading(fragColor,10);\n    fragColor.xyz = pow(fragColor.xyz,vec3(0.9))*1.3;  \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n\n\n// As the distance field is very distorded, we have to use small ray steps\n// If you have a good idea to avoid this, please tell me !\nconst int PRIM_RAY_IT = 500 ;\nconst float PRIM_RAY_STEP = 0.01;\nconst float EPS_NOR = 0.01;\nconst int AO_it = 6;\n\nstruct Impact {\n\tfloat d;\n    float lum;\n\tvec3 col;\n\tint refl;\n};\n\nstruct Light{\n\tvec3 p;\n    float r;    \n    float lum; \n    vec3 col;\n};\n\n\n\nLight light1 = Light(vec3( 1.0, 1.0, 1.0), 0.000001, 10.0, vec3(1.0,1.0,1.0));\n\n// A min function based on the distance for the Impact structures\nImpact getClosest( Impact p1, Impact p2 )\n{\n    if (p1.d<p2.d)\n    {\n        return p1;\n    }\n    else return p2;\n\n}\n\n//Shapes definition\nfloat dSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat dTerrain(vec3 p)\n{    \n    vec3 p2 = p + vec3(PI/2.0,PI/0.1,0.0);\n    \n    \n    float rotation = iTime*0.2+cos(p.z*1.0);   \n   \n    p2.x = p.x*cos(rotation) + p.y*sin(rotation);\n    p2.y = -p.x*sin(rotation) + p.y*cos(rotation);\n    \n    p2 = p2 + vec3(1.7,1.7,0.0);\n    \n    float peakFrequency = 10.0;\n    float peakAmplitude = 0.4;\n    float rad = cos(p2.x)+sin(p2.x);\n    float rv = cos(rad)+(cos(p2.x)*cos(p2.x)+abs(peakAmplitude*cos(peakFrequency*p2.x)))\n              *(cos(p2.y)*cos(p2.y)+abs(peakAmplitude*cos(peakFrequency*p2.y)))\n              *(-1.2*abs(sin(0.0*iTime+p2.z*1.0))-0.1+abs(peakAmplitude*sin(peakFrequency*p2.z))) +0.5 + 0.1*cos(p2.z)+0.1*cos(iTime*3.0);\n    \n    \n    return rv; \n \n}\n\n//Return information about the closest primitives\nImpact map(in vec3 pos)\n{\n    float terrainDistance = dTerrain(pos);\n    vec3 terrainColour = texture(iChannel0, vec2( pos.x/10.0,pos.y/10.0)).xyz;\n\n    terrainColour = vec3(abs(sin(pos.z*2.3)/PI),abs(sin(pos.z)/PI),abs(cos(pos.z*1.333))/PI);\n    \n    terrainColour = pow(terrainColour, vec3(1.8));\n  \n    Impact terrain = Impact(terrainDistance, 0.0, terrainColour, 0);\n    \n    //Light globe\n    float lightRadius = light1.r;\n\tfloat lightDistance = dSphere( pos-light1.p, lightRadius );\n    Impact light_p1 = Impact(lightDistance,light1.lum, light1.col, 0);\n    Impact closest = getClosest(terrain,light_p1);\n    \n    return closest;\n}\n\n//Compute the normal - Gradient of the distance function\nvec3 getNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( EPS_NOR, 0.0 );\t\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t\tmap(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t\tmap(pos+eps.yyx).d - map(pos-eps.yyx).d );\n    \n\treturn normalize(nor);\n}\n\n//Cast a ray from ro in direction d\nImpact castRay(in vec3 ro, in vec3 inputDir)\n{\t\n    vec3 dir = normalize(inputDir);\n    float t;\n    t = 0.1;\n    Impact impact;\n \tfor (int i = 0; i < PRIM_RAY_IT; i++)\n    {\n        vec3 p = ro+t*dir;\n        impact = map(p);     \n        if(impact.d < t*0.002) {\n            impact.d = t + impact.d;\n            return impact;\n        }\n       \n        t += impact.d*0.05;        \n    }\n    return Impact(0.0,0.0,vec3(0.0,0.0,0.0),-1);\n}\n\nfloat compAO(vec3 p, vec3 norm)\n{\n    float cumulDistToMap = 0.0;\n    vec3 p_AO = p + norm*0.01;\n\n \tfor(int i = 0; i<AO_it; i++)\n    {\n     \tcumulDistToMap +=  (map(p_AO)).d;  \n        p_AO += norm*0.01;\n    }\n    return cumulDistToMap/float(AO_it);\n}\n\n\nfloat BRDF_CookTorrance(vec3 n, vec3 wi, vec3 wo, float eta, float beta, float m, float alpha){ \n    vec3 h = normalize(wi + wo);\n\t// G Term (shadowing)\n\tfloat G1 = 2.*dot(n,h)*dot(n,wo)/dot(wo,h);\n    float G2 = 2.*dot(n,h)*dot(n,wi)/dot(wo,h);\n\tfloat G = min(1., min(G1, G2));\n    \n\t// D term (roughness)\n    alpha = acos(dot(n,h));\n\tfloat D = cos(beta)*exp(-(pow(alpha/m, 2.)));\n    \n    // Fresnel term\n    float c = dot(n,wi);\n    float b = sqrt(pow(eta, 2.) + pow(c, 2.) -1.);\n    float F = 0.5*pow(b-c,2.)/pow(b+c,2.)*(1.0+pow(c*(b+c)-1.,2.)/pow(c*(b-c)+1.,2.));\n \n    return F/PI*D*G/(dot(wo,n)*dot(wi,n));\n    \n}\n\nvec4 tracePath(in vec3 po, in vec3 dir, in vec2 fragCoord)\n{\n    vec3 p = po;\n    vec3 col_base = vec3(1.0);\n    vec4 col = vec4(0.0);\n    vec3 norm = vec3(0.0);  \n\n    float fact_r = 1.0;\n    for (int i = 0; i<1 ;i++)\n        {  \n\t        Impact impact = castRay(p,dir);\n    \t    p = p + dir*impact.d;            \n            \n            vec3 norm = getNormal(p);\n            \n            float ambiantOcc = compAO(p, norm);\n                \n\t\t\tvec3 dirToLight1 = light1.p - p;   \n\t\t\tImpact impactOnLight1 = castRay(p,dirToLight1);                       \n            float e1 = (impact.lum +impactOnLight1.lum * dot(dirToLight1, norm) )/(pow(impactOnLight1.d+0.01,3.0));      \n         \n            float e=e1;\n            \n            vec3 myCol = col_base*(impact.col*5.0)*1.0 + col_base*impact.col*(e+0.1)*5.0;\n\n            myCol *= ambiantOcc*2.0;\n            \n            col_base = impact.col;             \t\n          \t  \t    \n    \t    col.rgb += myCol*fact_r;\n            \n            vec3 newPos = p + dir*impact.d;\n            \n            float distanceToEye = length((po - newPos));\n            \n            col.rgb = mix(col.rgb, vec3(.0)+col.rgb*0.1, smoothstep(0., 40.0, distanceToEye));\n            col.a = abs(dot(norm,normalize(dir)));\n\n            \n            fact_r *=0.8;\n            \n            norm = getNormal(p);\n           \t\n            dir = reflect(dir, norm);   \n        }\n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 positionShift = vec3(sin(iTime)*0.0, cos(iTime)*0.0, iTime*1.0);\n\n    //vec3 eye = 2.0*vec3((iMouse.x-iResolution.x*0.5)/iResolution.x, (iMouse.y-iResolution.y*0.5)/iResolution.y, 0.0) +vec3(0.0, 0.0,-0.2) + positionShift ;   \n    vec3 eye = vec3(0.0, 0.0,-0.2) + positionShift ;   \n    \n    light1.p = positionShift+1.0*vec3(0.0+cos(iTime*2.3)*0.2,-0.0,+cos(1.7*iTime)*0.2)+vec3(0.0,0.0,1.0);\n    \n    float resRatio = iResolution.x/iResolution.y;\n    \n    vec3 pixelPos = vec3(fragCoord.xy/ iResolution.xy*vec2(resRatio,1.0)-vec2(0.5*resRatio,0.5),0.0) + positionShift;\n    \n    vec3 dir = normalize(pixelPos - eye);      \n        \n    dir = normalize (pixelPos - eye);\n        \n    vec4 col = tracePath(eye,dir, fragCoord);                  \n       \n    fragColor = vec4(col);\n    \n}","name":"Buf A","description":"","type":"buffer"}]}