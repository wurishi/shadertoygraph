{"ver":"0.1","info":{"id":"4sdcz8","date":"1517946536","viewed":1005,"name":"Duck never fly","username":"KimchiStorm","description":"Using SDF(Signed Distance Function)s and toon shading, I have created the Duck referred to the reference\n[url=http://i.imgur.com/0kvtMLE.gif] this image [/url]\n\nI referred to basic SDFs and star-field from Íñigo Quílez's articles.\n","likes":46,"published":1,"flags":64,"usePreview":1,"tags":["procedural","raymarching","cartoon","toon","duck"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdSXDz","filepath":"https://soundcloud.com/aomgofficial/jay-park-all-i-wanna-do-prod-by-cha-cha-malone","previewfilepath":"https://soundcloud.com/aomgofficial/jay-park-all-i-wanna-do-prod-by-cha-cha-malone","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by Byumjin Kim (KimchiStorm) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAX_MARCHING_STEPS 128\n#define MAX_SHADOW_STEPS 128\n#define MAX_REFLECTION_STEPS 30\n#define MAX_RAYDISTANCE 1000.0\n#define SHADOW_EPSILON 0.0001\n#define USE_CHEAP_NORMAL 1\n\n#define STEP_SIZE_SCALER 0.8\n\n#define PI 3.1415926535897932384626422832795028841971\n#define TwoPi 6.28318530717958647692\n#define InvPi 0.31830988618379067154\n#define Inv2Pi 0.15915494309189533577\n#define Inv4Pi 0.07957747154594766788\n\n#define DEGREE_TO_RAD 0.01745329251994329576923690768489\n\n#define DEGREE_7_5 0.1308996938995747182692768076366\n#define DEGREE_10 0.17453292519943295769236907684886\n#define DEGREE_12 0.20943951023931954923084289221863\n#define DEGREE_17 0.29670597283903602807702743064313\n#define DEGREE_17_5 0.30543261909900767596164588448558\n#define DEGREE_18_5 0.32288591161895097173088279217039\n#define DEGREE_24 0.41887902047863909846168578443727\n#define DEGREE_30 0.52359877559829887307710723054658\n#define DEGREE_37_5 0.65449846949787359134638403818338\n#define DEGREE_40 0.69813170079773183076947630739545\n#define DEGREE_60 1.0471975511965977461542144610932\n#define DEGREE_80 1.3962634015954636615389526147909\n#define DEGREE_85 1.4835298641951801403851371532157\n#define DEGREE_90 1.5707963267948966192313216916398\n#define DEGREE_95 1.6580627893946130980775062300646\n#define DEGREE_72 1.2566370614359172953850573533118\n#define DEGREE_100 1.7453292519943295769236907684886\n#define DEGREE_140 2.4434609527920614076931670758841\n#define DEGREE_144 2.5132741228718345907701147066236\n#define DEGREE_160 2.7925268031909273230779052295818\n\n#define PLANE 1.0\n#define DUCK_SHADOW 2.0\n\n#define POINT_EYE 100.0\n#define PEAK 101.0\n#define DUCK_FOOT 102.0\n#define DUCK_BODY 103.0\n\n#define SUN 104.0\n#define MOON 105.0\n\n#define PUREDUCK 0.0 // setting this value to 1.0 will show only a duck\n\n//----------------------------------------------- Sky Gradation ------------------------------------------------\nvec3 dawnCol = vec3(0.5, 0.5, 1.0);\nvec3 dawnCol2 = vec3(1.0, 1.0, 0.8);\n\nvec3 midDayCol = vec3(0.52941176470588235294117647058824, 0.81176470588235294117647058823529, 0.90980392156862745098039215686275);\nvec3 midDayCol2 = vec3(0.94901960784313725490196078431373, 1.0, 0.96862745098039215686274509803922);\n\nvec3 twilightCol = vec3(0.09411764705882352941176470588235, 0.06274509803921568627450980392157, 0.21568627450980392156862745098039);\nvec3 twilightCol2 = vec3(0.98431372549019607843137254901961, 0.49411764705882352941176470588235, 0.31372549019607843137254901960784);\n\nvec3 midNightCol = vec3(0.0, 0.0, 0.0);\nvec3 midNightCol2 = vec3(0.0, 0.0, 0.2);\n\n//----------------------------------------------- Noise ------------------------------------------------\n//From iq's procedural planet\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\n\n//----------------------------------------------- Screen Space Noise ------------------------------------------------\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 addStars(vec2 screenSize, vec2 fs_UV)\n{\n    float time = iTime * 80.0;\n    float galaxyClump = (pow(noise(fs_UV.xy * (30.0 * screenSize.x)), 3.0) * 0.5 + pow(noise(100.0 + fs_UV.xy * (15.0 * screenSize.x)), 5.0)) / 3.5;\n    \n    vec3 starColor = vec3(galaxyClump * pow(hash(fs_UV.xy), 1500.0) * 80.0);\n\n    starColor.x *= sqrt(noise(fs_UV.xy) * 1.2);\n    starColor.y *= sqrt(noise(fs_UV.xy * 4.0));\n\n    vec2 delta = (fs_UV.xy - screenSize.xy * 0.5) * screenSize.y * 1.2;  \n    float radialNoise = mix(1.0, noise(normalize(delta) * 20.0 + time * 0.5), 0.12);\n\n    float att = 0.057 * pow(max(0.0, 1.0 - (length(delta) - 0.9) / 0.9), 8.0);\n\n    starColor += radialNoise * min(1.0, att);\n\n    float randSeed = rand(fs_UV);\n\n    return starColor *  (( sin(randSeed + randSeed * time* 0.05) + 1.0)* 0.4 + 0.2);\n}\n\nvec3 calBackground(vec2 fs_UV)\n{\n   float DayOfTime = fract(iTime / 12.0);\n\n   vec3 dawn = mix(dawnCol, dawnCol2, fs_UV.y);\n   vec3 midDay = mix(midDayCol, midDayCol2, fs_UV.y);\n\n\n   float couldH = texture(iChannel3, vec2(fs_UV.x - iTime * 0.1 , fs_UV.y )).x;\n    \n   vec4 clouds = vec4(vec3(couldH), 1.0);\n\n   float cloudAlpha = clouds.x * (pow(fs_UV.y, 4.0));  \n\n   midDay = mix(midDay, clouds.xyz, cloudAlpha);\n\n   vec3 tw = mix(twilightCol, twilightCol2, fs_UV.y);\n\n   vec4 twclouds = clouds;\n   tw = mix(tw, twclouds.xyz * vec3(1.0, 0.7, 0.2), cloudAlpha );\n\n   vec3 midNight = mix(midNightCol, midNightCol2, fs_UV.y);\n\n   midNight += mix(vec3(0.0), addStars(iResolution.xy, fs_UV), fs_UV.y + 0.5);\n\n   if(DayOfTime < 0.0625)\n   {\n       return mix(midNight, dawn, DayOfTime / 0.0625);\n   }\n   else if(DayOfTime < 0.125)\n   {\n       return dawn;\n   }\n   else if(DayOfTime < 0.1875)\n   {\n       return mix(dawn, midDay, (DayOfTime - 0.125) / 0.0625);\n   }\n   else if(DayOfTime < 0.5)\n   {\n       return midDay;\n   }\n   else if(DayOfTime < 0.5625)\n   {\n       return mix(midDay, tw, (DayOfTime - 0.5) / 0.0625);\n   }\n   else if(DayOfTime < 0.625)\n   {\n        return tw;\n   }\n   else if(DayOfTime < 0.6875)\n   {\n       return mix(tw, midNight, (DayOfTime - 0.625) / 0.0625);\n   }\n   else\n   {\n       return midNight;\n   }\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n//----------------------------------------------- Basic SDF ------------------------------------------------\n//From iq's website\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn d1.x >= d2.x ?  d2 : d1;\n}\n\nvec2 opsU( vec2 d1, vec2 d2, float k )\n{\n    return vec2(smin(d1.x, d2.x, k), d1.x > d2.x ?  d2.y : d1.y);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 Blend_Thorn(vec3 q, float k)\n{\n\t//Bend\n\tfloat c = cos(k*q.y);\n    float s = sin(k*q.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(q.x, m*q.yz);    \n}\n\nvec3 Blend_ThornZ(vec3 q, float k)\n{\n\t//Bend\n\tfloat c = cos(k*q.y);\n    float s = sin(k*q.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*q.xy, q.z);    \n}\n\nvec2 boundingSphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n    \n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n//----------------------------------------------- Modeling Duck ------------------------------------------------\n\nvec2 Duck( vec3 p, vec3 ro, vec3 rd )\n{\n\n    // bounding sphere\n    vec2 dis = boundingSphere( vec4(vec3(0.0), 4.0), ro, rd );\n\n    if(dis.y < 0.0)\n    return vec2(1000.0, -1.0);\n\n    float swingSpeed = 10.5;\n    float normalSwing = sin(iTime * swingSpeed);\n\n    //Face\n    vec3 headPos = p;\n    mat4 head_rot = rotationMatrix(vec3(0.0, 0.0, 1.0), sin(iTime * swingSpeed - 0.15) * 0.36);\n    headPos = transpose(mat3(head_rot))* headPos;\n\n    vec2 head = vec2( sdEllipsoid(headPos - vec3(0.0, 2.8, 0.0), vec3(0.85)), DUCK_BODY );   \n\n    //eyes\n    vec2 leftEye = vec2( sdSphere(headPos - vec3(0.45, 3.0, 0.7), 0.07), POINT_EYE );\n    vec2 rightEye = vec2( sdSphere(headPos - vec3(-0.45, 3.0, 0.7), 0.07), POINT_EYE );\n\n    head = opU(head, leftEye);\n    head = opU(head, rightEye); \n\n    //Body\n    vec3 bodyPos = p + vec3(0.0, 2.2, 0.0);\n    mat4 body_rot = rotationMatrix(vec3(0.0, 0.0, 1.0), normalSwing * 0.1);\n\n    bodyPos = transpose(mat3(body_rot))* bodyPos;\n    bodyPos -= vec3(0.0, 2.2, 0.0);\n    vec2 body = vec2( sdEllipsoid(bodyPos - vec3(0.0, 0.0, -0.1), vec3(1.3, 1.7, 1.5)), DUCK_BODY );\n    \n    //Belly\n    mat4 rot_02 = rotationMatrix(vec3(1.0, 0.0, 0.0), DEGREE_60 );\n    vec3 q_02 = transpose(mat3(rot_02))* (bodyPos - vec3(0.0, -0.3, -1.43));\n    q_02 = Blend_Thorn(q_02, 0.2);\n\n    vec2 belly = vec2( sdEllipsoid(q_02, vec3(1.6, 2.6, 1.5)) , DUCK_BODY );\n\n    //LeftWing_00\n    mat4 rot_le00 = rotationMatrix(vec3(0.0, 0.0, 1.0), DEGREE_95 );\n    mat4 rot_le01 = rotationMatrix(vec3(0.0, 1.0, 0.0), -DEGREE_85 ) * rot_le00;\n    mat4 rot_le02 = rotationMatrix(vec3(1.0, 0.0, 0.0), -DEGREE_17 ) * rot_le01;\n    vec3 le_00 = transpose(mat3(rot_le02))* (bodyPos - vec3( 1.4, 0.2, -1.1));\n    le_00 = Blend_Thorn(le_00, -0.1);\n    le_00 = Blend_ThornZ(le_00 - vec3(0.0, 0.0, 0.0), 0.2);\n    vec2 leftWing00 = vec2( sdEllipsoid(le_00 , vec3(0.6, 1.7, 0.3)), DUCK_BODY );\n\n    //LeftWing_01\n    mat4 rot_le10 = rotationMatrix(vec3(0.0, 0.0, 1.0), DEGREE_85 );\n    mat4 rot_le11 = rotationMatrix(vec3(0.0, 1.0, 0.0), -DEGREE_85 ) * rot_le10;\n    mat4 rot_le12 = rotationMatrix(vec3(1.0, 0.0, 0.0), -DEGREE_17 ) * rot_le11;\n    vec3 le_01 = transpose(mat3(rot_le12))* (bodyPos - vec3( 1.45, -0.6, -0.9));\n    le_01 = Blend_Thorn(le_01, -0.2);\n    le_01 = Blend_ThornZ(le_01 - vec3(0.0, 0.0, 0.0), 0.2);\n    vec2 leftWing01 = vec2( sdEllipsoid(le_01 , vec3(0.4, 1.3333, 0.3)), DUCK_BODY );\n\n    //RightWing_00\n    mat4 rot_re01 = rotationMatrix(vec3(0.0, 1.0, 0.0), DEGREE_85 ) * rot_le00;\n    mat4 rot_re02 = rotationMatrix(vec3(1.0, 0.0, 0.0), -DEGREE_17 ) * rot_re01;\n    vec3 re_00 = transpose(mat3(rot_re02))* (bodyPos - vec3( -1.4, 0.2, -0.9));\n    re_00 = Blend_Thorn(re_00, -0.15);\n    re_00 = Blend_ThornZ(re_00 - vec3(0.0, 0.0, 0.0), 0.2);\n    vec2 rightWing00 = vec2( sdEllipsoid(re_00 , vec3(0.6, 1.7, 0.3)), DUCK_BODY );\n\n    //RightWing_01\n    //mat4 rot_re10 = rotationMatrix(vec3(0.0, 0.0, 1.0), DEGREE_TO_RAD * 85.0 );\n    mat4 rot_re11 = rotationMatrix(vec3(0.0, 1.0, 0.0), DEGREE_85 ) * rot_le10;\n    mat4 rot_re12 = rotationMatrix(vec3(1.0, 0.0, 0.0), -DEGREE_17 ) * rot_re11;\n    vec3 re_01 = transpose(mat3(rot_re12))* (bodyPos - vec3( -1.45, -0.6, -0.8));\n    re_01 = Blend_Thorn(re_01, -0.2);\n    re_01 = Blend_ThornZ(re_01 - vec3(0.0, 0.0, 0.0), 0.2);\n    vec2 rightWing01 = vec2( sdEllipsoid(re_01 , vec3(0.4, 1.3333, 0.3)), DUCK_BODY );\n\n    vec3 tailPos = p + vec3(0.0, 2.2, 0.0);\n    mat4 tail_rot = rotationMatrix(vec3(0.0, 0.0, 1.0), sin(iTime * swingSpeed - 1.57) * 0.15);\n\n    tailPos = transpose(mat3(tail_rot))* tailPos;\n\n    tailPos -= vec3(0.0, 2.2, 0.0);\n\n    mat4 rot_tail = rotationMatrix(vec3(1.0, 0.0, 0.0), DEGREE_37_5);\n    tailPos = transpose(mat3(rot_tail))* (tailPos - vec3(0.0, 1.9, -2.9));\n    vec2 tail = vec2( sdEllipsoid(tailPos, vec3(0.1, 0.3, 0.1)) , DUCK_BODY);\n\n    body = opsU(body, belly, 0.2);\n    body = opsU(body, tail, 0.7);    \n\n    body = opU(body, leftWing00);\n    body = opU(body, leftWing01);    \n    body = opU(body, rightWing00);    \n    body = opU(body, rightWing01);\n\n    float legSeed = fract((iTime* swingSpeed) / TwoPi);\n\n    float rightlegSwing = -sin(   pow (fract( iTime* swingSpeed / (TwoPi)) , 2.0 ) * (TwoPi) );\n    \n\n    //RightLeg\n    vec3 legPos = p - vec3(0.0, -2.0, -0.5);\n    vec3 rightLegPos = legPos - vec3(-0.75, 1.5, 0.0);\n\n    mat4 rightLeg_rot = rotationMatrix(vec3(1.0, 0.0, 0.0), rightlegSwing * 1.1 + 0.1);\n\n    rightLegPos = transpose(mat3(rightLeg_rot))* rightLegPos;\n    rightLegPos += vec3(0.0, 1.5, 0.0);\n\n    mat4 rot_rightLeg = rotationMatrix(vec3(0.0, 0.0, 1.0), DEGREE_7_5 );\n    vec3 riLeg = transpose(mat3(rot_rightLeg))* rightLegPos;\n    vec2 rightLeg =  vec2( sdCylinder( riLeg, vec2(0.1, 0.4) ), DUCK_FOOT);\n\n    mat4 rot_rightfoot00 = rotationMatrix(vec3(0.0, 0.0, 1.0), DEGREE_90 );\n    rot_rightfoot00 = rotationMatrix(vec3(0.0, 1.0, 0.0), DEGREE_17_5 ) * rot_rightfoot00;\n    rot_rightfoot00 = rotationMatrix(vec3(1.0, 0.0, 0.0), max(-rightlegSwing , 0.0) ) * rot_rightfoot00;\n\n    vec3 rf_00 = transpose(mat3(rot_rightfoot00))* (rightLegPos - vec3(-0.1, -0.5, 0.0)  );\n    vec3 rf_01 = Blend_Thorn(rf_00, 1.7);\n\n    vec2 rightFoot01 = vec2( sdEllipsoid(rf_01, vec3(0.1, 1.0, 0.3)), DUCK_FOOT );\n    vec2 rightFoot02 = vec2( sdEllipsoid(rf_00 - vec3(0.0, 0.0, 0.8), vec3(0.1, 0.1, 0.4)), DUCK_FOOT );\n\n    vec2 rightFoot = opsU(rightFoot01, rightFoot02, 0.5);\n    rightLeg = opsU(rightLeg, rightFoot, 0.3);\n\n\n    float leftlegSwing = -sin( pow (fract( (iTime* swingSpeed + PI) / (TwoPi)) , 2.0 ) * (TwoPi) );\n\n\n    //LeftLeg    \n    vec3 leftLegPos = legPos - vec3(0.75, 1.5, 0.0);\n\n    mat4 leftLeg_rot = rotationMatrix(vec3(1.0, 0.0, 0.0), leftlegSwing * 1.1 + 0.1);\n\n    leftLegPos = transpose(mat3(leftLeg_rot))* leftLegPos;\n    leftLegPos += vec3(0.0, 1.5, 0.0);\n\n    mat4 rot_leftLeg = rotationMatrix(vec3(0.0, 0.0, 1.0), -DEGREE_7_5 );\n    vec3 leLeg = transpose(mat3(rot_leftLeg))* leftLegPos;\n    vec2 leftLeg =  vec2( sdCylinder( leLeg, vec2(0.1, 0.4) ), DUCK_FOOT);\n\n    mat4 rot_leftfoot00 = rotationMatrix(vec3(0.0, 0.0, 1.0), DEGREE_90 );\n    rot_leftfoot00 = rotationMatrix(vec3(0.0, 1.0, 0.0), -DEGREE_17_5 ) * rot_leftfoot00;\n    rot_leftfoot00 = rotationMatrix(vec3(1.0, 0.0, 0.0), max(-leftlegSwing, 0.0) ) * rot_leftfoot00;\n\n    vec3 lf_00 = transpose(mat3(rot_leftfoot00))* (leftLegPos - vec3(0.1, -0.5, 0.0)  );\n    vec3 lf_01 = Blend_Thorn(lf_00, 1.7);\n\n    vec2 leftFoot01 = vec2( sdEllipsoid(lf_01, vec3(0.1, 1.0, 0.3)), DUCK_FOOT );\n    vec2 leftFoot02 = vec2( sdEllipsoid(lf_00 - vec3(0.0, 0.0, 0.8), vec3(0.1, 0.1, 0.4)), DUCK_FOOT );\n\n    vec2 leftFoot = opsU(leftFoot01, leftFoot02, 0.5);\n    leftLeg = opsU(leftLeg, leftFoot, 0.3);\n\n\n    //peak\n    vec3 peakPos = headPos - vec3(0.0, 2.6, 0.8);\n    vec2 peak_Body = vec2( sdEllipsoid(peakPos, vec3(0.6, 0.1, 0.5)), PEAK );\n    vec2 peak_Up = vec2( sdEllipsoid(peakPos - vec3(0.0, 0.15, 0.015), vec3(0.1, 0.1, 0.2)), PEAK );\n    vec2 peak = opsU(peak_Body, peak_Up, 0.45);\n\n    //shadow\n    vec3 shadowPos = p - vec3(0.0, -2.6, -0.5);\n    vec2 shdowBody = vec2( sdEllipsoid(shadowPos - vec3(normalSwing * 0.3, 0.0, -0.25), vec3(0.9, 0.05, 1.2)), DUCK_SHADOW );\n    vec2 shdowLeft = vec2( sdEllipsoid(shadowPos - vec3(0.9 + leftlegSwing*0.3, 0.0, 0.2 + leftlegSwing * 1.5), vec3(0.5, 0.03, 0.5)), DUCK_SHADOW );\n    vec2 shdowRight = vec2( sdEllipsoid(shadowPos - vec3(-0.9 - rightlegSwing*0.3, 0.0, 0.2 + rightlegSwing * 1.5), vec3(0.5, 0.03, 0.5)), DUCK_SHADOW );\n    \n    vec2 result = head;\n    result = opsU(result, body, 1.5);    \n    result = opU(result, peak);\n    \n    result = opsU(result, rightLeg, 0.2);\n    result = opsU(result, leftLeg, 0.2);\n       \n    result = opU(result, shdowBody);\n    result = opU(result, shdowLeft);\n    result = opU(result, shdowRight);  \n    \n    return result;\n}\n\n//----------------------------------------------- Modeling Land ------------------------------------------------\n\nvec2 stage( vec3 p, vec3 ro, vec3 rd)\n{\n  // bounding sphere\n  vec2 dis = boundingSphere( vec4(vec3(0.0), 41.0), ro, rd );\n\n  if(dis.y < 0.0)\n   return vec2(1000.0, -1.0);\n  \n  return vec2( sdSphere( p, 40.0 ), PLANE);\n\n}\n\n//----------------------------------------------- Modeling Sun and Moon ------------------------------------------------\n\nvec2 SunMoon( vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 center = p; \n\n    mat4 rot = rotationMatrix(vec3(0.0, 0.0, 1.0), fract( (iTime - 4.0) / 12.0) * TwoPi );\n    vec3 sun = transpose(mat3(rot))* (center );\n    sun -= vec3(0.0, 50.0, 0.0);\n\n    vec3 moon = sun + vec3(0.0, 100.0, 0.0);\n    mat4 rotMoon = rotationMatrix(vec3(0.0, 1.0, 0.0), -DEGREE_90 );\n    moon = transpose(mat3(rotMoon))* (moon );\n    moon = Blend_Thorn(moon, 0.7);\n\n    return opU( vec2( sdSphere( sun, 2.0 ), SUN), vec2( sdEllipsoid( moon, vec3(1.0, 2.6, 1.0) ), MOON));\n}\n\n//----------------------------------------------- Unioning SDF ------------------------------------------------\n\nvec2 SDF( vec3 p, vec3 ro, vec3 rd )\n{\n  vec2 result;\n\n  float upDown = sin(iTime * 0.00173) * 0.5;\n\n  vec3 pos = p;\n\n  result = Duck(pos, ro, rd);\n    \n  if(PUREDUCK < 0.5)\n  {\n      result = opU(result, stage(p - vec3(0.0, -42.8, 0.0), ro, rd));\n      result = opU(result, SunMoon(p - vec3(0.0, -42.8, -10.0), ro, rd));      \n  }\n    \n  return result;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n    vec3 cw = normalize(rt-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvec3 getSurfaceNormal(vec3 endPoint, float epsilonParam, vec3 ro, vec3 rd)\n{\n\tfloat epsilon = epsilonParam;\n\n\tvec2 e = vec2(1.0,-1.0)*0.5773*epsilon;\n\treturn normalize( e.xyy*SDF( endPoint + e.xyy, ro, rd).x + \n\t\t\t\t\t  e.yyx*SDF( endPoint + e.yyx, ro, rd).x + \n\t\t\t\t\t  e.yxy*SDF( endPoint + e.yxy, ro, rd).x + \n\t\t\t\t\t  e.xxx*SDF( endPoint + e.xxx, ro, rd).x );\n}\n\nfloat getAO(vec3 endPoint, vec3 normal)\n{\n\tfloat stepLen = 0.12;\n\tfloat AO = 0.0;\n    float att = 1.0;\n\n    float offset = 0.02;\n   \n    for( int i=0; i<5; i++ )\n    {\n        float dist = offset + stepLen*float(i)/4.0;\n        vec3 newEndpoint =  normal * dist + endPoint;\n        vec2 VAL = SDF( newEndpoint, endPoint, normal );\n\n        float gap = (dist - VAL.x);\n        AO += gap*att;        \n\n        att *= 0.95;\n    }\n\n\treturn 1.0 - clamp(3.5 * AO, 0.0, 1.0);\n}\n\n\nvec4 rayMarching(vec3 viewVec, vec3 eyePos, out bool isHit, out vec3 normal, float epsilon, out float AO)\n{\n\tisHit = false;\n\tfloat depth = 0.1;\n\n\tint count = 0;\n\n\tvec3 endPoint;\n\n\tfloat radius = 1.0;\n\tvec3 c = vec3(10.0);\n\n\tint maxRayStep = 128;\n\n\tfor(int i=0; i<maxRayStep; i++)\n\t{\n\t\tendPoint = eyePos + depth * viewVec;\n\n\t\tvec2 result = SDF( endPoint, eyePos, viewVec);\n\n\t\tfloat dist = result.x;\n\n\t\tif(dist < epsilon * depth) \n\t\t{\n\t\t\tisHit = true;       \n\n\t\t\tnormal = getSurfaceNormal(endPoint, epsilon, eyePos, viewVec);\n\t\t\tAO = getAO(endPoint, normal);\n\n\t\t\treturn vec4(endPoint, result.y);\n\t\t}\n\n\t\tdepth += dist * STEP_SIZE_SCALER;// + epsilon * log(float(i) + 1.0);\n\n\t\tif(depth >= MAX_RAYDISTANCE)\n\t\t{\t\t\t\n\t\t\treturn vec4(endPoint, -1.0);\n\t\t}\n\t}\n\n\treturn vec4(endPoint, -1.0);\n}\n\nvoid getSurfaceColor(in float materialFator, vec3 endPoint, out vec4 BasicColor, out float Roughness, float NoV, vec3 backgroundColor )\n{\n\tif(materialFator < 0.0)\n\t{\n\t\tBasicColor = vec4(0.0);\n\t\tRoughness = 1.0;\n\t}    \n\telse if( materialFator < PLANE + 0.5)\n\t{\n            vec3 rotatedPoint = vec3(endPoint);\n\n            rotatedPoint.z += iTime * 10.5;\n\n            vec2 UV = vec2(rotatedPoint.x, rotatedPoint.z);\n\n            BasicColor = mix( texture(iChannel1, UV * 0.2), texture(iChannel2, UV * 0.3),  noise(UV) + 0.1 );\n\n            if(NoV < 0.3)\n                BasicColor = mix(vec4(backgroundColor, 1.0), BasicColor, NoV * 10.0 / 3.0);\n\n            float DayOfTime = fract(iTime / 12.0);            \n            \n            if(DayOfTime < 0.0625)\n            {\n                 BasicColor.xyz *= mix(0.2, 1.0, DayOfTime / 0.0625);\n            }\n            else if( 0.625 <= DayOfTime && DayOfTime < 0.6875)\n            {\n                BasicColor.xyz *= mix(1.0, 0.2, (DayOfTime - 0.625) / 0.0625);\n            }\n            else if( 0.6875 <= DayOfTime )\n            {\n                BasicColor.xyz *= 0.2;\n            }\n            \n            Roughness = 0.05;        \n\t}\n    else if( materialFator < DUCK_SHADOW + 0.5)\n\t{\n\t\tBasicColor = vec4(0.15, 0.15, 0.15, 1.0);\n\t\tRoughness = 1.0;\n\t}\n    else if( materialFator < POINT_EYE + 0.5)\n\t{\n\t\tBasicColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\tRoughness = 0.7;\n\t}\n    else if( materialFator < PEAK + 0.5)\n\t{\n\t\tBasicColor = vec4(1.0, 1.0, 0.0, 1.0);\n\t\tRoughness = 0.3;\n\t}\n    else if( materialFator < DUCK_FOOT + 0.5)\n\t{\n\t\tBasicColor = vec4(1.0, 0.5, 0.0, 1.0);\n\t\tRoughness = 0.3;\n\t}\n    else if( materialFator < DUCK_BODY + 0.5)\n    {\n        BasicColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t\tRoughness = 0.9;\n    } \n    else if( materialFator < SUN + 0.5)\n    {\n        BasicColor = vec4(1.0, 0.7, 0.0, 1.0);\n\t\tRoughness = 0.9;\n    } \n    else if( materialFator < MOON + 0.5)\n    {\n        BasicColor = vec4(1.0, 1.0, 0.0, 1.0);\n\t\tRoughness = 0.9;\n    }   \n\n    BasicColor = clamp(BasicColor, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    vec2  q = fragCoord.xy/iResolution.xy;\n    vec3  ro = vec3(-3.7, 2.83528, 12.453);\n    vec3  ta = vec3(0.0,0.0,0.0);\n    mat3  ca = setCamera( ro, ta, 0.0 );\n    vec3  rd = normalize( ca * vec3(p,-1.8) );\n    \n    float epsilon = 2.0/(iResolution.y) * 0.25;\n\n\tbool isHit = false;\n\n\tvec3 normalVec;\n\tfloat AO = 0.0;\n    \n    vec4 endPoint = rayMarching(rd, ro, isHit, normalVec, epsilon, AO);\n    \n    float materialFator = endPoint.w;\n\n\t\t\n\tvec4 BasicColor = vec4(1.0, 0.5, 0.0, 1.0);\n\tfloat Roughness;\n\n    float NoV = dot(normalVec, -rd);\n    \n    vec3 backgroundColor;\n    \n    if(PUREDUCK < 0.5)\n    \tbackgroundColor = calBackground(uv);\n    else\n        backgroundColor = vec3(0.0);    \n    \n    getSurfaceColor(materialFator, endPoint.xyz, BasicColor, Roughness, NoV, backgroundColor);\n\t\n    vec3 color = backgroundColor;\n    \n    if(materialFator > 0.0)\n    {\n        //ToonShading\n        //edge\n        if( ( materialFator > POINT_EYE - 0.5 )  &&  (NoV < 0.4 || AO < 0.3) )\n        {\n            color = vec3(0.0);\n        }\n        else\n        {\n            color = BasicColor.xyz;\n        }\n    }\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}