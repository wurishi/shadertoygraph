{"ver":"0.1","info":{"id":"7dBSz1","date":"1619739092","viewed":176,"name":"Fluid Sphere","username":"Gallo","description":"Fluid Sphere","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["refraction","water","fluid","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO: check this https://www.shadertoy.com/view/4tB3RK\n//--------------------------------------\n// CONFIG\n//--------------------------------------\n\n//--------------------------------------\n// DEFINES & CONSTANTS\n//--------------------------------------\n\n//utility defines\n#define ZERO   (min(1,0))\n#define X_AXIS vec3(1,0,0)\n#define Y_AXIS vec3(0,1,0)\n#define Z_AXIS vec3(0,0,1)\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n// Materials\n#define MAT_DROPS  101\n\n//--------------------------------------\n// TYPES\n//--------------------------------------\n\n\n//--------------------------------------\n// UTILITY FUNCTIONS\n//--------------------------------------\nmat3 rotation(vec3 axis, float angle)\n{\n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return inverse(mat3(oc * axis.x * axis.x + c, \n                        oc * axis.x * axis.y - axis.z * s,  \n                        oc * axis.z * axis.x + axis.y * s, \n                        oc * axis.x * axis.y + axis.z * s,  \n                        oc * axis.y * axis.y + c,           \n                        oc * axis.y * axis.z - axis.x * s,  \n                        oc * axis.z * axis.x - axis.y * s,  \n                        oc * axis.y * axis.z + axis.x * s,  \n                        oc * axis.z * axis.z + c));\n}\n\n\n//--------------------------------------\n// NOISE FUNCTIONS\n//--------------------------------------\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\n//--------------------------------------\n// BASIC SDFs SHAPES\n// https://iquilezles.org/articles/distfunctions\n//--------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n//--------------------------------------\n// SDF BLEND & DOMAIN REPETITION\n// https://mercury.sexy/hg_sdf/\n//--------------------------------------\n\n//HG\nfloat fOpUnionRound(float a, float b, float r) \n{\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2.0 - vec2(1.0);\n\treturn c;\n}\n\nfloat fOpIntersectionRound(float a, float b, float r)\n{\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r)\n{\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n//IQ\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n//--------------------------------------\n// SDF FIGURES\n//--------------------------------------\nfloat bigDropsPattern(vec3 pos)\n{\n    float r = 1e10;\n    \n    //trunk stem\n    vec3 spherePos = pos - vec3(0.0, 0.4, 0.0);\n    vec3 sphereNormal = normalize(spherePos);\n    r =  sdSphere(spherePos + sphereNormal * noise(sphereNormal * 5.0 + (iTime * 0.6874)) * 0.05, 0.6  );\n   \n    return r;\n}\n\n\n//--------------------------------------\n// MAIN SDF \n//--------------------------------------\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2( 1e10, 0.0 );\n#   define opMin(_v, _m)    res = (_v < res.x) ? vec2(_v, _m) : res\n\n    float drops = bigDropsPattern(pos);\n    opMin(drops, MAT_DROPS);\n\n    return res;\n}\n\n//--------------------------------------\n// RAYMARCHING \n// https://iquilezles.org/articles/rmshadows\n//--------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    // bounding volume\n    //float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = tmin;\n    for( int i=ZERO; i<22; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.00;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 castRay(vec3 ro, vec3 rd)\n{\n    vec3 res = vec3(0.0, 1e10, 0.0);\n    float tmin = 1.0;\n    float tmax = 20.0;\n    float t = tmin;\n    for( int i=0; i<70 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec3(t, h.x, h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n//Biplanar mapping: https://www.shadertoy.com/view/3ddfDj\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n    // transition control\n    m = pow( m, vec2(k/8.0) );\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\nvec3 calcSkyColor(vec3 aDirection)\n{\n    //float t = smoothstep(0.1, 0.6, 0.5f*(aDirection.y + 1.0f));\n    //return mix(vec3(0.05f, 0.05f, 0.1f), vec3(0.4f, 0.6f, 1.0f), t);\n    //vec3 bgr0 = texture( iChannel0, aDirection ).xyz;\n#if 1\n    vec3 bgr1 =   textureLod( iChannel0, aDirection, 0.0 ).xyz  \n                + textureLod( iChannel0, normalize(aDirection * vec3(0.98, 1.0, 1.0) ), 0.0).xyz\n                + textureLod( iChannel0, normalize(aDirection * vec3(1.0, 0.98, 1.0) ), 0.0).xyz\n                + textureLod( iChannel0, normalize(aDirection * vec3(1.0, 1.0, 0.98) ), 0.0).xyz\n                + textureLod( iChannel0, normalize(aDirection * vec3(1.02, 1.0, 1.0) ), 0.0).xyz\n                + textureLod( iChannel0, normalize(aDirection * vec3(1.0, 1.02, 1.0) ), 0.0).xyz\n                + textureLod( iChannel0, normalize(aDirection * vec3(1.0, 1.0, 1.02) ), 0.0).xyz;\n    bgr1 /= 7.0;\n#else\n    vec3 bgr1 = texture( iChannel0, aDirection ).xyz;\n#endif           \n    \n    //return mix(bgr0, bgr1, 0.98);\n    return pow(bgr1, vec3(1.6));\n}\n\nvec4 calcColor(int matId, vec3 pos, vec3 rd, vec3 normal, float ao)\n{\n    vec4 FinalColor = vec4(0.1, 0.1, 0.1, 1);\n    \n    float fresnel = pow( clamp(1.0+dot(normal,rd),0.0,1.0), 1.6 );\n    \n    float roughPattern = biplanar(iChannel2, pos * 1.5 + vec3(iTime * 0.01, iTime * -0.03, iTime * 0.02) , normal, 8.0).b * biplanar(iChannel2, pos.yxz * 3.5, normal.yxz, 8.0).g;\n    //roughPattern *= mix(0.4, 1.0, fresnel);\n    \n    roughPattern = 1.0 - roughPattern;\n    roughPattern = pow(roughPattern, 1.2);\n    roughPattern *= 0.5;\n    \n    \n    normal += (roughPattern * 2.0 - 1.0) * 0.05;\n    rd += (roughPattern * 2.0 - 1.0) * 0.02;\n    //roughPattern = 0.0;\n    fresnel = pow( clamp(1.0+dot(normal,rd),0.0,1.0), 1.6 );\n    \n    vec3 R0 = refract(normal, -rd, -0.2 * mix(0.1, 1.0, fresnel));\n    vec3 R1 = reflect(rd, normal);\n    \n    vec3 bgr_refract = mix(calcSkyColor( R0 ).xyz, texture( iChannel1, R0 ).xyz, 0.0);\n    vec3 bgr_reflect = mix(calcSkyColor( R1 ).xyz, vec3(0.8, 0.8, 0.8), 0.5); // fix this\n    //vec3 bgr1_0 = texture( iChannel1, R ).xyz * mix(0.9, 1.0, fresnel);\n    //vec3 bgr1 = texture( iChannel1, mix(normal, vec3(0.0, 1.0, 0.0), roughPattern) ).xyz;\n    \n    //bgr_refract = pow(bgr_refract, vec3(1.6));\n    //bgr_reflect = pow(bgr_reflect, vec3(1.6));\n    bgr_reflect = smoothstep(0.5, 1.0, bgr_reflect);\n    //bgr_refract = pow(bgr_refract, vec3(1.6));\n    \n    if(matId == MAT_DROPS)\n    {\n        //FinalColor.rgb = (mix(bgr_refract, bgr_reflect, 0.1) * 0.8);\n        FinalColor.rgb = bgr_refract + pow(bgr_reflect.rrr, vec3(2.0)) * 0.02;\n        FinalColor.rgb =  mix(FinalColor.rgb, vec3(0.2, 0.2, 0.22), fresnel * 0.8);\n        //FinalColor.rgb += vec3(0.1, 0.2, 0.1) * mix(0.2, 0.8, roughPattern * fresnel) * 0.6;\n    }\n    \n    return FinalColor;\n}\n\nvec4 render( vec2 uv, in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec4 finalColor = vec4(calcSkyColor(rd), 0.0);\n        \n    vec3 res = castRay(ro, rd);\n    \n    if(res.y < 0.002)\n    {\n        vec3 pos = ro + rd * res.x;\n        vec3 normal = calcNormal(pos);\n        \n        float ao = pow(calcAO(pos, normal), 1.3);\n\n        vec4 color = calcColor(int(res.z), pos, rd, normal, ao);// * mix(0.22, 1.0, ao);\n        \n        //color.rgb = mix(color.rgb, WaterColor.rgb, WaterColor.a * 0.4);\n        \n        finalColor = vec4(color.rgb, res.x);\n         \n        //finalColor.rgb = finalColor.rgb * 0.4 + 0.6 * finalColor.rgb * calcSkyColor(normal);\n        \n        //finalColor = vec4(normal * 0.5 + 0.5, res.x);\n    }\n    \n\n    finalColor.a = 1.0;\n    return finalColor;\n}\n\n\n\n//main raymarching\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    //mo.y += 0.2;\n\tfloat time = 23.5 + iTime*1.5;\n    //float time = 23.5;\n    \n    // camera\t\n   ///vec3 ro = vec3( 1.6*cos(0.1*time + 12.0*mo.x),  1.2 + 3.0*mo.y, 1.6*sin(0.1*time + 12.0*mo.x) );\n   // vec3 ta = vec3( 0.0, 0.14, 0.0 );\n    vec3 ro = vec3( 1.6*cos(0.1*time + 12.0*mo.x),  0.5 + 2.0*mo.y, 1.6*sin(0.1*time + 12.0*mo.x) );\n    vec3 ta = vec3( 0.0, 0.4, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,2.0) );\n\n     // ray differentials (NOT USED YET)\n    vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n    vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n    vec3 rdx = ca * normalize( vec3(px,2.0) );\n    vec3 rdy = ca * normalize( vec3(py,2.0) );\n\n    // render\n    vec4 col = render( p, ro, rd, rdx, rdy );\n    \n    col.rgb = aces_tonemap(col.rgb);\n    \n    fragColor = col;\n} ","name":"Image","description":"","type":"image"}]}