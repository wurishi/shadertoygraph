{"ver":"0.1","info":{"id":"lXfXW2","date":"1710258087","viewed":60,"name":"Simple Raymarching Test 2","username":"Quadrapple","description":"Testing raymarching with different SDFs","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    float radius;\n};\n\nstruct Light {\n    vec3 pos;\n};\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Hit {\n    vec3 pos;\n    float travelled;\n    int steps;\n};\n\nvec3 color = vec3(1.0);\n\nvec3 pointing;\n\nconst int NR_SPHERES = 2;\n\nconst int LIGHT_MARCHES = 100;\nconst int GEOMETRY_MARCHES = 100;\n\nSphere spheres[NR_SPHERES] = Sphere[NR_SPHERES](\n        Sphere(vec3(2.0, 2.0, 3.0), 0.4),\n        Sphere(vec3(1.8, 1.0, 3.0), 0.5));\n        //Sphere(vec3(0.6, -0.2, 4.0), 0.5));\n\nconst Light light = Light(vec3(2.0, 3.0, -3.0));\n\nvec3 rotateAroundAxis(vec3 vec, float ang, vec3 s) {\n    mat3 rot;\n    \n    float cosa = cos(ang);\n    float sina = sin(ang);\n    \n    float mcosa = 1.0 - cosa;\n    \n    rot[0] = vec3(cosa + s.x * s.x * mcosa, s.x * s.y * mcosa - s.z * sina, s.x * s.z * mcosa + s.y * sina);\n    rot[1] = vec3(s.x * s.y * mcosa + s.z * sina, cosa + s.y * s.y * mcosa, s.y * s.z * mcosa - s.x * sina);\n    rot[2] = vec3(s.x * s.z * mcosa - s.y * sina, s.z * s.y * mcosa + s.x * sina, cosa + s.z * s.z * mcosa);\n    \n    return rot * vec;\n}\n\nfloat dist(Sphere sphere, vec3 pos) { \n    const float repeat = 0.0;\n    \n    vec3 modPos1 = vec3(mod(pos.x, repeat), mod(pos.y, repeat), mod(pos.z, repeat));\n    \n    float res = length(cos(pos.xz)) + pos.y;\n    \n    /*\n    vec3 axisDist = abs(modPos1 - sphere.pos);\n    \n    axisDist.x = min(axisDist.x, repeat - axisDist.x);\n    axisDist.y = min(axisDist.y, repeat - axisDist.y);\n    axisDist.z = min(axisDist.z, repeat - axisDist.z);\n    \n    float res = length(axisDist) - sphere.radius;*/\n    \n    //float res = distance(modPos1, sphere.pos) - sphere.radius;\n    return res;\n}\n\nfloat spheresDist(vec3 position) {\n    float minimum = dist(spheres[0], position);\n    \n    for(int i = 1; i < NR_SPHERES; i++) {\n        float d = dist(spheres[i], position);\n        if(d < minimum) {\n            minimum = d;\n        }\n    }\n    \n    return minimum;\n}\n\nvec3 normalSpheres(vec3 position) {\n    float value = spheresDist(position);\n    const float epsilon = 0.001;\n    \n    float deltaX = spheresDist(position + vec3(epsilon, 0.0, 0.0)) - value;\n    float deltaY = spheresDist(position + vec3(0.0, epsilon, 0.0)) - value;\n    float deltaZ = spheresDist(position + vec3(0.0, 0.0, epsilon)) - value;\n    \n    /*float mdeltaX = spheresDist(position + vec3(-epsilon, 0.0, 0.0)) - value;\n    float mdeltaY = spheresDist(position + vec3(0.0, -epsilon, 0.0)) - value;\n    float mdeltaZ = spheresDist(position + vec3(0.0, 0.0, -epsilon)) - value;*/\n\n    return normalize(vec3(deltaX, deltaY, deltaZ)); // - vec3(mdeltaX, mdeltaY, mdeltaZ)));\n}\n\nvec3 getPointing(vec2 angles) {\n    return vec3(-sin(angles.x) * cos(angles.y), sin(angles.y), cos(angles.x) * cos(angles.y));\n}\n\nvec3 fetchCamPos() {\n    return texelFetch(iChannel1, POSITION_ADDR, 0).xyz + pointing * 3.0;\n}\n\nvec2 fetchAngles() {\n    return texelFetch(iChannel1, ORIENTATION_ADDR, 0).xy;\n}\n\nvec3 rayDirection(vec2 uv, vec2 ang) {\n    \n    vec3 hor = vec3(1.0, 0.0, 0.0);\n    vec3 ver = vec3(0.0, 1.0, 0.0);\n    \n    //Rotation matrix\n    mat3 yaw;\n    yaw[0] = vec3(1, 0, 0);\n    yaw[1] = vec3(0, cos(ang.y), -sin(ang.y));\n    yaw[2] = vec3(0, sin(ang.y), cos(ang.y));\n    \n    mat3 pitch;\n    pitch[0] = vec3(cos(ang.x), 0, sin(ang.x));\n    pitch[1] = vec3(0, 1, 0);\n    pitch[2] = vec3(-sin(ang.x), 0, cos(ang.x));\n    \n    mat3 rot = pitch * yaw;\n    \n    //Apply rotation\n    hor = rot * hor;\n    ver = rot * ver;\n    \n    /*ang.x += (uv.x - 0.5 * iResolution.x / iResolution.y);\n    ang.y += (uv.y - 0.5);\n    \n    vec3 p = getPointing(vec2(ang.x, 0.0));\n    \n    vec3 axis = cross(p, vec3(0.0, 1.0, 0.0));\n    vec3 res = rotateAroundAxis(p, ang.y, axis);\n    \n    return normalize(res - pointing);*/\n    \n    return normalize((uv.x - 0.5 * iResolution.x / iResolution.y) * hor + (uv.y - 0.5) * ver - pointing);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 angles = fetchAngles();\n    pointing = getPointing(angles);\n    \n    vec3 camPos = fetchCamPos();\n\n\n    Ray ray = Ray( camPos, rayDirection(uv, angles) );\n\n    bool ifHit = false;\n    spheres[0].pos.x = sin(iTime) + 2.0;\n    \n    float glow = 0.0;\n    for(int i = 0; i < GEOMETRY_MARCHES; i++) {\n        //If close to sphere\n        float d = spheresDist(ray.pos);\n        \n        if(d <= 0.001 && d >= -0.001) {\n            ifHit = true;\n            break;\n        }\n        \n        glow += 1.0 / (pow(d, 8.0) + 100.0);\n        \n        //Else march\n        ray.pos += d * ray.dir * 0.8;\n\n\n    }\n    \n    //Check angle to light source\n    if(ifHit) {\n\n        vec3 toLight = normalize(light.pos - ray.pos);\n        Ray lray = Ray(ray.pos, toLight);\n        float lit = 0.0;\n        \n        //First march\n        lray.pos += lray.dir * 0.001;\n        \n        for(int i = 0; i < LIGHT_MARCHES; i++) {\n            //If close to sphere\n            float d = spheresDist(lray.pos);\n            float dl = length(lray.pos - light.pos);\n            \n            //d = min(d, pow(12.0, 0.5) - d);\n            //dl = min(dl, 4.0 - dl);\n            \n            if(dl <= 0.1) {\n                lit = 1.0;\n                break;\n            }\n            if(d <= 0.0001) {\n                lit = 1.0;\n                break;\n            }\n\n            //Else march\n            lray.pos += min(d, dl) * lray.dir;\n\n        }\n        vec3 normal = normalSpheres(ray.pos);\n        \n        float diffuse = max(dot(toLight, normal) * lit, 0.1);\n        //color = vec3(iMouse.w / iResolution.y, 0.5, 0.5);\n        fragColor = vec4(color * diffuse + vec3(0.0, 0.0, 0.0), 1.0);\n        \n        return;\n    }\n    \n\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const ivec2 POSITION_ADDR = ivec2(0, 0);\n\nconst ivec2 ORIENTATION_ADDR = ivec2(1, 0);\n\nconst ivec2 DIRVECTOR1_ADDR = ivec2(2, 0);\nconst ivec2 DIRVECTOR2_ADDR = ivec2(2, 1);\n\nconst ivec2 POINTING_VECTOR_ADDR = ivec2(2, 2);\n\nconst int KEY_A = 65;\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n\nconst int KEY_SPACE = 32;\nconst int KEY_LSHIFT = 16;\n\nconst int KEY_LEFT = 37;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 rotate(vec3 vec, vec2 ang) {\n    //vec2 ang = angl.xy;\n\n    mat3 yaw = mat3(1.0);\n    yaw[0] = vec3(1, 0, 0);\n    yaw[1] = vec3(0, cos(ang.y), -sin(ang.y));\n    yaw[2] = vec3(0, sin(ang.y), cos(ang.y));\n    \n    mat3 pitch = mat3(1.0);\n    pitch[0] = vec3(cos(ang.x), 0, sin(ang.x));\n    pitch[1] = vec3(0, 1, 0);\n    pitch[2] = vec3(-sin(ang.x), 0, cos(ang.x));\n    \n    return pitch * yaw * vec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if(iTime < 1.0) {\n        if( ivec2(fragCoord) == POSITION_ADDR ) {\n            fragColor.xyz = vec3(1.0, 1.0, 3.0);\n            return;\n        }\n    }\n\n    \n    //Check pixel to write if\n    if( ivec2(fragCoord) == POSITION_ADDR ) {\n        fragColor.xyz = texelFetch(iChannel1, POSITION_ADDR, 0).xyz;\n\n        \n        //Check if pressed\n        //Z\n        if(texelFetch(iChannel0, ivec2(KEY_W, 0), 0).x == 1.0) {\n            fragColor.z += 0.1;\n        }\n        if(texelFetch(iChannel0, ivec2(KEY_S, 0), 0).x == 1.0) {\n            fragColor.z -= 0.1;\n        }\n        //X\n        if(texelFetch(iChannel0, ivec2(KEY_A, 0), 0).x == 1.0) {\n            fragColor.x -= 0.1;\n        }\n        if(texelFetch(iChannel0, ivec2(KEY_D, 0), 0).x == 1.0) {\n            fragColor.x += 0.1;\n        }\n        //Y\n        if(texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).x == 1.0) {\n            fragColor.y += 0.1;\n        }\n        if(texelFetch(iChannel0, ivec2(KEY_LSHIFT, 0), 0).x == 1.0) {\n            fragColor.y -= 0.1;\n\n        }\n        \n    } else if( ivec2(fragCoord) == ORIENTATION_ADDR ) {\n        fragColor = texelFetch(iChannel1, ORIENTATION_ADDR, 0);\n        \n        vec2 offset = vec2(iMouse.x - iMouse.z, -iMouse.w - iMouse.y);\n        \n        if(iMouse.z > 0.0 && iMouse.w < 0.0) {\n            fragColor.xy = fragColor.zw + offset / iResolution.y;\n        } else {\n            fragColor.zw = fragColor.xy;\n        }\n\n    }/* else if( ivec2(fragCoord) == DIRVECTOR1_ADDR ) {\n        vec2 angles = texelFetch(iChannel1, ORIENTATION_ADDR, 0).xy;\n        \n        const vec3 side = vec3(1.0, 0.0, 0.0);\n        fragColor.xyz = rotate(side, angles);\n        \n    } else if( ivec2(fragCoord) == DIRVECTOR2_ADDR ) {\n        vec2 angles = texelFetch(iChannel1, ORIENTATION_ADDR, 0).xy;\n        \n        const vec3 down = vec3(0.0, 1.0, 0.0);\n        fragColor.xyz = rotate(down, angles);\n\n    } else if( ivec2(fragCoord) == POINTING_VECTOR_ADDR ) {\n        vec2 angles = texelFetch(iChannel1, ORIENTATION_ADDR, 0).xy;\n        //angles.x = 0.0;\n        fragColor.xyz = vec3(-sin(angles.x) * cos(angles.y), sin(angles.y), cos(angles.x) * cos(angles.y));\n    }*/\n}","name":"Buffer A","description":"","type":"buffer"}]}