{"ver":"0.1","info":{"id":"wsVyD3","date":"1603932218","viewed":52,"name":"Learning Brief Ray Marching","username":"benjm","description":"Demo of ray marching. Change light with mouse ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// BASIC Ray Marching following along with tutorial \n//by Doug James :\n//https://www.shadertoy.com/view/wdKyD3\nfloat sdSphere(vec3 p, float radius){\n    return length(p) - radius;\n}\n    \n//SDF implementation\nfloat map(in vec3 p){//0 0 -5 is position of sphere\n     return sdSphere(p - vec3(0., 0., -5.), 1.0);\n\n}\n\n//returns t* value of surface or big value in which case we missed\nfloat raymarch(in vec3 ro, in vec3 rd){\n    float t = 0.;\n    for(int i = 0; i< 50; i++){//render between us and the camera\n        vec3 rt = ro + rd*t;\n        float d = map(rt);\n        if(d < 0.01){// if we hit a surface based on signed distance field\n            return t;\n        } else{ //keep marching\n            t += d; //you could do if t > a big value then we missed it as below\n        }\n        if( t > 50.){\n            return -1.;\n        }\n    }\n    return -1.;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    vec3 pix = vec3(uv,0.); //pixel on screen at z = 0\n    \n    vec3 ro = vec3(0., 0., 3.); //camera is 5 units away from screen\n    vec3 rd = normalize(pix - ro); //unit ray at pixel from camera\n    \n    float t = raymarch(ro,rd); //compute distance along ray to surface\n    \n     // Point on surface\n\n    // Time varying pixel color\n    vec3 col = vec3(0.,0.,0.); //background\n    if(t > 0.0) { //i.e it hit a surface\n        vec3 p = ro + rd*t;\n        vec3 N = calcNormal(p);\n               vec3  L = normalize(ro+50.*vec3(mouse.x-0.5, mouse.y-0.5,0.) - p);// light at eye (safe!)\n        float LdotN = dot(L,N);\n\t    col = LdotN * vec3(1.,.3,.3);\n     }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}