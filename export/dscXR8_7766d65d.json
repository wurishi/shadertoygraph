{"ver":"0.1","info":{"id":"dscXR8","date":"1679365508","viewed":42,"name":"cube thingg","username":"kugge","description":"cube thing too complicated there is simpler way to do that + noise is ugly","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Helper functions\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 perspective(float fovy, float aspect, float near, float far) {\n    float f = 1.0 / tan(fovy / 2.0);\n    return mat4(f / aspect, 0.0, 0.0, 0.0,\n                0.0, f, 0.0, 0.0,\n                0.0, 0.0, (near + far) / (near - far), -1.0,\n                0.0, 0.0, 2.0 * near * far / (near - far), 0.0);\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat4(s.x, u.x, -f.x, 0.0,\n                s.y, u.y, -f.y, 0.0,\n                s.z, u.z, -f.z, 0.0,\n                -dot(s, eye), -dot(u, eye), dot(f, eye), 1.0);\n}\n\nfloat intersectCube(vec3 rayOrigin, vec3 rayDir, vec3 cubePos, float cubeSize, mat4 rotation) {\n    // Apply the inverse rotation to the ray\n    vec4 rayOrigin4 = rotation * vec4(rayOrigin - cubePos, 1.0);\n    vec4 rayDir4 = rotation * vec4(rayDir, 0.0);\n    // Calculate the bounds of the cube\n    vec3 cubeMin = vec3(-cubeSize * 0.5);\n    vec3 cubeMax = vec3(cubeSize * 0.5);\n\n    // Calculate the distance to the front and back planes of the cube\n    vec3 tNear = (cubeMin - rayOrigin4.xyz) / rayDir4.xyz;\n    vec3 tFar = (cubeMax - rayOrigin4.xyz) / rayDir4.xyz;\n\n    // Swap values if tNear is greater than tFar\n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n\n    // Find the intersection point with the closest plane\n    float t = max(max(tNear.x, tNear.y), tNear.z);\n\n    // Check if the intersection point is inside the cube\n    vec3 intersectionPos = rayOrigin4.xyz + rayDir4.xyz * t;\n    if (intersectionPos.x < cubeMin.x || intersectionPos.x > cubeMax.x ||\n        intersectionPos.y < cubeMin.y || intersectionPos.y > cubeMax.y ||\n        intersectionPos.z < cubeMin.z || intersectionPos.z > cubeMax.z) {\n        return -1.0;\n    }\n\n    return length(intersectionPos - rayOrigin4.xyz);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize the pixel coordinates and aspect ratio\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera settings\n    vec3 camPos = vec3(0.0, 0.0, -3.0);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n\n    // Calculate view and projection matrices\n    mat4 viewMat = lookAt(camPos, camTarget, camUp);\n    mat4 projMat = perspective(radians(60.0), iResolution.x / iResolution.y, 0.1, 10.0);\n\n    // Compute the ray direction\n    vec3 rayDir = (inverse(viewMat) * inverse(projMat) * vec4(uv, 1.0, 1.0)).xyz;\n\n    // Cube settings\n    vec3 cubePos = vec3(0.0, 0.0, 0.0);\n    float cubeSize = 1.5;\n\n    // Rotate the cube using the iTime uniform\n    float angle = iTime;\n    mat4 rotation = rotationMatrix(vec3(1.0, 1.0, 0.0), angle);\n\n    // Compute the intersection point between the ray and the cube\n    float t = intersectCube(camPos, rayDir, cubePos, cubeSize, rotation);\n\n    // Calculate color based on the intersection point\n    if (t > 0.0) {\n        vec3 intersectionPos = camPos + rayDir * t;\n        vec3 cubeColor = (intersectionPos + cubeSize) / (2.0 * cubeSize);\n        fragColor = vec4(cubeColor, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}