{"ver":"0.1","info":{"id":"wlt3zl","date":"1577319492","viewed":55,"name":"Lern Ray Marching","username":"CJG","description":"Me trying to lern ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// res: https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n//      https://iquilezles.org/articles/distfunctions\n\n#define PI 3.141592\n\n#define NUM_SPHERES 5.0\n\n#define COLOR vec3(1.0)\n\n#define RM_EPSILON 0.0001\n#define RM_T_MAX 10.0\n#define RM_T_MIN 0.01\n\n#define G_EPSILON 0.005\n\n#define AO_SAMPLES 5.0\n#define AO_DELTA 0.09\n\nfloat sdSphere(vec3 p, float s){\n\treturn length(p)-s;\n}\n\nfloat opUnion(float d1, float d2){\n    return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n    float h = clamp(0.5 + 0.5 * (d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat mapSphereRing(vec3 p, float size, float offset) {\n    float d = RM_T_MAX;\n    for(float i = 0.0; i < NUM_SPHERES; ++i){\n        float a = i / NUM_SPHERES * 2.0 * PI + offset;\n        d = opUnion(d, sdSphere(p + vec3(sin(a), cos(a), 0.), size));\n    }\n    return d;\n}\n\nfloat map(vec3 p){\n    float \n    d = mapSphereRing(p + vec3(0.0, 0.0, 1.5), 0.4, iTime);\n    d = opSmoothSubtraction(d, mapSphereRing(p + vec3(0.0, sin(iTime), 1.8), 0.5, -iTime / 7.0), 0.1);\n    d = opSmoothUnion(d, opSmoothUnion(0.6 + p.y, 4.0 + p.z, 1.0), 0.2);\n    return d;\n}\n\nvec3 grad(vec3 p){\n\treturn normalize(vec3(\n    \tmap(p + vec3(G_EPSILON, 0., 0.)) - map(p - vec3(G_EPSILON, 0., 0.)),\n        map(p + vec3(0., G_EPSILON, 0.)) - map(p - vec3(0.0, G_EPSILON, 0.)),\n        map(p + vec3(0., 0., G_EPSILON)) - map(p - vec3(0.0, 0.0, G_EPSILON))\n    ));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n\tfloat ao = 0.0;\n    float factor = 1.0;\n    for(float i = 0.0; i < AO_SAMPLES; ++i){\n        float d = i * AO_DELTA;\n    \tao += (d - map(p + d * n)) / factor;\n        factor *= 2.0;\n    }\n    return 1.0 - ao;\n}\n\nfloat raymarch(vec3 origin, vec3 direction, out vec3 hit){\n\tfor(float t = RM_T_MIN; t < RM_T_MAX;){\n\t\tfloat dis = map(hit = origin + direction * t);\n        if(dis <= RM_EPSILON){\n            return 1.0;\n        }\n        t += dis;\n    }\n\treturn 0.0;\n}\n\nvec3 render(vec2 pos){\n    vec3 origin = vec3(0.0, 0.0, 2.0);\n    vec3 direction = normalize(vec3(pos, 0.0) - origin);\n\n    float hit = raymarch(origin, direction, origin /* out pos */);\n    float ao = ambientOcclusion(origin, grad(origin));\n\n    return COLOR * ao * hit; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord/iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    fragColor.xyz = render(uv);\n}","name":"Image","description":"","type":"image"}]}