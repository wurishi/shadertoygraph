{"ver":"0.1","info":{"id":"dsKXzh","date":"1680732189","viewed":75,"name":"Quentin Brunet INFO4","username":"Signate","description":"INFO4","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["info4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// screen resolution\n#define R iResolution.xy\n\n// minimum distance to objects\n#define DIST_MIN 1.\n\n// maximum distance to objects\n#define DIST_MAX 2000.0\n\n// max number of steps for the ray-marching\n#define RAY_MARCH_STEPS 100\n\n// consider hit if we reach this distance\n#define RAY_MARCH_PRECI 0.001\n\n// for ray direction computation\n#define PI 3.14159265359\n\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Specular {\n    float intensity;\n    float size;\n    float sharpness;\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n    Specular spec; // specular\n    float diff; // diffuse\n};\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h ){\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nSurface add(in Surface s1, in Surface s2){\n    if(s1.t<s2.t)\n        return s1;\n    return s2;\n}\n\n// function random\nvec2 random (vec2 st) {\n    st = vec2(dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)));\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// function of a noise function\nfloat noiseFunction(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(dot(random(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                   dot(random(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n               mix(dot(random(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                   dot(random(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// function that generate perlin noise  in 2D\nfloat perlinNoise(vec2 p, float frequency, float amplitude, int octaves, float lacunarity, float persistence) {\n    float total = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        total += noiseFunction(p * frequency) * amplitude;\n        frequency *= lacunarity;\n        amplitude *= persistence;\n    }\n    return total;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat fbm2(vec2 p) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        r += amp * noise(freq*p);\n        amp *= 0.5; \n        freq *= 2.0;\n    }\n    return r;\n}\n\n//https://www.shadertoy.com/view/MsBBWK\nvec3 marble(float u, float v) {\n    vec2 p = vec2(u, v);\n    vec2 q = vec2(0);\n    vec2 r = vec2(0);\n    q.x = fbm2(p + vec2(1, 1));\n    q.y = fbm2(p + vec2(2, 2));\n    r.x = fbm2(p + 2.0*q + vec2(1, 1));\n    r.y = fbm2(p + 2.0*q + vec2(2, 2));\n    return fbm2(p + 4.0*r) * vec3(0, q.x + r.x, q.y + r.y);\n}\n\nSurface sdMountain(in vec3 p, in bool calculateTexture) { \n\n    float plane = sdSphere(p+vec3(0.0,2005.0,0.0), 2000.0);\n\n    if(plane < DIST_MAX){\n        float mountain = perlinNoise(vec2(p.x, p.z - (iTime * 0.5)), 0.2, 4.0, 5, 2.0, 0.5);\n        // multiply by a factor to make the mountain at the same level as the plane when approaching on the x axis\n        mountain = mountain * smoothstep(0.5, 3.0, abs(p.x)) * - 1.0;\n        plane = plane + mountain;\n    }\n    \n    return Surface(plane, vec3(0.6078, 0.3294, 0.1059), Specular(0.3,0.01,1.0), 0.2);\n}\n\n\n// https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\nmat3 Z(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nvec3 moonTexture(in vec3 p){\n\n    float noise = perlinNoise(p.xy, 0.2, 4.0, 5, 2.0, 0.5)*0.25 + 0.75;\n\n    return vec3(noise);\n}\n\nSurface sdPlanet(in vec3 p, in bool calculateTexture) {\n    vec3 marbleNoise;\n    if(calculateTexture){\n        marbleNoise = marble((p.x+(iTime))/50.0, p.y/50.0);\n    }else {\n        marbleNoise = vec3(0.0);\n    }\n\n    vec3 planetPosition = vec3(0.0, 30.0, 1000.0);\n    Surface planet = Surface(sdSphere(p+planetPosition, 100.0), marbleNoise, Specular(marbleNoise.b,0.1,0.5), 5.0);\n\n    // make a sattelite for  the planet\n\n    // caclulate the sattelite position that rotate around \"planetPosition\" point\n    vec3 sattelitePosition = (p+planetPosition) * rotateZ(iTime - 65.0) - vec3(160.0, 0, 0);\n\n\n    float sphere = sdSphere(sattelitePosition, 20.0);\n    float cratere = sdSphere(sattelitePosition - vec3(0.0,15.0,15.0), 10.0);\n\n    // make the sattelite cratere with an substraction\n    float sattelitePlanet = max(-cratere,sphere);\n\n    vec3 satteliteTexture;\n    if(calculateTexture){\n        // calculate the texture for the sattelite\n        vec3 satteliteTexturePosition = vec3(sattelitePosition.x-(sattelitePosition.x-p.x),sattelitePosition.y-(sattelitePosition.y-p.y),sattelitePosition.z-(sattelitePosition.z-p.z));\n\n        satteliteTexture = moonTexture(satteliteTexturePosition);\n    }else {\n        satteliteTexture = vec3(0.0);\n    }\n\n    Surface sattelite = Surface(sattelitePlanet, satteliteTexture, Specular(0.0,0.0,0.0), 1.0);\n\n    Surface final = add(planet, sattelite);\n\n    return final;\n}\n\nSurface scene(in vec3 p, in bool calculateTexture) {\n    Surface final;\n\n    Surface planeSurface = sdMountain(p, calculateTexture);\n\n    Surface planet = sdPlanet(p, calculateTexture);\n \n    final = add(planet, planeSurface);\n    // final = planeSurface;\n    // final = planet;\n\n    return final;\n}\n\nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d, true);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            s.t = s.t + t;\n            return s;\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0.0, 0.0, 0.0), Specular(0.0,0.0,0.0), 0.0);\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z), false).t-scene(vec3(p.x-e,p.y,p.z), false).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z), false).t-scene(vec3(p.x,p.y-e,p.z), false).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e), false).t-scene(vec3(p.x,p.y,p.z-e), false).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 10.;\n    float d = DP/2.;\n    vec3 ro = vec3(d*cos(6.0*m.x),DP/5.0 - 1.6,d*sin(6.0*m.x) );\n\n    //vec3 ro = vec3(0.,0.,-7.);\n\n    // target point\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + zf*cw);\n\n    return Ray(ro,rd);\n}\n\nvec3 shade(in Surface s,in Ray r) {\n    vec3 n = normalAt(s,r);\n    vec3 l = normalize(vec3(1.,1.,-1));\n    vec3 v = -r.d;\n    vec3 e = reflect(-l,n);\n    \n    vec3 Ka = vec3(0.0);\n    \n    float diff = min(max(dot(n,l + s.diff),0.), 1.0);\n    float spec = pow(max(dot(e,v),0.),s.spec.size * 50.) * s.spec.intensity;\n\n    vec3 color = (Ka + diff);\n    \n    return color * s.c + s.spec.sharpness * spec;\n}\n\n//https://www.shadertoy.com/view/sddSzX\nfloat n11(float p) {\n\treturn fract(sin(p*154.101)*313.019);\n}\n\nfloat n21(vec2 p) {\n\treturn sin(dot(p, vec2(7., 157.)));\n}\n\n\nfloat star(vec3 p) {\n\tfloat z = 1.;\n\tvec2 gv = fract(p.xy*z) - 0.5;\n\tvec2 id = floor(p.xy*z);\n\tgv.x += sin(n21(id)*354.23) * 0.3;\n\tgv.y += sin(n11(n21(id))*914.19) * 0.3;\n\tfloat r = n11(n21(id));\n\treturn 0.1*n11(r)*abs(sin(p.z+r*133.12))*0.4/length(gv)*0.1;\n}\n\nfloat stars(in vec3 p) {\n\tfloat z = 1., m = 0.;\n\tfor(int i=1; i<=6;i++){\n\t\tvec3 t = vec3(0., 0., p.z + iTime * 0.3);\n\t\tz *= 2.;\n\t\tm += star(vec3(p.xy*z, 1.)+t);\n\t}\n\treturn m;\n}\n//https://www.shadertoy.com/view/sddSzX\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n\n    Ray r = camRay(uv);\n    Surface s = march(r);\n\n    vec3 c;\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }else {\n        vec3 sphere =  r.d;\n        c = vec3(stars(sphere));\n    }\n    \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}