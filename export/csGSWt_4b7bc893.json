{"ver":"0.1","info":{"id":"csGSWt","date":"1681749103","viewed":113,"name":"Infinite Regression Circles","username":"darkfox","description":"the great reference: http://roy.red/posts/droste/ and http://roy.red/posts/infinite-regression/\nthanks!!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["glsl","infiniteloop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// reference: http://roy.red/posts/droste/\n// and http://roy.red/posts/infinite-regression/\n// these are great.\n\nconst float PI = 3.14159;\nconst float TAU = 6.28318;\n\n// hsb2rgb.\nvec3 hsb2rgb(float h, float s, float b){\n  vec3 c = vec3(h, s, b);\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat circle(vec2 z){\n  return 1.0 - length(2.0*z-1.0);\n}\n\nvec2 cExp(vec2 z){\n  return exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 cLog(vec2 z){\n  return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 cMul(vec2 z, vec2 w){\n  return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cDiv(vec2 z, vec2 w){\n  return vec2(z.x * w.x + z.y * w.y, z.x * w.y - z.y * w.x)/dot(w, w);\n}\n\nvec2 droste(vec2 z, float patternRatio, float multiplier, vec2 phase, float value) {\n  // 4. Take the tiled strips back to ordinary space.\n  z = cLog(z);\n  // 3. Scale and rotate the strips\n  float scale = log(patternRatio);\n\n  scale *= value;\n\n  // Negate the angle to twist the other way\n  float angle = atan(scale/(2.0*PI));\n\n  //z = cDiv(z, cExp(vec2(0,angle))*cos(angle));\n  vec2 z1 = z;\n  z.x = z1.x + multiplier * (scale/TAU)*z1.y;\n  z.y = z1.y + phase.y - 1.0*(scale/TAU)*z1.x;\n\n  // 2. Tile the strips\n  z.x = mod(z.x - phase.x, scale);\n  // 1. Take the annulus to a strip\n  z = cExp(z);\n  return z;\n}\n\nfloat invScaling(float x, float n){\n  return pow(n, -floor(log(x)/log(n)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) /iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n  vec2 z = uv;\n    \n  vec4 col = vec4(1.0);\n \n  float scaleRatio = 3.0;\n  \n  // This value can be anything, but I've included it so you don't have to deal with large numbers.\n  float value = 20.0;\n\n  float patternExponent = 11.0;\n  float patternRatio = pow(scaleRatio, patternExponent / value);\n\n  z = droste(z, patternRatio, 1.0, vec2(0.4, 0.3) * iTime, value);\n\n  vec2 absZ = abs(z);\n  float scale = invScaling(max(absZ.x, absZ.y), scaleRatio);\n  z *= scale;\n  z = fract(z);\n  col.rgb = vec3(circle(z));\n\n  // center dark.\n  float brightness = pow(length(uv), 0.3);\n  col.rgb *= brightness;\n\n  // overlay.\n  float r = min(1.0, length(uv));\n  vec4 cover = vec4(0.25 + r * hsb2rgb(0.55 + 0.2 * r, 1.0, 0.8), 1.0);\n\n  if(col.r < 0.5){\n    col.rgb = 2.0 * col.rgb * cover.rgb;\n  }else{\n    col.rgb = 2.0 * (col.rgb + cover.rgb - col.rgb * cover.rgb) - 1.0;\n  }\n  col.a = col.a + cover.a - col.a * cover.a;\n\n  fragColor = col * vec4(vec3(col.a), 1.0);\n}","name":"Image","description":"","type":"image"}]}