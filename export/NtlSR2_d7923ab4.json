{"ver":"0.1","info":{"id":"NtlSR2","date":"1626247594","viewed":107,"name":"Isoline Plateaus","username":"koalefant","description":"Isoline-based terrain plateus.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","terrain","isoline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// 2.5D terrain using isolines and Simplex noise.\n// \n\n// https://thebookofshaders.com/10/\nfloat random (vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// Simplex Noise borrowed from: https://www.shadertoy.com/view/wtsBzH\n// https://catlikecoding.com/unity/tutorials/simplex-noise/#a-equalities\nfloat SQUARES_TO_TRIANGLES = (3.0 - sqrt(3.0)) / 6.0;\nfloat TRIANGLES_TO_SQUARES = (sqrt(3.0) - 1.0) / 2.0;\nfloat simplexValue2DPart(vec2 uv, vec2 iuv) {\n    float unskew = (iuv.x + iuv.y) * SQUARES_TO_TRIANGLES;\n    float x = uv.x - iuv.x + unskew;\n    float y = uv.y - iuv.y + unskew;\n    float f = max(0.0, 0.5 - x * x - y * y);\n    return f * f * f * random(iuv);\n}\nfloat simplexValue2D(in vec2 uv) {\n    float skew = (uv.x + uv.y) * TRIANGLES_TO_SQUARES;\n    vec2 skewUV = uv + skew;\n    vec2 iuv = floor(skewUV);\n    // Get bottom left corner\n    float n = simplexValue2DPart(uv, iuv);\n    // Get top right corner\n    n += simplexValue2DPart(uv, iuv + vec2(1.0, 1.0));\n    if (skewUV.x - iuv.x >= skewUV.y - iuv.y) {\n    \t// Get bottom right corner\n        n += simplexValue2DPart(uv, iuv + vec2(1.0, 0.0));\n    } else {\n        // Get top left corner\n        n += simplexValue2DPart(uv, iuv + vec2(0.0, 1.0));\n    }\n    return n * (8.0 * 2.0) - 1.0;\n}\n\n// heightmap field function\nfloat eval(in vec2 uv) {\n    return 0.5-0.5*simplexValue2D(uv * 3.1);\n}\n\n// gradient using central differences\nvec2 grad( in vec2 x ) {\n    vec2 h = vec2( 1.0 / 128.0, 0.0 );\n    return vec2(eval(x + h.xy) - eval(x - h.xy),\n                eval(x + h.yx) - eval(x - h.yx)) / (2.0 * h.x);\n}\n\n// Global water level\nfloat water_level = 0.46;\n\n\n// Based on: https://iquilezles.org/articles/distance\nfloat distance_estimation(float v, float lg, float size_of_pixel, float thickness) {\n    float de = abs(v)/lg;\n    float eps = size_of_pixel;\n    return smoothstep( (thickness - 1.0)*eps, thickness*eps, de );\n}\n\nfloat isoline(float v, float lg, float size_of_pixel, float thickness) {\n    return 1.0 - distance_estimation(v, lg, size_of_pixel, thickness);\n}\n\nfloat interior(float v, float pixel_size) {\n    return smoothstep(0.0, pixel_size, v);\n}\n\n// Simple palette generation base on: https://iquilezles.org/articles/palettes\nvec3 palette(float val, float h, float brightness) {\n    float v = val;\n    vec3 start = vec3(1.0, 0.5, 0.0);\n    vec3 vel = vec3(2.1, 1.3, 1.0);\n    vec3 c = (0.5 - 0.5*cos(start + v*vel));\n    \n    c = c * (1.0 + brightness);    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    // correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    // add vertical motion based on time\n    uv.y += float(iTime) * 0.05;\n    vec3 delta = vec3(1./iResolution.yy, 0);\n    float pixel_size = delta.y;\n    float thickness = float(iResolution.y) / 256.0;\n\n    float v = eval(uv);\n    \n    // number of plateaus\n    int steps = 8;    \n   \n    float grad_len = length(grad(uv));    \n    \n    // background color\n    vec3 col = palette(0.0, v, 0.0);\n    \n    float water_mask = 1.0;\n    for (int i = 1; i < steps; ++i) {\n        float t = float(i) / float(steps);\n        float last_t = float(i - 1) / float(steps);\n        \n        \n        float y_offset = float(i);\n       \n       // Lower part\n        vec2 lower_uv = uv;\n        v = eval(lower_uv);\n        grad_len = length(grad(lower_uv));\n        if (v >= t) {\n           // Lower interior\n           col = mix(col, palette(last_t, v, 0.05), interior(v - t, pixel_size));           \n   \n        }\n        // Lower outline\n        col = mix(col, palette(last_t, v, -0.0625), isoline(v - t, grad_len, pixel_size, thickness * 2.0)); \n\n        // Upper part\n        vec2 upper_uv = uv + vec2(0.0, -1.0/8.0/float(steps));\n        float v2 = eval(upper_uv);\n        \n        \n        grad_len = length(grad(upper_uv));\n        if (v2 >= t) {\n            // Upper interior\n            col = mix(col, palette(t, v2, 0.0), interior(v2 - t, pixel_size));\n        }\n        // Upper outline\n        col = mix(col, palette(t, v2, 0.0 + 0.04), isoline(v2 - t, grad_len, pixel_size, thickness * 0.5)); \n        if (v2 <= t) {\n            // a hack to prevent water from being occluded\n            v = (v + v2) * 0.5;\n            break;\n        }        \n    }\n\n    if (v < water_level) {    \n        // shade underwater in blue\n        float water_interior = interior(v - water_level, pixel_size);\n        col = col + vec3(0.0, 0.3, 0.6) * (1.0 - water_interior) * water_mask;\n        col = mix(col, palette(water_level, water_level, -0.3), isoline(v - water_level, grad_len, pixel_size, thickness * 1.0) * water_mask);\n    \n        // bubbles\n        vec2 bubble_uv = uv * 100.0;\n        float a = smoothstep(0.8, 0.9, simplexValue2D(bubble_uv)*0.5 + 0.5);\n        col += vec3(0.5*(water_level - v) * a);\n    }        \n    \n    // trace outline with mouse (debugging)\n    // float mouse_f = float(iMouse.x)/float(iResolution.x);\n    // col = mix(col, vec3(0.4, 0, 0), isoline(v - mouse_f, grad_len, delta.x, 1.0));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}