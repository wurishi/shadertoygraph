{"ver":"0.1","info":{"id":"cssBDX","date":"1689362075","viewed":113,"name":"Stochastic Blur","username":"mastandunoh_bd","description":"Reduces number of texture reads by Monte-Carlo-ifying Gaussian convolution","likes":2,"published":1,"flags":34,"usePreview":0,"tags":["wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAGIC 43758.5453123\n\n#define MAGIC 43758.5453123\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec3 rand(vec3 stu)\n{\n    vec3 s = vec3(\n      dot(stu, vec3(-127.1, -311.7, 853.29)),\n      dot(stu, vec3(269.5, 183.3, -123.23)),\n      dot(stu, vec3(483.2, -164.3, 219.2))\n    );\n    s = fract(sin(s) * MAGIC); // Make between 0 and 1\n    return s;\n}\n\n// Takes vec2 in [0,1]^2 and from uniform distr. to normal distr.\nvec2 gauss(vec2 seed)\n{\n    float z0 = sqrt(-2.*log(seed.x)) * cos(6.283*seed.y);\n    float z1 = sqrt(-2.*log(seed.x)) * sin(6.283*seed.y);\n    return vec2(z0, z1);\n}\n\n\nconst int numSamples = 4;\nconst float stdev = 0.07;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    // st.x *= iResolution.x / iResolution.y;\n\n\n    vec4 newColor = vec4(0);\n    for (int i = 0; i < numSamples; ++i)\n    {\n        // Generate noise for this pixel + time\n        vec3 seed = vec3(st, 0);\n        seed.z = random(vec2(iTime, float(i)));\n        vec3 noise = rand(seed);\n        \n        // Convert to a normal distribution\n        vec2 offset = gauss(noise.xy) * stdev;\n        \n        // Sample from the offset\n        newColor += texture(iChannel0, st + offset);\n    }\n    \n    \n    newColor /= float(numSamples);\n    vec4 origColor = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    float alpha = 0.95;\n    \n    fragColor = mix(newColor, origColor, alpha);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}