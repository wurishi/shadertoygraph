{"ver":"0.1","info":{"id":"mtdcWr","date":"1709718597","viewed":106,"name":"capsule typeface art rendered","username":"chenxianming","description":"capsule typeface art rendered","likes":4,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","art","typeface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// https://www.shadertoy.com/view/ls3GWS\n// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n// https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n\n/*\n    FXAA or filted fetch pixel to compressed hash scene\n*/\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = texture(tex, uv.zw).xyz;\n    vec3 rgbNE = texture(tex, uv.zw + vec2(1,0)*rcpFrame.xy).xyz;\n    vec3 rgbSW = texture(tex, uv.zw + vec2(0,1)*rcpFrame.xy).xyz;\n    vec3 rgbSE = texture(tex, uv.zw + vec2(1,1)*rcpFrame.xy).xyz;\n    vec3 rgbM  = texture(tex, uv.xy).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        texture(tex, uv.xy + dir * (1.0/3.0 - 0.5)).xyz +\n        texture(tex, uv.xy + dir * (2.0/3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        texture(tex, uv.xy + dir * (0.0/3.0 - 0.5)).xyz +\n        texture(tex, uv.xy + dir * (3.0/3.0 - 0.5)).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    \n    vec3 col;\n    \n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    col = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\n    \n    fragColor = vec4( col, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926\n#define T( s ) fract( iTime * s ) * PI * 4.\n#define rot( a ) mat2( cos( a + vec4( 0, 11, 33, 0 ) ) )\n#define Zoom 1\n#define I iResolution\n#define tl( t ) clamp( t, 0., 1. )\n\n\n\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\n\nvec3 tex( vec2 u ){\n    float k = .2, i;\n    \n    while ( i++ < 20. )\n      u = abs( u ) - .1, u.y = abs( u.y ) - .1 * k,\n      u.y += sin( .2 ) * u.x * .01,\n      u *= rot(i / 3.1415 + (.6 - .4) - i * .01 ),\n      u.x = sin( abs( u.x ) - .015), k *= 1.11;\n     \n    return vec3( smoothstep( .001, abs( length( u ) ) - .09, .03 ) );\n}\n// IQ's segment circular\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n// found some where..\nvec4 sdBezierExtrude(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    // check for colinear\n    //if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < 0.0001)\n    //    return sdLinearSegment(pos, A, C);\n\n\t// first, calc curve T value\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\tfloat t;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        // 1 root\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 _t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n\t\t// 3 roots, but only need two\n\t\tvec3 r1 = d + (c + b * _t.x) * _t.x;\n\t\tvec3 r2 = d + (c + b * _t.y) * _t.y;\n\t\t//t = length(r2.xyz) < length(r1.xyz) ? _t.y : _t.x;\n        t = dot(r2,r2) < dot(r1,r1) ? _t.y : _t.x; // quicker\n        \n    }\n    \n    vec3 _tan = normalize((2.0 - 2.0 * t) * (B - A) + 2.0 * t * (C - B));  // spline tangent\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 binormal = normalize(cross(up, _tan));\n    vec3 _normal = cross(_tan, binormal);\n\n\tvec3 t1 = cross(_normal, _tan); // no need to normalize this?\n\tmat3 mm = mat3(t1, cross(_tan, t1), _tan);\n    pos.xyz = mix(mix(A, B, t), mix(B, C, t), t) - pos; // spline position\n    return vec4(pos.xyz*mm, t);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat B( vec3 p ){\n    float d = .1;\n    \n    vec3 a, b, c, bz;\n    \n    a = vec3( vec2( -0.04, 0.13 ), Zoom );\n    b = vec3( vec2( 0.15, 0.1 ), Zoom );\n    c = vec3( vec2( -0.04, -0.07 ), Zoom );\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    \n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .01 );\n    \n    a = vec3( vec2( -0.04, -0.27 ), Zoom );\n    b = vec3( vec2( 0.18, -0.25 ), Zoom );\n    c = vec3( vec2( -0.04, -0.07 ), Zoom );\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    \n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .01 );\n    \n    a = vec3( vec2( -0.08, 0.13 ), Zoom );\n    b = vec3( vec2( -0.08, -0.27 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .02\n    );\n    \n    return d;\n}\n\nfloat E( vec3 p ){\n    float d = .1;\n    \n    vec3 a, b, c, bz;\n    a = vec3( vec2( -0.11, -0.03 ), Zoom );\n    b = vec3( vec2( -0.01, 0.22 ), Zoom );\n    c = vec3( vec2( 0.13, -0.01 ) , Zoom );\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    \n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .01 );\n    \n    \n    a = vec3( vec2( -0.11, -0.03 ), Zoom );\n    b = vec3( vec2( -0.16, -0.24 ), Zoom );\n    c = vec3( vec2( 0.11, -0.22 ) , Zoom );\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    \n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .00 );\n    \n    a = vec3( vec2( -0.07, -0.05 ), Zoom );\n    b = vec3( vec2( 0.12, -0.05 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .03\n    );\n    \n    return d;\n}\n\nfloat N( vec3 p ){\n    float d = .1;\n    \n    vec3 a, b, c, bz;\n\n    \n    a = vec3( vec2( -0.07, 0.1 ), Zoom );\n    b = vec3( vec2( -0.07, -0.21 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .03\n    );\n    \n    a = vec3( vec2( -0.05, 0.03 ), Zoom );\n    b = vec3( vec2( 0.07, 0.1 ), Zoom );\n    c = vec3( vec2( 0.10, 0.0 ) , Zoom );\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    \n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .02 );\n    \n    a = vec3( vec2( 0.101, -0.05 ), Zoom );\n    b = vec3( vec2(0.102, -0.21 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .024\n    );\n    \n    \n    return d;\n}\n\nfloat C( vec3 p ){\n    float d = .1;\n    \n    vec3 a, b, c, bz;\n    a = vec3( vec2( -0.10, -0.05 ), Zoom );\n    b = vec3( vec2( -0.06, 0.14 ), Zoom );\n    c = vec3( vec2( 0.11, 0.03 ) , Zoom );\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .0 );\n    \n    a = vec3( vec2( -0.10, -0.05 ), Zoom );\n    b = vec3( vec2( -0.12, -0.25 ), Zoom );\n    c = vec3( vec2( 0.11, -0.19 ) , Zoom );\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .001 );\n    \n    return d;\n}\n\nfloat H( vec3 p ){\n    float d = .1;\n    \n    vec3 a, b, c, bz;\n\n    \n    a = vec3( vec2( -0.07, 0.13 ), Zoom );\n    b = vec3( vec2( -0.07, -0.23 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .03\n    );\n    \n    a = vec3( vec2( -0.05, -0.05 ), Zoom );\n    b = vec3( vec2( 0.07, 0.05 ), Zoom );\n    c = vec3( vec2( 0.10, -0.1 ) , Zoom );\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    \n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .02 );\n    \n    a = vec3( vec2( 0.101, -0.154 ), Zoom );\n    b = vec3( vec2(0.102, -0.23 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .025\n    );\n    \n    \n    return d;\n}\n\nfloat A( vec3 p ){\n    float d = .1;\n    \n    vec3 a, b;\n    \n    a = vec3( vec2( -.1, -.25 ), Zoom );\n    b = vec3( vec2( .05, .15 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .0\n    );\n    \n    a = vec3( vec2( .2, -.25 ), Zoom );\n    b = vec3( vec2( .05, .15 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .02\n    );\n    \n    a = vec3( vec2( .0, -.15 ), Zoom );\n    b = vec3( vec2( .12, -.15 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .02\n    );\n    \n    return d;\n}\n\nfloat R( vec3 p ){\n    float d = .1;\n    \n    vec3 a, b, c, bz;\n    \n    a = vec3( vec2( -0.07, 0.13 ), Zoom );\n    b = vec3( vec2( -0.07, -0.23 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .03\n    );\n    \n    a = vec3( vec2( -0.04, 0.00 ), Zoom );\n    b = vec3( vec2( 0.08, 0.12 ), Zoom );\n    c = vec3( vec2( 0.15, 0.04 ) , Zoom );\n\t\t\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    \n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .02 );\n    \n    return d;\n}\n\nfloat Tt( vec3 p ){\n    float d = .1;\n    \n    vec3 a, b, c, bz;\n\n\n    a = vec3( vec2( 0.07, 0.12 ), Zoom );\n    b = vec3( vec2(0.05, -0.15 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .0\n    );\n    \n    a = vec3( vec2( 0.17, 0.03 ), Zoom );\n    b = vec3( vec2( -0.05, 0.015 ), Zoom );\n    \n    d = smin(\n        d,\n        sdCapsule( p, a, b, .05 ),\n        .01\n    );\n    \n    a = vec3( vec2( 0.055, -0.2 ), Zoom );\n    b = vec3( vec2( 0.056, -0.27 ), Zoom );\n    c = vec3( vec2( 0.20, -0.21 ) , Zoom );\n    \n    bz = sdBezierExtrude(p, a, b, c).xyz;\n    \n    d = smin( d, sdTorus(bz, vec2( .0, .05 ) ), .02 );\n    \n    return d;\n}\n\n\nfloat slogan(vec3 p)\n{\n    \n    float d = .1;\n    \n    p.x += 1.5;\n    \n    d = min( d, B( p ) );\n    \n    p.x -= .4;\n    d = min( d, E( p ) );\n    \n    p.x -= .42;\n    d = min( d, N( p ) );\n    \n    p.x -= .43;\n    d = min( d, C( p ) );\n\n    p.x -= .4;\n    d = min( d, H( p ) );\n    \n    p.x -= .41;\n    d = min( d, A( p ) );\n    \n    p.x -= .49;\n    d = min( d, R( p ) );\n    \n    p.x -= .4;\n    d = min( d, Tt( p ) );\n    \n    return d;\n}\n\nfloat map( vec3 p ){\n    \n    return smin(\n        max( p.z - .94, -slogan( p ) ),\n        slogan( p ),\n        .09\n    );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n\n\nvec4 raymarching( vec3 ro, vec3 rd ){\n    \n    float t = 0.,\n          dist = 0.;\n          \n    vec3 lig = normalize(vec3(.57703));\n\n    lig.zy *= rot( iTime + ( 1. - tl( iTime * 2. ) ) );\n    vec3 hal = normalize(lig - rd);\n    \n    vec3 pos = vec3( 0. );\n    float spe;\n\n    for(  int i = min(0, iFrame); // credited @FabriceNeyret2\n        i <  (24 + ((iTime > 3. && iTime < 6.) ? int(iTime*10.) : 0) );\n    i++ ){\n        \n        pos = ro + rd * t;\n        \n        pos.zy *= rot( ( 1. - tl( iTime * .5 ) ) * .5 );\n        pos.xy *= rot( ( 1. - tl( iTime * .5 ) ) * .35 );\n        \n        pos.y += .3;\n        pos.zy *= rot( PI * .15 );\n        pos.yx *= rot( PI * .02 );\n        \n        dist = map( pos );\n\n        if( t > 1e3 ){\n            break ;\n        }\n        \n        t += dist;\n    }\n    \n    \n    if( dist < 1e-3 ){\n        \n        vec4 ou;\n        \n        vec3 nor = calcNormal(pos);\n        \n        vec3 ca = vec3(.4, .7, .3);\n\n        float dif = clamp(dot(nor, ca), 0.0, 1.0);\n\n        spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 5.0) * .2;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n\n        ou += vec4(\n            spe + vec3( 0.1 ) * amb + vec3( 0.17, 0.78, 0.98 ),\n            clamp( 1. - smoothstep( 0., .1, slogan( pos ) ), 0., 1. )\n        );\n        \n        \n        if( map( pos ) == slogan(pos) ){\n            ou += texture( iChannel0, reflect( nor, ro ) ) * .15;\n            \n            float dbg = tex( mod( ro.xy, 2. ) - 1. ).r;\n            \n            if( dbg < .8 )\n                dbg = 0.;\n            else\n                dbg = 1.;\n                \n            ou -= dbg * .02;\n            \n            ou += spe;\n        }else{\n            float dbg = tex( mod( ro.xy, 2. ) - 1. ).r;\n            \n            if( dbg < .8 )\n                dbg = 0.;\n            else\n                dbg = 1.;\n        \n            ou.rgb += dbg * .015;\n        }\n        \n        ou.a = spe;\n        \n        return ou;\n    }\n        \n    return vec4( vec3( 0.17, 0.78, 0.98 ), spe );\n}\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n\n    vec2 u = (V+V-I.xy) / min( I.x, I.y );\n    \n    if( iTime <= 6. ){\n        vec3 col = vec3( 0.17, 0.78, 0.98 );\n        vec3 ro = vec3( 0., 0., -1. );\n        vec3 rd = vec3( u * ( .5 + .5 * ( tl( iTime * .5 ) ) ), 1. );\n        vec4 hits = raymarching( rd, ro );\n        col = hits.rgb;\n        col = mix( col, vec3( 0.17, 0.78, 0.98 ) * .1, hits.a );\n\n        U = vec4(col,1.0);\n        return ;\n    }\n    \n    U = texture( iChannel1, V / iResolution.xy );\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}