{"ver":"0.1","info":{"id":"7t3SRf","date":"1639659452","viewed":57,"name":"HellFusion","username":"amousa","description":"Ray Marching demonstrating SDF manipulation for soft merging between spheres and hard merging between mirror planes.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Amousa\n#define LIGHT 0\n#define SPHERE 1\n#define PLANE 2\n#define CUBE 3\n\nvec2 UV;\n\nstruct Primitive\n{\n  int PRIMITIVE_TYPE;\n  vec3 color;\n  float sdvalue;\n};\n\n\nPrimitive unionshapehard(Primitive prim_1,Primitive prim_2)\n{\n  if(prim_1.sdvalue<prim_2.sdvalue) {return prim_1;}\n  return prim_2;\n}\n\n\nPrimitive unionshape(Primitive prim_1,Primitive prim_2)\n{\n  \n    Primitive shape;\n    float k = 4.56;\n    float h = clamp( 0.5 + 0.5*(prim_2.sdvalue-prim_1.sdvalue)/k, 0.0, 1.0 );\n    shape.PRIMITIVE_TYPE = int(mix( float(prim_2.PRIMITIVE_TYPE), float(prim_1.PRIMITIVE_TYPE), h ) - k*h*(1.0-h));\n    shape.sdvalue =  mix( prim_2.sdvalue, prim_1.sdvalue, h ) - k*h*(1.0-h); \n    shape.color =  mix( prim_2.color, prim_1.color, h ) - k*h*(1.0-h); \n    return shape;\n}\n\nPrimitive sdfplane(vec3 position,vec4 planenormal)\n{\n Primitive PlanePrim;\n   float displacement = sin(0.3 * position.x) * cos(-1.0 *sin(iTime) * position.y) * sin(0.9* position.z) * 0.25;\n\n PlanePrim.PRIMITIVE_TYPE = 2;\n PlanePrim.sdvalue =  dot(position,planenormal.xyz)+planenormal.w+displacement;\n PlanePrim.color = vec3(0.0,0.1,0.4);\n return PlanePrim;\n}\n\nPrimitive sdfSphere(vec3 p,vec3 sp,bool islight)\n{\n   Primitive SpherePrim;\n  float displacement = sin(8.0 * p.x) * cos(-8.0 * p.y) * sin(8.0* p.z) * 0.25;\n   SpherePrim.PRIMITIVE_TYPE = 1;\n   SpherePrim.sdvalue = length(p-sp)-3.0 + displacement;\n   if(islight) {SpherePrim.PRIMITIVE_TYPE=0;SpherePrim.sdvalue = length(p-sp)-1.0; }\n   if(islight) {   SpherePrim.color = vec3(0.5,0.0,0.0);}\n   else {SpherePrim.color = vec3(1.0,0.4,0.2);}\n  return SpherePrim;\n}\n\nfloat sdfCube(vec3 p)\n{\n  vec3 vecdist = abs(p)-vec3(3.0); \n  \n return length(max(vecdist,vec3(0.0))) + min(max(vecdist.z,max(vecdist.x,vecdist.y)),0.0);\n}\n\n\nvec3 getplanenormal(vec3 position,vec4 planedata)\n{\n  vec2 epi =vec2(0.001,0.0);\n  vec3 normal;\n  vec3 color;\n  normal.x = sdfplane(position+epi.xyy,planedata).sdvalue - sdfplane(position-epi.xyy,planedata).sdvalue;\n  normal.y = sdfplane(position+epi.yxy,planedata).sdvalue - sdfplane(position-epi.yxy,planedata).sdvalue;\n  normal.z = sdfplane(position+epi.yxx,planedata).sdvalue - sdfplane(position-epi.yxx,planedata).sdvalue;\n  return normalize(normal);\n}\n\nvec3 getnormal(vec3 position)\n{\n  vec2 epi =vec2(0.001,0.0);\n  vec3 normal;\n  vec3 color;\n  normal.x = sdfSphere(position+epi.xyy,vec3(1),false).sdvalue - sdfSphere(position-epi.xyy,vec3(1),false).sdvalue;\n  normal.y = sdfSphere(position+epi.yxy,vec3(1),false).sdvalue - sdfSphere(position-epi.yxy,vec3(1),false).sdvalue;\n  normal.z = sdfSphere(position+epi.yxx,vec3(1),false).sdvalue - sdfSphere(position-epi.yxx,vec3(1),false).sdvalue;\n  return normalize(normal);\n}\n\nvec3 raymarch(vec3 camerapos, vec3 raydir,vec3 lightposition)\n{\n  vec3 ro = camerapos;\n  vec3 color_1,color_2,color_3;\n  vec3 rd = raydir;  \n  float overalldist;\n  float total_distance_traveled=0.0;\n  vec4 planedata = vec4(0.3*sin(iTime),1.0,0.0,7.0);\n    for(int i=0;i<500;i++)\n    {\n       //\n       vec3 currentposition = ro + rd*total_distance_traveled;\n       float distancetocube = sdfCube(currentposition);\n       vec3 color;\n       Primitive  plane  = sdfplane(currentposition,planedata);\n       Primitive  plane_2  = sdfplane(currentposition,planedata*vec4(1,-1,1,1));\n       Primitive  light  = sdfSphere(currentposition,lightposition,true);\n       Primitive  light_2  = sdfSphere(currentposition,-lightposition*1.75,true);\n       Primitive  light_3  = sdfSphere(currentposition,lightposition*2.32,true);\n       Primitive  Sphere = sdfSphere(currentposition,vec3(1),false);\n       Primitive  shape  = unionshapehard(plane_2,unionshapehard(unionshape(light_3,(unionshape(light_2,unionshape(Sphere,light)))),plane));\n       if(shape.sdvalue<0.001)\n       {\n         if(shape.PRIMITIVE_TYPE == 0) {return shape.color + vec3(0.4,0.05,0.06);}\n         else if (shape.PRIMITIVE_TYPE == 1  || shape.PRIMITIVE_TYPE == 2) \n         {\n          float lightintensity=0.0;\n         vec3 lightdirection = normalize(lightposition-currentposition);\n         vec3 light_2direction = normalize(-lightposition*1.75-currentposition);\n         vec3 light_3direction = normalize(lightposition*1.75-currentposition);\n         if(shape.PRIMITIVE_TYPE == 1) { lightintensity = dot(lightdirection,getnormal(currentposition))+dot(light_2direction,getnormal(currentposition))+dot(light_3direction,getnormal(currentposition));          return vec3(lightintensity*shape.color*vec3(0.6,0.2,0.1)+ vec3(0.4,0.05,0.06));}\n         if(shape.PRIMITIVE_TYPE == 2) { lightintensity = dot(lightdirection,getplanenormal(currentposition,planedata));          return vec3(lightintensity*shape.color);}\n         }\n       }\n       \n       if(total_distance_traveled>500.0)\n       { break;}\n       \n       \n       total_distance_traveled += shape.sdvalue;\n    }\n    \n    return vec3(0.0);\n\n}\n\n\n\nvec3 raydirection(vec3 up,vec3 look,vec2 uv)\n\n{\n   float focallength = 1.0;\n   vec3 cameraforward = look;\n   vec3 cameraright = normalize(cross(cameraforward,up));\n   vec3 cameraup = normalize(cross(cameraright,cameraforward));\n   return normalize(uv.x*cameraright + uv.y*cameraup + focallength*cameraforward);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    UV = uv;\n    uv = uv-vec2(0.5);\n    \n    vec3 lightposition = vec3(3.0*sin(iTime),1,3.0*cos(iTime));\n    \n    vec3 CameraPosition = mix(vec3(1.0,2.0,-15.0),lightposition,0.8)*vec3(5.0,5.0,8.0);\n    \n    CameraPosition = mix(CameraPosition,vec3(0,0,0),0.1);\n    \n    vec3 up = vec3(0,1,0);\n    \n    vec3 target = vec3(1);\n    \n    vec3 look = normalize(target-CameraPosition);\n    \n    vec3 raydir = raydirection(up,look,uv);\n    \n    vec3 color = raymarch(CameraPosition,raydir,lightposition);\n    \n    fragColor = vec4(color,1);\n    \n    \n}","name":"Image","description":"","type":"image"}]}