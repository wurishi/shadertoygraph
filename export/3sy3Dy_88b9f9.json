{"ver":"0.1","info":{"id":"3sy3Dy","date":"1570820027","viewed":236,"name":"Equipotential charge lines","username":"Zotho","description":"Origin: https://www.shadertoy.com/view/XlfSRj\nThanks for: @stormoid (twitter)","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","vectorfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//2D Vector field visualizer by nmz (twitter: @stormoid)\n//Added moving charges and equipotential lines (@allexev)\n#define u_time iTime\n#define pi 3.1415926535897932384626433832795\n\nconst float arrow_density = 1.7;\nconst float arrow_length = 0.5;\n\n//---------------Field to visualize defined here-----------------\nvec2 field(in vec2 p)\n{\n    return vec2(sin(p.x+sin(p.y)+u_time), sin(p.x+cos(p.y)));\n}\n\nvec3 fieldGrav(vec2 p) {\n    float time_coeff = 2.;\n    vec3 s = vec3(0.);\n    float r = 3.5+sin(u_time/10.*time_coeff);\n    float phi = -3.5+u_time/20.*time_coeff;\n    float mk = 1.4;\n    const int n_iter = 7;\n    for (int i = 0; i < n_iter; i++) {\n        float fi = float(i) / float(n_iter) * 2. * pi;\n        vec2 pos = vec2(r*cos(fi+phi+sin(u_time/10.*time_coeff)), r*sin(fi+phi));\n        float d = distance(pos, p);\n        float m = mk * sin(fi + pi / 10.);\n        vec2 a = m * (pos - p) / pow(d, 3.);\n        s += vec3(a, sign(m) * length(a));\n    }\n    return s;\n}\n//---------------------------------------------------------------\n\nfloat segm(in vec2 p, in vec2 a, in vec2 b) //from iq\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h)*30.;\n}\n\nfloat fieldviz(in vec2 p, vec2 t)\n{\n    vec2 ip = floor(p*arrow_density) / arrow_density + .5/arrow_density;   \n    float m = pow(length(t), .5) * (arrow_length/arrow_density);\n    vec2 b = normalize(t)*min(m, .3);\n    float rz = segm(p, ip, ip+b);\n    vec2 prp = (vec2(-b.y, b.x));\n    rz = min(rz,segm(p, ip+b, ip + b*.65 + prp*.3));\n    return clamp(min(rz,segm(p, ip+b, ip + b*.65 - prp*.3)), 0., 1.);\n}\n\nfloat equipotentialLines(float fld)\n{\n    float a = 0.;\n    const int n_lines = 29;\n    for (int i = 0; i < n_lines; i++) {\n        float f = float(i) - float(n_lines + 1) / 2.;\n        f *= 0.1;\n        float range = 111./(abs(f) + .4) - 11.;\n    \ta = max(a, 1. - clamp(abs(fld - f) * range, 0., 1.));\n    }\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = gl_FragCoord.xy / iResolution.xy - 0.5;\n\tp.x *= iResolution.x / iResolution.y;\n    p *= 10.;\n    vec3 fld = fieldGrav(p);\n    vec3 col = vec3(0.);\n    float fviz = fieldviz(p, fld.xy);\n    col = max(col, 1. - fviz*vec3(1.));\n    col = max(col , equipotentialLines(fld.z));\n    col.rb = max(col.rb, vec2(-fld.z, fld.z));\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}