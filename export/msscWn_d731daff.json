{"ver":"0.1","info":{"id":"msscWn","date":"1686734387","viewed":204,"name":"The Mysterious Planet","username":"DrElectry","description":"3d planet using raymarching and perlin noise","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching3dmystic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uniform vec2 u_resolution;\nuniform float u_time;\n\nconst float EPSILON = 0.001;\nconst float MAX_DIST = 1800.0;\nconst float STEPS = 580.0;\nconst float PI = acos(-1.0);\nconst int NUM_OCTAVES = 7;\n\n\nfloat noise(vec2 p) {\n    return sin(p[0]) + sin(p[1]);\n}\n\n\nmat2 rot(float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\n\nfloat fbm(vec2 p) {\n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 1.95;\n    for( int i = 0; i < NUM_OCTAVES; i++) {\n        res += amp * noise(p);\n        amp *= 0.5;\n        p = p * freq * rot(PI / 4.0) - res * 0.4;\n    }\n    return res;\n}\n\n\nfloat getWater(vec3 p) {\n    float d = p.y + 5.0 * sin(iTime) + 80.0;\n    d += 6.0 * noise(p.xz * 0.02 + 1.0 * iTime);\n    return d;\n}\n\n\nfloat getTerrain(vec3 p) {\n    float d = 0.;\n    d -= 130.0 * noise(p.xz * 0.002);\n    d += 80.0 * noise(p.xz * 0.01) + 80.0;\n    d += 20.0 * fbm(p.xz * 0.1) * noise(p.xz * 0.01) + 20.0;\n    d -= 2.0 * sin(0.6 * d);\n    d += p.y + 2.0;\n    return d * 0.1;\n}\n\n\nfloat map(vec3 p) {\n    float d = 0.0;\n    d += getTerrain(p);\n    return min(d, getWater(p) + d);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    for (float i = 0.; i < STEPS; i++) {\n        vec3 p = ro + dist * rd;\n        float hit = map(p);\n        if (abs(hit) < EPSILON) break;\n        dist += hit;\n        if (dist > MAX_DIST) break;\n    }\n    return dist;\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(map(p)) - vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n    return normalize(n);\n}\n\n\nfloat getAmbientOcclusion(vec3 p, vec3 normal) {\n    float occ = 0.0;\n    float weight = 0.4;\n    for (int i = 0; i < 8; i++) {\n        float len = 0.01 + 0.02 * float(i * i);\n        float dist = map(p + normal * len);\n        occ += (len - dist) * weight;\n        weight *= 0.85;\n    }\n    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < 8; i++) {\n        float hit = map(p + lightPos * dist);\n        res = min(res, hit / (dist * lightSize));\n        if (hit < EPSILON) break;\n        dist += hit;\n        if (dist > 30.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\nvec3 lightPos = vec3(250.0, 100.0, -300.0) * 4.0;\n\nvec3 getLight(vec3 p, vec3 rd) {\n    vec3 color =vec3(1);\n    vec3 l = normalize(lightPos - p);\n    vec3 normal = getNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, normal);\n\n    float diff = 0.85 * max(dot(l, normal), 0.0);\n    float specular = 0.4 * pow(clamp(dot(r, v), 0.0, 1.0), 10.0);\n    float ambient = 0.2;\n\n    float shadow = getSoftShadow(p, lightPos);\n    float occ = getAmbientOcclusion(p, normal);\n    return  (ambient * occ + (specular * occ + diff) * shadow) * color;\n}\n\n\nmat3 getCam(vec3 ro, vec3 lookAt) {\n    vec3 camF = normalize(vec3(lookAt - ro));\n    vec3 camR = normalize(cross(vec3(0, 1, 0), camF));\n    vec3 camU = cross(camF, camR);\n    return mat3(camR, camU, camF);\n}\n\n\nvec3 getSky(vec3 p, vec3 rd) {\n    vec3 col = vec3(0.0);\n    float sun = 0.01 / (1.0 - dot(rd, normalize(lightPos)));\n    col = mix(col, vec3(0.3), 2.0 * fbm(vec2(20.5 * length(rd.xz), rd.y)));\n    col += sun * 0.1;\n    return col;\n}\n\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0);\n    vec3 ro = vec3(220.0, 50.0, 220.0);\n    ro.xz *= rot(iTime * 0.15);\n    vec3 lookAt = vec3(0, 1, 0);\n    vec3 rd = getCam(ro, lookAt) * normalize(vec3(uv, 2.0));\n\n    float dist = rayMarch(ro, rd);\n    vec3 p = ro + dist * rd;\n\n    if (dist < MAX_DIST) {\n        col += getLight(p, rd);\n        // fog\n        col = mix(getSky(p, rd), col, exp(-0.0000007 * dist * dist));\n\n    } else {\n        col += getSky(p, rd);\n    }\n    return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 color = render(uv);\n\n    fragColor = vec4(pow(color, vec3(1.5)), 1.0);\n}","name":"Image","description":"","type":"image"}]}