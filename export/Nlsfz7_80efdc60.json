{"ver":"0.1","info":{"id":"Nlsfz7","date":"1651072281","viewed":165,"name":"Raytracing Multiple Lightsources","username":"Topxic","description":"Simple raytracing demo","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","refraction","light","cubemap","glass","mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"TraceNode trace_nodes[MAX_STACK_SIZE];\nint trace_size;\n#define push(X) trace_nodes[trace_size++] = (X)\n#define pop() trace_nodes[--trace_size]\n\n// https://www.shadertoy.com/view/3djyWW\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x+y)*(y*y-x)+x)/2.14e9;\n}\n\nvec3 randvec(float seed) {\n    float h1 = hash(seed, seed);\n    float h2 = hash(h1, seed);\n    float h3 = hash(h2, seed);\n    return vec3(h1,h2,h3);\n}\n\nvec3 cast_shadow_ray(RayHit rh) {\n    // Apply ambient lightning for every object\n    vec3 mat_color = materials[rh.material_id].color;\n    vec3 color = AMBIENT_INTENSITY * AMBIENT_LIGHT_COLOR * mat_color;\n    vec3 pos = rh.pos + EPS * rh.n;\n    // Cast ray to each light source\n    for(int i = 0; i < LIGHT_COUNT; ++i) {\n        Light light = lights[i];\n        vec3 l = normalize(light.pos - pos);\n        Ray l_ray = Ray(pos, l);\n        bool hit = false;\n        // Check if sphere is between light and position\n        for(int j = 0; j < SPHERE_COUNT; ++j) {\n            Sphere sphere = spheres[j];\n            float dist = intersect(l_ray, sphere);\n            if(dist >= 0.f) {\n                hit = true;\n                break;\n            }\n        }\n        if(!hit) {\n            float dist = distance(light.pos, pos);\n            float intensity = light.intensity / (dist * dist);\n            vec3 diffuse = intensity * clamp(dot(rh.n, l), 0.f, 1.f) * light.color * mat_color;\n            color += diffuse;\n        }        \n    }    \n    return color;\n}\n\nRay cast_ray(vec2 uv) {\n    // Map uv from [0, 1] to [-1, 1]\n    uv = (uv * 2.f) - 1.f;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 cam_dir = normalize(cam.look_at - cam.pos);\n    float fov = FOV / 360.f * PI;\n    vec3 dy = cam_dir + tan(fov / 2.f) * uv.y * cam.up;\n    vec3 dx = cam_dir + tan(fov / 2.f) * uv.x * cross(cam.up, cam_dir);\n    return Ray(cam.pos, normalize(dx + dy));\n}\n\nvec3 calculate_color(Ray initial_ray) {\n    vec3 color = vec3(0, 0, 0);\n    // Push initial ray\n    trace_size = 0;\n    push(TraceNode(\n        initial_ray,\n        1.f,\n        0\n    ));\n    \n    while(trace_size > 0) {\n        TraceNode node = pop();\n        // Check for termination\n        if(node.intensity < EPS || node.depth > MAX_DEPTH) {\n            continue;\n        }\n            \n        RayHit rh;   \n        Ray ray = node.ray;\n        float t = FLOAT_MAX;\n        \n        // Check for ground plane collision\n        for(int i = 0; i < PLANE_COUNT; ++i) {\n            CirclePlane plane = planes[i];\n            float dist = intersect(ray, plane);\n            if(dist >= 0.f && dist < t) {\n                t = dist;\n                rh = RayHit(\n                    ray.o + t * ray.d,\n                    plane.n,\n                    plane.material_id\n                );\n            }\n        } \n\n        // Check for nearest sphere collision \n        for(int i = 0; i < SPHERE_COUNT; ++i) {\n            Sphere sphere = spheres[i];\n            float dist = intersect(ray, sphere);\n            if(dist >= 0.f && dist < t) {\n                t = dist;\n                rh = RayHit(\n                    ray.o + t * ray.d,\n                    normalize(ray.o + dist * ray.d - sphere.c),\n                    sphere.material_id\n                );\n            }\n        }\n        \n        if(t < FLOAT_MAX) {  \n            // Collision occured\n            float n1 = AIR_REFRACTION_IDX;\n            float n2 = materials[rh.material_id].refraction_idx;\n            float cos_theta = -dot(ray.d, rh.n) / (length(ray.d) * length(rh.n)); \n            if(cos_theta < 0.f) {\n                float tmp = n1;\n                n1 = n2;\n                n2 = tmp;\n                rh.n = -rh.n;\n                cos_theta = dot(ray.d, rh.n) / (length(ray.d) * length(rh.n));\n            }\n            float f = fresnel(n1, n2, acos(cos_theta));\n            float g = materials[rh.material_id].glass;\n            \n            // Calculate weights\n            float R = node.intensity * f;\n            float T = node.intensity * g * (1.f - f);\n            float D = node.intensity * (1.f - g) * (1.f - f);\n            \n            if(materials[rh.material_id].mirror) {\n                R += D + T;\n                D = 0.01f;\n                T = 0.f;\n            }\n            \n            // Start reflection ray\n            vec3 reflection_dir = reflect(ray.d, rh.n);\n            TraceNode reflection = TraceNode(\n                Ray(rh.pos, reflection_dir),\n                node.intensity * R,\n                node.depth + 1\n            );\n            push(reflection);\n            \n            // Start refraction ray\n            vec3 refraction_dir = refract(ray.d, rh.n, n1 / n2);\n            TraceNode refraction = TraceNode(\n                Ray(rh.pos + EPS * refraction_dir, refraction_dir),\n                node.intensity * T,\n                node.depth + 1\n            );\n            push(refraction);\n            \n            color += node.intensity * D * cast_shadow_ray(rh);\n        } else {\n            // No object was hit\n            color += node.intensity * texture(iChannel0, ray.d, -1.f).rgb;\n            continue;\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float speed = 0.6f;\n    float dist = 40.f;\n    cam.pos = vec3((dist + 8.f) * sin(iTime * speed), 17.f + 10.f * cos(iTime * speed), dist * cos(iTime * speed));\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    Ray ray = cast_ray(uv);\n    vec3 color = vec3(0);\n#if AA > 1\n    for (int i = 0; i < AA; ++i) {\n        for (int j = 0; j < AA; ++j) {\n            vec3 rnd = randvec(hash(float(i * AA + j), float(iFrame)));\n            rnd = normalize(rnd) * 0.00045;\n            Ray jittered = Ray(ray.o, normalize(ray.d + rnd));\n            color += calculate_color(jittered);\n        }\n    }\n#else\n    color += calculate_color(ray);\n#endif\n    fragColor = vec4(color / float(AA * AA), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* >========<\n * |SETTINGS|\n * >========<\n */\n\n#define EPS 0.002f\n#define FLOAT_MAX 3.402823466e+38f\n#define PI 3.14159265359\n\n#define FOV 100.f\n#define AA 1\n#define AMBIENT_LIGHT_COLOR vec3(1, 1, 1)\n#define AMBIENT_INTENSITY 0.8\n#define MAX_STACK_SIZE 32\n#define MAX_DEPTH 6\n\n#define AIR_REFRACTION_IDX 1.f\n \n/* >==========<\n * |DATA TYPES|\n * >==========<\n */\n\nstruct Camera {\n    vec3 pos;\n    vec3 look_at;\n    vec3 up;\n};\n\nstruct Material {\n    vec3 color;\n    float glass;\n    float refraction_idx;\n    bool mirror;\n};\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct RayHit {\n    vec3 pos;\n    vec3 n;\n    int material_id;\n};\n\nstruct TraceNode {\n    Ray ray;\n    float intensity;\n    int depth;\n};\n\nstruct CirclePlane {\n    vec3 o;\n    vec3 n;\n    float r;\n    int material_id;\n};\n\nstruct Sphere {\n    vec3 c;\n    float r;\n    int material_id;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n\n/* >==============<\n * |SCENE SETTINGS|\n * >==============<\n */\n\nCamera cam = Camera(\n    vec3(0, 5, 30), \n    vec3(0, 3, 0), \n    vec3(0, 1, 0)\n);\n\n#define PLANE_COUNT 1\nCirclePlane planes[PLANE_COUNT] = CirclePlane[PLANE_COUNT](\n    CirclePlane(vec3(0, 0, 0), vec3(0, 1, 0), 30.f, 0)\n);\n\n#define MATERIAL_COUNT 5\nMaterial materials[MATERIAL_COUNT] = Material[MATERIAL_COUNT](\n    Material(vec3(0.25, 0.25, 0.25), 0.0f, 1.f, false),\n    Material(vec3(1, 0, 0), 1.f, 1.52f, false),\n    Material(vec3(1, 1, 1), 0.5f, 1.f, true),\n    Material(vec3(1, 1, 0), 0.f, 1.f, false),\n    Material(vec3(0, 1, 0), 0.f, 1.f, false)\n);\n\n#define SPHERE_COUNT 18\nSphere spheres[SPHERE_COUNT] = Sphere[SPHERE_COUNT](    \n    // Mirror\n    Sphere(vec3(0, 4, -5), 2.f, 2),\n    Sphere(vec3(-5, 4, 0), 2.f, 2),\n    Sphere(vec3(0, 4, 5), 2.f, 2),\n    Sphere(vec3(5, 4, 0), 2.f, 2),\n    // Glass\n    Sphere(vec3(0, 4, 0), 2.f, 1),\n    // Solid\n    Sphere(vec3(5, 4, 5), 2.f, 3),\n    Sphere(vec3(-5, 4, 5), 2.f, 4),\n    Sphere(vec3(5, 4, -5), 2.f, 3),\n    Sphere(vec3(-5, 4, -5), 2.f, 4),\n    \n    // Solid\n    Sphere(vec3(0, 9, 0), 2.f, 3),\n    // Mirror\n    Sphere(vec3(5, 9, 5), 2.f, 2),\n    Sphere(vec3(-5, 9, 5), 2.f, 2),\n    Sphere(vec3(5, 9, -5), 2.f, 2),\n    Sphere(vec3(-5, 9, -5), 2.f, 2),\n    // Glass\n    Sphere(vec3(0, 9, -5), 2.f, 1),\n    Sphere(vec3(-5, 9, 0), 2.f, 1),\n    Sphere(vec3(0, 9, 5), 2.f, 1),\n    Sphere(vec3(5, 9, 0), 2.f, 1)\n);\n\n#define LIGHT_INTENSITY 400.f\n#define LIGHT_COUNT 4\nLight lights[LIGHT_COUNT] = Light[LIGHT_COUNT](\n    Light(vec3(-10, 15, -10), vec3(1, 1, 1), LIGHT_INTENSITY),\n    Light(vec3(-10, 15, 10), vec3(1, 0, 0), LIGHT_INTENSITY),\n    Light(vec3(10, 15, -10), vec3(0, 0, 1), LIGHT_INTENSITY),\n    Light(vec3(10, 15, 10), vec3(0, 1, 0), LIGHT_INTENSITY)\n);\n\n/* >================<\n * |HELPER FUNCTIONS|\n * >================<\n */\n\nfloat intersect(Ray r, Sphere s) {\n    float a = dot(r.d, r.o - s.c);\n    float b = length(r.o - s.c);\n    float delta = a * a - (b * b - s.r * s.r);\n    if(delta >= 0.f) {\n        // Intersection found\n        delta = sqrt(delta);\n        return min(-a + delta, -a - delta);\n    }  \n    return -1.f;\n}\n\nfloat intersect(Ray r, CirclePlane p) {\n    float denom = dot(p.n, r.d); \n    if (abs(denom) > EPS) { \n        float t = dot(p.o - cam.pos, p.n) / denom; \n        if(t > 0.f) {\n            vec3 inter = r.o + t * r.d;\n            if(distance(p.o, inter) <= p.r) {\n                // Intersection found\n                return t;\n            }\n        } \n    }  \n    return -1.f;\n}\n\nfloat fresnel(float n1, float n2, float cos_theta_I) {\n    float e = n1 / n2 * sin(cos_theta_I);\n    float q = 1.f - e * e;\n    if(q < 0.f) {\n        return 1.f;\n    }\n    \n    float a = n1 * cos(cos_theta_I);\n    float b = n2 * sqrt(q);\n    float rs = (a - b) / (a + b);\n    \n    float c = n1 * sqrt(q);\n    float d = n2 * cos(cos_theta_I);\n    float rp = (c - d) / (c + d);\n    \n    return 0.5f * (rs * rs + rp * rp);\n}\n","name":"Common","description":"","type":"common"}]}