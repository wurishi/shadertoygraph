{"ver":"0.1","info":{"id":"4fBcRh","date":"1721878492","viewed":62,"name":"蜘蛛侠：丛横宇宙配色","username":"Capo","description":"spider man！ you can use your mouse to click on the screen!","likes":3,"published":1,"flags":2,"usePreview":0,"tags":["imageprocessing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Define resolutions\n#define Res  iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n#define Res3 vec2(textureSize(iChannel3,0))\n\n// Function to get random values\nvec4 getRand(vec2 pos) \n{\n    vec2 uv = pos / Res1;\n    return texture(iChannel1, uv);\n}\n\n// Function to get value\nfloat getVal(vec2 uv)\n{\n    float r = getRand(uv * iResolution.xy * .02).x * 2. - 1.;\n    r = 0. * exp(-abs(r) / 0.05);\n    \n    return mix(1.,\n    length(textureLod(iChannel0, uv, 2.5 + .5 * log2(iResolution.x / 1920.)).xyz) * .6 +\n    length(textureLod(iChannel0, uv, 1.5 + .5 * log2(iResolution.x / 1920.)).xyz) * .3 +\n    length(textureLod(iChannel0, uv, .5 + .5 * log2(iResolution.x / 1920.)).xyz) * .2\n    , 1. - r);\n}\n\n// Function to get gradient\nvec2 getGrad(vec2 uv, float delta)\n{\n    vec2 d = vec2(delta, 0);\n    return vec2(\n        getVal(uv + d.xy) - getVal(uv - d.xy),\n        getVal(uv + d.yx) - getVal(uv - d.yx)\n    ) / delta;\n}\n\n// Refined height to color function\nvec3 heightToColor(float height) {\n  \n    vec3 lowColor = vec3(0.0, 0.0, 1.0);\n    vec3 midLowColor = vec3(0.0, 1.0, 1.0);\n    vec3 midColor = vec3(0.0, 1.0, 0.0);\n    vec3 midHighColor = vec3(1.0, 1.0, 0.0);\n    vec3 highColor = vec3(1.0, 0.0, 0.0);\n\n    if (height < 0.25) {\n        return mix(lowColor, midLowColor, height * 4.0);\n    } else if (height < 0.5) {\n        return mix(midLowColor, midColor, (height - 0.25) * 4.0);\n    } else if (height < 0.75) {\n        return mix(midColor, midHighColor, (height - 0.5) * 4.0);\n    } else {\n        return mix(midHighColor, highColor, (height - 0.75) * 4.0);\n    }\n}\n\n// Edge detection function\nvec4 edgeDetection(vec2 uv, float threshold) {\n    vec2 delta = vec2(1.0) / Res;\n    float gx = getVal(uv + delta * vec2(-1, -1)) * -1.0 + getVal(uv + delta * vec2(1, -1)) * 1.0\n             + getVal(uv + delta * vec2(-1, 1)) * -1.0 + getVal(uv + delta * vec2(1, 1)) * 1.0;\n    float gy = getVal(uv + delta * vec2(-1, -1)) * -1.0 + getVal(uv + delta * vec2(-1, 1)) * 1.0\n             + getVal(uv + delta * vec2(1, -1)) * -1.0 + getVal(uv + delta * vec2(1, 1)) * 1.0;\n    float g = length(vec2(gx, gy));\n    float edge = step(threshold, g);\n    return vec4(edge, edge, edge, 1.0);\n}\n\n// Smooth edges function\nvec4 smoothEdges(vec2 uv, float threshold) {\n    vec4 edges = vec4(0.0);\n    vec2 offset[9] = vec2[](\n        vec2(-1, -1), vec2(0, -1), vec2(1, -1),\n        vec2(-1, 0), vec2(0, 0), vec2(1, 0),\n        vec2(-1, 1), vec2(0, 1), vec2(1, 1)\n    );\n    float kernel[9] = float[](\n        1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0,\n        2.0 / 16.0, 4.0 / 16.0, 2.0 / 16.0,\n        1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0\n    );\n\n    for (int i = 0; i < 9; i++) {\n        edges += edgeDetection(uv + offset[i] / Res, threshold) * kernel[i];\n    }\n    return edges;\n}\n\n// High-pass filter\nvec4 highPassFilter(vec2 uv)\n{\n    vec2 offset[9] = vec2[](\n        vec2(-1, -1), vec2(0, -1), vec2(1, -1),\n        vec2(-1, 0), vec2(0, 0), vec2(1, 0),\n        vec2(-1, 1), vec2(0, 1), vec2(1, 1)\n    );\n    float kernel[9] = float[](\n        -1.0, -1.0, -1.0,\n        -1.0, 8.0, -1.0,\n        -1.0, -1.0, -1.0\n    );\n\n    vec4 sum = vec4(0.0);\n    for (int i = 0; i < 9; i++) {\n        sum += texture(iChannel0, uv + offset[i] / Res) * kernel[i];\n    }\n    return sum;\n}\n\n// Gamma correction\nvec3 gammaCorrection(vec3 color, float gamma)\n{\n    return pow(color, vec3(gamma));\n}\n\n// Histogram equalization\nvec3 histogramEqualization(vec3 color)\n{\n   \n    return color; \n}\n\n// Function to apply additional effects\nvec3 applyAdditionalEffects(vec2 uv, vec2 fragCoord, float iTime, vec2 iMouse, vec3 color) {\n    float sh = 4.0;\n    float sc = 1.0;\n    if (iMouse.x > 0.0) { \n        sh = 8.0 * iMouse.x / iResolution.x;\n        sc = 7.0 * iMouse.y / iResolution.y;\n    }    \n    vec2 c = floor(fragCoord / sc) * sc;\n    vec2 uvEffect = c / iResolution.xy;\n    vec4 tex = texture(iChannel0, uvEffect);\n    vec2 shift = floor(cos(iTime * vec2(5, 9)) * 1e4) * 1.0;\n    float di = 0.5;\n    vec4 col = floor(tex * sh + di) / sh;\n    col *= clamp(min(fragCoord.x, fragCoord.y) - 1.0, 0.0, 1.0);\n    vec3 finalColor = mix(color, col.rgb, 0.5);\n    return finalColor; // 返回vec3类型\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / Res;\n    \n    float height = getVal(uv);\n    \n   \n    vec3 color = heightToColor(height);\n    \n   \n    vec4 edgeColor = smoothEdges(uv, 0.2);\n    color = mix(color, vec3(0.0), edgeColor.r); \n    \n   \n    vec4 highPassColor = highPassFilter(uv);\n    color = mix(color, highPassColor.rgb, 0.5); \n    \n   \n    float gamma = 2.2;\n    color = gammaCorrection(color, 1.0 / gamma); \n    \n    color = histogramEqualization(color);\n    \n    \n    vec3 finalColor = applyAdditionalEffects(uv, fragCoord, iTime, iMouse.xy, color);\n    \n  \n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}