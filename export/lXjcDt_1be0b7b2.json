{"ver":"0.1","info":{"id":"lXjcDt","date":"1727894253","viewed":44,"name":"Pet Ball","username":"Elsio","description":"Extração dos cálculos de divisão da esfera em triângulos ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["math","icosahedron","spherical","polyhedron"],"hasliked":0,"parentid":"X3ByWd","parentname":"Sphere texturization study #01"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + pi * vec4(0, .5, 1.5, 0)))\n#define pi acos(-1.)\n#define TAU (pi * 2.)\n#define FAR 20.\n#define latblock 1.1071488\n#define t iTime\n\n#define esf2cart(x, y) vec3(cos(x) * sin(y), cos(y), sin(x) * sin(y)) / 2.\n#define h33(a) fract(sin(a * 192.12) * 432.12)\n\nvec4 cor;\n\nvoid rotObj(inout vec3 p) {\n    p.yz *= rot(t / 3.);\n    p.xz *= rot(t / 2.);\n    p.xy *= rot(cos(t * .5) * .15\n          * dot(vec2(cos(t * 13.), sin(t * 12.)), p.yx));    \n}\n\n\nfloat Tubes(vec3 p, int id, vec4 dd){\n    float flip = id == 0 || id == 3 ? 1. : -1.;\n    \n    vec4 A = vec4(0, pi-latblock, pi, latblock);\n    vec4 B = A.wwyy;\n    \n    vec3 ax = dd[id] + vec3(0, -pi, pi) * flip / 5.;\n    vec3 V = esf2cart(ax.x, A[id]) \n             + esf2cart(ax.y, B[id])\n             + esf2cart(ax.z, B[id]);\n                 \n    cor = vec4(h33(V + iMouse.x), 0);\n    vec3 b = normalize(V) * .5;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h) - .1;\n}\n\n\n#define op(a, b) (a.y < b.y ? a : b)\n#define cmp(i, a, b) id = op(id, vec2(i, length(p - esf2cart(a, b))))\n\nint closestFace(vec3 p, vec4 dd){\n    vec2 id = vec2(1e5);\n    vec2 lat = vec2(.65235823, 1.3820858);\n    \n    cmp(3, dd[2], pi - lat[1]);\n    \n    if(p.y < 0.){\n        cmp(1, dd[1], lat[1]);\n        cmp(2, dd[2], pi - lat[0]);\n    }\n    \n    else{\n        cmp(0, dd[0], lat[0]);\n        cmp(1, dd[1], lat[1]);\n    }\n    \n    return int(id.x);\n}\n\n\nfloat icosa(vec3 p) {\n    vec4 dd;\n    \n    dd = vec4(0, 0, 1, 1) / 2.;\n    dd += atan(p.z, p.x) * 5. / TAU;\n    dd = floor(dd) + vec4(1, 1, 0, 0) / 2.;\n    dd *= TAU / 5.;\n               \n    int id = closestFace(p, dd);\n    float face = length(p) - .43;\n    float tubes = Tubes(p, id, dd);\n    \n    return min(face, tubes);\n}\n\n\nfloat map(vec3 p) { \n    rotObj(p);\n    return icosa(p);\n}\n\n\nfloat march(vec3 ro, vec3 rd) {\n    float s, i, d;\n    \n    while(i++ < 180.) {\n        s = map(ro + d * rd);\n        if(s < .001 || d > FAR) break;\n        d += s * .9;\n    }\n    \n    return min(d, FAR);\n}\n\nvec3 normal(vec3 p) {\n    vec3 e = vec3(.001, 0, 0),\n         v = vec3(\n                 map(p + e.xyy), \n                 map(p + e.yxy),  \n                 map(p + e.yyx)\n             ) - map(p);\n    return normalize(v);\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n         u = (u - r / 2.) / r.y;\n    \n    vec3 p = vec3(0, 0, -5),\n         D = normalize(vec3(u, 5));\n    \n    float d = march(p, D);\n\n    o = vec4(-D.y * 6.);\n    \n    if(d < FAR){\n        vec3 n = normal(p + d * D);\n        o = length(sin(n * 1.5) * .35 + .35) * cor;\n    }\n}","name":"Image","description":"","type":"image"}]}