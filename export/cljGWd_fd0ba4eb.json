{"ver":"0.1","info":{"id":"cljGWd","date":"1674140493","viewed":55,"name":"Linear lighting","username":"khron","description":"Calculate lighting in linear space and correctly handle conversions between linear and sRGB colors.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gamma","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Use mouse to change directional and ambient light intensity\n// Horizontal axis controls directional light\n// Vertical axis controls ambient light\n\n// Compare color space conversions for lighting\n// Left column: Calculate lighting in linear, output linear\n// Middle column: Calculate lighting in sRGB, output sRGB\n// Right column: Calculate lighting in linear, output sRGB (CORRECT)\n\nvec3 srgb_to_lin(vec3 srgb)\n{\n    return mix(\n        pow((srgb + vec3(0.055)) / 1.055, vec3(2.4)),\n        srgb / vec3(12.92),\n        step(srgb, vec3(0.04045))\n    );\n}\n\nvec3 lin_to_srgb(vec3 lin)\n{\n    return mix(\n        pow(lin, vec3(1.0 / 2.4)) * 1.055 - vec3(0.055),\n        lin * vec3(12.92),\n        step(lin, vec3(0.0031308))\n    );\n}\n\nconst float hpi = radians(90.0);\nconst float pi = hpi * 2.0;\nconst float spec_power = 20.0;\n\nvec4 lighting(vec2 fragCoord, vec2 center, vec3 srgb_col)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float dir_light_intensity = (iMouse.x + iResolution.x * 0.1) / iResolution.x * 1.5;\n    float amb_light_intensity = (iMouse.y + iResolution.y * 0.1) / iResolution.y * 0.5;\n    float spec_strength = dir_light_intensity * 0.5;\n    \n    const float colors_f = 3.0;\n    float radius = iResolution.y / (colors_f * 2.0 * 1.2);\n    \n    vec2 pos2 = (fragCoord - center) / radius;\n    float dist2 = length(pos2);\n    if (dist2 < 1.0)\n    {\n        const vec3 view_dir = vec3(0.0, 0.0, 1.0);\n        vec3 nor = normalize(vec3(pos2, cos(dist2 * hpi)));\n        //vec3 light_dir = normalize(vec3((iMouse.xy / iResolution.xy - 0.5) * 2.0, 0.75));\n        vec3 light_dir = normalize(vec3(1.0));\n        vec3 reflect_dir = reflect(-light_dir, nor);\n        float dir_light_energy = max(dot(light_dir, nor), 0.0) * dir_light_intensity;\n        float specular = pow(max(dot(view_dir, reflect_dir), 0.0), spec_power) * spec_strength;\n        float light_energy = dir_light_energy + amb_light_intensity;\n        \n        vec2 sphere_uv = vec2(atan(nor.x, nor.z) - hpi, -atan(length(nor.xz), nor.y)) / pi;\n        \n        vec3 lit_col;\n        if (uv.x < 0.3333)\n            return vec4(srgb_to_lin(srgb_col) * light_energy + specular, 1.0);\n        else if (uv.x < 0.6666)\n            return vec4(srgb_col * light_energy + specular, 1.0);\n        else\n            return vec4(lin_to_srgb(srgb_to_lin(srgb_col) * light_energy + specular), 1.0);\n    }\n    else\n        return vec4(vec3(50.0 / 255.0), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center;\n    vec3 srgb_color;\n    \n    if (uv.x < 0.3333)\n        center.x = iResolution.x * 0.225;\n    else if (uv.x < 0.6666)\n        center.x = iResolution.x * 0.5;\n    else\n        center.x = iResolution.x * 0.775;\n    \n    if (uv.y < 0.3333)\n    {\n        center.y = iResolution.y * 0.1833;\n        srgb_color = vec3(133.0, 0.0, 0.0) * vec3(1.0 / 255.0);\n    }\n    else if (uv.y < 0.6666)\n    {\n        center.y = iResolution.y * 0.5;\n        srgb_color = vec3(0.0, 209.0, 35.0) * vec3(1.0 / 255.0);\n    }\n    else\n    {\n        center.y = iResolution.y * 0.8166;\n        srgb_color = vec3(174.0, 210.0, 230.0) * vec3(1.0 / 255.0);\n    }\n    \n    if (uv.x > 0.94 || uv.x < 0.06)\n        fragColor = vec4(srgb_color, 1.0);\n    else\n        fragColor = lighting(fragCoord, center, srgb_color);\n}","name":"Image","description":"","type":"image"}]}