{"ver":"0.1","info":{"id":"fd2GzV","date":"1618877985","viewed":112,"name":"315_fedorov_v3v5","username":"Wizardvh","description":"mashgraph","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["mashgraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//const vec3 CAMERA_POS = vec3(-3.5, 1.2, -3)* 1.0;\nconst vec3 CAMERA_POS = vec3(1.0, 0.8, -6.5);\n\nconst float INF = 1e9 + 7.0f;\n\nconst int DEPTH = 10;\nconst float eps = 1e-4;\nconst int LAMPS_NUMBER = 2;\n\nconst float AIR_IOF = 1.0;\nconst float GLASS_IOF = 1.5;\n\nconst vec3 TABLE_POS = vec3(0.0, -1.0, -5.0);\n\nconst float OCTAHEDRON_R = 1.1;\nconst float CYLINDER_H = 0.2;\n\nconst vec3 CRYSTALL_POS = vec3(0.0, TABLE_POS.y + OCTAHEDRON_R + CYLINDER_H, 0.0);\n\nconst float ABSORBTION = 20.0;\n\nvec3 randVals;\n//table plane pos is (0, -1, 0)\n\n\nfloat norm(vec3 v){\n    return sqrt(dot(v, v));\n}\n\nfloat pow2(float x){\n    return x * x;\n}\n\nfloat rand(float frame){\n    return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\n//------------ ray struct ----------\nconst int EMISSION = 0;\nconst int DIFFUSIVE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nstruct ray{\n    float t;//current distance\n    vec3 pos;//current start position\n    vec3 dir;//current direction\n    int materialType;//last reflected material type\n    vec3 normal;//material normal\n    float iof;\n    vec3 colorMult;\n};\n\n//----------------------------------\n\nfloat crossTriangle(const in vec3 v[3], const in vec3 p, const in vec3 d){\n//cross the vector p + d * t with triangle v[0], v[1], v[2]\n    vec3 E1 = v[1] - v[0];\n    vec3 E2 = v[2] - v[0];\n    vec3 T = p - v[0];\n    vec3 P = cross(d, E2);\n    vec3 Q = cross(T, E1);\n    \n    float S = dot(P, E1);\n    if (abs(S) < eps)\n        return INF;\n    S = 1.0f / S;\n    float u = dot(P, T) * S;\n    float w = dot(Q, d) * S;\n    if (abs (abs(u) + abs(w) + abs(1.0f - u - w) - 1.0f) < eps)\n        return dot(Q, E2) * S;\n    else\n        return INF;\n    \n}\n//--------------- rectangle -------\n\n\nstruct rectangle{\n    vec3 pos;\n    float h;\n    float w;\n    vec3 v[4];\n    vec3 n;\n};\n\nvoid createRect(inout rectangle rect, vec3 front){\n//rectangle consist of v1, v2, v3, v4 points\n// n - normal vector\n// v2 = v1 + d * k\n// d perpendicular to n\n// d perpendicular to v1 - v2\n    rect.n = normalize(front);\n    const float k = 640.0 / (1.5 * 0.3);\n    rect.w = 640.0 / k;\n    rect.h = 360.0 / k;\n    \n    vec3 d = normalize(cross(vec3(0.0, 1.0, 0.0), rect.n));\n    \n    rect.pos = CRYSTALL_POS - rect.n * 0.2 - d * 0.6 - vec3(0, 1, 0) * 0.2;\n    rect.v[0] = rect.pos;\n    \n    rect.v[1] = rect.pos;\n    rect.v[1].y += rect.h;\n    \n    rect.v[2] = rect.v[1] + rect.w * d;\n    \n    rect.v[3] = rect.v[2];\n    rect.v[3].y -= rect.h;\n}\n\nvec4 getRectCol(const in rectangle rect, vec3 pos){\n    vec3 x = normalize(rect.v[3] - rect.v[0]);\n    vec3 y = normalize(rect.v[1] - rect.v[0]);\n    vec3 P = pos - rect.pos;\n    \n    vec2 uv = vec2(dot(P, x) / rect.w, dot(P, y) / rect.h);\n    uv /= vec2(rect.w, rect.h);\n//    return texture(iChannel3, uv * 5.0);\n    return vec4(1.0, 0.5, 0.0, 1.0);\n}\n\n\n//--------------- sphere ----------\n\nstruct sphere{\n    float R;\n    vec3 pos;\n};\n\n\nfloat crossSphere(const in sphere s, const in vec3 p, const in vec3 d){\n//<p, p> + 2t<p, d> + t^2<d, d> = R^2\n    vec3 P = p - s.pos;\n    float b = dot(P, d);\n    float D = b * b - (dot(P, P) - s.R * s.R) * dot(d, d);\n    if (D < 0.0f)\n        return INF;\n    float t = -b - sqrt(D);\n    if (t > 0.0f)\n        return t;\n    t = -b + sqrt(D);\n    if (t < 0.0f)\n        return INF;\n    return t;\n}\n\n//------------------Cylinder--------------\n\nstruct cylinder{\n    vec3 pos;\n    float R;\n    float H;\n};\n\nvoid createCylinder(inout cylinder cyl){\n    cyl.R = OCTAHEDRON_R;\n    cyl.H = CYLINDER_H;\n    cyl.pos = CRYSTALL_POS;\n    cyl.pos.y = cyl.pos.y  - (OCTAHEDRON_R + CYLINDER_H);\n}\n\nfloat crossCylEdge(const in cylinder cyl, const in vec3 p, const in vec3 d){\n    float a = dot(d.xz, d.xz);\n    vec2 P = p.xz - cyl.pos.xz;\n    float b = dot(P, d.xz);\n    float D = b * b - (dot(P, P) - cyl.R * cyl.R) * a;\n    if (D < 0.0f)\n        return INF;\n    float t = (-b - sqrt(D)) / a;\n\n    vec3 worldPos = p + d * t;\n    if (t > 0.0f && worldPos.y < cyl.pos.y + cyl.H)\n        return t;\n\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0f)\n        return INF;\n    worldPos = p + d * t;\n    if ( worldPos.y < cyl.pos.y + cyl.H)\n        return t;\n    \n    return INF;\n}\n\n\n//--------------- octahedron ------------\n\nstruct octahedron{\n    vec3 point[6];\n    ivec3 edge[8];\n    float R;\n    vec4 color;\n    vec3 pos;\n    vec3 normal;\n    float iof;\n    float REFRACTION_CONST;\n};\n\nvoid createOct(inout octahedron oct){//fill octahedron\n    const float R = OCTAHEDRON_R;\n    oct.iof = GLASS_IOF;\n    oct.R = R;\n    oct.pos = CRYSTALL_POS;\n    oct.color = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    oct.REFRACTION_CONST = pow2(AIR_IOF - GLASS_IOF) / pow2(AIR_IOF + GLASS_IOF);\n    \n    oct.point[0] = vec3(R, 0.0, 0.0) + oct.pos;\n    oct.point[1] = vec3(-R, 0.0, 0.0) + oct.pos;\n    oct.point[2] = vec3(0.0, R, 0.0) + oct.pos;\n    oct.point[3] = vec3(0.0, -R, 0.0) + oct.pos;\n    oct.point[4] = vec3(0.0, 0.0, R) + oct.pos;\n    oct.point[5] = vec3(0.0, 0.0, -R) + oct.pos;\n\n    oct.edge[0] = ivec3(4, 2, 0);\n    oct.edge[1] = ivec3(0, 2, 5);\n    oct.edge[2] = ivec3(5, 2, 1);\n    oct.edge[3] = ivec3(1, 2, 4);\n    oct.edge[4] = ivec3(4, 3, 0);\n    oct.edge[5] = ivec3(0, 3, 5);\n    oct.edge[6] = ivec3(5, 3, 1);\n    oct.edge[7] = ivec3(1, 3, 4);\n}\nvec3 octNorm(in octahedron oct, const int i){\n//return norm vector for edge number i\n    ivec3 j = oct.edge[i];\n    vec3 v[3] = vec3[3](oct.point[j.x], oct.point[j.y], oct.point[j.z]);\n    if (i < 4)\n        return normalize(cross(v[0] - v[1], v[2] - v[1]));\n    else\n        return normalize(cross(v[2] - v[1], v[0] - v[1]));\n}\n\n//--------------------light sources-------------------------\n\nstruct lightSource{\n    sphere form;\n    vec4 color;\n    float lightK;\n    vec3 normal;\n};\n\n\nvoid createLight(inout lightSource l[2]){//fill lamps\n    l[0].color = vec4(1.0, 0.5, 0.5, 1.0);\n    l[0].lightK = 15.0;\n    l[0].form = sphere(0.8, vec3(-3, 1.5, 5));\n    \n/*\n    l[0].color = vec4(1.0, 0.5, 0.5, 1.0);\n    l[0].lightK = 15.0;\n    l[0].form = sphere(0.8, vec3(-3, 1.5, 5));\n*/\n    \n    l[1].color = vec4(0.0, 0.6, 1.0, 1.0);\n    l[1].lightK = 5.0;\n    l[1].form = sphere(0.25f, vec3(0.5, 0, 3.0));\n/*\n        l[1].color = vec4(0.0, 0.6, 1.0, 1.0);\n    l[1].lightK = 5.0;\n    l[1].form = sphere(0.25f, vec3(0.5, 0, 3.0));\n*/\n}\n\n//------------------------ computing light block-------------------------------------------\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal, \nin lightSource lamp[LAMPS_NUMBER]){\n    const float ambientLightK = 0.3; \n    \n    vec3 lightInt = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < LAMPS_NUMBER; ++i){\n        vec3 toLight = lamp[i].form.pos - pos;\n        float distSq = dot(toLight, toLight);\n        float att = lamp[i].lightK / distSq;\n        lightInt += max(0.0, dot(normal, normalize(toLight))) * att * lamp[i].color.rgb;\n    }\n    \n    \n    return color * (lightInt + texture(iChannel1, normal).rgb * ambientLightK);\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2){\n    if (dot(v, normal) < 0.0f)\n        normal = -normal;\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    \n    float sinB = n1 / n2 * sinA;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    \n    return sinB * tang + cosB * normal;\n}\n\n//------------------------ trace block-------------------------------------------\n// taceSomething(inout ray, inout vec4 fragColor, ...)\n\nvoid traceCyl(inout ray r, inout vec4 fragColor, inout cylinder cyl){\n    //top round lies in the plane <x - c, n> = 0\n    //<pos + t * dir - c, n> = 0 => t = <c - pos, n> / <dir, n>\n    //c - upper round cental point\n    vec3 c = cyl.pos;\n    c.y += cyl.H;\n    float t = (c.y - r.pos.y) / r.dir.y;\n//    float t = dot(c - r.pos, n) / dot(r.dir, n);\n    vec3 crossPoint = r.pos + t * r.dir;\n    \n    if (t < r.t && dot(crossPoint.xz - c.xz, crossPoint.xz - c.xz) <= cyl.R * cyl.R){\n        r.t = t;\n        fragColor = texture(iChannel2, crossPoint.xz);\n        r.normal = vec3(0, 1, 0);\n        r.materialType = DIFFUSIVE;\n    }\n    t = crossCylEdge(cyl, r.pos, r.dir);\n    crossPoint = r.pos + t * r.dir;\n    if (t != INF && t <= r.t){\n        r.t = t;\n        fragColor = texture(iChannel2, crossPoint.xy);\n        r.materialType = DIFFUSIVE;\n        r.normal = crossPoint - cyl.pos;\n        r.normal = normalize(vec3(r.normal.x, 0, r.normal.z));\n    }\n}\n\nvoid traceTable(inout ray r, inout vec4 fragColor){\n    const float R = 150.0f;\n    const vec3 pos = TABLE_POS;\n    float t = (-r.pos.y + pos.y) / r.dir.y;\n    vec3 worldPos = t * r.dir + r.pos;\n    if (t > 0.0 && dot(worldPos.xz, worldPos.xz) <= R && t <= r.t){\n        r.t = t;\n        r.normal = vec3(0, 1, 0);\n        fragColor = texture(iChannel0, worldPos.xz * 0.3);\n        if (randVals.x < 0.1)\n            r.materialType = REFLECTION;\n        else\n            r.materialType = DIFFUSIVE;\n    }\n}\n\nvoid traceOct(inout ray r, inout vec4 fragColor, in octahedron oct){    \n    for (int i = 0; i < 8; ++i){\n        ivec3 j = oct.edge[i];\n        vec3 v[3] = vec3[3](oct.point[j.x], oct.point[j.y], oct.point[j.z]);\n        float t = crossTriangle(v, r.pos, r.dir);\n        if (t != INF && t > 0.0 && t < r.t){\n            r.t = t;\n            r.normal = octNorm(oct, i);\n            if (randVals.x < oct.REFRACTION_CONST){\n                r.materialType = REFLECTION;\n            }\n            else{\n                r.materialType = REFRACTION;\n                r.colorMult = oct.color.rgb;\n            }\n            //change IOF, if rayPos \n            if (dot(r.normal, r.dir) < 0.0)\n                r.iof = oct.iof;//if scalar < 0 then the ray enters into the octahedr\n            else\n                r.iof = GLASS_IOF;//else it leaves the octahedr\n        }\n    }\n}\n\nvoid traceLamps(inout ray r, inout vec4 fragColor, \nconst in lightSource[LAMPS_NUMBER] lamp){\n    float t;\n    for (int i = 0; i < LAMPS_NUMBER; ++i){\n        t = crossSphere(lamp[i].form, r.pos, r.dir);\n        if (t > 0.0 && t < r.t){\n            r.t = t;\n            fragColor = lamp[i].color;\n            r.materialType = EMISSION;\n            r.normal = normalize(r.pos + t * r.dir - lamp[i].form.pos);\n        }\n    }\n}\n\nvoid traceRect(inout ray r, inout vec4 fragColor, in rectangle rect){\n    float t = crossTriangle(vec3[3](rect.v[0], rect.v[1], rect.v[2]), r.pos, r.dir);\n    if (t != INF && t < r.t){\n        r.t = t;\n        fragColor = getRectCol(rect, r.t * r.dir * r.pos);\n        r.normal = rect.n;\n        r.materialType = DIFFUSIVE;\n    }\n    t = crossTriangle(vec3[3](rect.v[2], rect.v[3], rect.v[0]), r.pos, r.dir);\n    if (t != INF && t < r.t){\n        r.t = t;\n        fragColor = getRectCol(rect, r.t * r.dir * r.pos);\n        r.normal = rect.n;\n        r.materialType = DIFFUSIVE;\n    }\n}\n\n//------------------fog block------------------------------------\n\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 vision(in vec2 w){\n    vec3 z;\n    vec3 d = vec3(w, 1) / iResolution - 0.5; \n    vec3 p, c, f;\n    vec3 g = d;\n    vec3 o;\n    vec3 y = vec3(1, 2, 0);\n    \n    o.z = 1.0;\n \to.y = 3.0 * cos((o.x = 0.3) * o.z);\n\n    for(float i = 0.0; i < 20.0; i += 0.01) {\n        f = fract(c = o += d * i * 0.01), p = floor(c) * 0.3;\n        if(cos(p.z) + sin(p.x) > ++p.y) {\n\t    \tg = (f.y - 0.04 * cos((c.x + c.z) * 40.0) > 0.8 ? y : f.y * y.yxz) / i;\n            break;\n        }\n    }\n    z.xyz = g;\n    return z;\n}\n\nfloat fogSdf(vec3 pos){ return length(pos - vec3(0, 0.5, 0)) - 0.6;}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled){\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nvec4 sampleFog(vec3 pos, vec3 dir, in vec2 w){\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(ABSORBTION * (\n                texture(iChannel3, curPos * 0.2).x\n                + texture(iChannel3, curPos * 0.4).x\n                + texture(iChannel3, curPos * 0.8).x\n                + texture(iChannel3, curPos * 1.6).x\n                ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    \n    vec3 color = vision(w - vec2(0, 50));\n    vec3 tmp = rgb2hsv(color);\n    tmp.x /= 1.15;\n    tmp.z *= 2.8;\n    color = hsv2rgb(tmp);\n    color *= 1.25;\n    \n    return vec4(color * totalAbs, 1.0 - opacity);\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 1.0)/ iResolution.x;\n    vec3 front = normalize(-CAMERA_POS + vec3(0.0, 0.0, 0.0));\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVector = normalize(front + right * uv.x + up * uv.y);\n    \n    octahedron oct;\n    createOct(oct);\n    \n    lightSource lamp[LAMPS_NUMBER];\n    createLight(lamp);\n    \n    cylinder cyl;\n    createCylinder(cyl);\n    \n    rectangle rect;\n    createRect(rect, front);\n        \n    ray r;\n    r.dir = viewVector;\n    r.pos = CAMERA_POS;\n    r.iof = AIR_IOF;\n    r.colorMult = vec3(1.0, 1.0, 1.0);\n    \n    vec3 colorMult;\n    vec3 visionSum = vec3(0.0, 0.0, 0.0);\n    \n    \n    float curIOF;\n    \n    for (int i = 0; i < DEPTH; ++i){\n        colorMult = r.colorMult;\n        curIOF = r.iof;\n        \n        r.t = INF;//clear current dist\n        traceOct(r, fragColor, oct);\n        traceLamps(r, fragColor, lamp);\n        traceTable(r, fragColor);\n \n        traceCyl(r, fragColor, cyl);\n        \n        if (r.t == INF){\n            fragColor.rgb = texture(iChannel1, r.dir).rgb;\n            fragColor.rgb *= colorMult * 0.7;\n            fragColor.rgb += visionSum;\n            break;\n        }\n        else if (r.materialType == DIFFUSIVE){\n            fragColor.rgb = computeLight(r.pos + r.dir * r.t, fragColor.rgb, r.normal, lamp);\n            fragColor.rgb *= colorMult;\n            fragColor.rgb += visionSum;\n            break;\n        }\n        else if (r.materialType == REFLECTION){\n            r.pos = r.dir * r.t + r.pos;\n            r.dir = reflect(r.dir, r.normal);\n            r.pos += r.dir * 1e-3;\n        }\n        else if (r.materialType == REFRACTION){\n            r.pos = r.dir * r.t + r.pos;\n            r.dir = refraction(r.dir, r.normal, curIOF, r.iof);\n            r.pos += r.dir * 1e-3;\n            \n            vec4 fog = sampleFog(r.pos, r.dir, fragCoord);\n            fragColor.rgb += fog.rgb * fog.a * colorMult;\n            colorMult *= (1.0 - fog.a);\n            if (i == 0){\n                visionSum = fog.rgb * fog.a * colorMult * 1.7;\n            }\n        }\n        else if (r.materialType == EMISSION)\n            break;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}