{"ver":"0.1","info":{"id":"mldfD8","date":"1701197006","viewed":67,"name":"device in cosmos","username":"nayk","description":"cosmos, space,stars,starfield","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["space","stars","cosmos","starfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*original /*original https://www.shadertoy.com/view/cttXRl https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/MlfcDN* https://www.shadertoy.com/view/Dsf3WH/ */\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define MAX_STEPS 64\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define Skew(a,b) mat2(1.0,tan(a),tan(b),1.0)\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n#define seg_DP 39\n\n#define MAX_STEPS 64\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define Skew(a,b) mat2(1.0,tan(a),tan(b),1.0)\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n#define seg_DP 39\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n   \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n   \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    float a = radians(45.0);\n    p.x = abs(p.x)-0.1;\n    p.y = abs(p.y)-0.05;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    d = max(d2,d);\n \n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n   \n    p = prevP;\n   \n    p.x+=size*1.8;\n    p.y-=size*3.5;\n    mask = B(p,vec2(size));\n    d = max(-mask,d);\n   \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n   \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n   \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n   \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n   \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n   \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n   \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n   \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n   \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n   \n    return d;\n}\n\nfloat segDecimalPoint(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.028;\n    p.y+=0.1;\n    float mask = B(p,vec2(size,size));\n    d = max(mask,d);\n    return d;\n}\n\nfloat drawFont(vec2 p, int char){\n    p*=2.0;\n    float d = 10.;\n \n   \n    return d;\n}\n\nfloat ring0(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(-iTime*30.+50.));\n    p = DF(p,16.0);\n    p -= vec2(0.35);\n    float d = B(p*Rot(radians(45.0)),vec2(0.005,0.03));\n    p = prevP;\n   \n    d = min(d,d);    \n   \n    return d;\n}\n\nfloat ring1(vec2 p){\n    vec2 prevP = p;\n    float size = 0.45;\n    float deg = 140.;\n    float thickness = 0.02;\n    float d = abs(length(p)-size)-thickness;\n   \n    p*=Rot(radians(iTime*60.));\n    float a = radians(deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(-deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n   \n    p = prevP;\n    float d2 = abs(length(p)-size)-0.001;\n   \n    return min(d,d2);\n}\n\nfloat ring2(vec2 p){\n    vec2 prevP = p;\n    float size = 0.3;\n    float deg = 120.;\n    float thickness = 0.02;\n   \n    p*=Rot(-radians(sin(iTime*2.)*90.));\n    float d = abs(length(p)-size)-thickness;\n    float a = radians(-deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n   \n    float d2 = abs(length(p)-size)-thickness;\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n   \n    return min(d,d2);\n}\n\nfloat ring3(vec2 p){\n    p*=Rot(radians(-iTime*80.-120.));\n   \n    vec2 prevP = p;\n    float deg = 140.;\n   \n    p = DF(p,6.0);\n    p -= vec2(0.3);\n    float d = abs(B(p*Rot(radians(45.0)),vec2(0.03,0.025)))-0.003;\n   \n    p = prevP;\n    float a = radians(-deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n   \n    p = prevP;\n   \n    p = DF(p,6.0);\n    p -= vec2(0.3);\n    float d2 = abs(B(p*Rot(radians(45.0)),vec2(0.03,0.025)))-0.003;\n   \n    p = prevP;\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n   \n    return min(d,d2);\n}\n\nfloat ring4(vec2 p){\n    p*=Rot(radians(iTime*75.-220.));\n   \n    vec2 prevP = p;\n    float deg = 20.;\n   \n    float d = abs(length(p)-0.25)-0.01;\n   \n    p = DF(p,2.0);\n    p -= vec2(0.1);\n   \n    float a = radians(-deg);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n   \n    return d;\n}\n\nfloat ring5(vec2 p){\n    p*=Rot(radians(-iTime*70.+170.));\n   \n    vec2 prevP = p;\n    float deg = 150.;\n   \n    float d = abs(length(p)-0.16)-0.02;\n   \n    float a = radians(-deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n   \n    p = prevP;\n    p*=Rot(radians(-30.));\n    float d2 = abs(length(p)-0.136)-0.02;\n   \n    deg = 60.;\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n   \n    d = min(d,d2);\n   \n    return d;\n}\n\nfloat ring6(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(iTime*72.+110.));\n   \n    float d = abs(length(p)-0.95)-0.001;\n    d = max(-(abs(p.x)-0.4),d);\n    d = max(-(abs(p.y)-0.4),d);\n   \n    p = prevP;\n    p*=Rot(radians(-iTime*30.+50.));\n    p = DF(p,16.0);\n    p -= vec2(0.6);\n   \n    p = prevP;\n   \n    p*=Rot(radians(-iTime*30.+50.));\n    float deg = 155.;\n    float a = radians(deg);\n   \n    a = radians(-deg);\n     \n   \n    return min(d,d);\n}\n\nfloat bg(vec2 p){\n    p.y-=iTime*0.1;\n    vec2 prevP = p;\n\n    p*=2.8;\n    vec2 gv = fract(p)-0.5;\n    vec2 gv2 = fract(p*3.)-0.5;\n    vec2 id = floor(p);\n\n    float d = min(B(gv2,vec2(0.02,0.09)),B(gv2,vec2(0.09,0.02)));\n   \n \n    gv+=vec2(0.166,0.17);\n    float d2 = abs(B(gv,vec2(0.169)))-0.004;\n   \n   \n    p = prevP;\n    p = mod(p,0.02)-0.01;\n    d2 = B(p,vec2(0.001));\n    d = min(d,d2);\n   \n    return d;\n}\n\nfloat numberWithCIrcleUI(vec2 p){\n   \n    vec2 prevP = p;\n   \n    p*=SkewX(radians(-15.0));\n    int num = int(mod(iTime*6.0,10.0));\n \n    num = int(mod(iTime*3.0,10.0));\n    float d2 = drawFont(p-vec2(-0.08,0.),num);\n \n   \n    p*=1.5;\n    num = int(mod(iTime*10.0,10.0));\n   \n    num = int(mod(iTime*15.0,10.0));\n   \n   \n    p = prevP;\n   \n    p.x-=0.07;\n    p*=Rot(radians(-iTime*50.));\n    p = DF(p,4.);\n    p -= vec2(0.085);\n \n    p = prevP;\n    d2 = max(-B(p,vec2(0.13,0.07)),d2);\n \n   \n    return d2;\n}\n\nfloat blockUI(vec2 p){\n    vec2 prevP = p;\n    p.x+=iTime*0.05;\n    p.y = abs(p.y)-0.02;\n    p.x = mod(p.x,0.04)-0.02;\n    float d = B(p,vec2(0.0085));\n    p = prevP;\n    p.x+=iTime*0.05;\n    p.x+=0.02;\n    p.x = mod(p.x,0.04)-0.02;\n\n \n    p = prevP;\n    d = max((abs(p.x)-0.2),d);\n    return abs(d)-0.0002;\n}\n\nfloat smallCircleUI(vec2 p){\n    p*=1.1;\n    vec2 prevP = p;\n   \n    float deg = 20.;\n   \n    p*=Rot(radians(sin(iTime*3.)*50.));\n    float d = abs(length(p)-0.1)-0.003;\n   \n    p = DF(p,0.75);\n    p -= vec2(0.02);\n   \n    float a = radians(-deg);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n   \n    p = prevP;\n    p*=Rot(radians(-sin(iTime*2.)*80.));\n    float d2 = abs(length(p)-0.08)-0.001;\n    d2 = max(-p.x,d2);\n    d = min(d,d2);\n   \n    p = prevP;\n    p*=Rot(radians(-iTime*50.));\n    d2 = abs(length(p)-0.05)-0.015;\n    deg = 170.;\n    a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    d = min(d,abs(d2)-0.0005);\n   \n    return d;\n}\n\nfloat smallCircleUI2(vec2 p){\n    vec2 prevP = p;\n    float d = abs(length(p)-0.04)-0.0001;\n    float d2 = length(p)-0.03;\n   \n    p*=Rot(radians(iTime*30.));\n    float deg = 140.;\n    float a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    d = min(d,d2);\n   \n    d2 = length(p)-0.03;\n    a = radians(deg);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-deg);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    d = min(d, d2);\n   \n    d = max(-(length(p)-0.02),d);\n   \n    return d;\n}\n\nfloat rectUI(vec2 p){\n    p*= Rot(radians(45.));\n    vec2 prevP = p;\n    float d = abs(B(p,vec2(0.12)))-0.003;\n   ;\n   \n    return d;\n}\n\nfloat graphUI(vec2 p){\n    vec2 prevP = p;\n    p.x+=0.5;\n    p.y-=iTime*0.25;\n    p*=vec2(1.,100.);\n\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n   \n \n   \n    float w = (abs(sin(iTime)+0.25)*0.03)*0.5;\n    float d = B(gv,vec2(w, 0.1));\n   \n    p = prevP;\n    d = max((abs(p.x)-0.2),d);\n    d = max((abs(p.y)-0.2),d);\n   \n    return d;\n}\n\nfloat staticUI(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.005,0.13));\n   \n    d = min(d,d);\n    return d;\n}\n\nfloat arrowUI(vec2 p){\n    vec2 prevP = p;\n    p.x*=-1.;\n    p.x-=iTime*0.12;\n    p.x = mod(p.x,0.07)-0.035;\n    p.x-=0.0325;\n   \n    p*=vec2(0.9,1.5);\n    p*=Rot(radians(90.));\n    float d = Tri(p,vec2(0.05),radians(45.));\n    d = max(-Tri(p-vec2(0.,-0.03),vec2(0.05),radians(45.)),d);\n    d = abs(d)-0.0005;\n    p = prevP;\n    d = max(abs(p.x)-0.15,d);\n    return d;\n}\n\nfloat sideLine(vec2 p) {\n    p.x*=-1.0;\n    vec2 prevP = p;\n    p.y = abs(p.y)-0.17;\n    p*=Rot(radians(45.));\n    float d = B(p,vec2(0.035,0.01));\n \n    return abs(d)-0.0005;\n}\n\nfloat sideUI(vec2 p){\n    vec2 prevP = p;\n    p.x*=-1.;\n    p.x+=0.025;\n   \n    p = prevP;\n    p.y= abs(p.y)-0.275;\n    float d2 = sideLine(p);\n   \n    return d2;\n}\n\n\nfloat GetDist(vec3 p) {\n    vec3 prevP = p;\n   \n    p.z+=0.7;\n    float maxThick = 0.03;\n    float minThick = 0.007;\n    float thickness = maxThick;\n    float frame = mod(iTime,30.);\n    float time = frame;\n   \n     \n   \n    float d = ring0(p.xy);\n    d = max((abs(p.z)-thickness),d);\n   \n    p.z-=0.2;\n    float d2 = ring1(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n   \n    p.z-=0.2;\n    d2 = ring2(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n       \n    p.z-=0.2;\n    d2 = ring3(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n           \n    p.z-=0.2;\n    d2 = ring4(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n   \n    p.z-=0.2;\n    d2 = ring5(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n   \n    p.z-=0.2;\n    d2 = ring6(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n   \n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, int stepnum) {\n    vec3 res = vec3(0.0);\n    float steps = 0.0;\n    float alpha = 0.0;\n   \n    float tmax = 5.;\n    float t = 0.0;\n   \n    float glowVal = 0.003;\n   \n    for(float i=0.; i<float(stepnum); i++) {\n        steps = i;\n        vec3 p = ro + rd*t;\n        float d = GetDist(p);\n        float absd = abs(d);\n\n        if (t > tmax) break;\n\n        alpha += 1.0 - smoothstep(0.0,glowVal, d);        \n        t += max(0.0001, absd * 0.6);\n    }\n    alpha /= steps;\n   \n    res += alpha * vec3(1.5);\n    return res;\n}\n#define R(p,a,r) mix(a*dot(p,a),p,cos(r)) + sin(r)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvec3 color(float t) {\n  vec3 c1 = vec3(1.0, 0.0, 0.0);\n  vec3 c2 = vec3(0.0, 1.0, 0.0);\n  vec3 c3 = vec3(0.0, 0.0, 1.0);\n  vec3 c4 = vec3(1.0, 1.0, 0.0);\n  vec3 c5 = vec3(1.0, 0.0, 1.0);\n  vec3 c6 = vec3(0.0, 1.0, 1.0);\n\n  float r = cos(t) * 0.5 + 0.5;\n  if (r < 0.23) return mix(c1, c2, r * 5.0);\n  if (r < 0.44) return mix(c2, c3, (r - 0.2) * 5.0);\n  if (r < 0.65) return mix(c3, c4, (r - 0.4) * 5.0);\n  if (r < 0.86) return mix(c4, c5, (r - 0.6) * 5.0);\n  return mix(c5, c6, (r - 0.8) * 7.0);\n}\n\nvec3 R2(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nconst float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    C_linear = clamp(C_linear, 0., 1.);\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nfloat lengthSquared(vec3 v) { return dot(v,v); }\n\nfloat sphere_depth(vec3 pos, float radius, vec3 ro, vec3 rd)\n{\n    float d2 = lengthSquared(cross(pos-ro, rd));\n    float x2 = radius*radius - d2;\n    if(x2 < 0.) return 0.;\n    float depth = 2. * sqrt(x2);\n    return depth;\n}\n\nstruct Sphere\n{\n    vec3 pos;\n    vec3 color;\n    float density;\n    float radius;\n};\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.)));\n        p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01),cos(iTime*0.01));// tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\n\na*=a*a; // add contrast\nif (r>6) fade*=1.2; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,1.);\nfloat time=iTime*speed+.25;\n  float time2 = .75 * iTime;\nuv*=2.;\nvec4 fragColor2 = vec4(0);\n    vec3 p, r = iResolution, d = normalize(vec3((fragCoord-.5*r.xy)/r.y,0.7));  \n   \n    for(float i = 0., g = 0., e, s; i < 99.; ++i)\n    {\n        p = g * tan(d);\n        p.z -= 0.60;\n        p = R(p, normalize(vec3(1,2,3)), iTime * 0.0);\n        s = 4.;\n\n        for(int j = 0; j++ < 14;)\n        {\n            p = abs(p);\n            p = p.x < p.y ? p.zxy : p.zyx;\n            s *= e = 1.8 / min(dot(p, p), 1.3);\n            p = p * e - vec3(15,3,2);\n        }\n\n        g += e = length(p.xz) / s;\n        fragColor2.rgb += color(iTime * 0.1 + cos(i)) * mix(r / r, H(log(s)), 0.7) * 0.08 * exp(-i * i * e);\n    }\n   \n   \n\n   \n    float c = cos(time2);\n    float s = sin(time2);\n    vec3 ro = 15. * vec3(c, 0., s) + vec3(0,0,0);\n    float focal = 2.;\n    vec3 rd = normalize(vec3(uv, -focal));\n    rd.xz = mat2(s, -c, c, s) * rd.xz;\n   \n    vec3 color = vec3(0.);\n        vec2 m =  iMouse.xy/iResolution.xy;\n   \n    vec3 ro2 = vec3(0, 0, -2.1);\n    if(iMouse.z>0.){\n        ro2.yz *= Rot(m.y*3.14+1.);\n        ro2.y = max(-0.9,ro.y);\n        ro2.xz *= Rot(-m.x*6.2831);\n         float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(ro2.xy) + .07)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);\n    ro2.xy*=ma;\n    } else {\n   \n        float YZ = 45.;\n        float ogRXZ = 50.;\n        float animRXZ = 20.;\n       \n        float frame = mod(iTime,30.);\n        float time = frame;\n\n        if(frame>=10.0 && frame<20.){\n            time = getTime(time-10.0,1.5);\n           \n            YZ = 45.-cubicInOut(time)*45.0;\n            ogRXZ = 50.-cubicInOut(time)*50.0;\n            animRXZ = 20.-cubicInOut(time)*20.0;\n        } else if(frame>=20.){\n            time = getTime(time-20.0,1.5);\n           \n            YZ = cubicInOut(time)*45.0;\n            ogRXZ = cubicInOut(time)*50.0;\n            animRXZ = cubicInOut(time)*20.0;\n        }\n   \n        ro2.yz *= Rot(radians(YZ));\n        ro2.xz *= Rot(radians(sin(iTime*0.3)*animRXZ+ogRXZ));\n    }\n   \n    vec3 rd2 = R2(uv, ro2, vec3(0,0.0,0), 1.0);\n    vec3 d2 = RayMarch(ro2, rd2, MAX_STEPS);\n    vec3 col = vec3(.0);\n \n \n\n    col=mix(col,d2.xyz,0.7);\n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n   \n \n    vec3 green = vec3(0.05,.675,.3);\n    vec3 pink = vec3(.675, 0.05, .3);\n    vec3 purple = vec3(.3, 0.05, .675);\n    vec3 blue = vec3(0.05, .3, .675);\n    vec3 yellow = vec3(0.95, .7, .325);\n        uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n   \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n   \n    Sphere[5] spheres;\n   \n    spheres[0].pos = vec3(0,sin(iTime)*.5,0);\n    spheres[0].radius = 8.0;\n    spheres[0].density = 0.5;\n    spheres[0].color = pink;\n   \n    spheres[1].pos = 2.*vec3(cos(iTime)*5.75,0,1);\n    spheres[1].radius = 2.0;\n    spheres[1].density = 0.75;\n    spheres[1].color = yellow;\n\n    spheres[2].pos = vec3(cos(iTime)*5.75,sin(iTime*.5)*4.,2);\n    spheres[2].radius = 3.;\n    spheres[2].density = 0.25;\n    spheres[2].color = blue;\n   \n    spheres[3].pos = vec3(cos(iTime*2.)*5.75,sin(iTime*2.5)*4.,3);\n    spheres[3].radius = 1.5;\n    spheres[3].density = 0.7;\n    spheres[3].color = green;\n   \n    spheres[4].pos = vec3(sin(iTime*1.5)*5.75, .7*sin(iTime*1.5*PI)*4.,4);\n    spheres[4].radius = 1.;\n    spheres[4].density = 0.9;\n    spheres[4].color = purple;\n   \n   \n    // sorting\n    float z[5];\n   \n    int[5] order = int[5](0,1,2,3,4);\n   \n    // Sphere center projected onto line from origin to camera\n    for (int i = 0; i < 5; i++)\n        z[i] = dot(spheres[i].pos, normalize(ro));\n   \n    // Bubble sort :)\n    for (int i = 0; i < 4; i++)\n    for (int j = 4; j > i; j--)\n    {\n        int a = j-1, b = j;\n       \n        // Swap if lowest element is nearer camera, so we draw back to front\n        // (i.e higher value z from origin, kinda reversed z from camera )\n        if(z[order[a]] > z[order[b]])\n        {\n            order[a] ^= order[b];\n            order[b] ^= order[a];\n            order[a] ^= order[b];\n        }\n    }\n   \n    // Draw splats\n    for(int i = 0; i < 5; i++)\n    {\n        int j = order[i];\n        float depth = sphere_depth(spheres[j].pos, spheres[j].radius, ro, rd);\n        float transmission = exp(-spheres[j].density*depth);\n        color = mix(spheres[j].color, color, transmission);\n    }\n   \n    // Optional tonemapping\n    #if 0\n    color = tanh(color);\n    #endif\n   \n    color = sRGBencode(color);\n \n        dir*=fragColor2.xyz;\nvec3 from=vec3(1.,.5,0.5)*color*col;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n     fragColor*= vec4(cheap_star(uv,anim) * vec3(1.35,1.2,1.15)*0.5, 1.0);\n \n}\n\n","name":"Image","description":"","type":"image"}]}