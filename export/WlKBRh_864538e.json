{"ver":"0.1","info":{"id":"WlKBRh","date":"1613862482","viewed":79,"name":"mouvvv","username":"yuuuui","description":"ca bouge ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length4( vec2 p )\n{\n\tp = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/4.0 );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 4.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/0.4 );\n}\n\nfloat length8( vec3 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/8.0 );\n}\n\n\n\n\n//-------------------------------------------------\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder4( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length4(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length4(max(d,0.0));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length2(q)-t.y;\n}\n\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdSphere8( in vec3 p, in float r )\n{\n    return length8(p)-r;\n}\n\n//---------------------------------\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    float popox = (iMouse.x / iResolution.x * 2.) - 1.5;\n    float popoy = (iMouse.y / iResolution.y * 2.) - 0.5;\n    \n\n    // double onion sphere\n    {\n    vec3 q = pos - vec3(popox,popoy,tan(popox * popoy));\n    d = min( d, sdSphere8( q, 0.4 ) );\n    }\n    \n    \n    // double onion sphere2\n    {\n    vec3 q = pos - vec3(popox,popoy,tan(popox * popoy));\n    d = min( d, sdSphere8( q, 0.04 ) );\n    }\n\n\n     \n    // single onion cylinder\n    {\n    vec3 q = pos - vec3(popox,popoy,tan(popox - popoy));\n    d = min( d, sdCappedCylinder4( q, vec2(4.4,0.2) ) );\n    }\n\n   \n    \n    // single onion torus\n    {\n    vec3 q = pos - vec3(popox,popoy,tan(popox + popoy));\n    d = min( d, sdTorus82( q, vec2(popox,4.1) ) );\n    }\n\n    // torus\n    {\n    vec3 q = pos - vec3(popox,popoy,tan(popox * popoy));\n    d = min( d, sdTorus( q.xzy, vec2(0.5,0.2) ) );\n    }\n    \n      // torus\n    {\n    vec3 q = pos - vec3(popox,popoy,tan(popox * popoy));\n    d = min( d, sdTorus( q.xzy, vec2(1,0.2) ) );\n    }\n    \n         // torus\n    {\n    vec3 q = pos - vec3(popox,popoy,tan(popox * popoy));\n    d = min( d, sdTorus( q.xzy, vec2(2,0.01) ) );\n    }\n    \n\n\n \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) -\n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 4.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(-0.4,4.0,5);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.0),-2.0));\n\n        float t = 5.0;\n        for( int i=0; i<80; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.0002 || t>10.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<10.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.18,0.2)*amb + \n                  vec3(0.1,0.6,0.2)*dif;\n                  //zone pour couleur a ne pas oublier 0 est violet\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 0.2 );\n}","name":"Image","description":"","type":"image"}]}