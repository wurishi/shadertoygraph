{"ver":"0.1","info":{"id":"4tGfWR","date":"1543104053","viewed":305,"name":"Moon gleam","username":"jsen","description":"A test to see how wave deformation affects the light column formed by the moon's reflection on water.\nImproved waves using code from https://www.shadertoy.com/view/Ms2SD1","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["moon","lightcolumn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 LIGHT_POS = vec3(0.0, 10.0, -100.0);\nconst vec3 LIGHT_COL = vec3(0.7, 0.7, 0.9);\nconst vec3 WATER_COL = vec3(0.4, 0.7, 1.0);\n\nconst float WAVE_FREQ = 1.0;\nconst float WAVE_AMP = 0.03;\nconst float WAVE_SPEED = 0.3;\nconst float SPEC_EXP = 64.0;\n\n\nfloat rand( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( rand( i + vec2(0.0,0.0) ), \n                     rand( i + vec2(1.0,0.0) ), u.x),\n                mix( rand( i + vec2(0.0,1.0) ), \n                     rand( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat sphereDF(vec3 p, float rad) {\n    return length(p) - rad;\n}\n\nfloat oct(vec2 uv) {\n    uv += noise(uv);\n    uv = 1.0 - abs(sin(uv));\n    return pow(1.0 - uv.x * uv.y, 8.0);\n}\n\nfloat waveDist(vec3 p) {\n    vec2 uv = p.xz;\n    \n    float d = 0.0;\n    float freq = WAVE_FREQ;\n    float amp = WAVE_AMP;\n    for (int i = 0; i < 3; ++i) {\n        d += amp * oct((uv + (2.0 + iTime) * WAVE_SPEED) * freq);\n        d += amp * oct((uv - (2.0 + iTime) * WAVE_SPEED) * freq);\n        amp *= 0.5;\n        freq *= 1.5;\n    }\n    \n    return d;\n}\n\nfloat planeDF(vec3 p, float y) {\n    return p.y - y;\n}\n\nfloat boxDF(vec3 p, vec3 b) {\n    return length(max(abs(p) - b, 0.0)) - 0.1;\n}\n\nfloat capDF(vec3 p, float h, float r) {\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat subDF(float a, float b) {\n    return max(a, -b);\n}\n\nvec4 mapU(vec4 a, vec4 b) {\n    return a.w < b.w ? a : b;\n}\n\nfloat waves(vec3 p, float y) {\n    return planeDF(p, y) - waveDist(p);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         );\n}\n\nfloat moon(vec3 p, float r) {\n    return sphereDF(p, r);\n}\n\nvec4 map(vec3 p) {\n    vec4 ret =      vec4(vec3(0.0), waves(p, -1.0));\n    ret = mapU(ret, vec4(LIGHT_COL, moon(p - LIGHT_POS, 2.0)));\n    \n    return ret;\n}\n\nvec3 normal(vec3 p) {\n    float eps = 0.01;\n    vec3 norm = vec3(\n        map(vec3(p.x + eps, p.y, p.z)).w - map(vec3(p.x - eps, p.y, p.z)).w,\n        map(vec3(p.x, p.y + eps, p.z)).w - map(vec3(p.x, p.y - eps, p.z)).w,\n        map(vec3(p.x, p.y, p.z + eps)).w - map(vec3(p.x, p.y, p.z - eps)).w\n    );\n    return normalize(norm);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    for (float t = mint; t < maxt;) {\n        float h = map(ro + rd * t).w;\n        if (h < 0.001)\n            return res;\n        t += h;\n        res = min(res, k * h / t);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    float mint = 0.0;\n    float maxt = 150.0;\n    \n    bool found = false;\n    vec3 surfPos = ro;\n    vec3 mapCol = vec3(0.0);\n    for (float t = mint; t < maxt;) {\n        surfPos = ro + t * rd;\n        vec4 mapVal = map(surfPos);\n        float h = mapVal.w;\n        if (h < 0.001) {\n            found = true;\n            mapCol = mapVal.xyz;\n            break;\n        }\n        t += h;\n    }\n    \n    vec3 col = vec3(1.0);\n    if (found && mapCol != LIGHT_COL) {\n        vec3 norm = normal(surfPos);\n        vec3 ref = reflect(rd, norm);\n        float ndl = dot(ref, normalize(LIGHT_POS - surfPos));\n\n        vec3 amb = 0.1 * normalize(LIGHT_COL);\n        vec3 dif = normalize(WATER_COL);\n        dif *= 0.1 * ndl;\n        \n        vec3 spe = normalize(LIGHT_COL);\n        spe *= pow(ndl, SPEC_EXP);\n\n        col = amb + dif + spe;\n    } else if (mapCol == LIGHT_COL) {\n        vec3 p = normalize(surfPos - LIGHT_POS);\n        vec2 sph = vec2(acos(p.z), atan(p.y / p.x));\n        \n        col = normalize(LIGHT_COL);\n        col *= vec3(0.5 + sin(p.x) + sin(p.z));\n        col -= 0.1 * (1.0 + noise(4.0 * sph));;\n    } else {\n        col = vec3(0.05, 0.07, 0.1);\n    }\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouseCurr = iMouse.xy / iResolution.xy;\n    \n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(0.0, 15.0 * (1.0 - mouseCurr.y), 50.0);\n    vec3 ro = camPos;\n    mat3 ca = setCamera(ro, vec3(0.0), 0.0);\n    vec3 rd = ca * normalize(vec3(p, 3.2));\n\n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}