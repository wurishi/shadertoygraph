{"ver":"0.1","info":{"id":"3sGfRy","date":"1610988823","viewed":50,"name":"MandelbrotSetHWK","username":"MattyHarv","description":"Assignment","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ITERATIONS = 256.0;\nfloat LIMIT = 4.0;\n\nvec4 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(1.,2.,2.),6.)-3.)-1.,0.,1.);\n  //vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  vec3 color = c.z * mix(vec3(1.0), rgb, c.y);\n   return vec4(color,1);\n}\n\nvec4 colormap(float i)\n{\n    if(i == ITERATIONS)\n        return vec4(0,0,0,1);\n    vec3 hsv = vec3(float(i)/ITERATIONS,1,1);\n    \n\treturn hsv2rgb(hsv);\n}\n\nvec4 MandelbrotColor( vec2 c )\n{\n    vec2 z = vec2(0,0);\n    float i = 0.0;\n    for (i=0.0;i<ITERATIONS;i++) {\n    \n    //Z = Z^2 + C - Algorithm for mandlebrot set\n    vec2 znew = vec2(z.x * z.x - z.y *z.y, 2.0 * z.x* z.y) + c;\n      if (dot(znew,znew) > LIMIT)\n         break;\n         z = znew;\n   }\n   \n   return colormap(i);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Shrank image to see the whole of the set\n    uv = (2.5 *fragCoord - iResolution.xy) / iResolution.xy;\n    //Centres image \n\tuv -= vec2(0.3, -0.3);\n    uv.x *= iResolution.x/iResolution.y;\n    \n            /* POINTS OF INTEREST\n    vec2 centre = vec2(-0.761574, -0.0847596);\n    vec2 centre = vec2(-0.412 , 0.609);\n    vec2 centre = vec2(0.278039575 , -0.007910056);\n    vec2 centre = vec2(-0.107631967 , -0.908353935);\n    vec2 centre = vec2(-0.290693391 , 0.670809656);*/\n    vec2 centre = vec2(-0.384264141 , -0.600523952);\n    \n    float angle = iTime* 0.75;\n    mat2 rotationMatrix = mat2( cos(angle), sin(angle),\n                               \t-sin(angle),  cos(angle));\n                                \n    //Makes a cos curve that oscillates equally above / below 0, used minus to start zoomed out\n    float cc = 4.5*-cos(0.25 * iTime) + 4.25; \n    //Smooths out the curve, making it less erratic \n    float zoom = pow(0.25, cc);\n    //Zooms in and out on the centre coordinates\n    uv *= zoom;\n    uv += centre;\n    //Applies rotation matrix about centre point\n    uv = rotationMatrix *(uv - centre) + centre ;\n\t\n    // Output to screen\n    fragColor = MandelbrotColor(uv);\n}","name":"Image","description":"","type":"image"}]}