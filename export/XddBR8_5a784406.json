{"ver":"0.1","info":{"id":"XddBR8","date":"1524240779","viewed":160,"name":"Simple light and shadow","username":"darkeclipz","description":"Testing a simple light and shadow with a circle. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","shadow","testing","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Circle line segment collision from:\n// https://stackoverflow.com/questions/1073336/circle-line-segment-collision-detection-algorithm\n\nstruct circle { vec2 pos; float r; };\n\nbool inCircle(vec2 uv, vec2 xy, float r) {\n\treturn length(xy-uv) < r;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-R/2.)/R.y;\n    vec3 col = vec3(0);\n    \n    // Light source\n    vec2 Lpos = vec2(0., 0.);\n    vec2 L = uv - Lpos;\n    \n    // Circle\n    circle C = circle(vec2(cos(iTime)/3., sin(iTime)/3.), 0.1);\n\n\tvec2 E = uv;\t \t// Ray start pos\n    vec2 d = L;\t\t    // Ray end pos\n    vec2 f = C.pos-uv;\t// Direction vector of start pos and circle center.\n    \n    // Solve y=ax^2+bx+c\n    float a = dot(d,d);\t\t\t\t// d dot d\n    float b = 2. * dot(d, f);\t\t// 2 * d dot f\n    float c = dot(f, f) - C.r*C.r;\t// f dot f - r^2\n    \n    float discr = b*b-4.*a*c; // discr < 0; no intersection\n    \t\t\t\t\t\t  // discr = 0; 1 intersection\n    \t\t\t\t\t\t  // discr > 0; 2 intersections\n    \n    // next time: check for t1, t2, and determine real intersection.\n    // https://stackoverflow.com/questions/1073336/circle-line-segment-collision-detection-algorithm\n\n\t// Background light color\n    col = mix(col, vec3(1), 0.20-length(L)/32.);\n    \n    // Light source\n    col = mix(col, vec3(1), inCircle(uv, Lpos, 0.1) ? 1.-length(uv-Lpos)/.1 : 0.);\n    col = mix(col, vec3(1), inCircle(uv, Lpos, 0.05) ? 1.-length(uv-Lpos)/.05 : 0.);\n    col = mix(col, vec3(1), inCircle(uv, Lpos, 0.02) ? 1.-length(uv-Lpos)/.03 : 0.);\n    \n    // Light\n    col = mix(col, vec3(1), .15 * max(0., 1.-length(uv-Lpos)/.80));\n    col = mix(col, vec3(1), .15 * max(0., 1.-length(uv-Lpos)/.40));\n    col = mix(col, vec3(1), .15 * max(0., 1.-length(uv-Lpos)/.20));    \n    \n    // Shadow\n    col = mix(col, vec3(0), discr > 0. \n              \t\t\t \t&& length(Lpos-uv) > length(Lpos-C.pos)\n              \t\t\t\t&& length(Lpos-uv) > length(C.pos-uv) ? .50 : 0.); \n    \n    // Circle\n    col = mix(col, vec3(1), float(inCircle(uv, C.pos, C.r)));\n    col = mix(col, vec3(0), float(inCircle(uv, C.pos, C.r-0.005)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}