{"ver":"0.1","info":{"id":"NsfBDB","date":"1645292293","viewed":141,"name":"Ray Marching Reflections","username":"rucksack","description":"Used The Art of Code's tutorial (https://www.youtube.com/watch?v=PGtv-dBi2wE) as basis.\nMade use of some of Inigo Quilez' articles (https://iquilezles.org/).\nAdded reflections, specular highlights and smooth shadows.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching parameters\n#define MAX_STEPS 300\n#define NEAR_ENOUGH 0.001\n#define TOO_FAR 100.0\n\n// Lighting parameters\n#define SHADOW_FACTOR 10.\n#define DIFFUSE_FACTOR 0.5\n#define SPECULAR_FACTOR 0.8\n#define SHININESS 64.\n#define FRESNEL_BIAS 0.3\n#define FRESNEL_POWER 2.1\n#define FRESNEL_SCALE 20.\n\n// SDFs\n\nfloat sphereDistance(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\n// From https://iquilezles.org/articles/distfunctions\nvec3 repeat(vec3 point, vec3 period, vec3 limit) {\n    return point - period*clamp(round(point/period),-limit,limit);\n}\n\nfloat distanceFromEverything(vec3 point) {\n    float planeDist = point.y + 0.02; // plane at y=-term\n    vec3 repeated = repeat(point, vec3(3, 0, 3), vec3(10, 1, 3));\n    float sphereDist = sphereDistance(repeated, vec3(0, 1, 6), 1.);\n    repeated = repeat(point, vec3(3, 0, 3), vec3(10, 1, 2));\n    float midSphereDist = sphereDistance(repeated, vec3(-0.5, 0.5, 6), .5);\n\n    float dist = min(planeDist, sphereDist);\n    dist = min(dist, midSphereDist);\n    return dist;\n}\n\n// Rays and lighting\n\nfloat rayMarch (vec3 rayorig, vec3 raydir) {\n    // How far we've traveled\n    float dist = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = rayorig + raydir*dist;\n        // How far anything is from us\n        float scenedist = distanceFromEverything(point);\n        // March on\n        dist += scenedist;\n        // Check status - have we reached a surface?\n        if (scenedist < NEAR_ENOUGH || dist > TOO_FAR)\n            break;\n    }\n    return dist;\n}\n\n// Using smooth shadow trick from https://iquilezles.org/articles/rmshadows\n// (does not look perfectly right :))))\nfloat rayMarchShadow (vec3 rayorig, vec3 raydir) {\n    // How far we've traveled\n    float shade = 1.0;\n    float stepdist = NEAR_ENOUGH;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = rayorig + raydir*stepdist;\n        // How far anything is from us\n        float nextdist = distanceFromEverything(point);\n        // Update penumbra factor\n        shade = min(shade, SHADOW_FACTOR * nextdist/stepdist);\n        // March on\n        stepdist += nextdist;\n        // Check status - have we reached a surface?\n        if (nextdist < NEAR_ENOUGH || stepdist > TOO_FAR)\n            break;\n    }\n    // Stop shadows from going too negative\n    return max(shade, -0.3);\n}\n\nvec3 normal(vec3 point) {\n    vec2 e = vec2(.01, 0); // x smol, y none\n    float dist = distanceFromEverything(point);\n    // Find normal as tangent of distance function\n    return normalize(dist - vec3(\n        distanceFromEverything(point - e.xyy),\n        distanceFromEverything(point - e.yxy),\n        distanceFromEverything(point - e.yyx)\n    ));\n}\n\nfloat light(vec3 point, vec3 lightpos, vec3 n, vec3 cam) {\n    vec3 l = normalize(lightpos-point);\n    // Standard diffuse term\n    float diffuse = max(dot(n, l), 0.);\n    float specular = pow(max(dot(reflect(-l, n), -cam), 0.), SHININESS);\n\n    return DIFFUSE_FACTOR * diffuse + SPECULAR_FACTOR * specular;\n}\n\nfloat shadow(vec3 point, vec3 lightpos, vec3 n) {\n    vec3 l = normalize(lightpos-point);\n    // Shadow factor\n    float shade = 1.;\n    // March to the light\n    return rayMarchShadow(point + n*NEAR_ENOUGH*2., l);\n    // WOOOOO YEAH\n}\n\n// From https://developer.download.nvidia.com/CgTutorial/cg_tutorial_chapter07.html\nfloat fresnel(vec3 i, vec3 n) {\n    return max(0., min(1., FRESNEL_BIAS + FRESNEL_SCALE * pow(1. + dot(i, n), FRESNEL_POWER)));\n}\n\nfloat fullLighting(vec3 point, vec3 camPos, vec3 camDir) {\n    // Avoid casting specular highlight from the void\n    if (length(point - camPos) > TOO_FAR*0.99)\n        return 0.;\n\n    vec3 lightpos = vec3(0, 5, 6);\n    lightpos.xz += vec2(2.*sin(iTime), 2.*cos(iTime));\n    vec3 l = normalize(lightpos-point);\n    vec3 n = normal(point);\n\n    // Get the standard light\n    float base = light(point, lightpos, n, camDir);\n    float shade = shadow(point, lightpos, n);\n    base *= shade;\n\n    float reflected = 0.;\n    // Don't reflect if in shadow or this is part of the ground.\n    if (shade > .5 && point.y > NEAR_ENOUGH ) {\n        // Find reflection!\n        vec3 ray = reflect(-l, n);\n        // March in direction of reflection\n        float rdist = rayMarch(point + ray*NEAR_ENOUGH*2., ray);\n        vec3 rpoint = point + ray*rdist;\n        // Find lighting there (though don't account for reflections recursively)\n        reflected = light(rpoint, lightpos, n, camDir) * shadow(rpoint, lightpos, n);\n        // Apply the Fresnel effect, https://en.wikipedia.org/wiki/Fresnel_equations\n        reflected *= fresnel(camDir, n);\n    }\n    \n    return base + reflected;\n}\n\n\n// From assignment template code in TDT4230\nfloat rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }\nfloat dither(vec2 uv) { return (rand(uv)*2. - 1.) / 256.; }\n\n// Start!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    // Ray origin\n    vec3 campos = vec3(0, 1, 0);\n    // Direction, with periodic zoom\n    vec3 raydir = normalize(vec3(uv, 2.5 + cos(.7 + .2*iTime)));\n\n    float dist = rayMarch(campos, raydir);\n    \n    vec3 surfacePoint = campos + raydir * dist;\n    \n    vec3 color = vec3(fullLighting(surfacePoint, campos, raydir) * 1.);\n    \n    // Gamma correction not from the video :))))\n    color = pow(color, vec3(.4545)) + vec3(0.13, 0.1, 0.);\n\n    // Output to screen\n    fragColor = vec4(color + dither(fragCoord),1.0);\n}\n","name":"Image","description":"","type":"image"}]}