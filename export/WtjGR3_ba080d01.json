{"ver":"0.1","info":{"id":"WtjGR3","date":"1560501619","viewed":271,"name":"Fire in the Wind - 2","username":"GabrieleGiuseppini","description":"Reverse-engineered \"Flame in the Wind\" by kuvkar, and changed it in order to render burning fire rather than candle fire.\n\nTo be used in Floating Sandbox (https://gamejolt.com/games/floating-sandbox/353572).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Based on \"Flame in the Wind\" by kuvkar (https://www.shadertoy.com/view/4tXXRn)\n//\n\nfloat GetNoise(vec2 uv) // -> (0.25, 0.75)\n{\n    float n = (texture(iChannel0, uv).r - 0.5) * 0.5;\n    n += (texture(iChannel0, uv * 2.0).r - 0.5) * 0.5 * 0.5;\n    \n    return n + 0.5;\n}\n\nmat2 GetRotationMatrix(float angle)\n{\n    mat2 m;\n    m[0][0] = cos(angle); m[0][1] = -sin(angle);\n    m[1][0] = sin(angle); m[1][1] = cos(angle);\n\n    return m;\n}\n\n\n#define paramWindSpeedMagnitude -80.0\n#define flamePersonalitySeed 1000.0\n\n// -----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5); // (x=[-0.5, 0.5], y=[-0.5, 0.5])\n    vec2 flameSpacePosition = uv + vec2(0.0, 0.5); // (x=[-0.5, 0.5], y=[0.0, 1.0])\n    uv.y /= (iResolution.x / iResolution.y); // obey aspect ratio\n    \n    float paramTime = iTime;\n    \n    ////////////////////////////////////////\n    \n    //\n    // Flame time\n    //\n    \n    #define FlameSpeed 0.23\n    float flameTime = paramTime * FlameSpeed;\n\n    //\n    // Apply wind\n    //\n    \n    // Rotation angle\n    float windAngle = -sign(paramWindSpeedMagnitude) * 0.4 * smoothstep(0.0, 100.0, abs(paramWindSpeedMagnitude));\n    \n    // Rotation angle is higher the higher we go\n    windAngle *= flameSpacePosition.y;\n\n    // Make rotation angle time-dependent\n    windAngle *= (1.0 + sin(iTime)) / 2.0;\n    \n    // Rotate around bottom\n    uv = GetRotationMatrix(windAngle) * (uv + vec2(0.0, 0.5)) - vec2(0.0, 0.5);\n\n    \n    //\n    // Get noise for this fragment and time\n    //\n    \n    #define NoiseResolution 0.7\n    float fragmentNoise = GetNoise(uv * NoiseResolution + vec2(flamePersonalitySeed)/777.0 + vec2(0.0, -flameTime/0.8));\n    \n    \n    //\n    // Rotate fragment based on noise and vertical extent\n    //\n    \n    float angle = (fragmentNoise - 0.5);\n\n    // Magnify rotation amount based on distance from center of quad\n    angle /= max(0.1, length(uv));\n\n    // Straighten the flame at the bottom and make full turbulence higher up\n    angle *= smoothstep(-0.1, 0.5, flameSpacePosition.y);\n\n    // Smooth the angle\n    angle *= 0.45;\n\n    // Rotate!\n    uv += GetRotationMatrix(angle) * uv;    \n    \n    \n    \n    //\n    // Calculate thickness\n    //\n    \n    #define FlameWidth 0.5\n    float thickness = 1.0 - smoothstep(0.1, FlameWidth, abs(uv.x));\n    \n    // Taper flame depending on randomized height\n    float variationH = fragmentNoise * 1.4;\n    thickness *= smoothstep(1.3, variationH * 0.5, flameSpacePosition.y); // Taper up\n    thickness *= smoothstep(-0.15, 0.15, flameSpacePosition.y); // Taper down\n    \n    // Focus (less halo, larger body)\n    #define FlameFocus 2.0\n    thickness = pow(clamp(thickness, 0.0, 3.0), FlameFocus);\n\n    \n    //\n    // Emit\n    //\n    \n    vec3 col1 = mix(vec3(1.0, 1.0, 0.6), vec3(1.0, 1.0, 1.0), thickness);\n    col1 = mix(vec3(1.0, 0.4, 0.1), col1, smoothstep(0.3, 0.8, thickness));    \n\n    // Blend with background\n    float alpha = smoothstep(0.0, 0.5, thickness);\n    fragColor = mix(vec4(1.0), vec4(col1, 1.0), alpha);\n}","name":"Image","description":"","type":"image"}]}