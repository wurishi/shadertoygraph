{"ver":"0.1","info":{"id":"ddVBRm","date":"1698085482","viewed":95,"name":"Lenia Pt.8 (DLC + New Arrays)","username":"26apastor","description":"I implemented a simulation of Lenia that uses every upgrade possible: Continuous time, states, space and arrays, multiple rings, multiple kernels, multiple channels, a soft clip function, and asymptotic update using a target function.\n(Extremely stable)","likes":4,"published":1,"flags":32,"usePreview":1,"tags":["automata","life","cellular","continuous","artificial","lenia"],"hasliked":0,"parentid":"cdVBRm","parentname":"Lenia Pt.7 Multi-channel arrays"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float nop        = 0.0;\nconst int inop         = 0;\nconst ivec4 iv0        = ivec4(0);\nconst ivec4 iv1        = ivec4(1);\nconst ivec4 iv2        = ivec4(2);\nconst vec4 v0          = vec4(0);\nconst vec4 v1          = vec4(1);\n\n\nconst mat4 rmu = mat4(vec4(0.5), vec4(0.5), vec4(0.5), vec4(0.5));\nconst mat4 rsigma = mat4(vec4(0.15), vec4(0.15), vec4(0.15), vec4(0.15));\n\nconst float noise_base = 0.165;\nconst float noise_width = 111.0;\nconst float max_radius = 11.;\nconst float T = 2.;\nconst mat4    betaLen = mat4( 1., 1., 2., 2., 1., 2., 1., 1., 1., 2., 2., 2., 1., 2., 1., v0 );  // kernel ring number\nconst mat4      beta0 = mat4( 1., 1., 1., 0., 1., 3./4., 1., 1., 1., 11./12., 3./4., 1., 1., 1./4., 1., v0 );  // kernel ring heights\nconst mat4      beta1 = mat4( 0., 0., 1./4., 1., 0., 1., 0., 0., 0., 1., 1., 11./12., 0., 1., 0., v0 );\nconst mat4      beta2 = mat4( v0, v0, v0, v0 );\nconst mat4         mu = mat4( 0.282, 0.354, 0.197, 0.164, 0.406, 0.251, 0.259, 0.517, 0.455, 0.264, 0.362, 0.167, 0.208, 0.395, 0.184, v0 );  // growth center\nconst mat4      sigma = mat4( 0.0646, 0.1584, 0.0359, 0.056, 0.0738, 0.0383, 0.0665, 0.0564, 0.1806, 0.2437, 0.0439, 0.0666, 0.0815, 0.1049, 0.0748, v1 );  // growth width\nconst mat4        eta = mat4( 0.082, 0.544, 0.26, 0.594, 0.508, 0.66, 0.326, 0.21, 0.438, 0.346, 0.384, 0.748, 0.44, 0.366, 0.294, v0 );  // growth strength\nconst mat4       relR = mat4( 0.85, 0.62, 0.69, 0.84, 0.82, 0.86, 1.0, 0.5, 0.78, 0.6, 0.5, 0.7, 0.67, 0.6, 0.8, v1 );  // relative kernel radius\nconst mat4 c0    = mat4( 0., 0., 0., 1., 1., 1., 2., 2., 2., 0., 0., 1., 1., 2., 2., nop );  // source channels\nconst mat4 c1    = mat4( 0., 0., 0., 1., 1., 1., 2., 2., 2., 1., 2., 0., 2., 0., 1., nop );  // destination channels\n\nvec3 soft_clip(vec3 x) {\n    return clamp(tanh(2.0 * x - 1.0) / 2.0 + 0.5, 0.0, 1.0);\n}\n\nmat4 gaussian_bell(mat4 sum, mat4 m, mat4 s) {\n    mat4 p = -matrixCompMult((sum - m) / s, (sum - m) / s) / 2.0;\n    return mat4(exp(p[0]), exp(p[1]), exp(p[2]), exp(p[3]));\n}\n\nfloat gaussian_bell(float x, float m, float s) {\n    return exp(-pow((x - m) / s, 2.0) / 2.0);\n}\n\nmat4 update(mat4 sum, mat4 m, mat4 s, vec3 cell) {\n    ivec4 c10 = ivec4(c1[0]), c11 = ivec4(c1[1]), c12 = ivec4(c1[2]), c13 = ivec4(c1[3]);\n    mat4 A = mat4(\n            cell[0] * vec4(equal(c10, iv0)) + cell[1] * vec4(equal(c10, iv1)) + cell[2] * vec4(equal(c10, iv2)), \n            cell[0] * vec4(equal(c11, iv0)) + cell[1] * vec4(equal(c11, iv1)) + cell[2] * vec4(equal(c11, iv2)), \n            cell[0] * vec4(equal(c12, iv0)) + cell[1] * vec4(equal(c12, iv1)) + cell[2] * vec4(equal(c12, iv2)),\n            cell[0] * vec4(equal(c13, iv0)) + cell[1] * vec4(equal(c13, iv1)) + cell[2] * vec4(equal(c13, iv2))\n         );\n    mat4 T = gaussian_bell(sum, m, s) - A;\n    mat4 G = gaussian_bell(sum, m, s) * 2.0 - 1.0;\n    mat4 result = mat4(\n            G[0] * vec4(equal(c10, iv0)) + G[0] * vec4(equal(c10, iv1)) + T[0] * vec4(equal(c10, iv2)), \n            G[1] * vec4(equal(c11, iv0)) + G[1] * vec4(equal(c11, iv1)) + T[1] * vec4(equal(c11, iv2)), \n            G[2] * vec4(equal(c12, iv0)) + G[2] * vec4(equal(c12, iv1)) + T[2] * vec4(equal(c12, iv2)), \n            G[3] * vec4(equal(c13, iv0)) + G[3] * vec4(equal(c13, iv1)) + T[3] * vec4(equal(c13, iv2))\n         );\n    return result;\n}\n\nfloat getGrowthDest(mat4 growth, ivec4 channel) {\n    return dot(growth[0], vec4(equal(ivec4(c1[0]), channel))) + \n           dot(growth[1], vec4(equal(ivec4(c1[1]), channel))) + \n           dot(growth[2], vec4(equal(ivec4(c1[2]), channel))) + \n           dot(growth[3], vec4(equal(ivec4(c1[3]), channel)));\n}\n\nvec4 getRGB(vec3 v, ivec4 srcv)\n{\n    return v.r * vec4(equal(srcv, iv0)) + v.g * vec4(equal(srcv, iv1)) + v.b * vec4(equal(srcv, iv2));\n}\n\nmat4 getCell(vec2 xy)\n{\n    xy = mod(xy / iResolution.xy, 1.);\n    vec3 cell = texture(iChannel0, xy).rgb;\n    return mat4(getRGB(cell, ivec4(c0[0])), \n                getRGB(cell, ivec4(c0[1])), \n                getRGB(cell, ivec4(c0[2])), \n                getRGB(cell, ivec4(c0[3]))\n           );\n}\n\nmat4 getWeight(float dist, mat4 relR) {\n    mat4 Br = betaLen / relR * dist;\n    mat4 radiuses = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));\n    for (int i = 0; i < 4; i++)\n    for (int j = 0; j < 4; j++) {\n        radiuses[i][j] += beta0[i][j] * gaussian_bell(dist, 0.0, 1.0 / betaLen[i][j]) +\n                          beta1[i][j] * gaussian_bell(dist, 1.0, 1.0 / betaLen[i][j]) +\n                          beta2[i][j] * gaussian_bell(dist, 2.0, 1.0 / betaLen[i][j]);\n    }\n    mat4 Br_mod = mat4(mod(Br[0], 1.0), mod(Br[1], 1.0), mod(Br[2], 1.0), mod(Br[3], 1.0));\n    return matrixCompMult(radiuses, gaussian_bell(Br_mod, rmu, rsigma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    mat4 sum = mat4(0.0), total = mat4(0.0);\n    mat4 weight = getWeight(0.0, relR);\n    mat4 cell = getCell(fragCoord); sum += matrixCompMult(cell, weight); total += weight;\n    \n    for(float x = 1.0; x <= max_radius; x++) {\n        float R = x / max_radius;\n        weight = getWeight(R, relR);\n        cell = getCell(fragCoord + vec2(x, 0));   sum += matrixCompMult(cell, weight); total += weight;\n        cell = getCell(fragCoord + vec2(-x, 0));  sum += matrixCompMult(cell, weight); total += weight;\n        cell = getCell(fragCoord + vec2(0, x));  sum += matrixCompMult(cell, weight); total += weight;\n        cell = getCell(fragCoord + vec2(0, -x)); sum += matrixCompMult(cell, weight); total += weight;   \n    }\n\n    for(float x = 1.0; x <= max_radius; x++) {\n        for(float y = 1.0; y <= max_radius; y++) {\n            float R = sqrt(x * x + y * y) / max_radius;\n            if (R <= 1.0) {\n                weight = getWeight(R, relR);\n                cell = getCell(fragCoord + vec2(x, y));   sum += matrixCompMult(cell, weight); total += weight;\n                cell = getCell(fragCoord + vec2(-x, y));  sum += matrixCompMult(cell, weight); total += weight;\n                cell = getCell(fragCoord + vec2(x, -y));  sum += matrixCompMult(cell, weight); total += weight;\n                cell = getCell(fragCoord + vec2(-x, -y)); sum += matrixCompMult(cell, weight); total += weight;\n                \n            }\n        }\n    }\n    \n    sum /= total;\n    \n    \n    vec3 previous_cell = texture(iChannel0, uv).rgb;\n    mat4 g = matrixCompMult(eta, update(sum, mu, sigma, previous_cell));\n    vec3 rgb_growth = vec3(getGrowthDest(g, iv0), getGrowthDest(g, iv1), getGrowthDest(g, iv2));\n    vec3 rgb = soft_clip(previous_cell + rgb_growth / T);\n    \n    if (iFrame < 1) {\n        rgb.r = noise_base + noise(fragCoord/noise_width + mod(iDate.w,1.)*44.5);\n        rgb.g = noise_base + noise(fragCoord/noise_width + mod(iDate.w,1.)*100.0);\n        rgb.b = noise_base + noise(fragCoord/noise_width + mod(iDate.w,1.)*155.5);\n    }\n    if (iMouse.z > 0.) {\n        float d = length((fragCoord.xy - iMouse.xy) / iResolution.xx);\n        if (d <= max_radius/iResolution.x) {\n        \trgb.r = 0.3 + noise(fragCoord/noise_width + mod(iDate.w,1.)*44.5);\n            rgb.g = 0.3 + noise(fragCoord/noise_width + mod(iDate.w,1.)*100.0);\n            rgb.b = 0.3 + noise(fragCoord/max_radius + mod(iDate.w,1.)*155.5);\n        }\n    }\n    fragColor = vec4(rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*Chakazul's use of this hash function is genius and all credits to him in his implementation of lenia: https://www.shadertoy.com/user/Chakazul\n*/\n\n// Noise simplex 2D by iq - https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}","name":"Common","description":"","type":"common"}]}