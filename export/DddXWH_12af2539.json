{"ver":"0.1","info":{"id":"DddXWH","date":"1692041275","viewed":54,"name":"gkurve segments (r13)","username":"slimsag","description":"gkurve","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gkurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_POINTS 5\n\nfloat dist(vec2 a, vec2 b) {\n    return sqrt(pow(b.x-a.x, 2.0) + pow(b.y-a.y, 2.0));\n}\nvec2 midpoint(vec2 a, vec2 b) {\n    return vec2((a.x+b.x)*0.5, (a.y+b.y)*0.5);\n}\nfloat slope(vec2 a, vec2 b) {\n    return (b.y-a.y)/(b.x-a.x)+1e-100;\n}\nvec2 scalep(vec2 p, vec2 center, float scaleFactor) {\n    return scaleFactor * (p - center) + center;\n}\n\n// returns the distance from p to an oriented linear gradient.\n//\n// The gradient is linear and has two stops: 0.0 to 1.0\n// The gradient is oriented such that z0 and z1 are both 0.0 values.\n// The gradient is oriented such that e is a 1.0 value.\nfloat gradient(vec2 p, vec2 z0, vec2 z1, vec2 e) {\n    vec2 e_z1 = e - z1;\n    vec2 p_z1 = p - z1;\n    float z0_z1_y = z0.y - z1.y;\n    float z1_z0_x = z1.x - z0.x;\n    float n = z0_z1_y*p_z1.x + z1_z0_x*p_z1.y;\n    float d = z0_z1_y*e_z1.x + z1_z0_x*e_z1.y;\n    return n/d;\n}\n\n// returns a value describing which side of a line p is on.\nfloat line(vec2 p, vec2 z0, vec2 z1) {\n    return gradient(p, z0, z1, z1);\n}\n\n// returns a value describing which side of a line p is on.\nfloat linePlus(vec2 p, vec2 z0, vec2 z1, float epsilon) {\n    vec2 e = z1;\n    vec2 e_z1 = e - z1;\n    vec2 p_z1 = p - z1;\n    float z0_z1_y = z0.y - z1.y;\n    float z1_z0_x = z1.x - z0.x;\n    float n = z0_z1_y*p_z1.x + z1_z0_x*p_z1.y - 0.1;\n    float d = z0_z1_y*e_z1.x + z1_z0_x*e_z1.y;\n    return n/d;\n}\n\nvec2 centroid2(vec2[NUM_POINTS*2] points) {\n    vec2 sum = vec2(0, 0);\n    for(int i=0; i < NUM_POINTS*2; i++) {\n        sum += points[i];\n    }\n    return (1.0/float(NUM_POINTS*2)) * sum;\n}\n\nfloat clmp(float v) {\n    return clamp(v, 0., 1.);\n}\n\nfloat isConcave(vec2 a, vec2 b, vec2 c) {\n    mat2 v = mat2(\n        (b.x - a.x), (c.x - a.x),\n        (b.y - a.y), (c.y - a.y)\n    );\n    if (determinant(v) < 0.0) {\n        return 1.0;\n    }\n    return -1.0;\n}\n\n// Produces a clipping mask for a polygon\nfloat polyClip(\n    vec2 p,\n    vec2[NUM_POINTS*2] points\n) {\n    float clip = 1.0;\n    vec2 p0 = points[0];\n    float e = 0.0001; // epsilon to avoid thin lines appearing in our virtual stencil buffer\n    for (int i=0; i < 2*NUM_POINTS; i+=1) {\n        vec2 p1 = points[(i+1) % (2*NUM_POINTS)];\n        vec2 p2 = points[(i+2) % (2*NUM_POINTS)];\n        float b0 = (gradient(p, p0, p1, p2) + gradient(p+e, p0, p1, p2))/2.;\n        float b1 = (gradient(p, p1, p2, p0) + gradient(p+e, p1, p2, p0))/2.;\n        float b2 = (gradient(p, p2, p0, p1) + gradient(p+e, p2, p0, p1))/2.;\n        if (b0 > 0. && b0 < 1. && b1 > 0. && b1 < 1. && b2 > 0. && b2 < 1.) {\n            clip += 1.0;\n        }\n    }\n    return 1.-(mod(clip, 2.)+1.0);\n}\n\n// Produces a clipping mask for a polygon\nfloat innerPolyClip(\n    vec2 p,\n    vec2[NUM_POINTS*2] points\n) {\n    vec2[NUM_POINTS*2] poly_points;\n    int num_poly_points = 0;\n    poly_points[num_poly_points] = points[0];\n    for (int i=0; i < NUM_POINTS; i+=2) {\n        vec2 p0 = points[(i+0) % (2*NUM_POINTS)];\n        vec2 p1 = points[(i+1) % (2*NUM_POINTS)];\n        vec2 p2 = points[(i+2) % (2*NUM_POINTS)];\n        vec2 p3 = points[(i+3) % (2*NUM_POINTS)];\n        vec2 p4 = points[(i+4) % (2*NUM_POINTS)];\n        float concave = isConcave(p2, p3, p4);\n        if (i % 4 == 0) {\n            if (concave == -1.0) {\n                poly_points[num_poly_points] = p2;\n                num_poly_points++;\n                poly_points[num_poly_points] = p3;\n                num_poly_points++;\n\n                poly_points[num_poly_points] = p3;\n                num_poly_points++;\n                poly_points[num_poly_points] = p4;\n                num_poly_points++;\n            } else {\n                poly_points[num_poly_points] = p2;\n                num_poly_points++;\n                poly_points[num_poly_points] = p4;\n                num_poly_points++;\n            }\n        }\n    }\n\n    float clip = 1.0;\n    vec2 f0 = points[0];\n    float e = 0.0001; // epsilon to avoid thin lines appearing in our virtual stencil buffer\n    for (int i=0; i < num_poly_points-1; i+=1) {\n        vec2 f1 = poly_points[(i+0) % num_poly_points];\n        vec2 f2 = poly_points[(i+1) % num_poly_points];\n        float b0 = (gradient(p, f0, f1, f2) + gradient(p+e, f0, f1, f2))/2.;\n        float b1 = (gradient(p, f1, f2, f0) + gradient(p+e, f1, f2, f0))/2.;\n        float b2 = (gradient(p, f2, f0, f1) + gradient(p+e, f2, f0, f1))/2.;\n        if (b0 > 0. && b0 < 1. && b1 > 0. && b1 < 1. && b2 > 0. && b2 < 1.) {\n            clip += 1.0;\n        }\n    }\n    return 1.-(mod(clip, 2.)+1.0);\n}\n\nfloat dist(\n    float scale,\n    float gradient_thickness,\n    vec2 p,\n    vec2[NUM_POINTS*2] points,\n    vec2[NUM_POINTS] cpoints\n) {\n    vec2 center = centroid2(points);\n    for (int i=0; i < 2*NUM_POINTS; i+=1) {\n        points[i] = scalep(points[i], center, scale);\n    }\n    for (int i=0; i < NUM_POINTS; i+=1) {\n        cpoints[i] = scalep(cpoints[i], center, scale);\n    }\n\n\n    float poly_clip = innerPolyClip(p, points);\n    float pc = 1.-((1.-poly_clip)-1.0);\n    float ipc = 1.-pc;\n    //return pc;\n\n    int min = 0;\n    float min_dist = 100000000000.0;\n    for (int i=0; i < 2*NUM_POINTS; i+=2) {\n        vec2 p1 = points[(i+1) % (2*NUM_POINTS)];\n        float d = dist(p1, p);\n        if (d < min_dist) {\n            min = i;\n            min_dist = d;\n        }\n    }\n\n    float mix = 0.0;\n    mix += poly_clip;\n    //mix = pc + mix*ipc;\n    for (int i=0; i < 2*NUM_POINTS; i+=2) {\n        vec2 p0 = points[(i+0) % (2*NUM_POINTS)];\n        vec2 p1 = points[(i+1) % (2*NUM_POINTS)];\n        vec2 p2 = points[(i+2) % (2*NUM_POINTS)];\n        vec2 c0 = cpoints[(((i/2)+0) % (NUM_POINTS))];\n\n        float blend0 = 1.-gradient(p, p0, c0, p2);\n        float blend1 = 1.-gradient(p, p2, c0, p0);\n\n        float clip0 = line(p, p1, p0);\n        float clip1 = line(p, p2, p1);\n        float clip2 = line(p, p0, p2);\n\n        float convex_gradient = 1.-(blend0*blend0+blend1*blend1);\n        float concave = isConcave(p0, p1, p2);\n        float clip = clmp(clip0*concave)*clmp(clip1*concave)*clmp(clip2*concave);\n        clip = clmp(clip0*concave)*clmp(clip1*concave)*clmp(clip2*concave);\n        float iclip = 1.0-clip;\n\n        if (concave == -1.0) {\n            convex_gradient = (blend0*blend0+blend1*blend1)-1.;\n        }\n        //convex_gradient += scale;\n\n        vec2 pxy = vec2(dFdx(convex_gradient), dFdy(convex_gradient));\n        float fx = convex_gradient * pxy.x-pxy.x;\n        float fy = convex_gradient * pxy.y-pxy.y;\n        float base = sqrt(fx*fx + fy*fy);\n        //convex_gradient /= (base*gradient_thickness);\n        convex_gradient = convex_gradient / base;\n\n        //mix = (mix+convex_gradient*pc) + mix*ipc;\n        //mix = (1.*pc) + mix*ipc;\n        //if (i == 0) break;\n\n        if (i == min) {\n            mix = 1.0*pc + mix*ipc;\n            //mix = 1.0;\n            //mix = (mix*pc);// +  convex_gradient*min_dist*pc + mix*ipc;\n            //break;\n        }\n        if (iclip < 1.0) {\n            mix = convex_gradient*clip + mix*iclip;\n        }\n    }\n    return mix;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 200.0;\n    vec2 p = fragCoord;\n\n    // User-input points (on-curve)\n    vec2 p0 = vec2(size*2.0, size*1.0);\n    vec2 p1 = vec2(size*1.0, size*1.75);\n    vec2 p2 = vec2(size*2.0, size*2.5);\n    vec2 p3 = vec2(size*3.5, size*2.5);\n    vec2 p4 = vec2(size*4.0, size*1.2);\n    p1 = iMouse.xy;\n\n    // Derived continuity points\n    vec2 pc0 = midpoint(p0, p1);\n    vec2 pc1 = midpoint(p1, p2);\n    vec2 pc2 = midpoint(p2, p3);\n    vec2 pc3 = midpoint(p3, p4);\n    vec2 pc4 = midpoint(p4, p0);\n\n    // Derived off-curve control points\n    float k0 = 1.0;\n    float k1 = 0.0;\n    vec2 c0 = scalep(p0, midpoint(p1, p4), k0); // derived off-curve point\n    vec2 c1 = scalep(p1, midpoint(p0, p2), k0); // derived off-curve point\n    vec2 c2 = scalep(p2, midpoint(p1, p3), k0); // derived off-curve point\n    vec2 c3 = scalep(p3, midpoint(p2, p4), k0); // derived off-curve point\n    vec2 c4 = scalep(p4, midpoint(p3, p0), k0); // derived off-curve point\n\n    // Derived continuity control points\n    vec2 cc0 = scalep(c0, c1, (1./3.)*2.);\n    vec2 cc1 = scalep(c0, c1, (1./3.)*1.);\n    vec2 cc2 = scalep(c1, c2, (1./3.)*2.);\n    vec2 cc3 = scalep(c1, c2, (1./3.)*1.);\n    vec2 cc4 = scalep(c2, c3, (1./3.)*2.);\n    vec2 cc5 = scalep(c2, c3, (1./3.)*1.);\n    vec2 cc6 = scalep(c3, c4, (1./3.)*2.);\n    vec2 cc7 = scalep(c3, c4, (1./3.)*1.);\n    vec2 cc8 = scalep(c4, c0, (1./3.)*2.);\n    vec2 cc9 = scalep(c4, c0, (1./3.)*1.);\n    pc0 = scalep(pc0, midpoint(cc0, cc1), k1);\n    pc1 = scalep(pc1, midpoint(cc2, cc3), k1);\n    pc2 = scalep(pc2, midpoint(cc4, cc5), k1);\n    pc3 = scalep(pc3, midpoint(cc6, cc7), k1);\n    pc4 = scalep(pc4, midpoint(cc8, cc9), k1);\n\n    vec2 points[NUM_POINTS*2] = vec2[](\n        pc4, p0, pc0, p1, pc1, p2, pc2, p3, pc3, p4\n    );\n    vec2 cpoints[NUM_POINTS] = vec2[](\n        c0, c1, c2, c3, c4\n    );\n\n    // Draw points\n    for (int i = 0; i < NUM_POINTS*2; i++) {\n        // User input points\n        if (i % 2 == 1 && dist(fragCoord, points[i]) < 10.0) {\n            fragColor = vec4(1, 1, 1, 1);\n            return;\n        }\n\n        // Derived continuity points\n        if (dist(fragCoord, points[i]) < 7.5) {\n            fragColor = vec4(0, 0, 0, 1);\n            return;\n        }\n        if (dist(fragCoord, points[i]) < 10.0) {\n            fragColor = vec4(1, 1, 1, 1);\n            return;\n        }\n    }\n\n    float gradient_thickness = 100.0;\n    float mix0 = dist(1.0, gradient_thickness, p, points, cpoints);\n    float mix1 = dist(0.75, gradient_thickness, p, points, cpoints);\n    float mix = mix1;\n\n    float ga = mix;\n    if (ga < 0.) {\n        fragColor = vec4(1.-ga, .0, .0, 1);\n        return;\n    }\n    fragColor = vec4(0.0, ga, 0.0, 1.0);\n    return;\n}\n","name":"Image","description":"","type":"image"}]}