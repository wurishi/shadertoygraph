{"ver":"0.1","info":{"id":"MXS3WV","date":"1708891409","viewed":234,"name":"Holographic Card Shader","username":"Roeming","description":"a holographic effect on a card","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["lighting","card","holographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*~ MAIN IMAGE ~*/\n\n/*\n Sources: \n\n playing around with projection - 2023 by jt\n https://www.shadertoy.com/view/DdSyDD\n\n Holofoil Card Shader Breakdown\n https://www.cyanilux.com/tutorials/holofoil-card-shader-breakdown/\n*/\n#define RAINBOW_TEXTURE iChannel0\n#define DOT_TEXTURE iChannel1\n#define CARD_ART_TEXTURE iChannel2\n#define DOT_STRENGTH 0.1\n\nvec2 div_z(vec3 v)\n{\n    return vec2(v) / v.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // p is the screen coordinate, -1 ... +1\n    vec2 p = 2.0 * fragCoord/iResolution.xy - 1.0;\n    // compensate for aspect ratio, make a square\n    p *= iResolution.xy / min(iResolution.x, iResolution.y);\n    // make it the aspect ratio of a TCG Card\n    p /= vec2(1, 1.5);\n    // zoom out\n    //p *= 2.0;\n\n    // create a matrix to rotate our card\n    float g = 0.4 * cos(iTime);\n    float h = 0.4 * sin(iTime);\n    // essentially, we're just skewing the texture to fake the effect of moving the camera\n    mat3 m = mat3\n    (\n        vec3(1,0,g),\n        vec3(0,1,h),\n        vec3(0,0,1)\n    );\n    \n    // create a new UV that's going to act as our skewed screen UV\n    vec2 rectUV = div_z((m * vec3(p, 1)));\n    \n    // create a UV that repeats across the plane, \n    // +0.5 to center a rect in the middle of the screen\n    vec2 tiledCoord = fract(rectUV + 0.5);\n    \n    // We're gonna isolate the center rect, but you could set this to 1.0 to repeat the card across the plane\n    float isCenterRect = (tiledCoord == (rectUV + 0.5)) ? 1.0 : 0.0;\n    \n    // Create a rotation for our rainbow texture\n    // this is faking the effect of light bouncing off our rect as a result of the norm changing\n    mat3 rotateUVMat = mat3(\n        vec3(g,h, 0),\n        vec3(-h,g, 0),\n        vec3(0,0,1)\n    );\n    \n    // create a rotated UV of our rect\n    // rotates around the bottom left corner\n    vec2 rotatedRainbowUV = (rotateUVMat * vec3(tiledCoord, 1.0)).rg;\n    \n    // load in the dot pattern\n    // we're gonna use the dot pattern as a UV offset\n    // scale down the intensity tho, so it can be a little bump\n    vec2 dotPatternOffset = texture(DOT_TEXTURE, tiledCoord).rr * DOT_STRENGTH;\n        \n    // load in the rainbowTexure, but add the dot as a uv offset, allowing the dots to be a different color\n    vec3 rainbow = texture(RAINBOW_TEXTURE, rotatedRainbowUV + dotPatternOffset).rgb;\n\n    vec3 cardArt = texture(CARD_ART_TEXTURE, tiledCoord).rgb;\n    \n    // remove some pixels, and just leave the light bits, have the alpha channel hold this info\n    vec4 cardStencil = vec4(cardArt, length(cardArt) > 0.9 ? 0.5 : 1.0);\n    \n    vec4 combinedCard = vec4(mix(rainbow, cardStencil.rgb, cardStencil.a), 1.0);\n    \n    fragColor = combinedCard;\n    // isolate the center rect\n    fragColor.rgb = (combinedCard.rgb * isCenterRect) + (1.0 - isCenterRect) * vec3(0.1, 0.5, 0.5);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*~ RAINBOW TEXTURE ~*/\n\n// hsv2rgb source \n// https://gist.github.com/983/e170a24ae8eba2cd174f\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n#define RAINBOW_REPETITIONS 2.5\n#define RAINBOW_OFFSET -0.4\n\n#define PI 3.14159265\n#define TWO_PI (2.0 * PI)\n\n#define MASK_OFFSET radians(-15.0)\n\n/*\n The goal is to create a rainbow texture that has rainbow on the left,\n and black on the right.\n \n We can create a repeating rainbow pattern with hsv.\n We just need to then mult by some mask to gradually fade out the right.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The x coord will act as our Hue in hsv\n    float x = fragCoord.x / iResolution.x;\n    // Stretch out the hue so it repeats multiple times across the texture\n    // desaturate the color to have a lighter tone\n    vec3 col = hsv2rgb(vec3(x * RAINBOW_REPETITIONS + RAINBOW_OFFSET, 1.0, 1.));\n    //col += 0.8;\n    // this is our mask, maybe not the best way, but it got the job done\n    float s = sin(x * TWO_PI + MASK_OFFSET);\n    \n    // clamp the texture to just exist 0 ... 1\n    fragColor = vec4(clamp(col * s, 0., 1.), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*~ DOT TEXTURE ~*/\n\n#define iDOT_COUNT 20\n#define DOT_COUNT float(iDOT_COUNT)\n\n#define DOT_STRENGTH 0.4\n#define INV_DOT_STRENGTH (1.0 - DOT_STRENGTH)\n\n/*\n    The goal is to make some dots.\n    They should be equally spread, but not touching\n    Ideally, there should be a good amount of space where the value is 0.\n    But each dot should reach 1.0 at the peak\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen UV\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // divide the UV into multiple cells that our dots will live in\n    vec2 d = fract(uv * DOT_COUNT);\n    \n    // for each cell, get the distance to the center of the cell\n    float distanceToCenter = length(d - 0.5);\n\n    // the distance is actually the opposite of what we want\n    // if distance to center is 0, make it the center of our dot\n    // make it bright\n    float invDistanceToCenter = 1.0 - distanceToCenter;\n    \n    // right now the corners of our dot cells will touch with a value of 0.5\n    // so we want to subtract some strength in order to isolate the dots\n    // but we still want the centers to be 1.0\n    float fin = (invDistanceToCenter - INV_DOT_STRENGTH) / DOT_STRENGTH;\n\n    // some of our values will be negative because we subtracted strength\n    // we want to clamp these values to 0\n    fragColor = vec4(vec3( clamp(fin, 0.0, 1.0) ), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}