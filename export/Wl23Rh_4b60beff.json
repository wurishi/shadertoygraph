{"ver":"0.1","info":{"id":"Wl23Rh","date":"1558469013","viewed":279,"name":" GLSL smallpt progressive 2","username":"bernie_freidin","description":"modifications","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","reflection","refraction","cornellbox","globalillumination","pathtracing","montecarlo","multipass","smallpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    col = pow(col, vec3(1.0/2.2)); // gamma\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n=============================================================================\nBased on https://www.shadertoy.com/view/XdcfRr (fjavifabre)\nWhich was based on https://www.shadertoy.com/view/4sfGDB (Zavie)\nOriginal code http://www.kevinbeason.com/smallpt/\n\nNote: this project is NOT intended to look great, it is intended to resolve\ndiscrepancies with the ground truth path tracer (currently I'm using Mitsuba).\nAt this point I've resolved discrepancies with diffuse material only, but not\nspecular or refractive.\n\nTODO:\n- support textured quad lights\n- Hammersley/Halton sampling\n- add GGX and metallic materials (low priority)\n- firefly suppression\n\nOther related clones:\nhttps://www.shadertoy.com/view/4dtGWB (vgs)\nhttps://www.shadertoy.com/view/4tc3RS (Incin)\nhttps://www.shadertoy.com/view/MdKyRK (Zgragselus) - has GGX and metallic materials\n\nTODO -- examine these:\nhttps://www.shadertoy.com/view/lsX3DH - bouncy\nhttps://www.shadertoy.com/view/ldKBRV - heavy-handed denoising\nhttps://www.shadertoy.com/view/ldKBzG - similar\nhttps://www.shadertoy.com/view/MsXfz4 - interesting camera controls .. textures\n\nPathtracing info:\nhttps://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing/global-illumination-path-tracing-practical-implementation\n\nProgressive Path Tracing with Explicit Light Sampling\nhttps://computergraphics.stackexchange.com/questions/5152/progressive-path-tracing-with-explicit-light-sampling\n\nPath weight for direct light sampling\nhttps://computergraphics.stackexchange.com/questions/4288/path-weight-for-direct-light-sampling\n\nOptimally Combining Sampling Techniques for Monte Carlo Rendering\nhttps://sites.fas.harvard.edu/~cs278/papers/veach.pdf\n=============================================================================\n*/\n\n// Play with the two following values to change quality.\n// You want as many samples as your GPU can bear. :)\n#define NUM_SAMPLES 32\n#define MAX_DEPTH 16\n#define NEXT_EVENT_PREDICTION (1)\n#define NEXT_EVENT_PREDICTION_SCREEN_SPLIT (1)\n\n#define SUPPORT_QUADS (1)\n#define CBOX_IS_QUADS (1 && SUPPORT_QUADS)\n#define LIGHT_IS_QUAD (0 && SUPPORT_QUADS)\n#define ALL_DIFFUSE (1) // make the whole scene diffuse, for easier reference comparison\n#define TEST_FIREFLIES (0) // note: lots of fireflies with next event estimation (but not without)\n\n#define MATERIAL_TYPE_DIFFUSE 0\n#define MATERIAL_TYPE_SPECULAR 1\n#define MATERIAL_TYPE_REFRACTIVE 2\n\n#define PI 3.14159265359\n\n#define USE_XORSHIFT_RNG (1) // xorshift seems slightly better in some situations ..\n#if USE_XORSHIFT_RNG\nuint seed = 0U;\nvoid InitRandom(vec2 fragCoord)\n{\n\tseed = uint(dot(fragCoord, vec2(1, iResolution.x))) + uint(iFrame*iFrame);\n    seed *= seed; // improves a bit more\n}\nfloat rand()\n{\n\tseed ^= seed << 13;\n\tseed ^= seed >> 17;\n\tseed ^= seed << 5;\n\treturn float(seed)*(1.0/4294967295.0); // [0..1]\n}\n#else\nfloat seed = 0.0;\nvoid InitRandom(vec2 fragCoord)\n{\n    vec2 st = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n    seed = iResolution.y*st.x + st.y + fract(iTime);\n}\nfloat rand()\n{\n    return fract(sin(seed++)*43758.5453123);\n}\n#endif\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 dir;\n};\n\nstruct Object\n{\n\tvec3 pos;\n\tfloat radius; // if zero, then it is a quad\n#if SUPPORT_QUADS\n\tvec3 quadNormal;\n\tvec3 quadBasisX; // divided by extent\n\tvec3 quadBasisY; // divided by extent\n#endif // SUPPORT_QUADS\n\tvec3 albedo;\n\tvec3 emissive;\n\tint materialType;\n};\n\n#if SUPPORT_QUADS\nObject MakeQuad(vec3 pos, vec3 normal, vec3 basisX, float extentX, vec3 basisY, float extentY, vec3 albedo, vec3 emissive, int materialType)\n{\n\tObject quad;\n\tquad.pos = pos;\n\tquad.radius = 0.0;\n\tquad.quadNormal = normal;\n\tquad.quadBasisX = basisX/extentX;\n\tquad.quadBasisY = basisY/extentY;\n\tquad.albedo = albedo;\n\tquad.emissive = emissive;\n\tquad.materialType = materialType;\n\treturn quad;\n}\n#endif // SUPPORT_QUADS\n\nObject MakeSphere(vec3 pos, float radius, vec3 albedo, vec3 emissive, int materialType)\n{\n\tObject sphere;\n\tsphere.pos = pos;\n\tsphere.radius = radius;\n#if SUPPORT_QUADS\n\tsphere.quadNormal = vec3(0);\n\tsphere.quadBasisX = vec3(0);\n\tsphere.quadBasisY = vec3(0);\n#endif // SUPPORT_QUADS\n\tsphere.albedo = albedo;\n\tsphere.emissive = emissive;\n\tsphere.materialType = materialType;\n\treturn sphere;\n}\n\nbool IsLight(Object obj)\n{\n    return max(max(obj.emissive.x, obj.emissive.y), obj.emissive.z) > 0.0;\n}\n\n#define NUM_OBJECTS 9\nObject objects[NUM_OBJECTS];\n\nvoid InitObjects()\n{\n\t// Cornell Box is (smallpt version):\n\t// x = 1 (left) to 99 (right)\n\t// y = 0 (bottom) to 81.6 (top)\n\t// z = 0 (front) to 170 (back)\n\t// light is centered at 50,81.6,81.6 with radius 20\n\n\tconst float lightRadiusScale = 1.0;\n\tconst float lightRadius = 20.0*lightRadiusScale;\n\tconst float lightIntensity = 12.0/(lightRadiusScale*lightRadiusScale);\n\n#if CBOX_IS_QUADS\n\tobjects[0] = MakeQuad(vec3( 1.0,40.8, 85.0), vec3(+1,0,0), vec3(0,0,1), 85.0, vec3(0,-1,0), 40.8, vec3(0.75,0.25,0.25), vec3(0), MATERIAL_TYPE_DIFFUSE); // left wall (red)\n\tobjects[1] = MakeQuad(vec3(99.0,40.8, 85.0), vec3(-1,0,0), vec3(0,0,1), 85.0, vec3(0,+1,0), 40.8, vec3(0.25,0.25,0.75), vec3(0), MATERIAL_TYPE_DIFFUSE); // right wall (green)\n\tobjects[2] = MakeQuad(vec3(50.0,81.6, 85.0), vec3(0,-1,0), vec3(0,0,1), 85.0, vec3(-1,0,0), 49.0, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE); // ceiling\n\tobjects[3] = MakeQuad(vec3(50.0, 0.0, 85.0), vec3(0,+1,0), vec3(0,0,1), 85.0, vec3(+1,0,0), 49.0, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE); // floor\n\tobjects[4] = MakeQuad(vec3(50.0,40.8,  0.0), vec3(0,0,+1), vec3(1,0,0), 49.0, vec3(0,+1,0), 40.8, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE); // front wall\n\tobjects[5] = MakeQuad(vec3(50.0,40.8,170.0), vec3(0,0,-1), vec3(1,0,0), 49.0, vec3(0,-1,0), 40.8, vec3(0.00), vec3(0), MATERIAL_TYPE_DIFFUSE); // back wall (black)\n#else\n\tconst float r = 1e5;\n\tobjects[0] = MakeSphere(vec3( 1.0 - r, 40.8, 81.6),  r, vec3(0.75,0.25,0.25), vec3(0), MATERIAL_TYPE_DIFFUSE); // left wall (red)\n\tobjects[1] = MakeSphere(vec3(99.0 + r, 40.8, 81.6),  r, vec3(0.25,0.25,0.75), vec3(0), MATERIAL_TYPE_DIFFUSE); // right wall (green)\n\tobjects[2] = MakeSphere(vec3(50.0, 81.6 + r, 81.6),  r, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE);// ceiling\n\tobjects[3] = MakeSphere(vec3(50.0, -r, 81.6),        r, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE); // floor\n\tobjects[4] = MakeSphere(vec3(50.0, 40.8, -r),        r, vec3(0.75), vec3(0), MATERIAL_TYPE_DIFFUSE); // front wall\n\tobjects[5] = MakeSphere(vec3(50.0, 40.8, 170.0 + r), r, vec3(0.0), vec3(0), MATERIAL_TYPE_DIFFUSE); // back wall (black)\n#endif\n\tconst bool allDiffuse = bool(ALL_DIFFUSE);\n\tobjects[6] = MakeSphere(vec3(27.0, 16.5, 47.0), 16.5, vec3(0.9),         vec3(0), allDiffuse ? MATERIAL_TYPE_DIFFUSE : MATERIAL_TYPE_SPECULAR);\n\tobjects[7] = MakeSphere(vec3(73.0, 16.5, 78.0), 16.5, vec3(0.7,0.9,0.9), vec3(0), allDiffuse ? MATERIAL_TYPE_DIFFUSE : MATERIAL_TYPE_REFRACTIVE);\n#if LIGHT_IS_QUAD\n\tconst float epsilon = 1e-3;\n#if TEST_FIREFLIES\n    objects[8] = MakeQuad(vec3(1.0 + epsilon, lightRadius - 37.0, lightRadius + 10.0), vec3(1,0,0), vec3(0,1,0), lightRadius, vec3(0,0,1), lightRadius, vec3(0.0), vec3(lightIntensity), MATERIAL_TYPE_DIFFUSE); // wall light\n#else\n\tobjects[8] = MakeQuad(vec3(50.0, 81.6 - epsilon, 81.6), vec3(0,-1,0), vec3(1,0,0), lightRadius, vec3(0,0,1), lightRadius, vec3(0.0), vec3(lightIntensity), MATERIAL_TYPE_DIFFUSE); // ceiling light\n#endif\n#else\n\tobjects[8] = MakeSphere(vec3(50.0, 81.6, 81.6), lightRadius, vec3(0.0), vec3(lightIntensity), MATERIAL_TYPE_DIFFUSE); // ceiling light\n#endif\n}\n\nfloat IntersectSphere(Ray ray, Object sphere)\n{\n\tvec3 V = sphere.pos - ray.origin;\n\tfloat b = dot(V, ray.dir);\n    float r = sphere.radius;\n\tfloat det = b*b - dot(V, V) + r*r;\n\tif (det < 0.0)\n\t\treturn 0.0;\n\telse {\n\t\tdet = sqrt(det);\n\t\tfloat epsilon = 1e-3;\n\t\tfloat t;\n\t\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.0);\n\t}\n}\n\n#if SUPPORT_QUADS\nfloat IntersectQuadOrPlane(Ray ray, Object quad, bool isInfinitePlane)\n{\n\tvec3 V = quad.pos - ray.origin;\n\tfloat t = max(0.0, dot(V, quad.quadNormal)/dot(ray.dir, quad.quadNormal));\n\tif (t > 0.0 && !isInfinitePlane) {\n\t\tV -= t*ray.dir;\n\t\tfloat vx = dot(V, quad.quadBasisX);\n\t\tfloat vy = dot(V, quad.quadBasisY);\n\t\tif (max(abs(vx), abs(vy)) > 1.0)\n\t\t\tt = 0.0;\n\t}\n\treturn t;\n}\nfloat IntersectQuad(Ray ray, Object quad)\n{\n\treturn IntersectQuadOrPlane(ray, quad, false);\n}\n#endif // SUPPORT_QUADS\n\nfloat IntersectObject(Ray ray, Object obj)\n{\n#if SUPPORT_QUADS\n\tif (obj.radius == 0.0)\n\t\treturn IntersectQuad(ray, obj);\n\telse\n#endif // SUPPORT_QUADS\n\t\treturn IntersectSphere(ray, obj);\n}\n\nvec3 GetSurfaceNormal(vec3 hitPos, Object obj)\n{\n#if SUPPORT_QUADS\n\tif (obj.radius == 0.0)\n\t\treturn obj.quadNormal;\n\telse\n#endif // SUPPORT_QUADS\n\t\treturn normalize(hitPos - obj.pos);\n}\n\nint IntersectScene(Ray ray, out float out_t, out Object out_obj, int ignoreObjId)\n{\n\tint id = -1;\n\tout_t = 1e5;\n\tout_obj = objects[0]; // none\n\tfor (int i = 0; i < NUM_OBJECTS; i++) {\n\t\tObject obj = objects[i];\n\t\tfloat t = IntersectObject(ray, obj);\n\t\tif (i != ignoreObjId && t != 0.0 && t < out_t) {\n\t\t\tid = i;\n\t\t\tout_t = t;\n\t\t\tout_obj = obj;\n\t\t}\n\t}\n\treturn id;\n}\n\nvec3 SampleHemisphere(vec3 N, float sinTheta, float cosTheta)\n{\n\tvec3 w = normalize(N);\n\tvec3 u = normalize(cross(w.yzx, w));\n\tvec3 v = cross(w, u);\n    float phi = 2.0*PI*rand();\n\treturn (u*cos(phi) + v*sin(phi))*sinTheta + w*cosTheta;\n}\n\nvec3 SampleHemisphereCosineWeighted(vec3 N)\n{\n    float sinThetaSqr = rand();\n\tfloat sinTheta = sqrt(sinThetaSqr);\n\tfloat cosTheta = sqrt(1.0 - sinThetaSqr);\n\treturn SampleHemisphere(N, sinTheta, cosTheta);\n}\n\nvec3 SampleHemisphereUniform(vec3 N)\n{\n\tfloat cosTheta = rand();\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    float phi = 2.0*PI*rand();\n    float sinPhi = sin(phi);\n\tfloat cosPhi = cos(phi);\n\tvec3 dir = vec3(vec2(cosPhi, sinPhi)*sinTheta, cosTheta);\n    dir *= sign(dot(dir, N));\n    return dir;\n}\n\nvec3 SampleLight(Object light, int lightId, int ignoreObjId, vec3 P, vec3 N, int numLightSamples)\n{\n    float e = 0.0;\n    for (int i = 0; i < numLightSamples; i++) { // TODO -- setting numLightSamples > 1 doesn't work\n        vec3 L;\n        float omega;\n    #if SUPPORT_QUADS\n        if (light.radius == 0.0) {\n            float sx2 = 1.0/dot(light.quadBasisX, light.quadBasisX);\n            float sy2 = 1.0/dot(light.quadBasisY, light.quadBasisY);\n            vec3 ex = sx2*light.quadBasisX; // could precompute this ..\n            vec3 ey = sy2*light.quadBasisY;\n            float rx = rand()*2.0 - 1.0;\n            float ry = rand()*2.0 - 1.0;\n            vec3 V = light.pos + ex*rx + ey*ry - P;\n            L = normalize(V);\n            float area = 4.0*sqrt(sx2*sy2); // could precompute this ..\n            omega = area*max(0.0, -dot(light.quadNormal, L))/dot(V, V);\n        } else\n    #endif // SUPPORT_QUADS\n        {\n            // http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources.html\n            vec3 V = light.pos - P;\n            float r = light.radius;\n            float sinThetaMaxSqr = r*r/dot(V, V);\n            float cosThetaMax = sqrt(1.0 - sinThetaMaxSqr);\n            float cosTheta = cosThetaMax + (1.0 - cosThetaMax)*rand();\n            float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n            L = SampleHemisphere(V, sinTheta, cosTheta);\n            omega = 2.0*PI*(1.0 - cosThetaMax);\n        }\n        float t;\n        if (IntersectScene(Ray(P, L), t, light, ignoreObjId) == lightId)\n            e += max(0.0, dot(N, L))*omega/PI;\n    }\n\treturn light.emissive*e/float(numLightSamples);\n}\n\nvec3 ComputeRadiance(vec2 fragCoord, Ray ray)\n{\n#if NEXT_EVENT_PREDICTION_SCREEN_SPLIT\n\tbool nextEventPrediction = fragCoord.x > iMouse.x;//float(fragCoord.x)*2.0 > iResolution.x;\n#else\n\tbool nextEventPrediction = bool(NEXT_EVENT_PREDICTION);\n#endif\n    uint wasPredicted = 0U;\n\tvec3 acc = vec3(0);\n\tvec3 mask = vec3(1);\n    int id = -1;\n\tfor (int depth = 0; depth < MAX_DEPTH; depth++) {\n\t\tfloat t;\n\t\tObject obj;\n\t\tif ((id = IntersectScene(ray, t, obj, id)) < 0)\n\t\t\tbreak;\n\t\tvec3 hitPos = ray.origin + t*ray.dir;\n\t\tvec3 N = GetSurfaceNormal(hitPos, obj);\n        if ((wasPredicted & (1U << id)) == 0U)\n\t\t\tacc += mask*obj.emissive;\n        wasPredicted = 0U;\n\t\tif (obj.materialType == MATERIAL_TYPE_DIFFUSE) {\n\t\t\tmask *= obj.albedo;\n\t\t\tif (nextEventPrediction && depth + 1 < MAX_DEPTH) {\n\t\t\t\tvec3 e = vec3(0);\n                for (int lightId = 0; lightId < NUM_OBJECTS; lightId++) {\n                    Object light = objects[lightId];\n                    if (IsLight(light)) {// && rand() <= 0.5) {\n                        int numLightSamples = 1;//fragCoord.y < iMouse.y ? 1 : 8;\n                        e += SampleLight(light, lightId, id, hitPos, N, numLightSamples);\n                        wasPredicted |= (1U << lightId);\n                    }\n                }\n\t\t\t\tacc += mask*e;\n\t\t\t}\n            // TODO -- support codepath using uniform hemisphere\n\t\t\t//vec3 dir = SampleHemisphereUniform(N);\n            //mask *= dot(N, dir);\n            vec3 dir = SampleHemisphereCosineWeighted(N);\n    \t\tray = Ray(hitPos, dir);\n\t\t} else if (obj.materialType == MATERIAL_TYPE_SPECULAR) {\n\t\t\tmask *= obj.albedo;\n\t\t\tray = Ray(hitPos, reflect(ray.dir, N));\n\t\t} else { // MATERIAL_TYPE_REFRACTIVE\n\t\t\tfloat a = dot(N, ray.dir);\n\t\t\tfloat ddn = abs(a);\n\t\t\tfloat nc = 1.0;\n\t\t\tfloat nt = 1.5;\n\t\t\tfloat nnt = mix(nc/nt, nt/nc, float(a > 0.0));\n\t\t\tfloat cos2t = 1.0 - nnt*nnt*(1.0 - ddn*ddn);\n\t\t\tray = Ray(hitPos, reflect(ray.dir, N));\n\t\t\tif (cos2t > 0.0) {\n\t\t\t\tvec3 tdir = normalize(ray.dir*nnt + sign(a)*N*(ddn*nnt + sqrt(cos2t)));\n\t\t\t\tfloat R0 = (nt - nc)/(nt + nc);\n\t\t\t\tR0 *= R0;\n\t\t\t\tfloat c = 1.0 - mix(ddn, dot(tdir, N), float(a > 0.0));\n\t\t\t\tfloat Re = R0 + (1.0 - R0)*c*c*c*c*c;\n\t\t\t\tfloat P = 0.25 + 0.5*Re;\n\t\t\t\tfloat RP = Re/P;\n\t\t\t\tfloat TP = (1.0 - Re)/(1.0 - P);\n\t\t\t\tif (rand() < P)\n\t\t\t\t\tmask *= RP;\n\t\t\t\telse {\n\t\t\t\t\tmask *= obj.albedo*TP;\n\t\t\t\t\tray = Ray(hitPos, tdir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn acc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tInitObjects();\n\tInitRandom(fragCoord);\n    \n\tvec2 offset = fract(iTime*vec2(23.75310853, 21.95340893)) - 0.5; // [-0.5..0.5], from https://www.shadertoy.com/view/MdKyRK\n\tvec2 uv = fragCoord.xy/iResolution.xy; // [0..1]\n\tvec2 st = 2.0*(fragCoord + offset)/iResolution.xy - 1.0; // [-1..1], randomly jittered\n\tvec3 control = texture(iChannel0, 0.5/iResolution.xy).xyz;\n\tvec2 mouse = 2.0*iMouse.xy/iResolution.xy - 1.0; // [-1..1]\n    if (iMouse.xy == vec2(0))\n        mouse = vec2(0.5);\n    \n\t//mouse = vec2(0.5); // locked\n\t\n\t// camera matrix\n\tvec3 camPos = vec3(mouse*vec2(48.0, 40.0), 0.0) + vec3(50.0, 40.8, 139.0);\n\tvec3 lookAt = vec3(50.0, 40.0, 81.6);\n\tvec3 cz = normalize(lookAt - camPos);\n\tvec3 cy = vec3(0,1,0);\n\tvec3 cx = normalize(cross(cz, cy));\n\tcy = cross(cx, cz);\n\n\tvec3 rayOrigin = camPos;\n\tfloat VFOV = 80.0;\n\tfloat tanVFOV = tan(VFOV*0.5*PI/180.0);\n\tfloat aspect = iResolution.x/iResolution.y;\n\n\tvec3 rayDir = normalize((aspect*st.x*cx + st.y*cy)*tanVFOV + cz);\n\tvec3 color = vec3(0);\n\tfor (int i = 0; i < NUM_SAMPLES; i++)\n\t\tcolor += ComputeRadiance(fragCoord, Ray(rayOrigin, rayDir));\n\tcolor /= float(NUM_SAMPLES);\n\n\tfloat frame = max(0.0, float(iFrame) - control.z);\n\tif (iMouse.z > 0.0)\n\t\tframe = 0.0;\n\tif (floor(fragCoord.xy) == vec2(0)) { // bottom right fragment is used for control\n\t\tif (iMouse.z > 0.0) // dragging ..\n\t\t\tcolor = vec3(0, 0, iFrame); // save current iFrame (xy not used)\n\t\telse\n\t\t\tcolor = control; // keep previous iFrame\n\t} else if (frame > 0.0) {\n\t\tfloat accum = 1.0/(frame + 1.0);\n\t\tcolor = color*accum + texture(iChannel0, uv).rgb*(1.0 - accum);\n\t}\n\tfragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}