{"ver":"0.1","info":{"id":"mlBBWt","date":"1694613423","viewed":71,"name":"Raymarched Ocean (FBM)","username":"pugly","description":"forked from my other ray marching project","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","fbm","ocean"],"hasliked":0,"parentid":"ct2fDK","parentname":"ray march attempt"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 CAMERA_POS = vec3(-1.,.1,0.);\n\nfloat random(in vec2 p) {\n    return fract(sin(dot(p,\n        vec2(16.12327, 27.4725))) *\n        29322.1543424);\n}\n\nfloat noise(in vec2 p) {\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) +\n        (c - a) * u.y * (1.0-u.x) +\n        (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 5\n\nfloat fbm(in vec2 p) {\n\n    float t = .5;\n    mat2 rot = mat2(\n        4./5., -3./5.,\n        3./5., 4./5.\n    );\n\n    float value = 0.;\n    float amp = .5;\n    float freq = 0.;\n    \n    for (int i = 0; i < OCTAVES; i++) {\n    \n        value += amp * noise(p.yx * rot + iTime/2.);\n        p *= 2.;\n        amp *= .5;\n    \n    }\n    \n    return value;\n}\n\nfloat repFbm(in vec2 p, int l) {\n    \n    float o = 0.;\n    \n    for (int i = 0; i < l; i++) {\n    \n        o = fbm(vec2(p+o));\n    \n    }\n    \n    return o;\n    \n}\n\nfloat map(in vec3 p) {\n\n    //float d = p.y + repFbm(p.xz / 2., 5);\n    float d = p.y + fbm(p.xz);\n    return d;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<40; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nconst vec3 lSource = vec3(1.3,0.2,1.);\nconst vec3 lCol = vec3(0.000,0.043,0.639);\nfloat lPow = 1.;\n\nconst vec3 lSource2 = vec3(0.1, 0.5, 0.5);\nconst vec3 lCol2 = vec3(.2,0.,0.);\nfloat lPow2 = .4;\n\nconst vec3 fogCol = vec3(0.1, 0.5, 0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n\tvec3 ro = CAMERA_POS + vec3(iTime/2.,0.,0.);\n\tvec3 rd = normalize( vec3(p-vec2(0.,.5),-1.) );\n\n    vec3 col = vec3(0);\n    \n    float t = intersect(ro,rd);\n\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        col = mix(vec3(0.149,0.345,0.427),\n            vec3(0.741,0.949,1.000),\n            pos.y);\n        col += clamp(dot(lSource,nor) * lCol * lPow,0.,1.);\n        //col += .5+.5*dot(lSource2,nor) * lCol2;\n        if (dot(nor, vec3(0.,1.,0.)) > .998)\n            col = vec3(1.);\n        col = mix(col, fogCol, 1.-exp(-t*0.03));\n\t} else {\n    \n        col = vec3(0., 0.95-(p.y+.1)/1.3, 0.95-p.y/2.);\n    \n    }\n\n    col = sqrt(col);\n    \n    col -= exp(abs(p.y))/50.;\n    col -= exp(abs(p.x))/50.;\n   \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}