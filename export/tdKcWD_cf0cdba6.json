{"ver":"0.1","info":{"id":"tdKcWD","date":"1602899337","viewed":417,"name":"Fishermen at sea","username":"athibaul","description":"Reproduction of the painting [url=https://en.wikipedia.org/wiki/Fishermen_at_Sea]Fishermen at Sea[/url] by William Turner.","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["procedural","waves","sea","ocean","painting","reproduction","williamturner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Trying to recreate the painting \"Fishermen at sea\" by William Turner\n// https://www.tate.org.uk/art/artworks/turner-fishermen-at-sea-t01585\n\n// I have rediscovered William Turner's paintings recently; \n// here is my take on this moonlight scene.\n// Many elements are missing (including the fishermen themselves!),\n// and the lighting is not quite on point, but I think it's already\n// rather pretty.\n\n\n\n// Inspired by \"Seascape\" by TDM\n// https://www.shadertoy.com/view/Ms2SD1\n\n// My clouds are 2D, but their lighting was inspired by\n// \"Clouds\" by iq\n// https://www.shadertoy.com/view/XslGRr\n\n// The non-physically-based lighting was inspired by\n// \"Live Coding \"Greek Temple\"\" by iq\n// https://youtu.be/-pdSjBPH3zM?t=5092\n\n\n\n\n\n#define ITER_GEOM 2\n#define ITER_SHADING 8\n#define WAVE_HEIGHT 1.2\n#define dot2(a) dot(a,a)\n\n#define T0(ip) texelFetch(iChannel0, ivec2(mod(ip,256.)), 0).r\n#define rgb(r,g,b) pow(vec3(r,g,b)/255., vec3(2.2))\n\nconst vec2 subject = vec2(-1.3,5.);\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p), fp = fract(p);\n    fp = smoothstep(0.,1.,fp);\n    vec2 e = vec2(1,0);\n    return mix(\n        mix(T0(ip     ), T0(ip+e.xy), fp.x),\n        mix(T0(ip+e.yx), T0(ip+e.xx), fp.x),\n        fp.y);\n}\n\n\nfloat seaOctave(vec2 uv, bool choppy)\n{\n    // Adapted from TDM \"Seascape\"\n    uv += 2.*noise(uv);\n    uv.x *= 0.62;\n    vec2 wv = 0.5+0.5*cos(2.*uv);\n    float w = pow(wv.x * wv.y, 0.6);\n   \tif(choppy)\n        return (1.-w)*(1.-w);\n    return 1.-w;\n}\n\nfloat clouds(vec2 uv, float time, float displace)\n{\n    uv += 0.7*noise(displace*uv + time) + time*vec2(1.,0.3);\n    float f = 0.5*noise(uv);\n    f += 0.25*noise(2.*uv) + 0.125*noise(4.*uv) + 0.0625*noise(8.*uv);\n    return f;\n}\n\n\nfloat seaHeight(vec2 uv, float time, int iter)\n{\n    vec2 p = uv;\n    uv *= 0.4;\n    float phase = time*0.18;\n    float h = 0.;\n    float amp = 0.25 * mix(0.2, 1.0, smoothstep(15.,5.,length(p-subject)));\n    for(int i=0; i<iter; i++)\n    {\n        bool choppy = (i<3);\n        h += amp * (seaOctave(uv+phase, choppy) + seaOctave(-uv+phase, choppy));\n        //uv *= mat2(.6,.8,-.8,.6)*2.;\n        uv *= mat2(0,2,-2,0);\n        // Wave propagation speed is approximately proportional to sqrt(wavenumber)\n        // https://en.wikipedia.org/wiki/Dispersion_(water_waves)\n        // so we scale phase by the appropriate factor\n        phase *= sqrt(2.);\n        amp *= 0.4;\n    }\n    return h;\n}\n\n\nfloat map(vec3 p, int iter)\n{\n    float d = p.z + WAVE_HEIGHT*(1. - seaHeight(p.xy, iTime, iter));\n     // Forced perspective : the sea in the foreground is lowering toward the viewer\n    d += 2./(1.+p.y) - 0.4;\n    return d;\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n    if(rd.z > 0.) return 100.;\n    float d, t=-ro.z/rd.z; // Water surface is below z=0\n    for(int i=0; i<100; i++)\n    {\n        d = map(ro+t*rd, ITER_GEOM);\n        if(d < 0.005 || t > 100.) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p, int iter)\n{\n    float eps = 0.005;\n    #if 0\n    vec2 e = eps * vec2(1,-1);\n    return normalize(\n          e.xxx*map(p+e.xxx, iter)\n        + e.xyy*map(p+e.xyy, iter)\n        + e.yxy*map(p+e.yxy, iter)\n        + e.yyx*map(p+e.yyx, iter)\n        );\n    #else\n    vec2 e = eps*vec2(1,0);\n    return normalize(\n        vec3(\n            map(p+e.xyy, iter) - map(p-e.xyy, iter),\n            map(p+e.yxy, iter) - map(p-e.yxy, iter),\n            2.*e.x\n            ));\n    #endif\n}\n\nconst vec3 moonColor = rgb(182,168,107);\nconst vec3 seaColor = rgb(35,59,59)*3.;\nconst vec3 horizonTint = rgb(140,120,61)/moonColor;\n\nvec3 moon = normalize(vec3(-0.2,1.0,0.35));\n\nvec3 getSkyColor(vec3 rd)\n{\n    float LdotV = dot(rd, moon);\n    float surface = 0.01*0.01;\n    float moonDisk = smoothstep(2.*surface, surface, 1.-LdotV);\n    \n    float cltime = iTime*0.1; // Clouds\n    vec2 cluv = rd.xz / (1.+rd.y);\n    vec2 moonuv = moon.xz / (1.+moon.y);\n    \n    vec3 moonHalo = vec3(clamp((1.+LdotV)/2., 0., 1.));\n    \n    moonHalo = pow(moonHalo, vec3(20,18,18)*1.5) * moonColor;\n    \n    moonHalo *= smoothstep(0.5,0.0,abs(cluv.x-moonuv.x));\n    \n    vec3 col = moonDisk * moonColor * 3. + moonHalo;\n    \n    \n    {\n        // Back clouds\n        float cl = clouds(vec2(50,100) * cluv, cltime, 3.);\n        float cl2 = clouds(vec2(50,100) * mix(cluv, moonuv, 0.05), cltime, 3.);\n        float lig = max((cl-cl2), 0.) / max(dot2(moonuv-cluv),1e-3)*0.03;\n        //cl += smoothstep(0.2, 0.6, length(vec2(rd.z, rd.x+0.15*rd.y)));\n        //cl = smoothstep(0.5, 1.0, cl);\n        cl *= smoothstep(0.,0.2,length(cluv-moonuv));\n        vec3 clcol = lig * mix(moonColor, vec3(0.5), 0.5);\n        col = mix(col, clcol, cl);\n    }\n    \n    // Front clouds\n    float cl = clouds(vec2(30,50) * cluv, cltime, 1.);\n    cl += smoothstep(0.2, 0.6, length(vec2(rd.z, rd.x+0.15*rd.y)));\n    cl = smoothstep(0.5, 1.0, cl);\n    float cl2 = clouds(vec2(30,50) * mix(cluv, moonuv, 0.01), cltime, 1.);\n    cl2 += smoothstep(0.2, 0.6, length(vec2(rd.z, rd.x+0.15*rd.y)));\n    cl2 = smoothstep(0.5, 1., cl2);\n    float lig = max((cl-cl2), 0.);\n    \n    lig *= 1. / max(dot2(moonuv-cluv),1e-3)*0.05;\n    \n    vec3 clcol = lig*moonColor*vec3(1.,0.8,0.6);\n    col = mix(col, clcol, cl);\n   \n    \n    \n    \n    float fogDepth = 1./max(rd.z,0.001);\n    fogDepth = mix(fogDepth, 0., cl*smoothstep(0.,0.3,rd.z));\n    col = mix(col, moonHalo*horizonTint, 1.-exp(-0.08*fogDepth));\n    \n    return col;\n}\n\nvec3 getBigMoonColor(vec3 rd)\n{\n    // Fake reflections using a big moon\n    //vec3 dist = vec3(0.05,1.,1.);\n    //vec3 rd2 = normalize(dist*rd), moon2=normalize(-dist*moon);\n    vec3 rd2 = rd, moon2 = normalize(vec3(0.,10.,5.));\n    float LdotV = dot(rd, moon);\n    float surface = 3e-4;\n    float moonDisk = smoothstep(surface, 0., 1.-LdotV);\n    return moonColor*moonDisk*0.002/surface;\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float d, t=0.;\n    for(int i=0; i<20; i++)\n    {\n        d = map(ro+t*rd, ITER_GEOM);\n        if(d < 0.02 || t > 100.) break;\n        t += d;\n    }\n    return t>10. ? 1. : 0.;\n}\n\nvec3 calculateColor(vec3 ro, vec3 rd)\n{\n    \n    float t = raymarch(ro, rd);\n    if(t < 100.)\n    {\n    \tvec3 p = ro+t*rd;\n        vec3 n = normal(p, ITER_SHADING);\n        vec3 rrd = reflect(rd, n);\n        //vec3 col = vec3(seaHeight(p.xy, iTime, ITER_SHADING));\n        vec3 col = 0.5+0.5*n;\n        \n        float fre = 1.0 - clamp(dot(-rd, n), 0.0, 1.0);\n        fre = pow(fre, 5.);\n        \n        // Here come the non-physical lighting tricks!\n        \n        // Fake subsurface scattering inspired by Tekf\n        // \"Wax (fake subsurface)\"\n        // https://www.shadertoy.com/view/lslXRj\n        float subsurfDist = 0.15;\n        float subsurfCoef = (map(p + moon*subsurfDist, 1) - map(p, 1))/subsurfDist;\n        subsurfCoef = smoothstep(0.25, 0.5, subsurfCoef);\n        // Modulate this component to highlight only the backfaces of waves\n        float backSubsurfCoef = clamp(dot(n, vec3(-1,-1,0)*moon), 0., 1.0);\n        float subsurfDist2 = 0.5;\n        float subsurfCoef2 = (map(p + moon*subsurfDist2, ITER_GEOM) - map(p, ITER_GEOM))/subsurfDist2;\n        subsurfCoef2 = clamp(subsurfCoef2, 0., 1.);\n        vec3 diffuse = 2.*seaColor * subsurfCoef2;\n        \n        float subjectDist = length(p.xy - subject);\n        // Add the strange lighting in the background\n        float backDist = length(p.xy - vec2(-10.,50.)*0.8);\n        vec3 backLight = pow(smoothstep(30.,0.,backDist),3.)*vec3(3.8,4.,5.)*2.;\n        diffuse *= smoothstep(5., 0.0, subjectDist) + backLight;\n        diffuse += 5.*moonColor*backSubsurfCoef*subsurfCoef * smoothstep(3.,0.,subjectDist);\n        \n        float LdotN = dot(n, moon);\n        //diffuse *= 1.+LdotN;\n        \n        vec3 specular = getSkyColor(rrd) * backLight;\n        \n        specular += getBigMoonColor(rrd)\n     \t\t\t\t* smoothstep(5.0, 0.0, subjectDist);\n\t\t\t\t\t//* shadow(p+0.01*n, rrd);\n\t\t\n        {\n            // Add a light at the position of the \"subject\"\n            vec3 lpos = vec3(subject, 0.15-map(vec3(subject,0),ITER_GEOM));\n            vec3 ldir = lpos - p;\n            vec3 lcol = vec3(1.,0.3, 0.03);\n            float ldist = length(ldir);\n            ldir /= ldist;\n            float intensity = 1./(ldist*ldist);\n           \tfloat LdotV = clamp(dot(ldir, rrd), 0., 1.);\n            specular += lcol * pow(LdotV, 1000.) * 10.*intensity;\n            diffuse += lcol * LdotV * intensity*0.01;\n        }\n        \n            \n        col = mix(diffuse, specular, fre);\n        \n        //col += moonColor *3. * pow(smoothstep(30.,0.,backDist), 3.)*fre;\n        \n        // Mix with fog\n        float fog = 1.-exp(-t*0.02);\n        col = mix(col, getSkyColor(vec3(rd.xy, 0.)), fog);\n        \n        return col;\n    } else\n    {\n        return getSkyColor(rd);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = vec3(0,0,0.1);\n    vec3 rd = normalize(vec3(uv.x,2.,uv.y+0.2));\n    \n    vec3 col = calculateColor(ro, rd);\n    \n    col = mix(col, 1.-(4./27.)/(col*col), step(2./3.,col));\n    col = pow(col, vec3(1./2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}