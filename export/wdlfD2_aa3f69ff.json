{"ver":"0.1","info":{"id":"wdlfD2","date":"1589387540","viewed":207,"name":"Hyperbolic bloom","username":"sl2c","description":"A horospherical slice a la Bulatov as in [url=https://www.shadertoy.com/view/tsXfWS#]my earlier shader[/url] but this time with a coloring of the icosahedra in the icosahedral honeycomb.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolic","horosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n#define swap(sigma) {for(int k=0;k<6;k++) {int temp = curr[k]; curr[k]=curr2[sigma[k]]; curr2[sigma[k]]=temp;}}\n#define swap2(i,j) {int temp = curr[i]; curr[i]=curr[j]; curr[j]=temp;}\n\nbool flip(inout vec3 z, inout float ds, in vec2 c, in float r, inout float t) {\n    z -= vec3(c,0.0);\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        ds *= r * r / dot(z,z);\n        z *= r * r / dot(z,z);\n    }\n    t = min(1.0, (dot(z,z)-r*r)/(2.0 * r * ds));\n    z += vec3(c,0.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float phi = 0.5 + sqrt(1.25);\n    vec2 c3 = vec2(phi, phi*phi);\n    float r3 = 2.0 * phi;\n    float r4 = 2.0 / (sqrt(3.0*phi-1.0)-phi*phi);\n    vec2 c4 = vec2(0.0, 0.5*r4);\n    \n    vec3[6] cols = vec3[](\n    \tvec3(1.0,0.5,0.0),\n    \tvec3(0.5,1.0,0.0),\n    \tvec3(0.0,1.0,0.5),\n    \tvec3(0.0,0.5,1.0),\n    \tvec3(0.5,0.0,1.0),\n    \tvec3(1.0,0.0,0.5));\n    \n    int[6] curr = int[](0,1,2,3,4,5);\n    int[6] curr2 = int[](0,1,2,3,4,5);\n    \n    int[6] sigma1 = int[](0,1,2,3,4,5);\n    int[6] sigma2 = int[](0,3,4,1,2,5);\n    int[6] sigma3 = int[](0,1,2,4,5,3);\n    int[6] sigma4 = int[](1,0,2,3,5,4);\n    \n    vec2 z = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 2.0 / iResolution.y;\n    z *= 6.0; ds *= 6.0;\n    vec3 zh = vec3(z, 1.0);\n    \n    float period = 0.6149689755422006;\n    float d = iTime * 0.2;\n    while (d > period * 0.1) {\n        float c = -0.8861114478828093; float s = -0.4634722234730269;\n        zh.xy = vec2(zh.x * c - zh.y * s, zh.x * s + zh.y * c);\n        d -= period;\n        swap2(0,1); swap2(3,4); swap2(1,3); swap2(2,4); \n    }\n    curr2 = curr;\n    \n    \n    zh *= exp(-d); ds *= exp(-d);\n    zh += vec3(0.09504814910742845,0.19915381513146063,0.0);\n    zh /= dot(zh, zh); ds *= dot(zh, zh);\n    zh -= vec3(0.9759259749906782,2.0448518254217527,0.0);\n    \n    float t = 1.0;\n    bool fl = false;\n    \n    for (int i=0; i<15; i++) {\n        if (zh.x < 0.0) {\n            zh.x = -zh.x;\n            fl = !fl;\n            swap(sigma1);\n        }\n        if (zh.y < 0.0) {\n            zh.y = -zh.y;\n            fl = !fl;\n            swap(sigma2);\n        }\n        \n        float throwaway;\n        if (flip(zh, ds, c3, r3, throwaway)) {\n            fl = !fl;\n            swap(sigma3);\n        }\n        if (flip(zh, ds, c4, r4, t)) {\n            fl = !fl;\n            swap(sigma4);\n        }\n    }\n\n    t = (1.0 - t) * 0.5;\n    vec3 col1 = cols[fl ? curr[0] : curr2[0]];\n    swap(sigma4);\n    vec3 col2 = cols[fl ? curr2[0] : curr[0]];\n    vec3 col = col1 * (1.0-t) + col2 * t;\n\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}","name":"Image","description":"","type":"image"}]}