{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// metropolis\n// @simesgreen 9/2013\n\nconst int maxSteps = 128;\nconst float hitThreshold = 0.0001;\nconst float rayOffset = 0.0002;\nconst float PI = 3.1415926535;\n\nconst vec3 skyTop = vec3(0.15, 0.25, 0.45);\nconst vec3 skyBot = vec3(1.0, 0.3, 0.0);\nconst vec3 lightColor = vec3(1.0, 0.5, 0.1);\nconst vec3 sunColor = vec3(1.0, 0.5, 0.1)*2.0;\nconst vec3 ambientCol = vec3(0.0, 0.1, 0.2);\nconst vec3 winColor = vec3(1.0, 0.4, 0.1)*0.8;\nconst vec3 winColor2 = vec3(1.0, 1.0, 0.1);\n\n// primitive functions\n// these all return the distance to the surface from a given point\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat _union(float a, float b, inout float m, float nm)\n{\n    m = (b < a) ? nm : m;\n    return min(a, b);\t\t\n}\n\nfloat building(vec3 p)\n{\n\tconst float s = 0.6;\n\tconst float s2 = 0.3;\n\tconst float s3 = 0.15;\n\n\tvec2 gi = floor(p.xz * 0.5);\n\tp.xz = mod(p.xz, 2.0) - 1.0;\n\t\n\t//float h = 1.0;\n\tvec4 r = texture(iChannel0, gi / iChannelResolution[0].xy);\n\tfloat h = r.x*r.x * 2.0 + 0.5;\n\t//h *= (abs(gi.x) > 4.0 || abs(gi.y) > 4.0) ? 0.0 : 1.0;\n\t//h *= exp(-dot(gi*0.1, gi*0.1));\n\t\n\tfloat d = box(p - vec3(0.0, h, 0.0), vec3(s, h, s));\n\t\n\tif (r.y > 0.5) {\n\t\t// 2nd storey\n\t\td = min(d, box(p - vec3(0.0, h*2.0+h*s2, 0.0), vec3(s2, h*s2, s2)));\t\n\t}\n\tif (r.y > 0.6) {\n\t\t// 3rd storey\n\t\td = min(d, box(p - vec3(0.0, h*2.0+h*s2*2.0+h*s3, 0.0), vec3(s3, h*s3, s3)));\t\t\n\t}\t\n\treturn d;\n}\n\n// distance to scene\nfloat scene(vec3 p, out float m)\n{          \n    float d = 1e10;\n\tm = 0.0;\n\td = plane(p, vec4(0.0, 1.0, 0.0, 0.0));\n\n\tp.z += iTime;\t\n\t//d = min(d, building(p));\n\td = _union(d, building(p), m, 1.0);\n\t\t\n\treturn d;\n}\n\n// calculate scene normal\nvec3 sceneNormal(in vec3 pos )\n{\n    float eps = 0.0001;\n    vec3 n;\n\tfloat m;\n    float d = scene(pos, m);\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z), m ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z), m ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps), m ) - d;\n    return normalize(n);\n}\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n\t\tfloat m;\n        a += weight*(d - scene(p + n*d, m));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit, out float m)\n{\n    hit = false;\n    vec3 pos = ro;\n    for(int i=0; i<maxSteps; i++)\n    {\n\t\tfloat d = scene(pos, m);\n\t\tif (d < hitThreshold) {\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\tpos += d*rd*0.5;\n    }\n    return pos;\n}\n\nvec3 background(vec3 rd, float tod, vec3 lightDir)\n{\n\t// pretty sunset\n\tfloat g = 1.0 - (rd.y*0.5+0.7);\n\tvec3 c = mix(skyTop, skyBot, g);\n\t\n\tfloat night = smoothstep(0.6, 0.7, tod) * smoothstep(0.9, 0.8, tod);\n\tc = mix(c, vec3(0.0, 0.0, 0.1), night);\n\t\n\tfloat sun = pow(max(0.0, dot(rd, lightDir)), 50.0);\t\n\tc += sun*sunColor;\n\t\n\tc = mix(c, vec3(0.0), rd.y > 0.0 ? 0.0 : 1.0);\n\treturn c;\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos, float m, float tod, vec3 lightDir, out float win, out vec3 light)\n{\n    float ao = ambientOcclusion(pos, n);\n\tvec3 c = ambientCol*ao;\n\t\t\n\t//float diff = max(0.0, dot(n, lightDir));\n\tfloat diff = dot(n, lightDir)*0.5+0.5;\n\t\n\tbool shadow;\n\tfloat m2;\n\tvec3 p2 = trace(pos + lightDir*rayOffset, lightDir, shadow, m2);\n\n\tvec3 sp = pos;\n\tsp.z += iTime;\n\n\t// lights on at night:\n\tfloat lightsOn = smoothstep(0.5, 0.7, tod) * smoothstep(1.0, 0.9, tod) * 0.5;\n\t\n\tif (m==0.0) {\n\t\t// street\t\n\t\tc += lightColor*diff*(shadow ? 0.5 : 1.0)*vec3(0.25);\n\t\t\n#if 0\n\t\tvec2 tp = fract(sp.xz*0.5);\n\t\tvec2 road = smoothstep(0.85, 0.95, tp) + smoothstep(0.15, 0.05, tp);\n\t\troad.x = clamp(road.x + road.y, 0.0, 1.0);\n\n        // car lights\n\t\tvec2 a = smoothstep(0.0, 0.1, tp) * smoothstep(0.2, 0.1, tp) + \n\t\t\t     smoothstep(0.8, 0.9, tp) * smoothstep(1.0, 0.9, tp);\n\t\tvec4 tex = texture(iChannel0, tp * 0.05);\n\t\ta.xy *= tex.x*tex.x;\t\t\n\t\tc += max(a.x, a.y)*vec3(1.0, 0.0, 0.0) * lightsOn*2.0;\n#endif\n\t\t\n\t} else {\n\t\t// building\n\t\tc += lightColor*diff*(shadow ? 0.5 : 1.0)*0.5;\n\t\t\t\n\t\t// windows\n\t\tconst vec3 rep = vec3(22.0, 12.0, 22.0);\n\t\t\n\t\tvec3 fp = fract(sp*rep);\n\t\tvec3 ip = floor(sp*rep);\n\t\t// window pattern, could do with some AA here...\n\t\twin = smoothstep(0.1, 0.2, fp.x) * smoothstep(0.9, 0.8, fp.x);\n\t\twin *= smoothstep(0.1, 0.2, fp.y) * smoothstep(0.9, 0.8, fp.y);\n\t\twin *= smoothstep(0.1, 0.2, fp.z) * smoothstep(0.9, 0.8, fp.z);\n\t\twin *= (n.y <= 0.0) ? 1.0 : 0.0; // no windows on top\n\t\t\n\t\t// randomize lights\n\t\tconst vec2 scale = vec2(1.0, 10.0);\n\t\tfloat rnd = texture(iChannel0, (ip.xy / iChannelResolution[0].xy)*scale).x;\n\t\tfloat rnd2 = texture(iChannel0, (ip.zy / iChannelResolution[0].xy)*scale).x;\n\t\trnd = mix(rnd, rnd2, abs(n.x) > abs(n.z) ? 1.0 : 0.0);\n\t\tfloat lightOn = step(rnd, lightsOn);\n\t\t\n\t\tlight = mix(winColor, winColor2, rnd)*win*lightOn;\n\t\tc += light;\n\t}\n\t\t\n\treturn c;\t\n}\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -1.5));\n    vec3 ro = vec3(0.0, 2.0, 5.0);\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tfloat roty = 0.0;\n\tfloat rotx = -0.2;\n\t\t\n\tif (iMouse.z > 0.0) {\n\t\trotx = -(0.9-mouse.y)*PI;\n\t\troty = -(mouse.x-0.5)*PI*4.0;\n\t} else {\n\t\tfloat cut = fract(iTime / 11.0);\n\t\tif (cut > 0.7) {\n\t\t\t// helicopter view\n\t\t\trotx = -PI*0.5;\t\n\t\t}\n\t\troty = iTime*0.15;\t\t\n\t}\n     \n    rd = rotateX(rd, rotx);\n    ro = rotateX(ro, rotx);\n          \n    rd = rotateY(rd, roty);\n    ro = rotateY(ro, roty);\n    \n    // totally unrealistic sun position...\n    float tod = fract(iTime*0.1);\n    float ax = PI*0.6 - (sin(tod*PI*2.0)*0.5+0.5)*PI*0.4;\n    float ay = tod*PI*2.0;\n    vec3 lightDir = vec3(sin(ax)*cos(ay), cos(ax), sin(ax)*sin(ay));\n            \t\n    // trace ray\n    bool hit;\n\tfloat m;\n    vec3 pos = trace(ro, rd, hit, m);\n\n    vec3 c;\n    if(hit) {\n        // calc normal\n        vec3 n = sceneNormal(pos);\n        // shade\n\t\tfloat win;\n\t\tvec3 light;\n        c = shade(pos, n, ro, m, tod, lightDir, win, light);\n\t\t\t\t\n#if 1\n\t\tif (m==1.0) {\n\t\t\t// reflections\n\t\t\tvec3 i = normalize(pos - ro);\n\t\t\tvec3 r = reflect(i, n);\n\t\t\tfloat fresnel = 0.5 + 0.5*pow( clamp(1.0-dot(-i, n), 0.0, 1.0), 5.0);\n\t\t\t//float fresnel = 1.0;\n\t\t\t//c = vec3(fresnel);\n\t\n\t\t\tvec3 ro2 = pos + n*rayOffset;\n\t\t\tfloat m2;\n\t\t\tvec3 pos2 = trace(ro2, r, hit, m2);\n\t\t\t\t\t\n\t\t\tif (hit) {\n\t\t\t\tfloat win2;\n\t\t\t\tvec3 light2;\n\t\t\t\tn = sceneNormal(pos2);\n\t\t\t\tvec3 rcol = shade(pos2, n, ro2, m2, tod, lightDir, win2, light2);\n\t\t\t\tc = mix(c, clamp(rcol*fresnel + light, vec3(0.0), vec3(1.0)), win);\n\t\t\t} else {\n\t\t\t\tc = mix(c, background(r, tod, lightDir)*fresnel + light, win);\n\t\t\t}\n\t\t}\n#endif\n\n\t\t// fog\n\t\tfloat d = length(pos - ro) * 0.05;\n\t\tfloat fog = exp(-d*d);\n\t\tc = mix(skyTop*0.5, c, fog);\n\t\t//c = vec3(fog);\n\t\t\t\t\n     } else {\n        c = background(rd, tod, lightDir);\n     }\n     \n    fragColor=vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ss3WS","date":"1379085489","viewed":1224,"name":"metropolis","username":"simesgreen","description":"sunset in the city.\n\nbit glitchy, not really finished, but anyway...","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","city"],"hasliked":0,"parentid":"","parentname":""}}