{"ver":"0.1","info":{"id":"M3fyzM","date":"1725973885","viewed":55,"name":"Woven Rectangle Tree Truchet","username":"chronos","description":"Saw the rectangle tree truchet pattern by snoopetheduck.\nClick to show rectangle subdivision tree.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["tree","truchet","rectangle","subdivision","weave","reproduction"],"hasliked":0,"parentid":"4XXyRN","parentname":"Rectangle Truchet Variant 2"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\n    \"Woven Rectangle Tree Truchet\" by chronos\n    ----------------------------------------------------------------------------------\n    \n    Hacked together a simple weave crossover pattern to use instead of parallel lines\n    in the base layer, and made the disc pattern transparent.\n    \n    Unfortunately there are still a lot of defects, because of how I hacked together the\n    pattern (   and the code is messy and suboptimal as well. Sorry Fabrice... :|   )\n    \n    \n    Self link https://www.shadertoy.com/view/M3fyzM\n    \n    ----------------------------------------------------------------------------------\n    Forked shader description:\n    ----------------------------------------------------------------------------------\n        \"Variant of \"RectSubdivide Multiscale Truchet\" by SnoopethDuckDuck\" by chronos\n\n        Tried to code this pattern myself after learning from the original shader.\n        It's not as good as Snoopeth's, but close enough for me! ¯\\_(ツ)_/¯\n\n        See SnoopethDuckDuck's original shader here: https://www.shadertoy.com/view/XfSBWV\n    \n    ----------------------------------------------------------------------------------\n*/\n\n#define TRANSPARENT_DISCS 1\n#define ALLOW_MIDDLE_DISCS 0\n#define POLAR_COORDINATES 1\n#define TUNNEL_COORDINATES 0\n#define CAST_SHADOW 0\n#define USE_WEAVE 1\n\nconst float gridsize = 10.;\nconst int num_iterations = 3;\nfloat zoom = 2.;\n    \n    \nvec2 split_wh(vec2 uv, vec2 wh, vec2 p)\n{\n    wh.x = uv.x < p.x ? p.x : wh.x - p.x;\n    wh.y = uv.y < p.y ? p.y : wh.y - p.y;\n    return wh;\n}\n\nvec2 split_uv(vec2 uv, vec2 p)\n{\n    uv.x = uv.x < p.x ? uv.x : uv.x - p.x;\n    uv.y = uv.y < p.y ? uv.y : uv.y - p.y;\n    return uv;\n}\n\nvec2 split_id(vec2 uv, vec2 p)\n{\n    uv.x = uv.x < p.x ? 0. : 1.;\n    uv.y = uv.y < p.y ? 0. : 1.;\n    return uv;\n}\n\nvec3 id_to_color(vec2 ids)\n{\n    return pow(texelFetch(iChannel0, ivec2(ids)%1024, 0).rgb, vec3(2.));\n}\n\nint ids_to_id(vec2 ids, int iter)\n{\n    ivec2 IDs = ivec2(ids);\n    int id = (IDs.y << iter) + IDs.x;\n    return id;\n}\n\nivec4 permutation(int id)\n{\n    ivec4 perm = ivec4(0,1,2,3);\n    \n    ivec4[24] all_permutations = ivec4[](\n        perm.xyzw,\n        perm.xywz,\n        perm.xzyw,\n        perm.xzwy,\n        perm.xwyz,\n        perm.xwzy,\n\n        perm.yxzw,\n        perm.yxwz,\n        perm.yzxw,\n        perm.yzwx,\n        perm.ywxz,\n        perm.ywzx,\n\n        perm.zyxw,\n        perm.zywx,\n        perm.zxyw,\n        perm.zxwy,\n        perm.zwyx,\n        perm.zwxy,\n\n        perm.wyzx,\n        perm.wyxz,\n        perm.wzyx,\n        perm.wzxy,\n        perm.wxyz,\n        perm.wxzy\n    );\n    \n    return all_permutations[id%24];\n}\n\nvec3 weave_pattern(vec2 uv, float ps)\n{\n    float sgn = 1. - 2. * abs(float((int(floor(uv.x)) % 2)));\n    uv.y = sgn * uv.y;\n    uv.x = abs(uv.x);\n\n    float r = 2./3.;\n\n    float f =\n        smoothstep((1.-r)-ps, (1.-r)+ps, uv.x) *\n        smoothstep(r+ps, r-ps, uv.x) *\n        step(.5, abs(uv.y))\n    ;\n\n    vec3 color = vec3(f);\n\n    vec2 p = vec2(.0, -.5);\n    float d = length(uv - p) - r;\n    float a = smoothstep(ps, -ps, d) * step(p.x, uv.x) * step(p.y, uv.y) * smoothstep(-r*.5 - ps, -r*.5 + ps, d);\n    \n    float pattern = \n            smoothstep(1./3.-ps, 1./3.+ps, fract(d+.66)) * \n            smoothstep(2./3.+ps, 2./3.-ps, fract(d+.66));\n    \n    color = mix(color, vec3(pattern), a);\n\n    // Shadow\n    p = vec2(.0, .5);\n    d = length(uv - p) - r;\n    \n    pattern = \n            smoothstep(1./3.-ps, 1./3.+ps, fract(d+2./3.)) * \n            smoothstep(2./3.+ps, 2./3.-ps, fract(d+2./3.));\n    \n    a = smoothstep(0.1+ps, 0., d) * step(p.x, uv.x) * step(uv.y, p.y) * smoothstep(-r*.5 - ps, -r*.5 + ps, d);\n    color *= 1.-a;\n\n    a = smoothstep(ps, -ps, d) * step(p.x, uv.x) * step(uv.y, p.y) * smoothstep(-r*.5 - ps, -r*.5 + ps, d);\n    color = mix(color, vec3(pattern), a);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    zoom = zoom * (max(cos(iTime*.5), 0.)+1.);\n    \n    float t = -iTime*.05;\n    \n    #if POLAR_COORDINATES\n        #if TUNNEL_COORDINATES\n            uv *= zoom;\n            uv = vec2(3./(length(uv)), 6.*fract(t*.5 + .5*(1.+atan(uv.y, uv.x)/3.14159265)));\n            float ps = //(uv.y < 5.99 && uv.y > 0.01) || uv.x > 6. ? length(fwidth(uv))/2. : \n                exp(2.*min(uv.x/2., 5.)) / iResolution.y;\n            uv.x += iTime*.5;\n            vec2 UV = uv;\n        #else\n            float len = length(uv);\n            uv = vec2(log(len)*.75, 6.*fract(t*.5 + .5*(1.+atan(uv.y, uv.x)/3.14159265)));\n            float ps = 2./(len * iResolution.y); //length(fwidth(uv))/2.;\n            vec2 UV = uv;\n            uv.x += iTime*.5;\n            uv.x = fract(uv.x);\n        #endif\n    \n    #else\n        uv *= zoom;\n        float ps = zoom / iResolution.y;\n        uv = (uv + 1.) / 2.;\n        uv += vec2(cos(t), sin(t))*10.;\n        vec2 UV = uv;\n    #endif\n    \n    vec3 color = vec3(0);\n\n    vec2 p   = vec2(0);\n    vec2 ids = floor(uv+1024.);\n    \n    uv = fract(uv+1024.);\n    \n    vec2 wh = vec2(1);\n    for(int i = 0; i < num_iterations; i++)\n    {\n        p   = ((1./gridsize) + (1.-2./gridsize) * texelFetch(iChannel0, ivec2(ids)%1024, 0).rg) * wh;\n        \n        p = round(gridsize * p) / gridsize;\n                \n        ids = ids * 2. + split_id(uv, p);\n        wh  = split_wh(uv, wh, p);\n        uv  = split_uv(uv, p);\n  \n        if(min(wh.x, wh.y) <= 2./gridsize) break;\n    }\n\n    color += \n        smoothstep(1./3.-gridsize*ps, 1./3.+gridsize*ps, fract(gridsize * (wh.x < wh.y? uv.y : uv.x))) * \n        smoothstep(2./3.+gridsize*ps, 2./3.-gridsize*ps, fract(gridsize * (wh.x < wh.y? uv.y : uv.x)));\n    #if USE_WEAVE\n    if(min(wh.x, wh.y) >= 2./gridsize)\n    {\n        vec2 weave_uv = uv ;\n        weave_uv = fract(.5 * gridsize * ((wh.x < wh.y? weave_uv.yx : weave_uv.xy)- vec2(0., -.5/gridsize))) *2. - 1.;\n        color = weave_pattern(weave_uv, gridsize*ps);\n    }\n    #endif\n        \n\n    vec2[4] positions = vec2[]( vec2(0), vec2(1,0)*wh, vec2(0,1)*wh, wh );\n\n    float r = min(wh.x, wh.y);\n    int id = ids_to_id(ids, num_iterations);\n    \n    // This allows some of the rectangles to put their discs on the middle of the short edges,\n    // instead of the coners\n    #if ALLOW_MIDDLE_DISCS\n    \n        if(id % 3 == 0)\n        {\n            r/=2.;\n            if(wh.x < wh.y)\n            {\n                positions[0] = vec2(r, 0);\n                positions[1] = vec2(r, 0);\n                positions[2] = vec2(r, wh.y);\n                positions[3] = vec2(r, wh.y);\n            }\n            else\n            {\n                positions[0] = vec2(0, r);\n                positions[1] = vec2(wh.x, r);\n                positions[2] = vec2(0, r);\n                positions[3] = vec2(wh.x, r);\n            }\n        }   \n    \n    #endif\n\n    ivec4 perm = permutation(id);\n    \n    for(int i = 0; i < 4; i++)\n    {\n        vec2 pos = positions[perm[i]];\n        \n        float d = length(uv - pos) - r;\n        \n        //float trim = .125/gridsize; // trims half the black edge\n        //float trim = .25/gridsize;  // trims the entire black edge\n        float trim = .175/gridsize;   // trims the majority of the black edge\n        \n        float pattern = \n            smoothstep(1./3.-gridsize*ps, 1./3.+gridsize*ps, fract(gridsize * d)) * \n            smoothstep(2./3.+gridsize*ps, 2./3.-gridsize*ps, fract(gridsize * d));\n\n        #if TRANSPARENT_DISCS\n        // Cast shadow from white lines\n        color *= \n            mix(1.-\n                smoothstep(0.3 -gridsize*ps, 1./3.+gridsize*ps, fract(gridsize * d)) * \n                smoothstep(0.9+gridsize*ps, 2./3.-gridsize*ps, fract(gridsize * d)),\n            1.,\n            smoothstep(0., trim, d+trim))\n            ;\n            \n        color = mix(color, vec3(1), pattern * smoothstep(ps, -ps, d + trim)); // only draw white lines\n        \n        #else\n        \n            #if CAST_SHADOW && !POLAR_COORDINATES\n                color *= smoothstep(0., trim, d+trim); // disc shadow\n            #endif\n        color = mix(color, vec3(pattern), smoothstep(ps, -ps, d + trim)); // draw pattern on disc\n        #endif\n    }\n\n    if(iMouse.z > 0.)\n    {\n    \n        color = mix(color, vec3(1), smoothstep(wh.x-0.005-ps, wh.x-0.005, uv.x));\n        color = mix(color, vec3(1), smoothstep(wh.y-0.005-ps, wh.y-0.005, uv.y));\n        \n        color = mix(color, vec3(1), smoothstep(0.005+ps, 0.005, uv.x));\n        color = mix(color, vec3(1), smoothstep(0.005+ps, 0.005, uv.y));\n        \n        color = color*.8 +.2;\n        color *= id_to_color(ids);\n    }\n    \n    #if POLAR_COORDINATES && !TUNNEL_COORDINATES\n    \n    color *= pow(tanh(len*2.), 1.);\n    \n    #endif\n    \n    color = pow(clamp(color, 0., 1.), vec3(1./2.2));\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}