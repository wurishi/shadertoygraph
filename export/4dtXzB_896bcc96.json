{"ver":"0.1","info":{"id":"4dtXzB","date":"1465418205","viewed":261,"name":"Voxel Isohedral Tetrahedron","username":"akohdr","description":"Shows six symmetries of Isohedral Tetrahedron in voxel space.\nLooking for cheap passable opacity, anyone care to comment?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voxel","golf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define R iResolution\n#define Z vec4(-1,0,1,.5)\n#define S(i,j,c) v=abs(u=p.i-7.*Z.j);if (v.x<4.+u.y && v.z<4.-u.y) return Z.c;\n\nvec4 V(vec4 p) {\n    vec3 u,v;\n    S(xyz,yzx,wyyw)\t\t\t\t// RED\n    S(yxz,xzz,ywyw)\t\t\t\t// GRN\n    S(zyx,zzy,yyww)\t\t\t\t// BLU\n    S(zxy,xxx,wwyw)\t\t\t\t// YEL\n    S(xzy,zxx,ywww)\t\t\t\t// CYN\n    S(yzx,xzx,wyww)\t\t\t\t// PRP\n    return Z;\n}\n\nvoid mainImage(out vec4 k, vec2 P) {\n    vec4 c, m = Z.yyyy,\n\t\t t = sin(Z+iDate.w),\n         r = (k=((P/R.xy).xyxy-.5)*vec4(R.y/R.x,Z*t).wxyz)-t,\n         f = ceil(t *= 6e1),\n         d = abs(dot(r,r)/r),\n    \t s = ((f-t-.5)*(r=sign(r))+.5)*d;\n    for(float i=147.; i>0.; i--)\n        (c = V(f += m*r)) != Z ?\n            k += .3*c:\n    \t\ts += d*(m = step(s,s.yzxw)*step(s,s.zxyw));\n}\n\n/*\n#define S(i,j,c) v=abs(u=p.i-7.*Z.j);if (v.x<4.+u.y && v.z<4.-u.y) return vec4(Z.yw.c,0);\n\nvec4 V(vec4 p) {\n    vec3 u,v;\n    S(xyz,yzx,yxx)\t\t\t\t// RED\n    S(yxz,xzz,xyx)\t\t\t\t// GRN\n    S(zyx,zzy,xxy)\t\t\t\t// BLU\n    S(zxy,xxx,yyx)\t\t\t\t// YEL\n    S(xzy,zxx,xyy)\t\t\t\t// CYN\n    S(yzx,xzx,yxy)\t\t\t\t// PRP\n    return Z;\n}\n\nvoid mainImage(out vec4 k, vec2 P) {\n    vec4 c, m = Z.yyyy,\n\t\t t = sin(Z+iDate.w),\n         r = (k=((P/R.xy).xyxy-.5)*vec4(R.y/R.x,Z*t).wxyz)-t,\n         f = ceil(t *= 6e1),\n         d = abs(dot(r,r)/r),\n    \t s = ((f-t-.5)*(r=sign(r))+.5)*d;\n    for(float i=147.; i>0.; i--)\n        (c = V(f += m*r)) != Z ?\n            k += .1 - .3*c - 8.*c/i:\n    \t\ts += d*(m = step(s,s.yzxw)*step(s,s.zxyw));\n}\n*/\n\n\n\n\n//    \t s = f+(r=sign(r));\t\t\t\t\t// flying in shaky distorted space\n\n\n\n\n\n\n\n/*\n// Thinking about renaming this version \"Number of the Beast\" :) (666 chars)\n\n#define S(a,b,c) u=p.a-v.b;if(abs(u.x)<u.y+4.&&abs(u.z)<4.-u.y){k=k.c;return true;}\n\nbool V(out vec4 k, const in vec3 p) {\n    k = vec4(.5,0,0,.5);\t\t// colour basis\n    vec3 u,v = vec3(-4,0,4)*2.;\n    S(xyz,yzx,xyzw)\t\t\t\t// RED\n    S(yxz,xzz,yxyw)\t\t\t\t// GRN\n    S(zxy,xxx,xxyw)\t\t\t\t// YEL\n    S(xzy,zxx,yxxw)\t\t\t\t// CYN\n    S(zyx,zzy,yyxw)\t\t\t\t// BLU\n    S(yzx,xzx,xyxw)\t\t\t\t// PRP\n    k-=k; return false;\n}\n\nvoid mainImage(out vec4 k, in vec2 P) {\n    vec4 M = iMouse, \t\t\tc = k = M-M;\n   float T = iTime - M.x/99.;\t\t\t\t// iDate.w messes with paused mouse rotate\n    vec3 R = iResolution, \t\tm = R-R,\n         l = P.xyx / R - .5,\n//\t\t t = vec3(-cos(T), 0, sin(T)),\n         t = sin(vec3(-.7,1.2,0)+T),\t\t\t// dual rotations\n//     \t t = sin(vec3(T-1.6,0,T)),\t\t\t\t// Fab'esque -2\n         r = l.xyx*vec3(t.z,R.y/R.x,-t.x)-t,\t// clockwise\n//         r = l.xyx*vec3(-t.z,R.y/R.x,t.x)-t,\t// anti-clockwise\n         o = t*60.,\n         q = sign(r),\n         f = floor(o),\n         d = abs(length(r)/r),\n         s = ((f-o + .5)*q + .5)*d;\n    for(int i=168; i>0; i--)\n        if(V(c, f += m*q))\n            k = mix(k, c, c/(k.a += c.a))*.9; \n        else\t\t\t\t\t\t\t\t\t// delays ray march faux refraction\n        \ts += d*(m = vec3(lessThan(s,s.yzx))*vec3(lessThanEqual(s,s.zxy)));\n    k += P.y/R.xyyy;\n}\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n/* Older versions\n\n#define S(a,b,c) u=p.a-v.b;if(abs(u.x)<(u.y+s)&&abs(u.z)<(s-u.y)){k=k.c;return true;}\n\nbool V(out vec4 k, const in vec3 p) {\n    k = vec4(.5,0,0,.35);\t\t// colour basis\n\tfloat s = 4.;\t\t\t\t// primitive size\n    vec3 u,v = vec3(-s,0,s)*2.;\t// primitive spacing\n    S(xyz,yzx,xyzw)\t\t\t\t// RED\n    S(yxz,xzz,yxyw)\t\t\t\t// GRN\n    S(zxy,xxx,xxyw)\t\t\t\t// YEL\n    S(xzy,zxx,yxxw)\t\t\t\t// CYN\n    S(zyx,zzy,yyxw)\t\t\t\t// BLU\n    S(yzx,xzx,xyxw)\t\t\t\t// PRP\n    k-=k; return false;\n}\n\nvoid mainImage(out vec4 k, in vec2 P) {\n    vec4 M = iMouse, \t\t\tc = k = M-M;\n   float T = iTime - M.x/99.;\t\t\t\t// iDate.w messes with mouse rotate\n    vec3 R = iResolution, \t\tm = R-R,\n         l = P.xyx / R - .5,\n\t\t t = vec3(-cos(T), 0, sin(T)),\n         r = l.xyx*vec3(t.z,R.y/R.x,-t.x)-t,\t// clockwise\n//         r = l.xyx*vec3(-t.z,R.y/R.x,t.x)-t,\t// anti-clockwise\n         o = t*60.,\n         q = sign(r),\n         f = floor(o),\n         d = abs(length(r)/r),\n         s = ((f-o + .5)*q + .5)*d;\n    for(int i=128; i>0; i--) {\n        if(V(c, f += m*q))\n            k = mix(k, c, c/(k.a += c.a))*\n                //(.8+.15*vec4(m.x>0. ? 1 : m.y>0. ? 3 : 2));\n            \t.9; //cheaper looses some of voxel look and  brightness\n        else\t// interesting faux glass, comment for original\n        s += d*(m = vec3(lessThan(s,s.yzx))*vec3(lessThanEqual(s,s.zxy)));\n    }\n    k += P.y/R.xyyy;\n}\n\n\n\n// compile flag for bounds (bounds show when click viewport)\n#define SHOW_BOUNDS\n//#define SKIP_OPACITY\n\n// pallette of colours\n#define RED vec4(.5,.0,.0,.3)\n#define GRN vec4(.0,.5,.0,.3)\n#define BLU vec4(.0,.0,.5,.3)\n#define CYN vec4(.0,.5,.5,.3)\n#define YEL vec4(.5,.5,.0,.3)\n#define PRP vec4(.5,.0,.5,.3)\n\n#define BOB_H 3.\n#define EYE_D 60.\n#define MAX_RAY 150\n#define OFFSET (vec3(1,-.3,1)*iMouse.y/20.)\n\n// Isohedral Tetrahedron primitive\n#define QISOTET(v,s) abs(v.x)<(v.y+s)&&abs(v.z)<(s-v.y)\n#define ISOTET(p,x,s,K) if(QISOTET((p-x),s))return K;\n\nvec4 cVoxel(const in vec4 p) {\n\n    // alpha channel k.a > 0. indicates voxel present\n\tfloat s = 4.;\t\t\t\t\t// primitive size\n     vec4 v = vec4(-s,0,s,0)*2.,\t// primitive spacing\n          k = vec4(0);\n\n//    v *= sin(iTime*2.);\t\t// animate primitives\n    \n    // swizzle for positioning and various symmetries\n    ISOTET(p.xyz, v.yzx, s, RED);\n    ISOTET(p.yxz, v.xzz, s, GRN);\n    ISOTET(p.zxy, v.xxx, s, YEL);\n    ISOTET(p.xzy, v.zxx, s, CYN);\n    ISOTET(p.zyx, v.zzy, s, BLU);\n    ISOTET(p.yzx, v.xzx, s, PRP);\n\n#ifdef SHOW_BOUNDS\n    if(iMouse.z>0.) { // bounding markers (white positive direction  .rgb <=> .xyz)\n        const vec4 L = vec4(12), H = vec4(.5);\n        vec4 ap = abs(p); bvec4 b = lessThan(ap,L);\n        if(length(ap.xyz-L.x)<3. && all(b.xyz)) k = H+.5*sign(p); \t// local corners\n        else if(length(abs(p.xyz-OFFSET)-L.xyz)<.5) k = H+sign(p); \t// global squares\n        else if(length(p.xyz-OFFSET)<.5) k = GRN; \t\t\t\t\t// world origin\n    }\n#endif\n    return k;\n}\n\nvoid VxViewer(out vec4 k,\t\t\t// fragColor\n         const in vec2 P,\t\t\t// fragCoord\n         const in vec3 R,\t\t\t// iResolution\n        const in float T ) {\t\t// timebase\n    \n    vec2 t = vec2(sin(T), cos(T)),\n         l = P.xx / R.xx - .5;\t\t// vec ops faster than single scalar\n    vec3 r = vec3(l.y*t.y - .8*t.x, (P.y/R.y - .5)*R.y/R.x, .8*t.y + l.x*t.x),\n         o = t.xxy * vec3(EYE_D, BOB_H, -EYE_D),\n         h = length(r)/r,\n         q = sign(r),\n//         q = sign(r)*.5,\t\t\t// higher res.\n         f = floor(o),\n         d = abs(h),\n         s = d*(q*(f-o) + (.5*q) + .5),\n         m;\n\tvec4 ok = k =vec4(.01);\n    \n    for(int i=MAX_RAY; i>0; i--) {\n        \n        vec4 vc = cVoxel(vec4(f + OFFSET.xyz, T));\n        if(vc.a>.0){\t\t// hit voxel\n\n#ifdef SKIP_OPACITY\n            k = 1.5*vc;\n            k.rgb += .15*vec3(m.x>0. ? 1 : m.y>0. ? 3 : 2);\n            if(k.a>0.) return; // early exit\n#else\n            // looking for cheap passable opacity to march voxel field\n    \t   \tk.a += vc.a;\t// accumulate opacity in alpha channel\n\t\t\t\t\t\t\t// keep marching until reach opacity threshold\n            \n            // only update k.rgb on change (i.e uniform colour region surface)\n            if(any(notEqual(ok.rgb,vc.rgb))) {\n                // wondering if different color space might work better??\n\n                // brightness component\n\t            k.rgb *= .8+.15*vec3(m.x>0. ? 1 : m.y>0. ? 3 : 2);\n                \n                // colour component\n\t       \t\tif(k.a<2.) k.rgb = mix(k.rgb, vc.rgb, vc.a/k.a).rgb; \n                \n            \tok = k;\n        \t}\n            \n//            if(k.a>1.){k.rgb*=1.5; return;} // early exit\n#endif\n        }\n        \n        s += d*(m = vec3(lessThan(s,s.yzx))*vec3(lessThanEqual(s,s.zxy)));\n//        float a=s.x, b=s.y, c=s.z;\n//        s += d*(m = vec3(a<b&&a<=c, b<c&&b<=a, c<a&&c<=b));\n        f += m*q;\n    }\n//    k += vec4(vec3(P.y/R.y),\t// vertical fade\n//             \t-1);  \t\t  \t// use alpha channel sign for hit flag\n    \n    k += texture(iChannel0,P/R.xy)/3.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{    \n    VxViewer(fragColor, \n             fragCoord,\n             iResolution,\n             iTime*1.5 - iMouse.x/99.);\n    \n    fragColor = vec4(clamp(fragColor.rgb, 0., 1.),1);  // good practice\n}\n*/\n","name":"Image","description":"","type":"image"}]}