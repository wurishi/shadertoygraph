{"ver":"0.1","info":{"id":"mljGRd","date":"1674746503","viewed":128,"name":"Any Implicit Graph SDF with AA!","username":"Fasteroid","description":"JFA, but it floodfills with best-fit line segments (https://www.desmos.com/calculator/etnprftoph) instead of points.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["2d","math","sdf","distance","desmos"],"hasliked":0,"parentid":"ct2GRw","parentname":"Implicit Graphs SDF AA Attempt 3"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int KEY_SPACE = 32;\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 seed = getPixel( fragCoord, iResolution.xy, iChannel0 );\n    \n    float dist = LineSDF( seed, fragCoord );\n    \n    float thickness = iMouse.x * 0.1 - 10.0;\n    if( iMouse.xy == vec2(0) ){\n        thickness = 5.0;\n    }\n    \n    float color = smoothstep( 0.0, 1.0, clamp( dist - max(0.0, thickness), 0.0, 1.0 ));\n    float h = smoothstep( 0.0, 1.0, clamp( dist, 0.0, 1.0 ));\n    \n    fragColor = vec4( vec3(h - color), 1.0 );\n    \n    // fragColor = vec4(0.0,0.0,20.0,0.0) + jfa * vec4(0.001,0.001,20.0,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// duh\nconst float INF = 1.0/0.0;\n\n// how many frames between steps.  1.0 = full speed.\nconst float c_frameStepDelay = 2.0;\n\n// how many JFA steps to do.  2^c_maxSteps is max image size on x and y\nconst float c_maxSteps = 10.0;\n\nbool shouldTick(int iFrame){\n    return mod(float(iFrame), c_frameStepDelay) == 0.0;\n}\n\nfloat getFrameStep(int iFrame){\n    return floor( float(iFrame) / c_frameStepDelay );\n}\n\nvec4 getPixel( in vec2 coord, in vec2 canvasSize, in sampler2D channel ){\n    return texture( channel, coord / canvasSize );\n}\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nfloat LineSDF(in vec4 line, in vec2 p){\n    return line_segment(p, vec2(line[0], line[1]), vec2(line[2], line[3]) );\n}\n\n\n//============== BEGIN GLesmos Imports ==============//\n\n    float dsm_rpow(float x, float y) {\n        if (x >= 0.0) return pow(x,y);\n        else {\n            float m = mod(y, 2.0);\n            if (m == 0.0) return pow(-x, y);\n            else if (m == 1.0) return -pow(-x, y);\n            else return pow(x, y);\n        }    \n    }\n\n    float glesmos_f0(float x, float y) { return (((((0.8)*(dsm_rpow((tanh(((1.4)*(sin(((5.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))))),(4.0))))+(dsm_rpow((sin(((atan(y,x))+((2.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))),(2.0))))-(0.7))+((0.1)/((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0))))));}\n\n    // float glesmos_f0(float x, float y){ return sqrt(x*x + y*y) - 1.0; }\n\n    float f0( in vec2 fragCoord, in vec2 canvasSize ){\n        vec2 uv = fragCoord.xy - canvasSize / 2.0;\n        uv = uv * 0.005;\n        return glesmos_f0(uv.x, uv.y);\n    } \n    \n//============== END GLesmos Imports ==============//\n\n\n//============== BEGIN JFA Helper Data ==============//\n\n    const vec2 JFA_kernel[9] = vec2[9]( \n        vec2(-1.0,1.0)  , vec2(0.0,1.0)  , vec2(1.0,1.0)  ,\n        vec2(-1.0,0.0)  , vec2(0.0,0.0)  , vec2(1.0,0.0)  ,\n        vec2(-1.0,-1.0) , vec2(0.0,-1.0) , vec2(1.0,-1.0)\n    );\n\n    const vec2 Q_kernel[4] = vec2[4](\n        vec2(-0.5,-0.5), vec2(0.5,-0.5),\n        vec2(-0.5,0.5), vec2(0.5,0.5)\n    );\n\n    const vec2 D_kernel[4] = vec2[4](\n        vec2(0,0), vec2(1,0),\n        vec2(0,1), vec2(1,1)\n    );\n\n    const vec4 JFA_undefined = vec4(-INF,-INF,-INF,-INF);\n\n//============== END JFA Helper Data ==============//\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float f0_cache( in vec2 fragCoord ){\n    return getPixel( fragCoord, iResolution.xy, iChannel1).x;\n}\nfloat f0_cache( in vec2 fragCoord, in vec2 useless ){\n    return getPixel( fragCoord, iResolution.xy, iChannel1).x;\n}\n\n\nvec2 d_f0( in vec2 fragCoord ){\n    float px = f0_cache(fragCoord, iResolution.xy);\n    return vec2( \n        px - f0_cache(fragCoord + vec2(1.0,0), iResolution.xy),\n        px - f0_cache(fragCoord + vec2(0,1.0), iResolution.xy) \n    );\n}\n\nbool detectSignChange( in vec2 fragCoord ){\n\n    float first = sign( f0_cache( fragCoord + Q_kernel[0] ) );\n    for( int i = 1; i < 4; i++ ){\n        if( sign( f0_cache(fragCoord + Q_kernel[i]) ) != first ){\n            return true;\n        }\n    }\n    return false;\n    \n}\n\n\nvec4 lineToPixel(in vec2 p1, in vec2 p2, in vec2 fragCoord){\n\n    return vec4( p1 + fragCoord, p2 + fragCoord );\n    \n}\n\nvec2 quadTreeSolve( in vec2 seed, in float scale ){\n\n    float closest = INF;\n    int closest_n = 0;\n    \n    for( int n = 0; n < 4; n++ ){\n        float tmp = abs( f0( seed + Q_kernel[n] * scale, iResolution.xy ) );\n        if( tmp < closest ){\n            closest_n = n;\n            closest = tmp;\n        }\n    }\n    \n    return seed + Q_kernel[closest_n] * scale;\n    \n}\n\nvec4 Step(in vec2 fragCoord, in float level){\n\n    level = clamp(level, 0.0, c_maxSteps);\n    float stepwidth = floor(exp2(c_maxSteps - level - 1.0));\n    \n    float bestDistance = INF;\n    vec4  bestLine     = JFA_undefined;\n    \n    for (int n = 0; n < 9; n++) {\n        \n        vec2 sampleCoord = fragCoord + JFA_kernel[n] * stepwidth;\n        vec4 seed        = getPixel( sampleCoord, iResolution.xy, iChannel0 );\n\n        if( seed == JFA_undefined ) continue; // don't try to use this one\n        float dist = LineSDF( seed, fragCoord );\n        \n        if (dist < bestDistance)\n        {\n            bestDistance = dist;\n            bestLine     = seed;\n        }\n            \n    }\n    \n    return bestLine;\n}\n\n\n//================================//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float frameStep = getFrameStep(iFrame);\n    bool  tick      = shouldTick(iFrame);\n    \n    // TODO: this is terrible, fix it.\n    if( tick ){\n    \n        if( frameStep == 0.0 ){\n            // Wait for Buffer B\n        }\n        \n        else if( frameStep == 1.0 ){\n            // JFA initialization\n            \n            bool mask = detectSignChange( fragCoord );\n            \n            if( mask ){\n\n                fragCoord = quadTreeSolve(fragCoord, 0.5);\n                fragCoord = quadTreeSolve(fragCoord, 0.25);\n                fragCoord = quadTreeSolve(fragCoord, 0.125);\n                \n                vec2 d = d_f0(fragCoord); // TODO: add QuadtreeSolve here!\n                d = normalize( vec2(-d.y, d.x) );\n                \n                fragColor = lineToPixel(-d, d, fragCoord);\n                return;\n            }\n            else {\n                fragColor = JFA_undefined;\n                return;\n            }\n            \n        }\n        \n        else if ( frameStep - 1.0 < c_maxSteps ) {\n            fragColor = Step( fragCoord, frameStep - 1.0);\n            return;\n        }\n        \n    }\n\n    fragColor = getPixel(fragCoord, iResolution.xy, iChannel0);\n        \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvec4 cacheImplicitValues( in vec2 fragCoord ){\n    float v = f0( fragCoord, iResolution.xy );\n    return vec4(v, 0, 0, 1);\n}\n\n//================================//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float frameStep = getFrameStep(iFrame);\n    bool  tick      = shouldTick(iFrame);\n    \n    // TODO: this is terrible, fix it.\n    if( tick ){\n    \n        if( frameStep == 0.0 ){\n            fragColor = cacheImplicitValues( fragCoord ); // cache this for use in Buffer A\n            return;\n        }\n        \n    }\n\n    fragColor = getPixel(fragCoord, iResolution.xy, iChannel1);\n        \n}","name":"Buffer B","description":"","type":"buffer"}]}