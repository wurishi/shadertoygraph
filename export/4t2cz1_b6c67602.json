{"ver":"0.1","info":{"id":"4t2cz1","date":"1507507859","viewed":174,"name":"Arabian Nights","username":"riouxld","description":"test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 400;\n\nconst float EARTH_RADIUS = 1500.0;\n\nconst float MOON_RADIUS = 30.0;\nconst vec3 MOON_POSITION = vec3(0.0, 100.0,540.0);\n\nconst int OCTAVE_OCEAN = 5;\nconst float PERSISTENCE_OCEAN = 0.5;\nconst vec2 FREQUENCY_OCEAN = vec2(2.2, 2.2);\nconst float AMPLITUDE_OCEAN = 0.05;\nconst vec2 SPEED_OCEAN = vec2(1.4,1.5);\n\nconst int OCTAVE_LAND = 2;\nconst float PERSISTENCE_LAND = 0.70;\nconst vec2 FREQUENCY_LAND = vec2(0.15, 0.15);\nconst float AMPLITUDE_LAND =2.0;\nconst vec2 SPEED_LAND = vec2(0.0);\n\n\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 550.0;\nconst float EPSILON = 0.005;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    \n    vec3 diffuse;\n    vec3 specular;\n    \n    float constant;\n    float linear;\n    float quadratic;\n};\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    \n    float shininess;\n};\n    \nstruct Sphere {\n    float radius;\n    vec3 center;\n    Material material;\n};\n    \n\nstruct Intersect {\n    float depth;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\n/*\nfloat noise( in vec2 x )\n{\n    #if 0\n    \n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = p.xy + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, 1.0);\n    \n    #else\n    \n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tvec2 rgA = texelFetch( iChannel0, (uv+ivec2(0,0))&255, 0 ).yx;\n    vec2 rgB = texelFetch( iChannel0, (uv+ivec2(1,0))&255, 0 ).yx;\n    vec2 rgC = texelFetch( iChannel0, (uv+ivec2(0,1))&255, 0 ).yx;\n    vec2 rgD = texelFetch( iChannel0, (uv+ivec2(1,1))&255, 0 ).yx;\n    vec2 rg = mix( mix( rgA, rgB, f.x ),\n                   mix( rgC, rgD, f.x ), f.y );\n    return mix( rg.x, rg.y, 1.0 );\n    \n    #endif\n}\n*/\nfloat random (vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n/*\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix( hash(p+vec2(0,0)), \n                        hash(p+vec2(1,0)),f.x),\n                   mix( hash(p+vec2(0,1)), \n                        hash(p+vec2(1,1)),f.x),f.y);\n}\n\n*/\n\n\nfloat octaveNoise (vec2 st, int octaves, float persistence, vec2 frequency, float amplitude, vec2 speed) {\n    float total = 0.0;\n    vec2 freq = frequency;\n    float amp = amplitude;\n    \n    for(int i=0;i<octaves;i++) {\n        total += noise(vec2(st.x * freq.x-speed.x*iTime, st.y * freq.y+speed.y*iTime)) * amp;\n        amp *= persistence;\n        freq.x *= 2.4;\n        freq.y *= 2.5;\n    }\n    \n    return total;\n}\n\n\nconst Sphere sphereMoon = Sphere(MOON_RADIUS, MOON_POSITION,\n                             Material( vec3(0.05, 0.05, 0.05),\n                                vec3(1.0, 1.0, 1.0),\n                                0.1*vec3(1.0, 1.0, 1.0),\n                                0.1));\n\n\nconst Sphere sphereOcean = Sphere(EARTH_RADIUS, vec3(0.0, -EARTH_RADIUS-2.5,0.0),\n                             Material( vec3(0.07, 0.45, 0.4),\n                                  vec3(0.07, 0.45, 0.4),\n                                  vec3(1.0, 1.0, 1.0),\n                                  0.6));\n\nconst Sphere sphereLand = Sphere(EARTH_RADIUS-1.22, vec3(0.0, -EARTH_RADIUS-2.5,0.0),\n                             Material( vec3(0.55, 0.27, 0.1),\n                                   0.75*vec3(0.55, 0.27, 0.1),\n                                   0.1*vec3(1.0, 1.0, 1.0),\n                                  0.05));\n\nfloat moonSDF(vec3 samplePoint, Sphere sphere) {\n    return length(samplePoint-sphere.center + vec3(sin(iTime)/3.0,1.2+sin(iTime)/6.0,cos(iTime)/4.0)) - sphere.radius;\n}\n\nfloat oceanSDF(vec3 samplePoint, Sphere sphere) {\n    return length(samplePoint-sphere.center) \n        - sphere.radius -octaveNoise (samplePoint.xz, OCTAVE_OCEAN, PERSISTENCE_OCEAN, FREQUENCY_OCEAN, AMPLITUDE_OCEAN, SPEED_OCEAN);\n}\n\nfloat landSDF(vec3 samplePoint, Sphere sphere) {\n    return length(samplePoint-sphere.center) \n        - sphere.radius -octaveNoise (samplePoint.xz, OCTAVE_LAND, PERSISTENCE_LAND, FREQUENCY_LAND, AMPLITUDE_LAND, SPEED_LAND);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    return min(min(oceanSDF(samplePoint, sphereOcean),landSDF(samplePoint, sphereLand)),moonSDF(samplePoint, sphereMoon));\n}\n\n\nfloat shortestDistanceToSurface(Ray ray) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(ray.origin + depth * ray.direction);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nfloat shortestDistanceToLand(Ray ray) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = landSDF(ray.origin + depth * ray.direction, sphereLand);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n            \nvec3 calcNormal(vec3 p) {\n    \n    float ref = sceneSDF(p);\n    return normalize(vec3(\n        ref - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        ref - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        ref - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(Ray ray, Intersect intersection, Light light) {\n    vec3 N = intersection.normal;\n    vec3 L = normalize(light.position - intersection.position);\n    vec3 V = normalize(ray.origin - intersection.position);\n    vec3 R = normalize(reflect(-L, intersection.normal));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0);\n    } \n    \n    float Ldist = length(light.position - intersection.position);\n    float attenuation = 1.0 / (light.constant + light.linear * Ldist + \n                                   light.quadratic * (pow(Ldist,2.0)));\n    \n    vec3 diffuse = light.diffuse*intersection.material.diffuse * dotLN;\n    \n    if (shortestDistanceToLand(Ray(intersection.position + EPSILON*intersection.normal, L))!=MAX_DIST)\n    {\n        return 0.3*diffuse;\n    }\n    \n    if (dotRV < 0.0) {\n        return diffuse;\n    }\n    \n    vec3 specular = light.specular*intersection.material.specular * pow(dotRV, intersection.material.shininess * 128.0);\n    \n    return (diffuse+specular)*attenuation;\n    \n}\n    \n\nvec3 phongIllumination(Ray ray, Intersect intersection) {\n    \n    vec3 ambient =  0.4*vec3(1.0)*intersection.material.ambient;\n    \n    vec3 color = ambient;\n\n    Light light2 = Light( \n     MOON_POSITION+vec3(MOON_RADIUS, 15.0,-60.0),\n     vec3(1.0, 1.0, 1.0),\n     vec3(1.0, 1.0, 1.0),\n     1.0,\n     0.0000007,\n     0.000000002);\n    \n    color += phongContribForLight(ray, intersection, light2);\n    \n    return color;\n}\n\nvec3 rayTracer(Ray ray)\n{\n    float dist = shortestDistanceToSurface(ray);\n\n    if (dist > MAX_DIST - EPSILON) {\n        return vec3(0.02,0.0,0.1);\n    }\n    \n    vec3 p = ray.origin + dist * ray.direction;\n    Intersect intersection = Intersect(dist, p, calcNormal(p), \n                                       Material(vec3(0.0), \n                                                vec3(0.0), \n                                                vec3(0.0),\n                                                0.0));\n    \n    if (moonSDF(p, sphereMoon)<= EPSILON) intersection.material = sphereMoon.material;\n    if (oceanSDF(p, sphereOcean)<=EPSILON) intersection.material = sphereOcean.material;\n    if (landSDF(p, sphereLand)<=EPSILON) intersection.material = sphereLand.material;\n    \n    \n    return phongIllumination(ray, intersection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= aspectRatio;\n    \n    vec3 eye = vec3(0.0, 0.25, -1.0);\n    Ray ray = Ray(eye,normalize(vec3(uv.x, uv.y, 0.0)-eye));\n    \n    fragColor = vec4(rayTracer(ray), 1.0);\n}","name":"Image","description":"","type":"image"}]}