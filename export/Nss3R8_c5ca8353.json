{"ver":"0.1","info":{"id":"Nss3R8","date":"1647935206","viewed":77,"name":"Star, or Gear Shader","username":"JohnShadow","description":"Star, or Gear Shader","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["star","gear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define orbit 10.0\n#define depth 200\n#define PI 3.14159265359\nfloat sdfS(vec3 a)\n{\n    return length(a) - 1.0;\n}\nfloat sdfP(vec3 a)\n{\n \treturn abs(a.y);   \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat StarSdf(vec3 position, float height, float radius, float modulus)\n{\n    //project onto circle\n    vec2 direction = normalize(position.xz);\n    \n    //reproject circle back into angle\n    float angle = cos(modulus * acos(direction.x))/(modulus + 1.0);\n    \n    //use a cylinder sdf then add the 2d angle sdf.\n    float harmonic = (length(position.xz) + angle) - radius;\n    position.y += height * 0.5;\n    return max(max(harmonic, position.y - height), -position.y);\n}\n\nfloat map(vec3 position)\n{\n    return StarSdf(position, 1.0, 1.0, 5.0);\n}\nvec3 getnormal (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0) ) - map(p - vec3(eps, 0, 0)),\n \t  map(p + vec3(0, eps, 0) ) - map(p - vec3(0, eps, 0)),\n\t  map(p + vec3(0, 0, eps) ) - map(p - vec3(0, 0, eps))\n \t)\n );\n}\nvec4 march(vec3 start, vec3 direction)\n{\n    vec3 position = start;\n    float fd = 0.0, cd = 0.0;\n    for(int i = 0; i < depth; ++i)\n    {\n        cd = map(position);\n        position += direction * cd;\n        fd += cd;\n     \tif(cd < 0.0001)\n            return vec4(position, fd);\n    }\n    return vec4(position, 0.0);\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 ori = vec3(orbit * sin(iTime * 0.5), 5.0, orbit * cos(iTime * 0.5));\n    mat4 viewToWorld = viewMatrix(ori, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 dir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec3 normal, color;\n    \n    // Time varying pixel color\n    vec4 hit = march(ori, dir);\n    if(hit.w != 0.0)  \n    {\n    \tnormal = getnormal(hit.xyz);\n        color = abs(normal);\n    }\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}