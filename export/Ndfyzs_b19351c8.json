{"ver":"0.1","info":{"id":"Ndfyzs","date":"1642510062","viewed":129,"name":"\"kifings tubes\" with oscillation","username":"Synthesoft","description":"This is a fork of Leon's \"kifings tubes with a twist\" with the goal of maximizing pattern variability over time.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["folding","fork","oscillation","leon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original shader by Leon Denise\n// \"kifings tubes with a twist\"\n// https://www.shadertoy.com/view/ssfcR2\n// are we arrived yet?\n// kifings tubes with a twist\n// leon denise 2022 01 16\n\n// Synthesoft fork #2 of Leon's \"kifings tubes with a twist\":\n//   I was blown away by Leon's mind-bending \"kifings tubes\" and was curious what would \n//   happen with other sdfs and time-based dimension/rotation scaling.  \n//\n//   Changes in this fork:\n//     Guiding principle: maximize variability over time\n//     Most of what were originally constant values are now oscillated within ranges at staggered frequencies\n//     Amped the color a bit  \n//     Added horizontal mouse drag to adjust position\n//\n//  Pros: Lots of variability \n//  Cons: Some of the variations aren't that interesting\n//\n\n#define OSC_RATE_SCALE 0.3   // global scaling of oscillation rate (smaller is slower)  \n\n#define INCLUDE_TORUS         \n#define INCLUDE_BOUNDING_BOX  \n#define INCLUDE_CYLINDER      \n\nfloat gTime;\n\n// repetition domain\n#define repeat(p,r) (mod(p+r/2.,r)-r/2.)\n\n// smooth union by Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin_old( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// smooth union by Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n    \n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n\n// https://in4k.github.io/html_articles/hg_sdf.html\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) \n{\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// https://in4k.github.io/html_articles/hg_sdf.html\nfloat fCylinder(vec3 p, float r, float height) \n{\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://in4k.github.io/html_articles/hg_sdf.html\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// https://in4k.github.io/html_articles/hg_sdf.html\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fOscillateRange(float fMin, float fMax, float fRate)\n{\n    fRate *= OSC_RATE_SCALE;   \n\treturn mix(fMin, fMax, abs(sin(gTime*fRate)));\n}\n\n\n// geometry\nfloat map(vec3 p)\n{\n\tfloat d1, d2, d3;\n\td1=d2=d3=1e20;\n    // Synthesoft: Generate the dimensions of the objects.\n    // I picked the oscillation freq scale parms mostly at random with the goal of having \n    // them out of sync to maximize variability\n    // The scale ranges could probably use some adjustment\n#ifdef INCLUDE_TORUS\n\tfloat fTorusInnerScale = fOscillateRange(0.5, 4.0, 0.11);\n\tfloat fTorusOuterScale = fTorusInnerScale + fOscillateRange(0.02, 12.0, 0.12);\n#endif\n#ifdef INCLUDE_CYLINDER\n\tfloat fCylinderRadiusScale = fOscillateRange(2.0, 4.0, 0.19);\n\tfloat fCylinderLengthScale = fOscillateRange(2.0, 60.0, 0.13);\n#endif\n#ifdef INCLUDE_BOUNDING_BOX\n\tvec3 fBoxScale = vec3(fOscillateRange(1.0, 16.0, 0.173), fOscillateRange(1.0, 16.0, 0.197), fOscillateRange(1.0, 16.0, 0.139) );\n#endif\n    float fs = fOscillateRange(0.1, 0.3, 0.043);      // previously fs was 0.2\n    float fs2 = fOscillateRange(0.01, 0.2, 0.047);      // previously fs was 0.05\n    float count = fOscillateRange(2.1, 7.0, 0.085);   // previously count was 6.0\n    float cell = fOscillateRange(0.420, 0.95, 0.0089);   // previously count was 0.7\n    float smscale = fOscillateRange(0.01, 2.0, 0.0027);   // previously count was 0.7\n\n    vec3 pp = p;\n    float dist = 1000.;\n    p.z += gTime * .05; // translate\n    //float pz = floor(p.z/cell); // index of cell in line\n    p.z = repeat(p.z, cell); // repeat space z\n    p.z *= mix(-1., 1., step(0.5, mod(p.z, 3.))); // mirror z per cell in line\n    float t = iTime * .1; // time rotation\n    float d = length(p);// * abs(sin(t*(length(p)/12.))); // distance from origin\n    float a = 1.; // amplitude of falloff\n\n    for (float i = 0.; i < count; ++i) { // kifing\n        // Synthesoft: I'm trying to produce a billowy effect\n        p.yz *= rot(iTime * 0.05 * (i+2.0));  // twist  \n        p.yx *= rot(iTime * 0.06 * (i+2.0));  // twist  \n        p.xz *= rot(iTime * 0.07 * (i+2.0));  // twist \n        \n        //p = abs(p)-((fs*.05)+d*(fs*.2))*a; // fold space\n\t\tp = abs(p)-(fs2+d*fs)*a; // fold space\n\n\t\tfloat v = (.01+d*0.01)*a;\n#ifdef INCLUDE_TORUS      \n        float d1 = fTorus(p, v*fTorusInnerScale, v*fTorusOuterScale); \n#else\n#endif\n#ifdef INCLUDE_CYLINDER\n\t\tfloat d2 = fCylinder(p, v*fCylinderRadiusScale, v*fCylinderLengthScale); \n#endif\n#ifdef INCLUDE_BOUNDING_BOX\n\t\tfloat d3 = sdBoundingBox(p, v*fBoxScale, v*(length(fBoxScale)/14.0));\n#endif\n\t\tfloat dMixed = min(min(d3, d1),d2);\n\t\t\n        dist = smin(dist, dMixed, d*a*(smscale)); // smoothly add shapes\n        a /= 2.; // falloff curve\n    }\n    return abs(dist)-.0001; // shell volume\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    // Allow time adjust based on horizontal mouse position\n    float m = (iMouse.x/iResolution.x)*500.0;\n\tgTime = (iTime+m);\n    \n    vec2 pixel = (coordinate - iResolution.xy / 2.) / iResolution.y;\n    vec3 eye = vec3(0,0,-1.);\n    vec3 ray = normalize(vec3(pixel, 1.5));\n    vec3 pos = eye + ray * .5; // start ahead, carve volume\n    \n    // raymarch\n    const float count = 60.;\n    float i = 0.;\n    for (i = count; i > 0.; --i) {\n        float dist = map(pos);\n        if (dist < .0001) break;\n        pos += ray * dist;\n    }\n    \n    // coloring\n    float shade = i/count;\n    // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n    vec3 tint = .9 + .1 * cos(vec3(.0, .3, .6) * 6.283 + shade * 6. + pos.z * 18. + 2.);\n    color = vec4(tint * shade,1.0);\n    color *= color;\n}\n","name":"Image","description":"","type":"image"}]}