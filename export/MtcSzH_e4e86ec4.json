{"ver":"0.1","info":{"id":"MtcSzH","date":"1478104803","viewed":2613,"name":"Trilateral Blur (with Gradient)","username":"ttoinou","description":"Trilateral Blur upgrades Bilateral Blur by taking into account gradient !\nMuch better (no halos, no edges issues) but needs more tuning.\n\nClick left to see original input, right for gradients magnitudes and top for sharpening effect.","likes":27,"published":1,"flags":32,"usePreview":0,"tags":["cartoon","blur","gradient","contrast","hdr","gaussian","bilateral","trilateral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define input \tiChannel0\n#define inputDX iChannel1\n#define inputDY iChannel2\n\n// my take on Trilateral Filtering\n// http://dl.acm.org/citation.cfm?id=882431\n\n// Upgrading Bilateral Blur with Gradient\n// https://www.shadertoy.com/view/MlVGW3\n#define RADIUS     (12)\n#define DIAMETER   (2*RADIUS+1)\n\n// bigger theses coeff the more we take into account the space concerned\n\n// shouldn't need to change it\n// close to 0 => square-shaped\n#define COORDCOEFF (1.41)\n\n// if theses two == 0. => filter is a gaussian blur\n// the closer to zero the blurier\n// the bigger the more selective\n#define LUMCOEFF   (8.)\n#define GRADCOEFF  (6.)\n\n// see line 84\n// not confident in my calculus in buffB & buffC\n#define LUMPLANECORRECTION (1.)\n\n#define GAMMA        (2.2)\n#define pow3(x,y)    (pow( max(x,0.) , vec3(y) ))\n#define LUMWEIGHT    (vec4(0.2126,0.7152,0.0722,0.3333))\n#define GRADIENT_RADIUS (8)\n\n#define GRADIENT_RADIUSf float(GRADIENT_RADIUS)\n#define GRADIENT_RADIUSi22f (4./float(GRADIENT_RADIUS*GRADIENT_RADIUS))\n#define PI           (3.14159265359)\n#define viewport(x) ( (x) /iResolution.xy)\n\n#define DX          (iMouse.x/iResolution.x)\n#define DY          (iMouse.y/iResolution.y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = viewport(fragCoord);\n    \n    vec4 thisColor = texture(input,uv);\n    vec4 thisGradX = texture(inputDX,uv);\n    vec4 thisGradY = texture(inputDY,uv);\n    \n    fragColor = vec4(0.);\n    vec4 diffColorToGradient;\n    vec4 diffGradientX;\n    vec4 diffGradientY;\n    float sum = 0.;\n    float coeff;\n    vec2 pos;\n    vec4 color = vec4(0.);\n    vec4 gradX = vec4(0.);\n    vec4 gradY = vec4(0.);\n    \n    float GradCoeff2 = GRADCOEFF*GRADCOEFF;\n    float LumCoeff2 = LUMCOEFF*LUMCOEFF;\n    float CoordCoeff2 = COORDCOEFF*COORDCOEFF/float(RADIUS*RADIUS);\n    \n    for( int i = -RADIUS ; i <= RADIUS ; i++ ){\n        for( int j = -RADIUS ; j <= RADIUS ; j++ ){\n            \n            pos = viewport(fragCoord.xy+vec2(i,j));\n            color = texture(input,pos);\n            gradX = texture(inputDX,pos);\n            gradY = texture(inputDY,pos);\n            \n            diffGradientX = thisGradX - gradX;\n            diffGradientY = thisGradY - gradY;\n            \n            diffColorToGradient = thisColor - color\n                // minus sign ? I must have made an error in buffB & buffC :-( \n                - (thisGradX*float(i) + thisGradY*float(j))*GRADIENT_RADIUSi22f*LUMPLANECORRECTION;\n            \n            coeff = exp( -(\n                // blur in coordinate space\n                float(i*i+j*j)*CoordCoeff2\n                // blur in distance to first local approximation\n                // instead of blur in color space\n                + dot(diffColorToGradient,diffColorToGradient)*LumCoeff2\n                // blur in gradient space\n                + dot( diffGradientX*diffGradientX + diffGradientY*diffGradientY , LUMWEIGHT )*GradCoeff2\n                ));\n            \n            \n            if( i == -RADIUS && j == -RADIUS ){\n            \tfragColor = color*coeff;\n            } else {\n            \tfragColor += color*coeff;\n            }\n            \n            sum += coeff;\n            \n        }\n    }\n    \n    // no need for uncertainty map (mix to thisColor based on sum log value)\n    // like in https://www.shadertoy.com/view/MlVGW3 ?\n\tfragColor = fragColor/sum;\n    \n    vec4 normGrad = sqrt(thisGradX*thisGradX + thisGradY*thisGradY)*GRADIENT_RADIUSi22f;\n    \n    if( iMouse.z > .5 ){\n    \tfragColor = DX >.5 ? normGrad : thisColor;\n    } else {\n        if( DY > .5 ){\n            fragColor = thisColor - 2.*(fragColor - thisColor);\n        }\n    }\n    \n\tfragColor.rgb = pow3(fragColor.rgb,1./GAMMA);\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define GAMMA        (2.2)\n#define pow3(x,y)    (pow( max(x,0.) , vec3(y) ))\n\n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor.rgb = pow3(texture(iChannel0,fragCoord/iResolution.xy).rgb,GAMMA);\n    // uncomment to add random noise\n    //fragColor.rgb += (hash33(vec3(fragCoord.xy,iTime))-.5)*0.2;\n    fragColor.a = 1.;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// continuous gradient\n// https://www.shadertoy.com/view/XtK3Dd\n#define GRADIENT_RADIUS (8)\n#define PI           (3.14159265359)\n#define LUMWEIGHT    (vec3(0.2126,0.7152,0.0722))\n#define gradientInput iChannel0\n#define gradientDirectionX (true)\n\n#define GRADIENT_RADIUSf float(GRADIENT_RADIUS)\n#define GRADIENT_RADIUSi22f 4./float(GRADIENT_RADIUS*GRADIENT_RADIUS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    \n    for( int i = -GRADIENT_RADIUS ; i <= GRADIENT_RADIUS ; i++ ){\n    \tfor( int j = -GRADIENT_RADIUS ; j <= GRADIENT_RADIUS ; j++ ){\n            fragColor += (gradientDirectionX ? float(i) : float(j))\n                *exp(-float(i*i + j*j)*GRADIENT_RADIUSi22f)/GRADIENT_RADIUSf\n                *texture(gradientInput,(fragCoord.xy+vec2(i,j))/iResolution.xy);\n        }\n        \n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// continuous gradient\n// https://www.shadertoy.com/view/XtK3Dd\n#define GRADIENT_RADIUS (8)\n#define PI           (3.14159265359)\n#define LUMWEIGHT    (vec3(0.2126,0.7152,0.0722))\n#define gradientInput iChannel0\n#define gradientDirectionX (false)\n\n#define GRADIENT_RADIUSf float(GRADIENT_RADIUS)\n#define GRADIENT_RADIUSi22f 4./float(GRADIENT_RADIUS*GRADIENT_RADIUS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    \n    for( int i = -GRADIENT_RADIUS ; i <= GRADIENT_RADIUS ; i++ ){\n    \tfor( int j = -GRADIENT_RADIUS ; j <= GRADIENT_RADIUS ; j++ ){\n            fragColor += (gradientDirectionX ? float(i) : float(j))\n                *exp(-float(i*i + j*j)*GRADIENT_RADIUSi22f)/GRADIENT_RADIUSf\n                *texture(gradientInput,(fragCoord.xy+vec2(i,j))/iResolution.xy);\n        }\n        \n    }\n}","name":"Buf C","description":"","type":"buffer"}]}