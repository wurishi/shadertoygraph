{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"bool renderMode = true;\n\n// edit Common shader to modify ro/lp/lightPosition etc.\n\nvec3 renderSeparately(vec3 col, vec2 fragCoord)\n{\n    \n    // when use other buffer to compute part of image(a layer, for example), use texelFetch() instead of texture() to read data.\n    // using texture() probably wont get the correct fragCoord result as you wish, because there are many internal process inside texture().\n     col += texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y), 0).xyz;\n     col += texelFetch(iChannel1, ivec2(fragCoord.x, fragCoord.y), 0).xyz;\n     col += texelFetch(iChannel2, ivec2(fragCoord.x, fragCoord.y), 0).xyz;\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0);\n\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd);\n\n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      if(renderMode){\n          // render separately\n          col = renderSeparately(col, fragCoord);\n      }else {\n  \n          // or as a whole part\n          vec3 p = ro + rd * d;\n          vec3 normal = calcNormal(p);\n          vec3 lightDirection = normalize(lightPosition - p);\n\n          // diffuse\n          float diffuse = clamp(dot(lightDirection, normal), 0., 1.);\n\n          col += diffuse * vec3(0.7, 0.5, 0);\n\n          // specular\n          float k_s = 0.6;\n          float dotRV = clamp(dot(reflect(lightDirection, normal), -rd), 0., 1.);\n          vec3 i_s = vec3(1, 1, 1);\n          float alpha = 2.;\n          vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n\n          col += specular;\n\n          // ambient light\n          col += vec3(0.8,0.2,0.2) * 0.1;\n      }\n      \n  }\n  \n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"// ambient light\n// always added on every visible object, a slight and global general light.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.8,0.2,0.2,1.0) * 0.1;\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nconst vec3 backgroundColor = vec3(0.835, 1, 1);\n\nconst vec3 lp = vec3(0); // lookat point (aka camera target)\nconst vec3 ro = vec3(0, 0, 3);\nconst vec3 lightPosition = vec3(2, 2, 7);\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\n// central difference method to compute SDF gradient vector, which is also surface normal vector at the point P.\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[],"code":"// lambert reflection (diffusion)\n// basically, L dot N multiply a constant. remember to clamp L dot N to avoid negative value.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n\n   vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n    float d = rayMarch(ro, rd);\n\n    if (d > MAX_DIST) {\n        col = backgroundColor;\n    } else {\n        vec3 p = ro + rd * d;\n        vec3 normal = calcNormal(p);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        float diffuse = clamp(dot(lightDirection, normal), 0., 1.);\n\n       col = diffuse * vec3(0.7, 0.5, 0);\n      \n    }\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[],"code":"// specular reflection\n// use GLSL builtin func \"reflect()\" to compute reflection direction vector R\n// then pow(R dot V, alpha), multiply a constant(i_s)\n// the smaller alpha is, the stronger specular light isï¼ˆbecause R dot V is a value no more than 1)\n// remember: the incident ray vector passed into reflect() should from hit point P towards light source.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n\n   vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n    float d = rayMarch(ro, rd);\n\n    if (d > MAX_DIST) {\n        col = backgroundColor;\n    } else {\n        vec3 p = ro + rd * d;\n        vec3 normal = calcNormal(p);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n       // specular\n       float k_s = 0.6;\n       float dotRV = clamp(dot(reflect(lightDirection, normal), -rd), 0., 1.);\n       vec3 i_s = vec3(1, 1, 1);\n       float alpha = 1.;\n       vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n\n       col = specular;\n      \n    }\n    fragColor = vec4(col,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"l3dcW4","date":"1735121433","viewed":19,"name":"Learn Phong Model","username":"MadDonkey","description":"use buffer A/B/C to render Lambert reflection, specular reflection and ambient light separately.\ncomment specific line in Image shader to show certain part of Phong Model.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarchingphongmodel"],"hasliked":0,"parentid":"","parentname":""}}