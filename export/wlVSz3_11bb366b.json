{"ver":"0.1","info":{"id":"wlVSz3","date":"1583276759","viewed":4326,"name":"Orchard (Alternative Projection)","username":"Dave_Hoskins","description":"This is an alternative projection of my 'Abstract Orchard' [url]https://www.shadertoy.com/view/tdGGWV[/url]\nRemoves rotation distortion associated with screen projection.\nAlthough translation movements break it.\nThanks to munrocket for Quaternion code. :)","likes":66,"published":3,"flags":0,"usePreview":1,"tags":["3d","raymarching","orchard","cylindricalprojection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Orchard (Alternative Projection)\n// by Dave Hoskins. March 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This breaks the effect a little...\n//#define MOVE_CAMERA\n\n\nint spointer;\nvec3 sunLight;\n#define SUN_COLOUR vec3(1., .9, .8)\n#define FOG_COLOUR vec3(1., .7, .7)\n\nstruct Stack\n{\n    vec3 pos;\n    float alpha;\n    float dist;\n    int mat;\n\n};\n\n#define STACK_SIZE 8\nStack stack[STACK_SIZE];\n\n//==============================================================================\n//--------------------------------------------------------------------------\nfloat getGroundHeight(vec2 p)\n{\n    float y =(sin(p.y*.23)+cos(p.x*.18))*.8;\n    return y;\n}\n//--------------------------------------------------------------------------\nmat3 getCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//--------------------------------------------------------------------------\n// Loop the camposition around a uneven sine and cosine, and default the time 0\n// to be steep at a loop point by adding 140...\nvec3 getCamPos(float t)\n{\n    //t = sin(t*.01)*200.;\n    t+=140.;\n    vec3 p = vec3(3.0+50.0*sin(t*.03),\n                  1.5,\n                  4.0 + 50.0*cos(t*.044));\n    p.y-=getGroundHeight(p.xz);\n    return p;\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n//------------------------------------------------------------------------------\nfloat randomTint(vec3 pos)\n{\n    float r = texture(iChannel1, pos.xz*.0027).x;\n    return r+.5;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(sam, p.yz).xyz;\n\tvec3 y = texture(sam, p.zx).xyz;\n\tvec3 z = texture(sam, p.xy).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//------------------------------------------------------------------------------\nvec4 grassTexture(vec3 pos, vec3 nor)\n{\n    \n    float g = texture(iChannel1, pos.xz*.5).x;\n    float s = texture(iChannel1, pos.xz*.015).x*.2;\n    \n    \n    vec3 flower = texture(iChannel2, pos.xz*.15).xyz;\n    float rand = texture(iChannel1, pos.xz*.003).x;\n    rand *= rand*rand;\n    \n    flower =pow(flower,vec3(8, 15, 5)) *10. * rand;\n    vec4 mat = vec4(g*.05+s, g*.65, 0, g*.1);\n    mat.xyz += flower;\n\n    // Do the red ground lines...\n    pos = fract(pos);\n    mat = mix(mat, vec4(.2, 0,0,0), (smoothstep(.05, .0,min(pos.x, pos.z))\n              \t\t\t\t\t  + smoothstep(.95, 1.,max(pos.x, pos.z))) * clamp(sin(iTime), 0.0, 1.0));\n\n    \n\treturn min(mat, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec4 barkTexture(vec3 p, vec3 nor)\n{\n    vec2 r = floor(p.xz / 5.0) * 0.02;\n    float br = texture(iChannel1, r).x;\n\tvec3 mat = texCube(iChannel3, p*.4, nor) * vec3(.4, .3, .1*br) *br;\n    mat += texCube(iChannel3, p*.53, nor)*smoothstep(0.0,.3, mat.x)*br;\n   \treturn vec4(mat, .1);\n}\n\n//------------------------------------------------------------------------------\nvec4 leavesTexture(vec3 p, vec3 nor)\n{\n    \n    vec3 rand = texCube(iChannel2, p*.15,nor);\n\tvec3 mat = vec3(0.4,1.2,0) *rand;\n   \treturn vec4(mat, .0);\n}\n\n//------------------------------------------------------------------------------\nvec4 fruitTexture(vec3 p, vec3 nor, float i)\n{\n    \n    \n    float rand = texCube(iChannel2, p*.1 ,nor).x;\n    float t = dot(nor, normalize(vec3(.8, .1, .1)));\n\tvec3 mat = vec3(1.,abs(t)*rand,0);\n    mat = mix(vec3(0,1,0), mat, i/10.);\n\n   \treturn vec4(mat, .5);\n}\n\n\n\n//------------------------------------------------------------------------------\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h)\n{\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n}\n\n//------------------------------------------------------------------------------\nconst int   SEEDS = 8 ;\nconst float STEP_SIZE = 2.;\n#define SIZE .03\n\n\n// This seed code is the starfield stuff from iapafoto\n// I've just removed the alpha part...\n// https://www.shadertoy.com/view/Xl2BRR\nmat2 rotMat2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nvec3 floatingSeeds(in vec3 ro, in vec3 rd, in float tmax)\n{ \n \n    float d =  0.;\n    ro /= STEP_SIZE;\n\tvec3 pos = floor(ro),\n\t     ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + .5 + rs*0.5) * ri;\n\t\n    float dint;\n\tvec3 offset, id;\n    vec3 col = vec3(0);\n    vec3 sum = vec3(0);\n    //float size = .04;\n    \n\tfor( int i=0; i< SEEDS; i++ )\n    {\n        id = hash33(pos);\n\n        offset = clamp(id+.2*cos(id*iTime),SIZE, 1.-SIZE);\n        d = distanceRayPoint(ro, rd, pos+offset, dint);\n        \n        if (dint > 0. && dint * STEP_SIZE < tmax)\n        {\n            col = vec3(.4)*smoothstep(SIZE, 0.0,d);\n            sum += col;\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n  \n\treturn sum * .7;\n}\n\n//--------------------------------------------------------------------------\nfloat findClouds2D(in vec2 p)\n{\n\tfloat a = 1.5, r = 0.0;\n    p*= .000001;\n    for (int i = 0; i < 5; i++)\n    {\n        r+= texture(iChannel1,p*=2.2).x*a;\n        a*=.5;\n    }\n\treturn max(r-1.5, 0.0);\n}\n//------------------------------------------------------------------------------\n// Use the difference between two cloud densities to light clouds in the direction of the sun.\nvec4 getClouds(vec3 pos, vec3 dir)\n{\n    if (dir.y < 0.0) return vec4(0.0);\n    float d = (4000. / dir.y);\n    vec2 p = pos.xz+dir.xz*d;\n    float r = findClouds2D(p);\n    float t = findClouds2D(p+normalize(sunLight.xz)*30.);    \n    t = sqrt(max((r-t)*20., .2))*2.;\n    vec3 col = vec3(t) * SUN_COLOUR;\n    // returns colour and alpha...\n    return vec4(col, r);\n} \n\n\n//------------------------------------------------------------------------------\n// Thanks to Fizzer for the space-folded tree idea...\n/// https://www.shadertoy.com/view/4tVcWR\nvec2 map(vec3 p, float t)\n{\n \n    float matID, f;\n    p.y += getGroundHeight(p.xz);\n\tfloat num = (floor(p.z/5.))*5.+(floor(p.x/5.0))*19.;\n\tp.xz = mod(p.xz, 5.0)-2.5;\n    //p.xz *= rotMat2D(p.y*num/300.); // ... No, just too expensive. :)\n    \n    float d = p.y;\n    matID = 0.0;\n\n    float s=1.,ss=1.6;\n    \n    // Tangent vectors for the branch local coordinate system.\n    vec3 w=normalize(vec3(-1.5+abs(hash11(num*4.)*.8),1,-1.));\n    vec3 u=normalize(cross(w,vec3(0,1.,0.)));\n\n    float scale=3.5;\n    p/=scale;\n    vec3 q = p;\n    // Make the iterations lessen over distance for speed up...\n    int it = 10-int(min(t*.03, 9.0));\n\n\tfloat h  = hash11(num*7.)*.3+.3;\n    vec3 uwc = normalize(cross(u,w));\n    int dontFold = int(hash11(num*23.0) * 9.0)+3;\n    \n    float thick = .2/(h-.24);\n    for (int i = 0; i < it; i++)\n    {\n\t\tf = scale*max(p.y-h,max(-p.y,length(p.xz)-.06/(p.y+thick)))/s;\n        if (f <= d)\n        {\n            d = f;\n            matID = 1.0;\n        }\n\n        // Randomly don't fold the space to give more branch types...\n        if (i != dontFold)\n        \tp.xz = abs(p.xz);\n\n        p.y-=h;\n        p*=mat3(u,uwc,w);\n        p*=ss;\n\t\ts*=ss;\n    }\n\n    float fr = .2;\n    f = (length(p)-fr)/s;\n    if (f <= d)\n    {\n        d = f;\n        matID = 2.0;\n    }\n    \n    q.y -= h*1.84;\n    h *= 1.1;\n    for (int i = 0; i < it; i++)\n    {\n      \tp = (normalize(hash31(num+float(i+19))-.5))*vec3(h, 0.1, h);\n     \tp+=q;\n        float ds =length(p)-.015;\n     \tif (ds <= d)\n        {\n            matID = 3.0+float(i);\n         \td = ds;\n        }\n    }\n\n\treturn vec2(d, matID);\n}\n\n//------------------------------------------------------------------------------\nfloat sphereRadius(float t)\n{\n\tt = abs(t-.0);\n\tt *= 0.003;\n\treturn clamp(t, 1.0/iResolution.y, 3000.0/iResolution.y);\n}\n\n//------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd, float dis)\n{\n\tfloat res = 1.0;\n    float t = .1;\n\tfloat h;\n\t\n    for (int i = 0; i < 15; i++)\n\t{\n        vec3 p =  ro + rd*t;\n\n\t\th = map(p,dis).x;\n\t\tres = min(3.*h / t, res);\n\t\tt += h;\n\t}\n    res += t*t*.08; // Dim over distance\n    return clamp(res, .6, 1.0);\n}\n\n//-------------------------------------------------------------------------------------------\n// Taken almost straight from Inigo's shaders, thanks man!\n// But I've changed a few things like the for-loop is now a float,\n// which removes the need for the extra multiply and divide in GL2\nfloat calcOcc( in vec3 pos, in vec3 nor, float d )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(float h= 0.05; h < .3; h+= .07)\n    {\n\t\tvec3 opos = pos + h*nor;\n        float d = map( opos, d ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n//-------------------------------------------------------------------------------------------\nfloat marchScene(in vec3 rO, in vec3 rD, vec2 co)\n{\n\tfloat t = hash12(co)*.5;\n\tvec4 normal = vec4(0.0);\n\tvec3 p;\n    float alphaAcc = 0.0;\n\n    spointer = 0;\n\tfor( int j=min(0,iFrame); j < 140; j++ )\n\t{\n        // Check if it's full or too far...\n\t\tif (spointer == STACK_SIZE || alphaAcc >= 1.) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = sphereRadius(t);\n\t\tvec2 h = map(p, t);\n\t\tif( h.x <= sphereR)\n\t\t{\n            //h = max(h,0.0);\n            float alpha = (1.0 - alphaAcc) * min(((sphereR-h.x+.01) / sphereR), 1.0);\n\t\t\tstack[spointer].pos = p;\n            stack[spointer].alpha = alpha;\n            stack[spointer].dist = t;\n            stack[spointer].mat = int(h.y);\n            alphaAcc += alpha;\n\t        spointer++;\n        }\n\t\tt +=  h.x+t*0.007;\n\t}\n    return alphaAcc;\n}\t\n\n//-------------------------------------------------------------------------------------------\nvec3 lighting(in vec4 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n  \n\tfloat sh = shadow(pos+sunLight*.01,  sunLight, d);\n    float occ = calcOcc(pos, normal, d);\n    // Light surface with 'sun'...\n\tvec3 col = mat.xyz * SUN_COLOUR*(max(dot(sunLight,normal)*.5+.2, 0.0))*sh;\n    // Ambient...\n\t\n    float fre = clamp(1.0+dot(normal,eyeDir),0.0,1.0)*.3;\n    float bac = clamp(.8*dot( normal, normalize(vec3(-sunLight.x,0.0,-sunLight.z))), 0.0, 1.0 );\n    normal = reflect(eyeDir, normal); // Specular...\n\tcol += pow(max(dot(sunLight, normal), 0.0), 16.0)  * SUN_COLOUR * sh * mat.w * occ;\n    col += bac*mat.xyz * occ;\n    col += mat.xyz * abs(normal.y)*.3*occ;\n\tcol += SUN_COLOUR * fre *.2*occ;\n\n\treturn min(col, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec3 getNormal2(vec3 p, float e)\n{\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), 0.).x - map(p-vec3(e,0.0,0.0), 0.).x,\n                            map(p+vec3(0.0,e,0.0), 0.).x - map(p-vec3(0.0,e,0.0), 0.).x,\n                            map(p+vec3(0.0,0.0,e), 0.).x - map(p-vec3(0.0,0.0,e), 0.).x));\n}\n\nvec3 getNormal(vec3 pos, float ds)\n{\n\n    float c = map(pos, 0.).x;\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(ds, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 0.0).x, map(pos + eps_zero.yxy, 0.0).x,\n                          map(pos + eps_zero.yyx, 0.0).x) - c);\n}\n\n\n//------------------------------------------------------------------------------\nvec3 getSky(vec3 dir)\n{\n\tvec3 col = mix(vec3(FOG_COLOUR), vec3(.0, 0.4,0.6),(abs(dir.y)));\n    return col;\n}\n\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    phi *= 0.5;\n    return vec4(sin(phi) * normalize(axis), cos(phi));\n}\n\nvec3 rotate(vec3 point, vec4 rotor) {\n    vec3 rotv = rotor.xyz;\n    return qmult(rotor, vec4(point * rotor.w - cross(point, rotv), dot(point, rotv))).xyz;\n}\n\nvec4 slerp(vec3 u0, vec3 u1, float t) {\n    return qrotor(cross(u0, u1), t * acos(dot(u0, u1)));\n}\n// Thanks to DR2 for this matrix code...\nmat3 viewMat (float ay, float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//==============================================================================\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    sunLight = normalize(vec3(-.8,1.8,-1.5));\n    \n    // Camera stuff...\n    // A simple cylindrical projection with normal Y\n    float time = iTime*1.+mouseXY.x*10.0;\n    \n    #ifdef MOVE_CAMERA\n\t\n    vec3 camera = getCamPos(time*.2);\n\tvec3 lookat = getCamPos(time*.2+10.);\n\n    #else\n    \n    // Don't move the camera bodge...\n    vec3 camera = getCamPos(0.0);\n\tvec3 lookat = getCamPos(0.0);\n    lookat += vec3(40.0*sin(time * 5.28), 0., 40.0*cos(time * .28) );\n\n    #endif\n    \n    float ride = sin(time*.5)*.4;\n    \n    \n    //mat3 camMat = getCamMat(camera, lookat, 0.0);\n    //uv *= .7;\n    // I didn't want to normalize here because it'll distort across the vertical slightly...\n    // But it looks like it's needed for a unit ray length...\n//\tvec3 seedDir = camMat * normalize(vec3(0.0, uv.y,  1.));\n//\tseedDir.xz = rot2D(seedDir.xz, uv.x*1.13); // Adjusted for rotation PI (roughly!) :)\n    \n\n    // Now using Quaternions, thanks to munrocket for the Quat code.\n    // https://www.shadertoy.com/view/3stXR2\n// Quarternion version..\n//    vec3 seedDir  = normalize(vec3(0,0, 1.));\n//    vec2 rotXY = vec2(uv.x+time*.5, -uv.y+ride);\n//    vec4 rotor = qrotor(vec3(0., 1., 0.), rotXY.x);\n//    rotor = qmult(rotor, qrotor(vec3(1., 0., 0.), rotXY.y));\n    //seedDir = rotate(seedDir, rotor);\n    \n    vec3 seedDir  = normalize(vec3(0,0, 1.));\n    seedDir = viewMat (uv.y+ride, uv.x+time*.5)*seedDir;\n  \n    \n\n\tvec3 rd = seedDir;\n\n\tvec3 col = vec3(0);\n\n\tvec3 sky  = getSky(rd);\n  \n\n    // Build the stack returning the final alpha value...\n    float alpha = marchScene(camera, rd, fragCoord);\n    vec4 mat;\n    // Render the stack...\n    if (alpha > .0)\n    {\n        for (int i = 0; i < spointer; i++)\n        {\n            vec3  pos = stack[i].pos; \n            float d = stack[i].dist;\n            \n            vec3 nor =  getNormal(pos, sphereRadius(d));\n            int matID = stack[i].mat;\n            if (matID == 0) mat =  grassTexture(pos, nor);\n            else\n\t\t\t\tif (matID == 1) mat = barkTexture(pos, nor);\n            else\n                if (matID == 2) mat = leavesTexture(pos, nor);\n            else\n                mat = fruitTexture(pos, nor, float(matID - 3));\n\n            mat *= randomTint(pos);\n \n            vec3  temp = lighting(mat, pos, nor, rd, d);\n            if (matID == 3) temp=temp*.4+vec3(.15, .01,0);\n            \n            temp = mix(sky, temp , exp(-d*.01));\n            col += temp * stack[i].alpha;\n        }\n    }\n    vec4 cc = getClouds(camera, rd);\n    sky+= pow(max(dot(sunLight, rd), 0.0), 20.0)*SUN_COLOUR*.03;\n    //sky = clamp(sky, 0.0,1.);\n\tsky = mix(sky, cc.xyz, cc.w);\n\tcol += sky *  (1.0-alpha);\n    \n    float d = stack[0].dist;\n    col+= floatingSeeds(camera, rd, d);\n    \n   \n    // Sun glow effect...\n    col+=pow(max(dot(sunLight, rd), 0.0), 6.0)*SUN_COLOUR*.2;\n    \n    // Clamp and contrast...\n    //col = col * vec3(1.1, 1.1,.9);\n    col = clamp(col,0.,1.);\n    col = col*col*(3.0-2.0*col);\n\n    \n    // The usual vignette...which manages to add more vibrancy...\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.3 + 0.7*pow(90.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.5);\n\t// A nice fade in start...\n    \n    \n    col *= smoothstep(0.0, 5.0, time);\n    fragColour = vec4(sqrt(col), 1.0);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}