{"ver":"0.1","info":{"id":"4syBDy","date":"1530175965","viewed":109,"name":"CEIG 2018 (HUB)","username":"HEGG","description":"¡Bienvenido al tutorial de Shadertoy! Esperamos que disfrutéis de la sesión :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shadertoy","2018","ceig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n¡Bienvenidos al tutorial de Shadertoy!\n\nA lo largo de la sesión de hoy (28/06/18) hablaremos un poco sobre como utilizar\nesta plataforma web para creación de efectos visuales, el renderizado, la simulación\ny todo lo que se os pueda ocurrir.\n\nCon el fin de que podáis experimentar tranquilamente con algunos de los conceptos\nque veremos, os dejamos abajo unos ejemplos muy sencillos que os pueden servir de base\npara montar cosas más chulas.\n\nNo obstante, debéis saber que Shadertoy es muy grande, y existe una ingente cantidad\nde ejemplos seguramente mejores que estos de aquí, así que lo mejor que podéis hacer\nes explorar y aprender de los grandes maestros.\n\n¡Esperamos que disfrutéis de la sesión! :)\n\n- Héctor & José A.\n\n_______________________________________________________________________________\n\nMATERIAL DEL TUTORIAL\n_______________________________________________________________________________\n\nPresentación (con slides extra)       - To be uploaded\n\nParte 0: Experimentos básicos         - https://www.shadertoy.com/view/XdVBzK\nParte 1: Campos de distancia          - https://www.shadertoy.com/view/XsVfRV\nParte 2: Extensión a 3D (Raymarching) - https://www.shadertoy.com/view/XdKBzV\nParte 3: Multipasada y simulación     - https://www.shadertoy.com/view/MdVfRK\n_______________________________________________________________________________\n\nMATERIAL EXTRA\n_______________________________________________________________________________\n\nExtra 1: Ejemplo sencillo 2D          - https://www.shadertoy.com/view/ldKBzV\nExtra 2: Ruido procedural             - https://www.shadertoy.com/view/XdGfDy\n\n_______________________________________________________________________________\n\nOTROS ENLACES INTERESANTES\n_______________________________________________________________________________\n\nRendering Worlds with Two Triangles (I. Quilez) - https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nModelling with Distance Functions (I. Quilez)   - https://iquilezles.org/articles/distfunctions\n\n*/\n\n#define PI    3.14159265359\n#define TWOPI 6.28318530718\n\n// __________________________________________________________________________________________________\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nvec2 sincos(float angle)\n{\n    return vec2(sin(angle), cos(angle));\n}\n\nvec2 rotate(float angle, vec2 vec)\n{\n    vec2 sc = sincos(angle);\n    mat2 R = mat2(sc.y, -sc.x, sc.x, sc.y);\n    return R * vec;\n}\n\nvec2 rotateAround(vec2 anchor, float angle, vec2 vec)\n{\n    return rotate(angle, vec - anchor) + anchor;\n}\n\n// __________________________________________________________________________________________________\n\nfloat line(vec2 pt, vec2 start, vec2 end)\n{\n    vec2 pa = pt - start;\n    vec2 ba = end - start;\n    vec2 q = start + ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return distance(pt, q);\n}\n\nfloat circle(vec2 pt, float radius)\n{\n    return length(pt) - radius;\n}\n\nfloat pie(vec2 pt, float radius, float angle)\n{    \n    vec2 dir = normalize(pt);\n    \n    float theta = PI-atan(dir.y, -dir.x);\n    theta = clamp(theta, angle, TWOPI - angle);\n    \n    vec2 q = vec2(cos(theta), sin(theta)) * radius; \n    return distance(pt, q);\n}\n\nfloat outline(float dist, float thickness)\n{\n    float h = 0.5 * fwidth(dist);\n    return 1.0 - smoothstep(thickness - h, thickness + h, abs(dist));    \n}\n\n// __________________________________________________________________________________________________\n\n\nfloat letterC(vec2 pt, vec2 center)\n{\n    const float radius = 55.0;\n    const float theta = radians(57.5);\n    \n    pt -= center;\n    return pie(pt, radius, theta);\n}\n\nfloat letterE(vec2 pt, vec2 center)\n{\n    const vec2 vertex00 = vec2(-31, 55.0);\n    const vec2 vertex01 = vec2(31, 55.0);\n    const vec2 vertex10 = vec2(-31, 0.0);\n    const vec2 vertex11 = vec2(21, 0.0);\n    const vec2 vertex20 = vec2(-31, -55.0);\n    const vec2 vertex21 = vec2(31, -55.0);\n    \n    pt -= center;\n    float dist1 = line(pt, vertex00, vertex20);\n    float dist2 = line(pt, vertex00, vertex01);\n    float dist3 = line(pt, vertex10, vertex11);\n    float dist4 = line(pt, vertex20, vertex21);\n    \n    return min(dist1, min(dist2, min(dist3, dist4)));\n}\n\nfloat letterI(vec2 pt, vec2 center)\n{\n    const vec2 vertex0 = vec2(0, 55.0);\n    const vec2 vertex1 = vec2(0, -55.0);\n    \n    pt -= center;\n    return line(pt, vertex0, vertex1);\n}\n\nfloat letterG(vec2 pt, vec2 center)\n{\n    const float radius = 55.0;\n    const float theta = radians(50.0);\n    \n    const vec2 vertex0 = radius * vec2(cos(theta), -sin(theta));\n    const vec2 vertex1 = vec2(radius * cos(theta), -5.0);\n    const vec2 vertex2 = vec2(0.0, -5.0);\n                               \n    pt -= center;\n    float dist1 = pie(pt, radius, theta);\n    float dist2 = line(pt, vertex0, vertex1);\n    float dist3 = line(pt, vertex1, vertex2);\n        \n    return min(dist1, min(dist2, dist3));\n}\n\nfloat number1(vec2 pt, vec2 center)\n{\n    const vec2 vertex0 = vec2(-30.0, 35.0);\n    const vec2 vertex1 = vec2(0.0, 55.0);\n    const vec2 vertex2 = vec2(0.0, -55.0);\n    \n    pt -= center;\n    float dist1 = line(pt, vertex0, vertex1);\n    float dist2 = line(pt, vertex1, vertex2);\n    return min(dist1, dist2);\n}\n\n\nfloat number8(vec2 pt, vec2 center)\n{\n    const float radius1 = 25.5;\n    const float radius2 = 29.5;\n    \n    pt -= center;\n\tfloat dist1 = circle(pt + vec2(0.0, -radius2), radius1);\n    float dist2 = circle(pt + vec2(0.0, radius1), radius2);\n    \n    return min(dist1, dist2);\n}\n\n\n// __________________________________________________________________________________________________\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 500.0 * uv - 255.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    const vec3 color0 = (1.0 / 255.0) * vec3(30.0);\n    const vec3 color1 = (1.0 / 255.0) * vec3(255.0);\n    const vec3 color2 = (1.0 / 255.0) * vec3(0.0, 155.0, 219.0);\n    const vec3 color3 = (1.0 / 255.0) * vec3(0.0, 144.0, 69.0);\n    const vec3 color4 = (1.0 / 255.0) * vec3(203.0, 96.0, 26.0);\n    const vec3 color5 = (1.0 / 255.0) * vec3(160.0, 16.0, 39.0);\n    const vec3 color6 = (1.0 / 255.0) * vec3(123.0, 8.0, 126.0);\n    const vec3 color7 = (1.0 / 255.0) * vec3(247.0, 224.0, 31.0);\n    const vec3 color8 = (1.0 / 255.0) * vec3(191.0, 33.0, 118.0);\n    \n    const vec2 centerCEIG = vec2(-105.0, 0.0);\n    float distC = letterC(uv, centerCEIG + vec2(-130.0, 0.0));\n    float distE = letterE(uv, centerCEIG + vec2(-30.0, 0.0));\n    float distI = letterI(uv, centerCEIG + vec2(40.0, 0.0));\n    float distG = letterG(uv, centerCEIG + vec2(130.0, 0.0));\n    float distCEIG = min(distC, min(distE, min(distI, distG)));\n    float outlineCEIG = outline(distCEIG, 5.0);\n\n    const vec2 center18 = vec2(205.0, 0.0);\n    float dist1 = number1(uv, center18 + vec2(-36.0, 0.0));\n    float dist8 = number8(uv, center18 + vec2(36.0, 0.0));\n    float dist18 = min(dist1, dist8);\n    float outline18 = outline(dist18, 5.0);\n    float mask18 = all(lessThan(abs(uv - center18), vec2(96.0, 70.0))) ? 1.0 : 0.0;\n    \n    const vec2 centerFlower = centerCEIG + vec2(-130.0, 0.0);\n    const vec2 anchorFlower = centerFlower + vec2(-60.0, 0.0);\n    float animAngle = radians(3.0) * cos(iTime);\n    float outlineCF0 = outline(letterC(rotateAround(anchorFlower, animAngle + radians(45.0), uv), centerFlower), 5.0);\n    float outlineCF1 = outline(letterC(rotateAround(anchorFlower, -animAngle + radians(90.0), uv), centerFlower), 5.0);\n    float outlineCF2 = outline(letterC(rotateAround(anchorFlower, animAngle + radians(135.0), uv), centerFlower), 5.0);\n    float outlineCF3 = outline(letterC(rotateAround(anchorFlower, -animAngle + radians(180.0), uv), centerFlower), 5.0);\n    float outlineCF4 = outline(letterC(rotateAround(anchorFlower, animAngle + radians(225.0), uv), centerFlower), 5.0);\n    float outlineCF5 = outline(letterC(rotateAround(anchorFlower, -animAngle + radians(270.0), uv), centerFlower), 5.0);\n    float outlineCF6 = outline(letterC(rotateAround(anchorFlower, animAngle + radians(315.0), uv), centerFlower), 5.0);\n    float flowerMask = step(0.0, circle(uv - centerFlower, 55.0));\n        \n    fragColor.rgb = color1;\n    fragColor.rgb = mix(fragColor.rgb, color8, flowerMask * outlineCF6);\n    fragColor.rgb = mix(fragColor.rgb, color7, flowerMask * outlineCF5);\n    fragColor.rgb = mix(fragColor.rgb, color6, flowerMask * outlineCF4);\n    fragColor.rgb = mix(fragColor.rgb, color5, flowerMask * outlineCF3);\n    fragColor.rgb = mix(fragColor.rgb, color4, flowerMask * outlineCF2);\n    fragColor.rgb = mix(fragColor.rgb, color3, flowerMask * outlineCF1);\n    fragColor.rgb = mix(fragColor.rgb, color2, flowerMask * outlineCF0);\n    fragColor.rgb = mix(fragColor.rgb, color0, outlineCEIG);\n    fragColor.rgb = mix(fragColor.rgb, color0, mask18);\n    fragColor.rgb = mix(fragColor.rgb, color1, outline18);\n\tfragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}