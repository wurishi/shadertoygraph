{"ver":"0.1","info":{"id":"wd3SzB","date":"1574185932","viewed":287,"name":"[delete] ocean","username":"delete","description":"ocean test","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sea","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//inspired by https://www.shadertoy.com/view/XdsGDB\n/////////////////////////////////////////////\n\n#define RAY_MAXDEPTH 1000.\n#define RAY_INTERVAL 0.01\n#define RAY_NUMSTEPS 100\n\n#define IOR_AIR 1.0 \n#define IOR_WATER 1.33 \n#define IOR_GLASS 1.5\n#define IOR_DIAMOND 2.4\n\n#define REFRACT\n#define REFLECT\n#define FOG\n\nconst vec3 fogColor=vec3(0.7227,0.7155,0.7445);\nconst vec3 seabaseColor=vec3(0.0090,0.1275,0.1884);\n\n\nstruct Light{\n\tvec3 pos;\n    vec3 intensity;\n};\n\nstruct Obj{\n\tfloat depth;\n    int id;\n};\n\nstruct Material{\n    vec3 albedo;\n    float roughness;\t//roughness [0 1] 1 for rough surface\n    float metallic; //[0 1] 1 metal specular coefficient\n    float ior;\n};\n\nconst int lightNum=1;\nconst Light lights[]=Light[lightNum](Light(vec3(1.,0.2,1.),vec3(1.,0.5,0.)));\nconst vec3 ambient=vec3(0.02);\n\nconst vec3 albedoGold=vec3(255,215,0)/255.;\nconst vec3 albedoDarkGold=vec3(184,134,11)/255.;\n\nMaterial getMaterialById(int id){\n    switch(id){\n        case 0: //ground\n        //return Material(vec3(0.8,0.9,0.6)*0.0,0.1,0.,1.5);\n        return Material(vec3(0.),0.2,0.,IOR_WATER);\n        case 1: //\n        return Material(vec3(1.),.5,0.,IOR_WATER);\n        case 3: //glass\n        return Material(vec3(0.),.1,0.,IOR_GLASS);\n\n        \n        case 11:\n        return Material(albedoDarkGold,.01,1.,0.27732);  \n        case 12:\n        return Material(albedoDarkGold,.2,1.,0.27732);  \n        case 13:\n        return Material(albedoDarkGold,.5,1.,0.27732);  \n        case 14:\n        return Material(albedoDarkGold,.8,1.,0.27732);  \n        case 15:\n        return Material(albedoDarkGold,1.,1.,0.27732);  \n\n        case 21:\n        return Material(albedoDarkGold,.01,0.,1.5);  \n        case 22:\n        return Material(albedoDarkGold,.2,0.,1.5);  \n        case 23:\n        return Material(albedoDarkGold,.5,0.,1.5);  \n        case 24:\n        return Material(albedoDarkGold,.8,0.,1.5);  \n        case 25:\n        return Material(albedoDarkGold,1.,0.,1.5);  \n\n    }\n    //no intersection\n    return Material(vec3(0.),0.,1.,1.);\n}\n\nfloat checkersMod( in vec3 p )\n{\n    vec3 q = floor(p);\n    return clamp(mod(q.x+q.y+q.z,2.),0.,1.);\n}\n\nObj intersectSDF(in Obj A, in Obj B) {\n    if(A.depth>B.depth)return A;\n    return B;\n}\n\nObj unionSDF(Obj A, Obj B) {\n    if(A.depth<B.depth)return A;\n    return B;\n}\n\nObj differenceSDF(Obj A, Obj B) {\n    B.depth*=-1.;\n    if(A.depth>B.depth)return A;\n    return B;\n}\n\n\nfloat intersectSDF(float A, float B) {\n    return A>B?A:B;\n}\n\nfloat unionSDF(float A, float B) {\n    return A<B?A:B;\n}\n\nfloat differenceSDF(float A, float B) {\n    B=-B;\n    return A>B?A:B;\n}\n\nfloat sphereSDF(vec3 pos,float R){\n\t//base sphere R=1, center=0;\n    return (length(pos)-R);\n}\nfloat cubeSDF(vec3 p,vec3 size, float r){\n    vec3 d = abs(p)-size+r;\n    return length(max(d,0.0))+min(maxcomp(d),0.0)-r;\n}\n\nfloat infinitePlaneSDF(vec3 p,vec3 n){\n\tn=normalize(n);\n    return dot(p,n);\n}\n\n\n//3d noise\n// return value noise (in x) and its derivatives (in yzw)\nfloat noise31( in vec3 x )\n{\n\tvec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    #if 1\n    vec2 uv1 =i.xz+f.xz+vec2(13.,17.)*i.y+0.5;//i.xz+f.xz;\n    float c1=textureLod(iChannel0,uv1/vec2(textureSize(iChannel0,0)),0.).r;\n    vec2 uv2 = uv1+vec2(13.,17.);\n    float c2=textureLod(iChannel0,uv2/vec2(textureSize(iChannel0,0)),0.).r;\n    return mix(c1,c2,f.y);\n    #else   \n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n    #endif\n}\n\n\nfloat groundHeightMid(vec2 uv){\n    float y=0.;\n    //large wave\n    float G=0.5;\n    float A=10.0;\n\n    //large wave\n    vec3 p=vec3(uv,uv.x)*0.01+vec3(.5,.5,.0)*iTime;\n    #if 1\n\t//A=5.;\n    y+=A*(noise31(p));\n    #endif\n    \n    //small wave\n    #if 1\n    //G=0.5;\n\t//A=5.;\n    p=vec3(uv,0.)*0.01+vec3(.0,.1,.1)*iTime;\n    for(int i=0;i<3;++i){\n    \ty+=A*(1.-abs(noise31(p)-0.5)*2.);\n        p*=2.;\n        //p.xy=m2*p.xy;\n        p = (p.yzx + p.zyx*vec3(1,-1,1))/sqrt(2.0);\n        A*=G;\n    }\n    #endif\n    return y;\n}\nfloat groundHeightHigh(vec2 uv){\n    float y=0.;\n    //large wave\n    float G=0.5;\n    float A=10.0;\n\n    //large wave\n    vec3 p=vec3(uv,uv.x)*0.01+vec3(.5,.5,.0)*iTime;\n    #if 1\n\t//A=5.;\n    y+=A*(noise31(p));\n    #endif\n    \n    //small wave\n    #if 1\n    //G=0.5;\n\t//A=5.;\n    p=vec3(uv,0.)*0.01+vec3(.0,.1,.1)*iTime;\n    for(int i=0;i<8;++i){\n    \ty+=A*(1.-abs(noise31(p)-0.5)*2.);\n        p*=2.;\n        //p.xy=m2*p.xy;\n        p = (p.yzx + p.zyx*vec3(1,-1,1))/sqrt(2.0);\n        A*=G;\n    }\n    #endif\n    return y;\n\n}\n\n//setup scene\nObj sceneSDF(vec3 p){\n    Obj res=Obj(RAY_MAXDEPTH,-1);\n    //res=unionSDF(res,Obj(sphereSDF(p-vec3(0.,1.9,0.),1.),3));\n    //res=unionSDF(res,Obj(cubeSDF(p-vec3(0.,1.9,0.),vec3(1.0),abs(sin(iTime*.2))),3));\n    return res;\n}\n\nvec3 envColor(vec3 rd){\n    //return texture(iChannel0,rd).rgb;\n\tvec3 skyUp=pow(vec3(0,191,255)/255.,vec3(2.2));\n    vec3 skyDown=vec3(1.,0.4,0.);\n    //return skyDown;\n    //add sun\n    float VdotL=max(dot(rd,normalize(lights[0].pos)),0.);\n    VdotL=pow(VdotL,200.);  \n    vec3 col=mix(skyDown,skyUp,max(sign(rd.y)*pow((rd.y)*3.+0.1,0.4),0.4));\n    col+=lights[0].intensity*VdotL*1.5;\n    \n    return col;\n}\n\n\nfloat calcSoftShadow(vec3 ro, vec3 rd,float tmin,float tmax,float k){\n\tfloat res=1.;\n    Obj temp;\n    for(float t=tmin;t<tmax;){\n        vec3 pos=ro+t*rd;\n        temp=sceneSDF(pos);\n        if(abs(temp.depth)<RAY_INTERVAL)return 0.;\n        res=min(res,k*temp.depth/t);\n        t+=temp.depth;\n    }\n    return res;\n}\n\n\n\n\nObj castTerrianRay2(vec3 ro,vec3 rd){\n\tconst float tmax=RAY_MAXDEPTH;\n    const float tmin=RAY_INTERVAL;\n    float dt=0.01;\n    Obj res=Obj(tmax,-1);\t//no intersection\n    if(rd.y>=0.)return res;\n    \n    float lh=0.f;\n    float ly=0.;\n    \n    for(float t=tmin;t<tmax;t+=dt){\n    \tvec3 p=ro+t*rd;\n        float h=groundHeightMid(p.xz);\n        if(p.y<h){\n            t=t-dt+dt*(ly-lh)/(h-p.y+ly-lh);\n        \tres=Obj(t,0);\n            break;\n        }\n        dt=max(0.02*t,0.001);\n        lh=h;\n        ly=p.y;\n    }\n    return res;  \n}\n\nObj castTerrianRay(vec3 ro,vec3 rd){\n\tconst float tmax=RAY_MAXDEPTH;\n    const float tmin=RAY_INTERVAL;\n    Obj res=Obj(tmax,-1);\t//no intersection\n    if(rd.y>=0.1)return res;\n    \n    float t=tmin;\n    float preH=0.f;\n    float preY=0.;\n    float dt=0.;\n    for(int i=0;i<RAY_NUMSTEPS;++i){\n    \tvec3 p=ro+t*rd;\n        float h=groundHeightMid(p.xz);\n        if(t>tmax)return res;\n        if(p.y<h){\n            //t-=(h-p.y)*(preY-preH)*0.4/(preY-preH+h-p.y);\n        \tres=Obj(t,0);\n            return res;\n        }\n        preH=h;\n        preY=p.y;\n        dt=max((p.y-h)*0.4,0.01);\n    \tt+=dt;\n    }\n    res=unionSDF(res,Obj(t,0));\n    return res;  \n}\n\n\n\nvec3 getTerrianNormal(vec3 p,float t){\n    //fix this\n\t//const float e=1e-1;\n    float e =max(.002*t,0.1);\n    //float e =max(.00001*t*t,0.2);\n    vec3 N=normalize(vec3(\n        groundHeightHigh(p.xz-vec2(e,0.))-groundHeightHigh(p.xz+vec2(e,0.)),\n        2.*e,\t\t\n    \tgroundHeightHigh(p.xz-vec2(0.,e))-groundHeightHigh(p.xz+vec2(0.,e)))\n    );\n      \n    return N;\n    \n}\n\n\nObj rayMarch(vec3 ro,vec3 rd){\n    const float tmax=RAY_MAXDEPTH;\n    const float tmin=RAY_INTERVAL+0.01;\n    Obj res=Obj(tmax,-1);\t//no intersection\n    \n    //ground\n#if 1\n    res=castTerrianRay(ro,rd);\n    ////float groundHeight=hash11(iTime);\n    //float d=(-0.1-ro.y)/rd.y;\n    //if(d>tmin&&d<tmax){\n    //    vec3 pos=ro+d*rd;\n    //    //d+=fbm(pos+iTime,5);\n    //    res=Obj(d,0);\n    //}\n#endif\n    //scene shapes\n    Obj temp;\n    float t=tmin;\n    for(int i=0;i<RAY_NUMSTEPS;++i){\n        vec3 pos=ro+t*rd;\n        temp=sceneSDF(pos);\n        t+=abs(temp.depth);\n        if(abs(temp.depth)<RAY_INTERVAL||t>tmax)break;\n    }\n    temp.depth=t;\n    res=unionSDF(res,temp);\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    //vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    //return normalize( e.xyy*sceneSDF( pos + e.xyy ).depth + \n\t//\t\t\t\t  e.yyx*sceneSDF( pos + e.yyx ).depth + \n\t//\t\t\t\t  e.yxy*sceneSDF( pos + e.yxy ).depth + \n\t//\t\t\t\t  e.xxx*sceneSDF( pos + e.xxx ).depth );\n    vec3 eps = vec3(RAY_INTERVAL,0.0,0.0);\n\treturn normalize( vec3(\n           sceneSDF(pos+eps.xyy).depth - sceneSDF(pos-eps.xyy).depth ,\n           sceneSDF(pos+eps.yxy).depth  - sceneSDF(pos-eps.yxy).depth ,\n           sceneSDF(pos+eps.yyx).depth  - sceneSDF(pos-eps.yyx).depth  ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneSDF(pos+0.0005*e).depth;\n    }\n    return normalize(n);\n#endif    \n}\n\n\n\nvec3 shading(in vec3 R0,in Light lights[lightNum],in Material material,vec3 pos,vec3 V,vec3 N){\n    vec3 col=vec3(0.);\n\n\tvec3 kd=vec3(1.);\n    \n    for(int i=0;i<lightNum;++i){\n        #if 0\n        vec3 tempL=lights[i].pos-pos;\n        vec3 L=normalize(tempL);\n        vec3 intensity=lights[i].intensity/pow(length(tempL),2.);\n        #else\n        vec3 L=normalize(lights[i].pos);\n        vec3 intensity=lights[i].intensity; \t//no attenuation\n        #endif\n\n        //float k_shadow=calcShadow(pos,L,0.001,length(tempL));\t//sharp shadow\n        //float k_shadow=calcSoftShadow(pos,L,RAY_INTERVAL+0.0001,RAY_MAXDEPTH,16.);\t//soft shadow\n        float k_shadow=1.;\n        #if 0\n        float d=DiffuseLamber(L,N);\n        #else\n        float d=DiffuseOrenNayar(material.roughness,L,V,N)*PI;\n        #endif\n\n        #if 0\n        float shinness=max(pow(1.-material.roughness,4.)*500.,10.); //replace this\n        float s=SpecularBlinnPhong(shinness,L,V,N)*(1.-material.roughness);\n        kd=vec3(material.roughness);\n\t\t#else\n        \n        vec3 ks=vec3(0.);\n        vec3 s=SpecularCookTorrance(R0,material.roughness,pos,L,V,N,ks);\n        kd=1.-ks;\n        #endif\n        \n        col+=k_shadow*intensity*(material.albedo*(1.-material.metallic)*kd*d+s);\n\t\t//col+=k_shadow*intensity*(material.albedo*(1.-material.metallic)*kd*d);\n        //col+=k_shadow*intensity*(s);\n        //col=vec3(s);\n    }\n    col+=ambient*material.albedo;\n    return col;\n}\n\n\n\nstruct Para{\n    vec3 ro;\n    vec3 rd;\n    float ior;\n    vec3 attenuation;\n};\nconst int STACKCAPACITY=10;\nconst int MAXITERATION=20;\nconst vec3 a_glass=vec3(0.2,.5,.2);\nconst vec3 a_water=vec3(.3,.3,.2); \n\nvec3 render(vec3 ro,vec3 rd){\n    // float curIOR=IOR_AIR,nextIOR=IOR_AIR;\n\n    vec3 col=vec3(0.);\n    Para paras[STACKCAPACITY];\n    paras[0]=Para(ro,rd,IOR_AIR,vec3(1.0));\n    int count=0;\n    for(int i=0;i>-1&&i<STACKCAPACITY&&count<MAXITERATION;--i,++count){\n        Para curPara=paras[i];\n        if(all(lessThan(curPara.attenuation,vec3(.01)))){continue;};\n        //vec3 color=curPara.attenuation*bgColor(curPara.rd);\n\n        Obj interP=rayMarch(curPara.ro,curPara.rd);\t//intersection pos depth\n        if(interP.depth<.01){continue;}\n\t\t//\n        #ifdef FOG\n        float fog=1.-clamp(exp(-pow(interP.depth/RAY_MAXDEPTH*1.0,2.)),0.,1.);\n       \t#else\n        float fog=0.;\n        #endif\n        if(interP.id!=-1){\n            //col=bgColor(curPara.rd);\n            vec3 pos=curPara.ro+interP.depth*curPara.rd;\n            Material material=getMaterialById(interP.id);\n            vec3 V=normalize(curPara.ro-pos);\n            vec3 N=vec3(0.);\n            if(interP.id==0)N=getTerrianNormal(pos,interP.depth);\n            else N=calcNormal(pos);\n            //col=N;\n            //break;\n            vec3 R0=F0Unreal(material.ior,material.albedo,material.metallic);\n            float VdotN=dot(V,N);\n\n            if(true){\n                vec3 F=vec3(0.0);\n               \t\n                #ifdef REFRACT\n                if(VdotN<-0.0){\n                    N=-N;\n                    VdotN=-VdotN;\n                \t//N*=vec3(1.,-1.,1.);\n                }\n                #endif\n                //F=F_Schlick(R0,VdotN);                                \n                F=F_SchlickRoughness(R0,VdotN,material.roughness);\n                \n                #ifdef REFRACT\n                if(interP.id==3){\n                    vec3 k=vec3(1.);\n                    //transparent object\n                    float nextIOR=material.ior;\n                    if(curPara.ior==nextIOR){\n                        nextIOR=IOR_AIR;\n                        k=exp(-a_glass*interP.depth);\n                    }\n                    vec3 t=refract(-V,N,curPara.ior/nextIOR);\n                    if(t!=vec3(0.)){\n                        //push refract\n                        paras[i]=Para(pos,t,nextIOR,curPara.attenuation*k*(1.-F));\n                        ++i;\n                    }else F=vec3(1.0);\n                }else if(interP.id==0){\n                    \n\t\t\t\t\tcol+=curPara.attenuation*mix(seabaseColor,fogColor,fog);   //sea base color \n                    //col+=vec3(0.08,0.09,0.16);\n                    //col+=vec3(0.,0.,.1); \n                }\n                #endif\n\n                #ifdef REFLECT //enable reflect cannot use width IBL\n                    vec3 r=reflect(-V,N);\n                    float b=pow((1.-material.roughness),1.);\n                \tcurPara.attenuation*=mix(1.,0.,fog);\n                    paras[i]=Para(pos,r,curPara.ior,curPara.attenuation*F*b); //\n                    ++i;\n                #endif\n            }\n            //if(interP.id==0){material.albedo=vec3(checkersMod(pos));}\n\t\t\t#if 1\n            //col+=curPara.attenuation*mix(shading(R0,lights,material,pos,V,N),0.6*envColor(curPara.rd*vec3(1.,0.,1.)),smoothstep(0.5,1.,interP.depth/RAY_MAXDEPTH));           \n            //col+=mix(curPara.attenuation*mix(shading(R0,lights,material,pos,V,N),0.6*envColor(curPara.rd*vec3(1.,0.,1.)),smoothstep(0.5,1.,interP.depth/RAY_MAXDEPTH)),fogColor,fog);//,vec3(0.1),fog);\n            col+=curPara.attenuation*mix(shading(R0,lights,material,pos,V,N),fogColor,fog);//,vec3(0.1),fog);\n            \n            #else \n            col+=shadingIBL(R0,material,pos,V,N);\n        \t#endif\n        }else{\n           // col+=curPara.attenuation*envColor(curPara.rd);\n            col+=curPara.attenuation*mix(envColor(curPara.rd),fogColor,fog);\n        }\n        \n    }\n    return clamp(col,0.,1.);    \n}\n\nvoid setCamera(vec2 uv,out vec3 ro,out mat3 V){\n    //\n    vec2 mo;\n    mo=step(1.,iMouse.z)==1.?vec2(iMouse.x/iResolution.x*2.-1.,iMouse.y/iResolution.y-0.5)*PI:vec2(0.);\n\n    float ans=0.*iTime; \n    const float r=100.; \n    ro = vec3( r*cos(ans + 1.0*mo.x-0.75*PI), r+r*sin(-0.5-mo.y), r*sin(ans + 1.0*mo.x-0.75*PI) );\n    //ro=vec3(r*cos(mo.x)*cos(mo.y),r*sin(-mo.y),r*sin(mo.x)*cos(mo.y));\n    //ro=vec3(0.,r*sin(-mo.y),r*cos(mo.y));\n    vec3 eyeUp=vec3(0,1,0);\n    vec3 eyeLookat=vec3(0,30.,0);\t//look at point\n    \n    //eye matrix\n    V=lookAt(ro,eyeLookat,eyeUp);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.xy;\n    \n    mat3 V;\n    vec3 ro,rd;\n    //\n    setCamera(uv,ro,V);\n    vec3 col=vec3(0.);\n\n    #define AA 1\n    for(int i=0;i<AA;++i){\n        for(int j=0;j<AA;++j){\n            //cast a view ray\n            vec2 p=(fragCoord+(vec2(i,j)+.5)/float(AA))/iResolution.xy-0.5;\n            //p.y*=float(iResolution.y)/iResolution.x;\n            p.x*=iResolution.x/iResolution.y;\n            rd=normalize(V*vec3(p.x,p.y,-1.));\t//world space\n            col+=render(ro,rd);\n        }\n    }\n    //col=rendering(ro,rd);\n    col/=float(AA*AA);\n\t\n    //float exposure=1.2;\n    //col = vec3(1.0) - exp((-col) * exposure);\n\n    col=pow(col,vec3(1./2.2));\n\n    fragColor=vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define ZERO (min(iFrame,0))\n#define PI 3.14159265358979323846\n#define DEG2RAD(a) a*PI/180.\n\nfloat maxcomp(vec2 v){\n\treturn max(v.x,v.y);\n}\n\nfloat maxcomp(vec3 v){\n\treturn max(max(v.x,v.y),v.z);\n}\nfloat maxcomp(vec4 v){\n\treturn max(max(max(v.x,v.y),v.z),v.w);\n}\n\nmat3 identity(inout mat3 m){\n    m[0]=vec3(0.);\n    m[1]=vec3(0.);\n    m[2]=vec3(0.);\n    m[0][0]=1.;\n    m[1][1]=1.;\n    m[2][2]=1.;\n    return m;\n}\n//rotate with x y z\nmat3 rotate(float angle, vec3 v){\n    float a = DEG2RAD(angle);\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\n    vec3 axis=normalize(v);\n    vec3 temp=(1. - c) * axis;\n\n    mat3 Rotate;\n    Rotate[0][0] = c + temp[0] * axis[0];\n\tRotate[0][1] = temp[0] * axis[1] + s * axis[2];\n\tRotate[0][2] = temp[0] * axis[2] - s * axis[1];\n\n\tRotate[1][0] = temp[1] * axis[0] - s * axis[2];\n\tRotate[1][1] = c + temp[1] * axis[1];\n\tRotate[1][2] = temp[1] * axis[2] + s * axis[0];\n\n\tRotate[2][0] = temp[2] * axis[0] + s * axis[1];\n\tRotate[2][1] = temp[2] * axis[1] - s * axis[0];\n\tRotate[2][2] = c + temp[2] * axis[2];\n\treturn Rotate;\n}\n\n\nmat3 scale(vec3 factor){\n    mat3 m;\n    identity(m);\n    m[0][0]=factor[0];\n    m[1][1]=factor[1];\n    m[2][2]=factor[2];\n    return m;\n}\n\n//eye matrix\nmat3 lookAt(vec3 pos,vec3 lookat,vec3 up){\n    mat3 m;\n    identity(m);\n    \n    //eye matrix\n    vec3 ww=-normalize(lookat-pos);\n    vec3 uu=normalize(cross(up,ww));\n    vec3 vv=normalize(cross(ww,uu));\n    m[0]=uu;\n    m[1]=vv;\n    m[2]=ww;\n    return m;    \n}\n\nmat3 surfaceTBN(vec3 N){\n    mat3 m;\n    identity(m);\n\n    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n    mat3 TBN = mat3(tangent, bitangent, N);\n    return TBN;\n}\n\n\n\n\nfloat hash11( float n )    // in [0,1]\n{\n    return fract(sin(n*13.)*43758.5453);\n}\nfloat hash21 (in vec2 _st) {\n    return fract(sin(dot(_st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 hash22( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat hash31(vec3 p)  // replace this by something better\n{\n    #if 0\n    p  = 13.0*fract( p*0.3183099 + .1);\n    return -1.0 + 2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    #else\n    float n = p.x + p.y*57.0 + 113.0*p.z;\t//?????\n    return hash11(n);\n    #endif\n}\n\n\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat radicalInverse_VdC(uint bits) {\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n }\n\n vec2 hammersley2d(uint i, uint N) {\n     return vec2(float(i)/float(N), radicalInverse_VdC(i));\n }\n\n\n\n\n\nfloat DiffuseOrenNayar(float roughness,vec3 L,vec3 V,vec3 N){\n    float res=0.;\n    float roughness2=roughness*roughness;\n    float A=1.-.5*roughness2/(roughness2+.33);\n    float B=.45*roughness2/(roughness2+.09);\n\n    float VdotN=max(dot(V,N),0.);\n    float aVN=acos(VdotN);\n\n    float LdotN=max(dot(L,N),0.);\n    float aLN=acos(LdotN);\n    float alpha=max(aVN,aLN);\n    float beta=min(aVN,aLN);\n    float c=max(0.,cos(aLN-aVN));\n    res=LdotN*(A+B*c*sin(alpha)*sin(beta))/PI;     //divide by PI\n    return max(res,0.);\n}\nfloat DiffuseLamber(vec3 L,vec3 N){\n\tfloat res=max(0.,dot(N,L));    \n    return (res);\n}\nfloat SpecularBlinnPhong(float shinness,vec3 L,vec3 V,vec3 N){\n    //shadow\n\tfloat res=(0.);\n    vec3 H=normalize(L+V);\n    res=pow(max(0.,dot(N,H)),shinness);    \n    return res;\n}\n\nvec3 F0Unreal(float ior,vec3 albedo,float metallic){\n    float F0 = abs ((1.0 - ior) / (1.0 + ior));\n    F0 = F0 * F0;\n    return mix(vec3(F0), albedo, metallic);\n}\n\nfloat F0Schlick(float n1,float n2){\n    return pow((n1-n2)/(n1+n2),2.);\n}\n\nvec3 F_Schlick(vec3 F0,float VdotN){\n    // return R0+(1.-R0)*pow(1.-cosTheta,5.);\n    return F0 + (1.0 - F0) * exp2((-5.55473 * VdotN - 6.98316) * VdotN);\n}\n\nvec3 F_SchlickRoughness(vec3 F0,float VdotN,float roughness){\n    // return R0+(1.-R0)*pow(1.-cosTheta,5.);\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * exp2((-5.55473 * VdotN - 6.98316) * VdotN);\n}\n\nfloat G_SchlickBeckmann(float k,vec3 i,vec3 H){\n    float cosTheta=max(0.,dot(i,H));\n    return cosTheta/(cosTheta*(1.-k)+k);\n}\n\n\nfloat Gp_GGX(float alpha2,vec3 i,vec3 N,vec3 H){\n\t//alpha is roughness\n    float idotH2=dot(i,H);\n    float chi=step(0.,idotH2/dot(i,N));\n    idotH2=idotH2*idotH2;\n    float tan2=(1.-idotH2)/idotH2;\n    return chi*2./(1.+sqrt(1.+alpha2*tan2));\n}\n\nfloat G_GGX(float alpha2,vec3 L,vec3 V,vec3 N,vec3 H){\n    return Gp_GGX(alpha2,L,N,H)*Gp_GGX(alpha2,V,N,H);\n}\n\n\nfloat G_Smith(float k,vec3 L,vec3 V,vec3 N){\n    return G_SchlickBeckmann(k,L,N)*G_SchlickBeckmann(k,V,N);\n}\n\nfloat D_GGX(float alpha2,vec3 H,vec3 N){\n    float cosTheta=max(0.,dot(H,N));\n    float cosTheta2=cosTheta*cosTheta;\n    float temp=1.+cosTheta2*(alpha2-1.);\n    return alpha2/(PI*temp*temp);\n}\n\n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness)\n{\n    float a = roughness*roughness;\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    // from spherical coordinates to cartesian coordinates\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n    return H;\n}\n\nconst int SAMPLENUM=16;\nvec3 SpecularCookTorrance(vec3 R0,float roughness,vec3 ro,vec3 L, vec3 V,vec3 N,out vec3 ks){\n\t\n    vec3 col=vec3(0.);\n    //V is vector to eye\n    //float alpha=roughness*roughness;\n    float alpha=roughness;\n    float alpha2=alpha*alpha;\n    float VdotN=max(dot(V,N),0.);\n    if(true){\n    //if(interP.depth>=RAY_MAXDEPTH){\n        vec3 H=normalize(L+V);\n        float HdotN=max(dot(H,N),0.);\n       \t\n        float VdotH=max(dot(V,H),0.);\n    \t//vec3 F=F_Schlick(R0,VdotH);\n        vec3 F=F_SchlickRoughness(R0,VdotN,roughness);\n        float D=D_GGX(alpha2,H,N);\n        //float G=G_Smith(k,rd[i],V,N);\n        float G=G_GGX(alpha2,L,V,H,N);\n        float cosTheta=max(0.,dot(L,N));\n        ks+=F;\n       \tcol+=F*D*G/max(4.*VdotN,0.5);\n    }\n    \n    return col;\n}\n","name":"Common","description":"","type":"common"}]}