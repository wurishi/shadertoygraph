{"ver":"0.1","info":{"id":"Mlc3DN","date":"1469296274","viewed":373,"name":"Animated Pokeball","username":"Nesvi7","description":"I have been waiting for hours, but this pokemon doesn't want to be catched.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pokeball","pokemon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//By Nestor Vina\n\n// ray marching\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float HALFPI = 1.57079632;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 up = vec3(0.0,-1.0,0.0);\nvec3 right = vec3(1.0,0.0,0.0);\n\nvec3 sunDir = normalize(vec3(-1.0,-1.0,0));\n\n//Primitives\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderHorizontal( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )//Unused\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat grassFloor( vec3 p )\n{\n    \n\treturn p.y+(texture(iChannel0,p.xz*0.05).xyz+texture(iChannel0,p.xz*0.008).xyz).x*1.5;\n}\n\nfloat sdTrunkSphere( vec3 p, float s, float h){\n  return max(sdSphere(p,s),-sdBox(p+vec3(0,h,0),vec3(s*2.0)));\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec4 map( vec3 pos) {\n   \n    //FLOOR\n    float floorPlane = grassFloor(pos+vec3(0,10.0,0));\n     pos.y += 10.0;\n    \n    //BALL THINGS\n    //Bounce animation\n    float height = 30.0;\n    float totalDuration = 4.0;\n    float animDuration = 2.0;\n#if 0\n    float dontDoBegin = clamp((iTime-5.0)*10.0,0.0,1.0);\n#else\n    float dontDoBegin = 1.0;\n#endif\n    float timeAnimation1 = clamp(mod(iTime,totalDuration)/animDuration,0.0,1.0);\n    float timeAnimation2 = clamp(mod(iTime,totalDuration)/animDuration-1.0,0.0,1.0);\n    mat3 rot = rotationXY( vec2(0.5*HALFPI*(1.0-timeAnimation2)*sin( timeAnimation2*2.0*PI*3.0 )*dontDoBegin,PI*0.7));\n    \n    pos = pos * rot; \n    pos += up * 10.0;\n    pos += (up*rot)*timeAnimation1 * height * abs(sin( timeAnimation1*2.0*PI*3.0 ))*dontDoBegin;\n\n        \n    float theDist;\n    vec3 theColor;\n    \n    //Modify initial scale. Can't get this working for now, any help is welcome :D (The problem is that the ray reachs end)\n#if 1\n    float s = 1.0;\n#else\n    float s = clamp((iTime-3.0)*10.0,0.1,1.0);\n    pos = pos/s;\n#endif    \n    \n    float cone = sdCappedCylinderHorizontal(pos+vec3(10.0,0,0),vec2(3,1.0));\n    float topSemiSphere = max(sdTrunkSphere(pos,10.0,19.0),-cone);\n    float botSemiSphere = max(sdTrunkSphere(pos,10.0,-19.0),-cone);\n    float blackParts = sdSphere(pos,9.5);\n    float button = min(sdCappedCylinderHorizontal(pos+vec3(9.30,0,0),vec2(1.9,0.5)),\n                       sdCappedCylinderHorizontal(pos+vec3(9.7,0,0),vec2(1.0,0.5)));\n    \n    if(topSemiSphere > botSemiSphere && blackParts > botSemiSphere && button > botSemiSphere && floorPlane > botSemiSphere){        \n    \ttheDist = botSemiSphere;\n        theColor = vec3(1.0,1.0,1.0);        \n    }\n    else if( blackParts > topSemiSphere && button > topSemiSphere && floorPlane > topSemiSphere) {\n        theDist = topSemiSphere;\n        theColor = vec3(1.0,0.0,0.0);\n    }\n    else if( button > blackParts && floorPlane > blackParts){\n    \ttheDist = blackParts;\n        theColor = vec3(0.0,0.0,0.0);\n    }\n    else if( floorPlane > button ){\n     \ttheDist = button;\n        theColor = mix(vec3(0.8,0.8,0.8),vec3(1.0,0.3,0.3),clamp(sin(iTime*3.0)+1.0,0.0,1.0)*(dontDoBegin));\n    }\n    else{\n        theDist = floorPlane;\n        theColor = vec3(-2.0,0.3,0.8);\n    }\n    \n    return vec4(theDist*s,theColor);\n}\n\n// ray marching\nvec4 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec4 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist <= stop_threshold ) {\n\t\t\treturn vec4(depth,distResult.yzw);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec4(end,-1.0,-1.0,-1.0);\n\t\t}\n\t}\n\treturn vec4(end,-1.0,-1.0,-1.0);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nvec3 shading( vec3 v, vec3 n, vec3 eye, vec3 tintColor ) {\n    vec3 albedo = tintColor*0.5;\t    \n    vec3 viewDir = normalize(v-eye);    \n    vec3 reflectionVector = reflect(viewDir,n);\n    vec3 reflectionColor = texture(iChannel3,reflectionVector).xyz;    \n    vec3 fresnelColor = vec3(0.7,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    float diffuse = dot(sunDir,-n)*0.3;\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    float specular = pow(clamp(dot(reflectionVector,-sunDir),0.0,1.0),6.0);\n    return albedo+diffuse+ambient+reflectionColor*0.05+specular;\n}\n\nfloat shadowCast( vec3 origin, vec3 dir, float start, float end ){\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec4 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist <= stop_threshold ) \n\t\t\treturn 0.0;\n\t\tdepth += dist;\n\t\tif ( depth >= end) return 1.0;\n\t}\n\treturn 1.0;\n}\n\nvec3 floorShading( vec3 v, vec3 n, vec3 eye ){  \n    vec3 tintColor = vec3(0.0,0.0,1.0);\n    vec3 albedo = tintColor*clamp((sin(length(v))+1.0)*0.5,0.4,1.0)*0.33;\n    albedo += tintColor*clamp(abs(0.0-v.x),0.0,1.0)*0.33;\n    albedo += tintColor*clamp(abs(0.0-v.z),0.0,1.0)*0.33;\n    albedo = (texture(iChannel0,v.xz*0.05).xyz+texture(iChannel0,v.xz*0.008).xyz)*0.5 * vec3(0.2,0.8,0.2) ;\n    vec3 normal = texture(iChannel1,v.xz*0.05).xyz;\n    \n    vec3 ambient = vec3(0.0);\n    vec3 lightColor = vec3(0.2,0.2,0.2);\n    float shadow = shadowCast(v,-sunDir,0.5,100.0);\n    return albedo*dot(-sunDir,normal) + shadow*lightColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 1.0, 98.0);// 38.0+clamp(iTime-6.0,0.0,1.0 )*60.0);\n    \n\t// rotate camera\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tmat3 rot = rotationXY( vec2(-0.45+clamp(mo.y,0.0,0.5),sin(iTime)*0.5+HALFPI*0.4+(mo.x-0.5)*10.0-HALFPI));//vec2(-0.2*sin(iTime), iTime/2.0 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n    vec3 fogColor = vec3(0.3,0.6,1.0);\n    vec4 rayResult = ray_marching( eye, dir, 0.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n        fragColor = vec4(fogColor,1.0);//vec4(texture(iChannel3,-dir).xyz,1.0);\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n   \n    \n    if( rayResult.y == -2.0)        \n    \tfragColor = vec4(floorShading( pos, n, eye ),1.0);\n    else\n    \tfragColor = vec4(shading( pos, n, eye, rayResult.yzw ),1.0);\n    //Fog\n    fragColor = vec4(mix( fragColor.xyz,fogColor, clamp((depth-300.0)*0.006,0.0,1.0)),1.0);\n}","name":"Image","description":"","type":"image"}]}