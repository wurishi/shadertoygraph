{"ver":"0.1","info":{"id":"ltlBWX","date":"1513771865","viewed":211,"name":"JPG (de)compressor II","username":"Ultraviolet","description":"Remake of [url=https://www.shadertoy.com/view/XtffDj]JPG (de)compressor[/url].\nHere the spectrum is stored non-locally, which allows to better visualise it (press space to toggle the reconstruction).\nUse the mouse for controlling spectrum.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(texelFetch(iChannel2, ivec2(32, 2), 0).r < 0.5)\n    \tfragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    else\n    \tfragColor = texture(iChannel3, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/// This is the input to the pipeline, you may put anything here\n\n\n#define N\t8.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = floor(iResolution.xy/N)*N;\n    \n    if(any(greaterThan(fragCoord, res)))\n    {\n        fragColor =vec4(0.);\n        return;\n    }\n    \n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    //fragColor = vec4(length((fragCoord/iResolution.xy - .5)*vec2(iResolution.x/iResolution.y, 1.0)) < 0.3 ? 1.0 : 0.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n/// This is the discrete cosine transform step, where 8x8 blocs are converted into frequency space\n/// Nice ref: https://unix4lyfe.org/dct/\n\n\n#define PI    3.1415972\n//#define SQRT2 0.70710678118\n#define SQRT2 0.25\n#define N\t8.\n\n\nfloat DCTcoeff(vec2 k, vec2 x)\n{\n    return cos(PI*k.x*x.x)*cos(PI*k.y*x.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = floor(iResolution.xy/N)*N;\n    \n    if(any(greaterThan(fragCoord, res)))\n    {\n        fragColor =vec4(0.);\n        return;\n    }\n    \n    vec2 k = floor(fragCoord/res*8.);\n    vec2 K = mod(floor(fragCoord) * 8., res);\n    \n    vec3 val = vec3(0.);\n    \n    for(int x=0; x<8; ++x)\n    \tfor(int y=0; y<8; ++y)\n        {\n            val += (texture(iChannel0, (K+vec2(x,y)+.5)/iResolution.xy).rgb) * DCTcoeff(k, (vec2(x,y)+0.5)/8.) * (k.x<.5?SQRT2:1.) * (k.y<.5?SQRT2:1.);\n        }\n    \n    fragColor=vec4(val/4.,0.);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n/// This is the Quantification step, where frequency values are discretized.\n/// This is where the lossy compression happens: this step is non invertible\n\n\n/// You may change the number of level to achieve different effects\n\n#define N\t8.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = floor(iResolution.xy/N)*N;\n    \n    if(any(greaterThan(fragCoord, res)))\n    {\n        fragColor =vec4(0.);\n        return;\n    }\n \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    //fragColor = vec4(1.0);\n    \n    \n\tfloat NB_LEVELS = (1.+99.*iMouse.y/iResolution.y);\n    \n    //*\n    if(length(iMouse.xy) < 2.)\n    {\n        //NB_LEVELS = 100.*(.5+.5*cos(iTime));\n        NB_LEVELS = 50.;\n    }\n\t//*/\n    \n    \n    if(texelFetch(iChannel2, ivec2(65, 0), 0).x<0.5)\n        // this assumes data between 0 and 1.\n        //fragColor = round(fragColor/8.*NB_LEVELS)*8./NB_LEVELS;\n        fragColor = round(fragColor*NB_LEVELS)/NB_LEVELS;\n    \n    \n    vec2 K = floor(fragCoord/res*8.) * res / 8.;\n    //    if(any(greaterThan(K,iMouse.xy)))\n    //        fragColor = vec4(0.);\n\n    if(iMouse.z>0.5)\n    {\n        //if((K.x/res.x+K.y/res.y)/2. > iMouse.x/iResolution.x)\n        if(max(K.x/res.x, K.y/res.y) > iMouse.x/iResolution.x)\n            fragColor = vec4(0.);\n    }\n    //*\n    else if(length(iMouse.xy) < 2.)\n    {\n        if(max(K.x/res.x, K.y/res.y) > min(mod(iTime, 2.0), 2.0-mod(iTime, 2.0)))\n            fragColor = vec4(0.);\n    }\n\t//*/\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n/// This is the reconstruction step, where each 8x8 bloc is converted back to the spatial domain\n\n\n#define PI 3.1415972\n//#define SQRT2 0.70710678118\n#define SQRT2 2.\n#define N\t8.\n\nfloat DCTcoeff(vec2 k, vec2 x)\n{\n    return cos(PI*k.x*x.x)*cos(PI*k.y*x.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = floor(iResolution.xy/N)*N;\n    \n    if(any(greaterThan(fragCoord, res)))\n    {\n        fragColor =vec4(0.);\n        return;\n    }\n    \n    \n    // coordinate in the 8x8 block\n    vec2 k = mod(floor(fragCoord), N);\n    \n    // coordinate of the 8x8 block\n    vec2 K = floor(fragCoord) - k;\n    \n    \n    vec3 val = vec3(0.);\n    for(int u=0; u<8; ++u)\n    \tfor(int v=0; v<8; ++v)\n        {\n    \t\tvec2 uv = K/res.xy / N + vec2(u,v)/N + vec2(.5)/res.xy;    \n    \t\tuv *= res/iResolution.xy;\n            val += texture(iChannel0, uv).rgb * DCTcoeff(vec2(u,v), (k+.5)/8.) * (u==0?SQRT2:1.) * (v==0?SQRT2:1.);\n        }\n    \n    fragColor=vec4(val/4., 1.);\n}","name":"Buf D","description":"","type":"buffer"}]}