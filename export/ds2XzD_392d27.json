{"ver":"0.1","info":{"id":"ds2XzD","date":"1670146545","viewed":240,"name":"Tiny Town WFC","username":"fenix","description":"Another wave function collapse experiment, trying to portray a town, or maybe an endless resort?\n\n*mouse drag up/left: zoom out*\n*mouse drag down/right: re-center and zoom in*\n*shift+mouse drag: pan* \n*space to reset*\n*up/down to zoom*","likes":24,"published":3,"flags":48,"usePreview":1,"tags":["terrain","simulation","random","map","automata","tile","tiles","wfc","wavefunctioncollapse","roads"],"hasliked":0,"parentid":"DdfSzj","parentname":"Simple Wave Function Collapse"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another experiement with my interpretation of Wave Function Collapse.\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders:\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC                 https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//\n//  There have been a couple of significant simulation upgrades since the last one:\n//\n//  * Tiles are now marked by how they are symmetric, so that different orientations of\n//    the same tiles are not treated as unique tiles. Also useful for creating directional\n//    effects like the bridge supports.\n//\n//  * You can now specify that a tile cannot connect to itself. This is useful for keeping\n//    lake corners from forming lots of tiny islands, and building corners from making wee\n//    buildings. Also keeps roads from being excessively wiggly.\n//\n//  I'm aware that this takes ages to fully converge, and I hope you will excuse me for\n//  that. My excuse is that enough of the map is finished to give you something to look\n//  at while construction is finished on the harder areas. Some of the situations, like\n//  long bridges meeting in the middle of a lake, are pretty tricky to resolve. In this\n//  case sometimes it comes up a solution that I didn't expect, so I'd almost consider it\n//  \"novel\"...it makes an island.\n//\n//  The entire buffer is simulated, so you're only looking at the center 1/64th of the\n//  buffer when the shader boots, chosen so that the 8x8 tile pixels are 1:1 with screen\n//  pixels. Click and drag the mouse up/left to zoom out.\n//\n//  The tiles are defined in the Common tab, and are designed to be easy to change. Forks\n//  of this shader are welcome if you draw your own tiles and make something intereting\n//  and new out of it. But please post a comment here so I don't miss it!\n//\n//  The rendering was probably harder to get working than the simulation, because I\n//  wanted to be able to zoom out and watch the simulation from farther away. My first\n//  attempt had horrible aliasing artifacts so I had to add this box clipping system.\n//\n//  I'm curious if the mouse camera controls are effective or not for other people. Once\n//  you get used to it, it's handy for zooming in on specific details, I think.\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\n// compute the overlapping area between two axis aligned boxes\nfloat boxClip(vec4 a, vec4 b)\n{\n    vec4 i = vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n    vec2 e = i.zw - i.xy;\n    return any(lessThanEqual(e, vec2(0))) ? 0. : e.x * e.y;\n}\n\n// rotate a pixel index\nivec2 rotIdx(ivec2 v, int r)\n{\n    if (r == 0) return ivec2(v.x, 8 - v.y);\n    if (r == 1) return v.yx;\n    if (r == 2) return ivec2(8 - v.x, v.y);\n    if (r == 3) return 8 - v.yx;\n}\n\n#define GET_SUBTILE(T, U) ((TILES[T].image[U.y] >> ((8 - U.x) * 3)) % 8u)\n\n// compute the color contribution of a single tile, clipped to the screen pixel\nvec3 tileClip(int type, int rot, vec4 clipBox, bool parity)\n{\n    vec3 sum = vec3(0);\n    for (ivec2 v = ivec2(0); v.x < 9; ++v.x)\n    for (v.y = 0; v.y < 9; ++v.y)\n    {\n        uint value = GET_SUBTILE(type, rotIdx(v, rot));\n        sum += subtileColor(value, parity ^^ ((v.x + v.y) & 1) == 0) * boxClip(clipBox, vec4(vec2(v) / 9., (vec2(v) + 1.) / 9.));\n    }\n    return sum;// * vec3(float(rot + 1) * .25);\n}\n\n// From FabriceNeyret2's  iResolution, iMouse, iDate, etc  https://www.shadertoy.com/view/llySRh\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug with an old driver\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n\nvec3 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .4 )\n        v += char(p, 48+ i%10 );\n    return v.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n\n    fragCoord -= .5 * iResolution.xy;\n    fragCoord *= state.zoom;\n    fragCoord += state.center * iResolution.y;\n    fragCoord += .5 * iResolution.xy;\n    \n    // compute the tile address and coordinates within the tile for the lower left and upper right corners of the pixel\n    vec2 llc = fragCoord - .5 * state.zoom;\n    ivec2 llt = ivec2(llc);\n    llc = fract(llc);\n    vec2 urc = fragCoord + .5 * state.zoom;\n    ivec2 urt = ivec2(urc);\n    urc = fract(urc);\n    \n    vec3 sum = vec3(0);\n    \n    // loop over all the tiles, clipping as we go\n    for (ivec2 tile = llt; tile.x <= urt.x; ++tile.x)\n    for (tile.y = llt.y; tile.y <= urt.y; ++tile.y)\n    {\n        if (all(greaterThan(tile, ivec2(0))) && all(lessThan(tile, ivec2(iResolution.xy))))\n        {\n            vec4 v = texelFetch(iChannel0, tile, 0);\n            int type = int(v.x);\n            int rot = int(v.y);\n\n            vec4 clipBox = vec4(0, 0, 1, 1);\n\n            // clip one or more sides if necessary\n            if (tile.x == llt.x) clipBox.x = llc.x;\n            if (tile.y == llt.y) clipBox.y = llc.y;\n            if (tile.x == urt.x) clipBox.z = urc.x;\n            if (tile.y == urt.y) clipBox.w = urc.y;\n\n            sum += tileClip(type, rot, clipBox, ((tile.x + tile.y) & 1) != 0);\n            \n            // debug draw tile values\n            //sum = max(sum, pInt(llc*4. - vec2(.3, 0), v.x));\n        }\n    }\n    \n    fragColor = sqrt(vec4(sum / (state.zoom * state.zoom), 1));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nvec3 subtileColor(uint value, bool parity)\n{\n    if (value == 0u) return vec3(0);\n    if (value == 1u) return vec3(.05,.3,0);\n    if (value == 2u) return vec3(.3);\n    if (value == 3u) return parity ? vec3(.7,.6,0) : vec3(.3);\n    if (value == 4u) return vec3(.1,.4,1.);\n    if (value == 5u) return parity ? vec3(.5,.1,.1) : vec3(.3,.1,.1);\n    if (value == 6u) return parity ? vec3(.05,.1,0) : vec3(.0,.2,.0);\n    if (value == 7u) return vec3(.7,.6,0);\n    return vec3(1,0,1);\n}\n\n// symmetry types\n#define S_X 0x1\n#define S_I 0x3\n#define S_L 0xf\n\nstruct Tile\n{\n    mat3 shape; // defines how this tile matches to neighbors\n    float prob; // lower numbers will cause this tile to be chosen less often\n    int sym; // symmetry type\n    bool selfConnect; // can connect to self\n    uint image[9]; // 8-color octal array defining how to render the tile, referencing the above colors\n};\n\nconst Tile T_EMPTY =\n    Tile(mat3(0, 0, 0,\n              0, 0, 0,\n              0, 0, 0),\n         .5,\n         S_X, true,\n         uint[](0222272222u,\n                0222272222u,\n                0222707222u,\n                0222707222u,\n                0227777722u,\n                0227707722u,\n                0277777772u,\n                0222222222u,\n                0222222222u));\n         \nconst Tile T_GRASS =\n    Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         1.,\n         S_X, true,\n         uint[](0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u));\n                \nconst Tile T_ROAD_STRAIGHT =\n    Tile(mat3(1, 2, 1,\n              1, 2, 1,\n              1, 2, 1),\n         .2,\n         S_I, true,\n         uint[](0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u));\n                \nconst Tile T_ROAD_TURN =\n    Tile(mat3(1, 1, 1,\n              1, 2, 2,\n              1, 2, 1),\n         .01,\n         S_L, false,\n         uint[](0111111111u,\n                0111222222u,\n                0112222222u,\n                0122222222u,\n                0122233333u,\n                0122232222u,\n                0122232222u,\n                0122232222u,\n                0122232221u));\n                \nconst Tile T_ROAD_T =\n    Tile(mat3(1, 1, 1,\n              2, 2, 2,\n              1, 2, 1),\n         .01,\n         S_I, false,\n         uint[](0111111111u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0333333333u,\n                0222232222u,\n                0222232222u,\n                0222232222u,\n                0122232221u));\n                \nconst Tile T_ROAD_X =\n    Tile(mat3(1, 2, 1,\n              2, 2, 2,\n              1, 2, 1),\n         .01,\n         S_I, false,\n         uint[](0122232221u,\n                0222232222u,\n                0222232222u,\n                0222232222u,\n                0333333333u,\n                0222232222u,\n                0222232222u,\n                0222232222u,\n                0122232221u));\n                \nconst Tile T_REDB =\n    Tile(mat3(5, 5, 5,\n              5, 5, 5,\n              5, 5, 5),\n         .06,\n         S_X, true,\n         uint[](0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u));\n\nconst Tile T_REDB_EDGE =\n    Tile(mat3(1, 5, 5,\n              1, 5, 5,\n              1, 5, 5),\n         .03,\n         S_L, true,\n         uint[](0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u));\n\nconst Tile T_REDB_CORNER =\n    Tile(mat3(1, 1, 1,\n              1, 5, 5,\n              1, 5, 5),\n         .03,\n         S_L, false,\n         uint[](0111111111u,\n                0111111111u,\n                0111111111u,\n                0111222222u,\n                0111222222u,\n                0111220000u,\n                0111220555u,\n                0111220555u,\n                0111220555u));\n\nconst Tile T_REDB_ICORNER =\n    Tile(mat3(5, 5, 5,\n              5, 5, 5,\n              5, 5, 1),\n         .03,\n         S_L, true,\n         uint[](05555555555u,\n                05555555555u,\n                05555555555u,\n                05555000000u,\n                05555055555u,\n                05555051111u,\n                05555051111u,\n                05555051111u,\n                05555051111u));\n\nconst Tile T_REDB_ENTR =\n    Tile(mat3(1, 5, 5,\n              2, 5, 5,\n              1, 5, 5),\n         .0,\n         S_L, false,\n         uint[](0111220005u,\n                0222222220u,\n                0222222220u,\n                0222222220u,\n                0333333330u,\n                0222222220u,\n                0222222220u,\n                0222222220u,\n                0111220005u));\n\nconst Tile T_REDB_T_ENTR_A =\n    Tile(mat3(1, 5, 5,\n              3, 5, 5,\n              1, 5, 5),\n         .0,\n         S_L, false,\n         uint[](0141410555u,\n                0000000000u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0000000000u,\n                0141410555u));\n\nconst Tile T_REDB_T_ENTR_B =\n    Tile(mat3(1, 5, 5,\n              4, 5, 5,\n              1, 5, 5),\n         .0,\n         S_L, false,\n         uint[](0141410555u,\n                0000000000u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0000000000u,\n                0141410555u));\n\nconst Tile T_TREE =\n    Tile(mat3(1, 1, 1,\n              1, 6, 6,\n              1, 6, 6),\n         .1,\n         S_L, true,\n         uint[](0111111111u,\n                0111111116u,\n                0111111611u,\n                0111166666u,\n                0111666666u,\n                0116166666u,\n                0161666666u,\n                0116666666u,\n                0166666666u));\n\nconst Tile T_PARK_ENTR =\n    Tile(mat3(1, 2, 1,\n              8, 7, 1,\n              10, 7, 10),\n         .1,\n         S_L, false,\n         uint[](0122232221u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u));\n\nconst Tile T_PARK_END =\n    Tile(mat3(1, 1, 1,\n              8, 7, 1,\n              10, 7, 10),\n         .0,\n         S_L, false,\n         uint[](01111111111u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u));\n\nconst Tile T_PARK_CORN =\n    Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              10, 9, 1),\n         .0,\n         S_L, false,\n         uint[](0111111111u,\n                0277777777u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0277777777u));\n\nconst Tile T_PARK_AISLE_A =\n    Tile(mat3(10, 7, 10,\n              9, 7, 8,\n              1, 9, 1),\n         .3,\n         S_L, false,\n         uint[](0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u));\n\nconst Tile T_PARK_AISLE_B =\n    Tile(mat3(1, 9, 1,\n              8, 7, 9,\n              10, 7, 10),\n         .3,\n         S_L, false,\n         uint[](0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u));\n\nconst Tile T_PARK_SPOT_A =\n    Tile(mat3(1, 8, 10,\n              1, 8, 9,\n              1, 1, 1),\n         0.,\n         S_L, false,\n         uint[](0222222222u,\n                0722222277u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u));\n                \nconst Tile T_PARK_SPOT_B =\n    Tile(mat3(10, 9, 1,\n              9, 8, 1,\n              1, 1, 1),\n         0.,\n         S_L, false,\n         uint[](0222222222u,\n                0722222277u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u));\n\nconst float LAKE_PROB = .02;\nconst Tile T_LAKE =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .3,\n         S_X, true,\n         uint[](0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u));\n\nconst Tile T_LAKE_EDGE =\n    Tile(mat3(1, 1, 1,\n              3, 3, 3,\n              3, 3, 3),\n         LAKE_PROB,\n         S_L, true,\n         uint[](0111111111u,\n                0111111111u,\n                0111117777u,\n                0711177777u,\n                0777774444u,\n                0477744444u,\n                0444444444u,\n                0444444444u,\n                0444444444u));\n\nconst Tile T_LAKE_CORNER =\n    Tile(mat3(1, 1, 1,\n              1, 3, 3,\n              1, 3, 3),\n         LAKE_PROB,\n         S_L, false,\n         uint[](0111111111u,\n                0111117711u,\n                0111777777u,\n                0117744477u,\n                0177444444u,\n                0177444444u,\n                0177444444u,\n                0177444444u,\n                0117744444u));\n\nconst Tile T_LAKE_ICORNER =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 1),\n         LAKE_PROB,\n         S_L, false,\n         uint[](0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444447u,\n                0444444477u,\n                0444444771u,\n                0444447711u));\n\nconst Tile T_BRIDGE =\n    Tile(mat3(3, 2, 3,\n              3, 2, 3,\n              3, 2, 3),\n         LAKE_PROB,\n         S_I, true,\n         uint[](0002232244u,\n                0442232244u,\n                0442232244u,\n                0002232244u,\n                0442232244u,\n                0442232244u,\n                0002232244u,\n                0442232244u,\n                0442232244u));\n\nconst Tile T_BRIDGE_ENTR =\n    Tile(mat3(3, 2, 3,\n              3, 2, 3,\n              1, 2, 1),\n         .001,\n         S_L, false,\n         uint[](0442232244u,\n                0442232244u,\n                0442232244u,\n                0442232244u,\n                0772232277u,\n                0722232227u,\n                0122232221u,\n                0122232221u,\n                0122232221u));\n\nconst int NUM_TILES = 23;\n\nconst Tile[NUM_TILES] TILES = Tile[](\n    T_EMPTY,\n    T_GRASS,\n    T_ROAD_STRAIGHT,\n    T_ROAD_TURN,\n    T_ROAD_T,\n    T_ROAD_X,\n    T_REDB,\n    T_REDB_EDGE,\n    T_REDB_CORNER,\n    T_REDB_ENTR,\n    T_TREE,\n    T_PARK_ENTR,\n    T_PARK_CORN,\n    T_PARK_AISLE_A,\n    T_PARK_AISLE_B,\n    T_PARK_SPOT_A,\n    T_PARK_SPOT_B,\n    T_LAKE,\n    T_LAKE_EDGE,\n    T_LAKE_CORNER,\n    T_LAKE_ICORNER,\n    T_BRIDGE,\n    T_BRIDGE_ENTR\n);\n\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    float resolution;\n    float zoom;\n    float oldZoom;\n    vec2 center;\n    vec2 oldCenter;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.zoom = data0.y;\n    state.oldZoom = data0.z;\n    state.attract = data0.w != 0.;\n    state.center = data1.xy;\n    state.oldCenter = data1.zw;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.zoom, state.oldZoom, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.center, state.oldCenter);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n// The room where it happens.\n// ---------------------------------------------------------------------------------------\n\nint g_NumValidTiles;\nconst int MAX_VALID_TILES = NUM_TILES * 4;\nint g_ValidTiles[MAX_VALID_TILES];\nint g_ValidTileRs[MAX_VALID_TILES];\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// find the full array of tiles that could be compatible with a particular tile already placed\nvoid findValidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        if (TILES[i].selfConnect == false && int(n.x) == i) continue;\n        \n        mat3 myShape = TILES[i].shape;\n        for (int d = 0; d < 4; ++d)\n        {\n            if ((TILES[i].sym & (1 << ((d + 4 - r) % 4))) != 0 && tilesMatch(rotShape(myShape, d), nShape))\n            {\n                g_ValidTiles[g_NumValidTiles] = i;\n                g_ValidTileRs[g_NumValidTiles] = (d + 4 - r) % 4;\n                g_NumValidTiles++;\n            }\n        }\n    }\n}\n\n// remove any tiles from the array that do not match the particular tile already placed\nvoid removeInvalidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n\n    for (int i = 0; i < g_NumValidTiles; ++i)\n    {\n        mat3 myShape = rotShape(TILES[g_ValidTiles[i]].shape, g_ValidTileRs[i] + r);\n        if (TILES[g_ValidTiles[i]].selfConnect == false && int(n.x) == g_ValidTiles[i]\n            || !tilesMatch(myShape, nShape))\n        {\n            g_ValidTiles[i] = g_ValidTiles[g_NumValidTiles - 1];\n            g_ValidTileRs[i] = g_ValidTileRs[g_NumValidTiles - 1];\n            g_NumValidTiles--;\n            i--;\n        }        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // reset\n        fragColor = vec4(0);\n        \n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update in an alternating checkerboard pattern, so no tile is updating on the same tick as any neighbor\n    if (((ifc.x + ifc.y) & 1) == (iFrame & 1)) return;\n\n    vec4 ns[4] = vec4[]( texelFetch(iChannel0, ifc + ivec2(0, 1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(1, 0), 0),\n                         texelFetch(iChannel0, ifc + ivec2(0, -1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(-1, 0), 0) );\n\n    vec3 h = hash3(uvec3(fragCoord, iFrame));\n\n    // reset when requested by neighbor that can't find a solution\n    if (ns[0].z > 0. || ns[1].z > 0. || ns[2].z > 0. || ns[3].z > 0. || fragColor.z > 0.)\n    {\n        if (h.x > .5)\n        {\n            fragColor.x = 0.;\n            fragColor.y = 0.;\n            fragColor.z = max(0., max(max(max(max(fragColor.z, ns[0].z), ns[1].z), ns[2].z), ns[3].z) - 1.);\n        }\n        return;\n    }\n    \n    // empty cells with no neighbors have a chance to spontaneously collapse\n    if (fragColor.x == 0. && ns[0].x == 0. && ns[1].x == 0. && ns[2].x == 0. && ns[3].x == 0.)\n    {\n       if (h.x < 1e-5)\n        {\n            fragColor.x = floor(h.y * float(NUM_TILES));\n            fragColor.y = floor(h.y * 4.);\n            fragColor.z = 0.;\n        }\n        return;\n    }\n    \n    if (fragColor.x == 0.)\n    {\n        // we're empty but one of our neighbors is not, look for a value for ourselves\n        g_NumValidTiles = 0;\n        bool noSolution = false;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (ns[d].x != 0.)\n            {\n                if (g_NumValidTiles == 0)\n                {\n                    // whichever direction is first non-empty will find all its valid tiles\n                    findValidTiles(ns[d], d);\n                }\n                else\n                {\n                    // every other direction then gets a chance to remove invalid options\n                    removeInvalidTiles(ns[d], d);\n                    if (noSolution = g_NumValidTiles == 0) break;\n                }\n            }\n        }\n\n        if (noSolution)\n        {\n            // if we're stuck, ask our neighbors to revert\n            fragColor.z = fragColor.z + 1.1;\n        }\n        else if (g_NumValidTiles > 0)\n        {\n            vec3 h = hash3(uvec3(fragCoord, iFrame));\n            int choice = int(h.y * float(g_NumValidTiles));\n            \n            // last chance rejection by probability, just try again next frame\n            if (g_NumValidTiles == 1 || h.z < TILES[g_ValidTiles[choice]].prob)\n            {\n                // install the chosen valid tile\n                fragColor.x = float(g_ValidTiles[choice]);\n                fragColor.y = float(g_ValidTileRs[choice]);\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.zoom = 1./8.;\n        state.oldZoom = 1./8.;\n        state.center = vec2(0);\n        state.oldCenter = vec2(0);\n        state.attract = true;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0. && iMouse.w < 0.)\n        {\n            state.attract = false;\n            if (keyDown(KEY_SHIFT))\n            {\n                vec2 delta = state.zoom * (iMouse.zw * vec2(1, -1) - iMouse.xy) / iResolution.y;\n                state.center = state.oldCenter + delta;\n            }\n            else\n            {\n                float mouseZoom = (iMouse.y + iMouse.w + iMouse.z - iMouse.x) / iResolution.y;\n                state.zoom = state.oldZoom * pow(2., 4. * mouseZoom);\n                if (mouseZoom < 0.)\n                {\n                    vec2 mouseCenter = (vec2(iMouse.z, -iMouse.w) - .5 * iResolution.xy) / iResolution.y;\n                    mouseCenter *= state.oldZoom;\n                    mouseCenter += state.oldCenter;\n                    state.center = mix(state.oldCenter, mouseCenter, min(1.,-5.*mouseZoom));\n                }\n            }\n        }\n        else\n        {\n            if (keyDown(KEY_UP))\n            {\n                state.zoom *= .9;\n            }\n            else if (keyDown(KEY_DOWN))\n            {\n                state.zoom *= 1.1;\n            }\n            \n            state.oldZoom = state.zoom;\n            state.oldCenter = state.center;\n        }\n        \n        if (state.attract)\n        {\n            state.center = .42*vec2(sin(iTime*.02), cos(iTime*.02));\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}","name":"Buffer B","description":"","type":"buffer"}]}