{"ver":"0.1","info":{"id":"XccfWn","date":"1732899801","viewed":52,"name":"Twisted cubes","username":"torrings","description":"A shape morphing between a cube and a ball, twisting. Repeated. Foggy. Glowing.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sceneSDF(vec3 p) {\n    // EFFECT 1: Rotate space over time\n    float rotation = iTime * 0.5;\n    p.xz *= mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n    \n    // EFFECT 2: Infinite repetition\n    vec3 rep = vec3(4.0);\n    vec3 id = round(p/rep);\n    p = mod(p + 0.5*rep, rep) - 0.5*rep;\n    \n    // EFFECT 3: Twist based on height\n    float twist = p.y * 2.0;\n    p.xz *= mat2(cos(twist), -sin(twist), sin(twist), cos(twist));\n    \n    // EFFECT 4: Shape morphing over time\n    float morph = sin(iTime) * 0.5 + 0.5;\n    float box = length(max(abs(p) - vec3(0.5), 0.0));\n    float sphere = length(p) - 0.7;\n    float d = mix(box, sphere, morph);\n    \n    // EFFECT 5: Add shells\n    d = abs(d) - 0.1;\n    d = abs(d) - 0.05;\n    \n    return d;\n}\n\nfloat glow = 0.0; // Global for accumulating glow\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    glow = 0.0;\n    \n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * d;\n        float dist = sceneSDF(p);\n        \n        // EFFECT 6: Accumulate glow based on how close we are to surface\n        glow += 0.1/(1.0 + dist * dist * 20.0);\n        \n        if(dist < 0.001) return d;\n        if(d > 20.0) break;\n        d += dist * 0.5;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Orbit camera\n    float time = iTime * 0.5;\n    vec3 ro = vec3(3.0 * sin(time), 2.0 * sin(time * 0.5), 3.0 * cos(time));\n    vec3 lookAt = vec3(0.0);\n    \n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + right * uv.x + up * uv.y);\n    \n    float d = raymarch(ro, rd);\n    vec3 color = vec3(0.0);\n    \n     \n    // EFFECT 8: Add accumulated glow\n    color += vec3(0.2, 0.4, 1.0) * glow;\n    \n    // EFFECT 9: Color grading\n    color = mix(color, color * vec3(1.0, 0.8, 0.7), 0.3);\n    color = pow(color, vec3(0.4545)); // Gamma\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}