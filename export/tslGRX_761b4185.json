{"ver":"0.1","info":{"id":"tslGRX","date":"1547081081","viewed":2175,"name":"RayCraft","username":"jolle","description":"Voxel terrain from noise, imitating minecraft style.\n\nCan use mouse position to look around.\n\nCurrently walks all the voxels, not variable step, so room for improvements. Also some precision issues.\n\nUpdated to use more concise trace step and ao sampling.","likes":56,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","terrain","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MULTISAMPLES 1 // Max 4\n\nconst float pi = 3.1415926536;\nconst float fov = 2.2;\nconst float cloud_height = 18.0;\nconst float threshold = 0.5;\nconst float clouds_threshold = 0.525;\nconst float sun_movement = 0.1;\nconst vec3 eye_movement = vec3(-4.0, 0.0, -1.0);\nconst vec3 cloud_movement = vec3(-1.0, 0.0, -1.5);\nconst vec3 eye_start = vec3(-40.0, 10.0, 20.0);\n\nvec3 sun_dir;\nvec3 eye;\nvec3 clouds_offset;\n\nfloat sq(float x) { return x * x; }\nfloat sq(vec2 x) { return dot(x, x); }\nfloat sqi(float x) { return 1.0 - sq(1.0 - x); }\nfloat sqi(vec2 x) { return 1.0 - sq(1.0 - x); }\n\nvec3 background(vec3 d)\n{\n\tconst float sun_intensity = 1.0;\n    vec3 sun = (pow(max(0.0, dot(d, sun_dir)), 48.0) + pow(max(0.0, dot(d, sun_dir)), 4.0) * 0.25) * sun_intensity * vec3(1.0, 0.85, 0.5);\n    vec3 sky = mix(vec3(0.6, 0.65, 0.8), vec3(0.15, 0.25, 0.65), d.y) * 1.15;\n    return sun + sky;\n}\n\nfloat noise(vec3 p)\n{\n    return textureLod(iChannel1, p, 0.0).x;\n}\n\nfloat cnoise(vec3 p)\n{\n    vec3 size = 1.0 / vec3(textureSize(iChannel1, 0));\n    return (\n        noise(p * size * 1.0 + vec3(0.52, 0.78, 0.43)) * 0.5 + \n        noise(p * size * 2.0 + vec3(0.33, 0.30, 0.76)) * 0.25 + \n        noise(p * size * 4.0 + vec3(0.70, 0.25, 0.92)) * 0.125) * 1.14;\n}\n\nbool voxel(vec3 vp)\n{\n    if (vp.y < cloud_height - 2.0)\n        return cnoise(vp * 0.05) + vp.y * -0.02 > threshold; \n    return false;\n}\n\nbool cloudVoxel(vec3 vp)\n{\n    if (vp.y == cloud_height)\n        return cnoise(vp * 0.2) > clouds_threshold;\n        //return cnoise(vec3(vp.xz * 0.2, floor(iTime * 5.0) * 0.01)) > clouds_threshold; // Animated clouds, somewhat distracting\n    return false;\n}\n\nstruct TraceResult\n{\n    vec3 vp;\n    vec3 p;\n    vec3 n;\n    float r;\n    bool hit;\n};\n\nTraceResult traceVoxel(vec3 p, vec3 d, float dist)\n{\n    TraceResult r;\n    r.hit = false;\n    r.n = -d;\n    r.r = dist;\n\n    vec3 id = 1.0 / d;\n    vec3 sd = sign(d);\n    vec3 nd = max(-sd, 0.0);\n    vec3 vp = floor(p) - nd * vec3(equal(floor(p), p));\n\n    for (int i = 0; i < 128; ++i)\n    {\n        if (dist <= 0.0 || p.y > cloud_height && d.y > 0.0)\n        \tbreak;\n\n        if (voxel(vp))\n        {\n\t\t\tr.vp = vp;\n\t\t\tr.p = p;\n\t\t\tr.r = dist;\n\t\t\tr.hit = true;\n\t\t\treturn r;\n        }\n\n        vec3 n = mix(floor(p + 1.0), ceil(p - 1.0), nd);\n\t\tvec3 ls = (n - p) * id;\n\t\tfloat l = min(min(ls.x, ls.y), ls.z);\n\t\tvec3 a = vec3(equal(vec3(l), ls));\n\n        p = mix(p + d * l, n, a);\n        vp += sd * a;\n        r.n = -sd * a;\n        dist -= l;\n    }\n\n    return r;\n}\n\nTraceResult traceClouds(vec3 p, vec3 d, float dist)\n{\n    TraceResult r;\n    r.hit = false;\n    r.n = -d;\n    r.r = dist;\n    \n    p += clouds_offset;\n    \n    if (p.y < cloud_height && d.y > 0.0)\n    {\n        float c = (cloud_height - p.y) / d.y;\n        p += d * c;\n        r.n = vec3(0.0, -1.0, 0.0);        \n        dist -= c;\n    }\n    else if (p.y > cloud_height + 1.0 && d.y < 0.0)\n    {\n        float c = (cloud_height + 1.0 - p.y) / d.y;\n        p += d * c;\n        r.n = vec3(0.0, 1.0, 0.0);\n        dist -= c;\n    }\n\n    vec3 id = 1.0 / d;\n    vec3 sd = sign(d);\n    vec3 nd = max(-sd, 0.0);\n    vec3 vp = floor(p) - nd * vec3(equal(floor(p), p));\n\n    for (int i = 0; i < 16; ++i)\n    {\n        if (dist <= 0.0 || p.y < cloud_height && d.y < 0.0 || p.y > cloud_height + 1.0 && d.y > 0.0)\n\t        break;\n\n        if (cloudVoxel(vp))\n        {\n\t\t\tr.vp = vp;\n\t\t\tr.p = p - clouds_offset;\n\t\t\tr.r = dist;\n\t\t\tr.hit = true;\n\t\t\treturn r;\n        }\n\n        vec3 n = mix(floor(p + 1.0), ceil(p - 1.0), nd);\n\t\tvec3 ls = (n - p) * id;\n\t\tfloat l = min(min(ls.x, ls.y), ls.z);\n\t\tvec3 a = vec3(equal(vec3(l), ls));\n\n        p = mix(p + d * l, n, a);\n        vp += sd * a;\n        r.n = -sd * a;\n        dist -= l;\n    }\n\n    return r;\n}\n\nfloat sample_ao(vec3 vp, vec3 p, vec3 n)\n{\n    const float s = 0.5;\n    const float i = 1.0 - s;\n    vec3 b = vp + n;\n    vec3 e0 = n.zxy;\n    vec3 e1 = n.yzx;\n    float a = 1.0;\n    if (voxel(b + e0))\n        a *= i + s * sqi(fract(dot(-e0, p)));\n    if (voxel(b - e0))\n        a *= i + s * sqi(fract(dot(e0, p)));\n    if (voxel(b + e1))\n        a *= i + s * sqi(fract(dot(-e1, p)));\n    if (voxel(b - e1))\n        a *= i + s * sqi(fract(dot(e1, p)));\n    if (voxel(b + e0 + e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((-e0 - e1) * p)))));\n    if (voxel(b + e0 - e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((-e0 + e1) * p)))));\n    if (voxel(b - e0 + e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((e0 - e1) * p)))));\n    if (voxel(b - e0 - e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((e0 + e1) * p)))));\n    return a;\n}\n\nvec3 ray(vec3 p, vec3 d)\n{\n    const vec3 grass_color = vec3(0.63, 1.0, 0.31);\n    const vec3 dirt_color = vec3(0.78, 0.56, 0.4);\n    const vec3 ambient_color = vec3(0.5, 0.5, 0.5);\n    const vec3 sun_color = vec3(0.5, 0.5, 0.5);\n    const float view_distance = 75.0;\n\n    TraceResult r = traceVoxel(p, d, view_distance);\n    TraceResult rc = traceClouds(p, d, view_distance);\n    if (rc.hit && (!r.hit || rc.r > r.r))\n        r = rc;\n    if (r.hit)\n    {\n        float sun_factor = max(0.0, dot(r.n, sun_dir));\n        \n        float fog_factor = min(1.0, sq(length(r.p - p) / view_distance));\n        vec3 fog_color = background(d);\n\n        if (r.vp.y == cloud_height)\n        {\n            vec3 c = 1.9 * ambient_color + sun_factor * sun_color;\n            return mix(c, fog_color, fog_factor * 0.6 + 0.4);\n        }\n\n        if (sun_factor > 0.0)\n        {\n        \tfloat sd = (cloud_height - r.p.y) / sun_dir.y;\n            if (traceVoxel(r.p, sun_dir, sd).hit)\n                sun_factor = 0.0;\n            else if (traceClouds(r.p, sun_dir, sd + 2.0).hit)\n                sun_factor *= 0.3;\n        }\n\n        float ambient_factor = sample_ao(r.vp, r.p, r.n);\n\n        float texel_noise = textureLod(iChannel0, r.p * 0.5, 0.0).r;\n\n\t\tfloat grass_mix = 0.0;\n        if (!voxel(r.vp + vec3(0, 1, 0)))\n        {\n            if (texel_noise * 4.0 + floor(fract(r.p.y) * 16.0) > 15.0)\n                grass_mix = 1.0;\n            else\n                grass_mix = max(0.0, r.n.y);\n        }\n\n        vec3 texel = vec3(texel_noise) * 0.3 + 0.7;\n        vec3 diffuse = texel * mix(dirt_color, grass_color, grass_mix);\n        vec3 c = diffuse * (ambient_factor * ambient_color + sun_factor * sun_color);\n\n        return mix(c, fog_color, fog_factor);\n    }\n    return background(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clouds_offset = cloud_movement * iTime;\n\n    vec2 sxz = cos(vec2(0.0, -pi * 0.5) - iTime * sun_movement);\n    sun_dir = normalize(vec3(sxz.x, 1.1, sxz.y));\n\n    eye = eye_start + vec3(0.01) + mod(eye_movement * iTime, 640.0);\n    TraceResult r = traceVoxel(vec3(eye.x, cloud_height, eye.z), vec3(0.0, -1.0, 0.0), cloud_height - eye.y);\n    if (r.hit)        \n    \teye.y = max(eye.y, r.p.y + 1.0);\n\n    float ry = iMouse.x / iResolution.x * pi * 2.0 + pi * 0.85;\n    float rx = -iMouse.y / iResolution.y * pi * 0.5 + pi * 0.95;\n\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n\n\tvec2 uv = fov * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));    \n    vec3 color = ray(eye, dir);\n#if MULTISAMPLES > 1\n    vec2 uvh = fov * vec2(0.5) / iResolution.x;\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left));\n#if MULTISAMPLES > 2\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up  + uv.x * left));\n#if MULTISAMPLES > 3\n    color += ray(eye, normalize(forward + uv.y * up + (uv.x + uvh.x) * left));\n#endif\n#endif\n    color /= float(MULTISAMPLES);\n#endif\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}