{"ver":"0.1","info":{"id":"tlScDR","date":"1594096288","viewed":142,"name":"Pole & Zero Contour Plot","username":"Mr_Mayhem","description":"A negative singularity is at the center of the screen, and the mouse has a positive singularity.  \nHills and valleys are colored green and red respectively. Click left mouse or tap.\nThis is my first shader; I came from years of using Processing.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["distancefields","fields","watershed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    float d1 = 0.0;     // distance to the mouse from each pixel\n    float d2 = 0.0; \t// distance to the center from each pixel\n    float dist = 0.0;   // combined d1 + d2 for each pixel\n\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 finalColor =  vec3(0.0, 1.0, 0.0);\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    \n    const float thick = 5.5;   // entire thickness\n    const float space = 0.05;  // space between slices\n    const float slice = 0.005; // slice thickness\n    \n    // Inverse distance from the pixel to the mouse.xy\n    d1 = 1.0/(1.0+(distance(uv,vec2(mousePos))));\n    // Inverse distance from the pixel to the center\n    d2 = -1.0/(1.0+(distance(uv,vec2(0.5))));\n    \n    // combine d1 and d2 with respect to each pixel\n    // its more fun to add more, but keeping it simple\n    dist = d1 + d2;\n    \n    if (dist > 0.0){ // green rings above zero\n        finalColor = vec3(0.0, dist, 0.0); // green gradient\n        \n        for (float i=0.0; i < thick;i += space)  {\n             // green slice qualifier\n            if (dist > i && dist < (i + slice)) {\n                finalColor = green; // green ring\n            }\n       } \n        \n    } else { // red rings below zero\n        finalColor = vec3(-dist, 0.0, 0.0); // red gradient\n       \n        for (float i=0.0; i < thick;i += space)  {\n             // red slice qualifier\n            if (dist > -i && dist < (-i + slice)) {\n                finalColor = red; // red ring\n            }\n       } \n        \n    }\n\n    fragColor = vec4( finalColor, 1.0 );\n}","name":"Image","description":"","type":"image"}]}