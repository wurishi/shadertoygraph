{"ver":"0.1","info":{"id":"McKXRG","date":"1715373106","viewed":97,"name":"poisson film grain","username":"googl4","description":"an approximation of an approximation, the poisson distribution is good model for photons striking silver halide crystals but there are more intricacies to real film","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["noise","grain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a slightly more physically based film grain filter than just adding a bit of white noise\n// this is a good article describing a fancier non-realtime filter for anyone interested in the principles:\n//   https://eng.aurelienpierre.com/2023/07/stochastic-photographic-grain-synthesis-from-crystallographic-structure-simulation/\n\n#define PI uintBitsToFloat( 0x40490FDBu )\n\nuint hash( uint x ) {\n    x ^= x >> 16;\n    x *= 0x21F0AAADu;\n    x ^= x >> 15;\n    x *= 0xD35A2D97u;\n    x ^= x >> 15;\n    return x;\n}\n\nuint rng_state;\n\nuint rand() {\n    rng_state = hash( rng_state );\n    return rng_state;\n}\n\nfloat frand() {\n    return uintBitsToFloat( 0x3F800000u | ( rand() >> 9 ) ) - 1.0;\n}\n\nfloat poisson_rand( float lambda ) {\n    // approximated with gaussian\n    float m = lambda - 0.5;\n    float s = sqrt( lambda );\n    \n    float x = frand();\n    float y = frand();\n    \n    return m + s * sqrt( -2.0 * log( x ) ) * cos( 2.0 * PI * y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture( iChannel0, uv ).rgb;\n    \n    rng_state = uint( iFrame / 3 ) + hash( floatBitsToUint( uv.x ) + hash( floatBitsToUint( uv.y ) ) );\n    \n    vec3 linear_col = pow( col, vec3( 2.2 ) );\n    \n    //float luma = dot( linear_col, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float luma = dot( linear_col, vec3( 1.0/6.0, 2.0/6.0, 3.0/6.0 ) );\n    \n    float scale = 120.0;\n    \n    float prnd = poisson_rand( luma * scale );\n    //fragColor.rgb = linear_col * vec3( ( prnd / scale ) / luma );\n    fragColor.rgb = vec3( prnd / scale );\n    \n    fragColor.rgb = pow( fragColor.rgb, vec3( 1.0 / 2.2 ) );\n}\n    \n    ","name":"Image","description":"","type":"image"}]}