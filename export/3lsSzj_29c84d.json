{"ver":"0.1","info":{"id":"3lsSzj","date":"1569592789","viewed":345,"name":"Triangle experimient 2","username":"104","description":"three is the best number of vertices","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","geometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// boilerplate ======================\nconst float PI = 3.14159;\nconst float PI2 = PI*2.;\n\nvec3 dtoa(float d, vec3 amount){\n    return vec3(1. / clamp(d*amount, vec3(1), amount));\n}\nfloat dtoa(float d, float amount){\n    return 1. / clamp(d*amount, 1., amount);\n}\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nfloat nsin(float x) {\n    return cos(x)*.5+.5;\n}\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opXor(float lhs, float rhs) {\n    return opUnion(opIntersection(lhs, -(rhs)), opIntersection(rhs, -(lhs)));\n}\nconst float C = sqrt(3.)/3.; // dist from center to \nfloat sdEquilateralTriangle(in vec2 p)\n{\n    p.y += C; // anchor center\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n// end boilerplate ======================\n\nfloat scurve(float x, float p) {\n    x = x / p * PI2;\n    return (x + sin(x+PI)) / PI2;\n}\n\nvoid sdthing(inout float sd, inout float sd2, vec2 uv, float a, float scale) {\n    sd2 = opXor(sd2, sdEquilateralTriangle(uv*scale));\n    sd = opXor(sd, sdEquilateralTriangle(scale*(((uv + vec2(0,-C*2.)) * rot2D(a - PI/3.)) - vec2(1.,C))));\n    sd = opXor(sd, sdEquilateralTriangle(scale*(((uv + vec2(-1.,C)) * rot2D(a+PI)) - vec2(1.,C))));\n    sd = opXor(sd, sdEquilateralTriangle(scale*(((uv + vec2(1.,C)) * rot2D(a + PI/3.)) - vec2(1.,C))));\n}\n\nvec4 thing(vec2 uv, float s) {\n    vec2 modperiod = vec2(8., 12.*C);\n    uv = mod(uv+modperiod*.5, modperiod) - modperiod*.5;\n    \n    float t = s*iTime*.6;\n    if (s < 0.)\n    \tt = scurve(t, 1.) * .5;\n\n    float sd = 1e6, sd2=sd;\n    // bank 1\n    float seg = mod(t, 3.);\n    float a = fract(seg) * PI * 4./3.;\n    sdthing(sd, sd2, uv, a, 1.);\n    sdthing(sd, sd2, uv, a, 3.);\n    \n    // bank 2\n    uv = mod(uv + modperiod, modperiod) - modperiod*.5;\n    seg = mod(-t+.5, 3.);\n    a = fract(seg) * PI * 4./3.;\n    sdthing(sd, sd2, uv, a, 1.);\n    sdthing(sd, sd2, uv, a, 3.);\n\n    vec4 o;\n    o.rgb = dtoa(sd, 3.*vec3(400,400,20)) * .5;\n    o.rgb += dtoa(sd2, 1.*vec3(5,40,80)) * .8;\n    o = pow(o, o-o+4.);\n    o.br *= rot2D(sd*.6);\n    o = clamp(o,o-o,o-o+1.);\n    o.a = min(sd,sd2);\n    return o;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uvorig = fragCoord/iResolution.xy-.5;\n    uvorig.x *= iResolution.x / iResolution.y;\n    //uvorig.x += iTime*.1;\n    uvorig *= 8.;\n    vec2 uv = uvorig;\n\n    o = thing(uv*3., 1.) * .5;\n    o = vec4(o.r*dtoa(-o.a,40.)*.05);\n    vec4 fore = thing(uv, -1.);\n    o = mix(o, fore, dtoa(fore.a,2000.));\n        \n    vec2 N = fragCoord / iResolution.xy-.5;\n\n    o = pow(o, o-o+.5);\n    o.rgb += (hash32(fragCoord+iTime)-.5)*.08;\n    o.rgb += dot(N,N) * vec3(.2,.5,1);\n    o = clamp(o,o-o,o-o+1.);\n    o *= 1.-length(12.*pow(abs(N), vec2(4.)));// vingette\n    o.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"}]}