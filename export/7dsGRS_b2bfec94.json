{"ver":"0.1","info":{"id":"7dsGRS","date":"1617458253","viewed":49,"name":"Proj2","username":"waifutaker","description":"aaaaa","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["aaaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define MAX_DIST 6000.\n#define SURF_DIST .0001\n//Второй обЬект повороты цвета мягкие тени;\n\n\n/*void sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r<minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2<fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n*/\n\n\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -3., 3.) * 2.0 - z;\n}\n\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n    \n\nvoid ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y- s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }  \n \n void ry2(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x- s * q.z;  \n  \tp.z = s * q.x + c * q.z; \n }  \n \nfloat DE3(vec3 z)\n{\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n <35; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\t//sphereFold(z,dr);    // Sphere Inversion\n \t\tfloat Scale =2.;\n                z=Scale*z + offset;  // Scale & Translate\n                dr = dr*abs(Scale)+1.0;\n\t}\n\tfloat r = length(z);\n\treturn r/abs(dr);\n}\n\n\nfloat TetraFOUR(vec3 p) {//Tetraброт\n\t//vec3 z = p;\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(1.*p.x,p.y,p.z,0.0);\n    vec4 z = vec4(p_vec4.x,p_vec4.y,p_vec4.z,p_vec4.w);\n    \n    float t = iTime/3.0;\n\tvec4 c = 0.5*vec4(sin(t),sin(t),sin(t),sin(t));\n    \n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < 14. ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>2.) break;\n       \n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;//pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = vec4(z.x*z.x-z.y*z.y-z.z*z.z+z.w*z.w, 2.*(z.x*z.y-z.z*z.w),2.*(z.x*z.z-z.y*z.w),2.*(z.x*z.w+z.y*z.z));\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\n/*\nfloat TetraFOUR(vec3 p) {//Tetraброт\n\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(1.*p.x,p.y,p.z,0.0);\n    vec4 z = vec4(p_vec4.x,p_vec4.y,p_vec4.z,p_vec4.w);\n    \n    float t = iTime/3.0;\n\tvec4 c = 0.5*vec4(sin(t),sin(t),sin(t),sin(t));\n    vec4 nz;\n    \n\tfloat mz2 = dot(z,z);\n    float md2 = 1.0;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < 14. ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>2.) break;\n        md2*=4.0*mz2;\n        \n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = c+vec4(z.x*z.x-z.y*z.y-z.z*z.z+z.w*z.w, 2.*(z.x*z.y-z.z*z.w),2.*(z.x*z.z-z.y*z.w),2.*(z.x*z.w+z.y*z.z));\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n*/\n/*\nfloat julia(vec3 pos)\n{\n    float t = iTime/3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<13;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n*/\nfloat MandelFOUR(vec3 p) {//Мандельброт 4d\n\t\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0.);\n    vec4 z = vec4(p,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float r2 = 0.0;\n    float r3 = 0.0;\n\tfor (float i = 0.; i < 10. ; i++) {\n\t\tr = length(z);\n        r2 = sqrt(z.x*z.x+z.y*z.y);\n        r3 = sqrt(z.x*z.x+z.y*z.y+z.z*z.z);\n\t\tif (r>2.) break;\n\t\t\n       \n\t\t// convert to polar coordinates\n\t\tfloat phi = atan(z.z,r2);\n        float psi = atan(z.w,r3);\n\t\tfloat theta = atan(z.y,z.x);//float phi = atan(z.y,z.x);\n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(2.*psi)*cos(2.*theta), cos(2.*psi)*cos(2.*phi), -cos(2.*psi)*sin(2.*phi),sin(2.*psi));\n\t\tz+=vec4(p,0);\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat Quadra(vec3 p) {//quadratics\n\t//vec3 z = p;\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(1.*p.x,p.y,p.z,0);\n\tfloat dr = 1.;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 50 ; i++) {\n\t\tr = length(z);\n\t\tif (r>400.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = 2.*acos(z.z/r);\n\t\tfloat phi = 2.*atan(2.*z.y,2.*z.x);//float phi = atan(z.y,z.x);\n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(theta)*cos(phi), sin(phi)*cos(theta), -sin(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat Mandel(vec3 p) {//Мандельброт\n\t\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(p.x,p.y,p.z,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 100 ; i++) {\n\t\tr = length(z);\n\t\tif (r>40.) break;\n        \n       \t\tfloat t = iTime/30.0;\n        \n        \n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(2.*z.y,2.*z.x);//float phi = atan(z.y,z.x);\n        float Power = abs(cos(t))*10.+1.5;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(theta)*cos(phi), sin(phi)*cos(theta), sin(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat Mandelbub(vec3 p) {//Мандельбуб \n\t//vec3 z = p;\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(p.x,p.y,p.z,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 100 ; i++) {\n\t\tr = length(z);\n\t\tif (r>3.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.x,z.y);//float phi = atan(z.y,z.x);\n        float Power =4.;//*(abs(sin(iTime)))+2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nfloat SinRep(float a)\n{\n    float h = 0.0;\n    float mult = 1.0;\n    for (int i = 0; i <20; i++)\n    {\n        h += (cos(a*mult)/(mult));\n        mult *= 2.0;\n    }\n    return h;\n}\n\nfloat DistanceToObject(vec3 p)\n{\n    float material = 0.0;\n    float h = 0.0;\n    p = RotateY(p, p.y*0.4 - cos(iTime)*0.4);\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\n    material = h;\n    //h += SinRep(RotateX(p, p.y).z);\n    //h += SinRep(RotateZ(p, sin(h)).y);\n    //h += SinRep(RotateY(p, h*1.0).x);\n    //h += SinRep(p.x+h)*0.5;\n    //h += SinRep(p.y+h)*0.5;\n    float final = (length(p)-4.0 - h*(0.25 + sin(iTime)*0.35));\n    return final;\n}\n\nfloat julia(vec3 pos)\n{\n    float t = iTime/3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<13;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n\nfloat DE(vec3 z)// Треугольник серпинского \n{\n vec3 n1 = vec3(-z.y,z.x,z.z);\n \n //float t = dot(z,n1); if (t<0.0) { z-=2.0*t*n1; }\n \n float r;\n \n \n int n = 0;\n float Scale=2.0;\n float Offset =8.;\n while (n < 15) {\n if(z.x+z.y<0.) z.xy = -z.yx; // fold 1  -z.yx*.8*cos(iTime)\n if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n if(z.y+z.z<0.) z.zy = -z.yz; // fold 3 \n float t = dot(z,n1); \n //if (t<0.0){ \n //z-=2.0*t*n1; \n \n z = z*Scale - Offset*(Scale-1.0);\n \n n++;\n }\n \n return (length(z) ) * pow(Scale, -float(n));\n}\n\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\nfloat sphereDist( vec3 p )\n    {\n  vec4 s = vec4(0., 0.1, 0.1, 1);\n  \n  return length(p-s.xyz)-s.w;\n}\n\n\n float f(vec3 p){\n \n \nvec2 mouse=iMouse.xy/iResolution.xy;\nfloat angle = mouse.x*3.1415*2.*10.;\nfloat angle2 = mouse.y*3.1415*2.*10.;\nfloat ang2 =+angle2;\n\n\nfloat ang =+angle;\n\n\t ry(p, 0.2);// ry2(p,ang*0.2);\n     ry2(p,0.2);// ry2(p,ang2*0.2);\n     return  DistanceToObject(1.*p);//TetraFOUR(p);  Quadra\n } \n\n\nfloat opTwist( in vec3 p )//Спираль \n{\n    float k = 0.*sin(iTime); // or some other amount\n    float c = sin(k*p.y);\n    float s = cos(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);//vec3(m*p.xz,p.x);\n    return f(q);\n}\n\nfloat opRep( in vec3 p, in vec3 c )// зеркало \n{\n    vec2 t = vec2(1);//vec2\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return  f(q); //зеркало premitive change \n}\n\n\nfloat opDisplace( in vec3 p )//sin \n{\n    \n    float d2 = (sin(5.*sin(iTime)*p.x)*sin(1.*sin(iTime)*p.y)*sin(sin(iTime)*p.z));\n    return f(p)+d2;\n}\n\n\nfloat GetDist(vec3 p) {\n\tvec3 b = vec3(10);\n    float s = 1.;\n    \n    float planeDist =p.y+5.;//high\n    \n    float dg= opTwist(.4*p);//opDisplace opTwist opRep(p,b) and size \n    \n    float d = min(dg,planeDist);\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(abs(cos(iTime))*1., abs(sin(iTime))*1.,abs(cos(iTime))*1.);\n    lightPos.xyz += vec3(-1.,5., -7.5)*6.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .009;\n    \n    return dif;\n}\n\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 9.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\n\nconst vec3 RED = vec3(3.,0.001103,0.08);\nconst vec3 ORANGE = vec3(0.032,0.01,0.09);\nconst vec3 GREEN = vec3(.0,3.0,3.00);\nconst vec3 BLUE = vec3(0.0,0.0,7.00);\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(0.7, 42.0 /3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx+ K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n///////////\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n///////////\n\n\n\nvec3 GetRay(vec2 uv, vec3 p, vec3 l , float zoom){\n   vec3 f = normalize(p-l),\n        r = normalize(cross(vec3 (0,1,0),f)),\n        u = cross(f,r),\n        c = p+f*zoom,\n        i = c + uv.x*r+uv.y*u,\n        d = normalize(i-p);\n        return d;\n        }\n\n\n\n#define MOVE_FORWARD_KEY1\t\tKEY_W\n#define MOVE_FORWARD_KEY2\t\tKEY_UP\n#define MOVE_FORWARD_KEY3\t\tKEY_Z\t\t\t// azerty\n#define MOVE_LEFT_KEY1\t\t\tKEY_A\n#define MOVE_LEFT_KEY2\t\t\tKEY_Q\t\t\t// azerty\n#define MOVE_BACKWARD_KEY1\t\tKEY_S\n#define MOVE_BACKWARD_KEY2\t\tKEY_DOWN\n#define MOVE_RIGHT_KEY1\t\t\tKEY_D\n#define MOVE_RIGHT_KEY2\t\t\tunassigned\n#define MOVE_UP_KEY1\t\t\tKEY_SPACE\n#define MOVE_UP_KEY2\t\t\tunassigned\n#define MOVE_DOWN_KEY1\t\t\tKEY_C\n#define MOVE_DOWN_KEY2\t\t\tunassigned\n#define RUN_KEY1\t\t\t\tKEY_SHIFT\n#define RUN_KEY2\t\t\t\tunassigned\n#define LOOK_LEFT_KEY1\t\t\tKEY_LEFT\n#define LOOK_LEFT_KEY2\t\t\tunassigned\n#define LOOK_RIGHT_KEY1\t\t\tKEY_RIGHT\n#define LOOK_RIGHT_KEY2\t\t\tunassigned\n#define LOOK_UP_KEY1\t\t\tKEY_PGDN\n#define LOOK_UP_KEY2\t\t\tunassigned\n#define LOOK_DOWN_KEY1\t\t\tKEY_DELETE\n#define LOOK_DOWN_KEY2\t\t\tunassigned\n#define CENTER_VIEW_KEY1\t\tKEY_END\n#define CENTER_VIEW_KEY2\t\tunassigned\n#define STRAFE_KEY1\t\t\t\tKEY_ALT\n#define STRAFE_KEY2\t\t\t\tunassigned\n#define RESPAWN_KEY1\t\t\tKEY_BKSP\n#define RESPAWN_KEY2\t\t\tKEY_HOME\n#define ATTACK_KEY1\t\t\t\tKEY_E\n#define ATTACK_KEY2\t\t\t\tKEY_F\n\n#define MENU_KEY1\t\t\t\tKEY_ESC\n#define MENU_KEY2\t\t\t\tKEY_TAB\n\n#define SHOW_PERF_STATS_KEY\t\tKEY_P\n#define TOGGLE_TEX_FILTER_KEY\tKEY_T\n#define TOGGLE_LIGHT_SHAFTS_KEY\tKEY_L\n#define TOGGLE_CRT_EFFECT_KEY\tKEY_V\n\nconst float\n\tSENSITIVITY\t\t\t\t\t= 1.0,\n\tMOUSE_FILTER\t\t\t\t= 0.0,\t\t// mostly for video recording\n\tTURN_SPEED\t\t\t\t\t= 180.0,\t// keyboard turning rate, in degrees per second\n\tWALK_SPEED\t\t\t\t\t= 400.0,\n\tJUMP_SPEED\t\t\t\t\t= 270.0,\n    STAIR_CLIMB_SPEED\t\t\t= 128.0,\n    STOP_SPEED\t\t\t\t\t= 100.0,\n    \n    GROUND_ACCELERATION\t\t\t= 10.0,\n    AIR_ACCELERATION\t\t\t= 1.0,\n\n    GROUND_FRICTION\t\t\t\t= 4.0,\n\tNOCLIP_START_FRICTION\t\t= 18.0,\n\tNOCLIP_STOP_FRICTION\t\t= 12.0,\n\n    ROLL_ANGLE\t\t\t\t\t= 2.0,\t\t// maximum roll angle when moving sideways\n\tROLL_SPEED\t\t\t\t\t= 200.0,\t// sideways speed at which the roll angle reaches its maximum\n\tBOB_CYCLE\t\t\t\t\t= 0.6,\t\t// seconds\n\tBOB_SCALE\t\t\t\t\t= 0.02,\n\n    AUTOPITCH_DELAY\t\t\t\t= 2.0,\t\t// seconds between last mouse look and automatic pitch adjustment\n    STAIRS_PITCH\t\t\t\t= 10.0,\n\n    RECOIL_ANGLE\t\t\t\t= 2.0,\n    WEAPON_SPREAD\t\t\t\t= 0.05,\t\t// slightly higher than in Quake, for dramatic effect\n    RATE_OF_FIRE\t\t\t\t= 2.0;\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n//#define GENERATE_TEXTURES\t\t(1<<MATERIAL_WIZMET1_1) | (1<<MATERIAL_WBRICK1_5)\n#define GENERATE_TEXTURES\t\t-1\n#define ALWAYS_REFRESH\t\t\t0\n#define WRITE_MAP_DATA\t\t\t1\n#define ENABLE_MENU\t\t\t\t1\n\n////////////////////////////////////////////////////////////////\n\nconst int\n\tKEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70, KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74,\n\tKEY_K = 75, KEY_L = 76, KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82, KEY_S = 83, KEY_T = 84,\n\tKEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88, KEY_Y = 89, KEY_Z = 90,\n\n    KEY_0 = 48, KEY_1 = 49, KEY_2 = 50, KEY_3 = 51, KEY_4 = 52, KEY_5 = 53, KEY_6 = 54, KEY_7 = 55, KEY_8 = 56, KEY_9 = 57,\n\n\tKEY_PLUS\t\t= 187,\n\tKEY_MINUS\t\t= 189,\n\tKEY_EQUAL\t\t= KEY_PLUS,\n\n    // firefox...\n    KEY_PLUS_FF\t\t= 61,\n    KEY_MINUS_FF\t= 173, \n\n    KEY_SHIFT\t\t= 16,\n\tKEY_CTRL\t\t= 17,\n\tKEY_ALT\t\t\t= 18,\n    \n    KEY_ESC\t\t\t= 27,\n\t\n    KEY_BKSP \t\t=  8,\n    KEY_TAB\t\t\t=  9,\n\tKEY_END\t\t\t= 35,\n\tKEY_HOME\t\t= 36,\n\tKEY_INS\t\t\t= 45,\n\tKEY_DEL\t\t\t= 46,\n\tKEY_INSERT\t\t= KEY_INS,\n\tKEY_DELETE\t\t= KEY_DEL,\n\n\tKEY_ENTER\t\t= 13,\n\tKEY_SPACE \t\t= 32,\n\tKEY_PAGE_UP \t= 33,\n\tKEY_PAGE_DOWN \t= 34,\n\tKEY_PGUP \t\t= KEY_PAGE_UP,\n\tKEY_PGDN \t\t= KEY_PAGE_DOWN,\n\n\tKEY_LEFT\t\t= 37,\n\tKEY_UP\t\t\t= 38,\n\tKEY_RIGHT\t\t= 39,\n\tKEY_DOWN\t\t= 40,\n\t\n\tunassigned\t\t= 0;\n\n////////////////////////////////////////////////////////////////\n\nfloat is_key_down(int code)\t\t\t\t{ return code != 0 ? texelFetch(iChannel0, ivec2(code, 0), 0).r : 0.; }\nfloat is_key_pressed(int code)\t\t\t{ return code != 0 ? texelFetch(iChannel0, ivec2(code, 1), 0).r : 0.; }\n\n////////////////////////////////////////////////////////////////\n\nfloat cmd(int code1, int code2)\t\t\t{ return max(is_key_down(code1), is_key_down(code2)); }\nfloat cmd(int c1, int c2, int c3)\t\t{ return max(is_key_down(c1), max(is_key_down(c2), is_key_down(c3))); }\nfloat cmd_press(int code1, int code2)\t{ return max(is_key_pressed(code1), is_key_pressed(code2)); }\n\n//float cmd_move_forward()\t\t\t\t{ return cmd(MOVE_FORWARD_KEY1,\t\tMOVE_FORWARD_KEY2,\t\tMOVE_FORWARD_KEY3); }\nfloat cmd_move_backward()\t\t\t\t{ return cmd(MOVE_BACKWARD_KEY1,\tMOVE_BACKWARD_KEY2); }\nfloat cmd_move_left()\t\t\t\t\t{ return cmd(MOVE_LEFT_KEY1,\t\tMOVE_LEFT_KEY2); }\nfloat cmd_move_right()\t\t\t\t\t{ return cmd(MOVE_RIGHT_KEY1,\t\tMOVE_RIGHT_KEY2); }\nfloat cmd_move_up()\t\t\t\t\t\t{ return cmd(MOVE_UP_KEY1,\t\t\tMOVE_UP_KEY2); }\nfloat cmd_move_down()\t\t\t\t\t{ return cmd(MOVE_DOWN_KEY1,\t\tMOVE_DOWN_KEY2); }\nfloat cmd_run()\t\t\t\t\t\t\t{ return cmd(RUN_KEY1,\t\t\t\tRUN_KEY2); }\nfloat cmd_look_left()\t\t\t\t\t{ return cmd(LOOK_LEFT_KEY1,\t\tLOOK_LEFT_KEY2); }\nfloat cmd_look_right()\t\t\t\t\t{ return cmd(LOOK_RIGHT_KEY1,\t\tLOOK_RIGHT_KEY2); }\nfloat cmd_look_up()\t\t\t\t\t\t{ return cmd(LOOK_UP_KEY1,\t\t\tLOOK_UP_KEY2); }\nfloat cmd_look_down()\t\t\t\t\t{ return cmd(LOOK_DOWN_KEY1,\t\tLOOK_DOWN_KEY2); }\nfloat cmd_center_view()\t\t\t\t\t{ return cmd(CENTER_VIEW_KEY1,\t\tCENTER_VIEW_KEY2); }\nfloat cmd_strafe()\t\t\t\t\t\t{ return cmd(STRAFE_KEY1,\t\t\tSTRAFE_KEY2); }\nfloat cmd_respawn()\t\t\t\t\t\t{ return cmd_press(RESPAWN_KEY1,\tRESPAWN_KEY2); }\nfloat cmd_attack()\t\t\t\t\t\t{ return cmd(ATTACK_KEY1,\t\t\tATTACK_KEY2); }\nfloat cmd_menu()\t\t\t\t\t\t{ return cmd_press(MENU_KEY1,\t\tMENU_KEY2); }\n\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n\tfloat d = DistLine(ro, rd, p);\n    d = smoothstep(.06, .05, d);\n    return d;\n}\n\n\n\n\n\n\n\nconst float WIDTH = 1920. , HEIGHT = 1080.;\n\n// Camera\nvec3 ro ;\nvec3 roSave ;\nvec3 cameraFront = vec3(0.0f, 0.0f, -1.0f);\nvec3 cameraUp    = vec3(0.0f, 1.0f,  0.0f);\nfloat yaw   = -90.0f;\t// Yaw is initialized to -90.0 degrees since a yaw of 0.0 results in a direction vector pointing to the right (due to how Eular angles work) so we initially rotate a bit to the left.\nfloat pitch =   0.0f;\nfloat lastX =  WIDTH  / 2.0;\nfloat lastY =  HEIGHT / 2.0;\nbool firstMouse ;\nbool keys[1024];\nfloat deltaTime = 0.0f;\t// Время, прошедшее между последним и текущим кадром\nfloat lastFrame = 0.0f;\n\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel0, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid do_movement()\n{\n\n float currentFrame = iTimeDelta;\ndeltaTime = currentFrame - lastFrame;\nlastFrame = currentFrame;\n    // Camera controls\n   \n    float cameraSpeed = 10.0f * deltaTime;\n    if (isKeyPressed(KEY_W))//key_callback(KEY_W,cmd_move_right()))\n        ro +=cameraSpeed * cameraFront*100.;\n    if (cmd_move_backward()!= 0.)\n        ro -= cameraSpeed * cameraFront;\n    if (cmd_move_right()!= 0.)\n        ro -= normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n    if (cmd_move_left()!= 0.)\n        ro += normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n}\n\n\n\n\n\nvec3 vel=vec3(0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ro=vec3(1.,2.,-4.);\n     \n    //vec3(sin(iTime)*1.,cos(iTime)*0.5,-4);\n    vec3 col=vec3(1.,3.,3.);\n    \n    \n    int firstMous = 1;\n    float currentFrame = iTimeDelta;\n    deltaTime = currentFrame - lastFrame;\n    lastFrame = currentFrame;\n    // Camera controls\n    \n     float cameraSpeed = 60.0;//* deltaTime;\n   \n   \n    \n\tfloat t = iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\n    vec2 mouse=iMouse.xy/iResolution.xy;\n\n   // vec3 ro = vec3(3., 2., -3.);\n\n\n\n   ////////// \n  \n    ////MOVMENT\n     \n   \n   \n   //ROTATION\n   /*\n    float xpos =+ mouse.x*1000.;\n    float ypos =+ mouse.y*1000.;\n   \n   if (firstMouse)\n    {\n        lastX = xpos;\n        lastY = ypos;\n        firstMous = 0;\n    }\n    \n    float xoffset = -xpos + lastX;\n    float yoffset = -lastY + ypos; // Reversed since y-coordinates go from bottom to left\n    lastX = xpos;\n    lastY = ypos;\n\n    float sensitivity = 0.5;\t// Change this value to your liking\n    xoffset *= sensitivity;\n    yoffset *= sensitivity;\n\n    yaw   += xoffset;\n    pitch += yoffset;\n\n    // Make sure that when pitch is out of bounds, screen doesn't get flipped\n    if (pitch > 89.0f)\n        pitch = 89.0f;\n    if (pitch < -89.0f)\n        pitch = -89.0f;\n   \n    vec3 front;\n    front.x = cos(radians(yaw)) * cos(radians(pitch));\n    front.y = sin(radians(pitch));\n    front.z = sin(radians(yaw)) * cos(radians(pitch));\n    cameraFront = normalize(front);\n  \n    \n    \n\n    if (isKeyPressed(KEY_W))\n        ro +=cameraSpeed * cameraFront;\n    if (isKeyPressed(KEY_S))\n        ro -= cameraSpeed * cameraFront;\n    if (isKeyPressed(KEY_D))\n        ro -= normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n    if (isKeyPressed(KEY_A))\n        ro += normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n\n*/\n\n    // ro.yz *=Rot(-mouse.y*3.1416+1.);\n    //ro.xz *=Rot(-mouse.x*3.1416*2.);\n   \n/////////\n    vec3 lookat = vec3(cameraFront);\n    \n    float zoom = 1.5;\n    \n    /*\n    \n    \n    \n     vec3 f = normalize(p-l),\n        r = normalize(cross(vec3 (0,1,0),f)),\n        u = cross(f,r),\n        c = p+f*zoom,\n        i = c + uv.x*r+uv.y*u,\n        d = normalize(i-p);\n        return d;\n        }*/\n   \n    \n  //cameraFront =  normalize(lookat-ro);\n    \n    //cameraFront += vel;\n    \n   // vel = ro;\n   \n    if (isKeyPressed(KEY_W))\n        ro +=cameraSpeed * cameraFront;\n    if (isKeyPressed(KEY_S))\n        ro -= cameraSpeed * cameraFront;\n    if (isKeyPressed(KEY_D))\n        ro -= normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n    if (isKeyPressed(KEY_A))\n        ro += normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n   \n   float xpos =+ mouse.x*1000.;\n    float ypos =+ mouse.y*1000.;\n   \n   if (firstMouse)\n    {\n        lastX = xpos;\n        lastY = ypos;\n        firstMous = 0;\n    }\n    \n    float xoffset = -xpos + lastX;\n    float yoffset = -lastY + ypos; // Reversed since y-coordinates go from bottom to left\n    lastX = xpos;\n    lastY = ypos;\n\n    float sensitivity = 0.5;\t// Change this value to your liking\n    xoffset *= sensitivity;\n    yoffset *= sensitivity;\n\n    yaw   += xoffset;\n    pitch += yoffset;\n\n    // Make sure that when pitch is out of bounds, screen doesn't get flipped\n    if (pitch > 89.0f)\n        pitch = 89.0f;\n    if (pitch < -89.0f)\n        pitch = -89.0f;\n   \n    vec3 front;\n    front.x = cos(radians(yaw)) * cos(radians(pitch));\n    front.y = sin(radians(pitch));\n    front.z = sin(radians(yaw)) * cos(radians(pitch));\n    cameraFront = normalize(front);\n    \n    vec3 r = normalize(cross(vec3(0., 1., 0.), cameraFront));\n    cameraUp = cross(cameraFront, r);\n    \n    vec3 c = ro + cameraFront*zoom;\n    vec3 i = c + uv.x*r + uv.y*cameraUp;\n    vec3 rd = normalize(i-ro);\n    \n    \n    \n   \n\n    \n   // rd.yz *=Rot(-mouse.y*3.1416+1.);\n   // rd.xz *=Rot(-mouse.x*3.1416*2.);\n  //  ro.x = ro.x+112.*sin(iTime);\n    \n\n    float d = RayMarch(ro, rd);\n/*    \n    vec3 ra = vec3(1.,0.5,-4);\n    float d2 = RayMarch(ra,rd);\n    vec3 t = ro+ra*d2;\n    float dif2 = GetLight(t);\n    vec3 color;\n    color = vec3(dif2);\n  */  \n    \n    \n   /* if(d<MAX_DIST){\n        \n        r = normalize(cross(vec3(0., 1., 0.), cameraFront));\n    cameraUp = cross(cameraFront, r);\n    c = ro + cameraFront*zoom;\n    i = c + uv.x*r + uv.y*cameraUp;\n    rd = normalize(i-ro);\n    \n    \n    \n    \n    vec3 p =(ro + rd * d);\n    vec3 n =GetNormal(p);\n     float dif = GetLight(p);\n    //float dif = dot(n,normalize(vec3(1)))*.5+5.;\n    col +=dif;\n    }*/\n     vec3 p =(ro + rd * d);\n    vec3 n =GetNormal(p);\n    \n    float dif = GetLight(p);\n    col = vec3(dif);//dif d/= 0199.\n    col = hsv2rgb(col);\n    \n   \n    vec3 ld = vec3(0.,1., .5);\n    ///////////\n    vec3 sky = 0.*GetSky(rd, ld, vec3(11.5,1.,3.));// 0убери\n    ////////////////\n    \n    \n    //float t =iTime\\3.0;\n    // color\n    \n    //vec3 n =GetNormal(p);\n    vec3 l0 = normalize(vec3(-1.0,0.0,-1.0));\n    vec3 l1 = normalize(vec3(0.3,0.5,0.5));\n    vec3 l2 = normalize(vec3(1.0,1.0,0.4));\n   \n\n\n    //col += specular(n,l0,rd,1.1) * BLUE;//*vec3(cos(iTime)*.5,sin(iTime)*0.4,cos(iTime)*.5);\n    //col += specular(n,l1,rd,1.2) *1.1*GREEN;//* vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.) * 1.1; \n    //col += specular(n,l2,rd,1.0) * 1.2; //*vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.);\n    //col = col*.20;\n    \n   // col = col*vec3(dif);//col = col*vec3(dif)**vec3(dif2)\n    \n    \n   // col = col*vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t//col=mix(col,sky, 1.0-exp(-0.001*p.x*p.x));\n    \n  // col = pow(col, vec3(.4545));\t// gamma correction   col = pow(col, vec3(.4545)); \n    fragColor = vec4(pow(col,vec3(0.4545)),0.0);//hs2v function\n    fragColor.xyz = mix( fragColor.xyz, sky, 0.*1.0-exp( -0.01*d*d ) );//fog (*1.0-exp( -0.01*d*d )\n    \n}","name":"Image","description":"","type":"image"}]}