{"ver":"0.1","info":{"id":"Mlcczr","date":"1531377058","viewed":2115,"name":"sci-fi hexagons","username":"laserdog","description":"some cool sci-fi hexagons. credit to Shane for hexagon tiling algorithm (https://www.shadertoy.com/view/Xljczw)","likes":61,"published":1,"flags":0,"usePreview":0,"tags":["tech","scifi","hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(r,v) smoothstep(9./iResolution.y,0.,abs(v-(r)))\n\nconst vec2 s = vec2(1, 1.7320508); // 1.7320508 = sqrt(3)\nconst vec3 baseCol = vec3(.05098, .25098, .2784);\nconst float borderThickness = .02;\nconst float isolineOffset = .4;\nconst float isolineOffset2 = .325;\n\nfloat calcHexDistance(vec2 p)\n{\n    p = abs(p);\n    return max(dot(p, s * .5), p.x);\n}\n\nfloat random(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 calcHexInfo(vec2 uv)\n{\n    vec4 hexCenter = round(vec4(uv, uv - vec2(.5, 1.)) / s.xyxy);\n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + .5) * s);\n    return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? vec4(offset.xy, hexCenter.xy) : vec4(offset.zw, hexCenter.zw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 3. * (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.x += iTime * .25;\n    \n    vec4 hexInfo = calcHexInfo(uv);\n    float totalDist = calcHexDistance(hexInfo.xy) + borderThickness;\n    float rand = random(hexInfo.zw);\n    \n    float angle = atan(hexInfo.y, hexInfo.x) + rand * 5. + iTime;\n    vec3 isoline = S(isolineOffset, totalDist) * baseCol * step(3. + rand * .5, mod(angle, 6.28))\n        + S(isolineOffset2, totalDist)\n                    * baseCol * step(4. + rand * 1.5, mod(angle + rand * 2., 6.28));\n    \n    float sinOffset = sin(iTime + rand * 8.);\n    float aa = 5. / iResolution.y;\n    \n    fragColor.rgb = (smoothstep(.51, .51 - aa, totalDist) + pow(1. - max(0., .5 - totalDist), 20.) * 1.5)\n        * (baseCol + rand * vec3(0., .1, .09)) + isoline + baseCol * smoothstep(.2 + sinOffset, .2 + sinOffset - aa, totalDist);    \n}","name":"Image","description":"","type":"image"}]}