{"ver":"0.1","info":{"id":"WttSz8","date":"1580461365","viewed":240,"name":"Hough Circle transform","username":"EaglEyd","description":"The hough circle transform is a method of automatically finding circles in images. This is a a crude implementation and visualisation (multiplication factor 5) for different radii. r1 and r2 can be adjusted to find ellipses too.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["circle","transform","hough"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926\n#define PHI_STEP M_PI/180.0\n\nvec2 fc;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r1 = 50.0*abs(sin(iTime))+5.0;\n    float r2 = 50.0*abs(sin(iTime))+5.0;\n    float c = 0.0;\n    \n    for(float phi = 0.0; phi < 2.0*M_PI; phi += PHI_STEP)\n    {\n    \tc += texture(iChannel0, (fragCoord.xy + vec2(r1*cos(phi), r2*sin(phi))) / iResolution.xy).r;        \n    }\n    c /= 360.0;\n    fragColor = vec4(vec3(5.0*c), 1.0);\n\t//fragColor = texture(iChannel0, fc / iResolution.xy);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define lu(x,y) texture(iChannel0, (fragCoord.xy + vec2(x,y)) / iResolution.xy).rgb\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 mean = vec3(0.0);\n    mean += 2.0  *lu(-2,-2);\n    mean += 4.0  *lu(-1,-2);\n    mean += 5.0  *lu( 0,-2);\n    mean += 4.0  *lu( 1,-2);\n    mean += 2.0  *lu( 2,-2);\n    \n    mean += 4.0  *lu(-2,-1);\n    mean += 9.0  *lu(-1,-1);\n    mean += 12.0 *lu( 0,-1);\n    mean += 9.0  *lu( 1,-1);\n    mean += 4.0  *lu( 2,-1);\n    \n    mean += 5.0  *lu(-2, 0);\n    mean += 12.0 *lu(-1, 0);\n    mean += 15.0 *lu( 0, 0);\n    mean += 12.0 *lu( 1, 0);\n    mean += 5.0  *lu( 2, 0);\n    \n    mean += 4.0  *lu(-2, 1);\n    mean += 9.0  *lu(-1, 1);\n    mean += 12.0 *lu( 0, 1);\n    mean += 9.0  *lu( 1, 1);\n    mean += 4.0  *lu( 2, 1);\n    \n    mean += 2.0  *lu(-2, 2);\n    mean += 4.0  *lu(-1, 2);\n    mean += 5.0  *lu( 0, 2);\n    mean += 4.0  *lu( 1, 2);\n    mean += 2.0  *lu( 2, 2);\n        \n    mean /= 159.0;\n\tfragColor = vec4(mean,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define lu(x,y) texture(iChannel0, (fragCoord.xy + vec2(x,y)) / iResolution.xy).r\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dx = \n        -3.0  * lu(-1,-1)\n        -10.0 * lu(-1, 0)\n        -3.0  * lu(-1, 1)\n        +3.0  * lu( 1,-1)\n        +10.0 * lu( 1, 0)\n        +3.0  * lu( 1, 1);\n    \n    float dy = \n        -3.0  * lu(-1,-1)\n        -10.0 * lu( 0,-1)\n        -3.0  * lu( 1,-1)\n        +3.0  * lu(-1, 1)\n        +10.0 * lu( 0, 1)\n        +3.0  * lu( 1, 1);\n    \n    fragColor = vec4(0.03125*dx+0.5, 0.03125*dy+0.5, 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 fc;\n\nvec2 tlut(vec2 offset) { return 32.0 * texture(iChannel0,(fc+offset)/iResolution.xy).rg - 16.0; }\n\nbool isMaximum(float G, float direction)\n{\n    vec2 dir = vec2(cos(direction), sin(direction));\n\tfloat G1 = length(tlut(dir));\n    float G2 = length(tlut(-dir));\n    return G > G1 && G > G2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fc = fragCoord.xy;\n    vec2 edge = tlut(vec2(0,0));\n    \n    float G = length(edge);\n    float dir = atan(edge.y, edge.x);\n    \n    if(isMaximum(G, dir) && G > 0.6) {\n        bool shouldInclude = false;\n        for(int y = -1; y <= 1; ++y)\n        {\n            for(int x = -1; x <= 1; ++x)\n            {\n                if(length(tlut(vec2(x,y))) > 0.6)\n                {\n                    shouldInclude = true;\n                }\n            }\n        }\n        if(shouldInclude)\n        {\n    \t\tfragColor = vec4(vec3(G), 1.0);\n        } else {\n            fragColor = vec4(vec3(0.0), 1.0);\n        }\n    } else {\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}