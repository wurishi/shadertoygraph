{"ver":"0.1","info":{"id":"XfBGzc","date":"1710149672","viewed":85,"name":"Mandelbrot set hsv","username":"Skelly","description":"I know this is very bad","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Improve with: https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set\n\nvec3 hsv2rgb(vec3 hsv) // Smoothing 1 = none, smoothing > 1 = smoothed\n{\n    hsv = vec3(fract(hsv.x), clamp(hsv.yz, 0., 1.));\n\n    float hue_scaled = hsv.x * 6.;\n    int hue_state = int(floor(hue_scaled));\n    float hue_substate = hue_scaled - float(hue_state);\n    vec3 hue;\n    switch (hue_state)\n    {\n        case 0:\n            hue = mix(vec3(1., 0., 0.), vec3(1., 1., 0.), hue_substate);\n            break;\n        \n        case 1:\n            hue = mix(vec3(1., 1., 0.), vec3(0., 1., 0.), hue_substate);\n            break;\n        \n        case 2:\n            hue = mix(vec3(0., 1., 0.), vec3(0., 1., 1.), hue_substate);\n            break;\n        \n        case 3:\n            hue = mix(vec3(0., 1., 1.), vec3(0., 0., 1.), hue_substate);\n            break;\n        \n        case 4:\n            hue = mix(vec3(0., 0., 1.), vec3(1., 0., 1.), hue_substate);\n            break;\n        \n        case 5:\n            hue = mix(vec3(1., 0., 1.), vec3(1., 0., 0.), hue_substate);\n            break;\n    }\n    \n    return mix(vec3(1.), hue, hsv.y) * hsv.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 point = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    float scale = 2.5 / (pow(iTime, iTime*0.1 + 1.)*0.01 + 1.);\n    vec2 centre = vec2(-.744, .1331);\n    \n    point *= scale;\n    point += centre;\n    \n    vec2 i_point = vec2(0.);\n    \n    int max_iterations = int(1000.);\n    int i = 0;\n    for (; i < max_iterations; i++)\n    {\n        float inf_radius = 100.;\n        if (i_point.x*i_point.x + i_point.y*i_point.y > (inf_radius*inf_radius))\n        {\n            break;\n        }\n    \n        i_point = vec2(i_point.x*i_point.x - i_point.y*i_point.y + point.x,\n            2.*i_point.x*i_point.y + point.y);\n    }\n    \n    vec3 colour;\n    \n    if ( i < max_iterations )\n        colour = hsv2rgb(vec3(float(i) * .01 + 0.6, .8, .8));\n\n    // Output to screen\n    fragColor = vec4(colour, 1.);\n}","name":"Image","description":"","type":"image"}]}