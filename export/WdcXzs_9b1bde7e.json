{"ver":"0.1","info":{"id":"WdcXzs","date":"1573453088","viewed":213,"name":"Giraffe pattern","username":"fancyzero","description":"Giraffe pattern","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["randomgirraffe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float THICKNESS =  0.07;\nconst float FAR = 1.;\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\nvec4 voronoi( in vec2 x )//original from here : https://www.shadertoy.com/view/Xll3zX\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2(n+g);\n\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\tfloat k = md;\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr ,k);\n}\n\nfloat testHeightField( vec3 p )\n{\n    return texture(iChannel1, p.xy*3.).x;// (sin(p.y*20.)+1.)/2.;\n}\n\nvec3 March( vec3 start, vec3 end, int steps, out vec3 pos, out vec3 n, out float ao )\n{\n    float delta = length(end -start)/float(steps);\n\tvec3 dir = normalize(end-start);\n    for ( int i=1; i <= steps; i++ )\n    {\n        float d = 0.001;\n        vec3 p = start+dir*float(i)*delta;//+delta*float(i)*vec3(.21,.21,0.);\n        float h = testHeightField(p.xyz)*THICKNESS;\n        //float h = texture(iChannel1,p.xy*2.).x*THICKNESS;\n        \n        if ( h > THICKNESS-(p.z-FAR) )\n        {\n        \tfloat hx = testHeightField(p.xyz+vec3(d,0.,0.))*THICKNESS;\n        \tfloat hy =  testHeightField(p.xyz+vec3(0.,d,0.))*THICKNESS;\n            pos = p;\n            n = normalize(cross(vec3(d,0, (hx-h)),vec3(0,d,(hy-h))));\n \n            ao = 1.-(p.z-FAR)/THICKNESS;\n            return vec3(h/(THICKNESS));\n            \n        }\n       \n    }\n     return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx;\n    vec2 p2 = p - vec2(0.5, iResolution.y*0.5/iResolution.x);\n    \n    vec3 rayDir = normalize(vec3(p2,0.7));\n    vec3 start = rayDir* FAR/rayDir.z;\n    vec3 end = rayDir*(FAR+THICKNESS)/rayDir.z;\n    \n    vec3 pos;\n    vec3 n;\n    float ao;\n    vec3 hit = March(start, end, 60, pos, n,ao);\n\tvec4 noise = texture(iChannel0,p.xy);\n    vec4 noise2 = texture(iChannel0,p.xy*4.);\n    p += noise.xy*0.003;\n    p = pos.xy;\n    vec4 c = voronoi( 8.0*p );\n\n    // borders\t\n    vec3 cola = mix(vec3(0.5,0.3,0.0), vec3(0.35,0.13,0.05), noise2.z*noise2.z);\n    vec3 colb = mix(vec3(0.67,0.56,0.4), vec3(0.5,0.4,0.45), noise2.a*noise2.a);\n    vec3 col = mix(cola,colb, ceil(0.02 - c.x+c.w*c.w*0.35) );\n    \n\n    vec3 l =  normalize(vec3(sin(iTime), cos(iTime),0.6));\n    float NoL = max(0.,dot(n,l));\n    vec3 v = normalize(-pos);\n    float NoH = max(0.,dot(n, normalize(l+v)));\n    NoH*=0.3;\n    NoH = pow(NoH,2.2);\n    NoL = clamp(0.,2.,NoL+1.5);\n\tfragColor = vec4(NoL*clamp(0.,1.,ao+0.5)*col+NoH,1.0);\n    fragColor = pow(fragColor, vec4(2.2));\n  // fragColor = vec4(NoH,NoH,NoH,1.0);\n}","name":"Image","description":"","type":"image"}]}