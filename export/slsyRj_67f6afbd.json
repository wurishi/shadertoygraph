{"ver":"0.1","info":{"id":"slsyRj","date":"1648332623","viewed":28,"name":"3D Raymarched Visualizer","username":"Jwebb4191","description":"Experimenting with ray marching and audio visualization","likes":0,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","bloom","visualizer"],"hasliked":0,"parentid":"fsSfWm","parentname":"RayMarchVisualize"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\n    //Depth of field taken from https://www.shadertoy.com/view/4tByz3\n    vec2 q = fragCoord / iResolution.xy;\n    \n    vec3 camPos = vec3(cos(iTime * .25) * 30.0, 5, sin(iTime * .25) * 20.0);\n    \n    float focus = length(camPos);\n\n    vec4 acc = vec4(0.0);\n    const int N = 12;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off/vec2(800.0,450.0)); \n        \n        float depth = tmp.w;\n        \n        vec3  color = tmp.xyz;\n        \n        \n        \n        float coc = 0.05 + 4.0*abs(depth-focus)/depth;\n        \n        if( dot(off,off) < (coc*coc))\n        {\n            float w = 1.0/(coc*coc); \n            acc += vec4(color*w,w);\n        }\n    }\n    \n    vec3 col = acc.xyz / acc.w;\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ltsXWs","filepath":"https://soundcloud.com/thefatrat/thefatrat-unity-1","previewfilepath":"https://soundcloud.com/thefatrat/thefatrat-unity-1","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//Average out sound samples\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    \n    vec4 prevSamples = texture(iChannel1, uv);\n    \n    fragColor.zw = prevSamples.xy;\n    fragColor.xy = ((prevSamples.xy + prevSamples.zw) / 2.0f + texture(iChannel0, uv).xy) / 2.0f;\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int MAX_MARCH_STEPS = 100;\nconst float MIN_STEP = 0.0;\nconst float MAX_STEP = 100.0;\nconst float EPSILON = .001;\nconst float PI = 3.14159;\nconst float PI23 = PI * .66;\nconst float LIGHT_INTENSITY =  .7;\nconst float BASE_LIGHT = 0.3;\n\n\nstruct Light\n{\n    vec3 Position;\n    vec3 Color;\n};\n\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n\nstruct Camera\n{\n    vec3 Position;\n    vec3 LookAt;\n    vec3 Up;\n};\n\nmat4 ViewMatrix(Camera camera)\n{\n    vec3 viewDir = normalize(camera.LookAt - camera.Position);\n    vec3 right = normalize(cross(viewDir, camera.Up));\n    vec3 transUp = normalize(cross(right, viewDir));\n    \n    return mat4(\n        vec4(right, 0.0),\n        vec4(transUp, 0.0),\n        vec4(-viewDir, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n//Almost all of the SDF functions are taken directly from or adapted from:\n//https://iquilezles.org/articles/distfunctions\nfloat IntersectSDF(float distA, float distB) \n{\n    return max(distA, distB);\n}\n\nfloat UnionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat DifferenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 center, float radius)\n{\n    return length(center) - radius;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Create infinite copies of an object\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n//A single instance of the infinitely repeated scene\nfloat RepeatedSceneSingleInstance(vec3 point)\n{\n    vec3 spherePont = point - vec3(-4,0,0);\n\n    float finalT = SphereSDF(spherePont, 1.0);\n    \n        \n    for(float i = -2.5; i < 5.0; i += 7.5 / 20.0)\n    {\n        float freq = texture(iChannel0, vec2((i + 2.5) / 20.0, 0.0)).x;\n        float discFrequency = floor(freq * 20.0) / 20.0;\n        \n        vec3 boxPoint = point - vec3(1.0 * i, 0, 0);\n        finalT = UnionSDF(finalT, BoxSDF(boxPoint, vec3(.1, pow(discFrequency, 4.0) * 3.0,.1)));\n    }\n    \n    \n    return finalT;\n}\n\n//The repeated scene\nfloat RepeatedSceneSDF(vec3 point) \n{\n\n    point = point - vec3(0, 0, 0);\n    vec3 repeatedPoint = opRep(point, vec3(10, 10, 10));\n    float finalT = RepeatedSceneSingleInstance(repeatedPoint);\n    \n    return finalT;\n}\n\n\n//The single instance scene\nfloat NormalScene(vec3 point, Light light1, Light light2, Light light3)\n{\n    vec3 lightPoint = point - light1.Position;\n    float t = SphereSDF(lightPoint, .5);\n    \n    lightPoint = point - light2.Position;\n    t = UnionSDF(t, SphereSDF(lightPoint, .5));\n    \n    lightPoint = point - light3.Position;\n    t = UnionSDF(t, SphereSDF(lightPoint, .5));\n    return t;\n}\n\n\nvec3 GenerateNormal(vec3 point, Light light1, Light light2, Light light3) \n{\n    vec3 normal = vec3(0,0,0);\n    \n    normal.x  = RepeatedSceneSDF(vec3(point.x + EPSILON, point.y, point.z));\n    normal.x -= RepeatedSceneSDF(vec3(point.x - EPSILON, point.y, point.z));\n    \n    normal.y  = RepeatedSceneSDF(vec3(point.x, point.y + EPSILON, point.z));\n    normal.y -= RepeatedSceneSDF(vec3(point.x, point.y - EPSILON, point.z));\n    \n    normal.z  = RepeatedSceneSDF(vec3(point.x, point.y, point.z + EPSILON));\n    normal.z -= RepeatedSceneSDF(vec3(point.x, point.y, point.z - EPSILON));\n\n    return normalize(normal);\n}\n\nfloat RayMarch(Ray ray, float startingTValue, float maxTValue) \n{\n    float currentT = startingTValue;\n    \n    for(int i = 0; i < MAX_MARCH_STEPS; ++i) \n    {\n        vec3 point = ray.Origin + ray.Direction * currentT;\n        \n        float closestTValue = RepeatedSceneSDF(point);\n        currentT += closestTValue;\n        \n        if(closestTValue < EPSILON || closestTValue > maxTValue) \n        {\n            return currentT;\n        }\n    }\n    \n    return currentT;\n}\n\nfloat RayMarchLights(Ray ray, float startingTValue, float maxTValue, Light light1, Light light2, Light light3) \n{\n    float currentT = startingTValue;\n    \n    for(int i = 0; i < MAX_MARCH_STEPS; ++i) \n    {\n        vec3 point = ray.Origin + ray.Direction * currentT;\n        \n        float closestTValue = NormalScene(point, light1, light2, light3);\n        currentT += closestTValue;\n        \n        if(closestTValue < EPSILON || closestTValue > maxTValue) \n        {\n            return currentT;\n        }\n    }\n    \n    return currentT;\n}\n\nvec3 GetNormal(vec3 point, Light light1, Light light2, Light light3) \n{\n    return GenerateNormal(point, light1, light2, light3);\n}\n\nfloat Diffuse(vec3 point, vec3 normal, Light light) \n{\n    \n    vec3 lightVector = normalize(light.Position - point);\n    \n    float cosAngle = max(dot(lightVector, normal), 0.0);\n    \n    return max(cosAngle, 0.0);\n}\n\nfloat Specular(vec3 point, vec3 normal, Camera camera, Light light, float shinyNess) \n{\n    vec3 lightVector = normalize(light.Position - point);\n    lightVector = reflect(lightVector, normal);\n    vec3 viewVector = normalize(camera.Position - point);\n    \n    float cosAngle = pow(max(dot(-lightVector, viewVector), 0.0), shinyNess);\n    \n    return max(cosAngle, 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Generating our ray\n    vec2 uvRay = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    \n    vec3 col = vec3(0,0,0);\n    \n    //Construct camera\n    Camera camera;\n    camera.Position = vec3(cos(iTime * .25) * 30.0, 5, sin(iTime * .25) * 20.0);\n    camera.Up = vec3(0, 1, 0);\n    camera.LookAt = vec3(5, 1, 0);\n    \n    mat4 worldToView = ViewMatrix(camera);\n    \n    vec4 worldDirection = normalize(vec4(uvRay, -1, 0));\n    vec4 viewDir = worldToView * worldDirection;\n    \n    //Get view ray\n    Ray ray;\n    ray.Origin = camera.Position;\n    ray.Direction = viewDir.xyz;\n    \n    float bassFreq = texture(iChannel0, vec2((.1), 0.0)).x;\n    float medFreq = texture(iChannel0, vec2((.2), 0.0)).x;\n    medFreq += texture(iChannel0, vec2((.3), 0.0)).x;\n    medFreq += texture(iChannel0, vec2((.4), 0.0)).x;\n    medFreq = medFreq / 3.0;\n    \n    float topFreq = texture(iChannel0, vec2((.5), 0.0)).x;\n    topFreq += texture(iChannel0, vec2((.6), 0.0)).x;\n    topFreq += texture(iChannel0, vec2((.7), 0.0)).x;\n    topFreq += texture(iChannel0, vec2((.8), 0.0)).x;\n    topFreq += texture(iChannel0, vec2((.9), 0.0)).x;\n    topFreq = topFreq / 5.0f;\n    \n    vec3 lightColor = vec3(1, 0.533, 0.066);\n    \n    //Define our lights\n    Light light1;\n    light1.Position = camera.LookAt + vec3(cos(iTime * 1.0), .25, sin(iTime * 1.0)) * 10.0;\n    light1.Color = BASE_LIGHT * lightColor;\n    vec3 light1ModulatedColor = BASE_LIGHT * lightColor + lightColor * LIGHT_INTENSITY * bassFreq;\n    \n    lightColor = vec3(0.125, 0.639, 0.619);\n    Light light2;\n    light2.Position = camera.LookAt + vec3(cos(PI23 + iTime * 1.0), .25, sin(PI23 + iTime * 1.0)) * 10.0;\n    light2.Color = BASE_LIGHT * lightColor;\n    vec3 light2ModulatedColor = BASE_LIGHT * lightColor + lightColor * LIGHT_INTENSITY * medFreq;\n    \n    lightColor = vec3(0.615, 0, 1);\n    Light light3;\n    light3.Position = camera.LookAt + vec3(cos(2.0 * PI23 + iTime * 1.0), .25, sin(2.0 * PI23 + iTime * 1.0)) * 10.0;\n    light3.Color = BASE_LIGHT * lightColor;\n    vec3 light3ModulatedColor = BASE_LIGHT * lightColor + lightColor * LIGHT_INTENSITY * topFreq;\n    \n    //March the ray into the scene and find our collision point\n    float rayTValue = RayMarch(ray, 0.0, 100.0);\n    \n    //Determine our point\n    vec3 point = ray.Origin + ray.Direction * rayTValue;\n    float closestTValue = RepeatedSceneSDF(point);\n    \n    //If we hit something, shade the point\n    if(closestTValue < EPSILON) \n    {\n        vec3 surfaceColor = vec3(1.0f, 1.0f, 1.0f);\n        vec3 normal = GetNormal(point, light1, light2, light3);\n        col = surfaceColor * .2f;  \n         \n        col += Diffuse(point, normal, light1) * light1ModulatedColor * surfaceColor;\n        col += Specular(point, normal, camera, light1, 10.0) * light1ModulatedColor * surfaceColor;\n        col += Diffuse(point, normal, light2) * light2ModulatedColor * surfaceColor;\n        col += Specular(point, normal, camera, light2, 10.0) * light2ModulatedColor * surfaceColor;\n        col += Diffuse(point, normal, light3) * light3ModulatedColor * surfaceColor;\n        col += Specular(point, normal, camera, light3, 10.0) * light3ModulatedColor * surfaceColor;\n    }\n    \n    //Separate pass from lights as they aren't repeated and may occlude found point\n    float lightTayTValue = RayMarchLights(ray, 0.0, 100.0, light1, light2, light3);\n    point = ray.Origin + ray.Direction * lightTayTValue;\n    closestTValue = NormalScene(point, light1, light2, light3);\n    if(lightTayTValue < rayTValue && closestTValue < EPSILON) \n    {\n        col = vec3(1, 1, 1);\n        \n        vec3 lightPoint = point - light1.Position;\n        float t = SphereSDF(lightPoint, .5);\n        \n        if(t < EPSILON) \n        {\n            col = light1.Color * 2.0;\n        }\n        else\n        {\n            lightPoint = point - light2.Position;\n            t = SphereSDF(lightPoint, .5);\n            if(t < EPSILON) \n            {\n                col = light2.Color * 2.0;\n            }\n            else \n            {\n                col = light3.Color * 2.0;\n            }\n        }\n        \n        col *= 4.0;\n        \n        rayTValue = lightTayTValue;\n    }\n    \n    //Depth fog\n    col = mix(col, vec3(0, 0, 0), min(rayTValue / 100.0, 1.0));\n    \n    // Output to screen\n    fragColor = vec4(col, rayTValue);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\n    //hastily attempted bloom\n    vec2 q = fragCoord / iResolution.xy;\n    \n    vec4 baseColor = texture(iChannel0, q);\n    \n    vec3 color = vec3(0,0,0);\n    const int N = 3;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off/vec2(800.0,450.0)); \n        \n        vec3 tmpColor = tmp.xyz;\n        \n        float brightness = dot(tmpColor.rgb, vec3(0.3, 0.7152, 0.0722));\n        \n        if(brightness > 1.0)\n        {\n            color.rgb += tmpColor * .1;\n        }\n    }\n    \n    fragColor = vec4(baseColor.rgb + color, baseColor.w);\n}","name":"Buffer C","description":"","type":"buffer"}]}