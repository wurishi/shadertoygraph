{"ver":"0.1","info":{"id":"llc3z8","date":"1472673002","viewed":112,"name":"[OLD]Ray-casting","username":"Sabouh","description":"Displaying height map, normal map and color map .\n2 spheres and 3 planes\nYou can move around using your mouse","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ray","raycasting","raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Inspired by inigo quilez's articles \n https://iquilezles.org/articles/distfunctions\n + Romain Vergne's lectures \nhttp://romain.vergne.free.fr\n\n Ray casting\n Author : Sabouh\n Creation : 2016-08-31\n*/\n \n//to get a higher float precision\nprecision highp float;\nconst float PI = 3.1415926535897932384626433832795;\nconst int PLANE_NB = 3;\nconst int SPHERE_NB = 2;\nconst int OBJ_NB = PLANE_NB + SPHERE_NB;\nconst int MAX_NB = 10;\nconst float MAX_VALUE = 100.;\nconst int MAX_INT_VALUE = 1000;\nconst vec4 background = vec4(1.,1.,1.,1.);\n\n//*******************************Tools**************************\n//Structures definition\n//Ray\nstruct Ray{\n\tvec3 o; //origin\n\tvec3 d; //direction\n};\n\n//Camera\nstruct Camera{\n\tvec3 e;//eye\n    vec3 r;//right\n    vec3 u;//up\n    vec3 v;//view\n\t\n};\n\nstruct Color{\n\tvec4 c;\n};\n\n//Plane\nstruct Plane{\n\tvec3 n; //normal\n\tfloat d; //offset\n};\n\n//Sphere\nstruct Sphere{\n\tvec3 c; //center\n\tfloat r; //rayon\n};\n\n//Distance functions\n\nfloat sdSphere( vec3 p, vec4 o){\n\treturn dot(p - o.xyz,p - o.xyz) - pow(o.w,2.);\n}\n\n\n//n.xyz is the normal and n.w the offset\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat sdSphereOrigin( vec3 p, float s){\n\treturn length(p)-s;\n}\n\n//--------------------------Distance operations\n\n//union\nvec2 opU(vec2 d1,vec2 d2){\n\treturn d1.x<d2.x ? d1 : d2; //if d1.x < d2.x return d1 else d2\n}\n\n//substraction\nfloat opS(float d1, float d2){\n\treturn max(-d1,d2);\n}\n\n//intersection\nfloat opI(float d1,float d2){\n\treturn max(d1,d2);\n}\n\n\n//---------------------------Intersections\n\n//intersection Ray-Sphere\nvec2 intersectSphere(Ray r, vec4 o, float index){\n\tfloat a,b,c;\n\ta = dot(r.d,r.d);\n\tb = dot(2.*(r.o-o.xyz),r.d);\n\tc =(dot(r.o-o.xyz,r.o-o.xyz)) - pow(o.w,2.) ;\n\t\n\tfloat delta =  pow(b,2.)-4.*a*c ;\n\tif(delta <0.){\n\t\treturn vec2(MAX_VALUE,-1);\n\t}else{\n\t\tfloat t1,t2;\n\t\tt1 = (-b + sqrt(delta) )/(2.*a);\n\t\tt2 = (-b - sqrt(delta) )/(2.*a);\n\t\tif(t1 <0.){\n\t\t\treturn vec2(t2,index);\n\t\t}else if(t2<0.){\n\t\t\treturn vec2(t1,index);\n\t\t}else{\n\t\t\treturn t1<t2 ? vec2(t1,index) : vec2(t2,index);\n\t\t}\n\t}\n}\n\n//intersection Ray-Plane\nvec2 intersectPlane(Ray r, vec4 n,float index){\n    vec3 norm = normalize(n.xyz);\n\tfloat t = -( n.w + dot(r.o,norm)) / dot(r.d,norm);\n\tif(t>=0.){\n\t\treturn vec2(t,index);\n\t\t\n\t}else{\n\t\treturn vec2(MAX_VALUE,-1);\n\t}\n}\n\n//manage intersections \nvec2 checkIntersection(Ray r, vec4 o, float index){\n\tif(index <= float(PLANE_NB) ){\n\t\treturn intersectPlane(r,o,index);\n\t}else{\n\t\treturn intersectSphere(r,o,index);\n\t}\n}\n\n\n//--------------------SCENE\n//Colors for each object\nvec4 getColor(float index){\n\t//vec4 colors[OBJ_NB] colors = vec4[](vec4(1,0,0,1),vec4(0,0,1,1));\n\tif(index == 1.){\n\t\treturn vec4(0.,1.,1.,1.); //cyan\n\t}else if(index == 2.){\n\t\treturn vec4(0.,1.,0.,1.); //green\n\t}else if(index == 3.){\n\t\treturn vec4(0.,0.,1.,1.); //blue\n\t}else if(index == 4.){\n\t\treturn vec4(1.,0.,0.,1.); //red\n\t}else if(index == 5.){ \n\t\treturn vec4(1.,1.,0.,0.); //yellow\n\t}else{\n\t\treturn background;//ERROR WHITE\n\t\t\n\t}\n}\n\nvec4 createSphere(vec3 c, float r, float phi, float teta){\n\tfloat x,y,z;\n\tx = c.x + r*sin(phi)*cos(teta);\n\ty = c.y + r*sin(phi)*sin(teta);\n\tz = c.z + r*cos(phi);\n    return vec4(x,y,z,r);\n    \n}\n\nvec4 getObject(float index){\n\tif(index == 1.){\n\t\treturn vec4(0.,0.,1.,0.); //Plan (x,y)\n\t}else if(index == 2.){\n\t\treturn vec4(1.,0.,0.,0.); //Plan (y,z)\n\t}else if(index == 3.){\n\t\treturn vec4(0.,1.,0.,0.); //Plan (x,z)\n\t}else if(index == 4.){;\n\t\treturn createSphere(vec3(2.,2.,2.), 1., PI/2., PI/2.*iTime); \n\t}else if(index == 5.){ \n\t\treturn createSphere(vec3(2.,2.,2.), 0.8, PI/2.*iTime, PI); \n\t}else{\n\t\treturn vec4(MAX_VALUE,MAX_VALUE,MAX_VALUE,MAX_VALUE);//ERROR \n\t\t\n\t}\t\n}\n\n\n//RayCasting\nvec4 rayCasting(vec2 fragCoord){\n\t//cast a ray w/ camera\n\t\n\t//(x,y) in range [-1;1] \n\tfloat x = (2.*fragCoord.x - iResolution.x )/iResolution.x;\n\tfloat y = (2.*fragCoord.y - iResolution.y )/iResolution.y;\n    \n\tfloat xMouse = (2.*iMouse.x - iResolution.x )/iResolution.x;\n\tfloat yMouse = (2.*iMouse.y - iResolution.y )/iResolution.y;\n\t\n\t//camera\n\tCamera c;\n    vec3 u1;\n\t//c.e = vec3(xMouse,yMouse,-2.);//mouse\n\tc.e = vec3(xMouse*10.,yMouse*10.,5.);//mouse\n\t//c.e = vec3(10.,1.,10.);//mouse\n\tc.v = normalize(-c.e);\n\tu1 = vec3(0.,1.,0.);\n\tc.r = normalize(cross(c.v,u1));\n\tc.u = normalize(cross(c.r,c.v));\n\t\n\t//Ray\n\tRay r;\n\tfloat D = 1./tan(PI/4.);\n\tr.o = c.e;\n\tvec3 rd = x*c.r + y *c.u+ D*c.v;\n\tr.d = normalize(rd);\n\t\t\n    float t = 0.;\n\tfloat t1 = 0.1;\n\tfloat index;\n\tvec3 pos; \n    \t\n\tvec2 minDist = vec2(MAX_VALUE,-1);\n\tvec2 maxDist = vec2(-1,-1);\n    \n\tfloat j;\n    //for each object of the scene\n\tfor(int i=1; i<=OBJ_NB ;i++){\n\t\t//test intersection btw ray and object\n\t\tj=float(i);\n\t\tvec2 dist = checkIntersection(r,getObject(j),j);\t\n\t\t//remember the object if dist < previous tests\n\t\tif(dist.y != -1. && dist.x < minDist.x){\n\t\t\tminDist = dist;\n\t\t}\n\t}\n\t//compute pixel colour\n    \n    \n    \n    if(mod(iTime,3.) <1.){\n    \t//color map\n\t\treturn getColor(minDist.y);\n    }else if(mod(iTime,3.) <2. ){\n    \t//height map\n        float h = minDist.x/(c.e.z*2.);\n     \treturn vec4(h,h,h,1.);\n    }else{\n    \t//normal map\n    \tif(minDist.y <= float(PLANE_NB)){\n        \treturn vec4((getObject(minDist.y)).xyz,1.0) ;\n    \t}else{\n        \tpos = r.o + r.d*minDist.x;\n        \tvec3 n = pos - getObject(minDist.y).xyz;\n\t\t\treturn vec4(n,1.0);\n    \t}\n    }\n    \n}\n\n\n\n//************************Application********************************************\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t  \n\tfragColor = rayCasting(fragCoord);\n    \n}","name":"Image","description":"","type":"image"}]}