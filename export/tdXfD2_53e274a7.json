{"ver":"0.1","info":{"id":"tdXfD2","date":"1589191440","viewed":82,"name":"final project","username":"meanjeekim","description":"cis561 final","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n    \n    //create the 1-D kernel\n    float sigma = 20.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    \n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel0, uv);\n    \n    fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RAY_STEPS 256\n#define PI 3.14159\n\nconst float FOCAL_LENGTH = 16.0;\nconst float FOCAL_RANGE = 16.0;\n\nconst float FOVY = 3.141569 * 0.25;\n\n\n\nstruct Intersection {\n    float t;\n    vec3 p;\n    vec3 color;\n    int object;\n};\n\n// SDFs, CSG by inigo quilez\n    \nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat onion( in float sdf, in float thick )\n{\n    return abs(sdf)-thick;\n}\n    \nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    return vec3(cos(a) * p.x - sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\n//sphere sdf\nfloat sphere(vec3 p, float r, vec3 c) {\n \treturn distance(p, c) - r;   \n}\n\n//box sdf\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\n//plane sdf\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n/*\n  Defining SDFs\n*/\n\n#define LIGHT_POS vec3(0., 7.45, 0.)\n\n#define BACKGROUND_SDF plane(pos, vec4(0.0, 0.0, -1.0, 6.0))\n#define CEILING_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 2.0))\n\nfloat sky(vec3 pos) {\n    vec3 q = opRep(pos - vec3(iTime, 4.0, 20.0), vec3(5.0));\n    \n    \n\tfloat sph1 = sphere(q, 0.5, vec3(0.0, 3.0, 1.0));\n    \n    float sph2 = sphere(q, 0.5, vec3(0.5, 2.5, 1.0));\n    float fin = opSmoothUnion(sph1, sph2, 0.2);\n    \n    \n    float sph3 = sphere(q, 0.6, vec3(0.7, 3.2, 0.8));\n    fin = opSmoothUnion(fin, sph3, 0.3);\n        \n    float sph4 = sphere(q, 0.6, vec3(-0.1, 2.4, 0.8));\n    fin = opSmoothUnion(fin, sph4, 0.2);\n    \n    float sph5 = sphere(q, 0.5, vec3(-0.8, 2.7, 0.8));\n    fin = opSmoothUnion(fin, sph5, 0.2);\n    \n    float sph6 = sphere(q, 0.5, vec3(1.3, 2.7, 0.8));\n    fin = opSmoothUnion(fin, sph6, 0.2);\n    \n    \n    \n    return fin;\n}\n\nfloat rings(vec3 pos) {\n    vec3 q = rotateX(pos - vec3(0.0, 5.15, 0.0), PI/2.f);\n    vec3 q2 = pos - vec3(0.0, 5.6, 0.0);\n    \n    float ring1 = sdTorus(q, vec2(0.3, 0.05));\n    float strap1 = sdRoundBox(q2, vec3(0.05, 0.2, 0.03), 0.05);\n    float fin = opUnion(ring1, strap1);\n    \n    float ring2 = sdTorus(q - vec3(2.0, 0.0, 0.0), vec2(0.3, 0.05));\n    float strap2 = sdRoundBox(q2 - vec3(2.0, 0.0, 0.0), vec3(0.05, 0.2, 0.03), 0.05);\n    fin = opUnion(ring2, fin);\n    fin = opUnion(strap2, fin);\n    \n    float ring3 = sdTorus(q - vec3(4.0, 0.0, 0.0), vec2(0.3, 0.05));\n    float strap3 = sdRoundBox(q2 - vec3(4.0, 0.0, 0.0), vec3(0.05, 0.2, 0.03), 0.05);\n    fin = opUnion(ring3, fin);\n    fin = opUnion(strap3, fin);\n    \n    float ring4 = sdTorus(q - vec3(6.0, 0.0, 0.0), vec2(0.3, 0.05));\n    float strap4 = sdRoundBox(q2 - vec3(6.0, 0.0, 0.0), vec3(0.05, 0.2, 0.03), 0.05);\n    fin = opUnion(ring4, fin);\n    fin = opUnion(strap4, fin);\n    \n    float ring5 = sdTorus(q - vec3(8.0, 0.0, 0.0), vec2(0.3, 0.05));\n    float strap5 = sdRoundBox(q2 - vec3(8.0, 0.0, 0.0), vec3(0.05, 0.2, 0.03), 0.05);\n    fin = opUnion(ring5, fin);\n    fin = opUnion(strap5, fin);\n    \n    float ring6 = sdTorus(q + vec3(2.0, 0.0, 0.0), vec2(0.3, 0.05));\n    float strap6 = sdRoundBox(q2 + vec3(2.0, 0.0, 0.0), vec3(0.05, 0.2, 0.03), 0.05);\n    fin = opUnion(ring6, fin);\n    fin = opUnion(strap6, fin);\n    \n    float ring7 = sdTorus(q + vec3(4.0, 0.0, 0.0), vec2(0.3, 0.05));\n    float strap7 = sdRoundBox(q2 + vec3(4.0, 0.0, 0.0), vec3(0.05, 0.2, 0.03), 0.05);\n    fin = opUnion(ring7, fin);\n    fin = opUnion(strap7, fin);\n    \n    float ring8 = sdTorus(q + vec3(6.0, 0.0, 0.0), vec2(0.3, 0.05));\n    float strap8 = sdRoundBox(q2 + vec3(6.0, 0.0, 0.0), vec3(0.05, 0.2, 0.03), 0.05);\n    fin = opUnion(ring8, fin);\n    fin = opUnion(strap8, fin);\n    \n    float ring9 = sdTorus(q + vec3(8.0, 0.0, 0.0), vec2(0.3, 0.05));\n    float strap9 = sdRoundBox(q2 + vec3(8.0, 0.0, 0.0), vec3(0.05, 0.2, 0.03), 0.05);\n    fin = opUnion(ring9, fin);\n    fin = opUnion(strap9, fin);\n    \n    \n    return fin;\n}\n\nfloat back_wall(vec3 pos) {\n\tfloat main = box(pos - vec3(0.0, 0.0, 5.5), vec3(15.0, 15.0, 0.3));\n    \n    float box1 = box(pos - vec3(0.0, 6.0, 7.5), vec3(2.5, 3.0, 3.0));\n    float box2 = box(pos - vec3(6.0, 6.0, 7.5), vec3(2.5, 3.0, 3.0));\n    float box3 = box(pos - vec3(-6.0, 6.0, 7.5), vec3(2.5, 3.0, 3.0));\n    float box4 = box(pos - vec3(12.0, 6.0, 7.5), vec3(2.5, 3.0, 3.0));\n    float box5 = box(pos - vec3(-12.0, 6.0, 7.5), vec3(2.5, 3.0, 3.0));\n    float fin = opSubtraction(box1, main);\n    fin = opSubtraction(box5, opSubtraction(box4, opSubtraction(box3, opSubtraction(box2, fin))));\n    return fin;\n}\n\nfloat seats(vec3 pos) {\n    vec3 q = pos - vec3(0.0, 1.5, 6.0);\n    \n    float box1 = sdRoundBox(q, vec3(10.0, 1.0, 1.0), 0.3);\n    float box2 = sdRoundBox(q - vec3(0.0, -1.5, -1.0), vec3(10.0, 0.2, 1.5), 0.3);\n    float fin = opUnion(box1, box2);\n    \n    return fin;\n}\n\nfloat seatBottom(vec3 pos) {\n\tvec3 q = pos - vec3(0.0, -1.0, 5.0);\n    \n    float box1 = box(q, vec3(10.0, 0.6, 1.5));\n    float box2 = box(q - vec3(0.0, -0.07, -1.5), vec3(1.5, 0.4, 0.1));\n    float fin = opSubtraction(box2, box1);\n    float box_in1 = box(q - vec3(0.0, -0.05, -1.5), vec3(1.4, 0.3, 0.2));\n    fin = opSubtraction(box_in1, fin);\n    \n    float box3 = box(q - vec3(3.5, -0.07, -1.5), vec3(1.5, 0.4, 0.1));\n    fin = opSubtraction(box3, fin);\n    float box_in3 = box(q - vec3(3.5, -0.05, -1.5), vec3(1.4, 0.3, 0.2));\n    fin = opSubtraction(box_in3, fin);\n    \n    float box4 = box(q - vec3(7.0, -0.07, -1.5), vec3(1.5, 0.4, 0.1));\n    fin = opSubtraction(box4, fin);\n    float box_in4 = box(q - vec3(7.0, -0.05, -1.5), vec3(1.4, 0.3, 0.2));\n    fin = opSubtraction(box_in4, fin);\n    \n    float box5 = box(q - vec3(-3.5, -0.07, -1.5), vec3(1.5, 0.4, 0.1));\n    fin = opSubtraction(box5, fin);\n    float box_in5 = box(q - vec3(-3.5, -0.05, -1.5), vec3(1.4, 0.3, 0.2));\n    fin = opSubtraction(box_in5, fin);\n    \n    float box6 = box(q - vec3(-7.0, -0.07, -1.5), vec3(1.5, 0.4, 0.1));\n    fin = opSubtraction(box6, fin);\n    float box_in6 = box(q - vec3(-7.0, -0.05, -1.5), vec3(1.4, 0.3, 0.2));\n    fin = opSubtraction(box_in6, fin);\n    \n    return fin;\n}\n\nfloat noface_bod(vec3 pos) {\n    vec3 q = pos - vec3(0.0, 1.0, 4.0);\n    \n    float top = sphere(pos, 1.0, vec3(0.0, 4.0, 4.0));\n    float mid = sdRoundCone(q, 1.9, 1.0, 2.0);\n    float fin = smin(top, mid, 1.0);\n    \n    float bot = sdRoundBox(q - vec3(0.0, -2.0, 0.0), vec3(1.5, 1.0, 0.5), 0.4);\n    fin = smin(fin, bot, 1.0);\n    \n    return fin;\n}\n\nfloat noface_head(vec3 pos) {\n    //vec3 q = rotateX(pos - vec3(0.0, 3.8, 2.5), PI/2.f);\n    \n    vec3 q = pos - vec3(0.0, 2.7, 3.5);\n    \n    float top = sdRoundCone(q, 0.8, 0.9, 1.0);\n    float eye = sdRoundBox(q - vec3(-0.5, 1.0, -0.8), vec3(0.08, 0.01, 0.3), 0.07);\n    float eye1_under = sdRoundBox(q - vec3(-0.5, 0.8, -0.8), vec3(0.05, 0.005, 0.3), 0.05);\n    float fin = opSubtraction(eye, top);\n    fin = opSubtraction(eye1_under, fin);\n    \n    float eye2 = sdRoundBox(q - vec3(0.5, 1.0, -0.8), vec3(0.08, 0.01, 0.3), 0.07);\n    float eye2_under = sdRoundBox(q - vec3(0.5, 0.8, -0.8), vec3(0.05, 0.005, 0.3), 0.05);\n    fin = opSubtraction(eye2, fin);\n    fin = opSubtraction(eye2_under, fin);\n    \n    float mouth = sdRoundBox(q - vec3(0.0, 0.25, -0.8), vec3(0.15, 0.01, 0.1), 0.07);\n    float mouth_under = sdRoundBox(q - vec3(0.0, 0.1, -0.8), vec3(0.05, 0.005, 0.2), 0.03);\n    fin = opSubtraction(mouth, fin);\n    fin = opSubtraction(mouth_under, fin);\n    \n    \n    //float fin = top;\n    return fin;\n}\n\nfloat noface_eyemarks(vec3 pos) {\n    vec3 q = pos - vec3(0.0, 2.7, 3.5);\n    \n    //float top = sdRoundCone(q, 0.8, 0.9, 1.0);\n    float eye = sdRoundCone(q - vec3(-0.45, 1.25, -0.65), 0.12, 0.05, 0.15);\n    float eye1_under = sdRoundCone(q - vec3(-0.5, 0.35, -0.65), 0.05, 0.12, 0.22);\n    float fin = opUnion(eye1_under, eye);\n    \n    float eye2 = sdRoundCone(q - vec3(0.45, 1.25, -0.65), 0.12, 0.05, 0.15);\n    float eye2_under = sdRoundCone(q - vec3(0.5, 0.35, -0.65), 0.05, 0.12, 0.22);\n    fin = opUnion(eye2, fin);\n    fin = opUnion(eye2_under, fin);\n\n    //float fin = eye;\n    return fin;\n}\n\n#define BACK_WALL 0\n#define BACKGROUND 1\n#define CEILING 3\n#define FLOOR 4\n#define TALL_BOX 5\n#define SMALL_BOX 6\n\n#define SKY 7\n#define SEATS 8\n#define SEAT_BOT 9\n#define RINGS 12\n\n#define NF_BODY 10\n#define NF_HEAD 11\n#define NF_EYES 13\n\nvoid testScene(vec3 pos, out float t, out int obj) {\n    t = back_wall(pos);\n    obj = BACK_WALL;\n  \n    float t2;\n    if ((t2 = CEILING_SDF) < t) {\n        t = t2;\n        obj = CEILING;\n    }\n    if ((t2 = BACKGROUND_SDF) < t) {\n        t = t2;\n        obj = BACKGROUND;\n    }\n    if ((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        obj = FLOOR;\n    }\n    if ((t2 = sky(pos)) < t) {\n        t = t2;\n        obj = SKY;\n    }\n    \n    if ((t2 = rings(pos)) < t) {\n        t = t2;\n        obj = RINGS;\n    }\n    \n    if ((t2 = seats(pos)) < t) {\n        t = t2;\n        obj = SEATS;\n    }\n    if ((t2 = seatBottom(pos)) < t) {\n        t = t2;\n        obj = SEAT_BOT;\n    }\n    \n    if ((t2 = noface_bod(pos)) < t) {\n        t = t2;\n        obj = NF_BODY;\n    }\n    \n    if ((t2 = noface_head(pos)) < t) {\n        t = t2;\n        obj = NF_HEAD;\n    }\n    \n    if ((t2 = noface_eyemarks(pos)) < t) {\n        t = t2;\n        obj = NF_EYES;\n    }\n}\n\nfloat testScene(vec3 pos) {\n \tfloat t = back_wall(pos);\n    float t2;\n    \n    t = min(t, CEILING_SDF);\n    t = min(t, FLOOR_SDF);\n    t = min(t, sky(pos));\n    t = min(t, BACKGROUND_SDF);\n    t = min(t, seats(pos));\n    t = min(t, seatBottom(pos));\n    t = min(t, noface_bod(pos));\n    t = min(t, noface_head(pos));\n    t = min(t, rings(pos));\n    t = min(t, noface_eyemarks(pos));\n    \n    return t;\n}\n    \n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(testScene(pos + epsilon.yxx) - testScene(pos - epsilon.yxx),\n                          testScene(pos + epsilon.xyx) - testScene(pos - epsilon.xyx),\n                          testScene(pos + epsilon.xxy) - testScene(pos - epsilon.xxy))\n                     );\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n \tt = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n        float m;\n        testScene(pos, m, hitObj);\n        if (m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 blinnphong(vec3 p, vec3 color, vec3 n, vec3 lightVec, vec3 view, float exp) {\n\tvec3 fin = vec3(0.0);\n    float ambient = 0.2;\n    \n    vec3 nn = normalize(n);\n    vec3 nlightVec = normalize(lightVec);\n    \n    // lambert\n    float diffuse = max(dot(nn, nlightVec), 0.0);\n    \n    //specular\n    vec3 h = (normalize(view) + nlightVec) / 2.0;\n    \n    float specIntens = max(pow(dot(h, n), exp), 0.0);\n    \n    float lightIntens = diffuse + ambient + specIntens;\n    \n    //compute + add to fin color\n    fin = fin + (lightIntens * color);\n    return fin;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view) {\n    float t;\n    float lambert = dot(lightVec, n);\n    vec3 mat = vec3(0., 0., 0.);\n    \n    switch(hitObj) {\n        case BACK_WALL:\n            mat = vec3(0.3, 0.1, 0.2);\n        \tmat = blinnphong(p, mat, n, lightVec, view, 10.0);\n            break;\n        case BACKGROUND:\n        \tmat = vec3(0.8, 1.0, 0.9);\n        \tbreak;\n        case CEILING:\n            mat = vec3(0.8, 0.8, 0.8);\n        \tmat *= lambert;\n            break;\n        case FLOOR:\n            mat = vec3(0.3, 0.0, 0.2);\n        \tmat = blinnphong(p, mat, n, lightVec, view, 20.0);\n            break;\n        case TALL_BOX:\n            mat = vec3(1., 1., 1.);\n            break;\n        case SMALL_BOX:\n            mat = vec3(0.8, 0.8, 0.8);\n            break;\n        case SKY:\n        \tmat = vec3(1.0, 1.0, 1.0);\n        \tmat *= lambert;\n        \tbreak;\n        case SEATS:\n        \tmat = vec3(0.8, 0.2, 0.3);\n        \tmat *= lambert;\n        \tbreak;\n        case SEAT_BOT:\n        \tmat = vec3(0.3, 0.1, 0.2);\n        \tmat = blinnphong(p, mat, n, lightVec, view, 10.0);\n            break;\n        case NF_BODY:\n        \tmat = vec3(0.1, 0.1, 0.1);\n        \tmat = blinnphong(p, mat, n, lightVec, view, 20.0);\n        \tbreak;\n        case NF_HEAD:\n        \tmat = vec3 (0.95, 0.95, 0.95);\n        \tmat *= lambert;\n        \tmat += vec3(0.1);\n        \tbreak;\n        case NF_EYES:\n        \tmat = vec3(0.9, 0.8, 1.0);\n        \tmat *= lambert;\n        \tbreak;\n        case RINGS:\n        \tmat = vec3(0.5, 0.5, 0.5);\n        \tmat = blinnphong(p, mat, n, lightVec, view, 5.0);\n        \tbreak;\n        case -1:\n            mat = vec3(0., 0., 0.);\n    }\n    return mat;\n}\n\nIntersection sdf3D (vec3 dir, vec3 eye, vec3 lightPos) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect);\n    vec3 lightDir = normalize(lightPos - isect); \n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    if (hitObj == -1) {\n        surfaceColor = vec3(0., 0., 0.);\n    }\n    \n    return Intersection(t, isect, surfaceColor, hitObj);\n}\n\n// returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n \tvec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0, 1, 0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    vec3 ray = normalize(p - eye);\n    ray.x *= -1.; // flip x-axis\n    return ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0.0, 3.0, -8.0);\n    vec3 ref = vec3(0.0, 2.5, 0.0);\n    \n    //vec3 rayDir = rayCast(eye, ref, uv);\n    \n    //Intersection isect = sdf3D(rayDir, eye, LIGHT_POS);\n    //fragColor = vec4(isect.color, 1.);\n    \n    vec3 dir = rayCast(eye, ref, uv);\n  \tIntersection isect = sdf3D(dir, eye, LIGHT_POS);\n    \n    float distAlongCamZ = abs(dot(normalize(ref - eye), (isect.p - eye)));\n    \n    float dofZ = min(1.0, abs(distAlongCamZ - (FOCAL_LENGTH + 10.* sin(iTime))) / FOCAL_RANGE);\n    \n    fragColor = vec4(isect.color * step(0.0, isect.t), dofZ);\n}","name":"Buffer A","description":"","type":"buffer"}]}