{"ver":"0.1","info":{"id":"fljBRw","date":"1651929459","viewed":128,"name":"Jellyfish for Ava","username":"JackFish","description":"A jellyfish that implements reflection and refraction, with Fresnel effect. The color is the support color of Ava in A-SOUL, and jellyfish is the favorite creature of Ava. \nHappy birthday !","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["jellyfish","fresnel","reflect","refract","asoul","asoul"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tMin 0.01\n#define tMax 50.\n#define rayMarchTime 256\n#define epsilon 0.01\n#define PI 3.141592653589\n#define kd vec3(1.)\n#define ka vec3(0.1)\n#define ks vec3(0.1)\n#define DO_AA 1  // 0 to turn off 16x jittered SSAA\n#define DO_REFRACT 1 // 1 to turn on refraction\n#define DO_REFLECT 1 // 1 to turn on reflection with Fresnel effect\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(443.897, 441.423, 437.195));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nint getLightNum()\n{\n    int lightNum = 3;\n    return lightNum;\n}\n\nstruct Light{\n    vec3 lightPos;\n    vec3 lightColor;\n    float lightInten;\n};\n\nLight getLight(int lightIndex)\n{\n    Light light1 = Light(vec3(0., 50., 50.), vec3(1., 1., 1.), 2000.);\n    Light light2 = Light(vec3(50., 50., 0.), vec3(1., 1., 1.), 2000.);\n    Light light3 = Light(vec3(0., 50., -50.), vec3(1., 1., 1.), 2000.);\n\n\n    Light[] lights = Light[](light1, light2, light3);\n\n    return lights[lightIndex];\n}\n\nLight getAmbLight()\n{\n    Light ambLight = Light(vec3(0.), vec3(0.03, 0.018, 0.018), 10.2);\n    return ambLight;\n}\n\nvec2 fixUV(in vec2 c)\n{\n    return 1. * (2. * c - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 ta, vec3 ro, float cr)\n{\n    vec3 z = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.);\n    vec3 x = normalize(cross(z, cp));\n    vec3 y = cross(x, z);\n\n    return mat3(x, y, z);\n}\n\nfloat sdfSphere(in vec3 p, in float radius)\n{\n    float d = length(p) - radius;\n\n    return d;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdfBox(in vec3 p, in vec3 b)\n{\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    \n    return d;\n}\n\nfloat sdfPlane(in vec3 p)\n{\n    return p.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdfEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n\n    return k0*(k0-1.0)/k1;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat sdfTentacle( in vec3 p, in float l, in float a, in float w)\n{\n    \n    // if perfectly straight\n    if( abs(a)<0.001 ) return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n    \n    // parameters\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    \n    // recenter\n    p.x -= ra;\n    \n    // reflect\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot( q+vec2(ra,0.0), q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    \n    return sqrt(d2+p.z*p.z)-w;\n}\n\nvec3 rotZ(vec3 pos, float a) {\n    mat3 mat = mat3(cos(a),-sin(a),0.0,\n                    sin(a),cos(a),0.0,\n                    0.0,0.0,1.0);\n    return pos * mat;\n               \n}\n\nvec3 rotX(vec3 pos, float a) {\n    mat3 mat = mat3(1.0,0.0,0.0,\n                    0.0,cos(a),-sin(a),\n                    0.0,sin(a),cos(a));\n    return pos * mat;\n}\n\nvec3 rotY(vec3 pos, float a) {\n    mat3 mat = mat3(cos(a),0.0,sin(a),\n                    0.0,1.0,0.0,\n                    -sin(a),0.0,cos(a));\n    return pos * mat;\n}\n\n\nfloat sdfJellyFish(in vec3 p)\n{\n    float d;\n\n    d = sdfEllipsoid(p, vec3(4.5,1.5,4.5));\n    d = smin(d, sdfSphere(p - vec3(0.,0.3,0.), 2.1), 4.5);\n    d = smax(d, -sdfEllipsoid(p + vec3(0.,1.2,0.), vec3(4.5,1.5,4.5)), 0.3);\n\n    float tentacle1 = sdfTentacle(rotZ(p, PI) + vec3(-1.,0.,0.), 9., 0.4*2., 0.75);\n    float tentacle2 = sdfTentacle(rotY(rotZ(p, PI),PI) + vec3(-1.,0.,0.), 9., 0.35*2., 0.75);\n    float tentacle3 = sdfTentacle(rotY(rotZ(p, PI),PI*0.5) + vec3(-1.,0.,0.), 9., 0.2*2., 0.75);\n    float tentacle4 = sdfTentacle(rotY(rotZ(p, PI),PI*1.5) + vec3(-1.,0.,0.), 9., 0.35*2., 0.75);\n    \n    d = smin(d, tentacle1, 0.1);\n    d = smin(d, tentacle2, 0.1);\n    d = smin(d, tentacle3, 0.1);\n    d = smin(d, tentacle4, 0.1);\n    \n    return d;\n}\n\n\nvec2 map(in vec3 p)\n{\n    float materialID;\n\n    float jellyFish = sdfJellyFish(p - vec3(0., 5., 0.));\n    float box = sdfBox(p-vec3(0., -13.5, 0.), vec3(9.5));\n\n    float d = min(box, jellyFish);\n\n    if (d == jellyFish)\n    {\n        materialID = 1.;\n    }\n    else if (d == box)\n    {\n        materialID = 2.;\n    }\n    else\n    {\n        materialID = 0.;\n    }\n\n    return vec2(d, materialID);\n}\n\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(in vec3 p)\n{\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map( p + k.xyy * epsilon ).x + \n                     k.yyx * map( p + k.yyx * epsilon ).x + \n                     k.yxy * map( p + k.yxy * epsilon ).x + \n                     k.xxx * map( p + k.xxx * epsilon ).x);\n}\n\n\nfloat softShadow(in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.;\n    float ph = 1e20;\n    for( float t = tMin; t < tMax;)\n    {\n        float h = map(ro + rd * t).x;\n        if(h < epsilon)\n            return 0.;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0., t - y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 getColor(in float materialID, in vec3 pos)\n{\n    vec3 color;\n    if (materialID == 1.) //jellyfish\n    {\n        color = vec3(156., 203., 231.) / 255.;\n    }\n    else if (materialID == 2.) //box\n    {\n        vec2 uv = pos.xz;\n\n        return vec3(mod(floor(uv.x/2.) + floor(uv.y/2.), 2.0) < 1.0 ? 1.0 : 0.4);\n    }\n    else //background\n    {\n        color = texture(iChannel0, pos).rgb;\n    }\n\n    return color;\n}\n\nvec2 rayIntersect(in vec3 ro, in vec3 rd, out vec3 normal)\n{\n    //find the intersection of ray and object, btw return the normal \n    float t = tMin;\n    for (int i = 0; i < rayMarchTime; i++)\n    {\n        vec3 p = ro + t * rd;\n        normal = calcNormal(p);\n        vec2 temp = map(p);\n        float d = abs(temp.x);\n        float materialID = temp.y;\n        if (t >= tMax || d <= epsilon)\n        {\n            return vec2(t, materialID);\n        }\n        t += d;\n    }\n}\n\n\nfloat fresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return f90;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    return mix(f0, f90, ret);\n}\n\nvec3 beerLambertLaw(vec3 absorbRate, float absorbDistance)\n{\n    return exp(-absorbRate * absorbDistance);\n}\n\nvec3 surfaceRendering(in vec3 ro, in vec3 rd, in float t, in vec3 normal, in float materialID)\n{\n    vec3 color = vec3(0.);\n    \n    //use my light structure : lightInten, lightColor, and lightPos\n    int lightNum = getLightNum();\n    Light ambLight = getAmbLight();\n    vec3 ambient = ka * ambLight.lightInten * ambLight.lightColor;\n\n    //get the total color\n    vec3 p = ro + t * rd;\n    for (int i = 0; i < lightNum; i++)\n    {\n        Light light = getLight(i);\n        vec3 v = normalize(-t * rd);\n        vec3 vl = light.lightPos - p;\n        float r2 = pow(length(vl), 2.);\n        vec3 h = normalize(v + vl);\n        vec3 n = normal;\n        vec3 l = normalize(light.lightPos - p);\n        float nh = max(0., dot(n, h));\n\n        vec3 diffuse = kd * light.lightInten / r2 * max(0., dot(n, l)) * light.lightColor;\n        vec3 specular = ks * light.lightInten / r2 * pow(nh, 150.) * light.lightColor;\n\n        //it seems the soft shadow needs to be calculate indepentantly, so we do not use it\n        //float st = softShadow(p, normalize(vl), 10.);\n        float st = 1.;\n\n        color += diffuse * st + specular;\n    }\n    color += ambient;\n    // dont forget to get the object color\n    color *= getColor(materialID, p);\n\n    return color;\n}\n\nvec3 fresnelRendering (in vec3 ro, in vec3 rd, in float t, in vec3 normal, in float materialID)\n{\n\n    vec3 ret = vec3(0.0);\n    float REFRACTIVE_INDEX_OUTSIDE = 1.00;\n    float REFRACTIVE_INDEX_INSIDE = 1.25;\n    \n    float absorbDistance = 0.0;\n\n    vec3 absorb = vec3(0.);\n    vec3 OBJECT_ABSORB = vec3(0.01); \n\n    // move the ray to the intersection point\n    ro += t * rd;\n\n    // calculate how much to reflect or transmit (refract or diffuse)\n    float reflectMultiplier = fresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, normal, rd, 0.05, 1.0);\n    float refractMultiplier = 1.0 - reflectMultiplier;\n\n    #if DO_REFLECT\n        // get reflection color\n        vec3 reflectDir = reflect(rd, normal);\n        vec3 reflectNormal;\n        vec2 reflectIntersect = rayIntersect(ro, reflectDir, reflectNormal);\n        float reflectT = reflectIntersect.x;\n        float reflectMaterialID = reflectIntersect.y;\n        if(reflectT < tMax)\n        {\n            ret = getColor(reflectMaterialID, ro+reflectT*reflectDir) * reflectMultiplier;\n        }\n        else\n        {\n            ret = getColor(0., ro+reflectT*reflectDir) * reflectMultiplier;\n        }\n    #endif\n    \n    #if DO_REFRACT\n        // get refraction color\n        vec3 refractDir = normalize(refract(rd, normal, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE));\n        vec3 refractNormal;\n        vec2 refractIntersect = rayIntersect(ro, refractDir, refractNormal);\n        float refractT = refractIntersect.x;\n        float refractMaterialID = refractIntersect.y;\n        // move the ray to the outway point\n        ro+=refractDir*refractT; //now it is all inside\n        absorbDistance += refractT;\n        absorb = beerLambertLaw(OBJECT_ABSORB, absorbDistance);\n        vec3 outDir = normalize(refract(refractDir, refractNormal, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE));\n        vec3 outNormal;\n        vec2 outIntersect = rayIntersect(ro, outDir, outNormal);\n        float outT = outIntersect.x;\n        float outMaterialID = outIntersect.y;\n        ret += getColor(0., outDir) * refractMultiplier * absorb;\n    #endif\n    \n    return ret;\n}\n\n\nvec3 renderer(vec2 uv)\n{\n    //the origin camera pose, an orbit camera\n    vec3 ro = vec3(15. * sin(iTime/5.), 10., 15. * cos(iTime/5.));\n    //once you click the mouse, change to the desired pose\n    if (iMouse.z > 0.0)\n    {\n        vec2 mouse = fixUV(iMouse.xy);\n        float angleX = iMouse.x / 100.;\n        float angleY = iMouse.y / 100.;\n        float r = 20.;\n        ro = vec3(r*sin(angleX) , r*cos(angleY), r*cos(angleX));\n    }\n    vec3 ta = vec3(0.);\n    mat3 cam = setCamera(ta, ro, 0.);\n    vec3 rd = normalize(cam * vec3(uv, 1.));\n\n    //find the ray-object intersect, btw return normal to reduce the computation\n    vec3 color = vec3(0.);\n    vec3 normal;\n    //return a 2-dim vector as (intersect time, material ID)\n    vec2 temp = rayIntersect(ro, rd, normal);\n    float t = temp.x;\n    float materialID = temp.y;\n\n    if(t < tMax)\n    {\n        #if DO_REFRACT\n            //if only refraction, double the color to get a brighter effect\n            color = fresnelRendering(ro, rd, t, normal, materialID) * 2.;\n        #else\n            color = fresnelRendering(ro, rd, t, normal, materialID) + surfaceRendering(ro, rd, t, normal, materialID);\n        #endif\n    }\n    else\n    {\n        //if no intersection means background\n        color = getColor(0., rd);\n    }\n\n    return color;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec3 finalColor = vec3(0.0);\n    \n    //here is the super-sample code\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            vec2 uv = fixUV(fragCoord + jitter);\n\n            //main renderer code, using raymarching tech\n            vec3 color = renderer(uv);\n            finalColor = mix(finalColor, color, 1.0 / float(i));\n\n        }\n    #else\n        vec2 uv = fixUV(fragCoord);\n\n   \t\tfinalColor = renderer(uv);\n    #endif\n\n    fragColor = vec4(finalColor, 1.);\n\n}","name":"Image","description":"","type":"image"}]}