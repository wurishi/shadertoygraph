{"ver":"0.1","info":{"id":"7tscW4","date":"1648061970","viewed":195,"name":"Gyroid inside sphere","username":"rucksack","description":"Got some rendering artifacts :)))))\nInspired by https://www.youtube.com/watch?v=-adHIyjIYgk","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// For easily pasting this into a project I'm working on\n#define time iTime\n\n// Raymarching parameters\n#define MAX_STEPS 300\n#define NEAR_ENOUGH 0.001\n#define TOO_FAR 20.0\n#define NORMAL_DELTA 0.03\n\n// Lighting parameters\n#define DIFFUSE_FACTOR 0.6\n#define SPECULAR_FACTOR .6\n#define SHININESS 6.\n\n#define BACKGROUND_COLOR vec3(0., 0., 0.)\n#define SURFACE_COLOR vec3(0.76471,0.78039,0.78039)\n#define BLOOM_COLOR vec3(0.84314,0.67843,0.39216)\n\n// Parameters\n#define SMOOTH_FACTOR 0.3\n#define BLOOM_STEP 0.04\n\nfloat sphere(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\nfloat distance_from_everything(vec3 point) {\n    // sphere encapsulating gyroid\n    float s = sphere(point, vec3(0, 0, 2.), 3.);\n    float scale = 2.4;\n    float bias = 0.;\n    float thickness = .1;\n    float a = .5*(cos(time)+2.);\n    float b = .7*(sin(time) + 2.);\n    point *= scale;\n    // gyroid\n    float d = (abs(dot(sin(point*a), cos(point.zxy*b)))-bias)/scale - thickness;\n    d = max(d*.4, s);\n    return d;\n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction) {\n    // How far we've traveled\n    float d = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on\n        d += current_distance*.8; // As suggested by elenzil\n        // Check status - have we reached a surface?\n        if (current_distance < NEAR_ENOUGH || d > TOO_FAR)\n            break;\n    }\n    return d;\n}\n\n// See https://iquilezles.org/articles/normalsSDF\nvec3 estimate_normal(vec3 point) {\n    vec2 e = vec2(NORMAL_DELTA, 0); // x smol, y none\n    // Find normal as tangent of distance function\n    return normalize(vec3(\n        distance_from_everything(point + e.xyy) - distance_from_everything(point - e.xyy),\n        distance_from_everything(point + e.yxy) - distance_from_everything(point - e.yxy),\n        distance_from_everything(point + e.yyx) - distance_from_everything(point - e.yyx)\n    ));\n}\n\nfloat phong_light(vec3 point, vec3 light_position, vec3 n, vec3 camera) {\n    vec3 l = normalize(light_position-point);\n    vec3 c = normalize(camera-point);\n    // Standard diffuse term\n    float diffuse = max(dot(n, l), 0.);\n    float specular = pow(max(dot(reflect(-l, n), -c), 0.), SHININESS);\n\n    return DIFFUSE_FACTOR * diffuse + SPECULAR_FACTOR * specular;\n}\n\nfloat bloom(vec3 ray_origin, vec3 ray_direction) {\n    float bloom = 0.0;\n    float stepdist = NEAR_ENOUGH;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 point = ray_origin + ray_direction*stepdist;\n        float nextdist = distance_from_everything(point);\n        // Update bloom\n        bloom += BLOOM_STEP;\n        // March on\n        stepdist += nextdist;\n        // Continue even if we reach a surface\n        if (stepdist > TOO_FAR)\n            break;\n    }\n    // Stop bloom from exceeding 1\n    return min(bloom, 1.);\n}\n\nvec3 lighting(vec3 point, vec3 camera, vec3 ray_direction, float dist) {\n    // Avoid casting specular highlight from the void\n    // (and blend in bloom)\n    float bloom = bloom(camera, ray_direction);\n    if (length(point - camera) > TOO_FAR*0.99)\n        return BACKGROUND_COLOR + bloom * BLOOM_COLOR;\n\n    float phong = phong_light(point, vec3(1, 1, -2), estimate_normal(point), camera);\n\n    return phong * SURFACE_COLOR + .5*sqrt(bloom) * BLOOM_COLOR;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    // Ray origin\n    vec3 camera = vec3(0., 0, -4.);\n    // Ray direction\n    vec3 ray_direction = vec3(xy, 1.);\n\n    float d = ray_march(camera, ray_direction);\n    \n    vec3 point = camera + ray_direction * d;\n    \n    vec3 base_color = lighting(point, camera, ray_direction, d);\n\n    fragColor = vec4(base_color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}