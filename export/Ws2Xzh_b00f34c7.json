{"ver":"0.1","info":{"id":"Ws2Xzh","date":"1552937037","viewed":203,"name":"Camera with Chromatic Aberration","username":"pyrite","description":"This models a physical camera, with the ability to handle unique focal lengths for each color channel. \nThe camera models a planar sensor, and a circular singlet lens with a flat focal plane. \nSee code comments for detailed info. ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["dof","chromatic","aberration","ssaa","physical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float asphere(in vec3 ro, in vec3 rd, in vec3 sp, in float sr){ \n    // geometric solution\n    float sr2 = sr*sr;\n    vec3 e0 = sp - ro; \n    float e1 = dot(e0,rd);\n    float r2 = dot(e0,e0) - e1*e1; \n    if (r2 > sr2) return 1e10; // 1e10 is a \"miss\" value. unlikely to appear in \"hit\" data.\n    float e2 = sqrt(sr2 - r2); \n    return e1-e2; \n}\n\n\nfloat amap(in vec3 ro, in vec3 rd){ \n    return min(asphere(ro,rd,vec3(0.0,0.0,0.0), 1.5),\n               min(asphere(ro,rd,vec3(-2,0.0,0.0),1.0), \n                   min(asphere(ro,rd,vec3(0.0,-2,0.0),1.0),\n                       min(asphere(ro,rd,vec3(1.15,1.15,1.15),1.0),\n                           min(asphere(ro,rd,vec3(0.0,0.0,-2),1.0),\n                              min(asphere(ro,rd,vec3(3.,3.,3.),0.2),\n                                 asphere(ro, rd, vec3(-3.,-3.,-3.), 0.2)))))));\n}\n\n\nvec3 ascene(in vec3 ro, in vec3 rd){\n    float t = amap(ro,rd);\n    vec3 col = vec3(0);\n    if (t==1e10){col = vec3(0.5);} //if a \"miss\" is returned, set pixel to 50% grey\n    \n    else {\n        vec3 loc = t*rd+ro;\n        loc = loc*0.5;\n        col =  vec3(clamp(loc.x,0.0,1.0),clamp(loc.y,0.0,1.0),clamp(loc.z,0.0,1.0));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //THIS v\n    const int lensRes = 8; //THIS <\n    const int ssaa = 1; //THIS <\n    float lensDis = 0.6; //THIS <\n    float lensSiz = 1.5; //THIS <\n    float focalDis = 11.5; //THIS <\n    float aberration = 0.15; //THIS <\n    bool splitScreen = true; //THIS <\n    //THIS ^\n    //fragcoord is the center of the pixel\n\tvec2 sensorLoc = fragCoord.xy / iResolution.x; //sets x limits from 0-1 y at same scale, center at (0.5,0.?)\n    sensorLoc = vec2(0.5, 0.5*(iResolution.y/iResolution.x)) - sensorLoc; //reverse sensor and center on (0,0)\n    \n    vec3 UP = vec3(0.0,1.0,0.0); //useful later could be hardcoded later instead\n    float t = 0.5*iTime - 5.0*iMouse.x/iResolution.x; //tau used to determine camera position\n    \n    vec3 cameraPos = 10.0*vec3(1.0*sin(2.0*t),1.0*cos(1.5*t),1.0*cos(2.0*t)); //this is not normalized\n    \n    vec3 cameraDir = -cameraPos; //this will and should be normalized\n    cameraDir = normalize(cameraDir); //normalize\n    \n    vec3 cameraX = cross(cameraDir,UP); //right dir for camera\n    cameraX = normalize(cameraX); //normalize\n    \n    vec3 cameraY = cross(cameraX,cameraDir); //up dir for camera\n    cameraY = normalize(cameraY); //normlize\n\t\n    vec3 colorTotal = vec3(0.0);//for each pixel reset the accumulated color\n    vec3 ucolorTotal = vec3(0.0); //set up for an unabberated comparison color\n    float colorCount = 0.0;\n    float lensResF = float(lensRes); //for comparing to float later\n    float focal = 1.0+lensDis/focalDis; //brings the image to focus at focalDis from the cameraPos\n    float ssaaF = float(ssaa); // for using later to save a cast.\n    float sscale = 1.0/(iResolution.x); // size of a pixel\n    float sstep = 1.0/ssaaF;\n    float sstart = sstep/2.0-0.5;\n    float lstep = 1.0/lensResF;\n    float lstart = lstep/2.0-0.5;\n    \n    //Red Channel\n    float rFocalDis = focalDis*(1.0+aberration);\n    float rFocal = 1.0+lensDis/rFocalDis;\n    \n   \n    //Green Channel \n    float gFocalDis = focalDis;\n    float gFocal = 1.0+lensDis/gFocalDis;\n    \n    \n    //Blue Channel\n    float bFocalDis = focalDis*(1.0-aberration);\n    float bFocal = 1.0+lensDis/bFocalDis;\n    \n    for (float sx = sstart; sx < 0.5; sx += sstep){ //SSAA x direction\n    \tfor (float sy = sstart; sy < 0.5; sy += sstep){ //SSAA y direction\n            \n        \tvec2 ss = vec2(sx,sy)*sscale; //sub pixel offset for SSAA\n            vec3 sensorRel = cameraX*(sensorLoc.x+ss.x) + cameraY*(sensorLoc.y+ss.y); //position on sensor relative to center of sensor. Used once\n            vec3 sensorPos = cameraPos - lensDis*cameraDir + sensorRel; //3d position of ray1 origin on sensor\n            \t\n            for (float lx = lstart; lx < 0.5; lx+=lstep){\n        \t\tfor (float ly = lstart; ly < 0.5; ly+=lstep){\n                    \n            \t\tvec2 lensCoord = vec2(lx,ly); //fragCoord analog for lens array. lens is square\n        \t\t\tvec2 lensLoc = (lensCoord)*lensSiz; //location on 2d lens plane\n            \t\t\n                    if (length(lensLoc)<(lensSiz/2.0)){ //trim lens to circle\n                        \n                \t\tvec3 lensRel = cameraX*(lensLoc.x) + cameraY*(lensLoc.y); //position on lens relative to lens center. Used twice\n            \t\t\tvec3 lensPos = cameraPos + lensRel; // 3d position of ray1 end and ray2 origin on lens\n            \t\t\tvec3 senlenRay = lensPos - sensorPos; //direction of ray from sensor to lens\n                        \n                        //Red channel\n            \t\t\tvec3 rRay = senlenRay - rFocal*(lensRel); //direction of ray afer being focused by lens\n            \t\t\trRay = normalize(rRay); //normalize after focus \n            \t\t\tfloat red = ascene(lensPos,rRay).x; //scene returns red\n                        \n                        //Green channel\n            \t\t\tvec3 gRay = senlenRay - gFocal*(lensRel); //direction of ray afer being focused by lens\n            \t\t\tgRay = normalize(gRay); //normalize after focus \n                        vec3 ucolor = ascene(lensPos,gRay); //unaberrated scene\n            \t\t\tfloat green = ucolor.y; //scene returns green\n                        \n                        //Blue channel\n            \t\t\tvec3 bRay = senlenRay - bFocal*(lensRel); //direction of ray afer being focused by lens\n            \t\t\tbRay = normalize(bRay); //normalize after focus \n            \t\t\tfloat blue = ascene(lensPos,bRay).z; //scene returns blue\n                        \n                        ucolorTotal = ucolorTotal + ucolor;\n            \t\t\tcolorTotal = colorTotal+vec3(red, green, blue); //sum color over all points from lens\n                        colorCount += 1.0; //total number of colors added.\n                    }\n                }\n            }\n        }\n    }\n\n    if (!splitScreen){\n        fragColor = vec4(colorTotal/colorCount,0.0);\n    }\n    else{\n        if((fragCoord.x / iResolution.x)>0.501 ){\n            fragColor = vec4(colorTotal/colorCount,0.0);\n        } else if ((fragCoord.x / iResolution.x)<0.499){\n            fragColor = vec4(ucolorTotal/colorCount, 0.0);\n        }\n        else{\n            fragColor=vec4(0.0);\n        \n        }\n    }\n    \n}","name":"Image","description":"","type":"image"}]}