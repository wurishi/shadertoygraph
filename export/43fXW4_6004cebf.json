{"ver":"0.1","info":{"id":"43fXW4","date":"1709583406","viewed":81,"name":"Clouds on the Ocean","username":"Chroma_Crash","description":"Clouds rendered using raymarching and depth sampling. Uses Henyey-Greenstein phase function to simulate scattering of light in cloud.\nUses noise volume rather than worley noise due to performance issues with having to generate worley at run time.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","waves","raymarch","sun","clouds","perlin","water","water","sky","density","rendered"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define CLOUD_SCALE vec3(1.0, 1.0, 1.0)\n#define ABSORPTION 0.6\n#define BRIGHTNESS 1.0\n\n#define TOTAL_SAMPLES 5\nfloat sampleWeights[TOTAL_SAMPLES] = float[](0.5, 0.125, 0.125, 0.125, 0.125);\nfloat sampleScales[TOTAL_SAMPLES]  = float[](0.05, 0.1, 4.0, 0.8, 16.0);\n\n#define MAX_STEPS 12\n#define LIGHT_STEPS 2\n\n#define CLOUD_RANGE 8.0\n\n#define SKY_COLOR vec3(0.6, 0.8, 1.0)\n#define CLOUD_COLOR vec3(1.0, 0.8, 0.5)\n#define WATER_COLOR vec3(0.1, 0.2, 0.6)\n#define SUN_COLOR vec3(1.0, 1.0, 0.9)\n\n#define LIGHT_DIRECTION normalize(vec3(0.4, -0.2, -0.6))\n\n#define DENSITY_THRESHOLD 0.2\n#define WAVE_THRESHOLD 0.05\n#define SUN_FOCUS 160.0\n\n#define CAMERA_ANGLE 1.25\n\nconst float forwardScattering = .83f;\nconst float backScattering = .3f;\nconst float baseBrightness = .8f;\nconst float phaseFactor = .15f;\n\nconst vec4 phaseParams = vec4(forwardScattering, backScattering, baseBrightness, phaseFactor);\n\nfloat rand(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453);\n}\n\nfloat hg(float a, float g) {\n    float g2 = g*g;\n    return (1.0-g2) / (4.0*3.1415*pow(1.0+g2-2.0*g*(a), 1.5));\n}\n\nfloat phase(float a) {\n    float blend = 0.5;\n    float hgBlend = hg(a,phaseParams.x) * (1.0-blend) + hg(a,-phaseParams.y) * blend;\n    return phaseParams.z + hgBlend*phaseParams.w;\n}\n\nvec3 cellPoint(vec3 cellId) {\n    return cellId + rand(cellId);\n}\n\nfloat worley(vec3 texCoord) {\n    vec3 position = texCoord;\n    vec3 cellId = floor(position);\n\n    float minDist = 8.0;\n\n    for (int z = -1; z <= 1; z++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int x = -1; x <= 1; x++) {\n                vec3 surroundingId = cellId + vec3(x, y, z);\n                vec3 surroundingPoint = cellPoint(surroundingId);\n                minDist = min(distance(position, surroundingPoint), minDist);\n            }\n        }\n    }\n   \n    return max(0.0, 1.0 - minDist);\n}\n\nfloat sampleDensity(vec3 position) {\n    float density = 0.0;\n    for (int i = 0; i < TOTAL_SAMPLES; i++) {\n        vec3 samplePosition = position * sampleScales[i] * CLOUD_SCALE;\n        //float wor = worley(samplePosition);\n        float wor = texture(iChannel0, samplePosition / 4.0).r;\n        density += max(0.0, wor - DENSITY_THRESHOLD) * sampleWeights[i];\n    }\n    return density;\n}\n\n\nfloat lightmarch(vec3 position) {\n    vec3 dirToLight = -LIGHT_DIRECTION;\n    \n    float top = (CLOUD_RANGE - position.y) / dirToLight.y;\n    float bottom = (-CLOUD_RANGE - position.y) / dirToLight.y;\n    \n    float s = max(0.0, min(top, bottom));\n    float e = max(top, bottom);\n    \n    float dstInsideBox = e - s;\n\n    float transmittance = 1.0;\n    float stepSize = dstInsideBox / float(LIGHT_STEPS);\n    \n    float totalDensity = 0.0;\n    \n    for (int s = 0; s < LIGHT_STEPS; s++) {\n        float density = sampleDensity(position);\n        totalDensity += max(0.0, density);\n        position += dirToLight * stepSize;\n    }\n\n    transmittance = exp(-totalDensity / float(LIGHT_STEPS));\n\n    return transmittance;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float top = (CLOUD_RANGE - ro.y) / rd.y;\n    float bottom = (-CLOUD_RANGE - ro.y) / rd.y;\n    \n    float s = max(0.0, min(top, bottom));\n    float e = max(top, bottom);\n    \n    if (e < 0.0) {\n        return SKY_COLOR;\n    }\n    \n    vec3 start = ro + rd * s;\n    vec3 end = ro + rd * e;\n    \n    vec3 r = end - start;\n    \n    float lightEnergy = 0.0;\n    float transmittance = 1.0;\n    int steps = 0;\n    \n    float cosAngle = dot(rd, -LIGHT_DIRECTION);\n    float phaseVal = phase(cosAngle);\n    \n    float stepSize = CLOUD_RANGE / 8.0;\n    \n    for (float t = 0.0; t < length(r); t += stepSize) {\n        vec3 samplePoint = start + r * t;\n        float density = sampleDensity(samplePoint);\n        \n        if (density > 0.0) {\n            float lightTransmittance = lightmarch(samplePoint);\n            lightEnergy += density * stepSize * transmittance * lightTransmittance * phaseVal;\n            transmittance *= exp(-density * stepSize * ABSORPTION);\n        }\n        \n        if (transmittance < 0.01) {\n            break;\n        }\n        \n    }\n    \n    float sunAngle = dot(rd, -LIGHT_DIRECTION) * 0.5 + 0.5;\n    vec3 skySun = mix(SKY_COLOR, SUN_COLOR, clamp(sunAngle * SUN_FOCUS + (1.0 - SUN_FOCUS), 0.0, 1.0));\n    \n    vec3 cloudCol = lightEnergy * BRIGHTNESS * CLOUD_COLOR;\n    vec3 col = skySun * transmittance + cloudCol;\n    \n    if (rd.y < 0.0) {\n        float wave = max(0.0, sampleDensity(end / 2.0) - WAVE_THRESHOLD) / (1.0 - WAVE_THRESHOLD);\n        vec3 water = mix(WATER_COLOR, vec3(1), wave);\n        col = mix(col, water, -rd.y + 0.1);\n    }\n    \n    return col;\n}\n\n\nvec3 render(vec2 uv) {\n   uv = (uv - 0.5) * vec2(iResolution.x / iResolution.y, 1.0);\n   vec3 rd = normalize(vec3(uv * CAMERA_ANGLE, 1.0));\n   return raymarch(vec3(0, 0, iTime * 2.0), rd); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = render(uv);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}