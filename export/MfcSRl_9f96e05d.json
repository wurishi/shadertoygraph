{"ver":"0.1","info":{"id":"MfcSRl","date":"1714315562","viewed":25,"name":"Collatz Fractal3 -Fastaro","username":"robfast","description":"james bond vaporwave collatz","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math","recursion","collatzconjecture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat collatzconv(float x, int maxIter){\n    int iter = 0;\n    float nx = x;\n    while (nx > 1.0 && iter < maxIter) {\n        float prevX = nx;\n        nx = floor((3.0 * nx + 1.0) * mod(nx, 2.0) + (nx / 2.0) * (1.0 - mod(nx, 2.0)));\n        iter++;\n        if (nx == prevX) break;  // Break if no change, preventing potential infinite loops\n    }\n    return nx;  // Return the last value of x, regardless of whether it reached 1 or not\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv =collatzconv(abs(2.05*sin(iTime*0.05)),5)*(fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    float n = length(uv) * 100.0;  // Adjust starting number based on distance\n    float angle = atan(uv.y, uv.x);  // Angle determines sequence parameter\n\n    float x = n;  // Initialize sequence value\n    int iter = 0;\n    int maxIter = 2;  // Maximum iterations for control\n        \n    \n    // Iteration loop\n    while (x > 1.0 && iter < maxIter) {\n        float prevX = x;\n        x = floor((3.0 * x + 1.0) * mod(x, 2.0) + (x / 2.0) * (1.0 - mod(x, 2.0)));\n        iter++;\n        if (x == prevX) break;  // Prevent infinite loops\n    }\n\n    // Convert iteration count to a radius for the spiral\n    float radius = float(iter) / float(maxIter);\n\n \n      for(int i = 0; i < 70; i++) {\n        radius = radius + 1.0;\n        angle = (4.0 + 3.0 * n) * pow(4.0, angle) -1.0;\n        angle /= 3.0;  // Apply your sequence formula\n        \n        if(length(vec2(angle, radius*angle)) < 11105.0) break;  // Escape condition\n    }\n     float theta = 2.0* 3.14159 * radius + angle;\n    // Map to cartesian coordinates for output\n    vec2 pos = vec2(radius * cos(theta), radius * sin(theta));\n    vec3 color2 =0.9* vec3(0.2 + 3.5 * cos(float((length(vec2(radius, angle)))*1.0/float(iter)) + iTime),\n                      0.5 + 0.5 * sin(float((length(vec2(radius, angle)))*1.0/float(iter)) + iTime),\n                      1.4+ 0.5*sin(iTime + 2.0*float((length(vec2(radius, angle)))*1.0/float(iter)) * 0.1));\n    float baseColorMod = 1.5 + 0.2 *  sin(float((length(vec2(radius/2.0, angle)))*1.0/float(iter)) + iTime);  // Slow time variation\n    // Output to screen, centered and scaled\n    vec2 screenPos = 0.5 * (pos + 1.0);\n    // Calculate hue based on iteration, limited to a smaller range for controlled color variation\n    float hue = 0.1 + 0.2 * sin(float((length(vec2(radius/2.0, angle)))*1.0/float(iter)));  // Reduced hue variation\n    float saturation = 8.0;  // Less saturation for more pastel colors\n    float value = 0.1 +   cos(float((length(vec2(radius, angle)))*1.0/float(iter)));  // Brightness variation\n    \n    vec3 hsv = vec3(hue, saturation, value);\n    vec3 color =1.0/2.0*baseColorMod* 9.0*color2+3.0*color2*0.3*hsv;  // Convert HSV to RGB\n\n    fragColor = vec4(color, 1.0);  // Set fragment color\n}\n","name":"Image","description":"","type":"image"}]}