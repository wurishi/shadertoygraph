{"ver":"0.1","info":{"id":"7dByDW","date":"1643519200","viewed":110,"name":"II","username":"szkiw","description":"rotating billboards","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["billboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3x4 premulRotationX(const float radian, const mat3x4 m){\n\tmat3x4 r;\n\tfloat s = sin(radian);\n\tfloat c = cos(radian);\n\tr[0] = m[0];\n\tr[1] = c * m[1] - s * m[2];\n\tr[2] = s * m[1] + c * m[2];\n\treturn r;\n}\nmat3x4 premulRotationY(const float radian, const mat3x4 m){\n\tmat3x4 r;\n\tfloat s = sin(radian);\n\tfloat c = cos(radian);\n\tr[0] = c * m[0] + s * m[2];\n\tr[1] = m[1];\n\tr[2] = -s * m[0] + c * m[2];\n\treturn r;\n}\nmat3x4 premulTranslation(const vec3 offset, const mat3x4 m){\n\tmat3x4 r = m;\n\tr[0].w += offset.x;\n\tr[1].w += offset.y;\n\tr[2].w += offset.z;\n\treturn r;\n}\n#define PI 3.1415926535f\nmat3x4 calculateWorldTransform(out float outBlueLocalZ, const float stepScale, const float frame)\n{\n\tconst float oz0 = 2.0f;\n\tconst float aoz0 = 0.1818180f;\n\tconst float rvx0 = 1.0f;\n\tconst float rax0 = -0.05f;\n\tconst float vz0 = 0.5681818f;\n\tconst float az0 = -0.2090909f;\n\tconst float vz1 = 0.15333f;\n\tconst float rvy1 = 0.4774193f;\n\tconst float vz2 = 0.2725f;\n\tconst float vz2b = 0.004f;\n\tconst float vy2 = 0.0011086956f;;\n\tconst float rvx3 = 0.229f;\n\tconst float rvy3 = 0.0096774187f;\n\tconst float vz3 = 0.1f;\n\tconst float rvx4 = 0.2413043f;    \n\tfloat cnt = min(frame, 220.0f);\n\tfloat t = cnt / 120.0f;\n\tmat3x4 world;\n\tworld[0] = vec4(1.0f, 0.0f, 0.0f, 0.0f);\n\tworld[1] = vec4(0.0f, 1.0f, 0.0f, 0.0f);\n\tworld[2] = vec4(0.0f, 0.0f, 1.0f, 0.0f);\n\tworld[2].w = -stepScale * (oz0 + t * t * 0.5f * aoz0);\n\tfloat rotRad = PI * 2.0f * float(int(cnt) % 120) / 120.0f * rvx0;\n\trotRad += PI * 2.0f * t * t * 0.5f * rax0;\n\tworld = premulRotationX(rotRad, world);\n\tvec3 offset = vec3(0.0f, 0.0f, 0.0f);\n\toffset.z += \n\t\tvz0 * t + \n\t\taz0 * t * t * 0.5f;\n\tvec2 rot = vec2(0.0f, 0.f);\n\tif(220.0f < frame){\n\t\tfloat dt = (min(frame, 346.0f) - 220.0f) / 120.0f;\n\t\toffset.z += vz1 * dt;\n\t\tfloat dt_ = (min(frame, 728.0f) - 220.0f) / 120.0f;\n\t\trot.y += PI * 2.0f * rvy1 * dt_;\n\t}\n\tfloat lz = 0.0f;\n\tif(346.0f < frame){\n\t\tfloat dt = (min(frame, 470.0f) - 346.0f) / 120.0f;\n\t\toffset.z -= vz2 * dt;\n\t\tlz += vz2b * dt;\n\t\toffset.y -= vy2 * dt;\n\t}\n\tif(470.0f < frame){\n\t\tfloat dt = (min(frame, 728.0f) - 470.0f) / 120.0f;\n\t\toffset.z -= vz3 * dt;\n\t\trot.x += PI * 2.0f * rvx3 * dt;\n\t\trot.y -= PI * 2.0f * rvy3 * dt;\n\t}\n\tif(728.0f < frame){\n\t\tfloat dt = (min(frame, 856.0f) - 728.0f) / 120.0f;\n\t\trot.x += PI * 2.0f * rvx4 * dt;\n\t}\n\tworld = premulRotationY(rot.y, world);\n\tworld = premulRotationX(rot.x, world);\n\tworld = premulTranslation(offset, world);\n\toutBlueLocalZ = lz;\n\treturn world;\n}\nvec3 calculateWorldPosition(const vec2 ndc, const float worldZ){\n\tfloat w = -worldZ + 1.0f;\n\tvec3 wp;\n\twp.x = ndc.x * w / 22.100083f;\n\twp.y = ndc.y * w / 39.289035f;\n\twp.z = worldZ;\n    wp.x *= \n        (iResolution.x / 1920.0f) /\n        (iResolution.y / 1080.0f);\n\treturn wp;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n    vec2 texcoord = fragCoord / iResolution.xy;\n\tfloat frameCount = float(fract(iTime * 60.0f / 992.f) * 992.f);//iTime[s]\n    vec2 ndc = texcoord * 2.0f - vec2(1.0f, 1.0f);\n    const float stepScale = 0.004125f * 0.5f;\n    vec2 step = vec2(11.0f / 12.0f, 1.0f);\n    step *= stepScale;\n    const vec2 size = vec2(stepScale) * 0.75f;\n    float lz = 0.0f;\n    mat3x4 wt = calculateWorldTransform(lz, stepScale, frameCount);//mat3x4=3columns*4rows\n    const uint w = 12u;\n    const uint h = 11u;\n    float minZ = -10.0f;\n\tuint rs[6];\n    rs[0] =\t0x00000000u;\n\trs[1] =\t0x000903fcu;\n\trs[2] =\t0x00090090u;\n\trs[3] =\t0x00090090u;\n\trs[4] =\t0x000003fcu;\n\trs[5] =\t0x00000000u;\n    for(uint i = 0u; i < h; ++i){\n        for(uint j = 0u; j < w; ++j){\n            float x = float(j) - float(w - 1u) * 0.5f;\n            float y = float(i) - float(h - 1u) * 0.5f;\n            uint seqIdx = i * w + j;\n            uint c = (rs[seqIdx / 24u] >> (seqIdx % 24u)) & 1u;\n            vec3 p = vec3(x * step.x, y * step.y, (0u != c) ? lz : 0.0f);\n            vec3 wp = vec4(p, 1.0f) * wt;\n            if(minZ < wp.z){\n                vec3 cp = calculateWorldPosition(ndc, wp.z);\n                vec2 d = cp.xy - wp.xy;\n                float radius = size.x * 0.66f;\n                if(dot(d, d) < radius * radius){\n                    vec3 n;\n                    n.xy = d / radius;\n                    n.z = sqrt(1.0f - dot(n.xy, n.xy));\n                    vec3 l = normalize(vec3(-1.50f, 1.50f, 1.0f));\n                    float d = dot(l, n);\n                    d = d * 0.5f + 0.5f;\n                    vec3 e = vec3(0.0f, 0.0f, 1.0f);//2d way\n                    vec3 h = normalize(e + l);\n                    float s = pow(dot(n, h), 6.0f);\n                    vec3 lightColor = vec3(1.0f, 1.0f, 1.0f)*1.25;\n                    vec3 baseColor = vec3(1.0f, 1.0f, 1.0f);\n                    float ds = 0.75f;\n                    if(0u != c){\n                        lightColor = vec3(0.5f, 1.0f, 1.0f) * 2.0f;\n                        baseColor = vec3(0.0f, 0.0f, 1.0f);\n                        ds = 0.5f;\n                    }\n                    fragColor.rgb = \n                        lightColor * (baseColor * (d * ds) + (s * (1.0f - ds)));\n                    minZ = wp.z;\n                }\n            }\n        }\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}