{"ver":"0.1","info":{"id":"M3sXDH","date":"1709497197","viewed":170,"name":"2D Screen Space Ray Tracing","username":"Zentient","description":"Uses mipmaps to sample light, allowing rays to sample larger areas simultaneously, has obvious issues due to linear interpolation inaccuracies.\nWhite is lightmap, green shows \"objects\".\n\nUse mouse to move the green circle","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","occlusion","screenspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Buffer A generates the lightmap\n//Buffer B does the work\n//Meant to prioritize performance over accuracy for implementing as a screen space GI algorithm\nvec3 ACESFilm(vec3 x)\n{\nfloat a = 2.51f;\nfloat b = 0.03f;\nfloat c = 2.43f;\nfloat d = 0.59f;\nfloat e = 0.14f;\nreturn clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 liM = texture(iChannel0, uv).rgb;\n    liM = 0.01 * liM;\n    vec3 GI = texture(iChannel1, uv, 1.0).rgb;\n    \n    vec3 col = GI + liM;\n    col = ACESFilm(col);\n    col = pow(col, vec3(1.0) / 2.2);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A is lightmap\nvec2 lightMap(vec2 coord)\n{\n    vec2 lightPos = vec2(0.5 + 0.5 * sin(0.5 * iTime), 0.5 + 0.5 * cos(0.5 * iTime));\n    lightPos *= iResolution.xy;\n    vec2 obPos = vec2(0.5 + 0.5 * cos(0.5 * iTime), 0.5 + 0.5 * cos(1.0 * iTime));\n    if(iMouse.x > 0.0) {obPos = iMouse.xy / iResolution.xy;}\n    obPos *= iResolution.xy;\n    float ld = distance(lightPos, coord);\n    float od = distance(obPos, coord);\n    \n    if(ld <= 15.0){return vec2(0.1, 0.0);}\n    if(od <= 50.0){return vec2(0.0, 1.0);}\n    return vec2(0.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 map = lightMap(fragCoord);\n    float tex = texture(iChannel0, fragCoord / iResolution.xy * 1.5).r;\n    tex = pow(tex, 10.0);\n    map += vec2(tex, 0.0);\n    \n    tex = texture(iChannel0, 1.5 - fragCoord / iResolution.xy * 1.5).r;\n    tex = clamp(10.0 * pow(tex, 5.0), 0.0, 1.0);\n    map += vec2(0.0, tex);\n    fragColor = vec4(clamp(map, 0.0, 1.0),0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Traces rays in the lightmap\nconst float rayL = 7.0;//How many lods are used\nconst int rayT = 0; //Additional steps per lod\nconst float stLod = 0.0;//starting lod value\nconst float includeNoise = 1.0;\nfloat sampGI(vec2 coord, vec2 offset)\n{\n    vec2 res = iResolution.xy;\n    vec2[8] dir; //Clockwise from verticle\n    dir[0] = vec2(0.0, 1.0);\n    dir[1] = vec2(0.7071);\n    dir[2] = vec2(1.0, 0.0);\n    dir[3] = vec2(0.7071, -0.7071);\n    dir[4] = vec2(0.0, -1.0);\n    dir[5] = vec2(-0.7071);\n    dir[6] = vec2(-1.0, 0.0);\n    dir[7] = vec2(-0.7071, 0.7071);\n    \n    //Radial Ray casting\n    float rayS;\n    float ac;\n    \n    vec2 map;\n    for(int i = 0; i < 8; i++)\n    {\n        vec2 rayP;\n        for(rayS = stLod; rayS <= rayL; rayS++)\n        {\n            \n            for(int ii = 0; ii <= rayT; ii++)\n            {\n                rayP += 1.0 * pow(2.0, rayS) * ((includeNoise * offset + dir[i]) / res);\n                map = texture(iChannel0, coord + rayP, rayS).rg;\n                ac += map.r * pow(2.0, rayS);\n                \n            }\n            if(map.g > 0.05) {break;}//Terminates ray when it hits a surface\n        }\n        \n    }\n    return ac / (8.0 * rayL);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 tex = texture(iChannel0, uv, 0.0).rgb;\n    vec2 offset = 1.0 - texture(iChannel1, fragCoord / 1024.0).rg;\n    vec3 col = tex;\n    col = vec3(sampGI(uv, 1.0 * (offset - 0.5)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}