{"ver":"0.1","info":{"id":"wljXDc","date":"1567413449","viewed":89,"name":"Simple Shapes","username":"Nano98","description":"First Step, just some models","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rotate(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sphere(vec3 p,float r){return length(p)-r;}\nfloat cap(vec3 p,float h,float r){\n    p.y -= clamp(p.y,0.0,h);\n    return length(p) - r;\n}\nfloat tor(vec3 p,vec2 t){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat oct(vec3 p,float s){\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if(3.0*p.x < m) q = p.xyz;\n    else if(3.0*p.y < m) q = p.yzx;\n    else if(3.0*p.z < m) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\nfloat getDist(vec3 p){\n    float s = sphere(p,0.25);\n    float cap = cap(abs(p)-vec3(0.3,0,0.3),0.4,0.02);\n    float p1 = p.y - (-0.25);\n    float tor = tor(abs(p)-vec3(0.3,0.0,0.3),vec2(0.3,0.05));\n    vec3 q = p;\n    q.xz *= rotate(iTime*2.0);\n    float oct = oct(q - vec3(0,0.5,0),0.1);\n    float m = min(min(s,p1),cap);\n    m = min(m,tor);\n    m = min(m,oct);\n    return m;\n}\n\nfloat Ray(vec3 ro, vec3 rd){\n    int steps = 100;\n    float h,t = 0.0;\n    \n    for(int i = 0;i<steps;i++){\n        vec3 pos = ro + t * rd;\n        h = getDist(pos);\n        t += h;\n        if(h<0.01 || t>20.0) break;\n    }\n    if(t > 20.0) t = -1.0;\n    return t;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.0001,0.0);\n    return normalize(vec3(getDist(p+e.xyy) - getDist(p-e.xyy),\n                          getDist(p+e.yxy) - getDist(p-e.yxy),\n                          getDist(p+e.yyx) - getDist(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.4,0.5,0.7);\n    \n    float angle = iTime;\n    \n    vec3 ro = vec3(sin(iTime),abs(cos(iTime)),1.0*cos(iTime));\n    vec3 tar = vec3(0.0,.125,0.0);\n    vec3 ww = normalize(tar-ro);\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.2*ww);\n    \n    float t = Ray(ro,rd);\n\n    if(t > 0.0){\n    \n        vec3 pos = ro + t * rd;\n        \n        vec3 keyLight = vec3(.8,.4,0.2);\n        vec3 light_dir = normalize(keyLight);\n        \n        vec3 nor = getNormal(pos);\n        \n        vec3 mate = vec3(0.18);\n        \n        float key_dif = clamp(dot(nor,light_dir),0.0,1.0);\n        float key_shadow = step(Ray(pos+ 0.01*nor,light_dir),0.0);\n        float sky_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n        float bound_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n        \n        col = mate*vec3(6.0,4.0,3.0)*key_dif*key_shadow;\n        col += mate*vec3(0.5,0.8,0.9) * sky_dif;\n        col += mate*vec3(0.7,0.3,0.2) * bound_dif;\n        \n    }\n    \n    col = pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}