{"ver":"0.1","info":{"id":"wlc3Ds","date":"1578221898","viewed":289,"name":"UG_Universe","username":"usoppGod","description":"Moving through the star clusters","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["stars","starcluster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define DRAW_SINGLE_LAYER\n\nfloat Convert ( float in1, float in2, float out1, float out2, float inVal ) \n{\n \tfloat ratio = clamp ( ( inVal - in1 ) / ( in2 - in1 ), 0., 1. );\n    return out1 + ( out2 - out1 ) * ratio;\n}\n\nfloat DrawCircle ( vec2 origin, float radius, float smoothingDeltaRadius, vec2 uv ) \n{\n    uv -= origin ;\n    \n    if ( length ( uv ) < radius ) return 1.0; \n    else if ( length( uv ) > (radius + smoothingDeltaRadius) ) return 0.;\n    else return Convert ( radius, radius + smoothingDeltaRadius, 1.0, 0.0, length ( uv ) );\n}\n\nfloat DrawDistance ( vec2 uv, vec2 a, vec2 b ) \n{\n    vec2 uva = uv - a;\n    vec2 ba = b - a;\n    \n    // projects uv on line segment ab; . if its more towards a, it will be near 0;\n    // if its more towards b, it will be 1\n    float t = clamp ( dot ( uva, ba ) / dot ( ba, ba ) , 0., 1. );\n \treturn length(  uva - ba*t );\n}\n\nfloat DrawLine ( vec2 uv, vec2 a, vec2 b, float width, float fadeWidth ) \n{\n \treturn smoothstep ( width, width - fadeWidth, DrawDistance ( uv, a, b ) );\n}\nfloat DrawLine ( vec2 uv, vec2 a, vec2 b, float width, float fadeWidth, out float distance ) \n{\n    distance = DrawDistance ( uv, a, b ) ;\n \treturn smoothstep ( width, width - fadeWidth, distance );\n}\n\nfloat DrawLineFade ( vec2 uv, vec2 a, vec2 b, float width, float fadeWidth ) \n{\n\tfloat distance = 0.; \n    float extraThickness = smoothstep ( 0.7, 0.6, length( a-b) );\n    \n    float c = DrawLine ( uv, a, b, width + extraThickness*0.02, fadeWidth, distance );\n    \n    c *= (smoothstep ( 1.2, 0.6, length( a-b) )*.5 + extraThickness ); \n \treturn c;\n}\n\nvec2 GetNormalizedUV ( vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv = ( uv - vec2( 0.5 ) );\n    uv.x *= ratio;\n    uv += vec2 ( 0.5 );\n    return uv;\n}\n\nfloat Random21 ( vec2 inpt ) \n{\n \tinpt = fract ( inpt*vec2 ( 233.34, 851.73 ) );\n    inpt += dot ( inpt, inpt + 23.45 ) ;\n    return fract ( inpt.x * inpt.y );\n}\nvec2 Random22 ( vec2 inpt ) \n{\n \tfloat n = Random21 ( inpt );\n    return vec2 ( n, Random21 ( inpt + n ) );\n}\nvec2 GetRandomPoint ( vec2 id, vec2 offset ) \n{\n  \tvec2 randomPoint =  Random22 ( id + offset );\n    float speed = 3.;\n    randomPoint.x += sin ( iTime * speed * randomPoint.x  ) * 1.0;\n    randomPoint.y += sin ( iTime * speed * randomPoint.y ) * 1.0;\n    randomPoint = vec2 ( Convert ( -1., 2., 0.2, 0.8, randomPoint.x ), Convert ( -1., 2., 0.2, 0.8, randomPoint.y ) );\n       \n   \treturn offset + randomPoint;\n}\n\nfloat Layer ( vec2 uv ) \n{\n    float c;\n    \n    vec2 uvFract = fract ( uv );\n    vec2 id = floor( uv );\n    \n    // Getting random point per tile. And oscillating them\n   \tvec2 randomPoint = GetRandomPoint ( id, vec2 (0) );\n    \n    // Drawing points \n    c = DrawCircle (randomPoint, 0.05, 0.05, uvFract ) ;\n    \n    \n    // Finding all the nearest Points \n    vec2 p[9];\n    int pIndex = 0;\n    for(int i = -1; i <= 1; i++) \n    {\n        for(int j = -1; j <= 1; j++) \n        {\n            p[pIndex++] = GetRandomPoint ( id, vec2 ( float(i), float(j) ) );\n        }\n    }\n\n    // Draw all the lines\n\tfor ( int i = 0; i < 9; i++ )\n    {\n        c += DrawLineFade ( uvFract, p[4]/* center */ ,p[i], 0.015, 0.01 );\n        \n        float len = length( p[i] - uvFract);\n        float sparkle = 1. / ( len * len * 200. );\n                              \n        c += sparkle * ( sin ( iTime * 10. /* speed */ + fract(p[i].x) * 10.  ) * 0.5 + 0.5 );\n    }\n\n    c += DrawLineFade ( uvFract, p[1] ,p[3], 0.02, 0.01 );\t// top-center to left-middle\n    c += DrawLineFade ( uvFract, p[1] ,p[5], 0.02, 0.01 ); // top - center to right - middle \n    c += DrawLineFade ( uvFract, p[3] ,p[7], 0.02, 0.01 );\t// left - middle to bottom-center\n    c += DrawLineFade ( uvFract, p[5] ,p[7], 0.02, 0.01 );  // right - middle to bottom - center \n    \n    \n    //c += DrawLine ( uvFract, randomPoint, vec2 ( 1, 1 ), 0.02, 0.01 );\n    //c += DrawLine ( uvFract, randomPoint, vec2 ( 0, 1 ), 0.02, 0.01 );\n    //c += DrawLine ( uvFract, randomPoint, vec2 ( 1, 0 ), 0.02, 0.01 );\n    //c += DrawLine ( uvFract, randomPoint, vec2 ( 0, 0 ), 0.02, 0.01 );\n    \n    return c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float min = 0.3;\n\tfloat deltaSmoothing = 0.005;\n    vec3 color = vec3( 1.0, 1.0, 1.0 );\n    vec2 center = vec2 ( 0.5, .5 );\n\tfloat c = 0.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = GetNormalizedUV( fragCoord );\n    float gradient = uv.y;\n    \n\t// Dividing into grid\n    uv -= 0.5;\n    \n    #ifdef DRAW_SINGLE_LAYER\n    \tuv *= 5.0;\n    \tc = Layer ( uv );\n\t#else\n    \n    float time = iTime * 0.4;\n    \n    float sn = sin ( time );\n    float cs = cos ( time );\n    mat2 rotationMatrix = mat2 ( cs, -sn, sn, cs );\n    \n    uv *= rotationMatrix;\n    \n    for ( float i = 0.; i < 1.; i += 1./4. )\n    {\n     \tfloat z = fract ( i + time );   \n        float count = mix ( 10. , 1.0, z );\n        \n        float fade = smoothstep ( 0.2, 0.9, z ) * smoothstep ( 1., 0.8, z ); \n        c += Layer ( uv * count + i*20. ) * fade; // i*20 is to create an offset between each layer\n        \t\t\t\t\t\t\t\t // so that they are do not look cloned\n    }\n    #endif\n    \n    \n    \n    vec3 origCol = sin ( time * 5./* speed */ * vec3 (0.345, 0.456, 0.678) ) * 0.4 + 0.6;\n    vec3 col = origCol*c;\n    col += (1.- clamp( gradient*1.,0., 1.  ) ) * origCol;\n    fragColor = vec4 ( col, 1 );\n    \n    \n\t//Debug - See the random color for each tile \n    //c =  Random21 ( id );\n    //fragColor = vec4 ( vec3 ( c ), 1 );\n\n\t// Debug - Show Grid  \n    vec2 uvFract = fract ( uv );\n\t//if ( uvFract.x > 0.98 || uvFract.y > 0.98 ) fragColor = vec4 ( 1., 0., 0., 1. );\t\n    //else fragColor = vec4 ( 0 );\n    \n    // Debug - to see the id of each tile\n    //fragColor.rg = id;\n\n    // Debug - See random noise\n    //c = Random21 ( floor( uv * 100. ) );\n    //fragColor = vec4 ( vec3 ( c ), 1);\n}","name":"Image","description":"","type":"image"}]}