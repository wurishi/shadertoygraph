{"ver":"0.1","info":{"id":"4sdfWH","date":"1525202613","viewed":90,"name":"Tractor Beam","username":"johnmarsz2","description":"He was a shadertoy, she said see ya later boy.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shadertoyproject"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\n#define S(a, b, t) smoothstep(a,b,t)\nstruct ray{\n\tvec3 o,d;\n};\n    \nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel0, vec2(key, 0.5) ).x;\n}\n    \nfloat unionSDF(float distA, float distB) {\n   return min(distA, distB);\n}\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n   return length(p) - 0.67;\n}\nfloat sphereSDF2(vec3 p, vec3 c, float r) {\n   return length(p) - 0.08;\n}\nfloat sphereSDF3(vec3 p, vec3 c, float r) {\n   return length(p) - 0.2;\n}\n\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n   vec2 q = vec2(length(p.xz)-t.x,p.y);\n   return length(q)-t.y;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.04));\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n   float t = iTime;\n   float sphereDist2 = sphereSDF2(samplePoint + vec3(0.0, -1.6+sin(t*1.9)*.1, 0.0), vec3(0.,0.,0.),3.);\n   float sphereDist = sphereSDF(samplePoint + vec3(0.0, -0.89+sin(t*1.9)*.1, 0.0), vec3(0.,0.8,0.),1.);\n   float TorusDist = TorusSDF(samplePoint + vec3(0.0,-.75+sin(t*1.9)*.1,0.), vec2(0.45, 0.35));\n   float sphereDist3 = sphereSDF3(samplePoint + vec3(0.0+sin(t)*2.5, -0.89+sin(t*1.9)*.9, 0.0+cos(t)*2.5), vec3(0.,0.8,0.),1.);\n   float TorusDist2 = TorusSDF(samplePoint + vec3(0.0+sin(t)*2.5,-.85+sin(t*1.9)*.9,0.+cos(t)*2.5), vec2(0.15, 0.1));\n   float antenna = sphereDist2;\n   float ship = unionSDF(sphereDist, TorusDist);\n   float ship2 = unionSDF(sphereDist3, TorusDist2);\n   float ufo = unionSDF(antenna, ship);\n   return unionSDF(ship2, ufo);\n}\n    \n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n   float depth = start;\n   for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n       float dist = sceneSDF(eye + depth * marchingDirection);\n       if (dist < EPSILON) {\n         return depth;\n       }\n       depth += dist;\n       if (depth >= end) {\n           return end;\n       }\n   }\n   return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n   return normalize(vec3(\n       sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n       sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n       sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n   ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                         vec3 lightPos, vec3 lightIntensity) {\n   vec3 N = estimateNormal(p);\n   vec3 L = normalize(lightPos - p);\n   vec3 V = normalize(eye - p);\n   vec3 R = normalize(reflect(-L, N));\n   float dotLN = dot(L, N);\n   float dotRV = dot(R, V);\n    \n   if (dotLN < 0.0) {\n       // Light not visible from this point on the surface\n       return vec3(0.0, 0.0, 0.0);\n   }\n\n   if (dotRV < 0.0) {\n       // Light reflection in opposite direction as viewer, apply only diffuse\n       // component\n       return lightIntensity * (k_d * dotLN);\n   }\n   return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n   float itm = iTime / 4.0;\n   const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n   vec3 color = ambientLight * k_a;\n\n   vec3 light1Pos = vec3(4.0 * sin(itm),\n                         2.0,\n                         4.0 * cos(itm));\n   vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n\n   color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                 light1Pos,\n                                 light1Intensity);\n\n   vec3 light2Pos = vec3(2.0 * sin(0.37 * itm),\n                         2.0 * cos(0.37 * itm),\n                         2.0);\n   vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n\n   color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                 light2Pos,\n                                 light2Intensity);   \n   return color;\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n\n   vec2 xy = fragCoord - size / 2.0;\n\n   float z = size.y / tan(radians(fieldOfView) / 2.0);\n\n   return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n   // Based on gluLookAt man page\n   vec3 f = normalize(center - eye);\n   vec3 s = normalize(cross(f, up));\n   vec3 u = cross(s, f);\n   return mat4(\n       vec4(s, 0.0),\n       vec4(u, 0.0),\n       vec4(-f, 0.0),\n       vec4(0.0, 0.0, 0.0, 1)\n   );\n}\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n\tray a;\n    a.o = camPos;\n    \n    vec3 f = normalize(lookat-camPos);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n    vec3 c = a.o + f * zoom;\n    vec3 i = c + uv.x * r + uv.y * u;\n    \n    a.d = normalize(i-a.o);\n    return a;                  \n}\nvec3 ClosestPoint(ray r, vec3 p){\n\treturn r.o+ max(0., dot(p-r.o, r.d))*r.d;\n}\nfloat DistRay(ray r, vec3 p) {\n    return length(p-ClosestPoint(r, p));\n}\nfloat Bokeh(ray r, vec3 p, float size, float blur) {\n\tfloat d = DistRay(r,p);\n    float c = S(size, size*(1.-blur), d);\n    c *= mix(.6, 1., S(size*.8, size,d));\n    return c;\n}\nvec3 background(ray r, float t){\n\tfloat s = 1./2.; \n    float m = 0.;\n       for(float i=0.; i<1.; i+=s) {\n    float ti = fract(t+i);\n    vec3 p = vec3(-.45+ti*.9,-0.05, 0.5);\n    m += Bokeh(r,p,.3,.1);\n       }\n    return vec3(.7, .3, .3)*m;\n}\nvec3 background2(ray r, float t){\n\tfloat s = 1./2.; \n    float m = 0.;\n       for(float i=0.; i<1.; i+=s) {\n    float ti = fract(t+i);\n    vec3 p = vec3(.45-ti*.9,0.5, 0.5);\n    m += Bokeh(r,p,.3,.1);\n       }\n    return vec3(.4, .3, .7)*m;\n}\n\nvec3 beam(ray r, float t){    \n\tfloat s = 1./10.; \n    float m = 0.;\n       for(float i=0.; i<1.; i+=s) {\n    float ti = fract(t+i);\n    vec3 p = vec3(0.,(-0.5+ti*1.0), 4.5);\n    m += Bokeh(r,p,.3,.1);\n       }\n    return vec3(.4, .7, .3)*m;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n       float t = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y; \n   vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n   vec3 eye = vec3(8.0, 5.0, 7.0);   \n   mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n   vec3 worldDir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n   float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n   vec3 q = eye + dist * worldDir;\n    \n   vec3 K_a = vec3(sin(t)*1.5, cos(t)*1.5, 1.7);\n   vec3 K_d = vec3(0.45, 1.7, 0.5);\n   vec3 K_s = vec3(1.5, 1.5, 1.5);\n    \n   float shininess = 10.0;\n   vec3 color = phongIllumination(K_a, K_d, K_s, shininess, q, eye);\n   if (dist > MAX_DIST - EPSILON) {\n\tvec3 camPos = vec3(0,.2,0);\n    vec3 lookat = vec3(0,.2,1.);\n    ray r = GetRay(uv, camPos, lookat, 2.);\n    float t = iTime;\n    \n    vec3 col = beam(r,t);\n      col += background(r, t);\n      col += background2(r,t);\n      fragColor = vec4(col, 1.);\n      return;\n   }   \n    fragColor = vec4((color), 1.);\n}","name":"Image","description":"","type":"image"}]}