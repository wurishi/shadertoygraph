{"ver":"0.1","info":{"id":"wssGD8","date":"1546085938","viewed":265,"name":"Cosmosball","username":"DarkWyvren","description":"testing","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["volumeraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.005;\nconst int max_iter = 230;\nconst float MAXDIST = 20.0;\nconst int octave = 4;\nconst float PI = 3.141592;\nfloat k = 00.01;\nfloat constDIV = 0.6;\n\n\nfloat contrast(float x, float neg,float mul){\n\treturn max(0.0,mul*(x-neg));\n}\t\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n\nfloat sphereSDF(vec3 pos, float r){\n\treturn length(pos)-r;\n}\nfloat boxSDF( vec3 pos, vec3 bounds )\n{\n  vec3 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat boxSDF( vec2 pos, vec2 bounds )\n{\n  vec2 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,d.y),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat roundEdge(float sdf,float rad){\n\treturn sdf+rad;\n}\n\nfloat sub(float sdf,float sdf2){\n\treturn max(-sdf,sdf2);\n}\nfloat Ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat add(float sdf,float sdf2){\n\treturn min(sdf,sdf2);\n}\nfloat Sadd(float sdf,float sdf2){\n\treturn smin(sdf,sdf2,k);\n}\n\nvec3 opRep( in vec3 p, in vec3 peroid)\n{\n    vec3 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\nvec2 opRep( in vec2 p, in vec2 peroid)\n{\n    vec2 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\n\n\nvec3 noise_offset = vec3(0,0,0);\nvec3 noise_offsetLerp = vec3(0,0,0);\n\nfloat getSmoothnoiseNoDistort(vec3 thing){\n\n    float noise = 0.0;\n    float m=1.0;\n    for(int i = 0;i<=octave;i++){\n        m = pow(2.0,-float(i));\n    \tnoise+=texture(iChannel2,thing*m).r*pow(2.0,-1.0+float(-octave+i));\n    }\n    return noise;\n\t\n}\nfloat getSmoothnoise(vec3 thing){\n    //thing*=10.0;\n    thing+= mix(noise_offset,noise_offsetLerp,length(thing));\n    float noise = 0.0;\n    float m=1.0;\n    for(int i = 0;i<=octave;i++){\n        m = pow(2.0,-float(i));\n    \tnoise+=texture(iChannel2,thing*m).r*pow(2.0,-1.0+float(-octave+i));\n    }\n    return noise;\n\t\n}\n\nfloat cutoff(float x,float c){\n    float s = Ssub(0.0,x-c,k);\n\treturn s+sign(s)*c;\n}\n\nfloat getAtmosphereDen(vec3 pos){\n\treturn cutoff(getSmoothnoise(pos),0.5)*2.0*sign(max(0.0,-0.05-sphereSDF(pos,1.0)));\n}\n\n\n\nfloat getcrossSDF(vec3 pos, float scale\t){\n    float sdf = sphereSDF(pos,scale);\n    \n    return sdf;\n}\n\nfloat getDirNormal(vec3 pos, vec3 dir,float eps)\n{\n    // ...\n    float den = getAtmosphereDen( pos );\n    float dif = clamp( (getAtmosphereDen(pos+eps*dir)-den)/eps, 0.0, 1.0 );\n    return dif;\n    // ...\n}\n\n\nvec3 getNormal(vec3 pos, float scale){\n\treturn normalize(vec3(getcrossSDF(pos+vec3(EPSILON,0,0),scale)-getcrossSDF(pos-vec3(EPSILON,0,0),scale),  \n               \tgetcrossSDF(pos+vec3(0,EPSILON,0),scale)-getcrossSDF(pos-vec3(0,EPSILON,0),scale),  \n                getcrossSDF(pos+vec3(0,0,EPSILON),scale)-getcrossSDF(pos-vec3(0,0,EPSILON),scale)  \n               ));\n}\n\nfloat getLightIntense(vec3 normal,vec3 lightdir,vec3 viewdir,float spec,float expo,float diff){\n\tvec3 ref = reflect(viewdir,normal);\n\treturn spec*pow(clamp(dot(ref,lightdir),0.0,1.0),expo) + max(0.0,dot(normal,lightdir)*diff);\n}\nfloat isHit(vec3 rayPos, vec3 raydir){\n    float sdfRN = 0.0;\n\tfor(int i = 0;i<max_iter;i++){\n    \tsdfRN = max(0.0,getcrossSDF(rayPos,1.0))*constDIV;\n        rayPos += sdfRN*raydir;\n        if(sdfRN<EPSILON*2.0){\n            return 1.0;\n        \tbreak;\n        }\n        \n        if(sdfRN>MAXDIST){\n            return 0.0;\n        \tbreak;\n        }\n    }\n    return 0.0;\n\n}\nfloat factor = 5.5;\nvec3 lightColor = vec3(1.0);\nvec3 extColor = vec3(0.9,0.6,0.3);\nvec3 getPassedAtten(vec3 rayPos, vec3 raydir){\n    float maxstep = 0.03;\n    vec3 power = vec3(1.0);\n    for(int i = 0;i<max_iter;i++){\n    \tfloat den = getAtmosphereDen(rayPos);\n        rayPos += maxstep*raydir;\n        float atten = 1.0-pow(10.0,-factor*den*maxstep);\n        power*=(1.0-atten*(vec3(1.0)-extColor));\n        if(length(rayPos)>1.0||length(power)<0.01){\n            return power;\n        \t//maxstep = 0.02;\n        }\n        if(getcrossSDF(rayPos,0.5)<0.00){\n        \tpower*=0.0;\n        }\n    }\n    return power;\n\n}\nvec4 getAmtos(vec3 rayPos, vec3 raydir,vec3 lightDir){ //gets the amount blocked by the volume and inner spehre and does the lighting\n    vec3 oRayPos = rayPos;\n    float totalDist = 0.0;\n    float sdfRN = 0.0;\n    vec4 contrib = vec4(0.0);\n    float maxstep = 99.0;\n    //float minStep = \n\tfor(int i = 0;i<max_iter;i++){//pushes the ray to the outer sphere.\n    \tsdfRN = max(0.0,getcrossSDF(rayPos,1.0))*constDIV;\n        rayPos += sdfRN*raydir;\n        totalDist+=sdfRN;\n        if(sdfRN<EPSILON*2.0){\n        \tbreak;\n        }\n        \n        if(sdfRN>MAXDIST||i==max_iter-1){\n            return contrib;\n        \tbreak;\n        }\n    }\n    maxstep = 0.03;\n    float power = 1.0;\n    //totalDist-=mod(totalDist,maxstep)-maxstep;  - for ease of implementation inviolving aligning to view plane\n    rayPos = oRayPos+ totalDist*raydir; \n    float otherSDF = 0.0;// the inner sphere\n    for(int i = 0;i<max_iter;i++){\n    \tsdfRN = max(0.0,getcrossSDF(rayPos,1.0))*constDIV;\n        otherSDF = max(0.0,getcrossSDF(rayPos,0.5));\n        maxstep = min(0.03,otherSDF);\n        rayPos += maxstep*raydir;\n        float den = getAtmosphereDen(rayPos);\n        float atten = 1.0-pow(10.0,-factor*den*maxstep);\n        \n        vec3 t = normalize(rayPos);//gets the closest point on the innersphere\n        t = den*3.0*vec3(0.2,0.5,1.0)*pow(2.0*abs(0.5-abs(getSmoothnoiseNoDistort(t*2.0)-0.5)),12.0)/(30.0*(length(rayPos)-0.45));\n        \n        vec3 light = t+getPassedAtten(rayPos,lightDir);//getDirNormal(rayPos,lightDir,0.01);\n        contrib += vec4(lightColor*atten*power*light,atten*power);\n        power*=(1.0-atten);\n        \n        \n        if(sdfRN>EPSILON*3.0||power<0.01){\n            \n        \tbreak;\n        }\n        if(otherSDF<EPSILON*2.0){\n            vec3 norm= getNormal(rayPos, 0.5);\n            float lightL = max(0.0,getLightIntense(norm,lightDir,raydir,0.0,0.0,0.5));;\n                if(dot(norm,lightDir)>0.0){\n                \tlightL*=light.g;\n                }    \n        \tvec4 thing = vec4(lightColor*lightL,1.0) + 3.0*vec4(0.2,0.5,1.0,0.0)*pow(2.0*abs(0.5-abs(getSmoothnoiseNoDistort(rayPos*2.0)-0.5)),12.0);\n            contrib= (1.0-contrib.a)*thing+vec4(contrib.xyz,1.0)*contrib.a;\n            break;\n        }\n    }\n    \n    return contrib;\n\n}\n\nfloat getDist(vec3 rayPos, vec3 raydir){\n    float totalDist = 0.0;\n    float sdfRN = 0.0;\n\tfor(int i = 0;i<max_iter;i++){\n    \tsdfRN = max(0.0,getcrossSDF(rayPos,1.0))*constDIV;\n        \n        rayPos += sdfRN*raydir;\n        totalDist += sdfRN;\n        if(sdfRN<EPSILON*2.0){\n            return totalDist;\n        \tbreak;\n        }\n        \n        if(sdfRN>MAXDIST){\n            return float(MAXDIST);\n        \tbreak;\n        }\n    }\n    return float(MAXDIST);\n\n}\n\n\n\nvec2 cartToSphere(vec3 cart){\n\treturn vec2(acos(cart.z),atan(cart.y,cart.x));\n}\n\nvec3 SphereToCart(vec2 sph){\n\treturn vec3(sin(sph.x)*cos(sph.y),sin(sph.x)*sin(sph.y),cos(sph.x));\n}\n\n\n\n\nvec4 getBG(vec3 dir,vec3 lightdir){\n    float dotP = max(0.0,dot(lightdir,dir));\n    return vec4(\n        \tvec3(contrast(texture(iChannel1,3.*cartToSphere(dir)).x,0.9,5.0))\n        \t+10.0*vec3(1.0,0.5,0.25)*pow(1.001*dotP,1000.0)\n            +0.3*vec3(1.0,0.65,0.4)*pow(1.001*dotP,10.0)\n        \t,1.0);\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.0*(fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5));\n\tvec3 col;\n    vec3 camray ;\n     vec3 rayPos;\n    vec3 raydir;\n    camray = normalize(vec3(uv,-1.0));\n    vec3 light = normalize(SphereToCart(vec2(iTime*0.3,0.0)));\n    vec3 lookPos = vec3(0,0,0);//vec3(15.0*sin(iTime)-20.0*cos(0.25*iTime)*sin(iTime),0);\n        rayPos = 3.0*SphereToCart(2.0*vec2(iTime*40.00,iMouse.y)/iResolution.xy);\n\t\t\n        mat4 camProj  = viewMatrix(rayPos, lookPos,vec3(0,1,0));\n        raydir = normalize((camProj * vec4(camray, 0.0)).xyz);\n    noise_offset = vec3(sin(iTime*0.1),cos(iTime*0.1),0.0);\n    vec4 atm = getAmtos(rayPos,raydir,light);\n    fragColor = (1.0-atm.a)*getBG(raydir,light)+vec4(atm)*atm.a;\n    \n    float cast1 = getDist(rayPos, raydir);\n    if(cast1<MAXDIST-EPSILON*2.0){\n        vec3 sLand= rayPos+ cast1*raydir;\n        vec3 norm= getNormal(sLand, 1.0);\n        fragColor.rgb += vec3(1.0)*getLightIntense(norm,light,raydir,1.3,49.0,0.1);\n    }\n    /*if(length(atm)<EPSILON*2.0){\n    \tfragColor = getBG(raydir)+vec4(atm); //inital cast\n    }else{\n        /*vec3 norm= getNormal(rayPos+raydir*cast1, 1.0);\n        //getSmoothnoise(\n        vec3 Light = max(vec3(0.0),getLightIntense(norm,light,raydir,0.1,2.0,0.9));\n        float t = getSmoothnoise(rayPos+raydir*cast1);\n        if(t<0.84){\n        \tLight = max(vec3(0.0),getLightIntense(norm,light,raydir,1.3,9.0,0.5))*vec3(0.5,0.7,1.0);\n        }\n        //Light*=getSmoothnoise(rayPos+raydir*cast1)\n    \tfragColor = vec4(0.0)+vec4(atm);\n    }*/\n\n    // Output to screen\n    \n}","name":"Image","description":"","type":"image"}]}