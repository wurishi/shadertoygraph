{"ver":"0.1","info":{"id":"lXKGz3","date":"1718023872","viewed":51,"name":"ForkBurningHeartAudioVisualizer","username":"ArthurTent","description":"For your love! \nhttps://www.youtube.com/watch?v=Z2LSSgQMc2E","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarch","audio","heart","visualizer","audiovisualizer"],"hasliked":0,"parentid":"llXGRX","parentname":"Burning Heart"},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// https://www.shadertoy.com/view/llXGRX\n// Modified by ArthurTent for ShaderAmp\n// Created by dnnkeeper\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n//\n// You can run this audio visualization with ANY music with ShaderAmp\n// ShaderAmp on Github: https://github.com/ArthurTent/ShaderAmp\n// ShaderAmp on Chrome Web Store: https://chromewebstore.google.com/detail/shaderamp/pbgkhemojiabmajgkcgjelgpnpoddcgl\n\n// Change music in iChannel0 to see how it reacts to different music.\n\n\nfloat v  = 0.;\nfloat red  = 0.;\nfloat grn  = 0.;\nfloat blu  = 0.;\n\nconst int hammerTime = 42; //can't touch this!\nconst int _VolumeSteps = 40;\nconst float _StepSize = 0.08;\nconst float _Density = 0.1;\n\nconst float _SphereRadius = 1.75;\nconst float _NoiseFreq = 1.0;\nconst float _NoiseAmp = 3.0;\nconst float _PulseAmp = 0.05;\nconst float _PulseFreq = 3.0;\nconst float _WaveLength = 0.8;\nconst float _WaveStr = 0.5;\nconst vec3 _NoiseAnim = vec3(-0.50, -1.0, 0.0);\n\n// iq's nice integer-less noise function\n\n// matrix to rotate the noise octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat sqlen(in vec3 p)\n{\n    return (p.x*p.x+p.y*p.y+p.z*p.z);\n}\n\nfloat Heart(in vec3 p)\n{\n    p = vec3(p.z,p.y,p.x)*(0.5+v);\n    float h=p.x*p.x+p.y*p.y+2.0*p.z*p.z-1.0,pyyy=p.y*p.y*p.y;\n    //float v=h*h*h-(p.x*p.x-0.1*p.z*p.z)*pyyy;//the messed up bit\n    float v=h*h*h-(p.x*p.x)*pyyy;//the messed up bit\n\n    vec3 g=vec3(6.0*p.x*h*h-2.0*p.x*pyyy,\n                    6.0*p.y*h*h-3.0*p.x*p.x*p.y*p.y-0.3*p.z*p.z*p.y*p.y,\n                    12.0*p.z*h*h-0.2*p.z*pyyy);\n\n\n    /*float pulse = (sin(iTime*_PulseFreq)-1.0)*4.0;\n\tpulse = pow(8.0,pulse);\n\n    return 5.0*(v/length(g)+pulse*_PulseAmp);\n    */\n    return 5.*(v/length(g));\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    //p = m*p*2.02; f += 0.03125*abs(noise( p ));\n    return f;\n}\n\n// returns signed distance to surface\nfloat distanceFunc(vec3 p)\n{\n\tfloat d = sqlen(p) - _SphereRadius;\t// distance to sphere\n    d = min(d, sin(d*_WaveLength-iTime*_PulseFreq)+_WaveStr);\n\t//d += min(d,Heart(p));\n\t// offset distance with pyroclastic noise\n\t//p = normalize(p) * _SphereRadius;\t// project noise point to sphere surface\n\td += fbm(p*_NoiseFreq + _NoiseAnim*iTime) * _NoiseAmp;\n    d = min(d,Heart(p));\n\treturn d;\n}\n\n// color gradient\n// this should be in a 1D texture really\nvec4 gradient(float x)\n{\n\t// no constant array initializers allowed in GLES SL!\n\tconst vec4 c0 = vec4(2, 2, 1, 1);\t// yellow\n\tconst vec4 c1 = vec4(1, 0, 0, 1);\t// red\n\tconst vec4 c2 = vec4(0, 0, 0, 0); \t// black\n\tconst vec4 c3 = vec4(0, 0.5, 1, 0.5); \t// blue\n\tconst vec4 c4 = vec4(0, 0, 0, 0); \t// black\n\n\tx = clamp(x, 0.0, 0.999);\n\tfloat t = fract(x*4.0);\n\tvec4 c;\n\tif (x < 0.25) {\n\t\tc =  mix(c0, c1, t);\n\t} else if (x < 0.5) {\n\t\tc = mix(c1, c2, t);\n\t} else if (x < 0.75) {\n\t\tc = mix(c2, c3, t);\n\t} else {\n\t\tc = mix(c3, c4, t);\n\t}\n\t//return vec4(x);\n\t//return vec4(t);\n\treturn c;\n}\n\n// shade a point based on distance\nvec4 shade(float d)\n{\n\t// lookup in color gradient\n\treturn gradient(d);\n\t//return mix(vec4(1, 1, 1, 1), vec4(0, 0, 0, 0), smoothstep(1.0, 1.1, d));\n}\n\n// procedural volume\n// maps position to color\nvec4 volumeFunc(vec3 p)\n{\n\tfloat d = distanceFunc(p)*v;\n\treturn shade(d);\n}\n\n// ray march volume from front to back\n// returns color\nvec4 rayMarch(vec3 rayOrigin, vec3 rayStep, out vec3 pos)\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\tpos = rayOrigin;\n\tfor(int i=0; i<_VolumeSteps; i++) {\n\t\tvec4 col = volumeFunc(pos);\n        col.r *= red;\n        col.g *= grn;\n        col.b *= blu;\n\t\tcol.a *= _Density;\n\t\t//col.a = min(col.a, 1.0);\n\n\t\t// pre-multiply alpha\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\n#if 0\n\t\t// exit early if opaque\n        \tif (sum.a > 1.0)\n            \t\tbreak;\n#endif\n\t\tpos += rayStep;\n\t}\n\treturn sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    v  = texture( iChannel0, vec2(1/510,0.25) ).x;\n    red  = texture( iChannel0, vec2(1/510,0.25) ).x;\n    grn  = texture( iChannel0, vec2(0.5,0.5) ).x;\n    blu  = texture( iChannel0, vec2(0.75,0.5) ).x;\n\n    //vec2 fragCoord = vUv * iResolution;\n    vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n    p.x *= iResolution.x/ iResolution.y;\n\n    //float rotx = ( iMouse.y / iResolution.y)*4.0;\n    //float roty = -(iMouse.x / iResolution.x)*4.0;\n    float rotx = 0.;\n    float roty = 0.;\n    float zoom = 4.0;\n\n    // camera\n    vec3 ro = zoom*normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    ro += rd*2.0;\n\n    // volume render\n    vec3 hitPos;\n    vec4 col = rayMarch(ro, rd*_StepSize, hitPos);\n    //vec4 col = gradient(p.x);\n\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}