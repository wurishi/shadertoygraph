{"ver":"0.1","info":{"id":"mtcBWr","date":"1701990876","viewed":40,"name":"Fork UCSD CSE 1 SouKangC 837","username":"SouKangC","description":"This is a homework template for a homework for UCSD CSE 167.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["boids"],"hasliked":0,"parentid":"ddtyDs","parentname":"UCSD CSE 167 Boids template"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Smooth HSV2RGB from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = vec4(0.5, 0.5, 0.5, 1.0);\n    // Loop over all boids\n    vec4 bcolor = vec4(0.0, 0.0, 0.0, 1.0);\n    bool hit = false;\n    for (int i = 0; i < NUM_BOIDS; i++) {\n        ivec2 tex_pos = ivec2(i % int(iChannelResolution[0].x),\n                                                i / int(iChannelResolution[0].x));\n        vec4 pos_vel = texelFetch(iChannel0, tex_pos, 0);\n        if (i == NUM_BOIDS - 1) {\n            // Draw predator as a square\n            float squareSize = 40.0; // Size of the predator square\n            vec2 sizeVec = vec2(squareSize, squareSize) / 2.0; // Half-size vector\n            vec2 lowerLeft = pos_vel.xy - sizeVec;\n            vec2 upperRight = pos_vel.xy + sizeVec;\n            bool inside = all(greaterThanEqual(fragCoord, lowerLeft)) && all(lessThanEqual(fragCoord, upperRight));\n            \n            if (inside) {\n                color = vec4(1.0, 0.0, 0.0, 1.0); // Red color for the predator\n                hit = true;\n            }\n        } else {\n            if (distance(fragCoord, pos_vel.xy) < BOIDS_SIZE) {\n                vec3 rgb = hsv2rgb(vec3((float(i)+0.5) / float(NUM_BOIDS), 1.0, 0.9));\n                bcolor += vec4(rgb, 1.0);\n                hit = true;\n            }\n        }\n    }\n    if (hit) {\n        color = bcolor;\n    }\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 predatorPos; // Predator position\n\nvec2 calculateFleeingForce(vec2 boidPos) {\n    vec2 fleeDirection = boidPos - predatorPos;\n    float distanceToPredator = length(fleeDirection);\n    // float fleeStrength = 10000.0 / (distanceToPredator * distanceToPredator + 1.0); // Avoid division by zero\n    float fleeStrength = exp(-(distanceToPredator*10.0)) * 1000000.0;\n    \n    return normalize(fleeDirection) * fleeStrength;\n}\n\nvec2 calculateBoundaryForce(vec2 pos, float left, float right, float top, float bottom, float weight) {\n    vec2 force = vec2(0.0);\n\n    // Apply force when approaching the left boundary\n    if (pos.x < left) {\n        force.x += weight * (left - pos.x);\n    }\n\n    // Apply force when approaching the right boundary\n    if (pos.x > right) {\n        force.x -= weight * (pos.x - right);\n    }\n\n    // Apply force when approaching the top boundary\n    if (pos.y < top) {\n        force.y += weight * (top - pos.y);\n    }\n\n    // Apply force when approaching the bottom boundary\n    if (pos.y > bottom) {\n        force.y -= weight * (pos.y - bottom);\n    }\n\n    return force;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame == 0) {\n        // initialize the buffer\n        vec4 pos_vel = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n        pos_vel.xy = iResolution.xy / 2.0 + (pos_vel.xy - 0.5) * iResolution.xy * 0.2;\n        pos_vel.zw = (pos_vel.zw - 0.5) * iResolution.xy * 1.0;\n        fragColor = pos_vel;\n        return;\n    }\n    ivec2 iFragCoord = ivec2(fragCoord);\n    // \n    vec4 pos_vel = texelFetch(iChannel0, iFragCoord, 0);\n    vec2 pos = pos_vel.xy;\n    vec2 vel = pos_vel.zw;\n    // ID of the current Boid\n    int my_id = int(iFragCoord.y) * int(iResolution.x) + int(iFragCoord.x);\n    \n    if (my_id >= NUM_BOIDS) return;\n\n    // Implement Boids here\n    if (my_id == NUM_BOIDS - 1) {\n        // Implement the predator force\n        \n        // Predator specific parameters\n        float predatorMaxSpeed = 40.0; // Predator's max speed\n        float chaseWeight = 0.4; // Weight for the chasing force\n        float preyDistance = 500.0; // Distance within which the predator will chase prey\n        float boundaryWeight = 0.7;\n        float dampingFactor = 0.95;\n\n        // Initialize predator forces\n        vec2 forceChase = vec2(0.0);\n\n        // Loop over all boids to calculate chasing force\n        for (int i = 0; i < NUM_BOIDS; i++) {\n            // Calculate texel position for boid 'i'\n            ivec2 tex_pos = ivec2(i % int(iChannelResolution[0].x),\n                                  i / int(iChannelResolution[0].x));\n\n            // Fetch position and velocity of boid 'i' from the texture\n            vec4 pos_vel_other = texelFetch(iChannel0, tex_pos, 0);\n\n            // Only chase non-predator boids\n            if (i != NUM_BOIDS - 1 && distance(pos, pos_vel_other.xy) < preyDistance) {\n                forceChase += normalize(pos_vel_other.xy - pos);\n            }\n        }\n\n        // Normalize and apply weight to the chasing force\n        if (length(forceChase) > 0.0) {\n            forceChase = normalize(forceChase) * chaseWeight;\n        }\n        \n        // Predator-specific boundary parameters\n        float predatorLeftBoundary = 100.0;\n        float predatorRightBoundary = iResolution.x - 100.0;\n        float predatorTopBoundary = 80.0;\n        float predatorBottomBoundary = iResolution.y - 80.0;\n\n        // Initialize predator boundary force\n        vec2 forcePredatorBoundary = calculateBoundaryForce(pos, predatorLeftBoundary, predatorRightBoundary, predatorTopBoundary, predatorBottomBoundary, boundaryWeight);\n\n        // Update velocity with chasing and boundary forces\n        vec2 force = forcePredatorBoundary + forceChase;\n        \n        // Add chasing force to the velocity\n        vel += force;\n        \n        // Apply damping to control momentum\n        vel *= dampingFactor;\n\n        // Limit the predator's velocity\n        float predatorSpeed = length(vel);\n        if (predatorSpeed > predatorMaxSpeed) {\n            vel = (vel / predatorSpeed) * predatorMaxSpeed;\n        }\n\n        // Update position\n        pos += vel;\n        \n        predatorPos = pos;\n\n        fragColor = vec4(pos, vel);\n    } else {\n        // Parameters (You can adjust these based on your requirements)\n        float maxSpeed = 10.0;\n        float minSpeed = 5.0;\n        float separationDistance = 30.0;\n        float cohesionDistance = 150.0;\n        float alignmentDistance = 150.0;\n        float separationWeight = 0.02;\n        float cohesionWeight = 0.001;\n        float alignmentWeight = 0.03;\n        float boundaryWeight = 0.5;\n        vec2 resolution = iResolution.xy; // Assuming this is defined earlier in your shader\n\n        // Boundary\n        float dleft = 200.0;\n        float dright = iResolution.x - 200.0;\n        float dtop = 160.0;\n        float dbottom = iResolution.y - 160.0;\n\n        // Initialize forces\n        vec2 forceSeparation = vec2(0.0);\n        vec2 forceCohesion = vec2(0.0);\n        vec2 forceAlignment = vec2(0.0);\n        vec2 forceBoundary = vec2(0.0);\n\n        // Counter\n        int numCohesionBoids = 0;\n        int numSeparationBoids = 0;\n        int numAlignmentBoids = 0;\n\n        // Loop over all boids to calculate forces\n        for (int i = 0; i < NUM_BOIDS; i++) {\n            // Calculate texel position for boid 'i'\n            ivec2 tex_pos = ivec2(i % int(iChannelResolution[0].x),\n                                  i / int(iChannelResolution[0].x));\n\n            // Calculate and compare id\n            int boid_id = int(tex_pos.y) * int(iResolution.x) + int(tex_pos.x);\n\n            if (my_id != i) {\n                // Fetch position and velocity of boid 'i' from the texture\n                vec4 pos_vel = texelFetch(iChannel0, tex_pos, 0);\n\n                // Extract position and velocity\n                vec2 otherPos = pos_vel.xy;\n                vec2 otherVel = pos_vel.zw;\n\n                // Separation\n                if (distance(pos, otherPos) < separationDistance) {\n                    forceSeparation += pos - otherPos;\n                    numSeparationBoids += 1;\n                }\n\n                // Cohesion\n                if (distance(pos, otherPos) < cohesionDistance) {\n                    forceCohesion += otherPos;\n                    numCohesionBoids += 1;\n                }\n\n                // Alignment\n                if (distance(pos, otherPos) < alignmentDistance) {\n                    forceAlignment += otherVel;\n                    numAlignmentBoids += 1;\n                }\n            }\n        }\n\n        // Average the cohesion and alignment forces\n        if (numSeparationBoids > 0) {\n            forceSeparation = forceSeparation / float(numSeparationBoids);\n        }\n        if (numCohesionBoids > 0) {\n            forceCohesion = (forceCohesion / float(numCohesionBoids)) - pos;\n        }\n        if (numAlignmentBoids > 0) {\n            forceAlignment = (forceAlignment / float(numAlignmentBoids)) - vel;\n        }\n\n        // Boundary force\n        if (pos.x < dleft) forceBoundary.x += 1.0;\n        if (pos.x > dright) forceBoundary.x -= 1.0;\n        if (pos.y < dtop) forceBoundary.y += 1.0;\n        if (pos.y > dbottom) forceBoundary.y -= 1.0;\n\n        // User interaction parameters\n        vec2 targetPos = iMouse.xy;\n        bool isMousePressed = iMouse.z > 0.0;\n        float attractionWeight = 0.1; // You can adjust this\n\n        // Initialize attraction force\n        vec2 forceAttraction = vec2(0.0);\n        if (isMousePressed) {\n            // Calculate attraction force\n            vec2 dirToTarget = targetPos - pos;\n            float distanceToTarget = length(dirToTarget);\n            forceAttraction = normalize(dirToTarget) * attractionWeight * distanceToTarget;\n        }\n\n        // Calculate fleeing force\n        vec2 forceFleeing = calculateFleeingForce(pos);\n\n        // Combine forces\n        vec2 force = separationWeight * forceSeparation +\n                     cohesionWeight * forceCohesion +\n                     alignmentWeight * forceAlignment +\n                     boundaryWeight * forceBoundary +\n                     forceAttraction +\n                     forceFleeing;\n\n        // Update velocity\n        vel += force;\n\n        // Limit velocity\n        float speed = length(vel);\n        if (speed > 0.0) {\n            if (speed > maxSpeed) {\n                vel = (vel / speed) * maxSpeed;\n            } else if (speed < minSpeed) {\n                vel = (vel / speed) * minSpeed;\n            }\n        }\n\n        // Update position\n        pos += vel;\n\n        fragColor = vec4(pos, vel);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NUM_BOIDS 201\n#define BOIDS_SIZE 10.0\n","name":"Common","description":"","type":"common"}]}