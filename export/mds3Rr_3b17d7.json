{"ver":"0.1","info":{"id":"mds3Rr","date":"1666122208","viewed":54,"name":"Recursive Art","username":"TonyIlersich","description":"Solves a random function recursively for each pixel.\n\nChange the DEPTH and SEED parameters to control the image.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= (vec2(res)-.5)/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const uint SYMBOL_X           = 0u;\nconst uint SYMBOL_Y           = 1u;\nconst uint SYMBOL_R           = 2u;\nconst uint SYMBOL_THETA       = 3u;\nconst uint SYMBOL_T           = 4u;\nconst uint SYMBOL_MX          = 5u;\nconst uint SYMBOL_MY          = 6u;\nconst uint NUM_ATOMIC_SYMBOLS = 7u;\n\nconst uint SYMBOL_SIN         = NUM_ATOMIC_SYMBOLS + 0u;\nconst uint SYMBOL_RECIP       = NUM_ATOMIC_SYMBOLS + 1u;\nconst uint NUM_UNARY_SYMBOLS  = NUM_ATOMIC_SYMBOLS + 2u;\n\nconst uint SYMBOL_ADD         = NUM_UNARY_SYMBOLS + 0u;\nconst uint SYMBOL_MUL         = NUM_UNARY_SYMBOLS + 1u;\nconst uint NUM_BINARY_SYMBOLS = NUM_UNARY_SYMBOLS + 2u;\n\nconst uint NUM_SYMBOLS        = NUM_BINARY_SYMBOLS;\n\nconst uint allowedAtoms[] = uint[](\n    SYMBOL_X, SYMBOL_Y,\n    SYMBOL_R, SYMBOL_THETA,\n    SYMBOL_T,\n    SYMBOL_MX, SYMBOL_MY\n);\n\nconst uint allowedOperators[] = uint[](\n    SYMBOL_SIN,\n    SYMBOL_ADD,\n    SYMBOL_MUL\n);\n\nuint operandCount(uint symbol)\n{\n    uint result = 0u;\n    switch (symbol)\n    {\n        // atomic\n        case SYMBOL_X:     result = 0u; break;\n        case SYMBOL_Y:     result = 0u; break;\n        case SYMBOL_R:     result = 0u; break;\n        case SYMBOL_THETA: result = 0u; break;\n        case SYMBOL_T:     result = 0u; break;\n        case SYMBOL_MX:    result = 0u; break;\n        case SYMBOL_MY:    result = 0u; break;\n        // unary\n        case SYMBOL_SIN:   result = 1u; break;\n        case SYMBOL_RECIP: result = 1u; break;\n        // binary\n        case SYMBOL_ADD:   result = 2u; break;\n        case SYMBOL_MUL:   result = 2u; break;\n    }\n    return result;\n}\n\nuint hash(uint x)\n{\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = (x >> 16) ^ x;\n    return x;\n}\n\nuint unhash(uint x)\n{\n    x = ((x >> 16) ^ x) * 0x119de1f3u;\n    x = ((x >> 16) ^ x) * 0x119de1f3u;\n    x = (x >> 16) ^ x;\n    return x;\n}\n\nfloat getSymbol(uint symbol, float x, float y)\n{\n    float result;\n    switch (symbol)\n    {\n        case SYMBOL_X:     result = x;                                                      break;\n        case SYMBOL_Y:     result = y;                                                      break;\n        case SYMBOL_R:     result = length(vec2(x,y));                                      break;\n        case SYMBOL_THETA: result = atan(y,x);                                              break;\n        case SYMBOL_T:     result = iTime / 10.0;                                           break;\n        case SYMBOL_MX:    result = (iMouse.x * 2.0 - iResolution.x) * 5.0 / iResolution.x; break;\n        case SYMBOL_MY:    result = (iMouse.y * 2.0 - iResolution.y) * 5.0 / iResolution.y; break;\n    }\n    return result;\n}\n\nfloat getExpr(uint expr, float lhs, float rhs)\n{\n    float result;\n    switch (expr)\n    {\n        case SYMBOL_SIN:   result = sin(lhs);  break;\n        case SYMBOL_RECIP: result = 1.0 / lhs; break;\n        case SYMBOL_ADD:   result = lhs + rhs; break;\n        case SYMBOL_MUL:   result = lhs * rhs; break;\n    }\n    return result;\n}\n\nfloat getValue(vec2 coord, uint seed)\n{\n    float x = coord.x;\n    float y = coord.y;\n    uint depth = 0u;\n    uint exprPtr = 0u;\n\n    const uint stackSize = (MAX_DEPTH + 1u) * 2u;\n\n    float valueStack[stackSize];\n    uint valueStackPtr = 0u;\n\n    uint opStack[stackSize];\n    uint opStackPtr = 0u;\n    \n    const uint OP_REC = uint(-1);\n\n    opStack[opStackPtr++] = OP_REC;\n\n    while (opStackPtr > 0u)\n    {\n        uint op = opStack[--opStackPtr];\n        // record work to do on the way down\n        if (op == OP_REC)\n        {\n            // read next expression\n            //uint expr = exprSeq[exprPtr++];\n            seed = hash(seed);\n            uint selection = seed;\n            if (depth < MIN_DEPTH) // use only non-atomic symbols\n            {\n                selection = seed % uint(allowedOperators.length()) + uint(allowedAtoms.length());\n            }\n            else if (depth >= MAX_DEPTH) // use only atomic symbols\n            {\n                selection = seed % uint(allowedAtoms.length());\n            }\n            else // allow any symbol\n            {\n                selection = seed % uint(allowedAtoms.length() + allowedOperators.length());\n            }\n            uint expr = selection < uint(allowedAtoms.length())\n                ? allowedAtoms[selection]\n                : allowedOperators[selection - uint(allowedAtoms.length())];\n            // push expression to stack\n            opStack[opStackPtr++] = expr;\n            // push recursive calls to stack for each operand\n            for (uint i = 0u; i < operandCount(expr); i++)\n            {\n                opStack[opStackPtr++] = OP_REC;\n            }\n            depth++;\n        }\n        // evaluate on the way up\n        else\n        {\n            depth--;\n            float lhs, rhs;\n            switch (operandCount(op))\n            {\n                case 0u:\n                    valueStack[valueStackPtr++] = getSymbol(op, x, y);\n                    break;\n                case 1u:\n                    lhs = valueStack[--valueStackPtr];\n                    valueStack[valueStackPtr++] = getExpr(op, lhs, 0.0);\n                    break;\n                case 2u:\n                    lhs = valueStack[--valueStackPtr];\n                    rhs = valueStack[--valueStackPtr];\n                    valueStack[valueStackPtr++] = getExpr(op, lhs, rhs);\n                    break;\n            }\n        }\n    }\n    \n    return valueStack[0];\n}\n\nfloat norm(float x)\n{\n    return sqrt(abs(x)) * sign(x) / 10.0 + .5;\n}\n\nvec3 getColor(vec2 coord)\n{\n    return vec3(norm(getValue(coord, SEED_RED)),\n                norm(getValue(coord, SEED_GREEN)),\n                norm(getValue(coord, SEED_BLUE)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0);\n    uvec2 coord = uvec2(fragCoord);\n    if (coord.x < res.x && coord.y < res.y)\n    {\n        vec2 uv = fragCoord/vec2(res);\n        col = getColor((uv - .5) * 4.0);\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const uvec2 res = uvec2(160, 90);\n\n// control how complicated the formula is\nconst uint MIN_DEPTH = 5u;\nconst uint MAX_DEPTH = 7u;\n\n// each color channel has its own seed to determine the formula\nconst uint SEED_RED    = 7604u;\nconst uint SEED_GREEN  = 896567u;\nconst uint SEED_BLUE   = 54183676u;","name":"Common","description":"","type":"common"}]}