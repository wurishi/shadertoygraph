{"ver":"0.1","info":{"id":"McByRd","date":"1722821206","viewed":79,"name":"Dynamic SDF Jump Flood","username":"chronos","description":"Basic jump flood based distance field drawing.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["basic","sdf","distance","field","flood","jump","signed","interior","flooding","jfa"],"hasliked":0,"parentid":"MfSyzV","parentname":"Draw Jump Flood Distance Field"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Dynamic SDF Jump Flood by chronos\n    ---------------------------------------------\n    \n    Just drawing a sign value in Buffer A, and then flooding with different offsets\n    Jump flooding implementation is updated from one of my previous JF shaders to\n    handle correct interior distances and dynamic updates of arbitrary fields.\n    \n    There is a similar shader to this by @fenix: https://www.shadertoy.com/view/ct2cDV\n    thanks to @MysteryPancake for making me aware of it.\n    I didn't know about it before starting this, so I think this one likely works somewhat differently.\n    \n    In any case, this one works by keeping track of an offset, fill and sign for each pixel.\n    \n    - The offset represents the vector from this pixel to the nearest sign change (zero crossing),\n        the distance is the length of this vector.\n    - The fill represents whether or not the current pixel has found any valid sign changes yet.\n    - The sign is just a channel where you draw the interior (-1) or exterior (+1).\n    \n    Then, if a pixel changes sign, it is 'invalidated' by resetting it's fill and other properties.\n    Or, if the offset target pixel pixel changes sign, then this pixel is also invalidated.\n    \n    If a pixel is invalidated, it has to perform the search anew, and always maintain an unfilled state until\n    it finds an offset to an explicit pixel of differing sign. So it will eventually be valid again.\n    \n    If a pixel didn't change sign itself, but has an offset to a target pixel that has changed sign,\n    then it should be invalidated itself, but it is not necessary to check for pointing to a pixel that has been invalidated, \n    since if it is a target pixel it must have opposite sign, and therefore the __validity only applies to the chain of differing sign__,\n    meaning it will not affect this pixel. So pixels shouldn't get stuck with stale targets.\n    \n    \n    The jump flood iteration is modified to that it only accepts a target if it is either of a different sign,\n    meaning the jump distance itself is the distance, or the target is filled, meaning that the target itself\n    has a valid path that leads to a different sign.\n    \n    You can hold spacebar to erase / draw exterior (+1 sign). By default it draws interior (-1 sign).\n    \n    \n    TODOs:\n    \n    It's of course a bit wasteful to use two channels for essentially two 1-bit values,\n    but that is straightforward to pack. Could also perhaps generalize to ID / SDF values ?\n    \n    The zero crossing is naturally also not at the pixel center itself if it has sign +/- 1,\n    but rather in between, so could device some logic to get more accurate subpixel distances.\n    The field is continuous, so any two pixels with differing sign will have a zero crossing between them,\n    but it would not be known where, unless they are neighbors, in which case some convention like the midpoint\n    between them could be used, or a smoothened version of the neighborhood. Some care needs to be taken here!\n    \n    \n    \n    Please excuse the awful looking code :P\n    \n    ---------------------------------------------\n        self link: https://www.shadertoy.com/view/McByRd\n*/\n\n// This buffer visualizes the result :)\n\n#define SHOW_ISOLINES 0\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0.,1.) * b - p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samp = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float dist = length(samp.rg);\n    vec3 color =  samp.b * vec3(.5*(1.+normalize(samp.rg)), tanh(dist) / 500.) * (1.-exp(-dist*0.1)) + step(0.,-samp.b);\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy) / iResolution.y;\n    float ps = 2./iResolution.y;\n    \n    // Draw animated distance and projection point tester\n    {\n        vec2 distance_tester_pos = (vec2(sin(iTime/8.), cos(iTime))*.5 + .5) ;\n\n        vec4 tester_samp = texture(iChannel0, distance_tester_pos);\n        float tester_dist = length(tester_samp.rg);\n\n        if(tester_dist < 1e9)\n        {\n            vec2 pixel_pos = fragCoord.xy;\n            float circ = abs(length(distance_tester_pos* iResolution.xy - pixel_pos) - tester_dist);\n            float alpha = smoothstep(3., 1., circ );\n            color = mix(color, vec3(1), 0.5*alpha);\n\n            float tester_dot = length(distance_tester_pos* iResolution.xy - pixel_pos)-5.;\n            alpha = smoothstep(2., -1., tester_dot);\n            color = mix(color, vec3(1), alpha);\n\n\n            float tester_proj = length(distance_tester_pos* iResolution.xy + tester_samp.rg - pixel_pos)-5.;\n            alpha = smoothstep(2., -1., tester_proj);\n            color = mix(color, vec3(1), alpha);\n\n            float tester_proj_seg = seg(distance_tester_pos* iResolution.xy, distance_tester_pos* iResolution.xy + tester_samp.rg, pixel_pos);\n            alpha = smoothstep(3., 1., tester_proj_seg);\n            color = mix(color, vec3(1), alpha);\n        }\n    }\n    \n    // field iso lines\n    #if SHOW_ISOLINES\n    float f = pow(abs(cos(3.14159265 * dist/15.)), 20.);\n    color = mix(color, vec3(step(0., samp.b)), .5*f);\n    #endif\n    \n    // Draw brush\n    if(iMouse.z > 0.) \n    {\n        float dist = abs(length(uv-mouse) - 0.125);\n        float alpha = smoothstep(2. * ps, ps, dist);\n        color = mix(color, vec3(0), .5*alpha);\n    }\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ij = ivec2(fragCoord);\n\n    const int N = 13;\n\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy) / iResolution.y;\n    bool mouse_down = iMouse.z > 0.;\n\n    // Initialize variables\n    float current_dist = 9e9;\n    vec2 current_offset = vec2(9e9);\n    float current_fill = 0.;\n    float current_sign = 1.;\n\n    if(iFrame == 0) // Initial pattern\n    {\n        if(min(1.5-length(uv), length(uv)-0.125 + .5*sin(5.*atan(uv.y,uv.x))) < 0.) \n        {\n            current_sign = -1.;\n        }\n    }\n    else // Jump flood\n    {\n        // pow2, e.g.: 256, 128, 64, 32, 16, 8, 4, 2, 1\n        // jump_size for iFrame%N == N-1 should be 1,\n        // therefore  min(iFrame%N + 1, N) should be N\n        int jump_size = (1 << N) >> min(iFrame % N + 1, N);\n\n        // Track if this pixel changes sign this frame,\n        // If it does, then the JFA would find itself or a previous neighbor in the search,\n        // so we skip JFA search for a frame if this happens.\n        bool sign_change_this_frame = false;\n    \n        vec4 prev = texelFetch(iChannel0, ij, 0);\n       \n        current_dist = length(prev.rg);\n        current_offset = prev.rg;\n        current_sign = prev.b;    // -1 or 1\n        current_fill = prev.a;    // 0 or 1\n        \n        if(length(uv-mouse) < 0.125 && mouse_down) \n        {\n            current_sign = -1. + 2. * texelFetch(iChannel3, ivec2(32. ,0), 0).r ;\n        }\n\n        vec4 prev_target = texelFetch(iChannel0, ij + ivec2(prev.rg), 0);\n\n        sign_change_this_frame = current_sign != prev.b;\n\n        // If this pixel sign or if the target solution fill value changed/no longer matches...\n        if(sign_change_this_frame || current_sign == prev_target.b) \n        {// ... Then we need to reset this pixel:\n                current_dist = 9e9;\n                current_offset = vec2(9e9);\n                current_fill = 0.;\n                sign_change_this_frame = true;\n        }\n    \n\n        if(!sign_change_this_frame)\n        for(int x = -1; x <= 1; ++x)\n        for(int y = -1; y <= 1; ++y)\n        {\n            ivec2 jump = jump_size * ivec2(x,y);\n            ivec2 coord = ij + jump;\n            if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y))\n            {\n                continue;\n            }\n\n            vec4 samp = texelFetch(iChannel0, coord, 0);\n\n            bool samp_fill = samp.a > .5;\n            bool samp_sign_match = samp.b == current_sign;\n\n            vec2 samp_offset = samp.rg;\n            vec2 candidate_offset = samp_sign_match ? vec2(jump) + samp_offset : vec2(jump);\n            float candidate_dist = length(candidate_offset);\n\n            if (candidate_dist < current_dist && (samp_fill || !samp_sign_match) )\n            {\n                current_dist = candidate_dist;\n                current_offset = candidate_offset;\n                current_fill = 1.;\n            }\n        }\n    }\n    // save offset, sign and fill\n    fragColor = vec4(current_offset, current_sign, current_fill);\n}","name":"Buffer A","description":"","type":"buffer"}]}