{"ver":"0.1","info":{"id":"MsScWW","date":"1492135129","viewed":142,"name":"IIS Hyperbolic Example","username":"soma_arc","description":"Render the orbit of circles with Iterated Inversion System.\nHyperbolic Generator.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","inversion","schottky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 makeCircleFromPoints(vec2 a, vec2 b, vec2 c){\n    float lA = distance(b, c);\n    float lB = distance(a, c);\n    float lC = distance(a, b);\n    float coefA = lA * lA * (lB * lB + lC * lC - lA * lA);\n    float coefB = lB * lB * (lA * lA + lC * lC - lB * lB);\n    float coefC = lC * lC * (lA * lA + lB * lB - lC * lC);\n    float denom = coefA + coefB + coefC;\n    vec2 center = (coefA * a + coefB * b + coefC * c)/denom;\n    return vec3(center, distance(center, a));\n}\n\nvec2 circleInvert(vec2 pos, vec3 circle){\n\treturn ((pos - circle.xy) * circle.z * circle.z)/(length(pos - circle.xy) * length(pos - circle.xy) ) + circle.xy;\n}\n\nfloat RT_2 = sqrt(2.);\nvec3 circleInvertOnCircle(vec3 invertCircle, vec3 genCircle){\n    float coeffR = invertCircle.z * RT_2 / 2.;\n    vec2 p1 = circleInvert(invertCircle.xy + vec2(coeffR), \n                           genCircle);\n    vec2 p2 = circleInvert(invertCircle.xy + vec2(-coeffR),\n                           genCircle);\n    vec2 p3 = circleInvert(invertCircle.xy + vec2(coeffR, -coeffR), \n                           genCircle);\n    return makeCircleFromPoints(p1, p2, p3);\n}\n\nvoid calcCircleLineIntersection(vec3 c, vec2 lineDir, vec2 linePoint,\n                                out vec2 isect1, out vec2 isect2){\n    float a = lineDir.x;\n    float b = lineDir.y;\n\n    float d = a * (c.y - linePoint.y) - b * (c.x - linePoint.x);\n    float a2b2 = a * a + b * b;\n    float rt = a2b2 * c.z * c.z - d * d;\n    if(rt > 0.){\n        rt = sqrt(rt);\n        float ab = a * (c.x - linePoint.x) + b * (c.y - linePoint.y);\n        float tPlus = (ab + rt) / a2b2;\n        float tMinus = (ab - rt) / a2b2;\n        isect1 = vec2(a * tPlus + linePoint.x, b * tPlus + linePoint.y);\n        isect2 = vec2(a * tMinus + linePoint.x, b * tMinus + linePoint.y);\n        if(isect1.x < isect2.x){\n        \tvec2 tmp = isect1;\n            isect1 = isect2;\n            isect2 = tmp;\n        }\n    }else if(rt == 0.){\n        float ab = a * (c.x - linePoint.x) + b * (c.y - linePoint.y);\n        float t = ab / a2b2;\n        vec2 isect = vec2(a * t + linePoint.x, b * t + linePoint.y);\n        isect1 = isect;\n        isect2 = isect;\n    }\n}\n\nvec2 positionOnCircle(vec3 circle, float rad){\n\treturn circle.xy + vec2(circle.z * cos(rad),\n                \t\t\tcircle.z * sin(rad));\n}\n\nconst float PI = 3.1415926535;\nconst float PI_2 = PI / 2.;\n\nconst float schottky1R = 100.;\nconst float schottky2R = 80.;\nconst float schottky3R = 50.;\nconst float schottky4R = 38.;\nvec3 schottky1 = vec3(60, 210, schottky1R);\nvec3 schottky2 = vec3(-120, 180, schottky2R);\nvec3 schottky3 = vec3(170, 110, schottky3R);\nvec3 schottky4 = vec3(-190, 80, schottky4R);\n\n// Parabolic Generator\nvec3 C1 = vec3(50, -20, 130.);\nvec3 C2 = vec3(0, 0, 200);\nvec3 C1d; // C1' = I_C2(C1)\n\n\nconst int MAX_ITERATIONS = 55;\nfloat colNum = 0.;\nint iterations = 0;\nfloat IIS(vec2 pos){\n    colNum = 0.;\n    float loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < MAX_ITERATIONS ; i++){\n        if(i > iterations) break;\n\t\tcont = false;\n        \n        \n\t\tif(distance(pos, schottky1.xy) < schottky1.z){\n\t\t\tpos = circleInvert(pos, schottky1);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, schottky2.xy) < schottky2.z){\n\t\t\tpos = circleInvert(pos, schottky2);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, schottky3.xy) < schottky3.z){\n\t\t\tpos = circleInvert(pos, schottky3);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, schottky4.xy) < schottky4.z){\n\t\t\tpos = circleInvert(pos, schottky4);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}// Parabolic generator\n        else if(distance(pos, C1.xy) < C1.z){\n           pos = circleInvert(pos, C1);\n           pos = circleInvert(pos, C2);\n           cont = true;\n           //loopNum++;\n        }else if(distance(pos, C1d.xy) >= C1d.z){\n           pos = circleInvert(pos, C2);\n           pos = circleInvert(pos, C1);\n           cont = true;\n           //loopNum++;\n        }\n        \n\t\tif(cont == false) break;\n\t}\n\n\treturn loopNum;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 renderGen(const vec2 pos, const vec3 C1, const vec3 C2, const vec3 C1d){\n    if(distance(pos, C1.xy) < C1.z){\n    \treturn vec3(.5, 0, 0);\n    }else if(distance(pos, C2.xy) < C2.z){\n    \treturn vec3(0, .5, 0);\n    }else if(distance(pos, C1d.xy) < C1d.z){\n    \treturn vec3(0, 0, .5);\n    }\n    return vec3(0);\n}\n\nvec3 gammaCorrect(vec3 c){\n    const float gammaCoeff = 1. / 2.2;\n\treturn vec3(pow(c.x, gammaCoeff),\n               \tpow(c.y, gammaCoeff),\n               \tpow(c.z, gammaCoeff));\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 sum = vec3(0);\n    float t = mod(iTime, 20.);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    \n    float rotation = t * 1.6;\n    float offsetR = 20. * sin(rotation) + 40.;\n    vec2 contactP = vec2(C2.z * cos(rotation), C2.z * sin(rotation));\n\n    float startTime = 0.;\n    schottky1.z = mix(0., schottky1R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n    \n    iterations += (t > startTime + 0.1) ? 1 : 0;\n    iterations += (t > startTime + 0.2) ? 1 : 0;\n    iterations += (t > startTime + 0.3) ? 1 : 0;\n    iterations += (t > startTime + 0.4) ? 1 : 0;\n    iterations += (t > startTime + 0.5) ? 1 : 0;\n    iterations += (t > startTime + 0.6) ? 1 : 0;\n    iterations += (t > startTime + 0.7) ? 1 : 0;\n    iterations += (t > startTime + 0.8) ? 1 : 0;\n    iterations += (t > startTime + 0.9) ? 1 : 0;\n    iterations += (t > startTime + 1.) ? 1 : 0;\n    \n    startTime += 1.;\n    \n    if(t > startTime && t < startTime + PI * 8. / 1.6)\n    \tC1.x = 50. * (cos(1.6* (t - startTime)));\n    \n    iterations += int(mix(0., 30.,\n                         scene(t, startTime, 0.5)));\n    startTime += 2.;\n    \n    schottky2.z = mix(0., schottky2R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\t\n    startTime += 2.;\n  \n    schottky3.z = mix(0., schottky3R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n  \n    schottky4.z = mix(0., schottky4R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n    \n    schottky1.z += mix(0., -schottky1R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n    \n    schottky2.z += mix(0., -schottky2R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\t\n    startTime += 2.;\n  \n    schottky3.z += mix(0., -schottky3R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n  \n    schottky4.z += mix(0., -schottky4R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    \n    C1d = circleInvertOnCircle(C1, C2);\n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\t\tposition = position * 2000.;\n//        position *= 1.2 + 1. * sin(t);\n//        position.x += 800. * cos(t);\n        \n        float loopNum = IIS(position);\n\n        if(loopNum >  0.){\n            sum += hsv2rgb(vec3(0.01 + 0.03 * (loopNum - 1.),1.0,1.0));\n        }else{\n            sum += renderGen(position, C1, C2, C1d);\n            //sum += vec3(0.,0.,0.);\n        }\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}","name":"Image","description":"","type":"image"}]}