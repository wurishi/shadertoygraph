{"ver":"0.1","info":{"id":"wtcXRf","date":"1581432172","viewed":126,"name":"2d Electric Shader With Music","username":"foez","description":"was trying something, but got this...\n\nTry it with different music in iChannel0\nTry changing color in line 48, 49 and 50;","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["music","random","electric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), \n             dot(p, vec2(269.5, 183.3)));\n    \n    return -1. + 2.*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n    vec2 i = floor(p + (p.x+p.y)*K1);\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step(a.yx, a.xy);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1. + 2.*K2;\n    vec3 h = max(.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.);\n    vec3 n = h*h*h*h*vec3(dot(a, hash(i)),\n                          dot(b, hash(i+o)),\n                          dot(c, hash(i+1.)));\n    return dot(n, vec3(70));\n}\n\nfloat fbm(vec2 p, float t) {\n    vec2 offset = vec2(cos(t), 0);\n    float aggr = 0.;\n    \n    aggr += noise(p);\n    aggr += 0.5*noise(p+offset);\n    aggr += 0.25*noise(p+offset.yx);\n    aggr += 0.125*noise(p-offset);\n    aggr += 0.0625*noise(p-offset.yx);\n    \n    aggr /= 1.+0.5+0.25+0.125+0.0625;\n    \n    return 0.5 + 0.5*aggr;\n}\n\nvec3 lightning(vec2 p, float offset) {\n    float time = iTime;\n    vec2 f = vec2(0, -time*.50);\n    \n    vec3 col = vec3(0);\n    int i = 0;\n    for(i=0;i<4;i++){\n        float n = abs(offset*0.02/(1.+offset-fbm((p+f)*2., time+float(i))));\n        float n2 = abs(offset*0.02/(1.+offset-fbm((p+f)*3., time+float(i)*10.)));\n        float n3 = abs(offset*0.02/(1.+offset-fbm((p+f)*3., time+float(i)*20.)));\n        col += n*vec3(1, 0.0, .0);    \n        col += n2*vec3(1);\n        col += n3*vec3(0, 0, 1);\n    }\n    \n    return col;\n}\n\nfloat df(vec2 p, int opt) {\n    p.y = 1.-p.y;\n  \n    p *= iResolution.xy/vec2(1123., 179.);\n    \n    vec2 p2 = p;\n   \n    p2.x += floor(p.y)*1.3;\n    p2 -= vec2(0.06, 3.5);\n    p -= vec2(0.06, -1.);\n\n    \n    float d = texture(iChannel0, p).r;\n    \n\n    \n    float d1 = texture(iChannel0, p2-vec2(-2, 0)).r;\n    if(opt == 1) return d1;\n\n    \n    return -1.+2.*d;\n}\n\n\n\n\nvec4 main1(vec2 uv, vec2 oo)\n{\n    vec3 col = vec3(0);\n    float n;\n    vec2 p = uv;\n    \n    float d = length(p)-1.;\n    d = df(oo, 0);\n    float d1 = df(oo, 1);\n    \n    col += lightning(uv, d-1.0);\n    col *= smoothstep(0., 1., d);\n    return vec4(col, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n   \n    fragColor = main1(uv, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"}]}