{"ver":"0.1","info":{"id":"DtfcD7","date":"1690805501","viewed":52,"name":"Spotlight test","username":"okarable","description":"just a test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define FLOOR_COLOR vec3(0.2, 0., 0.)\n#define BOX_COLOR vec3(0., 0.2, 0.2)\n\nvec3 rotate(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\nvec4 distFloor(vec3 p, vec3 n) {\n\tn = normalize(n);\n\treturn vec4(FLOOR_COLOR, dot(p, n) + 1.);\n}\n\nvec4 distBox(vec3 p, vec3 q) {\n\treturn vec4(BOX_COLOR, length(max(abs(p) - q, 0.)) - 0.002);\n}\n\nvec4 distAll(vec3 p) {\n\tvec4 df = distFloor(p, vec3(0., 1., 0.));\n\tvec4 db = distBox(rotate(p - vec3(0., -0.5, 2.7), iTime, vec3(0., 1., 0.)), vec3(0.3));\n\tvec4 ret = df.w < db.w ? df : db;\n\treturn ret;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat delta = 0.005;\n\n\treturn normalize(vec3(\n\t\tdistAll(vec3(p.x + delta, p.y, p.z)).w - distAll(vec3(p.x - delta, p.y, p.z)).w,\n\t\tdistAll(vec3(p.x, p.y + delta, p.z)).w - distAll(vec3(p.x, p.y - delta, p.z)).w,\n\t\tdistAll(vec3(p.x, p.y, p.z + delta)).w - distAll(vec3(p.x, p.y, p.z - delta)).w\n\t));\n}\n\nfloat genShadow(vec3 p, vec3 ld) {\n\tfloat h = 0.;\n\tfloat c = 0.001;\n\tfloat r = 1.;\n\tfloat shadowCoef = 0.5;\n\tfor (int i = 0; i < 100; i++) {\n\t\th = distAll(p + ld * c).w;\n\t\tif (h < 0.001) {\n\t\t\treturn shadowCoef;\n\t\t}\n\t\tr = min(r, h * 2. / c);\n\t\tc += h;\n\t}\n\treturn mix(shadowCoef, 1., r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = fragCoord / iResolution.xy;\n\tvec2 r = vec2(2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfloat xMax = iResolution.x / iResolution.y;\n\n\tfloat screenZ = 4.;\n\tvec3 cameraPosition = vec3(0., 0., 10.) - vec3(0., 0., 5.);\n\n\tvec3 rayDirection = normalize(vec3(r, screenZ) - cameraPosition);\n\n\tvec3 lightPosition = cameraPosition + vec3(0., 2., 0.);\n\tvec3 lightCenter = normalize(vec3(0., -0.5, 3.3) - lightPosition);\n\tvec3 lightDirection = normalize(vec3(1., 1., 1.));\n\n\tvec3 rayPosition = cameraPosition;\n\n\tvec3 color = vec3(0.);\n\tfloat rayLengthSum = 0.;\n\tvec4 dist = vec4(1.);\n\tfloat shadow = 1.;\n\tfloat scale = 0.;\n\n\tfor (int i = 0; i < 50; i++) {\n\t\tdist = distAll(rayPosition);\n\t\trayLengthSum += dist.w;\n\t\tif (abs(dist.w) < 0.001) {break;}\n\t\trayPosition = rayPosition + rayDirection * abs(dist.w);\n\t}\n\n\tif (abs(dist.w) < 0.001) {\n\t\tvec3 normal = getNormal(rayPosition);\n\t\tvec3 reflectDirection = rayDirection + 2. * dot(- rayDirection, normal) * normal;\n\n\t}\n\n\tif (abs(dist.w) < 0.001) {\n\t\t// generate normal\n\t\tvec3 normal = getNormal(rayPosition);\n\n\t\tlightDirection = normalize(lightPosition - rayPosition);\n\n\t\tshadow = genShadow(rayPosition + normal * 0.001, lightDirection);\n\n\t\tscale = smoothstep(0.975, 0.985, dot(lightCenter, - lightDirection));\n\t\tvec3 H = normalize((lightDirection + (cameraPosition - rayPosition)) / 2.);\n\t\tcolor = scale * vec3(max(0., 0.5 * dot(normal, lightDirection) + 0.5 * pow(dot(normal, H), 10.))) + dist.xyz;\n\t}\n\n\tfragColor = vec4(color * max(0.5, shadow), 1.0);\n}","name":"Image","description":"","type":"image"}]}