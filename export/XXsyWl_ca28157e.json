{"ver":"0.1","info":{"id":"XXsyWl","date":"1726788700","viewed":44,"name":"Generalized Sierpiński curve","username":"TriKri","description":"Generalized Sierpiński curve, colored by the distance along the curve from the start. Inspired by https://www.shadertoy.com/view/mlS3Rm","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sierpiski","sierpiskicurve"],"hasliked":0,"parentid":"4XfyDX","parentname":"Hilbert curve generator"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Sierpiński curve: https://en.wikipedia.org/wiki/Sierpi%C5%84ski_curve\n * \"H curve\": https://www.shadertoy.com/view/mlS3Rm\n * \n * Generalized Sierpiński curve, colored by the distance along the curve from the start.\n */\n\n\nconst int min_iterations = 0;\nconst int max_iterations = 20;\nconst float timePerIteration = 1.5;\nconst float squareHeight = 1.0;\nconst float thickness = 0.25;\nconst float minThicknessPx = 3.0;\nconst float edgeHalfStepLengthPx = 0.75;\nconst float verticalOffset = 1.0 / 3.0;\n//const float verticalOffset = 1.0 / 2.0;\n//const float verticalOffset = sqrt((1.0-sqrt(0.5))/(1.0+sqrt(0.5)));\n//const float gamma = 1.0; // Used for gamma correction\nconst float gamma = 2.2; // Used for gamma correction\nconst vec3 backgroundColor = vec3(0);\n\nvec3 alphaToColor(float alpha) {\n    float Alpha = mod(6.0 * alpha, 6.0);\n    int A = int(Alpha);\n    float a = Alpha - float(A);\n    switch (A) {\n        case 0: return vec3(1.0  ,     a, 0.0  ); // Red to yellow\n        case 1: return vec3(1.0-a, 1.0  , 0.0  ); // Yellow to green\n        case 2: return vec3(0.0  , 1.0  ,     a); // Green to cyan\n        case 3: return vec3(0.0  , 1.0-a, 1.0  ); // Cyan to blue\n        case 4: return vec3(    a, 0.0  , 1.0  ); // Blue to magenta\n        case 5: return vec3(1.0  , 0.0  , 1.0-a); // Magenta to red\n        case 6: return vec3(1, 0, 0); // Red (somesimes the modulation will return 6.0)\n    }\n}\n\nvec3 gammaCorrected(vec3 col) {\n    float newGamma = pow(gamma, min(1.0-(col.z-col.x), 1.0));\n    return vec3(pow(col.x, 1.0/newGamma), pow(col.y, 1.0/newGamma), pow(col.z, 1.0/newGamma));\n    return vec3(pow(col.x, 1.0/gamma), pow(col.y, 1.0/gamma), pow(col.z, 1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Resolutionagnostic pixel coordinates\n    float pixelSize = 1.0 / (min(iResolution.x, iResolution.y) * squareHeight);\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) * pixelSize + 0.5;\n    \n    bool inSquare = uv.x >= 0.0 && uv.x < 1.0 && uv.y >= 0.0 && uv.y < 1.0;\n    \n    if (!inSquare) {\n        fragColor = vec4(gammaCorrected(backgroundColor), 1.0);\n        return;\n    }\n    \n    // Find start triangle\n    float inv = 0.0;\n    if (uv.x < uv.y) {\n        // Rotate 180 degrees around the middle\n        uv = vec2(1) - uv;\n        inv += 0.5;\n    }\n    if (uv.x + uv.y > 1.0) {\n        // Rotate 90 clockwise around the middle\n        uv = vec2(uv.y, 1.0 - uv.x);\n        inv += 0.25;\n    }\n    \n    // Divide and conquer the triangle\n    float prec = 0.25;\n    vec2 inDir = vec2(-1,1);\n    vec2 outDir = vec2(1,1);\n    int max_k = min_iterations + int(iTime / timePerIteration) % (max(max_iterations - min_iterations, 0) + 1);\n    for (int k = 0; k < max_k; k++) {\n        int order;\n        if (uv.x < 0.5) {\n            order = 0;\n            inDir  = vec2(inDir.x + inDir.y, inDir.x - inDir.y);\n            uv     = vec2(   uv.x +    uv.y,    uv.x -    uv.y);\n            outDir = vec2(1, 1);\n        }\n        else {\n            order = 1;\n            inDir  = vec2(-1, 1);\n            uv     = vec2(    uv.x -     uv.y, 1.0 -     uv.x -     uv.y);\n            outDir = vec2(outDir.x - outDir.y,     - outDir.x - outDir.y);\n        }\n        pixelSize *= sqrt(2.0);\n        prec *= 0.5;\n        inv += prec * float(order);\n    }\n    \n    // Normalize in and out directions\n    inDir  /= length(inDir );\n    outDir /= length(outDir);\n    \n    uv -= vec2(0.5, verticalOffset/2.0);\n    vec2 mostAlignedDir = dot(uv, inDir) > dot(uv, outDir) ? inDir : outDir;\n    float doubleDistToWall = mostAlignedDir.y < 0.0 ? verticalOffset : (1.0-verticalOffset)/sqrt(2.0);\n    float cosAngle = -dot(inDir, outDir);\n    float tanHalfAngle = sqrt((1.0 - cosAngle)/(1.0 + cosAngle));\n    float deadStartDistance = thickness * tanHalfAngle;\n    inv += prec * max((dot(uv, mostAlignedDir) - 0.5*deadStartDistance) / (doubleDistToWall - deadStartDistance), 0.0) * (mostAlignedDir == outDir ? 1.0 : -1.0);\n    uv -= max(dot(uv, mostAlignedDir), 0.0) * mostAlignedDir;\n    float curveDist = length(uv);\n    curveDist = 0.5 * max(thickness, minThicknessPx*pixelSize) - curveDist;\n    \n    float edgeHalfStepLength = edgeHalfStepLengthPx * pixelSize;\n    float onCurve = smoothstep(-edgeHalfStepLength, edgeHalfStepLength, curveDist);\n    vec3 col = mix(backgroundColor, alphaToColor(inv), onCurve);\n    \n    // Gamma correct colors\n    col = gammaCorrected(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}