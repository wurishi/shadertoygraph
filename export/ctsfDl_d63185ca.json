{"ver":"0.1","info":{"id":"ctsfDl","date":"1694373947","viewed":32,"name":"Mandelbulb Morph","username":"Domenic3000","description":"Mandelbulb","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592;\nconst int GRADIENT_SIZE = 5;\n\nvec3 getGradientColor(int index) {\n    if (index == 0) return vec3(0.1, 0.4, 0.8);      \n    if (index == 1) return vec3(0.0, 0.2, 0.2);      \n    if (index == 2) return vec3(1.4, 0.4, 0.6);     \n    if (index == 3) return vec3(0.8, 0.4, 0.0);      \n    if (index == 4) return vec3(1.0, 0.5, 1.0);      \n    return vec3(0.0); // Default color\n}\n\nfloat gradientNoise(vec3 position) {\n    return fract(sin(dot(position, vec3(12.9898, 78.233, 54.53))) * 43758.5453);\n}\n\nvec3 getColorFromGradient(float t) {\n    float timeOffset = 0.5 * sin(iTime * 0.2);\n    t = mod(t + timeOffset, 1.0);\n\n    // Add gradient noise for richer color depth\n    t += 0.1 * gradientNoise(vec3(t, iTime, 0.0));  // Adjust 0.1 for noise intensity\n\n    int index = int(t * float(GRADIENT_SIZE - 1));\n    int nextIndex = min(index + 1, GRADIENT_SIZE - 1);\n    float alpha = fract(t * float(GRADIENT_SIZE - 1));\n    \n    return mix(getGradientColor(index), getGradientColor(nextIndex), alpha);\n}\n\nvec3 rotateX(vec3 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nfloat drippingEffect(float y) {\n    float frequency = 0.2; // Adjust for more/less frequent drips\n    float amplitude = 0.02; // Adjust for larger/smaller drips\n    float gradient = smoothstep(-1.0, 1.0, y); // Vertical gradient from 0 to 1\n    float sinusoidal = amplitude * sin(frequency * iTime + 6.0 * PI * gradient);\n    float displacement = -0.3 * gradient * gradient; // Downward displacement increases with gradient\n    return sinusoidal + displacement;\n}\n\nfloat mandelbulb(vec3 pos, out int iterations) {\n    // Dripping effect\n    float drip = drippingEffect(pos.y);\n    pos.y += drip;\n    \n    pos = rotateX(pos, iTime/20.0);  // Rotate fractal over time\n    pos = rotateY(pos, iTime/30.0);  // Rotate fractal over time\n    \n    pos += vec3(0.1 * sin(iTime*.2), 0.1 * cos(iTime*.2), 0.0);\n    \n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    const int maxIterations = 8;\n    const float bailout = 2.0;\n    float power = 8.0 + 4.0 * sin(iTime * 0.04);\n    iterations = 0;\n\n    for (int i = 0; i < maxIterations; i++) {\n        r = length(z);\n        if (r > bailout) {\n            iterations = i;\n            break;\n        }\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr = pow(r, power-1.0)*power*dr + 1.0;\n        float zr = pow(r,power);\n        theta = theta*power;\n        phi = phi*power;\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z += pos;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nvec3 getNormal(vec3 pos) {\n    const vec3 smallOffset = vec3(0.001, 0.0, 0.0);\n    vec3 normal;\n    int dummy;\n    normal.x = mandelbulb(pos + smallOffset.xyy, dummy) - mandelbulb(pos - smallOffset.xyy, dummy);\n    normal.y = mandelbulb(pos + smallOffset.yxy, dummy) - mandelbulb(pos - smallOffset.yxy, dummy);\n    normal.z = mandelbulb(pos + smallOffset.yyx, dummy) - mandelbulb(pos - smallOffset.yyx, dummy);\n    return normalize(normal);\n}\n\nvec3 computeLighting(vec3 normal, vec3 lightDir) {\n    float diff = max(dot(normal, lightDir), 0.0);\n    return diff * vec3(1.0); // white light\n}\n\n// Brightness and Contrast Adjustment\nvec3 adjustBrightnessContrast(vec3 color, float brightness, float contrast) {\n    color += brightness;\n    color = (color - 0.5) * contrast + 0.5;\n    return clamp(color, 0.0, 1.0); // Ensure values stay in the [0, 1] range\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 dithering(vec3 color, vec2 fragCoord) {\n    float dither = rand(fragCoord) * 0.05; // Change 0.05 to adjust dither strength\n    return color + vec3(dither);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / min(iResolution.y, iResolution.x);\n    vec3 camPos = vec3(0.0, 0.0, -3.0);\n    vec3 camTarget = vec3(0.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = cross(camDir, camRight);\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    float totalDist = 0.0;\n    const int maxSteps = 128;\n    const float maxDist = 20.0;\n    const float minDist = 0.001;\n    vec3 pos;\n    int iterations;\n    for (int i = 0; i < maxSteps; i++) {\n        pos = camPos + rayDir * totalDist;\n        float dist = mandelbulb(pos, iterations);\n        totalDist += dist;\n        if (dist < minDist || totalDist > maxDist) break;\n    }\n    \n    // Explicitly check if the fractal was hit\n    vec3 finalColor;\n    if (iterations < maxSteps) {\n        finalColor = getColorFromGradient(pow(float(iterations) / float(maxSteps), .25));\n    } else {\n        finalColor = vec3(0.0, 0.0, 0.0); // Black background\n    }\n\n    // Adjust brightness and contrast\n    const float brightness = 0.3;  // Adjust this value for desired brightness\n    const float contrast = 0.4;   // Adjust this value for desired contrast\n    finalColor = adjustBrightnessContrast(finalColor, brightness, contrast);\n    \n    vec3 lightDir = normalize(vec3(40.0, 70.0, 0.0)); // Some light direction\n    vec3 normal = getNormal(pos);\n    vec3 lightColor = computeLighting(normal, lightDir);\n    finalColor *= lightColor;\n    \n    float ambientStrength = 0.3;\n    vec3 ambient = ambientStrength * vec3(1.0); // white light\n\n    vec3 viewDir = normalize(camPos - pos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 20.0);\n    vec3 specular = spec * vec3(1.0); // white light\n\n    finalColor *= (ambient + lightColor + specular);\n    \n   \n    \n    finalColor = dithering(finalColor, fragCoord);\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}