{"ver":"0.1","info":{"id":"7syXzd","date":"1635120576","viewed":57,"name":"45/49","username":"tono","description":"45/49","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["49"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat pi = acos(-1.);\nvec2 pmod(vec2 p, float r){float a = atan(p.x,p.y)+pi/r;float n=(pi*2.)/r;return p*rot(-(floor(a/n)*n));}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat bo(vec3 p,vec3 s){p=abs(p)-s;return max(p.x,max(p.y,p.z));}\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n  //  u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\nvec2 pumpkin(vec3 p,float y , float st)\n{\n    float o = 10.;\n    float id = 0.;\n    \n    p.y *= y;\n    float t = (iTime+ st)/10.;\n    t = floor(t) + pow(fract(t),3.);\n    p.y += abs(sin(t * pi * 2.)) * 10.;\n    vec3 pp = p;\n    \n    p.xz = pmod(p.xz,13.);\n    p.z -= .5;\n    float yy = (sin(p.y+iTime*5.)*.5+.5)/1.;\n    \n    yy = sin(t * pi * 2.);\n    o = length(vec2(length(p.yz)-.3,p.x))-.5 + yy*.1;\n    pp.y *= mix(1., yy*1.5,.1);\n    float cyl = sdRoundedCylinder(pp+vec3(0.,.8,0.),0.05,0.02,0.3);\n    \n    if(o > cyl)\n    {\n        o = cyl;\n        id = 1.;\n    }\n    \n    \n    return vec2(o,id);\n}\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    vec3 pp = p;\n    \n    vec2 pump = pumpkin(pp,1.,-3.);\n    //pp.xz *= (sin(p.y)*.5+.5 + .8);\n    pp.x += 3.;\n    pp.z -= 2.;\n    pp.y += .3;\n    // pp.x -= 2.3;\n    // pp.z -= .1;\n    // pp.y += 0.3;\n    //pp.xy *= rot(0.8);\n    //pp.yz *= rot(0.4);\n    vec2 pump2 = pumpkin(pp,.7,3.);\n    if(pump.x > pump2.x)\n    {\n        pump = pump2;\n    }\n    o = pump.x;\n    id = pump.y;\n    p.y += sin(p.x * .5 + p.z * .3 + .3)/3.;\n    float b = bo(p-vec3(0.,1.45*2.,0.),vec3(13.,2.,13.));\n    \n    if(o > b)\n    {\n        o = b;\n\t\tif(o < .1)\n        {\n            o -= noise(p*10.)/30.;\n            o -= noise(p * 30.)/70.;\n        }\n        id = 2.;\n    }\n    else if(o < 0.03)\n    {\n        o -= noise(p*100.)/100.;\n    }\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.001)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(-3.,-2.,-12.);\n    cp.xz *= rot(iTime/12.);\n    cp.y += sin(iTime/6.);\n    vec3 target = vec3(0.,-1.3,0.);\n    target.xz += sin(iTime/7.)/1.;\n    cp.x += step(sin(iTime/2.),0.3) * -10.;\n    cp.y += step(sin(iTime/2.),0.3) * -10.;\n    vec3 col = vec3(0.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    if( d.x > 0.)\n    {\n       \tvec2 e = vec2(1.0, -1.0) * .05;\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        vec3 sun = normalize(vec3(5.,4.,2.));\n       // sun.xz *= rot(iTime/2.);\n        float diff = max(0.,dot(-sun,N));\n        diff = mix(diff , 1.,.1);\n        float sp = max(0.,dot(rd,reflect(N,sun)));\n        sp = pow(sp,1.6) * .3;\n        vec3 mat = mix(vec3(1.,0.5,0.),vec3(0.7,1.,0.),d.y);\n        if(d.y > 1.)mat = mix(vec3(.5,.15,0.2),vec3(0.2,0.23,0.),noise(pos*100.*(1./(d.x*.3)) ));\n        float shadow = step(march(pos + N * 0.01,-sun).x,0.);\n        float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 4.) * (.2+step(d.y,1.)*.2);\n        float up = max(0.,dot(N,vec3(0.,-1.,0.)));\n        float down = max(0.,dot(N,vec3(0.,1.,0.)));\n        \n        col = sp * mat + diff * mat + up * vec3(0.1) + down * vec3(0.1,0.12,.1);\n        col += rim;\n        col = floor(col * 3.)/2.4;\n        if(d.y > 1.)\n        { \n            col =mix( vec3(0.),col,shadow);\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}