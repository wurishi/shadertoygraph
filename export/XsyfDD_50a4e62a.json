{"ver":"0.1","info":{"id":"XsyfDD","date":"1528820577","viewed":700,"name":"THX","username":"mmerchante","description":"Decided to make a tribute to both the sound and visuals for THX's Deep Note intro. Sound is hard! And it's by no means accurate, but it was fun to play with it. Please use headphones!! ","likes":38,"published":1,"flags":8,"usePreview":0,"tags":["raymarching","sound","logo","synthesizer","chirp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n * Please use headphones!!\n * Decided to implement both the sound and visuals for THX's Deep Note intro.\n * Based on what THX published about how it was made, but I definitely do not know\n * enough to match it correctly.\n * Raymarching for the letters, spherical gaussians for the shading.\n * Fake glow, but I think it would look way better if I implemented a nice post process fx\n */\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MAX_STEPS 25\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define MAX_DISTANCE 10.0\n#define MIN_DISTANCE 6.0\n#define EPSILON .002\n#define EPSILON_NORMAL .01\n\n#define LIGHT_COUNT 16\n\n// iq\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// ---------------------------------------------------------\n\n// All SG math taken from \n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\nstruct SG\n{\n    vec3 Amplitude;\n    vec3 Axis;\n    float Sharpness;\n};\n    \nvec3 EvaluateSG(in SG sg, in vec3 dir)\n{\n    float cosAngle = dot(dir, sg.Axis);\n    return sg.Amplitude * exp(sg.Sharpness * (cosAngle - 1.0f));\n}\n\nSG SGProduct(in SG x, in SG y)\n{\n    vec3 um = (x.Sharpness * x.Axis + y.Sharpness * y.Axis) / (x.Sharpness + y.Sharpness);\n    float umLength = length(um);\n    float lm = x.Sharpness + y.Sharpness;\n \n    SG res;\n    res.Axis = um * (1.0f / umLength);\n    res.Sharpness = lm * umLength;\n    res.Amplitude = x.Amplitude * y.Amplitude * exp(lm * (umLength - 1.0f));\n \n    return res;\n}\n\nvec3 SGIntegral(in SG sg)\n{\n    float expTerm = 1.0f - exp(-2.0f * sg.Sharpness);\n    return 2.0 * 3.141592 * (sg.Amplitude / sg.Sharpness) * expTerm;\n}\n \nvec3 ApproximateSGIntegral(in SG sg)\n{\n    return 2.0 * 3.141592 * (sg.Amplitude / sg.Sharpness);\n}\n\n// Equals to the integral of the product of two SGs\nvec3 SGInnerProduct(in SG x, in SG y)\n{\n    float umLength = length(x.Sharpness * x.Axis + y.Sharpness * y.Axis);\n    vec3 expo = exp(umLength - x.Sharpness - y.Sharpness) *x.Amplitude * y.Amplitude;\n    float other = 1.0f - exp(-2.0f * umLength);\n    return (2.0f * 3.141592 * expo * other) / umLength;\n}\n\nfloat SGSharpnessFromThreshold(in float amplitude, in float epsilon, in float cosTheta)\n{\n    return (log(epsilon) - log(amplitude)) / (cosTheta - 1.0f);\n}\n\nSG CosineLobeSG(in vec3 direction)\n{\n    SG cosineLobe;\n    cosineLobe.Axis = direction;\n    cosineLobe.Sharpness = 2.133f;\n    cosineLobe.Amplitude = vec3(1.17f);\n    return cosineLobe;\n}\n\nvec3 SGIrradianceInnerProduct(in SG lightingLobe, in vec3 normal)\n{\n    SG cosineLobe = CosineLobeSG(normal);\n    return max(SGInnerProduct(lightingLobe, cosineLobe), 0.0f);\n}\n\nvec3 SGIrradianceFitted(in SG lightingLobe, in vec3 normal)\n{\n    float muDotN = dot(lightingLobe.Axis, normal);\n    float lambda = lightingLobe.Sharpness;\n \n    float c0 = 0.36f;\n    float c1 = 1.0f / (4.0f * c0);\n \n    float eml = exp(-lambda);\n    float em2l = eml * eml;\n    float rl = 1.0 / lambda;\n \n    float scale = 1.0f + 2.0f * em2l - rl;\n    float bias  = (eml - em2l) * rl - em2l;\n \n    float x  = sqrt(1.0f - scale);\n    float x0 = c0 * muDotN;\n    float x1 = c1 * x;\n \n    float n = x0 + x1;\n \n    float y = clamp(muDotN, 0.0, 1.0);\n    \n    if(abs(x0) <= x1)\n        y = (n * n) / x;\n \n    float result = scale * y + bias; \n    return result * ApproximateSGIntegral(lightingLobe);\n}\n\nvec3 SGDiffuseInnerProduct(in SG lightingLobe, in vec3 normal, in vec3 albedo)\n{\n    vec3 brdf = albedo / 3.141592;\n    return SGIrradianceFitted(lightingLobe, normal) * brdf;\n}\n\nSG DistributionTermSG(in vec3 direction, in float roughness)\n{\n    SG distribution;\n    distribution.Axis = direction;\n    float m2 = roughness * roughness;\n    distribution.Sharpness = 2.0 / m2;\n    distribution.Amplitude = vec3(1.0f / (3.141592 * m2)); \n    return distribution;\n}\n\nSG WarpDistributionSG(in SG ndf, in vec3 view)\n{\n    SG warp; \n    warp.Axis = reflect(-view, ndf.Axis);\n    warp.Amplitude = ndf.Amplitude;\n    warp.Sharpness = ndf.Sharpness;\n    warp.Sharpness /= (4.0f * max(dot(ndf.Axis, view), 0.0001f)); \n    return warp;\n}\n\nfloat GGX_V1(in float m2, in float nDotX)\n{\n    return 1.0f / (nDotX + sqrt(m2 + (1.0 - m2) * nDotX * nDotX));\n}\n \nvec3 SpecularTermSGWarp(in SG light, in vec3 normal, in float roughness, in vec3 view, in vec3 specAlbedo)\n{\n    SG ndf = DistributionTermSG(normal, roughness);\n    SG warpedNDF = WarpDistributionSG(ndf, view);\n \n    vec3 result = SGInnerProduct(warpedNDF, light);\n \n    vec3 warpDir = warpedNDF.Axis;\n    float m2 = roughness * roughness;\n    \n    // I'm still not sure I understand this, it's obscuring a lot of the fresnel contribution :/\n    float nDotL = saturate(dot(normal, warpDir));\n    result *= nDotL;\n    \n    float nDotV = saturate(dot(normal, view));\n    vec3 h = normalize(warpedNDF.Axis + view);\n \n    result *= GGX_V1(m2, nDotL) * GGX_V1(m2, nDotV);\n    \n    float powTerm = pow((1.0f - saturate(dot(warpDir, h))), 5.0);\n    result *= specAlbedo + (1.0f - specAlbedo) * powTerm;\n    \n    return max(result, 0.0f);\n}\n\n// ---------------------------------------------------------\n\nSG GetLightSG(int seed)\n{\n    seed += 1;\n    vec3 r1 = hash3(uvec3(seed * 7, seed * 19, seed * 53));\n    vec3 r2 = hash3(uvec3(seed * 7 * 7, seed * 19 * 7, seed * 53 * 7));\n    \n    float t = iTime * .25;// min(iTime, DURATION + INTRO + 8.0) * .25;\n    \n    float theta = (r1.x * 3.1415 - 1.75);\n    theta = mix(theta + t * .35, theta + t * .15, smoothstep(DURATION, DURATION + INTRO + 4.0, iTime));\n    float heightCap = 1.4;\n    float height = mod((1.0 - r1.y * r1.y) * heightCap + t * .2, heightCap) - heightCap * .5;\n    vec3 p = vec3(cos(theta), height, sin(theta));\n    \n    float amp = smoothstep(0.0, .1, abs(abs(height) - heightCap * .5));\n    \n\tSG light;\n\tlight.Axis = normalize(p);\n    light.Sharpness = mix(50.0, 1000.0, r2.x * r2.z);\n    light.Amplitude = pow(vec3(2.0), vec3(2.2)) * amp * mix(.05, .3, r2.y * r2.y);\n    return light;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat sdf(vec3 p)\n{\n    float d = fBox(p - vec3(.0, .1, -1.75), vec3(.1, .65, .12));    \n    \n    // Frame\n    d = min(d, fBox(p - vec3(.0, .75, .15), vec3(.1, .1, 2.65)));\n    d = min(d, fBox(p - vec3(.0, -.75, .15), vec3(.1, .1, 2.65)));\n    \n    // H\n    d = min(d, fBox(p - vec3(.0, .0, -.75), vec3(.1, .55, .13)));\n    d = min(d, fBox(p - vec3(.0, .0, .55), vec3(.1, .55, .13)));\n    d = min(d, fBox(p - vec3(.0, .0, -.1), vec3(.1, .13, .65)));\n    \n    // X\n    vec3 x1 = p - vec3(.0, .0, 1.65);\n    vec3 x2 = p - vec3(.0, .0, 1.65);\n    float a = 0.72665;\n    pR(x1.yz, a);\n    pR(x2.yz, -a);\n    float dX = fBox(x1, vec3(.1, .12, 1.0));\n    dX = min(dX, fBox(x2, vec3(.1, .12, 1.0)));    \n    dX = max(dX, fBox(p - vec3(.0, .0, 1.75), vec3(.1, .55, 1.8)));    \n    d = min(d, dX);\n    \n    // Some bevel\n    d += min(length(p.x * p.x * 25.0), .045);\n    \n    return d;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf(p + eps.xzz) - sdf(p + eps.yzz);\n\tfloat dY = sdf(p + eps.zxz) - sdf(p + eps.zyz);\n\tfloat dZ = sdf(p + eps.zzx) - sdf(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nvec3 triplanar(vec3 P, vec3 N)\n{    \n    vec3 Nb = abs(N);\n    \n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\t\n    \n    vec3 c0 = texture(iChannel0, P.xy).rgb * Nb.z;\n    vec3 c1 = texture(iChannel0, P.yz).rgb * Nb.x;\n    vec3 c2 = texture(iChannel0, P.xz).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvec3 Render(Camera camera, Intersection isect, vec2 uv)\n{\n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    if(isect.totalDistance < MAX_DISTANCE)\n    {\n        vec3 normal = sdfNormal(p, EPSILON_NORMAL);        \n        vec3 result = vec3(0.0);\n\n        vec3 tx = triplanar(p, normal);\n        \n        float roughness = .03;\n        vec3 diffuse = pow(vec3(.25, .3, .4), vec3(2.2)) * .3;// vec3(.9) * tx; \n        vec3 specular = pow(vec3(1.0, 1.3, 1.65), vec3(2.2));\n        \n\t\tfor(int i = 0; i < LIGHT_COUNT; ++i)\n        {\n        \tSG lightSG = GetLightSG(i);\n            \n        \tresult += SGDiffuseInnerProduct(lightSG, normal, diffuse);    \n            result += SpecularTermSGWarp(lightSG, normal, roughness, -camera.direction, specular);\n        }\n        \n        return result;\n    }\n\n    return vec3(0.0);\n}\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf(p);\n\n\t\toutData.totalDistance += outData.sdf;\n                \n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    return outData;\n}\n\nvec3 filmic(vec3 x)\n{\n\treturn ((x*(0.15f*x + 0.10f*0.50f) + 0.20f*0.02f) / (x*(0.15f*x + 0.50f) + 0.20f*0.30f)) - 0.02f / 0.30f;\n}\n\nvec3 glow(vec2 uv, vec2 size)\n{\n    uv /= size;\n \tvec3 glowColor = vec3(.2, .4, .7);\n    vec3 fx = glowColor * pow(saturate(1.0 - length(uv * vec2(.75, .9))), 2.0);\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.5, 1.0))), 2.0);\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.25, 7.0))), 2.0) * .25;\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.1, 7.0))), 2.0) * .15;    \n    return fx * fx * fx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;    \n    \n    vec3 color = vec3(0.0);\n    \n    if(abs(uv.y) < .6)\n    {\n        Camera camera = GetCamera(uv, 0.35, 0.0,  1293);\n        Intersection isect = Raymarch(camera);\n        color = Render(camera, isect, uv);\n    }\n\n\tvec3 vignette = mix(vec3(1.0, .8, .96) * .1, vec3(1.3), (1.0 - smoothstep(.0, 2.1, length(uv))));\n    vignette *= vignette;\n    \n    vec3 colorIntro = mix(vec3(0.0), color, smoothstep(INTRO + 2.0, INTRO + 7.0, iTime));\n    color *= mix(colorIntro, vec3(1.0), smoothstep(INTRO + 2.0, INTRO + DURATION, iTime));\n    \n    float box = smoothstep(.015, .005, abs(fBox2(uv, vec2(1.5, .7))));\n    color += pow(vec3(.05, .3, .6), vec3(2.2)) * box * .3 * smoothstep(INTRO - 1.0, INTRO + 2.0, iTime);    \n    \n    float glowTime = iTime - (INTRO + DURATION);\n    vec3 totalGlow = vec3(0.0);\n    vec3 fineGlow = vec3(0.0);    \n    \n    fineGlow += glow(uv, vec2(.5, .1)) * .1;\n    fineGlow += glow(uv + vec2(glowTime * .05, .28), vec2(.9, .1)) * .06;\n    fineGlow += glow(uv + vec2(.3 - glowTime * .1, -.28), vec2(.5, .14)) * .02;\n    \n    totalGlow += glow(uv + vec2(.0 - glowTime * .05, .0), vec2(1.9, 1.5)) * .005;\n    totalGlow *= smoothstep(40.0, INTRO + DURATION + 4.0, iTime);\n    \n    totalGlow += fineGlow * smoothstep(20.0, INTRO + DURATION + 2.0, iTime);\n    totalGlow *= smoothstep(INTRO + DURATION - 5.0, INTRO + DURATION + 4.0, iTime);\n    \n    color += totalGlow;\n    \n    float exposure = 32.0 * smoothstep(30.0, 20.0, iTime);    \n\tvec3 whiteScale = 1.0f / filmic(vec3(6.2f));\n    color.rgb = filmic(color.rgb * exposure * vignette);    \n    color.rgb = clamp(color.rgb * whiteScale, vec3(0.0), vec3(1.0));\n    color = pow(color, vec3(.45454));\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DURATION 8.0\n#define INTRO 6.0\n\nconst uint k = 1103515245U;\n\n// iq\nfloat hash( uint x )\n{\n    x = ((x>>8U)^x)*k;\n    x = ((x>>8U)^x)*k;\n    x = ((x>>8U)^x)*k;\n    return float(x)*(1.0/float(0xffffffffU));\n}\n\n\n// -------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \nfloat hash1(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nfloat hash2D(vec2 x)\n{\n\tfloat i = dot(x, vec2(123.4031, 46.5244876));\n\treturn fract(sin(i * 7.13) * 268573.103291);\n}\n\nCamera GetCamera(vec2 uv, float zoom, float time, int seed)\n{\n    float dist = 2.65 / zoom;\n    \n    vec3 target = vec3(0.0, 0.0, 0.2);\n    vec3 p = vec3(0.0, 0., 0.2) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"// Harmonics taken from\n// https://stackoverflow.com/questions/10702942/note-synthesis-harmonics-violin-piano-guitar-bass-frequencies-midi\nconst float coeff[26] = float[26] (1.0, \n\t0.286699025, 0.150079537, 0.042909002, \n    0.203797365, 0.229228698, 0.156931925, \n    0.115470898, 0.0, 0.097401803, 0.087653465, \n    0.052331036, 0.052922462, 0.038850593, \n    0.053554676, 0.053697434, 0.022270261, \n    0.013072562, 0.008585879, 0.005771505,\n    0.004343925, 0.002141371, 0.005343231, \n    0.000530244, 0.004711017, 0.009014153);\n\nfloat instrBase(float t)\n{\n    float s = 0.0;\n    \n    for(int i = 0; i < 26; ++i)\n        s += sin(t * float(i) * 2.0 * 3.141592) * coeff[i];\n    \n    for(int i = 0; i < 3; ++i)\n        s += sin(t * float(i) * 2.0 * 3.141592) * coeff[i];\n    \n    return s;\n}\n\nfloat instrument(float time)\n{\n    float s = 0.0;    \n    s += instrBase(time);\n    s += instrBase(time * .5) * .33;\n    s += instrBase(time * 2.0) * .05;\n    return s;\n}\n\n// Derivation (or integration :P) based on smootherstep\nfloat smoothChirp(float t, float from, float to, float duration)\n{\n    t /= duration;\n    float a = from * duration;\n    float b = to * duration;\n    \n    // a x - (5 a x^4)/2 + (5 b x^4)/2 + 3 a x^5 - 3 b x^5 - a x^6 + b x^6\n    float phase = a * t;\n    phase -= 5.0 * a * pow(t, 4.0) * .5;\n    phase += 5.0 * b * pow(t, 4.0) * .5;\n    phase += 3.0 * a * pow(t, 5.0);\n    phase -= 3.0 * b * pow(t, 5.0);\n    phase -= a * pow(t, 6.0);\n    phase += b * pow(t, 6.0);\n    \n    float offset = (a + b) * .5 + .45;\n    float introFix = .375; // hack\n    \n    if(t > 1.0)\n        phase = b * t + offset;\n    else if(t < 0.0)\n        phase = a * t + introFix;\n\telse\n        phase += introFix;\n    \n    return instrument(phase);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    int voices = 30;    \n    vec2 accum = vec2(0.0);\n        \n\tfor(int i = 0; i < voices; ++i)\n    {\n        vec3 r = vec3(hash(uint(i * 7)), hash(uint(i * 31)), hash(uint(i * 17)));\n        float r1 = r.x;\n        float r2 =  r.y;\n        float from = 100.0 + r1 * 200.0;\n        float to = 587.0 - 2.6;\n        \n        int octave = int(r1 * 4.0) - 2;\n        float oct = pow(2.0, float(octave));\n        \n        if(r2 < .33)\n            to = 369.0;\n        else if(r2 < .66)\n            to = 440.0;\n        else\n            to += 5.0 * (r.z * 2.0 - 1.0);\n\n        to *= oct;\n        from += sin(time * .6 + 1.95) * 7.0 * smoothstep(INTRO, 0.0, time);\n\n        float signal = smoothChirp(time - INTRO, from, to, DURATION);\n        signal *= (1.0 - r1 * r1 * .5) * 2.0;\n        \n        float ampByFreq = smoothstep(INTRO, DURATION + INTRO, time);\n        signal *= 1.0 + mix(oct, 1.0 / oct, ampByFreq);        \n        \n        float offset = float(i) * .25;\n        float so = 2.15;\n        accum += signal * vec2(cos(time * so + offset) * .5 + .5, sin(time * so + offset) * .5 + .5);\n    }\n    \n    float bass = 0.0;\n    bass += instrument(293.0 * .125 * time) * .115;\n    bass += instrument(587.0 * .25 * time) * .05;\n    bass += instrument(587.0 * .125 * time) * .25;    \n    bass *= .5 * smoothstep(DURATION + INTRO - 3.0, DURATION + INTRO, time);\n    \n    accum /= float(voices);\n    accum *= mix(1.0, 1.3, smoothstep(INTRO+DURATION - 3.0, INTRO+DURATION + 2.0, time));\n    accum += vec2(bass);\n    \n    float gT = time - DURATION;\n    accum *= smoothstep(.0, INTRO + 2.0, time) * smoothstep(30.0, 15.0, time - 4.0);\n\n    return accum;\n}","name":"Sound","description":"","type":"sound"}]}