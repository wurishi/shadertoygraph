{"ver":"0.1","info":{"id":"MtBXR3","date":"1445301375","viewed":176,"name":"[CIS565 2015F] Ray Marching","username":"Pontusun","description":"This is a course project from University of Pennsylvania CIS565\nThe code for this Shader can be found at:\nhttps://github.com/CIS565-Fall-2015/Project5-GLSL-Ray-Marcher\n\nThis Shadertoy uses material from:\nMorgan McGuire, Williams College, IÃ±igo QuÃ­lez","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simpleraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float dSphere(vec3 X, vec3 C, float r){\n    return length(X-C)-r;\n}\n\nfloat dPlane(vec3 X){\n    return X.y;\n}\n\nfloat dBox(vec3 X, vec3 C, float b){\n    vec3 d = abs(X-C)-b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dTorus(vec3 X, vec3 C, float R, float r)\n{\n\treturn length(vec2(length(X.xz - C.xz) - r, X.y - C.y)) - R;\n}\n\nvec2 opUnion(vec2 r1, vec2 r2){\n    return r1.x < r2.x ? r1 : r2;\n}\n\n\nvec2 allDist(in vec3 X){\n    vec2 res;\n\tfloat sphereDist = dSphere(X, vec3(-1.0, 0.25, 0.0), 0.25);\n    float planeDist = dPlane(X);\n    res = opUnion(vec2(sphereDist, 1.0), vec2(planeDist, 2.0));\n    float boxDist = dBox(X, vec3(1.0, 0.25, 1.0), 0.25);\n    res = opUnion(res, vec2(boxDist, 3.0));\n    float torusDist = dTorus(X, vec3(-1.5, 0.5, -1.5), 0.15, 0.5);\n    res = opUnion(res, vec2(torusDist, 4.0));\n    return res;\n}\n\nvec2 naiveMarch( in vec3 ro, in vec3 rd ){\n\tfloat tmin = 1.0;\n    float tmax = 20.0;\n    float tstep = 0.01;\n    \n    float precis = 0.001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<1000; i++ )\n    {\n\t    vec2 res = allDist( ro+rd*t );\n        if( res.x<precis) break;\n        m = res.y;\n        t += tstep;   \n    }  \n    \n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\nvec2 sphereMarch( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tfloat precis = 0.001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = allDist( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n\t    m = res.y;\n        t += res.x;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 getNormal( in vec3 X )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 n = vec3(\n\t    allDist(X+eps.xyy).x - allDist(X-eps.xyy).x,\n\t    allDist(X+eps.yxy).x - allDist(X-eps.yxy).x,\n\t    allDist(X+eps.yyx).x - allDist(X-eps.yyx).x );\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.001;\n    float eps = 0.0001;\n    vec2 res;\n    float dist = 1.0;\n    float maxDist = 1.0;\n    float C = 8.0;\n    for (int i = 0; i < 30; i++){\n        res = allDist(ro+rd*t);\n        if (res.x < eps){\n            return 0.0;\n        }\n        if (res.x > maxDist)\n            break;\n        dist = min(dist, C*res.x/t);\n        t+= res.x;\n    }\n    return clamp(dist, 0.0, 1.0);\n}\n\n\nvec3 shade(vec3 ro, vec3 rd, vec2 res){\n\tvec3 color;\n    if(res.y == 1.0){\n    \tcolor = vec3(0.8,0.2,0.2);\n    } else if( res.y == 2.0){\n    \tcolor = vec3(0.3, 0.8, 0.3);\n    } else if( res.y == 3.0){\n    \tcolor = vec3(0.5, 0.5, 0.9);\n    } else if( res.y == 4.0){\n    \tcolor = vec3(0.9, 0.9, 0.3);\n    } \n    \n    //for lighting\n    vec3 light = normalize( vec3(-0.6, 0.7, -0.5) );\n    vec3 norm = getNormal(ro+rd*res.x);\n    float diffuse = clamp( dot( norm, light ), 0.0, 1.0 );\n    \n    float shad = shadow(ro+rd*res.x, light);\n    \n    //return color*diffuse;\n    return color*diffuse*shad;\n    //return clamp( dot( rd, (rd*res.x) )*vec3(0.05), 0.0, 1.0 );\n    //return norm;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 color = vec3(0.8, 0.9, 1.0);\n    vec2 res = sphereMarch(ro, rd);\n    //vec2 res = naiveMarch(ro, rd);\n    if(res.y > 0.0){\n    \tcolor = shade(ro, rd, res);\n    }\n    return vec3( clamp(color,0.0,1.0) );\n    //return rd;  // camera ray direction debug view\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}