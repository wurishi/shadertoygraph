{"ver":"0.1","info":{"id":"lXjfWw","date":"1729623494","viewed":114,"name":"BristorBrot HoloPrism","username":"dougfractal","description":"BristorBrot rendered for HoloPrism display   [ 0: BristorBrot ,  1:  BristorBrot_abs,  2: Mandelbulb ] and julia sets","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["fractalraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" //Shder by Doug Bristor https://www.shadertoy.com/user/dougfractal\n        /*--------------------------------------------------------------------------------------\n        License CC0 - http://creativecommons.org/publicdomain/zero/1.0/\n        To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n        ----------------------------------------------------------------------------------------\n        ^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n        - Doug Bristor\n        \n        BristorBrot_abs updated to use acos to control sign : \"sign = acos(r/ length(z.yz) )>0.0 ? sign :-sign;\"\n        \n        */\n        /*\n        uniform float iTime;\n        uniform vec2 iResolution;\n        uniform sampler2D textureSampler;\n        \n        varying vec3 vPosition;\n        varying vec2 vUV;\n        #define iChannel0 textureSampler\n        \n        */\n        \n#define Epsilon  .00077192  \n     // .000197192\n#define RenderDistance 6.450  \n#define MAX_STEP 100 \n\n#define PI_2 1.570796327 \n#define PI 3.1415926538\n\n\nint drawType = 0 ;  // [ 0: BristorBrot ,  1:  BristorBrot_abs,  2: Mandelbulb ]\n\nfloat drawJulia = .0 ;   // bool drawJulia = false ; using mix\n \nbool mouse = false; \n\nbool show2by2 = false;   // 2by2 layout instead of holoprism layout\n\nfloat Power = 2.0;  // for mandelbulb only\n\nvec3 CamPos = vec3(-.0, -.0, -7.0);\n\nvec3 CamRot = vec3(.0, 1., 0.0);\n\nfloat CamFocalLength = .8;    \n\n\n\nmat2 rotate(float a) {\n   float s = sin(a);\n   float c = cos(a);\n   return mat2(c, -s, s, c);        \n}\n\n\n\nvec2 normalizeUVx(vec2 uv, vec2 res){\n    uv.x*=res.x/res.y;\n    uv.x-=.5*res.x/res.y-.5;\n    return uv;\n}\n\n\n\nfloat BristorBrot(vec3 z, vec3 pos ) {\n  float r, dr=1.0;\n  int i=MAX_STEP;\n  while ((r = length(z)) < RenderDistance  &&  i-- > 0 ) { \n      z = vec3(  \n            z.x*z.x - z.y*z.y - z.z*z.z,\n            z.y*(2.0*z.x - z.z),\n            z.z*(2.0*z.x + z.y)\n            ) + pos;\n      dr = 2.0 * r * dr + 1.0;   \n  }\n  return 0.5*log(r)*r/dr;\n}\n \n \n    \n// Bristorbrot (abs) formula     \nfloat BristorBrot_abs(vec3 z, vec3 pos ) {\n  float r = length(z), dr=1.0, sign=-1.0;\n \n  int i=MAX_STEP;\n  while ((r = length(z))< RenderDistance  &&  i-- > 0 ) { \n    sign = acos(r/ length(z.yz) )>0.0?  sign :-sign;\n    \n    z = vec3(  \n            z.x*z.x - z.y*z.y - z.z*z.z,\n            z.y*(2.0*z.x - abs(z.z)*sign),    \n            z.z*(2.0*z.x + abs(z.y)*sign)\n            ) + pos;      \n    dr =2.0 * r * dr + 1.0;  \n    r = length(z);\n  }\n  return 0.5*log(r)*r/dr; \n}\n \n \nfloat Mandelbulb(vec3 z, vec3 pos ) { \n   float dr = 1.0, theta, phi, r = length(z);\n   int i=MAX_STEP;\n   while ((r = length(z)) < RenderDistance  &&  i-- > 0 ) {        \n        theta = acos(z.y/r);\n\t\tphi = atan(z.z,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;   \n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tz = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + pos;\n   }\n   return 0.5*log(r)*r/dr; \n}\n \n\n        \nfloat distanceEstimation(vec3 pos) {\n  float r = length(pos);\n  if(r > RenderDistance  ) return r - 1.15; \n\n  vec3 z = pos;\n  \n  // ignore if drawJulia == 0.\n  vec3 julia = vec3(-.833,.23432,.01);\n  julia.x -=cos(iTime*0.1)*.325;\n  julia.y = julia.x *.3;\n  pos = mix(pos , julia , drawJulia) ;\n  //if (drawJulia) {\n    \n  //  pos = julia;   \n  //}\n  if (drawType==0) \n      return  BristorBrot( z, pos ) ;\n  return drawType==1 ? BristorBrot_abs( z, pos ) : \n         Mandelbulb( z, pos );            \n}\n         \n        \n        \n        \nvec3 normalEstimation(vec3 pos){\n   \n  vec3 xDir = vec3(Epsilon, 0.0, 0.0);\n  vec3 yDir = vec3(0.0, Epsilon, 0.0);\n  vec3 zDir = vec3(0.0, 0.0, Epsilon);\n\n  float normalX = distanceEstimation(pos + xDir)\n                - distanceEstimation(pos - xDir);\n  float normalY = distanceEstimation(pos + yDir)\n                - distanceEstimation(pos - yDir);\n  float normalZ = distanceEstimation(pos + zDir)\n                - distanceEstimation(pos - zDir);\n\n  return normalize(vec3(normalX, normalY, normalZ));\n}\n\n\n\n\nbool hit(inout vec3 pos, in vec3 dir) { \n\n\n    for(int i = 0; i < MAX_STEP; i++){\n        float dist = distanceEstimation(pos);\n        if(dist < Epsilon ) break;\n        if(dist > RenderDistance) return false;\n        pos += dist*dir;\n    }\n    for(int i = 0; i < 4; i++){\n        float dist = distanceEstimation(pos)-Epsilon;\n        pos += dist*dir;\n    } \n    return true;\n}\n        \n\n   \nvec4 colorAndDepth(vec3 pos, vec3 dir){\n    vec4 c = vec4(0.0,0,0, 1.0);\n \n    if(hit(pos, dir)){\n        vec3 normal = normalEstimation(pos);\n        c.rgb = normal;\n    \n        vec3 light = vec3(0, -1, -2);\n        \n        // Calculate diffuse lighting by taking the dot product of \n        // the light direction (light-p) and the normal.\n        float dif = clamp(dot(normal, normalize(light - pos)), 0., 1.);\n\t\t\n        // Multiply by light intensity (5) and divide by the square\n        // of the distance to the light.\n        dif *= 5. / dot(light - pos, light - pos);\n        c.rgb = mix(vec3(pow(dif, 0.4545)) ,normal.rbg , .25 );     // Gamma correction\n    }\n    return c;\n}\n\n/*\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n*/\n\n\nvec2 setRotation(vec2 rota) {\n   float time = float(iFrame)*.001 * 3.1429 *2.   ;\n   //  rota.y += -time;\n   rota.x += time*.537;\n   if( iMouse.z > 0.0 )  {\n       //mouse = true;\n       rota.y +=  (iMouse.y/iResolution.y-.5)*3.1429;\n       rota.x +=  (iMouse.x/iResolution.x-.5)*3.1429;\n    }\n    return rota ; \n}\n\n\nbool setCamera(out vec3 ro,  out vec3 rd, in  vec2 rota , in vec3 location , in vec2 uv)   {\n   rd =vec3(uv, 1.);\n   ro = CamPos;\n\n   // Apply rotation matrices\n   rota = setRotation(rota);\n   mat2 maty = rotate(rota.y);\n   mat2 matx = rotate(rota.x);\n\n   ro.yz *= maty;  // Rotates the camera position around the Y axis (left-right)\n   ro.xz *= matx; // Rotates the camera position around the X axis (up-down)\n\n   rd.xy += location.xy;\n   rd.z = CamFocalLength;\n\n   rd.yz *= maty; \n   rd.xz *= matx; \n  \n   return true;\n}\n\n\n//  2x2 grid layour\nvoid mainImageFourCorners( out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    // Get the aspect ratio of the window (width/height)\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalize fragCoord to [0, 1] and then adjust for aspect ratio\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.xy ;\n    \n    // Squish the scene to fit in a square by adjusting the x-coordinate\n    uv.x *= aspectRatio; \n  \n\n    //vec2 uv =(fragCoord - 0.5 * iResolution.xy) / iResolution.xy;\n \n    // Initialize tex as black with full opacity\n    vec4 tex = vec4(0.0, 0.0, 0.0, 1.0);  \n\n    // Check which quadrant the pixel is in using step() and combine them\n    float isRight = step(0.0, uv.x);   // 1 for right side, 0 for left\n    float isTop =  step(0.0, uv.y);     // 1 for top, 0 for bottom\n\n    float quadrantFactor = isRight + 2.0 * isTop;  // This gives values: \n\n    // Map the quadrant factor to different grey levels (0 = dark, 2 = bright)\n    tex.rgb = vec3(0. + quadrantFactor * 0.03);  // Adjust grey scale level\n\n     // Define possible rotations and locations for each quadrant\n    vec2 rotaSouth = vec2(-PI_2, PI_2);\n    vec2 rotaNorth = vec2(-PI_2, -PI_2);\n    vec2 rotaEast = vec2(PI_2, 0.0);\n    vec2 rotaWest = vec2(0.0, -PI_2);\n\n    vec3 locationSouth = vec3(1., 1., 0.) * 0.25;\n    vec3 locationNorth = vec3(-1., 1., 0.) * 0.25;\n    vec3 locationEast = vec3(1., -1., 0.) * 0.25;\n    vec3 locationWest = vec3(-1., -1., 0.) * 0.25;\n\n    // Use `mix` to interpolate between the values for each quadrant\n    vec2 rota = mix(rotaSouth, rotaNorth, step(1.0, quadrantFactor));\n    rota = mix(rota, rotaEast, step(2.0, quadrantFactor));\n    rota = mix(rota, rotaWest, step(3.0, quadrantFactor));\n\n    vec3 location = mix(locationSouth, locationNorth, step(1.0, quadrantFactor));\n    location = mix(location, locationEast, step(2.0, quadrantFactor));\n    location = mix(location, locationWest, step(3.0, quadrantFactor));\n \n    vec3 ro = CamPos; \n    vec3 rd ;\n    \n    setCamera( ro, rd, rota, location, uv);   \n\n    tex.rgb += location;\n    tex += colorAndDepth(ro, rd);\n\n    fragColor = tex;\n}\n\n\n\n\n// HoloPrism Format\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n     \n    if (show2by2 == true) {\n        mainImageFourCorners(fragColor, fragCoord);\n        return;\n    }\n     \n     \n    // Initialize texture color\n    vec4 tex ;\n    // Normalize fragCoord to the range [0, 1] for UV coordinates\n  \n    // Get the aspect ratio of the window (width/height)\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalize fragCoord to [0, 1] and then adjust for aspect ratio\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.xy ;\n    \n    // Squish the scene to fit in a square by adjusting the x-coordinate\n    uv.x *= aspectRatio;\n    \n    //uv *=.9;\n  \n    // vec2 uv =(fragCoord - 0.5 * iResolution.xy) / iResolution.xy;\n    \n    vec2 rota;\n    vec3 location, ro, rd; \n\n\n    // North\n    location = vec3(0.0, -1.0, 0.0) * 0.25 ;\n    rota = vec2(PI_2, PI_2);\n   \n    setCamera(ro, rd, rota, location  , uv);\n    tex += colorAndDepth(ro, rd);\n    \n    // EAST\n    rota = vec2( PI, 0.);\n    location = vec3(-1.0, 0.0, 0.0) *.25;\n    \n    setCamera(ro, rd, rota, location, uv  );\n    tex += colorAndDepth(ro, rd);    \n        \n    // WEST\n    rota =  vec2(0. , 0. ); \n    location = vec3(1.0, 0.0, 0.0) *.25;\n    \n    setCamera(ro, rd, rota, location, uv  );\n    tex += colorAndDepth(ro, rd);    \n            \n    // SOUTH\n    location = vec3(.0, 1.0, 0.0) * 0.25;\n    rota = vec2(PI_2 , -PI_2);\n \n    setCamera(ro, rd, rota, location, uv  );\n    tex += colorAndDepth(ro, rd);\n   \n    // Output the final color\n    fragColor = tex;\n}\n\n\n        \n/*\nvoid main() \n{\n    mainImage(gl_FragColor, vUV * iResolution.xy);\n}\n*/","name":"Image","description":"","type":"image"}]}