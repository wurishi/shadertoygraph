{"ver":"0.1","info":{"id":"X3dSD4","date":"1719046522","viewed":34,"name":"Colors around a circle","username":"Hawzen","description":"I'm learning how to do grids. This shader assigns colors for a grid of squares based on its distance from the center","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["colors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Speed constant\nconst float GRID_SPACING = .01;\nconst float SPEED = 10.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * SPEED;\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    // Create a grid\n    vec3 grid = vec3(0.0);\n    float gridWidth = 0.01;\n    float gridHeight = 0.01;\n    \n    // Calculate the grid position, based on uv\n    vec2 currentGridPosition = floor(uv / GRID_SPACING) * GRID_SPACING ; // Consider making this hexagons instead\n\n    // Position the center of the grid\n    vec2 centerPosition = (iMouse.xy - iResolution.xy * 0.5) / iResolution.y - vec2(GRID_SPACING / 2.0);\n\n    // Vec from the center to the current grid position\n    vec2 centerToCurrentGridPosition = currentGridPosition - centerPosition;\n    float centerToCurrentGridPositionLength = length(centerToCurrentGridPosition);\n\n    // Colors\n    const int NUM_COLORS = 7;\n    vec3 baseColors[NUM_COLORS];\n    baseColors[0] = vec3(1.0, 0.0, 0.0);\n    baseColors[1] = vec3(0.0, 1.0, 0.0);\n    baseColors[2] = vec3(0.0, 0.0, 1.0);\n    baseColors[3] = vec3(1.0, 1.0, 0.0);\n    baseColors[4] = vec3(1.0, 0.0, 1.0);\n    baseColors[5] = vec3(0.0, 1.0, 1.0);\n    baseColors[6] = vec3(1.0, 1.0, 1.0);\n    \n    float baseColorIndex = mod(time / 100., 7.) + 0.95; // This ensures we start from color 0 til 6 and loop back\n    vec3 colors = baseColors[int(mod(centerToCurrentGridPositionLength * 1000. + time, baseColorIndex))];    \n\n    // Circle effects\n    float radius = smoothstep(1., .5, time / 500.); // The circle gets smaller over time\n    vec2 wobble = vec2(cos(centerToCurrentGridPosition.x * 10. + time / 2.), sin(centerToCurrentGridPosition.y * 10. + time / 2.)); // Wobble the circle\n    float opacity = smoothstep(0., 1., radius - length(centerToCurrentGridPosition + wobble * 0.01));\n    \n    fragColor = vec4(colors, radius); // For some reason Shadertoy refuses to process the alpha channel\n}","name":"Image","description":"","type":"image"}]}