{"ver":"0.1","info":{"id":"wtjcDc","date":"1595613750","viewed":110,"name":"incrementalGaussianFilter","username":"david376","description":"compared the normal gaussian algorithm  and  incremental gaussian algorithm , looks totally the same. based on this paper.\nhttps://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-40-incremental-computation-gaussian","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["gaussian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float pixelSizeY = 1./iResolution.y;\n\n    \n    vec4 acc = vec4 (0.0);\n    \n    vec2 direction = vec2(0.,1.);\n    \n    if (GaussianType == 0.)\n        acc = StdGaussian(iChannel0,AnimSigma,uv,direction,pixelSizeY);\n    \n    if (GaussianType == 1.)\n        acc = IncrementalGaussian(iChannel0,AnimSigma,uv,direction,pixelSizeY);\n    \n    \n    // Output to screen\n    //fragColor = texture(iChannel0,uv);\n    fragColor = acc;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float pixelSizeX = 1./iResolution.x;\n\n    \n    //acc = incrementalGaussian(radius,g0,g1,g2,uv,pixelSizeX);\n    \n    vec4 acc;\n    vec2 direction = vec2(1.,0.);\n    if (GaussianType == 0.)\n        acc = StdGaussian(iChannel0,AnimSigma,uv,direction,pixelSizeX);\n    \n    if (GaussianType == 1.)\n        acc = IncrementalGaussian(iChannel0,AnimSigma,uv,direction,pixelSizeX);\n    \n    \n    \n    // Output to screen\n    fragColor = acc;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define Sigma 10.\n#define AnimSigma (Sigma * (0.5 * sin(iTime) + 0.5) + 1.)\n\n//It will be StandardGaussian filter,when mouse on the left side of the screen\n//While IncrementalGaussian filter, when mouse on the right\n#define GaussianType \\\nceil(clamp(iMouse.x-iResolution.x/2.0,0.,1.))\n\nvec4 StdGaussian(sampler2D inTex ,float localSigma,vec2 uv,vec2 direction, float pixelSizeX)\n{\t\n    vec4 acc = texture(inTex,uv);\n    float sum = 1.;\n    float norm = 1./(sqrt(2.*3.14159)*localSigma);\n    \n \tfor (int i = 1 ; float(i) < localSigma *3.  ; i ++)\n    {\n        float kernal = exp(-0.5 * float(i) * float(i) / localSigma /localSigma);\n        \n        acc += texture(inTex,uv + direction * float(i) * pixelSizeX) * kernal;\n        acc += texture(inTex,uv - direction * float(i) * pixelSizeX) * kernal;\n        sum += 2. * kernal;\n    }\n \tacc /= sum;\n    return acc;\n}\n\nvec4 IncrementalGaussian(sampler2D inTex,float localSigma,vec2 uv, vec2 direction,float pixelSize)\n{\t\n    vec4 acc = texture(inTex,uv);\n    float g0 = exp(-0.5 * 1. * 1. / localSigma /localSigma);\n    float g1 = g0 *g0 * g0;\n    float g2 = g0 * g0;\n    float norm = 1./(sqrt(2.*3.14159)*localSigma);\n    float sum = 1.;\n \tfor (int i = 1 ; float(i) <= localSigma *3.0 ; i ++)\n    {\n        acc += texture(inTex,uv + direction * float(i) * pixelSize) * g0; \n        acc += texture(inTex,uv - direction * float(i) * pixelSize) * g0;\n        sum += 2.*g0;\n        g0 *= g1;\n        g1 *= g2;\n    }\n    acc /= sum;\n    return acc;    \n}\n\n","name":"Common","description":"","type":"common"}]}