{"ver":"0.1","info":{"id":"DllSRN","date":"1674407383","viewed":105,"name":"Fork Simple 2D Lights","username":"ianertson","description":"Forked from https://www.shadertoy.com/view/dlXXR4\n\nAdded some bump-maps and stuff","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["lights2d"],"hasliked":0,"parentid":"dlXXR4","parentname":"Simple 2D Lights"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_LIGHTS 3\n#define DARKNESS 1.1\n\n// how smooth the cracks / normals should be\n// 0 = very rough\n// 1 = not visible at all\n#define SMOOTHNESS 0.51\n\n#define M_PI 3.14159265359\n#define TAU (M_PI*2.0)\n\nstruct Light\n{\n    vec2 position;\n    vec3 color;\n    float radius;\n};\n\nLight uLights[MAX_LIGHTS];\n\n\n\nvec2 extractBump(sampler2D tex, vec2 uv) {\n    vec3 color = texture(tex, uv).rgb;\n    vec2 texelSize = 1.0 / vec2(textureSize(tex, 0));\n    vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec2 a = normalize(vec2(dy.r - dx.r, dx.g - dy.g));\n    vec2 aspect = 1.0 / vec2(textureSize(tex, 0));\n    vec3 px =  color;\n    vec2 value = vec2(0.0);\n    for (float i = 0.0; i < TAU; i += TAU / 16.0) {\n        vec2 dir = vec2(sin(i), cos(i));\n        vec3 next = texture(tex, uv + dir * aspect * 6.0).rgb;\n        value += dir * distance(px, next);\n    }\n    return normalize(mix(a, normalize(value), 0.5));\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n\nvec3 tonemap(vec3 col) {\n    vec3 x = col;\n    vec3 vio = vec3(0.607843, 0.149019, 0.713725);\n    float dotVio = clamp(dot(col, vio), 0.0, 1.0);\n    \n    x = clamp(\n        (x * (2.51 * x + 0.03)) /\n        (x * (2.23 * x + 1.0392) + 0.98),\n    0.0, 1.0);\n   \n    x = saturate(x, dotVio);\n    x = mix(x, pow(x, vec3(2.0)), 0.3491*pow(dotVio, 2.0));\n    x += luma(x)/6.28;\n    x = clamp(x+(x/6.28), 0.0, 1.0);\n    \n    return pow(x, vec3(0.5125));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    // Mouse Light\n    uLights[0].position = iMouse.xy;\n    uLights[0].color = vec3(9., 3., 0.);\n    uLights[0].radius = 3.;\n    \n    // Red Light\n    uLights[1].position = vec2(50.);\n    uLights[1].color = vec3(1., 0., 0.);\n    uLights[1].radius = 30.;\n    \n    // Green Light\n    uLights[2].position = vec2(iResolution.x-50.0, iResolution.y-50.0);\n    uLights[2].color = vec3(0., 1., 0.);\n    uLights[2].radius = 30. + 10. * sin(iTime * 2.);\n\n    // Add light colors together\n    vec4 lightsCol = vec4(0., 0., 0., 1.);\n    \n    vec2 normal = extractBump(iChannel0, uv).xy;\n    vec3 albedo = texture(iChannel0, uv).rgb;\n    vec3 reflectance = vec3(0.0);\n    \n    vec2 texel = 1.0 / vec2(textureSize(iChannel0, 0).xy);\n    vec2 rad = texel*6.0;\n    \n    vec3 indirect = (((mix(\n        textureGrad(iChannel0, uv, vec2(1.0, -1.0)*rad, vec2(1.0, -1.0)*rad).rgb,\n        textureGrad(iChannel0, uv, vec2(-1.0, 1.0)*rad, vec2(-1.0, 1.0)*rad).rgb,\n        0.5\n    ).rgb / M_PI) + (vec3(0.1) / M_PI)) * 0.9) * max(0.0, 1.0 - (DARKNESS*0.3));\n    \n    vec3 col = indirect;\n    \n    vec3 diffuse = albedo / M_PI;\n   \n    \n    for (int i = 0; i < uLights.length(); i++)\n    {\n        float dist = distance(uLights[i].position, fragCoord);\n        vec2 L = normalize(fragCoord - uLights[i].position);\n        normal = normalize(mix(normal, L, SMOOTHNESS));\n        float NdotL = max(0.0, dot(normal, L));\n        float attenuation = 16.0*NdotL*(pow(uLights[i].radius, 2.0) / max(0.001, pow(dist*DARKNESS, 2.0)));\n        \n        reflectance += diffuse * uLights[i].color * attenuation;\n    \n    }\n    \n    reflectance *= M_PI;\n    \n    col += reflectance;\n    col += luma(col) / M_PI;\n    col = tonemap(col);\n    col = mix(col, pow(col, vec3(2.0)), 0.8);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}