{"ver":"0.1","info":{"id":"7lyGzh","date":"1637330520","viewed":701,"name":"retrowave","username":"skaplun","description":"Alot of code snippets was taken all around from shadertoy. Credits to their authors.\nNeed bloom pass here.","likes":35,"published":1,"flags":0,"usePreview":1,"tags":["raymarch","80s","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MOD_POS(poz) poz.x += iTime * 4. + mod(floor(poz.z), 2.) * .35;\n//#define MOD_POS(poz) poz.x += mod(floor(poz.z), 2.) * .35;\n\nvec2 CityBlock(vec3 p, vec2 pint){\n    // Get random numbers for this block by hashing the city block variable\n    vec4 rand;\n    rand.xy = Hash22(pint);\n    rand.zw = Hash22(rand.xy);\n    vec2 rand2 = Hash22(rand.zw);\n\n    // Radius of the building\n    float baseRad = 0.2 + (rand.x) * 0.1;\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;   // try to snap this for window texture\n\n    // make position relative to the middle of the block\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\n    float height = .75 * rand.w*rand.z + 0.3; // height of first building block\n    // Make the city skyline higher in the middle of the city.\n    height *= 1.5+(baseRad-0.15)*20.0;\n    height += 0.1;  // minimum building height\n    //height += sin(iTime + pint.x);    // animate the building heights if you're feeling silly\n    height = floor(height*20.0)*0.05;   // height is in floor units - each floor is 0.05 high.\n    float d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\n\n    // road\n    d = min(d, p.y);\n\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);   // Hack to LOD in the distance\n\n    // height of second building section\n    float height2 = max(0.0, rand.y * 2.0 - 1.0);\n    height2 = floor(height2*20.0)*0.05; // floor units\n    rand2 = floor(rand2*20.0)*0.05; // floor units\n    // size pieces of building\n    d = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\n    d = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\n    // second building section\n    if (rand2.y > 0.25)\n    {\n        d = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\n        // subtract off piece from top so it looks like there's a wall around the roof.\n        float topWidth = baseRad;\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\n        d = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\n    }\n    else\n    {\n        // Cylinder top section of building\n        if (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\n    }\n    // mini elevator shaft boxes on top of building\n    d = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\n    float big = sign(boxPos.x);\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\n    d = min(d, sdBox(boxPos,\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\n\n    // Put domes on some building tops for variety\n    if (rand.y < 0.04)\n    {\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\n    }\n\n    return vec2(d, 0.0);\n}\n\nfloat city(vec3 p){\n    MOD_POS(p)\n    vec3 rep = p;\n    rep.xz = fract(p.xz);\n    return CityBlock(rep, floor(p.xz)).x;\n}\n\nvec3 estimateCityNormal(vec3 p) {\n    return normalize(vec3(\n        city(vec3(p.x + EPSILON, p.y, p.z)) - city(vec3(p.x - EPSILON, p.y, p.z)),\n        city(vec3(p.x, p.y + EPSILON, p.z)) - city(vec3(p.x, p.y - EPSILON, p.z)),\n        city(vec3(p.x, p.y, p.z  + EPSILON)) - city(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nconst float voxelPad = .2;\nfloat marchCity(vec3 eye, vec3 dir, float start, float end) {\n    float t = start;\n    vec3 pos = vec3(0.0);\n    for (int i = ZERO; i < 128; i++) {\n        pos = eye + dir * t;\n        float dist = city(pos);\n        if(abs(dist) < EPSILON){\n            return t;\n        }\n        \n        float walk = dist;\n        float dx = -fract(pos.x);\n        float dz = -fract(pos.z);\n        float nearestVoxel = min(fract(dx/dir.x), fract(dz/dir.z)) + voxelPad;\n        nearestVoxel = max(voxelPad, nearestVoxel);\n        walk = min(walk, nearestVoxel);\n\n\n        t += walk;\n        if ((t > end)) break;\n    }\n    return -1.;\n}\n\nvec3 cityColor(vec3 pos, vec3 view){\n    vec3 normal = estimateCityNormal(pos);\n    MOD_POS(pos);\n    float winid = Hash21(floor(pos.xy * vec2(2., 6.)));\n    float winStencil = step(winid, Hash21(floor(pos.xz)) * .75);\n    float win = step(distance(.125, abs(fract(pos.x) - .5)), .075)\n              * step(distance(fract(pos.y * 6.), .5), .4);\n    return hsv2rgb(vec3(.525 + (winid * .2 - .1), 1., 1.)) * winStencil * win * step(.000001, dot(normal, vec3(0., 0., 1.)))\n         + vec3(1.0, 1.0, 0.0) * abs(dot(normal, vec3(1., 0., 0.))) * abs(dot(view, normal)) * .2;\n}\n\nconst vec3 boat_center = vec3(0., -.3, -9.);\nvec2 boat(vec3 pos){\n    float scale = .65;\n    float ang = noised(vec2(iTime)).x * .2 - .05;\n    pos.xy *= mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    pos += boat_center + vec3(0., ang, 0.);\n    \n    vec2 res = vec2(0.);\n    \n    float c = length(pos + vec3(0., 7., 0.) * scale) - 7. * scale;\n    res.x = max(res.x, c);\n    float d = length(pos + vec3(-.75, 7., 0.) * scale) - 7. * scale;\n    res.x = max(res.x, d);\n    \n    {\n        float a = sdRoundBox(pos + vec3(.65, .35, 0.) * scale, vec3(.9, .25, .65 + pos.x * .2) * scale, .02 * scale);\n        res.x = min(res.x, a);\n    }\n    \n    {\n        float a = sdEllipsoid(pos + vec3(1.8, .38, 0.) * scale, vec3(3., .75, .86) * scale);\n        a = max(a, sdPlane(pos, normalize(vec3(-1., 1., 0.)), -.05 * scale));\n        a = max(a, sdPlane(pos, normalize(vec3(0., -1., 0.)), -0.1));\n        res = opMin(res, vec2(a, 1.));\n    }\n    \n    {\n        vec3 mpos = pos + vec3(0., .2 - pos.x * .1, 0.) * scale;\n        float a = sdEllipsoid(mpos + vec3(0., 0., .25) * scale, vec3(2., .5, 1.) * scale);\n        float b = sdEllipsoid(mpos - vec3(0., 0., .25) * scale, vec3(2., .5, 1.) * scale);\n        res.x = max(max(a, b), res.x);\n    }\n    \n    {\n        float a = sdRoundBox(pos + vec3(.3, 0.2, 0.) * scale, vec3(.9, .25 + pos.y * .1, .42 + pos.x * .2) * scale, .25 * scale);\n        float b = sdRoundBox(pos + vec3(.3, 0.2, 0.) * scale, vec3(.85, .24, .4 + pos.x * .2) * scale, .25 * scale);\n        float comb = max(a, -b);\n        comb = max(comb, sdPlane(pos, normalize(vec3(1., -.2, 0.)), .4 * scale));\n        comb = max(comb, -sdPlane(pos, normalize(vec3(1., -.8, 0.)), .6 * scale));\n        comb = max(comb, -pos.y - .2 * scale);\n        res.x = min(res.x, comb);\n    }\n\n    float e = sdPlane(pos, -normalize(vec3(-1., .5, 0.) * scale), 1.2 * scale);\n    res.x = max(res.x, -e);\n    \n    return res;\n}\n\nvec3 boatNormals(vec3 pos){\n    vec2 eps = vec2(0.0, EPSILON);\n    vec3 n = normalize(vec3(\n        boat(pos + eps.yxx).x - boat(pos - eps.yxx).x,\n        boat(pos + eps.xyx).x - boat(pos - eps.xyx).x,\n        boat(pos + eps.xxy).x - boat(pos - eps.xxy).x));\n    return n;\n}\n\nvec2 marchBoat(in Ray r){\n    float t = .01;\n    for(int i = ZERO; i <= 64; i++){\n        vec3 p = r.origin + r.dir * t;\n        vec2 dst = boat(p);\n        if(dst.x < .01)\n            return vec2(t, dst.y);\n        t += dst.x;\n    }\n    return vec2(-1.);\n}\n\nvec3 boatColor(vec3 p, float matid){\n    vec3 bn = boatNormals(p);\n    vec3 albedo = mix(vec3(1.), vec3(1., 0., 0.), step(abs(-.4 - dot(bn, vec3(0., 1., 0.))), .2));\n    \n    vec3 sunPos = vec3(0., 3., -5.);\n    vec3 sun = max(dot(bn, normalize(sunPos - p)), .15) * mix(vec3(1.0, 0.0, 1.0), vec3(1.0, 1.0, 0.0), .4);\n    \n    if(matid == 0.)\n        return albedo * sun + smoothstep(.15, 1., dot(bn, normalize(vec3(1., -1., 0.)))) * vec3(1.0, .0, 1.0) * (noised(p.xz * 3. + vec2(iTime * 4., 0.)).x * .5 + .5) * .25;\n    else if(matid == 1.)\n        return vec3(0.);\n    else\n        return vec3(0.);\n}\n\nvec3 geometry(Ray r){\n    vec3 color = vec3(0.);\n\n    \n    float start = (-r.origin.z)/r.dir.z;\n    float end = (-3.-r.origin.z)/r.dir.z;\n    float cityDist = -1.;\n    if(box_hit(Box(vec3(0., 2.25, -2.), vec3(10., 2.25, 2.)), r)){\n        cityDist = marchCity(r.origin, r.dir, start, end);\n    }\n    if (cityDist >= 0.) {\n        color = cityColor(r.origin + cityDist * r.dir, r.dir);\n    }else{\n        vec3 backPlane = r.origin + end * r.dir;\n        color = sunEffect(backPlane.xy * .125);\n    }\n    \n    if(box_hit(Box(vec3(0., .4, 9.), vec3(1.2, .35, .5)), r)){\n        vec2 boatDist = marchBoat(r);\n        vec3 boatPoint = r.origin + boatDist.x * r.dir;\n        if (boatDist.x >= 0. && boatPoint.y >= 0.) {\n            color = boatColor(boatPoint, boatDist.y);\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    time = iTime;\n    Ray originalRay = makeViewRay(fragCoord, iResolution.xy, iMouse.x/iResolution.x * 5.);\n    Ray r = originalRay;\n    \n    vec3 color = vec3(0.);\n    \n    float groundDst = (-r.origin.y)/r.dir.y;\n    vec3 groundPos = r.origin + groundDst * r.dir;\n    vec3 nor = vec3(0., 1., 0.);\n    if(groundPos.z > 0. && r.dir.y < 0.) {\n        vec3 nor;\n        {\n            vec2 uv = mod(groundPos.xz + vec2(iTime * 2., 0.), vec2(100.)) * vec2(5., 10.);\n    \n            const vec2 size = vec2(10., 0.);\n            const vec3 off = vec3(-20.,0, 50.);\n\n            float s11 = noised(uv).x + trail(groundPos.xz);\n            float s01 = noised(uv + off.xy).x + trail(groundPos.xz + vec2(.4, 0.));\n            float s21 = noised(uv + off.zy).x + trail(groundPos.xz + vec2(-.4, 0.));\n            float s10 = noised(uv + off.yx).x + trail(groundPos.xz + vec2(.0, .4));\n            float s12 = noised(uv + off.yz).x + trail(groundPos.xz + vec2(.0, -.4));\n            vec3 va = normalize(vec3(size.xy, s21-s01));\n            vec3 vb = normalize(vec3(size.yx, s12-s10));\n            vec4 bump = vec4( cross(va,vb), s11 );\n            nor =  bump.xzy;\n        }\n        \n        vec3 reflected = reflect(r.dir, nor);\n        r = Ray(groundPos, reflected);\n    }\n    color = geometry(r);\n    \n    if(box_hit(Box(vec3(0., .3, 9.), vec3(1.2, .3, .5)), originalRay)){\n        vec2 boatDist = marchBoat(originalRay);\n        if (boatDist.x >= 0. && boatDist.x < groundDst) {\n            vec3 boatPoint = originalRay.origin + boatDist.x * originalRay.dir;\n            color = boatColor(boatPoint, boatDist.y);\n        }\n    }\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ZERO min(iFrame, 0)\n#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n#define EPSILON 1e-3\n#define saturate(x) clamp(x, 0., 1.)\n#define UP vec3(0., 1., 0.)\nconst float PI = acos(-1.);\nfloat time = 0.;\n\nstruct Ray{ vec3 origin, dir; };\nstruct Sphere{vec3 origin; float rad;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nRay makeViewRay(vec2 coord, vec2 res, float a){\n    //vec3 lookAt = vec3(0., 0., 0.);\n    //vec3 origin = vec3(15. * cos(a), 1., 15. * sin(a));\n    \n    vec3 lookAt = vec3(0., 1.5 ,0.);\n    vec3 origin = vec3(0., 2., 18.);\n    vec3 viewDir = rayDirection(60., res, coord);\n    mat4 viewToWorld = viewMatrix(origin, lookAt, vec3(0., 1., 0.));\n    vec3 rd = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    return Ray(origin, rd);\n}\n\nstruct Box{ vec3 origin; vec3 size; };\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, const in Ray inray){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.origin + vec3(inbox.size);\n    vec3 minbounds = inbox.origin + vec3(-inbox.size);\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0.){\n    \treturn true;\n    }\n        \n    return false;\n}\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.dir, inray.dir);\n    float b = dot(oc, inray.dir);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        return true;\n        //return (-b - sqrt(discriminant))/a;\n    }\n    return false;\n}\n\nfloat Hash21(vec2 uv){\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\n\nvec2 Hash22(vec2 uv){\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nfloat sdBox(vec3 p, vec3 radius){\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// capped cylinder distance field\nfloat cylCap(vec3 p, float r, float lenRad){\n    float a = length(p.xy) - r;\n    a = max(a, abs(p.z) - lenRad);\n    return a;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sun(vec2 p) {\n  vec2 sp = p + vec2(0., .55);\n  float clr = length(sp) - 1.;\n  return clr * .5;\n}\n\nvec3 sunEffect(vec2 p) {\n  vec3 res = vec3(0.1);\n  vec3 skyCol1 = hsv2rgb(vec3(283.0/360.0, 0.83, 0.16));\n  vec3 skyCol2 = hsv2rgb(vec3(297.0/360.0, 0.79, 0.43));\n  res = mix(skyCol1, skyCol2, pow(clamp(0.5*(1.0+p.y+0.1*sin(4.0*p.x)), 0.0, 1.0), 4.0));\n  \n  p.y -= .375;\n  float ds = sun(p);\n  vec3 sunCol = mix(vec3(1.0, 0.0, 1.0), vec3(1.0, 1.0, 0.0), clamp(0.5 - .5 * p.y, 0.0, 1.0));\n  vec3 glareCol = sqrt(sunCol);\n  \n  res += glareCol*(exp(-30.0*ds))*step(0.0, ds);\n  res = mix(res, sunCol, smoothstep(-.01, 0., -ds));\n\n  return res;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h ) {\n    return dot(p,n) + h;\n}\n\nvec2 opMin(vec2 a, vec2 b){\n    if(a.x <= b.x) return a; else return b;\n}\n\n//by iq\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nfloat trail(vec2 uv){\n    return smoothstep(distance(uv.y, 9. + noised(uv + vec2(time)).x), .5 - uv.x * .5 - .5, - uv.x * .5 - .5);\n}\n\nvec3 sea(vec2 uv){\n    \n    uv *= vec2(1., 3.);\n    \n    const vec2 size = vec2(10., 0.);\n    const vec3 off = vec3(-20.,0, 50.);\n    \n    float s11 = noised(uv).x;\n    float s01 = noised(uv + off.xy).x;\n    float s21 = noised(uv + off.zy).x;\n    float s10 = noised(uv + off.yx).x;\n    float s12 = noised(uv + off.yz).x;\n    vec3 va = normalize(vec3(size.xy, s21-s01));\n    vec3 vb = normalize(vec3(size.yx, s12-s10));\n    vec4 bump = vec4( cross(va,vb), s11 );\n    return bump.xzy;\n}","name":"Common","description":"","type":"common"}]}