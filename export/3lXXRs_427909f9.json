{"ver":"0.1","info":{"id":"3lXXRs","date":"1563856710","viewed":131,"name":"RT With PBS and Refraction   ","username":"ealicesora","description":"Ray-tracing with PBS and Refraction","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pbsandrefraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// PROJECT ID:30\n//\n// GROUP NUMBER:14\n//\n// STUDENT NAME: GONGYUNING\n// NUS User ID.: t0918107\n//\n// STUDENT NAME: PAN JINLEI\n// NUS User ID.: t0918084\n//\n// STUDENT NAME: LIN YUEBEI\n// NUS User ID.: t0918685\n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n#define USE_MULIT_REFRACTION_INREFRACTION1\n#define USE_FRESENEL_AFTER_REFRACTION_TO_CONTROAL_REFLECTION1\n#define PI 3.1415926\n#define USE_PBR\n#define USE_SPECIAL_IBL\n#define Gamma_Space\n#define Motion_Blur1\n#define Mulit_Balls\n#define LightAtten 0.3\nint NUM_LIGHTS = 2;\nint NUM_MATERIALS = 3;\nint NUM_PLANES = 0;\nint NUM_SPHERES = 2;\nconst float refractattern =1.0;\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\nconst float refrac_fresenl_coeff = 10.0;\nconst float GlobalEnmapFactor = 0.1;\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 30.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\nfloat depthOFfocus;\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\nfloat EnvironmentMappingCoeff;\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS =10;\nconst int NUM_FRAC_ITERATIONS = 3;\n\nconst int MAX_LIGHTS =2;\nconst int MAX_PLANES = 4;\nconst int MAX_SPHERES = 25;\nconst int MAX_MATERIAL = 20;\n\nvec3 cam_pos ;\nvec3 cam_lookto;\nvec3 cam_up_vec;\nfloat time;\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\nfloat saturate(float t)\n{\nreturn clamp(t,0.0,1.0);\n}\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n\tfloat fuzz;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n\tfloat roughness;\n\tvec3 k_refract;\n\tbool isrefractable;\n\tfloat refractivity;\n\tfloat randomseed;\n\tbool useRoughnessMap;\n\tfloat RoughnessMapScale;\n};\n\nPlane_t Plane[MAX_PLANES];\nSphere_t Sphere[MAX_SPHERES];\nLight_t Light[MAX_LIGHTS];\nMaterial_t Material[MAX_MATERIAL];\n\n\nint level;\n\nbool intime(float start,float end)\n{\nif(time<=start)\nreturn false;\nif(time>=end)\nreturn false;\nreturn true;\n\n}\n\n\nvoid CreateFollowingBall(int no,float theta, float rotRadius,float radius,float startdelayfrom34,float speed,int materialNo)\n{\nSphere[no].radius = radius;\nSphere[no].materialID = materialNo ;\nfloat height=0.0;\nif(time -34.0<startdelayfrom34)\n{\nheight =-99.0;\nSphere[no].center = vec3( rotRadius*cos(theta/360.0*2.0*PI),height,rotRadius*sin(theta/360.0*2.0*PI) );\nreturn ;\n}\nelse\nheight = ((time -34.0-startdelayfrom34)*speed - radius*2.0);\nif(height >40.0);\nheight = mod(height,40.0) - radius*2.0;\nSphere[no].center = vec3( rotRadius*cos(theta/360.0*2.0*PI),height,rotRadius*sin(theta/360.0*2.0*PI) );\nNUM_SPHERES++;\nreturn ;\n}\nvoid ACT1()\n{\n  /*CameraState camCurr;\n\tCam_LoadState( camCurr, iChannel1, ivec2(0) );\n\tcam_pos = camCurr.vPos;\n\tcam_lookto =normalize(camCurr.vTarget-cam_pos);\n  \tcam_up_vec = normalize(camCurr.vUp);*/\n\n\n\tPlane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 1;\n\t   // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 30.0;\n    Plane[1].materialID = 3;\n\n\tMaterial[19].k_d = vec3(0.1,1.0,4.0)*0.1;\n\tMaterial[19].k_a = 0.2 * Material[18].k_d;\n\tMaterial[19].k_r = 1.0 * Material[18].k_d;\n\tMaterial[19].k_rg = 0.1 * Material[18].k_r;\n\tMaterial[19].roughness =1.0;\n\tMaterial[19].isrefractable =false;\n\n\tMaterial[18].k_d = vec3(0.1,1.0,1.0)*0.3;\n\tMaterial[18].k_a = 0.2 * Material[18].k_d;\n\tMaterial[18].k_r = 1.0 * Material[18].k_d;\n\tMaterial[18].k_rg = 0.1 * Material[18].k_r;\n\tMaterial[18].roughness =0.7;\n\tMaterial[18].isrefractable =false;\n\n\tMaterial[17].k_d = vec3(0.9,1.0,0.3)*0.03;\n\tMaterial[17].k_a = 0.2 * Material[17].k_d;\n\tMaterial[17].k_r = 1.0 * Material[17].k_d;\n\tMaterial[17].k_rg = 0.1 * Material[17].k_r;\n\tMaterial[17].roughness =0.4;\n\tMaterial[17].isrefractable =false;\n\n\n\tMaterial[16].k_d = vec3(0.5,1.0,2.0)*0.03;\n\tMaterial[16].k_a = 0.2 * Material[15].k_d;\n\tMaterial[16].k_r = 1.0 * Material[15].k_d;\n\tMaterial[16].k_rg = 0.1 * Material[15].k_r;\n\tMaterial[16].n = 64.0;\n\tMaterial[16].refractivity =0.50;\n\tMaterial[16].roughness =0.1;\n\tMaterial[16].isrefractable =false;\n\tMaterial[16].k_refract=  vec3(1.0,1.0,2.0)*0.4;\n\tMaterial[16].useRoughnessMap=false;\n\n\tMaterial[15].k_d = vec3(0.5,5.0,2.0)*0.03;\n\tMaterial[15].k_a = 0.2 * Material[15].k_d;\n\tMaterial[15].k_r = 1.0 * Material[15].k_d;\n\tMaterial[15].k_rg = 0.1 * Material[15].k_r;\n\tMaterial[15].n = 64.0;\n\tMaterial[15].refractivity =1.0;\n\tMaterial[15].roughness =0.1;\n\tMaterial[15].isrefractable =true;\n\tMaterial[15].k_refract=  vec3(1.0,1.0,2.0)*0.4;\n\tMaterial[15].useRoughnessMap=false;\n\n\tMaterial[14].k_d = vec3(0.5,1.0,2.0)*0.3;\n\tMaterial[14].k_a = 0.2 * Material[13].k_d;\n\tMaterial[14].k_r = 1.0 * Material[13].k_d;\n\tMaterial[14].k_rg = 0.1 * Material[13].k_r;\n\tMaterial[14].n = 64.0;\n\tMaterial[14].refractivity =0.50;\n\tMaterial[14].roughness =0.1;\n\tMaterial[14].isrefractable =true;\n\tMaterial[14].k_refract=  vec3(1.0,1.0,2.0)*0.04;\n\tMaterial[14].useRoughnessMap=false;\n\n\tMaterial[13].k_d = vec3(1.0,4.0,1.0)*0.2;\n\tMaterial[13].k_a = 0.2 * Material[13].k_d;\n\tMaterial[13].k_r = 1.0 * Material[13].k_d;\n\tMaterial[13].k_rg = 0.1 * Material[13].k_r;\n\tMaterial[13].n = 64.0;\n\tMaterial[13].refractivity =0.50;\n\tMaterial[13].roughness =0.1;\n\tMaterial[13].isrefractable =true;\n\tMaterial[13].k_refract=  vec3(1.0,1.0,2.0)*0.04;\n\tMaterial[13].useRoughnessMap=false;\n\n\tMaterial[12].k_d = vec3(1.0,1.0,1.0)*0.05;\n\tMaterial[12].k_a = 0.2 * Material[12].k_d;\n\tMaterial[12].k_r = 2.0 * Material[12].k_d;\n\tMaterial[12].k_rg = 0.1 * Material[12].k_r;\n\tMaterial[12].n = 64.0;\n\tMaterial[12].refractivity =0.30;\n\tMaterial[12].roughness =0.1;\n\tMaterial[12].isrefractable =true;\n\tMaterial[12].k_refract=  vec3(1.0,1.0,2.0)*0.4;\n\tMaterial[12].useRoughnessMap=false;\n\n\tMaterial[11].k_d = vec3( 0.5,0.4,0.2)*3.0;\n\tMaterial[11].k_a = 0.2 * Material[11].k_d;\n\tMaterial[11].k_r =vec3(0.3);\n\tMaterial[11].k_rg = 0.01 * Material[11].k_r;\n\tMaterial[11].n = 64.0;\n\tMaterial[11].refractivity =1.0;\n\tMaterial[11].roughness =0.2;\n\tMaterial[11].isrefractable =true;\n\tMaterial[11].k_refract= vec3(0.3,0.1,0.1)*1.0;\n\tMaterial[11].useRoughnessMap=false;\n\n\tMaterial[10].k_d = vec3( 1.0)*0.05;\n\tMaterial[10].k_a = 0.002 * Material[10].k_d;\n\tMaterial[10].k_r =1.0 * Material[10].k_d;\n\tMaterial[10].k_rg = 0.001 * Material[10].k_r;\n\tMaterial[10].n = 64.0;\n\tMaterial[10].refractivity =0.99;\n\tMaterial[10].roughness =0.3;\n\tMaterial[10].isrefractable =true;\n\tMaterial[10].k_refract= vec3(1.3,1.3,1.3)*0.6;\n\tMaterial[10].useRoughnessMap=false;\n\n\t\n\tMaterial[9].k_d = vec3(1.0,1.0,2.0)*0.05;\n\tMaterial[9].k_a = 0.2 * Material[6].k_d;\n\tMaterial[9].k_r = 2.0 * Material[6].k_d;\n\tMaterial[9].k_rg = 0.1 * Material[6].k_r;\n\tMaterial[9].n = 64.0;\n\tMaterial[9].refractivity =0.16;\n\tMaterial[9].roughness =0.1;\n\tMaterial[9].isrefractable =true;\n\tMaterial[9].k_refract=  vec3(1.0,1.0,2.0)*0.7;\n\tMaterial[9].useRoughnessMap=false;\n\n\n\tMaterial[8].k_d = vec3( 0.3,0.1,0.1)*3.0;\n\tMaterial[8].k_a = 0.2 * Material[8].k_d;\n\tMaterial[8].k_r =vec3(0.05);\n\tMaterial[8].k_rg = 0.01 * Material[8].k_r;\n\tMaterial[8].n = 64.0;\n\tMaterial[8].refractivity =1.0;\n\tMaterial[8].roughness =0.2;\n\tMaterial[8].isrefractable =true;\n\tMaterial[8].k_refract= vec3(0.3,0.1,0.1)*0.5;\n\tMaterial[8].useRoughnessMap=false;\n\n\n\tMaterial[7].k_d = vec3( 0.1)*0.5;\n\tMaterial[7].k_a = 0.002 * Material[7].k_d;\n\tMaterial[7].k_r =1.0 * Material[7].k_d;\n\tMaterial[7].k_rg = 0.001 * Material[7].k_r;\n\tMaterial[7].n = 64.0;\n\tMaterial[7].refractivity =0.98;\n\tMaterial[7].roughness =0.2;\n\tMaterial[7].isrefractable =true;\n\tMaterial[7].k_refract= vec3(1.3,1.3,1.3)*0.6;\n\tMaterial[7].useRoughnessMap=false;\n\n\tMaterial[6].k_d = vec3(0.05);\n\tMaterial[6].k_a = 0.2 * Material[6].k_d;\n\tMaterial[6].k_r = 2.0 * Material[6].k_d;\n\tMaterial[6].k_rg = 0.1 * Material[6].k_r;\n\tMaterial[6].n = 64.0;\n\tMaterial[6].refractivity =0.76;\n\tMaterial[6].roughness =0.1;\n\tMaterial[6].isrefractable =true;\n\tMaterial[6].k_refract= vec3(1.0);\n\tMaterial[6].useRoughnessMap=false;\n\n\tMaterial[5].k_d = vec3(0.1,0.1,0.1);\n\tMaterial[5].k_a = 0.2 * Material[5].k_d;\n\tMaterial[5].k_r = 4.0 * Material[5].k_d;\n\tMaterial[5].k_rg = 0.2 * Material[5].k_r;\n\tMaterial[5].n = 64.0;\n\tMaterial[5].refractivity =1.0;\n\tMaterial[5].roughness =0.1;\n\tMaterial[5].isrefractable =true;\n\tMaterial[5].k_refract= vec3(0.7);\n\tMaterial[5].useRoughnessMap=false;\n\n\tMaterial[4].k_d = vec3( 0.01);\n\tMaterial[4].k_a = 0.2 * Material[4].k_d;\n\tMaterial[4].k_r = 1.0 * Material[4].k_d;\n\tMaterial[4].k_rg = 0.2 * Material[4].k_r;\n\tMaterial[4].n = 64.0;\n\tMaterial[4].roughness =1.0;\n\tMaterial[4].refractivity =1.0;\n\tMaterial[4].isrefractable =true;\n\tMaterial[4].k_refract= vec3(0.8);\n\tMaterial[4].useRoughnessMap=false;\n\n\tMaterial[3].k_d = vec3( 0.2);\n\tMaterial[3].k_a = 0.2 * Material[3].k_d;\n\tMaterial[3].k_r = 1.0 * Material[3].k_d;\n\tMaterial[3].k_rg = 0.3 * Material[3].k_r;\n\tMaterial[3].n = 64.0;\n\tMaterial[3].refractivity =1.0;\n\tMaterial[3].isrefractable =false;\n\tMaterial[3].k_refract= vec3( 0.5, 0.5, 0.5 );\n\tMaterial[3].roughness =1.0;\n\tMaterial[3].randomseed=99.0;\n\tMaterial[3].useRoughnessMap=false;\n\tMaterial[3].RoughnessMapScale=0.01;\n\n\n\tMaterial[2].k_d = vec3( 0.2,0.4,0.8 )*0.25;\n\tMaterial[2].k_a = 0.2 * Material[2].k_d;\n\tMaterial[2].k_r = 2.0 * Material[2].k_d;\n\tMaterial[2].k_rg = 0.01 * Material[2].k_r;\n\tMaterial[2].n = 64.0;\n\tMaterial[2].refractivity =1.0;\n\tMaterial[2].isrefractable =false;\n\tMaterial[2].k_refract= vec3( 0.5, 0.5, 0.5 );\n\tMaterial[2].roughness =0.4;\n\tMaterial[2].randomseed=99.0;\n\tMaterial[2].useRoughnessMap=false;\n\tMaterial[2].RoughnessMapScale=0.1;\n\n\tMaterial[1].k_d = vec3( 0.2,0.2,0.3 );\n\tMaterial[1].k_a = 0.2 * Material[1].k_d;\n\tMaterial[1].k_r = 5.0 * Material[1].k_d;\n\tMaterial[1].k_rg = 0.02 * Material[1].k_r;\n\tMaterial[1].n = 64.0;\n\tMaterial[1].refractivity =1.0;\n\tMaterial[1].isrefractable =false;\n\tMaterial[1].k_refract= vec3( 0.5, 0.5, 0.5 );\n\tMaterial[1].roughness =0.1;\n\tMaterial[1].randomseed=99.0;\n\tMaterial[1].useRoughnessMap=false;\n\tMaterial[1].RoughnessMapScale=0.01;\n\n\tMaterial[0].k_d = vec3( 0.2 );\n\tMaterial[0].k_a = 0.2 * Material[0].k_d;\n\tMaterial[0].k_r = 5.0 * Material[0].k_d;\n\tMaterial[0].k_rg = 0.5 * Material[0].k_r;\n\tMaterial[0].n = 64.0;\n\tMaterial[0].refractivity =1.0;\n\tMaterial[0].isrefractable =false;\n\tMaterial[0].k_refract= vec3( 0.5, 0.5, 0.5 );\n\tMaterial[0].roughness =0.3;\n\tMaterial[0].randomseed=9.0;\n\tMaterial[0].useRoughnessMap=false;\n\tMaterial[0].RoughnessMapScale=0.1;\n\n\t\n\tLight[0].position = vec3(3.0,3.0,-3.0);\n\tLight[0].I_a = vec3( 0.1, 0.1, 0.1 );\n\tLight[0].I_source = vec3( 0.3 );\n\n\tNUM_LIGHTS = 1;\n\tNUM_PLANES = 1;\n\tNUM_SPHERES = 2;\n\n\tfloat rotateRadius=4.5;\n\tcam_pos = vec3(0.0,3.0,-rotateRadius);\n\tcam_lookto = vec3(0.0,1.0,0.0) - cam_pos;\n\tcam_up_vec = vec3(0.0,1.0,0.0);\n\tSphere[1].radius = 0.7;\n\tSphere[1].materialID = 2 ;\n\tSphere[0].radius = 0.7;\n\tSphere[0].materialID = 0 ;\n\tif(intime(-1.0,3.0))\n\t{\n\t\tEnvironmentMappingCoeff =0.1;\t\n\t\tdepthOFfocus = mix( 8.0,0.0,time/3.0);\n\t\tSphere[0].center = vec3( 0.0,0.8, 0.5 );\n\t\tSphere[1].center = vec3( 0.0,10.0 -time, -0.0 );\n        return ;\n\n\t}\n\tdepthOFfocus = 0.0;\n\tif(intime(3.0,5.0))\n\t{\n\t\tEnvironmentMappingCoeff =mix( 0.1,0.5,(time-3.0)/2.0);\t\n\t\tSphere[0].center = vec3( 0.0,0.8, mix( 0.5,0.0,(time-3.0)/2.0) );\n\t\tLight[0].position = vec3(mix( 3.0,-3.0,(time-3.0)/2.0),3.0,-3.0);\n\t\tSphere[1].center = vec3( 0.0,10.0 -time, -0.5 );\n\t\t  return ;\n\t}\n\t\n\tcam_pos = vec3(sin( (time-5.0)*-0.3)*rotateRadius ,3.0,-1.0*rotateRadius * cos(-0.3*(time-5.0)) );\n\tcam_lookto = vec3(0.0,1.0,0.0) - cam_pos;\n\tEnvironmentMappingCoeff =0.5;\n\n\tLight[0].position = vec3(-3.0,3.0,-3.0);\n\tif(intime(5.0,6.0))\n\t{\n\t\tSphere[1].center = vec3( 0.0,10.0 -time,  0.0 );\n\t\tSphere[0].center = vec3( 0.0,0.8,  0.0 );\n\t\treturn ;\n\t}\n\t\n\tNUM_SPHERES = 2;\n\t\n\tif(intime(6.0,7.0))\n\t{\n\n\n\t\tSphere[0].center = vec3( 0.0,0.8,  0.0 );\n\n\t\tSphere[1].center = vec3( 0.0,4.0 - 0.8 * (time-6.0)*(time-6.0), 0.0 );\n\n\t\treturn;\n\t}\n\n\tif(intime(7.0,8.0))\n\t{\n\n\t\tSphere[0].center = vec3( mix(0.0,2.0,time-7.0),0.8,  0.0 );\n\n\t\tSphere[1].center = vec3( 0.0,4.0 - 0.8 * (time-6.0)*(time-6.0),  0.0 );\n\t\t\n\n\t\treturn;\n\t}\n\n\t\tif(intime(8.0,9.0))\n\t{\n\n\n\t\tSphere[0].center = vec3(2.0,0.8, 0.0 );\n\n\t\tSphere[1].center = vec3( 0.0,0.8,  0.0 );\n\t\n\n\t\treturn;\n\t}\n\n\tif(intime(9.0,10.0))\n\t{\n\n\t\tSphere[0].center = vec3(mix(2.0,1.0,time-9.0),0.8,0.0 );\n\n\t\tSphere[1].center = vec3( mix(0.0,-1.0,time-9.0),0.8, 0.0 );\n\n\t\treturn;\n\t}\n\tSphere[0].center = vec3(1.0,0.8, 0.0 );\n\tSphere[1].center = vec3( -1.0,0.8,  0.0);\n\t\tif(intime(10.0,15.0))\n\t{\n\t\t\n\t\treturn;\n\t}\n\n\t\tif(intime(15.0,16.0))\n\t{\n\n\t\treturn;\n\t}\n\n\tif(intime(16.0,17.0))\n\t{\n\n\t\treturn;\n\t\n\t}\n\tdepthOFfocus = 0.0;\n\n\n\tif(intime(17.0,21.0))\n\t{\n\t\tMaterial[2].k_d = mix(vec3( 0.2,0.4,0.8 ),vec3( 0.8,0.4,0.2 ),(time-17.0)/4.0);\n\t\tMaterial[2].k_a = 0.2 * Material[2].k_d;\n\t\tMaterial[2].k_r = mix(2.0,0.5,(time-17.0)/4.0) * Material[2].k_d;\n\t\tMaterial[2].k_rg = mix(0.01,0.1,(time-17.0)/4.0) * Material[2].k_r;\n\t\tMaterial[2].n = 64.0;\n\t\tMaterial[2].roughness =mix(0.4,0.0,(time-17.0)/4.0);\n\t\t\n\n\n\n\t\treturn;\n\t\n\t}\n\t\tMaterial[2].k_d =vec3( 0.8,0.4,0.2 );\n\t\tMaterial[2].k_a = 0.2 * Material[2].k_d;\n\t\tMaterial[2].k_r = 0.5 * Material[2].k_d;\n\t\tMaterial[2].k_rg = 0.1 * Material[2].k_r;\n\t\tMaterial[2].roughness =0.0;\n\n\tif(intime(21.0,25.0))\n\t{\n\t\tMaterial[0].k_d = mix(vec3( 0.2 ),vec3( 0.8,0.2,0.2 ),(time-21.0)/4.0);\n\t\tMaterial[0].k_a = 0.2 * Material[0].k_d;\n\t\tMaterial[0].k_r =  mix(5.0,0.3 ,(time-21.0)/4.0) * Material[0].k_d;\n\t\tMaterial[0].k_rg = mix(0.5,0.1,(time-21.0)/4.0) * Material[0].k_r;\n\t\tMaterial[0].roughness =mix(0.3,0.7,(time-21.0)/4.0);\n\t\treturn;\n\t}\n\t\tMaterial[0].k_d = vec3( 0.8,0.2,0.2 );\n\t\tMaterial[0].k_a = 0.2 * Material[0].k_d;\n\t\tMaterial[0].k_r = 0.3 * Material[0].k_d;\n\t\tMaterial[0].k_rg = 0.1 * Material[0].k_r;\n\t\tMaterial[0].roughness =0.7;\n\n\tNUM_SPHERES=12;\n\tif(intime(25.0,29.0))\n\t{\n\t\tNUM_PLANES = 1;\n\t\trotateRadius=mix(rotateRadius,10.0,(time-25.0)/4.0);\n\t\tcam_pos = vec3(sin( (time-5.0)*-0.3)*rotateRadius ,mix(3.0,2.0,(time-25.0)/4.0),-1.0*rotateRadius * cos(-0.3*(time-5.0)) );\n\t\tcam_lookto = vec3(0.0,mix(1.0,2.0,(time-25.0)/4.0),0.0) - cam_pos;\n\t\t\n\t\tSphere[2].radius = 1.0;\n\t\tSphere[2].materialID = 4 ;\n\t\tSphere[2].center = vec3( 0.0,-2.8+(time-25.0),3.0 );\n\n\t\tSphere[3].radius = 1.0;\n\t\tSphere[3].materialID = 5 ;\n\t\tSphere[3].center = vec3( 0.0,-2.8+(time-25.0),-3.0 );\n\t\tEnvironmentMappingCoeff =mix( 0.5,0.15,(time-25.0)/4.0);\n\t\treturn;\n\t\n\t}\n\tEnvironmentMappingCoeff = 0.15;\n\tNUM_PLANES = 1;\n\trotateRadius=10.0;\n\tcam_pos = vec3(sin( (time-5.0)*-0.3)*rotateRadius ,2.0,-1.0*rotateRadius * cos(-0.3*(time-5.0)) );\n\tcam_lookto = vec3(0.0,2.0,0.0) - cam_pos;\n\tSphere[2].radius =1.0;\n\tSphere[2].materialID = 4 ;\n\tSphere[2].center = vec3( 0.0,1.2,3.0 );\n\n\tSphere[3].radius = 1.0;\n\tSphere[3].materialID = 5 ;\n\tSphere[3].center = vec3( 0.0,1.2,-3.0 );\n\t\tSphere[4].radius = 1.0;\n\tSphere[4].materialID = 6 ;\n\tSphere[4].center = vec3( 11.0*cos(0.3),3.6,11.0*sin(0.3) );\n\tSphere[5].radius = 1.0;\n\tSphere[5].materialID = 7 ;\n\tSphere[5].center = vec3( -10.0*cos(0.3),4.2,-10.0*sin(0.3) );\n\tSphere[6].radius = 1.0;\n\tSphere[6].materialID = 8 ;\n\tSphere[6].center = vec3( -11.0*sin(0.3),3.6,-11.0*cos(0.3) );\n\tSphere[7].radius = 1.0;\n\tSphere[7].materialID = 12 ;\n\tSphere[7].center = vec3( 11.0*sin(0.3),3.6,11.0*cos(0.3) );\n\n\tSphere[8].radius = 1.0;\n\tSphere[8].materialID = 6 ;\n\tSphere[8].center = vec3( 11.0,3.6,0.0 );\n\tSphere[9].radius = 1.0;\n\tSphere[9].materialID = 10 ;\n\tSphere[9].center = vec3( -10.0,4.2,0.0 );\n\tSphere[10].radius = 1.0;\n\tSphere[10].materialID = 11 ;\n\tSphere[10].center = vec3( 0.0,3.6,-11.0 );\n\tSphere[11].radius = 1.0;\n\tSphere[11].materialID = 9 ;\n\tSphere[11].center = vec3( 0.0,3.6,11.0);\n\n\n\tif(intime(25.0,30.0))\n\t{\n\t\t\n\t\treturn;\n\t\n\t}\n\n\tif(intime(30.0,34.0))\n\t{\n\t\tNUM_LIGHTS=1;\n\t\tLight[0].position = vec3(mix( -3.0,0.0,(time-30.0)/4.0),\n\t\tmix( 3.0,5.0,(time-30.0)/4.0),\n\t\tmix( -3.0,0.0,(time-30.0)/4.0));\n\t\tLight[0].I_a = vec3( 0.1, 0.1, 0.1 )*mix( 1.0,7.0,(time-30.0)/4.0);\n\t\tLight[0].I_source = vec3( 0.3 )*mix( 1.0,2.0,(time-30.0)/4.0);;\n\t\trotateRadius=mix(rotateRadius,15.0,(time-30.0)/4.0);\n\t\tcam_pos = vec3(sin( (time-30.0)*-0.1-7.5)*rotateRadius ,mix(2.0,4.0,(time-30.0)/4.0),-1.0 *cos( (time-30.0)*-0.1-7.5 )*rotateRadius );\n\t\tcam_lookto = vec3(0.0,mix(2.0,3.0,(time-30.0)/4.0),0.0) - cam_pos;\n\t\treturn;\n\t\n\t}\n\tNUM_LIGHTS=1;\n\tLight[0].position=vec3(0,5,0);\n\tLight[0].I_a = vec3( 0.7);\n\tLight[0].I_source = vec3( 0.6);;\n\trotateRadius=15.0;\n\t\n\tcam_pos = vec3(sin( (time-30.0)*-0.1-7.5)*rotateRadius ,4.0,-1.0 *cos( (time-30.0)*-0.1-7.5 )*rotateRadius );\n\tcam_lookto = vec3(0.0,3.0,0.0) - cam_pos;\n\n\n\tSphere[2].center = vec3( 0.0,3.2-2.0*cos(1.3*(time-34.0)),3.0 );\n\tSphere[3].center = vec3( 0.0,3.2-2.0*cos(2.5*(time-34.0)),-3.0 );\n\tSphere[0].center = vec3(1.0,1.8-1.0*cos(3.0*(time-34.0)), 0.0 );\n\tSphere[1].center = vec3( -1.0,1.8-1.0*cos(2.0*(time-34.0)),  0.0);\n\tMaterial[4].refractivity =1.0-abs(sin(0.3*(time-34.0)))*0.3;\n\tNUM_SPHERES=12;\n\n\t#ifdef Mulit_Balls\n\tCreateFollowingBall(12, 60.0, 22.0,  2.0, 6.0, 1.0, 16);\n\tCreateFollowingBall(13, 160.0, 42.0, 7.0, 4.0, 2.0, 13);\n\tCreateFollowingBall(14, 180.0, 25.0, 2.0, 12.0, 3.0, 15);\n\tCreateFollowingBall(15, 270.0, 25.0, 1.0, 12.0, 5.0, 14);\n\tCreateFollowingBall(16, 24.0, 30.0, 5.0, 4.0, 6.0, 17);\n\tCreateFollowingBall(17, 290.0, 30.0, 2.0, 4.0, 6.0, 19);\n\tCreateFollowingBall(18, 250.0, 40.0, 4.0, 4.0, 6.0, 12);\n\tCreateFollowingBall(19, 200.0, 23.0, 4.0, 4.0, 6.0, 4);\n\tCreateFollowingBall(20, 130.0, 27.0, 2.0, 4.0, 6.0, 11);\n\tCreateFollowingBall(21, 30.0, 27.0, 2.0, 4.0, 6.0, 8);\n\tCreateFollowingBall(22, 0.0, 30.0, 2.0, 4.0, 6.0, 10);\n\tCreateFollowingBall(23, 330.0, 30.0, 2.0, 4.0, 6.0, 9);\n\tCreateFollowingBall(24, 310.0, 40.0, 4.0, 4.0, 6.0, 7);\n\t#endif\n\t\n\n\n}\nvoid gomi()\n{\n // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n\n}\n\n\nvoid InitScene()\n{\n   ACT1();\n}\nvec3 refractionatten(vec3 col,float dis)\n{\n\nfloat coeff= dis+1.0;\n//return col/(1.0+0.05/coeff);\nreturn col;\n}\n\n\n\n\nvec3 EnviromentColor(vec3 dir)\n{\nreturn texture(iChannel0,dir).xyz*EnvironmentMappingCoeff;\n}\n\nvec3 DisneyDiffuseColor(vec3 V,vec3 N,vec3 L,Material_t mat)\n{\n\tfloat roughness=0.0;\n\tif(mat.useRoughnessMap)\n\troughness =mat.RoughnessMapScale * texture(iChannel3,vec2(V.x*mat.randomseed+N.x,V.y*mat.randomseed-N.z)).x*texture(iChannel3,vec2(N.z*mat.randomseed+N.x,V.z*mat.randomseed-N.z)).x+mat.roughness;\n\telse\n\troughness = mat.roughness;\n\tvec3 H = normalize( (V+L)/2.0);\n\tfloat fd90 = 0.5+2.0*roughness*pow(dot(H,L),2.0);\n\treturn \t mat.k_d/PI *( 1.0 + (fd90-1.0) *  pow( (1.0-dot(N,L)),5.0)) *( 1.0 + (fd90-1.0) *  pow( (1.0-dot(N,V)),5.0)) ;\n\n}\n\nfloat SmithJointGGXVisibilityTerm(float NdotL,float NdotV,float roughness)\n{\n float a2 = roughness * roughness;  \n float lambdaV = NdotL * (NdotV * (1.0 - a2) + a2); \n float lambdaL = NdotV * (NdotL * (1.0 - a2) + a2); \n return 0.5 / (lambdaV + lambdaL + 0.00001); \n}\n\nfloat GGXTerm(float NdotH, float roughness)\n{  \nfloat a2 = roughness * roughness; \nfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0; \nreturn PI * a2 / (d * d + 0.0001); \n} \n\nvec3 FresnelTerm(vec3 c, float cosA) \n{  \nfloat t = pow(1.0 - cosA, 5.0);  \nreturn c + (1.0 - c) * t; \n}  \n\nvec3 SpecularBPR(vec3 V,vec3 N,vec3 L,Material_t mat)\n{\n\tfloat roughness=0.0;\n\tif(mat.useRoughnessMap)\n\troughness =mat.RoughnessMapScale * texture(iChannel3,vec2(V.x*mat.randomseed+N.x,V.y*mat.randomseed-N.z)).x*texture(iChannel3,vec2(N.z*mat.randomseed+N.x,V.z*mat.randomseed-N.z)).x+mat.roughness;\n\telse\n\troughness = mat.roughness;\n\tfloat nl = clamp(dot(N,L),0.0,1.0);\n\tfloat nv = clamp(dot(N,V),0.0,1.0);\n\tvec3 H = normalize( (V+L)/2.0);\n\tfloat lh = clamp(dot(L,H),0.0,1.0);\n\tfloat nh = clamp(dot(N,H),0.0,1.0);\n\tfloat Vis = SmithJointGGXVisibilityTerm(nl, nv, roughness); \n\tfloat NDF = GGXTerm(nh, roughness * roughness);\n\tvec3 Fre = FresnelTerm(mat.k_r, lh); \n\treturn Fre * Vis * NDF; \n\t\n}\n\nvec3 FresnelLerp(vec3 c0, vec3 c1, float cosA) \n{  \nfloat t = pow(1.0 - cosA, 5.0); \nreturn mix (c0, c1, t); \n} \n\nvec3 IBLFactor(vec3 V,vec3 N,vec3 dir,Material_t mat)\n{\n\tfloat roughness=0.0;\n\tif(mat.useRoughnessMap)\nroughness =mat.RoughnessMapScale * texture(iChannel3,vec2(V.x*mat.randomseed+N.x,V.y*mat.randomseed-N.z)).x*texture(iChannel3,vec2(N.z*mat.randomseed+N.x,V.z*mat.randomseed-N.z)).x+mat.roughness;\n\telse\n\troughness = mat.roughness;\n\tfloat nv = clamp(dot(N,V),0.0,1.0);\n\tfloat perceptualRoughness = mat.roughness * (1.7 - 0.7 * roughness); \n\tfloat mip = perceptualRoughness * 6.0 *GlobalEnmapFactor; \n\tvec4 envMap = texture(iChannel0,dir,mip); \n\tfloat oneMinusReflectivity = 1.0 - max(max(mat.k_r.r, mat.k_r.g), mat.k_r.b); \n\tfloat grazingTerm = saturate((1.0 - roughness) + (1.0 - oneMinusReflectivity)); \n\tfloat surfaceReduction = 1.0 / (roughness * roughness + 1.0);\n\tvec3 indirectSpecular = surfaceReduction * envMap.rgb * FresnelLerp(mat.k_r, vec3(grazingTerm), nv); \n\n\nreturn indirectSpecular;\n}\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\nfloat fresnel(vec3 V , vec3 N, float n12)\n{\n\nfloat f90 = pow(1.0-n12,2.0)/pow(1.0+n12,2.0);\n\nreturn f90+(1.0-f90)*pow(1.0-dot(V,N),5.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\tfloat a = dot(ray.d,ray.d);\n\tfloat b = 2.0 * dot(ray.d,ray.o-sph.center);\n\tfloat c = dot(ray.o-sph.center,ray.o-sph.center) - sph.radius*sph.radius;\n\tfloat delta = b * b - 4.0 * a * c;\n\tif(delta < 0.0)\n    return false;  // Replace this with your code.\n\tdelta = sqrt(delta);\n\tfloat big = (-b + delta)/(2.0*a);\n\tfloat small = (-b - delta)/(2.0*a);\n\tif(big < 0.0)\n\treturn false;\n\tfloat answer=0.0;\n\tif(small < 0.0)\n\tanswer = big;\n\telse\n\tanswer = small;\n\tif(answer<tmin || answer > tmax)\n\treturn false;\n\tt = answer;\n\thitPos = ray.o + ray.d * t;\n\thitNormal = normalize(hitPos - sph.center);\n\treturn true;\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n\tfloat a = dot(ray.d,ray.d);\n\tfloat b = 2.0 * dot(ray.d,ray.o-sph.center);\n\tfloat c = dot(ray.o-sph.center,ray.o-sph.center) - sph.radius*sph.radius;\n\tfloat delta = b * b - 4.0 * a * c;\n\tif(delta < 0.0)\n    return false;  // Replace this with your code.\n\tdelta = sqrt(delta);\n\tfloat big = (-b + delta)/(2.0*a);\n\tfloat small = (-b - delta)/(2.0*a);\n\tif(big < 0.0)\n\treturn false;\n\tfloat answer=0.0;\n\tif(small < 0.0)\n\tanswer = big;\n\telse\n\tanswer = small;\n\tif(answer<tmin || answer > tmax)\n\treturn false;\n\treturn true;\n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 Lighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n\t#ifdef USE_PBR\n\t if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n\tfloat nl = saturate(dot(N,L));\n     vec3 specularterm = SpecularBPR(V,N,L,mat);\n\t vec3 diffuseterm = DisneyDiffuseColor( V,N,L,mat);\n\t vec3 col =   light.I_a * mat.k_a +PI * (diffuseterm + specularterm) * light.I_source * nl  ; \n\t return col;\n    }\n\n\t#else\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n\t#endif\n}\n\nvoid CalculateInteractions(Ray_t ray,out float temp_t,out vec3 temp_hitPos,out vec3 temp_hitNormal, out bool temp_hasHit,out int nearest_hitMatID)\n{\n\ttemp_t = DEFAULT_TMAX;\n\ttemp_hasHit = false;\n\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t{\n\t\tif(IntersectPlane(Plane[i],ray , DEFAULT_TMIN,temp_t,temp_t,temp_hitPos,temp_hitNormal))\n\t\t{\n\t\ttemp_hasHit = true;\n\t\tnearest_hitMatID = Plane[i].materialID;\n\t\t}\n\t}\n\n\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t{\n\t\tif(IntersectSphere(Sphere[i],ray ,DEFAULT_TMIN,temp_t,temp_t,temp_hitPos,temp_hitNormal))\n\t\t{\n\t\ttemp_hasHit = true;\n\t\tnearest_hitMatID = Sphere[i].materialID;\n\t\t}\n\t}\n\n\n}\n\n\nvec3 CalculateRefraction3(in vec3 Pos,in vec3 L, in vec3 N, in vec3 V, \n                    in Material_t mat, in Light_t light )\n{\n\n\t\tRay_t refractRay;\n\t\trefractRay.o = Pos;\n\t\trefractRay.d = refract(-V,N,mat.refractivity);\n\t\t\tif(length(refractRay.d)>0.01)\n\t\t\t\t{\t\t\t\n\t\t\t\t\trefractRay.d = normalize(refractRay.d);\n\t\t\t\t\trefractRay.o += refractRay.d*0.01; \n\t\t\t\t\tfloat temp_t;\n\t\t\t\t\tvec3 temp_hitPos;\n\t\t\t\t\tvec3 temp_hitNormal;\n\t\t\t\t\tbool temp_hasHit;\n\t\t\t\t\tbool hasHitSomething = false;\n\t\t\t\t\tfloat nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n\t\t\t\t\tvec3 nearest_hitPos;              // 3D position of the nearest hit point.\n\t\t\t\t\tvec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n\t\t\t\t\tint nearest_hitMatID;\n\t\t\t\t\tCalculateInteractions(refractRay,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);//lock for the out point\n\t\t\t\t\thasHitSomething = temp_hasHit;\n\t\t\t\t\tvec3 refractOutDir =normalize( refract(normalize(temp_hitPos-Pos),-temp_hitNormal,1.0/mat.refractivity));\n\t\t\t\t\t\tif(length(refractOutDir)>0.01)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tRay_t RefractPoint2lightRay;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\t\t\t\t\t\tnearest_t = temp_t;\n\t\t\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\t\t\tRefractPoint2lightRay.o = nearest_hitPos;\n\t\t\t\t\t\tbool inShadow_t=false;\n\t\t\t\t\t\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\t\t\t\t\t\tRefractPoint2lightRay.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(IntersectPlane(Plane[i],RefractPoint2lightRay , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinShadow_t = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!inShadow_t)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectSphere(Sphere[i],RefractPoint2lightRay , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow_t = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t\t\t\tI_local+=Lighting(normalize(Light[i].position-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treflect(-refractOutDir,nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow_t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tMaterial[nearest_hitMatID],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLight[i])/(1.0+sqrt(length(nearest_hitPos-Light[i].position))*LightAtten);\n\t\t\t\t\t\t\t\tinShadow_t=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tRay_t OutRay;\n\t\t\t\t\t\tOutRay.d = normalize(refractOutDir);\n\t\t\t\t\t\tOutRay.o = temp_hitPos+OutRay.d*0.01;\n\t\t\t\t\t\tfloat refractionlength = length(Pos -temp_hitPos);\n\t\t\t\t\t\tCalculateInteractions(OutRay,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);\n\t\t\t\t\t\tif ( !temp_hasHit ) return I_local+EnviromentColor(OutRay.d);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tnearest_t = temp_t;\n\t\t\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\t\t\tnearest_hitNormal = temp_hitNormal;\n   \n\t\t\t\t\n\t\t\n\t\t\t\t\t\tbool inShadow=false;\n\t\t\t\t\t\tRay_t lightray;\n\t\t\t\t\t\tlightray.o = nearest_hitPos;\n\t\t\t\t\t\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\t\t\t\t\t\tlightray.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(IntersectPlane(Plane[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\t\tif(!inShadow)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectSphere(Sphere[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tI_local+=Lighting(normalize(Light[i].position-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(OutRay.o-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tMaterial[nearest_hitMatID],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLight[i])/(1.0+sqrt(length(nearest_hitPos-Light[i].position))*LightAtten);\n\t\t\t\t\t\t\t\tinShadow=false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\n\n\t\t\t\t\t\t\tRay_t scTrace;\n\t\t\t\t\t\t\tscTrace.d=refractOutDir;\n\t\t\t\t\t\t\tvec3 coeffrg=mat.k_rg;\n\n\t\t\t\t\t\t\tfor( int i=0; i<= NUM_FRAC_ITERATIONS;i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tscTrace.o = nearest_hitPos;\n\t\t\t\t\t\t\t\tscTrace.d = reflect(scTrace.d ,temp_hitNormal);\n\t\t\t\t\t\t\t\tCalculateInteractions(scTrace,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);\n\t\t\t\t\t\t\t\tif(!temp_hasHit)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t#ifdef USE_SPECIAL_IBL\n\t\t\t\t\t\t\t\t\t\tI_local +=  IBLFactor(reflect(-scTrace.d ,temp_hitNormal),temp_hitNormal,scTrace.d,Material[nearest_hitMatID])*coeffrg;\n\t\t\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tI_local +=  EnviromentColor(scTrace.d)*coeffrg;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnearest_t = temp_t;\n\t\t\t\t\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\t\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\n\t\t\t\t\t\t\t\tvec3 I_local_temp = vec3( 0.0 ); \n\t\t\n\t\t\t\t\t\t\t\tbool inShadow=false;\n\t\t\t\t\t\t\t\tRay_t lightray;\n\t\t\t\t\t\t\t\tlightray.o = nearest_hitPos;\n\t\t\t\t\t\t\t\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\t\t\t\t\t\t\t\t\tlightray.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectPlane(Plane[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\t\t\t\tif(!inShadow)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectSphere(Sphere[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tI_local_temp+=Lighting(normalize(Light[i].position-nearest_hitPos),\tnormalize(nearest_hitNormal),normalize(scTrace.o-nearest_hitPos),\tinShadow,\tMaterial[nearest_hitMatID],Light[i])/(1.0+sqrt(length(nearest_hitPos-Light[i].position))*LightAtten);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tinShadow=false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#ifdef USE_FRESENEL_AFTER_REFRACTION_TO_CONTROAL_REFLECTION\n\t\t\t\t\t\t\t\tif(Material[nearest_hitMatID].isrefractable)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcoeffrg*=fresnel(-scTrace.d  ,normalize(nearest_hitNormal), Material[nearest_hitMatID].refractivity)*refrac_fresenl_coeff;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\tI_local += I_local_temp*coeffrg;\n\t\t\t\t\t\t\t\tI_local_temp=vec3(0);\n\t\t\t\t\t\t\t\tcoeffrg = Material[nearest_hitMatID].k_rg*coeffrg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\treturn refractionatten(I_local,refractionlength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\treturn vec3(0,0,0);\t\n\t\t\t}\n}\n\n\n\n\n\n\n\nvec3 CalculateFinalColor3(in vec3 Pos,in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n\n\t\t\tif(mat.isrefractable)\n\t\t\t{\n\t\t\t\tfloat fre=fresnel(V,N,mat.refractivity);\n\t\t\t\tvec3 refractcolor=CalculateRefraction3(Pos, L,  N, V,  mat,  light )*mat.k_refract;\n\t\t\t\tvec3 reflectColor= Lighting(L,N,V,inShadow,mat,light);\n\t\t\t\treturn (1.0-fre)*refractcolor+reflectColor;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\treturn Lighting(L,N,V,inShadow,mat,light)/(1.0+sqrt(length(Pos-Light[0].position))*LightAtten);\n\t\t\n\t\t\t}\n\t\n}\n\n\n\n\nvec3 CalculateRefraction2(in vec3 Pos,in vec3 L, in vec3 N, in vec3 V, \n                    in Material_t mat, in Light_t light )\n{\n\t\tRay_t refractRay;\n\t\trefractRay.o = Pos;\n\t\trefractRay.d = refract(-V,N,mat.refractivity);\n\t\t\tif(length(refractRay.d)>0.01)\n\t\t\t\t{\t\t\t\n\t\t\t\t\trefractRay.d = normalize(refractRay.d);\n\t\t\t\t\trefractRay.o += refractRay.d*0.01; \n\t\t\t\t\tfloat temp_t;\n\t\t\t\t\tvec3 temp_hitPos;\n\t\t\t\t\tvec3 temp_hitNormal;\n\t\t\t\t\tbool temp_hasHit;\n\t\t\t\t\tbool hasHitSomething = false;\n\t\t\t\t\tfloat nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n\t\t\t\t\tvec3 nearest_hitPos;              // 3D position of the nearest hit point.\n\t\t\t\t\tvec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n\t\t\t\t\tint nearest_hitMatID;\n\t\t\t\t\tCalculateInteractions(refractRay,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);//lock for the out point\n\t\t\t\t\thasHitSomething = temp_hasHit;\n\t\t\t\t\tvec3 refractOutDir =normalize( refract(normalize(temp_hitPos-Pos),-temp_hitNormal,1.0/mat.refractivity));\n\t\t\t\t\t\tif(length(refractOutDir)>0.01)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tRay_t RefractPoint2lightRay;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\t\t\t\t\t\tnearest_t = temp_t;\n\t\t\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\t\t\tRefractPoint2lightRay.o = nearest_hitPos;\n\t\t\t\t\t\tbool inShadow_t=false;\n\t\t\t\t\t\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\t\t\t\t\t\tRefractPoint2lightRay.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(IntersectPlane(Plane[i],RefractPoint2lightRay , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinShadow_t = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!inShadow_t)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectSphere(Sphere[i],RefractPoint2lightRay , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow_t = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t\t\t\tI_local+=Lighting(normalize(Light[i].position-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treflect(-refractOutDir,nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow_t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tMaterial[nearest_hitMatID],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLight[i])/(1.0+sqrt(length(nearest_hitPos-Light[i].position))*LightAtten);\n\t\t\t\t\t\t\t\tinShadow_t=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tRay_t OutRay;\n\t\t\t\t\t\tOutRay.d = normalize(refractOutDir);\n\t\t\t\t\t\tOutRay.o = temp_hitPos+OutRay.d*0.01;\n\t\t\t\t\t\tfloat refractionlength = length(Pos -temp_hitPos);\n\t\t\t\t\t\tCalculateInteractions(OutRay,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);\n\t\t\t\t\t\tif ( !temp_hasHit ) return I_local+EnviromentColor(OutRay.d);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tnearest_t = temp_t;\n\t\t\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\t\t\tnearest_hitNormal = temp_hitNormal;\n   \n\t\t\t\t\n\t\t\n\t\t\t\t\t\tbool inShadow=false;\n\t\t\t\t\t\tRay_t lightray;\n\t\t\t\t\t\tlightray.o = nearest_hitPos;\n\t\t\t\t\t\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\t\t\t\t\t\tlightray.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(IntersectPlane(Plane[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\t\tif(!inShadow)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectSphere(Sphere[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tI_local+=CalculateFinalColor3(nearest_hitPos,normalize(Light[i].position-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(OutRay.o-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tMaterial[nearest_hitMatID],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLight[i]);\n\t\t\t\t\t\t\t\tinShadow=false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\n\n\t\t\t\t\t\t\tRay_t scTrace;\n\t\t\t\t\t\t\tscTrace.d=refractOutDir;\n\t\t\t\t\t\t\tvec3 coeffrg=mat.k_rg;\n\n\t\t\t\t\t\t\tfor( int i=0; i<= NUM_FRAC_ITERATIONS;i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tscTrace.o = nearest_hitPos;\n\t\t\t\t\t\t\t\tscTrace.d = reflect(scTrace.d ,temp_hitNormal);\n\t\t\t\t\t\t\t\tCalculateInteractions(scTrace,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);\n\t\t\t\t\t\t\t\tif(!temp_hasHit)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t#ifdef USE_SPECIAL_IBL\n\t\t\t\t\t\t\t\t\t\tI_local +=  IBLFactor(reflect(-scTrace.d ,temp_hitNormal),temp_hitNormal,scTrace.d,Material[nearest_hitMatID])*coeffrg;\n\t\t\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tI_local +=  EnviromentColor(scTrace.d)*coeffrg;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnearest_t = temp_t;\n\t\t\t\t\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\t\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\n\t\t\t\t\t\t\t\tvec3 I_local_temp = vec3( 0.0 ); \n\t\t\n\t\t\t\t\t\t\t\tbool inShadow=false;\n\t\t\t\t\t\t\t\tRay_t lightray;\n\t\t\t\t\t\t\t\tlightray.o = nearest_hitPos;\n\t\t\t\t\t\t\t\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\t\t\t\t\t\t\t\t\tlightray.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectPlane(Plane[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\t\t\t\tif(!inShadow)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectSphere(Sphere[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#ifndef USE_MULIT_REFRACTION_INREFRACTION\n\t\t\t\t\t\t\t\t\t\tI_local_temp+=Lighting(normalize(Light[i].position-nearest_hitPos),\tnormalize(nearest_hitNormal),normalize(scTrace.o-nearest_hitPos),\tinShadow,\tMaterial[nearest_hitMatID],Light[i]);\n\t\t\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tI_local_temp+=CalculateFinalColor2(nearest_hitPos,normalize(Light[i].position-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(scTrace.o-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMaterial[nearest_hitMatID],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLight[i]);\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\tinShadow=false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#ifdef USE_FRESENEL_AFTER_REFRACTION_TO_CONTROAL_REFLECTION\n\t\t\t\t\t\t\t\tif(Material[nearest_hitMatID].isrefractable)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcoeffrg*=fresnel(-scTrace.d  ,normalize(nearest_hitNormal), Material[nearest_hitMatID].refractivity)*refrac_fresenl_coeff;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\tI_local += I_local_temp*coeffrg;\n\t\t\t\t\t\t\t\tI_local_temp=vec3(0);\n\t\t\t\t\t\t\t\tcoeffrg = Material[nearest_hitMatID].k_rg*coeffrg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\treturn refractionatten(I_local,refractionlength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\treturn vec3(0,0,0);\t\n\t\t\t}\n}\nvec3 CalculateFinalColor2(in vec3 Pos,in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n\n\t\t\tif(mat.isrefractable)\n\t\t\t{\n\t\t\t\tvec3 refractcolor=CalculateRefraction2(Pos, L,  N, V,  mat,  light )*mat.k_refract;\n\t\t\t\tvec3 reflectColor= Lighting(L,N,V,inShadow,mat,light);\n\t\t\t\treturn refractcolor+reflectColor;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\treturn Lighting(L,N,V,inShadow,mat,light)/(1.0+sqrt(length(Pos-Light[0].position))*LightAtten);\n\t\t\n\t\t\t}\n\t\n}\n\n\n\n\nvec3 CalculateRefraction(in vec3 Pos,in vec3 L, in vec3 N, in vec3 V, \n                    in Material_t mat, in Light_t light,out float reflectfresnelcoeff )\n{\n\t\tRay_t refractRay;\n\t\trefractRay.o = Pos;\n\t\trefractRay.d = refract(-V,N,mat.refractivity);\n\t\t\tif(length(refractRay.d)>0.01)\n\t\t\t\t{\t\t\t\n\t\t\t\t\trefractRay.d = normalize(refractRay.d);\n\t\t\t\t\trefractRay.o += refractRay.d*0.01; \n\t\t\t\t\tfloat temp_t;\n\t\t\t\t\tvec3 temp_hitPos;\n\t\t\t\t\tvec3 temp_hitNormal;\n\t\t\t\t\tbool temp_hasHit;\n\t\t\t\t\tbool hasHitSomething = false;\n\t\t\t\t\tfloat nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n\t\t\t\t\tvec3 nearest_hitPos;              // 3D position of the nearest hit point.\n\t\t\t\t\tvec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n\t\t\t\t\tint nearest_hitMatID;\n\t\t\t\t\tCalculateInteractions(refractRay,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);//lock for the out point\n\t\t\t\t\thasHitSomething = temp_hasHit;\n\t\t\t\t\tvec3 refractOutDir =normalize( refract(normalize(temp_hitPos-Pos),-temp_hitNormal,1.0/mat.refractivity));\n\t\t\t\t\tif(length(refractOutDir)>0.01)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tRay_t RefractPoint2lightRay;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\t\t\t\t\t\tnearest_t = temp_t;\n\t\t\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\t\t\tRefractPoint2lightRay.o = nearest_hitPos;\n\t\t\t\t\t\tbool inShadow_t=false;\n\t\t\t\t\t\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\t\t\t\t\t\tRefractPoint2lightRay.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(IntersectPlane(Plane[i],RefractPoint2lightRay , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinShadow_t = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!inShadow_t)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectSphere(Sphere[i],RefractPoint2lightRay , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow_t = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\tif(dot(normalize(Light[i].position-nearest_hitPos),refractOutDir)>0.9)\t\t\t\t\n\t\t\t\t\t\t\t\tI_local+=Lighting(normalize(Light[i].position-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treflect(-refractOutDir,nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow_t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tMaterial[nearest_hitMatID],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLight[i])/(1.0+sqrt(length(nearest_hitPos-Light[i].position))*LightAtten);\n\t\t\t\t\t\t\t\tinShadow_t=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\treflectfresnelcoeff=1.0-fresnel(refractOutDir,nearest_hitNormal,Material[nearest_hitMatID].refractivity);\n\t\t\t\t\t\tRay_t OutRay;\n\t\t\t\t\t\tOutRay.d = normalize(refractOutDir);\n\t\t\t\t\t\tOutRay.o = temp_hitPos+OutRay.d*0.01;\n\t\t\t\t\t\tfloat refractionlength = length(Pos -temp_hitPos);\n\t\t\t\t\t\tCalculateInteractions(OutRay,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);\n\t\t\t\t\t\tif ( !temp_hasHit ) return I_local+EnviromentColor(OutRay.d);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tnearest_t = temp_t;\n\t\t\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\t\t\tnearest_hitNormal = temp_hitNormal;\n   \n\t\t\t\t\n\t\t\n\t\t\t\t\t\tbool inShadow=false;\n\t\t\t\t\t\tRay_t lightray;\n\t\t\t\t\t\tlightray.o = nearest_hitPos;\n\t\t\t\t\t\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\t\t\t\t\t\tlightray.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(IntersectPlane(Plane[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\t\tif(!inShadow)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectSphere(Sphere[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tI_local+=CalculateFinalColor2(nearest_hitPos,normalize(Light[i].position-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(OutRay.o-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tMaterial[nearest_hitMatID],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLight[i]);\n\t\t\t\t\t\t\t\tinShadow=false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\n\n\t\t\t\t\t\t\tRay_t scTrace;\n\t\t\t\t\t\t\tscTrace.d=refractOutDir;\n\t\t\t\t\t\t\tvec3 coeffrg=mat.k_rg;\n\n\t\t\t\t\t\t\tfor( int i=0; i<= NUM_FRAC_ITERATIONS;i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tscTrace.o = nearest_hitPos;\n\t\t\t\t\t\t\t\tscTrace.d = reflect(scTrace.d ,temp_hitNormal);\n\t\t\t\t\t\t\t\tCalculateInteractions(scTrace,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);\n\t\t\t\t\t\t\t\tif(!temp_hasHit)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t#ifdef USE_SPECIAL_IBL\n\t\t\t\t\t\t\t\t\t\tI_local +=  IBLFactor(reflect(-scTrace.d ,temp_hitNormal),temp_hitNormal,scTrace.d,Material[nearest_hitMatID])*coeffrg;\n\t\t\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tI_local +=  EnviromentColor(scTrace.d)*coeffrg;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnearest_t = temp_t;\n\t\t\t\t\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\t\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\n\t\t\t\t\t\t\t\tvec3 I_local_temp = vec3( 0.0 ); \n\t\t\n\t\t\t\t\t\t\t\tbool inShadow=false;\n\t\t\t\t\t\t\t\tRay_t lightray;\n\t\t\t\t\t\t\t\tlightray.o = nearest_hitPos;\n\t\t\t\t\t\t\t\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\t\t\t\t\t\t\t\t\tlightray.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectPlane(Plane[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\t\t\t\tif(!inShadow)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(IntersectSphere(Sphere[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#ifndef USE_MULIT_REFRACTION_INREFRACTION\n\t\t\t\t\t\t\t\t\t\tI_local_temp+=Lighting(normalize(Light[i].position-nearest_hitPos),\tnormalize(nearest_hitNormal),normalize(scTrace.o-nearest_hitPos),\tinShadow,\tMaterial[nearest_hitMatID],Light[i]);\n\t\t\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tI_local_temp+=CalculateFinalColor2(nearest_hitPos,normalize(Light[i].position-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(nearest_hitNormal),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalize(scTrace.o-nearest_hitPos),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinShadow,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMaterial[nearest_hitMatID],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLight[i]);\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\tinShadow=false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#ifdef USE_FRESENEL_AFTER_REFRACTION_TO_CONTROAL_REFLECTION\n\t\t\t\t\t\t\t\tif(Material[nearest_hitMatID].isrefractable)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcoeffrg*=fresnel(-scTrace.d  ,normalize(nearest_hitNormal), Material[nearest_hitMatID].refractivity)*refrac_fresenl_coeff;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\tI_local += I_local_temp*coeffrg;\n\t\t\t\t\t\t\t\tI_local_temp=vec3(0);\n\t\t\t\t\t\t\t\tcoeffrg = Material[nearest_hitMatID].k_rg*coeffrg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\treturn refractionatten(I_local,refractionlength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\treturn vec3(0,0,0);\t\n\t\t\t}\n}\nvec3 CalculateFinalColor(in vec3 Pos,in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n\n\t\t\tif(mat.isrefractable)\n\t\t\t{\n\t\t\t\tfloat reflectfresnelcoeff=1.0;\n\t\t\t\tvec3 refractcolor=CalculateRefraction(Pos, L,  N, V,  mat,  light,reflectfresnelcoeff )*mat.k_refract;\n\n\t\t\t\tvec3 reflectColor= Lighting(L,N,V,inShadow,mat,light);\n\t\t\t\t//return vec3(0.0);\n\t\t\t\t\n\t\t\t\treturn refractcolor*reflectfresnelcoeff+reflectColor;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\treturn Lighting(L,N,V,inShadow,mat,light)/(1.0+sqrt(length(Pos-Light[0].position))*LightAtten);\n\t\t\t//return vec3(0.2);\n\t\t\t}\n\t\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n\ttemp_t = nearest_t;\n\n\tCalculateInteractions(ray,temp_t,temp_hitPos,temp_hitNormal,temp_hasHit,nearest_hitMatID);\n\n\thasHitSomething = temp_hasHit;\n    // One of the output results.\n    hasHit = hasHitSomething;\n\n\n    if ( !hasHitSomething )\n\treturn EnviromentColor(ray.d);\n\n\tnearest_t = temp_t;\n\tnearest_hitPos = temp_hitPos;\n\tnearest_hitNormal = temp_hitNormal;\n    \n\t\n\t//LIGHT CALCULATION\n\t////////////////////////////////////////////////////////////////////////\n\tvec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n\tbool inShadow=false;\n\tRay_t lightray;\n\tlightray.o = nearest_hitPos;\n\tfor(int i = 0 ; i < NUM_LIGHTS ;i++)\n\t{\n\t\tfloat lengthMax = length(Light[i].position-nearest_hitPos);\n\t\tlightray.d = (Light[i].position-nearest_hitPos)/lengthMax;\n\t\tfor(int i = 0 ;i < NUM_PLANES; i ++)\n\t\t{\n\t\t\tif(IntersectPlane(Plane[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t{\n\t\t\tinShadow = true;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!inShadow)\n\t\t{\n\t\t\tfor(int i = 0 ;i < NUM_SPHERES; i ++)\n\t\t\t{\n\t\t\t\tif(IntersectSphere(Sphere[i],lightray , DEFAULT_TMIN,lengthMax))\n\t\t\t\t{\n\t\t\t\tinShadow = true;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tI_local+=CalculateFinalColor(nearest_hitPos,normalize(Light[i].position-nearest_hitPos),\n\t\t\t\t\tnormalize(nearest_hitNormal),\n\t\t\t\t\tnormalize(ray.o-nearest_hitPos),\n\t\t\t\t\tinShadow,\n\t\t\t\t\tMaterial[nearest_hitMatID],\n\t\t\t\t\tLight[i]);\n\tinShadow=false;\n\t}\n\n\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\t\n    return I_local;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tdepthOFfocus=0.0;\n\tfragColor=vec4(0.0);\n\ttime = mod(iTime,300.0);\n\tfloat weight[3];\n\tweight[0]=0.7;\n\tweight[1]=0.15;\n\tweight[2]=0.15;\n\t#ifdef Motion_Blur\n\tfor( int i = 0; i < 3 ;i++)\n\t{\n\ttime = iTime-float(i)*0.1;\n\t#endif\n\n\tInitScene();\n\t\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n  \n    float randseed = (time+1.2) * (time+1.2)/80.2132;\n\t//if(iTime>10.0)\n   //     coeff=0.0;\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis =-1.0* normalize(   cam_lookto );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis =normalize( cross(cam_z_axis, cam_x_axis));\n\tvec3 rand= (texture(iChannel2,pixel_pos*randseed).xyz-vec3(0.5));\n\tvec3 rand2= (texture(iChannel2,pixel_pos*PI*randseed).xyz-vec3(0.5));\n    vec3 rand3= (texture(iChannel3,pixel_pos*PI*randseed).xyz-vec3(0.5))*depthOFfocus;\n //   \n\tcam_x_axis += cross(rand*rand3,cam_z_axis);\n\tcam_y_axis += cross(rand2*rand3,cam_z_axis);\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n\t#ifdef Motion_Blur\n\t\n\t\t #ifdef Gamma_Space\n\t\tfragColor += vec4(pow(I_result.x,0.45),pow(I_result.y,0.45),pow(I_result.z,0.45),1.0)*weight[i];\n\t\t#else\n\t\t fragColor += vec4( I_result, 1.0 )*weight[i];\n\t\t#endif\n\n\t}\n\t #else\n\n\t\t#ifdef Gamma_Space\n\t\tfragColor = vec4(pow(I_result.x,0.45),pow(I_result.y,0.45),pow(I_result.z,0.45),1.0);\n\t\t#else\n\t\t fragColor = vec4( I_result, 1.0 );\n\t\t#endif\n\t\n\t#endif \n}\n","name":"Image","description":"","type":"image"}]}