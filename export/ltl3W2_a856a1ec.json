{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n//Based on Voronoise from iq :https://www.shadertoy.com/view/Xd23Dh\n\nint windows = 0;\nvec2 m = vec2(.7,.8);\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*5.78) * 43758.236237153);\n}\n\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 hash2b( vec2 p )\n{\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n\nfloat vnoise(vec2 x)//Value noise\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return  2.*mix(mix( hash(p),hash(p + vec2(1.,0.)),f.x),\n                  mix( hash(p+vec2(0.,1.)), hash(p+1.),f.x),f.y)-1.;\n            \n}\n\nfloat gnoise( in vec2 p )// gradient noise from iq\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y)*2.;\n}\n\n\nmat2 m2= mat2(.8,.6,-.6,.8);\n\n\nfloat dvnoise(vec2 p)//Value noise + value noise with rotation\n{\n    return .5*(vnoise(p)+vnoise(m2*p));    \n}\n\n\n//Perlin like version of iqnoise adapted from voronoise : 3x3 kernel\n\n\nfloat iqnoisep( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )//kernel limitations to increase performances :\n    for( int i=-1; i<=1; i++ )//3x3 instead of 5x5\n    {\n        \n        vec2 g = vec2( float(i),float(j) )+.5;\n\t\tfloat o = hash( p + g );\n\t\tvec2 r = g - f ;\n\t\tfloat d = dot(r,r)*(.4+m.x*.4);\n        d=smoothstep(0.0,1.,d);//d=smoothstep(0.0,1.,sqrt(d));\n        //d = d*d*d*(d*(d*6. - 15.) + 10.);\n\t\tfloat ww = 1.0-d;\n\t\tva += o*ww;\n\t\twt += ww;\n    }\n\t\n    return 2.*va/wt-1.;\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1531,311.7273)), \n\t\t\t\t   dot(p,vec2(269.5437,183.3581)), \n\t\t\t\t   dot(p,vec2(419.2673,371.9741)) );\n\treturn fract(sin(q)*43758.5453);\n}\nvec3 hash3b( vec2 p )\n{\n    float q = hash(p);\n\treturn vec3(q,1.-q,q*(2.-q));\n}\n\n\n\n//iq noise adapted from voronoise 3x3 kernel : valid for u+v<1.5\n\nfloat iqnoise3( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 sp = floor(f*1.1666);//kernel shift if f is large\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) )+sp;\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = sqrt(dot(r,r)*.5);\n        d = d*d*d*(d*(d*6. - 15.) + 10.);//additional hermit 5 smoothing\n\t\tfloat ww = pow( 1.0-smoothstep(0.,1.,d), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return 2.*va/wt-1.;\n}\n\n//a variant of the previous noise using exp in weights\n\nfloat iqnoise3b( in vec2 x, float u, float v )//iq noise adapted from voronoise 3x3 kernel : valid for u + v <1.5\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 sp = floor(f*1.1666);\t\t\n\tfloat k = 1.0+15.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) )+sp;\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = exp(-4.*k*d);//pow( 1.0-smoothstep(0.0,1.,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return 2.*va/wt-1.;\n}\n\n//iq noise from voronoise 4x4 kernel : valid for all u and v \nfloat iqnoise4( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=1; j++ )\n    for( int i=-2; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) )+.5;\n\t\tvec3 o = hash( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r)*.5;\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return 2.*va/wt-1.;\n}\n\nfloat hash( in vec3 p ) \n{\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\n\nfloat voronoise(in vec3 p)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=2; i++) \n\tfor (int j=-1; j<=2; j++) \n\tfor (int k=-1; k<=2; k++)\n\t{\n\t\tvec3 o = vec3(i, j, k)-.5;       \t\t\n        vec3 pp = fp +o -hash(ip - o);\n        float d = dot(pp, pp)*.7;\n        d=clamp(d,0.,1.);d=sqrt(d);\n        d = d*d*(3.0-2.0*d);       \n        d = d*d*d*(d*(d*6. - 15.) + 10.);\n        float w = 1.-d;\n        va += w*d;\n        wt += w;\n\t}    \n    return 2.*va/wt-1.;\n}\n\n// a kind of pure voronoi version of iqnoise\nfloat voronoise(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j);       \t\t\n        vec2 pp = fp +o -hash2b(ip - o)*m.y;\n        float d = dot(pp, pp)*.7;       \n        d = smoothstep(0.0,1.,sqrt(d));       \n        d = d*d*d*(d*(d*6. - 15.) + 10.);\n        float w =  1.0-d;\n        va += w*d;\n        wt += w;\n\t}    \n    return 2.*va/wt-1.;\n}\n\n//a variant of the previous noise using exp in weights\n\nfloat voronoise1(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j);       \t\t\n        vec2 pp = fp +o -hash2(ip - o)*m.y-0.5;\n        float d = sqrt(dot(pp, pp)*.6);\n        d=clamp(d,0.,1.);\n        d = d*d*(3.0-2.0*d);//d = d*d*d*(d*(d*6. - 15.) + 10.);               \n        float w =  exp(-d*4.);\n        va += w*d;\n        wt += w;\n\t}    \n    return va/wt*2.-1.;\n}\n\n//standard voronoi 3x3 kernel giving f1,f2 and f3 if f3<1\n\nfloat voronoi(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    vec3 f = vec3(5.);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j);       \t\t\n        vec2 pp = fp +o  -hash2b(ip - o);\n        float d = dot(pp, pp);\n        if(d<f.x){f=f.zxy;f.x=d;}\n        else if(d<f.y){f=f.xzy;f.y=d;}\n        else if(d<f.z){f.z=d;}\n\t}    \n    return (f.x+m.x*f.y-.5*m.y*min(f.z,1.))/2.;\n}\n\nfloat noise( vec2 p){\n    \n    \n    if(windows ==0)return voronoi(p);\n    if(windows ==1)return iqnoise3(p,m.x,m.y);\n    if(windows ==2)return iqnoisep(p);//iqnoise4(p,m.x,m.y);\n    //return 2.*gnoise(p*.5);\n    return voronoise(p*.5)*.8;\n}\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f ))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.07)*r;\n\t}\n\treturn r;\n}\n\nfloat fbm( vec2 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += noise( p*f )/f;       \n\t    f *=2.;\n\t}\n\treturn r;\n}\n\nfloat map(vec2 p){\n\n    //return noise(p*10.);\n    //return 2.*abs( noise(p*10.));\n\t//return fbm(p)+1.;\n    return 2.*fbmabs(p);\n}\n\nvec3 nor(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xy) - map(p - e.xy),\n\t\tmap(p + e.yx) - map(p - e.yx),\n\t\t-.2));\n}\n\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p = 2.*fragCoord.xy /iResolution.xy-1.;\n    \n\tif(p.y>0.){\n    \tif(p.x>0.)windows =1;\n    \telse    windows =0;}\n    else{\n    \tif(p.x>0.)windows =3;\n        else windows =2;}\n    //windows =2;\n    \n    p += .5*iTime;\n    \n    if(iMouse.z>0.)m = iMouse.xy/iResolution.xy;\n    \n    \n\tfloat r;\n\tr = (noise(p*10.));\n    vec3 light = normalize(vec3(4., 2., -1.));\n\n    r = max(dot(nor(p), light),0.1);\n    float k=map(p);\n    fragColor = clamp(vec4(r, r, r, 1.0),0.,1.);\n\tfragColor = clamp(vec4(r*k*k, r*k, r, 1.0),0.,1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltl3W2","date":"1425400769","viewed":826,"name":"Voronoise terrains","username":"guil","description":"Trying to fit iqnoise from voronoise in a 3x3 kernel using various tricks in order to get acceptable perfomances\nUse mouse to modify the parameters.\n","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi","noise","terrain"],"hasliked":0,"parentid":"","parentname":""}}