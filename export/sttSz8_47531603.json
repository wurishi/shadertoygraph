{"ver":"0.1","info":{"id":"sttSz8","date":"1638736574","viewed":647,"name":"Spectral Aim","username":"panna_pudi","description":"I don't really feel how to make glitches and tried some to apply 'fine' transition.\nlooked at this https://www.shadertoy.com/view/Md2GDw","likes":44,"published":1,"flags":0,"usePreview":0,"tags":["2d","glitch","transition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\nconst float RECORD_PERIOD = 15.;\n\n// #define NOAA\n\n// By gaz: https://www.shadertoy.com/view/WdfcWr\nvec2 pSFold(vec2 p, float n) {\n    float e = 5e-3;\n    float h = floor(log2(n));\n    float a = 6.2831 * exp2(h) / n;\n    for (float i = 0.0; i < h + 2.0; i++) {\n        vec2 v = vec2(-cos(a), sin(a));\n        float g = dot(p, v);\n        // https://iquilezles.org/articles/functions\n        p -= (g - sqrt(g * g + e)) * v;\n        a *= 0.5;\n    }\n    return p;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat hash21(vec2 coord){\n    return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// looping noise\n// note x range must be same size or bigger than loopLen\n// use bigger loopLen for more detail in loop\nfloat loop_noise(float x, float loopLen) {\n    // cycle the edges\n    x = mod(x, loopLen);\n\n    float i = floor(x);  // floored integer component\n    float f = fract(x);  // fractional component\n    float u =\n        f * f * f * (f * (f * 6. - 15.) + 10.);  // use f to generate a curve\n\n    // interpolate from the current edge to the next one wrt cycles\n    return mix(hash(i), hash(mod(i + 1.0, loopLen)), u);\n}\n\nvec3 pattern(vec2 uv, float time, float n) {\n    float num_seg = n;\n    uv *= rot(PI / num_seg);\n    uv = pSFold(uv, num_seg);\n\n    float loop_length = RECORD_PERIOD;\n    float transition_start = RECORD_PERIOD / 3.;\n\n    float phi = atan(uv.y, uv.x + 1e-6);\n    phi = phi / PI * 0.5 + 0.5;\n    float seg = floor(phi * num_seg);\n    float width = sin(seg) + 8.;\n\n    float theta = (seg + 0.5) / num_seg * PI * 2.;\n    vec2 dir1 = vec2(cos(theta), sin(theta));\n    vec2 dir2 = vec2(-dir1.y, dir1.x);\n    \n    float radial_length = dot(dir1, uv);\n    float prog = radial_length / width;\n    float idx = floor(prog);\n\n    const int NUM_CHANNELS = 3;\n    vec3 col = vec3(0.);\n    for (int i = 0; i < NUM_CHANNELS; ++i) {\n        float off = float(i) / float(NUM_CHANNELS) - 1.5;\n        time = time + off * .015;\n\n        float theta1 = loop_noise(idx * 34.61798 + time,      loop_length);\n        float theta2 = loop_noise(idx * 21.63448 + time + 1., loop_length);\n\n        float transition_progress =\n            (time - transition_start) / (loop_length - transition_start);\n        float progress = clamp(transition_progress, 0., 1.);\n\n        float threshold = mix(theta1, theta2, progress);\n\n        float width2 = fract(idx * 32.721784) * 500.;\n        float slide = fract(idx * seg * 32.74853) * 50. /* * time */\n                      + loop_noise(time, loop_length) * 100. +\n                      1000. * (hash(idx) - 0.5);\n        float prog2 = (dot(dir2, uv) - slide) / width2;\n\n        float c = clamp(width  * (fract(prog)  - threshold),      0., 1.)\n                * clamp(width2 * (fract(prog2) + threshold - 1.), 0., 1.);\n\n        col[i] = c;\n    }\n    return col;\n}\n\nfloat v1gnette(vec2 uv) {\n    vec2 d = abs(uv / iResolution.xy - vec2(0.5)) * 1.21;\n    d = pow(d, vec2(2.0));\n    return pow(clamp(1.0 - dot(d, d), 0., 1.0), 3.5);\n}\n\nvec3 draw(vec2 uv, float fold_n, float release, float time) {\n    vec3 col = vec3(0.);\n    \n    vec2 block = floor(uv / vec2(64.));\n    vec2 uv_noise = block / vec2(125);\n    uv_noise += floor(vec2(fract(time)) * vec2(1234.0, 3543.0)) / vec2(2);\n\n    float block_thresh = pow(fract(time), 2.0) * 0.5 * release;\n    float line_thresh = pow(fract(time), 2.0) * 0.5 * release;\n\n    vec2 uv_r = uv, uv_g = uv, uv_b = uv;\n\n    if (hash21(uv_noise) < block_thresh ||\n        hash21(uv_noise) < line_thresh) {\n        vec2 dist = (fract(uv_noise) - 0.5);\n        uv_r += dist * 50.1;\n        uv_g += dist * 40.2;\n        uv_b += dist * 60.125;\n    }\n\n    uv_r += 2.;\n\n    col.r = pattern(uv_r, time, fold_n).r;\n    col.g = pattern(uv_g, time, fold_n).g;\n    col.b = pattern(uv_b, time, fold_n).b;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float scale = 350.;\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1.);\n    uv *= scale;\n\n    float time = iTime;\n    \n    vec3 col = vec3(0.);\n\n    float n = RECORD_PERIOD / 2.;\n    // https://www.desmos.com/calculator/w4u0k6gejv\n    float release = smoothstep(1., 0., abs(mod(2. * time + 1., n) - 1.));\n    release = pow(release, 5.);\n    float type = step(n / 2., mod(time, n));\n    float fold_n = 4. + 2. * type;\n    uv *= 1. - 0.08 * type;\n\n#ifdef NOAA\n    col = draw(uv, fold_n, release, time);\n#else\n    const int N = 1;\n    for (int i = -N; i <= N; i++) {\n        for (int j = -N; j <= N; j++) {    \n            col += draw(uv - vec2(i, j) / (iResolution.xy / scale),\n                        fold_n, release, time);\n        }\n    }\n    float k = 2. * float(N) + 1.;\n    col /= k * k;\n#endif\n\n    col *= v1gnette(fragCoord);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}