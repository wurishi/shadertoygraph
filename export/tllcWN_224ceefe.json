{"ver":"0.1","info":{"id":"tllcWN","date":"1592146632","viewed":68,"name":"Spiral Cat","username":"mgjunior","description":"spiral pattern","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI =3.1415;\nconst float L=0.01;\nvec2 getHelix(float theda,vec2 center)\n{\n    float t = theda/(2.0*PI);\n    return (L*(t*t*t))*vec2(cos(theda),sin(theda));\n}\n\nconst int maxPiece =10;\n//split Spiral to many piece , each piece is 360 degree\nfloat findNowPieceRatio(vec2 nowVector,float theda,vec2 center)\n{\n    vec2 oldRef= vec2(0.0,0.0);\n    for(int fI=0;fI<maxPiece;fI++)\n    {\n        // in this piece ?\n        vec2 nowRef =getHelix(theda+float(fI)*2.0*PI,center);\n        float n=length(nowVector);\n        float R =length(nowRef);\n        if(n<R)\n        {\n            float r =length(oldRef);\n            float ratio = (n-r)/(R-r);\n            return ratio;\n        }\n        oldRef = nowRef;\n    }    \n    return 0.0;\n}\n\nvec2 bigCircleCenter=vec2(0.5,0.5);\nfloat R=0.5;\n\nfloat nearestDistanceInCircle(vec2 p)\n{\n    return (R-length(p-bigCircleCenter));\n}\n\nvec2 findIntersectWichCircle(vec2 p,vec2 dir)\n{\n    for(int i=0;i<5;i++)\n    {\n        float moveDis=nearestDistanceInCircle(p);\n        p = p+dir*moveDis;\n        if(R-length(p-bigCircleCenter)<0.000001)\n            return p;\n    }\n    return p;\n}\n\nfloat r=0.1;\nvec2 smallCircleCenter =vec2(0.5,0.5);\n\nvec4 render(vec2 uv)\n{\n    vec2 dir=uv-smallCircleCenter;\n    float theda =mod(atan(dir.y,dir.x)+2.0*PI+3.0*iTime,2.0*PI);\n    \n    float ratio = findNowPieceRatio(dir,theda,smallCircleCenter);\n\n    \n    float c =ratio;\n    //peak ratio\n    //return vec4(c,c,c,1.0f);\n    \n    dir = normalize(dir);\n    //find Intersect with big Circle\n    vec2 pOnCircle =findIntersectWichCircle(smallCircleCenter,dir);\n    float lineL=length(pOnCircle-smallCircleCenter)-r;\n\n    vec2 fetchUV=smallCircleCenter+dir*(r+lineL*ratio);\n    return vec4(c,c,c,1.0)*texture(iChannel0,fetchUV);      \n}\n\nvec2 uvDeform(vec2 uv)\n{\n    //find ray hit point\n    float depth =5.0;\n    vec3 planeCenter = vec3(smallCircleCenter,depth);\n    float strength=6.0;\n    vec2 target = strength*vec2(cos(iTime/2.0),sin(iTime/2.0));\n    vec3 planeNormal = vec3(target,-1.0);\n    planeNormal = normalize(planeNormal);\n    \n\tvec3 rayFrom =vec3(uv,0.0);\n    vec3 ray =vec3(0.0,0.0,1.0);\n    \n    float t = dot((planeCenter-rayFrom),planeNormal)/(dot(ray,planeNormal));\n    \n    vec3 hitPoint =rayFrom +t*ray;\n    hitPoint = hitPoint- vec3(bigCircleCenter,0.0);\n    \n    //project to plane z=1\n    hitPoint = hitPoint/hitPoint.z;\n    return hitPoint.xy*depth+bigCircleCenter; \n    //return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    float moveR=0.2;\n    smallCircleCenter = bigCircleCenter+moveR*vec2(cos(-iTime/4.0),sin(-iTime/2.0));\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = render(uvDeform(uv));\n}","name":"Image","description":"","type":"image"}]}