{"ver":"0.1","info":{"id":"wl33W7","date":"1581322637","viewed":140,"name":"3D-Fractals","username":"a1pha1","description":"Some 3D fractal distance function","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void rotateX(inout vec3 z, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tz.y = c*z.y + s*z.z;\n\tz.z = c*z.z - s*z.y;\n}\n\nvoid rotateY(inout vec3 z, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tz.z = c*z.z + s*z.x;\n\tz.x = c*z.x - s*z.z;\n}\n\nvoid rotateZ(inout vec3 z, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tz.x = c*z.x + s*z.y;\n\tz.y = c*z.y - s*z.x;\n}\n\nvoid distort(inout vec3 z, float s)\n{\n\tfloat nx, ny, nz;\n\tfloat y = z.y;\n\tny = sin(z.z);\n\tnz = z.x*0.9;\n\tnx = y;\n\tz = mix(z, vec3(ny, nz, nx), s);\n\t//z = max(z,-z);\n}\n\nvoid shrink(inout vec3 z, float shrink)\n{\n\tz = z*shrink;\n}\n\nvoid scaleAround(inout vec3 z, vec3 offset, float scale)\n{\n\tz = z*scale - offset*(scale-1.0);\n}\n\nvoid planeFold(inout vec3 z, vec3 n, float d) {\n\tz.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;\n}\n\nvoid sphereFold(inout vec3 z, float minR, float maxR) {\n\tfloat r2 = dot(z.xyz, z.xyz);\n\tz *= max(maxR / max(minR, r2), 1.0);\n}\n\nvoid boxFold(inout vec3 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\nvoid absFold(inout vec3 z, vec3 c) {\n\tz.xyz = abs(z.xyz - c) + c;\n}\nvoid sierpinskiFold(inout vec3 z) {\n\tz.xy -= min(z.x + z.y, 0.0);\n\tz.xz -= min(z.x + z.z, 0.0);\n\tz.yz -= min(z.y + z.z, 0.0);\n}\nvoid mengerFold(inout vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\n\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.141 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nconst float ITERATIONS = 15.;\nconst float EPSILON = 0.001;\n\nfloat map(vec3 z)\n{\n    shrink(z, 0.1);\n    planeFold(z, vec3(-1.0, 0.0, 0.0), -1.0);\n    \n    for(float n = 0.; n < ITERATIONS; n++) \n    {\n        sphereFold(z, 0.1, 1.2);\n        planeFold(z, vec3(0.0, 1.0, 0.0), -1.0);\n        planeFold(z, vec3(0.0, 0.0, 1.0), -1.0);\n        mengerFold(z);\n        scaleAround(z, vec3(1.0, 1.0, 1.0), 2.0);\n        rotateX(z,-0.1+sin(iTime*0.4)*0.1);\n        rotateZ(z,-0.048+sin(iTime*0.77)*0.1);\n        //rotateY(z, sin(iTime*0.2)*0.05);\n        sphereFold(z, 0.2, 1.7);\n   }\n   return (length(z)) * pow(2., -ITERATIONS);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(EPSILON, 0.);\n    return normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),map(pos+e.yxy)-map(pos-e.yxy),map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nconst float PI = 3.141;\nconst float PHI = 1.618;\n\nfloat hash1(float f)\n{\n  return fract(sin(f*234.345)*83457.32);   \n}\n\nvec3 nextVec( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, float pre, float dis)\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<int(pre); i++ )\n    {\n        vec3 ap = nextVec( float(i), pre );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*dis)*(32.0/dis), 0.0, 1.0 );\n    }\n\tao /= pre;\n\t\n    return clamp( ao*ao, 0.0, 1.0 );\n}\n\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float disO = 0.;\n    \n    for(int i = 0; i < 100000; i++)\n    {\n    \tvec3 pos = ro+rd*disO;\n        float d = map(pos);\n        disO += d;\n        \n        if(d < EPSILON)\n            return disO;\n        if(disO > 200.)\n            break;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AA = 2.;\n    \n    vec3 tot = vec3(0.);\n\n    for(float ax = 0.; ax < AA; ax++)\n    {\n        for(float ay = 0.; ay < AA; ay++)\n        {\n\t\t\tvec2 uv = ((fragCoord-0.5*iResolution.xy)/iResolution.y)+vec2(ax / (iResolution.x*AA), ay / (iResolution.y*AA));\n           // uv = abs(uv);\n\n            float w = 0.;\n            float dis = iTime-38.;\n            vec3 ro = vec3(10., dis, dis);\n\n            vec3 ta = ro+vec3(0., 0.785398, 0.785398);\n            vec3 f = normalize(ta-ro);\n            vec3 r = normalize(cross(vec3(0.,1., 0.), f));\n            vec3 u = normalize(cross(f, r));\n            float zoom = 1.;\n            vec3 rd = normalize(f*zoom+r*uv.x+u*uv.y);\n\n            vec3 col = vec3(0.);\n\n            float d = march(ro, rd);\n            if(d > 0.)\n            {\n                vec3 pos = ro+rd*d;\n                vec3 nor = calcNormal(pos);\n                vec3 lDir = normalize(u);\n                vec3 base = vec3(0.9);\n                float dif = diffuse(nor, lDir, 1.);\n                float ao1 = calcAO(pos, nor, 64., 1.5);\n                float ao2 = calcAO(pos, nor, 32.,EPSILON * 50.);\n                vec3 ref = normalize(lDir - (2.*dot(nor, lDir)*nor));\n                float spec = clamp(dot(normalize(pos-ro), ref), 0., 1.);\n                spec = pow(spec, 30.);\n\n                vec3 mat = mix(vec3(2., 0.4, 0.3), vec3(0.9), ao2*ao2*ao2);\n\n                col = vec3(mat*ao1*mix(dif, 1., 0.2)*0.8);\n                col += spec*0.1;\n                col *= 2.6*exp(d*-0.07);\n            }\n            tot+=col;\n        }\n    }\n    tot /= AA*AA;\n    tot = pow( tot, vec3(1.0,1.0,1.4) ) + vec3(0.0,0.02,0.12);\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n    fragColor =vec4(pow(tot,vec3(0.75)), 1.0);\n}","name":"Image","description":"","type":"image"}]}