{"ver":"0.1","info":{"id":"MtsSDf","date":"1440366547","viewed":164,"name":"PT II - Draw f(x)","username":"Piperoman","description":"Piperotutorial 2. Tutorial drawing basic stuffs. Learn more in this tutorial from vgs: https://www.shadertoy.com/view/Md23DV","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test","tutorial","dontlook"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n// Description: FUNCTION PLOTTING\n//\n// It is always useful to see the plots of functions on cartesian\n// coordinate system, to understand what they are doing precisely\n//\n// Let's plot some 1D functions!\n// \n// If y value is a function f of x value, the expression of their\n// relation is: y = f(x)\n// in other words, the plot of a function is all points\n// that satisfy the expression: y-f(x)=0\n// this set has 0 thickness, and can't be seen.\n// Instead use the set of (x,y) that satisfy: -d < y-f(x) < d\n// in other words abs(y-f(x)) < d\n// where d is the thickness. (the thickness in in y direction)\n// Because of the properties of absolute function, the condition\n// abs(y-f(x)) < d is equivalent to the condition:\n// abs(f(x) - y) < d\n// We'll use this last one for function plotting. (in the previous one\n// we have to negate the function that we want to plot)\n\n////////////////////////////////////////////\n// \t\tFunction declaration\n////////////////////////////////////////////\nvoid drawAxis( inout vec3 pixel, in vec2 r, in vec3 axesColor, in vec3 gridColor );\nfloat linearstep(float edge0, float edge1, float x);\nfloat smootherstep(float edge0, float edge1, float x);\nvoid drawLine( inout vec3 pixel, in vec2 r, in float m, in float n, in vec3 color, in float lineThickness);\nvoid drawQuadratic( inout vec3 pixel, in vec2 r, in float n, in vec3 color, in float lineThickness);\nvoid drawSin( inout vec3 pixel, in vec2 r, in float frequency, in float phase, in vec3 color, in float lineThickness);\nvoid drawStep( inout vec3 pixel, in vec2 r, in float y0, in float y1, in float x0, in vec3 color, in float lineThickness);\nvoid drawLinearStep( inout vec3 pixel, in vec2 r, in float y0, in float y1, in float x0, in float x1, in vec3 color, in float lineThickness);\nvoid drawSmoothStep( inout vec3 pixel, in vec2 r, in float y0, in float y1, in float x0, in float x1, in vec3 color, in float lineThickness);\nvoid drawClamp( inout vec3 pixel, in vec2 r, in float y0, in float amplitude, in float minclamp, in float maxclamp, in float frequency, in float phase, in vec3 color, in float lineThickness);\nvoid plot(vec2 r, float y, float lineThickness, vec3 color, inout vec3 pixel);\n\n////////////////////////////////////////////\n// \t\tFunction implementation\n////////////////////////////////////////////\n/*\n* This function draw the axis\n*/\nvoid drawAxis( inout vec3 pixel, in vec2 r, in vec3 axesColor, in vec3 gridColor )\n{\t\t\n\t// Draw the grid lines\n\t// we used \"const\" because loop variables can only be manipulated\n\t// by constant expressions.\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) \n    {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.004) pixel = gridColor;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n}\n\n/*\n* This function is like a gradient linear t\n*/\nfloat linearstep(float edge0, float edge1, float x) \n{\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\n/*\n* This function is like a gradient t^5\n*/\nfloat smootherstep(float edge0, float edge1, float x) \n{\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\n/**\n* This function draw in a pixel given a line y = m Â· x + n, with color and thickness\n*/\nvoid drawLine( inout vec3 pixel, in vec2 r, in float m, in float n, in vec3 color, in float lineThickness)\n{\n    if( abs(m * r.x + n - r.y) < 0.01 ) pixel = color;\n}\n\n/**\n* This function draw in a pixel given a quadratic y = x^2 + n\n*/\nvoid drawQuadratic( inout vec3 pixel, in vec2 r, in float n, in vec3 color, in float lineThickness)\n{\n\tif( abs(r.x * r.x + n - r.y) < lineThickness ) pixel = color;\n}\n\n/**\n* This function draw in a pixel given a quadratic y = x^2 + n\n*/\nvoid drawSin( inout vec3 pixel, in vec2 r, in float frequency, in float phase, in vec3 color, in float lineThickness)\n{\n\tif( abs(sin(TWOPI * frequency * r.x + phase) - r.y) < lineThickness ) pixel = color;\n}\n\n/**\n* This function draw in a pixel given a step\n*\n*    x0 = edge = where change value\n*    x = variable\n* // f(x0, x) = { y1 x>x0,  // Amplitude after\n* //            { y0 x<x0\t// Amplitude before\n*/\nvoid drawStep( inout vec3 pixel, in vec2 r, in float y0, in float y1, in float x0, in vec3 color, in float lineThickness)\n{\n\tif( abs(y1 * step(x0, r.x) + y0 - r.y) < lineThickness ) pixel = color;\n}\n\n/**\n* This function draw in a pixel given a step with a linear function\n*\n*    x0 = edge = where change value\n*    x = variable\n* // f(x0, x) = { y1 \t\tx>x1,  \t\t\t// Amplitude after\n* //\t\t\t{ linear \tx0 < x < x1\t\t// Linear\n* //            { y0\t\tx<x0\t\t\t// Amplitude before\n*/\nvoid drawLinearStep( inout vec3 pixel, in vec2 r, in float y0, in float y1, in float x0, in float x1, in vec3 color, in float lineThickness)\n{\n    if( abs( (y1 - y0) * linearstep(x0, x1, r.x)+ y0 - r.y) < lineThickness ) pixel = color;\n}\n\n/**\n* This function draw in a pixel given a step with a smooth function\n*\n*    x0 = edge = where change value\n*    x = variable\n* // f(x0, x) = { y1 \t\tx>x1,  \t\t\t// Amplitude after\n* //\t\t\t{ smooth \tx0 < x < x1\t\t// Smooth\n* //            { y0\t\tx<x0\t\t\t// Amplitude before\n*/\nvoid drawSmoothStep( inout vec3 pixel, in vec2 r, in float y0, in float y1, in float x0, in float x1, in vec3 color, in float lineThickness)\n{\n    if( abs( (y1 - y0) * smoothstep(x0, x1, r.x)+ y0 - r.y) < lineThickness ) pixel = color;\n}\n\n/**\n* This function draw a clamp\n*\n*  f(x, ymin, ymax) \t= \t\t\t{ amplitude * \tmax   x > max\n*                   \t\t\t\t{ amplitude * \tx   \t\tmax > x > min\n*                   \t\t\t\t{ amplitude *   min \t \t      \t  min > x\n*/\nvoid drawClamp( inout vec3 pixel, in vec2 r, in float y0, in float amplitude, in float minclamp, in float maxclamp, in float frequency, in float phase, in vec3 color, in float lineThickness)\n{\n    // plot(r, 0.5*clamp(sin(TWOPI*x), 0.0, 1.0)-0.7, 0.015, greenColor, pixel);\n    //if( abs( (y1 - y0) * smoothstep(x0, x1, r.x)+ y0 - r.y) < lineThickness ) pixel = color;\n    if( abs( (amplitude - y0) * clamp(sin(TWOPI * frequency * r.x + phase), minclamp, maxclamp)+ y0 - r.y) < lineThickness ) pixel = color;\n}\n/**\n* GENERAL: This function calculate is has to draw a function y given\n*/\nvoid plot(vec2 r, float y, float lineThickness, vec3 color, inout vec3 pixel) \n{\n\tif( abs(y - r.y) < lineThickness ) pixel = color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Basic variables\n    vec3 blackColor = vec3(0.0);\n    vec3 grayColor = vec3(0.5);\n    vec3 whiteColor = vec3(1.0);\n    vec3 redColor = vec3(1.0, 0.0, 0.0);\n    vec3 greenColor = vec3(0.0, 1.0, 0.0);\n    vec3 blueColor = vec3(0.0, 0.0, 1.0);\n    \n    // Operation variables\n    vec2 r = 2.0 * vec2( fragCoord.xy - 0.5*iResolution.xy ) / iResolution.y ; // x,y [-1.0, 1.0] with aspect Ratio\n    vec2 rxy = 2.0 * vec2( fragCoord.xy - 0.5*iResolution.xy ) / iResolution.y ; // x,y [-1.0, 1.0] \n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\t// Point this shader iteration\n    \n    // Output variables\n    vec3 pixel = vec3(1.0);\n    \n    drawAxis(pixel, r, blueColor, grayColor);\n\t\n\t// Draw functions\n\tfloat x = r.x;\n\tfloat y = r.y;\n\n    // Comment a draw* to avoid each function\n    \t// y = 2.0 * m + 0.5\n    //drawLine(pixel, r, 2.0, 0.5, greenColor, 0.02);\n\n\t\t// y = x^2 + 0.2\n\t//drawQuadratic(pixel, r, 0.2, greenColor, 0.02);\n    \n\t\t// y = sin(PI x)\n    //drawSin(pixel, r, 0.5, 0.0, greenColor, 0.02);\n\t\n\t\t// step from 0.2 to 0.5 in x = 0.0 ( center )\n    //drawStep(pixel, r, 0.2, 0.5, 0.0, greenColor, 0.01);\n    \n    \t// linear step from x = [-0.5, 0.5] y = [-0.5, 0.5]\n    //drawLinearStep(pixel, r, -0.5, 0.5, -0.5, 0.5, greenColor, 0.01);\n\t\n    \t// smooth step from x = [-0.5, 0.5] y = [-0.5, 0.5]\n\t//drawSmoothStep(pixel, r, -0.5, 0.5, -0.5, 0.5, greenColor, 0.01);\n    \n    \t// Draw clamp with start y0, amplitude, min, max, frequency and initial phase\n    //drawClamp(pixel, r, -0.1, 0.5, -0.0, 1.0, 1.0, 0.0, greenColor, 0.01);\n    \n\t\t// plot a bell curve around -0.5 using general function\n\t//plot(r, 0.6*exp(-10.0*(x+0.8)*(x+0.8)) - 0.1, 0.015, greenColor, pixel);\n    \n    // More functions to draw?\n\t\n\t// Final draw\n    fragColor = vec4(pixel, 1.0);\n}","name":"","description":"","type":"image"}]}