{"ver":"0.1","info":{"id":"wt2BRh","date":"1598375739","viewed":68,"name":"cloods","username":"EmmaChase","description":"clouds","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_STEPS 10\n#define NUM_SCATTER 2\n#define C_SCALE 0.15\n#define ENERGY_C 2.3\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid rayBoxDist(vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir, out float dstToBox, out float dstInsideBox) {\n    vec3 t0 = (boundsMin - rayOrigin) / rayDir;\n    vec3 t1 = (boundsMax - rayOrigin) / rayDir;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float dstA = max(max(tmin.x, tmin.y), tmin.z);\n    float dstB = min(tmax.x, min(tmax.y, tmax.z));\n    \n    dstToBox = max(0., dstA);\n    dstInsideBox = max(0., dstB - dstToBox);\n}\n\nvec3 sample_cloud(vec3 pos) {\n    vec3 nsamp = vec3(snoise(1. *pos+0.1*iTime))*0.5;\n    nsamp     += vec3(snoise(2. *pos))*0.25;\n    nsamp     += vec3(snoise(4. *pos))*0.125;\n    nsamp     += vec3(snoise(8. *pos))*0.02125;\n    nsamp     += vec3(snoise(16.*pos))*0.02125;\n    \n    return nsamp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 sunPos = vec3(0., 15., 8.);\n\n    \n    vec3 cameraPosition = vec3(4.+2.*sin(iTime), 3.5, -6.);\n    vec3 cameraLook = normalize(vec3(0, -0.5, 1.));\n    \n    vec3 rayDir = normalize(vec3(-0.7, -1.5, 1.) + 1.25*vec3(2.*uv - 1., 0.));//normalize(cameraLook + vec3(0.5*uv, 0.));\n    //nsamp /= 5.;\n    \n    vec3 boxMin = vec3(-1000, -10, -10);\n    vec3 boxMax = vec3(1000,3,200);\n    \n    float dtb = 0.;\n    float dib = 0.;\n    rayBoxDist(boxMin, boxMax, cameraPosition, rayDir, dtb, dib);\n    \n    float transmittance = 1.;\n    vec3 energy = vec3(0.);\n    \n    float lightAbsorptionThroughCloud = 0.25;\n    float lightAbsorptionTowardSun = 0.15;\n    \n    //float avg_density = 0.;\n    if (dib > 0.) {\n        vec3 step_pt = cameraPosition + rayDir*dtb;\n        float step_size = dib / (float(NUM_STEPS) - 1.);\n        for (int i = 0; i < NUM_STEPS; i++) {\n            float pt_density = max(0., sample_cloud(C_SCALE*step_pt).r);\n            \n            \n            if (pt_density > 0.) {\n                vec3 scatter_pt = step_pt;\n            \tvec3 scatter_dir = normalize(sunPos - scatter_pt);\n            \tfloat dts = 0.;\n            \tfloat dic = 0.;\n            \trayBoxDist(boxMin, boxMax, scatter_pt, scatter_dir, dts, dic);\n            \n                float subDensity = 0.;\n                \n\t            float scat_size = dic / float(NUM_SCATTER);\n    \t        for (int j = 0; j < NUM_SCATTER; j++) {\n        \t        scatter_pt += scatter_dir*scat_size;\n                \n            \t    subDensity += max(0., sample_cloud(C_SCALE*scatter_pt).r);\n            \t}\n                \n                float subTransmittance = exp(-subDensity * lightAbsorptionTowardSun);\n            \n                float phaseVal = acos(dot(rayDir, scatter_dir) / length(rayDir)*length(scatter_dir)) / (2.*3.1415);\n                \n                energy += ENERGY_C * pt_density * step_size * transmittance * subTransmittance * phaseVal;\n                transmittance *= exp(-pt_density * step_size * lightAbsorptionThroughCloud);\n            \t//avg_density += pt_density;\n                \n                // Too small anyways\n                if (transmittance < 0.01) {\n                    break;\n                }\n            }\n            \n            \n            step_pt += rayDir*step_size;\n        }\n        \n        //avg_density /= float(NUM_STEPS);\n        \n        //col *= vec3(1.) * (1. - avg_density);\n    }\n    \n    //float transmittance = exp(-2.*avg_density);\n    vec3 lightColor = vec3(1., 1., 1.);\n    vec3 cloudColor = energy*lightColor;\n    col *= transmittance;\n    col += cloudColor;\n    \n    // Output to screen\n    fragColor = vec4(col*transmittance, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}