{"ver":"0.1","info":{"id":"WdyGWd","date":"1571161134","viewed":771,"name":"making minmax quadtree for free2","username":"FabriceNeyret2","description":"Renormalize each quad between the local min/max value.\n( Twisting MIPmap to compute hierarchical min/max for ~free ).","likes":8,"published":3,"flags":32,"usePreview":0,"tags":["minmax","gpmipmap","bbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// variant of https://shadertoy.com/view/3sKGWy\n\n#define LOD 4.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float res = texture(iChannel0, U/R).a,\n            r = res / R.y;\n    O = texture(iChannel0, U/R*r).rrrr;\n    \n\n    int l = int(max(0.,LOD+log2(R.y/res)));\n    vec2 M = texelFetch(iChannel0, ivec2(U*r)>>l, l).gb;\n  //vec2 M = textureLod(iChannel0, U/R*r, float(l)).gb;\n    M *= exp2(2.*float(l));                    // convert MIPmap average to sum \n\n    M.x = pow( M.x,-1./POW );                     // this approximates MIN\n    M.y = pow( M.y, 1./POW );                     // this approximates MAX\n    //O.g *= exp2(-2.*float(l)/POW);              // convert MIPmap average to sum \n    //O.b *= exp2( 2.*float(l)/POW);              // convert MIPmap average to sum \n    O = ( O - M.x ) / (M.y-M.x);\n\n\n    O = pow( O, vec4(1./2.2) );                       // back to sRGB\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 O, vec2 U )\n{\n    float res = iChannelResolution[0].y,\n          lod = max(0., ceil(log2(res/R.y)));\n    O.r = length( texelFetch(iChannel0, ivec2(U), int(lod) ).rb ) / 1.3;\n    O.r = max(O.r,.019);              // no denormalized IEEE floats on the GPU ? or in float buffers ?\n    O.r = pow( O.r, 2.2 );            // sRGB to flat (was it necessary ?)\n    O.g = pow( O.r,-POW );            // this approximates MIN\n    O.b = pow( O.r, POW );            // this approximates MAX\n    O.a = res / exp2(lod);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define POW 10.  // the larger the better min/max, but more bigfloats precision issues\n\n#define R  (iResolution.xy)\n","name":"Common","description":"","type":"common"}]}