{"ver":"0.1","info":{"id":"NddBDM","date":"1656594600","viewed":779,"name":"The Infinite City III","username":"fancyzero","description":"A Procedural Art\nbased on https://www.shadertoy.com/view/slXGDl\nCONTROL:\nSPACE KEY : Generate New ","likes":70,"published":1,"flags":48,"usePreview":0,"tags":["procedural","heightfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//post process\n\n#define T texture(iChannel0, I\n\n//debug\nint D(vec2 p, float n) {\n    int i=int(p.y), b=int(exp2(floor(30.-p.x-n*3.)));\n    i = ( p.x<0.||p.x>3.? 0:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: 0 )/b;\n \treturn i-i/2*2;\n}\n\n\n vec4 DrawDigits(vec2 i, float x) \n {\n     vec4 o;\n    for (float n=5.; n>=0.; n--) \n    { \n        if ((i.x)<3.) \n        { \n        o = vec4(D(i,floor(mod(x/pow(10.,n),10.)))); \n        break; \n        } \n        i.x -=4.;  \n     \n    }\n    return o;\n}\n//end of debug\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\n/*\n    Fibonacci Bokeh Pass\n    \n    Based on: https://www.shadertoy.com/view/fljyWd\n    -2 chars by FabriceNeyret2\n*/\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //O = texture(iChannel2,I/iResolution.xy);\n    //return;\n    //Resolution for texel calculation\n    vec2 r = iResolution.xy;\n    //Sample point starting at vec2(scale, 0)\n    \n    float rad = abs(I.y/r.y-0.5);\n    \n    \n    #if FREE_CAMERA_MOVE\n    rad = rad*2.22;\n    #else\n    rad = mix(0., rad*1.11, smoothstep(0.6,0.,min(1.,iMouse.y/iResolution.y*2.)))*2.;\n    #endif\n    vec2 p = vec2(rad, O-=O);\n    \n    //\"i\" approximating the sqrt of the number of iterations.\n    //So i < 16 means roughly 256 texture samples.\n    for(float i=1.; i<8.; i+=1./i)\n        //Rotate sample point by golden angle (for even spacing).\n        p *= -mat2(.737, .676, -.676, .737),\n        //Add samples exponentially (a bit like a \"smooth maximum\").\n        O += exp(log(T/r+p*i/r))/.3);\n    //Convert back to linear color (making brighter pixel stand out)\n    O = pow(O,.3-O+O);\n    //Average by total sample weight via alpha channel.\n    O = sqrt(O/O.a);\n   \n    NoiseSeed = float(iFrame)* .003186154 + I.y * 17.2986546543 + I.x;\n    float noise = .9 + randomFloat()*.15;       \n    O.xyz*= noise*1.1;  \n    \n    \n    //int width = int(iResolution.x);\n    //vec4 randomData = texelFetch(iChannel2, ivec2(width-1,0),0);\n    \n    \n   // O += DrawDigits( I/4., randomData.y);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nmat2 makerot(float r)\n{\n    mat2 rotmat = mat2(vec2(cos(r),sin(r)), vec2(-sin(r), cos(r)));\n    return rotmat;\n}\n\n\nfloat hex(in vec2 p){\n    const float hexSize = .5;\n    const vec2 s = vec2(1, 1.7320508);\n    \n    p = abs(p);\n    return max(dot(p, s*.5), p.x) - hexSize;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //setup random parameters\n    \n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    int width = int(iResolution.x);\n    vec4 randomData = texelFetch(iChannel1, ivec2(width-1,0),0);\n    vec4 state1 = texelFetch(iChannel1, ivec2(width-2,0),0);//xy: resolution, z:base frame Num.\n    ivec2 index = ivec2(fragCoord);\n\n        \n    int baseRndSeed = int(randomData.x);\n    float windowSize = iResolution.y/10.;\n    \n    int symetrical = int(randomData.y) % 4;\n    if (symetrical != 0 )\n        baseRndSeed += int((fragCoord.x-iResolution.x/2.)/windowSize)+int((fragCoord.y-iResolution.y/2.)/windowSize)*10;\n    \n    int kernelShape = 0;\n\n    vec3 hh = hash(uvec3(baseRndSeed),11u);\n    int frameDivid=int(hh.x*6.)+3;   \n    int frameMod=int(hh.x*20.)+3;\n\n    int ppFrameDivid=randomRange(11,22,56,iFrame,0.);\n    int ppFrameMod=randomRange(4,7,56,iFrame,0.);\n\n    kernelShape=int (hash(uvec3(iFrame+77),99u).x*100.)%20;\n    \n    int frame = (iFrame-int(state1.z)) % 200 ;\n    \n\n    \n\n    \n    // initial frame\n    // and clear buffer if resolution change detedted\n    if ( frame <= 2 )\n    {\n        vec2 diff = abs(fragCoord - iResolution.xy/2.);\n        float f = max(diff.x, diff.y);\n        f = step(f,mod(randomData.y,8.)+2.);\n        vec3 hashValue = hash(uvec3(randomData.x, 0,0.),384u);\n        f= max(f,step(hash(uvec3(fragCoord.xy, randomData.x*18473.),77u).x,\n        hashValue.x*hashValue.x*hashValue.x*hashValue.x*0.00002));\n        fragColor = vec4(f, iTime,frame, 1.);  \n    }\n    else\n    {\n        ivec2 foffset = ivec2(0,0);\n        \n\n        int range = randomRange2(4,16,222,baseRndSeed,0.);\n\n        fragColor = texelFetch( iChannel0, ivec2(fragCoord.xy)+foffset,0);\n        if (frame > 100 )\n            return;\n        \n        if ( range < 6 && frame > 20 )\n            range = 6;\n            \n\n        //counting using a kernel\n        int total = 0;\n        ivec2 vc = ivec2(fragCoord);\n\n         \n        for (int i = -range; i <= range; i++ )\n        {\n            for (int j = -range; j <= range; j++ )        \n            {\n                if ( i*i + j*j > range*range && kernelShape ==0)\n                    continue;\n                    \n                if ( abs(i)> abs(j)  && kernelShape <=2 && kernelShape > 0)\n                    continue;   \n                    \n                ivec2 tvc = (vc/2+ivec2(i,j));\n\n                \n                vec4 data = texelFetch( iChannel1, tvc+foffset,0);\n                vec4 mask =vec4(1);\n                int ix = (vc.x)%2;\n                int iy = (vc.y)%2;\n                \n                if ( ix == 0 )\n                {\n                    if ( i == range )\n                        mask *= vec4(0);\n                    if ( i == -range )\n                        mask *= vec4(0,1,0,1);                         \n                }\n                else\n                {\n                    if ( i == -range )\n                        mask *= vec4(0);\n                    if ( i == range )\n                        mask *= vec4(1,0,1,0);                                \n                }  \n                    \n                if (iy == 0 )\n                {\n                    if ( j == range )\n                        mask *= vec4(0);\n                    if ( j == -range )\n                        mask *= vec4(0,0,1,1);\n                }\n                else\n                {\n                    if ( j == -range )\n                        mask *= vec4(0);\n                    if ( j == range )\n                        mask *= vec4(1,1,0,0);                    \n                }  \n                \n                \n                total +=int(dot(mask, data));\n            }\n        }        \n                \n        \n        \n        int pp = range;\n        int m = pp/(frame/ppFrameDivid+1)%ppFrameMod;\n        if (m < 8)\n            m = 8;\n            \n        // where the magic happens\n        if ( fragColor.x <= 0.5 && (total <= m) && (total >0) && ((total % pp) < m))\n            fragColor = vec4(1,iTime,frame,1);\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define FREE_CAMERA_MOVE 0\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x , uint seed)\n{\n    x += uvec3(seed);\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 random(int row,int col, float seed)\n{\n    return hash( uvec3(row, col, col), uint(seed));\n}\n\nint randomRange( int _min , int _max, int row, int col, float seed )\n{\n    return int(random( row, col, seed) *float(_max-_min))+_min;\n}\n\nint randomRange2( int _min , int _max, int row, int col, float seed )\n{\n    vec3 r = random( row, col, seed) ;\n    r *= r;\n    return int(r*float(_max-_min))+_min;\n}\n\n\n\nfloat randomRange( float _min , float _max, int row, int col, float seed )\n{\n    return random( row, col, seed).x *(_max-_min)+_min;\n}\n\n\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) \n        return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\nvec4 getMipRect( vec2 res , float lod)\n{\n   vec2 size = res.xy * pow(2.,-lod)*0.5;\n   vec2 maxPos = res.xy * (2. - pow(2.,-lod))*0.5;\n   vec2 minPos = maxPos - size;\n   maxPos.y = size.y;\n   minPos.y = 0.;\n   return vec4(minPos, maxPos);\n}\n\n\nvec2 getMipUV( vec2 uv )\n{\n     float lod = floor(abs(log2(1.-uv.x)));\n     vec4 rect = getMipRect(vec2(1.,1.), lod);\n     vec2 size = vec2(pow(2.,-lod)*0.5);\n     return (uv - rect.xy)/size;\n  \n}\n\n\nvec3 getCameraPositionFromBufferA(sampler2D bufferA)\n{\n \treturn texture(bufferA, vec2(0.0, 0.0)).xyz;\n}\n\nmat3 getCameraRotationFromBufferA(sampler2D bufferA, vec2 resolution)\n{\n \t\n    vec2 cameraAngle = texture(bufferA, vec2(1.2, 0.0) / resolution.xy).xy;\n    \n    mat3 cameraRotation = mat3(cos(cameraAngle.x), 0.0, -sin(cameraAngle.x),\n                                0.0, 1.0, 0.0,\n                                sin(cameraAngle.x), 0.0, cos(cameraAngle.x)) *\n        \t\t\t\t  mat3(1.0, 0.0, 0.0,\n                                  0.0, cos(cameraAngle.y), -sin(cameraAngle.y),\n                                  0.0, sin(cameraAngle.y), cos(cameraAngle.y));\n    \n    return cameraRotation;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//todo: pack 24*4 columns into 1 pixel to reduce sampling\n//due to the inconstistency of float<->bits storage on some platform I'm not storing 128 bits per pixel\n//and use buffer's upper right corner to store states such as camera pos, random seeds\n\nfloat sampleField( ivec2 f )\n{\n    \n    return texelFetch(iChannel0, f,0 ).x ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 uv = ivec2(fragCoord);\n    int width = int(iResolution.x);\n    \n\n    if ( uv.x == width-2 && uv.y == 0 )\n    {\n        fragColor = texelFetch(iChannel1, uv,0);\n        if ( fragColor.x != iResolution.x || fragColor.y != iResolution.y || texelFetch(iChannel2,ivec2(32,0),0).x > 0. )\n            fragColor.z = float(iFrame);\n\n        fragColor.xy = iResolution.xy;\n        return;\n    }\n    \n    if ( uv.x == width-1 && uv.y == 0 )\n    {\n        vec4 state1 = texelFetch(iChannel1, ivec2(width-2,0),0);//xy: resolution, z:base frame Num.    \n        fragColor = texelFetch(iChannel1, ivec2(width-1,0),0);\n        int frame = (iFrame-int(state1.z));\n        if ( frame % 200 == 0 )\n            fragColor.y =  iDate.w*100.+iTime;\n        if ( frame % 50 == 0 )\n            fragColor.x = hash(uvec3(fragColor.y ), uint(frame) ).x*32768.;\n\n            \n        fragColor.z =  hash(uvec3(fragColor.y ), uint(frame) ).y*32768.;\n        \n        if ( iFrame % 25 == 0 )\n            fragColor.w = hash(uvec3(fragColor.y ), uint(frame) ).z*32768.;            \n\n        return;\n    }\n\n\n    ivec2 f = ivec2(fragCoord) *2;\n    \n    \n    float a = sampleField( f );\n    float b = sampleField( f+ivec2(1,0) );\n    float c = sampleField( f+ivec2(0,1) );\n    float d = sampleField( f+ivec2(1,1) );\n    \n    fragColor = vec4(a,b,c,d);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//render 2d patterns into 3d scene\n#define CAMERA_INITAL_DIST (mix(300.,iResolution.x*1.2, mousePos.y))\n#define MAX_TRACE 512\n//could be very slow\n#define TRANSPARENT_ITERS 1\n\n// Set AA to 1 if your machine is too slow\n#if HW_PERFORMANCE==1\n#define AA 2\n#else\n#define AA 1  \n#endif\nconst float maxHeight = 25.;\nconst float materialDensity = 1.0;\n\nfloat getScale()\n{\n    return iResolution.y;\n}\n\nfloat easeOutBounce(float x)\n{\n    const float n1 = 7.5625;\n    const float d1 = 2.75;\n    if ( x > 1.)\n    return 1.;\n\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec4 HeightField( vec2 X )\n{\n    float aspect = iResolution.x/iResolution.y;\n    X /=vec2(getScale()*aspect,getScale() );\n    X += .5; \n    vec4 v = texture(iChannel0, X);\n    \n    float targetHeight = (sin(v.z*0.41)+1.)/2.;\n    targetHeight *= targetHeight ;\n    \n    float height =  2.+(maxHeight-4.)* mix(0., targetHeight,easeOutBounce((iTime-v.y)));\n    height = floor(height);\n    v.x *= height;\n    return v;\n}\n\nstruct HitInfo\n{\n    vec2 t;\n    vec3 pos;\n    vec3 n;\n    vec3 pos2;\n    vec3 n2;\n    vec4 fieldValue;\n    float smoothness;\n    bool hit;\n};\n\nHitInfo Intersect( vec3 cam ,vec3 rayDir, vec2 pixel )\n{\n    HitInfo ret;\n    ret.hit = false;\n\n    float voxelSize = getScale()/iResolution.y;\n    vec4 fieldValue = HeightField(pixel);\n    float h = max(0.0001,fieldValue.x);\n    vec2 center = (floor(pixel/voxelSize)+0.5 )*voxelSize;\n    vec3 aabb = vec3(voxelSize*0.5, h, voxelSize*.5 );\n    \n    vec2 t = boxIntersection(cam-vec3(center.x, 0., center.y), rayDir, aabb, ret.n);\n    if ( t.y > t.x )\n    {\n        ret.pos = cam+rayDir * t.x;\n        ret.pos2 = cam+rayDir*t.y;\n        ret.t = t;\n        ret.n2 = ret.n;\n        ret.fieldValue = fieldValue;\n        ret.hit = true;\n    }\n    \n    return ret;\n}\n\nvec4 getAABB( vec3 worldPos, int level)\n{\n    return vec4(0.);\n}\n\nbool March( vec3 start, vec3 end, out vec3 pos, out vec3 n, out vec3 pos2, out vec3 n2, out vec4 fieldValue )\n{\n    float voxelSize = getScale()/iResolution.y;\n    vec2 p0 = start.xz;\n    vec2 p1 = end.xz;\n    vec3 rayDir = normalize(end-start);\n    vec2 rd = p1-p0;\n    vec2 p = floor(p0);\n    vec2 rdinv = 1.0 / rd;\n    vec2 stp = sign(rd);\n\tvec2 delta = min(rdinv * stp, 1.0);\n    \n    // start at intersection of ray with initial cell\n    vec2 t_max = abs((p + max(stp, vec2(0.0)) - p0) * rdinv);\n    \n    for (int i = 0; i < MAX_TRACE; ++i) \n    {         \n        HitInfo hitInfo = Intersect(start ,rayDir, p);\n        if (hitInfo.hit)\n        {\n            pos = hitInfo.pos;\n            n = hitInfo.n;\n            pos2 = hitInfo.pos2;\n            n2  = hitInfo.n2;\n            fieldValue = hitInfo.fieldValue;\n            return true;\n        }\n        float next_t = min(t_max.x,t_max.y);\n        if (next_t > 1.0) \n            return false;\n                \n        vec2 cmp = step(t_max.xy, t_max.yx);\n        t_max += delta * cmp;\n        p += stp * cmp;\n        \n    }    \n   \n     return false;\n}\n\nvec3 getColor(vec3 n, vec3 pos, vec4 fieldValue)\n{\n     float h = fieldValue.x;\n    int width = int(iResolution.x);\n    int p =  int( mod(texelFetch(iChannel2, ivec2(width-1,0),0).y,4.) );\n    if ( fieldValue.x <= 0.)\n        return vec3(0.114,0.114,0.184);\n    float a = fieldValue.z*2.718238271823*10.;\n    \n    vec3 c =  pal( a, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) )*fieldValue.a;\n\n     if (p == 1)\n            c =pal( a, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) )*fieldValue.a;\n    if (p == 2)\n            c = pal( a, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.2,1.0,1.5),vec3(0.671,0.678,0.000) )*fieldValue.a;\n    if (p == 3)\n            c =pal( a, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )*fieldValue.a;\n     \n        return c*0.9;\n}\n\nvec2 getShiness(vec4 fieldValue)\n{\n    if ( fieldValue.x <= 0.)\n        return vec2(5,0.2);\n       \n    return vec2(20,.9);\n}\n\nfloat getDensity(float def, vec4 fieldValue)\n{\n    if ( fieldValue.x <= 0.)\n        return 8000.;\n    return def;\n}\n\n\n/////////////////////\n//\n////////////////////\nvec3 MarchLight( float density, vec3 start, vec3 end, vec3 surfaceN, out vec3 firstN)\n{    \n    float voxelSize = getScale()/iResolution.y;\n    vec2 p0 = start.xz;\n    vec2 p1 = end.xz;\n    vec3 rayDir = normalize(end-start);\n    vec2 rd = p1-p0;\n    vec2 p = floor(p0);\n    vec2 rdinv = 1.0 / rd;\n    vec2 stp = sign(rd);\n\tvec2 delta = min(rdinv * stp, 1.0);\n    \n    vec3 opticalDepth = vec3(0);\n \n    \n    // start at intersection of ray with initial cell\n    vec2 t_max = abs((p + max(stp, vec2(0.0)) - p0) * rdinv);\n    vec3 pos;\n    vec3 n;\n    vec3 pos2;\n    vec3 n2;\n    bool firstHit = false;\n\n    for (int i = 0; i < MAX_TRACE; ++i) \n    {   \n        HitInfo hitInfo = Intersect(start ,rayDir, p);\n        if (hitInfo.hit)\n        {\n            if (!firstHit)\n            {\n                firstN = n;\n                firstHit = true;\n            }\n            float far = min( hitInfo.t.y, length(end-start));\n            float travelDepth = max(0.,(far-hitInfo.t.x));\n\n            opticalDepth += vec3(travelDepth*getDensity(density,hitInfo.fieldValue)*(1.-getColor(surfaceN,end,hitInfo.fieldValue)));\n\n            if (far < hitInfo.t.y || (opticalDepth.x >30.0 && opticalDepth.x >30.0 && opticalDepth.x >30.0))\n            {\n                break;\n            }\n        }\n        vec2 cmp = step(t_max.xy, t_max.yx);\n        t_max += delta * cmp;\n        p += stp * cmp;\n    }       \n    return opticalDepth;\n\n\n}\n\n\nmat3x3 LookAt( vec3 src, vec3 target, vec3 up)\n{\n    vec3 forward = normalize(target-src);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3x3(right, -up, forward);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec4 totalColor = vec4(0);\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 txtUV = uv;\n\n\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    \n    vec3 cam = vec3(4., 4., 4.);\n    float near = 0.1;\n    float fov = 60.0;\n \n    float w = 2.* near / sqrt(3.);\n    float h = 1./aspect * w;\n\n    vec3 vrb = vec3(-w / 2., -h / 2., near);\n    vec3 vlt = vec3(w / 2., h / 2., near);\n    \n\n    float theta = mix(-2.14, -1.0, mousePos.x);//.x);\n    float phi = mix(1.01, 0.5, mousePos.y);\n    cam = vec3(cos(theta) * sin(phi),\n           cos(phi),\n            sin(theta) * sin(phi)) * CAMERA_INITAL_DIST;\n      \n    vec3 camLookAt = vec3(0,0,0);\n    #if FREE_CAMERA_MOVE\n    cam = getCameraPositionFromBufferA( iChannel3);\n    mat3 camRot = getCameraRotationFromBufferA( iChannel3, iResolution.xy);\n    #endif\n    uv = fragCoord / iResolution.xy;\n    vec3 lightPos = vec3(3300,2000.,3000);\n    vec3 totalPos = vec3(0);\n    for ( int aai = 0; aai < AA; aai++ )\n    for ( int aaj = 0; aaj < AA; aaj++ )\n    {\n\n        float ox = 1./iResolution.x/float(AA)*float(aai);\n        float oy= 1./iResolution.y/float(AA)*float(aaj);\n        vec3 rayDir = vec3(mix(vlt.x, vrb.x, uv.x+ox), mix(vlt.y, vrb.y, uv.y+oy), near);\n\n\n        mat3x3 rot = LookAt(cam,camLookAt, vec3(0., 1., 0.));\n        \n        #if FREE_CAMERA_MOVE\n        rayDir = normalize(camRot * rayDir);            \n        #else\n        rayDir = normalize(rot * rayDir);\n        #endif\n\n        vec3 hit;\n        vec3 n;\n\n        vec3 pos;\n        bool hitBox = false;\n        vec2 t = boxIntersection(cam-vec3(0.,maxHeight/2.,0.), rayDir, vec3(getScale()*0.5*aspect,maxHeight/2.,getScale()*0.5), n);\n        if ( t.y < t.x )\n        {\n            fragColor = vec4(0);\n           // return;\n        }\n\n\n\n        vec3 boxPos = cam + rayDir * t.x;\n        float fogDepth = t.x;\n        pos = boxPos;\n        //fragColor.xyz = boxPos;\n\n        vec4 fieldValue;\n        float transpareness = 1.;\n        \n        for ( int lt = 0; lt<TRANSPARENT_ITERS; lt++ )\n        {\n            vec3 pos2;\n            vec3 n2;\n            \n            vec3 marchedColor;\n            \n            if (March(pos, cam+rayDir*t.y, pos, n, pos2, n2,fieldValue)) \n            {\n                \n                vec3 fragN = n;\n                vec3 fragPos = pos;\n                totalPos += pos;\n                vec3 lightDir = normalize(pos - lightPos);//normalize(cross(cam, vec3(0,1,0)));\n                vec3 hv = normalize(-lightDir - rayDir );\n                float ndh = max(0.,dot( n, hv));\n                vec2 shiness = getShiness(fieldValue);                \n                float specular = pow(ndh,shiness.x)*1.35;\n                vec3 subSurface = vec3(0);\n                //multile sample sss is very slow\n                //int sssamples = 10;\n                //float w = 2.;\n\n                \n                t = boxIntersection(lightPos-vec3(0,maxHeight/2.,0), lightDir, vec3(getScale()*0.5*aspect,maxHeight/2.,getScale()*0.5), n);\n                if (t.x > 0. )\n                {\n                    //fragColor = vec4(1,0,0,1);\n                    \n                    boxPos = lightPos + lightDir * t.x;\n                    pos = boxPos;    \n                    vec3 offset = vec3(0);//w*tn*float(sssx)+w*bn*float(sssy);\n                    vec3 hitN;\n                    vec3 scattered = MarchLight(materialDensity,pos+offset,fragPos+lightDir*.5,fragN, hitN );\n                    subSurface +=exp(-scattered)*1.;\n                    //(dot(-lightDir,hitN))*2\n\n                }\n     \n                \n                float nol = max(0.,(dot(lightDir, fragN)));\n                //subSurface = subSurface/float((sssamples+1)*(sssamples+1));\n                //\n                marchedColor.xyz =  0.85*subSurface;\n                vec2 grid1 = abs(fract(fragPos.xz*.5)-0.5)*2.;\n                float grid = max(grid1.x, grid1.y);\n                grid = smoothstep(.3,0.5,grid);\n\n                marchedColor.xyz = mix(marchedColor.xyz,marchedColor.xyz*0.75,(1.-grid)*step(0.9,fragN.y));\n                marchedColor.xyz += vec3(max(0.,dot(-lightDir, fragN)))*\n                dot(subSurface,vec3(.22,.66,.11))*specular*shiness.y ;\n\n            }\n            else\n            {\n                 marchedColor.xyz = mix(vec3(0.000,0.000,0.000),vec3(0.114,0.114,0.106), 1.+dot(rayDir, normalize(lightPos))/2.);\n                 \n            }    \n            pos = pos2;\n            \n            \n            totalColor.xyz += mix(totalColor.xyz,marchedColor,transpareness);\n            \n            transpareness *= exp(-(t.y-t.x)*0.0016);\n        }\n    }\n     \n    fragColor = totalColor/float(AA*AA*TRANSPARENT_ITERS*TRANSPARENT_ITERS); \n    \n    fragColor.a = 1.;//distance(cam,totalPos/4.);\n   \n    \n\n       //fragColor.xyz = ACESFilm(fragColor.xyz);\n    \n   // fragColor = sin(texture(iChannel0, uv));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_G 71\n#define KEY_SHIFT 16\n\n#define GET_KEY(k) (texture(iChannel0, vec2(float(k) / 256.0, 0.1) ).x)\n#define GET_TOGGLE(k) (texture(iChannel0, vec2(float(k) / 256.0, 0.9) ).x)\n#define PI 3.1419\n\n#define MOVE_SPEED 20.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 1) //Camera start position and rotation\n    {\n     \tif (fragCoord.x <= 2.0)\n        {\n            if (fragCoord.x < 1.0)\n            {\n\t\t\t\tfragColor = vec4(100,100,1, 0.0);\n            }\n            else fragColor = vec4(0.0);\n        }\n    }\n    else if (fragCoord.y < 1.0 && fragCoord.x <= 2.0)\n    {\n        vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n        \n        if (iMouse.x < 1.0 && iMouse.y < 1.0) mousePos = vec2(0.0); \n\n        float yaw = mousePos.x * PI * 2.0+PI;\n        float pitch = -mousePos.y*0.5 * PI+PI;\n\n        //Same matrix construction as in common tab\n        mat3 cameraRotation = mat3(cos(yaw), 0.0, -sin(yaw),\n                                0.0, 1.0, 0.0,\n                                sin(yaw), 0.0, cos(yaw)) *\n            \t\t\t\tmat3(1.0, 0.0, 0.0,\n                                  0.0, cos(pitch), -sin(pitch),\n                                  0.0, sin(pitch), cos(pitch));\n                            \n\n        vec3 forward = cameraRotation * vec3(0, 0, 1);\n        vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n        vec3 up = normalize(cross(forward, right));\n\n        float keyW = GET_KEY(KEY_W);\n        float keyA = GET_KEY(KEY_A);\n        float keyS = GET_KEY(KEY_S);\n        float keyD = GET_KEY(KEY_D);\n        float keyQ = GET_KEY(KEY_Q);\n        float keyE = GET_KEY(KEY_E);\n        float toggleG = GET_TOGGLE(KEY_G);\n        float keyShift = GET_KEY(KEY_SHIFT);\n        \n        if (fragCoord.x < 1.0)\n        {\n            float speedBoost = (1.0 + keyShift * 3.0);\n            vec3 cameraPos = texture(iChannel1, vec2(0.0, 0.0)).xyz;\n            cameraPos += forward * (keyW - keyS) * iTimeDelta * MOVE_SPEED * speedBoost;\n            cameraPos += right * (keyD - keyA) * iTimeDelta * MOVE_SPEED * speedBoost;\n            cameraPos += up * (keyE - keyQ) * iTimeDelta * MOVE_SPEED * speedBoost;\n            fragColor = vec4(cameraPos, toggleG);\n        }\n        else\n        {\n            vec2 cameraRotation = vec2(yaw, pitch);\n            fragColor = vec4(cameraRotation, 0.0, 0.0);\n        }\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}