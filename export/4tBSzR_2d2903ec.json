{"ver":"0.1","info":{"id":"4tBSzR","date":"1440825984","viewed":196,"name":"Spheres_fbm","username":"felipevsfbr","description":"Trying to learn ray tracing :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracingspheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define pixProj(p) sqrt(dot(dFdx(p),dFdx(p)) + dot(dFdy(p),dFdy(p)))\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Material\n{\n\tvec3 ambient;\n\tvec3 diffuse;\n\tvec3 specular;\n\tfloat shin;\n};\n\nstruct Esfera\n{\n\tvec3 center;\n\tfloat r;\n\tint id;\n\tMaterial m;\n};\n\nstruct Plane\n{\n\tvec3 p0;\n\tvec3 n;\n\tint id;\n\tMaterial m;\n};\n\nstruct Light\n{\n\tvec3 position;\n\tvec3 diffuse;\n\tvec3 specular;\n\tfloat cntAt, linAt, quaAt;\n};\n\nstruct HitInfo\n{\n\tvec3 hitPos;\n\tvec3 hitNrm;\n\tfloat dist;\n\tint obj;\n\tMaterial m;\n};\n\nMaterial mb = Material(\n\tvec3(0.0), \n\tvec3(0.0), \n\tvec3(0.0), \n\t0.);\n\nMaterial mee = Material(\n\tvec3(0.2), vec3(0.9,0.3, 0.1),\n\tvec3(0.9), 120.);\n\nMaterial me = Material(\n\tvec3(0.2, 0.2, 0.2),\n\tvec3(0.3, 0.8,0.3),\n\tvec3(0.9, 0.9, 0.9),\n\t120.);\n\nMaterial mp = Material(\n\tvec3(0.5, 1., 1),\n\tvec3(1, 1,1),\n\tvec3(0.0),\n\t0.);\n\nEsfera es[2];\n\nPlane P = Plane(\n\tvec3(0.0, -3.0,0.0),\n\tvec3(0.0, 1.0, 0.0),\n\t1, Material(\n\tvec3(0.5, 1., 1),\n\tvec3(1, 1,1),\n\tvec3(0.0),\n\t0.));\n\nLight L = Light(\n\tvec3(30.0, 90.0, 50.0),\n\tvec3(1.0, 1.0, 1.0),\n\tvec3(1.0, 1.0, 1.0),\n\t0.,1.,0.03);\nRay getRays(Ray R, HitInfo hit, out Ray refracted, out bool internalRefl);\nbool ray_esfera(Ray R, Esfera E, out HitInfo hit);\nbool ray_plane(Ray R, Plane P, out HitInfo hit);\nvec3 local(HitInfo hit, Light L, Material m);\nbool intersect(Ray R, out HitInfo Info);\nbool shadow(HitInfo Info, Light L);\nfloat fbm(vec3 p);\nvec3 trace(Ray R);\n\n\nvec3 trace(Ray R)\n{\n    vec3 resolution = iResolution;\n\tvec3 col = vec3(0.);\n\tHitInfo info = HitInfo(vec3(0.0), vec3(0.0), 1000.0, -1, mb);\n\tHitInfo refl2, refr;\n\tRay temp = R, refracted;\n\tbool c;\n\tif(intersect(temp, info))\n\t\t\tcol = local(info, L, info.m);\n\tif(info.obj != -1)\n\t{\n\t\tcol += -0.5 + smoothstep(.3, .6, fbm(info.hitPos));\t\n\t\tRay refl = getRays(temp, info, refracted, c);\n\t\tif(intersect(refl, info))\n\t\t\tcol += 0.1*local(info, L, info.m);\n\t\ttemp = refl;\n\t}\n\telse\n\t{\n\t\tvec2 p = gl_FragCoord.xy/resolution.xy;\n\t\tcol = vec3(0.0, 0.0, .4);\n\t\tcol += fbm(vec3(gl_FragCoord.xy/resolution.xy, 1.0))\n\t\t\t     + 0.4*fbm(vec3(gl_FragCoord.yx/resolution.xy, 0.0));\n\t\tfloat dist = 0.1*distance(p, vec2(0.0));\n\t\tcol *= exp(-dist*sin(iTime));\n\t}\t\n\treturn col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 resolution = iResolution;\n\tvec2 uv = gl_FragCoord.xy/resolution.xy;\n\tuv = 2.0*uv - 1.0;\n\tuv.x *= resolution.x/resolution.y;\n\tvec2 m = iMouse.xy/resolution.xy;\n    m = 2.0*m - 1.0;\n    m.x *= resolution.x/resolution.y;\n\tes[0] = Esfera(\n\tvec3(3.0, -1.0, 0.0),\n\t2.0, 0, mee);\n\n\tes[1] = Esfera(\n\tvec3(-3.0, -1.0, -5.0),\n\t2.0, 0, me);\n\t\n\tvec3 at = vec3(0.0);\n\tvec3 eye = vec3(6.*2.*sin(0.5*iTime), 5, 10);\n\tvec3 look = normalize(at - eye);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 ww = cross(look, up);\n\tvec3 vv = cross(ww, look);\n\tvec3 dx = tan(radians(30.0))*ww;\n\tvec3 dy = tan(radians(30.0))*vv;\n    eye.xy *= abs(m.xy);\n\tRay R = Ray(eye, normalize(look + dx*uv.x + dy*uv.y));\n\tvec3 col = trace(R);\n\tfragColor = vec4(col, 1.0);\n\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0, s = .5, t= 0.;\n\n    f += s*noise( p ); t+=s; p = m*p*2.02; s*= .5; if(pixProj(p)> 1.) return f/t;\n    f += s*noise( p ); t+=s; p = m*p*2.03; s*= .5; if(pixProj(p)> 1.) return f/t;\n    f += s*noise( p ); t+=s; p = m*p*2.01; s*= .5; if(pixProj(p)> 1.) return f/t;\n    f += s*noise( p ); t+= s;\n\n    return f/t;\n}\n\nbool shadow(HitInfo Info, Light L)\n{\n\tvec3 lightv = normalize(L.position - Info.hitPos); \n\tRay sh = Ray(Info.hitPos, lightv);\n\tHitInfo hit = HitInfo(vec3(0.0), vec3(0.0), 1000.0, -1, mb);\n\tif(intersect(sh, hit))\n\t{\n\t\tfloat distToLight = distance(Info.hitPos, L.position);\n\t\tfloat distToObj = distance(Info.hitPos, hit.hitPos);\n\t\tif(distToLight > distToObj)\n\t\t\treturn true;\t\n\t}\n\treturn false;\n}\n\nRay getRays(Ray R, HitInfo hit, out Ray refracted, out bool internalRefl)\n{\n\tRay reflected;\n\tvec3 dir = reflect(R.direction, hit.hitNrm);\n\treflected = Ray(hit.hitPos, normalize(dir));\n\tvec3 nl = hit.hitNrm;\n\tfloat nls = dot(hit.hitNrm, R.direction);\n\tif(nls > 0.0) nl *= -1.;\n\tfloat nc = 1.0, nt = 1.5;\n\tfloat eta = nt/nc;\n\tbool into = dot(nl, hit.hitNrm) > 0.;\n\tfloat ddn = dot(R.direction, nl);\n\tif(into)\n\t\teta = nc/nt;\n\tfloat c2 = 1.0 - eta*eta*(1.0 - ddn*ddn);\n\tif(c2 < 0.0)\n\t{\n\t\tinternalRefl = true;\n\t\trefracted = Ray(vec3(0.0), vec3(0.0));\n\t}\n\telse\n\t{\n\t\tinternalRefl = false;\n\t\trefracted = Ray(hit.hitPos, normalize(refract(R.direction, hit.hitNrm, eta)));\n\t}\n\treturn reflected;\n}\n\nbool intersect(Ray R, out HitInfo Info)\n{\n\tHitInfo hit = HitInfo(vec3(0.0), vec3(0.0), 10000.0, -1, mb);\n\tHitInfo hitz;\n\tfor(int i = 0; i < 2; i++)\n\t\tif(ray_esfera(R ,es[i], hitz))\n            if(hitz.dist < hit.dist)\n\t\t\t\thit = hitz;\n\tif(ray_plane(R, P, hitz))\n\t\tif(hitz.dist < hit.dist)\n\t\t\thit = hitz;\n\tInfo = hit;\n\tif(hit.obj != -1)\n\t\treturn true;\n\treturn false;\n}\n\nvec3 getTexture(HitInfo hitInfo)\n{\n\tfloat size = 2.0;\n\tvec3 p = hitInfo.hitPos/size;\n    p = vec3(sin(3.14*hitInfo.hitPos/size));\n    float s = pixProj(p);\n    return vec3(0.3)*smoothstep(-s,s,p.x*p.y*p.z);\n}\n\nvec3 local(HitInfo hit, Light L, Material m)\n{\n\tvec3 col = vec3(0.0);\n\tvec3 lightv = L.position - hit.hitPos;\n\tfloat dist = length(lightv);\n\tlightv = normalize(lightv);\n\tfloat attenuation = 900.0/(L.cntAt + L.linAt*dist + L.quaAt*dist*dist);\n\tvec3 amb = attenuation*m.diffuse*m.ambient;\n\tvec3 dif = attenuation*m.diffuse*L.diffuse*dot(lightv, hit.hitNrm);\t\n\tfloat s = dot(lightv, hit.hitNrm);\n\tvec3 spec = vec3(0.0);\n\tif(s > 0.0)\n\t\tspec = pow(max(0.0, s), m.shin)*m.specular*L.specular;\n\tcol = amb + dif + spec;\n\tif(shadow(hit, L))\n\t\tcol = vec3(0.);\n\tif(hit.obj == 1)\n\t\tcol *= getTexture(hit);\n\treturn col;\n}\n\nbool ray_esfera(Ray R, Esfera E, out HitInfo hit)\n{\n\tvec3 or = R.origin - E.center;\n\tvec3 dir = R.direction;\n\tfloat a = dot(dir, dir);\n\tfloat b = 2.0*dot(or, dir);\n\tfloat c = dot(or, or) - E.r*E.r;\n\tfloat delt = b*b - 4.*a*c;\n\tif(delt > 0.0)\n\t{\n\t\tfloat t0 = -b -sqrt(delt);\n\t\tfloat t1 = -b +sqrt(delt);\n\t\tfloat t = min(max(0.0, t0), max(0.0, t1));\n\t\tt /= 2.0*a;\n\t\tif(t > 0.001)\n\t\t{\n\t\t\thit.hitPos = R.origin + t*R.direction;\n\t\t\thit.hitNrm = normalize(hit.hitPos - E.center);\n\t\t\thit.obj = E.id;\n\t\t\thit.dist = t;\n\t\t\thit.m = E.m;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool ray_plane(Ray R, Plane P, out HitInfo hit)\n{\n\tfloat t = dot(P.p0 - R.origin, P.n)/dot(R.direction, P.n);\n\tif(t > 0.001 && t < 70.0)\n\t{\n\t\thit.hitPos = R.origin + t*R.direction;\n\t\thit.hitNrm = P.n;\n\t\thit.dist = t;\n\t\thit.obj = P.id;\n\t\thit.m = P.m;\n\t\treturn true;\n\t}\n\treturn false;\n}","name":"Image","description":"","type":"image"}]}