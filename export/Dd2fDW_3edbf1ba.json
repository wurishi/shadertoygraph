{"ver":"0.1","info":{"id":"Dd2fDW","date":"1689734717","viewed":108,"name":"Follow You Slot with Cloud","username":"kirickiri","description":"Forked from https://www.shadertoy.com/view/WsVcRt from Khrebtov_M \nchanged a bit on the interaction","likes":2,"published":1,"flags":34,"usePreview":0,"tags":["tracing","webcam","motion","movement"],"hasliked":0,"parentid":"Dd2fzw","parentname":"Follow You Slot"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this shader traces moving objects. Check buffers for more info\nconst float PI = 3.14159265;\n\nconst float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n\t\n    \n    \n    \n\n    //float time = iTime *0.05;\n\n    float color1, color2, color;\n\n\tcolor1 = (sin(dot(fragCoord.xy,vec2(sin(time*3.0),cos(time*3.0)))*0.02+time*3.0)+1.0)/2.0;\n\n\tvec2 center = vec2(640.0/2.0, 360.0/2.0) + vec2(640.0/2.0*sin(-time*3.0),360.0/2.0*cos(-time*3.0));\n\n\tcolor2 = (cos(length(fragCoord.xy - center)*0.03)+1.0)/2.0;\n\n\tcolor = (color1+ color2)/2.0;\n\n\tfloat red\t= (cos(PI*color/0.5+time*3.0)+1.0)/2.0;\n\tfloat green\t= (sin(PI*color/0.5+time*3.0)+1.0)/2.0;\n\tfloat blue\t= (sin(+time*3.0)+1.0)/2.0;\n\n\n\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n    p.x = 1.0-p.x;//uv.x=1.-uv.x;//(invert)\n\tvec2 pos = textureLod(iChannel1,vec2(0.0),0.0).xy;\n\tfragColor=(textureLod(iChannel0,p,0.0).xxxw+texture(iChannel2,p))*0.01;\n\tif(distance(p.x,pos.x)<0.15 ||distance(p.x,pos.x)<0.075 )   fragColor +=vec4(texture(iChannel3,p).rgb, 1.0);\n\tif((distance(p.x,pos.x)<0.15 ||distance(p.x,pos.x)<0.075))   fragColor +=vec4(result, 0.85);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Buffer b stores camera image from the previous frame, and this buffer outputs \ndifference between previous frame and current frame, so,for pixels that moved\nthe output pixel is bright*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\n\nfragColor = textureLod( iChannel0, uv,1.0 )-textureLod( iChannel1, uv,1.0);    \n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Thit is the buffer that stores current image from the camera\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n\n    fragColor = texture( iChannel1, uv);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n/*this buffer is used to calculate the center of pixels from \nbuffer A  that are  bright enough  (those are the pixels that moved)\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //we want pixel(0;0) to output position of the center of bright pixels\n    \n    if( fragCoord.x>0.5) return;\n    if( fragCoord.y>0.5) return;\n    \n  /*we will calculate the sum of bright pixels'coordinates \n  and then divide it by the number of these pixels*/\n    \n    vec2 sum=vec2(0.0);\n    float g=0.0;\n    float threshold = 0.15;\n    for(float i=0.0;i<1.0;i+=0.01) for(float j=0.0;j<1.0;j+=0.01)\n \t    {\n            vec3 diff = textureLod(iChannel0,vec2(i,j)  ,3.0).xyz;\n            if(diff.r >= threshold || diff.g >= threshold || diff.b >= threshold)\n            {\n\t\t\t\tsum+=vec2(i,j);\n \t  \t        g++;\n \t        }\n  \t     \n\t   }\n    float  td= iTimeDelta;\n    \n    /*camera is not  a precise tool for tracking movement, so, if we just output\n     calculated center, it will be jittery. Instead, we can move cursor towards\n    the calculated center buy calculating the difference between this position\n   and previous position, and multiply this difference by some constant value*/\n\n\tvec4 te =texture(iChannel1,vec2(0.0,0.0));//xy-current coordinates;zw-desired coordinates;\n    vec2 delta = te.zw-te.xy;\n\tif(g<15.0) fragColor = te+vec4(3.0*delta*td,0.0,0.0);\n    else\n    {\n        te.zw =sum/g;\n    \tdelta = te.zw-te.xy;\n     \tfragColor =  te+vec4(3.0*delta*td,0.0,0.0);\n    }\n   \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//this buffer if for the line that cursor traces \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor=.97*texture(iChannel0,uv);\n   \n    vec2 pos = textureLod(iChannel1,vec2(0.0),0.0).xy;\n    if(distance(uv,pos)<0.2)   fragColor =vec4(1.);\n    \n    \n\n}","name":"Buffer C","description":"","type":"buffer"}]}