{"ver":"0.1","info":{"id":"lcySRG","date":"1715328681","viewed":135,"name":"SimplePBR","username":"YuryStrelkov","description":"Simple PBR lighting.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ----------------------------------------------------------------------------\n// Point light position change using mouse\n// ----------------------------------------------------------------------------\nvoid updateLightPosition(inout PointLight light)\n{\n\tlight.position = vec3(iMouse.xy, 0.0);\n}\n\n// ----------------------------------------------------------------------------\n// Depth\n// ----------------------------------------------------------------------------\nfloat sampleDepth(vec2 coords)\n{\n\tif(DEPTH_REVERSED)\n\t\treturn texture(DEPTH_TEXTURE, coords).x * DEPTH_SCALE;\n\treturn DEPTH_SCALE - texture(DEPTH_TEXTURE, coords).x * DEPTH_SCALE;\n}\n\n// ----------------------------------------------------------------------------\n// Normal\n// ----------------------------------------------------------------------------\nvec3 sampleNormalFromDepth(in vec2 fragCoord)\n{\n\tvec2 texelSize = vec2(1.0f / iResolution.y);\n\tvec3 a = vec3(fragCoord.x - texelSize.x, 0.0f, sampleDepth(vec2(fragCoord.x - texelSize.x, fragCoord.y)) * NORMAL_STRENGTH);\n    vec3 b = vec3(fragCoord.x + texelSize.x, 0.0f, sampleDepth(vec2(fragCoord.x + texelSize.x, fragCoord.y)) * NORMAL_STRENGTH);\n    vec3 c = vec3(0.0f, fragCoord.y + texelSize.y, sampleDepth(vec2(fragCoord.x, fragCoord.y + texelSize.y)) * NORMAL_STRENGTH);\n    vec3 d = vec3(0.0f, fragCoord.y - texelSize.y, sampleDepth(vec2(fragCoord.x, fragCoord.y - texelSize.y)) * NORMAL_STRENGTH);\n    return normalize(cross(b - a, c - d));\n}\n\n// ----------------------------------------------------------------------------\n// SSAO\n// ----------------------------------------------------------------------------\nfloat screenSpaceAmbientOcclusion(in vec2 fragCoord)\n{\n\t// https://learnopengl.com/Advanced-Lighting/SSAO\n    vec2 fragUv    = UV(fragCoord);\n    vec3 normal    = sampleNormalFromDepth(fragUv);\n    vec3 randomVec = sphereVolumeRandPoint();\n    vec3 tangent   = normalize(randomVec - normal * dot(randomVec, normal));\n    vec3 bitangent = cross(normal, tangent);\n    mat3 TBN       = mat3(tangent, bitangent, normal);\n    vec3 fragPos   = vec3(fragUv, sampleDepth(fragUv));\n    float occlusion = 0.0f;\n\tint index = SSAO_KERNEL_SIZE;\n    while(index-- > 0)\n    {\n        // get sample position\n        vec3 samplePos = TBN * sphereVolumeRandPoint(); // from tangent to view-space\n        samplePos = fragPos + samplePos * SSAO_RADIUS;  // \n        float sampleDepth = sampleDepth(samplePos.xy);  // get depth value of kernel sample\n        // range check & accumulate\n        float rangeCheck = smoothstep(0.0f, 1.0f, SSAO_RADIUS / abs(fragPos.z - sampleDepth));\n        occlusion += (sampleDepth >= samplePos.z + SSAO_BIAS ? 1.0f : 0.0f) * rangeCheck;           \n    }\n    return  max(0.0, 1.0 - (occlusion / float(SSAO_KERNEL_SIZE)));\n}\n\n// ----------------------------------------------------------------------------\n// SHADOWS\n// ----------------------------------------------------------------------------\nfloat softShadows(in vec2 fragCoord, in PointLight light)\n{\n\tvec2 fragUv   =  UV(fragCoord);\n    vec2 lightUv  =  UV(light.position.xy);\n    vec3 fragPos  =  vec3(fragUv,  sampleDepth(fragUv));\n    vec3 lightPos =  vec3(lightUv, sampleDepth(lightUv) + LIGHT_Z_OFFSET);\n    vec3 ligtDir  =  lightPos - fragPos;\n    float shadow  =  0.0f;\n\tfloat d_step  =  1.0f / float(SHADOW_SAMPLES - 1);\n\tfloat param   = -d_step;\n    // сканирование по направлению из источника света в пиксель\n    for(int step_index = 0; step_index < SHADOW_SAMPLES; ++step_index) {\n\t\tparam += d_step;\n        vec3  traversedPos   = fragPos + ligtDir * param;\n        float traversedDepth = sampleDepth(traversedPos.xy);\n        float diff = traversedPos.z - traversedDepth;\n        if (traversedPos.z < traversedDepth) shadow -= d_step * diff;\n    }\n    shadow *= SHADOW_INTENSITY / singlePointLight.radius;\n\treturn 1.0 - shadow;\n}\n\n// ----------------------------------------------------------------------------\n// IBL / PBR\n// ----------------------------------------------------------------------------\nvec3 PBR(in vec2 fragCoord)\n{\n\t// https://learnopengl.com/PBR/Lighting\n    vec2 fragUv   = UV(fragCoord); \n    vec3 normal   = sampleNormalFromDepth(fragUv);\n    vec3 viewDir  = vec3(0, 0, -1); // normalize(camPos - WorldPos);\n    vec3 worldPos = vec3(fragCoord.xy, sampleDepth(fragUv));\n    vec3 albedo   = gamma(surfaceMaterial.albedo);\n    vec3 reflectedDir = reflect(-viewDir, normal); \n    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 \n    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, surfaceMaterial.metalness);\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    // for(int i = 0; i < 4; ++i) // Single light source\n    {\n        // calculate per-light radiance\n        vec3 lightDir     = normalize(singlePointLight.position - worldPos);\n        vec3 halfwayDir   = normalize(lightDir + viewDir); \n        float dist        = length(singlePointLight.position - worldPos);\n        float attenuation = clamp(1.0 / singlePointLight.radius / singlePointLight.radius / (dist * dist), 0.0, 1.0);\n        vec3 radiance     = singlePointLight.color * attenuation;\n        // Cook-Torrance BRDF\n        float NDF = distributionGGX(normal, halfwayDir, surfaceMaterial.roughness);   \n        float G   = geometrySmith_PBR(normal, viewDir, lightDir, surfaceMaterial.roughness);      \n        vec3  F   = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n        vec3 numerator    = NDF * G * F; \n        float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * max(dot(normal, lightDir), 0.0) + 0.0001; // + 0.0001 to prevent divide by zero\n        vec3 specular     = numerator / denominator;\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals \n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - surfaceMaterial.metalness;\t  \n        // scale light by NdotL\n        float NdotL = max(dot(normal, lightDir), 0.0);        \n        // add to outgoing radiance Lo\n        Lo += (kD * albedo / PI + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }  \n\t\n\tvec3 F = fresnelSchlickRoughness(max(dot(normal, viewDir), 0.0), F0, surfaceMaterial.roughness);\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - surfaceMaterial.metalness;\t  \n    \n    vec3 irradiance = texture(ENVIRONMENT_MAP, normal).rgb;\n    vec3 diffuse    = irradiance * albedo;\n    \n    // sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.\n    vec3 prefilteredColor = textureLod(ENVIRONMENT_MAP, reflectedDir,  surfaceMaterial.roughness * MAX_REFLECTION_LOD).rgb;    \n    vec2 brdf  = texture(BRDF_LUT, vec2(max(dot(normal, viewDir), 0.0), surfaceMaterial.roughness)).rg;\n    vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);\n    \n    float ssao = gamma(screenSpaceAmbientOcclusion(fragCoord));\n    vec3  ambient = (kD * diffuse + specular) * ssao;\n    vec3  color = ambient + Lo;\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = inv_gamma(color); \n    return color;\n}\n\n// ----------------------------------------------------------------------------\n// Shader main function\n// ----------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tsetupMaterial(surfaceMaterial);\n    setupPointLight(singlePointLight);\n\tupdateLightPosition(singlePointLight);\n    float shadows = softShadows(fragCoord, singlePointLight);\n    vec3  color    = PBR(fragCoord);\n    fragColor = vec4(vec3(clamp(shadows, SHADOW_FACTOR, 1.0)) * color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ----------------------------------------------------------------------------\n// Common math\n// ----------------------------------------------------------------------------\n#define PI 3.14159265359\n// ----------------------------------------------------------------------------\n// Textures\n// ----------------------------------------------------------------------------\n#define DEPTH_TEXTURE   iChannel0\n#define ENVIRONMENT_MAP iChannel1\n// #define PREFILTER_MAP   iChannel2 <- mipmaps of ENVIRONMENT_MAP\n#define BRDF_LUT        iChannel2\n// ----------------------------------------------------------------------------\n// SSAO settings\n// ----------------------------------------------------------------------------\n#define SSAO_KERNEL_SIZE 64\n#define SSAO_RADIUS      0.02f\n#define SSAO_BIAS        0.01f\n// ----------------------------------------------------------------------------\n// Soft shadows settings\n// ----------------------------------------------------------------------------\n#define DEPTH_REVERSED      true\n#define DEPTH_SCALE         1.0f\n#define SOFT_SHADOWS        0.1f\n#define LIGHT_Z_OFFSET      0.3f\n#define SHADOW_INTENSITY    1.0f\n#define SHADOW_SAMPLES      32\n#define SHADOW_EPSILON      0.01f\n#define SHADOW_FACTOR       0.65f\n#define MINIMAL_LIGHT_SIZE  1e-5f\n#define MAIN_TEXTURE_TILING 1.333f\n// ----------------------------------------------------------------------------\n// Normals settings\n// ----------------------------------------------------------------------------\n#define NORMAL_STRENGTH  4.0f\n// ----------------------------------------------------------------------------\n// Macroses\n// ----------------------------------------------------------------------------\n// Compute uv's with saving image aspect ratio\n#define UV(uv)(MAIN_TEXTURE_TILING * vec2(uv.x / iResolution.y, uv.y / iResolution.y))  \n// ----------------------------------------------------------------------------\n// IBL\n// ----------------------------------------------------------------------------\n#define PBR_SAMPLE_COUNT    1024u\n#define GAMMA               2.2\n#define INV_GAMMA          (1.0/GAMMA)\n#define MAX_REFLECTION_LOD  4.0\n\n\n// chrome.exe --use-angle=gl\n#define ANGLE\n#ifdef ANGLE\n#define texture(a,b) textureLod(a,b,0.)\n#endif\n\n// ----------------------------------------------------------------------------\n// Gamma correction\n// ----------------------------------------------------------------------------\nvec3 gamma(vec3 col){\n\treturn pow(col, vec3(GAMMA));\n}\n\nvec3 inv_gamma(vec3 col){\n\treturn pow(col, vec3(INV_GAMMA));\n}\n\nfloat gamma(float col){\n\treturn pow(col, GAMMA);\n}\n\nfloat inv_gamma(float col){\n\treturn pow(col, INV_GAMMA);\n}\n\n// ----------------------------------------------------------------------------\n// Point light definition\n// ----------------------------------------------------------------------------\nstruct PointLight\n{\n    vec3  position; \n    vec3  color;\n    float radius;\n}singlePointLight;\n\n// ----------------------------------------------------------------------------\n// Material definition\n// ----------------------------------------------------------------------------\nstruct Material\n{\n    vec3  albedo;\n    float roughness;\n    float metalness;\n}surfaceMaterial;\n\n// ----------------------------------------------------------------------------\n// Point light default params setup function\n// ----------------------------------------------------------------------------\nvoid setupPointLight(inout PointLight light)\n{\n    light.position  = vec3(0.0f, 0.0f, 0.0f);\n    light.color     = vec3(1.0f, 1.0f, 1.0f);\n    light.radius    = 0.0333f;\n}\n\n// ----------------------------------------------------------------------------\n// Material default params setup function\n// ----------------------------------------------------------------------------\nvoid setupMaterial(inout Material material)\n{\n    material.albedo    = vec3(0.9f, 0.95f, 1.0f);\n    material.roughness = 0.5f;\n    material.metalness = 0.1f;\n}\n\n// ----------------------------------------------------------------------------\n// VS rand implementation. \n// Used in SSAO implementation.\n// ----------------------------------------------------------------------------\nint   RAND_SEED_VALUE = 1;\nvoid  srand(int s ) \n{\n\tRAND_SEED_VALUE = s; \n}\n\n// random int within range [-0xFFFF 0xFFFF];\nint   rand (void)\n{\n\tRAND_SEED_VALUE = RAND_SEED_VALUE * 0x343fd + 0x269ec3;\n\treturn (RAND_SEED_VALUE >> 16) & 32767;\n}\n\n// random float within range [-1.0f, 1.0f];\nfloat frand(void)\n{\n\treturn float(rand()) / 32767.0;\n}\n\n// ----------------------------------------------------------------------------\n// Random direction in oriented sphere.\n// Used in SSAO implementation.\n// ----------------------------------------------------------------------------\nvec3 sphereVolumeRandPoint()\n{\n    return normalize(vec3(frand(), frand(), frand())) * 2.0f - 1.0f;\n}\n\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\n// ----------------------------------------------------------------------------\nfloat vanDerCorpusCoeffs(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley(uint i, uint N)\n{\n\treturn vec2(float(i) / float(N), vanDerCorpusCoeffs(i));\n}\n\n// ----------------------------------------------------------------------------\n// IBL / PBR support functions\n// ----------------------------------------------------------------------------\nfloat distributionGGX(vec3 normal, vec3 H, float roughness)\n{\n    float roughness2 = roughness * roughness;\n    float roughness4 = roughness2 * roughness2;\n    float NdotH = max(dot(normal, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = roughness4;\n    float denom = (NdotH2 * (roughness4 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return nom / denom;\n}\n\n// ----------------------------------------------------------------------------\nfloat geometrySchlickGGX_BRDF(float nv, float roughness)\n{\n    float r = roughness;\n    float k = (r * r) / 2.0;\n    float nom   = nv;\n    float denom = nv * (1.0 - k) + k;\n    return nom / denom;\n}\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX_PBR(float nv, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float nom   = nv;\n    float denom = nv * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\n// ----------------------------------------------------------------------------\nfloat geometrySmith_BRDF(vec3 normal, vec3 viewDir, vec3 lightDir, float roughness)\n{\n    float nv = max(dot(normal, viewDir ), 0.0);\n    float nl = max(dot(normal, lightDir), 0.0);\n    float ggx2 = geometrySchlickGGX_BRDF(nv, roughness);\n    float ggx1 = geometrySchlickGGX_BRDF(nl, roughness);\n    return ggx1 * ggx2;\n}\n\n// ----------------------------------------------------------------------------\nfloat geometrySmith_PBR(vec3 normal, vec3 viewDir, vec3 lightDir, float roughness)\n{\n    float nv = max(dot(normal, viewDir ), 0.0);\n    float nl = max(dot(normal, lightDir), 0.0);\n    float ggx2 = GeometrySchlickGGX_PBR(nv, roughness);\n    float ggx1 = GeometrySchlickGGX_PBR(nl, roughness);\n    return ggx1 * ggx2;\n}\n\n// ----------------------------------------------------------------------------\nvec3 importanceSampleGGX(vec2 direction, vec3 normal, float roughness)\n{\n    float roughness2 = roughness * roughness;\n\t\n    float phi = 2.0 * PI * direction.x;\n    float cosTheta = sqrt((1.0 - direction.y) / (1.0 + (roughness2 * roughness2 - 1.0) * direction.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\n    // from spherical coordinates to cartesian coordinates\n    vec3 sphCoord;\n    sphCoord.x = cos(phi) * sinTheta;\n    sphCoord.y = sin(phi) * sinTheta;\n    sphCoord.z = cosTheta;\n\t\n    // from tangent-space vector to world-space sample vector\n    vec3 up  = abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0): vec3(1.0, 0.0, 0.0);\n    vec3 tg  = normalize(cross(up, normal));\n    vec3 btg = cross(normal, tg);\n\t\n    vec3 sampleVec = tg * sphCoord.x + btg * sphCoord.y + normal * sphCoord.z;\n    return normalize(sampleVec);\n}\n\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 f0)\n{\n    return f0 + (1.0 - f0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 f0, float roughness)\n{\n    return f0 + (max(vec3(1.0 - roughness), f0) - f0) * \n\t\t\t\t pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ----------------------------------------------------------------------------\n// BRDF texture compute\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// BRDF integration function\n// ----------------------------------------------------------------------------\nvec2 integrateBRDF(float nv, float roughness)\n{\n    vec3 viewDir;\n    viewDir.x = sqrt(max(1.0 - nv * nv, 0.0));\n    viewDir.y = 0.0;\n    viewDir.z = nv;\n\n    float a = 0.0;\n    float b = 0.0;\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n    for(uint index = 0u; index < PBR_SAMPLE_COUNT; ++index)\n    {\n        vec2 x = hammersley(index, PBR_SAMPLE_COUNT);\n        vec3 h = importanceSampleGGX(x, normal, roughness);\n        vec3 l = normalize(2.0 * dot(viewDir, h) * h - viewDir);\n\n        float nl = max(l.z, 0.0);\n        float nh = max(h.z, 0.0);\n        float vh = max(dot(viewDir, h), 0.0);\n\n        if(nl > 0.0)\n        {\n            float gSmith = geometrySmith_BRDF(normal, viewDir, l, roughness);\n            float gVis = (gSmith * vh) / (nh * nv);\n            float fc = pow(1.0 - vh, 5.0);\n            a += (1.0 - fc) * gVis;\n            b += fc * gVis;\n        }\n    }\n    a /= float(PBR_SAMPLE_COUNT);\n    b /= float(PBR_SAMPLE_COUNT);\n    return vec2(a, b);\n}\n\n// ----------------------------------------------------------------------------\n// Shader main function\n// ----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(integrateBRDF(uv.x, uv.y), 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}