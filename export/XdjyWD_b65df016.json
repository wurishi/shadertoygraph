{"ver":"0.1","info":{"id":"XdjyWD","date":"1492444871","viewed":3180,"name":"Hexagonal Blocks","username":"Shane","description":"Hexagonal surface tiling.","likes":65,"published":3,"flags":0,"usePreview":1,"tags":["raymarching","hexagon","block","overlap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tHexagonal Blocks\n\t----------------\n\n\tSome hexagonal surface tiling: It's been done many times before, and this is my take on it.\n\tI coded it off the top of my head, so I'd imagine there'd be more efficient methods out there. \n\tHaving said that, I tried to keep the operation count down to reasonable levels.\n\n\tAs anyone who's tried it can testify, it's impossible to draw repeat objects right up against\n\tone another - unless boundary tiling tricks are involved, or you take a voxelized approach. \n\tAt any rate, rendering overlapping objects on a plane definitely isn't possible with a one \n\tobject pass. The only way it appears possible to draw overlapping repeat objects on a 2D plane\n    is to take a brute-force approach and draw four objects, which is what I've done here. It seems \n\ta little wasteful, but drawing four hexagon pylons in a single pass isn't that great a challenge \n\tfor a modern GPU. Plus, I've managed to group some figures to minimize the instruction count.\n    By the way, technically, it's four objects on a square grid. With a simplex grid, you could get\n\taway with rendering three.\n\n\tThese objects are only touching, so technically not overlapping. However, the algorithm \n\tdoes allow for overlap - Uncomment OVERLAP, if you're curious. In fact, this is just a practice \n\trun for a more interesting overlapping example I'm working on.\n\n*/\n\n#define FAR 40. // Maximum ray distance.\n#define zRot 1./20. // XY plane rotation factor.\n\n// Overlapped version. Overlapping pylons wouldn't move, so movement's been disabled.\n//#define OVERLAP \n\n// Object (hexagonal pylon) ID, and it's associated random factor.\nvec4 vObjID, rndID;\n\n// Fabrice's consice, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Vec2 to float hash routine.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(41.97, 289.13)))*43758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    n = n = max(n*n - .2, 0.001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n// The individual objects. In this case, hexagonal pylons. \nfloat rObj(in vec3 q, in vec3 b){\n    \n    #if 1\n    q = abs(q);\n    return max(q.x - b.x, max(q.y*.866025 + q.z*.5 - b.y, q.z - b.z)); // Hexagonal pylon.\n    //return max(max(q.x - b.x, q.y - b.y), q.z - b.z); // Box shape.\n    #else\n    // More correct, more expensive distance field. The differences werent' that noticeable, \n    // so the cheaper one above it used.\n    q = abs(q);\n    q.yz = vec2(q.y*.866 + q.z*.5, q.z);\n    q -= b;\n    return max(min(max(q.y, q.z), 0.) + length(max(q.yz, 0.)), q.x);\n    //return min(max(max(q.x, q.y), q.z), 0.) + length(max(q, 0.));\n    #endif\n}\n\n// The distance function: Some hexagons rendered onto a couple of planes, with some spatial \n// contortion thrown in.\nfloat m(in vec3 p){\n    \n\t// XY plane rotation about the Z-axis. It's a very common raymarching move.\n    p.xy *= r2(p.z*zRot); \n\n    // YZ plane perturbation - just for a bit of variation.\n    p.x -= dot(sin(p*3.14159/4. - cos(p.zxy*3.14159/4.)), vec3(.2));\n    \n    \n\n    // Left and right YZ planes. Also a common raymarching move.\n    float signX = sign(p.x); // IDs which plane we're on. Used in the \"hash\" function.\n    p.x = signX*p.x - 2.; // Same as \"abs(p.x).\"  // abs(p.x) - .25;\n    \n\n    // The hexagonal surface.\n    //\n    p.yz /= 2.; // YZ-plane scaling.\n    \n    #ifdef OVERLAP\n    const float w = .3; // Hexagonal face width.\n    #else\n    const float w = .25; // Hexagonal face width.\n    #endif\n    \n\n    // Transformation factor: If you see the number \".866\" (sqrt(3)/2) inside a\n    // 2D vector, there'll be a good chance that something related to triangles \n    // or hexagons will be involved. It's based on boring high school math. :)\n    const vec2 c = vec2(.866025, 1);\n    \n    // Draw four hexagonal pylons (protruding from two walls). The two on the left\n    // are above and below one another, and the ones on the right are rendered in\n    // the same arrangement, but moved up by half a grid cell. For a visual, just \n    // look at a 2D hexagonal grid, or simply look at the example.\n    \n    // Setting up the positioning of the four shapes. Note the transformation\n    // factor also. These also serve as unique position IDs.\n    vec4 v12 = floor(vec4(p.yz, p.yz - vec2(0, .5))/c.xyxy);\n    vec4 v34 = floor(vec4(p.yz - vec2(.5, .25), p.yz - vec2(.5, .75))/c.xyxy);\n   \n    // Produce four unique random IDs from the positions above.\n    vec4 rnd = vec4(hash21(v12.xy + signX), hash21(v12.zw + vec2(0, .5) + signX), \n               \t\thash21(v34.xy + vec2(.5, .25) + signX), hash21(v34.zw + vec2(.5, .75) + signX));\n    \n    // Save the IDs, while they're still in the zero to one range. They'll be used\n    // to give the individual hexagonal pylons unique characteristics, like color\n    // and height.\n    rndID = rnd; // Range: [0, 1].\n    \n    #ifndef OVERLAP\n    // Animate the heights, using the standard hash animation trick.\n    rnd = sin(rnd*6.283 + iTime*(rnd + .5))*.5;\n    #endif\n    \n    \n    // Render the four hexagonal pylons in the arrangement described above.\n    // Note the inverse transformation factor.\n    vec4 n;\n\n    // Bottom left, bottom right, top left, top right. The random hights are\n    // passed in also.\n    //\n    // By the way, it's possible to to group a lot of the following into vector entities,\n    // etc, and cut down on \"min/max\" operations considerably, but it'd be at the expense\n    // of readability and changeability, so I've left it in this form.\n    n.x = rObj(p - vec3(rnd.x, (v12.xy + vec2(.5, .5))*c.xy), vec3(.5, w, w));\n    n.y = rObj(p - vec3(rnd.y, (v12.zw + vec2(.5, 1))*c.xy), vec3(.5, w, w));   \n    n.z = rObj(p - vec3(rnd.z, (v34.xy + vec2(1, .75))*c.xy), vec3(.5, w, w));\n    n.w = rObj(p - vec3(rnd.w, (v34.zw + vec2(1, 1.25))*c.xy), vec3(.5, w, w));\n \n    \n    // Save all the object IDs here - then sort them later. It's a little more complicated, \n    // but saves quite a few operations.\n    vObjID = n;\n \n    // Return the minimum of the contorted hexagon blocks above.\n    return min(min(n.x, n.y), min(n.z, n.w))*.75;\n \n\n \n}\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat shad(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 16; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0025*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<iter; i++){\n\n        float h = m(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .02, .2); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .3, 1.); \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n){\n\t\n    float sca = 5., occ = 0.;\n    for(float i=1.; i<6.; i++){\n    \n        float hr = i*.175/6.;        \n        float dd = m(p + n*hr);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n/*\n// Standard normal function.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\tm(p + e.yyx) - m(p - e.yyx)));\n}\n*/\n\n// Normal calculation, with some edging bundled in.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    // Edge spread of a few pixels, regardless of resolution.\n    vec2 e = vec2(6./iResolution.y, 0);\n\n\tfloat d1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\tfloat d3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\tfloat d5 = m(p + e.yyx), d6 = m(p - e.yyx);\n\tfloat d = m(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n    \n    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\td3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\td5 = m(p + e.yyx), d6 = m(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n\n// Minimum - with corresponding object ID.\nvec2 objMin(vec2 a, vec2 b){ \n    \n    // Returning the minimum distance along with the ID of the\n    // object. This is one way to do it. There are others.\n    \n    // Equivalent to: return a.x < b.x ? a: b; \n    float s = step(a.x, b.x);\n    return s*a + (1. - s)*b;\n}\n\n \n// Oldschool hatching effect: Interesting under the right circumstances. Without going into\n// too much detail, obtain the grey scale value of the pixel, then draw a series of crosses \n// depending on how light or dark the pixel is. Ligher parts of the image will have larger \n// crosses drawn, and darker ones will have additional smaller crosses drawn. The end result \n// is some crosshatching - albeit non organic, but still pretty cool.\n//\n// The idea has been around for years. I'm not sure who came up with the original, but this is\n// a generalized version of something I came across a while back.\nvec3 ch(in vec3 col, in vec2 p){\n    \n    float gr = dot(col, vec3(.299, .587, .114)); // Grey scale value.\n    \n    // Crosses. Right diagonal, plus a left diagonal.\n    //p *= r2(3.14159/8.); // + hash21(uv)*.002\n    float rgt = p.x + p.y; \n    float lft = p.x - p.y;\n    \n    const float levels = 3.;\n    const float iter = pow(2., levels) - 1.;\n        \n    // Choose these factors to suit the effect you're going for. I wanted low contrast.\n    // High contrast (col*4.) with darker hatching (col *= .5) will give it more of a \n    // traditional crosshatched feel.\n    vec3 fCol = col*1.5; col *= .7;\n    \n    float a = 2.; // Related to cross size.\n    \n    // Basically, the darker a pixel is, the more hatching lines it'll receive.\n    for(float i=1.; i<iter; i+=2.){\n\n        fCol = mix(fCol, mix(fCol, col, step(0., .5 - mod(lft, a))), step(gr, i/iter));\n        fCol = mix(fCol, mix(fCol, col, step(0., .5 - mod(rgt, a))), step(gr, (i + 1.)/iter));        \n        a *= 2.; // Increase the cross size factor.\n        \n    }\n    \n    return min(fCol, 1.);\n}\n\n \n\nvoid mainImage( out vec4 fc, in vec2 u )\n{\n    \n    // Unit direction vector with some \"fish eye\" lens distortion.\n    vec3 r = vec3(u - iResolution.xy*.5, iResolution.y*.75);\n    r = normalize(vec3(r.xy, sqrt(max(r.z*r.z - dot(r.xy, r.xy)*.5, 0.)) ));\n    \n    // Camera - or ray origin, plus a light vector.\n    vec3 o = vec3(0, 0, iTime*2.), l = o + vec3(0, 0, 4);\n \n    // A bit of camera rotation.\n    r.xy = r2(-o.z*zRot*2.)*r.xy;\n    r.xz = r2(cos(o.z*zRot*3.14159)/2.)*r.xz;\n    \n    // Raymarching loop.\n    float d, t = 0.;\n    \n    for(int i=0; i<128;i++){\n        \n        d = m(o + r*t);\n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n        //t += (1. - step(.5, d)*.25)*d;\n    }\n    \n    t = min(t, FAR); // Camera to surface distance.\n    \n    // Of the four rendered hexagonal pylons, use the global object distance vector\n    // to determine the closest. Ie; the ID of the pylon we've hit.\n    vec2 vObj = objMin(vec2(vObjID.x, 0.), vec2(vObjID.y, 1.));\n    vObj = objMin(vObj, objMin(vec2(vObjID.z, 2.), vec2(vObjID.w, 3.)));\n    \n    // Save the random ID vector here, or before the distance field function is called\n    // again for normal calculations, etc.\n    vec4 svRndID = rndID;\n    \n    // The object ID, which is an integer from zero to three inclusive.\n    //\n    // In regards to non constant integer array access: This is a WebGL 2 thing, and far more \n    // convenient than doing it the old way, which involved setting up a \"for\" loop. However, \n    // I'm at that age where I'm suspicious of new things, so if it gives anyone any trouble, \n    // feel free to let me know, and I'll make the appropriate changes. :)\n    int iObjID = int(vObj.y); \n    \n\n    // Initiate the scene color to zero.\n    vec3 col = vec3(0);\n    \n    \n    // If we hit the surface, light it up.\n    if(t<FAR){\n    \n        // Surface position and normal calculation.\n        float edge = 0.;\n        vec3 p = o + r*t, n = nr(p, edge);\n\n        // Shadows and occlusion.\n        float sh = shad(p + n*.005, l, 16., t);\n        float ao = cAO(p, n);        \n        \n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        \n\n\t\tfloat attn = 1./(1. + d*d*.25); // Attenuation - based on light-to-surface distance. \n        float diff = pow(max(dot(l, n), 0.), 1.); // Diffuse.\n        float spec = pow(max(dot(reflect(l, n), r), 0.), 8.); // Specular.\n        \n        // Texturing the object.\n        vec3 tP = p, tN = n;\n        \n        // Transforming the texture position to match the contortions in the distance function.\n        tP.xy *= r2(tP.z*zRot); // XY-plane rotation about Z.\n        tP.x -= dot(sin(tP*3.14159/4. - cos(tP.zxy*3.14159/4.)), vec3(.2)); // Perturbation.\n        #ifndef OVERLAP\n        // Moving the texture up and down with the pylons to match the distance function.\n        float hgt = sin(svRndID[iObjID]*6.283 + iTime*(svRndID[iObjID] + .5))*.5 + .5;\n        tP.x += -sign(tP.x)*hgt;\n        #endif\n \n        // Rotating the normal about the XY-plane to match the same in the distance function.\n        tN.xy *= r2(p.z*zRot);\n        \n\t\t// Surface texel.\n    \tvec3 tx = tex3D(iChannel0, tP/2., tN)*4.;\n    \ttx = mix(tx, vec3(1)*dot(tx, vec3(.299, .587, .114)), .5); // Toning down a little.\n \n        // Coloring some random pylons pink and blue, according to the individual IDs generated\n        // in the distance function.\n        if(svRndID[iObjID]>.9){\n            tx = mix(tx, tx*vec3(1, .2, .4)*2.5, .5);\n        }\n        else if(svRndID[iObjID]>.75) {\n            tx = mix(tx, tx*vec3(.2, .6, 1)*2.5, .5); \n\n        }\n\n\t\t// Combining the surface color with the other properties.\n        col = tx*(diff + ao*.75 + vec3(1, .6, .2)*spec);\n\n        col *= 1. - edge*.8; // Adding the dark edges.\n        \n        col *= ao*sh*attn; // Shading and attenuation.\n        \n        \n    }\n    \n    \n    // FOG\n    //\n    // Adding a bit of fog.\n    vec3 fog = vec3(1.3)*(-r.x*.5 + .5);\n    //fog = mix(fog, pow(vec3(1.5, 1, 1)*fog, vec3(1, 3, 16)), .15).zyx;\n    col = mix(col, fog, smoothstep(0., .99, t/FAR));\n    \n    \n    \n    // POSTPROCESSING\n    // \n    // The rendering was pretty basic, so I thought I'd try to make it look a little\n    // more artsy by throwing in some pretty cheap postprocessing effects. \n    \n    // A bit of sepia. I was in two minds as to whether I'd use it. I'm pretty sure \"col\" \n    // is always positive, but it's clamped for the Mac users, just in case. :)\n    col = mix(col, pow(max(col, 0.), vec3(1, 2, 10)), .25);\n \n  \n    // Rotated vertical and horizontal line overlay. \n    //vec2 u2 = u*r2(3.14159/6.);\n    //col *= .9 + .2*sin(u2.x*3.14159*450./8.);\n    //col *= .9 + .2*sin(u2.y*3.14159*450./8.);\n    \n    // Very basic crosshatching effect. Not realistic, but still artsy. I've mixed it in\n    // with the original to tone it down a little.\n    col = mix(col, ch(col, u), .75); \n    \n   \n    // Subtle vignette.\n    u /= iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125)*.5 + .5;\n    \n\n    // SCREEN PRESENTATION\n    //\n    // Approximate gamma correction.\n    fc = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n    \n}","name":"Image","description":"","type":"image"}]}