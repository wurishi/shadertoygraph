{"ver":"0.1","info":{"id":"MXfGRj","date":"1707671748","viewed":271,"name":"Voxel DDA Traversal Diagram","username":"chronos","description":"See Image tab comment for description :)\nClick and drag to draw ray.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["grid","tutorial","voxel","dda","cell","diagram","traversal","explainer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Voxel 'Digital Aifferential Analyzer' Traversal Diagram by chronos\n    \n    // Self: https://www.shadertoy.com/view/MXfGRj\n    \n    This shader is the result of me trying to figure out how the voxel traversing shaders on shadertoy work.\n    It didn't take me long to get the gist of it, and see how the various tricks worked for e.g branchless variants,\n    but the thing I struggled with was the part where it determines and keeps track of which direction to step.\n    It took me an embarrasingly long amount of time to feel like I had a rough handle on it, especially since I didn't find\n    any other shaders that really explained it. I'm sure they exist, but I haven't seen any yet :)\n    \n    So this is my attempt to document what I learned by working it out for myself,\n    and figured I may as well make it publicly available in case it helps anyone else.\n    The code and notes here are currently terribly messy. I'm sorry about that, but you get what you pay for :D\n    \n    \n    Yes, this is on a 2D grid but the method generalizes directly to 3D voxels ( or higher dimensions! )\n    \n    Observe that\n    - The voxel traversal pattern only steps in one of two directions at a time, e.g right & up\n      this is because a ray that starts in a cell only exits through one edge ( unless it's exactly on the corner )\n      \n    - From any cell you are currently in, it is safe to take a step the size of a voxel in the direction\n      of the next 'crossing edge'. This will land us in the next voxel to visit, at the same relative position in the cell,\n      without skipping over any cells or visiting them twice due to not moving far enough.\n    \n    - The direction of movement is axis aligned with the cell/voxel grid. In each case the direction is that of the normal vector of the \n      crossing edge / side.\n    \n    So now we just need to figure out which direction we should cross for each cell we visit,\n    so that we do not visit any cells that the ray doesn't intersect, and we do not skip any that it does intersect.\n    To that end, further observe that\n      \n    - The direction we should cross is the edge the ray first reaches. which is determined by how fast the ray travels in that direction\n      and how far it has to travel to reach that edge.\n      \n    - Since there are only two possible edges to choose from (3 in 3D), and we must take one of them,\n      the only thing that matters is which of the directions reaches the edge first, _not_ *when* they reach it.\n      \n    - If you step in an axis aligned direction (e.g X), you have not then accounted for any movement along the ray in the other direction (e.g Y).\n      We must take this into account so that we as closely as possible maintain the ratio dY/dX = (B.y - A.y)/(B.x - A.x), \n      where A is the starting point, and B is the end point.\n      \n    - The right triangle with corners A, B and (B.x, A.y) has sidelengths equal to the total distance we\n      must step in each axis aligned direction (X and Y), but it is not actually the total amount we need\n      for determining where to go next, but the ratio between them, which is dY/dX, meaning that\n      we don't need an endpoint at all, as long as we have the ratio of lengths of the ray direction \n      ( scaling a ray to be normalized does not change this ratio ).\n\n    Outline of approach:\n    \n    The initial predicate for determining whether we move in a direction becomes essentially this:\n    \n        is the \n            (distance to the edge)\n                divided by\n            (the speed in that direction)\n            \n          smaller than\n            \n            (distance to the other edge)\n                divided by\n            (the speed in the other direction)\n            \n            ?\n\n    But when we move in just one direction, we change the ratio dY/dX of distance traveled along each direction.\n    We must somehow compensate for this when stepping.\n    \n    Since we always end up in _the same relative location_ in the cell whenever we step,\n    the edge distances _do not change_ between steps.\n    \n    Therefore, we only need to initialize the stepping criterion with this offset once in the beginning,\n    and only update the stepping criterions by the direction ratio discrepancy at each step. (!)\n    \n    \n    We can find the initial edge distances for a unit-spaced grid size with edges at the integers by using \n        \n        fract(x) and fract(y) for the left and down directions\n        \n    and \n    \n        1.-fract(x) and 1.-fract(y) for the right and up directions\n        \n    \n    Another way to view the method is to scale the grid spacing by the projected ray speed so that the distance ratio becomes 1.\n\n    Yet one more thing to note is that uniform scaling of the grid does not change the ratios.\n\n    Note that there are still some cases I have not yet handled here for special cases where denominators can be zero or comparisons\n    have uncommon cases like equality, so be please be aware of that for any actual use!\n\n    // See \n    // https://en.wikipedia.org/wiki/Digital_differential_analyzer_(graphics_algorithm)\n    // https://www.shadertoy.com/view/4dX3zl by fb39ca4\n    // https://www.shadertoy.com/view/MtcGDH by fb39ca4\n    // https://www.shadertoy.com/view/4dfGzs by iq\n    \n    \n*/\n\n// This variable is a bit badly named, but I'm too lazy to come up with a better name heh\n// it is actually the number of grid cells per unit width and height in uv coordinates.\n// the unit size squares in UV coordinates are indicated in faint blue.\nconst float gridsize = 2.;\n\n// zoom out factor. This is also perhaps a bit badly named since it has a reciprocal relationship to what you would expect from the name :)\nconst float zoom = 2.;\n\n// Distance from line segment ab to point p\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\n// Axis Aligned Bounding Box check. Not necessary, but may be useful :)\nbool within_AABB(vec2 AABB_min, vec2 AABB_max, vec2 p)\n{\n    return (\n            all(greaterThanEqual(p, AABB_min))\n            &&\n            all(lessThanEqual(p, AABB_max))\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = zoom * (2. * fragCoord-iResolution.xy) / iResolution.y;\n    vec4 mouse = zoom * (2. * abs(iMouse)-iResolution.xyxy) / iResolution.y;\n    float ps = zoom * 2. / iResolution.y; // pixel size in uv coordinates\n\n    if(length(iMouse.xy) < 10.)\n    {\n        mouse.xy = vec2( .85,  .6) * zoom;\n        mouse.zw = vec2(-.85, -.6) * zoom;\n    }\n\n    vec3 color = vec3(.0125);\n    \n    vec2 uv_coord_borders = 0.1 * (pow(fract(uv), vec2(32.)) + pow(1.-fract(uv), vec2(32.)));\n    \n    color += max(uv_coord_borders.x, uv_coord_borders.y) * vec3(1,2,3)/3.;\n\n    vec2 p = uv * gridsize;\n\n    vec2 pf = fract(p);\n    vec2 pi = floor(p);\n    float p_ps = length(fwidth(p)) / sqrt(2.); // pixel size in p-coordinates.\n\n    float grid_thickness = 0.005;\n\n    vec2 gridax = max(smoothstep(1.-grid_thickness-p_ps, 1.-grid_thickness, pf), smoothstep(grid_thickness+p_ps, grid_thickness, pf));\n    float grid = max(gridax.x, gridax.y);\n\n    color = color = mix(color, vec3(0.5), grid);\n\n    vec2 vox_center = vec2(0.5);\n\n    // grid center dots\n    float d;\n    float a = smoothstep(p_ps, -p_ps, length(pf-vox_center) - 0.05);\n    color = mix(color, vec3(0.5), a);\n\n    // grid origin\n    color = mix(color, vec3(0), smoothstep(ps, -ps, length(uv)-0.06));\n    color = mix(color, vec3(1), smoothstep(ps, -ps, length(uv)-0.05));\n\n    // Start, end, and interpolated points\n    float t = fract(iTime * .25);\n    vec2 B = mouse.xy;\n    vec2 A = mouse.zw;\n    vec2 C = mix(A, B, t);\n    \n    vec2 rd = normalize(B-A); // Normalized ray direction\n    \n    float mousedotsize = .05;\n    \n    if(length(mouse.xy-mouse.zw) > 1e-7)\n    {\n        d = seg(mouse.xy, mouse.zw, uv) - mousedotsize/3.;\n        float s = dot(uv-A,B-A)/dot(B-A,B-A);\n        color = mix(color, mix(vec3(0.25, 1, 0.25), vec3(0, 0, 1), s), smoothstep(ps, -ps, d));\n    \n        d = length(uv-A)-mousedotsize;\n        color = mix(color, vec3(0.25, 1, 0.25), smoothstep(ps, -ps, d));\n\n        d = length(uv-B)-mousedotsize;\n        color = mix(color, vec3(0, 0, 1), smoothstep(ps, -ps, d));\n        \n        d = length(uv-C)-mousedotsize;\n        color = mix(color, vec3(1, 0, 0), smoothstep(ps, -ps, d));\n        \n        color += .025 * float(floor(C * gridsize) == pi) * vec3(1, 0, 0);\n        \n        d = seg(C, (floor(C*gridsize)+.5)/gridsize, uv) - mousedotsize/5.;\n        color = mix(color, vec3(1, 0, 1), smoothstep(ps, -ps, d));\n        \n        d = seg(A, vec2(B.x, A.y), uv) - mousedotsize/3.;\n        color = mix(color, vec3(1), .1 * smoothstep(ps, -ps, d));\n        \n        d = seg(vec2(B.x, A.y), B, uv) - mousedotsize/3.;\n        color = mix(color, vec3(1), .1 * smoothstep(ps, -ps, d));\n    }\n    \n    vec2 Ai = floor(A*gridsize) / gridsize;\n    vec2 Bi = floor(B*gridsize) / gridsize;\n\n    // Draw AABB\n        vec2 AABB_min = min(Ai, Bi);\n        vec2 AABB_max = max(Ai + 1./gridsize, Bi+1./gridsize);\n        d = 9e9;\n        d = min(d, seg(AABB_min, vec2(AABB_max.x, AABB_min.y), uv) - mousedotsize/5.);\n        d = min(d, seg(vec2(AABB_max.x, AABB_min.y), AABB_max, uv) - mousedotsize/5.);\n        d = min(d, seg(AABB_max, vec2(AABB_min.x, AABB_max.y), uv) - mousedotsize/5.);\n        d = min(d, seg(vec2(AABB_min.x, AABB_max.y), AABB_min, uv) - mousedotsize/5.);\n        d -= 0.01;\n        color = mix(color, vec3(0.01), smoothstep(ps, -ps, d));\n        color = mix(color, .5*vec3(0.1,1.,.5), smoothstep(ps, -ps, d));\n    \n    vec2 start_center = Ai + .5 / gridsize;\n    vec2 end_center   = Bi + .5 / gridsize;\n    \n    vec2 current_pos_center = start_center;\n    \n    d = length(uv-start_center)-mousedotsize;\n    color = mix(color, vec3(0,1,0), smoothstep(ps, -ps, d));\n    \n    d = length(uv-end_center)-mousedotsize;\n    color = mix(color, vec3(0,0,1), smoothstep(ps, -ps, d));\n    \n    vec2 rcp_rd = 1. / abs(rd);\n    vec2 sign_rd = sign(rd);\n            \n    vec2 xy = vec2(0);\n    \n    // Add distance to edge in relevant direction, and scale by projected (along edge normal) ray speed.\n    // Distance to edges are fract(A) and 1.-fract(A)\n    // Projected ray speed is rd.x and rd.y\n    // This can very obviously be simplified and compacted, but I think this is a bit clearer: (?)\n    // \n    // \n    if(sign_rd.x >= 0.)\n        xy.x += (1.-fract(A.x*gridsize)) / abs(rd.x);\n    if(sign_rd.y >= 0.)\n        xy.y += (1.-fract(A.y*gridsize)) / abs(rd.y);\n        \n    if(sign_rd.x < 0.)\n        xy.x += fract(A.x*gridsize) / abs(rd.x);\n    if(sign_rd.y < 0.)\n        xy.y += fract(A.y*gridsize) / abs(rd.y);\n    \n    // Draw seg from start cell center to ray origin.\n    {\n        d = seg(start_center, vec2(start_center.x, A.y), uv) - mousedotsize/3.;\n        color = mix(color, vec3(0, 0, 1), smoothstep(ps, -ps, d));\n        \n        d = seg(vec2(start_center.x,A.y), A, uv) - mousedotsize/3.;\n        color = mix(color, vec3(0, 0, 1), smoothstep(ps, -ps, d));\n    }\n    \n    \n    /*\n        The actual traversal logic!\n    */\n    \n    vec2 pos = A;\n    vec2 mask_total = vec2(0);\n    float max_steps = 100.;\n    for(float i = 0.; i < max_steps; i++)\n    { \n        if(!within_AABB(AABB_min, AABB_max, current_pos_center)) break;\n        \n        // Draw visited cell center\n        {\n            d = length(uv-current_pos_center)-mousedotsize/2.;\n            color = mix(color, vec3(0, 1, 1), smoothstep(ps, -ps, d));\n            color += .025 * float(floor(current_pos_center * gridsize) == pi);\n        }\n\n        vec2 mask = xy.x < xy.y ? vec2(1, 0) : vec2(0, 1);\n\n        xy += mask * rcp_rd;\n        \n        mask /= gridsize;\n        \n        mask_total += mask;\n        \n        current_pos_center = start_center + mask_total * sign_rd;\n\n        // Draw traversal step in alternating colors\n        {\n            d = seg(pos, pos + sign_rd * mask, uv) - mousedotsize/3.;\n            color = mix(color, vec3(0, 1.-mod(i, 2.),mod(i, 2.)), .25 * smoothstep(ps, -ps, d));\n            \n            pos += sign_rd * mask;\n        }\n    }\n    \n    color = pow(color, vec3(1. / 2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}