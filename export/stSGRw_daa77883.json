{"ver":"0.1","info":{"id":"stSGRw","date":"1623629348","viewed":235,"name":"Nonintersecting Convex Polygons","username":"pyBlob","description":"Finds the least distance one has to push boxes apart, so they don't intersect (or pull, so that they touch). Should generalize to arbitrary convex polygons. Can be further simplified for boxes due to symmetry,\n\nMouse: drag box 2","likes":8,"published":3,"flags":0,"usePreview":0,"tags":["collision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// find point x on box(p, b, r) that maximizes dot(x, n)\nvec2 support(vec2 p, vec2 b, mat2 r, vec2 n)\n{\n    return p + b * sign(r * n) * r;\n}\n\n// given a face with index (side, false) on box 1 or index (side, true) on box 2\n// how far do you have to push/pull the boxes, so that they definitely don't intersect\nvoid push1(\n    inout vec4 C, vec2 uv,\n    inout float d, inout vec2 normal, inout vec2 hit,\n    vec2 p1, vec2 b1, mat2 r1,\n    vec2 p2, vec2 b2, mat2 r2,\n    int side,\n    bool flip)\n{\n    if (flip)\n    {\n        swap(p1, p2);\n        swap(b1, b2);\n        swap(r1, r2);\n    }\n    const vec2[] sides = vec2[](vec2(-1,0),vec2(1,0),vec2(0,-1),vec2(0,1));\n    vec2 n = sides[side] * r1;\n    vec2 x = support(p2, b2, r2, -n);\n    vec2 y = support(p1, b1, r1, n);\n    d = dot(x - y, n);\n    normal = flip ? -n : n;\n    hit = flip ? y : x;\n    C = blend(C, vec4(.8,.2,0,1), abs(length(uv - y) - 6. * f));\n    C = blend(C, vec4(0,.5,0,1), abs(length(uv - x) - 10. * f));\n}\n\n// push boxes apart using the least distance traveled\nvoid push2(\n    inout vec4 C, vec2 uv,\n    inout float d, inout vec2 normal, inout vec2 hit,\n    vec2 p1, vec2 b1, mat2 r1,\n    vec2 p2, vec2 b2, mat2 r2)\n{\n    d = -10.;\n    vec4 c = vec4(0);\n    for (int j=0 ; j<2 ; ++j)\n    for (int i=0 ; i<4 ; ++i)\n    {\n        float di = -10.;\n        vec2 ni, hi;\n        vec4 ci = vec4(0);\n        push1(ci, uv, di, ni, hi, p1, b1, r1, p2, b2, r2, i, j == 0);\n        if (di > d)\n        {\n            d = di;\n            hit = hi;\n            normal = ni;\n            c = ci;\n        }\n    }\n    d = min(d, 0.); // only push, comment to pull\n    C = blend(C, c, 0.);\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    f = 1. / iResolution.y;\n    vec2 uv = (O - iResolution.xy / 2.) * f;\n\n    vec2 p1 = vec2(0);\n    vec2 b1 = vec2(.2, .1);\n    mat2 r1 = R(.2);\n\n    vec2 p2 = (iMouse.xy - iResolution.xy / 2.) * f;\n    vec2 b2 = vec2(.2, .1);\n    mat2 r2 = R(1.3);\n    \n    demo(p1, b1, r1, p2, b2, r2, iMouse, iTime);\n    \n    float d = 0.;\n    vec2 normal = vec2(0);\n    vec2 hit = vec2(0);\n    vec4 c = vec4(0);\n\n    // uncomment + edit exactly one\n    //push1(c, uv, d, normal, hit, p1, b1, r1, p2, b2, r2, 0, false);\n    //push1(c, uv, d, normal, hit, p1, b1, r1, p2, b2, r2, 2, true);\n    push2(c, uv, d, normal, hit, p1, b1, r1, p2, b2, r2);\n\n    C = vec4(0);\n    C = blend(C, c, 0.);\n    C = blend(C, vec4(1,0,0,1), arrow(uv, hit, hit - d * normal));\n    C = blend(C, vec4(1), abs(box(r1 * (uv - (p1 + d / 2. * normal)), b1)));\n    C = blend(C, vec4(1), abs(box(r2 * (uv - (p2 - d / 2. * normal)), b2)));\n    C = blend(C, vec4(0,0,1,1), abs(box(r1 * (uv - p1), b1)));\n    C = blend(C, vec4(0,0,1,1), abs(box(r2 * (uv - p2), b2)));\n    C = pow(C, vec4(.45));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = radians(180.);\n\nfloat box(vec2 p, vec2 b)\n{\n    // https://iquilezles.org/articles/distfunctions\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    b -= a;\n    p -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.));\n}\n\nfloat arrow(vec2 p, vec2 a, vec2 b)\n{\n    vec2 t = b - a;\n    vec2 n = vec2(-t.y, t.x);\n    float r = line(p, a, b);\n    r = min(r, line(p, b - .2 * t - .1 * n, b));\n    r = min(r, line(p, b - .2 * t + .1 * n, b));\n    return r;\n}\n\nmat2 R(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec4 blend(vec4 C, vec4 c)\n{\n    return C + c * (1. - C.w);\n}\n\nfloat f;\nvec4 blend(vec4 C, vec4 c, float r)\n{\n    return blend(C, c * smoothstep(f, 0., r));\n}\n\n#define mk_swap(t) \\\nvoid swap(inout t a, inout t b) \\\n{ \\\n    t tmp = a; \\\n    a = b; \\\n    b = tmp; \\\n}\n\nmk_swap(vec2)\nmk_swap(mat2)\n\nvoid demo(\n    inout vec2 p1, inout vec2 b1, inout mat2 r1,\n    inout vec2 p2, inout vec2 b2, inout mat2 r2,\n    vec4 iMouse, float iTime)\n{\n    if (iMouse.z == 0.)\n    {\n        float r = .12;\n        float a = iTime / 5.;\n        p1 = vec2(r,0) * R(a + radians(180.));\n        p2 = vec2(r,0) * R(a);\n        r1 = R(iTime / 7.);\n        r2 = R(-iTime / 3.);\n    }\n}\n","name":"Common","description":"","type":"common"}]}