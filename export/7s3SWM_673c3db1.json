{"ver":"0.1","info":{"id":"7s3SWM","date":"1633285675","viewed":147,"name":"Hexagon Math 2","username":"pdkl95","description":"Fun with hexagons.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 12.0\n#define FADESPEED 2.0\n\n#define EPSILON (0.001)\n#define EQUAL1(a,b) (((a - EPSILON) < b) && ((a + EPSILON) > b))\n#define EQUAL3(a,b) (EQUAL1(a.x, b.x) && EQUAL1(a.y, b.y) && EQUAL1(a.z, b.z))\n\nvec2 rec2hex(vec2 rec)\n{\n\tfloat temp = floor(rec.x + sqrt(3.0) * rec.y + 1.0);\n\tfloat q = floor((floor(2.0 * rec.x + 1.0) + temp) / 3.0);\n\tfloat r = floor((temp + floor(-rec.x + sqrt(3.0) * rec.y + 1.0)) / 3.0);\n\treturn vec2(q,r);\n}\n\nvec3 axial_to_cube(vec2 hex)\n{\n\treturn vec3(hex.x, hex.y, -hex.x-hex.y);\n}\n\nfloat hex_length(vec3 hex) {\n    return floor((abs(hex.x) + abs(hex.y) + abs(hex.z)) / 2.0);\n}\n\nfloat hex_distance(vec3 a, vec3 b) {\n    return hex_length(a - b);\n}\n\nvec3 hex_round(vec3 h) {\n    float q = floor(h.x);\n    float r = floor(h.y);\n    float s = floor(h.z);\n    float q_diff = abs(q - h.x);\n    float r_diff = abs(r - h.y);\n    float s_diff = abs(s - h.z);\n    if ((q_diff > r_diff) && (q_diff > s_diff)) {\n        q = -r - s;\n    } else if (r_diff > s_diff) {\n        r = -q - s;\n    } else {\n        s = -q - r;\n    }\n    return vec3 (q, r, s);\n}\n\nvec2 rotate(in vec2 point, in float rads)\n{\n\tfloat cs = cos(rads);\n\tfloat sn = sin(rads);\n\treturn point * mat2(cs, -sn, sn, cs);\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvec2 rand_loc(float i, float t)\n{\n\tfloat offset = i * 11.0;\n\tfloat seed = t + (offset * 200.0);\n\t\n\treturn vec2(snoise(vec2(seed, 11.0)),\n\t\t    snoise(vec2(seed, 88.765433)));\n\t\t    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 position = ((fragCoord.xy / iResolution.xy) * 2.0) - 1.0;\n\tposition.y *= iResolution.y/iResolution.x;\n\n\tfloat n = 7.0;\n\tvec2 pos = position * n;\n\t\n\tvec2 hpos = rec2hex(pos);\n\tvec3 orig_cube = axial_to_cube(hpos);\n\tvec3 orig_icube = hex_round(orig_cube);\n\n\tvec2 rhpos = rotate(hpos, iTime);\n\tvec3 cube = axial_to_cube(rhpos);\n\tvec3 h = abs(cube);\n\tfloat d = length(cube);\n\t\n\tvec3 color = vec3(0.0);\n\n\tcolor.rb = 1.0 - h.xz/n;\n\tfloat gfade = (cos(iTime) + 1.0) / 2.0;\n\tcolor.g = gfade * (1.0 - d/n);\n\t\n\tfloat bright = 0.0;\n\n\tfor (float i = 0.0; i < 1.0; i += (1.0/N)) {\n\t\tfloat t = iTime + i;\n\t\tfloat fadeiTime = t * FADESPEED;\n\t\tfloat stepiTime = floor(fadeiTime);\n\t\tfloat stepfract = fract(fadeiTime);\n\t\tfloat stepprog = sin(stepfract * 3.14159265);\n\t\tstepprog = stepprog * stepprog;\n\t\n\t\n\t\tvec2 loc = rand_loc(i, stepiTime);\n\t\tvec2 loc_axial = rec2hex(loc * n);\n\t\tvec3 loc_hex = axial_to_cube(loc_axial);\n\t\tvec3 loc_ihex = hex_round(loc_hex);\n\t\tif (EQUAL3(loc_ihex, orig_icube)) {\n\t\t\tbright += stepprog;\n\t\t}\n\t}\n\tfloat cbright = clamp(bright, 0.0, 1.0);\n\n#define R_SIZE  3.7\n#define R_MOD   1.0\n#define R_SPEED 1.666\n#define R_WIDE  1.3\n#define R_MARGIN (R_WIDE / 2.0)\n\n\tfloat r = R_SIZE + (R_MOD * sin(iTime * R_SPEED));\n\tif ((d > (r - R_MARGIN)) && (d < (r + R_MARGIN))) {\n\t\tvec3 grey = vec3((color.r + color.g + color.b) / 3.0);\n\t\tgrey *= 1.1;\n\t\tcolor = mix(grey, color, gfade);\n\t\t//color.rb /= 3.0;\n\t\t//color = vec3(0.0);\n\t}\n\t\n\tcolor += vec3(cbright);\n\n\tfragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}