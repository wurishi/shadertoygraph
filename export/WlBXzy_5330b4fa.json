{"ver":"0.1","info":{"id":"WlBXzy","date":"1566238604","viewed":568,"name":"3D blocks ","username":"ParaBellum","description":"Testing raycasting in 2D grid","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycasting","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AREA 60\n\nfloat r1D(float r)\n{\n    return fract(sin(r*12.43)*519803.43);\n}\n\nfloat rand(vec2 p)\n{\n  return fract(sin(dot(p,vec2(12.43,98.21)))*519803.43);\n}\n\nfloat map(vec2 v, float s, vec2 z)\n{\n    if (z.x >= 0. && z.y >= 0.)\n    {\n        v*=z;\n        v*=s;\n\t\treturn rand(floor(v));\n    }\n    if (z.x < 0. && z.y >= 0.)\n    {\n        v*=z;\n        v*=s;\n\t\treturn rand(vec2(ceil(v.x-1.), floor(v.y)));\n    }\n    if (z.x < 0. && z.y < 0.)\n    {\n        v*=z;\n        v*=s;\n\t\treturn rand(ceil(v-1.));\n    }\n    if (z.x >= 0. && z.y < 0.)\n    {\n        v*=z;\n        v*=s;\n\t\treturn rand(vec2(floor(v.x), ceil(v.y-1.)));\n    }\n}\n\nfloat grid2D(vec3 ro, vec3 rd, vec2 st)\n{\n    vec3 p;\n    vec3 u=ro;\n    \n    int j = 1;\n    for (int i=0;i<AREA;i+=0)\n    {\n        if (j > AREA)\n            break;\n        float h=0.;\n        if (rd.x != 0.)\n        {\n            p.x=floor(u.x)+1.;\n            h=(p.x-u.x)/rd.x;\n            p.y=h*rd.y+u.y;\n        }\n        else\tp.y=floor(u.y)+1.;\n        if (p.y>=floor(u.y)+1.)\n        {\n            p.y=floor(u.y)+1.;\n            h=(p.y-u.y)/rd.y;\n            p.x=h*rd.x+u.x;\n        }\n        else{j++;}\n        \n        float g=(p.x-u.x)/rd.x;\n        p.z=g*rd.z+u.z;\n        float t=map(u.xy,1.,sign(st))*abs(sin(iTime)*rand(floor(u.xy))+1.);\n        if (u.z<t)\n        {\n            return length(u-ro);\n            break;\n        }\n        if (p.z<t)\n        {\n            float z = p.z-t;\n            h=z/rd.z;\n            float x = h*rd.x;\n            h=x/rd.x;\n            float y = h*rd.y;\n            u = p-vec3(x,y,z);\n            return length(u-ro);\n        }\n        u=p;\n    }\n    return 0.;\n}\n\nvec3 normal(vec3 p, vec2 st)\n{\n    float d = length(p);\n    vec2 e = vec2(.01, 0.);\n   \tvec3 n = vec3(map(p.xy-e.xy,1.,sign(st))-map(p.xy+e.xy,1.,sign(st)),\n                  map(p.xy-e.yx,1.,sign(st))-map(p.xy+e.yx,1.,sign(st)),\n                  e.x);\n    return normalize(n);\n}\n\n#define B vec3(.6,.1,1.)\n#define G vec3(.6,1.,.1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 st=uv;\n    vec3 ro=vec3(0.,0.,10.);\n   \tvec3 rd=normalize(vec3(abs(st),-1.));\n    \n    vec3 col=vec3(0.);\n    \n    float d = grid2D(ro, rd, st);\n    vec3 p = ro+rd*d;\n    vec3 n = normal(p,st);\n    vec3 l = vec3(cos(iTime),sin(iTime),.25)*10.;\n    vec3 ld = normalize(l-p);\n    float diff = max(dot(ld,n),0.);\n    col += diff*p.z+(p.z+.1)*.1;\n    fragColor = vec4(sqrt(col*mix(B,G,p.z*1.5)), 0.);\n}","name":"Image","description":"","type":"image"}]}