{"ver":"0.1","info":{"id":"7ldyzj","date":"1660187167","viewed":104,"name":"Color Companions 2","username":"pb","description":"Click or Drag the Mouse!\n\nAnother version of Color Companions (https://www.shadertoy.com/view/flcyRB)  throwing a torus into the mix","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["mouse","torus","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\n\nfloat numOct  = 6. ;  //number of fbm octaves\nfloat focus = 0.;\nfloat focus2 = 0.;\nfloat tf = 0.;\n\n#define pi  3.14159265\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 1e6 );\n}\n\n\nfloat torus(vec3 p, vec2 axis) {\n    \n    vec2 q = vec2( length(p.xy) - axis.x, p.y);\n    return length(q) - axis.y;\n}\n\n\n//this is taken from Visions of Chaos shader \"Sample Noise 2D 4.glsl\"\nfloat noise(vec3 p) {\n    vec2 i = floor(p.yz);\n    vec2 f = fract(p.yz);\n    float a = random(i + vec2(0.,0.));\n    float b = random(i + vec2(1.,0.));\n    float c = random(i + vec2(0.,1.));\n    float d = random(i + vec2(1.,1.));\n    vec2 u = f*f*(3.-2.*f); //smoothstep here, it also looks good with u=f\n    \n    return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;\n\n}\n\nfloat fbm3d(vec3 p) {\n    float v = 0.;\n    float a = .5;\n    vec3 shift = vec3(focus - focus2);  //play with this\n    shift.z += .03*tf;\n    \n    float angle = pi/4.; //+ .001*focus; \n    float cc=cos(angle), ss=sin(angle);  \n    mat3 rot = mat3( cc,  0., ss, \n                      0., 1., 0.,\n                     -ss, 0., cc );\n    for (float i=0.; i<numOct; i++) {\n        v += a * noise(p);\n        p = rot * p * 2. + shift;\n        a *= .2*(1.+focus+focus2);  //changed from the usual .5\n ;\n    }\n    return v;\n}\n\nmat3 rxz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(cc,0.,-ss,\n                0.,1.,0.,\n                ss,0.,cc);                \n}\nmat3 ryz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(1.,0.,0.,\n                0.,cc,-ss,\n                0.,ss,cc);\n}                \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float coord_scale = 2.;\n    float tt = iTime / 8.;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mm = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    if ( iMouse.w == 0. ) mm.xy += vec2(1.,.5);\n\n    uv *= coord_scale;\n\n    vec3 rd = normalize( vec3(uv, -1.4) );  \n    vec3 ro = vec3(0.);\n    \n    float delta = pi/100.;\n    mat3 rot = rxz(-mm.x*delta) * ryz(-mm.y*delta);\n    \n    ro -= rot[2]*iTime/5.;\n    \n    vec3 p = ro + rot*rd;\n\n    \n    float ttt = 1.55;\n\n    //distance to torus\n    float td = torus( p - ro , vec2( 4.*cos(iTime/2.)*cos(ttt*5.),8.*sin(ttt*5.)) );\n\n    \n    mm *= coord_scale;\n    \n    focus = length(uv-mm);\n    focus = sqrt(focus);\n    focus = 2.5/(1.+focus/2.); \n\n    focus2 = length(uv+mm );\n    focus2 = 1./(1.+focus2*focus2);\n\n    tf = .1 * exp(-td);\n\n    \n    vec3 q;\n    q.x = fbm3d(p);\n    q.y = fbm3d(p.yzx);\n    q.z = fbm3d(p.zxy);\n\n    float f = fbm3d(p + q);\n    \n    vec3 cc = q;\n    cc *= 35.*f;\n    \n\n    cc.r += 2.*focus; cc.g+= 2.*focus; cc.b += 8.*focus2; cc.r-=4.*focus2;   \n    cc /= 10.;\n    cc /= (1.+.006*tf);\n    cc += .001*tf*vec3(.5,.2,1.);\n    \n    cc = 1. - exp(-cc*cc);\n    //cc = pow(cc, vec3(3.));  \n\n    fragColor = vec4(cc,1.0);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}