{"ver":"0.1","info":{"id":"7tGyD3","date":"1662318872","viewed":160,"name":"Karasik-trace test","username":"SID37","description":"Simple karasik ray-tracing test","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["volumetriclighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nstruct accumulator {\n    float power;\n    float intensity;\n};\n\nstruct context {\n    vec3 ray;\n    vec3 light;\n    vec3 u;\n    float i;\n    float u_len;\n};\n\n\n// ##########################################\n// ############### Primitives ###############\n// ##########################################\n\nvoid constant(in context ctx, inout accumulator acc, float c) {\n    acc.power += (ctx.i + ctx.u_len) * log(c);\n    acc.intensity *= c;\n}\n\nvoid wall_x(in context ctx, inout accumulator acc, float a, float k) {\n    float den = exp(k * (ctx.ray.x * ctx.i - a));\n    acc.power += (exp(-a * k) - den) / (k * ctx.ray.x);\n    acc.power += (exp(-k * (-ctx.light.x + a)) - den) * ctx.u_len / (k * ctx.u.x);\n    acc.intensity *= exp(-den);\n}\n\nvoid wall_z(in context ctx, inout accumulator acc, float a, float k) {\n    float den = exp(k * (ctx.ray.z * ctx.i - a));\n    acc.power += (exp(-a * k) - den) / (k * ctx.ray.z);\n    acc.power += (exp(-k * (-ctx.light.z + a)) - den) * ctx.u_len / (k * ctx.u.z);\n    acc.intensity *= exp(-den);\n}\n\nvoid wall_y(in context ctx, inout accumulator acc, float a, float k) {\n    float den = exp(k * (ctx.ray.y * ctx.i - a));\n    acc.power += (exp(-a * k) - den) / (k * ctx.ray.y);\n    acc.power += (exp(-k * (-ctx.light.y + a)) - den) * ctx.u_len / (k * ctx.u.y);\n    acc.intensity *= exp(-den);\n}\n\nfloat _sphere_power(vec3 sphere_pos, float r, float k, vec3 point, vec3 v, float v_len) {\n    vec3 d_light = sphere_pos - point;\n    float d = length(cross(d_light, v));\n    float a = dot(d_light, v);\n    float r_fake = (r >= d && a > 0.0) ? sqrt(r * r - d * d) : -10.0;\n\n    vec3 vec = 0.1 + vec3(1, 2, 3);\n\n    return (exp(k * (r_fake - a)) - exp(k * (r_fake + (v_len - a)))) / k;\n}\n\nvoid sphere(in context ctx, inout accumulator acc, vec3 pos, float r, float k) {\n    acc.power += _sphere_power(pos, r, k, ctx.light, normalize(ctx.u), ctx.u_len);\n    acc.power += _sphere_power(pos, r, k, vec3(0), ctx.ray, ctx.i);\n\n    float den = exp(-k * (length(ctx.ray * ctx.i - pos) - r));\n    acc.intensity *= exp(-den);\n}\n\n\n// ##########################################\n// ################# World ##################\n// ##########################################\n\naccumulator world(in context ctx) {\n    accumulator result = accumulator(0.0, 1.0);\n\n    constant(ctx, result, 0.9);\n    float wall_k = 100.0;\n    wall_x(ctx, result, 1.0, wall_k);\n    wall_x(ctx, result, -1.0, -wall_k);\n    wall_y(ctx, result, 1.0, wall_k);\n    wall_y(ctx, result, -1.0, -wall_k);\n    wall_z(ctx, result, 2.0, wall_k);\n    sphere(ctx, result, vec3(-0.3, -0.2, 1.5), 0.2, wall_k);\n    sphere(ctx, result, vec3(0.3, -0.7, 1.7), 0.1, wall_k);\n\n    return result;\n}\n\n\n// ##########################################\n// ################## Base ##################\n// ##########################################\n\nfloat process(vec3 ray, vec3 light) {\n    float delta = 0.03;\n    float len = 2.5;\n    context ctx;\n    ctx.ray = ray;\n    ctx.light = light;\n    float result = 0.0;\n    for (ctx.i = delta; ctx.i < len; ctx.i += delta) {\n        ctx.u = ctx.ray * ctx.i - ctx.light;\n        ctx.u_len = length(ctx.u);\n        accumulator acc = world(ctx);\n        result += delta * exp(acc.power) * (1.0 - acc.intensity) / (ctx.u_len * ctx.u_len);\n    }\n    return result;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ray = normalize(vec3(fragCoord + vec2(0.001, 0.001) - iResolution.xy / 2.0, iResolution.x / 2.2));\n    vec3 res = vec3(0.0);\n    // res += process(ray, vec3(0.1, -0.3, 1.5)) * vec3(0.3, 0, 1) * 0.1;\n    res += process(ray, vec3(cos(iTime) * 0.9, 0.5, 1.7)) * vec3(1, 0.7, 0.2) * 0.2;\n    // res += process(ray, vec3(sin(iTime / 1.0) * 0.5, -0.7, 1.5 + 0.5 *cos(iTime / 1.0))) * vec3(1, 0.7, 0.2) * 0.1;\n    // res += process(ray, vec3(sin(iTime / 1.0) * 0.5, 0.7, 1.5 - 0.5 *cos(iTime / 1.0))) * vec3(1, 0.7, 0.2) * 0.1;\n    fragColor = vec4(vec3(res * 10.0), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}